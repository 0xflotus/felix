@set_title("Extension Experiment")
@head(1,"Lexer")
A simple lexer.
@select(tangler("sex_lex.mll"))
{
open Sex_parse
let lexeme = Lexing.lexeme
let substr = String.sub
let len = String.length
}
(* special characters *)
let quote = '\''
let dquote = '"'
let slosh = '\\'
let linefeed = '\n'
let tab = '\t'
let space = ' '
let formfeed = '\012'
let vtab = '\011'
let carriage_return = '\013'
let underscore = '_'

(* character sets *)
let bindigit = ['0'-'1']
let octdigit = ['0'-'7']
let digit = ['0'-'9']
let hexdigit = digit | ['A'-'F'] | ['a'-'f']
let lower = ['a'-'z']
let upper = ['A'-'Z']
let letter = lower | upper
let hichar = ['\128'-'\255']
let white = space | tab

(* nasty: form control characters *)
let form_control = linefeed | carriage_return | vtab | formfeed
let newline_prefix = linefeed | carriage_return
let newline = formfeed | linefeed  | carriage_return linefeed
let hash = '#'

let lb = "("
let rb = ")"

let symchar =
  '!' | '$' | '%' | '&' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' |
  '`' | '{' | '|' | '}' | '~' | '#' | '\\'

let ordinary = letter | digit | hichar | symchar | lb | rb

let printable = ordinary | quote | dquote

let alphanum = letter | digit
let identifier = letter alphanum *
let integer = digit +
let sqstring = quote ordinary * quote
let dqstring = dquote ordinary * dquote
let string = sqstring | dqstring

let whitespace = (white | newline) +

rule sex_lex state = parse
| whitespace { sex_lex state lexbuf }
| identifier { ID (lexeme lexbuf) }
| string  { STR (lexeme lexbuf) }
| integer { INT (lexeme lexbuf) }
| lb { LB }
| rb { RB }
| symchar + { SYM (lexeme lexbuf) }
| eof { EOF }
| _ { failwith "lexing failed" }

{
}

@select(tangler("sex_parse.dyp"))
{
open Sex_types
}

%token LB
%token RB
%token EOF
%token <string> STR
%token <string> SYM
%token <string> ID
%token <string> INT

%start <Sex_types.sexp_t> sex_parse

%%

sex_parse: sexp EOF { $1 }

sexp:
  | INT { Int $1 }
  | STR { Str $1 }
  | SYM { Sym $1 }
  | ID  { Id $1 }
  | LB sexps RB { Lst $2 }

sexps:
  | sexp sexps { $1 :: $2 }
  | { [] }

@select(tangler("sex_types.ml"))
type sexp_t =
  | Int of string
  | Str of string
  | Sym of string
  | Id of string
  | Lst of sexp_t list

@select(tangler("sex_print.ml"))
open Sex_types
open List

let emit () = 
  let maxcol = 40 in
  let col = ref 0 in
  let newline () = print_endline ""; col := 0 in
  fun s ->
    let n = String.length s in
    if !col <> 0 && !col + n > maxcol then newline();
    if !col <> 0 then print_string " ";
    print_string s;
    col := !col + n + 1

let sex_print sex =
  let emit = emit () in
  let rec pr sex = match sex with
  | Int s
  | Sym s
  | Str s
  | Id s -> emit s
  | Lst sex -> emit "("; iter pr sex; emit ")"
  in 
  pr sex;
  print_endline ""

@select(tangler("sex_map.ml"))
open Sex_types
open List

let rec sex_map f (x:sexp_t): sexp_t = 
  match x with
  | Lst xs -> f (Lst (map (sex_map f) xs))
  | x -> f x

let rec subst fresh env x = 
  match x with
  | Lst [Id "lambda"; Id name; y] -> 
    let z = Id ("_" ^ string_of_int (fresh())) in
    Lst [Id "lambda"; z; subst fresh ((name,z)::env) y]

  | Id y as z -> (try assoc y env with Not_found -> z)
  | Lst xs -> Lst (map (subst fresh env) xs)
  | x -> x

let rec eval fresh env x = 
  (*
  print_string "Eval "; Sex_print.sex_print x;
  *)
  match x with
  | Lst [Id "apply"; f; arg] as term ->
    (*
    print_endline "Application = "; Sex_print.sex_print term;
    *)
    let f = subst fresh env f in
    let arg = subst fresh env arg in
    (*
    print_string "f = "; Sex_print.sex_print f; 
    print_string "a = "; Sex_print.sex_print arg; 
    *)
    begin match f with
    | Lst [Id "lambda"; Id name; body] ->
      let body = subst fresh ((name,arg)::env) body in
      (*
      print_string "body(after sub) = "; Sex_print.sex_print body;
      *)
      eval fresh env body

    | _ -> Lst [Id "apply"; f; arg]
    end

  | Lst [Id "letin"; Id name; y; body] ->
    let y = subst fresh env y in
    eval fresh ((name,y)::env) body

  | Lst [Id "defin"; Id name; y; body] ->
    eval fresh ((name,y)::env) body

  | Lst [Id "ifelse"; c; t; f] ->
    let c = eval fresh env c in
    let r = if c = Int "0" then f else t in
    (*
    print_string "After cond="; Sex_print.sex_print r;
    *)
    eval fresh env r

  | Lst (Sym "+" :: t) as x ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc + int_of_string y 
        | _ -> raise Not_found
      )
      0 t
      ))
    with Not_found -> x
    end

  | Lst (Sym "-" :: h :: t1 :: tt) as x ->
    let h = eval fresh env h in 
    begin match h with
    | Int h ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc - int_of_string y 
        | _ -> raise Not_found
      )
      (int_of_string h) (t1::tt)
      ))
    with Not_found -> x
    end
    | _ -> x
    end

  | Lst [Sym "-" ; Int s] ->
    Int (string_of_int (- (int_of_string s)))

  | Lst (Sym "*" :: h :: t) as x ->
    let h = eval fresh env h in 
    begin match h with
    | Int h ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc * int_of_string y 
        | _ -> raise Not_found
      )
      (int_of_string h) t
      ))
    with Not_found -> x
    end
    | _ -> x
    end
  | Id y as z -> (try assoc y env with Not_found -> z)
  | Lst xs -> Lst (map (eval fresh env) xs)
  | x -> x

@select(tangler("sex.ml"))
open Sex_types
open List

let main() =
  let mk_fresh () = 
    let counter = ref 0 in 
    fun x -> let y = !counter in incr counter; y
  in
  let fresh = mk_fresh () in
  let filename = Sys.argv.(1) in
  print_endline ("Processing " ^ filename);
  let file = open_in filename in
  let lexbuf = Lexing.from_channel file in
  let sexes = Sex_parse.sex_parse (Sex_lex.sex_lex 1) lexbuf in
  close_in file;

  let sex = match sexes with
  | (sex,_) :: _ -> sex
  | _ -> assert false (* ambiguous parse not expected! *)
  in
  Sex_print.sex_print sex;
  print_endline "Done"
  ;
  let sex = Sex_map.eval fresh [] sex in 
  print_endline "Evaluated:";
  Sex_print.sex_print sex

;;
main()
;;

@select(tangler("test.sex"))
(
  "Hello" fred 1 (2 3) (+ 30 (+ 6 4) 2)
  (lambda x (+ x x))
  (apply (lambda x (+ x x)) 42)
  (defin fact 
    (lambda x 
      (ifelse x 
        (* x (apply fact (- x 1)))
        1
      )
    )
    (apply fact 4)
  )
)

@select(tangler("Makefile"))
@srcs = [
   ('sex_types',''),
   ('sex_print',''),
   ('sex_map',''),
   ('sex_parse','-I ../../dypgen/dyplib'),
   ('sex_lex','-I ../../dypgen/dyplib'),
 ]
@#

all:
@tangle('\tpython ../../interscript/bin/iscr.py sex.pak')
@tangle('\tocamllex sex_lex.mll')
@tangle('\t../../bin/dypgen sex_parse.dyp')
@tangle('\trm sex_parse.mli')
@for src,flags in srcs:
  tangle('\tocamlopt '+flags+' -c '+src+'.ml')
@objs = ''
@for src,flags in srcs:
  objs = objs + src + '.cmx '
@tangle('\tocamlopt -a -o sex.cmxa '+objs)
@tangle('\tocamlopt -c sex.ml')
@tangle('\tocamlopt -o sex ../../dypgen/dyplib/dyplib.cmxa sex.cmxa sex.cmx')
clean:
@tangle('\trm -f *.a *.o *.cmi *.cmx *.cmxa *.ml *.mli *.dyp *.mll *.cache sex tmp.tmp *.sex')

test:
@tangle('\t./sex test.sex')

