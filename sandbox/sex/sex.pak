@set_title("Extension Experiment")
@head(1,"Lexer")
A simple lexer.
@select(tangler("sex_lex.mll"))
{
open Sex_parse
let lexeme = Lexing.lexeme
let substr = String.sub
let len = String.length
}
(* special characters *)
let quote = '\''
let dquote = '"'
let slosh = '\\'
let linefeed = '\n'
let tab = '\t'
let space = ' '
let formfeed = '\012'
let vtab = '\011'
let carriage_return = '\013'
let underscore = '_'

(* character sets *)
let bindigit = ['0'-'1']
let octdigit = ['0'-'7']
let digit = ['0'-'9']
let hexdigit = digit | ['A'-'F'] | ['a'-'f']
let lower = ['a'-'z']
let upper = ['A'-'Z']
let letter = lower | upper
let hichar = ['\128'-'\255']
let white = space | tab
let idletter = letter | underscore

(* nasty: form control characters *)
let form_control = linefeed | carriage_return | vtab | formfeed
let newline_prefix = linefeed | carriage_return
let newline = formfeed | linefeed  | carriage_return linefeed
let hash = '#'

let lb = "("
let rb = ")"

let symchar =
  '!' | '$' | '%' | '&' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' |
  '`' | '{' | '|' | '}' | '~' | '#' | '\\'

let ordinary = letter | digit | hichar | symchar | lb | rb

let printable = ordinary | quote | dquote

let alphanum = idletter | digit
let identifier = letter alphanum *
let integer = digit +
let sqstring = quote ordinary * quote
let dqstring = dquote ordinary * dquote
let string = sqstring | dqstring

let whitespace = (white | newline) +

rule sex_lex state = parse
| whitespace { sex_lex state lexbuf }
| identifier { ID (lexeme lexbuf) }
| string  { STR (lexeme lexbuf) }
| integer { INT (lexeme lexbuf) }
| lb { LB }
| rb { RB }
| symchar + { SYM (lexeme lexbuf) }
| eof { EOF }
| _ { failwith "lexing failed" }

{
}

@select(tangler("sex_parse.dyp"))
{
open Sex_types
}

%token LB
%token RB
%token EOF
%token <string> STR
%token <string> SYM
%token <string> ID
%token <string> INT

%start <Sex_types.sexp_t> sex_parse

%%

sex_parse: sexp EOF { $1 }

sexp:
  | INT { Int $1 }
  | STR { Str $1 }
  | SYM { Sym $1 }
  | ID  { Id $1 }
  | LB sexps RB { Lst $2 }

sexps:
  | sexp sexps { $1 :: $2 }
  | { [] }

@select(tangler("sex_types.ml"))
type sexp_t =
  | Int of string
  | Str of string
  | Sym of string
  | Id of string
  | Lst of sexp_t list

@select(tangler("sex_print.ml"))
open Sex_types
open List

let emit () = 
  let maxcol = 40 in
  let col = ref 0 in
  let newline () = print_endline ""; col := 0 in
  fun s ->
    let n = String.length s in
    if !col <> 0 && !col + n > maxcol then newline();
    if !col <> 0 then print_string " ";
    print_string s;
    col := !col + n + 1

let sex_print sex =
  let emit = emit () in
  let rec pr sex = match sex with
  | Int s
  | Sym s
  | Str s
  | Id s -> emit s
  | Lst sex -> emit "("; iter pr sex; emit ")"
  in 
  pr sex;
  print_endline ""

@select(tangler("sex_map.ml"))
open Sex_types
open List

let rec sex_map f (x:sexp_t): sexp_t = 
  match x with
  | Lst xs -> f (Lst (map (sex_map f) xs))
  | x -> f x

let rec subst fresh env x = 
  match x with
  | Lst [Id "lambda"; Id name; y] -> 
    let z = Id ("_" ^ string_of_int (fresh())) in
    Lst [Id "lambda"; z; subst fresh ((name,z)::env) y]

  | Id y as z -> (try assoc y env with Not_found -> z)
  | Lst xs -> Lst (map (subst fresh env) xs)
  | x -> x

let rec eval fresh env x = 
  (*
  print_string "Eval "; Sex_print.sex_print x;
  *)
  match x with
  | Lst [Id "apply"; f; arg] ->
    (*
    print_endline "Application = "; Sex_print.sex_print term;
    *)
    let f = subst fresh env f in
    let arg = subst fresh env arg in
    (*
    print_string "f = "; Sex_print.sex_print f; 
    print_string "a = "; Sex_print.sex_print arg; 
    *)
    begin match f with
    | Lst [Id "lambda"; Id name; body] ->
      let body = subst fresh ((name,arg)::env) body in
      (*
      print_string "body(after sub) = "; Sex_print.sex_print body;
      *)
      eval fresh env body

    | _ -> Lst [Id "apply"; f; arg]
    end

  | Lst [Id "letin"; Id name; y; body] ->
    let y = subst fresh env y in
    eval fresh ((name,y)::env) body

  | Lst [Id "defin"; Id name; y; body] ->
    eval fresh ((name,y)::env) body

  | Lst [Id "ifelse"; c; t; f] ->
    let c = eval fresh env c in
    let r = if c = Int "0" then f else t in
    (*
    print_string "After cond="; Sex_print.sex_print r;
    *)
    eval fresh env r

  | Lst (Sym "+" :: t) as x ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc + int_of_string y 
        | _ -> raise Not_found
      )
      0 t
      ))
    with Not_found -> x
    end

  | Lst (Sym "-" :: h :: t1 :: tt) as x ->
    let h = eval fresh env h in 
    begin match h with
    | Int h ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc - int_of_string y 
        | _ -> raise Not_found
      )
      (int_of_string h) (t1::tt)
      ))
    with Not_found -> x
    end
    | _ -> x
    end

  | Lst [Sym "-" ; Int s] ->
    Int (string_of_int (- (int_of_string s)))

  | Lst (Sym "*" :: h :: t) as x ->
    let h = eval fresh env h in 
    begin match h with
    | Int h ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc * int_of_string y 
        | _ -> raise Not_found
      )
      (int_of_string h) t
      ))
    with Not_found -> x
    end
    | _ -> x
    end
  | Id y as z -> (try assoc y env with Not_found -> z)
  | Lst xs -> Lst (map (eval fresh env) xs)
  | x -> x

@select(tangler("sex2flx.ml"))
open Sex_types
open Flx_ast
open Flx_types
open Flx_typing
open Flx_typing2
open List

exception Sex2FlxTypeError of string

let err s = raise (Sex2FlxTypeError s) 

let rec xexpr_t sr fresh env x = 
  let ex x = xexpr_t sr fresh env x in
  let xtype t = typecode_of_expr (ex t) in
  let ii i = int_of_string i in
  let ss s = String.sub s 1 (String.length s - 2) in
  let xq qn = qualified_name_of_expr (ex qn) in
  let xp x = xpattern_t sr fresh env x in
  match x with
 | Lst [] -> `AST_tuple (sr,[])
 | Lst [x] -> ex x
 | Lst [Id "AST_interpolate";  Str s] -> `AST_interpolate (sr,ss s)
 | Lst [Id "AST_vsprintf";  Str s] -> `AST_vsprintf (sr,ss s)
 | Lst [Id "AST_noexpand";  e] -> `AST_noexpand (sr,ex e)
 | Lst [Id "AST_name";  Str s ; Lst ts] -> `AST_name (sr,s,map xtype ts)

 | Lst [Id "AST_the";  e] -> `AST_the (sr, xq e)

 | Lst [Id "AST_index";  Str s ; Int i] -> `AST_index (sr,ss s,ii i)

 | Lst [Id "AST_case_tag";  Int i] -> `AST_case_tag (sr,ii i)

 | Lst [Id "AST_typed_case";  Int i; t] -> `AST_typed_case (sr,ii i,xtype t)
 | Lst [Id "AST_lookup";  Lst [e; Str s; Lst ts]] -> `AST_lookup (sr,(ex e, ss s,map xtype ts))
 | Lst [Id "AST_apply";  Lst [e1; e2]] -> `AST_apply(sr,(ex e1, ex e2))

 | Lst [Id "AST_tuple";  Lst es] -> `AST_tuple (sr,map ex es)
 | Lst [Id "AST_record";  Lst rs] -> 
   let rs = 
     map (function 
     | Lst [Str s; e] -> ss s, ex e 
     | _ -> err "Error in AST_record"
     ) 
     rs 
   in `AST_record (sr,rs)

 | Lst [Id "AST_record_type"; Lst rs] ->
   let rs = 
     map (function 
     | Lst [Str s; e] -> ss s, xtype e 
     | _ -> err "Error in AST_record_type"
     ) 
     rs 
   in `AST_record_type (sr,rs)

 | Lst [Id "AST_variant";  Lst [Str s;e]] -> `AST_variant (sr,(ss s, ex e))

 | Lst [Id "AST_variant_type"; Lst rs] ->
   let rs = 
     map (function 
     | Lst [Str s; e] -> ss s, xtype e 
     | _ -> err "Error in AST_variant_type"
     ) 
     rs 
   in `AST_variant_type (sr,rs)


 | Lst [Id "AST_arrayof";  Lst es] -> `AST_arrayof (sr, map ex es)
 | Lst [Id "AST_coercion";  e; t] ->  `AST_coercion (sr,(ex e, xtype t))

 | Lst [Id "AST_suffix";  Lst [qn;t]] -> `AST_suffix (sr,(xq qn,xtype t))

 | Lst [Id "AST_patvar";  Str s] -> `AST_patvar (sr, ss s)
 | Id "AST_patany" -> `AST_patany sr
 | Id "AST_void" -> `AST_void sr
 | Id "AST_ellipsis" -> `AST_ellipsis sr

 | Lst [Id "AST_product"; Lst es] -> `AST_product (sr, map ex es) 
 | Lst [Id "AST_sum";  Lst es] -> `AST_sum (sr,map ex es)
 | Lst [Id "AST_setintersection"; Lst es] -> `AST_setintersection (sr, map ex es)
 | Lst [Id "AST_setunion"; Lst es] -> `AST_setunion (sr, map ex es)
 | Lst [Id "AST_orlist"; Lst es] -> `AST_orlist (sr, map ex es)
 | Lst [Id "AST_andlist"; Lst es] -> `AST_andlist (sr, map ex es)
 | Lst [Id "AST_arrow";  Lst [e1; e2]] -> `AST_arrow (sr,(ex e1, ex e2))
 | Lst [Id "AST_longarrow";  Lst [e1; e2]] -> `AST_longarrow (sr,(ex e1, ex e2))
 | Lst [Id "AST_superscript";  Lst [e1; e2]] -> `AST_superscript (sr,(ex e1, ex e2))

(* 
 | Lst [Id "AST_literal";  * literal_t -> * literal_t
*)
 | Lst [Id "AST_deref"; e] -> `AST_deref (sr,ex e)
 | Lst [Id "AST_ref"; e] -> `AST_ref (sr,ex e)
 | Lst [Id "AST_new"; e] -> `AST_new (sr,ex e)
 | Lst [Id "AST_lvalue"; e] -> `AST_lvalue (sr,ex e)
 | Lst [Id "AST_callback";  qn] -> `AST_callback (sr,xq qn)
(*
 | Lst [Id "AST_method_apply";  * (id_t * expr_t * typecode_t list) -> * (id_t * expr_t * typecode_t list)
*)
 | Lst [Id "AST_dot";  Lst [e1; e2]] -> `AST_dot (sr,(ex e1, ex e2))
(*
 | Lst [Id "AST_lambda";  * (vs_list_t * params_t list * typecode_t * statement_t list) -> * (vs_list_t * params_t list * typecode_t * statement_t list)
*)
 | Lst [Id "AST_match_ctor";  Lst [qn; e]] -> `AST_match_ctor(sr,(xq qn,ex e))
 | Lst [Id "AST_match_case";  Lst [Int i; e]]-> `AST_match_case (sr,(ii i, ex e))

 | Lst [Id "AST_ctor_arg";  Lst [qn; e]] -> `AST_ctor_arg (sr,(xq qn, ex e))

 | Lst [Id "AST_case_arg"; Lst [Int i; e]] -> `AST_case_arg (sr,(ii i, ex e))

 | Lst [Id "AST_case_index";  e] -> `AST_case_index (sr, ex e)
 | Lst [Id "AST_letin";  Lst [p; e1; e2]] -> `AST_letin (sr,(xp p, ex e1, ex e2))

 | Lst [Id "AST_get_n";  Lst [Int i; e]] -> `AST_get_n(sr,(ii i, ex e))
 | Lst [Id "AST_get_named_variable";  Lst [Str s;e]]-> `AST_get_named_variable (sr, (ss s, ex e))

 | Lst [Id "AST_get_named_method";  Lst [Str s; Int i; Lst ts; e]] ->
   `AST_get_named_method (sr,(ss s, ii i, map xtype ts, ex e))

 | Lst [Id "AST_as";  Lst [e; Str s]] -> `AST_as (sr,(ex e, ss s))
(*
 | Lst [Id "AST_match";  * (expr_t * (pattern_t * expr_t) list) -> * (expr_t * (pattern_t * expr_t) list)
 | Lst [Id "AST_parse";  * expr_t * (range_srcref * production_t * expr_t) list -> * expr_t * (range_srcref * production_t * expr_t) list
 | Lst [Id "AST_sparse";  * expr_t * Str s * int list -> * expr_t * str s * int list

 | Lst [Id "AST_regmatch";  * (expr_t * expr_t * (regexp_t * expr_t) list) -> * (expr_t * expr_t * (regexp_t * expr_t) list)
 | Lst [Id "AST_string_regmatch";  * (expr_t * (regexp_t * expr_t) list) -> * (expr_t * (regexp_t * expr_t) list)
 | Lst [Id "AST_reglex";  * (expr_t * expr_t * (regexp_t * expr_t) list) -> * (expr_t * expr_t * (regexp_t * expr_t) list)
*)
 | Lst [Id "AST_typeof";  e] -> `AST_typeof (sr, ex e)
 | Lst [Id "AST_lift";  e] -> `AST_lift (sr,ex e)

 | Lst [Id "AST_cond";  Lst [e1;e2;e3]] -> `AST_cond (sr,(ex e1, ex e2, ex e3))

 | Lst [Id "AST_expr"; Str s; t] -> `AST_expr (sr, ss s, xtype t)

 | Lst [Id "AST_type_match";  Lst [t; Lst ts]] ->
   let ts = 
     map (function 
       | Lst [t1; t2] -> xtype t1, xtype t2 
       | _ -> err "AST_typematch typerrror"
     )
     ts
   in `AST_type_match (sr,(xtype t, ts))

 | Lst [Id "AST_macro_ctor";  Lst [Str s; e]] -> `AST_macro_ctor (sr,(ss s, ex e))

(*
 | Lst [Id "AST_macro_statements";  * statement_t list -> * statement_t list
*)
 | Lst [Id "AST_case";  Lst [e1; Lst ses; e2]] -> 
   let ses = 
     map (function 
       | Str s -> ss s 
       | _ -> err "AST_case type error") 
     ses 
   in
   `AST_case (sr, ex e1,ses,ex e2)
(*
 | Lst [Id "AST_user_expr";  * Str s * ast_term_t -> * str s * ast_term_t
*)

  | Id y -> `AST_name (sr,y,[])
  | Int i -> 
    let j = Big_int.big_int_of_string i in 
    `AST_literal (sr, `AST_int ("int",j))

  | x -> 
    print_endline "Invalid sex";
    Sex_print.sex_print x;
    raise Not_found

and xpattern_t sr fresh env x =
  let xp x = xpattern_t sr fresh env x in
  let ex x = xexpr_t sr fresh env x in
  let xtype t = typecode_of_expr (ex t) in
  let ii i = int_of_string i in
  let bi i = Big_int.big_int_of_string i in
  let ss s = String.sub s 1 (String.length s - 2) in
  let xq qn = qualified_name_of_expr (ex qn) in
  match x with
  | Id "PAT_nan" -> `PAT_nan sr
  | Id "PAT_none" -> `PAT_none sr

  (* constants *)
  | Lst [Id "PAT_int"; Str s; Int i] -> `PAT_int (sr,ss s, bi i)
  | Lst [Id "PAT_string"; Str s] -> `PAT_string (sr,ss s)

  (* ranges *)
  | Lst [Id "PAT_int_range"; Str s1; Int i1; Str s2; Int i2] ->
    `PAT_int_range (sr,ss s1, bi i1, ss s2, bi i2)

  | Lst [Id "PAT_string_range"; Str s1; Str s2] ->
    `PAT_string_range (sr,ss s1, ss s2)
(*  
  | `PAT_float_range of range_srcref * float_pat * float_pat 
*)
  (* other *)
  | Lst [Id "PAT_coercion"; p; t] ->
   `PAT_coercion (sr, xp p, xtype t)
  
  | Lst [Id "PAT_name"; Id x] -> `PAT_name (sr, x)
  | Lst [Id "PAT_tuple"; Lst ps] -> `PAT_tuple (sr, map xp ps)

  | Id "PAT_any" -> `PAT_any sr
(*
  | `PAT_regexp of range_srcref * string * id_t list 
*)  
  | Lst [Id "PAT_const_ctor"; qn] -> `PAT_const_ctor (sr, xq qn)
  | Lst [Id "PAT_nonconst_ctor"; qn; p] -> `PAT_nonconst_ctor (sr, xq qn, xp p)

  | Lst [Id "PAT_as"; p; Id s] -> `PAT_as (sr, xp p, s)
  | Lst [Id "PAT_when"; p; e] -> `PAT_when (sr, xp p, ex e)

  | Lst [Id "PAT_record"; Lst ips] -> 
    let ips = map (function
      | Lst [Id id; p] -> id,xp p
      | _ -> err "PAT_record syntax"
      )
      ips
    in
    `PAT_record (sr, ips)
  | x -> 
    print_endline "Invalid pattern sex";
    Sex_print.sex_print x;
    raise Not_found


@select(tangler("sex.ml"))
open Sex_types
open List

let main() =
  let mk_fresh () = 
    let counter = ref 0 in 
    fun x -> let y = !counter in incr counter; y
  in
  let fresh = mk_fresh () in
  let filename = Sys.argv.(1) in
  print_endline ("Processing " ^ filename);
  let file = open_in filename in
  let lexbuf = Lexing.from_channel file in
  let sexes = Sex_parse.sex_parse (Sex_lex.sex_lex 1) lexbuf in
  close_in file;

  let sex = match sexes with
  | (sex,_) :: _ -> sex
  | _ -> assert false (* ambiguous parse not expected! *)
  in
  Sex_print.sex_print sex;
  print_endline "Done"
  ;
  let sex = Sex_map.eval fresh [] sex in 
  print_endline "Evaluated:";
  Sex_print.sex_print sex
  ;

  let filename = "test2.sex" in
  print_endline ("Processing " ^ filename);
  let file = open_in filename in
  let lexbuf = Lexing.from_channel file in
  let sexes = Sex_parse.sex_parse (Sex_lex.sex_lex 1) lexbuf in
  close_in file;
  let sex = match sexes with
  | (sex,_) :: _ -> sex
  | _ -> assert false (* ambiguous parse not expected! *)
  in
  Sex_print.sex_print sex;
  let sr = "test2.sex",0,0,0,0 in
  let flxe : Flx_ast.expr_t = Sex2flx.xexpr_t sr 1 [] sex in
  print_endline ("e=" ^ Flx_print.string_of_expr flxe)
;;
main()
;;

@select(tangler("test2.sex"))
(
  AST_apply (add (AST_tuple (1 2)))
)
@select(tangler("test.sex"))
(
  "Hello" fred 1 (2 3) (+ 30 (+ 6 4) 2)
  (lambda x (+ x x))
  (apply (lambda x (+ x x)) 42)
  (defin fact 
    (lambda x 
      (ifelse x 
        (* x (apply fact (- x 1)))
        1
      )
    )
    (apply fact 4)
  )
)

@select(tangler("Makefile"))
@srcs = [
   ('sex_types',''),
   ('sex_print',''),
   ('sex_map',''),
   ('sex2flx','-I ../../src'),
   ('sex_parse','-I ../../dypgen/dyplib'),
   ('sex_lex','-I ../../dypgen/dyplib'),
 ]
@#

all:
@tangle('\tpython ../../interscript/bin/iscr.py sex.pak')
@tangle('\tocamllex sex_lex.mll')
@tangle('\t../../bin/dypgen sex_parse.dyp')
@tangle('\trm sex_parse.mli')
@for src,flags in srcs:
  tangle('\tocamlopt '+flags+' -c '+src+'.ml')
@objs = ''
@for src,flags in srcs:
  objs = objs + src + '.cmx '
@tangle('\tocamlopt -a -o sex.cmxa '+objs)
@tangle('\tocamlopt -I ../../src -c sex.ml')
@tangle('\tocamlopt -o sex nums.cmxa ../../dypgen/dyplib/dyplib.cmxa ../../src/flxlib.cmxa sex.cmxa sex.cmx')
clean:
@tangle('\trm -f *.a *.o *.cmi *.cmx *.cmxa *.ml *.mli *.dyp *.mll *.cache sex tmp.tmp *.sex')

test:
@tangle('\t./sex test.sex')

