// run with
// flx `pkg-config --cflags --libs gtk+-2.0` gpak

#import <flx.flxh>
include "pthread";
include "stl";

open Stl::Vector;
open Pthread;
open C_hack;

proc post_incr[t]: lvalue[ptr[t]] = "$1++;";

header '#include <glob.h>';
cstruct glob_t {
  gl_pathc: size;
  gl_pathv: ptr[charp];
  gl_offs: size;
};

proc glob: string * ptr[glob_t] = "::glob($1.data(),0,NULL,$2);";
proc globfree: ptr[glob_t] = "globfree($1);";

gen glob (pat:string): stl_vector[string] =
{
  var glob_data: glob_t; glob_data.gl_offs=0;
  glob(pat,addr glob_data);
  var n = glob_data.gl_pathc;
  var p = glob_data.gl_pathv;
  var pfile = *p;
  var files: stl_vector[string];
  whilst not isNULL(pfile) do
    var file = str(pfile);
    print file;
    push_back (files, file);
    p++;
    pfile = *p;
  done;
  globfree(addr glob_data);
  return files;
}


header '#include <gtk/gtk.h>';
header '#include <glib.h>';
header '#include <glib.h>';

// GLib
type GObject = "GObject*";
type GCallback = "GCallback";
type gpointer = "gpointer";

fun G_OBJECT[t]: t -> GObject = "G_OBJECT($1)";
fun G_CALLBACK[t]: t -> GCallback = "G_CALLBACK($1)";
proc g_print: string = "g_print($1.data());";

// GDK
type GdkEvent = "GdkEvent*";
const TRUE : bool = "TRUE";

// GTK
type GtkWidget = "GtkWidget*";
type GtkContainer = "GtkContainer*";
type GtkBox = "GtkBox*";
type GtkTable= "GtkTable*";
type GtkAdjustment = "GtkAdjustment*";
type GtkObject = "GtkObject*";

fun GTK_CONTAINER[t]: t -> GtkContainer = "GTK_CONTAINER($1)";
fun GTK_BOX[t]: t -> GtkBox = "GTK_BOX($1)";
fun GTK_TABLE[t]: t -> GtkTable = "GTK_TABLE($1)";
fun GTK_ADJUSTMENT[t]: t -> GtkAdjustment = "GTK_ADJUSTMENT($1)";

proc gtk_init: 1 = 'gtk_init(NULL,NULL);';
proc gtk_widget_show : GtkWidget = 'gtk_widget_show($1);';
proc gtk_main: 1 = 'gtk_main();';
proc gtk_main_quit : 1 = 'gtk_main_quit ();';

const GNULL : gpointer = "NULL";
proc g_signal_connect: GObject * charp * GCallback * gpointer;

// temporary wrapper, ignores widget
cproc gtkwrap ( w: GtkWidget, data: gpointer )
{
  var fp : cont = C_hack::cast[cont]data;
  Control::run fp;
}

proc signal_connect( w: GObject, sn: charp, var cls: 1 -> 0)
{
  g_signal_connect(w,sn,G_CALLBACK(the gtkwrap), C_hack::cast[gpointer]cls);
}

proc g_signal_connect_swapped: GObject * charp * GCallback * GObject;

proc gtk_container_set_border_width  : GtkContainer * int;

// Widgets
gen gtk_window_new: 1 -> GtkWidget ="gtk_window_new (GTK_WINDOW_TOPLEVEL)";
gen gtk_table_new: int * int * bool -> GtkWidget;
gen gtk_hbox_new: bool * int -> GtkWidget;
gen gtk_vbox_new: bool * int -> GtkWidget;
gen gtk_adjustment_new: double ^ 6 -> GtkObject;
gen gtk_vscrollbar_new: GtkAdjustment -> GtkWidget;
gen gtk_hscrollbar_new: GtkAdjustment -> GtkWidget;

gen gtk_button_new_with_label: string -> GtkWidget= 
  "gtk_button_new_with_label($1.data())"
;

fun gtk_adjustment_get_value: GtkAdjustment -> double;

proc gtk_container_add: GtkContainer * GtkWidget;
proc gtk_box_pack_start: GtkBox * GtkWidget * bool * bool * int;
proc gtk_table_attach_defaults: GtkTable * GtkWidget * int * int * int * int;

const gtk_widget_destroy: GCallback;

//-------------------------------------------------------

cfun delete_event ( 
  widget: GtkWidget, 
  event: GdkEvent, 
  data: gpointer 
) : bool =
{
    /* If you return FALSE in the "delete_event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    g_print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete_event". */

    return TRUE;
}

cproc destroy( widget : GtkWidget, data : gpointer )
{
    gtk_main_quit ();
}


cproc hello( widget: GtkWidget, data : gpointer)
{
    g_print ("Hello World\n");
}


gtk_init();
val window = gtk_window_new();

g_signal_connect (G_OBJECT(window), c"delete_event",G_CALLBACK(the delete_event), GNULL);
g_signal_connect (G_OBJECT(window), c"destroy",G_CALLBACK(the destroy), GNULL);

gtk_container_set_border_width (GTK_CONTAINER (window), 10);
var button = gtk_button_new_with_label ("Hello World");
g_signal_connect (G_OBJECT (button), c"clicked", G_CALLBACK (the hello), GNULL);

/* This will cause the window to be destroyed by calling
* gtk_widget_destroy(window) when "clicked".  Again, the destroy
* signal could come from here, or the window manager. */
g_signal_connect_swapped (G_OBJECT (button), c"clicked", G_CALLBACK (gtk_widget_destroy), G_OBJECT (window));

var topbox = gtk_vbox_new(false,4); // top level vbox
var stabbox = gtk_hbox_new(false,4); // scrolled table
var tabbox = gtk_vbox_new(false,4); // table

// make the table
var table = gtk_table_new(20,2,true);
var files = glob("lpsrc/*.pak");

open Reversible_Sequence[
  Stl::Vector::stl_vector[string], 
  Stl::Vector::stl_vector_iterator[string],
  Stl::Vector::stl_vector_reverse_iterator[string],
  string 
];


var i = 1;
var nfiles = 0;
var first = 0;
var depth = 20;
var p = begin files; whilst p != end files do
  var file = *p;
  print file; endl;
  if i >= first and i < first+depth do
    var buttonx = gtk_button_new_with_label(file);
    gtk_table_attach_defaults(GTK_TABLE(table),buttonx,0,1,i-1,i);
    gtk_widget_show(buttonx);
  done;
  ++p;
  ++i;
  ++nfiles;
done;    

// scroll bar for the table
var adj = gtk_adjustment_new(0.0,0.0,double(nfiles),1.0,5.0,20.0);
var bar = gtk_vscrollbar_new(GTK_ADJUSTMENT(adj));

/*
cproc set_scroll( widget : GtkWidget, data : gpointer ) 
{
  g_print ("Scrollbar moved\n");
}
*/

proc pslider () {
  val pos = gtk_adjustment_get_value$ GTK_ADJUSTMENT(adj);
  g_print$ f"Pos = %2.2f\n" pos;
}

signal_connect(G_OBJECT(adj),c"value_changed",the pslider);

// top button
gtk_box_pack_start(GTK_BOX(topbox),button,false,false,1);
gtk_widget_show(button);

// the table
gtk_box_pack_start(GTK_BOX(tabbox),table,false,false,1);
gtk_widget_show(table);

// scrolled table
gtk_box_pack_start(GTK_BOX(stabbox),tabbox,false,false,1);
gtk_widget_show(tabbox);
gtk_box_pack_start(GTK_BOX(stabbox),bar,false,false,1);
gtk_widget_show(bar);
gtk_widget_show(stabbox);
gtk_box_pack_start(GTK_BOX(topbox),stabbox,false,false,1);

// the client area
gtk_container_add(GTK_CONTAINER(window),topbox);
gtk_widget_show(topbox);
gtk_widget_show(window);

spawn_pthread { gtk_main(); };

print "GTK is running now!"; endl;

