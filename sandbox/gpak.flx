// run with
// flx `pkg-config --cflags --libs gtk+-2.0 gthread-2.0` gpak

#import <flx.flxh>
include "pthread";
include "stl";
include "glob";

open Stl::Vector;
open Pthread;
open C_hack;

proc post_incr[t]: lvalue[ptr[t]] = "$1++;";

// stat

header "#include <sys/types.h>";
header "#include <sys/stat.h>";
header "#include <unistd.h>";

type time_t = "time_t";
const eternity : time_t = "(time_t)-1";
const creation : time_t = "(time_t)0";
fun _ctor_int : time_t -> int = "(int)$1";

instance Eq[time_t] {
  fun eq: time_t * time_t -> bool = "$1==$2";
}


instance Tord[time_t] {
  fun native_less: time_t * time_t -> bool = "$1<$2";
  fun lt[with Eq[time_t]] (a: time_t, b:time_t):bool=>
    if a == eternity then false
    elif b == eternity then true
    else native_less (a,b)
    endif
  ;
}

open Tord[time_t];

type stat_t = "struct stat";
gen stat: string * ptr[stat_t] -> bool = "(stat($1.data(),$2)==0)";
fun modtime: ptr[stat_t] -> time_t = "$1->st_mtime";
gen filetime( f:string ) : time_t =
{
  var s: stat_t;
  return
    if stat (f, addr s) then
      modtime (addr s)
    else
      eternity
    endif
  ;
}

open Text_file;

gen get_manifest(pak:string): stl_vector[string] =
{
  var v : stl_vector[string];
  fn := "manifests/"+pak+".deps";
  //print$ "fn = " + fn; endl;
  f := fopen_input fn;
  if valid f do
    var line = strip$ readln f;
    //print line; endl;
    whilst line != "" do
      push_back (v,line);
      line = strip$ readln f;
    done;
  done;
  return v;
}

gen maxtime (v: stl_vector[string]): time_t =
{
  var p = begin v; e := end v;
  var t = creation;
  whilst p != e do
     fn := *p;
     tf := filetime fn;
     //print "Filetime '"; print fn; print "' "; print$ int tf; endl;
     t = max (t,tf);
     ++p;
  done;
  return t;
}

header '#include <gtk/gtk.h>';
header '#include <glib.h>';
header '#include <glib.h>';

// GLib
type GObject = "GObject*";
type GCallback = "GCallback";
type gpointer = "gpointer";

fun G_OBJECT[t]: t -> GObject = "G_OBJECT($1)";
fun G_CALLBACK[t]: t -> GCallback = "G_CALLBACK($1)";
proc g_print: string = "g_print($1.data());";

// GDK
type GdkEvent = "GdkEvent*";
const TRUE : bool = "TRUE";
cstruct GdkColor {
  pixel: uint32;
  red: uint16;
  green: uint16;
  blue: uint16;
};

nopix := 0u32;
bright := 65535u16;
dark := 0u16;

black := GdkColor(nopix,dark,dark,dark);
white := GdkColor(nopix,bright,bright,bright);
red := GdkColor(nopix,bright,dark,dark);
green:= GdkColor(nopix,dark,bright,dark);
blue := GdkColor(nopix,dark,dark,bright);
yellow := green + blue;

fun mul (a: GdkColor, x: double) =>
  GdkColor(
    nopix,
    cast[uint16](double(a.red) * x), 
    cast[uint16](double(a.green) * x), 
    cast[uint16](double(a.blue) * x)
  )
;
  
fun add (a: GdkColor, b: GdkColor) : GdkColor =>
  GdkColor (nopix,a.red + b.red, a.green + b.green, a.blue + b.blue)
;

type GtkStateType = "GtkStateType";

const GTK_STATE_NORMAL : GtkStateType;
const GTK_STATE_ACTIV : GtkStateType;
const GTK_STATE_PRELIGH : GtkStateType;
const GTK_STATE_SELECTE : GtkStateType;
const GTK_STATE_INSENSITI : GtkStateType;

// GTK
type GtkWindow = "GtkWindow*";
type GtkWidget = "GtkWidget*";
type GtkContainer = "GtkContainer*";
type GtkBox = "GtkBox*";
type GtkButton = "GtkButton*";
type GtkTable= "GtkTable*";
type GtkAdjustment = "GtkAdjustment*";
type GtkObject = "GtkObject*";
type GtkNotebook = "GtkNotebook*";
type GtkStyle = "GtkStyle*";
type GtkTextView= "GtkTextView*";
type GtkTextBuffer= "GtkTextBuffer*";
type GtkMenuShell= "GtkMenuShell*";
type GtkMenuItem= "GtkMenuItem*";

fun GTK_TEXT_VIEW[t]: t -> GtkTextView= "GTK_TEXT_VIEW($1)";
fun GTK_WINDOW[t]: t -> GtkWindow = "GTK_WINDOW($1)";
fun GTK_CONTAINER[t]: t -> GtkContainer = "GTK_CONTAINER($1)";
fun GTK_NOTEBOOK[t]: t -> GtkNotebook = "GTK_NOTEBOOK($1)";
fun GTK_BOX[t]: t -> GtkBox = "GTK_BOX($1)";
fun GTK_BUTTON[t]: t -> GtkButton = "GTK_BUTTON($1)";
fun GTK_TABLE[t]: t -> GtkTable = "GTK_TABLE($1)";
fun GTK_ADJUSTMENT[t]: t -> GtkAdjustment = "GTK_ADJUSTMENT($1)";
fun GTK_MENU_SHELL[t]: t -> GtkMenuShell = "GTK_MENU_SHELL($1)";
fun GTK_MENU_ITEM[t]: t -> GtkMenuItem = "GTK_MENU_ITEM($1)";

proc gtk_widget_destroy: GtkWidget;

proc g_thread_init: 1 = 'g_thread_init(NULL);';
proc gdk_threads_init: 1 = 'gdk_threads_init();';
proc gdk_threads_enter: 1 = 'gdk_threads_enter();';
proc gdk_threads_leave: 1 = 'gdk_threads_leave();';
proc gtk_init: 1 = 'gtk_init(NULL,NULL);';
proc gtk_widget_show : GtkWidget = 'gtk_widget_show($1);';
proc gtk_main: 1 = 'gtk_main();';
proc gtk_main_quit : 1 = 'gtk_main_quit ();';

const GNULL : gpointer = "NULL";
proc g_signal_connect: GObject * charp * GCallback * gpointer;

// temporary wrapper, ignores widget
cproc gtkwrap ( w: GtkWidget, data: gpointer )
{
  var fp : cont = C_hack::cast[cont]data;
  Control::run fp;
}

proc signal_connect( w: GObject, sn: charp, var cls: 1 -> 0)
{
  g_signal_connect(w,sn,G_CALLBACK(the gtkwrap), C_hack::cast[gpointer]cls);
}

proc g_signal_connect_swapped: GObject * charp * GCallback * GObject;

proc gtk_container_set_border_width  : GtkContainer * int;

// Widget constructors
gen gtk_window_new: 1 -> GtkWidget ="gtk_window_new (GTK_WINDOW_TOPLEVEL)";
gen gtk_scrolled_window_new: GtkAdjustment ^2 -> GtkWidget ="gtk_scrolled_window_new ($1,$2)";
gen gtk_table_new: int * int * bool -> GtkWidget;
gen gtk_hbox_new: bool * int -> GtkWidget;
gen gtk_vbox_new: bool * int -> GtkWidget;
gen gtk_adjustment_new: double ^ 6 -> GtkObject;
gen gtk_vscrollbar_new: GtkAdjustment -> GtkWidget;
gen gtk_hscrollbar_new: GtkAdjustment -> GtkWidget;
gen gtk_notebook_new: 1 -> GtkWidget;
gen gtk_label_new: string -> GtkWidget = "gtk_label_new($1.data())";
gen gtk_text_view_new : 1 -> GtkWidget;
gen gtk_button_new_with_label: string -> GtkWidget= 
  "gtk_button_new_with_label($1.data())"
;
gen gtk_menu_bar_new: 1 -> GtkWidget;
gen gtk_menu_new: 1 -> GtkWidget;
gen gtk_menu_item_new: 1 -> GtkWidget;
gen gtk_menu_item_new_with_label: string -> GtkWidget = 
  "gtk_menu_item_new_with_label($1.data())"
;


// operators
fun gtk_adjustment_get_value: GtkAdjustment -> double;

proc gtk_container_add: GtkContainer * GtkWidget;
proc gtk_container_remove: GtkContainer * GtkWidget;
proc gtk_box_pack_start: GtkBox * GtkWidget * bool * bool * int;
proc gtk_table_attach_defaults: GtkTable * GtkWidget * int * int * int * int;
proc gtk_button_set_alignment: GtkButton * double *double;
proc gtk_notebook_append_page: GtkNotebook * GtkWidget * GtkWidget;
proc gtk_window_set_title: GtkWindow * string = "gtk_window_set_title($1,$2.data());";
proc gtk_widget_modify_fg: GtkWidget * GtkStateType * ptr[GdkColor];
proc gtk_widget_modify_bg: GtkWidget * GtkStateType * ptr[GdkColor];
gen gtk_text_view_get_buffer: GtkTextView -> GtkTextBuffer;
proc gtk_text_buffer_set_text: GtkTextBuffer * string =
  "gtk_text_buffer_set_text($1,$2.data(),$2.size());"
;

proc gtk_menu_shell_append: GtkMenuShell * GtkWidget;
proc gtk_menu_item_set_submenu: GtkMenuItem * GtkWidget;

proc gtk_window_set_default_size: GtkWindow * int * int;

const gtk_widget_destroy_fun: GCallback = "G_CALLBACK(gtk_widget_destroy)";

//-------------------------------------------------------

cfun delete_event ( 
  widget: GtkWidget, 
  event: GdkEvent, 
  data: gpointer 
) : bool =
{
    /* If you return FALSE in the "delete_event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    g_print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete_event". */

    return TRUE;
}

cproc destroy( widget : GtkWidget, data : gpointer )
{
    gtk_main_quit ();
}


cproc hello( widget: GtkWidget, data : gpointer)
{
    g_print ("Hello World\n");
}


g_thread_init();
gdk_threads_init();
gtk_init();
val window = gtk_window_new();
gtk_window_set_title(GTK_WINDOW(window),"Felix Build Tool");

g_signal_connect (G_OBJECT(window), c"delete_event",G_CALLBACK(the delete_event), GNULL);
g_signal_connect (G_OBJECT(window), c"destroy",G_CALLBACK(the destroy), GNULL);

gtk_container_set_border_width (GTK_CONTAINER (window), 10);
var button = gtk_button_new_with_label ("QUIT");
g_signal_connect (G_OBJECT (button), c"clicked", G_CALLBACK (the hello), GNULL);

/* This will cause the window to be destroyed by calling
* gtk_widget_destroy(window) when "clicked".  Again, the destroy
* signal could come from here, or the window manager. */
g_signal_connect_swapped (G_OBJECT (button), c"clicked", gtk_widget_destroy_fun, G_OBJECT (window));

var topbox = gtk_vbox_new(false,4); // top level vbox
var notebook = gtk_notebook_new();
var stabbox = gtk_hbox_new(false,4); // scrolled table
var tabbox = gtk_vbox_new(false,4); // table

// make the table
var files = glob::glob("lpsrc/*.pak");

open Reversible_Sequence[
  Stl::Vector::stl_vector[string], 
  Stl::Vector::stl_vector_iterator[string],
  Stl::Vector::stl_vector_reverse_iterator[string],
  string 
];

// for a pak, the file manifests/pakname.deps records
// all the files on which the pak depends.
// The file manifests/pakname.log is a log of extraction
// and so records the extract date.
//
// If a pak file has no correpsonding manifest the button
// is coloured RED to indicate a manifest building extract
// is required. Ditto if there is no log file.
//
// Otherwise, if there is a log file is newer than
// all the dependencies, the button is coloured GREEN
// otherwise it is coloured yellow to indicate an 
// extract is required. For this purpose a missing dependency
// is considered very new, that is, it has 'maxtime' value.


var nfiles = 0;
var first = 0;
var depth = 20;

var initial = true;
var table : GtkWidget;

proc display_files() {
  var i = 1;
  nfiles = 0;
  if not initial do
    //gtk_container_remove(GTK_CONTAINER(tabbox),table);
    gtk_widget_destroy(table);
  done;
  initial = false;
  table = gtk_table_new(20,2,false);

  var p = begin files; whilst p != end files do
    var file = *p;
    pak := file.[6 to -4];
    if i >= first and i < first+depth do
      deps := get_manifest pak;
      change_time := maxtime deps;
      log_time := filetime$ "manifests/" + pak + ".log";
      //print$ f"%s %d Deps, change time %d, log time %d\n"$ cstr pak, len deps, int(change_time), int(log_time);
      var buttonx = gtk_button_new_with_label(pak);
      def var descr, var color = 
        if change_time > log_time then "CHANGED" , red
        elif log_time == eternity then "NOT EXTRACTED", yellow
        else "UP TO DATE", green
        endif
      ;
      var buttonx2 = gtk_button_new_with_label(descr);
      gtk_button_set_alignment(GTK_BUTTON(buttonx),0.0,0.7);
      gtk_widget_modify_bg(buttonx,GTK_STATE_NORMAL,addr color);
      signal_connect(G_OBJECT(buttonx),c"clicked",editfile file);
      gtk_button_set_alignment(GTK_BUTTON(buttonx2),0.0,0.7);
      gtk_table_attach_defaults(GTK_TABLE(table),buttonx,0,1,i-first,i-first+1);
      gtk_table_attach_defaults(GTK_TABLE(table),buttonx2,1,2,i-first,i-first+1);
      gtk_widget_show(buttonx);
      gtk_widget_show(buttonx2);
    done;
    ++p;
    ++i;
    ++nfiles;
  done;    
  // the table
  gtk_box_pack_start(GTK_BOX(tabbox),table,true,true,1);
  gtk_widget_show(table);
}

display_files;

// scroll bar for the table
var adj = gtk_adjustment_new(0.0,0.0,double(nfiles+1),1.0,5.0,20.0);
var bar = gtk_vscrollbar_new(GTK_ADJUSTMENT(adj));

proc pslider () {
  val pos = gtk_adjustment_get_value$ GTK_ADJUSTMENT(adj);
  //g_print$ f"Pos = %2.2f\n" pos;
  first = int(pos);
  display_files();
}

noinline proc editfile (var filename:string) () {
  print filename; endl;
  var data = Text_file::load filename;
  var view = gtk_text_view_new();
  var buffer = gtk_text_view_get_buffer (GTK_TEXT_VIEW (view));
  gtk_text_buffer_set_text (buffer, data);
  var swin = gtk_scrolled_window_new(cast[GtkAdjustment]0,cast[GtkAdjustment]0);
  gtk_container_add(GTK_CONTAINER(swin),view);
  var window = gtk_window_new();
  gtk_container_add(GTK_CONTAINER(window),swin);
  gtk_window_set_default_size(GTK_WINDOW(window),300,300);
  gtk_widget_show(view);
  gtk_widget_show(swin);
  gtk_widget_show(window);
  gtk_window_set_title(GTK_WINDOW(window),filename);
}

signal_connect(G_OBJECT(adj),c"value_changed",the pslider);

// top button
gtk_box_pack_start(GTK_BOX(topbox),button,false,false,1);
gtk_widget_show(button);

// scrolled table
gtk_box_pack_start(GTK_BOX(stabbox),tabbox,true,true,1);
gtk_widget_show(tabbox);
gtk_box_pack_start(GTK_BOX(stabbox),bar,true,true,1);
gtk_widget_show(bar);
gtk_widget_show(stabbox);

var tablabel = gtk_label_new("Paks");
gtk_widget_show(tablabel);
gtk_notebook_append_page(GTK_NOTEBOOK(notebook),stabbox,tablabel);

tablabel = gtk_label_new("spkgs");
gtk_widget_show(tablabel);
var unimp = gtk_label_new("not implemented");
gtk_widget_show(unimp);
gtk_notebook_append_page(GTK_NOTEBOOK(notebook),unimp,tablabel);

unimp = gtk_label_new("not implemented");
gtk_widget_show(unimp);
tablabel = gtk_label_new("cpkgs");
gtk_widget_show(tablabel);
gtk_notebook_append_page(GTK_NOTEBOOK(notebook),unimp,tablabel);
gtk_widget_show(notebook);

// menu
var menu = gtk_menu_new();
var item = gtk_menu_item_new_with_label("build");
gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
gtk_widget_show(item);
item = gtk_menu_item_new_with_label("quit");
gtk_menu_shell_append(GTK_MENU_SHELL(menu), item);
gtk_widget_show(item);
gtk_widget_show(menu);

var root_menu = gtk_menu_item_new_with_label("File");
gtk_widget_show(root_menu);
gtk_menu_item_set_submenu(GTK_MENU_ITEM(root_menu), menu);

var menubar = gtk_menu_bar_new();
gtk_menu_shell_append(GTK_MENU_SHELL(menubar), root_menu);
gtk_widget_show(menubar);
gtk_box_pack_start(GTK_BOX(topbox),menubar,false,false,2);

gtk_box_pack_start(GTK_BOX(topbox),notebook,true,true,1);

// the client area
gtk_container_add(GTK_CONTAINER(window),topbox);
gtk_widget_show(topbox);
gtk_widget_show(window);

spawn_pthread { 
  gdk_threads_enter();
  gtk_main(); 
  gdk_threads_leave();
};

print "GTK is running now!"; endl;

