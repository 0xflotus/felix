#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
import os
import sys
import glob
import shutil

# forward import of set
try:
  set
except NameError:
  from sets import Set as set

sys.path.append(
  os.path.join(os.path.dirname(sys.argv[0]), '..', 'lib')
)

os.environ['PYTHONPATH'] = os.pathsep.join([
  os.path.join(os.path.dirname(sys.argv[0]), '..', 'lib'),
  os.environ.get('PYTHONPATH', ''),
])

if '' not in sys.path: sys.path.insert(0, '')

import fbuild.flxbuild.flxutil
import fbuild.flxbuild.package
import fbuild.flxbuild.process

# ------------------------------------------------
# Load the initial config
# ------------------------------------------------

try:
  import config
except Exception:
  import traceback
  xt,xv,tb = sys.exc_info()
  print "ERROR IN config/__init__.py"
  traceback.print_exception(xt,xv,tb)
  print "You must either"
  print "(a) edit config/__init__.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

import fbuildroot

def load_options():
  from optparse import OptionParser, make_option

  parser = OptionParser()
  parser.add_options([
    make_option('-v', '--verbose',
      action='count',
      default=1,
      help='print out extra debugging info'),
    make_option('-q', '--quiet',
      action='count',
      default=0,
      help='do not print out extra debugging info'),
    make_option('--force',
      action='store_true',
      default=False,
      help='force running a process'),
    make_option('--phase', dest='selected_phases', metavar='PHASE',
      action='append',
      default=[],
      help='run only this phase of the build'),
    make_option('--pkg', dest='selected_packages', metavar='PKG',
      action='append',
      default=[],
      help='build only these packages'),
    make_option('--model', dest='selected_models', metavar='MODEL',
      action='append',
      default=[],
      help='build only the phases which can run on this platform'),
    make_option('--lparchive',
      metavar='PATH',
      help='use an alternative lpsrc directory'),
  ])

  try:
    extra_options = fbuildroot.options
  except AttributeError:
    pass
  else:
    option_group = parser.add_option_group('project options')
    option_group.add_options(extra_options)

  options, args = parser.parse_args()

  ####

  # temporary hack to set up the shell
  config.HOST_OCAML.verbose = options.verbose
  config.HOST_CC.verbose = options.verbose
  config.HOST_CXX.verbose = options.verbose
  config.TARGET_CC.verbose = options.verbose
  config.TARGET_CXX.verbose = options.verbose

  config.HOST_OCAML.quiet = options.quiet
  config.HOST_CC.quiet = options.quiet
  config.HOST_CXX.quiet = options.quiet
  config.TARGET_CC.quiet = options.quiet
  config.TARGET_CXX.quiet = options.quiet

  ####

  ####

  # if the user didn't say which phases to run
  # then run all the phases that use the host model
  # On building on Linux for MinGW, the build model
  # is linux, and the host model is mingw, the target
  # is win32. We'd be running all MinGW phases.
  # note a phase is named for the targetted product
  # NOT the machine that generates it. Thus host
  # phase mingw means 'compile on Linux for MingW'

  if not options.selected_phases and not options.selected_models:
    options.selected_models = [config.host_model]

  for model in options.selected_models:
    if model == config.build_model and 'build' not in options.selected_phases:
      options.selected_phases.append('build')

    if model == config.host_model and 'host' not in options.selected_phases:
      options.selected_phases.append('host')

    if model == config.target_model and 'target' not in options.selected_phases:
      options.selected_phases.append('target')

    if model == config.run_model and 'run' not in options.selected_phases:
      options.selected_phases.append('run')

  ####

  if options.lparchive:
    config.FLX_LPARCHIVE = options.lparchive

  return options, args


def initial_extraction(options, args):
  if "extract" not in args and "force_extract" not in args:
    return

  paks = glob.glob(os.path.join(config.FLX_LPARCHIVE, "lpsrc", "*.pak"))

  for p in paks:
    print "EXTRACTING", p, "from", config.FLX_LPARCHIVE
    if "force_extract" in args:
      cmd = (config.ISCR, '--force', '--break-on-error', p)
    else:
      cmd = (config.ISCR, '--break-on-error', p)

    fbuild.flxbuild.flxutil.execute(cmd,
      verbose=options.verbose,
      quiet=options.quiet,
    )

  # this is a hack
  fbuild.flxbuild.flxutil.mkdirs('speed')
  shutil.copy(os.path.join('misc', 'interscript.css'), 'speed')

  print "EXTRACTION COMPLETE"
  sys.exit(0)

# ----------------------------------------------------------------------------

def load_packages():
  pkgs = []
  unsorted_pkgs = []

  for i in glob.glob(os.path.join("spkgs", "*.py")):
    pkg = os.path.basename(os.path.splitext(i)[0])
    if pkg == '__init__':
      continue

    unsorted_pkgs.append(pkg)
    module = getattr(__import__('spkgs.' + pkg), pkg)
    d = {}
    for k, v in module.__dict__.iteritems():
      if k[0] != '_':
        d[k] = v
    fbuild.flxbuild.package.pkgd[pkg] = d

  def addpkg_r(pkg):
    if pkg not in pkgs:
      if pkg not in fbuild.flxbuild.package.pkgd.keys():
        print "Unknown package", pkg
        print "Please extract!"
        sys.exit(1)
      else:
        reqs = fbuild.flxbuild.package.pkgd[pkg].get('pkg_requires',[])
        fbuild.flxbuild.package.pkgreqs[pkg]=reqs
        for i in reqs:
          addpkg_r(i)
        pkgs.append(pkg)

  for pkg in unsorted_pkgs:
    addpkg_r(pkg)

  # invert the requirements in order to determine the dependencies
  fbuild.flxbuild.package.pkgdeps.update(
    fbuild.flxbuild.flxutil.invert(fbuild.flxbuild.package.pkgreqs))

  return pkgs

# -------------------------------------------------
# LOAD PROCESSES

def load_processes(options, args):
  for f in glob.glob(os.path.join(config.FLX_DIR, "fbuild", "lib", "fbuild", "mkplugins", "*.py")):
    name = os.path.basename(os.path.splitext(f)[0])
    if name == '__init__':
      continue

    module = getattr(__import__('fbuild.mkplugins.' + name).mkplugins, name)
    try:
      process_class = getattr(module, name)
    except AttributeError:
      pass
    else:
      process = process_class(
        verbose=options.verbose,
        quiet=options.quiet,
        optimise=options.optimise,
        debug=options.debug,
        force=options.force or 'force' in args,
        options=args,
      )
      fbuild.flxbuild.process.processes[name] = process

# -----------------------------------------------------------------------------

def calculate_packages(options, phase, packages):
  if options.selected_packages:
    selected_pkgs = options.selected_packages
  else:
    selected_pkgs = []
    max_len = max([len(s) for s in fbuild.flxbuild.package.pkgd])

    for pkg, pkgdict in fbuild.flxbuild.package.pkgd.iteritems():
      latest_src_time = fbuild.flxbuild.process.get_latest_src_time(pkgdict)

      stamp = os.path.join('pkg-stamps', '%s.%s' % (pkg, phase))
      latest_build_time = fbuild.flxbuild.flxutil.filetime(stamp)

      if latest_build_time == 0:
        print "Pak %s (virtual)" % pkg.ljust(max_len), 'UNBUILT'
        selected_pkgs.append(pkg)
      elif latest_build_time < latest_src_time:
        print "Pak %s changed: %s" % (
          pkg.ljust(max_len),
          fbuild.flxbuild.flxutil.fmtime(latest_src_time),
        )
        selected_pkgs.append(pkg)

  return [pkg for pkg in packages if pkg in selected_pkgs]

####

def run_phase(options, phase, packages):
  print '-' * 78
  print '***** MAKING PHASE', phase
  pkgsummary = {}
  for pkg in calculate_packages(options, phase, packages):
    pkgdict = fbuild.flxbuild.package.pkgd[pkg]
    print "*****", phase, "MAKING PACKAGE", pkg, "************"
    stamp = os.path.join("pkg-stamps", "%s.%s" % (pkg, phase))
    if os.path.exists(stamp):
        os.remove(stamp)

    for process in fbuildroot.fbuild_processes.get(phase, []):
      print "*****", phase, "RUNNING PROCESS", process, "************"
      result = fbuild.flxbuild.process.processes[process].runme(pkg, pkgdict, pkgsummary)
      if not result and result is not None:
        break
      else:
        fbuild.flxbuild.process.enstamp(stamp, options.quiet)

  if pkgsummary:
    pkgsummary = pkgsummary.items()
    pkgsummary.sort()
    print phase, "PHASE SUMMARY"
    for (package, process), summary in pkgsummary:
      print '  ', process.ljust(30), ':', package.ljust(30), ':', summary

# -----------------------------------------------------------------------------

def print_failures():
  # print out all the failed processes
  failure_log = fbuild.flxbuild.flxutil.Tee()

  failure_log.write("----- PROCESS STATUS -----\n")
  failed = 0
  fatal = 0
  for name, process in fbuild.flxbuild.process.processes.iteritems():
    nfail = len(process.failures)
    npass = len(process.successes)
    failed = failed or nfail>0
    fatal = fatal or (nfail>0 and not process.dummy)

    if nfail:
      print >> failure_log, 'PROCESS **FAILED**:', name,  nfail, '/', npass + nfail, 'failures'
      if process.dummy:
        print >> failure_log, "  [Expected failure, doesn't break build]"
    else:
      if process.used:
        print >> failure_log, 'PROCESS PASSED    :', name, npass, 'passed'
      else:
        print >> failure_log, 'PROCESS UNUSED    :', name

  if not failed:
    return False

  print '^^^^^^^^^^ FAILURES by group ^^^^^^^^^^^^^'

  kats = {}
  for name, process in fbuild.flxbuild.process.processes.iteritems():
    if not process.failures:
      continue

    print '- %s: %s' % (len(process.failures), name)

    lookup = {}

    for pkg, file, failure in process.failures:
      files = lookup.get(pkg, [])
      files.append(file)
      lookup[pkg] = files

    lookup = lookup.items()
    lookup.sort()

    for pkg, files in lookup:
      files.sort()

      print '  - %s: %s' % (len(files), pkg)
      lastfile = ""
      for file in files:
        if file == lastfile: continue
        lastfile = file
        # grab the first line of the file to see if it
        # has a #line number to print out as well, so we can
        # localize the error to the interscript file location

        emitted = 0
        f = open(file)
        eat = 1
        while eat == 1:
          try:
            line = f.readline()
          except:
            eat = 0
          if emitted == 0: fstring = file
          else: fstring = ""
          if emitted == 0 and line[0:5] == '#line':
            comment = line
          elif line [0:8] == "//Check ":
            kat = line[8:].strip()
            l = kats.get(kat,[])
            l.append(file)
            kats[kat]=l
            comment = kat
          else:
            if emitted == 0:
              comment = line
            else:
              comment = ""
            eat = 0
          if line != "":
            print '      %-35s %s' % (fstring, comment.strip())
            emitted = 1
        if emitted == 0:
          print '      %s' % file
        f.close()

  print '^^^^^^^^^^ FAILURES by category ^^^^^^^^^^'
  keys = kats.keys()
  keys.sort()
  for kat in keys:
    print kat+":"
    files = kats[kat]
    for file in files:
      print "  ",file

  f = open('errors.log', 'w')
  try:
    f.write(failure_log.getvalue())
  finally:
    f.close()

  return fatal

# -----------------------------------------------------------------------------

def main():
  # add the felix directory to the search paths
  sys.path.append(config.FLX_DIR)
  os.environ['PYTHONPATH'] = \
    config.FLX_DIR + os.pathsep + os.environ.get('PYTHONPATH', '')

  options, args = load_options()
  initial_extraction(options, args)
  packages = load_packages()
  load_processes(options, args)

  ####

  # run all the pre-processes
  for process in fbuildroot.fbuild_preprocesses:
    fbuild.flxbuild.process.processes[process].preprocess()

  # execute user selected processes in command line order
  for arg in args:
    # check in the build system stock process set
    # these are run independently of the selected phase
    if arg in fbuild.flxbuild.process.processes:
      fbuild.flxbuild.process.processes[arg].runme()

  # now run all the processes specified by the application
  # for the selected phases, in the application specified phase order
  for phase in options.selected_phases:
    run_phase(options, phase, packages)

  ####

  if print_failures():
    print "********* BUILD FAILED ********************"
    return 1
  else:
    print "*********** RUN COMPLETE: NO UNEXPECTED FAILURES DETECTED *******"

  return 0

if __name__ == '__main__':
  sys.exit(main())
