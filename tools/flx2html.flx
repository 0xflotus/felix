// Felix
module Flx2Html {
private val big_keywords = 
  "module",
  "cfun",
  "fun",
  "enum",
  "gen",
  "proc",
  "ctor",
  "type",
  "union",
  "struct",
  "typedef",
  "var",
  "val",
  "typeclass",
  "const",
  "instance",
  "header",
  "body",
  "include",
  "open",
  "spawn_fthread",
  "spawn_pthread",
  "reduce", "axiom", 
  "open", "inherit",
  "SCHEME","syntax","priority"
;
private val small_keywords =
  "if", "then", "else", "elif", "endif", "do", "done",
  "in", "forall", "while", "whilst","to", "upto","downto",
  "typematch","match","endmatch","with","requires","return","goto",
  "package"
;

private val qualifiers = 
  "virtual", "inline", "noinline", "private", "incomplete"
;
private val hack = "C_hack","C_hack"; // to make it an array we need 2 components


fun xlat_felix(t:string, dir:string)=
{
  var out = "";
  proc write_string(t:string) 
  { 
   out += t;
  }

  union state_t = 
    | sot // start of token
    | id // processing identifier
    | num // in a number
    | sq // processing single quote string
    | dq // processing double quote string
    | sq3 // processing single quote string
    | dq3 // processing double quote string
    | ccomment // a C style comment
    | cppcomment // a C++ style comment
  ;
  fun str(s:state_t) => match s with
  | sot => "sot"
  | id => "id"
  | num => "num"
  | sq => "sq"
  | dq => "dq"
  | sq3 => "sq3"
  | dq3 => "dq3"
  | ccomment=> "ccomment"
  | cppcomment => "cppcomment"
  endmatch;
  
  var i = 0; var s:state_t;
  var ch = t.[i];
  proc next() { ch = t.[i]; ++i; }
  fun ahead (j:int)=> t.[i+j-1]; 
  fun issq3() => 
    ch == char "'" and 
    ahead(1) == char "'" and
    ahead(2) == char "'" 
  ;
  fun isdq3() => 
    ch == char '"'  and
    ahead(1) == char '"' and
    ahead(2) == char '"' 
  ;

  var b = "";
  var last_id = "";
  var last_op = "";
  var last_key = "";

  proc cp() { b += ch; }
  fun fixup(x:string):string={
    var out2 = "";
    var i:int;
    forall i in 0 upto len x-1 do
      var ch = x.[i];
      if ch == char "<" do out2+="&lt;";
      elif ch == char ">" do out2+="&gt;";
      elif ch == char "&" do out2+="&amp;";
      else out2+=ch;
      done
    done
    return out2;
  }

  proc ws() {
    if last_id == "include" do // hackery
      var n = b; 
      whilst n.[0] == char "'" or n.[0] == char '"' do n = n.[1 to]; done
      whilst n.[-1] == char "'" or n.[-1] == char '"' do n = n.[to -1]; done
      if n.[-4 to] != ".flx" do n+= ".flx"; done // hack, fixme
      match get_file(n,FLX_PATH) with
      | Some ?f => { write_string('<a href="/$'+f+'" >' + b + '</a>') ; }
      | None => {  write_string('<span class="fstring">'+fixup b+"</span>"); }
      endmatch;
    elif last_key in ("header","body") do
      n = b; 
      var quote = '"""';
      if prefix(b,quote) do n = b.[3 to -3]; goto unstring; done
      quote = "'''"; 
      if prefix(b,quote) do n = b.[3 to -3]; goto unstring; done
      quote = "'"; 
      if prefix(b,quote) do n = b.[1 to -1]; goto unstring; done
      quote = '"'; 
      if prefix(b,quote) do n = b.[1 to -1]; goto unstring; done
      // shouldn't happen ..
unstring:>
      val c = Cpp2Html::xlat_cpp (n,dir);
      write_string(quote+'<span class="embedded_c">' + c + '</span>'+quote); 
    elif last_key == "package" do
       println$ "Package: " + b;
       n = b;
      whilst n.[0] == char "'" or n.[0] == char '"' do n = n.[1 to]; done
      whilst n.[-1] == char "'" or n.[-1] == char '"' do n = n.[to -1]; done
      n+=".fpc";
println$ "Package file basename is " + n;
      match get_file(n,FLX_PKGCONFIG_PATH) with
      | Some ?f => { write_string('<a href="/$'+f+'" >' + fixup b + '</a>') ; }
      | None => { 
          println$ "Can't find "+n+" in path " + str FLX_PKGCONFIG_PATH;   
          write_string('<span class="fstring">'+fixup b+"</span>"); 
        }
      endmatch;
    else 
     write_string('<span class="fstring">'+fixup b+"</span>"); 
    done
  }
  proc w() { 
    //println$ "Token["+str s+"]="+b; 
    match s with 
    | dq => { ws; }
    | sq => { ws; }
    | sq3 => { ws; }
    | dq3 => { ws; }
    | ccomment=> { write_string('<span class="comment">'+b+"</span>"); }
    | cppcomment=> { write_string('<span class="comment">'+b+"</span>"); }
    | id => 
      { 
        last_id = b;
        if b in big_keywords do last_key=b; write_string('<span class="big_keyword">'+b+"</span>"); 
        elif b in small_keywords do last_key=b; write_string('<span class="small_keyword">'+b+"</span>"); 
        elif b in qualifiers do write_string('<span class="qualifier">'+b+"</span>"); 
        elif b in hack do write_string('<span class="hack">'+b+"</span>"); 
        else write_string(b); done
      }
    | _ =>
      { 
        last_op=b; 
        if b == ";" do last_key = ""; done
        if b == "<" do b = "&lt;";
        elif b == ">" do b = "&gt;";
        elif b == "&" do b = "&amp;";
        done;
        write_string(b);  
      }
    endmatch;
    b = "";  
  }


  goto nextt;

contin:> // copy char and continue
  cp();
  goto nextch;
   
overrun:> // one past last char of token
  w();
  s = sot;
  goto thisch;

lastch:> // last char of token
  cp();
  w();

nextt:>  // new token on next char
  s = sot;

nextch:> // next char
  next();

thisch:> // same char, reconsider it
  //println$ "Considering char " + str(ord(ch));
  if isnull ch goto fin; // out of data
  match s with 
  | sot =>
    { 
      if isidstart ch do s = id; goto contin;
      elif isdigit ch do s = num; goto contin;
      elif issq3() do cp; next; cp; next; s = sq3; goto contin;
      elif isdq3() do cp; next; cp; next; s = dq3; goto contin;
      elif issq ch do s = sq; goto contin;
      elif isdq ch do s = dq; goto contin;
      elif ch == char "/" do
        if ahead(1) == char "/" do cp; next; s = cppcomment; goto contin
        elif ahead(1) == char "*" do cp; next; s = ccomment; goto contin
        else goto lastch
        done 
      else cp; w; goto nextt;
      done
    }

  | id => 
    {
      if isalphanum ch do goto contin;
      else goto overrun;
      done
    }
  | num => 
    {
      if isnumeric ch do goto contin;
      else goto overrun; 
      done
    } 
  // single quoted strings
  | sq =>
    {
      if issq ch do goto lastch; done
      goto contin;
    }
  | dq =>
    {
      if isdq ch do goto lastch; done
      goto contin;
    }
   // triple quoted strings
  | sq3 =>
    {
      if issq3() do cp; next; cp; next; cp; w; goto nextt; done
      goto contin;
    }
  | dq3 =>
    {
      if isdq3() do cp; next; cp; next; cp; w; goto nextt; done
      goto contin;
    }
   // comments
  | cppcomment =>
    {
      if iseol ch do goto lastch;
      else goto contin;
      done
    }
  | ccomment => // doesn't handle nested comments yet
    {
      if ch == char "*" and ahead(1) == char "/" do 
        cp; 
        goto lastch;
      else goto contin;
      done
    }
  endmatch
  ; // execute selected function
  println$ "Unexpected drop thru";

fin:>
   println "outof data, final write ..";
   w(); // whatever is left over gets written
   return out;
}
}
