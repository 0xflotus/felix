include "std/posix/filesystem";
open Judy;

var live = true;

fun dbg(s:string):string={ println s; return s; }

fun subst(s:string, v:varray[StringPiece]): string =
{
//println$ "Subst " + s +" with " + str v;
   enum mode_t {cp, ins};
   var b = "";
   var mode=cp;
   var j = 0;
   var i:int; 
   var count = 0;
   forall i in 0 upto len s - 1 do
     match mode with
     | cp => 
       if s.[i] == char "\\" do 
         mode = ins; 
         j=0; count = 0; 
       else 
        b += s.[i]; 
       done
     | ins =>
       if s.[i] in "0123456789" do
         j = j * 10 + ord(s.[i]) - ord (char "0");
         ++count;
       else
         if count == 0 do
           b += "\\";
         elif j < v.len.int do
           b+= str v.[j];
         done
         // adjacent insertion?
         if s.[i] == char "\\" do
           j=0; count=0;
         else
           mode = cp;
           b += s.[i]; 
         done
       done
     endmatch;
   done
   // run off end
   match mode with
   | cp => ;
   | ins =>
     if count == 0 do
       b += "\\";
     elif j < v.len.int do
       b+= str v.[j];
     done
   endmatch;
   return b;
}
  proc copyfiles(dname:string, re:RE2, tpat:string) 
  {
    var ds = JSLArray ();
    var sd = JSLArray ();
    var je: JError_t;
    var pv : &word;
    var pv2 : &word;
    var buffer: &char = C_hack::cast[&char] (C_hack::malloc(1000));
    var buffer2: &char = C_hack::cast[&char] (C_hack::malloc(1000));
    var dirs = JSLArray();
    var n = re.NumberOfCapturingGroups;
    var v = varray[StringPiece]$ (n+1).ulong, StringPiece "";
    proc rfi(dname2: string) 
    {   
      if dname2 != "." and dname2 != ".." do
      match FileSystem::filesin(Filename::join (dname,dname2)) with
      | None  => ;
      | Some ?files =>
        List::iter
          (proc (f:string) 
          { if f != "." and f != ".." do 
            var d = Filename::join (dname2,f);
            val t = FileSystem::filetype (Filename::join (dname,d));
            match t with
              | REGULAR => 
                //println$ "d="+d;
                if Re2::Match(re, StringPiece d, 0, ANCHOR_BOTH, v.stl_begin, v.len.int) 
                do 
                  var src = Filename::join (dname,d);
                  dst := subst(tpat,v);
                  JudySLIns(sd,cstr src,&je,&pv);
                  assert not isNULL(pv);
                  pv <- C_hack::cast[word] (new dst);
                  JudySLIns(ds,cstr dst,&je,&pv);
                  assert not isNULL(pv);
                  // check for duplicate targets
                  if not isNULL (*pv) do
                    println$ "Duplicate target " + dst;
                    System::exit(1);
                  done
                  pv <- C_hack::cast[word] (new src);
                  //println$ "Copy " + src + " -> " + dst;
                  iter 
                    (proc (x:string) { JudySLIns(dirs, cstr x, &je,&pv); }) 
                    (Filename::directories dst)
                  ;
                done 
              | DIRECTORY => rfi (d);
              | _ => ;
            endmatch;
            done
          }
          )
          files
        ;
      endmatch;
      done
    }
    rfi ("");

    // check record for dst clobbering src
    *buffer=char 0;
    JudySLFirst(sd,buffer,&je,&pv);
    whilst not isNULL pv do
      var cp = C_hack::cast[&string] (*pv);
      //println$ "Recorded copy " + string buffer + " -> " + *cp;

      Carray::strcpy(buffer2,buffer);
      JudySLGet(ds,buffer2,&je,&pv2);
      if not isNULL pv2 do
        println$ "Target clobbers src: " + buffer;
        System::exit(1);
      done
      JudySLGet(ds,buffer2,&je,&pv2);
      JudySLNext(sd,buffer,&je,&pv);
    done


    // list in order of target (not for any particular reason)
    /*
    *buffer=char 0;
    JudySLFirst(ds,buffer,&je,&pv);
    whilst not isNULL pv do
      cp = C_hack::cast[&string] (*pv);
      println$ "Recorded copy " + string buffer + " <- " + *cp;
      JudySLNext(ds,buffer,&je,&pv);
    done
    */

    // list all target directories
    *buffer = char 0;
    JudySLFirst(dirs,buffer,&je,&pv);
    whilst not isNULL pv do
      dir := string buffer;
      //println$ "Directory " + dir;
      if live do
        err:=FileSystem::mkdir(dir);
        if err !=0 do 
          //println$ "Mkdir, err=" + str err;
        done
      done
      JudySLNext(dirs,buffer,&je,&pv);
    done

      *buffer=char 0;
      JudySLFirst(sd,buffer,&je,&pv);
      whilst not isNULL pv do
        cp = C_hack::cast[&string] (*pv);
        print$ "copy " + string buffer + " -> " + *cp;
        if live do
          if FileSystem::filecopy(string buffer, *cp) do
            println " OK"; 
          else
            println "COPY FAILED";
          done
        else 
          println$ "  proposed";
        done
        JudySLNext(sd,buffer,&je,&pv);
      done

    C_hack::free(address buffer);
    C_hack::free(address buffer2);
  }
 

//println$ System::args ();
//println$ "argc=" + str System::argc;

var dir = 
  if System::argc < 2 then FileSystem::getcwd()
  else System::argv 1
  endif
;

var regex = 
  if System::argc < 3 then ".*"
  else System::argv 2
  endif
;

var re = Re2::RE2 regex;

if System::argc < 4 do
  println "Error: not target specified for copy";
  System::exit 1;
done;

var target =  System::argv 3;

if System::argc == 5 do
  match System::argv 4 with
  | "--test" => live = false; println "dry run";
  | "--exec" => live = true;
  | _ => println "trailing switch must be '--test' or '--exec'"; System::exit(1);
  endmatch;
done

println$ "Dir='" + dir + "', pattern='"+regex+"', dst='"+target+"'";
//println$ "Files in dir " + dir + "=";
copyfiles (dir, re, target);

