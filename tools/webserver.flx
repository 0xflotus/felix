if POSIX do
include "flx_faio_posix";  // aio_ropen
//open Faio_posix;
include "std/posix/signal";
Posix_Signal::ignore_signal(Posix_Signal::SIGPIPE);
done

include "flx_socket";
open Flx_socket;

include "flx_stream";
open Flx_stream;

open TerminalIByteStream[fd_t];
open TerminalIOByteStream[socket_t];

macro fun dbg(x) = { fprint (cerr,x); };

include "./cpp2html";
include "./flx2html";
include "./fdoc2html";
include "./charclass";
include "./css4html";

// this is a hack to make close work on a listener
// RF got this right the first time:
// in the abstract a listener is NOT a socket
// In fact, it is a socket server, with accept() a way to
// read new sockets off it ..
open TerminalIByteStream[socket_t];

var arg = "";
var argno = 1;
fun prefix(arg:string,key:string)=>
  arg.[to len key]==key
;
var LIBROOT = "";
whilst argno<System::argc do
  arg = System::argv argno;
  println$ "ARG=" + arg;
  if prefix(arg,"--root=") do
    LIBROOT=arg.[7 to]+"/lib";
  done
  ++argno;
done
println$ "LIBROOT="+LIBROOT;

fun getline_to_url (get:string) =>
  if not startswith get "GET " then
    ""
  else
    match find (get, ' ', 4) with
    | None[int] => ""
    | Some ?pos => get.[4 to pos]
    endmatch
  endif
;

fun split_url (inurl:string): opt[string*string] = {
  val url =
    if startswith inurl "http://" then
      inurl.[to 7]
    else
      inurl
    endif
  ;

  return
    match find (url, '/') with
    | None[int] => None[string*string]
    | Some ?pos => Some$ url.[0 to pos], url.[pos + 1 to]
    endmatch
  ;
}

fun parse_get_line (get:string): opt[string*string] =>
  split_url$ getline_to_url get
;

// TODO: fill in that length field, stream back the requested jpeg,
// get port from argv.

val html_header = """HTTP/0.9 200 OK\r
Date: Tue, 25 Apr 2006 00:16:12 GMT\r
Server: felix web server\r
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT\r
Connection: close\r
Content-Type: text/html\r
\r
""";

val gif_header = """HTTP/0.9 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: image/gif\r
\r
""";

val css_header = """HTTP/0.9 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: text/css\r
\r
""";


val notfound_header = """HTTP/0.9 404 Not Found\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: text/html\r
\r
PAGE NOT FOUND:\r
""";

proc write_http_header(s:socket_t, suffix:string, eof: &bool)
{
  // mime type mapping from suffix. make better here.
  if("gif" == suffix) then { write_string(s, gif_header, eof); }
  elif("css" == suffix) then { write_string(s, css_header, eof); }
  else { write_string(s, html_header, eof); } endif;
}

if WIN32 do
  proc win32_send_file(s:socket_t,fname:string,suffix:string)
  {
    // quick 'n' dirty unix -> dos style pathnames
    val wname = map (fun (a:char) => if a == char '/' then char '\\' else a endif) fname;
    print "mapped "; print fname; print " -> "; print wname; endl;
    var wf: WFILE <- Faio_win32::OpenFile(wname);
    if wf == Faio_win32::INVALID_HANDLE_VALUE do
    {
      print "BUGGER: OpenFile failed: "; print (GetLastError()); endl;
    } 
    else 
    {
      print "opened "; print wname; endl;
      write_http_header(s,suffix);
      print "Transmitting file!\n";
      TransmitFile(s, wf);
      CloseFile(wf);
    }
    done
  }
elif POSIX do
  proc posix_send_file(s:socket_t,fname:string,suffix:string, eof: &bool)
  {
if false do
    // this fn sets the O_NONBLOCK flag which is completely unnecessary
    // as read goes via the preading worker fifo. don't know if
    // O_NONBLOCK even works on actual files.
    var fd = Faio_posix::ropen(fname);

    if Faio_posix::invalid fd do
    {
      print ("BUGGER, posix open of "+fname+" failed\n");
      write_string(s, notfound_header, eof);
      write_string(s, fname+"\r\n\n", eof);
    } 
    else 
    {
      print ("got fd "+str fd +" for read file of "+fname+"\n");

      write_http_header(s,suffix, eof);
      var from_strm: Faio_posix::fd_t = fd;
      var to_strm: socket_t = s;
      Flx_stream::cat(from_strm, to_strm);

      dbg$ ("close read fd " + str(from_strm)+" file "+fname+"\n");
      iclose(from_strm); // this'll know how to close a unix fd
    } 
    done
else
    var contents = Text_file::load(fname);
    //print "loaded: "; print contents; endl;
    print "contents len="; print (len contents); endl;
val html_header = """HTTP/0.9 200 OK\r
Date: Tue, 25 Apr 2006 00:16:12 GMT\r
Server: felix web server\r
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT\r
Connection: close\r
Content-Type: text/html\r
Content-Length: """ + str (len (contents)) +"""\r
\r
""";

    write_string(s, html_header + contents, eof);
done
  }
done

fun inarray[N](s:string, a:array[string,N])=>
  mem (fun (x:string) => s == x) a
;
proc serve_cpp(s:socket_t, fname:string)
{
  var eof_flag = false;
  proc write_string(k:socket_t, t:string) 
  { 
   if not eof_flag do Flx_stream::write_string(k,t,&eof_flag); 
   else goto giveup;
   done
  }

  var flx = Text_file::load(fname);
  if flx == "" do flx = Text_file::load(LIBROOT+"/"+fname); done
  if flx == "" do flx = "NO FILE "+fname+" FOUND IN " + LIBROOT; done
  println$ "Loaded C/C++file " + fname;
  //println$ "Contents=" + flx;
  write_string(s, html_header);
  write_string(s, flx_head);
  write_string(s,"<pre>");
  write_cpp(s, flx, &eof_flag);
  write_string(s,"</pre>\n");
  write_string(s,"</body></html>\n\r");
giveup:>
}

proc write_text(k:socket_t, t:string, eof_flag: &bool)
{
  write_string(k,t,eof_flag);
}

proc serve_fdoc(s:socket_t, fname:string)
{
  var eof_flag = false;
  proc write_string(k:socket_t, t:string) 
  { 
   if not eof_flag do Flx_stream::write_string(k,t,&eof_flag); 
   else goto giveup;
   done
  }

  var txt = Text_file::load(fname);
  if txt == "" do txt = Text_file::load(LIBROOT+"/doc/"+fname); done
  if txt == "" do txt = "NO FILE "+fname+" FOUND IN " + LIBROOT+"/doc/"; done
  println$ "Loaded felix doc file " + fname;
  //println$ "Contents=" + flx;
  write_string(s, html_header);
  write_string(s, flx_head);
  write_fdoc(s, txt, &eof_flag);
  write_string(s,"</body></html>\n\r");
giveup:>
}

proc serve_file(infname: string, s: socket_t)
{
  var eof_flag = false;
  // if empty string, serve index.html
  // not quite right - needs to handle directories too, so
  // not only foo.com/ -> index.html, but foo.com/images/ -> images/index.html
  var fname = if "" == infname then "index.html" else infname endif;

  // set mime type depending on extension...
  // serve a "not found page" for that case (check for recursion)
  print "serve file: "; print fname; endl;

  // this isn't right, don't want the contents parsed as text, want them
  // sent faithfully over the wire. of course doesn't work for jpegs and other
  // binary formats.

  val suffix =
    match rfind (fname, ".") with
    | None[int] => ""
    | Some ?pos => fname.[pos + 1 to]
    endmatch
  ;

  print "suffix is "; print suffix; endl;

  if suffix == "flx" do serve_felix(s:socket_t, fname:string);
  elif suffix == "cpp" or suffix == "hpp" 
    or suffix == "cxx" or suffix == "h" or suffix == "c"
    do serve_cpp(s:socket_t, fname:string);
  
  elif suffix == "fdoc" do serve_fdoc(s:socket_t, fname:string);
  else
    if WIN32 do win32_send_file(s,fname, suffix);
    elif POSIX do posix_send_file(s,fname, suffix,&eof_flag);
    done
  done
}

val webby_port = 1234;

print "FLX WEB!!! listening on port "; print webby_port; endl;

// up the queue len for stress testing
var p = webby_port;
var listener: socket_t;
mk_listener(&listener, &p, 10);

var clock = Faio::mk_alarm_clock();

// noinline is necessary to stop the closure being
// inlined into the loop, preventing the socket variable k
// being duplicated as it must be [a bug in Felix]
noinline proc handler (var k:socket_t) ()
{
   dbg$ "Spawned fthread running for socket "+str k+"\n";
  // should spawn fthread here to allow for more io overlap

  var line: string;
  get_line(k, &line, str(k));  // should be the GET line.
  //cat(s, DEVNULL);

  print$ "got line from socket "+str k+": "; print line; endl;

  // now I need to parse the GET line, get a file name out of its url
  // (e.g. unqualfied -> index.html and name/flx.jpg -> flx.jpg
  match parse_get_line line with
  | None[string*string] => {
      print "BAD get line: "; print line; endl;
    }
  | Some (?base, ?file) => {
      print "well formed get...\n";
      print "base="; print base; endl;
      print "file="; print file; endl;

      serve_file(file, k);
    }
  endmatch;

  // we've only read the GET line, so let's flush out the rest of
  // the http request so we don't get connection reset errors when
  // we close the socket. shutting down stops cat blocking (?)
  //Faio_posix::shutdown(s, 1); // disallow further sends.
  //cat(s, DEVNULL);

  fprint$ cerr,"fthread socket "+str k+" close delay ..\n";
  Faio::sleep(clock,10.0); // give OS time to empty its buffers
  fprint$ cerr,"fthread socket "+str k+" shutdown now\n";
  Flx_socket::shutdown(k,3);
  ioclose(k);
  fprint$ cerr,"fthread "+str k+" terminating!\n";
};

forever {
  var s: socket_t;
  dbg$ "Waiting for connection\n";
  accept(listener, &s);  // blocking
  dbg$ "got connection "+str s + "\n";  // error check here

  // hmm - spawning an fthread is blocking the web server. don't know why
  print$ "spawning fthread to handle connection "+str s+"\n";
  var h = handler s;
  spawn_fthread  h;
 //collect(); // this hangs everything, no idea why!
};

println "WEB SERVER FINNISHED?";
iclose(listener);
