if POSIX do
include "flx_faio_posix";  // aio_ropen
//open Faio_posix;
include "std/posix/signal";
Posix_Signal::ignore_signal(Posix_Signal::SIGPIPE);
done

include "flx_socket";
open Flx_socket;

include "flx_stream";
open Flx_stream;

open TerminalIByteStream[fd_t];
open TerminalIOByteStream[socket_t];

macro fun dbg(x) = { fprint (cerr,x); };

include "./cpp2html";
include "./flx2html";
include "./fdoc2html";
include "./charclass";
include "./css4html";

// this is a hack to make close work on a listener
// RF got this right the first time:
// in the abstract a listener is NOT a socket
// In fact, it is a socket server, with accept() a way to
// read new sockets off it ..
open TerminalIByteStream[socket_t];

var arg = "";
var argno = 1;
fun prefix(arg:string,key:string)=>
  arg.[to len key]==key
;
var LIBROOT = "";
whilst argno<System::argc do
  arg = System::argv argno;
  println$ "ARG=" + arg;
  if prefix(arg,"--root=") do
    LIBROOT=arg.[7 to]+"/lib";
  done
  ++argno;
done
println$ "LIBROOT="+LIBROOT;

fun getline_to_url (get:string) =>
  if not startswith get "GET " then
    ""
  else
    match find (get, ' ', 4) with
    | None[int] => ""
    | Some ?pos => get.[4 to pos]
    endmatch
  endif
;

fun split_url (inurl:string): opt[string*string] = {
  val url =
    if startswith inurl "http://" then
      inurl.[to 7]
    else
      inurl
    endif
  ;

  return
    match find (url, '/') with
    | None[int] => None[string*string]
    | Some ?pos => Some$ url.[0 to pos], url.[pos + 1 to]
    endmatch
  ;
}

fun parse_get_line (get:string): opt[string*string] =>
  split_url$ getline_to_url get
;

// TODO: fill in that length field, stream back the requested jpeg,
// get port from argv.

fun make_gif(contents:string)=> """HTTP/0.9 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: image/gif\r
Content-Length: """+str(len(contents))+"""\r
\r
"""+contents;

fun make_css(contents:string)=> """HTTP/0.9 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: text/css\r
Content-Length: """+str (len (contents))+"""\r
\r
"""+contents;


fun make_notfound(contents:string)=> """HTTP/0.9 404 Not Found\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: text/html\r
Content-Length: """+str(len(contents)+19)+"""\r
\r
PAGE NOT FOUND: """+contents+"""\r
""";

fun make_html(contents:string)=>
"""HTTP/0.9 200 OK\r
Date: Tue, 25 Apr 2006 00:16:12 GMT\r
Server: felix web server\r
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT\r
Connection: close\r
Content-Type: text/html\r
Content-Length: """ + str (len (contents)) +"""\r
\r
"""+contents;


fun inarray[N](s:string, a:array[string,N])=>
  mem (fun (x:string) => s == x) a
;

proc serve_felix(k:socket_t, fname:string)
{
  var eof_flag = false;
  var flx = Text_file::load(fname);
  if flx == "" do flx = Text_file::load(LIBROOT+"/"+fname); done
  if flx == "" do flx = "NO FILE "+fname+" FOUND IN " + LIBROOT; done
  println$ "Loaded felix file " + fname+", len="+str (len flx);

  val data = make_html(
    "<head>"+Css4Html::flx_head+"</head>"+
    "<body><html><pre>"+
    Flx2Html::xlat_felix flx+
    "</pre></html></body>\n\r"
  );
  write_string(k,data,&eof_flag);
}

proc serve_cpp(k:socket_t, fname:string)
{
  var eof_flag = false;
  var flx = Text_file::load(fname);
  if flx == "" do flx = Text_file::load(LIBROOT+"/"+fname); done
  if flx == "" do flx = "NO FILE "+fname+" FOUND IN " + LIBROOT; done
  println$ "Loaded C/C++file " + fname+", len="+str(len flx);

  val data = make_html(
    "<head>"+Css4Html::flx_head+"</head>"+
    "<body><html><pre>"+
    Cpp2Html::xlat_cpp flx+
    "</pre></html></body>\n\r"
  );
  write_string(k,data,&eof_flag);

}

proc serve_text(k:socket_t, fname:string)
{
  var eof_flag = false;
  var txt = Text_file::load(fname);
  println$ "Loaded raw file " + fname+", len="+str(len txt);
  val data = make_html(
    "<head></head>"+
    "<body><html><pre>"+
    txt+
    "</pre></html></body>\n\r"
  );
  write_string(k,data,&eof_flag);
}

proc serve_fdoc(k:socket_t, fname:string)
{
  var eof_flag = false;
  var txt = Text_file::load(fname);
  if txt == "" do txt = Text_file::load(LIBROOT+"/doc/"+fname); done
  if txt == "" do txt = "NO FILE "+fname+" FOUND IN " + LIBROOT+"/doc/"; done
  println$ "Loaded felix doc file " + fname+", len="+str(len txt);
  //println$ "Contents=" + flx;
  val data = make_html(
    "<head>"+Css4Html::flx_head+"</head>"+
    "<body><html>"+
    Fdoc2Html::xlat_fdoc txt+
    "</html></body>\n\r"
  );
  write_string(k,data,&eof_flag);
}

proc serve_raw(k:socket_t, fname:string, suffix:string)
{
  var eof_flag = false;
  var txt = Text_file::load(fname);
  println$ "Loaded raw file " + fname+", len="+str(len txt);
  //println$ "Contents=" + flx;
  val data = make_html(txt);
  write_string(k,data,&eof_flag);
}

proc serve_file(infname: string, s: socket_t)
{
  var eof_flag = false;
  // if empty string, serve index.html
  // not quite right - needs to handle directories too, so
  // not only foo.com/ -> index.html, but foo.com/images/ -> images/index.html
  var fname = if "" == infname then "index.html" else infname endif;

  // set mime type depending on extension...
  // serve a "not found page" for that case (check for recursion)
  print "serve file: "; print fname; endl;

  // this isn't right, don't want the contents parsed as text, want them
  // sent faithfully over the wire. of course doesn't work for jpegs and other
  // binary formats.

  val suffix =
    match rfind (fname, ".") with
    | None[int] => ""
    | Some ?pos => fname.[pos + 1 to]
    endmatch
  ;

  print "suffix is "; print suffix; endl;

  if suffix == "flx" do 
    serve_felix(s, fname);
  elif suffix == "cpp" or suffix == "hpp" 
    or suffix == "cxx" or suffix == "h" or suffix == "c" do 
    serve_cpp(s, fname);
  
  elif suffix == "fdoc" do 
    serve_fdoc(s, fname);
  else
    serve_raw(s,fname, suffix);
  done
}

val webby_port = 1234;

print "FLX WEB!!! listening on port "; print webby_port; endl;

// up the queue len for stress testing
var p = webby_port;
var listener: socket_t;
mk_listener(&listener, &p, 10);

var clock = Faio::mk_alarm_clock();

// noinline is necessary to stop the closure being
// inlined into the loop, preventing the socket variable k
// being duplicated as it must be [a bug in Felix]
noinline proc handler (var k:socket_t) ()
{
   dbg$ "Spawned fthread running for socket "+str k+"\n";
  // should spawn fthread here to allow for more io overlap

  var line: string;
  get_line(k, &line, str(k));  // should be the GET line.
  //cat(s, DEVNULL);

  print$ "got line from socket "+str k+": "; print line; endl;

  // now I need to parse the GET line, get a file name out of its url
  // (e.g. unqualfied -> index.html and name/flx.jpg -> flx.jpg
  match parse_get_line line with
  | None[string*string] => {
      print "BAD get line: "; print line; endl;
    }
  | Some (?base, ?file) => {
      print "well formed get...\n";
      print "base="; print base; endl;
      print "file="; print file; endl;

      serve_file(file, k);
    }
  endmatch;

  // we've only read the GET line, so let's flush out the rest of
  // the http request so we don't get connection reset errors when
  // we close the socket. shutting down stops cat blocking (?)
  //Faio_posix::shutdown(s, 1); // disallow further sends.
  //cat(s, DEVNULL);

  fprint$ cerr,"fthread socket "+str k+" close delay ..\n";
  Faio::sleep(clock,1.0); // give OS time to empty its buffers
  fprint$ cerr,"fthread socket "+str k+" shutdown now\n";
  Flx_socket::shutdown(k,3);
  ioclose(k);
  fprint$ cerr,"fthread "+str k+" terminating!\n";
};

forever {
  var s: socket_t;
  dbg$ "Waiting for connection\n";
  accept(listener, &s);  // blocking
  dbg$ "got connection "+str s + "\n";  // error check here

  // hmm - spawning an fthread is blocking the web server. don't know why
  print$ "spawning fthread to handle connection "+str s+"\n";
  var h = handler s;
  spawn_fthread  h;
 //collect(); // this hangs everything, no idea why!
};

println "WEB SERVER FINNISHED?";
iclose(listener);
