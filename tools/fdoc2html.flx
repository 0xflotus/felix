// felix document
module Fdoc2Html {

val markdown_code = RE2 ("({([^}]*)})");
fun markdown (s:string):string= {
  var x = s;
  C_hack::ignore(GlobalReplace(&x, markdown_code, StringPiece ("<code>\\2</code>")));
  return x;
}

fun xlat_fdoc(t:string)=
{
  var out = "";
  proc write_string(t:string) 
  { 
    out += t;
  }

  union state_t = 
    | cmd // processing command
    | doc // processing document
    | felix // processing felix code
  ;
  fun str(s:state_t) => match s with
  | doc => "doc"
  | felix => "felix"
  | cmd => "cmd"
  endmatch;
  
  var i = 0; var s:state_t=doc;
  var ch = t.[i];
  proc next() { ch = t.[i]; ++i; }
  fun ahead (j:int)=> t.[i+j-1]; 

  var b = "";
  proc cp() { b += ch; }

nextc:>
  next();
  if isnull ch goto fin; // out of data
  match s with 
  | doc =>
    { 
      if char "@" == ch do 
        if b != "" do write_string(markdown b); done
        s = cmd; b="";
      elif char "\n" == ch and char "\n" == ahead(1) do b+="\n<p>\n";
      else cp; 
      done
      goto nextc;
    }
  | felix =>
    { 
      if char "@" == ch do 
        if b != "" do 
          write_string("<pre class=flxbg>"); 
          write_string(Flx2Html::xlat_felix (b,"")); // no parent!
          write_string("</pre>"); 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | cmd => 
    {
      if char "\n" != ch do cp; goto nextc;
      else
        if b == "felix" do s = felix;
        elif prefix (b,"felix") do {
          fname := strip(b.[5 to]);
          var flx = get_flx(fname);
          write_string("<pre class=inclusion>\n"+fname+"</pre>\n");
          write_string("<pre class=flxbg>"); 
          write_string(Flx2Html::xlat_felix (flx,""));
          write_string("</pre>"); 
        };
        s=doc;
        elif b=="obsolete" do write_string("<p class=obsolete> <em>Obsolete</em> "); s=doc;
        elif b=="caveat" do write_string("<p class=caveat> <em>Caveat: </em> "); s=doc;
        elif b=="impl" do write_string("<p class=implementation_detail> <em>Implementation Detail: </em>"); s=doc;
        elif b=="future" do write_string("<p class=future> <em>In future: </em>"); s=doc;
        elif b=="bug" do write_string("<p class=bug> <em>In future: </em>"); s=doc;
        elif prefix(b,"h1") do write_string("<h1>"+b.[3 to]+"</h1>\n"); s=doc;
        elif prefix(b,"h2") do write_string("<h2>"+b.[3 to]+"</h2>\n"); s=doc;
        elif prefix(b,"h3") do write_string("<h3>"+b.[3 to]+"</h3>\n"); s=doc;
        elif prefix(b,"h4") do write_string("<h4>"+b.[3 to]+"</h4>\n"); s=doc;
        else s = doc;
        done
      done
      b = "";
      goto nextc;
    }
  endmatch
  ; // execute selected function
  println$ "Unexpected drop thru";

fin:>
   println "outof data";
   if b != "" do write_string(match s with | doc => markdown b | _ => b endmatch); done
   return out;
}
}
