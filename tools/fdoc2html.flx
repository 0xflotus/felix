// felix document
include "std/posix/process";

module Fdoc2Html {

val markdown_code = RE2 ("({([^}]*)})");
fun markdown (s:string):string= {
  var x = s;
  C_hack::ignore(GlobalReplace(&x, markdown_code, StringPiece ("<code>\\2</code>")));
  return x;
}

val timeout = Filename::join (Config::FLX_INSTALL_DIR, "bin", "timeout"+Config::EXT_EXE);

gen safer_popen(cmd:string)=>
  Process::popen_in(timeout+" -t 15 " + cmd + " 2>&1")
;

fun xlat_fdoc(t:string)=
{
  var out = "";
  proc write_string(t:string) 
  { 
    out += t;
  }

  union state_t = 
    | cmd // processing command
    | doc // processing document
    | felix // processing felix code
    | flx_and_expect // processing felix code and expect file
  ;
  fun str(s:state_t) => match s with
  | doc => "doc"
  | felix => "felix"
  | flx_and_expect => "flx-and-expect"
  | cmd => "cmd"
  endmatch;
  
  var i = 0; var s:state_t=doc;
  var ch = t.[i];
  proc next() { ch = t.[i]; ++i; }
  fun ahead (j:int)=> t.[i+j-1]; 
  var b = "";
  proc cp() { b += ch; }


  // paragraph control
  var pstate = false;
  proc start_p () { write_string("<p>"); pstate=true; }
  proc end_p () { write_string("</p>"); pstate=false; }
  proc break_p () { write_string("</p><p>"); }
  proc sp() { if not pstate do start_p; done }
  proc ep() { if pstate do end_p; done }
  proc bp() { if pstate do end_p; done start_p; }

nextc:>
  next();
  if isnull ch goto fin; // out of data
  match s with 
  | doc =>
    { 
      if char "@" == ch do 
        if b != "" do bp; write_string(markdown b); done
        s = cmd; b="";
      elif char "\n" == ch and char "\n" == ahead(1) do 
        write_string(markdown b);
        b="";
        ep;
      else cp; 
      done
      goto nextc;
    }
  | felix =>
    { 
      if char "@" == ch do 
        if b != "" do 
          write_string("<pre class='flxbg'>"); 
          write_string(Flx2Html::xlat_felix (b,"")); // no parent!
          write_string("</pre>"); 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | cmd => 
    {
      if char "\n" != ch do cp; goto nextc;
      else
        if b == "felix" do s = felix;
        elif prefix (b,"felix ") do 
          {
            fname := strip(b.[6 to]);
            var flx = get_flx(fname);
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(Flx2Html::xlat_felix (flx,""));
            write_string("</pre>"); 
          };
          s=doc;
        elif prefix (b,"flx-and-expect ") do 
          {
            fname := strip(b.[15 to]);
            var flx = get_flx(fname+".flx");
            write_string("<pre class='inclusion'>"+fname+".flx</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(Flx2Html::xlat_felix (flx,""));
            write_string("</pre>\n");
            write_string("<pre class='inclusion'>"+fname+".expect</pre>\n");
            var xpected = get_flx(fname+".expect");
            write_string("<pre class='expected'>\n"); 
            write_string(xpected);
            write_string("</pre>"); 
          };
          s=doc;
        elif b=="obsolete" do ep; pstate=true; write_string("<p class='obsolete'> <em>Obsolete</em> "); s=doc;
        elif b=="caveat" do ep; pstate=true; write_string("<p class='caveat'> <em>Caveat: </em> "); s=doc;
        elif b=="impl" do ep; pstate=true; write_string("<p class='implementation_detail'> <em>Implementation Detail: </em>"); s=doc;
        elif b=="future" do ep; pstate=true; write_string("<p class='future'> <em>In future: </em>"); s=doc;
        elif b=="bug" do ep; pstate=true; write_string("<p class='bug'> <em>Bug: </em>"); s=doc;
        elif b=="fixed" do ep; pstate=true; write_string("<p class='fixed'> <em>Fixed: </em>"); s=doc;
        elif b=="done" do ep; pstate=true; write_string("<p class='done'> <em>Done: </em>"); s=doc;
        elif prefix(b,"h1") do ep; write_string("<h1>"+b.[3 to]+"</h1>\n"); s=doc;
        elif prefix(b,"h2") do ep; write_string("<h2>"+b.[3 to]+"</h2>\n"); s=doc;
        elif prefix(b,"h3") do ep; write_string("<h3>"+b.[3 to]+"</h3>\n"); s=doc;
        elif prefix(b,"h4") do ep; write_string("<h4>"+b.[3 to]+"</h4>\n"); s=doc;
        elif prefix(b,"sh") do 
          var cmd = b.[3 to];
          var fout = safer_popen(cmd);
          if Text_file::valid fout do
            var output = Text_file::load fout;
            var result = Process::pclose fout; 
            println$ "Ran cmd=" + cmd;
            //println$ "Output = " + output;
            write_string output;
          else
            println$ "Unable to run command '" + cmd "'";
            write_string("Failed cmd: " + b);
          done
          s=doc;
        else s = doc;
        done
      done
      b = "";
      goto nextc;
    }
  endmatch
  ; // execute selected function
  println$ "Unexpected drop thru";

fin:>
//   println "outof data";
   if b != "" do write_string(match s with | doc => markdown b | _ => b endmatch); done
   ep;
   return out;
}
}
