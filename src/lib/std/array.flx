publish "Compile Time Fixed Length Array"

open class Farray
{
  publish "Array type"
  typedef array[t,n] = t ^ n;

  publish "Array constructors"
  ctor[T,N] array[T,N] (x:array[T,N]) => x;

  // array as value
  instance[t,n] ArrayValue[array[t,n], t] {
    fun len (x:array[t, n]): size => Typing::arrayindexcount[n];
    fun unsafe_get: array[t, n] * size -> t = "$1.data[$2]";
    //fun unsafe_get (var a: array[t, n], j: size): t => a.j;
  }

  // array as object
  instance[t,n] ArrayValue[&array[t,n], t] {
    fun len (x:&array[t, n]): size => Typing::arrayindexcount[n];
    fun unsafe_get: &array[t, n] * size -> t = "$1->data[$2]";
  }

  instance[t,n] ArrayObject[&array[t,n], t] {
    proc unsafe_set: &array[t,n] * size * t = "$1->data[$2]=$3;";
  }

  instance[t,n] ContiguousArrayObject[&array[t,n], t] {
    fun stl_begin: &array[t,n] -> +t = "$1->data";
    fun stl_end ( x:&array[t,n] ) : +t => stl_begin x + len x;
  }

  fun map[V,N,U] (_f:V->U) (x:array[V,N]):array[U,N] = {
    var o : array[U,N];
    val n = x.len;
    if n > 0uz do
      for var i: size in 0uz upto n - 1uz do
        set (&o,i, _f x.i);
      done
    done
    return o;
  }



  // Note: for many loops below, note we're using unsigned values
  // iterating from 0 to N-1. Subtraction N-1 fails for n == 0
  // so we need a special test. 

  fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, N + M] = {
    var o : array[T, N + M];

    if x.len > 0uz do
      for var i in 0uz upto len(x) - 1uz do
        set (&o, i,x.i);
      done
    done
    i = x.len;
    if y.len > 0uz do
      for var k in 0uz upto len(y) - 1uz do
        set(&o,i + k, y.k);
      done
    done

    return o;
  }

  fun join[T, N] (x:array[T, N]) (y:T):array[T, N + 1] = {
    var o : array[T, N + 1];

    if x.len > 0uz do
      for var i in 0uz upto len(x) - 1uz do
        set (&o, i,x.i);
      done
    done
    set(&o,x.len, y);
    return o;
  }

  fun join[T, M] (x:T) (y:array[T, M]):array[T, 1 + M] = {
    var o : array[T, 1 + M];

    set (&o, 0, x);
    if y.len > 0uz do
      for var k in 0uz upto len(y) - 1uz do
        set(&o,1uz + k, y.k);
      done
    done

    return o;
  }


  // will probably clash with tuple joining functions if we implement them
  fun + [T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, N + M] => join x y;

  // subsumes zip
  fun transpose[T,N,M] (y:array[array[T,M],N]) : array[array[T,N],M] = {
    var o : array[array[T,N],M];
    var n = len y;
    var m = len y.0;
    for var i in 0uz upto n - 1uz do
      for var j in 0uz upto m - 1uz do
        val pfirst : +array[T,N] = &o.stl_begin;
        val psub: +array[T,N] = pfirst + j;
        val pelt : +T = psub.stl_begin;
        set(pelt,i, y.i.j);
      done
    done
    return o;
  }

  // reverse
  fun rev[T, N] (x:array[T, N]): array[T, N] = {
    var o : array[T, N];
    var n = len x;
    if n > 0uz do
      for var i:size in 0uz upto n - 1uz do
        set(&o,n - 1uz - i, x.i);
      done
    done
    return o;
  }

  // display
  instance[T,N with Show[T]] Str[array[T, N]] {
    fun str (xs:array[T,N]) = {
      var o = '(';
      val n = xs.len;
      if n  > 0uz do
        o += repr xs.0;

        for var i:size in 1uz upto n - 1uz do
          o += ', ' + repr xs.i;
        done
      done
      return o + ')';
    }
  }

  // equality
  instance[T,N with Eq[T]] Eq[array[T, N]] {
    fun == (xs:array[T,N],ys:array[T,N]) = {
      val n = xs.len;
      // assert n == ys.len;
      if n == 0uz do
        return true;
      else
        for var i:size in 0uz upto n - 1uz do
          if not (xs.i == ys.i) do return false; done
        done
      done
      return true;
    }
  }

  // total ordering 
  instance[T,N with Tord[T]] Tord[array[T,N]] {
    fun < (xs:array[T,N],ys:array[T,N]) = {
      val n = xs.len;
      if n == 0uz do return false; done
      // assert n == ys.len;
      var i:size;
      ph1:for i in 0uz upto n - 1uz do
        if not (xs.i < ys.i) do break ph1; done
      done
      for i in i upto n - 1uz do
        if not (xs.i <= ys.i) do return false; done
      done
      return true;
    }
  }
}

open[T,N] Eq[array[T,N]];
open[T,N] Tord[array[T,N]];
open[T,N with Eq[T]] Set[array[T,N],T];

open[T,N] ArrayValue[array[T,N], T];
open[T,N] ArrayValue[&array[T,N], T];
open[T,N] ArrayObject[&array[T,N], T];
open[T,N] ContiguousArrayObject[&array[T,N], T];

