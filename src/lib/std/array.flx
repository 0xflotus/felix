publish "Array manipulation"

open module Array
{
  publish "Array type"
  typedef array[t,n] = t ^ n;

  publish "Array constructors"
  ctor[T,N] array[T,N] (x:array[T,N]) => x;

  publish "Array access: works on LHS of assignment too"
  fun subscript[t,n]: array[t, n] * !ints -> t = "$1.data[$2]";
  fun get[t,n]: array[t, n] * !ints -> t = "$1.data[$2]";

  publish "Explicit array set function"
  proc set[t,n]: &array[t,n] * !ints * t = "((?1*)($1->data))[$2]=$3;";

  fun len[T, N] (x:array[T, N]): size => Typing::memcount[N];

  // Note: for many loops below, note we're using unsigned values
  // iterating from 0 to N-1. Subtraction N-1 fails for n == 0
  // so we need a special test. 

  // iteration
  proc iter[T, N] (_f:T->void) (x:array[T, N]) {
    val n = x.len;
    if n > 0uz do
      for var i:size in 0uz upto n - 1uz do
        _f x.[i];
      done
    done
  }

  fun map[T, N, U] (_f:T->U) (x:array[T, N]): array[U, N] = {
    var o : array[U, N];
    val n = x.len;
    if n > 0uz do
      for var i: size in 0uz upto n - 1uz do
        o.[i] = _f x.[i];
      done
    done
    return o;
  }

  fun fold_left[T, N, U] (_f:U->T->U) (init:U) (x:array[T, N]): U = {
    var o = init;
    val n = x.len;
    if n > 0uz do
      for var i:size in 0uz upto n - 1uz do
        o = _f o x.[i];
      done
    done
    return o;
  }

  fun fold_right[T, N, U] (_f:T->U->U) (x:array[T, N]) (init:U): U = {
    var o = init;
    val n = x.len;
    if n > 0uz do
      for var i:size in n - 1uz downto 0uz do
        o = _f x.[i] o;
      done
    done
    return o;
  }

/*
  fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, _flatten(N + M)] = {
    var o = array[T, _flatten(N + M)];
    val i : int;

    for i in 0 upto len(x) - 1 do
      o.[i] = x.[i];
    done;

    val j : int;

    for k in 0 upto len(y) - 1 do
      o.[i + j] = y.[i];
    done;

    return o;
  }
*/

  // searching
  fun mem[T, N] (pred:T->bool) (x:array[T, N]): bool = {
    val n = x.len;
    if n > 0uz do
      for var i:size in 0uz upto n  - 1uz do
        if pred(x.[i]) do
          return true;
        done
      done
    done
    return false;
  }

  fun mem[T, N, U] (eq:T*U->bool) (x:array[T, N]) (e:U): bool =>
    mem (fun (i:T) => eq(i, e)) x
  ;

  instance[T,N with Eq[T]] Set[array[T,N],T] {
    fun mem (x:T, a:array[T,N]) => mem[T,N,T] eq of (T * T) a x;
  }

  fun find[T, N] (pred:T*T->bool) (x:array[T, N]) (e:T): opt[T] = {
    val n = x.len;
    if n > 0uz do
      for var i:size in 0uz upto n - 1uz do
        if pred(x.[i], e) do
          return Some x.[i];
        done
      done
    done

    return None[T];
  }

  fun find[T, N] (pred:T->bool) (x:array[T, N]): opt[T] = {
    val n = x.len;
    if  n > 0uz do 
      for var i:size in 0uz upto n - 1uz do
        if pred(x.[i]) do
          return Some x.[i];
        done
      done
    done
    return None[T];
  }

  // reverse
  fun rev[T, N] (x:array[T, N]): array[T, N] = {
    var o : array[T, N];
    var n = len x;
    if n > 0uz do
      for var i:size in 0uz upto n - 1uz do
        o.[n - 1uz - i] = x.[i];
      done
    done
    return o;
  }

  // display
  instance[T,N with Show[T]] Str[array[T, N]] {
    fun str (xs:array[T,N]) = {
      var o = '(';
      val n = xs.len;
      if n  > 0uz do
        o += repr xs.[0];

        for var i:size in 1uz upto n - 1uz do
          o += ', ' + repr xs.[i];
        done
      done
      return o + ')';
    }
  }

  // equality
  instance[T,N with Eq[T]] Eq[array[T, N]] {
    fun eq(xs:array[T,N],ys:array[T,N]) = {
      val n = xs.len;
      // assert n == ys.len;
      if n == 0uz do
        return true;
      else
        for var i:size in 0uz upto n - 1uz do
          if not (xs.[i] == ys.[i]) do return false; done
        done
      done
      return true;
    }
  }

  instance[T,N with Tord[T]] Tord[array[T,N]] {
    fun lt(xs:array[T,N],ys:array[T,N]) = {
      val n = xs.len;
      if n == 0uz do return false; done
      // assert n == ys.len;
      var i:size;
      ph1:for i in 0uz upto n - 1uz do
        if not (xs.[i] < ys.[i]) do break ph1; done
      done
      for i in i upto n - 1uz do
        if not (xs.[i] <= ys.[i]) do return false; done
      done
      return true;
    }
  }
}

//open[T,N] Eq[array[T,N]];
open[T,N] Tord[array[T,N]];
open[T,N with Eq[T]] Set[array[T,N],T];

