publish "Compile Time Fixed Length Array"

open module Farray
{
  publish "Array type"
  typedef array[t,n] = t ^ n;

  publish "Array constructors"
  ctor[T,N] array[T,N] (x:array[T,N]) => x;

  // array as value
  instance[t,n] ArrayValue[array[t,n], t] {
    fun len (x:array[t, n]): size => Typing::memcount[n];
    fun unsafe_get: array[t, n] * size -> t = "$1.data[$2]";
  }

  // array as object
  instance[t,n] ArrayValue[&array[t,n], t] {
    fun len (x:&array[t, n]): size => Typing::memcount[n];
    fun unsafe_get: &array[t, n] * size -> t = "$1->data[$2]";
  }

  instance[t,n] ArrayObject[&array[t,n], t] {
    proc unsafe_set: &array[t,n] * size * t = "((?1*)($1->data))[$2]=$3;";
  }

  fun map[V,N,U] (_f:V->U) (x:array[V,N]):array[U,N] = {
    var o : array[U,N];
    val n = x.len;
    if n > 0uz do
      for var i: size in 0uz upto n - 1uz do
        set (&o,i, _f x.[i]);
      done
    done
    return o;
  }



  // Note: for many loops below, note we're using unsigned values
  // iterating from 0 to N-1. Subtraction N-1 fails for n == 0
  // so we need a special test. 

/*
  fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, _flatten(N + M)] = {
    var o = array[T, _flatten(N + M)];
    val i : int;

    if x.len > 0uz do
      for i in 0uz upto len(x) - 1uz do
        o.[i] = x.[i];
      done
    done

    val j : int;

    if y.len > 0uz do
      for k in 0uz upto len(y) - 1uz do
        o.[i + j] = y.[i];
      done
    done

    return o;
  }
*/

  instance[T,N with Eq[T]] Set[array[T,N],T] {
    fun mem (x:T, a:array[T,N]) => mem[T,N,T] eq of (T * T) a x;
  }

  // reverse
  fun rev[T, N] (x:array[T, N]): array[T, N] = {
    var o : array[T, N];
    var n = len x;
    if n > 0uz do
      for var i:size in 0uz upto n - 1uz do
        set(&o,n - 1uz - i, x.[i]);
      done
    done
    return o;
  }

  // display
  instance[T,N with Show[T]] Str[array[T, N]] {
    fun str (xs:array[T,N]) = {
      var o = '(';
      val n = xs.len;
      if n  > 0uz do
        o += repr xs.[0];

        for var i:size in 1uz upto n - 1uz do
          o += ', ' + repr xs.[i];
        done
      done
      return o + ')';
    }
  }

  // equality
  instance[T,N with Eq[T]] Eq[array[T, N]] {
    fun eq(xs:array[T,N],ys:array[T,N]) = {
      val n = xs.len;
      // assert n == ys.len;
      if n == 0uz do
        return true;
      else
        for var i:size in 0uz upto n - 1uz do
          if not (xs.[i] == ys.[i]) do return false; done
        done
      done
      return true;
    }
  }

  instance[T,N with Tord[T]] Tord[array[T,N]] {
    fun lt(xs:array[T,N],ys:array[T,N]) = {
      val n = xs.len;
      if n == 0uz do return false; done
      // assert n == ys.len;
      var i:size;
      ph1:for i in 0uz upto n - 1uz do
        if not (xs.[i] < ys.[i]) do break ph1; done
      done
      for i in i upto n - 1uz do
        if not (xs.[i] <= ys.[i]) do return false; done
      done
      return true;
    }
  }
}

//open[T,N] Eq[array[T,N]];
open[T,N] Tord[array[T,N]];
open[T,N with Eq[T]] Set[array[T,N],T];

open[T,N] ArrayValue[array[T,N], T];
open[T,N] ArrayValue[&array[T,N], T];
open[T,N] ArrayObject[&array[T,N], T];

