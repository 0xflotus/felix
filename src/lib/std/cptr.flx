open class Cptr 
{
  typedef ptr[T] = &T;
  union cptr[T] = | nullptr | Ptr of &T;

  ctor[T] cptr[T]: &T -> cptr[T] = "$1"; // safe
  ctor[T] ptr[T]( px:cptr[T]) => let Ptr  ?p = px in p; // match failure if null
  fun deref[T] (px:cptr[T])=> *(px.ptr); // checked deref
  fun is_nullptr[T] (px:cptr[T])=> match px with | nullptr => true | _ => false endmatch;
  
  instance[T] Eq[cptr[T]] {
    fun == : cptr[T] * cptr[T] -> bool = "$1==$2";
  }
  instance[T] Tord[cptr[T]] {
    fun < : cptr[T] * cptr[T] -> bool = "$1<$2";
  }
}

open[T] Eq[cptr[T]];
open[T] Tord[cptr[T]];

typedef fun n"@" (T:TYPE) : TYPE => cptr[T]; 


