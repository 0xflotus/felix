open class Fibres
{
  private gen _start[t]: (t->0)*t->cont = "$1->clone()->call(0,$2)";
  gen start[t] (p:t->0) (x:t) = { return _start (p,x); }
  private fun _start0: (1->0)->cont = "$1->clone()->call(0)";
  gen start (p:1->0) = { return _start0 (p); }

  gen mk_thread: cont->fthread = "new(*PTF gcp,::flx::rtl::_fthread_ptr_map,false) ::flx::rtl::fthread_t($1)";

  // Spawn a fibre on this fibres scheduler.
  // uses a supervisor call so can't be used in a function
  proc spawn_fthread(p:1->0)
  {
      var con = start p;              // get continuation of p
      var fthr = mk_thread con;
      svc$ svc_spawn_detached fthr;
  }


  // FIBRE SCHEDULER
  type fibre_scheduler = "::flx::run::sync_state_t*";
  // NOTE: NOT GARBAGE COLLECTED!
  ctor fibre_scheduler: 1 = """new ::flx::run::sync_state_t(false, PTF pgc, 
    new ::std::list<::flx::rtl::fthread_t*>)""";
  ;
  proc delete_fibre_scheduler : fibre_scheduler = """
    $1->gcp->collector->remove_root($1->ft);
    for(
     ::std::list<::flx::rtl::fthread_t*>::iterator p = $1.active->begin();
     p != $1->active->end();
     p++
    )
    $1->gcp->collector->remove_root(p);
    delete $1->active; delete $1->ft; delete $1;
  """;

  proc spawn_fibre: fibre_scheduler * fthread = """
    $1->gcp->collector->add_root($2);
    $1->active->push_back($2);
    $1->frun(); 
  """;

  enum fibre_scheduler_state {
    terminated, 
    blocked,    // normal exit: out of fibres to run
    delegated   // client fibre issued a service request such as svc_general
                // which the synchronous scheduler cannot satisfy
  };
  fun get_state : fibre_scheduler -> fibre_scheduler_state = "$1->fs";


  proc spawn_fthread (fs:fibre_scheduler) (p:1->0) => spawn_fibre (fs,p.start.mk_thread);

  publish "Resume a continuation until it yields"
  gen step: cont -> cont = "$1->resume()";
  proc kill: fthread = "$1->cc = 0;";

  publish """
  Run a continuation until it terminates.
  Do not use this proc if the underlying
  procedure attempts to read messages.

  This is a low level primitive, bypassing fthreads.
  """
  proc run: cont = "::flx::rtl::executil::run($1);" requires package "flx_executil";

  private proc _send[t]: &cont * t =
  """
  {
    using namespace ::flx::rtl;
    con_t *tmp = *(con_t**)$1.get_data();
    // run target until it reaches a service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // check it is alive and making the expected service request
    if (!tmp)
      throw flx_exec_failure_t (__FILE__,"send","Send to terminated procedure");
    if (!tmp->p_svc)
      throw flx_exec_failure_t (__FILE__,"send","Send to unready Procedure");
    if (tmp->p_svc->variant != svc_read)
      throw flx_exec_failure_t (__FILE__,"send","Send to Procedure which is not trying to read");
    // store the message
    **(?1**)tmp->p_svc->data= $2;
    // clear the service request
    tmp->p_svc = 0;
    // run the target until the next service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // save the new continuation
    *(con_t**)$1.get_data() = tmp;

  }
  """;

  publish """Send a message to a continuation.
  There is no type checking on the message type.
  The procedure is executed until
  the next wait_state, then the message is stored.

  Low level primitive, bypassing fthreads.
  """
  proc send[t] (p:&cont) (x:t)
  {
    _send (p,x);
  }

}

