include "std/posix/errno";

publish """
Lightwight 0MQ wrapper.
"""

class ZeroMQ {
  requires package "zmq";

  open Errno;

  // temporary hack to get it to compile
  // replace later with standard Felix mapping of native socket handles

  if PLAT_WIN32 do
    type file = "SOCKET";
  elif PLAT_POSIX do
    type file = "int";
  else
    compile_fail "ZMQ: Unsupported OS";
  done

/******************************************************************************/
/*  0MQ version.                                                              */
/******************************************************************************/

  const ZMQ_VERSION : int;
  proc zmq_version: &int * &int * &int;
  fun zmq_version()={
    var maj:int; 
    var min:int; 
    var rev:int; 
    zmq_version(&maj, &min,&rev);
    return maj,min,rev;
  }

/******************************************************************************/
/*  0MQ errors.                                                               */
/******************************************************************************/

  const EFSM : errno_t;
  const ENOCOMPATPROTO : errno_t;
  const ETERM : errno_t;
  const EMTHREAD : errno_t;

  fun zmq_errno : 1-> errno_t;
  fun zmq_strerror : errno_t -> string = "::std::string(zmq_strerror($1))";

  gen ewrap(var x:int) => if x == 0 then errno_t(0) else errno endif;

/******************************************************************************/
/*  0MQ message definition.                                                   */
/******************************************************************************/

  typedef zmq_free_fn = address * address --> void;
  body "void zmq_free(void *p, void *){ ::std::free(p); }";
  private const zmq_free: zmq_free_fn;

  body "void zmq_finalise(void *, void *p){ zmq_close(p); }";

  private type zmq_msg_t_ = "zmq_msg_t";
  _gc_pointer _gc_type zmq_msg_t_ type zmq_msg_t  = "zmq_msg_t*" requires finaliser "zmq_finalise";
  private gen make_zmq_msg_t : 1 -> zmq_msg_t = "new (*PTF gcp, @0, false) zmq_msg_t";

  gen zmq_msg_init:  zmq_msg_t->int;
  gen zmq_msg_init_size: zmq_msg_t * size -> int;
  gen zmq_msg_init_data: zmq_msg_t * address * size * zmq_free_fn * address -> int;
  private gen zmq_msg_close: zmq_msg_t -> int;

  ctor zmq_msg_t () {
    var x = make_zmq_msg_t();
    maybe_exit (zmq_msg_init x);
    return x;
  } 
  ctor zmq_msg_t (n:size) {
    var x = make_zmq_msg_t();
    maybe_exit(zmq_msg_init_size (x,n));
    return x;
  } 
  ctor zmq_msg_t (s:string) {
    var x = make_zmq_msg_t();
    var n = len s;
    var b = C_hack::malloc(n);
    memcpy(b, address s.cstr, n);
    maybe_exit(zmq_msg_init_data (x, b, n, zmq_free, NULL));
    return x;
  } 

  gen zmq_msg_move: zmq_msg_t * zmq_msg_t -> int;
  gen zmq_msg_copy: zmq_msg_t * zmq_msg_t -> int;
  fun zmq_msg_data: zmq_msg_t -> address;
  fun zmq_msg_size : zmq_msg_t -> size;

/*  Message options                                                           */
  pod type zmq_message_option_code_t = "int";
  const ZMQ_MORE : zmq_message_option_code_t;

  private fun zmq_getmsgopt: zmq_msg_t * zmq_message_option_code_t * address * &size -> int;
  fun zmq_more(m:zmq_msg_t):bool = 
  {
    var x: int;
    var n:size;
    C_hack::ignore(zmq_getmsgopt(m,ZMQ_MORE,&x.address,&n));
    assert n == C_hack::sizeof[int];
    return x != 0;
  } 

  ctor string: zmq_msg_t = "::std::string(zmq_msg_data($1), zmq_msg_size($1))";

/******************************************************************************/
/*  0MQ infrastructure (a.k.a. context) initialisation & termination.         */
/******************************************************************************/

  pod type zmq_context = "void*";
  gen zmq_init : int  -> zmq_context;
  gen zmq_term : zmq_context -> int;
  ctor zmq_context : int = "zmq_init($1)";

/******************************************************************************/
/*  0MQ socket definition.                                                    */
/******************************************************************************/

  pod type zmq_socket= "void*";
  ctor zmq_socket : zmq_context * zmq_socket_type_t = "zmq_socket($1,$2)";

/******************************************************************************/
/*  Socket types.                                                             */ 
/******************************************************************************/

  type zmq_socket_type_t = "int";
  instance Eq[zmq_socket_type_t] {
    fun == : zmq_socket_type_t * zmq_socket_type_t -> bool = "$1==$2";
  }

  const ZMQ_PAIR : zmq_socket_type_t;
  const ZMQ_PUB : zmq_socket_type_t;
  const ZMQ_SUB : zmq_socket_type_t;
  const ZMQ_REQ : zmq_socket_type_t;
  const ZMQ_REP : zmq_socket_type_t;
  const ZMQ_XREQ : zmq_socket_type_t;
  const ZMQ_XREP : zmq_socket_type_t;
  const ZMQ_PULL : zmq_socket_type_t;
  const ZMQ_PUSH : zmq_socket_type_t;
  const ZMQ_XPUB : zmq_socket_type_t;
  const ZMQ_XSUB : zmq_socket_type_t;
  const ZMQ_ROUTER : zmq_socket_type_t;
  const ZMQ_DEALER : zmq_socket_type_t;

  instance Str[zmq_socket_type_t] {
    fun str: zmq_socket_type_t -> string =
    | $(ZMQ_PAIR) => "ZMQ_PAIR"
    | $(ZMQ_PUB) => "ZMQ_PUB"
    | $(ZMQ_SUB) => "ZMQ_SUB"
    | $(ZMQ_REQ) => "ZMQ_REQ"
    | $(ZMQ_REP) => "ZMQ_REP"
    | $(ZMQ_XREQ) => "ZMQ_XREQ"
    | $(ZMQ_XREP) => "ZMQ_XREP"
    | $(ZMQ_PULL) => "ZMQ_PULL"
    | $(ZMQ_PUSH) => "ZMQ_PUSH"
    | $(ZMQ_XPUB) => "ZMQ_XPUB"
    | $(ZMQ_XSUB) => "ZMQ_XSUB"
    | $(ZMQ_ROUTER) => "ZMQ_ROUTER"
    | $(ZMQ_DEALER) => "ZMQ_DEALER"
    ;
  }

/******************************************************************************/
/*  Socket options.                                                           */
/******************************************************************************/

  type zmq_sockopts_tag = "int";
  instance Eq[zmq_sockopts_tag] {
    fun == : zmq_sockopts_tag * zmq_sockopts_tag -> bool = "$1==$2";
  }

  const ZMQ_AFFINITY : zmq_sockopts_tag;
  const ZMQ_IDENTITY : zmq_sockopts_tag;
  const ZMQ_SUBSCRIBE : zmq_sockopts_tag;
  const ZMQ_UNSUBSCRIBE : zmq_sockopts_tag;
  const ZMQ_RATE : zmq_sockopts_tag;
  const ZMQ_RECOVERY_IVL : zmq_sockopts_tag;
  const ZMQ_SNDBUF : zmq_sockopts_tag;
  const ZMQ_RCVBUF : zmq_sockopts_tag;
  const ZMQ_RCVMORE : zmq_sockopts_tag;
  const ZMQ_FD : zmq_sockopts_tag;
  const ZMQ_EVENTS : zmq_sockopts_tag;
  const ZMQ_TYPE : zmq_sockopts_tag;
  const ZMQ_LINGER : zmq_sockopts_tag;
  const ZMQ_RECONNECT_IVL : zmq_sockopts_tag;
  const ZMQ_BACKLOG : zmq_sockopts_tag;
  const ZMQ_RECONNECT_IVL_MAX : zmq_sockopts_tag;
  const ZMQ_MAXMSGSIZE : zmq_sockopts_tag;
  const ZMQ_SNDHWM : zmq_sockopts_tag;
  const ZMQ_RCVHWM : zmq_sockopts_tag;
  const ZMQ_MULTICAST_HOPS : zmq_sockopts_tag;
  const ZMQ_RCVTIMEO : zmq_sockopts_tag;
  const ZMQ_SNDTIMEO : zmq_sockopts_tag;
  const ZMQ_IPV4ONLY : zmq_sockopts_tag;

  instance Str[zmq_sockopts_tag] {
    fun str:zmq_sockopts_tag-> string =
    | $(ZMQ_AFFINITY) => "ZMQ_AFFINITY"
    | $(ZMQ_IDENTITY) => "ZMQ_IDENTITY"
    | $(ZMQ_SUBSCRIBE) => "ZMQ_SUBSCRIBE"
    | $(ZMQ_UNSUBSCRIBE) => "ZMQ_UNSUBSCRIBE"
    | $(ZMQ_RATE) => "ZMQ_RATE"
    | $(ZMQ_RECOVERY_IVL) => "ZMQ_RECOVERY_IVL"
    | $(ZMQ_SNDBUF) => "ZMQ_SNDBUF"
    | $(ZMQ_RCVBUF) => "ZMQ_RCVBUF"
    | $(ZMQ_RCVMORE) => "ZMQ_RCVMORE"
    | $(ZMQ_FD) => "ZMQ_FD"
    | $(ZMQ_EVENTS) => "ZMQ_EVENTS"
    | $(ZMQ_TYPE) => "ZMQ_TYPE"
    | $(ZMQ_LINGER) => "ZMQ_LINGER"
    | $(ZMQ_RECONNECT_IVL) => "ZMQ_RECONNECT_IVL"
    | $(ZMQ_BACKLOG) => "ZMQ_BACKLOG"
    | $(ZMQ_RECONNECT_IVL_MAX) => "ZMQ_RECONNECT_IVL_MAX"
    | $(ZMQ_MAXMSGSIZE) => "ZMQ_MAXMSGSIZE"
    | $(ZMQ_SNDHWM) => "ZMQ_SNDHWM"
    | $(ZMQ_RCVHWM) => "ZMQ_RCVHWM"
    | $(ZMQ_MULTICAST_HOPS) => "ZMQ_MULTICAST_HOPS"
    | $(ZMQ_RCVTIMEO) => "ZMQ_RCVTIMEO"
    | $(ZMQ_SNDTIMEO) => "ZMQ_SNDTIMEO"
    | $(ZMQ_IPV4ONLY) => "ZMQ_IPV4ONLY"
    ;
  }


  union zmq_socket_options =
  | zmq_affinity of uint64             // 64 1 bit flags for 64 threads
  | zmq_identity of string             // socket name
  | zmq_subscribe of string            // message prefix
  | zmq_unsubscribe of string          // message prefix
  | zmq_rate of int                    // kb/sec
  | zmq_recovery_ivl of int            // ms
  | zmq_sndbuf of int                  // bytes
  | zmq_rcvbuf of int                  // bytes
  | zmq_rcvmore of bool                // encoding: int, true=more parts following
  | zmq_fd of file                     // native file type 
  | zmq_events of zmq_pollitem_flag_t  // encoding: int
  | zmq_type of  zmq_socket_type_t     // ro, socket type: encoding int
  | zmq_linger of int                  // close linger time
  | zmq_reconnect_ivl of int           // ms
  | zmq_backlog of int                 // number of connections
  | zmq_reconnect_ivl_max of int       // ms
  | zmq_maxmsgsize of int64            // bytes
  | zmq_sndhwm of int                  // messages
  | zmq_rcvhwm of int                  // messages
  | zmq_multicast_hops of int          // hops
  | zmq_rcvtimeo of int                // ms
  | zmq_sndtimeo of int                // ms
  | zmq_ipv4only of bool               // encoding: int
  ;

  instance Str[zmq_socket_options] {
    fun str: zmq_socket_options -> string =
    | zmq_affinity ?x => "affinity " + str x // fix: bit set
    | zmq_identity ?x => "identity '" + str x+"' socket name"
    | zmq_subscribe ?x => "subscribe '" + str x+"' message prefix"
    | zmq_unsubscribe ?x => "unsubscribe '" + str x+"' message prefix"
    | zmq_rate ?x => "rate " + str x+" kb/sec"
    | zmq_recovery_ivl ?x => "recovery_ivl " + str x+" ms"
    | zmq_sndbuf ?x => "sndbuf " + str x+" bytes"
    | zmq_rcvbuf ?x => "rcvbuf " + str x+" bytes"
    | zmq_rcvmore ?x => "rcvmore " + str x
    | zmq_fd ?x => "fd ?? native file type " // fix, numeric code
    | zmq_events ?x => "events " + str x
    | zmq_type ?x => "type " + str x
    | zmq_linger ?x => "linger " + str x+" ms"
    | zmq_reconnect_ivl ?x => "reconnect_ivl " + str x+" ms"
    | zmq_backlog ?x => "backlog " + str x+" connections"
    | zmq_reconnect_ivl_max ?x => "reconnect_ivl_max " + str x+" ms"
    | zmq_maxmsgsize ?x => "maxmsgsize " + str x+" bytes"
    | zmq_sndhwm ?x => "sndhwm " + str x+" messages"
    | zmq_rcvhwm ?x => "rcvhwm " + str x+" messages"
    | zmq_multicast_hops ?x => "multicast_hops " + str x+" hops"
    | zmq_rcvtimeo ?x => "rcvtimeo " + str x+" ms"
    | zmq_sndtimeo ?x => "sndtimeo " + str x+" ms"
    | zmq_ipv4only ?x => "ipv4only " + str x
    ;
  }

  private typedef blobkind = typesetof (uint64,int64,int,char,size,bool,file,zmq_pollitem_flag_t, zmq_socket_type_t);
  private typedef blobkind_ptr = typesetof (&uint64,&int64,&int,&char,&size);

  private gen zmq_setsockopt : zmq_socket * zmq_sockopts_tag * !blobkind_ptr * size -> int;
  private gen zset(s:zmq_socket, o:zmq_sockopts_tag, var x:uint64 ) => 
    zmq_setsockopt (s, o, &x, C_hack::sizeof[uint64]);
  private gen zset(s:zmq_socket, o:zmq_sockopts_tag, var x:int64 )  => 
    zmq_setsockopt (s, o, &x, C_hack::sizeof[int64]);
  private gen zset(s:zmq_socket, o:zmq_sockopts_tag, var x:int )    => 
    zmq_setsockopt (s, o, &x, C_hack::sizeof[int]);
  private gen zset(s:zmq_socket, o:zmq_sockopts_tag, x:bool )       => 
    zset(s, o, if x then 1 else 0 endif);
  private gen zset(s:zmq_socket, o:zmq_sockopts_tag, x:string )     => 
    zmq_setsockopt (s, o, x.cstr, x.size);
  
 
  gen zmq_setsockopt(s: zmq_socket, o: zmq_socket_options) =>
    match o with
    | zmq_affinity ?x          => zset(s, ZMQ_AFFINITY, x) 
    | zmq_identity ?x          => zset(s, ZMQ_IDENTITY, x) 
    | zmq_subscribe ?x         => zset(s, ZMQ_SUBSCRIBE, x) 
    | zmq_unsubscribe ?x       => zset(s, ZMQ_UNSUBSCRIBE, x) 
    | zmq_rate ?x              => zset(s, ZMQ_RATE, x) 
    | zmq_recovery_ivl ?x      => zset(s, ZMQ_RECOVERY_IVL, x) 
    | zmq_sndbuf ?x            => zset(s, ZMQ_SNDBUF, x) 
    | zmq_rcvbuf ?x            => zset(s, ZMQ_RCVBUF, x) 
    | zmq_linger ?x            => zset(s, ZMQ_LINGER, x) 
    | zmq_reconnect_ivl ?x     => zset(s, ZMQ_RECONNECT_IVL, x) 
    | zmq_backlog ?x           => zset(s, ZMQ_BACKLOG, x) 
    | zmq_reconnect_ivl_max ?x => zset(s, ZMQ_RECONNECT_IVL_MAX, x) 
    | zmq_maxmsgsize ?x        => zset(s, ZMQ_MAXMSGSIZE, x) 
    | zmq_sndhwm ?x            => zset(s, ZMQ_SNDHWM, x) 
    | zmq_rcvhwm ?x            => zset(s, ZMQ_RCVHWM, x) 
    | zmq_multicast_hops ?x    => zset(s, ZMQ_MULTICAST_HOPS, x) 
    | zmq_rcvtimeo ?x          => zset(s, ZMQ_RCVTIMEO, x) 
    | zmq_sndtimeo ?x          => zset(s, ZMQ_SNDTIMEO, x) 
    | zmq_ipv4only ?x          => zset(s, ZMQ_IPV4ONLY, x) 
    | _ => Control::fail_fun[int]$ "ZMQ: Cannot set socket option " + str o
  ;
 
  private gen zmq_getsockopt : zmq_socket * zmq_sockopts_tag * address * &size -> int;

  proc get_sockopt[T:blobkind](s:zmq_socket, o:zmq_sockopts_tag, pd:&T, ps: &size)
  {
  again:>
    val ok = zmq_getsockopt(s,o,pd.address,ps);
    if ok == 0 return;
    if errno == EINTR goto again;
    Control::fail$ "zmq_setsockopt failed with code " + zmq_strerror errno;
  }

  private gen get_uint64(s:zmq_socket, o: zmq_sockopts_tag) = { 
    var x:uint64; var n = C_hack::sizeof[typeof(x)]; get_sockopt(s,o,&x,&n); return x; }
  private gen get_int64(s:zmq_socket, o: zmq_sockopts_tag) = { 
    var x:int64; var n = C_hack::sizeof[typeof(x)]; get_sockopt(s,o,&x,&n); return x; }
  private gen get_int(s:zmq_socket, o: zmq_sockopts_tag) = { 
    var x:int; var n = C_hack::sizeof[typeof(x)]; get_sockopt(s,o,&x,&n); return x; }
  private gen get_bool(s:zmq_socket, o: zmq_sockopts_tag) = { return get_int(s,o)!=0; } 
  private gen get_file(s:zmq_socket, o: zmq_sockopts_tag) = { 
    var x:file; var n = C_hack::sizeof[typeof(x)]; get_sockopt(s,o,&x,&n); return x; }
  private gen get_socket_type(s:zmq_socket, o: zmq_sockopts_tag) = { 
    var x:zmq_socket_type_t; var n = C_hack::sizeof[typeof(x)]; get_sockopt(s,o,&x,&n); return x; }
  private gen get_string(s:zmq_socket, o: zmq_sockopts_tag) : string = { 
    var x:array[char,256]; var n = 256uz; get_sockopt(s,o,carray &x,&n); return string(carray &x,n); }
  private gen get_pollitem(s:zmq_socket, o: zmq_sockopts_tag) = { 
    var x:zmq_pollitem_flag_t; var n = C_hack::sizeof[typeof(x)]; get_sockopt(s,o,&x,&n); return x; }


  gen getsockopt(s: zmq_socket, o: zmq_sockopts_tag) : zmq_socket_options =>
    match o with
    | $(ZMQ_AFFINITY)          => zmq_affinity (get_uint64(s, o))
    | $(ZMQ_IDENTITY)          => zmq_identity (get_string(s, o))
    | $(ZMQ_SUBSCRIBE)         => zmq_subscribe (get_string(s, o))
    | $(ZMQ_UNSUBSCRIBE)       => zmq_unsubscribe (get_string(s, o))
    | $(ZMQ_RATE)              => zmq_rate (get_int(s, o))
    | $(ZMQ_RECOVERY_IVL)      => zmq_recovery_ivl (get_int(s, o))
    | $(ZMQ_SNDBUF)            => zmq_sndbuf (get_int(s, o))
    | $(ZMQ_RCVBUF)            => zmq_rcvbuf (get_int(s, o))
    | $(ZMQ_RCVMORE)           => zmq_rcvmore (get_bool(s, o))
    | $(ZMQ_FD)                => zmq_fd (get_file(s, o))
    | $(ZMQ_EVENTS)            => zmq_events (get_pollitem(s, o))
    | $(ZMQ_TYPE)              => zmq_type (get_socket_type(s, o))
    | $(ZMQ_LINGER)            => zmq_linger (get_int(s, o))
    | $(ZMQ_RECONNECT_IVL)     => zmq_reconnect_ivl (get_int(s, o))
    | $(ZMQ_BACKLOG)           => zmq_backlog (get_int(s, o))
    | $(ZMQ_RECONNECT_IVL_MAX) => zmq_reconnect_ivl_max (get_int(s, o))
    | $(ZMQ_MAXMSGSIZE)        => zmq_maxmsgsize (get_int64(s, o))
    | $(ZMQ_SNDHWM)            => zmq_sndhwm (get_int(s, o))
    | $(ZMQ_RCVHWM)            => zmq_rcvhwm (get_int(s, o))
    | $(ZMQ_MULTICAST_HOPS)    => zmq_multicast_hops (get_int(s, o))
    | $(ZMQ_RCVTIMEO)          => zmq_rcvtimeo (get_int(s, o))
    | $(ZMQ_SNDTIMEO)          => zmq_sndtimeo (get_int(s, o))
    | $(ZMQ_IPV4ONLY)          => zmq_ipv4only (get_bool(s, o))
  ;
 
  gen zmq_close: zmq_socket -> int;
  gen zmq_bind : zmq_socket * string -> int = "zmq_bind($1, $2.c_str())";
  gen zmq_connect : zmq_socket * string -> int = "zmq_connect($1, $2.c_str())";

/******************************************************************************/
/*  Send/recv                                                                 */
/******************************************************************************/

  pod type zmq_xmit_options_t = "int";
  const ZMQ_XMIT_OPTIONS_NONE : zmq_xmit_options_t = "0";
  const ZMQ_DONTWAIT : zmq_xmit_options_t;
  const ZMQ_SNDMORE : zmq_xmit_options_t;
  instance Eq[zmq_xmit_options_t] {
    fun == : zmq_xmit_options_t * zmq_xmit_options_t -> bool = "$1==$2";
  }

 
  gen zmq_send : zmq_socket * address * size * zmq_xmit_options_t -> int;
  gen zmq_recv : zmq_socket * address * size * zmq_xmit_options_t -> int;
  gen zmq_sendmsg : zmq_socket * zmq_msg_t * zmq_xmit_options_t  -> int;
  gen zmq_recvmsg : zmq_socket * zmq_msg_t * zmq_xmit_options_t -> int;

/******************************************************************************/
/*  I/O multiplexing.                                                         */
/******************************************************************************/

  type zmq_pollitem_flag_t = "short";
  const ZMQ_POLLIN : zmq_pollitem_flag_t;
  const ZMQ_POLLOUT : zmq_pollitem_flag_t;
  const ZMQ_POLLERR : zmq_pollitem_flag_t;
  instance Bits[zmq_pollitem_flag_t] {}
  instance Str[zmq_pollitem_flag_t] {
    fun str(x:zmq_pollitem_flag_t) => "Some flag here";
  }

  type zmq_poll_item = "zmq_pollitem_t";
  cstruct zmq_pollitem_t {
    socket:zmq_socket;
    fd: file;
    events:short;
    revents:short;
  };

  gen zmq_poll: &zmq_pollitem_t * int * long -> int;
}

open Eq[ZeroMQ::zmq_socket_type_t];
open Str[ZeroMQ::zmq_socket_type_t];

open Eq[ZeroMQ::zmq_xmit_options_t];

open Eq[ZeroMQ::zmq_sockopts_tag];
open Str[ZeroMQ::zmq_sockopts_tag];

open Str[ZeroMQ::zmq_socket_options];
open Str[ZeroMQ::zmq_pollitem_flag_t];

