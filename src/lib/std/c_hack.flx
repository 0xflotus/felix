publish """
This class provides access to raw C/C++ encodings.
Incorrect typing is likely to pass by Felix and
be trapped by the C/C++ compiler. Incorrect management
of storage can lead to corruption. The use of the
C_hack class is necessary for interfacing.
"""
class C_hack
{
  publish "C void"
  incomplete type void_t = "void";

  publish "standard variable argument list pointer type"
  type va_list = "va_list";

  publish """
  GCC specific valist thingo: it will
  be optimised away if not used (eg on MSVC)
  """
  type __builtin_va_list = '__builtin_va_list';

  publish """
  Throw away result of a function call:
  only useful for C functions that are mainly
  called for side effects.
  """
  proc ignore[t]:t = "(void)$t;";

  fun cast[dst,src]: src->dst = '(?1)($1:assign)' is cast;
  fun static_cast[dst,src]: src->dst = 'static_cast<?1>($1)' is postfix;
  fun dynamic_cast[dst,src]: src->dst = 'dynamic_cast<?1>($1)' is postfix;
  fun const_cast[dst,src]: src->dst = 'const_cast<?1>($1)' is postfix;
  fun reinterpret_cast[dst,src]: src->dst = 'reinterpret_cast<?1>($1)' is postfix;
  fun reinterpret[dst,src]: src->dst = 'reinterpret<?1>($1)' is postfix;

  const sizeof[t]:size = 'sizeof(?1)';

  // deprecated
  fun int_of:size->int='$1';
  fun size_of:int->size='$1';

  publish "Pointer equality"
  fun eq[T]: gcptr[T] * gcptr[T] -> bool = "$1==$2";
  fun ne[T]: gcptr[T] * gcptr[T] -> bool = "$1!=$2";

  lvalue fun deref[t]: gcptr[t] -> t = "*$1";

  fun isNULL[t]: &t -> bool = "(0==$1)";
  fun isNULL[t]: gcptr[t] -> bool = "(0==$1)";

  publish """
  Polymorphic null pointer constant
  """
  const null[t]:&t = "(?1*)NULL";

  header dflt_h = "template<class T> T dflt() { return T(); }";
  publish """
  Workaround for g++ 3.2.2 parsing bug,
  it can parse T() as a default ctor call,
  but screws up on (T())
  """
  fun dflt[t]:1->t = "dflt<?1>()" requires dflt_h;

  body checked_malloc = """
    void *checked_malloc(size_t n) {
      void *p = ::std::malloc(n);
      if(p) return p;
      else throw "out of memory";
    }
  """; 
  // raw allocation and deallocation
  gen raw_malloc: !ints -> address = '::std::malloc($1)' requires Cxx_headers::cstdlib;
  gen malloc: !ints -> address = 'checked_malloc($1)' requires Cxx_headers::cstdlib, checked_malloc;
  proc free: address = '::std::free($1);' requires Cxx_headers::cstdlib;
}


