// NOTES: The Felix type 'address' is the correct type for Judy Word
// However it is also an unsigned integer type (int or long depending
// on platform)
//
// But Felix doesn't support automatic int/address conversions
//
// So we will (later) use a typeset to fix this!
module Judy
{
  requires package "judy";
  requires header "#include <Judy.h>";
  open C_hack;

  type word = "Word_t";
  fun _ctor_word: int -> word = "(Word_t)$1";
  fun _ctor_int: word -> int = "(int)$1";
  fun _ctor_ulong: word -> ulong = "(unsigned long int)$1";

  type JError_t = "JError_t*";
  gen _ctor_JError_t : 1 -> JError_t = "(JError_t*)malloc(sizeof(JError_t))";
  proc free: JError_t = "free($1);";

  type J1Array = "void**";
  gen _ctor_J1Array: 1 -> J1Array = "_mkj1()" requires body
   """
     void **_mkj1(){
       void **m =(void**)malloc(sizeof(void*));
       *m=0;
       return m;
     }
   """;

  proc free: J1Array = "_j1free($1);" requires body
    """
      void _j1free(void **p) {
        JError_t je;
        Judy1FreeArray(p, &je); free(p);
      }
    """;

  proc Judy1Set: J1Array * word * JError_t * ptr[int] =
    "*$4=Judy1Set($1,$2,$3);";

  proc Judy1UnSet: J1Array * word * JError_t * ptr[int] =
    "*$4=Judy1UnSet($1,$2,$3);";

  proc Judy1Test: J1Array * word * JError_t * ptr[int] =
    "*$4=Judy1Test(*$1,$2,$3);";

  proc Judy1Count: J1Array * word * word* JError_t * ptr[word] =
    "*$5=Judy1Count(*$1,$2,$3,$4);";

  proc Judy1ByCount: J1Array * word * ptr[word] * JError_t * ptr[word] =
    "*$5=Judy1ByCount(*$1,$2,$3,$4);";

  proc Judy1FreeArray: J1Array * JError_t * ptr[word] =
    "*$3=Judy1Free($1,$2);";

  proc Judy1MemUsed: J1Array * ptr[word] = "*$2=Judy1MemUsed(*$1);";

  proc Judy1First: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1First(*$1,$2,$3);";

  proc Judy1Next: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1Next(*$1,$2,$3);";

  proc Judy1Last: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1Last(*$1,$2,$3);";

  proc Judy1Prev: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1Prev(*$1,$2,$3);";

  proc Judy1FirstEmpty: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1FirstEmpty(*$1,$2,$3);";

  proc Judy1NextEmpty: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1NextEmpty(*$1,$2,$3);";

  proc Judy1LastEmpty: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1LastEmpty(*$1,$2,$3);";

  proc Judy1PrevEmpty: J1Array * ptr[word] * JError_t * ptr[int] =
    "*$4=Judy1PrevEmpty(*$1,$2,$3);";

///////////////////////////////////////

  type JLArray = "void**";
  gen _ctor_JLArray: 1 -> JLArray = "_mkjL()" requires body
   """
     void **_mkjL(){
       void **m =(void**)malloc(sizeof(void*));
       *m=0;
       return m;
     }
   """;

  proc free: JLArray = "_jLfree($1);" requires body
    """
      void _jLfree(void **p) { JudyLFreeArray(p); free(p); }
    """;

  proc JudyLIns: JLArray * word * JError_t * ptr[ptr[word]] =
    "*(Word_t**)$4=(Word_t*)JudyLIns($1,$2,$3);";

  proc JudyLDel: JLArray * word * JError_t * ptr[int] =
    "*$4=JudyLDel($1,$2,$3);";

  proc JudyLGet: JLArray * word * JError_t * ptr[ptr[word]] =
    "*$4=(Word_t*)JudyLGet(*$1,$2,$3);";

  proc JudyLCount: JLArray * word * word * JError_t * ptr[word] =
    "*$5=JudyLCount(*$1,$2,$3,$4);";

  proc JudyLByCount: JLArray * word * ptr[word] * JError_t * ptr[ptr[word]] =
    "*$5=JudyLCount(*$1,$2,$3,$4);";

  proc JudyLFreeArray: JLArray * JError_t * ptr[word] =
    "*$3=JudyLFree($1,$2);";

  proc JudyLMemUsed: JLArray * ptr[word] =
    "*$2=JudyLMemUsed(*$1);";

  proc JudyLFirst: JLArray * ptr[word] * JError_t * ptr[ptr[word]] =
    "*(Word_t**)$4=(Word_t*)JudyLFirst(*$1,$2,$3);";

  proc JudyLNext: JLArray * ptr[word] * JError_t * ptr[ptr[word]] =
    "*(Word_t**)$4=(Word_t*)JudyLNext(*$1,$2,$3);";

  proc JudyLLast: JLArray * ptr[word] * JError_t * ptr[ptr[word]] =
    "*$4=JudyLLast(*$1,$2,$3);";

  proc JudyLPrev: JLArray * ptr[word] * JError_t * ptr[ptr[word]] =
    "*$4=JudyLPrev(*$1,$2,$3);";

  proc JudyLFirstEmpty: JLArray * ptr[word] * JError_t * ptr[word] =
    "*$4=JudyLFirstEmpty(*$1,$2,$3);";

  proc JudyLNextEmpty: JLArray * ptr[word] * JError_t * ptr[word] =
    "*$4=JudyLNextEmpty(*$1,$2,$3);";

  proc JudyLLastEmpty: JLArray * ptr[word] * JError_t * ptr[word] =
    "*$4=JudyLLastEmpty(*$1,$2,$3);";

  proc JudyLPrevEmpty: JLArray * ptr[word] * JError_t * ptr[word] =
    "*$4=JudyLPrevEmpty(*$1,$2,$3);";

  type JHSArray = "void**";
  gen _ctor_JHSArray: 1 -> JHSArray = "_mkjHS()" requires body
   """
     void **_mkjHS(){
       void **m =(void**)malloc(sizeof(void*));
       *m=0;
       return m;
     }
   """;

  proc free: JHSArray = "_jHSfree($1);" requires body
    """
      void _jHSfree(void **p) { JudyHSFreeArray(p); free(p); }
    """;

  proc JudyHSIns: JHSArray * address * word * JError_t * ptr[ptr[word]] =
    "*$5=(Word_t*)JudyHSIns($1,$2,$3,$4);";

  proc JudyHSDel: JHSArray * address * word * JError_t * ptr[int] =
    "*$5=JudyHSDel($1,$2,$3,$4);";

  proc JudyHSGet: JHSArray * address * word * JError_t * ptr[ptr[word]] =
    "*$5=(Word_t*)JudyHSGet(*$1,$2,$3);";

}
