module Sqlite3 {
  requires package "flx_sqlite3";

  // type of a database handle
  type sqlite3_db_t = "sqlite3*";

  // database open and close
  gen sqlite3_open : string * &sqlite3_db_t -> int =
    "sqlite3_open($1.c_str(), $2)"
  ;
  proc sqlite3_close : sqlite3_db_t = "sqlite3_close($1);";

  typedef sqlite3_exec_callback_t = 
    address      // client data pointer established by call to sqlite3_exec 
    * int        // number of result columns
    * +(+char)   // column value as text
    * +(+char)   // column name
    --> int
  ;

  // quick sql execution
  gen sqlite3_exec : // with callback
    sqlite3_db_t                            // db
    * string                                // sql
    * sqlite3_exec_callback_t * address     // callback with client data pointer
    *  &(+char)                             // pointer to error message epointer
    -> int =
    "sqlite3_exec($1,$2.c_str(),$3,$4,$5)"
  ;

  // quick sql execution with data handler callback
  gen sqlite3_exec : // without callback
    sqlite3_db_t // db
    * string     // sql
    * &(+char)   // ptr to errmsg pointer
    -> int =
    "sqlite3_exec($1,$2.c_str(),0,0,$3)"
  ;


  // error message extractor
  gen sqlite3_errmsg : sqlite3_db_t -> +char=
    "(char*)sqlite3_errmsg($1)"
  ;
}

syntax sql { // see: http://www.sqlite.org/lang.html
  // core
  table_name := sname =># "_1";
  database_name := sname =># "_1";
  index_name := sname =># "_1";

  database_filename : string = strstring;
  filename : string = strstring;
  delim : string = strstring; // ??

  sql_statement : string = "alter" "table" (sql_database_name "." )? table_name alteration;
  alteration : string = "rename" "to" table_name;
  alteration : string = "add" "column"? column_def;

  sql_statement :string = "analyse" ((database_name ".")? table_name)?;

  sql_statement : string = "attach" "database"? database_filename "as" database_name;
  sql_statement : string = "begin"
    ("deferred" | "immediate" | "exclusive" | "transaction" sname?)?;

  sql_statement : string = "end" ("transaction" sname?)?;
  sql_statement : string = "commit" ("transaction" sname?)?;
  sql_statement : string = "rollback" ("transaction" sname?)?;

  sql_statement : string = "copy" ("or" conflict_algorithm)? (database_name ".")? table_name
    "from" filename ("using" "delimiters" delim);

  sql_statement : string = "create" "unique"? "index" ("if" "not" "exists")?
    (database_name ".")? index_name "on" table_name lpar column_name (, column_name)* rpar;
  column_name := sname ("collate" collation_name) ("asc" | "desc")?;

  sql_command : string =
    "create" ("temp" | "temporary")? table
      ("if" "not" "exists")? (database_name ".")? table_name
      lpar column_def (, column_def)* (, constraint)?* rpar
  ;
  sql_command : string = "create" ("temp" | "temporary")? "table" (database_name ".")? table_name "as" select_statement ;
  column_def : string =	sname sql_type? (constraint name? column_constraint)* ;
  sql_type : string = 	typename |
    typename lpar number rpar |
    typename lpar number , number rpar
  ;
  column_constraint : string =
    "not" "null" conflict_clause? |
    "primary" "key" sort_order? conflict_clause? "autoincrement"? |
    "unique" conflict_clause? |
    "check" lpar expr rpar |
    "default" value |
    "collate" collation_name
  ;
  constraint : string = "primary" "key" lpar column_list rpar conflict_clause? |
    "unique" lpar column_list rpar conflict_clause? |
    "check" lpar expr rpar
  ;
  conflict_clause : string = "on" "conflict" conflict_algorithm;
}
