open class Schannel 
{
  // the type of bidirectional, input and output synchronous channels
  _gc_pointer type schannel[t] = "::flx::rtl::schannel_t*";
  _gc_pointer type ischannel[t] = "::flx::rtl::schannel_t*";
  _gc_pointer type oschannel[t] = "::flx::rtl::schannel_t*";

  gen mk_schannel[t]: 1->schannel[t] =
    "new(*PTF gcp,::flx::rtl::schannel_ptr_map,false) ::flx::rtl::schannel_t(PTF gcp)"
    requires property "needs_gc"
  ;

  // safe casts from bidirectional to unidirectional channels
  ctor[t] oschannel[t](x:schannel[t]) => C_hack::cast[oschannel[t]] x;
  ctor[t] ischannel[t](x:schannel[t]) => C_hack::cast[ischannel[t]] x;

  // make an input and an output channel out of a bidirectional channel
  gen mk_ioschannel_pair[t](var ch:schannel[t]) =>
    ischannel[t] ch, oschannel[t] ch
  ;

  // construct a connected input and output channel pair
  gen mk_ioschannel_pair[t]() =>
    mk_ioschannel_pair[t]$ mk_schannel[t] ()
  ;

  // read an item from a bidirectional channel
  inline gen read[T] (chan:schannel[T]) = {
    var loc: gcptr[T];
    svc$ svc_sread$ C_hack::cast[_schannel] chan, C_hack::reinterpret[&gcaddress] (&loc);
    return C_hack::deref loc;
  }

  // read an item from an input channel
  inline gen read[T] (chan:ischannel[T]) => read$ C_hack::cast[schannel[T]] chan;

  // write an item to a bidirectional channel
  proc write[T] (chan:schannel[T], v:T) {
    var ps = C_hack::cast[gcaddress]$ new v;
    svc$ svc_swrite$ C_hack::cast[_schannel] chan, &ps;
  }
 
  // write an item to an output channel
  proc write[T] (chan:oschannel[T], v:T) { write (C_hack::cast[schannel[T]] chan, v); }
}
