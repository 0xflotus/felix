include "std/posix/errno";

module FileStat
{
  //------------------------------------------------------------
  // stat
  //------------------------------------------------------------
  pod type stat_t = "struct stat" requires Posix_headers::sys_stat_h;
  proc stat: string * &stat_t * &int = "*$3=stat($1.c_str(),$2);";
  gen stat(file: string, statbuf:&stat_t) = { 
    var res: int; 
    stat(file, statbuf, &res); 
    return res == 0;
  }

  //------------------------------------------------------------
  // access and modification times
  //------------------------------------------------------------
  body _mktim_fun = """
    unsigned long _mktim(struct timespec x){ 
     return x.tv_sec * 1000L + x.tv_nsec /1000L; // milliseconds
    }
  """;
  pod type time_t = "time_t";
  fun mtime: &stat_t -> uvlong = "(unsigned long)($1->st_mtime * 1000ul)";

  // get modification time of a file
  fun filetime(f:string):uvlong = // milliseconds
  {
    var b: stat_t;
    var err:int;
    stat(f,&b,&err);
    return if err == 0 then mtime (&b) else uvlong 0 endif;
  }

  // set access and modification time of a file
  proc utime: string * uvlong * uvlong * &int = 
  """
    {
    utimbuf u; 
    u.actime=(time_t)$2/1000;
    u.modtime=(time_t)$3/1000;
    *$4 = utime($1.c_str(),&u); 
    }
  """
  requires Posix_headers::utime_h;

  gen utime(f:string, a:uvlong, m:uvlong): bool = {
    var r:int;
    utime(f,a,m,&r);
    return r == 0;
  }
  gen utime(f:string, t:uvlong) => utime(f,t,t);

  fun fileexists(f:string):bool=> filetime f != uvlong 0;

  //------------------------------------------------------------
  // file mode: type and permissions
  //------------------------------------------------------------
  ctypes mode_t requires Posix_headers::sys_types_h;
  // file types
  const S_IFMT  : mode_t; // file type mask
  const S_IFIFO : mode_t;
  const S_IFCHR : mode_t;
  const S_IFDIR : mode_t;
  const S_IFBLK : mode_t;
  const S_IFREG : mode_t;
  const S_IFLNK : mode_t;
  const S_IFSOCK: mode_t;

  // permissions
  const S_IRWXU : mode_t; // RWX mask: owner
  const S_IRUSR : mode_t;
  const S_IWUSR : mode_t;
  const S_IXUSR : mode_t;

  const S_IRWXG : mode_t; // RWX mask: group
  const S_IRGRP : mode_t;
  const S_IWGRP : mode_t;
  const S_IXGRP : mode_t;

  const S_IRWXO : mode_t; // RWX mask: other
  const S_IROTH : mode_t;
  const S_IWOTH : mode_t;
  const S_IXOTH : mode_t;

  const S_ISUID : mode_t; // set user id on execute
  const S_ISGID : mode_t; // set group id on execute
  const S_ISVXT : mode_t; // sticky bit

  fun bnot : mode_t -> mode_t = "~$1";
  fun bor : mode_t * mode_t -> mode_t = "$1|$2";
  fun band : mode_t * mode_t -> mode_t = "$1&$2";
  fun eq: mode_t * mode_t -> bool = "$1==$2";

  val access_mask = S_IXOTH \| S_IXGRP \| S_IXUSR;

  gen chmod: string * mode_t -> int = "chmod($1.c_str(),$2)" requires Posix_headers::sys_stat_h;

  fun raw_mode: &stat_t -> mode_t = "$1->st_mode";
  fun file_type(m:mode_t)=>m \& S_IFMT;
  fun file_perm(m:mode_t)=>m \& ~S_IFMT;

  ctor uint: mode_t = "(unsigned int)$1";

  union file_type_t = 
    | PIPE 
    | STREAM 
    | DIRECTORY 
    | BLOCK 
    | REGULAR 
    | SYMLINK 
    | SOCKET 
    | INDETERMINATE
    | NONEXISTANT
    | NOPERMISSION
  ;

  fun file_type (s:&stat_t): file_type_t =>
    let ?m = file_type$ raw_mode s in
    if m == S_IFIFO then PIPE
    elif m == S_IFCHR then STREAM
    elif m == S_IFDIR then DIRECTORY
    elif m == S_IFBLK then BLOCK
    elif m == S_IFREG then REGULAR
    elif m == S_IFLNK then SYMLINK
    elif m == S_IFSOCK then SOCKET
    else INDETERMINATE
    endif
  ;

  gen umask: mode_t -> mode_t = "umask($1)";

  fun filetype(f:string):file_type_t = 
  {
    var b:stat_t;
    var err:int;
    stat(f,&b,&err);
    return 
      if err == 0 then file_type (&b)
      elif errno == EACCES then NOPERMISSION
      elif errno == ENOENT then NONEXISTANT  
      else INDETERMINATE
      endif
    ;
  }

}

