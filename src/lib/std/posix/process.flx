// Posix process stuff
include "std/posix/posix_headers";
include "std/posix/errno";
include "std/posix/signal";

class Process {
  open Posix_Signal;

  gen popen_in: string -> Text_file::input_text_file = 'popen($1.c_str(), "r")';
  gen pclose: Text_file::input_text_file -> process_status_t = "pclose($1)";

  type process_status_t = "int";

  gen WIFCONTINUED: process_status_t -> bool = "WIFCONTINUED($1)!=0";
  gen WIFEXITED: process_status_t -> int = "WIFEXITED($1)!=0";
  gen WISIGNALED: process_status_t -> int = "WISIGNALED($1)!=0";
  gen WIFSTOPPED: process_status_t -> int = "WIFSTOPPED($1)!=0";

  gen WEXITSTATUS: process_status_t -> int = "WEXITSTATUS($1)";
  gen WTERMSIG: process_status_t -> signal_t = "WTERMSIG($1)";
  gen WSTOPSIG: process_status_t -> signal_t = "WSTOPSIG($1)";

  // OSX only, not in Posix
  gen WCOREDUMP: process_status_t -> int = "WCOREDUMP($1)";


  const environ: &&char = "environ" requires Posix_headers::unistd_h;

  type exec_result_t = "int";
  const bad_exec: exec_result_t = "-1";
  fun == : exec_result_t * exec_result_t -> bool= "$1==$2";

  gen execv:&char *  &&char -> exec_result_t = "execv($1, $2)" requires Posix_headers::unistd_h;
  gen execvp:&char *  &&char -> exec_result_t = "execvp($1, $2)" requires Posix_headers::unistd_h;
  gen execve:&char *  &&char * &&char -> exec_result_t = "execve($1, $2, $3)" requires Posix_headers::unistd_h;

  // do NOT try to fork Felix programs, it doesn't work
  // because of threads already running. We use fork only
  // to preceed exec() calls.
  type pid_t = "pid_t" requires Posix_headers::unistd_h;
  ctor int: pid_t = "((int)$1)";
  const child_process : pid_t = "0";
  const bad_process : pid_t = "-1";
  fun == : pid_t * pid_t -> bool= "$1==$2";

  gen fork: unit -> pid_t = "fork()" requires Posix_headers::unistd_h;

  union spawn_result_t = | Error of errno_t | Process of pid_t;

  gen spawnv(file: string, argv:&&char) : spawn_result_t = {
    var x = fork();
    if x == child_process do 
      var y = execv(file.cstr, argv); 
      if y == bad_exec do 
        return Error errno; 
      else 
        return Process x; // never taken! 
      done 
    elif x == bad_process do return Error errno;
    else return Process x;
    done
  }

  gen spawnvp(file: string, argv:&&char) : spawn_result_t = { 
    var x = fork();
    if x == child_process do 
      var y = execvp(file.cstr, argv); 
      if y == bad_exec do 
        return Error errno; 
      else 
        return Process x; // never taken! 
      done 
    elif x == bad_process do return Error errno;
    else return Process x;
    done
  }

  gen spawnve(file: string, argv:&&char, env: &&char) : spawn_result_t = {
    var x = fork();
    if x == child_process do 
      var y = execve(file.cstr, argv, env); 
      if y == bad_exec do 
        return Error errno; 
      else 
        return Process x; // never taken! 
      done 
    elif x == bad_process do return Error errno;
    else return Process x;
    done
  }

  // implement waitpid here ..
}
