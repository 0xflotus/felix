include "std/posix/posix_headers";
include "std/posix/errno";
include "std/posix/time";
module FileSystem 
{
  //------------------------------------------------------------
  // stat
  //------------------------------------------------------------
  pod type stat_t = "struct stat" requires Posix_headers::sys_stat_h;
  proc stat: string * &stat_t * &int = "*$3=stat($1.c_str(),$2);";
  gen stat(file: string, statbuf:&stat_t) = { 
    var res: int; 
    stat(file, statbuf, &res); 
    return res == 0;
  }

  //------------------------------------------------------------
  // access and modification times
  //------------------------------------------------------------
  body _mktim_fun = """
    unsigned long _mktim(struct timespec x){ 
     return x.tv_sec * 1000L + x.tv_nsec /1000L; // milliseconds
    }
  """;
  pod type time_t = "time_t";
  fun mtime: &stat_t -> uvlong = "(unsigned long)($1->st_mtime * 1000ul)";

  // get modification time of a file
  fun filetime(f:string):uvlong = // milliseconds
  {
    var b: stat_t;
    var err:int;
    stat(f,&b,&err);
    return if err == 0 then mtime (&b) else uvlong 0 endif;
  }

  // set access and modification time of a file
  proc utime: string * uvlong * uvlong * &int = 
  """
    {
    utimbuf u; 
    u.actime=(time_t)$2/1000;
    u.modtime=(time_t)$3/1000;
    *$4 = utime($1.c_str(),&u); 
    }
  """
  requires Posix_headers::utime_h;

  gen utime(f:string, a:uvlong, m:uvlong): bool = {
    var r:int;
    utime(f,a,m,&r);
    return r == 0;
  }
  gen utime(f:string, t:uvlong) => utime(f,t,t);

  fun fileexists(f:string):bool=> filetime f != uvlong 0;

  //------------------------------------------------------------
  // file mode: type and permissions
  //------------------------------------------------------------
  ctypes mode_t requires Posix_headers::sys_types_h;
  // file types
  const S_IFMT  : mode_t; // file type mask
  const S_IFIFO : mode_t;
  const S_IFCHR : mode_t;
  const S_IFDIR : mode_t;
  const S_IFBLK : mode_t;
  const S_IFREG : mode_t;
  const S_IFLNK : mode_t;
  const S_IFSOCK: mode_t;

  // permissions
  const S_IRWXU : mode_t; // RWX mask: owner
  const S_IRUSR : mode_t;
  const S_IWUSR : mode_t;
  const S_IXUSR : mode_t;

  const S_IRWXG : mode_t; // RWX mask: group
  const S_IRGRP : mode_t;
  const S_IWGRP : mode_t;
  const S_IXGRP : mode_t;

  const S_IRWXO : mode_t; // RWX mask: other
  const S_IROTH : mode_t;
  const S_IWOTH : mode_t;
  const S_IXOTH : mode_t;

  const S_ISUID : mode_t; // set user id on execute
  const S_ISGID : mode_t; // set group id on execute
  const S_ISVXT : mode_t; // sticky bit

  fun bnot : mode_t -> mode_t = "~$1";
  fun bor : mode_t * mode_t -> mode_t = "$1|$2";
  fun band : mode_t * mode_t -> mode_t = "$1&$2";
  fun eq: mode_t * mode_t -> bool = "$1==$2";

  val access_mask = S_IXOTH \| S_IXGRP \| S_IXUSR;

  gen chmod: string * mode_t -> int = "chmod($1.c_str(),$2)" requires Posix_headers::sys_stat_h;

  fun raw_mode: &stat_t -> mode_t = "$1->st_mode";
  fun file_type(m:mode_t)=>m \& S_IFMT;
  fun file_perm(m:mode_t)=>m \& ~S_IFMT;

  ctor uint: mode_t = "(unsigned int)$1";

  union file_type_t = 
    | PIPE 
    | STREAM 
    | DIRECTORY 
    | BLOCK 
    | REGULAR 
    | SYMLINK 
    | SOCKET 
    | INDETERMINATE
    | NONEXISTANT
    | NOPERMISSION
  ;

  fun file_type (s:&stat_t): file_type_t =>
    let ?m = file_type$ raw_mode s in
    if m == S_IFIFO then PIPE
    elif m == S_IFCHR then STREAM
    elif m == S_IFDIR then DIRECTORY
    elif m == S_IFBLK then BLOCK
    elif m == S_IFREG then REGULAR
    elif m == S_IFLNK then SYMLINK
    elif m == S_IFSOCK then SOCKET
    else INDETERMINATE
    endif
  ;

  gen umask: mode_t -> mode_t = "umask($1)";

  fun filetype(f:string):file_type_t = 
  {
    var b:stat_t;
    var err:int;
    stat(f,&b,&err);
    return 
      if err == 0 then file_type (&b)
      elif errno == EACCES then NOPERMISSION
      elif errno == ENOENT then NONEXISTANT  
      else INDETERMINATE
      endif
    ;
  }

  //------------------------------------------------------------
  // File access and create modes
  //------------------------------------------------------------
  pod type file_perm_t = "int" requires Posix_headers::fcntl_h;
  const O_RDONLY     : file_perm_t;
  const O_WRONLY     : file_perm_t;
  const O_RDWR       : file_perm_t;
  const O_NONBLOCK   : file_perm_t;
  const O_APPEND     : file_perm_t;
  const O_CREAT      : file_perm_t;
  const O_TRUNC      : file_perm_t;
  const O_EXCL       : file_perm_t;
  const O_SHLOCK     : file_perm_t;
  const O_EXLOCK     : file_perm_t;
  const O_NOFOLLOW   : file_perm_t;
  const O_SYMLINK    : file_perm_t;
  const O_EVTONLY    : file_perm_t;
  fun band : file_perm_t * file_perm_t -> file_perm_t = "$1&$2";
  fun bor  : file_perm_t * file_perm_t -> file_perm_t = "$1|$2";

  //------------------------------------------------------------
  // File I/O functions
  //------------------------------------------------------------
  pod type posix_file = "int";
  fun valid: posix_file -> bool = "$1 != -1";
  ctor int : posix_file = "$1";

  gen open: string * file_perm_t * mode_t -> posix_file = "open($1.c_str(), $2, $3)";
  gen open: string * file_perm_t -> posix_file = "open($1.c_str(), $2)";
  gen close: posix_file -> int = "close($1)";
  gen read: posix_file * &char * size -> size = "read($1, $2, $3)";
  gen write: posix_file * &char * size -> size = "write($1, $2, $3)";


  //------------------------------------------------------------
  // copy a file, preserving last access and modification times
  // owner, group, and permissions
  //------------------------------------------------------------
  gen filecopy(src: string, dst: string) :  bool =
  {
    //println$ "Copy " + src + " -> " + dst;

    val now = (Time::time()).uvlong/1000ull; // milliseconds
    var stat_buf:stat_t;
    if not stat (src, &stat_buf) do
      println$ "Can't stat source file " + src;
      return false;
    done;
    val permissions = file_perm$ raw_mode (&stat_buf);
    val last_modification = filetime(src);
    var fsrc = open (src,O_RDONLY );
    if not valid fsrc do
      println$ " Bad src file in Filesystem::filecopy " + src;
      return false; 
    done
    var fdst = open (dst,O_WRONLY \| O_CREAT \| O_TRUNC, permissions);
    if not valid fdst do
      println$ " Bad dst file in Filesystem::filecopy " + dst;
      return false; 
    done
    bsiz := size (4096 * 1024); // 4 Meg
    var buffer = C_hack::cast[&char] (C_hack::malloc(bsiz)); // 4 MEG
    var bread = read (fsrc, buffer, bsiz);
    while bread > size 0 do
      var bwrite = write (fdst,buffer,bread);
      if bread != bwrite do
        if bwrite.int == -1 do
          println$ 
            "Dest des = " + str fdst.int+ " "+
            "Attempt to copy " + str bread + " bytes from " + src + " to " + dst + 
            " failed with errno = " + str errno + ": " + strerror_r() 
          ;
        else
          println$ 
            "Attempt to copy " + str bread + " bytes from " + src + " to " + dst + 
            " failed with " +  str bwrite + " only copied!"
          ;
        done
      done
      bread = read (fsrc, buffer, bsiz);
    done
    var res = close fsrc;
    res = close fdst;
    C_hack::ignore(utime(dst,now,last_modification));
    C_hack::free(C_hack::cast[address] buffer);
    return true;
  }
  
  //------------------------------------------------------------
  // create directory
  //------------------------------------------------------------
  gen mkdir: string * mode_t -> int = "mkdir($1.c_str(), $2)";
  gen mkdir: string  -> int = "mkdir($1.c_str(), 0777)";

  //------------------------------------------------------------
  // directory searching
  //------------------------------------------------------------
  type dirent_t = "struct dirent*" requires Posix_headers::dirent_h;
  type DIR_t = "DIR*" requires Posix_headers::dirent_h;
  proc opendir: string * &DIR_t = "*$2=opendir($1.c_str());";
  fun isNULL: DIR_t -> bool = "$1==0";
  fun isNULL: dirent_t -> bool = "$1==0";
  proc readdir: DIR_t * dirent_t * &dirent_t * &int = "*$4=readdir_r($1, $2, $3);";
  proc closedir: DIR_t = "closedir($1);";
  fun filename: dirent_t -> string = "std::string($1->d_name)";

  fun filesin(dname:string): opt[List::list[string]] = {
    //println$ "filesin " + dname;
    var d:DIR_t;
    var e: dirent_t = C_hack::cast[dirent_t]$ C_hack::malloc 5000;
    var eret = e;
    var err:int = 0;
    var files = List::Empty[string];
    opendir(dname,&d);
    if isNULL d do 
      println "Error opening dir"; 
      C_hack::free$ C_hack::cast[address] e; 
      return None[List::list[string]];
    else
    //println$ "Opened dir " + dname;
next:>
      readdir(d,e,&eret, &err);
      if err != 0 do 
        println "Error reading dir"; flush;
        closedir d; 
        C_hack::free$ C_hack::cast[address] e; 
        return None[List::list[string]];
      elif isNULL eret do 
        //println "End of dir"; 
        closedir d; 
        C_hack::free$ C_hack::cast[address] e; 
        return Some files;
      else 
        //println "Think we got a file?";
        assert err == 0;
        //println$ "Found a file " + filename e; 
        files += filename e; 
        goto next;
      done
    done
  }

  // current directory
  private fun getcwd: &char * size -> &char = "getcwd($1,$2)" requires header '#include <unistd.h>';
  fun getcwd():string = {
    var b: array[char,1024]; 
    var p = getcwd(C_hack::cast[&char] (&b),size 1024);
    return if C_hack::isNULL p then "" else string p endif; 
  }

  // find in path
  fun find_in_path(x:string, path:list[string]):opt[string]=>
    match path with
    | Empty[string] => None[string]
    | Cons (?d,?t) => 
      let ?p =  Filename::join(d,x) in
      match fileexists p with
      | true => Some p
      | false => find_in_path (x,t)
      endmatch
    endmatch
  ;

  fun regfilesin(dname:string, re:string): list[string] => regfilesin(dname, Re2::RE2 re);

  private gen dbg (s:string) : int = { println s; return 0; }

  fun regfilesin(dname:string, re:RE2): list[string] = {
    fun rfi(dname2: string) =>   
      if dname2 == "." or dname2 == ".." then Empty[string] else
      match FileSystem::filesin(Filename::join (dname,dname2)) with
      | None  => Empty[string]
      | Some ?files =>
        {
        //println$ "got files in " + dname2;
        return
        List::fold_left 
          (fun (acc:list[string]) (f:string) => if f == "." or f == ".." then Empty[string] else
            let ?d = Filename::join (dname2,f) in
            let ?t = FileSystem::filetype (Filename::join (dname,d)) in
            match t with
              | REGULAR => 
                /*
                let ?xx = dbg ("found file " + d) in
                if xx == 0 and Re2::Match(re, Re2::StringPiece d, 0, Re2::ANCHOR_BOTH, C_hack::null[Re2::StringPiece], 0) 
                then field[1](dbg("matched "+d),acc + d) 
                else field[1](dbg("no match "+d),acc)
                endif
                */
                if Re2::Match(re, Re2::StringPiece d, 0, Re2::ANCHOR_BOTH, C_hack::null[Re2::StringPiece], 0) 
                then acc + d 
                else acc
                endif
              | DIRECTORY => acc + rfi (d)
              | _ => acc
            endmatch
            endif
          )
          Empty[string]
          files;
        }()
      endmatch
      endif
    ;
    return rfi ("");
  }
 
  
  //------------------------------------------------------------
  // generate temporary file name
  //------------------------------------------------------------
  body tmpnam = """
    string flx_tmpnam() {
      char tmpn[] = "/tmp/flx_XXXXXX";
      close(mkstemp(tmpn));
      return string(tmpn);
     }
  """ requires header '#include <unistd.h>';

  gen tmp_filename: string -> string = "flx_tmpnam($1)" requires tmpnam;
    
}

