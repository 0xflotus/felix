// note: has to be called Fcomplex to avoid clash with typeclass Complex
open module Fcomplex
{
  ctor[t in reals] fcomplex : t * t = "::std::complex<float>($1,$2)";
  ctor[t in reals] fcomplex : t = "::std::complex<float>($1,0)";
  proc fprint: ostream * fcomplex = "*$1<<$2;" requires Cxx_headers::iostream;
  instance Str[fcomplex] {
    fun str (z:fcomplex) => str(real z) + "+" + str(imag z)+"i";
  }
  instance Complex[fcomplex,float] {
    fun real : fcomplex -> float = "real($1)";
    fun imag : fcomplex -> float = "imag($1)";
    fun abs: fcomplex -> float = "abs($1)";
    fun arg : fcomplex -> float = "arg($1)";
    fun neg: fcomplex -> fcomplex = "-$1";
    fun add : fcomplex * fcomplex -> fcomplex = "$1+$2";
    fun sub: fcomplex * fcomplex -> fcomplex = "$1-$2";
    fun mul: fcomplex * fcomplex -> fcomplex = "$1*$2";
    fun div: fcomplex * fcomplex -> fcomplex = "$1/$2";
    fun add : fcomplex * float -> fcomplex = "$1+$2";
    fun sub: fcomplex * float -> fcomplex = "$1-$2";
    fun mul: fcomplex * float -> fcomplex = "$1*$2";
    fun div: fcomplex * float -> fcomplex = "$1/$2";
    fun add : float * fcomplex -> fcomplex = "$1+$2";
    fun sub: float * fcomplex -> fcomplex = "$1-$2";
    fun mul: float * fcomplex -> fcomplex = "$1*$2";
    fun div: float * fcomplex -> fcomplex = "$1/$2";
    fun zero(): fcomplex => fcomplex 0.0;
    fun one(): fcomplex => fcomplex 1.0;
  }
}

open module Dcomplex
{
  ctor[t in reals] dcomplex : t * t = "::std::complex<double>($1,$2)";
  ctor[t in reals] dcomplex : t = "::std::complex<double>($1,0)";
  proc fprint: ostream * dcomplex = "*$1<<$2;" requires Cxx_headers::iostream;
  instance Str[dcomplex] {
    fun str (z:dcomplex) => str(real z) + "+" + str(imag z)+"i";
  }
  instance Complex[dcomplex,double] {
    fun real : dcomplex -> double = "real($1)";
    fun imag : dcomplex -> double = "imag($1)";
    fun abs: dcomplex -> double = "abs($1)";
    fun arg : dcomplex -> double = "arg($1)";
    fun neg: dcomplex -> dcomplex = "-$1";
    fun add : dcomplex * dcomplex -> dcomplex = "$1+$2";
    fun sub: dcomplex * dcomplex -> dcomplex = "$1-$2";
    fun mul: dcomplex * dcomplex -> dcomplex = "$1*$2";
    fun div: dcomplex * dcomplex -> dcomplex = "$1/$2";
    fun add : dcomplex * double -> dcomplex = "$1+$2";
    fun sub: dcomplex * double -> dcomplex = "$1-$2";
    fun mul: dcomplex * double -> dcomplex = "$1*$2";
    fun div: dcomplex * double -> dcomplex = "$1/$2";
    fun add : double * dcomplex -> dcomplex = "$1+$2";
    fun sub: double * dcomplex -> dcomplex = "$1-$2";
    fun mul: double * dcomplex -> dcomplex = "$1*$2";
    fun div: double * dcomplex -> dcomplex = "$1/$2";
    fun zero(): dcomplex => dcomplex 0.0;
    fun one(): dcomplex => dcomplex 1.0;
  }
}

open module Lcomplex
{
  ctor[t in reals] lcomplex : t * t = "::std::complex<long double>($1,$2)";
  ctor[t in reals] lcomplex : t = "::std::complex<long double>($1,0)";
  proc fprint: ostream * lcomplex = "*$1<<$2;" requires Cxx_headers::iostream;
  instance Str[lcomplex] {
    fun str (z:lcomplex) => str(real z) + "+" + str(imag z)+"i";
  }
  instance Complex[lcomplex,ldouble] {
    fun real : lcomplex -> ldouble = "real($1)";
    fun imag : lcomplex -> ldouble = "imag($1)";
    fun abs: lcomplex -> ldouble = "abs($1)";
    fun arg : lcomplex -> ldouble = "arg($1)";
    fun neg: lcomplex -> lcomplex = "-$1";
    fun add : lcomplex * lcomplex -> lcomplex = "$1+$2";
    fun sub: lcomplex * lcomplex -> lcomplex = "$1-$2";
    fun mul: lcomplex * lcomplex -> lcomplex = "$1*$2";
    fun div: lcomplex * lcomplex -> lcomplex = "$1/$2";
    fun add : lcomplex * ldouble -> lcomplex = "$1+$2";
    fun sub: lcomplex * ldouble -> lcomplex = "$1-$2";
    fun mul: lcomplex * ldouble -> lcomplex = "$1*$2";
    fun div: lcomplex * ldouble -> lcomplex = "$1/$2";
    fun add : ldouble * lcomplex -> lcomplex = "$1+$2";
    fun sub: ldouble * lcomplex -> lcomplex = "$1-$2";
    fun mul: ldouble * lcomplex -> lcomplex = "$1*$2";
    fun div: ldouble * lcomplex -> lcomplex = "$1/$2";
    fun zero(): lcomplex => lcomplex 0.0;
    fun one(): lcomplex => lcomplex 1.0;
  }
}

instance[t in (floats || complexes)] Trig[t] {
  requires Cxx_headers::cmath;
  fun sin: t -> t = "::std::sin($1)";
  fun cos: t -> t = "::std::cos($1)";
  fun tan: t -> t = "::std::tan($1)";
  fun asin: t -> t = "::std::asin($1)";
  fun acos: t -> t = "::std::acos($1)";
  fun atan: t -> t = "::std::atan($1)";
  fun sinh: t -> t = "::std::sinh($1)";
  fun cosh: t -> t = "::std::cosh($1)";
  fun tanh: t -> t = "::std::tanh($1)";
  fun asinh: t -> t = "::std::asinh($1)";
  fun acosh: t -> t = "::std::acosh($1)";
  fun atanh: t -> t = "::std::atanh($1)";
  fun exp: t -> t = "::std::exp($1)";
  fun log: t -> t = "::std::log($1)";
  fun pow: t * t -> t = "::std::pow($1,$2)";
}

instance[t in floats] Real[t] {
  requires Cxx_headers::cmath;
  fun abs: t -> t = "::std::abs($1)";
  fun log10: t -> t = "::std::log10($1)";
  fun sqrt: t -> t = "::std::sqrt($1)";
  fun ceil: t -> t = "::std::ceil($1)";
  fun floor: t -> t = "::std::floor($1)";
  fun trunc: t -> t = "::std::trunc($1)";
}

typeclass CartComplex[r] {
  typedef t = complex[r];
  inherit Complex[t,r];
}

instance[r in floats] CartComplex[r] {}

open Real[float];
open Real[double];
open Real[ldouble];
open Complex[fcomplex, float];
open Complex[dcomplex, double];
open Complex[lcomplex, ldouble];
open CartComplex[float];
open CartComplex[double];
open CartComplex[ldouble];



