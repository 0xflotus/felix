
//$ Synchronous Pipe.
open class Spipe {

  //$ Send an stream down a channel.
  proc source[T] (var it:1 -> T, out:oschannel[T]) 
  {
    while true do write (out,#it); done 
  }

  //$ Wire a source component to a sink.
  //$ Return coupled fibre ready to run.
  fun pipe[T] 
    (w: oschannel[T] -> 0,
    r: ischannel[T] -> 0)
  :
    1 -> 0
  => 
    {
      var chi,cho = mk_ioschannel_pair[T] ();
      spawn_fthread { (w cho); };
      spawn_fthread { (r chi); };
    }
  ;

  //$ Wire a source component to a transducer.
  //$ Return source.
  fun pipe[T,U]
    (w: oschannel[T] -> 0,
    t: ischannel[T] * oschannel[U] -> 0)
  :
    oschannel[U] -> 0 
  => 
    proc (out:oschannel[U])
    {
      var chi,cho = mk_ioschannel_pair[T] ();
      spawn_fthread { (w cho); };
      spawn_fthread { (t (chi, out)); };
    }
  ;

  proc sort[T with Tord[T]] (r: ischannel[opt[T]], w: oschannel[opt[T]]) () 
  {
     var x = darray[T]();
     acquire:while true do
       match read r with
       | Some ?v => x+=v;
       | None => break acquire;
       endmatch;
     done
     x.sort;
     for v in x do
       write (w, Some v);
     done
     write (w,None[T]);
  }
}

