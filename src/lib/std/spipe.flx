
//$ Synchronous Pipe.
open class Spipe {

  //$ Send an stream down a channel.
  proc source[T] (var it:1 -> T) (out:oschannel[T]) 
  {
    while true do write (out,#it); done 
  }

  //$ isrc converts a streamable data structure
  //$ such as an array into a source.
  proc isrc[V,T with Streamable[T,V]] (dat:T) (out:oschannel[opt[V]])
  {
    source[opt[V]] (dat.iterator) out;
  }


  //$ Wire a source component to a sink.
  //$ Return coupled fibre ready to run.
  fun pipe[T] 
    (w: oschannel[T] -> 0,
    r: ischannel[T] -> 0)
  :
    1 -> 0
  => 
    {
      var chi,cho = mk_ioschannel_pair[T] ();
      spawn_fthread { (w cho); };
      spawn_fthread { (r chi); };
    }
  ;

  //$ Wire a source component to a transducer.
  //$ Return source.
  fun pipe[T,U]
    (w: oschannel[T] -> 0,
    t: ischannel[T] * oschannel[U] -> 0)
  :
    oschannel[U] -> 0 
  => 
    proc (out:oschannel[U])
    {
      var chi,cho = mk_ioschannel_pair[T] ();
      spawn_fthread { (w cho); };
      spawn_fthread { (t (chi, out)); };
    }
  ;

  //$ xpipe connects a streamable data structure
  //$ such as an array directly into a transducer.
  fun xpipe[V,T,U with Streamable[T,V]] 
    (
      a:T,
      t: ischannel[opt[V]] * oschannel[U] -> 0
    )
    : oschannel[U] -> 0 =>
    pipe (a.isrc[V],t)
  ;


  //$ Wire a transducer into a transducer.
  //$ Return another transducer.
  fun pipe[T,U,V]
    (a: ischannel[T] * oschannel[U] -> 0,
    b: ischannel[U] * oschannel[V] -> 0)
  :
    ischannel[T] * oschannel[V] -> 0 
  => 
    proc (inp:ischannel[T], out:oschannel[V])
    {
      var chi,cho = mk_ioschannel_pair[U] ();
      spawn_fthread { a (inp, cho); };
      spawn_fthread { b (chi, out); };
    }
  ;

  //$ Wire a transducer into a sink.
  //$ Return a sink.
  fun pipe[T,U]
    (a: ischannel[T] * oschannel[U] -> 0,
    b: ischannel[U] -> 0)
  :
    ischannel[T]  -> 0 
  => 
    proc (inp:ischannel[T])
    {
      var chi,cho = mk_ioschannel_pair[U] ();
      spawn_fthread { a (inp, cho); };
      spawn_fthread { b (chi); };
    }
  ;


  //$ Stream sort using intermediate darray.
  //$ Requires stream of option type.
  proc sort[T with Tord[T]] (r: ischannel[opt[T]], w: oschannel[opt[T]])
  {
     var x = darray[T]();
     acquire:while true do
       match read r with
       | Some ?v => x+=v;
       | None => break acquire;
       endmatch;
     done
     x.sort;
     for v in x do
       write (w, Some v);
     done
     write (w,None[T]);
  }
}

