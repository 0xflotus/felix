include "stl/stl_map";

module Re2 {
  requires package "re2";

// This is an almost full binding of Google's re2 package.
// We do not support conversions of digits strings to integers
//
// TODO: we need to check the lvalue handling here
// The RE2, Options classes aren't copyable, so we may have
// to use pointers
//
// TODO: named group extractor

  // this is all a biy hacky still
  private incomplete type RE2_ = "::re2::RE2";
  var re2_shape = link_shape[RE2_]();
  C_hack::ignore(re2_shape); // needed to stop Felix optimising the variable away
  type RE2 = "::re2::RE2*";

  // Uses gc heap, hacky reference to the shape variable!
  // That var better be initialised before calling this routine!
  // this code is works around the fact that Felix new always copies
  // a value onto the heap, re2::RE2 isn't copyable
  gen _ctor_RE2 : string -> RE2 = "new (*PTF gcp, *PTF re2_shape, false) RE2($1)";


  type StringPiece = "::re2::StringPiece";
    ctor StringPiece: string = "::re2::StringPiece($1)";
    ctor StringPiece: unit = "::re2::StringPiece()";
    ctor string: StringPiece = "$1.as_string()";
    fun len: StringPiece -> int = "$1.size()";

  type Arg = "::re2::Arg";

  type Encoding = "::re2::RE2::Encoding";
    const EncodingUTF8: Encoding = "::re2::RE2::EncodingUTF8";
    const EncodingLatin1: Encoding = "::re2::RE2::EncodingLatin1";

  type RE2Options = "::re2::RE2::Options";

    proc Copy: RE2Options * RE2Options = "$1.Copy($2);";

    fun encoding: RE2Options -> Encoding = "$1.encoding()";
    proc set_encoding: RE2Options * Encoding = "$1.set_encoding($2);";
    
    fun posix_syntax: RE2Options -> bool = "$1.posix_syntax()";
    proc set_posix_syntax: RE2Options * bool = "$1.set_posix_syntax($2);";

    fun longest_match: RE2Options -> bool = "$1.longest_match()";
    proc set_longest_match: RE2Options * bool = "$1.set_longest_match($2);";
    
    fun log_errors: RE2Options -> bool = "$1.log_errors()";
    proc set_log_errors: RE2Options * bool = "$1.set_log_errors($2);";
    
    fun max_mem: RE2Options -> int = "$1.max_mem()";
    proc set_max_mem: RE2Options * int = "$1.set_max_mem($2);";
    
    fun literal: RE2Options -> bool = "$1.literal()";
    proc set_literal: RE2Options * bool = "$1.set_literal($2);";

    fun never_nl: RE2Options -> bool = "$1.never_nl()";
    proc set_never_nl: RE2Options * bool = "$1.set_never_nl($2);";
    
    fun case_sensitive: RE2Options -> bool = "$1.case_sensitive()";
    proc set_case_sensitive: RE2Options * bool = "$1.set_case_sensitive($2);";
    
    fun perl_classes: RE2Options -> bool = "$1.perl_classes()";
    proc set_perl_classes: RE2Options * bool = "$1.set_perl_classes($2);";
    
    fun word_boundary: RE2Options -> bool = "$1.word_boundary()";
    proc set_word_boundary: RE2Options * bool = "$1.set_word_boundary($2);";
    
    fun one_line: RE2Options -> bool = "$1.one_line()";
    proc set_one_line: RE2Options * bool = "$1.set_one_line($2);";

    fun ParseFlags: RE2Options -> int = "$1.ParseFlags()";
   
  type ErrorCode = "::re2::RE2::ErrorCode";
    const NoError : ErrorCode = "::re2::RE2::NoError";
    const ErrorInternal: ErrorCode = "::re2::RE2::ErrorInternal";
    const ErrorBadEscape : ErrorCode = "::re2::RE2::ErrorBadEscape";
    const ErrorBadCharClass : ErrorCode = "::re2::RE2::ErrorBadCharClass";
    const ErrorBadCharRange : ErrorCode = "::re2::RE2::ErrorBadCharRange";
    const ErrorMissingBracket : ErrorCode = "::re2::RE2::ErrorMissingBracket";
    const ErrorMissingParen : ErrorCode = "::re2::RE2::ErrorMissingParen";
    const ErrorTrailingBackslash : ErrorCode = "::re2::RE2::ErrorTrailingBackslash";
    const ErrorRepeatArgument : ErrorCode = "::re2::RE2::ErrorRepeatArgument";
    const ErrorRepeatSize : ErrorCode = "::re2::RE2::ErrorRepeatSize";
    const ErrorRepeatOp: ErrorCode = "::re2::RE2::ErrorRepeatOp";
    const ErrorBadPerlOp: ErrorCode = "::re2::RE2::ErrprBadPerlOp";
    const ErrorBadUTF8: ErrorCode = "::re2::RE2::ErrorBadUTF8";
    const ErrorBadNamedCapture: ErrorCode = "::re2::RE2::ErrorBadNamedCapture";
    const ErrorPatternTooLarge: ErrorCode = "::re2::RE2::ErrorPatternTooLarge";

  type Anchor = "::re2::RE2::Anchor";
    const UNANCHORED: Anchor = "::re2::RE2::UNANCHORED";
    const ANCHOR_START: Anchor = "::re2::RE2::ANCHOR_START";
    const ANCHOR_END: Anchor = "::re2::RE2::ANCHOR_END";

  fun pattern: RE2 -> string = "$1->pattern()";
  fun error: RE2 -> string = "$1->error()";
  fun error_code: RE2 -> ErrorCode = "$1->error_code()";
  fun error_arg: RE2 -> string = "$1->error_arg()";
  fun ok: RE2 -> bool = "$1->ok()";
  fun ProgramSize: RE2 -> int = "$1->ProgramSize()";

  gen GlobalReplace: &string * RE2 * StringPiece -> int = "::re2::RE2::GlobalReplace($1, *$2, $3)";
  gen Extract: string * RE2 * StringPiece * &string -> int = "::re2::RE2::GlobalExtract($1, *$2, $3, $4)";

  fun QuoteMeta: StringPiece -> string = "::re2::RE2::QuoteMeta($1)";
 
  fun PossibleMatchRange: RE2 * &string * &string * int -> bool = "$1->PossibleMatchRange($2,$3,$3,$4)";
  fun NumberOfCapturingGroups: RE2 -> int = "$1->NumberOfCapturingGroups()";
  fun NamedCapturingGroups: RE2 -> Map::stl_map[string, int] = "$1->NamedCapturingGroups()";

  // this function is fully general, just needs an anchor
  gen Match: RE2 * StringPiece * int * Anchor * &StringPiece * int -> bool = "$1->Match($2, $3, $4, $5, $6)";

  fun CheckRewriteString: RE2 * StringPiece * &string -> bool = "$1->CheckRewriteString($2, $3)";

  // StringPiece is really cool, should be spit out and expanded
  instance Str[StringPiece] { fun str(x:StringPiece)=>string x; }

}
