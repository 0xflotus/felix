publish "Unbounded Variable length arrays"

open module Darray
{
  private struct darray_ctl[T]
  {
    a: varray[T];
    resize: ulong * ulong --> ulong;
  }

  // this is the default array resize function
  // if we run out of space, allocate what we have + 50%
  // if we need less than half the allocated space, return the requested size + 50%
  // otherwise return the existing allocated space
  cfun dflt_resize(old_max:ulong, requested:ulong):ulong=
  {
    // GOTCHA: don't forget that division has a higher precedence than multiplication!
    // sensible minimum size of 20, except if zero length
    if requested == 0ul do return 0ul; done
    if requested < 20ul do return 20ul; done;
    if requested < old_max / 2ul do return (3ul * requested) / 2ul; done 
    if requested > old_max do return (requested * 3ul) / 2ul;  done
    return old_max;
  }

  type darray[T] = new &darray_ctl[T];

  proc do_resize[T] (pd: darray[T], new_size: ulong)
  {
//println$ "do resize " + new_size.str;
    var old = (_repr_ pd).a;
//println$ "Making new array maxlen " new_size.str " old len " old.len.str;
    (_repr_ pd).a = varray[T] (new_size, (Varray::len old), (fun(i:ulong)=>old.[i]));
  }

  // make an empty darray, give it 20 slots for no particular reason
  ctor[T] darray[T] () => _make_darray[T]$ new darray_ctl[T](varray[T] 20ul , dflt_resize);

  // make a darray from a varray
  ctor[T] darray[T] (a:varray[T]) =>  _make_darray[T]$ new darray_ctl[T]( varray[T] a, dflt_resize);

  // make a darray of a certain size initialised with some default value
  ctor[T] darray[T] (size:ulong, default:T) => darray[T] (varray[T](size,default));

  // basic array stuff, same interface as array
  fun len[t] (a:darray[t])=> Varray::len (_repr_ a).a;
  fun subscript[t,ii in ints] (a:darray[t],  n:ii) => (_repr_ a).a.[n];
  proc set[t,ii in ints] (a:darray[t],  n:ii, v:t) => set ((_repr_ a).a,n,v);

  // basic array stuff, same interface as varray
  proc pop[t](a:darray[t]) {
    pop (_repr_ a).a;
    newsize := (_repr_ a).resize (maxlen (_repr_ a).a, Varray::len (_repr_ a).a);
    if newsize != maxlen (_repr_ a).a do do_resize (a,newsize); done 
  }

  proc pluseq[t] (a:&darray[t],v:t) {
    push_back (*a, v);
  }

  proc push_back[t] (a:darray[t], v:t) {
    r := _repr_ a; 
    newsize := r.resize (maxlen r.a, Varray::len r.a + 1ul);
    if newsize != maxlen r.a do do_resize(a,newsize); done
    push_back (r.a, v); // hack to workaround compiler error Address non variable
  }

  proc iter[T] (_f:T->void) (x:darray[T]) = { iter _f (_repr_ x).a; }

  instance[T with Show[T]] Str[Darray::darray[T]] {
    fun str (x:darray[T])=> str (_repr_ x).a;
  }
}


