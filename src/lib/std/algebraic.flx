
// additive symmetric group
class FloatAddgrp[t] {
  inherit Eq[t];
  virtual fun zero: unit -> t;
  virtual fun + : t * t -> t;
  virtual fun - : t -> t;
  virtual fun + : t -> t = "$1";
  virtual fun - (x:t,y:t):t => x + -y;
  virtual proc += (px:&t,y:t) { px <- *px + y; }
  virtual proc -= (px:&t,y:t) { px <- *px - y; }

  reduce id (x:t): x+zero() => x;
  reduce id (x:t): zero()+x => x;
  reduce inv(x:t): x - x => zero();
  reduce inv(x:t): - (-x) => x;
  axiom sym (x:t,y:t): x+y == y+x;

  fun add(x:t,y:t)=> x + y;
  fun plus(x:t)=> +x;
  fun sub(x:t,y:t)=> x - y;
  fun neg(x:t)=> -x;
  proc pluseq(px:&t, y:t) {  += (px,y); }
  proc  minuseq(px:&t, y:t) { -= (px,y); }

}

class Addgrp[t] {
  inherit FloatAddgrp[t];
  axiom assoc (x:t,y:t,z:t): (x + y) + z == x + (y + z);
  reduce inv(x:t,y:t): x + y - y => x;
}

// mult semi group with unit
class FloatMultSemi1[t] {
  inherit Eq[t];
  proc muleq(px:&t, y:t) { *= (px,y); }
  fun mul(x:t, y:t) => x * y;
  virtual fun one: unit -> t;
  virtual fun * : t * t -> t;
  virtual proc *= (px:&t, y:t) { px <- *px * y; }
  reduce id (x:t): x*one() => x;
  reduce id (x:t): one()*x => x;
}

// mult semi group with unit
class MultSemi1[t] {
  inherit FloatMultSemi1[t];
  axiom assoc (x:t,y:t,z:t): (x * y) * z == x * (y * z);
  reduce cancel (x:t,y:t,z:t): x * z ==  y * z => x == y;
}

// ring
class FloatRing[t] {
  inherit FloatAddgrp[t];
  inherit FloatMultSemi1[t];
}

// ring
class Ring[t] {
  inherit Addgrp[t];
  inherit MultSemi1[t];
  axiom distrib (x:t,y:t,z:t): x * ( y + z) == x * y + x * z;
}

// division ring
class FloatDring[t] {
  inherit FloatRing[t];
  virtual fun / : t * t -> t; // pre t != 0
  virtual proc /= : &t * t;
  virtual fun % : t * t -> t;
  virtual proc %= : &t * t;

  fun div(x:t, y:t) => x / y;
  fun mod(x:t, y:t) => x % y;
  proc diveq(px:&t, y:t) { /= (px,y); }
  proc modeq(px:&t, y:t) { %= (px,y); }
}

// division ring
class Dring[t] {
  inherit Ring[t];
  inherit FloatDring[t];
}


class Bits[t] {
  virtual fun \^ : t * t -> t = "(?1)($1^$2)";
  virtual fun \| : t * t -> t = "$1|$2";
  virtual fun \& : t * t -> t = "$1&$2";
  virtual fun ~: t -> t = "(?1)(~$1)";
  virtual proc ^= : &t * t = "*$1^=$2;";
  virtual proc |= : &t * t = "*$1|=$2;";
  virtual proc &= : &t * t = "*$1&=$2;";

  fun bxor(x:t,y:t)=> x \^ y;
  fun bor(x:t,y:t)=> x \| y;
  fun band(x:t,y:t)=> x \& y;
  fun bnot(x:t)=> ~ x;

}

class Integer[t] {
  inherit Tord[t];
  inherit Dring[t];
  inherit Bidirectional[t];
  virtual fun << : t * t -> t = "$1<<$2";
  virtual fun >> : t * t -> t = "$1>>$2";

  fun shl(x:t,y:t)=> x << y;
  fun shr(x:t,y:t)=> x >> y;
}

// Signed Integers
class Signed_integer[t] {
  inherit Integer[t];
  virtual fun sgn: t -> int;
  virtual fun abs: t -> t;
}

// Unsigned Integers
class Unsigned_integer[t] {
  inherit Integer[t];
  inherit Bits[t];
}

class Trig[t] {
  virtual fun sin: t -> t;
  virtual fun cos: t -> t;
  virtual fun tan: t -> t;
  virtual fun asin: t -> t;
  virtual fun acos: t -> t;
  virtual fun atan: t -> t;
  virtual fun sinh: t -> t;
  virtual fun cosh: t -> t;
  virtual fun tanh: t -> t;
  virtual fun asinh: t -> t;
  virtual fun acosh: t -> t;
  virtual fun atanh: t -> t;
  virtual fun exp: t -> t;
  virtual fun log: t -> t;
  virtual fun pow: t * t -> t;
}

class Special[t] {
  virtual fun erf: t -> t;
  virtual fun erfc: t -> t;
}

class Real[t] {
  inherit Tord[t];
  inherit Trig[t];
  inherit Special[t];
  inherit FloatDring[t];
  virtual fun log10: t -> t;
  virtual fun abs: t -> t;
  virtual fun sqrt: t -> t;
  virtual fun ceil: t -> t;
  virtual fun floor: t -> t;
  virtual fun trunc: t -> t;
}

class Complex[t,r] {
  inherit Eq[t];
  inherit FloatRing[t];
  inherit Special[t];
  inherit Trig[t];
  virtual fun real: t -> r;
  virtual fun imag: t -> r;
  virtual fun abs: t -> r;
  virtual fun arg: t -> r;

  virtual fun + : r * t -> t;
  virtual fun + : t * r -> t;
  virtual fun - : r * t -> t;
  virtual fun - : t * r -> t;
  virtual fun * : t * r -> t;
  virtual fun * : r * t -> t;
  virtual fun / : t * r -> t;
  virtual fun / : r * t -> t;
}



