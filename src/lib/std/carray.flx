open class Carray
{
  requires Cxx_headers::cstdlib;
  open C_hack;

  publish "Carray type is just a pointer"

  publish "Convert Felix array to C array"
  typedef carray[T] = &T;
  ctor[T,N] carray[T]: &array[T,N] = "($t)->data";

  fun array_alloc[T]: !ints -> &T = '(?1*)::std::malloc(sizeof(?1)*$1)';
  fun array_calloc[T]: !ints -> &T = '(?1*)::std::calloc(sizeof(?1),$1)';
  proc free[T]: &T = "::std::free($1);";
  fun subscript[T]: &T * !ints -> T = '$1[$2]';
  fun deref[T]: &T -> T = '*$1';

  fun add[T]: &T * !ints -> &T= '$1+$2';
  fun sub[T]: &T * !ints -> &T = '$1-$2';
  fun sub[T]: &T * &T-> ptrdiff = '$1-$2';

  proc pre_incr[T]: &&T = '++*$1;';
  proc post_incr[T]: &&T = '(*$1)++;';
  proc pre_decr[T]: &&T = '--*$1;';
  proc post_decr[T]: &&T = '(*$1)--;';
  proc pluseq[T]: &&T * !ints = '*$1+=$2;';
  proc minuseq[T]: &&T * !ints = '*$1-=$2;';

  /* carray is alias for a pointer .. */
  instance[T] Eq[&T] {
    fun eq: &T * &T -> bool = '$1==$2';
    fun ne: &T * &T -> bool = '$1!=$2';
  }
  instance[T] Tord[&T] {
    fun lt: &T * &T -> bool = '$1<$2';
    fun le: &T * &T -> bool = '$1<=$2';
    fun gt: &T * &T -> bool = '$1>$2';
    fun ge: &T * &T -> bool = '$1>=$2';
  }

  publish "Convert C array to Felix array"
  fun array_of[T,N]: &T -> &array[T,N] = "*(#0*)(void*)$1";

  proc memcpy: address * address * size =
    "{if($1 && $2 && $3)::std::memcpy($1,$2,$3);}"
    requires Cxx_headers::cstring
  ;
  fun memcmp: address * address * size -> int = "::std::memcmp($1,$2,$3)"
    requires Cxx_headers::cstring
  ;

  // unsafe C string functions
  // move to where they should be (if it isn't here .. :)
  proc strcpy: &char * &char = "(void)::std::strcpy($1,$2);" requires Cxx_headers::cstring;
  proc strncpy: &char * &char * !ints = "(void)::std::strncpy($1,$2,$3);" requires Cxx_headers::cstring;
  fun strlen: &char ->size = "::std::strlen($1)" requires Cxx_headers::cstring;
}

open[T] Eq[&T];
open[T] Tord[&T];
