open class Carray
{
  requires Cxx_headers::cstdlib;
  open C_hack;

  publish "Convert Felix array to C array"
  type carray[T] = new &T;

  typedef fun +(T:TYPE) : TYPE => carray[T]; 
  fun +[T]:&T -> carray[T] = "$1"; // unsafe
  fun -[T]: carray[T] -> &T = "$1"; // safe (unless we allow +T to be NULL later ..)

  ctor[T] carray[T] : &T = "$1";

  ctor[T,N] carray[T]: &array[T,N] = "($1)->data";

  fun array_alloc[T]: !ints -> carray[T] = '(?1*)::std::malloc(sizeof(?1)*$1)';
  fun array_calloc[T]: !ints -> carray[T] = '(?1*)::std::calloc(sizeof(?1),$1)';
  proc free[T]: carray[T] = "::std::free($1);";
  lvalue fun subscript[T]: carray[T] * !ints -> T = '$1[$2]';
  lvalue fun deref[T]: carray[T] -> T = '*$1';
  fun get[T]: carray[T] * !ints -> T = '$1[$2]';
  fun apply [T,I in ints] (i:I, x:carray[T]) => get (x,i.size);

  proc set[T] : carray[T] * !ints * T = "$1[$2]=$3;";
  fun stl_begin[T,N]: carray[array[T,N]] -> carray[T] = "(?1*)&($1->data)";

  fun + [T]: carray[T] * !ints -> carray[T]= '$1+$2';
  fun - [T]: carray[T] * !ints -> carray[T] = '$1-$2';
  fun - [T]: carray[T] * carray[T]-> ptrdiff = '$1-$2';

  proc pre_incr[T]: &carray[T] = '++*$1;';
  proc post_incr[T]: &carray[T] = '(*$1)++;';
  proc pre_decr[T]: &carray[T] = '--*$1;';
  proc post_decr[T]: &carray[T] = '(*$1)--;';
  proc += [T]: &carray[T] * !ints = '*$1+=$2;';
  proc -= [T]: &carray[T] * !ints = '*$1-=$2;';

  /* carray is alias for a pointer .. */
  instance[T] Eq[carray[T]] {
    fun == : carray[T] * carray[T] -> bool = '$1==$2';
    fun != : carray[T] * carray[T] -> bool = '$1!=$2';
  }
  instance[T] Tord[carray[T]] {
    fun < : carray[T] * carray[T] -> bool = '$1<$2';
    fun <= : carray[T] * carray[T] -> bool = '$1<=$2';
    fun > : carray[T] * carray[T] -> bool = '$1>$2';
    fun >= : carray[T] * carray[T] -> bool = '$1>=$2';
  }

  publish "Convert C array to Felix array"
  fun array_of[T,N]: carray[T] -> &array[T,N] = "*(#0*)(void*)$1";

  proc memcpy: address * address * size =
    "{if($1 && $2 && $3)::std::memcpy($1,$2,$3);}"
    requires Cxx_headers::cstring
  ;
  fun memcmp: address * address * size -> int = "::std::memcmp($1,$2,$3)"
    requires Cxx_headers::cstring
  ;

  // unsafe C string functions
  // move to where they should be (if it isn't here .. :)
  proc strcpy: carray[char] * carray[char] = "(void)::std::strcpy($1,$2);" requires Cxx_headers::cstring;
  proc strncpy: carray[char] * carray[char] * !ints = "(void)::std::strncpy($1,$2,$3);" requires Cxx_headers::cstring;
  fun strlen: carray[char] ->size = "::std::strlen($1)" requires Cxx_headers::cstring;
  gen strdup(s:carray[char]) = {
    val n = strlen s;
    var out=array_alloc[char] (n+1uz);
    strcpy(out,s);
    return out;
  }
}

open[T] Eq[carray[T]];
open[T] Tord[carray[T]];

