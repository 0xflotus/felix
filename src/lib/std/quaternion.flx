module Quaternion
{
  type quaternion = new double ^ 4;
  ctor quaternion (x:double^4) => _make_quaterion x;
  r(q:quaternion)=> (_repr_ q) . 0;
  i(q:quaternion)=> (_repr_ q) . 1;
  j(q:quaternion)=> (_repr_ q) . 2;
  k(q:quaternion)=> (_repr_ q) . 3;

  ctor quaternion (x:double) => quaternion (x,0.0,0.0,0.0);

  fun add(a:quaternion,b:quaternion) =>
    quaternion (a.r+ b.r, a.i + b.i, a.j + b.j, a.k+b.k)
  ;

  fun mul(a:quaterion, b:quaternion) =>
    quaternion (
      a.r * b.r - a.i * b.i - a.j * b.j - a.k * b.k,
      a.r * b.i + a.i * b.r + a.j * b.k - a.k * b.j,
      a.r * b.j - a.i * b.k + a.j * b.r - a.k * b.i,
      a.r * b.k + a.i * b.j - a.j * b.i + a.k * b.r,

    )
  ;

  fun conj (a:quaternion) => quaternion (a.r, -a.i, -a.j, -a.k);
  fun norm (a:quaternion) => sqrt (a.r * a.r + a.i * a.i + a.j * a.j +a.k * a.k);

  fun mul(a:quaternion, b: double) => quaternion (a.r * b, a.i * b, a.j * b, a.k * b);
  fun mul(a: double, b:quaternion) => a * b;

  fun reciprocal (a:quaternion) => let ?n = norm a in conj a * (1.0/ (n * n));

  // add more later
}


