publish "Bounded Variable length arrays, bound set at construction time"

open class Varray
{
  _gc_pointer _gc_type t type varray[t] = "?1*";

  // an ordinary carray, but owned by the GC
  ctor[t] carray[t] : varray[t] = "$1";

  ctor[t] varray[t]: size =
    "(?1*)(PTF gcp->collector->create_empty_array(&@?1,$1))"
    requires property "needs_gc"
  ;

  // raw memory initialisation (really, this belongs in C_hack)
  private proc _init[T]: &T * T = "new((void*)$1) ?1($2);";
 

  publish "Construct a full varray with a default value"
  ctor[t] varray[t] (bound:size, default:t) = {
    var o = varray[t] bound;
    if bound > 0uz do for var i in 0uz upto bound - 1uz do
      push_back(o, default);
    done done
    return o;
  }

  publish "Construct a partially filled varray with a default value computed by a function"
  ctor[t] varray[t] (bound:size, used:size, f:size->t when used <= bound) = {
    var o = varray[t] bound;
    if used > 0uz do for var i in 0uz upto used - 1uz do
      push_back(o, f i);
    done done
    return o;
  }

  publish "Construct a full varray from an array"
  // funny, the N isn't explicitly used.
  ctor[t,N] varray[t] (x:array[t,N]) => 
     varray[t] (len x, len x, (fun (i:size)=>x.i))
  ;

  publish "Construct a partially full varray from a varray"
  ctor[t] varray[t] (x:varray[t], maxlen:size) =>
    varray[t] (maxlen, min(maxlen,len x), (fun (i:size)=> x.i))
  ;

  publish "Construct a full varray from a varray (copy constructor)"
  ctor[t] varray[t] (x:varray[t]) =>
    varray[t] (len x, len x, (fun (i:size)=> x.i))
  ;

  // construct a varray from a list
  ctor[t] varray[t] (x:list[t]) = {
    val n = x.len.size;
    var a = varray[t] n;
    iter (proc (v:t) { push_back(a,v); }) x;
    return a;
  }

  ctor varray[char] (x:string) = {
    var n = x.len; var p = x._unsafe_cstr;
    var v = varray[char] (n + 1);
    var q = v.stl_begin;
    strncpy (q, p, n);
    q+n <- char "";
    set_used (v,n + 1);
    return v;
  } 

  private proc set_used[t]: varray[t] * size =
    "PTF gcp->collector->set_used($1,$2);"
    requires property "needs_gc"
  ;

  instance[v] ArrayValue[varray[v],v] {
    fun len: varray[v] -> size =
      "PTF gcp->collector->get_used($1)"
      requires property "needs_gc"
    ;
    fun unsafe_get: varray[v] * size -> v = "$1[$2]";
  } 

  instance[v] ArrayObject[varray[v],v] {
    proc unsafe_set: varray[v] * size * v = "$1[$2]=$3;";
  }

  instance[v] ContiguousArrayObject[varray[v],v] {
    fun stl_begin: varray[v] -> +v = "$1";
    fun stl_end: varray[v] -> +v = "($1+PTF gcp->collector->get_used($1))";
  }

  fun maxlen[t]: varray[t] -> size =
    "PTF gcp->collector->get_count($1)"
    requires property "needs_gc"
  ;
  proc += [t] (pa:&varray[t],v:t) { push_back (*pa,v); }

  proc push_back[t] : varray[t] * t = """
    {
      //?1 * _p = *$1;
      unsigned long n = PTF gcp->collector->get_used($1);
      PTF gcp->collector->incr_used($1,1L);
      new($1+n) ?1($2);
    }
  """
    requires property "needs_gc"
  ;

  proc pop[t] : varray[t] = """
    {
      ?1 * _p = $1;
      unsigned long n = PTF gcp->collector->get_used(_p);
      PTF gcp->collector->incr_used(_p,-1L);
      destroy(_p+n-1);
    }
  """
    requires property "needs_gc"
  ;

  fun map[T, U] (_f:T->U) (x:varray[T]): varray[U] = {
    var o = varray[U]$ len(x);

    if len x > 0uz do for var i in 0uz upto len(x) - 1uz do
      push_back (o, _f x.i);
    done done
    return o;
  }

  // sort
  header 
  """
  template<class CT, class FT2, class FFT>
  struct comparator {
    FFT cmp;
    comparator() : cmp(0) {}
    comparator(FFT cmp_a) : cmp(cmp_a) {}
    bool operator ()(CT x, CT y){
      ::std::pair<CT,CT> z(x,y); 
      return cmp->apply(*(FT2*)(void*)&z);
    }
  };
  """ requires Cxx_headers::utility;

  private type _comparator[CT,FT2,FFT] = "comparator<?1,?2,?3>";
  private typedef comparator[T] = _comparator[T,T*T,T*T->bool];

  private fun _make_comparator[CT,FT2,FFT]: FFT -> comparator[CT] = "comparator<?1,?2,?3>($1)";
  private fun make_comparator[T](cmp:T * T -> bool) => _make_comparator[T, T*T, T*T->bool] (cmp);

  // invoke stl sort
  private proc _sort[T]: comparator[T] * +T * +T = "::std::sort($2, $3, $1);" 
    requires Cxx_headers::algorithm;


  // in place sort of varray using STL sort
  proc sort[t] (cmp: t * t -> bool) (a:varray[t]) {
    var first = a.stl_begin;
    var last = a.stl_end;
    var z: comparator[t] = make_comparator[t] (cmp);
    _sort[t] (z,first,last);
  }

}

instance[T with Show[T]] Str[Varray::varray[T]] {
  fun str (xs:varray[T]) = {
    var o = 'varray(';

    if len xs > 0uz do
      o += repr xs.0;

      for var i in 1uz upto len xs - 1uz do
        o += ', ' + repr xs.i;
      done
    done

    return o + ')';
  }
}

instance[T with Eq[T]] Set[varray[T],T] {
 fun \in (x:T, a:varray[T]) : bool = {
   if len a > 0uz do
     for var i in 0uz upto len a - 1uz do
       if a.i == x do return true; done
     done
   done
   return false;
 } 
}

open[T] Show[Varray::varray[T]];
open[T] Set[Varray::varray[T],T];
open[T] ArrayValue[varray[T], T];
open[T] ArrayObject[varray[T], T];
open[T] ContiguousArrayObject[varray[T], T];

