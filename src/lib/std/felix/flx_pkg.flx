include "std/felix/flx_pkgconfig";

class FlxPkg
{
  typedef pkgconfig_inspec_t = (
    FLX_INSTALL_DIR:string,
    EXT_EXE: string,
    EXT_STATIC_OBJ: string,
    STATIC: int,
    SLINK_STRING: string,
    DLINK_STRING: string,
    LINKER_SWITCHES: list[string],
    cpp_filebase : string
  );

  typedef pkgconfig_outspec_t = (
    INCLUDE_DIRS: list[string],
    INCLUDE_FILES: list[string],
    DRIVER_EXE: string,
    DRIVER_OBJS: list[string],
    LINK_STRING: string
  );

  gen map_package_requirements(spec:pkgconfig_inspec_t) : pkgconfig_outspec_t =
  {

    var PKGCONFIG_PATH="--path+="+Filename::join(spec.FLX_INSTALL_DIR,"config");
    var RESH = "@"+spec.cpp_filebase+".resh";

    gen pkgconfl(args:list[string]) : list[string] =
    {
      var allargs = PKGCONFIG_PATH+args+RESH; 
      var ret,s = FlxPkgConfig::flx_pkgconfig(allargs);
      if ret != 0 do
        eprintln$ "Error " + str ret + " executing flx_pkgconfig, args=" + str allargs;
        System::exit (1);
      done
      return s;
    }
    gen pkgconfs(args:list[string]) : string => cat ' ' $ pkgconfl(args);

    var e = Empty[string];

    // find all include directories
    var INCLUDE_DIRS=pkgconfl(e+'--field=cflags'+'--keepleftmost');

    // find all include files
    var INCLUDE_FILES=pkgconfl(e+'--field=includes'+'--keepleftmost');


    // find the driver package
    var DRIVER_PKG=pkgconfs(e+'--field=flx_requires_driver');
    DRIVER_PKG == "" ??  DRIVER_PKG="flx_run";

    // find the driver entity
    if spec.STATIC == 0 do
      // dynamic linkage: the driver executable
      var DRIVER_EXE= Filename::join$ list (
        spec.FLX_INSTALL_DIR,
        "bin",
        DRIVER_PKG+config.EXT_EXE
      )
    ;
    else
      // static linkage: the driver object files
      var DRIVER_OBJS =list(
        Filename::join (list (
          spec.FLX_INSTALL_DIR,
          "lib",
          "rtl",
          DRIVER_PKG+"_lib"+
          spec.EXT_STATIC_OBJ)),
        Filename::join (list (
          spec.FLX_INSTALL_DIR,
          "lib",
          "rtl",
          DRIVER_PKG+"_main"+spec.EXT_STATIC_OBJ))
      );
    done

    if spec.STATIC == 0 do
      // dynamic linkage: all the libraries required by the application
      var LINK_STRING=
        spec.DLINK_STRING+' ' +
        catmap ' ' Shell::quote_arg spec.LINKER_SWITCHES+" "+
        pkgconfs(e+"-r"+'--field=provides_dlib'+'--field=requires_dlibs'+DRIVER_PKG);
    else
      // static linkage: all the libraries required by the application and driver
      LINK_STRING=
        spec.SLINK_STRING+' ' +
        catmap ' ' Shell::quote_arg spec.LINKER_SWITCHES+" "+
        pkgconfs(e+'-r'+'--keeprightmost'+'--field=provides_slib'+'--field=requires_slibs'+DRIVER_PKG);
    done

    return ( 
      INCLUDE_DIRS = INCLUDE_DIRS,
      INCLUDE_FILES = INCLUDE_FILES,
      DRIVER_EXE = DRIVER_EXE,
      DRIVER_OBJS = DRIVER_OBJS,
      LINK_STRING = LINK_STRING
    );
  }

  proc write_include_file(path:string, INCLUDE_FILES:list[string]) {
    var f = fopen_output(path+".includes");
    List::iter  
      (proc (i:string) { writeln$ f, "#include " + i; })
      INCLUDE_FILES
    ;
    fclose f;
  }

}

