@title Graphs
@h1 Graphs
@felix
// Directed Cyclic graph

include "std/datatype/dlist";

class DiGraph[V,E with Str[V], Str[E]] // V,E labels for graph parts
{
  // vertices are stored in an array, so they're identified
  // by their slot number 0 origin
  typedef digraph_t = (vertices: darray[vertex_t], nedges: int);
  ctor digraph_t () => (vertices= #darray[vertex_t], nedges=0);

  // x index implicit, the edge source
  // y index is the edge destination
  typedef edge_t = (elabel:E, y:int, weight:int); 
  typedef vertex_t = (vlabel:V, outedges: list[edge_t]);

  fun len (d:digraph_t) => d.vertices.len;
 
  virtual fun default_vlabel: 1 -> V;
  virtual fun default_elabel: 1 -> E;
  fun default_vertex () => (vlabel = #default_vlabel, outedges = Empty[edge_t]);

  // Add an isolated vertex
  // If the vertex is already in the graph,
  // this routine just replaces the label
  // this allows adding out of order vertices
  // and adding vertices implicitly by adding edges
  proc add_vertex (d:&digraph_t, v:V, x:int) 
  {
    while x >= d*.vertices.len.int do push_back (d*.vertices, #default_vertex); done 
    var pv: &V = (d*.vertices,x.size).unsafe_get_ref.vlabel;
    pv <- v;
  }

  proc add_edge (d:&digraph_t, x:int, y:int, elab:E)
  {
    while x >= d*.vertices.len.int do add_vertex (d,#default_vlabel,d*.vertices.len.int); done;
    while y >= d*.vertices.len.int do add_vertex (d,#default_vlabel,d*.vertices.len.int); done;
    var pedges : &list[edge_t] = (d*.vertices,x.size).unsafe_get_ref.outedges;
    pedges <- (elabel=elab,y=y,weight=1) ! *pedges;
    d.nedges.pre_incr;
  }
 
  // add and edge and its reverse edge, distinct labels
  proc add_edge_pair (d:&digraph_t, x:int, y:int, felab:E, relab:E)
  {
    add_edge(d,x,y,felab);
    add_edge(d,y,x,relab);
  }

  // add and edge and its reverse edge, same label
  // use for undirected graph
  proc add_edge_pair (d:&digraph_t, x:int, y:int, elab:E)
  {
    add_edge(d,x,y,elab);
    add_edge(d,y,x,elab);
  }

 
  fun dump_digraph (d:digraph_t) : string = 
  {
    var out = "";
    reserve (&out,10000);
    var x = 0;
    for vertex in d.vertices do
      out += x.str + " " + vertex.vlabel.str + "\n";
      for edge in vertex.outedges do
        out += "  " + x.str + "->" + edge.y.str + " " + edge.elabel.str+ "\n";
      done
    ++x;
    done
    return out;
  }

  union Vstate = Undiscovered | Discovered | Processed;

  typedef digraph_visitor_processing_t = 
  (
    process_vertex_early: digraph_t -> int -> 0,
    process_vertex_late: digraph_t -> int -> 0,
    process_edge: digraph_t -> int * int -> 0
  );

  proc dflt_pve (g:digraph_t) (x:int) {};
  proc dflt_pvl (g:digraph_t) (x:int) {};
  proc dflt_pe (g:digraph_t) (x:int, y:int) {};

  // default visitor does nothing
  ctor digraph_visitor_processing_t () => (
    process_vertex_early= dflt_pve,
    process_vertex_late= dflt_pvl,
    process_edge= dflt_pe
  );

  proc breadth_first_iter (d:digraph_t) (startv:int) (p:digraph_visitor_processing_t)
  {
    open DList[int];
    var q = queue_t();
    var state = varray[Vstate] (bound=d.len,default=Undiscovered);
    enqueue &q startv;
    set (state,startv,Discovered);
    //var parent = -1;
    for v in &q do // all vertex indices in queue
      p.process_vertex_early d v;
      set (state,v,Processed);
      for edge in d.vertices.v.outedges do
        var y = edge.y;
        p.process_edge d (v, y);
        match state.y with
        | Undiscovered => 
          enqueue &q y; 
          set (state,y,Discovered); 
          //parent = v;
        | _ => ;
        endmatch;
      done
      p.process_vertex_late d v;
    done // vertices
    println$ "BFS DONE";
  }
}

instance DiGraph[string, string] 
{
  fun default_vlabel () => "Unlabelled Vertex";
  fun default_elabel () => "Unlabelled Edge";
}

