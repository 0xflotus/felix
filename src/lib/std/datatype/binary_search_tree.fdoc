@title Binary Search Tree
@felix
class BinarySearchTree[T with Tord[T]]
{

  typedef bstree_node_t =
    (
      elt: T,
      parent:bstree_t, 
      left:bstree_t, 
      right:bstree_t
    )
  ;

  // axiom: all elts in left subtree < elt < all elements in right subtree

  union bstree_t = 
    | Empty 
    | Node of &bstree_node_t 
  ;

  fun leaf: bstree_t -> bool =
    | Empty => false
    | Node ?p => 
      match p*.left, p*.right with 
      | Empty, Empty => true 
      | _ => false
  ;

  fun leaf_or_empty : bstree_t -> bool =
    | Empty => true
    | ?x => leaf x
  ;

  instance Str[bstree_t] {
    fun str : bstree_t -> string =
      | Empty => "()"
      | Node ?p =>
        p*.elt.str + "(" + p*.left.str + ") (" + p*.right.str + ")"
    ;
  }

  // Skiena p78
  fun find (tree:bstree_t) (elt:T) : bstree_t =>
    // saves passing invariant elt
    let fun aux (tree:bstree_t) : bstree_t =>
      match tree with 
      | Empty => tree
      | Node ?p => 
         if p*.elt == elt then tree
         elif elt < p*.elt then aux p*.left
         else aux p*.right
      endmatch
    in aux tree
  ;

  fun min (x:bstree_t) =>
    match x with 
    | Empty => x
    | Node ?p =>
      let fun aux (p:&bstree_node_t) =>
        match *p.left with
        | Empty => Node p 
        | Node ?p => aux p
      in aux p
   ; 
     
   proc iter (f: T -> 0) (x:bstree_t) =
   {
      proc aux (x:bstree_t) = {
        match x with
        | Empty => ;
        | Node ?p =>
          aux p*.left;
          f p*.elt;
          aux p*.right;
        endmatch;
      }
     aux x;
   }
    
  ctor bstree_t () => Empty;
  ctor bstree_node_t (x:T) => (parent=Empty,elt=x,left=Empty,right=Empty);
  ctor bstree_node_t (x:T, p:bstree_t) => (parent=p,elt=x,left=Empty,right=Empty);

  ctor bstree_t (x:T) => Node (new (bstree_node_t x));
  ctor bstree_t (x:T, p:bstree_t) => Node (new (bstree_node_t (x,p)));

  proc insert_with_parent (p:&bstree_t) (parent:bstree_t) (elt:T)
  {
     proc aux (p:&bstree_t) (parent:bstree_t) {
       match *p with
       | Empty => p <- bstree_t (elt,parent);
       | Node ?q =>
         if elt < q*.elt do
           aux q.left (*p);
         else
           aux q.right (*p);
         done
       endmatch;
     }
     aux p parent;
  }
 

}


