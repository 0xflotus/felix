// Core types and type classes

typedef void = 0;
typedef unit = 1;
typedef bool = 2;

// -----------------------------------------------------------------------------

typeclass IStream[f,t] {
  virtual gen read: f -> t;
}

typeclass OStream[f,t] {
  virtual proc write: f * t;
}

typeclass IOStream[f,t] {
  inherit IStream[f,t];
  inherit OStream[f,t];
}

// -----------------------------------------------------------------------------

typeclass IFile[f,t] {
  inherit IStream [f,opt[t]];
}

typeclass OFile[f,t] {
  inherit OStream[f,t];
  virtual proc close: f; // invalidates write operation
}

// -----------------------------------------------------------------------------

typeclass IBuffer [f] {
  virtual gen read: f -> address * int -> int * bool;
}

typeclass OBuffer [f] {
  virtual gen write : f -> address * int -> int * bool;
}

// -----------------------------------------------------------------------------

// note: eq is not necessarily required for a membership test
// for example: string member of regexp doesn't require
// string equality
// Set need not be finite (example regexp again)
// A list is a set, despite the duplications
typeclass Set[c,t] {
  virtual fun mem: t * c-> bool;
}

// roughly, a finite Set
typeclass Container [c,v]
{
  inherit Set[c,v];
  virtual fun len: c -> size;
  virtual fun empty(x: c): bool => len x == size(0);
}

// -----------------------------------------------------------------------------

typeclass Monad [M: TYPE->TYPE] {
  virtual fun bind[a,b]: M a * (a -> M b) -> M b;
  virtual fun ret[a]: a -> M a;
}

// -----------------------------------------------------------------------------

typeclass Str [T] {
  virtual fun str: T -> string;
}

typeclass Repr [T with Str[T]] {
  virtual fun repr (t:T) : string => str t;
}

typeclass Show [T] {
  inherit Str[T];
  inherit Repr[T];
}

// -----------------------------------------------------------------------------

instance Str[void] {
  fun str (x:void) => "void";
}
open Show[void];

// -----------------------------------------------------------------------------

instance Str[unit] {
  fun str (x:unit) => "()";
}
open Show[unit];

instance Eq[unit] {
  fun eq (x:unit, y:unit) => true;
}
open Eq[unit];
