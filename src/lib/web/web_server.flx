publish """ 
Accepts connection and spawns fthread to handle request 
See webapp.flx for usage example 
"""

//if POSIX do
include "std/posix/faio_posix";  // aio_ropen
include "std/posix/signal";
include "std/posix/filesystem";
include "std/posix/filestat";
Posix_Signal::ignore_signal(Posix_Signal::SIGPIPE);
//done

include "std/io/socket";
open Socket;

include "std/io/stream";
open Stream;

open TerminalIByteStream[fd_t];
open TerminalIOByteStream[socket_t];

proc dbg(x:string) { fprint (cerr,x); };
include "std/io/textio";
include "web/server_config";
include "web/http_request";
include "web/http_connection";
include "web/http_response";
include "web/http_handler";
include "web/mime_type";
include "web/http_status_code";
include "web/low_res_time";
include "web/sqlite3_ext";
include "web/pool"; 
include "web/cookie";
// this is a hack to make close work on a listenter
// RF got this right the first time:
// in the abstract a listener is NOT a socket
// In fact, it is a socket server, with accept() a way to
// read new sockets off it ..
open TerminalIByteStream[socket_t];

requires header '#include <stdlib.h>';

class WebServer {
  open ServerConfig;
  open HTTPRequest;
  open HTTPConnection;
  open MIMEType;
  open Assoc_list;  
  open HTTPHandler;  

  proc serve(conn:http_connection, request: http_request)
  {
    val s = conn.sock;
    match find (fun (a:http_handler) => a.handles(conn.config,request)) 
            conn.config.handlers with
      | Some(?h) => { h.handler_fn(conn,request); }
      | _ => {}
    endmatch;
    return;
  }

  
  proc start_webserver(config:server_config) {
    val webby_port = config.port;
    print "FLX WEB!!! listening on port "; print webby_port; endl;
    // up the queue len for stress testing
    var p = webby_port;
    var listener: socket_t;
    mk_listener(&listener, &p, 10);
    var clock = Faio::mk_alarm_clock();
    // noinline is necessary to stop the closure being
    // inlined into the loop, preventing the socket variable k
    // being duplicated as it must be [a bug in Felix]
    noinline proc handler (var k:socket_t) ()
    {
      dbg$ "Spawned fthread running for socket "+str k+"\n";
      // should spawn fthread here to allow for more io overlap
      val conn = http_connection(config ,k);
      var request:http_request;
      HTTPRequest::get_request(conn,&request);
      serve(conn,request);
      fprint$ cerr,"fthread socket "+str k+" close delay ..\n";
      Faio::sleep(clock,config.delay); // give OS time to empty its buffers
      fprint$ cerr,"fthread socket "+str k+" shutdown now\n";

      // try this:
      // Advised by: koettermarkus@gmx.de, MANY THANKS!

      gen hack_recv: socket_t * &char * int * int -> int = "recv($1,$2,$3,$4)";

      var buf:char ^1025;
      var counter = 0;
      var extra = 0;
      shutdown(k,1); // shutdown read
      retry:>
        var b = hack_recv(k,C_hack::cast[&char] (&buf),1024,0);
        //println$ "Error code " + str b + " from read after shutdown";
        if b > 0 do
          extra += b;
          if extra > 2000 do
            println$ "Read too many extraneous bytes from OS buffer";
            goto force_close;
          done;
          goto retry;
        elif b == -1 do
        ++counter;
        if counter > 200 do
          println "Timeout waiting for write buffers to be flushed";
          goto force_close;
        done;
        Faio::sleep(clock,0.1); // 100 ms
        goto retry;
      done;
      assert b==0;

      force_close:> 
      Socket::shutdown(k,2);
      ioclose(k);
      fprint$ cerr,"fthread "+str k+" terminating!\n";
    };

    forever {
      var s: socket_t;
      dbg$ "Waiting for connection\n";
      accept(listener, &s);  // blocking
      dbg$ "got connection "+str s + "\n";  // error check here

      //  - spawning an fthread is blocking the web server. don't know why
      print$ "spawning fthread to handle connection "+str s+"\n";
      var h = handler s;
      spawn_fthread  h;
      //collect(); // this hangs everything, no idea why!
    };

    println "WEB SERVER FINNISHED?";
    iclose (listener);
  }

}
