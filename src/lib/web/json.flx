open class Json 
{
  union Jvalue = 
  | Jstring of string
  | Jinteger of string
  | Jdictionary of list[Jpair]
  | Jarray of list [Jvalue]
  | Jname of string
  ;
  typedef Jpair = Jvalue * Jvalue;

  fun str (s:Jvalue, v:Jvalue) : string => str s + ': ' + str v;

  fun str (v: Jvalue) : string => match v with
  | Jstring ?s => '"' + s + '"' // hack, ignores quoting rules
  | Jinteger ?i => i
  | Jdictionary ?d => "{" + cat ", " (map str of (Jpair) d) + "}"
  | Jarray ?a => "[" + cat ", " (map str of (Jvalue) a) + "]"
  | Jname ?a => a
  endmatch
  ;

  union ParseResult =
  | Good of Jvalue
  | Bad of int
  ;

  fun parse_json(s:string): ParseResult = {
    var i = skip_white s 0;
    def i, var v = parse_value s i;
    i = skip_white s i;
    if s.[i] != "".char do
      return Bad i;
    else
      return v;
    done
  }

  private fun skip_white (s:string) (var i:int) = {
    while s.[i] in " \t\r\n" do ++i; done
    return i;
  }

  private fun parse_value (s:string) (i:int): int * ParseResult =>
    if s.[i] in "0123456789" then parse_int s i
    elif s.[i] == '"'.char then parse_string s (i+1)
    elif s.[i] == "{".char then parse_dictionary s (i+1)
    elif s.[i] ==  "[".char then parse_array s (i+1)
    elif s.[i] in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" then parse_name s i
    else i, Bad i
    endif
  ;

  private fun parse_name (s:string) (var i:int) = {
    var j = s.[i].string;
    ++i; 
    while s.[i] in "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_" do
       j += s.[i];
       ++i;
    done
    return i,Good (Jname j);
  }

  private fun parse_int (s:string) (var i:int) = {
    var j = "";
    while s.[i] in "0123456789" do
       j += s.[i];
       ++i;
    done
    return i,Good (Jinteger j);
  }

  private fun parse_string (s:string) (var i:int) = {
    var r = "";
    while s.[i] != "".char and s.[i] != '"'.char do
      r += s.[i];
      ++i;
    done
    if s.[i] == '"'.char do
      ++i;
      return i,Good (Jstring r);
    else
      return i, Bad i;
    done
  }

  private fun parse_dictionary (s:string) (var i:int) = {
    var elts = #list[Jvalue * Jvalue];
    i = skip_white s i;
    while s.[i] != "}".char do
      if s.[i] == '"'.char do
        def i, var ms = parse_string s (i+1);
        match ms with
        | Good ?sv => 
          i = skip_white s i;
          if s.[i] == ":".char do
            ++i;
            i = skip_white s i;
            def i, var mv = parse_value s i;
            match mv with 
            | Good ?v =>
              elts += sv,v;
              i = skip_white s i;
            | Bad ?j => return i, Bad j;
            endmatch;
          else
            return i, Bad i;
          done
          if s.[i] == ",".char do
            ++i; 
            i = skip_white s i;
          elif s.[i] == "}".char do ; 
          else
            return i, Bad i;
          done 
        | Bad ?j => return i, Bad j;
        endmatch;
      else
        return i, Bad i;
      done
    done
    ++i;
    i = skip_white s i;
    return i, Good (Jdictionary(rev elts));
  }

  private fun parse_array (s:string) (var i:int) = {
    var elts = #list[Jvalue];
    i = skip_white s i;
    while s.[i] != "]".char do
      def i, var mv = parse_value s i;
      match mv with
      | Good ?v => elts += v; 
        i = skip_white s i;
        if s.[i] == ",".char do
          ++i; 
          i = skip_white s i;
        elif s.[i] == "]".char do ; 
        else
          return i, Bad i;
        done 
      | Bad ?j => return i, Bad j;
      endmatch;
    done
    ++i;
    i = skip_white s i;
    return i, Good (Jarray (rev elts));
  }
}

