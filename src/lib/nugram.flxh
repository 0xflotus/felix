
SCHEME """
(begin
  (define (first x)(car x))
  (define (second x)(cadr x))
  (define (third x)(caddr x))
  (define (tail x)(cdr x))
)
""";

SCHEME """
(define fold_left
  (lambda (f acc lst)
    (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst)))))
""";

SCHEME """
(define (mkname x)`(ast_name ,_sr ,x ()))
""";

SCHEME """
(define (typesoftvarlist x) (map mkname (map first (first x))))
""";

SCHEME """
(define dfltaux '( (ast_tuple ("dummy" 0 0 0 0) ()) ()))
""";

SCHEME """
(define dfltvs
  `(
    ()           ;; vs list: name,type,constraint triple
    ,dfltaux
  )
)
""";

SCHEME """
  (define dfltargs '((() none)))
""";

SCHEME """
  (define (lazy stmts) `(ast_lambda (,dfltvs ,dfltargs typ_none ,stmts)))
""";

SCHEME """
  (define (lazy_proc stmts) `(ast_lambda (,dfltvs ,dfltargs ast_void ,stmts)))
""";

SCHEME """
  (define (block stmts)`(ast_call ,_sr ,(lazy_proc stmts) ())))
""";

SCHEME """
  (define call (lambda (f a) `(ast_call ,_sr (ast_name ,_sr ,f ()) ,a)))
""";

SCHEME """
(define (splitapply x)
  (if (pair? x)
    (if (eq? (car x) 'ast_apply)
      (if (pair? (cddr x))
        (begin
;;           (display "f=")(display (caaddr x))
;;           (display " arg=")(display (cadaddr x))
;;           (display " pair=")(display (caddr x))
           (caddr x))
        (list x ()))
      (list x ()))
    (list ()))
)
""";

SCHEME """
(define (mkl x)
  (begin
  ;;(display "mkl x=")(display x)
  (if (pair? x)
    (if (eq? (car x) 'ast_tuple)
      (if (pair? (cddr x)) (caddr x) (list x))
      (list x))
    (list x)))
)
""";

SCHEME """
(define (mkl2 x)
  (begin
  ;;(display "mkl2 x=")(display x)
  (if (pair? x)
    (if (eq? (car x) 'ast_product)
      (if (pair? (cddr x)) (caddr x) (list x))
      (list x))
    (list x)))
)
""";

SCHEME """
(define (cal_funkind adjs fk)
  (if (eq? fk 'CFunction)'CFunction
  (if (eq? fk 'Generator)'Generator
  ;; fk is Function
  (if (pair? adjs)(car adjs)'Function
))))
""";

SCHEME """
(define (myassoc elt alst)
  (let ((r (assoc elt alst)))
  (if r (cadr r) `(MISMATCHED_BRACKET ,elt ,alst))))
""";

SCHEME """
(define (tvfixup_folder vsct vtc)
  (begin ;;(display "tvfixup_folder vsct=")(display vsct)(display ", vtc=")(display vtc)(display "\\n")
  (let*
    (
      (vs (car vsct))
      (ct (cadr vsct))
      (v (car vtc))
      (t (cadr vtc))
      (c (caddr vtc))
      (ct2
        (cond
          ((eq? 'NoConstraint c) ct )
          ((eq? 'Eq (car c)) ;; type constraint
            `(ast_intersect
              ((ast_type_match ((ast_name ,_sr ,v ()) ((,(cadr c) ()))))
              ,ct)
            )
          )
          ((eq? 'In (car c)) ;; type constraint
            `(ast_intersect
              ((ast_isin ((ast_name ,_sr ,v ()) ,(cadr c)))
              ,ct)
            )
          )
        (else (display "ERROR!!!"))
        )
      )
    )
    (begin
    ;;  (display "vs=")(display vs)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\nv=")(display v)
    ;;  (display "\\nt=")(display t)
    ;;  (display "\\nc=")(display c)
    ;;  (display "\\nct2=")(display ct2)
    ;;  (display "\\n")
    (list (cons `(,v ,t) vs) ct2))
))))
""";

//
// rti = rtc:type constraint, rtr:typeclass requirement list
//

SCHEME """
(define (tvfixup tv ct)
  (begin ;;(display "tvfixup tv=")(display tv)(display ", ct=")(display ct)(display "\\n")
  (let*
    (
      (vscs (fold_left tvfixup_folder `(() (ast_tuple ,_sr ())) tv))
      (vs (car vscs))
      (cs (cadr vscs))
      (rtc (car ct))
      (rtr (cadr ct))
      (ct `((ast_intersect (,rtc ,cs)) ,rtr))
    )
    (begin
    ;;  (display "vs=")(display vs)
    ;;  (display "\\ncs=")(display cs)
    ;;  (display "\\nrtc=")(display rtc)
    ;;  (display "\\nrtr=")(display rtr)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\n")
    (list (reverse vs) ct))
  )
))
""";

SCHEME """
  (define (maybe k)(if (null? k)'none `(some ,(car k))))
""";

SCHEME """
  (define (strap a b)
  (if(null? b)a(if(equal? b "")a(if(equal? a "")b(string-append a " " b)))))
""";

SCHEME """
  (define (strcat ls)(fold_left strap "" ls))
""";

// chain 'and (x) yields just x,
// chain 'and (x y) yields ('and _sr (x y))
SCHEME """
  (define (chain op hd tl)
    (
      if (equal? tl ())
      hd
      `(,op ,_sr ,(cons hd (map cadr tl)))
    )
  )
""";

SCHEME """
(begin
  (define typenames ())
  (define (addtype t) (set! typenames (cons t typenames)))
  (define (istype) (if (member _arg typenames)_arg ()))
)
""";

//------------------------------------------
syntax expressions {
  /* Experimentally, start coding up for priority management */
  priority 
    let_pri < 
    slambda_pri <
    sdollar_apply_pri < 
    stuple_pri <
    sor_condition_pri <
    sand_condition_pri <
    snot_condition_pri <
    scomparison_pri <
    sas_expr_pri <
    ssetunion_pri <
    ssetintersection_pri <
    sarrow_pri <
    scase_literal_pri <
    sbor_pri <
    sbxor_pri <
    sband_pri <
    sshift_pri <
    ssum_pri <
    ssubtraction_pri <
    sproduct_pri <
    s_term_pri <
    sprefixed_pri <
    spower_pri <
    ssuperscript_pri <
    srefr_pri <
    sapplication_pri <
    scoercion_pri <
    sfactor_pri 
  ;

  sexpr := x[let_pri] =># "_1";
  stypeexpr:= x[sor_condition_pri] =># "_1";

  x[let_pri] := "let" spattern = x[let_pri] "in" x[let_pri] =># "`(ast_letin (,_2 ,_4 ,_6))";


  x[sdollar_apply_pri] := x[stuple_pri] "unless" x[let_pri] "then" x[sdollar_apply_pri] =>#
    "`(ast_cond ((ast_apply ,_sr (lnot ,_3)) ,_1 ,_5))";
  x[sdollar_apply_pri] := x[stuple_pri] $ x[sdollar_apply_pri] =># "`(ast_apply ,_sr (,_1 ,_3))";

  x[stuple_pri] := x[>stuple_pri] ( , x[>stuple_pri])+ =># "(chain 'ast_tuple _1 _2)";
  x[sor_condition_pri] := x[>sor_condition_pri] ( or x[>sor_condition_pri])+ =># "(chain 'ast_orlist _1 _2)" note "lor";
  x[sand_condition_pri] := x[>sand_condition_pri] ( and x[>sand_condition_pri])+ =># "(chain 'ast_andlist _1 _2)" note "land";
  x[snot_condition_pri] := not x[snot_condition_pri]  =># "`(ast_apply ,_sr (lnot ,_2))" note "lnot";

  // NOTE: this version doesn't support chains like a < b < c.. too bad
  x[scomparison_pri]:= x[>scomparison_pri] < x[>scomparison_pri] =># "`(ast_apply ,_sr (lt (,_1 ,_3)))" note "lt";
  x[scomparison_pri]:= x[>scomparison_pri] <= x[>scomparison_pri] =># "`(ast_apply ,_sr (le (,_1 ,_3)))" note "le";
  x[scomparison_pri]:= x[>scomparison_pri] == x[>scomparison_pri] =># "`(ast_apply ,_sr (eq (,_1 ,_3)))" note "eq";
  x[scomparison_pri]:= x[>scomparison_pri] != x[>scomparison_pri] =># "`(ast_apply ,_sr (ne (,_1 ,_3)))" note "ne";
  x[scomparison_pri]:= x[>scomparison_pri] >= x[>scomparison_pri] =># "`(ast_apply ,_sr (ge (,_1 ,_3)))" note "ge";
  x[scomparison_pri]:= x[>scomparison_pri] > x[>scomparison_pri] =># "`(ast_apply ,_sr (gt (,_1 ,_3)))" note "gt";

  x[sas_expr_pri] := x[sas_expr_pri] "as" sname =># "`(ast_as (,_1 ,_3))";

  x[ssetunion_pri] := x[>ssetunion_pri] ( || x[>ssetunion_pri])+ =># "(chain 'ast_setunion _1 _2)" note "setunion";
  x[ssetintersection_pri] := x[>ssetintersection_pri] (&& x[>ssetintersection_pri])+ =># "(chain 'ast_setintersection _1 _2)" note "setintersection";
  x[sarrow_pri] := x[scase_literal_pri] -> x[sarrow_pri] =># "`(ast_arrow (,_1 ,_3))";
  x[sarrow_pri] := x[scase_literal_pri] --> x[sarrow_pri] =># "`(ast_longarrow (,_1 ,_3))";
  x[scase_literal_pri] := "case" sinteger =># "`(ast_case_tag ,_2))";
  x[scase_literal_pri] := "case" sinteger "of" x[ssum_pri] =># "`(ast_typed_case ,_2 ,_4)";
  x[scase_literal_pri] := "case" sname "of" x[ssum_pri] =># "`(ast_variant (,_2 ,_4))";

  x[sbor_pri] := x[sbor_pri] \| x[>sbor_pri] =># "`(ast_apply ,_sr (bor (,_1 ,_3)))" note "bxor";
  x[sbxor_pri] := x[sbxor_pri] \^ x[>sbxor_pri] =># "`(ast_apply ,_sr (bxor (,_1 ,_3)))" note "bor";
  x[sband_pri] := x[sband_pri] \& x[>sband_pri] =># "`(ast_apply ,_sr (band (,_1 ,_3)))" note "band";
  x[sshift_pri] := x[sshift_pri] << x[>sshift_pri] =># "`(ast_apply ,_sr (shl (,_1 ,_3)))" note "shl";
  x[sshift_pri] := x[sshift_pri] >> x[>sshift_pri] =># "`(ast_apply ,_sr (shr (,_1 ,_3)))" note "shr";

  x[ssum_pri] := x[>ssum_pri] (plus x[>ssum_pri])+ =># "(chain 'ast_sum _1 _2)" note "add";
  x[ssubtraction_pri] := x[ssubtraction_pri] - x[sproduct_pri] =># "`(ast_apply ,_sr (sub (,_1 ,_3)))" note "sub";

  x[sproduct_pri] := x[>sproduct_pri] (star x[>sproduct_pri])+ =># "(chain 'ast_product _1 _2)" note "mul";

  x[s_term_pri] := x[s_term_pri] / x[>s_term_pri] =># "`(ast_apply ,_sr (div (,_1 ,_3)))" note "div";
  x[s_term_pri] := x[s_term_pri] % x[>s_term_pri] =># "`(ast_apply ,_sr (mod (,_1 ,_3)))" note "mod";

  x[sprefixed_pri] := ! x[spower_pri] =># "`(ast_apply ,_sr (excl ,_2))" note "excl";
  x[sprefixed_pri] := plus x[spower_pri] =># "`(ast_apply ,_sr (pos ,_2))" note "pos";
  x[sprefixed_pri] := - x[spower_pri] =># "`(ast_apply ,_sr (neg ,_2))" note "neg";
  x[sprefixed_pri] := ~ x[spower_pri] =># "`(ast_apply ,_sr (bnot ,_2))" note "bnot";

  x[spower_pri] := x[ssuperscript_pri] ** x[sprefixed_pri] =># "`(ast_apply ,_sr (pow (,_1 ,_3)))" note "pow";
  x[ssuperscript_pri] := x[ssuperscript_pri] ^ x[srefr_pri] =># "`(ast_superscript (,_1 ,_3))";

  x[srefr_pri] := & x[srefr_pri] =># "`(ast_ref ,_2)";
  x[srefr_pri] := star x[srefr_pri] =># "`(ast_apply ,_sr (deref ,_2))" note "deref";
  x[srefr_pri] := "_deref" x[srefr_pri] =># "`(ast_deref ,_2)";
  x[srefr_pri] := "new" x[srefr_pri] =># "`(ast_new ,_2)";
  x[srefr_pri] := anon_value =># "_1";

  anon_value := "struct" lbrace sstruct_mem_decl* rbrace =># "`(ast_record_type ,_3)";
    sstruct_mem_decl := sname : stypeexpr ssemi =># "`(,_1 ,_3)";
  anon_value := "struct" lbrace sstruct_assign* rbrace =># "`(ast_record ,_3)";
    sstruct_assign := sname = sexpr ssemi =># "`(,_1 ,_3)";

  anon_value := "union" lbrace stype_sum_item0* rbrace =># "`(ast_variant_type ,_3)";
    stype_sum_item := sname sopt_value stvarlist "of" sexpr =># "`(,_1 ,_2 ,_3 ,_5)";
    stype_sum_item := sname sopt_value stvarlist =># "`(,_1 ,_2 ,_3 ast_void)";

    stype_sum_item0 := sname "of" sexpr =># "`(,_1 none ,_3)";
    stype_sum_item0 := sname =># "`(,_1 none ast_void)";

    stype_sum_item1 := stype_sum_item ssemi =># "_1";

    stype_sum_item2 := vbar stype_sum_item =># "_2";
    stype_sum_items2 := stype_sum_item stype_sum_item2* =># "(cons _1 _2)";
    stype_sum_items2 := stype_sum_item2* =># "_1";

  x[sapplication_pri] := x[sapplication_pri] x[scoercion_pri] =># "`(ast_apply ,_sr (,_1 ,_2))" note "apply";
  x[sapplication_pri] := "caseno" x[scoercion_pri] =># "`(ast_case_index ,_2)";
  x[sapplication_pri] := "likely" x[scoercion_pri] =># "`(ast_likely ,_2)";
  x[sapplication_pri] := "unlikely" x[scoercion_pri] =># "`(ast_unlikely ,_2)";

  x[scoercion_pri] := x[scoercion_pri] : x[sfactor_pri] =># "`(ast_coercion (,_1 ,_3))";
  x[scoercion_pri] := ssuffixed_name =># "_1";

  x[sfactor_pri] := shash_name =># "_1";
  x[sfactor_pri] := x[sfactor_pri] . lsqb sexpr rsqb =># "`(ast_apply ,_sr (subscript (,_1 ,_4)))";
  x[sfactor_pri] := x[sfactor_pri] . lsqb sexpr k"to" sexpr rsqb =># "`(ast_apply ,_sr (substring (,_1 ,_4 ,_6)))";
  x[sfactor_pri] := x[sfactor_pri] . lsqb sexpr k"to" rsqb =># "`(ast_apply ,_sr (copyfrom (,_1 ,_4)))";
  x[sfactor_pri] := x[sfactor_pri] . lsqb k"to" sexpr rsqb =># "`(ast_apply ,_sr (copyto (,_1 ,_5)))";
  x[sfactor_pri] := x[sfactor_pri] . shash_name =>#
    "`(ast_dot ,_sr (,_1 ,_3))))";
  // note the next production MUST be after the previous one so it overrides the
  // interpretation of a.(0) as an AST_dot
  x[sfactor_pri] := x[sfactor_pri] . lpar sinteger rpar =># "`(ast_get_n (,_4 ,_1))";


  // these are weirdos
  sbasic_name_comma_list:= sname (, sname)* =># "(cons _1 (map cadr _2))";

  squalified_name_comma_list:= squalified_name (, squalified_name)* =>#
    "(cons _1 (map cadr _2))";


  shash_name := # shash_name =># "`(ast_lift ,_2)";
  shash_name := sthe_name =># "_1";

  sthe_name :=
    | "the" squalified_name =># "`(ast_the ,_2)"
    | "noexpand" squalified_name =># "`(ast_noexpand ,_2)"
    | quest sname =># "`(ast_patvar ,_2)"
    | squalified_name =># "_1"
  ;
  sthe_name := satom =># "_1";

  squalified_name := squalified_name :: ssimple_name_parts =>#
    "`(ast_lookup (,_1 ,(car _3) ,(cadr _3)))";
  squalified_name := ssimple_name_parts =>#
    "`(ast_name ,_sr ,(car _1) ,(cadr _1))";
  ssuffixed_name := squalified_name "of" x[sfactor_pri] =>#
    "`(ast_suffix (,_1 ,_3))";

  ssimple_name_parts := sname           =># "`(,_1 ())";
  ssimple_name_parts := sname lsqb sexpr rsqb =># "`(,_1 ,(mkl _3))";


  satom := lpar rassign (, rassign )* rpar =>#
    "`(ast_record ,(cons _2 (map cadr _3)))"
  ;
    rassign := sname = x[sor_condition_pri] =># "`(,_1 ,_3)";


  satom := sliteral =># "_1";
  satom := _ =># "'ast_patany";
  satom := ... =># "'ast_ellipsis";
  satom := sfalse =># "'(ast_typed_case  0 2)";
  satom := strue =># "'(ast_typed_case  1 2)";

  satom := "callback" lsqb sexpr rsqb =># "`(ast_callback ,_3)";
  satom := [| sexpr |] =># "`(ast_arrayof ,(mkl _2))";
  satom := lbrace sexpr rbrace =># """
    (lazy `((ast_fun_return ,_sr ,_2)))
  """;

  satom := scompound =># "(lazy _1)";

  satom := lpar sexpr rpar =># "_2";
  satom := lpar rpar =># "'()";
  satom := sconditional =># "_1";

  sconditional := if sexpr "then" sexpr selse_part "endif" =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

  selif := "elif" sexpr "then" sexpr =># "`(,_2 ,_4)";

  selifs := selif =># "`(,_1)";
  selifs := selifs selif =># "(cons _2 _1)";

  selse_part:= "else" sexpr =># "_2";
  selse_part:= selifs "else" sexpr =>#
      """
        (let ((f (lambda (result condthn)
          (let ((cond (car condthn)) (thn (cadr condthn)))
            `(ast_cond (,cond ,thn ,result))))))
        (fold_left f _3 _1))
      """;

}

//------------------------------------------
syntax patterns {
  satom := pattern_match =># "_1";

  pattern_match := "match" sexpr "with" smatching+ "endmatch" =>#
    "`(ast_match (,_2 ,_4))";

    smatching  := vbar spattern => sexpr =># "`(,_2 ,_4)";
    smatching  := vbar => sexpr =># "`(pat_none ,_4)";

    spattern := sas_pattern "when" sexpr =># "`(pat_when ,_1 ,_3)";
    spattern := sas_pattern =># "_1";

    sas_pattern := stuple_pattern "as" sname =># "`(pat_as ,_1 ,_3)";
    sas_pattern := stuple_pattern =># "_1";

    stuple_pattern := scoercive_pattern (, scoercive_pattern )* =># "(chain 'pat_tuple _1 _2)";

    scoercive_pattern := satomic_pattern : x[sarrow_pri] =># "`(pat_coercion ,_1 ,_3)";
    scoercive_pattern := satomic_pattern =># "_1";

    satomic_pattern := strue =># "'(pat_const_ctor (ast_case_tag 1))";
    satomic_pattern := sfalse =># "'(pat_const_ctor (ast_case_tag 0))";
    satomic_pattern := sstring =># "`(pat_string ,_1)";
    satomic_pattern := quest sname =># "`(pat_as pat_any ,_2)";
    satomic_pattern := _ =># "'pat_any";
    satomic_pattern := lpar spattern rpar =># "_2";
    satomic_pattern := "struct" lbrace spat_assign+ rbrace =># "`(pat_record ,_3)";
      spat_assign := sname = spattern ssemi =># "`(,_1 ,_3)";

    satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
    satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";
      sctor_name := squalified_name =># "_1";
      sctor_name := "case" sinteger =># "`(ast_case_tag ,_2)";

    satomic_pattern := sstring .. sstring =># "`(pat_string_range ,_1 ,_3)";
    satomic_pattern := sintegral =># "`(pat_int ,(car _1) ,(cadr _1))";
    satomic_pattern := sintegral .. sintegral=>#
      "`(pat_int_range ,(car _1) ,(cadr _1) ,(car _3) ,(cadr _3))";

    satomic_pattern := k"NaN" =># "'pat_nan";
    satomic_pattern := sfloating .. sfloating =>#
      "`(pat_float_range ,_1 ,_3)";

      sfloating:= sfloat =># "`(Float_plus ,(car _1) ,(cadr _1))";
      sfloating:= - sfloat =># "`(Float_minus ,(car _2) ,(cadr _2))";
      sfloating:= k"inf" =># "'Float_inf";
      sfloating:= - k"inf" =># "'Float_minus_inf";


}

//------------------------------------------
syntax functions {
  requires expressions;
  sdeclarative := sfunction_definition =># "_1";
  sdeclarative := sprocedure_definition =># "_1";
  sdeclarative := sctor_definition =># "_1";

  x[slambda_pri] := sadjectives "fun" stvarlist slambda_fun_args fun_return_type = scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ,_7))
    """;

  x[slambda_pri] := sadjectives "fun" stvarlist slambda_fun_args fun_return_type => sexpr =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ((ast_fun_return ,_sr ,_7))))
    """;

  x[slambda_pri] := sadjectives "proc" stvarlist slambda_fun_args scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ast_void ,_5))
    """;

  x[slambda_pri] := sadjectives "proc" stvarlist scompound =>#
    """
    `(ast_lambda (,_3 ((() none)) ast_void ,_4))
    """;

    sadjective := "inline" =># "'InlineFunction";
    sadjective := "noinline" =># "'NoInlineFunction";
    sadjective := "static" =># "'InlineFunction";
    sadjective := "extern" =># "'NoInlineFunction";
    sadjective := "virtual" =># "'Virtual";
    sadjectives := sadjective* =># "_1";

    slambda_fun_arg := lpar sparameter_comma_list "when" sexpr rpar =># "`(,_2 (some ,_4))";
    slambda_fun_arg := lpar sparameter_comma_list rpar =># "`(,_2 none)";
    slambda_fun_args := slambda_fun_arg+ =># "_1";

    fun_return_type := : stypeexpr "expect" sexpr =># "`(,_2 (some ,_4))";
    fun_return_type := : stypeexpr =># "`(,_2 none)";
    fun_return_type := "expect" sexpr =># "`(typ_none (some ,_2))";
    fun_return_type := sepsilon =># "'(typ_none none)";

    sparameter := sparam_qual sname : x[sarrow_pri] = x[sor_condition_pri] =># "`(,_1 ,_2 ,_4 (some ,_6))";
    sparameter := sparam_qual sname : x[sarrow_pri] =># "`(,_1 ,_2 ,_4 none)";
    sparameter := sparam_qual sname =># "`(,_1 ,_2 typ_none none)";

    sparameter_comma_list := sepsilon =># "()";
    sparameter_comma_list := sparameter (, sparameter)* =># "(cons _1 (map cadr _2))";


    sparam_qual := "val" =># "'PVal";
    sparam_qual := "var" =># "'PVar";
    sparam_qual := "ref" =># "'PRef";
    sparam_qual := "fun" =># "'PFun";
    sparam_qual := sepsilon =># "'PVal";

  sfun_arg :=  lpar sparameter_comma_list "when" sexpr rpar =># "`(,_2 (some ,_4))";
  sfun_arg :=  lpar sparameter_comma_list rpar =># "`(,_2 none)";
  sfun_arg :=  sname =># "`(((PVal ,_1 typ_none none)) none)";

  sfun_kind := "cfun" =># "'CFunction";
  sfun_kind := "gen" =># "'Generator";
  sfun_kind := "fun" =># "'Function";

  sfunction_definition := sadjectives sfun_kind sdeclname
    sfun_arg* fun_return_type => sexpr ssemi =>#
  """
    (let ((body `((ast_fun_return ,_sr ,_7))))
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,body)
    )
  """;


  sfunction_definition := sadjectives sfun_kind sdeclname
    sfun_arg* fun_return_type = scompound =>#
  """
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,_7)
  """;

  sopt_cstring := = scode_spec =># "`(some ,_2)";
  sopt_cstring := sepsilon =># "'none";

  sfunction_definition := sadjectives sfun_kind sdeclname
    fun_return_type = smatching+ ssemi =>#
  """
   (let
     (
      (t (car _4))
      (traint (cadr _4))
     )
    (begin ;;(display "ftype=")(display t)(display "\\n")
    (if (eq? 'ast_arrow (car t))
      (let
        (
          (argt (caadr t))
          (ret (cadadr t))
          (body `((ast_fun_return ,_sr (ast_match (_a ,_6)))))
        )
        `(ast_curry ,_sr ,(caar _3) ,(cadar _3)
          (
            (((PVal _a ,argt none)) none)
          )
          (,ret ,traint)
          ,(cal_funkind _1 _2) ,body)
      )
      'ERROR
     )
     )
   )
  """;

  sproc_kind := "proc" =># "'Function";
  sproc_kind := "cproc" =># "'CFunction";

  sopt_traint_eq:= "expect" sexpr = =># "`(some ,_2)";
  sopt_traint_eq:= = =># "'none";
  sopt_traint_eq:= sepsilon =># "'none";

  sopt_traint:= "expect" sexpr =># "`(some ,_2)";
  sopt_traint:= sepsilon =># "'none";


  sctor_init := sname lpar sexpr rpar =># "`(,_1 ,_3)";
  sctor_inits := : sctor_init (, sctor_init)* =># "(cons _2 _3)";
  sctor_inits := sepsilon =># "()";

  // only used by classes
  sctor_definition := "ctor" stvarlist sfun_arg* sopt_traint_eq
    sctor_inits scompound =>#
  """
  (let*
    (
      (name "__constructor__")
      (vs _2)
      (ret 'ast_void)
      (traint _4)
      (body _6)
      (inits _5)
      (args _3)
      (f (lambda (ne)`(ast_init ,_sr ,(car ne) ,(cadr ne))))
      (body (append (map f inits) body))
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Ctor ,body))
  """;

  sctor_definition := "ctor" stvarlist sname sfun_arg+ sopt_traint_eq
    scompound =>#
  """
  (let*
    (
      (name (string-append "_ctor_" _3))
      (vs _2)
      (ret `(ast_name ,_sr ,_3 ()))
      (traint _5)
      (body _6)
      (args _4)
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Function ,body))
  """;

  sctor_definition := "ctor" stvarlist sname sfun_arg+
    sopt_traint => sexpr ssemi =>#
  """
  (let*
    (
      (name (string-append "_ctor_" _3))
      (vs _2)
      (ret `(ast_name ,_sr ,_3 ,(typesoftvarlist _2)))
      (traint _5)
      (body `((ast_fun_return ,_sr ,_7)))
      (args _4)
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Function ,body))
  """;

  sprocedure_definition := sadjectives sproc_kind sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) ,(cal_funkind _1 _2) ,_6)
  """;

  sprocedure_definition := sadjectives sproc_kind sdeclname
    sfun_arg* => statement =>#
  """
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void none) ,(cal_funkind _1 _2) (,_6))
  """;
}

//------------------------------------------
syntax statements {
  requires expressions;
  statement:= sexecutable=># "_1";
  statement:= sdeclarative =># "_1";
  statement:= sinclusion =># "_1";
  statement:= sdirective =># "_1";
  statement:= spublish =># "_1";
  statement:= scomment =># "_1";
  statement:= snull_statement =># "_1";

  scomment := comment sstring ssemi =># "`(ast_comment ,_sr ,_2)";


  spublish := "private" sdeclarative =># "`(ast_private ,_2)";
  spublish := "private" sbinding_definition =># "`(ast_private ,_2)";
  spublish := "private" svar_def =># "`(ast_private ,_2)";
  spublish := "private" sval_def =># "`(ast_private ,_2)";

  spublish := "publish" sstring statement =># "_3";

  sdeclarative := smodule_definition =># "_1";
  sdeclarative := sunion_decl =># "_1";
  sdeclarative := sstruct_decl =># "_1";
  sdeclarative := stype_alias =># "_1";

  sdirective := sopen_decl =># "_1";

  snull_statement := ssemi =># """`(ast_nop ,_sr "")""";

  sinclusion := "include" sstring ssemi =># "`(ast_include ,_sr ,_2)";

  // note: list is reversed, eg X::Y::name goes to list name, Y, Z
  sdeclname := sdeclname :: sname stvarlist =># "(cons `(,_3 ,_4) _1)";
  sdeclname := sname stvarlist =># "`((,_1 ,_2))";

  sabstract_type := stype_qual* "type" sdeclname = "new" sexpr ssemi =>#
    """
    `(ast_newtype ,_sr ,(caar _3) ,(cadar _3) ,_6)
    """;

  stype_constraint := "with" squalified_name_comma_list "where" sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := "where" sexpr "with" squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := "where" sexpr =># "`(,_2 ())";
  stype_constraint := "with" squalified_name_comma_list =># "`((ast_tuple,_sr()) ,_2)";
  stype_constraint := sepsilon =># "`((ast_tuple,_sr())())";

  seqorin:= = stypeexpr =># "`(Eq ,_2)";
  seqorin:= "in" stypeexpr =># "`(In ,_2)";
  seqorin:= sepsilon =># "'NoConstraint";

  stvar := sname seqorin =># """`(,_1 (ast_name ,_sr "TYPE" ()) ,_2)""";
  stvar := sname : stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := , stvar =># "_2";

  stvarlist:= sepsilon =># "dfltvs";
  stvarlist:= lsqb stvar_comma_list stype_constraint rsqb =>#
    "(tvfixup _2 _3)";

  stypeparameter:= sname : x[sarrow_pri] =># "`(,_1 ,_3)";
  stypeparameter:= sname =># "`(,_1 typ_none)";
  stypeparameter_comma_list := sepsilon =># "()";
  stypeparameter_comma_list := stypeparameter , stypeparameter_comma_list =># "(cons _1 _3)";
  stypeparameter_comma_list := stypeparameter =># "`(,_1)";

  stypefun_arg := sname =># "`((,_1 typ_none))";
  stypefun_arg := lpar stypeparameter_comma_list rpar =># "_2";
  stypefun_args := stypefun_arg+  =># "_1";

  stodo := "todo" sstring ssemi =># "`(ast_nop ,_sr ,_2)";
  stodo := "todo" ssemi =># """`(ast_nop ,_sr "todo")""";

  //scompound := lbrace statement* rbrace =># "_2";
  scompound := lbrace sstatements rbrace =># "_2";

  sname_suffix:= comma sname sname_suffix =># "(cons _2 _3)";
  sname_suffix:= comma sname =># "`(,_2)";

}

//------------------------------------------
syntax variables {
  // assignments have lower priority than variable
  // definitions to support 'int x = 1;' being
  // a variable definition not an assignment,
  // so we have to requires them first: they're
  // currently defined in executable.. this is fragile ..
  requires statements, executable;

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  sval_def := "val" sname sname_suffix = sexpr ssemi =>#
  """
  (let
    (
      (names (cons _2 _3))
      (vals (mkl _5))
    )
    (begin
    ;;(display "names=")(display names)
    ;;(display "init=")(display vals)
    ;;(display "\\n")
    (if (eq? (length names)(length vals))
      (let
        (
          (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
        )
        `(ast_seq ,_sr ,(map f names vals))
      )
      (let*
        (
          (f (lambda (n)`((Val ,_sr ,n) none)))
          (lexpr (map f names))
        )
        `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
      )
  )))
  """;

  sval_def := "val" sdeclname = sexpr ssemi =>#
    """
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) none (some ,_4))
     """;

  sval_def := "val" sdeclname : stypeexpr = sexpr ssemi =>#
    """
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
     """;

  sval_def := "val" sdeclname : stypeexpr ssemi =>#
    """
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) none)
     """;

  sval_def := "ref" sdeclname <- sexpr ssemi =>#
    """
    `(ast_ref_decl ,(caar _2) ,(cadar _2) none (some ,_4))
     """;

  sval_def := "ref" sdeclname : stypeexpr <- sexpr ssemi =>#
    """
    `(ast_ref_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
     """;

  sval_def := "fun" sdeclname <- sexpr ssemi =>#
    """
    `(ast_lazy_decl ,(caar _2) ,(cadar _2) none (some ,_4))
     """;

  sval_def := "fun" sdeclname : stypeexpr <- sexpr ssemi =>#
    """
    `(ast_lazy_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
     """;

  svar_def := "var" sname sname_suffix = sexpr ssemi =>#
  """
  (let
    (
      (names (cons _2 _3))
      (vals (mkl _5))
    )
    (begin
    ;;(display "names=")(display names)
    ;;(display "init=")(display vals)
    ;;(display "\\n")
    (if (eq? (length names)(length vals))
      (let
        (
          (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
        )
        `(ast_seq ,_sr ,(map f names vals))
      )
      (let*
        (
          (f (lambda (n)`((Var ,_sr ,n) none)))
          (lexpr (map f names))
        )
        `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
      )
  )))
  """;

  svar_def := "var" sdeclname = sexpr ssemi =>#
    """
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) none (some ,_4))
     """;

  svar_def := "var" sdeclname : stypeexpr = sexpr ssemi =>#
    """
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
     """;

  svar_def := "var" sdeclname : stypeexpr ssemi =>#
    """
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) none)
     """;

}

//------------------------------------------
syntax macros {
  requires expressions, statements;

  sdirective := smacro_definition =># "_1";
  smacro_definition := macro sname "is" sbasic_name_comma_list ssemi =>#
    "`(ast_macro_names ,_2 ,_4)";

  // this MUST be next, overrides case with only one name
  smacro_definition := macro sname "is" sname ssemi =># "`(ast_macro_name ,_2 ,_4)";
  smacro_definition := macro for sname "in" sbasic_name_comma_list do statement* done ssemi =>#
    "`(ast_macro_ifor ,_3 ,_5 ,_7)";
  smacro_definition := macro for sname "in" lpar sbasic_name_comma_list rpar do statement* done ssemi =>#
    "`(ast_macro_ifor ,_3 ,_6 ,_9)";

  smacro_definition := macro sname "is" "new" ssemi =># """`(ast_macro_name ,_2 "")""";
  smacro_definition := macro "var" sbasic_name_comma_list = sexpr ssemi =>#
    "`(ast_macro_var ,_3 ,_5)";
  smacro_definition := macro "val" sbasic_name_comma_list = sexpr ssemi =>#
    "`(ast_macro_val ,_3 ,_5)";
  smacro_definition := macro sbasic_name_comma_list = sexpr ssemi =>#
    "`(ast_macro_assign ,_2 ,_4)";
  smacro_definition := macro "val" sname "is" sexpr ssemi =>#
    "`(ast_macro_vals ,_3 ,(mkl _5))";
  smacro_definition := macro "fun" sname smac_arg_list = sexpr ssemi =>#
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro "fun" sname smac_arg_list => sexpr ssemi =>#
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro "proc" sname smac_arg_list scompound =>#
    "`(ast_stmt_macro ,_3 ,_4 ,_5)";
  smacro_definition := macro scompound ssemi =># "`(ast_macro_block ,_2)";
  smacro_definition := macro "forget" sbasic_name_comma_list ssemi =>#
    "`(ast_macro_forget ,_3)";
  smacro_definition := macro "forget" ssemi =>#
    "`(ast_macro_forget ())";
  smacro_definition := macro "goto" sname ssemi =># "`(ast_macro_goto ,_3)";
  smacro_definition := macro sname :> =># "`(ast_macro_label ,_2)";
  smacro_definition := macro if sexpr "goto" sname ssemi =>#
    "`(ast_macro_ifgoto ,_3 ,_5)";
  smacro_definition := macro for "val" sbasic_name_comma_list "in" sexpr do statement* done ssemi =>#
    "`(ast_macro_vfor ,_4 ,_6 ,_8)";

    smac_arg:= sname : "fun" =># "`(,_1 Expr)";
    smac_arg:= sname : "proc" =># "`(,_1 Stmt)";
    smac_arg:= sname : sident =># "`(,_1 Stmt)";
    smac_arg:= sname =># "`(,_1 Expr)";
    smac_args := smac_arg , smac_args =># "(cons _1 _3)";
    smac_args := smac_arg =># "`(,_1)";
    smac_arg_list := lpar smac_args rpar =># "_2";
    smac_arg_list := lpar rpar =># "()";

  x[sapplication_pri] := macro "ctor" sname x[scoercion_pri] =># "`ast_macro_ctor (,_3 ,_4))";
}

//------------------------------------------
syntax cbind {
  requires expressions, statements;

  statement:= sbinding_definition =># "_1";
  sbinding_definition :=  sabstract_type =># "_1";
  sbinding_definition :=  sconst_def =># "_1";
  sbinding_definition :=  sbinding_header =># "_1";
  sbinding_definition :=  sexport_statement =># "_1";
   sexport_statement := "export" "fun" ssuffixed_name "as" sstring ssemi =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
   sexport_statement := "export" "python" "fun" ssuffixed_name "as" sstring ssemi =>#
    "`(ast_export_python_fun ,_sr ,_4 ,_6)";
  sexport_statement := "export" "proc" ssuffixed_name "as" sstring ssemi =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
  sexport_statement := "export" "type" lpar sexpr rpar "as" sstring ssemi =>#
    "`(ast_export_type ,_sr ,_4 ,_7)";

  sopt_prec := "is" sname =># "_2";
  sopt_prec := sepsilon =># '(quote "")';

  // note: also needed by typeclasses atm for virtual funs
  sfunction_definition := sadjectives sfun_kind sdeclname
    fun_return_type sopt_cstring sopt_prec srequires_clause ssemi =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t (car _4))
      (traint (cadr _4))
      (prec _6)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
        _7)
      )
      (ct
        (if (eq? 'none _5)
          (if (memv 'Virtual _1)
            'Virtual
             `(StrTemplate ,(string-append (caar _3) "($a)"))
           )
           (cadr _5))
      )
    )
    (let (
      (reqs
        (if (eq? 'Generator kind)
          `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
          reqs))
    )
    (if (eq? 'ast_arrow (car t))
      (let (
        (argt (caadr t))
        (ret (cadadr t)))
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
      )
      ('ERROR))))
  """;

  sfunction_definition :=
    "ctor" sname stvarlist : stypeexpr
    sopt_cstring sopt_prec srequires_clause ssemi =>#
  """
  (let*
    (
      (name (string-append "_ctor_" _2))
      (vs _3)
      (ret `(ast_name ,_sr ,_2 ()))
      (argt _5)
      (ct
        (if (eq? 'none _6)
          `(StrTemplate ,(string-append _2 "($a)"))
          (cadr _6)
        )
      )
      (prec _7)
      (reqs _8)
    )
    `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
  )
  """;

  sabstract_type:= stype_qual* "type" sdeclname = scode_spec srequires_clause ssemi =>#
    """
    `(ast_abs_decl ,_sr ,(caar _3) ,(cadar _3) ,_1 ,_5 ,_6)
    """;

  sabstract_type := "callback" "proc" sname : stypeexpr srequires_clause ssemi =>#
    """
    `(ast_callback_decl ,_sr ,_3 ,(mkl2 _5) ast_void ,_6)
    """;


  sabstract_type := "callback" "fun" sname : stypeexpr srequires_clause ssemi =>#
    """
    (if (eq? 'ast_arrow (car _5))
      (let*
        (
          (ft (cadr _5))
          (dom (car ft))
          (cod (cadr ft))
          (args (mkl2 dom))
        )
      `(ast_callback_decl  ,_sr,_3 ,args ,cod ,_6)
      )
      'ERROR
    )
    """;


  stype_qual := "incomplete" =># "'Incomplete";
  stype_qual := "pod" =># "'Pod";
  stype_qual := "_gc_pointer" =># "'GC_pointer";
  stype_qual := "_gc_type" stypeexpr =># "`(Raw_needs_shape ,_2)";

  sabstract_type:= stype_qual* "ctypes" sbasic_name_comma_list srequires_clause ssemi =>#
    "`(ast_ctypes ,_sr ,_3 ,_1 ,_4)";

  sexecutable := sinline_cpp =># "_1";
  sinline_cpp:= "code" scode_spec ssemi =># "`(ast_code ,_sr ,_2)";
  sinline_cpp:= "noreturn" "code" scode_spec ssemi =># "`(ast_noreturn_code ,_sr ,_3)";

  sclass_component:= "var" sname : stypeexpr ssemi =># "`(MemberVar ,_2 ,_4 none)";
  sclass_component:= "val" sname : stypeexpr ssemi =># "`(MemberVal ,_2 ,_4 none)";
  sclass_component:= "ctor" sopt_name : stypeexpr sopt_cstring ssemi =>#
    "`(MemberCtor ,_2 none ,_4 ,_5)";
  sclass_component:= "fun" sname stvarlist  : stypeexpr sopt_cstring ssemi =>#
    "`(MemberFun ,_2 none ,_3 ,_5 ,_6)";
  sclass_component:= "proc" sname stvarlist  : stypeexpr sopt_cstring ssemi =>#
    "`(MemberProc ,_2 none ,_3 ,_5 ,_6)";

  sexpr_code_prefix := "code" lsqb stypeexpr rsqb =># "_3";
  satom := sexpr_code_prefix sstring =># "`(ast_expr ,_2 ,_1)";
  satom := sexpr_code_prefix sname =># "`(ast_expr ,_2 ,_1)";

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives "const" sdeclname : stypeexpr = scode_spec srequires_clause ssemi =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and (rreq_atom (Property_req "virtual")) ,_8)
      _8)))
    `(ast_const_decl ,_sr ,(caar _3) ,(cadar _3) ,_5 ,_7 ,reqs)
    )
  """;

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives "const" sdeclname : stypeexpr srequires_clause ssemi =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and (rreq_atom (Property_req "virtual")) ,_6)
      _6)))
    `(ast_const_decl ,_sr ,(caar _3) ,(cadar _3) ,_5 (Str ,(caar _3)) ,reqs)
    )
  """;

  // note: also needed by typeclasses atm for virtual procs
  sprocedure_definition := sadjectives sproc_kind sdeclname : stypeexpr
    sopt_cstring srequires_clause ssemi =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t _5)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
        _7)
      )
      (ct
        (if (eq? 'none _6)
          (if (memv 'Virtual _1)
            'Virtual
             `(StrTemplate ,(string-append (caar _3) "($a);"))
           )
           (cadr _6))
      )
    )
    (let (
      (reqs
        (if (eq? 'Generator kind)
          `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
          reqs))
    )
    (let (
      (argt t)
      (ret 'ast_void))
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs "")
      )))
  """;


}

//------------------------------------------
syntax executable {
  requires statements;
  sexecutable := scall =># "_1";
  sexecutable := ssvc =># "_1";
  sexecutable := sreturn =># "_1";
  sexecutable := sifgoto =># "_1";
  sexecutable := stodo =># "_1";
  sexecutable := sassignment =># "_1";
  sexecutable := sgoto_statement=># "_1";
  sexecutable := slabel_statement =># "_1";

  ssvc := "_svc" sname ssemi =># "`(ast_svc ,_sr ,_2)";

  sassignment := sassignexpr ssemi =># "_1";

  // a0 <- f (a1, a2, ..)  means f (a0, a1, a2 ..)
  sassignexpr := sexpr <- sexpr =>#
   """
   (let* (
     (fl (splitapply _3))
     (f (car fl))
     (a (cadr fl)))
     (begin
     ;; (display "f=")(display f)
     ;; (display "\\n_1=")(display _1)
     ;; (display "\\na=")(display a)
     ;; (display "\\nnew a=")(display (cons _1 (mkl a)))
     ;; (display "\\n")
     `(ast_call ,_sr ,f ,(cons _1 (mkl a)))))
   """;

  sassignop:= = =># "'_set";
  sassignop:= := =># "'_init";

  srmwop:= += =># "'pluseq";
  srmwop:= -= =># "'minuseq";
  srmwop:= *= =># "'muleq";
  srmwop:= /= =># "'diveq";
  srmwop:= %= =># "'modeq";
  srmwop:= <<= =># "'leftshifteq";
  srmwop:= >>= =># "'rightshifteq";
  srmwop:= ^= =># "'bxoreq";
  srmwop:= |= =># "'boreq";
  srmwop:= &= =># "'bandeq";
  srmwop:= ~= =># "'tildeeq";

  sswapop := <-> =># "'_swap";

  spreincrop:= ++ =># "'pre_incr";
  spreincrop:= -- =># "'pre_decr";
  spostincrop:= ++ =># "'post_incr";
  spostincrop:= -- =># "'post_decr";

  slelement := "val" sname =># "`(Val ,_sr ,_2)";
  slelement := "var" sname =># "`(Var ,_sr ,_2)";
  slelement := sname =># "`(Name ,_sr ,_1)";
  slelement := _ =># "`(Skip ,_sr)";
  slelement := lpar slexprs rpar =># "`(List ,_2)";

  stlelement := slelement : x[sfactor_pri] =># "`(,_1 (some ,_3))";
  stlelement := slelement =># "`(,_1 none)";

  slexprs := stlelement , slexprs =># "(cons _1 _3)";
  slexprs := stlelement =># "`(,_1)";

  slexpr := slexprs =>#
    """
    (if (null? (cdr _1)) (car _1) `((List ,_1) none))
    """;

  sassignexpr := "def" slexpr = sexpr =># "`(ast_assign ,_sr _set ,_2 ,_4)";

  sassignexpr := sexpr sswapop sexpr =>#
    "`(ast_call ,_sr ,_2 (,_1 ,_3))";

  sassignexpr := sexpr sassignop sexpr =>#
    "`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)";

  sassignexpr := sexpr srmwop sexpr =>#
    "`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)";

  sassignexpr := sexpr spostincrop =># "`(ast_call ,_sr ,_2 (ast_ref ,_1))";
  sassignexpr := spreincrop sexpr =># "`(ast_call ,_sr ,_1 (ast_ref ,_2))";

  sreturn := "yield" sexpr ssemi =># "`(ast_yield ,_sr ,_2)";
  sreturn := "return" sexpr ssemi =># "`(ast_fun_return ,_sr ,_2)";
  sreturn := "return" ssemi =># "`(ast_proc_return ,_sr)";
  sreturn := "halt" sstring ssemi =># "`(ast_halt ,_sr ,_2)";
  sreturn := "trace" sname sstring ssemi =># "`(ast_trace ,_sr ,_2 ,_3)";

  scall := "call" sexpr ssemi =># """(cons 'ast_call (cons _sr (splitapply _2)))""";
  scall := "jump" sexpr ssemi =># """(cons 'ast_jump (cons _sr (splitapply _2)))""";
  //scall := loop sname sexpr ssemi =># "`(ast_loop ,_sr ,_2 ,_3)";
  //scall := loop sname ssemi =># "`(ast_loop ,_sr ,_2 (ast_tuple,_sr ()))";
  scall := "loop" sname sexpr ssemi =># "`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) ,_3)";
  scall := "loop" sname ssemi =># "`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) (ast_tuple,_sr ()))";

  scall := sexpr ssemi =># "(cons 'ast_call (cons _sr (splitapply _1)))";

  slabel_statement := sname :> =># "`(ast_label ,_sr ,_1)";
  sgoto_statement := "goto" sname ssemi =># "`(ast_goto ,_sr ,_2)";


  sifgoto := if sexpr "goto" sname ssemi =># "`(ast_ifgoto ,_sr ,_2 ,_4)";
  sifgoto := if sexpr "return" ssemi =># "`(ast_ifreturn ,_sr ,_2)";
  sifgoto := if sexpr "call" sexpr ssemi =>#
    "`(ast_ifdo ,_sr ,_2 (,(cons 'ast_call (cons _sr (splitapply _4))))())";
  sifgoto := if sexpr do statement* selse_clause done ssemi =>#
    "`(ast_ifdo ,_sr ,_2 ,_4 ,_5)";
  sifgoto := if sexpr do statement* done ssemi =>#
    "`(ast_ifdo ,_sr ,_2 ,_4 ())";

  selif_clause := "elif" sexpr do statement* =># "`(,_2 ,_4)";
  selif_clause := "elif" sexpr "return" ssemi =># "`(,_2 ((ast_proc_return ,_sr)))";
  selif_clause := "elif" sexpr "goto" sname ssemi =># "`(,_2 (ast_goto ,_sr ,_4))";
  selif_clauses := selif_clauses selif_clause =># "(cons _2 _1)";
  selif_clauses := selif_clause =># "`(,_1)";
  selse_clause := selif_clauses "else" statement* =>#
    """
        (let ((f (lambda (result condthn)
          (let ((cond (car condthn)) (thn (cadr condthn)))
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f _3 _1))
    """;

  selse_clause := "else" statement* =># "_2";
  selse_clause := selif_clauses =>#
    """
        (let ((f (lambda (result condthn)
          (let ((cond (car condthn)) (thn (cadr condthn)))
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f () _1))
    """;

  sifgoto := "whilst" sexpr do statement* done ssemi =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "break_label" "" )
      ( ast_macro_name "continue_label" "" )
      ( ast_label ,_sr "continue_label" )
      ( ast_unlikely_ifnotgoto ,_sr ,_2 "break_label" ))
      _4
      `(( ast_goto ,_sr "continue_label" )
      ( ast_label ,_sr "break_label" ))
      )
    )
  """;

  sifgoto := "until" sexpr do statement* done ssemi =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "break_label" "" )
      ( ast_macro_name "continue_label" "" )
      ( ast_label ,_sr "continue_label" )
      ( ast_unlikely_ifgoto ,_sr ,_2 "break_label" ))
      _4
      `(( ast_goto ,_sr "continue_label" )
      ( ast_label ,_sr "break_label" ))
      )
    )
  """;


  sifgoto := "forall" sname "in" sexpr do statement* done ssemi =>#
    "`(ast_macro_vfor (,_2) ,_4 ,_6)"
  ;

  sifgoto := "forall" sname "in" sexpr "upto" sexpr do statement* done ssemi =>#
  """
    `(ast_macro_block ,( append `(
      (ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_2 ())) none) ,_4)
      ( ast_macro_name "break_label" "" )
      ( ast_macro_name "continue_label" "" )
      ( ast_macro_name "redo_label" "" )
      ( ast_label ,_sr "redo_label" )
      ( ast_unlikely_ifnotgoto ,_sr
        (ast_apply ,_sr (le ((ast_name ,_sr ,_2 ()),_6)))
        "break_label"
      ))
      _8
      `(( ast_label ,_sr "continue_label" )
      (ast_call ,_sr pre_incr (ast_ref (ast_name ,_sr ,_2())))
      ( ast_goto ,_sr "redo_label" )
      ( ast_label ,_sr "break_label" ))
     ))
  """;

  sifgoto := "forall" sname "in" sexpr "downto" sexpr do statement* done ssemi =>#
  """
    `(ast_macro_block ,( append `(
      (ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_2 ())) none) ,_4)
      ( ast_macro_name "break_label" "" )
      ( ast_macro_name "continue_label" "" )
      ( ast_macro_name "redo_label" "" )
      ( ast_label ,_sr "redo_label" )
      ( ast_unlikely_ifnotgoto ,_sr
        (ast_apply ,_sr (ge ((ast_name ,_sr ,_2 ()) ,_6)))
        "break_label"
      ))
      _8
      `(( ast_label ,_sr "continue_label" )
      ( ast_call ,_sr pre_decr (ast_ref (ast_name ,_sr ,_2 ())))
      ( ast_goto ,_sr "redo_label" )
      ( ast_label ,_sr "break_label" ))
     ))
  """;
}

//------------------------------------------
syntax requirements {
  srequires_clause := "requires" srequirements =># "_2";

  srequires_clause := sepsilon =># "'rreq_true";

  srequirement:= squalified_name =># "`(Named_req ,_1)";
  srequirement :=  "property" sstring =># "`(Property_req ,_2)";
  srequirement :=  "package" scode_spec =># "`(Package_req ,_2)";

  srequirement_atom:= srequirement =># "`(rreq_atom ,_1)";
  srequirement_atom:= lpar srequirements rpar =># "_2";

  srequirement_and:= srequirement_and and srequirement_atom =>#
    "`(rreq_and ,_1 ,_3)";
  srequirement_and:= srequirement_atom =># "_1";

  srequirement_or:= srequirement_or or srequirement_and =>#
    "`(rreq_or ,_1 ,_3)";
  srequirement_or:= srequirement_and =># "_1";

  srequirements:= srequirements , srequirement_or =>#
    "`(rreq_and ,_1 ,_3)";
  srequirements:= srequirement_or =># "_1";


  srequirement := "body" scode_spec =># "`(Body_req ,_2)";
  srequirement := "header" scode_spec =># "`(Header_req ,_2)";

  scode_spec := sstring =># "`(StrTemplate ,_1)";
  scode_spec := scstring =># "`(Str ,_1)";
  scode_spec := sident =># "'Identity";

  sbinding_header := "requires" srequirements ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs (Str "") body ,_2)""";

  sbinding_header := sname "requires" srequirements ssemi =>#
    """`(ast_insert ,_sr ,_1 ,dfltvs (Str "") body ,_3)""";

  sbinding_header:= "header" scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 header ,_3))""";
  sbinding_header:= "body" scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 body ,_3))""";
  sbinding_header:= "header" = scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 header ,_4))""";
  sbinding_header:= "body" = scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 body ,_4))""";
  sbinding_header:= "header" sdeclname = scode_spec srequires_clause ssemi =>#
    """
    `(ast_insert ,_sr ,(caar _2) ,(cadar _2) ,_4 header ,_5)
     """;

  sbinding_header:= "body" sdeclname = scode_spec srequires_clause ssemi =>#
    """
    `(ast_insert ,_sr ,(caar _2) ,(cadar _2) ,_4 body ,_5)
     """;

}

syntax type_decls {
  requires statements;

  satom := stypematch =># "_1";

  stype_alias := "typedef" sdeclname = sexpr ssemi =>#
    """
    `(ast_type_alias ,_sr ,(caar _2) ,(cadar _2) ,_4)
    """;

  stype_alias := "typedef" "fun" sdeclname stypefun_args : stypeexpr => sexpr ssemi =>#
    """
    `(mktypefun ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_6 ,_8)
    """;

  stype_alias := "typedef" "fun" sdeclname : stypeexpr = stype_matching+ ssemi =>#
    """
    (if (eq? 'ast_arrow (car _5))
      (let (
        (argt (caadr _5))
        (ret (cadadr _5))
        (body `(ast_type_match (_a ,_7))))
        (let ((args `(((_a ,argt)))))
      `(mktypefun ,_sr ,(caar _3) ,(cadar _3) ,args ,ret ,body)
      ))
      ('ERROR)
    )
    """;

  stype_matching  := vbar sexpr => sexpr =># "`(,_2 ,_4)";

  stypematch := "typematch" sexpr "with" stype_matching+ "endmatch" =>#
    "`(ast_type_match (,_2 ,_4))";

  sstruct_decl := "struct" sdeclname = ? lbrace sstruct_mem_decl * rbrace =>#
    """
    `(ast_struct ,_sr ,(caar _2) ,(cadar _2) ,_5)
     """;

  sstruct_decl := "cstruct" sdeclname = ? lbrace sstruct_mem_decl * rbrace =>#
    """
    `(ast_cstruct ,_sr ,(caar _2) ,(cadar _2) ,_5)
     """;

  sopt_name := sname =># "_1";
  sopt_name := sepsilon =># '""';

  sstruct_decl := "class" sdeclname = ? scompound =>#
    """
    `(ast_class ,_sr ,(caar _2) ,(cadar _2) ,_4)
     """;

  sstruct_decl := "typeclass" sdeclname = ? scompound =>#
    """
    `(ast_typeclass ,_sr ,(caar _2) ,(cadar _2) ,_4)
     """;

  sstruct_decl := "instance" stvarlist squalified_name = ? scompound =>#
    """
    `(ast_instance ,_sr ,_2 ,_3 ,_5)
     """;

  sunion_decl := "union" sdeclname = stype_sum_items2 ssemi =>#
    """
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
     """;

  sunion_decl := "union" sdeclname lbrace stype_sum_item1* rbrace =>#
    """
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
     """;

  sunion_decl := senum_decl =># "_1";

  senum_decl := "enum" sdeclname lbrace senum_items rbrace =>#
    """
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
     """;

  sopt_value := = sinteger =># "`(some ,_2)";
  sopt_value := sepsilon =># "'none";
  senum_item := sname sopt_value =># "`(,_1 ,_2 ,dfltvs ast_void)";
  senum_items := senum_item , senum_items =># "(cons _1 _3)";
  senum_items := senum_item =># "`(,_1)";
  senum_items := sepsilon =># "()";

}

//------------------------------------------
syntax assertions {
  requires statements;
  sexecutable := sassert_statement =># "_1";

  sassert_statement:= "assert" sexpr ssemi =># "`(ast_assert ,_sr ,_2)";

  sdeclarative := sassertion =># "_1";

  sassertion := "axiom" sdeclname sfun_arg : sexpr ssemi =>#
  """
    `(ast_axiom ,_sr ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
  """;

  sassertion := "axiom" sdeclname sfun_arg : sexpr = sexpr ssemi =>#
  """
    `(ast_axiom ,_sr ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
  """;

  sassertion := "lemma" sdeclname sfun_arg : sexpr ssemi =>#
  """
    `(ast_lemma ,_sr ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
  """;

  sassertion := "lemma" sdeclname sfun_arg : sexpr = sexpr ssemi =>#
  """
    `(ast_lemma ,_sr ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
  """;

  sreduce_args := lpar stypeparameter_comma_list rpar =># "_2";

  sassertion := "reduce" sdeclname sreduce_args : sexpr => sexpr ssemi =>#
  """
    `(ast_reduce ,_sr ,(caar _2) ,(cadar _2) ,_3 ,_5 ,_7)
  """;

}

syntax namespaces {
  requires statements;
  sopen_decl := "rename" sdeclname = squalified_name ssemi =>#
    """
    `(ast_inherit ,_sr ,(caar _2) ,(cadar _2) ,_4)
    """;

  sopen_decl := "rename" "fun" sdeclname = squalified_name ssemi =>#
    """
    `(ast_inherit_fun ,_sr ,(caar _3) ,(cadar _3) ,_5)
    """;

  sopen_decl := "inherit" squalified_name ssemi =># "`(ast_inject_module ,_sr ,_2)";

  sopen_decl := "open" stvarlist squalified_name ssemi =>#
    "`(ast_open ,_sr ,_2 ,_3)";

  sopen_decl := "use" squalified_name ssemi =>#
    """
    (let ((name
      (if (eq? (car _2) 'ast_lookup) (cadadr _2)
        (if (eq? (car _2) 'ast_name) (cadr _2)
        ("ERROR")))))
    `(ast_use ,_sr ,name ,_2))
    """;
  sopen_decl := "use" sname = squalified_name ssemi =># "`(ast_use ,_sr ,_2 ,_4)";

  smodule_definition := "module" sdeclname = ? scompound =>#
    """
    `(ast_untyped_module ,_sr ,(caar _2) ,(cadar _2) ,_4)
     """;

  smodule_definition := "open" "module" sdeclname = ? scompound =>#
    """
    `(ast_seq ,_sr (
      (ast_untyped_module ,_sr ,(caar _3) ,(cadar _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(caar _3)()))))
     """;

  smodule_definition := namespace sdeclname = ? scompound =>#
    """
    `(ast_namespace ,(caar _2) ,(cadar _2) ,_4)
     """;

  smodule_definition := "open" namespace sdeclname = ? scompound =>#
    """
    `(ast_seq ,_sr (
      (ast_namespace ,(caar _3) ,(cadar _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(caar _3)()))))
     """;

}

//------------------------------------------
SCHEME """
(for-each addtype '(
  "tiny" "short" "int" "long" "vlong"
  "utiny" "uchar" "ushort" "uint" "ulong" "uvlong"

  "int8" "int16" "int32" "int64"
  "uint8" "uint16" "uint32" "uint64"

  "float" "double" "ldouble"
  "fcomplex" "dcomplex" "lcomplex"

  "char" "uchar"
  "string" "ustring"

  "intmax" "uintmax"
  "size" "address" "offset" "ptrdiff" "byte"
))
""";


syntax csyntax {
  requires statements;

  base_type :=
    | SCHEME "(istype)" =># '`(ast_name ,_sr ,_1 ())'
/*
    | "char" =># '`(ast_name ,_sr "char" ())' note "C character"
    | "uchar" =># '`(ast_name ,_sr "uchar" ())'

    | "tiny" =># '`(ast_name ,_sr "tiny" ())'
    | "short" =># '`(ast_name ,_sr "short" ())'
    | "int" =># '`(ast_name ,_sr "int" ())'
    | "long" =># '`(ast_name ,_sr "long" ())'
    | "vlong" =># '`(ast_name ,_sr "vlong" ())'
    | "utiny" =># '`(ast_name ,_sr "utiny" ())'
    | "uchar" =># '`(ast_name ,_sr "utiny" ())'
    | "ushort" =># '`(ast_name ,_sr "ushort" ())'
    | "uint" =># '`(ast_name ,_sr "uint" ())'
    | "ulong" =># '`(ast_name ,_sr "ulong" ())'
    | "uvlong" =># '`(ast_name ,_sr "uvlong" ())'

    | "int8" =># '`(ast_name ,_sr "int8" ())'
    | "int16" =># '`(ast_name ,_sr "int16" ())'
    | "int32" =># '`(ast_name ,_sr "int32" ())'
    | "int64" =># '`(ast_name ,_sr "int64" ())'
    | "uint8" =># '`(ast_name ,_sr "uint8" ())'
    | "uint16" =># '`(ast_name ,_sr "uint16" ())'
    | "uint32" =># '`(ast_name ,_sr "uint32" ())'
    | "uint64" =># '`(ast_name ,_sr "uint64" ())'

    | "float" =># '`(ast_name ,_sr "float" ())'
    | "double" =># '`(ast_name ,_sr "double" ())'
    | "ldouble" =># '`(ast_name ,_sr "ldouble" ())'

    | "fcomplex" =># '`(ast_name ,_sr "fcomplex" ())'
    | "dcomplex" =># '`(ast_name ,_sr "dcomlex" ())'
    | "lcomplex" =># '`(ast_name ,_sr "lcomplex" ())'

    | "string" =># '`(ast_name ,_sr "string" ())'
    | "ustring" =># '`(ast_name ,_sr "ustring" ())'

    | "intmax" =># '`(ast_name ,_sr "intmax" ())'
    | "uintmax" =># '`(ast_name ,_sr "uintmax" ())'

    | "size" =># '`(ast_name ,_sr "size" ())'
    | "address" =># '`(ast_name ,_sr "address" ())'
    | "offset" =># '`(ast_name ,_sr "offset" ())'
    | "ptrdiff" =># '`(ast_name ,_sr "ptrdiff" ())'
    | "byte" =># '`(ast_name ,_sr "byte" ())'
*/

    | "struct" sname =># "`(ast_name ,_sr ,_2 ())"
    | "union" sname =># "`(ast_name ,_sr ,_2 ())"
    | "class" sname =># "`(ast_name ,_sr ,_2 ())"
    | "enum" sname =># "`(ast_name ,_sr ,_2 ())"
  ;

  pointer_type:=
    | base_type =># "_1"
    | k"void" star =># '`(ast_name ,_sr "address" ())'
    | pointer_type star =># "`(ast_ref ,_1)"
  ;

  c_type :=
    | pointer_type =># "_1"
    | c_type lpar star rpar lpar c_type_list rpar =>#
      "`(ast_longarrow (,_6 ,_1))"           // cfunction
  ;

  c_type_suffix := comma c_type =># "_2";
  c_type_list :=
    | c_type c_type_suffix+ =># "`(ast_tuple,_sr ,(cons _1 _2))"
    | c_type =># "_1"
    | sepsilon =># "`(ast_tuple,_sr ())"
  ;

  declarator :=
    | pointer_type sname =># "`(PVar ,_2 ,_1)"
    | pointer_type "const" sname =># "`(PVal ,_3 ,_1)"
    | c_type lpar sname rpar lpar c_type_list rpar =>#
      "`(PVar ,_3 (ast_longarrow (,_6 ,_1)))"

    | c_type lpar star sname rpar lpar c_type_list rpar =>#
      "`(PVar ,_4 (ast_longarrow (,_7 ,_1)))"

    | c_type sname lpar c_type_list rpar =>#
      "`(PVar ,_2 (ast_longarrow (,_4 ,_1)))"
  ;

  // function parameter
  sparameter := declarator =># "(append _1 `(none))";
  sparameter := declarator = sor_condition =># "(append _1 `((some ,_3)))";

  // initialised variable
  svar_def := declarator = sexpr ssemi =>#
    """
    (let*
      (
        (kind (car _1))
        (name (cadr _1))
        (type (caddr _1))
        (dcl (if (eq? kind 'PVal) 'ast_val_decl 'ast_var_decl))
      )
    `(,dcl ,_sr ,name ,dfltvs (some ,type) (some ,_3)))
    """;

  // uninitialised variable (RISKY)
  svar_def := declarator ssemi =>#
    """
    (let*
      (
        (kind (car _1))
        (name (cadr _1))
        (type (caddr _1))
        (dcl (if (eq? kind 'PVal) 'ast_val_decl 'ast_var_decl))
      )
    `(,dcl ,_sr ,name ,dfltvs (some ,type) none))
    """;


  // function
  sprocedure_definition := sadjectives "void" sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) Function ,_6)
  """;

  // function
  cfun_kind := "extern" =># "'CFunction";
  cfun_kind := "static" =># "'Function";
  cfun_kind := "inline" =># "'Function";
  cfun_kind := "noinline" =># "'Function";

  sfunction_definition := cfun_kind sadjectives pointer_type sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    `(ast_curry ,_sr ,(caar _4) ,(cadar _4) ,_5 (,_3 ,_6) ,_1 ,_7)
  """;

  // union
  stype_sum_item1 := declarator ssemi =># """
    `(,(car _1) none ,dfltvs ,(cadr _1))
  """;

  // struct
  sstruct_mem_decl := declarator ssemi =># """
    ;;(begin (display "\\ndeclarator=")(display _1)
    ;;(display "\\nvariable=")(display (cadr _1))
    ;;(display "\\ntype=")(display (caddr _1))
    `(,(cadr _1) ,(caddr _1))
    ;;)
  """;

  // typedef
  stype_alias := "typedef" declarator ssemi =>#
    """
    `(ast_type_alias ,_sr ,(car _2) ,dfltvs ,(cadr _2))
    """;

  sifgoto := "break" ssemi =># '`(ast_goto ,_sr "break_label")';
  sifgoto := "continue" ssemi =># '`(ast_goto ,_sr "continue_label")';
  sifgoto := "redo" ssemi =># '`(ast_goto ,_sr "redo_label")';

  sifgoto := for lpar statement sexpr ssemi sassignexpr rpar statement =>#
  """
    (let*
      (
        (init _3)
        (cond _4)
        (iter _6)
        (body _8)
      )
    (block ( append `(
      ,init
      (ast_label ,_sr "redo_label" )
      (ast_unlikely_ifnotgoto ,_sr ,cond "break_label")
      ,body
      (ast_label ,_sr "continue_label" )
      ,iter
      (ast_goto ,_sr "redo_label")
      ( ast_label ,_sr "break_label" ))
    )))
  """;

  // note: we use sdollar_apply not sexpr here,
  // otherwise while (fun ()=>x) { } is interpreted
  // as a C while loop, instead of the while HOF in the library

  sifgoto := k"while" lpar x[sdollar_apply_pri] rpar statement =>#
  """
    ( block ( append `(
      ( ast_label ,_sr "continue_label" )
      ( ast_unlikely_ifnotgoto ,_sr ,_3 "break_label" )
      ,_5
      ( ast_goto ,_sr "continue_label" )
      ( ast_label ,_sr "break_label" )
    )))
  """;

  sifgoto := do scompound "until" x[sdollar_apply_pri] ssemi =>#
  """
    ( block ( append `(
      ( ast_label ,_sr "continue_label" )
      ,( block _2)
      ( ast_likely_ifnotgoto ,_sr ,_4 "continue_label" )
      ( ast_label ,_sr "break_label" )
    )))
  """;

  sifgoto := if lpar x[sdollar_apply_pri] rpar statement "else" statement =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" )
      ( ast_macro_name "lab2" "" )
      ( ast_ifnotgoto ,_sr ,_3 "lab1" )
      ,_5
      (ast_goto ,_sr "lab2")
      ( ast_label ,_sr "lab1" )
      ,_7
      ( ast_label ,_sr "lab2" )
    )))
  """;

  // this must be given first ..
  sifgoto := if lpar x[sdollar_apply_pri] rpar statement =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" )
      ( ast_ifnotgoto ,_sr ,_3 "lab1" )
      ,_5
      ( ast_label ,_sr "lab1" )
    )))
  """;

}

//------------------------------------------
syntax felix {
  requires
    statements,
      type_decls,
      variables,
      executable,
      assertions,
      namespaces,
    requirements,
    expressions,
    functions,
    patterns,
    cbind,
    macros,
    csyntax
  ;
}

