// interim menu stuff
// these menus are transient, retaining state only when open


include "std/datatype/lsexpr";

class FlxGuiMenu
{
  // A menu entry is either some text or a separator
  // The text has a visual label and a separate tag 
  // returned when an entry is selected
  union menu_entry_active_t = Active | Disabled;
  typedef menu_text_entry_t = (tag:string, label:string, active:menu_entry_active_t);

  union menu_entry_t = Separator | Text of menu_text_entry_t;

  // A menu is a list of trees with both leaves and nodes labelled
  typedef menu_item_t = LS_expr::lsexpr[menu_entry_t, menu_entry_t];
  typedef menu_data_t = list[menu_item_t];

  // A position in the tree is a list of integers
  // Separators do not count
  typedef menu_position_t = list[int];

  // A menu is either closed, or open at a particular position
  union menu_state_t = Closed | Open of menu_position_t;

  union menu_action_t = NoAction | ChangedPosition | SelectedAction of string;

  interface menu_model_t
  {
    get_menu: 1 -> menu_data_t;
    get_state: 1 -> menu_state_t;
    set_state: menu_state_t -> 0;
    get_current_tag: 1 -> string; // empty string if closed
    get_current_tag_chain: 1 -> list[string]; // from the top
  }

  object MenuModel (m:menu_data_t) implements menu_model_t =
  {
    var state = Closed;
    method fun get_menu () => m;
    method fun get_state () => state;
    method proc set_state (s:menu_state_t) => state = s;
    method fun get_current_tag () => "get current tag NOT IMPLEMENTED";
    method fun get_current_tag_chain () => Empty[string];
  }

  interface menu_display_t 
  {
    display: 1 -> 0;
    get_hotrects: 1 -> list[rect_t * menu_position_t];
  }

  typedef submenu_icon_t = (open_icon: &surface_t, closed_icon: &surface_t);

  object MenuDisplay 
  (
    m:menu_model_t,
    w:window_t,
    x:int,y:int,
    font:font_t,
    text_colour: button_colour_scheme_t,
    disabled_colour: button_colour_scheme_t,
    selected_colour: button_colour_scheme_t,
    submenu_icons: submenu_icon_t
  ) =
  {
    var icon_width = max (submenu_icons.open_icon*.w, submenu_icons.closed_icon*.w);
    var lineskip = get_lineskip font;
    var baseline_offset = font.TTF_FontAscent; 
    var border_width = 2;
    var left_padding = 4;
    var right_padding = 10 + icon_width;
    var min_width = 20;
    var separator_depth = 1;
    var top_padding = 1;
    var bottom_padding = 1;

    fun width (s:string) => (FlxGuiFont::get_textsize (font,s)).0;
    fun width: menu_entry_t -> int =
      | Separator => left_padding + right_padding + min_width
      | Text s => left_padding + right_padding + width s.label
    ;
    fun depth : menu_entry_t -> int = 
      | Separator => top_padding + bottom_padding + separator_depth
      | Text s => top_padding + bottom_padding + lineskip
    ;
    fun width : menu_item_t -> int =
      | Leaf menu_entry => width menu_entry
      | Tree (?menu_entries ,_) => width menu_entries
    ;

    fun depth : menu_item_t -> int =
      | Leaf menu_entry => depth menu_entry
      | Tree (?menu_entry ,_) => depth menu_entry
    ;
    fun width (ls: menu_data_t) => fold_left 
      (fun (w:int) (menu_item:menu_item_t) => max (w, width menu_item)) 
      0 
      ls
    ;
    fun depth (ls: menu_data_t) => fold_left
      (fun (d:int) (menu_item:menu_item_t) => d + depth menu_item)
      0
      ls
    ;
    proc display_menu(x:int, y:int, menu:menu_data_t, position:menu_position_t) 
    {
      var left_x = x;
      var top_y = y;
      var right_x = left_x + width menu;
      var bottom_y = top_y + depth menu;
      var scheme = text_colour;

      // top
      w.draw_line (scheme.top_colour, left_x - 2,top_y - 2,right_x + 2, top_y - 2); 
      w.draw_line (scheme.top_colour, left_x - 1,top_y - 1,right_x + 1, top_y - 1); 
      // left
      w.draw_line (scheme.left_colour, left_x - 2,top_y - 2,left_x - 2, bottom_y + 2); 
      w.draw_line (scheme.left_colour, left_x - 1,top_y - 1,left_x - 1, bottom_y + 1); 
      // right
      w.draw_line (scheme.right_colour, right_x + 2,top_y - 2,right_x + 2, bottom_y + 2); 
      w.draw_line (scheme.right_colour, right_x + 1,top_y - 1,right_x + 1, bottom_y + 1); 
      // bottom
      w.draw_line (scheme.bottom_colour, left_x - 1,bottom_y + 1,right_x + 1, bottom_y + 1); 
      w.draw_line (scheme.bottom_colour, left_x - 2,bottom_y + 2,right_x + 2, bottom_y + 2); 

      w.fill(SDL_Rect (left_x, top_y, right_x - left_x + 1, bottom_y - top_y + 1), scheme.bg_colour);

      var selected = match position with
        | Empty => 0 // ignore for the moment
        | Cons (?h,_) => h
      ;

      var counter = 0;
      var ypos = top_y + top_padding;
      proc show_entry (entry: menu_entry_t) (submenu:menu_data_t) => 
        match entry with
        | Separator => 
          var y = ypos;
          w.draw_line (RGB(0,0,0), left_x, y, right_x, y); 
          ypos = ypos + separator_depth + bottom_padding + top_padding;

        | Text (label=?s,active=?active) =>
          y = ypos + baseline_offset;
          var scheme, dosub = match active with
            | Active => if counter == selected then selected_colour, true else text_colour, false
            | Disabled => disabled_colour, false
          ;
          var client_area = rect_t (
            left_x+border_width,
            ypos+top_padding,
            right_x - left_x - 2 * border_width, 
            lineskip
          );
          w.fill (client_area, scheme.bg_colour);
          w.write (left_x+left_padding, y,font,scheme.label_colour,s);

          match submenu with
          | Empty => ;
          | _ =>
            var icon = if selected == counter then submenu_icons.open_icon else submenu_icons.closed_icon; 
            var dst = rect_t (right_x - icon_width - border_width - 1, ypos, 0,0);
            C_hack::ignore(SDL_BlitSurface (icon, C_hack::null[rect_t], SDL_GetWindowSurface w,&dst));
            if dosub do
              var subpos = match position with 
                | Cons (_,?tail) => tail
                | _ => position // empty
              ;
              display_menu (right_x+border_width,ypos+border_width,submenu,subpos);
            done
          endmatch;
          ypos = ypos + lineskip + bottom_padding+top_padding;
          ++counter;
        endmatch
      ;
      for item in menu do
        match item with
        | Leaf entry => show_entry entry Empty[LS_expr::lsexpr[menu_entry_t, menu_entry_t]];
        | Tree (?entry, ?submenu) => show_entry entry submenu;
        endmatch;
      done
      w.update; 
    }  
    method proc display() {
      val position = match #(m.get_state) with
        | Closed => list (0)
        | Open p => p
      ;
      display_menu (x,y,#(m.get_menu), position);
    }

    proc get_hotrecs(x:int, y:int, menu:menu_data_t, position:menu_position_t) 
      (revtrail: list[int]) 
      (photrecs:&list[rect_t * menu_position_t])=
    {
//println$ "get_hotrecs, revtrail=" + revtrail.str+", pos=" + position.str;
      var left_x = x;
      var top_y = y;
      var right_x = left_x + width menu;
      var bottom_y = top_y + depth menu;

      var selected = match position with
        | Empty => 0 // ignore for the moment
        | Cons (?h,_) => h
      ;

      var counter = 0;
      var ypos = top_y + top_padding;
      proc hotrecs (entry: menu_entry_t) (submenu:menu_data_t) 
      {
        match entry with
        | Separator => 
          ypos = ypos + separator_depth + bottom_padding + top_padding;
//println$ "SEPARATOR : Counter="+counter.str;

        | Text (label=?s,active=?active) =>
          y = ypos + baseline_offset;
          var dosub = match active with
            | Active => counter == selected
            | Disabled => false
          ;
          var client_area = rect_t (
            left_x+border_width,
            ypos+top_padding,
            right_x - left_x - 2 * border_width, 
            lineskip
          );
//println$ "TEXT: Counter="+counter.str+", Rect=" + client_area.str;
          match active with 
          | Active => photrecs <- (client_area, rev (counter + revtrail)) + *photrecs;
          | Disabled => ;
          endmatch;
          match submenu with
          | Empty => ;
          | _ =>
            if dosub do
              var subpos = match position with 
                | Cons (_,?tail) => tail
                | _ => position // empty
              ;
              get_hotrecs (right_x+border_width,ypos+border_width,submenu,subpos) (counter+revtrail) photrecs;
            done
          endmatch;
          ypos = ypos + lineskip + bottom_padding+top_padding;
          ++counter;
        endmatch;
      }
      for item in menu do
        match item with
        | Leaf entry => hotrecs entry Empty[LS_expr::lsexpr[menu_entry_t, menu_entry_t]];
        | Tree (?entry, ?submenu) => hotrecs entry submenu;
        endmatch;
      done
    }  

    method fun get_hotrects() : list[rect_t * menu_position_t] =
    {
      val position = match #(m.get_state) with
        | Closed => list (0)
        | Open p => p
      ;
      var hotrecs = Empty[rect_t * menu_position_t];
      get_hotrecs (x,y,#(m.get_menu),position) Empty[int] &hotrecs;
      return rev hotrecs;
    }

  }

  fun hotpos (point:SDL_Point, hot:list[rect_t * menu_position_t]) : opt[menu_position_t] =>
    match hot with
    | Empty => None[menu_position_t]
    | Cons ((?r,?pos),?tail) =>
      if point \in r then Some pos else hotpos (point, tail)
    endmatch
  ;

  proc menu_controller 
  (
    mm: menu_model_t,
    md: menu_display_t,
    ec: ischannel[event_t],
    response: oschannel[menu_action_t]
  ) ()
  {
    md.display();
    var run = true;
    var e = read ec;
    while run do
      match e.type.SDL_EventType with
      | $(SDL_WINDOWEVENT) =>
        match e.window.event.SDL_WindowEventID with
        | $(SDL_WINDOWEVENT_RESIZED) =>
          md.display();
          write$ response, NoAction;

        | _ => write$ response, NoAction;
        endmatch;

      | $(SDL_MOUSEMOTION) =>
        var hotrecs = md.get_hotrects();
        //List::iter proc (r:rect_t, pos:menu_position_t) { println$ "Rect=" + r.str + ", Pos=" + pos.str; } hotrecs; 
        
        var x,y = e.motion.x,e.motion.y; //int32
        match hotpos ( SDL_Point (x.int,y.int), hotrecs) with
        | None =>
          write$ response, NoAction;
        | Some pos =>
          println$ "Position " + pos.str;
          match #(mm.get_state) with
          | Closed =>
            write$ response, ChangedPosition;
          | Open oldpos =>
            if oldpos == pos do
              write$ response, NoAction;
            else
              mm.set_state (Open pos);
              write$ response, ChangedPosition;
            done
          endmatch;
        endmatch;
/*
          //println$ "Motion in client rect of button " + bd.get_label();
          match bm.get_state () with
          | Up => bm.set_state Mouseover; bd.display(); // Enter
          | _ => ;
          endmatch;
        else
          match bm.get_state () with
          | Mouseover => bm.set_state Up; bd.display(); // Leave
          | Down => bm.set_state Up; bd.display(); // Leave
          | _ => ;
          endmatch;
        done
*/
   
      | $(SDL_MOUSEBUTTONDOWN) => 
/*
        x,y = e.button.x,e.button.y; //int32
        if SDL_Point (x.int,y.int) \in bd.get_client_rect () do
          //println$ "Button down in client rect of button " + bd.get_label();
          bm.set_state Down; bd.display();
        done
*/
        write$ response, NoAction;
/*
   
      | $(SDL_MOUSEBUTTONUP) => 
        x,y = e.button.x,e.button.y; //int32
        if SDL_Point (x.int,y.int) \in bd.get_client_rect () do
          //println$ "Button up in client rect of button " + bd.get_label();
          bm.set_state Mouseover; bd.display();
          write$ response, ClickAction #(bm.get_tag);
        else
          bm.set_state Up; bd.display();
          write$ response, NoAction;
        done
*/
      | $(SDL_WINDOWEVENT) when e.window.event == SDL_WINDOWEVENT_LEAVE.uint8  =>
/*
        bm.set_state Up; bd.display();
*/
        write$ response, NoAction;

      | _ => 
        write$ response, NoAction;
      endmatch;
      e = read ec;
    done

  }

}

