// interim menu stuff
// these menus are transient, retaining state only when open


include "std/datatype/lsexpr";
class FlxGuiMenu
{
  // A menu entry is either some text or a separator
  // The text has a visual label and a separate tag 
  // returned when an entry is selected
  union menu_entry_active_t = Active | Disabled;
  typedef menu_text_entry_t = (tag:string, label:string, active:menu_entry_active_t);

  union menu_entry_t = Separator | Text of menu_text_entry_t;

  // A menu is a list of trees with both leaves and nodes labelled
  typedef menu_item_t = LS_expr::lsexpr[menu_entry_t, menu_entry_t];
  typedef menu_data_t = list[menu_item_t];

  // A position in the tree is a list of integers
  // Separators do not count
  typedef menu_position_t = list[int];

  // A menu is either closed, or open at a particular position
  union menu_state_t = Closed | Open of menu_position_t;

  union menu_action_t = NoAction | SelectedAction of string;

  interface menu_model_t
  {
    get_menu: 1 -> menu_data_t;
    get_state: 1 -> menu_state_t;
    set_state: menu_state_t -> 0;
    get_current_tag: 1 -> string; // empty string if closed
    get_current_tag_chain: 1 -> list[string]; // from the top
  }

  object MenuModel (m:menu_data_t) implements menu_model_t =
  {
    var state = Closed;
    method fun get_menu () => m;
    method fun get_state () => state;
    method proc set_state (s:menu_state_t) => state = s;
    method fun get_current_tag () => "get current tag NOT IMPLEMENTED";
    method fun get_current_tag_chain () => Empty[string];
  }

  interface menu_display_t 
  {
    display: 1 -> 0;
  }

  typedef submenu_icon_t = (open_icon: &surface_t, closed_icon: &surface_t);

  object MenuDisplay 
  (
    m:menu_model_t,
    w:window_t,
    x:int,y:int,
    font:font_t,
    text_colour: button_colour_scheme_t,
    disabled_colour: button_colour_scheme_t,
    selected_colour: button_colour_scheme_t,
    submenu_icons: submenu_icon_t
  ) =
  {
    var icon_width = max (submenu_icons.open_icon*.w, submenu_icons.closed_icon*.w);
    var lineskip = get_lineskip font;
    var baseline_offset = font.TTF_FontAscent; 
    var border_width = 2;
    var left_padding = 4;
    var right_padding = 10 + icon_width;
    var min_width = 20;
    var separator_depth = 1;
    var top_padding = 1;
    var bottom_padding = 1;

    fun width (s:string) => (FlxGuiFont::get_textsize (font,s)).0;
    fun width: menu_entry_t -> int =
      | Separator => left_padding + right_padding + min_width
      | Text s => left_padding + right_padding + width s.label
    ;
    fun depth : menu_entry_t -> int = 
      | Separator => top_padding + bottom_padding + separator_depth
      | Text s => top_padding + bottom_padding + lineskip
    ;
    fun width : menu_item_t -> int =
      | Leaf menu_entry => width menu_entry
      | Tree (?menu_entries ,_) => width menu_entries
    ;

    fun depth : menu_item_t -> int =
      | Leaf menu_entry => depth menu_entry
      | Tree (?menu_entry ,_) => depth menu_entry
    ;
    fun width (ls: menu_data_t) => fold_left 
      (fun (w:int) (menu_item:menu_item_t) => max (w, width menu_item)) 
      0 
      ls
    ;
    fun depth (ls: menu_data_t) => fold_left
      (fun (d:int) (menu_item:menu_item_t) => d + depth menu_item)
      0
      ls
    ;
    proc display_menu(x:int, y:int, menu:menu_data_t) 
    {
      var left_x = x;
      var top_y = y;
      var right_x = left_x + width menu;
      var bottom_y = top_y + depth menu;
      var scheme = text_colour;

      // top
      w.draw_line (scheme.top_colour, left_x - 2,top_y - 2,right_x + 2, top_y - 2); 
      w.draw_line (scheme.top_colour, left_x - 1,top_y - 1,right_x + 1, top_y - 1); 
      // left
      w.draw_line (scheme.left_colour, left_x - 2,top_y - 2,left_x - 2, bottom_y + 2); 
      w.draw_line (scheme.left_colour, left_x - 1,top_y - 1,left_x - 1, bottom_y + 1); 
      // right
      w.draw_line (scheme.right_colour, right_x + 2,top_y - 2,right_x + 2, bottom_y + 2); 
      w.draw_line (scheme.right_colour, right_x + 1,top_y - 1,right_x + 1, bottom_y + 1); 
      // bottom
      w.draw_line (scheme.bottom_colour, left_x - 1,bottom_y + 1,right_x + 1, bottom_y + 1); 
      w.draw_line (scheme.bottom_colour, left_x - 2,bottom_y + 2,right_x + 2, bottom_y + 2); 

      w.fill(SDL_Rect (left_x, top_y, right_x - left_x + 1, bottom_y - top_y + 1), scheme.bg_colour);

      var selected = match #(m.get_state) with
        | Closed => 0 // ignore for the moment
        | Open (Empty) => 0 // ignore for the moment
        | Open (Cons (?h,_)) => h
      ;

      var counter = 0;
      var ypos = top_y + top_padding;
      proc show_entry (entry: menu_entry_t) (submenu:menu_data_t) => 
        match entry with
        | Separator => 
          var y = ypos;
          w.draw_line (RGB(0,0,0), left_x, y, right_x, y); 
          ypos = ypos + separator_depth + bottom_padding + top_padding;

        | Text (label=?s,active=?active) =>
          y = ypos + baseline_offset;
          var scheme = match active with
            | Active => if counter == selected then selected_colour else text_colour 
            | Disabled => disabled_colour
          ;
          var client_area = rect_t (
            left_x+border_width,
            ypos+top_padding,
            right_x - left_x - 2 * border_width, 
            lineskip
          );
          w.fill (client_area, scheme.bg_colour);
          w.write (left_x+left_padding, y,font,scheme.label_colour,s);

          match submenu with
          | Empty => ;
          | _ =>
            var icon = if selected == counter then submenu_icons.open_icon else submenu_icons.closed_icon; 
            var dst = rect_t (right_x - icon_width - border_width - 1, ypos, 0,0);
            C_hack::ignore(SDL_BlitSurface (icon, C_hack::null[rect_t], SDL_GetWindowSurface w,&dst));
          endmatch;
          ypos = ypos + lineskip + bottom_padding+top_padding;
          ++counter;
        endmatch
      ;
      for item in menu do
        match item with
        | Leaf entry => show_entry entry Empty[lsexpr[menu_entry_t, menu_entry_t]];
        | Tree (?entry, ?submenu) => show_entry entry submenu;
        endmatch;
      done
      w.update; 
    }  
    method proc display() => display_menu (x,y,#(m.get_menu));
  }


  object MenuController (mm:menu_model_t, md:menu_display_t) = 
  {
  }
}

