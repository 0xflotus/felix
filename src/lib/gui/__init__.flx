include "sdl/SDL2";
include "sdl/SDL_ttf";
include "sdl/SDL_image";

class FlxGui 
{

proc init()
{
  if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0  do
    eprintln$ f"Unable to init SDL: %S\n" #SDL_GetError;
    System::exit(1);
  done
  println$ "SDL_init OK";
  if TTF_Init() < 0 do 
    eprintln$ f"Unable to init TTF: %S\n" #TTF_GetError;
    System::exit(1);
  done
  println$ "TTF_init OK";
  if IMG_Init(IMG_INIT_PNG) < 0 do 
    eprintln$ f"Unable to init IMG with PNG: %S\n" #IMG_GetError;
    System::exit(1);
  done
  println$ "IMG_init OK";
}

proc versions ()
{
  begin
    var compiled = #SDL_Compiled_Version;
    var linked = #SDL_Linked_Version;
    println$ f"We compiled against SDL version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against SDL version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #TTF_Compiled_Version;
    var linked = #TTF_Linked_Version;
    println$ f"We compiled against TTF version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against TTF version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #IMG_Compiled_Version;
    var linked = #IMG_Linked_Version;
    println$ f"We compiled against IMG version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against IMG version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

} 

fun OSX_dflt_font() => "/Library/Fonts/Courier New.ttf";  

gen get_font (font_file:string, ptsize:int) = {
  var font = TTF_OpenFont (font_file,ptsize);
  if not (TTF_ValidFont font) do
    eprintln$ f"Unable to open TTF font %S\n" font_file;
    System::exit 1;
  done
  TTF_SetFontKerning (font,0);
  var isfixed = TTF_FontFaceIsFixedWidth (font);
  println$ "Opened Font " + font_file + 
    " Facename: " + TTF_FontFaceFamilyName font + 
    (if isfixed>0 then " MONOSPACED" else " VARIABLE WIDTH");
  TTF_SetFontHinting (font,TTF_HINTING_MONO); // guess...
  return font;
}

typedef window_t = SDL_Window;
typedef font_t = TTF_Font;
typedef drawing_surface_t = SDL_Surface;
typedef colour_t = SDL_Color;
typedef color_t = colour_t; // dang yanks ..
typedef point_t = SDL_Point;
typedef rect_t = SDL_Rect;
typedef surface_t = SDL_Surface;
typedef event_t = SDL_Event;

fun RGB (r:int, g:int, b:int) => 
  SDL_Color (r.uint8, g.uint8, b.uint8, 255u8)
;

// create some colours and clear the window
var white = RGB (255,255,255);
var black = RGB (0,0,0);
var lightgrey = RGB (180,180,180);
var darkgrey = RGB (60,60,60);
var red = RGB(255,0,0);
var green = RGB (0,255,0);
var blue = RGB (0,0,255);
var purple = RGB (255,0,255);
var yellow = RGB (255,255,0);
var orange = RGB (100,255,100);

 
ctor window_t  (title:string, xpos:int, ypos:int, width:int,height:int) =
{
  var window = SDL_CreateWindow(
    title,
    xpos,ypos,
    width, height,
    SDL_WINDOW_SHOWN \| SDL_WINDOW_RESIZABLE
  );
  return window;
}

proc destroy (w:window_t) { SDL_DestroyWindow w; }

fun get_lineskip (f: font_t) => TTF_FontLineSkip(font) + 1;

fun get_textsize (f: font_t, s:string) = 
{
  var w: int; var h: int;
  C_hack::ignore$ TTF_SizeText (f,s,&w, &h);
  return w,h;
}

// x,y is the origin  of the first character
// The bounding box is 2 pixels up from the highest char
// 2 pixies down from the lowest char
// 2 pixies to the left of the first character's orgin
// and 2 pix right from the origin of the last char + the notional advance
// this ONLY works right for a monospaced font!
fun bounding_box (f:font_t, x:int, y:int, s:string) : rect_t =
{
  var n = s.len.int;
  var w = 
    #{ 
      var minx:int; var maxx:int; var miny:int; var maxy:int; var advance:int;
      C_hack::ignore$ TTF_GlyphMetrics(f,"m".char.ord.uint16,&minx, &maxx, &miny, &maxy, &advance);
      return advance;
    }
  ;
  var a = f.TTF_FontAscent;
  var d = f.TTF_FontDescent;
  return SDL_Rect (x - 2,y - a - 2, w * n +4, a - d + 4);
}


// x,y is the origin position of the the first char
// the first pixels may actually be to the left of this!
proc write(w:window_t) (x:int, y:int, font:font_t, c: colour_t, s:string)
{
    var rendered = TTF_RenderText_Solid (font,s,c);
    var rect : SDL_Rect;

    var minx:int; var maxx:int; var miny:int; var maxy:int; var advance:int;
    C_hack::ignore$ TTF_GlyphMetrics(font,"m".char.ord.uint16,&minx, &maxx, &miny, &maxy, &advance);
    
    rect.x = x + minx;
    rect.y = y - maxy;
    var nullRect = C_hack::null[SDL_Rect];
    var window_surface = SDL_GetWindowSurface w;

    var result = SDL_BlitSurface (rendered, nullRect, window_surface, &rect); 
    if result != 0 do
      eprintln$ "Unable to blit text to window surface";
      System::exit 1;
    done
    SDL_FreeSurface rendered;
}

// clear whole window
proc clear(w:window_t) (c: colour_t)
{
  var surf = SDL_GetWindowSurface w;
  var pixelformat : &SDL_PixelFormat  = surf*.format;
  var bgpixels = SDL_MapRGB(pixelformat,c.r,c.g,c.b);
  SDL_ClearClipRect (surf);
  C_hack::ignore$ SDL_FillSurface (surf, bgpixels);
}

proc fill (w:window_t) (var r:rect_t, c:colour_t)
{
  var surf = SDL_GetWindowSurface w;
  var pixelformat : &SDL_PixelFormat  = surf*.format;
  var bgpixels = SDL_MapRGB(pixelformat,c.r,c.g,c.b);
  C_hack::ignore$ SDL_SetClipRect (surf, &r);
  C_hack::ignore$ SDL_FillSurface (surf, bgpixels);
  SDL_ClearClipRect (surf);
}

proc draw_line (w:window_t)  (c:color_t, x0:int, y0:int, x1:int, y1:int)
{
   var s: &SDL_Surface = SDL_GetWindowSurface w;
   var r: SDL_Renderer = SDL_CreateSoftwareRenderer s;
   C_hack::ignore$ SDL_SetRenderDrawColor (r, c.r, c.g, c.b, c.a);
   C_hack::ignore$ SDL_RenderDrawLine (r, x0, y0, x1, y1);
   SDL_DestroyRenderer r;
}

proc update(w:window_t)
{
  var result = SDL_UpdateWindowSurface w;
  if result != 0 do
    eprintln$ "Unable to update window";
    System::exit 1;
  done
}

interface line_buffer_interface 
{
  get: 1 -> string;
  get_pos: 1 -> int;

  // movement
  mv_left : 1 -> 0;
  mv_right : 1 -> 0;
  mv_start : 1 -> 0;
  mv_end : 1 -> 0;

  // insert and overwrite
  ins: char -> 0;
  ovr: char -> 0;

  // delete
  del_left: 1 -> 0;
  del_right: 1 -> 0;
  clear : 1 ->0;
  clear_right : 1 -> 0;
  clear_left : 1 -> 0;
}

proc display_line_buffer 
(
  w:window_t, f:font_t, c:colour_t, bg:colour_t,
  x: int, y:int, b:line_buffer_interface
) 
()
{
  var nullRect = C_hack::null[SDL_Rect];
  var s = #(b.get);
println$ "Edit box = '" + s + "'";
  var text_rendered = TTF_RenderText_Solid(f,s,c);
  var window_surface: &SDL_Surface = SDL_GetWindowSurface w;
  var bbox = bounding_box (f,x,y,s);
  w.fill (bbox,bg);
  var viewport: SDL_Rect;
  var minx:int; var maxx:int; var miny:int; var maxy:int; var advance:int;
  C_hack::ignore$ TTF_GlyphMetrics(f,"m".char.ord.uint16,&minx, &maxx, &miny, &maxy, &advance);
    
  viewport.x = x + minx + 2; 
  viewport.y = y - maxy - 2;
  C_hack::ignore$ SDL_BlitSurface (text_rendered, nullRect, window_surface, &viewport); 
  SDL_FreeSurface text_rendered;
  var charwidth = 
    #{ 
      var minx:int; var maxx:int; var miny:int; var maxy:int; var advance:int;
      C_hack::ignore$ TTF_GlyphMetrics(f,"m".char.ord.uint16,&minx, &maxx, &miny, &maxy, &advance);
      return advance;
    }
  ;
  var curpos = x + charwidth * #(b.get_pos);
  w.draw_line(red,curpos,viewport.y - 1,curpos,viewport.y + viewport.h - 2);
  w.update;
} 

object line_buffer (n:int, var b:string) =
{
  b = substring (b+ ' ' *n,0,n); //clip and pad to n chars
  assert b.len.int == n;

  // caret position: can range between 0 and n inclusive!
  // its the position *between* two characters!!
  var pos = 0; 
  method fun get() => b;
  method fun get_pos () => pos;

  // movement
  method proc mv_left () => pos = max (0,pos - 1);
  method proc mv_right () => pos = min (n, pos + 1);
  method proc mv_start () => pos = 0;
  method proc mv_end () => pos = n;

  // insert and move right
  method proc ins (ch:char) 
  {
    b = substring (b, 0, pos) + ch + substring (b, pos, n);
    pos = min (pos + 1, n);
    assert b.len.int == n;
  }
  // overwrite and move right
  method proc ovr (ch:char) 
  {
    if pos < n do
      b = substring (b, 0, pos) + ch + substring (b, pos+1, n);
      pos = min (pos + 1, n);
    done
    assert b.len.int == n;
  }
  // delete to the left
  method proc del_left ()
  {
    if pos > 0 do
      b = substring (b, 0, pos - 1) + substring (b, pos, n) + ' ';
      pos = max (0, pos - 1);
    done
    assert b.len.int == n;
  }
  // delete to the right
  method proc del_right ()
  {
    if pos < n do
      b = substring (b, 0, pos) + substring (b, pos + 1, n) + ' ';
    done
    assert b.len.int == n;
  }
  // clear all
  method proc clear () 
  {
    b = ' ' *n; 
    pos = 0;
    assert b.len.int == n;
  }
  method proc clear_right ()
  {
    b = substring (b, 0, pos) + ' ' * (n - pos);
    assert b.len.int == n;
  }
  method proc clear_left ()
  {
    b = substring (b, pos, n) + ' ' * pos;
    pos = 0;
    assert b.len.int == n;
  }
}

proc line_edit (b:line_buffer_interface) (display:1->0) (ec:ischannel[event_t]) ()
{
  println$ "Line buffer running";
  display();
  var run = true;
  var e : event_t = read ec;
  while run do
    match e.type.SDL_EventType with
    | $(SDL_KEYDOWN) =>
      var vkey = e.key.keysym.sym;
      match vkey with
      | $(SDLK_LEFT) => b.mv_left (); display();
      | $(SDLK_RIGHT) => b.mv_right (); display();
      | $(SDLK_HOME) => b.mv_start (); display();
      | $(SDLK_END) => b.mv_end (); display();
      | $(SDLK_DELETE) => b.del_right(); display();
      | $(SDLK_BACKSPACE) => b.del_left(); display();
      | $(SDLK_RETURN) => b.mv_start(); display();
      | $(SDLK_TAB) => b.mv_start(); display();
      | _ => ;
      endmatch;
    | $(SDL_TEXTINPUT) =>
      var text_buffer : +char = e.text.text;
      var ch = text_buffer . 0;
      b.ovr ch; 
      display();

    // NOTE: not an actual SDL_QUIT!
    // We just need something to terminate.
    // Should be sent on window close actually.
    | $(SDL_QUIT) =>  
      run = false;
    | _ => ;
    endmatch;
    e = read ec;
  done
}


// ------------------------------------------------------------------
// Window controller is responsible for all the work
// being done on a window. It requires support for
// dispatching events on its event channel.
interface window_controller_interface {
  get_window_id : 1 -> uint32;
  get_oschannel : 1 -> oschannel[event_t];
  destroy_window : 1 -> 0;
}

object window_controller 
(
  w:window_t, 
  p:ischannel[event_t] -> 1->0
) 
  implements window_controller_interface = 
{
  var imsgs,omsgs = #mk_ioschannel_pair[event_t]; 
  
  method fun get_window_id () => SDL_GetWindowID w;
  method proc destroy_window () => SDL_DestroyWindow w;
  method fun get_oschannel () => omsgs;
  spawn_fthread (p imsgs);
}
 
// Window Manager is responsible for a set of windows,
// and dispatching events specific to a particular
// window to that window.

// ------------------------------------------------------------------
object window_manager () = 
{
  var windows = darray[window_controller_interface]();

  method fun get_n_windows () => windows.len.int;

  // add a new window to the controlled set
  // return its current index
  method gen add_window (w:window_controller_interface) : int = 
  { 
    windows += w; 
    return windows.len.int - 1; 
  }

  fun find_window(wid: uint32) : opt[window_controller_interface] =
  {
    for wobj in windows do
      if wid == #(wobj.get_window_id) return Some wobj;
    done
    return None[window_controller_interface];
  }

  fun find_window_index (wid: uint32) : opt[int] =
  {
    for var i in 0 upto windows.len.int - 1 do
      if wid == #(windows.i.get_window_id) return Some i;
    done
    return None[int];
  }

  method fun get_window_controller_from_index (i:int) => windows.i;

  method proc delete_window (wid: uint32)
  {
    match find_window_index wid with
    | None => ;
    | Some ?i => 
      println$ "delete window found index " + i.str;
      windows.i.destroy_window; 
      println$ "SDL destroyed";
      erase (windows, i);
      println$ "Window erased";
    endmatch;
  }

  // this is a global source for all events
  gen create_event_source () : ischannel[event_t]  =
  {
    var imsgs,omsgs = #mk_ioschannel_pair[SDL_Event]; 
    proc driver ()
    {
      var e : SDL_Event;
      // dummy first event
      e.type = SDL_FIRSTEVENT.uint32;
      write$ omsgs,e;
      SDL_PumpEvents;
      C_hack::ignore$ SDL_WaitEvent$ &e;
      while e.type.SDL_EventType != SDL_QUIT do
        write$ omsgs, e;
        SDL_PumpEvents;
        C_hack::ignore$ SDL_WaitEvent$ &e;
      done
      println$ "SDL_QUIT seen!";
      write$ omsgs, e;
      return;
    }
    spawn_fthread driver;
    return imsgs;
  }

  var imsgs = create_event_source ();
  method fun get_event_source () => imsgs;
  method proc dispatch_window_event (e:event_t) 
  {
    match SDL_GetWindowID e with
    | Some ?wid =>
      match find_window wid with
      | Some ?wobj =>
        var omsgs = #(wobj.get_oschannel);
        write (omsgs, e);
        if e.type.SDL_EventType == SDL_WINDOWEVENT and 
          e.window.event.SDL_WindowEventID == SDL_WINDOWEVENT_CLOSE 
        do
          #(wobj.get_window_id).delete_window;
          println$ "dispatch: window deleted!";
        done
        | None => println$ "Can't find window ID = " + str wid;
        endmatch;
      | None => println$ "No window for message: Event type " + e.type.SDL_EventType.str;
      endmatch;
  }

  method proc delete_all() 
  {
    println$ "Delete all";
    var e : SDL_Event;
    e.type = SDL_WINDOWEVENT.uint32;
    e.window.event = SDL_WINDOWEVENT_CLOSE.uint8;
    for wobj in windows do 
      var omsgs = #(wobj.get_oschannel);
      e.window.windowID = #(wobj.get_window_id);
      //write (omsgs, e);
    done
    // note: not bothering to delete the darray :)
  }
}

 
} // class FlxGui

