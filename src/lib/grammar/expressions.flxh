syntax expressions {
  /* Experimentally, start coding up for priority management */
  priority 
    let_pri < 
    slambda_pri <
    sdollar_apply_pri < 
    stuple_pri <
    sor_condition_pri <
    sand_condition_pri <
    snot_condition_pri <
    scomparison_pri <
    sas_expr_pri <
    ssetunion_pri <
    ssetintersection_pri <
    sarrow_pri <
    scase_literal_pri <
    sbor_pri <
    sbxor_pri <
    sband_pri <
    sshift_pri <
    ssum_pri <
    ssubtraction_pri <
    sproduct_pri <
    s_term_pri <
    sprefixed_pri <
    spower_pri <
    ssuperscript_pri <
    srefr_pri <
    sapplication_pri <
    scoercion_pri <
    sfactor_pri 
  ;

  sexpr := x[let_pri] =># "_1";
  stypeexpr:= x[sor_condition_pri] =># "_1";

  // let binding
  x[let_pri] := "let" spattern "=" x[let_pri] "in" x[let_pri] =># "`(ast_letin ,_sr (,_2 ,_4 ,_6))";
  x[let_pri] := sconditional =># '_1';
  x[let_pri] := pattern_match =># '_1';


  // alternate conditional
  x[sdollar_apply_pri] := x[stuple_pri] "unless" x[let_pri] "then" x[sdollar_apply_pri] =>#
    "`(ast_cond ,_sr ((ast_apply ,_sr (lnot ,_3)) ,_1 ,_5))";

  // low precedence right associative application
  x[sdollar_apply_pri] := x[stuple_pri] "$" x[sdollar_apply_pri] =># "`(ast_apply ,_sr (,_1 ,_3))";

  // tuple formation
  x[stuple_pri] := x[>stuple_pri] ( "," x[>stuple_pri])+ =># "(chain 'ast_tuple _1 _2)";

  // logic
  x[sor_condition_pri] := x[>sor_condition_pri] ( "or" x[>sor_condition_pri])+ =># "(chain 'ast_orlist _1 _2)" note "lor";
  x[sand_condition_pri] := x[>sand_condition_pri] ( "and" x[>sand_condition_pri])+ =># "(chain 'ast_andlist _1 _2)" note "land";
  x[snot_condition_pri] := "not" x[snot_condition_pri]  =># "(prefix 'lnot)";

  // comparisons
  x[scomparison_pri]:= x[>scomparison_pri] "<" x[>scomparison_pri] =># "(infix 'lt)";
  x[scomparison_pri]:= x[>scomparison_pri] "<=" x[>scomparison_pri] =># "(infix 'le)";
  x[scomparison_pri]:= x[>scomparison_pri] "==" x[>scomparison_pri] =># "(infix 'eq)";
  x[scomparison_pri]:= x[>scomparison_pri] "!=" x[>scomparison_pri] =># "(infix 'ne)";
  x[scomparison_pri]:= x[>scomparison_pri] ">=" x[>scomparison_pri] =># "(infix 'ge)";
  x[scomparison_pri]:= x[>scomparison_pri] ">" x[>scomparison_pri] =># "(infix 'gt)";
  x[scomparison_pri]:= x[>scomparison_pri] "in" x[>scomparison_pri] =># "(infix 'mem)";
  x[scomparison_pri]:= x[>scomparison_pri] "\in" x[>scomparison_pri] =># "(infix 'mem)";

  // named temporary
  x[sas_expr_pri] := x[sas_expr_pri] "as" sname =># "`(ast_as ,_sr (,_1 ,_3))";

  // set ops 
  x[ssetunion_pri] := x[>ssetunion_pri] ( "||" x[>ssetunion_pri])+ =># "(chain 'ast_setunion _1 _2)" note "setunion";
  x[ssetunion_pri] := x[>ssetunion_pri] ( "\\cup" x[>ssetunion_pri])+ =># "(chain 'ast_setunion _1 _2)" note "setunion";
  x[ssetintersection_pri] := x[>ssetintersection_pri] ("\\cap" x[>ssetintersection_pri])+ =># "(chain 'ast_setintersection _1 _2)" note "setintersection";

  // right arrows (no semantics)
  x[sarrow_pri] := x[scase_literal_pri] "->" x[sarrow_pri] =># "`(ast_arrow (,_1 ,_3))";
  x[sarrow_pri] := x[scase_literal_pri] "-->" x[sarrow_pri] =># "`(ast_longarrow (,_1 ,_3))";

  // case literals
  x[scase_literal_pri] := "case" sinteger =># "`(ast_case_tag ,_sr ,_2))";
  x[scase_literal_pri] := "case" sinteger "of" x[ssum_pri] =># "`(ast_typed_case ,_2 ,_4)";
  x[scase_literal_pri] := "case" sname "of" x[ssum_pri] =># "`(ast_variant (,_2 ,_4))";

  // bitwise operators
  x[sbor_pri] := x[sbor_pri] "\\|" x[>sbor_pri] =># "(infix 'bor)";
  x[sbxor_pri] := x[sbxor_pri] "\\^" x[>sbxor_pri] =># "(infix 'bxor)";
  x[sband_pri] := x[sband_pri] "\\&" x[>sband_pri] =># "(infix 'band)";
  x[sshift_pri] := x[sshift_pri] "<<" x[>sshift_pri] =># "(infix 'shl)";
  x[sshift_pri] := x[sshift_pri] ">>" x[>sshift_pri] =># "(infix 'shr)";

  // addition
  x[ssum_pri] := x[>ssum_pri] ("+" x[>ssum_pri])+ =># "(chain 'ast_sum _1 _2)" note "add";

  // subtraction
  x[ssubtraction_pri] := x[ssubtraction_pri] "-" x[sproduct_pri] =># "(infix 'sub)";

  
  // multiplication
  x[sproduct_pri] := x[>sproduct_pri] ("*" x[>sproduct_pri])+ =># "(chain 'ast_product _1 _2)" note "mul";

  // division
  x[s_term_pri] := x[s_term_pri] "/" x[>s_term_pri] =># "(infix 'div)";
  x[s_term_pri] := x[s_term_pri] "%" x[>s_term_pri] =># "(infix 'mod)";

  // prefixes
  x[sprefixed_pri] := "!" x[spower_pri] =># "(prefix 'excl)";
  x[sprefixed_pri] := "+" x[spower_pri] =># "(prefix 'pos)";
  x[sprefixed_pri] := "-" x[spower_pri] =># "(prefix 'neg)";
  x[sprefixed_pri] := "~" x[spower_pri] =># "(prefix 'bnot)";

  // superscripts
  x[spower_pri] := x[ssuperscript_pri] "**" x[sprefixed_pri] =># "(infix 'pow)";
  x[ssuperscript_pri] := x[ssuperscript_pri] "^" x[srefr_pri] =># "`(ast_superscript (,_1 ,_3))";

  // more prefixes
  x[srefr_pri] := "&" x[srefr_pri] =># "`(ast_ref ,_sr ,_2)";
  x[srefr_pri] := "*" x[srefr_pri] =># "(prefix 'deref)";
  x[srefr_pri] := "_deref" x[srefr_pri] =># "`(ast_deref ,_sr ,_2)";
  x[srefr_pri] := "new" x[srefr_pri] =># "`(ast_new ,_sr ,_2)";
  x[srefr_pri] := anon_value =># "_1";

  // record type
  anon_value := "(" srecord_mem_decl ("," srecord_mem_decl)*  ")" =># 
   "`(ast_record_type ,(cons _2 (map second _3)))";
    srecord_mem_decl := sname ":" stypeexpr =># "`(,_1 ,_3)";

  // variant type
  anon_value := "union" "{" stype_sum_item0* "}" =># "`(ast_variant_type ,_3)";
    stype_sum_item := sname sopt_value stvarlist "of" sexpr =># "`(,_1 ,_2 ,_3 ,_5)";
    stype_sum_item := sname sopt_value stvarlist =># "`(,_1 ,_2 ,_3 (ast_void ,_sr))";

    stype_sum_item0 := sname "of" sexpr =># "`(,_1 none ,_3)";
    stype_sum_item0 := sname =># "`(,_1 none (ast_void ,_sr))";

    stype_sum_item1 := stype_sum_item ";" =># "_1";

    stype_sum_item2 := "|" stype_sum_item =># "_2";
    stype_sum_items2 := stype_sum_item stype_sum_item2* =># "(cons _1 _2)";
    stype_sum_items2 := stype_sum_item2* =># "_1";

  // application
  x[sapplication_pri] := x[sapplication_pri] x[scoercion_pri] =># "`(ast_apply ,_sr (,_1 ,_2))" note "apply";

  // variant index
  x[sapplication_pri] := "caseno" x[scoercion_pri] =># "`(ast_case_index ,_sr ,_2)";

  // optimisation hint
  x[sapplication_pri] := "likely" x[scoercion_pri] =># "`(ast_likely ,_sr ,_2)";
  x[sapplication_pri] := "unlikely" x[scoercion_pri] =># "`(ast_unlikely ,_sr ,_2)";

  // suffixed coercion
  // mainly required in patterns? Can be used for type checking?
  x[scoercion_pri] := x[scoercion_pri] ":>>" x[sfactor_pri] =># "`(ast_coercion ,_sr (,_1 ,_3))";
  x[scoercion_pri] := ssuffixed_name =># "_1";

  x[sfactor_pri] := sthe_name =># "_1";

  // indexes and slices
  x[sfactor_pri] := x[sfactor_pri] "." "[" sexpr "]" =># "`(ast_apply ,_sr (,(noi 'subscript) (,_1 ,_4)))";
  x[sfactor_pri] := x[sfactor_pri] "." "[" sexpr "to" sexpr "]" =># "`(ast_apply ,_sr (,(noi 'substring) (,_1 ,_4 ,_6)))";
  x[sfactor_pri] := x[sfactor_pri] "." "[" sexpr "to" "]" =># "`(ast_apply ,_sr (,(noi 'copyfrom) (,_1 ,_4)))";
  x[sfactor_pri] := x[sfactor_pri] "." "[" "to" sexpr "]" =># "`(ast_apply ,_sr (,(noi 'copyto) (,_1 ,_5)))";
  x[sfactor_pri] := x[sfactor_pri] "." sthe_name =># "`(ast_dot ,_sr (,_1 ,_3))";
  x[sfactor_pri] := x[sfactor_pri] "*." sthe_name =># "`(ast_dot ,_sr ((ast_deref ,_sr ,_1) ,_3))";

  // these are weirdos
  sbasic_name_comma_list:= sname ("," sname)* =># "(cons _1 (map second _2))";
  squalified_name_comma_list:= squalified_name ("," squalified_name)* =># "(cons _1 (map second _2))";

  sthe_name :=
    | "#" sthe_name =># "`(ast_apply ,_sr (,_2 (ast_tuple ,_sr ())))"

    // macro expansion freezer
    | "noexpand" squalified_name =># "`(ast_noexpand ,_sr ,_2)"

    // pattern variable
    | "?" sname =># "`(ast_patvar ,_sr ,_2)"
    | squalified_name =># "_1"
  ;
  sthe_name := satom =># "_1";

  // qualified name
  squalified_name := squalified_name "::" ssimple_name_parts =>#
    "`(ast_lookup (,_1 ,(first _3) ,(second _3)))";
  squalified_name := ssimple_name_parts =>#
    "`(ast_name ,_sr ,(first _1) ,(second _1))";
  ssimple_name_parts := sname =># "`(,_1 ())";
  ssimple_name_parts := sname "[" sexpr "]" =># "`(,_1 ,(mkl _3))";

  // suffixed name (to name functions)
  ssuffixed_name := squalified_name "of" x[sfactor_pri] =>#
    "`(ast_suffix (,_1 ,_3))";

  // record value (comma separated)
  satom := "(" rassign ("," rassign )* ")" =>#
    "`(ast_record ,_sr ,(cons _2 (map second _3)))"
  ;
    rassign := sname "=" x[sor_condition_pri] =># "`(,_1 ,_3)";

  // scalar literals (numbers, strings)
  satom := sliteral =># "_1";

  // wildcard pattern
  satom := _ =># "`(ast_patany ,_sr)";

  // ellipsis (for binding C varags functions)
  satom := "..." =># "`(ast_ellipsis ,_sr)";

  // boolean constants
  satom := "false" =># "'(ast_typed_case  0 2)";
  satom := "true" =># "'(ast_typed_case  1 2)";

  // callback expression
  satom := "callback" "[" sexpr "]" =># "`(ast_callback ,_sr ,_3)";

  // array expression (deprecated)
  satom := "[|" sexpr "|]" =># "`(ast_arrayof ,_sr ,(mkl _2))";

  // anonymous function closure
  satom := "{" sexpr "}" =># "(lazy `((ast_fun_return ,_sr ,_2)))";

  // anonymous procedure closure
  satom := scompound =># "(lazy _1)";

  // grouping
  satom := "(" sexpr ")" =># "_2";

  // empty tuple
  satom := "(" ")" =># "'()";

  // conditional expression
  satom := sconditional "endif" =># "_1";

    sconditional := "if" sexpr "then" sexpr selse_part =>#
      "`(ast_cond ,_sr (,_2 ,_4 ,_5))";

      selif := "elif" sexpr "then" sexpr =># "`(,_2 ,_4)";

      selifs := selif =># "`(,_1)";
      selifs := selifs selif =># "(cons _2 _1)";

      selse_part:= "else" sexpr =># "_2";
      selse_part:= selifs "else" sexpr =>#
          """
            (let ((f (lambda (result condthn)
              (let ((cond (first condthn)) (thn (second condthn)))
                `(ast_cond ,_sr (,cond ,thn ,result))))))
            (fold_left f _3 _1))
          """;
}

