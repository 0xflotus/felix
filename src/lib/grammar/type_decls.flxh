syntax type_decls {
  requires statements;

  satom := stypematch =># "_1";

  tstatement := "typedef" sdeclname "=" sexpr ";" =>#
    """
    `(ast_type_alias ,_sr ,(first _2) ,(second _2) ,_4)
    """;

  tstatement := "typedef" "fun" sdeclname stypefun_args ":" stypeexpr "=>" sexpr ";" =>#
    """
    `(mktypefun ,_sr ,(first _3) ,(second _3) ,_4 ,_6 ,_8)
    """;

  tstatement := "typedef" "fun" sdeclname ":" stypeexpr "=" stype_matching+ ";" =>#
    """
    (if (eq? 'ast_arrow (first _5))
      (let (
        (argt (caadr _5))
        (ret (cadadr _5))
        (body `(ast_type_match ,_sr (,(noi '_a) ,_7))))
        (let ((args `(((_a ,argt)))))
      `(mktypefun ,_sr ,(first _3) ,(second _3) ,args ,ret ,body)
      ))
      ('ERROR)
    )
    """;

  stype_matching := "|" sexpr "=>" sexpr =># "`(,_2 ,_4)";

  stypematch := "typematch" sexpr "with" stype_matching+ "endmatch" =>#
    "`(ast_type_match ,_sr (,_2 ,_4))";

  tstatement := "struct" sdeclname "=" ? "{" sstruct_mem_decl * "}" =>#
    """
     (let* 
       (
         (vals (filter_first 'Pval _5))
         (funs (filter_first 'Pfun _5))
         (struct-name (first _2))
         (struct-polyspec (second _2))
         (struct-polyvars (first struct-polyspec))
         (struct-pvids (map first struct-polyvars))
         (struct-pvs (map nos struct-pvids))
         (struct-polyaux (second struct-polyspec))
         (struct `(ast_struct ,_sr ,struct-name ,struct-polyspec ,vals))
         (mfuns (map (lambda (x) 
           (let* 
             (
               (lst (first x))
               (t0 (list-ref lst 0)) ; ast_curry
               (t1 (list-ref lst 1)) ; sr
               (t2 (list-ref lst 2)) ; name
               (polyspec (list-ref lst 3)) ; polyvars
               (t4 (list-ref lst 4)) ; args
               (t5 (list-ref lst 5)) ; return type
               (t6 (list-ref lst 6)) ; fun kind
               (t7 (list-ref lst 7)) ; body
               (polyvars (first polyspec))
               (polyaux (second polyspec))
               (outpolyvars `(,(append struct-polyvars polyvars) ,polyaux))
               (kind (if (equal? (first (first t5)) 'ast_void) 'PRef 'PVal))
               (self-name 'self)
               (self-type `(ast_name ,_sr ,struct-name ,struct-pvs))
               (self-arg `(,kind ,self-name ,self-type none)) 
               (self-args `((,self-arg) none))
               (args (cons self-args t4))
             ) 
             `(,t0 ,t1 ,t2 ,outpolyvars ,args, t5 ,t6 ,t7)
           )) funs)
         )
         (sts (cons struct mfuns))
       )
       `(ast_seq ,_sr ,sts)
     )
     """;
    sstruct_mem_decl := sname ":" stypeexpr ";" =># "`(Pval ,_1 ,_3)";
    sstruct_mem_decl := sfunction  =># "`(Pfun ,_1)";

  tstatement := "cstruct" sdeclname "=" ? "{" sstruct_mem_decl * "}" srequires_clause ";" =>#
    """
    (let* 
       (
         (vals (filter_first 'Pval _5))
         (funs (filter_first 'Pfun _5))
         (struct `(ast_cstruct ,_sr ,(first _2) ,(second _2) ,vals ,_7))
         (mfuns (map (lambda (x) 
           (let* 
             (
               (lst (first x))
               (t0 (list-ref lst 0)) ; ast_curry
               (t1 (list-ref lst 1)) ; sr
               (t2 (list-ref lst 2)) ; name
               (polyspec (list-ref lst 3)) ; polyvars
               (t4 (list-ref lst 4)) ; args
               (t5 (list-ref lst 5)) ; return type
               (t6 (list-ref lst 6)) ; fun kind
               (t7 (list-ref lst 7)) ; body
               (polyvars (first polyspec))
               (polyaux (second polyspec))
               (outpolyvars `(,(append struct-polyvars polyvars) ,polyaux))
               (kind (if (equal? (first (first t5)) 'ast_void) 'PRef 'PVal))
               (self-name 'self)
               (self-type `(ast_name ,_sr ,struct-name ,struct-pvs))
               (self-arg `(,kind ,self-name ,self-type none)) 
               (self-args `((,self-arg) none))
               (args (cons self-args t4))
             ) 
             `(,t0 ,t1 ,t2 ,outpolyvars ,args, t5 ,t6 ,t7)
           )) funs)
         )
         
         (sts (cons struct mfuns))
       )
       `(ast_seq ,_sr ,sts)
     )
     """;

  sopt_name := sname =># "_1";
  sopt_name := sepsilon =># '""';

  tstatement := "union" sdeclname "=" stype_sum_items2 ";" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  tstatement := "union" sdeclname "{" stype_sum_item1* "}" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  tstatement := senum_decl =># "_1";

  tstatement := "enum" sdeclname "{" senum_items "}" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  tstatement := "enum" sdeclname "=" senum_items ";" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sopt_value := "=" sinteger =># "`(some ,_2)";
  sopt_value := sepsilon =># "'none";
  senum_item := sname sopt_value =># "`(,_1 ,_2 ,dfltvs (ast_void ,_sr))";
  senum_items := senum_item "," senum_items =># "(cons _1 _3)";
  senum_items := senum_item =># "`(,_1)";
  senum_items := sepsilon =># "()";

  tstatement := "interface" sdeclname stype_extension "{" srecord_type "}" =>#
    """
    `(ast_type_alias ,_sr ,(first _2) ,(second _2) (ast_type_extension ,_sr ,_3 ,_5))
    """;
    srecord_type := srecord_mem_decl (";" srecord_mem_decl)* ";" =># 
     "`(ast_record_type ,(cons _1 (map second _2)))";
    stypelist := stypeexpr ("," stypeexpr)* =># "(cons _1 (map second _2))";
    stype_extension := "extends" stypelist =># "_2";
    stype_extension := sepsilon =># "()";
}

