syntax type_decls {
  requires statements;

  satom := stypematch =># "_1";

  tstatement := "typedef" sdeclname "=" sexpr ";" =>#
    """
    `(ast_type_alias ,_sr ,(first _2) ,(second _2) ,_4)
    """;

  tstatement := "typedef" "fun" sdeclname stypefun_args ":" stypeexpr "=>" sexpr ";" =>#
    """
    `(mktypefun ,_sr ,(first _3) ,(second _3) ,_4 ,_6 ,_8)
    """;

  tstatement := "typedef" "fun" sdeclname ":" stypeexpr "=" stype_matching+ ";" =>#
    """
    (if (eq? 'ast_arrow (first _5))
      (let (
        (argt (caadr _5))
        (ret (cadadr _5))
        (body `(ast_type_match ,_sr (,(noi '_a) ,_7))))
        (let ((args `(((_a ,argt)))))
      `(mktypefun ,_sr ,(first _3) ,(second _3) ,args ,ret ,body)
      ))
      ('ERROR)
    )
    """;

  stype_matching := "|" sexpr "=>" sexpr =># "`(,_2 ,_4)";

  stypematch := "typematch" sexpr "with" stype_matching+ "endmatch" =>#
    "`(ast_type_match ,_sr (,_2 ,_4))";

  tstatement := "struct" sdeclname "=" ? "{" sstruct_mem_decl * "}" =>#
    """
    `(ast_struct ,_sr ,(first _2) ,(second _2) ,_5)
     """;
    sstruct_mem_decl := sname ":" stypeexpr ";" =># "`(,_1 ,_3)";

  tstatement := "cstruct" sdeclname "=" ? "{" sstruct_mem_decl * "}" srequires_clause ";" =>#
    """
    `(ast_cstruct ,_sr ,(first _2) ,(second _2) ,_5 ,_7)
     """;

  sopt_name := sname =># "_1";
  sopt_name := sepsilon =># '""';

  tstatement := "union" sdeclname "=" stype_sum_items2 ";" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  tstatement := "union" sdeclname "{" stype_sum_item1* "}" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  tstatement := senum_decl =># "_1";

  tstatement := "enum" sdeclname "{" senum_items "}" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  tstatement := "enum" sdeclname "=" senum_items ";" =>#
    """
    `(ast_union ,_sr ,(first _2) ,(second _2) ,_4)
     """;

  sopt_value := "=" sinteger =># "`(some ,_2)";
  sopt_value := sepsilon =># "'none";
  senum_item := sname sopt_value =># "`(,_1 ,_2 ,dfltvs (ast_void ,_sr))";
  senum_items := senum_item "," senum_items =># "(cons _1 _3)";
  senum_items := senum_item =># "`(,_1)";
  senum_items := sepsilon =># "()";
}

