SCHEME """
(define (stripus s) ; strip underscores 
  (let*
    ( 
      (chrs (string->list s))
      (chrs (filter (lambda (x) (not (char=? x (integer->char 95)))) chrs)) ; strip underscores
    )
    (list->string chrs)
  )
)
""";

SCHEME """
(define (tolower-char c) ; convert one character to lower case
  (let* 
    (
      (i (char->integer c))
      (i (if (and (>= i 65) (<= i 90)) (+ i 32) i))
    ) 
    (integer->char i)
  )
)
""";
SCHEME """
(define (tolower-string s) ; convert a whole string to lower case
  (let*
    (
      (chrs (string->list s))
      (chrs (map tolower-char chrs))
    )
    (list->string chrs)
  )
)
""";

SCHEME """
(define (findradix s)  ; find the radix of integer lexeme
  (let* 
    (
      (n (string-length s))
      (result 
        (cond 
          ((prefix? "0b" s)`(,(substring s 2 n) 2)) 
          ((prefix? "0o" s)`(,(substring s 2 n) 8)) 
          ((prefix? "0d" s)`(,(substring s 2 n) 10)) 
          ((prefix? "0x" s)`(,(substring s 2 n) 16)) 
          (else `(,s 10))
        )
      )
    )
    result
  )
)
""";
SCHEME """
(define (findtype s) ;; find type of integer lexeme
  (let*
    (
      (n (string-length s))
      (result
        (cond
          ((suffix? "ut" s)`(,(substring s 0 (- n 2)) "utiny"))
          ((suffix? "tu" s)`(,(substring s 0 (- n 2)) "utiny"))
          ((suffix? "t" s)`(,(substring s 0 (- n 1)) "tiny"))

          ((suffix? "us" s)`(,(substring s 0 (- n 2)) "ushort"))
          ((suffix? "su" s)`(,(substring s 0 (- n 2)) "ushort"))
          ((suffix? "s" s)`(,(substring s 0 (- n 1)) "short"))

          ((suffix? "ui" s)`(,(substring s 0 (- n 2)) "uint"))
          ((suffix? "iu" s)`(,(substring s 0 (- n 2)) "uint"))
          ((suffix? "i" s)`(,(substring s 0 (- n 1)) "int"))

          ((suffix? "uz" s)`(,(substring s 0 (- n 2)) "size"))
          ((suffix? "zu" s)`(,(substring s 0 (- n 2)) "size"))
          ((suffix? "z" s)`(,(substring s 0 (- n 1)) "ssize"))

          ((suffix? "uj" s)`(,(substring s 0 (- n 2)) "uintmax"))
          ((suffix? "ju" s)`(,(substring s 0 (- n 2)) "uintmax"))
          ((suffix? "j" s)`(,(substring s 0 (- n 1)) "intmax"))

          ((suffix? "up" s)`(,(substring s 0 (- n 2)) "uintptr"))
          ((suffix? "pu" s)`(,(substring s 0 (- n 2)) "uintptr"))
          ((suffix? "p" s)`(,(substring s 0 (- n 1)) "intptr"))

          ((suffix? "ud" s)`(,(substring s 0 (- n 2)) "uptrdiff"))
          ((suffix? "du" s)`(,(substring s 0 (- n 2)) "uptrdiff"))
          ((suffix? "d" s)`(,(substring s 0 (- n 1)) "ptrdiff"))

          ;; must come first!
          ((suffix? "uvl" s)`(,(substring s 0 (- n 3)) "uvlong"))
          ((suffix? "vlu" s)`(,(substring s 0 (- n 3)) "uvlong"))
          ((suffix? "ulv" s)`(,(substring s 0 (- n 3)) "uvlong"))
          ((suffix? "lvu" s)`(,(substring s 0 (- n 3)) "uvlong"))
          ((suffix? "llu" s)`(,(substring s 0 (- n 3)) "uvlong"))
          ((suffix? "ull" s)`(,(substring s 0 (- n 3)) "uvlong"))

          ((suffix? "uv" s)`(,(substring s 0 (- n 2)) "uvlong"))
          ((suffix? "vu" s)`(,(substring s 0 (- n 2)) "uvlong"))

          ((suffix? "lv" s)`(,(substring s 0 (- n 2)) "vlong"))
          ((suffix? "vl" s)`(,(substring s 0 (- n 2)) "vlong"))
          ((suffix? "ll" s)`(,(substring s 0 (- n 2)) "vlong"))
    
          ;; comes next
          ((suffix? "ul" s)`(,(substring s 0 (- n 2)) "ulong"))
          ((suffix? "lu" s)`(,(substring s 0 (- n 2)) "ulong"))

          ;; last
          ((suffix? "v" s)`(,(substring s 0 (- n 1)) "vlong"))
          ((suffix? "u" s)`(,(substring s 0 (- n 1)) "uint"))
          ((suffix? "l" s)`(,(substring s 0 (- n 1)) "long"))

          ;; exact
          ((suffix? "u8" s)`(,(substring s 0 (- n 2)) "uint8"))
          ((suffix? "u16" s)`(,(substring s 0 (- n 3)) "uint16"))
          ((suffix? "u32" s)`(,(substring s 0 (- n 3)) "uint32"))
          ((suffix? "u64" s)`(,(substring s 0 (- n 3)) "uint64"))
          ((suffix? "i8" s)`(,(substring s 0 (- n 2)) "int8"))
          ((suffix? "i16" s)`(,(substring s 0 (- n 3)) "int16"))
          ((suffix? "i32" s)`(,(substring s 0 (- n 3)) "int32"))
          ((suffix? "i64" s)`(,(substring s 0 (- n 3)) "int64"))
          (else `(,s "int"))
        )
      )
    )
    result
  )
)
""";
SCHEME """
(define (parse-int s) 
  (let*
    (
      (s (tolower-string s))
      (x (findradix s))
      (radix (second x))
      (x (first x))
      (x (findtype x))
      (type (second x))
      (digits (first x))
      (value (string->number digits radix))
    )
    (if (equal? value #f)
       (begin 
         (newline)
         (display "Invalid integer literal ") (display s) 
         (newline)
         (display "Radix ")(display radix)
         (newline)
         (display "Type ")(display type)
         (newline)
         (display "Digits ")(display digits)
         (newline)
         error
       )
       `(,type ,value)
    ) 
  )
)
""";
SCHEME """
(define (splitsign s)
  (let* 
    (
      (n (string-length s))
      (ch (substring s 0 1))
    )
    (if (equal? "+" ch) `( 1 ,(substring s 1 n))
      (if(equal? "-" ch) `( -1 ,(substring s 1 n)) `(1 ,s))
    )
  )
)
""";

SCHEME """
(define (decode-string s) 
  (let* 
    (
      (n (string-length s))
      (result 
        (cond
          ((prefix? "w'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "W'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "c'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "C'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "u'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "U'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "f'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "F'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "q'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "Q'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "n'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "N'''" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "r'''" s)(substring s 4 (- n 3)))
          ((prefix? "R'''" s)(substring s 4 (- n 3)))
          ((prefix? "'''" s)(unescape (substring s 3 (- n 3))))

          ((prefix? "w\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "W\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "c\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "C\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "u\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "U\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "f\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "F\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "q\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "Q\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "n\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "N\\"\\"\\"" s)(unescape (substring s 4 (- n 3))))
          ((prefix? "r\\"\\"\\"" s)(substring s 4 (- n 3)))
          ((prefix? "R\\"\\"\\"" s)(substring s 4 (- n 3)))
          ((prefix? "\\"\\"\\"" s)(unescape (substring s 3 (- n 3))))

          ((prefix? "w'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "W'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "c'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "C'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "u'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "U'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "f'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "F'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "q'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "Q'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "n'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "N'" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "r'" s)(substring s 2 (- n 1)))
          ((prefix? "R'" s)(substring s 2 (- n 1)))
          ((prefix? "'" s)(unescape (substring s 1 (- n 1))))

          ((prefix? "w\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "W\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "c\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "C\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "u\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "U\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "f\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "F\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "q\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "Q\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "n\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "N\\"" s)(unescape (substring s 2 (- n 1))))
          ((prefix? "r\\"" s)(substring s 2 (- n 1)))
          ((prefix? "R\\"" s)(substring s 2 (- n 1)))
          ((prefix? "\\"" s)(unescape (substring s 1 (- n 1))))

          (else error) 
        )
      )
    )
    ;;(begin 
    ;;   (newline)(display "string=")(display s)
    ;;   (newline)(display "text=")(display result)
       result
    ;;)
  )
)
""";

syntax lexer {
  /* ====================== REGULAR DEFINITIONS ============================ */
  /* special characters */
  regdef quote = '\'';
  regdef dquote = '"';
  regdef slosh = '\\';
  regdef hash = '#';
  regdef linefeed = '\n';
  regdef tab = '\t';
  regdef space = ' ';
  regdef formfeed = 12;
  regdef vtab = 11;
  regdef carriage_return = 13;
  regdef underscore = '_';

  /* character sets */
  regdef bindigit = ['01'];
  regdef octdigit = ['01234567'];
  regdef digit = ['0123456789'];
  regdef hexdigit = ["0123456789ABCDEFabcdef"];
  regdef lower = ['abcdefghijklmnopqrstuvwxyz'];
  regdef upper = ['ABCDEFGHIJKLMNOPQRSTUVWXYZ'];
  regdef letter = lower | upper;
  regdef hichar = [128-255];
  regdef white = space | tab;

  /* nasty: form control characters */
  regdef form_control = linefeed | carriage_return | vtab | formfeed;
  regdef newline_prefix = linefeed | carriage_return;
  regdef newline = formfeed | linefeed  | carriage_return linefeed;
  regdef hash = '#';

  regdef ordinary = letter | digit | hichar |
    '!' | '$' | '%' | '&' | '(' | ')' | '*' |
    '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
    '=' | '>' | '?' | '@' | '[' | ']' | '^' | '_' |
    '`' | '{' | '|' | '}' | '~';

  regdef printable = ordinary | quote | dquote | slosh | hash;

  /* identifiers */
  regdef ucn =
      "\\u" hexdigit hexdigit hexdigit hexdigit
    | "\\U" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit;

  regdef prime = '\'';
  regdef dash = '-';
  regdef idletter = letter | underscore | hichar | ucn;
  regdef alphnum = idletter | digit;
  regdef innerglyph = idletter | digit | dash;
  regdef flx_ident = idletter (innerglyph? (alphnum | prime) +)* prime*;
  regdef tex_ident = slosh letter+;
  regdef sym_ident =
    "+" | "-" | "*" | "/" | "%" | "^" | "~" | 
    "\\&" | "\\|" | "\\^" |
    /* mutator */
    "&=" | "|=" | "+=" | "-=" | "*=" | "/=" | "%=" | "^=" | "<<=" | ">>=" |
    /* comparison */
    "<" | ">" | "==" | "!=" | "<=" | ">=" | "<<" | ">>" 
  ;

  /* NOTE: upgrade to support n"wird + name" strings */
  literal flx_ident =># "(utf8->ucn _1)";
  literal tex_ident =># "_1";
  literal sym_ident =># "_1";

  sname := flx_ident =># "_1" | tex_ident =># "_1" | sym_ident =># "_1";

  /* integers */
  regdef bin_lit  = '0' ('b' | 'B') (underscore? bindigit) +;
  regdef oct_lit  = '0' ('o' | 'O') (underscore? octdigit) +;
  regdef dec_lit  = '0' ('d' | 'D') (underscore? digit) +;
  regdef dflt_dec_lit  =  digit (underscore? digit) *;
  regdef hex_lit  = '0' ('x' | 'X') (underscore? hexdigit)  +;
  regdef int_prefix = bin_lit | oct_lit | dec_lit | dflt_dec_lit | hex_lit;

  regdef fastint_type_suffix = 
    't'|'T'|'s'|'S'|'i'|'I'|'l'|'L'|'v'|'V'|"ll"|"LL"|"z"|"Z"|"j"|"J"|"p"|"P"|"d"|"D";
  regdef exactint_type_suffix =
      "i8" | "i16" | "i32" | "i64"
    | "u8" | "u16" | "u32" | "u64"
    | "I8" | "I16" | "I32" | "I64"
    | "U8" | "U16" | "U32" | "U64";

  regdef signind = 'u' | 'U';

  regdef int_type_suffix =
      '_'? exactint_type_suffix
    | ('_'? fastint_type_suffix)? ('_'? signind)?
    | ('_'? signind)? ('_'? fastint_type_suffix)?;

  regdef int_lit = int_prefix int_type_suffix;

  /* floats: Follows ISO C89, except that we allow underscores;
     AND we require both leading and trailing digits so ;
     x.0 works for tuple projections and 0.f is a function;
     application;
  */
  regdef decimal_string = digit (underscore? digit) *;
  regdef hexadecimal_string = hexdigit (underscore? hexdigit) *;

  regdef decimal_fractional_constant =
    decimal_string '.' decimal_string;

  regdef hexadecimal_fractional_constant =
    ("0x" |"0X")
    hexadecimal_string '.' hexadecimal_string;

  regdef decimal_exponent = ('E'|'e') ('+'|'-')? decimal_string;
  regdef binary_exponent = ('P'|'p') ('+'|'-')? decimal_string;

  regdef floating_suffix = 'L' | 'l' | 'F' | 'f' | 'D' | 'd';
  regdef floating_literal =
    (
      decimal_fractional_constant decimal_exponent? |
      hexadecimal_fractional_constant binary_exponent?
    )
    floating_suffix?;

  /* Python strings */
  regdef qqq = quote quote quote;
  regdef ddd = dquote dquote dquote;

  regdef escape = slosh _;

  regdef dddnormal = ordinary | hash | quote | escape | white | newline;
  regdef dddspecial = dddnormal | dquote dddnormal | dquote dquote dddnormal;

  regdef qqqnormal = ordinary | hash | dquote | escape | white | newline;
  regdef qqqspecial = qqqnormal | quote qqqnormal | quote quote qqqnormal;

  regdef qstring_tail = (ordinary | hash | dquote | escape | white) * quote;
  regdef dstring_tail = (ordinary | hash | quote | escape | white) * dquote;
  regdef qqqstring_tail = qqqspecial * qqq;
  regdef dddstring_tail = dddspecial * ddd;

  regdef qstring = quote qstring_tail;
  regdef dstring = dquote dstring_tail;
  regdef qqqstring = qqq qqqstring_tail;
  regdef dddstring = ddd dddstring_tail;


  regdef raw_dddnormal = ordinary | hash | quote | slosh | white | newline;
  regdef raw_dddspecial = raw_dddnormal | dquote raw_dddnormal | dquote dquote raw_dddnormal;

  regdef raw_qqqnormal = ordinary | hash | dquote | slosh | space | newline;
  regdef raw_qqqspecial = raw_qqqnormal | quote raw_qqqnormal | quote quote raw_qqqnormal;

  regdef raw = 'r' | 'R';

  regdef raw_dstring_tail =  (ordinary | hash | quote | escape | white) * dquote;
  regdef raw_qqqstring_tail = raw_qqqspecial * qqq;
  regdef raw_dddstring_tail = raw_dddspecial * ddd;

  regdef raw_dstring = raw dquote dstring_tail;
  regdef raw_qqqstring = raw qqq qqqstring_tail;
  regdef raw_dddstring = raw ddd dddstring_tail;

  regdef plain_string_literal = dstring | qqqstring | dddstring;
  regdef raw_string_literal = raw_dstring | raw_qqqstring | raw_dddstring;

  regdef string_literal = plain_string_literal | qstring | raw_string_literal;

  regdef wstring_literal = ('w' | 'W') plain_string_literal; 
  regdef ustring_literal = ('u' | 'U') plain_string_literal; 
  regdef cstring_literal = ('c' | 'C') plain_string_literal; 
  regdef qstring_literal = ('q' | 'Q') plain_string_literal; 
  regdef fstring_literal = ('f' | 'F') plain_string_literal; 
  regdef nstring_literal = ('n' | 'N') plain_string_literal; 

/*
  regdef not_hash_or_newline = ordinary | quote | dquote | white | slosh;
  regdef not_newline = not_hash_or_newline | hash;
  regdef quoted_filename = dquote (ordinary | hash | quote | white | slosh)+ dquote;
*/

  // Untyped integer literals.
  literal int_prefix =># """
  (let* 
    (
      (val (stripus _1))
      (x (parse-int val))
      (type (first x))
      (value (second x))
    )
    value
  )
  """; 
  sinteger := int_prefix =># "_1";

  // Typed integer literal.
  literal int_lit =># """
  (let* 
    (
      (val (stripus _1))
      (x (parse-int val))
      (type (first x))
      (value (second x))
    )
    `(,type ,value)
  )
  """; 
  sliteral := int_lit =># "`(ast_literal ,_sr (ast_int ,@_1))";

  // Typed signed integer constant.
  sintegral := int_lit =># "_1";
  sintegral := "-" int_lit =># """
  (let* 
    (
      (type (first _2))
      (val (second _2))
      (val (* -1 val))
    )
    `(,type ,val)
  )
  """;

  strint := sintegral =># "(second _1)";

  // Floating constant.
  regdef sfloat = floating_literal;
  literal sfloat =># """
  (let* 
     (
       (val (stripus _1))
       (val (tolower-string val))
       (n (string-length val))
       (n-1 (- n 1))
       (ch (substring val n-1 n))
       (rest (substring val 0 n-1))
       (result 
         (if (equal? ch "l") `("ldouble" ,rest)
           (if (equal? ch "f") `("float" ,rest) `("double" ,val))
         )
       )
     )
     result 
   ) 
   """; 

  strfloat := sfloat =># "(second _1)";

  // Floating literal.
  sliteral := sfloat =># "`(ast_literal ,_sr (ast_float ,@_1))";

  // String as name.
  literal nstring_literal =># "(decode-string _1)";
  sname := nstring_literal =># "_1";

  // String for pattern or code template.
  regdef sstring = string_literal;
  literal sstring =># "(decode-string _1)";

  // Cstring for code.
  regdef scstring = cstring_literal;
  literal scstring =># "(decode-string _1)";

  // String for string parser.
  regdef strstring = string_literal;
  literal strstring =># "(c-quote-string (decode-string _1))";

  // String like literals.
  regdef String = string_literal;
  literal String =># "`(ast_literal ,_sr (ast_string ,(decode-string  _1)))";
  sliteral := String =># "_1";

  regdef Wstring = wstring_literal;
  literal Wstring =># "`(ast_literal ,_sr (ast_wstring ,(decode-string  _1)))";
  sliteral := Wstring =># "_1";

  regdef Ustring = ustring_literal;
  literal Ustring =># "`(ast_literal ,_sr (ast_ustring ,(decode-string  _1)))";
  sliteral := Ustring =># "_1";

  regdef Cstring = cstring_literal;
  literal Cstring =># "`(ast_literal ,_sr (ast_cstring ,(decode-string  _1)))";
  sliteral := Cstring =># "_1";

  regdef Qstring = qstring_literal;
  literal Qstring =># "`(ast_interpolate ,_sr ,(decode-string _1))";
  sliteral := Qstring =># "_1";

  regdef Fstring = fstring_literal;
  literal Fstring =># "`(ast_vsprintf ,_sr ,(decode-string _1))";
  sliteral := Fstring =># "_1";

}
