syntax statements {
  requires expressions;
  tstatement := "comment" sstring ";" =># "`(ast_comment ,_sr ,_2)";

  tstatement := "private" tstatement =># "`(ast_private ,_2)";
  tstatement := "publish" sstring tstatement =># "_3";

  tstatement := ";" =># """`(ast_nop ,_sr "")""";

  tstatement := "include" sstring ";" =># "`(ast_include ,_sr ,_2)";

  // note: list is reversed, eg X::Y::name goes to list name, Y, Z
  sdeclname := sname stvarlist =># "`(,_1 ,_2)";

  tstatement := stype_qual* "type" sdeclname = "new" sexpr ";" =>#
    """
    `(ast_newtype ,_sr ,(first _3) ,(second _3) ,_6)
    """;

  stype_constraint := "with" squalified_name_comma_list "where" sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := "where" sexpr "with" squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := "where" sexpr =># "`(,_2 ())";
  stype_constraint := "with" squalified_name_comma_list =># "`((ast_tuple,_sr()) ,_2)";
  stype_constraint := sepsilon =># "`((ast_tuple,_sr())())";

  seqorin:= = stypeexpr =># "`(Eq ,_2)";
  seqorin:= "in" stypeexpr =># "`(In ,_2)";
  seqorin:= sepsilon =># "'NoConstraint";

  stvar := sname seqorin =># """`(,_1 (ast_name ,_sr "TYPE" ()) ,_2)""";
  stvar := sname ":" stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := "," stvar =># "_2";

  stvarlist:= sepsilon =># "dfltvs";
  stvarlist:= "[" stvar_comma_list stype_constraint "]" =>#
    "(tvfixup _2 _3)";

  stypeparameter:= sname ":" x[sarrow_pri] =># "`(,_1 ,_3)";
  stypeparameter:= sname =># "`(,_1 ,(noi 'typ_none))";
  stypeparameter_comma_list := sepsilon =># "()";
  stypeparameter_comma_list := stypeparameter "," stypeparameter_comma_list =># "(cons _1 _3)";
  stypeparameter_comma_list := stypeparameter =># "`(,_1)";

  stypefun_arg := sname =># "`((,_1 ,(noi 'typ_none)))";
  stypefun_arg := "(" stypeparameter_comma_list ")" =># "_2";
  stypefun_args := stypefun_arg+  =># "_1";

  stodo := "todo" sstring ";" =># "`(ast_nop ,_sr ,_2)";
  stodo := "todo" ";" =># """`(ast_nop ,_sr "todo")""";

  //scompound := "{" sstatements "}" =># "_2";
  scompound := "{" tstatement* "}" =># "_2";

  sname_suffix:= "," sname sname_suffix =># "(cons _2 _3)";
  sname_suffix:= "," sname =># "`(,_2)";
}

