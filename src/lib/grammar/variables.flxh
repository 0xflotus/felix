//$ General variable binders.
syntax variables {
  requires statements, executable;

  //$ Value binder: multi declaration. Like:
  //$ 
  //$ val x,y,z = 1,2,3;
  //$
  tstatement := "val" sname sname_suffix "=" sexpr ";" =>#
    """
    (let
      (
        (names (cons _2 _3))
        (vals (mkl _5))
      )
      (begin
      ;;(display "names=")(display names)
      ;;(display "init=")(display vals)
      ;;(display "\\n")
      (if (eq? (length names)(length vals))
        (let
          (
            (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
          )
          `(ast_seq ,_sr ,(map f names vals))
        )
        (let*
          (
            (f (lambda (n)`((Val ,_sr ,n) none)))
            (lexpr (map f names))
          )
          `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
        )
    )))
    """;

  //$ Value binder, single.
  tstatement := "val" sdeclname "=" sexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
     """;

  //$ Value binder, single, with type.
  tstatement := "val" sdeclname ":" stypeexpr "=" sexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  //$ Reference binder.
  tstatement := "ref" sdeclname "<-" sexpr ";" =>#
    """
    `(ast_ref_decl ,(first _2) ,(second _2) none (some ,_4))
     """;

  //$ Reference binder with type.
  tstatement := "ref" sdeclname ":" stypeexpr "<-" sexpr ";" =>#
    """
    `(ast_ref_decl ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  //$ Fun binder, for lazy evaluation.
  //$ A function with no arguments.
  //$ Uttering the name of the function calls it.
  tstatement := "fun" sdeclname "<-" sexpr ";" =>#
    """
    `(ast_lazy_decl ,(first _2) ,(second _2) none (some ,_4))
     """;

  //$ Fun binder with type.
  tstatement := "fun" sdeclname ":" stypeexpr "<-" sexpr ";" =>#
    """
    `(ast_lazy_decl ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  //$ Variable binder, multiple.
  tstatement := "var" sname sname_suffix "=" sexpr ";" =>#
    """
    (let
      (
        (names (cons _2 _3))
        (vals (mkl _5))
      )
      (begin
      ;;(display "names=")(display names)
      ;;(display "init=")(display vals)
      ;;(display "\\n")
      (if (eq? (length names)(length vals))
        (let
          (
            (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
          )
          `(ast_seq ,_sr ,(map f names vals))
        )
        (let*
          (
            (f (lambda (n)`((Var ,_sr ,n) none)))
            (lexpr (map f names))
          )
          `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
        )
    )))
    """;

  //$ Variable binder, single.
  tstatement := "var" sdeclname "=" sexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
     """;

  //$ Variable binder, single, with type.
  tstatement := "var" sdeclname ":" stypeexpr "=" sexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  //$ Variable binder, single, with type, no explicit initialiser.
  tstatement := "var" sdeclname ":" stypeexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) none)
     """;
}

