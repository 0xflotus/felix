syntax variables {
  // assignments have lower priority than variable
  // definitions to support 'int x = 1;' being
  // a variable definition "not" an assignment,
  // so we have to requires them first: they're
  // currently defined in executable.. this is fragile ..
  requires statements, executable;

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  sval_def := "val" sname sname_suffix = sexpr ";" =>#
    """
    (let
      (
        (names (cons _2 _3))
        (vals (mkl _5))
      )
      (begin
      ;;(display "names=")(display names)
      ;;(display "init=")(display vals)
      ;;(display "\\n")
      (if (eq? (length names)(length vals))
        (let
          (
            (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
          )
          `(ast_seq ,_sr ,(map f names vals))
        )
        (let*
          (
            (f (lambda (n)`((Val ,_sr ,n) none)))
            (lexpr (map f names))
          )
          `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
        )
    )))
    """;

  sval_def := "val" sdeclname = sexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
     """;

  sval_def := "val" sdeclname ":" stypeexpr = sexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  sval_def := "val" sdeclname ":" stypeexpr ";" =>#
    """
    `(ast_val_decl ,_sr ,(first _2) ,(second _2) (some ,_4) none)
     """;

  sval_def := "ref" sdeclname "<-" sexpr ";" =>#
    """
    `(ast_ref_decl ,(first _2) ,(second _2) none (some ,_4))
     """;

  sval_def := "ref" sdeclname ":" stypeexpr "<-" sexpr ";" =>#
    """
    `(ast_ref_decl ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  sval_def := "fun" sdeclname "<-" sexpr ";" =>#
    """
    `(ast_lazy_decl ,(first _2) ,(second _2) none (some ,_4))
     """;

  sval_def := "fun" sdeclname ":" stypeexpr "<-" sexpr ";" =>#
    """
    `(ast_lazy_decl ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  svar_def := "var" sname sname_suffix = sexpr ";" =>#
    """
    (let
      (
        (names (cons _2 _3))
        (vals (mkl _5))
      )
      (begin
      ;;(display "names=")(display names)
      ;;(display "init=")(display vals)
      ;;(display "\\n")
      (if (eq? (length names)(length vals))
        (let
          (
            (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
          )
          `(ast_seq ,_sr ,(map f names vals))
        )
        (let*
          (
            (f (lambda (n)`((Var ,_sr ,n) none)))
            (lexpr (map f names))
          )
          `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
        )
    )))
    """;

  svar_def := "var" sdeclname = sexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) none (some ,_4))
     """;

  svar_def := "var" sdeclname ":" stypeexpr = sexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) (some ,_6))
     """;

  svar_def := "var" sdeclname ":" stypeexpr ";" =>#
    """
    `(ast_var_decl ,_sr ,(first _2) ,(second _2) (some ,_4) none)
     """;
}

