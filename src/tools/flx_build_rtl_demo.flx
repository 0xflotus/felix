include "std/felix/toolchain_clang_config";
include "std/felix/toolchain_interface";
include "std/felix/flx_cp";
include "std/felix/flx_pkgconfig";

proc dbug (x:string) {
// println x;
}
proc make_lib 
(
  db: FlxPkgConfig::FlxPkgConfigQuery_t,  
  toolchain-maker: clang_config_t -> toolchain_t, 
  repo: string, build:string, pkg:string
)
{
  var FLX_INSTALL_DIR = #(Config::config).FLX_INSTALL_DIR;
  println$ "------------";
  println$ "Make lib " + pkg;
  var configdir = Filename::join (FLX_INSTALL_DIR, "config", "target");
  var srcpath = Filename::join (repo, pkg);
  var ddeps = db.getpkgfield (pkg,"requires_dlibs");
  var config = 
    (
      header_search_dirs= list[string] ("-I"+build, "-I"+configdir),
      macros= Empty[string],
      library_search_dirs= list[string] ("-L"+build),
      dynamic_libraries= ddeps,
      static_libraries= Empty[string],
      debugln = dbug
    )
  ;
  var toolchain = toolchain-maker config;
  println$ #(toolchain.whatami);
  CopyFiles::copyfiles (srcpath, RE2 r".*\.h(pp)?",Filename::join(build,"${0}"),true, true);

  var pat = r".*\.cpp";
  var files = FileSystem::regfilesin (srcpath,pat);
  fun objname (file:string) => let 
      ?dstobj = file.Filename::strip_extension + #(toolchain.dynamic_object_extension) in
      Filename::join (build, dstobj)
  ;

  for file in files do
    //println$ "Compiling " + file " -> " + objname file;
    var srcfile = Filename::join (srcpath, file);
    var result = toolchain.cxx_dynamic_object_compiler (src=srcfile, dst=objname file);
    if result != 0 do
      println$ "Compiler result " + str result;
      System::exit(1);
    done
  done

  var objs = map objname files;
  var dstlib = Filename::join (build, pkg+#(toolchain.dynamic_library_extension));
  result = toolchain.dynamic_library_linker(srcs=objs, dst=dstlib);
  if result != 0 do
    println$ "Linker result " + str result;
    System::exit(1);
  done
}

proc make_rtl (repo:string, build:string, pkgconfig_dir:string, boot_package:string)
{
  
  println$ 
    "flx_build: configdir=" + pkgconfig_dir + 
    ", bootpkg=" + boot_package +
    ", builddir=" + build +
    ", repository=" + repo
  ;

  var db = FlxPkgConfig::FlxPkgConfigQuery (list[string] pkgconfig_dir);

  gen getbootfield (field:string) => db.getpkgfield1 (boot_package, field);

  var compiler = getbootfield "compiler"; 
  var os = getbootfield "os"; 
  var toolchain = getbootfield "toolchain"; 
  println$ "compiler     : " + str compiler;
  println$ "os           : " + str os;
  println$ "toolchain    : " + str toolchain;

  var allpkgs = db.getclosure boot_package;
  println$ "Closure      : " + str allpkgs;

  for pkg in allpkgs do
    var slib = db.getpkgfielddflt (pkg,"provides_slib");
    var dlib = db.getpkgfielddflt (pkg,"provides_dlib");
    var srcdir = db.getpkgfielddflt (pkg,"srcdir");
    var src = db.getpkgfielddflt (pkg,"src");
    println$ f"%15S %20S %20S %20S %20S" (pkg,slib,dlib,srcdir,src);
  done

  var toolchain-maker = 
    Dynlink::load-plugin-func1 [toolchain_t,clang_config_t] 
    (
      dll-name="src/tools/" + toolchain, // temporary hack!
      setup-str="",
      entry-point=toolchain
    )
  ;
  for pkg in rev allpkgs do
    make_lib (db,toolchain-maker, repo,build,pkg);
  done
}

if System::argc < 4 do
  println$ "Usage: flx_build configdir bootpkg builddir repo";
done

var pkgconfig_dir = System::argv 1;
var boot_package = System::argv 2;
var build = System::argv 3;
var repo = System::argv 4;


make_rtl (repo, build, pkgconfig_dir,boot_package);
System::exit (0);







