include "std/felix/toolchain_clang_config";
include "std/felix/toolchain_interface";
include "std/felix/flx_cp";
include "std/felix/flx_pkgconfig";
include "std/felix/flx/flx";

proc make_lib 
(
  db: FlxPkgConfig::FlxPkgConfigQuery_t,  
  toolchain-maker: clang_config_t -> toolchain_t, 
  repo: string, build:string, pkg:string, tmpdir:string,
  debug: bool
)
{
  proc dbug (x:string) => debug ?? println$ '[make_lib: '+pkg+']' x;

  var FLX_INSTALL_DIR = #(Config::config).FLX_INSTALL_DIR;
  println$ "------------";
  println$ "Make lib " + pkg;
  println$ "------------";
  var configdir = Filename::join (FLX_INSTALL_DIR, "host", "lib", "rtl");
  var srcdir = db.getpkgfielddflt (pkg,"srcdir");
  var srcpath = Filename::join (repo, srcdir);
  var build_includes= db.getpkgfield (pkg,"build_includes");
  var ddeps = db.getpkgfield (pkg,"requires_dlibs"); // external libs
  var deps = db.getpkgfield(pkg,"Requires");
  var result,depdlibs =  db.query("--field=provides_dlib"+deps); // packaged dlibs
//println$ "Debug DEPLIBS: " + str ddeps + " AND " + str depdlibs;
  var macros = db.getpkgfield(pkg,"macros");
  var ccflags = db.getpkgfield(pkg,"cflags");
  fun mkinc (x:string) => "-I"+x;
  var config = 
    (
      header_search_dirs= list[string] (mkinc build, mkinc configdir)+map mkinc build_includes,
      macros= map (fun (x:string)=> "-D"+x) macros,
      cflags = ccflags,
      library_search_dirs= list[string] ("-L"+build),
      dynamic_libraries= ddeps+depdlibs,
      static_libraries= Empty[string],
      debugln = dbug
    )
  ;
  var toolchain = toolchain-maker config;
  println$ #(toolchain.whatami);
  var headers = db.getpkgfielddflt(pkg,"headers");
  if headers == "" do headers = r".*\.h(pp)?"; println$ "copying all header files"; done
  var hsrc, hdst = "","";
  match split (headers, ">") with
  | #Empty => ;
  | Cons (?h,#Empty) => hsrc = h;
  | Cons (?h,Cons (?d,#Empty)) => hsrc = h; hdst = d;
  | _ => println$ "Header file too many > characters " + headers;
  endmatch;

  if hdst == "" do hdst = "${0}"; done
  println$ "Copying headers " + hsrc + " > " + hdst;
  CopyFiles::copyfiles (srcpath, hsrc,Filename::join(build,hdst),true, true);

  var pats = db.getpkgfield(pkg,"src");
  var pat = catmap '|' (fun (x:string)=>"("+x+")") pats;
//println$ "Finding Sources in "+srcpath;
  var files = FileSystem::regfilesin (srcpath,pat);
//println$ "Sources = " + str files;
  {
    fun objname (file:string) => let 
        ?dstobj = file.Filename::strip_extension + #(toolchain.dynamic_object_extension) in
        Filename::join (tmpdir, dstobj)
    ;

    for file in files do
      println$ "Compiling [dynamic] " + file " -> " + objname file;
      var srcfile = Filename::join (srcpath, file);
      var dst = objname file;
      Directory::mkdirs (Filename::dirname dst);
      match Filename::get_extension srcfile with
      | ?x when x == ".cc" or x == ".cpp" =>
        result = toolchain.cxx_dynamic_object_compiler (src=srcfile, dst=dst);
      | ".c" =>
        result = toolchain.c_dynamic_object_compiler (src=srcfile, dst=dst);
      | ?x => println$ "Unknown extension " + x; System::exit(1);
      endmatch
      ;
      if result != 0 do
        println$ "Compiler result " + str result;
        System::exit(1);
      done
    done

    var objs = map objname files;
    var libname = "lib" + (db.getpkgfield1(pkg,"provides_dlib")).[2 to] +#(toolchain.dynamic_library_extension);
    var dstlib = Filename::join (build, libname);
    println$ "Dynamic Linking library " + dstlib;
    result = toolchain.dynamic_library_linker(srcs=objs, dst=dstlib);
    if result != 0 do
      println$ "Linker result " + str result;
      System::exit(1);
    done
  };
  {
    fun objname (file:string) => let 
        ?dstobj = file.Filename::strip_extension + #(toolchain.static_object_extension) in
        Filename::join (tmpdir, dstobj)
    ;

    for file in files do
      println$ "Compiling [static] " + file " -> " + objname file;
      var srcfile = Filename::join (srcpath, file);
      var dst = objname file;
      Directory::mkdirs (Filename::dirname dst);
      match Filename::get_extension srcfile with
      | ?x when x == ".cc" or x == ".cpp" =>
        result = toolchain.cxx_static_library_object_compiler (src=srcfile, dst=dst);
      | ".c" =>
        result = toolchain.c_static_object_compiler (src=srcfile, dst=dst);
      | ?x => println$ "Unknown extension " + x; System::exit(1);
      endmatch
      ;
      if result != 0 do
        println$ "Compiler result " + str result;
        System::exit(1);
      done
    done

    var objs = map objname files;
    var libname = "lib" + (db.getpkgfield1(pkg,"provides_slib")).[2 to] +#(toolchain.static_library_extension);
    var dstlib = Filename::join (build, libname);
    println$ "Static Linking Library " + dstlib;
    result = toolchain.static_library_linker(srcs=objs, dst=dstlib);
    if result != 0 do
      println$ "Linker result " + str result;
      System::exit(1);
    done
  };
}

proc make_rtl (
  repo:string, 
  build:string, 
  pkgconfig_dir:string, 
  boot_package:string, 
  tmpdir:string,
  debug: bool
)
{

  proc dbug (x:string) => debug ?? println$ '[make_rtl] ' + x;
  var librtl = Filename::join (build,"host","lib","rtl");
  var bin = Filename::join (build,"host","bin");
  Directory::mkdirs tmpdir;
  Directory::mkdirs librtl;
  println$ 
    "flx_librtl: configdir=" + pkgconfig_dir + 
    ", bootpkg=" + boot_package +
    ", librtldir=" + librtl +
    ", repository=" + repo
  ;

  var db = FlxPkgConfig::FlxPkgConfigQuery (list[string] pkgconfig_dir);

  gen getbootfield (field:string) => db.getpkgfield1 (boot_package, field);

  var compiler = getbootfield "compiler"; 
  var os = getbootfield "os"; 
  var toolchain = getbootfield "toolchain"; 
  println$ "compiler     : " + str compiler;
  println$ "os           : " + str os;
  println$ "toolchain    : " + str toolchain;

  var allpkgs = db.getclosure boot_package;
  //println$ "Closure      : " + str allpkgs;

  for pkg in allpkgs begin 
    var lib = db.getpkgfielddflt (pkg,"library");
    var srcdir = db.getpkgfielddflt (pkg,"srcdir");
    println$ f"%15S %20S %20S" (pkg,lib,srcdir);
  end 

  var toolchain-maker = 
    Dynlink::load-plugin-func1 [toolchain_t,clang_config_t] 
    (
      //dll-name=Filename::join (pluginpath,toolchain), 
      dll-name=toolchain, 
      setup-str="",
      entry-point=toolchain
    )
  ;
  for pkg in allpkgs begin
    var library = db.getpkgfielddflt (pkg,"library");
    var srcdir = db.getpkgfielddflt (pkg,"srcdir");
    var src = db.getpkgfield(pkg,"src");
    if library != "" do
      if srcdir == "" do
        println$ "Package error, package " + pkg + " library " + library + " No srcdir specified";
        System::exit(1);
      done
      if src.is_empty do
        println$ "Package error, package " + pkg + " library " + library + " No src files specified";
        System::exit(1);
      done
      make_lib (db,toolchain-maker, repo,librtl,pkg,tmpdir, debug);
    else 
      println$ "------------";
      println$ "External package " + pkg;
      println$ "------------";
    done
  end 

  // make drivers
  begin
    println$ "Make drivers";
    var FLX_INSTALL_DIR = #(Config::config).FLX_INSTALL_DIR;
    var configdir = Filename::join (FLX_INSTALL_DIR, "host", "lib","rtl");
    fun mkinc (x:string) => "-I"+x;
    var srcdir = Filename::join (repo,"src","flx_drivers");
    var config = 
      (
        header_search_dirs= list[string] (mkinc librtl, mkinc srcdir, mkinc configdir),
        macros= Empty[string],
        cflags = Empty[string],
        library_search_dirs= list[string] ("-L"+librtl),
        dynamic_libraries= Empty[string],
        static_libraries= Empty[string], //############ FIXME or the link won't work!
        debugln = dbug
      )
    ;
    fun prgname (file:string) => let 
        ?dstprg = file.Filename::strip_extension + #(toolchain.executable_extension) in
        Filename::join (bin, dstprg)
    ;


    var toolchain = toolchain-maker config;
    println$ #(toolchain.whatami);
    proc cobj (s:string,dst:string) {
      var src = Filename::join (srcdir,s);
      println$ "Compiling [static] " + src + " -> " + dst;
      var result = toolchain.cxx_static_object_compiler(src=src, dst=dst);
      if result != 0 do
        println$ "Driver compile "+ s + " -> " + dst +" FAILED";
      done
    }
    cobj("flx_run_lib_static.cpp",Filename::join(librtl,"flx_run_lib"+#(toolchain.static_object_extension)));
    cobj("flx_run_lib_dynamic.cpp",Filename::join(tmpdir,"flx_run_lib_dynamic"+#(toolchain.static_object_extension)));
    cobj("flx_arun_lib_static.cpp",Filename::join(librtl,"flx_arun_lib"+#(toolchain.static_object_extension)));
    cobj("flx_arun_lib_dynamic.cpp",Filename::join(tmpdir,"flx_arun_lib_dynamic"+#(toolchain.static_object_extension)));
    cobj("flx_run_main.cxx",Filename::join(librtl,"flx_run_main"+#(toolchain.static_object_extension)));
    cobj("flx_arun_main.cxx",Filename::join(librtl,"flx_arun_main"+#(toolchain.static_object_extension)));

    proc prg(file:string) {
      var exe = prgname file;
      println$ "Linking [executable] " + exe;
      var objs = list (
        Filename::join(tmpdir,file+"_lib_dynamic")+#(toolchain.static_object_extension),
        Filename::join(librtl,file+"_main")+#(toolchain.static_object_extension)
      );
      var result,libs = db.query$ list("--rec","--keeprightmost","--field=provides_slib",file);
      if result != 0 do
        println$ "Driver pkgconfig query for "+ file+" FAILED";
      done
      result = toolchain.executable_linker(srcs=objs+libs, dst=exe);
      if result != 0 do
        println$ "Driver link  "+ file+" FAILED";
      done
    }
    prg("flx_run");
    prg("flx_arun");
  end
}

fun / (x:string,y:string) => Filename::join(x,y);

proc dirsetup(debug:bool)
{
  println$ "Create clean target build/trial";
  C_hack::ignore$ FileSystem::unlink_file('build'/'trial');
  C_hack::ignore$ FileSystem::unlink_file("trial-tmp");

  C_hack::ignore$ Directory::mkdir('build'/'trial');
  C_hack::ignore$ Directory::mkdir('build'/'trial'/'host');
  C_hack::ignore$ Directory::mkdir('build'/'trial'/'host'/'bin');

  println$ "copy config";
  CopyFiles::copyfiles('build'/'release'/'host'/'config', '(.*)','build'/'trial'/'host'/'config'/'${1}',true,debug);
  CopyFiles::copyfiles('build'/'release'/'host'/'lib', r"(.*\.(h|hpp|flx|flxh))", 'build'/'trial'/'host'/'lib'/'${1}',true,debug);

  println$ "Copy repository src";
	CopyFiles::copyfiles('src', '(.*\.(h|hpp|ml|c|cpp|cxx|cc|flx|flxh|fdoc|js|html|svg|png|files|include))', 'build'/'trial'/'share'/'src'/'${1}',true,debug);

  println$ "Copy Felix library";
	CopyFiles::copyfiles ('build'/'trial'/'share'/'src'/'lib', r"(.*\.(flx|flxh|fdoc|files))", 'build/trial/share/lib/${1}',true,debug);

  // This is SPECIAL because "version.flx" is the only file which is both
  // shared-readonly and generated. So it has to be copied out of an
  // existing built library not the repository image.
	CopyFiles::copyfiles ('build'/'release'/'share'/'lib'/'std', '(version.flx)', 'build'/'trial'/'share'/'lib'/'std/${1}',true,debug);
}

proc build_plugins()
{
  var plugins = list (
    'cpp2html',
    'fdoc2html',
    'fdoc_button',
    'fdoc_fileseq',
    'fdoc_heading',
    'fdoc_paragraph',
    'fdoc_scanner',
    'fdoc_slideshow',
    'flx2html',
    'fpc2html',
    'ocaml2html',
    'py2html',
    'toolchain_clang_linux',
    'toolchain_clang_osx',
    'toolchain_gcc_linux',
    'toolchain_gcc_osx'
  );
  for plugin in plugins do
    println$ "Building plugin " + plugin;
    Flx::runflx$ list ('--test=build'/'trial', '-c', '-ox','build'/'trial'/'host'/'lib'/'rtl'/plugin, 'build'/'trial'/'share'/'lib'/'plugins'/plugin);
    Flx::runflx$ list ('--test=build'/'trial', '-c', '--nolink','-ox', 'build'/'trial'/'host'/'lib'/'rtl'/plugin, 'build'/'trial'/'share'/'lib'/'plugins'/plugin);
    Flx::runflx$ list ('--test=build'/'trial', '--static','-c', '--nolink','-ox', 'build'/'trial'/'host'/'lib'/'rtl'/plugin, 'build'/'trial'/'share'/'lib'/'plugins'/plugin);
  done
 
}
proc flx_build(boot_package:string, debug:bool)
{
  dirsetup(debug);

  // at this point, the build proceeds using host tools, but only target sources.
  make_rtl ('build'/'trial'/'share', 'build'/'trial', 'build'/'trial'/'host'/'config',boot_package, 'trial-tmp', debug);

  // copy the compiler 
  CopyFiles::copyfiles('build'/'release'/'host'/'bin', 'flxg', 'build'/'trial'/'host'/'bin'/'flxg', true, debug);
  build_plugins;
  println$ "Build Complete";
}


noinline proc build_felix (xargs:list[string])
{
  if xargs.len.int < 2 do
    println$ "Usage: flx_build [debug]";
    println$ "Execute from directory containing repository";
    println$ "Uses build/release to create build/trial";
    System::exit(1);
  done

  var v = varray xargs;
  var boot_package = xargs . 1uz;
  var debug = xargs.len.int == 3;
  flx_build (boot_package, debug);
}


build_felix (#System::args);

System::exit (0);


