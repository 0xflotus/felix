include "./charclass";

var FLX_PKGCONFIG_PATH = Empty[string];
var INSTALL_ROOT = "";
var C_PATH = Empty[string];

fun get_file (var fname:string, path:list[string]) = {
  if fname.[0] == char "$" do fname = fname.[1 to]; done
  if FileStat::fileexists fname do return Some fname;
  else
    var f = Filename::join(INSTALL_ROOT,fname);
    if FileStat::fileexists f do return Some f;
    else return FileSystem::find_in_path (fname, path);
    done
  done
}



module Fpc2Html 
{
fun xlat_fpc(t:string, dir:string) : bool * string =
{
  var out = "";
  val lines = split(t,"\n");
  iter handle_line lines;
  return false, out;

  proc handle_line(s:string) {
    match split(s,":") with
    | Cons(?fn,Cons(?fv,Empty[string]))  =>
      { 
        out+= "<span class=fpc_fieldname>"+fn+": </span>";
        if fn in ("Requires","flx_requires_driver") do
          var pkgs=split$ fv.strip, " ";
          iter handle_pkg pkgs;
          out+="\n";
        elif fn == "includes" do
          var includes=split$ fv.strip, " ";
          iter handle_include includes;
          out+="\n";
        else out+= fv+"\n"; 
        done;
      }
    | ?x => { out+=s + "\n"; }
    endmatch;
  }
  proc handle_pkg(s:string) {
    match get_file(s+".fpc",FLX_PKGCONFIG_PATH) with
    | Some ?path => { out += '<a href="/$' + path + '">' + s + '</a> '; }
    | None => { out += s + " "; }
    endmatch;
  }
  proc handle_include(s:string) {
    var n = s;
    while n.[0] in (char '"', char '<', char "'") do n=n.[1 to]; done
    while n.[-1] in (char '"',char '>',char "'") do n=n.[to -1]; done
    match get_file(n,C_PATH) with
    | Some ?path => { out += '<a href="/$' + path + '?cpp">' + s + '</a> '; }
    | None => { out += s + " "; }
    endmatch;
  }
}
}

println$ "Fpc2html initialisation";

fun setup(x:string) = {
  println$ "Fpc2html config: " + x;
  return 0;
}

export fun setup of (string) as "setup";
export fun Fpc2Html::xlat_fpc of (string * string) as "xlat_fpc";

