include "./charclass";
include "./plugin_common";

include "./slideshow-interface";
var slideshow-maker : (string->0) -> slideshow_t;

include "./paragraph-interface";
var paragraph-maker : (string->0) -> paragraph-control_t;

include "./heading-interface";
var heading-maker : (paragraph-control_t * (string->0)) -> heading-control_t;

include "./fileseq-interface";
var fileseq-maker : (string) -> fileseq-control_t;


// felix document
var INSTALL_ROOT="";
var FLX_PATH = Empty[string];
var FDOC_PATH = Empty[string];
var FLX_PKGCONFIG_PATH = Empty[string];
var FLX_WEBSERVER_PLUGIN_PATH = Empty[string];
var PLUGIN_MAP = Empty[string^3];


fun get_flx (fname:string) = {
  var flx =
    match get_file(fname,INSTALL_ROOT,FLX_PATH) with
    | Some ?name => load(name)
    | None => f"NO FILE %S FOUND IN %S" (fname, str FLX_PATH)
    endmatch
  ;
  println$ "Loaded felix file " + fname+", len="+str (flx.len.int);
  return flx;
}

// fixup text by replacing < > and & characters
fun txt2html (x:string) =
{
  var out2 = "";
  for var i in 0 upto x.len.int - 1 do
    var ch = x.[i];
    if ch == char "<" do out2+="&lt;";
    elif ch == char ">" do out2+="&gt;";
    elif ch == char "&" do out2+="&amp;";
    else out2+=ch;
    done
  done

  return out2;
}


typedef xlat_t = string * string -> bool * string;

var xlat_felix: xlat_t;
var xlat_cpp: xlat_t;

module Fdoc2Html {

proc boreq(l:&bool, r:bool) { l <- *l or r; } 

val markdown_code = RE2 ("({([^}]*)})");
fun markdown (s:string):string= {
  var x = s;
  C_hack::ignore(GlobalReplace(&x, markdown_code, StringPiece ("<code>\\2</code>")));
  return x;
}

val timeout = Filename::join (#Config::config.FLX_INSTALL_DIR, "bin", "timeout"+#Config::config.EXT_EXE);

gen safer_popen(cmd:string)=>
  Process::popen_in(timeout+" -t 15 " + cmd + " 2>&1")
;

fun xlat_fdoc(t:string, filename:string): bool * string =
{
  var slideshow = slideshow-maker write_string of (string);
  println$ "FDOC make slidehow .. " + #(slideshow.whatami);

  var paragraph = paragraph-maker write_string of (string);
  println$ "FDOC make paragraph .. " + #(paragraph.whatami);

  var heading = heading-maker (paragraph, write_string of (string));
  println$ "FDOC make heading .. " + #(heading.whatami);

  var fileseq = fileseq-maker (filename);
  println$ "FDOC make fileseq .. " + #(fileseq.whatami);


  var needs_mathjax = false;
  var out = "";
  proc write_string(t:string) 
  { 
    out += t;
  }

  private fun split_first (x:string, c:string):string*string =>
    match find_first_of (x, c) with
      | Some ?n => (strip(x.[to n]),strip(x.[n+1 to]))
      | _ => (x,"")
    endmatch
    ;

  write_string #(fileseq.shownav);

  union state_t = 
    | cmd // processing command
    | doc // processing document
    | felix // processing felix code
    | cpp // processing C/C++ code
    | pre // processing pre-formatted code
    | flx_and_expect // processing felix code and expect file
  ;
  fun str(s:state_t) => match s with
  | doc => "doc"
  | felix => "felix"
  | cpp => "c++"
  | pre => "preforma"
  | flx_and_expect => "flx-and-expect"
  | cmd => "cmd"
  endmatch;
  
  var i = 0; var s:state_t=doc;
  var ch = char "\n";
  var sol = true;
  proc next() { sol = ch == char "\n"; ch = t.[i]; ++i; }
  fun ahead (j:int)=> t.[i + j -1]; 
  var b = "";
  proc cp() { b += ch; }

  // paragraphs
  proc sp () { paragraph.sp (); }
  proc sp (cls:string) { paragraph.sp-clas cls; }
  proc ep () { paragraph.ep (); }
  proc bp () { paragraph.bp (); }

  // headings
  proc h(n:int, txt:string) {
    heading.head (#(fileseq.docnum), n, txt);
    s = doc;
  }
 
nextc:>
  next();
  if isnull ch goto fin; // out of data
  match s with 
  | doc =>
    { 
      if sol and char "@" == ch do 
        if b != "" do sp; write_string(markdown b); done
        s = cmd; b="";
      elif char "\n" == ch and char "\n" == ahead(1) do 
        sp; write_string(markdown b); ep;
        b="";
      else cp; 
      done
      goto nextc;
    }
  | pre =>
    { 
      if sol and char "@" == ch  do 
        if b != "" do 
          sp; 
          write_string("<pre>"); 
          write_string(txt2html b); 
          write_string("</pre>"); 
          ep;
        done
        s = cmd; b="";
      else cp; 
      done
      goto nextc;
    }

  | cpp =>
    { 
      if sol and char "@" == ch do 
        if b != "" do 
          sp;
          write_string("<pre class='cppbg'>"); 
          write_string((xlat_cpp,b,"").1); // no parent!
          write_string("</pre>");
          ep; 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | felix =>
    { 
      if sol and char "@" == ch do 
        if b != "" do 
          sp;
          write_string("<pre class='flxbg'>"); 
          needs_mathjax', txt := xlat_felix (b,"");
          needs_mathjax |= needs_mathjax';
          write_string(txt); // no parent!
          write_string("</pre>");
          ep; 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | cmd => 
    {
      if char "\n" != ch do cp; goto nextc;
      else
        b = strip b;
        if b == "felix" do s = felix;
        elif prefix (b,"felix ") do 
          {
            var rest = strip(b.[6 to]);
            var re1 = RE2('(.*) "(.*)" "(.*)"');
            var re2 = RE2('(.*) "(.*)"');
            var v1 = varray(4uz, StringPiece "");
            var v2 = varray(4uz, StringPiece "");
            var v3 = varray(4uz, StringPiece "");
            var matched1 = Match(re1, StringPiece(rest),0,ANCHOR_BOTH,v1.stl_begin, v1.len.int);
            var matched2 = Match(re2, StringPiece(rest),0,ANCHOR_BOTH,v2.stl_begin, v2.len.int);
            if matched1 do
              var fname = v1.1.string.strip;
            elif matched2 do
              fname = v2.1.string.strip;
            else
              fname = rest;
            done
            var flx = get_flx(fname);
            if matched1 do
               var p1 = match find(flx,v1.2.string) with
               | Some ?i => i
               | None => 0
               endmatch;
               flx = flx.[p1 to];
               var p2 = match find(flx,v1.3.string) with
               | Some ?i => i
               | None => flx.len.int - 1
               endmatch;
               flx = flx.[to p2];
            elif matched2 do
              var re3 = RE2(v2.2.string);
              var matched3 = Match(re3,StringPiece(flx),0,UNANCHORED,v3.stl_begin, v3.len.int);
              if matched3 do
                flx = v3.1.string;
              done
            done
            needs_mathjax', html := xlat_felix (flx,"");
            needs_mathjax |= needs_mathjax';
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(html);
            write_string("</pre>"); 
          };
          s=doc;
        elif prefix (b,"flx-and-expect ") do 
          {
            fname := strip(b.[15 to]);
            var flx = get_flx(fname+".flx");
            needs_mathjax', html := xlat_felix (flx,"");
            needs_mathjax |= needs_mathjax';
            write_string("<pre class='inclusion'>"+fname+".flx</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(html);
            write_string("</pre>\n");
            heading.add_button fname;
            write_string(heading.tree_button(fname,fname+"_d"));
            write_string("<code class='inclusion'>  "+fname+".expect</code>\n");
            var xpected = get_flx(fname+".expect");
            write_string("<pre id='"+fname+"_d' class='expected' style='display:none'>"); 
            write_string(xpected);
            write_string("</pre>"); 
          };
          s=doc;
          elif b == "c++" do s = cpp;
          elif prefix (b,"c++") do 
          {
            fname := strip(b.[6 to]);
            var flx = get_flx(fname);
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='cppbg'>"); 
            write_string((xlat_cpp (flx,"")).1);
            write_string("</pre>"); 
          };
          s=doc;
        elif b=="p" do bp; s=doc;
        elif b=="pre" do s = pre; 
        elif b=="obsolete" do ep; sp 'obsolete'; write_string("<em>Obsolete</em> "); s=doc;
        elif b=="caveat" do ep; sp 'caveat'; write_string("<em>Caveat: </em> "); s=doc;
        elif b=="impl" do ep; sp 'implementation_detail'; write_string("<em>Implementation Detail: </em>"); s=doc;
        elif b=="future" do ep; sp 'future'; write_string("<em>In future: </em>"); s=doc;
        elif b=="note" do ep; sp 'bug'; write_string("<em>Note: </em>"); s=doc;
        elif b=="bug" do ep; sp 'bug'; write_string("<em>Bug: </em>"); s=doc;
        elif b=="fixed" do ep; sp 'fixed'; write_string("<em>Fixed: </em>"); s=doc;
        elif b=="done" do ep; sp 'done'; write_string("<em>Done: </em>"); s=doc;

        elif prefix(b,"h1") do h(1,b.[3 to]); 
        elif prefix(b,"h2") do h(2,b.[3 to]); 
        elif prefix(b,"h3") do h(3,b.[3 to]);
        elif prefix(b,"h4") do h(4,b.[3 to]);
        elif prefix(b,"link") do 
          var e = split_first(b.[5 to],"|");
          var f = if e.(1) == ""then e else split_first(e.(1),"|") endif;
          write_string("<a href='"+strip(e.(0))+"'"+
              (if f.(1) == "" then "" else "style='"+f.(1)+"'" endif)+">"+
              (if endswith f.(0) ".fdoc" then f.(0).[to (f.(0).len - size(5)) ]
               else f.(0) endif)+"</a> ");
          s = doc;
        elif prefix(b,"image") do 
          var img = split_first(b.[6 to],"|");
          write_string("<img src='"+img.(0)+"' style='"+img.(1)+"'></img>");
        elif prefix(b,"sh") do 
          var cmd = b.[3 to];
          var fout = safer_popen(cmd);
          if valid fout do
            var output = load fout;
            var result = Process::pclose fout; 
            println$ "Ran cmd=" + cmd;
            //println$ "Output = " + output;
            write_string output;
          else
            println$ "Unable to run command '" + cmd "'";
            write_string("Failed cmd: " + b);
          done
          s=doc;
        elif slideshow.check-slide-commands b do
          s = doc;
        else s = doc;
        done
      done
      b = "";
      goto nextc;
    }
  endmatch
  ; // execute selected function
  println$ "Unexpected drop thru";

fin:>
//   println "outof data";
   if b != "" do write_string(match s with | doc => markdown b | _ => b endmatch); done
   ep;
   heading.finalise;
   write_string #(fileseq.shownav);
   slideshow.finalise;
   return needs_mathjax, #(heading.emit-nav) + out;
}
}

println$ "fdoc2html initialisation";

fun setup(config_data:string) = {
  var config_lines = split(config_data, "\n");
  config_lines = map (strip of (string)) config_lines; 
  var pathext = RE2("(.*)\\+=(.*)");
  var varset = RE2("(.*)=(.*)");
  var plugin_spec = RE2 " *extension (.*)->(.*)::(.*)";

  var result = varray[StringPiece] (4.size,StringPiece(""));
  for line in config_lines do
    var match_result = Match(pathext, StringPiece(line),0,ANCHOR_BOTH, result.stl_begin,3);
    if match_result do
      var lhs = result.1.str.strip;
      var rhs = result.2.str.strip;
      match lhs with
      | "FLX_PATH" => FLX_PATH += rhs; 
      | "FDOC_PATH" => FDOC_PATH += rhs; 
      | "FLX_PKGCONFIG_PATH" => FLX_PKGCONFIG_PATH += rhs;
      | "FLX_WEBSERVER_PLUGIN_PATH" => FLX_WEBSERVER_PLUGIN_PATH += rhs;
      | _ => ;
      endmatch;
    else
    match_result = Match(varset, StringPiece(line),0,ANCHOR_BOTH, result.stl_begin,3);
    if match_result do
      lhs = result.1.str.strip;
      rhs = result.2.str.strip;
      match lhs with
      | "INSTALL_ROOT" => INSTALL_ROOT = rhs;
      | _ => ;
      endmatch;
    else
    match_result = Match(plugin_spec, StringPiece(line),0,ANCHOR_BOTH, result.stl_begin,4);
    if match_result do
      var extn = result.1.str.strip;
      var lib = result.2.str.strip;
      var entry = result.3.str.strip;
      PLUGIN_MAP = Cons ((extn, lib, entry), PLUGIN_MAP);
    done done done
  done

  // Load Plugins.
  typedef libmap_entry = string * Dynlink::flx_instance;
  var libs = Empty[libmap_entry];
  fun have_lib (k:string) => Assoc_list::mem (== of (string * string)) libs k;
  var dll_extn = #Config::config.EXT_SHLIB;

  for d in PLUGIN_MAP do 
    match d with 
    | ?ext,?lib,?entry =>
      if not (have_lib lib) do
        if lib in list("flx2html", "cpp2html") do
//println$ "Adding lib " + lib;
          var linst = Dynlink::init_lib(lib + dll_extn);
          var sresult = Dynlink::func1[int,string] (linst, "setup") config_data;
          C_hack::ignore(sresult);
println$ lib+ " Library set up " + str sresult;
          libs = Cons ((lib, linst),libs); 
          match lib with
          | "flx2html" => 
            xlat_felix = Dynlink::func2[bool * string, string, string](linst,"xlat_felix");
          | "cpp2html" => 
            xlat_cpp = Dynlink::func2[bool * string, string, string](linst,"xlat_cpp");
          endmatch;
        done
      done 
    endmatch;
  done

  // paragraph plugin
  linst = Dynlink::init_lib("fdoc-paragraph"+ dll_extn);
  sresult = Dynlink::func1[int,string] (linst, "setup") ("HELLO PARAGRAPH");
  C_hack::ignore(sresult);
  println$ "paragraph Library set up " + str sresult;
  paragraph-maker = Dynlink::func1[paragraph-control_t,string->0] (linst, "create_paragraph_manager");

  // heading plugin
  linst = Dynlink::init_lib("fdoc-heading"+ dll_extn);
  sresult = Dynlink::func1[int,string] (linst, "setup") ("HELLO HEADING");
  C_hack::ignore(sresult);
  println$ "heading Library set up " + str sresult;
  heading-maker = Dynlink::func2[heading-control_t, paragraph-control_t, string->0] (linst, "create_heading_manager");

  // fileseq plugin
  linst = Dynlink::init_lib("fdoc-fileseq"+ dll_extn);
  sresult = Dynlink::func1[int,string] (linst, "setup") ("HELLO FILESEQ");
  C_hack::ignore(sresult);
  println$ "fileseq Library set up " + str sresult;
  fileseq-maker = Dynlink::func1[fileseq-control_t, string] (linst, "create_fileseq_manager");

  // slideshow plugin
  linst = Dynlink::init_lib("fdoc-slideshow"+ dll_extn);
  sresult = Dynlink::func1[int,string] (linst, "setup") ("HELLO SLIDESHOW");
  C_hack::ignore(sresult);
  println$ "slideshow Library set up " + str sresult;
  slideshow-maker = Dynlink::func1[slideshow_t,string->0] (linst, "create_slideshow_manager");

  return 0;
}

export fun setup of (string) as "setup";
export fun Fdoc2Html::xlat_fdoc of (string * string) as "xlat_fdoc";


