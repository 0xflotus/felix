// felix document
include "std/posix/process";

module Fdoc2Html {

proc boreq(l:&bool, r:bool) { l <- *l or r; } 

val markdown_code = RE2 ("({([^}]*)})");
fun markdown (s:string):string= {
  var x = s;
  C_hack::ignore(GlobalReplace(&x, markdown_code, StringPiece ("<code>\\2</code>")));
  return x;
}

val js1 = 
"""
<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
""";
val js2 =
"""
];
function expand_all()
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all()
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>
""";
val nav = '<p><button type="button" onclick="expand_all()">Expand</button>'
   '&nbsp;<button type="button" onclick="collapse_all()">Collapse</button> </p>'
;

// bid is the button id, cid is the stuff which is controlled by it
fun tree_button(bid:string, cid:string)=>
  "<img src='/web/images/minus.gif' id='"+bid+"' onclick='toggle(this,\""+cid+"\")' alt='+'/>"
;
val timeout = Filename::join (#Config::config.FLX_INSTALL_DIR, "bin", "timeout"+#Config::config.EXT_EXE);

gen safer_popen(cmd:string)=>
  Process::popen_in(timeout+" -t 15 " + cmd + " 2>&1")
;

fun xlat_fdoc(t:string, filename:string): bool * string =
{

  var needs_mathjax = false;
  fun cal_nav() = 
  {
    val relfile = match (filename,'/').split.rev with | Cons(?h,_) => h | Empty => "";
    var lpos = relfile.len.int;
    while lpos > 0 and not isdigit(relfile.[lpos - 1]) do 
       --lpos; 
    done 
    assert lpos == 0 or relfile.[lpos - 1].isdigit;
    var fpos = lpos;
    while fpos > 0 and isdigit(relfile.[fpos - 1]) do --fpos; done 
    assert fpos == 0 or relfile.[fpos].isdigit;
    val digits = 
      if fpos >=0 and lpos > fpos then
        relfile.[fpos to lpos]
      else ""
    ;

    val n = digits.len.int;
    val v = digits.int;
    val vnext = v + 1;
    val vprev = v - 1;
    var snext = (f"%010d" vnext).[10-n to];
    var sprev= (f"%010d" vprev).[10-n to];

    snext = relfile.[to fpos] + snext + relfile.[lpos to];
    sprev = relfile.[to fpos] + sprev + relfile.[lpos to];
    docindex := relfile.[to fpos] + "index" + relfile.[lpos to];

    return
      if digits == "" then 
        None[int],None[string],None[string],docindex
      elif vprev > 0 then 
        Some v,Some sprev, Some snext,docindex
      else
        Some v,None[string], Some snext,docindex
    ;
  }

  var all_buttons = "";

  var out = "";
  proc write_string(t:string) 
  { 
    out += t;
  }

  proc shownav() {
    write_string (
       match cal_nav() with
       | _,Some ?sprev, Some ?snext, ?docindex => "<a href='"+sprev+"'>Prev</a>  " +  "<a href='"+snext+"'>Next</a> " + "<a href='"+docindex+"'>Index</a>"
       | _,None, Some ?snext, ?docindex => "<a href='"+snext+"'>Next</a> "+"<a href='"+docindex+"'>Index</a>" 
       | _,None, None,_ => ""
     );
  }
  fun docnum()=>
    match cal_nav() with
    | None,_,_,_ => ""
    | Some ?v,_,_,_ => str v + "."
  ; 

  shownav();

  union state_t = 
    | cmd // processing command
    | doc // processing document
    | felix // processing felix code
    | cpp // processing C/C++ code
    | pre // processing pre-formatted code
    | flx_and_expect // processing felix code and expect file
  ;
  fun str(s:state_t) => match s with
  | doc => "doc"
  | felix => "felix"
  | cpp => "c++"
  | pre => "preforma"
  | flx_and_expect => "flx-and-expect"
  | cmd => "cmd"
  endmatch;
  
  var i = 0; var s:state_t=doc;
  var ch = char "\n";
  var sol = true;
  proc next() { sol = ch == char "\n"; ch = t.[i]; ++i; }
  fun ahead (j:int)=> t.[i + j -1]; 
  var b = "";
  proc cp() { b += ch; }


  // paragraph control
  var pstate = false;
  proc start_p () { write_string("<p>"); pstate=true; }
  proc end_p () { write_string("</p>"); pstate=false; }
  proc break_p () { write_string("</p><p>"); }
  proc sp() { if not pstate do start_p; done }
  proc ep() { if pstate do end_p; done }
  proc bp() { if pstate do end_p; done start_p; }

  // heading control
  var hstack = 0; // number of open <div>s
  var hnums = varray[int] (size 5,1); 
  proc edivs(n:int) { 
    while hstack > n do 
      write_string("</div>"); 
      --hstack;
      set (&hnums,hstack,1);
     done
     if hstack == n do
       --hstack;
       write_string("</div>"); 
       set(&hnums,hstack,hnums.[hstack]+1); 
     done
  }
  fun hnum() = {
    var s = ""; var i:int;
    for i in 0 upto hstack - 2 do
      s+=str(hnums.[i]) + ".";
    done
    return s + str(hnums.[hstack - 1]);
  } 
  proc h(n:int, txt:string) { 
    ep; 
    edivs(n); 
    all_buttons =if all_buttons != "" then all_buttons+',\n' else '' endif + '"' + txt + '"';
    tb:=tree_button(txt,txt+"_d");
    ++hstack;
    write_string("<h"+str n+">"+tb+" "+docnum()+hnum()+" "+ txt+"</h"+str n+"><div id='"+txt+"_d' style='display:block'>\n"); 
    s=doc;
  }
 
nextc:>
  next();
  if isnull ch goto fin; // out of data
  match s with 
  | doc =>
    { 
      if sol and char "@" == ch do 
        if b != "" do sp; write_string(markdown b); ep; done
        s = cmd; b="";
      elif char "\n" == ch and char "\n" == ahead(1) do 
        sp; write_string(markdown b); ep;
        b="";
      else cp; 
      done
      goto nextc;
    }
  | pre =>
    { 
      if sol and char "@" == ch  do 
        if b != "" do 
          sp; 
          write_string("<pre>"); 
          write_string(txt2html b); 
          write_string("</pre>"); 
          ep;
        done
        s = cmd; b="";
      else cp; 
      done
      goto nextc;
    }

  | cpp =>
    { 
      if sol and char "@" == ch do 
        if b != "" do 
          write_string("<pre class='cppbg'>"); 
          write_string(Cpp2Html::xlat_cpp (b,"")); // no parent!
          write_string("</pre>"); 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | felix =>
    { 
      if sol and char "@" == ch do 
        if b != "" do 
          write_string("<pre class='flxbg'>"); 
          needs_mathjax', txt := Flx2Html::xlat_felix (b,"");
          needs_mathjax |= needs_mathjax';
          write_string(txt); // no parent!
          write_string("</pre>"); 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | cmd => 
    {
      if char "\n" != ch do cp; goto nextc;
      else
        if b == "felix" do s = felix;
        elif prefix (b,"felix ") do 
          {
            fname := strip(b.[6 to]);
            var flx = get_flx(fname);
            needs_mathjax', html := Flx2Html::xlat_felix (flx,"");
            needs_mathjax |= needs_mathjax';
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(html);
            write_string("</pre>"); 
          };
          s=doc;
        elif prefix (b,"flx-and-expect ") do 
          {
            fname := strip(b.[15 to]);
            var flx = get_flx(fname+".flx");
            needs_mathjax', html := Flx2Html::xlat_felix (flx,"");
            needs_mathjax |= needs_mathjax';
            write_string("<pre class='inclusion'>"+fname+".flx</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(html);
            write_string("</pre>\n");
            all_buttons = if all_buttons != "" then all_buttons + ',' else '' endif + '"' + fname + '"';
            write_string(tree_button(fname,fname+"_d"));
            write_string("<code class='inclusion'>  "+fname+".expect</code>\n");
            var xpected = get_flx(fname+".expect");
            write_string("<pre id='"+fname+"_d' class='expected' style='display:none'>"); 
            write_string(xpected);
            write_string("</pre>"); 
          };
          s=doc;
          elif b == "c++" do s = cpp;
          elif prefix (b,"c++") do 
          {
            fname := strip(b.[6 to]);
            var flx = get_flx(fname);
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='cppbg'>"); 
            write_string(Cpp2Html::xlat_cpp (flx,""));
            write_string("</pre>"); 
          };
          s=doc;
        elif b=="pre" do s = pre; 
        elif b=="obsolete" do ep; pstate=true; write_string("<p class='obsolete'> <em>Obsolete</em> "); s=doc;
        elif b=="caveat" do ep; pstate=true; write_string("<p class='caveat'> <em>Caveat: </em> "); s=doc;
        elif b=="impl" do ep; pstate=true; write_string("<p class='implementation_detail'> <em>Implementation Detail: </em>"); s=doc;
        elif b=="future" do ep; pstate=true; write_string("<p class='future'> <em>In future: </em>"); s=doc;
        elif b=="bug" do ep; pstate=true; write_string("<p class='bug'> <em>Bug: </em>"); s=doc;
        elif b=="fixed" do ep; pstate=true; write_string("<p class='fixed'> <em>Fixed: </em>"); s=doc;
        elif b=="done" do ep; pstate=true; write_string("<p class='done'> <em>Done: </em>"); s=doc;
        elif prefix(b,"h1") do h(1,b.[3 to]); 
        elif prefix(b,"h2") do h(2,b.[3 to]); 
        elif prefix(b,"h3") do h(3,b.[3 to]);
        elif prefix(b,"h4") do h(4,b.[3 to]);
        elif prefix(b,"sh") do 
          var cmd = b.[3 to];
          var fout = safer_popen(cmd);
          if valid fout do
            var output = load fout;
            var result = Process::pclose fout; 
            println$ "Ran cmd=" + cmd;
            //println$ "Output = " + output;
            write_string output;
          else
            println$ "Unable to run command '" + cmd "'";
            write_string("Failed cmd: " + b);
          done
          s=doc;
        else s = doc;
        done
      done
      b = "";
      goto nextc;
    }
  endmatch
  ; // execute selected function
  println$ "Unexpected drop thru";

fin:>
//   println "outof data";
   if b != "" do write_string(match s with | doc => markdown b | _ => b endmatch); done
   ep;
   edivs(1);
   shownav();
   return needs_mathjax, js1+all_buttons +js2+nav+out;
}
}
