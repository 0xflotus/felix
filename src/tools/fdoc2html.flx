include "./charclass";
include "./plugin_common";

// felix document
include "std/posix/process";
var INSTALL_ROOT="";
var FLX_PATH = Empty[string];
var FDOC_PATH = Empty[string];
var FLX_PKGCONFIG_PATH = Empty[string];
var FLX_WEBSERVER_PLUGIN_PATH = Empty[string];
var PLUGIN_MAP = Empty[string^3];


fun get_flx (fname:string) = {
  var flx =
    match get_file(fname,INSTALL_ROOT,FLX_PATH) with
    | Some ?name => load(name)
    | None => f"NO FILE %S FOUND IN %S" (fname, str FLX_PATH)
    endmatch
  ;
  println$ "Loaded felix file " + fname+", len="+str (flx.len.int);
  return flx;
}

// fixup text by replacing < > and & characters
fun txt2html (x:string) =
{
  var out2 = "";
  for var i in 0 upto x.len.int - 1 do
    var ch = x.[i];
    if ch == char "<" do out2+="&lt;";
    elif ch == char ">" do out2+="&gt;";
    elif ch == char "&" do out2+="&amp;";
    else out2+=ch;
    done
  done

  return out2;
}


typedef raw_xlat_t = address * string * string --> bool * string;

var xlat_felix: raw_xlat_t;
var xlat_cpp: raw_xlat_t;

var tf_xlat_felix: address;
var tf_xlat_cpp: address;


module Fdoc2Html {

proc boreq(l:&bool, r:bool) { l <- *l or r; } 

val markdown_code = RE2 ("({([^}]*)})");
fun markdown (s:string):string= {
  var x = s;
  C_hack::ignore(GlobalReplace(&x, markdown_code, StringPiece ("<code>\\2</code>")));
  return x;
}

val js1 = 
"""
<script type="text/javascript">

function expand(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/web/images/minus.gif";
  button.alt = "-";
  n.display = "block";
}
function collapse(but,id)
{
  var n = document.getElementById(id).style;
  var button = document.getElementById(but);
  button.src = "/web/images/plus.gif";
  button.alt = "+";
  n.display = "none";
}
function toggle(button,id)
{
  var n = document.getElementById(id).style;
  if (n.display == "none")
  {
    button.src = "/web/images/minus.gif";
    button.alt = "-";
    n.display = "block";
  }
  else
  {
    button.src = "/web/images/plus.gif";
    button.alt = "+";
    n.display = "none";
  }
}
var allbuttons = [
""";
val js2 =
"""
];
function expand_all()
{
  for (i in allbuttons)
  {
    expand(allbuttons[i], allbuttons[i]+"_d");
  }
}
function collapse_all()
{
  for (i in allbuttons)
  {
    collapse(allbuttons[i], allbuttons[i]+"_d");
  }
}
</script>
""";
val nav = '<p><button type="button" onclick="expand_all()">Expand</button>'
   '&nbsp;<button type="button" onclick="collapse_all()">Collapse</button> </p>'
;

// bid is the button id, cid is the stuff which is controlled by it
fun tree_button(bid:string, cid:string)=>
  "<img src='/web/images/minus.gif' id='"+bid+"' onclick='toggle(this,\""+cid+"\")' alt='+'/>"
;
val timeout = Filename::join (#Config::config.FLX_INSTALL_DIR, "bin", "timeout"+#Config::config.EXT_EXE);

gen safer_popen(cmd:string)=>
  Process::popen_in(timeout+" -t 15 " + cmd + " 2>&1")
;

fun xlat_fdoc(t:string, filename:string): bool * string =
{

  var needs_mathjax = false;
  fun cal_nav() = 
  {
    val relfile = match (filename,'/').split.rev with | Cons(?h,_) => h | Empty => "";
    var lpos = relfile.len.int;
    while lpos > 0 and not isdigit(relfile.[lpos - 1]) do 
       --lpos; 
    done 
    assert lpos == 0 or relfile.[lpos - 1].isdigit;
    var fpos = lpos;
    while fpos > 0 and isdigit(relfile.[fpos - 1]) do --fpos; done 
    assert fpos == 0 or relfile.[fpos].isdigit;
    val digits = 
      if fpos >=0 and lpos > fpos then
        relfile.[fpos to lpos]
      else ""
    ;

    val n = digits.len.int;
    val v = digits.int;
    val vnext = v + 1;
    val vprev = v - 1;
    var snext = (f"%010d" vnext).[10-n to];
    var sprev= (f"%010d" vprev).[10-n to];

    snext = relfile.[to fpos] + snext + relfile.[lpos to];
    sprev = relfile.[to fpos] + sprev + relfile.[lpos to];
    docindex := relfile.[to fpos] + "index" + relfile.[lpos to];

    return
      if digits == "" then 
        None[int],None[string],None[string],docindex
      elif vprev > 0 then 
        Some v,Some sprev, Some snext,docindex
      else
        Some v,None[string], Some snext,docindex
    ;
  }

  var all_buttons = "";

  var out = "";
  proc write_string(t:string) 
  { 
    out += t;
  }

  proc shownav() {
    write_string (
       match cal_nav() with
       | _,Some ?sprev, Some ?snext, ?docindex => "<a href='"+sprev+"'>Prev</a>  " +  "<a href='"+snext+"'>Next</a> " + "<a href='"+docindex+"'>Index</a>"
       | _,None, Some ?snext, ?docindex => "<a href='"+snext+"'>Next</a> "+"<a href='"+docindex+"'>Index</a>" 
       | _,None, None,_ => ""
     );
  }
  fun docnum()=>
    match cal_nav() with
    | None,_,_,_ => ""
    | Some ?v,_,_,_ => str v + "."
  ; 

  shownav();

  union state_t = 
    | cmd // processing command
    | doc // processing document
    | felix // processing felix code
    | cpp // processing C/C++ code
    | pre // processing pre-formatted code
    | flx_and_expect // processing felix code and expect file
  ;
  fun str(s:state_t) => match s with
  | doc => "doc"
  | felix => "felix"
  | cpp => "c++"
  | pre => "preforma"
  | flx_and_expect => "flx-and-expect"
  | cmd => "cmd"
  endmatch;
  
  var i = 0; var s:state_t=doc;
  var ch = char "\n";
  var sol = true;
  proc next() { sol = ch == char "\n"; ch = t.[i]; ++i; }
  fun ahead (j:int)=> t.[i + j -1]; 
  var b = "";
  proc cp() { b += ch; }


  // paragraph control
  var pstate = false;
  proc start_p () { write_string("<p>"); pstate=true; }
  proc end_p () { write_string("</p>"); pstate=false; }
  proc break_p () { write_string("</p><p>"); }
  proc sp() { if not pstate do start_p; done }
  proc ep() { if pstate do end_p; done }
  proc bp() { if pstate do end_p; done start_p; }

  // heading control
  var hstack = 0; // number of open <div>s
  var hnums = varray[int] (size 5,1); 
  proc edivs(n:int) { 
    while hstack > n do 
      write_string("</div>"); 
      --hstack;
      set (hnums,hstack,1);
     done
     if hstack == n do
       --hstack;
       write_string("</div>"); 
       set(hnums,hstack,hnums.hstack+1); 
     done
  }
  fun hnum() = {
    var s = ""; var i:int;
    for i in 0 upto hstack - 2 do
      s+=str(hnums.i) + ".";
    done
    return s + str(hnums.(hstack - 1));
  } 
  proc h(n:int, txt:string) { 
    ep; 
    edivs(n); 
    all_buttons =if all_buttons != "" then all_buttons+',\n' else '' endif + '"' + txt + '"';
    tb:=tree_button(txt,txt+"_d");
    ++hstack;
    write_string("<h"+str n+">"+tb+" "+docnum()+hnum()+" "+ txt+"</h"+str n+"><div id='"+txt+"_d' style='display:block'>\n"); 
    s=doc;
  }
 
nextc:>
  next();
  if isnull ch goto fin; // out of data
  match s with 
  | doc =>
    { 
      if sol and char "@" == ch do 
        if b != "" do sp; write_string(markdown b); ep; done
        s = cmd; b="";
      elif char "\n" == ch and char "\n" == ahead(1) do 
        sp; write_string(markdown b); ep;
        b="";
      else cp; 
      done
      goto nextc;
    }
  | pre =>
    { 
      if sol and char "@" == ch  do 
        if b != "" do 
          sp; 
          write_string("<pre>"); 
          write_string(txt2html b); 
          write_string("</pre>"); 
          ep;
        done
        s = cmd; b="";
      else cp; 
      done
      goto nextc;
    }

  | cpp =>
    { 
      if sol and char "@" == ch do 
        if b != "" do 
          write_string("<pre class='cppbg'>"); 
          write_string((xlat_cpp (tf_xlat_cpp,b,"")).1); // no parent!
          write_string("</pre>"); 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | felix =>
    { 
      if sol and char "@" == ch do 
        if b != "" do 
          write_string("<pre class='flxbg'>"); 
          needs_mathjax', txt := xlat_felix (tf_xlat_felix,b,"");
          needs_mathjax |= needs_mathjax';
          write_string(txt); // no parent!
          write_string("</pre>"); 
          b= ""; 
        done
        s = cmd;
      else cp; 
      done
      goto nextc;
    }

  | cmd => 
    {
      if char "\n" != ch do cp; goto nextc;
      else
        if b == "felix" do s = felix;
        elif prefix (b,"felix ") do 
          {
            var rest = strip(b.[6 to]);
            var re1 = RE2('(.*) "(.*)" "(.*)"');
            var re2 = RE2('(.*) "(.*)"');
            var v1 = varray(4uz, StringPiece "");
            var v2 = varray(4uz, StringPiece "");
            var v3 = varray(4uz, StringPiece "");
            var matched1 = Match(re1, StringPiece(rest),0,ANCHOR_BOTH,v1.stl_begin, v1.len.int);
            var matched2 = Match(re2, StringPiece(rest),0,ANCHOR_BOTH,v2.stl_begin, v2.len.int);
            if matched1 do
              var fname = v1.1.string.strip;
            elif matched2 do
              fname = v2.1.string.strip;
            else
              fname = rest;
            done
            var flx = get_flx(fname);
            if matched1 do
               var p1 = match find(flx,v1.2.string) with
               | Some ?i => i
               | None => 0
               endmatch;
               flx = flx.[p1 to];
               var p2 = match find(flx,v1.3.string) with
               | Some ?i => i
               | None => flx.len.int - 1
               endmatch;
               flx = flx.[to p2];
            elif matched2 do
              var re3 = RE2(v2.2.string);
              var matched3 = Match(re3,StringPiece(flx),0,UNANCHORED,v3.stl_begin, v3.len.int);
              if matched3 do
                flx = v3.1.string;
              done
            done
            needs_mathjax', html := xlat_felix (tf_xlat_felix,flx,"");
            needs_mathjax |= needs_mathjax';
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(html);
            write_string("</pre>"); 
          };
          s=doc;
        elif prefix (b,"flx-and-expect ") do 
          {
            fname := strip(b.[15 to]);
            var flx = get_flx(fname+".flx");
            needs_mathjax', html := xlat_felix (tf_xlat_felix,flx,"");
            needs_mathjax |= needs_mathjax';
            write_string("<pre class='inclusion'>"+fname+".flx</pre>\n");
            write_string("<pre class='flxbg'>"); 
            write_string(html);
            write_string("</pre>\n");
            all_buttons = if all_buttons != "" then all_buttons + ',' else '' endif + '"' + fname + '"';
            write_string(tree_button(fname,fname+"_d"));
            write_string("<code class='inclusion'>  "+fname+".expect</code>\n");
            var xpected = get_flx(fname+".expect");
            write_string("<pre id='"+fname+"_d' class='expected' style='display:none'>"); 
            write_string(xpected);
            write_string("</pre>"); 
          };
          s=doc;
          elif b == "c++" do s = cpp;
          elif prefix (b,"c++") do 
          {
            fname := strip(b.[6 to]);
            var flx = get_flx(fname);
            write_string("<pre class='inclusion'>\n"+fname+"</pre>\n");
            write_string("<pre class='cppbg'>"); 
            write_string((xlat_cpp (tf_xlat_cpp,flx,"")).1);
            write_string("</pre>"); 
          };
          s=doc;
        elif b=="pre" do s = pre; 
        elif b=="obsolete" do ep; pstate=true; write_string("<p class='obsolete'> <em>Obsolete</em> "); s=doc;
        elif b=="caveat" do ep; pstate=true; write_string("<p class='caveat'> <em>Caveat: </em> "); s=doc;
        elif b=="impl" do ep; pstate=true; write_string("<p class='implementation_detail'> <em>Implementation Detail: </em>"); s=doc;
        elif b=="future" do ep; pstate=true; write_string("<p class='future'> <em>In future: </em>"); s=doc;
        elif b=="note" do ep; pstate=true; write_string("<p class='bug'> <em>Note: </em>"); s=doc;
        elif b=="bug" do ep; pstate=true; write_string("<p class='bug'> <em>Bug: </em>"); s=doc;
        elif b=="fixed" do ep; pstate=true; write_string("<p class='fixed'> <em>Fixed: </em>"); s=doc;
        elif b=="done" do ep; pstate=true; write_string("<p class='done'> <em>Done: </em>"); s=doc;
        elif prefix(b,"h1") do h(1,b.[3 to]); 
        elif prefix(b,"h2") do h(2,b.[3 to]); 
        elif prefix(b,"h3") do h(3,b.[3 to]);
        elif prefix(b,"h4") do h(4,b.[3 to]);
        elif prefix(b,"sh") do 
          var cmd = b.[3 to];
          var fout = safer_popen(cmd);
          if valid fout do
            var output = load fout;
            var result = Process::pclose fout; 
            println$ "Ran cmd=" + cmd;
            //println$ "Output = " + output;
            write_string output;
          else
            println$ "Unable to run command '" + cmd "'";
            write_string("Failed cmd: " + b);
          done
          s=doc;
        else s = doc;
        done
      done
      b = "";
      goto nextc;
    }
  endmatch
  ; // execute selected function
  println$ "Unexpected drop thru";

fin:>
//   println "outof data";
   if b != "" do write_string(match s with | doc => markdown b | _ => b endmatch); done
   ep;
   edivs(1);
   shownav();
   return needs_mathjax, js1+all_buttons +js2+nav+out;
}
}

println$ "fdoc2html initialisation";

fun setup(config_data:string) = {
  var config_lines = split(config_data, "\n");
  config_lines = map (strip of (string)) config_lines; 
  var pathext = RE2("(.*)\\+=(.*)");
  var varset = RE2("(.*)=(.*)");
  var plugin_spec = RE2 " *extension (.*)->(.*)::(.*)";

  var result = varray[StringPiece] (4.size,StringPiece(""));
  for line in config_lines do
    var match_result = Match(pathext, StringPiece(line),0,ANCHOR_BOTH, result.stl_begin,3);
    if match_result do
      var lhs = result.1.str.strip;
      var rhs = result.2.str.strip;
      match lhs with
      | "FLX_PATH" => FLX_PATH += rhs; 
      | "FDOC_PATH" => FDOC_PATH += rhs; 
      | "FLX_PKGCONFIG_PATH" => FLX_PKGCONFIG_PATH += rhs;
      | "FLX_WEBSERVER_PLUGIN_PATH" => FLX_WEBSERVER_PLUGIN_PATH += rhs;
      | _ => ;
      endmatch;
    else
    match_result = Match(varset, StringPiece(line),0,ANCHOR_BOTH, result.stl_begin,3);
    if match_result do
      lhs = result.1.str.strip;
      rhs = result.2.str.strip;
      match lhs with
      | "INSTALL_ROOT" => INSTALL_ROOT = rhs;
      | _ => ;
      endmatch;
    else
    match_result = Match(plugin_spec, StringPiece(line),0,ANCHOR_BOTH, result.stl_begin,4);
    if match_result do
      var extn = result.1.str.strip;
      var lib = result.2.str.strip;
      var entry = result.3.str.strip;
      PLUGIN_MAP = Cons ((extn, lib, entry), PLUGIN_MAP);
    done done done
  done

  // Load Plugins.
  typedef libmap_entry = string * Dynlink::flx_instance;
  var libs = Empty[libmap_entry];
  fun have_lib (k:string) => Assoc_list::mem (== of (string * string)) libs k;
  var dll_extn = #Config::config.EXT_SHLIB;

  for d in PLUGIN_MAP do 
    match d with 
    | ?ext,?lib,?entry =>
      if not (have_lib lib) do
        if lib in list("flx2html", "cpp2html") do
//println$ "Adding lib " + lib;
          var linst = Dynlink::init_lib(lib + dll_extn);
          var library = Dynlink::get_library linst;
          var tf = Dynlink::get_thread_frame linst;
          var raw_setup = Dynlink::dlsym$ library, "setup";
//println$ lib+ " Got setup address " + str raw_setup;
          var setup = C_hack::cast[address * string --> int] raw_setup;
          var sresult = setup(tf,config_data);
println$ lib+ " Library set up " + str sresult;
          libs = Cons ((lib, linst),libs); 
          match lib with
          | "flx2html" => 
            xlat_felix = C_hack::cast[raw_xlat_t]$ Dynlink::dlsym (library,entry);
            tf_xlat_felix = tf;
          | "cpp2html" => 
            xlat_cpp= C_hack::cast[raw_xlat_t]$ Dynlink::dlsym (library,entry);
            tf_xlat_cpp = tf;
          endmatch;
        done
      done 
    endmatch;
  done

  return 0;
}

export fun setup of (string) as "setup";
export fun Fdoc2Html::xlat_fdoc of (string * string) as "xlat_fdoc";


