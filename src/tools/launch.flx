include "std/posix/__init__";

// get the prefix of the executables from the command line
var exec_prefix = System::argv 1;

// the executables with any arguments
version := list$ exec_prefix+"version";

hwclient := list$ exec_prefix+"hwclient";
hwserver := list$ exec_prefix+"hwserver";

wuclient := list$ exec_prefix+"wuclient";
wuserver := list$ exec_prefix+"wuserver";
wuproxy  := list$ exec_prefix+"wuproxy";

mspoller := list$ exec_prefix+"mspoller";
msreader := list$ exec_prefix+"msreader";

rrbroker := list$ exec_prefix+"rrbroker";
rrclient := list$ exec_prefix+"rrclient";
rrserver := list$ exec_prefix+"rrserver";

mtclient := list$ exec_prefix+"mtclient";
mtserver := list$ exec_prefix+"mtserver";
mtrelay  := list$ exec_prefix+"mtrelay";

tasksink := list$ exec_prefix+"tasksink";
taskvent := list$ exec_prefix+"taskvent";
taskwork := list$ exec_prefix+"taskwork";
taskwork2 := list$ exec_prefix+"taskwork2";
tasksink2 := list$ exec_prefix+"tasksink2";


// multi-process test groups
group1 := 
  "http://zguide.zeromq.org/page:all#Ask-and-Ye-Shall-Receive",
  list( ("hwserver",hwserver), ("hwclient",hwclient))
;


group2 := 
  "http://zguide.zeromq.org/page:all#Version-Reporting",
  list (("version",version))
;

group3 :=
  "http://zguide.zeromq.org/page:all#Getting-the-Message-Out",
  list (
    ("wuserver",wuserver), 
    ("wuclient1",wuclient), ("wuclient2",wuclient), ("wuclient3",wuclient)
  )
;

group4 :=
  "http://zguide.zeromq.org/page:all#Divide-and-Conquer",
  list (
    ("taskvent",taskvent), 
    ("taskwork1",taskwork), ("taskwork2",taskwork), ("taskwork3",taskwork), 
    ("tasksink",tasksink)
  )
;

group5 :=
  "http://zguide.zeromq.org/page:all#Handling-Multiple-Sockets",
  list (("mspoller",mspoller), ("msreader",msreader))
;

group6 :=
  "http://zguide.zeromq.org/page:all#Handling-Errors-and-ETERM",
  list (
    ("taskvent",taskvent), 
    ("taskwork21",taskwork2), ("taskwork22",taskwork2), ("taskwork23",taskwork2), 
    ("tasksink3",tasksink2)
  )
;

group7 := 
  "http://zguide.zeromq.org/page:all#A-Publish-Subscribe-Proxy-Server",
  list (
    ("wuserver",wuserver),
    ("wuclient1",wuclient), ("wuclient2",wuclient), 
    ("wupoxy",wuproxy), 
    ("wuclient3", wuclient), 
    ("wuclient4",wuclient)
  ) 
  // NOTE: this will NOT work, because wuclient reads the wrong address
;

group8 :=
  "http://zguide.zeromq.org/page:all#A-Request-Reply-Broker",
  list (
    ("rrclient1",rrclient), ("rrclient2",rrclient), ("rrclient3",rrclient), 
    ("rrbroker", rrbroker), 
    ("rrserver1",rrserver), ("rrserver2",rrserver), ("rrserver3",rrserver)
  )
;

group9 := 
  "http://zguide.zeromq.org/page:all#Multithreading-with-MQ",
  list(("mtserver",mtserver))
;

group10 :=
  "http://zguide.zeromq.org/page:all#Signaling-between-Threads",
  list(("mtrelay",mtrelay))
;

fun pack_args(t:list[string]) = {
  var out = array_alloc[&char] t.len+1;
  var i = 0;
  for k in t do out.[i]=strdup k.cstr; ++i; done
  out.[i] = C_hack::null[char];
  return out;
}

fun make_args(p:list[string]) =>
  let Cons (?pn,_) = p in pn,pack_args p
;

open Process;

noinline proc launch_managed_process (
  port: opchannel[string], 
  name:string, 
  inargs:list[string], 
  timelimit:double) 
{
  //eprintln$ "name=" + name;
  def val pn, val outargs = make_args inargs;
  spawn_pthread { 
    start_time := #Time::time;
    eprintln$ "[" + name + "] "+"Process Monitoring pthread for " +pn+ " start at " + start_time.int.str;
    result := spawnv(pn, outargs);
    match result with
    | Error ?e =>
      eprintln$ "[" + name + "] "+"Error opening process for program " + pn + ": " +strerror e;
    | ProcessId ?pid =>
      eprintln$ "[" + name + "] "+"Process " + pid.int.str + " created for program " + pn;
    check_pid:>
      val status = checkpid(pid);
      match status with
      | Running => 
        if Time::time() - start_time > timelimit do
           C_hack::ignore$ Process::kill(pid, Posix_Signal::SIGKILL);
           eprintln$  "[" + name + "] "+"KILL: Process "+pid.int.str +" for " + pn + " exceeded time limit " + str timelimit;
        elif #get_ctrl_c do
           C_hack::ignore$ Process::kill(pid, Posix_Signal::SIGKILL);
           eprintln$  "[" + name + "] "+"KILL: Process "+pid.int.str +" for " + pn + " due to Ctrl-C";
        else
          //eprintln$ "[" + name + "] "+"Running "+ pid.int.str;
        done
        Faio::sleep(sys_clock, 2.0);
             
        goto check_pid;

      | Stopped ?status =>
        eprintln$ "[" + name + "] "+"Exit "+ pid.int.str+" status " + str status.int;
      endmatch;
    endmatch;
    eprintln$ "[" + name + "] "+"Monitoring pthread for "+pn+" done finish at " + #Time::time.int.str;
    write (port, "DEAD");
    eprintln$ "[" + name + "] "+"Signalled DEAD for "+pn;
  };
}

noinline proc funeral(port:ipchannel[string], name:string, process_count: &int)
{
  spawn_fthread { 
    assert read port == "DEAD"; 
    process_count <- *process_count - 1; 
    eprintln$ "Funeral of " + name; 
  };
}

noinline proc launch_managed_processes (inp: string * list[string * list[string]], timelimit: double) {
  desc, tinp := inp;
  eprintln desc;
  var process_count = 0;
  for k in tinp do
    name, args := k;
    eprintln$ name, args;
    def var iport, var oport = mk_iopchannel_pair[string]();
    launch_managed_process(oport, name, args, timelimit);
    ++process_count;
    funeral(iport, name, &process_count);
  done
  while process_count > 0 do Faio::sleep(sys_clock,1.0); done
  eprintln$ "Finished with group " + desc;
  eprintln$ "-" * 20;
}

//launch_managed_process ("p1proc", list("./p1"),10.0);

trap_ctrl_c;

launch_managed_processes (group1, 20.0);
launch_managed_processes (group2, 20.0);
launch_managed_processes (group3, 20.0);
launch_managed_processes (group4, 20.0);
launch_managed_processes (group5, 20.0);
launch_managed_processes (group6, 20.0);
launch_managed_processes (group7, 20.0);
launch_managed_processes (group8, 20.0);

eprintln "Mainline waiting for pthreads";

