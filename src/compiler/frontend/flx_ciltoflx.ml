(* CIL HANDLING .. MOVE ELSEWHERE *)
open Cil
open Flx_ctypes
open Flxcc_util
open Flx_ast
open List

let generated = ("Generated by desugaring",0,0,0,0)
let dfltvs_aux = { raw_type_constraint=`TYP_tuple []; raw_typeclass_reqs=[]}
let dfltvs = [],dfltvs_aux

let rpltname s = s
let rplname s = s

let litint n = match n with
| Const (CInt64 (i,_,_)) -> Int64.to_int i
| _ -> failwith "Literal integer required for array bound"

let rec ctyp_of_ciltyp t : ctype_t =
  let foc t = ctyp_of_ciltyp t in
  let foa (name,t,a) = foc t in
  match t with
  | TVoid a -> `Ct_base "void_t"
  | TInt (ik,a) -> `Ct_base (soi ik)
  | TFloat (fk,a) -> `Ct_base (sof fk)
  | TPtr (TVoid a',a) -> `Ct_base ((cvqual a')^"address")
  | TPtr (TFun _,a) -> failwith "cant do functions yet"
    (*
    let t' = typeSig t in
    begin try
      fst (Hashtbl.find stab.registry t')
    with
      Not_found ->
      let name = stab.stab_module ^"_cft_" ^ si !(stab.counter) in
      incr stab.counter;
      let sr = locUnknown in
      let t = remove_pnames t in
      let si = {tname=name;ttype=t;treferenced=true } in
      let gt =  GType (si,sr) in
      let d = defaultCilPrinter#pGlobal () gt in
      let s = Pretty.sprint 65 d in
      let s = reformatc s in
      Hashtbl.add stab.registry t' (name,s);
      name
    end
    *)

  | TPtr (t',a) ->
    let t = foc t' in
    begin match cvqual (attrof t') with
    | "" -> `Ct_ptr t
    | "c" -> `Ct_cptr t
    | "v" -> `Ct_vptr t
    | "cv" -> `Ct_cvptr t
    | _ -> assert false
    end

  | TArray (t',Some n,a)->
    let t = foc t' in
    let cv = cvqual (attrof t') in (* unused at the moment *)
    let n = litint n in
    `Ct_array (n,t)

  | TArray (t',None,a)->
    let t = foc t' in
    let cv = cvqual (attrof t') in (* unused at the moment *)
    `Ct_varray (t)

  | TFun (t',Some ps,false,a) ->
    let ret = foc t' in
    let argts = map foa ps in
    `Ct_fun (ret,argts)

  | TFun (t',None,false,a) ->
    let ret = foc t' in
    `Ct_fun (ret,[])

  | TFun (t',_,_,a) -> failwith "CANT HANDLE THIS FUN"

  | TNamed (ti,a) ->
    let name = ptname ti in
    let name' = rpltname name in
    `Ct_base name'

  | TComp (ci,a) ->
    let name = pci ci in
    `Ct_base (rpltname name)

  | TEnum (ei,a) -> `Ct_base "int"
  | TBuiltin_va_list a ->
    failwith "Can't handle varargs yet";
    `Ct_base "__builtin_va_list"

let rec ftyp_of_ctyp sr t =
  let foc t = ftyp_of_ctyp sr t in
  match t with
  | `Ct_base name -> `AST_name (sr,name,[])
  | `Ct_ptr t -> `AST_name (sr,"ptr", [foc t])
  | `Ct_cptr t -> `AST_name (sr,"cptr", [foc t])
  | `Ct_vptr t -> `AST_name (sr, "vptr", [foc t])
  | `Ct_cvptr t -> `AST_name (sr, "cvptr", [foc t])
  | `Ct_ptm (s,t)
  | `Ct_cptm (s,t)
  | `Ct_vptm (s,t)
  | `Ct_cvptm (s,t)
     -> failwith "can't handle pointer to member yet"

  | `Ct_array (n,t) -> `TYP_array (foc t,`TYP_unitsum n)

  | `Ct_varray t -> `AST_name (sr,"ptr", [foc t])
  | `Ct_fun (ret,ps) ->
    let ps = map foc ps in
    let ps = match ps with
      | [x] -> x
      | _ -> `TYP_tuple ps
    in
    `TYP_cfunction (ps,foc ret)

  | `Ct_vfun (ret,ps) ->
    let ps = map foc ps in
    let ps = rev (`TYP_ellipsis :: rev ps) in
    let ps = `TYP_tuple ps in
    `TYP_cfunction (ps,foc ret)

(* name with replacement *)
let flx_name x = match flx_name' x with
| Some x -> Some (rplname x)
| None -> None

(* type name with replacement *)
let flx_tname x = match flx_name' x with
| Some x -> rpltname x
| None -> "error!!"

let sr_of_loc {file=f; line=l} = f,l,0,l+1,0

let handle_global g =
  let loc = get_globalLoc g in
  let sr: range_srcref = sr_of_loc loc in
  let name = flx_tname g in
  print_endline ("Defining name = " ^ name);
  match g with
  | GType (ti,loc) ->
    begin
      match ti with {ttype=ttype} ->
      match  ttype with
      | TComp (ci,_) ->  print_endline "plain";
        []

      | TEnum (ei,_) ->
        print_endline "typedef enum";
        []

      | TFun (_,_,true,_) ->
        (* HACK: varargs function typedef *)
        print_endline "function type";
        []

      | t ->
        if isanont t then begin
          print_endline "Anonymous typedef?"; []
        end else begin
          let typ = ctyp_of_ciltyp  t in
          let typ : typecode_t = ftyp_of_ctyp sr typ in
          let stmt : statement_t = `AST_type_alias (sr,name,dfltvs,typ) in
          [stmt]
        end
    end

  | GCompTag (ci,loc) ->
    begin match ci with {
      cname=cname;
      cfields=cfields;
      cstruct=cstruct
    } ->
      print_endline "struct";
    end
    ;
    []


  | GCompTagDecl (ci,loc) ->
    print_endline "incomplete type";
    []

  | GEnumTag (ei,loc) ->
    print_endline "enum tag";
    []

  | GEnumTagDecl (ci,loc) ->
    print_endline "enum tag decl";
    []

  | GVar (vi,_,loc)
  | GFun ({svar=vi},loc)
  | GVarDecl (vi,loc) ->
    let vname, vtype=
      match vi with {vname=vname; vtype=vtype}->vname,vtype
    in
    if ispublic vname then
    begin match vtype with
    | TFun _ -> print_endline "Function"
    | _ -> print_endline "Variable"
    end
    ;
    []

  | GAsm _ -> print_endline "GASM"; []
  | GPragma _ -> print_endline "PRAGMA"; []
  | GText _ -> print_endline "TEXT"; []
