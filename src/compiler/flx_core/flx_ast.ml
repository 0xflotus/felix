(** {6 Source Reference}
 *
 * Provides a reference to the original source.  *)

(** Types used in the Felix compiler *)
open Big_int

(** type of a position in the {e original} sources *)
type srcref =
  string (* filename *) *
  int (* line number, 1 origin *) *
  int (* starting column, 1 origin *) *
  int (* ending column, 1 origin *)

(** type of a span between two positions in one file*)
type range_srcref =
  string * (* filename *)
  int * (* starting line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int * (* ending line number, 1 origin *)
  int   (* ending column, 1 origin *)

type bigint = big_int

(** {6 Abstract Syntax Tree}
 *
 * AST types are nodes of the Abstract Syntax Tree generated by the parser. *)

(** {7 Names}
 *
 * A simple name is an identifier, a qualified name is a dot (.) separated list
 * of instantiated names, and a instantiated name is a simple name optionally
 * followed by a square bracket enclosed list of type expressions. *)
type id_t = string
type bid_t = int
type index_map_t = (int,int) Hashtbl.t
type  c_t = [
  | `StrTemplate of string
  | `Str of string
  | `Virtual
  | `Identity
]

type base_type_qual_t = [
  | `Incomplete
  | `Pod
  | `GC_pointer (* this means the type is a pointer the GC must follow *)
]

(** type of a qualified name *)
type qualified_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_callback of range_srcref * qualified_name_t
  ]

(** type of a suffixed name *)
and suffixed_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_callback of range_srcref * qualified_name_t
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)
  ]

(** type of a regular expression *)
and regexp_t =
  [
  | `REGEXP_seq of regexp_t * regexp_t (** concatenation *)
  | `REGEXP_alt of regexp_t * regexp_t (** alternation *)
  | `REGEXP_aster of regexp_t (** Kleene closure *)
  | `REGEXP_name of qualified_name_t (** lookup regular definition *)
  | `REGEXP_string of string  (** concatenation of chars of string *)
  | `REGEXP_epsilon (** epsilon: null string *)
  | `REGEXP_sentinel (** end marker *)
  | `REGEXP_code of expr_t (** associated code *)
  | `REGEXP_group of string * regexp_t (** named group *)
  ]

(** {7 Type sublanguage}
 *
 * The encoding '`TYP_void' is the categorical initial: the type of an empty
 * union, and the type ordinary procedure types return.  There are no values
 * of this type. *)

(** type of a type *)
and typecode_t =
  [
  | `AST_void of range_srcref                   (** void type *)
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_callback of range_srcref * qualified_name_t
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)
  | `AST_patvar of range_srcref * string
  | `AST_patany of range_srcref
  | `TYP_tuple of typecode_t list               (** product type *)
  | `TYP_unitsum of int                         (** sum of units  *)
  | `TYP_sum of typecode_t list                 (** numbered sum type *)
  | `TYP_intersect of typecode_t list           (** intersection type *)
  | `TYP_record of (string * typecode_t) list   (** anon product *)
  | `TYP_variant of (string * typecode_t) list  (** anon sum *)
  | `TYP_function of typecode_t * typecode_t    (** function type *)
  | `TYP_cfunction of typecode_t * typecode_t   (** C function type *)
  | `TYP_pointer of typecode_t                  (** pointer type *)
  | `TYP_array of typecode_t * typecode_t       (** array type base ^ index *)
  | `TYP_as of typecode_t * string              (** fixpoint *)
  | `TYP_typeof of expr_t                       (** typeof *)
  | `TYP_var of int                             (** unknown type *)
  | `TYP_none                                   (** unspecified *)
  | `TYP_ellipsis                               (** ... for varargs *)
(*  | `TYP_lvalue of typecode_t *)                  (** ... lvalue annotation *)
  | `TYP_isin of typecode_t * typecode_t        (** typeset membership *)

  (* sets of types *)
  | `TYP_typeset of typecode_t list             (** discrete set of types *)
  | `TYP_setunion of typecode_t list            (** union of typesets *)
  | `TYP_setintersection of typecode_t list     (** intersection of typesets *)

  (* dualizer *)
  | `TYP_dual of typecode_t                     (** dual *)

  (* destructors *)
  | `TYP_dom of typecode_t                      (** function domain extractor *)
  | `TYP_cod of typecode_t                      (** function codomain extractor *)
  | `TYP_proj of int * typecode_t               (** tuple projection *)
  | `TYP_case_arg of int * typecode_t           (** argument of n'th variant *)

  | `TYP_apply of typecode_t * typecode_t       (** type function application *)
  | `TYP_typefun of simple_parameter_t list * typecode_t * typecode_t
                                                (** type lambda *)
  | `TYP_type                                   (** meta type of a type *)
  | `TYP_type_tuple of typecode_t list          (** meta type product *)

  | `TYP_type_match of typecode_t * (typecode_t * typecode_t) list

  | `TYP_glr_attr_type of qualified_name_t

  (* Barry Jay pattern calculus case *)
  | `TYP_case of typecode_t * string list * typecode_t

  | `TYP_lift of typecode_t                      (** lift type to metatype *)
  ]

and tpattern_t =
  [
  |  `TPAT_function of tpattern_t * tpattern_t
  |  `TPAT_sum of tpattern_t list
  |  `TPAT_tuple of tpattern_t list
  |  `TPAT_pointer of tpattern_t
  |  `TPAT_void
  |  `TPAT_var of string
  |  `TPAT_name of string * tpattern_t list
  |  `TPAT_as of tpattern_t * string
  |  `TPAT_any
  |  `TPAT_unitsum of int
  |  `TPAT_type_tuple of tpattern_t list
  ]

and raw_typeclass_insts_t = qualified_name_t list
and vs_aux_t = {
  raw_type_constraint:typecode_t;
  raw_typeclass_reqs: raw_typeclass_insts_t
}

and plain_vs_list_t = (id_t * typecode_t) list
and plain_ivs_list_t = (id_t * int * typecode_t) list
and vs_list_t = plain_vs_list_t *  vs_aux_t
and ivs_list_t = plain_ivs_list_t * vs_aux_t

(** Literals recognized by the lexer. *)
and literal_t =
  [
  | `AST_int of string * bigint
  | `AST_string of string
  | `AST_cstring of string
  | `AST_wstring of string
  | `AST_ustring of string
  | `AST_float of string * string
  ]

(** {7 Expressions}
 *
 * Raw expression terms. *)
and axiom_kind_t = [`Axiom | `Lemma ]
and axiom_method_t = [`Predicate of expr_t | `Equation of expr_t * expr_t]
and expr_t =
  [
  | `AST_interpolate of range_srcref * string
  | `AST_vsprintf of range_srcref * string
  | `AST_map of range_srcref * expr_t * expr_t
  | `AST_noexpand of range_srcref * expr_t
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `AST_apply of range_srcref * (expr_t * expr_t)
  | `AST_tuple of range_srcref * expr_t list
  | `AST_record of range_srcref * (string * expr_t) list
  | `AST_record_type of range_srcref * (string * typecode_t) list
  | `AST_variant of range_srcref * (string * expr_t)
  | `AST_variant_type of range_srcref * (string * typecode_t) list
  | `AST_arrayof of range_srcref * expr_t list
  | `AST_coercion of range_srcref * (expr_t * typecode_t)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)

  | `AST_patvar of range_srcref * string
  | `AST_patany of range_srcref

  | `AST_void of range_srcref
  | `AST_ellipsis of range_srcref
  | `AST_product of range_srcref * expr_t list
  | `AST_sum of range_srcref * expr_t list
  | `AST_intersect of range_srcref * expr_t list
  | `AST_isin of range_srcref * (expr_t * expr_t)
  | `AST_setintersection of range_srcref * expr_t list
  | `AST_setunion of range_srcref * expr_t list
  | `AST_orlist of range_srcref * expr_t list
  | `AST_andlist of range_srcref * expr_t list
  | `AST_arrow of range_srcref * (expr_t * expr_t)
  | `AST_longarrow of range_srcref * (expr_t * expr_t)
  | `AST_superscript of range_srcref * (expr_t * expr_t)

  | `AST_literal of range_srcref * literal_t
  | `AST_deref of range_srcref * expr_t
  | `AST_ref of range_srcref * expr_t
  | `AST_likely of range_srcref * expr_t
  | `AST_unlikely of range_srcref * expr_t
  | `AST_new of range_srcref * expr_t
(*  | `AST_lvalue of range_srcref * expr_t *)
  | `AST_callback of range_srcref * qualified_name_t
  | `AST_method_apply of range_srcref * (id_t * expr_t * typecode_t list)
  (*
  | `AST_dot of range_srcref * (expr_t * id_t * typecode_t list)
  *)
  | `AST_dot of range_srcref * (expr_t * expr_t)
  | `AST_lambda of range_srcref * (vs_list_t * params_t list * typecode_t * statement_t list)

  (* this boolean expression checks its argument is
     the nominated union variant .. not a very good name for it
  *)
  | `AST_match_ctor of range_srcref * (qualified_name_t * expr_t)

  (* this boolean expression checks its argument is the nominate
     sum variant
  *)
  | `AST_match_case of range_srcref * (int * expr_t)

  (* this extracts the argument of a named union variant -- unsafe *)
  | `AST_ctor_arg of range_srcref * (qualified_name_t * expr_t)

  (* this extracts the argument of a number sum variant -- unsafe *)
  | `AST_case_arg of range_srcref * (int * expr_t)

  (* this just returns an integer equal to union or sum index *)
  | `AST_case_index of range_srcref * expr_t (* the zero origin variant index *)

  | `AST_letin of range_srcref * (pattern_t * expr_t * expr_t)

  | `AST_get_n of range_srcref * (int * expr_t) (* get n'th component of a tuple *)
  | `AST_get_named_variable of range_srcref * (string * expr_t) (* get named component of a class or record *)
  | `AST_get_named_method of range_srcref * (string * int * typecode_t list * expr_t ) (* get named component of a class *)
  | `AST_as of range_srcref * (expr_t * string)
  | `AST_match of range_srcref * (expr_t * (pattern_t * expr_t) list)
  | `AST_parse of range_srcref * expr_t * (range_srcref * production_t * expr_t) list
  | `AST_sparse of range_srcref * expr_t * string * int list

  | `AST_regmatch of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  | `AST_string_regmatch of range_srcref * (expr_t * (regexp_t * expr_t) list)
  | `AST_reglex of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  | `AST_typeof of range_srcref * expr_t
  | `AST_lift of range_srcref * expr_t
  | `AST_cond of range_srcref * (expr_t * expr_t * expr_t)

  | `AST_expr of range_srcref * string * typecode_t

  | `AST_type_match of range_srcref * (typecode_t * (typecode_t * typecode_t) list)

  | `AST_macro_ctor of range_srcref * (string * expr_t)
  | `AST_macro_statements of range_srcref * statement_t list

  | `AST_case of range_srcref * expr_t * string list * expr_t
  | `AST_user_expr of range_srcref * string * ast_term_t
  ]

(** {7 Patterns}
 *
 * Patterns; used for matching variants in match statements. *)
and float_pat =
  | Float_plus of string * string (** type, value *)
  | Float_minus of string * string
  | Float_inf  (** infinity *)
  | Float_minus_inf (** negative infinity *)

and pattern_t =
  [
  | `PAT_nan of range_srcref
  | `PAT_none of range_srcref

  (* constants *)
  | `PAT_int of range_srcref * string * bigint
  | `PAT_string of range_srcref * string

  (* ranges *)
  | `PAT_int_range of range_srcref * string * bigint * string * bigint
  | `PAT_string_range of range_srcref * string * string
  | `PAT_float_range of range_srcref * float_pat * float_pat

  (* other *)
  | `PAT_coercion of range_srcref * pattern_t * typecode_t

  | `PAT_name of range_srcref * id_t
  | `PAT_tuple of range_srcref * pattern_t list
  | `PAT_any of range_srcref
  | `PAT_regexp of range_srcref * string * id_t list
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | `PAT_const_ctor of range_srcref * qualified_name_t
  | `PAT_nonconst_ctor of range_srcref * qualified_name_t * pattern_t
  | `PAT_as of range_srcref * pattern_t * id_t
  | `PAT_when of range_srcref * pattern_t * expr_t
  | `PAT_record of range_srcref * (id_t * pattern_t) list
  ]

(** {7 Statements}
 *
 * Statements; that is, the procedural sequence control system. *)
and param_kind_t = [`PVal | `PVar | `PFun | `PRef ]
and simple_parameter_t = id_t * typecode_t
and parameter_t = param_kind_t * id_t * typecode_t * expr_t option
and macro_parameter_type_t =
  | Ident
  | Expr
  | Stmt
and macro_parameter_t = id_t * macro_parameter_type_t
and lvalue_t = [
  | `Val of range_srcref * string
  | `Var of range_srcref * string
  | `Name of range_srcref * string
  | `Skip of range_srcref
  | `List of tlvalue_t list
  | `Expr of range_srcref * expr_t
]
and tlvalue_t = lvalue_t * typecode_t option

and funkind_t = [
  | `Object
  | `Function
  | `CFunction
  | `InlineFunction
  | `NoInlineFunction
  | `Virtual
  | `Ctor
  | `Generator
]

and property_t = [
  | `Recursive
  | `Inline
  | `NoInline
  | `Inlining_started
  | `Inlining_complete
  | `Generated of string
  | `Heap_closure        (* a heaped closure is formed *)
  | `Explicit_closure    (* explicit closure expression *)
  | `Stackable           (* closure can be created on stack *)
  | `Stack_closure       (* a stacked closure is formed *)
  | `Unstackable         (* closure cannot be created on stack *)
  | `Pure                (* closure not required by self *)
  | `Uses_global_var     (* a global variable is explicitly used *)
  | `Ctor                (* Class constructor procedure *)
  | `Generator           (* Generator: fun with internal state *)
  | `Yields              (* Yielding generator *)
  | `Cfun                (* C function *)

  (* one of the below must be set before code generation *)
  | `Requires_ptf        (* a pointer to thread frame is needed *)
  | `Not_requires_ptf    (* no pointer to thread frame is needed *)

  | `Uses_gc             (* requires gc locally *)
  | `Virtual             (* interface in a typeclass *)
]

and type_qual_t = [
  | base_type_qual_t
  | `Raw_needs_shape of typecode_t
]

and requirement_t = [
  | `Body_req of c_t
  | `Header_req of c_t
  | `Named_req of qualified_name_t
  | `Property_req of string
  | `Package_req of c_t
]

and ikind_t = [
  | `Header
  | `Body
  | `Package
]

and raw_req_expr_t =
[
  | `RREQ_atom of requirement_t
  | `RREQ_or of raw_req_expr_t * raw_req_expr_t
  | `RREQ_and of raw_req_expr_t * raw_req_expr_t
  | `RREQ_true
  | `RREQ_false
]

and named_req_expr_t =
[
  | `NREQ_atom of qualified_name_t
  | `NREQ_or of named_req_expr_t * named_req_expr_t
  | `NREQ_and of named_req_expr_t * named_req_expr_t
  | `NREQ_true
  | `NREQ_false
]

and prec_t = string
and glr_term_t =
[
  | `GLR_name of qualified_name_t
  | `GLR_opt of glr_term_t
  | `GLR_ast of glr_term_t
  | `GLR_plus of glr_term_t
  | `GLR_alt of glr_term_t list
  | `GLR_seq of glr_term_t list
]

and glr_entry_t = string option * glr_term_t
and production_t = glr_entry_t list

and reduced_glr_entry_t = string option * qualified_name_t
and reduced_production_t = reduced_glr_entry_t list
and params_t = parameter_t list * expr_t option (* second arg is a constraint *)
and class_member_t = [
  | `MemberVal of id_t * typecode_t * c_t option
  | `MemberVar of id_t * typecode_t * c_t option
  | `MemberFun of id_t * int option * vs_list_t * typecode_t * c_t option
  | `MemberProc of id_t * int option * vs_list_t * typecode_t * c_t option
  | `MemberCtor of id_t * int option * typecode_t * c_t option
]

and ast_term_t =
  [
  | `Expression_term of expr_t
  | `Statement_term of statement_t
  | `Statements_term of statement_t list
  | `Identifier_term of string
  | `Keyword_term of string
  | `Apply_term of ast_term_t * ast_term_t list
  ]

and statement_t =
  [
  | `AST_cparse of range_srcref * string
  | `AST_include of range_srcref * string
  | `AST_open of range_srcref * vs_list_t * qualified_name_t

  (* the keyword for this one is 'inherit' *)
  | `AST_inject_module of range_srcref * qualified_name_t
  | `AST_use of range_srcref * id_t * qualified_name_t
  | `AST_comment of range_srcref * string (* for documenting generated code *)
  (*
  | `AST_public of range_srcref * string * statement_t
  *)
  | `AST_private of range_srcref * statement_t

  (* definitions *)
  | `AST_reduce of range_srcref * id_t * vs_list_t * simple_parameter_t list * expr_t * expr_t
  | `AST_axiom of range_srcref * id_t * vs_list_t * params_t * axiom_method_t
  | `AST_lemma of range_srcref * id_t * vs_list_t * params_t * axiom_method_t
  | `AST_function of range_srcref * id_t * vs_list_t * params_t * (typecode_t * expr_t option) * property_t list * statement_t list
  | `AST_curry of range_srcref * id_t * vs_list_t * params_t list * (typecode_t * expr_t option) * funkind_t * statement_t list
  | `AST_object of range_srcref * id_t * vs_list_t * params_t * statement_t list
  | `AST_regdef of range_srcref * string * regexp_t
  | `AST_glr of range_srcref * string * typecode_t * (range_srcref * production_t * expr_t) list

  (* macros *)
  | `AST_macro_name of range_srcref * id_t * id_t
  | `AST_macro_names of range_srcref * id_t * id_t list
  | `AST_expr_macro of range_srcref * id_t * macro_parameter_t list * expr_t
  | `AST_stmt_macro of range_srcref * id_t * macro_parameter_t list * statement_t list
  | `AST_macro_block of range_srcref * statement_t list
  | `AST_macro_val  of range_srcref * id_t list * expr_t
  | `AST_macro_vals  of range_srcref * id_t * expr_t list
  | `AST_macro_var  of range_srcref * id_t list * expr_t
  | `AST_macro_assign of range_srcref * id_t list * expr_t
  | `AST_macro_forget of range_srcref * id_t list
  | `AST_macro_label of range_srcref * id_t
  | `AST_macro_goto of range_srcref * id_t
  | `AST_macro_ifgoto of range_srcref * expr_t * id_t
  | `AST_macro_proc_return of range_srcref

  (* type macros *)
  | `AST_macro_ifor of range_srcref * id_t * id_t list * statement_t list
  | `AST_macro_vfor of range_srcref * id_t list * expr_t * statement_t list

  (* composition of statements: note NOT A BLOCK *)
  | `AST_seq of range_srcref * statement_t list

  (* types *)
  | `AST_union of range_srcref * id_t * vs_list_t * (id_t * int option * vs_list_t * typecode_t) list
  | `AST_struct of range_srcref * id_t * vs_list_t * (id_t * typecode_t) list
  | `AST_cstruct of range_srcref * id_t * vs_list_t * (id_t * typecode_t) list
  | `AST_cclass of range_srcref * id_t * vs_list_t * class_member_t list
  | `AST_class of range_srcref * id_t * vs_list_t * statement_t list
  | `AST_type_alias of range_srcref * id_t * vs_list_t * typecode_t
  | `AST_inherit of range_srcref * id_t * vs_list_t * qualified_name_t
  | `AST_inherit_fun of range_srcref * id_t * vs_list_t * qualified_name_t

  (* variables *)
  | `AST_val_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
  | `AST_lazy_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
  | `AST_var_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
  | `AST_ref_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option

  (* module system *)
  | `AST_untyped_module of range_srcref * id_t * vs_list_t * statement_t list
  | `AST_namespace of range_srcref * id_t * vs_list_t * statement_t list
  | `AST_typeclass of range_srcref * id_t * vs_list_t * statement_t list
  | `AST_instance of range_srcref * vs_list_t * qualified_name_t * statement_t list

  (* control structures: primitives *)
  | `AST_label of range_srcref * id_t
  (*
  | `AST_whilst of range_srcref * expr_t * statement_t list
  | `AST_until of range_srcref * expr_t * statement_t list
  *)
  | `AST_goto of range_srcref * id_t
  | `AST_ifgoto of range_srcref * expr_t *id_t
  | `AST_ifreturn of range_srcref * expr_t
  | `AST_ifdo of range_srcref * expr_t * statement_t list * statement_t list
  | `AST_call of range_srcref * expr_t * expr_t
  | `AST_assign of range_srcref * string * tlvalue_t * expr_t
  | `AST_cassign of range_srcref * expr_t * expr_t
  | `AST_jump of range_srcref * expr_t * expr_t
  | `AST_loop of range_srcref * id_t * expr_t
  | `AST_svc of range_srcref * id_t
  | `AST_fun_return of range_srcref * expr_t
  | `AST_yield of range_srcref * expr_t
  | `AST_proc_return of range_srcref
  | `AST_halt of range_srcref  * string
  | `AST_trace of range_srcref  * id_t * string
  | `AST_nop of range_srcref * string
  | `AST_assert of range_srcref * expr_t
  | `AST_apply_ctor of range_srcref * id_t * expr_t * expr_t
  | `AST_init of range_srcref * id_t * expr_t

  | `AST_newtype of range_srcref * id_t * vs_list_t * typecode_t

  (* binding structures [prolog] *)
  | `AST_abs_decl of range_srcref * id_t * vs_list_t * type_qual_t list * c_t * raw_req_expr_t
  | `AST_ctypes of range_srcref * (srcref * id_t) list * type_qual_t list  * raw_req_expr_t
  | `AST_const_decl of range_srcref * id_t * vs_list_t * typecode_t * c_t * raw_req_expr_t
  | `AST_fun_decl of range_srcref * id_t * vs_list_t * typecode_t list * typecode_t * c_t * raw_req_expr_t * prec_t
  | `AST_callback_decl of range_srcref * id_t * typecode_t list * typecode_t * raw_req_expr_t
  (* embedding *)
  | `AST_insert of range_srcref * id_t * vs_list_t * c_t * ikind_t  * raw_req_expr_t
  | `AST_code of range_srcref * c_t
  | `AST_noreturn_code of range_srcref * c_t

  | `AST_export_fun of range_srcref * suffixed_name_t * string
  | `AST_export_python_fun of range_srcref * suffixed_name_t * string
  | `AST_export_type of range_srcref * typecode_t * string

  | `AST_user_statement of range_srcref * string * ast_term_t
  | `AST_scheme_string of range_srcref * string
  ]


and exe_t =
  [
  | `EXE_code of c_t (* for inline C++ code *)
  | `EXE_noreturn_code of c_t (* for inline C++ code *)
  | `EXE_comment of string (* for documenting generated code *)
  | `EXE_label of string (* for internal use only *)
  | `EXE_goto of string  (* for internal use only *)
  | `EXE_ifgoto of expr_t * string  (* for internal use only *)
  | `EXE_call of expr_t * expr_t
  | `EXE_jump of expr_t * expr_t
  | `EXE_loop of id_t * expr_t
  | `EXE_svc of id_t
  | `EXE_fun_return of expr_t
  | `EXE_yield of expr_t
  | `EXE_proc_return
  | `EXE_halt of string
  | `EXE_trace of id_t * string
  | `EXE_nop of string
  | `EXE_init of id_t * expr_t
  | `EXE_iinit of (id_t * int) * expr_t
  | `EXE_assign of expr_t * expr_t
  | `EXE_assert of expr_t
  | `EXE_apply_ctor of id_t * expr_t * expr_t
  ]

type sexe_t = range_srcref * exe_t

(** The whole of a compilation unit, this is the data structure returned by
 * parsing a whole file. *)
type compilation_unit_t = statement_t list
