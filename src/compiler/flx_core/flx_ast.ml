open Format
open Flx_format

module CS = Flx_code_spec
module L = Flx_literal

(** {6 Source Reference}
 *
 * Provides a reference to the original source.  *)

(** {6 Abstract Syntax Tree}
 *
 * AST types are nodes of the Abstract Syntax Tree generated by the parser. *)

type index_t = int
type index_map_t = (int,int) Hashtbl.t

type base_type_qual_t = [
  | `Incomplete
  | `Pod
  | `GC_pointer (* this means the type is a pointer the GC must follow *)
]

(** type of a qualified name *)
type qualified_name_t =
  [
  | `AST_void of Flx_srcref.t
  | `AST_name of Flx_srcref.t * Flx_id.t * typecode_t list
  | `AST_case_tag of Flx_srcref.t * int
  | `AST_typed_case of Flx_srcref.t * int * typecode_t
  | `AST_lookup of Flx_srcref.t * (expr_t * Flx_id.t * typecode_t list)
  | `AST_index of Flx_srcref.t * string * index_t
  | `AST_callback of Flx_srcref.t * qualified_name_t
  ]

(** type of a suffixed name *)
and suffixed_name_t =
  [
  | `AST_void of Flx_srcref.t
  | `AST_name of Flx_srcref.t * Flx_id.t * typecode_t list
  | `AST_case_tag of Flx_srcref.t * int
  | `AST_typed_case of Flx_srcref.t * int * typecode_t
  | `AST_lookup of Flx_srcref.t * (expr_t * Flx_id.t * typecode_t list)
  | `AST_index of Flx_srcref.t * string * index_t
  | `AST_callback of Flx_srcref.t * qualified_name_t
  | `AST_suffix of Flx_srcref.t * (qualified_name_t * typecode_t)
  ]

(** {7 Type sublanguage}
 *
 * The encoding '`TYP_void' is the categorical initial: the type of an empty
 * union, and the type ordinary procedure types return.  There are no values
 * of this type. *)

(** type of a type *)
and typecode_t =
  | TYP_void of Flx_srcref.t                   (** void type *)
  | TYP_name of Flx_srcref.t * Flx_id.t * typecode_t list
  | TYP_case_tag of Flx_srcref.t * int
  | TYP_typed_case of Flx_srcref.t * int * typecode_t
  | TYP_lookup of Flx_srcref.t * (expr_t * Flx_id.t * typecode_t list)
  | TYP_index of Flx_srcref.t * string * index_t
  | TYP_callback of Flx_srcref.t * qualified_name_t
  | TYP_suffix of Flx_srcref.t * (qualified_name_t * typecode_t)
  | TYP_patvar of Flx_srcref.t * Flx_id.t
  | TYP_patany of Flx_srcref.t
  | TYP_tuple of typecode_t list               (** product type *)
  | TYP_unitsum of int                         (** sum of units  *)
  | TYP_sum of typecode_t list                 (** numbered sum type *)
  | TYP_intersect of typecode_t list           (** intersection type *)
  | TYP_record of (Flx_id.t * typecode_t) list (** anon product *)
  | TYP_variant of (Flx_id.t * typecode_t) list (** anon sum *)
  | TYP_function of typecode_t * typecode_t    (** function type *)
  | TYP_cfunction of typecode_t * typecode_t   (** C function type *)
  | TYP_pointer of typecode_t                  (** pointer type *)
  | TYP_array of typecode_t * typecode_t       (** array type base ^ index *)
  | TYP_as of typecode_t * Flx_id.t            (** fixpoint *)
  | TYP_typeof of expr_t                       (** typeof *)
  | TYP_var of index_t                         (** unknown type *)
  | TYP_none                                   (** unspecified *)
  | TYP_ellipsis                               (** ... for varargs *)
(*  | TYP_lvalue of typecode_t *)                  (** ... lvalue annotation *)
  | TYP_isin of typecode_t * typecode_t        (** typeset membership *)

  (* sets of types *)
  | TYP_typeset of typecode_t list             (** discrete set of types *)
  | TYP_setunion of typecode_t list            (** union of typesets *)
  | TYP_setintersection of typecode_t list     (** intersection of typesets *)

  (* dualizer *)
  | TYP_dual of typecode_t                     (** dual *)

  | TYP_apply of typecode_t * typecode_t       (** type function application *)
  | TYP_typefun of simple_parameter_t list * typecode_t * typecode_t
                                                (** type lambda *)
  | TYP_type                                   (** meta type of a type *)
  | TYP_type_tuple of typecode_t list          (** meta type product *)

  | TYP_type_match of typecode_t * (typecode_t * typecode_t) list

and tpattern_t =
  | TPAT_function of tpattern_t * tpattern_t
  | TPAT_sum of tpattern_t list
  | TPAT_tuple of tpattern_t list
  | TPAT_pointer of tpattern_t
  | TPAT_void
  | TPAT_var of string
  | TPAT_name of string * tpattern_t list
  | TPAT_as of tpattern_t * string
  | TPAT_any
  | TPAT_unitsum of int
  | TPAT_type_tuple of tpattern_t list

and raw_typeclass_insts_t = qualified_name_t list
and vs_aux_t = {
  raw_type_constraint:typecode_t;
  raw_typeclass_reqs: raw_typeclass_insts_t
}

and plain_vs_list_t = (Flx_id.t * typecode_t) list
and vs_list_t = plain_vs_list_t * vs_aux_t

and axiom_kind_t = Axiom | Lemma
and axiom_method_t = Predicate of expr_t | Equation of expr_t * expr_t

(** {7 Expressions}
 *
 * Raw expression terms. *)
and expr_t =
  | EXPR_vsprintf of Flx_srcref.t * string
  | EXPR_map of Flx_srcref.t * expr_t * expr_t
  | EXPR_noexpand of Flx_srcref.t * expr_t
  | EXPR_name of Flx_srcref.t * Flx_id.t * typecode_t list
  | EXPR_index of Flx_srcref.t * string * index_t
  | EXPR_case_tag of Flx_srcref.t * int
  | EXPR_typed_case of Flx_srcref.t * int * typecode_t
  | EXPR_lookup of Flx_srcref.t * (expr_t * Flx_id.t * typecode_t list)
  | EXPR_apply of Flx_srcref.t * (expr_t * expr_t)
  | EXPR_tuple of Flx_srcref.t * expr_t list
  | EXPR_record of Flx_srcref.t * (Flx_id.t * expr_t) list
  | EXPR_record_type of Flx_srcref.t * (Flx_id.t * typecode_t) list
  | EXPR_variant of Flx_srcref.t * (Flx_id.t * expr_t)
  | EXPR_variant_type of Flx_srcref.t * (Flx_id.t * typecode_t) list
  | EXPR_arrayof of Flx_srcref.t * expr_t list
  | EXPR_coercion of Flx_srcref.t * (expr_t * typecode_t)
  | EXPR_suffix of Flx_srcref.t * (qualified_name_t * typecode_t)
  | EXPR_patvar of Flx_srcref.t * Flx_id.t
  | EXPR_patany of Flx_srcref.t
  | EXPR_void of Flx_srcref.t
  | EXPR_ellipsis of Flx_srcref.t
  | EXPR_product of Flx_srcref.t * expr_t list
  | EXPR_sum of Flx_srcref.t * expr_t list
  | EXPR_intersect of Flx_srcref.t * expr_t list
  | EXPR_isin of Flx_srcref.t * (expr_t * expr_t)
  | EXPR_orlist of Flx_srcref.t * expr_t list
  | EXPR_andlist of Flx_srcref.t * expr_t list
  | EXPR_arrow of Flx_srcref.t * (expr_t * expr_t)
  | EXPR_longarrow of Flx_srcref.t * (expr_t * expr_t)
  | EXPR_superscript of Flx_srcref.t * (expr_t * expr_t)
  | EXPR_literal of Flx_srcref.t * L.t
  | EXPR_deref of Flx_srcref.t * expr_t
  | EXPR_ref of Flx_srcref.t * expr_t
  | EXPR_likely of Flx_srcref.t * expr_t
  | EXPR_unlikely of Flx_srcref.t * expr_t
  | EXPR_new of Flx_srcref.t * expr_t
  | EXPR_callback of Flx_srcref.t * qualified_name_t
  | EXPR_dot of Flx_srcref.t * (expr_t * expr_t)
  | EXPR_lambda of Flx_srcref.t * (vs_list_t * params_t list * typecode_t * statement_t list)
  | EXPR_range_check of Flx_srcref.t * expr_t * expr_t * expr_t
  | EXPR_not of Flx_srcref.t * expr_t

  (* this boolean expression checks its argument is
     the nominated union variant .. not a very good name for it
  *)
  | EXPR_match_ctor of Flx_srcref.t * (qualified_name_t * expr_t)

  (* this boolean expression checks its argument is the nominate
     sum variant
  *)
  | EXPR_match_case of Flx_srcref.t * (int * expr_t)

  (* this extracts the argument of a named union variant -- unsafe *)
  | EXPR_ctor_arg of Flx_srcref.t * (qualified_name_t * expr_t)

  (* this extracts the argument of a number sum variant -- unsafe *)
  | EXPR_case_arg of Flx_srcref.t * (int * expr_t)

  (* this just returns an integer equal to union or sum index *)
  | EXPR_case_index of Flx_srcref.t * expr_t (* the zero origin variant index *)

  | EXPR_letin of Flx_srcref.t * (pattern_t * expr_t * expr_t)

  | EXPR_get_n of Flx_srcref.t * (int * expr_t)
  | EXPR_get_named_variable of Flx_srcref.t * (Flx_id.t * expr_t)
  | EXPR_as of Flx_srcref.t * (expr_t * Flx_id.t)
  | EXPR_match of Flx_srcref.t * (expr_t * (pattern_t * expr_t) list)

  | EXPR_typeof of Flx_srcref.t * expr_t
  | EXPR_cond of Flx_srcref.t * (expr_t * expr_t * expr_t)

  | EXPR_expr of Flx_srcref.t * string * typecode_t

  | EXPR_type_match of Flx_srcref.t * (typecode_t * (typecode_t * typecode_t) list)

(** {7 Patterns}
 *
 * Patterns; used for matching variants in match statements. *)
and float_pat =
  | Float_plus of L.Float_kind.t * string
  | Float_minus of L.Float_kind.t * string
  | Float_inf  (** infinity *)
  | Float_minus_inf (** negative infinity *)

and pattern_t =
  | PAT_nan of Flx_srcref.t
  | PAT_none of Flx_srcref.t

  (* constants *)
  | PAT_int of Flx_srcref.t * L.Int_kind.t * string
  | PAT_string of Flx_srcref.t * string

  (* ranges *)
  | PAT_int_range of
      Flx_srcref.t *
      L.Int_kind.t * string *
      L.Int_kind.t * string
  | PAT_string_range of Flx_srcref.t * string * string
  | PAT_float_range of Flx_srcref.t * float_pat * float_pat

  (* other *)
  | PAT_coercion of Flx_srcref.t * pattern_t * typecode_t

  | PAT_name of Flx_srcref.t * Flx_id.t
  | PAT_tuple of Flx_srcref.t * pattern_t list
  | PAT_any of Flx_srcref.t
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | PAT_const_ctor of Flx_srcref.t * qualified_name_t
  | PAT_nonconst_ctor of Flx_srcref.t * qualified_name_t * pattern_t
  | PAT_as of Flx_srcref.t * pattern_t * Flx_id.t
  | PAT_when of Flx_srcref.t * pattern_t * expr_t
  | PAT_record of Flx_srcref.t * (Flx_id.t * pattern_t) list
  | PAT_expr of Flx_srcref.t * expr_t

(** {7 Statements}
 *
 * Statements; that is, the procedural sequence control system. *)
and param_kind_t = [`PVal | `PVar | `PFun | `PRef ]
and simple_parameter_t = Flx_id.t * typecode_t
and parameter_t = param_kind_t * Flx_id.t * typecode_t * expr_t option
and lvalue_t = [
  | `Val of Flx_srcref.t * Flx_id.t
  | `Var of Flx_srcref.t * Flx_id.t
  | `Name of Flx_srcref.t * Flx_id.t
  | `Skip of Flx_srcref.t
  | `List of tlvalue_t list
  | `Expr of Flx_srcref.t * expr_t
]
and tlvalue_t = lvalue_t * typecode_t option

and funkind_t = [
  | `Function
  | `CFunction
  | `InlineFunction
  | `NoInlineFunction
  | `Virtual
  | `Ctor
  | `Generator
]

and property_t = [
  | `Recursive
  | `Inline
  | `NoInline
  | `Inlining_started
  | `Inlining_complete
  | `Generated of string
  | `Heap_closure        (* a heaped closure is formed *)
  | `Explicit_closure    (* explicit closure expression *)
  | `Stackable           (* closure can be created on stack *)
  | `Stack_closure       (* a stacked closure is formed *)
  | `Unstackable         (* closure cannot be created on stack *)
  | `Pure                (* closure not required by self *)
  | `Uses_global_var     (* a global variable is explicitly used *)
  | `Ctor                (* Class constructor procedure *)
  | `Generator           (* Generator: fun with internal state *)
  | `Yields              (* Yielding generator *)
  | `Cfun                (* C function *)
  | `Lvalue              (* primitive returns lvalue *)

  (* one of the below must be set before code generation *)
  | `Requires_ptf        (* a pointer to thread frame is needed *)
  | `Not_requires_ptf    (* no pointer to thread frame is needed *)

  | `Uses_gc             (* requires gc locally *)
  | `Virtual             (* interface in a typeclass *)
]

and type_qual_t = [
  | base_type_qual_t
  | `Raw_needs_shape of typecode_t
  | `Scanner of CS.t
  | `Finaliser of CS.t
]

and requirement_t =
  | Body_req of CS.t
  | Header_req of CS.t
  | Named_req of qualified_name_t
  | Property_req of string
  | Package_req of CS.t
  | Scanner_req of CS.t
  | Finaliser_req of CS.t

and ikind_t = [
  | `Header
  | `Body
  | `Package
]

and raw_req_expr_t =
  | RREQ_atom of requirement_t
  | RREQ_or of raw_req_expr_t * raw_req_expr_t
  | RREQ_and of raw_req_expr_t * raw_req_expr_t
  | RREQ_true
  | RREQ_false

and named_req_expr_t =
  | NREQ_atom of qualified_name_t
  | NREQ_or of named_req_expr_t * named_req_expr_t
  | NREQ_and of named_req_expr_t * named_req_expr_t
  | NREQ_true
  | NREQ_false

and prec_t = string
and params_t = parameter_t list * expr_t option (* second arg is a constraint *)

and ast_term_t =
  | Expression_term of expr_t
  | Statement_term of statement_t
  | Statements_term of statement_t list
  | Identifier_term of string
  | Keyword_term of string
  | Apply_term of ast_term_t * ast_term_t list

and statement_t =
  | STMT_include of Flx_srcref.t * string
  | STMT_open of Flx_srcref.t * vs_list_t * qualified_name_t

  (* the keyword for this one is 'inherit' *)
  | STMT_inject_module of Flx_srcref.t * vs_list_t * qualified_name_t
  | STMT_use of Flx_srcref.t * Flx_id.t * qualified_name_t
  | STMT_comment of Flx_srcref.t * string (* for documenting generated code *)
  (*
  | STMT_public of Flx_srcref.t * string * statement_t
  *)
  | STMT_private of Flx_srcref.t * statement_t

  (* definitions *)
  | STMT_reduce of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      simple_parameter_t list *
      expr_t *
      expr_t
  | STMT_axiom of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      params_t *
      axiom_method_t
  | STMT_lemma of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      params_t *
      axiom_method_t
  | STMT_function of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      params_t *
      (typecode_t * expr_t option) *
      property_t list *
      statement_t list
  | STMT_curry of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      params_t list *
      (typecode_t * expr_t option) *
      funkind_t *
      statement_t list

  (* macros *)
  | STMT_macro_val of Flx_srcref.t * Flx_id.t list * expr_t

  (* type macros *)
  | STMT_macro_forall of
      Flx_srcref.t *
      Flx_id.t list *
      expr_t *
      statement_t list

  (* composition of statements: note NOT A BLOCK *)
  | STMT_seq of Flx_srcref.t * statement_t list

  (* types *)
  | STMT_union of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      (Flx_id.t * int option * vs_list_t * typecode_t) list
  | STMT_struct of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      (Flx_id.t * typecode_t) list
  | STMT_cstruct of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      (Flx_id.t * typecode_t) list *
      raw_req_expr_t
  | STMT_type_alias of Flx_srcref.t * Flx_id.t * vs_list_t * typecode_t
  | STMT_inherit of Flx_srcref.t * Flx_id.t * vs_list_t * qualified_name_t
  | STMT_inherit_fun of Flx_srcref.t * Flx_id.t * vs_list_t * qualified_name_t

  (* variables *)
  | STMT_val_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      typecode_t option *
      expr_t option

  | STMT_lazy_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      typecode_t option *
      expr_t option

  | STMT_var_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      typecode_t option *
      expr_t option

  | STMT_ref_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      typecode_t option *
      expr_t option

  (* module system *)
  | STMT_untyped_module of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      statement_t list

  | STMT_typeclass of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      statement_t list

  | STMT_instance of
      Flx_srcref.t *
      vs_list_t *
      qualified_name_t *
      statement_t list

  (* control structures: primitives *)
  | STMT_label of Flx_srcref.t * Flx_id.t
  (*
  | STMT_whilst of Flx_srcref.t * expr_t * statement_t list
  | STMT_until of Flx_srcref.t * expr_t * statement_t list
  *)
  | STMT_goto of Flx_srcref.t * Flx_id.t
  | STMT_ifgoto of Flx_srcref.t * expr_t *Flx_id.t
  | STMT_ifreturn of Flx_srcref.t * expr_t
  | STMT_ifdo of Flx_srcref.t * expr_t * statement_t list * statement_t list
  | STMT_call of Flx_srcref.t * expr_t * expr_t
  | STMT_assign of Flx_srcref.t * Flx_id.t * tlvalue_t * expr_t
  | STMT_cassign of Flx_srcref.t * expr_t * expr_t
  | STMT_jump of Flx_srcref.t * expr_t * expr_t
  | STMT_loop of Flx_srcref.t * Flx_id.t * expr_t
  | STMT_svc of Flx_srcref.t * Flx_id.t
  | STMT_fun_return of Flx_srcref.t * expr_t
  | STMT_yield of Flx_srcref.t * expr_t
  | STMT_proc_return of Flx_srcref.t
  | STMT_halt of Flx_srcref.t  * string
  | STMT_trace of Flx_srcref.t  * Flx_id.t * string
  | STMT_nop of Flx_srcref.t * string
  | STMT_assert of Flx_srcref.t * expr_t
  | STMT_init of Flx_srcref.t * Flx_id.t * expr_t
  | STMT_stmt_match of Flx_srcref.t * (expr_t * (pattern_t * statement_t list) list)

  | STMT_newtype of Flx_srcref.t * Flx_id.t * vs_list_t * typecode_t

  (* binding structures [prolog] *)
  | STMT_abs_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      type_qual_t list *
      Flx_code_spec.t *
      raw_req_expr_t

  | STMT_ctypes of
      Flx_srcref.t *
      (Flx_srcref.t * Flx_id.t) list *
      type_qual_t list *
      raw_req_expr_t

  | STMT_const_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      typecode_t *
      Flx_code_spec.t *
      raw_req_expr_t

  | STMT_fun_decl of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      typecode_t list *
      typecode_t *
      Flx_code_spec.t *
      raw_req_expr_t *
      prec_t

  | STMT_callback_decl of
      Flx_srcref.t *
      Flx_id.t *
      typecode_t list *
      typecode_t *
      raw_req_expr_t

  (* embedding *)
  | STMT_insert of
      Flx_srcref.t *
      Flx_id.t *
      vs_list_t *
      Flx_code_spec.t *
      ikind_t *
      raw_req_expr_t
  | STMT_code of Flx_srcref.t * Flx_code_spec.t
  | STMT_noreturn_code of Flx_srcref.t * Flx_code_spec.t

  | STMT_export_fun of Flx_srcref.t * suffixed_name_t * string
  | STMT_export_python_fun of Flx_srcref.t * suffixed_name_t * string
  | STMT_export_type of Flx_srcref.t * typecode_t * string

  | STMT_scheme_string of Flx_srcref.t * string

type exe_t =
  | EXE_code of CS.t (* for inline C++ code *)
  | EXE_noreturn_code of CS.t (* for inline C++ code *)
  | EXE_comment of string (* for documenting generated code *)
  | EXE_label of string (* for internal use only *)
  | EXE_goto of string  (* for internal use only *)
  | EXE_ifgoto of expr_t * string  (* for internal use only *)
  | EXE_call of expr_t * expr_t
  | EXE_jump of expr_t * expr_t
  | EXE_loop of Flx_id.t * expr_t
  | EXE_svc of Flx_id.t
  | EXE_fun_return of expr_t
  | EXE_yield of expr_t
  | EXE_proc_return
  | EXE_halt of string
  | EXE_trace of Flx_id.t * string
  | EXE_nop of string
  | EXE_init of Flx_id.t * expr_t
  | EXE_iinit of (Flx_id.t * index_t) * expr_t
  | EXE_assign of expr_t * expr_t
  | EXE_assert of expr_t

type sexe_t = Flx_srcref.t * exe_t

(** The whole of a compilation unit, this is the data structure returned by
 * parsing a whole file. *)
type compilation_unit_t = statement_t list

let src_of_qualified_name (e : qualified_name_t) = match e with
  | `AST_void s
  | `AST_name  (s,_,_)
  | `AST_case_tag (s,_)
  | `AST_typed_case (s,_,_)
  | `AST_lookup (s,_)
  | `AST_index (s,_,_)
  | `AST_callback (s,_)
  -> s

let src_of_suffixed_name (e : suffixed_name_t) = match e with
  | #qualified_name_t as x -> src_of_qualified_name x
  | `AST_suffix (s,_)
  -> s

let src_of_typecode = function
  | TYP_void s
  | TYP_name  (s,_,_)
  | TYP_case_tag (s,_)
  | TYP_typed_case (s,_,_)
  | TYP_lookup (s,_)
  | TYP_index (s,_,_)
  | TYP_callback (s,_)
  | TYP_suffix (s,_)
  | TYP_patvar (s,_)
  | TYP_patany s
  -> s

  | TYP_tuple _
  | TYP_unitsum _
  | TYP_sum _
  | TYP_intersect _
  | TYP_record _
  | TYP_variant _
  | TYP_function _
  | TYP_cfunction _
  | TYP_pointer _
  | TYP_array _
  | TYP_as _
  | TYP_typeof _
  | TYP_var _
  | TYP_none
  | TYP_ellipsis
  | TYP_isin _
  | TYP_typeset _
  | TYP_setunion _
  | TYP_setintersection _
  | TYP_dual _
  | TYP_apply _
  | TYP_typefun _
  | TYP_type
  | TYP_type_tuple _
  | TYP_type_match _
  -> Flx_srcref.dummy_sr

let src_of_expr (e : expr_t) = match e with
  | EXPR_void s
  | EXPR_name (s,_,_)
  | EXPR_case_tag (s,_)
  | EXPR_typed_case (s,_,_)
  | EXPR_lookup (s,_)
  | EXPR_index (s,_,_)
  | EXPR_callback (s,_)
  | EXPR_suffix (s,_)
  | EXPR_patvar (s,_)
  | EXPR_patany s
  | EXPR_vsprintf (s,_)
  | EXPR_ellipsis s
  | EXPR_noexpand (s,_)
  | EXPR_product (s,_)
  | EXPR_sum (s,_)
  | EXPR_intersect (s,_)
  | EXPR_isin (s,_)
  | EXPR_orlist (s,_)
  | EXPR_andlist (s,_)
  | EXPR_arrow (s,_)
  | EXPR_longarrow (s,_)
  | EXPR_superscript (s,_)
  | EXPR_map (s,_,_)
  | EXPR_apply (s,_)
  | EXPR_deref (s,_)
  | EXPR_new (s,_)
  | EXPR_ref (s,_)
  | EXPR_likely (s,_)
  | EXPR_unlikely (s,_)
  | EXPR_literal (s,_)
  | EXPR_tuple (s,_)
  | EXPR_record (s,_)
  | EXPR_variant (s,_)
  | EXPR_record_type (s,_)
  | EXPR_variant_type (s,_)
  | EXPR_arrayof (s,_)
  | EXPR_dot (s,_)
  | EXPR_lambda (s,_)
  | EXPR_match_ctor (s,_)
  | EXPR_match_case (s,_)
  | EXPR_ctor_arg (s,_)
  | EXPR_case_arg (s,_)
  | EXPR_case_index (s,_)
  | EXPR_get_n (s,_)
  | EXPR_get_named_variable (s,_)
  | EXPR_coercion (s,_)
  | EXPR_as (s,_)
  | EXPR_match (s, _)
  | EXPR_type_match (s, _)
  | EXPR_cond (s,_)
  | EXPR_expr (s,_,_)
  | EXPR_letin (s,_)
  | EXPR_typeof (s,_)
  | EXPR_range_check (s,_,_,_)
  | EXPR_not (s,_)
  -> s

let src_of_stmt (e : statement_t) = match e with
  (*
  | STMT_public (s,_,_)
  *)
  | STMT_private (s,_)
  | STMT_label (s,_)
  | STMT_goto (s,_)
  | STMT_assert (s,_)
  | STMT_init (s,_,_)
  | STMT_function (s,_,_,_,_,_,_)
  | STMT_reduce (s,_,_,_,_,_)
  | STMT_axiom (s,_,_,_,_)
  | STMT_lemma (s,_,_,_,_)
  | STMT_curry (s,_,_,_,_,_,_)
  | STMT_macro_val (s,_,_)
  | STMT_macro_forall (s,_,_,_)
  | STMT_val_decl (s,_,_,_,_)
  | STMT_lazy_decl (s,_,_,_,_)
  | STMT_var_decl (s,_,_,_,_)
  | STMT_ref_decl (s,_,_,_,_)
  | STMT_type_alias (s,_,_,_)
  | STMT_inherit (s,_,_,_)
  | STMT_inherit_fun (s,_,_,_)
  | STMT_nop (s,_)
  | STMT_assign (s,_,_,_)
  | STMT_cassign (s, _,_)
  | STMT_call (s,_,_)
  | STMT_jump (s,_,_)
  | STMT_loop (s,_,_)
  | STMT_svc (s,_)
  | STMT_fun_return (s,_)
  | STMT_yield (s,_)
  | STMT_proc_return s
  | STMT_halt (s,_)
  | STMT_trace (s,_,_)
  | STMT_ifgoto (s,_,_)
  | STMT_ifreturn (s,_)
  | STMT_ifdo (s,_,_,_)
  (*
  | STMT_whilst (s,_,_)
  | STMT_until (s,_,_)
  *)
  | STMT_abs_decl (s,_,_,_,_,_)
  | STMT_newtype (s,_,_,_)
  | STMT_ctypes (s,_,_,_)
  | STMT_const_decl (s,_,_,_,_,_)
  | STMT_fun_decl (s,_,_,_,_,_,_,_)
  | STMT_callback_decl (s,_,_,_,_)
  | STMT_insert (s,_,_,_,_,_)
  | STMT_code (s,_)
  | STMT_noreturn_code (s,_)
  | STMT_union (s, _,_,_)
  | STMT_struct (s,_,_,_)
  | STMT_cstruct (s,_,_,_,_)
  | STMT_typeclass (s,_,_,_)
  | STMT_instance (s,_,_,_)
  | STMT_untyped_module (s,_,_,_)
  | STMT_export_fun (s,_,_)
  | STMT_export_python_fun (s,_,_)
  | STMT_export_type (s,_,_)
  | STMT_open (s,_,_)
  | STMT_inject_module (s,_,_)
  | STMT_include (s,_)
  | STMT_use (s,_,_)
  | STMT_seq (s,_)
  | STMT_scheme_string (s,_)
  | STMT_comment (s,_)
  | STMT_stmt_match (s,_)
  -> s

let src_of_pat (e : pattern_t) = match e with
  | PAT_coercion (s,_,_)
  | PAT_nan s
  | PAT_none s
  | PAT_int (s,_,_)
  | PAT_string (s,_)
  | PAT_int_range (s,_,_,_,_)
  | PAT_string_range (s,_,_)
  | PAT_float_range (s,_,_)
  | PAT_name (s,_)
  | PAT_tuple (s,_)
  | PAT_any s
  | PAT_const_ctor (s,_)
  | PAT_nonconst_ctor (s,_,_)
  | PAT_as (s,_,_)
  | PAT_when (s,_,_)
  | PAT_record (s,_)
  | PAT_expr (s,_)
  -> s

let typecode_of_qualified_name = function
  | `AST_void sr -> TYP_void sr
  | `AST_name (sr,name,ts) -> TYP_name (sr,name,ts)
  | `AST_case_tag (sr,v) -> TYP_case_tag (sr,v)
  | `AST_typed_case (sr,v,t) -> TYP_typed_case (sr,v,t)
  | `AST_lookup (sr,(e,name,ts)) -> TYP_lookup (sr,(e,name,ts))
  | `AST_index (sr,name,index) -> TYP_index (sr,name,index)
  | `AST_callback (sr,name) -> TYP_callback (sr,name)

let qualified_name_of_typecode = function
  | TYP_void sr -> Some (`AST_void sr)
  | TYP_name (sr,name,ts) -> Some (`AST_name (sr,name,ts))
  | TYP_case_tag (sr,v) -> Some (`AST_case_tag (sr,v))
  | TYP_typed_case (sr,v,t) -> Some (`AST_typed_case (sr,v,t))
  | TYP_lookup (sr,(e,name,ts)) -> Some (`AST_lookup (sr,(e,name,ts)))
  | TYP_index (sr,name,index) -> Some (`AST_index (sr,name,index))
  | TYP_callback (sr,name) -> Some (`AST_callback (sr,name))
  | _ -> None

(** Define a default vs_aux_t. *)
let dfltvs_aux =
  { raw_type_constraint = TYP_tuple []; raw_typeclass_reqs = []; }

(** Define a default vs_list_t. *)
let dfltvs = [], dfltvs_aux

(** Prints out a name to a formatter. *)
let print_name ppf = print_string ppf

(** Prints out a base_type_qual_t to a formatter. *)
let print_base_type_qual f = function
  | `Incomplete -> print_variant0 f "`Incomplete"
  | `Pod -> print_variant0 f "`Pod"
  | `GC_pointer -> print_variant0 f "`GC_pointer"

(** Prints out a property_t to a formatter. *)
let print_property f = function
  | `Recursive -> fprintf f "`Recursive"
  | `Inline -> fprintf f "`Inline"
  | `NoInline -> fprintf f "`NoInline"
  | `Inlining_started -> fprintf f "`Inlining_started"
  | `Inlining_complete -> fprintf f "`Inlining_complete"
  | `Generated s -> fprintf f "`Generated %S" s
  | `Heap_closure -> fprintf f "`Heap_closure"
  | `Explicit_closure -> fprintf f "`Explicit_closure"
  | `Stackable -> fprintf f "`Stackable"
  | `Stack_closure -> fprintf f "`Stack_closure"
  | `Unstackable -> fprintf f "`Unstackable"
  | `Pure -> fprintf f "`Pure"
  | `Uses_global_var -> fprintf f "`Uses_global_var"
  | `Ctor -> fprintf f "`Ctor"
  | `Generator -> fprintf f "`Generator"
  | `Yields -> fprintf f "`Yields"
  | `Cfun -> fprintf f "`Cfun"
  | `Lvalue -> fprintf f "`Lvalue"
  | `Requires_ptf -> fprintf f "`Requires_ptf"
  | `Not_requires_ptf -> fprintf f "`Not_requires_ptf"
  | `Uses_gc -> fprintf f "`Uses_gc"
  | `Virtual -> fprintf f "`Virtual"

(** Prints out a property list to a formatter. *)
let print_properties = Flx_list.print print_property

(** Prints out a param_kind_t to a formatter. *)
let print_param_kind f = function
  | `PVal -> fprintf f "`PVal"
  | `PVar -> fprintf f "`PVar"
  | `PFun -> fprintf f "`PFun"
  | `PRef -> fprintf f "`PRef"

(** Prints out a qualified name to a formatter. *)
let rec print_qualified_name ppf = function
  | `AST_void _ ->
      print_variant0 ppf "`AST_void"
  | `AST_name (_, name, typs) ->
      print_variant2 ppf "`AST_name"
        Flx_id.print name
        print_types typs
  | `AST_case_tag (_, case) ->
      print_variant1 ppf "`AST_case_tag"
        pp_print_int case
  | `AST_typed_case (_, case, typ) ->
      print_variant2 ppf "`AST_typed_case"
        pp_print_int case
        print_type typ
  | `AST_lookup (_, (expr, name, typs)) ->
      print_variant3 ppf "`AST_lookup"
        print_expr expr
        Flx_id.print name
        print_types typs
  | `AST_index (_, name, index) ->
      print_variant2 ppf "`AST_index"
        print_string name
        pp_print_int index
  | `AST_callback (_, name) ->
      print_variant1 ppf "`AST_callback"
        print_qualified_name name

(** Prints out a suffixed name to a formatter. *)
and print_suffixed_name ppf = function
  | #qualified_name_t as name -> print_qualified_name ppf name
  | `AST_suffix (_, (name, suffix)) ->
      print_variant2 ppf "`AST_suffix"
        print_qualified_name name
        print_type suffix

(** Prints out a type to a formatter. *)
and print_type ppf = function
  | TYP_void _ ->
      print_variant0 ppf "TYP_void"
  | TYP_name (_, name, typs) ->
      print_variant2 ppf "TYP_name"
        Flx_id.print name
        print_types typs
  | TYP_case_tag (_, case) ->
      print_variant1 ppf "TYP_case_tag"
        pp_print_int case
  | TYP_typed_case (_, case, typ) ->
      print_variant2 ppf "TYP_typed_case"
        pp_print_int case
        print_type typ
  | TYP_lookup (_, (expr, name, typs)) ->
      print_variant3 ppf "TYP_lookup"
        print_expr expr
        Flx_id.print name
        print_types typs
  | TYP_index (_, name, index) ->
      print_variant2 ppf "TYP_index"
        print_string name
        pp_print_int index
  | TYP_callback (_, name) ->
      print_variant1 ppf "TYP_callback"
        print_qualified_name name
  | TYP_suffix (_, (name, typ)) ->
      print_variant2 ppf "TYP_suffix"
        print_qualified_name name
        print_type typ
  | TYP_patvar (_, name) ->
      print_variant1 ppf "TYP_patvar"
        Flx_id.print name
  | TYP_patany _ ->
      print_variant0 ppf "TYP_patany"
  | TYP_tuple typs ->
      print_variant1 ppf "TYP_tuple"
        print_types typs
  | TYP_unitsum k ->
      print_variant1 ppf "TYP_unitsum"
        pp_print_int k
  | TYP_sum typs ->
      print_variant1 ppf "TYP_sum"
        print_types typs
  | TYP_intersect typs ->
      print_variant1 ppf "TYP_intersect"
        print_types typs
  | TYP_record items ->
      print_variant1 ppf "TYP_record"
        (Flx_list.print_tuples2 Flx_id.print print_type) items
  | TYP_variant items ->
      print_variant1 ppf "TYP_variant"
        (Flx_list.print_tuples2 Flx_id.print print_type) items
  | TYP_function (typ1, typ2) ->
      print_variant2 ppf "TYP_function"
        print_type typ1
        print_type typ2
  | TYP_cfunction (typ1, typ2) ->
      print_variant2 ppf "TYP_cfunction"
        print_type typ1
        print_type typ2
  | TYP_pointer typ ->
      print_variant1 ppf "TYP_pointer"
        print_type typ
  | TYP_array (typ1, typ2) ->
      print_variant2 ppf "TYP_array"
        print_type typ1
        print_type typ2
  | TYP_as (typ, name) ->
      print_variant2 ppf "TYP_as"
        print_type typ
        Flx_id.print name
  | TYP_typeof expr ->
      print_variant1 ppf "TYP_typeof"
        print_expr expr
  | TYP_var index ->
      print_variant1 ppf "TYP_var"
        pp_print_int index
  | TYP_none ->
      print_variant0 ppf "TYP_none"
  | TYP_ellipsis ->
      print_variant0 ppf "TYP_ellipsis"
  | TYP_isin (typ1, typ2) ->
      print_variant2 ppf "TYP_isin"
        print_type typ1
        print_type typ2
  | TYP_typeset typs ->
      print_variant1 ppf "TYP_typeset"
        print_types typs
  | TYP_setunion typs ->
      print_variant1 ppf "TYP_setunion"
        print_types typs
  | TYP_setintersection typs ->
      print_variant1 ppf "TYP_setintersection"
        print_types typs
  | TYP_dual typ ->
      print_variant1 ppf "TYP_dual"
        print_type typ
  | TYP_apply (typ1, typ2) ->
      print_variant2 ppf "TYP_apply"
        print_type typ1
        print_type typ2
  | TYP_typefun (params, typ1, typ2) ->
      print_variant3 ppf "TYP_typefun"
        (Flx_list.print print_simple_parameter) params
        print_type typ1
        print_type typ2
  | TYP_type ->
      print_variant0 ppf "TYP_type"
  | TYP_type_tuple typs ->
      print_variant1 ppf "TYP_type_tuple"
        print_types typs
  | TYP_type_match (typ, patterns) ->
      print_variant2 ppf "TYP_type_match"
        print_type typ
        (Flx_list.print_tuples2 print_type print_type) patterns

(** Prints out a list of types to a formatter. *)
and print_types ppf = Flx_list.print print_type ppf

(** Prints out a simple parameter to a formatter. *)
and print_simple_parameter ppf (name, typ) =
  print_tuple2 ppf
    Flx_id.print name
    print_type typ

(** Prints out a parameter to a formatter. *)
and print_parameter ppf (kind, name, typ, expr) =
  print_tuple4 ppf
    print_param_kind kind
    Flx_id.print name
    print_type typ
    (print_opt print_expr) expr

(** Prints out a parameter block to a formatter. *)
and print_params ppf (parameters, expr) =
  print_tuple2 ppf
    (Flx_list.print print_parameter) parameters
    (print_opt print_expr) expr

(** Prints out a float pattern to a formatter. *)
and print_float_pattern ppf = function
  | Float_plus (kind, f) ->
      print_variant2 ppf "Float_plus"
        L.Float_kind.print kind
        print_string f
  | Float_minus (kind, f) ->
      print_variant2 ppf "Float_minus"
        L.Float_kind.print kind
        print_string f
  | Float_inf ->
      print_variant0 ppf "Float_inf"
  | Float_minus_inf ->
      print_variant0 ppf "Float_minus_inf"

(** Prints out a pattern to a formatter. *)
and print_pattern ppf = function
  | PAT_nan _ ->
      print_variant0 ppf "PAT_nan"
  | PAT_none _ ->
      print_variant0 ppf "PAT_none"
  | PAT_int (_, kind, i) ->
      print_variant2 ppf "PAT_int"
        L.Int_kind.print kind
        print_string i
  | PAT_string (_, s) ->
      print_variant1 ppf "PAT_string"
        print_string s
  | PAT_int_range (_, kind1, i1, kind2, i2) ->
      print_variant4 ppf "PAT_int_range"
        L.Int_kind.print kind1
        print_string i1
        L.Int_kind.print kind2
        print_string i2
  | PAT_string_range (_, s1, s2) ->
      print_variant2 ppf "PAT_string_range"
        print_string s1
        print_string s2
  | PAT_float_range (_, pattern1, pattern2) ->
      print_variant2 ppf "PAT_float_range"
        print_float_pattern pattern1
        print_float_pattern pattern2
  | PAT_coercion (_, pattern, typ) ->
      print_variant2 ppf "PAT_coercion"
        print_pattern pattern
        print_type typ
  | PAT_name (_, name) ->
      print_variant1 ppf "PAT_name"
        Flx_id.print name
  | PAT_tuple (_, patterns) ->
      print_variant1 ppf "PAT_tuple"
        (Flx_list.print print_pattern) patterns
  | PAT_any _ ->
      print_variant0 ppf "PAT_any"
  | PAT_const_ctor (_, name) ->
      print_variant1 ppf "PAT_const_ctor"
        print_qualified_name name
  | PAT_nonconst_ctor (_, name, pattern) ->
      print_variant2 ppf "PAT_nonconst_ctor"
        print_qualified_name name
        print_pattern pattern
  | PAT_as (_, pattern, name) ->
      print_variant2 ppf "PAT_as"
        print_pattern pattern
        Flx_id.print name
  | PAT_when (_, pattern, expr) ->
      print_variant2 ppf "PAT_when"
        print_pattern pattern
        print_expr expr
  | PAT_record (_, items) ->
      print_variant1 ppf "PAT_record"
        (Flx_list.print_tuples2 Flx_id.print print_pattern) items
  | PAT_expr (_,e) ->
      print_variant1 ppf "PAT_expr"
      print_expr e

(** Prints out an expression to a formatter. *)
and print_expr ppf = function
  | EXPR_vsprintf (_, s) ->
      print_variant1 ppf "EXPR_vsprintf"
        print_string s
  | EXPR_map (_, expr1, expr2) -> 
      print_variant2 ppf "EXPR_map"
        print_expr expr1
        print_expr expr2
  | EXPR_noexpand (_, expr) -> 
      print_variant1 ppf "EXPR_noexpand"
        print_expr expr
  | EXPR_name (_, name, typs) -> 
      print_variant2 ppf "EXPR_name"
        Flx_id.print name
        print_types typs
  | EXPR_index (_, name, index) ->
      print_variant2 ppf "EXPR_index"
        print_string name
        pp_print_int index
  | EXPR_case_tag (_, case) -> 
      print_variant1 ppf "EXPR_case_tag"
        pp_print_int case
  | EXPR_typed_case (_, case, typ) ->
      print_variant2 ppf "EXPR_typed_case"
        pp_print_int case
        print_type typ
  | EXPR_lookup (_, (expr, name, typs)) ->
      print_variant3 ppf "EXPR_lookup"
        print_expr expr
        Flx_id.print name
        print_types typs
  | EXPR_apply (_, (expr1, expr2)) -> 
      print_variant2 ppf "EXPR_apply"
        print_expr expr1
        print_expr expr2
  | EXPR_tuple (_, exprs) -> 
      print_variant1 ppf "EXPR_tuple"
        print_exprs exprs
  | EXPR_record (_, items) ->
      print_variant1 ppf "EXPR_record"
        (Flx_list.print_tuples2 Flx_id.print print_expr) items
  | EXPR_record_type (_, items) ->
      print_variant1 ppf "EXPR_record_type"
        (Flx_list.print_tuples2 Flx_id.print print_type) items
  | EXPR_variant (_, (name, expr)) -> 
      print_variant2 ppf "EXPR_variant"
        Flx_id.print name
        print_expr expr
  | EXPR_variant_type (_, items) ->
      print_variant1 ppf "EXPR_variant_type"
        (Flx_list.print_tuples2 Flx_id.print print_type) items
  | EXPR_arrayof (_, exprs) -> 
      print_variant1 ppf "EXPR_arrayof"
        print_exprs exprs
  | EXPR_coercion (_, (expr, typ)) -> 
      print_variant2 ppf "EXPR_coercion"
        print_expr expr
        print_type typ
  | EXPR_suffix (_, (name, typ)) ->
      print_variant2 ppf "EXPR_suffix"
        print_qualified_name name
        print_type typ
  | EXPR_patvar (_, name) -> 
      print_variant1 ppf "EXPR_patvar"
        Flx_id.print name
  | EXPR_patany _ -> 
      print_variant0 ppf "EXPR_patany"
  | EXPR_void _ -> 
      print_variant0 ppf "EXPR_void"
  | EXPR_ellipsis _ -> 
      print_variant0 ppf "EXPR_ellipsis"
  | EXPR_product (_, exprs) -> 
      print_variant1 ppf "EXPR_product"
        print_exprs exprs
  | EXPR_sum (_, exprs) -> 
      print_variant1 ppf "EXPR_sum"
        print_exprs exprs
  | EXPR_intersect (_, exprs) -> 
      print_variant1 ppf "EXPR_intersect"
        print_exprs exprs
  | EXPR_isin (_, (expr1, expr2)) -> 
      print_variant2 ppf "EXPR_isin"
        print_expr expr1
        print_expr expr2
  | EXPR_orlist (_, exprs) -> 
      print_variant1 ppf "EXPR_orlist"
        print_exprs exprs
  | EXPR_andlist (_, exprs) -> 
      print_variant1 ppf "EXPR_andlist"
        print_exprs exprs
  | EXPR_arrow (_, (expr1, expr2)) -> 
      print_variant2 ppf "EXPR_arrow"
        print_expr expr1
        print_expr expr2
  | EXPR_longarrow (_, (expr1, expr2)) -> 
      print_variant2 ppf "EXPR_longarrow"
        print_expr expr1
        print_expr expr2
  | EXPR_superscript (_, (expr1, expr2)) -> 
      print_variant2 ppf "EXPR_superscript"
        print_expr expr1
        print_expr expr2
  | EXPR_literal (_, literal) -> 
      print_variant1 ppf "EXPR_literal"
        L.print literal
  | EXPR_deref (_, expr) -> 
      print_variant1 ppf "EXPR_deref"
        print_expr expr
  | EXPR_ref (_, expr) -> 
      print_variant1 ppf "EXPR_ref"
        print_expr expr
  | EXPR_likely (_, expr) -> 
      print_variant1 ppf "EXPR_likely"
        print_expr expr
  | EXPR_unlikely (_, expr) -> 
      print_variant1 ppf "EXPR_unlikely"
        print_expr expr
  | EXPR_new (_, expr) -> 
      print_variant1 ppf "EXPR_new"
        print_expr expr
  | EXPR_callback (_, name) -> 
      print_variant1 ppf "EXPR_callback"
        print_qualified_name name
  | EXPR_dot (_, (expr1, expr2)) -> 
      print_variant2 ppf "EXPR_dot"
        print_expr expr1
        print_expr expr2
  | EXPR_lambda (_, (vs, params, typ, stmts)) ->
      print_variant4 ppf "EXPR_lambda"
        print_vs vs
        (Flx_list.print print_params) params
        print_type typ
        (Flx_list.print print_statement) stmts
  | EXPR_match_ctor (_, (name, expr)) ->
      print_variant2 ppf "EXPR_match_ctor"
        print_qualified_name name
        print_expr expr
  | EXPR_match_case (_, (case, expr)) -> 
      print_variant2 ppf "EXPR_match_case"
        pp_print_int case
        print_expr expr
  | EXPR_ctor_arg (_, (name, expr)) ->
      print_variant2 ppf "EXPR_ctor_arg"
        print_qualified_name name
        print_expr expr
  | EXPR_case_arg (_, (case, expr)) ->
      print_variant2 ppf "EXPR_case_arg"
        pp_print_int case
        print_expr expr
  | EXPR_case_index (_, expr) -> 
      print_variant1 ppf "EXPR_case_index"
        print_expr expr
  | EXPR_letin (_, (pattern, expr1, expr2)) -> 
      print_variant3 ppf "EXPR_letin"
        print_pattern pattern
        print_expr expr1
        print_expr expr2
  | EXPR_get_n (_, (index, expr)) ->
      print_variant2 ppf "EXPR_get_n"
        pp_print_int index
        print_expr expr
  | EXPR_get_named_variable (_, (name, expr)) -> 
      print_variant2 ppf "EXPR_get_named_variable"
        Flx_id.print name
        print_expr expr
  | EXPR_as (_, (expr, name)) -> 
      print_variant2 ppf "EXPR_as"
        print_expr expr
        Flx_id.print name
  | EXPR_match (_, (expr, patterns)) ->
      print_variant2 ppf "EXPR_match"
        print_expr expr
        (Flx_list.print_tuples2 print_pattern print_expr) patterns
  | EXPR_typeof (_, expr) -> 
      print_variant1 ppf "EXPR_typeof"
        print_expr expr
  | EXPR_cond (_, (if_expr, then_expr, else_expr)) -> 
      print_variant3 ppf "EXPR_cond"
        print_expr if_expr
        print_expr then_expr
        print_expr else_expr
  | EXPR_expr (_, code, typ) ->
      print_variant2 ppf "EXPR_expr"
        print_string code
        print_type typ
  | EXPR_type_match (_, (typ, patterns)) ->
      print_variant2 ppf "EXPR_type_match"
        print_type typ
        (Flx_list.print_tuples2 print_type print_type) patterns

  | EXPR_range_check (_,mi,v,mx) ->
      print_variant3 ppf "EXPR_range_check"
      print_expr mi print_expr v print_expr mx
  | EXPR_not (_,e) ->
      print_variant1 ppf "EXPR_not"
      print_expr e


(** Prints out a list of expressions to a formatter. *)
and print_exprs ppf =
  Flx_list.print print_expr ppf

(** Prints out a variable list to a formatter. *)
and print_plain_vs_list ppf =
  Flx_list.print_tuples2 Flx_id.print print_type ppf

and print_raw_typeclass_insts ppf =
  Flx_list.print print_qualified_name ppf

and print_vs_aux ppf vs_aux =
  print_record2 ppf
    "raw_type_constraint" print_type vs_aux.raw_type_constraint
    "raw_typeclass_reqs" print_raw_typeclass_insts vs_aux.raw_typeclass_reqs

and print_vs ppf (plain_vs, vs_aux) =
  print_tuple2 ppf
    print_plain_vs_list plain_vs
    print_vs_aux vs_aux

(** Prints out an axiom method to a formatter. *)
and print_axiom_method ppf = function
  | Predicate expr ->
      print_variant1 ppf "Pedicate"
        print_expr expr
  | Equation (expr1, expr2) ->
      print_variant2 ppf "Equation"
        print_expr expr1
        print_expr expr2

(** Prints out a function kind to a formatter. *)
and print_fun_kind ppf = function
  | `Function -> print_variant0 ppf "`Function"
  | `CFunction -> print_variant0 ppf "`CFunction"
  | `InlineFunction -> print_variant0 ppf "`InlineFunction"
  | `NoInlineFunction -> print_variant0 ppf "`NoInlineFunction"
  | `Virtual -> print_variant0 ppf "`Virtual"
  | `Ctor -> print_variant0 ppf "`Ctor"
  | `Generator -> print_variant0 ppf "`Generator"

(** Prints out a requirement expression to a formatter. *)
and print_raw_requirement ppf = function
  | RREQ_atom req ->
      print_variant1 ppf "RREQ_atom"
        print_requirement req
  | RREQ_or (req1, req2) ->
      print_variant2 ppf "RREQ_or"
        print_raw_requirement req1
        print_raw_requirement req2
  | RREQ_and (req1, req2) ->
      print_variant2 ppf "REQ_and"
        print_raw_requirement req1
        print_raw_requirement req2
  | RREQ_true ->
      print_variant0 ppf "RREQ_true"
  | RREQ_false ->
      print_variant0 ppf "RREQ_false"

(** Prints out a term to a formatter. *)
and print_term ppf = function
  | Expression_term expr ->
      print_variant1 ppf "Expression_term"
        print_expr expr
  | Statement_term statement ->
      print_variant1 ppf "Statement_term"
        print_statement statement
  | Statements_term statements ->
      print_variant1 ppf "Statements_term"
        print_statements statements
  | Identifier_term identifier ->
      print_variant1 ppf "Identifier_term"
        print_string identifier
  | Keyword_term keyword ->
      print_variant1 ppf "Keyword_term"
        print_string keyword
  | Apply_term (lhs, rhs) ->
      print_variant2 ppf "Apply_term"
        print_term lhs
        (Flx_list.print print_term) rhs

(** Prints out an interface kind to a formatter. *)
and print_ikind ppf = function
  | `Header -> print_variant0 ppf "`Header"
  | `Body -> print_variant0 ppf "`Body"
  | `Package -> print_variant0 ppf "`Package"

(** Prints out a precedence to a formatter. *)
and print_prec ppf = print_string ppf

(** Prints out a type qualifier to a formatter. *)
and print_type_qual ppf = function
  | #base_type_qual_t as qual -> print_base_type_qual ppf qual
  | `Raw_needs_shape typ ->
      print_variant1 ppf "`Raw_needs_shape"
        print_type typ
  | `Scanner code ->
      print_variant1 ppf "`Scanner"
        CS.print code
  | `Finaliser code ->
      print_variant1 ppf "`Finaliser"
        CS.print code

(** Prints out a requirement to a formatter. *)
and print_requirement ppf = function
  | Body_req code ->
      print_variant1 ppf "Body_req"
        CS.print code
  | Header_req code ->
      print_variant1 ppf "Header_req"
        CS.print code
  | Named_req qualified_name ->
      print_variant1 ppf "Named_req"
        print_qualified_name qualified_name
  | Property_req property ->
      print_variant1 ppf "Property_req"
        print_string property
  | Package_req code ->
      print_variant1 ppf "Package_req"
        CS.print code
  | Scanner_req code ->
      print_variant1 ppf "Scanner_req"
        CS.print code
  | Finaliser_req code ->
      print_variant1 ppf "Finaliser_req"
        CS.print code

(** Prints out an lvalue to a formatter. *)
and print_lvalue ppf = function
  | `Val (_, name) ->
      print_variant1 ppf "`Val"
        Flx_id.print name
  | `Var (_, name) ->
      print_variant1 ppf "`Var"
        Flx_id.print name
  | `Name (_, name) ->
      print_variant1 ppf "`Name"
        Flx_id.print name
  | `Skip (_) ->
      print_variant0 ppf "`Skip"
  | `List tlvalues ->
      print_variant1 ppf "`List"
        (Flx_list.print print_tlvalue) tlvalues
  | `Expr (_, expr) ->
      print_variant1 ppf "`Expr"
        print_expr expr

(** Prints out an optionally typed lvalue to a formatter. *)
and print_tlvalue ppf (lvalue, typ) =
  print_tuple2 ppf
    print_lvalue lvalue
    (print_opt print_type) typ

(** Prints out a statement to a formatter. *)
and print_statement ppf = function
  | STMT_include (_, s) ->
      print_variant1 ppf "STMT_include"
        print_string s
  | STMT_open (_, vs, name) ->
      print_variant2 ppf "STMT_open"
        print_vs vs
        print_qualified_name name
  | STMT_inject_module (_, vs, name) ->
      print_variant2 ppf "STMT_inject_module"
        print_vs vs
        print_qualified_name name
  | STMT_use (_, name1, name2) ->
      print_variant2 ppf "STMT_use"
        Flx_id.print name1
        print_qualified_name name2
  | STMT_comment (_, comment) ->
      print_variant1 ppf "STMT_comment"
        print_string comment
  | STMT_private (_, statement) ->
      print_variant1 ppf "STMT_private"
        print_statement statement
  | STMT_reduce (_, name, vs, parameters, expr1, expr2) ->
      print_variant5 ppf "STMT_reduce"
        Flx_id.print name
        print_vs vs
        (Flx_list.print print_simple_parameter) parameters
        print_expr expr1
        print_expr expr2
  | STMT_axiom (_, name, vs, params, axiom_method) ->
      print_variant4 ppf "STMT_axiom"
        Flx_id.print name
        print_vs vs
        print_params params
        print_axiom_method axiom_method
  | STMT_lemma (_, name, vs, params, axiom_method) ->
      print_variant4 ppf "STMT_lemma"
        Flx_id.print name
        print_vs vs
        print_params params
        print_axiom_method axiom_method
  | STMT_function (_, name, vs, params, (return_type, post_condition), props, statements) ->
      print_variant7 ppf "STMT_function"
        Flx_id.print name
        print_vs vs
        print_params params
        print_type return_type
        (print_opt print_expr) post_condition
        print_properties props
        print_statements statements
  | STMT_curry (_, name, vs, params, (return_type, post_condition), fun_kind, statements) ->
      print_variant7 ppf "STMT_curry"
        Flx_id.print name
        print_vs vs
        (Flx_list.print print_params) params
        print_type return_type
        (print_opt print_expr) post_condition
        print_fun_kind fun_kind
        print_statements statements
  | STMT_macro_val  (_, names, expr) ->
      print_variant2 ppf "STMT_macro_val"
        (Flx_list.print Flx_id.print) names
        print_expr expr
  | STMT_macro_forall (_, names, expr, statements) ->
      print_variant3 ppf "STMT_macro_forall"
        (Flx_list.print Flx_id.print) names
        print_expr expr
        print_statements statements
  | STMT_seq (_, statements) ->
      print_variant1 ppf "STMT_seq"
        print_statements statements
  | STMT_union (_, name, vs, components) ->
      print_variant3 ppf "STMT_union"
        Flx_id.print name
        print_vs vs
        (Flx_list.print_tuples4
          Flx_id.print
          (print_opt pp_print_int)
          print_vs
          print_type) components
  | STMT_struct (_, name, vs, components) ->
      print_variant3 ppf "STMT_struct"
        Flx_id.print name
        print_vs vs
        (Flx_list.print_tuples2 Flx_id.print print_type) components
  | STMT_cstruct (_, name, vs, components, raw_req) ->
      print_variant4 ppf "STMT_cstruct"
        Flx_id.print name
        print_vs vs
        (Flx_list.print_tuples2 Flx_id.print print_type) components
        print_raw_requirement raw_req

  | STMT_type_alias (_, name, vs, typ) ->
      print_variant3 ppf "STMT_type_alias"
        Flx_id.print name
        print_vs vs
        print_type typ
  | STMT_inherit (_, name, vs, qualified_name) ->
      print_variant3 ppf "STMT_inherit"
        Flx_id.print name
        print_vs vs
        print_qualified_name qualified_name
  | STMT_inherit_fun (_, name, vs, qualified_name) ->
      print_variant3 ppf "STMT_inherit_fun"
        Flx_id.print name
        print_vs vs
        print_qualified_name qualified_name
  | STMT_val_decl (_, name, vs, typ, expr) ->
      print_variant4 ppf "STMT_val_decl"
        Flx_id.print name
        print_vs vs
        (print_opt print_type) typ
        (print_opt print_expr) expr
  | STMT_lazy_decl (_, name, vs, typ, expr) ->
      print_variant4 ppf "STMT_lazy_decl"
        Flx_id.print name
        print_vs vs
        (print_opt print_type) typ
        (print_opt print_expr) expr
  | STMT_var_decl (_, name, vs, typ, expr) ->
      print_variant4 ppf "STMT_var_decl"
        Flx_id.print name
        print_vs vs
        (print_opt print_type) typ
        (print_opt print_expr) expr
  | STMT_ref_decl (_, name, vs, typ, expr) ->
      print_variant4 ppf "STMT_ref_decl"
        Flx_id.print name
        print_vs vs
        (print_opt print_type) typ
        (print_opt print_expr) expr
  | STMT_untyped_module (_, name, vs, statements) ->
      print_variant3 ppf "STMT_untyped_module"
        Flx_id.print name
        print_vs vs
        print_statements statements
  | STMT_typeclass (_, name, vs, statements) ->
      print_variant3 ppf "STMT_typeclass"
        Flx_id.print name
        print_vs vs
        print_statements statements
  | STMT_instance (_, vs, qualified_name, statements) ->
      print_variant3 ppf "STMT_instance"
        print_vs vs
        print_qualified_name qualified_name
        print_statements statements
  | STMT_label (_, name) ->
      print_variant1 ppf "STMT_label"
        Flx_id.print name
  | STMT_goto (_, name) ->
      print_variant1 ppf "STMT_goto"
        Flx_id.print name
  | STMT_ifgoto (_, expr, name) ->
      print_variant2 ppf "STMT_ifgoto"
        print_expr expr
        Flx_id.print name
  | STMT_ifreturn (_, expr) ->
      print_variant1 ppf "STMT_ifreturn"
        print_expr expr
  | STMT_ifdo (_, if_expr, then_statements, else_statements) ->
      print_variant3 ppf "STMT_ifdo"
        print_expr if_expr
        print_statements then_statements
        print_statements else_statements
  | STMT_call (_, expr1, expr2) ->
      print_variant2 ppf "STMT_call"
        print_expr expr1
        print_expr expr2
  | STMT_assign (_, name, tlvalue, expr) ->
      print_variant3 ppf "STMT_assign"
        Flx_id.print name
        print_tlvalue tlvalue
        print_expr expr
  | STMT_cassign (_, expr1, expr2) ->
      print_variant2 ppf "STMT_cassign"
        print_expr expr1
        print_expr expr2
  | STMT_jump (_, expr1, expr2) ->
      print_variant2 ppf "STMT_jump"
        print_expr expr1
        print_expr expr2
  | STMT_loop (_, name, expr) ->
      print_variant2 ppf "STMT_loop"
        Flx_id.print name
        print_expr expr
  | STMT_svc (_, name) ->
      print_variant1 ppf "STMT_svc"
        Flx_id.print name
  | STMT_fun_return (_, expr) ->
      print_variant1 ppf "STMT_fun_return"
        print_expr expr
  | STMT_yield (_, expr) ->
      print_variant1 ppf "STMT_yield"
        print_expr expr
  | STMT_proc_return _ ->
      print_variant0 ppf "STMT_proc_return"
  | STMT_halt (_ , comment) ->
      print_variant1 ppf "STMT_halt"
        print_string comment
  | STMT_trace (_ , name, comment) ->
      print_variant2 ppf "STMT_trace"
        Flx_id.print name
        print_string comment
  | STMT_nop (_, comment) ->
      print_variant1 ppf "STMT_nop"
        print_string comment
  | STMT_assert (_, expr) ->
      print_variant1 ppf "STMT_assert"
        print_expr expr
  | STMT_init (_, name, expr) ->
      print_variant2 ppf "STMT_init"
        Flx_id.print name
        print_expr expr
  | STMT_stmt_match (_, (expr, components)) ->
      print_variant2 ppf "STMT_stmt_match"
        print_expr expr
        (Flx_list.print_tuples2 print_pattern print_statements) components
  | STMT_newtype (_, name, vs, typ) ->
      print_variant3 ppf "STMT_newtype"
        Flx_id.print name
        print_vs vs
        print_type typ
  | STMT_abs_decl (_, name, vs, type_quals, code, raw_req) ->
      print_variant5 ppf "STMT_abs_decl"
        Flx_id.print name
        print_vs vs
        (Flx_list.print print_type_qual) type_quals
        CS.print code
        print_raw_requirement raw_req
  | STMT_ctypes (_, names, type_quals, raw_req) ->
      print_variant3 ppf "STMT_ctypes"
        (Flx_list.print Flx_id.print) (List.map snd names)
        (Flx_list.print print_type_qual) type_quals
        print_raw_requirement raw_req
  | STMT_const_decl (_, name, vs, typ, code, raw_req) ->
      print_variant5 ppf "STMT_const_decl"
        Flx_id.print name
        print_vs vs
        print_type typ
        CS.print code
        print_raw_requirement raw_req
  | STMT_fun_decl (_, name, vs, arg_types, return_type, code, raw_req, prec) ->
      print_variant7 ppf "STMT_fun_decl"
        Flx_id.print name
        print_vs vs
        print_types arg_types
        print_type return_type
        CS.print code
        print_raw_requirement raw_req
        print_prec prec
  | STMT_callback_decl (_, name, arg_typs, return_type, raw_req) ->
      print_variant4 ppf "STMT_callback_decl"
        Flx_id.print name
        print_types arg_typs
        print_type return_type
        print_raw_requirement raw_req
  | STMT_insert (_, name, vs, code, ikind, raw_req) ->
      print_variant5 ppf "STMT_insert"
        Flx_id.print name
        print_vs vs
        CS.print code
        print_ikind ikind
        print_raw_requirement raw_req
  | STMT_code (_, code) ->
      print_variant1 ppf "STMT_code"
        CS.print code
  | STMT_noreturn_code (_, code) ->
      print_variant1 ppf "STMT_noreturn_code"
        CS.print code
  | STMT_export_fun (_, name, exported_name) ->
      print_variant2 ppf "STMT_export_fun"
        print_suffixed_name name
        print_string exported_name
  | STMT_export_python_fun (_, name, exported_name) ->
      print_variant2 ppf "STMT_export_python_fun"
        print_suffixed_name name
        print_string exported_name
  | STMT_export_type (_, typ, exported_name) ->
      print_variant2 ppf "STMT_export_type"
        print_type typ
        print_string exported_name
  | STMT_scheme_string (_, scheme) ->
      print_variant1 ppf "STMT_scheme_string"
        print_string scheme

(** Prints out statements to a formatter. *)
and print_statements ppf = Flx_list.print print_statement ppf
