%mltop {
open Flx_token
open Flx_mtypes2
}
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_set
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset
open Flx_exceptions
open Flx_util
open Flx_list
open Ocs_types
open Sex_types
open Dyp
open Lexing
open Big_int
open Flx_string

type action_t = [`Scheme of string | `None]
type symbol_t = [`Atom of token | `Group of dyalt_t list]
and dyalt_t = symbol_t list * range_srcref * action_t * anote_t

type page_entry_t = [
  | `Nt of string
  | `Subpage of string * page_entry_t list
]

let strip_us s =
  let n = String.length s in
  let x = Buffer.create n in
  for i=0 to n - 1 do
    match s.[i] with
    | '_' -> ()
    | c -> Buffer.add_char x c
  done;
  Buffer.contents x


let lexeme x = Lexing.lexeme (Dyp.std_lexbuf x)

let dummysr = "Dummy",0,0,0,0

let getsr lexbuf = 
  let lexbuf = Dyp.std_lexbuf lexbuf in
  let file = lexbuf.lex_start_p.pos_fname in
  let start_line = lexbuf.lex_start_p.pos_lnum in
  let start_col = lexbuf.lex_start_p.pos_cnum - lexbuf.lex_start_p.pos_bol + 1 in
  let end_col =   lexbuf.lex_curr_p.pos_cnum  - lexbuf.lex_start_p.pos_bol in
  file, start_line, start_col, end_col

let set_filename lexbuf fname = 
  let lexbuf = Dyp.std_lexbuf lexbuf in
  lexbuf.lex_curr_p <- { lexbuf.lex_curr_p with pos_fname = fname }

let set_lineno lexbuf n =
  let lexbuf = Dyp.std_lexbuf lexbuf in
  lexbuf.lex_curr_p <- { lexbuf.lex_curr_p with pos_lnum = n }

let incr_lineno lexbuf n = 
  let lexbuf = Dyp.std_lexbuf lexbuf in
  let n = ref n in
  while !n <> 0 do Lexing.new_line lexbuf; decr n done

let lfcount s =
  let n = ref 0 in
  for i = 0 to (String.length s) - 1 do
    if s.[i] = '\n' then incr n
  done;
  !n

(* string parsers *)
let decode_qstring s = let n = String.length s in unescape (String.sub s 0 (n-1))
let decode_dstring s = let n = String.length s in unescape (String.sub s 0 (n-1))
let decode_qqqstring s = let n = String.length s in unescape (String.sub s 0 (n-3))
let decode_dddstring s = let n = String.length s in unescape (String.sub s 0 (n-3))

let decode_raw_qstring s = let n = String.length s in String.sub s 0 (n-1)
let decode_raw_dstring s = let n = String.length s in String.sub s 0 (n-1)
let decode_raw_qqqstring s = let n = String.length s in String.sub s 0 (n-3)
let decode_raw_dddstring s = let n = String.length s in String.sub s 0 (n-3)


let silly_strtoken k = Flx_prelex.string_of_token k
  (*
  match k with
  | NAME (_,s) -> s
  | NONTERMINAL (_,s,p) -> s
  | _ -> Dyp_symbols.str_token k
  *)

let fresh_dssl = {
  prios = [];
  rules = [];
  deps = [];
  privacy = Drules.empty;
}

exception Scheme_error of sval

let giveup () = raise Giveup; Sunspec
let sraise s  = raise (Scheme_error s); Sunspec

let flx_ocs_init env =
  Ocs_env.set_pf0 env giveup "giveup";
  Ocs_env.set_pf1 env sraise "raise"

let init_env () =
  let env = Ocs_top.make_env () in
  flx_ocs_init env;

  let v1:Ocs_types.sval = Ocs_sym.get_symbol "_sr" in
  let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
  Ocs_env.bind_name env v1 g1;

  let v1:Ocs_types.sval = Ocs_sym.get_symbol "_arg" in
  let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
  Ocs_env.bind_name env v1 g1;

  for n = 1 to 20 do
    let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
    let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
    Ocs_env.bind_name env v1 g1;
  done;
  env

let global_data = {
  pcounter = ref 1;
  env=init_env();
  pdebug=ref false;
}

type local_data_t = {
  dssls:dssl_t Drules.t;
  loaded_dssls: string list;
  scm: (Flx_ast.range_srcref * string) list;
}

let local_data: local_data_t = {
  dssls=Drules.empty;
  loaded_dssls = [];
  scm = [];
}

let xsr sr =
  match sr with f,fl,fc,ll,lc ->
  Ocs_misc.make_slist Snull ((Sint lc) :: (Sint ll) :: (Sint fc) :: (Sint ll) :: (Sstring f) :: [])

let buffer_add_ocs b r = Ocs_print.print_to_buffer b false r

let scheme_lex sr (s:string):sval =
  let sr = short_string_of_src sr in
  let inp = Ocs_port.string_input_port s in
  let lex = Ocs_lex.make_lexer inp sr in
  match Ocs_read.read_expr lex with
  | Ocs_types.Seof -> print_endline "END OF FILE?"; Snull
  | v ->  v

let scheme_compile env (s:sval):Ocs_types.code =
  Ocs_compile.compile env s

let scheme_eval (c:Ocs_types.code):sval =
  let th = Ocs_top.make_thread () in
  let term = ref None in
  Ocs_eval.eval th (fun (r:sval) -> term := Some r) c;
  match !term with
  | None -> failwith "Scheme term not returned!"
  | Some r -> r

let scheme_run sr env (s:string):sval =
  let l :sval = scheme_lex sr s in
  let c :code = scheme_compile env l in
  let r :sval = scheme_eval c in
  r

let cal_priority_relation p =
  match p with
  | `No_prio -> No_priority
  | `Eq_prio p -> Eq_priority p
  | `Less_prio p -> Less_priority p
  | `Lesseq_prio p -> Lesseq_priority p
  | `Greater_prio p -> Greater_priority p
  | `Greatereq_prio p -> Greatereq_priority p

let define_scheme sr dyp dssl_record dssl name prio rhs (scm:string) =
(*
print_endline ("define_scheme " ^ name);
*)
  let mapnt name = try Drules.find name dssl_record.privacy with Not_found -> name in
  let pr_age = !(dyp.global_data.pcounter) in
  incr (dyp.global_data.pcounter);
  let name = mapnt name in
  (* this routine converts SCHEME "(scm prog)" into a single compiled token *)
  let rec fudge_rhs inls outls = match inls with
  | [] -> List.rev outls
  | SCHEME _ :: STRING (sr,scm) :: t ->
    (*
    print_endline ("Compiling Scheme checker " ^ scm);
    *)
    let cde =
      try
        let l = scheme_lex (slift sr) scm in
        let c = scheme_compile dyp.global_data.env l in
        c
      with
      | Ocs_error.Error err | Ocs_error.ErrorL (_,err) -> failwith ("Error " ^ err ^ " compiling " ^ scm)
    in
    fudge_rhs t (SCHEME_CODE (sr,scm,cde) :: outls)

  | h :: t -> fudge_rhs t (h::outls)
  in
  let rhs = fudge_rhs rhs [] in
  let rec f o =
    match o with
      | STRING _ ->
          Dyp.Ter "NAME"

      | SCHEME_CODE _ ->
          Dyp.Ter "NAME"

      | NONTERMINAL (sr,s,p) ->
          let nt = mapnt s in
          let ntpri = cal_priority_relation p in
          Dyp.Non_ter (nt,ntpri)

      | NAME (sr,s) -> assert false

      | s ->
(*
print_endline ("Token=" ^ Flx_prelex.string_of_token s);
print_endline ("Name =" ^ Flx_prelex.name_of_token s);
*)
        let name = Dyp_symbols.str_token s in
        let name = Flx_prelex.name_of_token s in
(*
print_endline ("Running f, arg=\"" ^ name ^ "\"");
*)
        Dyp.Ter name
  in
  let cde =
    try
      let l = scheme_lex sr scm in
      let c = scheme_compile dyp.global_data.env l in
      c
    with
    | Ocs_error.Error err | Ocs_error.ErrorL (_,err) -> failwith ("Error " ^ err ^ " compiling " ^ scm)
  in

  let priority = match prio with
  | `Default -> "default_priority"
  | `Priority p -> p
  in
  let rule = name,(List.map f rhs),priority,[] in
  if !(dyp.global_data.pdebug) then
  print_endline ("Rule "^string_of_int pr_age ^" " ^ name ^ "["^priority^"] := " ^
  catmap " " silly_strtoken rhs ^
  " =># "^scm);
  let action = fun _ avl ->
    match avl,scm with
    (* optimise special case *)
    | [`Obj_sexpr (_,sr,s)],"_1" -> `Obj_sexpr (pr_age,sr,s),[]
    | _ ->
    let age = ref pr_age in
    let b = Buffer.create 200 in
    if !(dyp.global_data.pdebug) then
    Buffer.add_string b ("Reducing Rule "^string_of_int pr_age ^" for " ^ name ^ "["^priority^"], scm="^scm^"\n");

    if !(dyp.global_data.pdebug) then
    print_endline ("Reducing Rule "^string_of_int pr_age ^" for " ^ name ^ "["^priority^"] := "^ catmap " " silly_strtoken rhs^ " #scm="^scm^"\n");

    (* let env = Ocs_env.env_copy dyp.local_data.env in *)
    (* let env = dyp.local_data.env in *)
    let env = dyp.global_data.env in
    let srs = ref [] in
    let rec aux objs syms n = match objs, syms with
      | [],[] -> ()
      | [],_ | _,[] -> assert false
      | h1::t1,h2::t2 ->
        let sr,s =
          match h1,h2 with
          | _,`Obj_sexpr (seq,sr,s) ->
            (* age := max !age seq; *)
            sr,s

          | k,`Obj_keyword sr -> slift sr, Sstring (Flx_prelex.string_of_token k)

          | (STRING (_,s1) | USER_KEYWORD (_,s1)),
            (`Obj_NAME (sr,s2) | `Obj_USER_KEYWORD (sr,s2))
            ->
            if s1 <> s2 then raise Giveup;
            slift sr,Sstring s1

          | SCHEME_CODE (_,scm,f),
            (`Obj_NAME (sr,s2) | `Obj_USER_KEYWORD (sr,s2))
            ->
            (* set _arg to the symbol *)
            let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_arg") in
            Ocs_env.set_glob env v1 (Sstring s2);
            let result = scheme_eval f in
            begin match result with
            | Snull -> raise Giveup
            | v -> slift sr,v
            end

          | k , _ ->
          print_endline ("Woops, unhandled token=" ^ Flx_prelex.string_of_token k);
          dummysr, Sstring (Flx_prelex.string_of_token k)
        in
        if !(dyp.global_data.pdebug) then begin
          Buffer.add_string b ("Arg " ^ string_of_int n ^ " = ");
          buffer_add_ocs b s; Buffer.add_string b "\n";
        end;
        let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
        Ocs_env.set_glob env v1 s;
        if (match sr with _,l,_,_,_ -> l) <> 0 then srs := sr :: !srs;
        aux t1 t2 (n+1)
    in
    aux rhs avl 1;
    if !(dyp.global_data.pdebug) then
    Buffer.add_string b "End of arguments\n";
    let sr = match !srs with
      | [] -> "dummy:"^name,0,0,0,0
      | sr::_ -> rsrange (List.hd (List.rev !srs)) sr
    in
    begin
      let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_sr") in
      (*
      let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = ssr } in
      *)
      Ocs_env.set_glob env v1 (xsr sr)
    end
    ;
    let r =
      try scheme_eval cde
      with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
        print_string (Buffer.contents b);
        print_string ("Error "^err^" evaluating " ^ scm);
        failwith "Error evaluating Scheme"
    in
    `Obj_sexpr (!age,sr,r),[]
  in
  rule,action,Bind_to_cons [(name, "Obj_sexpr")]

let extend_grammar dyp (dssl,(name,prio,prod,action,anote,sr)) =
  let m = dyp.local_data in
  let dssl_record = Drules.find dssl m.dssls in
  define_scheme sr dyp dssl_record dssl name prio prod action

(* ------------------------------------------------------ *)

(* create rules for nt* nt+ and nt? *)
let fixup_suffix_scheme sr pcounter rhs =
  let rec aux inp out extras = match inp with
  | [] -> List.rev out,extras
  | NONTERMINAL (sr,s,p) :: STAR _ :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__rlist_"^x in
    let sl = s ^ "__list_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"(reverse _1)","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(cons _2 _1)","",rsr in
    let rule2 = sl,`Default,[],"'()","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: PLUS _ :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__nerlist_"^x in
    let sl = s ^ "__nelist_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"(reverse _1)","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(cons _2 _1)","",rsr in
    let rule2 = sl,`Default,[NONTERMINAL(sr,s,`No_prio)],"`(,_1)","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: QUEST _ :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = s ^ "__opt_"^x in
    let rule1 = sl,`Default,[NONTERMINAL(sr,s,p)],"`(,_1)","",rsr in
    let rule2 = sl,`Default,[],"()","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | other :: QUEST sr :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__opt_"^x in
    let rule1 = sl,`Default,[other],"()","",rsr in
    let rule2 = sl,`Default,[],"()","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | h :: t -> aux t (h::out) extras
  in aux rhs [] []

let fixup_suffix_string sr pcounter rhs =
  let rec aux inp out extras = match inp with
  | [] -> List.rev out,extras
  | NONTERMINAL (sr,s,p) :: STAR _ :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__rlist_"^x in
    let sl = s ^ "__list_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"_1","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(strcat `(,_1 ,_2))","",rsr in
    let rule2 = sl,`Default,[],"\"\"","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: PLUS _ :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__nerlist_"^x in
    let sl = s ^ "__nelist_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"_1","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(strcat `(,_1 ,_2))","",rsr in
    let rule2 = sl,`Default,[NONTERMINAL(sr,s,`No_prio)],"_1","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: QUEST _ :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = s ^ "__opt_"^x in
    let rule1 = sl,`Default,[NONTERMINAL(sr,s,p)],"_1","",rsr in
    let rule2 = sl,`Default,[],"\"\"","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | other :: QUEST sr :: t ->
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__opt_"^x in
    let rule1 = sl,`Default,[other],"_1","",rsr in
    let rule2 = sl,`Default,[],"\"\"","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | h :: t -> aux t (h::out) extras
  in aux rhs [] []

let fixup_suffix sr pcounter kind rhs =
  match kind with
  | `Sval -> fixup_suffix_scheme sr pcounter rhs
  | `String -> fixup_suffix_string sr pcounter rhs

let fixup_prio rhs =
  let rec aux inp out = match inp with
  | [] -> List.rev out

  (* Default relation is greater equal *)
  | NAME (sr,s) :: LSQB _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Greatereq_prio p)::out)

  | NAME (sr,s) :: LSQB _ :: LESS _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Less_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: LESSEQUAL _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Lesseq_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: GREATER _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Greater_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: GREATEREQUAL _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Greatereq_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: EQUAL _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Eq_prio p)::out)
   
  | NAME (_,s) :: LSQB sr :: _ -> 
    clierr (slift sr) "Dangling [ in grammar"
 
  | NAME (sr,s) ::t ->
    aux t (NONTERMINAL (sr,s,`No_prio)::out)
  | h :: t -> aux t (h::out)
  in aux rhs []

let dflt_action kind prod =
  let rn = ref 1 in
  let action =
    match kind with
    | `Sval ->
      "`(" ^
      List.fold_left (fun acc _ -> let n = !rn in incr rn;
        (if acc = "" then "" else acc ^ " ") ^ ",_" ^ string_of_int n
      ) "" prod
      ^ ")"

    | `String ->
      "(strcat `(" ^
      List.fold_left (fun acc _ -> let n = !rn in incr rn;
        (if acc = "" then "" else acc ^ " ") ^ ",_" ^ string_of_int n
      ) "" prod
      ^ "))"
  in
  (*
  print_endline ("DEFAULT ACTION for " ^
    catmap " " silly_strtoken prod ^
    " =># " ^ action)
  ;
  *)
  action

let user_expr prod fn : string =
  (* this is a supreme hack .. but it is mandatory because Marshal
     cannot save an Ocs.sval because it can contain primitive
     functions
  *)
  let fn = Ocs_print.string_of_ocs fn in
  (*
  print_endline ("Rendered Ocs sval as " ^ fn);
  *)
  let rn = ref 1 in
  let arg =
    let rec aux acc inp = match inp with
    | [] -> acc
    | `Atom (NAME _) :: `Atom (LSQB _) ::
      `Atom
      (
        EQUAL _ | LESS _ |
        GREATER _ | LESSEQUAL _ |
        GREATEREQUAL _
      ) :: `Atom (NAME _) :: `Atom (RSQB _) :: t

    | `Atom (NAME _) :: t ->
      let n = !rn in incr rn;
      aux
      (
        (if acc = "" then "" else acc ^ " ")
        ^ "(Expression_term ,_" ^ string_of_int n ^ ")"
      ) t

    | `Atom (QUEST _ | PLUS _ | STAR _) :: _
    | `Group _ :: _ ->
      failwith "Production of user expression can't have meta symbols"

    | `Atom k :: t ->
      (* this is really a don't care case .. *)
      let k = silly_strtoken k in
      let n = !rn in incr rn;
      aux
      (
        (if acc = "" then "" else acc ^ " ")
        ^ "(Keyword_term " ^ Flx_string.c_quote_of_string k ^ ")"
      ) t
    in aux "" prod
  in
  let action = "(Apply_term (Expression_term " ^ fn ^ ") (" ^ arg ^ "))" in
  let action = "`(ast_user_expr ,_sr \"dunno\" " ^ action ^ ")" in
  (*
  print_endline ("User expression, action=" ^ action);
  *)
  action

let cal_action kind prod action =
  match action with
  | `None -> dflt_action kind prod
  | `Scheme scm -> scm

let rec flatten sr pcounter kind (rhs: symbol_t list) : token list * rule_t list =
  let rec aux inp out extras = match inp with
  | [] -> List.rev out,extras

  | `Group dyalts :: t ->
    let sr = Flx_srcref.slower sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__grp_"^x in
    let rules : rule_t list = fixup_alternatives pcounter kind sl `Default dyalts in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rules@extras)

  | `Atom h :: t -> aux t (h::out) extras
  in aux rhs [] []

and fixup_rule sr pcounter kind (rhs:symbol_t list) : token list * rule_t list =
  let rhs,extras = flatten sr pcounter kind rhs in
  let rhs, extras =
    fixup_prio rhs,
    List.map (fun (name,prio,prod,action,anote,sr) -> name,prio,fixup_prio prod, action,anote,sr) extras
  in
  let rhs,extras' = fixup_suffix sr pcounter kind rhs in
  rhs,extras@extras'

and fixup_alternatives pcounter kind name prio (dyalts:dyalt_t list) : rule_t list =
  let rules =
    List.fold_left
      (fun rules (rhs,sr,action,anote) ->
        let prod,extras = fixup_rule sr pcounter kind rhs in
        let action : string = cal_action kind prod action in
        ((name,prio,prod,action,anote,sr) :: extras) @ rules
      )
      [] dyalts
  in
  List.rev rules

let add_rule global_data local_data dssl rule =
  let m = local_data in
  let d: dssl_t = try Drules.find dssl m.dssls with Not_found -> fresh_dssl in
  match rule with
  | `Scheme_rule (privacy,name,prio,kind,dyalts) ->
     let rules = fixup_alternatives global_data.pcounter kind name prio dyalts in
     let rules = List.fold_left (fun acc rule -> uniq_add rule acc) d.rules rules in
     let privacy =
       match privacy with
       | `Private ->
          let n = !(global_data.pcounter) in incr (global_data.pcounter);
          let secret = "_"^name^"_"^string_of_int n in
          Drules.add name secret d.privacy
       | `Public -> d.privacy
     in
     let d: dssl_t = {d with rules = rules;  privacy = privacy} in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     global_data,m

  | `Requires ls ->
     let d: dssl_t = {d with deps = ls @ d.deps } in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     global_data,m

  | `Document (name,s) -> global_data,local_data
  | `Page (name,entries) -> global_data, local_data
  | `Priorities p ->
    let d = { d with prios = p::d.prios } in
    let m = {m with dssls=Drules.add dssl d m.dssls } in
    global_data, m

let ocs2flx sr r =
  let sex = Ocs2sex.ocs2sex r in
  (*
  print_endline "OCS scheme term converted to s-expression:";
  Sex_print.sex_print sex;
  *)
  let flx = Flx_sex2flx.xstatement_t sr sex in
  (*
  print_endline "s-expression converted to Felix statement!";
  print_endline (string_of_statement 0 flx);
  *)
  flx

let smerge ((oseq,osr,osex),ogd,old as oit) ((nseq,nsr,nsex),ngd,nld as nit) =
(*
   if !(global_data.pdebug) then
   begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ "\nnxt=" ^ Ocs_print.string_of_ocs nsex);
   end;
*)
   if oseq > nseq then oit
   else if nseq > oseq then nit
   (* else if osex = nsex then oit *)
   else if Ocs_misc.test_equal osex nsex then (
     print_endline ("MERGING EQUAL TERMS! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! =" ^ Ocs_print.string_of_ocs osex);
   oit)
   else begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ "\nnxt=" ^ Ocs_print.string_of_ocs nsex);
     Flx_exceptions.clierr2 osr nsr ("AMBIGUITY PARSING, same production!,seq = " ^ string_of_int nseq)
   end

let dyp_merge_Obj_sexpr ol =
 match ol with
 | [] -> assert false
(* | [_] -> assert false *)
 | [ntt,gd,ld] -> [ntt],gd,ld

 | h :: t ->
   match List.fold_left smerge h t with
   ntt,gd,ld -> [ntt],gd,ld

let rec elim_common_prefix x y =
  match x, y with
  | a :: ta, b :: tb ->
    let eq = try a = b with _ -> false in
    if eq then elim_common_prefix ta tb
    else x,y

  | x,y -> x,y

let ssmerge ((xseq,x),xgd,xld as xit) ((yseq,y),ygd,yld as yit) =
   if xseq > yseq then xit
   else if yseq > xseq then yit
   else
   let xsr = src_of_stmt (List.hd x) and ysr = src_of_stmt (List.hd y) in
   print_endline "Ambiguity parsing statements:";
   let x = List.rev x and y = List.rev y in
   let x,y = elim_common_prefix x y in
   print_endline ("Statements 1 = " ^ catmap "\n----\n" (string_of_statement 1) x);
   print_endline ("Statement 2 = " ^ catmap "\n----\n" (string_of_statement 1) y);
   Flx_exceptions.clierr2 xsr ysr "AMBIGUITY PARSING TOP LEVEL!"

let dyp_merge_Obj_statement_star ol =
 match ol with
 | []
 | [_] -> assert false
 | h::t ->
   match List.fold_left ssmerge h t with
   | ntt,gd,ld -> [ntt],gd,ld

}


/* special */
%token <(Flx_ast.srcref * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE
%token SLOSH
%token <(string)> COMMENT
%token <(string)> COMMENT_NEWLINE
%token <(int)> WHITE

/* literals */
%token <(Flx_ast.srcref * string)> NAME
%token <(Flx_ast.srcref * string * prio_t)> NONTERMINAL
%token <(Flx_ast.srcref * string * Flx_ast.bigint)> INTEGER
%token <(Flx_ast.srcref * string * string )> FLOAT
%token <(Flx_ast.srcref * string)> STRING
%token <(Flx_ast.srcref * string)> CSTRING
%token <(Flx_ast.srcref * string)> FSTRING
%token <(Flx_ast.srcref * string)> QSTRING
%token <(Flx_ast.srcref * string)> WSTRING
%token <(Flx_ast.srcref * string)> USTRING
%token <(Flx_ast.srcref * string)> USER_KEYWORD
%token <(string list)> HASH_INCLUDE_FILES
%token <(token list)> TOKEN_LIST
%token DUMMY

%token <local_data_t> LOAD_SYNTAX
%token <string> SAVE_SYNTAX

%token <(Flx_ast.srcref * string * Ocs_types.code)> SCHEME_CODE

%token <(Flx_ast.srcref)> DOLLAR
%constructor Obj_keyword %for DOLLAR
%token <(Flx_ast.srcref)> QUEST
%constructor Obj_keyword %for QUEST
%token <(Flx_ast.srcref)> EXCLAMATION
%constructor Obj_keyword %for EXCLAMATION
%token <(Flx_ast.srcref)> LPAR
%constructor Obj_keyword %for LPAR
%token <(Flx_ast.srcref)> RPAR
%constructor Obj_keyword %for RPAR
%token <(Flx_ast.srcref)> LSQB
%constructor Obj_keyword %for LSQB
%token <(Flx_ast.srcref)> RSQB
%constructor Obj_keyword %for RSQB
%token <(Flx_ast.srcref)> LBRACE
%constructor Obj_keyword %for LBRACE
%token <(Flx_ast.srcref)> RBRACE
%constructor Obj_keyword %for RBRACE
%token <(Flx_ast.srcref)> COLON
%constructor Obj_keyword %for COLON
%token <(Flx_ast.srcref)> COMMA
%constructor Obj_keyword %for COMMA
%token <(Flx_ast.srcref)> SEMI
%constructor Obj_keyword %for SEMI
%token <(Flx_ast.srcref)> PLUS
%constructor Obj_keyword %for PLUS
%token <(Flx_ast.srcref)> MINUS
%constructor Obj_keyword %for MINUS
%token <(Flx_ast.srcref)> STAR
%constructor Obj_keyword %for STAR
%token <(Flx_ast.srcref)> SLASH
%constructor Obj_keyword %for SLASH
%token <(Flx_ast.srcref)> VBAR
%constructor Obj_keyword %for VBAR
%token <(Flx_ast.srcref)> AMPER
%constructor Obj_keyword %for AMPER
%token <(Flx_ast.srcref)> LESS
%constructor Obj_keyword %for LESS
%token <(Flx_ast.srcref)> GREATER
%constructor Obj_keyword %for GREATER
%token <(Flx_ast.srcref)> EQUAL
%constructor Obj_keyword %for EQUAL
%token <(Flx_ast.srcref)> DOT
%constructor Obj_keyword %for DOT
%token <(Flx_ast.srcref)> PERCENT
%constructor Obj_keyword %for PERCENT
%token <(Flx_ast.srcref)> BACKQUOTE
%constructor Obj_keyword %for BACKQUOTE
%token <(Flx_ast.srcref)> TILDE
%constructor Obj_keyword %for TILDE
%token <(Flx_ast.srcref)> CIRCUMFLEX
%constructor Obj_keyword %for CIRCUMFLEX
%token <(Flx_ast.srcref)> HASH
%constructor Obj_keyword %for HASH
%token <(Flx_ast.srcref)> DOLLARDOLLAR
%constructor Obj_keyword %for DOLLARDOLLAR
%token <(Flx_ast.srcref)> ANDLESS
%constructor Obj_keyword %for ANDLESS
%token <(Flx_ast.srcref)> ANDGREATER
%constructor Obj_keyword %for ANDGREATER
%token <(Flx_ast.srcref)> EQEQUAL
%constructor Obj_keyword %for EQEQUAL
%token <(Flx_ast.srcref)> NOTEQUAL
%constructor Obj_keyword %for NOTEQUAL
%token <(Flx_ast.srcref)> LESSEQUAL
%constructor Obj_keyword %for LESSEQUAL
%token <(Flx_ast.srcref)> GREATEREQUAL
%constructor Obj_keyword %for GREATEREQUAL
%token <(Flx_ast.srcref)> LEFTSHIFT
%constructor Obj_keyword %for LEFTSHIFT
%token <(Flx_ast.srcref)> RIGHTSHIFT
%constructor Obj_keyword %for RIGHTSHIFT
%token <(Flx_ast.srcref)> STARSTAR
%constructor Obj_keyword %for STARSTAR
%token <(Flx_ast.srcref)> LESSCOLON
%constructor Obj_keyword %for LESSCOLON
%token <(Flx_ast.srcref)> COLONGREATER
%constructor Obj_keyword %for COLONGREATER
%token <(Flx_ast.srcref)> DOTDOT
%constructor Obj_keyword %for DOTDOT
%token <(Flx_ast.srcref)> COLONCOLON
%constructor Obj_keyword %for COLONCOLON
%token <(Flx_ast.srcref)> PLUSPLUS
%constructor Obj_keyword %for PLUSPLUS
%token <(Flx_ast.srcref)> MINUSMINUS
%constructor Obj_keyword %for MINUSMINUS
%token <(Flx_ast.srcref)> PLUSEQUAL
%constructor Obj_keyword %for PLUSEQUAL
%token <(Flx_ast.srcref)> MINUSEQUAL
%constructor Obj_keyword %for MINUSEQUAL
%token <(Flx_ast.srcref)> STAREQUAL
%constructor Obj_keyword %for STAREQUAL
%token <(Flx_ast.srcref)> SLASHEQUAL
%constructor Obj_keyword %for SLASHEQUAL
%token <(Flx_ast.srcref)> PERCENTEQUAL
%constructor Obj_keyword %for PERCENTEQUAL
%token <(Flx_ast.srcref)> CARETEQUAL
%constructor Obj_keyword %for CARETEQUAL
%token <(Flx_ast.srcref)> VBAREQUAL
%constructor Obj_keyword %for VBAREQUAL
%token <(Flx_ast.srcref)> AMPEREQUAL
%constructor Obj_keyword %for AMPEREQUAL
%token <(Flx_ast.srcref)> TILDEEQUAL
%constructor Obj_keyword %for TILDEEQUAL
%token <(Flx_ast.srcref)> COLONEQUAL
%constructor Obj_keyword %for COLONEQUAL
%token <(Flx_ast.srcref)> RIGHTARROW
%constructor Obj_keyword %for RIGHTARROW
%token <(Flx_ast.srcref)> EQRIGHTARROW
%constructor Obj_keyword %for EQRIGHTARROW
%token <(Flx_ast.srcref)> LEFTARROW
%constructor Obj_keyword %for LEFTARROW
%token <(Flx_ast.srcref)> LSQBAR
%constructor Obj_keyword %for LSQBAR
%token <(Flx_ast.srcref)> RSQBAR
%constructor Obj_keyword %for RSQBAR
%token <(Flx_ast.srcref)> AMPERAMPER
%constructor Obj_keyword %for AMPERAMPER
%token <(Flx_ast.srcref)> VBARVBAR
%constructor Obj_keyword %for VBARVBAR
%token <(Flx_ast.srcref)> SLOSHAMPER
%constructor Obj_keyword %for SLOSHAMPER
%token <(Flx_ast.srcref)> SLOSHVBAR
%constructor Obj_keyword %for SLOSHVBAR
%token <(Flx_ast.srcref)> SLOSHCIRCUMFLEX
%constructor Obj_keyword %for SLOSHCIRCUMFLEX
%token <(Flx_ast.srcref)> HASHBANG
%constructor Obj_keyword %for HASHBANG
%token <(Flx_ast.srcref)> LEFTSHIFTEQUAL
%constructor Obj_keyword %for LEFTSHIFTEQUAL
%token <(Flx_ast.srcref)> RIGHTSHIFTEQUAL
%constructor Obj_keyword %for RIGHTSHIFTEQUAL
%token <(Flx_ast.srcref)> LEFTRIGHTARROW
%constructor Obj_keyword %for LEFTRIGHTARROW
%token <(Flx_ast.srcref)> ANDEQEQUAL
%constructor Obj_keyword %for ANDEQEQUAL
%token <(Flx_ast.srcref)> ANDNOTEQUAL
%constructor Obj_keyword %for ANDNOTEQUAL
%token <(Flx_ast.srcref)> ANDLESSEQUAL
%constructor Obj_keyword %for ANDLESSEQUAL
%token <(Flx_ast.srcref)> ANDGREATEREQUAL
%constructor Obj_keyword %for ANDGREATEREQUAL
%token <(Flx_ast.srcref)> DOTDOTDOT
%constructor Obj_keyword %for DOTDOTDOT
%token <(Flx_ast.srcref)> LONGRIGHTARROW
%constructor Obj_keyword %for LONGRIGHTARROW
%token <(Flx_ast.srcref)> PARSE_ACTION
%constructor Obj_keyword %for PARSE_ACTION
%token <(Flx_ast.srcref)> HASHBANGSLASH
%constructor Obj_keyword %for HASHBANGSLASH
%token <(Flx_ast.srcref)> ALL
%constructor Obj_keyword %for ALL
%token <(Flx_ast.srcref)> ASSERT
%constructor Obj_keyword %for ASSERT
%token <(Flx_ast.srcref)> AXIOM
%constructor Obj_keyword %for AXIOM
%token <(Flx_ast.srcref)> BODY
%constructor Obj_keyword %for BODY
%token <(Flx_ast.srcref)> CALL
%constructor Obj_keyword %for CALL
%token <(Flx_ast.srcref)> CASE
%constructor Obj_keyword %for CASE
%token <(Flx_ast.srcref)> CASENO
%constructor Obj_keyword %for CASENO
%token <(Flx_ast.srcref)> CFUNCTION
%constructor Obj_keyword %for CFUNCTION
%token <(Flx_ast.srcref)> CLASS
%constructor Obj_keyword %for CLASS
%token <(Flx_ast.srcref)> COMMENT_KEYWORD
%constructor Obj_keyword %for COMMENT_KEYWORD
%token <(Flx_ast.srcref)> COMPOUND
%constructor Obj_keyword %for COMPOUND
%token <(Flx_ast.srcref)> CONST
%constructor Obj_keyword %for CONST
%token <(Flx_ast.srcref)> CPROCEDURE
%constructor Obj_keyword %for CPROCEDURE
%token <(Flx_ast.srcref)> CSTRUCT
%constructor Obj_keyword %for CSTRUCT
%token <(Flx_ast.srcref)> CTOR
%constructor Obj_keyword %for CTOR
%token <(Flx_ast.srcref)> CTYPES
%constructor Obj_keyword %for CTYPES
%token <(Flx_ast.srcref)> DEF
%constructor Obj_keyword %for DEF
%token <(Flx_ast.srcref)> DO
%constructor Obj_keyword %for DO
%token <(Flx_ast.srcref)> DONE
%constructor Obj_keyword %for DONE
%token <(Flx_ast.srcref)> ELIF
%constructor Obj_keyword %for ELIF
%token <(Flx_ast.srcref)> ELSE
%constructor Obj_keyword %for ELSE
%token <(Flx_ast.srcref)> ENDCASE
%constructor Obj_keyword %for ENDCASE
%token <(Flx_ast.srcref)> ENDIF
%constructor Obj_keyword %for ENDIF
%token <(Flx_ast.srcref)> ENDMATCH
%constructor Obj_keyword %for ENDMATCH
%token <(Flx_ast.srcref)> ENUM
%constructor Obj_keyword %for ENUM
%token <(Flx_ast.srcref)> EXPECT
%constructor Obj_keyword %for EXPECT
%token <(Flx_ast.srcref)> EXPORT
%constructor Obj_keyword %for EXPORT
%token <(Flx_ast.srcref)> EXTERN
%constructor Obj_keyword %for EXTERN
%token <(Flx_ast.srcref)> FOR
%constructor Obj_keyword %for FOR
%token <(Flx_ast.srcref)> FORGET
%constructor Obj_keyword %for FORGET
%token <(Flx_ast.srcref)> FORK
%constructor Obj_keyword %for FORK
%token <(Flx_ast.srcref)> FUNCTOR
%constructor Obj_keyword %for FUNCTOR
%token <(Flx_ast.srcref)> FUNCTION
%constructor Obj_keyword %for FUNCTION
%token <(Flx_ast.srcref)> GENERATOR
%constructor Obj_keyword %for GENERATOR
%token <(Flx_ast.srcref)> GOTO
%constructor Obj_keyword %for GOTO
%token <(Flx_ast.srcref)> HALT
%constructor Obj_keyword %for HALT
%token <(Flx_ast.srcref)> HEADER
%constructor Obj_keyword %for HEADER
%token <(Flx_ast.srcref)> IDENT
%constructor Obj_keyword %for IDENT
%token <(Flx_ast.srcref)> INCLUDE
%constructor Obj_keyword %for INCLUDE
%token <(Flx_ast.srcref)> INCOMPLETE
%constructor Obj_keyword %for INCOMPLETE
%token <(Flx_ast.srcref)> INF
%constructor Obj_keyword %for INF
%token <(Flx_ast.srcref)> IN
%constructor Obj_keyword %for IN
%token <(Flx_ast.srcref)> INSTANCE
%constructor Obj_keyword %for INSTANCE
%token <(Flx_ast.srcref)> IS
%constructor Obj_keyword %for IS
%token <(Flx_ast.srcref)> INHERIT
%constructor Obj_keyword %for INHERIT
%token <(Flx_ast.srcref)> INLINE
%constructor Obj_keyword %for INLINE
%token <(Flx_ast.srcref)> JUMP
%constructor Obj_keyword %for JUMP
%token <(Flx_ast.srcref)> LEMMA
%constructor Obj_keyword %for LEMMA
%token <(Flx_ast.srcref)> LET
%constructor Obj_keyword %for LET
%token <(Flx_ast.srcref)> LOOP
%constructor Obj_keyword %for LOOP
%token <(Flx_ast.srcref)> LVAL
%constructor Obj_keyword %for LVAL
%token <(Flx_ast.srcref)> MACRO
%constructor Obj_keyword %for MACRO
%token <(Flx_ast.srcref)> MODULE
%constructor Obj_keyword %for MODULE
%token <(Flx_ast.srcref)> NAMESPACE
%constructor Obj_keyword %for NAMESPACE
%token <(Flx_ast.srcref)> NAN
%constructor Obj_keyword %for NAN
%token <(Flx_ast.srcref)> NEW
%constructor Obj_keyword %for NEW
%token <(Flx_ast.srcref)> NOINLINE
%constructor Obj_keyword %for NOINLINE
%token <(Flx_ast.srcref)> NONTERM
%constructor Obj_keyword %for NONTERM
%token <(Flx_ast.srcref)> NORETURN
%constructor Obj_keyword %for NORETURN
%token <(Flx_ast.srcref)> NOT
%constructor Obj_keyword %for NOT
%token <(Flx_ast.srcref)> OPEN
%constructor Obj_keyword %for OPEN
%token <(Flx_ast.srcref)> PACKAGE
%constructor Obj_keyword %for PACKAGE
%token <(Flx_ast.srcref)> POD
%constructor Obj_keyword %for POD
%token <(Flx_ast.srcref)> PRIVATE
%constructor Obj_keyword %for PRIVATE
%token <(Flx_ast.srcref)> PROCEDURE
%constructor Obj_keyword %for PROCEDURE
%token <(Flx_ast.srcref)> PROPERTY
%constructor Obj_keyword %for PROPERTY
%token <(Flx_ast.srcref)> REDUCE
%constructor Obj_keyword %for REDUCE
%token <(Flx_ast.srcref)> REF
%constructor Obj_keyword %for REF
%token <(Flx_ast.srcref)> RENAME
%constructor Obj_keyword %for RENAME
%token <(Flx_ast.srcref)> REQUIRES
%constructor Obj_keyword %for REQUIRES
%token <(Flx_ast.srcref)> RETURN
%constructor Obj_keyword %for RETURN
%token <(Flx_ast.srcref)> SCHEME
%constructor Obj_keyword %for SCHEME
%token <(Flx_ast.srcref)> SYNTAX
%constructor Obj_keyword %for SYNTAX
%token <(Flx_ast.srcref)> STATIC
%constructor Obj_keyword %for STATIC
%token <(Flx_ast.srcref)> STRUCT
%constructor Obj_keyword %for STRUCT
%token <(Flx_ast.srcref)> THEN
%constructor Obj_keyword %for THEN
%token <(Flx_ast.srcref)> TODO
%constructor Obj_keyword %for TODO
%token <(Flx_ast.srcref)> TO
%constructor Obj_keyword %for TO
%token <(Flx_ast.srcref)> TYPEDEF
%constructor Obj_keyword %for TYPEDEF
%token <(Flx_ast.srcref)> TYPE
%constructor Obj_keyword %for TYPE
%token <(Flx_ast.srcref)> TYPECLASS
%constructor Obj_keyword %for TYPECLASS
%token <(Flx_ast.srcref)> UNION
%constructor Obj_keyword %for UNION
%token <(Flx_ast.srcref)> USE
%constructor Obj_keyword %for USE
%token <(Flx_ast.srcref)> VAL
%constructor Obj_keyword %for VAL
%token <(Flx_ast.srcref)> VAR
%constructor Obj_keyword %for VAR
%token <(Flx_ast.srcref)> VIRTUAL
%constructor Obj_keyword %for VIRTUAL
%token <(Flx_ast.srcref)> WHERE
%constructor Obj_keyword %for WHERE
%token <(Flx_ast.srcref)> WHEN
%constructor Obj_keyword %for WHEN
%token <(Flx_ast.srcref)> WITH
%constructor Obj_keyword %for WITH
%token <(Flx_ast.srcref)> YIELD
%constructor Obj_keyword %for YIELD
%token <(Flx_ast.srcref)> GC_POINTER
%constructor Obj_keyword %for GC_POINTER
%token <(Flx_ast.srcref)> GC_TYPE
%constructor Obj_keyword %for GC_TYPE
%token <(Flx_ast.srcref)> SVC
%constructor Obj_keyword %for SVC
%token <(Flx_ast.srcref)> DEREF
%constructor Obj_keyword %for DEREF
%token <(Flx_ast.srcref)> AND
%constructor Obj_keyword %for AND
%token <(Flx_ast.srcref)> AS
%constructor Obj_keyword %for AS
%token <(Flx_ast.srcref)> CALLBACK
%constructor Obj_keyword %for CALLBACK
%token <(Flx_ast.srcref)> CODE
%constructor Obj_keyword %for CODE
%token <(Flx_ast.srcref)> FALSE
%constructor Obj_keyword %for FALSE
%token <(Flx_ast.srcref)> IF
%constructor Obj_keyword %for IF
%token <(Flx_ast.srcref)> ISIN
%constructor Obj_keyword %for ISIN
%token <(Flx_ast.srcref)> MATCH
%constructor Obj_keyword %for MATCH
%token <(Flx_ast.srcref)> NOEXPAND
%constructor Obj_keyword %for NOEXPAND
%token <(Flx_ast.srcref)> OF
%constructor Obj_keyword %for OF
%token <(Flx_ast.srcref)> OR
%constructor Obj_keyword %for OR
%token <(Flx_ast.srcref)> THE
%constructor Obj_keyword %for THE
%token <(Flx_ast.srcref)> TRUE
%constructor Obj_keyword %for TRUE
%token <(Flx_ast.srcref)> TYPEMATCH
%constructor Obj_keyword %for TYPEMATCH
%token <(Flx_ast.srcref)> TYPECASE
%constructor Obj_keyword %for TYPECASE
%token <(Flx_ast.srcref)> WHENCE
%constructor Obj_keyword %for WHENCE
%token <(Flx_ast.srcref)> UNLESS
%constructor Obj_keyword %for UNLESS
%token <(Flx_ast.srcref)> UNDERSCORE
%constructor Obj_keyword %for UNDERSCORE
/* top level entry */
%constructor Obj_sexpr %for sterm

/* predefined major non-terminals */
%constructor Obj_sexpr %for statement sexpr
%constructor Obj_sexpr %for sstatements

/* low level non terminals */
%constructor Obj_sexpr %for sname sliteral

/* literals */
%constructor Obj_sexpr %for sinteger sfloat sstring scstring strue sfalse
%constructor Obj_sexpr %for strint strfloat strstring strtrue strfalse

/* patterns */
%constructor Obj_sexpr %for sintegral

/* tokens replacements for special symbols used in productions */
%constructor Obj_sexpr %for star plus quest sident
%constructor Obj_sexpr %for lbrace rbrace lpar rpar lsqb rsqb
%constructor Obj_sexpr %for ssemi comma colon vbar



/* nothing*/
%constructor Obj_sexpr %for sepsilon
%constructor Obj_sexpr %for strepsilon

%start <(Flx_ast.compilation_unit_t * local_data_t)> compilation_unit

%lexer

/* ====================== REGULAR DEFINITIONS ============================ */
/* special characters */
let quote = '\''
let dquote = '"'
let slosh = '\\'
let linefeed = '\n'
let tab = '\t'
let space = ' '
let formfeed = '\012'
let vtab = '\011'
let carriage_return = '\013'
let underscore = '_'

/* character sets */
let bindigit = ['0'-'1']
let octdigit = ['0'-'7']
let digit = ['0'-'9']
let hexdigit = digit | ['A'-'F'] | ['a'-'f']
let lower = ['a'-'z']
let upper = ['A'-'Z']
/* let letter = lower | upper */
let letter = lower | upper
let hichar = ['\128'-'\255']
let white = space | tab

/* nasty: form control characters */
let form_control = linefeed | carriage_return | vtab | formfeed
let newline_prefix = linefeed | carriage_return
let newline = formfeed | linefeed  | carriage_return linefeed
let hash = '#'

let ordinary = letter | digit | hichar |
  '!' | '$' | '%' | '&' | '(' | ')' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' | '_' |
  '`' | '{' | '|' | '}' | '~'

/* any sequence of these characters makes one or more tokens */
/* MISSING: # should be in here, but can't be supported atm
  because preprocessor # uses a conditional, and just errors
  out if the # isn't at the start of a line .. needs fixing,
  not sure how to fix it
*/

let symchar =
  '!' | '$' | '%' | '&' | '(' | ')' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' |
  '`' | '{' | '|' | '}' | '~' | '#' | '\\'

let printable = ordinary | quote | dquote | slosh | hash

/* identifiers */
let ucn =
    "\\u" hexdigit hexdigit hexdigit hexdigit
  | "\\U" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit

let prime = '\''
let idletter = letter | underscore | hichar | ucn
let identifier = idletter (idletter | digit | prime )*

/* integers */
let bin_lit  = '0' ('b' | 'B') (underscore? bindigit) +
let oct_lit  = '0' ('o' | 'O') (underscore? octdigit) +
let dec_lit  = ('0' ('d' | 'D'| "d_" | "D_"))? digit (underscore? digit) *
let hex_lit  = '0' ('x' | 'X') (underscore? hexdigit)  +
let fastint_type_suffix = 't'|'T'|'s'|'S'|'i'|'I'|'l'|'L'|'v'|'V'|"ll"|"LL"
let exactint_type_suffix =
    "i8" | "i16" | "i32" | "i64"
  | "u8" | "u16" | "u32" | "u64"
  | "I8" | "I16" | "I32" | "I64"
  | "U8" | "U16" | "U32" | "U64"

let signind = 'u' | 'U'

let suffix =
    '_'? exactint_type_suffix
  | ('_'? fastint_type_suffix)? ('_'? signind)?
  | ('_'? signind)? ('_'? fastint_type_suffix)?

let int_lit = (bin_lit | oct_lit | dec_lit | hex_lit) suffix

/* floats: Follows ISO C89, except that we allow underscores */
let decimal_string = digit (underscore? digit) *
let hexadecimal_string = hexdigit (underscore? hexdigit) *

let decimal_fractional_constant =
  decimal_string '.' decimal_string?
  | '.' decimal_string

let hexadecimal_fractional_constant =
  ("0x" |"0X")
  (hexadecimal_string '.' hexadecimal_string?
  | '.' hexadecimal_string)

let decimal_exponent = ('E'|'e') ('+'|'-')? decimal_string
let binary_exponent = ('P'|'p') ('+'|'-')? decimal_string

let floating_suffix = 'L' | 'l' | 'F' | 'f' | 'D' | 'd'
let floating_literal =
  (
    decimal_fractional_constant decimal_exponent? |
    hexadecimal_fractional_constant binary_exponent?
  )
  floating_suffix?

/* Python strings */
let qqq = quote quote quote
let ddd = dquote dquote dquote

let escape = slosh _

let dddnormal = ordinary | hash | quote | escape | white | newline
let dddspecial = dddnormal | dquote dddnormal | dquote dquote dddnormal

let qqqnormal = ordinary | hash | dquote | escape | white | newline
let qqqspecial = qqqnormal | quote qqqnormal | quote quote qqqnormal

let raw_dddnormal = ordinary | hash | quote | slosh | white | newline
let raw_dddspecial = raw_dddnormal | dquote raw_dddnormal | dquote dquote raw_dddnormal

let raw_qqqnormal = ordinary | hash | dquote | slosh | space | newline
let raw_qqqspecial = raw_qqqnormal | quote raw_qqqnormal | quote quote raw_qqqnormal

let qstring = (ordinary | hash | dquote | escape | white) * quote
let dstring = (ordinary | hash | quote | escape | white) * dquote
let qqqstring = qqqspecial * qqq
let dddstring = dddspecial * ddd

let raw = 'r' | 'R'
let see = 'c' | 'C'
let rqc = raw see | see raw

let raw_qstring = (ordinary | hash | dquote | escape | white) * quote
let raw_dstring =  (ordinary | hash | quote | escape | white) * dquote

let raw_qqqstring = raw_qqqspecial * qqq
let raw_dddstring = raw_dddspecial * ddd

let not_hash_or_newline = ordinary | quote | dquote | white | slosh
let not_newline = not_hash_or_newline | hash
let quoted_filename = dquote (ordinary | hash | quote | white | slosh)+ dquote


rule parse_qstring = parse
| qstring {
       
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
      (
        getsr lexbuf,
        decode_qstring s
      )
  }

and parse_dstring = parse
| dstring {
       
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
      (
        getsr lexbuf,
        decode_dstring s
      )
  }

and parse_qqqstring = parse
| qqqstring {
       
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
      (
        getsr lexbuf,
        decode_qqqstring s
      )
  }

and parse_dddstring = parse
| dddstring {
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
       
       (
        getsr lexbuf,
        decode_dddstring s
      )
  }

/* ----------- RAW STRING -----------------------------------*/
and parse_raw_qstring = parse
| raw_qstring {
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
       
      (
        getsr lexbuf,
        decode_raw_qstring s
      )
  }

and parse_raw_dstring = parse
| raw_dstring {
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
       
      (
        getsr lexbuf,
        decode_raw_dstring s
      )
  }

and parse_raw_qqqstring = parse
| raw_qqqstring {
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
       
      (
        getsr lexbuf,
        decode_raw_qqqstring s
      )
  }

and parse_raw_dddstring = parse
| raw_dddstring {
      let s = lexeme lexbuf in
      let n = lfcount s in
      incr_lineno lexbuf n; 
       
      (
        getsr lexbuf,
        decode_raw_dddstring s
      )
  }

and parse_hashbang = parse
| not_newline * newline {
      incr_lineno lexbuf 1
  }

and parse_C_comment count = parse
| "/*"    { parse_C_comment (count+1) lexbuf }
| newline { incr_lineno lexbuf 1; parse_C_comment count lexbuf }
| "*/"    { if count = 1 then () else parse_C_comment (count - 1) lexbuf }
| _       { parse_C_comment count lexbuf }

and parse_line = parse
| not_newline * (newline | eof)
  {
    incr_lineno lexbuf 1;
    lexeme lexbuf
  }

main lexer =
  "all" -> ALL { getsr lexbuf }
  "assert" -> ASSERT { getsr lexbuf }
  "axiom" -> AXIOM { getsr lexbuf }
  "body" -> BODY { getsr lexbuf }
  "call" -> CALL { getsr lexbuf }
  "case" -> CASE { getsr lexbuf }
  "caseno" -> CASENO { getsr lexbuf }
  "cfun" -> CFUNCTION { getsr lexbuf }
  "class" -> CLASS { getsr lexbuf }
  "comment" -> COMMENT_KEYWORD { getsr lexbuf }
  "compound" -> COMPOUND { getsr lexbuf }
  "const" -> CONST { getsr lexbuf }
  "cproc" -> CPROCEDURE { getsr lexbuf }
  "cstruct" -> CSTRUCT { getsr lexbuf }
  "ctor" -> CTOR { getsr lexbuf }
  "ctypes" -> CTYPES { getsr lexbuf }
  "def" -> DEF { getsr lexbuf }
  "do" -> DO { getsr lexbuf }
  "done" -> DONE { getsr lexbuf }
  "elif" -> ELIF { getsr lexbuf }
  "else" -> ELSE { getsr lexbuf }
  "endcase" -> ENDCASE { getsr lexbuf }
  "endif" -> ENDIF { getsr lexbuf }
  "endmatch" -> ENDMATCH { getsr lexbuf }
  "enum" -> ENUM { getsr lexbuf }
  "expect" -> EXPECT { getsr lexbuf }
  "export" -> EXPORT { getsr lexbuf }
  "extern" -> EXTERN { getsr lexbuf }
  "for" -> FOR { getsr lexbuf }
  "forget" -> FORGET { getsr lexbuf }
  "fork" -> FORK { getsr lexbuf }
  "functor" -> FUNCTOR { getsr lexbuf }
  "fun" -> FUNCTION { getsr lexbuf }
  "gen" -> GENERATOR { getsr lexbuf }
  "goto" -> GOTO { getsr lexbuf }
  "halt" -> HALT { getsr lexbuf }
  "header" -> HEADER { getsr lexbuf }
  "ident" -> IDENT { getsr lexbuf }
  "include" -> INCLUDE { getsr lexbuf }
  "incomplete" -> INCOMPLETE { getsr lexbuf }
  "inf" -> INF { getsr lexbuf }
  "in" -> IN { getsr lexbuf }
  "instance" -> INSTANCE { getsr lexbuf }
  "is" -> IS { getsr lexbuf }
  "inherit" -> INHERIT { getsr lexbuf }
  "inline" -> INLINE { getsr lexbuf }
  "jump" -> JUMP { getsr lexbuf }
  "lemma" -> LEMMA { getsr lexbuf }
  "let" -> LET { getsr lexbuf }
  "loop" -> LOOP { getsr lexbuf }
  "lval" -> LVAL { getsr lexbuf }
  "macro" -> MACRO { getsr lexbuf }
  "module" -> MODULE { getsr lexbuf }
  "namespace" -> NAMESPACE { getsr lexbuf }
  "NaN" -> NAN { getsr lexbuf }
  "new" -> NEW { getsr lexbuf }
  "noinline" -> NOINLINE { getsr lexbuf }
  "nonterm" -> NONTERM { getsr lexbuf }
  "noreturn" -> NORETURN { getsr lexbuf }
  "not" -> NOT { getsr lexbuf }
  "open" -> OPEN { getsr lexbuf }
  "package" -> PACKAGE { getsr lexbuf }
  "pod" -> POD { getsr lexbuf }
  "private" -> PRIVATE { getsr lexbuf }
  "proc" -> PROCEDURE { getsr lexbuf }
  "property" -> PROPERTY { getsr lexbuf }
  "reduce" -> REDUCE { getsr lexbuf }
  "ref" -> REF { getsr lexbuf }
  "rename" -> RENAME { getsr lexbuf }
  "requires" -> REQUIRES { getsr lexbuf }
  "return" -> RETURN { getsr lexbuf }
  "SCHEME" -> SCHEME { getsr lexbuf }
  "syntax" -> SYNTAX { getsr lexbuf }
  "static" -> STATIC { getsr lexbuf }
  "struct" -> STRUCT { getsr lexbuf }
  "then" -> THEN { getsr lexbuf }
  "todo" -> TODO { getsr lexbuf }
  "to" -> TO { getsr lexbuf }
  "typedef" -> TYPEDEF { getsr lexbuf }
  "type" -> TYPE { getsr lexbuf }
  "typeclass" -> TYPECLASS { getsr lexbuf }
  "union" -> UNION { getsr lexbuf }
  "use" -> USE { getsr lexbuf }
  "val" -> VAL { getsr lexbuf }
  "var" -> VAR { getsr lexbuf }
  "virtual" -> VIRTUAL { getsr lexbuf }
  "where" -> WHERE { getsr lexbuf }
  "when" -> WHEN { getsr lexbuf }
  "with" -> WITH { getsr lexbuf }
  "yield" -> YIELD { getsr lexbuf }
  "_gc_pointer" -> GC_POINTER { getsr lexbuf }
  "_gc_type" -> GC_TYPE { getsr lexbuf }
  "_svc" -> SVC { getsr lexbuf }
  "_deref" -> DEREF { getsr lexbuf }
  "and" -> AND { getsr lexbuf }
  "as" -> AS { getsr lexbuf }
  "callback" -> CALLBACK { getsr lexbuf }
  "code" -> CODE { getsr lexbuf }
  "false" -> FALSE { getsr lexbuf }
  "if" -> IF { getsr lexbuf }
  "isin" -> ISIN { getsr lexbuf }
  "match" -> MATCH { getsr lexbuf }
  "noexpand" -> NOEXPAND { getsr lexbuf }
  "of" -> OF { getsr lexbuf }
  "or" -> OR { getsr lexbuf }
  "the" -> THE { getsr lexbuf }
  "true" -> TRUE { getsr lexbuf }
  "typematch" -> TYPEMATCH { getsr lexbuf }
  "typecase" -> TYPECASE { getsr lexbuf }
  "whence" -> WHENCE { getsr lexbuf }
  "unless" -> UNLESS { getsr lexbuf }
  "_" -> UNDERSCORE { getsr lexbuf }

  "$" -> DOLLAR { getsr lexbuf }
  "?" -> QUEST { getsr lexbuf }
  "!" -> EXCLAMATION { getsr lexbuf }
  "(" -> LPAR { getsr lexbuf }
  ")" -> RPAR { getsr lexbuf }
  "[" -> LSQB { getsr lexbuf }
  "]" -> RSQB { getsr lexbuf }
  "{" -> LBRACE { getsr lexbuf }
  "}" -> RBRACE { getsr lexbuf }
  ":" -> COLON { getsr lexbuf }
  "," -> COMMA { getsr lexbuf }
  ";" -> SEMI { getsr lexbuf }
  "+" -> PLUS { getsr lexbuf }
  "-" -> MINUS { getsr lexbuf }
  "*" -> STAR { getsr lexbuf }
  "/" -> SLASH { getsr lexbuf }
  "|" -> VBAR { getsr lexbuf }
  "&" -> AMPER { getsr lexbuf }
  "<" -> LESS { getsr lexbuf }
  ">" -> GREATER { getsr lexbuf }
  "=" -> EQUAL { getsr lexbuf }
  "." -> DOT { getsr lexbuf }
  "%" -> PERCENT { getsr lexbuf }
  "`" -> BACKQUOTE { getsr lexbuf }
  "~" -> TILDE { getsr lexbuf }
  "^" -> CIRCUMFLEX { getsr lexbuf }
  "#" -> HASH { getsr lexbuf }
  "$$" -> DOLLARDOLLAR { getsr lexbuf }
  "&<" -> ANDLESS { getsr lexbuf }
  "&>" -> ANDGREATER { getsr lexbuf }
  "==" -> EQEQUAL { getsr lexbuf }
  "!=" -> NOTEQUAL { getsr lexbuf }
  "<=" -> LESSEQUAL { getsr lexbuf }
  ">=" -> GREATEREQUAL { getsr lexbuf }
  "<<" -> LEFTSHIFT { getsr lexbuf }
  ">>" -> RIGHTSHIFT { getsr lexbuf }
  "**" -> STARSTAR { getsr lexbuf }
  "<:" -> LESSCOLON { getsr lexbuf }
  ":>" -> COLONGREATER { getsr lexbuf }
  ".." -> DOTDOT { getsr lexbuf }
  "::" -> COLONCOLON { getsr lexbuf }
  "++" -> PLUSPLUS { getsr lexbuf }
  "--" -> MINUSMINUS { getsr lexbuf }
  "+=" -> PLUSEQUAL { getsr lexbuf }
  "-=" -> MINUSEQUAL { getsr lexbuf }
  "*=" -> STAREQUAL { getsr lexbuf }
  "/=" -> SLASHEQUAL { getsr lexbuf }
  "%=" -> PERCENTEQUAL { getsr lexbuf }
  "^=" -> CARETEQUAL { getsr lexbuf }
  "|=" -> VBAREQUAL { getsr lexbuf }
  "&=" -> AMPEREQUAL { getsr lexbuf }
  "~=" -> TILDEEQUAL { getsr lexbuf }
  ":=" -> COLONEQUAL { getsr lexbuf }
  "->" -> RIGHTARROW { getsr lexbuf }
  "=>" -> EQRIGHTARROW { getsr lexbuf }
  "<-" -> LEFTARROW { getsr lexbuf }
  "[|" -> LSQBAR { getsr lexbuf }
  "|]" -> RSQBAR { getsr lexbuf }
  "&&" -> AMPERAMPER { getsr lexbuf }
  "||" -> VBARVBAR { getsr lexbuf }
  "\\&" -> SLOSHAMPER { getsr lexbuf }
  "\\|" -> SLOSHVBAR { getsr lexbuf }
  "\\^" -> SLOSHCIRCUMFLEX { getsr lexbuf }
  "#!" -> HASHBANG { getsr lexbuf }
  "<<=" -> LEFTSHIFTEQUAL { getsr lexbuf }
  ">>=" -> RIGHTSHIFTEQUAL { getsr lexbuf }
  "<->" -> LEFTRIGHTARROW { getsr lexbuf }
  "&==" -> ANDEQEQUAL { getsr lexbuf }
  "&!=" -> ANDNOTEQUAL { getsr lexbuf }
  "&<=" -> ANDLESSEQUAL { getsr lexbuf }
  "&>=" -> ANDGREATEREQUAL { getsr lexbuf }
  "..." -> DOTDOTDOT { getsr lexbuf }
  "-->" -> LONGRIGHTARROW { getsr lexbuf }
  "=>#" -> PARSE_ACTION { getsr lexbuf }
  "#!/" -> HASHBANGSLASH { getsr lexbuf }

/* eof is not eaten up, so parent will find eof and emit ENDMARKER */
 "//" not_newline * (newline | eof) -> {
      incr_lineno lexbuf 1
  }

 "/*" -> { parse_C_comment 1 lexbuf }

 int_lit -> INTEGER {
      let sr = getsr lexbuf in
      let s = lexeme lexbuf in
      let n = String.length s in
      let converter, first =
        if n>1 && s.[0]='0'
        then
          match s.[1] with
          | 'b' | 'B' -> binbig_int_of_string,2
          | 'o' | 'O' -> octbig_int_of_string,2
          | 'd' | 'D' -> decbig_int_of_string,2
          | 'x' | 'X' -> hexbig_int_of_string,2
          | _         -> decbig_int_of_string,0
        else decbig_int_of_string,0
      in
      let k = ref (n-1) in
      let t =
        if n >= 2 && s.[n-2]='i' && s.[n-1]='8'
        then (k:=n-2; "int8")
        else if n >= 2 && s.[n-2]='u' && s.[n-1]='8'
        then (k:=n-2; "uint8")
        else if n >= 3 && s.[n-3]='i' && s.[n-2]='1' && s.[n-1]='6'
        then (k:=n-3; "int16")
        else if n >= 3 && s.[n-3]='u' && s.[n-2]='1' && s.[n-1]='6'
        then (k:=n-3; "uint16")

        else if n >= 3 && s.[n-3]='i' && s.[n-2]='3' && s.[n-1]='2'
        then (k:=n-3; "int32")
        else if n >= 3 && s.[n-3]='u' && s.[n-2]='3' && s.[n-1]='2'
        then (k:=n-3; "uint32")

        else if n >= 3 && s.[n-3]='i' && s.[n-2]='6' && s.[n-1]='4'
        then (k:=n-3; "int64")
        else if n >= 3 && s.[n-3]='u' && s.[n-2]='6' && s.[n-1]='4'
        then (k:=n-3; "uint64")

        else begin
          let sign = ref "" in
          let typ = ref "int" in
          begin try while !k>first do
            (match s.[!k] with
            | 'u' | 'U' -> sign := "u"
            | 't' | 'T' -> typ := "tiny"
            | 's' | 'S' -> typ := "short"
            | 'i' | 'I' -> typ := "int"
            | 'l' | 'L' ->
              typ :=
                if !typ = "long" then "vlong" else "long"
            | 'v' | 'V' -> typ := "vlong"
            | _ -> raise Not_found
            );
            decr k
          done with _ -> () end;
          incr k;
          !sign ^ !typ
        end
      in
      let d = String.sub s first (!k-first) in
      let v = (converter d) in
        (sr, t, v)
  }

 floating_literal -> FLOAT {
    let str = lexeme lexbuf in
    let n = String.length str in
    let last_char = str.[n-1] in
    match last_char with
    | 'l'|'L' ->
      (getsr lexbuf,"ldouble", strip_us (String.sub str 0 (n-1)))
    | 'f'|'F' ->
      (getsr lexbuf,"float",strip_us (String.sub str 0 (n-1)))
    | _ ->
      (getsr lexbuf,"double",strip_us str)
  }

/* Python strings */
 quote  -> STRING {   parse_qstring lexbuf }
 qqq    -> STRING {   parse_qqqstring lexbuf }
 dquote -> STRING {   parse_dstring lexbuf }
 ddd    -> STRING {   parse_dddstring lexbuf }

/* Python raw strings */
 ('r'|'R') qqq    -> STRING {   parse_raw_qqqstring lexbuf }
 ('r'|'R') dquote -> STRING {   parse_raw_dstring lexbuf }
 ('r'|'R') ddd    -> STRING {   parse_raw_dddstring lexbuf }


/* C strings: type char*  */
 ('c'|'C') qqq    -> CSTRING {   parse_qqqstring lexbuf }
 ('c'|'C') dquote -> CSTRING {   parse_dstring lexbuf }
 ('c'|'C') ddd    -> CSTRING {   parse_dddstring lexbuf }

/* raw C strings: type char*  */
 rqc qqq    -> CSTRING {   parse_raw_qqqstring lexbuf }
 rqc dquote -> CSTRING {   parse_raw_dstring lexbuf }
 rqc ddd    -> CSTRING {   parse_raw_dddstring lexbuf }


/* Format strings */
 ('f'|'F') qqq    -> FSTRING {   parse_qqqstring lexbuf }
 ('f'|'F') dquote -> FSTRING {   parse_dstring lexbuf }
 ('f'|'F') ddd    -> FSTRING {   parse_dddstring lexbuf }

/* wide strings */
 ('w' | 'W') qqq    -> WSTRING {   parse_qqqstring lexbuf }
 ('w' | 'W') dquote -> WSTRING {   parse_dstring lexbuf }
 ('w' | 'W') ddd    -> WSTRING {   parse_dddstring lexbuf }

/* UTF32 strings */
 ('u' | 'U') qqq    -> USTRING {   parse_qqqstring lexbuf }
 ('u' | 'U') dquote -> USTRING {   parse_dstring lexbuf }
 ('u' | 'U') ddd    -> USTRING {   parse_dddstring lexbuf }

/* keyword strings */
 ('k' | 'K') qqq    -> USER_KEYWORD {   parse_qqqstring lexbuf }
 ('k' | 'K') dquote -> USER_KEYWORD {   parse_dstring lexbuf }
 ('k' | 'K') ddd    -> USER_KEYWORD {   parse_dddstring lexbuf }

/* name strings */
 ('n' | 'N') qqq    -> NAME {   parse_qqqstring lexbuf }
 ('n' | 'N') dquote -> NAME {   parse_dstring lexbuf }
 ('n' | 'N') ddd    -> NAME {   parse_dddstring lexbuf }


/* this MUST be after strings, so raw strings take precedence
  over identifiers, eg r'x' is a string, not an identifier,
  but x'x' is an identifier .. yucky ..
*/
 identifier -> NAME {
       
      let s = lexeme lexbuf in
      let s' = Flx_id.utf8_to_ucn s in
      let src = getsr lexbuf in
      (src,s')
  }

/* whitespace */
 white+ -> { () }

 slosh -> SLOSH 

/* end of line */
 newline -> {
      incr_lineno lexbuf 1
  }

/* end of file */
 eof -> ENDMARKER { }

/* Anything else is an error */
 _ -> ERRORTOKEN {
      (
        getsr lexbuf, lexeme lexbuf
      )
  }

%parser

compilation_unit:
  | graminit statements ENDMARKER { 
    (*
    print_endline ("Returning syntax, loaded dssls = " ^ String.concat ","dyp.last_local_data.loaded_dssls);
    print_endline ("Returning syntax, Schemes = " ^ string_of_int (List.length dyp.last_local_data.scm)); 
    print_endline ("Returning syntax, Dssls = " ^ (Drules.fold (fun k _ acc -> acc ^ " " ^ k) dyp.last_local_data.dssls ""));
    *)
    $2, dyp.last_local_data }

graminit: @{
    (*
    print_endline "Parsing about to start";
    *)
    let m = dyp.local_data in
    let loaded_dssls = m.loaded_dssls in
    let scm = List.rev m.scm in
    let env = dyp.global_data.env in
(*
print_endline ("Doing scheme .. " ^ string_of_int (List.length scm) ^ " fragments");
*)
    List.iter (fun (sr,s) -> ignore (
       (* print_endline ("Scheme: " ^ s); *)
       try scheme_run sr env s
       with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
         print_endline ("Error "^err^" executing " ^s);
         failwith "Error executing SCHEME"
      ))
    scm;
(*
print_endline "Scheme Done .. ";
*)
    (* calculate the transitive closure of DSSL's required *)
    let visited = ref [] in
    let to_install = ref [] in
    let rec cal_install s =
      if List.mem s !visited then ()
      else begin
        visited := s :: !visited;
        let d =
          try Drules.find s m.dssls
          with Not_found -> failwith ("Can't open syntax " ^ s)
        in
        List.iter cal_install d.deps;
        to_install := s :: !to_install
      end
    in
    List.iter cal_install loaded_dssls;
    let to_install = List.rev (!to_install) in
(*
    print_endline ("Installing " ^ cat "," to_install);
*)
    let rules,prios =
      List.fold_left (fun (acc_rules, acc_prios) dssl ->
      let rules,prios =
        let d =
          try Drules.find dssl m.dssls
          with Not_found -> failwith ("Can't open syntax " ^ dssl)
        in d.rules,d.prios
      in
      let rules = List.map (fun x -> dssl,x) rules in
      acc_rules @ rules, acc_prios @ prios
      )
      ([],[])
      to_install
    in

    let bindings = ref [] in
    let add_rules = List.map (fun rule ->
      let rule, action, binding = extend_grammar dyp rule in
      bindings := binding :: !bindings;
      rule, action
      ) 
      rules 
    in
    let local_data = { m with loaded_dssls = to_install } in
(*
    print_endline ("Mounting Dssls = " ^ (Drules.fold (fun k _ acc -> acc ^ " " ^ k) m.dssls ""));
*)
    (),!bindings @ [Add_rules add_rules; Local_data local_data; Relation prios]
  }


/* top level statements only */
statements:
 | statement_star
   @{
     List.rev (snd $1),
     [Local_data dyp.last_local_data]
   }

statement_star:
 | statement_star statement
   @{
     let seq,sr,s = $2 in
     (match s with Snull -> $1 | _ ->
     let sseq,stmts = $1 in
     let s' = ocs2flx sr s in
     (max seq sseq, (s' :: stmts))),
     [Keep_grammar; Local_data (dyp.last_local_data)]
   }

 | { 0,[] }

/* inner statements only */
sstatements: 
  | sstatement_star
    {
      let ss = (snd $1) in
      let ss = Ocs_misc.make_slist Snull ss in
      (*
      print_endline "Returning inner statement list";
      *)
      0, dummysr, ss
    }

sstatement_star:
 | sstatement_star statement
   @{
     let seq,sr,s = $2 in
     (match s with Snull -> $1 | _ ->
     let sseq,stmts = $1 in
     (max seq sseq, (s :: stmts))),
     [Keep_grammar; Local_data (dyp.last_local_data)]
    }
  | { 0,[] }

dyprods:
   | dyprods dyprod { $2 :: $1 }
   | { [] }

opt_private:
  | PRIVATE { `Private }
  | { `Public }

opt_prio:
  | LSQB NAME RSQB { `Priority (snd $2) }
  | { `Default }

pri:
  | NAME { snd $1 }

prilist:
  | pri LESS prilist { $1 :: $3 }
  | pri { [$1] }

dyprod:
   | opt_private NAME opt_prio COLONEQUAL dyalts SEMI
     {
       (*
       print_endline ("RULE " ^ snd $2);
       *)
       `Scheme_rule ($1, snd $2, $3,`Sval,$5)
     }

   | opt_private NAME opt_prio COLON NAME EQUAL dyalts SEMI
     {
       if snd $5 <> "string" then raise Giveup;
       print_endline ("STRING RULE " ^ snd $2);
       `Scheme_rule ($1, snd $2,$3,`String,$7)
     }


   | REQUIRES basic_name_comma_list SEMI
     {
        let dssls = List.map snd $2 in
       `Requires dssls
     }

   | NAME NAME STRING SEMI
     {
       if snd $1 <> "explain" then raise Giveup;
       `Document ((snd $2),(snd $3))
     }

   | NAME NAME EQUAL subpage_entries SEMI
     {
       if snd $1 <> "page" then raise Giveup;
       `Page ((snd $2),$4)
     }

   | NAME prilist SEMI
     {
       if snd $1 <> "priority" then raise Giveup;
       `Priorities $2
     }

subpage_entry:
  | NAME EQUAL LPAR subpage_entries RPAR { `Subpage ((snd $1),$4) }
  | NAME { `Nt (snd $1) }

subpage_entries:
  | subpage_entry COMMA subpage_entries { $1 :: $3 }
  | subpage_entry { [$1] }

action:
   | STRING { `Scheme (snd $1) }
   | LPAR sexpr RPAR { `Expr $2 }

note:
   | NAME STRING
     {
       if snd $1 <> "note" then raise Giveup;
       snd $2
     }
   | { "" }

dyalt:
   | rhs PARSE_ACTION action note
     {
       let anote = $4 in
       let prod = $1 in
       let action = $3 in
       let action : action_t =
         match action with
         | `Scheme _ as x -> x
         | `None as x -> x
         | `Expr (_,_,e) ->
           `Scheme (user_expr prod e)
       in
       prod,slift $2,action,anote
     }
   | rhs { $1,dummysr,`None,"" }

dyaltlist:
   | { [] }
   | VBAR dyalt dyaltlist { $2 :: $3 }

dyalts:
   | dyalt dyaltlist { $1 :: $2 }
   | VBAR dyalt dyaltlist { $2 :: $3 }

rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

rhs_term :
  | rhs_atom { `Atom $1 }
  | LPAR dyalts RPAR { `Group $2 }

rhs_atom:
  | NAME { let sr,s = $1 in NAME (sr,s) } /* arbitrary nonterminal */
  | STRING { let sr,s = $1 in STRING (sr,s) } /* the string as an identifier */
  | IDENT { NAME ($1,"identifier") }
  | USER_KEYWORD { USER_KEYWORD $1 } /* user terminal */
  | ALL { ALL $1 }
  | ASSERT { ASSERT $1 }
  | AXIOM { AXIOM $1 }
  | BODY { BODY $1 }
  | CALL { CALL $1 }
  | CASE { CASE $1 }
  | CASENO { CASENO $1 }
  | CFUNCTION { CFUNCTION $1 }
  | CLASS { CLASS $1 }
  | COMMENT_KEYWORD { COMMENT_KEYWORD $1 }
  | COMPOUND { COMPOUND $1 }
  | CONST { CONST $1 }
  | CPROCEDURE { CPROCEDURE $1 }
  | CSTRUCT { CSTRUCT $1 }
  | CTOR { CTOR $1 }
  | CTYPES { CTYPES $1 }
  | DEF { DEF $1 }
  | DO { DO $1 }
  | DONE { DONE $1 }
  | ELIF { ELIF $1 }
  | ELSE { ELSE $1 }
  | ENDCASE { ENDCASE $1 }
  | ENDIF { ENDIF $1 }
  | ENDMATCH { ENDMATCH $1 }
  | ENUM { ENUM $1 }
  | EXPECT { EXPECT $1 }
  | EXPORT { EXPORT $1 }
  | EXTERN { EXTERN $1 }
  | FOR { FOR $1 }
  | FORGET { FORGET $1 }
  | FORK { FORK $1 }
  | FUNCTOR { FUNCTOR $1 }
  | FUNCTION { FUNCTION $1 }
  | GENERATOR { GENERATOR $1 }
  | GOTO { GOTO $1 }
  | HALT { HALT $1 }
  | HEADER { HEADER $1 }
  | INCLUDE { INCLUDE $1 }
  | INCOMPLETE { INCOMPLETE $1 }
  | INF { INF $1 }
  | IN { IN $1 }
  | INSTANCE { INSTANCE $1 }
  | IS { IS $1 }
  | INHERIT { INHERIT $1 }
  | INLINE { INLINE $1 }
  | JUMP { JUMP $1 }
  | LEMMA { LEMMA $1 }
  | LET { LET $1 }
  | LOOP { LOOP $1 }
  | MACRO { MACRO $1 }
  | MODULE { MODULE $1 }
  | NAMESPACE { NAMESPACE $1 }
  | NAN { NAN $1 }
  | NEW { NEW $1 }
  | NOINLINE { NOINLINE $1 }
  | NONTERM { NONTERM $1 }
  | NORETURN { NORETURN $1 }
  | NOT { NOT $1 }
  | OPEN { OPEN $1 }
  | PACKAGE { PACKAGE $1 }
  | POD { POD $1 }
  | PRIVATE { PRIVATE $1 }
  | PROCEDURE { PROCEDURE $1 }
  | PROPERTY { PROPERTY $1 }
  | REDUCE { REDUCE $1 }
  | REF { REF $1 }
  | RENAME { RENAME $1 }
  | REQUIRES { REQUIRES $1 }
  | RETURN { RETURN $1 }
  | SCHEME { SCHEME $1 }
  | SYNTAX { SYNTAX $1 }
  | STATIC { STATIC $1 }
  | STRUCT { STRUCT $1 }
  | THEN { THEN $1 }
  | TODO { TODO $1 }
  | TO { TO $1 }
  | TYPEDEF { TYPEDEF $1 }
  | TYPE { TYPE $1 }
  | TYPECLASS { TYPECLASS $1 }
  | UNION { UNION $1 }
  | USE { USE $1 }
  | VAL { VAL $1 }
  | VAR { VAR $1 }
  | VIRTUAL { VIRTUAL $1 }
  | WHERE { WHERE $1 }
  | WHEN { WHEN $1 }
  | WITH { WITH $1 }
  | YIELD { YIELD $1 }
  | GC_POINTER { GC_POINTER $1 }
  | GC_TYPE { GC_TYPE $1 }
  | SVC { SVC $1 }
  | DEREF { DEREF $1 }
  | AND { AND $1 }
  | AS { AS $1 }
  | CALLBACK { CALLBACK $1 }
  | CODE { CODE $1 }
  | FALSE { FALSE $1 }
  | IF { IF $1 }
  | ISIN { ISIN $1 }
  | MATCH { MATCH $1 }
  | NOEXPAND { NOEXPAND $1 }
  | OF { OF $1 }
  | OR { OR $1 }
  | THE { THE $1 }
  | TRUE { TRUE $1 }
  | TYPEMATCH { TYPEMATCH $1 }
  | TYPECASE { TYPECASE $1 }
  | WHENCE { WHENCE $1 }
  | UNLESS { UNLESS $1 }
  | UNDERSCORE { UNDERSCORE $1 }
  | DOLLAR { DOLLAR $1 }
  | QUEST { QUEST $1 }
  | EXCLAMATION { EXCLAMATION $1 }
  | LSQB { LSQB $1 }
  | RSQB { RSQB $1 }
  | LBRACE { LBRACE $1 }
  | RBRACE { RBRACE $1 }
  | COLON { COLON $1 }
  | COMMA { COMMA $1 }
  | PLUS { PLUS $1 }
  | MINUS { MINUS $1 }
  | STAR { STAR $1 }
  | SLASH { SLASH $1 }
  | AMPER { AMPER $1 }
  | LESS { LESS $1 }
  | GREATER { GREATER $1 }
  | EQUAL { EQUAL $1 }
  | DOT { DOT $1 }
  | PERCENT { PERCENT $1 }
  | BACKQUOTE { BACKQUOTE $1 }
  | TILDE { TILDE $1 }
  | CIRCUMFLEX { CIRCUMFLEX $1 }
  | HASH { HASH $1 }
  | DOLLARDOLLAR { DOLLARDOLLAR $1 }
  | ANDLESS { ANDLESS $1 }
  | ANDGREATER { ANDGREATER $1 }
  | EQEQUAL { EQEQUAL $1 }
  | NOTEQUAL { NOTEQUAL $1 }
  | LESSEQUAL { LESSEQUAL $1 }
  | GREATEREQUAL { GREATEREQUAL $1 }
  | LEFTSHIFT { LEFTSHIFT $1 }
  | RIGHTSHIFT { RIGHTSHIFT $1 }
  | STARSTAR { STARSTAR $1 }
  | LESSCOLON { LESSCOLON $1 }
  | COLONGREATER { COLONGREATER $1 }
  | DOTDOT { DOTDOT $1 }
  | COLONCOLON { COLONCOLON $1 }
  | PLUSPLUS { PLUSPLUS $1 }
  | MINUSMINUS { MINUSMINUS $1 }
  | PLUSEQUAL { PLUSEQUAL $1 }
  | MINUSEQUAL { MINUSEQUAL $1 }
  | STAREQUAL { STAREQUAL $1 }
  | SLASHEQUAL { SLASHEQUAL $1 }
  | PERCENTEQUAL { PERCENTEQUAL $1 }
  | CARETEQUAL { CARETEQUAL $1 }
  | VBAREQUAL { VBAREQUAL $1 }
  | AMPEREQUAL { AMPEREQUAL $1 }
  | TILDEEQUAL { TILDEEQUAL $1 }
  | COLONEQUAL { COLONEQUAL $1 }
  | RIGHTARROW { RIGHTARROW $1 }
  | EQRIGHTARROW { EQRIGHTARROW $1 }
  | LEFTARROW { LEFTARROW $1 }
  | LSQBAR { LSQBAR $1 }
  | RSQBAR { RSQBAR $1 }
  | AMPERAMPER { AMPERAMPER $1 }
  | VBARVBAR { VBARVBAR $1 }
  | SLOSHAMPER { SLOSHAMPER $1 }
  | SLOSHVBAR { SLOSHVBAR $1 }
  | SLOSHCIRCUMFLEX { SLOSHCIRCUMFLEX $1 }
  | HASHBANG { HASHBANG $1 }
  | LEFTSHIFTEQUAL { LEFTSHIFTEQUAL $1 }
  | RIGHTSHIFTEQUAL { RIGHTSHIFTEQUAL $1 }
  | LEFTRIGHTARROW { LEFTRIGHTARROW $1 }
  | ANDEQEQUAL { ANDEQEQUAL $1 }
  | ANDNOTEQUAL { ANDNOTEQUAL $1 }
  | ANDLESSEQUAL { ANDLESSEQUAL $1 }
  | ANDGREATEREQUAL { ANDGREATEREQUAL $1 }
  | DOTDOTDOT { DOTDOTDOT $1 }
  | LONGRIGHTARROW { LONGRIGHTARROW $1 }
  | HASHBANGSLASH { HASHBANGSLASH $1 }
statement:
  | SCHEME STRING SEMI
    @{
      let sr = rstoken $1 $3 in
      let s = snd $2 in
      let failwith x = print_endline ("Evaluating " ^ s); failwith x in
      (*
      let env = Ocs_env.env_copy dyp.local_data.env in
      *)
      let env = dyp.global_data.env in
      let r =
        try scheme_run sr env s
        with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
          print_endline ("Error "^err^" executing " ^s);
          failwith "Error executing SCHEME"
      in
      let local_data = { dyp.local_data with scm = (sr,s) :: dyp.local_data.scm } in
      (0,sr,Snull),[Local_data local_data]
    }

  | OPEN SYNTAX basic_name_comma_list SEMI
    @{
      (*
      print_endline "Opening syntax extensions";
      *)
      let sr = rstoken $1 $4 in
      let dssls = List.map snd $3 in
(*
      print_endline ("Parsed open of syntax extensions " ^ String.concat "," dssls);
*)
      let m = dyp.local_data in

      (* calculate the transitive closure of DSSL's required
         minus those already installed
      *)
      let installed = m.loaded_dssls in
      let visited = ref [] in
      let to_install = ref [] in
      let rec cal_install s =
        if List.mem s installed or List.mem s !visited then ()
        else begin
          visited := s :: !visited;
          let d =
            try Drules.find s m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ s)
          in
          List.iter cal_install d.deps;
          to_install := s :: !to_install
        end
      in
      List.iter cal_install dssls
      ;
      let to_install = List.rev (!to_install) in
(*
      print_endline ("Installing " ^ cat "," to_install);
*)
      let rules,prios =
        List.fold_left (fun (acc_rules, acc_prios) dssl ->
        let rules,prios =
          let d =
            try Drules.find dssl m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ dssl)
          in d.rules,d.prios
        in
        let rules = List.map (fun x -> dssl,x) rules in
        acc_rules @ rules, acc_prios @ prios
        )
        ([],[])
        to_install
      in

      let bindings = ref [] in
      let add_rules = List.map begin fun rule ->
        let rule, action, binding = extend_grammar dyp rule in
        bindings := binding :: !bindings;
        rule, action
      end rules in
(*
      print_endline "Prepared nu grammar rules to yield to Dypgen";
*)
      let local_data = { m with loaded_dssls = to_install @ m.loaded_dssls } in
      (0,sr,Snull),!bindings @ [Add_rules add_rules; Local_data local_data; Relation prios]
    }

  | SYNTAX NAME LBRACE dyprods RBRACE
    @{
      (* NOTE ORDER!! dyprods is reversed, but the fold reverses it again *)
      (*
      print_endline ("Parsed syntax extensions " ^ (snd $2));
      print_endline ("Defining syntax extensions " ^ (snd $2));
      *)
      let sr = rstoken $1 $5 in
      let dssl = snd $2 in
      let m = dyp.local_data in
      let m =
        if Drules.mem dssl m.dssls then m
        else {m with dssls=Drules.add dssl fresh_dssl m.dssls}
      in
      let global_data,local_data =
        List.fold_left (fun (g,l) x -> add_rule g l dssl x) (dyp.global_data, m) $4
      in
      (* This cal tries to avoid gratutions mods to global/local data
         by checking for physical equality. Note changes to any
         embedded mutable data structure propagate anyhow.
      *)
      let mods =
        (if dyp.global_data != global_data then [Global_data global_data] else [])
        @
        (if dyp.local_data != local_data then [Local_data local_data] else [])
      in
      (0,sr,Snull),mods
    }

  | LOAD_SYNTAX
    @{
      let local_data = $1 in
      let scm = List.rev local_data.scm in
      let env = dyp.global_data.env in
      List.iter (fun (sr,s) -> ignore (

          try scheme_run sr env s
          with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
            print_endline ("Error "^err^" executing " ^s);
            failwith "Error executing SCHEME"
      ))
      scm;
      (0,dummysr,Snull),[Local_data local_data]
    }

  | SAVE_SYNTAX
    {
      let this_version = !Flx_version.version_data in
      let filename = $1 in
      let x = try Some  (open_out_bin filename) with _ -> None in
      begin match x with
      | None -> ()
      | Some x ->
        print_endline ("// Save Syntax file " ^ filename);
        Marshal.to_channel x this_version [];
        Marshal.to_channel x dyp.local_data [];
        close_out x
      end;
      (0,dummysr,Snull)
    }
sexpr: | DUMMY { 0,dummysr,Snull }

/* identifiers which aren't keywords */
sname: NAME { 0,slift (fst $1),Sstring (snd $1) }

/*
replacements for * + and ? to be used in productions,
since these symbols have special meansings as
list, non-empty list, and optional respectively
*/
star: STAR { 0,slift $1,Snull }
plus: PLUS { 0,slift $1,Snull }
quest: QUEST { 0,slift $1,Snull }
sident: IDENT { 0,slift $1,Snull }

lbrace: LBRACE { 0,slift $1,Snull }
rbrace: RBRACE { 0,slift $1,Snull }
lpar: LPAR { 0,slift $1,Snull }
rpar: RPAR { 0,slift $1,Snull }
lsqb: LSQB { 0,slift $1,Snull }
rsqb: RSQB { 0,slift $1,Snull }

ssemi: SEMI { 0,slift $1,Snull }
comma: COMMA { 0,slift $1,Snull }
colon: COLON { 0,slift $1,Snull }
vbar: VBAR { 0,slift $1,Snull }
strue: TRUE { 0,slift $1,Snull }
sfalse : FALSE { 0,slift $1,Snull }

strtrue: TRUE { 0,slift $1,Sstring "true" }
strfalse : FALSE { 0,slift $1,Sstring "false" }

/*
a definite non-terminal for a sequence of no tokens,
since the production syntax cannot parse an empty
production at the moment
*/
sepsilon: | {0,dummysr,Snull }
strepsilon: | {0,dummysr,Sstring "" }

sinteger:
  | INTEGER
    {
      let sr,t,v = $1 in
      0,slift sr,Sbigint v
    }

strint:
  | INTEGER
    {
      let sr,t,v = $1 in
      let s = Big_int.string_of_big_int v in
      0,slift sr,Sstring s
    }

sfloat:
  | FLOAT
    {
      let sr,t,v = $1 in
      let x = Sstring t::Sstring v::[] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

strfloat:
  | FLOAT
    {
      let sr,t,v = $1 in
      0,slift sr,Sstring v
    }


sintegral:
  | INTEGER
    {
      let sr,t,v = $1 in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev i) in
      0,slift sr,x
    }
  | MINUS INTEGER
    {
      let sr,t,v = $2 in
      let v = Big_int.minus_big_int v in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev i) in
      0,slift sr,x
    }

sstring:
  | STRING
    {
      let sr,s = $1 in
      0,slift sr,Sstring s
    }

strstring:
  | STRING
    {
      let sr,s = $1 in
      let s = Flx_string.c_quote_of_string s in
      0,slift sr,Sstring s
    }

scstring:
  | CSTRING
    {
      let sr,s = $1 in
      0,slift sr,Sstring s
    }


sliteral:
  | INTEGER
    {
      let sr,t,v = $1 in
      let v = Big_int.string_of_big_int v in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let aint = Ocs_sym.get_symbol "ast_int" in
      let i = aint :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr (slift sr) :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

  | FLOAT
    {
      let sr,t,v = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let afloat = Ocs_sym.get_symbol "ast_float" in
      let i = afloat :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr (slift sr) :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

  | STRING
    {
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_string" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr (slift sr) :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
   }

  | WSTRING
    {
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_wstring" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr (slift sr) :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

  | USTRING
    {
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_ustring" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr (slift sr) :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

  | CSTRING
    {
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in
      let astring = Ocs_sym.get_symbol "ast_cstring" in
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (List.rev i) in
      let x = alit :: xsr (slift sr) :: i :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

  | QSTRING
    {
      let sr,s = $1 in
      let qstring = Ocs_sym.get_symbol "ast_interpolate" in
      let x = qstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

  | FSTRING
    {
      let sr,s = $1 in
      let fstring = Ocs_sym.get_symbol "ast_vsprintf" in
      let x = fstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (List.rev x) in
      0,slift sr,x
    }

basic_name:
  | NAME { $1 }

basic_name_comma_list:
  | basic_name COMMA basic_name_comma_list { $1 :: $3 }
  | basic_name { [$1] }
  | { [] }

epsilon: | {()}
%%
{
exception Found_file of string
let lookup_file incdirs f =
  try 
    begin
      if Filename.is_relative f then
        List.iter
        (fun d ->
          let f = Filename.concat d f in
          if Sys.file_exists f
          then raise (Found_file f)
        )
        incdirs
      else
        if Sys.file_exists f
        then raise (Found_file f)
    end; 
    failwith ("File " ^ f ^ " not found in path")
  with Found_file s -> s

let dyphack (ls : ( 'a * string) list) : 'a =
  match ls with
  | [x,_] -> x
  | _ -> failwith "Dypgen parser failed"

let parse1 local_data filename : compilation_unit_t * local_data_t = 
  print_endline ("PARSING " ^ filename);
  let ic = open_in filename in 
  let pilot = pp () in 
  let lexbuf = Dyp.from_channel pilot ic in
  let b = (Dyp.std_lexbuf lexbuf) in
  b.lex_curr_p <- { b.lex_curr_p with pos_fname = filename };
  let show_error() =
    let sr = slift (getsr lexbuf) in
    print_endline (long_string_of_src sr);
  in
  let parse_tree = 
    try dyphack (
      compilation_unit 
        ~local_data:local_data 
        ~global_data:global_data 
        lexbuf
      ) 
    with
      | Failure s ->
        begin
          print_endline ("Parse fail " ^ s);
          show_error();
          raise (Flx_exceptions.ParseError ("Failure \""^s^"\" Parsing File"))
        end
      | Flx_exceptions.ClientError (sr,s)
      | Flx_exceptions.ClientError2 (sr,_,s)
      | Flx_exceptions.ClientErrorn (sr::_, s) as x  ->
        begin
          print_endline "Parse fail";
          print_endline (Flx_srcref.long_string_of_src sr);
          raise x
        end

      | Dyp.Syntax_error ->
          show_error();
          failwith ("Syntax error at unknown location in file " ^ filename);

      | Dyp.Bad_constructor (nt,ctor1, ctor2) ->
          let s = "Bad constructor '" ^ ctor1 ^ "' and '" ^ ctor2 ^ "' for nonterminal '" ^ nt ^"'" in
          print_endline s;
          failwith s

      | x ->
        begin
          print_string "Fatal error: exception ";
          print_endline (Printexc.to_string x);
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
  in
  close_in ic;
  parse_tree

let parse_file filename dirname incdirs cache_dir auto_imports =
  let prefix_tree, local_data =
    List.fold_left begin fun (old_tree, old_local_data) filename ->
      let filename = lookup_file incdirs filename in
      let tree, local_data = parse1 old_local_data filename in
      old_tree @ tree, local_data
    end
    ([],local_data) auto_imports
  in
  let filename = lookup_file (dirname :: incdirs) filename in
  let tree,_ = parse1 local_data filename in
  prefix_tree @ tree
}


%mlitop {
open Flx_token
open Flx_mtypes2
}

%mli {
  exception Scheme_error of Ocs_types.sval
}


