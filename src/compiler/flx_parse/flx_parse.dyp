%mltop {
open Flx_token
open Flx_drules
}
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_print
open Flx_exceptions
open Ocs_types
open Sex_types
open Dyp
open Lexing
open Flx_string
open Flx_parse_helper

module DStringSet = Set.Make (
  struct
    type t = string
    let compare = compare
  end)

let string_set_of_list ls =
  List.fold_left (fun set elt -> DStringSet.add elt set) DStringSet.empty ls
(*
let dypgen_choose_token = `all
*)

(*
let dyp_merge = keep_all
*)
let smerge ((oseq,osr,osex),ogd,old as oit) ((nseq,nsr,nsex),ngd,nld as nit) =
   if !(global_data.pdebug) then
   begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ "\nnxt=" ^ Ocs_print.string_of_ocs nsex);
   end;
   if oseq > nseq then oit
   else if nseq > oseq then nit
   (* else if osex = nsex then oit *)
   else if Ocs_misc.test_equal osex nsex then (
     print_endline ("MERGING EQUAL TERMS! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! =" ^ Ocs_print.string_of_ocs osex);
   oit)
   else begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ "\nnxt=" ^ Ocs_print.string_of_ocs nsex);
     Flx_exceptions.clierr2 osr nsr ("AMBIGUITY PARSING, same production!,seq = " ^ string_of_int nseq)
   end

let dyp_merge_Obj_sexpr ol = keep_all ol

(*
let dyp_merge_Obj_sexpr ol =
 match ol with
 | [] -> assert false
(* | [_] -> assert false *)
 | [ntt,gd,ld] -> [ntt],gd,ld

 | h :: t ->
   match List.fold_left smerge h t with
   ntt,gd,ld -> [ntt],gd,ld
*)

let rec elim_common_prefix x y =
  match x, y with
  | a :: ta, b :: tb ->
    let eq = try a = b with _ -> false in
    if eq then elim_common_prefix ta tb
    else x,y

  | x,y -> x,y

let ssmerge ((xseq,x),xgd,xld as xit) ((yseq,y),ygd,yld as yit) =
  print_endline "statement merge happening?";
  if xseq > yseq then xit else
  if yseq > xseq then yit else
  let xsr = src_of_stmt (List.hd x) in
  let ysr = src_of_stmt (List.hd y) in
  print_endline "Ambiguity parsing statements:";
  let x = List.rev x in
  let y = List.rev y in
  let x,y = elim_common_prefix x y in
  print_endline ("Statements 1 = " ^ catmap "\n----\n" (string_of_statement 1) x);
  print_endline ("Statement 2 = " ^ catmap "\n----\n" (string_of_statement 1) y);
  Flx_exceptions.clierr2 xsr ysr "AMBIGUITY PARSING TOP LEVEL!"

let dyp_merge_Obj_statement_star ol =
  match ol with
  | []
  | [_] -> assert false
  | h::t ->
      match List.fold_left ssmerge h t with
      | ntt,gd,ld -> [ntt],gd,ld

let dyphack (ls : ( 'a * string) list) : 'a =
  match ls with
  | [x,_] -> x
  | [] -> failwith "No parse found"
  | _ -> failwith "Multiple parses found"


(* move this to elsewhere eventually *)
(* Calculate the dssls that need to be loaded based on those already loaded. *)
let tran_cls_dssls drules installed_dssls dssls =
  (* Calculate the transitive closure of DSSL's required. *)
  let rec cal_install (visited, to_install) dssl =
    (* Ignore dssls we've already visited. *)
    if DStringSet.mem dssl visited then (visited, to_install) else
    let visited = DStringSet.add dssl visited in

    let drule =
      try Drules.find dssl drules
      with Not_found -> failwith ("Can't open syntax " ^ dssl)
    in

    (* Make sure we install all of the dssl's dependencies first. *)
    let visited, to_install = List.fold_left
      cal_install
      (visited, to_install)
      drule.deps
    in

    visited, dssl :: to_install
  in

  (* Finally, calculate the dssls we need to install. We'll consider all the
   * installed dssls as already visited. *)
  let _, to_install = List.fold_left
    cal_install
    (string_set_of_list installed_dssls, [])
    dssls
  in

  (* We got our list backwards. *)
  let to_install = List.rev to_install in

  (* print_endline ("Installing " ^ cat "," to_install); *)
  to_install

(* Extract rules and priority scheme from the dssls which are to be
 * installed. *)
let extract_syntax to_install dssls =
  List.fold_left
    begin fun (acc_rules, acc_prios) dssl ->
      let rules, prios =
        let d =
          try Drules.find dssl dssls
          with Not_found -> failwith ("Can't open syntax " ^ dssl)
        in
        d.rules, d.prios
      in
      let rules = List.map (fun x -> dssl,x) rules in
      acc_rules @ rules, acc_prios @ prios
    end
    ([],[])
    to_install


(** Create the bindings from all the rules. *)
let bind_grammar_rules dyp rules =
  let bindings = ref [] in
  let add_rules = List.map
    begin fun rule ->
      let rule, action, binding = extend_grammar dyp rule in
      bindings := binding :: !bindings;
      rule, action
    end
    rules
  in
  add_rules, !bindings


(** Run all the scheme commands for a rule. *)
let load_scheme_defs env scm =
  (*
  print_endline ("Doing scheme .. " ^ string_of_int (List.length scm) ^ " fragments");
  *)
  List.iter begin fun (sr,s) ->
    ignore (
      (* print_endline ("Scheme: " ^ s); *)
       try scheme_run sr env s
       with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
         print_endline ("Error "^err^" executing " ^s);
         failwith "Error executing SCHEME"
     )
  end scm
  (*
  ; print_endline "Scheme Done .. "
  *)

}


/* special */
%token <(Flx_srcref.t * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE
%token SLOSH

/* literals */
%token <string> NAME
%token <(string * prio_t)> NONTERMINAL
%token <int> INTEGER
%token <string> STRING
%token <'obj Dyp.dyplexbuf> HASH_LINE
%token <'obj Dyp.dyplexbuf> HASH_INCLUDE
%token DUMMY
%token <'obj Dyp.dyplexbuf> EMPTY

/* This stuff is only needed to specify the type of the RHS elements of
   an extensible grammar production, i.e. for parsing the Felix grammar.
*/
%token QUEST
%constructor Obj_keyword %for QUEST
%token PLUS
%constructor Obj_keyword %for PLUS
%token STAR
%constructor Obj_keyword %for STAR

%token LPAR
%constructor Obj_keyword %for LPAR
%token RPAR
%constructor Obj_keyword %for RPAR

%token LSQB
%constructor Obj_keyword %for LSQB
%token RSQB
%constructor Obj_keyword %for RSQB

%token LBRACE
%constructor Obj_keyword %for LBRACE
%token RBRACE
%constructor Obj_keyword %for RBRACE

%token COMMA
%constructor Obj_keyword %for COMMA
%token VBAR
%constructor Obj_keyword %for VBAR

%token LESS
%constructor Obj_keyword %for LESS
%token GREATER
%constructor Obj_keyword %for GREATER
%token EQUAL
%constructor Obj_keyword %for EQUAL
%token EQEQUAL
%constructor Obj_keyword %for EQEQUAL
%token NOTEQUAL
%constructor Obj_keyword %for NOTEQUAL
%token LESSEQUAL
%constructor Obj_keyword %for LESSEQUAL
%token GREATEREQUAL
%constructor Obj_keyword %for GREATEREQUAL

%token UNDERSCORE
%constructor Obj_keyword %for UNDERSCORE

/* 
%token FUN
%constructor Obj_keyword %for FUN

*/

/* top level entry */
%constructor Obj_sexpr %for sterm

/* predefined major non-terminals */
%constructor Obj_sexpr %for sexpr
%constructor Obj_sexpr %for sstatements tstatement utstatement

/* low level non terminals */
%constructor Obj_sexpr %for sname sliteral

/* literals */
%constructor Obj_sexpr %for sstring scstring
%constructor Obj_sexpr %for strstring

/* tokens replacements for special symbols used in productions */
%constructor Obj_sexpr %for sident

/* nothing*/
%constructor Obj_sexpr %for sepsilon
%constructor Obj_sexpr %for strepsilon

/* Note: BACKWARDS list */
%start <local_data_t> compilation_unit
%start <local_data_t> syntax_unit
%relation ralt_prix<rseq_prix<rpostfix_prix<ratom_prix 


%lexer

/* ====================== REGULAR DEFINITIONS ============================ */
/* special characters */
let quote = '\''
let dquote = '"'
let slosh = '\\'
let hash = '#'
let linefeed = '\n'
let tab = '\t'
let space = ' '
let formfeed = '\012'
let vtab = '\011'
let carriage_return = '\013'
let underscore = '_'

/* character sets */
let bindigit = ['0'-'1']
let octdigit = ['0'-'7']
let digit = ['0'-'9']
let hexdigit = digit | ['A'-'F'] | ['a'-'f']
let lower = ['a'-'z']
let upper = ['A'-'Z']
let letter = lower | upper
let hichar = ['\128'-'\255']
let white = space | tab

/* nasty: form control characters */
let form_control = linefeed | carriage_return | vtab | formfeed
let newline_prefix = linefeed | carriage_return
let newline = formfeed | linefeed  | carriage_return linefeed
let hash = '#'

let ordinary = letter | digit | hichar |
  '!' | '$' | '%' | '&' | '(' | ')' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' | '_' |
  '`' | '{' | '|' | '}' | '~'

let printable = ordinary | quote | dquote | slosh | hash

/* identifiers */
let ucn =
    "\\u" hexdigit hexdigit hexdigit hexdigit
  | "\\U" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit

let prime = '\''
let dash = '-'
let idletter = letter | underscore | hichar | ucn
let alphnum = idletter | digit
let innerglyph = idletter | digit | dash
let identifier = idletter (innerglyph? (alphnum | prime) +)* prime*

/* Python strings */
let qqq = quote quote quote
let ddd = dquote dquote dquote

let escape = slosh _

let dddnormal = ordinary | hash | quote | escape | white | newline
let dddspecial = dddnormal | dquote dddnormal | dquote dquote dddnormal

let qqqnormal = ordinary | hash | dquote | escape | white | newline
let qqqspecial = qqqnormal | quote qqqnormal | quote quote qqqnormal

let raw_dddnormal = ordinary | hash | quote | slosh | white | newline
let raw_dddspecial = raw_dddnormal | dquote raw_dddnormal | dquote dquote raw_dddnormal

let raw_qqqnormal = ordinary | hash | dquote | slosh | space | newline
let raw_qqqspecial = raw_qqqnormal | quote raw_qqqnormal | quote quote raw_qqqnormal

let qstring = (ordinary | hash | dquote | escape | white) * quote
let dstring = (ordinary | hash | quote | escape | white) * dquote
let qqqstring = qqqspecial * qqq
let dddstring = dddspecial * ddd

let raw = 'r' | 'R'

let raw_qstring = (ordinary | hash | dquote | escape | white) * quote
let raw_dstring =  (ordinary | hash | quote | escape | white) * dquote

let raw_qqqstring = raw_qqqspecial * qqq
let raw_dddstring = raw_dddspecial * ddd

let not_hash_or_newline = ordinary | quote | dquote | white | slosh
let not_newline = not_hash_or_newline | hash
let quoted_filename = dquote (ordinary | hash | quote | white | slosh)+ dquote


rule parse_qstring = parse
| qstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_qstring s
  }

and parse_dstring = parse
| dstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_dstring s
  }

and parse_qqqstring = parse
| qqqstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_qqqstring s
  }

and parse_dddstring = parse
| dddstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_dddstring s
  }

/* ----------- RAW STRING -----------------------------------*/
and parse_raw_qstring = parse
| raw_qstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_qstring s
  }

and parse_raw_dstring = parse
| raw_dstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_dstring s
  }

and parse_raw_qqqstring = parse
| raw_qqqstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_qqqstring s
  }

and parse_raw_dddstring = parse
| raw_dddstring {
    let s = lexeme lexbuf in
    let n = lfcount s in
    incr_lineno lexbuf n;
    decode_raw_dddstring s
  }

and parse_C_comment count = parse
| "/*"    { parse_C_comment (count+1) lexbuf }
| newline { incr_lineno lexbuf 1; parse_C_comment count lexbuf }
| "*/"    { if count = 1 then () else parse_C_comment (count - 1) lexbuf }
| _       { parse_C_comment count lexbuf }


main lexer =
/* eof is not eaten up, so parent will find eof and emit ENDMARKER */
 "//" not_newline * (newline | eof) -> {
      incr_lineno lexbuf 1
  }

  "#line"  -> HASH_LINE {
     lexbuf
  }

/*
  "#include"  -> HASH_INCLUDE {
     print_endline "Lexed a #include command";
     lexbuf
  }
*/

 "/*" -> { parse_C_comment 1 lexbuf }

 digit+ -> INTEGER {
      let s = lexeme lexbuf in
      int_of_string s
  }

/* Python strings */
 quote  -> STRING { parse_qstring lexbuf }
 qqq    -> STRING { parse_qqqstring lexbuf }
 dquote -> STRING { parse_dstring lexbuf }
 ddd    -> STRING { parse_dddstring lexbuf }

/* Python raw strings */
 ('r'|'R') qqq    -> STRING { parse_raw_qqqstring lexbuf }
 ('r'|'R') dquote -> STRING { parse_raw_dstring lexbuf }
 ('r'|'R') ddd    -> STRING { parse_raw_dddstring lexbuf }

/* this MUST be after strings, so raw strings take precedence
  over identifiers, eg r'x' is a string, not an identifier,
  but x'x' is an identifier .. yucky ..
*/
 identifier -> NAME { Flx_utf.utf8_to_ucn (lexeme lexbuf) }

/* whitespace */
 white+ -> { () }

 slosh -> SLOSH

/* end of line */
 newline -> { incr_lineno lexbuf 1 }

/* end of file */
 eof -> ENDMARKER { }

/* Anything else is an error */
 _ -> ERRORTOKEN { lexeme lexbuf }

%parser

syntax_unit:
  | syntax_init top_statements ENDMARKER {
    (*
    print_endline ("Returning syntax, loaded dssls = " ^ String.concat ","dyp.last_local_data.installed_dssls);
    print_endline ("Returning syntax, Schemes = " ^ string_of_int (List.length dyp.last_local_data.scm));
    print_endline ("Returning syntax, Dssls = " ^ (Drules.fold (fun k _ acc -> acc ^ " " ^ k) dyp.last_local_data.dssls ""));
    print_endline ("Returning syntax, statements = " ^ Flx_print.string_of_statements 0 (List.rev dyp.last_local_data.rev_stmts));
    *)
    dyp.last_local_data }

syntax_init: 
   {
    let file = Flx_srcref.file (getsr dyp) in
    print_endline ("syninit: Parsing " ^ file)
   }

compilation_unit:
  | grammar_init top_statements ENDMARKER {
    (*
    print_endline ("Returning syntax, loaded dssls = " ^ String.concat ","dyp.last_local_data.installed_dssls);
    print_endline ("Returning syntax, Schemes = " ^ string_of_int (List.length dyp.last_local_data.scm));
    print_endline ("Returning syntax, Dssls = " ^ (Drules.fold (fun k _ acc -> acc ^ " " ^ k) dyp.last_local_data.dssls ""));
    print_endline ("Returning syntax, statements = " ^ Flx_print.string_of_statements 0 (List.rev dyp.last_local_data.rev_stmts));
    *)
    dyp.last_local_data }

grammar_init: @{
    (* print_endline ("grammar_init: Parsing " ^ file); *)
    let m = dyp.local_data in

    (* We need to reinstall the dssls that we loaded in syntax_unit. *)
    let to_install = tran_cls_dssls m.drules [] m.installed_dssls in
    let rules, prios = extract_syntax to_install m.drules in

    match !(dyp.global_data.parsing_device) with
    | Some device ->
      (* print_endline "Parsing device detected"; *)

      let ffpdev = Marshal.from_string device 0 in
      (* print_endline "Unmarshalled parsing device"; *)

      let add_rules, bindings = bind_grammar_rules dyp rules in
      let pdev = import_functions ffpdev dyp.parser_pilot add_rules in
      (), bindings @ [Parser pdev]

    | None ->
      (* print_endline "Parsing device missing"; *)

      (* Since we don't have a parsing device, we will have to run the scheme
       * commands. *)
      let env = dyp.global_data.env in
      let scm = List.rev m.scm in
      load_scheme_defs env scm;

      (* We need to bind after we've executed the scheme. *)
      let add_rules, bindings = bind_grammar_rules dyp rules in

      let local_data = { m with installed_dssls = to_install } in
      (*
      print_endline ("Mounting Dssls = " ^ (Drules.fold (fun k _ acc -> acc ^ " " ^ k) m.drules ""));
      *)

      (),
      bindings @ [Add_rules add_rules; Local_data local_data; Relation prios]
  }

tstatement:
  | utstatement ";" @{ $1, [Keep_grammar; Local_data (dyp.last_local_data)] }
/*
  | utstatement newline @{ $1, [Keep_grammar; Local_data (dyp.last_local_data)] }
*/
  | HASH_LINE INTEGER STRING newline
   {
     let sr = getsr dyp in
     let lexbuf = $1 in
     let n = $2 in
     set_lineno lexbuf n;
     Dyp.set_fname lexbuf $3;
     0,sr,Snull
   }

  | HASH_LINE INTEGER newline
   {
     let sr = getsr dyp in
     let lexbuf = $1 in
     let n = $2 in
     set_lineno lexbuf n;
     0,sr,Snull
   }

  | HASH_INCLUDE STRING newline
    {
      let sr = getsr dyp in
      let lexbuf = $1 in
      let include_file = $2 in
      print_endline ("#include " ^ include_file);
      (*
      push_lexbuf dyp (Dyp.std_lexbuf lexbuf) $2;
      *)
      0,sr,Snull
    }

/* top level statements only */
top_statements:
 | top_statements tstatement
   @{
      let seq,sr,s = $2 in
(*
      print_endline ("BB sr=" ^ Flx_srcref.short_string_of_src sr);
*)
     let local_data =
        match s with
        | Snull -> dyp.last_local_data
        | _ -> { dyp.last_local_data with rev_stmts = ocs2flx sr s :: dyp.last_local_data.rev_stmts }
      in
      (),[Keep_grammar; Local_data (local_data)]
   }

 | { () }


/* inner statements only */
sstatements:
  | sstatement_star utstatement?
    {
      let _, stmts = $1 in
      let stmts = match $2 with
        | None -> stmts
        | Some (seq,sr,s) ->
          match s with
          | Snull -> stmts
          | _ -> s::stmts
      in
      let stmts = Ocs_misc.make_slist Snull stmts in
      (*
      print_endline "Returning inner statement list";
      *)
      0, Flx_srcref.dummy_sr, stmts
    }

sstatement_star:
 | sstatement_star tstatement
   @{
     let seq,sr,s = $2 in
     (match s with Snull -> $1 | _ ->
     let sseq,stmts = $1 in
     (max seq sseq, (s :: stmts))),
     [Keep_grammar; Local_data (dyp.last_local_data)]
    }
  | { 0,[] }

dyprods:
  | dyprods dyprod { $2 :: $1 }
  | { [] }

opt_private:
  | "private" { `Private }
  | { `Public }

opt_prio:
  | "[" NAME "]" { `Priority $2 }
  | { `Default }

pri:
  | NAME { $1 }

prilist:
  | pri "<" prilist { $1 :: $3 }
  | pri { [$1] }

dyprod:
   | opt_private NAME opt_prio ":=" dyalts ";"
     {
       (*
       print_endline ("RULE " ^ snd $2);
       *)
       `Scheme_rule ($1, $2, $3, `Sval, $5)
     }

   | opt_private NAME opt_prio ":" NAME "=" dyalts ";"
     {
       if $5 <> "string" then raise Giveup;
       (*
       print_endline ("STRING RULE " ^ $2);
       *)
       `Scheme_rule ($1, $2, $3, `String, $7)
     }


   | "requires" basic_name_comma_list ";"
     {
        let dssls = List.map snd $2 in
       `Requires dssls
     }

   | NAME prilist ";"
     {
       if $1 <> "priority" then raise Giveup;
       `Priorities $2
     }

   | "regdef" NAME "=" ssre ";" { `Regex ($2,$4) }

   | opt_private "literal" NAME "=>#" STRING ";" 
     {
       let priv = $1 in
       let name = $3 in
       let prio = `Default in
       let scm = $5 in
       let action = `Scheme scm in
       let anote = "" in
       let prod = [`Atom (REGEX (RE_Name name))] in
(*
       print_endline ("Defining literal " ^ name ^ " as " ^ scm);
*)
       let dyalts = [prod,getsr dyp,action,anote] in
       `Scheme_rule (priv,name,prio,`Sval,dyalts) 
     }

  ssre :  ssre(>=ralt_prix) ["|" ssre(>ralt_prix)]+ { RE_Alt ($1::$2) } ralt_prix 
  ssre :  ssre(>=rseq_prix) [ssre(>rseq_prix)]+ { RE_Seq ($1::$2)  } rseq_prix 
  ssre :  ssre(>=rpostfix_prix) "*" { RE_Star $1 } rpostfix_prix
  ssre :  ssre(>=rpostfix_prix) "+" { RE_Plus $1 } rpostfix_prix
  ssre :  ssre(>=rpostfix_prix) "?" { RE_Option $1 } rpostfix_prix
  ssre :  "(" ssre(>=ralt_prix) ")" {$2 } ratom_prix
  ssre :  INTEGER { RE_Char (Char.chr $1) } ratom_prix
  ssre :  "_" { RE_Char_set [Char.chr 0, Char.chr 255] } ratom_prix
  ssre :  "." { RE_Char_set [Char.chr 32, Char.chr 255] } ratom_prix
  ssre :  "[" INTEGER "-" INTEGER "]" { 
    RE_Char_set [
      Char.chr $2, 
      Char.chr $4
    ] } ratom_prix

  ssre :  "charset" STRING {
    let lst = ref [] in
    String.iter (fun ch -> lst := (ch,ch)::(!lst)) $2;
    RE_Char_set (!lst)
  } ratom_prix

  ssre :  "[" STRING "]" {
    let lst = ref [] in
    String.iter (fun ch -> lst := (ch,ch)::(!lst)) $2;
    RE_Char_set (!lst)
  } ratom_prix
 
  ssre :  STRING { RE_String $1 } ratom_prix
  ssre :  NAME {RE_Name $1 } ratom_prix /* probably won't work! */
 
action:
   | STRING { `Scheme $1 }

note:
   | NAME STRING
     {
       if $1 <> "note" then raise Giveup;
       $2
     }
   | { "" }

dyalt:
   | rhs "=>#" action note
     {
       let anote = $4 in
       let prod = $1 in
       let action = $3 in
       let action : action_t =
         match action with
         | `Scheme _ as x -> x
         | `None as x -> x
       in
       prod,getsr dyp,action,anote
     }
   | rhs { $1,getsr dyp,`None,"" }

dyaltlist:
   | { [] }
   | "|" dyalt dyaltlist { $2 :: $3 }

dyalts:
   | dyalt dyaltlist { $1 :: $2 }
   | "|"  dyalt dyaltlist { $2 :: $3 }

rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

rhs_term :
  | rhs_atom { `Atom $1 }
  | "(" dyalts ")" { `Group $2 }

rhs_atom:
  | NAME { NAME $1 } /* arbitrary nonterminal */
  | STRING { STRING $1 } /* the string as an identifier */
  | "?"{ QUEST }
  | "+" { PLUS }
  | "*" { STAR }
  | "(" { LPAR }
  | ")" { RPAR }
  | "[" { LSQB }
  | "]" { RSQB }
  | "{" { LBRACE }
  | "}" { RBRACE }
  | "," { COMMA }
  | "<" { LESS }
  | ">" { GREATER }
  | "=" { EQUAL }
  | "==" { EQEQUAL }
  | "!=" { NOTEQUAL }
  | "<=" { LESSEQUAL }
  | ">=" { GREATEREQUAL }
  | "_" { UNDERSCORE }

utstatement:
  | "SCHEME" STRING
    @{
      let sr = getsr dyp in
      let s = $2 in
      let failwith x = print_endline ("Evaluating " ^ s); failwith x in
      (*
      let env = Ocs_env.env_copy dyp.local_data.env in
      *)
      let env = dyp.global_data.env in
      let r =
        try scheme_run sr env s
        with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
          print_endline ("Error "^err^" executing " ^s);
          failwith "Error executing SCHEME"
      in
      let local_data = { dyp.local_data with scm = (sr,s) :: dyp.local_data.scm } in
      (0, sr, Snull), [Local_data local_data]
    }

  | "SAVE"
    {
      print_endline "Setting automaton";
      let sr = getsr dyp in
      let s = Marshal.to_string (function_free_pdev dyp.parser_pilot.pp_dev) [] in
      dyp.global_data.parsing_device := Some s;
      (0,sr,Snull)
    }

tstatement:
  | "syntax" NAME "{" dyprods "}"
    @{
      (* NOTE ORDER!! dyprods is reversed, but the fold reverses it again *)
      (*
      print_endline ("Parsed syntax extensions " ^ $2);
      print_endline ("Defining syntax extensions " ^ $2);
      *)
      let sr = getsr dyp in
      let dssl = $2 in
      let m = dyp.local_data in
      let m =
        if Drules.mem dssl m.drules then m
        else { m with drules = Drules.add dssl fresh_dssl m.drules }
      in
      let global_data,local_data = List.fold_left
        (fun (g,l) x -> add_rule g l dssl x)
        (dyp.global_data, m)
        $4
      in
      (* This cal tries to avoid gratutions mods to global/local data
         by checking for physical equality. Note changes to any
         embedded mutable data structure propagate anyhow.
      *)
      let mods =
        (if dyp.global_data != global_data then [Global_data global_data] else [])
        @
        (if dyp.local_data != local_data then [Local_data local_data] else [])
      in
      (0, sr, Snull), mods
    }


  | "open" "syntax" basic_name_comma_list ";"
    @{
      let sr = getsr dyp in
      print_endline
        ("Opening syntax extensions " ^ Flx_srcref.short_string_of_src sr);

      let dssls = List.map snd $3 in

      print_endline
        ("Parsed open of syntax extensions " ^ String.concat "," dssls);

      let m = dyp.local_data in

      let to_install = tran_cls_dssls m.drules m.installed_dssls dssls in
      let rules, prios = extract_syntax to_install m.drules in
      let add_rules, bindings = bind_grammar_rules dyp rules in
      let local_data = 
      { 
        m with installed_dssls = to_install @ m.installed_dssls
      } 
      in
      (0, sr, Snull),
      bindings @ [Add_rules add_rules; Local_data local_data; Relation prios]
    }

sexpr: | DUMMY { 0, Flx_srcref.dummy_sr, Snull }

/*
a definite non-terminal for a sequence of no tokens,
since the production syntax cannot parse an empty
production at the moment
*/
sepsilon: | { 0, Flx_srcref.dummy_sr, Snull }
strepsilon: | { 0, Flx_srcref.dummy_sr, Sstring "" }

basic_name:
  | NAME { getsr dyp, $1 }

basic_name_comma_list:
  | basic_name "," basic_name_comma_list { $1 :: $3 }
  | basic_name { [$1] }

epsilon: | { () }


%%

{
let parse_lexbuf old_local_data lexbuf =
  let env = global_data.env in
  let adjust_line s =
    match s with
    | Sstring s -> incr_lineno lexbuf (lfcount s); Sunspec
    | _ -> raise (Ocs_error.Error ("adjust-linecount: not a string"))
    in
  Ocs_env.set_pf1 env adjust_line "adjust-linecount";

  let show_error () =
    let b = (Dyp.std_lexbuf lexbuf) in
    let file = b.lex_start_p.pos_fname in
    let start_line = b.lex_start_p.pos_lnum in
    let start_col = b.lex_start_p.pos_cnum - b.lex_start_p.pos_bol + 1 in
    let end_line = b.lex_curr_p.pos_lnum in
    let end_col = b.lex_curr_p.pos_cnum - b.lex_start_p.pos_bol in
    let sr = Flx_srcref.make (file, start_line, start_col, end_line, end_col) in
    print_endline (Flx_srcref.long_string_of_src sr);
  in
  let local_data =
    try
      dyphack (compilation_unit ~local_data:old_local_data ~global_data lexbuf)
    with
      | Failure s ->
        begin
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          print_endline ("Parse fail " ^ s);
          show_error();
          raise (Flx_exceptions.ParseError ("Failure \"" ^ s ^ "\" Parsing File"))
        end
      | Flx_exceptions.ClientError (sr, s)
      | Flx_exceptions.ClientError2 (sr, _, s)
      | Flx_exceptions.ClientErrorn (sr::_, s) as x  ->
        begin
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          print_endline "Parse fail";
          print_endline (Flx_srcref.long_string_of_src sr);
          raise x
        end

      | Dyp.Syntax_error as x ->
          show_error();
          raise x

      | Dyp.Bad_constructor (nt, ctor1, ctor2) ->
          let s = "Bad constructor '" ^ ctor1 ^ "' and '" ^ ctor2 ^ "' for nonterminal '" ^ nt ^ "'" in
          print_endline s;
          failwith s

      | x ->
        begin
          print_string "Fatal error: exception ";
          print_endline (Printexc.to_string x);
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
  in
  local_data

let make_parser_state () = local_data

let parser_data { rev_stmts = r } = r

let parse_channel ?(name="<channel>") parser_state channel =
  let parser_pilot = pp () in
  let lexbuf = Dyp.from_channel parser_pilot channel in
  Dyp.set_fname lexbuf name;
  parse_lexbuf parser_state lexbuf

let parse_file ?(include_dirs=[]) parser_state name =
  let name = Flx_filesys.find_file ~include_dirs name in
  Flx_filesys.with_file_in name (parse_channel ~name parser_state)

let parse_string ?(name="<string>") parser_state str =
  let parser_pilot = pp() in
  let lexbuf = Dyp.from_string parser_pilot str in
  Dyp.set_fname lexbuf name;
  parse_lexbuf parser_state lexbuf

let parse_function ?(name="<function>") parser_state f =
  let parser_pilot = pp () in
  let lexbuf = Dyp.from_function parser_pilot f in
  parse_lexbuf parser_state lexbuf


(* ---------------------------------------------------------------------------------------- *)

let parse_syntax_lexbuf old_local_data lexbuf =
  let show_error () =
    let b = (Dyp.std_lexbuf lexbuf) in
    let file = b.lex_start_p.pos_fname in
    let start_line = b.lex_start_p.pos_lnum in
    let start_col = b.lex_start_p.pos_cnum - b.lex_start_p.pos_bol + 1 in
    let end_line = b.lex_curr_p.pos_lnum in
    let end_col = b.lex_curr_p.pos_cnum - b.lex_start_p.pos_bol in
    let sr = Flx_srcref.make (file, start_line, start_col, end_line, end_col) in
    print_endline (Flx_srcref.long_string_of_src sr);
  in
  let local_data =
    try
      dyphack (syntax_unit ~local_data:old_local_data ~global_data lexbuf)
    with
      | Failure s ->
        begin
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          print_endline ("Parse fail " ^ s);
          show_error();
          raise (Flx_exceptions.ParseError ("Failure \"" ^ s ^ "\" Parsing File"))
        end
      | Flx_exceptions.ClientError (sr, s)
      | Flx_exceptions.ClientError2 (sr, _, s)
      | Flx_exceptions.ClientErrorn (sr::_, s) as x  ->
        begin
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          print_endline "Parse fail";
          print_endline (Flx_srcref.long_string_of_src sr);
          raise x
        end

      | Dyp.Syntax_error as x ->
          show_error();
          raise x

      | Dyp.Bad_constructor (nt, ctor1, ctor2) ->
          let s = "Bad constructor '" ^ ctor1 ^ "' and '" ^ ctor2 ^ "' for nonterminal '" ^ nt ^ "'" in
          print_endline s;
          failwith s

      | x ->
        begin
          print_string "Fatal error: exception ";
          print_endline (Printexc.to_string x);
          if Printexc.backtrace_status () then begin
            print_endline (Printexc.get_backtrace ());
          end;
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
  in
  local_data


let parse_syntax_channel ?(name="<channel>") parser_state channel =
  let parser_pilot = pp () in
  let lexbuf = Dyp.from_channel parser_pilot channel in
  Dyp.set_fname lexbuf name;
  parse_syntax_lexbuf parser_state lexbuf

let parse_syntax_file ?(include_dirs=[]) parser_state name =
  let name = Flx_filesys.find_file ~include_dirs name in
  Flx_filesys.with_file_in name (parse_syntax_channel ~name parser_state)

}
