open Flx_token
open List

let hash_table_from_list n lst =
  let tbl = Hashtbl.create n
  in let addEntry (s,kw) = Hashtbl.add tbl s kw
  in
  List.iter addEntry lst;
  tbl

let flx_keywords = [
  "all", "ALL";
  "assert", "ASSERT";
  "axiom", "AXIOM";
  "body", "BODY";
  "call", "CALL";
  "case", "CASE";
  "caseno", "CASENO";
  "cfun", "CFUNCTION";
  "class", "CLASS";
  "comment", "COMMENT_KEYWORD";
  "compound", "COMPOUND";
  "const", "CONST";
  "cproc", "CPROCEDURE";
  "cstruct", "CSTRUCT";
  "ctor", "CTOR";
  "ctypes", "CTYPES";
  "def", "DEF";
  "do", "DO";
  "done", "DONE";
  "elif", "ELIF";
  "else", "ELSE";
  "endcase", "ENDCASE";
  "endif", "ENDIF";
  "endmatch", "ENDMATCH";
  "enum", "ENUM";
  "expect", "EXPECT";
  "export", "EXPORT";
  "extern", "EXTERN";
  "for", "FOR";
  "forget", "FORGET";
  "fork", "FORK";
  "functor", "FUNCTOR";
  "fun", "FUNCTION";
  "gen", "GENERATOR";
  "goto", "GOTO";
  "halt", "HALT";
  "header", "HEADER";
  "ident", "IDENT";
  "include", "INCLUDE";
  "incomplete", "INCOMPLETE";
  "inf", "INF";
  "in", "IN";
  "instance", "INSTANCE";
  "is", "IS";
  "inherit", "INHERIT";
  "inline", "INLINE";
  "jump", "JUMP";
  "lemma", "LEMMA";
  "let", "LET";
  "loop", "LOOP";
  "lval", "LVAL";
  "macro", "MACRO";
  "module", "MODULE";
  "namespace", "NAMESPACE";
  "NaN", "NAN";
  "new", "NEW";
  "noinline", "NOINLINE";
  "nonterm", "NONTERM";
  "noreturn", "NORETURN";
  "not", "NOT";
  "open", "OPEN";
  "package", "PACKAGE";
  "pod", "POD";
  "private", "PRIVATE";
  "proc", "PROCEDURE";
  "property", "PROPERTY";
  "reduce", "REDUCE";
  "ref", "REF";
  "rename", "RENAME";
  "requires", "REQUIRES";
  "return", "RETURN";
  "SCHEME", "SCHEME";
  "syntax", "SYNTAX";
  "static", "STATIC";
  "struct", "STRUCT";
  "then", "THEN";
  "todo", "TODO";
  "to", "TO";
  "typedef", "TYPEDEF";
  "type", "TYPE";
  "typeclass", "TYPECLASS";
  "union", "UNION";
  "use", "USE";
  "val", "VAL";
  "var", "VAR";
  "virtual", "VIRTUAL";
  "where", "WHERE";
  "when", "WHEN";
  "with", "WITH";
  "yield", "YIELD";
  "_gc_pointer", "GC_POINTER";
  "_gc_type", "GC_TYPE";
  "_svc", "SVC";
  "_deref", "DEREF";
  "and", "AND";
  "as", "AS";
  "callback", "CALLBACK";
  "code", "CODE";
  "false", "FALSE";
  "if", "IF";
  "isin", "ISIN";
  "match", "MATCH";
  "noexpand", "NOEXPAND";
  "of", "OF";
  "or", "OR";
  "the", "THE";
  "true", "TRUE";
  "typematch", "TYPEMATCH";
  "typecase", "TYPECASE";
  "whence", "WHENCE";
  "unless", "UNLESS";
  "_", "UNDERSCORE";
]

let flx_syms = [
  "DOLLAR", "$";
  "QUEST", "?";
  "EXCLAMATION", "!";
  "LPAR", "(";
  "RPAR", ")";
  "LSQB", "[";
  "RSQB", "]";
  "LBRACE", "{";
  "RBRACE", "}";
  "COLON", ":";
  "COMMA", ",";
  "SEMI", ";";
  "PLUS", "+";
  "MINUS", "-";
  "STAR", "*";
  "SLASH", "/";
  "VBAR", "|";
  "AMPER", "&";
  "LESS", "<";
  "GREATER", ">";
  "EQUAL", "=";
  "DOT", ".";
  "PERCENT", "%";
  "BACKQUOTE", "`";
  "TILDE", "~";
  "CIRCUMFLEX", "^";
  "HASH", "#";
  "DOLLARDOLLAR", "$$";
  "ANDLESS", "&<";
  "ANDGREATER", "&>";
  "EQEQUAL", "==";
  "NOTEQUAL", "!=";
  "LESSEQUAL", "<=";
  "GREATEREQUAL", ">=";
  "LEFTSHIFT", "<<";
  "RIGHTSHIFT", ">>";
  "STARSTAR", "**";
  "LESSCOLON", "<:";
  "COLONGREATER", ":>";
  "DOTDOT", "..";
  "COLONCOLON", "::";
  "PLUSPLUS", "++";
  "MINUSMINUS", "--";
  "PLUSEQUAL", "+=";
  "MINUSEQUAL", "-=";
  "STAREQUAL", "*=";
  "SLASHEQUAL", "/=";
  "PERCENTEQUAL", "%=";
  "CARETEQUAL", "^=";
  "VBAREQUAL", "|=";
  "AMPEREQUAL", "&=";
  "TILDEEQUAL", "~=";
  "COLONEQUAL", ":=";
  "RIGHTARROW", "->";
  "EQRIGHTARROW", "=>";
  "LEFTARROW", "<-";
  "LSQBAR", "[|";
  "RSQBAR", "|]";
  "AMPERAMPER", "&&";
  "VBARVBAR", "||";
  "SLOSHAMPER", "\\&";
  "SLOSHVBAR", "\\|";
  "SLOSHCIRCUMFLEX", "\\^";
  "HASHBANG", "#!";
  "LEFTSHIFTEQUAL", "<<=";
  "RIGHTSHIFTEQUAL", ">>=";
  "LEFTRIGHTARROW", "<->";
  "ANDEQEQUAL", "&==";
  "ANDNOTEQUAL", "&!=";
  "ANDLESSEQUAL", "&<=";
  "ANDGREATEREQUAL", "&>=";
  "DOTDOTDOT", "...";
  "LONGRIGHTARROW", "-->";
  "PARSE_ACTION", "=>#";
  "HASHBANGSLASH", "#!/";
]

let flx_keyword_table =          (* 97 is a prime larger than table size *)
  hash_table_from_list 97 [
  "all", (fun s -> ALL s);
  "assert", (fun s -> ASSERT s);
  "axiom", (fun s -> AXIOM s);
  "body", (fun s -> BODY s);
  "call", (fun s -> CALL s);
  "case", (fun s -> CASE s);
  "caseno", (fun s -> CASENO s);
  "cfun", (fun s -> CFUNCTION s);
  "class", (fun s -> CLASS s);
  "comment", (fun s -> COMMENT_KEYWORD s);
  "compound", (fun s -> COMPOUND s);
  "const", (fun s -> CONST s);
  "cproc", (fun s -> CPROCEDURE s);
  "cstruct", (fun s -> CSTRUCT s);
  "ctor", (fun s -> CTOR s);
  "ctypes", (fun s -> CTYPES s);
  "def", (fun s -> DEF s);
  "do", (fun s -> DO s);
  "done", (fun s -> DONE s);
  "elif", (fun s -> ELIF s);
  "else", (fun s -> ELSE s);
  "endcase", (fun s -> ENDCASE s);
  "endif", (fun s -> ENDIF s);
  "endmatch", (fun s -> ENDMATCH s);
  "enum", (fun s -> ENUM s);
  "expect", (fun s -> EXPECT s);
  "export", (fun s -> EXPORT s);
  "extern", (fun s -> EXTERN s);
  "for", (fun s -> FOR s);
  "forget", (fun s -> FORGET s);
  "fork", (fun s -> FORK s);
  "functor", (fun s -> FUNCTOR s);
  "fun", (fun s -> FUNCTION s);
  "gen", (fun s -> GENERATOR s);
  "goto", (fun s -> GOTO s);
  "halt", (fun s -> HALT s);
  "header", (fun s -> HEADER s);
  "ident", (fun s -> IDENT s);
  "include", (fun s -> INCLUDE s);
  "incomplete", (fun s -> INCOMPLETE s);
  "inf", (fun s -> INF s);
  "in", (fun s -> IN s);
  "instance", (fun s -> INSTANCE s);
  "is", (fun s -> IS s);
  "inherit", (fun s -> INHERIT s);
  "inline", (fun s -> INLINE s);
  "jump", (fun s -> JUMP s);
  "lemma", (fun s -> LEMMA s);
  "let", (fun s -> LET s);
  "loop", (fun s -> LOOP s);
  "lval", (fun s -> LVAL s);
  "macro", (fun s -> MACRO s);
  "module", (fun s -> MODULE s);
  "namespace", (fun s -> NAMESPACE s);
  "NaN", (fun s -> NAN s);
  "new", (fun s -> NEW s);
  "noinline", (fun s -> NOINLINE s);
  "nonterm", (fun s -> NONTERM s);
  "noreturn", (fun s -> NORETURN s);
  "not", (fun s -> NOT s);
  "open", (fun s -> OPEN s);
  "package", (fun s -> PACKAGE s);
  "pod", (fun s -> POD s);
  "private", (fun s -> PRIVATE s);
  "proc", (fun s -> PROCEDURE s);
  "property", (fun s -> PROPERTY s);
  "reduce", (fun s -> REDUCE s);
  "ref", (fun s -> REF s);
  "rename", (fun s -> RENAME s);
  "requires", (fun s -> REQUIRES s);
  "return", (fun s -> RETURN s);
  "SCHEME", (fun s -> SCHEME s);
  "syntax", (fun s -> SYNTAX s);
  "static", (fun s -> STATIC s);
  "struct", (fun s -> STRUCT s);
  "then", (fun s -> THEN s);
  "todo", (fun s -> TODO s);
  "to", (fun s -> TO s);
  "typedef", (fun s -> TYPEDEF s);
  "type", (fun s -> TYPE s);
  "typeclass", (fun s -> TYPECLASS s);
  "union", (fun s -> UNION s);
  "use", (fun s -> USE s);
  "val", (fun s -> VAL s);
  "var", (fun s -> VAR s);
  "virtual", (fun s -> VIRTUAL s);
  "where", (fun s -> WHERE s);
  "when", (fun s -> WHEN s);
  "with", (fun s -> WITH s);
  "yield", (fun s -> YIELD s);
  "_gc_pointer", (fun s -> GC_POINTER s);
  "_gc_type", (fun s -> GC_TYPE s);
  "_svc", (fun s -> SVC s);
  "_deref", (fun s -> DEREF s);
  "and", (fun s -> AND s);
  "as", (fun s -> AS s);
  "callback", (fun s -> CALLBACK s);
  "code", (fun s -> CODE s);
  "false", (fun s -> FALSE s);
  "if", (fun s -> IF s);
  "isin", (fun s -> ISIN s);
  "match", (fun s -> MATCH s);
  "noexpand", (fun s -> NOEXPAND s);
  "of", (fun s -> OF s);
  "or", (fun s -> OR s);
  "the", (fun s -> THE s);
  "true", (fun s -> TRUE s);
  "typematch", (fun s -> TYPEMATCH s);
  "typecase", (fun s -> TYPECASE s);
  "whence", (fun s -> WHENCE s);
  "unless", (fun s -> UNLESS s);
  "_", (fun s -> UNDERSCORE s);
]

let map_flx_keywords srcref lex_item =
  try (Hashtbl.find flx_keyword_table lex_item) srcref
  with Not_found -> NAME (srcref, lex_item)
