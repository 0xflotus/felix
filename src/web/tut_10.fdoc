@h1 Structs
You can also have named structures as in C:
@felix
struct X {
  a:int;
  b:double;
};
var X x = X(1,2);
println$ str x.a + str x.b;
@
Each {struct} has an autogenerated constructor which takes a tuple
of values of types in the same order as declared in the {struct}
definition.

{struct}s are similar to records, however records are <em>structurally typed</em>,
or <em>anonymously typed</em>. This means you can just create a value
of a record type, without declaring the type.

For a {struct} however, you must first declare the type and give it a name:
they're said to be <em>nominally typed</em>. This means two {struct}s with the
same components but declared with distinct names are distinct types.

@h2 Accessor Methods
You can also define {fun}ctions in a {struct} like this:

@felix
struct complx {
  x: double;
  y: double;
  fun arg => tan (self.x/self.y);
  fun mod => sqrt (self.x * self.x + self.y * self.y);
  fun add (z:complx) => complx(self.x + z.x, self.y + z.y);
}

var z = complx(0.5, 0.5);
println$ z.x, z.y, z.arg, z.mod;

var a = z.add z;
println$ a.x, a.y;
@
Accessor functions are ordinary function which just get an extra
argument called {self} of the type of the {struct}.

@h2 Mutator Methods
You can also define mutators in a {struct}.
@felix
struct complx {
  x: double;
  y: double;
  proc doset (xx:double, yy:double) { self.x = xx; self.y = yy; }
}

var a = complx(1.0,2.0);
(&a).doset (0.7, 0.8);
println$ a.x, a.y;
@
Note that mutators require a pointer argument.
