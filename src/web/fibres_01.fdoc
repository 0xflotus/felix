@h1 Fibres and Channels
Felix supports a powerful new programming paradigm which allows
millions of lightweight, cooperative threads to exist concurrently
and represent actors, monsters in a game, or other active processes.

<em>Active programming</em> is the opposite of re-active programming. Active and
re-active components can be combined. Reactive programming is good for
small simple objects, meaning, objects with simple state.


Active programming is better when objects have complex state because
the stack can be used to encode part or all of the state.

Active programming uses two constructions: fibres (also called felix threads
or just f-threads), and synchronous channels, also called s-channels.
F-threads exchange control by transfer of the control token along an s-channel,
possibly along with some data.

Best to show an example of course!

@felix
open Text_file;

proc client(x:ischannel[string]) {
  while true do
    line := read x;
    print line;
  done
}

proc server(x:oschannel[string]) {
  f := fopen_input "xyz.flx";
  var line = readln f;
  while line != "" do
    write$ x,line;
    line = readln f;
  done;
  fclose f;
}

proc launch() {
  inp,out:= mk_ioschannel_pair[string]();
  spawn_fthread { client(inp); };
  spawn_fthread { server (out); };
}

launch;
println$ "Launched!";
@

In this example we implement a simple client/server application.
Of course this could easily be rewritten in an ordinary coding style,
but the active programming style offers a major advantage: the client
and server code are entirely decoupled statically: they're linked only
by a dynamically passed synchronous channel. 

The client and server are ordinary procedures. The library function
{spawn_fthread} launches its argument as a new fibre, 
which must be a procedure accepting no arguments: that's the 
bit in the braces (which in turn calls the server or client).

The client and server run <em>alternately</em> and <em>not concurrently</em>.
Control is <em>exchanged</em> between the client and server by reading or
writing to an {schannel}.

The way this works is: both the client and server are added to a list of
fibres waiting to be resumed at their entry point. When the mainline
fibre exits one of these is popped off the wait list and execution
begins. It continues until the fibre reads or write to an schannel
or terminates.

Lets assume the server runs first. When the server does a write on
the schannel, the system discovers there's no corresponding read,
so it simply resumes the fibre on top of the wait list, which will
be the client. The writer is attached to the schannel as a pending
fibre.

When the client does a read, it finds there is a writer waiting
on the channel, so the writer is moved off the channel and put
back on the wait list.

The actual data transfer is always implemented by passing a pointer
from the writer to the reader: this is usually a pointer to a heap
copy of the data being written (rather than a pointer to the stack
of the writer, since that may be modified or invalidated when the
writer resumes).

If the client runs first, the same kind of control exchange is
performed. It makes no difference which one runs first: the first
fibre to access the thread is suspended and the one first doing
the corresponding input/output operation captures the data, if any,
then moves the suspended fibre off the channel onto the wait list.

It is possible for multiple fibres to write to or read from a channel
before a corresponding read or write is executed. When that happens,
one of the multiple waiting fibres is selected at random and its
data captured and it is then put back on the wait list.

It is also indeterminate which of the reader/write pair will be
resumed first after the data transfer.

You should note carefully that the transfer of data along the channel
is not important: the key thing is that the transfer acts as a 
synchronisation point.

There is one further very important issue: what happens if a 
read is performed and there's no writer around? Or similarly,
if a write is performed and there's no reader?

The answer is: nothing. Literally nothing. Fibres <em>cannot deadlock</em>
in the sense that if one is stalled because the owners of the other end
of the channel have completed, then the stalled procedure is no longer
reachable and will be reaped by the garbage collector.

It is therefore vital <em>not</em> to store the channels in, say,
global variables, because that would make waiting fibres reachable.
In other words, if a running or waiting fibre can access a channel,
it could in theory complete the pending I/O operation .. even if it
never does. In that case, the suspended fibre will wait until the
last channel owner terminates.

You should also note that control transfer by this mechanism
is synchronous, that is, under program control. There is no possibility
of pre-emption, so low level locks are not required. Of course high
level interlocking of fibres is required by carefully desiging the
system.

A collection of fibres and channels is, in fact, a network,
and acts very much like a collection of integrated circuits 
connected with wires.

It is this fact that is the key to the power of active programming:
the "chips" can be designed and programmed independently and
connected together dynamically to make a circuit.

In passing we mention that function subroutines are just a special case 
of this where argument is passed in using an channel and the return
value is passed out using a channel too:

@felix
proc subroutine(argument: ischannel[int], result: oschannel[string)
{
  v := read argument;
  s = str v;
  write$ result, s;
}

{
  iarg,oarg := mk_ioschannel_pair[int];
  ires,ores := mk_ioschannel_pair[string];
  spawn_fthread { subroutine (iarg, ores); }
  write$ oarg, 42;
  s := read ires;
  println$ "42 as a string is " + s;
};
@

In other words, the fibres and channels model subsumes then function
and procedure call and return model. Note clearly that with subroutines
we also pass data in and out along with control.

Of course the fibre and channel model is more complex because it
is vastly more flexible! In particular, communicating fibres are
<em>control neutral</em> with respect to each other, unlike the
asymmtric master/slave relation of the subroutine model. This is
why fibres are a much better programming paradigm. Simply
put .. <em>no more callbacks!</em> Callbacks are bad because they have
to preserve where control resumes without the benefit of the usual
control stack. Preserving control state as data this way is difficult
and error prone. Many people use pre-emptibe threads to solve this problem.
When doing that one is using the <em>control inversion</em> property
of threads, but not the facet which is their real purpose: concurrency.

Using threads also has much higher cost in terms of OS resources,
and context switching time, not to mention the need to use locks
or some construct built around them. [Note: Felix also provides
pre-emptive threads or p-threads with p-channels for communication,
the model is syntactically similar to f-thread and s-channels
but the semantics are utterly different: pthreads can deadlock
and they can exchange control at arbitrary points of time,
or even run concurrently: locks must be used to access shared
memory. Using Felix pchannels makes it easier to synchronise
data exchange.

As noted in the introduction: you can run millions of fibres
at once without a problem. The context switches are extremely
fast, and the data structures representing fibres and schannels
extremely lightweight.

By comparison pthreads are expensive in resources, slow to switch
context, and most OS cannot support very many of them. Pthreads
should <em>only</em> be used in two circumstances: first, to manage
asynchonous data sources, and secondly to share the workload of
real-time processes between multiple CPUs. If you merely want
to obtain contol inversion, use fibres instead.

A sophisticated example of use of fibres is to be found
in the Felix webserver (in the tools directory). This launches
a fibre for each connection. A single pthread is used in the
system to monitor all socket I/O. The serves does not require
a pthread for each connection: only one http request can be
serviced at once so there's no reason for concurrency unless
you want to shared the load between several CPUs.

As noted before, consider what would happen if we wrote by mistake:
@felix
  s := read ires;
  write$ oarg, 42;
@

It's simple. The read suspends the calling procedure (in braces),
but the subroutine also suspends doing a read. So we have two
reads an no writes. Deadlocked? No. We have two suspended procedures
hanging on a channel owned by one of them so no active procedure
can communicate with either of these suspended procedures,
in other words they're unreachable and so they're reaped by
the garbage collector.

You can do this deliberately as a way to terminate a fibre!
In that case it is known as <em>suicide</em>. Accidental suicide
will cause code you expected to execute to simply evaporate.
In the same circumstances pre-emptive threads deadlock (because
the communication media are owned by the operating system
not the user program, and the OS has no concept of reachability).

@h2 A broadcast service
As noted, if you have multiple readers and one writer, only
one of the readers is sent the data. That seems like a restriction,
and suggests an extension. 

But no! The existing model is enough:

@felix
gen broadcaster() : 
  oschannel[oschannel[string]] * // subscription channel
  oschannel[string]              // news reporting channel
=
{
  // -------------------------------------------------------------
  // SUBSCRIPTIONS
  // -------------------------------------------------------------

  // subscriber list
  var clients = darray[oschannel[string]] ();

  // subscription channel
  iregistry, oregistry := mk_ioschannel_pair[oschannel[string]]();

  // accept registrations
  spawn_fthread {
    while true do
      push_back (clients, read iregistry);
      println "Got a subscriber";
    done
  };
 
  // -------------------------------------------------------------
  // RELAY THE NEWS
  // -------------------------------------------------------------

  // news reading channel
  inews, onews := mk_ioschannel_pair[string]();

  // send news to all clients
  spawn_fthread {
    while true do
      news_line := read inews;
      if len clients > 0uz do
        for var i in 0uz upto len clients - 1uz do
          write$ clients.[i], news_line;
        done
      done
    done
  };

  // return the channel for subscribing to news reports,
  // and the channel for making news reports
  return oregistry, onews;
}

// Create the broadcast station
subscribe, news := broadcaster();

// create a template for bored train commuters who want to read the news
proc commuter (i:int) {
  ichan, ochan := mk_ioschannel_pair[string]();
  write$ subscribe, ochan; //subscribe to news
  while true do 
   line := read ichan;
   print$ "Commuter " + str i + ": " + line;
  done
}

// create two commuters
spawn_fthread { commuter 1; };
spawn_fthread { commuter 2; };

// yield so that the commuters get a chance to subscribe
// to the new before the broadcast begins
// (this is a hack just to make the demo work)
svc$ svc_yield;

// create a reporter that just sends a file as news
spawn_fthread {
  f := Text_file::fopen_input "br.flx";
  var line = Text_file::readln f;
  while line != "" do
    print$ "Reporting : " + line;
    write$ news, line;
    line = Text_file::readln f;
  done
  Text_file::fclose f;
};

println$ "Demo started";
@

