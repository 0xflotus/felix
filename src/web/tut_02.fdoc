@h1 Simple function definitions
You can define simple calculations easily. We'll
use a classic example:
@felix
fun square (x:int) => x * x;
write$ stdout, "Input number: "; fflush stdout;
val result = readln$ stdin;
val cleaned_result = strip result;
val v = int cleaned_result;
val v2 = square v;
println$ "Square of " + str v + " is " + str v2;
@
Here:
<ul>
<li> The {fun} binder introduces the function {square}.</li>
<li> {square} accepts a single argument of type {int}.</li>
<li> The operator {*} is used for multiplication.</li>
<li> {square} returns the product of its argument with itself.</li>
<li> The type of value returned by {square} is deduced by the compiler, 
that type will be {int} because multiplying an {int} by another {int}
yields an {int}. </li>
<li> The type {int} can also be used as a function to convert a {string} 
containing only digits to an {int}.</li>
<li>The function {str} can be used to convert an {int} to a string.</li>
</ul>

There is a rule for functions: 
<blockquote><em>
A function introduced by
a {fun} binder is not allowed to have any side effects.
</em></blockquote>

The compiler does not enforce this rule, but it does take
advantage of it when optimising your code. 

@h1 Simple procedure definitions
It is also possible to defined new commands,
these are called procedures. Procedures do not return
a value, and may and generally should have side-effects.
Here is a simple example:
@felix
proc prompt (x:string) {
  write$ stdout, x; 
  fflush stdout;
}
prompt "Input number :";
println$ readln$ stdin;
@
Here:
<ul>
<li> The {proc} binder introduces a procedure.</li>
<li> The procedure {prompt} issues a prompt on {stdout} with
a {fflush} to force the output to the device.</li>
<li> Procedures have side effects, here it is I/O.</li>
<li> Procedures cannot return values </li>
</ul>

@h1 Simple generator definition
A <em>generator</em> is a function that may have side effects.
@felix
gen getnum():int {
  prompt "Input number : ";
  var x = readln stdin;
  return x;
}
@

