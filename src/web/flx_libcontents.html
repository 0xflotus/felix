fdoc2html initialisation
flx2html initialisation
cpp2html initialisation
cpp2html initialisation
ocaml2html initialisation
Py2html initialisation
<html><body>
<h1>Felix Library Contents</h1>
<hr/><a href="/$src/lib/std/__init__.flx">__init__.flx</a>
<hr/><a href="/$src/lib/std/address.flx">address.flx</a>

<pre>0002:  <a href="/$src/lib/std/address.flx#0002">open class Address</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Core operations on addresses.
</p></div>
<pre>0004:    <a href="/$src/lib/std/address.flx#0004">ctor[T] address: &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from Felix object pointer.
</p></div>
<pre>0007:    <a href="/$src/lib/std/address.flx#0007">ctor[T] address: @T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from possibly NULL pointer.
</p></div>
<pre>0010:    <a href="/$src/lib/std/address.flx#0010">ctor[T] address: +T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from possibly array element pointer.
</p></div>
<pre>0013:    <a href="/$src/lib/std/address.flx#0013">ctor[D,C] address: D --> C</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct from C function
</p></div>
<pre>0017:    <a href="/$src/lib/std/address.flx#0017">fun isNULL: address -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check is an address is NULL.
</p></div>
<pre>0029:    <a href="/$src/lib/std/address.flx#0029">fun str (t:T) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Define NULL address.
</p></div>
<hr/><a href="/$src/lib/std/algebraic.flx">algebraic.flx</a>

<pre>0004:  <a href="/$src/lib/std/algebraic.flx#0004">class FloatAddgrp[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Additive symmetric float-approximate group, symbol +.
 Note: associativity is not assumed.
</p></div>
<pre>0006:    <a href="/$src/lib/std/algebraic.flx#0006">virtual fun zero: unit -> t</a></pre>
<pre>0020:    <a href="/$src/lib/std/algebraic.flx#0020">fun add(x:t,y:t)</a></pre>
<pre>0021:    <a href="/$src/lib/std/algebraic.flx#0021">fun plus(x:t)</a></pre>
<pre>0022:    <a href="/$src/lib/std/algebraic.flx#0022">fun sub(x:t,y:t)</a></pre>
<pre>0023:    <a href="/$src/lib/std/algebraic.flx#0023">fun neg(x:t)</a></pre>
<pre>0024:    <a href="/$src/lib/std/algebraic.flx#0024">proc pluseq(px:&t, y:t)</a></pre>
<pre>0025:    <a href="/$src/lib/std/algebraic.flx#0025">proc  minuseq(px:&t, y:t)</a></pre>

<pre>0030:  <a href="/$src/lib/std/algebraic.flx#0030">class Addgrp[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Additive symmetric group, symbol +.
</p></div>

<pre>0038:  <a href="/$src/lib/std/algebraic.flx#0038">class FloatMultSemi1[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Multiplicative symmetric float-approximate semi group with unit symbol *.
 Note: associativity is not assumed.
</p></div>
<pre>0040:    <a href="/$src/lib/std/algebraic.flx#0040">proc muleq(px:&t, y:t)</a></pre>
<pre>0041:    <a href="/$src/lib/std/algebraic.flx#0041">fun mul(x:t, y:t)</a></pre>
<pre>0042:    <a href="/$src/lib/std/algebraic.flx#0042">fun sqr(x:t)</a></pre>
<pre>0043:    <a href="/$src/lib/std/algebraic.flx#0043">fun cube(x:t)</a></pre>
<pre>0044:    <a href="/$src/lib/std/algebraic.flx#0044">virtual fun one: unit -> t</a></pre>

<pre>0052:  <a href="/$src/lib/std/algebraic.flx#0052">class MultSemi1[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Multiplicative semi group with unit.
</p></div>

<pre>0059:  <a href="/$src/lib/std/algebraic.flx#0059">class FloatRing[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate ring.
</p></div>

<pre>0065:  <a href="/$src/lib/std/algebraic.flx#0065">class Ring[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Ring.
</p></div>

<pre>0072:  <a href="/$src/lib/std/algebraic.flx#0072">class FloatDring[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate division ring.
</p></div>
<pre>0079:    <a href="/$src/lib/std/algebraic.flx#0079">fun div(x:t, y:t)</a></pre>
<pre>0080:    <a href="/$src/lib/std/algebraic.flx#0080">fun mod(x:t, y:t)</a></pre>
<pre>0081:    <a href="/$src/lib/std/algebraic.flx#0081">fun recip (x:t)</a></pre>
<pre>0083:    <a href="/$src/lib/std/algebraic.flx#0083">proc diveq(px:&t, y:t)</a></pre>
<pre>0084:    <a href="/$src/lib/std/algebraic.flx#0084">proc modeq(px:&t, y:t)</a></pre>

<pre>0088:  <a href="/$src/lib/std/algebraic.flx#0088">class Dring[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Division ring.
</p></div>

<pre>0095:  <a href="/$src/lib/std/algebraic.flx#0095">class Bits[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Bitwise operators.
</p></div>
<pre>0104:    <a href="/$src/lib/std/algebraic.flx#0104">fun bxor(x:t,y:t)</a></pre>
<pre>0105:    <a href="/$src/lib/std/algebraic.flx#0105">fun bor(x:t,y:t)</a></pre>
<pre>0106:    <a href="/$src/lib/std/algebraic.flx#0106">fun band(x:t,y:t)</a></pre>
<pre>0107:    <a href="/$src/lib/std/algebraic.flx#0107">fun bnot(x:t)</a></pre>

<pre>0112:  <a href="/$src/lib/std/algebraic.flx#0112">class Integer[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Integers.
</p></div>
<pre>0119:    <a href="/$src/lib/std/algebraic.flx#0119">fun shl(x:t,y:t)</a></pre>
<pre>0120:    <a href="/$src/lib/std/algebraic.flx#0120">fun shr(x:t,y:t)</a></pre>

<pre>0124:  <a href="/$src/lib/std/algebraic.flx#0124">class Signed_integer[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Signed Integers.
</p></div>
<pre>0126:    <a href="/$src/lib/std/algebraic.flx#0126">virtual fun sgn: t -> int</a></pre>
<pre>0127:    <a href="/$src/lib/std/algebraic.flx#0127">virtual fun abs: t -> t</a></pre>

<pre>0131:  <a href="/$src/lib/std/algebraic.flx#0131">class Unsigned_integer[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Unsigned Integers.
</p></div>

<pre>0137:  <a href="/$src/lib/std/algebraic.flx#0137">class Trig[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate trigonometric functions.
</p></div>
<pre>0146:    <a href="/$src/lib/std/algebraic.flx#0146">virtual fun sin: t -> t</a></pre>
<pre>0147:    <a href="/$src/lib/std/algebraic.flx#0147">virtual fun cos: t -> t</a></pre>
<pre>0148:    <a href="/$src/lib/std/algebraic.flx#0148">virtual fun tan (x:t)</a></pre>
<pre>0150:    <a href="/$src/lib/std/algebraic.flx#0150">virtual fun sec (x:t)</a></pre>
<pre>0151:    <a href="/$src/lib/std/algebraic.flx#0151">virtual fun csc (x:t)</a></pre>
<pre>0152:    <a href="/$src/lib/std/algebraic.flx#0152">virtual fun cot (x:t)</a></pre>
<pre>0154:    <a href="/$src/lib/std/algebraic.flx#0154">virtual fun asin: t -> t</a></pre>
<pre>0155:    <a href="/$src/lib/std/algebraic.flx#0155">virtual fun acos: t -> t</a></pre>
<pre>0156:    <a href="/$src/lib/std/algebraic.flx#0156">virtual fun atan: t -> t</a></pre>
<pre>0158:    <a href="/$src/lib/std/algebraic.flx#0158">virtual fun asec (x:t)</a></pre>
<pre>0159:    <a href="/$src/lib/std/algebraic.flx#0159">virtual fun acsc (x:t)</a></pre>
<pre>0160:    <a href="/$src/lib/std/algebraic.flx#0160">virtual fun acot (x:t)</a></pre>
<pre>0164:    <a href="/$src/lib/std/algebraic.flx#0164">virtual fun sinh: t -> t</a></pre>
<pre>0165:    <a href="/$src/lib/std/algebraic.flx#0165">virtual fun cosh: t -> t</a></pre>
<pre>0166:    <a href="/$src/lib/std/algebraic.flx#0166">virtual fun tanh (x:t)</a></pre>
<pre>0168:    <a href="/$src/lib/std/algebraic.flx#0168">virtual fun sech (x:t)</a></pre>
<pre>0169:    <a href="/$src/lib/std/algebraic.flx#0169">virtual fun csch (x:t)</a></pre>
<pre>0170:    <a href="/$src/lib/std/algebraic.flx#0170">virtual fun coth (x:t)</a></pre>
<pre>0172:    <a href="/$src/lib/std/algebraic.flx#0172">virtual fun asinh: t -> t</a></pre>
<pre>0173:    <a href="/$src/lib/std/algebraic.flx#0173">virtual fun acosh: t -> t</a></pre>
<pre>0174:    <a href="/$src/lib/std/algebraic.flx#0174">virtual fun atanh: t -> t</a></pre>
<pre>0176:    <a href="/$src/lib/std/algebraic.flx#0176">virtual fun asech (x:t)</a></pre>
<pre>0177:    <a href="/$src/lib/std/algebraic.flx#0177">virtual fun acsch (x:t)</a></pre>
<pre>0178:    <a href="/$src/lib/std/algebraic.flx#0178">virtual fun acoth (x:t)</a></pre>
<pre>0181:    <a href="/$src/lib/std/algebraic.flx#0181">virtual fun exp: t -> t</a></pre>
<pre>0182:    <a href="/$src/lib/std/algebraic.flx#0182">virtual fun log: t -> t</a></pre>
<pre>0183:    <a href="/$src/lib/std/algebraic.flx#0183">virtual fun pow: t * t -> t</a></pre>

<pre>0187:  <a href="/$src/lib/std/algebraic.flx#0187">class Special[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Finance and Statistics.
</p></div>
<pre>0188:    <a href="/$src/lib/std/algebraic.flx#0188">virtual fun erf: t -> t</a></pre>
<pre>0189:    <a href="/$src/lib/std/algebraic.flx#0189">virtual fun erfc: t -> t</a></pre>

<pre>0193:  <a href="/$src/lib/std/algebraic.flx#0193">class Real[t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate real numbers.
</p></div>
<pre>0197:    <a href="/$src/lib/std/algebraic.flx#0197">virtual fun embed: int -> t</a></pre>
<pre>0199:    <a href="/$src/lib/std/algebraic.flx#0199">virtual fun log10: t -> t</a></pre>
<pre>0200:    <a href="/$src/lib/std/algebraic.flx#0200">virtual fun abs: t -> t</a></pre>
<pre>0201:    <a href="/$src/lib/std/algebraic.flx#0201">virtual fun sqrt: t -> t</a></pre>
<pre>0202:    <a href="/$src/lib/std/algebraic.flx#0202">virtual fun ceil: t -> t</a></pre>
<pre>0203:    <a href="/$src/lib/std/algebraic.flx#0203">virtual fun floor: t -> t</a></pre>
<pre>0204:    <a href="/$src/lib/std/algebraic.flx#0204">virtual fun trunc: t -> t</a></pre>

<pre>0208:  <a href="/$src/lib/std/algebraic.flx#0208">class Complex[t,r]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Float-approximate Complex.
</p></div>
<pre>0212:    <a href="/$src/lib/std/algebraic.flx#0212">virtual fun real: t -> r</a></pre>
<pre>0213:    <a href="/$src/lib/std/algebraic.flx#0213">virtual fun imag: t -> r</a></pre>
<pre>0214:    <a href="/$src/lib/std/algebraic.flx#0214">virtual fun abs: t -> r</a></pre>
<pre>0215:    <a href="/$src/lib/std/algebraic.flx#0215">virtual fun arg: t -> r</a></pre>
<hr/><a href="/$src/lib/std/bool.flx">bool.flx</a>

<pre>0004:  <a href="/$src/lib/std/bool.flx#0004">open class Bool</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Standard operations on boolean type.
 Note bool = 2 defined in std/algebraic.flx.
 Literals true and false defined in grammer/expressions.flxh.
</p></div>
<pre>0007:    <a href="/$src/lib/std/bool.flx#0007">fun land: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Disjunction: logical and.
</p></div>
<pre>0010:    <a href="/$src/lib/std/bool.flx#0010">fun nand: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Negated and.
</p></div>
<pre>0013:    <a href="/$src/lib/std/bool.flx#0013">fun lor: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Conjunction: logical or.
</p></div>
<pre>0016:    <a href="/$src/lib/std/bool.flx#0016">fun nor: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Negated or.
</p></div>
<pre>0019:    <a href="/$src/lib/std/bool.flx#0019">fun xor: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Logical exclusive or.
</p></div>
<pre>0022:    <a href="/$src/lib/std/bool.flx#0022">fun lnot: bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Logical negation.
</p></div>
<pre>0025:    <a href="/$src/lib/std/bool.flx#0025">fun implies: bool * bool -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Logical implication.
</p></div>
<pre>0045:    <a href="/$src/lib/std/bool.flx#0045">fun str (b:bool) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutating or.
 Mutating and.
 Convert bool to string.
</p></div>
<hr/><a href="/$src/lib/std/c_hack.flx">c_hack.flx</a>

<pre>0006:  <a href="/$src/lib/std/c_hack.flx#0006">class C_hack</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> This class provides access to raw C/C++ encodings.
 Incorrect typing is likely to pass by Felix and
 be trapped by the C/C++ compiler. Incorrect management
 of storage can lead to corruption. The use of the
 C_hack class is necessary for interfacing.
</p></div>
<pre>0012:    <a href="/$src/lib/std/c_hack.flx#0012">type va_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C void type. Incomplete, can't be instantiated.
 Standard variable argument list pointer type.
</p></div>
<pre>0016:    <a href="/$src/lib/std/c_hack.flx#0016">type __builtin_va_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> GCC specific valist thingo: it will
 be optimised away if not used (eg on MSVC).
</p></div>
<pre>0021:    <a href="/$src/lib/std/c_hack.flx#0021">proc ignore[t]:t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Throw away result of a function call:
 only useful for C functions that are mainly
 called for side effects.
</p></div>
<pre>0024:    <a href="/$src/lib/std/c_hack.flx#0024">fun cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C style cast.
</p></div>
<pre>0027:    <a href="/$src/lib/std/c_hack.flx#0027">fun static_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ static cast.
</p></div>
<pre>0030:    <a href="/$src/lib/std/c_hack.flx#0030">fun dynamic_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ dynamic cast.
</p></div>
<pre>0033:    <a href="/$src/lib/std/c_hack.flx#0033">fun const_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ const cast.
</p></div>
<pre>0036:    <a href="/$src/lib/std/c_hack.flx#0036">fun reinterpret_cast[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ reinterpret cast.
</p></div>
<pre>0041:    <a href="/$src/lib/std/c_hack.flx#0041">fun reinterpret[dst,src]: src->dst</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Felix reinterpret cast.
 More powerful than C++ reinterpret cast.
 Allows casting an rvalue to an lvalue.
</p></div>
<pre>0047:    <a href="/$src/lib/std/c_hack.flx#0047">fun eq[T]: gcptr[T] * gcptr[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Equality for gcptr
</p></div>
<pre>0055:    <a href="/$src/lib/std/c_hack.flx#0055">fun isNULL[t]: &t -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Special lvalue deref for gcptr
 Special NULL check for Felix pointers.
 Should never succeed.
</p></div>
<pre>0059:    <a href="/$src/lib/std/c_hack.flx#0059">fun isNULL[t]: +t -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Special NULL check for carray.
 Should never succeed.
</p></div>
<pre>0063:    <a href="/$src/lib/std/c_hack.flx#0063">fun isNULL[t]: gcptr[t] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Special NULL check for gcptr.
 Might succeed.
</p></div>
<pre>0074:    <a href="/$src/lib/std/c_hack.flx#0074">fun dflt[t]:1->t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Polymorphic null pointer constant
 Values of this type should not exist.
 This value is provided for checking.
 C++ default value for a type T.
 Workaround for g++ 3.2.2 parsing bug,
 it can parse T() as a default ctor call,
 but screws up on (T())
</p></div>
<pre>0087:    <a href="/$src/lib/std/c_hack.flx#0087">gen raw_malloc: !ints -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Raw unchecked malloc.
 Used typed malloc in carray if possible.
</p></div>
<pre>0091:    <a href="/$src/lib/std/c_hack.flx#0091">gen malloc: !ints -> address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Malloc with out of memory check.
 Throws c"out of memory" if out of memory.
</p></div>
<pre>0094:    <a href="/$src/lib/std/c_hack.flx#0094">proc free: address</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Raw unchecked free.
</p></div>
<hr/><a href="/$src/lib/std/c_headers.flx">c_headers.flx</a>

<pre>0004:  <a href="/$src/lib/std/c_headers.flx#0004">class C89_headers</a></pre>

<pre>0024:  <a href="/$src/lib/std/c_headers.flx#0024">class C95_headers</a></pre>

<pre>0033:  <a href="/$src/lib/std/c_headers.flx#0033">class C99_headers</a></pre>
<hr/><a href="/$src/lib/std/carray.flx">carray.flx</a>

<pre>0002:  <a href="/$src/lib/std/carray.flx#0002">open class Carray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> A carray[T] = +T is an incrementable, non-NULL, pointer.
</p></div>
<pre>0008:    <a href="/$src/lib/std/carray.flx#0008">type carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The carray type.
</p></div>
<pre>0011:    <a href="/$src/lib/std/carray.flx#0011">typedef fun +(T:TYPE) : TYPE</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Define prefix + notation.
</p></div>
<pre>0020:    <a href="/$src/lib/std/carray.flx#0020">ctor[T] carray[T] : &T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unsafe conversion of Felix pointer to carray.
 Demote carray to Felix pointer (safe unless off the end).
 Unsafe conversion of Felix pointer to carray.
</p></div>
<pre>0023:    <a href="/$src/lib/std/carray.flx#0023">ctor[T,N] carray[T]: &array[T,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get a carray from a Felix array object.
</p></div>
<pre>0027:    <a href="/$src/lib/std/carray.flx#0027">fun array_alloc[T]: !ints -> carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Allocate a C array on the C heap (malloc).
 Unsafe: Not tracked by GC.
</p></div>
<pre>0031:    <a href="/$src/lib/std/carray.flx#0031">fun array_calloc[T]: !ints -> carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Allocate a C array on the C heap with 0 fill (cmalloc).
 Unsafe: Not tracked by GC.
</p></div>
<pre>0035:    <a href="/$src/lib/std/carray.flx#0035">proc free[T]: carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Free a C array (free).
 Must point to C heap allocated storage. Unsafe.
</p></div>
<pre>0044:    <a href="/$src/lib/std/carray.flx#0044">fun get[T]: carray[T] * !ints -> T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Lvalue reference to element by index position. Unsafe.
 Lvalue reference to element by pointer.
 Functional get by index.
</p></div>
<pre>0048:    <a href="/$src/lib/std/carray.flx#0048">fun apply [T,I in ints] (i:I, x:carray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get by index using application.
 i x = x . i = get (x,i)
</p></div>
<pre>0051:    <a href="/$src/lib/std/carray.flx#0051">proc set[T] : carray[T] * !ints * T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Store value in array at index position.
</p></div>
<pre>0054:    <a href="/$src/lib/std/carray.flx#0054">fun stl_begin[T,N]: carray[array[T,N]] -> carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get carray of an array.
</p></div>
<pre>0067:    <a href="/$src/lib/std/carray.flx#0067">proc pre_incr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Advance carray to next element.
 Backup carray to previous element.
 Calculate the offset in elements between
 two overlapping carrays.
 Mutable pre-increment ++p.
</p></div>
<pre>0070:    <a href="/$src/lib/std/carray.flx#0070">proc post_incr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable post-increment p++.
</p></div>
<pre>0073:    <a href="/$src/lib/std/carray.flx#0073">proc pre_decr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable pre-decarement --p.
</p></div>
<pre>0076:    <a href="/$src/lib/std/carray.flx#0076">proc post_decr[T]: &carray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable post-decarement p--.
</p></div>
<pre>0099:    <a href="/$src/lib/std/carray.flx#0099">fun array_of[T,N]: carray[T] -> &array[T,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Mutable advance by offset amount.
 Mutable backup by offset amount.
 Pointer equality.
 Pointer total ordering.
 Convert C array to Felix array.
</p></div>
<pre>0103:    <a href="/$src/lib/std/carray.flx#0103">proc memcpy: address * address * size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fast byte-wise copy from address to address.
 WHY IS THIS HERE?
</p></div>
<pre>0109:    <a href="/$src/lib/std/carray.flx#0109">fun memcmp: address * address * size -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fast bytewise comparison from address to address.
 WHY IS THIS HERE?
</p></div>
<pre>0117:    <a href="/$src/lib/std/carray.flx#0117">proc strcpy: carray[char] * carray[char]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C strcpy.
</p></div>
<pre>0120:    <a href="/$src/lib/std/carray.flx#0120">proc strncpy: carray[char] * carray[char] * !ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C strncpy.
</p></div>
<pre>0123:    <a href="/$src/lib/std/carray.flx#0123">fun strlen: carray[char] ->size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C strlen: NTBS length.
</p></div>
<pre>0126:    <a href="/$src/lib/std/carray.flx#0126">gen strdup(s:carray[char])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional NTBS strdup.
</p></div>
<hr/><a href="/$src/lib/std/categ.flx">categ.flx</a>

<pre>0002:  <a href="/$src/lib/std/categ.flx#0002">open class Categ</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Categorical Operators
</p></div>
<pre>0013:    <a href="/$src/lib/std/categ.flx#0013">fun curry[u,v,r] (f:u*v->r) : u -> v -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change star into arrow (2 components)
</p></div>
<pre>0016:    <a href="/$src/lib/std/categ.flx#0016">fun curry[u,v,w,r] (f:u*v*w->r) : u -> v -> w -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change star into arrow (3 components)
</p></div>
<pre>0019:    <a href="/$src/lib/std/categ.flx#0019">fun uncurry2[u,v,r] (f:u->v->r) : u * v -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change arrow into star (arity 2)
</p></div>
<pre>0022:    <a href="/$src/lib/std/categ.flx#0022">fun uncurry3[u,v,w,r] (f:u->v->w->r) : u * v * w -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> change arrow into star (arity 3)
</p></div>
<pre>0025:    <a href="/$src/lib/std/categ.flx#0025">fun twist[u,v,r] (f:u*v->r) : v * u -> r</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> argument order permutation (2 components)
</p></div>
<pre>0028:    <a href="/$src/lib/std/categ.flx#0028">fun proj1[u1,u2,r1,r2] (f:u1*u2->r1*r2) : u1 * u2 -> r1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> projection 1 (2 components)
</p></div>
<pre>0032:    <a href="/$src/lib/std/categ.flx#0032">fun proj2[u1,u2,r1,r2] (f:u1*u2->r1*r2) : u1 * u2 -> r2</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> projection 2 (2 components)
</p></div>
<pre>0037:    <a href="/$src/lib/std/categ.flx#0037">fun ravel[u1,u2,r1,r2] (f1:u1->r1,f2:u2->r2) : u1 * u2 -> r1 * r2</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> parallel composition
</p></div>
<pre>0041:    <a href="/$src/lib/std/categ.flx#0041">fun compose[u,v,w] (f:v->w, g:u->v) : u -> w</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> series composition (2 functions)
</p></div>
<pre>0046:    <a href="/$src/lib/std/categ.flx#0046">fun rev_compose[u,v,w] (f:u->v, g:v->w) : u -> w</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> series reverse composition (2 functions)
</p></div>
<hr/><a href="/$src/lib/std/char.flx">char.flx</a>

<pre>0002:  <a href="/$src/lib/std/char.flx#0002">open class Char</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Standard C operations on C character set.
</p></div>
<pre>0005:    <a href="/$src/lib/std/char.flx#0005">fun ord: char -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Ordinal value as int.
</p></div>
<pre>0011:    <a href="/$src/lib/std/char.flx#0011">fun toupper : char -> char requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Constructor from any integer type.
 Convert to upper case.
</p></div>
<pre>0014:    <a href="/$src/lib/std/char.flx#0014">fun tolower : char -> char requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert to lower case.
</p></div>
<pre>0017:    <a href="/$src/lib/std/char.flx#0017">fun isupper : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if upper case [A-Z].
</p></div>
<pre>0020:    <a href="/$src/lib/std/char.flx#0020">fun islower : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if lower case [a-z].
</p></div>
<pre>0023:    <a href="/$src/lib/std/char.flx#0023">fun isalnum : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if alphanumeric [A-Za-z0-9].
</p></div>
<pre>0026:    <a href="/$src/lib/std/char.flx#0026">fun isalpha : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if alphabetic [A-Za-z]
</p></div>
<pre>0029:    <a href="/$src/lib/std/char.flx#0029">fun isdigit : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if digit [0-9].
</p></div>
<pre>0032:    <a href="/$src/lib/std/char.flx#0032">fun isxdigit : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if hex digit [0-9A-Fa-f].
</p></div>
<pre>0035:    <a href="/$src/lib/std/char.flx#0035">fun iscntrl : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if control character 0x0 - 0x20, 0x7F
</p></div>
<pre>0038:    <a href="/$src/lib/std/char.flx#0038">fun isspace : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if space x020.
</p></div>
<pre>0041:    <a href="/$src/lib/std/char.flx#0041">fun isblank : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if space 0x20 or tab 0x09
</p></div>
<pre>0044:    <a href="/$src/lib/std/char.flx#0044">fun isprint : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if printable 0x20-0x7e
</p></div>
<pre>0047:    <a href="/$src/lib/std/char.flx#0047">fun ispunct : char -> bool requires C89_headers::ctype_h</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if punctuation character.
</p></div>

<pre>0054:  <a href="/$src/lib/std/char.flx#0054">open class Wchar</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Wide character support.
 DO NOT USE except for C bindings.
 C wchar_t is not portable.
</p></div>
<pre>0057:    <a href="/$src/lib/std/char.flx#0057">fun ord: wchar -> long</a></pre>
<pre>0060:    <a href="/$src/lib/std/char.flx#0060">fun toupper : wchar -> wchar</a></pre>
<pre>0061:    <a href="/$src/lib/std/char.flx#0061">fun tolower : wchar -> wchar</a></pre>
<pre>0063:    <a href="/$src/lib/std/char.flx#0063">fun isupper : wchar -> bool</a></pre>
<pre>0064:    <a href="/$src/lib/std/char.flx#0064">fun islower : wchar -> bool</a></pre>
<pre>0065:    <a href="/$src/lib/std/char.flx#0065">fun isalnum : wchar -> bool</a></pre>
<pre>0066:    <a href="/$src/lib/std/char.flx#0066">fun isalpha : wchar -> bool</a></pre>
<pre>0067:    <a href="/$src/lib/std/char.flx#0067">fun isdigit : wchar -> bool</a></pre>
<pre>0068:    <a href="/$src/lib/std/char.flx#0068">fun isxdigit : wchar -> bool</a></pre>
<pre>0069:    <a href="/$src/lib/std/char.flx#0069">fun iscntrl : wchar -> bool</a></pre>
<pre>0070:    <a href="/$src/lib/std/char.flx#0070">fun isspace : wchar -> bool</a></pre>
<pre>0071:    <a href="/$src/lib/std/char.flx#0071">fun isblank : wchar -> bool</a></pre>
<pre>0072:    <a href="/$src/lib/std/char.flx#0072">fun isprint : wchar -> bool</a></pre>
<pre>0073:    <a href="/$src/lib/std/char.flx#0073">fun ispunct : wchar -> bool</a></pre>

<pre>0078:  <a href="/$src/lib/std/char.flx#0078">open class Uchar</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Unicode character support.
 Obsoleted by C++11.
</p></div>
<pre>0080:    <a href="/$src/lib/std/char.flx#0080">fun ord: uchar -> uint32</a></pre>
<pre>0085:    <a href="/$src/lib/std/char.flx#0085">fun str: T -> string</a></pre>
<pre>0089:    <a href="/$src/lib/std/char.flx#0089">fun repr[with Str[T]] (c:T) : string</a></pre>
<hr/><a href="/$src/lib/std/cmdopt.flx">cmdopt.flx</a>

<pre>0001:  <a href="/$src/lib/std/cmdopt.flx#0001">open class CmdOpt</a></pre>
<pre>0005:    <a href="/$src/lib/std/cmdopt.flx#0005">noinline fun cvt-key-arg (keys: list[string * string]) (x:list[string])</a></pre>
<pre>0027:    <a href="/$src/lib/std/cmdopt.flx#0027">noinline gen parse-key-multi-value (keys:list[string]) (d:strdict[list[string]]) (x:list[string])</a></pre>
<pre>0052:    <a href="/$src/lib/std/cmdopt.flx#0052">noinline gen parse-key-single-value (keys:list[string]) (d:strdict[string]) (x:list[string])</a></pre>
<pre>0080:    <a href="/$src/lib/std/cmdopt.flx#0080">noinline gen parse-key (keys:list[string]) (d:strdict[int]) (x:list[string])</a></pre>
<pre>0106:    <a href="/$src/lib/std/cmdopt.flx#0106">noinline gen parse-switches (switchmap: list[char * string] ) (d:strdict[int]) (x:list[string])</a></pre>
<pre>0129:    <a href="/$src/lib/std/cmdopt.flx#0129">typedef cmdspec_t</a></pre>
<pre>0137:    <a href="/$src/lib/std/cmdopt.flx#0137">typedef cmdopt-parse-result_t</a></pre>
<pre>0144:    <a href="/$src/lib/std/cmdopt.flx#0144">ctor cmdopt-parse-result_t ()</a></pre>
<pre>0152:    <a href="/$src/lib/std/cmdopt.flx#0152">noinline gen parse-cmdline (spec:cmdspec_t) (x:list[string]) : cmdopt-parse-result_t</a></pre>
<hr/><a href="/$src/lib/std/codec/__init__.flx">codec/__init__.flx</a>
<hr/><a href="/$src/lib/std/codec/base64.flx">codec/base64.flx</a>

<pre>0004:  <a href="/$src/lib/std/codec/base64.flx#0004">class Base64</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Base64 encode/decode functions.
 http://en.wikipedia.org/wiki/Base64
</p></div>
<pre>0013:    <a href="/$src/lib/std/codec/base64.flx#0013">gen make_string: size*char->string</a></pre>
<pre>0029:    <a href="/$src/lib/std/codec/base64.flx#0029">fun encode (inp:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Returns base 64 encoding of supplied string inp.
</p></div>
<pre>0031:    <a href="/$src/lib/std/codec/base64.flx#0031">fun encode (inp:string, iOff:int, iLen:int) : string</a></pre>
<pre>0066:    <a href="/$src/lib/std/codec/base64.flx#0066">fun wrap (b64_str:string,ll:uint) : string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wraps encoded string after ll chars, no newline on last line.
</p></div>
<pre>0083:    <a href="/$src/lib/std/codec/base64.flx#0083">fun decode(enc_str:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Decodes supplied base 64 encoded string.
</p></div>
<hr/><a href="/$src/lib/std/codec/csv.flx">codec/csv.flx</a>

<pre>0003:  <a href="/$src/lib/std/codec/csv.flx#0003">class Csv</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Comma Separated Values (CSV) reader
 Splits a string like 1,2,"hell" up into three strings.
</p></div>
<pre>0008:    <a href="/$src/lib/std/codec/csv.flx#0008">proc get_csv_value(s:string, i:&int,res:&string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch a value string res from position i of string s.
 Update i past the comma ready to fetch another value.
</p></div>
<pre>0010:    <a href="/$src/lib/std/codec/csv.flx#0010">proc add(j:int)</a></pre>
<pre>0013:    <a href="/$src/lib/std/codec/csv.flx#0013">fun eq(a:state_t, b:state_t)</a></pre>
<pre>0044:    <a href="/$src/lib/std/codec/csv.flx#0044">fun get_csv_values(s:string): list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch all the values in a CSV string
 and return them as list.
</p></div>
<hr/><a href="/$src/lib/std/codec/uri_codec.flx">codec/uri_codec.flx</a>

<pre>0015:  <a href="/$src/lib/std/codec/uri_codec.flx#0015">class URICodec</a></pre>
<pre>0058:    <a href="/$src/lib/std/codec/uri_codec.flx#0058">gen uri_encode: string -> string</a></pre>
<pre>0066:    <a href="/$src/lib/std/codec/uri_codec.flx#0066">fun uri_decode(encoded:string):string</a></pre>
<hr/><a href="/$src/lib/std/condition_variable.flx">condition_variable.flx</a>

<pre>0002:  <a href="/$src/lib/std/condition_variable.flx#0002">open class Condition_Variable</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Condition Variable for pthread synchronisation.
</p></div>
<pre>0007:    <a href="/$src/lib/std/condition_variable.flx#0007">type condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a condition variable.
</p></div>
<pre>0010:    <a href="/$src/lib/std/condition_variable.flx#0010">ctor condition_variable: 1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Condition variable constructor taking unit argument.
</p></div>
<pre>0013:    <a href="/$src/lib/std/condition_variable.flx#0013">proc destroy: condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to release a condition variable.
</p></div>
<pre>0017:    <a href="/$src/lib/std/condition_variable.flx#0017">proc wait: condition_variable * mutex</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to wait until a signal is raised on
 the condition variable by another thread.
</p></div>
<pre>0022:    <a href="/$src/lib/std/condition_variable.flx#0022">proc signal: condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to raise a signal on a condition
 variable which will allow at most one thread
 waiting on it to proceed.
</p></div>
<pre>0026:    <a href="/$src/lib/std/condition_variable.flx#0026">proc broadcast: condition_variable</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to broadcast a signal releasing all
 threads waiting on a conditiona variable.
</p></div>
<pre>0030:    <a href="/$src/lib/std/condition_variable.flx#0030">gen timedwait: condition_variable * mutex * double -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Timed wait for signal on condition variable.
 Time in seconds. Resolution nanoseconds.
</p></div>
<hr/><a href="/$src/lib/std/control/control.flx">control/control.flx</a>

<pre>0001:  <a href="/$src/lib/std/control/control.flx#0001">open class Control</a></pre>
<pre>0005:    <a href="/$src/lib/std/control/control.flx#0005">proc forever (bdy:unit->void)</a></pre>
<pre>0014:    <a href="/$src/lib/std/control/control.flx#0014">proc pass()</a></pre>
<pre>0017:    <a href="/$src/lib/std/control/control.flx#0017">proc for_each</a></pre>
<pre>0033:    <a href="/$src/lib/std/control/control.flx#0033">fun fail:string -> any</a></pre>
<pre>0036:    <a href="/$src/lib/std/control/control.flx#0036">fun fail_fun[t]:1->t</a></pre>
<pre>0039:    <a href="/$src/lib/std/control/control.flx#0039">fun fail_fun[t]:string->t</a></pre>
<pre>0045:    <a href="/$src/lib/std/control/control.flx#0045">fun current_continuation: unit -> cont</a></pre>
<pre>0071:    <a href="/$src/lib/std/control/control.flx#0071">proc throw_continuation(x: unit->void)</a></pre>
<pre>0074:    <a href="/$src/lib/std/control/control.flx#0074">proc throw[T] : T</a></pre>
<pre>0085:    <a href="/$src/lib/std/control/control.flx#0085">union svc_req_t</a></pre>
<pre>0102:    <a href="/$src/lib/std/control/control.flx#0102">noinline proc svc(x:svc_req_t)</a></pre>
<hr/><a href="/$src/lib/std/control/fibres.flx">control/fibres.flx</a>

<pre>0002:  <a href="/$src/lib/std/control/fibres.flx#0002">open class Fibres</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Low level management of Felix fthreads (fibres).
</p></div>
<pre>0007:    <a href="/$src/lib/std/control/fibres.flx#0007">gen start[t] (p:t->0) (x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to start a continution with argument type t.
</p></div>
<pre>0012:    <a href="/$src/lib/std/control/fibres.flx#0012">gen start (p:1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to start a contiuation without an argument.
</p></div>
<pre>0015:    <a href="/$src/lib/std/control/fibres.flx#0015">gen mk_thread: cont->fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Function to make a fibre out of a continuation.
</p></div>
<pre>0019:    <a href="/$src/lib/std/control/fibres.flx#0019">proc spawn_fthread(p:1->0)</a></pre>
<pre>0028:    <a href="/$src/lib/std/control/fibres.flx#0028">type fibre_scheduler</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a fibre scheduler.
</p></div>
<pre>0032:    <a href="/$src/lib/std/control/fibres.flx#0032">ctor fibre_scheduler: 1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a fibre scheduler.
  NOTE: NOT GARBAGE COLLECTED!
</p></div>
<pre>0035:    <a href="/$src/lib/std/control/fibres.flx#0035">proc delete_fibre_scheduler : fibre_scheduler</a></pre>
<pre>0047:    <a href="/$src/lib/std/control/fibres.flx#0047">proc spawn_fibre: fibre_scheduler * fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Spawn a fibre on a given scheduler with a given continuation.
</p></div>
<pre>0070:    <a href="/$src/lib/std/control/fibres.flx#0070">fun get_state : fibre_scheduler -> fibre_scheduler_state</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of the stop state of the fibre scheduler.
 terminated: the scheduler is terminated.
 blocked: the scheduler is out of threads to run.
 delegated: the scheduler has been issued a service
  request by a thread which it cannot satisfy.
  The scheduler is put in delegated state and awaits
  for another service to satisfy the request and put
  it back in operation.
</p><p> Note: there is no "operating" state because the
 stop state can only be queried by the schedulers caller
 when the scheduler returns control to it.
</p></div>
<pre>0074:    <a href="/$src/lib/std/control/fibres.flx#0074">proc spawn_fthread (fs:fibre_scheduler) (p:1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Core user procedure for launching a fibre.
</p></div>
<pre>0077:    <a href="/$src/lib/std/control/fibres.flx#0077">gen step: cont -> cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute a single step of a fibre.
</p></div>
<pre>0080:    <a href="/$src/lib/std/control/fibres.flx#0080">proc kill: fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schedule death of a fibre.
</p></div>
<pre>0086:    <a href="/$src/lib/std/control/fibres.flx#0086">proc run: cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Run a continuation until it terminates.
 Do not use this proc if the underlying
 procedure attempts to read messages.
 This is a low level primitive, bypassing fthreads.
</p></div>
<pre>0125:    <a href="/$src/lib/std/control/fibres.flx#0125">proc send[t] (p:&cont) (x:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Send a message to a continuation.
 There is no type checking on the message type.
 The procedure is executed until
 the next wait_state, then the message is stored.
 Low level primitive, bypassing fthreads.
</p></div>
<hr/><a href="/$src/lib/std/control/forkjoin.flx">control/forkjoin.flx</a>

<pre>0002:  <a href="/$src/lib/std/control/forkjoin.flx#0002">open class ForkJoin</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Implement fork/join protocol.
</p></div>
<pre>0006:    <a href="/$src/lib/std/control/forkjoin.flx#0006">proc concurrently_by_iterator (var it:1 -> opt[1->0])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Launch a set of pthreads and wait
 until all of them are finished.
</p></div>
<pre>0028:    <a href="/$src/lib/std/control/forkjoin.flx#0028">proc concurrently[T with Streamable[T,1->0]] (d:T)</a></pre>
<hr/><a href="/$src/lib/std/control/mutex.flx">control/mutex.flx</a>

<pre>0001:  <a href="/$src/lib/std/control/mutex.flx#0001">open class Mutex</a></pre>
<pre>0006:    <a href="/$src/lib/std/control/mutex.flx#0006">type mutex</a></pre>
<pre>0007:    <a href="/$src/lib/std/control/mutex.flx#0007">ctor mutex: unit</a></pre>
<pre>0008:    <a href="/$src/lib/std/control/mutex.flx#0008">proc lock: mutex</a></pre>
<pre>0009:    <a href="/$src/lib/std/control/mutex.flx#0009">proc unlock: mutex</a></pre>
<pre>0010:    <a href="/$src/lib/std/control/mutex.flx#0010">proc destroy: mutex</a></pre>
<hr/><a href="/$src/lib/std/control/mux.flx">control/mux.flx</a>

<pre>0003:  <a href="/$src/lib/std/control/mux.flx#0003">open class Multiplexor</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Schannel multiplexor.
 Read multiple input schannels, write to an output schannel.
</p></div>
<pre>0006:    <a href="/$src/lib/std/control/mux.flx#0006">noinline proc copy[T] (i:ischannel[T],o:oschannel[T]) ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schannel copy.
</p></div>
<pre>0017:    <a href="/$src/lib/std/control/mux.flx#0017">proc mux[T] (inp:1->opt[ischannel[T]], out:oschannel[T]) ()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schannel multiplexor based on iterator argument.
 Accepts stream of input schannels.
 Writes to output schannel.
</p></div>
<pre>0028:    <a href="/$src/lib/std/control/mux.flx#0028">fun mux[C,T with Streamable[C,ischannel[T]]] (a:C, out:oschannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Schannel multiplexor based on streamable data structure.
 Creates stream of input schannels.
 Writes to output schannel.
</p></div>
<hr/><a href="/$src/lib/std/control/pchannels.flx">control/pchannels.flx</a>

<pre>0009:  <a href="/$src/lib/std/control/pchannels.flx#0009">open class Pchannel</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Pchannels are unbuffered synchronisation points
 for pre-emptive threads.
</p><p> Similarly to schannels, paired reader-writer pthreads
 cannot proceed until both parties agree data exchange is complete.
 Unlike schannels, both reader and writer can subsequently
 continue concurrently after the exchange.
</p></div>
<pre>0014:    <a href="/$src/lib/std/control/pchannels.flx#0014">type pchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pre-emptive thread channels (monitor).
</p></div>
<pre>0016:    <a href="/$src/lib/std/control/pchannels.flx#0016">type ipchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pre-emptive thread input channel.
</p></div>
<pre>0018:    <a href="/$src/lib/std/control/pchannels.flx#0018">type opchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pre-emptive thread output channel.
</p></div>
<pre>0021:    <a href="/$src/lib/std/control/pchannels.flx#0021">fun mk_pchannel[t]: 1->pchannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make bidirectional pchannel.
</p></div>
<pre>0024:    <a href="/$src/lib/std/control/pchannels.flx#0024">ctor[t] opchannel[t](x:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to output pchannel.
</p></div>
<pre>0026:    <a href="/$src/lib/std/control/pchannels.flx#0026">ctor[t] ipchannel[t](x:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to input pchannel.
</p></div>
<pre>0029:    <a href="/$src/lib/std/control/pchannels.flx#0029">fun mk_iopchannel_pair[t](var ch:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make an input and an output pchannel out of a bidirectional channel.
</p></div>
<pre>0034:    <a href="/$src/lib/std/control/pchannels.flx#0034">fun mk_iopchannel_pair[t]()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a connected input and output pchannel pair.
</p></div>
<pre>0047:    <a href="/$src/lib/std/control/pchannels.flx#0047">proc _read[t]: pchannel[t] * &&t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read from a pchannel.
</p></div>
<pre>0059:    <a href="/$src/lib/std/control/pchannels.flx#0059">noinline gen read[t] (chan:pchannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write to a pchannel.
</p></div>
<pre>0064:    <a href="/$src/lib/std/control/pchannels.flx#0064">gen read[t] (chan:ipchannel[t])</a></pre>
<pre>0066:    <a href="/$src/lib/std/control/pchannels.flx#0066">proc _write[t]: pchannel[t] * &t</a></pre>
<pre>0077:    <a href="/$src/lib/std/control/pchannels.flx#0077">noinline proc write[t](chan:pchannel[t], v:t)</a></pre>
<pre>0081:    <a href="/$src/lib/std/control/pchannels.flx#0081">proc write[t] (chan:opchannel[t], v:t)</a></pre>
<hr/><a href="/$src/lib/std/control/ppipe.flx">control/ppipe.flx</a>

<pre>0003:  <a href="/$src/lib/std/control/ppipe.flx#0003">open class Ppipe</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Asynchronous Synchronous Pipe.
 Used to link pthreads.
</p></div>
<pre>0006:    <a href="/$src/lib/std/control/ppipe.flx#0006">proc psource[T] (var it:1 -> T) (out:opchannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Send an stream down a channel.
</p></div>
<pre>0013:    <a href="/$src/lib/std/control/ppipe.flx#0013">proc pisrc[V,T with Streamable[T,V]] (dat:T) (out:opchannel[opt[V]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> isrc converts a streamable data structure
 such as an array into a source.
</p></div>
<pre>0021:    <a href="/$src/lib/std/control/ppipe.flx#0021">fun pipe[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a sink.
 Return coupled fibre ready to run.
</p></div>
<pre>0036:    <a href="/$src/lib/std/control/ppipe.flx#0036">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a transducer.
 Return source.
</p></div>
<pre>0052:    <a href="/$src/lib/std/control/ppipe.flx#0052">fun xpipe[V,T,U with Streamable[T,V]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> xpipe connects a streamable data structure
 such as an array directly into a transducer.
</p></div>
<pre>0064:    <a href="/$src/lib/std/control/ppipe.flx#0064">fun pipe[T,U,V]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a transducer.
 Return another transducer.
</p></div>
<pre>0080:    <a href="/$src/lib/std/control/ppipe.flx#0080">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a sink.
 Return a sink.
</p></div>
<pre>0097:    <a href="/$src/lib/std/control/ppipe.flx#0097">proc sort[T with Tord[T]] (r: ipchannel[opt[T]], w: opchannel[opt[T]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream sort using intermediate darray.
 Requires stream of option type.
</p></div>
<hr/><a href="/$src/lib/std/control/pthread.flx">control/pthread.flx</a>

<pre>0013:  <a href="/$src/lib/std/control/pthread.flx#0013">open class Pthread</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> This class provides access to the operating system's native
 threading routines. On systems with multiple cpus, this may
 increase performance as the operating system may schedule
 threads on different processors.
</p></div>
<pre>0017:    <a href="/$src/lib/std/control/pthread.flx#0017">type job_queue</a></pre>
<pre>0018:    <a href="/$src/lib/std/control/pthread.flx#0018">type worker_task</a></pre>
<pre>0019:    <a href="/$src/lib/std/control/pthread.flx#0019">gen mk_job_queue: int * int -> job_queue</a></pre>
<pre>0020:    <a href="/$src/lib/std/control/pthread.flx#0020">proc add_worker_task : job_queue  * worker_task</a></pre>
<pre>0023:    <a href="/$src/lib/std/control/pthread.flx#0023">proc spawn_pthread(p:1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> spawn a detached pthread.
</p></div>
<hr/><a href="/$src/lib/std/control/schannels.flx">control/schannels.flx</a>

<pre>0005:  <a href="/$src/lib/std/control/schannels.flx#0005">open class Schannel</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Sychronous Channels.
 Used to exchange control and possibly data
 between Felix f-threads (aka fibres).
</p></div>
<pre>0017:    <a href="/$src/lib/std/control/schannels.flx#0017">gen mk_schannel[t]: 1->schannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a bidirectional synchronous channel.
 The type of an input synchronous channel.
 The type of an output synchronous channel.
 Create a bidirectional synchronous channel.
</p></div>
<pre>0026:    <a href="/$src/lib/std/control/schannels.flx#0026">gen mk_null_schannel[t]: 1->schannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model a NULL pointer as an schannel. 
 Necessary for killing off schannels,
 so as to make them unreachable, so the gc can reap them.
 Note: null_schannels are safe.
</p></div>
<pre>0031:    <a href="/$src/lib/std/control/schannels.flx#0031">gen mk_null_ischannel[t]: 1->ischannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model a NULL pointer as an ischannel. 
 Necessary for killing off schannels,
 so as to make them unreachable, so the gc can reap them.
</p></div>
<pre>0036:    <a href="/$src/lib/std/control/schannels.flx#0036">gen mk_null_oschannel[t]: 1->oschannel[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model a NULL pointer as an oschannel. 
 Necessary for killing off schannels,
 so as to make them unreachable, so the gc can reap them.
</p></div>
<pre>0039:    <a href="/$src/lib/std/control/schannels.flx#0039">fun isNULL[T] :schannel[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if an schannel is NULL.
</p></div>
<pre>0042:    <a href="/$src/lib/std/control/schannels.flx#0042">fun isNULL[T] :ischannel[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if an ischannel is NULL.
</p></div>
<pre>0045:    <a href="/$src/lib/std/control/schannels.flx#0045">fun isNULL[T] :oschannel[T] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if an oschannel is NULL.
</p></div>
<pre>0048:    <a href="/$src/lib/std/control/schannels.flx#0048">ctor[t] oschannel[t](x:schannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to ouput synchronous channel.
</p></div>
<pre>0051:    <a href="/$src/lib/std/control/schannels.flx#0051">ctor[t] ischannel[t](x:schannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Safe cast from bidirectional to input synchronous channel.
</p></div>
<pre>0054:    <a href="/$src/lib/std/control/schannels.flx#0054">gen mk_ioschannel_pair[t](var ch:schannel[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make an input and an output channel out of a bidirectional channel.
</p></div>
<pre>0059:    <a href="/$src/lib/std/control/schannels.flx#0059">gen mk_ioschannel_pair[t]()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a connected input and output channel pair.
</p></div>
<pre>0064:    <a href="/$src/lib/std/control/schannels.flx#0064">inline gen read[T] (chan:schannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read an item from a bidirectional channel.
</p></div>
<pre>0071:    <a href="/$src/lib/std/control/schannels.flx#0071">inline gen read[T] (chan:ischannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read an item from an input channel.
</p></div>
<pre>0074:    <a href="/$src/lib/std/control/schannels.flx#0074">proc write[T] (chan:schannel[T], v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write an item to a bidirectional channel.
</p></div>
<pre>0080:    <a href="/$src/lib/std/control/schannels.flx#0080">proc write[T] (chan:oschannel[T], v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write an item to an output channel.
</p></div>
<hr/><a href="/$src/lib/std/control/spipe.flx">control/spipe.flx</a>

<pre>0003:  <a href="/$src/lib/std/control/spipe.flx#0003">open class Spipe</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Synchronous Pipe.
</p></div>
<pre>0006:    <a href="/$src/lib/std/control/spipe.flx#0006">proc source[T] (var it:1 -> T) (out:oschannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Send an stream down a channel.
</p></div>
<pre>0013:    <a href="/$src/lib/std/control/spipe.flx#0013">proc isrc[V,T with Streamable[T,V]] (var dat:T) (out:oschannel[opt[V]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> isrc converts a streamable data structure
 such as an array into a source.
</p></div>
<pre>0021:    <a href="/$src/lib/std/control/spipe.flx#0021">fun pipe[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a sink.
 Return coupled fibre ready to run.
</p></div>
<pre>0036:    <a href="/$src/lib/std/control/spipe.flx#0036">fun pipe[T0,T1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two sources to two sinks.
 Returns a SINGLE pipeline!
</p></div>
<pre>0055:    <a href="/$src/lib/std/control/spipe.flx#0055">proc run_tee[T] (i:ischannel[T], o1:oschannel[T], o2:oschannel[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Utility for tee connector.
</p></div>
<pre>0066:    <a href="/$src/lib/std/control/spipe.flx#0066">fun pipe[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire together a source component with two sinks.
 Returns a closed pipeline.
</p></div>
<pre>0087:    <a href="/$src/lib/std/control/spipe.flx#0087">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a source component to a transducer.
 Return source.
</p></div>
<pre>0103:    <a href="/$src/lib/std/control/spipe.flx#0103">fun pipe[T0,T1,U0,U1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two source components to two transducers.
 Return two sources.
</p></div>
<pre>0131:    <a href="/$src/lib/std/control/spipe.flx#0131">fun pipe[T,U0,U1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire together a source component with two transducers
 Returns two sources.
</p></div>
<pre>0155:    <a href="/$src/lib/std/control/spipe.flx#0155">fun xpipe[V,T,U with Streamable[T,V]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> xpipe connects a streamable data structure
 such as an array directly into a transducer.
</p></div>
<pre>0167:    <a href="/$src/lib/std/control/spipe.flx#0167">fun pipe[T,U,V]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a transducer.
 Return another transducer.
</p></div>
<pre>0183:    <a href="/$src/lib/std/control/spipe.flx#0183">fun pipe[T0,T1,U0,U1,V0,V1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two transducers into two transducers.
 Return two transducers.
</p></div>
<pre>0203:    <a href="/$src/lib/std/control/spipe.flx#0203">fun pipe[T,U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire a transducer into a sink.
 Return a sink.
</p></div>
<pre>0219:    <a href="/$src/lib/std/control/spipe.flx#0219">fun pipe[T0,T1,U0,U1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Wire two transducers into two sinks.
 Return two sinks.
</p></div>
<pre>0240:    <a href="/$src/lib/std/control/spipe.flx#0240">proc sort[T with Tord[T]] (r: ischannel[opt[T]], w: oschannel[opt[T]])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream sort using intermediate darray.
 Requires stream of option type.
</p></div>
<hr/><a href="/$src/lib/std/control/stream.flx">control/stream.flx</a>

<pre>0005:  <a href="/$src/lib/std/control/stream.flx#0005">open class Streamable[ContainerType, ValueType]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Class of data structures supporting streaming.
 The container type just needs an iterator method.
 The iterator method returns a generator which
 yields the values stored in the container.
</p></div>
<pre>0006:    <a href="/$src/lib/std/control/stream.flx#0006">virtual fun iterator : ContainerType -> 1 -> opt[ValueType]</a></pre>
<hr/><a href="/$src/lib/std/control/ts_bound_queue.flx">control/ts_bound_queue.flx</a>

<pre>0001:  <a href="/$src/lib/std/control/ts_bound_queue.flx#0001">open class TS_Bound_Queue</a></pre>
<pre>0009:    <a href="/$src/lib/std/control/ts_bound_queue.flx#0009">ctor[T] ts_bound_queue_t[T]: !ints</a></pre>
<pre>0013:    <a href="/$src/lib/std/control/ts_bound_queue.flx#0013">proc enqueue[T] (Q:ts_bound_queue_t[T])  (elt:T)</a></pre>
<pre>0016:    <a href="/$src/lib/std/control/ts_bound_queue.flx#0016">gen dequeue[T] (Q:ts_bound_queue_t[T]): T</a></pre>
<pre>0017:    <a href="/$src/lib/std/control/ts_bound_queue.flx#0017">proc wait[T]: ts_bound_queue_t[T]</a></pre>
<pre>0018:    <a href="/$src/lib/std/control/ts_bound_queue.flx#0018">proc resize[T]: ts_bound_queue_t[T] * !ints</a></pre>
<hr/><a href="/$src/lib/std/control/ts_counter.flx">control/ts_counter.flx</a>

<pre>0001:  <a href="/$src/lib/std/control/ts_counter.flx#0001">open class Ts_counter</a></pre>
<pre>0003:    <a href="/$src/lib/std/control/ts_counter.flx#0003">type ts_counter</a></pre>
<pre>0004:    <a href="/$src/lib/std/control/ts_counter.flx#0004">ctor ts_counter : 1</a></pre>
<pre>0005:    <a href="/$src/lib/std/control/ts_counter.flx#0005">proc destroy : ts_counter</a></pre>
<pre>0006:    <a href="/$src/lib/std/control/ts_counter.flx#0006">gen pre_incr: ts_counter -> long</a></pre>
<pre>0007:    <a href="/$src/lib/std/control/ts_counter.flx#0007">gen post_incr: ts_counter-> long</a></pre>
<pre>0008:    <a href="/$src/lib/std/control/ts_counter.flx#0008">gen pre_decr: ts_counter -> long</a></pre>
<pre>0009:    <a href="/$src/lib/std/control/ts_counter.flx#0009">gen post_decr: ts_counter -> long</a></pre>
<pre>0010:    <a href="/$src/lib/std/control/ts_counter.flx#0010">gen decr_pos: ts_counter -> long</a></pre>
<pre>0011:    <a href="/$src/lib/std/control/ts_counter.flx#0011">gen get: ts_counter -> long</a></pre>
<pre>0012:    <a href="/$src/lib/std/control/ts_counter.flx#0012">proc set: ts_counter * long</a></pre>
<pre>0013:    <a href="/$src/lib/std/control/ts_counter.flx#0013">gen swap: ts_counter * long -> long</a></pre>
<pre>0014:    <a href="/$src/lib/std/control/ts_counter.flx#0014">proc wait_zero: ts_counter</a></pre>
<hr/><a href="/$src/lib/std/cptr.flx">cptr.flx</a>

<pre>0005:  <a href="/$src/lib/std/cptr.flx#0005">open class Cptr</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Felix and C pointers.
 Felix pointer ptr[T] = &T.
 C pointer cptr[T] = &T.
 See also carray for incrementable pointers carray[T] = +T.
</p></div>
<pre>0011:    <a href="/$src/lib/std/cptr.flx#0011">typedef ptr[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a Felix pointer.
 Always points to an object.
 Cannot be NULL.
 Cannot be incremented.
</p></div>
<pre>0019:    <a href="/$src/lib/std/cptr.flx#0019">union cptr[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Dereference a Felx pointer.
 Type of a C pointer.
 Either pointes to an object or is NULL.
 Cannot be incremented.
</p></div>
<pre>0022:    <a href="/$src/lib/std/cptr.flx#0022">ctor[T] cptr[T]: &T -> cptr[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Demote a Felix pointer to a C pointer. Safe.
</p></div>
<pre>0027:    <a href="/$src/lib/std/cptr.flx#0027">ctor[T] ptr[T]( px:cptr[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Promote a C pointer to a Felix pointer.
 Conversion is checked.
 Aborts with match failure if NULL.
</p></div>
<pre>0030:    <a href="/$src/lib/std/cptr.flx#0030">fun deref[T] (px:cptr[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Checked dereference of C pointer.
</p></div>
<pre>0033:    <a href="/$src/lib/std/cptr.flx#0033">fun is_nullptr[T] (px:cptr[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Test if a C pointer is NULL.
</p></div>
<pre>0050:    <a href="/$src/lib/std/cptr.flx#0050">typedef fun n"@" (T:TYPE) : TYPE</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Equality of C pointers.
 Total ordering of C pointer.
 NULL is the least element.
 Special notation @T for  type of a C pointer.
</p></div>
<hr/><a href="/$src/lib/std/cstdlib.flx">cstdlib.flx</a>

<pre>0001:  <a href="/$src/lib/std/cstdlib.flx#0001">open class Cstdlib</a></pre>
<pre>0007:    <a href="/$src/lib/std/cstdlib.flx#0007">proc srand: uint</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C89 Standard C library seed random number generator.
</p></div>
<pre>0011:    <a href="/$src/lib/std/cstdlib.flx#0011">fun rand: unit -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C89 Standard C library random number generator.
 Known to be not very good. Try not to use it!
</p></div>
<hr/><a href="/$src/lib/std/ctypedefs.flx">ctypedefs.flx</a>
<pre>0002:    <a href="/$src/lib/std/ctypedefs.flx#0002">pod type byte</a></pre>
<pre>0003:    <a href="/$src/lib/std/ctypedefs.flx#0003">pod type address</a></pre>
<pre>0004:    <a href="/$src/lib/std/ctypedefs.flx#0004">pod type offset</a></pre>
<pre>0005:    <a href="/$src/lib/std/ctypedefs.flx#0005">pod type char</a></pre>
<pre>0006:    <a href="/$src/lib/std/ctypedefs.flx#0006">pod type wchar</a></pre>
<pre>0007:    <a href="/$src/lib/std/ctypedefs.flx#0007">pod type uchar</a></pre>
<pre>0008:    <a href="/$src/lib/std/ctypedefs.flx#0008">pod type tiny</a></pre>
<pre>0009:    <a href="/$src/lib/std/ctypedefs.flx#0009">pod type short</a></pre>
<pre>0010:    <a href="/$src/lib/std/ctypedefs.flx#0010">pod type int</a></pre>
<pre>0011:    <a href="/$src/lib/std/ctypedefs.flx#0011">pod type long</a></pre>
<pre>0012:    <a href="/$src/lib/std/ctypedefs.flx#0012">pod type vlong</a></pre>
<pre>0013:    <a href="/$src/lib/std/ctypedefs.flx#0013">pod type utiny</a></pre>
<pre>0014:    <a href="/$src/lib/std/ctypedefs.flx#0014">pod type ushort</a></pre>
<pre>0015:    <a href="/$src/lib/std/ctypedefs.flx#0015">pod type uint</a></pre>
<pre>0016:    <a href="/$src/lib/std/ctypedefs.flx#0016">pod type ulong</a></pre>
<pre>0017:    <a href="/$src/lib/std/ctypedefs.flx#0017">pod type uvlong</a></pre>
<pre>0018:    <a href="/$src/lib/std/ctypedefs.flx#0018">pod type float</a></pre>
<pre>0019:    <a href="/$src/lib/std/ctypedefs.flx#0019">pod type double</a></pre>
<pre>0020:    <a href="/$src/lib/std/ctypedefs.flx#0020">pod type ldouble</a></pre>
<pre>0021:    <a href="/$src/lib/std/ctypedefs.flx#0021">pod type fcomplex</a></pre>
<pre>0022:    <a href="/$src/lib/std/ctypedefs.flx#0022">pod type dcomplex</a></pre>
<pre>0023:    <a href="/$src/lib/std/ctypedefs.flx#0023">pod type lcomplex</a></pre>
<pre>0030:    <a href="/$src/lib/std/ctypedefs.flx#0030">pod type ptrdiff</a></pre>
<pre>0031:    <a href="/$src/lib/std/ctypedefs.flx#0031">pod type size</a></pre>
<pre>0032:    <a href="/$src/lib/std/ctypedefs.flx#0032">pod type ssize</a></pre>
<pre>0033:    <a href="/$src/lib/std/ctypedefs.flx#0033">pod type intmax</a></pre>
<pre>0034:    <a href="/$src/lib/std/ctypedefs.flx#0034">pod type uintmax</a></pre>
<pre>0035:    <a href="/$src/lib/std/ctypedefs.flx#0035">pod type intptr</a></pre>
<pre>0036:    <a href="/$src/lib/std/ctypedefs.flx#0036">pod type uintptr</a></pre>
<pre>0037:    <a href="/$src/lib/std/ctypedefs.flx#0037">pod type int8</a></pre>
<pre>0038:    <a href="/$src/lib/std/ctypedefs.flx#0038">pod type int16</a></pre>
<pre>0039:    <a href="/$src/lib/std/ctypedefs.flx#0039">pod type int32</a></pre>
<pre>0040:    <a href="/$src/lib/std/ctypedefs.flx#0040">pod type int64</a></pre>
<pre>0041:    <a href="/$src/lib/std/ctypedefs.flx#0041">pod type uint8</a></pre>
<pre>0042:    <a href="/$src/lib/std/ctypedefs.flx#0042">pod type uint16</a></pre>
<pre>0043:    <a href="/$src/lib/std/ctypedefs.flx#0043">pod type uint32</a></pre>
<pre>0044:    <a href="/$src/lib/std/ctypedefs.flx#0044">pod type uint64</a></pre>
<hr/><a href="/$src/lib/std/ctypesets.flx">ctypesets.flx</a>
<pre>0002:    <a href="/$src/lib/std/ctypesets.flx#0002">typedef addressing</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Types associated with raw address calculations.
</p></div>
<pre>0008:    <a href="/$src/lib/std/ctypesets.flx#0008">typedef chars</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Character types.
</p></div>
<pre>0012:    <a href="/$src/lib/std/ctypesets.flx#0012">typedef fast_sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> "natural" sized signed integer types.
 These correspond to C/C++ core types.
</p></div>
<pre>0017:    <a href="/$src/lib/std/ctypesets.flx#0017">typedef exact_sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Exact sized signed integer types.
 In C these are typedefs.
 In Felix they're distinct types.
</p></div>
<pre>0021:    <a href="/$src/lib/std/ctypesets.flx#0021">typedef fast_uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> "natural" sized unsigned integer types.
 These correspond to C/C++ core types.
</p></div>
<pre>0026:    <a href="/$src/lib/std/ctypesets.flx#0026">typedef exact_uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Exact sized unsigned integer types.
 In C these are typedefs.
 In Felix they're distinct types.
</p></div>
<pre>0030:    <a href="/$src/lib/std/ctypesets.flx#0030">typedef weird_sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Weirdo signed integers types corresponding to
 typedefs in C.
</p></div>
<pre>0034:    <a href="/$src/lib/std/ctypesets.flx#0034">typedef weird_uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Weirdo unsigned integers types corresponding to
 typedefs in C.
</p></div>
<pre>0037:    <a href="/$src/lib/std/ctypesets.flx#0037">typedef sints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the signed integers.
</p></div>
<pre>0040:    <a href="/$src/lib/std/ctypesets.flx#0040">typedef uints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the usigned integers.
</p></div>
<pre>0043:    <a href="/$src/lib/std/ctypesets.flx#0043">typedef fast_ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the fast integers.
</p></div>
<pre>0046:    <a href="/$src/lib/std/ctypesets.flx#0046">typedef exact_ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the exact integers.
</p></div>
<pre>0049:    <a href="/$src/lib/std/ctypesets.flx#0049">typedef ints</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the integers.
</p></div>
<pre>0052:    <a href="/$src/lib/std/ctypesets.flx#0052">typedef floats</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core floating point types.
</p></div>
<pre>0055:    <a href="/$src/lib/std/ctypesets.flx#0055">typedef reals</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core approximations to real types.
</p></div>
<pre>0058:    <a href="/$src/lib/std/ctypesets.flx#0058">typedef complexes</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core approximations to complex types.
</p></div>
<pre>0061:    <a href="/$src/lib/std/ctypesets.flx#0061">typedef numbers</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the core approximations to numbers.
</p></div>
<pre>0064:    <a href="/$src/lib/std/ctypesets.flx#0064">typedef basic_types</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> All the basic scalar types.
</p></div>
<hr/><a href="/$src/lib/std/cxx_headers.flx">cxx_headers.flx</a>

<pre>0001:  <a href="/$src/lib/std/cxx_headers.flx#0001">class Cxx_headers</a></pre>

<pre>0059:  <a href="/$src/lib/std/cxx_headers.flx#0059">class Cxx11_headers  // http://en.cppreference.com/w/cpp/header</a></pre>
<hr/><a href="/$src/lib/std/datatype/array.flx">datatype/array.flx</a>

<pre>0002:  <a href="/$src/lib/std/datatype/array.flx#0002">open class Farray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Compile time fix length array.
</p></div>
<pre>0004:    <a href="/$src/lib/std/datatype/array.flx#0004">typedef array[t,n]</a></pre>
<pre>0009:    <a href="/$src/lib/std/datatype/array.flx#0009">fun copy[T,N] (var x:array[T,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array copy.
</p></div>
<pre>0012:    <a href="/$src/lib/std/datatype/array.flx#0012">ctor[T] array[T,1] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array of one element.
</p></div>
<pre>0016:    <a href="/$src/lib/std/datatype/array.flx#0016">fun len (x:array[t, n]): size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array as value.
</p></div>
<pre>0018:    <a href="/$src/lib/std/datatype/array.flx#0018">fun unsafe_get (var a: array[t, n], j: size): t</a></pre>
<pre>0023:    <a href="/$src/lib/std/datatype/array.flx#0023">fun len (x:&array[t, n]): size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pointer to array as value.
</p></div>
<pre>0024:    <a href="/$src/lib/std/datatype/array.flx#0024">fun unsafe_get: &array[t, n] * size -> &t</a></pre>
<pre>0027:    <a href="/$src/lib/std/datatype/array.flx#0027">proc unsafe_set[t,n]: &array[t,n] * size * t</a></pre>
<pre>0028:    <a href="/$src/lib/std/datatype/array.flx#0028">proc set[t,n, I in ints] (a: &array[t,n], i:I,v:t)</a></pre>
<pre>0033:    <a href="/$src/lib/std/datatype/array.flx#0033">fun stl_begin[t,n]: &array[t,n] -> +t</a></pre>
<pre>0034:    <a href="/$src/lib/std/datatype/array.flx#0034">fun stl_end[t,n] ( x:&array[t,n] ) : +t</a></pre>
<pre>0037:    <a href="/$src/lib/std/datatype/array.flx#0037">fun map[V,N,U] (_f:V->U) (x:array[V,N]):array[U,N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Array map.
</p></div>
<pre>0055:    <a href="/$src/lib/std/datatype/array.flx#0055">fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, N + M]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join two arrays (functional).
</p></div>
<pre>0074:    <a href="/$src/lib/std/datatype/array.flx#0074">fun join[T, N] (x:array[T, N]) (y:T):array[T, N + 1]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Append value to end of an array (functional).
</p></div>
<pre>0087:    <a href="/$src/lib/std/datatype/array.flx#0087">fun join[T, M] (x:T) (y:array[T, M]):array[T, 1 + M]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Prepand value to start of an array (functional).
</p></div>
<pre>0108:    <a href="/$src/lib/std/datatype/array.flx#0108">fun transpose[T,N,M] (y:array[array[T,M],N]) : array[array[T,N],M]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join two arrays (functional).
 Transpose and array.
 Subsumes zip.
 Example: transpose ( (1,2,3), (4,5,6) ) = ( (1,4), (2,4), (3,6) ).
</p></div>
<pre>0124:    <a href="/$src/lib/std/datatype/array.flx#0124">fun rev[T, N] (x:array[T, N]): array[T, N]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Reverse elements of an array.
</p></div>
<pre>0135:    <a href="/$src/lib/std/datatype/array.flx#0135">fun sort[T,N] (cmp: T * T -> bool) (var x:array[T,N]) : array[T,N]</a></pre>
<pre>0140:    <a href="/$src/lib/std/datatype/array.flx#0140">fun sort[T,N] (var x:array[T,N]) : array[T,N]</a></pre>
<pre>0148:    <a href="/$src/lib/std/datatype/array.flx#0148">fun str (xs:array[T,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Display: convert to string like (1,2,3).
</p></div>
<hr/><a href="/$src/lib/std/datatype/avl.flx">datatype/avl.flx</a>

<pre>0001:  <a href="/$src/lib/std/datatype/avl.flx#0001">class Avl</a></pre>
<pre>0003:    <a href="/$src/lib/std/datatype/avl.flx#0003">union avl[T]</a></pre>
<pre>0010:    <a href="/$src/lib/std/datatype/avl.flx#0010">fun _ctor_avl[T] ()</a></pre>
<pre>0012:    <a href="/$src/lib/std/datatype/avl.flx#0012">fun _ctor_avl[T] (x : T, left : avl[T], right : avl[T])</a></pre>
<pre>0078:    <a href="/$src/lib/std/datatype/avl.flx#0078">fun insert[T] (tree : avl[T], y : T, cmp : T*T->int)</a></pre>
<pre>0093:    <a href="/$src/lib/std/datatype/avl.flx#0093">fun insert[T] (y : T, cmp : T*T->int)</a></pre>
<pre>0099:    <a href="/$src/lib/std/datatype/avl.flx#0099">fun find[T] (tree : avl[T], y : T, cmp : T*T->int) : opt[T]</a></pre>
<pre>0115:    <a href="/$src/lib/std/datatype/avl.flx#0115">fun last[T] : avl[T]->T</a></pre>
<pre>0120:    <a href="/$src/lib/std/datatype/avl.flx#0120">fun all_but_last[T] : avl[T]->avl[T]</a></pre>
<pre>0127:    <a href="/$src/lib/std/datatype/avl.flx#0127">fun first[T] : avl[T]->T</a></pre>
<pre>0132:    <a href="/$src/lib/std/datatype/avl.flx#0132">fun all_but_first[T] : avl[T]->avl[T]</a></pre>
<pre>0139:    <a href="/$src/lib/std/datatype/avl.flx#0139">fun join[T] (A : avl[T], B : avl[T])</a></pre>
<pre>0146:    <a href="/$src/lib/std/datatype/avl.flx#0146">fun remove[T] (tree : avl[T], y : T, cmp : T*T->int)</a></pre>
<pre>0162:    <a href="/$src/lib/std/datatype/avl.flx#0162">fun fold_left[T, U] (f:U->T->U) (accumulated:U) (tree:avl[T]):U</a></pre>
<pre>0170:    <a href="/$src/lib/std/datatype/avl.flx#0170">fun fold_right[T, U] (f:T->U->U) (tree:avl[T]) (accumulated:U)</a></pre>
<pre>0180:    <a href="/$src/lib/std/datatype/avl.flx#0180">proc iter[T] (f:T->void, tree:avl[T])</a></pre>
<pre>0192:    <a href="/$src/lib/std/datatype/avl.flx#0192">proc iter[T] (f:int*T->void, tree:avl[T])</a></pre>
<pre>0194:    <a href="/$src/lib/std/datatype/avl.flx#0194">proc aux (depth:int, f:int*T->void, tree:avl[T])</a></pre>
<hr/><a href="/$src/lib/std/datatype/bsarray.flx">datatype/bsarray.flx</a>

<pre>0005:  <a href="/$src/lib/std/datatype/bsarray.flx#0005">open class Bsarray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Bounded sparse array.
 Basically a sarray with a given bound.
 The bound is ignored for get and set methods.
 The bound is used for membership tests and iteration.
</p></div>
<pre>0008:    <a href="/$src/lib/std/datatype/bsarray.flx#0008">type bsarray[T]</a></pre>
<pre>0017:    <a href="/$src/lib/std/datatype/bsarray.flx#0017">fun len(b:bsarray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contruct with default value and bound.
 Contrue as array value.
</p></div>
<pre>0018:    <a href="/$src/lib/std/datatype/bsarray.flx#0018">fun unsafe_get(b:bsarray[T], i:size)</a></pre>
<pre>0023:    <a href="/$src/lib/std/datatype/bsarray.flx#0023">proc unsafe_set(b:bsarray[T], i:size, v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contrue as array object.
</p></div>
<pre>0041:    <a href="/$src/lib/std/datatype/bsarray.flx#0041">fun str (xs:bsarray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Contrue as set: membership test.
 Convert to string.
</p></div>
<hr/><a href="/$src/lib/std/datatype/judy.flx">datatype/judy.flx</a>

<pre>0008:  <a href="/$src/lib/std/datatype/judy.flx#0008">class Judy</a></pre>
<pre>0014:    <a href="/$src/lib/std/datatype/judy.flx#0014">type word</a></pre>
<pre>0015:    <a href="/$src/lib/std/datatype/judy.flx#0015">ctor word: !ints</a></pre>
<pre>0016:    <a href="/$src/lib/std/datatype/judy.flx#0016">ctor word: address</a></pre>
<pre>0017:    <a href="/$src/lib/std/datatype/judy.flx#0017">ctor int: word</a></pre>
<pre>0018:    <a href="/$src/lib/std/datatype/judy.flx#0018">ctor uint: word</a></pre>
<pre>0019:    <a href="/$src/lib/std/datatype/judy.flx#0019">ctor ulong: word</a></pre>
<pre>0020:    <a href="/$src/lib/std/datatype/judy.flx#0020">ctor size: word</a></pre>
<pre>0021:    <a href="/$src/lib/std/datatype/judy.flx#0021">ctor address: word</a></pre>
<pre>0022:    <a href="/$src/lib/std/datatype/judy.flx#0022">fun isNULL: word -> bool</a></pre>
<pre>0023:    <a href="/$src/lib/std/datatype/judy.flx#0023">fun isNULL: &word -> bool</a></pre>
<pre>0025:    <a href="/$src/lib/std/datatype/judy.flx#0025">type JError_t</a></pre>
<pre>0030:    <a href="/$src/lib/std/datatype/judy.flx#0030">typedef void *voidp</a></pre>
<pre>0060:    <a href="/$src/lib/std/datatype/judy.flx#0060">gen _ctor_J1Array: 1 -> J1Array</a></pre>
<pre>0066:    <a href="/$src/lib/std/datatype/judy.flx#0066">proc free: J1Array</a></pre>
<pre>0068:    <a href="/$src/lib/std/datatype/judy.flx#0068">proc Judy1Set: J1Array * word * &JError_t * &int</a></pre>
<pre>0071:    <a href="/$src/lib/std/datatype/judy.flx#0071">proc Judy1Unset: J1Array * word * &JError_t * &int</a></pre>
<pre>0074:    <a href="/$src/lib/std/datatype/judy.flx#0074">proc Judy1Test: J1Array * word * &JError_t * &int</a></pre>
<pre>0085:    <a href="/$src/lib/std/datatype/judy.flx#0085">proc Judy1Count: J1Array * word * word* &JError_t * &word</a></pre>
<pre>0088:    <a href="/$src/lib/std/datatype/judy.flx#0088">proc Judy1ByCount: J1Array * word * &word * &JError_t * &word</a></pre>
<pre>0091:    <a href="/$src/lib/std/datatype/judy.flx#0091">proc Judy1FreeArray: J1Array * &JError_t * &word</a></pre>
<pre>0094:    <a href="/$src/lib/std/datatype/judy.flx#0094">proc Judy1MemUsed: J1Array * &word</a></pre>
<pre>0096:    <a href="/$src/lib/std/datatype/judy.flx#0096">proc Judy1First: J1Array * &word * &JError_t * &int</a></pre>
<pre>0099:    <a href="/$src/lib/std/datatype/judy.flx#0099">proc Judy1Next: J1Array * &word * &JError_t * &int</a></pre>
<pre>0102:    <a href="/$src/lib/std/datatype/judy.flx#0102">proc Judy1Last: J1Array * &word * &JError_t * &int</a></pre>
<pre>0105:    <a href="/$src/lib/std/datatype/judy.flx#0105">proc Judy1Prev: J1Array * &word * &JError_t * &int</a></pre>
<pre>0108:    <a href="/$src/lib/std/datatype/judy.flx#0108">proc Judy1FirstEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0111:    <a href="/$src/lib/std/datatype/judy.flx#0111">proc Judy1NextEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0114:    <a href="/$src/lib/std/datatype/judy.flx#0114">proc Judy1LastEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0117:    <a href="/$src/lib/std/datatype/judy.flx#0117">proc Judy1PrevEmpty: J1Array * &word * &JError_t * &int</a></pre>
<pre>0139:    <a href="/$src/lib/std/datatype/judy.flx#0139">gen _ctor_JLArray: 1 -> JLArray</a></pre>
<pre>0145:    <a href="/$src/lib/std/datatype/judy.flx#0145">proc free: JLArray</a></pre>
<pre>0148:    <a href="/$src/lib/std/datatype/judy.flx#0148">proc JudyLIns: JLArray * word * &JError_t * &&word</a></pre>
<pre>0151:    <a href="/$src/lib/std/datatype/judy.flx#0151">proc JudyLDel: JLArray * word * &JError_t * &int</a></pre>
<pre>0154:    <a href="/$src/lib/std/datatype/judy.flx#0154">proc JudyLGet: JLArray * word * &JError_t * &&word</a></pre>
<pre>0157:    <a href="/$src/lib/std/datatype/judy.flx#0157">proc JudyLCount: JLArray * word * word * &JError_t * &word</a></pre>
<pre>0160:    <a href="/$src/lib/std/datatype/judy.flx#0160">proc JudyLByCount: JLArray * word * &word * &JError_t * &&word</a></pre>
<pre>0163:    <a href="/$src/lib/std/datatype/judy.flx#0163">proc JudyLFreeArray: JLArray * &JError_t * &word</a></pre>
<pre>0166:    <a href="/$src/lib/std/datatype/judy.flx#0166">proc JudyLMemUsed: JLArray * &word</a></pre>
<pre>0169:    <a href="/$src/lib/std/datatype/judy.flx#0169">proc JudyLFirst: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0172:    <a href="/$src/lib/std/datatype/judy.flx#0172">proc JudyLNext: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0175:    <a href="/$src/lib/std/datatype/judy.flx#0175">proc JudyLLast: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0178:    <a href="/$src/lib/std/datatype/judy.flx#0178">proc JudyLPrev: JLArray * &word * &JError_t * &&word</a></pre>
<pre>0181:    <a href="/$src/lib/std/datatype/judy.flx#0181">proc JudyLFirstEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0184:    <a href="/$src/lib/std/datatype/judy.flx#0184">proc JudyLNextEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0187:    <a href="/$src/lib/std/datatype/judy.flx#0187">proc JudyLLastEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0190:    <a href="/$src/lib/std/datatype/judy.flx#0190">proc JudyLPrevEmpty: JLArray * &word * &JError_t * &word</a></pre>
<pre>0216:    <a href="/$src/lib/std/datatype/judy.flx#0216">gen _ctor_JSLArray: 1 -> JSLArray</a></pre>
<pre>0222:    <a href="/$src/lib/std/datatype/judy.flx#0222">proc free: JSLArray</a></pre>
<pre>0226:    <a href="/$src/lib/std/datatype/judy.flx#0226">proc JudySLIns: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0232:    <a href="/$src/lib/std/datatype/judy.flx#0232">proc JudySLDel: JSLArray * +char * &JError_t * &int</a></pre>
<pre>0235:    <a href="/$src/lib/std/datatype/judy.flx#0235">proc JudySLGet: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0238:    <a href="/$src/lib/std/datatype/judy.flx#0238">proc JudySLFirst: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0241:    <a href="/$src/lib/std/datatype/judy.flx#0241">proc JudySLNext: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0244:    <a href="/$src/lib/std/datatype/judy.flx#0244">proc JudySLLast: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0247:    <a href="/$src/lib/std/datatype/judy.flx#0247">proc JudySLPrev: JSLArray * +char * &JError_t * &&word</a></pre>
<pre>0255:    <a href="/$src/lib/std/datatype/judy.flx#0255">type JHSArray</a></pre>
<pre>0256:    <a href="/$src/lib/std/datatype/judy.flx#0256">gen _ctor_JHSArray: 1 -> JHSArray</a></pre>
<pre>0258:    <a href="/$src/lib/std/datatype/judy.flx#0258">proc free: JHSArray</a></pre>
<pre>0263:    <a href="/$src/lib/std/datatype/judy.flx#0263">proc JudyHSIns: JHSArray * address * word * &JError_t * &&word</a></pre>
<pre>0266:    <a href="/$src/lib/std/datatype/judy.flx#0266">proc JudyHSDel: JHSArray * address * word * &JError_t * &int</a></pre>
<pre>0269:    <a href="/$src/lib/std/datatype/judy.flx#0269">proc JudyHSGet: JHSArray * address * word * &JError_t * &&word</a></pre>
<hr/><a href="/$src/lib/std/datatype/option.flx">datatype/option.flx</a>
<pre>0004:    <a href="/$src/lib/std/datatype/option.flx#0004">union opt[T]</a></pre>

<pre>0009:  <a href="/$src/lib/std/datatype/option.flx#0009">open class Option</a></pre>
<pre>0012:    <a href="/$src/lib/std/datatype/option.flx#0012">fun str (x:opt[T])</a></pre>
<pre>0022:    <a href="/$src/lib/std/datatype/option.flx#0022">fun or_else[T] (x:opt[T]) (d:T) : T</a></pre>
<pre>0031:    <a href="/$src/lib/std/datatype/option.flx#0031">fun or_else[T] (x:opt[T]) (alt:opt[T]) : opt[T]</a></pre>
<pre>0039:    <a href="/$src/lib/std/datatype/option.flx#0039">proc iter[T] (_f:T->void) (x:opt[T])</a></pre>
<pre>0047:    <a href="/$src/lib/std/datatype/option.flx#0047">ctor[T] list[T] (x:opt[T])</a></pre>
<pre>0055:    <a href="/$src/lib/std/datatype/option.flx#0055">pure fun is_empty[T] : opt[T] -> 2</a></pre>
<pre>0061:    <a href="/$src/lib/std/datatype/option.flx#0061">pure fun is_defined[T] : opt[T] -> 2</a></pre>
<pre>0067:    <a href="/$src/lib/std/datatype/option.flx#0067">fun get[T] : opt[T] -> T</a></pre>
<pre>0073:    <a href="/$src/lib/std/datatype/option.flx#0073">fun map[T,U] (_f:T->U) (x:opt[T]): opt[U]</a></pre>
<pre>0083:    <a href="/$src/lib/std/datatype/option.flx#0083">fun filter[T] (P:T -> bool) (x:opt[T]) : opt[T]</a></pre>
<pre>0093:    <a href="/$src/lib/std/datatype/option.flx#0093">gen iterator[T] (var x:opt[T]) ()</a></pre>

<pre>0099:  <a href="/$src/lib/std/datatype/option.flx#0099">class DefaultValue[T]</a></pre>
<pre>0100:    <a href="/$src/lib/std/datatype/option.flx#0100">virtual fun default[T]: 1->T</a></pre>
<pre>0102:    <a href="/$src/lib/std/datatype/option.flx#0102">fun or_default[T]  (x:opt[T]) ()</a></pre>
<hr/><a href="/$src/lib/std/datatype/ralist.flx">datatype/ralist.flx</a>

<pre>0009:  <a href="/$src/lib/std/datatype/ralist.flx#0009">class Ralist</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Purely functional Random Access List.
 Based on design from Okasaki, Purely Functional Datastructures.
 Transcribed from Hongwei Xi's encoding for ATS2 library.
</p><p> An ralist provides O(log N) indexed access and amortised
 O(1) consing. This is roughly the closest thing to
 purely functional array available.
</p></div>
<pre>0013:    <a href="/$src/lib/std/datatype/ralist.flx#0013">union pt[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Auxilliary data structure.
</p></div>
<pre>0016:    <a href="/$src/lib/std/datatype/ralist.flx#0016">union ralist[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of an ralist.
</p></div>
<pre>0023:    <a href="/$src/lib/std/datatype/ralist.flx#0023">fun ralist_length[a] : ralist[a] -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Length of an ralist.
</p></div>
<pre>0040:    <a href="/$src/lib/std/datatype/ralist.flx#0040">fun ralist_cons[a] (x:a, xs: ralist[a])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Cons: new list with extra value at the head.
</p></div>
<pre>0045:    <a href="/$src/lib/std/datatype/ralist.flx#0045">fun ralist_empty[a]: ralist[a] -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check for an empty list.
</p></div>
<pre>0074:    <a href="/$src/lib/std/datatype/ralist.flx#0074">proc ralist_uncons[a] (xs: ralist[a], phd: &a, ptl: &ralist[a])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Proedure to split a non-empty ralist
 into a head element and a tail.
</p></div>
<pre>0084:    <a href="/$src/lib/std/datatype/ralist.flx#0084">fun ralist_head[a] (xs: ralist[a]) : a</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Head element of a non-empty ralist.
</p></div>
<pre>0093:    <a href="/$src/lib/std/datatype/ralist.flx#0093">fun ralist_tail[a] (xs: ralist[a]) : ralist[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Tail list of a non-empty ralist.
</p></div>
<pre>0128:    <a href="/$src/lib/std/datatype/ralist.flx#0128">fun ralist_lookup[a] (xs:ralist[a],i:int)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Random access to an ralist. Unchecked.
</p></div>
<pre>0169:    <a href="/$src/lib/std/datatype/ralist.flx#0169">fun ralist_update[a] (xs:ralist[a], i:int, x0:a)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a list with the i'th element replaced by x0.
 Index is unchecked.
</p></div>
<pre>0210:    <a href="/$src/lib/std/datatype/ralist.flx#0210">proc ralist_foreach[a]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Callback based iteration.
 Apply procedure to each element of the ralist.
</p></div>
<pre>0229:    <a href="/$src/lib/std/datatype/ralist.flx#0229">fun str (xx: ralist[a]):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert ralist to a string.
</p></div>
<hr/><a href="/$src/lib/std/datatype/sarray.flx">datatype/sarray.flx</a>

<pre>0004:  <a href="/$src/lib/std/datatype/sarray.flx#0004">open class Sarray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Unbounded sparse psuedo-array sarray.
 This data type is not a real array because it has no bounds
 and therefore cannot support iteration.
</p></div>
<pre>0010:    <a href="/$src/lib/std/datatype/sarray.flx#0010">type sarray[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a sarray.
</p></div>
<pre>0013:    <a href="/$src/lib/std/datatype/sarray.flx#0013">ctor[T] sarray[T] (dflt:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct an infinite sarray with all values set to the given default.
</p></div>
<pre>0016:    <a href="/$src/lib/std/datatype/sarray.flx#0016">fun get[T] (a:sarray[T], i:size) : T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the value at the given position.
</p></div>
<pre>0025:    <a href="/$src/lib/std/datatype/sarray.flx#0025">proc set[T] (a:sarray[T], i:size, v:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Set the given value at the given position.
</p></div>
<pre>0048:    <a href="/$src/lib/std/datatype/sarray.flx#0048">proc del[T] (a:sarray[T], i:size)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Replace the value at a given position with the default.
</p></div>
<pre>0068:    <a href="/$src/lib/std/datatype/sarray.flx#0068">proc pack[T] (a:sarray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pack a sparse array. 
 This is an optimisation with no semantics.
 Reorganises the sarray to reduce memory use and optimise lookup.
</p></div>
<hr/><a href="/$src/lib/std/datatype/slice.flx">datatype/slice.flx</a>
<pre>0002:    <a href="/$src/lib/std/datatype/slice.flx#0002">union slice[T]</a></pre>
<pre>0010:    <a href="/$src/lib/std/datatype/slice.flx#0010">gen slice_range[T with Integer[T]] (first:T) (last:T) ()</a></pre>
<pre>0015:    <a href="/$src/lib/std/datatype/slice.flx#0015">gen iterator[t] (f:1->opt[t])</a></pre>
<pre>0030:    <a href="/$src/lib/std/datatype/slice.flx#0030">fun cal_slice (n:int, var b:int, var e:int)</a></pre>
<hr/><a href="/$src/lib/std/datatype/sort.flx">datatype/sort.flx</a>

<pre>0002:  <a href="/$src/lib/std/datatype/sort.flx#0002">class Sort</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Utility class to leverage STL sort.
</p></div>
<pre>0009:    <a href="/$src/lib/std/datatype/sort.flx#0009">struct comparator</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> STL compliant comparator object built from
 a closure of a Felix function.
</p></div>
<pre>0021:    <a href="/$src/lib/std/datatype/sort.flx#0021">type stl_comparator[T]</a></pre>
<pre>0028:    <a href="/$src/lib/std/datatype/sort.flx#0028">ctor[T] stl_comparator[T] (cmp:T * T -> bool)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Make a C++ STL comparator object from a Felix comparison function.
</p></div>
<pre>0033:    <a href="/$src/lib/std/datatype/sort.flx#0033">proc stl_sort[T]: stl_comparator[T] * +T * +T</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke stl sort with C++ comparator.
</p></div>
<pre>0037:    <a href="/$src/lib/std/datatype/sort.flx#0037">inline proc stl_sort[T] (cmp: T * T -> bool, b: +T,  e:+T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke stl sort with Felix comparison function.
</p></div>
<pre>0042:    <a href="/$src/lib/std/datatype/sort.flx#0042">inline proc stl_sort[T with Tord[T]] (b:+T, e:+T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke stl sort default comparison function.
</p></div>
<hr/><a href="/$src/lib/std/datatype/strdict.flx">datatype/strdict.flx</a>

<pre>0014:  <a href="/$src/lib/std/datatype/strdict.flx#0014">class StrDict[T]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> A strdict is dictionary keyed by strings.
 The strings must not contain nul bytes.
</p><p> This is an ultra high performance data structure
 implemented using a JudySLArray.
 Typically about the same speed as a hashtable on exact key retrieval,
 but with the ability to perform linear key seeking as well.
 Linear seeking means searching for a key satisfying one of the total
 ordering relations to a given key, including ordered iteration.
</p><p> Scales to terabytes.
 No other data structure can do this.
</p></div>
<pre>0018:    <a href="/$src/lib/std/datatype/strdict.flx#0018">type strdict</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a strdict.
</p></div>
<pre>0021:    <a href="/$src/lib/std/datatype/strdict.flx#0021">ctor strdict()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct and empty dictionary.
</p></div>
<pre>0023:    <a href="/$src/lib/std/datatype/strdict.flx#0023">proc add (x:strdict) (key:string) (value: T)</a></pre>
<pre>0031:    <a href="/$src/lib/std/datatype/strdict.flx#0031">ctor strdict ( kv: list[string * T] )</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a dictionary from a list of pairs.
</p></div>
<pre>0039:    <a href="/$src/lib/std/datatype/strdict.flx#0039">fun get (x:strdict) (key: string) : opt[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch a value optionally using the given key.
</p></div>
<pre>0047:    <a href="/$src/lib/std/datatype/strdict.flx#0047">fun haskey (x:strdict) (key: string) : bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if value is in the dictionary.
</p></div>
<pre>0059:    <a href="/$src/lib/std/datatype/strdict.flx#0059">fun get_dflt (x:strdict) (key:string, dflt:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch a value using the given key.
 If there is no value in the dictionary with that key,
 then return a default value.
</p></div>
<pre>0068:    <a href="/$src/lib/std/datatype/strdict.flx#0068">gen del (x:strdict) (key: string) : bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Remove a key/value pair from the dictionary if it exists.
 Return a boolean value signalling if it existed. 
</p></div>
<pre>0077:    <a href="/$src/lib/std/datatype/strdict.flx#0077">gen charp_get_ge (x:strdict) (var key: +char) : opt[T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than or equal to
 the supplied NTBS (unsafe!)
</p></div>
<pre>0091:    <a href="/$src/lib/std/datatype/strdict.flx#0091">fun get_ge (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than or equal to
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0110:    <a href="/$src/lib/std/datatype/strdict.flx#0110">gen charp_get_gt (x:strdict) (var key: +char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than  (>)
 the supplied NTBS (unsafe!)
</p></div>
<pre>0124:    <a href="/$src/lib/std/datatype/strdict.flx#0124">fun get_gt (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key greater than (>) 
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0143:    <a href="/$src/lib/std/datatype/strdict.flx#0143">gen charp_get_le (x:strdict) (var key: +char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than or equal to (<=)
 the supplied NTBS (unsafe!)
</p></div>
<pre>0157:    <a href="/$src/lib/std/datatype/strdict.flx#0157">fun get_le (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than or equal to (<=)
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0176:    <a href="/$src/lib/std/datatype/strdict.flx#0176">gen charp_get_lt (x:strdict) (var key: +char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than (<)
 the supplied NTBS (unsafe!)
</p></div>
<pre>0190:    <a href="/$src/lib/std/datatype/strdict.flx#0190">fun get_lt (x:strdict) (var key: string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get an optional value with key less than (<)
 the supplied string. Safer than the NTBS version but slower. 
 Fails if the string contains a nul byte.
</p></div>
<pre>0209:    <a href="/$src/lib/std/datatype/strdict.flx#0209">gen charp_first (x:strdict) (buffer:+char)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the optional first key in the dictionary into
 the supplied NTBS (unsafe!)
</p></div>
<pre>0215:    <a href="/$src/lib/std/datatype/strdict.flx#0215">fun first (x:strdict) : opt[string * T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the optional first key in the dictionary.
</p></div>
<pre>0220:    <a href="/$src/lib/std/datatype/strdict.flx#0220">gen iterator (x:strdict) () : opt[string * T]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Stream iterator scanning through all key value pairs
 in the dictionary, in key order.
</p></div>
<pre>0236:    <a href="/$src/lib/std/datatype/strdict.flx#0236">fun str(var x:strdict) : string</a></pre>
<hr/><a href="/$src/lib/std/datatype/tuple.flx">datatype/tuple.flx</a>

<pre>0005:  <a href="/$src/lib/std/datatype/tuple.flx#0005">class Tuple[U]</a></pre>
<pre>0006:    <a href="/$src/lib/std/datatype/tuple.flx#0006">virtual fun tuple_str (x:U)</a></pre>
<pre>0010:    <a href="/$src/lib/std/datatype/tuple.flx#0010">fun tuple_str (x: U ** V)</a></pre>
<pre>0018:    <a href="/$src/lib/std/datatype/tuple.flx#0018">fun tuple_str (x: U * V)</a></pre>
<pre>0027:    <a href="/$src/lib/std/datatype/tuple.flx#0027">fun str (x: U ** V)</a></pre>
<pre>0031:    <a href="/$src/lib/std/datatype/tuple.flx#0031">fun str (t:T, u:U)</a></pre>
<pre>0034:    <a href="/$src/lib/std/datatype/tuple.flx#0034">fun str (t1:T, t2:T)</a></pre>
<pre>0087:    <a href="/$src/lib/std/datatype/tuple.flx#0087">fun field[n,t,u where n</a></pre>
<pre>0088:    <a href="/$src/lib/std/datatype/tuple.flx#0088">fun field[n,t,u where n</a></pre>
<pre>0090:    <a href="/$src/lib/std/datatype/tuple.flx#0090">fun field[n,t,u,v where n</a></pre>
<pre>0091:    <a href="/$src/lib/std/datatype/tuple.flx#0091">fun field[n,t,u,v where n</a></pre>
<pre>0092:    <a href="/$src/lib/std/datatype/tuple.flx#0092">fun field[n,t,u,v where n</a></pre>
<pre>0094:    <a href="/$src/lib/std/datatype/tuple.flx#0094">fun field[n,t,u,v,w where n</a></pre>
<pre>0095:    <a href="/$src/lib/std/datatype/tuple.flx#0095">fun field[n,t,u,v,w where n</a></pre>
<pre>0096:    <a href="/$src/lib/std/datatype/tuple.flx#0096">fun field[n,t,u,v,w where n</a></pre>
<pre>0097:    <a href="/$src/lib/std/datatype/tuple.flx#0097">fun field[n,t,u,v,w where n</a></pre>
<pre>0099:    <a href="/$src/lib/std/datatype/tuple.flx#0099">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0100:    <a href="/$src/lib/std/datatype/tuple.flx#0100">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0101:    <a href="/$src/lib/std/datatype/tuple.flx#0101">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0102:    <a href="/$src/lib/std/datatype/tuple.flx#0102">fun field[n,t,u,v,w,x where n</a></pre>
<pre>0103:    <a href="/$src/lib/std/datatype/tuple.flx#0103">fun field[n,t,u,v,w,x where n</a></pre>
<hr/><a href="/$src/lib/std/datatype/varray.flx">datatype/varray.flx</a>

<pre>0003:  <a href="/$src/lib/std/datatype/varray.flx#0003">open class Varray</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Bounded Variable length arrays, bound set at construction time.
</p></div>
<pre>0010:    <a href="/$src/lib/std/datatype/varray.flx#0010">ctor[t] carray[t] : varray[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A varray is just a pointer. 
 The current length and bound are maintained by the GC.
 An ordinary carray, but owned by the GC.
</p></div>
<pre>0013:    <a href="/$src/lib/std/datatype/varray.flx#0013">ctor[t] varray[t]: size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create an empty varray with the given bound.
</p></div>
<pre>0023:    <a href="/$src/lib/std/datatype/varray.flx#0023">ctor[t] varray[t] (bound:size, default:t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Raw memory initialisation (really, this belongs in C_hack).
 Construct a varray filled up with a default value.
</p></div>
<pre>0032:    <a href="/$src/lib/std/datatype/varray.flx#0032">ctor[t] varray[t] (bound:size, used:size, f:size->t when used <</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a partially filled varray with a default value computed by a function.
</p></div>
<pre>0042:    <a href="/$src/lib/std/datatype/varray.flx#0042">ctor[t,N] varray[t] (x:array[t,N])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a full varray from an array.
</p></div>
<pre>0047:    <a href="/$src/lib/std/datatype/varray.flx#0047">ctor[t] varray[t] (x:varray[t], maxlen:size)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a partially full varray from a varray.
</p></div>
<pre>0052:    <a href="/$src/lib/std/datatype/varray.flx#0052">ctor[t] varray[t] (x:varray[t])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a full varray from a varray (copy constructor).
</p></div>
<pre>0057:    <a href="/$src/lib/std/datatype/varray.flx#0057">ctor[t] varray[t] (x:list[t])</a></pre>
<pre>0066:    <a href="/$src/lib/std/datatype/varray.flx#0066">ctor varray[char] (var x:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct a varray from a string.
 Include a trailing nul byte.
</p></div>
<pre>0084:    <a href="/$src/lib/std/datatype/varray.flx#0084">fun len: varray[v] -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Treat a varray as an ArrayValue.
 Length of a varray (used).
</p></div>
<pre>0089:    <a href="/$src/lib/std/datatype/varray.flx#0089">fun unsafe_get: varray[v] * size -> v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unsafe get value at position.
</p></div>
<pre>0096:    <a href="/$src/lib/std/datatype/varray.flx#0096">proc unsafe_set: varray[v] * size * v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Treat a varray as an ArrayObject.
 Allows modifications.
 Store the given value at the given position.
</p></div>
<pre>0102:    <a href="/$src/lib/std/datatype/varray.flx#0102">fun stl_begin: varray[v] -> +v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Treat a varray as a ContiguousArrayObject.
 STL iterator to start of array.
</p></div>
<pre>0105:    <a href="/$src/lib/std/datatype/varray.flx#0105">fun stl_end: varray[v] -> +v</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> STL iterator to end of array.
</p></div>
<pre>0109:    <a href="/$src/lib/std/datatype/varray.flx#0109">fun maxlen[t]: varray[t] -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the bound of a varray.
</p></div>
<pre>0120:    <a href="/$src/lib/std/datatype/varray.flx#0120">proc push_back[t] : varray[t] * t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Append a new element to the end of a varray.
 Aborts if you go past the bound.
 Append a new element to the end of a varray.
 Aborts if you go past the bound.
</p></div>
<pre>0133:    <a href="/$src/lib/std/datatype/varray.flx#0133">proc pop[t] : varray[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pop an element off the end of a varray.
 Aborts if the array is empty.
</p></div>
<pre>0145:    <a href="/$src/lib/std/datatype/varray.flx#0145">fun map[T, U] (_f:T->U) (x:varray[T]): varray[U]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Traditional map varray to varray.
</p></div>
<pre>0160:    <a href="/$src/lib/std/datatype/varray.flx#0160">fun str (xs:varray[T])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a varray[T] to a string.
 Requires Show[T]
</p></div>
<hr/><a href="/$src/lib/std/db/__init__.flx">db/__init__.flx</a>
<hr/><a href="/$src/lib/std/db/pgsql/__init__.flx">db/pgsql/__init__.flx</a>
<hr/><a href="/$src/lib/std/db/pgsql/pgsql.flx">db/pgsql/pgsql.flx</a>

<pre>0001:  <a href="/$src/lib/std/db/pgsql/pgsql.flx#0001">class Pgsql</a></pre>
<pre>0005:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0005">fun isNull[t]: t -> bool</a></pre>
<pre>0006:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0006">proc hex_of[t]: t</a></pre>
<pre>0009:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0009">type pgconn</a></pre>
<pre>0010:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0010">type pgconn_ptr</a></pre>
<pre>0011:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0011">type pgresult_ptr</a></pre>
<pre>0023:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0023">typedef conn_status_type</a></pre>
<pre>0032:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0032">typedef postgres_polling_status_type</a></pre>
<pre>0050:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0050">typedef exec_status_type</a></pre>
<pre>0059:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0059">typedef pg_transaction_status_type</a></pre>
<pre>0082:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0082">gen pq_connectdb: string->pgconn_ptr</a></pre>
<pre>0088:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0088">proc pq_finish: pgconn_ptr</a></pre>
<pre>0093:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0093">proc pq_reset: pgconn_ptr</a></pre>
<pre>0099:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0099">gen pq_status: pgconn_ptr->conn_status_type</a></pre>
<pre>0104:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0104">gen pq_transaction_status: pgconn_ptr->pg_transaction_status_type</a></pre>
<pre>0112:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0112">generally be returned except in out-of-memory conditions or serious errors such as</a></pre>
<pre>0118:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0118">gen pq_exec: pgconn_ptr*string-> pgresult_ptr</a></pre>
<pre>0142:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0142">gen pq_result_status: pgresult_ptr->exec_status_type</a></pre>
<pre>0149:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0149">gen pq_res_status: exec_status_type->string</a></pre>
<pre>0156:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0156">gen pq_result_error_message: pgresult_ptr->string</a></pre>
<pre>0163:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0163">proc pq_clear: pgresult_ptr</a></pre>
<pre>0170:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0170">gen pq_ntuples: pgresult_ptr->int</a></pre>
<pre>0176:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0176">gen pq_nfields: pgresult_ptr->int</a></pre>
<pre>0184:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0184">gen pq_fname: pgresult_ptr*int->string</a></pre>
<pre>0190:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0190">gen pq_fnumber: pgresult_ptr*string->int</a></pre>
<pre>0270:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0270">gen pq_getvalue: pgresult_ptr*int*int->string</a></pre>
<pre>0315:    <a href="/$src/lib/std/db/pgsql/pgsql.flx#0315">typedef struct</a></pre>
<hr/><a href="/$src/lib/std/db/pgsql/pgsql_pool.flx">db/pgsql/pgsql_pool.flx</a>

<pre>0004:  <a href="/$src/lib/std/db/pgsql/pgsql_pool.flx#0004">class PgsqlPool</a></pre>
<pre>0011:    <a href="/$src/lib/std/db/pgsql/pgsql_pool.flx#0011">fun create_pgsql_pool(connect_string:string,sz:int)</a></pre>
<pre>0027:    <a href="/$src/lib/std/db/pgsql/pgsql_pool.flx#0027">proc destroy_member (m:member_t)</a></pre>
<hr/><a href="/$src/lib/std/db/sqlite3/__init__.flx">db/sqlite3/__init__.flx</a>
<hr/><a href="/$src/lib/std/db/sqlite3/sqlite3.flx">db/sqlite3/sqlite3.flx</a>

<pre>0039:  <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0039">class Sqlite3</a></pre>
Unable to understand @command ''
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Core Sqlite3 functions and extensions to provide row iterator, simple statement execution, 
 statement preperation and access to sqlite_step statement execution.
</p><p> Iterator example:
 
</p><p><pre class='flxbg'><span class="lineno" id="0001">0001: </span>  <span class="big_keyword" title="Define a mutable variable">var</span> db : sqlite3_db_t;
<span class="lineno" id="0002">0002: </span>  <span class="big_keyword" title="Define a mutable variable">var</span> stmt:sqlite3_stmt_t;
<span class="lineno" id="0003">0003: </span>  <span class="big_keyword" title="Define a mutable variable">var</span> err = sqlite3_open(<span class="fstring">"multiple_sa.db"</span>, &amp;db);
<span class="lineno" id="0004">0004: </span>  <span class="small_keyword" title="conditional">if</span> err != 0 <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id="0005">0005: </span>    <span class="library" title="Print a string to standard output">print</span> <span class="fstring">"open DB error[abort] "</span>;
<span class="lineno" id="0006">0006: </span>    <span class="library" title="Print a string to standard output with newline appended">println</span> $ sqlite3_errmsg db;
<span class="lineno" id="0007">0007: </span>    <span class="small_keyword" title="jump to label">goto</span> finish;
<span class="lineno" id="0008">0008: </span>  <span class="small_keyword" title="end of body">done</span>;
<span class="lineno" id="0009">0009: </span>  err = sqlite3_prepare_v2(db, <span class="fstring">"select * from contact"</span>, 21, stmt, <span class="fstring">""</span>);
<span class="lineno" id="0010">0010: </span>  <span class="small_keyword" title="conditional">if</span> not err == (caseno SQLITE_OK) <span class="small_keyword" title="conditional">then</span>
<span class="lineno" id="0011">0011: </span>    { <span class="library" title="Print a string to standard output with newline appended">println</span> (<span class="fstring">"sql error "</span>+<span class="library" title="Convert a value to a string">str</span>(err)+<span class="fstring">":"</span>+sqlite3_errmsg(db));<span class="small_keyword" title="jump to label">goto</span> finish; }
<span class="lineno" id="0012">0012: </span>  <span class="small_keyword" title="conditional">else</span> {
<span class="lineno" id="0013">0013: </span>    <span class="big_keyword" title="Define a mutable variable">var</span> it = sqlite3_row_iterator (stmt);
<span class="lineno" id="0014">0014: </span>    <span class="big_keyword" title="Define a mutable variable">var</span> row:ret_val[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[column_value]];
<span class="lineno" id="0015">0015: </span>    <span class="small_keyword" title="while loop">while</span> (<span class="big_keyword" title="Define a function with no side-effects">fun</span> ():bool = { row = it();
<span class="lineno" id="0016">0016: </span>               <span class="small_keyword" title="return">return</span> (<span class="small_keyword" title="match statement or expression">match</span> row <span class="small_keyword" title="type-class constraint">with</span> |end_of_results[<span class="library" title="array with unbounded dynamically variable limit">darray</span>[column_value]] =&gt;false |_ =&gt; true
<span class="lineno" id="0017">0017: </span>               <span class="small_keyword" title="end a match statement or expression">endmatch</span>); }) () <span class="small_keyword" title="imperative code begins">do</span>
<span class="lineno" id="0018">0018: </span>    <span class="big_keyword" title="Define a mutable variable">var</span> t = <span class="small_keyword" title="match statement or expression">match</span> row <span class="small_keyword" title="type-class constraint">with</span> 
<span class="lineno" id="0019">0019: </span>      | row ?a =&gt;  ((get_text_val(get(a,0))),(get_text_val(get(a,1))))
<span class="lineno" id="0020">0020: </span>      | _ =&gt; (<span class="fstring">""</span>,<span class="fstring">""</span>)
<span class="lineno" id="0021">0021: </span>    <span class="small_keyword" title="end a match statement or expression">endmatch</span>;
<span class="lineno" id="0022">0022: </span>    <span class="library" title="Print a string to standard output">print</span> t; endl;
<span class="lineno" id="0023">0023: </span>    <span class="small_keyword" title="end of body">done</span>
<span class="lineno" id="0024">0024: </span>  }
<span class="lineno" id="0025">0025: </span>  finish:&gt;
<span class="lineno" id="0026">0026: </span>    err = sqlite3_finalize(stmt);
<span class="lineno" id="0027">0027: </span>    <span class="library" title="Print a string to standard output with newline appended">println</span>(<span class="library" title="Convert a value to a string">str</span>(err));
<span class="lineno" id="0028">0028: </span>    sqlite3_close(db);
</pre></p></div>
<pre>0043:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0043">type sqlite3_db_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a database handle.
</p></div>
<pre>0046:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0046">gen sqlite3_open : string * &sqlite3_db_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Database open.
</p></div>
<pre>0051:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0051">proc sqlite3_close : sqlite3_db_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Database close.
</p></div>
<pre>0054:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0054">typedef sqlite3_exec_callback_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of an exec callback.
</p></div>
<pre>0069:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0069">gen sqlite3_exec : sqlite3_db_t * string * sqlite3_exec_callback_t * address * &(+char) -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Quick sql execution using callback.
 arg1: db_handle
 arg2: sql statement.
 arg3: callback function.
 arg4: client data pointer.
 arg5: pointer to error message array.
 result: error code.
</p></div>
<pre>0077:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0077">gen sqlite3_exec : sqlite3_db_t * string   * &(+char) -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> quick sql execution without data handler callback.
 arg1: db_handle
 arg2: sql statement.
 arg3: pointer to error message array.
</p></div>
<pre>0083:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0083">gen sqlite3_errmsg : sqlite3_db_t -> +char</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Error message extractor.
</p></div>
<pre>0088:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0088">type sqlite3_stmt_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of sql statement handle.
</p></div>
<pre>0125:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0125">fun to_sqlite3_result_code: int -> sqlite3_result_codes</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Sqlite3 return codes.
 Conversion from int result to named return codes.
</p></div>
<pre>0174:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0174">fun to_sqlite3_type: int -> sqlite3_types</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Tag names for Sqlite3 data types.
 Allow checking for specific return codes.
 Conversion from int type to named Sqlite3 data type.
</p></div>
<pre>0184:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0184">gen sqlite3_prepare_v2: sqlite3_db_t * string * int * sqlite3_stmt_t *string -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Prepare an sqlite3 statement for execution.
</p></div>
<pre>0188:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0188">noinline gen sqlite3_step: sqlite3_stmt_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute one step of the prepared statement.
</p></div>
<pre>0191:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0191">gen sqlite3_column_count: sqlite3_stmt_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determine the number of columns (field) a statement will process.
</p></div>
<pre>0194:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0194">gen sqlite3_column_name: sqlite3_stmt_t*int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determine the name of the n'th column to be processed.
</p></div>
<pre>0197:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0197">gen sqlite3_column_type: sqlite3_stmt_t*int->int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Determine the type of the n'th column to be processed.
</p></div>
<pre>0200:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0200">gen sqlite3_column_text: sqlite3_stmt_t*int->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a text field.
</p></div>
<pre>0203:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0203">gen sqlite3_column_double: sqlite3_stmt_t*int->double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a double field.
</p></div>
<pre>0206:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0206">gen sqlite3_column_int: sqlite3_stmt_t*int->int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a int field.
</p></div>
<pre>0209:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0209">gen sqlite3_column_blob: sqlite3_stmt_t*int->&byte</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the value of a blob field.
</p></div>
<pre>0212:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0212">gen sqlite3_column_bytes: sqlite3_stmt_t*int -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch the number of bytes of a field.
</p></div>
<pre>0217:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0217">gen sqlite3_finalize: sqlite3_stmt_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Finish up with stepping a statement.
 Releases associated resources.
 The statement handle becomes invalid afterwards.
</p></div>
<pre>0220:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0220">union column_value</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A unified type to fetch a field value.
</p></div>
<pre>0228:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0228">union ret_val[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A unified result of a statement.
</p></div>
<pre>0234:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0234">union result_code[t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A unified result code.
</p></div>
<pre>0239:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0239">fun sqlite3_prepare_stmt (db:sqlite3_db_t,query:string):result_code[sqlite3_stmt_t]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Unified preparation of a query.
</p></div>
<pre>0249:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0249">fun sqlite3_get_columns (stmt:sqlite3_stmt_t):darray[column_value]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fetch all the columns of a query at once.
 Return them in a darray.
</p></div>
<pre>0268:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0268">gen sqlite3_row_iterator (stmt:sqlite3_stmt_t) () :ret_val[darray[column_value]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> A stream iterator which returns successive rows of a table.
</p></div>
<pre>0285:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0285">fun get_int_val: column_value->int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the int value out of a int typed field.
 Throws match failure if the field isn't an int type.
</p></div>
<pre>0289:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0289">fun get_double_val:  column_value->double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the double value out of a double typed field.
 Throws match failure if the field isn't a double type.
</p></div>
<pre>0293:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0293">fun get_text_val:  column_value->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the text value out of a text typed field.
 Throws match failure if the field isn't a text type.
</p></div>
<pre>0296:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0296">fun get_stmt: result_code[sqlite3_stmt_t]-> sqlite3_stmt_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the statement handle out of a return code.
</p></div>
<pre>0299:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0299">gen get_next ( iter:()->ret_val[darray[column_value]],row:&ret_val[darray[column_value]]):bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the next row from an row iterator.
</p></div>
<pre>0309:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0309">gen sqlite3_execute (stmt:sqlite3_stmt_t) :bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Execute an prepared statement.
</p></div>
<pre>0329:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0329">gen sqlite3_quote: string->string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Quote a string for use in a query.
</p></div>
<pre>0376:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0376">typename lpar number rpar |</a></pre>
<pre>0377:    <a href="/$src/lib/std/db/sqlite3/sqlite3.flx#0377">typename lpar number , number rpar</a></pre>
<hr/><a href="/$src/lib/std/db/sqlite3/sqlite3_pool.flx">db/sqlite3/sqlite3_pool.flx</a>

<pre>0003:  <a href="/$src/lib/std/db/sqlite3/sqlite3_pool.flx#0003">class Sqlite3Pool</a></pre>
<pre>0010:    <a href="/$src/lib/std/db/sqlite3/sqlite3_pool.flx#0010">fun sqlite3_pool(db_file:string):pool</a></pre>
<pre>0024:    <a href="/$src/lib/std/db/sqlite3/sqlite3_pool.flx#0024">proc destroy_member (m:sqlite3_db_t)</a></pre>
<hr/><a href="/$src/lib/std/debug.flx">debug.flx</a>
<pre>0003:    <a href="/$src/lib/std/debug.flx#0003">type flx_location_t</a></pre>

<pre>0005:  <a href="/$src/lib/std/debug.flx#0005">class Debug</a></pre>
<pre>0012:    <a href="/$src/lib/std/debug.flx#0012">fun filename: flx_location_t -> +char</a></pre>
<pre>0013:    <a href="/$src/lib/std/debug.flx#0013">fun startline: flx_location_t -> int</a></pre>
<pre>0014:    <a href="/$src/lib/std/debug.flx#0014">fun startcol: flx_location_t -> int</a></pre>
<pre>0015:    <a href="/$src/lib/std/debug.flx#0015">fun endline: flx_location_t -> int</a></pre>
<pre>0016:    <a href="/$src/lib/std/debug.flx#0016">fun endcol: flx_location_t -> int</a></pre>
<pre>0019:    <a href="/$src/lib/std/debug.flx#0019">fun str(var x:flx_location_t)</a></pre>
<pre>0030:    <a href="/$src/lib/std/debug.flx#0030">fun repr_expr[t]: t -> string</a></pre>
<hr/><a href="/$src/lib/std/directory.flx">directory.flx</a>

<pre>0003:  <a href="/$src/lib/std/directory.flx#0003">class Directory_class[os,mode_t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> File system directory services,
 Parametrised  by operating system and mode type.
</p></div>
<pre>0007:    <a href="/$src/lib/std/directory.flx#0007">virtual gen mkdir: string * mode_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create a directory with specified mode.
 Returns 0 if successful.
</p></div>
<pre>0011:    <a href="/$src/lib/std/directory.flx#0011">virtual gen mkdir: string -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create a directory with default mode.
 Returns 0 if successful.
</p></div>
<pre>0015:    <a href="/$src/lib/std/directory.flx#0015">virtual proc mkdirs: string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Try to ensure all the directories in a path exist.
 Does not return any error indication.
</p></div>
<pre>0021:    <a href="/$src/lib/std/directory.flx#0021">virtual fun filesin:string -> opt[List::list[string]]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return an option list of all the regular files in a given directory.
 Returns None if the directory does not exist or isn't accessible.
 Returns Some ?files if the directory exists and is accessible.
 If the directory has no regular files, the list is Empty.
</p></div>
<pre>0024:    <a href="/$src/lib/std/directory.flx#0024">virtual fun getcwd: 1 -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the absolute pathname of the current working directory.
</p></div>
<pre>0027:    <a href="/$src/lib/std/directory.flx#0027">virtual fun mk_absolute_filename: string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a relative filename to an absolute pathname. 
</p></div>

<pre>0032:  <a href="/$src/lib/std/directory.flx#0032">class Directory</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Host file system directory services.
 Platform dependent.
</p></div>
<hr/><a href="/$src/lib/std/env.flx">env.flx</a>

<pre>0002:  <a href="/$src/lib/std/env.flx#0002">class Env</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Access environmenyt variables.
</p></div>
<pre>0006:    <a href="/$src/lib/std/env.flx#0006">fun getenv:string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the value of a given variable.
 Returns empty string if the variable doesn't exist.
</p></div>
<pre>0012:    <a href="/$src/lib/std/env.flx#0012">fun getenv(name:string,dflt:string):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the value of a given variable.
 Returns specified default if the variable doesn't exist.
</p></div>
<hr/><a href="/$src/lib/std/felix/__init__.flx">felix/__init__.flx</a>
<hr/><a href="/$src/lib/std/felix/cident.flx">felix/cident.flx</a>

<pre>0005:  <a href="/$src/lib/std/felix/cident.flx#0005">class Cident</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> A function to convert a byte string into a
 legal C identifier in a canonical way.
 This routine should match the Ocaml function Flx_name.flxid_to_cid.
</p></div>
<pre>0010:    <a href="/$src/lib/std/felix/cident.flx#0010">fun basename : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Basename of a filename. Hacky, not the real thing.
 Enough for calculating module names hopefully.
 Treats / and \ as path separators.
</p></div>
<pre>0015:    <a href="/$src/lib/std/felix/cident.flx#0015">fun chop_extension : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Chop extension of a filename. Hacky, not the real thing.
 Enough for calculating module names hopefully.
 Treats / and \ as path separators.
</p></div>
<pre>0020:    <a href="/$src/lib/std/felix/cident.flx#0020">fun flxid_to_cid : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a "normal enough" Felix identifier to a C identifier.
 Does canonical replacement of chars illegal in C identifiers.
 Hacky, only supports ASCII, doesn't support i18n.
</p></div>
<pre>0025:    <a href="/$src/lib/std/felix/cident.flx#0025">fun filename_to_modulename : string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Convert a "normal enough" filename to a modulename.
 Uses all the above hacky stuff.
 Just please use sensible ASCII filenames!
</p></div>
<hr/><a href="/$src/lib/std/felix/rtti.flx">felix/rtti.flx</a>

<pre>0001:  <a href="/$src/lib/std/felix/rtti.flx#0001">class Rtti</a></pre>
<pre>0004:    <a href="/$src/lib/std/felix/rtti.flx#0004">type collector_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of the collector.
</p></div>
<pre>0007:    <a href="/$src/lib/std/felix/rtti.flx#0007">type gc_shape_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of an RTTI record.
</p></div>
<pre>0008:    <a href="/$src/lib/std/felix/rtti.flx#0008">fun isNULL: gc_shape_t -> bool</a></pre>
<pre>0009:    <a href="/$src/lib/std/felix/rtti.flx#0009">typedef gc_shape_flags_t</a></pre>
<pre>0016:    <a href="/$src/lib/std/felix/rtti.flx#0016">typedef gc_finaliser_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The type of a finalisation function.
</p></div>
<pre>0017:    <a href="/$src/lib/std/felix/rtti.flx#0017">typedef gc_encoder_t</a></pre>
<pre>0018:    <a href="/$src/lib/std/felix/rtti.flx#0018">typedef gc_decoder_t</a></pre>
<pre>0021:    <a href="/$src/lib/std/felix/rtti.flx#0021">fun next_shape: gc_shape_t -> gc_shape_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Iterator to find the next shape after a given one.
</p></div>
<pre>0024:    <a href="/$src/lib/std/felix/rtti.flx#0024">fun cname: gc_shape_t -> +char</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The C++ name of the Felix type.
</p></div>
<pre>0028:    <a href="/$src/lib/std/felix/rtti.flx#0028">fun number_of_elements: gc_shape_t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The static number of elements in an array type.
 Note this is not the size of a varray!
</p></div>
<pre>0031:    <a href="/$src/lib/std/felix/rtti.flx#0031">fun bytes_per_element: gc_shape_t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Number of bytes in one element.
</p></div>
<pre>0034:    <a href="/$src/lib/std/felix/rtti.flx#0034">fun finaliser: gc_shape_t -> gc_finaliser_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The finaliser function.
</p></div>
<pre>0037:    <a href="/$src/lib/std/felix/rtti.flx#0037">fun encoder : gc_shape_t -> gc_encoder_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The encoder function.
</p></div>
<pre>0040:    <a href="/$src/lib/std/felix/rtti.flx#0040">fun decoder: gc_shape_t -> gc_decoder_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The decoder function.
</p></div>
<pre>0043:    <a href="/$src/lib/std/felix/rtti.flx#0043">fun uses_offset_table : gc_shape_t -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check for offset data
</p></div>
<pre>0047:    <a href="/$src/lib/std/felix/rtti.flx#0047">fun _unsafe_n_offsets: gc_shape_t -> size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The number of pointers in the base type.
 If the type is an array that's the element type.
</p></div>
<pre>0049:    <a href="/$src/lib/std/felix/rtti.flx#0049">fun n_offsets (shape: gc_shape_t) : size</a></pre>
<pre>0054:    <a href="/$src/lib/std/felix/rtti.flx#0054">fun _unsafe_offsets: gc_shape_t -> +size</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Pointer to the offset table.
</p></div>
<pre>0056:    <a href="/$src/lib/std/felix/rtti.flx#0056">fun offsets (shape: gc_shape_t) : +size</a></pre>
<pre>0061:    <a href="/$src/lib/std/felix/rtti.flx#0061">fun flags: gc_shape_t -> gc_shape_flags_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Flags.
</p></div>
<pre>0065:    <a href="/$src/lib/std/felix/rtti.flx#0065">fun shape_list_head : unit -> gc_shape_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Global head of the compiled shape list.
 This is actually the first type, since they're linked together.
</p></div>
<pre>0068:    <a href="/$src/lib/std/felix/rtti.flx#0068">type type_info</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ type_info for the type.
</p></div>
<pre>0071:    <a href="/$src/lib/std/felix/rtti.flx#0071">fun name : type_info -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ source name of the type.
</p></div>
<pre>0088:    <a href="/$src/lib/std/felix/rtti.flx#0088">fun gxx_demangle(s:string) :string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ Type_info of a type.
 For gcc only, the C++ name a mangled name represents.
</p></div>
<pre>0095:    <a href="/$src/lib/std/felix/rtti.flx#0095">proc _link_shape[T]: &gc_shape_t</a></pre>
<pre>0120:    <a href="/$src/lib/std/felix/rtti.flx#0120">gen link_shape[T]()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Put a new shape record into the global list.
 This routine constructs a new shape record on the heap.
 It fills in some of the data based on the type.
 It links the new record into the shape list.
 Then it stores the shape at the user specified address.
 Since the shape is represented in Felix by a pointer,
 subsequent modifications carry through to the linked shape object.
 This routine is only useful for adding a shape record for a statically
 known type: that's useful because not all statically known types get
 shape records: the compiler only generates them if the shape is
 required because an object of that type is allocated on the heap.
</p></div>
<hr/><a href="/$src/lib/std/felix/sync.flx">felix/sync.flx</a>

<pre>0001:  <a href="/$src/lib/std/felix/sync.flx#0001">class SyncControl</a></pre>
<pre>0010:    <a href="/$src/lib/std/felix/sync.flx#0010">fun str: fstate_t -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Model of synchronous control state value.
 terminated: Not used.
 blocked: out of fthreads to run.
 delegated: non synchronous service call, delegate to our caller.
</p></div>
<pre>0026:    <a href="/$src/lib/std/felix/sync.flx#0026">type fthread_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fthread state model.
 next_fthread_pos: restart scheduler by grabbing a new fthread
 from the active list.
 next_request_pos: restart scheduler by handling the service
 request of the currently active fthread.
 The type of a list of active fthreads to schedule.
</p></div>
<pre>0029:    <a href="/$src/lib/std/felix/sync.flx#0029">ctor fthread_list: 1</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Construct an empty fthread list.
</p></div>
<pre>0032:    <a href="/$src/lib/std/felix/sync.flx#0032">proc delete : fthread_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Delete an fthread list.
</p></div>
<pre>0035:    <a href="/$src/lib/std/felix/sync.flx#0035">proc push_back: fthread_list * fthread</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Push an fthread onto an fthread list.
</p></div>
<pre>0038:    <a href="/$src/lib/std/felix/sync.flx#0038">ctor cont: (1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Upcast a procedure closure to a continuation.
</p></div>
<pre>0041:    <a href="/$src/lib/std/felix/sync.flx#0041">ctor fthread: cont</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Create an fthread from a continuation.
</p></div>
<pre>0044:    <a href="/$src/lib/std/felix/sync.flx#0044">type scheduler</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Type of a synchronous scheduler.
</p></div>
<pre>0049:    <a href="/$src/lib/std/felix/sync.flx#0049">ctor scheduler : fthread_list</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Constructor for a synchronous scheduler.
 Accepts a list of fthreads to run.
 Uses the callers garbage collector.
</p></div>
<pre>0050:    <a href="/$src/lib/std/felix/sync.flx#0050">proc delete: scheduler</a></pre>
<pre>0055:    <a href="/$src/lib/std/felix/sync.flx#0055">proc run : scheduler</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke the scheduler and run until one of two
 events transpires: blocked, delegated.
</p></div>
<pre>0058:    <a href="/$src/lib/std/felix/sync.flx#0058">fun get_scheduler_state : scheduler -> fstate_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> get the exit state of the scheduler after running.
</p></div>
<pre>0065:    <a href="/$src/lib/std/felix/sync.flx#0065">proc run_proc (p: 1->0)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Run a single procedure as a fibre on
 new scheduler. This scheduler acts like a subroutine,
 control doesn't return to the caller until the scheduler
 queue is empty. This call cannot handle async I/O,
 so any attempt to do it will cause the program to abort.
</p></div>
<hr/><a href="/$src/lib/std/filename.flx">filename.flx</a>

<pre>0002:  <a href="/$src/lib/std/filename.flx#0002">class Filename_class[os]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Operations on filenames.
</p></div>
<pre>0005:    <a href="/$src/lib/std/filename.flx#0005">virtual fun sep: 1 -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> The path separator.
</p></div>
<pre>0013:    <a href="/$src/lib/std/filename.flx#0013">fun split1(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> split1 returns a pair consisting of a directory name and basename
 with the separator between them lost except in the special case
 "/x" where the "/" is kept as the directory name.
 If there is no separator, the path is the basename and
 the directory name is the empty string (NOT . !!!)
</p></div>
<pre>0030:    <a href="/$src/lib/std/filename.flx#0030">fun split(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> split a filename into a list of components.
</p></div>
<pre>0039:    <a href="/$src/lib/std/filename.flx#0039">fun join(p:string, b:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join two pathnames into a single pathname.
 split and join are inverses, however join is not
 not associative: join("x", join("","y")) = "x/y"
 whereas join(join("x",""),"y") = "x//y"
 since split pulls components off from the RHS we have to
 fold them back from the left
</p></div>
<pre>0047:    <a href="/$src/lib/std/filename.flx#0047">fun basename(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the basename of a path (last component).
</p></div>
<pre>0050:    <a href="/$src/lib/std/filename.flx#0050">fun dirname(s:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the directory name of a path (all but the last component).
</p></div>
<pre>0054:    <a href="/$src/lib/std/filename.flx#0054">fun directories (s:string) : list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Return a list of all the directory names in a path.
 For example a/b/c gives "a", "a/b"
</p></div>
<pre>0062:    <a href="/$src/lib/std/filename.flx#0062">fun join(a:string, b:string, c:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join 3 strings into a pathname.
</p></div>
<pre>0065:    <a href="/$src/lib/std/filename.flx#0065">fun join(x:string) (y:string)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join 2 strings into a pathname (curried form).
</p></div>
<pre>0068:    <a href="/$src/lib/std/filename.flx#0068">fun join(ps: List::list[string])</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Join all the strings in a list into a pathname.
</p></div>
<pre>0074:    <a href="/$src/lib/std/filename.flx#0074">fun strip_extension (s:string): string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Remove an extension from a filename if there is one.
 Works backwards until it hits a dot, path separator,
 or end of data. If a dot, strip it and the tail of the string,
 otherwise return the original string.
</p></div>

<pre>0085:  <a href="/$src/lib/std/filename.flx#0085">class Win32Filename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Windows Filenames
</p></div>
<pre>0089:    <a href="/$src/lib/std/filename.flx#0089">fun sep()</a></pre>

<pre>0094:  <a href="/$src/lib/std/filename.flx#0094">class PosixFilename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Posix Filenames
</p></div>
<pre>0098:    <a href="/$src/lib/std/filename.flx#0098">fun sep()</a></pre>

<pre>0103:  <a href="/$src/lib/std/filename.flx#0103">class Filename</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Host Filenames.
</p></div>
<hr/><a href="/$src/lib/std/filestat.flx">filestat.flx</a>

<pre>0003:  <a href="/$src/lib/std/filestat.flx#0003">class FileStat_class[OS,stat_t, mode_t]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Filesystem file kind query functions parametrised
 by operating system, status type and mode type.
</p></div>
<pre>0007:    <a href="/$src/lib/std/filestat.flx#0007">virtual proc stat: string * &stat_t * &int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get information about a file into a status buffer.
 Sets error code at argument 3 pointer.
</p></div>
<pre>0012:    <a href="/$src/lib/std/filestat.flx#0012">virtual proc utime: string * double * double * &int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> set access and modification time of a file.
 Sets error code at argument 4 pointer.
 Times are in seconds, nominally from Epoch (Jan 1 1970).
</p></div>
<pre>0018:    <a href="/$src/lib/std/filestat.flx#0018">virtual gen chmod: string * mode_t -> int</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Change read,write permissions for group, owner etc.
 Return 0 on success.
 On Windows this function may silently fail to obey
 unsupported operations.
</p></div>
<pre>0023:    <a href="/$src/lib/std/filestat.flx#0023">virtual gen umask: mode_t -> mode_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> set mask for subsequent permissions.
 On Windows this function may silently fail to obey
 unsupported operations.
</p></div>
<pre>0026:    <a href="/$src/lib/std/filestat.flx#0026">union file_type_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Abstracted platform independent file type taxonomy.
</p></div>
<pre>0040:    <a href="/$src/lib/std/filestat.flx#0040">virtual fun file_type: &stat_t -> file_type_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the file type from a file stat buffer.
</p></div>
<pre>0043:    <a href="/$src/lib/std/filestat.flx#0043">gen stat(file: string, statbuf:&stat_t)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Fill a stat buffer with information about a file.
</p></div>
<pre>0051:    <a href="/$src/lib/std/filestat.flx#0051">fun mtime: &stat_t -> double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get a file last modification time from a stat buffer.
 Time is in seconds.
</p></div>
<pre>0056:    <a href="/$src/lib/std/filestat.flx#0056">fun ctime: &stat_t -> double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get a file creation time from a stat buffer.
 Note: not available on Unix.
 Time is in seconds.
</p></div>
<pre>0060:    <a href="/$src/lib/std/filestat.flx#0060">fun filetime(f:string):double</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get modification time of a file by name.
 Time is in seconds.
</p></div>
<pre>0069:    <a href="/$src/lib/std/filestat.flx#0069">gen utime(f:string, a:double, m:double): bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Set the last access and modification time of a file by name.
</p></div>
<pre>0077:    <a href="/$src/lib/std/filestat.flx#0077">gen utime(f:string, t:double)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Set the last access and modification time of a file by name,
 where the two times are given by a single argument.
</p></div>
<pre>0080:    <a href="/$src/lib/std/filestat.flx#0080">fun fileexists(f:string):bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if a file exists.
</p></div>
<pre>0083:    <a href="/$src/lib/std/filestat.flx#0083">fun filetype(f:string):file_type_t</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find the type of a file.
</p></div>

<pre>0100:  <a href="/$src/lib/std/filestat.flx#0100">class FileStat</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Platform dependent operations for host file system.
</p></div>
<hr/><a href="/$src/lib/std/filesystem.flx">filesystem.flx</a>

<pre>0003:  <a href="/$src/lib/std/filesystem.flx#0003">class FileSystem_class[os]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Filesystem operations parametrised by operating system.
 YET TO BE DONE.
</p></div>

<pre>0008:  <a href="/$src/lib/std/filesystem.flx#0008">class FileSystem</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Platform dependent filesystem operations for host file system.
</p></div>
<pre>0016:    <a href="/$src/lib/std/filesystem.flx#0016">fun find_in_path(x:string, path:list[string]):opt[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find a file in a list of directories.
</p></div>
<pre>0038:    <a href="/$src/lib/std/filesystem.flx#0038">fun regfilesin(dname:string, re:string): list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find all the files matching an RE2-regular expression
 in a given directory. 
 NOTE: this search finds files in descendant directories too.
 The search is recursive, but the whole pathname within
 the specified directory must match the regexp.
 For example to find all *.flx files in src use:
   regfilesin("src", ".*[.]flx")
 To find the files only in the given directory, on Unix use instead
   regfilesin("src", "[^/]*[.]flx")
 to exclude files in child directories.
</p></div>
<pre>0041:    <a href="/$src/lib/std/filesystem.flx#0041">fun regfilesin(dname:string, re:RE2): list[string]</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Find all the files matching a compiled RE2-regular expression.
</p></div>
<pre>0045:    <a href="/$src/lib/std/filesystem.flx#0045">proc rfi(dname2: string)</a></pre>
<hr/><a href="/$src/lib/std/float_format.flx">float_format.flx</a>

<pre>0002:  <a href="/$src/lib/std/float_format.flx#0002">open class float_format</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Functions to format floating point numbers.
</p></div>
<pre>0008:    <a href="/$src/lib/std/float_format.flx#0008">union mode</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Style of formatting.
 default (w,d)    : like C "w.dG" format
 fixed (w,d)      : like C "w.dF" format
 scientific (w,d) : like C "w.dE" format
</p></div>
<pre>0015:    <a href="/$src/lib/std/float_format.flx#0015">fun fmt[t in reals] (v:t, m: mode)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format a real number v with format m.
</p></div>
<pre>0025:    <a href="/$src/lib/std/float_format.flx#0025">fun fmt[t,r with Complex[t,r]] (v:t, m: mode)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format a complex number v in x + iy form,
 with format m for x and y.
</p></div>
<pre>0034:    <a href="/$src/lib/std/float_format.flx#0034">fun fmt_default[t] : t * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format default.
</p></div>
<pre>0037:    <a href="/$src/lib/std/float_format.flx#0037">fun fmt_fixed[t] : t * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format fixed.
</p></div>
<pre>0040:    <a href="/$src/lib/std/float_format.flx#0040">fun fmt_scientific[t] : t * int * int -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Format scientfic.
</p></div>
<pre>0044:    <a href="/$src/lib/std/float_format.flx#0044">fun xstr: float -> string</a></pre>
<pre>0047:    <a href="/$src/lib/std/float_format.flx#0047">fun str(x:float):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Default format float, also supports nan, +inf, -inf.
</p></div>
<pre>0057:    <a href="/$src/lib/std/float_format.flx#0057">fun xstr: double -> string</a></pre>
<pre>0060:    <a href="/$src/lib/std/float_format.flx#0060">fun str(x:double):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Default format double, also supports nan, +inf, -inf.
</p></div>
<pre>0070:    <a href="/$src/lib/std/float_format.flx#0070">fun xstr: ldouble -> string</a></pre>
<pre>0073:    <a href="/$src/lib/std/float_format.flx#0073">fun str(x:ldouble):string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Default format long double, also supports nan, +inf, -inf.
</p></div>
<hr/><a href="/$src/lib/std/float_math.flx">float_math.flx</a>

<pre>0006:  <a href="/$src/lib/std/float_math.flx#0006">open class Fcomplex</a></pre>
<pre>0011:    <a href="/$src/lib/std/float_math.flx#0011">fun str (z:fcomplex)</a></pre>

<pre>0015:  <a href="/$src/lib/std/float_math.flx#0015">open class Dcomplex</a></pre>
<pre>0020:    <a href="/$src/lib/std/float_math.flx#0020">fun str (z:dcomplex)</a></pre>

<pre>0024:  <a href="/$src/lib/std/float_math.flx#0024">open class Lcomplex</a></pre>
<pre>0029:    <a href="/$src/lib/std/float_math.flx#0029">fun str (z:lcomplex)</a></pre>
<pre>0034:    <a href="/$src/lib/std/float_math.flx#0034">fun real : complex[t] -> t</a></pre>
<pre>0035:    <a href="/$src/lib/std/float_math.flx#0035">fun imag : complex[t] -> t</a></pre>
<pre>0036:    <a href="/$src/lib/std/float_math.flx#0036">fun abs: complex[t] -> t</a></pre>
<pre>0037:    <a href="/$src/lib/std/float_math.flx#0037">fun arg : complex[t] -> t</a></pre>
<pre>0051:    <a href="/$src/lib/std/float_math.flx#0051">fun zero: 1 -> complex[t]</a></pre>
<pre>0052:    <a href="/$src/lib/std/float_math.flx#0052">fun one: 1 -> complex[t]</a></pre>
<pre>0057:    <a href="/$src/lib/std/float_math.flx#0057">fun sin: t -> t</a></pre>
<pre>0058:    <a href="/$src/lib/std/float_math.flx#0058">fun cos: t -> t</a></pre>
<pre>0059:    <a href="/$src/lib/std/float_math.flx#0059">fun tan: t -> t</a></pre>
<pre>0060:    <a href="/$src/lib/std/float_math.flx#0060">fun asin: t -> t</a></pre>
<pre>0061:    <a href="/$src/lib/std/float_math.flx#0061">fun acos: t -> t</a></pre>
<pre>0062:    <a href="/$src/lib/std/float_math.flx#0062">fun atan: t -> t</a></pre>
<pre>0063:    <a href="/$src/lib/std/float_math.flx#0063">fun sinh: t -> t</a></pre>
<pre>0064:    <a href="/$src/lib/std/float_math.flx#0064">fun cosh: t -> t</a></pre>
<pre>0065:    <a href="/$src/lib/std/float_math.flx#0065">fun tanh: t -> t</a></pre>
<pre>0066:    <a href="/$src/lib/std/float_math.flx#0066">fun asinh: t -> t</a></pre>
<pre>0067:    <a href="/$src/lib/std/float_math.flx#0067">fun acosh: t -> t</a></pre>
<pre>0068:    <a href="/$src/lib/std/float_math.flx#0068">fun atanh: t -> t</a></pre>
<pre>0069:    <a href="/$src/lib/std/float_math.flx#0069">fun exp: t -> t</a></pre>
<pre>0070:    <a href="/$src/lib/std/float_math.flx#0070">fun log: t -> t</a></pre>
<pre>0071:    <a href="/$src/lib/std/float_math.flx#0071">fun pow: t * t -> t</a></pre>
<pre>0076:    <a href="/$src/lib/std/float_math.flx#0076">fun abs: t -> t</a></pre>
<pre>0077:    <a href="/$src/lib/std/float_math.flx#0077">fun log10: t -> t</a></pre>
<pre>0078:    <a href="/$src/lib/std/float_math.flx#0078">fun sqrt: t -> t</a></pre>
<pre>0079:    <a href="/$src/lib/std/float_math.flx#0079">fun ceil: t -> t</a></pre>
<pre>0080:    <a href="/$src/lib/std/float_math.flx#0080">fun floor: t -> t</a></pre>
<pre>0081:    <a href="/$src/lib/std/float_math.flx#0081">fun trunc: t -> t</a></pre>
<pre>0082:    <a href="/$src/lib/std/float_math.flx#0082">fun embed: int -> t</a></pre>

<pre>0085:  <a href="/$src/lib/std/float_math.flx#0085">class CartComplex[r]</a></pre>
<pre>0086:    <a href="/$src/lib/std/float_math.flx#0086">typedef t</a></pre>
<pre>0090:    <a href="/$src/lib/std/float_math.flx#0090">typedef complex[t in floats]</a></pre>
<pre>0097:    <a href="/$src/lib/std/float_math.flx#0097">ctor complex[float] (x:float, y:float)</a></pre>
<pre>0098:    <a href="/$src/lib/std/float_math.flx#0098">ctor complex[double] (x:double, y:double)</a></pre>
<pre>0099:    <a href="/$src/lib/std/float_math.flx#0099">ctor complex[ldouble] (x:ldouble, y:ldouble)</a></pre>
<pre>0101:    <a href="/$src/lib/std/float_math.flx#0101">ctor complex[float] (x:float)</a></pre>
<pre>0102:    <a href="/$src/lib/std/float_math.flx#0102">ctor complex[double] (x:double)</a></pre>
<pre>0103:    <a href="/$src/lib/std/float_math.flx#0103">ctor complex[ldouble] (x:ldouble)</a></pre>
<pre>0105:    <a href="/$src/lib/std/float_math.flx#0105">typedef polar[t in floats]</a></pre>
<hr/><a href="/$src/lib/std/flx_ctypes.flx">flx_ctypes.flx</a>
<hr/><a href="/$src/lib/std/flx_tclass.flx">flx_tclass.flx</a>
<pre>0003:    <a href="/$src/lib/std/flx_tclass.flx#0003">typedef void</a></pre>
<pre>0004:    <a href="/$src/lib/std/flx_tclass.flx#0004">typedef unit</a></pre>
<pre>0005:    <a href="/$src/lib/std/flx_tclass.flx#0005">typedef bool</a></pre>

<pre>0009:  <a href="/$src/lib/std/flx_tclass.flx#0009">class IStream[f,t]</a></pre>
<pre>0010:    <a href="/$src/lib/std/flx_tclass.flx#0010">virtual gen read: f -> t</a></pre>

<pre>0013:  <a href="/$src/lib/std/flx_tclass.flx#0013">class OStream[f,t]</a></pre>
<pre>0014:    <a href="/$src/lib/std/flx_tclass.flx#0014">virtual proc write: f * t</a></pre>

<pre>0017:  <a href="/$src/lib/std/flx_tclass.flx#0017">class IOStream[f,t]</a></pre>

<pre>0024:  <a href="/$src/lib/std/flx_tclass.flx#0024">class IFile[f,t]</a></pre>

<pre>0028:  <a href="/$src/lib/std/flx_tclass.flx#0028">class OFile[f,t]</a></pre>
<pre>0030:    <a href="/$src/lib/std/flx_tclass.flx#0030">virtual proc close: f</a></pre>

<pre>0035:  <a href="/$src/lib/std/flx_tclass.flx#0035">class IBuffer [f]</a></pre>
<pre>0036:    <a href="/$src/lib/std/flx_tclass.flx#0036">virtual gen read: f -> address * int -> int * bool</a></pre>

<pre>0039:  <a href="/$src/lib/std/flx_tclass.flx#0039">class OBuffer [f]</a></pre>
<pre>0040:    <a href="/$src/lib/std/flx_tclass.flx#0040">virtual gen write : f -> address * int -> int * bool</a></pre>

<pre>0050:  <a href="/$src/lib/std/flx_tclass.flx#0050">class Set[c,t]</a></pre>
<pre>0051:    <a href="/$src/lib/std/flx_tclass.flx#0051">fun mem (elt:t, container:c):bool</a></pre>

<pre>0056:  <a href="/$src/lib/std/flx_tclass.flx#0056">class Container [c,v]</a></pre>
<pre>0059:    <a href="/$src/lib/std/flx_tclass.flx#0059">virtual fun len: c -> size</a></pre>
<pre>0060:    <a href="/$src/lib/std/flx_tclass.flx#0060">virtual fun empty(x: c): bool</a></pre>

<pre>0065:  <a href="/$src/lib/std/flx_tclass.flx#0065">class Monad [M: TYPE->TYPE]</a></pre>
<pre>0066:    <a href="/$src/lib/std/flx_tclass.flx#0066">virtual fun bind[a,b]: M a * (a -> M b) -> M b</a></pre>
<pre>0067:    <a href="/$src/lib/std/flx_tclass.flx#0067">virtual fun ret[a]: a -> M a</a></pre>

<pre>0072:  <a href="/$src/lib/std/flx_tclass.flx#0072">class Str [T]</a></pre>
<pre>0073:    <a href="/$src/lib/std/flx_tclass.flx#0073">virtual fun str: T -> string</a></pre>

<pre>0076:  <a href="/$src/lib/std/flx_tclass.flx#0076">class Repr [T with Str[T]]</a></pre>
<pre>0077:    <a href="/$src/lib/std/flx_tclass.flx#0077">virtual fun repr (t:T) : string</a></pre>

<pre>0080:  <a href="/$src/lib/std/flx_tclass.flx#0080">class Show [T]</a></pre>
<pre>0088:    <a href="/$src/lib/std/flx_tclass.flx#0088">fun str (x:void)</a></pre>
<pre>0095:    <a href="/$src/lib/std/flx_tclass.flx#0095">fun str (x:unit)</a></pre>
<hr/><a href="/$src/lib/std/gc.flx">gc.flx</a>

<pre>0004:  <a href="/$src/lib/std/gc.flx#0004">open class Gc</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Generic garbage collector interface.
 This class provides a generic interface to the GC,
 that is, one that is independent of the GC representation.
</p></div>
<pre>0007:    <a href="/$src/lib/std/gc.flx#0007">proc collect()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Invoke the garbage collector.
</p></div>
<pre>0010:    <a href="/$src/lib/std/gc.flx#0010">fun gc_get_allocation_amt : unit -> ulong</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the total number of bytes currently allocated.
</p></div>
<pre>0014:    <a href="/$src/lib/std/gc.flx#0014">fun gc_get_allocation_count : unit -> ulong</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the total number of objects currently allocated.
</p></div>
<pre>0018:    <a href="/$src/lib/std/gc.flx#0018">fun gc_get_root_count : unit -> ulong</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Get the total number of roots.
</p></div>
<hr/><a href="/$src/lib/std/glob.flx">glob.flx</a>

<pre>0007:  <a href="/$src/lib/std/glob.flx#0007">class glob</a></pre>
<pre>0018:    <a href="/$src/lib/std/glob.flx#0018">gen glob: string * &glob_t -> bool</a></pre>
<pre>0019:    <a href="/$src/lib/std/glob.flx#0019">proc globfree: &glob_t</a></pre>
<pre>0021:    <a href="/$src/lib/std/glob.flx#0021">gen glob (pat:string): stl_vector[string]</a></pre>
<hr/><a href="/$src/lib/std/int.flx">int.flx</a>
<pre>0001:    <a href="/$src/lib/std/int.flx#0001">typedef fun integral_promotion: TYPE -> TYPE</a></pre>

<pre>0014:  <a href="/$src/lib/std/int.flx#0014">open class Tiny</a></pre>
<pre>0016:    <a href="/$src/lib/std/int.flx#0016">ctor tiny: string</a></pre>

<pre>0020:  <a href="/$src/lib/std/int.flx#0020">open class Short</a></pre>
<pre>0022:    <a href="/$src/lib/std/int.flx#0022">ctor short: string</a></pre>

<pre>0026:  <a href="/$src/lib/std/int.flx#0026">open class Int</a></pre>
<pre>0028:    <a href="/$src/lib/std/int.flx#0028">ctor int: string</a></pre>
<pre>0031:    <a href="/$src/lib/std/int.flx#0031">ctor int(x:bool)</a></pre>

<pre>0034:  <a href="/$src/lib/std/int.flx#0034">open class Long</a></pre>
<pre>0036:    <a href="/$src/lib/std/int.flx#0036">ctor long: string</a></pre>

<pre>0040:  <a href="/$src/lib/std/int.flx#0040">open class Vlong</a></pre>
<pre>0042:    <a href="/$src/lib/std/int.flx#0042">ctor vlong: string</a></pre>

<pre>0046:  <a href="/$src/lib/std/int.flx#0046">open class Utiny</a></pre>
<pre>0048:    <a href="/$src/lib/std/int.flx#0048">ctor utiny: string</a></pre>

<pre>0052:  <a href="/$src/lib/std/int.flx#0052">open class Ushort</a></pre>
<pre>0054:    <a href="/$src/lib/std/int.flx#0054">ctor ushort: string</a></pre>

<pre>0058:  <a href="/$src/lib/std/int.flx#0058">open class Uint</a></pre>
<pre>0060:    <a href="/$src/lib/std/int.flx#0060">ctor uint: string</a></pre>

<pre>0064:  <a href="/$src/lib/std/int.flx#0064">open class Ulong</a></pre>
<pre>0066:    <a href="/$src/lib/std/int.flx#0066">ctor ulong: string</a></pre>

<pre>0070:  <a href="/$src/lib/std/int.flx#0070">open class Uvlong</a></pre>
<pre>0072:    <a href="/$src/lib/std/int.flx#0072">ctor uvlong: string</a></pre>

<pre>0076:  <a href="/$src/lib/std/int.flx#0076">open class Int8</a></pre>
<pre>0078:    <a href="/$src/lib/std/int.flx#0078">ctor int8: string</a></pre>

<pre>0082:  <a href="/$src/lib/std/int.flx#0082">open class Int16</a></pre>
<pre>0084:    <a href="/$src/lib/std/int.flx#0084">ctor int16: string</a></pre>

<pre>0088:  <a href="/$src/lib/std/int.flx#0088">open class Int32</a></pre>
<pre>0090:    <a href="/$src/lib/std/int.flx#0090">ctor int32: string</a></pre>

<pre>0094:  <a href="/$src/lib/std/int.flx#0094">open class Int64</a></pre>
<pre>0096:    <a href="/$src/lib/std/int.flx#0096">ctor int64: string</a></pre>

<pre>0100:  <a href="/$src/lib/std/int.flx#0100">open class Uint8</a></pre>
<pre>0102:    <a href="/$src/lib/std/int.flx#0102">ctor uint8: string</a></pre>

<pre>0106:  <a href="/$src/lib/std/int.flx#0106">open class Uint16</a></pre>
<pre>0108:    <a href="/$src/lib/std/int.flx#0108">ctor uint16: string</a></pre>

<pre>0112:  <a href="/$src/lib/std/int.flx#0112">open class Uint32</a></pre>
<pre>0114:    <a href="/$src/lib/std/int.flx#0114">ctor uint32: string</a></pre>

<pre>0118:  <a href="/$src/lib/std/int.flx#0118">open class Uint64</a></pre>
<pre>0120:    <a href="/$src/lib/std/int.flx#0120">ctor uint64: string</a></pre>

<pre>0124:  <a href="/$src/lib/std/int.flx#0124">open class Ssize</a></pre>
<pre>0126:    <a href="/$src/lib/std/int.flx#0126">ctor ssize: string</a></pre>

<pre>0130:  <a href="/$src/lib/std/int.flx#0130">open class Size</a></pre>
<pre>0132:    <a href="/$src/lib/std/int.flx#0132">ctor size: string</a></pre>

<pre>0140:  <a href="/$src/lib/std/int.flx#0140">open class Offset</a></pre>
<pre>0142:    <a href="/$src/lib/std/int.flx#0142">ctor offset: string</a></pre>

<pre>0146:  <a href="/$src/lib/std/int.flx#0146">open class Ptrdiff</a></pre>
<pre>0148:    <a href="/$src/lib/std/int.flx#0148">ctor ptrdiff: string</a></pre>

<pre>0152:  <a href="/$src/lib/std/int.flx#0152">open class Intptr</a></pre>
<pre>0154:    <a href="/$src/lib/std/int.flx#0154">ctor intptr: string</a></pre>

<pre>0158:  <a href="/$src/lib/std/int.flx#0158">open class Uintptr</a></pre>
<pre>0160:    <a href="/$src/lib/std/int.flx#0160">ctor uintptr: string</a></pre>

<pre>0164:  <a href="/$src/lib/std/int.flx#0164">open class Intmax</a></pre>
<pre>0166:    <a href="/$src/lib/std/int.flx#0166">ctor intmax: string</a></pre>

<pre>0170:  <a href="/$src/lib/std/int.flx#0170">open class Uintmax</a></pre>
<pre>0172:    <a href="/$src/lib/std/int.flx#0172">ctor uintmax: string</a></pre>
<pre>0178:    <a href="/$src/lib/std/int.flx#0178">fun str: tiny -> string</a></pre>
<pre>0182:    <a href="/$src/lib/std/int.flx#0182">fun str: utiny -> string</a></pre>
<pre>0193:    <a href="/$src/lib/std/int.flx#0193">fun str: T -> string</a></pre>
<pre>0242:    <a href="/$src/lib/std/int.flx#0242">fun succ: t -> t</a></pre>
<pre>0243:    <a href="/$src/lib/std/int.flx#0243">proc pre_incr: &t</a></pre>
<pre>0244:    <a href="/$src/lib/std/int.flx#0244">proc post_incr: &t</a></pre>
<pre>0248:    <a href="/$src/lib/std/int.flx#0248">fun pred: t -> t</a></pre>
<pre>0249:    <a href="/$src/lib/std/int.flx#0249">proc pre_decr: &t</a></pre>
<pre>0250:    <a href="/$src/lib/std/int.flx#0250">proc post_decr: &t</a></pre>
<pre>0259:    <a href="/$src/lib/std/int.flx#0259">fun sgn: t -> int</a></pre>
<pre>0260:    <a href="/$src/lib/std/int.flx#0260">fun abs: t -> t</a></pre>
<hr/><a href="/$src/lib/std/io/__init__.flx">io/__init__.flx</a>
<hr/><a href="/$src/lib/std/io/demux.flx">io/demux.flx</a>

<pre>0002:  <a href="/$src/lib/std/io/demux.flx#0002">class Demux</a></pre>
<pre>0004:    <a href="/$src/lib/std/io/demux.flx#0004">type demuxer</a></pre>
<pre>0007:    <a href="/$src/lib/std/io/demux.flx#0007">gen mk_sys_demux: 1->demuxer</a></pre>
<hr/><a href="/$src/lib/std/io/faio.flx">io/faio.flx</a>

<pre>0001:  <a href="/$src/lib/std/io/faio.flx#0001">class Faio</a></pre>
<pre>0007:    <a href="/$src/lib/std/io/faio.flx#0007">proc faio_req[t](x:&t)</a></pre>
<pre>0012:    <a href="/$src/lib/std/io/faio.flx#0012">proc get_thread(thread: &fthread)</a></pre>
<pre>0016:    <a href="/$src/lib/std/io/faio.flx#0016">type sel_param</a></pre>
<pre>0017:    <a href="/$src/lib/std/io/faio.flx#0017">type sel_param_ptr</a></pre>
<pre>0019:    <a href="/$src/lib/std/io/faio.flx#0019">fun get_bytes_done : sel_param_ptr -> int</a></pre>
<pre>0020:    <a href="/$src/lib/std/io/faio.flx#0020">proc init_pb : sel_param*address*int</a></pre>
<pre>0023:    <a href="/$src/lib/std/io/faio.flx#0023">proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)</a></pre>
<pre>0035:    <a href="/$src/lib/std/io/faio.flx#0035">type sleep_request</a></pre>
<pre>0036:    <a href="/$src/lib/std/io/faio.flx#0036">type alarm_clock</a></pre>
<pre>0038:    <a href="/$src/lib/std/io/faio.flx#0038">fun mk_alarm_clock: 1 -> alarm_clock</a></pre>
<pre>0039:    <a href="/$src/lib/std/io/faio.flx#0039">fun mk_sleep_request: alarm_clock * double -> sleep_request</a></pre>
<pre>0041:    <a href="/$src/lib/std/io/faio.flx#0041">proc sleep(clock: alarm_clock, delta: double)</a></pre>
<hr/><a href="/$src/lib/std/io/socket.flx">io/socket.flx</a>

<pre>0001:  <a href="/$src/lib/std/io/socket.flx#0001">class Socket</a></pre>
<pre>0005:    <a href="/$src/lib/std/io/socket.flx#0005">typedef socket_t</a></pre>
<pre>0007:    <a href="/$src/lib/std/io/socket.flx#0007">typedef socket_t</a></pre>
<pre>0010:    <a href="/$src/lib/std/io/socket.flx#0010">proc mk_listener(l: &socket_t, port: &int, qlen: int)</a></pre>
<pre>0019:    <a href="/$src/lib/std/io/socket.flx#0019">proc accept(l: socket_t, s: &socket_t)</a></pre>
<pre>0033:    <a href="/$src/lib/std/io/socket.flx#0033">proc shutdown(s: socket_t, how: int)</a></pre>
<pre>0042:    <a href="/$src/lib/std/io/socket.flx#0042">proc connect(s: &socket_t, addr: +char, port: int)</a></pre>
<pre>0058:    <a href="/$src/lib/std/io/socket.flx#0058">proc read(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0061:    <a href="/$src/lib/std/io/socket.flx#0061">proc read(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0069:    <a href="/$src/lib/std/io/socket.flx#0069">proc write(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0076:    <a href="/$src/lib/std/io/socket.flx#0076">proc write(s: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0086:    <a href="/$src/lib/std/io/socket.flx#0086">proc iclose (s:socket_t)</a></pre>
<pre>0089:    <a href="/$src/lib/std/io/socket.flx#0089">proc iclose (s:socket_t)</a></pre>
<pre>0097:    <a href="/$src/lib/std/io/socket.flx#0097">proc oclose (s:socket_t)</a></pre>
<pre>0100:    <a href="/$src/lib/std/io/socket.flx#0100">proc oclose (s:socket_t)</a></pre>
<pre>0108:    <a href="/$src/lib/std/io/socket.flx#0108">proc ioclose (s:socket_t)</a></pre>
<pre>0124:    <a href="/$src/lib/std/io/socket.flx#0124">proc ioclose (s:socket_t)</a></pre>
<hr/><a href="/$src/lib/std/io/stream.flx">io/stream.flx</a>

<pre>0001:  <a href="/$src/lib/std/io/stream.flx#0001">class Stream</a></pre>
<pre>0009:    <a href="/$src/lib/std/io/stream.flx#0009">typedef fd_t</a></pre>
<pre>0012:    <a href="/$src/lib/std/io/stream.flx#0012">typedef fd_t</a></pre>

<pre>0018:  <a href="/$src/lib/std/io/stream.flx#0018">class IByteStream[T]</a></pre>

<pre>0024:  <a href="/$src/lib/std/io/stream.flx#0024">class OByteStream[T]</a></pre>

<pre>0030:  <a href="/$src/lib/std/io/stream.flx#0030">class IOByteStream[T]</a></pre>

<pre>0036:  <a href="/$src/lib/std/io/stream.flx#0036">class TerminalIByteStream[T]</a></pre>

<pre>0044:  <a href="/$src/lib/std/io/stream.flx#0044">class TerminalOByteStream[T]</a></pre>

<pre>0052:  <a href="/$src/lib/std/io/stream.flx#0052">class TerminalIOByteStream[T]</a></pre>
<pre>0062:    <a href="/$src/lib/std/io/stream.flx#0062">union devnull_t</a></pre>
<pre>0067:    <a href="/$src/lib/std/io/stream.flx#0067">proc read(strm: devnull_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0075:    <a href="/$src/lib/std/io/stream.flx#0075">proc write(strm: devnull_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0090:    <a href="/$src/lib/std/io/stream.flx#0090">proc read(fd: fd_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0101:    <a href="/$src/lib/std/io/stream.flx#0101">proc write(fd: fd_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0114:    <a href="/$src/lib/std/io/stream.flx#0114">proc iclose (fd: fd_t)</a></pre>
<pre>0125:    <a href="/$src/lib/std/io/stream.flx#0125">proc oclose (fd: fd_t)</a></pre>
<pre>0136:    <a href="/$src/lib/std/io/stream.flx#0136">proc ioclose (fd: fd_t)</a></pre>
<pre>0148:    <a href="/$src/lib/std/io/stream.flx#0148">proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0167:    <a href="/$src/lib/std/io/stream.flx#0167">proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0181:    <a href="/$src/lib/std/io/stream.flx#0181">proc cat[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0193:    <a href="/$src/lib/std/io/stream.flx#0193">proc stream_cmp[istr1,istr2 with IByteStream[istr1], IByteStream[istr2]] (</a></pre>
<pre>0240:    <a href="/$src/lib/std/io/stream.flx#0240">proc cmp[istr1, istr2 with IByteStream[istr1], IByteStream[istr2]] (</a></pre>
<pre>0254:    <a href="/$src/lib/std/io/stream.flx#0254">proc echo[iostr with IOByteStream[iostr]] (</a></pre>
<pre>0264:    <a href="/$src/lib/std/io/stream.flx#0264">proc tee[istr,ostr with IByteStream[istr], OByteStream[ostr]] (</a></pre>
<pre>0289:    <a href="/$src/lib/std/io/stream.flx#0289">noinline proc get_line[istr with IByteStream[istr]] (</a></pre>
<pre>0313:    <a href="/$src/lib/std/io/stream.flx#0313">proc write_string[ostr with OByteStream[ostr]] (</a></pre>
<hr/><a href="/$src/lib/std/io/textio.flx">io/textio.flx</a>

<pre>0007:  <a href="/$src/lib/std/io/textio.flx#0007">class Input_text_file[input_text_file]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> These classes provide simple I/O for text, primarily intended for
 naive use, debugging etc. This is because there is no error
 handling. This simplifies usage at the expense of correctness,
 and so these routines should not be used in production code.
 Abstract input file.
</p></div>
<pre>0010:    <a href="/$src/lib/std/io/textio.flx#0010">virtual gen fopen_input: string -> input_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Open file for reading.
</p></div>
<pre>0013:    <a href="/$src/lib/std/io/textio.flx#0013">virtual gen valid : input_text_file -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if the file was opened correctly.
</p></div>
<pre>0016:    <a href="/$src/lib/std/io/textio.flx#0016">virtual proc fclose: input_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Close file.
</p></div>
<pre>0019:    <a href="/$src/lib/std/io/textio.flx#0019">virtual gen load: input_text_file -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Load the rest of an open file.
</p></div>
<pre>0023:    <a href="/$src/lib/std/io/textio.flx#0023">virtual gen readln: input_text_file -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Read one line with the trailing end-line mark included.
 Empty string indicates end of file.
</p></div>
<pre>0026:    <a href="/$src/lib/std/io/textio.flx#0026">virtual gen feof : input_text_file -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check for end of file.
</p></div>

<pre>0030:  <a href="/$src/lib/std/io/textio.flx#0030">class Output_text_file[output_text_file]</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Abstract output file.
</p></div>
<pre>0033:    <a href="/$src/lib/std/io/textio.flx#0033">virtual gen fopen_output: string -> output_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Open file for writing.
</p></div>
<pre>0036:    <a href="/$src/lib/std/io/textio.flx#0036">virtual gen valid : output_text_file -> bool</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Check if the file was opened correctly.
</p></div>
<pre>0039:    <a href="/$src/lib/std/io/textio.flx#0039">virtual proc fclose: output_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Close file.
</p></div>
<pre>0042:    <a href="/$src/lib/std/io/textio.flx#0042">virtual proc writeln : output_text_file * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write one line adding the trailing end line mark.
</p></div>
<pre>0045:    <a href="/$src/lib/std/io/textio.flx#0045">virtual proc write : output_text_file * string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a string.
</p></div>
<pre>0048:    <a href="/$src/lib/std/io/textio.flx#0048">virtual proc write : output_text_file * utiny</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a byte.
</p></div>
<pre>0051:    <a href="/$src/lib/std/io/textio.flx#0051">virtual proc write : output_text_file * char</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a char.
</p></div>
<pre>0054:    <a href="/$src/lib/std/io/textio.flx#0054">virtual proc fflush: output_text_file</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Flush the buffers.
</p></div>
<pre>0057:    <a href="/$src/lib/std/io/textio.flx#0057">proc space (s:output_text_file)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write a space.
</p></div>
<pre>0060:    <a href="/$src/lib/std/io/textio.flx#0060">proc endl (s:output_text_file)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write end of line mark.
</p></div>
<pre>0063:    <a href="/$src/lib/std/io/textio.flx#0063">proc fprint[T with Str[T]] (s:output_text_file, x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write data with conversion using Str::str.
</p></div>
<pre>0066:    <a href="/$src/lib/std/io/textio.flx#0066">proc fprintln[T with Str[T]] (s:output_text_file, x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write data with conversion using Str::str and end line mark.
</p></div>

<pre>0070:  <a href="/$src/lib/std/io/textio.flx#0070">open class Cstdio</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> C standard IO with FILE*.
</p></div>
<pre>0075:    <a href="/$src/lib/std/io/textio.flx#0075">pod type ifile</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C file type.
</p></div>
<pre>0076:    <a href="/$src/lib/std/io/textio.flx#0076">pod type ofile</a></pre>
<pre>0080:    <a href="/$src/lib/std/io/textio.flx#0080">fun load: string -> string</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Load file from filename.
 Note: loaded in binary mode not text mode!
</p></div>
<pre>0105:    <a href="/$src/lib/std/io/textio.flx#0105">gen fopen_input: string -> ifile</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Standard input, can be redirected by flx_run.
 Standard output, can be redirected by flx_run.
 Standard error, can be redirected by flx_run.
 Standard input, redirected by shell.
 Standard output, redirected by shell.
 Standard error, redirected by shell.
 C standard IO as instance of Input_text_file.
</p></div>
<pre>0106:    <a href="/$src/lib/std/io/textio.flx#0106">gen valid : ifile -> bool</a></pre>
<pre>0107:    <a href="/$src/lib/std/io/textio.flx#0107">proc fclose: ifile</a></pre>
<pre>0108:    <a href="/$src/lib/std/io/textio.flx#0108">gen load: ifile -> string</a></pre>
<pre>0109:    <a href="/$src/lib/std/io/textio.flx#0109">gen readln: ifile -> string</a></pre>
<pre>0110:    <a href="/$src/lib/std/io/textio.flx#0110">gen feof : ifile -> bool</a></pre>
<pre>0116:    <a href="/$src/lib/std/io/textio.flx#0116">gen fopen_output: string -> ofile</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C standard IO as instance of Output_text_file.
</p></div>
<pre>0117:    <a href="/$src/lib/std/io/textio.flx#0117">gen valid : ofile -> bool</a></pre>
<pre>0118:    <a href="/$src/lib/std/io/textio.flx#0118">proc fclose: ofile</a></pre>
<pre>0119:    <a href="/$src/lib/std/io/textio.flx#0119">proc writeln : ofile * string</a></pre>
<pre>0120:    <a href="/$src/lib/std/io/textio.flx#0120">proc write : ofile * string</a></pre>
<pre>0121:    <a href="/$src/lib/std/io/textio.flx#0121">proc write : ofile * utiny</a></pre>
<pre>0122:    <a href="/$src/lib/std/io/textio.flx#0122">proc write : ofile * char</a></pre>
<pre>0123:    <a href="/$src/lib/std/io/textio.flx#0123">proc fflush: ofile</a></pre>

<pre>0131:  <a href="/$src/lib/std/io/textio.flx#0131">open class Iostream</a></pre>
<pre>0134:    <a href="/$src/lib/std/io/textio.flx#0134">pod type istream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> istream type.
</p></div>
<pre>0137:    <a href="/$src/lib/std/io/textio.flx#0137">pod type ostream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> ostream type.
</p></div>
<pre>0154:    <a href="/$src/lib/std/io/textio.flx#0154">gen fopen_input: string -> istream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Standard input, redirected by shell.
 Standard output, redirected by shell.
 Standard error, redirected by shell.
 Standard log, redirected by shell.
 C++ istream as instance of Input_text_file.
</p></div>
<pre>0155:    <a href="/$src/lib/std/io/textio.flx#0155">gen valid : istream -> bool</a></pre>
<pre>0156:    <a href="/$src/lib/std/io/textio.flx#0156">proc fclose: istream</a></pre>
<pre>0157:    <a href="/$src/lib/std/io/textio.flx#0157">gen load: istream -> string</a></pre>
<pre>0158:    <a href="/$src/lib/std/io/textio.flx#0158">gen readln: istream -> string</a></pre>
<pre>0159:    <a href="/$src/lib/std/io/textio.flx#0159">gen feof : istream -> bool</a></pre>
<pre>0165:    <a href="/$src/lib/std/io/textio.flx#0165">gen fopen_output: string -> ostream</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> C++ ostream as instance of Output_text_file.
</p></div>
<pre>0166:    <a href="/$src/lib/std/io/textio.flx#0166">gen valid : ostream -> bool</a></pre>
<pre>0167:    <a href="/$src/lib/std/io/textio.flx#0167">proc fclose: ostream</a></pre>
<pre>0168:    <a href="/$src/lib/std/io/textio.flx#0168">proc writeln : ostream * string</a></pre>
<pre>0169:    <a href="/$src/lib/std/io/textio.flx#0169">proc write : ostream * string</a></pre>
<pre>0170:    <a href="/$src/lib/std/io/textio.flx#0170">proc write : ostream * utiny</a></pre>
<pre>0171:    <a href="/$src/lib/std/io/textio.flx#0171">proc write : ostream * char</a></pre>
<pre>0172:    <a href="/$src/lib/std/io/textio.flx#0172">proc fflush: ostream</a></pre>
<pre>0181:    <a href="/$src/lib/std/io/textio.flx#0181">proc print  [T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to cout.
</p></div>
<pre>0184:    <a href="/$src/lib/std/io/textio.flx#0184">proc println[T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to cout with end of line.
</p></div>
<pre>0187:    <a href="/$src/lib/std/io/textio.flx#0187">proc endl()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write end of line on cout.
</p></div>
<pre>0190:    <a href="/$src/lib/std/io/textio.flx#0190">proc space()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write space on cout.
</p></div>
<pre>0193:    <a href="/$src/lib/std/io/textio.flx#0193">proc fflush()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> flush buffers of cout.
</p></div>
<pre>0196:    <a href="/$src/lib/std/io/textio.flx#0196">proc eprint  [T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to cerr.
</p></div>
<pre>0199:    <a href="/$src/lib/std/io/textio.flx#0199">proc eprintln[T with Str[T]] (x:T)</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write string to cerr with end of line.
</p></div>
<pre>0202:    <a href="/$src/lib/std/io/textio.flx#0202">proc eendl()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write end of line on cerr.
</p></div>
<pre>0205:    <a href="/$src/lib/std/io/textio.flx#0205">proc espace()</a></pre>
<div style='font-family:sans-serif; font-size:10pt; margin-left:100; margin-right:100; top:2; color:#404040; '><p> Write space on cerr.
</p></div>
<hr/><a href="/$src/lib/std/io/zmq.flx">io/zmq.flx</a>

<pre>0006:  <a href="/$src/lib/std/io/zmq.flx#0006">class ZeroMQ</a></pre>
<pre>0016:    <a href="/$src/lib/std/io/zmq.flx#0016">proc zmq_version: &int * &int * &int</a></pre>
<pre>0017:    <a href="/$src/lib/std/io/zmq.flx#0017">fun zmq_version()</a></pre>
<pre>0034:    <a href="/$src/lib/std/io/zmq.flx#0034">fun zmq_errno : 1-> errno_t</a></pre>
<pre>0035:    <a href="/$src/lib/std/io/zmq.flx#0035">fun zmq_strerror : errno_t -> string</a></pre>
<pre>0037:    <a href="/$src/lib/std/io/zmq.flx#0037">gen ewrap(var x:int)</a></pre>
<pre>0039:    <a href="/$src/lib/std/io/zmq.flx#0039">proc zmq_validate (msg:string) (var retcode: int)</a></pre>
<pre>0045:    <a href="/$src/lib/std/io/zmq.flx#0045">proc zmq_validate (var retcode: int)</a></pre>
<pre>0047:    <a href="/$src/lib/std/io/zmq.flx#0047">fun zmq_check (msg:string) (var retcode:int)</a></pre>
<pre>0054:    <a href="/$src/lib/std/io/zmq.flx#0054">fun zmq_check(var retcode: int)</a></pre>
<pre>0060:    <a href="/$src/lib/std/io/zmq.flx#0060">typedef zmq_free_fn</a></pre>
<pre>0066:    <a href="/$src/lib/std/io/zmq.flx#0066">gen make_zmq_msg_t : 1 -> zmq_msg_t</a></pre>
<pre>0069:    <a href="/$src/lib/std/io/zmq.flx#0069">gen zmq_msg_init: zmq_msg_t->int</a></pre>
<pre>0070:    <a href="/$src/lib/std/io/zmq.flx#0070">gen zmq_msg_init_size: zmq_msg_t * size -> int</a></pre>
<pre>0071:    <a href="/$src/lib/std/io/zmq.flx#0071">gen zmq_msg_init_data: zmq_msg_t * address * size * zmq_free_fn * address -> int</a></pre>
<pre>0072:    <a href="/$src/lib/std/io/zmq.flx#0072">gen zmq_msg_close: zmq_msg_t -> int</a></pre>
<pre>0074:    <a href="/$src/lib/std/io/zmq.flx#0074">gen zmq_msg_move: zmq_msg_t * zmq_msg_t -> int</a></pre>
<pre>0075:    <a href="/$src/lib/std/io/zmq.flx#0075">gen zmq_msg_copy: zmq_msg_t * zmq_msg_t -> int</a></pre>
<pre>0076:    <a href="/$src/lib/std/io/zmq.flx#0076">fun zmq_msg_data: zmq_msg_t -> address</a></pre>
<pre>0077:    <a href="/$src/lib/std/io/zmq.flx#0077">fun zmq_msg_size : zmq_msg_t -> size</a></pre>
<pre>0080:    <a href="/$src/lib/std/io/zmq.flx#0080">pod type zmq_message_option_code_t</a></pre>
<pre>0083:    <a href="/$src/lib/std/io/zmq.flx#0083">fun zmq_getmsgopt: zmq_msg_t * zmq_message_option_code_t * address * &size -> int</a></pre>
<pre>0089:    <a href="/$src/lib/std/io/zmq.flx#0089">pod type zmq_context</a></pre>
<pre>0092:    <a href="/$src/lib/std/io/zmq.flx#0092">gen zmq_init : int  -> zmq_context</a></pre>
<pre>0093:    <a href="/$src/lib/std/io/zmq.flx#0093">gen zmq_term : zmq_context -> int</a></pre>
<pre>0099:    <a href="/$src/lib/std/io/zmq.flx#0099">pod type zmq_socket</a></pre>
<pre>0101:    <a href="/$src/lib/std/io/zmq.flx#0101">ctor zmq_socket : zmq_context * zmq_socket_type_t</a></pre>
<pre>0102:    <a href="/$src/lib/std/io/zmq.flx#0102">gen zmq_close: zmq_socket -> int</a></pre>
<pre>0103:    <a href="/$src/lib/std/io/zmq.flx#0103">gen zmq_bind : zmq_socket * string -> int</a></pre>
<pre>0104:    <a href="/$src/lib/std/io/zmq.flx#0104">gen zmq_connect : zmq_socket * string -> int</a></pre>
<pre>0105:    <a href="/$src/lib/std/io/zmq.flx#0105">fun valid: zmq_socket->bool</a></pre>
<pre>0118:    <a href="/$src/lib/std/io/zmq.flx#0118">fun str: zmq_socket_type_t -> string</a></pre>
<pre>0148:    <a href="/$src/lib/std/io/zmq.flx#0148">fun str:zmq_sockopts_tag-> string</a></pre>
<pre>0176:    <a href="/$src/lib/std/io/zmq.flx#0176">union zmq_socket_options</a></pre>
<pre>0203:    <a href="/$src/lib/std/io/zmq.flx#0203">fun str: zmq_socket_options -> string</a></pre>
<pre>0249:    <a href="/$src/lib/std/io/zmq.flx#0249">gen set_sockopt(s: zmq_socket) (o: zmq_socket_options)</a></pre>
<pre>0275:    <a href="/$src/lib/std/io/zmq.flx#0275">proc get_sockopt[T:blobkind](s:zmq_socket, o:zmq_sockopts_tag, pd:&T, ps: &size)</a></pre>
<pre>0301:    <a href="/$src/lib/std/io/zmq.flx#0301">gen getsockopt(s: zmq_socket, o: zmq_sockopts_tag) : zmq_socket_options</a></pre>
<pre>0338:    <a href="/$src/lib/std/io/zmq.flx#0338">gen zmq_send : zmq_socket * address * size * zmq_xmit_options_t -> int</a></pre>
<pre>0339:    <a href="/$src/lib/std/io/zmq.flx#0339">gen zmq_recv : zmq_socket * address * size * zmq_xmit_options_t -> int</a></pre>
<pre>0340:    <a href="/$src/lib/std/io/zmq.flx#0340">gen zmq_sendmsg : zmq_socket * zmq_msg_t * zmq_xmit_options_t  -> int</a></pre>
<pre>0341:    <a href="/$src/lib/std/io/zmq.flx#0341">gen zmq_recvmsg : zmq_socket * zmq_msg_t * zmq_xmit_options_t -> int</a></pre>
<pre>0346:    <a href="/$src/lib/std/io/zmq.flx#0346">type zmq_pollitem_flag_t</a></pre>
<pre>0350:    <a href="/$src/lib/std/io/zmq.flx#0350">ctor short: zmq_pollitem_flag_t</a></pre>
<pre>0353:    <a href="/$src/lib/std/io/zmq.flx#0353">fun str(x:zmq_pollitem_flag_t)</a></pre>
<pre>0363:    <a href="/$src/lib/std/io/zmq.flx#0363">type zmq_poll_item</a></pre>
<pre>0364:    <a href="/$src/lib/std/io/zmq.flx#0364">ctor zmq_poll_item: zmq_socket * zmq_pollitem_flag_t</a></pre>
<pre>0365:    <a href="/$src/lib/std/io/zmq.flx#0365">fun revents: zmq_poll_item -> zmq_pollitem_flag_t</a></pre>
<pre>0367:    <a href="/$src/lib/std/io/zmq.flx#0367">gen zmq_poll: carray[zmq_poll_item] * int * long -> int</a></pre>
<pre>0369:    <a href="/$src/lib/std/io/zmq.flx#0369">gen zmq_poll(pits : varray[zmq_poll_item], t:double)</a></pre>

<pre>0380:  <a href="/$src/lib/std/io/zmq.flx#0380">class Checked_ZeroMQ[T]</a></pre>
<pre>0384:    <a href="/$src/lib/std/io/zmq.flx#0384">proc init_size (x:zmq_msg_t) (n:size)</a></pre>
<pre>0385:    <a href="/$src/lib/std/io/zmq.flx#0385">proc init (x:zmq_msg_t)</a></pre>
<pre>0386:    <a href="/$src/lib/std/io/zmq.flx#0386">proc close (x:zmq_msg_t)</a></pre>
<pre>0388:    <a href="/$src/lib/std/io/zmq.flx#0388">fun _ctor_zmq_msg_t ()</a></pre>
<pre>0390:    <a href="/$src/lib/std/io/zmq.flx#0390">proc init_string (x:zmq_msg_t) (s:string)</a></pre>
<pre>0397:    <a href="/$src/lib/std/io/zmq.flx#0397">ctor string: zmq_msg_t</a></pre>
<pre>0399:    <a href="/$src/lib/std/io/zmq.flx#0399">fun zmq_more(m:zmq_msg_t):bool</a></pre>
<pre>0408:    <a href="/$src/lib/std/io/zmq.flx#0408">fun zmq_more (s:zmq_socket)</a></pre>
<pre>0414:    <a href="/$src/lib/std/io/zmq.flx#0414">proc send_msg (s:zmq_socket) (m:zmq_msg_t)</a></pre>
<pre>0415:    <a href="/$src/lib/std/io/zmq.flx#0415">proc send_string (s:zmq_socket) (m:string)</a></pre>
<pre>0416:    <a href="/$src/lib/std/io/zmq.flx#0416">proc send_string_part (s:zmq_socket) (m:string)</a></pre>
<pre>0417:    <a href="/$src/lib/std/io/zmq.flx#0417">proc recv_msg (s:zmq_socket) (m:zmq_msg_t)</a></pre>
<pre>0418:    <a href="/$src/lib/std/io/zmq.flx#0418">proc recv_msg_dontwait (s:zmq_socket) (m:zmq_msg_t)</a></pre>
<pre>0419:    <a href="/$src/lib/std/io/zmq.flx#0419">gen recv_string (s:zmq_socket)</a></pre>
<pre>0428:    <a href="/$src/lib/std/io/zmq.flx#0428">gen recv_string_dontwait (s:zmq_socket)</a></pre>
<pre>0437:    <a href="/$src/lib/std/io/zmq.flx#0437">ctor zmq_context : int</a></pre>
<pre>0438:    <a href="/$src/lib/std/io/zmq.flx#0438">proc term (x:zmq_context)</a></pre>
<pre>0440:    <a href="/$src/lib/std/io/zmq.flx#0440">fun check_socket(var x:zmq_socket)</a></pre>
<pre>0441:    <a href="/$src/lib/std/io/zmq.flx#0441">gen mk_socket (c: zmq_context) (t:zmq_socket_type_t)</a></pre>
<pre>0442:    <a href="/$src/lib/std/io/zmq.flx#0442">proc set_opt(s: zmq_socket) (o: zmq_socket_options)</a></pre>
<pre>0443:    <a href="/$src/lib/std/io/zmq.flx#0443">fun get_opt(s: zmq_socket) (o: zmq_sockopts_tag) : zmq_socket_options</a></pre>
<pre>0445:    <a href="/$src/lib/std/io/zmq.flx#0445">proc bind(x:zmq_socket) (a:string)</a></pre>
<pre>0446:    <a href="/$src/lib/std/io/zmq.flx#0446">proc connect(x:zmq_socket) (a:string)</a></pre>
<pre>0447:    <a href="/$src/lib/std/io/zmq.flx#0447">proc close (s:zmq_socket)</a></pre>
<pre>0449:    <a href="/$src/lib/std/io/zmq.flx#0449">gen poll(pits:varray[zmq_poll_item], timeout:double)</a></pre>
<pre>0452:    <a href="/$src/lib/std/io/zmq.flx#0452">proc send_strings (s:zmq_socket) (ss:varray[string])</a></pre>
<pre>0462:    <a href="/$src/lib/std/io/zmq.flx#0462">proc send_strings (s:zmq_socket) (ss:list[string])</a></pre>
<pre>0466:    <a href="/$src/lib/std/io/zmq.flx#0466">gen recv_strings (s:zmq_socket) : varray[string]</a></pre>
<pre>0479:    <a href="/$src/lib/std/io/zmq.flx#0479">type zmq_ehandler_t</a></pre>
<pre>0482:    <a href="/$src/lib/std/io/zmq.flx#0482">fun ehandler():any</a></pre>

<pre>0489:  <a href="/$src/lib/std/io/zmq.flx#0489">class ZMQ</a></pre>
<hr/><a href="/$src/lib/std/linux/linux.flx">linux/linux.flx</a>
<pre>0004:    <a href="/$src/lib/std/linux/linux.flx#0004">fun get_cpu_nr: 1 -> int</a></pre>
<hr/><a href="/$src/lib/std/linux/smaps.flx">linux/smaps.flx</a>

<pre>0017:  <a href="/$src/lib/std/linux/smaps.flx#0017">class Smaps</a></pre>
<pre>0019:    <a href="/$src/lib/std/linux/smaps.flx#0019">struct smaps_metric</a></pre>
<pre>0036:    <a href="/$src/lib/std/linux/smaps.flx#0036">fun getpid: ()->Process::pid_t</a></pre>
<pre>0038:    <a href="/$src/lib/std/linux/smaps.flx#0038">fun pid_touint: Process::pid_t->uint</a></pre>
<pre>0040:    <a href="/$src/lib/std/linux/smaps.flx#0040">fun uint_topid: uint->Process::pid_t</a></pre>
<pre>0042:    <a href="/$src/lib/std/linux/smaps.flx#0042">fun min_whitespace(s:string)</a></pre>
<pre>0060:    <a href="/$src/lib/std/linux/smaps.flx#0060">fun smaps_total(p:Process::pid_t,path:string):smaps_metric</a></pre>
<hr/><a href="/$src/lib/std/mixedint.flx">mixedint.flx</a>

<pre>0002:  <a href="/$src/lib/std/mixedint.flx#0002">class MixedInt</a></pre>
<pre>0013:    <a href="/$src/lib/std/mixedint.flx#0013">fun shl [t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)</a></pre>
<pre>0014:    <a href="/$src/lib/std/mixedint.flx#0014">fun shr [t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)</a></pre>
<hr/><a href="/$src/lib/std/number.flx">number.flx</a>
<pre>0003:    <a href="/$src/lib/std/number.flx#0003">fun zero: unit -> t</a></pre>
<pre>0012:    <a href="/$src/lib/std/number.flx#0012">fun one: unit -> t</a></pre>
<hr/><a href="/$src/lib/std/order.flx">order.flx</a>

<pre>0003:  <a href="/$src/lib/std/order.flx#0003">class Eq[t]</a></pre>
<pre>0011:    <a href="/$src/lib/std/order.flx#0011">fun eq(x:t, y:t)</a></pre>
<pre>0012:    <a href="/$src/lib/std/order.flx#0012">fun ne(x:t, y:t)</a></pre>

<pre>0016:  <a href="/$src/lib/std/order.flx#0016">class Pord[t]</a></pre>

<pre>0028:  <a href="/$src/lib/std/order.flx#0028">class Tord[t]</a></pre>
<pre>0043:    <a href="/$src/lib/std/order.flx#0043">fun lt (x:t,y:t): bool</a></pre>
<pre>0044:    <a href="/$src/lib/std/order.flx#0044">fun gt(x:t,y:t):bool</a></pre>
<pre>0045:    <a href="/$src/lib/std/order.flx#0045">fun le (x:t,y:t):bool</a></pre>
<pre>0046:    <a href="/$src/lib/std/order.flx#0046">fun ge (x:t,y:t):bool</a></pre>
<pre>0047:    <a href="/$src/lib/std/order.flx#0047">fun max(x:t,y:t):t</a></pre>
<pre>0048:    <a href="/$src/lib/std/order.flx#0048">fun min(x:t,y:t):t</a></pre>

<pre>0052:  <a href="/$src/lib/std/order.flx#0052">class Forward[t]</a></pre>
<pre>0053:    <a href="/$src/lib/std/order.flx#0053">virtual fun succ: t -> t</a></pre>
<pre>0054:    <a href="/$src/lib/std/order.flx#0054">virtual proc pre_incr: &t</a></pre>
<pre>0055:    <a href="/$src/lib/std/order.flx#0055">virtual proc post_incr: &t</a></pre>

<pre>0058:  <a href="/$src/lib/std/order.flx#0058">class Bidirectional[t]</a></pre>
<pre>0060:    <a href="/$src/lib/std/order.flx#0060">virtual fun pred: t -> t</a></pre>
<pre>0061:    <a href="/$src/lib/std/order.flx#0061">virtual proc pre_decr: &t</a></pre>
<pre>0062:    <a href="/$src/lib/std/order.flx#0062">virtual proc post_decr: &t</a></pre>
<hr/><a href="/$src/lib/std/posix/__init__.flx">posix/__init__.flx</a>
<pre>0001:    <a href="/$src/lib/std/posix/__init__.flx#0001">struct Posix</a></pre>
<hr/><a href="/$src/lib/std/posix/directory.flx">posix/directory.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/directory.flx#0001">class PosixDirectory</a></pre>
<pre>0004:    <a href="/$src/lib/std/posix/directory.flx#0004">type dirent_t</a></pre>
<pre>0005:    <a href="/$src/lib/std/posix/directory.flx#0005">type DIR_t</a></pre>
<pre>0006:    <a href="/$src/lib/std/posix/directory.flx#0006">proc opendir: string * &DIR_t</a></pre>
<pre>0007:    <a href="/$src/lib/std/posix/directory.flx#0007">fun isNULL: DIR_t -> bool</a></pre>
<pre>0008:    <a href="/$src/lib/std/posix/directory.flx#0008">fun isNULL: dirent_t -> bool</a></pre>
<pre>0009:    <a href="/$src/lib/std/posix/directory.flx#0009">proc readdir: DIR_t * dirent_t * &dirent_t * &int</a></pre>
<pre>0010:    <a href="/$src/lib/std/posix/directory.flx#0010">proc closedir: DIR_t</a></pre>
<pre>0011:    <a href="/$src/lib/std/posix/directory.flx#0011">fun filename: dirent_t -> string</a></pre>
<pre>0019:    <a href="/$src/lib/std/posix/directory.flx#0019">gen mkdir: string * PosixFileStat::mode_t -> int</a></pre>
<pre>0020:    <a href="/$src/lib/std/posix/directory.flx#0020">gen mkdir: string  -> int</a></pre>
<pre>0021:    <a href="/$src/lib/std/posix/directory.flx#0021">proc mkdirs (s:string)</a></pre>
<pre>0030:    <a href="/$src/lib/std/posix/directory.flx#0030">fun getcwd():string</a></pre>
<pre>0035:    <a href="/$src/lib/std/posix/directory.flx#0035">fun is_absolute_filename (s:string)</a></pre>
<pre>0036:    <a href="/$src/lib/std/posix/directory.flx#0036">fun mk_absolute_filename(s:string)</a></pre>
<pre>0040:    <a href="/$src/lib/std/posix/directory.flx#0040">fun filesin(dname:string): opt[List::list[string]]</a></pre>
<hr/><a href="/$src/lib/std/posix/errno.flx">posix/errno.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/errno.flx#0001">open class Errno</a></pre>
<pre>0003:    <a href="/$src/lib/std/posix/errno.flx#0003">pod type errno_t</a></pre>
<pre>0004:    <a href="/$src/lib/std/posix/errno.flx#0004">ctor int : errno_t</a></pre>
<pre>0005:    <a href="/$src/lib/std/posix/errno.flx#0005">ctor errno_t : int</a></pre>
<pre>0021:    <a href="/$src/lib/std/posix/errno.flx#0021">proc maybe_exit(var n:int)</a></pre>
<pre>0022:    <a href="/$src/lib/std/posix/errno.flx#0022">proc maybe_exit(var n:errno_t)</a></pre>
<pre>0023:    <a href="/$src/lib/std/posix/errno.flx#0023">proc maybe_exit()</a></pre>
<pre>0028:    <a href="/$src/lib/std/posix/errno.flx#0028">proc strerror_r: errno_t *  carray[char] * size</a></pre>
<pre>0032:    <a href="/$src/lib/std/posix/errno.flx#0032">proc strerror_r: errno_t * carray[char] * size</a></pre>
<pre>0036:    <a href="/$src/lib/std/posix/errno.flx#0036">fun strerror(e:errno_t) : string</a></pre>
<pre>0046:    <a href="/$src/lib/std/posix/errno.flx#0046">gen strerror()</a></pre>

<pre>0052:  <a href="/$src/lib/std/posix/errno.flx#0052">class Check[T]</a></pre>
<pre>0054:    <a href="/$src/lib/std/posix/errno.flx#0054">proc int_to_proc (var x:int)</a></pre>
<pre>0055:    <a href="/$src/lib/std/posix/errno.flx#0055">fun int_to_int (var x:int)</a></pre>
<pre>0056:    <a href="/$src/lib/std/posix/errno.flx#0056">fun pointer_to_pointer[U] (var p:&U)</a></pre>
<pre>0060:    <a href="/$src/lib/std/posix/errno.flx#0060">type check_ignore</a></pre>
<pre>0063:    <a href="/$src/lib/std/posix/errno.flx#0063">fun ehandler ():any</a></pre>
<pre>0065:    <a href="/$src/lib/std/posix/errno.flx#0065">type check_throw</a></pre>
<pre>0068:    <a href="/$src/lib/std/posix/errno.flx#0068">fun ehandler ():any</a></pre>
<hr/><a href="/$src/lib/std/posix/faio_posix.flx">posix/faio_posix.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/faio_posix.flx#0001">class Faio_posix</a></pre>
<pre>0013:    <a href="/$src/lib/std/posix/faio_posix.flx#0013">fun sys_job_queue_qbound()</a></pre>
<pre>0014:    <a href="/$src/lib/std/posix/faio_posix.flx#0014">fun sys_job_queue_nthreads()</a></pre>
<pre>0018:    <a href="/$src/lib/std/posix/faio_posix.flx#0018">typedef fd_t</a></pre>
<pre>0019:    <a href="/$src/lib/std/posix/faio_posix.flx#0019">type socket_t</a></pre>
<pre>0023:    <a href="/$src/lib/std/posix/faio_posix.flx#0023">fun str: FileSystem::posix_file -> string</a></pre>
<pre>0027:    <a href="/$src/lib/std/posix/faio_posix.flx#0027">fun str: socket_t -> string</a></pre>
<pre>0030:    <a href="/$src/lib/std/posix/faio_posix.flx#0030">proc close: socket_t</a></pre>
<pre>0031:    <a href="/$src/lib/std/posix/faio_posix.flx#0031">proc shutdown: socket_t*int</a></pre>
<pre>0032:    <a href="/$src/lib/std/posix/faio_posix.flx#0032">fun bad_socket : socket_t -> bool</a></pre>
<pre>0036:    <a href="/$src/lib/std/posix/faio_posix.flx#0036">gen aio_ropen: string -> FileSystem::posix_file</a></pre>
<pre>0038:    <a href="/$src/lib/std/posix/faio_posix.flx#0038">gen aio_wopen: string -> FileSystem::posix_file</a></pre>
<pre>0040:    <a href="/$src/lib/std/posix/faio_posix.flx#0040">gen aio_rwopen: string -> FileSystem::posix_file</a></pre>
<pre>0042:    <a href="/$src/lib/std/posix/faio_posix.flx#0042">gen aio_creat: string * posix_permissions-> FileSystem::posix_file</a></pre>
<pre>0047:    <a href="/$src/lib/std/posix/faio_posix.flx#0047">type socketio_request</a></pre>
<pre>0049:    <a href="/$src/lib/std/posix/faio_posix.flx#0049">gen mk_socketio_request: demuxer * socket_t*address*int*bool -> socketio_request</a></pre>
<pre>0052:    <a href="/$src/lib/std/posix/faio_posix.flx#0052">fun get_pb: socketio_request -> sel_param_ptr</a></pre>
<pre>0055:    <a href="/$src/lib/std/posix/faio_posix.flx#0055">proc async_rw(fd: socket_t, len: &int, buf: address, eof: &bool, read_flag: bool)</a></pre>
<pre>0066:    <a href="/$src/lib/std/posix/faio_posix.flx#0066">proc async_read(fd: socket_t, len: &int, buf: address,</a></pre>
<pre>0072:    <a href="/$src/lib/std/posix/faio_posix.flx#0072">proc async_write(fd: socket_t, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0079:    <a href="/$src/lib/std/posix/faio_posix.flx#0079">type flxfileio_request</a></pre>
<pre>0082:    <a href="/$src/lib/std/posix/faio_posix.flx#0082">type async_connect</a></pre>
<pre>0084:    <a href="/$src/lib/std/posix/faio_posix.flx#0084">fun mk_async_connect: demuxer * +char *int-> async_connect</a></pre>
<pre>0085:    <a href="/$src/lib/std/posix/faio_posix.flx#0085">fun get_socket: async_connect -> socket_t</a></pre>
<pre>0086:    <a href="/$src/lib/std/posix/faio_posix.flx#0086">fun get_err: async_connect -> int</a></pre>
<pre>0089:    <a href="/$src/lib/std/posix/faio_posix.flx#0089">proc connect(s: &socket_t, addr: +char, port: int)</a></pre>
<pre>0096:    <a href="/$src/lib/std/posix/faio_posix.flx#0096">type accept_request</a></pre>
<pre>0098:    <a href="/$src/lib/std/posix/faio_posix.flx#0098">fun mk_accept: demuxer * socket_t -> accept_request</a></pre>
<pre>0099:    <a href="/$src/lib/std/posix/faio_posix.flx#0099">fun get_socket: accept_request -> socket_t</a></pre>
<pre>0102:    <a href="/$src/lib/std/posix/faio_posix.flx#0102">proc mk_listener: &socket_t* &int *int</a></pre>
<pre>0105:    <a href="/$src/lib/std/posix/faio_posix.flx#0105">proc accept(s: &socket_t, listener: socket_t)</a></pre>
<pre>0115:    <a href="/$src/lib/std/posix/faio_posix.flx#0115">fun mk_faio: job_queue * FileSystem::posix_file *address*int*int*bool -> flxfileio_request</a></pre>
<pre>0117:    <a href="/$src/lib/std/posix/faio_posix.flx#0117">fun get_pb: flxfileio_request -> sel_param_ptr</a></pre>
<pre>0119:    <a href="/$src/lib/std/posix/faio_posix.flx#0119">proc faio_rw(q:job_queue, fd: FileSystem::posix_file, len: &int, buf: address, eof: &bool, read_flag: bool)</a></pre>
<pre>0127:    <a href="/$src/lib/std/posix/faio_posix.flx#0127">proc faio_read(fd: FileSystem::posix_file, len: &int, buf: address,</a></pre>
<pre>0133:    <a href="/$src/lib/std/posix/faio_posix.flx#0133">proc faio_write(fd: FileSystem::posix_file, len: &int, buf: address, eof: &bool)</a></pre>
<hr/><a href="/$src/lib/std/posix/filestat.flx">posix/filestat.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/filestat.flx#0001">class PosixFileStat</a></pre>
<pre>0003:    <a href="/$src/lib/std/posix/filestat.flx#0003">pod type stat_t</a></pre>
<pre>0005:    <a href="/$src/lib/std/posix/filestat.flx#0005">pod type mode_t</a></pre>
<pre>0046:    <a href="/$src/lib/std/posix/filestat.flx#0046">fun raw_mode: &stat_t -> mode_t</a></pre>
<pre>0047:    <a href="/$src/lib/std/posix/filestat.flx#0047">fun file_type(m:mode_t)</a></pre>
<pre>0048:    <a href="/$src/lib/std/posix/filestat.flx#0048">fun file_perm(m:mode_t)</a></pre>
<pre>0050:    <a href="/$src/lib/std/posix/filestat.flx#0050">ctor uint: mode_t</a></pre>
<pre>0057:    <a href="/$src/lib/std/posix/filestat.flx#0057">proc stat: string * &stat_t * &int</a></pre>
<pre>0059:    <a href="/$src/lib/std/posix/filestat.flx#0059">proc utime: string * double * double * &int</a></pre>
<pre>0071:    <a href="/$src/lib/std/posix/filestat.flx#0071">gen chmod: string * mode_t -> int</a></pre>
<pre>0072:    <a href="/$src/lib/std/posix/filestat.flx#0072">gen umask: mode_t -> mode_t</a></pre>
<pre>0074:    <a href="/$src/lib/std/posix/filestat.flx#0074">fun file_type (s:&stat_t): file_type_t</a></pre>
<hr/><a href="/$src/lib/std/posix/filesystem.flx">posix/filesystem.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/filesystem.flx#0001">class PosixFileSystem</a></pre>
<pre>0006:    <a href="/$src/lib/std/posix/filesystem.flx#0006">pod type file_perm_t</a></pre>
<pre>0026:    <a href="/$src/lib/std/posix/filesystem.flx#0026">pod type posix_file</a></pre>
<pre>0027:    <a href="/$src/lib/std/posix/filesystem.flx#0027">fun valid: posix_file -> bool</a></pre>
<pre>0028:    <a href="/$src/lib/std/posix/filesystem.flx#0028">ctor int : posix_file</a></pre>
<pre>0033:    <a href="/$src/lib/std/posix/filesystem.flx#0033">gen open: string * file_perm_t * PosixFileStat::mode_t -> posix_file</a></pre>
<pre>0034:    <a href="/$src/lib/std/posix/filesystem.flx#0034">gen open: string * file_perm_t -> posix_file</a></pre>
<pre>0036:    <a href="/$src/lib/std/posix/filesystem.flx#0036">gen ropen: string -> posix_file</a></pre>
<pre>0037:    <a href="/$src/lib/std/posix/filesystem.flx#0037">gen wopen: string -> posix_file</a></pre>
<pre>0038:    <a href="/$src/lib/std/posix/filesystem.flx#0038">gen rwopen: string -> posix_file</a></pre>
<pre>0039:    <a href="/$src/lib/std/posix/filesystem.flx#0039">gen creat: string * PosixFileStat::mode_t-> posix_file</a></pre>
<pre>0041:    <a href="/$src/lib/std/posix/filesystem.flx#0041">gen close: posix_file -> int</a></pre>
<pre>0042:    <a href="/$src/lib/std/posix/filesystem.flx#0042">gen read: posix_file * &char * size -> size</a></pre>
<pre>0043:    <a href="/$src/lib/std/posix/filesystem.flx#0043">gen write: posix_file * &char * size -> size</a></pre>
<pre>0045:    <a href="/$src/lib/std/posix/filesystem.flx#0045">gen dup: posix_file -> posix_file</a></pre>
<pre>0046:    <a href="/$src/lib/std/posix/filesystem.flx#0046">gen dup2: posix_file * posix_file -> posix_file</a></pre>
<pre>0048:    <a href="/$src/lib/std/posix/filesystem.flx#0048">struct _piper_hack</a></pre>
<pre>0060:    <a href="/$src/lib/std/posix/filesystem.flx#0060">gen pipe ()</a></pre>
<pre>0062:    <a href="/$src/lib/std/posix/filesystem.flx#0062">gen fdopen_input: posix_file ->  ifile</a></pre>
<pre>0063:    <a href="/$src/lib/std/posix/filesystem.flx#0063">gen fdopen_output: posix_file ->  ofile</a></pre>
<pre>0068:    <a href="/$src/lib/std/posix/filesystem.flx#0068">gen unlink_file: string -> int</a></pre>
<pre>0073:    <a href="/$src/lib/std/posix/filesystem.flx#0073">gen rename_file: string * string -> int</a></pre>
<pre>0079:    <a href="/$src/lib/std/posix/filesystem.flx#0079">gen filecopy(src: string, dst: string) :  bool</a></pre>
<pre>0146:    <a href="/$src/lib/std/posix/filesystem.flx#0146">gen tmp_filename: 1 -> string</a></pre>
<hr/><a href="/$src/lib/std/posix/mmap.flx">posix/mmap.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/mmap.flx#0001">class Mmap</a></pre>
<pre>0012:    <a href="/$src/lib/std/posix/mmap.flx#0012">typedef off_t</a></pre>
<pre>0054:    <a href="/$src/lib/std/posix/mmap.flx#0054">fun mmap:</a></pre>
<pre>0064:    <a href="/$src/lib/std/posix/mmap.flx#0064">fun munmap: address * size -> int</a></pre>
<pre>0067:    <a href="/$src/lib/std/posix/mmap.flx#0067">fun msync: address * size * int -> int</a></pre>
<hr/><a href="/$src/lib/std/posix/posix_headers.flx">posix/posix_headers.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/posix_headers.flx#0001">class Posix_headers</a></pre>
<hr/><a href="/$src/lib/std/posix/process.flx">posix/process.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/process.flx#0001">class PosixProcess</a></pre>
<pre>0004:    <a href="/$src/lib/std/posix/process.flx#0004">gen popen_in: string -> Cstdio::ifile</a></pre>
<pre>0005:    <a href="/$src/lib/std/posix/process.flx#0005">gen pclose: Cstdio::ifile -> process_status_t</a></pre>
<pre>0007:    <a href="/$src/lib/std/posix/process.flx#0007">type process_status_t</a></pre>
<pre>0008:    <a href="/$src/lib/std/posix/process.flx#0008">ctor int:process_status_t</a></pre>
<pre>0009:    <a href="/$src/lib/std/posix/process.flx#0009">ctor process_status_t : int</a></pre>
<pre>0011:    <a href="/$src/lib/std/posix/process.flx#0011">fun WIFCONTINUED: process_status_t -> bool</a></pre>
<pre>0012:    <a href="/$src/lib/std/posix/process.flx#0012">fun WIFEXITED: process_status_t -> bool</a></pre>
<pre>0013:    <a href="/$src/lib/std/posix/process.flx#0013">fun WIFSIGNALED: process_status_t -> bool</a></pre>
<pre>0014:    <a href="/$src/lib/std/posix/process.flx#0014">fun WIFSTOPPED: process_status_t -> bool</a></pre>
<pre>0016:    <a href="/$src/lib/std/posix/process.flx#0016">fun WEXITSTATUS: process_status_t -> int</a></pre>
<pre>0017:    <a href="/$src/lib/std/posix/process.flx#0017">fun WTERMSIG: process_status_t -> signal_t</a></pre>
<pre>0018:    <a href="/$src/lib/std/posix/process.flx#0018">fun WSTOPSIG: process_status_t -> signal_t</a></pre>
<pre>0021:    <a href="/$src/lib/std/posix/process.flx#0021">fun  WCOREDUMP: process_status_t -> int</a></pre>
<pre>0024:    <a href="/$src/lib/std/posix/process.flx#0024">fun str(x:process_status_t)</a></pre>
<pre>0038:    <a href="/$src/lib/std/posix/process.flx#0038">type exec_result_t</a></pre>
<pre>0042:    <a href="/$src/lib/std/posix/process.flx#0042">gen execv:+char *  + +char -> exec_result_t</a></pre>
<pre>0043:    <a href="/$src/lib/std/posix/process.flx#0043">gen execvp:+char *  + +char -> exec_result_t</a></pre>
<pre>0044:    <a href="/$src/lib/std/posix/process.flx#0044">gen execve:+char *  + +char * + +char -> exec_result_t</a></pre>
<pre>0049:    <a href="/$src/lib/std/posix/process.flx#0049">type pid_t</a></pre>
<pre>0052:    <a href="/$src/lib/std/posix/process.flx#0052">fun str: pid_t -> string</a></pre>
<pre>0055:    <a href="/$src/lib/std/posix/process.flx#0055">ctor int: pid_t</a></pre>
<pre>0060:    <a href="/$src/lib/std/posix/process.flx#0060">gen fork: unit -> pid_t</a></pre>
<pre>0062:    <a href="/$src/lib/std/posix/process.flx#0062">union spawn_result_t</a></pre>
<pre>0072:    <a href="/$src/lib/std/posix/process.flx#0072">gen spawnv(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0092:    <a href="/$src/lib/std/posix/process.flx#0092">gen spawnvp(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0112:    <a href="/$src/lib/std/posix/process.flx#0112">gen spawnve(file: string, argv:+ +char, env: + +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0132:    <a href="/$src/lib/std/posix/process.flx#0132">type process_status_options_t</a></pre>
<pre>0139:    <a href="/$src/lib/std/posix/process.flx#0139">gen waitpid: pid_t * &process_status_t * process_status_options_t -> pid_t requires Posix_headers::sys_wait_h</a></pre>
<pre>0141:    <a href="/$src/lib/std/posix/process.flx#0141">gen waitpid(pid:pid_t)</a></pre>
<pre>0152:    <a href="/$src/lib/std/posix/process.flx#0152">union ProcesStatus</a></pre>
<pre>0154:    <a href="/$src/lib/std/posix/process.flx#0154">gen checkpid(pid:pid_t)</a></pre>
<pre>0167:    <a href="/$src/lib/std/posix/process.flx#0167">gen kill: pid_t * signal_t -> int</a></pre>
<hr/><a href="/$src/lib/std/posix/shell.flx">posix/shell.flx</a>

<pre>0004:  <a href="/$src/lib/std/posix/shell.flx#0004">class Bash</a></pre>
<pre>0010:    <a href="/$src/lib/std/posix/shell.flx#0010">fun quote(s:string):string</a></pre>
<hr/><a href="/$src/lib/std/posix/signal.flx">posix/signal.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/signal.flx#0001">class PosixSignal</a></pre>
<pre>0003:    <a href="/$src/lib/std/posix/signal.flx#0003">type signal_t</a></pre>
<pre>0004:    <a href="/$src/lib/std/posix/signal.flx#0004">ctor signal_t: int</a></pre>
<pre>0005:    <a href="/$src/lib/std/posix/signal.flx#0005">ctor int: signal_t</a></pre>
<pre>0007:    <a href="/$src/lib/std/posix/signal.flx#0007">type sig_t</a></pre>
<pre>0008:    <a href="/$src/lib/std/posix/signal.flx#0008">gen signal: signal_t * sig_t -> sig_t</a></pre>
<pre>0022:    <a href="/$src/lib/std/posix/signal.flx#0022">fun str: signal_t -> string</a></pre>
<pre>0058:    <a href="/$src/lib/std/posix/signal.flx#0058">proc ignore_signal(s:signal_t)</a></pre>
<pre>0064:    <a href="/$src/lib/std/posix/signal.flx#0064">struct sigaction sa</a></pre>
<pre>0075:    <a href="/$src/lib/std/posix/signal.flx#0075">proc trap_ctrl_c: unit requires ctrl_c_handling</a></pre>
<hr/><a href="/$src/lib/std/posix/time.flx">posix/time.flx</a>

<pre>0001:  <a href="/$src/lib/std/posix/time.flx#0001">class PosixTime</a></pre>
<pre>0021:    <a href="/$src/lib/std/posix/time.flx#0021">gen time () : double</a></pre>
<hr/><a href="/$src/lib/std/process.flx">process.flx</a>

<pre>0003:  <a href="/$src/lib/std/process.flx#0003">class Process_class[os]</a></pre>

<pre>0007:  <a href="/$src/lib/std/process.flx#0007">class Process</a></pre>
<hr/><a href="/$src/lib/std/quaternion.flx">quaternion.flx</a>

<pre>0001:  <a href="/$src/lib/std/quaternion.flx#0001">class Quaternion</a></pre>
<pre>0003:    <a href="/$src/lib/std/quaternion.flx#0003">type quaternion</a></pre>
<pre>0004:    <a href="/$src/lib/std/quaternion.flx#0004">ctor quaternion (x:double^4)</a></pre>
<pre>0006:    <a href="/$src/lib/std/quaternion.flx#0006">fun r(x:q)</a></pre>
<pre>0007:    <a href="/$src/lib/std/quaternion.flx#0007">fun i(x:q)</a></pre>
<pre>0008:    <a href="/$src/lib/std/quaternion.flx#0008">fun j(x:q)</a></pre>
<pre>0009:    <a href="/$src/lib/std/quaternion.flx#0009">fun k(x:q)</a></pre>
<pre>0011:    <a href="/$src/lib/std/quaternion.flx#0011">ctor q (x:double)</a></pre>
<pre>0026:    <a href="/$src/lib/std/quaternion.flx#0026">fun conj (a:q):q</a></pre>
<pre>0027:    <a href="/$src/lib/std/quaternion.flx#0027">fun norm (a:q):double</a></pre>
<pre>0032:    <a href="/$src/lib/std/quaternion.flx#0032">fun reciprocal (a:q):q</a></pre>
<hr/><a href="/$src/lib/std/rawc.flx">rawc.flx</a>

<pre>0017:  <a href="/$src/lib/std/rawc.flx#0017">class Raw_C</a></pre>
<pre>0020:    <a href="/$src/lib/std/rawc.flx#0020">typedef ntbs</a></pre>
<pre>0023:    <a href="/$src/lib/std/rawc.flx#0023">gen malloc:size -> address</a></pre>
<pre>0024:    <a href="/$src/lib/std/rawc.flx#0024">proc free:address</a></pre>
<pre>0025:    <a href="/$src/lib/std/rawc.flx#0025">gen realloc:address * size -> address</a></pre>
<pre>0026:    <a href="/$src/lib/std/rawc.flx#0026">proc calloc:size</a></pre>
<pre>0029:    <a href="/$src/lib/std/rawc.flx#0029">gen memset:address * int * size -> address</a></pre>
<pre>0030:    <a href="/$src/lib/std/rawc.flx#0030">gen memcpy:address * address * size -> address</a></pre>
<pre>0031:    <a href="/$src/lib/std/rawc.flx#0031">gen memmove:address * address * size -> address</a></pre>
<pre>0034:    <a href="/$src/lib/std/rawc.flx#0034">gen strlen: ntbs -> size</a></pre>
<pre>0035:    <a href="/$src/lib/std/rawc.flx#0035">gen strcpy:ntbs * ntbs -> ntbs</a></pre>
<pre>0036:    <a href="/$src/lib/std/rawc.flx#0036">gen strncpy:ntbs * ntbs * size -> ntbs</a></pre>
<pre>0037:    <a href="/$src/lib/std/rawc.flx#0037">gen strdup:ntbs -> ntbs</a></pre>
<pre>0038:    <a href="/$src/lib/std/rawc.flx#0038">gen strcat:ntbs * ntbs -> ntbs</a></pre>
<pre>0039:    <a href="/$src/lib/std/rawc.flx#0039">gen strchr:ntbs * int -> ntbs</a></pre>
<pre>0040:    <a href="/$src/lib/std/rawc.flx#0040">gen strcmp:ntbs * ntbs-> int</a></pre>
<hr/><a href="/$src/lib/std/real.flx">real.flx</a>
<hr/><a href="/$src/lib/std/semaphore.flx">semaphore.flx</a>

<pre>0001:  <a href="/$src/lib/std/semaphore.flx#0001">open class Semaphore</a></pre>
<pre>0004:    <a href="/$src/lib/std/semaphore.flx#0004">type semaphore</a></pre>
<pre>0005:    <a href="/$src/lib/std/semaphore.flx#0005">ctor semaphore</a></pre>
<pre>0006:    <a href="/$src/lib/std/semaphore.flx#0006">ctor semaphore * int</a></pre>
<pre>0007:    <a href="/$src/lib/std/semaphore.flx#0007">proc destroy : semaphore</a></pre>
<pre>0008:    <a href="/$src/lib/std/semaphore.flx#0008">proc post: semaphore</a></pre>
<pre>0009:    <a href="/$src/lib/std/semaphore.flx#0009">proc wait: semaphore</a></pre>
<pre>0010:    <a href="/$src/lib/std/semaphore.flx#0010">gen trywait: semaphore -> int</a></pre>
<hr/><a href="/$src/lib/std/signal.flx">signal.flx</a>

<pre>0008:  <a href="/$src/lib/std/signal.flx#0008">class Signal_class [os]</a></pre>
<pre>0009:    <a href="/$src/lib/std/signal.flx#0009">gen get_ctrl_c_flag: 1 -> bool requires ctrl_c_flag</a></pre>
<pre>0010:    <a href="/$src/lib/std/signal.flx#0010">proc set_ctrl_c_flag: int requires ctrl_c_flag</a></pre>
<pre>0011:    <a href="/$src/lib/std/signal.flx#0011">virtual proc trap_ctrl_c: 1</a></pre>

<pre>0015:  <a href="/$src/lib/std/signal.flx#0015">class Signal</a></pre>
<hr/><a href="/$src/lib/std/strings/lexer.flx">strings/lexer.flx</a>

<pre>0001:  <a href="/$src/lib/std/strings/lexer.flx#0001">class Lexer</a></pre>
<pre>0003:    <a href="/$src/lib/std/strings/lexer.flx#0003">pod type lex_iterator</a></pre>
<pre>0004:    <a href="/$src/lib/std/strings/lexer.flx#0004">fun start_iterator : string -> lex_iterator</a></pre>
<pre>0005:    <a href="/$src/lib/std/strings/lexer.flx#0005">fun end_iterator: string -> lex_iterator</a></pre>
<pre>0006:    <a href="/$src/lib/std/strings/lexer.flx#0006">fun bounds (x:string): lex_iterator * lex_iterator</a></pre>
<pre>0012:    <a href="/$src/lib/std/strings/lexer.flx#0012">fun string_between: lex_iterator * lex_iterator -> string</a></pre>
<pre>0018:    <a href="/$src/lib/std/strings/lexer.flx#0018">fun deref: lex_iterator -> char</a></pre>
<hr/><a href="/$src/lib/std/strings/re2.flx">strings/re2.flx</a>

<pre>0004:  <a href="/$src/lib/std/strings/re2.flx#0004">open class Re2</a></pre>
<div style='font-family:sans-serif; font-size:12pt; margin-left:100; margin-right:100; top:5; color:#406040'><p> Binding of Google RE2 regexp library.
</p></div>
<pre>0032:    <a href="/$src/lib/std/strings/re2.flx#0032">gen _ctor_RE2 : string -> RE2</a></pre>
<pre>0035:    <a href="/$src/lib/std/strings/re2.flx#0035">type StringPiece</a></pre>
<pre>0036:    <a href="/$src/lib/std/strings/re2.flx#0036">ctor StringPiece: string</a></pre>
<pre>0037:    <a href="/$src/lib/std/strings/re2.flx#0037">ctor StringPiece: unit</a></pre>
<pre>0038:    <a href="/$src/lib/std/strings/re2.flx#0038">ctor string: StringPiece</a></pre>
<pre>0039:    <a href="/$src/lib/std/strings/re2.flx#0039">fun len: StringPiece -> size</a></pre>
<pre>0040:    <a href="/$src/lib/std/strings/re2.flx#0040">fun data: StringPiece -> +char</a></pre>
<pre>0044:    <a href="/$src/lib/std/strings/re2.flx#0044">fun len: StringPiece -> size</a></pre>
<pre>0053:    <a href="/$src/lib/std/strings/re2.flx#0053">fun str: StringPiece -> string</a></pre>
<pre>0056:    <a href="/$src/lib/std/strings/re2.flx#0056">type Arg</a></pre>
<pre>0058:    <a href="/$src/lib/std/strings/re2.flx#0058">type Encoding</a></pre>
<pre>0062:    <a href="/$src/lib/std/strings/re2.flx#0062">type RE2Options</a></pre>
<pre>0064:    <a href="/$src/lib/std/strings/re2.flx#0064">proc Copy: RE2Options * RE2Options</a></pre>
<pre>0066:    <a href="/$src/lib/std/strings/re2.flx#0066">fun encoding: RE2Options -> Encoding</a></pre>
<pre>0067:    <a href="/$src/lib/std/strings/re2.flx#0067">proc set_encoding: RE2Options * Encoding</a></pre>
<pre>0069:    <a href="/$src/lib/std/strings/re2.flx#0069">fun posix_syntax: RE2Options -> bool</a></pre>
<pre>0070:    <a href="/$src/lib/std/strings/re2.flx#0070">proc set_posix_syntax: RE2Options * bool</a></pre>
<pre>0072:    <a href="/$src/lib/std/strings/re2.flx#0072">fun longest_match: RE2Options -> bool</a></pre>
<pre>0073:    <a href="/$src/lib/std/strings/re2.flx#0073">proc set_longest_match: RE2Options * bool</a></pre>
<pre>0075:    <a href="/$src/lib/std/strings/re2.flx#0075">fun log_errors: RE2Options -> bool</a></pre>
<pre>0076:    <a href="/$src/lib/std/strings/re2.flx#0076">proc set_log_errors: RE2Options * bool</a></pre>
<pre>0078:    <a href="/$src/lib/std/strings/re2.flx#0078">fun max_mem: RE2Options -> int</a></pre>
<pre>0079:    <a href="/$src/lib/std/strings/re2.flx#0079">proc set_max_mem: RE2Options * int</a></pre>
<pre>0081:    <a href="/$src/lib/std/strings/re2.flx#0081">fun literal: RE2Options -> bool</a></pre>
<pre>0082:    <a href="/$src/lib/std/strings/re2.flx#0082">proc set_literal: RE2Options * bool</a></pre>
<pre>0084:    <a href="/$src/lib/std/strings/re2.flx#0084">fun never_nl: RE2Options -> bool</a></pre>
<pre>0085:    <a href="/$src/lib/std/strings/re2.flx#0085">proc set_never_nl: RE2Options * bool</a></pre>
<pre>0087:    <a href="/$src/lib/std/strings/re2.flx#0087">fun case_sensitive: RE2Options -> bool</a></pre>
<pre>0088:    <a href="/$src/lib/std/strings/re2.flx#0088">proc set_case_sensitive: RE2Options * bool</a></pre>
<pre>0090:    <a href="/$src/lib/std/strings/re2.flx#0090">fun perl_classes: RE2Options -> bool</a></pre>
<pre>0091:    <a href="/$src/lib/std/strings/re2.flx#0091">proc set_perl_classes: RE2Options * bool</a></pre>
<pre>0093:    <a href="/$src/lib/std/strings/re2.flx#0093">fun word_boundary: RE2Options -> bool</a></pre>
<pre>0094:    <a href="/$src/lib/std/strings/re2.flx#0094">proc set_word_boundary: RE2Options * bool</a></pre>
<pre>0096:    <a href="/$src/lib/std/strings/re2.flx#0096">fun one_line: RE2Options -> bool</a></pre>
<pre>0097:    <a href="/$src/lib/std/strings/re2.flx#0097">proc set_one_line: RE2Options * bool</a></pre>
<pre>0099:    <a href="/$src/lib/std/strings/re2.flx#0099">fun ParseFlags: RE2Options -> int</a></pre>
<pre>0101:    <a href="/$src/lib/std/strings/re2.flx#0101">type ErrorCode</a></pre>
<pre>0118:    <a href="/$src/lib/std/strings/re2.flx#0118">type Anchor</a></pre>
<pre>0123:    <a href="/$src/lib/std/strings/re2.flx#0123">fun pattern: RE2 -> string</a></pre>
<pre>0124:    <a href="/$src/lib/std/strings/re2.flx#0124">fun error: RE2 -> string</a></pre>
<pre>0125:    <a href="/$src/lib/std/strings/re2.flx#0125">fun error_code: RE2 -> ErrorCode</a></pre>
<pre>0126:    <a href="/$src/lib/std/strings/re2.flx#0126">fun error_arg: RE2 -> string</a></pre>
<pre>0127:    <a href="/$src/lib/std/strings/re2.flx#0127">fun ok: RE2 -> bool</a></pre>
<pre>0128:    <a href="/$src/lib/std/strings/re2.flx#0128">fun ProgramSize: RE2 -> int</a></pre>
<pre>0130:    <a href="/$src/lib/std/strings/re2.flx#0130">gen GlobalReplace: &string * RE2 * StringPiece -> int</a></pre>
<pre>0131:    <a href="/$src/lib/std/strings/re2.flx#0131">gen Extract: StringPiece * RE2 * StringPiece * &string -> bool</a></pre>
<pre>0133:    <a href="/$src/lib/std/strings/re2.flx#0133">fun QuoteMeta: StringPiece -> string</a></pre>
<pre>0135:    <a href="/$src/lib/std/strings/re2.flx#0135">fun PossibleMatchRange: RE2 * &string * &string * int -> bool</a></pre>
<pre>0136:    <a href="/$src/lib/std/strings/re2.flx#0136">fun NumberOfCapturingGroups: RE2 -> int</a></pre>
<pre>0137:    <a href="/$src/lib/std/strings/re2.flx#0137">fun NamedCapturingGroups: RE2 -> Stl_Map::stl_map[string, int]</a></pre>
<pre>0140:    <a href="/$src/lib/std/strings/re2.flx#0140">gen Match: RE2 * StringPiece * int * Anchor * +StringPiece * int -> bool</a></pre>
<pre>0144:    <a href="/$src/lib/std/strings/re2.flx#0144">noinline gen Match(re:RE2, var s:string) : opt[varray[string]]</a></pre>
<pre>0157:    <a href="/$src/lib/std/strings/re2.flx#0157">gen apply (re:RE2, s:string)</a></pre>
<pre>0159:    <a href="/$src/lib/std/strings/re2.flx#0159">fun CheckRewriteString: RE2 * StringPiece * &string -> bool</a></pre>
<pre>0167:    <a href="/$src/lib/std/strings/re2.flx#0167">gen iterator (re2:string, var target:string)</a></pre>
<pre>0170:    <a href="/$src/lib/std/strings/re2.flx#0170">gen iterator (r:RE2, var target:string) () : opt[varray[string]]</a></pre>
<pre>0195:    <a href="/$src/lib/std/strings/re2.flx#0195">fun extract (re2:string, target:string) : opt[varray[string]]</a></pre>
<pre>0196:    <a href="/$src/lib/std/strings/re2.flx#0196">fun extract (re2:RE2, target:string) : opt[varray[string]]</a></pre>
<hr/><a href="/$src/lib/std/strings/regdef.flx">strings/regdef.flx</a>

<pre>0001:  <a href="/$src/lib/std/strings/regdef.flx#0001">class Regdef</a></pre>
<pre>0002:    <a href="/$src/lib/std/strings/regdef.flx#0002">union regex</a></pre>
<pre>0045:    <a href="/$src/lib/std/strings/regdef.flx#0045">fun ngrp (s:string)</a></pre>
<pre>0048:    <a href="/$src/lib/std/strings/regdef.flx#0048">fun render: regex -> string</a></pre>
<hr/><a href="/$src/lib/std/strings/tre.flx">strings/tre.flx</a>

<pre>0001:  <a href="/$src/lib/std/strings/tre.flx#0001">class Tre</a></pre>
<pre>0005:    <a href="/$src/lib/std/strings/tre.flx#0005">type tre_regex_t</a></pre>
<pre>0013:    <a href="/$src/lib/std/strings/tre.flx#0013">fun tre_regcomp (x:string): opt[tre_regex_t]</a></pre>
<pre>0021:    <a href="/$src/lib/std/strings/tre.flx#0021">fun nsub: &tre_regex_t -> int</a></pre>
<pre>0029:    <a href="/$src/lib/std/strings/tre.flx#0029">fun add: +char * regoff_t -> +char</a></pre>
<pre>0030:    <a href="/$src/lib/std/strings/tre.flx#0030">fun sub: regoff_t * regoff_t -> int</a></pre>
<pre>0031:    <a href="/$src/lib/std/strings/tre.flx#0031">ctor int : regoff_t</a></pre>
<pre>0043:    <a href="/$src/lib/std/strings/tre.flx#0043">fun tre_regexec (re_in: tre_regex_t) (x:string): int * int * +regmatch_t</a></pre>
<hr/><a href="/$src/lib/std/system.flx">system.flx</a>

<pre>0002:  <a href="/$src/lib/std/system.flx#0002">class System</a></pre>
<pre>0007:    <a href="/$src/lib/std/system.flx#0007">fun argv:int -> string</a></pre>
<pre>0008:    <a href="/$src/lib/std/system.flx#0008">fun argv_dflt (x:int) (y:string)</a></pre>
<pre>0010:    <a href="/$src/lib/std/system.flx#0010">fun args ()</a></pre>
<pre>0011:    <a href="/$src/lib/std/system.flx#0011">gen system: string -> int</a></pre>
<pre>0013:    <a href="/$src/lib/std/system.flx#0013">gen exit: int -> any</a></pre>
<pre>0014:    <a href="/$src/lib/std/system.flx#0014">gen abort: 1 -> any</a></pre>
<pre>0015:    <a href="/$src/lib/std/system.flx#0015">type ptf_t</a></pre>
<hr/><a href="/$src/lib/std/time.flx">time.flx</a>

<pre>0001:  <a href="/$src/lib/std/time.flx#0001">class Time_class [os]</a></pre>
<pre>0002:    <a href="/$src/lib/std/time.flx#0002">virtual gen time: 1 -> double</a></pre>

<pre>0005:  <a href="/$src/lib/std/time.flx#0005">open class Time</a></pre>
<hr/><a href="/$src/lib/std/typing.flx">typing.flx</a>

<pre>0001:  <a href="/$src/lib/std/typing.flx#0001">open class Typing</a></pre>
<pre>0003:    <a href="/$src/lib/std/typing.flx#0003">typedef fun dom(t:TYPE):TYPE</a></pre>
<pre>0004:    <a href="/$src/lib/std/typing.flx#0004">typematch t with</a></pre>
<pre>0009:    <a href="/$src/lib/std/typing.flx#0009">typedef fun cod(t:TYPE):TYPE</a></pre>
<pre>0010:    <a href="/$src/lib/std/typing.flx#0010">typematch t with</a></pre>
<pre>0015:    <a href="/$src/lib/std/typing.flx#0015">typedef fun prj1(t:TYPE):TYPE</a></pre>
<pre>0016:    <a href="/$src/lib/std/typing.flx#0016">typematch t with</a></pre>
<pre>0021:    <a href="/$src/lib/std/typing.flx#0021">typedef fun prj2(t:TYPE):TYPE</a></pre>
<pre>0022:    <a href="/$src/lib/std/typing.flx#0022">typematch t with</a></pre>
<pre>0027:    <a href="/$src/lib/std/typing.flx#0027">typedef fun type_land(x:TYPE, y:TYPE):TYPE</a></pre>
<pre>0028:    <a href="/$src/lib/std/typing.flx#0028">typematch (x,  y) with</a></pre>
<pre>0035:    <a href="/$src/lib/std/typing.flx#0035">typedef fun type_lor(x:TYPE, y:TYPE):TYPE</a></pre>
<pre>0036:    <a href="/$src/lib/std/typing.flx#0036">typematch (x,  y) with</a></pre>
<pre>0042:    <a href="/$src/lib/std/typing.flx#0042">typedef fun eq(x:TYPE, y:TYPE):TYPE</a></pre>
<pre>0043:    <a href="/$src/lib/std/typing.flx#0043">typematch x with</a></pre>
<pre>0049:    <a href="/$src/lib/std/typing.flx#0049">typedef fun</a></pre>
<pre>0050:    <a href="/$src/lib/std/typing.flx#0050">typematch x with</a></pre>
<hr/><a href="/$src/lib/std/win32/__init__.flx">win32/__init__.flx</a>
<pre>0001:    <a href="/$src/lib/std/win32/__init__.flx#0001">struct Win32</a></pre>
<hr/><a href="/$src/lib/std/win32/directory.flx">win32/directory.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/directory.flx#0001">class Win32Directory</a></pre>
<pre>0005:    <a href="/$src/lib/std/win32/directory.flx#0005">type DIR_t</a></pre>
<pre>0006:    <a href="/$src/lib/std/win32/directory.flx#0006">type FINDDATA_t</a></pre>
<pre>0008:    <a href="/$src/lib/std/win32/directory.flx#0008">proc findfirst: string * &FINDDATA_t * &DIR_t</a></pre>
<pre>0009:    <a href="/$src/lib/std/win32/directory.flx#0009">proc findnext: DIR_t * &FINDDATA_t * &int</a></pre>
<pre>0010:    <a href="/$src/lib/std/win32/directory.flx#0010">proc findclose : DIR_t</a></pre>
<pre>0012:    <a href="/$src/lib/std/win32/directory.flx#0012">fun findfailed : DIR_t -> bool</a></pre>
<pre>0013:    <a href="/$src/lib/std/win32/directory.flx#0013">fun filename : FINDDATA_t -> string</a></pre>
<pre>0028:    <a href="/$src/lib/std/win32/directory.flx#0028">gen mkdir: string * Win32FileStat::mode_t -> int</a></pre>
<pre>0029:    <a href="/$src/lib/std/win32/directory.flx#0029">gen mkdir: string  -> int</a></pre>
<pre>0030:    <a href="/$src/lib/std/win32/directory.flx#0030">proc mkdirs (s:string)</a></pre>
<pre>0041:    <a href="/$src/lib/std/win32/directory.flx#0041">fun getcwd():string</a></pre>
<pre>0050:    <a href="/$src/lib/std/win32/directory.flx#0050">fun is_absolute_filename (s:string)</a></pre>
<pre>0056:    <a href="/$src/lib/std/win32/directory.flx#0056">fun mk_absolute_filename(s:string)</a></pre>
<pre>0063:    <a href="/$src/lib/std/win32/directory.flx#0063">fun filesin(dname:string): opt[list[string]]</a></pre>
<hr/><a href="/$src/lib/std/win32/faio_win32.flx">win32/faio_win32.flx</a>
<pre>0013:    <a href="/$src/lib/std/win32/faio_win32.flx#0013">type WFILE</a></pre>
<pre>0014:    <a href="/$src/lib/std/win32/faio_win32.flx#0014">typedef fd_t</a></pre>
<pre>0019:    <a href="/$src/lib/std/win32/faio_win32.flx#0019">type SOCKET</a></pre>
<pre>0020:    <a href="/$src/lib/std/win32/faio_win32.flx#0020">typedef socket_t</a></pre>
<pre>0023:    <a href="/$src/lib/std/win32/faio_win32.flx#0023">fun str: socket_t -> string</a></pre>
<pre>0029:    <a href="/$src/lib/std/win32/faio_win32.flx#0029">fun GetLastError: 1 -> int</a></pre>
<pre>0034:    <a href="/$src/lib/std/win32/faio_win32.flx#0034">fun cmk_socket : unit -> SOCKET</a></pre>
<pre>0039:    <a href="/$src/lib/std/win32/faio_win32.flx#0039">proc mk_socket(s: &SOCKET)</a></pre>
<pre>0046:    <a href="/$src/lib/std/win32/faio_win32.flx#0046">type wasync_accept</a></pre>
<pre>0048:    <a href="/$src/lib/std/win32/faio_win32.flx#0048">fun mk_accept: demuxer *  SOCKET*SOCKET -> wasync_accept</a></pre>
<pre>0050:    <a href="/$src/lib/std/win32/faio_win32.flx#0050">fun get_success[t]: t -> bool</a></pre>
<pre>0055:    <a href="/$src/lib/std/win32/faio_win32.flx#0055">fun eq : SOCKET*SOCKET -> bool</a></pre>
<pre>0058:    <a href="/$src/lib/std/win32/faio_win32.flx#0058">proc Accept(success: &bool, listener: SOCKET, accepted: SOCKET)</a></pre>
<pre>0065:    <a href="/$src/lib/std/win32/faio_win32.flx#0065">type connect_ex</a></pre>
<pre>0066:    <a href="/$src/lib/std/win32/faio_win32.flx#0066">fun mk_connect_ex: demuxer * SOCKET*+char*int -> connect_ex</a></pre>
<pre>0070:    <a href="/$src/lib/std/win32/faio_win32.flx#0070">proc Connect(success: &bool, s: SOCKET, addr: +char, port: int)</a></pre>
<pre>0077:    <a href="/$src/lib/std/win32/faio_win32.flx#0077">proc Connect(s: &SOCKET, addr: +char, port: int)</a></pre>
<pre>0087:    <a href="/$src/lib/std/win32/faio_win32.flx#0087">proc cmk_listener: &SOCKET*&int*int</a></pre>
<pre>0090:    <a href="/$src/lib/std/win32/faio_win32.flx#0090">proc mk_listener(listener: &SOCKET, port: &int, backlog: int)</a></pre>
<pre>0097:    <a href="/$src/lib/std/win32/faio_win32.flx#0097">proc closesocket: SOCKET</a></pre>
<pre>0103:    <a href="/$src/lib/std/win32/faio_win32.flx#0103">proc shutdown: SOCKET*int</a></pre>
<pre>0105:    <a href="/$src/lib/std/win32/faio_win32.flx#0105">type wasync_transmit_file</a></pre>
<pre>0113:    <a href="/$src/lib/std/win32/faio_win32.flx#0113">gen OpenFile: string -> WFILE</a></pre>
<pre>0118:    <a href="/$src/lib/std/win32/faio_win32.flx#0118">gen OpenFileDuplex: string -> WFILE</a></pre>
<pre>0123:    <a href="/$src/lib/std/win32/faio_win32.flx#0123">proc CloseFile: WFILE</a></pre>
<pre>0129:    <a href="/$src/lib/std/win32/faio_win32.flx#0129">fun mk_transmit_file : demuxer * SOCKET*WFILE -> wasync_transmit_file</a></pre>
<pre>0133:    <a href="/$src/lib/std/win32/faio_win32.flx#0133">proc TransmitFile(s: SOCKET, f: WFILE)</a></pre>
<pre>0144:    <a href="/$src/lib/std/win32/faio_win32.flx#0144">fun mk_reuse_socket : demuxer * SOCKET -> wasync_transmit_file</a></pre>
<pre>0147:    <a href="/$src/lib/std/win32/faio_win32.flx#0147">proc ReuseSocket(s: SOCKET)</a></pre>
<pre>0153:    <a href="/$src/lib/std/win32/faio_win32.flx#0153">type wsa_socketio</a></pre>
<pre>0154:    <a href="/$src/lib/std/win32/faio_win32.flx#0154">gen mk_wsa_socketio: demuxer * SOCKET*sel_param_ptr*bool->wsa_socketio</a></pre>
<pre>0159:    <a href="/$src/lib/std/win32/faio_win32.flx#0159">proc WSARecv(s: SOCKET, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0171:    <a href="/$src/lib/std/win32/faio_win32.flx#0171">proc WSASend(s: SOCKET, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0182:    <a href="/$src/lib/std/win32/faio_win32.flx#0182">type winfile_io</a></pre>
<pre>0184:    <a href="/$src/lib/std/win32/faio_win32.flx#0184">fun mk_winfile_io: demuxer * WFILE*address*int*bool->winfile_io</a></pre>
<pre>0187:    <a href="/$src/lib/std/win32/faio_win32.flx#0187">fun get_pb: winfile_io -> sel_param_ptr</a></pre>
<pre>0189:    <a href="/$src/lib/std/win32/faio_win32.flx#0189">proc ReadFile(f: WFILE, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0197:    <a href="/$src/lib/std/win32/faio_win32.flx#0197">proc WriteFile(f: WFILE, len: &int, buf: address, eof: &bool)</a></pre>
<pre>0207:    <a href="/$src/lib/std/win32/faio_win32.flx#0207">type iocp_associator</a></pre>
<pre>0208:    <a href="/$src/lib/std/win32/faio_win32.flx#0208">fun mk_iocp_associator: demuxer * SOCKET -> iocp_associator</a></pre>
<pre>0213:    <a href="/$src/lib/std/win32/faio_win32.flx#0213">proc associate_with_iocp(s: SOCKET)</a></pre>
<hr/><a href="/$src/lib/std/win32/filestat.flx">win32/filestat.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/filestat.flx#0001">class Win32FileStat</a></pre>
<pre>0013:    <a href="/$src/lib/std/win32/filestat.flx#0013">pod type mode_t</a></pre>
<pre>0014:    <a href="/$src/lib/std/win32/filestat.flx#0014">pod type stat_t</a></pre>
<pre>0032:    <a href="/$src/lib/std/win32/filestat.flx#0032">fun raw_mode: &stat_t -> mode_t</a></pre>
<pre>0033:    <a href="/$src/lib/std/win32/filestat.flx#0033">fun file_type(m:mode_t)</a></pre>
<pre>0034:    <a href="/$src/lib/std/win32/filestat.flx#0034">fun file_perm(m:mode_t)</a></pre>
<pre>0036:    <a href="/$src/lib/std/win32/filestat.flx#0036">ctor uint: mode_t</a></pre>
<pre>0043:    <a href="/$src/lib/std/win32/filestat.flx#0043">proc stat: string * &stat_t * &int</a></pre>
<pre>0045:    <a href="/$src/lib/std/win32/filestat.flx#0045">proc utime: string * double * double * &int</a></pre>
<pre>0057:    <a href="/$src/lib/std/win32/filestat.flx#0057">gen chmod: string * mode_t -> int</a></pre>
<pre>0058:    <a href="/$src/lib/std/win32/filestat.flx#0058">gen umask: mode_t -> mode_t</a></pre>
<pre>0060:    <a href="/$src/lib/std/win32/filestat.flx#0060">fun file_type (s:&stat_t): file_type_t</a></pre>
<hr/><a href="/$src/lib/std/win32/filesystem.flx">win32/filesystem.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/filesystem.flx#0001">class Win32FileSystem</a></pre>
<pre>0006:    <a href="/$src/lib/std/win32/filesystem.flx#0006">pod type file_perm_t</a></pre>
<pre>0026:    <a href="/$src/lib/std/win32/filesystem.flx#0026">pod type posix_file</a></pre>
<pre>0027:    <a href="/$src/lib/std/win32/filesystem.flx#0027">fun valid: posix_file -> bool</a></pre>
<pre>0028:    <a href="/$src/lib/std/win32/filesystem.flx#0028">ctor int : posix_file</a></pre>
<pre>0033:    <a href="/$src/lib/std/win32/filesystem.flx#0033">gen open: string * file_perm_t * Win32FileStat::mode_t -> posix_file</a></pre>
<pre>0034:    <a href="/$src/lib/std/win32/filesystem.flx#0034">gen open: string * file_perm_t -> posix_file</a></pre>
<pre>0036:    <a href="/$src/lib/std/win32/filesystem.flx#0036">gen ropen: string -> posix_file</a></pre>
<pre>0037:    <a href="/$src/lib/std/win32/filesystem.flx#0037">gen wopen: string -> posix_file</a></pre>
<pre>0038:    <a href="/$src/lib/std/win32/filesystem.flx#0038">gen rwopen: string -> posix_file</a></pre>
<pre>0039:    <a href="/$src/lib/std/win32/filesystem.flx#0039">gen creat: string * Win32FileStat::mode_t-> posix_file</a></pre>
<pre>0041:    <a href="/$src/lib/std/win32/filesystem.flx#0041">gen close: posix_file -> int</a></pre>
<pre>0042:    <a href="/$src/lib/std/win32/filesystem.flx#0042">gen read: posix_file * &char * size -> size</a></pre>
<pre>0043:    <a href="/$src/lib/std/win32/filesystem.flx#0043">gen write: posix_file * &char * size -> size</a></pre>
<pre>0045:    <a href="/$src/lib/std/win32/filesystem.flx#0045">gen dup: posix_file -> posix_file</a></pre>
<pre>0046:    <a href="/$src/lib/std/win32/filesystem.flx#0046">gen dup2: posix_file * posix_file -> posix_file</a></pre>
<pre>0048:    <a href="/$src/lib/std/win32/filesystem.flx#0048">struct _piper_hack</a></pre>
<pre>0060:    <a href="/$src/lib/std/win32/filesystem.flx#0060">gen pipe ()</a></pre>
<pre>0062:    <a href="/$src/lib/std/win32/filesystem.flx#0062">gen fdopen_input: posix_file ->  ifile</a></pre>
<pre>0063:    <a href="/$src/lib/std/win32/filesystem.flx#0063">gen fdopen_output: posix_file ->  ofile</a></pre>
<pre>0068:    <a href="/$src/lib/std/win32/filesystem.flx#0068">gen unlink_file: string -> int</a></pre>
<pre>0073:    <a href="/$src/lib/std/win32/filesystem.flx#0073">gen rename_file: string * string -> int</a></pre>
<pre>0079:    <a href="/$src/lib/std/win32/filesystem.flx#0079">gen filecopy(src: string, dst: string) :  bool</a></pre>
<pre>0147:    <a href="/$src/lib/std/win32/filesystem.flx#0147">gen tmp_filename: 1 -> string</a></pre>
<hr/><a href="/$src/lib/std/win32/process.flx">win32/process.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/process.flx#0001">class Win32Process</a></pre>
<pre>0004:    <a href="/$src/lib/std/win32/process.flx#0004">gen popen_in: string -> Cstdio::ifile</a></pre>
<pre>0005:    <a href="/$src/lib/std/win32/process.flx#0005">gen pclose: Cstdio::ifile -> process_status_t</a></pre>
<pre>0006:    <a href="/$src/lib/std/win32/process.flx#0006">type process_status_t</a></pre>
<pre>0007:    <a href="/$src/lib/std/win32/process.flx#0007">ctor intptr:process_status_t</a></pre>
<pre>0008:    <a href="/$src/lib/std/win32/process.flx#0008">ctor int:process_status_t</a></pre>
<pre>0009:    <a href="/$src/lib/std/win32/process.flx#0009">ctor process_status_t : intptr</a></pre>
<pre>0012:    <a href="/$src/lib/std/win32/process.flx#0012">fun WIFCONTINUED: process_status_t -> bool</a></pre>
<pre>0013:    <a href="/$src/lib/std/win32/process.flx#0013">fun WIFEXITED: process_status_t -> bool</a></pre>
<pre>0014:    <a href="/$src/lib/std/win32/process.flx#0014">fun WIFSIGNALED: process_status_t -> bool</a></pre>
<pre>0015:    <a href="/$src/lib/std/win32/process.flx#0015">fun WIFSTOPPED: process_status_t -> bool</a></pre>
<pre>0017:    <a href="/$src/lib/std/win32/process.flx#0017">fun WEXITSTATUS: process_status_t -> int</a></pre>
<pre>0018:    <a href="/$src/lib/std/win32/process.flx#0018">fun WTERMSIG: process_status_t -> signal_t</a></pre>
<pre>0019:    <a href="/$src/lib/std/win32/process.flx#0019">fun WSTOPSIG: process_status_t -> signal_t</a></pre>
<pre>0022:    <a href="/$src/lib/std/win32/process.flx#0022">fun  WCOREDUMP: process_status_t -> int</a></pre>
<pre>0025:    <a href="/$src/lib/std/win32/process.flx#0025">fun str(x:process_status_t)</a></pre>
<pre>0039:    <a href="/$src/lib/std/win32/process.flx#0039">type exec_result_t</a></pre>
<pre>0043:    <a href="/$src/lib/std/win32/process.flx#0043">gen execv:+char *  + +char -> exec_result_t</a></pre>
<pre>0044:    <a href="/$src/lib/std/win32/process.flx#0044">gen execvp:+char *  + +char -> exec_result_t</a></pre>
<pre>0045:    <a href="/$src/lib/std/win32/process.flx#0045">gen execve:+char *  + +char * + +char -> exec_result_t</a></pre>
<pre>0050:    <a href="/$src/lib/std/win32/process.flx#0050">type pid_t</a></pre>
<pre>0051:    <a href="/$src/lib/std/win32/process.flx#0051">ctor intptr: pid_t</a></pre>
<pre>0056:    <a href="/$src/lib/std/win32/process.flx#0056">fun str: pid_t -> string</a></pre>
<pre>0059:    <a href="/$src/lib/std/win32/process.flx#0059">union spawn_result_t</a></pre>
<pre>0069:    <a href="/$src/lib/std/win32/process.flx#0069">gen spawnv:+char *  + +char -> pid_t</a></pre>
<pre>0070:    <a href="/$src/lib/std/win32/process.flx#0070">gen spawnvp:+char *  + +char -> pid_t</a></pre>
<pre>0071:    <a href="/$src/lib/std/win32/process.flx#0071">gen spawnve:+char *  + +char * + +char -> pid_t</a></pre>
<pre>0073:    <a href="/$src/lib/std/win32/process.flx#0073">gen spawnv(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0082:    <a href="/$src/lib/std/win32/process.flx#0082">gen spawnvp(file: string, argv:+ +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0091:    <a href="/$src/lib/std/win32/process.flx#0091">gen spawnve(file: string, argv:+ +char, env: + +char, setup:1->int) : spawn_result_t</a></pre>
<pre>0100:    <a href="/$src/lib/std/win32/process.flx#0100">type process_status_options_t</a></pre>
<pre>0108:    <a href="/$src/lib/std/win32/process.flx#0108">gen waitpid: pid_t * &process_status_t * process_status_options_t -> pid_t requires Posix_headers::sys_wait_h</a></pre>
<pre>0110:    <a href="/$src/lib/std/win32/process.flx#0110">gen waitpid(pid:pid_t)</a></pre>
<pre>0121:    <a href="/$src/lib/std/win32/process.flx#0121">union ProcesStatus</a></pre>
<pre>0123:    <a href="/$src/lib/std/win32/process.flx#0123">gen checkpid(pid:pid_t)</a></pre>
<pre>0136:    <a href="/$src/lib/std/win32/process.flx#0136">gen kill: pid_t * signal_t -> int</a></pre>
<hr/><a href="/$src/lib/std/win32/signal.flx">win32/signal.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/signal.flx#0001">class Win32Signal</a></pre>
<pre>0003:    <a href="/$src/lib/std/win32/signal.flx#0003">type signal_t</a></pre>
<pre>0004:    <a href="/$src/lib/std/win32/signal.flx#0004">ctor signal_t: int</a></pre>
<pre>0005:    <a href="/$src/lib/std/win32/signal.flx#0005">ctor int: signal_t</a></pre>
<pre>0008:    <a href="/$src/lib/std/win32/signal.flx#0008">type sig_t</a></pre>
<pre>0009:    <a href="/$src/lib/std/win32/signal.flx#0009">gen signal: signal_t * sig_t -> sig_t</a></pre>
<pre>0022:    <a href="/$src/lib/std/win32/signal.flx#0022">fun str: signal_t -> string</a></pre>
<pre>0036:    <a href="/$src/lib/std/win32/signal.flx#0036">proc ignore_signal(s:signal_t)</a></pre>
<pre>0049:    <a href="/$src/lib/std/win32/signal.flx#0049">proc trap_ctrl_c: unit requires ctrl_c_handling</a></pre>
<hr/><a href="/$src/lib/std/win32/time.flx">win32/time.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/time.flx#0001">class Win32Time</a></pre>
<pre>0019:    <a href="/$src/lib/std/win32/time.flx#0019">gen time () : double</a></pre>
<hr/><a href="/$src/lib/std/win32/win32_headers.flx">win32/win32_headers.flx</a>

<pre>0001:  <a href="/$src/lib/std/win32/win32_headers.flx#0001">class Win32_headers</a></pre>
<hr/><a href="/$src/lib/std/xsi/__init__.flx">xsi/__init__.flx</a>
<hr/><a href="/$src/lib/std/xsi/ncurses.flx">xsi/ncurses.flx</a>

<pre>0001:  <a href="/$src/lib/std/xsi/ncurses.flx#0001">class Ncurses</a></pre>
<pre>0004:    <a href="/$src/lib/std/xsi/ncurses.flx#0004">type WINDOW</a></pre>
<pre>0005:    <a href="/$src/lib/std/xsi/ncurses.flx#0005">type SCREEN</a></pre>
<pre>0006:    <a href="/$src/lib/std/xsi/ncurses.flx#0006">type NCURSES_SCREEN_CB</a></pre>
<pre>0007:    <a href="/$src/lib/std/xsi/ncurses.flx#0007">type NCURSES_WINDOW_CB</a></pre>
<pre>0008:    <a href="/$src/lib/std/xsi/ncurses.flx#0008">type NCURSES_ATTR_T</a></pre>
<pre>0011:    <a href="/$src/lib/std/xsi/ncurses.flx#0011">typedef attr_t</a></pre>
<pre>0012:    <a href="/$src/lib/std/xsi/ncurses.flx#0012">typedef chtype</a></pre>
<pre>0013:    <a href="/$src/lib/std/xsi/ncurses.flx#0013">ctor chtype : int</a></pre>
<pre>0014:    <a href="/$src/lib/std/xsi/ncurses.flx#0014">ctor chtype : char</a></pre>
<pre>0015:    <a href="/$src/lib/std/xsi/ncurses.flx#0015">ctor char : chtype</a></pre>
<pre>0016:    <a href="/$src/lib/std/xsi/ncurses.flx#0016">ctor int : chtype</a></pre>
<pre>0019:    <a href="/$src/lib/std/xsi/ncurses.flx#0019">gen addch: chtype -> int</a></pre>
<pre>0020:    <a href="/$src/lib/std/xsi/ncurses.flx#0020">gen addchnstr: &chtype * int -> int</a></pre>
<pre>0021:    <a href="/$src/lib/std/xsi/ncurses.flx#0021">gen addchstr: &chtype -> int</a></pre>
<pre>0022:    <a href="/$src/lib/std/xsi/ncurses.flx#0022">gen addnstr: &char * int -> int</a></pre>
<pre>0023:    <a href="/$src/lib/std/xsi/ncurses.flx#0023">gen addstr: &char -> int</a></pre>
<pre>0024:    <a href="/$src/lib/std/xsi/ncurses.flx#0024">gen attroff: NCURSES_ATTR_T -> int</a></pre>
<pre>0025:    <a href="/$src/lib/std/xsi/ncurses.flx#0025">gen attron: NCURSES_ATTR_T -> int</a></pre>
<pre>0026:    <a href="/$src/lib/std/xsi/ncurses.flx#0026">gen attrset: NCURSES_ATTR_T -> int</a></pre>
<pre>0027:    <a href="/$src/lib/std/xsi/ncurses.flx#0027">gen attr_get: &attr_t * &short * address -> int</a></pre>
<pre>0028:    <a href="/$src/lib/std/xsi/ncurses.flx#0028">gen attr_off: attr_t * address -> int</a></pre>
<pre>0029:    <a href="/$src/lib/std/xsi/ncurses.flx#0029">gen attr_on: attr_t * address -> int</a></pre>
<pre>0030:    <a href="/$src/lib/std/xsi/ncurses.flx#0030">gen attr_set: attr_t * short * address -> int</a></pre>
<pre>0031:    <a href="/$src/lib/std/xsi/ncurses.flx#0031">gen baudrate: unit -> int</a></pre>
<pre>0032:    <a href="/$src/lib/std/xsi/ncurses.flx#0032">gen beep : unit -> int</a></pre>
<pre>0033:    <a href="/$src/lib/std/xsi/ncurses.flx#0033">gen bkgd: chtype -> int</a></pre>
<pre>0034:    <a href="/$src/lib/std/xsi/ncurses.flx#0034">gen bkgdset: chtype -> void</a></pre>
<pre>0035:    <a href="/$src/lib/std/xsi/ncurses.flx#0035">gen border: chtype * chtype * chtype * chtype * chtype * chtype * chtype * chtype -> int</a></pre>
<pre>0036:    <a href="/$src/lib/std/xsi/ncurses.flx#0036">gen box: WINDOW * chtype * chtype -> int</a></pre>
<pre>0037:    <a href="/$src/lib/std/xsi/ncurses.flx#0037">gen can_change_color: unit -> bool</a></pre>
<pre>0038:    <a href="/$src/lib/std/xsi/ncurses.flx#0038">gen cbreak: unit -> int</a></pre>
<pre>0039:    <a href="/$src/lib/std/xsi/ncurses.flx#0039">gen chgat: int * attr_t * short * address -> int</a></pre>
<pre>0040:    <a href="/$src/lib/std/xsi/ncurses.flx#0040">gen clear: unit -> int</a></pre>
<pre>0041:    <a href="/$src/lib/std/xsi/ncurses.flx#0041">gen clearok: WINDOW * bool -> int</a></pre>
<pre>0042:    <a href="/$src/lib/std/xsi/ncurses.flx#0042">gen clrtobot: unit -> int</a></pre>
<pre>0043:    <a href="/$src/lib/std/xsi/ncurses.flx#0043">gen clrtoeol: unit -> int</a></pre>
<pre>0044:    <a href="/$src/lib/std/xsi/ncurses.flx#0044">gen color_content: short * &short * &short * &short -> int</a></pre>
<pre>0045:    <a href="/$src/lib/std/xsi/ncurses.flx#0045">gen color_set: short * address -> int</a></pre>
<pre>0046:    <a href="/$src/lib/std/xsi/ncurses.flx#0046">gen COLOR_PAIR: int -> int</a></pre>
<pre>0047:    <a href="/$src/lib/std/xsi/ncurses.flx#0047">gen copywin: WINDOW * WINDOW * int * int * int * int * int * int * int -> int</a></pre>
<pre>0048:    <a href="/$src/lib/std/xsi/ncurses.flx#0048">gen curs_set: int -> int</a></pre>
<pre>0049:    <a href="/$src/lib/std/xsi/ncurses.flx#0049">gen def_prog_mode: unit -> int</a></pre>
<pre>0050:    <a href="/$src/lib/std/xsi/ncurses.flx#0050">gen def_shell_mode: unit -> int</a></pre>
<pre>0051:    <a href="/$src/lib/std/xsi/ncurses.flx#0051">gen delay_output: int -> int</a></pre>
<pre>0052:    <a href="/$src/lib/std/xsi/ncurses.flx#0052">gen delch: unit -> int</a></pre>
<pre>0053:    <a href="/$src/lib/std/xsi/ncurses.flx#0053">gen delscreen: &SCREEN -> void</a></pre>
<pre>0054:    <a href="/$src/lib/std/xsi/ncurses.flx#0054">gen delwin: WINDOW -> int</a></pre>
<pre>0055:    <a href="/$src/lib/std/xsi/ncurses.flx#0055">gen deleteln: unit -> int</a></pre>
<pre>0056:    <a href="/$src/lib/std/xsi/ncurses.flx#0056">gen derwin: WINDOW * int * int * int * int -> WINDOW</a></pre>
<pre>0057:    <a href="/$src/lib/std/xsi/ncurses.flx#0057">gen doupdate: unit -> int</a></pre>
<pre>0058:    <a href="/$src/lib/std/xsi/ncurses.flx#0058">gen dupwin: WINDOW -> WINDOW</a></pre>
<pre>0059:    <a href="/$src/lib/std/xsi/ncurses.flx#0059">gen echo: unit -> int</a></pre>
<pre>0060:    <a href="/$src/lib/std/xsi/ncurses.flx#0060">gen echochar: chtype -> int</a></pre>
<pre>0061:    <a href="/$src/lib/std/xsi/ncurses.flx#0061">gen erase: unit -> int</a></pre>
<pre>0062:    <a href="/$src/lib/std/xsi/ncurses.flx#0062">gen endwin: unit -> int</a></pre>
<pre>0063:    <a href="/$src/lib/std/xsi/ncurses.flx#0063">gen erasechar: unit -> char</a></pre>
<pre>0064:    <a href="/$src/lib/std/xsi/ncurses.flx#0064">gen filter: unit -> void</a></pre>
<pre>0065:    <a href="/$src/lib/std/xsi/ncurses.flx#0065">gen flash: unit -> int</a></pre>
<pre>0066:    <a href="/$src/lib/std/xsi/ncurses.flx#0066">gen flushinp: unit -> int</a></pre>
<pre>0067:    <a href="/$src/lib/std/xsi/ncurses.flx#0067">gen getbkgd: WINDOW -> chtype</a></pre>
<pre>0068:    <a href="/$src/lib/std/xsi/ncurses.flx#0068">gen getch: unit -> int</a></pre>
<pre>0069:    <a href="/$src/lib/std/xsi/ncurses.flx#0069">gen getnstr: &char * int -> int</a></pre>
<pre>0070:    <a href="/$src/lib/std/xsi/ncurses.flx#0070">gen getstr: &char -> int</a></pre>
<pre>0072:    <a href="/$src/lib/std/xsi/ncurses.flx#0072">gen halfdelay: int -> int</a></pre>
<pre>0073:    <a href="/$src/lib/std/xsi/ncurses.flx#0073">gen has_colors: unit -> bool</a></pre>
<pre>0074:    <a href="/$src/lib/std/xsi/ncurses.flx#0074">gen has_ic: unit -> bool</a></pre>
<pre>0075:    <a href="/$src/lib/std/xsi/ncurses.flx#0075">gen has_il: unit -> bool</a></pre>
<pre>0076:    <a href="/$src/lib/std/xsi/ncurses.flx#0076">gen hline: chtype * int -> int</a></pre>
<pre>0077:    <a href="/$src/lib/std/xsi/ncurses.flx#0077">gen idcok: WINDOW * bool -> void</a></pre>
<pre>0078:    <a href="/$src/lib/std/xsi/ncurses.flx#0078">gen idlok: WINDOW * bool -> int</a></pre>
<pre>0079:    <a href="/$src/lib/std/xsi/ncurses.flx#0079">gen immedok: WINDOW * bool -> void</a></pre>
<pre>0080:    <a href="/$src/lib/std/xsi/ncurses.flx#0080">gen inch: unit -> chtype</a></pre>
<pre>0081:    <a href="/$src/lib/std/xsi/ncurses.flx#0081">gen inchnstr: &chtype * int -> int</a></pre>
<pre>0082:    <a href="/$src/lib/std/xsi/ncurses.flx#0082">gen inchstr: &chtype -> int</a></pre>
<pre>0083:    <a href="/$src/lib/std/xsi/ncurses.flx#0083">gen initscr: unit -> WINDOW</a></pre>
<pre>0084:    <a href="/$src/lib/std/xsi/ncurses.flx#0084">gen init_color: short * short * short * short -> int</a></pre>
<pre>0085:    <a href="/$src/lib/std/xsi/ncurses.flx#0085">gen init_pair: short * short * short -> int</a></pre>
<pre>0086:    <a href="/$src/lib/std/xsi/ncurses.flx#0086">gen innstr: &char * int -> int</a></pre>
<pre>0087:    <a href="/$src/lib/std/xsi/ncurses.flx#0087">gen insch: chtype -> int</a></pre>
<pre>0088:    <a href="/$src/lib/std/xsi/ncurses.flx#0088">gen insdelln: int -> int</a></pre>
<pre>0089:    <a href="/$src/lib/std/xsi/ncurses.flx#0089">gen insertln: unit -> int</a></pre>
<pre>0090:    <a href="/$src/lib/std/xsi/ncurses.flx#0090">gen insnstr: &char * int -> int</a></pre>
<pre>0091:    <a href="/$src/lib/std/xsi/ncurses.flx#0091">gen insstr: &char -> int</a></pre>
<pre>0092:    <a href="/$src/lib/std/xsi/ncurses.flx#0092">gen instr: &char -> int</a></pre>
<pre>0093:    <a href="/$src/lib/std/xsi/ncurses.flx#0093">gen intrflush: WINDOW * bool -> int</a></pre>
<pre>0094:    <a href="/$src/lib/std/xsi/ncurses.flx#0094">gen isendwin: unit -> bool</a></pre>
<pre>0095:    <a href="/$src/lib/std/xsi/ncurses.flx#0095">gen is_linetouched: WINDOW * int -> bool</a></pre>
<pre>0096:    <a href="/$src/lib/std/xsi/ncurses.flx#0096">gen is_wintouched: WINDOW -> bool</a></pre>
<pre>0097:    <a href="/$src/lib/std/xsi/ncurses.flx#0097">gen keyname: int -> &char</a></pre>
<pre>0098:    <a href="/$src/lib/std/xsi/ncurses.flx#0098">gen keypad: WINDOW * bool -> int</a></pre>
<pre>0099:    <a href="/$src/lib/std/xsi/ncurses.flx#0099">gen killchar: unit -> char</a></pre>
<pre>0100:    <a href="/$src/lib/std/xsi/ncurses.flx#0100">gen leaveok: WINDOW * bool -> int</a></pre>
<pre>0101:    <a href="/$src/lib/std/xsi/ncurses.flx#0101">gen longname: unit -> &char</a></pre>
<pre>0102:    <a href="/$src/lib/std/xsi/ncurses.flx#0102">gen meta: WINDOW * bool -> int</a></pre>
<pre>0103:    <a href="/$src/lib/std/xsi/ncurses.flx#0103">gen move: int * int -> int</a></pre>
<pre>0104:    <a href="/$src/lib/std/xsi/ncurses.flx#0104">gen mvaddch: int * int * chtype -> int</a></pre>
<pre>0105:    <a href="/$src/lib/std/xsi/ncurses.flx#0105">gen mvaddchnstr: int * int * &chtype * int -> int</a></pre>
<pre>0106:    <a href="/$src/lib/std/xsi/ncurses.flx#0106">gen mvaddchstr: int * int * &chtype -> int</a></pre>
<pre>0107:    <a href="/$src/lib/std/xsi/ncurses.flx#0107">gen mvaddnstr: int * int * &char * int -> int</a></pre>
<pre>0108:    <a href="/$src/lib/std/xsi/ncurses.flx#0108">gen mvaddstr: int * int * &char -> int</a></pre>
<pre>0109:    <a href="/$src/lib/std/xsi/ncurses.flx#0109">gen mvchgat: int * int * int * attr_t * short * address -> int</a></pre>
<pre>0110:    <a href="/$src/lib/std/xsi/ncurses.flx#0110">gen mvcur: int * int * int * int -> int</a></pre>
<pre>0111:    <a href="/$src/lib/std/xsi/ncurses.flx#0111">gen mvdelch: int * int -> int</a></pre>
<pre>0112:    <a href="/$src/lib/std/xsi/ncurses.flx#0112">gen mvderwin: WINDOW * int * int -> int</a></pre>
<pre>0113:    <a href="/$src/lib/std/xsi/ncurses.flx#0113">gen mvgetch: int * int -> int</a></pre>
<pre>0114:    <a href="/$src/lib/std/xsi/ncurses.flx#0114">gen mvgetnstr: int * int * &char * int -> int</a></pre>
<pre>0115:    <a href="/$src/lib/std/xsi/ncurses.flx#0115">gen mvgetstr: int * int * &char -> int</a></pre>
<pre>0116:    <a href="/$src/lib/std/xsi/ncurses.flx#0116">gen mvhline: int * int * chtype * int -> int</a></pre>
<pre>0117:    <a href="/$src/lib/std/xsi/ncurses.flx#0117">gen mvinch: int * int -> chtype</a></pre>
<pre>0118:    <a href="/$src/lib/std/xsi/ncurses.flx#0118">gen mvinchnstr: int * int * &chtype * int -> int</a></pre>
<pre>0119:    <a href="/$src/lib/std/xsi/ncurses.flx#0119">gen mvinchstr: int * int * &chtype -> int</a></pre>
<pre>0120:    <a href="/$src/lib/std/xsi/ncurses.flx#0120">gen mvinnstr: int * int * &char * int -> int</a></pre>
<pre>0121:    <a href="/$src/lib/std/xsi/ncurses.flx#0121">gen mvinsch: int * int * chtype -> int</a></pre>
<pre>0122:    <a href="/$src/lib/std/xsi/ncurses.flx#0122">gen mvinsnstr: int * int * &char * int -> int</a></pre>
<pre>0123:    <a href="/$src/lib/std/xsi/ncurses.flx#0123">gen mvinsstr: int * int * &char -> int</a></pre>
<pre>0124:    <a href="/$src/lib/std/xsi/ncurses.flx#0124">gen mvinstr: int * int * &char -> int</a></pre>
<pre>0129:    <a href="/$src/lib/std/xsi/ncurses.flx#0129">proc mvprintw: int * int * string</a></pre>
<pre>0131:    <a href="/$src/lib/std/xsi/ncurses.flx#0131">gen mvvline: int * int * chtype * int -> int</a></pre>
<pre>0132:    <a href="/$src/lib/std/xsi/ncurses.flx#0132">gen mvwaddch: WINDOW * int * int * chtype -> int</a></pre>
<pre>0133:    <a href="/$src/lib/std/xsi/ncurses.flx#0133">gen mvwaddchnstr: WINDOW * int * int * &chtype * int -> int</a></pre>
<pre>0134:    <a href="/$src/lib/std/xsi/ncurses.flx#0134">gen mvwaddchstr: WINDOW * int * int * &chtype -> int</a></pre>
<pre>0135:    <a href="/$src/lib/std/xsi/ncurses.flx#0135">gen mvwaddnstr: WINDOW * int * int * &char * int -> int</a></pre>
<pre>0136:    <a href="/$src/lib/std/xsi/ncurses.flx#0136">gen mvwaddstr: WINDOW * int * int * &char -> int</a></pre>
<pre>0137:    <a href="/$src/lib/std/xsi/ncurses.flx#0137">gen mvwchgat: WINDOW * int * int * int * attr_t * short * address -> int</a></pre>
<pre>0138:    <a href="/$src/lib/std/xsi/ncurses.flx#0138">gen mvwdelch: WINDOW * int * int -> int</a></pre>
<pre>0139:    <a href="/$src/lib/std/xsi/ncurses.flx#0139">gen mvwgetch: WINDOW * int * int -> int</a></pre>
<pre>0140:    <a href="/$src/lib/std/xsi/ncurses.flx#0140">gen mvwgetnstr: WINDOW * int * int * &char * int -> int</a></pre>
<pre>0141:    <a href="/$src/lib/std/xsi/ncurses.flx#0141">gen mvwgetstr: WINDOW * int * int * &char -> int</a></pre>
<pre>0142:    <a href="/$src/lib/std/xsi/ncurses.flx#0142">gen mvwhline: WINDOW * int * int * chtype * int -> int</a></pre>
<pre>0143:    <a href="/$src/lib/std/xsi/ncurses.flx#0143">gen mvwin: WINDOW * int * int -> int</a></pre>
<pre>0144:    <a href="/$src/lib/std/xsi/ncurses.flx#0144">gen mvwinch: WINDOW * int * int -> chtype</a></pre>
<pre>0145:    <a href="/$src/lib/std/xsi/ncurses.flx#0145">gen mvwinchnstr: WINDOW * int * int * &chtype * int -> int</a></pre>
<pre>0146:    <a href="/$src/lib/std/xsi/ncurses.flx#0146">gen mvwinchstr: WINDOW * int * int * &chtype -> int</a></pre>
<pre>0147:    <a href="/$src/lib/std/xsi/ncurses.flx#0147">gen mvwinnstr: WINDOW * int * int * &char * int -> int</a></pre>
<pre>0148:    <a href="/$src/lib/std/xsi/ncurses.flx#0148">gen mvwinsch: WINDOW * int * int * chtype -> int</a></pre>
<pre>0149:    <a href="/$src/lib/std/xsi/ncurses.flx#0149">gen mvwinsnstr: WINDOW * int * int * &char * int -> int</a></pre>
<pre>0150:    <a href="/$src/lib/std/xsi/ncurses.flx#0150">gen mvwinsstr: WINDOW * int * int * &char -> int</a></pre>
<pre>0151:    <a href="/$src/lib/std/xsi/ncurses.flx#0151">gen mvwinstr: WINDOW * int * int * &char -> int</a></pre>
<pre>0156:    <a href="/$src/lib/std/xsi/ncurses.flx#0156">proc mvwprintw: WINDOW * int * int * string</a></pre>
<pre>0158:    <a href="/$src/lib/std/xsi/ncurses.flx#0158">gen mvwvline: WINDOW * int * int * chtype * int -> int</a></pre>
<pre>0159:    <a href="/$src/lib/std/xsi/ncurses.flx#0159">gen napms: int -> int</a></pre>
<pre>0160:    <a href="/$src/lib/std/xsi/ncurses.flx#0160">gen newpad: int * int -> WINDOW</a></pre>
<pre>0162:    <a href="/$src/lib/std/xsi/ncurses.flx#0162">gen newwin: int * int * int * int -> WINDOW</a></pre>
<pre>0163:    <a href="/$src/lib/std/xsi/ncurses.flx#0163">gen nl: unit -> int</a></pre>
<pre>0164:    <a href="/$src/lib/std/xsi/ncurses.flx#0164">gen nocbreak: unit -> int</a></pre>
<pre>0165:    <a href="/$src/lib/std/xsi/ncurses.flx#0165">gen nodelay: WINDOW * bool -> int</a></pre>
<pre>0166:    <a href="/$src/lib/std/xsi/ncurses.flx#0166">gen noecho: unit -> int</a></pre>
<pre>0167:    <a href="/$src/lib/std/xsi/ncurses.flx#0167">gen nonl: unit -> int</a></pre>
<pre>0168:    <a href="/$src/lib/std/xsi/ncurses.flx#0168">gen noqiflush: unit -> void</a></pre>
<pre>0169:    <a href="/$src/lib/std/xsi/ncurses.flx#0169">gen noraw: unit -> int</a></pre>
<pre>0170:    <a href="/$src/lib/std/xsi/ncurses.flx#0170">gen notimeout: WINDOW * bool -> int</a></pre>
<pre>0171:    <a href="/$src/lib/std/xsi/ncurses.flx#0171">gen overlay: &WINDOW * WINDOW -> int</a></pre>
<pre>0172:    <a href="/$src/lib/std/xsi/ncurses.flx#0172">gen overwrite: &WINDOW * WINDOW -> int</a></pre>
<pre>0173:    <a href="/$src/lib/std/xsi/ncurses.flx#0173">gen pair_content: short * &short * &short -> int</a></pre>
<pre>0174:    <a href="/$src/lib/std/xsi/ncurses.flx#0174">gen PAIR_NUMBER: int -> int</a></pre>
<pre>0175:    <a href="/$src/lib/std/xsi/ncurses.flx#0175">gen pechochar: WINDOW * chtype -> int</a></pre>
<pre>0176:    <a href="/$src/lib/std/xsi/ncurses.flx#0176">gen pnoutrefresh: &WINDOW * int * int * int * int * int * int -> int</a></pre>
<pre>0177:    <a href="/$src/lib/std/xsi/ncurses.flx#0177">gen prefresh: WINDOW * int * int * int * int * int * int -> int</a></pre>
<pre>0181:    <a href="/$src/lib/std/xsi/ncurses.flx#0181">proc printw : string</a></pre>
<pre>0183:    <a href="/$src/lib/std/xsi/ncurses.flx#0183">gen putwin: WINDOW * &FILE -> int</a></pre>
<pre>0184:    <a href="/$src/lib/std/xsi/ncurses.flx#0184">gen qiflush: unit -> void</a></pre>
<pre>0185:    <a href="/$src/lib/std/xsi/ncurses.flx#0185">gen raw: unit -> int</a></pre>
<pre>0186:    <a href="/$src/lib/std/xsi/ncurses.flx#0186">gen redrawwin: WINDOW -> int</a></pre>
<pre>0187:    <a href="/$src/lib/std/xsi/ncurses.flx#0187">gen refresh: unit -> int</a></pre>
<pre>0188:    <a href="/$src/lib/std/xsi/ncurses.flx#0188">gen resetty: unit -> int</a></pre>
<pre>0189:    <a href="/$src/lib/std/xsi/ncurses.flx#0189">gen reset_prog_mode: unit -> int</a></pre>
<pre>0190:    <a href="/$src/lib/std/xsi/ncurses.flx#0190">gen reset_shell_mode: unit -> int</a></pre>
<pre>0192:    <a href="/$src/lib/std/xsi/ncurses.flx#0192">gen savetty: unit -> int</a></pre>
<pre>0195:    <a href="/$src/lib/std/xsi/ncurses.flx#0195">gen scr_dump: &char -> int</a></pre>
<pre>0196:    <a href="/$src/lib/std/xsi/ncurses.flx#0196">gen scr_init: &char -> int</a></pre>
<pre>0197:    <a href="/$src/lib/std/xsi/ncurses.flx#0197">gen scrl: int -> int</a></pre>
<pre>0198:    <a href="/$src/lib/std/xsi/ncurses.flx#0198">gen scroll: WINDOW -> int</a></pre>
<pre>0199:    <a href="/$src/lib/std/xsi/ncurses.flx#0199">gen scrollok: WINDOW * bool -> int</a></pre>
<pre>0200:    <a href="/$src/lib/std/xsi/ncurses.flx#0200">gen scr_restore: &char -> int</a></pre>
<pre>0201:    <a href="/$src/lib/std/xsi/ncurses.flx#0201">gen scr_set: &char -> int</a></pre>
<pre>0202:    <a href="/$src/lib/std/xsi/ncurses.flx#0202">gen setscrreg: int * int -> int</a></pre>
<pre>0203:    <a href="/$src/lib/std/xsi/ncurses.flx#0203">gen set_term: &SCREEN -> &SCREEN</a></pre>
<pre>0204:    <a href="/$src/lib/std/xsi/ncurses.flx#0204">gen slk_attroff: chtype -> int</a></pre>
<pre>0205:    <a href="/$src/lib/std/xsi/ncurses.flx#0205">gen slk_attr_off: attr_t * address -> int</a></pre>
<pre>0206:    <a href="/$src/lib/std/xsi/ncurses.flx#0206">gen slk_attron: chtype -> int</a></pre>
<pre>0207:    <a href="/$src/lib/std/xsi/ncurses.flx#0207">gen slk_attr_on: attr_t * address -> int</a></pre>
<pre>0208:    <a href="/$src/lib/std/xsi/ncurses.flx#0208">gen slk_attrset: chtype -> int</a></pre>
<pre>0209:    <a href="/$src/lib/std/xsi/ncurses.flx#0209">gen slk_attr: unit -> attr_t</a></pre>
<pre>0210:    <a href="/$src/lib/std/xsi/ncurses.flx#0210">gen slk_attr_set: attr_t * short * address -> int</a></pre>
<pre>0211:    <a href="/$src/lib/std/xsi/ncurses.flx#0211">gen slk_clear: unit -> int</a></pre>
<pre>0212:    <a href="/$src/lib/std/xsi/ncurses.flx#0212">gen slk_color: short -> int</a></pre>
<pre>0213:    <a href="/$src/lib/std/xsi/ncurses.flx#0213">gen slk_init: int -> int</a></pre>
<pre>0214:    <a href="/$src/lib/std/xsi/ncurses.flx#0214">gen slk_label: int -> &char</a></pre>
<pre>0215:    <a href="/$src/lib/std/xsi/ncurses.flx#0215">gen slk_noutrefresh: unit -> int</a></pre>
<pre>0216:    <a href="/$src/lib/std/xsi/ncurses.flx#0216">gen slk_refresh: unit -> int</a></pre>
<pre>0217:    <a href="/$src/lib/std/xsi/ncurses.flx#0217">gen slk_restore: unit -> int</a></pre>
<pre>0218:    <a href="/$src/lib/std/xsi/ncurses.flx#0218">gen slk_set: int * &char * int -> int</a></pre>
<pre>0219:    <a href="/$src/lib/std/xsi/ncurses.flx#0219">gen slk_touch: unit -> int</a></pre>
<pre>0220:    <a href="/$src/lib/std/xsi/ncurses.flx#0220">gen standout: unit -> int</a></pre>
<pre>0221:    <a href="/$src/lib/std/xsi/ncurses.flx#0221">gen standend: unit -> int</a></pre>
<pre>0222:    <a href="/$src/lib/std/xsi/ncurses.flx#0222">gen start_color: unit -> int</a></pre>
<pre>0223:    <a href="/$src/lib/std/xsi/ncurses.flx#0223">gen subpad: WINDOW * int * int * int * int -> WINDOW</a></pre>
<pre>0224:    <a href="/$src/lib/std/xsi/ncurses.flx#0224">gen subwin: WINDOW * int * int * int * int -> WINDOW</a></pre>
<pre>0225:    <a href="/$src/lib/std/xsi/ncurses.flx#0225">gen syncok: WINDOW * bool -> int</a></pre>
<pre>0226:    <a href="/$src/lib/std/xsi/ncurses.flx#0226">gen termattrs: unit -> chtype</a></pre>
<pre>0227:    <a href="/$src/lib/std/xsi/ncurses.flx#0227">gen termname: unit -> &char</a></pre>
<pre>0228:    <a href="/$src/lib/std/xsi/ncurses.flx#0228">gen timeout: int -> void</a></pre>
<pre>0229:    <a href="/$src/lib/std/xsi/ncurses.flx#0229">gen touchline: WINDOW * int * int -> int</a></pre>
<pre>0230:    <a href="/$src/lib/std/xsi/ncurses.flx#0230">gen touchwin: WINDOW -> int</a></pre>
<pre>0231:    <a href="/$src/lib/std/xsi/ncurses.flx#0231">gen typeahead: int -> int</a></pre>
<pre>0232:    <a href="/$src/lib/std/xsi/ncurses.flx#0232">gen ungetch: int -> int</a></pre>
<pre>0233:    <a href="/$src/lib/std/xsi/ncurses.flx#0233">gen untouchwin: WINDOW -> int</a></pre>
<pre>0234:    <a href="/$src/lib/std/xsi/ncurses.flx#0234">gen use_env: bool -> void</a></pre>
<pre>0235:    <a href="/$src/lib/std/xsi/ncurses.flx#0235">gen vidattr: chtype -> int</a></pre>
<pre>0237:    <a href="/$src/lib/std/xsi/ncurses.flx#0237">gen vline: chtype * int -> int</a></pre>
<pre>0238:    <a href="/$src/lib/std/xsi/ncurses.flx#0238">gen vwprintw: WINDOW * &char * C_hack::va_list -> int</a></pre>
<pre>0239:    <a href="/$src/lib/std/xsi/ncurses.flx#0239">gen vw_printw: WINDOW * &char * C_hack::va_list -> int</a></pre>
<pre>0240:    <a href="/$src/lib/std/xsi/ncurses.flx#0240">gen vwscanw: WINDOW * &char * C_hack::va_list -> int</a></pre>
<pre>0241:    <a href="/$src/lib/std/xsi/ncurses.flx#0241">gen vw_scanw: WINDOW * &char * C_hack::va_list -> int</a></pre>
<pre>0242:    <a href="/$src/lib/std/xsi/ncurses.flx#0242">gen waddch: WINDOW * chtype -> int</a></pre>
<pre>0243:    <a href="/$src/lib/std/xsi/ncurses.flx#0243">gen waddchnstr: WINDOW * &chtype * int -> int</a></pre>
<pre>0244:    <a href="/$src/lib/std/xsi/ncurses.flx#0244">gen waddchstr: WINDOW * &chtype -> int</a></pre>
<pre>0245:    <a href="/$src/lib/std/xsi/ncurses.flx#0245">gen waddnstr: WINDOW * &char * int -> int</a></pre>
<pre>0246:    <a href="/$src/lib/std/xsi/ncurses.flx#0246">gen waddstr: WINDOW * &char -> int</a></pre>
<pre>0247:    <a href="/$src/lib/std/xsi/ncurses.flx#0247">proc waddstr: WINDOW * string</a></pre>
<pre>0248:    <a href="/$src/lib/std/xsi/ncurses.flx#0248">gen wattron: WINDOW * int -> int</a></pre>
<pre>0249:    <a href="/$src/lib/std/xsi/ncurses.flx#0249">gen wattroff: WINDOW * int -> int</a></pre>
<pre>0250:    <a href="/$src/lib/std/xsi/ncurses.flx#0250">gen wattrset: WINDOW * int -> int</a></pre>
<pre>0251:    <a href="/$src/lib/std/xsi/ncurses.flx#0251">gen wattr_get: WINDOW * &attr_t * &short * address -> int</a></pre>
<pre>0252:    <a href="/$src/lib/std/xsi/ncurses.flx#0252">gen wattr_on: WINDOW * attr_t * address -> int</a></pre>
<pre>0253:    <a href="/$src/lib/std/xsi/ncurses.flx#0253">gen wattr_off: WINDOW * attr_t * address -> int</a></pre>
<pre>0254:    <a href="/$src/lib/std/xsi/ncurses.flx#0254">gen wattr_set: WINDOW * attr_t * short * address -> int</a></pre>
<pre>0255:    <a href="/$src/lib/std/xsi/ncurses.flx#0255">gen wbkgd: WINDOW * chtype -> int</a></pre>
<pre>0256:    <a href="/$src/lib/std/xsi/ncurses.flx#0256">gen wbkgdset: WINDOW * chtype -> void</a></pre>
<pre>0257:    <a href="/$src/lib/std/xsi/ncurses.flx#0257">gen wborder: WINDOW * chtype * chtype * chtype * chtype * chtype * chtype * chtype * chtype -> int</a></pre>
<pre>0258:    <a href="/$src/lib/std/xsi/ncurses.flx#0258">gen wchgat: WINDOW * int * attr_t * short * address -> int</a></pre>
<pre>0259:    <a href="/$src/lib/std/xsi/ncurses.flx#0259">gen wclear: WINDOW -> int</a></pre>
<pre>0260:    <a href="/$src/lib/std/xsi/ncurses.flx#0260">gen wclrtobot: WINDOW -> int</a></pre>
<pre>0261:    <a href="/$src/lib/std/xsi/ncurses.flx#0261">gen wclrtoeol: WINDOW -> int</a></pre>
<pre>0262:    <a href="/$src/lib/std/xsi/ncurses.flx#0262">gen wcolor_set: &WINDOW * short * address -> int</a></pre>
<pre>0263:    <a href="/$src/lib/std/xsi/ncurses.flx#0263">gen wcursyncup: WINDOW -> void</a></pre>
<pre>0264:    <a href="/$src/lib/std/xsi/ncurses.flx#0264">gen wdelch: WINDOW -> int</a></pre>
<pre>0265:    <a href="/$src/lib/std/xsi/ncurses.flx#0265">gen wdeleteln: WINDOW -> int</a></pre>
<pre>0266:    <a href="/$src/lib/std/xsi/ncurses.flx#0266">gen wechochar: WINDOW * chtype -> int</a></pre>
<pre>0267:    <a href="/$src/lib/std/xsi/ncurses.flx#0267">gen werase: WINDOW -> int</a></pre>
<pre>0268:    <a href="/$src/lib/std/xsi/ncurses.flx#0268">gen wgetch: WINDOW -> int</a></pre>
<pre>0269:    <a href="/$src/lib/std/xsi/ncurses.flx#0269">gen wgetnstr: WINDOW * &char * int -> int</a></pre>
<pre>0270:    <a href="/$src/lib/std/xsi/ncurses.flx#0270">gen wgetstr: WINDOW * &char -> int</a></pre>
<pre>0271:    <a href="/$src/lib/std/xsi/ncurses.flx#0271">gen whline: WINDOW * chtype * int -> int</a></pre>
<pre>0272:    <a href="/$src/lib/std/xsi/ncurses.flx#0272">gen winch: WINDOW -> chtype</a></pre>
<pre>0273:    <a href="/$src/lib/std/xsi/ncurses.flx#0273">gen winchnstr: WINDOW * &chtype * int -> int</a></pre>
<pre>0274:    <a href="/$src/lib/std/xsi/ncurses.flx#0274">gen winchstr: WINDOW * &chtype -> int</a></pre>
<pre>0275:    <a href="/$src/lib/std/xsi/ncurses.flx#0275">gen winnstr: WINDOW * &char * int -> int</a></pre>
<pre>0276:    <a href="/$src/lib/std/xsi/ncurses.flx#0276">gen winsch: WINDOW * chtype -> int</a></pre>
<pre>0277:    <a href="/$src/lib/std/xsi/ncurses.flx#0277">gen winsdelln: WINDOW * int -> int</a></pre>
<pre>0278:    <a href="/$src/lib/std/xsi/ncurses.flx#0278">gen winsertln: WINDOW -> int</a></pre>
<pre>0279:    <a href="/$src/lib/std/xsi/ncurses.flx#0279">gen winsnstr: WINDOW * &char * int -> int</a></pre>
<pre>0280:    <a href="/$src/lib/std/xsi/ncurses.flx#0280">gen winsstr: WINDOW * &char -> int</a></pre>
<pre>0281:    <a href="/$src/lib/std/xsi/ncurses.flx#0281">gen winstr: WINDOW * &char -> int</a></pre>
<pre>0282:    <a href="/$src/lib/std/xsi/ncurses.flx#0282">gen wmove: WINDOW * int * int -> int</a></pre>
<pre>0283:    <a href="/$src/lib/std/xsi/ncurses.flx#0283">gen wnoutrefresh: WINDOW -> int</a></pre>
<pre>0286:    <a href="/$src/lib/std/xsi/ncurses.flx#0286">proc wprintw: WINDOW * string</a></pre>
<pre>0287:    <a href="/$src/lib/std/xsi/ncurses.flx#0287">gen wredrawln: WINDOW * int * int -> int</a></pre>
<pre>0288:    <a href="/$src/lib/std/xsi/ncurses.flx#0288">gen wrefresh: WINDOW -> int</a></pre>
<pre>0291:    <a href="/$src/lib/std/xsi/ncurses.flx#0291">gen wscrl: WINDOW * int -> int</a></pre>
<pre>0292:    <a href="/$src/lib/std/xsi/ncurses.flx#0292">gen wsetscrreg: WINDOW * int * int -> int</a></pre>
<pre>0293:    <a href="/$src/lib/std/xsi/ncurses.flx#0293">gen wstandout: WINDOW -> int</a></pre>
<pre>0294:    <a href="/$src/lib/std/xsi/ncurses.flx#0294">gen wstandend: WINDOW -> int</a></pre>
<pre>0295:    <a href="/$src/lib/std/xsi/ncurses.flx#0295">gen wsyncdown: WINDOW -> void</a></pre>
<pre>0296:    <a href="/$src/lib/std/xsi/ncurses.flx#0296">gen wsyncup: WINDOW -> void</a></pre>
<pre>0297:    <a href="/$src/lib/std/xsi/ncurses.flx#0297">gen wtimeout: WINDOW * int -> void</a></pre>
<pre>0298:    <a href="/$src/lib/std/xsi/ncurses.flx#0298">gen wtouchln: WINDOW * int * int * int -> int</a></pre>
<pre>0299:    <a href="/$src/lib/std/xsi/ncurses.flx#0299">gen wvline: WINDOW * chtype * int -> int</a></pre>
<pre>0304:    <a href="/$src/lib/std/xsi/ncurses.flx#0304">gen tigetflag: &char -> int</a></pre>
<pre>0305:    <a href="/$src/lib/std/xsi/ncurses.flx#0305">gen tigetnum: &char -> int</a></pre>
<pre>0306:    <a href="/$src/lib/std/xsi/ncurses.flx#0306">gen tigetstr: &char -> &char</a></pre>
<pre>0307:    <a href="/$src/lib/std/xsi/ncurses.flx#0307">gen putp: &char -> int</a></pre>
<pre>0319:    <a href="/$src/lib/std/xsi/ncurses.flx#0319">gen getattrs: WINDOW -> int</a></pre>
<pre>0320:    <a href="/$src/lib/std/xsi/ncurses.flx#0320">gen getcurx: WINDOW -> int</a></pre>
<pre>0321:    <a href="/$src/lib/std/xsi/ncurses.flx#0321">gen getcury: WINDOW -> int</a></pre>
<pre>0322:    <a href="/$src/lib/std/xsi/ncurses.flx#0322">gen getbegx: WINDOW -> int</a></pre>
<pre>0323:    <a href="/$src/lib/std/xsi/ncurses.flx#0323">gen getbegy: WINDOW -> int</a></pre>
<pre>0324:    <a href="/$src/lib/std/xsi/ncurses.flx#0324">gen getmaxx: WINDOW -> int</a></pre>
<pre>0325:    <a href="/$src/lib/std/xsi/ncurses.flx#0325">gen getmaxy: WINDOW -> int</a></pre>
<pre>0326:    <a href="/$src/lib/std/xsi/ncurses.flx#0326">gen getparx: WINDOW -> int</a></pre>
<pre>0327:    <a href="/$src/lib/std/xsi/ncurses.flx#0327">gen getpary: WINDOW -> int</a></pre>
<pre>0341:    <a href="/$src/lib/std/xsi/ncurses.flx#0341">gen is_term_resized: int * int -> bool</a></pre>
<pre>0342:    <a href="/$src/lib/std/xsi/ncurses.flx#0342">gen keybound: int * int -> &char</a></pre>
<pre>0343:    <a href="/$src/lib/std/xsi/ncurses.flx#0343">gen curses_version: unit -> &char</a></pre>
<pre>0344:    <a href="/$src/lib/std/xsi/ncurses.flx#0344">gen assume_default_colors: int * int -> int</a></pre>
<pre>0345:    <a href="/$src/lib/std/xsi/ncurses.flx#0345">gen define_key: &char * int -> int</a></pre>
<pre>0346:    <a href="/$src/lib/std/xsi/ncurses.flx#0346">gen key_defined: &char -> int</a></pre>
<pre>0347:    <a href="/$src/lib/std/xsi/ncurses.flx#0347">gen keyok: int * bool -> int</a></pre>
<pre>0348:    <a href="/$src/lib/std/xsi/ncurses.flx#0348">gen resize_term: int * int -> int</a></pre>
<pre>0349:    <a href="/$src/lib/std/xsi/ncurses.flx#0349">gen resizeterm: int * int -> int</a></pre>
<pre>0350:    <a href="/$src/lib/std/xsi/ncurses.flx#0350">gen set_escdelay: int -> int</a></pre>
<pre>0351:    <a href="/$src/lib/std/xsi/ncurses.flx#0351">gen set_tabsize: int -> int</a></pre>
<pre>0352:    <a href="/$src/lib/std/xsi/ncurses.flx#0352">gen use_default_colors: unit -> int</a></pre>
<pre>0353:    <a href="/$src/lib/std/xsi/ncurses.flx#0353">gen use_extended_names: bool -> int</a></pre>
<pre>0354:    <a href="/$src/lib/std/xsi/ncurses.flx#0354">gen use_legacy_coding: int -> int</a></pre>
<pre>0355:    <a href="/$src/lib/std/xsi/ncurses.flx#0355">gen use_screen: SCREEN * NCURSES_SCREEN_CB * address -> int</a></pre>
<pre>0356:    <a href="/$src/lib/std/xsi/ncurses.flx#0356">gen use_window: WINDOW * NCURSES_WINDOW_CB * address -> int</a></pre>
<pre>0357:    <a href="/$src/lib/std/xsi/ncurses.flx#0357">gen wresize: WINDOW * int * int -> int</a></pre>
<pre>0358:    <a href="/$src/lib/std/xsi/ncurses.flx#0358">proc nofilter:1</a></pre>
<pre>0364:    <a href="/$src/lib/std/xsi/ncurses.flx#0364">gen wgetparent: WINDOW -> WINDOW</a></pre>
<pre>0365:    <a href="/$src/lib/std/xsi/ncurses.flx#0365">gen is_cleared: WINDOW -> bool</a></pre>
<pre>0366:    <a href="/$src/lib/std/xsi/ncurses.flx#0366">gen is_idcok: WINDOW -> bool</a></pre>
<pre>0367:    <a href="/$src/lib/std/xsi/ncurses.flx#0367">gen is_idlok: WINDOW -> bool</a></pre>
<pre>0368:    <a href="/$src/lib/std/xsi/ncurses.flx#0368">gen is_immedok: WINDOW -> bool</a></pre>
<pre>0369:    <a href="/$src/lib/std/xsi/ncurses.flx#0369">gen is_keypad: WINDOW -> bool</a></pre>
<pre>0370:    <a href="/$src/lib/std/xsi/ncurses.flx#0370">gen is_leaveok: WINDOW -> bool</a></pre>
<pre>0371:    <a href="/$src/lib/std/xsi/ncurses.flx#0371">gen is_nodelay: WINDOW -> bool</a></pre>
<pre>0372:    <a href="/$src/lib/std/xsi/ncurses.flx#0372">gen is_notimeout: WINDOW -> bool</a></pre>
<pre>0373:    <a href="/$src/lib/std/xsi/ncurses.flx#0373">gen is_scrollok: WINDOW -> bool</a></pre>
<pre>0374:    <a href="/$src/lib/std/xsi/ncurses.flx#0374">gen is_syncok: WINDOW -> bool</a></pre>
<pre>0375:    <a href="/$src/lib/std/xsi/ncurses.flx#0375">gen wgetscrreg: WINDOW * &int * &int -> int</a></pre>
<pre>0378:    <a href="/$src/lib/std/xsi/ncurses.flx#0378">type mmask_t</a></pre>
<pre>0416:    <a href="/$src/lib/std/xsi/ncurses.flx#0416">gen getmouse: &MEVENT -> int</a></pre>
<pre>0417:    <a href="/$src/lib/std/xsi/ncurses.flx#0417">gen ungetmouse: &MEVENT -> int</a></pre>
<pre>0418:    <a href="/$src/lib/std/xsi/ncurses.flx#0418">gen mousemask: mmask_t * &mmask_t -> mmask_t</a></pre>
<pre>0419:    <a href="/$src/lib/std/xsi/ncurses.flx#0419">gen wenclose: WINDOW * int * int -> bool</a></pre>
<pre>0420:    <a href="/$src/lib/std/xsi/ncurses.flx#0420">gen mouseinterval: int -> int</a></pre>
<pre>0421:    <a href="/$src/lib/std/xsi/ncurses.flx#0421">gen wmouse_trafo: WINDOW * &int * &int * bool -> bool</a></pre>
<pre>0422:    <a href="/$src/lib/std/xsi/ncurses.flx#0422">gen mouse_trafo: &int * &int * bool -> bool</a></pre>
</body></html>
