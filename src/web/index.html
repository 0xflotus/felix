<html>
<head>
    <title>Felix</title>
</head>
<body>
<h1 style="text-align:center">The Felix Programming Language</h1>
<p style="text-align:center">The fastest scripting language on Earth.</p>
<p style="text-align:center"><img style="align:center;" src=/share/src/web/images/200px-Felix_the_cat.svg.png></p>
<p style="text-align:center">
  <a href=/share/src/web/download.html>Download</a> |
  <a href=/share/src/web/ref/tools.fdoc>Tools</a> |
  <a href="/share/src/web/tut_slides.fdoc">Overview: Slideshow</a> |
  <a href="/share/src/web/tutorial.fdoc">Tutorial</a> |
  <a href="/share/src/web/ref/reference.fdoc">Reference</a> |
  <a href="/share/src/web/ref/glossary.fdoc">Glossary</a> |
  <a href="/share/src/web/community.html">Community</a> 
</p>
<hr />

<h3>Why do we need a new programming language?</h3>
<p>Existing languages have too many faults to support modern requirements. </p>

<h3>Goals.</h3>
<p><ul>
<li>high performance</li>
<li>rapid prototyping and a scripting language deployment model</li>
<li>safety and correctness</li>
<li>scalability</li>
<li>adaptability</li>
<li>platform independence</li>
</ul>
</p>
<h4>Performance</h4>
<p>
The ability to obtain high performance in a wide variety
of domains is fundamental. Light-speed behaviour was a
primary goal of C++ and it is for Felix too. In fact,
we aim for hyper-light performance: faster than C.</p>

<p>Network performance matters too. This means 
we need platform independent asynchronous
I/O.  To support a large number of clients, we need
lightweight threads with fast context switching.</p>

<h4>Rapid Prototyping and scripting harness</h4>
<p>C++ is typically very hard to build. Make files,
macros, compiler and OS feature tests, switches,
paths and a huge
array of poorly integrated non-portable tools
make development a nightmare compared with the easy
of deploying Python or Perl scripts. IDEs fix these
problems in a clean way, but only handle boilerplate
workflows.
</p>

<h4>Correctness</h4>
<p>Unfortunately dynamic typing is not amenable to 
reasoning about program correctness, and traditional
imperative programming also presents obstacles.
</p>

<p>We need:
<ul>
<li>static typing for low level safety</li>
<li>contract programming model for high level safety</li>
<li>automatic memory management without compromising performance</li>
<li>overloading for convenience</li>
<li>parametric polymorphism for data types</li>
<li>functional programming for correctness</li>
<li>imperative programming for performance</li>
<li>platform independence for portability</li>
<li>platform dependence for performance and low level programming</li>
<li>shared-memory concurrency for real-time performance</li>
<li>message passing for distributed concurrent cloud computing</li>
<li>low level optimisations for tight calculations</li>
<li>high level optimisations for overall application speed</li>
<li>extensible grammar in user space for implementing Domain Specific Sub-Languages</li>
<li>easy use of existing C and C++ libraries and code bases</li>
<li>built-in support for web development</li>
<li>built-in support for high performance computing</li>
<li>built-in support for game development</li>
</ul>
which quite a demanding list!
</p>
<h3>How Felix meets these goals.</h3>
<p>Felix is designed to address all these issues. It is
a C++ code generator and thereby can provide compatibility
with existing C and C++ code bases. We let the native
C++ compiler do the hard work of low level optimisation
whilst Felix does high level optimisations. The resulting
code is very fast, sometimes "faster than the speed of light (C)",
but can be platform independent and is simply to deploy: 
just distribute the source files and run them, 
like a scripting language.</p>

<p>However Felix has its own type system based on a combination of
Ocaml and Haskell. Like Ocaml it provides strong support for functional
programming, whilst also supporting imperative programming. The type system
is strict.</p>

<p>First order polymorphism is core, not a bolt-on as in Java and C++.
Felix also provides open overloading like C++, but only allows
exact matches. It also provides Haskell style type classes
as an alternative way to obtain genericity.</p>

<p>To overcome syntactic impedence mismatching with the
wide number of application domains, the Felix grammar
is defined in user space. It can be extended by the
end user to provide a suitable Domain Specific Sub-Language.
The parser is GLR and the user actions are written in R5RS Scheme.</p>

<p>A rich set of shortcuts makes programming a breeze.
Built-in regular expression support and other features
provide string handling on par with Perl. Web programming
is enabled by built-in asynchronous socket I/O
combined with cooperatively multi-tasked fibres that would
support millions of http clients if only the server could
supply enough sockets. Context switching is achieved
by a pointer swap, and state is maintained by a spaghetti
stack.</p>

</body>
</html>
