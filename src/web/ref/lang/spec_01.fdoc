@title Felix Language Reference
@h1 Program structure
A Felix program consists of a nominated root parse unit and
the transitive closure of units with respect to inclusion.

The behaviour of this system consists of the action of the
initialisation code in each unit, performed in sequence
within a given unit, with the order of action between
units unspecified.

@h2 Parse Unit
A parse unit is a file augmented by prefixing specified import
files to the front. These consist of a suite of grammar files
defining the syntax and other files defining macros.
With this augmentation all parse units in a program
are independently parsed to produce an list of statements
represented as abstract syntax, denoted an AST (even
though it is a list of trees, not a single tree).

@h2 AST
The program consists of the concatenation of the ASTs
of each parse unit, resulting in a single AST, which
is then translated to a C++ translation unit by the
compiler.

@h1 Grammar
The Felix grammar is part of the library.
It is notionally prefixed to each file to be processed
prior to any import files to specify the syntax
with which the file is to be parsed and translated to
an AST.

The grammar uses an augmented BNF like syntax
with parse actions specified in R5RS Scheme.

The resulting S-expressions are translated to
an intermediate form and then into an internal
AST structure.

@h2 Include Directive
An include directive has the syntax:
@felix
include "filename";
@
where the filename is a Unix relative filename,
may not have an extension, and may not begin with or 
contain @{..} (two dots).

If the filename begins with @{./} then the balance of the name
is relative, a sibling of the including file, otherwise the name
is searched for on an include path. 

In either case, a search succeeds when it finds a file with
the appropriate base path in the search directory with
extension @{.flx} or {.fdoc}. If both files exist the
most recently changed one is used. If the time stamps are
the same the choice is unspecified.

@h2 Modules
Every Felix program is encapsulated in a module with
the name being a mangle of the basename of the root unit.
The mangling replaces characters in the filename with
other characters so that the module name is a valid
ISO C identifier.

@h2 Special procedure @{flx_main}
A program module may contain at most one top level
procedure named @{flx_main}. After initialisation 
code suspends or terminates, this procedure is invoked
if it exists. It is the analogue of @{main} in C++
however it is rarely used: side-effects of the
root units initialisation code are typically used instead.

@h2 Libraries
In Felix a library is a root unit together with its
transitive closure with respect to inclusion,
which does not contain a top level @{flx_main}.

A program unit can be augmented by a set of libraries
which are then considered as if included, but without
an include directive being present.


@h2 Lexicology
All Felix files are considered to be UTF-8 encoded Unicode.

@h1 Macros
Felix provides a basic syntax macro facility which
post-processes the parse AST.

@h2 Macro val
The @{macro val} macro specifies a name is to be replaced
by an expression wherever it occurs in an executable
expression, type expression, or pattern, for example
@felix
macro val LINUX = true;
@
causes each occurrence of the identifier @{LINUX}
to be replaced by @{true}.

The primary purpose of this statement is to define
manifest constants to be used in pattern matches.

@h2 Macro for loop
The macro for loop can be used to generate a list of
statements repeatedly with a sequence of substitutions.
@felix
var a = 1;
var b = 2;
var c = 3;
macro for name in a,b,c do
  println$ name;
done
@
is equivalent to
@felix
var a = 1;
var b = 2;
var c = 3;
println$ a;
println$ b;
println$ c;
@

Note that arbitrary processing can be performed in the grammar
using the Scheme action code.

@h1 General lookup
By default Felix looks up symbols in nested scopes, 
starting with all symbols in the current scope
and proceeding through its containing scope outwards
until the outermost scope is reached.

Symbols are visible in the whole of a scope,
both before and after their introduction.

A symbol lookup may properly find either a single
non-function symbol, which is final, or a set 
of function symbols.

If the kind of symbol being sought is a function 
symbol, overload resolution is performed on 
the set of function signatures found in a scope.
If a best match is found, that is final.
If no match is found the search continues in 
the next outermost scope.

All other cases are in error.

@h1 Classes
The top level Felix module can contain submodules 
which are specified by a non-polymorphic class
statement:
@felix
class classname { ... }
@
The effect is to produce a qualified name to be used
outside the class:
@felix
class classname { proc f () {} }
classname::f (); 
@
Classes may be nested.

A class may contain private definitions:
@felix
class X {
  private var a = 1;
}
// X::a will fail, since a is private to the class X
@
A private definition is visible within the scope
of the class but not outside it.

A class must be specified within a single file.

Classes are not extensible, a definition of a class
with the same name in the same scope is not permitted.

The body of a class forms a nested scope. Within
a class all symbols defined in the class are visible,
along with all those visible in the enclosing context.

The reserved name @{root} may be used as a prefix
for the top level module:
@felix
var x = 1;
class A { var x = root::x; }
@
@h2 Open directive
The simple @{open} directive may be used to make the symbols
defined in a class visible in the scope containing the @{open} directive.
@felix
class X { var x = 1; }
open X;
println$ x;
@

Names made visible by an open directive
live in a weak scope under the current scope.
Names in the weak scope may be hidden by definitions
in the current scope without error.
@felix
class X { var x = 1; }
open X;
var x = 2;
println$ x; // prints 2
@

The open directive is not transitive.
The names it makes visible are only visible
in the scope in which the open directive is written.

@h2 Inherit directive
The inherit directive allows all of the public symbols
of a class to be included in another scope as if they
were defined in that scope. This means such names
inherited into a class can be accessed by qualification
with the inheriting class name, and will be visible
if that class is opened. 

Inheriting is transtitive.

If a name is inherited it will clash with a local definition.
@felix
class A { var a = 1; }
class B { inherit A; }
println$ B::a;
@

@h2 Rename directive
This directive is can be used to inherit a single
symbol into a scope, possibly with a new name,
and also to add an alias for a name in the current
scope.

When applied to a function name all functions with
that name are renamed.

@felix
class A { 
  var a = 1; 
  proc f() {} 
  proc f(x:int) {} 
}

class B { 
  rename a = A::a;
  rename fun f = A::f;
}
@
The new name injected by a rename may be polymorphic:
@felix
class A { proc f[T] () {} }
class B { rename g[T] = A::f[T]; } 

@h2 Use directive
This is a short form of the rename directive:
@felix
class A { var a = 1; }
class B { use A::a; use b = A::a; }
@
It cannot be applied to functions. The first
form is equivalent to
@felix
use a = A::a;
@
Unlike the rename directive the new name cannot be polymorphic
and is limited to a simple identifier.

@h2 Export directives
The @{export} directives make the exported symbol a root
of the symbol graph. 

The functional export and forces it to be place in the
generated code as an @{extern "C"} symbol with the
given name:
@felix
export fun f of (int) as "myf";
export cfun f of (int) as "myf";
export proc f of (int) as "myf";
export cproc f of (int) as "myf";
@
Functions are exported by generating a wrapper around
the Felix function. If the function is exported as @{fun}
or @{proc} the C function generated requires a pointer
to the thread frame as the first argument,
if the @{cfun} or @{cproc} forms are used, the wrapper
will not require the thread frame. 

In the latter case, the Felix function must not
require the thread frame.

A type may also be exported:
@felix
export type ( mystruct ) as "MyStruct";
@
This causes a C typedef to be emitted making 
the name @{MyStruct} an alias to the Felix type.
This is useful because Felix types can have unpredictable
mangled names.

The word @[export} optionally followed by a string
may also be used as a prefix for any Felix function,
generator, or procedure definition. If the string
is omitted is taken as the symbol name. The effect
is the same as if an export statement has been written.

@h1 Definitions
A definition is a statement which defines a name, but does
no cause any observable behavior, or, a class statement, or, 
a var or val statement. The latter two exceptions define a name
but may also have associated behaviour.

@h2 The @{var} statement
The @{var} statement is used to introduce a variable name
and potential executable behaviour. It has one of three 
basic forms:
@felix
var x : int = 1;
var y : int;
var z = 1;
@
The first form specifies the type and an initialising
expression which must be of the specified type.

The second form specifies a variable of the given type
without an explicit initialiser, however the variable
will be initialised anyhow with the default contructor
for the underlying C++ type, although that constructor
may be trivial.

The third form does not specify the type, it will be deduced
from the initialiser.

If the initialiser has observable behaviour it will be observed
if at all, when control passes through the variable statement.

If the variable introduced by the @{var} statement is not used,
the variable and its initaliser will be elided and any observable
behaviour will be lost.

To be used means to have its address taken in a used expression,
to occur in a used expression. A used expression is one which
initialises a used variable, or, is an argument to function
or generator in a used expression, or an argument to a procedure
through which control passes. 

In other words, the variable is used if the behaviour of
the program appears to depend on its value or its address.

The library procedure @{C_hack::ignore} ensures the compiler
believes a variable is used:
@felix
var x = expr;
C_hack::ignore x;
@
so that any side effects of @{expr} will be seen.
In general the argument to any primitive function, generator
or procedure will be considered used if its containing 
entity is also considered used. In general this means there
is a possible execution path from a root procedure of the
program.

A variable may have its address taken:
@felix
var x = 1;
var px = &x;
@
it may be assigned a new value directly or indirectly:
@felix
x = 2;
px <- 3;
*px = 4;
@

A variable is said to name an object, not a value.
This basically means it is associated with the address of a typed
storage location.

@h2 The @{val} statement.
A @{val} statement defines a name for an expression.
@felix
val x : int = 1;
val z = 1;
@
The value associated with a @{val} symbol may be computed
at any time between its definition and its use, and may
differ between uses, if the initialising expression depends
on variable state, such as a variable or call to a generator.

It is not an error to create such a dependence since either
the value may, in fact, not change, or the change may
not be significant.

Nevertheless the user must be warned to take care
with the indeterminate evaluation time and use
a @{var} when there is any doubt.

Since a @{val} simply names an expression, it is associated
with a value not an object and cannot be addressed
or assigned to. However this does NOT mean its value cannot
change:
@felix
for var i in 0 upto 9 do
  val x = i;
  println$ x;
done
@
In this example, x isn't mutable but it does take on
all the values 0 to 9 in succession. This is just a 
most obvious case: a less obvious one:
@felix
var i = 0;
val x = i;
println$ x;
++i;
println$ x;
@
which is clearly just an expansion of the the first two
iteration of the previously given for loop. However in
this case there is no assurance @{x} will change after @{i}
is incremented because the compiler is free to replace
any @{val} definition with a @{var} definition.

@h2 The @{goto} statement and label prefix
Felix statements may be prefixed by a label
to which control may be transfered by a @{goto}
statement:
@felix
alabel:>
  dosomething;
  goto alabel;
@
The label must be visible from the goto statement.

There are two kinds of gotos. A local goto is a jump
to a label in the same scope as the goto statement.

A non-local goto is a jump to any other visible label.

Non-local transfers of control may cross procedure
boundaries. They may not cross function or generator 
boundaries.

The procedure or function containing the label 
must be active at the time of the control transfer.

A non-local goto may be wrapped in a procedure closure
and passed to a procedure from which the goto target
is not visible.

@felix
proc doit (err: 1 -> 0) { e; }

proc outer () {
  proc handler () { goto error; }
  doit (handler);
  return;

  error:> println$ error;
}
@
This is a valid way to handle errors.
the code is correct because @{outer} is active
at the time that @{handler} performs the
control transfer.


