@title Felix Language Reference
@h1 Program structure
A Felix program consists of a nominated root parse unit and
the transitive closure of units with respect to inclusion.

The behaviour of this system consists of the action of the
initialisation code in each unit, performed in sequence
within a given unit, with the order of action between
units unspecified.

@h2 Parse Unit
A parse unit is a file augmented by prefixing specified import
files to the front. These consist of a suite of grammar files
defining the syntax and other files defining macros.

By convention import files have the extension @{.flxh}.

With this augmentation all parse units in a program
are independently parsed to produce an list of statements
represented as abstract syntax, denoted an AST (even
though it is a list of trees, not a single tree).

@h2 AST
The program consists of the concatenation of the ASTs
of each parse unit, resulting in a single AST, which
is then translated to a C++ translation unit by the
compiler.

@h1 Grammar
The Felix grammar is part of the library.
It is notionally prefixed to each file to be processed
prior to any import files to specify the syntax
with which the file is to be parsed and translated to
an AST.

The grammar uses an augmented BNF like syntax
with parse actions specified in R5RS Scheme.

The resulting S-expressions are translated to
an intermediate form and then into an internal
AST structure.

The parser is a scannerless GLR parser with significant
extensions.

@h2 Grammar syntax
Not written yet. Browse the 
<a href=/share/lib/grammar>grammar directory</a> 
for examples.

@h2 Modules
Every Felix program is encapsulated in a module with
the name being a mangle of the basename of the root unit.
The mangling replaces characters in the filename with
other characters so that the module name is a valid
ISO C identifier.

@h2 Special procedure @{flx_main}
A program module may contain at most one top level
procedure named @{flx_main}. After initialisation 
code suspends or terminates, this procedure is invoked
if it exists. It is the analogue of @{main} in C++
however it is rarely used: side-effects of the
root units initialisation code are typically used instead.

@h2 Libraries
In Felix a library is a root unit together with its
transitive closure with respect to inclusion,
which does not contain a top level @{flx_main}.

A program unit can be augmented by a set of libraries
which are then considered as if included, but without
an include directive being present.


@h1 Lexicology
All Felix files are considered to be UTF-8 encoded Unicode.

Felix uses a scannerless parser, there are no keywords.

@h2 Identifiers
A plain identifier starts with a letter or underscore,
then consists of a sequence of letters, digits, apostrophy, has no more
than one apostrophy or dash in a row, except at the end no dash is
allowed, and any number of apostrophies.
@felix
Ab_cd1  a' b-x
@
Identifies starting with underscore are reserved for the implementation.

A letter may be any Unicode character designated for use in an identifier
by the ISO C++ standard. In practice, all high bit set octets are allowed.

A TeX identifier starts with a slosh and is followed by a sequence
of letters. 
@
@h2 Integer Literals
An plain integer literal consists of a sequence of digits,
optionally separated by underscores. Each separating
underscore must be between digits.

A prefixed integer literal is a plain integer literal
or a plain integer literal prefixed by a radix specifier.
The radix specifier is a zero followed by one of
the letters @{bBoOdDxX} for binary, octal, decimal or hex.

An underscore is permitted after the prefix.

The radix is the one specified by the prefix or decimal
by default.

The digits of an integer consist of those permitted
by the radix: @{01 for binary}, @{01234567}
for octal, @{0123456789} for decimal, @{0123456789abcdefABCDEF}
for hex.

Note there are no negative integer literals.

A type suffix may be added to the end of a prefixed
integer to designate a literal of a particular integer type,
it has the form of an upper or lower case letter or pair of
letters usually combined with a prefix or suffix @{u} or @{U}
to designate an unsigned variant of the type. A table
of suffices and the types they signify follows in lower case:
@pre
i8
i16
i32
i64
u8
u16
u32
u64

t
s
l
ll
ut tu
us su
ul lu
ull llu

z uz
...
@ 

@h2 Floating point Literals
TBD
@h2 String literals
TBD
@h2 Format literals
TBD
 
@h2 Include Directive
An include directive has the syntax:
@felix
include "filename";
@
where the filename is a Unix relative filename,
may not have an extension, and may not begin with or 
contain @{..} (two dots).

If the filename begins with @{./} then the balance of the name
is relative, a sibling of the including file, otherwise the name
is searched for on an include path. 

In either case, a search succeeds when it finds a file with
the appropriate base path in the search directory with
extension @{.flx} or {.fdoc}. If both files exist the
most recently changed one is used. If the time stamps are
the same the choice is unspecified.


@h1 Macro val
TBD
@h1 Macro for
TBD
@h1 Conatsnt folding and conditional comopilation
TBD
@h1 General lookup
By default Felix looks up symbols in nested scopes, 
starting with all symbols in the current scope
and proceeding through its containing scope outwards
until the outermost scope is reached.

Symbols are visible in the whole of a scope,
both before and after their introduction.

A symbol lookup may properly find either a single
non-function symbol, which is final, or a set 
of function symbols.

If the kind of symbol being sought is a function 
symbol, overload resolution is performed on 
the set of function signatures found in a scope.
If a best match is found, that is final.
If no match is found the search continues in 
the next outermost scope.

All other cases are in error.

@h1 Classes
The top level Felix module can contain submodules 
which are specified by a non-polymorphic class
statement:
@felix
class classname { ... }
@
The effect is to produce a qualified name to be used
outside the class:
@felix
class classname { proc f () {} }
classname::f (); 
@
Classes may be nested.

A class may contain private definitions:
@felix
class X {
  private var a = 1;
}
// X::a will fail, since a is private to the class X
@
A private definition is visible within the scope
of the class but not outside it.

A class must be specified within a single file.

Classes are not extensible, a definition of a class
with the same name in the same scope is not permitted.

The body of a class forms a nested scope. Within
a class all symbols defined in the class are visible,
along with all those visible in the enclosing context.

The reserved name @{root} may be used as a prefix
for the top level module:
@felix
var x = 1;
class A { var x = root::x; }
@
@h1 Lookup control directives

@h2 Open directive
The simple @{open} directive may be used to make the symbols
defined in a class visible in the scope containing the @{open} directive.
@felix
class X { var x = 1; }
open X;
println$ x;
@

Names made visible by an open directive
live in a weak scope under the current scope.
Names in the weak scope may be hidden by definitions
in the current scope without error.
@felix
class X { var x = 1; }
open X;
var x = 2;
println$ x; // prints 2
@

The open directive is not transitive.
The names it makes visible are only visible
in the scope in which the open directive is written.

@h2 Inherit directive
The inherit directive allows all of the public symbols
of a class to be included in another scope as if they
were defined in that scope. This means such names
inherited into a class can be accessed by qualification
with the inheriting class name, and will be visible
if that class is opened. 

Inheriting is transtitive.

If a name is inherited it will clash with a local definition.
@felix
class A { var a = 1; }
class B { inherit A; }
println$ B::a;
@

@h2 Rename directive
This directive is can be used to inherit a single
symbol into a scope, possibly with a new name,
and also to add an alias for a name in the current
scope.

When applied to a function name all functions with
that name are renamed.

@felix
class A { 
  var a = 1; 
  proc f() {} 
  proc f(x:int) {} 
}

class B { 
  rename a = A::a;
  rename fun f = A::f;
}
@
The new name injected by a rename may be polymorphic:
@felix
class A { proc f[T] () {} }
class B { rename g[T] = A::f[T]; } 

@h2 Use directive
This is a short form of the rename directive:
@felix
class A { var a = 1; }
class B { use A::a; use b = A::a; }
@
It cannot be applied to functions. The first
form is equivalent to
@felix
use a = A::a;
@
Unlike the rename directive the new name cannot be polymorphic
and is limited to a simple identifier.

@h2 Export directives
The @{export} directives make the exported symbol a root
of the symbol graph. 

The functional export and forces it to be place in the
generated code as an @{extern "C"} symbol with the
given name:
@felix
export fun f of (int) as "myf";
export cfun f of (int) as "myf";
export proc f of (int) as "myf";
export cproc f of (int) as "myf";
@
Functions are exported by generating a wrapper around
the Felix function. If the function is exported as @{fun}
or @{proc} the C function generated requires a pointer
to the thread frame as the first argument,
if the @{cfun} or @{cproc} forms are used, the wrapper
will not require the thread frame. 

In the latter case, the Felix function must not
require the thread frame.

A type may also be exported:
@felix
export type ( mystruct ) as "MyStruct";
@
This causes a C typedef to be emitted making 
the name @{MyStruct} an alias to the Felix type.
This is useful because Felix types can have unpredictable
mangled names.

The word @[export} optionally followed by a string
may also be used as a prefix for any Felix function,
generator, or procedure definition. If the string
is omitted is taken as the symbol name. The effect
is the same as if an export statement has been written.


@h1 Variable Definitions
A definition is a statement which defines a name, but does
no cause any observable behavior, or, a class statement, or, 
a var or val statement. The latter two exceptions define a name
but may also have associated behaviour.

@h2 The @{var} statement
The @{var} statement is used to introduce a variable name
and potential executable behaviour. It has one of three 
basic forms:
@felix
var x : int = 1;
var y : int;
var z = 1;
@
The first form specifies the type and an initialising
expression which must be of the specified type.

The second form specifies a variable of the given type
without an explicit initialiser, however the variable
will be initialised anyhow with the default contructor
for the underlying C++ type, although that constructor
may be trivial.

The third form does not specify the type, it will be deduced
from the initialiser.

If the initialiser has observable behaviour it will be observed
if at all, when control passes through the variable statement.

If the variable introduced by the @{var} statement is not used,
the variable and its initaliser will be elided and any observable
behaviour will be lost.

To be used means to have its address taken in a used expression,
to occur in a used expression. A used expression is one which
initialises a used variable, or, is an argument to function
or generator in a used expression, or an argument to a procedure
through which control passes. 

In other words, the variable is used if the behaviour of
the program appears to depend on its value or its address.

The library procedure @{C_hack::ignore} ensures the compiler
believes a variable is used:
@felix
var x = expr;
C_hack::ignore x;
@
so that any side effects of @{expr} will be seen.
In general the argument to any primitive function, generator
or procedure will be considered used if its containing 
entity is also considered used. In general this means there
is a possible execution path from a root procedure of the
program.

A variable may have its address taken:
@felix
var x = 1;
var px = &x;
@
it may be assigned a new value directly or indirectly:
@felix
x = 2;
px <- 3;
*px = 4;
@

A variable is said to name an object, not a value.
This basically means it is associated with the address of a typed
storage location.

@h3 Multiple variables
Multipls variables can be defined at once:
@felix
var m = 1,2;
var a,b = 1,2;
var c,d = m;
@
With this syntax, no type annotation may be given.

@h2 The @{val} statement.
A @{val} statement defines a name for an expression.
@felix
val x : int = 1;
val z = 1;
@
The value associated with a @{val} symbol may be computed
at any time between its definition and its use, and may
differ between uses, if the initialising expression depends
on variable state, such as a variable or call to a generator.

It is not an error to create such a dependence since either
the value may, in fact, not change, or the change may
not be significant.

Nevertheless the user must be warned to take care
with the indeterminate evaluation time and use
a @{var} when there is any doubt.

Since a @{val} simply names an expression, it is associated
with a value not an object and cannot be addressed
or assigned to. However this does NOT mean its value cannot
change:
@felix
for var i in 0 upto 9 do
  val x = i;
  println$ x;
done
@
In this example, x isn't mutable but it does take on
all the values 0 to 9 in succession. This is just a 
most obvious case: a less obvious one:
@felix
var i = 0;
val x = i;
println$ x;
++i;
println$ x;
@
which is clearly just an expansion of the the first two
iteration of the previously given for loop. However in
this case there is no assurance @{x} will change after @{i}
is incremented because the compiler is free to replace
any @{val} definition with a @{var} definition.

@h3 Multiple values
Multipls values can be defined at once:
@felix
val m = 1,2;
val a,b = 1,2;
val c,d = m;
@
With this syntax, no type annotation may be given.



@h1 Functions
A felix function definition takes one of three basic forms:
@felix
fun f (x:int) = { var y = x + x; return y + 1; }
fun g (x:int) => x + x + 1;
fun h : int -> int = | ?x => x + x + 1;
@
The first form is the most general, the body 
of the function contains executable statements
and the result is returned by a return statement.

The second form is equivalent to a function in the first
form whose body returns the RHS expression.

The third form specifies the function type then the
body of a pattern match. It is equivalent to
@felix
fun h (a:int) = { return match a with | ?x => x + x + 1 endmatch; }
@
The first two forms also allow the return type to be
specified:
@felix
fun f (x:int) : int = { var y = x + x; return y + 1; }
fun g (x:int) :int => x + x + 1;
@

Functions may not have side effects.

All these function have a type:
@felix
D -> C
@
where D is the domain and C is the codomain: both would
be @[int} in the examples.

A function can be applied by the normal forward
notation using juxtaposition or what is whimsically
known as operator whitespace, or in reverse notation
using operator dot:
@felix
f x
x.f
@
Such applications are equivalent.  Both operators are left
associative. Operator dot binds more
tightly than whitespace so that
@felix
f x.g    // means
f (g x)
@

A special notation is used for application to the unit tuple:
@felix
#zero // means
zero ()
@
The intention is intended to suggest a constant since a pure
function with unit argument must always return the
same value. 

This hash operator binds more tightly than operator dot so
@felix
#a.b // means
(#a).b
@


@h2 Pre- and post-conditions
A function using one of the first two forms
may have pre-conditions, post-conditions, or both:
@felix
fun f1 (x:int when x > 0) => x + x + 1;
fun f2 (x:int) expect result > 1 => x + x + 1;
fun f3 (x:int when x > 0) expect result > 1 => x + x + 1;
@
Pre- and pos-conditions are usually treated as boolean assertions
which are checked at run time. The compiler may occasionally be able
to prove a pre- or post-condition must hold and elide it.

The special identifier @{result} is used to indicate the return
value of the function.

@h2 Higher order functions
A function may be written like
@felix
fun hof (x:int) (y:int) : int = { return x + y; }
fun hof (x:int) (y:int) => x + y;
@
These are called higher order functions of arity 2.
They have the type
@felix
int -> int -> int   // or equivalently
int -> (int -> int) //since -> is right associative.
@
They are equivalent to
@felix
fun hof (x:int) : int -> int = 
{
  fun inner (y:int) : int => x + y;
  return inner;
}
@
that is, a function which returns another function.

Such a function can be applied like
@felix
hof 1 2 // or equivalently
(hof 1) 2
@
since whitespace application is left associative.

@h2 Procedures
A function which returns control but no value is called a procedure.
Procedures may have side effects.
@felix
fun show (x:int) : 0 = { println x; }
proc show (x:int) { println x; }
proc show (x:int) => println x;
@
The second form is a more convenient notation.
The type 0 is also called @{void} and denotes
a type with no values.

A procedure may return with a simple return statement:
@felix
proc show (x:int) { println x; return; }
@
however one is assumed at the end of the procedure
body .

Procedures can also have pre- and post-conditions.

A procedure may be called like an application,
however it must be a whole statement since
expressions of type void may not occur interior
to an expression.
@felix
show 1;
1.show;
@
If a procedure accepts the unit argument, it may be elided:
@felix
proc f () =>  show 1;
f; // equivalent to
f ();
@

@h2 Generators
TBD

@h1 Types
@h2 Primitives
TBD
@h3 cenum
TBD
@h3 cstruct
TBD
@h3 ctypes
TBD
@h3 cflags
TBD
@h2 Tuples
TBD
@h2 Records
TBD
@h2 Structs
TBD
@h2 Sums
TBD
@h3 union
TBD
@h2 enum
TBD
@h2 variant
TBD
@h2 Array
TBD
@h2 typedef
TBD
@h3 typedef fun
TBD
@h2 typematch
TBD
@h2 type sets
TBD

@h2 Abstract types
TBD

@h1 Expressions
TBD

@h1 Executable statements
@h2 Assignment
TBD

@h2 The @{goto} statement and label prefix
Felix statements may be prefixed by a label
to which control may be transfered by a @{goto}
statement:
@felix
alabel:>
  dosomething;
  goto alabel;
@
The label must be visible from the goto statement.

There are two kinds of gotos. A local goto is a jump
to a label in the same scope as the goto statement.

A non-local goto is a jump to any other visible label.

Non-local transfers of control may cross procedure
boundaries. They may not cross function or generator 
boundaries.

The procedure or function containing the label 
must be active at the time of the control transfer.

A non-local goto may be wrapped in a procedure closure
and passed to a procedure from which the goto target
is not visible.

@felix
proc doit (err: 1 -> 0) { e; }

proc outer () {
  proc handler () { goto error; }
  doit (handler);
  return;

  error:> println$ error;
}
@
This is a valid way to handle errors.
the code is correct because @{outer} is active
at the time that @{handler} performs the
control transfer.
@h3 halt
Stops the program with a diagnostic.
@felix
halt "Program complete";
@

@h3 try/catch/entry
The try/catch construction may only be user to wrap
calls to C++ primitives, so as to catch exceptions.
@felix
proc mythrow 1 = "throw 0;";
try
   mythrow;
catch (x:int) =>
   println$ "Caughht integer " + x.str;
endtry
@

@h3 goto-indirect/label_address
The @{label-address} operator captures the address
of code at a nominated label. 

The address has type @{LABEL} and can be stored in a variable.

Provided the activation record of the procedure containing
the label remains live, a subsequent @{goto-indirect) can
be used to jump to that location.

@felix
proc demo (selector:int) {
  var pos : LABEL = 
    if selector == 1 
    then label_address lab1
    else label_address lab2
    endif
  ;
  goto-indirect selector;
lab1:>
  println$ "Lab1"; return;
lab2:>
  println$ "Lab2"; return;
}
@

@h3 Exchange of control
TBD
@h2 match/endmatch
TBD
@h2 if/goto
The conditional goto is an abbreviation for 
the more verbose conditional:
@felix
if c goto lab; // equivalent to
if c do goto lab; done
@

@h3 if/return
The conditional return is an abbreviation for
the more verbose conditional:
@felix
if c return; // equivalent to
if c do return; done
@

@h3 if/call
The conditional call is an abbreviation for
the more verbose conditional:
@felix
if c call f x; // equivalent to
if c do call f x; done
@


@h2 if/do/elif/else/done
The procedural conditional branch is used to select
a control path based on a boolean expression.

The @{else} and @{elif} clauses are optional.
@felix
if c1 do 
  stmt1;
  stmt2;
elif c2 do
  stmt3;
  stmt4;
else
  stmt5;
  stmt6;
done
@

The @{elif} clause saves writing a nested conditional.
The above is equivalent to:
@felix
if c1 do 
  stmt1;
  stmt2;
else 
  if c2 do
    stmt3;
    stmt4;
  else
    stmt5;
    stmt6;
  done
done
@
One or more statements may be givn in the selected control path.

A simple conditional is an abbreviation for a statement match:
@felix
if c do stmt1; stmt2; else stmt3; stmt4; done
// is equivalent to
match c with
| true => stmt1; stmt2; 
| false => stmt3; stmt4;
endmatch;
@

@h2 call
The @{call} statement is used to invoke a procedure.
@felix
proc p(x:int) { println$ x; }
call p 1;
@
The word @{call} may be elided in a simple call:
@felix
p 1;
@
If the argument is of unit type; that is, it is the
empty tuple, then the tuple may also be elided in
a simple call:
@felix
proc f() { println$ "Hi"; }
call f (); // is equivalent to
f(); // is equivalent to
f;
@

@h2 procedure return
The procedural return is used to return control
from a procedure to its caller.

A return is not required at the end of a procedure
where control would otherwise appear to drop through,
a return is assumed:
@felix
proc f() { println$ 1; }
// equivalent to
proc f() { println$ 1; return; }
@

@h3 return from
The return from statement allows control to be
returned from an enclosing procedure, provided that
procedure is active.
@felix
proc outer () {
  proc inner () {
     println$ "Inner";
     return from outer;
  }
  inner;
  println$ "Never executed";
}
@

@h3 jump 
The procedural jump is an abbreviation for 
the more verbose sequence:
@felix
jump procedure arg; // is equivalent to
call procedure arg;
return;
@

@h2 function return
The functional return statement returns a value from
a function.
@felix
fun f () : int = {
  return 1;
}
@
Control may not fall through the end of a function.

@h3 yield
The yield statement returns a value from a generator
whilst retaining the current location so that execution
may be resumed at the point after the yield.

For this to work a closure of the generator must be stored
in a variable which is subsequently applied.
@felix
gen counter () = { 
  var x = 0;
next_integer:>
  yield x;
  ++x;
  goto next_integer;
}

var counter1 = counter;
var zero = counter1 ();
var one = counter1 ();
println$ zero, one;
@


@h2 spawn_fthread
The @{spawn_fthread} library function invokes the corresponding
service call to schedule the initial continuation of a procedure 
taking a unit argument as an fthread (fibre). 

The spawned fthread begins executing immediately.
If coutrol returns before yielding by a synchronous
channel operation, the action is equivalent to calling
the procedure.

Otherwise the spawned fthread is suspended when the first
write, or the first unmatched read operation occurs.


@h3 read/write/broadcast schannel
TBD
@h2 spawn_pthread
TBD
@h3 read/write pchannel
TBD
@h3 exchange

@h1 loops
Felix has some low level and high level loop constructions.

The low level for, while, and repeat loops are equivalent
to loops implemented with gotos.

The bodies of do loops do not constitute a scope,
therefore any symbol defined in such a body is also visible
in the surrounding code.

Low level loops may be labelled with a loop label
which is used to allow break, continue, and redo
statements to exit from any containing loop.

@felix
outer:for var i in 0 upto 9 do
   inner: for var j in 0 upto 9 do
     println$ i,j;
     if i == j do break inner; done
     if i * j > 60 do break outer; done
   done
done
@

@h2 redo
The redo statement causes control to jump to the start
of the specified loop without incrementing the control variable.

@h2 break
The break statement causes control to jump past the end of
the specified loop, terminating iteration.

@h2 continue
The continue statement causes the control variable to
be incremented and tests and the next iteration commenced
or the loop terminated.

@h2 for/in/upto/downto/do/done
A basic loop with an inclusive range.
@felix
// up
for var ti:int in 0 upto 9 do println$ ti; done
for var i in 0 upto 9 do println$ i; done
for i in  0 upto 9 do println$ i; done

// down
for var tj:int in 9 downto 0 do println$ j; done
for var j in 9 downto 0 do println$ j; done
for j in  0 upto 9 do println$ j; done
@
The start and end expressions must be of the same type.

If the control variable is defined in the loop with a type
annotation, that type must agree with the control variable.

The type must support comparison with the equality operator @{==}
the less than or equals operator @{<=} and increment with 
the pre increment procedure @{++}.

For loops over unsigned types cannot handle the empty case.
For loops over signed types cannot span the whole range of the type.

The loop logic takes care to ensure the control variable is not
incremented (resp. decremented) past the end (resp.start) value.

@h2 while/do/done
The while loop executes the body repeatedly whilst the control
condition is true at the start of the loop body.
@felix
var i = 0;
while i < 10 do println$ i; ++i; done
@

@h2 until loop
The until loop executes the loop body repeatedly
until the control condition is false at the start of the loop,
it is equivalent o a while loop with a negated condition.
@felix
var i = 0;
until i == 9 do println$ i; ++i; done
@

@h2 for/match/done
TBD
@h2 loop
TBD
@h2 assert
TBD
@h2 axiom
TBD
@h2 lemma
TBD
@h2 theorem
TBD
@h2 reduce
TBD
@h2 invariant
TBD
@h2 code
TBD
@h3 noreturn code
TBD
@h2 Service call
TBD


@h2 with/do/done
TBD
@h2 do/done
TDB
@h2 begin/end
TDB
@h1 C bindings
TBD
@h1 Domain Specific Sublanguages
@h2 Regexps
TBD
@h2 Pipelines
TBD





