@title Sieve of Eratosthenes
@h1 Sieve of Eratosthenes

@felix

fun range (l:int) (u:int) =
{
  fun range_aux (acc:list[int]) (x:int) (y:int) =>
    if x == y then acc
    else range_aux (acc + list[int](x)) (x + 1) y
    endif;

  return range_aux (list[int] ()) l u ;
}

fun filter (test:int->bool) (s:list[int]) =
{
  fun f (acc:list[int]) (e:int) =>
     if not (test e) then acc 
     else acc + list[int](e)
     endif;

  return List::fold f (list[int]()) s;
}

typedef il_t = int * list[int];

proc client (x:ischannel[il_t], y:oschannel[il_t])
{
  p, l := read x;
  var s = filter (fun (e:int) => (e%p != 0 or e/p == 1)) l;
  var r = filter (fun (e:int) => e > p) s;
  if len r == 0uz do
     write$ y, (0, l); //We're done
  else
     inp,out:=#mk_ioschannel_pair[il_t];
     spawn_fthread { client (inp, y); };
     write$ out, (r.0, s);
  done
}

proc launch ()
{
  inp,out:=#mk_ioschannel_pair[il_t];
  spawn_fthread { client (inp, out); };

  val k = 5000; //Run with FLX_MIN_MEM=500 (MB) for k=5000
  var l =range 2 (k + 1);
  write$ out, (2, l);

  val i, res = read inp;
  println$ "Primes: " + str k + " are " + str (res);
}

launch;


