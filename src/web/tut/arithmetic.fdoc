// /home/fletch/project/felix.git/build/release/host/bin/flx --force --echo --test=build/release src/web/tut/arithmetic.fdoc
//
//To understand segfaults you do this:
//  (a) Run flx with --force and --echo
//        This tells you the name of the C++ file in the cache
//        Now edit the C++ file with your text editor to put printf()
//        statements in various places.
//
//  (b) Run flx again with --nofelix option
//        That stops the flxg compiler running so it doesn't clobber
//        your edits to the C++ file.
//
//You can then put Felix prints between the steps, this prints debug
//stuff to show progress AND it put the prints in the C++ so you can
//more easily find where you're up to.

//Some more notes:

//Compare this code against the 'E_let' case in 'eval' which uses a
//"short form syntax"
//
// let v = eval env e in #{ env <- (tag, v) ! (deref env); return v; } 
//

//Notice also 'deref' is used here since '*' is hidden by the syntax
//definition in effect for 'zero_or_more'.
//
//
//This can be addressed in the future using the approach taken
//by regdefs (see
//http://felix-lang.org/$/usr/local/lib/felix/felix-latest/share/lib/grammar/regexps.fsyn
//which uses a postfix '*'.
//
//"If you use a DSSL you can do like regdefs but then you have to
//"unquote" to get back to standard notation i.e. you introduce by pcomb
//(expr) pcomb switches syntax then you need in that syntax felix (expr)
//to switch back eg you can do pcomb ( a b c \ d* ) if you get my drift:
//you have a parser combinator language, there's no interaction with any
//Felix operators at all."

// --

//Result of a parse
union parsed[A, B] = 
  | Returns of B * list[A] 
  | Parse_failed
  ;

struct myunit_t {};
var myunit_v = myunit_t ();

//Type of a parser
typedef parser[A, B] = list[A] -> parsed[A, B];

fun just_unit[A] ()(toks:list[A]):parsed[A, myunit_t] => 
  Returns (myunit_v, toks) 
;

//Emtpy string parser
fun empty[A, B] (v:B)(toks:list[A]):parsed[A, B] => 
  Returns (v, toks)
  ;

//Given a predicate, produce a parser
fun token[A, B](test:A->opt[B]):parser[A,B] =>
  fun (l:list[A]):parsed[A, B] => 
    match l with
    | Cons (t, ts) =>
        match test t with
        | Some r => Returns[A, B] (r, ts)
        | #None => Parse_failed[A, B]
        endmatch
    | #Empty => Parse_failed[A, B]
    endmatch
  ;

//Parser of a specific token
fun char_[A with Eq[A]] (ch:A):parser[A, A] =>
  token (
  fun (tok:A):opt[A] =>
    match tok with
      | c when (c == ch) => Some ch
      | _ => None[A]
    endmatch
  )
  ;

//Parser disjunction
fun orelse[A, B] (p1:parser[A, B], p2:parser[A, B]):parser[A, B] =>
   fun (toks:list[A]):parsed[A, B] =>
      match p1 toks with
        | #Parse_failed => p2 toks
        | res => res
      endmatch
  ;

//Parser conjunction
fun andalso[A, B, C] (p1:parser[A, B],p2:parser[A, C]):parser[A, (B * C)] =>
  fun (toks:list[A]) : parsed[A, (B * C)]=>
    match p1 toks with
      | Returns (r1, toks1) =>
          match p2 toks1 with
            | Returns (r2, toks2) => Returns ((r1, r2), toks2)
            | _ => Parse_failed[A, (B * C)]
          endmatch
      | _ => Parse_failed[A, (B * C)]
    endmatch
  ;

//Transform the result of a parse
fun gives[A, B, C] (p:parser[A, B], f:B ->C):parser[A, C] =>
  fun (toks:list[A]):parsed[A, C] =>
    match p toks with
      | Returns (v, toks1) => Returns (f v, toks1)
      | _ => Parse_failed[A, C]
   endmatch
  ;

//Infix operators
syntax infix_c
{
  //orelse
  x[ssetunion_pri] := 
   x[ssetunion_pri] "|~" x[>ssetunion_pri] =># 
    '''`(ast_apply ,_sr (,(nos "orelse") (,_1 ,_3)))'''
  ;

  //andalso
  x[ssetintersection_pri] := 
   x[ssetintersection_pri] "&~" x[>ssetintersection_pri] =># 
    '''`(ast_apply ,_sr (,(nos "andalso") (,_1 ,_3)))'''
  ;

  //gives
  x[scomparison_pri]:= 
   x[scomparison_pri] ">=~" x[>scomparison_pri] =># 
    '''`(ast_apply ,_sr (,(nos "gives") (,_1 ,_3)))'''
  ;

  //givento
  x[scomparison_pri]:= 
   x[scomparison_pri] ">>=~" x[>scomparison_pri] =># 
    '''`(ast_apply ,_sr (,(nos "givento") (,_1 ,_3)))'''
  ;

}

open syntax infix_c;

//Kleene '*'
fun zero_or_more[A, B] (p:parser[A, B]): parser[A, list[B]] =>
  fun (toks:list[A]) : parsed[A, list[B]] =>
   (gives (p &~ (zero_or_more p), 
         (fun (res:(B * list[B])) : list[B] => Cons (res.0, res.1)))
  |~ (empty[A, list[B]] (list[B]()))) toks
;

syntax prefix_c 
{
  //zero_or_more
  x[srefr_pri] := "*" x[srefr_pri] =># "(prefix 'zero_or_more)";
}

open syntax prefix_c;

//Check if a character is a member of one of the provided ranges
fun char_range (c:char)(l:list[char * char]):bool =>
  match l with
    | #Empty => false
    | Cons ((c1, c2), tl) =>    
       (ord c1 <= ord c and ord c <= ord c2) or char_range c tl
  endmatch
  ;

//An element of the alphabet
var letter : parser[char, char] =
  token (fun (c:char) => 
           if char_range c 
            (list[char*char](
             (char 'a', char 'z'), 
            (char 'A', char 'Z'))) 
           then Some c else None[char])
  ;

//Digit parser
var digit : parser[char, char] = 
  token (fun (c:char) : opt[char] => if isdigit c then Some c else None[char])
  ;

//Parser of a sequence of digit
var digits : parser[char, list[char]] = 
  (digit &~ *digit) >=~ 
    (fun (p:char*list[char]):list[char] => Cons (p.0,p.1))
  ;

// '-' | '+' | eps
var optsign : parser[char, list[char]] =
  token (fun (c:char):opt[list[char]] =>
    match c with
    | c when c == char '-' => Some (list[char] (c))
    | c when c == char '+'=> Some (list[char] (c))
    | _ => None[list[char]]
   endmatch) |~ empty[char, list[char]] (list[char] ())
  ;

// '.' digit* | eps
var optfrac : parser[char, list[char]] =
  ((char_ (char '.') &~ *digit) >=~ (fun (p:char*list[char]):list[char] => Cons (p.0,p.1)))
  |~ empty[char, list[char]] (list[char] ())
  ;

//(('e'|'E') optsign digits)|eps
var optexp : parser[char, list[char]] =
  (((((char_ (char 'e') |~ char_ (char 'E')) &~ optsign) 
    >=~ (fun (p:char * list[char]):list[char] => Cons (p.0,p.1))) &~ digits) 
    >=~ (fun (x:list[char], y:list[char]) : list[char] => x + y)) 
  |~ empty[char, list[char]] (list[char] ())
;

//Tokens
union token_t  =
  | T_num of double
  | T_ident of string
  | T_lparen | T_rparen
  | T_plus | T_minus | T_star | T_slash | T_semicolon | T_equal
  ;

//Explode a string into a list of char
fun explode (s:string):list[char] =
{
  val n:size = len s;
  fun loop (acc:list[char]) (i:size) : list[char] =>
    if (i == n) then rev acc
    else loop (Cons (s.[i], acc)) (i + 1)
  ;
  return loop (list[char]()) 0uz;
};

//Implode a list of char to a string
fun implode (xs:list[char]) =>
  fold_left (fun (a:string) (b:char):string => a + b) "" xs
  ;

//Number token
var number:parser[char, token_t] =
  (digits &~ optfrac &~ optexp) >=~
    (fun (p:list[char] * list[char], cse:list[char]):token_t =>
      T_num (atof (implode (p.0 + p.1 + cse))))
  ;

//Identifier token
var identifier : parser[char, token_t] =
  (letter &~ (zero_or_more letter)) >=~ 
    (fun (c:char, cs:list[char]):token_t => 
       T_ident (implode (Cons (c, cs))))
  ;

//Operator token
var operator : parser[char, token_t] =
  token (fun (ch:char) : opt[token_t] =>
    match ch with
    | c when c == char '-' => Some T_minus
    | c when c == char '+' => Some T_plus
    | c when c == char '*' => Some T_star
    | c when c == char '/' => Some T_slash
    | _ => None[token_t]
    endmatch
  );

//Parenthesis token
var paren : parser[char, token_t] =
  token (fun (ch:char) : opt[token_t] =>
    match ch with
    | c when c == char '(' => Some T_lparen
    | c when c == char ')' => Some T_rparen
    | _ => None[token_t]
    endmatch
  );

//Equal token
var equal : parser[char, token_t] =
  token (fun (ch:char) : opt[token_t] =>
  match ch with
  | c when c == '=' => Some T_equal
    | _ => None[token_t]
    endmatch
  );

//Semicolon token
var semicolon : parser[char, token_t] =
  token (fun (ch:char) : opt[token_t] =>
  match ch with
  | c when c == ';' => Some T_equal
    | _ => None[token_t]
    endmatch
  );

//Parse a whitespace character
var space_ : parser[char, myunit_t] =
 token (fun (ch:char) : opt[myunit_t] =>
   match ch with
     | c when c == char ' ' => Some[myunit_t] myunit_v
     | c when c == char '\t' => Some[myunit_t] myunit_v
     | c when c == char '\n' => Some[myunit_t] myunit_v
     | c when c == char '\r' => Some[myunit_t] myunit_v
     | _ => None[myunit_t]
   endmatch
  );


//Parser of whitespace
fun spaces (toks:list[char]) : parsed[char, myunit_t] =>
  (((space_ &~ spaces) >=~ (fun (u:myunit_t, v:myunit_t):myunit_t => myunit_v))
    |~ empty[char, myunit_t](myunit_v))
  toks
  ;

//Lexer for the language of arithmetic expressions
fun lex (toks : list[char]) : parsed [char, list[token_t]] =>
    (spaces &~ 
    *(((identifier |~ number |~ operator |~ paren |~ semicolon |~ equal) &~ spaces) >=~ 
    (fun (tok:token_t, _:myunit_t) : token_t => tok)) >=~ (fun (u:myunit_t, ts:list[token_t]) : list[token_t] => ts)) toks
  ;

//Arithmetic expressions
union ast_t =
  | E_const of double
  | E_var of string
  | E_add of ast_t * ast_t
  | E_sub of ast_t * ast_t
  | E_mul of ast_t * ast_t
  | E_div of ast_t * ast_t
  | E_let of (string * ast_t)
  ;

//Constants
val num:parser[token_t, ast_t] =
  token (
    fun (t:token_t):opt[ast_t] =>
      match t with
        | T_num n => Some (E_const n)
        | _ => None[ast_t]
      endmatch
  );

//Identifiers
val ident:parser[token_t, ast_t] =
  token (
    fun (t:token_t):opt[ast_t] =>
      match t with
        | T_ident s => Some (E_var s)
        | _ => None[ast_t]
  );

//Addition, subtraction operators
val addop:parser[token_t, ast_t -> ast_t -> ast_t] =
  token (
    fun (t:token_t):opt[ast_t -> ast_t -> ast_t] =>
      match t with
        | T_plus => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_add (e1, e2))
        | T_minus => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_sub (e1, e2))
        | _ => None[ast_t -> ast_t -> ast_t]
        endmatch
  );

//Multiplication, division operators
val mulop:parser[token_t, ast_t -> ast_t -> ast_t] =
  token (
    fun (t:token_t):opt[ast_t -> ast_t -> ast_t] =>
      match t with
        | T_star => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_mul (e1, e2))
        | T_slash => Some (fun (e1:ast_t)(e2:ast_t):ast_t => E_div (e1, e2))
        | _ => None[ast_t -> ast_t -> ast_t]
        endmatch
  );

//A parser that feeds its result into another
fun givento[A, B, C] (p1:parser[A, B], p2:B -> parser[A, C]) : parser[A, C] =>
  fun (toks : list[A]) : parsed[A, C] =>
     match p1 toks with
      | Returns (r1, toks1) => p2 r1 toks1
      | #Parse_failed => Parse_failed[A, C]
     endmatch
    ;

//Build left-associative trees e.g. expr := term (op term)*
fun left_assoc[A, B] 
  (term : parser[A, B]) 
  (op : parser[A, B -> B-> B]) : parser[A, B] =
{
  fun sequence (t1:B) : parser [A, B] =
  {
    return (op &~ term >=~ (fun (f:B -> B -> B, t2:B) => f t1 t2) >>=~ sequence of (B)) |~ (empty[A, B] t1);
  }

  return (term >>=~ sequence);
}

//Opening paren
var open_paren : parser[token_t, myunit_t] =
  token (fun (tok : token_t) : opt[myunit_t] =>
  match tok with
  | #T_lparen => Some (myunit_v)
  | _ => None[myunit_t]
  endmatch)
  ;

//Closing paren
var close_paren : parser[token_t, myunit_t] =
  token (fun (tok : token_t) : opt[myunit_t] =>
  match tok with
  | #T_rparen => Some (myunit_v)
  | _ => None[myunit_t]
  endmatch)
  ;

//Semi-colon
var semi : parser[token_t, myunit_t] =
  token (fun (tok : token_t) : opt[myunit_t] =>
  match tok with
  | #T_semicolon => Some (myunit_v)
  | _ => None[myunit_t]
  endmatch)
  ;

//Equals sign
var equals : parser[token_t, myunit_t] =
  token (fun (tok : token_t) : opt[myunit_t] =>
  match tok with
  | #T_equal => Some (myunit_v)
  | _ => None[myunit_t]
  endmatch)
  ;

//A language of arithmetic expressions
/*
expr_list :=
  | expr (';' expr)*
  ;
expr :=
  | identifier '=' expr
  | term (['+'|'-'] term)*
  ;
term :=
  | fact (['*'|'/'] fact)*
  ;
fact :=
  | num
  | identifier
  | '( expr ')
 */

//expr_list := expr (';' expr)*
var expr_list : parser[token_t, list[ast_t]] =
  (((expr &~ 
    zero_or_more(
       (semi &~ expr) >=~ (fun (p:(myunit_t * ast_t)) : ast_t => p.1))
   ) >=~  (fun (p:ast_t * list[ast_t]):list[ast_t] => Cons (p.0,p.1))) 
   |~ empty[token_t, list[ast_t]] (list[ast_t]()))
  ;

//expr :=
//| bind
//| term (['+'|'-'] term)*
//;
fun expr (toks : list[token_t]) : parsed[token_t, ast_t] =>
  (bind |~ left_assoc[token_t, ast_t] term addop) toks
  ;

//bind := identifier '=' expr
var bind : parser[token_t, ast_t] =
   (((ident &~ equals) >=~ (fun (p:ast_t * myunit_t) : ast_t => p.0)) &~ expr) >=~ 
   (fun (p : ast_t * ast_t) : ast_t => 
      match p.0 with
      | E_var e => E_let (e, p.1)
      endmatch)
  ;

//term := fact (['*'|'/'] fact)*
var term : parser[token_t, ast_t] = left_assoc[token_t, ast_t] fact mulop ;

//fact :=
// | num
// | identifier
// | '( expr ')
// ;
fun fact (toks : list[token_t]) : parsed[token_t, ast_t] =>
  (num |~ ident |~ 
    ((open_paren &~ expr &~ close_paren) >=~ 
        (fun (p:(myunit_t * ast_t), u:myunit_t) : ast_t => p.1))
   ) toks
  ;

//A function to extract the result of a parse
fun accept[A, B] (result : parsed[A, B]) : opt[B] =>
  match result with
  | Returns (b, #Empty) => Some[B] (b)
  | #Parse_failed => None[B]
  endmatch
  ;

//A function to produce a list of tokens from a string
fun tokenize (s : string) : opt[list[token_t]] => 
  accept (lex (explode (s))) 
  ;

//A function to produce an AST from a list of tokens
fun parse_expr (s : string) : opt[ast_t] =>
  match tokenize s with
    | Some toks => accept (expr toks)
    | #None => None[ast_t]
  endmatch
  ;

//A function to produce a list of ASTs from a list of tokens
fun parse_expr_list (s : string) : opt[list[ast_t]] =>
  match tokenize s with
  | Some toks => accept (expr_list toks)
  | #None => None[list[ast_t]]
  endmatch
  ;

//assoc a l returns the value associated with key a in the list of
//pairs l.  That is, assoc a [ ...; (a,b); ...] = b if (a,b) is the
//leftmost binding of a in list l
fun assoc[A, B with Eq[A]] (x : A) (l : list[(A * B)]) : opt[B] =>
  match l with
    | #Empty => None[B]
    | Cons ((a, b), t) => if a == x then Some b else assoc x t
  endmatch
    ;

//Evaluate an expression in an environment
fun eval (env:&list[(string * double)]) (ast:ast_t): opt[double] =>
  match ast with 
    | E_const f => Some f
    | E_let (tag, e) => 
      let v = eval env e in
      match eval env e with
      | Some x => ( env <- (tag, x) ! (deref env);  v)
      | #None => None[double]
      endmatch
   | E_var e => assoc e (deref env)
   | E_add (l, r) => 
     let (x, y) = (eval env l, eval env r) in
     match (x, y) with
       | Some u, Some v => Some (u + v)
       | _, _ => None[double]
     endmatch
    | E_sub (l, r) => 
      let (x, y) = (eval env l, eval env r) in
      match (x, y) with
       | Some u, Some v => Some (u - v)
       | _, _ => None[double]
      endmatch
     | E_mul (l, r) => 
       let (x, y) = (eval env l, eval env r) in
       match (x, y) with
         | Some u, Some v => Some (u * v)
         | _, _ => None[double]
       endmatch
     | E_div (l, r) => 
       let (x, y) = (eval env l, eval env r) in
       match (x, y) with
         | Some u, Some v => Some (u / v)
         | _, _ => None[double]
       endmatch
   endmatch
  ;

gen parse_eval_exprs 
  (env:&list[(string*double)]) (s:string) : opt[list[double]] =
{
  gen f (x : opt[double]) : double = {
    if is_defined x do return (get x);
    else goto gen_end;
    done;
  }

  val exprs : opt[list[ast_t]] = parse_expr_list s;

  if (is_defined exprs) do
    return Some (map f (map (eval env) (get exprs)));
  done;

gen_end :>
  return None[list[double]];
}  

proc prompt (continuing:bool) {
  if (not continuing) do
    write$ stdout, "? ";
  else
    write$ stdout, "... ";
  done;
  fflush stdout;
}

gen read (continuing:bool) : string = {
  prompt (continuing);
  val l = readln$ stdin;
  //println$ str (len l) + " bytes read";
  return l;
}

//Read-eval-print-loop
proc repl () {

  var env = list [(string * double)]();

  //A buffer
  var buf:string ="";
  reserve (&buf, 1048); //initial capacity
  
repl_loop : //iz in ur loop!
  while true do

    val l:string = read (len buf != 0uz);
    val n:size = len l;

    if n == 0uz 
      break repl_loop; //kthxbai!

   l = substring (l, 0, n - 2) ; // Strip newline

    if n > 0uz do
      if (l.[0] == char '%') //Comment line. Discard
        continue repl_loop;

      if l.[n - 1] == char '\\' do //Line continuation; append and keep reading
        buf += substring (l, 0, n - 2);
        continue repl_loop;
      done

      if l.[n - 1] == char 7 do //Discard partial statements with ^G
        buf = "";
        println$ "Buf has " + str (len buf) + " chars now";
        continue repl_loop;
      done

      //We think we got a phrase. Evaluate
      buf += l;
      val res : opt[list[double]] = parse_eval_exprs (&env) buf;
      buf = ""; //reset buf

      //Uncomment this block 

      if is_empty res do
         println$ "Error";
         continue repl_loop;
       done

       println$ str (drop (int((len l) - 1)) (get res));

      // to get,
      // arithmetic.cpp: In member function ‘flx::rtl::_uctor_ flxusr::arithmetic::_lam_63091::apply(const flxusr::arithmetic::_tt76465&)’:
      // arithmetic.cpp:153:12: error: ‘const struct flxusr::arithmetic::_tt76465’ has no member named ‘mem_1’
      //    _ = _arg.mem_1;
      //             ^
      // compilation terminated due to -Wfatal-errors.

     /* The code involved is this. Apparently relating to the 'lex' function.
//FUNCTION <63666>: lex::_lam_63091: Apply method
::flx::rtl::_uctor_ _lam_63091::apply(_tt76465 const &_arg ){
  tok = _arg.mem_0;
  _ = _arg.mem_1;
      return tok;
    FLX_DROPTHRU_FAILURE("/home/shayne/project/felix.git/src/web/tut/arithmetic.fdoc",307,6,307,47); // HACK! 
}
     */

    done
  done //repl_loop
}

//repl () ;

fun str (tok : token_t) : string =>
  match tok with
    | T_num f => "T_num " + (str f)
    | T_ident s => "T_ident " + s
    | T_lparen => "T_lparen"
    | T_rparen => "T_rparen"
    | T_plus => "T_plus"
    | T_minus => "T_minus"
    | T_star => "T_star"
    | T_slash => "T_slash"
    | T_semicolon => "T_semicolon"
    | T_equal => "T_equal"
   endmatch;

fun test (cs : list[char]) : parsed[char, token_t] =>
  ((spaces &~ identifier) >=~ 
    (fun (u:myunit_t, s:token_t) : token_t => s)) 
   cs
;

match (spaces (explode "    ")) with
    | Returns (toks, remains) => println$ "Success" ;
    | _ => println$ "Failure";
  endmatch
 ;


