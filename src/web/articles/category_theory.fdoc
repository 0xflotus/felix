
@mathjax
\(\DeclareMathOperator{\obj}{obj}\
\DeclareMathOperator{\arr}{arr}\
\DeclareMathOperator{\dom}{dom}\
\DeclareMathOperator{\cod}{cod}\)
@title Theory of Polynomial Types
@h1 Categories
@h2 Definition
A category \(K\) is a collection of objects \[O = \obj K\] and arrows \[A = \arr K\] with the following
data:
<ol>
<li>Each arrow \(f\in A\) has a specified domain object \(\dom f = D\in O\) and codomain object
\(\cod f = C\in O\) which is noted by stating \[f:D\rightarrow C\]</li>
<li>if \(f:A\rightarrow B\) and \(g:B\rightarrow C\) then there is a designated
composite arrow \[h:A\rightarrow C = g \circ f\]
</li>
<li>Given an object \(A\) there is a designated identity arrow \[1_A:A\rightarrow A\]</li>
</ol>
Satisfying the following laws:
<ol>
<li>Identity Law: If \(f:A\rightarrow B\) then \[1_B \circ f = f\] and \[f\circ 1_A = f\]</li>
<li>Associative Law: If \(f:A\rightarrow B\), \(g:B\rightarrow C\) and \(h:C\rightarrow D\) then
\[
h\circ (g \circ f) = (h \circ g) \circ f : A \rightarrow D
\]
</ol>
@h2 Example: Sets
The easiest example is the category \(\bf Set\) of all sets and all
functions between them.
@h2 Example: Types
Related to sets, the category \(\bf Type\) of all types in a decent programming 
language and functions between them.
You can think of a type as a set of values, and a function as the semantics
of the an encoding of a function in the language. Don't confuse the
categorical arrow, however, with the encoding: two distinct encodings
of a function are equal is they have the same semantics.

@h1 Core
Felix has a core type system based on the theory
of polynomial types which we review here. Of most 
interest is the way in which these theoretical
types are represented, in particular the data types
used, and implementation of the various isomorphisms.

I would comment that a programming @{hello} language is characterised
by the choice of isomorphism representations, in particular
which isomorphisms must be invoked by the user, and which
require run time conversions.
In the theory we have n-ary products and sums.
These are characterised by projections and  injections:
\[prj_{T_0\times T_1,i}: T_0 \times T_1 \rightarrow T_i\]
\[
inj_{T_0+T_1,i}: T_i -> T_0+T_1
\]

