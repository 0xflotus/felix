
@mathjax
\(\DeclareMathOperator{\obj}{obj}\
\DeclareMathOperator{\arr}{arr}\
\DeclareMathOperator{\dom}{dom}\
\DeclareMathOperator{\cod}{cod}\)
@title Theory of Polynomial Types
@h1 Categories
@h2 Definition
A category \(K\) is a collection of objects \[O = \obj K\] and arrows \[A = \arr K\] with the following
data:
<ol>
<li>Each arrow \(f\in A\) has a specified domain object \(\dom f = D\in O\) and codomain object
\(\cod f = C\in O\) which is noted by stating \[f:D\rightarrow C\]</li>
<li>if \(f:A\rightarrow B\) and \(g:B\rightarrow C\) then there is a designated
composite arrow \[h:A\rightarrow C = f \cdot g = g \circ f\]
</li>
<li>Given an object \(A\) there is a designated identity arrow \[1_A:A\rightarrow A\]</li>
</ol>
Satisfying the following laws:
<ol>
<li>Identity Law: If \(f:A\rightarrow B\) then \[f \cdot 1_B \= f\] and \[ 1_A \cdot f = f\]</li>
<li>Associative Law: If \(f:A\rightarrow B\), \(g:B\rightarrow C\) and \(h:C\rightarrow D\) then
\[
f\cdot (g \cdot h) = (f \cdot g) \cdot h : A \rightarrow D
\]
</ol>
Note that \(g \circ f = f \cdot g\), the RHS is the usual forward composition
but the LHS reverse composition is much better for category theory, since it
follows arrows from source to destination.
@h2 Example: Sets
The easiest example is the category \(\bf Set\) of all sets and all
functions between them.
@h2 Example: Types
Related to sets, the category \(\bf Type\) of all types in a decent programming 
language and functions between them.
You can think of a type as a set of values, and a function as the semantics
of the an encoding of a function in the language. Don't confuse the
categorical arrow, however, with the encoding: two distinct encodings
of a function are equal is they have the same semantics.

@h1 SubCategories
A subcategory \(S\) of a category \(K\) is any subset of objects and arrows which
is itself a category. In particular each object must have its identity arrow,
and be closed under composition.
@h2 Example
Let the objects be all sets and draw and arrow from \(A\) to \(B\) if \(A\) is a subset 
of or equal to \(B\). This is a category, and a subcategory of \(\bf Set\), however
without the equality there would be no identity arrows, so proper subset relations
don't form a category.

@h1 Category generated by a graph
For any directed graph \(G\) take the vertices as objects and the
edges as arrows together with an arrow from every vertex to
itself designated the identity for that vertex. Then we can take
the joining of paths as composition, and the result is called the
category generated by the graph.

Note in this example, arrows are not necessarily functions, 
nor are the objects sets or types.

@h1 Functors
A functor \(F\)is a mapping from a category \(D\) to another category \(C\) which 
consists of a function \(\obj F\) from objects to objects and 
function \(arr F\) from arrows to arrows which preserves structure in the
following sense:
<ol>
<li>If \(c = \obj F d\) then \(1_c =  \arr 1_d\) </li>
<li>If \(f: A \rightarrow B\) and \(g: B \rightarrow C\) then
\[
\arr F (f\cdot g) = \arr F (f) \cdot \arr F (g)
\]
</li>
</ol>
In other words, identities and composition are preserved.

@h2 Example: polymorphic types
A polymorphic type @{F}, such as a C++ class template, can be considered
as a functor from \(\bf Type \) to \( Type \). Given any type @{t},
a new type @{F&lt;t&gt;} is constructed.

For example then @{vector} is a functor. Here the structure
is preserved by defining \(\arr @{vector} (f)\) the action of a \(f\) on
a vector as the action on its elements. This operation is commonly
called a map.

@h2 Meta programming
We can make a category whose objects are other categories,
and whose arrows are functors. So category theory has the nice
property that it can describe itself.

