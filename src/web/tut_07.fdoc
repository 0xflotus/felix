@h1 Unions and Matches
The dual concept to structures is unions. A structures has "each of" logic whereas
a union has "one of logic". Each-of logic demands treating each of the components
in sequence whereas one-of logic demand selecting one of the components.

Unions therefore represent alternatives. We use pattern matching with
the {match} construction to discover which alternative is encoded
and handle it in a typesafe manner. A {match} is an advanced for
of a {switch}: {union}s are an advanced form of an {enum}eration.

@felix
union boolean = 
  | True
  | False
;

var b:boolean = True;

proc f(b:boolean)  {
  match b with
  | True => println "True";
  | False => println "False";
  endmatch;
}

println$ match b with | True => "True" | False => "False" endmatch;
@

This code demonstrates a simple union of two cases: {True} and {False}
and shows a procedural {match} whose case handlers are {println}
statements, and a function {match} whose handlers are expressions.

A more sophisticated example:

@felix
union Z = 
  | Cart of double * double // cartesian complex x+iy
  | Polar of double * double // polar complex re^(i\theta)
;

fun str (z:Z) => match z with
  | Cart ?x,?y => str x + "+"+str y+"i"
  | Polar ?r,?theta => str r + "e^"+str theta+"i"
;
@

The identifiers {Cart} and {Polar} here are called <em>type constructors</em>
or just plain constructors, note here the arguments of the constructors
are both the same: a pair of {double}. 

The question mark {?} here is used to introduce a parameter to
represent the argument.

Unions are the way to unify heterogenous data types. If you're
from an OO background you may think subclassing should be used
for this. Unlearn this error. It is <em>utterly</em> wrong.

Subclassing is a way to represent a subtype, that is, a type
with a subset of values of another type: for example the set of
triangular matrices is a subtype of all matrices.

Similarly, composition using tuple or structs is the way to add
more data to a type. Not inheritance. Unlearn that mistake too!

The match construction is very powerful. It can be used to match
tuples and records too:

@felix
fun fst (a:int * long) => 
  match a with 
  | ?x,_ => x
  endmatch
;

fun xaxis (a:(x:double; y:double;))=> 
  match a with
  | (x=?xval) => xval
  endmatch
;

println$ fst (41,99l);
println$ xaxis (x=1.2,y=2.2);
@
Here the {_} is a wildcard that matches anything.

You can also match against literals:
...
compound matches
...
ranges
...

