@title Unique C String
@tangler cstring.flx = share/lib/std/strings/cstring.flx
@tangler ustr.flx = share/lib/std/strings/ustr.flx
@h1 Traditional C Strings

Primitive operations on C strings, distinct from 
corresponding byte operations in that they depend on
or involve the null terminator.

@tangle cstring.flx
// Primitives
class CString
{
  //$ C strcpy.
  proc strcpy: +char * +char = "(void)::std::strcpy($1,$2);" 
    requires Cxx_headers::cstring
  ;

  //$ C strncpy.
  proc strncpy: +char * +char * !ints = "(void)::std::strncpy($1,$2,$3);" 
    requires Cxx_headers::cstring
  ;

  //$ C strlen: NTBS length.
  fun strlen: +char -> size = "::std::strlen($1)" 
    requires Cxx_headers::cstring
  ;

  fun len (s:+char) => strlen s;

  //$ Traditional NTBS strdup.
  gen strdup(s:carray[char]) = {
    val n = strlen s;
    var out=array_alloc[char] (n+1uz);
    strcpy(out,s);
    return out;
  }
}

@h1 Unique C Strings 
A safer way to handle NTBS, using uniq typing to transfer
owenership. Doesn't require GC.

@tangle ustr.flx
open class UniqueCStrings
{
  open CString;

  typedef ustr = uniq (+char);
  // Constructors
  ctor ustr (s:string) = {
     var p =  (s._unsafe_cstr.strdup);
     println$ "Creating " + p.repr + " @" + p.address.repr;
     return uniq p;
  }

  ctor ustr (s:+char) => uniq (s.strdup);

  // deletes the store
  proc delete (p:ustr) {
    var q = ununiq p;
    println$ "Deleting " + q.address.repr;
    free q;
  } 

  // length
  fun len(s:&ustr) : size => s.peek.strlen;

  // modify one char
  fun set (s:ustr, i:int, c:char) : ustr =  {
    var cs = ununiq s;
    set (cs, i, c); // Carray::set
    return uniq cs;
  }

  private gen realloc : +char * size -> +char = 
    "(char*)::std::realloc($1,$2)"
    requires Cxx_headers::cstdlib
  ; 

  // reserve storage 
  fun reserve (s:ustr, n:size) : ustr =>
    uniq (realloc (ununiq s,n))
  ;

  // append: consumes y
  fun append (x:ustr, y:ustr): ustr = {
    var cx = ununiq x;
    var cy = ununiq y;
    var lx = cx.len;
    var ly = cy.len;
    var r = realloc (cx, lx+ly+1);
    strncpy (r+lx,cy,ly+1);
    println$ "Realloc @" + cx.address.repr + " -> " + r.address.repr;
    println$ "Free @" + cy.address.repr;
    free cy;
    return uniq r;
  } 

  // append: doesnt consume y
  noinline fun append (x:ustr, py:&ustr): ustr = {
    var cx = ununiq x;
    var cy = py.peek;
    var lx = cx.len;
    var ly = cy.len;
    var r = realloc (cx, lx+ly+1);
    println$ "Realloc @" + cx.address.repr + " -> " + r.address.repr;
    strncpy (r+lx,cy,ly+1);
    return uniq r;
  } 

  // nicer appends
  fun + (x:ustr, y:ustr) => append (x,y);
  fun + (x:ustr, py:&ustr) => append (x,py);

  proc += (lhs: &ustr, rhs: ustr) => 
    *lhs = append (*lhs,rhs)
  ;
  proc += (lhs: &ustr, rhs: &ustr) => 
    *lhs = append (*lhs,rhs)
  ;
}
