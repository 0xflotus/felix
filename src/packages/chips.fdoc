@tangler chips.flx      = share/lib/std/control/chips.flx
@tangler parsers.flx = share/lib/std/strings/parsers.flx

@title Chips.
@h1 Standard components
@h2 Write block.
Blocks reader.
@tangle chips.flx
chip writeblock[T]
  connector io
    pin inp : %<T
{
}

@h2 Read block.
Blocks writer.
@tangle chips.flx
chip readblock[T]
  connector io
    pin inp: %>T
{
}


@h2 Universal sink
Reads input forever.
@tangle chips.flx
chip sink[T]
  connector io
    pin inp : %<T
{
  while true do
    var x = read (io.inp);
    C_hack::ignore (x);
  done
}

@h2 Constant Source.
Write fixed value forever.
@tangle chips.flx
chip source[T] (a:T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, a);
  done
}

@h2 Source from list
@tangle chips.flx
chip source_from_list[T] (a:list[T])
  connector io
    pin out: %>T
{
  for y in a perform write (io.out,y);
}

@h2 Function adaptor.
Converts function to chip.
@tangle chips.flx
chip function[D,C] (f:D->C)
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
    var y = f x; 
    write (io.out, y);
  done
}

@h2 Buffer.
One step buffer. Same as a function adaptor passed identity.
@tangle chips.flx
chip buffer [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    var x = read io.inp;
    write (io.out, x);
  done
}

@h2 Debug Buffer.

@tangle chips.flx
chip debug_buffer [T with Str[T]] (tag:string)
  connector io
    pin inp: %<T
    pin out: %>T
{
  while true do
    println$ "Debug buffer [" + tag + "] READ";
    var x = read io.inp;
    println$ "Debug buffer [" + tag + "] read " + x.str;
    write (io.out, x);
    println$ "Debug buffer [" + tag + "] written " + x.str;
  done
}

@h2 One Shot.
A one shot buffer.  
@tangle chips.flx
chip oneshot [T]
  connector io
    pin inp: %<T
    pin out: %>T
{
  var x = read io.inp;
  write (io.out, x);
}

@h2 Store
Stores read values in a variable.
@tangle chips.flx
chip store[T] (p:&T)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    p <- x;
  done
}

@h2 Fetch
Writes current value of a variable.
@tangle chips.flx
chip fetch[T] (p:&T)
  connector io
    pin out: %>T
{
  while true do
    write (io.out, *p);
  done
}

@h2 Printer
Writes input to console.

@tangle chips.flx
chip debug_sink [T with Str[T]] (s:string)
  connector io
    pin inp: %<T
{
  while true do
    var x = read io.inp;
    println$ "Debug sink ["+s+"] "+x.str;
  done
}


@h2 Asynchronous Latch.
Satisfied all reads with the last
value written. Blocks readers until at least
one value is written.
@tangle chips.flx
chip latch[T]
  connector io
    pin inp: %<T
    pin out: %>T
{
   var x = read io.inp;
   device w = fetch &x;
   device r = store &x;
   circuit
     wire io.inp to r.inp
     wire io.out to w.out
   endcircuit
} 

@h2 Serialise.
Read values in sequence from a sequence of channels,
write each one out on a single channel. Repeat.
The input channels are fixed by supplying them as
an argument.

@tangle chips.flx
chip serialise_chan_list[T] (a: list[%<T])
 connector io
   pin out: %>T
{
  while true do
    var current = a;
next:>
    match current with
    | Cons (h,t) =>
      var x = read h;
      write (io.out, x);
      current = t;
      goto next;
    | Empty => ;
    endmatch;
  done
}

typedef iopair_t[D,C] = (inp: %<D, out: %>C);
typedef iochip_t[D,C] = iopair_t[D,C] -> 1 -> 0;

// NOTE: this is currently a one-shot!
// .. Well sort of!
// It can do multiple reads if its first chip
// cycles. If the pipeline drops dead, it will
// not be reuable.
//
// To be reusable, components should not return,
// instead loop back to reading without writing.

chip pipeline_list[T] (a: list[iochip_t[T,T]])
  connector io
    pin inp: %<T
    pin out: %>T
{
  proc aux (lst:list[iochip_t[T,T]]) (inp: %<T) {
    match lst with
    | h1 ! h2 ! tail =>
      var inchan,outchan = mk_ioschannel_pair[T]();
      spawn_fthread$  h1 (inp=inp, out=outchan);
      aux (h2!tail) inchan;
    | h1 ! _ =>
      spawn_fthread$  h1 (inp=inp, out=io.out);
    endmatch;
  }
  aux a io.inp;
}

// This loops, but only by repeatedly spawning
// the alternative set. The alternatives are restricted
// to a single read on each iteration. The chips are
// respawned because they might be locked up, in which
// case the whole thing locks up.
//
// NOTE: if one of the alternatives starts, and does not
// read the input, everything locks up. This is because
// the implementation ACTUALLY progresses serially.
//
// this COULD be fixed by adding a buffer to the front of
// each. Actually better, add a one shot source based
// on the input.
chip tryall_list[D,C with Str[D]] (a: list[iochip_t[D,C]]) 
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
//println$ "Tryall read " + x.str;
    for h in a do
      var lin,lout = mk_ioschannel_pair[D]();
      spawn_fthread (h (inp=lin, out=io.out));
      write (lout,x);
    done
  done
}

@h1 Parsing
Chips to providing parsing functions.

@h2 Buffer type
Parsers work on an array of chars in memory. We use a Google
StringPiece to represent it. 

@tangle parsers.flx
struct Buffer
{
  sp: StringPiece;
  pos: int;

  fun atend => self.pos >= self.sp.len.int;

  fun get => 
    if self.atend then char "" 
    else (self.sp.data) . (self.pos)
  ;

  proc next { 
    if not self*.atend do
      pre_incr self.pos;
    done
  }

  fun advanced =>
    if self.atend then self
    else Buffer (self.sp, self.pos + 1)
  ;
}

ctor Buffer (p:&string) =>
  Buffer (p.StringPiece,0)
;

instance Str[Buffer] {
  fun str (b:Buffer) => "@"+b.pos.str;
}

// hack, ignore underlying data.. FIXME
instance Eq[Buffer] {
  fun == (a:Buffer, b:Buffer) => a.pos == b.pos;
}


@h2 A string matcher.

@tangle parsers.flx
chip match_string (s:string)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
nextmatch:>
  var b = read io.inp;
  for i in 0..< s.len.int do 
    if s.[i] != b.get goto nextmatch;
    b&.next;
  done
  write (io.out, b);
  goto nextmatch;  
}

@h2 Whitespace matcher.
@tangle parsers.flx
chip match_white 
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  while true do
    var b = read io.inp;
    while not b.atend and b.get <= char ' ' perform b&.next;
    write (io.out,b);
  done
}

@h2 regex matcher.

@tangle parsers.flx
chip match_regex (r:RE2)
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  while true do
    var b = read io.inp;
//println$ "Match regex " + r.str;
    var matched = varray[StringPiece] (1uz,StringPiece());
    var result = Match(r,b.sp,b.pos,ANCHOR_START,matched.stl_begin,1);
//println$ "Match result " + result.str;
    if result do
//println$ "Matched OK, match len = " + matched.0.len.str;
      var b2 = Buffer (b.sp,b.pos+matched.0.len.int);
//println$ "Writing buffer = " + b2.str;
      write(io.out,b2);
    done
  done
}

@h2 Identifier matcher.
For C like identifiers.

@tangle parsers.flx
device cident_matcher = match_regex (RE2 "[A-Za-z][A-Za-z0-9_]*");

@h2 Integer matcher.
For plain identifiers.

@tangle parsers.flx
device decimal_integer_matcher = match_regex (RE2 "[0-9]+");

@h2 String Literal matcher.
One shot. Simple, matches single or double quoted
string not spanning lines, with no escape codes, 
@tangle parsers.flx
chip match_string_literal 
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
restart:>
  var b = read io.inp;
  if b.atend goto restart; // end of data
  var leadin = b.get;
//println$ "string literal matcher got char " + leadin.str;
  if not (leadin in (char '"', char "'")) goto restart;
//println$ "Got valid string start .. ";
  b&.next; 
  if b.atend goto restart;
  var ch = b.get;
  while ch != leadin do
    b&.next;
    if b.atend goto restart;
    ch = b.get;
    if ch == char "\n" goto restart; // end of line
  done
  b&.next;
  io.out `write` b;  
  goto restart;
}

@h2 Capturing wrappers
Given a Buffer->Buffer scanner chip 'scan',
and a state updater 'newstate' which takes the
old state and the end position of the scanned lexeme
and produces a new state, run the scan chip
to match a lexeme and output the updated state.

The design of this chip is a bit weird and requires
explanation!

The captured device is expected to have signature (read+ write)+,
and so must the capturing device. So we cannot just read then
write and loop, because the captured scanner may fail, and this
would block the capturer. Instead, we have to spawn a fibre
that does a write and read on the captured device for every
input, which will fail if the scanner fails.

We have to make sure the handler parameter is bound to the
correct x, because it may be suspended when another input
comes in! So the closure y is formed to ensure capture.

@tangle parsers.flx
typedef pardat_t[T] = Buffer * T;

chip leaf_capture[T] 
  (
    scan: iochip_t[Buffer,Buffer],
    newstate: pardat_t[T] * Buffer -> pardat_t[T]
  )
  connector io
    pin inp: %<pardat_t[T]
    pin out: %>pardat_t[T]
{
while true do
  var x = read io.inp;
  noinline proc handler (var x: pardat_t[T]) () {
    var b,pd = x;
    var rin,win= mk_ioschannel_pair[Buffer]();
    var rout,wout= mk_ioschannel_pair[Buffer]();
    spawn_fthread (scan (inp=rin,out=wout));
    write(win,b);
    var b2 = read rout; // this can block forever if scan fails
    var s = newstate ((b,pd),b2);
    write (io.out,s);
  }
  var y = handler x;
  spawn_fthread y;
done
}



@h2 Optional matcher.
Matches given matcher if possible and epsilon.
Note the epsilon match is ALWAYS output!

@tangle parsers.flx
chip optional (p:iochip_t[Buffer,Buffer])
  connector io
    pin inp: %<Buffer
    pin out: %>Buffer
{
  device both = tryall_list ([
    p,
    debug_buffer[Buffer] "Epsilon"
  ]);
  circuit
    wire io.inp to both.inp
    wire io.out to both.out
  endcircuit
}

@h2 One or more matcher
@tangle parsers.flx

chip oneormore_matcher (A:iochip_t[Buffer,Buffer]) 
connector chans 
  pin inp: %<Buffer 
  pin out: %>Buffer
{
 device As = oneormore_matcher A;
 device As2 = pipeline_list (A,As).list; 
 device Ass = tryall_list (A, As2).list;
 circuit
   wire chans.inp to Ass.inp
   wire chans.out to Ass.out
 endcircuit
}

@h2 Grammar processing
@tangle parsers.flx

union symbol_t =
  | Terminal of string
  | Nonterminal of string 
;

typedef production_t = list[symbol_t];
typedef alternatives_t = list[production_t];

typedef grammar_t = (start:string, strdict[alternatives_t]);

chip parse_simple_grammar 
  connector io
    pin inp: %<string
    pin out: %>grammar_t
{
}


