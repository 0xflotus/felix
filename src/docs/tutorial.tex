
\documentclass[oneside]{book}
\usepackage{color}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\title{Introduction to Felix}
\author{John Skaller}
\begin{document}
\maketitle
\tableofcontents
\chapter{Quick Start}
We must of course begin with the traditional greeting!

\begin{minted}{felix}
println$ "Hello World";
\end{minted}

Here \verb%println% is a procedure which outputs a value to
standard output. The argument is of course a literal of
type \verb%string%. Calls to procedures must be terminated
by a semicolon \verb%;%. You will note, we do not require
parentheses around the argument to denote a procedure call!
We do not like parentheses much! The \verb%$% sign will be
explained in more detail later, but for now you should
know it is just a low precedence, right associative application
or call operator.

You can run this program from your console or terminal, once
Felix is installed, by just typing:

\begin{verbatim}
flx hello.flx
\end{verbatim}

assuming the file \verb%hello.flx% contains the sample code
and is in the current directory. Behind the scenes Felix does
dependency checking, transates the program to C++, compiles
the C++ to a machine binary, and runs it.

It works like Python but it performs like C++.

For more information see \url{http://felix-lang.org}.

\section{Integers: {\tt int}}
Felix has the usual integer type \verb%int% and literals consisting
of decimal digits, and the usual {\empha binary operators} \verb%+% for addition,
\verb%-% for subtraction, \verb%*% for multiplication, \verb%/% for division,
and \verb+%+ for remainder. We also have \verb%<<% to multiply by a power of 2,
and \verb%>>% to divide by a power of 2.These have the same semantics as in C, because,
these operators are in fact implemented in the Felix standard library by
delegating to C.

\begin{minted}{felix}
println$ 42;
println$ (42 + 12) * 90 - (36 / 2 + 1) * 127 % 3;
\end{minted}

Note you must put spaces around the \verb%-% operator! This is because
in Felix \verb%-% is also a hyphen, allowed in identifier names.

We also have the {\empha unary operator} \verb%-% for negation, and for symmetry
we also have unary \verb%+% which does nothing.

These operators are just functions so here are some more: 
the function \verb%str% converts an \verb%int% to a readable
string, the function \verb%abs% finds the absolute value of an
integer and \verb%sgn% returns $-1$ if its argument is negative,
$0$ if it is zero, and $1$ if it is positive.

We also have the usual {\empha comparisons} on integers represented as
infix operators: \verb%==% for equality, \verb%!=% for inequality, 
\verb%<% for less than, \verb%>% for greater than, and
\verb%<=% and \verb%>=% for less than or equal and greater than
or equal, respectively.

\section{Other integer types}
Felix has a lot of other integer types corresponding to those found
in C. Each of these types is distinct, none are aliases! See Table \ref{Felix Integer Types}.

\begin{table}
\caption{Felix Integer Types}
\label{Felix Integer Types}
\centering
\begin{tabular}[c]{lll}
\hline
Felix&C&Suffix\\
\hline
\multicolumn{3}{c}{Standard signed integers}\\
\hline
\verb%tiny% &\verb%char% & 42t \\
\verb%short% &\verb%short% & 42s \\
\verb%int% &\verb%int% & 42 \\
\verb%long% &\verb%long% & 42l \\
\verb%vlong% &\verb%long long% & 42ll \\
\multicolumn{3}{c}{Standard unsigned integers}\\
\hline
\verb%utiny% &\verb%unsigned char% & 42ut \\
\verb%ushort% &\verb%unsigned short% & 42us \\
\verb%uint% &\verb%unsigned int% & 42u \\
\verb%ulong% &\verb%unsigned long% & 42ul \\
\verb%uvlong% &\verb%unsigned long long% & 42ull \\
\multicolumn{3}{c}{Exact signed integers}\\
\hline
\verb%int8% &\verb%int8_t% & 42i8 \\
\verb%int16% &\verb%int16_t% & 42i16 \\
\verb%int32% &\verb%int32_t% & 42i32 \\
\verb%int64% &\verb%int64_t% & 42i64 \\
\multicolumn{3}{c}{Exact unsigned integers}\\
\hline
\verb%uint8% &\verb%uint8_t% & 42u8 \\
\verb%uint16% &\verb%uint16_t% & 42u16 \\
\verb%uint32% &\verb%uint32_t% & 42u32 \\
\verb%uint64% &\verb%uint64_t% & 42u64 \\
\multicolumn{3}{c}{Weird ones}\\
\hline
\verb%size% &\verb%size_t% & 42uz \\
\verb%intptr% &\verb%uintptr_t% & 42p \\
\verb%uintptr% &\verb%uintptr_t% & 42up \\
\verb%ptrdiff% &\verb%ptrdiff_t% & 42d \\
\verb%uptrdiff% &\verb%ptrdiff_t% & 42ud \\
\verb%intmax% &\verb%intmax_t% & 42j\\
\verb%uintmax% &\verb%uintmax_t% & 42uj \\
\multicolumn{3}{c}{Addressing}\\
\hline
\verb%address% &\verb%void*% &\\
\verb%byte% &\verb%unsigned char% &\\
\end{tabular}
\end{table}

\subsection{Conversions}
All the integer types can be inter-converted with a conversion.
This is just the name of the target type, used as a function. 
For example:

\begin{minted}{felix}
var x : long = long 42uz;
var y : int64 = x.int64;
\end{minted}

The dot notation is just shortcut high precedence reverse
application operator much beloved by OO enthusiasts.

\subsection{Bitwise operations}
For unsigned integers only, bitwise operations are supported.
These are \verb%\&% for bitwise and, \verb%\|% for bitwise or,
\verb%\^% for bitwise exclusive or, and \verb%~% for bitwise
complement.

\section{Booleans: {\tt bool}}
The result of a comparison is a new type, \verb%bool%
which has two values, \verb%false% and \verb%true%.
You can print booleans:

\begin{minted}{felix}
println$ 1 < 2;
\end{minted}

Felix also has a special statement for asserting that a 
boolean value is true:

\begin{minted}{felix}
assert$ 1 < 2;
\end{minted}

If the argument of an \verb%assert% is false, then if control
flows through it, the program is terminated with an error message.

Booleans support the usual {\empha logical operators}, but in Felix they
are spelled out. Conjunction is spelled \verb%and%, whilst disjunction
is spelled \verb%or%, implication is spelled \verb%implies%. Of course
we also have negation \verb%not%.

\subsection{Conditional Expression}
With \verb%bool% and \verb%int% we can demonstrate the conditional
expression:

\begin{minted}{felix}
println$ 
  if 1 < 2 then "less" 
  elif 1 > 2 then "greater" 
  else "equal" 
  endif
;
\end{minted}

Note that bool also forms a \href{https://en.wikipedia.org/wiki/Total_order}{total order} 
and can be compared, we
have $\verb%false% < \verb%true%$ so that $a \verb%==% b$
means $a$ is equivalent to $b$, we can also say that $a$ is true
if and only if $b$ is true. It turns out inequality $a \verb%!=% b$
is the same as exclusive or. Be careful though, since if
$a$ is less than or equal to $b$, written $a \verb%<=% b$ this actually
means that $a$ implies $b$ logically!

\section{Variables: {\tt var}}
Felix is a procedural programming language, so it has variables!
A variable denotes an addressable, mutable, storage location
which in Felix, like C, is called an {\em object}.

\begin{minted}{felix}
var x = 1;
var y = 2;
var z = x + 2 * y;
println$ z;
z = 2 * x + y;
println$ z;
\end{minted}

This code shows variables can be used to factor expressions into
a sequence of assignments. We assign variable $x$ the value 1,
variable $y$ the value 2, add $x$ to twice $y$ and put the
result in variable $z$, then print it.

Then we assign perform a different calculation and assign
that value to $z$ and print it.

What appears to be a variable initialisation is actually
equivalent to a definition of an uninitialised variable
followed by an assignment.

\begin{minted}{felix}
var x: int;
x = 1;
\end{minted}

The first statment reserves uninitialised store of type \verb%int%
named $x$ and the second assigns a value to it. Be very careful
with variables, initialised or not!  Felix has setwise scoping
rules, which are similar to C's function scope used for labels.
This means in a scope, you can refer to any symbol defined
{\em anywhere} in that scope. We shall see this is useful
for recursive functions because it eliminates the need for
forward declarations. However the following code has undefined behaviour:

\begin{minted}{felix}
println$ x;
var x = 1;
\end{minted}

There is no syntax error, no type error, and no lookup error in 
this code. The programmer used an uninitialised variable:
even though the variable is assigned a value, it is done too late.

Strangely, this code has deterministic behaviour:

\begin{minted}{felix}
println$ x;
var x = "Hello";
\end{minted}

but it may not do what you expect! It prints nothing!
The reason is simple enough: when Felix creates a variable
it is first initialised with its C++ default constructor.
Since a Felix \verb%int% is literally a C++ \verb%int% the
default constructor exists, but it is said to be trivial,
meaning, it does nothing. This is to improve performance,
in the case the first use of the variable will be to assign
a value to it: there's no point putting a value in there and
then overwriting it!

On the other hand Felix \verb%string% type is just 
C++ \verb%::std::basic_string<char>% and its default 
initialiser sets the string to the empty string \verb%""%.
That's what the code above prints!

\section{Floating Point: {\tt double}}
Felix also provides a model of C++ type \verb%double%
with the usual operators.  This is a double precision floating point type 
which usually follows IEEE standard. You can write a double precision
literal in the usual way. Felix follows ISO C-99 for floating point
literals.

A set of useful functions is also provided, corresponding to those
found in C-99 header file \verb%math.h%.

\begin{minted}{felix}
var x = 1.3;
var y = 0.7;
assert sqrt (sqr (sin x) + sqr (cos y)) - 1.0 < 1E-6;
\end{minted}

Note there is a special caveat with floating poimt arithmetic.
In Felix, \verb%-% has higher precedence than \verb%+%.
This means that:

\begin{minted}{felix}
var x: double = something;
var y: double; something_else;
assert x + y - y == 0.0;
\end{minted}

because the subtraction is done first.  This can make
a difference for integers too, if a calculation overflows,
but most floating point operators are not associative: order matters!

Similarly, division has a higher precedence than multiplication!

Floating reals are totally ordered and support exact comparisons.
However these operations are not numerically sound, they're
based on the underlying finite representation.

Floats also provide checks for \verb%nan% pseudo value, as well 
as \verb%+inf% and \verb%-inf%.

\subsection{Other floats}
As well as \verb%double% Felix provides single precision
\verb%float% and extended precision \verb%ldouble%
based on \verb%float% and \verb%long double% respectively,
with the equivalent operators.

It also supports complex numbers with Cartesian representation
based on C++ complex forms. The types are \verb%fcomplex% based
on \verb%float%, \verb%dcomplex% based on \verb%double%,
and \verb%lcomplex% based on \verb%ldouble%.

In addition Felix provides double precision based \verb%quaternion%
type.

\section{Strings: {\tt string}}
Felix uses C++ strings for its own strings for compatibility.
String literals have 6 forms following Python. Strings
not spanning multiples lines can be enclosed in either single
or double quotes. Strings spanning multiple lines may
be enclosed in tripled single or double quotes.

\begin{minted}{felix}
var ss1 = 'Short String';
var ss2 = "Short String";
var ls3 = """
A poem may contain
many lines of prose
""";
var ls4 = '''
Especially if it is written
by T.S. Elliot
''';
\end{minted}

Note that the triple quoted strings contain everything between the
triple quotes, including leading and trailing newlines if present.

Strings can be concatenated by writing them one after the other
separated by whitespace.

\begin{minted}{felix}
var rose = "Rose";
var ss5 = 
  "A " rose ", "
  "by another "
  "name."
;
\end{minted}

Note that concatenation works for string expressions in general,
not just literals.

\subsection{Escape Codes}
Special escapes may be included in strings. The simple
escapes are for newline, \verb%\n%, tab \verb%\t%,
form feed \verb%\f%, vertical tab \verb%\v%, 
the escape character \verb%\e%, \verb%\a% alert
or bell, \verb%\b% backspace, \verb%\'% single quote,
\verb%\"% double quote, \verb%\r% carriage return,
\verb%\\% backslash (slosh).

These can be used in any simple string form.
Note carefully each is replaced by a single character.
This includes \verb%\n%, even on Windows.

In addition Felix provides \verb%\xXX% where each
X is one of the hex digits $0123456789$, $ABCDEF$, or, $abcdef$.
The hex escape is at most two characters
after the \verb%x%, if the second character is not a
hex digit, the escape is only one character long,
the sequence is replaced by the char with ordinal value 
given by the hex code.

Felix also provides decimal and octal escapes using
\verb%\dDDD% and \verb%\oOOO% respectively, with a 
3 character limit on the decoder. Note carefully
Felix does NOT provide C's octal escape using
a 0 character. Octal is totally archaic. 

Felix also provides two unicode escapes. These
are \verb%\uXXXX% and \verb%\UXXXXXXXX% which 
consist of up to 4 and up to 8 hex digits exactly. 
The corresponding value is translated to UTF-8
and that sequence of characters replaces the escape.
The value must be in the range supported by UTF-8.

Felix also provides raw strings, in which escapes
are not recognised. This consists of the letter \verb%r%
or \verb%R% followed by a single or triple quoted string
with double quote delimiter. You cannot use the raw prefix
with single quoted strings because the single quote following
a letter is allowed in identifiers.

\subsection{String Functions}
Felix has a rich set of string functions. The most important
is \verb%char%, which returns a value of type \verb%char%.
If the string argument has zero length, the character with
ordinal value 0 is returned, otherwise the first character
of the string is returned. Again, following Python, Felix does 
not provide any character literals!

\subsubsection{Comparisons}
We provide the usual comparison operators.

\subsubsection{Length}
Felix also provides the most important function \verb%len%
which returns the length of a string. The return type is
actually \verb%size% which is a special unsigned integer type
corresponding to ISO C's \verb%size_t%.

\subsubsection{Substring}
Felix can fetch a substring of a string using Python like convenions.

\begin{minted}{felix}
var x = "Hello World";
var copied = x.[to];   // substring
var hello = x.[to 5];  // copyto
var world= x.[6 to];   // copyfrom
var ello = x.[1 to 5]; // substring
var last3 = x.[-3 to]; // substring
\end{minted}

The first index is inclusive, the second exclusive. 
The default first position is 0, the default last
position is the length of the string. If the range specified
goes off either end of the string it is clipped back to the string.
If the indices are out of order an empty string is returned.

A negative index is translated to by adding the string length.

The substring function s defined so it cannot fail.
The name of the actual library function called by this notation
is shown in the corresponding comment.

\subsubsection{Index}
To fetch a single character use:

\begin{minted}{felix}
var x = "Hello world";
var y : char = x.[1]; // subscript
\end{minted}

If the index is out of range, a character with ordinal 0 is returned.
Negative indices are translated by adding the string length.
The index function cannot fail.

\section{Tuples}
Felix has an strucurally typed product where components are
accessed by position, commonly called a {\em tuple}.  Tuples
can be constructed using the non-associative n-ary comma operator
and accessed by using a plain decimal integer as the projection
function:

\begin{minted}{felix}
var x = 1,"Hello", 42.7; // type int * string * double
var i = x . 0;
var h  = x . 1;
var d = x  . 2;
\end{minted}

Tuple is just another name for Cartesian product.
They allow you to pack several values together into a single
value in such a way that you can get the components you put
in out again.

We shall see tuples are vital for functions, since functions
can only take a single argument. To work around this fact,
we can pack multiple values together using a tuple.

\subsection{Unit tuple}
There is a special tuple with nothing in it called
the unit tuple, written:

\begin{minted}{felix}
  var u : unit = ();
  var u2 : 1 = ();
\end{minted}

It is a \href{https://en.wikipedia.org/wiki/Unit_type}{unit type}.

\subsection{Arrays}
If all the elements of a tuple are the same type,
its called an {\em array}. In this case the accessor
index, or projection, can be an expression of \verb%int%
type.

\begin{minted}{felix}
var x : int ^4 = 1,2,3,4;
for var i in 0 upto x.len.int - 1 do
  println$ x . i;
done
\end{minted}

You will also see the use of a low level \verb%for% loop
here, and the use of the \verb%len% function to get the array
length. The \verb%len% function returns a value of type \verb%size%
but the loop variable \verb%i% is an \verb%int%, so we have to 
convert it.

\section{Unit Sums}
The type of the array in the last section
is given by

\begin{minted}{felix}
  int ^ 4 = int * int * int * int
\end{minted}

This is the usual meaning of the exponential operator \verb%^%:
raising to some power $n$ means multiplication of $n$ copies.

However you may be surprised to learn that in Felix, \verb%4%
is a type, and 

\begin{minted}{felix}
  4 = 1 + 1 + 1 + 1
\end{minted}

The type \verb%1% here is also called \verb%unit% and is just the
type of the empty tuple \verb%()%. Now, you have seen that the
cartesian product type is denoted using the n-ary non-associative
operator \verb%*%, so it is not so surprising that the type
denoted by the n-ary non-associative operator \verb%+% is called
a sum.

Values of a unit sum just represent cases. The notation is ugly:

\begin{minted}{felix}
var x : int ^4 = 1,2,3,4;
var third = case 2 of 4;
println$ x.third; // the *true* projection
\end{minted}

especially as it's zero origin. When you use an integer array
index, it has to be bounds checked at run time. However if you use a unit
sum index, the check is done by the type system at compile time.

There is a very commonly used unitsum. You already know it: \verb%bool%
is nothing more than another name for type \verb%2% and the special
words \verb%false% and \verb%true% are just aliases for \verb%case 0 of 2%
and \verb%case 1 of 2% respectively!


\section{Lists}
A list is a variable length sequence of values of the same type.
An empty list of \verb%int% is denoted \verb%Empty[int]%.
Given a list you can create a new one with a new element
on the front using the constructor \verb%Cons% as follows:

\begin{minted}{felix}
var x = Empty[int];
x = Cons (1,x);
x = Cons (2,x);
x = Cons (3,x);
var y = Cons (3, Cons (2, Cons (1, Empty[int])));
\end{minted}

Of course this is messy! Here is a better way:

\begin{minted}{felix}
var z = list (3,2,1);
\end{minted}

This method converts a tuple to a list. You can add two lists
together, prepend a value, or add a value to the end of a list
with the infix \verb%+% operator:

\begin{minted}{felix}
var x = list (1,2,3);
x = 1 + x + x + 42;
\end{minted}

Take care that + associates to the left and you don't
accidentally add two integers together! There is a second
operator you can use as well which is right associative and
prepends an element to a list:

\begin{minted}{felix}
var x = 3 ! 2 ! 1 ! Empty[int];
x = 42 ! x;
\end{minted}

You can use the \verb%len% function to find the length of a list,
and test if an element is in a list using the \verb%in% operator:

\begin{minted}{felix}
var x = list (1,2,3);
assert len x in x; // 3 is in the list!
\end{minted}

Lists in Felix are purely functional data structures: you cannot
modify a list. All the nodes in a list are immutable, which
means when you prepend an element $A$ to a list $L$, and then
prepends an element $P$ to the same list $L$, the tail of the list
is shared. Lists can be passed around efficiently without copying.

When some prefix of a list is no longer accessible because the function
prepending the prefix returns without saving the list, the prefix
elements will be removed automatically by the Felix garbage collector.

\section{Pattern Matching and Union}
A list is actually defined like this:

\begin{minted}{felix}
union list[T] = 
  | Empty
  | Cons of T * list[T]
;
\end{minted}

The \verb%union% construction defines a nominally typed
sum. The words \verb%Empty% and \verb%Cons% are called
type constructors. This union is also polymorphic!
This means you can make lists of any type. The first 
case is just an empty list. The second case, \verb%Cons%
joins together an element of type \verb%T% and another list.
In other words it creates a new list by adding a new
element onto the front. A type like this is called
an \href{https://en.wikipedia.org/wiki/Inductive_type}{inductive type}.

A list can be taken apart with a pattern match:

\begin{minted}{felix}
var x = list (3,2,1);
println$
  match x with
  | #Empty =>  "Empty"
  | Cons(v, tail) => "first element " + v.str
  endmatch
;
\end{minted}


\subsection{Option Type}
Another commonly used union type is the option type \verb%opt%:

\begin{minted}{felix}
union opt[T] = 
  | None 
  | Some of T
;

fun maybe_divide (num:int, denom:int) =>
  if denom == 0 then None[int]
  else Some (num/denom)
;

println$
  match maybe_divide (10,0) with
  | #None =>  "Divide by Zero"
  | Some j => "Quotient " + j.str
  endmatch
;
\end{minted}


\section{Functions}
We have enough preliminaries now to finally introduce functions.
Without further ado, here are some basic functions:

\begin{minted}{felix}
fun twice (x:int) : int => x + x;
fun thrice (x:int) :int  => twice x + x;
\end{minted}

Functions also have a more expanded form:

\begin{minted}{felix}
fun trickdiv (num:int, denom:int) :int = 
{
   var y = if denom == 0 then 1 else denom endif;
   return xnum / y;
}
\end{minted}

There is a rule for functions: 

{\bf functions defined with the \verb%fun% binder may not have observable
side effects}

The rule is relaxed; that is, not enforced,
to permit debugging, profiling, coverage checking, etc.

\subsubsection{Pattern Syntax for Functions}
Functions can also be defined with an abbreviated
form which merges the definition with a pattern match:

\begin{minted}{felix}
fun len[T] : list[T] -> int =
  | #Empty => 0
  | Cons (_, tail) => 1 + len tail
;
\end{minted}

This is just shorthand for

\begin{minted}{felix}
fun len[T] (x:list[T]): int =>
  match x with
  | #Empty => 0
  | Cons (_, tail) => 1 + len tail
  endmatch
;
\end{minted}


\subsection{Calling functions}
In Felix you can call a function using operator whitespace:

\begin{minted}{felix}
fun twice (x:int) : int => x + x;
println$ twice 42;
\end{minted}

This is the usual prefix mathematical notation. In Felix, parentheses
are not required around arguments to make a function call, they are
just used for grouping. Some programmers also like postfix notation
and you can use that too:

\begin{minted}{felix}
fun twice (x:int) : int => x + x;
fun thrice (x:int) :int  => twice x + x;
println$ thrice 42.twice;
\end{minted}

Here, \verb%twice% is called first, because operator \verb%.% has a higher
precedence that operator whitepsace. Both operators are left associative!
Operator dot is called {\em reverse application} because the argument
is written first, then the function to apply.

Felix also has operator dollar \verb%$% which is a very low precedence
right associative operator:

\begin{minted}{felix}
println$ k $ h $ g 42.f;
println ( k ( h ( g ( f 42))));
\end{minted}

and there is also a left associative low precedence reverse order
operator too:

\begin{minted}{felix}
h $ g 42.f |> k |> println;
println ( k ( h ( g ( f 42))));
\end{minted}

This is called {\em reverse pipe application} and has an even lower
precedence than forward dollar application.

There is one more application operator!

\begin{minted}{felix}
fun hhgttg() => 42;
h $ g #hhgttg.f |> k |> println;
\end{minted}

Operator hash \verb%#% just applies a function
to the unit tuple \verb%()%, it is often used
for constant functions. It is a very high precedence operator.

It's no wonder they wanted to spacedoze 
the Earth to build a freeway.

\subsection{Overloading}
You can define two functions with the same name, this
is never an error. However to apply a function with the 
same name as another, it must be possible to distinguish
between them.

{\em Overloading} provides on method for doing this:

\begin{minted}{felix}
fun twice (x:int) => x + x;
fun twice (x:double) => x + x;
println$ twice 42, twice 42.1;
\end{minted}

In the above example, the first application in the \verb%println%
argument tuple calls the first function, because the argument is
of type \verb%int%, and the second application calls the second
function because the argument is of type \verb%double%.

Selecting functions based on matching the argument and parameter
types like this is called overload resolution. Note that unlike
C++ there are no automatic conversions in Felix. The argument
and parameter type must match exactly.

Overloading first looks in the scope of the application.
If matching fails to find any candidate functions, it proceeds
to the next outer level, until there are no more levels left.

\subsection{Higher Order Functions}
In Felix, a function can become a first class value.
This value is called a closure. Functions that accept
functions as arguments, or return functions, are
called higher order functions or {\em HOF}'s.

\begin{minted}{felix}
fun twice(x:int) => x + x;
fun both (x:int, y:int, g: int -> int) => g x, gy;
println$ both (3,7,twice);
\end{minted}

The function \verb%both% applies its argument \verb%g% to
both x and y, returning the pair of results. On the
other hand here:

\begin{minted}{felix}
fun increment (x:int) : int * int -> int = 
{
   fun add (y:int) => x + y;
   return add;
}
println$ increment 3 42; // 45
var add3 = increment 3;
println$ add3 42; // 45
\end{minted}

the increment function returns another function which increments
its argument y, when applied, but the argument x first passed to it.
The variable \verb%add3% binds the first argument x, and is another
function which will add that x to its argument when applied.

The function \verb%increment% is said to have {\em arity} 2
because it appears to accept two arguments. In fact, there is 
no such thing as a function accepting two arguments.

The function of higher arity is sometimes said to be {\em curried}
named for theorist Howard Curry, although prefer Indian food.
If a function returns a function which is not immediately
applied to an argument it is said, surprisingly, to be
{\em partially applied}. When Felix does overload
resolution it can take into account as many arguments
as are provided for a curried function application.
It find candidates based on the first argument first,
then tries to whittle down the list based on the next
argument, and so on.

\subsection{Polymorphic Functions}
In Felix, you can write functions that work with a family
of types. 

\begin{minted}{felix}
fun diag[T] (x:T) => x, x;
\end{minted}

This is the famous diagonal function, which makes two
copies of its argument. It works for any type, so it
is a polymorphic function. In general such functions
can {\em only} do structural manipulations so they are
of limited utility.

Unless, that is, they're HOFs! For example:

\begin{minted}{felix}
fun add3[T] (x:T, y:T, z:T, add:T * T -> T) => 
  add (x, add (y,z))
;
\end{minted}

\subsubsection{Overloading Polymorphic Functions}
Polymorphic functions can be overloaded too.
However unlike ordinary functions, more than one
function might match. For example:

\begin{minted}{felix}
fun f[U,V] (x: U, y: V) => y,x;
fun f[W[ (x:W, y:int) => y+1,x;
println$ f (2,4); // which f?
\end{minted}

A function matches if the parameter type can be specialised
to the argument type by substituting some type expression for
each of the function's type variables. In the above case

$$\begin{aligned}
\verb%U% &\rightarrow \verb%int%\\
\verb%V% &\rightarrow \verb%int% 
\end{aligned}
$$

causes the first function to match and

$$ \verb%W% \rightarrow \verb%int% $$

causes the second one to match.

will cause both functions to match the argument type exactly.
In this case the most specialised function is chosen if there
is one. Here, the first function is clearly more general because
the substitution:

$$\begin{aligned}
\verb%U% &\rightarrow \verb%W%\\
\verb%V% &\rightarrow \verb%int% 
\end{aligned}
$$

into the type of the first function's parameter yields the second
function's parameter type. Since there is no substitution in the
other direction, the second function is strictly more specialised
and so it is selected.
 
The process of finding a substiution which makes types with type
variables equal is called 
\href{https://en.wikipedia.org/wiki/Unification_%28computer_science%29}{unification}.
The substitution effecting equality is called a {\em unifier}, and the
two terms rendered equal are said to be {\em unified}. There can
be more than one unifier, a most general unifier is one which can
produce all the other unifiers by some substitutions. If there is
a most general unifier it is unique up to changing variable names.

\section{Procedures}
A {\em procedure} is like a function which returns no value and
is allowed to have side effects.

\begin{minted}{felix}
proc printint(x:int)
{
   println$ "An integer " + x.str;
}
\end{minted}

This is in fact syntactic sugar for

\begin{minted}{felix}
fun printint(x:int) : void =
{
   println$ "An integer " + x.str;
}

printit 42;
\end{minted}

The pseudo type \verb%void% is the type you use when 
there is no value.

Procedures with unit argument type have a special call notation,
the unit argument () can be dropped:

\begin{minted}{felix}
proc print42()
{
   println$ "The world is coming to an end";
}

print42; // no () required
\end{minted}

You're right, I hate excess parens!

\section{Generators}
There is one further special kind of function, 
called a {\em generator}. A generator returns
a value and may have a side effect.

\begin{minted}{felix}
var counter = 0;
gen fresh2() : int =
{
  ++counter;
  return counter;
}
println$ #fresh, #fresh; // 1,2
\end{minted}

The term generator comes from the exemplar generator,
namely the random number generators. 

\chapter{Functional Programming}
We shall begin our more serious exploration of Felix with functional programming
techniques.


\begin{minted}{felix}
fun inner_strlist (x: list[int]) =>
  match x with
  // Emnpty list
  | #Empty => ""

  // One element list
  | Cons (head, #Empty) => str head 

  // Two element list
  | Cons (head, Cons (second, #Empty)) => str head ", " + str second 

  // More that two elements
  | Cons (head, tail) => str head ", " + inner_strlist tail
  endmatch
;

fun strlist (x:list[int]) => "list (" + inner_strlist x + ")";

println$ strlist (list (1,2,3));
\end{minted}

Here, the function \verb%inner_strlist% is recursive. It matches
the list so it is empty it produces an empty string.
If there is only one element, it produces the string 
representation of that int.

If the list contains two elements, it produces a string containing
the string representation of the two integers separated by a comma.
Otherwise it produces a string representation of the head, followed
by a comma, followed by a string representation of the tail.
The tail must contain at least two elements, otherwise the pattern
match would not reach that case.

However his function is not tail recursive! Lets rewrite it so 
it is:


\begin{minted}{felix}
fun inner_strlist (x: list[int], result:string) =>
  match x with
  // Emnpty list
  | #Empty => ""

  // One element list
  | Cons (head, #Empty) => str head 

  // Two element list
  | Cons (head, Cons (second, #Empty)) => str head ", " + str second 

  // More that two elements
  | Cons (head, tail) => inner_strlist (tail, str head ", ")
  endmatch
;
\end{minted}

A {\em tail call} is the final call in a function. Tail calls can
be optimised from a call followed by a return to just a jump. 
This avoids pushing the return address, then returning to that
address from the called procedure, then immediately returning
to the callers return address. Instead, the called procedure
just returns to the callers return address directly.

In particular, if the tail call is call to self, then by assigning
the call argument to the parameter, we then just jump to the start
of the function. In other words, we can optimise tail recursion
to a simple loop. This saves more than the space of the return
address on the stack, it saves the space required by all the local
variables as well. We can reuse these variables, since the old
values cannot be accessed.

Here is another, simpler tail recursive function:

\begin{minted}{felix}
fun addup (x: list[int]) =
{
  fun aux (rest: list, acc: int) =>
    match rest with
    | #Empty => rest
    | Cons (head, tail) => aux (tail, acc + head)
    endmatch
  ;
  return aux x 0;
}
\end{minted}

The non-recursive function \verb%addup% contains a nested tail recursive
function \verb%aux%.

Ok so, what if I wanted to add up the squares of the numbers 
in the list? Is there a way to avoid that?

The answer is yes:


\begin{minted}{felix}
fun fold(binop: int * int -> int, init:int, x:list[int]) =
{
  fun aux (rest: list, acc: int) =>
    match rest with
    | #Empty => rest
    | Cons (head, tail) => aux (tail, binop (acc,head))
    endmatch
  ;
  return aux x init;
}
\end{minted}

Fold works with any binary operator on \verb%int%. For example:

\begin{minted}{felix}
fun addition (acc:int,y:elt) => x + y;
assert addup x == fold (addition, 0, x);
\end(minted}

There is another way to write the folding expression:

\begin{minted}{felix}
assert addup x == fold (fun (acc:int, y:elt)=>x+y), 0, x);
\end{minted}

using an unnamed, or anonymous function, sometimes called 
a lambda.

So what happens if we want to make the sum of the square roots
of a list of \verb%int%?

It should work, right, if we change the signature of the
binary operator to 

\begin{minted}{felix}
double * int -> double
\end{felix}

and pass an appropriate function. The first component of the argument
is intended to hold the accumulated sum.

What if the list were of \verb%string% and we wanted to get the
complete length? Then we'd use


\begin{minted}{felix}
int * string -> int
\end{felix}

Can we generalise, so we only have one function? 

Sure. That's what parametric polymorphism is for.


\begin{minted}{felix}
fun fold[ResultType, ElementType] 
(
  binop: ResultType * ElementType -> ResultType, 
  init:ResultType, 
  x:list[ElementType]
) = 
{
  fun aux (rest: list, acc: int) =>
    match rest with
    | #Empty => rest
    | Cons (head, tail) => aux (tail, binop (acc,head))
    endmatch
  ;
  return aux x init;
}
\end{minted}

Now we can write:

\begin{minted}{felix}
println$ 
  fold [int,string]
  (
    (fun (acc:int, s:string)=>acc + len s),
    0,
    (list ("Hello", "World"))
  )
;
\end{minted}

This is all very nice!  Even better we can write:

\begin{minted}{felix}
println$ 
  fold 
  (
    (fun (acc:int, s:string)=>acc + len s),
    0,
    (list ("Hello", "World"))
  )
;
\end{minted}

because the instances of the type variables required
can be deduced from the arguments.

However our implementation
has a slight ugliness: we first define a function,
then return an application of it, which consists of
two statements, and requires the expanded form of
function definition.

Can we do it as a one liner, using only the simplified
form? The answer is yes, using a \verb%let-in% expression:


\begin{minted}{felix}
fun fold[ResultType, ElementType] 
(
  binop: ResultType * ElementType -> ResultType, 
  init:ResultType, 
  x:list[ElementType]
) =>
  let fun aux (rest: list, acc: int) =>
    match rest with
    | #Empty => rest
    | Cons (head, tail) => aux (tail, binop (acc,head))
    endmatch
  in 
  aux x init
;
\end{minted}

The fold above utilises what is called a {\em type schema}.
This is a limited kind of polymorphism also called
first order polymorphism, or simply {\em templates}.
Type schemes are limited to having type variables universally
quantifed on outside and can be instantiated by replacing
the type variable with an actual type. At run time, there
are no type variables about. You cannot have a polymorphic
function at run time. So

\begin{minted}{felix}
// NO polymorphic function closures in Felix!
type-error var x = fold[int, string];
\end{minted}

There is another way to write this, using a method called
currying, in a form called curry form. This is the more
conventional form in some languages.

In functional programming languages, functions are first
class, meaning you can pass them into another function,
and return them from a function. Consider this:

\begin{minted}{felix}
fun fold[ResultType, ElementType] 
  (binop: ResultType * ElementType -> ResultType)
{
    fun A(init:ResultType) 
    {
      fun B(x:list[ElementType]) 
      {  
        let fun aux (rest: list, acc: int) =>
          match rest with
          | #Empty => rest
          | Cons (head, tail) => aux (tail, binop (acc,head))
          endmatch
        in 
        return aux x init;
      }
      return B;
   }
   return A;
}
\end{minted}

What is the type of this function? Well, 

\begin{minted}{felix}
B:list[ElementType]-> ResultType
\end{minted}

and since A returns B, its type is:

\begin{minted}{felix}
A: ResultType -> (list[ElementType]-> ResultType)
\end{minted}

and since fold returns A its type is

\begin{minted}{felix}
fold: list[ElementType] -> (ResultType -> (list[ElementType]-> ResultType))
\end{minted}

How would we use this? Well:

\begin{minted}{felix}
println$ 
  (
    (
      (
         fold 
           (fun (acc:int, s:string)=>acc + len s))
      )
      0
    )
    (list ("Hello", "World"))
  )
;
\end{minted}


Note that the \verb%->% function operator is right associative we
don't need the parens so we can write this as:

\begin{minted}{felix}
fold: list[ElementType] -> ResultType -> list[ElementType]-> ResultType
\end{minted}

getting rid of parens, and, since application (the whitespace operator!) is 
left associative, we can write:

\begin{minted}{felix}
println$ 
  fold 
    (fun (acc:int, s:string)=>acc + len s))
    0
    (list ("Hello", "World"))
;
\end{minted}

again getting rid of parens. The form:

\begin{minted}{felix}
  fold fn init alist
\end{minted}

is the curried form of the call we wrote in tuple form like:

\begin{minted}{felix}
  fold (fn, init, alist)
\end{minted}

Curried form has an advantage:

\begin{minted}{felix}
fun string_lengths (x:list[string]) =>
   fold 
    (fun (acc:int, s:string)=>acc + len s))
    0
;

var l1 = list ("Hello", "World");
var l2 = list ("Felix", "Rocks");
println$ string_lengths l1, string_lengths l2;
\end{minted}

In the function, we simply apply the fold to the
first three arguments, which returns a function 
of one argument, a list of strings.

Curried form is so useful, there is syntactic sugar
for writing functions in this form:

\begin{minted}{felix}
fun fold[ResultType, ElementType] 
  (binop: ResultType * ElementType -> ResultType)
  (init:ResultType)
  (x:list[ElementType])
=>
  let fun aux (rest: list, acc: int) =>
    match rest with
    | #Empty => rest
    | Cons (head, tail) => aux (tail, binop (acc,head))
    endmatch
  in 
  aux x init
;
\end{minted}


\end{document}
