

\documentclass[oneside]{book}
\usepackage{color}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\title{The FARM\\ Felix Annotated Reference Manual}
\author{John Skaller}
\begin{document}
\maketitle
\tableofcontents
\chapter{Introduction}
This reference is a guide to the Felix programming language.
It is not the usual reference because Felix differs from
other systems in that most of the grammar is part of the library,
in user space. In principle then, separating the library from the 
core language is impossible: if anything the core language is
defined by the compiler intermediate abstract machine, details
of little interest to most programmers.

Furthermore even that characterisation is weak, because considerable
functionality is actually embodied in the run time library. For example
the compiler knows what a service request is, but it has no idea
what an fthread is. It knows what a generator is, and it knows which
generators perform yields, but it has no idea what an iterator is,
despite the fact these are effectively a core language feature.

Therefore, our presentation cannot be complete, it cannot be precise,
and it cannot replace actually reading the library code. Felix is a highly
mutable language, major new features can often be introduced without
touching the compiler.

For example a complete set of primitive types with their base
operations cannot be presented, because, with a couple of exceptions
there aren't any such type. Instead, most primitive types are introduced
without knowledge of the compiler, by creating bindings to C++ in 
library code; these bindings defined the type name and some operations
on the types in terms of C++.

% =====================================

\chapter{Program structure}
A Felix program consists of a nominated root parse unit and
the transitive closure of units with respect to inclusion.

The behaviour of this system consists of the action of the
initialisation code in each unit, performed in sequence
within a given unit, with the order of action between
units unspecified.

\section{Parse Unit}
A parse unit is a file augmented by prefixing specified import
files to the front. These consist of a suite of grammar files
defining the syntax and other files defining macros.

By convention syntax files have the extension \verb%.fsyn%,
and other import files have the extension \verb%.flxh%.

With this augmentation all parse units in a program
are independently parsed to produce an list of statements
represented as abstract syntax, denoted an AST (even
though it is a list of trees, not a single tree).

\section{AST}
The program consists of the concatenation of the ASTs
of each parse unit, resulting in a single AST, which
is then translated to a C++ translation unit by the
compiler.

\section{Grammar}
The Felix grammar is part of the library.
It is notionally prefixed to each file to be processed
prior to any import files to specify the syntax
with which the file is to be parsed and translated to
an AST.

The grammar uses an augmented BNF like syntax
with parse actions specified in R5RS Scheme.

The resulting S-expressions are translated to
an intermediate form and then into an internal
AST structure.

The parser is a scannerless GLR parser with significant
extensions.

\section{Grammar syntax}
Not written yet. Browse the 
\href{http://felix-lang.org/share/lib/grammar}{grammar directory} 
for examples.

% =====================================
\chapter{Modules}
Every Felix program is encapsulated in a module with
the name being a mangle of the basename of the root unit.
The mangling replaces characters in the filename with
other characters so that the module name is a valid
ISO C identifier.

\section{Special procedure {\tt flx\_main}}
A program module may contain at most one top level
procedure with no arguments, exported as \verb%flx_main%. 
After initialisation code suspends or terminates, this procedure is invoked
if it exists. It is the analogue of \verb%main% in C++
however it is rarely used: side-effects of the
root unit initialisation code are typically used instead.

A simple example:

\begin{minted}{felix}
println "Init";
var i,o = mk_ioschannel_pair[int]();
write (o,42);

export proc flx_main()
{
  println$ "main " + (read i).str;
  println$ "done ..";
}

println$ "Init done";
\end{minted}

produces output:

\begin{minted}{text}
Init
main 42
done ..
Init done
\end{minted}

Note that \verb%flx_main% must be exported to ensure that
an \verb%extern "C"% symbol is created by the linker.

\section{Libraries}
In Felix a library is a root unit together with its
transitive closure with respect to inclusion,
which does not contain a top level exported \verb%flx_main%.

A program unit can be augmented by a set of libraries
which are then considered as if included, but without
an include directive being present.


% =====================================
\chapter{Lexicology}
All Felix files are considered to be UTF-8 encoded Unicode.

Felix uses a scannerless parser, there are no keywords.

\section{Identifiers}
A plain identifier starts with a letter or underscore,
then consists of a sequence of letters, digits, apostrophy, has no more
than one apostrophy or dash in a row, except at the end no dash is
allowed, and any number of apostrophies.

\begin{minted}{felix}
Ab_cd1  a' b-x
\end{minted}

Identifies starting with underscore are reserved for the implementation.

A letter may be any Unicode character designated for use in an identifier
by the ISO C++ standard. In practice, all high bit set octets are allowed.

\subsection{TeX Identifiers}
A TeX identifier starts with a slosh and is followed by a sequence
of letters. 

\href{http://felix-lang.org/share/src/web/ref/texops.fdoc}{TeX Symbols} 

\section{Operator Identifiers}
Felix allows some operators to be used as an identifier.
For example you can write:

\begin{minted}{felix}
fun +: int * int -> int = "$1+$2";
\end{minted}

to define addition on int in C. Symbols recognised by the parser
such as \verb%+% are usually mapped to functions with the same
name as the operator.`

These operators are recognised as identifiers by the parser in
positions where an identifier is expected:

\begin{verbatim}
    +  -  *  /  %  ^  ~  
    \&  \  \^ 
    &=  =  +=  -=  *=  /=  %=  ^=  <<=  >>= 
    <  >  ==  !=  <=  >=  <<  >> 
\end{verbatim}

\subsection{Special identifiers}
The special literal with a "n" or "N" prefix is a way to encode
an arbitrary sequence of characters as an identifer in a context
where the parser might interpret it otherwise.
It can be used, for example, to define special characters as functions.
For example:

\begin{minted}{felix}
typedef fun n"@" (T:TYPE) : TYPE => cptr[T];
\end{minted}

\chapter{Macro processing}
\href{http://felix-lang.org/share/lib/grammar/macros.fsyn}{Syntax}

\href{http://felix-lang.org/share/src/compiler/flx_desugar/flx_macro.ml}{Semantics}
\section{Include Directive}
An include directive has the syntax:

\begin{minted}{felix}
include "filename";\end{minted}

where the filename is a Unix relative filename,
may not have an extension, and may not begin with or 
contain \verb%..% (two dots).

If the filename begins with \verb%./% then the balance of the name
is relative, a sibling of the including file, otherwise the name
is searched for on an include path. 

In either case, a search succeeds when it finds a file with
the appropriate base path in the search directory with
extension \verb%.flx% or \verb%.fdoc%. If both files exist the
most recently changed one is used. If the time stamps are
the same the choice is unspecified.

\section{Macro val}
The macro val statement is used to specify an identifier should
be replaced by the defining expression wherever it occurs in an
expression, type expression, or pattern.

\begin{minted}{felix}
macro val WIN32 = true;
macro val hitchhiker;
macro val a,b,c = 1,2,3;
\end{minted}


\section{Macro for}
This statement allows a list of statements to be repeated
with a sequence of replacements.

\begin{minted}{felix}
forall name in 1,2,3 do
  println$ name;
done
\end{minted}


\section{Constant folding and conditional compilation}
\href{http://felix-lang.org/share/src/compiler/flx_desugar/flx_constfld.ml}{Reference}

Felix provides two core kinds of constant folding:
folding of arithmetic, boolean, and string values, and 
deletion of code, either statements or expressions,
which would become unreachable due to certain
value of conditionals.

Basic operations on integer literals, namely 
addition, subtraction, negation, multiplication,
division, and remainder are folded.

Strings are concatenated.

Boolean and, or, exclusive or, and negation,
are evaluated.

False branches of if/then/else/endif expression
and match expressions are eliminated.

False branches of if/do/elif/else/done 
are also eliminated.

By this mechanism of constant folding and
elimination, Felix provides conditional
compilation without the need for special
constructions.



% =====================================
\chapter{Core Primitive Types}

\section{Integer types}

\href{http://felix-lang.org/share/lib/grammar/grammar_int_lexer.fsyn}{Reference}

An plain integer literal consists of a sequence of digits,
optionally separated by underscores. Each separating
underscore must be between digits.

A prefixed integer literal is a plain integer literal
or a plain integer literal prefixed by a radix specifier.
The radix specifier is a zero followed by one of
the letters \verb%bBoOdDxX% for binary, octal, decimal or hex.

An underscore is permitted after the prefix.

The radix is the one specified by the prefix or decimal
by default.

The digits of an integer consist of those permitted
by the radix: \verb%01% for binary, \verb%01234567%
for octal, \verb%0123456789% for decimal, \verb%0123456789abcdefABCDEF%
for hex.

Note there are no negative integer literals.

A type suffix may be added to the end of a prefixed
integer to designate a literal of a particular integer type,
it has the form of an upper or lower case letter or pair of
letters usually combined with a prefix or suffix \verb%u} or @{U%
to designate an unsigned variant of the type. 

There is a table of the types \ref{Int Operators}.

\begin{table}
\caption{Felix Integer Types}
\label{Felix Integer Types}
\centering
\begin{tabular}[c]{lll}
\hline
Felix&C&Suffix\\
\hline
\multicolumn{3}{c}{Standard signed integers}\\
\hline
\verb%tiny% &\verb%char% & 42t \\
\verb%short% &\verb%short% & 42s \\
\verb%int% &\verb%int% & 42 \\
\verb%long% &\verb%long% & 42l \\
\verb%vlong% &\verb%long long% & 42ll \\
\multicolumn{3}{c}{Standard unsigned integers}\\
\hline
\verb%utiny% &\verb%unsigned char% & 42ut \\
\verb%ushort% &\verb%unsigned short% & 42us \\
\verb%uint% &\verb%unsigned int% & 42u \\
\verb%ulong% &\verb%unsigned long% & 42ul \\
\verb%uvlong% &\verb%unsigned long long% & 42ull \\
\multicolumn{3}{c}{Exact signed integers}\\
\hline
\verb%int8% &\verb%int8_t% & 42i8 \\
\verb%int16% &\verb%int16_t% & 42i16 \\
\verb%int32% &\verb%int32_t% & 42i32 \\
\verb%int64% &\verb%int64_t% & 42i64 \\
\multicolumn{3}{c}{Exact unsigned integers}\\
\hline
\verb%uint8% &\verb%uint8_t% & 42u8 \\
\verb%uint16% &\verb%uint16_t% & 42u16 \\
\verb%uint32% &\verb%uint32_t% & 42u32 \\
\verb%uint64% &\verb%uint64_t% & 42u64 \\
\multicolumn{3}{c}{Weird ones}\\
\hline
\verb%size% &\verb%size_t% & 42uz \\
\verb%intptr% &\verb%uintptr_t% & 42p \\
\verb%uintptr% &\verb%uintptr_t% & 42up \\
\verb%ptrdiff% &\verb%ptrdiff_t% & 42d \\
\verb%uptrdiff% &\verb%ptrdiff_t% & 42ud \\
\verb%intmax% &\verb%intmax_t% & 42j\\
\verb%uintmax% &\verb%uintmax_t% & 42uj \\
\multicolumn{3}{c}{Addressing}\\
\hline
\verb%address% &\verb%void*% &\\
\verb%byte% &\verb%unsigned char% &\\
\end{tabular}
\end{table}


Note that all these types are distinct unlike C and C++.
The types designated are not the complete set of available
integer like types since not all have literal representations.

Note the suffices do not entirely agree with C.


Signed integers are expected to be two's complement with one
more negative value that positive value. Bitwise and,
or, exclusive or, and complement operations do not apply
with signed types.

The effect of overflow on signed types is unspecified.

Unsigned types use the standard representation. 
Bitwise operations may be applied to unsigned types.
Basic arithmetic operations on unsigned types are
all well defined as the result of the operation
mathematically modulo the maximum value of the type
plus one.

The maximum value of an unsigned type is one less than
two raised to the power of the number of bits in the type.
The number of bits is 8, 16, 32, or 64 or 128 for all unsigned types.

There is a table of the operators \ref{Integer Operators}.

\begin{table}
\caption{Integer Operators}
\label{Integer Operators}
\centering
\begin{tabular}[c]{lll}
\hline
name&kind&semantics\\
\hline
\multicolumn{3}{c}{All Integers}\\
\hline
\verb%==%&\verb%T * T -> bool%&equality\\
\verb%!=%&\verb%T * T -> bool%&inequality\\
\verb%<%&\verb%T * T -> bool%&less\\
\verb%<=%&\verb%T * T -> bool%&less or equal\\
\verb%>%&\verb%T * T -> bool%&greater\\
\verb%>=%&\verb%T * T -> bool%&greater or equal\\
\verb%+%&\verb%T * T -> T%&addition\\
\verb%-%&\verb%T * T -> T%&subtraction\\
\verb%*%&\verb%T * T -> T%&multiplication\\
\verb%/%&\verb%T * T -> T%&quotient\\
\verb+%+&\verb%T * T -> T%&remainder\\
\verb%<<%&\verb%T * T -> T%&multiplication by power of 2\\
\verb%>>%&\verb%T * T -> T%&division by power of 2\\
\verb%-%&\verb%T -> T%&negation\\
\verb%+%&\verb%T -> T%&no op\\
\multicolumn{3}{c}{Signed Integers}\\
\hline
\verb%sgn%&\verb%T -> T%&sign\\
\verb%abs%&\verb%T -> T%&absolute value\\
\multicolumn{3}{c}{Unsigned Integers}\\
\hline
\verb%\&%&\verb%T * T -> T%&bitwise and\\
\verb%\|%&\verb%T * T -> T%&bitwise or\\
\verb%\^%&\verb%T * T -> T%&bitwise exclusive or\\
\verb%~%&\verb%T * T -> T%&bitwise complement\\
\end{tabular}
\end{table}

\section{Floating point types}
\href{http://felix-lang.org/share/lib/grammar/grammar_float_lexer.fsyn}{Reference}

Floating point literals follow ISO C89, except that underscores
are allowed between digits, and a a digit is required both before
and after the decimal point if it is present.

The mantissa may be decimal, or hex, a hex mantissa uses a
leading 0x or 0X prefix optionally followed by an underscore.

The exponent may designate a power of 10 using E or e,
or a power of 2, using P or p.

A suffix may be F,f,D,d, L or l, designating floating type,
double precision floating type, or long double precision floating 
type.

\begin{minted}{felix}
123.4
123_456.78
12.6E-5L
0xAf.bE6f
12.7p35
\end{minted}

There is a table of the operators \ref{Floating Operators}.

\begin{table}
\caption{Floating Point Operators}
\label{Floating Operators}
\centering
\begin{tabular}[c]{lll}
\hline
name&kind&semantics\\
\hline
\hline
\verb%==%&\verb%T * T -> bool%&equality\\
\verb%!=%&\verb%T * T -> bool%&inequality\\
\hline
\verb%<%&\verb%T * T -> bool%&less\\
\verb%<=%&\verb%T * T -> bool%&less or equal\\
\verb%>%&\verb%T * T -> bool%&greater\\
\verb%>=%&\verb%T * T -> bool%&greater or equal\\
\hline
\verb%+%&\verb%T * T -> T%&addition\\
\hline
\verb%-%&\verb%T * T -> T%&subtraction\\
\hline
\verb%*%&\verb%T * T -> T%&multiplication\\
\hline
\verb%/%&\verb%T * T -> T%&quotient\\
\hline
\verb%-%&\verb%T -> T%&negation\\
\end{tabular}
\end{table}

\section{Complex types}
There is a table of the operators \ref{Complex Operators}.

\begin{table}
\caption{Complex Operators}
\label{Complex Operators}
\centering
\begin{tabular}[c]{lll}
\hline
name&kind&semantics\\
\hline
\hline
\verb%==%&\verb%T * T -> bool%&equality\\
\verb%!=%&\verb%T * T -> bool%&inequality\\
\hline
\verb%+%&\verb%T * T -> T%&addition\\
\hline
\verb%-%&\verb%T * T -> T%&subtraction\\
\hline
\verb%*%&\verb%T * T -> T%&multiplication\\
\hline
\verb%/%&\verb%T * T -> T%&quotient\\
\hline
\verb%-%&\verb%T -> T%&negation\\
\end{tabular}
\end{table}


\section{Quaternion type}
There is a table of the operators \ref{Quaternion Operators}.

\begin{table}
\caption{Quaternion Operators}
\label{Quanternion Operators}
\centering
\begin{tabular}[c]{lll}
\hline
name&kind&semantics\\
\hline
\hline
\verb%==%&\verb%T * T -> bool%&equality\\
\verb%!=%&\verb%T * T -> bool%&inequality\\
\hline
\verb%+%&\verb%T * T -> T%&addition\\
\hline
\verb%-%&\verb%T * T -> T%&subtraction\\
\hline
\verb%*%&\verb%T * T -> T%&multiplication\\
\hline
\verb%/%&\verb%T * T -> T%&quotient\\
\hline
\verb%-%&\verb%T -> T%&negation\\
\end{tabular}
\end{table}



\section{Strings}

\href{http://felix-lang.org/share/lib/grammar/grammar_string_lexer.fsyn}{Reference}

Generaly we follow Python here.
Felix allows strings to be delimited by;
single quotes ',
double quotes ",
triped single quotes ''' or
tripled double quotes """.

The single quote forms must be on a single line.

The triple quoted forms may span lines, and include embedded newline
characters.

The complete list of special escapes is shown in table \ref{String Escapes}.

\begin{table}
\caption{String Escapes}
\label{String Escapes}
\centering
\begin{tabular}[c]{lll}
\multicolumn{3}{c}{Basic}\\
Escape&Name&Decimal Code\\
\hline
\verb%\a%&ASCII Bell& 7\\
\verb%\b%&ASCII Backspace&8\\
\verb%\t%&ASCII Tab&9\\
\verb%\n%&ASCII New Line&10\\
\verb%\r%&ASCII Vertical Tab&11\\
\verb%\f%&ASCII Form Feed&12\\
\verb%\r%&ASCII Carriage Return&13\\
\verb%\'%&ASCII Single Quote&39\\
\verb%\"%&ASCII Double Quote&34\\
\verb%\\%&ASCII Backslash&92\\
\multicolumn{3}{c}{Numeric}\\
\hline
\verb%\d%999&Decimal encoding&\\
\verb%\o%777&Octal encoding&\\
\verb%\x%FF&Hex encoding&\\
\verb%\u%FFFF&UTF-8 encoding&\\
\verb%\U%FFFFFFFF&UTF-8 encoding&\\
\end{tabular}
\end{table}

\subsection{Raw strings}
A prefix "r" or "R" on a double quoted string
or triple double quoted string suppresses escape processing,

this is called a raw string literal.
NOTE: single quoted string cannot be used!

\subsection{Null terminated strings}
A prefix of "c" or "C" specifies a C NTBS (Nul terminated
byte string) be generated instead of a C++ string.
Such a string has type +char rather than string.

\subsection{Perl interpolation strings}
A literal prefixed by "q" or "Q" is a Perl interpolation
string. Such strings are actually functions.
Each occurrence of \verb%$(varname)% in the string is replaced
at run time by the value "str varname". The type of the
variable must provide an overload of "str" which returns
a C++ string for this to work.

\subsection{C format strings}
A literal prefixed by a "f" or "F" is a C format string.

Such strings are actually functions.

The string contains code such as "%d" or other supported
C format specifiers. 

Variable field width specifiers "*" are not permitted. 

The additional format specification %S
is supported and requires a Felix string argument.

Such functions accept a tuple of values like this:

\begin{minted}{felix}
f"%d-%S" (42, "Hello")
\end{minted}

If \verb%vsnprintf% is available on the local platform it is used
to provide an implementation which cannot overrun.
If it is not, \verb%vsprintf% is used instead with a 1000 character
buffer.

The argument types and code types are fully checked for type safety.

\section{Regexps}

\chapter{General lookup}
By default Felix looks up symbols in nested scopes, 
starting with all symbols in the current scope
and proceeding through its containing scope outwards
until the outermost scope is reached.

Symbols are visible in the whole of a scope,
both before and after their introduction.

A symbol lookup may properly find either a single
non-function symbol, which is final, or a set 
of function symbols.

If the kind of symbol being sought is a function 
symbol, overload resolution is performed on 
the set of function signatures found in a scope.
If a best match is found, that is final.
If no match is found the search continues in 
the next outermost scope.

All other cases are in error.

\chapter{Classes}
\href{http://felix-lang.org/share/lib/grammar/namespaces.fsyn}{Syntax}

The top level Felix module can contain submodules 
which are specified by a non-polymorphic class
statement:

\begin{minted}{felix}
class classname { ... }
\end{minted}

The effect is to produce a qualified name to be used
outside the class:

\begin{minted}{felix}
class classname { proc f () {} }
classname::f (); 
\end{minted}

Classes may be nested.

A class may contain private definitions:

\begin{minted}{felix}
class X {
  private var a = 1;
}
// X::a will fail, since a is private to the class X
\end{minted}

A private definition is visible within the scope
of the class but not outside it.

A class must be specified within a single file.

Classes are not extensible, a definition of a class
with the same name in the same scope is not permitted.

The body of a class forms a nested scope. Within
a class all symbols defined in the class are visible,
along with all those visible in the enclosing context.

The reserved name \verb%root% may be used as a prefix
for the top level module:

\begin{minted}{felix}
var x = 1;
class A { var x = root::x; }
\end{minted}

\chapter{Lookup control directives}

\section{Open directive}
The simple \verb%open% directive may be used to make the symbols
defined in a class visible in the scope containing the \verb%open% directive.

\begin{minted}{felix}
class X { var x = 1; }
open X;
println$ x;
\end{minted}


Names made visible by an open directive
live in a weak scope under the current scope.
Names in the weak scope may be hidden by definitions
in the current scope without error.

\begin{minted}{felix}
class X { var x = 1; }
open X;
var x = 2;
println$ x; // prints 2
\end{minted}


The open directive is not transitive.
The names it makes visible are only visible
in the scope in which the open directive is written.

\section{Inherit directive}
The inherit directive allows all of the public symbols
of a class to be included in another scope as if they
were defined in that scope. This means such names
inherited into a class can be accessed by qualification
with the inheriting class name, and will be visible
if that class is opened. 

Inheriting is transtitive.

If a name is inherited it will clash with a local definition.

\begin{minted}{felix}
class A { var a = 1; }
class B { inherit A; }
println$ B::a;
\end{minted}


\section{Rename directive}
This directive is can be used to inherit a single
symbol into a scope, possibly with a new name,
and also to add an alias for a name in the current
scope.

When applied to a function name all functions with
that name are renamed.


\begin{minted}{felix}
class A { 
  var a = 1; 
  proc f() {} 
  proc f(x:int) {} 
}

class B { 
  rename a = A::a;
  rename fun f = A::f;
}
\end{minted}

The new name injected by a rename may be polymorphic:

\begin{minted}{felix}
class A { proc f[T] () {} }
class B { rename g[T] = A::f[T]; } 
\end{minted}

\section{Use directive}
This is a short form of the rename directive:

\begin{minted}{felix}
class A { var a = 1; }
class B { use A::a; use b = A::a; }
\end{minted}

It cannot be applied to functions. The first
form is equivalent to

\begin{minted}{felix}
use a = A::a;
\end{minted}

Unlike the rename directive the new name cannot be polymorphic
and is limited to a simple identifier.

\section{Export directives}
The \verb%export% directives make the exported symbol a root
of the symbol graph. 

The functional export and forces it to be place in the
generated code as an \verb%extern "C"% symbol with the
given name:


\begin{minted}{felix}
export fun f of (int) as "myf";
export cfun f of (int) as "myf";
export proc f of (int) as "myf";
export cproc f of (int) as "myf";
\end{minted}


Functions are exported by generating a wrapper around
the Felix function. If the function is exported as \verb%fun%
or \verb%proc% the C function generated requires a pointer
to the thread frame as the first argument,
if the \verb%cfun% or \verb%cproc% forms are used, the wrapper
will not require the thread frame. 

In the latter case, the Felix function must not
require the thread frame.

A type may also be exported:

\begin{minted}{felix}
export type ( mystruct ) as "MyStruct";
\end{minted}

This causes a C typedef to be emitted making 
the name \verb%MyStruct% an alias to the Felix type.
This is useful because Felix types can have unpredictable
mangled names.

The word \verb%export% optionally followed by a string
may also be used as a prefix for any Felix function,
generator, or procedure definition. If the string
is omitted is taken as the symbol name. The effect
is the same as if an export statement has been written.


\part{Executable Code}
\chapter{Variable Definitions}
\href{http://felix-lang.org/share/lib/grammar/variables.fsyn}{Syntax}

A definition is a statement which defines a name, but does
no cause any observable behavior, or, a class statement, or, 
a var or val statement. The latter two exceptions define a name
but may also have associated behaviour.

\section{The {\tt var} statement}
The \verb%var% statement is used to introduce a variable name
and potential executable behaviour. It has one of three 
basic forms:

\begin{minted}{felix}
var x : int = 1;
var y : int;
var z = 1;
\end{minted}

The first form specifies the type and an initialising
expression which must be of the specified type.

The second form specifies a variable of the given type
without an explicit initialiser, however the variable
will be initialised anyhow with the default contructor
for the underlying C++ type, although that constructor
may be trivial.

The third form does not specify the type, it will be deduced
from the initialiser.

If the initialiser has observable behaviour it will be observed
if at all, when control passes through the variable statement.

If the variable introduced by the \verb%var% statement is not used,
the variable and its initaliser will be elided and any observable
behaviour will be lost.

To be used means to have its address taken in a used expression,
to occur in a used expression. A used expression is one which
initialises a used variable, or, is an argument to function
or generator in a used expression, or an argument to a procedure
through which control passes. 

In other words, the variable is used if the behaviour of
the program appears to depend on its value or its address.

The library procedure \verb%C_hack::ignore% ensures the compiler
believes a variable is used:

\begin{minted}{felix}
var x = expr;
C_hack::ignore x;
\end{minted}

so that any side effects of \verb%expr% will be seen.
In general the argument to any primitive function, generator
or procedure will be considered used if its containing 
entity is also considered used. In general this means there
is a possible execution path from a root procedure of the
program.

A variable may have its address taken:

\begin{minted}{felix}
var x = 1;
var px = &x;
\end{minted}

it may be assigned a new value directly or indirectly:

\begin{minted}{felix}
x = 2;
px <- 3;
*px = 4;
\end{minted}


A variable is said to name an object, not a value.
This basically means it is associated with the address of a typed
storage location.

\subsection{Multiple variables}
Multipls variables can be defined at once:


\begin{minted}{felix}
var m = 1,2;
var a,b = 1,2;
var c,d = m;
\end{minted}

With this syntax, no type annotation may be given.

\section{The \tt{val} statement.}
A \verb%val% statement defines a name for an expression.

\begin{minted}{felix}
val x : int = 1;
val z = 1;
\end{minted}

The value associated with a \verb%val% symbol may be computed
at any time between its definition and its use, and may
differ between uses, if the initialising expression depends
on variable state, such as a variable or call to a generator.

It is not an error to create such a dependence since either
the value may, in fact, not change, or the change may
not be significant.

Nevertheless the user must be warned to take care
with the indeterminate evaluation time and use
a \verb%var% when there is any doubt.

Since a \verb%val% simply names an expression, it is associated
with a value not an object and cannot be addressed
or assigned to. However this does NOT mean its value cannot
change:

\begin{minted}{felix}
for var i in 0 upto 9 do
  val x = i;
  println$ x;
done
\end{minted}

In this example, x isn't mutable but it does take on
all the values 0 to 9 in succession. This is just a 
most obvious case: a less obvious one:

\begin{minted}{felix}
var i = 0;
val x = i;
println$ x;
++i;
println$ x;
\end{minted}

which is clearly just an expansion of the the first two
iteration of the previously given for loop. However in
this case there is no assurance \verb%x% will change after \verb%i%
is incremented because the compiler is free to replace
any \verb%val% definition with a \verb%var% definition.

\subsection{Multiple values}
Multipls values can be defined at once:

\begin{minted}{felix}
val m = 1,2;
val a,b = 1,2;
val c,d = m;
\end{minted}

With this syntax, no type annotation may be given.



\chapter{Functions }
\href{http://felix-lang.org/share/lib/grammar/functions.fsyn}{Syntax}

\section{Functions }
A felix function definition takes one of three basic forms:

\begin{minted}{felix}
fun f (x:int) = { var y = x + x; return y + 1; }
fun g (x:int) => x + x + 1;
fun h : int -> int = | x => x + x + 1;
\end{minted}

The first form is the most general, the body 
of the function contains executable statements
and the result is returned by a return statement.

The second form is equivalent to a function in the first
form whose body returns the RHS expression.

The third form specifies the function type then the
body of a pattern match. It is equivalent to

\begin{minted}{felix}
fun h (a:int) = { return match a with | x => x + x + 1 endmatch; }
\end{minted}

The first two forms also allow the return type to be
specified:

\begin{minted}{felix}
fun f (x:int) : int = { var y = x + x; return y + 1; }
fun g (x:int) :int => x + x + 1;
\end{minted}


Functions may not have side effects.

All these function have a type:

\begin{minted}{felix}
D -> C
\end{minted}

where D is the domain and C is the codomain: both would
be \verb%int% in the examples.

A function can be applied by the normal forward
notation using juxtaposition or what is whimsically
known as operator whitespace, or in reverse notation
using operator dot:

\begin{minted}{felix}
f x
x.f
\end{minted}

Such applications are equivalent.  Both operators are left
associative. Operator dot binds more
tightly than whitespace so that

\begin{minted}{felix}
f x.g    // means
f (g x)
\end{minted}


A special notation is used for application to the unit tuple:

\begin{minted}{felix}
#zero // means
zero ()
\end{minted}

The intention is intended to suggest a constant since a pure
function with unit argument must always return the
same value. 

This hash operator binds more tightly than operator dot so

\begin{minted}{felix}
#a.b // means
(#a).b
\end{minted}



\section{Pre- and post-conditions}
A function using one of the first two forms
may have pre-conditions, post-conditions, or both:

\begin{minted}{felix}
fun f1 (x:int when x > 0) => x + x + 1;
fun f2 (x:int) expect result > 1 => x + x + 1;
fun f3 (x:int when x > 0) expect result > 1 => x + x + 1;
fun f4 (x:int when x > 0) : int expect result > 1 => x + x + 1;
\end{minted}

Pre- and pos-conditions are usually treated as boolean assertions
which are checked at run time. The compiler may occasionally be able
to prove a pre- or post-condition must hold and elide it.

The special identifier \verb%result% is used to indicate the return
value of the function.

\section{Higher order functions}
A function may be written like

\begin{minted}{felix}
fun hof (x:int) (y:int) : int = { return x + y; }
fun hof (x:int) (y:int) => x + y;
\end{minted}

These are called higher order functions of arity 2.
They have the type

\begin{minted}{felix}
int -> int -> int   // or equivalently
int -> (int -> int) //since -> is right associative.
\end{minted}

They are equivalent to

\begin{minted}{felix}
fun hof (x:int) : int -> int = 
{
  fun inner (y:int) : int => x + y;
  return inner;
}
\end{minted}

that is, a function which returns another function.

Such a function can be applied like

\begin{minted}{felix}
hof 1 2 // or equivalently
(hof 1) 2
\end{minted}

since whitespace application is left associative.

\section{Procedures}
A function which returns control but no value is called a procedure.
Procedures may have side effects.


\begin{minted}{felix}
fun show (x:int) : 0 = { println x; }
proc show (x:int) { println x; }
proc show (x:int) => println x;
\end{minted}


The second form is a more convenient notation.
The type 0 is also called \verb%void% and denotes
a type with no values.

A procedure may return with a simple return statement:


\begin{minted}{felix}
proc show (x:int) { println x; return; }
\end{minted}


however one is assumed at the end of the procedure
body.

Procedures can also have pre- and post-conditions.

A procedure may be called like an application,
however it must be a whole statement since
expressions of type void may not occur interior
to an expression.


\begin{minted}{felix}
show 1;
1.show;
\end{minted}


If a procedure accepts the unit argument, it may be elided:


\begin{minted}{felix}
proc f () =>  show 1;
f; // equivalent to
f ();
\end{minted}


\section{Generators}
A generator is a special kind of function which is allowed
to have side effects. It is defined similarly to a function,
but using the binder \verb%gen% instead of \verb%fun%:


\begin{minted}{felix}
var seqno = 1;
gen seq () { var result = seqno; ++seqno; return result; }
\end{minted}


When a generator is directly applied in an expression, the application
is replaced by a fresh variable and the generator application
is lifted out and assigned to the variable. For example:


\begin{minted}{felix}
fun twice (x:int) => x + x;
println$ twice #seq;
\end{minted}


will always print an even number because it is equivalent to


\begin{minted}{felix}
var tmp = #seq;
println$ twice tmp;
\end{minted}


Therefore even if twice is inlined we end up with the argument
to \verb%println} being @{tmp+tmp} and not @{#seq+#seq% which would
print an odd number.

\subsection{Yielding Generators}
A generator may contain a \verb%yield% statement:

\begin{minted}{felix}
gen fresh() {
  var x = 1;
  while x < 10 do
    yield x;
    ++x;
  done
  return x;
}
\end{minted}

In order to use such a yielding generator, a closure of the generator
must be stored in a variable. Then the generator may be called repeatedly.


\begin{minted}{felix}
var g = fresh;
for i in 1 upto 20 do 
  println$ i,#g;
done
\end{minted}


This will print pairs (1,1), (2,2) up to (10,10) then print
(11,10), (12,10) up to (20,10).

The yield statement returns a value such that a subsequent call
to a closure of the generator will resume execution after the yield
statement. Therefore \verb%yield% is a kind of cross between a return
and a subroutine call.

If a generator executes a return statement, that is equivalent
to yielding a value and setting the resume point back to the return
statement, in other words \verb%return expr;% is equivalent to

\begin{minted}{felix}
while true do yield expr; done
\end{minted}


Yielding generators should not be called directly because they
will always start at the beginning with a fresh copy of any
local variables used to maintain state.

Function closures differ from generator closures in that
the closures is cloned before every application to ensure
that the initial state is fresh.

Yielding generators are primarily intended to implement iterators,
that is, to provide lazy lists or streams.

\section{Constructors}
Felix provides a special notation which allows an identifier
naming a type to return a value of that type:

\begin{minted}{felix}
typedef cart = dcomplex;
typedef polar = dcomplex;
ctor cart (x:double, y:double) => dcomplex (x,y);
ctor polar (r: double, theta: double) => 
  dcomplex (r * sin theta, r * cos theta)
;
var z = cart (20.0,15.0) + polar (25.8, 0.7 * pi);
\end{minted}

The constructions are equivalent to

\begin{minted}{felix}
fun _ctor_cart (x:double, y:double) : cart => dcomplex (x,y);
fun _ctor_polar (r: double, theta: double): polar => 
  dcomplex (r * sin theta, r * cos theta)
;
\end{minted}

When a type with a simple name is applied to a value,
Felix tries to find a function with that name prefixed by  \verb%_ctor_%
instead.

Note that Felix generates a constructor for struct and cstruct types
automatically with argument type the product of the types of the
structure fields.

\section{Special function {\tt apply}}
When Felix finds and application

\begin{minted}{felix}
  f a
\end{minted}

where \verb%f% is a value of type F which is not
a function (or C function) type, Felix looks instead 
for a function named apply with argument of type:

\begin{minted}{felix}
F * A
\end{minted}

where A is the type of a. For example

\begin{minted}{felix}
fun apply (x:string, y:string) => x + y; // concat
var x = "hello " "world"; // apply a string to a string
\end{minted}


\section{Objects}
Felix provides an object system with syntax based on Java,
and technology based on CLOS.

An object is a record of function closures, closed over the local
scope of a constructor function that returns the record.


\begin{minted}{felix}
interface person_t {
  get_name: 1 -> string; 
  set_age: int -> 0; 
  set_job : string -> 0;
  get_job : 1 -> string;
}

object person (name:string, var age:int) implements person_t =
{
  var job = "unknown";
  method fun get_name () => name;
  method proc set_age (x:int) { age = x; }
  method fun get_job () => job;
  method proc set_job (x:string) {  job = x; }
}

var john = person ("John", 42);
println$ #(john.name) + " is " + #(john.age).str;
\end{minted}

The entity \verb%person% is a function which when called with
its argument of name and age returns a record of type
\verb%person_t% consisting of closures of the functions and procedures
marked as method in its definition.

Since functions hide their local variables the object state
is hidden and can only be accessed using the methods.

The \verb%implements% clause is optional.

Objects provide an excellent way for a dynamically loaded
shared library to export a set of functions, only the object
function needs to be exported so it has a C name which
can be linked to with \verb%dlopen%.

\part{Type System}
\chapter{Type constructors}
\href{http://felix-lang.org/share/lib/grammar/type_decls.fsyn}{Syntax}

\section{typedef}
The typedef statement is used to define an alias for a type.
It does not create a new type.

\begin{minted}{felix}
typedef Int = int;
\end{minted}


\section{Tuples}
Tuple types are well known: a tuple is just a Cartesian Product
with components identified by position, starting at 0. 
The n-ary type combinator is infix \verb%*% and the n-ary value
constructor is infix \verb%,%:

\begin{minted}{felix}
val tup : int * string * double = 1, "Hello", 4.2;
\end{minted}

The 0-ary tuple type is denoted \verb%1% or \verb%unit%
with sole value \verb%()%:


\begin{minted}{felix}
val u : unit = ();
\end{minted}


The 1-ary tuple of type \verb%T% component value \verb%v% is identified
with the type \verb%T% and has value \verb%v%.

The individual components of a tuple may be accessed by a projection
function. Felix uses an integer literal to denote this function.

\begin{minted}{felix}
var x = 1,"Hello";
assert 0 x == 1; assert x.0 == 1;
assert 1 x == "Hello"; assert x.1 == "Hello";
\end{minted}


[There should be a way to name this function without application to
a tuple!]

A pointer to a tuple is also in itself a tuple, namely the
tuple of pointers to the individual components. This means
if a tuple is addressable, so are the components.

\begin{minted}{felix}
var x = 1, "Hello";
val px = &x;
val pi = px.0; pi <-42;
val ps = px.1; ps <-"World";
assert x.0 == 42;
assert x.1 == "World";
\end{minted}


In particular note:

\begin{minted}{felix}
var x = 1, "Hello";
&x.0 <- 42;
\end{minted}


because the precedences make the grouping \verb%(&x).0%.

You cannot take the address of a tuple component because
a projection of a value is a value.

Assignment to components of tuples stored in variables is supported
but only to one level, for general access you must take a pointer
and use the store-at-address operator \verb%<-%.

\subsection{Tuple projections}
The projections of a tuple can also be written in an expanded form
so that they may stand alone as functions:


\begin{minted}{felix}
var first = proj 0 of (int * string);
var a = 1, "Hello";
var one = a . first; 
var two = a . proj 1 of (int * string);
\end{minted}


\section{Records}
A record is similar to a tuple except the components are 
named and considered unordered up to duplication.

\subsection{Plain Record}
A plain record is one without duplicate fields. A plain record
type is one without duplicate fields or a row variable.
A record is constructed using a parenthesis enclosed list
of comma separated field assignments. An empty record is
equivalent to an empty tuple.

\begin{minted}{felix}
typedef xy = (x:int, y:int);
var r : xy = (x=1,y=2);
\end{minted}

\subsection{Record projections}
A component of a record may be accessed with a 
function called a record value projection, it is denoted
by the name of the field.

\begin{minted}{felix}
var r (x=1,y=2);
println$ x r, r.y;
\end{minted}

Record value projections can also be used as stand-alone
functions. For example:

\begin{minted}{felix}
var rl = list ((x=1,y=11),(x=2,y=22));
var xs =  map (x of (x:int, y:int)) rl;
println$ xs; // list (1,2)
\end{minted}

Records also have pointer projections, overloaded with
the value projections: if the name of
a field is applied to a pointer to a record,
a pointer to the named component field is returned.
This allows assignment and other mutators to be
applied to record components.

\begin{minted}{felix}
var r =(x=1,y=2);
var px = &r.x; // means (&r).x
px <- 42;
r&.y <- 23;
println$ r.x, r.y; // (42,23)
\end{minted}

Record pointer projects can also be used as stand-alone functions:

\begin{minted}{felix}
var prjx = x of (xy);
var prjpx = x of (&xy);
\end{minted}

\subsection{General record}
Records may have duplicate fields. In this case, reading from left
to right in a record literal, a duplicate field is hidden by a previous 
field of the same name, in a push down stack like fashion.
 
\begin{minted}{felix}
var r = (x=1,y=2,x="Hello");
println$ r._strr, r.x;
  // ((x=1,x='Hello',y=2), 1)
\end{minted}

Note that the generic function \verb%_strr% displays the whole of the
record including duplicate fields. However projections only find
the left-most field.

\subsection{Adding fields}
Fields can be added to an existing record to construct 
a new record:

\begin{minted}{felix}
var r = (x=1,y=2);
var r2 = (a="one",b="two",x="newx" | r);
println$ r2._strr,r2,x;
  // ((a='one',b='two',x='newx',x=1,y=2), newx)
\end{minted}

Again, leftmost fields hide rightmost ones. You can also add two 
records with infix \verb%+%:

\begin{minted}{felix}
var r = (a=1) + (b=2) + (a="hello");
println$ r._strr, r.a.str; // ((a=1,a='hello',b=2), 1)
\end{minted}

The leftmost field with a given name dominates. Record addition
by \verb%+% is only applied if a user defined addition is not
found for the argument types.

Currently, addition of fields of two records of the same type
is not supported: it is likely the user intended to add corresponding
field values rather than hide the fields in the right argument
with those on the left.


\subsection{Row Polymorphism}
Felix provides a special record type called a {\em polyrecord} which
supports row polymorphism with scoped labels in the style of
Daan Leijen. The article
is \href{http://research.microsoft.com/pubs/65409/scopedlabels.pdf}{here}.

This allows a generic function to be written which accepts an argument
which is or contains a value of a record type with more fields than
required. Unlike subtyping, the extra fields, whilst inaccessible,
are not lost and can be returned by the function. For example:

\begin{minted}{felix}
val circle = (x=0.0,y=0.0,r=1.0);
val square = (x=0.0,y=0.0,w=1.0,h=1.0);

fun move[T] (dx:double, dy:double) (shape: (x:double, y:double | T)) =>
  (x=shape.x+dx, y=shape.y+dx | (shape without x y))
;

var inc = 1.0,1.0;
println$ (move inc circle)._strr, (move inc square)._strr;
\end{minted}

\subsubsection{{\tt without} operator}
The \verb%without% operator can be used to return a record
with some fields removed. It works on values of record and
polyrecord type. Note that because Felix uses scoped fields
once a field is removed, the previous value of that field is exposed
if it exists, and can also be removed. This means it is correct
and sometimes necessary to list a field more than once when
using the \verb%without% operator.


\subsection{Interfaces}
An interface is a special notation for a record type
all of whose fields are functions or procedures.

\begin{minted}{felix}
interface fred {
  f: int -> int;
  g: int -> 0; // procedure
}

// equivalent to
typedef fred = (f: int -> int, g: int -> 0);
\end{minted}

The primary use is for specifying the type of a Java like
object.

\section{Structs}
A struct is a a nominally typed record, that is, it must be defined,
and each definition specifies a distinct type.

\begin{minted}{felix}
struct S { x:int; y:int; };
var s : S = S (1,2);
println$ s.x,s.y;
\end{minted}

A struct value can be constructued using the structure name as a function
and passing a tuple of values corresponding by position to the fields
of the struct.

A struct constructor can be used a first class function.

The field names are projection functions and can be applied
to a struct value to extract the nominated component,
or applied to a pointer to a struct to find a pointer to the
nominated component.

The notation (may be changed soon)

\begin{minted}{felix}
var prjx = x of (S);
var prjpx = x of (&S);
\end{minted}

can be used to refer to a projection in isolation, and a pointer
projection in isolation, that is, as unapplied first class functions.

A struct may also contain function and procedure definitions:

\begin{minted}{felix}
struct A { 
  x:int;
  y:int;
  fun get2x => 2 * self.x;
  fun get2y () => 2 * self.y;
  proc diag (d:int) { self.x <- d; self.y <-d; }
};
\end{minted}

These functions are precisely equivalent to:

\begin{minted}{felix}
fun get2x (self:A) => 2 * self.x;
proc diag (self: &A) (d:int) { self.x <-d; self.y <-d; }
\end{minted}

Note that for a function \verb%self} is a value, for a procedure @{self%
is a pointer.

Because of these definitions, we can form object closures over a struct:

\begin{minted}{felix}
var a = A(1,2);
var g2y = a. get2y;
var di = a . diag;
\end{minted}

Note we can't form a closure for \verb%get2x% without an explicit wrapper,
i.e. eta-expansion.

\section{Sums}
Sum types are the dual of tuples. They represent a sequence
of possible cases, potentially with arguments. Case indicies
are 0 origin. Sum variables are decode with a match which
may also extract an argument value:

\begin{minted}{felix}
typedef num = int + long + double;
var x = (case 1 of num) 53L;
println$ 
  match x with
  | case 0 (i) => "int " + i.str
  | case 1 (l) => "long" + l.str
  | case 2 (d) => "double " + d.str
  endmatch
;
\end{minted}


\subsection{Unit sum}
There is a family of special sum types equivalent to:

\begin{minted}{felix}
  2 = 1 + 1
  3 = 1 + 1 + 1
  4 = 1 + 1 + 1
\end{minted}

Recall type 1, or unit, is the type of the empty tuple.
The type 2 is also known as bool, and represents two cases
where \verb%false} is an alias for @{case 0 of 2} and @{true%
is an alias for \verb%case 1 of 2%.

The type 0 or void, is the type of no values.

These types are called unit sums because they're a sum
of a certain number of units.

Note carefully that:

\begin{minted}{felix}
  x + (y + z), (x + y) + z, x + y + z
\end{minted}

are three distinct types because operator + is not associative.

\section{union}
A union is the dual of a struct. It is a nominally typed version
of a sum. Here for example is a list of integers:

\begin{minted}{felix}
union intlist {
  iEmpty ;
  iCons of int * intlist;
};
\end{minted}


This alternative syntax is more commonly used
and comes from ML family:

\begin{minted}{felix}
union intlist = 
  | iEmpty 
  | iCons of int * intlist
;
\end{minted}


The fields of a union type are injections or type constructors.
In effect they cast their argument to the type of the union, thus
unifying heterogenous types into a single type.

Pattern matches are used to decode unions.

\begin{minted}{felix}
var x = iEmpty;
x = iCons (1, x);
x = iCons (2, x); // list of two integers

fun istr (x:intlist) =>
  match x with
  | #iEmpty => "end"
  | iCons (i, tail) => i.str + "," + istr tail
  endmatch
;
\end{minted}


The first variant represents an empty list. The second variant
says that a pair consisting of an int and a list can be considered
as a list by applying the type constructor iCons to it.

Unlike product types, a sum may directly contain itself.
This is because sum types are represented by pointers.

\subsection{enum}
A restricted kind of union, being a nominally typed version
of a unit sum.

\begin{minted}{felix}
enum colour { red, green, blue }; // same as
enum colour = red, green, blue; // same as
union colour = red | green | blue;
\end{minted}


The tag value of an enum can be set:

\begin{minted}{felix}
enum wsize = w8=8, w16=16, w32=32, w64=64;
\end{minted}


\subsection{caseno operator}
The caseno operator can find the tag value of any sum type,
the anonymous sum, union, enum or variant as an integer.

\begin{minted}{felix}
assert caseno w16 == 16;
assert caseno (case 1 of 2) == 1;
\end{minted}


\section{variant}
Wariants the sum type which are the dual of records.
They used named injections like unions but are structurally typed.

\begin{minted}{felix}
typedef vars = union { Int of int ; Float of float; };
\end{minted}


\section{Array}
Felix has various kinds of array. The term is abused and sometimes
refers to the abstract concept, and sometimes the statically
typed fixed length array described here.

An array is nothing but a tuple all of whose elements have the
same type. It is convenient to use an exponential operator with
a  unit sum index to provide a compact notation:

\begin{minted}{felix}
int ^ 3 // array of 3 integers equivalent to
int * int * int
\end{minted}

Therefore the value:

\begin{minted}{felix}
var a3 = 1,2,3;
\end{minted}

is, in fact, an array. As for tuples an integer literal applied
to an array value returns a component, however for arrays,
an expression may be used as well:

\begin{minted}{felix}
var i = 1;
var y = a3 . i;
var z = a3 . proj i of (int^3);
\end{minted}

The last form is equivalent to

\begin{minted}{felix}
var z = a . 
  match i with
  | 0 => proj 0 of (int^3)
  | 1 => proj 1 of (int^3)
  | 2 => proj 2 of (int^3)
  | _ => throw error
  endmatch
;
\end{minted}

in other words there is a run time array bounds check equivalent to a match failure.
Note that of course the actual generated code is optimised!

A run time check can be avoided by using the correct type of index:

\begin{minted}{felix}
var i = case 1 of 3;
var z = a . i; // no run time check
\end{minted}


\subsection{Multi-arrays}
Whilst we introduced the exponential notation

\begin{minted}{felix}
  B ^ J
\end{minted}

as a mere shorthand, where J is a unit sum, in fact Felix allows
the index to be any compact linear type.

A compact linear type is any combination of sums, products,
and exponentials of unit sums. The type

\begin{minted}{felix}
 3 * 4 * 5
\end{minted}

for example is compact linear, and therefore Felix allows the array type

\begin{minted}{felix}
typedef matrix = double ^ (3 * 4 * 5)
\end{minted}

Although this looks like the type

\begin{minted}{felix}
typedef array3 = double  ^ 3 ^ 4 ^ 5
\end{minted}

as suggested by the usual index laws, the latter is an array size 5 of
arrays size 4 of arrays size 3 which can be used like:

\begin{minted}{felix}
var a : array3;
var z = a . case 1 of 5 . case 1 of 4 . case 1 of 3;
\end{minted}

where you will note that the projections are applied in the reverse
order to the indices. On the other hand to use the first form we have
instead:

\begin{minted}{felix}
var m : matrix;
var z = a . (case 1 of 3, case 1 of 4, case 1 of 5);
\end{minted}

The exponent here is a value of a compact linear type.
It is a single tuple value! It is called a multi-index
when applied to an array.

The advantage of this type is that there is an obvious
encoding of the values shown in this psuedo code:

\begin{minted}{felix}
  i * 3 * 4 + j * 3 + k
\end{minted}

which is nothing more than a positional number notation where the
base varies with position. That encoding clearly associates
with the compact linear value as integer in the range 0 to 59,
or, alternatively, an value of type 60. In other words the type
is linear and compact.

Since clearly, given an integer in range 0 through 59 and this type
we can decode the integer into a tuple, being the positional representation
of the integer in this weird coding scheme, the type is clearly
isomorphic to the subrange of integer.

Therefore Felix allows you to coerce an integer to a compact linear
type with a run time check, and convert a compact linear type
to an integer or a unitsum:

\begin{minted}{felix}
var i : int = ((case 1 of 3, case 1 of 4, case 1 of 5) :>> int);
var j : 60 = ((case 1 of 3, case 1 of 4, case 1 of 5) :>> 60);
var clt : 3 * 4 * 5 = (16 :>> 3 * 4 * 5);
\end{minted}

Because we can do this we can now write a loop over a matrix
with a single iterator:

\begin{minted}{felix}
for i in 60 do
  println$ m . (i :>> 3 * 4 * 5);
done
\end{minted}

This is an advanced topic which will require an extensive explanation
beyond the scope of this summary. However we will not that this
facility provides a very high level feature known as polyadic array
programming. In short this means that one may write routines which
work on matrices of arbitrary dimension. You can of course do this
in C by doing your own index calculations at run time and using
casts, however Felix does these calculations for you based on the
type so they're always correct.


\chapter{Meta-typing}
Felix provides some facilities for meta-typing.

\subsection{typedef fun}
The notation

\begin{minted}{felix}
typedef fun diag (T:TYPE):TYPE=> T * T;
var x: diag int = 1,2;
\end{minted}

defines a type function (or functor). Given a type T,
this function returns the type for a pair of T's.
The identifier \verb%TYPE% denotes the kind which is a category 
of all types.

Applications of type functions must be resolved during binding, since
the result may influence overloading.

\section{typematch}
Felix has a facility to inspect and decode types at compile time.

\begin{minted}{felix}
typedef T = int * long;
var x: 
  typematch T with
  | A * B => A
  | _ => int
  endmatch
  = 1
;
\end{minted}

As with type functions, type matches must be resolved during binding.
If a type match fails, an error is issued a compilation halted.
The wildcard type pattern \verb%_% matches any type.

The real power of the type match comes when combined with a type function:

\begin{minted}{felix}
typedef fun promote (T:TYPE): TYPE =>
  typematch T with
  | #tiny => int
  | #short => int
  | #int => int
  | #long => long
  | #vlong => vlong
  endmatch
;
\end{minted}

This functor does integral promotions of signed integer types 
corresponding to ISO C rules.

\section{type sets}
TBD

\chapter{Abstract types}
Felix provides abstract types as demonstrated in this example.

\begin{minted}{felix}
class Rat {
  type rat = new (num:int, den:int);
  ctor rat (x:int, y:int) =>  
    let d = gcd (x,y) in
    _make_rat (num=x/d, den-y/d)
  ;

  fun + (a:rat, b:rat) => 
    let a = _repr_ a in
    let b = _repr_ b in
    _make_rat ( 
      a.num * b.den + b.num * a.den,
      a.den * b.den
    )
  ;
}
\end{minted}

Here, the abstract type \verb%rat% is represented by a record of
two integers, \verb%num} and @{den%, but this type is hidden.

Inside the class \verb%Rat} the operator @{_make_rat% 
casts the implementation value to an abstract value,
and the operator \verb%_repr_% casts the abstract value to its implementation.

These casts cannot be used outside the class, thereby hiding the implementation
outside the class.

\chapter{Polymorphism}
TBD

\part{Expressions}
\href{http://felix-lang.org/share/lib/grammar/expressions.fsyn}{Syntax}

Expressions are listed in approximate order of precedence,
starting with the weakest binding.

We will often exhibit expressions in the form

\begin{minted}{felix}
var x = expr;
\end{minted}

so as to present a complete statement. The \verb%x% is of no significance.
\section{Chain forms}
\subsection{Pattern let}
The traditional let binding of ML.
The syntax is 

\begin{minted}{felix}
var x = let pattern = expr1 in expr2; // equivalent to
var x = match expr1 with pattern => expr2 endmatch
\end{minted}

\begin{minted}{felix}
var x = let a = 1 in a + 1; // equivalent to
var x = match 1 with a => a + 1 endmatch
\end{minted}


\subsection{Function let}
A let form which makes a function available in the
expression

\begin{minted}{felix}
var x = 
  let fun f(y:int)=> y + 1 in 
  f 42
;
\end{minted}

\subsection{Match chain}
A variant on the terminated match which allows a second
match to be chained onto the last branch without any endmatch.

\begin{minted}{felix}
var y = list (1,2);
var x = 
  match y with
  | #Empty => "Empty"
  | _ =>
  match y with 
  | h ! Empty => h.str
  | _ =>
  match y with 
  | h1 ! h2 ! Empty => h1.str + "," + h2.str
;

println$ x;
\end{minted}

\subsection{conditional chain}
A variant on the terminated if/then/elif/else allowing chaining.

\begin{minted}{felix}
var x = 
  if c1 then r1 
  elif c2 then r2 else
  if c3 then r3 else
  r4
;
\end{minted}


\section{Alternate conditional chain}

\begin{minted}{felix}
var x = n / d unless d == 0 then 0;
\end{minted}


\section{Dollar application}
A right associative low precedence forward apply operator taken
from Haskell.

\begin{minted}{felix}
var x =  str$ rev$ list$ 1,2,3;
\end{minted}



\section{Pipe application}
A left associative low precedence reverse apply operator taken
from \verb%C#%.

\begin{minted}{felix}
var x =  1,2,3 |> list |> rev |> str;
\end{minted}


\section{Tuple cons constructor}
A right associative cons operator for tuples. Allows concatenating
an element to the head/front/left end of a tuple. Can also be used
in a pattern match to recursively decode a tuple like a list.

\begin{minted}{felix}
var x =  3,4;
var y = 1 ,, 2 ,, x; // 1,2,3,4
\end{minted}


\section{N-ary tuple constructor}
The is a non-associative n-ary tuple constructor
consists of a sequence of expressions separated by commas.

\begin{minted}{felix}
var x = 1,2,3,4;
\end{minted}


\section{Logical implication}
An operator for function \verb%implies%.

\begin{minted}{felix}
var x = false implies true;
\end{minted}


\section{Logical disjunction}
A chaining operator for function \verb%lor%.

\begin{minted}{felix}
var x = true or false;
\end{minted}

 
\section{Logical conjunction}
A chaining operator for function \verb%land%.

\begin{minted}{felix}
var x = true and false;
\end{minted}


\section{Logical negation}
A bool operator for function \verb%lnot%.

\section{Comparisons}
Non-associative.

\begin{minted}{felix}
var x =
  a < b or 
  a > b or
  a <= b or
  a >= b or
  a == b or
  a != b or
  1 in list(1,2,3)
  1 \in list (1,2,3)
;
\end{minted}


\section{Name temporary}
Allows a subexpression to be named as a \verb%val% by default
or a \verb%var%.

\begin{minted}{felix}
var x = a +  (f y as z) + z; // equivalent to
val z = f y; var x = a + z + z;

var x = a +  (f y as var k) + k; // equivalent to
var k = f y; var x = a + k + k;
\end{minted}

Note that the \verb%var% for ensures the subexpression is eagerly
evaluated, before the containing expression.

\section{Schannel pipe operators}
Used to flow data through schannels from the source on the 
left to the sink on the right via processing units in between.

\begin{minted}{felix}
spawn_fthread$ source |-> filter |-> enhancer |-> sink;
\end{minted}


This variant uses an iterator to stream data out of a data structure:

\begin{minted}{felix}
spawn_fthread$ list (1,2,3) >-> sink;
\end{minted}


\section{Right Arrows}
Right associative arrow operators.

List cons operator.

\begin{minted}{felix}
var x = 1 ! 2 ! list (3,4);
\end{minted}


Function types (type language only):

\begin{minted}{felix}
  D -> C // Felix function
  D --> C // C function pointer
\end{minted}


\section{Case literals}

The case tag is only used in pattern matches.
The sum or union type isn't required because it can be deduced
from the match argument.

\begin{minted}{felix}
var a = match a with Some v  => v | #None => 0;
\end{minted}


The case constructor with integer caseno has two uses. 

It creates a value of
a sum type with no arguments:

\begin{minted}{felix}
var x = case 1 of 2; // aka true
\end{minted}

or it is a function for a sum type variant with an argument:

\begin{minted}{felix}
var x = (case 1 of int + double) 4.2;
\end{minted}


A case literal with a name instead of an integer constructs
a variant instead:

\begin{minted}{felix}
typedef maybe = union { No; Yes of int; };
var x = (case Yes of maybe) 42;
\end{minted}


The tuple projection function names a tuple projection:

\begin{minted}{felix}
typedef triple = int * long * string;
var snd = proj 1 of triple;
var y: int = snd (1, 2L, "3");
\end{minted}


\section{Bitwise or}
Left associative.

\begin{minted}{felix}
var x = q \| b;
\end{minted}


\section{Bitwise exclusive or}
Left associative.

\begin{minted}{felix}
var x = q \^ b;
\end{minted}


\section{Bitwise and}
Left associative.

\begin{minted}{felix}
var x = q \& b;
\end{minted}


\section{Bitwise shifts}
Left associative.

\begin{minted}{felix}
var x = a << b; // left shift
var x = a >> b; // right shift
\end{minted}


\section{Addition}
Chain operator. Non-associative for types. 
Left associative for expressions.

\begin{minted}{felix}
var x = a + b + c;
\end{minted}


\section{Subtraction}
Left associative.

\begin{minted}{felix}
var x = a - b;
\end{minted}


\section{Multiplication}
Chain operator. Non-associative for types.
Left associative for expressions.

\begin{minted}{felix}
var x = a * b;
\end{minted}


\section{Division operators}
Left associative. Not carefully: higher precedence
that multiplication, unlike C!!

\begin{minted}{felix}
var x = a * b / c * d; // means
var x = a * (b / c) * d;

var x = a * b % c * d; // means
var x = a * (b % c) * d;
\end{minted}


\section{Prefix operators}

\begin{minted}{felix}
var x = !a;
var x = -a; // negation
var x = ~a; // bitwise complement
\end{minted}


\section{Fortran exponentiation}
Infix \verb%**} is special syntax for function @{pow%. 
The left operand binds more tightly than \verb%**%
but the right operand binds as for prefixed operators
or more tightly. Observe than that:


\begin{minted}{felix}
var x = -a**-b;  // means
var x = -(a**(-b));
\end{minted}

preserving the usual mathematical syntax. 

\section{Felix exponentiation}
Left associative. The right operand binds as deref operator
or more tightly. Used for array notation in the type language.

\begin{minted}{felix}
var x = a ^ ix;
\end{minted}


\section{Function composition}
Standard math notation. Left associative. Same precedence as
exponentiation. Spelled \verb%\}@{circ%.

\begin{minted}{felix}
var x = f \circ g;
\end{minted}


\section{Dereference}
For function \verb%deref%.

\begin{minted}{felix}
var x = *p;
\end{minted}


For builtin dereference operator:

\begin{minted}{felix}
var x = _deref p;
\end{minted}


Note these usually have the same meaning however
the function \verb%deref% can be overloaded. If the overloaded
definition is not to be circular it may use \verb%_deref%
when dereferencing pointers.

\subsection{Operator new}
Copies a value onto the heap and returns a pointer.

\begin{minted}{felix}
var px = new 42;
\end{minted}


\section{Whitespace application}
Operator whitespace is used for applications.
\subsection{General}

\begin{minted}{felix}
var x = sin y;
\end{minted}


\subsection{Caseno operator}
Returns the integer tag value of the value of an anonymous sum, 
union, or variant  type.

\begin{minted}{felix}
var x = caseno true; // 1
var x = caseno (Some 43); // 1
\end{minted}


\subsection{Likelyhood}
Indicaties if a bool valued expression is likely
or unlikely to be true. Used to generate the corresponding
gcc optimisation hints, if available.

\begin{minted}{felix}
if likely (c) goto restart;
if unlikely (d) goto loopend;
\end{minted}


\section{Coercion operator}
left associative. The right operand is a type.

\begin{minted}{felix}
var x = 1L :>> int; // cast
\end{minted}


\section{Suffixed name}
The most general form of a name:

\begin{minted}{felix}
var x = qualified::name of int;
\end{minted}

Used to name functions, with the right operand specifying
the function argument type.

\section{Factors}
\subsection{Subscript}
Used for array and string subscripting. Calls function \verb%subscript%.
For strings, returns a character. If the subscript is out of range
after adjustment of negative index, returns \verb%char 0% and thus
cannot fail.

\begin{minted}{felix}
var x = a . [ i ]; // i'th element
\end{minted}


\subsection{Subsstring}
Calls function \verb%substring%. Negative indices may be used to
offset from end, i.e. -1 is the index of the last element.
Out of range indices (past the end or before the start, after
adjustment of negative indices) are clipped back to the end
or start respectively.

\begin{minted}{felix}
var x = a . [ first to past]; 
  // past is one past the last element refered to
\end{minted}


\subsection{Copyfrom}
Calls function \verb%copyfrom%. Copies from designated index to end.
Supports negative indices and range clipping for strings.

\begin{minted}{felix}
var x = a . [to past]; // from the first
\end{minted}


\subsection{Copyto}
Calls function \verb%copyto%. Supports negative indices and
range clipping for strings.

\begin{minted}{felix}
var x = a . [to past]; // from the first
\end{minted}


\subsection{Reverse application}
Left associative.

\begin{minted}{felix}
var x = y .f; // means
var x = f y;
\end{minted}


\subsection{Reverse application with deref}
Left associative

\begin{minted}{felix}
var x = p *. k; // means
var x = (*p) . k;
\end{minted}


\subsection{Reverse application with addressing}
Left associative

\begin{minted}{felix}
var x = v &. k; // means
var x = (&v) . k;
\end{minted}


\subsection{Unit application}
Prefix operator applies argument to empty tuple.

\begin{minted}{felix}
var x = #f; // means
var x = f ();
\end{minted}


\subsection{Addressing}
Finds the pointer address of a variable.
Means pointer to in type language.

\begin{minted}{felix}
var x : int = 1;
var px : &int = &x; 
  // address of x
  // type pointer to int
\end{minted}


\subsection{C pointer}
Used in type language for pointer to type or NULL.

\begin{minted}{felix}
var px : @char =  malloc (42);
\end{minted}


Note that this symbol is also used in fdoc as a markup
indicator. Please keep out of column 1, do not follow
with a left brace.

\subsection{Label address}
Used to find the machine address in the code text of
a label. Used with computed goto instruction.

\begin{minted}{felix}
proc f (a: int) {
  var target: LABEL = 
    if a < 0 then label_address neg
    elif a > 0 then label_address pos
    else label_address zer
  ;
  goto-indirect target;
  pos:> println$ "pos"; return;
  neg:> println$ "neg"; return;
  zer:> println$ "zer"; return;
}
\end{minted}


\subsection{Macro freezer}
Used to disable macro expansion of a symbol.

\begin{minted}{felix}
macro val fred = joe;
var x = fred + noexpand fred; // means
var x = joe + fred;
\end{minted}


\subsection{Pattern variable}
Notation \verb%v% Used in patterns to designate a val variable
to be bound in the pattern matching.

\begin{minted}{felix}
var x = 
  match y with 
  | Some v => "Some " + v.str 
  | #None => "None";
;
\end{minted}


\subsection{Parser argument}
Notation \verb%n} for some integer @{n%. In user defined syntax designates
the n'th term of a syntax production.

\section{Qualified name}
A name in Felix has the form:

\begin{minted}{felix}
  class1 :: nested1 :: ... :: identifier [ type1, type2, ... ]
\end{minted}

where the qualifiers and/or type list may be elided. 
This is the same as C++ except we use \verb%[]} instead of @{<>%
for template argument types.

\part{Atoms}
\section{Record expression}

\begin{minted}{felix}
var x = (name="Hello", age=42);
\end{minted}


\section{Alternate record expression}

\begin{minted}{felix}
var x = 
  struct {
    var name = "Hello";
    var age = 42;
  }
;
\end{minted}


\section{Variant type}
Denotes a variant type.

\begin{minted}{felix}
var x : 
  union {
    Cart of double * double;
    Polar of double * double;
  }
;
\end{minted}


\section{Wildcard pattern}
Used in a pattern match, matches anything.

\begin{minted}{felix}
  var x = match a with _ => "anything";
\end{minted}


\section{Ellipsis}
Used only in C bindings to denote varags.

\begin{minted}{felix}
  fun f: int * ... -> int;
\end{minted}


\section{Truth constants}

\begin{minted}{felix}
  false // alias for case 0 of 2
  true  // alias for case 1 of 2
\end{minted}


\section{callback expression}
??

\begin{minted}{felix}
callback [ x ]
\end{minted}


\section{Lazy expression}
Function of unit.

\begin{minted}{felix}
var f = { expr };
var x = f ();
\end{minted}


\section{Sequencing}
Function dependent on final expression.

\begin{minted}{felix}
var x = ( var y = 1; var z = y + y; z + 1 ); // equivalent to
var x = #{ var y = 1; var z = y + y; return z + 1; };
\end{minted}


\section{Procedure of unit.}

\begin{minted}{felix}
var p = { println$ "Hello"; } // procedure
p (); 

var f = { var y = 1; return y + y; }; // function
var x = f ();
\end{minted}


\section{Grouping}
Parentheses are used for grouping.

\begin{minted}{felix}
var x = (1 + 2) * 3;
\end{minted}


\section{Object extension}

\begin{minted}{felix}
var x = extend a,b with c end;
\end{minted}


\section{Conditional expression}

\begin{minted}{felix}
var x =
  if c1 then a elif c2 then b else c endif
;
\end{minted}


\part{Executable statements}
\section{Assignment}
\href{http://felix-lang.org/share/lib/grammar/assignment.fsyn}{Syntax}

\section{The {\tt goto} statement and label {\tt prefix}}
Felix statements may be prefixed by a label
to which control may be transfered by a \verb%goto%
statement:

\begin{minted}{felix}
alabel:>
  dosomething;
  goto alabel;
\end{minted}

The label must be visible from the goto statement.

There are two kinds of gotos. A local goto is a jump
to a label in the same scope as the goto statement.

A non-local goto is a jump to any other visible label.

Non-local transfers of control may cross procedure
boundaries. They may not cross function or generator 
boundaries.

The procedure or function containing the label 
must be active at the time of the control transfer.

A non-local goto may be wrapped in a procedure closure
and passed to a procedure from which the goto target
is not visible.


\begin{minted}{felix}
proc doit (err: 1 -> 0) { e; }

proc outer () {
  proc handler () { goto error; }
  doit (handler);
  return;

  error:> println$ error;
}
\end{minted}

This is a valid way to handle errors.
the code is correct because \verb%outer% is active
at the time that \verb%handler% performs the
control transfer.
\subsection{halt}
Stops the program with a diagnostic.

\begin{minted}{felix}
halt "Program complete";
\end{minted}


\subsection{try/catch/entry}
The try/catch construction may only be user to wrap
calls to C++ primitives, so as to catch exceptions.

\begin{minted}{felix}
proc mythrow 1 = "throw 0;";
try
   mythrow;
catch (x:int) =>
   println$ "Caughht integer " + x.str;
endtry
\end{minted}


\subsection{goto-indirect/label\_address}
The \verb%label-address% operator captures the address
of code at a nominated label. 

The address has type \verb%LABEL% and can be stored in a variable.

Provided the activation record of the procedure containing
the label remains live, a subsequent @{goto-indirect) can
be used to jump to that location.


\begin{minted}{felix}
proc demo (selector:int) {
  var pos : LABEL = 
    if selector == 1 
    then label_address lab1
    else label_address lab2
    endif
  ;
  goto-indirect selector;
lab1:>
  println$ "Lab1"; return;
lab2:>
  println$ "Lab2"; return;
}
\end{minted}


\subsection{Exchange of control}
Built on top of label adressing and indirect gotos,
the \verb%branch-and-link% instruction is conceptually
the most fundamental control instruction. The library
implementation is in 

\begin{minted}{felix}
inline proc branch-and-link (target:&LABEL, save:&LABEL)
{
  save <- label_address next;
  goto-indirect *target;
  next:>
}
\end{minted}

A good example is \href{http://felix-lang.org/share/src/test/regress/rt/coroutines-01.fdoc}{here},
which shows an example of coroutines.

\section{match/endmatch}
The form:

\begin{minted}{felix}
match expr with
| pattern1 => stmts1
| pattern2 => stmts2
...
endmatch
\end{minted}

is an extension of the C switch statement. The patterns
are composed of these forms:

\begin{minted}{felix}
(v1, v2, ... )          // tuple match
h!t                     // list match
h,,t                    // tuple cons
Ctor                      // const union or variant match
Ctor v                   // nonconst union or variant match
(fld1=f1, fld2=f2, ...)  // record match
pat as v                 // assign variable to matched subexpression
pat when expr             // guarded match
pat1 | pat2               // match either pattern
999                       // integer match
"str"                     // string match 
lit1 .. lit2              // range match
_                         // wildcard match
\end{minted}


The guarded match only matches the pattern if the guard expression is true.

\begin{minted}{felix}
match x with
| (x,y) when y != 0 => ...
endmatch
\end{minted}


The tuple as list cons match is a form of row polymorphism
where the first element of a tuple and the remaining elements
considered as a tuple are matched.

A good example of this is found in the library \href{http://felix-lang.org/share/lib/std/datatype/tuple.flx}{here}
which allows printing a tuple of arbitrary number of components, indeed,
this facility was implemented precisely to allow this definition in the library.

Record matches succeed with any record containing a superset
of the specified fields.

As well as integer and string matches, a literal of any type with an
equality and inequality operator can be matched. In addition,
if there is a less than or equal operator \verb%<=% an inclusive
range match can be specified.

\section{if/goto}
The conditional goto is an abbreviation for 
the more verbose conditional:

\begin{minted}{felix}
if c goto lab; // equivalent to
if c do goto lab; done
\end{minted}


\subsection{if/return}
The conditional return is an abbreviation for
the more verbose conditional:

\begin{minted}{felix}
if c return; // equivalent to
if c do return; done
\end{minted}


\subsection{if/call}
The conditional call is an abbreviation for
the more verbose conditional:

\begin{minted}{felix}
if c call f x; // equivalent to
if c do call f x; done
\end{minted}



\section{if/do/elif/else/done}
The procedural conditional branch is used to select
a control path based on a boolean expression.

The \verb%else} and @{elif% clauses are optional.

\begin{minted}{felix}
if c1 do 
  stmt1;
  stmt2;
elif c2 do
  stmt3;
  stmt4;
else
  stmt5;
  stmt6;
done
\end{minted}


The \verb%elif% clause saves writing a nested conditional.
The above is equivalent to:

\begin{minted}{felix}
if c1 do 
  stmt1;
  stmt2;
else 
  if c2 do
    stmt3;
    stmt4;
  else
    stmt5;
    stmt6;
  done
done
\end{minted}

One or more statements may be givn in the selected control path.

A simple conditional is an abbreviation for a statement match:

\begin{minted}{felix}
if c do stmt1; stmt2; else stmt3; stmt4; done
// is equivalent to
match c with
| true => stmt1; stmt2; 
| false => stmt3; stmt4;
endmatch;
\end{minted}


\section{call}
The \verb%call% statement is used to invoke a procedure.

\begin{minted}{felix}
proc p(x:int) { println$ x; }
call p 1;
\end{minted}

The word \verb%call% may be elided in a simple call:

\begin{minted}{felix}
p 1;
\end{minted}

If the argument is of unit type; that is, it is the
empty tuple, then the tuple may also be elided in
a simple call:

\begin{minted}{felix}
proc f() { println$ "Hi"; }
call f (); // is equivalent to
f(); // is equivalent to
f;
\end{minted}


\section{procedure return}
The procedural return is used to return control
from a procedure to its caller.

A return is not required at the end of a procedure
where control would otherwise appear to drop through,
a return is assumed:

\begin{minted}{felix}
proc f() { println$ 1; }
// equivalent to
proc f() { println$ 1; return; }
\end{minted}


\subsection{return from}
The return from statement allows control to be
returned from an enclosing procedure, provided that
procedure is active.

\begin{minted}{felix}
proc outer () {
  proc inner () {
     println$ "Inner";
     return from outer;
  }
  inner;
  println$ "Never executed";
}
\end{minted}


\subsection{jump }
The procedural jump is an abbreviation for 
the more verbose sequence:

\begin{minted}{felix}
jump procedure arg; // is equivalent to
call procedure arg;
return;
\end{minted}


\section{function return}
The functional return statement returns a value from
a function.

\begin{minted}{felix}
fun f () : int = {
  return 1;
}
\end{minted}

Control may not fall through the end of a function.

\subsection{yield}
The yield statement returns a value from a generator
whilst retaining the current location so that execution
may be resumed at the point after the yield.

For this to work a closure of the generator must be stored
in a variable which is subsequently applied.

\begin{minted}{felix}
gen counter () = { 
  var x = 0;
next_integer:>
  yield x;
  ++x;
  goto next_integer;
}

var counter1 = counter;
var zero = counter1 ();
var one = counter1 ();
println$ zero, one;
\end{minted}



\section{{\tt spawn\_fthread}}
\href{http://felix-lang.org/share/lib/std/control/fibres.flx}{Reference}

The \verb%spawn_fthread% library function invokes the corresponding
service call to schedule the initial continuation of a procedure 
taking a unit argument as an fthread (fibre). 

The spawned fthread begins executing immediately.
If coutrol returns before yielding by a synchronous
channel operation, the action is equivalent to calling
the procedure.

Otherwise the spawned fthread is suspended when the first
write, or the first unmatched read operation occurs.


\subsection{read/write/broadcast schannel}
\href{http://felix-lang.org/share/lib/std/control/schannels.flx}{Reference}

\section{{\tt spawn\_pthread}}
\href{http://felix-lang.org/share/lib/std/control/pthread.flx}{Reference}

\subsection{read/write pchannel}
\href{http://felix-lang.org/share/lib/std/control/pchannels.flx}{Reference}

\subsection{exchange}

\section{loops}
\href{http://felix-lang.org/share/lib/grammar/loops.fsyn}{Reference}

Felix has some low level and high level loop constructions.

The low level for, while, and repeat loops are equivalent
to loops implemented with gotos.

The bodies of do loops do not constitute a scope,
therefore any symbol defined in such a body is also visible
in the surrounding code.

Low level loops may be labelled with a loop label
which is used to allow break, continue, and redo
statements to exit from any containing loop.


\begin{minted}{felix}
outer:for var i in 0 upto 9 do
   inner: for var j in 0 upto 9 do
     println$ i,j;
     if i == j do break inner; done
     if i * j > 60 do break outer; done
   done
done
\end{minted}


\subsection{redo}
The redo statement causes control to jump to the start
of the specified loop without incrementing the control variable.

\subsection{break}
The break statement causes control to jump past the end of
the specified loop, terminating iteration.

\subsection{continue}
The continue statement causes the control variable to
be incremented and tests and the next iteration commenced
or the loop terminated.

\subsection{for/in/upto/downto/do/done}
A basic loop with an inclusive range.

\begin{minted}{felix}
// up
for var ti:int in 0 upto 9 do println$ ti; done
for var i in 0 upto 9 do println$ i; done
for i in  0 upto 9 do println$ i; done

// down
for var tj:int in 9 downto 0 do println$ j; done
for var j in 9 downto 0 do println$ j; done
for j in  0 upto 9 do println$ j; done
\end{minted}

The start and end expressions must be of the same type.

If the control variable is defined in the loop with a type
annotation, that type must agree with the control variable.

The type must support comparison with the equality operator \verb%==%
the less than or equals operator \verb%<=% and increment with 
the pre increment procedure \verb%++%.

For loops over unsigned types cannot handle the empty case.
For loops over signed types cannot span the whole range of the type.

The loop logic takes care to ensure the control variable is not
incremented (resp. decremented) past the end (resp.start) value.

\subsection{while/do/done}
The while loop executes the body repeatedly whilst the control
condition is true at the start of the loop body.

\begin{minted}{felix}
var i = 0;
while i < 10 do println$ i; ++i; done
\end{minted}


\subsection{until loop}
The until loop executes the loop body repeatedly
until the control condition is false at the start of the loop,
it is equivalent o a while loop with a negated condition.

\begin{minted}{felix}
var i = 0;
until i == 9 do println$ i; ++i; done
\end{minted}


\subsection{for/match/done}
TBD
\subsection{loop}
TBD
\section{Assertions}
\href{http://felix-lang.org/share/lib/grammar/assertions.fsyn}{Reference}
\section{assert}
Ad hoc assertion throws an assertion exception if its argument
is false. 

\begin{minted}{felix}
assert x > 0;
\end{minted}


\subsection{axiom}
An axiom is a relationship between functions, typically
polymorphic, which is required to hold.

\begin{minted}{felix}
axiom squares (x:double) => x * x >= 0;
class addition[T]
{
  virtual add : T * T -> T;
  virtual == : T * T -> bool;

  axiom assoc (x:T, y:T, z:T) : 
    add (add (x,y),z) == add (x, add (y,z))
  ;
}
\end{minted}

In a class, an axiom is a specification constraining
implementations of virtual function in instances.

Axioms are restricted to first order logic, that is, they
may be polymorphic, but the universal quantification implied
is always at the head.

Existential quantification can be provided in a constructive
logic by actually constructing the requisite variable.

Second order logic, with quantifiers internal to the 
logic term, are not supported.

\subsection{lemma}
A lemma is similar to an axiom, except that is it
easily derivable from axioms; in particular,
a reasonable automatic theorem prover should
be able to derived it.

\subsection{theorem}
A theorem is similar to a lemma, except that it is 
too hard to expect an automatic theorem prover
to be able to derive it without hints or assistance.

There is currently no standard way to prove such hints.

\subsection{reduce}
A reduce statement specifies a term reduction and is logically
equivalent to an axiom, lemma, or theorem, however it acts
as an instruction to the compiler to attempt to actually 
apply the axiom.

The compiler may apply the axiom, but it may miss opportunities
for application.

The set of reductions must be coherent and terminal, 
that is, after a finite number of reductions the final
term must be unique and irreducible. 

Application of reduction is extremely expensive and they
should be used lightly.

\begin{minted}{felix}
reduce revrev[T] (x: list[T]) : rev (rev x) => x;
\end{minted}



\subsection{invariant}
An invariant is an assertion which must hold on the state variables
of an object, at the point after construction of the state
is completed by the constructor function and just before the
record of method closures is returned, and, at the start and
end of every method invocation.

The invariant need not hold during execution of a method.

Felix inserts the a check on the invariant into the constructor function
and into the post conditions of every procedure or generator
method.


\begin{minted}{felix}
object f(var x:int, var y:int) =
{
   invariant y >= 0;
   method proc set_y (newy: int) => y = newy;
}
\end{minted}


\section{code}
The code statement inserts C++ code literally into the current
Felix code.

The code must be one or more C++ statements.


\begin{minted}{felix}
code 'cout << "hello";';
\end{minted}


\subsection{noreturn code}
Similar to code, however noreturn code never returns.

\begin{minted}{felix}
noreturn code "throw 1;";
\end{minted}


\section{Service call}
The service call statement calls the Felix system kernel
to perform a specified operation.

It is equivalent to an OS kernel call.

The available operations include:

\begin{minted}{felix}
  union svc_req_t =
  /*0*/ | svc_yield
  /*1*/ | svc_get_fthread         of &fthread    // CHANGED LAYOUT
  /*2*/ | svc_read                of address
  /*3*/ | svc_general             of &address    // CHANGED LAYOUT
  /*4*/ | svc_reserved1
  /*5*/ | svc_spawn_pthread       of fthread
  /*6*/ | svc_spawn_detached      of fthread
  /*7*/ | svc_sread               of _schannel * &gcaddress
  /*8*/ | svc_swrite              of _schannel * &gcaddress
  /*9*/ | svc_kill                of fthread
  /*10*/ | svc_reserved2
  /*11*/ | svc_multi_swrite       of _schannel * &gcaddress 
  /*12*/ | svc_schedule_detached  of fthread
  ;
\end{minted}


These operations are typically related to coroutine or thread scheduling.
However \verb%svc_general% is an unspecified operation, which is typically
used to invoke the asynchronous I/O subsystem.

Service calls can only be issued from flat code, that is,
from procedures, since they call the system by returning
control, the system must reside exactly one return address
up the machine stack at the point a service call is executed.

\section{with/do/done}
The with/do/done statement is use to define temporary variables
which are accessible only in the do/done body of the statement.

It is the statement equivalent of the let expression.

\begin{minted}{felix}
var x = 1;
with var x = 2; do println$ x; done
assert x == 1;
\end{minted}


\section{do/done}
The do/done statement has no semantics and merely acts as a
way to make a sequence of statements appear as a single
statement to the parser.

Jumps into do/done groups are therefore allowed, and
any labels defined in a do/done group are visible in
the enclosing context.

Any variables, functions, or other symbols defined in a do/done
group are visible in the enclosing context.

\begin{minted}{felix}
do something; done
\end{minted}


\section{begin/end}
The begin/end statement creates an anonymous procedure
and then calls it. It therefore appears as a single statement
to the parser, but it simulates a block as would be used in C.
It is exactly equivalent to a brace enclosed procedure called
by a terminating semi-colon.

\begin{minted}{felix}
begin
  var x = 1;
end
// equivalent to
{
  var x = 1;
};
\end{minted}



\part{C bindings}
Felix is specifically designed to provide almost seamless integration
with C and C++.

In particular, Felix and C++ can share types and functions,
typically without executable glue.

However Felix has a stronger and stricter type system than C++
and a much better syntax, so binding specifications which lift
C++ entities into Felix typically require some static glue.

\section{Type bindings}
In general, Felix requires all primitive types to be first class,
that is, they must be default initialisable, copy constructible,
assignable, and destructible. Assignment to a default initialised
variable must have the same semantics as copy construction.

It is recommended C++ objects provide move constructors as
Felix generated code uses pass by value extensively.

The Felix type system does not support C++ references in general,
you should use pointers instead. 

However, there is a special lvalue annotation for C++ functions
returning lvalues that allows them to appear on the LHS of
an assignment. Only primitives can be marked lvalue.

The Felix type system does not support either const or volatile.
This has no impact when passing arguments to C++ functions.
However it may be necessary to cast a pointer returned from
a primitive function in order for the generated code to type check.



\section{Expression bindings}
TBD
\section{Function bindings}
TBD
\section{Floating insertions}
TBD
\section{Package requirements}
TBD

\part{Domain Specific Sublanguages}
\section{Regexps}
\href{http://felix-lang.org/share/lib/grammar/regexps.fsyn}{Syntax}

\href{http://felix-lang.org/share/lib/std/strings/regdef.flx}{Combinators}

\href{http://felix-lang.org/share/lib/std/strings/re2.flx}{Google Re2 Binding}

\section{Pipelines}
\subsection{Synchronouse pipelines}
\href{http://felix-lang.org/share/lib/std/control/spipe.flx}{Library}
\subsection{Asynchronouse pipelines}
\href{http://felix-lang.org/share/lib/std/control/ppipe.flx}{Library}

\subsection{Json}
TBD
\subsection{Sqlite3}
TBD




\appendix
\backmatter
\end{document}
