\documentclass[oneside]{book}
\usepackage{color}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}
\title{The FARM\\ Felix Annotated Reference Manual}
\author{John Skaller}
\begin{document}
\maketitle
\tableofcontents
\chapter{Introduction}
This reference is a guide to the Felix programming language.
It is not the usual reference because Felix differs from
other systems in that most of the grammar is part of the library,
in user space. In principle then, separating the library from the 
core language is impossible: if anything the core language is
defined by the compiler intermediate abstract machine, details
of little interest to most programmers.

Furthermore even that characterisation is weak, because considerable
functionality is actually embodied in the run time library. For example
the compiler knows what a service request is, but it has no idea
what an fthread is. It knows what a generator is, and it knows which
generators perform yields, but it has no idea what an iterator is,
despite the fact these are effectively a core language feature.

Therefore, our presentation cannot be complete, it cannot be precise,
and it cannot replace actually reading the library code. Felix is a highly
mutable language, major new features can often be introduced without
touching the compiler.

For example a complete set of primitive types with their base
operations cannot be presented, because, with a couple of exceptions
there aren't any such type. Instead, most primitive types are introduced
without knowledge of the compiler, by creating bindings to C++ in 
library code; these bindings defined the type name and some operations
on the types in terms of C++.

% =====================================

\part{Gross Structure}

\chapter{Program structure}
A Felix program consists of a nominated root parse unit and
the transitive closure of units with respect to inclusion.

The behaviour of this system consists of the action of the
initialisation code in each unit, performed in sequence
within a given unit, with the order of action between
units unspecified.

\section{Parse Unit}
A parse unit is a file augmented by prefixing specified import
files to the front. These consist of a suite of grammar files
defining the syntax and other files defining macros.

By convention syntax files have the extension \verb%.fsyn%,
and other import files have the extension \verb%.flxh%.

With this augmentation all parse units in a program
are independently parsed to produce an list of statements
represented as abstract syntax, denoted an AST (even
though it is a list of trees, not a single tree).

\section{AST}
The program consists of the concatenation of the ASTs
of each parse unit, resulting in a single AST, which
is then translated to a C++ translation unit by the
compiler.

The ASTs to be concatenated are those parsed from
the parse units specified by the transitive closure
of include directives.

The order of concatenation is unspecified.
Note that include directives do {\em not} cause
an AST to be inserted at the point where the
directive is written.

Parse units can be and are parsed independently.
The contents of a parse unit cannot influence the
parsing of another.

\section{Include Directive}
\subsection{Syntax}
An include directive has the syntax:

\begin{minted}{felix}
include "filename";
include "dirname/filename";
include "./filename";
\end{minted}

where the filename is a Unix relative filename,
may not have an extension, and may not begin with or 
contain \verb%..% (two dots).

If the filename begins with \verb%./% then the balance of the name
is relative, a sibling of the including file, otherwise the name
is searched for on an include path. 

In either case, a search succeeds when it finds a file with
the appropriate base path in the search directory with
extension \verb%.flx% or \verb%.fdoc%. If both files exist the
most recently changed one is used. If the time stamps are
the same the choice is unspecified.

\subsection{Effect}
An include directive is included in the AST generated
by the parser. 

An extraction process extracts the set of directives
and locates the files specified and adds them to a set
of files which must be parsed.

Unparsed files are upgraded to parse units and parsed,
and then the extraction process again applied. 

When all the files have been processed the resulting
ASTs are concatenated.

Felix uses a caching scheme to avoid parsing all the
files every time.

\section{Grammar}
The Felix grammar is part of the library.
It is notionally prefixed to each file to be processed
prior to any import files to specify the syntax
with which the file is to be parsed and translated to
an AST.

The grammar uses an augmented BNF like syntax
with parse actions specified in R5RS Scheme.

The resulting S-expressions are translated to
an intermediate form and then into an internal
AST structure.

The parser is a scannerless GLR parser with significant
extensions.

\chapter{Parsing}
Felix has the most advanced parser of any production
programming language. The parser is extensible, and Felix
makes good use of this. The core, hardcoded grammar, called
the {\em bootstrap grammar} does not provide the syntax for
the Felix programming language the average production programmer
is interested in.

Therefore, we recommended this chapter be lightly scanned
or even skipped, until such time as a deeper understanding
is required. Nevertheless we feel obligated to present
some details now, since the ability to define Domain Specific
Sub-Languages is one of the key advantages of the Felix system.

In Felix, the usual programming language is defined by a grammar
in the library in user space. The compiler interprets the 
grammar to produce a parser
for the scope in which the grammar is active. Grammar extension
activations are properly scoped.

As with any modern programming language it is sometimes difficult
to distinguish features present in the core language and those
defined in the standard library. In particular the semantics of some 
features in the library could not be defined in the core language, 
but their syntactic representation can be. This is most evident
in the C programming language where, for example, Posix defines
semantics for multi-threading which are represented by library
functions which could not possibly be defined in C.

However in Felix the situation is even more extreme, since the very
language itself is defined in the library. What is more, most
of the definitions are real Felix code: we are not just
leveraging the library for syntactic modelling of semantics
we could not otherwise define, but are actually presenting
the definitions.

Naturally this is not possible without a core built-in parsing
system and semantics, this called the bootstrap parser
and the first stage abstract machine.

It reads the library syntax specifications to extend itself
to the full blown Felix language described in this document
and maps the input syntax onto terms of the abstract machine.


\section{Bootstrap Parser Grammar}
\href{http://felix-lang.org/share/src/compiler/flx_parse/flx_parse.dyp}{Compiler Reference}

The bootstrap parser is a hard coded parser which translates
Felix EBNF like syntax specification into a parser automaton,
which in turn translates Felix programs.

\subsection{Parser Processing}
Felix use the Dypgen parsing system, which is a run time
extensible GLR parsing engine with extensions. 

When the parsing of the production of a non-terminal is 
complete, the associated action code is executed.

The action code is a string containing a procedure
written in R5RS Scheme. The OCS Scheme language processor
is used for the processing.

Using predefined variables representing the s-expressions
associated with the evaluation of the actions associated
with the symbols of the production, the client action
code constructs a new s-expression representing the
intended AST for parsing that production.

Provided the returned AST is acceptable to subsequent
processing steps, this mechanism is safe provided the
executed Scheme code is purely functional.

If the Scheme actions have side effects, care must be taken.
Dypgen parsers may parse the same text more than once.
At any point in the parsing process the next symbol
is used to determine a possible set of parses, and all
these parses are then explored simultaneously.

Most of these parses will fail at some point in the
future, and the AST constructed at that point is discarded.
Except in special circumstances, if more than one parse
succeeds, the Felix translator will fail with a parsing
ambiguity.

The point, however, is that side effects from exploratory
parses cannot be discarded, nor can the order in which
the parses is performed be predicted. Although the parses
are, in principle, simultaneous, Dypgen actually processes
a single token for each parse in sequence, suspending the
parsing of one thread until all parses have processed
the token, then resuming with the next token, having
discarded failed parses, but also possibly spawning a new
set of parses. In other words, the parsing is performed
using coroutines which ensure that the input is only
consumed in a linear fashion without any backtracking.

If side effects are necessary, then they should usually
be idempotent. For example setting a variable to a fixed
value is an idempotent operation. Incrementing a variable is not.

There is, however, a special exception to this rule.
Top level statements are guaranteed to be parsed exactly once.
Although the start symbol is defined recursively, the recursion
is optimised to a plain loop. This is not necessarily the 
case for nested statements!

\subsection{Spawning Choices}
When presented with a non-terminal to parse, a GLR parser
notionally processes all alternatives simultaneously.
Many of these branches will fail, indeed, if the parse
is to be ambiguous all but one should eventually fail.
This method could be called purely speculative parsing.

However, Dypgen does not actually try all the alternatives.
Some alternatives must start with a particular token
or one of a set of tokens. Instead of starting the parse
and failing after examining the next token, Dypgen
uses an LALR1 predictive parser to narrow down the
set of alternatives. The LALR1 automaton is a finite
state machine which given the next token supplies
a set of possible parse which might continue.
Although LALR1 is not accurate, it is conservative,
and only rejects alternatives that could not possibly
work.

\subsection{No keywords}
In most language, there is a severe lack of usable symbols.
To compensate for this, certain identifiers called keywords
are specified as symbols instead. The tokeniser checks if an
identifier is a keyword and returns a suitable token if it is,
otherwise it returns an identifier.

Unfortunately, because keywords encroach on user space,
many languages such as C++ try to minimise the set used,
and in the case of a language extension, introducing a new
keyword may break existing code. So there is tendancy to
reuse the keyword in a different context, leading to
the nightmare that is evident in C++.

Felix also has keywords, but they are not global.
The Felix parser is scannerless which means it does not
require a separate tokeniser. Instead tokenisation
is local to each parser state, and in particular
the identifiers used as keywords are only recognised
in this state. Felix also provides a consistent way
to unkeyword with a special form of literal to force
the parser to recognise an identifier instead of a keyword.

\begin{minted}{felix}
// var = 1; 
   // Syntax error, variable init expected

var var = 1; 
  // OK, declares identifier "var" as a variable

n"var" = 1; 
  // allows assigning to identifier named "var".
\end{minted}

\subsection{Predefined Variables}
When scheme code is executed certain global variables are
automatically predefined. 

\begin{itemize}
\item The variable \verb%_sr% is set to contain the current
location in the source file. It consists of a scheme list
of the current original source filename as a string, then the 
starting line, starting column, ending line, and ending column
of the text being parsed by the current production.

\item The variables \verb%_1%, \verb%_2% etc refer to the 
scheme s-expressions associated with the parse of the n'th
symbol in a production.
\end{itemize}

Together these variables allow the scheme action code
of a production to construct an scheme s-expression representing
the AST desired for parsing the associated production.

\subsection{{\tt SCHEME} statement}
The keyword \verb%SCHEME% followed by a string literal and semi-colon
causes the embedded R5RS scheme interpreter to execute the text
of the string literal as scheme code during parsing.

It is primarily intended to introduce global procedure definitions
as helper functions to be used in the parser action codes.

However it may contain arbitrary Scheme code, including,
for example diagnostic output, an interpreter, or anything
else. The return value of the execution is discarded.

\begin{minted}{felix}
SCHEME """
  (display "Hello parsing world\n")
""";
\end{minted}

The \verb%SCHEME% statement may be used anywhere a statement is allowed,
it results in a empty statement in the AST. At the top level, the
side-effects will only be seen once. However if nested in a grouping
statement, multiple explorations of the possible parses of that
statement may occur, leading to multiple observations of the side-effects.

\subsection{{\tt STMT} statement}
The keyword \verb%STMT% followed by a string literal and semi-colon
causes the embedded R5RS scheme interpreter to execute the text
of the string literal as scheme code during parsing.

The result of the execution is returned and appended to the current
list of statements being parsed.

It is primarily intended to provide an mechanism whereby
arbitary Felix statements can be generated under program control,
in other words it is a very sophisticated and properly structured
macro processor. The client must have intimated knowledge of the
which s-expressions are accepted by the subsequent compiler
processing phases and what their semantics are.

Care must be taken if the result of the execution is not
invariant. For example if the time, a file from the file system,
or other such variable entity is used in the computation,
the Felix dependency checking system will not recognise
the external dependencies and the cached version of the current
file's parse may be used.

\begin{minted}{felix}
for i in 0..10 do
  println "Stopping now";
  STMT '`(ast_halt ,_sr "STOPPED")';
done
\end{minted}

\subsection{{\tt syntax} statement}
The \verb%syntax% statement consists of the word \verb%syntax%
followed by an identifier and a list of syntax definition statements
enclosed in curly braces \verb"{" and \verb"}". The entity
defined is called a {\em Domain Specific Sub-Language} or just
{\em dssl}.

The given definitions are recorded as a set under the given
name but are not activated. For example here is the
DSSL for the Felix macros:

\begin{minted}{felix}
syntax macros {
  requires expressions, statements, list;
  
  stmt := "macro" "val" snames "=" sexpr ";" =>#
    "`(ast_macro_val ,_sr ,_3 ,_5)";

  stmt := "forall" sname "in" sexpr "do" stmt* "done" =>#
    "`(ast_macro_forall ,_sr (,_2) ,_4 ,_6)"
  ;
}
\end{minted}

\subsection{{\tt requires} statement}
Within a dssl definition, the requires statement
consists of the word \verb%requires% followed by a comma
separated list of identifiers, and terminated by a semi-colon.

The names in the list identify other dssls on which this
dssl depends, so that subsequently activating the dssl
will also cause the dependent dssls, recursively, to be
activated.

\subsection{Priority statement}
The \verb%priority% statement introduces a set of priority
names which can be used for indexed non-terminals,
and specifies a total ordering between them,
sometimes called a precedence. Here are the priorities
used for non-terminal \verb%x% representing expressions
in the Felix grammar, lower priority means weaker binding:

\begin{minted}{felix}
  priority 
    let_pri < 
    slambda_pri <
    spipe_apply_pri <
    sdollar_apply_pri < 
    stuple_cons_pri <
    stuple_pri <
    simplies_condition_pri <
    sor_condition_pri <
    sand_condition_pri <
    snot_condition_pri <
    stex_implies_condition_pri <
    stex_or_condition_pri <
    stex_and_condition_pri <
    stex_not_condition_pri <
    scomparison_pri <
    sas_expr_pri <
    ssetunion_pri <
    ssetintersection_pri <
    sarrow_pri <
    scase_literal_pri <
    sbor_pri <
    sbxor_pri <
    sband_pri <
    sshift_pri <
    ssum_pri <
    ssubtraction_pri <
    sproduct_pri <
    s_term_pri <
    sprefixed_pri <
    spower_pri <
    ssuperscript_pri <
    srefr_pri <
    sapplication_pri <
    scoercion_pri <
    sfactor_pri <
    srcompose_pri <
    sthename_pri <
    satomic_pri
  ;
\end{minted}


\subsection{Non-terminal definition}
A nonterminal definition, in its most basic
form, consists of the non-terminal name,
followed by \verb":=" followed by a list of alternatives
separated by a \verb"|" followed by a semi-colon \verb";".

An alternative is a sequence of grammar symbols 
followed by \verb"=>#" followed by a string.
The sequence of symbols is called the rhs (right hand side)
of the production, and the string is called the action.
The string must encode an R5RS Scheme procedure which returns
an s-expression representing the AST subtree desired to be inserted
in the syntax tree.

The non-terminal name on the left is either an identifier,
or, an identifier followed by \verb"[", an priority identifier,
followed by \verb"]". A priority identifier is an identifier
appearing in a priority specification.

An grammar symbol is either a predefined atom, a string
which is required to match the input stream, a non-terminal
expression, or a grammar expression enclosed in 
parentheses \verb"(" and \verb")", a macro invocation 
or a grammar symbol followed by one of \verb"*" representing 0 or more occurences,
\verb"+" representing one or more occurences, or
\verb"?" representing 0 or 1 occurence.

A non-terminal expression is either a name, or a name followed
by a priority indicator, or a macro invocation. A priority indicator is a priority
name enclosed in either \verb"[" and \verb"]" which indicates
a fixed non terminal, or \verb%[>% and \verb"]" which
indicates all the non-terminals with a greater priority
than the specified one.

A macro invocation is a name optionally followed by \verb"::" and another name,
followed by a sequence of macro arguments. 
A macro argument is a symbol enclosed in \verb"<" and \verb">".

\subsection{Preprocessing productions}
Felix pre-proceses productions to reduce them to
a sequence of basic symbols: either a terminal
or non-terminal symbol. 

\begin{itemize}
\item Expressions contained
in parentheses are replaced by a generated non-terminal
name and the non-terminal is defined by the enclosed
sequence, its action is to return a list of the ASTs
of each symbol.

\item A non-terminal postfixed by \verb%*% or \verb%+% is replaced
by a generated non-terminal defined to recursively generate
a list of the non-terminal, with either 0 or more or 1 or
more entries in the list, respectively.

\item A non-terminal postfixed by \verb%?% returns the a list
containing just the s-expression
returned by the non-terminal if it is matched, otherwise an
empty list.
 
\item Macro calls are expanded. This done by replacing each
occurence of a macro parameter with the correponding argument
of the call.
\end{itemize}

\subsection{Grammar Macros}
A grammar macro is defined by the same syntax as a non-terminal,
except that a sequence of parameter names is added on the lhs after
the first name. The first name may not be indexed.

On expansion due to an invocation of a macro, each parameter
name in the production is replaced by the non-terminal argument.

As an example, suppose we wish to define a comma separated list
of strings, a comma separated list of integers, and a comma 
separated list of names. By using a macro, the common structure
of the productions can be captured: a macro is basically 
a grammar function. The following is actually found in the
Felix library: 

\begin{minted}{felix}
syntax list 
{
  seplist1 sep a := a (sep a)* =># '(cons _1 (map second _2))'; 
  seplist0 sep a = seplist1<sep><a>;
  seplist0 sep a := sepsilon =># '()';
  commalist1 a = seplist1<","><a>;
  commalist0 a = seplist0<","><a>;

  snames = commalist1<sname>;
  sdeclnames = commalist1<sdeclname>;
}
\end{minted}

Although grammar macros were primarily intended as basic boilerplate
templates, macros can also be passed as arguments to another macro,
thereby allowing higher order macros. Furthermore, since arguments
are presented in a curried for, closures can also be created,
that is, macros with some but not all parameters fixed.

In particular, a macro can actually be passed to itself!
Although this seems weird it is in fact a very high power
technique used in functional programming and type systems,
known as {\em open recursion}.

Open recursion allows a recursive structure to be extended
so that the extensions {\em backport} to the core, in other
words, the extensions are covariant. This solves a significant
problem in grammar extension. Normally in a grammar extension
is easily done by simply adding extra productions for a non-terminal.

The problem is that the nonterminal is then effectively a global 
variable and extensions from different sources can clash. However
the use of a global automatically assures we have covariant extensions,
since existing productions using the non-terminal will automatically
parse the extensions since they're now alternatives of the non-terminal.

The problem with clashing is only a symptom of the deeper problem:
the mechanism does not obey Meyer's Open/Closed principle.

Open recursion solves this problem. The recursions are replaced
by parameters, flattening the term structure and allowing
extenions in a tree like manner. The programmer then closes
the loop at any desired point with a new definition formed by
passing the flat term to itself. 

More generally, a term structure with more details such
as a language with statements, value expressions, type expressions,
and patterns, allows any combination of the extensions to be
used with nested (recursive) structures equal to the top level
or constrained to some lower level as required.

This method obeys the Open/Closed principle because each closure
is specific and cannot be further extended, yet the open part of
the system remaims open for extension.
\subsection{{\tt regdef} statement}

\subsection{{\tt literal} statement}

\subsection{{\tt open syntax} statement}
The \verb%open syntax% statement consists of the words
\verb%open syntax% followed by a comma separated list of names.

It simultaneously activates the transitive closure
with respect to \verb%requires% statements,
of dssls previously recorded by \verb%syntax% statements
identified by the list of names.


\section{Felix Grammar syntax}
\href{http://felix-lang.org/share/lib/src/packages}{Library Package} 
\href{http://felix-lang.org/share/lib/grammar}{Grammar directory} 


% =====================================
\chapter{Modules}
Every Felix program is encapsulated in a module with
the name being a mangle of the basename of the root unit.
The mangling replaces characters in the filename with
other characters so that the module name is a valid
ISO C identifier.

\section{Special procedure {\tt flx\_main}}
A program module may contain at most one top level
procedure with no arguments, exported as \verb%flx_main%. 
After initialisation code suspends or terminates, this procedure is invoked
if it exists. It is the analogue of \verb%main% in C++
however it is rarely used: side-effects of the
root unit initialisation code are typically used instead.

A simple example:

\begin{minted}{felix}
println "Init";
var i,o = mk_ioschannel_pair[int]();
write (o,42);

export proc flx_main()
{
  println$ "main " + (read i).str;
  println$ "done ..";
}

println$ "Init done";
\end{minted}

produces output:

\begin{minted}{text}
Init
main 42
done ..
Init done
\end{minted}

Note that \verb%flx_main% must be exported to ensure that
an \verb%extern "C"% symbol is created by the linker.

\section{Libraries}
In Felix a library is a root unit together with its
transitive closure with respect to inclusion,
which does not contain a top level exported \verb%flx_main%.

A program unit can be augmented by a set of libraries
which are then considered as if included, but without
an include directive being present.


% =====================================
\chapter{Lexicology}
All Felix files are considered to be UTF-8 encoded Unicode.

Felix uses a scannerless parser, there are no keywords.

\section{Comments}
There are lexical commenting methods for \verb%*.flx% files.
Comments are treated as white space separators. For example

\begin{minted}{felix}
println$ f/**/x; // parsed as f x not fx
\end{minted}

The two forms of lexical comments are exclusive, once the
parser is scanning one kind of comment the other is not
recognised.

\subsection{C++ comments}
C++ style comments consist of \verb%//% followed by all the characters
up to and including the next newline charcter.

\subsection{Nested C comments}
C style comments consist of the lead in sequence
\verb%/*% followed by all the characters
up to and including the balancing exit sequence \verb%*/%. 
These comments can span
multiple lines and can be nested. When scanning comments
lead in and exit sequences are recognised as such even
in strings.

\section{Layout}
Felix treats code points 0 through 32 (space) as whitespace
which may be used freely between symbols. Whitespace is significant
in strings, however, and newline is a terminator for C++ style comments.

\section{File inclusion}
There is (deliberately) no support in the Felix language 
for lexical (physical)  file inclusion. Inclusions are processed at 
the AST level instead, allowing files to be parsed independently of other files. 
However command line switches can be used to prepend files or sets
of files to the command input file, in particular the grammar
and some standard macros are notionally inserted.

\section{fdoc files}
As well as \verb%*.flx% files, the Felix language processor
can directly process \verb%*.fdoc% files using a limited
subset of available \verb%fdoc% commands.

\verb%fdoc% files are processed slighly differently to \verb%*.flx% files.
The translator begins treating the file in comment mode, so all text
is ignored up to a Felix leadin code.

\subsection{Uncomments}
A felix uncomment switches to processing lines as Felix program code.
It consists of the line \verb%@felix%, and is terminated by any
line starting with \verb%@%. 

\begin{minted}{text}
@title This is an fdoc.
@h1 Fdocs are documents.
They can contain code:
@felix
var x = 1;
@
Which defines a variable and
@felix
println$ x;
@
which prints it.
\end{minted}

\subsection{{\tt \#line} directive}
Felix provides support for programs that generate Felix code
by allowing C style \verb%#line% directives. Such a directive
consists of the characters \verb%#line% at the start of a line,
followed by whitespace, a decimal number indicating the line
number in the original source, and optionally whitespace
followed by a filename in double quotes. 

If the filename is present the parser
original source filename is set to it. The line number sets
the line number, 1 origin, so that the next source line
will be taken to be obtained from the original source file
at that line number.

Felix provides two standard programs which make use of this
facility: \verb%flx_tangle% and \verb%flx_iscr% both of
which are literate programming tools which extract source
code from mixed code and comments.

In the event of a compilation error, Felix will specify that
the error occured at a location in the original source
file, as indicated by \verb%#line% directives. An example:

\begin{minted}{felix}
#line 42 "anerror.fdoc"
var x = error;
\end{minted}

If this program is processed by Felix the error on the second
line will be reported as an error on line 42 of the 
file \verb%anerror.fdoc%.

\section{\#! directive}
If the first line of an \verb%*.flx% file starts with \verb%#!% then
the line is ignored. This allows a file on a Unix system marked
executable to specify its natural translator so that the file
may be run directly as a program. On Linux you should use:

\begin{minted}{felix}
#!env /usr/local/lib/felix/felix-latest/host/bin/flx
\end{minted}

assuming you have a standard install and have linked
\verb%felix-latest% to a directory containing an installed
version of Felix such as 

\begin{verbatim}
%/usr/local/lib/felix/felix-2016.05.25%.
\end{verbatim}

This is the standard way to refer to the most recent version of Felix
installed on Unix systems. Note the path name to the translator
on Unix systems must be an absolute path for security reasons.

\section{Identifiers}

\href{http://felix-lang.org/share/lib/grammar/grammar_ident_lexer.fsyn}{Library Reference}

Felix has three kinds of basic identifiers, plain identfiers, which
are an enhanced variant of standard C identifiers, TeX identifiers,
which are encodings of mathematical symbols in the style of \TeX,
and some ascii-art character sequences normally use for punctuation
or operators which are also recognised as names.

\subsection{Plain Identifiers}
A plain identifier starts with a letter or underscore,
then consists of a sequence of letters, digits, dash (\verb%-%),
apostrophy (\verb%'%), has no more
than one apostrophy or dash in a row, except at the end no dash is
allowed, and any number of apostrophies.

\begin{minted}{felix}
Ab_cd1  a' b-x
\end{minted}

Identifies starting with underscore are reserved for the implementation.

A letter may be any Unicode character designated for use in an identifier
by the ISO C++ standard. In practice, all high bit set octets are allowed.
Identifiers are uniquely identified by their sequence of 
ISO-10646 (Unicode) code points, alternate encodings of the same 
glyph are distinct.

\subsection{TeX Identifiers}
A TeX identifier starts with a slosh and is followed by a sequence
of letters. 

Here is a partial table of 
\href{http://felix-lang.org/share/src/web/ref/texops.fdoc}{TeX Symbols} 
recognised by the grammar as identifiers with undefined semantics
but pre-assigned kind and precedence.

\section{Operator Identifiers}
Felix allows some operators to be used as an identifier.
For example you can write:

\begin{minted}{felix}
fun +: int * int -> int = "$1+$2";
\end{minted}

to define addition on int in C. Symbols recognised by the parser
such as \verb%+% are usually mapped to functions with the same
name as the operator.`

These operators are recognised as identifiers by the parser in
positions where an identifier is expected:

\begin{verbatim}
    +  -  *  /  %  ^  ~  
    \&  \  \^ 
    &=  =  +=  -=  *=  /=  %=  ^=  <<=  >>= 
    <  >  ==  !=  <=  >=  <<  >> 
\end{verbatim}

\subsection{Special identifiers}
The special string literal with a "n" or "N" prefix is a way to encode
an arbitrary sequence of characters as an identifer in a context
where the parser might interpret it otherwise.
It can be used, for example, to define special characters as functions.
For example:

\begin{minted}{felix}
typedef fun n"@" (T:TYPE) : TYPE => cptr[T];
\end{minted}

\section{Boolean Literals}
There are two literals of type \verb%bool%, namely \verb%true% and \verb%false%.

\section{Integer Literals}

\href{http://felix-lang.org/share/lib/grammar/grammar_int_lexer.fsyn}{Library Reference}

An plain integer literal consists of a sequence of digits,
optionally separated by underscores. Each separating
underscore must be between digits.

A prefixed integer literal is a plain integer literal
or a plain integer literal prefixed by a radix specifier.
The radix specifier is a zero followed by one of
the letters \verb%bB% for binary radix, \verb%oO% for octal
radix, optionally on may use \verb%dD% for decimal radix,
although this is the default, and \verb%xX% for hexadecimal radix.

An underscore is permitted after the prefix.

The radix is the one specified by the prefix or decimal
by default.

The digits of an integer consist of those permitted
by the radix: \verb%01% for binary, \verb%01234567%
for octal, \verb%0123456789% for decimal, \verb%0123456789abcdefABCDEF%
for hex.

Note there are no negative integer literals.

A type suffix may be added to the end of a prefixed
integer to designate a literal of a particular integer type,
it has the form of an upper or lower case letter or pair of
letters usually combined with a prefix or suffix \verb%u% or \verb%U%
to designate an unsigned variant of the type.  The allowed lower case
suffices are:

\begin{verbatim}
t  s  l  ll 
ut us u ul ull 
tu su   lu llu
i8 i16 i32 i64
u8 u16 u32 u64
   p  d  j 
zu pu du ju
uz up ud uj
\end{verbatim}

In addition, one or more letters may be upper case, except
that \verb%lL% and \verb%Ll% are not permitted.

There is a table of the types \fullref{Integer Types}.

Note the suffices do not entirely agree with C.

\section{Floating point literals}
\href{http://felix-lang.org/share/lib/grammar/grammar_float_lexer.fsyn}{Library Reference}

Floating point literals follow ISO C89, except that underscores
are allowed between digits, and a a digit is required both before
and after the decimal point if it is present.

The mantissa may be decimal, or hex, a hex mantissa uses a
leading 0x or 0X prefix optionally followed by an underscore.

The exponent may designate a power of 10 using E or e,
or a power of 2, using P or p.

A suffix may be F,f,D,d, L or l, designating floating type,
double precision floating type, or long double precision floating 
type.

\begin{minted}{felix}
123.4
123_456.78
12.6E-5L
0xAf.bE6f
12.7p35
\end{minted}

There is a table of the operators \fullref{Floating Operators}.

\section{String like literals}
\href{http://felix-lang.org/share/lib/grammar/grammar_string_lexer.fsyn}{Library Reference}

\subsection{Standard string literals}
Generaly we follow Python here.
Felix allows strings to be delimited by;
single quotes ',
double quotes ",
triped single quotes ''' or
tripled double quotes """.

The single quote forms must be on a single line.

The triple quoted forms may span lines, and include embedded newline
characters.

The complete list of special escapes is shown in table \fullref{String Escapes}.

\begin{table}
\caption{String Escapes\label{String Escapes}}
\centering
\begin{tabular}[c]{lll}
\multicolumn{3}{c}{Basic}\\
Escape&Name&Decimal Code\\
\hline
\verb%\a%&ASCII Bell& 7\\
\verb%\b%&ASCII Backspace&8\\
\verb%\t%&ASCII Tab&9\\
\verb%\n%&ASCII New Line&10\\
\verb%\r%&ASCII Vertical Tab&11\\
\verb%\f%&ASCII Form Feed&12\\
\verb%\r%&ASCII Carriage Return&13\\
\verb%\'%&ASCII Single Quote&39\\
\verb%\"%&ASCII Double Quote&34\\
\verb%\\%&ASCII Backslash&92\\
\multicolumn{3}{c}{Numeric}\\
\hline
\verb%\d%999&Decimal encoding&\\
\verb%\o%777&Octal encoding&\\
\verb%\x%FF&Hex encoding&\\
\verb%\u%FFFF&UTF-8 encoding&\\
\verb%\U%FFFFFFFF&UTF-8 encoding&\\
\end{tabular}
\end{table}

\subsection{Raw strings}
A prefix "r" or "R" on a double quoted string
or triple double quoted string suppresses escape processing,
This is called a raw string literal.

NOTE: single quoted string cannot be used, because this would
clash with the use of single quotes/apostrophies in identifiers.

\subsection{Null terminated strings}
A prefix of "c" or "C" specifies a C NTBS (Nul terminated
byte string) be generated instead of a C++ string.
Such a string has type +char rather than string.

\subsection{Perl interpolation strings}
A literal prefixed by "q" or "Q" is a Perl interpolation
string. Such strings are actually functions.
Each occurrence of \verb%$(varname)% in the string is replaced
at run time by the value "str varname". The type of the
variable must provide an overload of "str" which returns
a C++ string for this to work.

\begin{minted}{felix}
var x = 1;
var y = 3.2;
println$ q"x=$(x), y=$(y)";
\end{minted}

\subsection{C format strings}
A literal prefixed by a "f" or "F" is a C format string.

Such strings are actually functions.

The string contains code such as "%d" or other supported
C format specifiers. 

\begin{minted}{felix}
var x = 1;
var y = 3.2;
println$ f"x=%03d, y=%4.1f, s=%S" (x,y,"Hello");
\end{minted}

Variable field width specifiers "*" are not permitted. 

The additional format specification %S
is supported and requires a Felix string argument.

If \verb%vsnprintf% is available on the local platform it is used
to provide an implementation which cannot overrun.
If it is not, \verb%vsprintf% is used instead with a 1000 character
buffer.

The argument types and code types are fully checked for type safety.
There are some tables of accepted codes: 
\fullref{C format codes: integer},
\fullref{C format codes: integer special},
\fullref{C format codes: floating},
\fullref{C format codes: other}.

Please see a suitable reference to learn how to use C format codes.

\begin{table}
\caption{C format codes: integer\label{C format codes: integer}}
\centering
\begin{tabular}[c]{rll}
Code&Type&Radix\\
\hline
hhd&tiny&decimal\\
hhi&tiny&decimal\\
hho&utiny&octal\\
hhx&utiny&hex\\
hhX&utiny&HEX\\
\hline
hd&short&decimal\\
hi&short&decimal\\
hu&ushort&decimal\\
ho&ushort&octal\\
hx&ushort&hex\\
hX&ushort&HEX\\
\hline
d&int&decimal\\
i&int&decimal\\
u&uint&decimal\\
o&uint&octal\\
x&uint&hex\\
X&uint&HEX\\
\hline
ld&long&decimal\\
li&long&decimal\\
lu&ulong&decimal\\
lo&ulong&octal\\
lx&ulong&hex\\
lX&ulong&HEX\\
\hline
lld&vlong&decimal\\
lli&vlong&decimal\\
llu&uvlong&decimal\\
llo&uvlong&octal\\
llx&uvlong&hex\\
llX&uvlong&HEX\\
\end{tabular}
\end{table}


\begin{table}
\caption{C format codes: special integer\label{C format codes: special integer}}
\centering
\begin{tabular}[c]{rll}
Code&Type&Radix\\
\hline
zd&ssize&decimal\\
zi&ssize&decimal\\
zu&size&decimal\\
zo&size&octal\\
zx&size&hex\\
zX&size&HEX\\
\hline
jd&intmax&decimal\\
ji&intmax&decimal\\
ju&uintmax&decimal\\
jo&uintmax&octal\\
jx&uintmax&hex\\
jX&uintmax&HEX\\
\hline
td&ptrdiff&decimal\\
ti&ptrdiff&decimal\\
tu&uptrdiff&decimal\\
to&uptrdiff&octal\\
tx&uptrdiff&hex\\
tX&uptrdiff&HEX\\
\end{tabular}
\end{table}




\begin{table}
\caption{C format codes: floating\label{C format codes: floating}}
\centering
\begin{tabular}[c]{rll}
Code&Type&format\\
\hline
e&double&scientific\\
E&double&SCIENTIFIC\\
f&double&fixed\\
F&double&FIXED\\
g&double&general\\
G&double&GENERAL\\
a&double&hex\\
A&double&HEX\\
\hline
Le&ldouble&scientific\\
LE&ldouble&SCIENTIFIC\\
Lf&ldouble&fixed\\
LF&ldouble&FIXED\\
Lg&ldouble&general\\
LG&ldouble&GENERAL\\
La&ldouble&hex\\
LA&ldouble&HEX\\
\end{tabular}
\end{table}

\begin{table}
\caption{C format codes: other\label{C format codes: other}}
\centering
\begin{tabular}[c]{rll}
Code&Type\\
\hline

c&int (prints char)\\

S&string\\
s&\&char\\
p&address&hex\\
P&address&HEX\\
\end{tabular}
\end{table}


\chapter{Macro processing}
\href{http://felix-lang.org/share/lib/grammar/macros.fsyn}{Library Syntax Reference}

\href{http://felix-lang.org/share/src/compiler/flx_desugar/flx_macro.ml}{Compiler Semantics Reference}

\section{Macro val}
The macro val statement is used to specify an identifier should
be replaced by the defining expression wherever it occurs in an
expression, type expression, or pattern.

\begin{minted}{felix}
macro val WIN32 = true;
macro val hitchhiker;
macro val a,b,c = 1,2,3;
\end{minted}


\section{Macro for}
This statement allows a list of statements to be repeated
with a sequence of replacements.

\begin{minted}{felix}
forall name in 1,2,3 do
  println$ name;
done
\end{minted}


\section{Constant folding and conditional compilation}
\href{http://felix-lang.org/share/src/compiler/flx_desugar/flx_constfld.ml}{Compiler Semantics Reference}

Felix provides two core kinds of constant folding:
folding of arithmetic, boolean, and string values, and 
deletion of code, either statements or expressions,
which would become unreachable due to certain
value of conditionals.

Basic operations on integer literals, namely 
addition, subtraction, negation, multiplication,
division, and remainder are folded.

Strings are concatenated.

Boolean and, or, exclusive or, and negation,
are evaluated.

False branches of if/then/else/endif expression
and match expressions are eliminated.

False branches of if/do/elif/else/done 
are also eliminated.

By this mechanism of constant folding and
elimination, Felix provides conditional
compilation without the need for special
constructions.

\part{Lookup}

\chapter{Names}
\section{Kinds of Names}
Felix has several kinds of names which can find two kinds of entities.

\subsection{Simple Names}
A {\em simple name} is just an identifier.

\begin{minted}{felix}
  x
  joe
\end{minted}

\subsection{Simple Indexed Names}
An {\em simple indexed name} is an identifier followed by an
open square bracket \verb%[%, a possibly empty comma separated list of type
expressions, followed by a close square bracket \verb%]%. If the list
is empty, the name is equivalent to a simple name. 

\begin{minted}{felix}
  x[] // equivalent to just x
  joe[int]
  fred[int,string]
\end{minted}

\subsection{Unqualified Names}
An {\em unqualified name} is a simple name or simple
indexed name. Because indexed names with an empty index list
are equivalent to simple unindexed names, all unqualified names
are notionally simple indexed names.

\subsection{Qualified Names}
A {\em qualified name} is sequence of at least two unqualified names
separated by two colons \verb%::%.

\begin{minted}{felix}
  A::B::f
  A[int]::f[long]
  root::B
\end{minted}

\subsection{Special name {\tt root}}
The special name \verb%root% is an alias for the top level module
name and may be used to force qualified name lookup  starting with the top
level module.

\subsection{Unsuffixed Name}
An {\em unsuffixed name} is a qualified or unqualified name.

\subsection{Suffixed Name}
A {\em suffixed name} is an unsuffixed name followed by a suffix consisting
of the word \verb%of% followed either by a simple name, or a possibly empty
comma separated list of type expressions enclosed in parentheses \verb%(% and
\verb%)%.

\begin{minted}{felix}
fun f (x:int) => x;
fun f (x:double, s:string) => x.str + s;
var closure = f of (double * string); // suffixed name
\end{minted}

Suffixed names are used to disambiguate references to functions
from an overloaded set.

\section{Symbol Tables}
Felix represents scopes using symbol tables. There are two kinds of symbol table.

\subsection{Symbol definition table}
Every symbol defined is allocated a unique integer representative and 
the definition is stored in a hash table keyed by this integer, 
this is the {\em symbol definition table}. 
The definition includes a reference to the parent if any, and, a name lookup table if the
defined entity contains a scope.

\subsection{Name lookup table}
For each scope, another kind of hash table called a {\em name lookup table}
is used which maps a string name to a single entry which is one of two
kinds: either the entry is a non-function entry or a function entry.
Non-function entries contain a single view of a symbol, whilst 
function entries contain a list of views.

Each scope is associated with two name lookup tables.

\subsubsection{Private name lookup table}
This table maps all the names defined in the scope
to all the definitions in the scope. It is used for
unqualified lookup within the scope or any children of the scope.

\subsubsection{Public name lookup table}
This table contains mappings of the names of all
definitions in the scope which are not marked private
to those definitions. It is used for qualified lookup
into the scope from outside the scope.

\subsection{Views}
A {\em view} of a symbol consists of the index of the definition in the
symbol definition table together with a list of type variables and a list
of type expressions using these type variables, this list of
type expression must agree in number with the type variables 
in the entry symbol definition table.

The interpretation of a definition refered to by a view is as a polymorphic
definition indexed by the view type variables, with each use of the
definition's type variables in the body of the definition replaced
by the corresponding type in the view's list of type expressions.

For example:

\begin{minted}{felix}
class A[T] { fun f:T * T -> T; }
open[U, V] A[U * V];
var x = f ( (1,2.0), (3, 4.0) );
\end{minted}

This matches because the view of f available in
the open has type

\begin{minted}{felix}
(U * V) * (U * V)
\end{minted}

via the assigment \verb%T <- U * V%,
and the assignents
\verb%U <- int% and \verb%V <- long% mean the function call
is a specialisation of the view, which in turn is a specialisation
of the original function.

Multiple views of a function, even if overlapping, never create
an ambiguity: views are logically merged with non-discriminated
setwise union.

This is effected as follows by overload resolution.

\subsection{Name lookup environments}
A name lookup environment consists of a stack of pairs
of name lookup tables. The top of the stack represents
the current, innermost scope. This is where searching
for a name begins. Each layer represents an including
or parent scope, up to the bottom of the stack,
which represents the outermost or global scope,
which has no parent.

The two name lookup tables at each level are the primary
name lookup table and the shadow name lookup table.

\subsubsection{Primary name lookup table}
The primary name lookup table contains mappings for
all the symbols defined in the scope or injected
into the scope with a \verb%inherit% or \verb%rename% directives.

\subsubsection{Shadow name lookup table}
The shadow name lookup table contains mappings for
all the symbols made available by an \verb%open% directive
or by the \verb%with% clause of the type variable specification
of a definition.

\verb%open% directives make the public names defined
in, or inherited into, a class available via a view.

The name lookup algorithms always search the primary
lookup table first, if that fails they try the shadow
table. This ensures any definitions in a scope can be used
to hide names provided by an open, which ensures it is
possible to resolve ambiguities or modify semantics
for a particular name, whilst retaining the other names.

\section{Overload Resolution}
Overload resolution proceeeds as follows. We start with the result
of a function lookup which returns a set of views called candidates.
Our aim is to select a unique function, together with assignments to
the type variables of the definition, which cause the signature
of the call to equal the signature of the function, and any constraints
specified for the function to be satisfied.

\begin{itemize}
\item During overload resolution, a subset of the
candidates views is selected which match the supplied name and signatures.

\item Constraints are now applied to eliminate candidates additional candidates.
See \fullref{Type Constraints} for more details.

\item The subset is then reduced by eliminating views which are strictly less
specialised than another. 

\item If the result of this reduction consists of a set
of more than one view or the same function, then they must map to the same
specialisation of the function, and overload resolution has succeeded. 
\end{itemize}

The algorithm is non trivial. Here is another example:

\begin{minted}{felix}
class A[T] { fun f (x:T) => x; }
open[U] A[U * int];
open [V] A[int * V];
println$ f (1,1);
\end{minted}

Here, there are two views of \verb$f$, {\em both} of which 
have \verb%T <-int% as a specialisation. The first views is accepted
because \verb%U <- int% shows the call signature \verb%int * int%
is a specialisation of signature \verb%U * int%, 
and the second because \verb%V <- int% shows the call signatures is
a specialisation of the signature \verb%int * V%.

Now, the first view provides the substitution \verb%T <- U * int%
and the second \verb%T <- int * V%, and substituting the respective
specialisations of the views by the call results in the same specialisation
of the original function \verb%T <- int * int%. Therefore this specialisation,
being unique, allows the function \verb%f% to be called directly with signature
\verb%int * int%.

Not all calls view the views uniify. For example a call on signature
\verb%long * int% only matches the first view, and with \verb%int * long%
only matches the second: the point is that if more than one view
of the same function matches, it is never ambiguous because the views
always lead to the same specialisation of the function.

This is not true if the views are views of distinct functions.
Something like this can and does happen when the inverse of view
lookup is performed when instantiating class virtual functions
with distinct instances. In this case, if there are two instances
which match, neither of which is most specialised, then Felix
will report an ambiguity, even though semantically the behaviour
is required to be the same: the semantic requirement is too sloppy
to ensure this is meaninful.

Our conclusion is that the programmer is free to open overlapping
views of the same function, and in particular duplicated opens
do not cause a problem (the same consideration applies to non-functions).
This is {\em not} the case when specifying type class instances,
where overlaps are associated with distinct definitions, so that
a single most specialised definition is required. This issue,
however, does not occur in ordinary (phase 1) lookup of names.
It occurs only during instantiation by monomorphisation when
a type class virtual must select from available instances.
In this case, there is no overloading to consider since the
particular function in each instance is already selected:
we only need consider the specialisation lattice.

\section{Lookup}
Names refer either to a function set or single non-function entity.
Finding the entity a particular use of a name refers to is called
{\em name lookup} or {\em name binding}.

Note that unlike C++, Felix has no automatic type conversions.
Matching of signatures in Felix must be exact.
(However see \fullref{Row Polymorphism}).

\subsection{Unqualified name lookup}
Unqualified name lookup is performed using one of 
two base general algorithms, depending on the kind
of name required.

\subsection{Basic unqualified non-function lookup}
When seeking a non-function, Felix first looks for the
simple (non-indexed) part of the unqualified name in the
current scope.

If the name is found but it is a function symbol
the compiler aborts with a diagnostic message.

If the name is not found, it then looks in the special
shadow scope of the current context which contains symbols
inserted by \verb%open% or \verb%rename% directives.

If an \verb%open% or \verb%rename% directive introduces
the same non-function name into the same shadow scope
and it refers to the same non-function, with the equivalent
indices, one entry is discarded to prevent an ambiguous
name error, when in fact both insertions are equivalent
and refer to the same entity.

The equivalent indices check works by testing for
type equality after alpha conversion. For example

\begin{minted}{felix}
class Unique[T] { typedef A = B; }
open[U] Unique[U * U];
open[V] Unique[V * V];
var x: A[int]; // OK
\end{minted}

If there are two occurences of the name in the shadow scope,
it aborts the compile with a diagnostic message.
Note: this error occurs whilst creating the shadow scope,
even if the symbol is not used.

If the name is still not found, Felix repeats the process in
the parent scope, if any, or aborts the compile with
a diagnostic if there is no parent.

\begin{minted}{felix}
var x = 1;
class A {
  var x = "hello";
  class C {
     fun f() => x; // A::x = hello
   }
}

begin
  fun f() => x; // root::x = 1
end

open A;
fun f() => x; // root::x = 1

begin
  open A;
  fun f () => x; // A::x = hello
end
\end{minted}

If the name is indexed, it then checks that the number 
and kind of indices matches the definition of the symbol
discovered, if not it aborts the compile with a 
diagnostic.

\subsection{Basic unqualified function lookup}
This is the same as non-function lookup, except that
the result is expected to be a set of functions
with exactly one member.

\begin{minted}{felix}
fun f() => 1;
var closure = f; // only one f, OK
\end{minted}

\subsection{Lookup with signatures}
Felix can find a list of signatures for a function
lookup in two contexts.

If the name is a suffixed name, the suffix supplies
the sole signature:

\begin{minted}{felix}
fun f (x:int) => x;
fun f (x:double) => x;
var closure = f of (double);
\end{minted}

In an application or call the argument or arguments supply
the signatures:

\begin{minted}{felix}
fun f (x:int) => x;
fun f (x:double) => x;
var xi = f 1; // f of (double);
var xd = f 1.0; // f of (double);

fun g(x:int) (y:int) => x + y;
fun g(x:int) (y:double) => x.double + y;

var yi = g 1 2; // signatures int,int
var ydi = g 1 2.0; // signatures int,double
// var closure = g 1; // ambiguous, error
\end{minted}

Care must be taken designing functions to reduce
possible ambiguities. Using curried arguments has advantages
but one disadvantage is that eta-expansion may be required
to select the right overload. A famous example from the 
Felix library:

\begin{minted}{felix}
class List {
  fun map[T,U] (f:T->U) (ls: list[T]) : list[U];
}
class Varray {
  fun map[T,U] (f:T->U) (ls: varray[T]) : varray[U];
}

open List;
open Array;
fun itod (x:int): double => x.double;
// var closure = map itod; // Error, which map?
\end{minted}


\subsection{Unqualified function lookup with signatures}
When seeking a function with signatures, 
felix follows similar rules to non-functions, except as follows. 

When a function symbol is found, it consists of a set of functions,
not a single function. Felix then performs overload
resolution to determine if any of the candidates matches.

If there is no match at all, it proceeds with the next step.
If there is more than one match, and no match is most specialised,
it aborts with a diagnostic message.

Lookup in the shadow scope is performed similarly.
Function names introduced from multiple opens are merged
prior to the shadow scope lookup. This merger ensures that
if the same name is present in two opens, refers to the same
original symbol, and has the same type indicies, one is discarded.
Note: this merge of equivalent names is not done when constructing
the shadow scope, but during overload resolution. Therefore it
is not an error to introduce the same name with the same signature
for distinct functions, it is only an error if there is an attempt
to use such a name. This is different from non-function lookup.

\begin{minted}{felix}
fun f(x:int) => x; // signature int
class A {
  fun f(x:double) => x; // signature double
  fun g() {
    return f 1; // signature int: finds root::f of (int)
  }
}
begin 
  open A;
  fun f(x:string) => x; // signature string;
  var x = f 1.1; // signature int: finds A::f of (double)
end
\end{minted}

For the first lookup, there is no f in g.
There is no shadow scope.
The f in A has signature double which doesn't match.
The f in root has signature int which matches.

For the second lookup we want an f with signature double.
The f in the begin/end scope does not match.
The f in the begin/end shadow scope introduced by the open
does match so A::f of (double) is found.

Note that this algorithms is not the same as C++.
Felix has fixed the design fault.

   
\subsection{Qualified non-funtion name lookup}
Qualified name lookup for a non-function proceeds by
first performing an unqualified name lookup on the first
component of the qualified name, ignoring indices.

If the name is not found the compile aborts and a diagnostic
is issued. If the name is not a class name, the compiler aborts
and a diagnostic is issued.

Now, the next component is searched for in the
specified class scope. If the name is not found, the compile
aborts and a diagnostic is issued. The search ignores shadow
scopes, and it does not proceed into the context of the
classes parent. However it does take inherited names into account.
All names except the final one must resolve to class names.

The search a non-ultimate name requires a class to be found
in the previously found class. Qualified name lookup, therefore,
drills down into a class heirarchy from the root.

The final name is sought similarly and must be of the
kind sought.

Finally the complete sequence of type index parameters is checked
for length against the entity's definition.

\subsection{Qualified function name lookup}
Searching for a qualified name of a function is the same
as for a non-function, except that a set of overloaded
functions may be returned. 

If a unique symbol is required, then the set must contain
only one function name.

\subsection{Qualified lookup for function with signatures}
A standard qualified name lookup is performed so that the
last component returns a function set. 

Overload resolution is then performed on the function set.
The result is final.

\chapter{Classes}
\href{http://felix-lang.org/share/lib/grammar/namespaces.fsyn}{Syntax}

\section{Class Statement}
The top level Felix module can contain submodules 
which are specified by a non-polymorphic class
statement:

\begin{minted}{felix}
class classname { ... }
\end{minted}

\subsection{Qualified Names}
The effect is to produce a qualified name to be used
outside the class:

\begin{minted}{felix}
class classname { proc f () {} }
classname::f (); 
\end{minted}

\subsection{Nested Classes}
Classes may be nested.

\begin{minted}{felix}
class A { 
  class B {
    proc f () {}
    f(); 
  }
  B::f();
}
A::B::f (); 
\end{minted}

\subsection{Private definitions}
A class may contain private definitions,
if a symbol is marked private it is only visible
in the scope class in which it is defined,
including any nested classes:


\begin{minted}{felix}

class A { 
  private proc f () {}
  class B {
    f(); // visible inside A 
  }
  f(); // visible inside A
}
// A::f () fails, f is not visible outside A
\end{minted}

\subsection{Single File Rule}
A class must be specified within a single file.

\subsection{Completeness Rule}
Classes are not extensible, a definition of a class
with the same name in the same scope is not permitted.

\subsection{Setwise Lookup}
The body of a class forms a nested scope. Within
a class all symbols defined in the class are visible,
along with all those visible in the enclosing context.

\begin{minted}{felix}
var x = "Hello";
class A {
   proc f() { g(); } // g visible before defined
   proc g() { x = x + 1; } // use uninitialised variable!
   var x = 1;
}
\end{minted}

Beware using uninitialised variables! The procedure \verb%g%
above uses \verb%A::x% before it is initialised.

\subsection{Top level module alias}
The reserved name \verb%root% may be used as a prefix
for the top level module:

\begin{minted}{felix}
var x = 1;
class A { var x = root::x; }
\end{minted}

\section{Polymorphic Classes}

\subsection{Parametric Polymorphism}
A class may be specified with one or more type variables.
Such a class is said to be a polymorphic class.

\begin{minted}{felix}
class MakePair[T,U] {
  fun fwd_pair (x:T) (y:U) => x,y;
  fun rev_pair (x:T) (y:U) => x,y;
}
\end{minted}

\subsection{No Variables}
Polymorphic classes may not directly contain variables,
all members must be function or type definitions.

\subsection{Indexed Names}

Entities from a class can be specified from
outside using a qualified name in which the
class name is followed a square bracketted list
of types instantiating the corresponding type
variables, this is an {\em indexed name}:

\begin{minted}{felix}
var f = MakePair[int,string]::fwd_pair 42 "Hello";
var r = MakePair[int,string]::rev_pair 42 "Hello";
\end{minted}

\subsection{Deduced indices}
However one or more or even all the types can be omitted
from the right end of the list if they can be deduced by 
overload resolution. 

\subsection{Elision of indices}
The square brackets are optional if they enclose an
empty list.

\begin{minted}{felix}
f = MakePair[int,string]::fwd_pair 42 "Hello";
f = MakePair[int]::fwd_pair 42 "Hello";
f = MakePair[]::fwd_pair 42 "Hello";
f = MakePair::fwd_pair 42 "Hello";
\end{minted}

Note that all symbols in Felix are considered to be
indexed. So for example this is correct:

\begin{minted}{felix}
var x = 1;
println$ x[];
\end{minted}

\subsection{Sloppy indexing}
It is also permitted to move the instance types across
qualification boundaries:

\begin{minted}{felix}
f = MakePair[int]::fwd_pair[string] 42 "Hello";
\end{minted}

although this practice is not recommended.

From the outside, class type variables are
viewed as univeral quantification. From
inside however, the variable names are
fixed types which happen to be unknown, that
is they're to be considered as existentials.

This means they cannot be specified explicitly
or implicitly inside the class with unqualified access:

\begin{minted}{felix}
class A[T] {
  fun f(x:T) => x,x;
   fun g(y:T) => f y; // correct
   fun h(y:T) => A[T]::f y; // correct
   // fun h(y:T) => f[T] y; // wrong
}
\end{minted}

From inside the class the function \verb%f% above is
monomorphic, not polymorphic. Although \verb%T% is not
known, it is a fixed, invariant type.

\subsection{Polymorphic Members}
Functional members of a class may be polymorphic.
This is independent of the class type parameters.

\begin{minted}{felix}
class A[T] {
  fun f[U] (x:T, y:U) => x,y;
  fun g(a:T) => f[T * T] (a,a);
\end{minted}

In this case the function \verb%f% has its own personal
type variable \verb%U% which is set in the call in 
\verb%g% to \verb%T * T% because its argument is a pair
of \verb%a% which has that type.

\section{Virtuals and instances}
A polymorphic class may contain functions or
procedures marked \verb%virtual%. In this
case a definition is optional.

\begin{minted}{felix}
class A[T] {
  // non virtual function
  fun f(x:T) => x,x; 

  // virtual function with definition
  virtual fun g (x:T) => f x;

  // virtual function without definition
  virtual fun h : T -> T * T;
}
\end{minted}

If a virtual function without a definition from a class is used, it must be
defined for the types for which it is used. This is done in an
instance statement:

\begin{minted}{felix}
var a = 1; // int
var x = A[int]::h a; // h used for T=int

// instance defining h for int
instance A[int] {
  fun h(a:int) => a + 1, a - 1;
}
\end{minted}

An instance can be defined anywhere in a non-functional scope
provided the class being instantiated is visible.

In this case symbols in the instance definition are bound
the context of the instance scope and its enclosing scope
in the usual way.

It is not possible to directly access the definitions
in an instance from outside the instance. Instead all
access is diverted through the top level class being
instantiated. Symbols are bound to the top level class
member first to fix the type variables, then a matching
instance is sought.

If there is no matching instance, the program
fails with a diagnostic.

If there is more than than one matching instance,
the most specialised instance is used. If there
is no most specialised instance, the use of the class
member is ambiguous and the program fails with
a diagnostic.

An instance must be not less specialised than the class
it instantiated (that is, equally specialised or more specialised).

Instance specialisation is judged by the polymorphic subtyping
rule which is implemented using unification algorithm.

A polymorphic type S[T] parametrised by a type variable T is more
specialised than a polymorphic type A[U] is there if T may be
replaced by a type expression containing U the result of which
equals S[T].

If S has more than one type variable, substitutions for each
of them must be found. If A has more than one type variable,
the substitutions involve all of these variables.

A specialisation S1 of A is strictly more specialised than a specialisation
S2 of A if S1 is also strictly a specialisation of S2.

\subsection{Default Definition}
If a virtual function has a definition, it is called
a {\em default definition}. On a use of a function with
a default definition, if no matching instance is found, 
the default definition is specialised and used instead.
Note that default definitions do not resolve ambiguity
from overlapping instances.

\subsection{Matching polymorphic functions}
If a virtual function is polymorphic, the personal
type variables of the function must not be specialised
in an instance. The class type variables are resolved
independently of the function type variables.

You may think of this as if the class type variables
are resolved first by finding a uniquely matching
instance, and then the function type variables are
resolved in a second step (although in fact there
is no coupling between the resolution).

\section{Classes as Categories}
A class may thought of in a category theoretic sense.

A base category constists of objects which consists of a 
finite set of base types and all combinations thereof formed
by the available set of type combinators such as tuples,
records, function types, etc. 

The arrows of this category
consist of all the functions explicity defined on these
types, and all compositions thereof. This includes the
identity functions implicitly defined by copying.

This is the category generated by the graph consisting
of the defined functions, where paths in the graph
are (reverse) function compositions. This is called
the free category generated by the graph.

A class in the context of a base category generates
an extension to that category by throwing in some
additional types and arrows. The type variables are added 
to the set of base types, so that the set of combinations
is extended. The functions are added to the set of digraph
edges of the base generating graph, to add additional
arrows.

This view of the role of a class is vital to understand
semantic rules which correspond to the notion of a
category generated by a graph with relations. The relations
form a constraint. In category theory, the relations are 
generally equations relating the arrows which specify that
certain function compositions are equal to others.

The freely generated category is sometimes called an
initial algebra. When constraints are added a new
category is formed by collapsing some sequences of
arrows to a single arrow. There is a mapping called
an epi-morphism which takes each arrow from the freely
generated category to the target so that two distinct
composites may map to the same arrow in the target. 

Conversely, there is a reverse mapping from the arrows
of the target category to sets of arrows of the freely
generated one, forming another category called a quotient
category. These two mappings are functions and together
form an adjunction.

The purpose of this explanation is not merely for your
entertainment. In most programming classes are intended
to be constrained, that is, the instances are intended
to have a certain behaviour. 

Consider for example:

\begin{minted}{felix}
class Addable [T] {
  virtual fun add: T * T -> T;
}
\end{minted}

Now consider the following instances:

\begin{minted}{felix}
instance Addable[uint] {
  fun add (x:uint, y:uint) => x + y;
}

instance Addable[int] {
  fun add (x:int, y:int) => x + y;
}

instance Addable[double] {
  fun add (x:double, y:double) => x + y;
}
\end{minted}

These instances are good according to the specification,
however the addition of \verb%int% and \verb%double%
is unspecifed because we may have overflow. Furthermore
one may get a big surprise adding floating point representations
of reals: if you add a big float to a small one the small one
may be so small that the result is equal to the big one.

Basic laws of arithmetic are not obeyed by
floating representations, in particular addition of
floats is not associative!

It is usual to specify requirements in comments and
the programmer must carefully check that instances
obey the constraints specified for the class in these
comments.

Felix, however, can do a bit better.

\section{Axioms, Lemmas and Theorems}
Felix allows some semantic constraints on class instances
to be specified with explicit axioms. For example:

\begin{minted}{felix}
class Addable [T] {
  virtual fun add: T * T -> T;
  axiom associative (x:T, y:T, z:T):
    add (add (x,y), z) == add (x, add (y, z))
  ;
}
\end{minted}

The axiom documents in a formal language the requirement
that the addition operator defined in an instance
must be associative. An axiom is similar to an ordinary
boolean function which tests whether some condition is
met or not. By applying an axiom to particular values
we can check for non-conformance of instances.

However, in a categorical sense, an equational axiom
plays precisely the role of a relation in the formation
of a category with generators and relations. It is a vital
part of practical specification of semantics.

We should note that not all constraints can be expressed
as axioms in Felix. In particular since Felix only provides
first order polymorphism, only equational predicates
in Horn form can be used, that is, all the quantifiers
must be (implicitly or explicitly) on the left of the formula.
Interior quantifiers require second order polymorphism.

Note also that like most programming languages we use
constructive mathematics which constrains the role
of existentials to calculations. That is, it is not
acceptable to assert that something exists because
if it did not a contradiction would be derived.
Indirect proof is not allowed in constructive mathematics.

Instead, one must prove something exists by actually 
constructing one! So for example given $a < b$ we
know there exists a number $x$ such that $a < x < b$.
A proof of this by asserting that if no such $x$
existed, then we would have a contradiction, is
not allowed in constructive mathematics. Instead
the proof is simply given by $x = (a + b) / 2$.
And of course .. the assertion is false for many types
such as integers!

\subsection{Lemmas and Theorems}
Lemmas and theorems play the same role as axioms.
The idea, however, is that lemmas and theorems
can be derived from the axioms. A lemma is a simple
rule which a good automatic theorem prover could 
derive, and which seems obvious to a human.

A theorem is a more difficult rule which would
require a proof assistant with hints to derive a proof.

\subsection{Reductions}
A reduction is also an axiom, but it has an additional
property. Instead of an equation, reductions use a directed
equality:

\begin{minted}{felix}
  reduce revrev[T] (x:list[T]):
    rev (rev x) => x
  ;
\end{minted}

This reduction asserts that if you reverse a list twice
you end up back where you started. But it does more:
it give the compiler a hint that it is allowed to replace
an expression which reverse a list twice with the list,
removing the two reversing operations.

This is a particularly interesting example of the general
rule that all theorems are nothing more than optimisations,
in this case literally allowing the compiler to optimise
a program. Note that it is only a hint!

\chapter{General lookup}
By default Felix looks up symbols in nested scopes, 
starting with all symbols in the current scope
and proceeding through its containing scope outwards
until the outermost scope is reached.

Symbols are visible in the whole of a scope,
both before and after their introduction.

A symbol lookup may properly find either a single
non-function symbol, which is final, or a set 
of function symbols.

If the kind of symbol being sought is a function 
symbol, overload resolution is performed on 
the set of function signatures found in a scope.
If a best match is found, that is final.
If no match is found the search continues in 
the next outermost scope.

All other cases are in error.

\chapter{Overload Resolution}
Blah.

\chapter{Lookup control directives}

\section{Open directive}
The simple \verb%open% directive may be used to make the symbols
defined in a class visible in the scope containing the \verb%open% directive.

\begin{minted}{felix}
class X { var x = 1; }
open X;
println$ x;
\end{minted}


Names made visible by an open directive
live in a weak scope under the current scope.
Names in the weak scope may be hidden by definitions
in the current scope without error.

\begin{minted}{felix}
class X { var x = 1; }
open X;
var x = 2;
println$ x; // prints 2
\end{minted}


The open directive is not transitive.
The names it makes visible are only visible
in the scope in which the open directive is written.

\section{Inherit directive}
The inherit directive allows all of the public symbols
of a class to be included in another scope as if they
were defined in that scope. This means such names
inherited into a class can be accessed by qualification
with the inheriting class name, and will be visible
if that class is opened. 

Inheriting is transtitive.

If a name is inherited it will clash with a local definition.

\begin{minted}{felix}
class A { var a = 1; }
class B { inherit A; }
println$ B::a;
\end{minted}


\section{Rename directive}
This directive is can be used to inherit a single
symbol into a scope, possibly with a new name,
and also to add an alias for a name in the current
scope.

When applied to a function name all functions with
that name are renamed.


\begin{minted}{felix}
class A { 
  var a = 1; 
  proc f() {} 
  proc f(x:int) {} 
}

class B { 
  rename a = A::a;
  rename fun f = A::f;
}
\end{minted}

The new name injected by a rename may be polymorphic:

\begin{minted}{felix}
class A { proc f[T] () {} }
class B { rename g[T] = A::f[T]; } 
\end{minted}

\section{Use directive}
This is a short form of the rename directive:

\begin{minted}{felix}
class A { var a = 1; }
class B { use A::a; use b = A::a; }
\end{minted}

It cannot be applied to functions. The first
form is equivalent to

\begin{minted}{felix}
use a = A::a;
\end{minted}

Unlike the rename directive the new name cannot be polymorphic
and is limited to a simple identifier.

\section{Export directives}
The \verb%export% directives make the exported symbol a root
of the symbol graph. 

The functional export and forces it to be place in the
generated code as an \verb%extern "C"% symbol with the
given name:


\begin{minted}{felix}
export fun f of (int) as "myf";
export cfun f of (int) as "myf";
export proc f of (int) as "myf";
export cproc f of (int) as "myf";
\end{minted}


Functions are exported by generating a wrapper around
the Felix function. If the function is exported as \verb%fun%
or \verb%proc% the C function generated requires a pointer
to the thread frame as the first argument,
if the \verb%cfun% or \verb%cproc% forms are used, the wrapper
will not require the thread frame. 

In the latter case, the Felix function must not
require the thread frame.

A type may also be exported:

\begin{minted}{felix}
export type ( mystruct ) as "MyStruct";
\end{minted}

This causes a C typedef to be emitted making 
the name \verb%MyStruct% an alias to the Felix type.
This is useful because Felix types can have unpredictable
mangled names.

The word \verb%export% optionally followed by a string
may also be used as a prefix for any Felix function,
generator, or procedure definition. If the string
is omitted is taken as the symbol name. The effect
is the same as if an export statement has been written.

\part{Type System}
\chapter{Type constructors}
\href{http://felix-lang.org/share/lib/grammar/type_decls.fsyn}{Syntax}

\section{typedef}
The typedef statement is used to define an alias for a type.
It does not create a new type.

\begin{minted}{felix}
typedef Int = int;
\end{minted}


\section{Tuples}
Tuple types are well known: a tuple is just a Cartesian Product
with components identified by position, starting at 0. 
The n-ary type combinator is infix \verb%*% and the n-ary value
constructor is infix \verb%,%:

\begin{minted}{felix}
val tup : int * string * double = 1, "Hello", 4.2;
\end{minted}

The 0-ary tuple type is denoted \verb%1% or \verb%unit%
with sole value \verb%()%:


\begin{minted}{felix}
val u : unit = ();
\end{minted}


The 1-ary tuple of type \verb%T% component value \verb%v% is identified
with the type \verb%T% and has value \verb%v%.

The individual components of a tuple may be accessed by a projection
function. Felix uses an integer literal to denote this function.

\begin{minted}{felix}
var x = 1,"Hello";
assert 0 x == 1; assert x.0 == 1;
assert 1 x == "Hello"; assert x.1 == "Hello";
\end{minted}


[There should be a way to name this function without application to
a tuple!]

A pointer to a tuple is also in itself a tuple, namely the
tuple of pointers to the individual components. This means
if a tuple is addressable, so are the components.

\begin{minted}{felix}
var x = 1, "Hello";
val px = &x;
val pi = px.0; pi <-42;
val ps = px.1; ps <-"World";
assert x.0 == 42;
assert x.1 == "World";
\end{minted}


In particular note:

\begin{minted}{felix}
var x = 1, "Hello";
&x.0 <- 42;
\end{minted}


because the precedences make the grouping \verb%(&x).0%.

You cannot take the address of a tuple component because
a projection of a value is a value.

Assignment to components of tuples stored in variables is supported
but only to one level, for general access you must take a pointer
and use the store-at-address operator \verb%<-%.

\subsection{Tuple projections}
The projections of a tuple can also be written in an expanded form
so that they may stand alone as functions:


\begin{minted}{felix}
var first = proj 0 of (int * string);
var a = 1, "Hello";
var one = a . first; 
var two = a . proj 1 of (int * string);
\end{minted}


\section{Records}
A record is similar to a tuple except the components are 
named and considered unordered up to duplication.

\subsection{Plain Record}
A plain record is one without duplicate fields. A plain record
type is one without duplicate fields or a row variable.
A record is constructed using a parenthesis enclosed list
of comma separated field assignments. An empty record is
equivalent to an empty tuple.

\begin{minted}{felix}
typedef xy = (x:int, y:int);
var r : xy = (x=1,y=2);
\end{minted}

\subsection{Record projections}
A component of a record may be accessed with a 
function called a record value projection, it is denoted
by the name of the field.

\begin{minted}{felix}
var r (x=1,y=2);
println$ x r, r.y;
\end{minted}

Record value projections can also be used as stand-alone
functions. For example:

\begin{minted}{felix}
var rl = list ((x=1,y=11),(x=2,y=22));
var xs =  map (x of (x:int, y:int)) rl;
println$ xs; // list (1,2)
\end{minted}

Records also have pointer projections, overloaded with
the value projections: if the name of
a field is applied to a pointer to a record,
a pointer to the named component field is returned.
This allows assignment and other mutators to be
applied to record components.

\begin{minted}{felix}
var r =(x=1,y=2);
var px = &r.x; // means (&r).x
px <- 42;
r&.y <- 23;
println$ r.x, r.y; // (42,23)
\end{minted}

Record pointer projects can also be used as stand-alone functions:

\begin{minted}{felix}
var prjx = x of (xy);
var prjpx = x of (&xy);
\end{minted}

\subsection{General record}
Records may have duplicate fields. In this case, reading from left
to right in a record literal, a duplicate field is hidden by a previous 
field of the same name, in a push down stack like fashion.
 
\begin{minted}{felix}
var r = (x=1,y=2,x="Hello");
println$ r._strr, r.x;
  // ((x=1,x='Hello',y=2), 1)
\end{minted}

Note that the generic function \verb%_strr% displays the whole of the
record including duplicate fields. However projections only find
the left-most field.

\subsection{Adding fields}
Fields can be added to an existing record to construct 
a new record:

\begin{minted}{felix}
var r = (x=1,y=2);
var r2 = (a="one",b="two",x="newx" | r);
println$ r2._strr,r2,x;
  // ((a='one',b='two',x='newx',x=1,y=2), newx)
\end{minted}

Again, leftmost fields hide rightmost ones. You can also add two 
records with infix \verb%+%:

\begin{minted}{felix}
var r = (a=1) + (b=2) + (a="hello");
println$ r._strr, r.a.str; // ((a=1,a='hello',b=2), 1)
\end{minted}

The leftmost field with a given name dominates. Record addition
by \verb%+% is only applied if a user defined addition is not
found for the argument types.

Currently, addition of fields of two records of the same type
is not supported: it is likely the user intended to add corresponding
field values rather than hide the fields in the right argument
with those on the left.


\subsection{Row Polymorphism}
\label{Row Polymorphism}
Felix provides a special record type called a {\em polyrecord} which
supports row polymorphism with scoped labels in the style of
Daan Leijen. The article
is \href{http://research.microsoft.com/pubs/65409/scopedlabels.pdf}{here}.

This allows a generic function to be written which accepts an argument
which is or contains a value of a record type with more fields than
required. Unlike subtyping, the extra fields, whilst inaccessible,
are not lost and can be returned by the function. For example:

\begin{minted}{felix}
val circle = (x=0.0,y=0.0,r=1.0);
val square = (x=0.0,y=0.0,w=1.0,h=1.0);

fun move[T] (dx:double, dy:double) (shape: (x:double, y:double | T)) =>
  (x=shape.x+dx, y=shape.y+dx | (shape without x y))
;

var inc = 1.0,1.0;
println$ (move inc circle)._strr, (move inc square)._strr;
\end{minted}

\subsubsection{{\tt without} operator}
The \verb%without% operator can be used to return a record
with some fields removed. It works on values of record and
polyrecord type. Note that because Felix uses scoped fields
once a field is removed, the previous value of that field is exposed
if it exists, and can also be removed. This means it is correct
and sometimes necessary to list a field more than once when
using the \verb%without% operator.


\subsection{Interfaces}
An interface is a special notation for a record type
all of whose fields are functions or procedures.

\begin{minted}{felix}
interface fred {
  f: int -> int;
  g: int -> 0; // procedure
}

// equivalent to
typedef fred = (f: int -> int, g: int -> 0);
\end{minted}

The primary use is for specifying the type of a Java like
object.

\section{Structs}
A struct is a a nominally typed record, that is, it must be defined,
and each definition specifies a distinct type.

\begin{minted}{felix}
struct S { x:int; y:int; };
var s : S = S (1,2);
println$ s.x,s.y;
\end{minted}

A struct value can be constructued using the structure name as a function
and passing a tuple of values corresponding by position to the fields
of the struct.

A struct constructor can be used a first class function.

The field names are projection functions and can be applied
to a struct value to extract the nominated component,
or applied to a pointer to a struct to find a pointer to the
nominated component.

The notation (may be changed soon)

\begin{minted}{felix}
var prjx = x of (S);
var prjpx = x of (&S);
\end{minted}

can be used to refer to a projection in isolation, and a pointer
projection in isolation, that is, as unapplied first class functions.

A struct may also contain function and procedure definitions:

\begin{minted}{felix}
struct A { 
  x:int;
  y:int;
  fun get2x => 2 * self.x;
  fun get2y () => 2 * self.y;
  proc diag (d:int) { self.x <- d; self.y <-d; }
};
\end{minted}

These functions are precisely equivalent to:

\begin{minted}{felix}
fun get2x (self:A) => 2 * self.x;
proc diag (self: &A) (d:int) { self.x <-d; self.y <-d; }
\end{minted}

Note that for a function \verb%self} is a value, for a procedure @{self%
is a pointer.

Because of these definitions, we can form object closures over a struct:

\begin{minted}{felix}
var a = A(1,2);
var g2y = a. get2y;
var di = a . diag;
\end{minted}

Note we can't form a closure for \verb%get2x% without an explicit wrapper,
i.e. eta-expansion.

\section{Sums}
Sum types are the dual of tuples. They represent a sequence
of possible cases, potentially with arguments. Case indicies
are 0 origin. Sum variables are decode with a match which
may also extract an argument value:

\begin{minted}{felix}
typedef num = int + long + double;
var x = (case 1 of num) 53L;
println$ 
  match x with
  | case 0 (i) => "int " + i.str
  | case 1 (l) => "long" + l.str
  | case 2 (d) => "double " + d.str
  endmatch
;
\end{minted}


\subsection{Unit sum}
There is a family of special sum types equivalent to:

\begin{minted}{felix}
  2 = 1 + 1
  3 = 1 + 1 + 1
  4 = 1 + 1 + 1
\end{minted}

Recall type 1, or unit, is the type of the empty tuple.
The type 2 is also known as bool, and represents two cases
where \verb%false} is an alias for @{case 0 of 2} and @{true%
is an alias for \verb%case 1 of 2%.

The type 0 or void, is the type of no values.

These types are called unit sums because they're a sum
of a certain number of units.

Note carefully that:

\begin{minted}{felix}
  x + (y + z), (x + y) + z, x + y + z
\end{minted}

are three distinct types because operator + is not associative.

\section{union}
A union is the dual of a struct. It is a nominally typed version
of a sum. Here for example is a list of integers:

\begin{minted}{felix}
union intlist {
  iEmpty ;
  iCons of int * intlist;
};
\end{minted}


This alternative syntax is more commonly used
and comes from ML family:

\begin{minted}{felix}
union intlist = 
  | iEmpty 
  | iCons of int * intlist
;
\end{minted}


The fields of a union type are injections or type constructors.
In effect they cast their argument to the type of the union, thus
unifying heterogenous types into a single type.

Pattern matches are used to decode unions.

\begin{minted}{felix}
var x = iEmpty;
x = iCons (1, x);
x = iCons (2, x); // list of two integers

fun istr (x:intlist) =>
  match x with
  | #iEmpty => "end"
  | iCons (i, tail) => i.str + "," + istr tail
  endmatch
;
\end{minted}


The first variant represents an empty list. The second variant
says that a pair consisting of an int and a list can be considered
as a list by applying the type constructor iCons to it.

Unlike product types, a sum may directly contain itself.
This is because sum types are represented by pointers.

\subsection{enum}
A restricted kind of union, being a nominally typed version
of a unit sum.

\begin{minted}{felix}
enum colour { red, green, blue }; // same as
enum colour = red, green, blue; // same as
union colour = red | green | blue;
\end{minted}


The tag value of an enum can be set:

\begin{minted}{felix}
enum wsize = w8=8, w16=16, w32=32, w64=64;
\end{minted}


\subsection{caseno operator}
The caseno operator can find the tag value of any sum type,
the anonymous sum, union, enum or variant as an integer.

\begin{minted}{felix}
assert caseno w16 == 16;
assert caseno (case 1 of 2) == 1;
\end{minted}


\section{variant}
Wariants the sum type which are the dual of records.
They used named injections like unions but are structurally typed.

\begin{minted}{felix}
typedef vars = union { Int of int ; Float of float; };
\end{minted}


\section{Array}
Felix has various kinds of array. The term is abused and sometimes
refers to the abstract concept, and sometimes the statically
typed fixed length array described here.

An array is nothing but a tuple all of whose elements have the
same type. It is convenient to use an exponential operator with
a  unit sum index to provide a compact notation:

\begin{minted}{felix}
int ^ 3 // array of 3 integers equivalent to
int * int * int
\end{minted}

Therefore the value:

\begin{minted}{felix}
var a3 = 1,2,3;
\end{minted}

is, in fact, an array. As for tuples an integer literal applied
to an array value returns a component, however for arrays,
an expression may be used as well:

\begin{minted}{felix}
var i = 1;
var y = a3 . i;
var z = a3 . proj i of (int^3);
\end{minted}

The last form is equivalent to

\begin{minted}{felix}
var z = a . 
  match i with
  | 0 => proj 0 of (int^3)
  | 1 => proj 1 of (int^3)
  | 2 => proj 2 of (int^3)
  | _ => throw error
  endmatch
;
\end{minted}

in other words there is a run time array bounds check equivalent to a match failure.
Note that of course the actual generated code is optimised!

A run time check can be avoided by using the correct type of index:

\begin{minted}{felix}
var i = case 1 of 3;
var z = a . i; // no run time check
\end{minted}


\subsection{Multi-arrays}
Whilst we introduced the exponential notation

\begin{minted}{felix}
  B ^ J
\end{minted}

as a mere shorthand, where J is a unit sum, in fact Felix allows
the index to be any compact linear type.

A compact linear type is any combination of sums, products,
and exponentials of unit sums. The type

\begin{minted}{felix}
 3 * 4 * 5
\end{minted}

for example is compact linear, and therefore Felix allows the array type

\begin{minted}{felix}
typedef matrix = double ^ (3 * 4 * 5)
\end{minted}

Although this looks like the type

\begin{minted}{felix}
typedef array3 = double  ^ 3 ^ 4 ^ 5
\end{minted}

as suggested by the usual index laws, the latter is an array size 5 of
arrays size 4 of arrays size 3 which can be used like:

\begin{minted}{felix}
var a : array3;
var z = a . case 1 of 5 . case 1 of 4 . case 1 of 3;
\end{minted}

where you will note that the projections are applied in the reverse
order to the indices. On the other hand to use the first form we have
instead:

\begin{minted}{felix}
var m : matrix;
var z = a . (case 1 of 3, case 1 of 4, case 1 of 5);
\end{minted}

The exponent here is a value of a compact linear type.
It is a single tuple value! It is called a multi-index
when applied to an array.

The advantage of this type is that there is an obvious
encoding of the values shown in this psuedo code:

\begin{minted}{felix}
  i * 3 * 4 + j * 3 + k
\end{minted}

which is nothing more than a positional number notation where the
base varies with position. That encoding clearly associates
with the compact linear value as integer in the range 0 to 59,
or, alternatively, an value of type 60. In other words the type
is linear and compact.

Since clearly, given an integer in range 0 through 59 and this type
we can decode the integer into a tuple, being the positional representation
of the integer in this weird coding scheme, the type is clearly
isomorphic to the subrange of integer.

Therefore Felix allows you to coerce an integer to a compact linear
type with a run time check, and convert a compact linear type
to an integer or a unitsum:

\begin{minted}{felix}
var i : int = ((case 1 of 3, case 1 of 4, case 1 of 5) :>> int);
var j : 60 = ((case 1 of 3, case 1 of 4, case 1 of 5) :>> 60);
var clt : 3 * 4 * 5 = (16 :>> 3 * 4 * 5);
\end{minted}

Because we can do this we can now write a loop over a matrix
with a single iterator:

\begin{minted}{felix}
for i in 60 do
  println$ m . (i :>> 3 * 4 * 5);
done
\end{minted}

This is an advanced topic which will require an extensive explanation
beyond the scope of this summary. However we will not that this
facility provides a very high level feature known as polyadic array
programming. In short this means that one may write routines which
work on matrices of arbitrary dimension. You can of course do this
in C by doing your own index calculations at run time and using
casts, however Felix does these calculations for you based on the
type so they're always correct.


\chapter{Meta-typing}
Felix provides some facilities for meta-typing.

\subsection{typedef fun}
The notation

\begin{minted}{felix}
typedef fun diag (T:TYPE):TYPE=> T * T;
var x: diag int = 1,2;
\end{minted}

defines a type function (or functor). Given a type T,
this function returns the type for a pair of T's.
The identifier \verb%TYPE% denotes the kind which is a category 
of all types.

Applications of type functions must be resolved during binding, since
the result may influence overloading.

\section{typematch}
Felix has a facility to inspect and decode types at compile time.

\begin{minted}{felix}
typedef T = int * long;
var x: 
  typematch T with
  | A * B => A
  | _ => int
  endmatch
  = 1
;
\end{minted}

As with type functions, type matches must be resolved during binding.
If a type match fails, an error is issued a compilation halted.
The wildcard type pattern \verb%_% matches any type.

The real power of the type match comes when combined with a type function:

\begin{minted}{felix}
typedef fun promote (T:TYPE): TYPE =>
  typematch T with
  | #tiny => int
  | #short => int
  | #int => int
  | #long => long
  | #vlong => vlong
  endmatch
;
\end{minted}

This functor does integral promotions of signed integer types 
corresponding to ISO C rules.

\section{type sets}
TBD

\chapter{Abstract types}
Felix provides abstract types as demonstrated in this example.

\begin{minted}{felix}
class Rat {
  type rat = new (num:int, den:int);
  ctor rat (x:int, y:int) =>  
    let d = gcd (x,y) in
    _make_rat (num=x/d, den-y/d)
  ;

  fun + (a:rat, b:rat) => 
    let a = _repr_ a in
    let b = _repr_ b in
    _make_rat ( 
      a.num * b.den + b.num * a.den,
      a.den * b.den
    )
  ;
}
\end{minted}

Here, the abstract type \verb%rat% is represented by a record of
two integers, \verb%num} and @{den%, but this type is hidden.

Inside the class \verb%Rat} the operator @{_make_rat% 
casts the implementation value to an abstract value,
and the operator \verb%_repr_% casts the abstract value to its implementation.

These casts cannot be used outside the class, thereby hiding the implementation
outside the class.

\chapter{Polymorphism}
\section{Type Constraints}
\label{Type Constraints}
Felix provides 4 kinds of type constraints.
\subsection{Type class constraints}
Class constraints have no impact on phase 1 overload resolution
when selecting a binding. 

However, when binding the definition
of a symbol, specified class views are introduced in a shadow
scope as if the class were opened.

During monomorphisation, any virtuals must be mapped to instance
functions and this is done by a process similar to that used for
overload resolution. 

\subsection{Typeset membership constraints}
Typesets were introduced to Felix to simplify bindings to C functions.
For example:

\begin{minted}{felix}
typedef someints = typesetof (int, long);
typedef someuints = typesetof (uint, ulong);
fun someadd[T in someints] : T * T -> T = "$1+$2";
fun someadd[T in someuints] : T * T -> T = "$1+$2";
println$ someadd (1,2); // OK, first function
println$ someadd (1u,2u); // OK, second function
// println$ someadd (1,2u); // fails
\end{minted}

In this example, a call to \verb%someadd% will only work if
the arguments types are the same and both either \verb%int% or \verb%long%.
Overload resolution first treats the functions as if there were no constraints.
Then, any candidate which fails the constraint it thrown out of the set.

This method saves writing out all the cases individually,
which may be exponential in the number of individual types involved,
whilst at the same time preventing invalid cases which an unconstrained
binding would allow.

If two candidates exist with the same signatures, and one has
a constraint and the other does not (or has the constant constraint true),
the constrained candidate is considered more specialised than the
unconstrained one.

However in general, constraints cannot be compared to see which is
most specialised. In particular if for all values of type variables
constraint A implies constraint B, A is more specialised, however
there is no operational method for measuring this in general
(halting problem!).

\subsection{Equational Constraints}
Felix allows a constraint to be
For example:

\begin{minted}{felix}
fun f[T,U where T * int == int * U] (x:T * U) => x;
println$ f (1,2);
\end{minted}

This example uses an equational constraint.

Here is another example using a typematch:

\begin{minted}{felix}
typedef fun ispair (x:TYPE) : TYPE => 
  typematch x with
  | _ * _ => 1
  | _ => 0
  endmatch
;

fun f[T where ispair T] (x:T)=>x;

println$ f (42,33L); // OK, signature ispair (int * long) true
\end{minted}

\part{Definitions}
\chapter{Variable Definitions}
\href{http://felix-lang.org/share/lib/grammar/variables.fsyn}{Syntax}

A definition is a statement which defines a name, but does
no cause any observable behavior, or, a class statement, or, 
a var or val statement. The latter two exceptions define a name
but may also have associated behaviour.

\section{The {\tt var} statement}
The \verb%var% statement is used to introduce a variable name
and potential executable behaviour. It has one of three 
basic forms:

\begin{minted}{felix}
var x : int = 1;
var y : int;
var z = 1;
\end{minted}

The first form specifies the type and an initialising
expression which must be of the specified type.

The second form specifies a variable of the given type
without an explicit initialiser, however the variable
will be initialised anyhow with the default contructor
for the underlying C++ type, although that constructor
may be trivial.

The third form does not specify the type, it will be deduced
from the initialiser.

If the initialiser has observable behaviour it will be observed
if at all, when control passes through the variable statement.

If the variable introduced by the \verb%var% statement is not used,
the variable and its initaliser will be elided and any observable
behaviour will be lost.

To be used means to have its address taken in a used expression,
to occur in a used expression. A used expression is one which
initialises a used variable, or, is an argument to function
or generator in a used expression, or an argument to a procedure
through which control passes. 

In other words, the variable is used if the behaviour of
the program appears to depend on its value or its address.

The library procedure \verb%C_hack::ignore% ensures the compiler
believes a variable is used:

\begin{minted}{felix}
var x = expr;
C_hack::ignore x;
\end{minted}

so that any side effects of \verb%expr% will be seen.
In general the argument to any primitive function, generator
or procedure will be considered used if its containing 
entity is also considered used. In general this means there
is a possible execution path from a root procedure of the
program.

A variable may have its address taken:

\begin{minted}{felix}
var x = 1;
var px = &x;
\end{minted}

it may be assigned a new value directly or indirectly:

\begin{minted}{felix}
x = 2;
px <- 3;
*px = 4;
\end{minted}


A variable is said to name an object, not a value.
This basically means it is associated with the address of a typed
storage location.

\subsection{Multiple variables}
Multipls variables can be defined at once:


\begin{minted}{felix}
var m = 1,2;
var a,b = 1,2;
var c,d = m;
\end{minted}

With this syntax, no type annotation may be given.

\section{The \tt{val} statement.}
A \verb%val% statement defines a name for an expression.

\begin{minted}{felix}
val x : int = 1;
val z = 1;
\end{minted}

The value associated with a \verb%val% symbol may be computed
at any time between its definition and its use, and may
differ between uses, if the initialising expression depends
on variable state, such as a variable or call to a generator.

It is not an error to create such a dependence since either
the value may, in fact, not change, or the change may
not be significant.

Nevertheless the user must be warned to take care
with the indeterminate evaluation time and use
a \verb%var% when there is any doubt.

Since a \verb%val% simply names an expression, it is associated
with a value not an object and cannot be addressed
or assigned to. However this does NOT mean its value cannot
change:

\begin{minted}{felix}
for var i in 0 upto 9 do
  val x = i;
  println$ x;
done
\end{minted}

In this example, x isn't mutable but it does take on
all the values 0 to 9 in succession. This is just a 
most obvious case: a less obvious one:

\begin{minted}{felix}
var i = 0;
val x = i;
println$ x;
++i;
println$ x;
\end{minted}

which is clearly just an expansion of the the first two
iteration of the previously given for loop. However in
this case there is no assurance \verb%x% will change after \verb%i%
is incremented because the compiler is free to replace
any \verb%val% definition with a \verb%var% definition.

\subsection{Multiple values}
Multipls values can be defined at once:

\begin{minted}{felix}
val m = 1,2;
val a,b = 1,2;
val c,d = m;
\end{minted}

With this syntax, no type annotation may be given.


\chapter{Functions }
\href{http://felix-lang.org/share/lib/grammar/functions.fsyn}{Syntax}

\section{Functions }
A felix function definition takes one of three basic forms:

\begin{minted}{felix}
fun f (x:int) = { var y = x + x; return y + 1; }
fun g (x:int) => x + x + 1;
fun h : int -> int = | x => x + x + 1;
\end{minted}

The first form is the most general, the body 
of the function contains executable statements
and the result is returned by a return statement.

The second form is equivalent to a function in the first
form whose body returns the RHS expression.

The third form specifies the function type then the
body of a pattern match. It is equivalent to

\begin{minted}{felix}
fun h (a:int) = { return match a with | x => x + x + 1 endmatch; }
\end{minted}

The first two forms also allow the return type to be
specified:

\begin{minted}{felix}
fun f (x:int) : int = { var y = x + x; return y + 1; }
fun g (x:int) :int => x + x + 1;
\end{minted}


Functions may not have side effects.

All these function have a type:

\begin{minted}{felix}
D -> C
\end{minted}

where D is the domain and C is the codomain: both would
be \verb%int% in the examples.

A function can be applied by the normal forward
notation using juxtaposition or what is whimsically
known as operator whitespace, or in reverse notation
using operator dot:

\begin{minted}{felix}
f x
x.f
\end{minted}

Such applications are equivalent.  Both operators are left
associative. Operator dot binds more
tightly than whitespace so that

\begin{minted}{felix}
f x.g    // means
f (g x)
\end{minted}


A special notation is used for application to the unit tuple:

\begin{minted}{felix}
#zero // means
zero ()
\end{minted}

The intention is intended to suggest a constant since a pure
function with unit argument must always return the
same value. 

This hash operator binds more tightly than operator dot so

\begin{minted}{felix}
#a.b // means
(#a).b
\end{minted}



\section{Pre- and post-conditions}
A function using one of the first two forms
may have pre-conditions, post-conditions, or both:

\begin{minted}{felix}
fun f1 (x:int when x > 0) => x + x + 1;
fun f2 (x:int) expect result > 1 => x + x + 1;
fun f3 (x:int when x > 0) expect result > 1 => x + x + 1;
fun f4 (x:int when x > 0) : int expect result > 1 => x + x + 1;
\end{minted}

Pre- and pos-conditions are usually treated as boolean assertions
which are checked at run time. The compiler may occasionally be able
to prove a pre- or post-condition must hold and elide it.

The special identifier \verb%result% is used to indicate the return
value of the function.

\section{Higher order functions}
A function may be written like

\begin{minted}{felix}
fun hof (x:int) (y:int) : int = { return x + y; }
fun hof (x:int) (y:int) => x + y;
\end{minted}

These are called higher order functions of arity 2.
They have the type

\begin{minted}{felix}
int -> int -> int   // or equivalently
int -> (int -> int) //since -> is right associative.
\end{minted}

They are equivalent to

\begin{minted}{felix}
fun hof (x:int) : int -> int = 
{
  fun inner (y:int) : int => x + y;
  return inner;
}
\end{minted}

that is, a function which returns another function.

Such a function can be applied like

\begin{minted}{felix}
hof 1 2 // or equivalently
(hof 1) 2
\end{minted}

since whitespace application is left associative.

\section{Procedures}
A function which returns control but no value is called a procedure.
Procedures may have side effects.


\begin{minted}{felix}
fun show (x:int) : 0 = { println x; }
proc show (x:int) { println x; }
proc show (x:int) => println x;
\end{minted}


The second form is a more convenient notation.
The type 0 is also called \verb%void% and denotes
a type with no values.

A procedure may return with a simple return statement:


\begin{minted}{felix}
proc show (x:int) { println x; return; }
\end{minted}


however one is assumed at the end of the procedure
body.

Procedures can also have pre- and post-conditions.

A procedure may be called like an application,
however it must be a whole statement since
expressions of type void may not occur interior
to an expression.


\begin{minted}{felix}
show 1;
1.show;
\end{minted}


If a procedure accepts the unit argument, it may be elided:


\begin{minted}{felix}
proc f () =>  show 1;
f; // equivalent to
f ();
\end{minted}


\section{Generators}
A generator is a special kind of function which is allowed
to have side effects. It is defined similarly to a function,
but using the binder \verb%gen% instead of \verb%fun%:


\begin{minted}{felix}
var seqno = 1;
gen seq () { var result = seqno; ++seqno; return result; }
\end{minted}


When a generator is directly applied in an expression, the application
is replaced by a fresh variable and the generator application
is lifted out and assigned to the variable. For example:


\begin{minted}{felix}
fun twice (x:int) => x + x;
println$ twice #seq;
\end{minted}


will always print an even number because it is equivalent to


\begin{minted}{felix}
var tmp = #seq;
println$ twice tmp;
\end{minted}


Therefore even if twice is inlined we end up with the argument
to \verb%println} being @{tmp+tmp} and not @{#seq+#seq% which would
print an odd number.

\subsection{Yielding Generators}
A generator may contain a \verb%yield% statement:

\begin{minted}{felix}
gen fresh() {
  var x = 1;
  while x < 10 do
    yield x;
    ++x;
  done
  return x;
}
\end{minted}

In order to use such a yielding generator, a closure of the generator
must be stored in a variable. Then the generator may be called repeatedly.


\begin{minted}{felix}
var g = fresh;
for i in 1 upto 20 do 
  println$ i,#g;
done
\end{minted}


This will print pairs (1,1), (2,2) up to (10,10) then print
(11,10), (12,10) up to (20,10).

The yield statement returns a value such that a subsequent call
to a closure of the generator will resume execution after the yield
statement. Therefore \verb%yield% is a kind of cross between a return
and a subroutine call.

If a generator executes a return statement, that is equivalent
to yielding a value and setting the resume point back to the return
statement, in other words \verb%return expr;% is equivalent to

\begin{minted}{felix}
while true do yield expr; done
\end{minted}


Yielding generators should not be called directly because they
will always start at the beginning with a fresh copy of any
local variables used to maintain state.

Function closures differ from generator closures in that
the closures is cloned before every application to ensure
that the initial state is fresh.

Yielding generators are primarily intended to implement iterators,
that is, to provide lazy lists or streams.

\section{Constructors}
Felix provides a special notation which allows an identifier
naming a type to return a value of that type:

\begin{minted}{felix}
typedef cart = dcomplex;
typedef polar = dcomplex;
ctor cart (x:double, y:double) => dcomplex (x,y);
ctor polar (r: double, theta: double) => 
  dcomplex (r * sin theta, r * cos theta)
;
var z = cart (20.0,15.0) + polar (25.8, 0.7 * pi);
\end{minted}

The constructions are equivalent to

\begin{minted}{felix}
fun _ctor_cart (x:double, y:double) : cart => dcomplex (x,y);
fun _ctor_polar (r: double, theta: double): polar => 
  dcomplex (r * sin theta, r * cos theta)
;
\end{minted}

When a type with a simple name is applied to a value,
Felix tries to find a function with that name prefixed by  \verb%_ctor_%
instead.

Note that Felix generates a constructor for struct and cstruct types
automatically with argument type the product of the types of the
structure fields.

\section{Special function {\tt apply}}
When Felix finds and application

\begin{minted}{felix}
  f a
\end{minted}

where \verb%f% is a value of type F which is not
a function (or C function) type, Felix looks instead 
for a function named apply with argument of type:

\begin{minted}{felix}
F * A
\end{minted}

where A is the type of a. For example

\begin{minted}{felix}
fun apply (x:string, y:string) => x + y; // concat
var x = "hello " "world"; // apply a string to a string
\end{minted}


\section{Objects}
Felix provides an object system with syntax based on Java,
and technology based on CLOS.

An object is a record of function closures, closed over the local
scope of a constructor function that returns the record.


\begin{minted}{felix}
interface person_t {
  get_name: 1 -> string; 
  set_age: int -> 0; 
  set_job : string -> 0;
  get_job : 1 -> string;
}

object person (name:string, var age:int) implements person_t =
{
  var job = "unknown";
  method fun get_name () => name;
  method proc set_age (x:int) { age = x; }
  method fun get_job () => job;
  method proc set_job (x:string) {  job = x; }
}

var john = person ("John", 42);
println$ #(john.name) + " is " + #(john.age).str;
\end{minted}

The entity \verb%person% is a function which when called with
its argument of name and age returns a record of type
\verb%person_t% consisting of closures of the functions and procedures
marked as method in its definition.

Since functions hide their local variables the object state
is hidden and can only be accessed using the methods.

The \verb%implements% clause is optional.

Objects provide an excellent way for a dynamically loaded
shared library to export a set of functions, only the object
function needs to be exported so it has a C name which
can be linked to with \verb%dlopen%.


\part{Executable statements}
\section{Assignment}
\href{http://felix-lang.org/share/lib/grammar/assignment.fsyn}{Syntax}

\section{The {\tt goto} statement and label {\tt prefix}}
Felix statements may be prefixed by a label
to which control may be transfered by a \verb%goto%
statement:

\begin{minted}{felix}
alabel:>
  dosomething;
  goto alabel;
\end{minted}

The label must be visible from the goto statement.

There are two kinds of gotos. A local goto is a jump
to a label in the same scope as the goto statement.

A non-local goto is a jump to any other visible label.

Non-local transfers of control may cross procedure
boundaries. They may not cross function or generator 
boundaries.

The procedure or function containing the label 
must be active at the time of the control transfer.

A non-local goto may be wrapped in a procedure closure
and passed to a procedure from which the goto target
is not visible.


\begin{minted}{felix}
proc doit (err: 1 -> 0) { e; }

proc outer () {
  proc handler () { goto error; }
  doit (handler);
  return;

  error:> println$ error;
}
\end{minted}

This is a valid way to handle errors.
the code is correct because \verb%outer% is active
at the time that \verb%handler% performs the
control transfer.
\subsection{halt}
Stops the program with a diagnostic.

\begin{minted}{felix}
halt "Program complete";
\end{minted}


\subsection{try/catch/entry}
The try/catch construction may only be user to wrap
calls to C++ primitives, so as to catch exceptions.

\begin{minted}{felix}
proc mythrow 1 = "throw 0;";
try
   mythrow;
catch (x:int) =>
   println$ "Caughht integer " + x.str;
endtry
\end{minted}


\subsection{goto-indirect/label\_address}
The \verb%label-address% operator captures the address
of code at a nominated label. 

The address has type \verb%LABEL% and can be stored in a variable.

Provided the activation record of the procedure containing
the label remains live, a subsequent @{goto-indirect) can
be used to jump to that location.


\begin{minted}{felix}
proc demo (selector:int) {
  var pos : LABEL = 
    if selector == 1 
    then label_address lab1
    else label_address lab2
    endif
  ;
  goto-indirect selector;
lab1:>
  println$ "Lab1"; return;
lab2:>
  println$ "Lab2"; return;
}
\end{minted}


\subsection{Exchange of control}
Built on top of label adressing and indirect gotos,
the \verb%branch-and-link% instruction is conceptually
the most fundamental control instruction. The library
implementation is in 

\begin{minted}{felix}
inline proc branch-and-link (target:&LABEL, save:&LABEL)
{
  save <- label_address next;
  goto-indirect *target;
  next:>
}
\end{minted}

A good example is \href{http://felix-lang.org/share/src/test/regress/rt/coroutines-01.fdoc}{here},
which shows an example of coroutines.

\section{match/endmatch}
The form:

\begin{minted}{felix}
match expr with
| pattern1 => stmts1
| pattern2 => stmts2
...
endmatch
\end{minted}

is an extension of the C switch statement. The patterns
are composed of these forms:

\begin{minted}{felix}
(v1, v2, ... )          // tuple match
h!t                     // list match
h,,t                    // tuple cons
Ctor                      // const union or variant match
Ctor v                   // nonconst union or variant match
(fld1=f1, fld2=f2, ...)  // record match
pat as v                 // assign variable to matched subexpression
pat when expr             // guarded match
pat1 | pat2               // match either pattern
999                       // integer match
"str"                     // string match 
lit1 .. lit2              // range match
_                         // wildcard match
\end{minted}


The guarded match only matches the pattern if the guard expression is true.

\begin{minted}{felix}
match x with
| (x,y) when y != 0 => ...
endmatch
\end{minted}


The tuple as list cons match is a form of row polymorphism
where the first element of a tuple and the remaining elements
considered as a tuple are matched.

A good example of this is found in the library \href{http://felix-lang.org/share/lib/std/datatype/tuple.flx}{here}
which allows printing a tuple of arbitrary number of components, indeed,
this facility was implemented precisely to allow this definition in the library.

Record matches succeed with any record containing a superset
of the specified fields.

As well as integer and string matches, a literal of any type with an
equality and inequality operator can be matched. In addition,
if there is a less than or equal operator \verb%<=% an inclusive
range match can be specified.

\section{if/goto}
The conditional goto is an abbreviation for 
the more verbose conditional:

\begin{minted}{felix}
if c goto lab; // equivalent to
if c do goto lab; done
\end{minted}


\subsection{if/return}
The conditional return is an abbreviation for
the more verbose conditional:

\begin{minted}{felix}
if c return; // equivalent to
if c do return; done
\end{minted}


\subsection{if/call}
The conditional call is an abbreviation for
the more verbose conditional:

\begin{minted}{felix}
if c call f x; // equivalent to
if c do call f x; done
\end{minted}



\section{if/do/elif/else/done}
The procedural conditional branch is used to select
a control path based on a boolean expression.

The \verb%else} and @{elif% clauses are optional.

\begin{minted}{felix}
if c1 do 
  stmt1;
  stmt2;
elif c2 do
  stmt3;
  stmt4;
else
  stmt5;
  stmt6;
done
\end{minted}


The \verb%elif% clause saves writing a nested conditional.
The above is equivalent to:

\begin{minted}{felix}
if c1 do 
  stmt1;
  stmt2;
else 
  if c2 do
    stmt3;
    stmt4;
  else
    stmt5;
    stmt6;
  done
done
\end{minted}

One or more statements may be givn in the selected control path.

A simple conditional is an abbreviation for a statement match:

\begin{minted}{felix}
if c do stmt1; stmt2; else stmt3; stmt4; done
// is equivalent to
match c with
| true => stmt1; stmt2; 
| false => stmt3; stmt4;
endmatch;
\end{minted}


\section{call}
The \verb%call% statement is used to invoke a procedure.

\begin{minted}{felix}
proc p(x:int) { println$ x; }
call p 1;
\end{minted}

The word \verb%call% may be elided in a simple call:

\begin{minted}{felix}
p 1;
\end{minted}

If the argument is of unit type; that is, it is the
empty tuple, then the tuple may also be elided in
a simple call:

\begin{minted}{felix}
proc f() { println$ "Hi"; }
call f (); // is equivalent to
f(); // is equivalent to
f;
\end{minted}


\section{procedure return}
The procedural return is used to return control
from a procedure to its caller.

A return is not required at the end of a procedure
where control would otherwise appear to drop through,
a return is assumed:

\begin{minted}{felix}
proc f() { println$ 1; }
// equivalent to
proc f() { println$ 1; return; }
\end{minted}


\subsection{return from}
The return from statement allows control to be
returned from an enclosing procedure, provided that
procedure is active.

\begin{minted}{felix}
proc outer () {
  proc inner () {
     println$ "Inner";
     return from outer;
  }
  inner;
  println$ "Never executed";
}
\end{minted}


\subsection{jump }
The procedural jump is an abbreviation for 
the more verbose sequence:

\begin{minted}{felix}
jump procedure arg; // is equivalent to
call procedure arg;
return;
\end{minted}


\section{function return}
The functional return statement returns a value from
a function.

\begin{minted}{felix}
fun f () : int = {
  return 1;
}
\end{minted}

Control may not fall through the end of a function.

\subsection{yield}
The yield statement returns a value from a generator
whilst retaining the current location so that execution
may be resumed at the point after the yield.

For this to work a closure of the generator must be stored
in a variable which is subsequently applied.

\begin{minted}{felix}
gen counter () = { 
  var x = 0;
next_integer:>
  yield x;
  ++x;
  goto next_integer;
}

var counter1 = counter;
var zero = counter1 ();
var one = counter1 ();
println$ zero, one;
\end{minted}



\section{{\tt spawn\_fthread}}
\href{http://felix-lang.org/share/lib/std/control/fibres.flx}{Library Reference}

The \verb%spawn_fthread% library function invokes the corresponding
service call to schedule the initial continuation of a procedure 
taking a unit argument as an fthread (fibre). 

The spawned fthread begins executing immediately.
If coutrol returns before yielding by a synchronous
channel operation, the action is equivalent to calling
the procedure.

Otherwise the spawned fthread is suspended when the first
write, or the first unmatched read operation occurs.


\subsection{read/write/broadcast schannel}
\href{http://felix-lang.org/share/lib/std/control/schannels.flx}{Library Reference}

\section{{\tt spawn\_pthread}}
\href{http://felix-lang.org/share/lib/std/control/pthread.flx}{Library Reference}

\subsection{read/write pchannel}
\href{http://felix-lang.org/share/lib/std/control/pchannels.flx}{Library Reference}

\subsection{exchange}

\section{loops}
\href{http://felix-lang.org/share/lib/grammar/loops.fsyn}{Library Reference}

Felix has some low level and high level loop constructions.

The low level for, while, and repeat loops are equivalent
to loops implemented with gotos.

The bodies of do loops do not constitute a scope,
therefore any symbol defined in such a body is also visible
in the surrounding code.

Low level loops may be labelled with a loop label
which is used to allow break, continue, and redo
statements to exit from any containing loop.


\begin{minted}{felix}
outer:for var i in 0 upto 9 do
   inner: for var j in 0 upto 9 do
     println$ i,j;
     if i == j do break inner; done
     if i * j > 60 do break outer; done
   done
done
\end{minted}


\subsection{redo}
The redo statement causes control to jump to the start
of the specified loop without incrementing the control variable.

\subsection{break}
The break statement causes control to jump past the end of
the specified loop, terminating iteration.

\subsection{continue}
The continue statement causes the control variable to
be incremented and tests and the next iteration commenced
or the loop terminated.

\subsection{for/in/upto/downto/do/done}
A basic loop with an inclusive range.

\begin{minted}{felix}
// up
for var ti:int in 0 upto 9 do println$ ti; done
for var i in 0 upto 9 do println$ i; done
for i in  0 upto 9 do println$ i; done

// down
for var tj:int in 9 downto 0 do println$ j; done
for var j in 9 downto 0 do println$ j; done
for j in  0 upto 9 do println$ j; done
\end{minted}

The start and end expressions must be of the same type.

If the control variable is defined in the loop with a type
annotation, that type must agree with the control variable.

The type must support comparison with the equality operator \verb%==%
the less than or equals operator \verb%<=% and increment with 
the pre increment procedure \verb%++%.

For loops over unsigned types cannot handle the empty case.
For loops over signed types cannot span the whole range of the type.

The loop logic takes care to ensure the control variable is not
incremented (resp. decremented) past the end (resp.start) value.

\subsection{while/do/done}
The while loop executes the body repeatedly whilst the control
condition is true at the start of the loop body.

\begin{minted}{felix}
var i = 0;
while i < 10 do println$ i; ++i; done
\end{minted}


\subsection{until loop}
The until loop executes the loop body repeatedly
until the control condition is false at the start of the loop,
it is equivalent o a while loop with a negated condition.

\begin{minted}{felix}
var i = 0;
until i == 9 do println$ i; ++i; done
\end{minted}


\subsection{for/match/done}
TBD
\subsection{loop}
TBD
\section{Assertions}
\href{http://felix-lang.org/share/lib/grammar/assertions.fsyn}{Library Reference}
\section{assert}
Ad hoc assertion throws an assertion exception if its argument
is false. 

\begin{minted}{felix}
assert x > 0;
\end{minted}


\subsection{axiom}
An axiom is a relationship between functions, typically
polymorphic, which is required to hold.

\begin{minted}{felix}
axiom squares (x:double) => x * x >= 0;
class addition[T]
{
  virtual add : T * T -> T;
  virtual == : T * T -> bool;

  axiom assoc (x:T, y:T, z:T) : 
    add (add (x,y),z) == add (x, add (y,z))
  ;
}
\end{minted}

In a class, an axiom is a specification constraining
implementations of virtual function in instances.

Axioms are restricted to first order logic, that is, they
may be polymorphic, but the universal quantification implied
is always at the head.

Existential quantification can be provided in a constructive
logic by actually constructing the requisite variable.

Second order logic, with quantifiers internal to the 
logic term, are not supported.

\subsection{lemma}
A lemma is similar to an axiom, except that is it
easily derivable from axioms; in particular,
a reasonable automatic theorem prover should
be able to derived it.

\subsection{theorem}
A theorem is similar to a lemma, except that it is 
too hard to expect an automatic theorem prover
to be able to derive it without hints or assistance.

There is currently no standard way to prove such hints.

\subsection{reduce}
A reduce statement specifies a term reduction and is logically
equivalent to an axiom, lemma, or theorem, however it acts
as an instruction to the compiler to attempt to actually 
apply the axiom.

The compiler may apply the axiom, but it may miss opportunities
for application.

The set of reductions must be coherent and terminal, 
that is, after a finite number of reductions the final
term must be unique and irreducible. 

Application of reduction is extremely expensive and they
should be used lightly.

\begin{minted}{felix}
reduce revrev[T] (x: list[T]) : rev (rev x) => x;
\end{minted}



\subsection{invariant}
An invariant is an assertion which must hold on the state variables
of an object, at the point after construction of the state
is completed by the constructor function and just before the
record of method closures is returned, and, at the start and
end of every method invocation.

The invariant need not hold during execution of a method.

Felix inserts the a check on the invariant into the constructor function
and into the post conditions of every procedure or generator
method.


\begin{minted}{felix}
object f(var x:int, var y:int) =
{
   invariant y >= 0;
   method proc set_y (newy: int) => y = newy;
}
\end{minted}


\section{code}
The code statement inserts C++ code literally into the current
Felix code.

The code must be one or more C++ statements.


\begin{minted}{felix}
code 'cout << "hello";';
\end{minted}


\subsection{noreturn code}
Similar to code, however noreturn code never returns.

\begin{minted}{felix}
noreturn code "throw 1;";
\end{minted}


\section{Service call}
The service call statement calls the Felix system kernel
to perform a specified operation.

It is equivalent to an OS kernel call.

The available operations include:

\begin{minted}{felix}
  union svc_req_t =
  /*0*/ | svc_yield
  /*1*/ | svc_get_fthread         of &fthread    // CHANGED LAYOUT
  /*2*/ | svc_read                of address
  /*3*/ | svc_general             of &address    // CHANGED LAYOUT
  /*4*/ | svc_reserved1
  /*5*/ | svc_spawn_pthread       of fthread
  /*6*/ | svc_spawn_detached      of fthread
  /*7*/ | svc_sread               of _schannel * &gcaddress
  /*8*/ | svc_swrite              of _schannel * &gcaddress
  /*9*/ | svc_kill                of fthread
  /*10*/ | svc_reserved2
  /*11*/ | svc_multi_swrite       of _schannel * &gcaddress 
  /*12*/ | svc_schedule_detached  of fthread
  ;
\end{minted}


These operations are typically related to coroutine or thread scheduling.
However \verb%svc_general% is an unspecified operation, which is typically
used to invoke the asynchronous I/O subsystem.

Service calls can only be issued from flat code, that is,
from procedures, since they call the system by returning
control, the system must reside exactly one return address
up the machine stack at the point a service call is executed.

\section{with/do/done}
The with/do/done statement is use to define temporary variables
which are accessible only in the do/done body of the statement.

It is the statement equivalent of the let expression.

\begin{minted}{felix}
var x = 1;
with var x = 2; do println$ x; done
assert x == 1;
\end{minted}


\section{do/done}
The do/done statement has no semantics and merely acts as a
way to make a sequence of statements appear as a single
statement to the parser.

Jumps into do/done groups are therefore allowed, and
any labels defined in a do/done group are visible in
the enclosing context.

Any variables, functions, or other symbols defined in a do/done
group are visible in the enclosing context.

\begin{minted}{felix}
do something; done
\end{minted}


\section{begin/end}
The begin/end statement creates an anonymous procedure
and then calls it. It therefore appears as a single statement
to the parser, but it simulates a block as would be used in C.
It is exactly equivalent to a brace enclosed procedure called
by a terminating semi-colon.

\begin{minted}{felix}
begin
  var x = 1;
end
// equivalent to
{
  var x = 1;
};
\end{minted}


\part{Expressions}
\href{http://felix-lang.org/share/lib/grammar/expressions.fsyn}{Syntax}

Expressions are listed in approximate order of precedence,
starting with the weakest binding.

We will often exhibit expressions in the form

\begin{minted}{felix}
var x = expr;
\end{minted}

so as to present a complete statement. The \verb%x% is of no significance.
\section{Chain forms}
\subsection{Pattern let}
The traditional let binding of ML.
The syntax is 

\begin{minted}{felix}
var x = let pattern = expr1 in expr2; // equivalent to
var x = match expr1 with pattern => expr2 endmatch
\end{minted}

\begin{minted}{felix}
var x = let a = 1 in a + 1; // equivalent to
var x = match 1 with a => a + 1 endmatch
\end{minted}


\subsection{Function let}
A let form which makes a function available in the
expression

\begin{minted}{felix}
var x = 
  let fun f(y:int)=> y + 1 in 
  f 42
;
\end{minted}

\subsection{Match chain}
A variant on the terminated match which allows a second
match to be chained onto the last branch without any endmatch.

\begin{minted}{felix}
var y = list (1,2);
var x = 
  match y with
  | #Empty => "Empty"
  | _ =>
  match y with 
  | h ! Empty => h.str
  | _ =>
  match y with 
  | h1 ! h2 ! Empty => h1.str + "," + h2.str
;

println$ x;
\end{minted}

\subsection{conditional chain}
A variant on the terminated if/then/elif/else allowing chaining.

\begin{minted}{felix}
var x = 
  if c1 then r1 
  elif c2 then r2 else
  if c3 then r3 else
  r4
;
\end{minted}


\section{Alternate conditional chain}

\begin{minted}{felix}
var x = n / d unless d == 0 then 0;
\end{minted}


\section{Dollar application}
A right associative low precedence forward apply operator taken
from Haskell.

\begin{minted}{felix}
var x =  str$ rev$ list$ 1,2,3;
\end{minted}



\section{Pipe application}
A left associative low precedence reverse apply operator taken
from \verb%C#%.

\begin{minted}{felix}
var x =  1,2,3 |> list |> rev |> str;
\end{minted}


\section{Tuple cons constructor}
A right associative cons operator for tuples. Allows concatenating
an element to the head/front/left end of a tuple. Can also be used
in a pattern match to recursively decode a tuple like a list.

\begin{minted}{felix}
var x =  3,4;
var y = 1 ,, 2 ,, x; // 1,2,3,4
\end{minted}


\section{N-ary tuple constructor}
The is a non-associative n-ary tuple constructor
consists of a sequence of expressions separated by commas.

\begin{minted}{felix}
var x = 1,2,3,4;
\end{minted}


\section{Logical implication}
An operator for function \verb%implies%.

\begin{minted}{felix}
var x = false implies true;
\end{minted}


\section{Logical disjunction}
A chaining operator for function \verb%lor%.

\begin{minted}{felix}
var x = true or false;
\end{minted}

 
\section{Logical conjunction}
A chaining operator for function \verb%land%.

\begin{minted}{felix}
var x = true and false;
\end{minted}


\section{Logical negation}
A bool operator for function \verb%lnot%.

\section{Comparisons}
Non-associative.

\begin{minted}{felix}
var x =
  a < b or 
  a > b or
  a <= b or
  a >= b or
  a == b or
  a != b or
  1 in list(1,2,3)
  1 \in list (1,2,3)
;
\end{minted}


\section{Name temporary}
Allows a subexpression to be named as a \verb%val% by default
or a \verb%var%.

\begin{minted}{felix}
var x = a +  (f y as z) + z; // equivalent to
val z = f y; var x = a + z + z;

var x = a +  (f y as var k) + k; // equivalent to
var k = f y; var x = a + k + k;
\end{minted}

Note that the \verb%var% for ensures the subexpression is eagerly
evaluated, before the containing expression.

\section{Schannel pipe operators}
Used to flow data through schannels from the source on the 
left to the sink on the right via processing units in between.

\begin{minted}{felix}
spawn_fthread$ source |-> filter |-> enhancer |-> sink;
\end{minted}


This variant uses an iterator to stream data out of a data structure:

\begin{minted}{felix}
spawn_fthread$ list (1,2,3) >-> sink;
\end{minted}


\section{Right Arrows}
Right associative arrow operators.

List cons operator.

\begin{minted}{felix}
var x = 1 ! 2 ! list (3,4);
\end{minted}


Function types (type language only):

\begin{minted}{felix}
  D -> C // Felix function
  D --> C // C function pointer
\end{minted}


\section{Case literals}

The case tag is only used in pattern matches.
The sum or union type isn't required because it can be deduced
from the match argument.

\begin{minted}{felix}
var a = match a with Some v  => v | #None => 0;
\end{minted}


The case constructor with integer caseno has two uses. 

It creates a value of
a sum type with no arguments:

\begin{minted}{felix}
var x = case 1 of 2; // aka true
\end{minted}

or it is a function for a sum type variant with an argument:

\begin{minted}{felix}
var x = (case 1 of int + double) 4.2;
\end{minted}


A case literal with a name instead of an integer constructs
a variant instead:

\begin{minted}{felix}
typedef maybe = union { No; Yes of int; };
var x = (case Yes of maybe) 42;
\end{minted}


The tuple projection function names a tuple projection:

\begin{minted}{felix}
typedef triple = int * long * string;
var snd = proj 1 of triple;
var y: int = snd (1, 2L, "3");
\end{minted}


\section{Bitwise or}
Left associative.

\begin{minted}{felix}
var x = q \| b;
\end{minted}


\section{Bitwise exclusive or}
Left associative.

\begin{minted}{felix}
var x = q \^ b;
\end{minted}


\section{Bitwise and}
Left associative.

\begin{minted}{felix}
var x = q \& b;
\end{minted}


\section{Bitwise shifts}
Left associative.

\begin{minted}{felix}
var x = a << b; // left shift
var x = a >> b; // right shift
\end{minted}


\section{Addition}
Chain operator. Non-associative for types. 
Left associative for expressions.

\begin{minted}{felix}
var x = a + b + c;
\end{minted}


\section{Subtraction}
Left associative.

\begin{minted}{felix}
var x = a - b;
\end{minted}


\section{Multiplication}
Chain operator. Non-associative for types.
Left associative for expressions.

\begin{minted}{felix}
var x = a * b;
\end{minted}


\section{Division operators}
Left associative. Not carefully: higher precedence
that multiplication, unlike C!!

\begin{minted}{felix}
var x = a * b / c * d; // means
var x = a * (b / c) * d;

var x = a * b % c * d; // means
var x = a * (b % c) * d;
\end{minted}


\section{Prefix operators}

\begin{minted}{felix}
var x = !a;
var x = -a; // negation
var x = ~a; // bitwise complement
\end{minted}


\section{Fortran exponentiation}
Infix \verb%**} is special syntax for function @{pow%. 
The left operand binds more tightly than \verb%**%
but the right operand binds as for prefixed operators
or more tightly. Observe than that:


\begin{minted}{felix}
var x = -a**-b;  // means
var x = -(a**(-b));
\end{minted}

preserving the usual mathematical syntax. 

\section{Felix exponentiation}
Left associative. The right operand binds as deref operator
or more tightly. Used for array notation in the type language.

\begin{minted}{felix}
var x = a ^ ix;
\end{minted}


\section{Function composition}
Standard math notation. Left associative. Same precedence as
exponentiation. Spelled \verb%\}@{circ%.

\begin{minted}{felix}
var x = f \circ g;
\end{minted}


\section{Dereference}
For function \verb%deref%.

\begin{minted}{felix}
var x = *p;
\end{minted}


For builtin dereference operator:

\begin{minted}{felix}
var x = _deref p;
\end{minted}


Note these usually have the same meaning however
the function \verb%deref% can be overloaded. If the overloaded
definition is not to be circular it may use \verb%_deref%
when dereferencing pointers.

\subsection{Operator new}
Copies a value onto the heap and returns a pointer.

\begin{minted}{felix}
var px = new 42;
\end{minted}


\section{Whitespace application}
Operator whitespace is used for applications.
\subsection{General}

\begin{minted}{felix}
var x = sin y;
\end{minted}


\subsection{Caseno operator}
Returns the integer tag value of the value of an anonymous sum, 
union, or variant  type.

\begin{minted}{felix}
var x = caseno true; // 1
var x = caseno (Some 43); // 1
\end{minted}


\subsection{Likelyhood}
Indicaties if a bool valued expression is likely
or unlikely to be true. Used to generate the corresponding
gcc optimisation hints, if available.

\begin{minted}{felix}
if likely (c) goto restart;
if unlikely (d) goto loopend;
\end{minted}


\section{Coercion operator}
left associative. The right operand is a type.

\begin{minted}{felix}
var x = 1L :>> int; // cast
\end{minted}


\section{Suffixed name}
The most general form of a name:

\begin{minted}{felix}
var x = qualified::name of int;
\end{minted}

Used to name functions, with the right operand specifying
the function argument type.

\section{Factors}
\subsection{Subscript}
Used for array and string subscripting. Calls function \verb%subscript%.
For strings, returns a character. If the subscript is out of range
after adjustment of negative index, returns \verb%char 0% and thus
cannot fail.

\begin{minted}{felix}
var x = a . [ i ]; // i'th element
\end{minted}


\subsection{Subsstring}
Calls function \verb%substring%. Negative indices may be used to
offset from end, i.e. -1 is the index of the last element.
Out of range indices (past the end or before the start, after
adjustment of negative indices) are clipped back to the end
or start respectively.

\begin{minted}{felix}
var x = a . [ first to past]; 
  // past is one past the last element refered to
\end{minted}


\subsection{Copyfrom}
Calls function \verb%copyfrom%. Copies from designated index to end.
Supports negative indices and range clipping for strings.

\begin{minted}{felix}
var x = a . [to past]; // from the first
\end{minted}


\subsection{Copyto}
Calls function \verb%copyto%. Supports negative indices and
range clipping for strings.

\begin{minted}{felix}
var x = a . [to past]; // from the first
\end{minted}


\subsection{Reverse application}
Left associative.

\begin{minted}{felix}
var x = y .f; // means
var x = f y;
\end{minted}


\subsection{Reverse application with deref}
Left associative

\begin{minted}{felix}
var x = p *. k; // means
var x = (*p) . k;
\end{minted}


\subsection{Reverse application with addressing}
Left associative

\begin{minted}{felix}
var x = v &. k; // means
var x = (&v) . k;
\end{minted}


\subsection{Unit application}
Prefix operator applies argument to empty tuple.

\begin{minted}{felix}
var x = #f; // means
var x = f ();
\end{minted}


\subsection{Addressing}
Finds the pointer address of a variable.
Means pointer to in type language.

\begin{minted}{felix}
var x : int = 1;
var px : &int = &x; 
  // address of x
  // type pointer to int
\end{minted}


\subsection{C pointer}
Used in type language for pointer to type or NULL.

\begin{minted}{felix}
var px : @char =  malloc (42);
\end{minted}


Note that this symbol is also used in fdoc as a markup
indicator. Please keep out of column 1, do not follow
with a left brace.

\subsection{Label address}
Used to find the machine address in the code text of
a label. Used with computed goto instruction.

\begin{minted}{felix}
proc f (a: int) {
  var target: LABEL = 
    if a < 0 then label_address neg
    elif a > 0 then label_address pos
    else label_address zer
  ;
  goto-indirect target;
  pos:> println$ "pos"; return;
  neg:> println$ "neg"; return;
  zer:> println$ "zer"; return;
}
\end{minted}


\subsection{Macro freezer}
Used to disable macro expansion of a symbol.

\begin{minted}{felix}
macro val fred = joe;
var x = fred + noexpand fred; // means
var x = joe + fred;
\end{minted}


\subsection{Pattern variable}
Notation \verb%v% Used in patterns to designate a val variable
to be bound in the pattern matching.

\begin{minted}{felix}
var x = 
  match y with 
  | Some v => "Some " + v.str 
  | #None => "None";
;
\end{minted}


\subsection{Parser argument}
Notation \verb%n} for some integer @{n%. In user defined syntax designates
the n'th term of a syntax production.

\section{Qualified name}
A name in Felix has the form:

\begin{minted}{felix}
  class1 :: nested1 :: ... :: identifier [ type1, type2, ... ]
\end{minted}

where the qualifiers and/or type list may be elided. 
This is the same as C++ except we use \verb%[]} instead of @{<>%
for template argument types.

\chapter{Atoms}
\section{Record expression}

\begin{minted}{felix}
var x = (name="Hello", age=42);
\end{minted}


\section{Alternate record expression}

\begin{minted}{felix}
var x = 
  struct {
    var name = "Hello";
    var age = 42;
  }
;
\end{minted}


\section{Variant type}
Denotes a variant type.

\begin{minted}{felix}
var x : 
  union {
    Cart of double * double;
    Polar of double * double;
  }
;
\end{minted}


\section{Wildcard pattern}
Used in a pattern match, matches anything.

\begin{minted}{felix}
  var x = match a with _ => "anything";
\end{minted}


\section{Ellipsis}
Used only in C bindings to denote varags.

\begin{minted}{felix}
  fun f: int * ... -> int;
\end{minted}


\section{Truth constants}

\begin{minted}{felix}
  false // alias for case 0 of 2
  true  // alias for case 1 of 2
\end{minted}


\section{callback expression}
??

\begin{minted}{felix}
callback [ x ]
\end{minted}


\section{Lazy expression}
Function of unit.

\begin{minted}{felix}
var f = { expr };
var x = f ();
\end{minted}


\section{Sequencing}
Function dependent on final expression.

\begin{minted}{felix}
var x = ( var y = 1; var z = y + y; z + 1 ); // equivalent to
var x = #{ var y = 1; var z = y + y; return z + 1; };
\end{minted}


\section{Procedure of unit.}

\begin{minted}{felix}
var p = { println$ "Hello"; } // procedure
p (); 

var f = { var y = 1; return y + y; }; // function
var x = f ();
\end{minted}


\section{Grouping}
Parentheses are used for grouping.

\begin{minted}{felix}
var x = (1 + 2) * 3;
\end{minted}


\section{Object extension}

\begin{minted}{felix}
var x = extend a,b with c end;
\end{minted}


\section{Conditional expression}

\begin{minted}{felix}
var x =
  if c1 then a elif c2 then b else c endif
;
\end{minted}


\part{Library}
\chapter{C bindings}
Felix is specifically designed to provide almost seamless integration
with C and C++.

In particular, Felix and C++ can share types and functions,
typically without executable glue.

However Felix has a stronger and stricter type system than C++
and a much better syntax, so binding specifications which lift
C++ entities into Felix typically require some static glue.

\section{Type bindings}
In general, Felix requires all primitive types to be first class,
that is, they must be default initialisable, copy constructible,
assignable, and destructible. Assignment to a default initialised
variable must have the same semantics as copy construction.

It is recommended C++ objects provide move constructors as
Felix generated code uses pass by value extensively.

The Felix type system does not support C++ references in general,
you should use pointers instead. 

However, there is a special lvalue annotation for C++ functions
returning lvalues that allows them to appear on the LHS of
an assignment. Only primitives can be marked lvalue.

The Felix type system does not support either const or volatile.
This has no impact when passing arguments to C++ functions.
However it may be necessary to cast a pointer returned from
a primitive function in order for the generated code to type check.



\section{Expression bindings}
TBD
\section{Function bindings}
TBD
\section{Floating insertions}
TBD
\section{Package requirements}
TBD


% =====================================
\chapter{Core Primitive Types}

\section{Boolean type}
The type \verb%bool% which is also called \verb%2% provides the
usual boolean logic values \verb%false% and \verb%true%. 
The name \verb%bool% is actually an alias for type %2% the
unitsum of two cases. The name \verb%false% is an alternate
name of the value \verb%case 0 of 2% and the name \verb%true%
is an alternate name for the value \verb%case 1 of 2%.

See \fullref{Unit sum} for more information.

\section{Integer types}
\href{http://felix-lang.org/share/lib/std/scalar/ctypedefs.flx}{Library Reference}

There is a table of the types \fullref{Integer Types}.

\begin{table}
\caption{Felix Integer Types\label{Integer Types}}
\centering
\begin{tabular}[c]{lll}
\hline
Felix&C&Suffix\\
\hline
\multicolumn{3}{c}{Standard signed integers}\\
\hline
\verb%tiny% &\verb%char% & t \\
\verb%short% &\verb%short% & s \\
\verb%int% &\verb%int% &  \\
\verb%long% &\verb%long% & l \\
\verb%vlong% &\verb%long long% & ll \\
\multicolumn{3}{c}{Standard unsigned integers}\\
\hline
\verb%utiny% &\verb%unsigned char% & ut \\
\verb%ushort% &\verb%unsigned short% & us \\
\verb%uint% &\verb%unsigned int% & u \\
\verb%ulong% &\verb%unsigned long% & ul \\
\verb%uvlong% &\verb%unsigned long long% & ull \\
\multicolumn{3}{c}{Exact signed integers}\\
\hline
\verb%int8% &\verb%int8_t% & i8 \\
\verb%int16% &\verb%int16_t% & i16 \\
\verb%int32% &\verb%int32_t% & i32 \\
\verb%int64% &\verb%int64_t% & i64 \\
\multicolumn{3}{c}{Exact unsigned integers}\\
\hline
\verb%uint8% &\verb%uint8_t% & u8 \\
\verb%uint16% &\verb%uint16_t% & u16 \\
\verb%uint32% &\verb%uint32_t% & u32 \\
\verb%uint64% &\verb%uint64_t% & u64 \\
\multicolumn{3}{c}{Weird ones}\\
\hline
\verb%size% &\verb%size_t% & uz \\
\verb%intptr% &\verb%uintptr_t% & p \\
\verb%uintptr% &\verb%uintptr_t% & up \\
\verb%ptrdiff% &\verb%ptrdiff_t% & d \\
\verb%uptrdiff% &\verb%ptrdiff_t% & ud \\
\verb%intmax% &\verb%intmax_t% & j\\
\verb%uintmax% &\verb%uintmax_t% & uj \\
\multicolumn{3}{c}{Addressing}\\
\hline
\verb%address% &\verb%void*% &\\
\verb%byte% &\verb%unsigned char% &\\
\end{tabular}
\end{table}


Note that all these types are distinct unlike C and C++.
The types designated are not the complete set of available
integer like types since not all have literal representations.

Signed integers are expected to be two's complement with one
more negative value that positive value. Bitwise and,
or, exclusive or, and complement operations do not apply
with signed types.

The effect of overflow on signed types is unspecified.

Unsigned types use the standard representation. 
Bitwise operations may be applied to unsigned types.
Basic arithmetic operations on unsigned types are
all well defined as the result of the operation
mathematically modulo the maximum value of the type
plus one.

The maximum value of an unsigned type is one less than
two raised to the power of the number of bits in the type.
The number of bits is 8, 16, 32, or 64 or 128 for all unsigned types.

There is a table of the operators \fullref{Integer Operators}.

\begin{table}
\caption{Integer Operators\label{Integer Operators}}
\centering
\begin{tabular}[c]{llll}
\hline
symbol&kind&type&semantics\\
\hline
\multicolumn{4}{c}{All Integers}\\
\hline
\verb%==%&infix-nassoc&\verb%T * T -> bool%&equality\\
\verb%!=%&infix-nassoc&\verb%T * T -> bool%&inequality\\
\verb%<%&infix-nassoc&\verb%T * T -> bool%&less\\
\verb%<=%&infix-nassoc&\verb%T * T -> bool%&less or equal\\
\verb%>%&infix-nassoc&\verb%T * T -> bool%&greater\\
\verb%>=%&infix-nassoc&\verb%T * T -> bool%&greater or equal\\
\verb%+%&infix-lassoc&\verb%T * T -> T%&addition\\
\verb%-%&infix-lassoc&\verb%T * T -> T%&subtraction\\
\verb%*%&infix-lassoc&\verb%T * T -> T%&multiplication\\
\verb%/%&infix-lassoc&\verb%T * T -> T%&quotient\\
\verb+%+&infix-lassoc&\verb%T * T -> T%&remainder\\
\verb%<<%&infix-lassoc&\verb%T * T -> T%&multiplication by power of 2\\
\verb%>>%&infix-lassoc&\verb%T * T -> T%&division by power of 2\\
\verb%-%&prefix&\verb%T -> T%&negation\\
\verb%+%&prefix&\verb%T -> T%&no op\\
\hline
\verb%succ%&func&\verb%T -> T%&successor\\
\verb%pred%&func&\verb%T -> T%&predecessor\\
\multicolumn{4}{c}{Signed Integers}\\
\hline
\verb%sgn%&func&\verb%T -> T%&sign\\
\verb%abs%&func&\verb%T -> T%&absolute value\\
\multicolumn{4}{c}{Unsigned Integers}\\
\hline
\verb%\&%&infix-lassoc&\verb%T * T -> T%&bitwise and\\
\verb%\|%&infix-lassoc&\verb%T * T -> T%&bitwise or\\
\verb%\^%&infix-lassoc&\verb%T * T -> T%&bitwise exclusive or\\
\verb%~%&prefix&\verb%T * T -> T%&bitwise complement\\
\hline
\multicolumn{4}{l}{nassoc: non-associative}\\
\multicolumn{4}{l}{lassoc: left associative}\\
\multicolumn{4}{l}{func: function}\\
\multicolumn{4}{l}{note prefix {\tt -} maps to function {\tt neg}}\\
\hline
\end{tabular}
\end{table}

\subsection{Classification of integers}
\href{http://felix-lang.org/share/lib/std/scalar/ctypedefs.flx}{Library Reference}

Integer types can be grouped into sets. In Felix this can be
done with a \verb%typeset% construction. The defined typesets
are show in \fullref{Integer Typesets}. 

Fast integers correspond to the usual C distinct integer types.

Exact integers are aliases to fast integers of specified sizes,
in Felix these are distinct types.

The weird integers are special purposes aliases to fast integers
which have special uses, again in Felix these are distinct types.
\begin{itemize}
\item The type \verb%ptrdiff% is a signed type intended to represent
the difference between two pointers. 
\item The \verb%size% type is
for measuring the sizes of objects and number of elements
in an array.
\item  The \verb%intmax% and \verb%uintmax% types are
the largest available signed and unsigned integer types,
respectively. 
\item Finally the \verb%intptr% and \verb%uintptr%
types are the same size as a pointer and can be used for
low level numerical operations on pointers either by 
a conversion or reinterpret cast. They're typically used
for to pack extra data into the low bits of a pointer
to a type with an alignment which ensures the low bits
of the pointer are zero.
\end{itemize}

\begin{table}
\caption{Integer Typesets\label{Integer Typesets}}
\centering
\begin{tabular}[c]{ll}
\hline
fast\_sints &(tiny, short, int, long, vlong)\\
exact\_sints &(int8,int16,int32,int64)\\
fast\_uints &(utiny, ushort, uint, ulong,uvlong)\\
exact\_uints &(uint8,uint16,uint32,uint64)\\
weird\_sints &(ptrdiff, ssize, intmax, intptr)\\
weird\_uints &(size, uintmax, uintptr)\\
sints &fast\_sints $\cup$ exact\_sints $\cup$ weird\_sints\\
uints & fast\_uints $\cup$ exact\_uints $\cup$ weird\_uints\\
fast\_ints & fast\_sints $\cup$ fast\_uints\\
exact\_ints & exact\_sints $\cup$ exact\_uints\\
ints & sints $\cup$ uints\\
\hline
\end{tabular}
\end{table}

Typesets can be used to simplify specification of C function bindings
by leveraging constrained polymorphism.

\begin{minted}{felix}
fun add[T in ints]: T * T -> T = "$1+$2";

// or equivalently
fun add[T : ints]: T * T -> T = "$1+$2";
\end{minted}

A special form which implies a quantifer for every use
also exists,  by specifying a \verb%!% followed by
a typeset name. For example,

\begin{minted}{felix}
fun intsum: !ints * !ints -> long = "(long)($1+$2)";

// or equivalently
fun intsum[T:ints, U:ints] : T * U -> long = "(long)($1+$2)";
\end{minted}

Note \verb%intsum% can add any different kinds of integers,
returning a \verb%long%.

Polymorphism with typeset constraints is {\em only} 
useful for C bindings because the constraints are not
propagated. It simply saves writing out all the finite
combinations when genericity in the C or C++ target
code means the C code would be the same in each case.

\section{Floating point types}
\href{http://felix-lang.org/share/lib/std/scalar/float\_math.flx}{Library Reference}

There is a table of the operators \fullref{Floating Operators},
we also have \fullref{Trig functions}.

Felix also provides \verb%FINFINITY%, \verb%DINFINITY% and \verb%LINFINITY%
for positive infinity representation for \verb%float%, \verb%double%
and \verb%ldouble% types, respectively.

\begin{table}
\caption{Trig functions\label{Trig functions}}
\centering
\begin{tabular}[c]{lll}
\hline
symbol&type&semantics\\
\hline
\multicolumn{3}{c}{circular}\\
\verb%sin%&\verb%T -> T%&sine\\
\verb%cos%&\verb%T -> T%&cosine \\
\verb%tan%&\verb%T -> T%&tangent\\
\verb%asin%&\verb%T -> T%&arc (inverse) sine\\
\verb%acos%&\verb%T -> T%&arc (inverse) cosine\\
\verb%atan%&\verb%T -> T%&arc (inverse) tangent\\
\multicolumn{3}{c}{hyperbolic}\\
\hline
\verb%sinh%&\verb%T -> T%&hyperbolic sine\\
\verb%cosh%&\verb%T -> T%&hyperbolc cosine\\
\verb%tanh%&\verb%T -> T%&hyperbolic tangent\\
\verb%asinh%&\verb%T -> T%&arc (inverse) hyperbolic sine\\
\verb%acosh%&\verb%T -> T%&arc (inverse) hyperbolic cosine\\
\verb%atanh%&\verb%T -> T%&arc (inverse) hyperbolic tangent\\
\hline
\multicolumn{3}{l}{Note: Inverses return primary branch}\\
\hline
\end{tabular}
\end{table}


\begin{table}
\caption{Floating Point Operators\label{Floating Operators}}
\centering
\begin{tabular}[c]{llll}
\hline
symbol&kind&type&semantics\\
\hline
\hline
\verb%==%&infix-nassoc&\verb%T * T -> bool%&equality\\
\verb%!=%&infix-nassoc&\verb%T * T -> bool%&inequality\\
\hline
\verb%<%&infix-nassoc&\verb%T * T -> bool%&less\\
\verb%<=%&infix-nassoc&\verb%T * T -> bool%&less or equal\\
\verb%>%&infix-nassoc&\verb%T * T -> bool%&greater\\
\verb%>=%&infix-nassoc&\verb%T * T -> bool%&greater or equal\\
\hline
\verb%+%&infix-nassoc&\verb%T * T -> T%&addition\\
\hline
\verb%-%&infix-nassoc&\verb%T * T -> T%&subtraction\\
\hline
\verb%*%&infix-nassoc&\verb%T * T -> T%&multiplication\\
\hline
\verb%/%&infix-nassoc&\verb%T * T -> T%&quotient\\
\hline
\verb%-%&prefix&\verb%T -> T%&negation\\
\hline
\verb%abs%&func&\verb%T->T%&absolute value\\
\verb%log10%&func&\verb%T->T%&base 10 logarithm\\
\verb%sqrt%&func&\verb%T->T%&square root\\
\verb%ceil%&func&\verb%T->T%&ceiling\\
\verb%floor%&func&\verb%T->T%&floor\\
\verb%trunc%&func&\verb%T->T%&truncate\\
\verb%embed%&func&\verb%int->T%&embedding\\
\hline
%\verb%exp&func&\verb%T -> T%&natural exponential\\
%\verb%log&func&\verb%T -> T%&natural logarithm\\
%\verb%pow&func&\verb%T * T -> T%&power\\
\hline
\multicolumn{4}{l}{nassoc: non-associative}\\
\multicolumn{4}{l}{lassoc: left associative}\\
\multicolumn{4}{l}{func: function}\\
\multicolumn{4}{l}{note prefix {\tt -} maps to function {\tt neg}}\\
\hline
\end{tabular}
\end{table}

\section{Complex types}

There are three complex types, \verb%fcomplex%, \verb%dcomplex%
and \verb%lcomplex% corresponding to cartesian representation
using a pair of \verb%float%, \verb%double% and \verb%ldouble%
values, respectively.

There is a table of the operators \fullref{Complex Operators},
we also have \fullref{Trig functions}.

\begin{table}
\caption{Complex Operators}
\label{Complex Operators}
\centering
\begin{tabular}[c]{llll}
\hline
symbol&kind&type&semantics\\
\hline
\hline
\verb%fcomplex%&ctor&\verb%float * float -> fcomplex%&cartesian\\
\verb%fcomplex%&ctor&\verb%float -> fcomplex%&from real\\
\verb%dcomplex%&ctor&\verb%double * double -> dcomplex%&cartesian\\
\verb%dcomplex%&ctor&\verb%double -> dcomplex%&from real\\
\verb%lcomplex%&ctor&\verb%ldouble * ldouble -> lcomplex%&cartesian\\
\verb%lcomplex%&ctor&\verb%ldouble -> lcomplex%&from real\\
\verb%==%&infix-nassoc&\verb%T * T -> bool%&equality\\
\verb%!=%&infix-nassoc&\verb%T * T -> bool%&inequality\\
\hline
\verb%+%&infix-lassoc&\verb%T * T -> T%&addition\\
\hline
\verb%-%&infix-lassoc&\verb%T * T -> T%&subtraction\\
\hline
\verb%*%&infix-lassoc&\verb%T * T -> T%&multiplication\\
\hline
\verb%/%&infix-lassoc&\verb%T * T -> T%&quotient\\
\hline
\verb%-%&prefix&\verb%T -> T%&negation\\
\hline
\verb%real%&func&\verb%T->R%&real part\\
\verb%imag%&func&\verb%T->R%&imaginary part\\
\verb%abs%&func&\verb%T->R%&norm\\
\verb%arg%&func&\verb%T->R%&argument\\
\hline
%\verb%exp&func&\verb%T -> T%&natural exponential\\
%\verb%log&func&\verb%T -> T%&natural logarithm\\
%\verb%pow&func&\verb%T * T -> T%&power\\
\hline
\multicolumn{4}{l}{nassoc: non-associative}\\
\multicolumn{4}{l}{lassoc: left associative}\\
\multicolumn{4}{l}{func: function}\\
\multicolumn{4}{l}{ctor: constructor}\\
\multicolumn{4}{l}{note prefix {\tt -} maps to function {\tt neg}}\\
\hline
\end{tabular}
\end{table}


\section{Quaternion type}
There is a table of the operators \fullref{Quaternion Operators}.

\begin{table}
\caption{Quaternion Operators}
\label{Quaternion Operators}
\centering
\begin{tabular}[c]{llll}
\hline
symbol&kind&type&semantics\\
\hline
\hline
\verb%==%&infix-nassoc&\verb%T * T -> bool%&equality\\
\verb%!=%&infix-nassoc&\verb%T * T -> bool%&inequality\\
\hline
\verb%+%&infix-lassoc&\verb%T * T -> T%&addition\\
\hline
\verb%-%&infix-lassoc&\verb%T * T -> T%&subtraction\\
\hline
\verb%*%&infix-lassoc&\verb%T * T -> T%&multiplication\\
\hline
\verb%/%&infix-lassoc&\verb%T * T -> T%&quotient\\
\hline
\verb%-%&prefix&\verb%T -> T%&negation\\
\hline
\multicolumn{4}{l}{nassoc: non-associative}\\
\multicolumn{4}{l}{lassoc: left associative}\\
\multicolumn{4}{l}{func: function}\\
\multicolumn{4}{l}{note prefix {\tt -} maps to function {\tt neg}}\\
\hline
\end{tabular}
\end{table}



\section{Char Type}
Felix has a type \verb%char% corresponding to C's \verb%char%.
There are no literals of type \verb%char%, instead there
is a function, also called \verb%char% to construct a \verb%char%
from a string literal. If the string at least length 1, the first
character is returned, if the string is empty the \verb%NUL% char
\verb%\0x00% is returned.

An overload of the \verb%char% function also accepts an \verb%int%
argument and constructs a \verb%char% with the designated C code value
which must be in the range 0 through 255.

The function \verb%ord% extracts the C code value of a \verb%char%
as an \verb%int% in the range 0 through 255.

We note that C code values were originally used for the ASCII
character set. Strings of \verb%char% may be used to represent
ISO-10646 (Unicode) code points via the UTF-8 encoding method.
ASCII characters in the range 0 through 127 agree with Unicode
interpretation.

\subsection{ASCII classification functions}
There is a set of \fullref{ASCII classification functions}
used to test the ASCII class of char.

The library also provides character sets represents as
strings, show in \fullref{ASCII charsets}

\begin{table}
\caption{ASCII charsets}
\label{ASCII charsets}
\centering
\begin{tabular}[c]{ll}
\hline
symbol&definition\\
\hline
\verb%upper%&\verb%ABCDEFGHIJKLMNOPQRSTUVWXYZ%\\
\verb%lower%&\verb%abcdefghijklmnopqrstuvwxyz%\\
\verb%letters%&\verb%upper + lower%\\
\verb%digits%&\verb%0123456789%\\
\verb%alphanum%&\verb%letters + digits%\\
\verb%cidcont%&\verb%alphanum+"_"%\\
\verb%flxidcont%&\verb%alphanum+"_-'"%\\
\verb%camlidcont%&\verb%alphanum+"_'"%\\
\verb%numeric%&\verb%digits + ".eEdD_"%\\
\end{tabular}
\end{table}


\begin{table}
\caption{ASCII classification functions}
\label{ASCII classification functions}
\centering
\begin{tabular}[c]{lll}
\hline
symbol&type&semantics\\
\hline
\multicolumn{3}{c}{ISO C functions}\\
\verb%isupper%&\verb%char -> bool%&A-Z\\
\verb%islower%&\verb%char -> bool%&a-z\\
\verb%isalnum%&\verb%char -> bool%&A-Za-z0-9\\
\verb%isalpha%&\verb%char -> bool%&A-Za-z\\
\verb%isdigit%&\verb%char -> bool%&0-9\\
\verb%isxdigit%&\verb%char -> bool%&0-9A-Za-z\\
\verb%iscntrl%&\verb%char -> bool%&0x0-0x1F\\
\verb%isspace%&\verb%char -> bool%&0x20\\
\verb%isblank%&\verb%char -> bool%&0x20,0x09\\
\verb%isprint%&\verb%char -> bool%&0x20-0x7e\\
\verb%ispunct%&\verb%char -> bool%&punctuation\\
\multicolumn{3}{c}{Lexing functions}\\
\hline
\verb%isidstart%&\verb%char -> bool%&First char identifier\\
\verb%iscamlidcont%&\verb%char -> bool%&Ocaml, subsequent chars\\
\verb%iscidcont%&\verb%char -> bool%&C, subsequent chars\\
\verb%isflxidcont%&\verb%char -> bool%&Felix, subsequent chars\\
\verb%isnumeric%&\verb%char -> bool%&\verb%0-9+-.Ee%\\
\verb%isalphanum%&\verb%char -> bool%&A-Za-z0-9\\
\verb%isletter%&\verb%char -> bool%&A-Za-z\\
\verb%issq%&\verb%char -> bool%&\verb%'%\\
\verb%isdq%&\verb%char -> bool%&\verb%"%\\
\verb%isslosh%&\verb%char -> bool%&\verb%\%\\
\verb%isnull%&\verb%char -> bool%&0x0\\
\verb%iseol%&\verb%char -> bool%&\verb%\n% LF: Unix, CR: Windows\\
\hline
\end{tabular}
\end{table}


\section{String Type}
\subsection{Equality and total ordering}
\begin{minted}{felix}
  fun == (s:string, c:string): bool
  fun < (s:string, c:string): bool
  fun <= (s:string, c:string): bool
  fun > (s:string, c:string): bool
  fun >= (s:string, c:string): bool
\end{minted}

\subsection{Equality of {\tt string} and {\tt char}}
\begin{minted}{felix}
  fun == (s:string, c:char): bool
  fun == (c:char, s:string): bool
  fun != (s:string, c:char): bool
  fun != (c:char, s:string): bool
\end{minted}

\subsection{Append to {\tt string} object}
\begin{minted}{felix}
  proc  += : &string * string 
  proc  += : &string * +char
  proc  += : &string * char
\end{minted}

\subsection{Length of {\\ string}}
\begin{minted}{felix}
  fun len: string -> size
\end{minted}

\subsection{String concatenation}
\begin{minted}{felix}
  fun + : string * string -> string
  fun + : string * carray[char] -> string
  fun + : string * char -> string
  fun + : char * string -> string
  fun + ( x:string,  y: int):string
\end{minted}

\subsection{Repetition of {\tt string} or {\tt char}}
\begin{minted}{felix}
  fun * : string * int -> string
  fun * : char * int -> string
\end{minted}

\subsection{Application of {\tt string} to {\tt string} or {\tt int} is concatenation}
\begin{minted}{felix}
  fun apply (x:string, y:string):string
  fun apply (x:string, y:int):string
\end{minted}

\subsection{Construct a char from first byte of a {\tt string}}
Returns nul char (code 0) if the string is empty.

\begin{minted}{felix}
  ctor char (x:string)
\end{minted}

\subsection{Constructors for {\tt string}}
\begin{minted}{felix}
  ctor string (c:char)
  ctor string: +char 
  ctor string: +char  * !ints
  fun utf8: int -> string
\end{minted}

\subsection{Substrings}
\begin{minted}{felix}
  fun subscript: string * !ints -> char
  fun copyfrom: string * !ints -> string
  fun copyto: string * !ints -> string
  fun substring: string * !ints * !ints -> string
  fun subscript (x:string, gs:gslice[int]):string
  proc store: &string * !ints * char
\end{minted}

\subsection{Map a string {\tt char} by {\tt char}}
\begin{minted}{felix}
  fun map (f:char->char) (var x:string): string = {
\end{minted}

\subsection{STL string functions}
These come in two flavours: the standard C++ operations
which return \verb%stl_npos% on failure, and a more Felix
like variant which uses an @{option} type.

\begin{minted}{felix}
  const stl_npos: size

  fun stl_find: string * string -> size
  fun stl_find: string * string * size -> size
  fun stl_find: string * +char -> size
  fun stl_find: string * +char * size -> size
  fun stl_find: string * char -> size
  fun stl_find: string * char * size -> size

  fun find (s:string, e:string) : opt[size] 
  fun find (s:string, e:string, i:size) : opt[size]
  fun find (s:string, e:+char) : opt[size]
  fun find (s:string, e:+char, i:size) : opt[size]
  fun find (s:string, e:char) : opt[size]
  fun find (s:string, e:char, i:size) : opt[size]

  fun stl_rfind: string * string -> size
  fun stl_rfind: string * string * size -> size
  fun stl_rfind: string * +char-> size
  fun stl_rfind: string * +char * size
  fun stl_rfind: string * char -> size
  fun stl_rfind: string * char * size -> size

  fun rfind (s:string, e:string) : opt[size]
  fun rfind (s:string, e:string, i:size) : opt[size]
  fun rfind (s:string, e:+char) : opt[size]
  fun rfind (s:string, e:+char, i:size) : opt[size]
  fun rfind (s:string, e:char) : opt[size]
  fun rfind (s:string, e:char, i:size) : opt[size]

  fun stl_find_first_of: string * string -> size
  fun stl_find_first_of: string * string * size -> size
  fun stl_find_first_of: string * +char -> size
  fun stl_find_first_of: string * +char * size -> size
  fun stl_find_first_of: string * char -> size
  fun stl_find_first_of: string * char * size -> size

  fun find_first_of (s:string, e:string) : opt[size]
  fun find_first_of (s:string, e:string, i:size) : opt[size]
  fun find_first_of (s:string, e:+char) : opt[size]
  fun find_first_of (s:string, e:+char, i:size) : opt[size]
  fun find_first_of (s:string, e:char) : opt[size]
  fun find_first_of (s:string, e:char, i:size) : opt[size]

  fun stl_find_first_not_of: string * string -> size
  fun stl_find_first_not_of: string * string * size -> size
  fun stl_find_first_not_of: string * +char -> size
  fun stl_find_first_not_of: string * +char * size -> size
  fun stl_find_first_not_of: string * char -> size
  fun stl_find_first_not_of: string * char * size -> size

  fun find_first_not_of (s:string, e:string) : opt[size]
  fun find_first_not_of (s:string, e:string, i:size) : opt[size]
  fun find_first_not_of (s:string, e:+char) : opt[size]
  fun find_first_not_of (s:string, e:+char, i:size) : opt[size]
  fun find_first_not_of (s:string, e:char) : opt[size]
  fun find_first_not_of (s:string, e:char, i:size) : opt[size]

  fun stl_find_last_of: string * string -> size
  fun stl_find_last_of: string * string * size -> size
  fun stl_find_last_of: string * +char -> size
  fun stl_find_last_of: string * +char * size -> size
  fun stl_find_last_of: string * char -> size
  fun stl_find_last_of: string * char * size -> size

  fun find_last_of (s:string, e:string) : opt[size]
  fun find_last_of (s:string, e:string, i:size) : opt[size]
  fun find_last_of (s:string, e:+char) : opt[size]
  fun find_last_of (s:string, e:+char, i:size) : opt[size]
  fun find_last_of (s:string, e:char) : opt[size]
  fun find_last_of (s:string, e:char, i:size) : opt[size]

  fun stl_find_last_not_of: string * string -> size
  fun stl_find_last_not_of: string * string * size -> size
  fun stl_find_last_not_of: string * +char -> size
  fun stl_find_last_not_of: string * +char * size -> size
  fun stl_find_last_not_of: string * char -> size
  fun stl_find_last_not_of: string * char * size -> size

  fun find_last_not_of (s:string, e:string) : opt[size]
  fun find_last_not_of (s:string, e:string, i:size) : opt[size]
  fun find_last_not_of (s:string, e:+char) : opt[size]
  fun find_last_not_of (s:string, e:+char, i:size) : opt[size]
  fun find_last_not_of (s:string, e:char) : opt[size]
  fun find_last_not_of (s:string, e:char, i:size) : opt[size]
\end{minted}

  
\subsection{Construe {\tt string} as set of {\tt char}}
\begin{minted}{felix}
  instance Set[string,char] {
    fun \in (c:char, s:string) => stl_find (s,c) != stl_npos;
  }
\end{minted}
  
\subsection{Construe {\tt string} as stream of {\tt char}}
\begin{minted}{felix}
  instance Iterable[string, char] {
    gen iterator(var x:string) () = {
      for var i in 0 upto x.len.int - 1 do yield Some (x.[i]); done
      return None[char];
    }
  }
  inherit Streamable[string,char];
\end{minted}

\subsection{Test if a string has given prefix or suffix}
\begin{minted}{felix}
  fun prefix(arg:string,key:string)=
  fun suffix (arg:string,key:string)
  fun startswith (x:string) (e:string) : bool

  // as above: slices are faster
  fun endswith (x:string) (e:string) : bool

  fun startswith (x:string) (e:char) : bool 
  fun endswith (x:string) (e:char) : bool
\end{minted}

\subsection{h2 Trim off specified prefix or suffix or both}
\begin{minted}{felix}
  fun ltrim (x:string) (e:string) : string 
  fun rtrim (x:string) (e:string) : string
  fun trim (x:string) (e:string) : string
\end{minted}

\subsection{Strip characters from left, right, or both end of a string.}
\begin{minted}{felix}
  fun lstrip (x:string, e:string) : string
  fun rstrip (x:string, e:string) : string
  fun strip (x:string, e:string) : string
  fun lstrip (x:string) : string
  fun rstrip (x:string) : string
  fun strip (x:string) : string
\end{minted}

\subsection{Justify string contents}
\begin{minted}{felix}
  fun ljust(x:string, width:int) : string
  fun rjust(x:string, width:int) : string
\end{minted}

\section{Regexps}

\href{http://felix-lang.org/share/lib/grammar/regexps.fsyn}{Syntax}

\href{http://felix-lang.org/share/lib/std/strings/regdef.flx}{Combinators}

\href{http://felix-lang.org/share/lib/std/strings/re2.flx}{Google Re2 Binding}

\chapter{Fibres and Schannels}
\href{http://felix-lang.org/share/src/packages/fibres.fdoc}{Library Package}
\section{Pipelines}
\subsection{Synchronouse pipelines}
\href{http://felix-lang.org/share/lib/std/control/spipes.flx}{Library Reference}
lah.
\chapter{Asychronous Events}
blah.
\chapter{Pre-emptive Threading}
\href{http://felix-lang.org/share/src/packages/pthreads.fdoc}{Library Package}

\chapter{Json}
TBD
\chapter{Sqlite3}
TBD




\appendix
\backmatter
\end{document}
