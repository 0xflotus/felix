\documentclass{article}
\usepackage{color}
\definecolor{bg}{rgb}{0.95,0.95,0.95}
\definecolor{emphcolor}{rgb}{0.5,0.0,0.0}
\newcommand{\empha}{\bf\color{emphcolor}}
\usepackage{parskip}
\usepackage{minted}
\usepackage{caption}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amscd}
\usepackage{makeidx}
\makeindex
\usemintedstyle{friendly}
\setminted{bgcolor=bg,xleftmargin=20pt}
\usepackage{hyperref}
\hypersetup{pdftex,colorlinks=true,allcolors=blue}
\usepackage{hypcap}
\newcommand*{\fullref}[1]{\hyperref[{#1}]{\autoref*{#1} \nameref*{#1}}}
\DeclareMathOperator{\quot}{div}
\DeclareMathOperator{\rmd}{rmd}
\title{Row Polymorphism}
\author{John Skaller}
\begin{document}
\maketitle
\section{Records}
Felix has structurally typed records as illustrated below:

\begin{minted}{felix}
var r : (a:int,b:string) = (a=1,b="Hello");
\end{minted}

The order of the fields fields with different names
is irrelevant.

The names of the fields can be used as projections:

\begin{minted}{felix}
var i = a r;
var s = r.b;
\end{minted}

Stand alone value projections can be specified like:

\begin{minted}{felix}
var p = a of (a:int,b:string);
var i = p r;
\end{minted}

Pointer projections are also supported:

\begin{minted}{felix}
var pi : &int = &r.a;
var ps : &string = r&.b;
var i = *pi;
var s = *ps;
var p = a of &(a:int,b:string);
var i2 = *(p &r);
\end{minted}

Record field names may be repeated:

\begin{minted}{felix}
var rr : (a:int,a:double,a:int,b:string)
  = (a=1,a=2.3,a=4L,b="Hello")
;
\end{minted}

In this case projections refer to the leftmost field of
the given name. The order of fields with the same name
matters.


One can also use blank field names. The grammar allows the name 
\verb%n""% to be used. Alternatively, the name can be omitted,
or both the name and \verb%=% sign can be omitted, except for
the first field:


\begin{minted}{felix}
var x = (a=1,=2,n""=3);
println$ x._strr;
\end{minted}

If all the field names are blank, you can also omit the \verb%=% sign
from the first entry, and, if precedence allows, the parentheses:

\begin{minted}{felix}
var x : int * int * string = 1,2,"hello";
println$ x._strr;
\end{minted}

in which case the record called a tuple. Plain decimal integer
literals can be used for tuple projections:

\begin{minted}{felix}
var x : int * int * string = 1,2,"hello";
println$ x.1;
\end{minted}

Standalone tuples projections are denoted like:

\begin{minted}{felix}
var x : int * int * string = 1,2,"hello";
var prj1 = proj 1 of (int * int * string);
println$ prj1 x;
\end{minted}

If the types of a tuple are all the same, it is called an array:

\begin{minted}{felix}
var x : int ^ 3 = 1,2,3;
println$ x._strr;
\end{minted}

In this case the projections can be either an integer expression,
or an expression of the type of the array index:

\begin{minted}{felix}
var x : int ^ 3 = 1,2,3;
var one = 0 x;
var two = x.1;
var three = x.(case 2 of 3);
\end{minted}

If the projection is an integer it is bounds checked at
run time. If it is a compact linear type which is the type
of the array index, no bounds check is required.

\section{Addition}
Records and tuples can be concatenated with infix operator \verb%+%.
Duplicate fields retain their order.

\section{Polyrecords}
A list of fields may be added to any type with a polyrecord
expression:

\begin{minted}{felix}
var x = (a=1,b=2);
var y = (a=3,d=2 | x);
\end{minted}

The type of the result is a record if the RHS term is a record, including
tuples or unit tuple.

\end{document}
