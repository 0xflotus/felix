include "plat/config";
include "std/posix/__init__";
open Process;

proc pexit(e:int)
{
  if e != 0 do
    if WIFEXITED e.process_status_t do
      err :=  WEXITSTATUS e.process_status_t;
      eprintln$ "Error "+err.str+" in flx: " + strerror err.errno_t;
      System::exit err;
    elif WIFSIGNALED e.process_status_t do
      sig := WTERMSIG e.process_status_t;
      eprintln$ "Shell terminated by signal " + str sig;
      System::exit 2;
    else
      eprintln$ "Unknown error in shell " + str e;
      System::exit 3;
    done
  done
  System::exit e;
}

// Felix version of THIS program (NOT the one being installed
// if you're using flx to install Felix)

var config = #Config::config;
var VERSION=config.VERSION;

// --------------------------------------------------
// Print help
// --------------------------------------------------


proc print_help() {
  debugln "Display top level manual page using 'man' program";
  println "Usage: flx [options] filename[.flx] [args ..]";
  println "options:";
  println "--test               : use felix installation in current directory";
  println "--test=dir           : use felix installation in dir";
  println "--where              : print location of felix installation";
  println "--show               : print the felix program to stdout";
  println "-c                   : compile only, do not run";
  println "-o                   : linker output filename";
  println "--static             : make standalone statically linked executable";
  println "--nofelix            : do not run felix translator, leave C++ outputs alone";
  println "--options            : show option set";
  println "--config             : show configuration";
  println "--version            : show felix version";
  println "--force              : force run Felix compiler";
  println "--cache_dir=dir      : directory cache output from parser (*.par files), autocreated, default $HOME/.felix/cache";
  println "--output_dir=dir     : directory to hold C++ output from translator, autocreated, default $HOME/.felix/cache";
  println "--clean              : delete the caches first";
  println "--man                : show flx man page (if there is one)";
  println "--help               : show this help";
  println "--noinline           : force inlining off, may break things!";
  println "--inline             : aggressive inlining"; 
  println "--inline=999         : set inline cap to 999 'instructions'"; 
  println "--echo               : print shell commands before running them";
  println "--time               : print target program run time after it finishes";
  println "--nostdlib           : don't load the standard library";
  println "--nooptimise         : disable C++ compiler optimisation";
  println "--debug              : put debug symbols in generated binaries";
  println "--debug-compiler     : make felix compiler print progress diagnostics";
  println "--debug-flx          : make flx tool print diagnostics";
  println "--stdout=file        : run program with standard output redirected to file";
  println "--backup             : backup working source tree to dir 'backup'";
  println "--install            : install --test directory to configured location";
  println "--import=file        : add an import which is prefixed to all files being translated";
  println "--import=@file       : add all the files listed in file as imports (recursive on @)";
  println "--nostdimport        : don't import the standard imports nugram.flxh and flx.flxh";
  println "--compiler-phase     : specify which phase of the compiler to run";
  println "-Idir                : add dir to search path for both felix and C++ includes";                      
  println "-Ldir                : add dir to linker search path"; 
  println "-llib                : add dir lib to linker command";
  println "-Dmac                : add macro def to C++ compiler command";
  println "-DFLX_ENABLE_TRACE       : enable compilation of trace generators (defaults off)";
  println "-DFLX_PTF_STATIC_STRUCT  : make the thread_frame a static object (default Felix heap)";
  println "-DFLX_PTF_STATIC_POINTER : access the thread_frame from a static pointer (default pass as arg)";
  println "-DFLX_CGOTO              : use gcc indirect gotos and use assembler hack for long jumps (default on if config detects support)";
  println "";
  println "*.c *.cc *.cpp *.cxx ";
  println "                     : add files to C++ compilation (and linker) steps";
  println "*.o *.obj *.lib *.dll *.a *.so";
  println "                     : add files to linker steps";
  println "* *.flx              : Felix program name, terminates options and starts runtime arguments";
}



// --------------------------------------------------
// String Utilities 
// --------------------------------------------------

fun splitext(p:string)=>
  if p.[-4 to] == ".flx" then p.[to -4],"flx"
  elif p.[-4 to] == ".cpp" then p.[to -4],"cpp"
  else p,""
  endif
;

fun prefix(arg:string,key:string)=>
  arg.[to len key]==key
;

// --------------------------------------------------
// Optionally print a debug line.
// --------------------------------------------------

var dbug = false; // switch off for production
proc debugln[T with Str[T]] (x:T) {
  dbug ?? fprintln (cerr, "[flx] " + str x);
}

// --------------------------------------------------
// Invoke the shell
// --------------------------------------------------

var ECHO=0;
gen system(cmd:string):int= {
  if ECHO==1 do fprintln$ cerr, cmd; done
  var result = System::system(cmd);
  if ECHO==1 do fprintln$ cerr, "Result code " + str(result); done
  return result;
}

gen get_stdout(x:string) = {
  // We're screwed if popen doesn't work ..
/*
  if os.name == "nt": // popen doesn't work on Windows
    result := system(x + " >tmp.out");
    Stdout::flush();
    output := load "tmp.out";
  else:
*/
    //var fout = Process::popen_in(x+" 2>&1 "); // this screws up flx_pkgconfig!
    var fout = Process::popen_in(x+" ");
    if valid fout do
      var output = load fout;
      var result = Process::pclose fout; 
      return (Process::WEXITSTATUS result), output;
    else
      println$ "Unable to run command '" + x "'";
      return -1,"";
    done
}

gen xqt(cmd:string) = {
  ECHO == 1 or dbug ?? fprintln (cerr, "cmd="+cmd);
  var result,output = get_stdout(cmd);
  if result == 0 do
    n := 
      match find_first_of (output, char "\n") with
      | Some ?n => n 
      | None => output.len.int 
      endmatch
    ; 
    output = output.[to n]; // first line excluding newline
    ECHO==1 or dbug ?? fprintln (cerr, "output='"+output+"'");
  else
    debugln "COMMAND FAILED";
    fprint$ cerr, ("Error "+repr(result)+" executing command " + cmd + "/n");
    pexit result;
  done
  return output;
}


// --------------------------------------------------
// Install scripts
// --------------------------------------------------
var INSTALL_ROOT_TOPDIR=config.INSTALL_ROOT_TOPDIR;
var INSTALL_ROOT=config.INSTALL_ROOT;
var FLX_INSTALL_DIR=config.FLX_INSTALL_DIR;

proc install_old() {
    debugln "Install Felix";
    println "Install Felix: ONLY ON UNIX (you may need to be superuser)";
    println "Always installs the --test directory to the configured install target";
    println "Because that is hard coded into this program";
    println "Note: does NOT install this program 'flx' into your PATH!";
    println "  Use --install-bin for that!";
    println$ "FROM: " + FLX_INSTALL_DIR;
    println$ "TO  : " + INSTALL_ROOT;
    if FLX_INSTALL_DIR == INSTALL_ROOT do
      eprintln "Can't install, src and dst are the same";
      System::exit(1);
    else
      result=system("mkdir -pv "+INSTALL_ROOT_TOPDIR);
      if result != 0 do
        eprintln$ "Cannot create directory " + INSTALL_ROOT_TOPDIR;
        System::exit 1;
      done
      result=system("rm -rf "+INSTALL_ROOT);
      result=system("mkdir -pv "+INSTALL_ROOT);
      result=system("cp -Rpv "+FLX_INSTALL_DIR+"/* "+INSTALL_ROOT);
      if result == 0 do println "Install succeeded";
      else eprintln$ "Install failed, code = " + str(result);
      done
      pexit(result);
    done
}

proc install() {
    debugln "Install Felix build";
    println$ "FROM: " + FLX_INSTALL_DIR;
    println$ "TO  : " + INSTALL_ROOT;

    if FLX_INSTALL_DIR == INSTALL_ROOT do
      println "Can't install, src and dst are the same";
      System::exit(1);
    done

    var result = 0;

    // remove old install
    result=system("rm -rf "+INSTALL_ROOT);
    result=system("mkdir -pv "+INSTALL_ROOT);
    println "Target directory cleaned";
 
    // copy using flx_cp from build
    proc cp(s:string) {
      cmd=FLX_INSTALL_DIR+"/bin/flx_cp '"+FLX_INSTALL_DIR+"' '"+s+"' '"+INSTALL_ROOT+"/\\0'";
      //println$ "shell cmd = " + cmd;
      result=system(cmd);
      if result != 0 do  
        goto failure; done
    }
    dss:= list(

     (" * Tools", list( "bin/.*" )),

     (" * Run time libraries and C/C++ headers",
     list( 
       "lib/rtl/.*\\.(h|hpp|c|cpp|dylib|so|a)",
       "lib/rtl/flx_a?run.(o|obj)"
     )),


     (" * Resource database", list("config/[^/]*\\.fpc")),

     (" * Platform Dependent C++ headers", list("config/.*\\.hpp")),

     (" * Felix library",
     list( 
       "(tools|lib)/.*\\.(flxh?|files|fdoc)"
     )),

     (" * Felix web resources",
     list( 
       "(lib/web)/.*\\.(css|png|jpg|gif|js|db|sql|html)"
     )),


     (" * Regression and Unit test code", list("(test|tut)/.*\\.(flx|expect)")),

     (" * Documentation", 
       list (
        "doc/.*\\.(fdoc|html)",
        "web/.*\\.(fdoc|html|gif|png|jpg)",
        "index.html",
        "index2.html",
        "VERSION"
     ))

    );
    iter (proc (desc:string, srcs:list[string]) { println$ desc; iter cp srcs; }) dss; 

    println "Source Install succeeded";
    System::exit(result);
failure:> 
    println$ "Install failed, code = " + str(result);
    println$ "Flx_cp: ERROR " + str result+": "+strerror(result.errno_t); 
    System::exit(result);
}


proc backup() {
    debugln "Backup Felix build";
    println$ "FROM: " + FLX_INSTALL_DIR;
    println$ "TO  : backup";
    var result = 0;
    
    proc cp(s:string) {
      cmd=FLX_INSTALL_DIR+"/bin/flx_cp '"+FLX_INSTALL_DIR+"' '"+s+"' 'backup/\\0'";
      println$ cmd;
      result=system(cmd);
      if result != 0 do println$ "ERROR " + str result; goto failure; done
    }
    srcs := list(
     "(tools|lib)/.*\\.(flxh?|par2|libtab)",
     "lib/rtl/.*\\.(h|hpp|c|cpp|dylib|so|a)",
     "lib/rtl/flx_a?run.(o|obj)",
     "bin/.*",
     "config/.*",
     "(test|tut)/.*\\.(flx|expect)",
     "doc/.*\\.(fdoc|html)",
     "web/.*\\.(fdoc|html|gif|png|jpg)",
     "index.html",
     "index2.html",
     "VERSION"
    );
    iter cp srcs; 

    println "Source Install succeeded";
    System::exit(result);
failure:> 
    println$ "Install failed, code = " + str(result);
    System::exit(result);
}



// install executable files in usr/local/bin
// target cannot be changed.

proc install_bin ()
{
  // NOTE: these installs use the immediate build directory,
  // NOT the final build target, eg tools/webserver not bin/webserver
  // This may be wrong!
  debugln "Install executables and plugins";
  println$ "FROM: " + FLX_INSTALL_DIR;
  println$ "TO   : /usr/local/bin (fixed, can't be changed: privilege required)";
  println$ "AND  : /usr/local/lib (fixed, can't be changed: privilege required)";

  result=system("cp -f "+FLX_INSTALL_DIR+"/bin/flx /usr/local/bin");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/bin/mk_daemon /usr/local/bin");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/bin/timeout /usr/local/bin");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/webserver /usr/local/bin");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/flx_ls /usr/local/bin");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/flx_cp /usr/local/bin");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/ocaml2html"+EXT_SHLIB+" /usr/local/lib");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/py2html"+EXT_SHLIB+" /usr/local/lib");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/fpc2html"+EXT_SHLIB+" /usr/local/lib");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/flx2html"+EXT_SHLIB+" /usr/local/lib");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/fdoc2html"+EXT_SHLIB+" /usr/local/lib");
  if result !=0 goto install_bin_failed;

  result= system("cp -f "+FLX_INSTALL_DIR+"/tools/cpp2html"+EXT_SHLIB+" /usr/local/lib");
  if result !=0 goto install_bin_failed;

  println "Install succeeded";
  System::exit(0);

install_bin_failed:>
  println$ "Install failed, code = " + str(result);
  System::exit(result);
}
// --------------------------------------------------
// OS kind
// --------------------------------------------------

var CYGWIN=config.CYGWIN;
var WIN32=config.WIN32;
var MACOSX=config.MACOSX;

// --------------------------------------------------
// File time stamp processing
// --------------------------------------------------

body """
long macosx_ftime(::std::string s) {
  struct stat sb;
  int e = stat(s.c_str(),&sb);
  if(e != 0) return 0l;
  return sb.st_mtime;
}
""" requires header "#include <sys/stat.h>";

body """
long posix_ftime(::std::string s) {
  struct stat sb;
  int e = stat(s.c_str(),&sb);
  if(e != 0) return 0l;
  return sb.st_mtime;
}
""" requires header "#include <sys/stat.h>";


fun macosx_ftime: string -> double = "(double)macosx_ftime($1)";
fun posix_ftime: string -> double = "(double)posix_ftime($1)";

val past_time = -1.0;
val future_time = double(ulong(-1)); // a hacky way to get a big number

fun filetime(f:string)=>if MACOSX then macosx_ftime(f) else posix_ftime(f) endif;
fun dfiletime(f:string, dflt:double)=
{
  val x = filetime (f);
  dbug??println$ "Time of file " + f + " is " + fmt(x,fixed(0,3));
  return if x == 0.0 then dflt else x endif;
}

fun maxf (x: double) (f:string) => max (x, if f == "" then x else dfiletime (f+".flx",future_time) endif);
fun cal_files_time (fs: list[string])=> fold_left maxf 0.0 fs;
fun cal_time_from_dep (df: string):double=
{
  val deptext = load df;
  val lines = split (deptext, "\n"); 
  debugln$ "Deps=" + str(lines);
  val deptime = cal_files_time lines;
  debugln$ "Deptime=" + fmt(deptime,fixed(0,3));
  return deptime;
}

fun cal_dep_time(f:string)=> max(
  filetime(f+".flx"),
  cal_time_from_dep(f+".dep"));


// --------------------------------------------------
// Other Configuration Data
// --------------------------------------------------

//  C compiler kind
var HAVE_GNU=config.HAVE_GNU;
var HAVE_MSVC=config.HAVE_MSVC;

// compilation and linkage command heads
var CCOBJ_DLLIB=config.CCOBJ_DLLIB;
var CCLINK_DLLIB=config.CCLINK_DLLIB;
var CCOBJ_STATIC_LIB=config.CCOBJ_STATIC_LIB;
var CCLINK_STATIC=config.CCLINK_STATIC;

// extensions of various file kinds
var EXT_LIB=config.EXT_LIB;
var EXT_STATIC_OBJ=config.EXT_STATIC_OBJ;
var EXT_SHARED_OBJ=config.EXT_SHARED_OBJ;
var EXT_EXE=config.EXT_EXE;
var EXT_SHLIB=config.EXT_SHLIB;
var SPEC_OBJ_FILENAME=config.SPEC_OBJ_FILENAME;
var SPEC_EXE_FILENAME=config.SPEC_EXE_FILENAME;

// compilation switches
var OPTIMISE=config.OPTIMISE;
var DEBUG_FLAGS=config.DEBUG_FLAGS;
var DEFAULT_LINK_STATIC=config.DEFAULT_LINK_STATIC;

proc print_config() {
  println$ "VERSION            = "+VERSION;
  println$ "INSTALL_ROOT_TOPDIR= "+INSTALL_ROOT_TOPDIR;
  println$ "INSTALL_ROOT       = "+INSTALL_ROOT;
  println$ "FLX_INSTALL_DIR    = "+FLX_INSTALL_DIR;
  println$ "";
  println$ "CYGWIN             = "+str CYGWIN;
  println$ "WIN32              = "+str WIN32;
  println$ "MACOSX             = "+str MACOSX;

  println$ "";
  println$ "HAVE_GNU           = "+str HAVE_GNU;
  println$ "HAVE_MSVC          = "+str HAVE_MSVC;

  println$ "";
  println$ "CCOBJ_DLLIB        = "+CCOBJ_DLLIB;
  println$ "CCLINK_DLLIB       = "+CCLINK_DLLIB;
  println$ "CCOBJ_STATIC_LIB   = "+CCOBJ_STATIC_LIB;
  println$ "CCLINK_STATIC      = "+CCLINK_STATIC;

  println$ "";
  println$ "EXT_LIB            = "+EXT_LIB;
  println$ "EXT_STATIC_OBJ     = "+EXT_STATIC_OBJ;
  println$ "EXT_SHARED_OBJ     = "+EXT_SHARED_OBJ;
  println$ "EXT_EXE            = "+EXT_EXE;
  println$ "EXT_SHLIB          = "+EXT_SHLIB;
  println$ "SPEC_OBJ_FILENAME  = "+SPEC_OBJ_FILENAME;
  println$ "SPEC_EXE_FILENAME  = "+SPEC_EXE_FILENAME;

  println$ "";
  println$ "OPTIMISE           = "+str OPTIMISE;
  println$ "DEBUG_FLAGS        = "+str DEBUG_FLAGS;
}


// --------------------------------------------------
// Control Values
// --------------------------------------------------

var RECOMPILE=0;
var RUNIT=1;
var FELIX=1;

// --------------------------------------------------
// processing options
// --------------------------------------------------

var HOME= Env::getenv "HOME";

var DEBUG=0;
var DEBUG_COMPILER=0;
var COMPILER_PHASE="";
var INLINE=100;
var TIME=0;
var NOOPTIMISE=0;
var TIMECMD="time -p";
var STATIC=DEFAULT_LINK_STATIC;
var SHOWCODE=0;
var CCFLAGS="";
var LINKER_SWITCHES="";
var MACROS="";
var cpps="";
var cppos="";
var INCLUDE_DIRS="";
var INCLUDE_FILES="";
var NOSTDLIB=0;
var STDOUT="";
var STDGRAMMAR="@grammar/grammar.files";
var STDIMPORT="--import=plat/flx.flxh";
var IMPORTS="";
var CLEAR_CACHE=0;

var DEFAULT_CACHE_DIR = 
  if HOME=="" then "" else Filename::join (list(HOME,".felix","cache","binary")) 
;

var CACHE_DIR=
  let ?x = Env::getenv "FLX_CACHE_DIR" in 
  if x != "" then x else DEFAULT_CACHE_DIR
;

var DEFAULT_OUTPUT_DIR = 
    if HOME=="" then "" else Filename::join (list (HOME,".felix","cache","text"));

var OUTPUT_DIR=
  let ?x = Env::getenv "FLX_OUTPUT_DIR" in 
  if x != "" then x else DEFAULT_OUTPUT_DIR
;

var DRIVER_PKG = "";
var DRIVER = "";
var LINK_STRING = "";

var pkgs="";

var CONFIG_DIR = "";
var FLXG = "";
var FLXRUN = "";

var DLINK_STRING:string;
var SLINK_STRING:string;

proc print_options() {
    println$ "NOOPTIMISE         = "+str NOOPTIMISE;
    println$ "STATIC             = "+str STATIC;
    println$ "ECHO               = "+str ECHO;
    println$ "NOSTDLIB           = "+str NOSTDLIB;
    println$ "DEBUG              = "+str DEBUG;
    println$ "DEBUG_COMPILER     = "+str DEBUG_COMPILER;
    println$ "STDIMPORT          = "+str STDIMPORT;
    println$ "STDGRAMMAR         = "+str STDGRAMMAR;
    println$ "IMPORTS            = "+str IMPORTS;
    println$ "RECOMPILE          = "+str RECOMPILE;
    println$ "cpps               = "+str cpps;
    println$ "cppos              = "+str cppos;
    println$ "TIME               = "+str TIME;
    println$ "OUTPUT_DIR         = "+str OUTPUT_DIR;
    println$ "CACHE_DIR          = "+str CACHE_DIR;
    println$ "RUNIT              = "+str RUNIT;
    println$ "INCLUDE_DIRS       = "+str INCLUDE_DIRS;
    println$ "FELIX              = "+str FELIX;
    println$ "LINKER_SWITCHES    = "+str LINKER_SWITCHES;
    println$ "LINKER_OUTPUT_FILENAME = "+str LINKER_OUTPUT_FILENAME;
    println$ "MACROS             = "+str MACROS;
    println$ "SHOWCODE           = "+str SHOWCODE;
}

var compile_exts = List::list ('cpp','cxx','c','cc');
var linkexts =  List::list ('o','obj','lib','dll','a','so');
var result = 0;
var SET_LINKER_OUTPUT = false;
var LINKER_OUTPUT_FILENAME = "";

// Argument parsing loop
var argno=1;
var grab=1;
var arg = "";

grabbing_args: while grab == 1 and argno<System::argc do
  arg = System::argv argno;
  debugln$ "ARGNO="+str(argno)+", arg='"+arg+"'";
  if SET_LINKER_OUTPUT do
     LINKER_OUTPUT_FILENAME = arg;
     debugln$ "Set linker output file=" + LINKER_OUTPUT_FILENAME;
     SET_LINKER_OUTPUT = false;
     ++argno;
     continue grabbing_args;
  done

  var path,ext = splitext(arg);
  var dir,base = Filename::split1(path);
  debugln$ "path="+path+", ext="+ext+",dir="+dir+",base="+base;
  if ext != "flx" and ext != "" do
    // add to list of things to link, and also things to compile
    // if the extension is appropriate
    if List::mem eq of (string * string) compile_exts ext do
      cpps = cpps + " " + arg;
      cppos = cppos + " " + path + "." + EXT_OBJ;
    else
     cppos = cppos + " " + arg;
    done

  elif arg == "--nostdimport" do
    debugln "No standard library import";
    // Note: currently, Felix compiler generates code that REQUIRES
    // the standard library, eg the driver passes a gc_profile_t record
    // and the compiler generates _uctor_ objects, etc etc
    STDIMPORT="";

  elif prefix(arg,"--import=") do
   debugln "Add import";
   IMPORTS=IMPORTS + " " + arg.[9 to];

  elif prefix(arg,"--test=") do
    debugln "Set test directory";
    FLX_INSTALL_DIR=arg.[7 to];

  elif arg=="--test" do
    debugln "Set test directory";
    FLX_INSTALL_DIR=".";

  elif arg=="--install" do
    install; // non-return
  elif arg=="--backup" do
    backup; // non-return
  elif arg=="--install-bin" do
    install_bin; // non-return
  elif prefix(arg,"--stdout=") do
    debugln "Redirect standard output";
    // of the Felix program only: used for saving the output
    // to a file so the test harness can compare it with an .expect file
    STDOUT=arg.[9 to];

  elif arg=="--show" do
    SHOWCODE=1;

  elif arg=="--clean" do
    debugln "Clear caches";
    CLEAR_CACHE=1;

  elif arg=="--force" do
    debugln "Force recompilation";
    // of the felix code, runs Felix unless --nofelix is set
    // the C++ compiler is run unless the felix compile failed
    RECOMPILE=1;

  elif arg=="--debug-flx" do
    dbug = true;
    debugln "debug flx tool ON";
    DEBUG=1;

  elif arg=="--debug" do
    debugln "Enable runtime debugging";
    DEBUG=1;

  elif arg=="--debug-compiler" do
    debugln "Enable compiler debugging";
    DEBUG_COMPILER=1;

  elif prefix(arg,"--compiler-phase=") do
    debugln "Change the compiler phase";
    COMPILER_PHASE=arg.[len "--compiler-phase=" to];
    RUNIT=0;

  elif arg=="--nooptimise" do
    debugln "Disable optimisation";
    NOOPTIMISE=1;

  elif arg=="--nostdlib" do
    debugln "Do not load standard library";
    NOSTDLIB=1;

  elif arg == "--echo" do
    debugln "Echo commands sent to system";
    ECHO=1;

  elif arg == "--static" do
    debugln "Compile a statically linked program";
    STATIC=1;

  elif prefix(arg,"--inline=") do
    debugln "Set inline aggressiveness";
    INLINE=int(arg.[to 9]);

  elif arg == "--inline" do
    debugln "Set inline aggressiveness";
    INLINE=100;

  elif arg == "--noinline" do
    debugln "Disable inlining (NOT RECOMMENDED)";
    INLINE=0;

  elif arg == "--version" do
    debugln "Print Felix version and exit";
    print("version ");
    println(VERSION);
    System::exit(0);

  elif arg == "--config" do
    print_config;
    System::exit(0);

  elif arg == "--options" do
    print_options;
    System::exit(0);

  elif arg == "--where" do
    debugln "Print location of install directory and exit";
    println(FLX_INSTALL_DIR);
    System::exit(0);

  elif arg == "--time" do
    debugln "Time program execution and print after running";
    TIME=1;

  elif prefix(arg,"--output_dir=") do
    debugln "Set the directory for compiler generated C++ files";
    OUTPUT_DIR=arg.[13 to];

  elif prefix(arg,"--cache_dir=") do
    debugln "Set the directory for compiler generated *.par files";
    CACHE_DIR=arg.[12 to];

  elif arg == "--man" do
    debugln "Display top level manual page using 'man' program";
    C_hack::ignore(system( "man -M "+FLX_INSTALL_DIR+#Filename::sep+"man"+" flx"));
    System::exit(0);

  elif arg == "--help" do
    print_help;
    System::exit(0);

  elif arg == "-c" do
    debugln "Compile program but do not run it";
    RUNIT=0;

  elif arg == "-o" do
    debugln "Set linker output name (next arg)";
    SET_LINKER_OUTPUT=true;

  elif prefix(arg,"-I") do
    debugln "Set include directories for both Felix and C/C++";
    INCLUDE_DIRS=INCLUDE_DIRS + " " + arg;

  elif arg== "--nofelix" do
    debugln "Do not translate Felix code, just compile generated C++ (used to debug at C++ level)";
    FELIX=0;

  elif prefix(arg,"-l") or prefix(arg,"-L") do
    debugln "Set extra switched for linker";
    LINKER_SWITCHES=LINKER_SWITCHES + " " + arg;

  elif prefix(arg,"-D") do
    debugln "Set extra macros for C++ compilation";
    MACROS=MACROS + " " + arg;

  elif prefix(arg,"--pkg=") do
    debugln "Add pkgconfig package to link";
    pkgs= pkgs + " " + arg.[6 to];

  elif prefix(arg,"--") do
    debugln "Unknown -- style option, abort";
    println("Unknown option '"+ arg+"'");
    System::exit(1);

// the main filename -- subsequent args are args to flx_run
  else
    debugln "Assume we have the filename now";
    grab=0;
  done
  argno = argno + 1;
done

if WIN32 do
  FLXG=Filename::join(FLX_INSTALL_DIR, 'bin', 'flxg');
  FLXRUN='';
else
  FLXG=FLX_INSTALL_DIR+"/bin/flxg";
  // the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
  if MACOSX do
    FLXRUN="env DYLD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$DYLD_LIBRARY_PATH ";
  else
    FLXRUN="env LD_LIBRARY_PATH="+FLX_INSTALL_DIR+"/lib/rtl:$LD_LIBRARY_PATH ";
  done
done

Directory::mkdirs(CACHE_DIR);

var flxg_time = dfiletime(FLXG, future_time);
debugln$ "Flxg_time=" + fmt(flxg_time,fixed(0,3));

var flxg_stamp = Filename::join CACHE_DIR "flxg_time.stamp";
var cache_time = dfiletime(flxg_stamp,future_time);
debugln$ "cache_time=" + fmt (cache_time,fixed(0,3));

var flxg_stamp_data = load flxg_stamp;
//println$ "Flxg_stamp_data=" + flxg_stamp_data; 

var flxg_stamp_time = flxg_stamp_data.atof;
debugln$ "Flxg_stamp_data : " + fmt(flxg_stamp_time,fixed(0,3));

fun gramtime(path:string, s:string) : double = {
  //println$ "Path=" + path + " file = " + s;
  fun maxtime (x:double) (s:string) => max (x, gramtime (path, s));
  if s.[0]=="@".char do
    var file = Filename::join$ path, s.[1 to].strip;
    var filetime = dfiletime(file,0.0);
    if filetime == 0.0 do
      println$ "Grammar include file " + file " doesn't exist, exiting";
      System::exit 1;
    done
    debugln$ "Grammar include file " + file + " time=" + fmt(filetime,fixed(0,3));
    var filetext = load file;
    var files = split (filetext, "\n");
    //println$ "Files=" + files;
    return fold_left maxtime filetime files;
  else
    file = Filename::join$ path, s;
    filetime = dfiletime(file,0.0);
    if filetime == 0.0 do
      println$ "Grammar file " + file " doesn't exist, exiting";
      System::exit 1;
    done
    debugln$ "Grammar file " + file + " time=" + fmt (filetime, fixed(0,3));
    return filetime;
  done
}

var grammar_time = gramtime(Filename::join (FLX_INSTALL_DIR,"lib"), STDGRAMMAR);
debugln$ "Grammar text time=" + fmt (grammar_time,fixed(0,3));
var automaton_name = 
  Filename::join( CACHE_DIR, 
  Directory::mk_absolute_filename (Filename::join (list( 
    FLX_INSTALL_DIR,
    "lib",
    "grammar",
    "syntax.automaton"
  ))))
;

var automaton_time = dfiletime(automaton_name,future_time);
debugln$ "Automaton " + automaton_name + " time=" + fmt(automaton_time, fixed(0,3));

// Still if this fails,  the compiler is new and 
// the cache should be deleted.
if cache_time != future_time and flxg_stamp_time != flxg_time do
  println$ "Cache may be out of date due to compiler upgrade!";
  println$ "Flxg compiler time stamp=" + fmt(flxg_time,fixed(0,3));
  println$ "Cache time stamp        =" + fmt(cache_time,fixed(0,3));
  if not (
    (OUTPUT_DIR == "/" or OUTPUT_DIR == "" or OUTPUT_DIR == ".") or
    (CACHE_DIR == "/" or CACHE_DIR == "" or CACHE_DIR == ".")
  )
  do 
    CLEAR_CACHE = 1;
  done
elif automaton_time != future_time and grammar_time > automaton_time do
  println$ "Cache may be out of date due to grammar upgrade!";
  println$ "Grammar time stamp          =" + fmt(grammar_time, fixed(0,3));
  println$ "Automaton.syntax time stamp =" + fmt(automaton_time, fixed(0,3));
  if not (
    (OUTPUT_DIR == "/" or OUTPUT_DIR == "" or OUTPUT_DIR == ".") or
    (CACHE_DIR == "/" or CACHE_DIR == "" or CACHE_DIR == ".")
  )
  do 
    CLEAR_CACHE = 1;
  done
done

// FFF BE CAREFUL! The value "/" for these caches is perfectly good
if CLEAR_CACHE != 0 do
  // refuse to delete "" or "/" or ".", basic safety check
  if 
    (OUTPUT_DIR == "/" or OUTPUT_DIR == "" or OUTPUT_DIR == ".") or
    (CACHE_DIR == "/" or CACHE_DIR == "" or CACHE_DIR == ".")
  do
    println "WILL NOT DELETE CACHES";
    println$ "output cache " + OUTPUT_DIR;
    println$ "binary cache " + CACHE_DIR;
    System::exit(1);
  done

  // if the cache is default $HOME one, which cannot be ""
  // due to previous check, then delete without question
  if 
    OUTPUT_DIR == DEFAULT_OUTPUT_DIR and 
    CACHE_DIR == DEFAULT_CACHE_DIR 
  do 
    var answer = "Y\n";
  else
    // otherwise prompt for confirmation
    println$ "Would delete cache " + OUTPUT_DIR;
    println$ "Would delete cache " + CACHE_DIR;
    print "Are you SURE? (Y/n) "; fflush stdout;
    answer = readln stdin;
  done
  if answer == "Y\n" or answer == "y\n" do
    // delete the caches loudly
    println$ "Delete cache " + OUTPUT_DIR;
    C_hack::ignore$ xqt("rm -rf " + OUTPUT_DIR);
    println$ "Delete cache " + CACHE_DIR;
    C_hack::ignore$ xqt("rm -rf " + CACHE_DIR);
    Directory::mkdirs(CACHE_DIR);
    var f = fopen_output flxg_stamp;
    write(f, fmt(flxg_time, fixed (0,3)));
    f.fclose;
  else
    // otherwise exit with an error
    println "Not deleting cache, exiting with error 1";
    System::exit(1);
  done
done


debugln$ grab, argno, System::argc;
if grab == 1 and argno == System::argc do
  if CLEAR_CACHE == 1 do
    System::exit(0);
  else
    println "usage: flx [options] filename";
    System::exit(1);
  done
done

debugln "#--------";
debugln$ "DONE, option index = "+str(argno);
debugln$ "path="+path+": dir="+dir+",base="+base+", ext="+ext;
debugln$ "cpps="+cpps;
debugln$ "cppos="+cppos;

if dbug do 
  ECHO=1;
done

var USER_ARGS = ""; 
while argno < System::argc do 
  USER_ARGS+=" " + Bash::quote (System::argv argno); ++argno; 
done
debugln$ "USER_ARGS=" + USER_ARGS;

if NOOPTIMISE == 0 do
  debugln "Set C++ compiler optimisation switches";
  CCFLAGS=CCFLAGS+" " + OPTIMISE;
else
  debugln "What, no optimisation?";
done

var PKGCONFIG=Filename::join$ List::list(FLX_INSTALL_DIR,"bin","flx_pkgconfig");
debugln$ "Felix package manager program is "+PKGCONFIG;

if ECHO == 1 do
  fprintln (cerr, "#FLX_INSTALL_DIR="+FLX_INSTALL_DIR);
  fprintln (cerr, "#PKGCONFIG="+PKGCONFIG);
done

DLINK_STRING, SLINK_STRING = Config::link_strings(FLX_INSTALL_DIR);

CONFIG_DIR = Filename::join(FLX_INSTALL_DIR,'config');
debugln$ "Felix package manager config directory is "+CONFIG_DIR;
// make a list of any *.cpp files (or other g++ options ..)

var EXT_OBJ = 
  if STATIC == 0 then EXT_SHARED_OBJ
  else EXT_STATIC_OBJ
  endif
;

// this hack forces a directory name, because executing "prog"
// can fail if the currect directory is not on the PATH, 
// or worse, the wrong program can execute. The PATH is not
// searched if the filename includes a / somewhere so force one in.
// similarly for dynamic loaders looking for shared libraries
//
// It would probably be better to convert any relative filename
// to an absolute one, however this only makes sense on Unix 
// since Windows has multiple "drives" it is much harder to
// do the conversion.
dir = 
  if dir != "" then dir 
  else "."
  endif
;

var filebase = Directory::mk_absolute_filename$ Filename::join(dir,base);
debugln$ "User program base is " + filebase;
var cpp_filebase = if OUTPUT_DIR=="" then filebase else Filename::join(OUTPUT_DIR,filebase) endif;
debugln$ "C++ file base is " + cpp_filebase;

// Find absolute pathname

if path == "" do
  fprint$ cerr, ("No such felix program: "+path+"\n");
  System::exit(1);
done

proc calpackages () {

  // find external header files
  var PKGCONFIG_CFLAGS=PKGCONFIG+ " --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=cflags ";

  // external header files
  var PKGCONFIG_INCLUDES=PKGCONFIG+ " --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=includes ";

  // find external dynload libraries
  var PKGCONFIG_DLIBS=PKGCONFIG+" -r --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=provides_dlib --field=requires_dlibs ";

  // find external static libraries
  var PKGCONFIG_SLIBS=PKGCONFIG+" -r --keeprightmost --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=provides_slib --field=requires_slibs ";

  //find driver package required
  var PKGCONFIG_DRIVER=PKGCONFIG+" --path+="+Filename::join(FLX_INSTALL_DIR,"config") + " --field=flx_requires_driver ";


  // find all include directories
  var x = xqt(PKGCONFIG_CFLAGS+ " @"+cpp_filebase+".resh");
  INCLUDE_DIRS=INCLUDE_DIRS +" " + x;

  // find all include files
  x = xqt(PKGCONFIG_INCLUDES+ " @"+cpp_filebase+".resh");
  INCLUDE_FILES=INCLUDE_FILES +" " + x;

  // find the driver package
  DRIVER_PKG=xqt(PKGCONFIG_DRIVER+" @"+cpp_filebase+".resh");
  DRIVER_PKG == "" ??  DRIVER_PKG="flx_run";

  // find the driver entity
  if STATIC == 0 do
    // dynamic linkage: the driver executable
    DRIVER=Filename::join$ List::list (FLX_INSTALL_DIR,"bin",DRIVER_PKG+EXT_EXE);
  else
    // static linkage: the driver object file
    DRIVER=Filename::join$ List::list (FLX_INSTALL_DIR,"lib","rtl",DRIVER_PKG+EXT_STATIC_OBJ);
  done

  if STATIC == 0 do
    // dynamic linkage: all the libraries required by the application
    LINK_STRING=DLINK_STRING+LINKER_SWITCHES+" "+xqt(
      PKGCONFIG_DLIBS+" @"+cpp_filebase+".resh");
  else
    // static linkage: all the libraries required by the application and driver
    LINK_STRING=SLINK_STRING+LINKER_SWITCHES+" "+xqt(
      PKGCONFIG_SLIBS+" "+DRIVER_PKG+" @"+cpp_filebase+".resh");
  done

  if ECHO == 1 do
    fprintln (cerr, "//RESOURCE FILE="+cpp_filebase+".resh");
    fprintln (cerr, "//INCLUDE_DIRS="+INCLUDE_DIRS);
    fprintln (cerr, "//INCLUDE_FILES="+INCLUDE_FILES);
    fprintln (cerr, "//DRIVER="+DRIVER);
    fprintln (cerr, "//LINK_STRING="+LINK_STRING);
  done
}

proc write_include_file(path:string) {
  includes := split (strip INCLUDE_FILES,char " ");
  var f = fopen_output(path+".includes");
  List::iter  
    (proc (i:string) { writeln$ f, "#include " + i; })
    includes
  ;
  fclose f;
}

if LINKER_OUTPUT_FILENAME == "" do
  if STATIC == 0 do // dynamic
    LINKER_OUTPUT_FILENAME = filebase+EXT_SHLIB;
  else
    LINKER_OUTPUT_FILENAME = filebase+EXT_EXE;
  done
done
LINKER_OUTPUT_FILENAME =  Directory::mk_absolute_filename LINKER_OUTPUT_FILENAME; 

val args = USER_ARGS;
debugln$ "Target program args = "+args;

var INCLUDE_DIR="-I"+Filename::join(FLX_INSTALL_DIR,"lib","rtl") + " -I"+Filename::join(FLX_INSTALL_DIR,"config","target");
debugln$ "C++ Include directory for Felix library " + INCLUDE_DIR;

var FLXLIB="-I"+Filename::join(FLX_INSTALL_DIR,"lib");
var STDLIB=list("std","posix","web");
if NOSTDLIB == 1 do
  FLXLIB="";
  STDLIB=Empty[string];
done

var DEBUGSWITCH="";
DEBUG_COMPILER == 1?? DEBUGSWITCH=" --debug";

var STATIC_ENV="";
DEBUG_COMPILER == 1?? STATIC_ENV="env FLX_DEBUG=1 ";

var cmd = "";
debugln$ "RECOMPILE="+str RECOMPILE;
debugln$ "RUNIT="+str RUNIT;
if SHOWCODE == 1 do {
  prg := load(filebase+".flx");
  print prg;
}; done

if RECOMPILE == 0 and RUNIT == 1 and CLEAR_CACHE == 0 do
  // not (--force or -c)
  debugln "Checking to see if the binary is uptodate";
  debugln$ "Binary time = " + fmt (dfiletime(LINKER_OUTPUT_FILENAME,past_time),fixed(0,3));
  if STATIC == 0 do
    var xtime = dfiletime(LINKER_OUTPUT_FILENAME,past_time);
//println$ "xtime=" + fmt(xtime,fixed(0,3)) + ", cache time =" + fmt(cache_time, fixed(0,3));
    if xtime > cal_dep_time (filebase) and xtime > cache_time do
      debugln$ "Running dynamically linked binary";
      calpackages();
      cmd=FLXRUN+DRIVER+DEBUGSWITCH+" "+ LINKER_OUTPUT_FILENAME+" "+args;
      if STDOUT != "" do cmd=cmd + " > "+STDOUT; done
      debugln$ "Uptodate shared lib: Running command " + cmd;
      pexit(system(cmd));
    else
      debugln$ "Dynamically linked binary out of date or non-existant";
    done
  else
    xtime = dfiletime(LINKER_OUTPUT_FILENAME,past_time);
    if xtime > cal_dep_time(filebase)  and xtime > cache_time do
      debugln$ "Running statically linked binary";
      cmd=STATIC_ENV+" "+LINKER_OUTPUT_FILENAME+" "+args;
      debugln$ "Uptodate executable: Running command " + cmd;
      pexit(system(cmd));
    else
      debugln$ "Statically linked binary out of date or non-existant";
    done
  done
done

// Need Felix and c++ compile, then run it
dbug??println$ "RECOMPILING!!";

var VERBOSE = "";
if DEBUG_COMPILER == 1 do
  VERBOSE="-v";
  debugln "Compiler debugging on";
else
  VERBOSE="-q";
  debugln "Compiler debugging off";
done

if DEBUG==1 do
  CCFLAGS=CCFLAGS+DEBUG_FLAGS;
done

var FLXFLAGS="--inline="+str(INLINE);
if OUTPUT_DIR != "" do FLXFLAGS += ' --output_dir=' + str(OUTPUT_DIR); done;
if CACHE_DIR != "" do FLXFLAGS += " --cache_dir=" + CACHE_DIR; done
if COMPILER_PHASE != "" do FLXFLAGS += ' --compiler-phase=' + COMPILER_PHASE; done;

var FCMD="";
var LCMD="";
var CCMD="";

if FELIX == 1 do
  var stdlibs = cat ' ' STDLIB;
  FCMD=List::cat ' ' (List::list (
    FLXG,
    VERBOSE, FLXFLAGS, FLXLIB,
    INCLUDE_DIRS, "--syntax="+STDGRAMMAR, STDIMPORT, IMPORTS)) + 
    ' ' + stdlibs + 
    ' ' + filebase
  ;
  debugln$ "Felix command="+FCMD;
  result=system(FCMD);
  if result != 0 do 
    debugln "Felix compilation failed";
    pexit(result); 
  done
  debugln "Felix compilation succeeded";
  calpackages();
  write_include_file(cpp_filebase);
else
  debugln "Felix compilation skipped by switch";
  calpackages(); // need to do this here to set linker switches
done

if STATIC == 0 do
  debugln "Dynamic linkage";
  CCMD=List::cat ' ' (List::list (
    CCOBJ_DLLIB, CCFLAGS, "-DTARGET_BUILD",
    INCLUDE_DIR, INCLUDE_DIRS, MACROS,
    cpps, cpp_filebase+".cpp",
    SPEC_OBJ_FILENAME+cpp_filebase+EXT_OBJ));
  LCMD=List::cat ' ' (List::list (
    CCLINK_DLLIB, CCFLAGS,
    cppos, cpp_filebase+EXT_OBJ,
    SPEC_EXE_FILENAME+LINKER_OUTPUT_FILENAME,
    LINK_STRING));
  debugln$ "C++ command="+CCMD;
  result = system(CCMD);
  if result == 0 do
    debugln$ "Link command="+LCMD;
    result = system(LCMD);
    if result == 0 do
      if RUNIT == 1 do
        if TIME == 1 do
          cmd=List::cat ' ' (List::list (
            TIMECMD,
            FLXRUN+DRIVER+DEBUGSWITCH,
            LINKER_OUTPUT_FILENAME, args));
        else
          cmd=List::cat ' ' (List::list (
            FLXRUN+DRIVER+DEBUGSWITCH,
            LINKER_OUTPUT_FILENAME, args));
        done
        if STDOUT != "" do cmd=cmd+" > " +STDOUT; done
        debugln$ "Run command="+cmd;
        pexit(system(cmd));
      else
        debugln "Not running program selected by switch";
      done
    else
      debugln "Dynamic linkage failed";
    done
  else
    debugln "C++ compilation failed";
  done
else
  debugln "Static linkage";
  CCMD=List::cat ' ' (List::list (
    CCOBJ_STATIC_LIB,
    CCFLAGS, "-DTARGET_BUILD",
    "-DFLX_STATIC_LINK", INCLUDE_DIR, INCLUDE_DIRS,
    MACROS, cpps, cpp_filebase+".cpp",
    SPEC_OBJ_FILENAME+cpp_filebase+EXT_OBJ));
  LCMD=List::cat ' ' (List::list (
    CCLINK_STATIC, SPEC_EXE_FILENAME+LINKER_OUTPUT_FILENAME,
    cpp_filebase+EXT_OBJ, DRIVER, cppos, LINK_STRING));
  debugln$ "C++ command="+CCMD;
  result=system(CCMD);
  if result == 0 do
    debugln$ "Link command="+LCMD;
    result=system(LCMD);
    if result == 0 do
      // rm -f "$base.cpp"
      if RUNIT == 1 do
        if TIME == 1 do
          cmd= List::cat ' ' (List::list (
            TIMECMD, STATIC_ENV, LINKER_OUTPUT_FILENAME, args));
        else
          cmd=List::cat ' ' (List::list (
            STATIC_ENV, LINKER_OUTPUT_FILENAME,args));
        done
        if STDOUT != "" do cmd=cmd + " > "+STDOUT; done
        debugln$ "Run command="+cmd;
        pexit(system(cmd));
      else
        debugln "Not running program selected by switch";
      done
    else
      debugln "Static Linkage failed";
    done
  else
    debugln "C++ compilation failed";
  done
done

pexit(result);

