include "plat/config";
include "./flx_plat";
include "./flx_install";
include "./flx_cmdopt";
include "./flx_cache";
include "./flx_pkg";
include "./flx_config";
include "./flx_control";

// Felix version of THIS program (NOT the one being installed
// if you're using flx to install Felix)

var config = #Config::config;

// --------------------------------------------------
// Optionally print a debug line.
// --------------------------------------------------

var dbug = false; // switch off for production
proc debugln[T with Str[T]] (x:T) {
  dbug ?? fprintln (cerr, "[flx] " + str x);
}

// --------------------------------------------------
// Invoke the shell
// --------------------------------------------------

var ECHO=0;

val past_time = -1.0;
val future_time = double(ulong(-1)); // a hacky way to get a big number
// --------------------------------------------------
// Other Configuration Data
// --------------------------------------------------

// --------------------------------------------------
// Control Values
// --------------------------------------------------
var HOME= 
  let ?h = Env::getenv "HOME" in
    if h!="" then h 
    elif PLAT_WIN32 then Env::getenv "USERPROFILE"
    else ""
    endif
;
if HOME == "" do
    eprintln$ "HOME environment variable is not set.  Please set HOME before building."; 
	System::exit 1;
done 

var DEFAULT_CACHE_DIR = 
  Filename::join (list(HOME,".felix","cache","binary")) 
;


var DEFAULT_OUTPUT_DIR = 
  Filename::join (list (HOME,".felix","cache","text"))
;

var control = #dflt_control;

var compile_exts = List::list ('cpp','cxx','c','cc');
var linkexts =  List::list ('o','obj','lib','dll','a','so');
var result = 0;

// Argument parsing loop
var argno=1;
var grab=1;
var arg = "";
var path="";
var ext="";
var base="";
var dir="";

parse_cmd_line;

Directory::mkdirs(control.CACHE_DIR);

var flxg_time = dfiletime(control.FLXG, future_time);
debugln$ "Flxg_time=" + strfiletime(flxg_time);

var flxg_stamp = Filename::join control.CACHE_DIR "flxg_time.stamp";
var cache_time = dfiletime(flxg_stamp,future_time);
debugln$ "cache_time=" + strfiletime(cache_time);

var flxg_stamp_data = load flxg_stamp;
//println$ "Flxg_stamp_data=" + flxg_stamp_data; 

var flxg_stamp_time = match flxg_stamp_data.atof with | 0.0 => past_time | ?x => x;

debugln$ "Flxg_stamp_data : " + strfiletime(flxg_stamp_time);
var grammar_time = gramtime(Filename::join (config.FLX_INSTALL_DIR,"lib"), control.STDGRAMMAR);
debugln$ "Grammar text time=" + strfiletime (grammar_time);
var automaton_name = 
  cache_join(control.CACHE_DIR, 
  Directory::mk_absolute_filename (Filename::join (list( 
    config.FLX_INSTALL_DIR,
    "lib",
    "grammar",
    "syntax.automaton"
  ))))
;

var automaton_time = dfiletime(automaton_name,future_time);
debugln$ "Automaton " + automaton_name + " time=" + strfiletime(automaton_time);

validate_cache;


debugln$ grab, argno, System::argc;
if grab == 1 and argno == System::argc do
  if control.CLEAR_CACHE == 1 do
    System::exit(0);
  else
    println "usage: flx [options] filename";
    System::exit(1);
  done
done

debugln "#--------";
debugln$ "DONE, option index = "+str(argno);
debugln$ "path="+path+": dir="+dir+",base="+base+", ext="+ext;
debugln$ "cpps="+control.cpps;
debugln$ "cppos="+control.cppos;

if dbug do 
  ECHO=1;
done

while argno < System::argc do 
  control.USER_ARGS+=" " + quote (System::argv argno); ++argno; 
done
debugln$ "USER_ARGS=" + control.USER_ARGS;

if control.NOOPTIMISE == 0 do
  debugln "Set C++ compiler optimisation switches";
  control.CCFLAGS=control.CCFLAGS+" " + control.OPTIMISE;
else
  debugln "What, no optimisation?";
done
// Note we have to do it this way so the -f switches turn
// off optimisations previously introduced (order matters)
control.CCFLAGS += control.EXTRA_CCFLAGS;

var PKGCONFIG=quote(Filename::join$ List::list(config.FLX_INSTALL_DIR,"bin","flx_pkgconfig"));
debugln$ "Felix package manager program is "+PKGCONFIG;

if ECHO == 1 do
  fprintln (cerr, "#FLX_INSTALL_DIR="+config.FLX_INSTALL_DIR);
  fprintln (cerr, "#PKGCONFIG="+PKGCONFIG);
done

control.DLINK_STRING, control.SLINK_STRING = Config::link_strings(config.FLX_INSTALL_DIR);

var CONFIG_DIR = Filename::join(config.FLX_INSTALL_DIR,'config');
debugln$ "Felix package manager config directory is "+CONFIG_DIR;
// make a list of any *.cpp files (or other g++ options ..)

var EXT_OBJ = 
  if control.STATIC == 0 then config.EXT_SHARED_OBJ
  else config.EXT_STATIC_OBJ
  endif
;

// this hack forces a directory name, because executing "prog"
// can fail if the currect directory is not on the PATH, 
// or worse, the wrong program can execute. The PATH is not
// searched if the filename includes a / somewhere so force one in.
// similarly for dynamic loaders looking for shared libraries
//
// It would probably be better to convert any relative filename
// to an absolute one, however this only makes sense on Unix 
// since Windows has multiple "drives" it is much harder to
// do the conversion.
dir = 
  if dir != "" then dir 
  else "."
  endif
;
debugln$ "FileDir= " + dir;
var rel_filebase = if dir == "." then base else Filename::join(dir,base);
debugln$ "Rel_filebase= " + rel_filebase;
debugln$ "Given Extension=" + ext;

  // this is a hack! We should resolve the filename first.
var use_ext = if ext != "" then "."+ext else
  #{ 
     var flxt = dfiletime (rel_filebase+".flx",past_time);
     var fdoct = dfiletime (rel_filebase+".fdoc",past_time);
     return 
       if flxt > fdoct then ".flx"
       elif fdoct > flxt then ".fdoc"
       else ""
     ;
  }
;
debugln$ "Computed Extension=" + use_ext;
var filebase = Directory::mk_absolute_filename$ rel_filebase;
debugln$ "User program base is " + filebase;
var cpp_filebase =
  match control.BUNDLE_DIR with
  | Some ?dir => Filename::join(dir,Filename::basename filebase)
  | None =>if control.OUTPUT_DIR=="" then filebase 
           else cache_join(control.OUTPUT_DIR,filebase) 
           endif
  endmatch;         
debugln$ "C++ file base is " + cpp_filebase;

// Find absolute pathname

if path == "" do
  fprint$ cerr, ("No such felix program: "+path+"\n");
  System::exit(1);
done

if control.LINKER_OUTPUT_FILENAME == "" do
  if control.STATIC == 0 do // dynamic
    control.LINKER_OUTPUT_FILENAME = filebase+config.EXT_SHLIB;
  else
    control.LINKER_OUTPUT_FILENAME = filebase+config.EXT_EXE;
  done
done
control.LINKER_OUTPUT_FILENAME =  Directory::mk_absolute_filename control.LINKER_OUTPUT_FILENAME; 

val args = control.USER_ARGS;
debugln$ "Target program args = "+args;

var INCLUDE_DIR=quote("-I"+Filename::join(config.FLX_INSTALL_DIR,"lib","rtl")) + " "+quote("-I"+Filename::join(config.FLX_INSTALL_DIR,"config","target"));
debugln$ "C++ Include directory for Felix library " + INCLUDE_DIR;

var FLXLIB=quote("-I"+Filename::join(config.FLX_INSTALL_DIR,"lib"));
var STDLIB=list("std","web");
if control.NOSTDLIB == 1 do
  FLXLIB="";
  STDLIB=Empty[string];
done

var DEBUGSWITCH="";
if control.DEBUG_COMPILER == 1 do DEBUGSWITCH=" --debug"; done

var STATIC_ENV="";
if control.DEBUG_COMPILER == 1 do STATIC_ENV="env FLX_DEBUG=1 "; done

var cmd = "";
debugln$ "RECOMPILE="+str control.RECOMPILE;
debugln$ "RUNIT="+str control.RUNIT;
if control.SHOWCODE == 1 do {
  var prg = 
    if use_ext == "" then "// No file "+filebase+".(flx|fdoc) found"
    else load(filebase+"."+use_ext)
  ;
  print prg;
}; done

if control.RECOMPILE == 0 and control.RUNIT == 1 and control.CLEAR_CACHE == 0 do
  // not (--force or -c)
  debugln "Checking to see if the binary is uptodate";
  var xtime = dfiletime(control.LINKER_OUTPUT_FILENAME,past_time);
  var srctime = cal_dep_time (filebase);

  debugln$ "Filebase = " + filebase; 
  debugln$ "Binary time = " + strfiletime (xtime);
  debugln$ "src time = " + strfiletime (srctime);
  debugln$ "cache time = " + strfiletime (cache_time);
  if control.STATIC == 0 do
    if xtime > srctime and xtime > cache_time do
      debugln$ "Running dynamically linked binary";
      calpackages();
      cmd=control.FLXRUN+control.DRIVER_EXE+DEBUGSWITCH+" "+ quote(control.LINKER_OUTPUT_FILENAME)+" "+args;
      if control.STDOUT != "" do cmd=cmd + " > "+control.STDOUT; done
      debugln$ "Uptodate shared lib: Running command " + cmd;
      pexit(system(cmd));
    else
      debugln$ "Dynamically linked binary out of date or non-existant";
    done
  else
    if xtime > srctime and xtime > cache_time do
      debugln$ "Running statically linked binary";
      cmd=STATIC_ENV+" "+quote(control.LINKER_OUTPUT_FILENAME)+" "+args;
      if control.STDOUT != "" do cmd=cmd + " > "+control.STDOUT; done
      debugln$ "Uptodate executable: Running command " + cmd;
      pexit(system(cmd));
    else
      debugln$ "Statically linked binary out of date or non-existant";
    done
  done
done

// Need Felix and c++ compile, then run it
dbug??println$ "RECOMPILING!!";

var VERBOSE = "";
if control.DEBUG_COMPILER == 1 do
  VERBOSE="-v";
  debugln "Compiler debugging on";
else
  VERBOSE="-q";
  debugln "Compiler debugging off";
done

if control.DEBUG==1 do
  control.CCFLAGS=control.CCFLAGS+config.DEBUG_FLAGS;
done

var FLXFLAGS="--inline="+str(control.INLINE);
if control.OUTPUT_DIR != "" do FLXFLAGS += ' '+quote('--output_dir=' + str(control.OUTPUT_DIR)); done;
for dir in control.BUNDLE_DIR do FLXFLAGS += ' ' + quote('--bundle_dir=' + dir); done;
if control.CACHE_DIR != "" do FLXFLAGS += " "+quote("--cache_dir=" + control.CACHE_DIR); done
if control.COMPILER_PHASE != "" do FLXFLAGS += ' --compiler-phase=' + control.COMPILER_PHASE; done;

var FCMD="";
var LCMD="";
var CCMD="";

if control.FELIX == 1 do
  var stdlibs = cat ' ' STDLIB;
  FCMD=List::cat ' ' (List::list (
    control.QUOTE_FLXG,
    VERBOSE, FLXFLAGS, FLXLIB,
    control.INCLUDE_DIRS, "--syntax="+control.STDGRAMMAR, control.STDIMPORT, control.IMPORTS)) + 
    ' ' + stdlibs + 
    ' ' + quote(filebase+use_ext)
  ;
  debugln$ "Felix command="+FCMD;
  
  result=system(FCMD);
  if result != 0 do 
    debugln "Felix compilation failed";
    pexit(result); 
  done
  debugln "Felix compilation succeeded";
  calpackages();
  write_include_file(cpp_filebase);
else
  debugln "Felix compilation skipped by switch";
  calpackages(); // need to do this here to set linker switches
done

if control.CCOMPILEIT == 0 do
  debugln "C++ compilation skipped by switch";
elif control.STATIC == 0 do
  debugln "Dynamic linkage";
  CCMD=List::cat ' ' (List::list (
    config.CCOBJ_DLLIB, control.CCFLAGS, "-DTARGET_BUILD",
    INCLUDE_DIR, control.INCLUDE_DIRS, control.MACROS,
    control.cpps, quote(cpp_filebase+".cpp"),
    config.SPEC_OBJ_FILENAME+quote(cpp_filebase+EXT_OBJ)));
  LCMD=List::cat ' ' (List::list (
    config.CCLINK_DLLIB, control.CCFLAGS,
    control.cppos, quote(cpp_filebase+EXT_OBJ),
    config.SPEC_EXE_FILENAME+quote(control.LINKER_OUTPUT_FILENAME),
    control.LINK_STRING));
  debugln$ "C++ command="+CCMD;
  result = system(CCMD);
  if control.LINKIT == 0 do
    debugln "Not linking program selected by switch";
  elif result == 0 do
    debugln$ "Link command="+LCMD;
    result = system(LCMD);
    if result == 0 do
      if control.RUNIT == 1 do
        if control.TIME == 1 do
          cmd=List::cat ' ' (List::list (
            control.TIMECMD,
            control.FLXRUN+control.DRIVER_EXE+DEBUGSWITCH,
            quote(control.LINKER_OUTPUT_FILENAME), args));
        else
          cmd=List::cat ' ' (List::list (
            control.FLXRUN+control.DRIVER_EXE+DEBUGSWITCH,
            quote(control.LINKER_OUTPUT_FILENAME), args));
        done
        if control.STDOUT != "" do cmd=cmd+" > " +quote(control.STDOUT); done
        debugln$ "Run command="+cmd;
        pexit(system(cmd));
      else
        debugln "Not running program selected by switch";
      done
    else
      debugln "Dynamic linkage failed";
    done
  else
    debugln "C++ compilation failed";
  done
else
  debugln "Static linkage";
  var CCMD1=List::cat ' ' (List::list (
    config.CCOBJ_STATIC_LIB,
    control.CCFLAGS, "-DTARGET_BUILD",
    "-DFLX_STATIC_LINK", INCLUDE_DIR, control.INCLUDE_DIRS,
    control.MACROS, control.cpps, 
    quote(cpp_filebase+"_static_link_thunk.cpp"),
    config.SPEC_OBJ_FILENAME+quote(cpp_filebase+"_static_link_thunk"+EXT_OBJ)));

  var CCMD2=List::cat ' ' (List::list (
    config.CCOBJ_STATIC_LIB,
    control.CCFLAGS, "-DTARGET_BUILD",
    "-DFLX_STATIC_LINK", INCLUDE_DIR, control.INCLUDE_DIRS,
    control.MACROS, control.cpps, 
    quote(cpp_filebase+".cpp"),
    config.SPEC_OBJ_FILENAME+quote(cpp_filebase+EXT_OBJ)));


  LCMD=List::cat ' ' (List::list 
    (
      config.CCLINK_STATIC, config.SPEC_EXE_FILENAME+quote(control.LINKER_OUTPUT_FILENAME),
      quote(cpp_filebase+"_static_link_thunk"+EXT_OBJ),
      quote(cpp_filebase+EXT_OBJ)
    ) + 
    control.DRIVER_OBJS + 
    list( control.cppos, control.LINK_STRING))
  ;
  debugln$ "C++ command="+CCMD1;
  result=system(CCMD1);
  if result != 0 do
    debugln$ "C++ compilation failed";
  else
  result=system(CCMD2);
  debugln$ "C++ command="+CCMD2;
  if result != 0 do
    debugln$ "C++ compilation failed";
  done
  done

  if control.LINKIT == 0 do
    debugln "Not linking based on switch";
  elif result == 0 do
    debugln$ "Link command="+LCMD;
    result=system(LCMD);
    if result == 0 do
      // rm -f "$base.cpp"
      if control.RUNIT == 1 do
        if control.TIME == 1 do
          cmd= List::cat ' ' (List::list (
            control.TIMECMD, STATIC_ENV, quote(control.LINKER_OUTPUT_FILENAME), args));
        else
          cmd=List::cat ' ' (List::list (
            STATIC_ENV, quote(control.LINKER_OUTPUT_FILENAME),args));
        done
        if control.STDOUT != "" do cmd=cmd + " > "+control.STDOUT; done
        debugln$ "Run command="+cmd;
        pexit(system(cmd));
      else
        debugln "Not running program selected by switch";
      done
    else
      debugln "Static Linkage failed";
    done
  else
    debugln "C++ compilation failed";
  done
done

pexit(result);

