/*
This program provides roughly the same functionality as
the pkg-config program. It isn't the same, however,
and it uses its own files. As usual other people's software
is harder to modify so it work right than to do it oneself;(

This program should be compiled static with Felix, as early
as possible, since it is needed to compile Felix code
which uses extensions, plugins, or whatever.
Maybe the tarball should even include the C++ sources,
so it can be built early enough.
*/

proc kludge : 1 = "PTF gcp->allow_collection_anywhere=false;";
kludge();

open String;
open List;
open System;
open Env;
open Filename;
open Text_file;
open Lexer;
/*
regexp white = " " +;
regexp black = [^" "]+;
regexp dquoted = '"' [^'"']* '"';
regexp squoted = "'" [^"'"]* "'";
regexp quoted = dquoted | squoted;
*/

proc pre_incr:&iterator = "++*$1;";

fun lexit(ini:iterator, finish:iterator): iterator * string =
{
  var start = ini;

  // already at end
  if start == finish do 
    return start, "";

  // eat white space 
  elif *start == char(' ') do 
    ++start;
    whilst start != finish and *start == char(' ') do ++start; done;
    return start,"";

  // double quoted string
  elif *start == char('"') do
    ++start;
    p1 := start;
    whilst start != finish and *start != char('"') do ++start; done;
    if start == finish do
      return start,string_between(p1,start);
    else
      ++start;
      return start+1,string_between(p1, start-2);
    done;

  // single quoted string
  elif *start == char("'") do
    ++start;
    p2 := start;
    whilst start != finish and *start != char("'") do ++start; done;
    if start == finish do 
      return start,string_between(p2,start);
    else
      ++start;
      return start+1,string_between(p2, start-2);
    done;

  done;
  // identifier
  p3 := start;
  whilst start != finish and *start != char(" ")  do ++start; done;
  return start,string_between(p3,start);
}

fun lexstr(s':string): list[string] =
{
  var s = s';
  val first = start_iterator s;
  val finish = end_iterator s;
  var current = first;
  var words = Empty[string];
  while { current != finish }
  {
    match lexit(current,finish) with
    | ?next,?lexeme =>
      {
        current = next;
        if lexeme != "" do words = Cons(lexeme,words); done;
      }
    endmatch;
  };
  return rev words;
}

macro val streq = eq of (string * string);

var path=getenv("PKG_CONFIG_PATH");

// parse arguments
var fields = Empty[string];
var pkgs = Empty[string];

var hide = false; // only find first file in path
var require_pkg_exists = true; // fail if file not found
var missing = false; // report missing packages
var require_field_exists = false; // fail if file doesn't contain field
var recfields = Empty[string];
var dolist = false;
var listkeys = false;
var return_code = 0;
var backwards = false;
enum keep_t {keepall, keepleftmost, keeprightmost};
var keep= keepleftmost;

var i = 1;
var arg = argv i;
var args = Empty[string];
whilst arg != "" do args = arg + args; ++i; arg=argv i; done;
args = rev args;

fun is_prefix_of(p:string,w:string)=> p == w.[to len p];

fun xfind(flags: string, c: string) =>
 match find(flags, c) with
 | None => false
 | Some _ => true
 endmatch
;

proc parse_args(args:list[string])
{
  match args with
  | Empty => {}
  | Cons (?arg,?tail) =>
    {
      fun prefix(x:string)=>is_prefix_of(x,arg);

      if prefix("--hide") do hide = true;
      elif prefix("--backwards") do backwards = true;
      elif prefix("--list") do dolist = true;
      elif prefix("--missing") do missing = true;
      elif prefix("--noerror") do require_pkg_exists = false;
      elif prefix("--keeprightmost") do keep = keeprightmost;
      elif prefix("--keepleftmost") do keep = keepleftmost;
      elif prefix("--keepall") do keep = keepall;

      elif "--field" == arg.[0 to 7] do
        fields = fields + arg.[8 to];

      elif "-" == arg.[0 to 1] and "-" != arg.[1 to 2] do
        flags := arg.[1 to];
        if xfind(flags, "r") do
          recfields = append_unique streq recfields "Requires";
        done;

        if xfind(flags,"h") do hide = true; done;
        if xfind(flags,"b") do backwards = true; done;
        if xfind(flags,"l") do dolist = true; done;

      elif "--rec" == arg.[0 to 5] do
        var fld = arg.[6 to];
        fld = if fld == "" then "Requires" else fld endif;
        recfields = append_unique streq recfields fld;

      // add to path
      elif "--path+" == arg.[0 to 7] do
        val x = arg.[8 to];
        if path != "" do
          path= path + ":" + x;
        else
          path= x;
        done;

      // set path
      elif "--path" == arg.[0 to 6] do
        path= arg.[7 to];


      elif "@" == arg.[0 to 1] do
        val data = Text_file::load$ strip arg.[1 to];
        parse_args$ split(data,c" \n\r\t,");

      // ignore unknown options
      elif "-" == arg.[0 to 1] do ;

      // ignore empty arguments
      elif "" == arg do ;

      // package name
      else
        pkgs = pkgs + arg;
      done;
      parse_args(tail);
    }
  endmatch;
}

parse_args(args);

fun str: list[string] -> string =
  | Cons (?e,?t) => e + " " + str t
  | Empty => ""
;

//print$ "Fields   = " + str fields; endl;
//print$ "Packages = " + str pkgs; endl;

val dirs=split(path, char ':');

//print$ "Path = " + str dirs; endl;

var result = Empty[string];

fun get_field(line:string):string * string =>
    match find (line,char ':') with
    | None => "",""
    | Some ?n =>
        strip line.[to n],
        strip line.[n+1 to]
    endmatch
  ;

proc add_val(v:string){
 result = insert_unique streq result v;
//  result = rev$ Cons(v, rev result);
}

proc tail_val(v:string){
   result = append_unique streq result v;
//  result = Cons(v, result);
}

proc keep_val (v:string){
  result = result + v;
}

proc handle_pkg (pkg:string, trace:list[string]){
   if mem streq trace pkg return;
   var found = false;
   iter(proc (dir:string){
     val filename =
       if dir=="" then "." else dir endif + sep + pkg + ".fpc"
     ;
     //print filename; endl;

     // examine line of one file
     file := fopen_input filename;
     if valid file do
       if dolist call add_val pkg;
       var lines = Empty[string];
       var line = readln file;
       whilst line != "" do
         lines = Cons(line,lines);
         line = readln file;
       done;
       if not backwards do lines = rev lines; done;

       iter (proc (line:string)
       {
         //print line;
         def var key, var value = get_field(line);
         if listkeys call add_val key;
         var values = lexstr(value);

         if mem streq fields key do
           match keep with
           | keepleftmost => { iter the add_val values; }
           | keeprightmost => { iter the tail_val values; }
           | keepall => { iter the keep_val values; }
           endmatch;
         done;

         // chase dependent packages
         if mem streq recfields key do
           iter (proc (s:string){
             handle_pkg$ s,Cons(pkg,trace);
           })
           values;
         done;
       })
       lines
       ;
       fclose file;
       found = true;
       if hide return; // only find first file in path
     done;
   })
   dirs;
   if not found do
     if require_pkg_exists do return_code = 1; done;
     if missing call add_val(pkg);
   done;
}

whilst not is_empty pkgs do
  match pkgs with
  | Empty => {}
  | Cons (?pkg,?tail) =>
    {
      pkgs = tail;
      handle_pkg(pkg,Empty[string]);
    }
  endmatch;
done;

// strip any trailing space off to ease bash scripting
print$ strip$ str result; endl;
System::exit return_code;
