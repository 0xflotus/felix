@h1 Syntax Macro Processor Basics
WARNING: Macros will probably be removed entirely.
Generally speaking .. MACROS SUCK.

Why is this? Because, unlike normal programming where one generates output
with explicit operations, macro definitions are reduced to become the output.
This reduction is basically the same as beta-reduction in lambda-calculus
and the ordering is generally normal; that is, lazy;
except that values can be obtained both from parameter argument bindings and
from environment bindings. We also have to provide alpha-conversion to ensure
symbols are exposed to environment bindings where desired and not otherwise.
Consequently the timing of reductions and alpha-conversions has a major impact
on the resulting term, and the rules are usually complex and involve rescanning
because otherwise the macros aren't powerful enough to really do anything useful.

Their main purpose at the moment is to support 
the parser action code to generate ASTs. This support was essential
prior to introduction of the new parsing system which uses Scheme
for the actions. Scheme is better structured and more powerful
than any macro processor.

WARNING: Macros respect Macro, Felix, and File scopes.
The only exception is that procedure macros are designed to
allow exporting of code defined in their bodies.

Because macros respect scopes, and Felix include facility fully
encapsulates all parsing and macro processing, macros cannot be
propagated from one file to another. The only way to share macros
in some file is to use the <pre>--import=macrofile</pre> switch
of the {flxg} compiler or {flx} command line harness. 
This causes the imported text to be "glued"
onto the front of every file in such a way that macros and syntax
definitions propagate globally. The system uses that to ensure macros
defining the operating system are available to support conditional
compilation based on platform.

Macros currently have one other use: macro vals are occasionally useful
for the same purpose as in C: to define compile time constants.
In particular, pattern matching does not support expressions, only
structural patterns using literals for constants: the constants cannot
be named <em>except by a macro val</em>.

WARNING: the macro elaboration rules are so complex and finicky
that even this author doesn't really understand how they work.

WARNING: Macro invocations can be recursive. There is a recursion limit
to stop the compiler exploding.

@h2 Expression Macro Facility
Felix provides an powerful and dangerous
expression macro facility. Felix macros
generally respect scope, so any definitions
nested in a function or module, for example,
will not be visible outside that scope.

Expresion symbols only expand inside expressions.

@h3 Macro values
The macro val statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.

@flx-and-expect tut/macros/mac-1.01.01-0

@h3 Macro variables
The macro var statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.

Macro variables can be assigned a new value.
@flx-and-expect tut/macros/mac-1.01.02-0

@h3 Macro variables in requirements
Named requirements in requirements clauses are
macro expanded as expressions: they must be qualified
names though.

@flx-and-expect tut/macros/mac-1.01.03-0

@h3 Macro functions
You can also define a macro function.
The expansion rules are: the body
is not expanded during definition.
At the point of call, the arguments
are expanded and then substituted into
the body, then the body is expanded.

WARNING: macro function definitions need a semi-colon
at the end. This is because the RHS is universally
treated as an expression.
@flx-and-expect tut/macros/mac-1.01.04-0

It is vital to understand that macros cannot break
syntactically established precedence rules.
In the last example, a 1 expands to (b c) 1,
which expands to f 1. Substitutions are implemented
by manipulation of the abstract syntax tree (AST),
not token pasting or string manipulation.

@h2 Constant Expression Folding
The Felix macro processor also performs constant folding;
that is, evaluation of certain expressions involving
only literals. The following operations are folded:
<pre>
  op                     descr
  +int
  -int
  int+int
  int-int
  int*int
  int/int
  int%int
  int&lt;int
  int&gt;int
  int&lt;=int
  int&gt;=int
  int==int
  int!=int
  string+string
  string==string
  string!=string
  string*int             cat n copies
  string string          cat
  string int             cat ISO10646
  not bool
  bool &amp;&amp; bool
  bool or bool
  bool == bool
  bool != bool
  if bool then expr1 else expr2 endif
</pre>
The critical operation here is that a conditional
with a constant first argument is replaced by one
of the two expressions, and the other is elided.
See the example for an application: the implication
is that the elided expression, whilst it must be
well formed syntactically, does not need to be
type correct, nor do symbols in it need to be defined.

Note that the fold uses compiler intrinsic operations
on integers, bools, and strings: user defined functions
are not applied and do not need to be defined.
Consequently, the result may disagree with a user
defined function applied at run time.  If necessary,
constant folding can be blocked with the noexpand mark 'noexpand'.

Note: the expressions
<pre>
  "" 999
  u"" 999
</pre>
are semantically, but not physically equivalent.
The first operation is the UTF-8 representation
of 999, whilst the second is the UCS-4 value 999.

@flx-and-expect tut/macros/mac-1.02-0

@h2 Procedure Macros
A procedure macro represents a list of statements.
Macros defined in macro procedures are exported
to the surrounding scope so that macro procedures
can be used to package up a set of macro definitions.
This represents a special exception to the rule
that macros respect scope.
@flx-and-expect tut/macros/mac-1.03-0

Note there is a crucial difference between procedure
and expressions macros. In the above example,
dump requires a proc argument. When the parameter
is expanded, the list of statements it represented
is produced. Had this been a function macro,
the result would have been an the call executable lambda
expression applied to unit argument. The difference
is in the handling of any variable declarations:
they'd be exposed in the first case, but not the second.

@h2 Advanced Procedure Macro Programming
Felix procedure macros also contain rudimentary
control structures: you can encode labels, unconditional
jumps, conditional jumps, and returns. Note the conditional
goto requires the condition resolve to a constant expression.
Of course, the value can change with time, since it can
depend on macro variables.
@p()
This example also illustrates the macro block, which is
an anonymous procedure, called after definition. The effect
is similar to the statements in the block, except that
locally defined symbols are not exported. The construction
is regularly required by the syntax extension facility,
to prevent name conflicts when the same construction
is expanded more than once, particularly cases where
a macro expansion has as its argument another expansion
of itself.

@flx-and-expect tut/macros/mac-1.04-0

@h2 Expansion Barrier
The symbol 'noexpand' can be used to block expansion.

@flx-and-expect tut/macros/mac-1.05-0

@h2 Identifier Macros
A identifier macros represent names. They replace names
in expressions and most declarations, including the
name of a function or variable being defined.
Names are not replaced in type expressions, patterns,
or regular expressions.

The special form in which the RHS name is called 'new'
creates a fresh, previously unused name.

Unlike other macros, the RHS name of an ident macro
is not expanded at the point of definition.

On use, the value of an ident macro is the first
name in the chain which is not an ident macro,
or which recurs.
@flx-and-expect tut/macros/mac-1.06-0

@h3 Forgetting Macros
You can forget macros defined in the current scope with
the forget statement. If no arguments are given,
all macros defined in the current scope are forgotten.

@flx-and-expect tut/macros/mac-1.06.01-0

@h3 For Loops
Felix provides two for loops which iterate over tuples.

@flx-and-expect tut/macros/mac-1.06.02-0

@h3 Unpacking Tuples
Tuples can be unpacked by macro assignment,
macro val, macro var, and macro for val statements.

@flx-and-expect tut/macros/mac-1.06.03-0
@flx-and-expect tut/macros/mac-1.06.04-0
@flx-and-expect tut/macros/mac-1.06.05-0
