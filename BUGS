* Operator . doesn't work right applying curried function:
   x.(f 1)

* Operator . doesn't work right for procedures. Eg x.println doesn't work.
  FIXED 11/12/2011

* when x.filename is a &char, x.filename.string doesn't do what I expected,
  it actually does string of the char pointed at, using the rule that
  p.a means (*p).a if p is a pointer. This coupled with the fact 
  r.a means a'th field of record or struct r, not reverse application.

  BOTH these meanings of operator . (not to mention composition!)
  can lead to unexpected results. We need to unify/fix this mess.

  For get method, easy to make x.a mean (a x) as reverse application,
  if the field name 'a' is notionally a projection function.

  For assignment like x.a = v, goes to &(x.a) <- v, we need to make
  &(x.a) equal (&x).a = pointer to a component, NOT value of a.
  This seems to conflict with auto-deref.

* I think there is a bug in the compiler where a generator result assigned
  to a variable is ignored if that value of the variable is ignored.
  This has the effect of eliminating the side effect. The case causing
  the problem was posix close(), the result being leaving open a heap
  of files. Try to reproduce this problem, then fix the compiler so it doesn't
  happen! Or, document it and show the proper workaround (eg C_hack::ignore).

