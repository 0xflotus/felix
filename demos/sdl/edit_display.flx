include "sdl/SDL2";
include "sdl/SDL_ttf";
include "sdl/SDL_image";
include "./edit_display_interface";

object edit_display (init: edit_display_init) 
implements edit_display_interface = 
{

  var ibeam = #{
    var f = SDL_RWFromInputFile "Ibeam.png";
    var ibeam = IMG_LoadPNG_RW f;
    SDL_FreeRW f;
    return ibeam;
  };

  var nullRect = C_hack::null[SDL_Rect];

  var red = SDL_Color (255u8,0u8, 0u8,0u8);
  var white = SDL_Color (255u8,250u8, 250u8,0u8);
  var black = SDL_Color (0u8,0u8, 0u8,0u8);
  var brown = SDL_Color (200u8, 150u8, 190u8, 0u8);
  var blue = SDL_Color (0u8, 0u8, 255u8, 0u8);
  var green = SDL_Color (0u8, 255u8, 0u8, 0u8);
  var darkgreen = SDL_Color (50u8, 200u8, 50u8, 0u8);
  var yellow = SDL_Color (0u8, 255u8, 255u8, 0u8);
  var orange = SDL_Color (200u8, 150u8, 150u8, 0u8);
  var purple = SDL_Color (255u8, 0u8, 255u8, 0u8);
  var keycolour = SDL_Color (150u8, 80u8, 80u8, 0u8);

  var lightgrey = SDL_Color (200u8, 200u8, 200u8, 0u8);
  var grey = SDL_Color (150u8, 150u8, 150u8, 0u8);
  var darkgrey = SDL_Color (100u8, 100u8, 100u8, 0u8);
  var soot = SDL_Color (50u8, 50u8, 50u8, 0u8);

  var startline = 0;
  var lineskip = TTF_FontHeight(init.font)+1;
  var yoffset = 10; 
  var xoffset = 20;

  method fun get_xoffset () => xoffset;
  method proc set_xoffset (x:int) => xoffset = x;

  method fun get_yoffset () => yoffset;
  method proc set_yoffset (x:int) => yoffset = x;

  method fun get_lineskip () => lineskip;
  method fun get_startline () => startline;

  fun minx (font:TTF_Font, chrix : int) =
  {
    var minx:int; var maxx:int; var miny:int; var maxy:int; var advance:int;
    var fi : uint16 = chrix.uint16; 
    C_hack::ignore$ TTF_GlyphMetrics(font,fi,&minx, &maxx, &miny, &maxy, &advance);
    return minx;
  }

  var charwidth = #{
    var minx:int; var maxx:int; var miny:int; var maxy:int; var advance:int;

    var result = TTF_GlyphMetrics(init.font,"m".char.ord.uint16,&minx, &maxx, &miny, &maxy, &advance);
    if result < 0 do 
      eprintln$ "Couldn't get size of 'm' in courier font";
      System::exit 1;
    done
    println$ "Metrics m = minx="+minx.str+" maxx="+maxx.str+" adv="+advance.str;
    return advance;
  };

  method fun get_charwidth () => charwidth;

  enum tclass = ordinary, identifier, keyword, coment, strng, error;

  // hack tokeniser
  fun tokenise (var state:int, s:string) = 
  {
    var words = Empty[tclass * string];
    var word = "";
    var kind = ordinary;
    proc setkind() {
      kind = match state with | 0 => ordinary | 1 => identifier | 2 => coment | _ => error;
      if word in 
      (
        "fun", "proc", "var","gen","val",
        "typedef","union","struct",
        "do", "done",
        "if","else","elif","begin","end","while","then",
        "for","upto","downto"
        "match","endmatch",
        "return","yield",
        "method","object","interface","implements",
        "and","or","not"
      ) 
      do 
        kind = keyword; 
      done
    }
    if s.len.int > 0 do 
      for var i in 0 upto s.len.int - 1 do
        var ch = s.[i];
        if state == 0 do // scanning non-ident
          if ch in alphanum do
            if word.len.int > 0 do
              words += (ordinary,word);
              word = "";
            done
            state = 1; // scanning ident
          elif ch == char "/" and s.[i+1] == char "/" do
            state = 2; // scanning comment
          done
        elif state ==  1 do
          if not (ch in alphanum) do
            if word.len.int > 0 do 
              setkind;
              words += (kind,word);
              word = "";
            done
            if ch == char "/" and s.[i+1] == char "/" do
              state = 2; // scanning comment
            else
              state = 0;
            done
          done
        else // state = 3, scanning C++ comment
          // nothing to do 
        done
        word += ch;
      done
    done
    if word.len.int > 0 do
      setkind;
      words += (kind,word);
      word = "";
    done
    state = 0;
    return state,words;
  } 

  method proc draw()
  {
    var window_surface = SDL_GetWindowSurface init.window;
    var curline = #(init.editor.get_curline);
    var curcol= #(init.editor.get_curcol);
    var selection = #(init.editor.get_selection);
    var lines = #(init.editor.get_lines);
 
    startline = curline - #(init.editor.get_soffset);
    if startline < 0 do startline = 0; done
    var bg = white;
    var pixelformat : &SDL_PixelFormat  = window_surface*.format;
    var bgpixels = SDL_MapRGB(pixelformat,bg.r, bg.g, bg.b);
    var result = SDL_FillRect(window_surface, nullRect,bgpixels);
    var r = SDL_CreateSoftwareRenderer (window_surface); 
    C_hack::ignore$ SDL_RenderDrawLine (r, 10,10,100,10);
    SDL_DestroyRenderer r;
    var lno = 0;
    var sel = 
      if selection.first_line > selection.last_line 
      or 
        selection.first_line == selection.last_line and 
        selection.first_col > selection.past_col
      then (
        first_line=selection.last_line, 
        first_col=selection.past_col, 
        last_line=selection.first_line, 
        past_col=selection.first_col
      )
      else selection
   ;

    val unused=0;
    var state = 0;
    for line in lines do
      if lno >= startline do
        def state, var words = tokenise (state,line);
        var presel = 
          if lno == sel.first_line then sel.first_col 
          else 0
        ;
        var postsel = 
          if lno == sel.last_line then sel.past_col 
          elif lno >= sel.first_line and lno < sel.last_line then line.len.int
          else 0
        ;
        fun dstview() => SDL_Rect (
          xoffset+x+xadj,
          yoffset + (lno - startline) * lineskip,
          unused,unused)
        ;

        var i = 0;
        match ?kind,?word in words do
          for var j in 0 upto word.len.int - 1 do // no null words
            if i >=presel and i < postsel do
              var xadj = 0; // min (0,minx (init.font, line.[i].ord));
              var text_rendered = TTF_RenderGlyph_Shaded(init.font,word.[j].ord.uint16,red,grey);
            else
              var colour = 
                match kind with 
                | ordinary => soot 
                | identifier => soot 
                | keyword => keycolour
                | coment => darkgreen
                | _ => red
              ;
              xadj = min (0,minx (init.font, word.[j].ord));
              text_rendered = TTF_RenderGlyph_Solid(init.font,word.[j].ord.uint16,colour);
            done
            var x = charwidth * i;
            var viewport = #dstview;
            result = SDL_BlitSurface (text_rendered, nullRect, window_surface, &viewport); 
            SDL_FreeSurface text_rendered;
            ++i;
          done
        done
      done
      ++lno;
    done
    var xpos = xoffset + curcol * charwidth;
    var ypos = yoffset + (curline - startline) * lineskip;
    var dstpos = SDL_Rect (xpos,ypos,0,0);
    var srcrect = SDL_Rect (0,0,1,20);
    result = SDL_BlitSurface (ibeam, &srcrect, window_surface, &dstpos); 
    result = SDL_UpdateWindowSurface init.window;
    if result != 0 do
      eprintln$ "Unable to update window";
      System::exit 1;
    done
  }
}


fun setup(x:string)= { println$ "edit display setup"; C_hack::ignore x; return 0; } 
  // the hack here is a BUG in the compiler, dropping
  // an unused parameter

export fun setup of (string) as "edit_display_setup";
export proc edit_display of (edit_display_init) as "edit_display";

