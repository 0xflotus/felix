/* SDL based programmers text editor 

Design notes.

We use roughly an MVC system, the Model is the
edit buffer, the View is the display, and the
control dispatches keystrokes to the editor and
calls for the display at various times.

In an ideal system the text editing API would be
cleanly separated from the display management.

However, some user operations both modify the buffer
and require adjustments to the view. The general
invariant which separates the buffer from the display
is that the current cursor location be display on
approximately the middle line of the display area.

Some commands such as a mouse click reposition
the cursor (edit buffer) AND change the current screen
line (display) the cursor is shown on (so that in fact the operation
moves the cursor but not the text).

The display is naturally dependent on the edit buffer (since it
has to get the text to display from it!). However if the cursor
is part of the edit buffer then commands like page-up and page-down
move an amount dependent on the number of screen lines. However
the movement might be clipped by the total number of text lines,
so the calculation depends on BOTH the display state and the
edit buffer state.

So again we have an operation which exhibits coupling.

*/


// SDL2 test
include "sdl/SDL2";
include "sdl/SDL_ttf";
include "sdl/SDL_image";
include "./edit_buffer_interface";
include "./edit_display_interface";
include "./edit_controller_interface";

proc init()
{
  if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0  do
    eprintln$ f"Unable to init SDL: %S\n" #SDL_GetError;
    System::exit(1);
  done
  println$ "SDL_init OK";
  if TTF_Init() < 0 do 
    eprintln$ f"Unable to init TTF: %S\n" #TTF_GetError;
    System::exit(1);
  done
  println$ "TTF_init OK";
  if IMG_Init(IMG_INIT_PNG) < 0 do 
    eprintln$ f"Unable to init IMG with PNG: %S\n" #IMG_GetError;
    System::exit(1);
  done
  println$ "IMG_init OK";
}

proc versions ()
{
  begin
    var compiled = #SDL_Compiled_Version;
    var linked = #SDL_Linked_Version;
    println$ f"We compiled against SDL version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against SDL version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #TTF_Compiled_Version;
    var linked = #TTF_Linked_Version;
    println$ f"We compiled against TTF version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against TTF version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #IMG_Compiled_Version;
    var linked = #IMG_Linked_Version;
    println$ f"We compiled against IMG version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against IMG version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

} 

proc mainline ()
{
  init;
  versions;

  var font = #{ 
    var font_file = "/Library/Fonts/Courier New Bold.ttf";
    var font = TTF_OpenFont (font_file,12);
    if not (TTF_ValidFont font) do
      eprintln$ f"Unable to open TTF font %S\n" font_file;
      System::exit 1;
    done
    TTF_SetFontKerning (font,0);
    var isfixed = TTF_FontFaceIsFixedWidth (font);
    println$ "Opened Font " + font_file + 
      " Facename: " + TTF_FontFaceFamilyName font + 
      (if isfixed>0 then " MONOSPACED" else " VARIABLE WIDTH");
    return font;
  };
 
  var window = SDL_CreateWindow(
    "SDL_RenderClear",
    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
    512, 512,
    SDL_WINDOW_SHOWN \| SDL_WINDOW_RESIZABLE)
  ;
  var clock = #Faio::mk_alarm_clock;

  var red = SDL_Color (250u8,0u8, 0u8,0u8);
  var white = SDL_Color (250u8,255u8, 255u8,0u8);
  var black = SDL_Color (0u8,0u8, 0u8,0u8);

  var intro = "Hello from Felix";
  var intro_rendered = TTF_RenderText_Solid (font,intro,red);
  var nullRect = C_hack::null[SDL_Rect];
  var window_surface = SDL_GetWindowSurface window;

  var result = SDL_BlitSurface (intro_rendered, nullRect, window_surface, nullRect); 
  if result != 0 do
    eprintln$ "Unable to blit text to window surface";
    System::exit 1;
  done
  println$ "Blitted Text to Window Surface";
  SDL_FreeSurface intro_rendered;
 
  result = SDL_UpdateWindowSurface window;
  if result != 0 do
    eprintln$ "Unable to update window";
    System::exit 1;
  done

// ------------------------------------------------------------------------------
  var E = #{
    var text = load "demos/sdl/sdltest.flx";
    var lines = darray$ varray$ split$ text, char '\n';
    var editor = Dynlink::load-plugin-func1 [edit_buffer_interface, darray[string]] 
      (dll-name="edit_buffer")
    ;
    return editor lines;
  };


  var D = #{
    var display = 
      Dynlink::load-plugin-func1 [edit_display_interface, edit_display_init] 
      (dll-name="edit_display")
    ;
    return display (font=font, editor=E, window=window);
  };


// ------------------------------------------------------------------------------

  D.draw; 
  var CTL = #{
    var ctl = Dynlink::load-plugin-func2 [edit_controller_interface, edit_buffer_interface, edit_display_interface]
      (dll-name="edit_controller")
    ;
    return ctl (E,D);
  };

  getevent:while true do
    var e : SDL_Event;
    C_hack::ignore$ SDL_WaitEvent$ &e;
    if #(E.get_changed) do
      E.reset();
      D.draw;
    done
    match e.type.SDL_EventType with
    | $(SDL_QUIT) =>
      println$ "QUIT";
      break getevent;

    | $(SDL_KEYDOWN) =>
      E.set_dotext true;
      var vkey = e.key.keysym.sym;
      //println$ "Keydown " + strmods e.key.keysym.mod + str vkey;
      if e.key.keysym.mod == 0u16 do 
        if vkey == SDLK_KP_5 do CTL.recentre;
        else
          E.modless_keys vkey;
        done
      elif e.key.keysym.mod \& (KMOD_LSHIFT.uint16 \| KMOD_RSHIFT.uint16) != 0u16 do E.shift_keys vkey;
      elif e.key.keysym.mod \& (KMOD_CTRL .uint16 \| KMOD_RCTRL.uint16) != 0u16 do E.control_keys vkey;
      done

    | $(SDL_KEYUP) => 
      //println$ "Keyup"
      ;
    | $(SDL_TEXTEDITING) =>
      println$ "TextEditing";

    | $(SDL_TEXTINPUT) =>
      begin
        if #(E.get_dotext) do
          var buffer : +char = e.text.text;
          var ch = buffer.0; 
          E.insert_char ch;
        done
      end
    | $(SDL_MOUSEBUTTONDOWN) => 
      begin
        var bno = e.button.button;
        var x = e.button.x.int;
        var y = e.button.y.int;
        CTL.begin_mark_selection (x,y);
        //println$ "Mousedown b="+bno.int.str + " x=" + x.str + " y=" + y.str;
      end
    | $(SDL_MOUSEBUTTONUP) => 
      begin
        var bno = e.button.button;
        var x = e.button.x.int;
        var y = e.button.y.int;
        //println$ "Mouseup="+bno.int.str + " x=" + x.str + " y=" + y.str;
        CTL.end_mark_selection (x,y);
      end
    | $(SDL_MOUSEMOTION) => 
      /* println$ "Mousemove"*/ ;
      if e.motion.state != 0u32 do // some button down will do for now
      begin
        var bno = e.button.button;
        var x = e.button.x.int;
        var y = e.button.y.int;
        CTL.extend_selection (x,y);

        //println$ "Mouse move="+bno.int.str + " x=" + x.str + " y=" + y.str;
      end
      done

    | $(SDL_MOUSEWHEEL) => 
      begin
        var y = e.wheel.y.int;
        CTL.pan y;
      end 

    | $(SDL_WINDOWEVENT) => 
        println$ "WindowEvent " + 
          e.window.event.SDL_WindowEventID.str
        ;
        if e.window.event.SDL_WindowEventID == SDL_WINDOWEVENT_SIZE_CHANGED do
          // reset nlines etc here!
          D.draw;
        done
    | _ => 
      println$ "Event type " + e.type.str;
    endmatch;
  done
  Faio::sleep(clock,1.0);
  SDL_DestroyWindow(window);
  SDL_Quit;
 
}

mainline;
