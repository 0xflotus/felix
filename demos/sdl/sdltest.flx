// SDL2 test
include "sdl/SDL2";
include "sdl/SDL_ttf";
include "sdl/SDL_image";

proc init()
{
 if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0  do
    eprintln$ f"Unable to init SDL: %S\n" #SDL_GetError;
    System::exit(1);
  done
  println$ "SDL_init OK";
  if TTF_Init() < 0 do 
    eprintln$ f"Unable to init TTF: %S\n" #TTF_GetError;
    System::exit(1);
  done
  println$ "TTF_init OK";
   if IMG_Init(IMG_INIT_PNG) < 0 do 
    eprintln$ f"Unable to init IMG with PNG: %S\n" #IMG_GetError;
    System::exit(1);
  done
  println$ "IMG_init OK";
}

proc versions ()
{
   begin
    var compiled = #SDL_Compiled_Version;
    var linked = #SDL_Linked_Version;
    println$ f"We compiled against SDL version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against SDL version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #TTF_Compiled_Version;
    var linked = #TTF_Linked_Version;
    println$ f"We compiled against TTF version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against TTF version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #IMG_Compiled_Version;
    var linked = #IMG_Linked_Version;
    println$ f"We compiled against IMG version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against IMG version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

} 

proc mainline ()
{
  init;
  versions;

  var font = #{ 
    var font_file = "/Library/Fonts/Courier New.ttf";
    var font = TTF_OpenFont (font_file,16);
    if not (TTF_ValidFont font) do
      eprintln$ f"Unable to open TTF font %S\n" font_file;
      System::exit 1;
    done
    println$ "Opened Font " + font_file + " Facename: " + TTF_FontFaceFamilyName font;
    return font;
  };
 
  var charwidth = #{
    var width: int; var depth: int;
    var result = TTF_SizeText (font,"m",&width,&depth);
    if result < 0 do 
      eprintln$ "Couldn't get size of 'm' in courier font";
      System::exit 1;
    done
    return width;
  };

  var window = SDL_CreateWindow(
    "SDL_RenderClear",
    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
    512, 512,
    SDL_WINDOW_SHOWN \| SDL_WINDOW_RESIZABLE)
  ;
  var clock = #Faio::mk_alarm_clock;

  var red = SDL_Color (250u8,200u8, 200u8,0u8);
  var white = SDL_Color (250u8,250u8, 250u8,0u8);
  var intro = "Hello from Felix";
  var intro_rendered = TTF_RenderText_Solid (font,intro,red);
  var nullRect = C_hack::null[SDL_Rect];
  var window_surface = SDL_GetWindowSurface window;

  var result = SDL_BlitSurface (intro_rendered, nullRect, window_surface, nullRect); 
  if result != 0 do
    eprintln$ "Unable to blit text to window surface";
    System::exit 1;
  done
  println$ "Blitted Text to Window Surface";
  SDL_FreeSurface intro_rendered;
 
  result = SDL_UpdateWindowSurface window;
  if result != 0 do
    eprintln$ "Unable to update window";
    System::exit 1;
  done

  var ibeam = #{
    var f = SDL_RWFromInputFile "Ibeam.png";
    var ibeam = IMG_LoadPNG_RW f;
    SDL_FreeRW f;
    return ibeam;
  };
 
  var text = load "demos/sdl/sdltest.flx";
  println$ "-" * 20;
  print text;
  println$ "-" * 20;
  var lines = darray$ varray$ split$ text, char '\n';
  var curline = 0;
  var curcol = 0;
  var startline = 0;
  var nlines = 30; // hack, calculate on resize
  proc draw()
  {
    startline = curline - nlines/2;
    if startline < 0 do startline = 0; done
    var pixelformat : &SDL_PixelFormat  = window_surface*.format;
    var result = SDL_FillRect(window_surface, nullRect, SDL_MapRGB(pixelformat,0u8, 0u8, 250u8)); 
    var lno = 0;
    for line in lines do
      if lno >= startline do
        var viewport = SDL_Rect (20,10 + (lno - startline) * 20,500,500);
        var text_rendered = TTF_RenderText_Solid (font,line,white);
        result = SDL_BlitSurface (text_rendered, nullRect, window_surface, &viewport); 
        /* 
        if result != 0 do
          eprintln$ "Unable to blit text to window surface";
          System::exit 1;
        done
        */
        if lno == curline do
           // this is total hack
           var xpos = 20 + curcol * charwidth;
           var ypos = 10 + (lno - startline) * 20;
           var currect = SDL_Rect (xpos,ypos,5,20);
           result = SDL_BlitSurface (ibeam, nullRect, window_surface, &currect); 
        done
        SDL_FreeSurface text_rendered;
      done
      ++lno;
    done
    result = SDL_UpdateWindowSurface window;
    if result != 0 do
      eprintln$ "Unable to update window";
      System::exit 1;
    done
   }
  draw; 
  getevent:while true do
    var e : SDL_Event;
    C_hack::ignore$ SDL_WaitEvent$ &e;
    match e.type.SDL_EventType with
    | $(SDL_QUIT) =>
      println$ "QUIT";
      break getevent;

    | $(SDL_KEYDOWN) =>
      begin 
        var vkey = e.key.keysym.sym;
        println$ "Keydown " + str vkey;
        match vkey with
        | $(SDLK_DOWN) => 
          if curline < lines.len.int do
            curline = curline + 1;
            draw;
          done

        | $(SDLK_UP) => 
          if curline >0 do
            curline = curline - 1;
            draw;
          done

        | $(SDLK_LEFT) => 
          if curcol > 0 do
            curcol = curcol - 1;
            draw;
          elif curline > 0 do
            curline = curline - 1;
            curcol = lines.curline.len.int;
            draw;
          done

        | $(SDLK_RIGHT) => 
          if curcol < lines.curline.len.int do
            curcol = curcol + 1;
            draw;
          elif curline < lines.len.int do
            curline = curline + 1;
            curcol = 0;
            draw;
          done
        | $(SDLK_DELETE) =>
          begin
            if curline < lines.len.int do
              var n = lines.curline.len.int;
              if curcol < n do
                var tmp = lines.curline;
                erase$ tmp,curcol,1;
                set(lines,curline,tmp);
                draw; 
              elif curline < lines.len.int - 1 do
                tmp = lines.curline;
                tmp = tmp + ' ' * (curcol - n) + lines.(curline+1);
                set(lines,curline, tmp);
                var first = curline + 1;
                var last = lines.len.int - 2;
                if first <= last do
                  for var i in first upto last do
                    set(lines,i,lines.(i+1));
                  done
                done
                pop lines;
                draw;
              done
            done
          end

        | $(SDLK_BACKSPACE) =>
          begin
            var n = lines.curline.len.int;
            if curcol > 0 do
              if curcol <= n do
                var tmp = lines.curline;
                erase$ tmp,curcol - 1,1;
                set(lines,curline,tmp);
              done
              --curcol;
              draw; 
            elif curline > 0 do
              --curline;
              set(lines,curline, lines.curline+lines.(curline + 1));
              for var i in curline + 1 upto lines.len.int - 2 do
                set(lines,i,lines.(i+1));
              done
              pop lines;
              curcol = lines.curline.len.int;
              draw;
            done
          end

        | $(SDLK_RETURN) =>
          begin
            if curline < lines.len.int do
              var tmp = lines.curline.[curcol to];
              set(lines,curline,lines.curline.[to curcol]);
              push_back (lines,lines.(lines.len.int - 1)); // last line
              var last = lines.len.int - 2;
              var first = curline + 1;
              if first <= last do
                for var i in last downto first do
                  set(lines, i + 1, lines.i);
                done
              done
              set(lines,curline+1,tmp);
              ++curline;
              curcol = 0;
              draw;
            done
          end

        | $(SDLK_HOME) => 
          curcol = 0;
          draw;

        | $(SDLK_END) => 
          curcol = lines.curline.len.int;
          draw;


        | _ => ;
        endmatch; // vkey
      end // keydown

    | $(SDL_KEYUP) => 
      println$ "Keyup";
    | $(SDL_TEXTEDITING) =>
      println$ "TextEditing";

    | $(SDL_TEXTINPUT) =>
      begin
        var buffer : +char = e.text.text;
        var ch = buffer.0; 
        var ins = ch.str;
        println$ "Textinput char0=" + ins;
        var tmp = lines.curline;
        var n = tmp.len.int;
        if curcol > n do
          tmp = tmp + ' ' * (curcol - n) + ins;
        else
          insert$ tmp, curcol, ins;
        done
        set (lines,curline,tmp);
        ++curcol;
        draw;
      end
    | $(SDL_MOUSEBUTTONDOWN) => 
      println$ "Mousedown";
    | $(SDL_MOUSEBUTTONUP) => 
      println$ "Mouseup";
    | $(SDL_MOUSEMOTION) => 
      /* println$ "Mousemove"*/ ;
    | $(SDL_MOUSEWHEEL) => 
      begin
        //println$ "Mousewheel x=" + e.wheel.x.str + ", y=" + e.wheel.y.str;
        var y = e.wheel.y.str;
        curline = curline - y.int;
        if curline < 0 do curline = 0; done
        draw;
      end 

    | $(SDL_WINDOWEVENT) => 
        println$ "WindowEvent " + 
          e.window.event.SDL_WindowEventID.str
        ;
        if e.window.event.SDL_WindowEventID == SDL_WINDOWEVENT_SIZE_CHANGED do
          window_surface = SDL_GetWindowSurface window;
          draw;
        done
    | _ => 
      println$ "Event type " + e.type.str;
    endmatch;
  done
  Faio::sleep(clock,1.0);
  SDL_DestroyWindow(window);
  SDL_Quit;
 
}

mainline;

