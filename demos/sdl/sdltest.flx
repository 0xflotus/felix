/* SDL based programmers text editor 

Design notes.

We use roughly an MVC system, the Model is the
edit buffer, the View is the display, and the
control dispatches keystrokes to the editor and
calls for the display at various times.

In an ideal system the text editing API would be
cleanly separated from the display management.

However, some user operations both modify the buffer
and require adjustments to the view. The general
invariant which separates the buffer from the display
is that the current cursor location be display on
approximately the middle line of the display area.

Some commands such as a mouse click reposition
the cursor (edit buffer) AND change the current screen
line (display) the cursor is shown on (so that in fact the operation
moves the cursor but not the text).

The display is naturally dependent on the edit buffer (since it
has to get the text to display from it!). However if the cursor
is part of the edit buffer then commands like page-up and page-down
move an amount dependent on the number of screen lines. However
the movement might be clipped by the total number of text lines,
so the calculation depends on BOTH the display state and the
edit buffer state.

So again we have an operation which exhibits coupling.

*/


// SDL2 test
include "sdl/SDL2";
include "sdl/SDL_ttf";
include "sdl/SDL_image";
include "./edit_buffer_interface";
include "./edit_display_interface";
include "./edit_controller_interface";

proc init()
{
  if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0  do
    eprintln$ f"Unable to init SDL: %S\n" #SDL_GetError;
    System::exit(1);
  done
  println$ "SDL_init OK";
  if TTF_Init() < 0 do 
    eprintln$ f"Unable to init TTF: %S\n" #TTF_GetError;
    System::exit(1);
  done
  println$ "TTF_init OK";
  if IMG_Init(IMG_INIT_PNG) < 0 do 
    eprintln$ f"Unable to init IMG with PNG: %S\n" #IMG_GetError;
    System::exit(1);
  done
  println$ "IMG_init OK";
}

proc versions ()
{
  begin
    var compiled = #SDL_Compiled_Version;
    var linked = #SDL_Linked_Version;
    println$ f"We compiled against SDL version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against SDL version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #TTF_Compiled_Version;
    var linked = #TTF_Linked_Version;
    println$ f"We compiled against TTF version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against TTF version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

  begin
    var compiled = #IMG_Compiled_Version;
    var linked = #IMG_Linked_Version;
    println$ f"We compiled against IMG version %d.%d.%d ..."
      (compiled.major.int, compiled.minor.int, compiled.patch.int);
    println$ f"But we are linking against IMG version %d.%d.%d."
      (linked.major.int, linked.minor.int, linked.patch.int);
  end 

} 

fun choose_font () = {
  var font_file = "/Library/Fonts/Courier New Bold.ttf";
  var font = TTF_OpenFont (font_file,12);
  if not (TTF_ValidFont font) do
    eprintln$ f"Unable to open TTF font %S\n" font_file;
    System::exit 1;
  done
  TTF_SetFontKerning (font,0);
  var isfixed = TTF_FontFaceIsFixedWidth (font);
  println$ "Opened Font " + font_file + 
    " Facename: " + TTF_FontFaceFamilyName font + 
    (if isfixed>0 then " MONOSPACED" else " VARIABLE WIDTH");
  return font;
}

proc mainline ()
{
  init;
  versions;

  var font = #choose_font;
  var lineskip = TTF_FontHeight(font)+1;
  var vsep = lineskip; 
  var window = SDL_CreateWindow(
    "Felix Editor",
    SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,
    512, 512,
    SDL_WINDOW_SHOWN \| SDL_WINDOW_RESIZABLE)
  ;
  var clock = #Faio::mk_alarm_clock;

  var red = SDL_Color (250u8,0u8, 0u8,0u8);
  var white = SDL_Color (250u8,255u8, 255u8,0u8);
  var black = SDL_Color (0u8,0u8, 0u8,0u8);

  var intro = "Hello from Felix";
  var intro_rendered = TTF_RenderText_Solid (font,intro,red);
  var nullRect = C_hack::null[SDL_Rect];
  var window_surface = SDL_GetWindowSurface window;

  var result = SDL_BlitSurface (intro_rendered, nullRect, window_surface, nullRect); 
  if result != 0 do
    eprintln$ "Unable to blit text to window surface";
    System::exit 1;
  done
  println$ "Blitted Text to Window Surface";
  SDL_FreeSurface intro_rendered;
 
  result = SDL_UpdateWindowSurface window;
  if result != 0 do
    eprintln$ "Unable to update window";
    System::exit 1;
  done

// ------------------------------------------------------------------------------
  var text = load "demos/sdl/sdltest.flx";
  var lines = darray$ varray$ split$ text, char '\n';
  var editor = Dynlink::load-plugin-func1 [edit_buffer_interface, darray[string]] 
    (dll-name="edit_buffer")
  ;
  var display = 
    Dynlink::load-plugin-func1 [edit_display_interface, edit_display_init] 
    (dll-name="edit_display")
  ;
  

// ------------------------------------------------------------------------------

  var ctl = Dynlink::load-plugin-func2 [edit_controller_interface, edit_buffer_interface, edit_display_interface]
    (dll-name="edit_controller")
  ;

  var CTL = #{
    var E = editor lines;
    E.whoami;
    var s = SDL_GetWindowSurface window;
    var dr = SDL_Rect (20,20, s*.w - 40, s*.h - 40);
    var D = display (font=font, editor=E, window=window, r = dr);
    D.whoami;
    return ctl (E,D);
  };
  CTL.whoami;
  CTL.draw;


  // at this stage, editor in a single window
  // extend to many windows later
  var editors = darray[edit_controller_interface] ();
  editors += CTL;
  var editor_index = 0;

  proc select_editor (i:int) 
  {
    if i >= 0 and i < editors.len.int do
      CTL = editors . i;
      editor_index = i;
    done
  }

  fun find_editor_in_window (x:int, y:int) : int = 
  {
    for var i in 0 upto editors.len.int - 1 do
      var r = #(editors.i.get_display_rect);
      if inRect(x,y,r) return i;
    done
    return -1;
  }

  proc vsplit()
  {
    var oldE = CTL.get_editor ();
    var oldD = CTL.get_display ();
    var dr = oldD.get_display_rect ();

    var E = editor #(oldE.get_lines);
    var D = display (font=font, editor=E, window=window, r = dr);
    var h = dr.h/2;
    dr.h = h - vsep/2;
    oldD.set_display_rect dr;
    D.set_display_rect (dr.x, dr.y+h+vsep, dr.w, dr.h).SDL_Rect;
    CTL = ctl (E,D);
    CTL.draw;
    ++editor_index;
    insert (editors, editor_index, CTL);
  }

  proc sswap () 
  {
     var i = editor_index;
     ++i;
     editor_index = if i >= editors.len.int then 0 else i;
     CTL = editors.editor_index;
  }

  proc adjust_panes()
  {
    var surf = SDL_GetWindowSurface window;
    var w = surf*.w - 40;
    var h = surf*.h;
    var vused = 40;
    for var i in 0 upto editors.len.int - 2 do
      var r = #(editors.i.get_display).get_display_rect();
      r.w = w;
      vused += r.h + vsep;
      #(editors.i.get_display).set_display_rect r;
    done
    i = editors.len.int - 1;
    r = #(editors.i.get_display).get_display_rect();
    r.w = w;
    var newh = h - vused;
    if newh > 0 do r.h = newh; done
    #(editors.i.get_display).set_display_rect r;
  }

  // clear whole window to black
  proc clear_window ()
  {
    var surf = SDL_GetWindowSurface window;
    var pixelformat : &SDL_PixelFormat  = surf*.format;
    var bgpixels = SDL_MapRGB(pixelformat,0u8, 0u8, 0u8);
    SDL_ClearClipRect (surf);
    C_hack::ignore$ SDL_FillSurface (surf, bgpixels);
  }

  // draw each pane, then update window from surface
  proc draw_panes()
  {
    for var i in 0 upto editors.len.int - 1 do
      editors.i.draw ();
    done 
    var result = SDL_UpdateWindowSurface window;
    if result != 0 do
      eprintln$ "Unable to update window";
      System::exit 1;
    done
  }

  adjust_panes;
  clear_window;
  getevent:while true do
    draw_panes;

    var e : SDL_Event;
    SDL_PumpEvents;
    C_hack::ignore$ SDL_WaitEvent$ &e;
    match e.type.SDL_EventType with
    | $(SDL_QUIT) =>
      println$ "QUIT";
      break getevent;

    | $(SDL_KEYDOWN) =>
      CTL.set_dotext true;
      var vkey = e.key.keysym.sym;
      //println$ "Keydown " + strmods e.key.keysym.mod + str vkey;
      if e.key.keysym.mod == 0u16 do 
        if vkey == SDLK_KP_5 do CTL.recentre;
        else
          CTL.dispatch_modless_key vkey;
        done
      elif e.key.keysym.mod \& (KMOD_LSHIFT.uint16 \| KMOD_RSHIFT.uint16) != 0u16 do CTL.dispatch_shift_key vkey;
      elif e.key.keysym.mod \& (KMOD_CTRL .uint16 \| KMOD_RCTRL.uint16) != 0u16 do CTL.dispatch_control_key vkey;
      elif e.key.keysym.mod \& (KMOD_LALT.uint16 \| KMOD_RALT.uint16) != 0u16 do 
        if vkey == SDLK_v do vsplit; adjust_panes; clear_window;
        elif vkey == SDLK_s do sswap;
        else
          println "Unknown ALT combo";
        done
        CTL.set_dotext false;
      done

    | $(SDL_KEYUP) => 
      //println$ "Keyup"
      ;
    | $(SDL_TEXTEDITING) =>
      println$ "TextEditing";

    | $(SDL_TEXTINPUT) => CTL.dispatch_text_input e.text;

    | $(SDL_MOUSEBUTTONDOWN) => 
      begin
        var bno = e.button.button;
        var x = e.button.x.int;
        var y = e.button.y.int;
        select_editor$ find_editor_in_window (x,y);
        CTL.begin_mark_selection (x,y);
        //println$ "Mousedown b="+bno.int.str + " x=" + x.str + " y=" + y.str;
      end
    | $(SDL_MOUSEBUTTONUP) => 
      begin
        var bno = e.button.button;
        var x = e.button.x.int;
        var y = e.button.y.int;
        //println$ "Mouseup="+bno.int.str + " x=" + x.str + " y=" + y.str;
        CTL.end_mark_selection (x,y);
      end
    | $(SDL_MOUSEMOTION) => 
      /* println$ "Mousemove"*/ ;
      if e.motion.state != 0u32 do // some button down will do for now
      begin
        var bno = e.button.button;
        var x = e.button.x.int;
        var y = e.button.y.int;
        CTL.extend_selection (x,y);

        //println$ "Mouse move="+bno.int.str + " x=" + x.str + " y=" + y.str;
      end
      done

    | $(SDL_MOUSEWHEEL) => 
      begin
        var y = e.wheel.y.int;
        CTL.pan y;
      end 

    | $(SDL_WINDOWEVENT) => 
        println$ "WindowEvent " + 
          e.window.event.SDL_WindowEventID.str
        ;
        if e.window.event.SDL_WindowEventID == SDL_WINDOWEVENT_RESIZED do
          adjust_panes;
          clear_window;
        done
    | _ => 
      println$ "Event type " + e.type.str;
    endmatch;
  done
  Faio::sleep(clock,1.0);
  SDL_DestroyWindow(window);
  SDL_Quit;
 
}

mainline;
