//Check closures
// closure formation test

// primitive function
fun appl (x:int, f:int * int -> int):int => f (x,x);

print "closure of add primitive ";
print (appl (2, add of (int*int))); endl;

// anonymous variant type constructor as function
typedef Y = 1 + int;
fun exec2(y2:int->Y,a:int):Y= { return  y2 a; }
proc yprint(y:Y) { print "union Y"; }
yprint (exec2(case 1 of Y, 1)); endl;
