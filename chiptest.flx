include "std/strings/parsers";
include "std/control/chips";

var sample = "The quick brown fox.";
var b = Buffer (&sample);
println$ b.get;
b&.next;
println$ b.get;

proc test (s:string) (d:iochip_t[Buffer,Buffer]) (b:Buffer)
{
  println$ "-" * 20;
  println$ "TEST " + s;
  var startinp,startout= mk_ioschannel_pair[Buffer]();
  var endinp,endout= mk_ioschannel_pair[Buffer]();
  circuit
    wire startinp to d.inp
    wire endout to d.out
  endcircuit
  write (startout,b);
  spawn_fthread {
    while true do
      var res = read endinp;
      println$ "RESULT: "+ res.str;
    done
  };
  swait();
}

///////////////////// string match
begin
  // reset
  b=Buffer(&sample);
  device match_the = match_string "The";
  test "string match" match_the b;
end

///////////////////// regexp match

begin
  // reset
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  test "regexp match" match_the b;
end

///////////////////// pipeline

begin
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device match_brown= match_regex (RE2 "brown");
  var parse = list (
    debug_buffer[Buffer] "start",
    match_the, 
    match_white, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown", 
    match_brown)
  ;
  device pl = pipeline_list parse;
  test "pipeline" pl b;
end

///////////////////// Quick alts
begin
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device ta = tryall_list (list (match_the, match_quick));
  test "Quick alts" ta b;
end

///////////////////// optional the, present 
begin 
  var b = Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device maybe = optional (pipeline_list (
    match_the, 
    match_white, 
    debug_buffer[Buffer] "before quick", 
    match_quick,
    debug_buffer[Buffer] "After quick").list);
  test "optional the, present" maybe b;
end

///////////////////// optional the, absent
begin
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device match_brown= match_regex (RE2 "brown");

  var parse1 = list (
    debug_buffer[Buffer] "start1",
    match_the, 
    match_white, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown1", 
    match_brown)
  ;
  device pl1 = pipeline_list parse1;

  var parse2 = list (
    debug_buffer[Buffer] "start2",
    match_the, 
    match_white, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown2", 
    match_brown)
  ;
  device pl2 = pipeline_list parse2;

  var parse3 = list (
    debug_buffer[Buffer] "bugged3",
    match_the, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown3", 
    match_brown)
  ;
  device pl3 = pipeline_list parse3;

  var alts = list (pl1,pl2,pl3);
  device ta = tryall_list alts;

  test "Alternatives" ta b;
end

///////////////////// AAAB
begin
  var AAAB = "AAAB"; 
  var b = Buffer(&AAAB);
  device A = match_string("A");
  device B = match_string("B");
  chip As 
    connector chans 
      pin inp: %<Buffer 
      pin out: %>Buffer
  {
    device As2 = pipeline_list (A,As).list; 
    device Ass = tryall_list (A, As2).list;
    circuit
      wire chans.inp to Ass.inp
      wire chans.out to Ass.out
    endcircuit
  }
  device AsB = pipeline_list (As,B).list;
  test "AAAB" AsB b;
end

///////////////////// AAAB (oneormore_matcher)
begin
  var AAAB = "AAAB"; 
  var b = Buffer(&AAAB);
  device A = match_string("A");
  device B = match_string("B");
  device As = oneormore_matcher A;
  device AsB = pipeline_list (As,B).list;
  test "AAAB (oneormore_matcher)" AsB b;
end

///////////////////// grammar production
begin
  var X = "X = A 'A' A B;";
  var b = Buffer(&X);

  device id = cident_matcher;
  device eq = match_string("=");
  device semi = pipeline_list 
    ([
      debug_buffer[Buffer] "before semi",
      match_string(";"), 
      debug_buffer[Buffer] "after semi"
    ])
  ;
  device str = match_string_literal;
  device w = match_white;
  device sym = tryall_list ([id,str]);
  device wsym = pipeline_list ([w,sym]);
  device wsyms = oneormore_matcher wsym;
  device prod = pipeline_list 
    ([
      w,id,w,eq,wsyms,w,semi
    ])
  ;
  test "grammar production" prod b;
end

///////////////////// capture string match
begin
  println$ "-" * 20;
  println$ "TEST " + "Capture string match (manual)";
  var b=Buffer(&sample);
  device match_the = match_string "The";
  gen show_lexeme (first: Buffer * int, last: Buffer) : Buffer * int =
  {
     var i = first.1;
     var b0 = first.0;
     var sp = b0.sp;
     var s = sp.string;
     var p0 = b0.pos;
     var p1 = last.pos;
     var lexeme = sp.[p0..<p1].string;
     //println$ "Lexeme = '" + lexeme+"'";
     return last,i + 42;
  }

  device captured_the = leaf_capture[Buffer,int] (match_the,show_lexeme); 
  var state = b,99;
  var rin,rout = mk_ioschannel_pair[Buffer * int]();
  var win,wout = mk_ioschannel_pair[Buffer * int]();
  spawn_fthread (captured_the (inp=rin,out=wout));
  write (rout,state);
  var newstate = read win;
  println$ "New state int = " + newstate.1.str;
  swait;
end

////////////////// captured test (manual)
proc captured_test[T] (s:string) (d:iochip_t[Buffer * T,Buffer * T]) (b:Buffer * T)
{
  println$ "-" * 20;
  println$ "TEST " + s;
  var startinp,startout= mk_ioschannel_pair[Buffer * T]();
  var endinp,endout= mk_ioschannel_pair[Buffer * T]();
  circuit
    wire startinp to d.inp
    wire endout to d.out
  endcircuit
  write (startout,b);
  spawn_fthread {
    while true do
      var res = read endinp;
      println$ "RESULT: "+ res.str;
    done
  };
  swait;
}

///////////////////// capture string match (auto)
begin
  var b=Buffer(&sample);
  device match_the = match_string "The";
  gen show_lexeme (first: Buffer * int, last: Buffer) : Buffer * int =
  {
     var i = first.1;
     var b0 = first.0;
     var sp = b0.sp;
     var s = sp.string;
     var p0 = b0.pos;
     var p1 = last.pos;
     var lexeme = sp.[p0..<p1].string;
     //println$ "Lexeme = '" + lexeme+"'";
     return last,i + 42;
  }

  device captured_the = leaf_capture[Buffer,int] (match_the,show_lexeme); 
  captured_test[int] "Captured string match (auto)" captured_the (b,99); 
end

///////////////////// capture pipeline 

begin
  var b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device match_brown= match_regex (RE2 "brown");

  gen show_lexeme (first: Buffer * int, last: Buffer) : Buffer * int =
  {
     var i = first.1;
     var b0 = first.0;
     var sp = b0.sp;
     var s = sp.string;
     var p0 = b0.pos;
     var p1 = last.pos;
     var lexeme = sp.[p0..<p1].string;
     //println$ "Lexeme = '" + lexeme+"'";
     return last,i + 42;
  }

  device captured_the = leaf_capture[Buffer,int] (match_the,show_lexeme); 
  device captured_white = leaf_capture[Buffer,int] (match_white,show_lexeme); 
  device captured_quick = leaf_capture[Buffer,int] (match_quick,show_lexeme); 
  device captured_brown = leaf_capture[Buffer,int] (match_brown,show_lexeme); 


  var parse = list (
    captured_the, 
    captured_white, 
    captured_quick, 
    captured_white, 
    captured_brown)
  ;
  device pl = pipeline_list parse;
  captured_test[int] "pipeline" pl (b,99);
end

begin
  var b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device match_brown= match_regex (RE2 "brown");



  device captured_the = leaf_capture[Buffer,ll_t] (match_the,push_entry); 
  device captured_white = leaf_capture[Buffer,ll_t] (match_white,skip_entry); 
  device captured_quick = leaf_capture[Buffer,ll_t] (match_quick,push_entry); 
  device captured_brown = leaf_capture[Buffer,ll_t] (match_brown,push_entry); 


  var parse = list (
    captured_the, 
    captured_white, 
    captured_quick, 
    captured_white, 
    captured_brown)
  ;
  device pl = pipeline_list parse;
  var init = Empty[lsexpr_t];
  captured_test[ll_t] "pipeline lsexpr" pl (b,init);
end

///////////////////// expression  statement (recognize and tokenise)
begin
  var sample = "1+2+3-4;";
  var b = Buffer &sample;
  device plus = match_string "+";
  device minus = match_string "-";
  device digit = match_regex "[0-9]".RE2;
  device semi = match_string(";"); 

  device cap_plus = leaf_capture[Buffer,ll_t] (plus,push_entry);
  device cap_minus = leaf_capture[Buffer,ll_t] (minus,push_entry);
  device cap_int = leaf_capture[Buffer,ll_t] (digit,push_entry);
  device cap_semi = leaf_capture[Buffer,ll_t] (semi,push_entry);

  chip expr
    connector io
      pin inp: %< (Buffer * ll_t)
      pin out: %> (Buffer * ll_t)
  {
    device add = pipeline_list ([cap_int,cap_plus,expr]);
    device sub = pipeline_list ([cap_int,cap_minus,expr]);
    device expr1 = tryall_list ([cap_int, add, sub]);
    circuit
      wire io.inp to expr1.inp
      wire io.out to expr1.out
    endcircuit
  }
  device statement = pipeline_list ([expr,cap_semi]);
  var init = Empty[lsexpr_t];
  captured_test[ll_t] "Expression statement (recognize and tokenize)" statement (b,init);
end
///////////////////// expression  statement (parse to AST)

begin
  var sample = "1+2+3-4;";
  var b = Buffer &sample;
  device plus = match_string "+";
  device minus = match_string "-";
  device digit = match_regex "[0-9]".RE2;
  device semi = match_string(";"); 

  device cap_plus = leaf_capture[Buffer,ll_t] (plus,push_entry);
  device cap_minus = leaf_capture[Buffer,ll_t] (minus,push_entry);
  device cap_int = leaf_capture[Buffer,ll_t] (digit,push_entry);
  device cap_semi = leaf_capture[Buffer,ll_t] (semi,push_entry);

  // pop 3 elements off the parser stack and push
  // one on; REDUCE action
  fun ntgroup (lab: string, lst: ll_t): ll_t =>
    match lst with
    | l!op!r!rest =>
    LS_expr::Tree (lab, ([r,l])) ! rest
  ;

  chip capnt (s:string)
    connector io
    pin inp: %< (Buffer * ll_t)
    pin out: %> (Buffer * ll_t)
  {
    while true do
      var b,lst = read io.inp;
      write (io.out, (b,ntgroup (s,lst)));
    done
  }

  chip expr (rcnt:int)
    connector io
      pin inp: %< (Buffer * ll_t)
      pin out: %> (Buffer * ll_t)
  {
    //println$ "Expr level " + rcnt.str;
    if rcnt > 5 return; // Fail .. will this crap something out??
    device expr_action = capnt "EXPR";
    device add = pipeline_list ([expr (rcnt+1),cap_plus, cap_int, capnt "ADD"]);
    device sub = pipeline_list ([expr (rcnt+1),cap_minus,cap_int, capnt "SUB"]);
    device expr1 = tryall_list ([cap_int, add, sub]);
    circuit
      wire io.inp to expr1.inp
      wire io.out to expr1.out
    endcircuit
  }
  device statement = pipeline_list ([expr 0,cap_semi]);
  var init = Empty[lsexpr_t];
  captured_test[ll_t] "Expression statement (parse)" statement (b,init);
end

// test a memo chip
// Given a chip which repeatedly reads an input and writes 0 or more
// outputs, we aim to produce a memo wrapper chip which records
// all the outputs for each given input.
//
// if the input is records, the chip replays the recording, otherwise
// it runs the argument chip, collecting the outputs, records them,
// and emits them
//
// For this to work the input type D must be equality comparable at least.
//
// Concerning the outputs of type C, we have an issue: what happens if
// some output is repeated? Do we have to replay the outputs in order?
//
// I say yes for the moment.
//
// Now, a technical problem: how to gather all outputs?
// We ONLY have one tool for that, swait.

// Our memo is a global mutable cache so we have to use a pointer
// to it

// The cache is a list of pairs, the first being a unique D value,
// and the second being a list of C.

fun memo_find[D,C] (memo: list[D * list[C]]) (key:D) : opt[list[C]] =
{
//println$ "-------";
//  println$ "Searching memo for key " + key.str;
//  println$ "Memo is ";
//  for entry in memo do
//    var k,v = entry;
//    println$ "Key=" + k.str;
//  done
  var maybe = find memo key;
//  match maybe with
//  | Some _ => println$ " ** FOUND";
//  | None => println$  " ** NOT FOUND";
//  endmatch;
//println$ "-------";
  return maybe; 
}

chip replay[D,C with Eq[D]] (name:string) (memo: &list[D * list[C]]) (a: iochip_t[D,C])
  connector io
    pin inp: %<D
    pin out: %>C
{
//println$ "Replay running .. " + name;
  while true do
//println$ "Replay reading an input";
    var x = read io.inp;
//println$ "Memo=" + (*memo).str;
    var maybe : opt[list[C]] = memo_find (*memo) x;
    match maybe with 
    | Some lst =>
//println$ "Using memo " + name + ": "+ x.str;
      for y in lst perform write (io.out,y);
    | None =>
      var sched = fibre_scheduler ();
      var rin,win = mk_ioschannel_pair[D]();
      var rout,wout = mk_ioschannel_pair[C]();
      spawn_fthread sched (a (inp=rin,out=wout));
      var gather = Empty[C];
      spawn_fthread sched { 
        while true do 
          var x = read rout;
          gather = x ! gather; // cons onto output store
        done
      };
      spawn_fthread sched {write (win, x);};
      sched.run;
      delete_fibre_scheduler sched;
      gather = rev gather; // reverse list 
      maybe = memo_find (*memo) x;
      match maybe with
      | None =>
//println$ "Saving NEW memo " +name ": " + x.str + " -> " + gather.str;
      memo <- (x,gather) ! *memo;
      for y in gather perform write (io.out,y);

      | Some old_values =>
//println$ "GOT SOME OLD VALUES for key " + x.str; 
//println$ "OLD VALUES=" + old_values.str;
//println$ "NEW VALUES=" + gather.str;
        var new_values = Empty[C];
        for y in gather do
          if not (y in old_values) perform new_values = y ! new_values;
        done
        if new_values.len > 0uz do
//println$ "MERGING memo " + name +": " + x.str + "->" + new_values.str;
//println$ "MERGED VALUES=" + new_values.str;
        var stripped_memo = List::filter (fun (k:D,v:list[C]) => not (k == x)) (*memo);
        memo <- (x,new_values+old_values) ! stripped_memo;
        done
        for y in gather perform write (io.out,y);
      endmatch;
    endmatch;
  done
}

// Now to test it we use a dumb idea: lets make a chip
// that takes a memo and replays it. The idea, simply,
// is to then wrap that chip in our reply chip, and it should
// produce related memo as follows: each actual input
// generates an entry. If all the keys in the original
// memo are sent as inputs, we should get the same output memo.
// If we send an input NOT in the original memo, the output
// memo will contain additional entries whose key selects
// an empty list as data.

chip alist [D,C with Eq[D]] (m: list[D * list[C]])
  connector io
    pin inp: %<D
    pin out: %>C
{
  while true do
    var x = read io.inp;
    var maybe : opt[list[C]]= find m x;
    match maybe with
    | None => ; // no output
    | Some lst => 
      for y in lst perform write (io.out,y);
    endmatch;
  done
}

// first test alist
begin
  var sample = ([0,1,2,3]);
  var response  = ([
    (0,Empty[int]),
    (1,([10])),
    (2,([20,21])),
    (3,([30,31,32]))
  ]);
  device src = source_from_list sample;
  device z = alist response;
  device sink = debug_sink[int] "Result";
  circuit
    connect src.out, z.inp
    connect z.out, sink.inp
  endcircuit
  swait;
end

// now run it through memoiser 

begin
  var sample = ([0,1,2,3,2,4,2,1]);
  var response  = ([
    (0,Empty[int]),
    (1,([10])),
    (2,([20,21])),
    (3,([30,31,32]))
  ]);
  var memo = Empty[int * list[int]];

  device target = alist response;
  device rep = replay "sample" &memo target;
  device src = source_from_list sample;
  device sink = debug_sink[int] "WResult";
  circuit
    connect src.out, rep.inp
    connect rep.out, sink.inp
  endcircuit
  swait;
  println$ "Memo = " + memo.str;
  swait;
  println$ "Memo = " + memo.str;
end


///////////////////// expression  statement (parse to AST, memo)
begin
  var tstart = time();
  var sample = "1+2+3-4;";
  var b = Buffer &sample;
  device plus = match_string "+";
  device minus = match_string "-";
  device digit = match_regex "[0-9]".RE2;
  device semi = match_string(";"); 

  //device cap_plus = leaf_capture[Buffer,ll_t] (plus,push_entry);
  parser cap_plus = "+";
  device cap_minus = leaf_capture[Buffer,ll_t] (minus,push_entry);
  device cap_int = leaf_capture[Buffer,ll_t] (digit,push_entry);
  device cap_semi = leaf_capture[Buffer,ll_t] (semi,push_entry);

  // pop 3 elements off the parser stack and push
  // one on; REDUCE action
  fun reduce_binop (lab: string) (lst: ll_t): ll_t =>
    match lst with
    | l!op!r!rest =>
    LS_expr::Tree (lab, ([r,l])) ! rest
  ;

  chip capnt_general (s:string) (ntgroup: string -> ll_t -> ll_t)
    connector io
    pin inp: %< (Buffer * ll_t)
    pin out: %> (Buffer * ll_t)
  {
    while true do
      var b,lst = read io.inp;
      write (io.out, (b,ntgroup s lst));
    done
  }

  fun binop (s:string) => capnt_general s reduce_binop;

  typedef memo_key_t = Buffer * ll_t;
  typedef memo_data_t = memo_key_t;
  typedef memo_pair_t = memo_key_t * list[memo_data_t];
  typedef memo_t = list[memo_pair_t];
 
  var memo : memo_t = Empty [memo_pair_t];

  chip expr (rcnt:int)
    connector io
      pin inp: %< (Buffer * ll_t)
      pin out: %> (Buffer * ll_t)
  {
    //println$ "Expr level " + rcnt.str;
    if rcnt > 200 return; // Fail .. will this crap something out??
    device expr_action = capnt_general "EXPR";
    device mexpr = replay[memo_key_t, memo_data_t] "expr" &memo (expr (rcnt+1));
    //device add = pipeline_list ([mexpr,cap_plus, cap_int, capnt "ADD"]);
    //device add = pipeline_list ([mexpr,cap_minus, cap_int, capnt "SUB"]);
    //device expr1 = tryall_list ([cap_int, add, sub]);
    device capnt_sub = binop "SUB";
    parser add = mexpr "+" cap_int {binop "ADD"};
    parser sub = mexpr cap_minus cap_int capnt_sub;
    parser expr1 = cap_int | add | sub;
    circuit
      wire io.inp to expr1.inp
      wire io.out to expr1.out
    endcircuit
  }
  //device statement = pipeline_list ([expr 0,cap_semi]);
  parser statement = {expr 0} ";";
  var init = Empty[lsexpr_t];
  captured_test[ll_t] "Expression statement (parse, memo)" statement (b,init);
  var tend = time();
  println$ f"elapsed time %3.3f" (tend - tstart);
end


///////////////////// expression2 statement (parse to AST, memo)
begin
  var tstart = time();
  var sample = "6*7+1/2-4*2*5+8;";
  var b = Buffer &sample;
  device digit = match_regex "[0-9]".RE2;

  device cap_int = leaf_capture[Buffer,ll_t] (digit,push_entry);

  // pop 3 elements off the parser stack and push
  // one on; REDUCE action
  fun reduce_binop (lab: string) (lst: ll_t): ll_t =>
    match lst with
    | l!op!r!rest =>
    LS_expr::Tree (lab, ([r,l])) ! rest
  ;

  chip capnt_general (s:string) (ntgroup: string -> ll_t -> ll_t)
    connector io
    pin inp: %< (Buffer * ll_t)
    pin out: %> (Buffer * ll_t)
  {
    while true do
      var b,lst = read io.inp;
      write (io.out, (b,ntgroup s lst));
    done
  }

  fun binop (s:string) => capnt_gRESULT: (@8, list(;, SUB(list(ADD(list(ADD(list(1, 2)), 3)), 4))))
elapsed time 0.221eneral s reduce_binop;

  typedef memo_key_t = Buffer * ll_t;
  typedef memo_data_t = memo_key_t;
  typedef memo_pair_t = memo_key_t * list[memo_data_t];
  typedef memo_t = list[memo_pair_t];
 
  var expr_memo : memo_t = Empty [memo_pair_t];
  var factor_memo : memo_t = Empty [memo_pair_t];

  chip expr (rcnt:int)
    connector io
      pin inp: %< (Buffer * ll_t)
      pin out: %> (Buffer * ll_t)
  {
//println$ "Expr " + rcnt.str;
    if rcnt > 200 return; // Fail .. will this crap something out??
    device mexpr = replay[memo_key_t, memo_data_t] "expr" &expr_memo (expr (rcnt+1));
    parser add = mexpr "+" {factor 0} {binop "ADD"};
    parser sub = mexpr "-" {factor 0} {binop "SUB"}; 
    parser expr1 = add | sub | {factor 0};
    circuit
      wire io.inp to expr1.inp
      wire io.out to expr1.out
    endcircuit
  }

  chip factor (rcnt:int)
    connector io
      pin inp: %< (Buffer * ll_t)
      pin out: %> (Buffer * ll_t)
  {
//println$ "Factor " + rcnt.str;
    if rcnt > 200 return; // Fail .. will this crap something out??
    device mfactor = replay[memo_key_t, memo_data_t] "factor" &factor_memo (factor (rcnt+1));
    parser mul = mfactor "*" cap_int {binop "MUL"};
    parser div = mfactor "/" cap_int {binop "DIV"}; 
    parser factor1 = mul | div | cap_int;
    circuit
      wire io.inp to factor1.inp
      wire io.out to factor1.out
    endcircuit
  }


  parser statement = {expr 0} ";";
  var init = Empty[lsexpr_t];
  captured_test[ll_t] "Expression2 statement (parse, memo)" statement (b,init);
  var tend = time();
  println$ f"elapsed time %3.3f" (tend - tstart);
end


