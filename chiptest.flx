include "std/strings/parsers";
include "std/control/chips";

var sample = "The quick brown fox.";
var b = Buffer (&sample);
println$ b.get;
b&.next;
println$ b.get;

proc test (s:string) (d:iochip_t[Buffer,Buffer]) (b:Buffer)
{
  println$ "-" * 20;
  println$ "TEST " + s;
  var startinp,startout= mk_ioschannel_pair[Buffer]();
  var endinp,endout= mk_ioschannel_pair[Buffer]();
  circuit
    wire startinp to d.inp
    wire endout to d.out
  endcircuit
  write (startout,b);
  spawn_fthread {
    while true do
      var res = read endinp;
      println$ "RESULT: "+ res.str;
    done
  };
  swait();
}

///////////////////// string match
begin
  // reset
  b=Buffer(&sample);
  device match_the = match_string "The";
  test "string match" match_the b;
end

///////////////////// regexp match

begin
  // reset
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  test "regexp match" match_the b;
end

///////////////////// pipeline

begin
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device match_brown= match_regex (RE2 "brown");
  var parse = list (
    debug_buffer[Buffer] "start",
    match_the, 
    match_white, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown", 
    match_brown)
  ;
  device pl = pipeline_list parse;
  test "pipeline" pl b;
end

///////////////////// Quick alts
begin
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device ta = tryall_list (list (match_the, match_quick));
  test "Quick alts" ta b;
end

///////////////////// optional the, present 
begin 
  b = Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device maybe = optional (pipeline_list (
    match_the, 
    match_white, 
    debug_buffer[Buffer] "before quick", 
    match_quick,
    debug_buffer[Buffer] "After quick").list);
  test "optional the, present" maybe b;
end

///////////////////// optional the, absent
begin
  b=Buffer(&sample);
  device match_the = match_regex (RE2 "The");
  device match_quick = match_regex (RE2 "quick");
  device match_brown= match_regex (RE2 "brown");

  var parse1 = list (
    debug_buffer[Buffer] "start1",
    match_the, 
    match_white, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown1", 
    match_brown)
  ;
  device pl1 = pipeline_list parse1;

  var parse2 = list (
    debug_buffer[Buffer] "start2",
    match_the, 
    match_white, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown2", 
    match_brown)
  ;
  device pl2 = pipeline_list parse2;

  var parse3 = list (
    debug_buffer[Buffer] "bugged3",
    match_the, 
    match_quick, 
    match_white, 
    debug_buffer[Buffer] "Before brown3", 
    match_brown)
  ;
  device pl3 = pipeline_list parse3;

  var alts = list (pl1,pl2,pl3);
  device ta = tryall_list alts;

  test "Alternatives" ta b;
end

///////////////////// AAAB
begin
  var AAAB = "AAAB"; 
  b = Buffer(&AAAB);
  device A = match_string("A");
  device B = match_string("B");
  chip As 
    connector chans 
      pin inp: %<Buffer 
      pin out: %>Buffer
  {
    device As2 = pipeline_list (A,As).list; 
    device Ass = tryall_list (A, As2).list;
    circuit
      wire chans.inp to Ass.inp
      wire chans.out to Ass.out
    endcircuit
  }
  device AsB = pipeline_list (As,B).list;
  test "AAAB" AsB b;
end

///////////////////// AAAB (oneormore_matcher)
begin
  var AAAB = "AAAB"; 
  b = Buffer(&AAAB);
  device A = match_string("A");
  device B = match_string("B");
  device As = oneormore_matcher A;
  device AsB = pipeline_list (As,B).list;
  test "AAAB (oneormore_matcher)" AsB b;
end

///////////////////// grammar production
begin
  var X = "X = A 'A' A B;";
  var b = Buffer(&X);

  device id = cident_matcher;
  device eq = match_string("=");
  device semi = match_string(";");
  device str = match_string_literal;
  device w = match_white;
  device sym = tryall_list ([id,str]);
  device wsym = pipeline_list ([w,sym]);
  device wsyms = oneormore_matcher wsym;
  device prod = pipeline_list 
    ([
      w,id,w,eq,wsyms,w,semi
    ])
  ;
  test "grammar production" prod b;
end


///////////////////// capture string match
begin
  // reset
  b=Buffer(&sample);
  device match_the = match_string "The";
  gen show_lexeme (first: Buffer * int, last: Buffer) : Buffer * int =
  {
     var i = first.1;
     var b0 = first.0;
     var sp = b0.sp;
     var s = sp.string;
     var p0 = b0.pos;
     var p1 = last.pos;
     var lexeme = sp.[p0..<p1].string;
     println$ "Lexeme = '" + lexeme+"'";
     return last,i + 42;
  }

  device captured_the = leaf_capture[int] (match_the,show_lexeme); 
  var state = b,99;
  var rin,rout = mk_ioschannel_pair[Buffer * int]();
  var win,wout = mk_ioschannel_pair[Buffer * int]();
  spawn_fthread (captured_the (inp=rin,out=wout));
  write (rout,state);
  var newstate = read win;
  println$ "New state int = " + newstate.1.str;
end
swait;

