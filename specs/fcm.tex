\documentclass{report}
\title{Felix Compilation Model}
\author{John Skaller}
\begin{document}
\maketitle
\tableofcontents

\chapter{Overview}
Felix is a cross-cross compiler toolkit comprising a number of tools.
The supplied base tools are compiled programs and scripts:
\begin{verbatim}
flx_pkgconfig     # package manager
flxg              # Felix compiler
flxp              # parser debug
flxm              # syntax macro debug
flxd              # desugaring debug
flxb              # binding debug
flx               # bash command line harness (Unix) 
flx.bat           # CMD.EXE command line harness (Windows)
flx.py            # Python 2.4 command line harness (Platform independent)
flx_elkhound      # GLR parser generator
flxcc             # C header wrapper generator
flx_run           # basic dynamic program driver
flx_arun          # driver with asynchronous I/O support
tools/webserver   # a demo webserver
\end{verbatim}
%
The client must supply a C++ compiler. GNU \verb%g++% and Microsoft
\verb%MSVC++% are both supported. The compilers are required to implement
a reasonable subset of ISO C 89 and ISO C++, ISO C99 support is highly
desirable.

Python is not required, but can be used to run platform independent
command line and GUI interface scripts and is therefore considered
desirable. Version 2.4 or above is recommended. The scripts will
not run with Python 3 due to unfortunate incompatibilities with
the print statement.

\section{Platform model}
Compilation terminology specifies
four potentially distinct platforms. 

\begin{verbatim}
felix(build) --[flxg]--> C++(host) --[g++]--> binary(target) --[ship]--> flx_run(run)
\end{verbatim}

The {\em build} platform is the one
on which the Felix code is developed, and the Felix \verb%flxg% translator is usually run.
It generates platform independent ISO C++ code from the input Felix code.

This code can then be shipped to a second machine on which the C++ code
is compiled, this is called the {\em host} machine. The Felix translator
could also be run on this platform. Generally the build and host platforms
are identified and referred to as the host platform.

The C++ compiler targets a third machine call the {\em target}
platform. Many C++ compilers provide the ability to target other platforms.
For example it is possible on Linux to use a version of \verb%gcc% which will
generate binaries for Microsoft Windows. On Windows itself, there are two
common platforms: a 32 bit and a 64 bit environment, and \verb%MSVC++% 
cross compilers exist which run in one of these environments targetting
the other. Cygwin is another cross compilation environment.

After the required binaries are created, they can be shipped to a fourth
machine called the {\em run} platform which provides the actual execution environment. 
Although this machine must be compatible with the target model, it is often a significantly
distinct machine. For example the Debian autobuilder provides a very specific environment
for generating binary packages, quite distinct from the client Linux on which the
binaries will actually be run. The target and run machines are usually identified.

Felix provides some convenient tools for integrating the development and
execution of programs where all the platforms are identified. In other
cases the developers and their clients must organise the scheduling of
the software process using the component tools directly.

\subsection{File name conventions}
\begin{verbatim}
*.flx                      # general felix code
*.expect                   # expected stdout of program (for regression testing)
*.output                   # actual output of program (for regression testing)

*.flxh                     # felix macro package headers
*.flxh.syncache            # cached grammar
*.par                      # cached parse tree
*.hpp                      # generated and library C++ headers
*.cpp                      # generated C++ implementation
*_parser99.cpp             # generated Elkhound parser implementation (C++)
*_lexer99.cpp              # generated Elkhound lexer implementation (C++)
*.rtti                     # generated run time type information (C++)
*.includes                 # generated collated C++ header includes
*_ctors.cpp                # generated C++ constructors
*.why                      # generated Ergo format theorem proving code
*.resh                     # generated list of abstract resource requirements
*.fpc                      # resource database row mapping abstract to concrete resources

*_static.o                 # generated static link object files (Unix)
*_static.obj               # generated static link object files (Windows)
*_dynamic.o                # generated dymamic link object files (Unix)
*_dynamic.obj              # generated dynamic link object files (Windows)

lib*_static.a              # supplied static link libraries (Unix)
*_static.lib               # supplied static link libraries (Windows)

lib*_dynamic.so            # supplied dynamic link libraries (Unix)
lib*_dynamic.dylib         # supplied dynamic link libraries (OSX)
_dynamic.dll               # supplied dynamic link libraries (Windows)
_dynamic.exp               # supplied dynamic link export thunks (Windows)

<none>                     # generated statically link program (Unix)
*.exe                      # generated statically linked programs (Windows)

*.so                       # generated dymamic link program (Unix)
*.dylib                    # generated dynamic link program (OSX)
*.dll                      # generated dynamic link program (Windows)
\end{verbatim}

\chapter{Command Line Interface}
The Felix compiler is designed to be used in conjunction with a host management
program, various Felix system libraries, and user supplied application support
libraries. The system is fully integrated by the command line processor 
\verb%flx% which organises the compilation, linking, and execution of a 
Felix script file. The system is designed to have the look and feel of a
conventional scripting language such as Perl or Python, driving the Felix compiler,
C++ compiler and linker without need for complex options or specification of
resource locations.

\section{Basic operation}
Most programs can be run simply by:
%
\begin{verbatim}
flx filename
\end{verbatim}
%
or equivalently
%
\begin{verbatim}
flx filename.flx
\end{verbatim}

On Unix, if the first line of the file is
%
\begin{verbatim}
#!/usr/bin/env flx
\end{verbatim}
%
and the file is marked as executable, then the script can be run just by
invoking the filename:
%
\begin{verbatim}
filename.flx
\end{verbatim}

A similar facility is available for Microsoft Windows.

\section{Selecting Felix Version}
Felix support an arbitrary number of independent Felix installations.
All of the program files, apart from the command line processor \verb%flx%, 
can be installed in a single directory. This directory will typically
be named for the Felix version, for example:
%
\begin{verbatim}
felix-1.1.4_rc4
\end{verbatim}
%
describes Felix version 1.1.4, release candidate 4. On Unix these are
typically installed in one of
%
\begin{verbatim}
/usr/lib
/usr/local/lib
/opt/felix
${HOME}/lib
\end{verbatim}
%
or some such place where packages are installed. The \verb%flx% script
will usually have a hard coded constant refering to the installation location.

\subsection{Overriding the version on the command line}
This can be overridden by specifying the installation directory using the
\verb%--test% option:
%
\begin{verbatim}
flx --test filename
flx --test=/opt/felix-1.1.4_rc4 filename
\end{verbatim}
%
The first variant specifies the current directory, and is primarily used by
developers testing the system. The second variant can be used to specify a 
particular installation, allowing an upgraded system to be installed without
compromising existing working programs.

\subsection{Overriding the version with environment variables}
Felix also provides an environment variable \verb%FLX_INSTALL_DIR% 
which can be used to override the installation directory:
%
\begin{verbatim}
FLX_INSTALL_DIR=/opt/felix-1.1.4_rc4 flx filename
\end{verbatim}

On Unix, this can also be set in a program file like:
%
\begin{verbatim}
#!/usr/bin/env FLX_INSTALL_DIR=/opt/felix-1.1.4_rc4 flx
\end{verbatim}
%
to ensure a program is run with a particular version.

\subsection{Querying the Version}
The version of the \verb%flx% script can be found by:
%
\begin{verbatim}
flx --version
\end{verbatim}
Note that this is the version of the {\em flx script} and not
the version of the installation!

\subsubsection{Alternate driver scripts}
Felix provides three implementations of the driver script:
\verb%flx% is written for Unix \verb%bash%, \verb%flx.bat% is written for Windows
\verb%CMD.EXE% shell, and \verb%flx.py% is written for Python and should operate
on all platforms where Python is installed.

\subsubsection{Getting Help}
In GNU tradition, some help on the command line can be obtained by
simply typing
%
\begin{verbatim}
flx
\end{verbatim}
%
which will reply
\begin{verbatim}
usage: flx [options] filename
\end{verbatim}
%
More extensive help can be obtained on Unix by 
\begin{verbatim}
flx --help
\end{verbatim}
%
which invokes the \verb%man% processor for the main
Felix man page. Other documentation is to be found in the \verb%doc%
directory of the installation.

\subsection{Linkage model}
Felix supports two linkage models: dynamic and static.
Dynamic linkage is the default if the target platform supports it.
Some platforms, such as embedded systems, do not support dynamic
linkage. Other platforms, notable Microsoft Windows, and increasingly
Linux systems, do not provide static link versions of important libraries,
and so dymamic linkage is mandatory.

\subsubsection{Static Linkage}
In the static linkage model, Felix generates C++ code which is compiled
to an object file, extension \verb%.o% on Unix or \verb%.obj% on Windows.
This file is then linked against various libraries, typically \verb%.a%
files on Unix, or \verb%.lib% files on Windows. All Felix built static
linkage files have the suffix \verb%_static% added to the library name,
for example:
%
\begin{verbatim}
lib/rtl/libflx_gc_static.a
\end{verbatim}
provides the garbage collector library in static link form on Unix.
Note the prefix \verb%lib% which Unix favours. On Cygwin the prefix
is \verb%cyg%, whereas Windows does not use a prefix.
%
The \verb%_static% suffix is essential to prevent {\em smart} linkers
such as Unix \verb%ld% from linking with either static or dynamic linkage
depending on availability, and thereby producing unexpected program form,
corrupted programs, or subsequently failing for hard to understand reasons
when other libraries are not available in static link format.

Static linkage can be invoked by
\begin{verbatim}
flx --static filename
\end{verbatim}
%
however it will be chosen by default if the build is configured so as not
to support dynamic linkage.

Static linkage creates a standalone statically linked executable program
with the basename of the file on Unix, and with extension \verb%.EXE%
on Windows.

Static link programs are sometimes faster than dynamic linked
programs, and are easier to ship. However they're harder to upgrade
to work with new system libraries. Note some platforms (such as Linux)
do not statically link the C library even in the static link model.
Other platforms always statically link thunks, even when linking
dynamically, notably Windows.

Finally note some Felix features such as dynamic loading of
plugins do not work with the static link model.

\subsubsection{Dynamic Linkage}
Dynamic linkage is the default and preferred linkage model for Felix.
In this model, not only are the support libraries dynamic link libraries
(DLLs) but the user Felix program itself is linked as a DLL. The program is 
invoked by running a driver mainline, which loads the user DLL code using
a dynamic function call: \verb%dlopen()% on Unix, or \verb%LoadLibrary% 
on Windows. 

These DLLs have several prescribed entry points which are then
invoked by the driver program to create the global data object (thread frame),
initialise it, run the program, and finally destroy the object. 
The mechanism is the same for static linkage, except that the entry points
are looked up by string name using \verb%dlsym()% on Unix or \verb%GetProcAddress%
on Windows.

All Felix built dynamic
linkage files have the suffix \verb%_dynamic% added to the library name,
for example:
%
\begin{verbatim}
lib/rtl/libflx_gc_dynamic.so
\end{verbatim}
provides the garbage collector library in dynamic link form on Unix.

\subsection{Drivers}
The mainline program used to run user Felix code is similar for both
static and dynamic linkage, except for the mechanism for locating
the user entry points. However Felix provides two versions of the driver
as standard. 

The driver \verb%flx_run% is the most basic one and has provides support
for basic operations including multi-threading. 

The driver \verb%flx_arun% is more advanced, and provides support for asynchronous
operations, particularly socket I/O.

Felix automagically calculates which driver is required for user code and invokes
that driver. Custom drivers can also be written but are beyond the scope of
this document.

The driver program is roughly equivalent to a scripting language interpreter,
in that it provides a regular interface to native operating system facilities,
and provides and event loop for synchronising program component execution.
Note however Felix generates ultra-high performance native code, and the driver
switches context extremely fast, much faster than native operating system
pre-emptive threading.

\subsection{Cached Compilation}
The Felix command line script automagically caches the results of a compilation.
The first time you execute a script, it will take some time to translate
to C++ and then compile and link the C++ code. The second time you do this on
an unmodified file, the binary code created by the first compilation will
be invoked directly. If you have changed a file on which you program depends,
but not changed the main Felix program file itself, the CLI processor may
mistakenly run the code without recompiling it. In this case you can force
a complete rebuild using the \verb%--force% option:
%
\begin{verbatim}
flx --force filename
\end{verbatim}

It is also possible to perform only some of the compilations steps as follows:
\begin{verbatim}
flx -c filename
\end{verbatim}
%
compiles and links the program, but does not run it.
%
\begin{verbatim}
flx --nofelix filename
\end{verbatim}
compiles the C++ code, links it, and runs it, but does not run the Felix
compiler to generate the C++ code, instead it uses the C++ code already there.
This is useful if you want to edit the generated C++, in particular is you wish
to add C++ debugging such as \verb%printf()% statements into the C++ to help
locate a bug.

\section{Ad Hoc Resource Management}
It is sometimes useful to compile and link with additional resources
such as extra Felix files, extra C++ header files, extra libraries,
or extra object files. In addition, some extra controls over compilation
and linkage may be required. Please note this feature is {\em not desirable}
and there is generally a much better way to support automatic resource
location using a resource database, which is described subsequently.

The following options can also be provided on the command line:

\begin{verbatim}
-DMACRO
\end{verbatim}
adds a macro to the C++ compilation.
\begin{verbatim}
*.c *.cxx *.cpp
\end{verbatim}
adds a file to the compilation and link step.
\begin{verbatim}
*.a *.o *.lib *.obj
\end{verbatim}
adds a file to the link step.
\begin{verbatim}
-Idir
\end{verbatim}
adds a directory to both the Felix and C++ include file compilation search
paths.
\begin{verbatim}
-llibrary
\end{verbatim}
adds a library to the link step,
\begin{verbatim}
-Ldir
\end{verbatim}
adds a directory to the linker library search path 
\begin{verbatim}
--nostdlib
\end{verbatim}
omits the standard Felix libraries from the link step.
\begin{verbatim}
--nostdimport
\end{verbatim}
omits the standard Felix library from the Felix compilation step.
This option is used to compile a Felix program in fully raw mode,
with no standard definitions. On the other hand
\begin{verbatim}
--import=filename
\end{verbatim}
can be used to import an additional file automagically to each 
Felix file, this option can be used with \verb%--nostdimport%
to replace the standard library with custom or patched libraries.

The special option:
\begin{verbatim}
-<anything>
\end{verbatim}
which is a dash followed by anything not recognized is assumed to
be a switch for the underlying C++ compiler and linker and is
passed to both. Using this feature is not recommended as the
set of options \verb%flx% supports may change.

\subsection{Optimisation}
Felix normally optimised heavily by default. The option
\begin{verbatim}
--noinline
\end{verbatim}
can be used to turn off inlining completely. This is strongly discouraged
as some essential semantics are effected by the inlining pass. Instead
please use
\begin{verbatim}
--inline=999
\end{verbatim}
to specify the maximum number of lines a function can have
and still be inlined. Specifying a small number such as 2 will
effective ensure significant functions are not inlined.
The default is 100. The exact meaning of {\em line} is not specified.

\subsection{debugging}
The switch
\begin{verbatim}
--debug
\end{verbatim}
enables full debugging. This includes debugging the Felix compiler operation
as well as debugging the behaviour of the executable whilst running. This option
produces a very large amount of information most of which is primarily useful
only to an expert user or the Felix developers.

The CLI itself can be traced by
\begin{verbatim}
--echo
\end{verbatim}
which echos out most of the commands it is executing so you can
trace the build process and flags being used.

\chapter{Resource Management Model}
Felix has an advanced resource management model which is designed
to allow programs to build automatically without need to specify
any additional libraries on the command line whilst at the same
time leaving these programs entirely portable.

This is achieved by requiring programs to specify the abstract
resources they require, whilst the client is required to establish
bindings from the abstract resources to concrete ones in their
environment. For example an abstract library called \verb%faio%
may be required by a program \verb%myprog%, so the program must include a 
directive:
\begin{verbatim}
requires package "faio";
\end{verbatim}
This causes the Felix compiler to emit a file \verb%myprog.resh%
which contains the line
\begin{verbatim}
faio
\end{verbatim}
amoung others. The CLI reads this file, and then it searches for
the file
\begin{verbatim}
faio.fpc
\end{verbatim}
in the current package configuration path. By default this is the
\verb%config% directory of the current installation. That file
must exist and looks something like this:
\begin{verbatim}
Name: faio
Description: Asynchronous I/O support
Version: $Id: flx_faio.pak 2120 2007-12-22 01:47:22Z idadesub $
provides_dlib: -lfaio_dynamic
provides_slib: -lfaio_static
includes: "faio_posixio.hpp"
Requires: demux
\end{verbatim}
This tells the CLI to add include file \verb%faio_posixio.hpp%
to the C++ compiler (as if a \verb%-I% had been used, however
the current implementation uses a different method). It also tells
the CLI to put \verb%-lfaio_dynamic% on the link line if dynamnic
linkage is being used, or \verb%-lfaio_static% if the static link
model is being used. 

In addition, it specifies the library \verb%faio% requires the 
library \verb%demux% to operate. 
The faio C++ header file will already include the demux header file.
For static linkage, the demux library will be added to the link line.
For dynamic linkage on Linux, nothing is added because the Elf linker
manages dependencies automatically, on other platforms, the demux
library may have to be added.

The collection of \verb%*.fpc% files is a resource management database.
The concept here is similar to the popular \verb%pkg-config% program,
however that program has too many bugs and is far too C (and Unix)
specific to be useful for Felix. Instead, we provide our own database
format and the program \verb%flx_pkgconfig% which is a more general
and robust program (based on mathematics not C hackery). In fact,
\verb%flx_pkgconfig% is itself written in Felix. A more complete
description is provided subsequently, however for now it should
be noted that the environment variable:
\begin{verbatim}
PKG_CONFIX_PATH=.:myresources
\end{verbatim}
whose component directories are separated by \verb%:% on all 
platforms (including Windows), can be used extend the set of 
directories in which \verb%flx_pkgconfig% searches for \verb%*.fpc%
files. The CLI uses a command line option to specify the Felix
\verb%config% directory of the currently used installation, and such
directories are added after those specified in the environment,
so any duplication will be resolved in favour of the environment
specified resources, allowing the user to override those provided
by default.

\chapter{Felix resources}
This chapter describes {\em in-program} resource management.
Felix programs generally consist of a main file, together
with various library files, both Felix and C++.

\section{Parse tree inclusion}
The Felix syntax inclusion directive
\begin{verbatim}
include "mycode";
\end{verbatim}
is used to include at the current point in the parse, the parse
tree which results from parsing and syntax macro processing
the specified resource. The resource is a text file containing
Felix code, by defaulting ending in the \verb%.flx% extension.
Syntactic inclusion only imports a built syntax tree: it does
not import any macros. The parser and macro processors are
invoked recursively on the included file. The result of such
a subparse is cached in a \verb%*.par% file with the same basename,
by default in the same directory as the included file.
(The Felix compiler \verb%flxg% provides an option to change
the cache directory but this is not currently available via the CLI).

Because the parsing of both the including and included file are
entirely independent, in the inclusion tree only changed files
need to reparsed. Even if an included file has been
modified, the cached parse of an unmodified including file
does not require reparsing. Unlike C and C++ pre-compiled headers,
Felix include files do not allow either up or down propagation
of any environment which could impact parsing. Thus, pre-compilation
of Felix files leads to extremely fast parsing of Felix programs
built from a large number of smaller files. Since the Felix parser
is a bleeding edge extensible GLR parser, it is considerably slower
the less capable automata, so reducing the amoung of code that
need to be compiled by partitioning is important for production
programming.

\section{The pre-processor}
The Felix pre-processor is a C style line oriented conditional
compilation facility with some constraints and additions.
It is provided rather begrudingly to ensure most of the tricks
that can be done in C with pre-processing conditionals are
available in Felix. However Felix does {\em not} support
macro expansion in Felix code with this processor.  
Pre-processor macros are supported, but they only expand
in pre-processor statements.

\subsection{File inclusion}
When the 
\begin{verbatim}
#include "filename.flxi"
\end{verbatim}
directives are invoked, the incuded file is first recursively pre-processed,
then the resulting token stream is emitted. In a similar way to
the syntactic include, no macros can be either imported or exported
using this directive, so the tokenisation of the included and including
files are independent. This directive is hardly ever used and may be phased
out in the future.

Because it is sometimes desirable to bundly commonly used macros into
a package for reuse, Felix also provides the
\begin{verbatim}
#import "filename.flxh"
\end{verbatim}
directive. This directive imports pre-processor macros from the specified filename
and exports the current macros into that file. This allows configuration 
macros to be stored in a reusable file, and thence control conditional
compilation in several client files.

\subsection{Conditional Compilation}
Macros are set the same way as in C:
\begin{verbatim}
#define UNIX 1
\end{verbatim}
and of course they can be unset:
\begin{verbatim}
#undef UNIX
\end{verbatim}
Then the usual conditional compilation directives are available:
\begin{verbatim}
#ifdef MSCRO
#ifndef MACRO
#if EXPR
#elif EXPR
#else
#endif
\end{verbatim}
Conditional compilation directives must nest properly inside files.

\subsection{Debugging}
The usual directive
\begin{verbatim}
#line 999 "filename"
\end{verbatim}
is provided to remap error messages to a generating file. This source
tracking pervades the compiler.

Felix provides 
\begin{verbatim}
#error "Some bug"
#warn "Maybe nasty"
\end{verbatim}
to facilitate debugging and error management in conjunction with
conditional compilation.

\subsection{Tokenisation}
The Felix tokeniser tokenises a whole file before parsing. Whilst the parser
can play some tricks distinguising identifiers and keywords, it cannot recognize
other kinds of new symbols. Therefore, rudimentary facilities are provided in the
preprocessor to generate a restricted class of user defined tokens.
The
\begin{verbatim}
#infix 99 "$*" funds
#infix "$*" funds
#infix 99 fred funds
#infix fred funds
\end{verbatim}
introduce either a symbol name, consisting of a sequence of special
characters, or a keyword name, and make them infix operator mapping to
a function taking a pair of arguments. Thus the syntax
\begin{verbatim}
1 $* 2
\end{verbatim}
is mapped to
\begin{verbatim}
funds (1,2)
\end{verbatim}
The precedence is currently ignored: all symbols have a fixed low precedence.
The syntax
\begin{verbatim}
#symbol "$*"
#symbol fred
\end{verbatim}
also introduces a new token.
All these symbols are encoded as a \verb%USER10% token with attributes
precedence 10, symbol as specified, and function as specified, or, the token
spelling if elided. Currently \verb%infix% and \verb%symbol% are synonyms
and can be used interchangeably.

Although these symbols are encoded in a fixed token, the parser is able to test
attributes and abort parses when token attributes fail some condition. Therefore,
the parser is capable of distinguishing tokens based on their attributes
provided the grammar is programmed to do so.

Felix also provides
\begin{verbatim}
#bracket "left" "right" funbr
\end{verbatim}
which defines two new tokens which act as balanced pairs or brackets
and apply the specified function to their contents, so that
\begin{verbatim}
left x right
\end{verbatim}
maps to
\begin{verbatim}
funbr x
\end{verbatim}
These are encoded in the \verb%USERLB% and \verb%USERRB% tokens respectively
with the bracket spelling as an attribute, and the function encoded in the
left bracket token.

Finally, the 
\begin{verbatim}
#keyword id1 id2 id3
\end{verbatim}
directive introduces new keywords without mapping them to anything.
These are encoded in the \verb%USER_KEYWORD% token, with the keyword
as the attribute.

\chapter{Code insertions}
Felix provides a sophsiticated system of code insertion.
\subsection{floating insertions}
Two directives specify floating insertions. These are
\begin{verbatim}
header tag="#include <complex>";
body tag='#include "mycode.cpp"';
\end{verbatim}
%
These directives specify literal text to emit near the top
of the generated C++ header and body files, respectively.
The insertions preceed any Felix generated code, but follow
fixed system headers. These directives are usually used to 
specify required C++ header files as shown, but any valid
C++ text can be emitted. The optional tag followed by equal sign
can be given to name the insertion. 
%
Floating insertions are emitted in order of writing. The same tag
can be given for multiple insertions.
%
Floating insertions also support a requires clause as described below.
They can also be polymorphic!

\subsection{requires clause}
A requires clause can be added to any floating insertion or
definition of a primitive type, to specify inclusion of any
resources required to support the definition. A requires clause
can also be given as a directive, in which case it is unconditional
if at global scope, or applies to the containing module or typeclass
instance if contained in a module or typeclass instance.
\begin{verbatim}
requires tag;
requires header "#include <sys.h>";
requires body "#define PI 3.141";
requires package "faio";
\end{verbatim}
The four forms of clause generate a dependence on another
insertion, generate a floating header or body, or specify
a package is needed, respectively.

When a package is specified, the compiler uses the \verb%flx_pkgconfig%
program to search for *.fpc resource files, and then determines if
any C++ headers need to be included. It also addes the abstract name
of the resource specified to the program resource file *.resh, to
allow the CLI or other code to locate any binary libraries which
must be linked in. Using package requirements isolates client file
system layout and C++ compiler and linker variations from the
Felix program, allowing it to remain essential platform independent.

The requires clause can be used as a whole statement as shown, however
it can also be used like this:
\begin{verbatim}
header cmpx_h="#include <complex>";
type dcomplex = "std::complex<double>" requies cmpx_h;
\end{verbatim}
The effect of this is that, if and only if the dcomplex type
is actually used in a program, then the C++ complex header
file is included. Note that you can also write stuff like:
\begin{verbatim}
header A requires B,C,D;
\end{verbatim}
to create a dependency graph. Cycles in dependency graphs are
alllowed. Once a set of depenencies are determine they're
emitted in order of writing. Generally, any physical dependency
between insertions must be handled by writing in the proper order.

The rooting of resource requirements in the actual usage of
client programs minimises the amount of C++ header that need to
be compiled and the number of libraries that need to be linked.
It also allows libraries to provide alternate facilities such
as Unix and Windows functions simultaneously and without error,
provided the client uses the one appropriate for their platform.
In particular the interfaces for libraries which are missing from
the system can still be provided: if they're not used, they
won't be C++ compiled or linked.

A complete description of the insertion, requirements, and
primitive code generation technology is beyond the scope of
this document and can be found in the language specification.

\chapter{The Felix compiler}
The Felix compiler is provided by the executable \verb%flxg%
together with debugging versions \verb%flxp% (parser only),
\verb%flxm% (parse and macro process), \verb%flxd% (parse,
macro process and desugar), and \verb%flxb% (parse, macros, desugaring
and binding).

In addition, if the client must launch the package manager \verb%flx_pkgconfig%
to generate the include file resource file for the program.

If the program uses the GLR parsing feature, then the compiler launches
the specified Elkhound executable, usually \verb%flx_elkhound% to generate
the C++ code for the lexer and parser. This program and the associated
run time libraries are derived from Scott McPeak's Elkhound system.

The Felix compiler must occasionally search for include files and
other resources, and generates a set of files as output. Generally
all resource files in Felix code must be Unix format relative filenames,
even on Windows. That is, they use \verb%/% as a directory name separator,
and may not start with any \verb%/% or \verb%.%. However filenames given
on the command line are given in native OS format.

Apart from such filename munging, the Felix compiler is entirely
platform independent, and, both the input Felix and output
C++ is also platform independent. Platform dependencies are handled
by the package manager, for example the selection of an asynchronous
socket driver. Felix provides drivers using epoll (Linux), poll (Unix),
kqueue (BSD, OSX), select (general Unix), IO completion ports (Sun style
for SunOS) and IO completion ports (Windows style for Windows). The configuration
phase of the build process determines the best package to use and configures
the package management database so asynchronous I/O requests made by the
\verb%faio% (Felix Asycn IO) system are delegated to chosen platform
specific library from the \verb%demux% system.

\section{Compiler options}
\begin{verbatim}
--version                         # prints the Felix compiler version
-v --verbose                      # lots of info for debugging your program
--debug                           # for debugging the compiler
--elkhound=flx_elkhound           # specify pathname of elkhound executable
--document-grammar                # generate HTML documentation of the processed grammar
--document-typeclass              # generate HTML documenation of processed type classes 
--with-comments                   # emit verbose comments in generated C++ code
--mangle-names                    # generate short mangled names for C++ identifiers
-Idir --include=dir               # specify include search path
--no-check-axioms                 # omit generating code from check directives
--trace                           # enable generating code from trace directives
-e                                # flip the logic of the return value
--force                           # disable reading cached parse trees
--cache_dir=dir                   # set directory for cached parse tress
--output_dir=dir                  # set directory for ouput files
--inline=99                       # set inlining threshhold (default 50, minimum 2)
--import=filename                 # include Felix library header
\end{verbatim}

\subsection{Notes}
The inlining algorithm implements fundamental semantics and must not
be disabled.

Normally, Felix tries to mimic user names, appending type and 
instance information for debugging. This can lead quite large,
hard to read and slow to compile C++ code. The \verb%mangle-names%
option reduces all names to unique instance numbers to reduce
output size and speed up compilation, at the expense of reducing
the clues to the origin of the identifiers. 

Normally Felix emits only a few comments into generated sources.
The \verb%with-comments% flag enables generation of verbose comments.
This can help to find the origin of some code hidden by aggressive
inlining and switches, but it makes the code very long and otherwise
hard to read.

The \verb%no-check-axioms% switch disables generation of run time
axiom checking code. Normally user written \verb%check_axiom%
directives generate run time checks of axioms. An extremely large
number of checks can be generated by only a few check directives,
because checks are based on pattern matching the check arguments
against all visible axioms. In addition, since checks are executable
code, they can be included inside functions and loops. Disabling
the checking code is sometimes necessary to debug the code
driving the checks.

The \verb%document-grammar% and \verb%document-typeclass% switches
are hacks to switch the mode of the \verb%flxp% and \verb%flxb% 
programs into documentation generators. They're integrated with
the compiler to ensure the parsing and lookup logic required
to document libraries is actually what the compiler does.

The \verb%--trace% option enables generation of code for trace
directives. These directive generate code which generates
output on \verb%stderr% when the program runs, tracing program
execution.

\chapter{The package manager}
Felix uses a package management technology loosely based on the
popular \verb%pkgconfig% program. However we use the program
\verb%flx_pkgconfig% instead, and distinct specification
files with extension \verb%.fpc%.

\section{fpc files}
A package file ending in extension \verb%fpc% is used to specify the
foreign resources to be incorporated into a program. The file
consists of a number of field specifications, being a line
with the field name, followed by a colon (\verb%:%) followed
by the field value. Multiple values can be given for some fields,
separated by spaces. A value containing spaces can be quoted using
either single or double quotation marks. Some fields can be
repeated to specify multiple values.

\verb%flx_pkgconfig% itself only recognizes one field, namely
\verb%Requires%. The value of this field must name another
package, and indicate this package depends on that package.

Felix specifies the following fields.
\subsection{Library binaries}
\begin{verbatim}
requires_slibs: '-L/opt/local/lib -lSDLmain -lSDL -Wl,-framework,Cocoa'
provides_slib:   -lsdl
requires_dlibs: '-L/opt/local/lib -lSDLmain -lSDL -Wl,-framework,Cocoa'
provides_dlib:   -lsdl
\end{verbatim}
Specify linker switches to link a static or dynamic
library respectively. The provides field specifies the library provided
by the package, the requires field specifies libraries and switches
it requires which are not packaged.

You should especially note that the package layout must match your
linker. Unix linkers require external references to be introduced
first in the command line, and then satisfied by subsequent definitions.
Thus the library must be provided before its dependencies. If there are
circularities, libraries containing definitions must be specified 
again. Motorola linkers specify defintions before references and automatically
find the transitive closure. The location of options and the Requires clause
must be suited to the recursion algorithm specified by the command line
switches (see below).

You should also note that on systems using Elf linkers, dynamic linkage
should not recursively gather dependent libraries, since the Elf linker
does this itself.

\subsection{Header files}
\begin{verbatim}
cflags: -I/usr/local/mylibs -DMY_MAC
includes: mylib2.h
\end{verbatim}

Specify the C/C++ source interface to a library.

\subsection{Driver}
\begin{verbatim}
flx_requires_driver: flx_arun 
\end{verbatim}

Specify the driver required to run a program. by default Felix use
the driver \verb%flx_run% which does not provide asynchronous I/O
support. Programs using the asynchronous socket interface for 
networking need the \verb%flx_arun% driver.

Other programs may require custom drivers, for example SDL requires
some environment to be initialised in the program mainline.
The current command line interface \verb%flx% has no provision
for handling conflicts. 

\section{Interface}
The general format of a call is:
\begin{verbatim}
flx_pkgconfig [options] pkg pkg ...
\end{verbatim}
The environment variable
\begin{verbatim}
PKG_CONFIG_PATH=dir:dir
\end{verbatim}
can be used to specify a list of directories to search for \verb%*.fpc% files.
The options are as follows:
\begin{verbatim}
-h --hide                  # package early in path shadows later one
-b --backwards             # process fields bottom up
-l --list                  # list selected packages
--missing                  # list missing packages
--noerror                  # ignore errors
--keeprightmost            # remove all but rightmost duplicates
--keepleftmost             # remove all but leftmost duplicates
--keepall                  # keep duplicates
--field=fieldname          # collect values of field fieldname
-r --rec                   # recurse on Requires field
--rec=fieldname            # recurse on value of specified field 
--path=dir                 # set search path
--path+=dir                # add to search path
@response_file             # use response file to specify more options
\end{verbatim}

The hide features relates to finding files in the specified path.
By default, all files of the given package name ending in \verb%.fpc%
will be independently processed. The \verb%--hide% option specifies that
a file found earlier in the path should hide any files of the same name
later in the path. This option is global. Normally, incremental processing
allows extra information to be added to a package by adding a directory
of extra specifications. However if you wish to replace a specification
by another, use the --hide option. The two effects cannot be combined
inside \verb%flx_pkgconfig%, you will have to write a script doing
multiple calls and merging the results if you want anything more complicated.

In absense of other options, \verb%flx_pkgconfig% scans the given list
of package names and returns 0 if they are all found, or 1 if one
of them is missing.

If the \verb%--field=value% option is given, it prints the values
of the specified field in each package out. If a field is missing
the program still completes, but returns 1. 

The \verb%--noerror%  option cause a return code of 0 to be issued
no matter what happens.

Fields are scanned in order of writing unless \verb%--backwards% is
specified, in which case they're scanned in reverse order,
however if a recursion option is specified, the scan is interrupted
whenever the specified field is discovered, and the program
recursively processes the packages listed as values of that field,
before continuing with the current package, provided that the program is
not already processing that package. Thus, circular linkages are automatically
and silently broken.


\end{document}

