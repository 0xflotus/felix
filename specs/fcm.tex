\documentclass{report}
\title{Felix Compilation Model}
\author{John Skaller}
\begin{document}
\maketitle
%\tableofcontents
\chapter{Command Line Interface}
The Felix compiler is designed to be used in conjunction with a host management
program, various Felix system libraries, and user supplied application support
libraries. The system is fully integrated by the command line processor 
\verb%flx% which organises the compilation, linking, and execution of a 
Felix script file. The system is designed to have the look and feel of a
conventional scripting language such as Perl or Python, driving the Felix compiler,
C++ compiler and linker without need for complex options or specification of
resource locations.

\section{Basic operation}
Most programs can be run simply by:
%
\begin{verbatim}
flx filename
\end{verbatim}
%
or equivalently
%
\begin{verbatim}
flx filename.flx
\end{verbatim}

On Unix, if the first line of the file is
%
\begin{verbatim}
#!/usr/bin/env flx
\end{verbatim}
%
and the file is marked as executable, then the script can be run just by
invoking the filename:
%
\begin{verbatim}
filename.flx
\end{verbatim}

A similar facility is available for Microsoft Windows.

\section{Selecting Felix Version}
Felix support an arbitrary number of independent Felix installations.
All of the program files, apart from the command line processor \verb%flx%, 
can be installed in a single directory. This directory will typically
be named for the Felix version, for example:
%
\begin{verbatim}
felix-1.1.4_rc4
\end{verbatim}
%
describes Felix version 1.1.4, release candidate 4. On Unix these are
typically installed in one of
%
\begin{verbatim}
/usr/lib
/usr/local/lib
/opt/felix
${HOME}/lib
\end{verbatim}
%
or some such place where packages are installed. The \verb%flx% script
will usually have a hard coded constant refering to the installation location.

\subsection{Overriding the version on the command line}
This can be overridden by specifying the installation directory using the
\verb%--test% option:
%
\begin{verbatim}
flx --test filename
flx --test=/opt/felix-1.1.4_rc4 filename
\end{verbatim}
%
The first variant specifies the current directory, and is primarily used by
developers testing the system. The second variant can be used to specify a 
particular installation, allowing an upgraded system to be installed without
compromising existing working programs.

\subsection{Overriding the version with environment variables}
Felix also provides an environment variable \verb%FLX_INSTALL_DIR% 
which can be used to override the installation directory:
%
\begin{verbatim}
FLX_INSTALL_DIR=/opt/felix-1.1.4_rc4 flx filename
\end{verbatim}

On Unix, this can also be set in a program file like:
%
\begin{verbatim}
#!/usr/bin/env FLX_INSTALL_DIR=/opt/felix-1.1.4_rc4 flx
\end{verbatim}
%
to ensure a program is run with a particular version.

\subsection{Querying the Version}
The version of the \verb%flx% script can be found by:
%
\begin{verbatim}
flx --version
\end{verbatim}
Note that this is the version of the \em{flx script} and not
the version of the installation!

\subsubsection{Alternate driver scripts}
Felix provides three implementations of the driver script:
\verb%flx% is written for Unix \verb%bash%, \verb%flx.bat% is written for Windows
\verb%CMD.EXE% shell, and \verb%flx.py% is written for Python and should operate
on all platforms where Python is installed.

\subsubsection{Getting Help}
In GNU tradition, some help on the command line can be obtained by
simply typing
%
\begin{verbatim}
flx
\end{verbatim}
%
which will reply
\begin{verbatim}
usage: flx [options] filename
\end{verbatim}
%
More extensive help can be obtained on Unix by 
\begin{verbatim}
flx --help
\end{verbatim}
%
which invokes the \verb%man% processor for the main
Felix man page. 

\subsection{Linkage model}
Felix supports two linkage models: dynamic and static.
Dynamic linkage is the default if the target platform supports it.
Some platforms, such as embedded systems, do not support dynamic
linkage. Other platforms, notable Microsoft Windows, and increasingly
Linux systems, do not provide static link versions of important libraries,
and so dymamic linkage is mandatory.

\subsubsection{Static Linkage}
In the static linkage model, Felix generates C++ code which is compiled
to an object file, extension \verb%.o% on Unix or \verb%.obj% on Windows.
This file is then linked against various libraries, typically \verb%.a%
files on Unix, or \verb%.lib% files on Windows. All Felix built static
linkage files have the suffix \verb%_static% added to the library name,
for example:
%
\begin{verbatim}
lib/rtl/libflx_gc_static.a
\end{verbatim}
provides the garbage collector library in static link form on Unix.
Note the prefix \verb%lib% which Unix favours. On Cygwin the prefix
is \ver%cyg%, whereas Windows does not use a prefix.
%
The \verb%_static% suffix is essential to prevent \em{smart} linkers
such as Unix \verb%ld% from linking with either static or dynamic linkage
depending on availability, and thereby producing unexpected program form,
corrupted programs, or subsequently failing for hard to understand reasons
when other libraries are not available in static link format.

Static linkage can be invoked by
\begin{verbatim}
flx --static filename
\end{verbatim}
%
however it will be chosen by default if the build is configured so as not
to support dynamic linkage.

Static linkage creates a standalone statically linked executable program.

Static link programs are sometimes faster than dynamic linked
programs, and are easier to ship. However they're harder to upgrade
to work with new system libraries. Note some platforms (such as Linux)
do not statically link the C library even in the static link model.
Other platforms always statically link thunks, even when linking
dynamically, notably Windows.

Finally note some Felix features such as dynamic loading of
plugins do not work with the static link model.

\subsubsection{Dynamic Linkage}
Dynamic linkage is the default and preferred linkage model for Felix.
In this model, not only are the support libraries dynamic link libraries
(DLLs) but the user Felix program itself is linked as a DLL. The program is 
invoked by running a driver mainline, which loads the user DLL code using
a dynamic function call: \verb%dlopen()% on Unix, or \verb%LoadLibrary% 
on Windows. 

These DLLs have several prescribed entry points which are then
invoked by the driver program to create the global data object (thread frame),
initialise it, run the program, and finally destroy the object. 
The mechanism is the same for static linkage, except that the entry points
are looked up by string name using \verb%dlsym()% on Unix or \verb%GetProcAddress%
on Windows.

All Felix built dynamic
linkage files have the suffix \verb%_dynamic% added to the library name,
for example:
%
\begin{verbatim}
lib/rtl/libflx_gc_dynamic.so
\end{verbatim}
provides the garbage collector library in dynamic link form on Unix.

\subsection{Drivers}
The mainline program used to run user Felix code is similar for both
static and dynamic linkage, except for the mechanism for locating
the user entry points. However Felix provides two versions of the driver
as standard. 

The driver \verb%flx_run% is the most basic one and has provides support
for basic operations including multi-threading. 

The driver \verb%flx_arun% is more advanced, and provides support for asynchronous
operations, particularly socket I/O.

Felix automagically calculates which driver is required for user code and invokes
that driver. Custom drivers can also be written but are beyond the scope of
this document.

The driver program is roughly equivalent to a scripting language interpreter,
in that it provides a regular interface to native operating system facilities,
and provides and event loop for synchronising program component execution.
Note however Felix generates ultra-high performance native code, and the driver
switches context extremely fast, much faster than native operating system
pre-emptive threading.

\subsection{Cached Compilation}
The Felix command line script automagically caches the results of a compilation.
The first time you execute a script, it will take some time to translate
to C++ and then compile and link the C++ code. The second time you do this on
an unmodified file, the binary code created by the first compilation will
be invoked directly. If you have changed a file on which you program depends,
but not changed the main Felix program file itself, the CLI processor may
mistakenly run the code without recompiling it. In this case you can force
a complete rebuild using the \verb%--force% option:
%
\begin{verbatim}
flx --force filename
\end{verbatim}

It is also possible to perform only some of the compilations steps as follows:
\begin{verbatim}
flx -c filename
\end{verbatim}
%
compiles and links the program, but does not run it.
%
\begin{verbatim}
flx --nofelix filename
\end{verbatim}
compiles the C++ code, links it, and runs it, but does not run the Felix
compiler to generate the C++ code, instead it uses the C++ code already there.
This is useful if you want to edit the generated C++, in particular is you wish
to add C++ debugging such as \verb%printf()% statements into the C++ to help
locate a bug.

\section{Ad Hoc Resource Management}
It is sometimes useful to compile and link with additional resources
such as extra Felix files, extra C++ header files, extra libraries,
or extra object files. In addition, some extra controls over compilation
and linkage may be required. Please note this feature is \em{not desirable}
and there is generally a much better way to support automatic resource
location using a resource database, which is described subsequently.

The following options can also be provided on the command line:

\begin{verbatim}
-DMACRO
\end{verbatim}
adds a macro to the C++ compilation.
\begin{verbatim}
*.c *.cxx *.cpp
\end{verbatim}
adds a file to the compilation and link step.
\begin{verbatim}
*.a *.o *.lib *.obj
\end{verbatim}
adds a file to the link step.
\begin{verbatim}
-Idir
\end{verbatim}
adds a directory to both the Felix and C++ include file compilation search
paths.
\begin{verbatim}
-llibrary
\end{verbatim}
adds a library to the link step,
\begin{verbatim}
-Ldir
\end{verbatim}
adds a directory to the linker library search path 
\begin{verbatim}
--nostdlib
\end{verbatim}
omits the standard Felix libraries from the link step.
\begin{verbatim}
--nostdimport
\end{verbatim}
omits the standard Felix library from the Felix compilation step.
This option is used to compile a Felix program in fully raw mode,
with no standard definitions. On tghe other hand
\begin{verbatim}
--import=filename
\end{verbatim}
can be used to import an additional file automagically to each 
Felix file, this option can be used with \verb%--nostdimport%
to replace the standard library with custom or patched libraries.

The special option:
\begin{verbatim}
-<anything>
\end{verbatim}
which is a dash followed by anything not recognized is assumed to
be a switch for the underlying C++ compiler and linker and is
passed to both. Using this feature is not recommended as the
set of options \verb%flx% supports may change.

\subsection{Optimisation}
Felix normally optimised heavily by default. The option
\begin{verbatim}
--noinline
\end{verbatim}
can be used to turn off inlining completely. This is strongly discouraged
as some essential semantics are effected by the inlining pass. Instead
please use
\begin{verbatim}
--inline=999
\end{verbatim}
to specify the maximum number of lines a function can have
and still be inlined. Specifying a small number such as 2 will
effective ensure significant functions are not inlined.
The default is 100. The exact meaning of \em{line} is not specified.

\subsection{debugging}
The switch
\begin{verbatim}
--debug
\end{verbatim}
enables full debugging. This includes debugging the Felix compiler operation
as well as debugging the behaviour of the executable whilst running. This option
produces a very large amount of information most of which is primarily useful
only to an expert user or the Felix developers.

The CLI itself can be traced by
\begin{verbatim}
--echo
\end{verbatim}
which echos out most of the commands it is executing so you can
trace the build process and flags being used.

\chapter{Resource Management Model}
Felix has an advanced resource management model which is designed
to allow programs to build automatically without need to specify
any additional libraries on the command linem whilst at the same
time leaving these programs entirely portable.

This is achieved by requiring programs to specify the abstract
resources they require, whilst the client is required to establish
bindings from the abstract resources to concrete ones in their
environment. For example an abstract library called \verb%faio%
may be required by a program \verb%myprog%, so the program must include a 
directive:
\begin{verbatim}
requires package "faio";
\end{verbatim}
This causes the Felix compiler to emit a file \verb%myprog.resh%
which contains the line
\begin{verbatim}
faio
\end{verbatim}
amoung others. The CLI reads this file, and then it searches for
the file
\begin{verbatim}
faio.fpc
\end{verbatim}
in the current package configuration path. By default this is the
\verb%config% directory of the current installation. That file
must exist and looks something like this:
\begin{verbatim}
Name: faio
Description: Asynchronous I/O support
Version: $Id: flx_faio.pak 2120 2007-12-22 01:47:22Z idadesub $
provides_dlib: -lfaio_dynamic
provides_slib: -lfaio_static
includes: "faio_posixio.hpp"
Requires: demux
\end{verbatim}
This tells the CLI to add include file \verb%faio_posixio.hpp%
to the C++ compiler (as if a \verb%-I% had been used, however
the current implementation uses a different method). It also tells
the CLI to put \verb%-lfaio_dynamic% on the link line if dynamnic
linkage is being used, or \verb%-lfaio_static% if the static link
model is being used. 

In addition, it specifies the library \verb%faio% requires the 
library \verb%demux% to operate. 
The faio C++ header file will already include the demux header file.
For static linkage, the demux library will be added to the link line.
For dynamic linkage on Linux, nothing is added because the Elf linker
manages dependencies automatically, on other platforms, the demux
library may have to be added.

The collection of \verb%*.fpc% files is a resource management database.
The concept here is similar to the popular \verb%pkg-config% program,
however that program has too many bugs and is far too C (and Unix)
specific to be useful for Felix. Instead, we provide our own database
format and the program \verb%flx_pkgconfig% which is a more general
and robust program (based on mathematics not C hackery). In fact,
\verb%flx_pkgconfig% is itself written in Felix. A more complete
description is provided subsequently, however for now it should
be noted that the environment variable:
\begin{verbatim}
PKG_CONFIX_PATH=.:myresources
\end{verbatim}
whose component directories are separated by \verb%:% on all 
platforms (including Windows), can be used extend the set of 
directories in which \verb%flx_pkgconfig% searches for \verb%*.fpc%
files. The CLI uses a command line option to specify the Felix
\verb%config% directory of the currently used installation, and such
directories are added after those specified in the environment,
so any duplication will be resolved in favour of the environment
specified resources, allowing the user to override those provided
by default.

\chapter{Felix resources}
This chapter describes \em{in-program} resource management.
Felix programs generally consist of a main file, together
with various library files, both Felix and C++.

\section{Parse tree inclusion}
The Felix syntax inclusion directive
\begin{verbatim}
include "mycode";
\end{verbatim}
is used to include at the current point in the parse, the parse
tree which results from parsing and syntax macro processing
the specified resource. The resource is a text file containing
Felix code, by defaulting ending in the \verb%.flx% extension.
Syntactic inclusion only imports a built syntax tree: it does
not import any macros. The parser and macro processors are
invoked recursively on the included file. The result of such
a subparse is cached in a \verb%*.par% file with the same basename,
by default in the same directory as the included file.
(The Felix compiler \verb%flxg% provides an option to change
the cache directory but this is not currently available via the CLI).

Because the parsing of both the including and included file are
entirely independent, in the inclusion tree only changed files
need to reparsed. Even if an included file has been
modified, the cached parse of an unmodified including file
does not require reparsing. Unlike C and C++ pre-compiled headers,
Felix include files do not allow either up or down propagation
of any environment which could impact parsing. Thus, pre-compilation
of Felix files leads to extremely fast parsing of Felix programs
built from a large number of smaller files. Since the Felix parser
is a bleeding edge extensible GLR parser, it is considerably slower
the less capable automata, so reducing the amoung of code that
need to be compiled by partitioning is important for production
programming.

\section{The pre-processor}
The Felix pre-processor is a C style line oriented conditional
compilation facility with some constraints and additions.
It is provided rather begrudingly to ensure most of the tricks
that can be done in C with pre-processing conditionals are
available in Felix. However Felix does \em{not} support
macro expansion in Felix code with this processor.  
Pre-processor macros are supported, but they only expand
in pre-processor statements.

\subsection{File inclusion}
When the 
\begin{verbatim}
#include "filename.flxi"
\end{verbatim}
directives are invoked, the incuded file is first recursively pre-processed,
then the resulting token stream is emitted. In a similar way to
the syntactic include, no macros can be either imported or exported
using this directive, so the tokenisation of the included and including
files are independent. This directive is hardly ever used and may be phased
out in the future.

Because it is sometimes desirable to bundly commonly used macros into
a package for reuse, Felix also provides the
\begin{verbatim}
#import "filename.flxh"
\end{verbatim}
directive. This directive imports pre-processor macros from the specified filename
and exports the current macros into that file. This allows configuration 
macros to be stored in a reusable file, and thence control conditional
compilation in several client files.

\subsection{Conditional Compilation}
Macros are set the same way as in C:
\begin{verbatim}
#define UNIX 1
\end{verbatim}
and of course they can be unset:
\begin{verbatim}
#undef UNIX
\end{verbatim}
Then the usual conditional compilation directives are available:
\begin{verbatim}
#ifdef MSCRO
#ifndef MACRO
#if EXPR
#elif EXPR
#else
#endif
\end{verbatim}
Conditional compilation directives must nest properly inside files.

\subsection{Debugging}
The usual directive
\begin{verbatim}
#line 999 "filename"
\end{verbatim}
is provided to remap error messages to a generating file. This source
tracking pervades the compiler.

Felix provides 
\begin{verbatim}
#error "Some bug"
#warn "Maybe nasty"
\end{verbatim}
to facilitate debugging and error management in conjunction with
conditional compilation.

\subsection{Tokenisation}
The Felix tokeniser tokenises a whole file before parsing. Whilst the parser
can play some tricks distinguising identifiers and keywords, it cannot recognize
other kinds of new symbols. Therefore, rudimentary facilities are provided in the
preprocessor to generate a restricted class of user defined tokens.
The
\begin{verbatim}
#infix 99 "$*" funds
#infix "$*" funds
#infix 99 fred funds
#infix fred funds
\end{verbatim}
introduce either a symbol name, consisting of a sequence of special
characters, or a keyword name, and make them infix operator mapping to
a function taking a pair of arguments. Thus the syntax
\begin{verbatim}
1 $* 2
\end{verbatim}
is mapped to
\begin{verbatim}
funds (1,2)
\end{verbatim}
The precedence is currently ignored: all symbols have a fixed low precedence.
The syntax
\begin{verbatim}
#symbol "$*"
#symbol fred
\end{verbatim}
also introduces a new token.
All these symbols are encoded as a \verb%USER10% token with attributes
precedence 10, symbol as specified, and function as specified, or, the token
spelling if elided. Currently \verb%infix% and \verb%symbol% are synonyms
and can be used interchangeably.

Although these symbols are encoded in a fixed token, the parser is able to test
attributes and abort parses when token attributes fail some condition. Therefore,
the parser is capable of distinguishing tokens based on their attributes
provided the grammar is programmed to do so.

Felix also provides
\begin{verbatim}
#bracket "left" "right" funbr
\end{verbatim}
which defines two new tokens which act as balanced pairs or brackets
and apply the specified function to their contents, so that
\begin{verbatim}
left x right
\end{verbatim}
maps to
\begin{verbatim}
funbr x
\end{verbatim}
These are encoded in the \verb%USERLB% and \verb%USERRB% tokens respectively
with the bracket spelling as an attribute, and the function encoded in the
left bracket token.

Finally, the 
\begin{verbatim}
#keyword id1 id2 id3
\end{verbatim}
directive introduces new keywords without mapping them to anything.
These are encoded in the \verb%USER_KEYWORD% token, with the keyword
as the attribute.

\end{document}
