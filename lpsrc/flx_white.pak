@set_title('Felix: White Paper')
@head(1,'Origins')
Felix is a new programming language which is designed
to overcome serious limitiations in C and C++
for high level programming, without loss of efficiency,
by adopting some of the ideas of 
functional programming and scripting languages,
whilst retaining a form of compatibility to 
support reuse of existing C and C++ codes.
@p()
We discuss below some of the difficulties, and the
Felix solution.
@p()
In addition, Felix provides support for
cooperative multitasking of ultra-lightweight threads.
The translator accepts code written in a thread like
style, but generates event driven code.

@head(2,'Purely functional subsystem')
In C/C++, functions may have side effects.
As a result, the order in which state changes
occur is difficult to determine from the
syntactic form of an expression. 
@p()
For human readers, this means the semantics of a program
may be difficult to determine.
@p()
For the compiler, lots of optimisation opportunities
are missed.
@p()
Felix does not permit side effects in expressions,
and thus syntactically functional code posseses 
the property known as 'referential transparency'.
@p()
Note that Felix primitive functions
are defined by specifying C/C++ expressions,
which may have side effects: Felix cannot
detect such a breach of the requirements.

@head(2,'Declarator Syntax and Grammar')
C/C++ declarator syntax is very hard to read
and write. It prevents simple parsing by both
common machine parsing techniques, and also
by human readers.
@p()
Felix uses an LALR(1) unambiguous yaccable grammar.
@p()
Felix uses an ML style type grammar.
@p()
As an example we exhibit a variable definition:
@begin_displayed_code()
  var x : int = 1;
@end_displayed_code()
and a function definition and variable:
@begin_displayed_code()
  function sum(a:int, b:int):int =
  {
    return a + b;
  }
  var f : int * int -> int = sum of (int * int);
@end_displayed_code()
The suffix (int * int) here is used to chose
a particular function from a potential overload
set.

@head(2,'Type inference')
In C/C++ serial decomposition of expressions
is made difficult by the need to declare the
type of a subexpression, in C89 the situation 
is even worse, since the variable needs to be
declared non-locally. For example in C++,
the expression:
@begin_displayed_code()
  x + y * z;
@end_displayed_code()
can be decomposed to:
@begin_displayed_code()
  int yz = y * z;
  x + yz;
@end_displayed_code()
but only because I know the name of the type of 'y * z'.
In addition, note that a statement is required to
support the decomposition of an expression.
@p()
Felix supports type inference for values and variables
so that it is possible to write
@begin_displayed_code()
  val yz = y * z;
  x + yz;
@end_displayed_code()
In addition, it supports the traditional 'let .. in'
construction of functional programming:
@begin_displayed_code()
  let yz = y * z in
  x + yz;
@end_displayed_code()
@p()
Deduction of function return types is also supported.
@p()
Deduction of function parameter types is not supported.
There are two main reasons: error messages tend
to be obscure, and overloading cannot easily
be supported. There is a third reason too: Hindly-Milner
type inference is an NP-hard.
@p()
In summary we can say Felix provides bottom (synthetic)
type deduction, but not full inference in the 
ML (Hindly-Milner) style.

@head(2,'Functions and tuples')
In Felix, functions always have exactly one
argument and return a result. However,
Felix provides a tuple type, tuple
constructor syntax, and sugar for functions
so that tuple arguments are more easily 
supported. For the function 'sum' given
above, the following two calls are equivalent:
@begin_displayed_code()
  val x1 = sum (a,b);
  val ab = (a,b);
  val x2 = sum ab;
@end_displayed_code()
As can be seen a bracketed comma separated
list denotes a tuple: brackets are not required
to apply a function, although they can always be given.

@head(2,'Overloading and Conversions')
Unlike ML style languages, Felix supports
overloaded functions and procedures.
Unlike C++, overloading requires an exact match.
Felix does not support any implicit type conversions.
Overloading, type inference and automatic conversions
do not fit well together.
@p()
There are some implicit kinding conversions though:
when a function is used, a closure is implicitly
constructed: in terms of the representation,
a function is a class, whilst a closure is an
instance of it; that is, an object.

@head(2,'Nesting')
Felix constructions, including functions, procedures
and modules, all nest. Note that there is a constraint
on calling procedures in functions: the procedure
may modify the data of the function enclosing
it, but not any enclosing scope. This localises
side effects. Such procedure calls can always be
executed using the machine stack: they do not go through 
the usual control inversion mechanism. 
@p()
Felix overconstrains calling of nested procedures
to ensure that simple compile time static evaluation
can determine if it is safe to call the procedure.

@head(2,'Parallel definitions')
In Felix, declarations in the same
scope are always mutually recursive and parallel
like 'let rec' in ML languages or member functions
in C++. In effect, the scope acts to declare a
set of names. Thus, it is possible to assign
a value to a variable before it is declared,
and it is not possible to assign the value
of a variable from an outer scope to one of the
same name in an inner scope without using a
qualified name or alias (such as a pointer
or parameter).

@head(2,'Modules and generics')
Felix supports non-extensible namespaces called modules.
Modules can be parameterised by module signatures,
such a module is known as a functor. Functors are
the only mechanism available for generic programming.
Functor instantiation is implicit, as in C++.

@head(2,'Coercions and bound types')
The Felix type system is novel in that
it supports a kind of type known as a bound type.
A bound type results when an abstract type in
an interface is associated with an actual
type in a module implementation by a modular
coercion. For example:
@begin_displayed_code()
  interface I { type t; }
  module M { typedef t = int; }
  module B = M : I;
  val x : B::t;
@end_displayed_code()

Here the type of x, denoted B::t, is, in fact

@begin_displayed_code()
  B::t/int
@end_displayed_code()

and should be thought of as a component of the
functor M : I from I to M which maps the interface
I onto the implementation M by name.
@p()
Bound types have two operations, lifting and lowering:
the lift of a bound type n/d is n, the lower is d.
For the purpose of typechecking, the lift of a bound
type is always used to enforce information hiding.
For code generation, the lowering is used, so as to
instantiate the actual representation.

@head(2,'Purely Abstract Primitives')
Felix is unual in that it supports no builtin types.
Instead, primitive types are defined using
constructions which are simultaneously abstraction
and concrete. We elucidate with an example:
@begin_displayed_code()
  type int = "int";
  fun add: int * int -> int = '$1 + $2';
  proc print: int = 'printf("%d",$1);';
  fun demo(a:int) { print (add (a,a)); }
@end_displayed_code()
In this code, the left hand side provides
an abstract specification of the type 'int':
it is defined in terms of the functions that
can use it, add and print.
@p()
The front end of the compiler treats 'int'
as abstract. The back end, on the other hand,
uses the right hand sides of the definitions
to generate C++ code.

@head(2,'Purely Abstract Algebraic Data structures')
Felix provides two basic data algebraic
data structues: structs and unions,
these are product and sum types.
Here are examples:
@begin_displayed_code()
  struct complex {
    x : float;
    y : float;
  };
  union maybe_int =
    | Int of int
    | None;
@end_displayed_code()
@p()
Although Felix uses a particular data structure
for these two constructions, it also generates
functions for using them. By following a fixed
convention, C++ code can manipulate these structures
without knowing the underlying concrete data
structure; furthermore, because Felix uses these
functions whenever the appropriate Felix syntax
is used, the C++ programmer can model existing
data structures as structs and unions, without
needing to use the same concrete representation.
@p()
In other words, even constructed data types
are represented by a pure abstraction,
as if they were primitives. For example,
the (rvalue) expression
@begin_displayed_code()
  z.x
@end_displayed_code()
is syntactic sugar for
@begin_displayed_code()
  get_x z
@end_displayed_code()
and so the following also works:
@begin_displayed_code()
  header '#include <complex.h>';
  type complex = "complex";
  fun get_x: complex -> float = "$1.x";
  complex z;
  val z = z.x;
@end_displayed_code()
Here, we have equipped the abstract type 'complex'
with an x projection function so that we can
use it as if it were a Felix struct.
@p()
Note that the Felix tuple type is nothing
other than a struct with standard names
for the components, or, in reverse,
a struct is a generative form of a tuple
with user specified component names.
@p()
Unions are handled similarly, although the abstraction
is slightly more complicated.

@head(2,'Pattern matching')
Felix provides ML style pattern matching.
In addition to the usual constructions
for matching tuples and unions, constructions
for matching integer, string, and floating
ranges are provided, as well as syntax for
Perl style regular expressions.

@head(2,'Higher order functions')
Function and procedure closures may be
returned by a function, and
passed as values to functions and procedures.
Note that a function cannot call a procedure
argument (since it might have side effects).

@head(2,'Garbage Collection')
Felix uses an exact garbage collector with
reference counting for automatic memory management.
The collector makes it possible to support closures,
while reference counting implies timely well ordered
finalisation allowing the resource acquisition on
construction and release on destruction technique
to be used effectively, as well as reducing the
collectors workload and conserving memory.


@head(2,'Control inversion')
Felix supports a 'read' primitive which is used
to fetch the next message from a message queue.
It does this by relinquising control, and allowing
the driver program to fetch the message, and resume
execution after the read statement.
This allows an event loop to call Felix code with
each message, whilst the Felix program can be
crafted algorithmically, rather than as a callback.

@head(2,Compilation Model')
Felix is designed to produce a dynamically loadable
shared library object which is used by a driver
program hand crafted in C++ by the programmer.
This choice permits embedding Felix libraries in
a wide variety of existing application frameworks.

@head(2,'Security')
Most programming languages provide no, or highly contrived
security models. C for example provides little or no
security, whilst TCL and Python, for example, provide
simplistic restricted execution environments. Java provides
a more sophisticated security model which unfortunately
is fundamentally flawed because whilst it provides
secure transmission of codes, it fails to provide
any way of verifying the semantics.
@p()
The Felix solution provides total and configurable
security by two mechanisms. Firstly, felix codes
constitute libraries run by user written drivers
which have as much control over the environment in which
the codes run as the driver's author desires. Secondly,
the transmission medium is intrinically based on human readable
source codes, ensuring the suitability of the software
can be examined by a client.

