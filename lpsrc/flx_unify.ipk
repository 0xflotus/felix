@head(1,'Unification')
@h=tangler('src/flx_unify.mli')
@select(h)
(** this module provides type unification
and utilities
*)

open Flx_types

(** obtain the mgu of a set of type equations *)
val maybe_unification: 
  symbol_table_t -> (* just for diagnostics *)
  (btypecode_t * btypecode_t) list ->
  (int * btypecode_t) list option

(** obtain the mgu of a set of type equations *)
val unification: 
  symbol_table_t -> (* just for diagnostics *)
  (btypecode_t * btypecode_t) list -> 
  (int * btypecode_t) list

(** test if two types unify *)
val unifies: 
  symbol_table_t -> (* just for diagnostics *)
  btypecode_t -> 
  btypecode_t -> 
  bool

(** compare type for structural/unificational ordering *)
val compare_sigs:
  symbol_table_t ->
  btypecode_t ->
  btypecode_t ->
  partial_order_result_t

(** check if the two types unify: update the
variable definitions in sym_state ??? Only
useful if type variables are global, which is
the function return type unknown variable case..
*)
val do_unify:
  sym_state_t ->
  btypecode_t ->
  btypecode_t ->
  bool

(** compare for iso-equality *)
val type_eq:
  btypecode_t ->
  btypecode_t ->
  bool

(** [unfold t] returns t with each fix variable 
  denoting t replaced with t 
*)
val unfold:
  btypecode_t ->
  btypecode_t 

(** undo an unfold *)
val fold:
  btypecode_t ->
  btypecode_t 

(** minimise the representation of a type
with respect to recursion
*)

val minimise:
  btypecode_t ->
  btypecode_t 

(** replace variables in the term using
the mapping in a list *)
val list_subst:
  (int * btypecode_t) list ->
  btypecode_t ->
  btypecode_t

(** replace variables using vs and ts list to
determine mapping *)
val tsubst :
  (string * int) list -> (* vs list *)
  btypecode_t list ->  (* ts list *)
  btypecode_t ->
  btypecode_t

(** replace variables in the term using
the mapping in the hashtable 
*)
val varmap_subst:
  (int,btypecode_t) Hashtbl.t ->
  btypecode_t ->
  btypecode_t

(** check for variables *)
val var_occurs:
  btypecode_t ->
  bool

(** check for a particular variable *)
val var_i_occurs:
  int ->
  btypecode_t ->
  bool

(** normalise returns count of the type variables
  occuring in a type, and the type rewritten so the type variables
  are systematically numbered from 0 - n-1
*)
val normalise_type: 
  btypecode_t -> int list * btypecode_t

@h=tangler('src/flx_unify.ml')
@select(h)
open Flx_types
open Flx_print
open Flx_maps
open Flx_util
open List

let term_subst t1 i t2 =
  let rec s t = match map_btype s t with
  | `BTYP_var j when i = j -> t2
  | t -> t
  in s t1

let list_subst x t1 = 
  fold_left (fun t1 (i,t2) -> term_subst t1 i t2) t1 x
  
let varmap0_subst varmap t =
  let rec s t = match map_btype s t with
  | `BTYP_var i as x ->
    if Hashtbl.mem varmap i
    then Hashtbl.find varmap i
    else x
  | x -> x
  in s t

let varmap_subst varmap t =
  let rec s t = match map_btype s t with
  | `BTYP_var i as x ->
    if Hashtbl.mem varmap i
    then Hashtbl.find varmap i
    else x
  | `BTYP_typefun (p,r,b) ->
    let 
      p = map (fun (name,kind) -> (name, s kind)) p and
      r = s r and
      b = s b 
    in
      `BTYP_typefun (p,r,b)
  | x -> x
  in s t

(* the type arguments are matched up with the type
  variables in order so that
  vs_i -> ts_i
  where vs_t might be (fred,var j)
*)
let tsubst 
  (vs:(string * int) list) 
  (ts:btypecode_t list)
  (t:btypecode_t) 
=
  if length ts <> length vs 
  then 
    failwith 
    (
      "[tsubst] wrong number of type args, expected vs=" ^ 
      si (length vs) ^
      ", got ts=" ^ 
      si (length ts)
    )
  ;
  let tvs = combine vs ts in
  let varmap = Hashtbl.create 97 in
  iter
  (fun ((name, varidx),typ) -> Hashtbl.add varmap varidx typ)
  tvs
  ;
  varmap_subst varmap t


(* returns the most general unifier (mgu)
  of a set of type equations as a list
  of variable assignments i -> t
  or raises Not_found if there is no solution

  HOW IT WORKS:

  We start with some set of type equations
  t1 = t2
  t3 = t4  (1)
  ...

  in which the LHS and RHS are general terms that 
  may contain type variables.

  We want to say whether the equations are consistent,
  and if so, to return a solution of the form
  of a set of equations:

  v1 = u1
  v2 = u2   (2)

  where v1 .. vn are type variable
  which do not occur in any of the
  terms u1 .. un

  Such a set is a solution if by replacing v1 with u1,
  v2 with u2 .. vn with un,
  everywhere they occur in t1, t2 .... tn,
  the original equations are reduced to
  equations terms which are structurally equal 

  The technique is to pick one equation,
  and match up the outermost structure,
  making new equations out of the pieces in the middle,
  or failing if the outer structure does not match.

  We discard the original equation,
  add the new equations to the set,
  and then for any variable assignments of form (2)
  found, we eliminate that variable in the
  all the other equations by substitution.


  At the end we are guarrateed to either have found
  the equations have no solution, or computed one,
  although it may be that the terms u1 .. u2 ..
  contain some type variables.

  There is a caveat though: we may obtain
  an equation 

    v = t

  where v occurs in t, that is, a recursive equation.
  If that happens, we eliminate the occurences
  of v in t before replacement in other equations:
  we do this by replacing the RHS occurences of
  v with a fixpoint operator.

*)


let var_i_occurs i t =
  let rec aux t:unit = match t with
    | `BTYP_var j when i = j -> raise Not_found
    | _ -> iter_btype aux t
 in 
   try 
     aux t; 
     false 
   with Not_found -> true

(* NOTE: this algorithm unifies EQUATIONS 
  not inequations, therefore it doesn't
  handle any subtyping
*)
let rec unification dfns eqns: (int * btypecode_t) list = 
  let eqns = ref eqns in
  let mgu = ref [] in
  let rec loop () : unit =
    match !eqns with
    | [] -> ()
    | h :: t ->
      eqns := t;
      let s = ref None in
      begin match h with
      | `BTYP_var i, `BTYP_var j ->
        if i <> j then s := Some (i,`BTYP_var j)

      | `BTYP_var i, t
      | t,`BTYP_var i ->
        if var_i_occurs i t
        then  (* we actually want to handle this, but I can't
          seem to generate any test cases that trigger this
          message .. *)
          failwith 
          (
            "Unexpected recursion in unification, terms: " ^
            match h with (a,b) ->
            sbt dfns a ^ " = " ^ sbt dfns b
         )
        else
          s := Some (i,t)

      | `BTYP_pointer t2, `BTYP_pointer t1 ->
        eqns := (t1,t2) :: !eqns

      | `BTYP_binding (t11, t12), `BTYP_binding (t21, t22)
      | `BTYP_function (t11, t12), `BTYP_function (t21, t22) ->
        eqns := (t11,t21) :: (t12,t22) :: !eqns

      | `BTYP_void,`BTYP_void -> ()

      | `BTYP_inst (i1,ts1),`BTYP_inst (i2,ts2) ->
        if i1 <> i2 then raise Not_found
        else if length ts1 <> length ts2 then raise Not_found
        else
        begin
          let rec merge e a b = match a,b with
          | [],[] -> e
          | ah :: at, bh :: bt -> merge ((ah,bh) :: e) at bt
          | _ -> assert false
          in 
            eqns := merge !eqns ts1 ts2;
            s := None
        end

      | `BTYP_fix 0,_
      | _,`BTYP_fix 0 -> ()
        
      | `BTYP_fix i,`BTYP_fix j
      | `BTYP_name i, `BTYP_name j ->
        if i <> j then raise Not_found

      | (`BTYP_tuple ls1, `BTYP_tuple ls2) 
      | (`BTYP_sum ls1, `BTYP_sum ls2)  ->
        if length ls1 = length ls2 then
        begin
          let rec merge e a b = match a,b with
          | [],[] -> e
          | ah :: at, bh :: bt -> merge ((ah,bh) :: e) at bt
          | _ -> assert false
          in 
            eqns := merge !eqns ls1 ls2;
            s := None
        end
        else raise Not_found
      | _ -> raise Not_found
      end 
      ;
      begin match !s with
      | None -> ()
      | Some (i,t) ->
        eqns := 
          map 
          (fun (a,b) -> term_subst a i t, term_subst b i t) 
          !eqns
        ;
        assert(not (mem_assoc i !mgu));
        mgu := 
          (i,t) :: 
          (map 
            (fun (j,t') -> j,term_subst t' i t) 
            !mgu
          )
      end
      ;
      loop ()
    in 
      loop (); 
      !mgu

let maybe_unification dfns eqns = 
  try Some (unification dfns eqns)
  with Not_found -> None

let unifies dfns t1 t2 =
  try ignore(unification dfns [t1,t2]); true
  with Not_found -> false

(* a < b means a is more specialised than b *)
let compare_sigs dfns a b =
  (*
  print_endline ("Compare " ^ sbt dfns a ^ " with " ^ sbt dfns b);
  *)
  match maybe_unification dfns [a,b] with
  | None -> `Incomparable
  | Some [] -> `Equal
  | Some mgu ->
    let left = ref 0 and right = ref 0 in
    iter (fun (i,t) ->
      match t with `BTYP_var _ -> () | _ ->
      if var_i_occurs i a then incr left
      else incr right
    )
    mgu
    ;
    match !left,!right with
    | 0,0 -> `Equal
    | 0,_ -> `Less 
    | _,0 -> `Greater
    | _ -> `Incomparable

(* returns true if a and b have an mgu,
   and also adds each element of the mgu to
   the varmap if it isn't already present
   this routine is ONLY to be used for
   calculating the return types of functions,
   where we're unifying the type of the
   return statements... probably fails
   for generic functions .. since the two
   kinds of type variables aren't distinguished
   (Fun ret type var is an unknown type, not a 
   variable one .. it must be eliminated, but
   type parameters must not be [since they're
   instantiated to multiple values .. ..])
*)

let do_unify syms a b =
  let eqns = 
    [
      varmap_subst syms.varmap a, 
      varmap_subst syms.varmap b
    ] 
  in
  try 
    (*
    print_endline "Calling unification";
    *)
    let mgu = unification syms.dfns eqns in
    (*
    print_endline "mgu=";
    iter
    (fun (i, t) -> 
      print_endline (string_of_int i ^ " -> " ^ string_of_btypecode syms.dfns t)
    )
    mgu;
    *)
    iter
    (fun (i, t) ->
      if Hashtbl.mem syms.varmap i
      then 
        begin
          (*
          print_endline "Var already in varmap ..";
          *)
          let t' = Hashtbl.find syms.varmap i in
          if t' <> t then 
            failwith 
            (
               "[do_unify] binding for type variable " ^ string_of_int i ^
               " is inconsistent\n"
            )
          else ()
        end
      else 
        begin
          (*
          print_endline ("Adding variable " ^ string_of_int i ^ " type " ^ string_of_btypecode syms.dfns t);
          *)
          Hashtbl.add syms.varmap i t
        end
    )
    mgu
    ;
    true
  with Not_found -> false

let rec memq trail (a,b) = match trail with
  | [] -> false
  | (_,(i,j))::t -> i == a && j == b || memq t (a,b)

let rec type_eq' trail depth t1 t2 = 
  if memq trail (t1,t2) then true
  else let te a b = type_eq' ((depth,(t1,t2))::trail) (depth+1) a b in
  match t1,t2 with
  | `BTYP_inst (i1,ts1),`BTYP_inst (i2,ts2) -> 
    i1 = i2 && 
    length ts1 = length ts2 &&
    fold_left2 
    (fun tr a b -> tr && te a b) 
    true ts1 ts2
 
  | `BTYP_name i,`BTYP_name j 
    -> i = j 

  | `BTYP_sum ts1, `BTYP_sum ts2
  | `BTYP_tuple ts1,`BTYP_tuple ts2 ->
    if length ts1 = length ts2
    then 
      fold_left2 
      (fun tr a b -> tr && te a b) 
      true ts1 ts2
    else false

  | `BTYP_binding (s1,d1),`BTYP_binding (s2,d2)
  | `BTYP_function (s1,d1),`BTYP_function (s2,d2) 
    -> te s1 s2 && te d1 d2

  | `BTYP_pointer p1,`BTYP_pointer p2 
    -> te p1 p2

  | `BTYP_void,`BTYP_void
    -> true

  | `BTYP_var i, `BTYP_var j ->
    i = j

  | `BTYP_fix i,`BTYP_fix j ->
    i = j

  | `BTYP_fix i,t ->
    type_eq' trail depth (fst (assoc (depth+i) trail)) t

  | t,`BTYP_fix i ->
    type_eq' trail depth t (snd (assoc (depth+i) trail))

  | _ -> false

let type_eq t1 t2 = type_eq' [] 0 t1 t2

(* NOTE: only works on explicit fixpoint operators,
  i.e. it won't work on typedefs: no name lookup,
  these should be removed first .. 
  another view: only works on non-generative types.
*)

let unfold t =
  let rec aux depth t' = 
  let uf t = aux (depth+1) t in
  match t' with 
  | `BTYP_sum ls -> `BTYP_sum (map uf ls)
  | `BTYP_tuple ls -> `BTYP_tuple (map uf ls)
  | `BTYP_function (a,b) -> `BTYP_function (uf a, uf b)
  | `BTYP_pointer a -> `BTYP_pointer (uf a)
  | `BTYP_binding (a,b) -> `BTYP_binding (uf a, uf b)
  | `BTYP_fix i when (-i) = depth -> t
  | `BTYP_fix i when (-i) > depth -> 
    failwith ("[unfold] Fix point outside term, depth="^string_of_int i)

  | `BTYP_inst (i,ts) -> `BTYP_inst (i,map uf ts)
  | `BTYP_name i -> `BTYP_name i
  | _ -> t'
  in aux 0 t

exception Found of btypecode_t

(* this undoes an unfold: it won't minimise an arbitrary type *)
let fold t = 
  let rec aux trail depth t' = 
    let ax t = aux ((depth,t')::trail) (depth+1) t in
    match t' with
    | `BTYP_sum ls 
    | `BTYP_inst (_,ls)
    | `BTYP_tuple ls -> iter ax ls

    | `BTYP_binding (a,b)
    | `BTYP_function (a,b) -> ax a; ax b

    | `BTYP_pointer a  -> ax a

    | `BTYP_void
    | `BTYP_name _ 

    | `BTYP_var _ 
    | `BTYP_fix 0 -> ()

    | `BTYP_fix i ->
      let k = depth + i in
      begin try 
        let t'' = assoc k trail in
        if type_eq t'' t then raise (Found t'')
      with Not_found -> ()
      end 
    | _ -> failwith "unexpected metatype"
  in
    try aux [] 0 t; t
    with Found t -> t

(* produces a unique minimal representation of a type
by folding at every node *)

let minimise t = match map_btype fold t with x -> fold x

let var_occurs t =
  let rec aux t =
    match t with
    | `BTYP_sum ls 
    | `BTYP_inst (_,ls)
    | `BTYP_tuple ls -> iter aux ls

    | `BTYP_binding (a,b)
    | `BTYP_function (a,b) -> aux a; aux b

    | `BTYP_pointer a  -> aux a

    | `BTYP_void
    | `BTYP_name _ 
    | `BTYP_fix _ -> ()

    | `BTYP_var _ -> raise Not_found
    | _ -> failwith "unexpected metatype"

 in try aux t; false with Not_found -> true

let normalise_type t =
  let counter = ref 0 in
  let varmap = ref [] in
  let rec aux t = match map_btype aux t with
  | `BTYP_var i ->
    `BTYP_var 
    (
      match list_index !varmap i with
      | Some j -> j
      | None ->
        let n = !counter in 
        incr counter;
        varmap := !varmap @ [i];
        n
     )
   | x -> x
   in 
     let x = aux t in
     !varmap, x

