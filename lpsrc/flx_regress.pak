@import glob

@set_title('Regression Tests')
@execfile("config"+os.sep+"config.py")
@tdir = 'test'+os.sep+'regress'+os.sep

@flx_regress_levels = []
@flx_regress_level_str = ''
@def flx_regress_head(level, name):
  global flx_regress_levels,flx_regress_level_str
  while len(flx_regress_levels) < level: flx_regress_levels.append(0)
  flx_regress_levels[level - 1] = int(flx_regress_levels[level - 1]) + 1
  flx_regress_levels = flx_regress_levels[:level]

  for i in range(len(flx_regress_levels)):
    flx_regress_levels[i] = string.zfill(str(flx_regress_levels[i]), 2)

  flx_regress_level_str = string.join(flx_regress_levels,'.')
  
  return head(level, name)

@def kat(code):
  tangle("//Check " + code)
  f = get_tangler().sink.filename
  ff = string.split(f,'/')[-1][:-4]
  v = registry_out.get(code,[])
  if ff not in v:
    set_anchor(ff)
    v.append(ff) 
    registry_out[code]=v

@def emit_katlist():
  begin_list("keyed")
  keys = registry_in.keys()
  keys.sort()
  for k in keys:
    v = registry_in[k]
    item(k)
    first = 1
    for i in v:
      if first: first = 0
      else: weave(", ")
      ref_anchor(i)
  end_list()


@registry_in = {}
@registry_out = {}
@katfile="tmp" + os.sep + "kat-regress.tmp"
@try:
  execfile(katfile)
 except: pass

@flx_regress_head(1,'Regression tests')
There are four kinds of test. The compiler
must be run with standard output redirected
to /dev/null. All these tests use the standard
flx_run harness.

@begin_list('keyed')
@item('rt')
Each good test should generate output which,
when compared with a known good run, should
be much the same. Good tests typically have
several things tested. 
@item('dt')
Bad tests check the compiler issues
a diagnostic. Usually, they have just one
error.
@item('bt')
Nasty tests should crash. These are typically
things I'd like to catch with an improved
version of the compiler or run time.
@item('pt')
Performance tests measure speed. The result
is an overall time in seconds, which should
get smaller with each compiler improvement.
@item('dn')
Tests with non-deterministic results. Output
is printed, not compared with expected output.
@item('kf')
Tests that should compile, but are known to error out
or hang during compilation. These should be fixed in
some future version of the compiler.
@item('wt')
Tests that suggest a possible language changes that
are not currently implemented. They may or may not
be added to some future version of the compiler, so
they are not currently checked.
@end_list()

@head(2,"Category Reference",nospawn=1)
Tests by category keyword.
@emit_katlist()

@select(tangler('spkgs/flx_regression_tests_rt.py'))
@tangle("unit_tests = glob.glob('"+tdir+"rt-*.flx')")

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_drt.py'))
@tangle("dynamic_unit_tests = glob.glob('"+tdir+"drt-*.flx')")

pkg_requires = ['flx_compiler','flx_drivers','flx_regression_tests_rt']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_nd.py'))
@tangle("completion_tets = glob.glob('"+tdir+"nd-*.flx')")

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_bt.py'))
# these are supposed to fail!
@tangle("failure_tests = glob.glob('"+tdir+"bt-*.flx')")

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()

@select(tangler('spkgs/flx_regression_tests_kf.py'))
# these are supposed to fail!
@tangle("known_failed_tests = glob.glob('"+tdir+"kf-*.flx')")

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests.py'))
pkg_requires = [
  'flx_regression_tests_rt', 'flx_regression_tests_drt', 
  'flx_regression_tests_nd', 'flx_regression_tests_bt', 
  'flx_regression_tests_kf']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@flx_regress_head(2,'Good tests')

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("integer math")
#import <flx.flxh>
open Tiny;
open Short;
open Long;
open Vlong;
open Utiny;
open Ushort;
open Uint;
open Ulong;
open Uvlong;
open Int8;
open Int16;
open Int32;
open Int64;
open Uint8;
open Uint16;
open Uint32;
open Uint64;
@xs = [
  "2",
  "0b10","0B10",
  "0o2","0O2",
  "0d2","0D2",
  "0x2","0X2"
  ]
@ys = [
  "40","0b0010_1000","0B_0010_1000",
  "0o50","0O50",
  "0d40","0D40",
  "0x28",
  "0X28"
  ]
@ss = [
  "",
  "t","T","s","S","i","I","l","L","v","V","ll","LL",
  "u",
  "ut","uT","us","uS","ui","uI","ul","uL","uv","uV","ull","uLL",
  "Ut","UT","Us","US","Ui","UI","Ul","UL","Uv","UV","Ull","ULL",
  "U",
  "tu","Tu","su","Su","iu","Iu","lu","Lu","vu","Vu","llu","LLu",
  "tU","TU","sU","SU","iU","IU","lU","LU","vU","VU","llU","LLU",
  "i8","i16","i32","i64",
  "u8","u16","u32","u64"
  ]
@for x in xs:
  for y in ys:
    tname = "tst_"+x+y
    tangle("//noinline is needed to stop gcc dropping dead") 
    tangle("noinline proc "+tname+" () {")
    for s in ss:
      tangle("  assert(int_of("+x+s+" + "+y+s+")==42);") 
    tangle("}")
    tangle(tname+";")

print "test complete"; endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
test complete
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("closures")
@kat("recursion")
header r"""
#include <stdio.h>
typedef char *charp;
""";

typedef bool = 2;
type int = "int";
type string = "charp";

proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';

fun sub: int * int -> int = "$1 - $2";
fun mul: int * int -> int = "$1 * $2";
fun gt: int * int -> bool = "$1 > $2";
fun eq: int * int -> bool = "$1 == $2";

// test some recursion
fun fact(a:int): int =
{
  fun f (a:int, p:int) : int = {
    return 
      if a>1 then f(a-1, p*a) else p endif;
  }
  return f(a,1);
}

// test function variable
val factc : int -> int = fact of (int);
assert (fact 6 == 6 * 5 * 4 * 3 * 2);
assert (factc 6 == 6 * 5 * 4 * 3 * 2);

// test procedure variable
proc printer (a:int) { print a; }
val printv = printer of (int);
printer 10;
print "\n";
printv 10;

// test structure constructor function
struct X = {
  x : int;
  y : int;
}

proc printX (x:X) {
  print "x=";
  print x.x;
  print ", y=";
  print x.y;
  print "\n";
}

val x = X(1,2);
printX x;

// test special procedure overloading
proc t1() 
{
  proc print: int = 'printf("int=%d",$1);';
  print "Not hidden: ";
  print 1;
  print " print:int hides outer\n";
}
t1();

module A 
{
  proc print:int='printf("module A print int=%d",$1);';
  print 1;
  print "\n";
}
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
10
10x=1, y=2
Not hidden: int=1 print:int hides outer
module A print int=1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("laziness")
#import <flx.flxh>
// test lazy functions and procedures
print "lazy expr eval test\n";
var x = 1;
var y = 2;
val f = {x+y};
print (f ()); print "\n";
x = 3;
print (f ()); print "\n";
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
lazy expr eval test
3
5
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("strings")
// test the string library
#import <flx.flxh>
var x = "Hello";
x += "+";
x += "World";
print x; endl;
assert(x == "Hello+World");
print x.[1 to 6]; endl;
print x.[to 6]; endl;
print x.[6 to]; endl;
print x.[6 to -1]; endl;

var i = 0;
var n = len x;
while {i < n} {
  print x.[i];
  ++i;
};
endl;

i = 1;
while {i <= n} {
  print x.[-i];
  ++i;
};
endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
Hello+World
ello+
Hello+
World
Worl
Hello+World
dlroW+olleH
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
// test the chained comparison
#import <flx.flxh>
assert(1<2&<3&<4);
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("recursive types")
fun land: 2 * 2 -> 2 = "$1 && $2";
type int = "int";
fun eq: int * int -> 2 = "$1 == $2";

type string = "char*";
proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';
proc eol: 1 = 'printf("\\n");';

val x:int = 1;
val y : typeof(x) = 1;
val z = 25;

print  x; eol;
print  y; eol;
print  z; eol;

// now try recursive case


typedef tt = int * &tt;
var v : tt = (1,&v);
var u = (1,&u); // this is OK, type is 'tt'
val xx = match u with |(?x,_) => x endmatch;

print "OK"; eol;

fun f(i:int) = { return 1; }
fun e(i:int) = { return f 1; }

print (e 10); eol;

match (1,2) with
| (?x,2) => { print x; }
| (1,?y) => { print y; }
endmatch;
eol;

print (if 1==1 then "true" else "false" endif); eol;
print (if 1==0 then "true" else "false" endif); eol;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1
1
25
OK
1
1
true
false
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("closures")
#import <flx.flxh>
// closure formation test

// primitive function
fun appl(x:int, f:int * int -> int):int = {
  return f (x,x);
}

print "closure of add primitive ";
print (appl (2, add of (int*int))); endl;

// struct as function
struct X { x:int; }
fun execX(p:int->X):X = { return p(1); }
proc xprint(x:X){ print "struct X"; }
xprint (execX (X of (int))); endl;
xprint (execX (X)); endl;

// struct get projection as function
fun execx(p:X->int,a:X):int => p a;
proc pprint(x:int){ print "struct X: x get projection "; print x; }

// note: old get_x method not supported now!
fun getx(a:X):int=>a.x;
pprint (execx (getx of (X), X(42))); endl;

// C struct as function
header """
struct CX {int x; };
""";

cstruct CX { x:int; }
fun execCX(p:int->CX):CX = { return p(1); }
proc xprint(x:CX){ print "struct CX"; }
xprint (execCX (CX of (int))); endl;
xprint (execCX (CX)); endl;


// anonymous variant type constructor as function
typedef Y = 1 + int;
fun exec2(y2:int->Y,a:int):Y= { return  y2 a; }
proc yprint(y:Y) { print "union Y"; }
yprint (exec2(case 1 of Y, 1)); endl;

// named variant type constructor as function
union U = | A | B of int;
fun exec3(y2:int->U,a:int):U= { return  y2 a; }
proc xprint(y:U) { print "union U"; }
xprint (exec3(B of (int), 1)); endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
closure of add primitive 4
struct X
struct X
struct X: x get projection 42
struct CX
struct CX
union Y
union U
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("insertions")
// code insertion
body "#include <iostream>";
code 'static int x = 1;';
type int = "int";
fun add:int * int -> int = "$1 + $2";
fun two (): int = { return code[int]x + code[int]'x'; }
proc print:int = 'std::cout << $1 << std::endl;';
print (two());
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
2
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
multiple assignment

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("def statement")
#import <flx.flxh>
var a:int;
var b:int;
var c:int;

a,(b,c) = 1,(2,3);

print a; print " ";
print b; print " ";
print c; print " ";
endl;

def a = 1;
def val x = 2;
def var y = 3;

def a, val d, var e = 9,8,7;

print a; print " ";
print d; print " ";
print e; print " ";
endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1 2 3 
9 8 7 
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("type operator")
#import <flx.flxh>
open Long;

// test dual
typedef y = ~(int+int); // = int * int
val x : y = (1,2);

print x.(0); print " "; print x.(1); endl;

typedef ibl = typeof (1,1L);

// test typematch
typedef tt = typematch ibl with | _ * ?t as z => t * t * z endmatch;
var a:tt = (1L, 2L, (3,4L));

print a.(0); print " "; print a.(1); print " ";
print a.(2).(0); print " "; print a.(2).(1); endl;

typedef fun domainf (t:TYPE):TYPE => typematch t with | ?aa -> ?bb => aa endmatch;
typedef domains [t] = typematch t with | ?aa -> ?bb => aa endmatch;
typedef il = int -> long;
typedef ityf = domainf il;
typedef itys = domains [il];

val one:itys = 1;
val two:ityf = 1;
print one; endl;
print two; endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1 2
1 2 3 4
1
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
generics inlining/call lifting tests

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("polymorphism")
#import <flx.flxh>

proc f[k] (z:k, pr:k->void) {
  fun diag[t] (x:t):t*t = { return x,x; }
  fun prj1[t1,t2] (x:t1,y:t2):t1 = { return x; }
  fun prj2[t1,t2] (x:t1,y:t2):t2 = { return y; }
  pr (prj1(diag z)); endl;
}

// eta expansion
proc pr(x:int) { fprint (cout,x); }
f[int] (1, the pr);
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
call inlining
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("inlining")
#import <flx.flxh>
proc g[t]()
{
  proc h()
  {
    proc j[t]()
    {
      print "SIXTEEN\n";
      print "SEVENTEEN\n";
      print "EIGHTTEEN\n";
    }
    proc k()
    {
      print "THIRTEEN\n";
      print "FOURTEEN\n";
      print "FIFTEEN\n";
      j[int]();
    }
    print "TEN\n";
    print "ELEVEN\n";
    print "TWELVE\n";
    k();
  }
  print "SEVEN\n";
  print "EIGHT\n";
  print "NINE\n";
  h();
}

proc f[t]() {
  print "FOUR\n";
  print "FIVE\n";
  print "SIX\n";
  g[t]();
}

print "ONE\n";
print "TWO\n";
print "THREE\n";
f[int]();
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
ONE
TWO
THREE
FOUR
FIVE
SIX
SEVEN
EIGHT
NINE
TEN
ELEVEN
TWELVE
THIRTEEN
FOURTEEN
FIFTEEN
SIXTEEN
SEVENTEEN
EIGHTTEEN
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
call inlining

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("inlining")
#import <flx.flxh>

val x = 1;
if x == 1 then 
{ 
  if x == 1 
  then { print "ONE\n"; } 
  else { print "IMPOSSIBLE"; } 
  endif
  ;
}
else 
{ 
  print "TWO\n"; 
}
endif
;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
ONE
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
more generic stuff

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("polymorphism")
#import <flx.flxh>
open List;

fun snd(x,y)=>y;
fun fst(x,y)=>x;

fun index[t] (l:list[t]) = {
  fun f(il:int * list [int * t]) (e: t) =>
    match il with
    | ?i,?l => i+1, Cons ((i, e),l)
    endmatch
  ;
  return
    rev (snd ( fold_left
      f of (int * list[int *t])
      (0, Empty[int * t]) 
      l
    ))
  ;
}

var x = Empty[int];
x = Cons(11,x);
x = Cons(22,x);
x = Cons(33,x);
x = Cons(44,x);
x = Cons(55,x);
x = Cons(66,x);

val z = index x;
iter 
  (proc (x:int,y:int)
    {
      print x; print " -> "; print y; endl;
    }
  )
  z
;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
0 -> 66
1 -> 55
2 -> 44
3 -> 33
4 -> 22
5 -> 11
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("recursion")
@kat("tail call optimisation")
#import <flx.flxh>
// self-tail rec test (inspect output)
// (requires --inline atm)
var x = 4;
proc recur ()
{
  if x == 0 goto endoff;
  print x; endl;
  --x;
  recur();
endoff:>
}
recur();
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
4
3
2
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
non-self-tail rec test (inspect output) (requires --inline atm)

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("recursion")
@kat("tail call optimisation")
#import <flx.flxh>
var x = 4;
proc recur2 ()
{
  if x > 0 then 
  {
    print x; endl;
    --x;
    recur2();
  }
  else {} endif;
}
recur2();
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
4
3
2
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
self-tail rec test (inspect output) (requires --inline atm)

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("recursion")
@kat("tail call optimisation")
#import <flx.flxh>
fun g(x:int):int = {
  if x == 0 goto endoff;
  return g(x-1);
endoff:>
  return 1;
}
 
print (g 10); endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("recursion")
@kat("tail call optimisation")
#import <flx.flxh>
// non-self-tail rec test (inspect output)
// (requires --inline atm)

fun f(x:int)=>
  if(x == 0) then 1
  else f(x-1)
  endif
;
 
print (f 10); endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("lvalues")
// lvalue decay if function called thru variable
#import <flx.flxh>

proc f(g:int->void) { var x=1; g x; }
proc g(x:int) { }
f g of (int);
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("regmatch")
// contrib by Valery, mod by Skaller
#import <flx.flxh>

// emulate command line arguments
arguments := "--test", "words", "more words";
argc := 3;
fun argv (i:int):string =>
  match i with
  | 0 .. 2 => arguments.[i]
  | _ => ""
  endmatch
;
 
var i = 0;
whilst i < argc do
  print "checking arg "; print i; print "="; print (argv i); endl;
  regmatch (argv i) with
  | "--test" => { print "test"; endl; }
  | _*       => { print "terminating"; endl; i = argc; }
  endmatch;
  i++;
done;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
checking arg 0=--test
test
checking arg 1=words
terminating
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
Warning: result is dependent on implementation
detail (order of execution after read/write matchup)

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("fibres")
@kat("channels")
#import <flx.flxh>

var y = ();
proc f() { print "Hello"; endl; }
f y;

var x = mk_schannel[unit]();

proc reader() {
  print "R1"; endl;
  var &u:unit <- read x;
  print "R2"; endl;
}

proc writer() {
  print "W1"; endl;
  write (x,());
  print "W2"; endl;
}

spawn_fthread the reader;
spawn_fthread the writer;

print "Done"; endl;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
Hello
Done
W1
R1
R2
W2
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'a.flx'))
@kat("fibres")
@kat("channels")
#import <flx.flxh>
open Control;
 
var chin,chout = mk_ioschannel_pair[int] ();

spawn_fthread { 
  var x = 1; 
  whilst x <= 10 do 
    write$ chout,x; 
    ++x;
  done; 
};

spawn_fthread { 
  var x = 1; 
  whilst x < 10 do 
    read$ &x,chin; print x; endl; 
  done; 
};
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'a.expect','data'))
1
2
3
4
5
6
7
8
9
10
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("type constraints")
#import <flx.flxh>
open C_hack;
header '#include <iostream>';
// basic type constraints

// The general case is put in an open module
// so it is not considered if the specialisation applies
// but can still be selected otherwise
// Note Felix cannot order this kind of constraint.

open module X { fun f[t,u]: t * u -> int = "999"; }
fun f: !fast_ints * !fast_ints -> int = "$1+$2";

print$ f$ 1,2L; endl; // 3
print$ f$ 1,2.0; endl; // 999

@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
3
999
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("type constraints")
#import <flx.flxh>
open C_hack;
header '#include <iostream>';

fun f: !fast_ints * !fast_ints -> int = "$1+$2";

print$ f$ 1,2L; endl;

var x = 1;
var px:ptr[int] = addr x;

proc h[t,u:ptr[t]]: u  * t = "*$1=$2;";
h(px,1);

proc h2[t,u:ptr[t]]: u  * t = "*$1=$2;";
h2(px,1);

proc k[t,u:ptr[t]]: u = "std::cout << *$1 <<std::endl;";
k px;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
3
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("reductions")
@kat("axioms")
#import <flx.flxh>

// the noinline is needed because reductions are
// currently applies AFTER inlining. Hmm.

noinline fun f(x:int):int = { print "Cheat"; endl; return x; }

reduce idem(x:int): f ( f x ) => f x;

var x = f(f(f(f(1))));
print x; endl;

axiom symmetry (x:int,y:int): x + y == y + x;
axiom associativity (x:int, y:int, z:int): (x + y) + z == x + (y + z);
reduce additive_unit(x:int): x + 0 => x;
reduce multiplicative_unit(x:int): x * 0 => 0;
reduce additive_unit(x:int): 0 + x => x;
reduce multiplicative_unit(x:int): 0 * x=> 0;

//axiom wrong(x:int,y:int): x == y;
fun hh(x:int)=>x;

reduce silly (x:int): hh x => x;

axiom_check (1,2,3);

var i:int; forall i in 1 upto 5 do axiom_check (i,2); done;

axiom poly[t] ( sym:t * t -> t, eq:t * t-> bool, x:t, y:t): 
  sym(x,y) == sym(y,x)
;

axiom_check (add of (int * int), eq of (int * int), 1,2);
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
Cheat
1
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("member count")
#import <flx.flxh>
// HACK!
// NOTE: who_cares is now in the library! 
// See Typing::memcount.
//
const who_cares[t] : int = "#memcount";
print who_cares[22]; endl;

proc f[t,n] (a:t ^ n) { print who_cares[n]; endl; }
proc f2[t] (a:t) { print who_cares[t]; endl; }
var x: double ^ 42;
f x;
f2 x;
@doc()

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
22
42
42
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("arrays")
@kat("array iterators")
#import <flx.flxh>

open List;

proc foo (x:int) {
  print x;
  endl;
}

var x = [|1,2,3|];
var y = list(x);
var z = list(4,5,6);

Array::iter[int, 3] (the foo) x;
iter (the foo) y;
iter (the foo) z;

@select(tangler(tdir+"rt-"+flx_regress_level_str+".expect","data"))
1
2
3
1
2
3
4
5
6
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>
var z = 0;
noinline proc f
  (a:unit ->int)
  (b:unit ->int)
{ z = a() + b(); }
  
noinline proc g() { f {1} {2} ; };
g();
print z; endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
3
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>

union U =
| A of (unit -> void)
;

proc p0 (x:U)
{
  match x with
  | A ?f => {f;}
  endmatch;
}

proc p1
{
  print "hello"; endl;
}

p0$ A the p1;

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
hello
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("laziness")
@kat("lazy variables")
#include <flx.flxh>

var v = 1;

fun x => v;
fun y : int => 1; // just check syntax here

print$ x; endl;
v = 2;
print$ x; endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
1
2
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("ref semantics")
#include <flx.flxh>

noinline proc f(var x:int, val y:int)
{
  print$ x; endl;
  ++x;
  print$ x; endl;

  print$ y; endl;
  //++y;
  //print$ y; endl;
}

call f$ 3, 1;
var a = 1;
call f$ a, a;
print "------------------\n";

inline proc g(var x:int, val y:int)
{
  print$ x; endl;
  ++x;
  print$ x; endl;

  print$ y; endl;
  //++y;
  //print$ y; endl;
}

call g$ 3, 1;
var b = 1;
call g$ b, b;

noinline proc r(x:int, ref y:int)
{
  var z = case 1 of (int + long);
  print$ y; endl;
  y++;
  print $y; endl;
}

inline proc s(x:int, ref y:int)
{
  var z = case 1 of (int + long);
  print$ y; endl;
  y++;
  print $y; endl;
}

a = 66;

print "------------------\n";
r$ 1, &a;
print a; endl;

print "------------------\n";
s$ 1, &a;
print a; endl;
print "------------------\n";

noinline proc h(fun y: int)
{
  print$ y; endl;
  ++a;
  print$ y; endl;
}

inline proc k(fun y: int)
{
  print$ y; endl;
  ++a;
  print$ y; endl;

}

h { a+1 };
k { a +1 };
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
3
4
1
1
2
1
------------------
3
4
1
1
2
1
------------------
66
67
67
------------------
67
68
68
------------------
69
70
70
71
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("lexing keywords")
#import <flx.flxh>
#
module X {
  fun f(x:int)=> x + x;
}

#keyword f

print$ X::f 22; endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
44
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("translation of typedefs to _ctor_name calls")
#import <flx.flxh>

open module Foo
{
  typedef foo = int;
  fun _ctor_foo () => 5;
  val x = foo ();
  print x; endl;
}

val y = Foo::foo ();
print y; endl;

val z = foo ();
print z; endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
5
5
5
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("generators")
#import <flx.flxh>

var cheat : int = 0;
gen f():int = {
  ++cheat;
  //print "Generator "; print cheat; endl;
  return cheat;
}

print "F 1="; print$ f(); endl; // 1

body """
  static int x = 0;
  int g() { ++x; return x; }
""";

gen g : 1 -> int;

print "C 1="; print$ g(); endl; // 1

fun d(x:int) => x + x;

// all these should be even
print "F Even? "; print$ d(f()); endl; // 4
print "F Even? "; print$ d(f()); endl; // 6

print "C Even? "; print$ d(g()); endl; // 4
print "C Even? "; print$ d(g()); endl; // 6

print "F 4="; print$ f(); endl; // 4
print "C 4="; print$ g(); endl; // 4
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
F 1=1
C 1=1
F Even? 4
F Even? 6
C Even? 4
C Even? 6
F 4=4
C 4=4
@doc()

@flx_regress_head(3,tdir+'rt-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("generators")
#import <flx.flxh>

gen f(init:int)(inc:int):int = {
  var counter = init;
again:>
  counter += inc;
  yield counter;
  yield counter+1;
  goto again;
}

var x = f(40);
print$ x(2); endl; // 42
print$ x(999); endl; // 43
print$ x(2); endl; // 44 
print$ x(999); endl; // 45
print$ x(10); endl; // 54
print$ x(999); endl; // 55
print$ x(10); endl; // 64
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
42
43
44
45
54
55
64
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("generators")
#import <flx.flxh>

union tree = TEmpty | Leaf of int | Node of tree * tree;

var example = 
  Node 
  (
    Node
    (
      Leaf 1,
      Node
      (
        Leaf 2,
        Leaf 3
      )
    )
    ,
    Node
    (
      Leaf 4,
      Leaf 5
    )
  )
;

fun sum: tree->int =
  | Leaf ?x => x
  | Node (?l,?r) => sum l + sum r
  | TEmpty => 0
;

print$ sum example; endl;

fun accumulate(it: 1-> int):int=
{
  var x = 0;
  var v = it();
  whilst v != -1 do
    x += v;
    v = it();
  done;
  return x;
}

gen visitor(x:tree) () : int =
{
  var con =
    match x with
    | Leaf ?a => { print "visiting leaf "; print a; endl; yield a; return -1; }
    | Node (?a,?b) => 
      { 
        print "visiting node: left\n";
        var it = visitor(a);
        var v = it();
        whilst v != -1 do
          yield v;
          v = it();
        done;
        print "visiting node: right\n";
        it = visitor(b);
        v = it();
        whilst v != -1 do
          yield v;
          v = it();
        done;
        return -1;
      }
    | TEmpty => { return -1; }
    endmatch
  ;
  var r = con();
  whilst r != -1 do
    yield r;
    r = con();
  done;
  return -1;
}

var it = visitor(example);
var res = accumulate(it);
print$ res; endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
15
visiting node: left
visiting node: left
visiting leaf 1
visiting node: right
visiting node: left
visiting leaf 2
visiting node: right
visiting leaf 3
visiting node: right
visiting node: left
visiting leaf 4
visiting node: right
visiting leaf 5
15
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>

module Foo
{
  union foo = | A | B;

  fun _ctor_foo (x:int):foo => A;
}

val x = Foo::foo 5;

print$ match x with
| Foo::A => "a"
| Foo::B => "b"
endmatch;
endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
a
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
@kat("comments")
#import <flx.flxh>

//test
// test
print "1"; endl;//test
print "2"; endl; //test

print "3"; endl;/*
print "should not see this"; endl;
*/
print "4"; endl; /*
print "should not see this"; endl;
*/
print/*
print "should not see this"; endl;
*/"5"; endl; 
print /*
print "should not see this"; endl;
*/"6"; endl; 
print/*
print "should not see this"; endl;
*/ "7"; endl; 
print /*
print "should not see this"; endl;
*/ "8"; endl; 

print /*
print "should not see this"; endl;/*
print "should not see this"; endl;
*/print "should not see this"; endl;
*/ "9"; endl; 

print /*
print "should not see this"; endl; /*
print "should not see this"; endl;
*/print "should not see this"; endl;
*/ "10"; endl; 

print /*
print "should not see this"; endl;/*
print "should not see this"; endl;
*/ print "should not see this"; endl;
*/ "11"; endl; 

print /*
print "should not see this"; endl; /*
print "should not see this"; endl;
*/ print "should not see this"; endl;
*/ "12"; endl;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.expect','data'))
1
2
3
4
5
6
7
8
9
10
11
12
@doc()

@flx_regress_head(3,tdir+"rt-"+flx_regress_level_str+".flx")
test argument handling
@select(tangler(tdir+'rt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>
  
open List;

iter (proc (x:string) { print x; endl; })$ 
  match System::args() with
  | Empty[string] => Empty[string]
  | Cons(?h, ?t) => t
  endmatch
;
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.arguments','data'))
a b c
e f g
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.args0.expect','data'))
a
b
c
@doc()

@select(tangler(tdir+'rt-'+flx_regress_level_str+'.args1.expect','data'))
e
f
g
@doc()

@flx_regress_head(2,"Dynamic good tests")
@flx_regress_head(3,tdir+"drt-"+flx_regress_level_str+".flx")
// plugin loader test
@select(tangler(tdir+'drt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>

print "Starting .. "; endl;
@tangle('Dynlink::run_lib("./'+tdir+'rt-01.01.01'+EXT_SHLIB+'");')
@tangle('Dynlink::run_lib("./'+tdir+'rt-01.01.02'+EXT_SHLIB+'");')
print "Its run"; endl;
@doc()

@select(tangler(tdir+'drt-'+flx_regress_level_str+'.expect', 'data'))
Starting ..
test complete
10
10x=1, y=2
Not hidden: int=1 print:int hides outer
module A print int=1
Its run
@doc()

@flx_regress_head(2,'Bad tests')
All these should fail gracefully at (felix) compile time. 
Run the compiler with the -e option to invert
the return code parity.

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
basic parser error
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
module X { proc p(){} }
module Y { proc p(){} }
open X;
open Y;
p; // ambiguous
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
// open depends on self
#import <flx.flxh>
interface I { proc print_endl:int; }
module X {
  module M { proc print_endl (a:int) { print a; endl; } }
  module B = M:I;
}
open X;
open B;
print_endl 1;
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>
// these now fail OK: (should yield 'any' .. then fail overload :-)
val aa = bb + 1;
val bb = aa + 1;
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
// impossible recursion
type int = "int";
fun neg(a:int) = { return -a; }
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
// privacy violation
#import <flx.flxh>

module X 
{
  private fun f:int -> int = "$1";
  val x = f 1;
}
open X;
val x = f 1;
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
#define FIRST
#define FIRST
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.imp','data'))
#define FIRST
@doc()

@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
#define FIRST
@tangle('#import "bt-'+flx_regress_level_str+'.imp"')
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
// this should give an error at felix time
// but we only get one at C++ compile time

/*
[skaller@pelican] ~/links/flx>g++ -w -I. sss.cpp
sss.cpp: In member function `virtual flx::rtl::con_t*
   _i12_p11__init_::resume()':
sss.cpp:256: no matching function for call to `_i15_p6__lam_1::call(
   flx::rtl::con_t*&, _i18_f8__lam_2*&)'
sss.cpp:121: candidates are: virtual flx::rtl::con_t*
   _i15_p6__lam_1::call(flx::rtl::con_t*)
*/
ctypes int;
{ var x:int; read x; }

{ {var x:int; read x; } }

;
@doc()

@flx_regress_head(3,tdir+"bt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'bt-'+flx_regress_level_str+'.flx'))
// function drops off end
#import <flx.flxh>
fun f(x:int):int =
{
  if  x == 1 do return 1; done;
}
print (f 1); endl;
@doc()

@flx_regress_head(2,'Bad tests')
All these should successfully compile, but currently fail
or enter into an infinite loop.

@flx_regress_head(3,'kf-'+flx_regress_level_str+'.flx')
@select(tangler(tdir+'kf-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>

proc foo(x, y:int)
{
}

proc foo(x)
{
  foo (0, x);
}

foo 0;
@doc()

@flx_regress_head(2,'Wish tests')
Tests that suggest a possible language changes that
are not currently implemented. They may or may not
be added to some future version of the compiler, so
they are not currently checked.


@flx_regress_head(3,tdir+"wt-"+flx_regress_level_str+".flx")
@select(tangler(tdir+'wt-'+flx_regress_level_str+'.flx'))
#import <flx.flxh>

if (len s > 3) do
  print s;
  s := "12345\n";
done;
@doc()


@f = open(katfile,"w")
@f.write("registry_in="+repr(registry_out))
@f.close()

