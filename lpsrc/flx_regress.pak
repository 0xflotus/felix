@set_title('Regression Tests')

@import glob

@execfile("config"+os.sep+"config.py")
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env_rt  = setup_test('test/regress/rt-')
@env_srt = setup_test('test/regress/srt-')
@env_drt = setup_test('test/regress/drt-')
@env_pt  = setup_test('test/regress/pt-')
@env_nd  = setup_test('test/regress/nd-')
@env_bt  = setup_test('test/regress/bt-')
@env_kf  = setup_test('test/regress/kf-')
@env_wt  = setup_test('test/regress/wt-')

@def kat_rt(code): env_rt.kat(get_tangler(),code)
@def kat_srt(code): env_srt.kat(get_tangler(),code)
@def kat_drt(code): env_drt.kat(get_tangler(),code)
@def kat_pt(code): env_pt.kat(get_tangler(),code)
@def kat_nd(code): env_nd.kat(get_tangler(),code)
@def kat_bt(code): env_bt.kat(get_tangler(),code)
@def kat_kf(code): env_fk.kat(get_tangler(),code)
@def kat_wt(code): env_wt.kat(get_tangler(),code)

@head(1,'Regression tests')
There are four kinds of test. The compiler
must be run with standard output redirected
to /dev/null. All these tests use the standard
flx_run harness.

@begin_list('keyed')
@item('rt')
Each good test should generate output which,
when compared with a known good run, should
be much the same. Good tests typically have
several things tested. 
@item('dt')
Bad tests check the compiler issues
a diagnostic. Usually, they have just one
error.
@item('bt')
Nasty tests should crash. These are typically
things I'd like to catch with an improved
version of the compiler or run time.
@item('pt')
Performance tests measure speed. The result
is an overall time in seconds, which should
get smaller with each compiler improvement.
@item('nd')
Tests with non-deterministic results. Output
is printed, not compared with expected output.
@item('kf')
Tests that should compile, but are known to error out
or hang during compilation. These should be fixed in
some future version of the compiler.
@item('wt')
Tests that suggest a possible language changes that
are not currently implemented. They may or may not
be added to some future version of the compiler, so
they are not currently checked.
@end_list()

@head(2,"Category Reference",nospawn=1)
Tests by category keyword.
@env_rt.emit_katlist()
@env_srt.emit_katlist()
@env_drt.emit_katlist()
@env_pt.emit_katlist()
@env_nd.emit_katlist()
@env_kf.emit_katlist()
@env_wt.emit_katlist()

@env_rt.head(2,'Good tests')

@env_rt.head(3)
@rt_test1 = env_rt.test('.flx')
@select(rt_test1)
@kat_rt("integer math")
open Tiny;
open Short;
open Long;
open Vlong;
open Utiny;
open Ushort;
open Uint;
open Ulong;
open Uvlong;
open Int8;
open Int16;
open Int32;
open Int64;
open Uint8;
open Uint16;
open Uint32;
open Uint64;
@xs = [
  "2",
  "0b10","0B10",
  "0o2","0O2",
  "0d2","0D2",
  "0x2","0X2"
  ]
@ys = [
  "40","0b0010_1000","0B_0010_1000",
  "0o50","0O50",
  "0d40","0D40",
  "0x28",
  "0X28"
  ]
@ss = [
  "",
  "t","T","s","S","i","I","l","L","v","V","ll","LL",
  "u",
  "ut","uT","us","uS","ui","uI","ul","uL","uv","uV","ull","uLL",
  "Ut","UT","Us","US","Ui","UI","Ul","UL","Uv","UV","Ull","ULL",
  "U",
  "tu","Tu","su","Su","iu","Iu","lu","Lu","vu","Vu","llu","LLu",
  "tU","TU","sU","SU","iU","IU","lU","LU","vU","VU","llU","LLU",
  "i8","i16","i32","i64",
  "u8","u16","u32","u64"
  ]
@for x in xs:
  for y in ys:
    tname = "tst_"+x+y
    tangle("//noinline is needed to stop gcc dropping dead") 
    tangle("noinline proc "+tname+" () {")
    for s in ss:
      tangle("  assert(int_of("+x+s+" + "+y+s+")==42);") 
    tangle("}")
    tangle(tname+";")
print "test complete"; endl;
@doc()

@rt_expect1 = env_rt.expect()
@select(rt_expect1)
test complete
@doc()

@env_rt.head(3)
@rt_test2 = env_rt.test('.flx', categories=['closures', 'recursion'])
@select(rt_test2)
@kat_rt("closures")
@kat_rt("recursion")

// test some recursion
fun fact(a:int): int =
{
  fun f (a:int, p:int) : int = {
    return 
      if a>1 then f(a-1, p*a) else p endif;
  }
  return f(a,1);
}

// test function variable
val factc : int -> int = fact of (int);
assert (fact 6 == 6 * 5 * 4 * 3 * 2);
assert (factc 6 == 6 * 5 * 4 * 3 * 2);

// test procedure variable
proc printer (a:int) { print a; }
val printv = printer of (int);
printer 10;
print "\n";
printv 10;

// test structure constructor function
struct X = {
  x : int;
  y : int;
}

proc printX (x:X) {
  print "x=";
  print x.x;
  print ", y=";
  print x.y;
  print "\n";
}

val x = X(1,2);
printX x;

// test special procedure overloading
proc t1() 
{
  proc print: int = 'printf("int=%d",$1);';
  print "Not hidden: ";
  print 1;
  print " print:int hides outer\n";
}
t1();

module A 
{
  proc print:int='printf("module A print int=%d",$1);';
  print 1;
  print "\n";
}
@doc()

@rt_expect2 = env_rt.expect()
@select(rt_expect2)
10
10x=1, y=2
Not hidden: int=1 print:int hides outer
module A print int=1
@doc()

@env_rt.head(3)
@rt_test3 = env_rt.test('.flx')
@select(rt_test3)
@kat_rt("laziness")
// test lazy functions and procedures
print "lazy expr eval test\n";
var x = 1;
var y = 2;
val f = {x+y};
print (f ()); print "\n";
x = 3;
print (f ()); print "\n";
@doc()

@rt_expect3 = env_rt.expect()
@select(rt_expect3)
lazy expr eval test
3
5
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("export")
// The following program gets me c++ compilation errors when "print s" is
// commented out:

proc poot(s: charp) {
  // print s;
}

export proc poot of (charp) as "poot";

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("strings")
var x = "Hello";
x += "+";
x += "World";
print x; endl;
assert(x == "Hello+World");
print x.[1 to 6]; endl;
print x.[to 6]; endl;
print x.[6 to]; endl;
print x.[6 to -1]; endl;

var i = 0;
var n = len x;
while {i < n} {
  print x.[i];
  ++i;
};
endl;

i = 1;
while {i <= n} {
  print x.[-i];
  ++i;
};
endl;
@doc()

@select(env_rt.expect())
Hello+World
ello+
Hello+
World
Worl
Hello+World
dlroW+olleH
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("assert")
// chained comparison not implemented in nu grammar
assert(1<2 and 2<3 and 3<4);
@doc()

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("recursion:types")
proc eol: 1 = 'printf("\\n");';

val x:int = 1;
val y : typeof(x) = 1;
val z = 25;

print  x; eol;
print  y; eol;
print  z; eol;

// now try recursive case


typedef tt = int * &tt;
var v : tt = (1,&v);
var u = (1,&u); // this is OK, type is 'tt'
val xx = match u with |(?x,_) => x endmatch;

print "OK"; eol;

fun f(i:int) = { return 1; }
fun e(i:int) = { return f 1; }

print (e 10); eol;

match (1,2) with
| (?x,2) => { print x; }
| (1,?y) => { print y; }
endmatch;
eol;

print (if 1==1 then "true" else "false" endif); eol;
print (if 1==0 then "true" else "false" endif); eol;
@doc()

@select(env_rt.expect())
1
1
25
OK
1
1
true
false
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("closures")
// closure formation test

// primitive function
fun appl(x:int, f:int * int -> int):int = {
  return f (x,x);
}

print "closure of add primitive ";
print (appl (2, add of (int*int))); endl;

// struct as function
struct X { x:int; }
fun execX(p:int->X):X = { return p(1); }
proc xprint(x:X){ print "struct X"; }
xprint (execX (X of (int))); endl;
xprint (execX (X)); endl;

// struct get projection as function
fun execx(p:X->int,a:X):int => p a;
proc pprint(x:int){ print "struct X: x get projection "; print x; }

// note: old get_x method not supported now!
fun getx(a:X):int=>a.x;
pprint (execx (getx of (X), X(42))); endl;

// C struct as function
header """
struct CX {int x; };
""";

cstruct CX { x:int; }
fun execCX(p:int->CX):CX = { return p(1); }
proc xprint(x:CX){ print "struct CX"; }
xprint (execCX (CX of (int))); endl;
xprint (execCX (CX)); endl;


// anonymous variant type constructor as function
typedef Y = 1 + int;
fun exec2(y2:int->Y,a:int):Y= { return  y2 a; }
proc yprint(y:Y) { print "union Y"; }
yprint (exec2(case 1 of Y, 1)); endl;

// named variant type constructor as function
union U = | A | B of int;
fun exec3(y2:int->U,a:int):U= { return  y2 a; }
proc xprint(y:U) { print "union U"; }
xprint (exec3(B of (int), 1)); endl;
@doc()

@select(env_rt.expect())
closure of add primitive 4
struct X
struct X
struct X: x get projection 42
struct CX
struct CX
union Y
union U
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("insertions")
body "#include <iostream>";
code 'static int x = 1;';
type INT = "int";
fun add:INT * INT -> INT = "$1 + $2";
fun two (): INT = { return code[INT]x + code[INT]'x'; }
proc print:INT = 'std::cout << $1 << std::endl;';
print (two());
@doc()

@select(env_rt.expect())
2
@doc()

@env_rt.head(3)
multiple assignment

@select(env_rt.test('.flx'))
@kat_rt("statements:def")
var a:int;
var b:int;
var c:int;

a,(b,c) = 1,(2,3);

print a; print " ";
print b; print " ";
print c; print " ";
endl;

def a = 1;
def val x = 2;
def var y = 3;

def a, val d, var e = 9,8,7;

print a; print " ";
print d; print " ";
print e; print " ";
endl;
@doc()

@select(env_rt.expect())
1 2 3 
9 8 7 
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("type operators")
open Long;

// test dual
typedef y = ~(int+int); // = int * int
val x : y = (1,2);

print x.(0); print " "; print x.(1); endl;

typedef ibl = typeof (1,1L);

// test typematch
typedef tt = typematch ibl with | _ * ?t as z => t * t * z endmatch;
var a:tt = (1L, 2L, (3,4L));

print a.(0); print " "; print a.(1); print " ";
print a.(2).(0); print " "; print a.(2).(1); endl;

typedef fun domainf (t:TYPE):TYPE => typematch t with | ?aa -> ?bb => aa endmatch;
typedef domains [t] = typematch t with | ?aa -> ?bb => aa endmatch;
typedef il = int -> long;
typedef ityf = domainf il;
typedef itys = domains [il];

val one:itys = 1;
val two:ityf = 1;
print one; endl;
print two; endl;
@doc()

@select(env_rt.expect())
1 2
1 2 3 4
1
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("functors")
@kat_rt("polymorphism")
@kat_rt("types:higher order")

typedef fun pair (t:TYPE):TYPE => t * t;
typedef Pair[t] = t * t;
typedef PAIR = fun (t:TYPE):TYPE =>Pair[t];

var x: pair int;

fun f[t,u:TYPE->TYPE] (x: u t)=>x;

var k1 = f[int, the pair] (1,1);
var k2 = f[int, (fun (t:TYPE):TYPE =>Pair[t] ) ] (1,2);
var k3 = f[int, the PAIR] (1,3);
var k4 = f[int, the Pair] (1,4);

print k1.(0); print ","; print k1.(1); endl;
print k2.(0); print ","; print k2.(1); endl;
print k3.(0); print ","; print k3.(1); endl;
print k4.(0); print ","; print k4.(1); endl;
@doc()

@select(env_rt.expect())
1,1
1,2
1,3
1,4
@doc()

@env_rt.head(3)
generics inlining/call lifting tests

@select(env_rt.test('.flx'))
@kat_rt("polymorphism")

proc f[k] (z:k, pr:k->void) {
  fun diag[t] (x:t):t*t = { return x,x; }
  fun prj1[t1,t2] (x:t1,y:t2):t1 = { return x; }
  fun prj2[t1,t2] (x:t1,y:t2):t2 = { return y; }
  pr (prj1(diag z)); endl;
}

// eta expansion
proc pr(x:int) { fprint (cout,x); }
f[int] (1, the pr);
@doc()

@select(env_rt.expect())
1
@doc()

@env_rt.head(3)
call inlining
@select(env_rt.test('.flx'))
@kat_rt("inlining")
proc g[t]()
{
  proc h()
  {
    proc j[t]()
    {
      print "SIXTEEN\n";
      print "SEVENTEEN\n";
      print "EIGHTTEEN\n";
    }
    proc k()
    {
      print "THIRTEEN\n";
      print "FOURTEEN\n";
      print "FIFTEEN\n";
      j[int]();
    }
    print "TEN\n";
    print "ELEVEN\n";
    print "TWELVE\n";
    k();
  }
  print "SEVEN\n";
  print "EIGHT\n";
  print "NINE\n";
  h();
}

proc f[t]() {
  print "FOUR\n";
  print "FIVE\n";
  print "SIX\n";
  g[t]();
}

print "ONE\n";
print "TWO\n";
print "THREE\n";
f[int]();
@doc()

@select(env_rt.expect())
ONE
TWO
THREE
FOUR
FIVE
SIX
SEVEN
EIGHT
NINE
TEN
ELEVEN
TWELVE
THIRTEEN
FOURTEEN
FIFTEEN
SIXTEEN
SEVENTEEN
EIGHTTEEN
@doc()

@env_rt.head(3)
call inlining

@select(env_rt.test('.flx'))
@kat_rt("inlining")

val x = 1;
if x == 1 then 
{ 
  if x == 1 
  then { print "ONE\n"; } 
  else { print "IMPOSSIBLE"; } 
  endif
  ;
}
else 
{ 
  print "TWO\n"; 
}
endif
;
@doc()

@select(env_rt.expect())
ONE
@doc()

@env_rt.head(3)
more generic stuff

@select(env_rt.test('.flx'))
@kat_rt("polymorphism")
open List;

fun snd(x,y)=>y;
fun fst(x,y)=>x;

fun index[t] (l:list[t]) = {
  fun f(il:int * list [int * t]) (e: t) =>
    match il with
    | ?i,?l => i+1, Cons ((i, e),l)
    endmatch
  ;
  return
    rev (snd ( fold_left
      f of (int * list[int *t])
      (0, Empty[int * t]) 
      l
    ))
  ;
}

var x = Empty[int];
x = Cons(11,x);
x = Cons(22,x);
x = Cons(33,x);
x = Cons(44,x);
x = Cons(55,x);
x = Cons(66,x);

val z = index x;
iter 
  (proc (x:int,y:int)
    {
      print x; print " -> "; print y; endl;
    }
  )
  z
;
@doc()

@select(env_rt.expect())
0 -> 66
1 -> 55
2 -> 44
3 -> 33
4 -> 22
5 -> 11
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['recursion', 'tail call optimisation']))
// self-tail rec test (inspect output)
// (requires --inline atm)
var x = 4;
proc recur ()
{
  if x == 0 goto endoff;
  print x; endl;
  --x;
  recur();
endoff:>
}
recur();
@doc()

@select(env_rt.expect())
4
3
2
1
@doc()

@env_rt.head(3)
non-self-tail rec test (inspect output) (requires --inline atm)

@select(env_rt.test('.flx', categories=['recursion', 'tail call optimisation']))
var x = 4;
proc recur2 ()
{
  if x > 0 then 
  {
    print x; endl;
    --x;
    recur2();
  }
  else {} endif;
}
recur2();
@doc()

@select(env_rt.expect())
4
3
2
1
@doc()

@env_rt.head(3)
self-tail rec test (inspect output) (requires --inline atm)

@select(env_rt.test('.flx', categories=['recursion', 'tail call optimisation']))
fun g(x:int):int = {
  if x == 0 goto endoff;
  return g(x-1);
endoff:>
  return 1;
}
 
print (g 10); endl;
@doc()

@select(env_rt.expect())
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['recursion', 'tail call optimisation']))
// non-self-tail rec test (inspect output)
// (requires --inline atm)

fun f(x:int)=>
  if(x == 0) then 1
  else f(x-1)
  endif
;
 
print (f 10); endl;
@doc()

@select(env_rt.expect())
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['lvalues']))
// lvalue decay if function called thru variable

proc f(g:int->void) { var x=1; g x; }
proc g(x:int) { }
f g of (int);
@doc()

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['regmatch']))
// contrib by Valery, mod by Skaller

// emulate command line arguments
arguments := "--test", "words", "more words";
argc := 3;
fun argv (i:int):string =>
  match i with
  | 0 .. 2 => arguments.[i]
  | _ => ""
  endmatch
;
 
var i = 0;
whilst i < argc do
  print "checking arg "; print i; print "="; print (argv i); endl;
  regmatch (argv i) with
  | "--test" => { print "test"; endl; }
  | _*       => { print "terminating"; endl; i = argc; }
  endmatch;
  i++;
done;
@doc()

@select(env_rt.expect())
checking arg 0=--test
test
checking arg 1=words
terminating
@doc()

@env_rt.head(3)
Warning: result is dependent on implementation
detail (order of execution after read/write matchup)

@select(env_rt.test('.flx', categories=['fibres', 'channels']))

var y = ();
proc f() { print "Hello"; endl; }
f y;

var x = mk_schannel[unit]();

proc reader() {
  print "R1"; endl;
  var &u:unit <- read x;
  print "R2"; endl;
}

proc writer() {
  print "W1"; endl;
  write (x,());
  print "W2"; endl;
}

spawn_fthread the reader;
spawn_fthread the writer;

print "Done"; endl;
@doc()

@select(env_rt.expect())
Hello
Done
W1
R1
R2
W2
@doc()

@select(env_rt.test('.flx', categories=['fibres', 'channels']))
open Control;
 
var chin,chout = mk_ioschannel_pair[int] ();

spawn_fthread { 
  var x = 1; 
  whilst x <= 10 do 
    write$ chout,x; 
    ++x;
  done; 
};

spawn_fthread { 
  var x = 1; 
  whilst x < 10 do 
    read$ &x,chin; print x; endl; 
  done; 
};
@doc()

@select(env_rt.expect())
1
2
3
4
5
6
7
8
9
10
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['type constraints']))
open C_hack;
header '#include <iostream>';
// basic type constraints

// The general case is put in an open module
// so it is not considered if the specialisation applies
// but can still be selected otherwise
// Note Felix cannot order this kind of constraint.

open module X { fun f[t,u]: t * u -> int = "999"; }
fun f: !fast_ints * !fast_ints -> int = "$1+$2";

print$ f$ 1,2L; endl; // 3
print$ f$ 1,2.0; endl; // 999

@doc()

@select(env_rt.expect())
3
999
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['type constraints']))
open C_hack;
header '#include <iostream>';

fun f: !fast_ints * !fast_ints -> int = "$1+$2";

print$ f$ 1,2L; endl;

var x = 1;
var px:ptr[int] = addr x;

proc h[t,u=ptr[t]]: u  * t = "*$1=$2;";
h(px,1);

proc h2[t,u=ptr[t]]: u  * t = "*$1=$2;";
h2(px,1);

proc k[t,u=ptr[t]]: u = "std::cout << *$1 <<std::endl;";
k px;
@doc()

@select(env_rt.expect())
3
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['type constraints']))
open C_hack;
header '#include <iostream>';
proc pr[t]:t="std::cout<<$1<<std::endl;";

var x = 1;
var px:ptr[int] = addr x;

module X {
  proc h[t,u=ptr[t]]: u  * t = '*$1=$2; std::cout <<*$1<<","<<$2<<std::endl;';
  h(px,1);

  // address and dereference operators where
  // constraint is required to deduce type variable
  // (artificial example, since we could write signatures
  // directly in terms of t)
  fun adr[t,u=ptr[t]]: lvalue[t]->u = "&$1";
  fun drf[t,u=ptr[t]]:  u -> t = "*$1";
  //h(px,1.1); // should fail
}

open X[int];
h(px,1);
//h(px,1.1); // should fail

pr$ drf px;
pr$ drf$ adr x;
pr$ X::drf px;
pr$ X::drf$ X::adr x;

fun ff[t,k where t==k ]: t * k -> t = "$1+$2";

pr$ ff$ 1,2; 
//pr$ ff$ 1,2.0; // should fail
@doc()

@select(env_rt.expect())
1,1
1,1
1
1
1
1
3
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['reductions', 'axioms']))

noinline fun f(x:int):int = { print "Cheat"; endl; return x; }

reduce idem(x:int): f ( f x ) => f x;

var x = f(f(f(f(1))));
print x; endl;

axiom symmetry (x:int,y:int): x + y == y + x;
axiom associativity (x:int, y:int, z:int): (x + y) + z == x + (y + z);
reduce additive_unit(x:int): x + 0 => x;
reduce multiplicative_unit(x:int): x * 0 => 0;
reduce additive_unit(x:int): 0 + x => x;
reduce multiplicative_unit(x:int): 0 * x=> 0;

//axiom wrong(x:int,y:int): x == y;
fun hh(x:int)=>x;

reduce silly (x:int): hh x => x;

axiom_check (1,2,3);

var i:int=1; 
lab:>
  axiom_check (i,2); 
  i=i+1;
  if i <= 5  goto lab;

axiom poly[t] ( sym:t * t -> t, eq:t * t-> bool, x:t, y:t): 
  sym(x,y) == sym(y,x)
;

axiom_check (add of (int * int), eq of (int * int), 1,2);

@doc()

@select(env_rt.expect())
Cheat
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['member count']))
// HACK!
// NOTE: who_cares is now in the library! 
// See Typing::memcount.
//
const who_cares[t] : int = "#memcount";
print who_cares[22]; endl;

proc f[t,n] (a:t ^ n) { print who_cares[n]; endl; }
proc f2[t] (a:t) { print who_cares[t]; endl; }
var x: double ^ 42;
f x;
f2 x;
@doc()

@select(env_rt.expect())
22
42
42
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['arrays', 'array iterators']))

open List;

proc foo (x:int) {
  print x;
  endl;
}

var x = [|1,2,3|];
var y = list(x);
var z = list(4,5,6);

Array::iter[int, 3] (the foo) x;
iter (the foo) y;
iter (the foo) z;

@select(env_rt.expect())
1
2
3
1
2
3
4
5
6
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
var z = 0;
noinline proc f
  (a:unit ->int)
  (b:unit ->int)
{ z = a() + b(); }
  
noinline proc g() { f {1} {2} ; };
g();
print z; endl;
@doc()

@select(env_rt.expect())
3
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))

union U =
| A of (unit -> void)
;

proc p0 (x:U)
{
  match x with
  | A ?f => {f;}
  endmatch;
}

proc p1
{
  print "hello"; endl;
}

p0$ A the p1;

@select(env_rt.expect())
hello
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['laziness', 'lazy variables']))

var v = 1;

fun x => v;
fun y : int => 1; // just check syntax here

print$ x; endl;
v = 2;
print$ x; endl;
@doc()

@select(env_rt.expect())
1
2
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx', categories=['ref semantics']))

noinline proc f(var x:int, val y:int)
{
  print$ x; endl;
  ++x;
  print$ x; endl;

  print$ y; endl;
  //++y;
  //print$ y; endl;
}

call f$ 3, 1;
var a = 1;
call f$ a, a;
print "------------------\n";

inline proc g(var x:int, val y:int)
{
  print$ x; endl;
  ++x;
  print$ x; endl;

  print$ y; endl;
  //++y;
  //print$ y; endl;
}

call g$ 3, 1;
var b = 1;
call g$ b, b;

noinline proc r(x:int, ref y:int)
{
  var z = case 1 of (int + long);
  print$ y; endl;
  y++;
  print $y; endl;
}

inline proc s(x:int, ref y:int)
{
  var z = case 1 of (int + long);
  print$ y; endl;
  y++;
  print $y; endl;
}

a = 66;

print "------------------\n";
r$ 1, &a;
print a; endl;

print "------------------\n";
s$ 1, &a;
print a; endl;
print "------------------\n";

noinline proc h(fun y: int)
{
  print$ y; endl;
  ++a;
  print$ y; endl;
}

inline proc k(fun y: int)
{
  print$ y; endl;
  ++a;
  print$ y; endl;

}

h { a+1 };
k { a +1 };
@doc()

@select(env_rt.expect())
3
4
1
1
2
1
------------------
3
4
1
1
2
1
------------------
66
67
67
------------------
67
68
68
------------------
69
70
70
71
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("lexing:keywords")
#
module X {
  fun f(x:int)=> x + x;
}

#keyword f

print$ X::f 22; endl;
@doc()

@select(env_rt.expect())
44
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("applicative types")

open module Foo
{
  typedef foo = int;
  fun _ctor_foo () => 5;
  val x = foo ();
  print x; endl;
}

val y = Foo::foo ();
print y; endl;

val z = foo ();
print z; endl;
@doc()

@select(env_rt.expect())
5
5
5
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("generators")

var cheat : int = 0;
gen f():int = {
  ++cheat;
  //print "Generator "; print cheat; endl;
  return cheat;
}

print "F 1="; print$ f(); endl; // 1

body """
  static int x = 0;
  int g() { ++x; return x; }
""";

gen g : 1 -> int;

print "C 1="; print$ g(); endl; // 1

fun d(x:int) => x + x;

// all these should be even
print "F Even? "; print$ d(f()); endl; // 4
print "F Even? "; print$ d(f()); endl; // 6

print "C Even? "; print$ d(g()); endl; // 4
print "C Even? "; print$ d(g()); endl; // 6

print "F 4="; print$ f(); endl; // 4
print "C 4="; print$ g(); endl; // 4
@doc()

@select(env_rt.expect())
F 1=1
C 1=1
F Even? 4
F Even? 6
C Even? 4
C Even? 6
F 4=4
C 4=4
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("generators")

gen f(init:int)(inc:int):int = {
  var counter = init;
again:>
  counter += inc;
  yield counter;
  yield counter+1;
  goto again;
}

var x = f(40);
print$ x(2); endl; // 42
print$ x(999); endl; // 43
print$ x(2); endl; // 44 
print$ x(999); endl; // 45
print$ x(10); endl; // 54
print$ x(999); endl; // 55
print$ x(10); endl; // 64
@doc()

@select(env_rt.expect())
42
43
44
45
54
55
64
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("generators")

union tree = TEmpty | Leaf of int | Node of tree * tree;

var example = 
  Node 
  (
    Node
    (
      Leaf 1,
      Node
      (
        Leaf 2,
        Leaf 3
      )
    )
    ,
    Node
    (
      Leaf 4,
      Leaf 5
    )
  )
;

fun sum: tree->int =
  | Leaf ?x => x
  | Node (?l,?r) => sum l + sum r
  | TEmpty => 0
;

print$ sum example; endl;

fun accumulate(it: 1-> int):int=
{
  var x = 0;
  var v = it();
  whilst v != -1 do
    x += v;
    v = it();
  done;
  return x;
}

gen visitor(x:tree) () : int =
{
  var con =
    match x with
    | Leaf ?a => { print "visiting leaf "; print a; endl; yield a; return -1; }
    | Node (?a,?b) => 
      { 
        print "visiting node: left\n";
        var it = visitor(a);
        var v = it();
        whilst v != -1 do
          yield v;
          v = it();
        done;
        print "visiting node: right\n";
        it = visitor(b);
        v = it();
        whilst v != -1 do
          yield v;
          v = it();
        done;
        return -1;
      }
    | TEmpty => { return -1; }
    endmatch
  ;
  var r = con();
  whilst r != -1 do
    yield r;
    r = con();
  done;
  return -1;
}

var it = visitor(example);
var res = accumulate(it);
print$ res; endl;
@doc()

@select(env_rt.expect())
15
visiting node: left
visiting node: left
visiting leaf 1
visiting node: right
visiting node: left
visiting leaf 2
visiting node: right
visiting leaf 3
visiting node: right
visiting node: left
visiting leaf 4
visiting node: right
visiting leaf 5
15
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))

module Foo
{
  union foo = | A | B;

  fun _ctor_foo (x:int):foo => A;
}

val x = Foo::foo 5;

print$ match x with
| Foo::A => "a"
| Foo::B => "b"
endmatch;
endl;
@doc()

@select(env_rt.expect())
a
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("lexing:comments")

//test
// test
print "1"; endl;//test
print "2"; endl; //test

print "3"; endl;/*
print "should not see this"; endl;
*/
print "4"; endl; /*
print "should not see this"; endl;
*/
print/*
print "should not see this"; endl;
*/"5"; endl; 
print /*
print "should not see this"; endl;
*/"6"; endl; 
print/*
print "should not see this"; endl;
*/ "7"; endl; 
print /*
print "should not see this"; endl;
*/ "8"; endl; 

print /*
print "should not see this"; endl;/*
print "should not see this"; endl;
*/print "should not see this"; endl;
*/ "9"; endl; 

print /*
print "should not see this"; endl; /*
print "should not see this"; endl;
*/print "should not see this"; endl;
*/ "10"; endl; 

print /*
print "should not see this"; endl;/*
print "should not see this"; endl;
*/ print "should not see this"; endl;
*/ "11"; endl; 

print /*
print "should not see this"; endl; /*
print "should not see this"; endl;
*/ print "should not see this"; endl;
*/ "12"; endl;
@doc()

@select(env_rt.expect())
1
2
3
4
5
6
7
8
9
10
11
12
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("types:nested")

fun f(x:int)= {
  union x_t = | X of int;
  fun pr(a:x_t): int = {
    return
      match a with
      | X ?i => i
      | _ => 0
      endmatch
    ;
  }
  val a = X x;
  return a,the pr;
}

val v,d = f 1;

print$ d v; endl;
@doc()
@select(env_rt.expect())
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("goto:nonlocal")

proc f () {
  val x = { goto foo; };
  print 'there'; endl;
  foo:>
  print 'here'; endl;
}

f;

proc g () {
  val x = { goto foo; };
  print 'there'; endl;
  foo:>
  print 'here'; endl;
}

g;
@doc()

@select(env_rt.expect())
there
here
there
here
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("generators")
 
gen f ():int = {
  var i:int; forall i in 0 upto 5 do
    yield i;
  done;
  halt "Call exhausted generator";
}

var g = the f;
print$ g (); endl;
print$ g (); endl;
print$ g (); endl;
print$ g (); endl;
@doc()

@select(env_rt.expect())
0
1
2
3
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("type constraints")
open C_hack;
header '#include <iostream>';
proc pr[t]:t="std::cout<<$1<<std::endl;";
fun f: !fast_ints * !fast_ints -> int = "$1+$2";

print$ f$ 1,2L; endl;

var x = 1;
var px:ptr[int] = addr x;

module X {
  proc h[t,u=ptr[t]]: u  * t = '*$1=$2; std::cout <<*$1<<","<<$2<<std::endl;';
  h(px,1);

  fun adr[t,u=ptr[t]]: lvalue[t]->u = "&$1";
  fun drf[t,u=ptr[t]]:  u -> t = "*$1";
//h(px,1.1);
}

open X[int]; // only specifies 1 variable
h(px,1);
//h(px,1.1);
pr$ drf px;
pr$ drf$ adr x;
pr$ X::drf px;
pr$ X::drf$ X::adr x;

proc h2[t,u=ptr[t]]: u  * t = "*$1=$2;";
h2(px,1);

proc k[t,u=ptr[t]]: u = "std::cout << *$1 <<std::endl;";
k px;

fun ff[t,k where t==k ]: t * k -> t = "$1+$2";


pr$ ff$ 1,2; 
//pr$ ff$ 1,2.0;

@select(env_rt.expect())
3
1,1
1,1
1
1
1
1
1
3
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("typeclasses")
proc pr[t]:t="std::cout<<$1<<std::endl;" requires iostream;

typeclass XEq[t,u] {
  virtual fun xeq: t * u -> 2;
  virtual proc ppp: t;
}

instance XEq[int,int] {
  fun xeq: int * int -> 2 = "$1==$2";
  proc ppp (x:int) { pr x; }
  fun fred: int -> int = "";
}


instance XEq[long,int] {
  fun xeq: long * int -> 2 = "$1==$2";
  proc ppp (x:long) { pr x; }
}

fun jeq[r,s with XEq[r,s]] (x:r,y:s)=> xeq(x,y);
fun keq[t with XEq[t,t]] (x:t,y:t)=> jeq(x,y);
fun peq[t with XEq[t,t]] (x:t,y:t)=> keq(x,y);
proc zzz[t with XEq[t,t]] (x:t) { ppp x; }

pr$ peq$ 1,2; 
pr$ peq$ 1,1; 

zzz 1;
@doc()
@select(env_rt.expect())
0
1
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("typeclasses")

open List;

typeclass Str2[T] {
  virtual fun str2: T->string;
}

instance Str2[int] {
  fun str2 (x:int): string => str x;
}

fun str2[T with Str[T]] (x:list[T]):string =>
  match x with
  | Empty[T] => "()"
  | Cons(?h, ?t) => "(" + (str2 h) + ", "  + (str2 t) + ")"
  endmatch
;

fun str2[T with Str2[T]] (x:T) => str2 x;

print$ str2 5; endl;
print$ str2$ list(1,2,3,4); endl;

@select(env_rt.expect())
5
(1, (2, (3, (4, ()))))
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("typeclasses:inheritance")
@kat_rt("inherit:specialisation")
header '#include <iostream>';

typeclass XEq[t] {
  virtual fun xeq: t * t -> bool;
  virtual fun xne: t * t -> bool;
}

typeclass XCmp[t] {
  inherit XEq[t];
  virtual fun xlt: t * t -> bool;
  virtual fun xgt: t * t -> bool;
  virtual fun xle: t * t -> bool;
  virtual fun xge: t * t -> bool;
}

instance XEq[int] {
  fun xeq: int * int -> bool = "$1==$2";  
  fun xne: int * int -> bool = "$1!=$2";  
}

instance XCmp[int] {
  fun xlt: int * int -> bool = "$1<$2" ;
  fun xgt: int * int -> bool = "$1>$2" ;
  fun xle: int * int -> bool = "$1<=$2" ;
  fun xge: int * int -> bool = "$1>=$2" ;
}

fun feq[with XEq[int]] (x:int,y:int) => xeq(x,y);
fun geq[with XCmp[int]] (x:int,y:int) => xeq(x,y);

print$ feq(1,2); endl;
print$ geq(1,2); endl;

module Fred[t]
{
  proc pr: t = "std::cout<<$1<<endl;";
}

Fred::pr 1; 

module Joe
{
  inherit Fred[int];
}

Joe::pr 1; 

open Joe;
pr 1;
@doc()
@select(env_rt.expect())
false
false
1
1
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("typeclasses:polymorphic methods")

typeclass X[u] {
  virtual fun f[v]: u * v -> int;
}

instance X[int] {
  fun f[v]: int * v -> int = "(int)$1+$2";
}

fun g[with X[int]] (x:int, y:long) => f(x,y);

print$ g$ 1,2L; endl;

@select(env_rt.expect())
3
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("typeclasses:imbue module")
@kat_rt("typeclasses:polymorphic methods")
header '#include <iostream>';


typeclass XEq[t] {
  virtual fun xeq: t * t -> bool;
  virtual fun xne: t * t -> bool;
}

instance XEq[int] {
  fun xeq: int * int -> bool = "$1==$2";  
  fun xne: int * int -> bool = "$1!=$2";  
}

module Joe[with XEq[int]] {
  fun feq(x:int,y:int) => xeq(x,y);
}
print$ Joe::feq(1,2); endl;

module Max[t with XEq[t]] {
  fun feq(x:t,y:t) => xeq(x,y);
}
print$ Max::feq(1,1); endl;

@select(env_rt.expect())
false
true
@doc()
@env_rt.head(3)
@select(env_rt.test('.flx'))
#import <flx.flxh>;
open List;


fun eq[T]: T * T -> bool = "$1==$2";

fun eql[T] (x:T) (y:T):bool => eq(x, y);

//-----------------------------------------------------------------------------
// Double Linked List of T
//-----------------------------------------------------------------------------

class DLL_List[T] {
    var next : DLL_List[T];
    var prev : DLL_List[T];
    var item : T;

    ctor (n:T)
    {
        item = n;
    }

    proc add_Link (nxt:DLL_List[T])
    {
        nxt.prev = this;
        nxt.next = next;
        nxt.next.prev = nxt;
        next = nxt;
    }

    proc pr_list()
    {
        proc aux(head:DLL_List[T], been: list[DLL_List[T]])
        {
            print "Listn(";
            print[T] item;
            print ")->";
            if (mem (eql this) been) == false do
                aux (next, Cons[DLL_List[T]](this, been));
            else
                print "Loop\n";
            done;
        }
        aux(this,Empty[DLL_List[T]]);
    }
}
var lst1 <- new DLL_List[int](11);
var lst2 <- new DLL_List[int](11);

lst1.pr_list();
endl;
var xx = (eql lst1);
print (xx lst1);
endl;
print (xx lst2);
endl;

@select(env_rt.expect())
Listn(11)->Listn(11)->Loop

true
false
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("type:abstract")

module X {
  open C_hack;
  type pi = new int * int;
  fun fst(x:pi):int => (_repr_ x).(0);
  fun snd(x:pi):int => (_repr_ x).(1);
  fun mkpi(x:int,y:int):pi=>_make_pi(x,y);
  
  type pif = new int * double;
  fun fst(x:pif):int => (_repr_ x).(0);
  fun snd(x:pif):double => (_repr_ x).(1);
  fun mkpif(x:int,y:double):pif=>_make_pif(x,y);

  type ii = new int;
  fun mkii(x:int):ii=> _make_ii x;
  fun get(x:ii):int=>_repr_ x;
}

open X;

var x:pi = mkpi$ 1,2;
print$ str(fst x) + " " + str(snd x) + ";\n";

var y:pif = mkpif$ 1,2.76;
print$ str(fst y) + " " + str(snd y) + ";\n";

var z = mkii 99;
print$ get z; endl;

//print$ str x.(0); endl;

@select(env_rt.expect())
1 2;
1 2.76;
99
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("types:recursive")
@kat_rt("type functions:recursive")

typedef fun uncurry(t:TYPE):TYPE =>
  typematch t with
  | ?head -> ?tail => head * uncurry tail
  | _ => t
  endmatch
;

typedef f123 = int -> (long -> float);

typedef f567 = uncurry f123;

var x: f567 = 1, (2L, 3.0f);

typedef list = 1 + int * list;

typedef fun lst(t1:TYPE, t2:TYPE ):TYPE=> 1 + t1 * lst (t2,t1);

var y1: lst (int,long);
var y2:  1 + int * (1 + long * x)  as x;
y1 = y2;

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("purely functional")
#import <flx.flxh>;

open List;

open Avl;

proc pr_node (x:int) {
    print "B(";
    print x;
    print ")\n";
}

proc pr_tree(tree:avl[int]) {
    Avl::iter[int] (pr_node of int, tree);
}

proc pr_node (d:int, x:int) {
    print ("  " * d);
    print "B(";
    print x;
    print ")\n";
}

proc pr_treed(tree:avl[int]) {
    Avl::iter[int] (pr_node of (int*int), tree);
}

proc print_string (x:string) {
    print x;
}

fun cmp_int(x:int, y:int) =>
    if x > y then
        1
    elif x < y then
        -1
    else
        0
    endif
;

fun cadd_list_to_int (x:int) (y:list[int]) =>
    y + x
;

fun cadd_int_to_list (y:list[int]) (x:int) =>
    y + x
;

fun cadd_int_to_avl (y:avl[int]) (x:int) =>
    Avl::insert[int](y, x, cmp_int of (int*int));

fun main () =
{

    var y = list(1, 3, 5, 7, 9 );
    var z:avl[int] = (fold_left (the cadd_int_to_avl)  (avl[int]())  y);
    pr_treed(z);
    endl;

    z = remove[int](z, 7, cmp_int of (int*int));
    pr_treed(z);
    endl;

    z = insert(z, 11, cmp_int of(int*int));
    pr_treed(z);
    endl;

    println$ first(z);
    endl;

    z = all_but_first(z);
    pr_treed(z);
    endl;

    println$ last(z);
    endl;

    z = all_but_last(z);
    pr_treed(z);
    endl;

    return 0;
}

System::exit (main());
@doc()

@select(env_rt.expect())
  B(1)
B(3)
    B(5)
  B(7)
    B(9)

  B(1)
B(3)
  B(5)
    B(9)

  B(1)
B(3)
    B(5)
  B(9)
    B(11)

1

  B(3)
    B(5)
B(9)
  B(11)

11

B(3)
    B(5)
  B(9)

@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("axiom checks:integer")
axiom_check(-1);
axiom_check(0);
axiom_check(1);

axiom_check(0,1);
axiom_check(1,0);
axiom_check(-1,0);
axiom_check(0,-1);
axiom_check(1,-1);
axiom_check(1,2);
axiom_check(3,4);
axiom_check(42,0);

axiom_check(5,6,7);
axiom_check(0,-8,9);

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("axiom checks:float")
axiom_check(-1.0);
axiom_check(0.0);
axiom_check(1.0);

axiom_check(0.0,1.0);
axiom_check(1.0,0.0);
axiom_check(-1.0,0.0);
axiom_check(0.0,-1.0);
axiom_check(1.0,-1.0);
axiom_check(1.0,2.0);
axiom_check(3.0,4.0);
axiom_check(0.1,-0.4);
axiom_check(1.0,-8.0,9.0);
axiom_check(-1.0,8.0,-9.0);
axiom_check(-0.1,0.4,0.7);

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("export")

include "flx_faio";

var clock = Faio::mk_alarm_clock();

proc foo(x: int, y: int) {
    print x; endl; print y; endl;
    Faio::sleep (clock,1.0);
}

export proc foo of (int*int) as "foo";
@doc()

@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("export")

proc foo(x: int, y: int) { print x; print y; endl; }
proc foo(a:int) { print a; }
proc foo { }

export proc foo of (int*int) as "foo2";
export proc foo of (int) as "foo1";
export proc foo of (1) as "foo0";

@doc()
@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("export")

proc foo(x: int, y: int) {
    print y; endl;
    spawn_fthread { print "fibre\n"; };
}

export proc foo of (int*int) as "foo";
@doc()
@select(env_rt.expect())
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("reglex")

open Lexer;

module Foo
{
  regexp space = ' ';
  regexp tab = '\t';
  regexp white = space | tab;
}

fun f (start:iterator, finish:iterator) =>
  reglex start to finish with
  | Foo::white => "foo"
  endmatch
;

var s = " ";
val start = start_iterator s;
val finish = end_iterator s;

val x, y = f (start, finish);

print y; endl;
@select(env_rt.expect())
foo
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("regmatch")

fun format (suffix:string) : string =>
  regmatch "1" with
  | "1" => ".static_suffix" + suffix
  endmatch
;

print $ format (".dynamic_suffix"); endl;
@select(env_rt.expect())
.static_suffix.dynamic_suffix
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("typedef")

module X[t] {
  typedef mytype = t;
}

open X[long];
var x: mytype = 1L;
println$ x;
@select(env_rt.expect())
1
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("show typeclass")

proc p[T with Show[T]] (t:T) {
  var x = t;
  print $ "str:  " + (str x); endl;
  print $ "repr: " + (repr x); endl;
}

p true;
p 1t;
p 1ut;
p 1s;
p 1us;
p 1;
p 1u;
p 1l;
p 1ul;
p 1v;
p 1uv;

// to dodge c++'s divide-by-zero check
val fzero = 0.0f;
val dzero = 0.0;
val ldzero = 0.0l;

p 1.0f;
p 1.5f;
p (0.0f/fzero);
p (1.0f/fzero);
p (-1.0f/fzero);

p 1.0;
p (0.0/dzero);
p (1.0/dzero);
p (-1.0/dzero);

p 1.0l;
p (0.0l/ldzero);
p (1.0l/ldzero);
p (-1.0l/ldzero);

p $ char 'a';
p $ wchar 97l;
p $ uchar $ 97u;

p $ C_hack::cast[byte] 1t;
p $ C_hack::cast[address] 16ul;
p $ C_hack::cast[caddress] 16ul;
p $ C_hack::cast[vaddress] 16ul;
p $ C_hack::cast[cvaddress] 16ul;
p $ C_hack::cast[offset] 16ul;

p "Domo Arigato,\nMr Roboto!";
//p u"Domo Arigato,\nMr Roboto!";

p $ List::list(1,2,3);
p $ List::list("a","b","c");

// can't have the same number of template and array typeclasses
/*
p $ (1,2,3,4);
p $ (1,2,3,4,5);
p $ (1,2,3,4,5,6);
p $ (1,"b");
p $ (1,"b",1.0);
*/
@doc()

@select(env_rt.expect())
str:  true
repr: true
str:  1
repr: 1t
str:  1
repr: 1ut
str:  1
repr: 1s
str:  1
repr: 1us
str:  1
repr: 1
str:  1
repr: 1u
str:  1
repr: 1l
str:  1
repr: 1ul
str:  1
repr: 1v
str:  1
repr: 1uv
str:  1
repr: 1
str:  1.5
repr: 1.5
str:  nan
repr: nan
str:  +inf
repr: +inf
str:  -inf
repr: -inf
str:  1
repr: 1
str:  nan
repr: nan
str:  +inf
repr: +inf
str:  -inf
repr: -inf
str:  1
repr: 1
str:  nan
repr: nan
str:  +inf
repr: +inf
str:  -inf
repr: -inf
str:  a
repr: a
str:  97
repr: 97
str:  97
repr: 97
str:  1
repr: 1
str:  16
repr: 16
str:  16
repr: 16
str:  16
repr: 16
str:  16
repr: 16
str:  16
repr: 16
str:  Domo Arigato,
Mr Roboto!
repr: 'Domo Arigato,\nMr Roboto!'
str:  [1, 2, 3]
repr: [1, 2, 3]
str:  ['a', 'b', 'c']
repr: ['a', 'b', 'c']
@doc()

@env_rt.head(3)
@namespace_test = env_rt.test('.flx')
@select(namespace_test)
@kat_rt("namespace")

namespace Foo      { val a = 1; }
namespace Foo      { val b = 2; }
module    Foo::Bar { val c = 3; }

println Foo::a;
println Foo::b;
println Foo::Bar::c;

open Foo;
println a;
println b;
println Bar::c;

open Foo::Bar;
println c;
@doc()

@select(env_rt.expect())
1
2
3
1
2
3
3
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt("namespace")
@tangle('include ' + repr(unix2native(os.path.splitext(namespace_test.sink.name)[0])) + ';')

namespace Foo      { val d = 4; }
module    Foo::Baz { val e = 5; }

println Foo::a;
println Foo::b;
println Foo::Bar::c;
println Foo::d;
println Foo::Baz::e;

open Foo;
println a;
println b;
println Bar::c;
println d;
println Baz::e;

open Foo::Bar;
println c;

open Foo::Baz;
println e;
@doc()

@select(env_rt.expect())
1
2
3
1
2
3
3
1
2
3
4
5
1
2
3
4
5
3
5
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
@kat_rt('assoc_list')
open List;
open Assoc_list;

val xs = list((1,"a"), (3, "c"), (5, "e"));

println $ mem (fun (a:int) => a == 1) xs;
println $ mem (fun (a:int) => a == 2) xs;
println $ mem (eq of (int*int)) xs 3;
println $ mem (eq of (int*int)) xs 4;

println $ find (fun (a:int) => a == 1) xs;
println $ find (fun (a:int) => a == 2) xs;
println $ find (eq of (int*int)) xs 3;
println $ find (eq of (int*int)) xs 4;
@doc()

@select(env_rt.expect())
true
false
true
false
Some a
None
Some c
None
@doc()

@env_rt.head(3)
@select(env_rt.test('.flx'))
// cheats, uses fun instead of gen.. may break later
fun fold_file[a,b]
              (read_func: 1->opt[a])
              (elem_func: a->b->b)
              (seed: b) :b =
{              
  fun aux (prev_val:b) :b =>
      match read_func () with
      | Some ?input => aux (elem_func input prev_val)
      | None => prev_val
      endmatch
  ;
  return aux seed;
}

include "std/textio";
open Text_file;

fun line_count (filename:string) : int =
{
   f := fopen_input filename;
   fun counter (x:string) (count:int)=> count + 1;
   fun readline () => match readln f with | ""=>None[string] | ?x => Some x endmatch;
   return fold_file the readline the counter 0;
}

println$ line_count "test/regress/data/somelines.txt";

@select(env_rt.expect())
30
@doc()

@select(tangler("test/regress/data/somelines.txt"))
@for i in range(1,31): tangle(str(i))
@doc()

@env_nd.head(2,"Non deterministic tests")

@env_nd.head(3)
@select(env_nd.test('.flx'))
@kat_nd("garbage collector")
#import <flx.flxh>;
open List;
Control::collect();
var a = list(1,2,3,4);
fun conv (a:list[int])=> 
  fold_left 
    (fun (acc: list[int]) (item2:int)=>
      acc + map (fun (item1:int)=> item1+item2) a
    ) 
    Empty[int]
    a
;

var x = conv a;
Control::collect();
println q"x=$(x)";
Control::collect();
x = conv x; 
Control::collect();
println q"x=$(x)";
Control::collect();
/*
x = conv x; 
Control::collect();
println q"x=$(x)";
Control::collect();
*/

var x_sum = fold_left (fun (acc:int) (item:int)=>acc+item) 0 x;
var y = map (fun (item:int)=> item * item) x;
var y_sum = fold_left (fun (acc:int) (item:int)=>acc+item) 0 y;

println q"x_sum=$x_sum, y_sum=$(y_sum)";


@env_nd.head(3)
@select(env_nd.test('.flx'))
@kat_nd("pthreads")
@kat_nd("pchannels")
open System;

include "flx_faio";
include "pthread";

open Faio; // async I/O module
open Pthread; // pre-emptive threading

var clock = mk_alarm_clock();

var nthreads, njobs = 3,4;
print$ f"%d threads, %d jobs\n"$ nthreads,njobs;

// read delay, and wait that long, exit on 0
proc worker(i:int, chan:pchannel[int])(){
 print$ f"Starting pthread %d\n" i;
 var &delay:int <- read chan; 
 whilst delay != 0 do
   print$ f"Thread %i, Delay %d\n"$ i,delay;
   sleep$ clock,double delay;
   &delay <- read chan; 
 done;
}

// start the worker pthreads
var chan = mk_pchannel[int]();
proc spawn_workers(i:int)
{
  if i > nthreads return;
  spawn_pthread (worker$ i,chan);
  spawn_workers$ i+1;
}
spawn_workers 1;

// dispatch jobs
whilst njobs > 0 do
  var delay = Cstdlib::rand () % 10 + 1;
  print$ f"Dispatch job %d\n" delay;
  write$ chan, delay; 
  --njobs;
done;

// terminate workers
whilst nthreads > 0 do 
  write$ chan, 0;
  --nthreads;
done;

@env_srt.head(2,"Static good tests")

@env_drt.head(2,"Dynamic good tests")
@env_drt.head(3)
// plugin loader test

@select(env_drt.test('.flx'))

print "Starting .. "; endl;
@tangle('Dynlink::run_lib("./' + \
        os.path.splitext(rt_test2.sink.name)[0] + \
        EXT_SHLIB + '");')
@tangle('Dynlink::run_lib("./' + \
        os.path.splitext(rt_test3.sink.name)[0] + \
        EXT_SHLIB + '");')
print "Its run"; endl;
@doc()

@select(env_drt.expect())
Starting .. 
@tangle(open(rt_expect2.sink.name).read()[:-1])
@tangle(open(rt_expect3.sink.name).read()[:-1])
Its run 
@doc()

@env_bt.head(2,'Bad tests')
All these should fail gracefully at (felix) compile time. 
Run the compiler with the -e option to invert
the return code parity.

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
basic parser error
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
module X { proc p(){} }
module Y { proc p(){} }
open X;
open Y;
p; // ambiguous
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
// open depends on self
interface I { proc print_endl:int; }
module X {
  module M { proc print_endl (a:int) { print a; endl; } }
  module B = M:I;
}
open X;
open B;
print_endl 1;
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
// these now fail OK: (should yield 'any' .. then fail overload :-)
val aa = bb + 1;
val bb = aa + 1;
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
// impossible recursion
type int = "int";
fun neg(a:int) = { return -a; }
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
// privacy violation

module X 
{
  private fun f:int -> int = "$1";
  val x = f 1;
}
open X;
val x = f 1;
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#define FIRST
#define FIRST
@doc()

@env_bt.head(3)
@select(tangler(env_bt.filename() + '.imp', 'flx'))
#define FIRST
@doc()

@select(env_bt.test('.flx'))
#define FIRST
@tangle('#import "'+env_bt.filename() + '.imp"')
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
// this should give an error at felix time
// but we only get one at C++ compile time

/*
[skaller@pelican] ~/links/flx>g++ -w -I. sss.cpp
sss.cpp: In member function `virtual flx::rtl::con_t*
   _i12_p11__init_::resume()':
sss.cpp:256: no matching function for call to `_i15_p6__lam_1::call(
   flx::rtl::con_t*&, _i18_f8__lam_2*&)'
sss.cpp:121: candidates are: virtual flx::rtl::con_t*
   _i15_p6__lam_1::call(flx::rtl::con_t*)
*/
ctypes int;
{ var x:int; read x; }

{ {var x:int; read x; } }

;
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
#import <flx.flxh>
// function drops off end
fun f(x:int):int =
{
  if  x == 1 do return 1; done;
}
print (f 1); endl;
@doc()

@env_bt.head(3)
@select(env_bt.test('.flx'))
@kat_rt('namespace')
#import <flx.flxh>

namespace Foo      { val a = 1; }
namespace Foo      { val b = 2; }
module    Foo::Bar { val c = 3; }

open Foo::Bar;
println a;
@doc()

@env_kf.head(2,'Known failure tests')
All these should successfully compile, but currently fail
or enter into an infinite loop.

@env_kf.head(3)
@select(env_kf.test('.flx'))
#import <flx.flxh>

proc foo(x, y:int)
{
}

proc foo(x)
{
  foo (0, x);
}

foo 0;
@doc()

@env_wt.head(2,'Wish tests')
Tests that suggest a possible language changes that
are not currently implemented. They may or may not
be added to some future version of the compiler, so
they are not currently checked.


@env_wt.head(3)
@select(env_wt.test('.flx'))

if (len s > 3) do
  print s;
  s := "12345\n";
done;
@doc()

@env_wt.head(3)
@select(env_wt.test('.flx'))

proc foo (x:int) = {
  print 'here'; endl;
}

proc bar (x:int) => foo x;
@doc()


@head(1, 'Packages')
@select(tangler('spkgs/flx_regression_tests_rt.py'))
@tangle('unit_tests = glob.glob('+repr(unix2native(env_rt.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/regress'
@doc()


@select(tangler('spkgs/flx_regression_tests_srt.py'))
@tangle('static_unit_tests = glob.glob('+repr(unix2native(env_srt.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers','flx_regression_tests_rt']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_drt.py'))
@tangle('dynamic_unit_tests = glob.glob('+repr(unix2native(env_drt.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers','flx_regression_tests_rt']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_nd.py'))
@tangle('completion_tests = glob.glob('+repr(unix2native(env_nd.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_pt.py'))
@tangle('perform_tests = glob.glob('+repr(unix2native(env_pt.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests_bt.py'))
# these are supposed to fail!
@tangle('failure_tests = glob.glob('+repr(unix2native(env_bt.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()

@select(tangler('spkgs/flx_regression_tests_kf.py'))
# these are supposed to fail!
@tangle('known_failed_tests = glob.glob('+repr(unix2native(env_kf.root)+"*.flx")+')')

pkg_requires = ['flx_compiler','flx_drivers']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
@doc()


@select(tangler('spkgs/flx_regression_tests.py'))
pkg_requires = [
  'flx_regression_tests_rt', 'flx_regression_tests_drt', 
  'flx_regression_tests_nd', 'flx_regression_tests_bt', 
  'flx_regression_tests_kf']
iscr_source = ['lpsrc/flx_regress.pak']

weaver_directory = 'doc/test/'
tmpdir = ['test']

@doc()

@env_rt.write_katfile()
@env_srt.write_katfile()
@env_drt.write_katfile()
@env_pt.write_katfile()
@env_nd.write_katfile()
@env_bt.write_katfile()
@env_kf.write_katfile()
@env_wt.write_katfile()
