@head(1,"Make stack calls")
Name binding pass 2.

@h = tangler("src/flx_stack_calls.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2
open Flx_child

val make_stack_calls:
  sym_state_t ->
  child_map_t * fully_bound_symbol_table_t -> 
  unit

@h = tangler("src/flx_stack_calls.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions

(* first approximation: we can stack functions that have no
  function or procedure children AND no variables: later
  we will check the return type, for now just check
  the code generator works
*)

exception Found

(* A function is stackable provided it doesn't return
  a pointer to itself. There are only two ways this
  can happen: the function returns the address of
  a variable, or, it returns the closure of a child.

  We will check the return type for pointer or
  function types. If its a function, there
  has to be at least one child to grab our this
  pointer in its display. If its a pointer,
  there has to be either a variable, or any
  non-stackable child function, or any child
  procedure -- note that the pointer might address
  a variable in a child function or procedure,
  however it can't 'get out' of a function except
  by it being returned.
  
  Proposition: type variables cannot carry either
  pointers to a variable or a child function closure.

  Reason: type variables are all universally quantified
  and unconstrained. We would have v1 = &v2 for the pointer
  case, contrary to the current lack of constraints.
  Smly for functions. So we'll just ignore type variables.
*)

let has_var bbdfns children =
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_var _  -> raise Found
      | _ -> ()
    )
    children
    ;
    true
  with Found -> false

let has_fun bbdfns children =
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_procedure _ 
      | `BBDCL_function _ -> raise Found
      | _ -> ()
    )
    children
    ;
    true
  with Found -> false


(* NOTE: this won't work for abstracted types like unions
   or structs .. 
*)
exception Unsafe

let has_ptr_fn cache syms bbdfns children e = 
  let rec aux e = 
    try match Hashtbl.find cache e with
    | `Recurse -> ()
    | `Unsafe -> raise Unsafe
    | `Safe -> ()
    with Not_found ->
      Hashtbl.add cache e `Recurse;
      match e with
      | `BTYP_function _ -> 
        (* if has_fun bbdfns children then *)
        Hashtbl.replace cache e `Unsafe;
        raise Unsafe

      | `BTYP_pointer _ -> 
        (* encode the more lenient condition here!! *)
        Hashtbl.replace cache e `Unsafe;
        raise Unsafe

      | `BTYP_inst (i,ts) ->
        let id,parent,sr,entry = Hashtbl.find bbdfns i in
        begin match entry with
        | `BBDCL_abs _ -> ()
        | `BBDCL_union (vs,cs)
        | `BBDCL_struct (vs,cs)
        | `BBDCL_cstruct (vs,cs) -> 
          let varmap = mk_varmap vs ts in
          begin try
            iter 
            (fun (_,t) -> 
              let t = varmap_subst varmap t in
              aux t
            ) 
            cs;
            Hashtbl.replace cache e `Safe
          with Unsafe ->
            Hashtbl.replace cache e `Unsafe;
            raise Unsafe
          end

        | _ -> assert false
        end
      | x -> 
        try 
          iter_btype aux x;
          Hashtbl.replace cache e `Safe
        with Unsafe ->
          Hashtbl.replace cache e `Unsafe;
          raise Unsafe

  in try aux e; false with Unsafe -> true
    
let can_stack_func cache syms (child_map,bbdfns) i =
  let children = try Hashtbl.find child_map i with Not_found -> [] in
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (_,_,_,ret,_) -> 
    not (has_ptr_fn cache syms bbdfns children ret)

  | `BBDCL_nonconst_ctor _
  | `BBDCL_fun _
  | `BBDCL_struct _
  | `BBDCL_cstruct _ 
  | `BBDCL_regmatch _
  | `BBDCL_reglex _
    -> false (* hack *)
  | _ -> failwith ("Unexpected non-function " ^ id)

let rec is_pure syms (child_map, bbdfns) i =
  let children = try Hashtbl.find child_map i with Not_found -> [] in
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_var _ 
  | `BBDCL_val _
  | `BBDCL_tmp _
  | `BBDCL_const_ctor _
  | `BBDCL_nonconst_ctor _
  | `BBDCL_fun _
  | `BBDCL_proc _
  | `BBDCL_header _
  | `BBDCL_body _
  | `BBDCL_struct _
  | `BBDCL_cstruct _
  | `BBDCL_union _
  | `BBDCL_abs _
  | `BBDCL_const _
     -> true

  | `BBDCL_glr _
  | `BBDCL_reglex _
  | `BBDCL_regmatch _
  | `BBDCL_procedure _ 
    -> false

  | `BBDCL_function _ ->
    match parent with Some _ -> false | None ->
    try 
      iter (fun kid -> 
        if not (is_pure syms (child_map, bbdfns) kid) 
        then begin
          (*
          print_endline ("Child " ^ si kid ^ " is not pure");
          *)
          raise Not_found
        end
      )
      children
      ;
      true
    with 
    | Not_found -> false

let ident x = x 
let tident t = t 

let rec enstack_applies cache syms (child_map, bbdfns) x = 
  let ea e = enstack_applies cache syms (child_map, bbdfns) e in
  match map_tbexpr ident ea tident x with
  | (
       `BEXPR_apply ((`BEXPR_closure(i,ts),_),b),t 
     | `BEXPR_apply_direct (i,ts,b),t
    ) as x 
    ->
      begin
        let _,_,_,entry = Hashtbl.find bbdfns i in
        match entry with 
        | `BBDCL_function (props,_,_,_,_) ->
          if mem `Stackable props
          then `BEXPR_apply_stack (i,ts,b),t
          else x
        | _ -> x
      end
  | x -> x

let mark_stackable cache syms (child_map,bbdfns) =
  Hashtbl.iter
  (fun i (id,parent,sr,entry) ->
    match entry with
    | `BBDCL_function (props,vs,p,ret,exes) ->
      let props: property_t list ref = ref props in
      if can_stack_func cache syms (child_map,bbdfns) i then
      begin
        props := `Stackable :: !props;
        if is_pure syms (child_map,bbdfns) i then
        begin
          (*
          print_endline ("Function " ^ id ^ "<" ^ si i ^ "> is PURE");
          *)
          props := `Pure :: !props;
        end
        (*
        else
          print_endline ("Stackable Function " ^ id ^ "<" ^ si i ^ "> is NOT PURE")
        *)
      end
      (*
      else print_endline ("Function " ^ id ^ "<" ^ si i ^ "> is NOT STACKABLE")
      *)
      ;
      let props : property_t list = !props in
      let entry : bbdcl_t = `BBDCL_function (props,vs,p,ret,exes) in
      Hashtbl.replace bbdfns i (id,parent,sr,entry)
    | _ -> ()
  )
  bbdfns

let enstack_calls cache syms (child_map,bbdfns) exes =
  let ea e = enstack_applies cache syms (child_map, bbdfns) e in
  let id x = x in
  map (map_bexe id ea id id id) exes

let make_stack_calls syms (child_map, (bbdfns: fully_bound_symbol_table_t)) =
  let cache = Hashtbl.create 97 in
  let ea e = enstack_applies cache syms (child_map, bbdfns) e in
  mark_stackable cache syms (child_map,bbdfns);
  Hashtbl.iter
  (fun i (id,parent,sr,entry) -> match entry with
    | `BBDCL_procedure (props,vs,p,exes) ->
      let exes = enstack_calls cache syms (child_map,bbdfns) exes in
      let exes = Flx_cflow.final_tailcall_opt exes in
      Hashtbl.replace bbdfns i (id,parent,sr,`BBDCL_procedure (props,vs,p,exes))

    | `BBDCL_function (props,vs,p,ret,exes) ->
      let exes = enstack_calls cache syms (child_map,bbdfns) exes in
      Hashtbl.replace bbdfns i (id,parent,sr,`BBDCL_function (props,vs,p,ret,exes))

    | `BBDCL_glr (props,vs,t,(p,exes)) ->
      let exes = enstack_calls cache syms (child_map,bbdfns) exes in
      Hashtbl.replace bbdfns i (id,parent,sr,`BBDCL_glr (props,vs,t,(p,exes)))

    | `BBDCL_regmatch (_,vs,p,t,(a,i,h,m)) ->
      Hashtbl.iter
      (fun k e -> Hashtbl.replace h k (ea e))
      h

    | `BBDCL_reglex (_,vs,p,j,t,(a,i,h,m)) ->
      Hashtbl.iter
      (fun k e -> Hashtbl.replace h k (ea e))
      h

    | _ -> ()
  )
  bbdfns

