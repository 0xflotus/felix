@head(1,'Regression tests')
There are four kinds of test. The compiler
must be run with standard output redirected
to /dev/null. All these tests use the standard
flx_run harness.
@begin_list('keyed')
@item('rt')
Each good test should generate output which,
when compared with a known good run, should
be much the same. Good tests typically have
several things tested. 
@item('dt')
Bad tests check the compiler issues
a diagnostic. Usually, they have just one
error.
@item('bt')
Nasty tests should crash. These are typically
things I'd like to catch with an improved
version of the compiler or run time.
@item('pt')
Performance tests measure speed. The result
is an overall time in seconds, which should
get smaller with each compiler improvement.
@end_list()


@head(2,'Good tests')
@select(tangler('test/rt01.flx'))
#include <std.flx>
open Tiny;
open Short;
open Long;
open Vlong;
open Utiny;
open Ushort;
open Uint;
open Ulong;
open Uvlong;
open Int8;
open Int16;
open Int32;
open Int64;
open Uint8;
open Uint16;
open Uint32;
open Uint64;
@xs = [
  "2",
  "0b10","0B10",
  "0o2","0O2",
  "0d2","0D2",
  "0x2","0X2"
  ]
@ys = [
  "40","0b0010_1000","0B_0010_1000",
  "0o50","0O50",
  "0d40","0D40",
  "0x28",
  "0X28"
  ]
@ss = [
  "",
  "t","T","s","S","i","I","l","L","v","V","ll","LL",
  "u",
  "ut","uT","us","uS","ui","uI","ul","uL","uv","uV","ull","uLL",
  "Ut","UT","Us","US","Ui","UI","Ul","UL","Uv","UV","Ull","ULL",
  "U",
  "tu","Tu","su","Su","iu","Iu","lu","Lu","vu","Vu","llu","LLu",
  "tU","TU","sU","SU","iU","IU","lU","LU","vU","VU","llU","LLU",
  "i8","i16","i32","i64",
  "u8","u16","u32","u64"
  ]
@for x in xs:
  for y in ys:
    tname = "tst_"+x+y
    tangle("//noinline is needed to stop gcc dropping dead") 
    tangle("noinline proc "+tname+" () {")
    for s in ss:
      tangle("  assert(int_of("+x+s+" + "+y+s+")==42);") 
    tangle("}")
    tangle(tname+";")

print "rt01 complete\n";

@select(tangler('test/rt02.flx'))
header r"""
#include <stdio.h>
#include <assert.h>
typedef char *charp;
""";

typedef bool = 2;
type int = "int";
type string = "charp";

proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';

fun sub: int * int -> int = "$1 - $2";
fun mul: int * int -> int = "$1 * $2";
fun gt: int * int -> bool = "$1 > $2";
fun eq: int * int -> bool = "$1 == $2";
proc assert:bool = "assert($1);";

// test some recursion
fun fact(a:int): int =
{
  fun f (a:int, p:int) : int = {
    return 
      if a>1 then f(a-1, p*a) else p endif;
  }
  return f(a,1);
}

// test function variable
val factc : int -> int = fact of (int);
assert (fact 6 == 6 * 5 * 4 * 3 * 2);
assert (factc 6 == 6 * 5 * 4 * 3 * 2);

// test procedure variable
proc printer (a:int) { print a; }
val printv = printer of (int);
printer 10;
print "\n";
printv 10;

// test structure constructor function
struct X = {
  x : int;
  y : int;
}

proc printX (x:X) {
  print "x=";
  print x.x;
  print ", y=";
  print x.y;
  print "\n";
}

val x = X(1,2);
printX x;

// test special procedure overloading
proc t1() 
{
  proc print: int = 'printf("int=%d",$1);';
  print "Not hidden: ";
  print 1;
  print " print:int hides outer\n";
}
t1();

module A 
{
  proc print:int='printf("module A print int=%d",$1);';
  print 1;
  print "\n";
}

@select(tangler('test/rt03.flx'))
#include <std.flx>
// test lazy functions and procedures
print "lazy expr eval test\n";
var x = 1;
var y = 2;
val f = {x+y};
print (f ()); print "\n";
x = 3;
print (f ()); print "\n";

@select(tangler('test/rt04.flx'))
// test the string library
#include <std.flx>
var x = "Hello";
x += "+";
x += "World";
print x; endl;
assert(x == "Hello+World");
print x.[1 to 6]; endl;
print x.[to 6]; endl;
print x.[6 to]; endl;
print x.[6 to -1]; endl;

var i = 0;
var n = len x;
while {i < n} {
  print x.[i];
  ++i;
};
endl;

i = 1;
while {i <= n} {
  print x.[-i];
  ++i;
};
endl;

@select(tangler('test/rt05.flx'))
// test the chained comparison
#include <std.flx>
assert(1<2&<3&<4);


@select(tangler('test/rt07.flx'))
header "#include <stdio.h>";
header "#include <assert.h>";

fun land: 2 * 2 -> 2 = "$1 && $2";
type int = "int";
fun eq: int * int -> 2 = "$1 == $2";

type string = "char*";
proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';
proc eol: 1 = 'printf("\\n");';

val x:int = 1;
val y : typeof(x) = 1;
val z = 25;

print  x; eol;
print  y; eol;
print  z; eol;

// now try recursive case


typedef tt = int * &tt;
var v : tt = (1,&v);
var u = (1,&u); // this is OK, type is 'tt'
val xx = match u with |(?x,_) => x endmatch;

print "OK"; eol;

fun f(i:int) = { return 1; }
fun e(i:int) = { return f 1; }

print (e 10); eol;

match (1,2) with
| (?x,2) => { print x; }
| (1,?y) => { print y; }
endmatch;
eol;

print (if 1==1 then "true" else "false" endif); eol;
print (if 1==0 then "true" else "false" endif); eol;

@select(tangler('test/rt08.flx'))
#include <std.flx>
// closure formation test

// primitive function
fun appl(x:int, f:int * int -> int):int = {
  return f (x,x);
}

print "closure of add primitive ";
print (appl (2, add of (int*int))); endl;

// struct as function
struct X { x:int; }
fun execX(p:int->X):X = { return p(1); }
proc print(x:X){ print "struct X"; }
print (execX (X of (int))); endl;
print (execX (X)); endl;

// struct get projection as function
fun execx(p:X->int,a:X):int => p a;
proc pprint(x:int){ print "struct X: x get projection "; print x; }
pprint (execx (get_x of (X), X(42))); endl;

// C struct as function
header """
struct CX {int x; };
""";

cstruct CX { x:int; }
fun execCX(p:int->CX):CX = { return p(1); }
proc print(x:CX){ print "struct CX"; }
print (execCX (CX of (int))); endl;
print (execCX (CX)); endl;


// anonymous variant type constructor as function
typedef Y = 1 + int;
fun exec2(y2:int->Y,a:int):Y= { return  y2 a; }
proc print(y:Y) { print "union Y"; }
print (exec2(case 2 of Y, 1)); endl;

// named variant type constructor as function
union U = | A | B of int;
fun exec3(y2:int->U,a:int):U= { return  y2 a; }
proc print(y:U) { print "union U"; }
print (exec3(B of (int), 1)); endl;

@select(tangler('test/rt09.flx'))
// code insertion
body "#include <iostream>";
code 'static int x = 1;';
type int = "int";
fun add:int * int -> int = "$1 + $2";
fun two (): int = { return code[int]x + code[int]'x'; }
proc print:int = 'std::cout << $1 << std::endl;';
print (two());

@select(tangler('test/rt10.flx'))
//multiple assignment
include "std";
var a:int;
var b:int;
var c:int;

a,(b,c) = 1,(2,3);

print a; print " ";
print b; print " ";
print c; print " ";
endl;

def a = 1;
def val x = 2;
def var y = 3;

def a, val d, var e = 9,8,7;

print a; print " ";
print d; print " ";
print e; print " ";
endl;

@select(tangler('test/rt11.flx'))
include "std";

// test dual
typedef y = ~(int+int); // = int * int
val x : y = (1,2);

print x.(0); print " "; print x.(1); endl;

typedef ibl = typeof (1,1L);

// test typematch
typedef tt = typematch ibl with | _ * ?t as z => t * t * z endmatch;
var a:tt = (1L, 2L, (3,4L));

Long::print a.(0); print " "; Long::print a.(1); print " ";
print a.(2).(0); print " "; Long::print a.(2).(1); endl;

typedef fun domainf (t:TYPE):TYPE = typematch t with | ?aa -> ?bb => aa endmatch;
typedef domains [t] = typematch t with | ?aa -> ?bb => aa endmatch;
typedef il = int -> long;
typedef ityf = domainf il;
typedef itys = domains [il];

val one:itys = 1;
val two:ityf = 1;
print one; endl;
print two; endl;

@select(tangler('test/rt12.flx'))
// generics inlining/call lifting tests
include "std";

proc f[k] (z:k, print:k->void) {
  fun diag[t] (x:t):t*t = { return x,x; }
  fun prj1[t1,t2] (x:t1,y:t2):t1 = { return x; }
  fun prj2[t1,t2] (x:t1,y:t2):t2 = { return y; }
  print (prj1(diag z)); endl;
}

f[int] (1, print of (int));

@select(tangler('test/rt13.flx'))
//call inlining
include "std";
proc g[t]()
{
  proc h()
  {
    proc j[t]()
    {
      print "SIXTEEN\n";
      print "SEVENTEEN\n";
      print "EIGHTTEEN\n";
    }
    proc k()
    {
      print "THIRTEEN\n";
      print "FOURTEEN\n";
      print "FIFTEEN\n";
      j[int]();
    }
    print "TEN\n";
    print "ELEVEN\n";
    print "TWELVE\n";
    k();
  }
  print "SEVEN\n";
  print "EIGHT\n";
  print "NINE\n";
  h();
}

proc f[t]() {
  print "FOUR\n";
  print "FIVE\n";
  print "SIX\n";
  g[t]();
}

print "ONE\n";
print "TWO\n";
print "THREE\n";
f[int]();

@select(tangler('test/rt14.flx'))
//call inlining
include "std";

val x = 1;
if x == 1 then 
{ 
  if x == 1 
  then { print "ONE\n"; } 
  else { print "IMPOSSIBLE"; } 
  endif
  ;
}
else 
{ 
  print "TWO\n"; 
}
endif
;

@select(tangler('test/rt15.flx'))
// more generic stuff
include "std";
open List;

fun snd(x,y)=>y;
fun fst(x,y)=>x;

fun index[t] (l:list[t]) = {
  fun f(il:int * list [int * t]) (e: t) =>
    match il with
    | ?i,?l => i+1, Cons ((i, e),l)
    endmatch
  ;
  return
    rev (snd ( fold_left
      f of (int * list[int *t])
      (0, Empty[int * t]) 
      l
    ))
  ;
}

var x = Empty[int];
x = Cons(11,x);
x = Cons(22,x);
x = Cons(33,x);
x = Cons(44,x);
x = Cons(55,x);
x = Cons(66,x);

val z = index x;
iter 
  (proc (x:int,y:int)
    {
      print x; print " -> "; print y; endl;
    }
  )
  z
;

@select(tangler('test/rt16.flx'))
include "std";
// self-tail rec test (inspect output)
// (requires --inline atm)
var x = 4;
proc recur ()
{
  if x == 0 goto endoff;
  print x; endl;
  --x;
  recur();
endoff:>
}
recur();

@select(tangler('test/rt17.flx'))
include "std";
// non-self-tail rec test (inspect output)
// (requires --inline atm)
var x = 4;
proc recur2 ()
{
  if x > 0 then 
  {
    print x; endl;
    --x;
    recur2();
  }
  else {} endif;
}
recur2();


@select(tangler('test/rt18.flx'))
include "std";
// self-tail rec test (inspect output)
// (requires --inline atm)
fun g(x:int):int = {
  if x == 0 goto endoff;
  return g(x-1);
endoff:>
  return 1;
}
 
print (g 10); endl;
@select(tangler('test/rt19.flx'))
include "std";
// non-self-tail rec test (inspect output)
// (requires --inline atm)

fun f(x:int)=>
  if(x == 0) then 1
  else f(x-1)
  endif
;
 
print (f 10); endl;

@select(tangler('test/rt20.flx'))
// lvalue decay if function called thru variable
include "std";

proc f(g:int->void) { var x=1; g x; }
proc g(x:int) { }
f g of (int);

@select(tangler('test/drt1.flx'))
// plugin loader test
include "std";

print "Starting .. "; endl;
Dynlink::run_lib("./test/rt02.so");
Dynlink::run_lib("./test/rt04.so");
Dynlink::run_lib("./test/rt05.so");
Dynlink::run_lib("./test/rt07.so");
Dynlink::run_lib("./test/rt08.so");
Dynlink::run_lib("./test/rt09.so");
Dynlink::run_lib("./test/rt10.so");
Dynlink::run_lib("./test/rt11.so");
Dynlink::run_lib("./test/rt12.so");
Dynlink::run_lib("./test/rt13.so");
Dynlink::run_lib("./test/rt14.so");
Dynlink::run_lib("./test/rt15.so");
Dynlink::run_lib("./test/rt16.so");
Dynlink::run_lib("./test/rt17.so");
Dynlink::run_lib("./test/rt18.so");
Dynlink::run_lib("./test/rt19.so");
print "Its run"; endl;

@head(2,'Bad tests')
All these should fail gracefully at (felix) compile time. 
Run the compiler with the -e option to invert
the return code parity.
@select(tangler('test/bt01.flx'))
basic parser error

@select(tangler('test/bt02.flx'))
module X { proc p(){} }
module Y { proc p(){} }
open X;
open Y;
p; // ambiguous

@select(tangler('test/bt03.flx'))
// open depends on self
#include <std.flx>
interface I { proc print_endl:int; }
module X {
  module M { proc print_endl (a:int) { print a; endl; } }
  module B = M:I;
}
open X;
open B;
print_endl 1;

@select(tangler('test/bt04.flx'))
#include <std.flx>
// these now fail OK: (should yield 'any' .. then fail overload :-)
val aa = bb + 1;
val bb = aa + 1;

@select(tangler('test/bt05.flx'))
// impossible recursion
type int = "int";
fun neg(a:int) = { return -a; }

@select(tangler('test/bt06.flx'))
// privacy violation
include "std";

module X 
{
  private fun f:int -> int = "$1";
  val x = f 1;
}
open X;
val x = f 1;

@select(tangler('test/bt07.flx'))
#define FIRST
#define FIRST

@select(tangler('test/bt08.imp','data'))
#define FIRST

@select(tangler('test/bt08.flx'))
#define FIRST
#import "bt08.imp"

@select(tangler('test/bt09.flx'))
// this should give an error at felix time
// but we only get one at C++ compile time

/*
[skaller@pelican] ~/links/flx>g++ -w -I. sss.cpp
sss.cpp: In member function `virtual flx::rtl::con_t*
   _i12_p11__init_::resume()':
sss.cpp:256: no matching function for call to `_i15_p6__lam_1::call(
   flx::rtl::con_t*&, _i18_f8__lam_2*&)'
sss.cpp:121: candidates are: virtual flx::rtl::con_t*
   _i15_p6__lam_1::call(flx::rtl::con_t*)
*/
ctypes int;
{ var x:int; read x; }

{ {var x:int; read x; } }

;

@select(tangler('test/bt10.flx'))
// function drops off end
include "std";
fun f(x:int):int =
{
  if  x == 1 do return 1; done;
}
print (f 1); endl;

