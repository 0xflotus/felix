@head(1,'Regression tests')
There are four kinds of test. The compiler
must be run with standard output redirected
to /dev/null. All these tests use the standard
flx_run harness.
@begin_list('keyed')
@item('rt')
Each good test should generate output which,
when compared with a known good run, should
be much the same. Good tests typically have
several things tested. 
@item('dt')
Bad tests check the compiler issues
a diagnostic. Usually, they have just one
error.
@item('bt')
Nasty tests should crash. These are typically
things I'd like to catch with an improved
version of the compiler or run time.
@item('pt')
Performance tests measure speed. The result
is an overall time in seconds, which should
get smaller with each compiler improvement.
@end_list()

@select(tangler('test/dt01.flx'))
basic parser error

@select(tangler('test/dt02.flx'))
module X { proc p(){} }
module Y { proc p(){} }
open X;
open Y;
p; // ambiguous

@select(tangler('test/dt03.flx'))
// open depends on self
#include <std.flx>
interface I { proc print_endl:int; }
module X {
  module M { proc print_endl (a:int) { print a; endl; } }
  module B = M:I;
}
open X;
open B;
print_endl 1;


@select(tangler('test/rt01.flx','data'))
#include <std.flx>
open Tiny;
open Short;
open Long;
open Vlong;
open Utiny;
open Ushort;
open Uint;
open Ulong;
open Uvlong;
open Int8;
open Int16;
open Int32;
open Int64;
open Uint8;
open Uint16;
open Uint32;
open Uint64;
@xs = [
  "2",
  "0b10","0B10",
  "0o2","0O2",
  "0d2","0D2",
  "0x2","0X2"
  ]
@ys = [
  "40","0b0010_1000","0B_0010_1000",
  "0o50","0O50",
  "0d40","0D40",
  "0x28",
  "0X28"
  ]
@ss = [
  "",
  "t","T","s","S","i","I","l","L","v","V","ll","LL",
  "u",
  "ut","uT","us","uS","ui","uI","ul","uL","uv","uV","ull","uLL",
  "Ut","UT","Us","US","Ui","UI","Ul","UL","Uv","UV","Ull","ULL",
  "U",
  "tu","Tu","su","Su","iu","Iu","lu","Lu","vu","Vu","llu","LLu",
  "tU","TU","sU","SU","iU","IU","lU","LU","vU","VU","llU","LLU",
  "i8","i16","i32","i64",
  "u8","u16","u32","u64"
  ]
@for x in xs:
  for y in ys:
    for s in ss:
      tangle("assert(int_of("+x+s+" + "+y+s+")==42);") 

@select(tangler('test/rt02.flx'))
header r"""
#include <stdio.h>
typedef char *charp;
""";

typedef bool = 2;
type int = "int";
type string = "charp";

proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';

fun sub: int * int -> int = code "$1 - $2";
fun mul: int * int -> int = code "$1 * $2";
fun gt: int * int -> bool = code "$1 > $2";
fun eq: int * int -> bool = code "$1 == $2";
proc assert:bool = "assert($1);";

// test some recursion
fun fact(a:int): int do
{
  fun f (a:int, p:int) : int do {
    return 
      if a>1 
      then 
        f(a-1, p*a)
      else 
        p
      endif;
  }
  return f(a,1);
}

// test function variable
val factc : int -> int = fact of (int);
assert (fact 6 == 6 * 5 * 4 * 3 * 2);
assert (factc 6 == 6 * 5 * 4 * 3 * 2);

// test procedure variable
proc printer (a:int) { print a; }
val printv = printer of (int);
printer 10;
print "\n";
printv 10;

// test structure constructor function
struct X = {
  x : int;
  y : int;
}

proc printX (x:X) {
  print "x=";
  print x.x;
  print ", y=";
  print x.y;
  print "\n";
}

val x = X(1,2);
printX x;

// test special procedure overloading
proc t1() 
{
  proc print: int = 'printf("int=%d",$1);';
  print "Not hidden: ";
  print 1;
  print " print:int hides outer\n";
}
t1();

module A 
{
  proc print:int='printf("module A print int=%d",$1);';
  print 1;
  print "\n";
}

@select(tangler('test/rt03.flx'))
#include <std.flx>
// test lazy functions and procedures
print "lazy expr eval test\n";
var x = 1;
var y = 2;
val f = [x+y];
print (f ()); print "\n";
x = 3;
print (f ()); print "\n";

@select(tangler('test/rt04.flx'))
// test the string library
#include <std.flx>
var x = "Hello";
x += "+";
x += "World";
print x; endl;
assert(x == "Hello+World");
print x.[1 to 6]; endl;
print x.[to 6]; endl;
print x.[6 to]; endl;
print x.[6 to -1]; endl;

var i = 0;
var n = len x;
while [i < n] {
  print x.[i];
  ++i;
};
endl;

i = 1;
while [i <= n] {
  print x.[-i];
  ++i;
};
endl;

@select(tangler('test/rt05.flx'))
// test the chained comparison
#include <std.flx>
assert(1<2&<3&<4);


@select(tangler('test/rt06.flx'))
// open bound module
#include <std.flx>
interface I { proc print_endl:int; }
module M { proc print_endl (a:int) { print a; endl; } }
module B = M:I;
open B;
print_endl 1;

@select(tangler('test/rt07.flx'))
// include a file twice
#include <std.flx>
#include <std.flx>

@select(tangler('test/rt08.flx'))
//Duplicated Open
type int = "int";
module X {
  proc f(a:int) {}
}
open X;
open X;
f 1; // should work ..

@select(tangler('test/rt09.flx'))
#include <std.flx>
union  satisfaction = | Low | High | Very of satisfaction;
union  diameter = | Large | Small;
union  sort = | Mozzarella | Gorgonzola;
union topping = | Cheese of sort | Tomatoes | Mushrooms;
union  spiced = | False | True;
union  meal =
    | WienerSchnitzel of diameter
    | Pizza of (diameter * spiced * topping)
    | TapirSoup of spiced;

fun model (meal_d1:meal):satisfaction =
  let satisfaction_c1 = 
    match meal_d1 with
    | TapirSoup ?spiced_d1 =>
      match spiced_d1 with
        | True => Low
        | False => High 
      endmatch
    | Pizza (_, ?spiced_d1, ?topping_d1) =>
        let satisfaction_c1 =
          match spiced_d1 with
          | True =>
          match topping_d1 with
        | Cheese ?sort_d1 =>
          match sort_d1 with
          | Gorgonzola => Low
          | Mozzarella => High
          endmatch
          | _ => High
          endmatch
          | False => Low
          endmatch 
        in
        Very satisfaction_c1
    | WienerSchnitzel _ => Low 
    endmatch 
    in
  Very satisfaction_c1
;

fun string_of(x:satisfaction)=
  match x with
  | Low => "Low"
  | High => "High"
  | Very ?z => "Very " + string_of z
  endmatch
;

val MyMeal = Pizza (Large,True, Cheese Mozzarella);
assert (string_of (model MyMeal) == "Very Very High");


