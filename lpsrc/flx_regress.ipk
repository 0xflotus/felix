@head(1,'Regression tests')
There are four kinds of test. The compiler
must be run with standard output redirected
to /dev/null. All these tests use the standard
flx_run harness.
@begin_list('keyed')
@item('rt')
Each good test should generate output which,
when compared with a known good run, should
be much the same. Good tests typically have
several things tested. 
@item('dt')
Bad tests check the compiler issues
a diagnostic. Usually, they have just one
error.
@item('bt')
Nasty tests should crash. These are typically
things I'd like to catch with an improved
version of the compiler or run time.
@item('pt')
Performance tests measure speed. The result
is an overall time in seconds, which should
get smaller with each compiler improvement.
@end_list()

@select(tangler('test/bt01.flx'))
basic parser error

@select(tangler('test/bt02.flx'))
module X { proc p(){} }
module Y { proc p(){} }
open X;
open Y;
p; // ambiguous


@select(tangler('test/rt01.flx'))
#include <std.flx>
open Tiny;
open Short;
open Long;
open Vlong;
open Utiny;
open Ushort;
open Uint;
open Ulong;
open Uvlong;
open Int8;
open Int16;
open Int32;
open Int64;
open Uint8;
open Uint16;
open Uint32;
open Uint64;
@xs = [
  "2",
  "0b10","0B10",
  "0o2","0O2",
  "0d2","0D2",
  "0x2","0X2"
  ]
@ys = [
  "40","0b0010_1000","0B_0010_1000",
  "0o50","0O50",
  "0d40","0D40",
  "0x28",
  "0X28"
  ]
@ss = [
  "",
  "t","T","s","S","i","I","l","L","v","V","ll","LL",
  "u",
  "ut","uT","us","uS","ui","uI","ul","uL","uv","uV","ull","uLL",
  "Ut","UT","Us","US","Ui","UI","Ul","UL","Uv","UV","Ull","ULL",
  "U",
  "tu","Tu","su","Su","iu","Iu","lu","Lu","vu","Vu","llu","LLu",
  "tU","TU","sU","SU","iU","IU","lU","LU","vU","VU","llU","LLU",
  "i8","i16","i32","i64",
  "u8","u16","u32","u64"
  ]
@for x in xs:
  for y in ys:
    for s in ss:
      tangle("assert(int_of("+x+s+" + "+y+s+")==42);") 

@select(tangler('test/rt02.flx'))
header r"""
#include <stdio.h>
typedef char *charp;
""";

typedef bool = 2;
type int = "int";
type string = "charp";

proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';

fun sub: int * int -> int = "$1 - $2";
fun mul: int * int -> int = "$1 * $2";
fun gt: int * int -> bool = "$1 > $2";
fun eq: int * int -> bool = "$1 == $2";
proc assert:bool = "assert($1);";

// test some recursion
fun fact(a:int): int =
{
  fun f (a:int, p:int) : int = {
    return 
      if a>1 then f(a-1, p*a) else p endif;
  }
  return f(a,1);
}

// test function variable
val factc : int -> int = fact of (int);
assert (fact 6 == 6 * 5 * 4 * 3 * 2);
assert (factc 6 == 6 * 5 * 4 * 3 * 2);

// test procedure variable
proc printer (a:int) { print a; }
val printv = printer of (int);
printer 10;
print "\n";
printv 10;

// test structure constructor function
struct X = {
  x : int;
  y : int;
}

proc printX (x:X) {
  print "x=";
  print x.x;
  print ", y=";
  print x.y;
  print "\n";
}

val x = X(1,2);
printX x;

// test special procedure overloading
proc t1() 
{
  proc print: int = 'printf("int=%d",$1);';
  print "Not hidden: ";
  print 1;
  print " print:int hides outer\n";
}
t1();

module A 
{
  proc print:int='printf("module A print int=%d",$1);';
  print 1;
  print "\n";
}

@select(tangler('test/rt03.flx'))
#include <std.flx>
// test lazy functions and procedures
print "lazy expr eval test\n";
var x = 1;
var y = 2;
val f = {x+y};
print (f ()); print "\n";
x = 3;
print (f ()); print "\n";

@select(tangler('test/rt04.flx'))
// test the string library
#include <std.flx>
var x = "Hello";
x += "+";
x += "World";
print x; endl;
assert(x == "Hello+World");
print x.[1 to 6]; endl;
print x.[to 6]; endl;
print x.[6 to]; endl;
print x.[6 to -1]; endl;

var i = 0;
var n = len x;
while {i < n} {
  print x.[i];
  ++i;
};
endl;

i = 1;
while {i <= n} {
  print x.[-i];
  ++i;
};
endl;

@select(tangler('test/rt05.flx'))
// test the chained comparison
#include <std.flx>
assert(1<2&<3&<4);


@select(tangler('test/rt06.flx'))
// open bound module
#include <std.flx>
interface I { proc print_endl:int; }
module M { proc print_endl (a:int) { print a; endl; } }
module B = M:I;
open B;
print_endl 1;

@select(tangler('test/bt03.flx'))
// open depends on self
#include <std.flx>
interface I { proc print_endl:int; }
module X {
  module M { proc print_endl (a:int) { print a; endl; } }
  module B = M:I;
}
open X;
open B;
print_endl 1;

@select(tangler('test/rt07.flx'))
header "#include <stdio.h>";

fun land: 2 * 2 -> 2 = "$1 && $2";
type int = "int";
fun eq: int * int -> 2 = "$1 == $2";

type string = "char*";
proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';
proc eol: unit = 'printf("\n");';

val x:int = 1;
val y : typeof(x) = 1;
val z = 25;

print  x; eol;
print  y; eol;
print  z; eol;

// now try recursive case


typedef tt = int * &tt;
var v : tt = (1,&v);
var u = (1,&u); // this is OK, type is 'tt'
val xx = match u with |(?x,_) => x endmatch;

print "OK"; eol;

fun f(i:int) = { return 1; }
fun e(i:int) = { return f 1; }

print (e 10); eol;

match (1,2) with
| (?x,2) => { print x; }
| (1,?y) => { print y; }
endmatch;
eol;

print (if 1==1 then "true" else "false" endif); eol;
print (if 1==0 then "true" else "false" endif); eol;


@select(tangler('test/bt04.flx'))
#include <std.flx>
// these now fail OK: (should yield 'any' .. then fail overload :-)
val aa = bb + 1;
val bb = aa + 1;


