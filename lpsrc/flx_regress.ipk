@head(1,'Regression tests')
There are four kinds of test. The compiler
must be run with standard output redirected
to /dev/null. All these tests use the standard
flx_run harness.
@begin_list('keyed')
@item('rt')
Each good test should generate output which,
when compared with a known good run, should
be much the same. Good tests typically have
several things tested. 
@item('dt')
Bad tests check the compiler issues
a diagnostic. Usually, they have just one
error.
@item('bt')
Nasty tests should crash. These are typically
things I'd like to catch with an improved
version of the compiler or run time.
@item('pt')
Performance tests measure speed. The result
is an overall time in seconds, which should
get smaller with each compiler improvement.
@end_list()


@head(2,'Good tests')
@select(tangler('test/rt01.flx'))
#include <std.flx>
open Tiny;
open Short;
open Long;
open Vlong;
open Utiny;
open Ushort;
open Uint;
open Ulong;
open Uvlong;
open Int8;
open Int16;
open Int32;
open Int64;
open Uint8;
open Uint16;
open Uint32;
open Uint64;
@xs = [
  "2",
  "0b10","0B10",
  "0o2","0O2",
  "0d2","0D2",
  "0x2","0X2"
  ]
@ys = [
  "40","0b0010_1000","0B_0010_1000",
  "0o50","0O50",
  "0d40","0D40",
  "0x28",
  "0X28"
  ]
@ss = [
  "",
  "t","T","s","S","i","I","l","L","v","V","ll","LL",
  "u",
  "ut","uT","us","uS","ui","uI","ul","uL","uv","uV","ull","uLL",
  "Ut","UT","Us","US","Ui","UI","Ul","UL","Uv","UV","Ull","ULL",
  "U",
  "tu","Tu","su","Su","iu","Iu","lu","Lu","vu","Vu","llu","LLu",
  "tU","TU","sU","SU","iU","IU","lU","LU","vU","VU","llU","LLU",
  "i8","i16","i32","i64",
  "u8","u16","u32","u64"
  ]
@for x in xs:
  for y in ys:
    for s in ss:
      tangle("assert(int_of("+x+s+" + "+y+s+")==42);") 

print "rt01 complete\n";

@select(tangler('test/rt02.flx'))
header r"""
#include <stdio.h>
#include <assert.h>
typedef char *charp;
""";

typedef bool = 2;
type int = "int";
type string = "charp";

proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';

fun sub: int * int -> int = "$1 - $2";
fun mul: int * int -> int = "$1 * $2";
fun gt: int * int -> bool = "$1 > $2";
fun eq: int * int -> bool = "$1 == $2";
proc assert:bool = "assert($1);";

// test some recursion
fun fact(a:int): int =
{
  fun f (a:int, p:int) : int = {
    return 
      if a>1 then f(a-1, p*a) else p endif;
  }
  return f(a,1);
}

// test function variable
val factc : int -> int = fact of (int);
assert (fact 6 == 6 * 5 * 4 * 3 * 2);
assert (factc 6 == 6 * 5 * 4 * 3 * 2);

// test procedure variable
proc printer (a:int) { print a; }
val printv = printer of (int);
printer 10;
print "\n";
printv 10;

// test structure constructor function
struct X = {
  x : int;
  y : int;
}

proc printX (x:X) {
  print "x=";
  print x.x;
  print ", y=";
  print x.y;
  print "\n";
}

val x = X(1,2);
printX x;

// test special procedure overloading
proc t1() 
{
  proc print: int = 'printf("int=%d",$1);';
  print "Not hidden: ";
  print 1;
  print " print:int hides outer\n";
}
t1();

module A 
{
  proc print:int='printf("module A print int=%d",$1);';
  print 1;
  print "\n";
}

@select(tangler('test/rt03.flx'))
#include <std.flx>
// test lazy functions and procedures
print "lazy expr eval test\n";
var x = 1;
var y = 2;
val f = {x+y};
print (f ()); print "\n";
x = 3;
print (f ()); print "\n";

@select(tangler('test/rt04.flx'))
// test the string library
#include <std.flx>
var x = "Hello";
x += "+";
x += "World";
print x; endl;
assert(x == "Hello+World");
print x.[1 to 6]; endl;
print x.[to 6]; endl;
print x.[6 to]; endl;
print x.[6 to -1]; endl;

var i = 0;
var n = len x;
while {i < n} {
  print x.[i];
  ++i;
};
endl;

i = 1;
while {i <= n} {
  print x.[-i];
  ++i;
};
endl;

@select(tangler('test/rt05.flx'))
// test the chained comparison
#include <std.flx>
assert(1<2&<3&<4);


@select(tangler('test/rt07.flx'))
header "#include <stdio.h>";
header "#include <assert.h>";

fun land: 2 * 2 -> 2 = "$1 && $2";
type int = "int";
fun eq: int * int -> 2 = "$1 == $2";

type string = "char*";
proc print: string = 'printf("%s",$1);';
proc print: int = 'printf("%d",$1);';
proc eol: 1 = 'printf("\n");';

val x:int = 1;
val y : typeof(x) = 1;
val z = 25;

print  x; eol;
print  y; eol;
print  z; eol;

// now try recursive case


typedef tt = int * &tt;
var v : tt = (1,&v);
var u = (1,&u); // this is OK, type is 'tt'
val xx = match u with |(?x,_) => x endmatch;

print "OK"; eol;

fun f(i:int) = { return 1; }
fun e(i:int) = { return f 1; }

print (e 10); eol;

match (1,2) with
| (?x,2) => { print x; }
| (1,?y) => { print y; }
endmatch;
eol;

print (if 1==1 then "true" else "false" endif); eol;
print (if 1==0 then "true" else "false" endif); eol;

@select(tangler('test/rt08.flx'))
#include <std.flx>
// closure formation test

// struct as function
/*
struct X { x:int; }
fun execX(p:int->X):X = { return p(1); }
proc print(x:X){ print "struct X"; }
print (execX (X of (int))); endl;
print (execX (X)); endl;
*/

/*
typedef Y = 1 + int;
fun exec2(y2:int->Y,a:int):Y= { return  y2 a; }
proc print(y:Y) { print "union Y"; }
print (exec2(case 2 of Y, 1)); endl;
*/

/*
union U = | A | B of int;
fun exec3(y2:int->U,a:int):U= { return  y2 a; }
proc print(y:U) { print "union U"; }
print (exec2(B, 1)); endl;
*/

@select(tangler('test/rt09.flx'))
// code insertion
body "#include <iostream>";
code 'static int x = 1;';
type int = "int";
fun add:int * int -> int = "$1 + $2";
fun two (): int = { return code[int]x + code[int]'x'; }
proc print:int = 'std::cout << $1 << std::endl;';
print (two());

@select(tangler('test/rt10.flx'))
//multiple assignment
include "std";
var a:int;
var b:int;
var c:int;

a,(b,c) = 1,(2,3);

print a; print " ";
print b; print " ";
print c; print " ";
endl;

def a = 1;
def val x = 2;
def var y = 3;

def a, val d, var e = 9,8,7;

print a; print " ";
print d; print " ";
print e; print " ";
endl;

@select(tangler('test/rt11.flx'))
include "std";

// test dual
typedef y = ~(int+int); // = int * int
val x : y = (1,2);

print x.(0); print " "; print x.(1); endl;

typedef ibl = typeof (1,1L);

// test typematch
typedef tt = typematch ibl with | _ * ?t as z => t * t * z endmatch;
var a:tt = (1L, 2L, (3,4L));

Long::print a.(0); print " "; Long::print a.(1); print " ";
print a.(2).(0); print " "; Long::print a.(2).(1); endl;

typedef fun domainf (t:TYPE):TYPE = typematch t with | ?aa -> ?bb => aa endmatch;
typedef domains [t] = typematch t with | ?aa -> ?bb => aa endmatch;
typedef il = int -> long;
typedef ityf = domainf il;
typedef itys = domains [il];

val one:itys = 1;
val two:ityf = 1;
print one; endl;
print two; endl;

@select(tangler('test/rt12.flx'))
include "std";
print "Felix refcnt test"; endl;

header """
static int counter = 0;
struct checker
{
  int number;
  checker() { number = counter++; std::cout << "ctor " << number << std::endl; }
  ~checker() {std::cout << "dtor " << number << std::endl; --counter; assert (number==counter);}
};
""";

ctypes checker;
fun counter:unit -> int = "counter";
fun get_key:checker->int = "$1.number";

proc f() {
  var x:checker;
  print "F"; print (get_key x); endl;
 proc g() 
 {
    var x:checker;
    print "G"; print (get_key x); endl;
 }
 g();
 g();
}

print "mainline start "; print (get_key zz); endl;
f();
f();

print "mainline end "; print (get_key zz); endl;
var zz:checker;

@head(2,'Bad tests')
All these should fail gracefully at (felix) compile time. 
Run the compiler with the -e option to invert
the return code parity.
@select(tangler('test/bt01.flx'))
basic parser error

@select(tangler('test/bt02.flx'))
module X { proc p(){} }
module Y { proc p(){} }
open X;
open Y;
p; // ambiguous

@select(tangler('test/bt03.flx'))
// open depends on self
#include <std.flx>
interface I { proc print_endl:int; }
module X {
  module M { proc print_endl (a:int) { print a; endl; } }
  module B = M:I;
}
open X;
open B;
print_endl 1;

@select(tangler('test/bt04.flx'))
#include <std.flx>
// these now fail OK: (should yield 'any' .. then fail overload :-)
val aa = bb + 1;
val bb = aa + 1;

@select(tangler('test/bt05.flx'))
// impossible recursion
type int = "int";
fun neg(a:int) = { return -a; }

@select(tangler('test/bt06.flx'))
// privacy violation
include "std";

module X 
{
  private fun f:int -> int = "$1";
  val x = f 1;
}
open X;
val x = f 1;

@select(tangler('test/bt07.flx'))
#define FIRST
#define FIRST

@select(tangler('test/bt08.imp'))
#define FIRST

@select(tangler('test/bt08.flx'))
#define FIRST
#import "bt08.imp"

@select(tangler('test/bt09.flx'))
// this should give an error at felix time
// but we only get one at C++ compile time

/*
[skaller@pelican] ~/links/flx>g++ -w -I. sss.cpp
sss.cpp: In member function `virtual flx::rtl::con_t*
   _i12_p11__init_::resume()':
sss.cpp:256: no matching function for call to `_i15_p6__lam_1::call(
   flx::rtl::con_t*&, _i18_f8__lam_2*&)'
sss.cpp:121: candidates are: virtual flx::rtl::con_t*
   _i15_p6__lam_1::call(flx::rtl::con_t*)
*/
ctypes int;
{ var x:int; read x; }

{ {var x:int; read x; } }

;

