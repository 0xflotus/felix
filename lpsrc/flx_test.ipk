@head(1,'Test Drivers')
These are C++ mainline routines, which are used
to drive different kinds of Felix programs.
@p()
The Universal Program Driver, flx_run,
runs a Felix program with no inputs.
@p()
The Universal Filter Driver, flx_stdin,
runs a Felix program which reads standard input.
@p()
We need some other standard drivers.
An X-Windows driver would be really nice.

@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.

@d = tangler('test/flx_run.cpp')
@select(d)
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <string.h>
#include <assert.h>
#include <dlfcn.h>
#include <string>
#include <unistd.h>
#include "flx_collector.hpp"

// ********** BEGIN HACKS ***************************
// We hack the continuation structure
// here, to make the driver universal
struct continuation_t // abstract base for mutable continuations
{
  int pc;              // program counter
  enum action_t        // what the dispatch should do
  {                    // when the resume callback returns
    yield_action,      // cooperative yield (resume after housekeeping)
    wait_action        // resume with new message
  }  action;

  void *p_message;   // where the next message is put

  continuation_t();
  virtual continuation_t *resume()=0;
  virtual ~continuation_t();
};

continuation_t::continuation_t() : pc(0), action(yield_action) {}
continuation_t::~continuation_t(){}
//
// ********** END HACKS ************************

using namespace std;

// frame types are incomplete
typedef void global_frame_t;
typedef void process_frame_t;
typedef void thread_frame_t;


struct library_linkage_t
{
  // types for linkage
  // frame creators
  typedef global_frame_t *(*global_frame_creator_t)(void);
  typedef process_frame_t *(*process_frame_creator_t)(global_frame_t*);
  typedef thread_frame_t *(*thread_frame_creator_t)
  (
    global_frame_t*,
    process_frame_t*, 
    flx::gc::generic::collector_t*
  );

  // frame destructors
  typedef void (*global_frame_destructor_t)(global_frame_t*);
  typedef void (*process_frame_destructor_t)(process_frame_t*);
  typedef thread_frame_t *(*thread_frame_destructor_t) (thread_frame_t*);


  // library initialisation routine
  typedef continuation_t *(*start_t)
  (
    global_frame_t*, 
    process_frame_t*, 
    thread_frame_t*
  );

  // interface
  void *library;
  global_frame_creator_t global_frame_creator;
  process_frame_creator_t process_frame_creator;
  thread_frame_creator_t thread_frame_creator;
  global_frame_destructor_t global_frame_destructor;
  process_frame_destructor_t process_frame_destructor;
  thread_frame_destructor_t thread_frame_destructor;
  start_t start;
  
  
  void link(char *filename)
  {
    library = dlopen(filename,RTLD_NOW);
    if(!library) {
      printf("Unable to load library %s: make sure LD_LIBRARY_PATH is set, or you use ./xxx.so form\n", filename);
      printf("Error: %s\n", dlerror());
      exit(1);
    }

    global_frame_creator = (global_frame_creator_t)
      dlsym(library,"create_global_frame");
    if(!global_frame_creator) {
      printf("Unable to get global frame creator from library\n");
      exit(1);
    }
    process_frame_creator = (process_frame_creator_t)
      dlsym(library,"create_process_frame");
    if(!process_frame_creator) {
      printf("Unable to get process frame creator from library\n");
      exit(1);
    }
    thread_frame_creator = (thread_frame_creator_t)
      dlsym(library,"create_thread_frame");
    if(!thread_frame_creator) {
      printf("Unable to get thread frame creator from library\n");
      exit(1);
    }

    global_frame_destructor = (global_frame_destructor_t)
      dlsym(library,"destroy_global_frame");
    if(!global_frame_destructor) {
      printf("Unable to get global frame destructor from library\n");
      exit(1);
    }
    process_frame_destructor = (process_frame_destructor_t)
      dlsym(library,"destroy_process_frame");
    if(!process_frame_destructor) {
      printf("Unable to get process frame destructor from library\n");
      exit(1);
    }
    thread_frame_destructor = (thread_frame_destructor_t)
      dlsym(library,"destroy_thread_frame");
    if(!thread_frame_destructor) {
      printf("Unable to get thread frame destructor from library\n");
      exit(1);
    }

    start = (start_t)
      dlsym(library,"start");
    if(!start) {
      printf("Unable to get start procedure from library\n");
      exit(1);
    }
  }

  void unlink()
  {
    dlclose(library);
  }
};


struct library_init_t 
{
  global_frame_t *global_frame;
  process_frame_t *process_frame;
  thread_frame_t *thread_frame;
  continuation_t *start;
  library_linkage_t *lib;

  void create
  (
    library_linkage_t *lib_a, 
    flx::gc::generic::collector_t *collector
  )
  {
    lib = lib_a;
    global_frame = lib->global_frame_creator();
    process_frame = lib->process_frame_creator(global_frame);
    thread_frame = lib->thread_frame_creator(
      global_frame, 
      process_frame, 
      collector 
    );
    start = lib->start(global_frame, process_frame, thread_frame);
  }

  void destroy () {
    lib->thread_frame_destructor(thread_frame);
    lib->process_frame_destructor(process_frame);
    lib->global_frame_destructor(global_frame);
  }
};

int main(int argc, char* argv[])
{
 
  if (argc<2) 
  {
    printf("usage: flx_run ./<shared library name>\n");
    exit(1);
  }
  try 
  {
    //printf("flx_run driver begins\n");
    library_linkage_t library;
    library_init_t instance;

    library.link(argv[1]);
    flx::gc::generic::malloc_free allocator;
    flx::gc::collector::flx_collector_t collector(&allocator);
    instance.create(&library, &collector);
    
    collector.add_root(instance.start);
    int gc_counter = 0;
    continuation_t *top = instance.start;

    while( top && top->action == continuation_t::yield_action)
    {
      continuation_t *new_top = top->resume();
      if(new_top != top) {
        if(new_top) collector.add_root(new_top);
        collector.remove_root(top);
        top = new_top;
      }
    }

    instance.destroy();
    //printf("flx_run driver ends normally\n");
  }
  catch (...)
  {
    printf("flx_run driver ends with EXCEPTION\n");
  }
}

@head(3,'Test 1')
This routine just loops through
numbers 1 to 10, and prints if they're odd or even.
@d = tangler('test/test_library1.flx')
@select(d)
// dispatcher test
header r"""
#include <string>
#include <stdio.h>
using namespace std;
""";

typedef bool = 2;
val false:bool = case 1 of 2;
val true:bool = case 2 of 2;
fun lnot:bool->bool = "!$1";

proc while (cond:unit->bool) (body:unit->void)
{
  repeat:>
    if not (cond()) then goto finished; endif;
    body();
    goto repeat;
  finished:>
}

type string = "string";
proc print: string = 'printf("%s",$1.c_str());';

// type int
type int = "int";
proc print: int = 'printf("%d",$1);';
proc incr : &int = "(*$1)++;";
fun eq : int * int -> bool = "$1==$2";
fun mod: int * int -> int = "$1%$2";
fun lt : int * int -> bool = "$1<$2";
proc set : & int * int = "*$1 = $2;";

union parity = Even | Odd;

procedure fire()
{
  var i : int = 0;
  function get_parity(): parity =
  {
    if(i%2==0) then return Even;
    else return Odd;
    endif
  }
  while [ i < 10]
  {
    print i; print " ";

    val result = 
      match get_parity() with
      |Even => "Even\n"
      |Odd => "Odd\n"
      endmatch
    ;
    print result;

    incr (&i); 
  };
}

print "Felix test_library1 initialising\n";
fire();
print "Felix test_library1 terminating\n";

@head(2,'Performance Test')
The first test program generates lines like:
@begin_displayed_code()
0 0 TEXT
0 1 TEXT
2 2 TEXT
2 3 TEXT
...
@end_displayed_code()
where the first value is a service key, and the second
a sequence number. Messages with the same service
key are sent to the same Felix line handler task:
if one does not exist, it is created. Each task
suicides after reading two lines.
@p()
We create 1 million threads, and process 2 million
messages.
@d = tangler('test/perf_lib_1.flx')
@select(d)
// dispatcher test
header r"""
#include <string>
#include <stdio.h>
using namespace std;
struct check {
  check() { printf("ctor\n"); }
  ~check() { printf("dtor\n"); }
};
""";

type check = "check";
type bool = "bool";
type string = "string";
proc print: string = 'printf("%s",$1.c_str());';

type int = "int";
proc print: int = 'printf("%d",$1);';
proc incr : &int = "(*$1)++;";
fun eq : int * int -> bool = "$1==$2";
proc set : & int * int = "*$1 = $2;";
var counter : int = 0;
var counter2 : int = 0;
proc eol : unit = 'printf("\n");';

procedure handle_line()
{
  var checker : check;
  var line : string;
  print "Reading line 1 ..";
  read line;
  print "line 1 read: "; 
  print line;
  print "\n";
  incr (&counter);
  if (counter == 1000)
  {
    counter <- 0;
    incr (&counter2);
    print counter2;
    print " K\n";
    eol();
  }
  print "SLPI: Reading line 2 ..";
  read line;
  print "line 2 read: "; 
  print line;
  print "suiciding now ..\n";
}

export handle_line of (unit) as "line_handler_creator";

@d = tangler('test/perf_drv_1.cpp')
@select(d)
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <string.h>
#include <assert.h>
#include <dlfcn.h>
#include <string>
#include <unistd.h>

#include "perf_lib_1.hpp"
continuation_t::continuation_t() : pc(0), action(yield_action) {}
continuation_t::~continuation_t(){}

using namespace std;

int xcounter = 0;
int xcounter2 = 0;
message_t read_message() 
{
  char buffer[2000];
  ++ xcounter;
  if (xcounter > 100000) { 
    xcounter = 1; 
    xcounter2++; 
    if(xcounter2>200) exit(0); 
  }
  sprintf(buffer, "%d %d TEXT", xcounter & ~1, xcounter); 
  return message_t(buffer); 
}


int id_of_message(message_t const &msg) 
{
//  return msg >> 1;

  int id = 0;
  char const*p = msg.c_str();
  for(; *p; ++p)
    if(isdigit(*p)) break;

  for(; *p; ++p)
  {
    if(!isdigit(*p)) break;
    else id = id * 10 + int(*p)-int('0');
  }
  //printf("Message id is %d\n",id);
  return id;
}

struct library_linkage_t
{
  // types for linkage
  typedef global_frame_t *(*global_frame_creator_t)(void);
  typedef process_frame_t *(*process_frame_creator_t)(global_frame_t *);
  typedef thread_frame_t *(*thread_frame_creator_t)(global_frame_t *, process_frame_t *, flx::gc::generic::allocator_t *);
  typedef continuation_t *(*start_t)(global_frame_t*, process_frame_t*, thread_frame_t*);
  typedef continuation_t *(*line_handler_creator_t)(global_frame_t*,process_frame_t*,thread_frame_t*);

  // interface
  void *library;
  global_frame_creator_t global_frame_creator;
  process_frame_creator_t process_frame_creator;
  thread_frame_creator_t thread_frame_creator;
  start_t start;
  line_handler_creator_t line_handler_creator;
  
  // find dlsyms from library
  void link(char *filename)
  {
    library = dlopen(filename,RTLD_NOW);
    if(!library) {
      printf("Unable to load library %s: make sure LD_LIBRARY_PATH is set, or you use ./xxx.so form\n", filename);
      printf("Error: %s\n", dlerror());
      exit(1);
    }

    global_frame_creator = (global_frame_creator_t)
      dlsym(library,"create_global_frame");
    if(!global_frame_creator) {
      printf("Unable to get global frame creator from library\n");
      exit(1);
    }
    process_frame_creator = (process_frame_creator_t)
      dlsym(library,"create_process_frame");
    if(!process_frame_creator) {
      printf("Unable to get process frame creator from library\n");
      exit(1);
    }
    thread_frame_creator = (thread_frame_creator_t)
      dlsym(library,"create_thread_frame");
    if(!thread_frame_creator) {
      printf("Unable to get thread frame creator from library\n");
      exit(1);
    }
    start = (start_t)
      dlsym(library,"start");
    if(!start) {
      printf("Unable to get start procedure from library\n");
      exit(1);
    }
    line_handler_creator = (line_handler_creator_t)
      dlsym(library,"line_handler_creator");
    if(!line_handler_creator) {
      printf("Unable to get line handler creator procedure from library\n");
      exit(1);
    }
  }

  void unlink()
  {
    dlclose(library);
  }
};


struct library_init_t 
{
  void *global_frame;
  void *process_frame;
  thread_frame_t *thread_frame;
  continuation_t *start;

  void create(library_linkage_t *lib, flx::gc::generic::allocator_t *allocator)
  {
    global_frame = lib->global_frame_creator();
    process_frame = lib->process_frame_creator(global_frame);
    thread_frame = lib->thread_frame_creator(global_frame, process_frame);
    start = lib->start(global_frame, process_frame, thread_frame);
  }

  void destroy () {}
};

int main(int argc, char* argv[])
{
 
  if (argc<2) 
  {
    printf("usage test_dispatch ./<shared library name>\n");
    exit(1);
  }
  try 
  {
    printf("Running dispatcher ..\n");
    sleep(1);
    library_linkage_t library;
    library_init_t instance;

    library.link(argv[1]);
    flx::gc::generic::malloc_free allocator;
    instance.create(&library, &allocator);
    
    typedef int session_key;
    typedef pair<const session_key, continuation_t*> session_record;

    std::list<session_record> active;
    std::map<session_key,continuation_t*> waiting;
    active.push_front(make_pair(-1,instance.start));
    instance.thread_frame->pool.add_root(instance.start);
    int gc_counter = 0;
    while (true)
    {
      // process all yielded threads until they block or die
      while(active.size() > 0)
      {
        assert(active.size()<100);
        session_record top_rec = *(active.begin());
        int active_thread_id = top_rec.first;
        //printf("Processing active thread %d\n",top_rec.first);
        continuation_t *top = top_rec.second;
        active.pop_front();
        assert(top);
        while(
          top && 
          (
            top->action == continuation_t::yield_action
          )
        )
        {
          continuation_t *new_top = top->resume();
          if(new_top != top) {
            if(new_top) instance.thread_frame->pool.add_root(new_top);
            instance.thread_frame->pool.remove_root(top);
            top = new_top;
          }
        }
        if(top)
        {
          assert (top->action==continuation_t::wait_action);
          try {
            waiting.insert(make_pair(top_rec.first, top));
            assert(waiting.size()<100);
          }
          catch (...) {
            fprintf(stderr,"INSERT FAILED\n");
            exit(0);
          }
        }
        else {
          //printf("SLPI SUICIDES\n");
        }
      }

      //printf("Out of active threads\n");
      // read a message, calculate it's session id
      message_t msg = read_message();
      //printf("Message =%s\n",msg.c_str());
      int id = id_of_message(msg);
      //printf("New message Id=%d\n",id);
   
      // find the id in the map of waiting
      std::map<int,continuation_t*>::iterator line_handler_ptr = 
        waiting.find(id);
      
      if(line_handler_ptr  != waiting.end())
      {
        //printf("Found existing WAITING line handler for %d, making active\n", id);
        active.push_front(*line_handler_ptr);
        *((*line_handler_ptr).second->p_message) = msg;  
        (*line_handler_ptr).second->action = continuation_t::yield_action;  
        waiting.erase(line_handler_ptr);
      }
      else 
      {
        //printf("creating new slpi %d\n", id);
        gc_counter++;
        if(gc_counter==10) {
          //printf("TRIGGERING GC CYCLE\n");
          //printf("Total memory allocated=%ld\n",instance.thread_frame->pool.allocation_amt);
          int collected = instance.thread_frame->pool.collect(); 
          //printf("Collected %d unreachable objects\n", collected);
          //printf("Total memory allocated=%ld\n",instance.thread_frame->pool.allocation_amt);
          if(instance.thread_frame->pool.allocation_count>100)
            printf("WARNING!: Currently allocated=%ld\n", 
            instance.thread_frame->pool.allocation_count);
          gc_counter = 0;
        }
        continuation_t *top = 
          library.line_handler_creator(
            instance.global_frame,
            instance.process_frame,
            instance.thread_frame
          )
        ;
        instance.thread_frame->pool.add_root(top);
        //printf("slpi created, continuation=%p\n",top);
        while(
          top && 
          (
            top->action == continuation_t::yield_action
          )
        )
        {
          continuation_t *new_top = top->resume();
          if(new_top != top) {
            if(new_top) instance.thread_frame->pool.add_root(new_top);
            instance.thread_frame->pool.remove_root(top);
            top = new_top;
          }
        }
        if(top)
        {
          assert (top->action==continuation_t::wait_action);
          top->action = continuation_t::yield_action;
          //printf("slpi waiting for INITIAL message\n");
          try {
            active.push_front (make_pair(id,top));
            assert(active.size()<100);
          }
          catch (...) {
            fprintf(stderr,"PUSH FRONT3 failed\n");
            exit(0);
          }

          if (top->p_message)
          {
            *(top->p_message) = msg;
          }
          else 
          {
            printf("SERVICE ERROR: waiting for message without setting address\n");
            exit(1);
          }
        }
        else 
          printf("Slpi died before reading INITIAL message\n") ;
      }
    }
  }
  catch (...) {
    fprintf(stderr,"EXCEPTION CAUGHT\n");
  }
}

@d = tangler('test/test_library3.flx')
@select(d)
header r"""
#include <string>
#include <stdio.h>
using namespace std;
struct check {
  check() { printf("ctor\n"); }
  ~check() { printf("dtor\n"); }
};
""";

type check = "check";
type bool = "bool";
const true : bool = "true";

type string = "string";
proc print: string = 'printf("%s",$1.c_str());';

type int = "int";
proc print: int = 'printf("%d",$1);';
proc incr : &int = "*$1++;";
fun eq : int * int -> bool = "$1==$2";
proc set : & int * int = "*$1 = $2;";
var counter : int = 0;
var counter2 : int = 0;
proc eol : unit = 'printf("\n");';

procedure handle_line()
{
  var checker : check;
  var line : string;
  loop
  {
    read line;
    print line;
  }
}

export handle_line of (unit) as "line_handler_creator";


@d = tangler('test/test_program2.cpp')
@select(d)
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <string.h>
#include <assert.h>
#include <dlfcn.h>
#include <string>
#include <unistd.h>

#include "test_filter1.hpp"
continuation_t::continuation_t() : pc(0), action(yield_action) {}
continuation_t::~continuation_t(){}

using namespace std;

struct library_linkage_t
{
  // types for linkage
  typedef global_frame_t *(*global_frame_creator_t)(void);
  typedef process_frame_t *(*process_frame_creator_t)(global_frame_t *);
  typedef thread_frame_t *(*thread_frame_creator_t)(global_frame_t *, process_frame_t *, flx::gc::generic::allocator_t *);
  typedef continuation_t *(*start_t)(global_frame_t*, process_frame_t*, thread_frame_t*);
  typedef continuation_t *(*line_handler_creator_t)(global_frame_t*,process_frame_t*,thread_frame_t*);

  // interface
  void *library;
  global_frame_creator_t global_frame_creator;
  process_frame_creator_t process_frame_creator;
  thread_frame_creator_t thread_frame_creator;
  start_t start;
  line_handler_creator_t line_handler_creator;
  
  // find dlsyms from library
  void link(char *filename)
  {
    library = dlopen(filename,RTLD_NOW);
    if(!library) {
      printf("Unable to load library %s: make sure LD_LIBRARY_PATH is set, or you use ./xxx.so form\n", filename);
      printf("Error: %s\n", dlerror());
      exit(1);
    }

    global_frame_creator = (global_frame_creator_t)
      dlsym(library,"create_global_frame");
    if(!global_frame_creator) {
      printf("Unable to get global frame creator from library\n");
      exit(1);
    }
    process_frame_creator = (process_frame_creator_t)
      dlsym(library,"create_process_frame");
    if(!process_frame_creator) {
      printf("Unable to get process frame creator from library\n");
      exit(1);
    }
    thread_frame_creator = (thread_frame_creator_t)
      dlsym(library,"create_thread_frame");
    if(!thread_frame_creator) {
      printf("Unable to get thread frame creator from library\n");
      exit(1);
    }
    start = (start_t)
      dlsym(library,"start");
    if(!start) {
      printf("Unable to get start procedure from library\n");
      exit(1);
    }
    line_handler_creator = (line_handler_creator_t)
      dlsym(library,"line_handler_creator");
    if(!line_handler_creator) {
      printf("Unable to get line handler creator procedure from library\n");
      exit(1);
    }
  }

  void unlink()
  {
    dlclose(library);
  }
};


struct library_init_t 
{
  global_frame_t *global_frame;
  process_frame_t *process_frame;
  thread_frame_t *thread_frame;
  continuation_t *start;

  void create(library_linkage_t *lib, flx::gc::generic::allocator_t *allocator)
  {
    global_frame = lib->global_frame_creator();
    process_frame = lib->process_frame_creator(global_frame);
    thread_frame = lib->thread_frame_creator(global_frame, process_frame, allocator);
    start = lib->start(global_frame, process_frame, thread_frame);
  }

  void destroy () {
    delete thread_frame;
    delete process_frame;
    delete global_frame;
  }
};

int main(int argc, char* argv[])
{
 
  if (argc<2) 
  {
    printf("usage test_filter ./<shared library name>\n");
    exit(1);
  }
  try 
  {
    printf("Running stdin filter ..\n");
    library_linkage_t library;
    library_init_t instance;

    library.link(argv[1]);
    flx::gc::generic::malloc_free allocator;
    instance.create(&library, &allocator);
    
    instance.thread_frame->pool.add_root(instance.start);
    int gc_counter = 0;
    continuation_t *top = 
      library.line_handler_creator(
        instance.global_frame,
        instance.process_frame,
        instance.thread_frame
    );
    instance.thread_frame->pool.add_root(top);

    while(true)
    {
      while( top && top->action == continuation_t::yield_action)
      {
        continuation_t *new_top = top->resume();
        if(new_top != top) {
          if(new_top) instance.thread_frame->pool.add_root(new_top);
          instance.thread_frame->pool.remove_root(top);
          top = new_top;
        }
      }

      // dispatch message
      if(top)
      {
        assert (top->action==continuation_t::wait_action);
        top->action = continuation_t::yield_action;
        if (top->p_message)
        {
          char buffer[2000];
          if(fgets(buffer,2000,stdin))
            *(string*)(top->p_message) = string(buffer);
          else break;
        }
        else 
        {
          printf("SERVICE ERROR: waiting for message without setting address\n");
          exit(1);
        }
      }

      // collect garbage
      {
        gc_counter++;
        if(gc_counter==10) {
          int collected = instance.thread_frame->pool.collect(); 
          if(instance.thread_frame->pool.get_allocation_count()>100)
            printf("WARNING!: Currently allocated=%ld\n", 
            instance.thread_frame->pool.get_allocation_count());
          gc_counter = 0;
        }
      }
    }
    instance.destroy();
    printf("DONE\n");
  }
  catch (...)
  {
    printf("EXCEPTION\n");
  }
}


