@head(1,'Drivers')
These are C++ mainline routines, which are used
to drive different kinds of Felix programs.
@p()
The Universal Filter Driver, flx_stdin,
runs a Felix program which reads standard input.
@p()
We need some other standard drivers.
An X-Windows driver would be really nice.


@head(2,'Test 1')
The Universal Program Driver, flx_run,
runs a Felix program with no inputs.
This driver is located in flx_rtl.ipk.
@p()
This routine just loops through
numbers 1 to 10, and prints if they're odd or even.
@d = tangler('test/flx_run_lib1.flx')
@select(d)
// dispatcher test
header r"""
#include <string>
#include <stdio.h>
using namespace std;
""";

typedef void = 0;
typedef unit = 1;
typedef bool = 2;
fun lnot:bool->bool = "!$1";

proc while (cond:unit->bool) (bdy:unit->void)
{
  repeat:>
    if not (cond()) goto finished;
    bdy();
    goto repeat;
  finished:>
}

type string = "string";
proc print: string = 'printf("%s",$1.data());';

// type int
type int = "int";
proc print: int = 'printf("%d",$1);';
proc incr : &int = "(*$1)++;";
fun eq : int * int -> bool = "$1==$2";
fun mod: int * int -> int = "$1%$2";
fun lt : int * int -> bool = "$1<$2";
proc set : & int * int = "*$1 = $2;";

union parity = Even | Odd;

proc fire()
{
  var i : int = 0;
  fun get_parity(): parity =
  {
    return
      if(i%2==0) then Even
      else Odd
      endif;
  }
  while {i < 10}
  {
    print i; print " ";

    val result = 
      match get_parity() with
      |Even => "Even\n"
      |Odd => "Odd\n"
      endmatch
    ;
    print result;

    incr (&i); 
  };
}

print "Felix test_library1 initialising\n";
fire();
print "Felix test_library1 terminating\n";

@head(2,'Standard input Driver')
Driver delivers standard input by way
of a string. No end of file is delivered
to the client.

@head(3,'Driver implementation')
@d = tangler('rtl/flx_stdin_drv.cpp')
@select(d)
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <string.h>
#include <assert.h>
#include <dlfcn.h>
#include <string>
#include <unistd.h>

#include "rtl/flx_rtl.hpp"
#include "rtl/flx_collector.hpp"
#include "rtl/flx_dynlink.hpp"

using namespace flx::rtl;
using namespace flx::gc::generic;
using namespace flx::gc::collector;
using namespace std;

typedef string message_t;

struct library_linkage_t : flx_dynlink_t
{
  typedef con_t *(*line_handler_creator_t)
  (
    global_frame_t*,
    process_frame_t*,
    thread_frame_t*
  );

  // interface
  line_handler_creator_t line_handler_creator;
  
  // find dlsyms from library
  void usr_link()
  {
    line_handler_creator = (line_handler_creator_t)
      dlsym(library,"line_handler_creator");
    if(!line_handler_creator) {
      printf("Unable to get line handler creator procedure from library\n");
      exit(1);
    }
  }
};


int main(int argc, char* argv[])
{
 
  if (argc<2) 
  {
    printf("stdin filter driver\n");
    printf("usage flx_stdin_drv ./<shared library name>\n");
    exit(1);
  }
  try 
  {
    printf("Running stdin filter ..\n");
    library_linkage_t library;
    flx_libinit_t instance;

    library.link(argv[1]);
    malloc_free allocator;
    flx_collector_t collector(&allocator);
    instance.create(&library, &collector);
 
    collector.add_root(instance.start);
    int gc_counter = 0;
    con_t *top = 
      library.line_handler_creator(
        instance.global_frame,
        instance.process_frame,
        instance.thread_frame
    );
    collector.add_root(top);

    while(true)
    {
      while( top && top->action == con_t::yield_action)
      {
        con_t *new_top = top->resume();
        if(new_top != top) {
          if(new_top) collector.add_root(new_top);
          collector.remove_root(top);
          top = new_top;
        }
      }

      // dispatch message
      if(top)
      {
        assert (top->action==con_t::wait_action);
        top->action = con_t::yield_action;
        if (top->p_message)
        {
          char buffer[2000];
          if(fgets(buffer,2000,stdin))
            *(string*)(top->p_message) = string(buffer);
          else break;
        }
        else 
        {
          printf("SERVICE ERROR: waiting for message without setting address\n");
          exit(1);
        }
      }

      // collect garbage
      {
        gc_counter++;
        if(gc_counter==10) {
          int collected = collector.collect(); 
          if(collector.get_allocation_count()>100)
            printf("WARNING!: Currently allocated=%ld\n", 
            collector.get_allocation_count());
          gc_counter = 0;
        }
      }
    }
    instance.destroy();
    printf("DONE\n");
  }
  catch (...)
  {
    printf("EXCEPTION\n");
  }
}


@head(3,'Test1')
@d = tangler('test/flx_stdin_lib1.flx')
@select(d)
header r"""
#include <string>
#include <stdio.h>
using namespace std;
struct check {
  check() { printf("ctor\n"); }
  ~check() { printf("dtor\n"); }
};
""";

type check = "check";
typedef bool = 2;

type string = "string";
proc print: string = 'printf("%s",$1.data());';

type int = "int";
proc print: int = 'printf("%d",$1);';
proc incr : &int = "*$1++;";
fun eq : int * int -> bool = "$1==$2";
proc set : & int * int = "*$1 = $2;";
var counter : int = 0;
var counter2 : int = 0;
proc eol : 1 = 'printf("\n");';

proc handle_line()
{
  var checker : check;
  var line : string;
  repeat:> 
    read line;
    print line;
    goto repeat;
}

export handle_line of (1) as "line_handler_creator";


@head(2,'Performance Test')
The first test program generates lines like:
@begin_displayed_code()
0 0 TEXT
0 1 TEXT
2 2 TEXT
2 3 TEXT
...
@end_displayed_code()
where the first value is a service key, and the second
a sequence number. Messages with the same service
key are sent to the same Felix line handler task:
if one does not exist, it is created. Each task
suicides after reading two lines.
@p()
We create 1 million threads, and process 2 million
messages.

@head(3,'Driver Implementation')
@d = tangler('test/flx_perf_drv1.cpp')
@select(d)
#include <unistd.h>
#include <dlfcn.h>

#include <cstdio>
#include <cstring>
#include <cassert>

#include <vector>
#include <list>
#include <map>
#include <string>
#include <iostream>

#include "rtl/flx_rtl.hpp"
#include "rtl/flx_collector.hpp"
#include "rtl/flx_dynlink.hpp"

using namespace flx::rtl;
using namespace flx::gc::generic;
using namespace flx::gc::collector;
using namespace std;

typedef string message_t;

int xcounter = 0;
int xcounter2 = 0;
message_t read_message() 
{
  char buffer[30];
  memset(buffer,0,30);
  ++ xcounter;
  if (xcounter > 100000) { 
    xcounter = 1; 
    xcounter2++; 
    if(xcounter2>200) exit(0); 
  }
  sprintf(buffer, "%d %d TEXT", xcounter & ~1, xcounter); 
  return buffer;
}


int id_of_message(string const &msg) 
{
//  return msg >> 1;

  int id = 0;
  char const*p = msg.data();
  for(; *p; ++p)
    if(isdigit(*p)) break;

  for(; *p; ++p)
  {
    if(!isdigit(*p)) break;
    else id = id * 10 + int(*p)-int('0');
  }
  //printf("Message id is %d\n",id);
  return id;
}

struct library_linkage_t : flx_dynlink_t
{
  typedef con_t *(*line_handler_creator_t)
  (
    global_frame_t*,
    process_frame_t*,
    thread_frame_t*
  );

  // interface
  line_handler_creator_t line_handler_creator;
  
  // find dlsyms from library
  void usr_link()
  {
    line_handler_creator = (line_handler_creator_t)
      dlsym(library,"line_handler_creator");
    if(!line_handler_creator) {
      printf("Unable to get line handler creator procedure from library\n");
      exit(1);
    }
  }
};


int main(int argc, char* argv[])
{
 
  if (argc<2) 
  {
    printf("usage flx_perf_drv ./<shared library name>\n");
    exit(1);
  }
  try 
  {
    printf("Running flx_perf_drv ..\n");
    sleep(1);
    library_linkage_t library;
    flx_libinit_t instance;

    library.link(argv[1]);
    malloc_free allocator;
    flx_collector_t collector(&allocator);
    instance.create(&library, &collector);
    
    typedef int session_key;
    typedef pair<const session_key, con_t*> session_record;

    std::list<session_record> active;
    std::map<session_key,con_t*> waiting;
    active.push_front(make_pair(-1,instance.start));
    collector.add_root(instance.start);
    int gc_counter = 0;
    while (true)
    {
      // process all yielded threads until they block or die
      while(active.size() > 0)
      {
        assert(active.size()<100);
        session_record top_rec = *(active.begin());
        int active_thread_id = top_rec.first;
        //printf("Processing active thread %d\n",top_rec.first);
        con_t *top = top_rec.second;
        active.pop_front();
        assert(top);
        while(
          top && 
          (
            top->action == con_t::yield_action
          )
        )
        {
          con_t *new_top = top->resume();
          if(new_top != top) {
            if(new_top) collector.add_root(new_top);
            collector.remove_root(top);
            top = new_top;
          }
        }
        if(top)
        {
          assert (top->action==con_t::wait_action);
          try {
            waiting.insert(make_pair(top_rec.first, top));
            assert(waiting.size()<100);
          }
          catch (...) {
            fprintf(stderr,"INSERT FAILED\n");
            exit(0);
          }
        }
        else {
          //printf("SLPI SUICIDES\n");
        }
      }

      //printf("Out of active threads\n");
      // read a message, calculate it's session id
      message_t msg = read_message();
      //printf("Message =%s\n",msg.data());
      int id = id_of_message(msg);
      //printf("New message Id=%d\n",id);
   
      // find the id in the map of waiting
      std::map<int,con_t*>::iterator line_handler_ptr = 
        waiting.find(id);
      
      if(line_handler_ptr  != waiting.end())
      {
        //printf("Found existing WAITING line handler for %d, making active\n", id);
        active.push_front(*line_handler_ptr);
        *(message_t*)((*line_handler_ptr).second->p_message) = msg;  
        (*line_handler_ptr).second->action = con_t::yield_action;  
        waiting.erase(line_handler_ptr);
      }
      else 
      {
        //printf("creating new slpi %d\n", id);
        gc_counter++;
        if(gc_counter==100) {
          //printf("TRIGGERING GC CYCLE\n");
          //printf("Total memory allocated=%ld\n",collector.get_allocation_amt());
          int collected = collector.collect(); 
          //printf("Collected %d unreachable objects\n", collected);
          //printf("Total memory allocated=%ld\n",collector.get_allocation_amt());
          if(collector.get_allocation_count()>100)
            printf("WARNING!: Currently allocated=%ld\n", 
            collector.get_allocation_count());
          gc_counter = 0;
        }
        con_t *top = 
          library.line_handler_creator(
            instance.global_frame,
            instance.process_frame,
            instance.thread_frame
          )
        ;
        collector.add_root(top);
        //printf("slpi created, continuation=%p\n",top);
        while(
          top && 
          (
            top->action == con_t::yield_action
          )
        )
        {
          con_t *new_top = top->resume();
          if(new_top != top) {
            if(new_top) collector.add_root(new_top);
            collector.remove_root(top);
            top = new_top;
          }
        }
        if(top)
        {
          assert (top->action==con_t::wait_action);
          top->action = con_t::yield_action;
          //printf("slpi waiting for INITIAL message\n");
          try {
            active.push_front (make_pair(id,top));
            assert(active.size()<100);
          }
          catch (...) {
            fprintf(stderr,"PUSH FRONT3 failed\n");
            exit(1);
          }

          if (top->p_message)
          {
            *(message_t*)(top->p_message) = msg;
          }
          else 
          {
            printf("SERVICE ERROR: waiting for message without setting address\n");
            exit(1);
          }
        }
        else 
          printf("Slpi died before reading INITIAL message\n") ;
      }
    }
    printf("All services terminated ..\n");
    printf("%ld garbage\n",collector.get_allocation_amt());
    collector.collect();
    instance.destroy();
    printf("flx_perf_drv ends normally\n");
    exit(0);
  }
  catch (...) {
    fprintf(stderr,"EXCEPTION CAUGHT\n");
  }
}

@head(2,'Performance test client')
@d = tangler('test/flx_perf_lib1.flx')
@select(d)
// dispatcher test
header r"""
#include <string>
#include <stdio.h>
#include <iostream>

using namespace std;
struct check {
  check() { printf("ctor %p\n",this); }
  ~check() { printf("dtor %p\n",this); }
};
""";

type check = "check";
typedef bool = 2;
type string = "string";
proc print: string = 'cout << $1;';

type int = "int";
proc print: int = 'cout <<$1;';
proc incr : &int = "(*$1)++;";
fun eq : int * int -> bool = "$1==$2";
proc set : & int * int = "*$1 = $2;";
var counter : int = 0;
var counter2 : int = 0;

proc handle_line()
{
  //var checker : check;
  var line : string;
  //print "Reading line 1 ..";
  read line;
  //print "line 1 read: "; 
  //print line;
  //print "\n";
  incr (&counter);
  if (counter == 100000) then
  {
    counter = 0;
    incr (&counter2);
    print counter2;
    print "00 K\n";
  } 
  else 
  {} 
  endif
  ;
  //print "SLPI: Reading line 2 ..";
  read line;
  //print "line 2 read: "; 
  //print line;
  //print "suiciding now ..\n";
}

export handle_line of (1) as "line_handler_creator";


