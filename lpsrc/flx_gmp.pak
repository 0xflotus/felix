@from flxbuild.iscrutil import setup_test
@from flxbuild.flxutil import unix2native

@env = setup_test(get_input_frame(), 'test/gmp/gmp-')

@head(1,'GNU Multiple Precision library')
This module provides a wrapper for the Gnu Multiple
Precision Arithmetic library known as gmp.
The C++ interface is required for this library,
you may need to download it. The library and include
files must be available in standard places for the
scripting harness to find them.
@p()
REQUIRES: -lgmpxx -lgmp

@select(tangler("cpkgs/target/gmpxx.py"))
from flxbuild.config_support import cwrite, cload, pa
try:
  cload(globals(),"target_gmpxx")
except:
  import config
  HAVE_GMPXX = config.TARGET_CXX.check_header_exists('gmpxx.h')
  f = cwrite('target_gmpxx')
  pa(f, locals(), "HAVE_GMPXX")
  f.close()
  cload(globals(), "target_gmpxx")

@h = tangler('spkgs/gmpxx.py')
@select(h)
from cpkgs.target.gmpxx import HAVE_GMPXX
if HAVE_GMPXX:
@tangle('  unit_tests = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')

iscr_source = ['lpsrc/flx_gmp.pak']
weaver_directory = 'doc/gmp/'

@h = tangler('config/gmpxx.fpc')
@select(h)
requires_slibs: -lgmp
requires_dlibs: -lgmp
provides_dlib: -lgmpxx
provides_slib: -lgmpxx

@h = tangler('lib/flx_gmp.flx','data')
@select(h)
#import <flx.flxh>

// THIS WRAPPER IS FFAU .. it is NOT LGPL licenced
// This is because the wrapper was hand written from
// scratch .. it was NOT derived from any LGPL headers
// Code LINKED against libgmp, however, may be governed
// by the LGPL licence, since the object files ARE
// derived from gmp.h

header "#include <cstdio>";
header gmpxx_h = """
#include <gmpxx.h>
#include <string>
#include <cstdio>
namespace flx { namespace gmp {
extern mpz_class lcm(mpz_class const&,mpz_class const&);
extern mpz_class gcd(mpz_class const&,mpz_class const&);
extern std::string flx_mpf_get_str(mpf_class const&);
}}
""";

body gmpxx_lcm = """
namespace flx { namespace gmp {
mpz_class lcm(mpz_class const &a, mpz_class const &b)
{
  mpz_t r; mpz_init(r);
  mpz_lcm(r,a.get_mpz_t(),b.get_mpz_t());
  return mpz_class(r);
}
}}
""";

body gmpxx_gcd = """
namespace flx { namespace gmp {
mpz_class gcd(mpz_class const &a, mpz_class const &b)
{
  mpz_t r; mpz_init(r);
  mpz_gcd(r,a.get_mpz_t(),b.get_mpz_t());
  return mpz_class(r);
}
}}
""";

body flx_mpf_get_str_h = """
namespace flx { namespace gmp {
string flx_mpf_get_str(mpf_class const &a)
{
  mp_exp_t x;
  std::string s = a.get_str(&x,10,0);
  char b[100];
  std::snprintf(b,100,"e%ld",(long)x);
  return std::string(".")+s+b;
}
}}
""";


@typs = ['mpz', 'mpq', 'mpf']
@iops = [('add','+'),('sub','-',),('mul','*'),('div','/')]
module Gmp
{
  requires gmpxx_h;
  requires package "gmpxx";
  type mpz='mpz_class';
  type mpq='mpq_class';
  type mpf='mpf_class';
@for t in typs:
  for op,infix in iops:
    tangle('  fun '+op+':'+t+'*'+t+'->'+t+'="$1'+infix+'$2";')
  tangle('  fun neg:'+t+'->'+t+'="-$1";')
  tangle('  fun abs:'+t+'->'+t+'="abs($1)";')
  tangle('  fun sgn:'+t+'->int="sgn($1)";')
  tangle('  fun sqrt:'+t+'->'+t+'="sqrt($1)";')
  tangle('  fun cmp:'+t+'*'+t+'->int="cmp($1,$2)";')
  tangle('  proc fprint: ostream * '+t+'="*$1<<$2;";')
fun lcm: mpz * mpz -> mpz = "flx::gmp::lcm($1,$2)" requires gmpxx_lcm;
fun gcd: mpz * mpz -> mpz = "flx::gmp::gcd($1,$2)" requires gmpxx_gcd;
fun wedge: mpz * mpz -> mpz = "flx::gmp::lcm($1,$2)" requires gmpxx_lcm;
fun vee: mpz * mpz -> mpz = "flx::gmp::gcd($1,$2)" requires gmpxx_gcd;

fun mod: mpz * mpz -> mpz = "$1%$2";
fun mpz_of_int: int -> mpz = "mpz_class($1)";
fun mpq_of_int: int -> mpq = "mpq_class($1)";
fun mpf_of_double: double -> mpf = "mpf_class($1)";

@for t in typs:
  tangle("instance Eq["+t+"] {")
  tangle('  fun eq:'+t+'*'+t+'->bool="$1==2";')
  tangle('  fun ne:'+t+'*'+t+'->bool="$1!=$2";')
  tangle("}")
  tangle("instance Tord["+t+"] {")
  tangle('  fun lt:'+t+'*'+t+'->bool="$1<$2";')
  tangle('  fun le:'+t+'*'+t+'->bool="$1<=$2";')
  tangle('  fun gt:'+t+'*'+t+'->bool="$1>$2";')
  tangle('  fun ge:'+t+'*'+t+'->bool="$1>=$2";')
  tangle("}")
@for t in ['mpz','mpq']:
  tangle("instance Str["+t+"] {")
  tangle('  fun str:'+t+'->string="#1($1).get_str(10)";')
  tangle("}")
@#

instance Str[mpf] {
  fun str:mpf->string="flx::gmp::flx_mpf_get_str($1)" requires flx_mpf_get_str_h;
}

}
@for t in typs:
  tangle("open Eq[Gmp::"+t+"];")
  tangle("open Tord[Gmp::"+t+"];")
  tangle("open Str[Gmp::"+t+"];")
@#
@doc()

@env.head(1,'gmp tests')
@select(env.test('.flx'))
#import <flx.flxh>
include "flx_gmp";
open Gmp;

{
  val x:mpz = mpz_of_int 99;
  val y:mpz = mpz_of_int 7;
  print x; endl;
  print y; endl;
  print$ x + y; endl;
  print$ x - y; endl;
  print$ x * y; endl;
  print$ x / y; endl;
  print$ x % y; endl;

  print$ x == y; endl;
  print$ x != y; endl;
  print$ x < y; endl;
  print$ x <= y; endl;
  print$ x > y; endl;
  print$ x >= y; endl;

  print$ lcm (x,y); endl;
  print$ gcd (x,y); endl;
  print$ x /\ y; endl;
  print$ x \/ y; endl;
};
{
  val x:mpq = mpq_of_int 99;
  val y:mpq = mpq_of_int 7;
  print x; endl;
  print y; endl;
  print$ x + y; endl;
  print$ x - y; endl;
  print$ x * y; endl;
  print$ x / y; endl;
  print$ x == y; endl;
  print$ x != y; endl;
  print$ x < y; endl;
  print$ x <= y; endl;
  print$ x > y; endl;
  print$ x >= y; endl;
};
{
  val x:mpf = mpf_of_double 99.0;
  val y:mpf = mpf_of_double 7.0;
  print x; endl;
  print y; endl;
  print$ x + y; endl;
  print$ x - y; endl;
  print$ x * y; endl;
  print$ x / y; endl;
  print$ x == y; endl;
  print$ x != y; endl;
  print$ x < y; endl;
  print$ x <= y; endl;
  print$ x > y; endl;
  print$ x >= y; endl;
};
@doc()

@select(env.expect())
99
7
106
92
693
14
1
false
true
false
false
true
true
693
1
693
1
99
7
106
92
693
99/7
false
true
false
false
true
true
.99e2
.7e1
.106e3
.92e2
.693e3
.141428571428571428571e2
false
true
false
false
true
true
@doc()
