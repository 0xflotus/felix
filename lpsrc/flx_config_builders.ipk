@h = tangler("flxbuild/compiler_base.py")
@select (h)
import os
import sys
from flxbuild.flxutil import xqt

class compiler_base(object):
  def __init__(self, verbose=False, quiet=False):
    class Options:
      pass
    self.options = Options()
    self.verbose = verbose
    self.quiet = quiet

  def shell(self, *args, **kwds):
    kwds.setdefault('verbose', self.verbose)
    kwds.setdefault('quiet', self.quiet)

    return xqt(*args, **kwds)

  def set_options(self):
    pass

  def save_options(self, filename):
    f = open(filename, "w")
    ks = self.options.__dict__.keys()
    ks.sort()
    for k in ks:
      if k[0] != '_': # do not save __builtins__
        v = self.options.__dict__[k]
        f.write(k+'='+repr(v) + "\n")
    f.close()


  def load_options(self,filename):
    f = open(filename)
    exec f in self.options.__dict__
    f.close()

  def find_in_flx_dir(self, filename):
    # check first if the file exists in the felix directory
    # if it does, use it instead of the one in the local directory
    try:
      from config import FLX_DIR
    except ImportError:
      pass
    else:
      f = os.path.join(FLX_DIR, filename)
      if os.path.exists(f):
        return f

    return filename

@h = tangler("flxbuild/c_cxx_base.py")
@select (h)
import os
import sys

from flxbuild.flxutil import mkdirs, ExecutionError
from flxbuild.compiler_base import compiler_base

class c_cxx_base(compiler_base):
  DEFAULT_COM = None
  DEFAULT_AR = None
  DEFAULT_RANLIB = None

  def set_options(self,
      COM=None,
      AR=None,
      RANLIB=None,
      build="posix",
      model="detect",
      use="generic",
      include_paths=None,
      lib_paths=None,
      **kwds):
    super(c_cxx_base, self).set_options(**kwds)

    opt = self.options

    # RF: this looks like in most cases it replaces None with None...
    if COM is None:           COM = self.DEFAULT_COM
    if AR is None:            AR = self.DEFAULT_AR
    if RANLIB is None:        RANLIB = self.DEFAULT_RANLIB
    if include_paths is None: include_paths = []
    if lib_paths is None:     lib_paths = []

    assert COM, 'need to specify a compiler'
    assert AR, 'need to specify a static library linker'

    if RANLIB is not None: RANLIB = RANLIB + ' '

    opt.COM = COM + ' '
    opt.AR = AR + ' '
    opt.RANLIB = RANLIB
    opt.build = build
    opt.model = model
    opt.use = use
    opt.include_paths = include_paths
    opt.lib_paths = lib_paths

    # defaults for gcc specific stuff
    opt.HAVE_GNU_X86 = False
    opt.HAVE_GNU_X86_64 = False
    opt.USE_REGPARM3 = False
    opt.HAVE_CGOTO = False
    opt.HAVE_ASM_LABELS = False
    opt.HAVE_STL_GNU_CXX = False
    opt.HAVE_GNU_BUILTIN_EXPECT = False


    print "COM =", opt.COM

  ########

  # RF: would be nice to know which kind of source was being written
  def write_src(self, data, basename='tmp'):
    f = open(basename + self.options.EXT_SRC_MAIN, "w")
    try:
      f.write(data + '\n')
    finally:
      f.close()

    return basename

  # RF: temporarily added this to get the dll building config tests working.
  # previously write_src was creating .cpp files and the build_dll code
  # was looking for .cxx. This is a work around.
  def write_lib_src(self, data, basename='tmp'):
    f = open(basename + self.options.EXT_SRC_LIB, "w")
    try:
      f.write(data + '\n')
    finally:
      f.close()

    return basename

  ########

  def compile_thing(self, COM, EXT_SRC, EXT_DST, basenames,
      outdir='',
      include_paths=[],
      macros=[],
      optimise=False,
      debug=False,
      CFLAGS=None,
      log=None,
      ):
    opt = self.options

    objects = []
    for basename in basenames:
      src = self.find_in_flx_dir(basename + EXT_SRC)
      dst = os.path.join(outdir, basename + EXT_DST)
      mkdirs(os.path.dirname(dst))

      # compile for a dll: position independent code etc
      cmd = [COM]

      # debug symbols
      if debug: cmd.append(opt.DEBUG_FLAGS)

      # optimisation
      if optimise: cmd.append(opt.OPTIMISE)

      # include path
      for i in include_paths:     cmd.append(opt.SPEC_INCLUDE + i)
      for i in opt.include_paths: cmd.append(opt.SPEC_INCLUDE + i)

      # output file
      cmd.append(opt.SPEC_OBJ_FILENAME + dst)

      #macros
      for i in macros: cmd.append(opt.SPEC_DEFINE + i)

      if opt.use == "host":     cmd.append(opt.SPEC_DEFINE + "HOST_BUILD")
      elif opt.use == "target": cmd.append(opt.SPEC_DEFINE + "TARGET_BUILD")

      if CFLAGS: cmd.append(CFLAGS)

      #input file
      cmd.append(src)

      # compile it
      self.shell(*cmd, **dict(log=log))

      objects.append(dst)

    return objects

  ####

  def compile_static_thing(self, COM, EXT_SRC, *args, **kwds):
    return self.compile_thing(COM, EXT_SRC, self.options.EXT_STATIC_OBJ,
        *args, **kwds)


  # compile a file to an object suitable for inclusion in a static link
  # version of the RTL
  def compile_static_rtl(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_STATIC_RTL', opt.COM + opt.SPEC_COMPILE_OBJ)
    return self.compile_static_thing(COM, opt.EXT_SRC_LIB, *args, **kwds)


  def compile_static_main(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_STATIC_MAIN', opt.COM + opt.SPEC_COMPILE_OBJ)
    return self.compile_static_thing(COM, opt.EXT_SRC_MAIN, *args, **kwds)


  def compile_felix_static(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_STATIC_FLX', opt.COM + opt.SPEC_COMPILE_OBJ)
    return self.compile_static_thing(COM, opt.EXT_SRC_LIB, *args, **kwds)

  ####

  def compile_shared_thing(self, COM, EXT_SRC, *args, **kwds):
    # add shared flag, then execute
    return self.compile_thing(COM, EXT_SRC, self.options.EXT_SHARED_OBJ,
        *args, **kwds)


  # compile a file to an object suitable for inclusion in a mainline
  # which links to shared libraries
  def compile_shared_rtl(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_DYNAMIC_RTL', opt.COM + opt.SPEC_COMPILE_OBJ)
    return self.compile_shared_thing(COM, opt.EXT_SRC_LIB, *args, **kwds)


  def compile_shared_main(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_DYNAMIC_MAIN', opt.COM + opt.SPEC_COMPILE_OBJ)
    return self.compile_shared_thing(COM, opt.EXT_SRC_MAIN, *args, **kwds)


  def compile_felix_dll(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_DYNAMIC_FLX', opt.COM + opt.SPEC_COMPILE_OBJ)
    return self.compile_shared_thing(COM, opt.EXT_SRC_LIB, *args, **kwds)

  ########

  def link_thing(self, LINK, EXT_DST, objects, outfile,
      lib_paths=[],
      libs=[],
      LDFLAGS="",
      log=None,
      ):
    dst = outfile + EXT_DST

    opt = self.options
    cmd = [LINK]
    cmd.append(opt.SPEC_EXE_FILENAME + dst)
    cmd.extend(objects)

    # RF: this is a hack to make sure that /link come before all link flags
    # under visual studio. I tried making sure that LDFLAGS had /link first
    # and moved it to just after the obj files, but that broke the gcc build
    # as some folk pass the libs in "libs" and others pass them directly
    # as LDFLAGS args. So much for encapsulation, eh?
    if opt.PRE_LINK_FLAGS: cmd.append(opt.PRE_LINK_FLAGS)

    for i in lib_paths:     cmd.append(opt.SPEC_LIBPATH + i)
    for i in opt.lib_paths: cmd.append(opt.SPEC_LIBPATH + i)

    for i in libs:
      if opt.POSIX and i.startswith('lib'):
        i = i[3:]

      cmd.append(opt.SPEC_LIB + i)

    cmd.append(LDFLAGS)

    mkdirs(os.path.dirname(outfile))

    self.shell(*cmd, **dict(log=log))

    return dst

  ####

  def link_static_thing(self, COM, EXT_DST, *args, **kwds):
    return self.link_thing(COM, EXT_DST, *args, **kwds)


  def link_static_rtl(self, objects, outfile,
      lib_paths=[],
      libs=[],
      LDFLAGS="",
      log=None):
    opt = self.options

    filename = outfile + opt.EXT_LIB

    cmd = [opt.AR, opt.SPEC_AR_OUT_FILENAME + filename]
    cmd.extend(objects)

    mkdirs(os.path.dirname(outfile))

    self.shell(*cmd, **dict(log=log))

    if opt.RANLIB:
      self.shell(opt.RANLIB, filename, log=log)

    return filename


  def link_static_program(self, *args, **kwds):
    opt = self.options
    return self.link_static_thing(opt.CCLINK_STATIC, opt.EXT_EXE, *args, **kwds)

  ####

  def link_shared_thing(self, COM, EXT_DST, *args, **kwds):
    return self.link_thing(COM, EXT_DST, *args, **kwds)


  def link_shared_rtl(self, *args, **kwds):
    opt = self.options
    return self.link_shared_thing(opt.CCLINK_DYNAMIC_RTL, opt.EXT_DYLIB,
        *args, **kwds)


  def link_shared_dll(self, *args, **kwds):
    opt = self.options
    return self.link_shared_thing(opt.CCLINK_DYNAMIC_FLX, opt.EXT_SHLIB,
        *args, **kwds)


  def link_shared_program(self, *args, **kwds):
    opt = self.options
    return self.link_shared_thing(opt.CCLINK_DYNAMIC_MAIN, opt.EXT_EXE,
        *args, **kwds)

  ########

  def build_thing(self, compile_fn, link_fn, basenames,
      outfile=None,
      outdir='',
      objects=[],
      include_paths=[],
      macros=[],
      optimise=False,
      debug=False,
      CFLAGS="",
      lib_paths=[],
      libs=[],
      LDFLAGS="",
      log=None,
      ):
    if type(basenames) != type([]):
      basenames = [basenames]

    assert basenames

    objects = objects + compile_fn(basenames,
            outdir=outdir,
            include_paths=include_paths,
            macros=macros,
            optimise=optimise,
            debug=debug,
            CFLAGS=CFLAGS,
            log=log,
            )

    if outfile is None:
      outfile = basenames[0]

    return link_fn(objects, outfile,
        lib_paths=lib_paths,
        libs=libs,
        LDFLAGS=LDFLAGS,
        log=log,
      )


  def build_static_rtl(self, *args, **kwds):
    return self.build_thing(self.compile_static_rtl, self.link_static_rtl,
        *args, **kwds)

  def build_felix_static(self, *args, **kwds):
    return self.build_thing(self.compile_felix_static, self.link_static_program,
        *args, **kwds)

  def build_static_program(self, *args, **kwds):
    return self.build_thing(self.compile_static_main, self.link_static_program,
        *args, **kwds)

  def build_shared_rtl(self, *args, **kwds):
    return self.build_thing(self.compile_shared_rtl, self.link_shared_rtl,
        *args, **kwds)

  def build_shared_dll(self, *args, **kwds):
    return self.build_thing(self.compile_felix_dll, self.link_shared_dll,
        *args, **kwds)

  def build_shared_program(self, *args, **kwds):
    return self.build_thing(self.compile_shared_main, self.link_shared_program,
        *args, **kwds)

  ########

  def run_static_program(self, *args, **kwds):
    filename = self.build_static_program(*args, **kwds)
    return self.shell(filename)

  def run_shared_program(self, basename):
    filename = self.build_shared_program(*args, **kwds)
    return self.shell(filename)

  ########

  def run_static_string_program(self, data, basename, *args, **kwds):
    basename = self.write_src(data, basename)
    return self.run_static_program(basename, *args, **kwds)


  def run_static_shared_program(self, data, basename, *args, **kwds):
    basename = self.write_src(data, basename)
    return self.run_shared_program(basename, *args, **kwds)

  ########

  def build_string_program(self, data, basename='tmp', **kwds):
    filename = self.write_src(data, basename)
    return self.build_static_program(filename, **kwds)

  ####

  def compile_dummy_main(self, **kwds):
    basename = 'tmp' + os.sep + 'dummy'
    filename = self.write_src(
        'int main(int argc, char** argv) { return 0; }', basename)
    return self.compile_static_main([filename], **kwds)


  def compile_dummy_lib_program(self, **kwds):
    basename = 'tmp' + os.sep + 'dummy_lib'
    # RF: This can be compiled as both c and c++ these days it seems
    # hence conditional extern "C"
    # P.S. This lovingly hand crafted function doesn't seem to be called
    sys.exit(1234) # let's see!
    proggy = """
#ifdef __cplusplus
extern "C"
#endif
int fred(int argc, char** argv) { return 0; }
"""

    filename = self.write_src(proggy, basename)

    return self.compile_static_main([filename], **kwds)

  ########

  def check_macro_defined(self, macro, header=''):
    if header:
      header = '#include <%s>' % header

    filename = "tmp" + os.sep + "mchk"
    self.write_src("""
%s
#ifndef %s
#error %s
#endif
int main(int argc, char** argv) {return 0;}
""" % (header, macro, macro), filename)

    try:
      self.compile_static_main([filename])
    except ExecutionError:
      if header:
        print "NOT defined %s in %s" % (macro, header)
      else:
        print "NOT defined", macro
      return False
    else:
      if header:
        print "#defined %s in %s" % (macro, header)
      else:
        print "#defined", macro
      return True


  def check_header_exists(self, name):
    basename = "tmp" + os.sep + "hchk"
    filename = self.write_src('#include <%s>\nint main(int argc, char** argv) { return 0; }' % name, basename)
    try:
      self.compile_static_main([filename])
      print "#include <%s>" % name
      return True
    except ExecutionError:
      print "NO HEADER <%s>" % name
      return False

  ########

  def get_type_size(self, typedef, header=''):
    if header:
      header = '#include <%s>' % header

    if typedef[:7] != 'typedef':
      t = 'typedef %s t;' % typedef
    else:
      t = typedef

    filename = "tmp" + os.sep + "type_size"
    self.write_src("""
#include <stddef.h>
#include <stdio.h>
%s

%s

int main(int argc, char** argv) {
  printf("%%d\\n",(int)sizeof(t));
  return 0;
}
""" % (header, t), filename)

    try:
      lines = self.run_static_program(filename)
    except ExecutionError:
      return None

    size = int(lines[0])
    return size


  def get_type_align(self, typedef, header=''):
    """the typedef defines alias 't' for the type"""
    if header:
      header = '#include <%s>' % header

    if typedef[:7] != 'typedef':
      t = 'typedef %s t;' % typedef
    else:
      t = typedef

    filename = "tmp" + os.sep + "type_align"
    self.write_src("""
#include <stddef.h>
#include <stdio.h>
%s

%s

struct TEST {
  char c;
  t mem;
};

int main(int argc, char** argv) {
  printf("%%d\\n",(int)offsetof(struct TEST,mem));
  return 0;
}
""" % (header, t), filename)

    try:
      lines = self.run_static_program(filename)
    except ExecutionError:
      return None

    align = int(lines[0])
    print '%s: align: %s' % (typedef, align)
    return align


  def get_type_size_sign(self, typedef1, typedef2=None, header=''):
    if header:
      header = '#include <%s>' % header

    if typedef2 is None:
      typedef2 = typedef1
      expr1 = '(t1)0'
      expr2 = '(t1)~3 < ' + expr1
    else:
      expr1 = '(t1)0 + (t2)0'
      expr2 = '(t1)~3 + (t2)1 < ' + expr1

    filename = "tmp" + os.sep + "type_size_sign"
    self.write_src("""
#include <stddef.h>
#include <stdio.h>
%s

typedef %s t1;
typedef %s t2;

int main(int argc, char** argv) {
  printf("%%d\\n",(int)sizeof(%s));
  printf("%%d\\n", %s);

  return 0;
}
""" % (header, typedef1, typedef2, expr1, expr2), filename)

    try:
      lines = self.run_static_program(filename)
    except ExecutionError:
      return None, None
    size = int(lines[0])
    sign = int(lines[1])
    if typedef1 == typedef2:
      print '(%s)0: sign: %s' % (typedef1, sign)
    else:
      print '(%s)0 + (%s)0: sign: %s' % (typedef1, typedef2, sign)

    return size, sign

  ########

  native_int_types = [ \
      ('SCHAR', 'signed char'),
      ('UCHAR', 'unsigned char'),
      ('CHAR', 'char'),
      ('SHORT', 'short'),
      ('USHORT', 'unsigned short'),
      ('INT', 'int'),
      ('UINT', 'unsigned int'),
      ('LONG', 'long'),
      ('ULONG', 'unsigned long'),
      ('LONGLONG', 'long long'),
      ('ULONGLONG', 'unsigned long long'),
      ('BOOL', 'bool'),
      ]


  def detect_type_data(self, m, t, header=''):
    size = self.get_type_size(t, header)

    opt = self.options

    if size is None:
      if header:
        print "NO TYPE %s in <%s>" % (t, header)
      else:
        print "NO TYPE %s" % t

      opt.__dict__['HAVE_' + m] = False
    else:
      print '%s: size: %s' % (t, size)

      align = self.get_type_align(t, header)

      opt.__dict__['HAVE_' + m] = True
      opt.__dict__['SIZEOF_' + m] = size
      opt.__dict__['ALIGNOF_' + m] = align


  def detect_int_data(self):
    opt = self.options

    # find if we have stdint.h
    opt.HAVE_STDINT = self.check_header_exists("stdint.h")

    opt.sizesign2type = {}

    for m, t in self.native_int_types:
      self.detect_type_data(m, t)
      sizesign = self.get_type_size_sign(t)

      opt.sizesign2type[sizesign] = opt.sizesign2type.get(sizesign, t)


  def find_alias(self, t1, t2=None, header=''):
    size, sign = self.get_type_size_sign(t1, t2, header)
    if size is None:
      return None
    return self.options.sizesign2type[size, sign]


  def detect_aliases(self):
    opt = self.options
    opt.arith_conv = {}

    for m1, t1 in self.native_int_types:
      for m2, t2 in self.native_int_types:
        alias = self.find_alias(t1, t2)
        if alias is not None:
          opt.arith_conv[(t1, t2)] = alias

    for t in ['ptrdiff_t', 'size_t']:
      alias = self.find_alias(t)
      if alias:
        opt.__dict__['ALIAS_' + t] = alias

    if opt.HAVE_STDINT:
      for t in [
        'int8_t', 'uint8_t',
        'int16_t', 'uint16_t',
        'int32_t', 'uint32_t',
        'int64_t', 'uint64_t',
        'intmax_t', 'uintmax_t',
        'intptr_t', 'uintptr_t',
        ]:
        alias = self.find_alias(t, header='stdint.h')
        if alias:
          opt.__dict__['ALIAS_' + t] = alias

    if not getattr(opt,"ALIAS_int8",None):
      opt.ALIAS_int8_t="signed char"

    if not getattr(opt,"ALIAS_uint8",None):
      opt.ALIAS_uint8_t="unsigned char"

    sizes = {
      opt.SIZEOF_SHORT*8 : "short",
      opt.SIZEOF_INT*8: "int",
      opt.SIZEOF_LONG*8 : "long",
    }

    if opt.HAVE_LONGLONG:
      sizes[opt.SIZEOF_LONGLONG*8]="long long"

    if not getattr(opt,"ALIAS_intmax_t",None):
      opt.ALIAS_intmax_t="long"
      opt.ALIAS_uintmax_t="unsigned long"
      if opt.HAVE_LONGLONG:
        opt.ALIAS_intmax_t="long long"
        opt.ALIAS_uintmax_t="unsigned long long"

    for size in [16,32,64]:
      if not getattr(opt,"ALIAS_int"+str(size)+"_t",None):
        try:
          t = sizes[size]
          opt.__dict__["ALIAS_int"+str(size)+"_t"]=t
          opt.__dict__["ALIAS_uint"+str(size)+"_t"]="unsigned " + t
        except KeyError:
          opt.__dict__["ALIAS_int"+str(size)+"_t"]="emul_int"+str(size)
          opt.__dict__["ALIAS_uint"+str(size)+"_t"]="emul_uint"+str(size)

    if not getattr(opt,"ALIAS_intptr_t",None):
      try:
        opt.ALIAS_intptr_t=sizes[opt.SIZEOF_VOIDP*8]
        opt.ALIAS_uintptr_t="unsigned "+sizes[opt.SIZEOF_VOIDP*8]
      except:
        print "NO INTEGER THE SIZE OF A VOID*!"
        sys.exit(1)

  def detect_c_type_data(self):
    self.detect_int_data()

    std_dtypes = [
      ('BOOL', 'bool', ''),
      ('FLOAT', 'float', ''),
      ('DOUBLE', 'double', ''),
      ('LONGDOUBLE', 'long double', ''),
      ('ENUM', 'typedef enum enum_t {tag} t;', ''),
      ('VOIDP', 'void *', ''),
      ('FUNCP', 'typedef void (*t)(void);', ''),
      ('CBOOL', '_Bool', ''),
      ('WCHAR', 'wchar_t', 'stddef.h'),
      ('PTRDIFF', 'ptrdiff_t', 'stddef.h'),
      ('INTPTR', 'intptr_t', 'stdint.h'),
      ('UINTPTR', 'uintptr_t', 'stdint.h'),
      ('INTMAX', 'intmax_t', 'stdint.h'),
      ('UINTMAX', 'uintmax_t', 'stdint.h'),
      ('SIZE', 'size_t', 'stddef.h'),
      ('COMPLEX', 'float _Complex', ''),
      ('DOUBLECOMPLEX', 'double _Complex', ''),
      ('LONGDOUBLECOMPLEX', 'long double _Complex', ''),
      ('IMAGINARY', 'float _Imaginary', ''),
      ('DOUBLEIMAGINARY', 'double _Imaginary', ''),
      ('LONGDOUBLEIMAGINARY', 'long double _Imaginary', ''),
      ('INT8', 'int8_t', 'stdint.h'),
      ('INT16', 'int16_t', 'stdint.h'),
      ('INT32', 'int32_t', 'stdint.h'),
      ('INT64', 'int64_t', 'stdint.h'),
      ('UINT8', 'uint8_t', 'stdint.h'),
      ('UINT16', 'uint16_t', 'stdint.h'),
      ('UINT32', 'uint32_t', 'stdint.h'),
      ('UINT64', 'uint64_t', 'stdint.h'),
    ]

    for m, t, f in std_dtypes:
      self.detect_type_data(m, t, header=f)

    self.detect_aliases()

    opt = self.options


  def detect_win32(self):
    return self.check_macro_defined("_WIN32")

  def detect_win64(self):
    return self.check_macro_defined("_WIN64")

  def detect_posix(self):
    if self.check_macro_defined("_WIN32"):
      return False
    else:
      return True

  def detect_cygwin(self):
    return self.check_macro_defined("__CYGWIN__")

  def detect_osx(self):
    return self.check_macro_defined("__APPLE__")

  def detect_osx_version(self):
    if not self.options.MACOSX:
      return None
    else:
      # query gestalt to determine os version
      try:
        from gestalt import gestalt
        import MacOS
      except ImportError:
        return None

      try:
        sysv = gestalt('sysv')
      except (RuntimeError, MacOS.Error):
        return None

      major = (sysv & 0xff00) >> 8
      minor = (sysv & 0x00f0) >> 4
      patch = (sysv & 0x000f)

      # convert into decimal
      major = int(hex(major)[2:])

      version = major*100 + minor*10 + patch

      print 'MACOSX VERSION:', version

      return version

  def detect_bsd(self):
    return self.check_macro_defined("BSD")

  def detect_solaris(self):
    # can't find a symbol for solaris...
    # return self.check_macro_defined("__SOLARIS__")
    try:
      # print SunOS on solaris
      return self.shell("uname", verbose=False) == 'SunOS\n'
    except ExecutionError:
      return False

  def detect_linux(self):
    return self.check_macro_defined("__linux__")

  # only allows 4 models: cygwin, osx, win32 and posix
  # nocygwin = mingw = win32
  def detect_model(self):
    opt = self.options

    # check that we can use the compiler
    self.compile_dummy_main()

    opt.MACOSX = self.detect_osx()
    opt.MACOSX_VERSION = self.detect_osx_version()
    opt.BSD = self.detect_bsd()
    opt.SOLARIS = self.detect_solaris()
    opt.LINUX= self.detect_linux()
    opt.WIN32 = self.detect_win32()
    opt.WIN64 = self.detect_win64()
    opt.CYGWIN = self.detect_cygwin()
    opt.POSIX = self.detect_posix()

    sum = opt.MACOSX + opt.WIN32 + opt.CYGWIN
    if sum > 1:
      print "INCOMPATIBLE MODELS DETECTED"
      print "MACOSX",opt.MACOSX
      print "CYGWIN",opt.CYGWIN
      print "WIN32",opt.WIN32
    else:
     if opt.model == "detect":
       if opt.CYGWIN: opt.model = "cygwin"
       if opt.MACOSX: opt.model = "osx"
       if opt.WIN32: opt.model = "win32"
       if opt.WIN64: opt.model = "win64"
       if opt.SOLARIS: opt.model = "solaris"
       if opt.LINUX: opt.model = "linux"
       if opt.BSD: opt.model = "bsd"
       if opt.model == "detect": opt.model = "posix"
    if opt.model in ["mingw", "nocygwin"]: opt.model = "win32"
    if opt.model in ["posix"] and opt.CYGWIN: opt.model = "cygwin"

    if opt.model not in ["posix", "linux", "solaris", "bsd", "osx", "cygwin", "win32", "win64"]:
      print "UNKNOWN MODEL", opt.model
      sys.exit(1)

    print "MODEL=", self.options.model

  ########

  def detect_intsizes(self):
    """find misc info about endianess"""

    opt = self.options

    filename = "tmp" + os.sep + "intsizes"

    try:
      output = self.run_static_string_program(r"""
#include <stdio.h>
#include <stddef.h>

enum enum_t {e_tag};
typedef void (*fp_t)(void);

union endian_t {
  unsigned long x;
  unsigned char y[sizeof(unsigned long)];
} endian;

int main(int argc, char** argv) {
  printf("CHAR_IS_UNSIGNED=%d\n",((char)0xFF)>0?1:0);
  endian.x = 1ul;
  printf("LITTLE_ENDIAN=%d\n", endian.y[0]);
  printf("BIG_ENDIAN=%d\n", endian.y[sizeof(unsigned long)-1]);

  return 0;
}
""", filename)
    except ExecutionError:
      print "FATAL: can't determine sizes of ints"
      raise
    ## THIS CALL CANNOT USE THE SHELL BECAUSE IT REDIRECTS OUTPUT
    os.system("tmp"+os.sep+"intsizes > tmp"+os.sep+"intsizes.py")
    f = open("tmp"+os.sep+"intsizes.py")
    try:
      exec f in opt.__dict__
    finally:
      f.close()
    # RF (zzz): getting \r\n output from target/xcompile stage,
    # under nocygwin which is confusing 'exec' which flags them
    # as syntax errors. re-enabling the old code (not sure why it was
    # changed as it sure as hell weren't broke).

    # exec string.join(output, '\n') in opt.__dict__

    if opt.CHAR_IS_UNSIGNED:
      print "char is unsigned"
    else:
      print "char is signed"

    if opt.BIG_ENDIAN: print "Big Endian byte order detected"
    if opt.LITTLE_ENDIAN: print "Little Endian byte order detected"


  def detect_alignment(self):
    #calculate alignment tables
    vbls = [
      ("ALIGNOF_CBOOL","_Bool"),
      ("ALIGNOF_BOOL","bool"),
      ("ALIGNOF_SHORT","short"),
      ("ALIGNOF_INT","int"),
      ("ALIGNOF_LONG","long"),
      ("ALIGNOF_LONGLONG","long long"),

      ("ALIGNOF_FLOAT","float"),
      ("ALIGNOF_DOUBLE","double"),
      ("ALIGNOF_LONGDOUBLE","long double"),

      ("ALIGNOF_WCHAR","wchar_t"),
      ("ALIGNOF_VOIDP","void*"),
      ]

    opt = self.options

    opt.MAX_ALIGN = 1
    opt.flx_aligns = {}
    for k, t in vbls:
      try:
        v = opt.__dict__[k]
        opt.flx_aligns[v]=t
      except KeyError:
        pass
      else:
        if v > opt.MAX_ALIGN:
          opt.MAX_ALIGN = v
    opt.flx_aligns[1] = "char"


  def detect_isnan(self):
    # find if we have C99 isnan in <math.h>
    try:
      self.build_string_program(r"""
#include <math.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isnan(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_C99_ISNAN_IN_MATH = True
      print "C99 isnan found in <math.h>"
    except ExecutionError:
      self.options.HAVE_C99_ISNAN_IN_MATH = False

    # find if we have BSD isnanf in <math.h> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <math.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isnanf(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_BSD_ISNAN_IN_MATH = True
      print "Isnan found in <math.h>"
    except ExecutionError:
      self.options.HAVE_BSD_ISNAN_IN_MATH = False

    # find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <ieeefp.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isnanf(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_ieeefp')
      self.options.HAVE_BSD_ISNAN_IN_IEEEFP = True
      print "Isnan found in <ieeefp.h>"
    except ExecutionError:
      self.options.HAVE_BSD_ISNAN_IN_IEEEFP = False

    # find if we have C99 isinf in <math.h>
    try:
      self.build_string_program(r"""
#include <math.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isinf(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_C99_ISINF_IN_MATH = True
      print "C99 isnan found in <math.h>"
    except ExecutionError:
      self.options.HAVE_C99_ISINF_IN_MATH = False

    # find if we have BSD isinff in <math.h> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <math.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isinff(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_BSD_ISINF_IN_MATH = True
      print "BSD isinf found in <math.h>"
    except ExecutionError:
      self.options.HAVE_BSD_ISINF_IN_MATH = False

    # find if we have BSD isinff in <ieeefp.h> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <ieeefp.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isinff(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_ieeefp')
      self.options.HAVE_BSD_ISINF_IN_IEEEFP = True
      print "BSD isinf found in <ieeefp.h>"
    except ExecutionError:
      self.options.HAVE_BSD_ISINF_IN_IEEEFP = False

    # find if we have C99 isfinite in <math.h>
    try:
      self.build_string_program(r"""
#include <math.h>

int main(int argc,char** argv) {
  float f = 0.0;
  isfinite(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_C99_ISFINITE_IN_MATH = True
      print "C99 isfinite found in <math.h>"
    except ExecutionError:
      self.options.HAVE_C99_ISFINITE_IN_MATH = False

    # find if we have BSD finitef in <math.h> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <math.h>

int main(int argc,char** argv) {
  float f = 0.0;
  finitef(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_BSD_FINITE_IN_MATH = True
      print "BSD finitef found in <math.h>"
    except ExecutionError:
      self.options.HAVE_BSD_FINITE_IN_MATH = False

    # find if we have BSD isfinitef in <ieeefp.h> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <ieeefp.h>

int main(int argc,char** argv) {
  float f = 0.0;
  finitef(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_ieeefp')
      self.options.HAVE_BSD_FINITE_IN_IEEEFP = True
      print "BSD finitef found in <ieeefp.h>"
    except ExecutionError:
      self.options.HAVE_BSD_FINITE_IN_IEEEFP = False


  def detect_vsnprintf(self):
    opt = self.options

    filename = self.write_src(r"""
#include <stdio.h>
#include <stdarg.h>

int check(char const*fmt,...)
{
  va_list ap;
  va_start(ap,fmt);
  int n = vsnprintf(NULL,0,fmt,ap);
  va_end(ap);
  return n!=3;
}

int main(int argc,char** argv) {
  return check("%s","XXX"); // 0 means pass
}
""", 'tmp' + os.sep + 'vsnprintf')

    try:
      lines = self.run_static_program(filename)
    except ExecutionError:
      opt.HAVE_VSNPRINTF = False
    else:
      opt.HAVE_VSNPRINTF = True

    if opt.HAVE_VSNPRINTF:
      print "vsnprintf() supported"
    else:
      print "vsnprintf() NOT supported"

  ########

  def detect_compiler_options(self):
    pass

  def check_options(self):
    self.detect_model()

    self.detect_compiler_options()

    self.detect_intsizes()
    self.detect_c_type_data()
    self.detect_alignment()
    self.detect_isnan()
    self.detect_vsnprintf()

    # would like to know if we have SDL_opengl. that's done by compiling
    # and running sdl_opengl.cxx Needs can be compiled like
    # g++ `sdl-config --cflags` sdl_opengl.cxx `sdl-config --libs`
    # but how is that done portably? Does win32 even have sdl-config?


  def report_config(self):
    opt = self.options
    print "**********************************************"
    print opt.COM, opt.use, "configuration"
    print "**********************************************"
    print "model=", opt.model
    print "static library tool #1                  : " + opt.AR
    print "static library tool #2                  : " + opt.RANLIB
    print
    print "Command to compile static Felix rtl     : " + opt.CCOBJ_STATIC_RTL
    print "Command to compile shared Felix rtl     : " + opt.CCOBJ_DYNAMIC_RTL
    print "Command to link shared Felix rtl        : " + opt.CCLINK_DYNAMIC_RTL
    print
    print "Command to compile static Felix driver  : " + opt.CCOBJ_STATIC_MAIN
    print "Command to compile dynamic Felix driver : " + opt.CCOBJ_DYNAMIC_MAIN
    print "Command to link dynamic Felix driver    : " + opt.CCLINK_DYNAMIC_MAIN
    print
    print "Command to compile static Felix object  : " + opt.CCOBJ_STATIC_FLX
    print "Command to compile loadable Felix object: " + opt.CCOBJ_DYNAMIC_FLX
    print "Command to link loadable Felix object   : " + opt.CCLINK_DYNAMIC_FLX
    print
    print "Extension for static object file        : " + opt.EXT_STATIC_OBJ
    print "Extension for shared object file        : " + opt.EXT_SHARED_OBJ
    print "Extension for static archive            : " + opt.EXT_LIB
    print "Extension for loadable RTL              : " + opt.EXT_DYLIB
    print "Extension for flx modules               : " + opt.EXT_SHLIB
    print "Extension for executable                : " + opt.EXT_EXE
    print "RTL in directory                        : " + opt.SHLIB_DIR

    print
    self.report_isnan()

@h = tangler("flxbuild/c_base.py")
@select (h)
import os

from flxbuild.c_cxx_base import c_cxx_base

class c_base(c_cxx_base):
  def __init__(self, *args, **kwds):
    super(c_base, self).__init__(*args, **kwds)

    self.options.EXT_SRC_MAIN = ".c"
    self.options.EXT_SRC_LIB = ".c"

  def report_isnan(self):
    opt = self.options

    if opt.HAVE_C99_ISNAN_IN_MATH:
      print "C99 NaN Support in                      : <math.h>"
    elif opt.HAVE_BSD_ISNAN_IN_MATH:
      print "BSD NaN Support in                      : <math.h>"
    elif opt.HAVE_BSD_ISNAN_IN_IEEEFP:
      print "BSD NaN Support in                      : <ieeefp.h>"
    else:
      print "NaN                                     : EMULATED"

    if opt.HAVE_C99_ISINF_IN_MATH:
      print "C99 INF Support in                      : <math.h>"
    elif opt.HAVE_BSD_ISINF_IN_MATH:
      print "BSD INF Support in                      : <math.h>"
    elif opt.HAVE_BSD_ISINF_IN_IEEEFP:
      print "BSD INF Support in                      : <ieeefp.h>"
    else:
      print "INF                                     : EMULATED"

@h = tangler("flxbuild/cxx_base.py")
@select (h)
import os

from flxbuild.c_cxx_base import c_cxx_base

class cxx_base(c_cxx_base):
  def __init__(self, *args, **kwds):
    super(cxx_base, self).__init__(*args, **kwds)

    self.options.EXT_SRC_MAIN = ".cxx"
    self.options.EXT_SRC_LIB = ".cpp"


  def detect_static_initialization(self):
    # find if we have static const init in class
    # [not so much an extension as a bug if we don't]
    try:
      self.build_string_program(r"""
struct X {
  static const int i = 1;
};

int main(int argc, char** argv) {
  return 0;
}
""", 'tmp' + os.sep + 'check_inclass')
      self.options.HAVE_INCLASS_MEMBER_INITIALIZATION = True
      print "Inclass member initialisation supported"
    except ExecutionError:
      self.options.HAVE_INCLASS_MEMBER_INITIALIZATION = False
      print "Inclass member initialisation NOT supported"


  def detect_cmath_isnan(self):
    # find if we have BSD isnan in <cmath> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <cmath>

int main(int argc, char** argv) {
  float f = 0.0;
  std::isnan(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_cmath')
      self.options.HAVE_CXX_ISNAN_IN_CMATH = True
      print "C++ isnan found in <cmath>"
    except ExecutionError:
      self.options.HAVE_CXX_ISNAN_IN_CMATH = False

    # find if we have BSD isinf in <cmath> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <cmath>

int main(int argc, char** argv) {
  float f = 0.0;
  std::isinf(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_cmath')
      self.options.HAVE_CXX_ISINF_IN_CMATH = True
      print "C++ isinf found in <cmath>"
    except ExecutionError:
      self.options.HAVE_CXX_ISINF_IN_CMATH = False

    # find if we have BSD isinf in <cmath> (NAUGHTY!)
    try:
      self.build_string_program(r"""
#include <cmath>

int main(int argc, char** argv) {
  float f = 0.0;
  std::isfinite(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_cmath')
      self.options.HAVE_CXX_ISFINITE_IN_CMATH = True
      print "C++ isfinite found in <cmath>"
    except ExecutionError:
      self.options.HAVE_CXX_ISFINITE_IN_CMATH = False



  def check_options(self):
    super(cxx_base, self).check_options()

    self.detect_static_initialization()
    self.detect_cmath_isnan()

  def report_isnan(self):
    opt = self.options

    if opt.HAVE_CXX_ISNAN_IN_CMATH:
      print "C++ isnan Support in                        : <cmath>"
    else:
      print "C++ isnan                                   : EMULATED"

    if opt.HAVE_CXX_ISINF_IN_CMATH:
      print "C++ isinf Support in                        : <cmath>"
    elif opt.HAVE_CXX_ISFINITE_IN_CMATH:
      print "C++ isfinite Support in                     : <cmath>"
    else:
      print "C++ isinf                                   : EMULATED"

@h = tangler("flxbuild/gnu_mixin.py")
@select(h)
import os
import sys
import flxbuild
from flxbuild.flxutil import ExecutionError

from flxbuild.c_cxx_base import c_cxx_base

class gnu_mixin(object):
  DEFAULT_AR = 'ar -rc'
  DEFAULT_RANLIB = 'ranlib'

  def set_options(self, STRIP="strip", **kwds):
    """these options are model dependent and have to
    be supplied by the client"""

    super(gnu_mixin, self).set_options(**kwds)

    opt = self.options
    opt.STRIP = STRIP + " "

    self.lang = opt.COM

    if opt.model == "nocygwin":
      opt.COM = opt.COM + "-mno-cygwin "
      opt.EXT_STATIC_OBJ = "_static.obj" # temporary hack
      opt.EXT_SHARED_OBJ = "_dynamic.obj" # temporary hack

  ########

  def detect_model(self):
    opt = self.options

    # default options
    opt.EXT_STATIC_OBJ = "_static.o"
    opt.EXT_SHARED_OBJ = "_dynamic.o"
    opt.EXT_LIB = ".a"
    opt.EXT_EXE = ""
    opt.EXT_SHLIB = ".so"
    opt.EXT_DYLIB = ".so"
    opt.SHLIB_DIR = os.path.join("lib", "rtl")

    opt.SPEC_COMPILE_OBJ = "-c "
    opt.SPEC_OBJ_FILENAME = "-o "
    opt.SPEC_EXE_FILENAME = "-o "
    opt.SPEC_DEFINE = "-D"
    opt.SPEC_INCLUDE = "-I"
    opt.SPEC_LIBPATH = "-L"
    opt.SPEC_LIB = "-l"
    opt.SPEC_AR_OUT_FILENAME = ""
    opt.DEBUG_FLAGS = "-g "
    #opt.OPTIMISE = "-O3 -fomit-frame-pointer --inline -DNDEBUG "
    opt.OPTIMISE = "-O3 -fomit-frame-pointer --inline "

    # RF: a hack to make the VS build work. sort of an "any last words"
    # argument/hook before link directives.
    opt.PRE_LINK_FLAGS = ""

    super(gnu_mixin, self).detect_model()

    if opt.model in ["cygwin", "win32", "win64"]:
      opt.EXT_EXE = ".exe"
      opt.EXT_SHLIB = ".dll"
      opt.EXT_DYLIB = opt.EXT_SHLIB
      opt.SHLIB_DIR = "bin"

    if opt.model in ["win32", "win64"]:
      opt.EXT_STATIC_OBJ = "_static.obj"
      opt.EXT_SHARED_OBJ = "_dynamic.obj"

    if opt.model == "osx":
      # flags for rtl & flx executable compilation & linking taken from
      # http://fink.sourceforge.net/doc/porting/shared.php with many thanks

      # differentiated now because osx treats dylibs
      # and plugin-type libraries.
      opt.EXT_DYLIB = ".dylib"
      opt.PIC = "" # darwin code is by default position independent


  def detect_warning_flags(self):
    opt = self.options

    # find if we have g++ with -Wno-invalid-offsetof
    #
    # NOTE: this is a hack .. Felix makes offsetof() errors
    # We HAVE to detect if the switch turn them off is available
    # first, and if not use -w, otherwise we use -Wall -Wno-offsetof,
    # because these errors must be tolderated in Felix generated C++
    #
    # But the error can't occur in C, and specifying the option
    # causes gcc to barf with a warning
    #
    if self.lang == "g++ ":
      try:
        self.compile_dummy_main(CFLAGS="-Wno-invalid-offsetof")
        opt.NO_INVALID_OFFSETOF_WARNING = "-Wall -Wno-invalid-offsetof "
        print "-Wno-invalid-offsetof supported"
      except ExecutionError:
        opt.NO_INVALID_OFFSETOF_WARNING = "-w "
    else:
      opt.NO_INVALID_OFFSETOF_WARNING = "-Wall "

    # find if we have g++ with -Wfatal-errors
    try:
      self.compile_dummy_main(CFLAGS="-Wfatal-errors")
      opt.NO_INVALID_OFFSETOF_WARNING = opt.NO_INVALID_OFFSETOF_WARNING + "-Wfatal-errors "
      print "-Wfatal-errors supported"
    except ExecutionError:
      pass

  ########

  def detect_gcc_builtin_expect(self):
    opt = self.options

    filename = self.write_src(r"""
int main(int argc, char** argv) {
   if(__builtin_expect(1,1));
   return 0;
}
""", 'tmp' + os.sep + 'gnu_builtin')

    try:
      self.build_static_program(filename)
      opt.HAVE_GNU_BUILTIN_EXPECT= True
      print "gcc __builtin_expect() support detected"
    except ExecutionError:
      opt.HAVE_GNU_BUILTIN_EXPECT= False

  def detect_named_registers(self):
    opt = self.options

    filename = self.write_src(r"""
#include <stdio.h>
register void *sp __asm__ ("esp");

int main(int argc, char** argv) {
   printf("Sp = %p\n",sp);
   return 0;
}
""", 'tmp' + os.sep + 'gnu_x86')

    # find if we have gnu on 32 bit x86 platform with named registers
    try:
      self.build_static_program(filename)
      opt.HAVE_GNU_X86 = True
      print "gnu x86 32 bit support detected"
    except ExecutionError:
      opt.HAVE_GNU_X86 = False

    filename = self.write_src(r"""
#include <stdio.h>
register void *sp __asm__ ("rsp");

int main(int argc, char** argv) {
   printf("Sp = %p\n",sp);
   return 0;
}
""", 'tmp' + os.sep + 'gnu_x86_64')

    # find if we have gnu on 64 bit x86 platform with named registers
    try:
      self.build_static_program(filename)
      opt.HAVE_GNU_X86_64 = True
      print "gnu x86 64 bit support detected"
    except ExecutionError:
      opt.HAVE_GNU_X86_64 = False

    # X86_64 dominates X86
    if opt.HAVE_GNU_X86 and opt.HAVE_GNU_X86_64:
      opt.HAVE_GNU_X86 = False

    if opt.HAVE_GNU_X86:
      opt.USE_REGPARM3 = True
      print "regparm3 supported"
    else:
      opt.USE_REGPARM3 = False


  def detect_computed_gotos(self):
    opt = self.options

    filename = self.write_src("""
int main(int argc, char** argv) {
  void *label = &&label2;
  goto *label;
  label1:
    return 1;
  label2:
    return 0;
}
""", 'tmp' + os.sep + 'cgoto')


    # find if we have g++ supporting computed jumps
    try:
      self.build_static_program(filename)
      opt.HAVE_CGOTO = True
      print "Computed goto supported"
    except ExecutionError:
      opt.HAVE_CGOTO = False

    filename = self.write_src("""
int main(int argc, char** argv) {
  void *label = &&label2;
  __asm__(".global fred");
  __asm__("fred:");
  __asm__(""::"g"(&&label1));
  goto *label;
  label1:
    return 1;
  label2:
    return 0;
}
""", 'tmp' + os.sep + 'asm_labels')

    # find if we have g++ supporting computed jumps and asm labels
    try:
      self.build_static_program(filename)
      opt.HAVE_ASM_LABELS = True
      print "Asm labels supported"
    except ExecutionError:
      opt.HAVE_ASM_LABELS = False


  def detect_openmp(self):
    # find if we can use -fopenmp without a warning
    try:
      self.compile_dummy_main(CFLAGS="-Werror -fopenmp")
      self.options.openmp= "-fopenmp "
      print "OpenMP based parallel programming supported"
      self.options.HAVE_OPENMP = True
    except ExecutionError:
      self.options.openmp = ""
      self.options.HAVE_OPENMP = False
      print "OpenMP based parallel programming not supported"


  def detect_PIC(self):
    # find if we can use -fPIC without a warning
    # if a warning is generated it will say something like
    # 'all code is relocatable on this platform'
    # so we make that into an error, detect it, and say -fPIC only
    # if it would not generate this warning
    try:
      self.compile_dummy_main(CFLAGS="-Werror -fPIC")
      self.options.PIC = "-fPIC "
      print "-fPIC supported"
    except ExecutionError:
      self.options.PIC = ""
      print "All code is position independent"


  def construct_compiler_commands(self):
    opt = self.options

    if opt.model == "osx":
      #COMPILE_DYNAMIC_RTL = opt.PIC + "-bundle -c "
      COMPILE_DYNAMIC_RTL = opt.PIC + opt.SPEC_COMPILE_OBJ + "-fno-common "
      # make a dynamic library (not loadable via APIs like dlcompat)
      LINK_DYNAMIC_RTL = "-dynamiclib "

      COMPILE_DYNAMIC_MAIN = opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_MAIN = ""

      COMPILE_DYNAMIC_FLX = opt.PIC + "-bundle -c " "-fno-common "
      LINK_DYNAMIC_FLX = "-bundle "
    else:
      COMPILE_DYNAMIC_RTL = opt.PIC + opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_RTL = "-shared "

      COMPILE_DYNAMIC_MAIN = opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_MAIN = " "

      COMPILE_DYNAMIC_FLX = opt.PIC + opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_FLX = "-shared "

    COM = opt.COM

    if opt.openmp:
      COM = COM + opt.openmp

    opt.CCOBJ_DYNAMIC_FLX = COM + COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = COM + LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = COM + COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = COM + LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = COM + COMPILE_DYNAMIC_MAIN
    opt.CCLINK_DYNAMIC_MAIN = COM + LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = COM + opt.SPEC_COMPILE_OBJ
    opt.CCOBJ_STATIC_RTL = COM + opt.SPEC_COMPILE_OBJ
    opt.CCOBJ_STATIC_MAIN = COM + opt.SPEC_COMPILE_OBJ

    opt.CCOBJ_DYNAMIC_RTL = opt.CCOBJ_DYNAMIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_DYNAMIC_FLX = opt.CCOBJ_DYNAMIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING

    opt.CCOBJ_STATIC_RTL = opt.CCOBJ_STATIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX = opt.CCOBJ_STATIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING

    opt.CCLINK_STATIC = COM


  def detect_pthreads(self):
    opt = self.options

    # Note that this pthread fragment actually tests the return value
    # as incorrectly compiled threaded code on solaris links and runs,
    # but returns errors.
    filename = self.write_src("""
#include <pthread.h>

void* start(void* data)
{
  return NULL;
}

int main(int argc, char** argv) {
  pthread_t thr;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  int res = pthread_create(&thr, &attr, start, NULL);
  pthread_attr_destroy(&attr);
  return res;
}
""", 'tmp' + os.sep + 'pthreads')

    # find out how to do pthreads
    opt.HAVE_PTHREADS = False
    opt.PTHREAD_SWITCH = None
    for switch in [' ', '-lpthread ', '-pthread ', '-pthreads ']:
      try:
        lines = self.run_static_program(filename, LDFLAGS=switch)
      except ExecutionError:
        pass
      else:
        opt.HAVE_PTHREADS = True
        opt.PTHREAD_SWITCH = switch
        break

    if opt.HAVE_PTHREADS:
      print "Posix Threads supported with", opt.PTHREAD_SWITCH
    else:
      print "Posix Threads not supported"


  def detect_mmap(self):
    opt = self.options

    opt.HAVE_MMAP = self.check_macro_defined('sys/mman.h')

    if not opt.HAVE_MMAP:
      print "mmap not supported"
      return

    print "mmap supported"

    opt.HAVE_MMAP_PROT_EXEC    = self.check_macro_defined('PROT_EXEC',        'sys/mman.h')
    opt.HAVE_MMAP_PROT_READ    = self.check_macro_defined('PROT_READ',        'sys/mman.h')
    opt.HAVE_MMAP_PROT_WRITE   = self.check_macro_defined('PROT_WRITE',       'sys/mman.h')
    opt.HAVE_MMAP_DENYWRITE    = self.check_macro_defined('MAP_DENYWRITE',    'sys/mman.h')
    opt.HAVE_MMAP_ANONYMOUS    = self.check_macro_defined('MAP_ANON',         'sys/mman.h')
    opt.HAVE_MMAP_FILE         = self.check_macro_defined('MAP_FILE',         'sys/mman.h')
    opt.HAVE_MMAP_FIXED        = self.check_macro_defined('MAP_FIXED',        'sys/mman.h')
    opt.HAVE_MMAP_HASSEMAPHORE = self.check_macro_defined('MAP_HASSEMAPHORE', 'sys/mman.h')
    opt.HAVE_MMAP_SHARED       = self.check_macro_defined('MAP_SHARED',       'sys/mman.h')
    opt.HAVE_MMAP_PRIVATE      = self.check_macro_defined('MAP_PRIVATE',      'sys/mman.h')
    opt.HAVE_MMAP_NORESERVE    = self.check_macro_defined('MAP_NORESERVE',    'sys/mman.h')
    opt.HAVE_MMAP_LOCKED       = self.check_macro_defined('MAP_LOCKED',       'sys/mman.h')
    opt.HAVE_MMAP_GROWSDOWN    = self.check_macro_defined('MAP_GROWSDOWN',    'sys/mman.h')
    opt.HAVE_MMAP_32BIT        = self.check_macro_defined('MAP_32BIT',        'sys/mman.h')
    opt.HAVE_MMAP_POPULATE     = self.check_macro_defined('MAP_POPULATE',     'sys/mman.h')
    opt.HAVE_MMAP_NONBLOCK     = self.check_macro_defined('MAP_NONBLOCK',     'sys/mman.h')

    try:
      output = self.run_static_string_program("""
#include <sys/mman.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>

int main(int argc, char** argv)
{
   size_t n = 10000;
   int fd;
   fd = open("/dev/zero", O_RDWR);
   if (fd == -1) {
     return 1;
   }
   void *data =
       mmap
       (
          NULL,n,
          PROT_WRITE | PROT_READ,
          MAP_PRIVATE,
          fd,0
       )
    ;
   if (data == MAP_FAILED)
   {
      return 1;
   }
   int res = munmap(data,n);
   if (res != 0)
   {
      return 1;
   }
   return 0;
}
""", 'tmp'+os.sep+'mmap')
    except ExecutionError:
      pass
    else:
      opt.HAVE_MMAP_DEV_ZERO = True


  def detect_win_dynamic_loading(self):
    opt = self.options

    # check if can get LoadLibrary to work
    basename = 'tmp' + os.sep + 'win32_dummy_lib'
    # RF: This can be compiled as both c and c++ these days it seems
    # hence conditional extern "C"
    dummy_lib_filename = self.write_lib_src("""
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllexport) int fred(int argc,char** argv) { return 0; }
""", basename)

    basename = 'tmp' + os.sep + 'win32_dummy_main'
    dummy_main_filename = self.write_src("""
#include <windows.h>
#include <stdlib.h>

int main(int argc,char** argv) {
   HMODULE lib = LoadLibrary(argv[1]);
   void *fred;
   if(!lib) exit(1);
   fred = (void*)GetProcAddress(lib,"fred");
   if(!fred) exit(1);
   return 0;
}
""", basename)

    try:
      dll = self.build_shared_dll(dummy_lib_filename)
      exe = self.build_shared_program(dummy_main_filename)

      self.shell(exe, dll)
    except ExecutionError:
      pass
    else:
      opt.SUPPORT_DYNAMIC_LOADING = True
      opt.HAVE_LOADLIBRARY = True
      print "Dynamic Loading Supported (with LoadLibrary)"


  def detect_posix_dynamic_loading(self):
    opt = self.options

    basename = 'tmp' + os.sep + 'dummy_lib'
    # RF: This can be compiled as both c and c++ these days it seems
    # hence conditional extern "C"
    # P.S. This lovingly hand crafted function doesn't seem to be called
    proggy = """
#ifdef __cplusplus
extern "C"
#endif
int fred(int argc, char** argv) { return 0; }
"""

    dummy_lib_filename = self.write_lib_src( proggy, basename)

    basename = 'tmp' + os.sep + 'dummy_main'
    dummy_main_filename = self.write_src(r"""
#include <dlfcn.h>
#include <stdlib.h>

int main(int argc, char** argv) {
   void *lib = dlopen(argv[1],RTLD_NOW);
   void *fred = 0;
   if(!lib) exit(1);
   fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}
""", basename)

    try:
      dll = self.build_shared_dll(dummy_lib_filename)
      exe = self.build_shared_program(dummy_main_filename)
      self.shell(exe, dll)
      opt.SUPPORT_DYNAMIC_LOADING = True
      opt.HAVE_DLOPEN = True
    except ExecutionError:
      try: # nope, try with -ldl
        exe = self.build_shared_program([dummy_main_filename], libs=['dl'])
        opt.HAVE_DLOPEN = True
        opt.SUPPORT_DYNAMIC_LOADING = True
        opt.DLLIB = "dl"
        print "Dynamic Loading Supported (with -ldl)"
      except ExecutionError:
        if opt.model == "osx":
          opt.SUPPORT_DYNAMIC_LOADING = True  # pre 10.3, we do our own dlopen

  def detect_dynamic_loading(self):
    opt = self.options

    #check if we can get dlopen to work without -ldl (BSD, Cygwin don't need)
    opt.SUPPORT_DYNAMIC_LOADING = False
    opt.HAVE_DLOPEN = False
    opt.HAVE_LOADLIBRARY = False
    opt.DLLIB = ""

    if opt.model in ["win32", "win64"]:
      self.detect_win_dynamic_loading()
    else:
      self.detect_posix_dynamic_loading()

    if not opt.SUPPORT_DYNAMIC_LOADING:
      print "DYNAMIC LOADING NOT SUPPORTED"
      print "Temporarily this is mandatory [during config debugging]"
      sys.exit(1)


  def detect_sockets(self):
    opt = self.options

    filename = self.write_src(r"""
#include <sys/types.h>
#include <sys/socket.h>
extern "C" int accept(int s, struct sockaddr *addr, socklen_t *addrlen);
int main(int argc, char** argv) { return 0; }
""", 'tmp' + os.sep + 'have_socketlen_t')

    try:
      self.compile_static_main([filename])
      opt.FLX_SOCKLEN_T = "socklen_t"
    except ExecutionError:
      filename = self.write_src(r"""
#include <sys/types.h>
#include <sys/socket.h>
extern "C" int accept(int s, struct sockaddr *addr, unsigned int *addrlen);
int main(int argc, char** argv) { return 0; }
""", 'tmp' + os.sep + 'have_socketlen_t_is_uint')

      try:
        self.compile_static_main([filename])
        opt.FLX_SOCKLEN_T = "unsigned int"
      except ExecutionError:
        filename = self.write_src(r"""
#include <sys/types.h>
#include <sys/socket.h>
extern "C" int accept(int s, struct sockaddr *addr, int *addrlen);
int main(int argc, char** argv) { return 0; }
""", 'tmp' + os.sep + 'have_socketlen_t_is_int')

        try:
          self.compile_static_main([filename])
          opt.FLX_SOCKLEN_T = "int"
        except ExecutionError:
          opt.FLX_SOCKLEN_T = "int"
    print "socklen_t =", opt.FLX_SOCKLEN_T


  def detect_kqueues(self):
    opt = self.options

    filename = self.write_src(r"""
#include <sys/types.h>      // from the kqueue manpage
#include <sys/event.h>      // kernel events
#include <sys/time.h>       // timespec (kevent timeout)

int
main(int argc, char** argv) {
  int kq = kqueue();
  return (-1 == kq) ? 1 : 0;
}
""", 'tmp' + os.sep + 'kqt')

    # see what sort of demuxers we support. right now just testing for
    # kqueues, to unbreak the osx 10.2.8 build. I need demux to be extracted
    # by this point, so I've added a line to configure to do that. That
    # required me to remove the flx_demux.pak's dependence on the config
    # directory (not created at configure time). also had to create a fake
    # flx_rtl_config.h in tmp/

    # now that kqueue demuxer uses condition vars and locks for a clean
    # takedown using this method of config is a nightmare before config
    # because the pthread pak file depends on the config results. for now
    # I've replaced the whole lot with a simple kqueue+main programme.
    try:
      # basically a un*x test, note the non portable path separators and
      # gcc style switches
      self.compile_static_main([filename])
      opt.HAVE_KQUEUE_DEMUXER = True
    except ExecutionError:
      opt.HAVE_KQUEUE_DEMUXER = False

    print "HAVE_KQUEUE_DEMUXER =", opt.HAVE_KQUEUE_DEMUXER

  def detect_epoll(self):
    opt = self.options

    filename = self.write_src(r"""
#include <sys/epoll.h>

int
main(int argc, char** argv) {
  int efd = epoll_create(20);
  return (-1 == efd) ? 1 : 0;
}
""", 'tmp' + os.sep + 'epolltest')

    try:
      lines = self.run_static_program(filename)
    except ExecutionError:
      opt.HAVE_EPOLL = False
    else:
      opt.HAVE_EPOLL = True

    print "HAVE_EPOLL=", opt.HAVE_EPOLL

  def detect_strip(self):
    opt = self.options

    # see if we have strip: it isn't considered essential
    filename = self.compile_dummy_main()
    if opt.STRIP:
      try:
        self.shell(opt.STRIP, filename)
      except:
        opt.STRIP = "true strip "
    else:
      opt.STRIP = "true strip "


  def detect_ar(self):
    opt = self.options

    # see if we have ar
    filenames = self.compile_dummy_main()
    self.shell(opt.AR, os.path.join("tmp", "dummy.a"), *filenames)

    # see if we have ranlib, it isn't considered essential
    # (a totally brain dead Unix idea: AR should do this)
    try:
      self.shell(opt.RANLIB, os.path.join("tmp", "dummy.a"))
    except ExecutionError:
      opt.RANLIB = "true ranlib "


  def detect_compiler_options(self):
    self.detect_warning_flags()
    self.detect_PIC()
    self.detect_openmp()
    self.construct_compiler_commands()
    self.detect_dynamic_loading()


  def check_options(self):
    self.detect_gcc_builtin_expect()
    self.detect_named_registers()
    self.detect_computed_gotos()
    self.detect_pthreads()
    self.detect_mmap()
    self.detect_sockets()
    # could just replace this with header_exists("sys/event.h") but
    # it ain't broke.
    self.detect_kqueues()
    self.options.HAVE_POLL = self.check_header_exists("poll.h")
    self.detect_epoll()
    # nice one, Sun, no one else would ever call a header file "port.h"
    self.options.HAVE_EVTPORTS = self.check_header_exists("port.h")
    print "HAVE_POLL =", self.options.HAVE_POLL
    print "HAVE_EPOLL =", self.options.HAVE_EPOLL
    print "HAVE_EVTPORTS =", self.options.HAVE_EVTPORTS

    self.detect_strip()
    self.detect_ar()

  ####

  def link_thing(self, *args, **kwds):
    opt = self.options

    # strip off the lib from the start of the libraries
    libs = []
    for lib in kwds.get('libs', []):
      if lib[0:3] == 'lib': lib = lib[3:]
      libs.append(lib)
    kwds['libs'] = libs

    if opt.__dict__.get('HAVE_PTHREADS', False):
      kwds['LDFLAGS'] = kwds.get('LDFLAGS', '') + ' ' + opt.PTHREAD_SWITCH

    return super(gnu_mixin, self).link_thing(*args, **kwds)


  def link_shared_thing(self, *args, **kwds):
    if self.options.DLLIB:
      libs = kwds.get('libs', [])[:]
      libs.append(self.options.DLLIB)
      kwds['libs'] = libs

    return super(gnu_mixin, self).link_thing(*args, **kwds)


  def report_config(self):
    super(gnu_mixin, self).report_config()
    opt = self.options

    print
    if opt.SUPPORT_DYNAMIC_LOADING:
      if opt.HAVE_DLOPEN:
        if opt.DLLIB:
          print "Dynamic Loading Supported : with dlopen() in -l", opt.DLLIB
        else:
          print "Dynamic Loading Supported : with dlopen() [native]"
      if opt.HAVE_LOADLIBRARY:
          print "Dynamic Loading Supported : with LoadLibrary"
    else:
      print "Dynamic Loading               : NOT SUPPORTED"
    print

@h = tangler("flxbuild/gcc_class.py")
@select(h)
from flxbuild.c_base import c_base
from flxbuild.gnu_mixin import gnu_mixin

class gcc(gnu_mixin, c_base):
  DEFAULT_COM = 'gcc'

  def check_options(self):
    c_base.check_options(self)
    gnu_mixin.check_options(self)


@h = tangler("flxbuild/gxx_class.py")
@select(h)
import os
import sys
import flxbuild
from flxbuild.cxx_base import cxx_base
from flxbuild.gnu_mixin import gnu_mixin

class gxx(gnu_mixin, cxx_base):
  DEFAULT_COM = 'g++'

  def check_options(self):
    cxx_base.check_options(self)
    gnu_mixin.check_options(self)

    self.detect_gxx_template_extensions()


  def detect_gxx_template_extensions(self):
    # find if we have g++ supported ext/ with STL extensions
    try:
      self.build_string_program(r"""
#include <iostream>

// we only bother to check the include file exists
#include <ext/hash_map>
using namespace __gnu_cxx;

int main(int argc,char** argv) {
   return 0;
}
""", 'tmp' + os.sep + 'gnu_hash')
      self.options.HAVE_STL_GNU_CXX = True
      print "Gnu ext/ templates supported"
    except ExecutionError:
      self.options.HAVE_STL_GNU_CXX = False

@h = tangler("flxbuild/msvc_mixin.py")
@select(h)
import os
import sys

import flxbuild
from flxbuild.c_cxx_base import c_cxx_base

class msvc_mixin(object):
  DEFAULT_COM = 'cl '
  DEFAULT_AR = 'lib '

  def set_options(self, **kwds):
    """these options are model dependent and have to
    be supplied by the client"""

    super(msvc_mixin, self).set_options(**kwds)

    opt = self.options

    # RF: add /GR to generate RTTI information, if this isn't on, we get
    # access violations when doing dynamic_casts. Of course, these access
    # violations are thrown as exceptions, which can be caught with
    # catch(std::exception& e). we also don't want the logo
    # OF COURSE now /GR will have no sense if this happens to be a
    # c compiler. let's hope it doesn't error out.
    opt.COM = self.DEFAULT_COM + "/nologo /GR "
    opt.AR = self.DEFAULT_AR + "/nologo "

  ########

  def detect_model(self):
    super(msvc_mixin, self).detect_model()

    if self.options.model == "detect":
      self.options.model = "win32"


  def detect_compiler_options(self):
    self.detect_warning_flags()
    self.detect_openmp()
    self.construct_compiler_commands()


  # CHECK_OPTIONS FOR CL.EXE IN CASE YOU WERE WONDERING
  # RIGHT NOW WE'RE IN THE FILE msvc_mixin.py, SOMETIMES THAT CAN
  # BE CONFUSING.
  def check_options(self):
    opt = self.options
    COM = opt.COM

    # RF: Does windows have mmap? Let's say no.
    opt.HAVE_MMAP = False
    opt.RANLIB = "@rem nothing" # RF: better than none.
    opt.SUPPORT_DYNAMIC_LOADING = True
    opt.SPEC_COMPILE_OBJ = "/c "
    opt.SPEC_OBJ_FILENAME = "/Fo"
    opt.SPEC_EXE_FILENAME = "/Fe"
    opt.SPEC_DEFINE = "/D"
    opt.SPEC_INCLUDE = "/I"
    opt.SPEC_LIBPATH = "/LIBPATH:"
    opt.SPEC_LIB = "/DEFAULTLIB:"
    opt.SPEC_AR_OUT_FILENAME = "/OUT:"
    #opt.DEBUG_FLAGS = "/Yd /Zi /RTC "
    # /Yd deprecated, /RTC not recognized with VS2005
    opt.DEBUG_FLAGS = "/Zi "
    #opt.OPTIMISE = "/Ox /DNDEBUG "
    opt.OPTIMISE = "/Ox "

    opt.EXT_LIB = ".lib"
    opt.EXT_EXE= ".exe"
    opt.EXT_SHLIB = ".dll"
    opt.EXT_DYLIB = opt.EXT_SHLIB
    opt.EXT_STATIC_OBJ = "_static.obj"
    opt.EXT_SHARED_OBJ = "_dynamic.obj"

    opt.HAVE_DLOPEN = False
    opt.DLLIB = ""

    # where to put the rtl: Cygwin requires the dll be in the PATH
    opt.SHLIB_DIR = "bin"
    print "rtl located in bin directory"

  def detect_openmp(self):
    # find if we can use /openmp without a warning
    try:
      self.compile_dummy_main(CFLAGS="/openmp ")
      self.options.openmp= "/openmp "
      print "OpenMP based parallel programming supported"
      self.options.HAVE_OPENMP = True
    except ExecutionError:
      self.options.openmp = ""
      self.options.HAVE_OPENMP = False
      print "OpenMP based parallel programming not supported"


  def detect_warning_flags(self):
    # RF: silencing all warnings /w has masked some really insidious bugs
    # (like dynamic_casts whilst RTTI was disabled). does the offset warning
    # even apply to vs toolchain? I don't think so, however, there is one
    # warning, that about missing delete for the custom operator new,
    # the follow /wd<n> should silence that warning.
    # self.options.NO_INVALID_OFFSETOF_WARNING = "/w "
    self.options.NO_INVALID_OFFSETOF_WARNING="/wd4291 "


  def construct_compiler_commands(self):
    opt = self.options
    COM = opt.COM
    # RF: /MT (link with multithreaded clib, LIBCMT.LIB) for static builds
    # and /MD for dynamic (multithreaded dynamic clib, MSVCRT.LIB).
    # This last one's important as it means that not only is malloc threadsafe,
    # but the SAME allocator is shared between the app and its dynamic libs.
    # Without this, pushing an fthread in flx_run and popping it in
    # flxdynamic_lib is actually an insidious error. Note that /M* flags are
    # not just for link time, they seem to need to be passed to the compilation
    # phase as well. To run with debug versions of clib, try /MDd, /MTd and
    # /LDd when linking dynamic libs. Phew.
    # RF: update: Max suggested trying /MD (threadsafe dll clib) for all
    # builds, including static. I forget why, perhaps for uniformity. Anyway,
    # it works fine. It might have implications for folks who link against
    # static libs (folks like me), but I'm using nocygwin, so, yknow, eh.
    # P.S. Erick, if ever again you checkin any changes to this that you
    # haven't first tested, I'll kill you.

    # JS: openmp support now detected, and the right compiler option applied
    # Windows prof. ed. 2005 supports openMP for dynamic link only
    # Express doesn't support openMP
    # Xbox also supports static link, but we don't handle that here
    #
    # So far, we don't link the right library.. can't see at present how
    # to get the library in, and not sure that /openmp doesn't link it
    # automatically.
    # It's called vcomp.lib/vcomp.dll.
    # this has to specified with LDFLAGS to go after the 'link' directive
    # assuming the /openmp switch doesn't force the right linkage

    COMPILE_DYNAMIC_RTL = "/MD /c /EHs "
    LINK_DYNAMIC_RTL = "/MD /LD "

    COMPILE_DYNAMIC_MAIN = "/MD /c /EHs "
    LINK_DYNAMIC_MAIN = "/MD "

    COMPILE_DYNAMIC_FLX = "/MD /c /EHs "
    LINK_DYNAMIC_FLX = "/MD /LD "

    opt.CCOBJ_DYNAMIC_FLX = COM + COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = COM + LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = COM + COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = COM + LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = COM + COMPILE_DYNAMIC_MAIN + opt.openmp
    opt.CCLINK_DYNAMIC_MAIN = COM + LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = COM + "/MD /EHs /c "
    opt.CCOBJ_STATIC_RTL = COM + "/MD /EHs /c "
    opt.CCOBJ_STATIC_MAIN = COM + "/MD /EHs /c "

    opt.CCOBJ_DYNAMIC_RTL = opt.CCOBJ_DYNAMIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING + opt.openmp
    opt.CCOBJ_DYNAMIC_FLX = opt.CCOBJ_DYNAMIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING + opt.openmp
    opt.CCOBJ_STATIC_RTL = opt.CCOBJ_STATIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX = opt.CCOBJ_STATIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCLINK_STATIC = COM + "/MD "

  ########

  def link_thing(self, *args, **kwds):
    kwds['LDFLAGS'] = kwds.get('LDFLAGS', '')
    # RF: hack to get /link before all other link directives,
    # including the libraries themselves and their paths.
    self.options.PRE_LINK_FLAGS = '/link '

    return super(msvc_mixin, self).link_thing(*args, **kwds)

  ########

  def report_config(self):
    c_cxx_base.report_config(self)
    opt = self.options

    print
    if opt.SUPPORT_DYNAMIC_LOADING:
      print "Dynamic Loading Supported               : [Windows native]"
    else:
      print "Dynamic Loading                         : NOT SUPPORTED"

    print
    self.report_isnan()

@h = tangler("flxbuild/msvcc_class.py")
@select(h)
from flxbuild.c_base import c_base
from flxbuild.msvc_mixin import msvc_mixin

class msvcc(msvc_mixin, c_base):
  # RF: /TC is screwing up the link stage, treating the object file
  # as a .c file. Taking it away and hoping that cl can figure it out.
  # DEFAULT_COM = 'cl /TC '
  DEFAULT_COM = 'cl '

  def check_options(self):
    msvc_mixin.check_options(self)
    c_base.check_options(self)

@h = tangler("flxbuild/msvcxx_class.py")
@select(h)
from flxbuild.cxx_base import cxx_base
from flxbuild.msvc_mixin import msvc_mixin

class msvcxx(msvc_mixin, cxx_base):
  # RF: this might be a good place to put the RTTI switch zzz
  # /TP was forcing the link stage to interpret the .obj files as c++.
  # DEFAULT_COM = 'cl /TP '
  DEFAULT_COM = 'cl '

  def check_options(self):
    msvc_mixin.check_options(self)
    cxx_base.check_options(self)

@h = tangler("flxbuild/ocaml_class.py")
@select(h)
#---------------------------------------------------
# discover which ocaml compilers are available
import os
import sys
import shutil

from flxbuild.flxutil import mkdirs, ExecutionError
from flxbuild.compiler_base import compiler_base

class ocaml(compiler_base):

  def autodetect(self, linkopts,log=None):
    opt = self.options

    if os.name == 'nt' or sys.platform == 'cygwin':
      opt.EXT_EXE = '.exe'
      # ocamlbuild doesn't work under windows
      opt.HAVE_OCAMLBUILD = False
    else:
      opt.EXT_EXE = ''

      try: # check if ocamlbuild exists
        self.shell('ocamlbuild', '-version', log=log)
        opt.OCAMLBUILD = 'ocamlbuild -classic-display '
        #opt.HAVE_OCAMLBUILD = True
        # ocaml build doesn't work properly at the moment
        # due to hygiene checks or something .. so i have
        # to disable it
        opt.HAVE_OCAMLBUILD = False
      except ExecutionError:
        opt.HAVE_OCAMLBUILD = False

    try: # check if the client bootstrapped the native code compiler
      self.shell('ocamlopt.opt', log=log)
      opt.OCAMLCC = 'ocamlopt.opt ' + linkopts
      opt.OCAMLLEX = 'ocamllex.opt'
      opt.OCAMLYACC = 'ocamlyacc'
      opt.NATIVE_CODE_COMPILER = True
    except ExecutionError:
      try: # check if the client has unbootstrapped native code compiler
        self.shell('ocamlopt', log=log)
        opt.OCAMLCC = 'ocamlopt ' + linkopts
        opt.OCAMLLEX = 'ocamllex'
        opt.OCAMLYACC = 'ocamlyacc'
        opt.NATIVE_CODE_COMPILER = True
      except ExecutionError:
        opt.NATIVE_CODE_COMPILER = False
        try: # check if the client has ocaml at all ..
          self.shell('ocamlc', log=log)
          opt.OCAMLCC = 'ocamlc'
          opt.OCAMLLEX = 'ocamllex'
          opt.OCAMLYACC = 'ocamlyacc'
          opt.OCAMLDOC = 'ocamldoc'
        except ExecutionError:
          print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
          opt.OCAMLCC = 'false ocamlc'
          opt.OCAMLLEX = 'false ocamllex'
          opt.OCAMLYACC = 'false ocamlyacc'

    try: # check if there is a native code version of the bytecode compiler
      self.shell('ocamlc.opt', log=log)
      opt.OCAMLB = 'ocamlc.opt'
    except ExecutionError:
      try: # check if the client has ocaml at all
        self.shell('ocamlc', log=log)
        opt.OCAMLB = 'ocamlc'
      except ExecutionError:
        print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
        opt.OCAMLB = 'false ocamlc'

    try:
      self.shell('ocamldoc.opt', log=log)
      opt.OCAMLDOC = 'ocamldoc.opt'
    except ExecutionError:
      try:
        self.shell('ocamldoc', log=log)
        opt.OCAMLDOC = 'ocamldoc'
      except ExecutionError:
        print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
        opt.OCAMLDOC = 'false ocamldoc'

    # set the default ocaml compiler
    if opt.OCAMLCC[0] != '#':
      opt.OCAMLC = opt.OCAMLCC
    else:
      opt.OCAMLC = opt.OCAMLB

    opt.OCAMLCP = "ocamlcp "
    # where the ocaml is installed
    try:
      output = self.shell(opt.OCAMLC, '-where', verbose=False)
    except ExecutionError:
      print "Woops, Can't run", opt.OCAMLC
      sys.exit(1)
    opt.OCAML_INCLUDE_DIRECTORY= output[0].strip()

    try:
      output = self.shell(opt.OCAMLB, '-v', verbose=False)
    except ExecutionError:
      print "Woops, Can't run", opt.OCAMLB
      sys.exit(1)
    opt.OCAMLB_DESCRIPTION, ocamlb_version = output[0].strip().split(', ')

    try:
      output = self.shell(opt.OCAMLC, '-v', verbose=False)
    except ExecutionError:
      print "Woops, Can't run", opt.OCAMLC
      sys.exit(1)
    opt.OCAMLC_DESCRIPTION, ocamlc_version = output[0].strip().split(', ')
    if ocamlb_version != ocamlc_version:
      print "Inconsistent Ocaml tool versions"
      print "Ocaml: bytecode compiler", ocamlb_version
      print "Ocaml: compiler         ", ocamlc_version
      sys.exit(1)
    else:
      opt.OCAML_VERSION = ocamlb_version

    warn=' -w yzex -warn-error FDPSU '
    try:
      f = open('tmp'+os.sep+'camldummy.ml','w')
      try:
        f.write('print_endline "OK";;\n')
      finally:
        f.close()
    except (IOError, OSError):
      pass
    else:
      try:
        output = self.shell(opt.OCAMLC,
          warn,
          os.path.join('tmp', 'camldummy.ml'),
          verbose=False,
        )
      except ExecutionError:
        pass
      else:
        opt.OCAMLB = opt.OCAMLB + warn
        opt.OCAMLC = opt.OCAMLC + warn

  def report_config(self):
    opt = self.options

    print
    print "OCAML tool configuration"
    print "************************"
    print
    print "Ocaml Version",opt.OCAML_VERSION
    if opt.NATIVE_CODE_COMPILER:
      print "Using Native code Compiler"
    else:
      print "Using Bytecode Compiler"
    print "Lexer generator .............. ",opt.OCAMLLEX
    print "Parser generator ............. ",opt.OCAMLYACC
    print "Bytecode and Interface compiler",opt.OCAMLB
    print "   ",opt.OCAMLB_DESCRIPTION
    print "Compiler ..................... ",opt.OCAMLC
    print "   ",opt.OCAMLC_DESCRIPTION
    print "Profiling Compiler ........... ",opt.OCAMLCP
    print "Document Generator ........... ",opt.OCAMLDOC
    print "C include directory .......... ",opt.OCAML_INCLUDE_DIRECTORY
    print


  def compile_thing(self, COM, EXT_SRC, EXT_DST, basenames,
      outdir='',
      include_paths=[],
      packs=[],
      debug=False,
      profile=False,
      optimise=False,
      FLAGS=None,
      log=None,
      ):
    objects = []
    for basename in basenames:
      src = self.find_in_flx_dir(basename + EXT_SRC)
      dst = os.path.join(outdir, basename + EXT_DST)

      # search for generated files first
      f = os.path.join(outdir, src)
      if os.path.exists(f):
        src = f

      mkdirs(os.path.dirname(dst))

      cmd = [COM]
      for i in include_paths: cmd.append('-I ' + i)
      cmd.append('-I ' + os.path.dirname(dst))

      if debug: cmd.append('-g')
      if optimise: cmd.extend(['-unsafe', '-noassert'])

      for path, packed, parts in packs:
        if basename in parts:
          cmd.extend(['-for-pack', pack])

      cmd.append('-o ' + dst)
      cmd.append('-c ' + src)

      # compile it
      self.shell(*cmd, **dict(log=log))

      objects.append(dst)

    return objects


  def compile_bytecode_thing(self, *args, **kwds):
    if kwds.pop('profile', False):
      return self.compile_thing(self.options.OCAMLCP, *args, **kwds)
    else:
      return self.compile_thing(self.options.OCAMLB, *args, **kwds)


  def compile_native_thing(self, *args, **kwds):
    if not self.options.NATIVE_CODE_COMPILER:
      return self.compile_bytecode_thing(*args, **kwds)

    compiler = self.options.OCAMLC
    if kwds.pop('profile', False):
      compiler += ' -p'

    if kwds.get('optimise', False):
      compiler += ' -inline 5'

    return self.compile_thing(compiler, *args, **kwds)

  ####

  def compile_interface(self, *args, **kwds):
    return self.compile_bytecode_thing('.mli', '.cmi', *args, **kwds)

  def compile_bytecode(self, *args, **kwds):
    return self.compile_bytecode_thing('.ml', '.cmo', *args, **kwds)

  def compile_native(self, *args, **kwds):
    return self.compile_native_thing('.ml', '.cmx', *args, **kwds)

  ####

  def link_thing(self, LINK, EXT_DST, objects, outfile,
      outdir='',
      include_paths=[],
      libs=[],
      log=None,
      ):
    dst = os.path.join(outdir, outfile)

    cmd = [LINK]
    for i in include_paths: cmd.append('-I ' + i)
    cmd.append('-I ' + os.path.dirname(dst))

    cmd.append('-o ' + dst)
    cmd.extend([lib + EXT_DST for lib in libs])
    cmd.extend(objects)

    self.shell(*cmd, **dict(log=log))

    return dst

  def link_bytecode_lib(self, objects, outfile, *args, **kwds):
    return self.link_thing(
        self.options.OCAMLB + ' -a', '.cma', objects, outfile + '.cma',
        *args, **kwds)

  def link_native_lib(self, objects, outfile, *args, **kwds):
    if not self.options.NATIVE_CODE_COMPILER:
      return self.link_bytecode(*args, **kwds)

    return self.link_thing(
        self.options.OCAMLC + ' -a', '.cmxa', objects, outfile + '.cmxa',
        *args, **kwds)

  def link_bytecode_exe(self, *args, **kwds):
    opt = self.options
    return self.link_thing(opt.OCAMLC, '.cma', *args, **kwds)

  def link_native_exe(self, *args, **kwds):
    if not self.options.NATIVE_CODE_COMPILER:
      return self.link_bytecode_exe(*args, **kwds)

    opt = self.options
    return self.link_thing(opt.OCAMLC, '.cmxa', *args, **kwds)

  ####

  def gen_thing(self, COM, EXT_SRC, basenames,
      outdir='',
      FLAGS=[],
      log=None):
    for basename in basenames:
      src = self.find_in_flx_dir(basename + EXT_SRC)
      dst = os.path.join(outdir, basename + EXT_SRC)

      mkdirs(os.path.dirname(dst))
      shutil.copy(src, dst)

      cmd = [COM]
      cmd.extend(FLAGS)
      cmd.append(dst)

      self.shell(*cmd, **dict(log=log))


  def gen_lexer(self, *args, **kwds):
    return self.gen_thing(self.options.OCAMLLEX, '.mll', *args, **kwds)


  def gen_parser(self, *args, **kwds):
    return self.gen_thing(self.options.OCAMLYACC, '.mly',
        *args, **kwds)


  def gen_pgen_parser(self, *args, **kwds):
    return self.gen_thing(os.path.join('bin', 'pgen'), '.dyp',
        *args, **kwds)

  def gen_dypgen_parser(self, *args, **kwds):
    return self.gen_thing(os.path.join('bin', 'dypgen'), '.dyp',
        *args, **kwds)
