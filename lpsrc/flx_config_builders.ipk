@h = tangler("flxbuild/compiler_base.py")
@select (h)
import flxbuild
import os
import sys
import string

class compiler_base:
  def __init__(self):
    class Options:
      pass
    self.options = Options()


  def save_options(self, filename):
    f = open(filename, "w")
    ks = self.options.__dict__.keys()
    ks.sort()
    for k in ks:
      if k[0] != '_': # do not save __builtins__
        v = self.options.__dict__[k]
        f.write(k+'='+repr(v) + "\n")
    f.close()


  def load_options(self,filename):
    f = open(filename)
    exec f in self.options.__dict__
    f.close()

@h = tangler("flxbuild/c_cxx_base.py")
@select (h)
import os
import sys
import string

from flxbuild.flxutil import mkdirs, MakeError
from flxbuild.compiler_base import compiler_base

class c_cxx_base(compiler_base):
  DEFAULT_COM = None
  DEFAULT_AR = None
  DEFAULT_RANLIB = None
  
  def set_options(self, 
      COM=None,
      AR=None,
      RANLIB=None,
      build="posix",
      model="detect",
      use="generic",
      include_paths=None,
      lib_paths=None,
      ):
    opt = self.options

    # RF: this looks like in most cases it replaces None with None...
    if COM is None:           COM = self.DEFAULT_COM
    if AR is None:            AR = self.DEFAULT_AR
    if RANLIB is None:        RANLIB = self.DEFAULT_RANLIB
    if include_paths is None: include_paths = []
    if lib_paths is None:     lib_paths = []

    assert COM, 'need to specify a compiler'
    assert AR, 'need to specify a static library linker'

    if RANLIB is not None: RANLIB = RANLIB + ' '

    opt.COM = COM + ' '
    opt.AR = AR + ' '
    opt.RANLIB = RANLIB
    opt.build = build
    opt.model = model
    opt.use = use
    opt.include_paths = include_paths
    opt.lib_paths = lib_paths

    print "COM =", opt.COM

  ########
  
  # RF: would be nice to know which kind of source was being written
  def write_src(self, data, basename='tmp'):
    f = open(basename + self.options.EXT_SRC_MAIN, "w")
    try:
      f.write(data + '\n')
    finally:
      f.close()

    return basename

  # RF: temporarily added this to get the dll building config tests working.
  # previously write_src was creating .cpp files and the build_dll code 
  # was looking for .cxx. This is a work around.
  def write_lib_src(self, data, basename='tmp'):
    f = open(basename + self.options.EXT_SRC_LIB, "w")
    try:
      f.write(data + '\n')
    finally:
      f.close()

    return basename
   
  ########
  
  def compile_thing(self, COM, EXT_SRC, EXT_DST, shell, basename, 
      include_paths=[], 
      macros=[], 
      optimise=0, 
      debug=0, 
      CFLAGS=""):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = COM

    # debug symbols
    if debug: cmd = cmd + opt.DEBUG_FLAGS

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE + " "

    # include path
    for i in include_paths:     cmd = cmd + opt.SPEC_INCLUDE + i + " "
    for i in opt.include_paths: cmd = cmd + opt.SPEC_INCLUDE + i + " "

    # output file
    cmd = cmd + opt.SPEC_OBJ_FILENAME + basename + EXT_DST + " "

    #macros
    for i in macros: cmd=cmd + opt.SPEC_DEFINE + i + " "

    if opt.use == "host":     cmd=cmd + opt.SPEC_DEFINE + "HOST_BUILD "
    elif opt.use == "target": cmd=cmd + opt.SPEC_DEFINE + "TARGET_BUILD "

    cmd = cmd + CFLAGS + " "

    #input file
    cmd = cmd + basename + EXT_SRC

    mkdirs(os.path.dirname(basename))

    # compile it
    shell(cmd)

    return basename + EXT_DST

  ####

  def compile_static_thing(self, COM, EXT_SRC, *args, **kwds):
    args = (COM, EXT_SRC, self.options.EXT_STATIC_OBJ) + args
    return apply(self.compile_thing, args, kwds)
  

  # compile a file to an object suitable for inclusion in a static link 
  # version of the RTL 
  def compile_static_rtl(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_STATIC_RTL', opt.COM + opt.SPEC_COMPILE_OBJ)
    return apply(self.compile_static_thing, (COM, opt.EXT_SRC_LIB) + args, kwds)


  def compile_static_main(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_STATIC_MAIN', opt.COM + opt.SPEC_COMPILE_OBJ)
    return apply(self.compile_static_thing, (COM, opt.EXT_SRC_MAIN) + args, kwds)


  def compile_felix_static(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_STATIC_FLX', opt.COM + opt.SPEC_COMPILE_OBJ)
    return apply(self.compile_static_thing, (COM, opt.EXT_SRC_LIB) + args, kwds)

  ####

  def compile_shared_thing(self, COM, EXT_SRC, *args, **kwds):
    # add shared flag, then execute
    args = (COM, EXT_SRC, self.options.EXT_SHARED_OBJ) + args
    return apply(self.compile_thing, args, kwds)


  # compile a file to an object suitable for inclusion in a mainline
  # which links to shared libraries
  def compile_shared_rtl(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_DYNAMIC_RTL', opt.COM + opt.SPEC_COMPILE_OBJ)
    return apply(self.compile_shared_thing, (COM, opt.EXT_SRC_LIB) + args, kwds)


  def compile_shared_main(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_DYNAMIC_MAIN', opt.COM + opt.SPEC_COMPILE_OBJ)
    return apply(self.compile_shared_thing, (COM, opt.EXT_SRC_MAIN) + args, kwds)


  def compile_felix_dll(self, *args, **kwds):
    opt = self.options
    COM = opt.__dict__.get('CCOBJ_DYNAMIC_FLX', opt.COM + opt.SPEC_COMPILE_OBJ)
    return apply(self.compile_shared_thing, (COM, opt.EXT_SRC_LIB) + args, kwds)

  ########

  def link_thing(self, CCLINK, EXT_DST, shell, objects, outfile, 
      lib_paths=[], 
      libs=[], 
      LDFLAGS=""):
    opt = self.options
    cmd = CCLINK
    cmd = cmd + opt.SPEC_EXE_FILENAME + outfile + EXT_DST + " "

    for i in objects:       cmd = cmd + i + " "
    # RF: this is a hack to make sure that /link come before all link flags
    # under visual studio. I tried making sure that LDFLAGS had /link first
    # and moved it to just after the obj files, but that broke the gcc build
    # as some folk pass the libs in "libs" and others pass them directly
    # as LDFLAGS args. So much for encapsulation, eh?
    cmd = cmd + opt.PRE_LINK_FLAGS
    for i in lib_paths:     cmd = cmd + opt.SPEC_LIBPATH + i + " "
    for i in opt.lib_paths: cmd = cmd + opt.SPEC_LIBPATH + i + " "
    for i in libs:          cmd = cmd + opt.SPEC_LIB + i + " "

    cmd = cmd + LDFLAGS

    mkdirs(os.path.dirname(outfile))

    shell(cmd)

    return outfile + EXT_DST

  ####

  def link_static_thing(self, COM, EXT_DST, *args, **kwds):
    return apply(self.link_thing, (COM, EXT_DST) + args, kwds)


  def link_static_rtl(self, shell, objects, outfile, 
      lib_paths=[],
      libs=[],
      LDFLAGS=""):
    opt = self.options

    filename = outfile + opt.EXT_LIB
    
    cmd = opt.AR + " " + opt.SPEC_AR_OUT_FILENAME + filename + " " 
    for i in objects: cmd = cmd + i + " "

    mkdirs(os.path.dirname(outfile))

    shell(cmd)
    if opt.RANLIB:
      shell(opt.RANLIB + " " + filename)

    return filename


  def link_static_program(self, *args, **kwds):
    opt = self.options
    args = (opt.CCLINK_STATIC, opt.EXT_EXE) + args
    return apply(self.link_static_thing, args, kwds)

  ####

  def link_shared_thing(self, COM, EXT_DST, *args, **kwds):
    return apply(self.link_thing, (COM, EXT_DST) + args, kwds)


  def link_shared_rtl(self, *args, **kwds):
    opt = self.options
    args = (opt.CCLINK_DYNAMIC_RTL, opt.EXT_DYLIB) + args
    return apply(self.link_shared_thing, args, kwds)

    
  def link_shared_dll(self, *args, **kwds):
    opt = self.options
    args = (opt.CCLINK_DYNAMIC_FLX, opt.EXT_SHLIB) + args
    return apply(self.link_shared_thing, args, kwds)
 
 
  def link_shared_program(self, *args, **kwds):
    opt = self.options
    args = (opt.CCLINK_DYNAMIC_MAIN, opt.EXT_EXE) + args
    return apply(self.link_shared_thing, args, kwds)

  ########

  def build_thing(self, compile_fn, link_fn, shell, basenames,
      outfile=None,
      objects=[],
      include_paths=[],
      macros=[],
      optimise=0,
      debug=0,
      CFLAGS="",
      lib_paths=[],
      libs=[],
      LDFLAGS="",
      ):
    if type(basenames) != type([]):
      basenames = [basenames]

    assert basenames
      
    objects = objects[:]
    for basename in basenames:
      objects.append(
          compile_fn(shell, basename, 
            include_paths=include_paths,
            macros=macros,
            optimise=optimise,
            debug=debug,
            CFLAGS=CFLAGS,
          ))

    if outfile is None:
      outfile = basenames[0]

    return link_fn(shell, objects, outfile,
        lib_paths=lib_paths,
        libs=libs,
        LDFLAGS=LDFLAGS)


  def build_static_rtl(self, *args, **kwds):
    args = (self.compile_static_rtl, self.link_static_rtl) + args
    return apply(self.build_thing, args, kwds)


  def build_felix_static(self, *args, **kwds):
    args = (self.compile_felix_static, self.link_static_program) + args
    return apply(self.build_thing, args, kwds)


  def build_static_program(self, *args, **kwds):
    args = (self.compile_static_main, self.link_static_program) + args
    return apply(self.build_thing, args, kwds)


  def build_shared_rtl(self, *args, **kwds):
    args = (self.compile_shared_rtl, self.link_shared_rtl) + args
    return apply(self.build_thing, args, kwds)


  def build_shared_dll(self, *args, **kwds):
    args = (self.compile_felix_dll, self.link_shared_dll) + args
    return apply(self.build_thing, args, kwds)


  def build_shared_program(self, *args, **kwds):
    args = (self.compile_shared_main, self.link_shared_program) + args
    return apply(self.build_thing, args, kwds)

  ########

  def run_static_program(self, shell, get_stdout, *args, **kwds):
    filename = apply(self.build_static_program, (shell,) + args, kwds)
    return get_stdout(filename)

  def run_shared_program(self, get_stdout, basename):
    filename = apply(self.build_shared_program, (shell,) + args, kwds)
    return get_stdout(filename)

  ########

  def run_static_string_program(self, shell, get_stdout, data, basename, *args, **kwds):
    basename = self.write_src(data, basename)
    return apply(self.run_static_program, (shell, get_stdout, basename) + args, kwds)
 
 
  def run_static_shared_program(self, shell, get_stdout, data, basename, *args, **kwds):
    basename = self.write_src(data, basename)
    return apply(self.run_shared_program, (shell, get_stdout, basename) + args, kwds)

  ########

  def build_string_program(self, shell, data, basename='tmp', **kwds):
    filename = self.write_src(data, basename)
    return apply(self.build_static_program, (shell, filename), kwds)

  ####

  def compile_dummy_main(self, shell, **kwds):
    basename = 'tmp' + os.sep + 'dummy'
    filename = self.write_src(
        'int main(int argc, char** argv) { return 0; }', basename)
    return apply(self.compile_static_main, (shell, filename), kwds)


  def compile_dummy_lib_program(self, shell, **kwds):
    basename = 'tmp' + os.sep + 'dummy_lib'
    # RF: This can be compiled as both c and c++ these days it seems
    # hence conditional extern "C"
    # P.S. This lovingly hand crafted function doesn't seem to be called
    sys.exit(1234) # let's see!
    proggy = """
#ifdef __cplusplus
extern "C"
#endif
int fred(int argc, char** argv) { return 0; }
"""

    filename = self.write_src(proggy, basename)

    return apply(self.compile_static_main, (shell, filename), kwds)

  ########

  def check_macro_defined(self, shell, macro, header=''):
    if header:
      header = '#include <%s>' % header

    filename = "tmp" + os.sep + "mchk"
    self.write_src("""
%s
#ifndef %s
#error %s
#endif
int main(int argc, char** argv) {return 0;}
""" % (header, macro, macro), filename)

    try:
      self.compile_static_main(shell, filename)
    except EnvironmentError:
      if header:
        print "NOT defined %s in %s" % (macro, header)
      else:
        print "NOT defined", macro
      return 0
    else:
      if header:
        print "#defined %s in %s" % (macro, header)
      else:
        print "#defined", macro
      return 1


  def check_header_exists(self, shell, name):
    basename = "tmp" + os.sep + "hchk"
    filename = self.write_src('#include <%s>\nint main(int argc, char** argv) { return 0; }' % name, basename)
    try:
      self.compile_static_main(shell, filename)
      print "#include <%s>" % name
      return 1
    except EnvironmentError:
      print "NO HEADER <%s>" % name
      return 0

  ########

  def get_type_size(self, shell, get_stdout, typedef, header=''):
    if header:
      header = '#include <%s>' % header

    if typedef[:7] != 'typedef': 
      t = 'typedef %s t;' % typedef
    else:
      t = typedef

    filename = "tmp" + os.sep + "type_size"
    self.write_src("""
#include <stddef.h>
#include <stdio.h>
%s

%s

int main(int argc, char** argv) { 
  printf("%%d\\n",(int)sizeof(t));
  return 0;
}
""" % (header, t), filename)

    try:
      result, lines = self.run_static_program(shell, get_stdout, filename)
    except EnvironmentError:
      pass
    else:
      if not result: # got a result
        size = int(lines[0])
        return size
     
    return None


  def get_type_align(self, shell, get_stdout, typedef, header=''):
    """the typedef defines alias 't' for the type"""
    if header:
      header = '#include <%s>' % header

    if typedef[:7] != 'typedef': 
      t = 'typedef %s t;' % typedef
    else:
      t = typedef

    filename = "tmp" + os.sep + "type_align"
    self.write_src("""
#include <stddef.h>
#include <stdio.h>
%s

%s

struct TEST {
  char c;
  t mem;
};

int main(int argc, char** argv) { 
  printf("%%d\\n",(int)offsetof(struct TEST,mem));
  return 0;
}
""" % (header, t), filename)

    try:
      result, lines = self.run_static_program(shell, get_stdout, filename)
    except EnvironmentError:
      pass
    else:
      if not result: # got a result
        align = int(lines[0])
        print '%s: align: %s' % (typedef, align)
        return align
    return None


  def get_type_size_sign(self, shell, get_stdout, typedef1, typedef2=None, header=''):
    if header:
      header = '#include <%s>' % header

    if typedef2 is None:
      typedef2 = typedef1
      expr1 = '(t1)0'
      expr2 = '(t1)~3 < ' + expr1
    else:
      expr1 = '(t1)0 + (t2)0'
      expr2 = '(t1)~3 + (t2)1 < ' + expr1

    filename = "tmp" + os.sep + "type_size_sign"
    self.write_src("""
#include <stddef.h>
#include <stdio.h>
%s

typedef %s t1;
typedef %s t2;

int main(int argc, char** argv) {
  printf("%%d\\n",(int)sizeof(%s));
  printf("%%d\\n", %s);

  return 0;
}
""" % (header, typedef1, typedef2, expr1, expr2), filename)

    try:
      result, lines = self.run_static_program(shell, get_stdout, filename)
    except EnvironmentError:
      pass
    else:
      if not result: # got a result
        size = int(lines[0])
        sign = int(lines[1])
        if typedef1 == typedef2:
          print '(%s)0: sign: %s' % (typedef1, sign)
        else:
          print '(%s)0 + (%s)0: sign: %s' % (typedef1, typedef2, sign)

        return size, sign

    return None, None

  ########
 
  native_int_types = [ \
      ('SCHAR', 'signed char'),
      ('UCHAR', 'unsigned char'),
      ('CHAR', 'char'),
      ('SHORT', 'short'),
      ('USHORT', 'unsigned short'),
      ('INT', 'int'),
      ('UINT', 'unsigned int'),
      ('LONG', 'long'), 
      ('ULONG', 'unsigned long'),
      ('LONGLONG', 'long long'),
      ('ULONGLONG', 'unsigned long long'),
      ]


  def detect_type_data(self, shell, get_stdout, m, t, header=''):
    size = self.get_type_size(shell, get_stdout, t, header)

    opt = self.options

    if size is None:
      if header:
        print "NO TYPE %s in <%s>" % (t, header)
      else:
        print "NO TYPE %s" % t

      opt.__dict__['HAVE_' + m] = 0
    else:
      print '%s: size: %s' % (t, size)

      align = self.get_type_align(shell, get_stdout, t, header)

      opt.__dict__['HAVE_' + m] = 1
      opt.__dict__['SIZEOF_' + m] = size
      opt.__dict__['ALIGNOF_' + m] = align


  def detect_int_data(self, shell, get_stdout):
    opt = self.options
 
    # find if we have stdint.h
    opt.HAVE_STDINT = self.check_header_exists(shell, "stdint.h")

    opt.sizesign2type = {}

    for m, t in self.native_int_types:
      self.detect_type_data(shell, get_stdout, m, t)
      sizesign = self.get_type_size_sign(shell, get_stdout, t)

      opt.sizesign2type[sizesign] = opt.sizesign2type.get(sizesign, t)


  def find_alias(self, shell,get_stdout, t1, t2=None, header=''):
    size, sign = self.get_type_size_sign(shell, get_stdout, t1, t2, header)
    if size is None:
      return None
    return self.options.sizesign2type[size, sign]


  def detect_aliases(self, shell, get_stdout):
    opt = self.options
    opt.arith_conv = {}

    for m1, t1 in self.native_int_types:
      for m2, t2 in self.native_int_types:
        alias = self.find_alias(shell, get_stdout, t1, t2)
        if alias is not None:
          opt.arith_conv[(t1, t2)] = alias

    for t in ['ptrdiff_t', 'size_t']:
      alias = self.find_alias(shell, get_stdout, t)
      if alias:
        opt.__dict__['ALIAS_' + t] = alias

    for t in [
      'int8_t', 'uint8_t',
      'int16_t', 'uint16_t',
      'int32_t', 'uint32_t',
      'int64_t', 'uint64_t']:
      alias = self.find_alias(shell, get_stdout, t, header='stdint.h')
      if alias:
        opt.__dict__['ALIAS_' + t] = alias
   

  def detect_c_type_data(self, shell, get_stdout):
    self.detect_int_data(shell, get_stdout)
    self.detect_aliases(shell, get_stdout)

    opt = self.options
      
    std_dtypes = [
      ('BOOL', 'bool', ''),
      ('FLOAT', 'float', ''),
      ('DOUBLE', 'double', ''),
      ('LONGDOUBLE', 'long double', ''),
      ('ENUM', 'typedef enum enum_t {tag} t;', ''),
      ('VOIDP', 'void *', ''),
      ('FUNCP', 'typedef void (*t)(void);', ''),
      ('CBOOL', '_Bool', ''),
      ('WCHAR', 'wchar_t', 'stddef.h'),
      ('PTRDIFF', 'ptrdiff_t', 'stddef.h'),
      ('SIZE', 'size_t', 'stddef.h'),
      ('COMPLEX', 'float _Complex', ''),
      ('DOUBLECOMPLEX', 'double _Complex', ''),
      ('LONGDOUBLECOMPLEX', 'long double _Complex', ''),
      ('IMAGINARY', 'float _Imaginary', ''),
      ('DOUBLEIMAGINARY', 'double _Imaginary', ''),
      ('LONGDOUBLEIMAGINARY', 'long double _Imaginary', ''),
      ('INT8', 'int8_t', 'stdint.h'),
      ('INT16', 'int16_t', 'stdint.h'),
      ('INT32', 'int32_t', 'stdint.h'),
      ('INT64', 'int64_t', 'stdint.h'),
      ('UINT8', 'uint8_t', 'stdint.h'),
      ('UINT16', 'uint16_t', 'stdint.h'),
      ('UINT32', 'uint32_t', 'stdint.h'),
      ('UINT64', 'uint64_t', 'stdint.h'),
    ]

    for m, t, f in std_dtypes:
      self.detect_type_data(shell, get_stdout, m, t, header=f)


  def detect_win32(self, shell):
    return self.check_macro_defined(shell, "_WIN32")

  def detect_win64(self, shell):
    return self.check_macro_defined(shell, "_WIN64")

  def detect_posix(self, shell):
    if self.check_macro_defined(shell, "_WIN32"):
      return 0
    else:
      return 1

  def detect_cygwin(self, shell):
    return self.check_macro_defined(shell, "__CYGWIN__")

  def detect_osx(self, shell):
    return self.check_macro_defined(shell, "__APPLE__")

  def detect_bsd(self, shell):
    return self.check_macro_defined(shell, "BSD")

  def detect_solaris(self, shell, get_stdout):
    # can't find a symbol for solaris...
    # return self.check_macro_defined(shell,"__SOLARIS__")
    result,output = get_stdout("uname")  # print SunOS on solaris
    if not result and output[0] == "SunOS\n":
      return 1
    else:
      return 0

  def detect_linux(self, shell):
    return self.check_macro_defined(shell, "__linux__")

  # only allows 4 models: cygwin, osx, win32 and posix
  # nocygwin = mingw = win32
  def detect_model(self, shell, get_stdout):
    opt = self.options

    # check that we can use the compiler
    self.compile_dummy_main(shell)

    opt.MACOSX = self.detect_osx(shell)
    opt.BSD = self.detect_bsd(shell)
    opt.SOLARIS = self.detect_solaris(shell, get_stdout)
    opt.LINUX= self.detect_linux(shell)
    opt.WIN32 = self.detect_win32(shell)
    opt.WIN64 = self.detect_win64(shell)
    opt.CYGWIN = self.detect_cygwin(shell)
    opt.POSIX = self.detect_posix(shell)

    sum = opt.MACOSX + opt.WIN32 + opt.CYGWIN
    if sum > 1:
      print "INCOMPATIBLE MODELS DETECTED"
      print "MACOSX",opt.MACOSX
      print "CYGWIN",opt.CYGWIN
      print "WIN32",opt.WIN32
    else:
     if opt.model == "detect":
       if opt.CYGWIN: opt.model = "cygwin"
       if opt.MACOSX: opt.model = "osx"
       if opt.WIN32: opt.model = "win32"
       if opt.WIN64: opt.model = "win64"
       if opt.SOLARIS: opt.model = "solaris"
       if opt.LINUX: opt.model = "linux"
       if opt.BSD: opt.model = "bsd"
       if opt.model == "detect": opt.model = "posix"
    if opt.model in ["mingw", "nocygwin"]: opt.model = "win32"
    if opt.model in ["posix"] and opt.CYGWIN: opt.model = "cygwin"

    if opt.model not in ["posix", "linux", "solaris", "bsd", "osx", "cygwin", "win32", "win64"]:
      print "UNKNOWN MODEL", opt.model
      sys.exit(1)

    print "MODEL=", self.options.model

  ########

  def detect_intsizes(self, shell, get_stdout):
    """find misc info about endianess"""

    opt = self.options

    filename = "tmp" + os.sep + "intsizes"

    try:
      errno, output = self.run_static_string_program(shell, get_stdout, r"""
#include <stdio.h>
#include <stddef.h>

enum enum_t {e_tag};
typedef void (*fp_t)(void);

union endian_t {
  unsigned long x;
  unsigned char y[sizeof(unsigned long)];
} endian;

int main(int argc, char** argv) { 
  printf("CHAR_IS_UNSIGNED=%d\n",((char)0xFF)>0?1:0);
  endian.x = 1ul;
  printf("LITTLE_ENDIAN=%d\n", endian.y[0]);
  printf("BIG_ENDIAN=%d\n", endian.y[sizeof(unsigned long)-1]);

  return 0;
}
""", filename)
      #shell(opt.COM+" -w tmp"+os.sep+"intsizes.cxx -o tmp"+os.sep+"intsizes")
      #shell(opt.COM+" /ML /w tmp"+os.sep+"intsizes.cxx /Fetmp"+os.sep+"intsizes.exe")
    except EnvironmentError:
      print "FATAL: can't determine sizes of ints"
      raise
    else:
      if errno:
        raise EnvironmentError("FATAL: can't determine size of ints")

      ## THIS CALL CANNOT USE THE SHELL BECAUSE IT REDIRECTS OUTPUT
      os.system("tmp"+os.sep+"intsizes > tmp"+os.sep+"intsizes.py")
      f = open("tmp"+os.sep+"intsizes.py")
      try:
        exec f in opt.__dict__
      finally:
        f.close()
      # RF (zzz): getting \r\n output from target/xcompile stage,
      # under nocygwin which is confusing 'exec' which flags them
      # as syntax errors. re-enabling the old code (not sure why it was
      # changed as it sure as hell weren't broke).

      # exec string.join(output, '\n') in opt.__dict__

    if opt.CHAR_IS_UNSIGNED:
      print "char is unsigned"
    else:
      print "char is signed"

    if opt.BIG_ENDIAN: print "Big Endian byte order detected"
    if opt.LITTLE_ENDIAN: print "Little Endian byte order detected"
  

  def detect_alignment(self, shell, get_stdout):
    #calculate alignment tables
    vbls = [
      ("ALIGNOF_CBOOL","_Bool"),
      ("ALIGNOF_BOOL","bool"),
      ("ALIGNOF_SHORT","short"),
      ("ALIGNOF_INT","int"),
      ("ALIGNOF_LONG","long"),
      ("ALIGNOF_LONGLONG","long long"),
      
      ("ALIGNOF_FLOAT","float"),
      ("ALIGNOF_DOUBLE","double"),
      ("ALIGNOF_LONGDOUBLE","long double"),

      ("ALIGNOF_WCHAR","wchar_t"),
      ("ALIGNOF_VOIDP","void*"),
      ]

    opt = self.options

    opt.MAX_ALIGN = 1
    opt.flx_aligns = {}
    for k, t in vbls:
      try:
        v = opt.__dict__[k]
        opt.flx_aligns[v]=t
      except KeyError: 
        pass
      else:
        if v > opt.MAX_ALIGN: 
          opt.MAX_ALIGN = v
    opt.flx_aligns[1] = "char"


  def detect_isnan(self, shell, get_stdout):
    # find if we have BSD isnanf in <math.h> (NAUGHTY!)
    try:
      self.build_string_program(shell, r"""
#include <math.h>

int main(int argc,char** argv) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_math')
      self.options.HAVE_ISNAN_IN_CMATH = 1
      print "Isnan found in <math.h>"
    except EnvironmentError:
      self.options.HAVE_ISNAN_IN_CMATH = 0

    # find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
    try:
      self.build_string_program(shell, r"""
#include <ieeefp.h>

int main(int argc,char** argv) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_ieeefp')
      self.options.HAVE_ISNAN_IN_IEEEFP = 1
      print "Isnan found in <ieeefp.h>"
    except EnvironmentError:
      self.options.HAVE_ISNAN_IN_IEEEFP = 0


  def detect_vsnprintf(self, shell, get_stdout):
    opt = self.options

    filename = self.write_src(r"""
#include <stdio.h>
#include <stdarg.h>

int check(char const*fmt,...)
{
  va_list ap;
  va_start(ap,fmt);
  int n = vsnprintf(NULL,0,fmt,ap);
  va_end(ap);
  return n!=3;
}

int main(int argc,char** argv) { 
  return check("%s","XXX"); // 0 means pass
}
""", 'tmp' + os.sep + 'vsnprintf')
    
    try:
      res, lines = self.run_static_program(shell, get_stdout, filename)
      if res: 
        opt.HAVE_VSNPRINTF = 0
      else:
        opt.HAVE_VSNPRINTF = 1
    except EnvironmentError:
      opt.HAVE_VSNPRINTF = 0

    if opt.HAVE_VSNPRINTF:
      print "vsnprintf() supported"
    else:
      print "vsnprintf() NOT supported"

  ########

  def detect_compiler_options(self, shell, get_stdout):
    pass

  def check_options(self, shell, get_stdout):
    self.detect_model(shell, get_stdout)

    self.detect_compiler_options(shell, get_stdout)
    
    self.detect_intsizes(shell, get_stdout)
    self.detect_c_type_data(shell, get_stdout)
    self.detect_alignment(shell, get_stdout)
    self.detect_isnan(shell, get_stdout)
    self.detect_vsnprintf(shell, get_stdout)
  
    # would like to know if we have SDL_opengl. that's done by compiling
    # and running sdl_opengl.cxx Needs can be compiled like 
    # g++ `sdl-config --cflags` sdl_opengl.cxx `sdl-config --libs`
    # but how is that done portably? Does win32 even have sdl-config?


  def report_config(self):
    opt = self.options
    print "**********************************************"
    print opt.COM, opt.use, "configuration"
    print "**********************************************"
    print "model=", opt.model
    print "static library tool #1                  : " + opt.AR
    print "static library tool #2                  : " + opt.RANLIB
    print
    print "Command to compile static Felix rtl     : " + opt.CCOBJ_STATIC_RTL
    print "Command to compile shared Felix rtl     : " + opt.CCOBJ_DYNAMIC_RTL
    print "Command to link shared Felix rtl        : " + opt.CCLINK_DYNAMIC_RTL
    print
    print "Command to compile static Felix driver  : " + opt.CCOBJ_STATIC_MAIN
    print "Command to compile dynamic Felix driver : " + opt.CCOBJ_DYNAMIC_MAIN
    print "Command to link dynamic Felix driver    : " + opt.CCLINK_DYNAMIC_MAIN
    print
    print "Command to compile static Felix object  : " + opt.CCOBJ_STATIC_FLX
    print "Command to compile loadable Felix object: " + opt.CCOBJ_DYNAMIC_FLX
    print "Command to link loadable Felix object   : " + opt.CCLINK_DYNAMIC_FLX
    print
    print "Extension for static object file        : " + opt.EXT_STATIC_OBJ
    print "Extension for shared object file        : " + opt.EXT_SHARED_OBJ
    print "Extension for static archive            : " + opt.EXT_LIB
    print "Extension for loadable RTL              : " + opt.EXT_DYLIB
    print "Extension for flx modules               : " + opt.EXT_SHLIB
    print "Extension for executable                : " + opt.EXT_EXE
    print "RTL in directory                        : " + opt.SHLIB_DIR

    print
    self.report_isnan()

@h = tangler("flxbuild/c_base.py")
@select (h)
import os

from flxbuild.c_cxx_base import c_cxx_base

class c_base(c_cxx_base):
  def __init__(self, *args, **kwds):
    apply(c_cxx_base.__init__, (self,) + args, kwds)

    self.options.EXT_SRC_MAIN = ".c"
    self.options.EXT_SRC_LIB = ".c"

  def report_isnan(self):
    opt = self.options

    if opt.HAVE_ISNAN_IN_IEEEFP:
      print "NaN Support in                          : <ieeefp.h>"
    if not opt.HAVE_ISNAN_IN_IEEEFP:
      print "NaN                                     : NOT SUPPORTED"


@h = tangler("flxbuild/cxx_base.py")
@select (h)
import os

from flxbuild.c_cxx_base import c_cxx_base

class cxx_base(c_cxx_base):
  def __init__(self, *args, **kwds):
    apply(c_cxx_base.__init__, (self,) + args, kwds)

    self.options.EXT_SRC_MAIN = ".cxx"
    self.options.EXT_SRC_LIB = ".cpp"


  def detect_static_initialization(self, shell):
    # find if we have static const init in class
    # [not so much an extension as a bug if we don't]
    try:
      self.build_string_program(shell, r"""
struct X {
  static const int i = 1;
};

int main(int argc, char** argv) { 
  return 0;
}
""", 'tmp' + os.sep + 'check_inclass')
      #shell(opt.COM+" -w -c tmp"+os.sep+"check_inclass.cxx -o tmp"+os.sep+"dummy.o")
      #shell(opt.COM+" /w /c tmp"+os.sep+"check_inclass.cxx /Fotmp"+os.sep+"dummy.o")
      self.options.HAVE_INCLASS_MEMBER_INITIALIZATION = 1
      print "Inclass member initialisation supported"
    except EnvironmentError:
      self.options.HAVE_INCLASS_MEMBER_INITIALIZATION = 0
      print "Inclass member initialisation NOT supported"


  def detect_cmath_isnan(self, shell):
    self.options.HAVE_ISNAN_IN_CMATH = 0
    # find if we have BSD isnan in <cmath> (NAUGHTY!)
    try:
      self.build_string_program(shell, r"""
#include <cmath>

int main(int argc, char** argv) { 
  float f = 0.0;
  std::isnan(f);
  return 0;
}
""", 'tmp' + os.sep + 'nan_cmath')
      self.options.HAVE_ISNAN_IN_CMATH = 1
      print "Isnan found in <cmath>"
    except EnvironmentError:
      self.options.HAVE_ISNAN_IN_CMATH = 0
  

  def check_options(self, shell, get_stdout):
    c_cxx_base.check_options(self, shell, get_stdout)

    self.detect_static_initialization(shell)
    self.detect_cmath_isnan(shell)

  def report_isnan(self):
    opt = self.options

    if opt.HAVE_ISNAN_IN_CMATH:
      print "NaN Support in                          : <cmath>"
    if opt.HAVE_ISNAN_IN_IEEEFP:
      print "NaN Support in                          : <ieeefp.h>"
    if not opt.HAVE_ISNAN_IN_IEEEFP and not opt.HAVE_ISNAN_IN_CMATH:
      print "NaN                                     : NOT SUPPORTED"


@h = tangler("flxbuild/gnu_mixin.py")
@select(h)
import string
import os
import sys
import flxbuild

from flxbuild.c_cxx_base import c_cxx_base

class gnu_mixin:
  DEFAULT_AR = 'ar -rc'
  DEFAULT_RANLIB = 'ranlib'

  def set_options(self, STRIP="strip", **kwds):
    """these options are model dependent and have to
    be supplied by the client"""

    apply(c_cxx_base.set_options, (self,), kwds)
      
    opt = self.options
    opt.STRIP = STRIP + " "

    if opt.model == "nocygwin": 
      opt.COM = opt.COM + "-mno-cygwin "
      opt.EXT_STATIC_OBJ = "_static.obj" # temporary hack
      opt.EXT_SHARED_OBJ = "_dynamic.obj" # temporary hack

  ########

  def detect_model(self, shell, get_stdout):
    opt = self.options

    # default options
    opt.EXT_STATIC_OBJ = "_static.o"
    opt.EXT_SHARED_OBJ = "_dynamic.o"
    opt.EXT_LIB = ".a"
    opt.EXT_EXE = ""
    opt.EXT_SHLIB = ".so"
    opt.EXT_DYLIB = ".so"
    opt.SHLIB_DIR = "rtl"

    opt.SPEC_COMPILE_OBJ = "-c "
    opt.SPEC_OBJ_FILENAME = "-o "
    opt.SPEC_EXE_FILENAME = "-o "
    opt.SPEC_DEFINE = "-D"
    opt.SPEC_INCLUDE = "-I"
    opt.SPEC_LIBPATH = "-L"
    opt.SPEC_LIB = "-l"
    opt.SPEC_AR_OUT_FILENAME = ""
    opt.DEBUG_FLAGS = "-g "
    opt.OPTIMISE = "-O3 -fomit-frame-pointer --inline -DNDEBUG "

    # RF: a hack to make the VS build work. sort of an "any last words"
    # argument/hook before link directives.
    opt.PRE_LINK_FLAGS = ""

    c_cxx_base.detect_model(self, shell, get_stdout)

    if opt.model in ["cygwin", "win32", "win64"]:
      opt.EXT_EXE = ".exe"
      opt.EXT_SHLIB = ".dll"
      opt.EXT_DYLIB = opt.EXT_SHLIB
      opt.SHLIB_DIR = "bin"

    if opt.model in ["win32", "win64"]:
      opt.EXT_STATIC_OBJ = "_static.obj"
      opt.EXT_SHARED_OBJ = "_dynamic.obj"

    if opt.model == "osx":
      # flags for rtl & flx executable compilation & linking taken from
      # http://fink.sourceforge.net/doc/porting/shared.php with many thanks

      # differentiated now because osx treats dylibs
      # and plugin-type libraries.
      opt.EXT_DYLIB = ".dylib"
      opt.PIC = ""		# darwin code is by default position independent


  def detect_warning_flags(self, shell, get_stdout):
    opt = self.options

    # find if we have g++ with -Wno-invalid-offsetof
    try:
      self.compile_dummy_main(shell, CFLAGS="-Wno-invalid-offsetof")
      #shell(COM+"-Wno-invalid-offsetof tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      opt.NO_INVALID_OFFSETOF_WARNING = "-Wall -Wno-invalid-offsetof "
      print "-Wno-invalid-offsetof supported"
    except EnvironmentError:
      opt.NO_INVALID_OFFSETOF_WARNING = "-w "

    # find if we have g++ with -Wfatal-errors
    try:
      self.compile_dummy_main(shell, CFLAGS="-Wfatal-errors")
      #shell(COM+"-Wfatal-errors tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      opt.NO_INVALID_OFFSETOF_WARNING = opt.NO_INVALID_OFFSETOF_WARNING + "-Wfatal-errors "
      print "-Wfatal-errors supported"
    except EnvironmentError:
      pass

  ########

  def detect_named_registers(self, shell, get_stdout):
    opt = self.options

    filename = self.write_src(r"""
#include <stdio.h>
register void *sp __asm__ ("esp");

int main(int argc, char** argv) { 
   printf("Sp = %p\n",sp);
   return 0;
}
""", 'tmp' + os.sep + 'gnu_x86')

    # find if we have gnu on 32 bit x86 platform with named registers
    try:
      self.build_static_program(shell, filename)
      #shell(opt.COM + "-w tmp"+os.sep+"gnu_x86.c -o tmp"+os.sep+"x86_check")
      #shell("tmp"+os.sep+"x86_check")
      opt.HAVE_GNU_X86 = 1
      print "gnu x86 32 bit support detected"
    except EnvironmentError:
      opt.HAVE_GNU_X86 = 0

    filename = self.write_src(r"""
#include <stdio.h>
register void *sp __asm__ ("rsp");

int main(int argc, char** argv) { 
   printf("Sp = %p\n",sp);
   return 0;
}
""", 'tmp' + os.sep + 'gnu_x86_64')

    # find if we have gnu on 64 bit x86 platform with named registers
    try:
      self.build_static_program(shell, filename)
      #shell(opt.COM + "-w tmp"+os.sep+"gnu_x86_64.c -o tmp"+os.sep+"x86_64_check")
      #shell("tmp"+os.sep+"x86_64_check")
      opt.HAVE_GNU_X86_64 = 1
      print "gnu x86 64 bit support detected"
    except EnvironmentError:
      opt.HAVE_GNU_X86_64 = 0

    # X86_64 dominates X86
    if opt.HAVE_GNU_X86 and opt.HAVE_GNU_X86_64:
      opt.HAVE_GNU_X86 = 0

    if opt.HAVE_GNU_X86:
      opt.USE_REGPARM3 = 1
      print "regparm3 supported"
    else:
      opt.USE_REGPARM3 = 0


  def detect_computed_gotos(self, shell, get_stdout):
    opt = self.options

    filename = self.write_src("""
int main(int argc, char** argv) { 
  void *label = &&label2;
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}
""", 'tmp' + os.sep + 'pthreads')


    # find if we have g++ supporting computed jumps
    try:
      self.build_static_program(shell, filename)
      #shell(COM + " tmp" + os.sep + "gnu_cgoto.c -o tmp" + os.sep + "cgoto")
      #shell("tmp" + os.sep + "cgoto")
      opt.HAVE_CGOTO = 1
      print "Computed goto supported"
    except EnvironmentError:
      opt.HAVE_CGOTO = 0

    filename = self.write_src("""
int main(int argc, char** argv) { 
  void *label = &&label2;
  __asm__(".global fred");
  __asm__("fred:");
  __asm__(""::"g"(&&label1));
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}
""", 'tmp' + os.sep + 'pthreads')

    # find if we have g++ supporting computed jumps and asm labels
    try:
      self.build_static_program(shell, filename)
      #shell(COM + "tmp" + os.sep + "gnu_asm_labels.c -o tmp" + os.sep + "asm_labels")
      #shell("tmp" + os.sep + "asm_labels")
      opt.HAVE_ASM_LABELS = 1
      print "Asm labels supported"
    except EnvironmentError:
      opt.HAVE_ASM_LABELS = 0


  def detect_PIC(self, shell, get_stdout):
    # find if we can use -fPIC without a warning
    # if a warning is generated it will say something like 
    # 'all code is relocatable on this platform' 
    # so we make that into an error, detect it, and say -fPIC only
    # if it would not generate this warning
    try:
      self.compile_dummy_main(shell, CFLAGS="-Werror -fPIC")
      #shell(COM+"-Werror -fPIC tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      self.options.PIC = "-fPIC "
      print "-fPIC supported"
    except EnvironmentError:
      self.options.PIC = ""
      print "All code is position independent"


  def construct_compiler_commands(self, shell, get_stdout):
    opt = self.options

    if opt.model == "osx":
      #COMPILE_DYNAMIC_RTL = opt.PIC + "-bundle -c "
      COMPILE_DYNAMIC_RTL = opt.PIC + opt.SPEC_COMPILE_OBJ + "-fno-common "
      # make a dynamic library (not loadable via APIs like dlcompat)
      LINK_DYNAMIC_RTL = "-dynamiclib "
      
      COMPILE_DYNAMIC_MAIN = opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_MAIN = ""
      
      COMPILE_DYNAMIC_FLX = opt.PIC + "-bundle -c " "-fno-common "
      LINK_DYNAMIC_FLX = "-bundle "
    else:
      COMPILE_DYNAMIC_RTL = opt.PIC + opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_RTL = "-shared "
      
      COMPILE_DYNAMIC_MAIN = opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_MAIN = " "

      COMPILE_DYNAMIC_FLX = opt.PIC + opt.SPEC_COMPILE_OBJ
      LINK_DYNAMIC_FLX = "-shared "

    COM = opt.COM

    opt.CCOBJ_DYNAMIC_FLX = COM + COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = COM + LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = COM + COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = COM + LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = COM + COMPILE_DYNAMIC_MAIN
    opt.CCLINK_DYNAMIC_MAIN = COM + LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = COM + opt.SPEC_COMPILE_OBJ
    opt.CCOBJ_STATIC_RTL = COM + opt.SPEC_COMPILE_OBJ
    opt.CCOBJ_STATIC_MAIN = COM + opt.SPEC_COMPILE_OBJ

    opt.CCOBJ_DYNAMIC_RTL = opt.CCOBJ_DYNAMIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_DYNAMIC_FLX = opt.CCOBJ_DYNAMIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING

    opt.CCOBJ_STATIC_RTL = opt.CCOBJ_STATIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX = opt.CCOBJ_STATIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING

    opt.CCLINK_STATIC = COM


  def detect_pthreads(self, shell, get_stdout):
    opt = self.options

    filename = self.write_src("""
#include <pthread.h>
int main(int argc, char** argv) {
  pthread_t pt;
  pthread_cancel(pt);
  return 0;
}
""", 'tmp' + os.sep + 'pthreads')

    # find out how to do pthreads
    try:
      obj = self.compile_static_main(shell, filename)
      #shell(opt.COM+" -w -c tmp"+os.sep+"pthreads.cxx -o tmp"+os.sep+"pthreads.o")
      opt.HAVE_PTHREADS = 1
    except EnvironmentError:
      opt.HAVE_PTHREADS = 0

    opt.PTHREAD_SWITCH = ''
    if opt.HAVE_PTHREADS:
      for i in [' ', '-lpthread ', '-pthread ', '-pthreads ']:
        try:
          self.link_static_program(shell, [obj], 'tmp' + os.sep + 'pthreads', LDFLAGS=i)
          #shell(opt.COM + "tmp" + os.sep + "pthreads.o -o tmp" + os.sep + "pthreads " + i)
          opt.PTHREAD_SWITCH = i
          break
        except EnvironmentError:
          pass

    if opt.HAVE_PTHREADS and not opt.PTHREAD_SWITCH:
      print "FATAL: Cannot find how to link pthreads"
      sys.exit(1)

    if opt.HAVE_PTHREADS:
      print "Posix Threads supported with", opt.PTHREAD_SWITCH
    else:
      print "Posix Threads not supported"


  def detect_dynamic_loading(self, shell, get_stdout):
    opt = self.options

    #check if we can get dlopen to work without -ldl (BSD, Cygwin don't need)
    opt.SUPPORT_DYNAMIC_LOADING = 0
    opt.HAVE_DLOPEN = 0
    opt.HAVE_LOADLIBRARY = 0
    opt.DLLIB = ""
    if opt.model in ["win32", "win64"]:
      # check if can get LoadLibrary to work
      print "LOADLIBRARY!!?"
      basename = 'tmp' + os.sep + 'win32_dummy_lib'
      # RF: This can be compiled as both c and c++ these days it seems
      # hence conditional extern "C"
      dummy_lib_filename = self.write_lib_src("""
#ifdef __cplusplus
extern "C"
#endif
__declspec(dllexport) int fred(int argc,char** argv) { return 0; }
""", basename)

      basename = 'tmp' + os.sep + 'win32_dummy_main'
      dummy_main_filename = self.write_src("""
#include <windows.h>
#include <stdlib.h>

int main(int argc,char** argv) { 
   HMODULE lib = LoadLibrary(argv[1]);
   void *fred;
   if(!lib) exit(1);
   fred = (void*)GetProcAddress(lib,"fred");
   if(!fred) exit(1);
   return 0;
}
""", basename)

      try:
        dll = self.build_shared_dll(shell, dummy_lib_filename)
        exe = self.build_shared_program(shell, dummy_main_filename)

        shell(exe + ' ' + dll)
      except EnvironmentError:
        pass
      else:
        opt.SUPPORT_DYNAMIC_LOADING = 1
        opt.HAVE_LOADLIBRARY = 1
        print "Dynamic Loading Supported (with LoadLibrary)"
    else:
      basename = 'tmp' + os.sep + 'dummy_lib'
      # RF: This can be compiled as both c and c++ these days it seems
      # hence conditional extern "C"
      # P.S. This lovingly hand crafted function doesn't seem to be called
      proggy = """
#ifdef __cplusplus
extern "C"
#endif
int fred(int argc, char** argv) { return 0; }
"""

      dummy_lib_filename = self.write_lib_src( proggy, basename)

      basename = 'tmp' + os.sep + 'dummy_main'
      dummy_main_filename = self.write_src(r"""
#include <dlfcn.h>
#include <stdlib.h>

int main(int argc, char** argv) { 
   void *lib = dlopen(argv[1],RTLD_NOW);
   void *fred = 0;
   if(!lib) exit(1);
   fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}
""", basename)

      try:
        dll = self.build_shared_dll(shell, dummy_lib_filename)
        exe = self.build_shared_program(shell, dummy_main_filename)
        shell(exe + ' ' + dll)
        #shell(opt.CCOBJ_DYNAMIC_FLX+"tmp"+os.sep+"dummy_lib.cxx -o tmp"+os.sep+"dummy_lib.o")
        #shell(opt.CCOBJ_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.cxx -o tmp"+os.sep+"dummy_main.o")
        #shell(opt.CCLINK_DYNAMIC_FLX+"tmp"+os.sep+"dummy_lib.o -o tmp"+os.sep+"dummy_lib"+opt.EXT_SHLIB)
        #shell(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.o -o tmp"+os.sep+"dlmain")
        #shell("tmp"+os.sep+"dlmain tmp"+os.sep+"dummy_lib"+opt.EXT_SHLIB)
        opt.SUPPORT_DYNAMIC_LOADING = 1
        opt.HAVE_DLOPEN = 1
      except EnvironmentError:
        try: # nope, try with -ldl
          exe = self.build_shared_program(shell, dummy_main_filename, libs=['dl'])
          #shell(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.o -o tmp"+os.sep+"dlmain -ldl")
          #shell("tmp"+os.sep+"dlmain tmp"+os.sep+"dummy_lib"+opt.EXT_SHLIB)
          opt.HAVE_DLOPEN = 1
          opt.SUPPORT_DYNAMIC_LOADING = 1
          opt.DLLIB = "dl"
          print "Dynamic Loading Supported (with -ldl)"
        except EnvironmentError:
          if opt.model == "osx":
            opt.SUPPORT_DYNAMIC_LOADING = 1  # pre 10.3, we do our own dlopen


    if not opt.SUPPORT_DYNAMIC_LOADING:
      print "DYNAMIC LOADING NOT SUPPORTED"
      print "Temporarily this is mandatory [during config debugging]"
      sys.exit(1)


  def detect_sockets(self, shell, get_stdout):
    opt = self.options

    filename = self.write_src(r"""
#include <sys/types.h>
#include <sys/socket.h>
extern "C" int accept(int s, struct sockaddr *addr, socklen_t *addrlen);
int main(int argc, char** argv) { return 0; }
""", 'tmp' + os.sep + 'have_socketlen_t')

    try:
      self.compile_static_main(shell, filename)
      #shell(opt.COM+" -w tmp"+os.sep+"have_socklen_t.cxx -o tmp"+os.sep+"dummy")
      opt.FLX_SOCKLEN_T = "socklen_t"
    except EnvironmentError:
      filename = self.write_src(r"""
#include <sys/types.h>
#include <sys/socket.h>
extern "C" int accept(int s, struct sockaddr *addr, unsigned int *addrlen);
int main(int argc, char** argv) { return 0; }
""", 'tmp' + os.sep + 'have_socketlen_t_is_uint')

      try:
        self.compile_static_main(shell, filename)
        #shell(opt.COM+" -w tmp"+os.sep+"socklen_t_is_uint.cxx -o tmp"+os.sep+"dummy")
        opt.FLX_SOCKLEN_T = "unsigned int"
      except EnvironmentError:
        filename = self.write_src(r"""
#include <sys/types.h>
#include <sys/socket.h>
extern "C" int accept(int s, struct sockaddr *addr, int *addrlen);
int main(int argc, char** argv) { return 0; }
""", 'tmp' + os.sep + 'have_socketlen_t_is_int')

        try:
          self.compile_static_main(shell, filename)
          #shell(opt.COM+" -w tmp"+os.sep+"socklen_t_is_int.cxx -o tmp"+os.sep+"dummy")
          opt.FLX_SOCKLEN_T = "int"
        except EnvironmentError:
          opt.FLX_SOCKLEN_T = "int"
    print "socklen_t =", opt.FLX_SOCKLEN_T


  def detect_kqueues(self, shell, get_stdout):
    opt = self.options

    filename = self.write_src(r"""
#include <sys/types.h>      // from the kqueue manpage
#include <sys/event.h>      // kernel events
#include <sys/time.h>       // timespec (kevent timeout)

int
main(int argc, char** argv) {
  int kq = kqueue();
  return (-1 == kq) ? 1 : 0;
}
""", 'tmp' + os.sep + 'kqt')

    # see what sort of demuxers we support. right now just testing for 
    # kqueues, to unbreak the osx 10.2.8 build. I need demux to be extracted
    # by this point, so I've added a line to configure to do that. That
    # required me to remove the flx_demux.pak's dependence on the config
    # directory (not created at configure time). also had to create a fake
    # flx_rtl_config.h in tmp/

    # now that kqueue demuxer uses condition vars and locks for a clean
    # takedown using this method of config is a nightmare before config
    # because the pthread pak file depends on the config results. for now
    # I've replaced the whole lot with a simple kqueue+main programme.
    try: 
      # basically a un*x test, note the non portable path separators and
      # gcc style switches
      self.compile_static_main(shell, filename)
      #cmd = opt.COM+" tmp/kqt.cxx -o tmp/kqt"
      #print "CMD IS " + cmd
      #shell(cmd)
      opt.HAVE_KQUEUE_DEMUXER = 1
    except EnvironmentError:
      opt.HAVE_KQUEUE_DEMUXER = 0

    print "HAVE_KQUEUE_DEMUXER =", opt.HAVE_KQUEUE_DEMUXER


  def detect_strip(self, shell, get_stdout):
    opt = self.options
    
    # see if we have strip: it isn't considered essential
    filename = self.compile_dummy_main(shell)
    if opt.STRIP:
      shell(opt.STRIP + filename)
    else:
      opt.STRIP = "#strip "


  def detect_ar(self, shell, get_stdout):
    opt = self.options

    # see if we have ar
    filename = self.compile_dummy_main(shell)
    shell(opt.AR + "tmp" + os.sep + "dummy.a " + filename)

    # see if we have ranlib, it isn't considered essential
    # (a totally brain dead Unix idea: AR should do this)
    try:
      shell(opt.RANLIB + "tmp" + os.sep + "dummy.a")
    except EnvironmentError:
      opt.RANLIB = "#ranlib "


  def detect_compiler_options(self, shell, get_stdout):
    self.detect_warning_flags(shell, get_stdout)
    self.detect_PIC(shell, get_stdout)
    self.construct_compiler_commands(shell, get_stdout)
    self.detect_dynamic_loading(shell, get_stdout)


  def check_options(self, shell, get_stdout):
    self.detect_named_registers(shell, get_stdout)
    self.detect_computed_gotos(shell, get_stdout)
    self.detect_pthreads(shell, get_stdout)
    self.detect_sockets(shell, get_stdout)
    # could just replace this with header_exists("sys/event.h") but
    # it ain't broke.
    self.detect_kqueues(shell, get_stdout)
    self.options.HAVE_POLL = self.check_header_exists(shell,"poll.h")
    # RF: no one freak out about that slash, ok? Epoll's not about to
    # show up in windows or os/2 or PDP/11 or ebcdic or whatever.
    self.options.HAVE_EPOLL = self.check_header_exists(shell,"sys/epoll.h")
    # nice one, Sun, no one else would ever call a header file "port.h"
    self.options.HAVE_EVTPORTS = self.check_header_exists(shell,"port.h")
    print "HAVE_POLL =", self.options.HAVE_POLL
    print "HAVE_EPOLL =", self.options.HAVE_EPOLL
    print "HAVE_EVTPORTS =", self.options.HAVE_EVTPORTS

    self.detect_strip(shell, get_stdout)
    self.detect_ar(shell, get_stdout)

  ####

  def link_thing(self, *args, **kwds):
    opt = self.options
    
    # strip off the lib from the start of the libraries
    libs = []
    for lib in kwds.get('libs', []):
      if lib[0:3] == 'lib': lib = lib[3:]
      libs.append(lib)
    kwds['libs'] = libs

    if opt.__dict__.get('HAVE_PTHREADS', 0): 
      kwds['LDFLAGS'] = kwds.get('LDFLAGS', '') + ' ' + opt.PTHREAD_SWITCH

    return apply(c_cxx_base.link_thing, (self,) + args, kwds)


  def link_shared_thing(self, *args, **kwds):
    if self.options.DLLIB:
      libs = kwds.get('libs', [])[:]
      libs.append(self.options.DLLIB)
      kwds['libs'] = libs

    return apply(self.link_thing, args, kwds)


  def report_config(self):
    c_cxx_base.report_config(self)
    opt = self.options

    print
    if opt.SUPPORT_DYNAMIC_LOADING:
      if opt.HAVE_DLOPEN:
        if opt.DLLIB:
          print "Dynamic Loading Supported : with dlopen() in -l", opt.DLLIB
        else:
          print "Dynamic Loading Supported : with dlopen() [native]"
      if opt.HAVE_LOADLIBRARY:
          print "Dynamic Loading Supported : with LoadLibrary"
    else:
      print "Dynamic Loading               : NOT SUPPORTED"
    print

@h = tangler("flxbuild/gcc_class.py")
@select(h)
from flxbuild.c_base import c_base
from flxbuild.gnu_mixin import gnu_mixin

class gcc(gnu_mixin, c_base):
  DEFAULT_COM = 'gcc'

  def check_options(self, shell, get_stdout):
    c_base.check_options(self, shell, get_stdout)
    gnu_mixin.check_options(self, shell, get_stdout)


@h = tangler("flxbuild/gxx_class.py")
@select(h)
import string
import os
import sys
import flxbuild
from flxbuild.cxx_base import cxx_base
from flxbuild.gnu_mixin import gnu_mixin

class gxx(gnu_mixin, cxx_base):
  DEFAULT_COM = 'g++'
  
  def check_options(self, shell, get_stdout):
    cxx_base.check_options(self, shell, get_stdout)
    gnu_mixin.check_options(self, shell, get_stdout)

    self.detect_gxx_template_extensions(shell)


  def detect_gxx_template_extensions(self, shell):
    # find if we have g++ supported ext/ with STL extensions
    try:
      self.build_string_program(shell, r"""
#include <iostream>

// we only bother to check the include file exists
#include <ext/hash_map>
using namespace __gnu_cxx;

int main(int argc,char** argv) { 
   return 0;
}
""", 'tmp' + os.sep + 'gnu_hash')
      #shell(COM+"tmp"+os.sep+"gxx_hash.cxx -o tmp"+os.sep+"gxx_hash")
      #shell("tmp"+os.sep+"gxx_hash")
      self.options.HAVE_STL_GNU_CXX = 1
      print "Gnu ext/ templates supported"
    except EnvironmentError:
      self.options.HAVE_STL_GNU_CXX = 0

@h = tangler("flxbuild/msvc_mixin.py")
@select(h)
import string
import os
import sys

import flxbuild
from flxbuild.c_cxx_base import c_cxx_base

class msvc_mixin:
  DEFAULT_COM = 'cl '
  DEFAULT_AR = 'lib '

  def set_options(self, **kwds):
    """these options are model dependent and have to
    be supplied by the client"""

    apply(c_cxx_base.set_options, (self,), kwds)

    opt = self.options

    # RF: add /GR to generate RTTI information, if this isn't on, we get
    # access violations when doing dynamic_casts. Of course, these access
    # violations are thrown as exceptions, which can be caught with
    # catch(std::exception& e). we also don't want the logo
    # OF COURSE now /GR will have no sense if this happens to be a
    # c compiler. let's hope it doesn't error out.
    opt.COM = self.DEFAULT_COM + "/nologo /GR "
    opt.AR = self.DEFAULT_AR + "/nologo "

  ########

  def detect_model(self, shell, get_stdout):
    c_cxx_base.detect_model(self, shell, get_stdout)

    if self.options.model == "detect": 
      self.options.model = "win32" 


  def detect_compiler_options(self, shell, get_stdout):
    self.detect_warning_flags(shell)
    self.construct_compiler_commands(shell, get_stdout)


  def check_options(self, shell, get_stdout):
    opt = self.options
    COM = opt.COM

    opt.RANLIB = "@rem nothing" # RF: better than none.
    opt.SUPPORT_DYNAMIC_LOADING = 1
    opt.SPEC_COMPILE_OBJ = "/c "
    opt.SPEC_OBJ_FILENAME = "/Fo"
    opt.SPEC_EXE_FILENAME = "/Fe"
    opt.SPEC_DEFINE = "/D"
    opt.SPEC_INCLUDE = "/I"
    opt.SPEC_LIBPATH = "/LIBPATH:"
    opt.SPEC_LIB = "/DEFAULTLIB:"
    opt.SPEC_AR_OUT_FILENAME = "/OUT:"
    opt.DEBUG_FLAGS = "/Yd /Zi /RTC "
    opt.OPTIMISE = "/Ox /DNDEBUG "

    opt.EXT_LIB = ".lib"
    opt.EXT_EXE= ".exe"
    opt.EXT_SHLIB = ".dll"
    opt.EXT_DYLIB = opt.EXT_SHLIB
    opt.EXT_STATIC_OBJ = "_static.obj"
    opt.EXT_SHARED_OBJ = "_dynamic.obj"

    opt.HAVE_GNU_X86 = 0
    opt.HAVE_GNU_X86_64 = 0
    opt.USE_REGPARM3 = 0
    opt.HAVE_CGOTO = 0
    opt.HAVE_ASM_LABELS = 0
    opt.HAVE_STL_GNU_CXX = 0

    opt.HAVE_DLOPEN = 0
    opt.DLLIB = ""

    # where to put the rtl: Cygwin requires the dll be in the PATH
    opt.SHLIB_DIR = "bin"
    print "rtl located in bin directory"
  

  def detect_warning_flags(self, shell):
    # RF: silencing all warnings /w has masked some really insidious bugs
    # (like dynamic_casts whilst RTTI was disabled). does the offset warning
    # even apply to vs toolchain? I don't think so, however, there is one
    # warning, that about missing delete for the custom operator new,
    # the follow /wd<n> should silence that warning.
    # self.options.NO_INVALID_OFFSETOF_WARNING = "/w "
    self.options.NO_INVALID_OFFSETOF_WARNING="/wd4291 "


  def construct_compiler_commands(self, shell, get_stdout):
    opt = self.options
    COM = opt.COM
    # RF: /MT (link with multithreaded clib, LIBCMT.LIB) for static builds
    # and /MD for dynamic (multithreaded dynamic clib, MSVCRT.LIB).
    # This last one's important as it means that not only is malloc threadsafe,
    # but the SAME allocator is shared between the app and its dynamic libs.
    # Without this, pushing an fthread in flx_run and popping it in
    # flxdynamic_lib is actually an insidious error. Note that /M* flags are
    # not just for link time, they seem to need to be passed to the compilation
    # phase as well. To run with debug versions of clib, try /MDd, /MTd and
    # /LDd when linking dynamic libs. Phew.
    # RF: update: Max suggested trying /MD (threadsafe dll clib) for all
    # builds, including static. I forget why, perhaps for uniformity. Anyway,
    # it works fine. It might have implications for folks who link against
    # static libs (folks like me), but I'm using nocygwin, so, yknow, eh.
    # P.S. Erick, if ever again you checkin any changes to this that you
    # haven't first tested, I'll kill you.
    COMPILE_DYNAMIC_RTL = "/MD /c /EHs "
    LINK_DYNAMIC_RTL = "/MD /LD "
      
    COMPILE_DYNAMIC_MAIN = "/MD /c /EHs "
    LINK_DYNAMIC_MAIN = "/MD "

    COMPILE_DYNAMIC_FLX = "/MD /c /EHs "
    LINK_DYNAMIC_FLX = "/MD /LD "

    opt.CCOBJ_DYNAMIC_FLX = COM + COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = COM + LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = COM + COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = COM + LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = COM + COMPILE_DYNAMIC_MAIN
    opt.CCLINK_DYNAMIC_MAIN = COM + LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = COM + "/MD /EHs /c "
    opt.CCOBJ_STATIC_RTL = COM + "/MD /EHs /c "
    opt.CCOBJ_STATIC_MAIN = COM + "/MD /EHs /c "

    opt.CCOBJ_DYNAMIC_RTL = opt.CCOBJ_DYNAMIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_DYNAMIC_FLX = opt.CCOBJ_DYNAMIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_RTL = opt.CCOBJ_STATIC_RTL + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX = opt.CCOBJ_STATIC_FLX + opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCLINK_STATIC = COM + "/MD "

  ########

  def link_thing(self, *args, **kwds):
    kwds['LDFLAGS'] = kwds.get('LDFLAGS', '')
    # RF: hack to get /link before all other link directives,
    # including the libraries themselves and their paths.
    self.options.PRE_LINK_FLAGS = '/link '

    return apply(c_cxx_base.link_thing, (self,) + args, kwds)

  ########

  def report_config(self):
    c_cxx_base.report_config(self)
    opt = self.options

    print
    if opt.SUPPORT_DYNAMIC_LOADING:
      print "Dynamic Loading Supported               : [Windows native]"
    else:
      print "Dynamic Loading                         : NOT SUPPORTED"

    print
    if opt.HAVE_ISNAN_IN_CMATH:
      print "NaN Support in                          : <cmath>"
    if opt.HAVE_ISNAN_IN_IEEEFP:
      print "NaN Support in                          : <ieeefp.h>"
    if not opt.HAVE_ISNAN_IN_IEEEFP and not opt.HAVE_ISNAN_IN_CMATH:
      print "NaN                                     : NOT SUPPORTED"
    print "**********************************************"


@h = tangler("flxbuild/msvcc_class.py")
@select(h)
from flxbuild.c_base import c_base
from flxbuild.msvc_mixin import msvc_mixin

class msvcc(msvc_mixin, c_base):
  # RF: /TC is screwing up the link stage, treating the object file
  # as a .c file. Taking it away and hoping that cl can figure it out.
  # DEFAULT_COM = 'cl /TC '
  DEFAULT_COM = 'cl '

  def check_options(self, shell, get_stdout):
    msvc_mixin.check_options(self, shell, get_stdout)
    c_base.check_options(self, shell, get_stdout)

@h = tangler("flxbuild/msvcxx_class.py")
@select(h)
from flxbuild.cxx_base import cxx_base
from flxbuild.msvc_mixin import msvc_mixin

class msvcxx(msvc_mixin, cxx_base):
  # RF: this might be a good place to put the RTTI switch zzz
  # /TP was forcing the link stage to interpret the .obj files as c++.
  # DEFAULT_COM = 'cl /TP '
  DEFAULT_COM = 'cl '

  def check_options(self, shell, get_stdout):
    msvc_mixin.check_options(self, shell, get_stdout)
    cxx_base.check_options(self, shell, get_stdout)

@h = tangler("flxbuild/ocaml_class.py")
@select(h)
#---------------------------------------------------
# discover which ocaml compilers are available
import string
import os

from flxbuild.flxutil import MakeError
from flxbuild.compiler_base import compiler_base

class ocaml(compiler_base):
  def autodetect(self, shell, get_stdout):
    opt = self.options

    try: # check if the client bootstrapped the native code compiler
      shell('ocamlopt.opt')
      opt.OCAMLCC = 'ocamlopt.opt '
      opt.OCAMLLEX = 'ocamllex.opt '
      opt.OCAMLYACC = 'ocamlyacc '
      opt.NATIVE_CODE_COMPILER = 1
    except MakeError:
      try: # check if the client has unbootstrapped native code compiler
        shell('ocamlopt')
        opt.OCAMLCC = 'ocamlopt '
        opt.OCAMLLEX = 'ocamllex '
        opt.OCAMLYACC = 'ocamlyacc '
        opt.NATIVE_CODE_COMPILER = 1
      except MakeError:
        opt.NATIVE_CODE_COMPILER = 0
        try: # check if the client has ocaml at all ..
          shell('ocamlc')
          opt.OCAMLCC = 'ocamlc '
          opt.OCAMLLEX = 'ocamllex '
          opt.OCAMLYACC = 'ocamlyacc '
          opt.OCAMLDOC = 'ocamldoc '
        except MakeError:
          print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
          opt.OCAMLCC = '#ocamlc '
          opt.OCAMLLEX = '#ocamllex '
          opt.OCAMLYACC = '#ocamlyacc '

    try: # check if there is a native code version of the bytecode compiler
      shell('ocamlc.opt')
      opt.OCAMLB = 'ocamlc.opt '
    except MakeError:
      try: # check if the client has ocaml at all
        shell('ocamlc')
        opt.OCAMLB = 'ocamlc '
      except MakeError:
        print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
        opt.OCAMLB = '#ocamlc '

    try:
      shell('ocamldoc.opt')
      opt.OCAMLDOC = 'ocamldoc.opt '
    except MakeError:
      try:
        shell('ocamldoc')
        opt.OCAMLDOC = 'ocamldoc '
      except MakeError:
        print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
        opt.OCAMLDOC = '#ocamldoc '

    # set the default ocaml compiler
    if opt.OCAMLCC[0] != '#':
      opt.OCAMLC = opt.OCAMLCC
    else:
      opt.OCAMLC = opt.OCAMLB

    opt.OCAMLCP = "ocamlcp "
    # where the ocaml is installed
    result,x = get_stdout(opt.OCAMLC + " -where")
    if result:
      print "Woops, Can't run",opt.OCAMLC
      sys.exit(1)
    opt.OCAML_INCLUDE_DIRECTORY= x[0][0:-1]

    result,x = get_stdout(opt.OCAMLB + " -v")
    if result:
      print "Woops, Can't run",opt.OCAMLB
      sys.exit(1)
    x=x[0][0:-1]
    opt.OCAMLB_DESCRIPTION,y = string.split(x,",")
    y = string.strip(y)
    opt.OCAML_VERSION=y

    result,x = get_stdout(opt.OCAMLC + " -v")
    if result:
      print "Woops, Can't run",opt.OCAMLC
      sys.exit(1)
    x=x[0][0:-1]
    opt.OCAMLC_DESCRIPTION,y = string.split(x,",")
    y = string.strip(y)
    if opt.OCAML_VERSION <> y:
      print "Inconsistent Ocaml tool versions"
      print "Ocaml: bytecode compiler",opt.OCAML_VERSION
      print "Ocaml: compiler         ",y
      sys.exit(1)
    warn=' -w yzex -warn-error FDPSU '
    try:
      f = open('tmp'+os.sep+'camldummy.ml','w')
      try:
        f.write('print_endline "OK";;\n')
      finally:
        f.close()
    except (IOError, OSError):
      pass
    else:
      result,x = get_stdout(opt.OCAMLC + warn+'tmp'+os.sep+'camldummy.ml')
      if not result:
        opt.OCAMLB = opt.OCAMLB + warn
        opt.OCAMLC = opt.OCAMLC + warn
    
  def report_config(self):
    opt = self.options

    print
    print "OCAML tool configuration"
    print "************************"
    print
    print "Ocaml Version",opt.OCAML_VERSION
    if opt.NATIVE_CODE_COMPILER:
      print "Using Native code Compiler"
    else:
      print "Using Bytecode Compiler"
    print "Lexer generator .............. ",opt.OCAMLLEX
    print "Parser generator ............. ",opt.OCAMLYACC
    print "Bytecode and Interface compiler",opt.OCAMLB
    print "   ",opt.OCAMLB_DESCRIPTION
    print "Compiler ..................... ",opt.OCAMLC
    print "   ",opt.OCAMLC_DESCRIPTION
    print "Profiling Compiler ........... ",opt.OCAMLCP
    print "Document Generator ........... ",opt.OCAMLDOC
    print "C include directory .......... ",opt.OCAML_INCLUDE_DIRECTORY
    print
