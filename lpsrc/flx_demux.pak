@head(1,'demux')
$Log$
Revision 1.21  2006/04/23 06:09:15  rfistman
fixed bug in async win32 ReadFile/WriteFile code - wasn't handling
ERROR_IO_PENDING properly. Was also not opening files with FILE_FLAG_OVERLAPPED
added actual io to windows named pipe example

Revision 1.20  2006/04/22 07:43:37  rfistman
taking down kqueue event source was blocking on osx 10.4.
fixed now, but not perfect yet. similar problems exist with other sources,
giving undefined behaviour (I believe) on takedown. watch this space.

Revision 1.19  2006/04/20 01:57:17  rfistman
factored out self_piper class. will be used in kqueue_demuxer and an
eventual epoll demuxer.

Revision 1.18  2006/04/08 08:18:34  rfistman
fixed up flx_listener, working on portable regression test for tcp
bug still at large in nocygwin flx_accept - hope it's portable!

Revision 1.17  2006/04/08 03:53:44  skaller
Detect vsnprintf.. some Windows don't provide it even though
MSDN says it is available. The MS variation when available
doesn't work correctly anyhow.

Revision 1.16  2006/03/07 04:22:36  skaller
Termination in presence of spawned pthreads should now
be working, using new ts_locker class. Exception handling
on per thread basis not implemented yet.

Revision 1.15  2006/03/06 15:08:08  skaller
Cygwin and MinGW builds.

Revision 1.14  2006/03/06 13:16:16  skaller
Fix library builds so exports and imports are properly
distinguished on a library by library basis.

Revision 1.13  2006/03/06 01:29:29  skaller
spawn_pthread: init works

Revision 1.12  2006/03/04 09:50:42  rfistman
added "suck it and see" for kqueues.

Revision 1.11  2006/03/04 04:26:41  rfistman
making demux configure more "suck it and see". temporarily disabled kqueues
whilst fixing osx 10.2 build.

Revision 1.10  2006/03/03 04:51:24  rfistman
removed the following line from the kqueues code (was breaking the mac build)
don't know what it means, but there are no threads in the kqueue code.:
using namespace flx::pthread;

Revision 1.9  2006/03/02 17:52:51  skaller
Fix flx_pkgconfig to handle linker switches

Revision 1.8  2006/03/02 02:41:39  skaller
Fixes for Win32/MSVC++ build.

Revision 1.7  2006/03/01 14:52:28  skaller
Cygwin needed one extra lib dependency.

Revision 1.6  2006/02/28 02:07:13  skaller
Refactor demux into demux + pthread.

Revision 1.5  2006/02/26 06:39:36  skaller
Fix flx_pkgconfig to conform to new spec.

Revision 1.4  2006/02/25 20:38:12  skaller
Upgrade flx_pkgconfig

Revision 1.3  2006/02/23 19:33:01  skaller
More fiddling with build system

Revision 1.2  2006/02/22 19:00:04  rfistman
oops, was passing ULONG as ULONG_PTR. Thanks to 64bit compiler for
poinnting this out.

Revision 1.1  2006/02/22 17:36:48  skaller
Rename some files.. more coming. Make RTL modules full .paks

Revision 1.54  2006/02/21 05:46:45  skaller
Fix wrong link flag tag.

Revision 1.53  2006/02/20 09:21:24  skaller
Mingw/nocygwin support

Revision 1.52  2006/02/20 02:16:44  rfistman
removed recursive locks from the threadsafe select demuxer and from
the code in general.

Revision 1.51  2006/02/19 16:04:57  skaller
Win32 build changes..seems to work now

Revision 1.50  2006/02/19 14:02:51  skaller
Windows sys libs with right switches

Revision 1.49  2006/02/18 16:30:48  skaller
More work on new package manager.

Revision 1.48  2006/02/17 09:38:31  skaller

conditionalised recursive mutex (to be removed)
fixed windows lib_requires (added lib prefix)

Revision 1.47  2006/02/16 23:39:11  rfistman
fixed cygwin hang in posix tests. cygwin wakes select with an error flag
when you shutdown a socket. other impls seem to wake select, but with no
error.

Revision 1.46  2006/02/16 15:09:45  skaller
MSVC++ package manager

Revision 1.45  2006/02/16 07:51:40  skaller
Replace pkg-config with a Felix program flx_pkgconfig.
Make sure to build it in a timely manner, since flx script
now depends on it.

Revision 1.44  2006/02/15 10:54:08  skaller
Build time packaging system.

Revision 1.43  2006/02/15 04:10:56  rfistman
working on thread safe select demuxer (ts_select_demuxer). that should
fix cygwin probs. and as yet other undiscovered problems.

Revision 1.42  2006/02/13 05:47:40  rfistman
readded recursive flag to (portable) mutexes

Revision 1.41  2006/02/12 06:51:30  rfistman
added WSAID_CONNECTEX and LPFN_CONNECTEX definitions for ming (nocygwin) target
now conditionally define EAGAIN in posix compat layer because ming seems to
have it.

Revision 1.40  2006/02/11 22:12:30  skaller
Allow assigning constructor index to enums.

Revision 1.39  2006/02/09 21:05:33  skaller
Fixed sdl to use polling.

Revision 1.38  2006/02/09 07:53:27  skaller
Fix windows semaphores.

Revision 1.37  2006/02/07 15:55:06  skaller
Added portable semaphores and a monitor class to demux.

Revision 1.36  2006/02/06 11:05:18  skaller
Timed wait on condition variable.

Revision 1.35  2006/02/06 06:50:01  skaller
Added pthread_cond_timedwait and pthread_cond_uswait functions
to condition variables. The latter is my own invention, it waits
for a specific interval in micro-seconds. The later is more
efficient on Windows when you want to wait for an interval,
since this is the native method. Otherwise you need to first
obtain the time of day, do a nasty calculation .. and then
the timedwait function will undo that, resulting in two
unnecessary and expensive system calls.

Revision 1.34  2006/02/04 11:34:36  skaller
Portable demux stuff, Win32 version

Revision 1.33  2006/02/04 10:35:55  skaller
Portable thread sync stuff

Revision 1.31  2006/02/02 18:52:35  skaller
Reorganise demux a bit

Revision 1.30  2006/01/31 04:29:17  rfistman
added demux level "sleep until" code. Not quite right yet (posix format
of current time in double isn't so good as it's measured from the 70s in
microseconds, so macroscopic sleep amounts get swamped by the magnitude
of "now"), so felix binding coming soon.

Revision 1.29  2006/01/29 07:07:21  skaller
fixed visual studio build after demux merge

Revision 1.28  2006/01/29 05:58:08  rfistman
fixed windows build (ming nocygwin) after merge

Revision 1.27  2006/01/29 02:53:16  rfistman
fixed missing epoll header for linux.:w

Revision 1.26  2006/01/29 02:17:29  rfistman
using latest demux, added epoll to flx_run (for linux). bugs fixed.

Revision 1.25  2006/01/26 10:04:28  rfistman
fixed failure to wake fthread after connects that finish immediately.
this fast connect only ever shows up on solaris, so full marks to them.

Revision 1.24  2006/01/21 23:45:10  rfistman
fixed potential leak and warning in posix_timer_queue constructor

Revision 1.23  2006/01/16 01:25:43  rfistman
factored faio posix accept and connect back demux as control blocks
removed pthread cancel from code - implicit cancel points are no longer used.
instead the threads are convinced to return from their mains via specially
formatted inputs.

Revision 1.22  2006/01/13 05:16:50  rfistman
made worker_fifo portable

Revision 1.21  2006/01/11 01:16:32  rfistman
added win_timer_queue to demux

Revision 1.20  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.


@h=tangler('tmp/flx_demux_config.hpp')
@select(h)
// This is a fake flx_demux_config.h to be used at config time, before
// the rtl proper exists. It contains just enough info to compile
// a few of the demuxers.
#define DEMUX_EXTERN

@h=tangler('rtl/flx_demux_config.hpp')
@select(h)
#ifndef __FLX_DEMUX_CONFIG_GUARD__
#define __FLX_DEMUX_CONFIG_GUARD__
#include "flx_rtl_config.hpp"
#ifdef BUILD_DEMUX
#define DEMUX_EXTERN FLX_EXPORT
#else
#define DEMUX_EXTERN FLX_IMPORT
#endif
#endif

@h=tangler('demux/demux_demuxer.hpp')
@select(h)
#ifndef __DEMUXER__
#define __DEMUXER__
#include <flx_demux_config.hpp>

namespace flx { namespace demux {

typedef struct {
  char*   buffer;           // set on input
  long    buffer_size;        // set on input
  long    bytes_written;        // set on input and output

  bool    finished() { return bytes_written == buffer_size; }
}sel_param;

// rename ...
// read/write flags - they're no longer mutually exclusive
enum { PDEMUX_READ = 1, PDEMUX_WRITE = 2 };


// ********************************************************
/// Demux base.
// ********************************************************
class DEMUX_EXTERN demuxer {
protected:
  // wait for outstanding events. may return before given events, so
  // check your conditions. I've turned of all the timeouts that cause
  // this, but don't rely on it!
  // FACTOR. Give poll a greedy interface
  virtual void  get_evts(bool poll) = 0;

  bool quit_flag; // for clean takedown
public:
  demuxer() : quit_flag(false) {}
  virtual ~demuxer() {}

  void wait() { get_evts(false); }
  void poll() { get_evts(true); }

  // ask users of demuxer to exit. not guarded. be sure to either set & get
  // this flag from only one thread (with a wait/wakeup callback - see
  // self_piper) or by using a memory barrier.
  bool get_quit_flag() { return quit_flag; }
  void set_quit_flag(bool f) { quit_flag = f; }
};
}} // namespace demux, flx
#endif  /* __DEMUXER__ */

@h=tangler('demux/demux_epoll_demuxer.hpp')
@select(h)
#ifndef __EPOLL_DEMUXER__
#define __EPOLL_DEMUXER__

#include <flx_demux_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {
// epoll allows only one event per socket - it does not differentiate
// on the awaited operation (read/write), however it does let you wait
// on any combination (I think)

// ********************************************************
/// epoll based demuxer
// ********************************************************

class DEMUX_EXTERN epoll_demuxer : public posix_demuxer {
  int   epoll_fd;

  // be careful of this - don't let it create race conditions
  // should probably only be called by wait = in one thread only (check)
  // this removes ALL outstanding events for s.
  void  remove_wakeup(int s);

  virtual void  get_evts(bool poll);
public:
  epoll_demuxer();
  virtual ~epoll_demuxer();
  
  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_evtport_demuxer.hpp')
@select(h)
#ifndef __EVTPORT_DEMUXER__
#define __EVTPORT_DEMUXER__

// driver for solaris 10 event port notifications

#include "demux_posix_demuxer.hpp"

// Event ports are oneshot by default (I don't know if you can change that).
// Events are tracked only by fd and not fd*event, so you cannot add
// separate wakeups for read and write with the same fd and hope for it to
// work as the later one will overwrite the earlier, fodder for race
// conditions. This impl satisfies 1-1 wakeup to request ratio.

// I don't know if evtports can be waited upon by other evtports

// OBS.
// after removing the threads from the demuxers/event sources
// how are the two half demuxers supposed to work? They used to
// have three threads and now they have one. How can two waits be
// done in one thread? I could add one half_demuxer's evtport to
// the other's and wait on that. Would that work? Otherwise I'll
// have to start a thread, which screws things up a bit. Could do
// that and communicate back to single thread via a waitable queue.
// could have three half-demuxers, add them both to third and call
// their wait functions depending on the outer's wait result.

class DEMUX_EXTERN evtport_demuxer : public posix_demuxer {
    int     evtport;

  // I think evtports only track socket the socket and not
  // socket*operation, so there's only one remove
  void remove_wakeup(int s);

    virtual void  get_evts(bool poll);
public:
  evtport_demuxer();
  virtual ~evtport_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};


}} // namespace demux, flx
#endif

@h=tangler('demux/demux_iocp_demuxer.hpp')
@select(h)
#ifndef __IOCP_DEMUXER__
#define __IOCP_DEMUXER__

#include <flx_demux_config.hpp>
#include <Windows.h>

#include "demux_demuxer.hpp"
#include "pthread_sleep_queue.hpp"


namespace flx { namespace demux {

// not here? returns INVALID_SOCKET on failure.
// if *io_port == 0, then a port is chosen and returned in *io_port
SOCKET DEMUX_EXTERN create_listener_socket(int* io_port, int backlog);
// these two probably not used. move to wsockety.h
SOCKET DEMUX_EXTERN nice_accept(SOCKET listener);
SOCKET DEMUX_EXTERN nice_connect(const char* addr, int port);
int DEMUX_EXTERN set_tcp_nodelay(int s, int disable_nagle);

// ********************************************************
/// make sure you instantion ONE (1) of these before using winsock
// ********************************************************
class DEMUX_EXTERN winsock_initer
{
public:
  winsock_initer();
  ~winsock_initer();
};

// ********************************************************
/// iocp_wakeup base class for users of iocp_demuxer
/// becoming an overlapped call control block
// ********************************************************
class DEMUX_EXTERN iocp_wakeup {
protected:            // folks need to use these in win 32 calls
  OVERLAPPED  ol;
  // store wakeup error here?
  // I didn't want this to be felixy, useful though.
  void clear_overlapped();  // zero the OVERLAPPED structure
public:
  // 2 possibilities for piggybacking data. who could ask for more?
  // udat = per iocp association, olp = per overlapped function call.
  // why don't I need this in the posix version?
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err) = 0;

  // start overlapped async operation. returns true if it finished
  // immediately. in this case there will be no iocp_finished wakeup.
  // assumes all args ready for call.
  virtual bool start_overlapped() = 0;

  // retrieves this pointer from OVERLAPPED pointer
  static iocp_wakeup* from_overlapped(LPOVERLAPPED olp);
};

// ********************************************************
// ********************************************************
class DEMUX_EXTERN iocp_demuxer : public demuxer {
  HANDLE    iocp;     // the io completion queue

  void get_evts(bool poll);
public:
  iocp_demuxer();
  virtual ~iocp_demuxer();

  // udat is the per IOCP object user cookie & the overlapped pointer
  // is the per overlapped operation cookie (sort of), so in the case
  // of acceptex, udat is set when the listener is associated with the
  // iocp and is passed to the subsequent acceptex iocp wakeups.
  // probably won't be used very often
  // the OVERLAPPED retrieved from the iocp is assumed to be part of
  // an iocp_wakeup - beware! returns 0 on success, -1 on failure.
  int associate_with_iocp(HANDLE obj, ULONG_PTR udat);

};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_kqueue_demuxer.hpp')
@select(h)
#ifndef __KQUEUE_DEMUXER__
#define __KQUEUE_DEMUXER__

#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// ********************************************************
/// kqueue demuxer for BSD
// ********************************************************
class DEMUX_EXTERN kqueue_demuxer : public posix_demuxer {
  int   kq;
protected:
  // this could just be passed the socket_wakeup, if it stored
  // the flags. Those flags are also set, though, which would
  // create a race condition. In and out flags?

  int add_kqueue_filter(socket_wakeup* sv, short filter);
  int remove_kqueue_filter(int s, short filter);

  int remove_socket_wakeup(int s, int flags);
  void get_evts(bool poll);
public:
  kqueue_demuxer();
  virtual ~kqueue_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_pfileio.hpp')
@select(h)
#ifndef __PFILEIO__
#define __PFILEIO__
#include <flx_demux_config.hpp>

#include "demux_demuxer.hpp"
#include "pthread_sleep_queue.hpp"
#include "pthread_mutex.hpp"
// #include <sys/types.h> // off_t (don't have flx iface to this yet)
              // can just add new constructor
#include "pthread_work_fifo.hpp"
namespace flx { namespace demux {

// ********************************************************
/// like another event source. this is basically a wrapped pread, pwrite
/// should probably be derived from posix_wakeup or something like that.
/// or have the same signature. abstract - users overload "finished
// ********************************************************
class DEMUX_EXTERN fileio_request : public flx::pthread::worker_task
{
  long    offset;   // make this a proper offset (64bit)
  // off_t    offset; // in: offset, for use with pread, pwrite
  int     fd;     // in: fd in question
  bool    read_flag;  // in: read else write

  int     err;    // out:
public:
  // public so it can be got in felix
  sel_param pb;   // in & out: what you want, what you get (64bit len?)

  virtual ~fileio_request(); // c++ should do this automatically
  fileio_request();       // flx linkage
  fileio_request(int f, char* buf, long len, long off, bool rd);

  virtual void doit();      // sync
};

// ********************************************************
// could do separate threads for in & out. or implement some form of cache.
// ********************************************************
class DEMUX_EXTERN pasync_fileio : public flx::pthread::worker_fifo
{
public:
  pasync_fileio(int n,int m) : worker_fifo(n,m) {}
  // compatibility only. don't need this class anymore.
  void add_fileio_request(fileio_request* req) { add_worker_task(req); } 
};

}} // namespace demux, flx
#endif  // __PFILEIO__

@h=tangler('demux/demux_posix_demuxer.hpp')
@select(h)
#ifndef __POSIX_DEMUXER__
#define __POSIX_DEMUXER__

// base classes for posix style demuxers

#include "demux_demuxer.hpp"

namespace flx { namespace demux {
class DEMUX_EXTERN posix_demuxer;            // fwd decl

// abc
class DEMUX_EXTERN posix_wakeup {
public:
  virtual ~posix_wakeup() {}

  // when called, the wakeup has finished and been removed.
  virtual void wakeup(posix_demuxer& demux) = 0;
};

class DEMUX_EXTERN socket_wakeup : public posix_wakeup {
public:
  int   s;                // the non blocking socket
  int   wakeup_flags;         // set on wakeup, r/w or both

  socket_wakeup() : s(-1) {}
};

class DEMUX_EXTERN posix_demuxer : public demuxer {
protected:
  
public:
  virtual ~posix_demuxer();

  // posix style sockets. for reading and writing (but not both at once
  // for the same socket_wakeup) you are guaranteed to receive only one
  // wakeup per call to this function when you call wait.
  // returns -1 if no wakeup is coming and zero if one is.
  // For simultaneous reading and writing you may get two wakeups,
  // that is, it may violate the "one shot" rule. Ignoring for now,
  // as it's not a common use. This makes it undefined behaviour.
  // wakeup is owned by the demuxer until its wakeup is called,
  // so treat it with kid gloves, i.e. don't mess with it.
  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags) = 0;

  // to be called when we can read & write without blocking
  // return true if connection closed, update pb
  // sort of a strange place to have this..., more a socket wakeup
  // thing, even if static
  static bool   socket_recv(int s, sel_param* pb);
  static bool   socket_send(int s, sel_param* pb);
};

// some handy control blocks for common non-blocking socket operations
// note that they "fortuitously" both have start methods. hmm.
// a socket io one could be handy here.

// this one's restartable (makes sense for listener sockets)
class DEMUX_EXTERN accept_control_block : public socket_wakeup {
public:
  int   accepted;   // accepted socket (out)
  int   socket_err;   // the error, if acceptee == -1, else 0 (out)
  
  accept_control_block() : accepted(-1), socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);
};

class DEMUX_EXTERN connect_control_block : public socket_wakeup {
public:
  int     socket_err;   // outgoing error (on start or wake)
  // this should probably be a sockaddr type
  const char* addy;     // addr (dotted quad) (in)
  int     p;        // port (in)
  
  connect_control_block() : socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);

  // oops, can't check for s != -1 as it's always there.
  // was always "finished" and so I started io, losing the first wakeup
  // on epoll evtsrc. Is this right, or should it be != EINPROGRESS?
  // keep in sync with iocp version. give socket_err initial definition
  // that works with this?
  bool finished() { return ( 0 == socket_err); }
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_select_demuxer.hpp')
@select(h)
#ifndef __SELECT_DEMUXER__
#define __SELECT_DEMUXER__

#include "demux_posix_demuxer.hpp"
#include <sys/types.h>    // for sys/select.h on osx
#include <sys/select.h>   // for fd_set
//#include <sys/time.h>   // GUSI WTF?

// Unlike the other demuxers, this one is NOT thread safe, so wait and
// add socket wakeup must only be called from the same thread.
// if you're looking for the thread safe version, try ts_select_demuxer

namespace flx { namespace demux {

class DEMUX_EXTERN select_demuxer : public posix_demuxer {
  void  remove_fd(int s);
  
  // thanks Beej!
  fd_set      master_read_set;    // fd watched for reading
  fd_set      master_write_set;   // for writing
  fd_set      master_except_set;    // for exceptions

  // read sveglias - note we only have one set, so currently this demuxer
  // cannot have separate wakeups for the same file descriptor. this
  // fits in fine with the "undefined" nature of doing that.
  socket_wakeup*  svs[FD_SETSIZE];    // read sveglias
  //socket_wakeup*  write_svs[FD_SETSIZE];  // write wakeups

  int       fdmax;          // high watermark for select

protected:
  virtual void  get_evts(bool poll);

public:
  // get_evts broken into pieces for thread safe implementations
  void copy_sets(fd_set& rset, fd_set& wset, fd_set& exset);
  // returns true if process_sets should be called.
  bool select(fd_set& rset, fd_set& wset, fd_set& exset, bool poll);
  // these could be consts
  void process_sets(fd_set& rset, fd_set& wset, fd_set& exset);

  select_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};
}} // namespace demux, flx
#endif

@h=tangler('demux/demux_ts_select_demuxer.hpp')
@select(h)
#ifndef __TS_SELECT_DEMUXER__
#define __TS_SELECT_DEMUXER__

#include "demux_select_demuxer.hpp"
#include "demux_self_piper.hpp"
#include "pthread_mutex.hpp"

namespace flx { namespace demux {

// thread safe version of select demuxer

class DEMUX_EXTERN ts_select_demuxer : public posix_demuxer {
  flx::pthread::flx_mutex_t      ham_fist;   
  select_demuxer  demux;

  // self pipe trick for waking waiting thread when we like.
  self_piper sp;
protected:
    virtual void    get_evts(bool poll);
public:
  ts_select_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};
}} // namespace demux, flx

#endif
@h=tangler('demux/demux_timer_queue.hpp')
@select(h)
#ifndef __TIMER_QUEUE__
#define __TIMER_QUEUE__

#include <flx_demux_config.hpp>

namespace flx { namespace demux {

// trying to factor out code to share between pc & posix versions

// class sleep_task : public worker_task
// may not need time in here - just the wakeup - something I surely have
// somewhere else.
class DEMUX_EXTERN sleep_task
{
public:
    virtual ~sleep_task() {}

    virtual void fire() = 0;
};

class DEMUX_EXTERN timer_queue
{
public:
    virtual ~timer_queue() {}    

    virtual void add_sleep_request(sleep_task* st, double delta) = 0;
    virtual void add_abs_sleep_request(sleep_task* st, double when) = 0;

    // bad design - this is actually implemented in the descendent classes,
    // which limits the number of such classes probably to one.
    static void get_time(double& t);        // in seconds from some ref pt
};

}} // namespace demux, flx

#endif

@h=tangler('demux/demux_posix_timer_queue.hpp')
@select(h)
#ifndef __POSIX_TIMER_QUEUE__
#define __POSIX_TIMER_QUEUE__

#include "pthread_thread.hpp"  // flx_thread_t
#include "pthread_mutex.hpp"  // flx_mutex_t
#include "pthread_condv.hpp"  // flx_cond_t
#include "demux_timer_queue.hpp" // base class
#include <sys/time.h>        // timespecs, gettimeofday

namespace flx { namespace demux {

// looks like a worker queue, but couldn't quite mash it into one
class DEMUX_EXTERN posix_timer_queue : public timer_queue
{
    flx::pthread::flx_mutex_t lock; // factor to prio queue?
    flx::pthread::flx_condv_t sleep_cond;
    flx::pthread::flx_thread_t sleep_thread;
    void*        opaque_prio_queue;        // less fat

    static void* thread_start(void*);    // passed "this"
    bool thread_loop_body();


    void wakeup_thread();                // we can do this!

    void add_sleep_request(sleep_task* st, timespec* abs);
public:
    posix_timer_queue();
    ~posix_timer_queue();

    // thread safe.
    virtual void add_sleep_request(sleep_task* st, double delta);

    // in seconds, relative to same base as timer::get_time.
    virtual void add_abs_sleep_request(sleep_task* st, double when);
};

}}

#endif // __POSIX_TIMER_QUEUE__

@h=tangler('demux/demux_posix_timer_queue.cpp')
@select(h)
#include "demux_posix_timer_queue.hpp"

// a prio queue that executes tasks in a given order
// factor out prio_queue? could be like queue.

// try to make work like the worker thread thing, fix it do so?.
// remove time from sleep task...

#include <queue>    // stl seems to have a prio_queue
#include <sys/time.h> // gettimeofday for calculating "now"

using namespace flx::pthread;
namespace flx { namespace demux {

#define MIL 1000000        // one million
#define BIL (MIL*1000)    // one billion (metric)

using namespace std;

// it could happen!
// factor
class future_evt
{
public:
    timespec    when;    
    sleep_task*    task;

    // ignore the direction, just trying to sort with smallest first
    bool operator<(const future_evt& rhs) const
    {
        if(when.tv_sec != rhs.when.tv_sec)    // precedence to more significant
            return when.tv_sec > rhs.when.tv_sec;
        else                                // else check the less significant
            return when.tv_nsec > rhs.when.tv_nsec;
    }
};

typedef priority_queue<future_evt> void_prio_queue;
#define PRIOQ ((void_prio_queue*)opaque_prio_queue)

posix_timer_queue::posix_timer_queue()
{
    opaque_prio_queue = new void_prio_queue;    // a.k.a. PRIOQ
    fprintf(stderr,"initing timer sleep thread\n");
    sleep_thread.init(thread_start, this);
}

posix_timer_queue::~posix_timer_queue()
{
    // the sleep_thread uses the prioq, so we must explicitly shut it
    // down now, before we delete the prioq. left to its own devices,
    // c++ destructs it at the end of this destructor.

    // take down the thread first because it uses all the other stuff.
    // I actually don't need to do anything special to bring the thread
    // down because all pthread_cond_*wait* are cancel aware. Or so they
    // should be. As far as I can tell only the 64bit osx10.4.2 is, so
    // for now the explicit cancel + wakeup followed by explicit 
    // cancel test stays.

    // fprintf(stderr, "asking timer thread to quit\n");
    add_sleep_request(NULL, 0.0);    // super secret quit thread quit request
    wakeup_thread();                // wakeup, cause to goto a cancel pt

    sleep_thread.join();            // will join
    fprintf(stderr,"about to delete PRIOQ\n");
    delete PRIOQ;
}

static void
get_now(timespec* now)
{
    struct timeval tp;

    if(gettimeofday(&tp, NULL) == -1)
        perror("gettimeofday");

    // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
    now->tv_sec = tp.tv_sec;
    now->tv_nsec = tp.tv_usec*1000;        // fits!

    // fprintf(stderr,"get_now = %li, %li\n", now->tv_sec, now->tv_nsec);
}

// LIMIT!
// seconds to microseconds - signed this gives a bit over half an hour
#define SEC2TIMESPEC(ts, t) long    wait_musec = (long)(t*MIL);    \
    timespec    ts = { wait_musec / MIL, (wait_musec % MIL)*1000 }


// offset delta from "now" and store in "when"
static void
calc_when(timespec* when, double delta)
{
// how to use the posix abstime versions of timed waits? what kind of absolute
// is abstime? pthread_get_expiration_np looks useful, but it too is np.
// abstime is apparently in seconds since the Epoch, UTC.
// To get now there's clock_gettime (not portable) or gettimeofday with
// null timezone.

    timespec    now;
    get_now(&now);

    // limit!
    // seconds to microseconds - signed this gives a bit over half an hour
    // long    wait_musec = (long)(delta*MIL);
    // timespec    delay = { wait_musec / MIL, (wait_musec % MIL)*1000 };
    SEC2TIMESPEC(delay, delta);
    
    // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
    when->tv_sec = now.tv_sec + delay.tv_sec;
    when->tv_nsec = now.tv_nsec + delay.tv_nsec;

    if(when->tv_nsec >= BIL)            // overflow of nanoseconds?
    {
        // fprintf(stderr,"OVERFLOW = %li, %li\n", when->tv_sec, when->tv_nsec);
        // x, y < BIL, x + y < 2BIL
        when->tv_sec++;
        when->tv_nsec -= BIL;
        // when->tv_sec += when->tv_nsec/BIL;
        // when->tv_nsec %= BIL;
    }

    // fprintf(stderr,"when = %li, %li\n", when->tv_sec, when->tv_nsec);
    // tp contains tv_sec (seconds) & tv_usec (microseconds) both longs.
    // however, if nonposix works everywhere...
}

// absolute time
void
posix_timer_queue::add_sleep_request(sleep_task* st, timespec* abs)
{
    future_evt    evt;
    evt.task = st;
    evt.when = *abs;

    flx::pthread::flx_mutex_locker_t    locker(lock);

    PRIOQ->push(evt);

    // we may have inserted at sooner than any other evt, so wake up thread
    // to figure it out (if need be). I seemed to be getting more wakeups
    // with this. Turned off for now. Not sure how that works.
    if(1 || PRIOQ->top().task == st)
    {
//        fprintf(stderr,"WE PUSHED IN - waking thread\n");
        wakeup_thread();
    }
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
posix_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
    // fprintf(stderr,"add_sleep_request: %lf\n", delta);
    timespec    when;
    calc_when(&when, delta);        // calculate when (t a delta)

    add_sleep_request(st, &when);
}

void
posix_timer_queue::add_abs_sleep_request(sleep_task* st, double when)
{
    // absolute version is closer to the posix implementation
    SEC2TIMESPEC(abs_time, when);
    add_sleep_request(st, &abs_time);
}

// cause the timer wait thread to wake up. useful for asking it to
// exit or re-evaluate a changed sleep queue.
void
posix_timer_queue::wakeup_thread()
{
    sleep_cond.signal();
}

void*
posix_timer_queue::thread_start(void* udat)
{
    posix_timer_queue*    q = (posix_timer_queue*)udat;
    fprintf(stderr,"sleeper thread\n");

    while(q->thread_loop_body()) ;

    return 0;
}

bool
posix_timer_queue::thread_loop_body()
{
    flx::pthread::flx_mutex_locker_t    locker(lock);    // lock on. lock off when waiting on condition

    int        res;

    // pthread_cond_wait & pthread_cond_timedwait (& np rel version?) are
    // cancellation points. doco notes for timed & untimed waits that the
    // predicate should be rechecked as there can be spurious wakeups.
    // no worries, when we wakeup the lock has been acquired.

    while(!PRIOQ->empty())
    {
        future_evt    evt = PRIOQ->top();

        // quit request
        if(!evt.task) return false;

        future_evt  now;        // "now' has no task, just a dummy.
        get_now(&now.when);

        // if(evt < now)        // would prefer <=, eh.
        // < is arse backwards because I don't know how to use the stl
        if(now < evt)        // would prefer <=, eh.
        {
            // fprintf(stderr,"firing of (%li, %li) at (%li, %li)!\n",
            //    evt.when.tv_sec, evt.when.tv_nsec,
            //    now.when.tv_sec, now.when.tv_nsec);
            evt.task->fire();
            PRIOQ->pop();
        }
        else    // we have an event in future, so sleep for that long
        {
            // remember that condition waits are exit points...
            // so I don't need to test - check that.
            // fprintf(stderr,"sleeping from %li, %li until %li, %li\n",
            //    now.when.tv_sec, now.when.tv_nsec,
            //    evt.when.tv_sec, evt.when.tv_nsec);
            (void)sleep_cond.timedwait(&lock, &evt.when);

            // if using posix abstime timed wait we make get EINVAL here for 
            // abstimes in the past. must handle this.
            //JS: It's handled now, waiting for a time in the past is OK
 
            // fprintf(stderr,"pthread_cond_timedwait woke up! (%i)\n", res);
        }
    }

    // if we got here then the queue is empty, so sleep indefinitely
    // that we don't really need the mainloop testcancel because the condition
    // wait functions are cancellation points.
    // fprintf(stderr,"no sleep task, sleeping indefinitely\n");
    sleep_cond.wait(&lock);
    // fprintf(stderr,"pthread_cond_wait woke up! (%i)\n", res);

    // lock released here
    return true;                    // keep going
}


// in seconds from some ref pt
// N.B. declared in base class!
void
timer_queue::get_time(double& t)
{
    timespec    now;
    get_now(&now);        // just calls gettimeofday (msec) and converts
                        // to timespec (sec, nsec). could skip that
                        // and call directly, avoiding conversion
    t = now.tv_sec + (now.tv_nsec*BIL);
}  

}}

@h=tangler('demux/demux_win_timer_queue.hpp')
@select(h)
#ifndef __WIN_TIMER_QUEUE__
#define __WIN_TIMER_QUEUE__

#include "flx_demux_config.hpp"
#include <Windows.h>

#include "demux_timer_queue.hpp"

namespace flx { namespace demux {

class DEMUX_EXTERN win_timer_queue : public timer_queue
{
  HANDLE    timer_queue;

  static VOID CALLBACK timer_callback(PVOID, BOOLEAN);
public:
  win_timer_queue();
  ~win_timer_queue();

  virtual void add_sleep_request(sleep_task* st, double delta);
  virtual void add_abs_sleep_request(sleep_task* st, double when);

};

}}

#endif // __SLEEP_TASK__

@h=tangler('demux/demux_win_timer_queue.cpp')
@select(h)
#include "flx_demux_config.hpp"
#include <Windows.h>
#include <assert.h>

// simply wrapped windows timer queue. requires windows 5.00, which is 
// quite high (xp?) because I couldn't get the waitable timers to work.
// must be careful with this stuff lest it create millions of threads.
#include "demux_win_timer_queue.hpp"

#include <stdio.h>

namespace flx { namespace demux {

#define MIL 1000000    // 1 metric million

typedef struct
{
  sleep_task*  st;        // so we can make it fire
  HANDLE    timer;      // we need to delete the timer, so we keep it
  HANDLE    timer_queue;  // AND its queue (no back ptrs, I guess)
} timer_cookie;

win_timer_queue::win_timer_queue()
{
  // fprintf(stderr,"win_timer_queue ctor\n");

  timer_queue = CreateTimerQueue();
  if(!timer_queue)
  {
    fprintf(stderr, "CreateTimerQueue failed: %i\n", GetLastError());
    throw -1;
  }
  // fprintf(stderr, "created timer queue: %p\n", timer_queue);
}


win_timer_queue::~win_timer_queue()
{
  // INVALID_HANDLE_VALUE indicates that DeleteTimerQueueEx should wait for
  // all callback functions to complete before returning. One would hope that
  // calling this causes all the timers to go off before their time (what
  // else would the "actually fired" callback flag be for?). The alternative
  // of waiting for some ever distant timer to go off would be too stupid
  // for words. As usual, the msdn glosses over the important details like
  // this one. Anyway, it's easy to test out... No, that flag's always true
  // for timers, and this wait option doesn't work - maybe with other types
  // flags for CreateTimerQueueTimer?
  if(!DeleteTimerQueueEx(timer_queue, INVALID_HANDLE_VALUE))
  {
    fprintf(stderr, "DeleteTimerQueueEx failed: %i\n", GetLastError());
    // whatcha gonna do about it?
  }
  // fprintf(stderr, "finished - did it wait?\n");
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
win_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
  // fprintf(stderr,"add_sleep_request: %lf to %p\n", delta, timer_queue);

  timer_cookie*  tc = new timer_cookie;

  // copy in the sleep_task and the timer queue
  tc->st = st;
  tc->timer_queue = timer_queue;

  // the timer thread may not be the best solution as nothing is stopping
  // anyone from performing long operations with this structure, however
  // in all likelihood, it'll just be felix adding threads back to its queue.
  if(!CreateTimerQueueTimer(
    &tc->timer,          // resulting timer in timer_cookie
    timer_queue,
    //NULL,            // add to default timer queue
    timer_callback,        // should get called in delta seconds
    tc,             // timer cookie is user data
    (DWORD)(delta*1000),    // millisecond timer
    0,              // zero period => signal once
    WT_EXECUTEINTIMERTHREAD))  // NB: for short tasks (will this do?)
  {
    fprintf(stderr, "CreateTimerQueueTimer failed: %i\n", GetLastError());
    delete tc;          // at least try not to leak
    return;
  }
}

// this is a c callback - all the c++ code should probably be wrapped
// in a try/catch. timer_or_wait_fired is always true for timers.
VOID CALLBACK
win_timer_queue::timer_callback(PVOID udat, BOOLEAN timer_or_wait_fired)
{
  timer_cookie*  tc = (timer_cookie*)udat;
  
  // fprintf(stderr, "timer queue callback fired: %p, %i\n",
  //  tc, timer_or_wait_fired);

  if(!tc)
  {
    // Nothing that we can do in this situation.
    fprintf(stderr, "WHOA - NULL queue cookie! (fired: %i)\n",
      timer_or_wait_fired);
    return;            // outta here
  }

  // NULL means delete the thing now, INVALID_HANDLE_VALUE means wait until
  // callback finishes. We're in the callback, so we can't do that (=deadlock
  // of the timer thread, which isn't good). We're all adults here, the timer
  // has expired, we know what we're doing, so lets just delete it.
  tc->st->fire();

  // on my box this returns ERROR_IO_PENDING, on others it doesn't
  // msdn says this should be ok, but I'm not so sure.
  if(!DeleteTimerQueueTimer(tc->timer_queue, tc->timer, NULL))
  {
    int  err = GetLastError();

    if( ERROR_IO_PENDING != err)
    {
      fprintf(stderr, "DeleteTimerQueueTimer of %p failed: %i\n",
        tc->timer, err);
    }
    else
    {
      // I'm not so sure, see if it leaks.
      fprintf(stderr, "DeleteTimerQueueTimer = ERROR_IO_PENDING\n");
      fprintf(stderr, "Apparently this is ok...\n");
    }
  }
  delete tc;

  // fprintf(stderr, "leaving timer callback\n");
}

// in seconds from some ref pt (UTC for this fn)
// N.B. declared in base class!
void
timer_queue::get_time(double& t)
{
  SYSTEMTIME  sysnow;
  GetSystemTime(&sysnow);
  // now convert to seconds
  // via FILETIME?

  // kinda sucks, but is the msdn recommended way of doing calculations
  // on dates.
  FILETIME  fnow;
  if(!SystemTimeToFileTime(&sysnow, &fnow))
  {
    fprintf(stderr, "SystemTimeToFileTime failed: %i\n", GetLastError());
    t = 0;
    return;
  }

  ULARGE_INTEGER now;  // so we can do some maths

  assert(sizeof(now) == sizeof(fnow));
  memcpy(&now, &fnow, sizeof(now));

  // and now we have a big integer containing an offset jan 1, 1601 (UTC)
  // 100 nanosecond intervals
  t = now.QuadPart*MIL*10;  // *10 to microseconds, *MIL to seconds
}

void
win_timer_queue::add_abs_sleep_request(sleep_task* st, double when)
{
  // win timer queue works with relative offsets, so convert this absolute
  double  now;
  get_time(now);
  double  delta = when-now;
  if(delta < 0.0) delta = 0.0;
  add_sleep_request(st, delta);
}

}}
@h=tangler('demux/demux_demuxer.cpp')
@select(h)
#include "demux_demuxer.hpp"

// nothing here atm ..

@h=tangler('demux/demux_epoll_demuxer.cpp')
@select(h)
// epoll interface. does epoll support ordinary files in addition to sockets?
// EPOLLET to make epoll edgetriggered. I guess the default is level triggered.

// epoll events are not one shot, in fact they're quite sticky so socket
// filters must be removed manually to guarantee a one-to-one wakeup
// to add_wakeup ratio. note that the oneshot flag is not a solution.

// cool! EPOLLONESHOT
// BUGGER! doesn't seem to exist! and doing this doesn't make it so!
// #ifndef EPOLLONESHOT
// #define EPOLLONESHOT (1<<30)
// #endif

#include "demux_epoll_demuxer.hpp"

#include <sys/epoll.h>  // for epoll_*
#include <stdio.h>    // for perror
#include <unistd.h>   // for close
#include <errno.h>    // EEXIST, errno

namespace flx { namespace demux {

epoll_demuxer::epoll_demuxer()
  : epoll_fd(-1)
{
  // EPOLLONESHOT is shit, don't use it. Enabling it just means that your
  // wakeups are suppressed and you have to use EPOLL_CTL_MOD instead
  // of EPOLL_CTL_ADD. If it isn't defined then so much the better.
//#ifdef EPOLLONESHOT
//  fprintf(stderr,"WARNING: EPOLLONESHOT AVAILABLE (%x)!!!\n", EPOLLONESHOT);
//#endif

  // god knows what the maximum size will be, I'll just say 1 for now
  epoll_fd = epoll_create(1);
  if(-1 == epoll_fd)
  {
    perror("epoll_create");
    throw -1;
  }
}

epoll_demuxer::~epoll_demuxer()
{
  if(-1 != epoll_fd)
  {
    if(close(epoll_fd) != 0)
      perror("epoll close");
  }
}

int
epoll_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  int s = sv->s;

  struct epoll_event  evt;
  // fprintf(stderr,"add_socket_wakeup: %i (sv=%p, flags=%x)\n",
  //  s, sv, flags);

  // EPOLLONESHOT saves us not only a system call to remove epoll evts,
  // which aren't intrinsically one-shot, but having to do it ourselves
  // would have been a pain as epoll doesn't tell you which fd had the event
  // this way we can get away with not knowing & not losing our user cookie
  evt.events = 0;
  
  if(flags & PDEMUX_READ) evt.events |= EPOLLIN;
  if(flags & PDEMUX_WRITE) evt.events |= EPOLLOUT;

  // fprintf(stderr, "flags %x -> evt.events %x\n", flags, evt.events);

  // We do the remove manually because oneshot in epoll doesn't
  // remove the socket, but rather, disables it.
//#ifdef EPOLLONESHOT
//  evt.events |= EPOLLONESHOT;         // yes!
//#endif
  // I think EPOLLHUP comes when the connection closes (on read?)
// poll's (plain old poll) equivalents to this are ignored for input
// same here?
  // I get EPOLLHUPs for bad async connects whether I ask for them or not.
  evt.events |= (EPOLLHUP | EPOLLERR);    // I think I want this

  evt.data.ptr = sv;              // our user data

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, s, &evt) == -1)
  {
    // EPOLL_CTL_MOD cannot help us do bidirection io on one socket,
    // the mod will overwrite the old user cookie and direction. 
    // It seems that only kqueues, select and iocps allow that.
    // Will need a wakeup that can do both, oneshot that indicates
    // the available direction.
// when using oneshot, we're supposed to use EPOLL_CTL_MOD
#if 0
    int err = errno;

    if(EEXIST == err)
    {
      // ok - let's try EPOLL_CTL_MOD
      fprintf(stderr, "RETRYING WITH EPOLL_CTL_MOD\n");
      if(epoll_ctl(epoll_fd, EPOLL_CTL_MOD, s, &evt) != -1)
        return 0; // good!
    }
#endif
    perror("epoll_ctl (add)");
    
    return -1;
  }
  return 0;
}

// epoll doesn't differentiate on events. I bet I could
// just not pass that event...
void
epoll_demuxer::remove_wakeup(int s)
{
  // EPOLL_CTL_DEL uses no information from the event
  // and so I should be able to pass NULL.
  // struct epoll_event evt;
  // evt.events = (read) ? EPOLLIN : EPOLLOUT;

  // fprintf(stderr,"removing socket wakeup %i\n", s);

  if(epoll_ctl(epoll_fd, EPOLL_CTL_DEL, s, NULL) == -1)
  {
    //const char* str = (read) ? "epoll_ctl (remove read)"
    //  : "epoll_ctl (remove write)";
    // perror(str);
    perror("epoll_ctl (remove)");
  }
}

void
epoll_demuxer::get_evts(bool poll)
{
  struct epoll_event  evt;

  switch(epoll_wait(epoll_fd, &evt, 1, (poll) ? 0 : ~0))
  {
    case -1:    // error
    perror("epoll_wait");
      // fall through
    case 0:     // no events (happens with timeout)
      return;
  }

  socket_wakeup* sv = (socket_wakeup*)evt.data.ptr;
  
  // not seeing timeouts as they're filtered by the switching.
  // assuming that sv is good
  // fprintf(stderr,"wakeup (sv=%p, sv->s=%i evt.events=%x)!\n",
  //  sv, sv->s, evt.events);

  // accumulate bit field of what we got
  sv->wakeup_flags = 0;

  bool  wake = false;
  
  // it might be possible to get both a read & write event...
  // in which case I should take out the else below
  if(evt.events & EPOLLIN)                // I think this is how you do it
  {
    // fprintf(stderr,"EPOLLIN for %p\n", sv);
    sv->wakeup_flags |= PDEMUX_READ;
    wake = true;
  }

  if(evt.events & EPOLLOUT)
  {
    //fprintf(stderr,"EPOLLOUT for %p\n", sv);
    sv->wakeup_flags |= PDEMUX_WRITE;
    wake = true;
  }

  // Is this for shutdown or closing of the other end?
  // I get it for failed async connects. I don't know if other events cause
  // it. In any case, I don't know whether it should be for read or write,
  // so I just don't say. In any case, it should wake to get error.
  // I seem to get both EPOLLHUP and EPOLLERROR on bad async connect
  if(evt.events & EPOLLHUP)
  {
    fprintf(stderr, "EPOLLHUP for %p->%i\n", sv, sv->s);
    wake = true;
  }

  if(evt.events & EPOLLERR)
  {
// How do I retrieve the error?
    // There's no ambiguity - there's only ever one fd in a given epoll.
    // If oneshot's present then don't need to do anything
// not sure what to do here. if we've enabled/got oneshot the socket
// should already have been removed
    fprintf(stderr,"epoll error, waking: %i (errno?)\n", sv->s);
    // similar story to EPOLLHUP
    wake = true;
  }

    if((evt.events & ~(EPOLLERR|EPOLLIN|EPOLLOUT|EPOLLHUP)))
    {
        fprintf(stderr,"unknown events in epoll_demuxer %x\n", evt.events);
    }

  // we got something. tell the people.
  // not dependent solely on wakeup_flags - errors need to wake too.
  if(wake)
  {
    // we got something. better call wakeup, must remove to guarantee
    // 1-1 wakeups with add_sockets
    // fprintf(stderr, "no one-shot... remove %i\n", sv->s);
    remove_wakeup(sv->s);
    // fprintf(stderr, "calling wakeup (flags=%x)\n", sv->wakeup_flags);
    sv->wakeup(*this);
  }
}
}}

@h=tangler('demux/demux_evtport_demuxer.cpp')
@select(h)
// Evtports can get timer wakeups with PORT_SOURCE_TIMER.
// Can also pick up aio notifications with PORT_SOURCE_AIO.

// looks like this stuff is only in solaris10, and not SunOS 5.8. Damn.

#include "demux_evtport_demuxer.hpp"

#include <port.h>
#include <poll.h> // POLLIN/POLLOUT
#include <stdio.h>  // printf
#include <unistd.h> // close
#include <assert.h>

using namespace flx::pthread;
namespace flx { namespace demux {

// header files for this stuff?
// can use port_send for user defined events, to wake up reap loop
// truss to see what's happening

evtport_demuxer::evtport_demuxer()
{
  if((evtport = port_create()) < 0)
  {
    perror("port_create");
    throw -1;
  }
}

evtport_demuxer::~evtport_demuxer()
{
  if(-1 != evtport)
  {
    if(close(evtport) != 0)
      perror("evtport close");
  }
}

int
evtport_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  if(flags & ~(PDEMUX_READ|PDEMUX_WRITE)) // I can't understand you, lady!
    return -1;

  int events = 0; // events are flags so we can accumulate them
  int s = sv->s;

  if(flags & PDEMUX_READ) events |= POLLIN;
  if(flags & PDEMUX_WRITE) events |= POLLOUT;

  // POLLHUP might make sense only for reads... add conditionally?
  events |= (POLLHUP | POLLERR);

  // fprintf(stderr,"add_socket_wakeup: %i, sv: %p (%x)\n", s, sv, flags);

  // register for event we are interested in...
  // works for files, sockets, timers...
  // sockets are file descriptors in unix, so src is PORT_SOURCE_FD
  if(port_associate(evtport, PORT_SOURCE_FD, (uintptr_t)s, events, sv) == -1)
  {
    perror("add socket_wakeup/port_associate");
    return -1;
  }

  return 0;
}

// note that these two functions are exactly the same
// we have to remove after a read or write else we can get multiple
// wakeups - usually with a dud user cookie. the fact that there is
// no differentiation between POLLIN & POLLOUT could be a problem for
// mixed read/write things (rare). note that evt_ports let me associate
// the samething twice. I don't know if this means you have to dissociate
// (disassociate) twice.
void
evtport_demuxer::remove_wakeup(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("reading port_dissociate");
}

#define POLLPR(ev) if(e->portev_events & ev) fprintf(stderr,#ev", ")

static void
print_port_evt(port_event_t* e)
{
  char* srcstr[PORT_SOURCE_ALERT-PORT_SOURCE_AIO+1]
    = { "ALERT", "TIMER", "USER", "FD", "AIO"};
  fprintf(stderr,"e: %p\n\t", e);
  //fprintf(stderr,"portev_events: %x\n\t", e->portev_events);
  fprintf(stderr,"portev_events: ");

  // I got these constants from the poll.h file
  POLLPR(POLLIN); POLLPR(POLLOUT); POLLPR(POLLPRI);
  POLLPR(POLLRDNORM); POLLPR(POLLRDBAND); POLLPR(POLLWRBAND);

  // in poll these are in a different field. port_event_t doesn't
  // have that field, so lets try here.
  POLLPR(POLLERR); POLLPR(POLLHUP); POLLPR(POLLNVAL); POLLPR(POLLREMOVE);

  fprintf(stderr," (%x)\n\t", e->portev_events);
  
  int src = e->portev_source;
  if(PORT_SOURCE_AIO <= src && src <= PORT_SOURCE_ALERT)
  {
    fprintf(stderr,"portev_source: PORT_SOURCE_%s (%x)\n\t",
      srcstr[src-PORT_SOURCE_AIO], src);
  }
  else
  {
    fprintf(stderr,"portev_source: %x\n\t", e->portev_source);
  }

  fprintf(stderr,"portev_pad: %x\n\t", e->portev_pad);
  // often our socket
  fprintf(stderr,"portev_object: %x\n\t", e->portev_object);
  fprintf(stderr,"portev_user: %p\n", e->portev_user);
}

void
evtport_demuxer::get_evts(bool poll)
{
  // Block until a single event appears on the port. Event will not fire
  // again, so we get max 1 wakeup per event added.

  port_event_t  evt;
  timespec    timeout, *tp = NULL;

  if(poll)    // effect a poll
  {
    timeout.tv_sec = 0;
    timeout.tv_nsec = 0;
    tp = &timeout;
  }

  // wait for single event, no timeout
  if(port_get(evtport, &evt, tp) == -1)
  {
    perror("port_get");
    return;
  }

  // fprintf(stderr,"PORT_GET RETURNED: "); print_port_evt(&evt);

  // get wakeup obj tucked away in the user cookie.
  socket_wakeup*  sv = (socket_wakeup*)evt.portev_user;
  int       s = evt.portev_object;

  assert(sv != NULL);
  if(evt.portev_source != PORT_SOURCE_FD)
  {
    // when polling I often end up in here - we get an unknown evt
    // source and a POLLNVAL event plus lots of other unknown flags.
    // there's interesting looking stuff in the user field and so on,
    // but it's nothing of mine and also undocumented
    // fprintf(stderr,"got non PORT_SOURCE_FD (s=%i, sv=%p, src=%i)\n",
    //  s, sv, evt.portev_source);
    // fprintf(stderr, "skipping out...\n");
    return;
  }


  // let's see what we've got for the wakeup
  sv->wakeup_flags = 0;

  if(evt.portev_events & POLLERR)
  {
    fprintf(stderr,"ERRORS on s = %i, sv = %p\n", s, sv); 
    //evt.portev_events &= ~POLLERR;
    //return;
  }

  // for bidirectional wakeups, we should be able to get both
  // POLLIN and POLLOUT at the same time, but I've not yet
  // seen it happen, they're coming in one at a time for me.


  if(evt.portev_events & POLLIN)
  {
    // fprintf(stderr,"GOT POLLIN FOR %p\n", sv);
    sv->wakeup_flags |= PDEMUX_READ;
  }

  if(evt.portev_events & POLLOUT)
  {
    // fprintf(stderr,"GOT POLLOUT FOR %p\n", sv);
    sv->wakeup_flags |= PDEMUX_WRITE;
  }

  // I never asked for POLLERR, but anyway
  if(evt.portev_events & ~(POLLIN | POLLOUT | POLLERR))
    {
        fprintf(stderr,"UNSOLICITED events in evtport_demuxer (%x)\n",
      evt.portev_events);
    }

  assert(sv->wakeup_flags != 0);    // we should've gotten SOMETHING.

  if(sv->wakeup_flags)  
    sv->wakeup(*this);
}
}}

@h=tangler('demux/demux_iocp_demuxer.cpp')
@select(h)
#include "demux_iocp_demuxer.hpp"
#include "pthread_mutex.hpp"

#include <stdio.h>      // for printf debugging
#include <stddef.h>     // offsetof
#include <assert.h>
// shoving the win_queue in here for now

using namespace flx::pthread;
namespace flx { namespace demux {

// this could really do with auto objs. steal the strat stuff?

// add windows error processing macros. It's a bore otherwise.

// WaitForSingleObject on an kill event in the thread for thread cancel
// kill_event = CreateEvent(NULL, TRUE, FALSE, NULL); (what's that)
// SetEvent(kill_event) to invoke (?): SetEvent sets the event to the 
// signalled state. Return value is success flag. GetLastError.

// do auto SOCKET wrapper, check closesocket return code.

// a completion port is a queue into which the os puts notifications of
// completed overlapped io requests. once the operation completes, a
// notification is sent to a worker thread that can process the result.
// a socket may be associated with a completion port at any point after
// creation.


// I don't see how to nicely stop a thread, I may have to have my own protocol
// to ask it to exit.

// PostQueuedCompletionStatus can be used by threads to wake up a worker
// thread. Could be handy replacement for timeout. "useful for notifying
// worker threads of external events"

// working through this: http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/
// example of worker thread here
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/i_o_completion_ports.asp
// nono, use this onec
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// oh, wait they're the same
// FormatMessge

winsock_initer::winsock_initer()
{
  WSADATA wsaData;

  // apparently 2.2's the way to go
  int res= WSAStartup(MAKEWORD(2, 2), &wsaData);
  if(res!= 0)
  {
    //JS: WSAGetLastError CANNOT be called, since WSAStartup failed
    fprintf(stderr,"couldn't find usable winsock dll: %i\n", res);
    throw res;
  }
}

winsock_initer::~winsock_initer()
{
  if(WSACleanup() != 0)
  {
    fprintf(stderr,"WSACleanup failed %i\n", WSAGetLastError());
  }
}

// iocp_wakeup base class for users of iocp_demuxer
//static
iocp_wakeup*
iocp_wakeup::from_overlapped(LPOVERLAPPED olp)
{
  // calculate the address of this from overlapped member
  // suffer an obligatory offsestof warning from broken gccs.
  return (iocp_wakeup*)((char*)olp-offsetof(iocp_wakeup, ol));
}

void
iocp_wakeup::clear_overlapped()
{
  ZeroMemory(&ol, sizeof(ol));  // much better than memset, right?
}


iocp_demuxer::iocp_demuxer()
  : iocp(NULL)
{
  // Create the completion port
  // not sure what first 3 args do, but by specifying INVALID_HANDLE_VALUE
  // for the first I think I can ignore the rest (apart from the last, numthreads)
  // I still have to create the threads, but only NumberOfConcurrentThreads
  // will wake up from GetQueuedCompletionStatus at a time. This looks to be
  // slightly elastic...
// NT 3.51 doesn't let you pass null filehandle, you've got to have a dummy
// socket. keep that in mind. see InitializeIOCP in IOCPServer.cpp example
// taken from codeproject. GetSystemInfo to find out num CPUs
  fprintf(stderr,"CreateIoCompletionPort with ONE WORKER THREAD\n");
  iocp = CreateIoCompletionPort(
    INVALID_HANDLE_VALUE,
    NULL,
    (ULONG_PTR)0,
    1       // 1 thread (zero means one for each CPU)
  );

  if(NULL == iocp)
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed to create completion port: %li\n", err);
    throw -1;
  }
}

iocp_demuxer::~iocp_demuxer()
{
  fprintf(stderr, "~iocp (%p)\n", iocp);

  if(NULL != iocp && !CloseHandle(iocp))
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed cleanup iocp: %li\n", err);
  }
}

int
iocp_demuxer::associate_with_iocp(HANDLE obj, ULONG_PTR udat)
{
  // fprintf(stderr, "associating with iocp=%p: %p, udat: %lx\n",
  //  iocp, obj, udat);

  // Any overlapped operations performed on the object will use the
  // completion port for notification. The 3rd param can be used to pass
  // per object context information. we'll just pass that back.
  if(CreateIoCompletionPort(obj, iocp, udat, 0) == NULL) {
    // adding the same obj twice without an intervening get completion
    // status wakup gets an error 87, ERROR_INVALID_PARAMETER
    fprintf(stderr,"CreateIoCompletionPort failed to register object: %li\n",
      GetLastError());
    return -1;
  }

  return 0;
}

void
iocp_demuxer::get_evts(bool poll) {
  // with multiple threads, this will actually wake up the last to
  // block (lifo)

  // get context, call worker_thread 
  // need to be able to tell which thing completed, can have extra data
  // following some kind of struct
  // get this pointer

  // I guess to avoid swapping of thread context. By calling this on a given
  // completion port this thread is associated with it until exit or respec
  DWORD     nbytes;   // number of bytes in io transaction
  ULONG_PTR     udat;   // user data - not using this atm
  LPOVERLAPPED  olp;    // we get iocp_wakeup from this.

// If a socket handle associated with a completion port is closed,
// GetQueuedCompletionStatus returns ERROR_SUCCESS, with *lpOverlapped
// non-NULL and lpNumberOfBytes equal zero.
  
  int err = NO_ERROR;

  // No timeout. What does false mean? Eh. Could need a timeout to bring
  // the thread down.
  if(!GetQueuedCompletionStatus(iocp, &nbytes, &udat, &olp, 
    (poll) ? 0: INFINITE))
  {
    // That's strange - I sometimes get my ConnectEx errors popping
    // out here (ERROR_SEM_TIMEOUT=121, ERROR_CONNECTION_REFUSED=1225)
    // it looks like my args (overlapped, etc) are still filled out, so
    // I can still awake the sleeper
    err = GetLastError();   // doco says this & not WSALastError.

    // let's see: yep - there's my overlapped
    // fprintf(stderr,"!iocp::wait: nbytes=%li, udat=%lx, io=%p, err=%i\n",
    //  nbytes, udat, olp, err);

    if(WAIT_TIMEOUT == err)
    {
      // we get this a lot now that we can poll the iocp, so no output
      // interestingly, nbytes = 1. what could that mean?
      return;         // no wakeup
    }
    else if(ERROR_OPERATION_ABORTED == err)
    {
      // that's real bad manners. Or I could just ignore it. Anyway,
      // any overlapped received is stale.
      fprintf(stderr, "WHOA!!! - disassociate before killing handle\n");
      return;         // no wakeup
    }
    else
    {
      fprintf(stderr,"GetQueuedCompletionStatus returned false: %i\n",
        err);
      // return here? relying on olp being NULL, to stop us dereffing
    }

    // I'm going to assume that there's a good wakeup, and fall through
    // We need to wakeup on some errors (like ERROR_CONNECTION_REFUSED)
    // FALL THROUGH
  }

// An IOCP is a very general event mechanism. It tells you not only about
// the completion of reads & writes, but also of pretty much any asynchronous
// event's completion. It doesn't quite fit in with my select style interfaces.
// I've got general overlapped things completing here. I don't want them to
// know about demuxers & so forth so I'll have to know about them.

  //fprintf(stderr,"HOLEY! Woke up!\n");
  //fprintf(stderr,"nbytes=%li, udat=%lx, olp=%p, err=%i\n",
  //  nbytes, udat, olp, err);

  // with polling it's normal not to get an overlapped pointer, because
  // we may simply have timed out
  assert( olp );

  // tell someone that some overlapped op finished
  iocp_wakeup*  wakeup = iocp_wakeup::from_overlapped(olp);

  // passing olp may be redundant, seeing as it's contained in iocp_wakeup
  wakeup->iocp_op_finished(nbytes, udat, olp, err);
}



// simple utility fn, shouldn't be here. creates listener on any interface.
// this could benifit from a SOCKET class. in failure returns INVALID_SOCKET
// CURRENTLY EATS ERROR, SO DON'T BOTHER CHECKING
SOCKET
create_listener_socket(int* io_port, int backlog)
{
  fprintf(stderr,"creating_listener_socket\n");
  SOCKET        listener;

  // could use WSASocket, but these seem to be turning out overlapped anyway
  // at least after tangling with overlapped functions.
  // socket returns INVALID_SOCKET on failure.
  listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if (INVALID_SOCKET == listener)
  {
    fprintf(stderr,"listener create failed: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  SOCKADDR_IN   addr;

  // msdn code examples don't zero the sockaddr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(*io_port);

  // bind our name to the socket
  int         res;
  res = bind(listener, (LPSOCKADDR)&addr, sizeof(addr));

  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"bind() failed %i\n", WSAGetLastError());
    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }
    return INVALID_SOCKET;
  }

  // if user wanted port chosen tell them what it turned out to be
  if(0 == *io_port)
  {
    int namelen;

    if (getsockname(listener, (struct sockaddr *)&addr, &namelen) 
      == SOCKET_ERROR)
    {
      fprintf(stderr, "getsockname failed (%i)\n", WSAGetLastError());

      if(closesocket(listener) == SOCKET_ERROR)
      {
        fprintf(stderr,"closesocket failed on listener: %i\n",
          WSAGetLastError());
      }
      return INVALID_SOCKET;
    }

    *io_port = ntohs(addr.sin_port);
  }

  // Set the socket to listen
  res = listen(listener, backlog);
  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"listen() failed %i\n", WSAGetLastError());

    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }

    return INVALID_SOCKET;
  }

  return listener;
}

// currently the following aren't used. Look forward to warnings
// about them.

// the posix version of this made the socket nonblocking.
// I don't seem to have to do that when using iocp. if you
// want to create a nonblocking socket (or overlapped) pass
// WSA_FLAG_OVERLAPPED to WSASocket. I've never had to
// actually do this. How do you make accept do this? (supposing
// you wanted to) WSAAccept doesn't have a flag for it (however
// it does let you do conditional accepting). 
// There doesn't seem to be a sockopt
// returns INVALID_SOCKET on failure. eats the err.
SOCKET
nice_accept(SOCKET listener)
{
  struct sockaddr_in  remoteaddr;
  int         addrlen = sizeof(remoteaddr);
  SOCKET        s;
  
  // accept returns INVALID_SOCKET when it fails
  s = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);

  if(INVALID_SOCKET == s)
  {
    fprintf(stderr,"nice_accept failed (%i)\n", WSAGetLastError());
  }

  // the posix version makes the socket nonblocking here
  // we're not bothering

  return s;
}

// returns SOCKET_ERROR on failure, with err in WSAGetLastError()
static int
connect_sock(SOCKET s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

// returns INVALID_SOCKET on failure, eats last error with WSAGetLastError
// unlike the posix version, this does not make the socket nonblocking.
SOCKET
nice_connect(const char* addr, int port)
{
  SOCKET      s;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != INVALID_SOCKET
    && connect_sock(s, addr, port) != SOCKET_ERROR)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  fprintf(stderr,"nice_connect failed (%i)\n", WSAGetLastError());

  if(INVALID_SOCKET != s && closesocket(s) == SOCKET_ERROR)
    fprintf(stderr,"nice close failed (%i)\n", WSAGetLastError());

  return INVALID_SOCKET;
}

// returns -1 on error with errno in WSAGetLastError. 0 otherwise.
// kind of crap.
int
set_tcp_nodelay(int s, int disable)
{
  BOOL  disable_nagle = (disable) ? true : false;

  int res = setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
      (const char*)&disable_nagle, sizeof(disable_nagle));

  return (res == SOCKET_ERROR) ? -1 : 0;
}
}}

@h=tangler('demux/demux_overlapped.cpp')
@select(h)
#include "demux_overlapped.hpp"
#include <stdio.h>      // fprintf
#include <assert.h>

// cygwin's copy of mswsock.h leaves something to be desired...
#ifndef WSAID_CONNECTEX
typedef 
BOOL
(PASCAL FAR * LPFN_CONNECTEX) (
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen,
    IN PVOID lpSendBuffer OPTIONAL,
    IN DWORD dwSendDataLength,
    OUT LPDWORD lpdwBytesSent,
    IN LPOVERLAPPED lpOverlapped 
    );

#define WSAID_CONNECTEX \           
    {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
#endif

using namespace flx::pthread;
namespace flx { namespace demux {

// windows includes files here? vs will be fussy.

// AcceptEx

// return async finished flag (error flags - can be transmitted via class)
// AcceptEx is the way to get accept connections via the IOCP
bool
acceptex_control_block::start_overlapped()
{
  clear_overlapped();

// I've seen two examples get the pointer to AcceptEx, just in case it
// isn't implemented...
  // fprintf(stderr,"AcceptExing: listen backlog => can succeed immediately\n");

  // this is only set when acceptex receives data and returns immediately.
  // can't hurt to set it.
  DWORD nbytes = 0;
  BOOL  success;

  // note that in order to get the wakeup packet, the listener must
  // already be associated with the iocp. for future async io, the acceptor
  // must be associated too.
  success = AcceptEx(listener, acceptor,
    accept_buf,       // required - near/far address
    0,            // receive data size - don't yet want this
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    &nbytes,        // only set if fn completes. should be 0
    &ol);         // oblig. gets us back to the this ptr

  // if there is a backlog of connections, AcceptEx can return immediately
  if(success)
  {
    // must clear the wait
    fprintf(stderr,"WHOA! AcceptEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "This could be bad, as wait should call op_finish\n");
    fprintf(stderr, "We also lose the udat cookie (set to NULL)\n");
    // handle the successful wakeup
    // complete_async_op(demux, drv, nbytes, NO_ERROR); 
    // I hope they don't want the udat pointer, because I
    // just made it up (0=NULL). Not using it anyway.
    iocp_op_finished(nbytes, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();
    // can also return WSACONNRESET, which isn't so bad
    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"AcceptEx returned ERROR_IO_PENDING - that's normal\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      fprintf(stderr,"AcceptEx failed: %i\n", err);
      fprintf(stderr,"returning true should wake thread to detect failure.\n");
      return true;    // have self woken
    }
  }
  return false;       // async not finished

}

// ConnectEx
#if 0
// apparently we're supposed to do this now to make the acceptee inherit
// the listener's state. it is currently in the default state
//err = setsockopt( sAcceptSocket, 
//  SOL_SOCKET, 
//  SO_UPDATE_ACCEPT_CONTEXT, 
//  (char *)&sListenSocket, 
//  sizeof(sListenSocket) );
#endif

// what a pain in the arse (zzz)
// This doesn't exist in win2000, so it'll need to be synchronous there.
static int
GetConnectExAddr(SOCKET s, LPFN_CONNECTEX* conn_fn)
{
  *conn_fn = NULL;
  GUID      GuidConnectEx = WSAID_CONNECTEX;   
  DWORD     dwBytes;
  int       err;

  err = WSAIoctl(s,   // why do I need this?
    SIO_GET_EXTENSION_FUNCTION_POINTER,
    &GuidConnectEx,
    sizeof(GuidConnectEx),
    conn_fn,
    sizeof(*conn_fn),
    &dwBytes,
    NULL, NULL);    // no overlapped, no completion fun ptr
//  fprintf(stderr,"Get addr dwbytes: %li\n", dwBytes);
  return err;
}

// this is the weirdest. To use ConnectEx, the socket must be already bound.
// By trial and error, I found that it had to be bound to INADDR_ANY: 0.
// So strange. Apparently I don't have to do it again if I want to reuse.
static int
bind_socket(SOCKET s)
{
  SOCKADDR_IN   addr;

  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(0);

  return bind(s, (LPSOCKADDR)&addr, sizeof(addr));
}

bool
connectex_control_block::start_overlapped()
{
  clear_overlapped();

  // why not get this directly from the ConnectEx?
  socket_err = ERROR_IO_PENDING;


  DWORD bytes_sent = 0;   // we're not sending data on connect (yet)
  BOOL  success;

  LPFN_CONNECTEX  pfConnectEx;

  // unfortunate, will fix up later.
  // fprintf(stderr,"Getting ConnectEx address\n");

  // Turns out that ConnectEx isn't defined anywhere; I have to load its
  // addr via WSAIoctl
  // this is a bad way. make the driver cache it. why on earth is this
  // call per-socket? does it really need to be that way?
  if(GetConnectExAddr(s, &pfConnectEx) == SOCKET_ERROR)
  {
    fprintf(stderr,"GetConnectExAddr failed: %i\n", WSAGetLastError());
    return true;
  }

  // fprintf(stderr,"about to connectex to %s:%i, %i\n", addy, p, s);

  // this is so strange - I have to bind the socket to the localhost.
  // if I don't, ConnectEx returns EINVAL. in any case, I won't need
  // to do this again if I reuse this socket.
  if(bind_socket(s) == SOCKET_ERROR)
    fprintf(stderr,"ConnectEx bind failed: %i\n", WSAGetLastError());

  // I hope ConnectEx doesn't want this to hang around, because it's
  // going to drop off the stack after this.
  SOCKADDR_IN   addr;

  // some examples don't zero the addr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr(addy);
  addr.sin_port = htons(p);

  // in order to receive the wakeup packet, s must already be associated
  // with the iocp. this is best done at socket creation time. for these
  // sockets it's probably best to also bind them at the same time.
  // that requires "purposed" sockets (CreateConnectSocket?).
  // p.s. the default (waio_base) wakeup is doing fine for now.

  success = (*pfConnectEx)(s, // socket
    (LPSOCKADDR)&addr,    // connect address
    sizeof(addr),     // size thereof
    NULL,         // not sending any data yet, but we could
    0,            // ditto
    NULL,         // should be zero until this changes
    &ol);         // oblig. gets us back to the this ptr

// there's a caveat about the type of socket s becomes after ConnectEx.
// It's in some kind of default state and cannot be used with shutdown
// change it with setsockopt (?)
  if(success)
  {
    fprintf(stderr,"WHOA! ConnectEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "BAD: calls op_finish and loses udat cookie\n");
    // handle the successful wakeup. (udat=0, olp=&ol)
    iocp_op_finished(bytes_sent, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();

    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"ConnectEx pending...\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      // maybe store the error here. that could work for all
      // windows wakeups
      fprintf(stderr,"ConnectEx failed: %i\n", err);
      return true;    // have self woken
    }
  }
  return false;       // not finished
}

// TransmitFile

bool
transmitfile_control_block::start_overlapped()
{
  clear_overlapped();

  // 0 bytes => transmit entire file
  // the second zero means use the default chunk size
  // the NULL is for mem buffers to bookend the file with. nothing yet.
  // the final zero is for various flags, including a way of doing
  // DisconnectEx style socket reuse (more widely compatible?)

  // in order to receive the wakeup, s must already be associated with the
  // iocp. this is best done at socket creation time.
  if(TransmitFile(s, file, 0, 0, &ol, NULL, flags))
  {
    fprintf(stderr,"Transmit file succeeded immediately! waking...\n");
    return true;
  }
  else
  {
    DWORD err = WSAGetLastError();

    // will need to actually signal something
    // fprintf(stderr,"signal TransmitFile failure!\n");
    if(ERROR_IO_PENDING != err && WSA_IO_PENDING != err)
      fprintf(stderr,"genuine error from TransmitFile: %li\n", err);
  }
  return false;
}


// SOCKET io using WSASend and WSARecv

// windows style control blocks
wsasocketio_control_block::wsasocketio_control_block(SOCKET src, sel_param* pb,
  bool inread)
  : s(src), ppb(pb), reading(inread)
{
}

bool
wsasocketio_control_block::start_overlapped()
{
  clear_overlapped();

  error = 0;

  // num bytes received IF recv completes immediately.
  DWORD imm_bytes;
  int   recv_res;

  // set up the single wbuf, bearing in mind we may be part way.
  wbufs[0].len = ppb->buffer_size - ppb->bytes_written;
  wbufs[0].buf = ppb->buffer + ppb->bytes_written;

// fprintf(stderr, "sockio: %p->finished = %i, reading = %i\n",
//  ppb, ppb->finished(), reading);

  // Ideally, we would like to be able to use MSG_WAITALL, which would
  // let us only get a completion packet when either all the data was
  // available or the connection had been closed or shutdown.
  // Unfortunately this is not possible for non-blocking sockets, so
  // we have to take whatever we get and then call WSARecv again.

  //#define MSG_WAITALL 0   // not defined in cygwin - apparently this
  //DWORD flags = MSG_WAITALL;

  // ah, unfortunately MSG_WAITALL is not supported for non blocking sockets
  // we'll just have to do it ourselves
  DWORD flags = MSG_PARTIAL;

  // completion routines! (unused)
  if(reading)
    recv_res = WSARecv(s, wbufs, NUM_WBUFS, &imm_bytes, &flags, &ol, NULL);
  else
    recv_res = WSASend(s, wbufs, NUM_WBUFS, &imm_bytes, flags, &ol, NULL);

  // don't know if I need to check non winsock errs

  switch(recv_res)
  {
    case 0:
    {
      // flags are updated to indicate what? if there was a callback, it
      // would be scheduled to be called when this thread is in the
      // waitable state, whatever that means.
      //fprintf(stderr,
      //  "WSA%s completed immediately!!! nbytes: %li, flags: %lx\n",
      //    (reading) ? "Recv" : "Send", imm_bytes, flags);

      // looks like we get the completion packet even if we do finish
      // immediately so let the iocp wake us. note that this method
      // of manually calling iocp_op_finished is not so great as we
      // don't know the (as yet unused) udat cookie and so set it to 0.
      // fprintf(stderr, "calling finished manually (ppb=%p)\n", ppb);
      // iocp_op_finished(imm_bytes, 0, &ol, NO_ERROR); 

      // false because iocp_op_finished will wake us. I guess false from
      // these guys means that a completion packet is in the mail and
      // true means that it isn't (in the mail).
      return false;
    }
    break;
    case SOCKET_ERROR:
    {
      DWORD err = WSAGetLastError();

      // normal mode - wait for completion
      // fyi, xp pro seems to mostly give us ERROR_IO_PENDING
      if(ERROR_IO_PENDING == err || WSA_IO_PENDING == err)
      {
        // fprintf(stderr,"WSA%s pending completion (%li)\n",
        //  (reading) ? "Recv" : "Send", err);
        return false;     
      }

      fprintf(stderr,"WSARecv/Send returned SOCKET_ERR: %li\n", err);
      return true;    // assume it's bad and we won't get a wakeup
    }
    break;
    default:
    {
      fprintf(stderr,"WSARecv/Send returned other error: %i, GetLastError: %li\n",
        recv_res, GetLastError());
      return true;        // wake up
    }
    break;
  }

  return false;
}

// NB: called by iocp::wait, so be aware of which thread is doing what, lest
// you be surprised by this being called asynchronously.
void
wsasocketio_control_block::iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  error = err;        // copy back for others to look at.
                // perhaps move back to iocpwakeup
// fprintf(stderr, "wsasocketio::finished: ppb=%p, nbytes=%li, err=%i, read=%i\n",
//  ppb, nbytes, err, reading);

  if(err)
  {
    fprintf(stderr, "wsasocketio, got error: %i\n", err);
  }

  // fprintf(stderr,"wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );
assert( !ppb->finished() );
  // keep track of bytes received.
  ppb->bytes_written += nbytes;

  if(0 == nbytes)
  {
    fprintf(stderr, "wsaiosocket got zero bytes: err=%i, read=%i\n",
      err, reading);
  }

  // if we're not finished, we have to reinstall our request
  // zero bytes indicates shutdown/closure, right?
  // might be using this for WSASend. Instead of broken pipes on win32, 
  // instead we get WSAECONNRESET (pretty sure) on write. On read?
// not sure about this - I don't think we have to check nbytes == 0
  if(0 == nbytes || ppb->finished())
  {
    return;
  }
  else
  {
    // go back around again
    fprintf(stderr,"didn\'t get everything (%li of %li bytes)\n",
      ppb->bytes_written, ppb->buffer_size);
    if(start_overlapped())
    {
      fprintf(stderr, "UM, socket restart finished immediately\n");
      fprintf(stderr, "causes new wakeup? or should I loop around?\n");
    }
  }
}


// file io using ReadFile and WriteFile

winfileio_control_block::winfileio_control_block(HANDLE f, void* buf, int len, bool inread)
  : file(f), reading(inread)
{
  // pb is not so useful here. we only want to
  // know num bytes written/processed.
  pb.buffer = (char*)buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// if file is opened with FILE_FLAG_OVERLAPPED, we can do "immutable file ptr"
// ops & set the desired offset within the overlapped. can also stick an
// event to signal in there.
bool
winfileio_control_block::start_overlapped()
{
  // fprintf(stderr,"winfileio_cb::start_overlapped: reading=%i\n", reading);
  clear_overlapped();

  // DWORD  imm_bytes;
  BOOL  success;

  // don't need bytes read, written when we have an OVERLAPPED
  if(reading)
    // success = ReadFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = ReadFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
  else
    //success = WriteFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = WriteFile(file, pb.buffer, pb.buffer_size, NULL, &ol);

  // fprintf(stderr,"immbytes = %li\n", imm_bytes);

  if(!success)
  {
    int err = GetLastError();

    // I'm getting this for unfinished
    if(ERROR_IO_PENDING == err)
    {
       return false;  // sleep on
    }
    else
    {
       fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
         err);
       return true;      // ask for wakeup
    }

    // fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
    //  GetLastError());
    // fprintf(stderr,"do I still get completion packet???\n");
    // assume not
  }

  return false;       // sleep on
}

}}

@h=tangler('demux/demux_overlapped.hpp')
@select(h)
#ifndef __DEMUX_OVERLAPPED__
#define __DEMUX_OVERLAPPED__
#include "flx_demux_config.hpp"

// visual studio is quite sensitve about how you do these includes.
#include <WinSock2.h>              // Winsock2 (WSABufs, etc) must come before Windows.h
#include "demux_iocp_demuxer.hpp"  // this header file include Windows.h
#include <MSWSock.h>  // AcceptEx, TF_REUSE_SOCKET, etc

namespace flx { namespace demux {

// rename these to control block something or other
// get rid of default constructors - faio can worry about that.

// WARNING: in some "immediate completion" cases I have to call
// the finished function myself - in these cases I set the udat to 0, making
// it not very reliable. Either make sure the user understands immediate
// finish (and does it themselves) or keep a copy of udat.

// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class DEMUX_EXTERN acceptex_control_block : public iocp_wakeup {
  enum { ACCEPTEX_ADDR_SIZE = sizeof(SOCKADDR_IN) + 16 };

public:
  SOCKET  listener, acceptor;
  // there are two of these!
  char  accept_buf[2*ACCEPTEX_ADDR_SIZE];

  virtual bool start_overlapped();

  acceptex_control_block() 
    : listener(INVALID_SOCKET), acceptor(INVALID_SOCKET) {}
};

class DEMUX_EXTERN connectex_control_block : public iocp_wakeup
{
public:
  // move further back?
  int socket_err;         // outgoing

  // can have buffer to be sent on connection
  SOCKET    s;          // previously unbound socket
  const char* addy;       // ipv4 address
  int     p;          // port number

  // socket_err undefined
  connectex_control_block() : s(INVALID_SOCKET), addy(0), p(0) {}

  // see posix version of this, try to keep them in sync. give socket_err
  // initial definition that works with this?
  bool finished() { return ERROR_IO_PENDING != socket_err; }

  virtual bool start_overlapped();
};

// TransmitFile here (requires file handle)
class DEMUX_EXTERN transmitfile_control_block : public iocp_wakeup {
  SOCKET  s;
  HANDLE  file;
  DWORD flags;                // for possible socket reuse.
public:

  transmitfile_control_block(SOCKET dst)      // for reuse of socket
    : s(dst), file(NULL), flags(TF_DISCONNECT | TF_REUSE_SOCKET) {}

  transmitfile_control_block(SOCKET dst, HANDLE src)  // actual transmitfile
    : s(dst), file(src), flags(0) {}

  virtual bool start_overlapped();
};


// handles both WSASend & WSARecv
class DEMUX_EXTERN wsasocketio_control_block : public iocp_wakeup {
protected:
  enum { NUM_WBUFS = 1 }; // just one for now, but can do scattered send/recvs
  WSABUF    wbufs[NUM_WBUFS];
public:
  SOCKET    s;
  sel_param*  ppb;      // on input what you want, on output what you got
  int     error;
  bool    reading;  // else use WSASend

  // watch the memory interfaces here, going back and forth between threads.
  wsasocketio_control_block(SOCKET src, sel_param* pb, bool read);

  virtual bool start_overlapped();

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// looks a bit like wsasocketio_control_block (bad name, sends too)
class DEMUX_EXTERN winfileio_control_block : public iocp_wakeup {
  HANDLE    file;
  bool    reading;
public:
// probably should be a pointer (?)
  sel_param pb;

  // offset?
  winfileio_control_block(HANDLE f, void* buf, int len, bool read);

  virtual bool start_overlapped();

  //virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  //  LPOVERLAPPED olp, int err);
};

}}

#endif
@h=tangler('demux/demux_kqueue_demuxer.cpp')
@select(h)
// kqueue demuxer for bsd/os x
// N.B. calling close on a file descriptor will remove any kevents that
// reference that descriptor. that would explain remove complaining from
// time to time.
// try EV_EOF to pick up eofs, useful for async file io.

#include "demux_kqueue_demuxer.hpp"
#include "demux_self_piper.hpp"

#include <stdio.h>      // perror
#include <unistd.h>     // close

#include <sys/types.h>    // from the kqueue manpage
#include <sys/event.h>    // kernel events
#include <sys/time.h>   // timespec (kevent timeout)

// #include <sys/syscall.h> // syscall(SYC_close,kq) close workaround

namespace flx { namespace demux {
kqueue_demuxer::kqueue_demuxer()
  : kq(-1)
{
  // Not that you care, but this event queue is not inherited by
  // forked children.
  kq = kqueue();
  if(-1 == kq)
  {
    perror("kqueue");
    throw -1;
  }
}

kqueue_demuxer::~kqueue_demuxer()
{
  // calling close on a kq while a thread is waiting in kevent causes close
  // to block! this happens on 10.4. Hard to say on 10.3 as close simply
  // fails there. we need to wake the waiting thread, so we'll use that
  // handy self pipe waker. Luckily, kqueues are responsive to new fds,
  // otherwise we'd need the self pipe waker to be there from the start 

fprintf(stderr, "trying to nicely take down kqueue\n");
  // we don't want exceptions being thrown in a destructor
  try {
    // this will wake the thread (there should only be one atm), however
    // that's just another race between kevent and close. really need to
    // extend self piper to set a quit flag. we have to currently assume
    // that there is only event collecting thread.
    self_piper sp;
    // clean this up
    sp.install(this, true);  // install WITH QUIT FLAG
    sp.wake();
  } catch(...) {
    fprintf(stderr, "error waking kqueue with self pipe trick\n");
  }

  //if(syscall(SYS_close, kq) == -1)
  // I don't seem to be able to close a kq. can't fstat it either
  if(-1 != kq && close(kq) == -1)
    perror("kqueue close");
}


// Events of interest to us ERead, EWrite.
// ERead has fflags: NOTE_LOWAT, NOTE_EOF. ident is a descriptor (any?) 

// if you're using the kqueue_demuxer to do a single biderectional wakeup,
// be aware that it currently breaks the "one shot" rule, that is you
// make get an unexpected wakeup the next time you call wait.
int
kqueue_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // we only know these flags
  if((flags & ~(PDEMUX_READ | PDEMUX_WRITE))) return -1;

// could set wakeup_flags here of what's been installed!

  // FUCK - can only do one at a time with kqueues
  // For those doing both, if one fails, you're in a bit of trouble.
  if(flags & PDEMUX_READ)
  {
    if(add_kqueue_filter(sv, EVFILT_READ) == -1) return -1;
  }

  if(flags & PDEMUX_WRITE)
  {
    if(add_kqueue_filter(sv, EVFILT_WRITE) == -1) return -1;
  }

  return 0;
}

int
kqueue_demuxer::add_kqueue_filter(socket_wakeup* sv, short filter)
{
  int       s = sv->s;
  struct kevent evt;
  
  // this works just like select if the s is a listening socket
  // *except* works with all types of fds, including pipes, files & fifos
  // can set low water mark for reads with NOTE_LOWAT in fflags and size
  // in data. on return data contains number of bytes available to read
  // on return sets EV_EOF in flags if read dir socket has shutdown and
  // returns a possible socket err in fflags
  // should that be EV_ENABLE | EV_ADD. fflags zero cos I don't know what
  // to put there. pass pb in udata
  
  // adding EV_ONESHOT to save me removing on wakeup (a syscall).
  // I now require that during the evt be removed before wakeup fn.
  
  EV_SET(&evt, s, filter, EV_ADD | EV_ONESHOT, 0, 0, sv);
  // trying to detect when have reached eof with async file io using kq
  //EV_SET(&evt, s, EVFILT_READ, EV_ADD, | EV_ONESHOT NOTE_LOWAT, 16*1024, sv);

  // add event
  if(kevent(kq, &evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent add_kqueue_filter");
    return -1;
  }
  return 0;
}

// useful, but unused atm, thanks to ONESHOT.
// this function skirts the portability boundaries of the demux interface
// for kqueues each event monitor is identified (for sockets) by a pair,
// (s, filter), or for us, (s, {in|out}). This means that we can add
// individual wakeups for reading and writing but not both at once.
// I think epoll can do both, and so can select (and N/A to IOCPs).
// This "both at once" thing can't easily be one shot. There's a good
// case for this behaviour to be defined "undefined". Not many people
// using this part - could be caveat emptor...
int
kqueue_demuxer::remove_kqueue_filter(int s, short filter)
{
  struct kevent evt;

  EV_SET(&evt, s, filter, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent remove_socket_wakeup");
    return -1;
  }

  return 0;
}

int
kqueue_demuxer::remove_socket_wakeup(int s, int flags)
{
  int r1 = 0, r2 = 0;

  if(flags & PDEMUX_READ) r1 = remove_kqueue_filter(s, EVFILT_READ);
  if(flags & PDEMUX_WRITE) r2 = remove_kqueue_filter(s, EVFILT_WRITE);

  // If you want to know which one failed, you're out of luck.
  if(r1 || r2) return -1;

  return 0;
}

// from "advanced macos programming", on reading shutdown causes
// the EV_EOF flag to be set in the flags field and returns errno
// in the fflags field. There may still be pending data to read
// when EV_EOF is set. The data field says how many bytes available.
// for writing data says how much you can write. EV_EOF is set
// when the reader "disconnects". Says nothing about errno/fflags
// in this case.
/*
    fprintf(stderr,"readevt on %i, EOF = %s\n",
      s, (ev.flags & EV_EOF) ? "TRUE" : "FALSE");
 */

// do that thing where you get the events. can I get them one at a time?
// I bet I can.
void
kqueue_demuxer::get_evts(bool poll)
{
  // event seems to remain unless we remove it
  struct kevent ev;
  int       nevts;

  struct timespec timeout, *tptr = NULL;
  
  if(poll)
  {
    timeout.tv_sec = 0;   // effectuate a poll
    timeout.tv_nsec = 0;
    tptr = &timeout;
  }

  // timeout.tv_sec = 1;    // timeout every second
  // timeout.tv_nsec = 0; // 10^9 nanoseconds per second

  nevts = kevent(kq, NULL, 0, &ev, 1, tptr);  // wait or poll
  if(nevts <= 0)
  {
    // error, else timeout & return to allow cancel
    if(nevts < 0)
      perror("kevent event fetch");

    return;
  }

  // fprintf(stderr,"kqueue wakeup!\n");

  socket_wakeup*  sv = (socket_wakeup*)ev.udata;

  // The filters are not bit fields, hence they must come in serially.
  // this means you're never going to get both read and write on
  // a kqueue_demuxer wake up. No worries.
  if(ev.filter == EVFILT_READ)
  {
  // this capability is lost for the moment, as we have no way
  // of explaining it to felix. the event stuff isn't so good right now
/*
    // can chunk up on accepts. nice one kqueue
    if(NULL == sv)      // => listener
    {
      int backlog = (int)ev.data;   
      // fprintf(stderr,"kq listen backlog: %i\n", backlog);
      for(int i = 0; i < backlog; i++) handle_connection();
    }
    else
*/
    // If a socket wakeup were a control block, you'd set the err here.
    if(0 && ev.flags & EV_EOF)
    {
      // errno in fflags!
      fprintf(stderr,
        "got EV_EOF on read, %i bytes remain in buffer, errno=%i\n",
        (int)ev.data, ev.fflags);
    }
    // fprintf(stderr,"EVFILT_READ: got %i bytes coming\n", (int)ev.data);
    // remove_reading_fd(s);      // now useing EV_ONESHOT
// remove other outstanding here...?
    sv->wakeup_flags = PDEMUX_READ;   // Tell 'em what they've won.
    sv->wakeup(*this);
  }
  else if(ev.filter == EVFILT_WRITE)
  {
    // fprintf(stderr,"EVFILT_WRITE: can write (?) %i bytes\n",
    //  (int)ev.data);

    // using oneshot mode now.
    // remove_writing_fd(s);

    if(ev.flags & EV_EOF)
    {
      // errno in fflags? data should be zero bytes, right?
      // can't write anything
      fprintf(stderr,
        "got EV_EOF on write, data bytes =%i (0?), errno/fflags?=%i\n",
        (int)ev.data, ev.fflags);
    }
// remove other outstanding here?
    sv->wakeup_flags = PDEMUX_WRITE;
    sv->wakeup(*this);
  }
  else
  {
    fprintf(stderr,"unsolicited event from kqueue (%i)...\n", ev.filter);
    // no wakeup
  }
}
}}

@h=tangler('demux/demux_pfileio.cpp')
@select(h)
#include <stdio.h>    // printf
#include <errno.h>    // errno
#include "demux_pfileio.hpp"

// blocking reads & writes that use a worker fifo. users overload
// finished flag to implement wakeup

// if we could group the requests, we could do a scattered read
// or we could do single reads if the requests were of a similar
// nature, i.e. the whole file, of popular files.

// for pwrite/pread, I'm supposed to include the following three (osx man page)
// they don't appear to be necessary, but let's play it safe
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

using namespace flx::pthread;
namespace flx { namespace demux {
// fileio_request stuff follows

// read or write in a blocking fashion. I like the idea of using pread
// which doesn't change the file pointer. this could allow reuse of the same
// file descriptor & block caching

fileio_request::~fileio_request(){}
fileio_request::fileio_request(){}

fileio_request::fileio_request(int f, char* buf, long len, long off, bool rd)
  : offset(off), fd(f), read_flag(rd), err(0)
{
  pb.buffer = buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// synchronously process read/write
void
fileio_request::doit()
{
  // fprintf(stderr,"faio about to try to %s %i bytes from fd=%i\n",
  //  (read_flag) ? "read" : "write", pb.buffer_size, fd);

// switching off (explicit) seeks for now because I'm not using them
// in the flx code & I'm not passing around enough info (just the fd)
  ssize_t res;

  if(read_flag)
  {
    // res = pread(fd, pb.buffer, pb.buffer_size, offset);
    res = read(fd, pb.buffer, pb.buffer_size);
  }
  else
  {
    // res = pwrite(fd, pb.buffer, pb.buffer_size, offset);
    res = write(fd, pb.buffer, pb.buffer_size);
  }
  
  // zero return value indicates end of file. that should just work.
  if(-1 == res)
  {
    err = errno;    // grab errno
    fprintf(stderr,"faio error: %i\n", err);
  }
  else
  {
    // fprintf(stderr,"faio %s %i bytes\n", (read_flag) ? "read" : "write", res);
    pb.bytes_written = res;
  }
}
}}

@h=tangler('demux/demux_posix_demuxer.cpp')
@select(h)
#include "demux_posix_demuxer.hpp"
#include "demux_sockety.hpp"

#include <stdio.h>        // "printf"
#include <assert.h>       // assert
#include <string.h>       // strerror
#include <unistd.h>       // close

#include <sys/types.h>      // send/recv
#include <sys/socket.h>

//#include <sys/errno.h>
#include <errno.h>        // GUSI & solaris prefer this

namespace flx { namespace demux {

posix_demuxer::~posix_demuxer()
{
}

bool
posix_demuxer::socket_recv(int s, sel_param* pb)
{
  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;
  
  // if this were read then this fn would work with non-sockets
  nbytes = recv(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written, 0);

  if(nbytes <= 0)
  {
    if(nbytes == 0)
    {
      return true;        // connection closed
    }
    else
    {
      perror("recv");       // can get reset connection here
      return true;        // so say closed, yeah?
    }
  }
  else
  {
    // got some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

bool
posix_demuxer::socket_send(int s, sel_param* pb)
{
  // kqueue (and some of the other ones) can let you know know how much
  // to write... imagine that!

  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;

  nbytes = send(s, pb->buffer + pb->bytes_written,
    pb->buffer_size - pb->bytes_written, 0);

  // similar story here, with send vs write?

  // what's the story with zero? Is that allowed or does it signal
  // that the connection closed?
  if(-1 == nbytes)
  {
    perror("send");
    return true;          // I guess the connection closed
  }
  else
  {
    // sent some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

#if 0
  //nbytes = recv(s, pb->buffer + pb->bytes_written,
  //      pb->buffer_size - pb->bytes_written, 0);

  // select and kqueue know when non socket fds have data.
  // recv only works with sockets, but read works with both files
  // and sockets and who knows what else. is there any disadvantage
  // to using read instead? apart from losing flags arg?
  // does read get the same 0 bytes = close behaviour
  nbytes = read(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written);
#endif

// handy posix control blocks for accept, connect.

int
accept_control_block::start(posix_demuxer& demux)
{
  // add listener to demuxer as reading socket - see man 2 accept
  // returns 0 on success, -1 on failure. not sure how to communicate
  // the error.
// could try the accept now, to see if it succeeds instantly...
// observe wakeup rules (formulate them first)
  accepted = -1;
  // socket_err = 0;
  // not quite true, but I want it to be clear if this ever becomes possible
  // to do immediately
  socket_err = EINPROGRESS;
    return demux.add_socket_wakeup(this, PDEMUX_READ);
}

// one wakeup socket is in accepted and error in socket_err
void
accept_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"accept_control_block woke up\n");

  // we can now accept without blocking
  // s is the listener, ambiguously named in parent socket_wakeup class
  accepted = nice_accept(s, &socket_err);

  if(accepted == -1)
  {
    fprintf(stderr, "nice_accept failed, err (%i)\n", socket_err);
  }
}

// returns -1 on failure, 0 on success. on success the call is finished
// (and so no wakeup) if socket_err == 0.
int
connect_control_block::start(posix_demuxer& demux)
{
  // fprintf(stderr,"async connect start\n");

  int finished;

  // returns either finished and err, or not finished
  // and (no err || EINPROGRESS)
  s = async_connect(addy, p, &finished, &socket_err);

  // fprintf(stderr,"async_connect returned s: %i, finished: %i, err=%i\n",
  //  s, finished, socket_err);

  if(-1 == s)   // failed!
  {
    fprintf(stderr,"async_connect failed (%i)\n", socket_err);
    return -1;  // error in socket_err, no wakeup
  }

  if(finished)
  {
    // this actually happens on solaris when connecting to localhost!
    fprintf(stderr,"async_connect finished immediately, waking\n");
    fprintf(stderr, "No wakeup coming...\n");
    // this does not indicate an error, but that there is no wakeup
    // coming. this could be done by a wakeup, all that happens is
    // getsockopt is called to check the socket's error state.
    return -1;          
  }

  // fprintf(stderr,"connect_request didn't finish immediatly, sleeping\n");

  // add to demuxer as writing socket - see man 2 connect
  // how do they get the error?
    return demux.add_socket_wakeup(this, PDEMUX_WRITE);
}

void
connect_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"connect woke up\n");
  // this is how we check the success of async connects
  // if get_socket_err fails, we're treating its errno as the socket's...
  if(get_socket_error(s, &socket_err) == -1)
    fprintf(stderr, "eep - get_socket_err failed!\n");

  // failed, throw away socket
  if(0 != socket_err)
  {
    fprintf(stderr,"async connect error: %s (%i), closing\n",
      strerror(socket_err), socket_err);
    // we created the connect socket, so we close it too.
    if(close(s) != 0)
      perror("async socket close");

    s = -1;   // the result
  }

  // resulting connected socket in s
}
}}

@h=tangler('demux/demux_select_demuxer.cpp')
@select(h)
// P.S. for current impl don't need the pthreads. WHOO!!!

// A very light wrapper around select, that allows the addition
// of new sockets and returns status in a queue.
// on the powerbook with 10.3, FD_SETSIZE is 1024, that means
// max 1024 sockets. That's kind of lame. See IO completion ports
// on NT for a better solution.

// See ACE_Handle_Set_Iterator for an optimised seelect bit field examination
// algorithm (p149 C++ network programming, volume1)

// see epoll, kqueue & IOCPs

// is select level triggered? I think it is.
// strangely, I'm never seeing anything from the exception set.

#include "demux_select_demuxer.hpp"

#include <assert.h>
#include <string.h>       // memset

#include <stdio.h>        // printf debug
#include <stdlib.h>
#include "demux_sockety.hpp"  // get_socket_error
#include <memory>

namespace flx { namespace demux {

select_demuxer::select_demuxer()
{
  // clear these guys. after the thread starts, access to them will have
  // to be via the lock
  FD_ZERO(&master_read_set);
  FD_ZERO(&master_write_set);
  FD_ZERO(&master_except_set);
  fdmax = 0;        // corresponds to stdin, which we're not using

  // clear this possibly quite large list
  //memset(svs, 0, sizeof(svs));
  //JS: memset must not be used except for raw data or chars
  std::uninitialized_fill_n(svs,FD_SETSIZE,(socket_wakeup*)0);
}

// one select, must not block indefinitely, so choose a timeslice
// or find a way to make it wake on command, like a dummy socket
void
select_demuxer::get_evts(bool poll)
{
  // to use select we must copy our arguments, as it changes them!
  // this code has been broken up in to pieces so that I can implement

  fd_set  read_set, write_set, except_set;

  copy_sets(read_set, write_set, except_set);
  
  if(select(read_set, write_set, except_set, poll))
    process_sets(read_set, write_set, except_set);
}

int
select_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  int s = sv->s;

  // fprintf(stderr, "adding select wakeup for %i, flags=%x\n", s, flags);

  if(s < 0 || s >= FD_SETSIZE) return -1; // weakness of select

  assert(svs[s] == NULL);         // sanity check: nothing there

  if(flags & PDEMUX_READ) FD_SET(s, &master_read_set);

  if(flags & PDEMUX_WRITE) FD_SET(s, &master_write_set);

  // does this mean we could add a non-reading, non-writing socket
  // and wait for errors on it?
  FD_SET(s, &master_except_set);

  svs[s] = sv;              // record wakeup. ours now.


  if(s > fdmax) fdmax = s;        // update highwater mark

  return 0;
}

// removes for both reading AND writing.
void
select_demuxer::remove_fd(int s)
{
  // fprintf(stderr, "removing select fd: %i\n", s);

  assert(s >= 0 && s < FD_SETSIZE);
  assert(svs[s] != NULL);         // there should be something there

  // clear them all regardless. 
  FD_CLR(s, &master_read_set);
  FD_CLR(s, &master_write_set);
  FD_CLR(s, &master_except_set);

  svs[s] = NULL;
}

// virtual functions to be overridden for thread safe descendent
void
select_demuxer::copy_sets(fd_set& rset, fd_set& wset, fd_set& exset)
{
  rset = master_read_set;
  wset = master_write_set;
  exset = master_except_set;
}

bool
select_demuxer::select(fd_set& rset, fd_set& wset, fd_set& exset, bool poll)
{
  // this is depending on my fake socket to wakeup. perhaps use the timer
  // for now.
  struct timeval  tv, *tp = NULL;
  //tv.tv_sec = 0;
  //tv.tv_usec = 1000000/100;

  if(poll)
  {
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    tp = &tv;
  }
  
  // the return value here actually has significance
  // sometimes I have to try again, or weed out bad fds.
  //if(select(fdmax+1, &read_set, &write_set, &except_set, &tv) == -1)
// nah! wait forever. none of these things shutdown properly yet.
// it'll force the async new wakeup responsiveness
  switch(::select(fdmax+1, &rset, &wset, &exset, tp))
  {
    case 0:
      return false;   // timed out, don't process sets
    break;
    case -1:
    // not the ideal reaction. I think this is where I weed out
    // the bad socket(s). would need error set.

    // closing a socket without removing can get us here. that's pretty
    // nasty, because our data would be stale. Try not to do that. I
    // wonder if the except set would tell us when the socket was
    // closed on us? Damn, you have to clear it, else you keep getting
    // the same error.
      perror("select");
      // fall through and examine except set
    break;
  }
  return true;    // call process_sets
}

void
select_demuxer::process_sets(fd_set& rset, fd_set& wset, fd_set& exset)
{
  // since we're about to traverse the socket sets anyway, we should
  // note the highest fd seen, and make that the highwater mark.
  // that way we wouldn't be guaranteed monotonically degrading performance.

  // might be worth keeping a low water mark as well.
  // I guess this is why select sucks. On osx we can only watch
  // about 1024 sockets. That sucks too. could allocate larger sets
  // with malloc... see c++ network programming book.

  // like kqueues, this code could theoretically handle separate wakeups
  // for read and write, should I do it? not right now.
  int new_fdmax = 0;

  for(int i = 0; i <= fdmax; i++)
  {
    int   flags = 0;

    if(FD_ISSET(i, &rset)) flags |= PDEMUX_READ;

    if(FD_ISSET(i, &wset)) flags |= PDEMUX_WRITE;
  
    // sorta suggests that I ought to call the wakeup and pass
    // an error flag on to it.
    if(FD_ISSET(i, &exset))
    {
      // don't remove bad sockets - it's an error to close the socket
      // or deallocate the wakeup without telling the source. when
      // we get socket errors, we'd better hope that there's reading
      // or writing to be done.
      // under cygwin, closing down a socket (read, write or both)
      // causes select to wake up with an exception bit. out of cygwin
      // we only wake up. In both cases, the read bit is set so
      // just handling the stuff seems to work. not sure about write.
      // posix_demuxer::socket_recv thinks the connection's closed, but
      // it all seems to work out. Yours, Confused.

      fprintf(stderr, "select error on socket %i, flags=%x\n",
        i, flags);

      int err;
      // heh heh, this isn't great to call on the pipe that is used
      // in the self pipe trick. I don't know why it's getting an
      // err anyway.
      if(get_socket_error(i, &err) == -1)
        fprintf(stderr, "get_socket_error failed!?!\n");

      fprintf(stderr, "socket err = %i, %s\n", err, strerror(err));
      // don't remove! see below
      // remove_fd(i);
    }

    //
    if(flags)
    {
      socket_wakeup*  sv = svs[i];
      // remove before wakeup so wakeup can add itself back, 
      // if necessary.
      remove_fd(i);

      sv->wakeup_flags = flags;
      sv->wakeup(*this);
    }

    // to lower high-watermark, keep track of highest seen.
    if(svs[i]) new_fdmax = i;
  }

  // fprintf(stderr, "new_fdmax=%i, fdmax=%i\n", new_fdmax, fdmax);

  fdmax = new_fdmax;      // copy it back
}

}} // flx, demux

@h=tangler('demux/demux_ts_select_demuxer.cpp')
@select(h)
#include "demux_ts_select_demuxer.hpp"
#include <stdio.h>
#include <unistd.h>       // pipe for self-pipe trick.
#include <assert.h>

using namespace flx::pthread;
namespace flx { namespace demux {

ts_select_demuxer::ts_select_demuxer()
{
  // fprintf(stderr, "creating pipe for self-pipe trick\n");
  // install self pipe trick
  sp.install(&demux);
}

void
ts_select_demuxer::get_evts(bool poll)
{
  fd_set  rset, wset, exset;

  // copy args under lock
  {
    flx::pthread::flx_mutex_locker_t locker(ham_fist);
    demux.copy_sets(rset, wset, exset);
  }
  
  // process arg set under lock. note that the select demuxer is passed
  // to wakeups, so no recursive lock is needed. also, because any 
  // readditions caused by the callback are done to the naive demuxer,
  // no selfpipe writes are required either. the only thing to remember
  // is that the wakeup recipient should not be surprised to see a demuxer
  // in its callback different to the one it originally added to.
  if(demux.select(rset, wset, exset, poll))
  {
    flx::pthread::flx_mutex_locker_t locker(ham_fist);
    demux.process_sets(rset, wset, exset);
  }
}

// thread safe overloaded functions follow. all acquire the lock
// then call the unthreadsafe version of the function. nice!
int
ts_select_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // fprintf(stderr, "ts_select::add: %p->%i (%s), %x\n",
  //  sv, s, (s == self_pipe_fds[0]) ? "self pipe" : "socket", flags);
  flx::pthread::flx_mutex_locker_t locker(ham_fist);

  int res = demux.add_socket_wakeup(sv, flags);
  // I wouldn't touch the sv after this.

  // we have a new socket, so wake the wait thread
  if(-1 != res) sp.wake();

  return res;

// we need to wake a blocking get_evts call here else we'll have bad
// performance or even a lockup. the question is do we need to do it under
// the tutelage of the lock?
}

}}

@h=tangler('demux/demux_sockety.hpp')
@select(h)
#ifndef __DEMUX_SOCKETY__
#define __DEMUX_SOCKETY__
#include <flx_demux_config.hpp>
namespace flx { namespace demux {

// Shouldn't this all be DEMUX_EXTERN?
int create_listener_socket(int* io_port, int q_len);
int create_async_listener(int* io_port, int q_len);
int nice_accept(int listener, int* err);
int nice_connect(const char* addr, int port);
int async_connect(const char* addr, int port, int* finished, int* err);

/* handy socket building blocks */

int connect_sock(int s, const char* addr, int port);

/* this could possibly do with NIC addr as well as port */
int bind_sock(int s, int* io_port);

int make_nonblock(int s);
int set_tcp_nodelay(int s, int disable_nagle);
int get_socket_error(int s, int* socket_err);

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_self_piper.hpp')
@select(h)

#ifndef __DEMUX_SELF_PIPER__
#define __DEMUX_SELF_PIPER__

#include <flx_demux_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// there's no standard posix_socketio_wakeup, could be handy. could also
// perhaps use it here? this is a pipe, not a socket. not sure if recv nor
// send work on it, besides want to read an unlimited amount of redundant
// data.
class DEMUX_EXTERN selfpipe_wakeup : public socket_wakeup {
public:
    bool request_quit;

    virtual void wakeup(posix_demuxer& demux);
};

class DEMUX_EXTERN auto_fd {
public:
    int fd;

    auto_fd();
    ~auto_fd();
};

class DEMUX_EXTERN self_piper {
    // self pipe trick!!! fd[0] = read end, fd[1] = write end.
    auto_fd         fds[2];
    selfpipe_wakeup spw;

public:
    self_piper();
    void install(posix_demuxer* demux, bool request_quit = false);
    void wake();
};

}} // namespace demux, flx

#endif
@h=tangler('demux/demux_self_piper.cpp')
@select(h)

#include "demux_self_piper.hpp"
#include <stdio.h>              // printf, perror
#include <unistd.h>             // pipe for self-pipe trick.
#include <assert.h>

namespace flx { namespace demux {

auto_fd::auto_fd()
{
    fd = -1;        // invalid
}

auto_fd::~auto_fd()
{
    if(-1 == fd) return;

    if(close(fd) == -1)
        perror("auto fd close");
}


self_piper::self_piper()
{
    // fprintf(stderr, "creating pipe for self-pipe trick\n");

    int         self_pipe_fds[2];
    if(pipe(self_pipe_fds) == -1)
    {
        perror("ts_select_demuxer::self_pipe");
        throw -1;
    }

    // fprintf(stderr, "self pipe fds: read: %i, write: %i\n",
    //  self_pipe_fds[0], self_pipe_fds[1]);

    fds[0].fd = self_pipe_fds[0];
    fds[1].fd = self_pipe_fds[1];

    spw.s = self_pipe_fds[0];   // setup wakeup for read end of pipe

    // this is a tiny bit ugly. I've added a flag to self_piper that causes
    // its wakeup callback to set the demuxer's quit flag. I've arranged this
    // so that the thread that sets the flag (the wakeup callback) and the
    // the thread that checks it (the demux wait thread) are the same.
    // Precarious!
    spw.request_quit = false;
}

void
self_piper::install(posix_demuxer* demux, bool request_quit)
{
    spw.request_quit = request_quit;
    int res = demux->add_socket_wakeup(&spw, PDEMUX_READ);
    assert(-1 != res);
}


// wake the demuxer referenced in install
void
self_piper::wake()
{
    // fprintf(stderr, "waking select with write (blocking?)\n");

    char    b = 1;
    ssize_t nbytes;
    // is this blocking? I guess it has to be...
    nbytes = write(fds[1].fd, &b, 1);       // wake up, jeff!

    if(-1 == nbytes) perror("self-pipe write");
    assert(1 == nbytes);
}

// currently setup to not see the self piper
/*
void
self_piper::inspect(int s)
{   
    // lets wake the demuxer by writing to our end of the pipe
    // lets also not add redundant select wakes for our own selfpipe, as
    // we know it's adding whilst not in select. Is that clear?
    if(s != fds[0].fd) wake();
}
*/

void
selfpipe_wakeup::wakeup(posix_demuxer& demux)
{   
    // fprintf(stderr, "selfpipe wakeup: read the pending byte and re-arm\n");

    // hack! check flag and set demux quit flag
    // flag visible to the wait thread.
    if(request_quit) demux.set_quit_flag(true);
    
    ssize_t         nbytes;
    char            b;
    
    // if this were read then this fn would work with non-sockets
    nbytes = read(s, &b, 1);
    
    if(nbytes == -1) perror("recv");
    
    // fprintf(stderr, "GOT: %li, %x\n", nbytes, b);
    assert(nbytes == 1 && b == 1);
    
    // add self back!
    int res = demux.add_socket_wakeup(this, PDEMUX_READ);
    assert(-1 != res);
}

} }

