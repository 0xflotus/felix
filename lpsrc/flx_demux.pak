@head(1,'demux')
$Log$
Revision 1.37  2006/08/14 05:56:58  skaller
Fix that faio_01 bug: uninitialised name length in call to
getsockname().

Revision 1.36  2006/08/13 06:40:04  idadesub
renamed all felix macros to have FLX_ prepended to them to prevent name
collision with other external libraries

Revision 1.35  2006/08/12 17:24:27  idadesub
renamed all header guards to use the __FLX_filename_H__
the file flx_host_config defined the check FLX_HOST_CONFIG, but defines
FLX_RTL_CONFIG. I renamed them to __FLX_HOST_CONFIG__
one of the files checked if FLX_GC was defined before including flx_gc.h,
but this check is flx_gc.h, so we don't need to guard it twice.

Revision 1.34  2006/08/12 14:41:53  skaller
Revert the ALIAS changes because they didn't work, leaves an
open problem on Solaris with intptr etc.
Rewrite pthread stuff to use a portable interface, using a
wrapper which also catches exceptions which would otherwise
try to escape the thread.

Revision 1.33  2006/08/05 19:59:18  skaller
Remove a couple of fprintf debugs from poll demuxer

Revision 1.32  2006/08/04 07:07:08  skaller
get rid of debugging stuff

Revision 1.31  2006/07/24 18:22:46  skaller
Fix epoll bug which ignored epoll bug in kernels earlier
than 2.6.9 .. epoll_ctl requires a non-NULL event address
even though the argument is not used.

Revision 1.30  2006/07/19 17:57:52  rfistman
wrote self pipe for windows, not happy with it though because it
 has to use a named pipe (anon pipes don't work in nonblock mode).
made demux_quitter portable and now quitting iocp demuxer cleanly
added demux callbacks which are currently used for quitting and making
 demuxers responsive to new sockets.
fixed unbalanced quote in ./bin/flx script

Revision 1.29  2006/07/14 16:00:28  rfistman

generalised demux quit flag into a condition variable that is picked up and
  signalled just before the event thread exits. this was yet another race
  condition in which a quit and destructed demuxer was still in use by
  its event thread.

made get/set quit flag virtual so that "ts" style demuxers (those that
 encapsulate a non ts demuxer) report the quit flag properly.

factored kqueue quit into  async_quit for making sure that waiting thread
 in thread safe demuxers exits before the demuxer destructor completes.
 affects ts_poll_demuxer, ts_select_demuxer, evtport_demuxer
 still to do: same for iocp_demuxer.

Revision 1.28  2006/07/13 18:22:55  idadesub
fixes for freebsd. hopefully this won't break any other builds

Revision 1.27  2006/06/22 06:59:28  rfistman
added poll ts_poll demuxer.

conditionalised demuxer usage, so linux no longer implies epoll,
and solaris no longer implies evtports. this means that older
systems should fall back to select and that we may get the rare
nice surprise of finding a system that supports an unexpected
demuxer (like osx10.4 with poll) or a linux with kqueues. who knows.
ooh, case in point: cygwin supports poll. It spews warnings but
it does work.

Revision 1.26  2006/05/30 18:53:22  rfistman
fixed exception handler linkage on win32
flx_rtl_config now stops Windows.h on VS toolchain including winsock vers 1
disabled HAVE_ISBLANK in tre config file to unbreak win32 build
removed async bootstrapping from pkg_config as it's no longer needed

Revision 1.25  2006/04/30 05:56:29  rfistman
minimal change to test commit emails

Revision 1.24  2006/04/30 02:09:37  rfistman
got rid of suckitnsee kqueue config (too complicated with pthread use)
added a quitter to ts_select_demuxer to fix crash
fixed string exception in demo web server caused by POSTs

Revision 1.23  2006/04/27 00:53:03  rfistman
added demux_quitter to take down kqueue nicely. a simple quitting selfpipe
trick was not enough as the kqueue could exit before the selfpipe's callback
had finished. we now have to two ways to get attention on a (for now posix)
demuxer: selfpiper + demux_quitter. quitter will come in handy for other
demuxer whose quit boundary conditions are a little hazy.

Revision 1.22  2006/04/25 10:38:42  rfistman
added solaris libs (-lrt for semaphores, -lnsl, -lsocket) missing from some
pkgs and added -lnsl -lsocket to flx_pkgconfig bootstrap, added missing
namespace to evtport demuxer

Revision 1.21  2006/04/23 06:09:15  rfistman
fixed bug in async win32 ReadFile/WriteFile code - wasn't handling
ERROR_IO_PENDING properly. Was also not opening files with FILE_FLAG_OVERLAPPED
added actual io to windows named pipe example

Revision 1.20  2006/04/22 07:43:37  rfistman
taking down kqueue event source was blocking on osx 10.4.
fixed now, but not perfect yet. similar problems exist with other sources,
giving undefined behaviour (I believe) on takedown. watch this space.

Revision 1.19  2006/04/20 01:57:17  rfistman
factored out self_piper class. will be used in kqueue_demuxer and an
eventual epoll demuxer.

Revision 1.18  2006/04/08 08:18:34  rfistman
fixed up flx_listener, working on portable regression test for tcp
bug still at large in nocygwin flx_accept - hope it's portable!

Revision 1.17  2006/04/08 03:53:44  skaller
Detect vsnprintf.. some Windows don't provide it even though
MSDN says it is available. The MS variation when available
doesn't work correctly anyhow.

Revision 1.16  2006/03/07 04:22:36  skaller
Termination in presence of spawned pthreads should now
be working, using new ts_locker class. Exception handling
on per thread basis not implemented yet.

Revision 1.15  2006/03/06 15:08:08  skaller
Cygwin and MinGW builds.

Revision 1.14  2006/03/06 13:16:16  skaller
Fix library builds so exports and imports are properly
distinguished on a library by library basis.

Revision 1.13  2006/03/06 01:29:29  skaller
spawn_pthread: init works

Revision 1.12  2006/03/04 09:50:42  rfistman
added "suck it and see" for kqueues.

Revision 1.11  2006/03/04 04:26:41  rfistman
making demux configure more "suck it and see". temporarily disabled kqueues
whilst fixing osx 10.2 build.

Revision 1.10  2006/03/03 04:51:24  rfistman
removed the following line from the kqueues code (was breaking the mac build)
don't know what it means, but there are no threads in the kqueue code.:
using namespace flx::pthread;

Revision 1.9  2006/03/02 17:52:51  skaller
Fix flx_pkgconfig to handle linker switches

Revision 1.8  2006/03/02 02:41:39  skaller
Fixes for Win32/MSVC++ build.

Revision 1.7  2006/03/01 14:52:28  skaller
Cygwin needed one extra lib dependency.

Revision 1.6  2006/02/28 02:07:13  skaller
Refactor demux into demux + pthread.

Revision 1.5  2006/02/26 06:39:36  skaller
Fix flx_pkgconfig to conform to new spec.

Revision 1.4  2006/02/25 20:38:12  skaller
Upgrade flx_pkgconfig

Revision 1.3  2006/02/23 19:33:01  skaller
More fiddling with build system

Revision 1.2  2006/02/22 19:00:04  rfistman
oops, was passing ULONG as ULONG_PTR. Thanks to 64bit compiler for
poinnting this out.

Revision 1.1  2006/02/22 17:36:48  skaller
Rename some files.. more coming. Make RTL modules full .paks

Revision 1.54  2006/02/21 05:46:45  skaller
Fix wrong link flag tag.

Revision 1.53  2006/02/20 09:21:24  skaller
Mingw/nocygwin support

Revision 1.52  2006/02/20 02:16:44  rfistman
removed recursive locks from the threadsafe select demuxer and from
the code in general.

Revision 1.51  2006/02/19 16:04:57  skaller
Win32 build changes..seems to work now

Revision 1.50  2006/02/19 14:02:51  skaller
Windows sys libs with right switches

Revision 1.49  2006/02/18 16:30:48  skaller
More work on new package manager.

Revision 1.48  2006/02/17 09:38:31  skaller

conditionalised recursive mutex (to be removed)
fixed windows lib_requires (added lib prefix)

Revision 1.47  2006/02/16 23:39:11  rfistman
fixed cygwin hang in posix tests. cygwin wakes select with an error flag
when you shutdown a socket. other impls seem to wake select, but with no
error.

Revision 1.46  2006/02/16 15:09:45  skaller
MSVC++ package manager

Revision 1.45  2006/02/16 07:51:40  skaller
Replace pkg-config with a Felix program flx_pkgconfig.
Make sure to build it in a timely manner, since flx script
now depends on it.

Revision 1.44  2006/02/15 10:54:08  skaller
Build time packaging system.

Revision 1.43  2006/02/15 04:10:56  rfistman
working on thread safe select demuxer (ts_select_demuxer). that should
fix cygwin probs. and as yet other undiscovered problems.

Revision 1.42  2006/02/13 05:47:40  rfistman
readded recursive flag to (portable) mutexes

Revision 1.41  2006/02/12 06:51:30  rfistman
added WSAID_CONNECTEX and LPFN_CONNECTEX definitions for ming (nocygwin) target
now conditionally define EAGAIN in posix compat layer because ming seems to
have it.

Revision 1.40  2006/02/11 22:12:30  skaller
Allow assigning constructor index to enums.

Revision 1.39  2006/02/09 21:05:33  skaller
Fixed sdl to use polling.

Revision 1.38  2006/02/09 07:53:27  skaller
Fix windows semaphores.

Revision 1.37  2006/02/07 15:55:06  skaller
Added portable semaphores and a monitor class to demux.

Revision 1.36  2006/02/06 11:05:18  skaller
Timed wait on condition variable.

Revision 1.35  2006/02/06 06:50:01  skaller
Added pthread_cond_timedwait and pthread_cond_uswait functions
to condition variables. The latter is my own invention, it waits
for a specific interval in micro-seconds. The later is more
efficient on Windows when you want to wait for an interval,
since this is the native method. Otherwise you need to first
obtain the time of day, do a nasty calculation .. and then
the timedwait function will undo that, resulting in two
unnecessary and expensive system calls.

Revision 1.34  2006/02/04 11:34:36  skaller
Portable demux stuff, Win32 version

Revision 1.33  2006/02/04 10:35:55  skaller
Portable thread sync stuff

Revision 1.31  2006/02/02 18:52:35  skaller
Reorganise demux a bit

Revision 1.30  2006/01/31 04:29:17  rfistman
added demux level "sleep until" code. Not quite right yet (posix format
of current time in double isn't so good as it's measured from the 70s in
microseconds, so macroscopic sleep amounts get swamped by the magnitude
of "now"), so felix binding coming soon.

Revision 1.29  2006/01/29 07:07:21  skaller
fixed visual studio build after demux merge

Revision 1.28  2006/01/29 05:58:08  rfistman
fixed windows build (ming nocygwin) after merge

Revision 1.27  2006/01/29 02:53:16  rfistman
fixed missing epoll header for linux.:w

Revision 1.26  2006/01/29 02:17:29  rfistman
using latest demux, added epoll to flx_run (for linux). bugs fixed.

Revision 1.25  2006/01/26 10:04:28  rfistman
fixed failure to wake fthread after connects that finish immediately.
this fast connect only ever shows up on solaris, so full marks to them.

Revision 1.24  2006/01/21 23:45:10  rfistman
fixed potential leak and warning in posix_timer_queue constructor

Revision 1.23  2006/01/16 01:25:43  rfistman
factored faio posix accept and connect back demux as control blocks
removed pthread cancel from code - implicit cancel points are no longer used.
instead the threads are convinced to return from their mains via specially
formatted inputs.

Revision 1.22  2006/01/13 05:16:50  rfistman
made worker_fifo portable

Revision 1.21  2006/01/11 01:16:32  rfistman
added win_timer_queue to demux

Revision 1.20  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.


#@h=tangler('tmp/flx_demux_config.hpp')
#@select(h)
#// This is a fake flx_demux_config.h to be used at config time, before
#// the rtl proper exists. It contains just enough info to compile
#// a few of the demuxers.
##define DEMUX_EXTERN

@h=tangler('rtl/flx_demux_config.hpp')
@select(h)
#ifndef __FLX_DEMUX_CONFIG_H__
#define __FLX_DEMUX_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_DEMUX
#define DEMUX_EXTERN FLX_EXPORT
#else
#define DEMUX_EXTERN FLX_IMPORT
#endif
#endif

@h=tangler('demux/demux_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_DEMUXER_H__
#define __FLX_DEMUX_DEMUXER_H__
#include <flx_demux_config.hpp>

namespace flx { namespace demux {

typedef struct {
  char*   buffer;           // set on input
  long    buffer_size;        // set on input
  long    bytes_written;        // set on input and output

  bool    finished() { return bytes_written == buffer_size; }
}sel_param;

// rename ...
// read/write flags - they're no longer mutually exclusive
enum { PDEMUX_READ = 1, PDEMUX_WRITE = 2 };

// base class/hook for implementing thread safe multithreaded demux quit
// not that useful for single threaded implementations.
class DEMUX_EXTERN demux_quit_flag
{
public:
  virtual void signal_true() = 0; // = signal finish
  virtual ~demux_quit_flag() {}
};

// ********************************************************
/// Demux base.
// ********************************************************
class DEMUX_EXTERN demuxer {
protected:
  // wait for outstanding events. may return before given events, so
  // check your conditions. I've turned of all the timeouts that cause
  // this, but don't rely on it!
  // FACTOR. Give poll a greedy interface
  virtual void  get_evts(bool poll) = 0;

  // for clean async takedown. contents guaranteed to be valid until
  // quit_flag->signal_true is called
  demux_quit_flag* quit_flag; 
public:
  demuxer() : quit_flag(0) {}
  virtual ~demuxer() {}

  void wait() { get_evts(false); }
  void poll() { get_evts(true); }

  // ask users of demuxer to exit. not guarded. be sure to either set & get
  // this flag from only one thread (with a wait/wakeup callback - see
  // self_piper) or by using a memory barrier.
  virtual demux_quit_flag* get_quit_flag() { return quit_flag; }
  virtual void set_quit_flag(demux_quit_flag* f) { quit_flag = f; }
};

// base class for callback from demuxer. useful when used in conjuction
// with the self piper for implementing threadsafe demuxer quit and
// guaranteeing responsiveness to new sockets.
// run in the same thread that called d->wait/poll.
class DEMUX_EXTERN demux_callback {
public:
  virtual void callback(demuxer* d) = 0;
  virtual ~demux_callback() {}
};

}} // namespace demux, flx
#endif  /* __DEMUXER__ */

@h=tangler('demux/demux_epoll_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_EPOLL_DEMUXER_H__
#define __FLX_DEMUX_EPOLL_DEMUXER_H__

#include <flx_demux_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {
// epoll allows only one event per socket - it does not differentiate
// on the awaited operation (read/write), however it does let you wait
// on any combination (I think)

// ********************************************************
/// epoll based demuxer
// ********************************************************

class DEMUX_EXTERN epoll_demuxer : public posix_demuxer {
  int   epoll_fd;

  // be careful of this - don't let it create race conditions
  // should probably only be called by wait = in one thread only (check)
  // this removes ALL outstanding events for s.
  void  remove_wakeup(int s);

  virtual void  get_evts(bool poll);
public:
  epoll_demuxer();
  virtual ~epoll_demuxer();
  
  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_evtport_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_EVTPORT_DEMUXER_H__
#define __FLX_DEMUX_EVTPORT_DEMUXER_H__

// driver for solaris 10 event port notifications

#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// Event ports are oneshot by default (I don't know if you can change that).
// Events are tracked only by fd and not fd*event, so you cannot add
// separate wakeups for read and write with the same fd and hope for it to
// work as the later one will overwrite the earlier, fodder for race
// conditions. This impl satisfies 1-1 wakeup to request ratio.

// I don't know if evtports can be waited upon by other evtports

// OBS.
// after removing the threads from the demuxers/event sources
// how are the two half demuxers supposed to work? They used to
// have three threads and now they have one. How can two waits be
// done in one thread? I could add one half_demuxer's evtport to
// the other's and wait on that. Would that work? Otherwise I'll
// have to start a thread, which screws things up a bit. Could do
// that and communicate back to single thread via a waitable queue.
// could have three half-demuxers, add them both to third and call
// their wait functions depending on the outer's wait result.

class DEMUX_EXTERN evtport_demuxer : public posix_demuxer {
    int     evtport;

  // I think evtports only track socket the socket and not
  // socket*operation, so there's only one remove
  void remove_wakeup(int s);

    virtual void  get_evts(bool poll);
public:
  evtport_demuxer();
  virtual ~evtport_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_iocp_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_IOCP_DEMUXER_H__
#define __FLX_DEMUX_IOCP_DEMUXER_H__

#include <flx_demux_config.hpp>
//#include <Windows.h>
// be specific - flx_rtl_config.h now jigs it so that windows.h  does not
// include winsock version 1 headers by default. this was making the order
// of inclusion of windows.h and winsock2.h significant with cl.exe.
#include <WinSock2.h>

#include "demux_demuxer.hpp"
#include "pthread_sleep_queue.hpp"


namespace flx { namespace demux {

// not here? returns INVALID_SOCKET on failure.
// if *io_port == 0, then a port is chosen and returned in *io_port
SOCKET DEMUX_EXTERN create_listener_socket(int* io_port, int backlog);
// these two probably not used. move to wsockety.h
SOCKET DEMUX_EXTERN nice_accept(SOCKET listener);
SOCKET DEMUX_EXTERN nice_connect(const char* addr, int port);
int DEMUX_EXTERN set_tcp_nodelay(int s, int disable_nagle);

// ********************************************************
/// make sure you instantion ONE (1) of these before using winsock
// ********************************************************
class DEMUX_EXTERN winsock_initer
{
public:
  winsock_initer();
  ~winsock_initer();
};

// ********************************************************
/// iocp_wakeup base class for users of iocp_demuxer
/// becoming an overlapped call control block
// ********************************************************
class DEMUX_EXTERN iocp_wakeup {
protected:            // folks need to use these in win 32 calls
  OVERLAPPED  ol;
  // store wakeup error here?
  // I didn't want this to be felixy, useful though.
  void clear_overlapped();  // zero the OVERLAPPED structure
public:
  // 2 possibilities for piggybacking data. who could ask for more?
  // udat = per iocp association, olp = per overlapped function call.
  // why don't I need this in the posix version?
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err) = 0;

  // start overlapped async operation. returns true if it finished
  // immediately. in this case there will be no iocp_finished wakeup.
  // assumes all args ready for call.
  virtual bool start_overlapped() = 0;

  // retrieves this pointer from OVERLAPPED pointer
  static iocp_wakeup* from_overlapped(LPOVERLAPPED olp);
};

// ********************************************************
// ********************************************************
class DEMUX_EXTERN iocp_demuxer : public demuxer {
  HANDLE    iocp;     // the io completion queue

  void get_evts(bool poll);
public:
  iocp_demuxer();
  virtual ~iocp_demuxer();

  // udat is the per IOCP object user cookie & the overlapped pointer
  // is the per overlapped operation cookie (sort of), so in the case
  // of acceptex, udat is set when the listener is associated with the
  // iocp and is passed to the subsequent acceptex iocp wakeups.
  // probably won't be used very often
  // the OVERLAPPED retrieved from the iocp is assumed to be part of
  // an iocp_wakeup - beware! returns 0 on success, -1 on failure.
  int associate_with_iocp(HANDLE obj, ULONG_PTR udat);

};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_kqueue_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_KQUEUE_DEMUXER_H__
#define __FLX_DEMUX_KQUEUE_DEMUXER_H__

#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// ********************************************************
/// kqueue demuxer for osx'n'BSD and at least 1 linux
// ********************************************************
class DEMUX_EXTERN kqueue_demuxer : public posix_demuxer {
  int   kq;
protected:
  // this could just be passed the socket_wakeup, if it stored
  // the flags. Those flags are also set, though, which would
  // create a race condition. In and out flags?

  int add_kqueue_filter(socket_wakeup* sv, short filter);
  int remove_kqueue_filter(int s, short filter);

  int remove_socket_wakeup(int s, int flags);
  void get_evts(bool poll);
public:
  kqueue_demuxer();
  virtual ~kqueue_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_pfileio.hpp')
@select(h)
#ifndef __FLX_DEMUX_PFILEIO_H__
#define __FLX_DEMUX_PFILEIO_H__
#include <flx_demux_config.hpp>

#include "demux_demuxer.hpp"
#include "pthread_sleep_queue.hpp"
#include "pthread_mutex.hpp"
// #include <sys/types.h> // off_t (don't have flx iface to this yet)
              // can just add new constructor
#include "pthread_work_fifo.hpp"
namespace flx { namespace demux {

// ********************************************************
/// like another event source. this is basically a wrapped pread, pwrite
/// should probably be derived from posix_wakeup or something like that.
/// or have the same signature. abstract - users overload "finished
// ********************************************************
class DEMUX_EXTERN fileio_request : public flx::pthread::worker_task
{
  long    offset;   // make this a proper offset (64bit)
  // off_t    offset; // in: offset, for use with pread, pwrite
  int     fd;     // in: fd in question
  bool    read_flag;  // in: read else write

  int     err;    // out:
public:
  // public so it can be got in felix
  sel_param pb;   // in & out: what you want, what you get (64bit len?)

  virtual ~fileio_request(); // c++ should do this automatically
  fileio_request();       // flx linkage
  fileio_request(int f, char* buf, long len, long off, bool rd);

  virtual void doit();      // sync
};

// ********************************************************
// could do separate threads for in & out. or implement some form of cache.
// ********************************************************
class DEMUX_EXTERN pasync_fileio : public flx::pthread::worker_fifo
{
public:
  pasync_fileio(int n,int m) : worker_fifo(n,m) {}
  // compatibility only. don't need this class anymore.
  void add_fileio_request(fileio_request* req) { add_worker_task(req); } 
};

}} // namespace demux, flx
#endif  // __PFILEIO__

@h=tangler('demux/demux_posix_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_POSIX_DEMUXER_H__
#define __FLX_DEMUX_POSIX_DEMUXER_H__

// base classes for posix style demuxers

#include "demux_demuxer.hpp"

namespace flx { namespace demux {
class DEMUX_EXTERN posix_demuxer;            // fwd decl

// abc
class DEMUX_EXTERN posix_wakeup {
public:
  virtual ~posix_wakeup() {}

  // when called, the wakeup has finished and been removed.
  virtual void wakeup(posix_demuxer& demux) = 0;
};

class DEMUX_EXTERN socket_wakeup : public posix_wakeup {
public:
  int   s;                // the non blocking socket
  int   wakeup_flags;         // set on wakeup, r/w or both

  socket_wakeup() : s(-1) {}
};

class DEMUX_EXTERN posix_demuxer : public demuxer {
protected:
  void async_quit(); // useful for requesting wait thread quit in
                     // thread safe demuxer destructors. doesn't throw.

public:
  virtual ~posix_demuxer();

  // posix style sockets. for reading and writing (but not both at once
  // for the same socket_wakeup) you are guaranteed to receive only one
  // wakeup per call to this function when you call wait.
  // returns -1 if no wakeup is coming and zero if one is.
  // For simultaneous reading and writing you may get two wakeups,
  // that is, it may violate the "one shot" rule. Ignoring for now,
  // as it's not a common use. This makes it undefined behaviour.
  // wakeup is owned by the demuxer until its wakeup is called,
  // so treat it with kid gloves, i.e. don't mess with it.
  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags) = 0;

  // to be called when we can read & write without blocking
  // return true if connection closed, update pb
  // sort of a strange place to have this..., more a socket wakeup
  // thing, even if static
  static bool   socket_recv(int s, sel_param* pb);
  static bool   socket_send(int s, sel_param* pb);
};

// some handy control blocks for common non-blocking socket operations
// note that they "fortuitously" both have start methods. hmm.
// a socket io one could be handy here.

// this one's restartable (makes sense for listener sockets)
class DEMUX_EXTERN accept_control_block : public socket_wakeup {
public:
  int   accepted;   // accepted socket (out)
  int   socket_err;   // the error, if acceptee == -1, else 0 (out)
  
  accept_control_block() : accepted(-1), socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);
};

class DEMUX_EXTERN connect_control_block : public socket_wakeup {
public:
  int     socket_err;   // outgoing error (on start or wake)
  // this should probably be a sockaddr type
  const char* addy;     // addr (dotted quad) (in)
  int     p;        // port (in)
  
  connect_control_block() : socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);

  // oops, can't check for s != -1 as it's always there.
  // was always "finished" and so I started io, losing the first wakeup
  // on epoll evtsrc. Is this right, or should it be != EINPROGRESS?
  // keep in sync with iocp version. give socket_err initial definition
  // that works with this?
  bool finished() { return ( 0 == socket_err); }
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_select_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_SELECT_DEMUXER_H__
#define __FLX_DEMUX_SELECT_DEMUXER_H__

#include "demux_posix_demuxer.hpp"
#include <sys/types.h>    // for sys/select.h on osx
#include <sys/select.h>   // for fd_set
#include <sys/time.h>     // GUSI WTF?
#include <unistd.h>       // for bsd

// Unlike the other demuxers, this one is NOT thread safe, so wait and
// add socket wakeup must only be called from the same thread.
// if you're looking for the thread safe version, try ts_select_demuxer

namespace flx { namespace demux {

class DEMUX_EXTERN select_demuxer : public posix_demuxer {
  void  remove_fd(int s);
  
  // thanks Beej!
  fd_set      master_read_set;    // fd watched for reading
  fd_set      master_write_set;   // for writing
  fd_set      master_except_set;    // for exceptions

  // read sveglias - note we only have one set, so currently this demuxer
  // cannot have separate wakeups for the same file descriptor. this
  // fits in fine with the "undefined" nature of doing that.
  socket_wakeup*  svs[FD_SETSIZE];    // read sveglias
  //socket_wakeup*  write_svs[FD_SETSIZE];  // write wakeups

  int       fdmax;          // high watermark for select

protected:
  virtual void  get_evts(bool poll);

public:
  // get_evts broken into pieces for thread safe implementations
  void copy_sets(fd_set& rset, fd_set& wset, fd_set& exset);
  // returns true if process_sets should be called.
  bool select(fd_set& rset, fd_set& wset, fd_set& exset, bool poll);
  // these could be consts
  void process_sets(fd_set& rset, fd_set& wset, fd_set& exset);

  select_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};
}} // namespace demux, flx
#endif

@h=tangler('demux/demux_ts_select_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_TS_SELECT_DEMUXER_H__
#define __FLX_DEMUX_TS_SELECT_DEMUXER_H__

#include "demux_select_demuxer.hpp"
#include "demux_self_piper.hpp"
#include "pthread_mutex.hpp"

namespace flx { namespace demux {

// thread safe version of select demuxer

class DEMUX_EXTERN ts_select_demuxer : public posix_demuxer {
  // lock
  flx::pthread::flx_mutex_t      ham_fist;   
  // protects this little fella here.
  select_demuxer  demux;

  // self pipe trick for waking waiting thread when we like.
  // for demuxer responsiveness.
  self_piper sp;
protected:
  virtual void    get_evts(bool poll);
public:
  ts_select_demuxer();
  ~ts_select_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);

  // oops! need to correctly get/set the quit flag
  virtual demux_quit_flag* get_quit_flag() { return demux.get_quit_flag(); }
  virtual void set_quit_flag(demux_quit_flag* f) { demux.set_quit_flag(f); }
};
}} // namespace demux, flx

#endif
@h=tangler('demux/demux_timer_queue.hpp')
@select(h)
#ifndef __FLX_DEMUX_TIMER_QUEUE_H__
#define __FLX_DEMUX_TIMER_QUEUE_H__

#include <flx_demux_config.hpp>

namespace flx { namespace demux {

// trying to factor out code to share between pc & posix versions

// class sleep_task : public worker_task
// may not need time in here - just the wakeup - something I surely have
// somewhere else.
class DEMUX_EXTERN sleep_task
{
public:
    virtual ~sleep_task() {}

    virtual void fire() = 0;
};

class DEMUX_EXTERN timer_queue
{
public:
    virtual ~timer_queue() {}    

    virtual void add_sleep_request(sleep_task* st, double delta) = 0;
    virtual void add_abs_sleep_request(sleep_task* st, double when) = 0;

    // bad design - this is actually implemented in the descendent classes,
    // which limits the number of such classes probably to one.
    static void get_time(double& t);        // in seconds from some ref pt
};

}} // namespace demux, flx

#endif

@h=tangler('demux/demux_posix_timer_queue.hpp')
@select(h)
#ifndef __FLX_DEMUX_POSIX_TIMER_QUEUE_H__
#define __FLX_DEMUX_POSIX_TIMER_QUEUE_H__

#include "pthread_thread.hpp"  // flx_thread_t
#include "pthread_mutex.hpp"  // flx_mutex_t
#include "pthread_condv.hpp"  // flx_condv_t
#include "demux_timer_queue.hpp" // base class
#include <sys/time.h>        // timespecs, gettimeofday

namespace flx { namespace demux {

// looks like a worker queue, but couldn't quite mash it into one
class DEMUX_EXTERN posix_timer_queue : public timer_queue
{
    flx::pthread::flx_mutex_t lock; // factor to prio queue?
    flx::pthread::flx_condv_t sleep_cond;
    flx::pthread::flx_thread_t sleep_thread;
    void*        opaque_prio_queue;        // less fat

    static void thread_start(void*);    // passed "this"
    bool thread_loop_body();


    void wakeup_thread();                // we can do this!

    void add_sleep_request(sleep_task* st, timespec* abs);
public:
    posix_timer_queue();
    ~posix_timer_queue();

    // thread safe.
    virtual void add_sleep_request(sleep_task* st, double delta);

    // in seconds, relative to same base as timer::get_time.
    virtual void add_abs_sleep_request(sleep_task* st, double when);
};

}}

#endif // __POSIX_TIMER_QUEUE__

@h=tangler('demux/demux_posix_timer_queue.cpp')
@select(h)
#include "demux_posix_timer_queue.hpp"

// a prio queue that executes tasks in a given order
// factor out prio_queue? could be like queue.

// try to make work like the worker thread thing, fix it do so?.
// remove time from sleep task...

#include <queue>    // stl seems to have a prio_queue
#include <sys/time.h> // gettimeofday for calculating "now"

//using namespace flx::pthread;
namespace flx { namespace demux {

#define MIL 1000000        // one million
#define BIL (MIL*1000)    // one billion (metric)

using namespace std;

// it could happen!
// factor
class future_evt
{
public:
    timespec    when;    
    sleep_task*    task;

    // ignore the direction, just trying to sort with smallest first
    bool operator<(const future_evt& rhs) const
    {
        if(when.tv_sec != rhs.when.tv_sec)    // precedence to more significant
            return when.tv_sec > rhs.when.tv_sec;
        else                                // else check the less significant
            return when.tv_nsec > rhs.when.tv_nsec;
    }
};

typedef priority_queue<future_evt> void_prio_queue;
#define PRIOQ ((void_prio_queue*)opaque_prio_queue)

posix_timer_queue::posix_timer_queue()
{
    opaque_prio_queue = new void_prio_queue;    // a.k.a. PRIOQ
    //fprintf(stderr,"initing timer sleep thread\n");
    
    // NEED'S TO CHECK RETURN VAL AND HANDLE ERROR
    if(sleep_thread.init(thread_start, this))
      fprintf(stderr, "failed to create posix timer queue thread!\n");
}

posix_timer_queue::~posix_timer_queue()
{
    // the sleep_thread uses the prioq, so we must explicitly shut it
    // down now, before we delete the prioq. left to its own devices,
    // c++ destructs it at the end of this destructor.

    // take down the thread first because it uses all the other stuff.
    // I actually don't need to do anything special to bring the thread
    // down because all pthread_cond_*wait* are cancel aware. Or so they
    // should be. As far as I can tell only the 64bit osx10.4.2 is, so
    // for now the explicit cancel + wakeup followed by explicit 
    // cancel test stays.

    // fprintf(stderr, "asking timer thread to quit\n");
    add_sleep_request(NULL, 0.0);    // super secret quit thread quit request
    wakeup_thread();                // wakeup, cause to goto a cancel pt

    sleep_thread.join();            // will join
    //fprintf(stderr,"about to delete PRIOQ\n");
    delete PRIOQ;
}

static void
get_now(timespec* now)
{
    struct timeval tp;

    if(gettimeofday(&tp, NULL) == -1)
        perror("gettimeofday");

    // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
    now->tv_sec = tp.tv_sec;
    now->tv_nsec = tp.tv_usec*1000;        // fits!

    // fprintf(stderr,"get_now = %li, %li\n", now->tv_sec, now->tv_nsec);
}

// LIMIT!
// seconds to microseconds - signed this gives a bit over half an hour
#define SEC2TIMESPEC(ts, t) long    wait_musec = (long)(t*MIL);    \
    timespec    ts = { wait_musec / MIL, (wait_musec % MIL)*1000 }


// offset delta from "now" and store in "when"
static void
calc_when(timespec* when, double delta)
{
// how to use the posix abstime versions of timed waits? what kind of absolute
// is abstime? pthread_get_expiration_np looks useful, but it too is np.
// abstime is apparently in seconds since the Epoch, UTC.
// To get now there's clock_gettime (not portable) or gettimeofday with
// null timezone.

    timespec    now;
    get_now(&now);

    // limit!
    // seconds to microseconds - signed this gives a bit over half an hour
    // long    wait_musec = (long)(delta*MIL);
    // timespec    delay = { wait_musec / MIL, (wait_musec % MIL)*1000 };
    SEC2TIMESPEC(delay, delta);
    
    // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
    when->tv_sec = now.tv_sec + delay.tv_sec;
    when->tv_nsec = now.tv_nsec + delay.tv_nsec;

    if(when->tv_nsec >= BIL)            // overflow of nanoseconds?
    {
        // fprintf(stderr,"OVERFLOW = %li, %li\n", when->tv_sec, when->tv_nsec);
        // x, y < BIL, x + y < 2BIL
        when->tv_sec++;
        when->tv_nsec -= BIL;
        // when->tv_sec += when->tv_nsec/BIL;
        // when->tv_nsec %= BIL;
    }

    // fprintf(stderr,"when = %li, %li\n", when->tv_sec, when->tv_nsec);
    // tp contains tv_sec (seconds) & tv_usec (microseconds) both longs.
    // however, if nonposix works everywhere...
}

// absolute time
void
posix_timer_queue::add_sleep_request(sleep_task* st, timespec* abs)
{
    future_evt    evt;
    evt.task = st;
    evt.when = *abs;

    flx::pthread::flx_mutex_locker_t    locker(lock);

    PRIOQ->push(evt);

    // we may have inserted at sooner than any other evt, so wake up thread
    // to figure it out (if need be). I seemed to be getting more wakeups
    // with this. Turned off for now. Not sure how that works.
    if(1 || PRIOQ->top().task == st)
    {
      // fprintf(stderr,"WE PUSHED IN - waking thread\n");
      wakeup_thread();
    }
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
posix_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
    // fprintf(stderr,"add_sleep_request: %lf\n", delta);
    timespec    when;
    calc_when(&when, delta);        // calculate when (t a delta)

    add_sleep_request(st, &when);
}

void
posix_timer_queue::add_abs_sleep_request(sleep_task* st, double when)
{
    // absolute version is closer to the posix implementation
    SEC2TIMESPEC(abs_time, when);
    add_sleep_request(st, &abs_time);
}

// cause the timer wait thread to wake up. useful for asking it to
// exit or re-evaluate a changed sleep queue.
void
posix_timer_queue::wakeup_thread()
{
    sleep_cond.signal();
}

void
posix_timer_queue::thread_start(void* udat)
{
    posix_timer_queue*    q = (posix_timer_queue*)udat;
    //fprintf(stderr,"sleeper thread\n");

    while(q->thread_loop_body()) ;
}

bool
posix_timer_queue::thread_loop_body()
{
    // lock on. lock off when waiting on condition
    flx::pthread::flx_mutex_locker_t    locker(lock);

    int        res;

    // pthread_cond_wait & pthread_cond_timedwait (& np rel version?) are
    // cancellation points. doco notes for timed & untimed waits that the
    // predicate should be rechecked as there can be spurious wakeups.
    // no worries, when we wakeup the lock has been acquired.

    while(!PRIOQ->empty())
    {
        future_evt    evt = PRIOQ->top();

        // quit request
        if(!evt.task) return false;

        future_evt  now;        // "now' has no task, just a dummy.
        get_now(&now.when);

        // if(evt < now)        // would prefer <=, eh.
        // < is arse backwards because I don't know how to use the stl
        if(now < evt)        // would prefer <=, eh.
        {
            // fprintf(stderr,"firing of (%li, %li) at (%li, %li)!\n",
            //    evt.when.tv_sec, evt.when.tv_nsec,
            //    now.when.tv_sec, now.when.tv_nsec);
            evt.task->fire();
            PRIOQ->pop();
        }
        else    // we have an event in future, so sleep for that long
        {
            // remember that condition waits are exit points...
            // so I don't need to test - check that.
            // fprintf(stderr,"sleeping from %li, %li until %li, %li\n",
            //    now.when.tv_sec, now.when.tv_nsec,
            //    evt.when.tv_sec, evt.when.tv_nsec);
            (void)sleep_cond.timedwait(&lock, &evt.when);

            // if using posix abstime timed wait we make get EINVAL here for 
            // abstimes in the past. must handle this.
            //JS: It's handled now, waiting for a time in the past is OK
 
            // fprintf(stderr,"pthread_cond_timedwait woke up! (%i)\n", res);
        }
    }

    // if we got here then the queue is empty, so sleep indefinitely
    // that we don't really need the mainloop testcancel because the condition
    // wait functions are cancellation points.
    // fprintf(stderr,"no sleep task, sleeping indefinitely\n");
    sleep_cond.wait(&lock);
    // fprintf(stderr,"pthread_cond_wait woke up! (%i)\n", res);

    // lock released here
    return true;                    // keep going
}


// in seconds from some ref pt
// N.B. declared in base class!
void
timer_queue::get_time(double& t)
{
    timespec    now;
    get_now(&now);        // just calls gettimeofday (msec) and converts
                        // to timespec (sec, nsec). could skip that
                        // and call directly, avoiding conversion
    t = now.tv_sec + (now.tv_nsec*BIL);
}  

}}

@h=tangler('demux/demux_win_timer_queue.hpp')
@select(h)
#ifndef __FLX_DEMUX_WIN_TIMER_QUEUE_H__
#define __FLX_DEMUX_WIN_TIMER_QUEUE_H__

#include "flx_demux_config.hpp"
#include <Windows.h>

#include "demux_timer_queue.hpp"

namespace flx { namespace demux {

class DEMUX_EXTERN win_timer_queue : public timer_queue
{
  HANDLE    timer_queue;

  static VOID CALLBACK timer_callback(PVOID, BOOLEAN);
public:
  win_timer_queue();
  ~win_timer_queue();

  virtual void add_sleep_request(sleep_task* st, double delta);
  virtual void add_abs_sleep_request(sleep_task* st, double when);

};

}}

#endif // __SLEEP_TASK__

@h=tangler('demux/demux_win_timer_queue.cpp')
@select(h)
#include "flx_demux_config.hpp"
#include <Windows.h>
#include <assert.h>

// simply wrapped windows timer queue. requires windows 5.00, which is 
// quite high (xp?) because I couldn't get the waitable timers to work.
// must be careful with this stuff lest it create millions of threads.
#include "demux_win_timer_queue.hpp"

#include <stdio.h>

namespace flx { namespace demux {

#define MIL 1000000    // 1 metric million

typedef struct
{
  sleep_task*  st;        // so we can make it fire
  HANDLE    timer;      // we need to delete the timer, so we keep it
  HANDLE    timer_queue;  // AND its queue (no back ptrs, I guess)
} timer_cookie;

win_timer_queue::win_timer_queue()
{
  // fprintf(stderr,"win_timer_queue ctor\n");

  timer_queue = CreateTimerQueue();
  if(!timer_queue)
  {
    fprintf(stderr, "CreateTimerQueue failed: %i\n", GetLastError());
    throw -1;
  }
  // fprintf(stderr, "created timer queue: %p\n", timer_queue);
}


win_timer_queue::~win_timer_queue()
{
  // INVALID_HANDLE_VALUE indicates that DeleteTimerQueueEx should wait for
  // all callback functions to complete before returning. One would hope that
  // calling this causes all the timers to go off before their time (what
  // else would the "actually fired" callback flag be for?). The alternative
  // of waiting for some ever distant timer to go off would be too stupid
  // for words. As usual, the msdn glosses over the important details like
  // this one. Anyway, it's easy to test out... No, that flag's always true
  // for timers, and this wait option doesn't work - maybe with other types
  // flags for CreateTimerQueueTimer?
  if(!DeleteTimerQueueEx(timer_queue, INVALID_HANDLE_VALUE))
  {
    fprintf(stderr, "DeleteTimerQueueEx failed: %i\n", GetLastError());
    // whatcha gonna do about it?
  }
  // fprintf(stderr, "finished - did it wait?\n");
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
win_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
  // fprintf(stderr,"add_sleep_request: %lf to %p\n", delta, timer_queue);

  timer_cookie*  tc = new timer_cookie;

  // copy in the sleep_task and the timer queue
  tc->st = st;
  tc->timer_queue = timer_queue;

  // the timer thread may not be the best solution as nothing is stopping
  // anyone from performing long operations with this structure, however
  // in all likelihood, it'll just be felix adding threads back to its queue.
  if(!CreateTimerQueueTimer(
    &tc->timer,          // resulting timer in timer_cookie
    timer_queue,
    //NULL,            // add to default timer queue
    timer_callback,        // should get called in delta seconds
    tc,             // timer cookie is user data
    (DWORD)(delta*1000),    // millisecond timer
    0,              // zero period => signal once
    WT_EXECUTEINTIMERTHREAD))  // NB: for short tasks (will this do?)
  {
    fprintf(stderr, "CreateTimerQueueTimer failed: %i\n", GetLastError());
    delete tc;          // at least try not to leak
    return;
  }
}

// this is a c callback - all the c++ code should probably be wrapped
// in a try/catch. timer_or_wait_fired is always true for timers.
VOID CALLBACK
win_timer_queue::timer_callback(PVOID udat, BOOLEAN timer_or_wait_fired)
{
  timer_cookie*  tc = (timer_cookie*)udat;
  
  // fprintf(stderr, "timer queue callback fired: %p, %i\n",
  //  tc, timer_or_wait_fired);

  if(!tc)
  {
    // Nothing that we can do in this situation.
    fprintf(stderr, "WHOA - NULL queue cookie! (fired: %i)\n",
      timer_or_wait_fired);
    return;            // outta here
  }

  // NULL means delete the thing now, INVALID_HANDLE_VALUE means wait until
  // callback finishes. We're in the callback, so we can't do that (=deadlock
  // of the timer thread, which isn't good). We're all adults here, the timer
  // has expired, we know what we're doing, so lets just delete it.
  tc->st->fire();

  // on my box this returns ERROR_IO_PENDING, on others it doesn't
  // msdn says this should be ok, but I'm not so sure.
  if(!DeleteTimerQueueTimer(tc->timer_queue, tc->timer, NULL))
  {
    int  err = GetLastError();

    if( ERROR_IO_PENDING != err)
    {
      fprintf(stderr, "DeleteTimerQueueTimer of %p failed: %i\n",
        tc->timer, err);
    }
    else
    {
      // I'm not so sure, see if it leaks.
      fprintf(stderr, "DeleteTimerQueueTimer = ERROR_IO_PENDING\n");
      fprintf(stderr, "Apparently this is ok...\n");
    }
  }
  delete tc;

  // fprintf(stderr, "leaving timer callback\n");
}

// in seconds from some ref pt (UTC for this fn)
// N.B. declared in base class!
void
timer_queue::get_time(double& t)
{
  SYSTEMTIME  sysnow;
  GetSystemTime(&sysnow);
  // now convert to seconds
  // via FILETIME?

  // kinda sucks, but is the msdn recommended way of doing calculations
  // on dates.
  FILETIME  fnow;
  if(!SystemTimeToFileTime(&sysnow, &fnow))
  {
    fprintf(stderr, "SystemTimeToFileTime failed: %i\n", GetLastError());
    t = 0;
    return;
  }

  ULARGE_INTEGER now;  // so we can do some maths

  assert(sizeof(now) == sizeof(fnow));
  memcpy(&now, &fnow, sizeof(now));

  // and now we have a big integer containing an offset jan 1, 1601 (UTC)
  // 100 nanosecond intervals
  t = now.QuadPart*MIL*10;  // *10 to microseconds, *MIL to seconds
}

void
win_timer_queue::add_abs_sleep_request(sleep_task* st, double when)
{
  // win timer queue works with relative offsets, so convert this absolute
  double  now;
  get_time(now);
  double  delta = when-now;
  if(delta < 0.0) delta = 0.0;
  add_sleep_request(st, delta);
}

}}
@h=tangler('demux/demux_demuxer.cpp')
@select(h)
#include "demux_demuxer.hpp"

// nothing here atm ..

@h=tangler('demux/demux_epoll_demuxer.cpp')
@select(h)
// epoll interface. does epoll support ordinary files in addition to sockets?
// EPOLLET to make epoll edgetriggered. I guess the default is level triggered.

// epoll events are not one shot, in fact they're quite sticky so socket
// filters must be removed manually to guarantee a one-to-one wakeup
// to add_wakeup ratio. note that the oneshot flag is not a solution.

// cool! EPOLLONESHOT
// BUGGER! doesn't seem to exist! and doing this doesn't make it so!
// #ifndef EPOLLONESHOT
// #define EPOLLONESHOT (1<<30)
// #endif

#include "demux_epoll_demuxer.hpp"

#include <sys/epoll.h>  // for epoll_*
#include <stdio.h>    // for perror
#include <unistd.h>   // for close
#include <errno.h>    // EEXIST, errno

namespace flx { namespace demux {

epoll_demuxer::epoll_demuxer()
  : epoll_fd(-1)
{
  // EPOLLONESHOT is shit, don't use it. Enabling it just means that your
  // wakeups are suppressed and you have to use EPOLL_CTL_MOD instead
  // of EPOLL_CTL_ADD. If it isn't defined then so much the better.
//#ifdef EPOLLONESHOT
//  fprintf(stderr,"WARNING: EPOLLONESHOT AVAILABLE (%x)!!!\n", EPOLLONESHOT);
//#endif

  // god knows what the maximum size will be, I'll just say 1 for now
  epoll_fd = epoll_create(1);
  if(-1 == epoll_fd)
  {
    perror("epoll_create");
    throw -1;
  }
}

epoll_demuxer::~epoll_demuxer()
{
  async_quit(); // get waiting thread to exit. 

  if(-1 != epoll_fd)
  {
    if(close(epoll_fd) != 0)
      perror("epoll close");
  }
}

int
epoll_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  int s = sv->s;

  struct epoll_event  evt;
  // fprintf(stderr,"add_socket_wakeup: %i (sv=%p, flags=%x)\n",
  //  s, sv, flags);

  // EPOLLONESHOT saves us not only a system call to remove epoll evts,
  // which aren't intrinsically one-shot, but having to do it ourselves
  // would have been a pain as epoll doesn't tell you which fd had the event
  // this way we can get away with not knowing & not losing our user cookie
  evt.events = 0;
  
  if(flags & PDEMUX_READ) evt.events |= EPOLLIN;
  if(flags & PDEMUX_WRITE) evt.events |= EPOLLOUT;

  // fprintf(stderr, "flags %x -> evt.events %x\n", flags, evt.events);

  // We do the remove manually because oneshot in epoll doesn't
  // remove the socket, but rather, disables it.
//#ifdef EPOLLONESHOT
//  evt.events |= EPOLLONESHOT;         // yes!
//#endif
  // I think EPOLLHUP comes when the connection closes (on read?)
// poll's (plain old poll) equivalents to this are ignored for input
// same here?
  // I get EPOLLHUPs for bad async connects whether I ask for them or not.
  evt.events |= (EPOLLHUP | EPOLLERR);    // I think I want this

  evt.data.ptr = sv;              // our user data

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, s, &evt) == -1)
  {
    // EPOLL_CTL_MOD cannot help us do bidirection io on one socket,
    // the mod will overwrite the old user cookie and direction. 
    // It seems that only kqueues, select and iocps allow that.
    // Will need a wakeup that can do both, oneshot that indicates
    // the available direction.
// when using oneshot, we're supposed to use EPOLL_CTL_MOD
#if 0
    int err = errno;

    if(EEXIST == err)
    {
      // ok - let's try EPOLL_CTL_MOD
      fprintf(stderr, "RETRYING WITH EPOLL_CTL_MOD\n");
      if(epoll_ctl(epoll_fd, EPOLL_CTL_MOD, s, &evt) != -1)
        return 0; // good!
    }
#endif
    perror("epoll_ctl (add)");
    
    return -1;
  }
  return 0;
}

// epoll doesn't differentiate on events. I bet I could
// just not pass that event...
void
epoll_demuxer::remove_wakeup(int s)
{
  // EPOLL_CTL_DEL uses no information from the event
  // and so I should be able to pass NULL.
  struct epoll_event evt;
  // evt.events = (read) ? EPOLLIN : EPOLLOUT;

  // fprintf(stderr,"removing socket wakeup %i\n", s);

  if(epoll_ctl(epoll_fd, EPOLL_CTL_DEL, s, &evt) == -1)
  {
    //const char* str = (read) ? "epoll_ctl (remove read)"
    //  : "epoll_ctl (remove write)";
    // perror(str);
    perror("epoll_ctl (remove)");
  }
}

void
epoll_demuxer::get_evts(bool poll)
{
  struct epoll_event  evt;

  switch(epoll_wait(epoll_fd, &evt, 1, (poll) ? 0 : ~0))
  {
    case -1:    // error
    perror("epoll_wait");
      // fall through
    case 0:     // no events (happens with timeout)
      return;
  }

  socket_wakeup* sv = (socket_wakeup*)evt.data.ptr;
  
  // not seeing timeouts as they're filtered by the switching.
  // assuming that sv is good
  // fprintf(stderr,"wakeup (sv=%p, sv->s=%i evt.events=%x)!\n",
  //  sv, sv->s, evt.events);

  // accumulate bit field of what we got
  sv->wakeup_flags = 0;

  bool  wake = false;
  
  // it might be possible to get both a read & write event...
  // in which case I should take out the else below
  if(evt.events & EPOLLIN)                // I think this is how you do it
  {
    // fprintf(stderr,"EPOLLIN for %p\n", sv);
    sv->wakeup_flags |= PDEMUX_READ;
    wake = true;
  }

  if(evt.events & EPOLLOUT)
  {
    //fprintf(stderr,"EPOLLOUT for %p\n", sv);
    sv->wakeup_flags |= PDEMUX_WRITE;
    wake = true;
  }

  // Is this for shutdown or closing of the other end?
  // I get it for failed async connects. I don't know if other events cause
  // it. In any case, I don't know whether it should be for read or write,
  // so I just don't say. In any case, it should wake to get error.
  // I seem to get both EPOLLHUP and EPOLLERROR on bad async connect
  // see poll demuxer notes on POLLHUP for further possibly useful info.
  if(evt.events & EPOLLHUP)
  {
    fprintf(stderr, "EPOLLHUP for %p->%i\n", sv, sv->s);
    wake = true;
  }

  if(evt.events & EPOLLERR)
  {
// How do I retrieve the error?
    // There's no ambiguity - there's only ever one fd in a given epoll.
    // If oneshot's present then don't need to do anything
// not sure what to do here. if we've enabled/got oneshot the socket
// should already have been removed
    fprintf(stderr,"epoll error, waking: %i (errno?)\n", sv->s);
    // similar story to EPOLLHUP
    wake = true;
  }

    if((evt.events & ~(EPOLLERR|EPOLLIN|EPOLLOUT|EPOLLHUP)))
    {
        fprintf(stderr,"unknown events in epoll_demuxer %x\n", evt.events);
    }

  // we got something. tell the people.
  // not dependent solely on wakeup_flags - errors need to wake too.
  if(wake)
  {
    // we got something. better call wakeup, must remove to guarantee
    // 1-1 wakeups with add_sockets
    // fprintf(stderr, "no one-shot... remove %i\n", sv->s);
    remove_wakeup(sv->s);
    // fprintf(stderr, "calling wakeup (flags=%x)\n", sv->wakeup_flags);
    sv->wakeup(*this);
  }
}
}}

@h=tangler('demux/demux_evtport_demuxer.cpp')
@select(h)
// Evtports can get timer wakeups with PORT_SOURCE_TIMER.
// Can also pick up aio notifications with PORT_SOURCE_AIO.

// looks like this stuff is only in solaris10, and not SunOS 5.8. Damn.

#include "demux_evtport_demuxer.hpp"

#include <port.h>
#include <poll.h> // POLLIN/POLLOUT
#include <stdio.h>  // printf
#include <unistd.h> // close
#include <assert.h>

namespace flx { namespace demux {

// header files for this stuff?
// can use port_send for user defined events, to wake up reap loop
// truss to see what's happening

evtport_demuxer::evtport_demuxer()
{
  if((evtport = port_create()) < 0)
  {
    perror("port_create");
    throw -1;
  }
}

evtport_demuxer::~evtport_demuxer()
{
  async_quit(); // gets waiting thread to quit, returning afterwards

  if(-1 != evtport)
  {
    if(close(evtport) != 0)
      perror("evtport close");
  }
}

int
evtport_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  if(flags & ~(PDEMUX_READ|PDEMUX_WRITE)) // I can't understand you, lady!
    return -1;

  int events = 0; // events are flags so we can accumulate them
  int s = sv->s;

  if(flags & PDEMUX_READ) events |= POLLIN;
  if(flags & PDEMUX_WRITE) events |= POLLOUT;

  // POLLHUP might make sense only for reads... add conditionally?
  events |= (POLLHUP | POLLERR);

  // fprintf(stderr,"add_socket_wakeup: %i, sv: %p (%x)\n", s, sv, flags);

  // register for event we are interested in...
  // works for files, sockets, timers...
  // sockets are file descriptors in unix, so src is PORT_SOURCE_FD
  if(port_associate(evtport, PORT_SOURCE_FD, (uintptr_t)s, events, sv) == -1)
  {
    perror("add socket_wakeup/port_associate");
    return -1;
  }

  return 0;
}

// note that these two functions are exactly the same
// we have to remove after a read or write else we can get multiple
// wakeups - usually with a dud user cookie. the fact that there is
// no differentiation between POLLIN & POLLOUT could be a problem for
// mixed read/write things (rare). note that evt_ports let me associate
// the samething twice. I don't know if this means you have to dissociate
// (disassociate) twice.
void
evtport_demuxer::remove_wakeup(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("reading port_dissociate");
}

#define POLLPR(ev) if(e->portev_events & ev) fprintf(stderr,#ev", ")

static void
print_port_evt(port_event_t* e)
{
  char* srcstr[PORT_SOURCE_ALERT-PORT_SOURCE_AIO+1]
    = { "ALERT", "TIMER", "USER", "FD", "AIO"};
  fprintf(stderr,"e: %p\n\t", e);
  //fprintf(stderr,"portev_events: %x\n\t", e->portev_events);
  fprintf(stderr,"portev_events: ");

  // I got these constants from the poll.h file
  POLLPR(POLLIN); POLLPR(POLLOUT); POLLPR(POLLPRI);
  POLLPR(POLLRDNORM); POLLPR(POLLRDBAND); POLLPR(POLLWRBAND);

  // in poll these are in a different field. port_event_t doesn't
  // have that field, so lets try here.
  POLLPR(POLLERR); POLLPR(POLLHUP); POLLPR(POLLNVAL); POLLPR(POLLREMOVE);

  fprintf(stderr," (%x)\n\t", e->portev_events);
  
  int src = e->portev_source;
  if(PORT_SOURCE_AIO <= src && src <= PORT_SOURCE_ALERT)
  {
    fprintf(stderr,"portev_source: PORT_SOURCE_%s (%x)\n\t",
      srcstr[src-PORT_SOURCE_AIO], src);
  }
  else
  {
    fprintf(stderr,"portev_source: %x\n\t", e->portev_source);
  }

  fprintf(stderr,"portev_pad: %x\n\t", e->portev_pad);
  // often our socket
  fprintf(stderr,"portev_object: %x\n\t", e->portev_object);
  fprintf(stderr,"portev_user: %p\n", e->portev_user);
}

void
evtport_demuxer::get_evts(bool poll)
{
  // Block until a single event appears on the port. Event will not fire
  // again, so we get max 1 wakeup per event added.

  port_event_t  evt;
  timespec    timeout, *tp = NULL;

  if(poll)    // effect a poll
  {
    timeout.tv_sec = 0;
    timeout.tv_nsec = 0;
    tp = &timeout;
  }

  // wait for single event, no timeout
  if(port_get(evtport, &evt, tp) == -1)
  {
    perror("port_get");
    return;
  }

  // fprintf(stderr,"PORT_GET RETURNED: "); print_port_evt(&evt);

  // get wakeup obj tucked away in the user cookie.
  socket_wakeup*  sv = (socket_wakeup*)evt.portev_user;
  int       s = evt.portev_object;

  assert(sv != NULL);
  if(evt.portev_source != PORT_SOURCE_FD)
  {
    // when polling I often end up in here - we get an unknown evt
    // source and a POLLNVAL event plus lots of other unknown flags.
    // there's interesting looking stuff in the user field and so on,
    // but it's nothing of mine and also undocumented
    // fprintf(stderr,"got non PORT_SOURCE_FD (s=%i, sv=%p, src=%i)\n",
    //  s, sv, evt.portev_source);
    // fprintf(stderr, "skipping out...\n");
    return;
  }


  // let's see what we've got for the wakeup
  sv->wakeup_flags = 0;

  if(evt.portev_events & POLLERR)
  {
    fprintf(stderr,"ERRORS on s = %i, sv = %p\n", s, sv); 
    //evt.portev_events &= ~POLLERR;
    //return;
  }

  // for bidirectional wakeups, we should be able to get both
  // POLLIN and POLLOUT at the same time, but I've not yet
  // seen it happen, they're coming in one at a time for me.


  if(evt.portev_events & POLLIN)
  {
    // fprintf(stderr,"GOT POLLIN FOR %p\n", sv);
    sv->wakeup_flags |= PDEMUX_READ;
  }

  if(evt.portev_events & POLLOUT)
  {
    // fprintf(stderr,"GOT POLLOUT FOR %p\n", sv);
    sv->wakeup_flags |= PDEMUX_WRITE;
  }

  // I never asked for POLLERR, but anyway
  if(evt.portev_events & ~(POLLIN | POLLOUT | POLLERR))
    {
        fprintf(stderr,"UNSOLICITED events in evtport_demuxer (%x)\n",
      evt.portev_events);
    }

  assert(sv->wakeup_flags != 0);    // we should've gotten SOMETHING.

  if(sv->wakeup_flags)  
    sv->wakeup(*this);
}
}}

@h=tangler('demux/demux_iocp_demuxer.cpp')
@select(h)
#include "demux_iocp_demuxer.hpp"
#include "demux_quitter.hpp" // for clean threaded iocp takedown

#include <stdio.h>      // for printf debugging
#include <stddef.h>     // offsetof
#include <assert.h>
// shoving the win_queue in here for now

namespace flx { namespace demux {

// this could really do with auto objs. steal the strat stuff?

// add windows error processing macros. It's a bore otherwise.

// WaitForSingleObject on an kill event in the thread for thread cancel
// kill_event = CreateEvent(NULL, TRUE, FALSE, NULL); (what's that)
// SetEvent(kill_event) to invoke (?): SetEvent sets the event to the 
// signalled state. Return value is success flag. GetLastError.

// do auto SOCKET wrapper, check closesocket return code.

// a completion port is a queue into which the os puts notifications of
// completed overlapped io requests. once the operation completes, a
// notification is sent to a worker thread that can process the result.
// a socket may be associated with a completion port at any point after
// creation.


// I don't see how to nicely stop a thread, I may have to have my own protocol
// to ask it to exit.

// PostQueuedCompletionStatus can be used by threads to wake up a worker
// thread. Could be handy replacement for timeout. "useful for notifying
// worker threads of external events"

// working through this: http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/
// example of worker thread here
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/i_o_completion_ports.asp
// nono, use this onec
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// oh, wait they're the same
// FormatMessge

winsock_initer::winsock_initer()
{
  WSADATA wsaData;

  // strange, rt_faio_01 static doesn't work under vs without this.
  // hum.
  // fprintf(stderr, "WINSOCK INIT!!!\n");
  // apparently 2.2's the way to go
  int res= WSAStartup(MAKEWORD(2, 2), &wsaData);
  if(res!= 0)
  {
    //JS: WSAGetLastError CANNOT be called, since WSAStartup failed
    fprintf(stderr,"couldn't find usable winsock dll: %i\n", res);
    throw res;
  }
}

winsock_initer::~winsock_initer()
{
  if(WSACleanup() != 0)
  {
    fprintf(stderr,"WSACleanup failed %i\n", WSAGetLastError());
  }
}

// iocp_wakeup base class for users of iocp_demuxer
//static
iocp_wakeup*
iocp_wakeup::from_overlapped(LPOVERLAPPED olp)
{
  // calculate the address of this from overlapped member
  // suffer an obligatory offsestof warning from broken gccs.
  return (iocp_wakeup*)((char*)olp-offsetof(iocp_wakeup, ol));
}

void
iocp_wakeup::clear_overlapped()
{
  ZeroMemory(&ol, sizeof(ol));  // much better than memset, right?
}


iocp_demuxer::iocp_demuxer()
  : iocp(NULL)
{
  // Create the completion port
  // not sure what first 3 args do, but by specifying INVALID_HANDLE_VALUE
  // for the first I think I can ignore the rest (apart from the last, numthreads)
  // I still have to create the threads, but only NumberOfConcurrentThreads
  // will wake up from GetQueuedCompletionStatus at a time. This looks to be
  // slightly elastic...
// NT 3.51 doesn't let you pass null filehandle, you've got to have a dummy
// socket. keep that in mind. see InitializeIOCP in IOCPServer.cpp example
// taken from codeproject. GetSystemInfo to find out num CPUs
  //fprintf(stderr,"CreateIoCompletionPort with ONE WORKER THREAD\n");
  iocp = CreateIoCompletionPort(
    INVALID_HANDLE_VALUE,
    NULL,
    (ULONG_PTR)0,
    1       // 1 thread (zero means one for each CPU)
  );

  if(NULL == iocp)
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed to create completion port: %li\n", err);
    throw -1;
  }
}

iocp_demuxer::~iocp_demuxer()
{
  //fprintf(stderr, "~iocp (%p) NOW WITH ASYNC QUITTER!\n", iocp);
  try
  {
    demux_quitter q;
    q.quit(this);
  }
  catch(...)
  {
    fprintf(stderr, "~iocp_demuxer async quit threw exception!\n");
    // now what do we do?
  }


  if(NULL != iocp && !CloseHandle(iocp))
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed cleanup iocp: %li\n", err);
  }
}

int
iocp_demuxer::associate_with_iocp(HANDLE obj, ULONG_PTR udat)
{
  // fprintf(stderr, "associating with iocp=%p: %p, udat: %lx\n",
  //  iocp, obj, udat);

  // Any overlapped operations performed on the object will use the
  // completion port for notification. The 3rd param can be used to pass
  // per object context information. we'll just pass that back.
  if(CreateIoCompletionPort(obj, iocp, udat, 0) == NULL) {
    // adding the same obj twice without an intervening get completion
    // status wakup gets an error 87, ERROR_INVALID_PARAMETER
    fprintf(stderr,"CreateIoCompletionPort failed to register object: %li\n",
      GetLastError());
    return -1;
  }

  return 0;
}

void
iocp_demuxer::get_evts(bool poll) {
  // with multiple threads, this will actually wake up the last to
  // block (lifo)

  // get context, call worker_thread 
  // need to be able to tell which thing completed, can have extra data
  // following some kind of struct
  // get this pointer

  // I guess to avoid swapping of thread context. By calling this on a given
  // completion port this thread is associated with it until exit or respec
  DWORD     nbytes;   // number of bytes in io transaction
  ULONG_PTR     udat;   // user data - not using this atm
  LPOVERLAPPED  olp;    // we get iocp_wakeup from this.

// If a socket handle associated with a completion port is closed,
// GetQueuedCompletionStatus returns ERROR_SUCCESS, with *lpOverlapped
// non-NULL and lpNumberOfBytes equal zero.
  
  int err = NO_ERROR;

  // No timeout. What does false mean? Eh. Could need a timeout to bring
  // the thread down.
  if(!GetQueuedCompletionStatus(iocp, &nbytes, &udat, &olp, 
    (poll) ? 0: INFINITE))
  {
    // That's strange - I sometimes get my ConnectEx errors popping
    // out here (ERROR_SEM_TIMEOUT=121, ERROR_CONNECTION_REFUSED=1225)
    // it looks like my args (overlapped, etc) are still filled out, so
    // I can still awake the sleeper
    err = GetLastError();   // doco says this & not WSALastError.

    // let's see: yep - there's my overlapped
    // fprintf(stderr,"!iocp::wait: nbytes=%li, udat=%lx, io=%p, err=%i\n",
    //  nbytes, udat, olp, err);

    if(WAIT_TIMEOUT == err)
    {
      // we get this a lot now that we can poll the iocp, so no output
      // interestingly, nbytes = 1. what could that mean?
      return;         // no wakeup
    }
    else if(ERROR_OPERATION_ABORTED == err)
    {
      // that's real bad manners. Or I could just ignore it. Anyway,
      // any overlapped received is stale.
      fprintf(stderr, "WHOA!!! - disassociate before killing handle\n");
      return;         // no wakeup
    }
    else
    {
      fprintf(stderr,"GetQueuedCompletionStatus returned false: %i\n",
        err);
      // return here? relying on olp being NULL, to stop us dereffing
    }

    // I'm going to assume that there's a good wakeup, and fall through
    // We need to wakeup on some errors (like ERROR_CONNECTION_REFUSED)
    // FALL THROUGH
  }

// An IOCP is a very general event mechanism. It tells you not only about
// the completion of reads & writes, but also of pretty much any asynchronous
// event's completion. It doesn't quite fit in with my select style interfaces.
// I've got general overlapped things completing here. I don't want them to
// know about demuxers & so forth so I'll have to know about them.

  //fprintf(stderr,"HOLEY! Woke up!\n");
  //fprintf(stderr,"nbytes=%li, udat=%lx, olp=%p, err=%i\n",
  //  nbytes, udat, olp, err);

  // with polling it's normal not to get an overlapped pointer, because
  // we may simply have timed out
  assert( olp );

  // tell someone that some overlapped op finished
  iocp_wakeup*  wakeup = iocp_wakeup::from_overlapped(olp);

  // passing olp may be redundant, seeing as it's contained in iocp_wakeup
  wakeup->iocp_op_finished(nbytes, udat, olp, err);
}



// simple utility fn, shouldn't be here. creates listener on any interface.
// this could benifit from a SOCKET class. in failure returns INVALID_SOCKET
// CURRENTLY EATS ERROR, SO DON'T BOTHER CHECKING
SOCKET
create_listener_socket(int* io_port, int backlog)
{
  fprintf(stderr,"creating_listener_socket\n");
  SOCKET        listener;

  // could use WSASocket, but these seem to be turning out overlapped anyway
  // at least after tangling with overlapped functions.
  // socket returns INVALID_SOCKET on failure.
  listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if (INVALID_SOCKET == listener)
  {
    fprintf(stderr,"listener create failed: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  SOCKADDR_IN   addr;

  // msdn code examples don't zero the sockaddr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(*io_port);

  // bind our name to the socket
  int         res;
  res = bind(listener, (LPSOCKADDR)&addr, sizeof(addr));

  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"bind() failed %i\n", WSAGetLastError());
    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }
    return INVALID_SOCKET;
  }

  // if user wanted port chosen tell them what it turned out to be
  if(0 == *io_port)
  {
    int namelen = sizeof(addr);
    if (getsockname(listener, (struct sockaddr *)&addr, &namelen) 
      == SOCKET_ERROR)
    {
      fprintf(stderr, "getsockname failed (%i)\n", WSAGetLastError());

      if(closesocket(listener) == SOCKET_ERROR)
      {
        fprintf(stderr,"closesocket failed on listener: %i\n",
          WSAGetLastError());
      }
      return INVALID_SOCKET;
    }

    *io_port = ntohs(addr.sin_port);
  }

  // Set the socket to listen
  res = listen(listener, backlog);
  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"listen() failed %i\n", WSAGetLastError());

    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }

    return INVALID_SOCKET;
  }

  return listener;
}

// currently the following aren't used. Look forward to warnings
// about them.

// the posix version of this made the socket nonblocking.
// I don't seem to have to do that when using iocp. if you
// want to create a nonblocking socket (or overlapped) pass
// WSA_FLAG_OVERLAPPED to WSASocket. I've never had to
// actually do this. How do you make accept do this? (supposing
// you wanted to) WSAAccept doesn't have a flag for it (however
// it does let you do conditional accepting). 
// There doesn't seem to be a sockopt
// returns INVALID_SOCKET on failure. eats the err.
SOCKET
nice_accept(SOCKET listener)
{
  struct sockaddr_in  remoteaddr;
  int         addrlen = sizeof(remoteaddr);
  SOCKET        s;
  
  // accept returns INVALID_SOCKET when it fails
  s = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);

  if(INVALID_SOCKET == s)
  {
    fprintf(stderr,"nice_accept failed (%i)\n", WSAGetLastError());
  }

  // the posix version makes the socket nonblocking here
  // we're not bothering

  return s;
}

// returns SOCKET_ERROR on failure, with err in WSAGetLastError()
static int
connect_sock(SOCKET s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

// returns INVALID_SOCKET on failure, eats last error with WSAGetLastError
// unlike the posix version, this does not make the socket nonblocking.
SOCKET
nice_connect(const char* addr, int port)
{
  SOCKET      s;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != INVALID_SOCKET
    && connect_sock(s, addr, port) != SOCKET_ERROR)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  fprintf(stderr,"nice_connect failed (%i)\n", WSAGetLastError());

  if(INVALID_SOCKET != s && closesocket(s) == SOCKET_ERROR)
    fprintf(stderr,"nice close failed (%i)\n", WSAGetLastError());

  return INVALID_SOCKET;
}

// returns -1 on error with errno in WSAGetLastError. 0 otherwise.
// kind of crap.
int
set_tcp_nodelay(int s, int disable)
{
  BOOL  disable_nagle = (disable) ? true : false;

  int res = setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
      (const char*)&disable_nagle, sizeof(disable_nagle));

  return (res == SOCKET_ERROR) ? -1 : 0;
}

}}

@h=tangler('demux/demux_overlapped.cpp')
@select(h)
#include "demux_overlapped.hpp"
#include <stdio.h>      // fprintf
#include <assert.h>

// cygwin's copy of mswsock.h leaves something to be desired...
#ifndef WSAID_CONNECTEX
typedef 
BOOL
(PASCAL FAR * LPFN_CONNECTEX) (
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen,
    IN PVOID lpSendBuffer OPTIONAL,
    IN DWORD dwSendDataLength,
    OUT LPDWORD lpdwBytesSent,
    IN LPOVERLAPPED lpOverlapped 
    );

#define WSAID_CONNECTEX \           
    {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
#endif

namespace flx { namespace demux {

// windows includes files here? vs will be fussy.

// AcceptEx

// return async finished flag (error flags - can be transmitted via class)
// AcceptEx is the way to get accept connections via the IOCP
bool
acceptex_control_block::start_overlapped()
{
  clear_overlapped();

// I've seen two examples get the pointer to AcceptEx, just in case it
// isn't implemented...
  // fprintf(stderr,"AcceptExing: listen backlog => can succeed immediately\n");

  // this is only set when acceptex receives data and returns immediately.
  // can't hurt to set it.
  DWORD nbytes = 0;
  BOOL  success;

  // note that in order to get the wakeup packet, the listener must
  // already be associated with the iocp. for future async io, the acceptor
  // must be associated too.
  success = AcceptEx(listener, acceptor,
    accept_buf,       // required - near/far address
    0,            // receive data size - don't yet want this
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    &nbytes,        // only set if fn completes. should be 0
    &ol);         // oblig. gets us back to the this ptr

  // if there is a backlog of connections, AcceptEx can return immediately
  if(success)
  {
    // must clear the wait
    fprintf(stderr,"WHOA! AcceptEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "This could be bad, as wait should call op_finish\n");
    fprintf(stderr, "We also lose the udat cookie (set to NULL)\n");
    // handle the successful wakeup
    // complete_async_op(demux, drv, nbytes, NO_ERROR); 
    // I hope they don't want the udat pointer, because I
    // just made it up (0=NULL). Not using it anyway.
    iocp_op_finished(nbytes, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();
    // can also return WSACONNRESET, which isn't so bad
    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"AcceptEx returned ERROR_IO_PENDING - that's normal\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      fprintf(stderr,"AcceptEx failed: %i\n", err);
      fprintf(stderr,"returning true should wake thread to detect failure.\n");
      return true;    // have self woken
    }
  }
  return false;       // async not finished

}

// ConnectEx
#if 0
// apparently we're supposed to do this now to make the acceptee inherit
// the listener's state. it is currently in the default state
//err = setsockopt( sAcceptSocket, 
//  SOL_SOCKET, 
//  SO_UPDATE_ACCEPT_CONTEXT, 
//  (char *)&sListenSocket, 
//  sizeof(sListenSocket) );
#endif

// what a pain in the arse (zzz)
// This doesn't exist in win2000, so it'll need to be synchronous there.
static int
GetConnectExAddr(SOCKET s, LPFN_CONNECTEX* conn_fn)
{
  *conn_fn = NULL;
  GUID      GuidConnectEx = WSAID_CONNECTEX;   
  DWORD     dwBytes;
  int       err;

  err = WSAIoctl(s,   // why do I need this?
    SIO_GET_EXTENSION_FUNCTION_POINTER,
    &GuidConnectEx,
    sizeof(GuidConnectEx),
    conn_fn,
    sizeof(*conn_fn),
    &dwBytes,
    NULL, NULL);    // no overlapped, no completion fun ptr
//  fprintf(stderr,"Get addr dwbytes: %li\n", dwBytes);
  return err;
}

// this is the weirdest. To use ConnectEx, the socket must be already bound.
// By trial and error, I found that it had to be bound to INADDR_ANY: 0.
// So strange. Apparently I don't have to do it again if I want to reuse.
static int
bind_socket(SOCKET s)
{
  SOCKADDR_IN   addr;

  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(0);

  return bind(s, (LPSOCKADDR)&addr, sizeof(addr));
}

bool
connectex_control_block::start_overlapped()
{
  clear_overlapped();

  // why not get this directly from the ConnectEx?
  socket_err = ERROR_IO_PENDING;


  DWORD bytes_sent = 0;   // we're not sending data on connect (yet)
  BOOL  success;

  LPFN_CONNECTEX  pfConnectEx;

  // unfortunate, will fix up later.
  // fprintf(stderr,"Getting ConnectEx address\n");

  // Turns out that ConnectEx isn't defined anywhere; I have to load its
  // addr via WSAIoctl
  // this is a bad way. make the driver cache it. why on earth is this
  // call per-socket? does it really need to be that way?
  if(GetConnectExAddr(s, &pfConnectEx) == SOCKET_ERROR)
  {
    fprintf(stderr,"GetConnectExAddr failed: %i\n", WSAGetLastError());
    return true;
  }

  // fprintf(stderr,"about to connectex to %s:%i, %i\n", addy, p, s);

  // this is so strange - I have to bind the socket to the localhost.
  // if I don't, ConnectEx returns EINVAL. in any case, I won't need
  // to do this again if I reuse this socket.
  if(bind_socket(s) == SOCKET_ERROR)
    fprintf(stderr,"ConnectEx bind failed: %i\n", WSAGetLastError());

  // I hope ConnectEx doesn't want this to hang around, because it's
  // going to drop off the stack after this.
  SOCKADDR_IN   addr;

  // some examples don't zero the addr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr(addy);
  addr.sin_port = htons(p);

  // in order to receive the wakeup packet, s must already be associated
  // with the iocp. this is best done at socket creation time. for these
  // sockets it's probably best to also bind them at the same time.
  // that requires "purposed" sockets (CreateConnectSocket?).
  // p.s. the default (waio_base) wakeup is doing fine for now.

  success = (*pfConnectEx)(s, // socket
    (LPSOCKADDR)&addr,    // connect address
    sizeof(addr),     // size thereof
    NULL,         // not sending any data yet, but we could
    0,            // ditto
    NULL,         // should be zero until this changes
    &ol);         // oblig. gets us back to the this ptr

// there's a caveat about the type of socket s becomes after ConnectEx.
// It's in some kind of default state and cannot be used with shutdown
// change it with setsockopt (?)
  if(success)
  {
    fprintf(stderr,"WHOA! ConnectEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "BAD: calls op_finish and loses udat cookie\n");
    // handle the successful wakeup. (udat=0, olp=&ol)
    iocp_op_finished(bytes_sent, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();

    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"ConnectEx pending...\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      // maybe store the error here. that could work for all
      // windows wakeups
      fprintf(stderr,"ConnectEx failed: %i\n", err);
      return true;    // have self woken
    }
  }
  return false;       // not finished
}

// TransmitFile

bool
transmitfile_control_block::start_overlapped()
{
  clear_overlapped();

  // 0 bytes => transmit entire file
  // the second zero means use the default chunk size
  // the NULL is for mem buffers to bookend the file with. nothing yet.
  // the final zero is for various flags, including a way of doing
  // DisconnectEx style socket reuse (more widely compatible?)

  // in order to receive the wakeup, s must already be associated with the
  // iocp. this is best done at socket creation time.
  if(TransmitFile(s, file, 0, 0, &ol, NULL, flags))
  {
    fprintf(stderr,"Transmit file succeeded immediately! waking...\n");
    return true;
  }
  else
  {
    DWORD err = WSAGetLastError();

    // will need to actually signal something
    // fprintf(stderr,"signal TransmitFile failure!\n");
    if(ERROR_IO_PENDING != err && WSA_IO_PENDING != err)
      fprintf(stderr,"genuine error from TransmitFile: %li\n", err);
  }
  return false;
}


// SOCKET io using WSASend and WSARecv

// windows style control blocks
wsasocketio_control_block::wsasocketio_control_block(SOCKET src, sel_param* pb,
  bool inread)
  : s(src), ppb(pb), reading(inread)
{
}

bool
wsasocketio_control_block::start_overlapped()
{
  clear_overlapped();

  error = 0;

  // num bytes received IF recv completes immediately.
  DWORD imm_bytes;
  int   recv_res;

  // set up the single wbuf, bearing in mind we may be part way.
  wbufs[0].len = ppb->buffer_size - ppb->bytes_written;
  wbufs[0].buf = ppb->buffer + ppb->bytes_written;

// fprintf(stderr, "sockio: %p->finished = %i, reading = %i\n",
//  ppb, ppb->finished(), reading);

  // Ideally, we would like to be able to use MSG_WAITALL, which would
  // let us only get a completion packet when either all the data was
  // available or the connection had been closed or shutdown.
  // Unfortunately this is not possible for non-blocking sockets, so
  // we have to take whatever we get and then call WSARecv again.

  //#define MSG_WAITALL 0   // not defined in cygwin - apparently this
  //DWORD flags = MSG_WAITALL;

  // ah, unfortunately MSG_WAITALL is not supported for non blocking sockets
  // we'll just have to do it ourselves
  DWORD flags = MSG_PARTIAL;

  // completion routines! (unused)
  if(reading)
    recv_res = WSARecv(s, wbufs, NUM_WBUFS, &imm_bytes, &flags, &ol, NULL);
  else
    recv_res = WSASend(s, wbufs, NUM_WBUFS, &imm_bytes, flags, &ol, NULL);

  // don't know if I need to check non winsock errs

  switch(recv_res)
  {
    case 0:
    {
      // flags are updated to indicate what? if there was a callback, it
      // would be scheduled to be called when this thread is in the
      // waitable state, whatever that means.
      //fprintf(stderr,
      //  "WSA%s completed immediately!!! nbytes: %li, flags: %lx\n",
      //    (reading) ? "Recv" : "Send", imm_bytes, flags);

      // looks like we get the completion packet even if we do finish
      // immediately so let the iocp wake us. note that this method
      // of manually calling iocp_op_finished is not so great as we
      // don't know the (as yet unused) udat cookie and so set it to 0.
      // fprintf(stderr, "calling finished manually (ppb=%p)\n", ppb);
      // iocp_op_finished(imm_bytes, 0, &ol, NO_ERROR); 

      // false because iocp_op_finished will wake us. I guess false from
      // these guys means that a completion packet is in the mail and
      // true means that it isn't (in the mail).
      return false;
    }
    break;
    case SOCKET_ERROR:
    {
      DWORD err = WSAGetLastError();

      // normal mode - wait for completion
      // fyi, xp pro seems to mostly give us ERROR_IO_PENDING
      if(ERROR_IO_PENDING == err || WSA_IO_PENDING == err)
      {
        // fprintf(stderr,"WSA%s pending completion (%li)\n",
        //  (reading) ? "Recv" : "Send", err);
        return false;     
      }

      fprintf(stderr,"WSARecv/Send returned SOCKET_ERR: %li\n", err);
      return true;    // assume it's bad and we won't get a wakeup
    }
    break;
    default:
    {
      fprintf(stderr,"WSARecv/Send returned other error: %i, GetLastError: %li\n",
        recv_res, GetLastError());
      return true;        // wake up
    }
    break;
  }

  return false;
}

// NB: called by iocp::wait, so be aware of which thread is doing what, lest
// you be surprised by this being called asynchronously.
void
wsasocketio_control_block::iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  error = err;        // copy back for others to look at.
                // perhaps move back to iocpwakeup
// fprintf(stderr, "wsasocketio::finished: ppb=%p, nbytes=%li, err=%i, read=%i\n",
//  ppb, nbytes, err, reading);

  if(err)
  {
    fprintf(stderr, "wsasocketio, got error: %i\n", err);
  }

  // fprintf(stderr,"wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );
assert( !ppb->finished() );
  // keep track of bytes received.
  ppb->bytes_written += nbytes;

  if(0 == nbytes)
  {
    fprintf(stderr, "wsaiosocket got zero bytes: err=%i, read=%i\n",
      err, reading);
  }

  // if we're not finished, we have to reinstall our request
  // zero bytes indicates shutdown/closure, right?
  // might be using this for WSASend. Instead of broken pipes on win32, 
  // instead we get WSAECONNRESET (pretty sure) on write. On read?
// not sure about this - I don't think we have to check nbytes == 0
  if(0 == nbytes || ppb->finished())
  {
    return;
  }
  else
  {
    // go back around again
    fprintf(stderr,"didn\'t get everything (%li of %li bytes)\n",
      ppb->bytes_written, ppb->buffer_size);
    if(start_overlapped())
    {
      fprintf(stderr, "UM, socket restart finished immediately\n");
      fprintf(stderr, "causes new wakeup? or should I loop around?\n");
    }
  }
}


// file/pipe io using ReadFile and WriteFile

winfileio_control_block::winfileio_control_block(HANDLE f, void* buf, int len,
  bool inread)
  : reading(inread), file(f)
{
  // pb is not so useful here. we only want to
  // know num bytes written/processed.
  pb.buffer = (char*)buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// if file is opened with FILE_FLAG_OVERLAPPED, we can do "immutable file ptr"
// ops & set the desired offset within the overlapped. can also stick an
// event to signal in there.
bool
winfileio_control_block::start_overlapped()
{
  // fprintf(stderr,"winfileio_cb::start_overlapped: reading=%i\n", reading);
  clear_overlapped();

  // DWORD  imm_bytes;
  BOOL  success;

  // don't need bytes read, written when we have an OVERLAPPED
  if(reading)
    // success = ReadFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = ReadFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
  else
    //success = WriteFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = WriteFile(file, pb.buffer, pb.buffer_size, NULL, &ol);

  // fprintf(stderr,"immbytes = %li\n", imm_bytes);

  if(!success)
  {
    int err = GetLastError();

    // I'm getting this for unfinished
    if(ERROR_IO_PENDING == err)
    {
       return false;  // sleep on
    }
    else
    {
       fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
         err);
       return true;      // ask for wakeup
    }

    // fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
    //  GetLastError());
    // fprintf(stderr,"do I still get completion packet???\n");
    // assume not
  }

  return false;       // sleep on
}

}}

@h=tangler('demux/demux_overlapped.hpp')
@select(h)
#ifndef __FLX_DEMUX_OVERLAPPED_H__
#define __FLX_DEMUX_OVERLAPPED_H__
#include "flx_demux_config.hpp"

// visual studio is quite sensitve about how you do these includes.
#include <WinSock2.h>              // Winsock2 (WSABufs, etc) must come before Windows.h
#include "demux_iocp_demuxer.hpp"  // this header file include Windows.h
#include <MSWSock.h>  // AcceptEx, TF_REUSE_SOCKET, etc

namespace flx { namespace demux {

// rename these to control block something or other
// get rid of default constructors - faio can worry about that.

// WARNING: in some "immediate completion" cases I have to call
// the finished function myself - in these cases I set the udat to 0, making
// it not very reliable. Either make sure the user understands immediate
// finish (and does it themselves) or keep a copy of udat.

// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class DEMUX_EXTERN acceptex_control_block : public iocp_wakeup {
  enum { ACCEPTEX_ADDR_SIZE = sizeof(SOCKADDR_IN) + 16 };

public:
  SOCKET  listener, acceptor;
  // there are two of these!
  char  accept_buf[2*ACCEPTEX_ADDR_SIZE];

  virtual bool start_overlapped();

  acceptex_control_block() 
    : listener(INVALID_SOCKET), acceptor(INVALID_SOCKET) {}
};

class DEMUX_EXTERN connectex_control_block : public iocp_wakeup
{
public:
  // move further back?
  int socket_err;         // outgoing

  // can have buffer to be sent on connection
  SOCKET    s;          // previously unbound socket
  const char* addy;       // ipv4 address
  int     p;          // port number

  // socket_err undefined
  connectex_control_block() : s(INVALID_SOCKET), addy(0), p(0) {}

  // see posix version of this, try to keep them in sync. give socket_err
  // initial definition that works with this?
  bool finished() { return ERROR_IO_PENDING != socket_err; }

  virtual bool start_overlapped();
};

// TransmitFile here (requires file handle)
class DEMUX_EXTERN transmitfile_control_block : public iocp_wakeup {
  SOCKET  s;
  HANDLE  file;
  DWORD flags;                // for possible socket reuse.
public:

  transmitfile_control_block(SOCKET dst)      // for reuse of socket
    : s(dst), file(NULL), flags(TF_DISCONNECT | TF_REUSE_SOCKET) {}

  transmitfile_control_block(SOCKET dst, HANDLE src)  // actual transmitfile
    : s(dst), file(src), flags(0) {}

  virtual bool start_overlapped();
};


// handles both WSASend & WSARecv
class DEMUX_EXTERN wsasocketio_control_block : public iocp_wakeup {
protected:
  enum { NUM_WBUFS = 1 }; // just one for now, but can do scattered send/recvs
  WSABUF    wbufs[NUM_WBUFS];
public:
  SOCKET    s;
  sel_param*  ppb;      // on input what you want, on output what you got
  int     error;
  bool    reading;  // else use WSASend

  // watch the memory interfaces here, going back and forth between threads.
  wsasocketio_control_block(SOCKET src, sel_param* pb, bool read);

  virtual bool start_overlapped();

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// looks a bit like wsasocketio_control_block (bad name, sends too)
class DEMUX_EXTERN winfileio_control_block : public iocp_wakeup {
  bool    reading;
public:
// probably should be a pointer (?)
  sel_param pb;
  HANDLE    file; // I like to modify this from the outside

  // offset?
  winfileio_control_block(HANDLE f, void* buf, int len, bool read);

  virtual bool start_overlapped();

  // NB: no iocp_op_finished callback. defined by users of the class.
};

}}

#endif
@h=tangler('demux/demux_kqueue_demuxer.cpp')
@select(h)
// kqueue demuxer for bsd/os x
// N.B. calling close on a file descriptor will remove any kevents that
// reference that descriptor. that would explain remove complaining from
// time to time.
// try EV_EOF to pick up eofs, useful for async file io.

#include "demux_kqueue_demuxer.hpp"

#include <stdio.h>      // perror
#include <unistd.h>     // close

#include <sys/types.h>    // from the kqueue manpage
#include <sys/event.h>    // kernel events
#include <sys/time.h>   // timespec (kevent timeout)

// #include <sys/syscall.h> // syscall(SYC_close,kq) close workaround

namespace flx { namespace demux {
kqueue_demuxer::kqueue_demuxer()
  : kq(-1)
{
  // Not that you care, but this event queue is not inherited by
  // forked children.
  kq = kqueue();
  if(-1 == kq)
  {
    perror("kqueue");
    throw -1;
  }
}

kqueue_demuxer::~kqueue_demuxer()
{
  // calling close on a kq while a thread is waiting in kevent causes close
  // to block! this happens on 10.4. Hard to say on 10.3 as close simply
  // fails there. we need to wake the waiting thread, so we'll use that
  // handy self pipe waker. Luckily, kqueues are responsive to new fds,
  // otherwise we'd need the self pipe waker to be there from the start 
  // p.s. it's also bad form to destruct a demuxer while a thread waits
  // on it. top marks to kqueues for making this obvious, passing fail
  // to me for not applying the same to the other async demuxers.
  async_quit();

  //if(syscall(SYS_close, kq) == -1)
  // I don't seem to be able to close a kq. can't fstat it either
  if(-1 != kq && close(kq) == -1)
    perror("kqueue close");
}


// Events of interest to us ERead, EWrite.
// ERead has fflags: NOTE_LOWAT, NOTE_EOF. ident is a descriptor (any?) 

// if you're using the kqueue_demuxer to do a single biderectional wakeup,
// be aware that it currently breaks the "one shot" rule, that is you
// make get an unexpected wakeup the next time you call wait.
int
kqueue_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // we only know these flags
  if((flags & ~(PDEMUX_READ | PDEMUX_WRITE))) return -1;

// could set wakeup_flags here of what's been installed!

  // FUCK - can only do one at a time with kqueues
  // For those doing both, if one fails, you're in a bit of trouble.
  if(flags & PDEMUX_READ)
  {
    if(add_kqueue_filter(sv, EVFILT_READ) == -1) return -1;
  }

  if(flags & PDEMUX_WRITE)
  {
    if(add_kqueue_filter(sv, EVFILT_WRITE) == -1) return -1;
  }

  return 0;
}

int
kqueue_demuxer::add_kqueue_filter(socket_wakeup* sv, short filter)
{
  int       s = sv->s;
  struct kevent evt;
  
  // this works just like select if the s is a listening socket
  // *except* works with all types of fds, including pipes, files & fifos
  // can set low water mark for reads with NOTE_LOWAT in fflags and size
  // in data. on return data contains number of bytes available to read
  // on return sets EV_EOF in flags if read dir socket has shutdown and
  // returns a possible socket err in fflags
  // should that be EV_ENABLE | EV_ADD. fflags zero cos I don't know what
  // to put there. pass pb in udata
  
  // adding EV_ONESHOT to save me removing on wakeup (a syscall).
  // I now require that during the evt be removed before wakeup fn.
  
  EV_SET(&evt, s, filter, EV_ADD | EV_ONESHOT, 0, 0, sv);
  // trying to detect when have reached eof with async file io using kq
  //EV_SET(&evt, s, EVFILT_READ, EV_ADD, | EV_ONESHOT NOTE_LOWAT, 16*1024, sv);

  // add event
  if(kevent(kq, &evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent add_kqueue_filter");
    return -1;
  }
  return 0;
}

// useful, but unused atm, thanks to ONESHOT.
// this function skirts the portability boundaries of the demux interface
// for kqueues each event monitor is identified (for sockets) by a pair,
// (s, filter), or for us, (s, {in|out}). This means that we can add
// individual wakeups for reading and writing but not both at once.
// I think epoll can do both, and so can select (and N/A to IOCPs).
// This "both at once" thing can't easily be one shot. There's a good
// case for this behaviour to be defined "undefined". Not many people
// using this part - could be caveat emptor...
int
kqueue_demuxer::remove_kqueue_filter(int s, short filter)
{
  struct kevent evt;

  EV_SET(&evt, s, filter, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent remove_socket_wakeup");
    return -1;
  }

  return 0;
}

int
kqueue_demuxer::remove_socket_wakeup(int s, int flags)
{
  int r1 = 0, r2 = 0;

  if(flags & PDEMUX_READ) r1 = remove_kqueue_filter(s, EVFILT_READ);
  if(flags & PDEMUX_WRITE) r2 = remove_kqueue_filter(s, EVFILT_WRITE);

  // If you want to know which one failed, you're out of luck.
  if(r1 || r2) return -1;

  return 0;
}

// from "advanced macos programming", on reading shutdown causes
// the EV_EOF flag to be set in the flags field and returns errno
// in the fflags field. There may still be pending data to read
// when EV_EOF is set. The data field says how many bytes available.
// for writing data says how much you can write. EV_EOF is set
// when the reader "disconnects". Says nothing about errno/fflags
// in this case.
/*
    fprintf(stderr,"readevt on %i, EOF = %s\n",
      s, (ev.flags & EV_EOF) ? "TRUE" : "FALSE");
 */

// do that thing where you get the events. can I get them one at a time?
// I bet I can.
void
kqueue_demuxer::get_evts(bool poll)
{
  // event seems to remain unless we remove it
  struct kevent ev;
  int       nevts;

  struct timespec timeout, *tptr = NULL;
  
  if(poll)
  {
    timeout.tv_sec = 0;   // effectuate a poll
    timeout.tv_nsec = 0;
    tptr = &timeout;
  }

  // timeout.tv_sec = 1;    // timeout every second
  // timeout.tv_nsec = 0; // 10^9 nanoseconds per second

  nevts = kevent(kq, NULL, 0, &ev, 1, tptr);  // wait or poll

  if(nevts <= 0)
  {
    // error, else timeout & return to allow cancel
    if(nevts < 0)
      perror("kevent event fetch");

    return;
  }

  // fprintf(stderr,"kqueue wakeup!\n");

  socket_wakeup*  sv = (socket_wakeup*)ev.udata;

  // The filters are not bit fields, hence they must come in serially.
  // this means you're never going to get both read and write on
  // a kqueue_demuxer wake up. No worries.
  if(ev.filter == EVFILT_READ)
  {
  // this capability is lost for the moment, as we have no way
  // of explaining it to felix. the event stuff isn't so good right now
/*
    // can chunk up on accepts. nice one kqueue
    if(NULL == sv)      // => listener
    {
      int backlog = (int)ev.data;   
      // fprintf(stderr,"kq listen backlog: %i\n", backlog);
      for(int i = 0; i < backlog; i++) handle_connection();
    }
    else
*/
    // If a socket wakeup were a control block, you'd set the err here.
    if(0 && ev.flags & EV_EOF)
    {
      // errno in fflags!
      fprintf(stderr,
        "got EV_EOF on read, %i bytes remain in buffer, errno=%i\n",
        (int)ev.data, ev.fflags);
    }
    // fprintf(stderr,"EVFILT_READ: got %i bytes coming\n", (int)ev.data);
    // remove_reading_fd(s);      // now useing EV_ONESHOT
// remove other outstanding here...?
    sv->wakeup_flags = PDEMUX_READ;   // Tell 'em what they've won.
    sv->wakeup(*this);
  }
  else if(ev.filter == EVFILT_WRITE)
  {
    // fprintf(stderr,"EVFILT_WRITE: can write (?) %i bytes\n",
    //  (int)ev.data);

    // using oneshot mode now.
    // remove_writing_fd(s);

    if(ev.flags & EV_EOF)
    {
      // errno in fflags? data should be zero bytes, right?
      // can't write anything
      fprintf(stderr,
        "got EV_EOF on write, data bytes =%i (0?), errno/fflags?=%i\n",
        (int)ev.data, ev.fflags);
    }
// remove other outstanding here?
    sv->wakeup_flags = PDEMUX_WRITE;
    sv->wakeup(*this);
  }
  else
  {
    fprintf(stderr,"unsolicited event from kqueue (%i)...\n", ev.filter);
    // no wakeup
  }
}
}}

@h=tangler('demux/demux_pfileio.cpp')
@select(h)
#include <stdio.h>    // printf
#include <errno.h>    // errno
#include "demux_pfileio.hpp"

// blocking reads & writes that use a worker fifo. users overload
// finished flag to implement wakeup

// if we could group the requests, we could do a scattered read
// or we could do single reads if the requests were of a similar
// nature, i.e. the whole file, of popular files.

// for pwrite/pread, I'm supposed to include the following three (osx man page)
// they don't appear to be necessary, but let's play it safe
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

namespace flx { namespace demux {
// fileio_request stuff follows

// read or write in a blocking fashion. I like the idea of using pread
// which doesn't change the file pointer. this could allow reuse of the same
// file descriptor & block caching

fileio_request::~fileio_request(){}
fileio_request::fileio_request(){}

fileio_request::fileio_request(int f, char* buf, long len, long off, bool rd)
  : offset(off), fd(f), read_flag(rd), err(0)
{
  pb.buffer = buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// synchronously process read/write
void
fileio_request::doit()
{
  // fprintf(stderr,"faio about to try to %s %i bytes from fd=%i\n",
  //  (read_flag) ? "read" : "write", pb.buffer_size, fd);

// switching off (explicit) seeks for now because I'm not using them
// in the flx code & I'm not passing around enough info (just the fd)
  ssize_t res;

  if(read_flag)
  {
    // res = pread(fd, pb.buffer, pb.buffer_size, offset);
    res = read(fd, pb.buffer, pb.buffer_size);
  }
  else
  {
    // res = pwrite(fd, pb.buffer, pb.buffer_size, offset);
    res = write(fd, pb.buffer, pb.buffer_size);
  }
  
  // zero return value indicates end of file. that should just work.
  if(-1 == res)
  {
    err = errno;    // grab errno
    fprintf(stderr,"faio error: %i\n", err);
  }
  else
  {
    // fprintf(stderr,"faio %s %i bytes\n", (read_flag) ? "read" : "write", res);
    pb.bytes_written = res;
  }
}
}}

@h=tangler('demux/demux_posix_demuxer.cpp')
@select(h)
#include "demux_posix_demuxer.hpp"
#include "demux_sockety.hpp"
#include "demux_quitter.hpp" // fns for waking and quitting a demuxer

#include <stdio.h>        // "printf"
#include <assert.h>       // assert
#include <string.h>       // strerror
#include <unistd.h>       // close

#include <sys/types.h>      // send/recv
#include <sys/socket.h>

//#include <sys/errno.h>
#include <errno.h>        // GUSI & solaris prefer this

namespace flx { namespace demux {

posix_demuxer::~posix_demuxer()
{
}

bool
posix_demuxer::socket_recv(int s, sel_param* pb)
{
  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);
  ssize_t     nbytes;
  
  // if this were read then this fn would work with non-sockets
  nbytes = recv(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written, 0);

  if(nbytes <= 0)
  {
    if(nbytes == 0)
    {
      return true;        // connection closed
    }
    else
    {
      perror("recv");       // can get reset connection here
      return true;        // so say closed, yeah?
    }
  }
  else
  {
    // got some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

bool
posix_demuxer::socket_send(int s, sel_param* pb)
{
  // kqueue (and some of the other ones) can let you know know how much
  // to write... imagine that!

  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;

  nbytes = send(s, pb->buffer + pb->bytes_written,
    pb->buffer_size - pb->bytes_written, 0);

  // similar story here, with send vs write?

  // what's the story with zero? Is that allowed or does it signal
  // that the connection closed?
  if(-1 == nbytes)
  {
    perror("send");
    return true;          // I guess the connection closed
  }
  else
  {
    // sent some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

// doesn't throw
void
posix_demuxer::async_quit()
{
  try {
    // NEW and IMPROVED!!! demux quitter which sets demux quit flag
    // via self pipe trick then waits for self pipe/quitting callback
    // to finish. no fear of quitter being destructed early!

    // this will wake the thread (there should only be one atm), however
    // that's just another race between kevent and close. really need to
    // extend self piper to set a quit flag. we have to currently assume
    // that there is only event collecting thread.
    // fprintf(stderr, "taking down kqueue with quitter (QUITTER!)\n");
    demux_quitter quitter;
    quitter.quit(this);
  } catch(...) {
    fprintf(stderr, "error waking demuxer with self pipe quitter\n");
  }
}

#if 0
  //nbytes = recv(s, pb->buffer + pb->bytes_written,
  //      pb->buffer_size - pb->bytes_written, 0);

  // select and kqueue know when non socket fds have data.
  // recv only works with sockets, but read works with both files
  // and sockets and who knows what else. is there any disadvantage
  // to using read instead? apart from losing flags arg?
  // does read get the same 0 bytes = close behaviour
  nbytes = read(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written);
#endif

// handy posix control blocks for accept, connect.

int
accept_control_block::start(posix_demuxer& demux)
{
  // add listener to demuxer as reading socket - see man 2 accept
  // returns 0 on success, -1 on failure. not sure how to communicate
  // the error.
// could try the accept now, to see if it succeeds instantly...
// observe wakeup rules (formulate them first)
  accepted = -1;
  // socket_err = 0;
  // not quite true, but I want it to be clear if this ever becomes possible
  // to do immediately
  socket_err = EINPROGRESS;
    return demux.add_socket_wakeup(this, PDEMUX_READ);
}

// one wakeup socket is in accepted and error in socket_err
void
accept_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"accept_control_block woke up\n");

  // we can now accept without blocking
  // s is the listener, ambiguously named in parent socket_wakeup class
  accepted = nice_accept(s, &socket_err);

  if(accepted == -1)
  {
    fprintf(stderr, "nice_accept failed, err (%i)\n", socket_err);
  }
}

// returns -1 on failure, 0 on success. on success the call is finished
// (and so no wakeup) if socket_err == 0.
int
connect_control_block::start(posix_demuxer& demux)
{
  // fprintf(stderr,"async connect start\n");

  int finished;

  // returns either finished and err, or not finished
  // and (no err || EINPROGRESS)
  s = async_connect(addy, p, &finished, &socket_err);

  // fprintf(stderr,"async_connect returned s: %i, finished: %i, err=%i\n",
  //  s, finished, socket_err);

  if(-1 == s)   // failed!
  {
    fprintf(stderr,"async_connect failed (%i)\n", socket_err);
    return -1;  // error in socket_err, no wakeup
  }

  if(finished)
  {
    // this actually happens on solaris when connecting to localhost!
    fprintf(stderr,"async_connect finished immediately, waking\n");
    fprintf(stderr, "No wakeup coming...\n");
    // this does not indicate an error, but that there is no wakeup
    // coming. this could be done by a wakeup, all that happens is
    // getsockopt is called to check the socket's error state.
    return -1;          
  }

  // fprintf(stderr,"connect_request didn't finish immediatly, sleeping\n");

  // add to demuxer as writing socket - see man 2 connect
  // how do they get the error?
    return demux.add_socket_wakeup(this, PDEMUX_WRITE);
}

void
connect_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"connect woke up\n");
  // this is how we check the success of async connects
  // if get_socket_err fails, we're treating its errno as the socket's...
  if(get_socket_error(s, &socket_err) == -1)
    fprintf(stderr, "eep - get_socket_err failed!\n");

  // failed, throw away socket
  if(0 != socket_err)
  {
    fprintf(stderr,"async connect error: %s (%i), closing\n",
      strerror(socket_err), socket_err);
    // we created the connect socket, so we close it too.
    if(close(s) != 0)
      perror("async socket close");

    s = -1;   // the result
  }

  // resulting connected socket in s
}
}}

@h=tangler('demux/demux_select_demuxer.cpp')
@select(h)
// P.S. for current impl don't need the pthreads. WHOO!!!

// A very light wrapper around select, that allows the addition
// of new sockets and returns status in a queue.
// on the powerbook with 10.3, FD_SETSIZE is 1024, that means
// max 1024 sockets. That's kind of lame. See IO completion ports
// on NT for a better solution.

// See ACE_Handle_Set_Iterator for an optimised seelect bit field examination
// algorithm (p149 C++ network programming, volume1)

// see epoll, kqueue & IOCPs

// is select level triggered? I think it is.
// strangely, I'm never seeing anything from the exception set.

#include "demux_select_demuxer.hpp"

#include <assert.h>
#include <string.h>       // memset

#include <stdio.h>        // printf debug
#include <stdlib.h>
#include "demux_sockety.hpp"  // get_socket_error
#include <memory>

namespace flx { namespace demux {

select_demuxer::select_demuxer()
{
  // clear these guys. after the thread starts, access to them will have
  // to be via the lock
  FD_ZERO(&master_read_set);
  FD_ZERO(&master_write_set);
  FD_ZERO(&master_except_set);
  fdmax = 0;        // corresponds to stdin, which we're not using

  // clear this possibly quite large list
  //memset(svs, 0, sizeof(svs));
  //JS: memset must not be used except for raw data or chars
  std::uninitialized_fill_n(svs,FD_SETSIZE,(socket_wakeup*)0);
}

// one select, must not block indefinitely, so choose a timeslice
// or find a way to make it wake on command, like a dummy socket
void
select_demuxer::get_evts(bool poll)
{
  // to use select we must copy our arguments, as it changes them!
  // this code has been broken up in to pieces so that I can implement

  fd_set  read_set, write_set, except_set;

  copy_sets(read_set, write_set, except_set);
  
  if(select(read_set, write_set, except_set, poll))
    process_sets(read_set, write_set, except_set);
}

int
select_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  int s = sv->s;

  // fprintf(stderr, "adding select wakeup for %i, flags=%x\n", s, flags);

  if(s < 0 || s >= FD_SETSIZE) return -1; // weakness of select

  assert(svs[s] == NULL);         // sanity check: nothing there

  if(flags & PDEMUX_READ) FD_SET(s, &master_read_set);

  if(flags & PDEMUX_WRITE) FD_SET(s, &master_write_set);

  // does this mean we could add a non-reading, non-writing socket
  // and wait for errors on it?
  FD_SET(s, &master_except_set);

  svs[s] = sv;              // record wakeup. ours now.


  if(s > fdmax) fdmax = s;        // update highwater mark

  return 0;
}

// removes for both reading AND writing.
void
select_demuxer::remove_fd(int s)
{
  // fprintf(stderr, "removing select fd: %i\n", s);

  assert(s >= 0 && s < FD_SETSIZE);
  assert(svs[s] != NULL);         // there should be something there

  // clear them all regardless. 
  FD_CLR(s, &master_read_set);
  FD_CLR(s, &master_write_set);
  FD_CLR(s, &master_except_set);

  svs[s] = NULL;
}

// virtual functions to be overridden for thread safe descendent
void
select_demuxer::copy_sets(fd_set& rset, fd_set& wset, fd_set& exset)
{
  rset = master_read_set;
  wset = master_write_set;
  exset = master_except_set;
}

bool
select_demuxer::select(fd_set& rset, fd_set& wset, fd_set& exset, bool poll)
{
  // this is depending on my fake socket to wakeup. perhaps use the timer
  // for now.
  struct timeval  tv, *tp = NULL;

  if(poll)
  {
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    tp = &tv;
  }
  
  // the return value here actually has significance
  // sometimes I have to try again, or weed out bad fds.
  //if(select(fdmax+1, &read_set, &write_set, &except_set, &tv) == -1)
// nah! wait forever. none of these things shutdown properly yet.
// it'll force the async new wakeup responsiveness
  switch(::select(fdmax+1, &rset, &wset, &exset, tp))
  {
    case 0:
      return false;   // timed out, don't process sets
    break;
    case -1:
    // not the ideal reaction. I think this is where I weed out
    // the bad socket(s). would need error set.

    // closing a socket without removing can get us here. that's pretty
    // nasty, because our data would be stale. Try not to do that. I
    // wonder if the except set would tell us when the socket was
    // closed on us? Damn, you have to clear it, else you keep getting
    // the same error.
      perror("select");
      // fall through and examine except set
    break;
  }
  return true;    // call process_sets
}

void
select_demuxer::process_sets(fd_set& rset, fd_set& wset, fd_set& exset)
{
  // since we're about to traverse the socket sets anyway, we should
  // note the highest fd seen, and make that the highwater mark.
  // that way we wouldn't be guaranteed monotonically degrading performance.

  // might be worth keeping a low water mark as well.
  // I guess this is why select sucks. On osx we can only watch
  // about 1024 sockets. That sucks too. could allocate larger sets
  // with malloc... see c++ network programming book.

  // like kqueues, this code could theoretically handle separate wakeups
  // for read and write, should I do it? not right now.
  int new_fdmax = 0;

  for(int i = 0; i <= fdmax; i++)
  {
    int   flags = 0;

    if(FD_ISSET(i, &rset)) flags |= PDEMUX_READ;

    if(FD_ISSET(i, &wset)) flags |= PDEMUX_WRITE;
  
    // sorta suggests that I ought to call the wakeup and pass
    // an error flag on to it.
    if(FD_ISSET(i, &exset))
    {
      // don't remove bad sockets - it's an error to close the socket
      // or deallocate the wakeup without telling the source. when
      // we get socket errors, we'd better hope that there's reading
      // or writing to be done.
      // under cygwin, closing down a socket (read, write or both)
      // causes select to wake up with an exception bit. out of cygwin
      // we only wake up. In both cases, the read bit is set so
      // just handling the stuff seems to work. not sure about write.
      // posix_demuxer::socket_recv thinks the connection's closed, but
      // it all seems to work out. Yours, Confused.

      fprintf(stderr, "select error on socket %i, flags=%x\n",
        i, flags);

      int err;
      // heh heh, this isn't great to call on the pipe that is used
      // in the self pipe trick. I don't know why it's getting an
      // err anyway.
      if(get_socket_error(i, &err) == -1)
        fprintf(stderr, "get_socket_error failed!?!\n");

      fprintf(stderr, "socket err = %i, %s\n", err, strerror(err));
      // don't remove! see below
      // remove_fd(i);
    }

    //
    if(flags)
    {
      socket_wakeup*  sv = svs[i];
      // remove before wakeup so wakeup can add itself back, 
      // if necessary.
      remove_fd(i);

      sv->wakeup_flags = flags;
      sv->wakeup(*this);
    }

    // to lower high-watermark, keep track of highest seen.
    if(svs[i]) new_fdmax = i;
  }

  // fprintf(stderr, "new_fdmax=%i, fdmax=%i\n", new_fdmax, fdmax);

  fdmax = new_fdmax;      // copy it back
}

}} // flx, demux

@h=tangler('demux/demux_ts_select_demuxer.cpp')
@select(h)
#include "demux_ts_select_demuxer.hpp"

// #include <stdio.h>

namespace flx { namespace demux {

ts_select_demuxer::ts_select_demuxer()
{
  // fprintf(stderr, "creating pipe for self-pipe trick\n");
  // install self pipe trick
  sp.install(&demux);
}

ts_select_demuxer::~ts_select_demuxer()
{
  async_quit(); // wake thread, ask to leave.
}

void
ts_select_demuxer::get_evts(bool poll)
{
  fd_set  rset, wset, exset;

  // copy args under lock
  {
    flx::pthread::flx_mutex_locker_t locker(ham_fist);
    demux.copy_sets(rset, wset, exset);
  }
  
  // process arg set under lock. note that the select demuxer is passed
  // to wakeups, so no recursive lock is needed. also, because any 
  // readditions caused by the callback are done to the naive demuxer,
  // no selfpipe writes are required either. the only thing to remember
  // is that the wakeup recipient should not be surprised to see a demuxer
  // in its callback different to the one it originally added to.
  if(demux.select(rset, wset, exset, poll))
  {
    flx::pthread::flx_mutex_locker_t locker(ham_fist);
    demux.process_sets(rset, wset, exset);
  }
}

// thread safe overloaded functions follow. all acquire the lock
// then call the unthreadsafe version of the function. nice!
int
ts_select_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // fprintf(stderr, "ts_select::add: %p->%i (%s), %x\n",
  //  sv, s, (s == self_pipe_fds[0]) ? "self pipe" : "socket", flags);
  flx::pthread::flx_mutex_locker_t locker(ham_fist);

  int res = demux.add_socket_wakeup(sv, flags);
  // I wouldn't touch the sv after this.

  // we have a new socket, so wake the event waiting thread
  // for great responsiveness.
  if(-1 != res) sp.wake();

  return res;

// we need to wake a blocking get_evts call here else we'll have bad
// performance or even a lockup. the question is do we need to do it under
// the tutelage of the lock?
}

}}

@h=tangler('demux/demux_sockety.hpp')
@select(h)
#ifndef __FLX_DEMUX_SOCKETY_H__
#define __FLX_DEMUX_SOCKETY_H__
#include <flx_demux_config.hpp>
namespace flx { namespace demux {

// Shouldn't this all be DEMUX_EXTERN? eh, doesn't happen on win32
// we'll probably live.
int create_listener_socket(int* io_port, int q_len);
int create_async_listener(int* io_port, int q_len);
int nice_accept(int listener, int* err);
int nice_connect(const char* addr, int port);
int async_connect(const char* addr, int port, int* finished, int* err);

/* handy socket building blocks */

int connect_sock(int s, const char* addr, int port);

/* this could possibly do with NIC addr as well as port */
int bind_sock(int s, int* io_port);

int make_nonblock(int s);
int set_tcp_nodelay(int s, int disable_nagle);
int get_socket_error(int s, int* socket_err);

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_quitter.hpp')
@select(h)

#ifndef __FLX_DEMUX_QUITTER_H__
#define __FLX_DEMUX_QUITTER_H__

#include <flx_demux_config.hpp>
#include "demux_demuxer.hpp"  // demuxers
#include "pthread_mutex.hpp"  // mutexes 
#include "pthread_condv.hpp"  // condition var for same

#if FLX_WIN32
#include "demux_wself_piper.hpp" // win32 self piper
#else
#include "demux_self_piper.hpp" // posix self piper
#endif

namespace flx { namespace demux {

// a waitable boolean. gratuitously tied to demuxer by demux_quit_flag
// todo: unhook.
class DEMUX_EXTERN async_bool : public demux_quit_flag {
  flx::pthread::flx_mutex_t cv_lock;       // to work with the condition var
  flx::pthread::flx_condv_t finished_cond; 
  bool finished;   // might seem redundant, but that's how CVs work.
public:
  async_bool();

  void wait_until_true();
  virtual void signal_true();
};

// quits a demuxer 
class DEMUX_EXTERN demux_quitter : public demux_callback {
  // self pipes for getting demuxer attention
#if FLX_WIN32
  wself_piper sp;
#else
  self_piper sp;
#endif
  async_bool finished;  // initially false
  void callback(demuxer* demux); // called back by demuxer in event thread.
public:
  void quit(demuxer* demux); // blocks until event thread exits
};

/*
class DEMUX_EXTERN wdemux_quitter : demux_callback {
  wself_piper sp;
  async_bool finished; // initially false
public:
  void quit(iocp_demuxer* demux); // blocks until demuxer/event thread exits

  void callback(demuxer* d); // called back by demuxer
};
*/

} }

#endif

@h=tangler('demux/demux_quitter.cpp')
@select(h)
#include "demux_quitter.hpp"
#include <stdio.h>

namespace flx { namespace demux {

async_bool::async_bool()
  : finished(false)
{
  // nothing
}

// called from the non-event-waiting thread.
void
async_bool::wait_until_true()
{
  flx::pthread::flx_mutex_locker_t    locker(cv_lock);

  // wait for the wakeup to say it's finished
  while(!finished)
  {
    finished_cond.wait(&cv_lock);
  }
}

// call this last thing before event thread exit
void
async_bool::signal_true()
{
  finished = true;
  finished_cond.signal();
  // do absolutely NOTHING here as we may have already been destructed. boom.
}

void
demux_quitter::callback(demuxer* demux)
{
  //fprintf(stderr, "quitter callback\n");
  demux->set_quit_flag(&finished);
}

void
demux_quitter::quit(demuxer* demux)
{
   // fprintf(stderr, "trying to quit demuxer...\n");
   // install self piper, with our callback
   sp.install(demux, this);
   // wake demuxer, getting our callback called, which sets quit flag
   sp.wake(); 
   // wait for quit flag to be signalled by exiting event thread
   finished.wait_until_true();
   // event thread exited
}

/*
// blocks until demuxer/event thread exits
void
wdemux_quitter::quit(iocp_demuxer* demux)
{
  //fprintf(stderr, "wdemux_quitter::quit\n");
  
  // install self piper in iocp demuxer, along withour callback.
  sp.install(demux, this);
  sp.wake(); // wake the demuxer
  fprintf(stderr, "wdemux_quitter::quit waiting on finished flag\n");
  finished.wait_until_true();
  fprintf(stderr, "wdemux_quitter::quit exiting\n");
} 

void
wdemux_quitter::callback(demuxer* d)
{
  fprintf(stderr, "wdemux_quitter got called back by demuxer (%p)!\n", d);
  // install quit flag in demuxer
  d->set_quit_flag(&finished);
}
*/

} }

@h=tangler('demux/demux_self_piper.hpp')
@select(h)

#ifndef __FLX_DEMUX_SELF_PIPER_H__
#define __FLX_DEMUX_SELF_PIPER_H__

#include <flx_demux_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// there's no standard posix_socketio_wakeup, could be handy. could also
// perhaps use it here? this is a pipe, not a socket. not sure if recv nor
// send work on it, besides want to read an unlimited amount of redundant data.
class DEMUX_EXTERN selfpipe_wakeup : public socket_wakeup {
public:
  demux_callback* cb; // optional callback

  virtual void wakeup(posix_demuxer& demux);
};

class DEMUX_EXTERN auto_fd {
public:
    int fd;

    auto_fd();
    ~auto_fd();
};

// make portable here? make part of the wakeup obj?
class DEMUX_EXTERN pipe_pair {
  // self pipe trick!!! fd[0] = read end, fd[1] = write end.
  auto_fd         fds[2];
public:
  pipe_pair();
  // void read_byte(); // done for us by wakeup obj.
  void write_byte();
  int get_read_end();
};

// wakes a POSIX demuxer, for when you want some kind of attention
// todo: make portable
class DEMUX_EXTERN self_piper {
    pipe_pair       pp;
    selfpipe_wakeup spw;
public:
    void install(demuxer* demux, demux_callback* cb = 0);
    void wake();
};

}} // namespace demux, flx

#endif
@h=tangler('demux/demux_self_piper.cpp')
@select(h)

#include "demux_self_piper.hpp"
#include <stdio.h>              // printf, perror
#include <unistd.h>             // pipe for self-pipe trick.
#include <assert.h>

namespace flx { namespace demux {

auto_fd::auto_fd()
{
    fd = -1;        // invalid
}

auto_fd::~auto_fd()
{
    if(-1 == fd) return;

    if(close(fd) == -1)
        perror("auto fd close");
}

void
self_piper::install(demuxer* d, demux_callback* cb)
{
    //fprintf(stderr, "installing self piper in %p with cb=%p\n", d, cb);
    posix_demuxer* demux = static_cast<posix_demuxer*>(d);
    spw.s = pp.get_read_end();
    spw.cb = cb;

    int res = demux->add_socket_wakeup(&spw, PDEMUX_READ);
    assert(-1 != res);
}

// wake the demuxer referenced in install
void
self_piper::wake()
{
    // fprintf(stderr, "self_piper::wake\n");
    pp.write_byte();
}

// currently setup to not see the self piper
/*
void
self_piper::inspect(int s)
{   
    // lets wake the demuxer by writing to our end of the pipe
    // lets also not add redundant select wakes for our own selfpipe, as
    // we know it's adding whilst not in select. Is that clear?
    if(s != fds[0].fd) wake();
}
*/

void
selfpipe_wakeup::wakeup(posix_demuxer& demux)
{   
    // fprintf(stderr, "selfpipe wakeup: read the pending byte and re-arm\n");
    // not using the pipe pair because it doesn't know that it's part of
    // one. not to worry.
    ssize_t         nbytes;
    char            b;
    
    // if this were read then this fn would work with non-sockets
    // EH? It IS read.
    nbytes = read(s, &b, 1);
    
    if(nbytes == -1) perror("read");
    
    // fprintf(stderr, "GOT: %li, %x\n", nbytes, b);
    assert(nbytes == 1 && b == 1);

    // callback!
    if(cb) cb->callback(&demux);
    
    // add self back! this happens even when we're quitting, but that
    // doesn't seem to matter.
    // fprintf(stderr, "selfpiper rearming\n");
    int res = demux.add_socket_wakeup(this, PDEMUX_READ);
    assert(-1 != res);
}

pipe_pair::pipe_pair()
{
  // fprintf(stderr, "creating pipe for self-pipe trick\n");

  int         self_pipe_fds[2];
  if(pipe(self_pipe_fds) == -1)
  {
      perror("ts_select_demuxer::self_pipe");
      throw -1;
  }

  // fprintf(stderr, "self pipe fds: read: %i, write: %i\n",
  //  self_pipe_fds[0], self_pipe_fds[1]);

  fds[0].fd = self_pipe_fds[0];
  fds[1].fd = self_pipe_fds[1];
}

// never gets called.
/*
void
pipe_pair::read_byte()
{
  ssize_t         nbytes;
  char            b;
    
  // if this were read then this fn would work with non-sockets
  // EH? It IS read.
  nbytes = read(fds[0].fd, &b, 1);  // read end of the pipe
    
  if(nbytes == -1) perror("read");
    
  // fprintf(stderr, "GOT: %li, %x\n", nbytes, b);
  assert(nbytes == 1 && b == 1);
}
*/

void
pipe_pair::write_byte()
{
    char    b = 1;
    ssize_t nbytes;
    // is this blocking? I guess it has to be...
    nbytes = write(fds[1].fd, &b, 1);       // wake up, jeff!

    // fprintf(stderr, "self_piper::wake write returned: %i\n", nbytes);

    if(-1 == nbytes) perror("pipe_pair::write_byte");
    assert(1 == nbytes);
}

int
pipe_pair::get_read_end()
{
  return fds[0].fd;
}

} }

@h=tangler('demux/demux_wself_piper.hpp')
@select(h)
#ifndef __FLX_DEMUX_WSELF_PIPER_H__
#define __FLX_DEMUX_WSELF_PIPER_H__

#include <flx_demux_config.hpp>
#include "demux_overlapped.hpp"  // I use readfile control block
#include "demux_wself_piper.hpp"

namespace flx { namespace demux {

class DEMUX_EXTERN auto_handle {
public:
  HANDLE h;
  
  auto_handle();
  ~auto_handle();
};

// win32 self pipe trick (what a pain!)
class DEMUX_EXTERN wpipe_pair {
  enum { READ_END, WRITE_END };
  // HANDLE pipe[2];  // 0 = read end, 1 = write end
  auto_handle pipe[2];
public:
  wpipe_pair();

  void write_byte();
  HANDLE get_read_end() { return pipe[READ_END].h; }
};

// use a winfileio_control_block to install a nonblocking ReadFile on the
// read end of the pipe pair. when we get a byte we can execute whatever
// the user wanted which for win32 which seems to be naturally responsive
// to new sockets/handles. demux quit will probably be the only operation
// needed.
class DEMUX_EXTERN wself_piper_wakeup : public winfileio_control_block
{
  char the_byte;

public:
  // possibly null, if not, called on iocp_op_finished
  demux_callback* cb; 

  // the demuxer. doesn't actually get passed by iocp_op_finished
  iocp_demuxer* d;  


  wself_piper_wakeup();

  // detect when single byte read has finished and exec callback,
  // re-arming.
  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);

  void arm();
};

// at the very least, the read end must be nonblocking and associated
// with the iocp.
class DEMUX_EXTERN wself_piper {
  wpipe_pair pp;
  wself_piper_wakeup spw;
public:
  void install(demuxer* demux, demux_callback* cb = 0);
  void wake(); // wakes demuxer which calls callback
};

} } // demux, flx

#endif

@h=tangler('demux/demux_wself_piper.cpp')
@select(h)

#include "demux_wself_piper.hpp"
#include <stdio.h>

namespace flx { namespace demux {

auto_handle::auto_handle()
{
  h = INVALID_HANDLE_VALUE;
}

auto_handle::~auto_handle()
{
  if(INVALID_HANDLE_VALUE == h) return; // done

  if(!CloseHandle(h))
    fprintf(stderr, "auto CloseHandle failed: %i\n", GetLastError());
}

wpipe_pair::wpipe_pair()
{
  // fprintf(stderr, "wpipe CTOR\n");
  // made bufsize 1 as we only ever read and write 1 byte at a time

  // looks like I can't use anonymous pipes with iocp. will have to
  // use a specially setup named pipe - one that allows repetitions...
  // this doesn't sound good.
  const char* pname = "\\\\.\\pipe\\flx_iocp_quitter";

  // don't actually need duplex, nor those buffers. 1 byte at a time suffices
  // I probably don't need both ends to be marked as nonblocking either, should
  // only need the read end nonblocking.

  // create pipe
  pipe[READ_END].h = CreateNamedPipe(pname,
   PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
   PIPE_TYPE_BYTE, 1, 256, 256, 0, NULL);

  if(INVALID_HANDLE_VALUE == pipe[READ_END].h)
  {
    fprintf(stderr, "couldn't create named pipe: %i\n", GetLastError());
    throw -1;
  }

  // this is the part that I don't like - this pipe's name isn't unique
  // and so theoretically another iocp quitter could join here. a race!

  // connect to it. note that overlapped isn't needed for write end as
  // we want to block.
  pipe[WRITE_END].h = CreateFile(pname, FILE_READ_DATA | FILE_WRITE_DATA,
    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

  if(INVALID_HANDLE_VALUE == pipe[WRITE_END].h)
  {
    fprintf(stderr, "failed to open named pipe: %i\n", GetLastError());
    throw -1;
  }

  // anonymous pipes can't be made nonblocking/iocpable on windows!
  // What a shame!
/*
  if(!CreatePipe(&pipe[READ_END], &pipe[WRITE_END], NULL, 1))
  {
    fprintf(stderr, "wpipe_pair CreatePipe failed: %i\n", GetLastError());
    throw -1;
  }
*/ 
}

void
wpipe_pair::write_byte()
{
  // I think I want a blocking write here.
  char  b = 1;
  DWORD bytes_written;
  // last arg is overlapped pointer, unused, we want to block.
  if(!WriteFile(pipe[WRITE_END].h, &b, 1, &bytes_written, NULL))
    fprintf(stderr, "wpipe_pair failed to write byte: %i\n",
      GetLastError());
}

void
wself_piper::install(demuxer* d, demux_callback* cb)
{
  fprintf(stderr, "wself_piper::install(%p, %p)\n", d, cb);
  iocp_demuxer* demux = static_cast<iocp_demuxer*>(d);

  // make read end non blocking and associate with iocp
  HANDLE read_end = pp.get_read_end();

#if 0
  // make the anonymous pipe non blocking. this function is for named pipes,
  // but I've heard talk that it works for anon pipes too. Nope, doesn't work.
  DWORD pipe_mode = PIPE_NOWAIT;
  if(!SetNamedPipeHandleState(read_end, &pipe_mode, NULL, NULL))
  {
    fprintf(stderr, "SetNamedPipeHandleState failed: %i\n", GetLastError());
    return; // not much to be done here.
  }
#endif

  if(0 != demux->associate_with_iocp(read_end, NULL))
  {
    fprintf(stderr, "failed to install self pipe in IOCP!!!\n");
    return; // error code?
  }

  // copy into the self pipe wakeup, for its later use.
  spw.d = demux;
  spw.cb = cb;
  spw.file = read_end;

  fprintf(stderr, "initial self pipe arm\n");
  spw.arm();
}

// wakes demuxer
void
wself_piper::wake() 
{
  fprintf(stderr, "wself_piper::wake - write a byte\n");
  pp.write_byte();
}

wself_piper_wakeup::wself_piper_wakeup()
  // configure the control block for ReadFile on the read end pipe
  // will set pipe handle later, read = true
  : winfileio_control_block(INVALID_HANDLE_VALUE, NULL, 0, true),
    cb(0), d(0)
{
  // I'll probably need to reset the byte address
  fprintf(stderr, "SET UP THE PIPE HANDLE!\n");
}

// at this point the byte has already been read. we want to re-arm for future
// wakeups.
void
wself_piper_wakeup::iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
{
  fprintf(stderr, "wself_piper_wakeup::iocp_op_finished\n");
  fprintf(stderr, "nbytes=%i, err=%i\n", nbytes, err);
  fprintf(stderr, "about to callback %p(%p)\n", cb, d);

  if(cb) cb->callback(d);

  arm();  // re-arm
}

void
wself_piper_wakeup::arm()
{
  // exec another nonblocking ReadFile on read end of pipe
  fprintf(stderr, "wself_piper_wakeup::arm\n");
  pb.buffer = &the_byte;
  pb.buffer_size = 1;
  pb.bytes_written = 0;
  if(start_overlapped())
    fprintf(stderr, "WARNING: wslef_pipe install completed immediately\n");
}

} }

@h=tangler('demux/demux_poll_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_POLL_DEMUXER_H__
#define __FLX_DEMUX_POLL_DEMUXER_H__
    
#include <flx_demux_config.hpp>
#include "demux_posix_demuxer.hpp"
    
// not re-entrant

namespace flx { namespace demux {

class DEMUX_EXTERN poll_demuxer : public posix_demuxer {
  void*  fd_array;    // make him stop! 
  void*  sv_array;
    
  virtual void get_evts(bool poll);
public:
  poll_demuxer();
  virtual ~poll_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, int flags);

  void get_arrays(void** fds, void** svs);
  int dopoll(void* infds, bool poll_flag);    // returns nevents
  void process_evts(void* infds, void* svs, int nevts);
};  
    
} }
#endif

@h=tangler('demux/demux_poll_demuxer.cpp')
@select(h)
#include <stdio.h>      // my friend printf
#include <poll.h>
#include <assert.h>
#include "demux_poll_demuxer.hpp"

#include <vector>

namespace flx { namespace demux {

using namespace std;
  
typedef vector<socket_wakeup*> sockvec;
typedef vector<struct pollfd> fdvec;
  
#define FDS ((fdvec*)fd_array)
#define SOCS ((sockvec*)sv_array)
  
// be aware that under os x 10.3 (and other systems?), poll is a thin
// user level layer on top of select and so of no real advantage.
// the select emulation doesn't seem to give POLLHUP errs, either.
// under 10.4 poll doesn't appear to be calling select, so I guess it's
// all good.
  
poll_demuxer::poll_demuxer()
  : fd_array(0), sv_array(0)
{
  // fprintf(stderr, "poll_demuxer ctor\n");
} 
    
poll_demuxer::~poll_demuxer()
{ 
  // fprintf(stderr, "poll_demuxer dtor\n");
  if(SOCS) delete SOCS;
  if(FDS) delete FDS;
}

// breaking up for a thread safe impl
void
poll_demuxer::get_arrays(void** fds, void** svs)
{
  *fds = fd_array; 
  *svs = sv_array;
  
  fd_array = 0;
  sv_array = 0;
}

// returns nevents
int
poll_demuxer::dopoll(void* infds, bool poll_flag)
{
  fdvec*    fds_copy = (fdvec*)infds;

  if(!fds_copy)
  {
    if(!poll_flag) fprintf(stderr, "Warning ::poll(\\inf) on zero fds!\n");
    return 0;
  }
  
  struct pollfd*  fds = &(*fds_copy)[0];
  // I sometimes end up with nothing to watch in poll mode 
  // this type doesn't seem to exist for the 10.3 emulated poll.
  unsigned long nfds = (*fds_copy).size();
  // nfds_t  nfds = (*fds_copy).size();
  int      nevts;
  
  // fprintf(stderr, "calling ::poll with %p*%i fds\n", fds, nfds);
  // -1 for timeout means wait indefinitely 
  nevts = ::poll(fds, nfds, (poll_flag) ? 0 : -1);
  
  if(-1 == nevts)
  { 
    perror("poll_demuxer::get_evts");
    return 0;
  }
  
  return nevts;    // zero => timeout
}

// processes events, calls callbacks, deletes fds & svs upon completion.
// Seems a bit busy, no?
void
poll_demuxer::process_evts(void* infds, void* svs, int nevts)
{ 
  // Optimisation: when no events (due to timeout) and our fds
  // are null (nothing changed in the meantime), just set the
  // fd and svs members to the incoming ones and return
  
  // fprintf(stderr, "poll::process_evts: %i, %p\n", nevts, fd_array);
  
  if(0 == nevts && !fd_array)
  { 
    // fprintf(stderr, "Optimising by resetting arrays!\n");
    assert( !sv_array );  // keep in sync
    fd_array = infds;
    sv_array = svs;
    return;
  }

  fdvec*    fds_copy = (fdvec*)infds;
  sockvec*  socs_copy = (sockvec*)svs;

  struct pollfd*  fds = &(*fds_copy)[0];
  unsigned long nfds = (*fds_copy).size();
  // nfds_t  nfds = (*fds_copy).size();

  // sanity check. looks like read and write count as 1 each
  int    evts_encountered = 0;

  // examine all fds for signs of life. try early out with nevts?
  // for(nfds_t i = 0; i < nfds; i++, fds++)
  for(unsigned long i = 0; i < nfds; i++, fds++)
  {
    // fprintf(stderr, "fds[%i]->revents=%x\n", i, fds->revents);

    socket_wakeup* sv = (*socs_copy)[i];

    // accumulate bit field of what we got
    // don't touch original bits, we might have to restore them
    int  wakeup_flags = 0;

    bool    wake = false;

    // it might be possible to get both a read & write event...
    // in which case I should take out the else below
    if(fds->revents & POLLIN)                // I think this is how you do it
    {
          // fprintf(stderr,"POLLIN for %p->%i\n", sv, sv->s);
      wakeup_flags |= PDEMUX_READ;
      wake = true;
      evts_encountered++;
    }

    if(fds->revents & POLLOUT)
    {
      // fprintf(stderr,"POLLOUT for %p->%i\n", sv, sv->s);
      wakeup_flags |= PDEMUX_WRITE;
      wake = true;
      evts_encountered++;
    }

    // check here for the unsolicited POLLERR, POLLHUP and POLLNVALs
    if(fds->revents & POLLERR)
    {
      fprintf(stderr, "POLLERR for %p->%i\n", sv, sv->s);
      wake = true;    // good to do?
    }

    // device has been disconnected. this and POLLOUT are mutually exclusive.
    // a stream can never be writeable again if a hangup has occured.
    // I've seen POLLHUPs come in for shutdown(s, 1). In this case you want
    // the wakeup, at least if you were waiting to write. POLLHUPs also seem
    // to be the message/wake up when reading from a connection that has
    // closed: you get the remaining bytes, but via POLLHUP rathern POLLOUT.
    // perhaps not worth printing, seeing as this usage is quite common
    if(fds->revents & POLLHUP)
    {
      fprintf(stderr, "POLLHUP for %p->%i\n", sv, sv->s);
      assert((fds->revents & POLLOUT) == 0);
      wake = true;    // good to do? probably.
    }

    // Invalid fd. We shouldn't ever get that.
    if(fds->revents & POLLNVAL)
    {
      fprintf(stderr, "POLLNVAL for %p->%i\n", sv, sv->s);
      wake = true;    // good to do?
    }

    if(wake)
    {   
      // 1-1 wakeups with add_sockets
      // be aware that callback may add back...
      sv->wakeup_flags = wakeup_flags;
      sv->wakeup(*this); 
    }
    else
    {
      // reinstall for the next iteration. note that we keep a copy
      // of the flags in sv->wakeup_flags, set on adding. that belongs
      // to us so there should be no problem there.
      //fprintf(stderr, "poll::readding: %i, %x\n",
      //  sv->s, sv->wakeup_flags);
      if(add_socket_wakeup(sv, sv->wakeup_flags) == -1)
        fprintf(stderr, "poll re-add finished immediately!?!\n");
    }
  }

  // keep the bastards honest
  if(evts_encountered != nevts)
  { 
    fprintf(stderr, "poll seen/nevts mismatch: %i/%i\n",
      evts_encountered, nevts);
  }
  
  // delete all here.
  delete fds_copy;
  delete socs_copy;
}


// poll is the call, call the bool poll_flag
void
poll_demuxer::get_evts(bool poll_flag)
{ 
  // fprintf(stderr, "poll_demuxer::get_evts\n");
  void    *fds, *svs;
  int      nevts;
  
  get_arrays(&fds, &svs);    // we now own them. must call process_evts
                // to give them back.
  
  nevts = this->dopoll(fds, poll_flag);
  
  // don't shortcut based on nevts being zero - pass it on to process_evts
  // it recongnises the optimisation opportunity uation and handles it,
  // which has the advantage of benefiting the threadsafe version too.
  process_evts(fds, svs, nevts);
}

// precondition: not currently in get_evts (not reentrant)
int
poll_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // fprintf(stderr, "poll::add_socket_wakeup: %p->%i, %x\n",
  //  sv, sv->s, flags);

  if(!FDS)
  {
    // fprintf(stderr, "creating fds and svns\n");
    assert(SOCS == NULL);    // both should be null or non null, no mix

    fd_array = new fdvec;    // FDS
    sv_array = new sockvec;    // SOCS
  }

  // add to array
  struct pollfd  fd;
  
  // note that we keep a copy of the flags, because we often have to
  // copy the wakeups back that haven't had activity
  sv->wakeup_flags = flags;
  
  fd.fd = sv->s;
  fd.events = 0;
  // set on output, but in the ambiguous case of a poll that returns due
  // to timeout what would it be? If I can guarantee 0, then I can use the
  // same piece of code to re-add the fds in the thread safe version.
  fd.revents = 0;
  
  if(flags & PDEMUX_READ) fd.events |= POLLIN;
  if(flags & PDEMUX_WRITE) fd.events |= POLLOUT;
  
  // don't bother setting  POLLERR or POLLHUP. They're output (revents) only.
  // is the same true for epoll_demuxer? I'd say so...
  
  // fd.revents is set on output by ::poll
  // fprintf(stderr, "turning all revents bits on to test 0 output\n");
  // fd.revents = -1;
  
  assert(0 != fd.events);
  
  // add to array along with sv pointer
  FDS->push_back(fd);
  SOCS->push_back(sv);
  
  return 0;      // there'll be a wakeup
}

} }

@h=tangler('demux/demux_ts_poll_demuxer.hpp')
@select(h)
#ifndef FLX_DEMUX_TS_POLL_DEMUXER_H
#define FLX_DEMUX_TS_POLL_DEMUXER_H

// thread safe version of poll_demuxer

#include "demux_poll_demuxer.hpp"
#include "demux_self_piper.hpp"     // self pipe trick
#include "pthread_mutex.hpp"

namespace flx { namespace demux {

class ts_poll_demuxer : public posix_demuxer {
  // lock
  flx::pthread::flx_mutex_t    ham_fist;
  // protects this little fella here.
  poll_demuxer    demux;

  self_piper      sp;
protected:
  virtual void    get_evts(bool poll);
public:
  ts_poll_demuxer();
  ~ts_poll_demuxer();

  virtual int     add_socket_wakeup(socket_wakeup* sv, int flags);

  // oops! need to correctly get/set the quit flag
  virtual demux_quit_flag* get_quit_flag() { return demux.get_quit_flag(); }
  virtual void set_quit_flag(demux_quit_flag* f) { demux.set_quit_flag(f); }
};

}} // namespace demux, flx

#endif

@h=tangler('demux/demux_ts_poll_demuxer.cpp')
@select(h)
#include "demux_ts_poll_demuxer.hpp"
#include <stdio.h>

namespace flx { namespace demux {

ts_poll_demuxer::ts_poll_demuxer()
{
  //fprintf(stderr, "ts_poll_demuxer installing self-piper\n");
  // install self pipe trick.
  sp.install(&demux);
}

ts_poll_demuxer::~ts_poll_demuxer()
{
  //fprintf(stderr, "ts_polling asking thread to quit\n");
  async_quit();  // get async waiting thread to stop waiting
  //fprintf(stderr, "ts_poll async quit finished\n");
}

void
ts_poll_demuxer::get_evts(bool poll)
{   
  void  *fds, *svs;
    
  // copy args under lock
  { 
    flx::pthread::flx_mutex_locker_t  locker(ham_fist);
    demux.get_arrays(&fds, &svs);  // the arrays are now mine 
    // lock released
  } 

  // do the poll
  int  nevts = demux.dopoll(fds, poll);

  // regardless of the number of events, I have to copy the pieces back
  // under lock tutelage
  { 
    flx::pthread::flx_mutex_locker_t  locker(ham_fist);
    demux.process_evts(fds, svs, nevts);
    // lock released
  } 
}

// thread safe overloaded functions follow. all acquire the lock
// then call the unthreadsafe version of the function. nice!
int
ts_poll_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // fprintf(stderr, "ts_poll::add_sock(%i, %x)\n", sv->s, flags);
  flx::pthread::flx_mutex_locker_t  locker(ham_fist);

  int  res = demux.add_socket_wakeup(sv, flags);
  // I wouldn't touch the sv after this.

  if(-1 != res) sp.wake();

  return res;
}
}}
