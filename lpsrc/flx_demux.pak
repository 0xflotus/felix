@head(1,'demux')
#@h=tangler('tmp/flx_demux_config.hpp')
#@select(h)
#// This is a fake flx_demux_config.h to be used at config time, before
#// the rtl proper exists. It contains just enough info to compile
#// a few of the demuxers.
##define DEMUX_EXTERN

@h=tangler('rtl/flx_demux_config.hpp')
@select(h)
#ifndef __FLX_DEMUX_CONFIG_H__
#define __FLX_DEMUX_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_DEMUX
#define DEMUX_EXTERN FLX_EXPORT
#else
#define DEMUX_EXTERN FLX_IMPORT
#endif
#endif


@h=tangler('demux/flx_demux.hpp')
@select(h)
#ifndef __FLX_DEMUX_H__
#define __FLX_DEMUX_H__
#include <flx_demux_config.hpp>
#include "pthread_thread.hpp"

#if FLX_WIN32
 #include "demux_iocp_demuxer.hpp"
 namespace flx { namespace demux { 
   typedef iocp_demuxer flx_demuxer_t; 
 }}
#elif FLX_HAVE_KQUEUE_DEMUXER
 #include "demux_kqueue_demuxer.hpp"
  namespace flx { namespace demux {
    typedef kqueue_demuxer flx_demuxer_t; 
  }}
#elif FLX_HAVE_EVTPORTS
 #include "demux_evtport_demuxer.hpp"
  namespace flx { namespace demux {
    typedef evtport_demuxer flx_demuxer_t; 
  }}
#elif FLX_HAVE_EPOLL
 #include "demux_epoll_demuxer.hpp"
  namespace flx { namespace demux {
    typedef epoll_demuxer flx_demuxer_t; 
  }}
#elif FLX_HAVE_POLL
 // NB!: on osx 10.3 poll exists, but is a poor cousin emulation layer on
 // top of select. however, 10.3 has kqueues (above), so should be ok...
 #include "demux_ts_poll_demuxer.hpp"
  namespace flx { namespace demux {
    typedef ts_poll_demuxer flx_demuxer_t; 
  }}
#else
 #include "demux_ts_select_demuxer.hpp"
  namespace flx { namespace demux {
    typedef ts_select_demuxer flx_demuxer_t; 
  }}
#endif


namespace flx { namespace demux {
DEMUX_EXTERN flx_demuxer_t * make_std_demuxer();
}}

#endif

@h=tangler('demux/flx_demux.cpp')
@select(h)
#include "flx_demux.hpp"
#include <stdio.h>
#include <stdlib.h>

namespace flx { namespace demux {

// the thread which runs the demuxer polling loop
static void
pthread_thread(void* udat)
{
    demuxer*    d = (demuxer*)udat;

    while(1)
    {
        //fprintf(stderr, "ETHREAD ABOUT TO WAIT\n");
        d->wait();          // this does it
        //fprintf(stderr, "ETHREAD CHECKING QUIT FLAG\n");
        demux_quit_flag* f = d->get_quit_flag();
        if(f)
        {
          // got a quit flag - this is the very last thing we do before
          // exiting. don't use the demuxer after this as it's probably been
          // destructed.
          //fprintf(stderr, "ETHREAD GOT QUIT FLAG, SIGNALLING AND EXITING\n");
          f->signal_true();
          // in the case of a system takedown there's no guarantee that
          // anything after the signal_finish will be run at all, so this
          // is not a good place to put anything important.
          break;  // outta here
        }
    }
    //fprintf(stderr, "ETHREAD EXITING\n");
    // fprintf(stderr, "proto_async was asked to quit...\n");
}

flx_demuxer_t *
make_std_demuxer()
{     
  flx_demuxer_t *d = new flx_demuxer_t();
  pthread::flx_thread_t ethread;
  if(ethread.init(pthread_thread, d, NULL) == -1) 
  {
    fprintf(stderr,"Proto_async thread init failure\n");
    exit(1);
  }
  return d;
}
}}

@h=tangler('lib/flx_demux.flx')
@select(h)
#import <flx.flxh>
module Demux
{
  type demuxer = "flx::demux::flx_demuxer_t*"
    requires header '#include "flx_demux.hpp"'
  ;
  gen mk_sys_demux: 1->demuxer = "flx::demux::make_std_demuxer()";
  val sys_demux =  mk_sys_demux();
}

@h=tangler('demux/demux_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_DEMUXER_H__
#define __FLX_DEMUX_DEMUXER_H__
#include <flx_demux_config.hpp>

namespace flx { namespace demux {

struct sel_param {
  char*   buffer;           // set on input
  long    buffer_size;        // set on input
  long    bytes_written;        // set on input and output

  bool    finished() { return bytes_written == buffer_size; }
};

// rename ...
// read/write flags - they're no longer mutually exclusive
enum { PDEMUX_READ = 1, PDEMUX_WRITE = 2, PDEMUX_EOF=4, PDEMUX_ERROR=8 };

// base class/hook for implementing thread safe multithreaded demux quit
// not that useful for single threaded implementations.
class DEMUX_EXTERN demux_quit_flag
{
public:
  virtual void signal_true() = 0; // = signal finish
  virtual ~demux_quit_flag() {}
};

// ********************************************************
/// Demux base.
// ********************************************************
class DEMUX_EXTERN demuxer {
protected:
  // wait for outstanding events. may return before given events, so
  // check your conditions. I've turned of all the timeouts that cause
  // this, but don't rely on it!
  // FACTOR. Give poll a greedy interface
  virtual void  get_evts(bool poll) = 0;

  // for clean async takedown. contents guaranteed to be valid until
  // quit_flag->signal_true is called
  demux_quit_flag* quit_flag; 
public:
  demuxer() : quit_flag(0) {}
  virtual ~demuxer() {}

  void wait() { get_evts(false); }
  void poll() { get_evts(true); }

  // ask users of demuxer to exit. not guarded. be sure to either set & get
  // this flag from only one thread (with a wait/wakeup callback - see
  // self_piper) or by using a memory barrier.
  virtual demux_quit_flag* get_quit_flag() { return quit_flag; }
  virtual void set_quit_flag(demux_quit_flag* f) { quit_flag = f; }
};

// base class for callback from demuxer. useful when used in conjuction
// with the self piper for implementing threadsafe demuxer quit and
// guaranteeing responsiveness to new sockets.
// run in the same thread that called d->wait/poll.
class DEMUX_EXTERN demux_callback {
public:
  virtual void callback(demuxer* d) = 0;
  virtual ~demux_callback() {}
};

}} // namespace demux, flx
#endif  /* __DEMUXER__ */

@h=tangler('demux/demux_timer_queue.hpp')
@select(h)
#ifndef __FLX_DEMUX_TIMER_QUEUE_H__
#define __FLX_DEMUX_TIMER_QUEUE_H__

#include <flx_demux_config.hpp>

namespace flx { namespace demux {

// trying to factor out code to share between pc & posix versions

// class sleep_task : public worker_task
// may not need time in here - just the wakeup - something I surely have
// somewhere else.
class DEMUX_EXTERN sleep_task
{
public:
    virtual ~sleep_task() {}

    virtual void fire() = 0;
};

class DEMUX_EXTERN timer_queue
{
public:
    virtual ~timer_queue() {}    

    virtual void add_sleep_request(sleep_task* st, double delta) = 0;
    virtual void add_abs_sleep_request(sleep_task* st, double when) = 0;

    // bad design - this is actually implemented in the descendent classes,
    // which limits the number of such classes probably to one.
    static void get_time(double& t);        // in seconds from some ref pt
};

DEMUX_EXTERN timer_queue *mk_timer_queue();

}} // namespace demux, flx

#endif

@h=tangler('demux/demux_demuxer.cpp')
@select(h)
#include "demux_demuxer.hpp"

// nothing here atm ..

@h=tangler('demux/demux_quitter.hpp')
@select(h)

#ifndef __FLX_DEMUX_QUITTER_H__
#define __FLX_DEMUX_QUITTER_H__

#include <flx_demux_config.hpp>
#include "demux_demuxer.hpp"  // demuxers

#if FLX_WIN32
#include "demux_wself_piper.hpp" // win32 self piper
#else
#include "demux_self_piper.hpp" // posix self piper
#endif

#include "pthread_waitable_bool.hpp"

namespace flx { namespace demux {

// quits a demuxer 
class DEMUX_EXTERN demux_quitter
	: public demux_callback, public demux_quit_flag {
  // self pipes for getting demuxer attention
#if FLX_WIN32
  wself_piper sp;
#else
  self_piper sp;
#endif
  pthread::waitable_bool finished;  // initially false
  void callback(demuxer* demux); // called back by demuxer in event thread.
  virtual void signal_true(); // signal finish, from demux_quit_flag
public:
  void quit(demuxer* demux); // blocks until event thread exits
};

} }

#endif

@h=tangler('demux/demux_quitter.cpp')
@select(h)
#include "demux_quitter.hpp"
#include <stdio.h>

namespace flx { namespace demux {

// this is called by the demuxer, from its event thread.
// for this reason it can modify the demuxer with tranquility, asking it
// to quit, by setting the "quit flag". this is an obj with a virtual 
// signal_true method which the event thread/demuxer user calls, in effect
// promising to never interact with that demuxer ever again. what to do with
// the wakeups that demuxer still knows about is unclear, and with most
// demuxer impls there isn't even a way to know which wakeups are outstanding.
// it hasn't been a problem yet.
void
demux_quitter::callback(demuxer* demux)
{
  //fprintf(stderr, "quitter callback\n");
  demux->set_quit_flag(this);
}

// call this last thing before event thread exit, or more explicitly
// call it before never touching the given demuxer ever again. see?
// it is linked to demuxers. a better name for this method would be
// i_promise_to_never_use_the_associated_object_ever_again_clear_question_mark
void
demux_quitter::signal_true() // signal finish, from demux_quit_flag
{
  finished.signal_true(); 
  // do NOTHING here, we've probably already been destructed, mr anderson.
  // I told you, my name is "neil".
}

void
demux_quitter::quit(demuxer* demux)
{
   // fprintf(stderr, "trying to quit demuxer...\n");
   // install self piper, with our callback
   sp.install(demux, this);
   // wake demuxer, getting our callback called, which sets quit flag
   // NB: this requires that there BE another thread.
   sp.wake(); 
   // wait for quit flag to be signalled by exiting event thread
   finished.wait_until_true();
   // event thread exited
}

} }

@head(2,"OS specific demux codes")
@include_file("flx_posix_demux.ipk")
@include_file("flx_epoll_demux.ipk")
@include_file("flx_evtport_demux.ipk")
@include_file("flx_kqueue_demux.ipk")
@include_file("flx_poll_demux.ipk")
@include_file("flx_select_demux.ipk")
@include_file("flx_iocp_demux.ipk")

@include_file("flx_wintimer_demux.ipk")
@include_file("flx_posixtimer_demux.ipk")


