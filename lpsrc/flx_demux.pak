@head(1,'demux')
$Log$
Revision 1.3  2006/02/23 19:33:01  skaller
More fiddling with build system

Revision 1.2  2006/02/22 19:00:04  rfistman
oops, was passing ULONG as ULONG_PTR. Thanks to 64bit compiler for
poinnting this out.

Revision 1.1  2006/02/22 17:36:48  skaller
Rename some files.. more coming. Make RTL modules full .paks

Revision 1.54  2006/02/21 05:46:45  skaller
Fix wrong link flag tag.

Revision 1.53  2006/02/20 09:21:24  skaller
Mingw/nocygwin support

Revision 1.52  2006/02/20 02:16:44  rfistman
removed recursive locks from the threadsafe select demuxer and from
the code in general.

Revision 1.51  2006/02/19 16:04:57  skaller
Win32 build changes..seems to work now

Revision 1.50  2006/02/19 14:02:51  skaller
Windows sys libs with right switches

Revision 1.49  2006/02/18 16:30:48  skaller
More work on new package manager.

Revision 1.48  2006/02/17 09:38:31  skaller

conditionalised recursive mutex (to be removed)
fixed windows lib_requires (added lib prefix)

Revision 1.47  2006/02/16 23:39:11  rfistman
fixed cygwin hang in posix tests. cygwin wakes select with an error flag
when you shutdown a socket. other impls seem to wake select, but with no
error.

Revision 1.46  2006/02/16 15:09:45  skaller
MSVC++ package manager

Revision 1.45  2006/02/16 07:51:40  skaller
Replace pkg-config with a Felix program flx_pkgconfig.
Make sure to build it in a timely manner, since flx script
now depends on it.

Revision 1.44  2006/02/15 10:54:08  skaller
Build time packaging system.

Revision 1.43  2006/02/15 04:10:56  rfistman
working on thread safe select demuxer (ts_select_demuxer). that should
fix cygwin probs. and as yet other undiscovered problems.

Revision 1.42  2006/02/13 05:47:40  rfistman
readded recursive flag to (portable) mutexes

Revision 1.41  2006/02/12 06:51:30  rfistman
added WSAID_CONNECTEX and LPFN_CONNECTEX definitions for ming (nocygwin) target
now conditionally define EAGAIN in posix compat layer because ming seems to
have it.

Revision 1.40  2006/02/11 22:12:30  skaller
Allow assigning constructor index to enums.

Revision 1.39  2006/02/09 21:05:33  skaller
Fixed sdl to use polling.

Revision 1.38  2006/02/09 07:53:27  skaller
Fix windows semaphores.

Revision 1.37  2006/02/07 15:55:06  skaller
Added portable semaphores and a monitor class to demux.

Revision 1.36  2006/02/06 11:05:18  skaller
Timed wait on condition variable.

Revision 1.35  2006/02/06 06:50:01  skaller
Added pthread_cond_timedwait and pthread_cond_uswait functions
to condition variables. The latter is my own invention, it waits
for a specific interval in micro-seconds. The later is more
efficient on Windows when you want to wait for an interval,
since this is the native method. Otherwise you need to first
obtain the time of day, do a nasty calculation .. and then
the timedwait function will undo that, resulting in two
unnecessary and expensive system calls.

Revision 1.34  2006/02/04 11:34:36  skaller
Portable demux stuff, Win32 version

Revision 1.33  2006/02/04 10:35:55  skaller
Portable thread sync stuff

Revision 1.31  2006/02/02 18:52:35  skaller
Reorganise demux a bit

Revision 1.30  2006/01/31 04:29:17  rfistman
added demux level "sleep until" code. Not quite right yet (posix format
of current time in double isn't so good as it's measured from the 70s in
microseconds, so macroscopic sleep amounts get swamped by the magnitude
of "now"), so felix binding coming soon.

Revision 1.29  2006/01/29 07:07:21  skaller
fixed visual studio build after demux merge

Revision 1.28  2006/01/29 05:58:08  rfistman
fixed windows build (ming nocygwin) after merge

Revision 1.27  2006/01/29 02:53:16  rfistman
fixed missing epoll header for linux.:w

Revision 1.26  2006/01/29 02:17:29  rfistman
using latest demux, added epoll to flx_run (for linux). bugs fixed.

Revision 1.25  2006/01/26 10:04:28  rfistman
fixed failure to wake fthread after connects that finish immediately.
this fast connect only ever shows up on solaris, so full marks to them.

Revision 1.24  2006/01/21 23:45:10  rfistman
fixed potential leak and warning in posix_timer_queue constructor

Revision 1.23  2006/01/16 01:25:43  rfistman
factored faio posix accept and connect back demux as control blocks
removed pthread cancel from code - implicit cancel points are no longer used.
instead the threads are convinced to return from their mains via specially
formatted inputs.

Revision 1.22  2006/01/13 05:16:50  rfistman
made worker_fifo portable

Revision 1.21  2006/01/11 01:16:32  rfistman
added win_timer_queue to demux

Revision 1.20  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.

@execfile('config'+os.sep+'config.py')

@h = tangler('config/demux.fpc')
@select(h)
Name: demux
Description: Pre-emptive threading support
Version: $Id$

@if HAVE_MSVC:
   tangle("dlibs: /DEFAULTLIB:libdemux_dynamic /DEFAULTLIB:ws2_32 /DEFAULTLIB:mswsock")
   tangle("slibs: /DEFAULTLIB:libdemux_static /DEFAULTLIB:ws2_32 /DEFAULTLIB:mswsock")
 elif WIN32:
   tangle("dlibs: -ldemux_dynamic -lws2_32 -lmswsock")
   tangle("slibs: -ldemux_static -lws2_32 -lmswsock")
 else:
   tangle("dlibs: -ldemux_dynamic")
   tangle("slibs: -ldemux_static")
Requires: flx

@h = tangler('pkg/demux.py')
@select(h)

DEMUXRTL_INTERFACES = [
 'demux/demux_thread.hpp',        # portable
 'demux/demux_posix_thread.hpp',  # posix
 'demux/demux_win_thread.hpp',    # win32
 
 'demux/demux_win_posix_condv_emul.hpp',         # win32 and posiz
 'demux/demux_mutex.hpp',         # portable
 'demux/demux_condv.hpp',         # portable
 'demux/demux_semaphore.hpp',     # portable
 'demux/demux_monitor.hpp',       # portable
 'demux/demux_sleep_queue.hpp',   # portable
 'demux/demux_work_fifo.hpp',     # portable

 'demux/demux_demuxer.hpp',       # portable
 'demux/demux_posix_demuxer.hpp', # posix
 'demux/demux_timer_queue.hpp',   # portable
 'demux/demux_posix_timer_queue.hpp',   # posix
 'demux/demux_pfileio.hpp',       # posix
 'demux/demux_select_demuxer.hpp',# posix
 'demux/demux_iocp_demuxer.hpp',  # win32 (monolithic)
 'demux/demux_overlapped.hpp',    # win32
 'demux/demux_win_timer_queue.hpp',  # win32
 'demux/demux_kqueue_demuxer.hpp',# osx/bsd
 'demux/demux_evtport_demuxer.hpp',# solaris
 'demux/demux_epoll_demuxer.hpp',# linux (>= 2.6)
 'demux/demux_sockety.hpp',       # posix
 'demux/demux_ts_select_demuxer.hpp',
]

DEMUX_CPPS = [
  "demux/demux_mutex", 
  "demux/demux_condv",
  "demux/demux_semaphore",
  "demux/demux_monitor",
  "demux/demux_sleep_queue",
  "demux/demux_work_fifo",
  "demux/demux_demuxer",
  "demux/demux_win_posix_condv_emul", # portability hackery
  "rtl/flx_ts_collector",
]

POSIX_DEMUX_CPPS = [
  "demux/demux_posix_thread",       # posix
  "demux/demux_posix_demuxer",      # all posix
  "demux/demux_select_demuxer",     # all posix
  "demux/demux_posix_timer_queue",  # posix
  "demux/demux_sockety",            # posix
  "demux/demux_pfileio",            # posix
  'demux/demux_ts_select_demuxer',
]

LINUX_DEMUX_CPPS = [
  "demux/demux_epoll_demuxer",      # Linux 2.6 +
]

SOLARIS_DEMUX_CPPS = [
  "demux/demux_evtport_demuxer",    # solaris
]

WINDOWS_DEMUX_CPPS = [
  "demux/demux_win_thread",       # posix
  "demux/demux_iocp_demuxer",       # windows
  "demux/demux_overlapped",         # windows
  "demux/demux_win_timer_queue",    # windows
]

BSD_DEMUX_CPPS = [
  "demux/demux_kqueue_demuxer",     # osx/bsd
]

EXTRA_SYS_LIBS = ""
if WIN32:
  DEMUX_CPPS = DEMUX_CPPS + WINDOWS_DEMUX_CPPS
  if HAVE_MSVC:
    EXTRA_SYS_LIBS = "/DEFAULTLIB:ws2_32 /DEFAULTLIB:mswsock "
  else:
    # mingw
    EXTRA_SYS_LIBS = "-lws2_32 -lmswsock "


if POSIX:
  DEMUX_CPPS = DEMUX_CPPS + POSIX_DEMUX_CPPS

if LINUX:
  DEMUX_CPPS = DEMUX_CPPS + LINUX_DEMUX_CPPS

if BSD or MACOSX:
  DEMUX_CPPS = DEMUX_CPPS + BSD_DEMUX_CPPS

if SOLARIS:
  DEMUX_CPPS = DEMUX_CPPS + SOLARIS_DEMUX_CPPS
  EXTRA_SYS_LIBS = "-lsocket -lnsl"

cpp_cpps = DEMUX_CPPS
rtl_interfaces = DEMUXRTL_INTERFACES
pkg_requires = ['flx_rtl']
lib_requires = ['libflx'] 
#lib_requires_linkflags = EXTRA_SYS_LIBS
dflags = EXTRA_SYS_LIBS
sflags = EXTRA_SYS_LIBS
iscr_source = ["lpsrc/flx_demux.pak"]

@head(1,"Pre-emptive threads (pthread)")
Note WE say pthread means 'pre-emptive thread' not
merely Posix thread. Confusing on Solaris especially.
However it fits with name fthread for felix threads
which are actually s- (synchronous) or np- (non-preemptive) 
threads.

@head(2,'Posix Thread')
@h=tangler('demux/demux_posix_thread.hpp')
@select(h)
#ifndef __POSIX_THREAD__
#define __POSIX_THREAD__
#include <flx_rtl_config.hpp>
#include <pthread.h>

// auto pthread, because I forget how to deallocate them nicely
// could init in the constructor, but ultimately you don't want the thread
// barging in before you've finished doing other stuff
// Addendum (20051128): doing stdio in turns out to be not very safe.
// I don't know if printf et al are supposed to be thread safe (most impls
// seem to try to be) but I sometimes get deadlocks in ppc64 os x 10.4.2
// with 4.0.1 when printfing to stdout. Nasty.

namespace flx { namespace demux {

// ********************************************************
/// Posix Threads. This class simply wraps the creation
/// and joining of threads. It is not safe.
// ********************************************************

class FLX_RTL_EXTERN flx_thread_t {
  pthread_t   thr;        ///< the thread
  flx_thread_t(flx_thread_t const&); // uncopyable
  void operator=(flx_thread_t const&); // uncopyable
public:
  flx_thread_t();
  ~flx_thread_t();
  int init(void* (*start)(void*), void* udat);
  void join();  
};

/// RAII wrapper for thread class
class FLX_RTL_EXTERN flx_thread_wrapper_t {
  flx_thread_t thread;
  flx_thread_wrapper_t(flx_thread_wrapper_t const&); // uncopyable
  void operator=(flx_thread_wrapper_t const&); // uncopyable
public:
  ~flx_thread_wrapper_t();
  flx_thread_wrapper_t(void* (*start)(void*), void* udat);
};

}}
#endif

@h=tangler('demux/demux_posix_thread.cpp')
@select(h)
#include "demux_posix_thread.hpp"
#include <stdio.h>

namespace flx { namespace demux {
flx_thread_t::flx_thread_t(flx_thread_t const&){} // uncopyable
void flx_thread_t::operator=(flx_thread_t const&){} // uncopyable

int 
flx_thread_t::init(void* (*start)(void*), void* udat)
{
  // fprintf(stderr,"flx_thread_t::init(this=%p, fn=%p, udat=%p)\n",
  //  this, start, udat);

  // default attrs. hope they're good
  pthread_create(&thr, NULL, start, udat);
  return 0;
}

void flx_thread_t::join() { pthread_join(thr, NULL); }

flx_thread_t::~flx_thread_t() { }
flx_thread_t::flx_thread_t() { }

flx_thread_wrapper_t::flx_thread_wrapper_t(flx_thread_wrapper_t const&){} // uncopyable
void flx_thread_wrapper_t::operator=(flx_thread_wrapper_t const&){} // uncopyable

flx_thread_wrapper_t::flx_thread_wrapper_t(void* (*start)(void*), void* udat)
{
  thread.init(start,udat);
}

flx_thread_wrapper_t::~flx_thread_wrapper_t() { thread.join(); }

}}

@head(2,'Windows Thread')
@h=tangler('demux/demux_win_thread.hpp')
@select(h)
#ifndef __WIN_THREAD__
#define __WIN_THREAD__
#include "flx_rtl_config.hpp"
#include <windows.h>

namespace flx { namespace demux {

// ********************************************************
/// Windows Threads.
// ********************************************************

class FLX_RTL_EXTERN flx_thread_t {
  HANDLE    thread;
  flx_thread_t(flx_thread_t const&); // uncopyable
  void operator=(flx_thread_t const&); // uncopyable
public:
  flx_thread_t();
  ~flx_thread_t();
  int init(LPTHREAD_START_ROUTINE, LPVOID lParam);
  void join();
};

/// RAII wrapper for thread class
class FLX_RTL_EXTERN flx_thread_wrapper_t {
  flx_thread_t thread;
  flx_thread_wrapper_t(flx_thread_t const&); // uncopyable
  void operator=(flx_thread_wrapper_t const&); // uncopyable
public:
  ~flx_thread_wrapper_t();
  flx_thread_wrapper_t(LPTHREAD_START_ROUTINE, LPVOID lParam);
};

}}

#endif

@h=tangler('demux/demux_win_thread.cpp')
@select(h)
#include "demux_win_thread.hpp"
#include <stdio.h>

namespace flx { namespace demux {

flx_thread_t::flx_thread_t(flx_thread_t const&){} // uncopyable
void flx_thread_t::operator=(flx_thread_t const&){} // uncopyable


flx_thread_t::flx_thread_t() { }
flx_thread_t::~flx_thread_t() { }

// this should be idempotent
void
flx_thread_t::join()
{
  // Let's try and wait for the thread to finish, however first I have to
  // tell it to finish up.

  DWORD  wait_res = WaitForSingleObject(thread, INFINITE);

  // will this give me my return status? how do I get that?
  if(WAIT_FAILED == wait_res)
  {
    fprintf(stderr,"thread wait failed (%li)\n", GetLastError());
  }

  // I've already tried waiting on the  thread's exit
  if(!CloseHandle(thread))
  {
    fprintf(stderr,"failed to delete thread (%li)\n", GetLastError());
  }
}

// returns -1 on failure with error in GetLastError, 0 if all good.
int
flx_thread_t::init(LPTHREAD_START_ROUTINE fn, LPVOID lParam)
{
  DWORD thread_id = 0;
  thread = (HANDLE)CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)fn, lParam, 0, &thread_id);  
  return 0;
}

flx_thread_wrapper_t::flx_thread_wrapper_t(LPTHREAD_START_ROUTINE f, LPVOID lParam)
{
  thread.init(f,lParam);
}
flx_thread_wrapper_t::~flx_thread_wrapper_t() { thread.join(); }

}}

@head(2,'Portable Thread')
@h=tangler('demux/demux_thread.hpp')
@select(h)
#ifndef __FLX_THREAD__
#define __FLX_THREAD__

#ifdef _WIN32
#include "demux_win_thread.hpp"
#else
#include "demux_posix_thread.hpp"
#endif

#endif

@head(1,"Mutex")
@head(2,'Windows Emulation of Posix Synchronisation primitives')
@h=tangler('demux/demux_win_posix_condv_emul.hpp')
@select(h)
#ifndef __WIN_POSIX_CONDV_EMUL__
#define __WIN_POSIX_CONDV_EMUL__
// Note: no namespaces here!
// See http://www.cs.wustl.edu/~schmidt/win32-cv-1.html

#include "flx_rtl_config.hpp"
#ifdef _WIN32
#include <windows.h>

typedef HANDLE pthread_mutex_t;
typedef void pthread_mutexattr_t; // do NOT use them!
typedef void pthread_condattr_t; // do NOT use them!

struct pthread_cond_t
{
  int waiters_count_;
  // Number of waiting threads.

  CRITICAL_SECTION waiters_count_lock_;
  // Serialize access to <waiters_count_>.

  HANDLE sema_;
  // Semaphore used to queue up threads waiting for the condition to
  // become signaled. 

  HANDLE waiters_done_;
  // An auto-reset event used by the broadcast/signal thread to wait
  // for all the waiting thread(s) to wake up and be released from the
  // semaphore. 

  size_t was_broadcast_;
  // Keeps track of whether we were broadcasting or signaling.  This
  // allows us to optimize the code if we're just signaling.
};

// THIS IS SICK but there ain't no other way in C
#define ETIMEDOUT WAIT_TIMEOUT
// looks like EAGAIN is available in minggw, but not in vs sdk.
#ifndef EAGAIN
#define EAGAIN WAIT_TIMEOUT
#endif

int FLX_RTL_EXTERN pthread_mutex_init (pthread_mutex_t*, const pthread_mutexattr_t*);
int FLX_RTL_EXTERN pthread_mutex_lock(pthread_mutex_t*);
int FLX_RTL_EXTERN pthread_mutex_unlock(pthread_mutex_t*);
int FLX_RTL_EXTERN pthread_mutex_destroy(pthread_mutex_t*);

int FLX_RTL_EXTERN pthread_cond_init (pthread_cond_t*, const pthread_condattr_t*);
int FLX_RTL_EXTERN pthread_cond_destroy(pthread_cond_t*);
int FLX_RTL_EXTERN pthread_cond_wait (pthread_cond_t*, pthread_mutex_t*);
int FLX_RTL_EXTERN pthread_cond_timedwait(pthread_cond_t*, pthread_mutex_t*, struct timespec const*);
int FLX_RTL_EXTERN pthread_cond_uswait(pthread_cond_t*, pthread_mutex_t*, unsigned long us);
int FLX_RTL_EXTERN pthread_cond_signal (pthread_cond_t*); 
int FLX_RTL_EXTERN pthread_cond_broadcast (pthread_cond_t*);


typedef HANDLE sem_t;

int FLX_RTL_EXTERN sem_init(sem_t *sem, int pshared, unsigned int value);
int FLX_RTL_EXTERN sem_wait(sem_t * sem);
int FLX_RTL_EXTERN sem_trywait(sem_t * sem);
int FLX_RTL_EXTERN sem_post(sem_t * sem);
int FLX_RTL_EXTERN sem_getvalue(sem_t * sem, int * sval);
int FLX_RTL_EXTERN sem_destroy(sem_t * sem);

#else
#include <pthread.h>
#include <semaphore.h>
// emulate the native Window functionality
int FLX_RTL_EXTERN pthread_cond_uswait( pthread_cond_t*, pthread_mutex_t*, unsigned long us);
#endif
#endif

@h=tangler('demux/demux_win_posix_condv_emul.cpp')
@select(h)
#include "demux_win_posix_condv_emul.hpp"
#include <assert.h>
#ifdef _WIN32
#include <string.h>

struct timespec {
  unsigned long tv_sec;
  unsigned long tv_nsec;
};

int pthread_mutex_init (pthread_mutex_t *m, const pthread_mutexattr_t*)
{
  *m = CreateMutex(NULL,FALSE,NULL); 
  return 0;
}

int pthread_mutex_lock(pthread_mutex_t *m)
{
  WaitForSingleObject(*m,INFINITE); 
  return 0;
}

int pthread_mutex_unlock(pthread_mutex_t *m)
{
  ReleaseMutex(*m);
  return 0;
}

int pthread_mutex_destroy(pthread_mutex_t *m)
{
  CloseHandle(*m);
  return 0;
}

int 
pthread_cond_init 
(
  pthread_cond_t *cv,
  const pthread_condattr_t *
)
{
  cv->waiters_count_ = 0;
  cv->was_broadcast_ = 0;
  cv->sema_ = CreateSemaphore 
  (
    NULL,       // no security
    0,          // initially 0
    0x7fffffff, // max count .. (I hate limits .. but thats a lot of pthreads)
    NULL        // unnamed
  ); 
  InitializeCriticalSection (&cv->waiters_count_lock_);
  cv->waiters_done_ = CreateEvent 
  (
    NULL,  // no security
    FALSE, // auto-reset
    FALSE, // non-signaled initially
    NULL   // unnamed
  );
  return 0;
}

int 
pthread_cond_destroy(pthread_cond_t *cv)
{
  CloseHandle(cv->sema_);
  CloseHandle(cv->waiters_done_);
  return 0;
}

// returns ETIMEDOUT = WAIT_TIMEOUT
static int
private_cond_wait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex,
  unsigned long ms
)
{
  // Avoid race conditions.
  EnterCriticalSection (&cv->waiters_count_lock_);
  cv->waiters_count_++;
  LeaveCriticalSection (&cv->waiters_count_lock_);

  // This call atomically releases the mutex and waits on the
  // semaphore until <pthread_cond_signal> or <pthread_cond_broadcast>
  // are called by another thread.
  int res = SignalObjectAndWait (*external_mutex, cv->sema_, ms, FALSE);

  // Reacquire lock to avoid race conditions.
  EnterCriticalSection (&cv->waiters_count_lock_);

  // We're no longer waiting...
  cv->waiters_count_--;

  // Check to see if we're the last waiter after <pthread_cond_broadcast>.
  int last_waiter = cv->was_broadcast_ && cv->waiters_count_ == 0;

  LeaveCriticalSection (&cv->waiters_count_lock_);

  // If we're the last waiter thread during this particular broadcast
  // then let all the other threads proceed.
  if (last_waiter)
    // This call atomically signals the <waiters_done_> event and waits until
    // it can acquire the <external_mutex>.  This is required to ensure fairness. 
    SignalObjectAndWait (cv->waiters_done_, *external_mutex, INFINITE, FALSE);
  else
    // Always regain the external mutex since that's the guarantee we
    // give to our callers. 
    WaitForSingleObject (*external_mutex, INFINITE);
  return res;
}

int
pthread_cond_wait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex
)
{
  return private_cond_wait(cv,external_mutex,INFINITE);
}

// Posix is a pain in the butt here
// we have to get the current time and subtract it
// from the target time to get a duration
// the pain is that we probably wanted a duration
// and had to construct a target time by adding it
// to the current time
//
// to fix this we add the native Windows mode (a duration)
// to posix

int
pthread_cond_uswait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex,
  unsigned long us
)
{

  // Windows waits in ms, ours in us
  return private_cond_wait(cv,external_mutex,us * 1000);
}

int
pthread_cond_timedwait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex,
  struct timespec const *abstime
)
{
  unsigned long t1 = abstime->tv_sec * 1000 + abstime->tv_nsec / 1000;
  SYSTEMTIME tod;
  GetSystemTime(&tod);
  FILETIME ft;
  SystemTimeToFileTime(&tod,&ft);
  ULARGE_INTEGER now;  // so we can do some maths
  assert(sizeof(now) == sizeof(ft));
  memcpy(&now, &ft, sizeof(now));
  unsigned long t0 = now.QuadPart / 10; // us now 
  unsigned long timeout = t1>t0 ? t1 - t0 : 0;
  return private_cond_wait(cv,external_mutex,timeout);
}

int
pthread_cond_signal (pthread_cond_t *cv)
{
  EnterCriticalSection (&cv->waiters_count_lock_);
  int have_waiters = cv->waiters_count_ > 0;
  LeaveCriticalSection (&cv->waiters_count_lock_);

  // If there aren't any waiters, then this is a no-op.  
  if (have_waiters)
    ReleaseSemaphore (cv->sema_, 1, 0);
  return 0;
}

int
pthread_cond_broadcast (pthread_cond_t *cv)
{
  // This is needed to ensure that <waiters_count_> and <was_broadcast_> are
  // consistent relative to each other.
  EnterCriticalSection (&cv->waiters_count_lock_);
  int have_waiters = 0;

  if (cv->waiters_count_ > 0) {
    // We are broadcasting, even if there is just one waiter...
    // Record that we are broadcasting, which helps optimize
    // <pthread_cond_wait> for the non-broadcast case.
    cv->was_broadcast_ = 1;
    have_waiters = 1;
  }

  if (have_waiters) {
    // Wake up all the waiters atomically.
    ReleaseSemaphore (cv->sema_, cv->waiters_count_, 0);

    LeaveCriticalSection (&cv->waiters_count_lock_);

    // Wait for all the awakened threads to acquire the counting
    // semaphore. 
    WaitForSingleObject (cv->waiters_done_, INFINITE);
    // This assignment is okay, even without the <waiters_count_lock_> held 
    // because no other waiter threads can wake up to access it.
    cv->was_broadcast_ = 0;
  }
  else
    LeaveCriticalSection (&cv->waiters_count_lock_);
  return 0;
}

int sem_init(sem_t *sem, int pshared, unsigned int value)
{
  *sem = CreateSemaphore(NULL,value,0x7FFFFFFF,NULL);
  return 0;
}

int sem_wait(sem_t * sem) 
{ 
  return WaitForSingleObject(*sem,INFINITE); 
}

int sem_trywait(sem_t * sem) 
{ 
  return WaitForSingleObject(*sem,0); 
}

int sem_post(sem_t * sem) 
{ 
  return ReleaseSemaphore(*sem,1,NULL); 
}

int sem_getvalue(sem_t * sem, int * sval)
{
  LONG x;  
  ReleaseSemaphore(*sem,0,&x); 
  *sval = x;
  return 0;
}

int sem_destroy(sem_t * sem) 
{
  return CloseHandle(*sem);
}


#else

//POSIX
#include <time.h>
#include <sys/time.h>

int pthread_cond_uswait(
  pthread_cond_t *cv, 
  pthread_mutex_t *m, 
  unsigned long us
)
{
  timeval tv;
  gettimeofday(&tv,NULL);
  unsigned long t0 = tv.tv_sec * 1000000uL + tv.tv_usec;
  unsigned long t1 = t0 + us;
  timespec ts;
  ts.tv_sec = t1 / 1000000uL;
  ts.tv_nsec = (t1 % 1000000uL) * 1000;
  return pthread_cond_timedwait(cv,m,&ts);
}

#endif

@head(2,'Portable Mutex')
@h=tangler('demux/demux_mutex.hpp')
@select(h)
#ifndef __FLX_MUTEX__
#define __FLX_MUTEX__
#include "flx_rtl_config.hpp"

#include "demux_win_posix_condv_emul.hpp"

namespace flx { namespace demux {

// ********************************************************
/// Mutex.
// ********************************************************
class FLX_RTL_EXTERN flx_mutex_t {
  flx_mutex_t(flx_mutex_t const&); // uncopyable
  void operator=(flx_mutex_t const&); // uncopyable
public:
  pthread_mutex_t m;        // be nice, don't touch
  flx_mutex_t();
  ~flx_mutex_t();
  void lock();
  void unlock();
};

class FLX_RTL_EXTERN flx_mutex_locker_t {
  flx_mutex_t* p;
  flx_mutex_locker_t(flx_mutex_locker_t const&); // uncopyable
  void operator=(flx_mutex_locker_t const&); // uncopyable
public:
  flx_mutex_locker_t(flx_mutex_t& pm);
  ~flx_mutex_locker_t();
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_mutex.cpp')
@select(h)
#include "demux_mutex.hpp"
#include <stdio.h>
#include <assert.h>

namespace flx { namespace demux {
flx_mutex_t::flx_mutex_t(flx_mutex_t const&){} // uncopyable
void flx_mutex_t::operator=(flx_mutex_t const&){} // uncopyable

flx_mutex_t::flx_mutex_t() {
    assert( !recursive );
    int res = pthread_mutex_init(&m, NULL);
    if(res != 0) throw res;
}

flx_mutex_t::~flx_mutex_t() { pthread_mutex_destroy(&m); }
void flx_mutex_t::lock() { pthread_mutex_lock(&m); }
void flx_mutex_t::unlock() { pthread_mutex_unlock(&m);}

flx_mutex_locker_t::flx_mutex_locker_t(flx_mutex_locker_t const&){} // uncopyable
void flx_mutex_locker_t::operator=(flx_mutex_locker_t const&){} // uncopyable
flx_mutex_locker_t::flx_mutex_locker_t(flx_mutex_t& pm) : p(&pm) { p->lock(); }
flx_mutex_locker_t::~flx_mutex_locker_t() { p->unlock(); }

}}

@head(1,"Condition Variable")
@head(2,'Portable Condition Variable')
@h=tangler('demux/demux_condv.hpp')
@select(h)
#ifndef __CONDV__
#define __CONDV__
#include <flx_rtl_config.hpp>
#include "demux_mutex.hpp"

#include "demux_win_posix_condv_emul.hpp"

namespace flx { namespace demux {

// ********************************************************
/// Condition Variable.
// ********************************************************
class FLX_RTL_EXTERN flx_condv_t {
public:
  pthread_cond_t cv;        // be nice, don't touch
  flx_condv_t();
  ~flx_condv_t();
  void signal();
  void broadcast();
  void wait(flx_mutex_t*);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_condv.cpp')
@select(h)
#include "demux_condv.hpp"
#include <stdio.h>        // printf debugging
#include <assert.h>

namespace flx { namespace demux {

flx_condv_t::flx_condv_t() { pthread_cond_init(&cv, NULL); }
flx_condv_t::~flx_condv_t() { pthread_cond_destroy(&cv); }
void flx_condv_t::wait(flx_mutex_t *m) { pthread_cond_wait(&cv,&(m->m)); }
void flx_condv_t::signal() { pthread_cond_signal(&cv);}
void flx_condv_t::broadcast() { pthread_cond_broadcast(&cv); }

}}

@head(1,"Semaphore")
@head(2,'Portable Semaphore')
@h=tangler('demux/demux_semaphore.hpp')
@select(h)
#ifndef __SEMAPHORE__
#define __SEMAPHORE__
#include <flx_rtl_config.hpp>
#include "demux_mutex.hpp"

#include "demux_win_posix_condv_emul.hpp"

namespace flx { namespace demux {

// ********************************************************
/// Semaphore
// ********************************************************
class FLX_RTL_EXTERN flx_semaphore_t {
  sem_t sem;
public:
  flx_semaphore_t(int n=0);
  ~flx_semaphore_t();
  void post();
  void operator++() { post(); }
  void wait();
  void operator--() { wait(); }
  int get();
  int operator*() { return get(); }

  /// atomic test and decrement if non-zero function.
  /// returns EAGAIN on failure to decrement.
  int trywait(); 
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_semaphore.cpp')
@select(h)
#include "demux_semaphore.hpp"
#include <stdio.h>        // printf debugging
#include <assert.h>

namespace flx { namespace demux {
flx_semaphore_t::flx_semaphore_t(int n) { sem_init(&sem, 0, n); }
flx_semaphore_t::~flx_semaphore_t() { sem_destroy(&sem); }
void flx_semaphore_t::wait() { sem_wait(&sem); }
int flx_semaphore_t::trywait() { return sem_trywait(&sem); }
void flx_semaphore_t::post() { sem_post(&sem); }
int flx_semaphore_t::get(){ int x; sem_getvalue(&sem,&x); return x; }

}}

@h=tangler('demux/demux_monitor.hpp')
@select(h)
#ifndef __MONITOR__
#define __MONITOR__
#include <flx_rtl_config.hpp>
#include "demux_mutex.hpp"
#include "demux_condv.hpp"
#include "demux_semaphore.hpp"

// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace demux {

// ********************************************************
/// A monitor is an concurrent version of a channel.
/// It matches up readers and writers in pairs,
/// synchronising transfer of one datum.
///
/// Unlike the bounded queue below, a monitor is a fully
/// synchronised unbuffered transfer, mediated by a full
/// handshake.
/// 
/// In particular, unlike the queue of size 1, the writer
/// cannot proceed until the reader sends an acknowlege
/// signal.
///
/// This logic matches that provides by schannels, but 
/// across an asynchronous boundary.
// ********************************************************

class FLX_RTL_EXTERN monitor_t {
  flx_mutex_t member_lock; 
  flx_semaphore_t readers;
  flx_semaphore_t writers;
  flx_condv_t ack;
  void *data;
public:
  monitor_t();
  ~monitor_t();
  void enqueue(void*);
  void* dequeue();
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_monitor.cpp')
@select(h)
#include "demux_monitor.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror

using namespace std;

namespace flx { namespace demux {

monitor_t::monitor_t(){}
monitor_t::~monitor_t() { }

void
monitor_t::enqueue(void* elt)
{
  ++writers;
  --readers;
  flx_mutex_locker_t   l(member_lock);
  data = elt;
  ack.wait(&member_lock); // wait for reader to acknowledge
}

void*
monitor_t::dequeue()
{
  ++readers;
  --writers;
  flx_mutex_locker_t   l(member_lock);
  void *d = data;
  ack.signal(); // send acknowlege to release writer
  return d;
}

}}

@head(1,"Portable Thread safe Queue")
Both queue and dequeue operations are critical
sections protected by a mutex.
@p()
When the queue is empty, the dequeue operation waits 
on a semaphore signaled by the enqueue operation.

@h=tangler('demux/demux_sleep_queue.hpp')
@select(h)
#ifndef __SLEEPQUEUE__
#define __SLEEPQUEUE__
#include <flx_rtl_config.hpp>
#include "demux_mutex.hpp"
#include "demux_condv.hpp"

// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace demux {

// ********************************************************
/// Thread safe bounded queue.
///
/// The queue can be locked by setting bound=0.
/// In this state it can only be unlocked by setting a non-zero bound.
///
/// If the bound is set to 1 (the default),
/// then the queue is always either empty or full.
/// An empty queue blocks readers until a writer sends some data.
/// A full queue blocks writers, until a reader reads the data.
/// Note that when the queue is empty a writer can write data
/// and continues without waiting for the data to be read.
// ********************************************************

class FLX_RTL_EXTERN sleep_queue_t {
  flx_mutex_t member_lock; 
  flx_condv_t not_empty_cond; 
  flx_condv_t not_full_cond; 
  void *lame_opaque;  
  size_t bound;
public:
  sleep_queue_t(size_t);
  ~sleep_queue_t();
  void enqueue(void*);
  void* dequeue();
  void resize(size_t);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_sleep_queue.cpp')
@select(h)
#include "demux_sleep_queue.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror

using namespace std;

namespace flx { namespace demux {
typedef queue<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

sleep_queue_t::sleep_queue_t(size_t n) : bound(n)
{
  lame_opaque = new void_queue;
}

// Much care is needed deleting a queue.
// A safe method is possible .. but not provided here
sleep_queue_t::~sleep_queue_t()
{
  delete ELTQ;
}

void
sleep_queue_t::enqueue(void* elt)
{
  //fprintf(stderr,"Q%p: Enqueue %p\n",this,elt);
  flx_mutex_locker_t   l(member_lock);
  if(ELTQ->size() >= bound)
  {
    //fprintf(stderr,"Q%p: Queue is full, waiting\n",this);
    not_full_cond.wait(&member_lock);
  }
  //fprintf(stderr,"Q%p: Queue has space\n",this);
  ELTQ->push(elt);
  //fprintf(stderr,"Q%p: Signal not empty\n",this);
  not_empty_cond.signal(); // cannot return an error
}

void*
sleep_queue_t::dequeue()
{
  flx_mutex_locker_t   l(member_lock);
  if(ELTQ->empty())
  {
    //fprintf(stderr,"Q%p: Waiting for non empty queue\n",this);
    not_empty_cond.wait(&member_lock);
  }
  void *elt = ELTQ->front();
  //fprintf(stderr,"Q%p: Dequeue %p\n",this,elt);
  ELTQ->pop();
  if(ELTQ->size() < bound)
  {
    //fprintf(stderr,"Q%p: Signalling not full\n",this);
    not_full_cond.signal();
  }
  //fprintf(stderr,"Q%p: Dequeued, returning %p\n",this,elt);
  return elt;
}

void 
sleep_queue_t::resize(size_t n)
{
  flx_mutex_locker_t   l(member_lock);
  bound = n;
  // get things rolling again
  if(!ELTQ->empty()) not_empty_cond.signal();
  if(ELTQ->size()<bound) not_full_cond.signal();
}

}}


@head(1,'Portable Job Queue')
The class is actually a thread plus a job queue.
@h=tangler('demux/demux_work_fifo.hpp')
@select(h)
#ifndef __WORKER_FIFO__
#define __WORKER_FIFO__
#include <flx_rtl_config.hpp>
#include "demux_thread.hpp"
#include "demux_mutex.hpp"
#include "demux_sleep_queue.hpp"

namespace flx { namespace demux {

/// Class of jobs to be queued in fifo for execution.
class FLX_RTL_EXTERN worker_task
{
public:
  virtual ~worker_task() {}   // c++ should do this automatically

  /// function called by worker thread to carry out user job
  virtual void doit() = 0;     

  /// function called by worker thread after doit() is completed
  /// used to notify job completion
  virtual void finished() = 0; // finished hook (mi serve start gancia?)
};

/// Linear job scheduler, executes jobs in turn from queue
class FLX_RTL_EXTERN worker_fifo
{
  // this thread is destructed very carefully to make sure that all
  // the objects in this class outlive its execution.
  flx_thread_t  thread;
  sleep_queue_t fifo;

  static void* thread_start(void*); // thread entry point, passed this
  bool thread_loop_body();      // returns keep going flag

public:
  worker_fifo(int n);
  ~worker_fifo();

  /// method used by client to schedule jobs
  /// for this worker thread
  void add_worker_task(worker_task* task);  // also re-entrant

  // those deriving from this class might like to stop the
  // thread in their destructors, so that their objects used
  // by the worker thread can outlive it
  void stop_worker_thread();
  };

}} // namespace demux, flx
#endif  // __WORKER_FIFO__

@h=tangler('demux/demux_work_fifo.cpp')
@select(h)
#include <stdio.h>    // printf
#include "demux_work_fifo.hpp"
namespace flx { namespace demux {

// a fifo of tasks & a thread (threads?) to serve them.
// users overload finished function to implement wakeup

worker_fifo::worker_fifo(int n) : fifo(n)
{
  //fprintf(stderr,"async worker fifo io module constructor\n");
  // fifo already inited and ready to go, so get pthread going
#ifdef _WIN32
  int res = thread.init((LPTHREAD_START_ROUTINE)thread_start, this);
#else
  int res = thread.init(thread_start, this);
#endif

  if(0 != res) throw res;

// do it properly or not at all
#if 0
  fprintf(stderr,"hey, trying multi threads here (leakingly)\n");
  for(int i = 1; i < 1; i++)
  {
    fprintf(stderr,"extra io thread\n");
    flx_thread_t* pt = new flx_thread_t;
    res = pt->init(thread_start, this);
    if(0 != res) throw res;
  }
#endif
}

// To get rid of thread cancel we could have a simple finished flag
// that's set by the class and set by the thread. Since both are executed
// synchronously w.r.t the same thread, we wouldn't need to protect anything
// that won't work if we have multiple worker threads, however.

// better idea - add a null task to front of queue to mean quit. queue
// is already threadsafe. If there are n worker threads, add n nulls.

// stopping the worker thread turns out to be trickier than it sounds
// because it's hard to wake up on an empty queue. 
void
worker_fifo::stop_worker_thread()
{
  add_worker_task(NULL);    // thread safe takedown.
                // for n worker threads add n times
  thread.join();      // join waits for thread to exit.
                // which should happen eventually
}

worker_fifo::~worker_fifo()
{
  // the thread must be brought down before the objects it
  // uses are destructed. lets hope anyone deriving from this
  // class knows that and let them call this function in their
  // destructor.
  stop_worker_thread();
}

// io thread entry point, passed this
void*
worker_fifo::thread_start(void* udat)
{ 
  worker_fifo*  fio = (worker_fifo*)udat;
  fprintf(stderr,"worker_fifo thread started! this=%p\n", fio);

  while(fio->thread_loop_body()) ;

  return 0;             // return status.
}

// dequeues one task and executes it, calling finished hook. interprest
// null task as a request to exit.
bool
worker_fifo::thread_loop_body()
{
  worker_task*  req = (worker_task*)fifo.dequeue();
  //fprintf(stderr,"dequeued worker_task (%p)\n", req);

  if(!req) return false;        // finished, got quit signal

  req->doit();
  req->finished();          // finish hook. I find this handy

  return true;            // keep going
}

void
worker_fifo::add_worker_task(worker_task* task)
{
  //fprintf(stderr,"adding worker task %p\n",task);
  fifo.enqueue(task);         // don't worry, fifo is re-entrant
}

}}


@h=tangler('demux/demux_demuxer.hpp')
@select(h)
#ifndef __DEMUXER__
#define __DEMUXER__
#include <flx_rtl_config.hpp>

namespace flx { namespace demux {

typedef struct {
  char*   buffer;           // set on input
  long    buffer_size;        // set on input
  long    bytes_written;        // set on input and output

  bool    finished() { return bytes_written == buffer_size; }
}sel_param;

// rename ...
// read/write flags - they're no longer mutually exclusive
enum { PDEMUX_READ = 1, PDEMUX_WRITE = 2 };


// ********************************************************
/// Demux base.
// ********************************************************
class FLX_RTL_EXTERN demuxer {
protected:
  // wait for outstanding events. may return before given events, so
  // check your conditions. I've turned of all the timeouts that cause
  // this, but don't rely on it!
  // FACTOR. Give poll a greedy interface
  virtual void  get_evts(bool poll) = 0;

public:
  virtual ~demuxer() {}

  void wait() { get_evts(false); }
  void poll() { get_evts(true); }
};
}} // namespace demux, flx
#endif  /* __DEMUXER__ */

@h=tangler('demux/demux_epoll_demuxer.hpp')
@select(h)
#ifndef __EPOLL_DEMUXER__
#define __EPOLL_DEMUXER__

#include <flx_rtl_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {
// epoll allows only one event per socket - it does not differentiate
// on the awaited operation (read/write), however it does let you wait
// on any combination (I think)

// ********************************************************
/// epoll based demuxer
// ********************************************************

class FLX_RTL_EXTERN epoll_demuxer : public posix_demuxer {
  int   epoll_fd;

  // be careful of this - don't let it create race conditions
  // should probably only be called by wait = in one thread only (check)
  // this removes ALL outstanding events for s.
  void  remove_wakeup(int s);

  virtual void  get_evts(bool poll);
public:
  epoll_demuxer();
  virtual ~epoll_demuxer();
  
  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_evtport_demuxer.hpp')
@select(h)
#ifndef __EVTPORT_DEMUXER__
#define __EVTPORT_DEMUXER__

// driver for solaris 10 event port notifications

#include "demux_posix_demuxer.hpp"

// Event ports are oneshot by default (I don't know if you can change that).
// Events are tracked only by fd and not fd*event, so you cannot add
// separate wakeups for read and write with the same fd and hope for it to
// work as the later one will overwrite the earlier, fodder for race
// conditions. This impl satisfies 1-1 wakeup to request ratio.

// I don't know if evtports can be waited upon by other evtports

// OBS.
// after removing the threads from the demuxers/event sources
// how are the two half demuxers supposed to work? They used to
// have three threads and now they have one. How can two waits be
// done in one thread? I could add one half_demuxer's evtport to
// the other's and wait on that. Would that work? Otherwise I'll
// have to start a thread, which screws things up a bit. Could do
// that and communicate back to single thread via a waitable queue.
// could have three half-demuxers, add them both to third and call
// their wait functions depending on the outer's wait result.

class FLX_RTL_EXTERN evtport_demuxer : public posix_demuxer {
    int     evtport;

  // I think evtports only track socket the socket and not
  // socket*operation, so there's only one remove
  void remove_wakeup(int s);

    virtual void  get_evts(bool poll);
public:
  evtport_demuxer();
  virtual ~evtport_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};


}} // namespace demux, flx
#endif

@h=tangler('demux/demux_iocp_demuxer.hpp')
@select(h)
#ifndef __IOCP_DEMUXER__
#define __IOCP_DEMUXER__

#include <flx_rtl_config.hpp>
#include <Windows.h>

#include "demux_demuxer.hpp"
#include "demux_sleep_queue.hpp"


namespace flx { namespace demux {

// not here? returns INVALID_SOCKET on failure.
// if *io_port == 0, then a port is chosen and returned in *io_port
SOCKET FLX_RTL_EXTERN create_listener_socket(int* io_port, int backlog);
// these two probably not used. move to wsockety.h
SOCKET FLX_RTL_EXTERN nice_accept(SOCKET listener);
SOCKET FLX_RTL_EXTERN nice_connect(const char* addr, int port);
int FLX_RTL_EXTERN set_tcp_nodelay(int s, int disable_nagle);

// ********************************************************
/// make sure you instantion ONE (1) of these before using winsock
// ********************************************************
class FLX_RTL_EXTERN winsock_initer
{
public:
  winsock_initer();
  ~winsock_initer();
};

// ********************************************************
/// iocp_wakeup base class for users of iocp_demuxer
/// becoming an overlapped call control block
// ********************************************************
class FLX_RTL_EXTERN iocp_wakeup {
protected:            // folks need to use these in win 32 calls
  OVERLAPPED  ol;
  // store wakeup error here?
  // I didn't want this to be felixy, useful though.
  void clear_overlapped();  // zero the OVERLAPPED structure
public:
  // 2 possibilities for piggybacking data. who could ask for more?
  // udat = per iocp association, olp = per overlapped function call.
  // why don't I need this in the posix version?
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err) = 0;

  // start overlapped async operation. returns true if it finished
  // immediately. in this case there will be no iocp_finished wakeup.
  // assumes all args ready for call.
  virtual bool start_overlapped() = 0;

  // retrieves this pointer from OVERLAPPED pointer
  static iocp_wakeup* from_overlapped(LPOVERLAPPED olp);
};

// ********************************************************
// ********************************************************
class FLX_RTL_EXTERN iocp_demuxer : public demuxer {
  HANDLE    iocp;     // the io completion queue

  void get_evts(bool poll);
public:
  iocp_demuxer();
  virtual ~iocp_demuxer();

  // udat is the per IOCP object user cookie & the overlapped pointer
  // is the per overlapped operation cookie (sort of), so in the case
  // of acceptex, udat is set when the listener is associated with the
  // iocp and is passed to the subsequent acceptex iocp wakeups.
  // probably won't be used very often
  // the OVERLAPPED retrieved from the iocp is assumed to be part of
  // an iocp_wakeup - beware! returns 0 on success, -1 on failure.
  int associate_with_iocp(HANDLE obj, ULONG_PTR udat);

};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_kqueue_demuxer.hpp')
@select(h)
#ifndef __KQUEUE_DEMUXER__
#define __KQUEUE_DEMUXER__

#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// ********************************************************
/// kqueue demuxer for BSD
// ********************************************************
class FLX_RTL_EXTERN kqueue_demuxer : public posix_demuxer {
  int   kq;
protected:
  // this could just be passed the socket_wakeup, if it stored
  // the flags. Those flags are also set, though, which would
  // create a race condition. In and out flags?

  int add_kqueue_filter(socket_wakeup* sv, short filter);
  int remove_kqueue_filter(int s, short filter);

  int remove_socket_wakeup(int s, int flags);
  void get_evts(bool poll);
public:
  kqueue_demuxer();
  virtual ~kqueue_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, int flags);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_pfileio.hpp')
@select(h)
#ifndef __PFILEIO__
#define __PFILEIO__
#include <flx_rtl_config.hpp>

#include "demux_demuxer.hpp"
#include "demux_sleep_queue.hpp"
#include "demux_mutex.hpp"
// #include <sys/types.h> // off_t (don't have flx iface to this yet)
              // can just add new constructor
#include "demux_work_fifo.hpp"
namespace flx { namespace demux {

// ********************************************************
/// like another event source. this is basically a wrapped pread, pwrite
/// should probably be derived from posix_wakeup or something like that.
/// or have the same signature. abstract - users overload "finished
// ********************************************************
class FLX_RTL_EXTERN fileio_request : public worker_task
{
  long    offset;   // make this a proper offset (64bit)
  // off_t    offset; // in: offset, for use with pread, pwrite
  int     fd;     // in: fd in question
  bool    read_flag;  // in: read else write

  int     err;    // out:
public:
  // public so it can be got in felix
  sel_param pb;   // in & out: what you want, what you get (64bit len?)

  virtual ~fileio_request(); // c++ should do this automatically
  fileio_request();       // flx linkage
  fileio_request(int f, char* buf, long len, long off, bool rd);

  virtual void doit();      // sync
};

// ********************************************************
// could do separate threads for in & out. or implement some form of cache.
// ********************************************************
class FLX_RTL_EXTERN pasync_fileio : public worker_fifo
{
public:
  pasync_fileio(int n) : worker_fifo(n) {}
  // compatibility only. don't need this class anymore.
  void add_fileio_request(fileio_request* req) { add_worker_task(req); } 
};

}} // namespace demux, flx
#endif  // __PFILEIO__

@h=tangler('demux/demux_posix_demuxer.hpp')
@select(h)
#ifndef __POSIX_DEMUXER__
#define __POSIX_DEMUXER__

// base classes for posix style demuxers

#include "demux_demuxer.hpp"

namespace flx { namespace demux {
class FLX_RTL_EXTERN posix_demuxer;            // fwd decl

// abc
class FLX_RTL_EXTERN posix_wakeup {
public:
  virtual ~posix_wakeup() {}

  // when called, the wakeup has finished and been removed.
  virtual void wakeup(posix_demuxer& demux) = 0;
};

class FLX_RTL_EXTERN socket_wakeup : public posix_wakeup {
public:
  int   s;                // the non blocking socket
  int   wakeup_flags;         // set on wakeup, r/w or both

  socket_wakeup() : s(-1) {}
};

class FLX_RTL_EXTERN posix_demuxer : public demuxer {
protected:
  
public:
  virtual ~posix_demuxer();

  // posix style sockets. for reading and writing (but not both at once
  // for the same socket_wakeup) you are guaranteed to receive only one
  // wakeup per call to this function when you call wait.
  // returns -1 if no wakeup is coming and zero if one is.
  // For simultaneous reading and writing you may get two wakeups,
  // that is, it may violate the "one shot" rule. Ignoring for now,
  // as it's not a common use. This makes it undefined behaviour.
  // wakeup is owned by the demuxer until its wakeup is called,
  // so treat it with kid gloves, i.e. don't mess with it.
  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags) = 0;

  // to be called when we can read & write without blocking
  // return true if connection closed, update pb
  // sort of a strange place to have this..., more a socket wakeup
  // thing, even if static
  static bool   socket_recv(int s, sel_param* pb);
  static bool   socket_send(int s, sel_param* pb);
};

// some handy control blocks for common non-blocking socket operations
// note that they "fortuitously" both have start methods. hmm.
// a socket io one could be handy here.

// this one's restartable (makes sense for listener sockets)
class FLX_RTL_EXTERN accept_control_block : public socket_wakeup {
public:
  int   accepted;   // accepted socket (out)
  int   socket_err;   // the error, if acceptee == -1, else 0 (out)
  
  accept_control_block() : accepted(-1), socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);
};

class FLX_RTL_EXTERN connect_control_block : public socket_wakeup {
public:
  int     socket_err;   // outgoing error (on start or wake)
  // this should probably be a sockaddr type
  const char* addy;     // addr (dotted quad) (in)
  int     p;        // port (in)
  
  connect_control_block() : socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);

  // oops, can't check for s != -1 as it's always there.
  // was always "finished" and so I started io, losing the first wakeup
  // on epoll evtsrc. Is this right, or should it be != EINPROGRESS?
  // keep in sync with iocp version. give socket_err initial definition
  // that works with this?
  bool finished() { return ( 0 == socket_err); }
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_select_demuxer.hpp')
@select(h)
#ifndef __SELECT_DEMUXER__
#define __SELECT_DEMUXER__

#include "demux_posix_demuxer.hpp"
#include <sys/types.h>    // for sys/select.h on osx
#include <sys/select.h>   // for fd_set
//#include <sys/time.h>   // GUSI WTF?

// Unlike the other demuxers, this one is NOT thread safe, so wait and
// add socket wakeup must only be called from the same thread.
// if you're looking for the thread safe version, try ts_select_demuxer

namespace flx { namespace demux {

class FLX_RTL_EXTERN select_demuxer : public posix_demuxer {
  void  remove_fd(int s);
  
  // thanks Beej!
  fd_set      master_read_set;    // fd watched for reading
  fd_set      master_write_set;   // for writing
  fd_set      master_except_set;    // for exceptions

  // read sveglias - note we only have one set, so currently this demuxer
  // cannot have separate wakeups for the same file descriptor. this
  // fits in fine with the "undefined" nature of doing that.
  socket_wakeup*  svs[FD_SETSIZE];    // read sveglias
  //socket_wakeup*  write_svs[FD_SETSIZE];  // write wakeups

  int       fdmax;          // high watermark for select

protected:
  virtual void  get_evts(bool poll);

public:
  // get_evts broken into pieces for thread safe implementations
  void copy_sets(fd_set& rset, fd_set& wset, fd_set& exset);
  // returns true if process_sets should be called.
  bool select(fd_set& rset, fd_set& wset, fd_set& exset, bool poll);
  // these could be consts
  void process_sets(fd_set& rset, fd_set& wset, fd_set& exset);

  select_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};
}} // namespace demux, flx
#endif

@h=tangler('demux/demux_ts_select_demuxer.hpp')
@select(h)
#ifndef __TS_SELECT_DEMUXER__
#define __TS_SELECT_DEMUXER__

#include "demux_select_demuxer.hpp"
#include "demux_mutex.hpp"

namespace flx { namespace demux {

// thread safe version of select demuxer

// there's no standard posix_socketio_wakeup, could be handy. could also
// perhaps use it here?
class FLX_RTL_EXTERN selfpipe_wakeup : public socket_wakeup {
public:
  virtual void wakeup(posix_demuxer& demux);
};

class FLX_RTL_EXTERN auto_fd {
public:
  int fd;

  auto_fd();
  ~auto_fd();
};

class FLX_RTL_EXTERN ts_select_demuxer : public posix_demuxer {
  // big conservative recursive hamfisted lock.
  flx_mutex_t      ham_fist;   
  // protects this little fella here.
  select_demuxer  demux;


  // self pipe trick!!! fd[0] = read end, fd[1] = write end.
  auto_fd     fds[2];
  selfpipe_wakeup spw;
protected:
    virtual void    get_evts(bool poll);
public:
  ts_select_demuxer();
  virtual ~ts_select_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, int flags);
};
}} // namespace demux, flx

#endif
@h=tangler('demux/demux_sockety.hpp')
@select(h)
#ifndef __SOCKETY__
#define __SOCKETY__
#include <flx_rtl_config.hpp>
namespace flx { namespace demux {

// Shouldn't this all be FLX_RTL_EXTERN?
int create_listener_socket(int* io_port, int q_len);
int create_async_listener(int* io_port, int q_len);
int nice_accept(int listener, int* err);
int nice_connect(const char* addr, int port);
int async_connect(const char* addr, int port, int* finished, int* err);

/* handy socket building blocks */

int connect_sock(int s, const char* addr, int port);

/* this could possibly do with NIC addr as well as port */
int bind_sock(int s, int* io_port);

int make_nonblock(int s);
int set_tcp_nodelay(int s, int disable_nagle);
int get_socket_error(int s, int* socket_err);

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_timer_queue.hpp')
@select(h)
#ifndef __TIMER_QUEUE__
#define __TIMER_QUEUE__

#include <flx_rtl_config.hpp>

namespace flx { namespace demux {

// trying to factor out code to share between pc & posix versions

// class sleep_task : public worker_task
// may not need time in here - just the wakeup - something I surely have
// somewhere else.
class FLX_RTL_EXTERN sleep_task
{
public:
    virtual ~sleep_task() {}

    virtual void fire() = 0;
};

class FLX_RTL_EXTERN timer_queue
{
public:
    virtual ~timer_queue() {}    

    virtual void add_sleep_request(sleep_task* st, double delta) = 0;
    virtual void add_abs_sleep_request(sleep_task* st, double when) = 0;

    // bad design - this is actually implemented in the descendent classes,
    // which limits the number of such classes probably to one.
    static void get_time(double& t);        // in seconds from some ref pt
};

}} // namespace demux, flx

#endif

@h=tangler('demux/demux_posix_timer_queue.hpp')
@select(h)
#ifndef __POSIX_TIMER_QUEUE__
#define __POSIX_TIMER_QUEUE__

#include "demux_posix_thread.hpp"  // flx_thread_t, lock
#include "demux_mutex.hpp"  // flx_thread_t, lock
#include "demux_timer_queue.hpp" // base class
#include <sys/time.h>        // timespecs, gettimeofday

namespace flx { namespace demux {

// looks like a worker queue, but couldn't quite mash it into one
class FLX_RTL_EXTERN posix_timer_queue : public timer_queue
{
    // ATTENZIONE: the thread uses this & so it must outlive it
    // for this it is declared before the thread (I would've expected
    // an error to be returned from pthread_mutex_lock instead of
    // deadlock but whatever).
    // update: I was getting deadlock in a broken stdlib version
    // gcc4.0.1, ppc64, osx10.4.2 in printf, however the above still
    // stands: the lock must outlive the thread that uses it.
    flx_mutex_t        lock;                    // factor to prio queue?

    flx_thread_t    sleep_thread;
    static void* thread_start(void*);    // passed "this"
    bool thread_loop_body();

    void*        opaque_prio_queue;        // less fat

    pthread_cond_t    sleep_cond;            // this could be cool.
    int setup_sleep_cond();
    void takedown_sleep_cond();            // deallocate the condition

    void wakeup_thread();                // we can do this!

    void add_sleep_request(sleep_task* st, timespec* abs);
public:
    posix_timer_queue();
    ~posix_timer_queue();

    // thread safe.
    virtual void add_sleep_request(sleep_task* st, double delta);

    // in seconds, relative to same base as timer::get_time.
    virtual void add_abs_sleep_request(sleep_task* st, double when);
};

}}

#endif // __POSIX_TIMER_QUEUE__

@h=tangler('demux/demux_posix_timer_queue.cpp')
@select(h)
#include "demux_posix_timer_queue.hpp"

// a prio queue that executes tasks in a given order
// factor out prio_queue? could be like queue.

// try to make work like the worker thread thing, fix it do so?.
// remove time from sleep task...

#include <queue>    // stl seems to have a prio_queue
#include <sys/time.h> // gettimeofday for calculating "now"

namespace flx { namespace demux {

#define MIL 1000000        // one million
#define BIL (MIL*1000)    // one billion (metric)

using namespace std;

// it could happen!
// factor
class future_evt
{
public:
    timespec    when;    
    sleep_task*    task;

    // ignore the direction, just trying to sort with smallest first
    bool operator<(const future_evt& rhs) const
    {
        if(when.tv_sec != rhs.when.tv_sec)    // precedence to more significant
            return when.tv_sec > rhs.when.tv_sec;
        else                                // else check the less significant
            return when.tv_nsec > rhs.when.tv_nsec;
    }
};

typedef priority_queue<future_evt> void_prio_queue;
#define PRIOQ ((void_prio_queue*)opaque_prio_queue)

int
posix_timer_queue::setup_sleep_cond()
{
    fprintf(stderr,"setup_sleep_cond\n");
    int    res;
    res = pthread_cond_init(&sleep_cond, NULL);

    if(0 != res)
        fprintf(stderr,"pthread_cond_init failed: %i\n", res);

    return res;
}

void
posix_timer_queue::takedown_sleep_cond()
{
    fprintf(stderr,"sleep cond taking down\n");
    int    res;
    res = pthread_cond_destroy(&sleep_cond);
    if(0 != res) fprintf(stderr,"condition destroy failed: %i\n", res);
}

// it's a real bore properly cleaning up in the face of exceptions in
// constructors. try using some local objects to look after it.
posix_timer_queue::posix_timer_queue()
{
    // fprintf(stderr,"posix_timer_queue ctor\n");

    // if this throws, no harm done
    opaque_prio_queue = new void_prio_queue;    // a.k.a. PRIOQ

    int    res;
    res = setup_sleep_cond();
    if(0 != res)
    {
        delete PRIOQ;                            // cleanup, carry on
        throw res;
    }

    // do the thread last because it uses all of the above
    fprintf(stderr,"initing sleep thread\n");

    res = sleep_thread.init(thread_start, this);

    if(0 != res)
    {
        delete PRIOQ;
        takedown_sleep_cond();
        throw res;
    }
    // not good to do much else after this as the thread is running
}

posix_timer_queue::~posix_timer_queue()
{
    // the sleep_thread uses the prioq, so we must explicitly shut it
    // down now, before we delete the prioq. left to its own devices,
    // c++ destructs it at the end of this destructor.

    // take down the thread first because it uses all the other stuff.
    // I actually don't need to do anything special to bring the thread
    // down because all pthread_cond_*wait* are cancel aware. Or so they
    // should be. As far as I can tell only the 64bit osx10.4.2 is, so
    // for now the explicit cancel + wakeup followed by explicit 
    // cancel test stays.

    // fprintf(stderr, "asking timer thread to quit\n");
    add_sleep_request(NULL, 0.0);    // super secret quit thread quit request
    wakeup_thread();                // wakeup, cause to goto a cancel pt

    sleep_thread.join();            // will join
    fprintf(stderr,"about to delete PRIOQ\n");
    delete PRIOQ;

    takedown_sleep_cond();
}

static void
get_now(timespec* now)
{
    struct timeval tp;

    if(gettimeofday(&tp, NULL) == -1)
        perror("gettimeofday");

    // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
    now->tv_sec = tp.tv_sec;
    now->tv_nsec = tp.tv_usec*1000;        // fits!

    // fprintf(stderr,"get_now = %li, %li\n", now->tv_sec, now->tv_nsec);
}

// LIMIT!
// seconds to microseconds - signed this gives a bit over half an hour
#define SEC2TIMESPEC(ts, t) long    wait_musec = (long)(t*MIL);    \
    timespec    ts = { wait_musec / MIL, (wait_musec % MIL)*1000 }


// offset delta from "now" and store in "when"
static void
calc_when(timespec* when, double delta)
{
// how to use the posix abstime versions of timed waits? what kind of absolute
// is abstime? pthread_get_expiration_np looks useful, but it too is np.
// abstime is apparently in seconds since the Epoch, UTC.
// To get now there's clock_gettime (not portable) or gettimeofday with
// null timezone.

    timespec    now;
    get_now(&now);

    // limit!
    // seconds to microseconds - signed this gives a bit over half an hour
    // long    wait_musec = (long)(delta*MIL);
    // timespec    delay = { wait_musec / MIL, (wait_musec % MIL)*1000 };
    SEC2TIMESPEC(delay, delta);
    
    // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
    when->tv_sec = now.tv_sec + delay.tv_sec;
    when->tv_nsec = now.tv_nsec + delay.tv_nsec;

    if(when->tv_nsec >= BIL)            // overflow of nanoseconds?
    {
        // fprintf(stderr,"OVERFLOW = %li, %li\n", when->tv_sec, when->tv_nsec);
        // x, y < BIL, x + y < 2BIL
        when->tv_sec++;
        when->tv_nsec -= BIL;
        // when->tv_sec += when->tv_nsec/BIL;
        // when->tv_nsec %= BIL;
    }

    // fprintf(stderr,"when = %li, %li\n", when->tv_sec, when->tv_nsec);
    // tp contains tv_sec (seconds) & tv_usec (microseconds) both longs.
    // however, if nonposix works everywhere...
}

// absolute time
void
posix_timer_queue::add_sleep_request(sleep_task* st, timespec* abs)
{
    future_evt    evt;
    evt.task = st;
    evt.when = *abs;

    flx_mutex_locker_t    locker(lock);

    PRIOQ->push(evt);

    // we may have inserted at sooner than any other evt, so wake up thread
    // to figure it out (if need be). I seemed to be getting more wakeups
    // with this. Turned off for now. Not sure how that works.
    if(1 || PRIOQ->top().task == st)
    {
//        fprintf(stderr,"WE PUSHED IN - waking thread\n");
        wakeup_thread();
    }
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
posix_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
    // fprintf(stderr,"add_sleep_request: %lf\n", delta);
    timespec    when;
    calc_when(&when, delta);        // calculate when (t a delta)

    add_sleep_request(st, &when);
}

void
posix_timer_queue::add_abs_sleep_request(sleep_task* st, double when)
{
    // absolute version is closer to the posix implementation
    SEC2TIMESPEC(abs_time, when);
    add_sleep_request(st, &abs_time);
}

// cause the timer wait thread to wake up. useful for asking it to
// exit or re-evaluate a changed sleep queue.
void
posix_timer_queue::wakeup_thread()
{
    // fprintf(stderr,"waking sleeper thread with pthread_cond_signal\n");
    int    res;
    // we don't need broadcast because we're only ever waking
    // one thread, the sleeper thread.
    res = pthread_cond_signal(&sleep_cond);
    if(0 != res) fprintf(stderr,"condition signal failed: %i\n", res);
}

void*
posix_timer_queue::thread_start(void* udat)
{
    posix_timer_queue*    q = (posix_timer_queue*)udat;
    fprintf(stderr,"sleeper thread\n");

    while(q->thread_loop_body()) ;

    return 0;
}

bool
posix_timer_queue::thread_loop_body()
{
    flx_mutex_locker_t    locker(lock);    // lock on. lock off when waiting on condition

    int        res;

    // pthread_cond_wait & pthread_cond_timedwait (& np rel version?) are
    // cancellation points. doco notes for timed & untimed waits that the
    // predicate should be rechecked as there can be spurious wakeups.
    // no worries, when we wakeup the lock has been acquired.

    while(!PRIOQ->empty())
    {
        future_evt    evt = PRIOQ->top();

        // quit request
        if(!evt.task) return false;

        future_evt  now;        // "now' has no task, just a dummy.
        get_now(&now.when);

        // if(evt < now)        // would prefer <=, eh.
        // < is arse backwards because I don't know how to use the stl
        if(now < evt)        // would prefer <=, eh.
        {
            // fprintf(stderr,"firing of (%li, %li) at (%li, %li)!\n",
            //    evt.when.tv_sec, evt.when.tv_nsec,
            //    now.when.tv_sec, now.when.tv_nsec);
            evt.task->fire();
            PRIOQ->pop();
        }
        else    // we have an event in future, so sleep for that long
        {
            // remember that condition waits are exit points...
            // so I don't need to test - check that.
            // fprintf(stderr,"sleeping from %li, %li until %li, %li\n",
            //    now.when.tv_sec, now.when.tv_nsec,
            //    evt.when.tv_sec, evt.when.tv_nsec);
            res = pthread_cond_timedwait(&sleep_cond, &lock.m, &evt.when);

            // if using posix abstime timed wait we make get EINVAL here for 
            // abstimes in the past. must handle this.
 
            // fprintf(stderr,"pthread_cond_timedwait woke up! (%i)\n", res);
        }
    }

    // if we got here then the queue is empty, so sleep indefinitely
    // that we don't really need the mainloop testcancel because the condition
    // wait functions are cancellation points.
    // fprintf(stderr,"no sleep task, sleeping indefinitely\n");
    res = pthread_cond_wait(&sleep_cond, &lock.m);
    // fprintf(stderr,"pthread_cond_wait woke up! (%i)\n", res);

    // lock released here
    return true;                    // keep going
}


// in seconds from some ref pt
// N.B. declared in base class!
void
timer_queue::get_time(double& t)
{
    timespec    now;
    get_now(&now);        // just calls gettimeofday (msec) and converts
                        // to timespec (sec, nsec). could skip that
                        // and call directly, avoiding conversion
    t = now.tv_sec + (now.tv_nsec*BIL);
}  

}}

@h=tangler('demux/demux_win_timer_queue.hpp')
@select(h)
#ifndef __WIN_TIMER_QUEUE__
#define __WIN_TIMER_QUEUE__

#include "flx_rtl_config.hpp"
#include <Windows.h>

#include "demux_timer_queue.hpp"

namespace flx { namespace demux {

class FLX_RTL_EXTERN win_timer_queue : public timer_queue
{
  HANDLE    timer_queue;

  static VOID CALLBACK timer_callback(PVOID, BOOLEAN);
public:
  win_timer_queue();
  ~win_timer_queue();

  virtual void add_sleep_request(sleep_task* st, double delta);
  virtual void add_abs_sleep_request(sleep_task* st, double when);

};

}}

#endif // __SLEEP_TASK__

@h=tangler('demux/demux_win_timer_queue.cpp')
@select(h)
#include "flx_rtl_config.hpp"
#include <Windows.h>
#include <assert.h>

// simply wrapped windows timer queue. requires windows 5.00, which is 
// quite high (xp?) because I couldn't get the waitable timers to work.
// must be careful with this stuff lest it create millions of threads.
#include "demux_win_timer_queue.hpp"

#include <stdio.h>

namespace flx { namespace demux {

#define MIL 1000000    // 1 metric million

typedef struct
{
  sleep_task*  st;        // so we can make it fire
  HANDLE    timer;      // we need to delete the timer, so we keep it
  HANDLE    timer_queue;  // AND its queue (no back ptrs, I guess)
} timer_cookie;

win_timer_queue::win_timer_queue()
{
  // fprintf(stderr,"win_timer_queue ctor\n");

  timer_queue = CreateTimerQueue();
  if(!timer_queue)
  {
    fprintf(stderr, "CreateTimerQueue failed: %i\n", GetLastError());
    throw -1;
  }
  // fprintf(stderr, "created timer queue: %p\n", timer_queue);
}


win_timer_queue::~win_timer_queue()
{
  // INVALID_HANDLE_VALUE indicates that DeleteTimerQueueEx should wait for
  // all callback functions to complete before returning. One would hope that
  // calling this causes all the timers to go off before their time (what
  // else would the "actually fired" callback flag be for?). The alternative
  // of waiting for some ever distant timer to go off would be too stupid
  // for words. As usual, the msdn glosses over the important details like
  // this one. Anyway, it's easy to test out... No, that flag's always true
  // for timers, and this wait option doesn't work - maybe with other types
  // flags for CreateTimerQueueTimer?
  if(!DeleteTimerQueueEx(timer_queue, INVALID_HANDLE_VALUE))
  {
    fprintf(stderr, "DeleteTimerQueueEx failed: %i\n", GetLastError());
    // whatcha gonna do about it?
  }
  // fprintf(stderr, "finished - did it wait?\n");
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
win_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
  // fprintf(stderr,"add_sleep_request: %lf to %p\n", delta, timer_queue);

  timer_cookie*  tc = new timer_cookie;

  // copy in the sleep_task and the timer queue
  tc->st = st;
  tc->timer_queue = timer_queue;

  // the timer thread may not be the best solution as nothing is stopping
  // anyone from performing long operations with this structure, however
  // in all likelihood, it'll just be felix adding threads back to its queue.
  if(!CreateTimerQueueTimer(
    &tc->timer,          // resulting timer in timer_cookie
    timer_queue,
    //NULL,            // add to default timer queue
    timer_callback,        // should get called in delta seconds
    tc,             // timer cookie is user data
    (DWORD)(delta*1000),    // millisecond timer
    0,              // zero period => signal once
    WT_EXECUTEINTIMERTHREAD))  // NB: for short tasks (will this do?)
  {
    fprintf(stderr, "CreateTimerQueueTimer failed: %i\n", GetLastError());
    delete tc;          // at least try not to leak
    return;
  }
}

// this is a c callback - all the c++ code should probably be wrapped
// in a try/catch. timer_or_wait_fired is always true for timers.
VOID CALLBACK
win_timer_queue::timer_callback(PVOID udat, BOOLEAN timer_or_wait_fired)
{
  timer_cookie*  tc = (timer_cookie*)udat;
  
  // fprintf(stderr, "timer queue callback fired: %p, %i\n",
  //  tc, timer_or_wait_fired);

  if(!tc)
  {
    // Nothing that we can do in this situation.
    fprintf(stderr, "WHOA - NULL queue cookie! (fired: %i)\n",
      timer_or_wait_fired);
    return;            // outta here
  }

  // NULL means delete the thing now, INVALID_HANDLE_VALUE means wait until
  // callback finishes. We're in the callback, so we can't do that (=deadlock
  // of the timer thread, which isn't good). We're all adults here, the timer
  // has expired, we know what we're doing, so lets just delete it.
  tc->st->fire();

  // on my box this returns ERROR_IO_PENDING, on others it doesn't
  // msdn says this should be ok, but I'm not so sure.
  if(!DeleteTimerQueueTimer(tc->timer_queue, tc->timer, NULL))
  {
    int  err = GetLastError();

    if( ERROR_IO_PENDING != err)
    {
      fprintf(stderr, "DeleteTimerQueueTimer of %p failed: %i\n",
        tc->timer, err);
    }
    else
    {
      // I'm not so sure, see if it leaks.
      fprintf(stderr, "DeleteTimerQueueTimer = ERROR_IO_PENDING\n");
      fprintf(stderr, "Apparently this is ok...\n");
    }
  }
  delete tc;

  // fprintf(stderr, "leaving timer callback\n");
}

// in seconds from some ref pt (UTC for this fn)
// N.B. declared in base class!
void
timer_queue::get_time(double& t)
{
  SYSTEMTIME  sysnow;
  GetSystemTime(&sysnow);
  // now convert to seconds
  // via FILETIME?

  // kinda sucks, but is the msdn recommended way of doing calculations
  // on dates.
  FILETIME  fnow;
  if(!SystemTimeToFileTime(&sysnow, &fnow))
  {
    fprintf(stderr, "SystemTimeToFileTime failed: %i\n", GetLastError());
    t = 0;
    return;
  }

  ULARGE_INTEGER now;  // so we can do some maths

  assert(sizeof(now) == sizeof(fnow));
  memcpy(&now, &fnow, sizeof(now));

  // and now we have a big integer containing an offset jan 1, 1601 (UTC)
  // 100 nanosecond intervals
  t = now.QuadPart*MIL*10;  // *10 to microseconds, *MIL to seconds
}

void
win_timer_queue::add_abs_sleep_request(sleep_task* st, double when)
{
  // win timer queue works with relative offsets, so convert this absolute
  double  now;
  get_time(now);
  double  delta = when-now;
  if(delta < 0.0) delta = 0.0;
  add_sleep_request(st, delta);
}

}}
@h=tangler('demux/demux_demuxer.cpp')
@select(h)
#include "demux_demuxer.hpp"

// nothing here atm ..

@h=tangler('demux/demux_epoll_demuxer.cpp')
@select(h)
// epoll interface. does epoll support ordinary files in addition to sockets?
// EPOLLET to make epoll edgetriggered. I guess the default is level triggered.

// epoll events are not one shot, in fact they're quite sticky so socket
// filters must be removed manually to guarantee a one-to-one wakeup
// to add_wakeup ratio. note that the oneshot flag is not a solution.

// cool! EPOLLONESHOT
// BUGGER! doesn't seem to exist! and doing this doesn't make it so!
// #ifndef EPOLLONESHOT
// #define EPOLLONESHOT (1<<30)
// #endif

#include "demux_epoll_demuxer.hpp"

#include <sys/epoll.h>  // for epoll_*
#include <stdio.h>    // for perror
#include <unistd.h>   // for close
#include <errno.h>    // EEXIST, errno

namespace flx { namespace demux {

epoll_demuxer::epoll_demuxer()
  : epoll_fd(-1)
{
  // EPOLLONESHOT is shit, don't use it. Enabling it just means that your
  // wakeups are suppressed and you have to use EPOLL_CTL_MOD instead
  // of EPOLL_CTL_ADD. If it isn't defined then so much the better.
//#ifdef EPOLLONESHOT
//  fprintf(stderr,"WARNING: EPOLLONESHOT AVAILABLE (%x)!!!\n", EPOLLONESHOT);
//#endif

  // god knows what the maximum size will be, I'll just say 1 for now
  epoll_fd = epoll_create(1);
  if(-1 == epoll_fd)
  {
    perror("epoll_create");
    throw -1;
  }
}

epoll_demuxer::~epoll_demuxer()
{
  if(-1 != epoll_fd)
  {
    if(close(epoll_fd) != 0)
      perror("epoll close");
  }
}

int
epoll_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  int s = sv->s;

  struct epoll_event  evt;
  // fprintf(stderr,"add_socket_wakeup: %i (sv=%p, flags=%x)\n",
  //  s, sv, flags);

  // EPOLLONESHOT saves us not only a system call to remove epoll evts,
  // which aren't intrinsically one-shot, but having to do it ourselves
  // would have been a pain as epoll doesn't tell you which fd had the event
  // this way we can get away with not knowing & not losing our user cookie
  evt.events = 0;
  
  if(flags & PDEMUX_READ) evt.events |= EPOLLIN;
  if(flags & PDEMUX_WRITE) evt.events |= EPOLLOUT;

  // fprintf(stderr, "flags %x -> evt.events %x\n", flags, evt.events);

  // We do the remove manually because oneshot in epoll doesn't
  // remove the socket, but rather, disables it.
//#ifdef EPOLLONESHOT
//  evt.events |= EPOLLONESHOT;         // yes!
//#endif
  // I think EPOLLHUP comes when the connection closes (on read?)
// poll's (plain old poll) equivalents to this are ignored for input
// same here?
  // I get EPOLLHUPs for bad async connects whether I ask for them or not.
  evt.events |= (EPOLLHUP | EPOLLERR);    // I think I want this

  evt.data.ptr = sv;              // our user data

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, s, &evt) == -1)
  {
    // EPOLL_CTL_MOD cannot help us do bidirection io on one socket,
    // the mod will overwrite the old user cookie and direction. 
    // It seems that only kqueues, select and iocps allow that.
    // Will need a wakeup that can do both, oneshot that indicates
    // the available direction.
// when using oneshot, we're supposed to use EPOLL_CTL_MOD
#if 0
    int err = errno;

    if(EEXIST == err)
    {
      // ok - let's try EPOLL_CTL_MOD
      fprintf(stderr, "RETRYING WITH EPOLL_CTL_MOD\n");
      if(epoll_ctl(epoll_fd, EPOLL_CTL_MOD, s, &evt) != -1)
        return 0; // good!
    }
#endif
    perror("epoll_ctl (add)");
    
    return -1;
  }
  return 0;
}

// epoll doesn't differentiate on events. I bet I could
// just not pass that event...
void
epoll_demuxer::remove_wakeup(int s)
{
  // EPOLL_CTL_DEL uses no information from the event
  // and so I should be able to pass NULL.
  // struct epoll_event evt;
  // evt.events = (read) ? EPOLLIN : EPOLLOUT;

  // fprintf(stderr,"removing socket wakeup %i\n", s);

  if(epoll_ctl(epoll_fd, EPOLL_CTL_DEL, s, NULL) == -1)
  {
    //const char* str = (read) ? "epoll_ctl (remove read)"
    //  : "epoll_ctl (remove write)";
    // perror(str);
    perror("epoll_ctl (remove)");
  }
}

void
epoll_demuxer::get_evts(bool poll)
{
  struct epoll_event  evt;

  switch(epoll_wait(epoll_fd, &evt, 1, (poll) ? 0 : ~0))
  {
    case -1:    // error
    perror("epoll_wait");
      // fall through
    case 0:     // no events (happens with timeout)
      return;
  }

  socket_wakeup* sv = (socket_wakeup*)evt.data.ptr;
  
  // not seeing timeouts as they're filtered by the switching.
  // assuming that sv is good
  // fprintf(stderr,"wakeup (sv=%p, sv->s=%i evt.events=%x)!\n",
  //  sv, sv->s, evt.events);

  // accumulate bit field of what we got
  sv->wakeup_flags = 0;

  bool  wake = false;
  
  // it might be possible to get both a read & write event...
  // in which case I should take out the else below
  if(evt.events & EPOLLIN)                // I think this is how you do it
  {
    // fprintf(stderr,"EPOLLIN for %p\n", sv);
    sv->wakeup_flags |= PDEMUX_READ;
    wake = true;
  }

  if(evt.events & EPOLLOUT)
  {
    //fprintf(stderr,"EPOLLOUT for %p\n", sv);
    sv->wakeup_flags |= PDEMUX_WRITE;
    wake = true;
  }

  // Is this for shutdown or closing of the other end?
  // I get it for failed async connects. I don't know if other events cause
  // it. In any case, I don't know whether it should be for read or write,
  // so I just don't say. In any case, it should wake to get error.
  // I seem to get both EPOLLHUP and EPOLLERROR on bad async connect
  if(evt.events & EPOLLHUP)
  {
    fprintf(stderr, "EPOLLHUP for %p->%i\n", sv, sv->s);
    wake = true;
  }

  if(evt.events & EPOLLERR)
  {
// How do I retrieve the error?
    // There's no ambiguity - there's only ever one fd in a given epoll.
    // If oneshot's present then don't need to do anything
// not sure what to do here. if we've enabled/got oneshot the socket
// should already have been removed
    fprintf(stderr,"epoll error, waking: %i (errno?)\n", sv->s);
    // similar story to EPOLLHUP
    wake = true;
  }

    if((evt.events & ~(EPOLLERR|EPOLLIN|EPOLLOUT|EPOLLHUP)))
    {
        fprintf(stderr,"unknown events in epoll_demuxer %x\n", evt.events);
    }

  // we got something. tell the people.
  // not dependent solely on wakeup_flags - errors need to wake too.
  if(wake)
  {
    // we got something. better call wakeup, must remove to guarantee
    // 1-1 wakeups with add_sockets
    // fprintf(stderr, "no one-shot... remove %i\n", sv->s);
    remove_wakeup(sv->s);
    // fprintf(stderr, "calling wakeup (flags=%x)\n", sv->wakeup_flags);
    sv->wakeup(*this);
  }
}
}}

@h=tangler('demux/demux_evtport_demuxer.cpp')
@select(h)
// Evtports can get timer wakeups with PORT_SOURCE_TIMER.
// Can also pick up aio notifications with PORT_SOURCE_AIO.

// looks like this stuff is only in solaris10, and not SunOS 5.8. Damn.

#include "demux_evtport_demuxer.hpp"

#include <port.h>
#include <poll.h> // POLLIN/POLLOUT
#include <stdio.h>  // printf
#include <unistd.h> // close
#include <assert.h>

namespace flx { namespace demux {

// header files for this stuff?
// can use port_send for user defined events, to wake up reap loop
// truss to see what's happening

evtport_demuxer::evtport_demuxer()
{
  if((evtport = port_create()) < 0)
  {
    perror("port_create");
    throw -1;
  }
}

evtport_demuxer::~evtport_demuxer()
{
  if(-1 != evtport)
  {
    if(close(evtport) != 0)
      perror("evtport close");
  }
}

int
evtport_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  if(flags & ~(PDEMUX_READ|PDEMUX_WRITE)) // I can't understand you, lady!
    return -1;

  int events = 0; // events are flags so we can accumulate them
  int s = sv->s;

  if(flags & PDEMUX_READ) events |= POLLIN;
  if(flags & PDEMUX_WRITE) events |= POLLOUT;

  // POLLHUP might make sense only for reads... add conditionally?
  events |= (POLLHUP | POLLERR);

  // fprintf(stderr,"add_socket_wakeup: %i, sv: %p (%x)\n", s, sv, flags);

  // register for event we are interested in...
  // works for files, sockets, timers...
  // sockets are file descriptors in unix, so src is PORT_SOURCE_FD
  if(port_associate(evtport, PORT_SOURCE_FD, (uintptr_t)s, events, sv) == -1)
  {
    perror("add socket_wakeup/port_associate");
    return -1;
  }

  return 0;
}

// note that these two functions are exactly the same
// we have to remove after a read or write else we can get multiple
// wakeups - usually with a dud user cookie. the fact that there is
// no differentiation between POLLIN & POLLOUT could be a problem for
// mixed read/write things (rare). note that evt_ports let me associate
// the samething twice. I don't know if this means you have to dissociate
// (disassociate) twice.
void
evtport_demuxer::remove_wakeup(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("reading port_dissociate");
}

#define POLLPR(ev) if(e->portev_events & ev) fprintf(stderr,#ev", ")

static void
print_port_evt(port_event_t* e)
{
  char* srcstr[PORT_SOURCE_ALERT-PORT_SOURCE_AIO+1]
    = { "ALERT", "TIMER", "USER", "FD", "AIO"};
  fprintf(stderr,"e: %p\n\t", e);
  //fprintf(stderr,"portev_events: %x\n\t", e->portev_events);
  fprintf(stderr,"portev_events: ");

  // I got these constants from the poll.h file
  POLLPR(POLLIN); POLLPR(POLLOUT); POLLPR(POLLPRI);
  POLLPR(POLLRDNORM); POLLPR(POLLRDBAND); POLLPR(POLLWRBAND);

  // in poll these are in a different field. port_event_t doesn't
  // have that field, so lets try here.
  POLLPR(POLLERR); POLLPR(POLLHUP); POLLPR(POLLNVAL); POLLPR(POLLREMOVE);

  fprintf(stderr," (%x)\n\t", e->portev_events);
  
  int src = e->portev_source;
  if(PORT_SOURCE_AIO <= src && src <= PORT_SOURCE_ALERT)
  {
    fprintf(stderr,"portev_source: PORT_SOURCE_%s (%x)\n\t",
      srcstr[src-PORT_SOURCE_AIO], src);
  }
  else
  {
    fprintf(stderr,"portev_source: %x\n\t", e->portev_source);
  }

  fprintf(stderr,"portev_pad: %x\n\t", e->portev_pad);
  // often our socket
  fprintf(stderr,"portev_object: %x\n\t", e->portev_object);
  fprintf(stderr,"portev_user: %p\n", e->portev_user);
}

void
evtport_demuxer::get_evts(bool poll)
{
  // Block until a single event appears on the port. Event will not fire
  // again, so we get max 1 wakeup per event added.

  port_event_t  evt;
  timespec    timeout, *tp = NULL;

  if(poll)    // effect a poll
  {
    timeout.tv_sec = 0;
    timeout.tv_nsec = 0;
    tp = &timeout;
  }

  // wait for single event, no timeout
  if(port_get(evtport, &evt, tp) == -1)
  {
    perror("port_get");
    return;
  }

  // fprintf(stderr,"PORT_GET RETURNED: "); print_port_evt(&evt);

  // get wakeup obj tucked away in the user cookie.
  socket_wakeup*  sv = (socket_wakeup*)evt.portev_user;
  int       s = evt.portev_object;

  assert(sv != NULL);
  if(evt.portev_source != PORT_SOURCE_FD)
  {
    // when polling I often end up in here - we get an unknown evt
    // source and a POLLNVAL event plus lots of other unknown flags.
    // there's interesting looking stuff in the user field and so on,
    // but it's nothing of mine and also undocumented
    // fprintf(stderr,"got non PORT_SOURCE_FD (s=%i, sv=%p, src=%i)\n",
    //  s, sv, evt.portev_source);
    // fprintf(stderr, "skipping out...\n");
    return;
  }


  // let's see what we've got for the wakeup
  sv->wakeup_flags = 0;

  if(evt.portev_events & POLLERR)
  {
    fprintf(stderr,"ERRORS on s = %i, sv = %p\n", s, sv); 
    //evt.portev_events &= ~POLLERR;
    //return;
  }

  // for bidirectional wakeups, we should be able to get both
  // POLLIN and POLLOUT at the same time, but I've not yet
  // seen it happen, they're coming in one at a time for me.


  if(evt.portev_events & POLLIN)
  {
    // fprintf(stderr,"GOT POLLIN FOR %p\n", sv);
    sv->wakeup_flags |= PDEMUX_READ;
  }

  if(evt.portev_events & POLLOUT)
  {
    // fprintf(stderr,"GOT POLLOUT FOR %p\n", sv);
    sv->wakeup_flags |= PDEMUX_WRITE;
  }

  // I never asked for POLLERR, but anyway
  if(evt.portev_events & ~(POLLIN | POLLOUT | POLLERR))
    {
        fprintf(stderr,"UNSOLICITED events in evtport_demuxer (%x)\n",
      evt.portev_events);
    }

  assert(sv->wakeup_flags != 0);    // we should've gotten SOMETHING.

  if(sv->wakeup_flags)  
    sv->wakeup(*this);
}
}}

@h=tangler('demux/demux_iocp_demuxer.cpp')
@select(h)
#include "demux_iocp_demuxer.hpp"
#include "demux_mutex.hpp"

#include <stdio.h>      // for printf debugging
#include <stddef.h>     // offsetof
#include <assert.h>
// shoving the win_queue in here for now

namespace flx { namespace demux {

// this could really do with auto objs. steal the strat stuff?

// add windows error processing macros. It's a bore otherwise.

// WaitForSingleObject on an kill event in the thread for thread cancel
// kill_event = CreateEvent(NULL, TRUE, FALSE, NULL); (what's that)
// SetEvent(kill_event) to invoke (?): SetEvent sets the event to the 
// signalled state. Return value is success flag. GetLastError.

// do auto SOCKET wrapper, check closesocket return code.

// a completion port is a queue into which the os puts notifications of
// completed overlapped io requests. once the operation completes, a
// notification is sent to a worker thread that can process the result.
// a socket may be associated with a completion port at any point after
// creation.


// I don't see how to nicely stop a thread, I may have to have my own protocol
// to ask it to exit.

// PostQueuedCompletionStatus can be used by threads to wake up a worker
// thread. Could be handy replacement for timeout. "useful for notifying
// worker threads of external events"

// working through this: http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/
// example of worker thread here
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/i_o_completion_ports.asp
// nono, use this onec
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// oh, wait they're the same
// FormatMessge

winsock_initer::winsock_initer()
{
  WSADATA wsaData;

  // apparently 2.2's the way to go
  if(WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
  {
    int err = WSAGetLastError();
    fprintf(stderr,"couldn't find usable winsock dll: %i\n", err);
    throw err;
  }
}

winsock_initer::~winsock_initer()
{
  if(WSACleanup() != 0)
  {
    fprintf(stderr,"WSACleanup failed %i\n", WSAGetLastError());
  }
}

// iocp_wakeup base class for users of iocp_demuxer
//static
iocp_wakeup*
iocp_wakeup::from_overlapped(LPOVERLAPPED olp)
{
  // calculate the address of this from overlapped member
  // suffer an obligatory offsestof warning from broken gccs.
  return (iocp_wakeup*)((char*)olp-offsetof(iocp_wakeup, ol));
}

void
iocp_wakeup::clear_overlapped()
{
  ZeroMemory(&ol, sizeof(ol));  // much better than memset, right?
}


iocp_demuxer::iocp_demuxer()
  : iocp(NULL)
{
  // Create the completion port
  // not sure what first 3 args do, but by specifying INVALID_HANDLE_VALUE
  // for the first I think I can ignore the rest (apart from the last, numthreads)
  // I still have to create the threads, but only NumberOfConcurrentThreads
  // will wake up from GetQueuedCompletionStatus at a time. This looks to be
  // slightly elastic...
// NT 3.51 doesn't let you pass null filehandle, you've got to have a dummy
// socket. keep that in mind. see InitializeIOCP in IOCPServer.cpp example
// taken from codeproject. GetSystemInfo to find out num CPUs
  fprintf(stderr,"CreateIoCompletionPort with ONE WORKER THREAD\n");
  iocp = CreateIoCompletionPort(
    INVALID_HANDLE_VALUE,
    NULL,
    (ULONG_PTR)0,
    1       // 1 thread (zero means one for each CPU)
  );

  if(NULL == iocp)
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed to create completion port: %li\n", err);
    throw -1;
  }
}

iocp_demuxer::~iocp_demuxer()
{
fprintf(stderr, "~iocp\n");
  if(NULL != iocp && !CloseHandle(iocp))
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed cleanup iocp: %li\n", err);
  }
}

int
iocp_demuxer::associate_with_iocp(HANDLE obj, ULONG_PTR udat)
{
  // fprintf(stderr, "associating with iocp=%p: %p, udat: %lx\n",
  //  iocp, obj, udat);

  // Any overlapped operations performed on the object will use the
  // completion port for notification. The 3rd param can be used to pass
  // per object context information. we'll just pass that back.
  if(CreateIoCompletionPort(obj, iocp, udat, 0) == NULL) {
    // adding the same obj twice without an intervening get completion
    // status wakup gets an error 87, ERROR_INVALID_PARAMETER
    fprintf(stderr,"CreateIoCompletionPort failed to register object: %li\n",
      GetLastError());
    return -1;
  }

  return 0;
}

void
iocp_demuxer::get_evts(bool poll) {
  // with multiple threads, this will actually wake up the last to
  // block (lifo)

  // get context, call worker_thread 
  // need to be able to tell which thing completed, can have extra data
  // following some kind of struct
  // get this pointer

  // I guess to avoid swapping of thread context. By calling this on a given
  // completion port this thread is associated with it until exit or respec
  DWORD     nbytes;   // number of bytes in io transaction
  ULONG_PTR     udat;   // user data - not using this atm
  LPOVERLAPPED  olp;    // we get iocp_wakeup from this.

// If a socket handle associated with a completion port is closed,
// GetQueuedCompletionStatus returns ERROR_SUCCESS, with *lpOverlapped
// non-NULL and lpNumberOfBytes equal zero.
  
  int err = NO_ERROR;

  // No timeout. What does false mean? Eh. Could need a timeout to bring
  // the thread down.
  if(!GetQueuedCompletionStatus(iocp, &nbytes, &udat, &olp, 
    (poll) ? 0: INFINITE))
  {
    // That's strange - I sometimes get my ConnectEx errors popping
    // out here (ERROR_SEM_TIMEOUT=121, ERROR_CONNECTION_REFUSED=1225)
    // it looks like my args (overlapped, etc) are still filled out, so
    // I can still awake the sleeper
    err = GetLastError();   // doco says this & not WSALastError.

    // let's see: yep - there's my overlapped
    // fprintf(stderr,"!iocp::wait: nbytes=%li, udat=%lx, io=%p, err=%i\n",
    //  nbytes, udat, olp, err);

    if(WAIT_TIMEOUT == err)
    {
      // we get this a lot now that we can poll the iocp, so no output
      // interestingly, nbytes = 1. what could that mean?
      return;         // no wakeup
    }
    else if(ERROR_OPERATION_ABORTED == err)
    {
      // that's real bad manners. Or I could just ignore it. Anyway,
      // any overlapped received is stale.
      fprintf(stderr, "WHOA!!! - disassociate before killing handle\n");
      return;         // no wakeup
    }
    else
    {
      fprintf(stderr,"GetQueuedCompletionStatus returned false: %i\n",
        err);
      // return here? relying on olp being NULL, to stop us dereffing
    }

    // I'm going to assume that there's a good wakeup, and fall through
    // We need to wakeup on some errors (like ERROR_CONNECTION_REFUSED)
    // FALL THROUGH
  }

// An IOCP is a very general event mechanism. It tells you not only about
// the completion of reads & writes, but also of pretty much any asynchronous
// event's completion. It doesn't quite fit in with my select style interfaces.
// I've got general overlapped things completing here. I don't want them to
// know about demuxers & so forth so I'll have to know about them.

  //fprintf(stderr,"HOLEY! Woke up!\n");
  //fprintf(stderr,"nbytes=%li, udat=%lx, olp=%p, err=%i\n",
  //  nbytes, udat, olp, err);

  // with polling it's normal not to get an overlapped pointer, because
  // we may simply have timed out
  assert( olp );

  // tell someone that some overlapped op finished
  iocp_wakeup*  wakeup = iocp_wakeup::from_overlapped(olp);

  // passing olp may be redundant, seeing as it's contained in iocp_wakeup
  wakeup->iocp_op_finished(nbytes, udat, olp, err);
}



// simple utility fn, shouldn't be here. creates listener on any interface.
// this could benifit from a SOCKET class. in failure returns INVALID_SOCKET
// CURRENTLY EATS ERROR, SO DON'T BOTHER CHECKING
SOCKET
create_listener_socket(int* io_port, int backlog)
{
  fprintf(stderr,"creating_listener_socket\n");
  SOCKET        listener;

  // could use WSASocket, but these seem to be turning out overlapped anyway
  // at least after tangling with overlapped functions.
  // socket returns INVALID_SOCKET on failure.
  listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if (INVALID_SOCKET == listener)
  {
    fprintf(stderr,"listener create failed: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  SOCKADDR_IN   addr;

  // msdn code examples don't zero the sockaddr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(*io_port);

  // bind our name to the socket
  int         res;
  res = bind(listener, (LPSOCKADDR)&addr, sizeof(addr));

  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"bind() failed %i\n", WSAGetLastError());
    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }
    return INVALID_SOCKET;
  }

  // if user wanted port chosen tell them what it turned out to be
  if(0 == *io_port)
  {
    int namelen;

    if (getsockname(listener, (struct sockaddr *)&addr, &namelen) 
      == SOCKET_ERROR)
    {
      fprintf(stderr, "getsockname failed (%i)\n", WSAGetLastError());

      if(closesocket(listener) == SOCKET_ERROR)
      {
        fprintf(stderr,"closesocket failed on listener: %i\n",
          WSAGetLastError());
      }
      return INVALID_SOCKET;
    }

    *io_port = ntohs(addr.sin_port);
  }

  // Set the socket to listen
  res = listen(listener, backlog);
  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"listen() failed %i\n", WSAGetLastError());

    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }

    return INVALID_SOCKET;
  }

  return listener;
}

// currently the following aren't used. Look forward to warnings
// about them.

// the posix version of this made the socket nonblocking.
// I don't seem to have to do that when using iocp. if you
// want to create a nonblocking socket (or overlapped) pass
// WSA_FLAG_OVERLAPPED to WSASocket. I've never had to
// actually do this. How do you make accept do this? (supposing
// you wanted to) WSAAccept doesn't have a flag for it (however
// it does let you do conditional accepting). 
// There doesn't seem to be a sockopt
// returns INVALID_SOCKET on failure. eats the err.
SOCKET
nice_accept(SOCKET listener)
{
  struct sockaddr_in  remoteaddr;
  int         addrlen = sizeof(remoteaddr);
  SOCKET        s;
  
  // accept returns INVALID_SOCKET when it fails
  s = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);

  if(INVALID_SOCKET == s)
  {
    fprintf(stderr,"nice_accept failed (%i)\n", WSAGetLastError());
  }

  // the posix version makes the socket nonblocking here
  // we're not bothering

  return s;
}

// returns SOCKET_ERROR on failure, with err in WSAGetLastError()
static int
connect_sock(SOCKET s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

// returns INVALID_SOCKET on failure, eats last error with WSAGetLastError
// unlike the posix version, this does not make the socket nonblocking.
SOCKET
nice_connect(const char* addr, int port)
{
  SOCKET      s;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != INVALID_SOCKET
    && connect_sock(s, addr, port) != SOCKET_ERROR)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  fprintf(stderr,"nice_connect failed (%i)\n", WSAGetLastError());

  if(INVALID_SOCKET != s && closesocket(s) == SOCKET_ERROR)
    fprintf(stderr,"nice close failed (%i)\n", WSAGetLastError());

  return INVALID_SOCKET;
}

// returns -1 on error with errno in WSAGetLastError. 0 otherwise.
// kind of crap.
int
set_tcp_nodelay(int s, int disable)
{
  BOOL  disable_nagle = (disable) ? true : false;

  int res = setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
      (const char*)&disable_nagle, sizeof(disable_nagle));

  return (res == SOCKET_ERROR) ? -1 : 0;
}
}}

@h=tangler('demux/demux_overlapped.cpp')
@select(h)
#include "demux_overlapped.hpp"
#include <stdio.h>      // fprintf
#include <assert.h>

// cygwin's copy of mswsock.h leaves something to be desired...
#ifndef WSAID_CONNECTEX
typedef 
BOOL
(PASCAL FAR * LPFN_CONNECTEX) (
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen,
    IN PVOID lpSendBuffer OPTIONAL,
    IN DWORD dwSendDataLength,
    OUT LPDWORD lpdwBytesSent,
    IN LPOVERLAPPED lpOverlapped 
    );

#define WSAID_CONNECTEX \           
    {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
#endif

namespace flx { namespace demux {

// windows includes files here? vs will be fussy.

// AcceptEx

// return async finished flag (error flags - can be transmitted via class)
// AcceptEx is the way to get accept connections via the IOCP
bool
acceptex_control_block::start_overlapped()
{
  clear_overlapped();

// I've seen two examples get the pointer to AcceptEx, just in case it
// isn't implemented...
  // fprintf(stderr,"AcceptExing: listen backlog => can succeed immediately\n");

  // this is only set when acceptex receives data and returns immediately.
  // can't hurt to set it.
  DWORD nbytes = 0;
  BOOL  success;

  // note that in order to get the wakeup packet, the listener must
  // already be associated with the iocp. for future async io, the acceptor
  // must be associated too.
  success = AcceptEx(listener, acceptor,
    accept_buf,       // required - near/far address
    0,            // receive data size - don't yet want this
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    &nbytes,        // only set if fn completes. should be 0
    &ol);         // oblig. gets us back to the this ptr

  // if there is a backlog of connections, AcceptEx can return immediately
  if(success)
  {
    // must clear the wait
    fprintf(stderr,"WHOA! AcceptEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "This could be bad, as wait should call op_finish\n");
    fprintf(stderr, "We also lose the udat cookie (set to NULL)\n");
    // handle the successful wakeup
    // complete_async_op(demux, drv, nbytes, NO_ERROR); 
    // I hope they don't want the udat pointer, because I
    // just made it up (0=NULL). Not using it anyway.
    iocp_op_finished(nbytes, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();
    // can also return WSACONNRESET, which isn't so bad
    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"AcceptEx returned ERROR_IO_PENDING - that's normal\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      fprintf(stderr,"AcceptEx failed: %i\n", err);
      fprintf(stderr,"returning true should wake thread to detect failure.\n");
      return true;    // have self woken
    }
  }
  return false;       // async not finished

}

// ConnectEx
#if 0
// apparently we're supposed to do this now to make the acceptee inherit
// the listener's state. it is currently in the default state
//err = setsockopt( sAcceptSocket, 
//  SOL_SOCKET, 
//  SO_UPDATE_ACCEPT_CONTEXT, 
//  (char *)&sListenSocket, 
//  sizeof(sListenSocket) );
#endif

// what a pain in the arse (zzz)
// This doesn't exist in win2000, so it'll need to be synchronous there.
static int
GetConnectExAddr(SOCKET s, LPFN_CONNECTEX* conn_fn)
{
  *conn_fn = NULL;
  GUID      GuidConnectEx = WSAID_CONNECTEX;   
  DWORD     dwBytes;
  int       err;

  err = WSAIoctl(s,   // why do I need this?
    SIO_GET_EXTENSION_FUNCTION_POINTER,
    &GuidConnectEx,
    sizeof(GuidConnectEx),
    conn_fn,
    sizeof(*conn_fn),
    &dwBytes,
    NULL, NULL);    // no overlapped, no completion fun ptr
//  fprintf(stderr,"Get addr dwbytes: %li\n", dwBytes);
  return err;
}

// this is the weirdest. To use ConnectEx, the socket must be already bound.
// By trial and error, I found that it had to be bound to INADDR_ANY: 0.
// So strange. Apparently I don't have to do it again if I want to reuse.
static int
bind_socket(SOCKET s)
{
  SOCKADDR_IN   addr;

  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(0);

  return bind(s, (LPSOCKADDR)&addr, sizeof(addr));
}

bool
connectex_control_block::start_overlapped()
{
  clear_overlapped();

  // why not get this directly from the ConnectEx?
  socket_err = ERROR_IO_PENDING;


  DWORD bytes_sent = 0;   // we're not sending data on connect (yet)
  BOOL  success;

  LPFN_CONNECTEX  pfConnectEx;

  // unfortunate, will fix up later.
  // fprintf(stderr,"Getting ConnectEx address\n");

  // Turns out that ConnectEx isn't defined anywhere; I have to load its
  // addr via WSAIoctl
  // this is a bad way. make the driver cache it. why on earth is this
  // call per-socket? does it really need to be that way?
  if(GetConnectExAddr(s, &pfConnectEx) == SOCKET_ERROR)
  {
    fprintf(stderr,"GetConnectExAddr failed: %i\n", WSAGetLastError());
    return true;
  }

  // fprintf(stderr,"about to connectex to %s:%i, %i\n", addy, p, s);

  // this is so strange - I have to bind the socket to the localhost.
  // if I don't, ConnectEx returns EINVAL. in any case, I won't need
  // to do this again if I reuse this socket.
  if(bind_socket(s) == SOCKET_ERROR)
    fprintf(stderr,"ConnectEx bind failed: %i\n", WSAGetLastError());

  // I hope ConnectEx doesn't want this to hang around, because it's
  // going to drop off the stack after this.
  SOCKADDR_IN   addr;

  // some examples don't zero the addr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr(addy);
  addr.sin_port = htons(p);

  // in order to receive the wakeup packet, s must already be associated
  // with the iocp. this is best done at socket creation time. for these
  // sockets it's probably best to also bind them at the same time.
  // that requires "purposed" sockets (CreateConnectSocket?).
  // p.s. the default (waio_base) wakeup is doing fine for now.

  success = (*pfConnectEx)(s, // socket
    (LPSOCKADDR)&addr,    // connect address
    sizeof(addr),     // size thereof
    NULL,         // not sending any data yet, but we could
    0,            // ditto
    NULL,         // should be zero until this changes
    &ol);         // oblig. gets us back to the this ptr

// there's a caveat about the type of socket s becomes after ConnectEx.
// It's in some kind of default state and cannot be used with shutdown
// change it with setsockopt (?)
  if(success)
  {
    fprintf(stderr,"WHOA! ConnectEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "BAD: calls op_finish and loses udat cookie\n");
    // handle the successful wakeup. (udat=0, olp=&ol)
    iocp_op_finished(bytes_sent, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();

    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"ConnectEx pending...\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      // maybe store the error here. that could work for all
      // windows wakeups
      fprintf(stderr,"ConnectEx failed: %i\n", err);
      return true;    // have self woken
    }
  }
  return false;       // not finished
}

// TransmitFile

bool
transmitfile_control_block::start_overlapped()
{
  clear_overlapped();

  // 0 bytes => transmit entire file
  // the second zero means use the default chunk size
  // the NULL is for mem buffers to bookend the file with. nothing yet.
  // the final zero is for various flags, including a way of doing
  // DisconnectEx style socket reuse (more widely compatible?)

  // in order to receive the wakeup, s must already be associated with the
  // iocp. this is best done at socket creation time.
  if(TransmitFile(s, file, 0, 0, &ol, NULL, flags))
  {
    fprintf(stderr,"Transmit file succeeded immediately! waking...\n");
    return true;
  }
  else
  {
    DWORD err = WSAGetLastError();

    // will need to actually signal something
    // fprintf(stderr,"signal TransmitFile failure!\n");
    if(ERROR_IO_PENDING != err && WSA_IO_PENDING != err)
      fprintf(stderr,"genuine error from TransmitFile: %li\n", err);
  }
  return false;
}


// SOCKET io using WSASend and WSARecv

// windows style control blocks
wsasocketio_control_block::wsasocketio_control_block(SOCKET src, sel_param* pb,
  bool inread)
  : s(src), ppb(pb), reading(inread)
{
}

bool
wsasocketio_control_block::start_overlapped()
{
  clear_overlapped();

  error = 0;

  // num bytes received IF recv completes immediately.
  DWORD imm_bytes;
  int   recv_res;

  // set up the single wbuf, bearing in mind we may be part way.
  wbufs[0].len = ppb->buffer_size - ppb->bytes_written;
  wbufs[0].buf = ppb->buffer + ppb->bytes_written;

// fprintf(stderr, "sockio: %p->finished = %i, reading = %i\n",
//  ppb, ppb->finished(), reading);

  // Ideally, we would like to be able to use MSG_WAITALL, which would
  // let us only get a completion packet when either all the data was
  // available or the connection had been closed or shutdown.
  // Unfortunately this is not possible for non-blocking sockets, so
  // we have to take whatever we get and then call WSARecv again.

  //#define MSG_WAITALL 0   // not defined in cygwin - apparently this
  //DWORD flags = MSG_WAITALL;

  // ah, unfortunately MSG_WAITALL is not supported for non blocking sockets
  // we'll just have to do it ourselves
  DWORD flags = MSG_PARTIAL;

  // completion routines! (unused)
  if(reading)
    recv_res = WSARecv(s, wbufs, NUM_WBUFS, &imm_bytes, &flags, &ol, NULL);
  else
    recv_res = WSASend(s, wbufs, NUM_WBUFS, &imm_bytes, flags, &ol, NULL);

  // don't know if I need to check non winsock errs

  switch(recv_res)
  {
    case 0:
    {
      // flags are updated to indicate what? if there was a callback, it
      // would be scheduled to be called when this thread is in the
      // waitable state, whatever that means.
      //fprintf(stderr,
      //  "WSA%s completed immediately!!! nbytes: %li, flags: %lx\n",
      //    (reading) ? "Recv" : "Send", imm_bytes, flags);

      // looks like we get the completion packet even if we do finish
      // immediately so let the iocp wake us. note that this method
      // of manually calling iocp_op_finished is not so great as we
      // don't know the (as yet unused) udat cookie and so set it to 0.
      // fprintf(stderr, "calling finished manually (ppb=%p)\n", ppb);
      // iocp_op_finished(imm_bytes, 0, &ol, NO_ERROR); 

      // false because iocp_op_finished will wake us. I guess false from
      // these guys means that a completion packet is in the mail and
      // true means that it isn't (in the mail).
      return false;
    }
    break;
    case SOCKET_ERROR:
    {
      DWORD err = WSAGetLastError();

      // normal mode - wait for completion
      // fyi, xp pro seems to mostly give us ERROR_IO_PENDING
      if(ERROR_IO_PENDING == err || WSA_IO_PENDING == err)
      {
        // fprintf(stderr,"WSA%s pending completion (%li)\n",
        //  (reading) ? "Recv" : "Send", err);
        return false;     
      }

      fprintf(stderr,"WSARecv/Send returned SOCKET_ERR: %li\n", err);
      return true;    // assume it's bad and we won't get a wakeup
    }
    break;
    default:
    {
      fprintf(stderr,"WSARecv/Send returned other error: %i, GetLastError: %li\n",
        recv_res, GetLastError());
      return true;        // wake up
    }
    break;
  }

  return false;
}

// NB: called by iocp::wait, so be aware of which thread is doing what, lest
// you be surprised by this being called asynchronously.
void
wsasocketio_control_block::iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  error = err;        // copy back for others to look at.
                // perhaps move back to iocpwakeup
// fprintf(stderr, "wsasocketio::finished: ppb=%p, nbytes=%li, err=%i, read=%i\n",
//  ppb, nbytes, err, reading);

  if(err)
  {
    fprintf(stderr, "wsasocketio, got error: %i\n", err);
  }

  // fprintf(stderr,"wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );
assert( !ppb->finished() );
  // keep track of bytes received.
  ppb->bytes_written += nbytes;

  if(0 == nbytes)
  {
    fprintf(stderr, "wsaiosocket got zero bytes: err=%i, read=%i\n",
      err, reading);
  }

  // if we're not finished, we have to reinstall our request
  // zero bytes indicates shutdown/closure, right?
  // might be using this for WSASend. Instead of broken pipes on win32, 
  // instead we get WSAECONNRESET (pretty sure) on write. On read?
// not sure about this - I don't think we have to check nbytes == 0
  if(0 == nbytes || ppb->finished())
  {
    return;
  }
  else
  {
    // go back around again
    fprintf(stderr,"didn\'t get everything (%li of %li bytes)\n",
      ppb->bytes_written, ppb->buffer_size);
    if(start_overlapped())
    {
      fprintf(stderr, "UM, socket restart finished immediately\n");
      fprintf(stderr, "causes new wakeup? or should I loop around?\n");
    }
  }
}


// file io using ReadFile and WriteFile

winfileio_control_block::winfileio_control_block(HANDLE f, void* buf, int len, bool inread)
  : file(f), reading(inread)
{
  // pb is not so useful here. we only want to
  // know num bytes written/processed.
  pb.buffer = (char*)buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// if file is opened with FILE_FLAG_OVERLAPPED, we can do "immutable file ptr"
// ops & set the desired offset within the overlapped. can also stick an
// event to signal in there.
bool
winfileio_control_block::start_overlapped()
{
  fprintf(stderr,"trying out some read/write file\n");
  clear_overlapped();

  // DWORD  imm_bytes;
  BOOL  success;

  // don't need bytes read, written when we have an OVERLAPPED
  if(reading)
    // success = ReadFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = ReadFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
  else
    //success = WriteFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = WriteFile(file, pb.buffer, pb.buffer_size, NULL, &ol);

  // fprintf(stderr,"immbytes = %li\n", imm_bytes);

  if(!success)
  {
// this is probably going to be IOPENDING
    fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
      GetLastError());
    fprintf(stderr,"do I still get completion packet???\n");
    // assume not
    return true;      // ask for wakeup
  }

  return false;       // sleep on
}

}}

@h=tangler('demux/demux_overlapped.hpp')
@select(h)
#ifndef __DEMUX_OVERLAPPED__
#define __DEMUX_OVERLAPPED__
#include "flx_rtl_config.hpp"

// visual studio is quite sensitve about how you do these includes.
#include <WinSock2.h>              // Winsock2 (WSABufs, etc) must come before Windows.h
#include "demux_iocp_demuxer.hpp"  // this header file include Windows.h
#include <MSWSock.h>  // AcceptEx, TF_REUSE_SOCKET, etc

namespace flx { namespace demux {

// rename these to control block something or other
// get rid of default constructors - faio can worry about that.

// WARNING: in some "immediate completion" cases I have to call
// the finished function myself - in these cases I set the udat to 0, making
// it not very reliable. Either make sure the user understands immediate
// finish (and does it themselves) or keep a copy of udat.

// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class FLX_RTL_EXTERN acceptex_control_block : public iocp_wakeup {
  enum { ACCEPTEX_ADDR_SIZE = sizeof(SOCKADDR_IN) + 16 };

public:
  SOCKET  listener, acceptor;
  // there are two of these!
  char  accept_buf[2*ACCEPTEX_ADDR_SIZE];

  virtual bool start_overlapped();

  acceptex_control_block() 
    : listener(INVALID_SOCKET), acceptor(INVALID_SOCKET) {}
};

class FLX_RTL_EXTERN connectex_control_block : public iocp_wakeup
{
public:
  // move further back?
  int socket_err;         // outgoing

  // can have buffer to be sent on connection
  SOCKET    s;          // previously unbound socket
  const char* addy;       // ipv4 address
  int     p;          // port number

  // socket_err undefined
  connectex_control_block() : s(INVALID_SOCKET), addy(0), p(0) {}

  // see posix version of this, try to keep them in sync. give socket_err
  // initial definition that works with this?
  bool finished() { return ERROR_IO_PENDING != socket_err; }

  virtual bool start_overlapped();
};

// TransmitFile here (requires file handle)
class FLX_RTL_EXTERN transmitfile_control_block : public iocp_wakeup {
  SOCKET  s;
  HANDLE  file;
  DWORD flags;                // for possible socket reuse.
public:

  transmitfile_control_block(SOCKET dst)      // for reuse of socket
    : s(dst), file(NULL), flags(TF_DISCONNECT | TF_REUSE_SOCKET) {}

  transmitfile_control_block(SOCKET dst, HANDLE src)  // actual transmitfile
    : s(dst), file(src), flags(0) {}

  virtual bool start_overlapped();
};


// handles both WSASend & WSARecv
class FLX_RTL_EXTERN wsasocketio_control_block : public iocp_wakeup {
protected:
  enum { NUM_WBUFS = 1 }; // just one for now, but can do scattered send/recvs
  WSABUF    wbufs[NUM_WBUFS];
public:
  SOCKET    s;
  sel_param*  ppb;      // on input what you want, on output what you got
  int     error;
  bool    reading;  // else use WSASend

  // watch the memory interfaces here, going back and forth between threads.
  wsasocketio_control_block(SOCKET src, sel_param* pb, bool read);

  virtual bool start_overlapped();

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// looks a bit like wsasocketio_control_block (bad name, sends too)
class FLX_RTL_EXTERN winfileio_control_block : public iocp_wakeup {
  HANDLE    file;
  bool    reading;
public:
// probably should be a pointer (?)
  sel_param pb;

  // offset?
  winfileio_control_block(HANDLE f, void* buf, int len, bool read);

  virtual bool start_overlapped();

  //virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  //  LPOVERLAPPED olp, int err);
};

}}

#endif
@h=tangler('demux/demux_kqueue_demuxer.cpp')
@select(h)
// kqueue demuxer for bsd/os x
// N.B. calling close on a file descriptor will remove any kevents that
// reference that descriptor. that would explain remove complaining from
// time to time.
// try EV_EOF to pick up eofs, useful for async file io.

#include "demux_kqueue_demuxer.hpp"

#include <stdio.h>      // perror
#include <unistd.h>     // close

#include <sys/types.h>    // from the kqueue manpage
#include <sys/event.h>    // kernel events
#include <sys/time.h>   // timespec (kevent timeout)

// #include <sys/syscall.h> // syscall(SYC_close,kq) close workaround

namespace flx { namespace demux {
kqueue_demuxer::kqueue_demuxer()
  : kq(-1)
{
  // Not that you care, but this event queue is not inherited by
  // forked children.
  kq = kqueue();
  if(-1 == kq)
  {
    perror("kqueue");
    throw -1;
  }
}

kqueue_demuxer::~kqueue_demuxer()
{
  //if(syscall(SYS_close, kq) == -1)
  // I don't seem to be able to close a kq. can't fstat it either
  if(-1 != kq && close(kq) == -1)
    perror("kqueue close");
}


// Events of interest to us ERead, EWrite.
// ERead has fflags: NOTE_LOWAT, NOTE_EOF. ident is a descriptor (any?) 

// if you're using the kqueue_demuxer to do a single biderectional wakeup,
// be aware that it currently breaks the "one shot" rule, that is you
// make get an unexpected wakeup the next time you call wait.
int
kqueue_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // we only know these flags
  if((flags & ~(PDEMUX_READ | PDEMUX_WRITE))) return -1;

// could set wakeup_flags here of what's been installed!

  // FUCK - can only do one at a time with kqueues
  // For those doing both, if one fails, you're in a bit of trouble.
  if(flags & PDEMUX_READ)
  {
    if(add_kqueue_filter(sv, EVFILT_READ) == -1) return -1;
  }

  if(flags & PDEMUX_WRITE)
  {
    if(add_kqueue_filter(sv, EVFILT_WRITE) == -1) return -1;
  }

  return 0;
}

int
kqueue_demuxer::add_kqueue_filter(socket_wakeup* sv, short filter)
{
  int       s = sv->s;
  struct kevent evt;
  
  // this works just like select if the s is a listening socket
  // *except* works with all types of fds, including pipes, files & fifos
  // can set low water mark for reads with NOTE_LOWAT in fflags and size
  // in data. on return data contains number of bytes available to read
  // on return sets EV_EOF in flags if read dir socket has shutdown and
  // returns a possible socket err in fflags
  // should that be EV_ENABLE | EV_ADD. fflags zero cos I don't know what
  // to put there. pass pb in udata
  
  // adding EV_ONESHOT to save me removing on wakeup (a syscall).
  // I now require that during the evt be removed before wakeup fn.
  
  EV_SET(&evt, s, filter, EV_ADD | EV_ONESHOT, 0, 0, sv);
  // trying to detect when have reached eof with async file io using kq
  //EV_SET(&evt, s, EVFILT_READ, EV_ADD, | EV_ONESHOT NOTE_LOWAT, 16*1024, sv);

  // add event
  if(kevent(kq, &evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent add_kqueue_filter");
    return -1;
  }
  return 0;
}

// useful, but unused atm, thanks to ONESHOT.
// this function skirts the portability boundaries of the demux interface
// for kqueues each event monitor is identified (for sockets) by a pair,
// (s, filter), or for us, (s, {in|out}). This means that we can add
// individual wakeups for reading and writing but not both at once.
// I think epoll can do both, and so can select (and N/A to IOCPs).
// This "both at once" thing can't easily be one shot. There's a good
// case for this behaviour to be defined "undefined". Not many people
// using this part - could be caveat emptor...
int
kqueue_demuxer::remove_kqueue_filter(int s, short filter)
{
  struct kevent evt;

  EV_SET(&evt, s, filter, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent remove_socket_wakeup");
    return -1;
  }

  return 0;
}

int
kqueue_demuxer::remove_socket_wakeup(int s, int flags)
{
  int r1 = 0, r2 = 0;

  if(flags & PDEMUX_READ) r1 = remove_kqueue_filter(s, EVFILT_READ);
  if(flags & PDEMUX_WRITE) r2 = remove_kqueue_filter(s, EVFILT_WRITE);

  // If you want to know which one failed, you're out of luck.
  if(r1 || r2) return -1;

  return 0;
}

// from "advanced macos programming", on reading shutdown causes
// the EV_EOF flag to be set in the flags field and returns errno
// in the fflags field. There may still be pending data to read
// when EV_EOF is set. The data field says how many bytes available.
// for writing data says how much you can write. EV_EOF is set
// when the reader "disconnects". Says nothing about errno/fflags
// in this case.
/*
    fprintf(stderr,"readevt on %i, EOF = %s\n",
      s, (ev.flags & EV_EOF) ? "TRUE" : "FALSE");
 */

// do that thing where you get the events. can I get them one at a time?
// I bet I can.
void
kqueue_demuxer::get_evts(bool poll)
{
  // event seems to remain unless we remove it
  struct kevent ev;
  int       nevts;

  struct timespec timeout, *tptr = NULL;
  
  if(poll)
  {
    timeout.tv_sec = 0;   // effectuate a poll
    timeout.tv_nsec = 0;
    tptr = &timeout;
  }

  // timeout.tv_sec = 1;    // timeout every second
  // timeout.tv_nsec = 0; // 10^9 nanoseconds per second

  nevts = kevent(kq, NULL, 0, &ev, 1, tptr);  // wait or poll
  if(nevts <= 0)
  {
    // error, else timeout & return to allow cancel
    if(nevts < 0)
      perror("kevent event fetch");

    return;
  }

  // fprintf(stderr,"kqueue wakeup!\n");

  socket_wakeup*  sv = (socket_wakeup*)ev.udata;

  // The filters are not bit fields, hence they must come in serially.
  // this means you're never going to get both read and write on
  // a kqueue_demuxer wake up. No worries.
  if(ev.filter == EVFILT_READ)
  {
  // this capability is lost for the moment, as we have no way
  // of explaining it to felix. the event stuff isn't so good right now
/*
    // can chunk up on accepts. nice one kqueue
    if(NULL == sv)      // => listener
    {
      int backlog = (int)ev.data;   
      // fprintf(stderr,"kq listen backlog: %i\n", backlog);
      for(int i = 0; i < backlog; i++) handle_connection();
    }
    else
*/
    // If a socket wakeup were a control block, you'd set the err here.
    if(0 && ev.flags & EV_EOF)
    {
      // errno in fflags!
      fprintf(stderr,
        "got EV_EOF on read, %i bytes remain in buffer, errno=%i\n",
        (int)ev.data, ev.fflags);
    }
    // fprintf(stderr,"EVFILT_READ: got %i bytes coming\n", (int)ev.data);
    // remove_reading_fd(s);      // now useing EV_ONESHOT
// remove other outstanding here...?
    sv->wakeup_flags = PDEMUX_READ;   // Tell 'em what they've won.
    sv->wakeup(*this);
  }
  else if(ev.filter == EVFILT_WRITE)
  {
    // fprintf(stderr,"EVFILT_WRITE: can write (?) %i bytes\n",
    //  (int)ev.data);

    // using oneshot mode now.
    // remove_writing_fd(s);

    if(ev.flags & EV_EOF)
    {
      // errno in fflags? data should be zero bytes, right?
      // can't write anything
      fprintf(stderr,
        "got EV_EOF on write, data bytes =%i (0?), errno/fflags?=%i\n",
        (int)ev.data, ev.fflags);
    }
// remove other outstanding here?
    sv->wakeup_flags = PDEMUX_WRITE;
    sv->wakeup(*this);
  }
  else
  {
    fprintf(stderr,"unsolicited event from kqueue (%i)...\n", ev.filter);
    // no wakeup
  }
}
}}

@h=tangler('demux/demux_pfileio.cpp')
@select(h)
#include <stdio.h>    // printf
#include <errno.h>    // errno
#include "demux_pfileio.hpp"

// blocking reads & writes that use a worker fifo. users overload
// finished flag to implement wakeup

// if we could group the requests, we could do a scattered read
// or we could do single reads if the requests were of a similar
// nature, i.e. the whole file, of popular files.

// for pwrite/pread, I'm supposed to include the following three (osx man page)
// they don't appear to be necessary, but let's play it safe
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

namespace flx { namespace demux {
// fileio_request stuff follows

// read or write in a blocking fashion. I like the idea of using pread
// which doesn't change the file pointer. this could allow reuse of the same
// file descriptor & block caching

fileio_request::~fileio_request(){}
fileio_request::fileio_request(){}

fileio_request::fileio_request(int f, char* buf, long len, long off, bool rd)
  : offset(off), fd(f), read_flag(rd), err(0)
{
  pb.buffer = buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// synchronously process read/write
void
fileio_request::doit()
{
  // fprintf(stderr,"faio about to try to %s %i bytes from fd=%i\n",
  //  (read_flag) ? "read" : "write", pb.buffer_size, fd);

// switching off (explicit) seeks for now because I'm not using them
// in the flx code & I'm not passing around enough info (just the fd)
  ssize_t res;

  if(read_flag)
  {
    // res = pread(fd, pb.buffer, pb.buffer_size, offset);
    res = read(fd, pb.buffer, pb.buffer_size);
  }
  else
  {
    // res = pwrite(fd, pb.buffer, pb.buffer_size, offset);
    res = write(fd, pb.buffer, pb.buffer_size);
  }
  
  // zero return value indicates end of file. that should just work.
  if(-1 == res)
  {
    err = errno;    // grab errno
    fprintf(stderr,"faio error: %i\n", err);
  }
  else
  {
    // fprintf(stderr,"faio %s %i bytes\n", (read_flag) ? "read" : "write", res);
    pb.bytes_written = res;
  }
}
}}

@h=tangler('demux/demux_posix_demuxer.cpp')
@select(h)
#include "demux_posix_demuxer.hpp"
#include "demux_sockety.hpp"

#include <stdio.h>        // "printf"
#include <assert.h>       // assert
#include <string.h>       // strerror
#include <unistd.h>       // close

#include <sys/types.h>      // send/recv
#include <sys/socket.h>

//#include <sys/errno.h>
#include <errno.h>        // GUSI & solaris prefer this

namespace flx { namespace demux {

@tangle("typedef " + FLX_SOCKLEN_T + " FLX_SOCKLEN_T;")

posix_demuxer::~posix_demuxer()
{
}

bool
posix_demuxer::socket_recv(int s, sel_param* pb)
{
  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;
  
  // if this were read then this fn would work with non-sockets
  nbytes = recv(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written, 0);

  if(nbytes <= 0)
  {
    if(nbytes == 0)
    {
      return true;        // connection closed
    }
    else
    {
      perror("recv");       // can get reset connection here
      return true;        // so say closed, yeah?
    }
  }
  else
  {
    // got some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

bool
posix_demuxer::socket_send(int s, sel_param* pb)
{
  // kqueue (and some of the other ones) can let you know know how much
  // to write... imagine that!

  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;

  nbytes = send(s, pb->buffer + pb->bytes_written,
    pb->buffer_size - pb->bytes_written, 0);

  // similar story here, with send vs write?

  // what's the story with zero? Is that allowed or does it signal
  // that the connection closed?
  if(-1 == nbytes)
  {
    perror("send");
    return true;          // I guess the connection closed
  }
  else
  {
    // sent some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

#if 0
  //nbytes = recv(s, pb->buffer + pb->bytes_written,
  //      pb->buffer_size - pb->bytes_written, 0);

  // select and kqueue know when non socket fds have data.
  // recv only works with sockets, but read works with both files
  // and sockets and who knows what else. is there any disadvantage
  // to using read instead? apart from losing flags arg?
  // does read get the same 0 bytes = close behaviour
  nbytes = read(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written);
#endif

// handy posix control blocks for accept, connect.

int
accept_control_block::start(posix_demuxer& demux)
{
  // add listener to demuxer as reading socket - see man 2 accept
  // returns 0 on success, -1 on failure. not sure how to communicate
  // the error.
// could try the accept now, to see if it succeeds instantly...
// observe wakeup rules (formulate them first)
  accepted = -1;
  // socket_err = 0;
  // not quite true, but I want it to be clear if this ever becomes possible
  // to do immediately
  socket_err = EINPROGRESS;
    return demux.add_socket_wakeup(this, PDEMUX_READ);
}

// one wakeup socket is in accepted and error in socket_err
void
accept_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"accept_control_block woke up\n");

  // we can now accept without blocking
  // s is the listener, ambiguously named in parent socket_wakeup class
  accepted = nice_accept(s, &socket_err);

  if(accepted == -1)
  {
    fprintf(stderr, "nice_accept failed, err (%i)\n", socket_err);
  }
}

// returns -1 on failure, 0 on success. on success the call is finished
// (and so no wakeup) if socket_err == 0.
int
connect_control_block::start(posix_demuxer& demux)
{
  // fprintf(stderr,"async connect start\n");

  int finished;

  // returns either finished and err, or not finished
  // and (no err || EINPROGRESS)
  s = async_connect(addy, p, &finished, &socket_err);

  // fprintf(stderr,"async_connect returned s: %i, finished: %i, err=%i\n",
  //  s, finished, socket_err);

  if(-1 == s)   // failed!
  {
    fprintf(stderr,"async_connect failed (%i)\n", socket_err);
    return -1;  // error in socket_err, no wakeup
  }

  if(finished)
  {
    // this actually happens on solaris when connecting to localhost!
    fprintf(stderr,"async_connect finished immediately, waking\n");
    fprintf(stderr, "No wakeup coming...\n");
    // this does not indicate an error, but that there is no wakeup
    // coming. this could be done by a wakeup, all that happens is
    // getsockopt is called to check the socket's error state.
    return -1;          
  }

  // fprintf(stderr,"connect_request didn't finish immediatly, sleeping\n");

  // add to demuxer as writing socket - see man 2 connect
  // how do they get the error?
    return demux.add_socket_wakeup(this, PDEMUX_WRITE);
}

void
connect_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"connect woke up\n");
  // this is how we check the success of async connects
  // if get_socket_err fails, we're treating its errno as the socket's...
  if(get_socket_error(s, &socket_err) == -1)
    fprintf(stderr, "eep - get_socket_err failed!\n");

  // failed, throw away socket
  if(0 != socket_err)
  {
    fprintf(stderr,"async connect error: %s (%i), closing\n",
      strerror(socket_err), socket_err);
    // we created the connect socket, so we close it too.
    if(close(s) != 0)
      perror("async socket close");

    s = -1;   // the result
  }

  // resulting connected socket in s
}
}}

@h=tangler('demux/demux_select_demuxer.cpp')
@select(h)
// P.S. for current impl don't need the pthreads. WHOO!!!

// A very light wrapper around select, that allows the addition
// of new sockets and returns status in a queue.
// on the powerbook with 10.3, FD_SETSIZE is 1024, that means
// max 1024 sockets. That's kind of lame. See IO completion ports
// on NT for a better solution.

// See ACE_Handle_Set_Iterator for an optimised seelect bit field examination
// algorithm (p149 C++ network programming, volume1)

// see epoll, kqueue & IOCPs

// is select level triggered? I think it is.
// strangely, I'm never seeing anything from the exception set.

#include "demux_select_demuxer.hpp"

#include <assert.h>
#include <string.h>       // memset

#include <stdio.h>        // printf debug
#include <stdlib.h>
#include "demux_sockety.hpp"  // get_socket_error
#include <memory>

namespace flx { namespace demux {

select_demuxer::select_demuxer()
{
  // clear these guys. after the thread starts, access to them will have
  // to be via the lock
  FD_ZERO(&master_read_set);
  FD_ZERO(&master_write_set);
  FD_ZERO(&master_except_set);
  fdmax = 0;        // corresponds to stdin, which we're not using

  // clear this possibly quite large list
  //memset(svs, 0, sizeof(svs));
  //JS: memset must not be used except for raw data or chars
  std::uninitialized_fill_n(svs,FD_SETSIZE,(socket_wakeup*)0);
}

// one select, must not block indefinitely, so choose a timeslice
// or find a way to make it wake on command, like a dummy socket
void
select_demuxer::get_evts(bool poll)
{
  // to use select we must copy our arguments, as it changes them!
  // this code has been broken up in to pieces so that I can implement

  fd_set  read_set, write_set, except_set;

  copy_sets(read_set, write_set, except_set);
  
  if(select(read_set, write_set, except_set, poll))
    process_sets(read_set, write_set, except_set);
}

int
select_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  int s = sv->s;

  // fprintf(stderr, "adding select wakeup for %i, flags=%x\n", s, flags);

  if(s < 0 || s >= FD_SETSIZE) return -1; // weakness of select

  assert(svs[s] == NULL);         // sanity check: nothing there

  if(flags & PDEMUX_READ) FD_SET(s, &master_read_set);

  if(flags & PDEMUX_WRITE) FD_SET(s, &master_write_set);

  // does this mean we could add a non-reading, non-writing socket
  // and wait for errors on it?
  FD_SET(s, &master_except_set);

  svs[s] = sv;              // record wakeup. ours now.


  if(s > fdmax) fdmax = s;        // update highwater mark

  return 0;
}

// removes for both reading AND writing.
void
select_demuxer::remove_fd(int s)
{
  // fprintf(stderr, "removing select fd: %i\n", s);

  assert(s >= 0 && s < FD_SETSIZE);
  assert(svs[s] != NULL);         // there should be something there

  // clear them all regardless. 
  FD_CLR(s, &master_read_set);
  FD_CLR(s, &master_write_set);
  FD_CLR(s, &master_except_set);

  svs[s] = NULL;
}

// virtual functions to be overridden for thread safe descendent
void
select_demuxer::copy_sets(fd_set& rset, fd_set& wset, fd_set& exset)
{
  rset = master_read_set;
  wset = master_write_set;
  exset = master_except_set;
}

bool
select_demuxer::select(fd_set& rset, fd_set& wset, fd_set& exset, bool poll)
{
  // this is depending on my fake socket to wakeup. perhaps use the timer
  // for now.
  struct timeval  tv, *tp = NULL;
  //tv.tv_sec = 0;
  //tv.tv_usec = 1000000/100;

  if(poll)
  {
    tv.tv_sec = 0;
    tv.tv_usec = 0;
    tp = &tv;
  }
  
  // the return value here actually has significance
  // sometimes I have to try again, or weed out bad fds.
  //if(select(fdmax+1, &read_set, &write_set, &except_set, &tv) == -1)
// nah! wait forever. none of these things shutdown properly yet.
// it'll force the async new wakeup responsiveness
  switch(::select(fdmax+1, &rset, &wset, &exset, tp))
  {
    case 0:
      return false;   // timed out, don't process sets
    break;
    case -1:
    // not the ideal reaction. I think this is where I weed out
    // the bad socket(s). would need error set.

    // closing a socket without removing can get us here. that's pretty
    // nasty, because our data would be stale. Try not to do that. I
    // wonder if the except set would tell us when the socket was
    // closed on us? Damn, you have to clear it, else you keep getting
    // the same error.
      perror("select");
      // fall through and examine except set
    break;
  }
  return true;    // call process_sets
}

void
select_demuxer::process_sets(fd_set& rset, fd_set& wset, fd_set& exset)
{
  // since we're about to traverse the socket sets anyway, we should
  // note the highest fd seen, and make that the highwater mark.
  // that way we wouldn't be guaranteed monotonically degrading performance.

  // might be worth keeping a low water mark as well.
  // I guess this is why select sucks. On osx we can only watch
  // about 1024 sockets. That sucks too. could allocate larger sets
  // with malloc... see c++ network programming book.

  // like kqueues, this code could theoretically handle separate wakeups
  // for read and write, should I do it? not right now.
  int new_fdmax = 0;

  for(int i = 0; i <= fdmax; i++)
  {
    int   flags = 0;

    if(FD_ISSET(i, &rset)) flags |= PDEMUX_READ;

    if(FD_ISSET(i, &wset)) flags |= PDEMUX_WRITE;
  
    // sorta suggests that I ought to call the wakeup and pass
    // an error flag on to it.
    if(FD_ISSET(i, &exset))
    {
      // don't remove bad sockets - it's an error to close the socket
      // or deallocate the wakeup without telling the source. when
      // we get socket errors, we'd better hope that there's reading
      // or writing to be done.
      // under cygwin, closing down a socket (read, write or both)
      // causes select to wake up with an exception bit. out of cygwin
      // we only wake up. In both cases, the read bit is set so
      // just handling the stuff seems to work. not sure about write.
      // posix_demuxer::socket_recv thinks the connection's closed, but
      // it all seems to work out. Yours, Confused.

      fprintf(stderr, "select error on socket %i, flags=%x\n",
        i, flags);

      int err;
      // heh heh, this isn't great to call on the pipe that is used
      // in the self pipe trick. I don't know why it's getting an
      // err anyway.
      if(get_socket_error(i, &err) == -1)
        fprintf(stderr, "get_socket_error failed!?!\n");

      fprintf(stderr, "socket err = %i, %s\n", err, strerror(err));
      // don't remove! see below
      // remove_fd(i);
    }

    //
    if(flags)
    {
      socket_wakeup*  sv = svs[i];
      // remove before wakeup so wakeup can add itself back, 
      // if necessary.
      remove_fd(i);

      sv->wakeup_flags = flags;
      sv->wakeup(*this);
    }

    // to lower high-watermark, keep track of highest seen.
    if(svs[i]) new_fdmax = i;
  }

  // fprintf(stderr, "new_fdmax=%i, fdmax=%i\n", new_fdmax, fdmax);

  fdmax = new_fdmax;      // copy it back
}

}} // flx, demux

@h=tangler('demux/demux_ts_select_demuxer.cpp')
@select(h)
#include "demux_ts_select_demuxer.hpp"
#include <stdio.h>
#include <unistd.h>       // pipe for self-pipe trick.
#include <assert.h>

namespace flx { namespace demux {

auto_fd::auto_fd()
{
  fd = -1;    // invalid
}

auto_fd::~auto_fd()
{
  if(-1 == fd) return;

  if(close(fd) == -1)
    perror("auto fd close");
}

ts_select_demuxer::ts_select_demuxer()
{
  // fprintf(stderr, "creating pipe for self-pipe trick\n");

  int     self_pipe_fds[2];
  if(pipe(self_pipe_fds) == -1)
  {
    perror("ts_select_demuxer::self_pipe");
    throw -1;
  }

  // fprintf(stderr, "got two fds: %i, %i\n",
  //  self_pipe_fds[0], self_pipe_fds[1]);

  fds[0].fd = self_pipe_fds[0];
  fds[1].fd = self_pipe_fds[1];

  // make a close obj or something.
  spw.s = self_pipe_fds[0]; // setup wakeup for read end of pipe

  if(demux.add_socket_wakeup(&spw, PDEMUX_READ) == -1)  // no wakeup!?!
    throw -1;                 // that makes me angry!!!
}

ts_select_demuxer::~ts_select_demuxer()
{
// is that even our job? how do we wait?
// fprintf(stderr, "could wake here to do clean take down...\n"); 
}

void
ts_select_demuxer::get_evts(bool poll)
{
  fd_set  rset, wset, exset;

  // copy args under lock
  {
    flx_mutex_locker_t locker(ham_fist);
    demux.copy_sets(rset, wset, exset);
  }
  
  // process arg set under lock. note that the select demuxer is passed
  // to wakeups, so no recursive lock is needed. also, because any 
  // readditions caused by the callback are done to the naive demuxer,
  // no selfpipe writes are required either. the only thing to remember
  // is that the wakeup recipient should not be surprised to see a demuxer
  // in its callback different to the one it originally added to.
  if(demux.select(rset, wset, exset, poll))
  {
    flx_mutex_locker_t locker(ham_fist);
    demux.process_sets(rset, wset, exset);
  }
}

// thread safe overloaded functions follow. all acquire the lock
// then call the unthreadsafe version of the function. nice!
int
ts_select_demuxer::add_socket_wakeup(socket_wakeup* sv, int flags)
{
  // not a solution - there will still be race conditions... this s
  // could go stale...
  int s = sv->s;    // keep a copy so we don't introduce race conditions

  // fprintf(stderr, "ts_select::add: %p->%i (%s), %x\n",
  //  sv, s, (s == self_pipe_fds[0]) ? "self pipe" : "socket", flags);
  flx_mutex_locker_t locker(ham_fist);

  int res = demux.add_socket_wakeup(sv, flags);
  // I wouldn't touch the sv after this.

  // lets wake the select demuxer by writing to our end of the pipe
  // lets also not add redundant select wakes for our own selfpipe, as
  // we know it's adding whilst not in select. Is that clear?
  if(s != fds[0].fd)
  {
    // fprintf(stderr, "waking select with write (blocking?)\n");

    char  b = 1;
    ssize_t nbytes;
    // is this blocking? I guess it has to be...
    nbytes = write(fds[1].fd, &b, 1);   // wake up, jeff!

    if(-1 == nbytes) perror("self-pipe write");
    assert(1 == nbytes);
  }

  return res;

// we need to wake a blocking get_evts call here else we'll have bad
// performance or even a lockup. the question is do we need to do it under
// the tutelage of the lock?
}

void
selfpipe_wakeup::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr, "selfpipe wakeup: read the pending byte and re-arm\n");

  ssize_t         nbytes;
  char      b;

    // if this were read then this fn would work with non-sockets
    nbytes = read(s, &b, 1);

  if(nbytes == -1) perror("recv");

  // fprintf(stderr, "GOT: %li, %x\n", nbytes, b);
  assert(nbytes == 1 && b == 1);

  // add self back!
  int res = demux.add_socket_wakeup(this, PDEMUX_READ);
  assert(-1 != res);
}

}}

@h=tangler('demux/demux_sockety.cpp')
@select(h)
#include "demux_sockety.hpp" /* for this stuff */

#include <stdio.h>        /* for perror */
#include <fcntl.h>        /* for making non blocking sockets */
#include <netinet/in.h>     /* for sockaddr_in */
#include <arpa/inet.h>      /* for inet_addr */
#include <unistd.h>       /* for close */

#include <netinet/in.h>     /* IPPROTO_TCP and sockaddr_in */
#include <netinet/tcp.h>    /* TCP_NODELAY */

#include <sys/types.h>      /* for accept */
#include <sys/socket.h>
//#include <sys/errno.h>    /* EINPROGRESS (GUSI doesn't like both this and errno.h)*/

#include <errno.h>        /* errno */

#include <string.h>       /* for memset */
namespace flx { namespace demux {

@tangle("typedef " + FLX_SOCKLEN_T + " FLX_SOCKLEN_T;")

/*
 returns a socket ready for listening (AF_INET, SOCK_STREAM for now).
 0 in for port means let kernel decide, result in *io_port
 portable, can be factored out. listens on all NICs.
 returns -1 on failure, sometimes eats errno.
 p.s. sets SO_REUSEADDR.
*/
int
create_listener_socket(int* io_port, int q_len)
{
  int         listener;
  int         yes = 1;  /* for address reuse */

  if((listener = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    return -1;

  /* get rid of those *pesky* "address already in use" errors. */
  /* for when you don't cleanly shutdown the server */
  if(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1)
    goto listener_fail;

  /* bind listener to local interface (ANY) */
  if(bind_sock(listener, io_port) == -1)
    goto listener_fail;

  /* set listen queue length for socket */
  if(listen(listener, q_len) == -1)
    goto listener_fail;

  return listener;

listener_fail:
  perror("create_listener_socket"); /* eats errno! */
  if(close(listener) == -1)
    perror("create_listener_socket close");
  return -1;
}

/* create listener, make it non-blocking */
/* duh, sometimes eats errno...*/
int
create_async_listener(int* io_port, int q_len)
{
  int   listener;

  listener = create_listener_socket(io_port, q_len);

  if(-1 == listener) return -1;

  if(make_nonblock(listener) == -1)
  {
    if(close(listener) != 0)
      perror("create_async_listener close");
    return -1;
  }

  return listener;
}

/* ps, sets resulting socket to non-block. some people would say that */
/* this WASN'T nice, so change the name some time. returns socket or -1 */
/* on failure, with *err containing the error code. on success returns 0 */
/* with zero (= no error) in *err */
int
nice_accept(int listener, int* err)
{
  struct sockaddr_in  remoteaddr;
  /*socklen_t     addrlen = sizeof(remoteaddr);*/
  /* os x 10.2.8 doesn't have socklen_t. will this work elsewhere? */
  /* 10.4 (gcc 4.0) complains about signedeness, so now unsigned */
  FLX_SOCKLEN_T addrlen = sizeof(remoteaddr);
  int         newfd;
  
  *err = 0;     /* assume all good */
  
  newfd = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);
  if(-1 == newfd) {
    *err = errno;
    return -1;
  }
  else
  {
    /*I think 0's the result I want*/
    if(make_nonblock(newfd) == -1)
    {
      *err = errno;

      /* bizarre case, note that close's errno is lost */
      if(close(newfd) == -1) 
        perror("nice_accept close");
      newfd = -1;
    }
  }
  return newfd;
}

/* call this connect_ipv4? would its interface work for ipv6? */
/* this connect can be either asynchronous or synchronous, */
/* depending on whether or not the socket is non blocking */
/* returns -1 with err in errno on failure */
int
connect_sock(int s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;     /* host byte order */
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

/* bind s to local address with given port number, or zero to let OS */
/* choose. can you bind to non-local addresses? not sure, but you might */
/* like to choose which local interface... (ADD OTHER INTERFACES HERE) */
/* returns -1 on failure with error code in errno */
int
bind_sock(int s, int* io_port)
{
  struct sockaddr_in  addr;
  FLX_SOCKLEN_T namelen = sizeof(addr);

  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;      /* host byte order */
  /* make the NIC an argument */
  addr.sin_addr.s_addr = htonl(INADDR_ANY); /* allow multihomed */
  addr.sin_port = htons(*io_port);

  /* bind to port */
  if (bind(s, (struct sockaddr *)&addr, namelen) < 0)
  {
    return -1;
  }

  /* we don't need to do this when the port was specified */
  if(0 == *io_port)
  {
    /* Find out what port number was chosen */
    if (getsockname(s, (struct sockaddr *)&addr, &namelen) < 0)
    {
      return -1;
    }

    *io_port = ntohs(addr.sin_port);
  }

  return 0; /* success! */
}

/* simple wrapper for fcntl for those too lazy to look it up */
/* returns -1 on failure with errno set or non -1  otherwise */
int
make_nonblock(int s)
{
  return fcntl(s, F_SETFL, O_NONBLOCK);
}

/* returns -1 on failure with errno set or 0 otherwise */
int
set_tcp_nodelay(int s, int disable_nagle)
{
  return setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
    (char*)&disable_nagle, sizeof(disable_nagle));
}

/*
    Getting the determining if the async connect succeeded and if not,
    its error, can actually be quite hairy on some systems, see
    http://cr.yp.to/docs/connect.html
    for suggestions (none of which I follow at this point)
  returns 0 on success and socket error in *socket_err
  on failure returns -1 and *socket_err errno
*/
int
get_socket_error(int s, int* socket_err)
{
  int       res;
    FLX_SOCKLEN_T len = sizeof(*socket_err);
    /* god knows what the level should be. socket level seems sensible. */
    res = getsockopt(s, SOL_SOCKET, SO_ERROR, socket_err, &len);

    /* I've heard of impls of getsockopt(SO_ERROR) acting as they they */
    /* had the socket error (i.e. returning -1 and the sock err in errno) */
    if(-1 == res)
    {
        *socket_err = errno;     // don't think its ours
        fprintf(stderr, "getsockopt failed - is that our error? (%i)\n",
            *socket_err);
    }

  return res;
}

/* also make non-blocking AFTER connect, that is, */
/* this is a synchronous connect */
/* is eating errno, fix */
int
nice_connect(const char* addr, int port)
{
  int     s;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != -1
    && connect_sock(s, addr, port) == 0
    && make_nonblock(s) != -1)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  perror("nice_connect");

  if(-1 != s && close(s) != 0)
    perror("nice close");

  return -1;
}

/* makes the socket non-blocking BEFORE connect, returns result */
/* from which can be determined if it finished immediately */
/* returns the socket & finished flag or -1 on failure, with the */
/* error returned in *err */
int
async_connect(const char* addr, int port, int* finished, int* err)
{
  int     s = -1;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != -1 && make_nonblock(s) != -1)
  {
    /* no error we now have s, a non-blocking socket */
    if(connect_sock(s, addr, port) == 0)
    {
      *err = 0;         /* no error */
      *finished = 1;        /* finished */
      return s;
    }

    *err = errno;         /* connect failed or in-progress */

    /* this can apparently be EWOULDBLOCK or even EAGAIN on some systems */
    /* any info? on some systems they're the same, on some they're not */
    if(EINPROGRESS == *err)
    {
      *finished = 0;        /* not finished, in progress */
      return s;
    }
    /* some other failure, fall through and clean up */
  }

  /* hope you can read same errno twice in threaded apps! */
  *err = errno;           /* pass back error */

  if(-1 != s && close(s) != 0)    /* we lose the close error */
    perror("async_connect close");

  *finished = 1;            /* for completeness */
  return -1;
}
}}



