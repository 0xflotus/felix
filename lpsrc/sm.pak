@head(1,'smbase')
@h=tangler('licences/sm_licence.txt','data')
@select(h)
All of the modules in the sm system are
hereby placed in the public domain.

@h=tangler('elk/sm_malloc_stub.cpp')
@select(h)
// malloc_stub.h            see license.txt for copyright and terms of use
// no-op implementation of ckheap.h

#include "sm_ckheap.h"     // interface to implement

void checkHeap() {}

void checkHeapNode(void *node) {}

void malloc_stats() {}

unsigned numMallocCalls() { return 0; }
unsigned numFreeCalls() { return 0; }

void walkMallocHeap(HeapWalkFn func) {}

// EOF
@h=tangler('elk/sm_array.h')
@select(h)
// array.h            see license.txt for copyright and terms of use
// some array classes

#ifndef ARRAY_H
#define ARRAY_H

#include "sm_xassert.h"


// -------------------- Array ----------------------
// This is the same as C++'s built-in array, but automatically deallocates.
// If you want bounds checking too, use GrowArray, below.
template <class T>
class Array {
private:     // data
  T *arr;

private:     // not allowed
  Array(Array&);
  void operator=(Array&);

public:
  Array(int len) : arr(new T[len]) {}
  ~Array() { delete[] arr; }
  
  T const &operator[] (int i) const { return arr[i]; }
  T &operator[] (int i) { return arr[i]; }

  operator T const* () const { return arr; }
  operator T const* () { return arr; }
  operator T * () { return arr; }
  
  T const* operator+ (int i) const { return arr+i; }
  T * operator+ (int i) { return arr+i; }
  
  // convenience
  void setAll(T val, int len) {
    for (int i=0; i<len; i++) {
      arr[i] = val;
    }
  }
};


// ------------------ GrowArray --------------------
// This class implements an array of T's; it automatically expands
// when 'ensureAtLeast' or 'ensureIndexDoubler' is used; it does not
// automatically contract.  All accesses are bounds-checked.
//
// class T must have:
//   T::T();           // default ctor for making arrays
//   operator=(T&);    // assignment for copying to new storage
//   T::~T();          // dtor for when old array is cleared
template <class T>
class GrowArray {
private:     // data
  T *arr;                 // underlying array; NULL if sz==0
  int sz;                 // # allocated entries in 'arr'

private:     // funcs
  void bc(int i) const    // bounds-check an index
    { xassert((unsigned)i < (unsigned)sz); }
  void eidLoop(int index);

public:      // funcs
  GrowArray(int initSz);
  ~GrowArray();

  // allocated space
  int size() const { return sz; }

  // element access
  T const& operator[] (int i) const   { bc(i); return arr[i]; }
  T      & operator[] (int i)         { bc(i); return arr[i]; }

  // set size, reallocating if old size is different; if the
  // array gets bigger, existing elements are preserved; if the
  // array gets smaller, elements are truncated
  void setSize(int newSz);

  // make sure there are at least 'minSz' elements in the array;
  void ensureAtLeast(int minSz)
    { if (minSz > sz) { setSize(minSz); } }

  // grab a read-only pointer to the raw array
  T const *getArray() const { return arr; }

  // grab a writable pointer; use with care
  T *getDangerousWritableArray() { return arr; }
  T *getArrayNC() { return arr; }     // ok, not all that dangerous..

  // make sure the given index is valid; if this requires growing,
  // do so by doubling the size of the array (repeatedly, if
  // necessary)
  void ensureIndexDoubler(int index)
    { if (sz-1 < index) { eidLoop(index); } }

  // set an element, using the doubler if necessary
  void setIndexDoubler(int index, T const &value)
    { ensureIndexDoubler(index); arr[index] = value; }
    
  // swap my data with the data in another GrowArray object
  void swapWith(GrowArray<T> &obj) {
    T *tmp1 = obj.arr; obj.arr = this->arr; this->arr = tmp1;
    int tmp2 = obj.sz; obj.sz = this->sz; this->sz = tmp2;
  }

  // convenience
  void setAll(T val) {
    for (int i=0; i<sz; i++) {
      arr[i] = val;
    }
  }
};


template <class T>
GrowArray<T>::GrowArray(int initSz)
{
  sz = initSz;
  if (sz > 0) {
    arr = new T[sz];
  }
  else {
    arr = NULL;
  }
}


template <class T>
GrowArray<T>::~GrowArray()
{
  if (arr) {
    delete[] arr;
  }
}


template <class T>
void GrowArray<T>::setSize(int newSz)
{
  if (newSz != sz) {
    // keep track of old
    int oldSz = sz;
    T *oldArr = arr;

    // make new
    sz = newSz;
    if (sz > 0) {
      arr = new T[sz];
    }
    else {
      arr = NULL;
    }

    // copy elements in common
    for (int i=0; i<sz && i<oldSz; i++) {
      arr[i] = oldArr[i];
    }

    // get rid of old
    if (oldArr) {
      delete[] oldArr;
    }
  }
}


// this used to be ensureIndexDoubler's implementation, but
// I wanted the very first check to be inlined
template <class T>
void GrowArray<T>::eidLoop(int index)
{
  if (sz-1 >= index) {
    return;
  }

  int newSz = sz;
  while (newSz-1 < index) {
    #ifndef NDEBUG_NO_ASSERTIONS    // silence warning..
      int prevSz = newSz;
    #endif
    if (newSz == 0) {
      newSz = 1;
    }
    newSz = newSz*2;
    xassert(newSz > prevSz);        // otherwise overflow -> infinite loop
  }

  setSize(newSz);
}


// ---------------------- ArrayStack ---------------------
// This is an array where some of the array is unused.  Specifically,
// it maintains a 'length', and elements 0 up to length-1 are
// considered used, whereas length up to size-1 are unused.  The
// expected use is as a stack, where "push" adds a new (used) element.
template <class T>
class ArrayStack : public GrowArray<T> {
private:
  int len;               // # of elts in the stack

public:
  ArrayStack(int initArraySize = 10)
    : GrowArray<T>(initArraySize),
      len(0)
    {}
  ~ArrayStack();

  // element access; these declarations are necessary because
  // the uses of 'operator[]' below are not "dependent", hence
  // they can't use declarations inherited from GrowArray<T>
  T const& operator[] (int i) const { return GrowArray<T>::operator[](i); }
  T      & operator[] (int i)       { return GrowArray<T>::operator[](i); }

  void push(T const &val)
    { setIndexDoubler(len++, val); }
  T pop()
    { return operator[](--len); }
  T const &top() const
    { return operator[](len-1); }
  T &top()
    { return operator[](len-1); }

  // alternate interface, where init/deinit is done explicitly
  // on returned references
  T &pushAlt()    // returns newly accessible item
    { GrowArray<T>::ensureIndexDoubler(len++); return top(); }
  T &popAlt()     // returns item popped
    { return operator[](--len); }

  // items stored
  int length() const
    { return len; }

  bool isEmpty() const
    { return len==0; }
  bool isNotEmpty() const
    { return !isEmpty(); }

  void popMany(int ct)
    { len -= ct; xassert(len >= 0); }
  void empty()
    { len = 0; }

  // useful when someone has used 'getDangerousWritableArray' to
  // fill the array's internal storage
  void setLength(int L) { len = L; }

  // consolidate allocated space to match length
  void consolidate() { setSize(length()); }

  // swap
  void swapWith(ArrayStack<T> &obj) {
    GrowArray<T>::swapWith(obj);
    int tmp = obj.len; obj.len = this->len; this->len = tmp;
  }
};

template <class T>
ArrayStack<T>::~ArrayStack()
{}


// iterator over contents of an ArrayStack, to make it easier to
// switch between it and SObjList as a representation
template <class T>
class ArrayStackIterNC {
  NO_OBJECT_COPIES(ArrayStackIterNC);   // for now

private:     // data
  ArrayStack<T> /*const*/ &arr;   // array being accessed
  int index;                      // current element

public:      // funcs
  ArrayStackIterNC(ArrayStack<T> /*const*/ &a) : arr(a), index(0) {}

  // iterator actions
  bool isDone() const             { return index >= arr.length(); }
  void adv()                      { xassert(!isDone()); index++; }
  T /*const*/ *data() const       { return &(arr[index]); }
};


// I want const polymorphism!

                        
// pop (and discard) a value off a stack at end of scope
template <class T>
class ArrayStackPopper {
private:
  ArrayStack<T> &stk;

public:
  ArrayStackPopper(ArrayStack<T> &s) : stk(s) {}
  ArrayStackPopper(ArrayStack<T> &s, T const &pushVal)
    : stk(s) { stk.push(pushVal); }
  ~ArrayStackPopper()
    { stk.pop(); }
};


// ------------------- ObjArrayStack -----------------
// an ArrayStack of owner pointers
template <class T>
class ObjArrayStack {
private:    // data
  ArrayStack<T*> arr;

public:     // funcs
  ObjArrayStack(int initArraySize = 10)
    : arr(initArraySize)
    {}
  ~ObjArrayStack() { deleteAll(); }

  void push(T *ptr)          { arr.push(ptr); }
  T *pop()                   { return arr.pop(); }

  T const *topC() const      { return arr.top(); }
  T       *top()             { return arr.top(); }

  T const * operator[](int index) const  { return arr[index]; }
  T *       operator[](int index)        { return arr[index]; }

  int length() const         { return arr.length(); }
  bool isEmpty() const       { return arr.isEmpty(); }
  bool isNotEmpty() const    { return !isEmpty(); }

  void deleteTopSeveral(int ct);
  void deleteAll()           { deleteTopSeveral(length()); }
  
  // will not delete any items
  void consolidate()         { arr.consolidate(); }

  void swapWith(ObjArrayStack<T> &obj)   { arr.swapWith(obj.arr); }
};


template <class T>
void ObjArrayStack<T>::deleteTopSeveral(int ct)
{
  while (ct--) {
    delete pop();
  }
}


// ------------------------- ArrayStackEmbed --------------------------
// This is like ArrayStack, but the first 'n' elements are stored
// embedded in this object, instead of allocated on the heap; in some
// circumstances, this lets us avoid allocating memory in common cases.
//
// For example, suppose you have an algorithm that is usually given a
// small number of elements, say 1 or 2, but occasionally needs to
// work with more.  If you put the array of elements in the heap, then
// even in the common case a heap allocation is required, which is
// bad.  But by using ArrayStackEmbed<T,2>, you can be sure that if
// the number of elements is <= 2 there will be no heap allocation,
// even though you still get a uniform (array-like) interface to all
// the elements.
template <class T, int n>
class ArrayStackEmbed {
private:      // data
  // embedded storage
  T embed[n];

  // heap-allocated storage
  GrowArray<T> heap;

  // total number of elements in the stack; if this
  // exceeds 'n', then heap.arr is non-NULL
  int len;

private:      // funcs
  void bc(int i) const    // bounds-check an index
    { xassert((unsigned)i < (unsigned)len); }

public:       // funcs
  ArrayStackEmbed()
    : /*embed is default-init'd*/
      heap(0),    // initially a NULL ptr
      len(0)
  {}
  ~ArrayStackEmbed()
  {}              // heap auto-deallocs its internal data
  
  void push(T const &val)
  { 
    if (len < n) {
      embed[len++] = val;
    }
    else {
      heap.setIndexDoubler(len++ - n, val); 
    }
  }

  T pop() 
  {                
    xassert(len > 0);
    if (len <= n) {
      return embed[--len];
    }
    else {
      return heap[--len - n];
    }
  }

  int length() const
    { return len; }
  bool isEmpty() const
    { return len==0; }
  bool isNotEmpty() const
    { return !isEmpty(); }

  // direct element access
  T const &getElt(int i) const
  { 
    bc(i);
    if (i < n) {
      return embed[i];
    }
    else {
      return heap[i - n];
    }
  }

  T const& operator[] (int i) const
    { return getElt(i); }
  T & operator[] (int i)
    { return const_cast<T&>(getElt(i)); }
    
  T const &top() const
    { return getElt(len-1); }
};


#endif // ARRAY_H
@h=tangler('elk/sm_arraymap.h')
@select(h)
// arraymap.h            see license.txt for copyright and terms of use
// template class to maintain an array-based map from
// integers to object pointers; the map owns all of
// the objects referred-to

// as far as I know, nothing currently uses this file, but
// I believe it *has* been tested (whatever once used it now
// uses something else)

#ifndef ARRAYMAP_H
#define ARRAYMAP_H

#include "sm_xassert.h"

// map: int -> T
template <class T>
class ArrayMap {
private:     // data
  T **map;               // array[0,nextId-1] of owner ptr
  int nextId;            // next id to assign
  int mapSize;           // allocated size of 'map'

private:     // funcs
  void make();
  void del();
  void validate(int index) const;

public:      // data
  ArrayMap() { make(); }
  ~ArrayMap() { del(); }

  // # of elements defined
  int count() const { return nextId; }

  // insert a new element and yield its assigned id
  int insert(T * /*owner*/ t);

  // retrieve by id
  T const *lookupC(int id) const;
  T *lookup(int id) { return const_cast<T*>(lookupC(id)); }
  T *&lookupRef(int id) { validate(id); return map[id]; }

  // throw everything away
  void empty() { del(); make(); }
};

template <class T>
void ArrayMap<T>::make()
{
  mapSize = 100;
  nextId = 0;
  map = new T* [mapSize];
}

template <class T>
void ArrayMap<T>::del()
{
  for (int i=0; i<nextId; i++) {
    delete map[i];
  }
  delete[] map;
}

template <class T>
int ArrayMap<T>::insert(T *t)
{
  if (nextId == mapSize) {
    // make it bigger
    int newMapSize = mapSize * 2;
    T **newMap = new T* [newMapSize];

    // copy the old contents to the new map
    for (int i=0; i<mapSize; i++) {
      newMap[i] = map[i];
    }
    mapSize = newMapSize;

    // blow away the old map
    delete[] map;

    // grab the new map
    map = newMap;
  }

  int ret = nextId++;
  map[ret] = t;
  return ret;
}

template <class T>
void ArrayMap<T>::validate(int id) const
{
  xassert(0 <= id && id < nextId);
}

template <class T>
T const *ArrayMap<T>::lookupC(int id) const
{
  validate(id);
  return map[id];
}


#define FOREACH_ARRAYMAP(type, array, var)       \
  type const *var = NULL;                        \
  for (int var##id=0;                            \
       var##id<(array).count() &&                \
         (var=(array).lookupC(var##id), true);   \
       var##id++)


#define FOREACH_ARRAYMAP_INDEX(array, var)   \
  for (int var=0;                            \
       var<(array).count();                  \
       var++)


#define MUTATE_EACH_ARRAYMAP(type, array, var)   \
  type *var = NULL;                              \
  for (int var##id=0;                            \
       var##id<(array).count() &&                \
         (var=(array).lookup(var##id), true);    \
       var##id++)


#endif // ARRAYMAP_H
@h=tangler('elk/sm_arrayqueue.h')
@select(h)
// arrayqueue.h
// queue, implemented with an array

#ifndef ARRAYQUEUE_H
#define ARRAYQUEUE_H

#include "sm_xassert.h"

// needed operations on T:
//   T()                       // default ctor
//   operator=(T&)             // assignment
//   bool operator==(T&)       // comparison

template <class T>
class ArrayQueue {
private:     // data
  T *arr;                      // working storage
  int arrSize;                 // allocated length of 'arr'
  int head;                    // index of first element to dequeue
  int tail;                    // index+1 of last element to dequeue

  // NOTE: If head == tail then the queue is empty.  If head > tail,
  // then the queue elements circularly wrap around the end of 'arr'.
  // At all times, 0 <= head,tail < arrSize.

public:      // funcs
  ArrayQueue(int initSize = 10);
  ~ArrayQueue();

  // test # of elements in queue
  int length() const
    { return head<=tail? tail-head : arrSize-(head-tail); }
  bool isEmpty() const                  { return head==tail; }
  bool isNotEmpty() const               { return !isEmpty(); }

  // add/remove elements in FIFO order
  void enqueue(T const &t);
  T dequeue();

  // remove all elements
  void empty()                          { head = tail = 0; }

  // access elements of the queue in dequeue order; that is,
  // element 0 is the next element to be dequeued, and element
  // length()-1 is the element most recently enqueued
  //
  // as this interface is O(1), it is the intended method
  // of iterating over the elements in the queue
  T const &eltC(int index) const;
  T &elt(int index)                     { return const_cast<T&>(eltC(index)); }
  T &operator[] (int index)             { return elt(index); }
  T const &operator[] (int index) const { return eltC(index); }

  // reverse the sequence of stored elements
  void reverse();

  // true if a specific element is among the queue elements
  bool contains(T const &t) const;
};


template <class T>
ArrayQueue<T>::ArrayQueue(int initSize)
{
  // initial size must be positive, since array growth is
  // simply by doubling the size
  xassert(initSize > 0);

  arr = new T[initSize];
  arrSize = initSize;
  head = tail = 0;
}


template <class T>
ArrayQueue<T>::~ArrayQueue()
{
  delete[] arr;
}


template <class T>
void ArrayQueue<T>::enqueue(T const &t)
{
  if (length() == arrSize-1) {
    // must expand the queue

    // make new array
    int newArrSize = arrSize * 2;
    T *newArr = new T[newArrSize];

    // copy elements sequentially
    int oldLength = length();
    for (int i=0; i<oldLength; i++) {
      newArr[i] = eltC(i);
    }

    // discard old array
    delete[] arr;

    // put new one in its place
    arr = newArr;
    arrSize = newArrSize;
    head = 0;
    tail = oldLength;
  }
  
  // store the new element where 'tail' points
  arr[tail] = t;
  
  // advance 'tail'
  if (++tail == arrSize) {
    tail = 0;
  }
}


template <class T>
T ArrayQueue<T>::dequeue()
{
  if (isEmpty()) {
    xfailure("attempt to dequeue an empty queue");
  }

  // advance 'head' while yielding the element it currently points at;
  // avoid making an intermediate copy (for performance)
  if (head == arrSize-1) {
    head = 0;
    return arr[arrSize-1];
  }
  else {
    return arr[head++];
  }
}

  
template <class T>
T const &ArrayQueue<T>::eltC(int index) const
{                         
  xassert(0 <= index && index < length());

  if (head+index < arrSize) {
    return arr[head+index];
  }
  else {
    return arr[head+index - arrSize];
  }
}


template <class T>
void ArrayQueue<T>::reverse()
{
  int i = 0, j = length()-1;
  while (i < j) {
    // swap i,j elements
    T tmp = elt(i);
    elt(i) = elt(j);
    elt(j) = tmp;

    i++;
    j--;
  }
}


template <class T>
bool ArrayQueue<T>::contains(T const &t) const
{                                 
  int len=length();
  for (int i=0; i<len; i++) {
    if (t == eltC(i)) {
      return true;
    }
  }
  return false;
}


#endif // ARRAYQUEUE_H
@h=tangler('elk/sm_astlist.h')
@select(h)
// astlist.h            see license.txt for copyright and terms of use
// owner list wrapper around VoidTailList
// name 'AST' is because the first application is in ASTs

#ifndef ASTLIST_H
#define ASTLIST_H

#include "sm_vdtllist.h"

template <class T> class ASTListIter;
template <class T> class ASTListIterNC;

// a list which owns the items in it (will deallocate them), and
// has constant-time access to the last element
template <class T>
class ASTList {
private:
  friend class ASTListIter<T>;        
  friend class ASTListIterNC<T>;

protected:
  VoidTailList list;                    // list itself

private:
  ASTList(ASTList const &obj);          // not allowed

public:
  ASTList()                             : list() {}
  ~ASTList()                            { deleteAll(); }

  // ctor to make singleton list; often quite useful
  ASTList(T *elt)                       : list() { prepend(elt); }

  // stealing ctor; among other things, since &src->list is assumed to
  // point at 'src', this class can't have virtual functions;
  // these ctors delete 'src'
  ASTList(ASTList<T> *src)              : list(&src->list) {}
  void steal(ASTList<T> *src)           { deleteAll(); list.steal(&src->list); }

  // selectors
  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }
  T *nth(int which)                     { return (T*)list.nth(which); }
  T const *nthC(int which) const        { return (T const*)list.nth(which); }
  T *first()                            { return (T*)list.first(); }
  T const *firstC() const               { return (T const*)list.first(); }
  T *last()                             { return (T*)list.last(); }
  T const *lastC() const                { return (T const*)list.last(); }

  // insertion
  void prepend(T *newitem)              { list.prepend(newitem); }
  void append(T *newitem)               { list.append(newitem); }
  void insertAt(T *newitem, int index)  { list.insertAt(newitem, index); }
  void concat(ASTList<T> &tail)         { list.concat(tail.list); }

  // removal
  T *removeFirst()                      { return (T*)list.removeFirst(); }
  T *removeLast()                       { return (T*)list.removeLast(); }
  T *removeAt(int index)                { return (T*)list.removeAt(index); }
  void removeItem(T *item)              { list.removeItem((void*)item); }
  
  // this one is awkwardly named to remind the user that it's
  // contrary to the usual intent of this class
  void removeAll_dontDelete()           { return list.removeAll(); }

  // deletion
  void deleteFirst()                    { delete (T*)list.removeFirst(); }
  void deleteAll();

  // list-as-set: selectors
  int indexOf(T const *item) const      { return list.indexOf((void*)item); }
  int indexOfF(T const *item) const     { return list.indexOfF((void*)item); }
  bool contains(T const *item) const    { return list.contains((void*)item); }

  // list-as-set: mutators
  bool prependUnique(T *newitem)        { return list.prependUnique(newitem); }
  bool appendUnique(T *newitem)         { return list.appendUnique(newitem); }

  // debugging: two additional invariants
  void selfCheck() const                { list.selfCheck(); }
};


template <class T>
void ASTList<T>::deleteAll()
{
  while (!list.isEmpty()) {
    deleteFirst();
  }
}


template <class T>
class ASTListIter {
protected:
  VoidTailListIter iter;      // underlying iterator

public:
  ASTListIter(ASTList<T> const &list) : iter(list.list) {}
  ~ASTListIter()                       {}

  void reset(ASTList<T> const &list)   { iter.reset(list.list); }

  // iterator copying; generally safe
  ASTListIter(ASTListIter const &obj)             : iter(obj.iter) {}
  ASTListIter& operator=(ASTListIter const &obj)  { iter = obj.iter;  return *this; }

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T const *data() const                 { return (T const*)iter.data(); }
};

#define FOREACH_ASTLIST(T, list, iter) \
  for(ASTListIter<T> iter(list); !iter.isDone(); iter.adv())


// version of the above, but for non-const-element traversal
template <class T>
class ASTListIterNC {
protected:
  VoidTailListIter iter;      // underlying iterator

public:
  ASTListIterNC(ASTList<T> &list)      : iter(list.list) {}
  ~ASTListIterNC()                     {}

  void reset(ASTList<T> &list)         { iter.reset(list.list); }

  // iterator copying; generally safe
  ASTListIterNC(ASTListIterNC const &obj)             : iter(obj.iter) {}
  ASTListIterNC& operator=(ASTListIterNC const &obj)  { iter = obj.iter;  return *this; }

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T *data() const                       { return (T*)iter.data(); }
  
  // iterator mutation; use with caution
  void setDataLink(T *newData)          { iter.setDataLink((void*)newData); }
};

#define FOREACH_ASTLIST_NC(T, list, iter) \
  for(ASTListIterNC<T> iter(list); !iter.isDone(); iter.adv())


// this function is somewhat at odds with the nominal purpose
// of ASTLists, but I need it in a weird situation so ...
template <class T>
ASTList<T> *shallowCopy(ASTList<T> *src)
{
  ASTList<T> *ret = new ASTList<T>;
  FOREACH_ASTLIST_NC(T, *src, iter) {
    ret->append(iter.data());
  }
  return ret;
}


#endif // ASTLIST_H
@h=tangler('elk/sm_autofile.h')
@select(h)
// autofile.h            see license.txt for copyright and terms of use
// little wrapper around FILE*

#ifndef SMUTIL_H
#define SMUTIL_H

#include <stdio.h>      // FILE


// fopen, but throw an XOpen exception (see exc.h) on failure instead
// of returning NULL
FILE *xfopen(char const *fname, char const *mode);


// automatically close a file in the destructor
class AutoFclose {
private:       // data
  FILE *fp;           
  
private:       // disallowed
  AutoFclose(AutoFclose&);
  void operator=(AutoFclose&);
  
public:
  AutoFclose(FILE *f) : fp(f) {}
  ~AutoFclose() { fclose(fp); }

  // may as well allow access to my storage
  FILE *getFP() { return fp; }
};


// simple wrapper on FILE*
class AutoFILE : private AutoFclose {
public:
  // open, throwing an XOpen exception on failure
  AutoFILE(char const *fname, char const *mode);

  // close the file
  ~AutoFILE();

  // behave like FILE* in between
  operator FILE* () { return getFP(); }
};


#endif // SMUTIL_H
@h=tangler('elk/sm_bflatten.h')
@select(h)
// bflatten.h            see license.txt for copyright and terms of use
// binary file flatten implementation

#ifndef BFLATTEN_H
#define BFLATTEN_H

#include "sm_flatten.h"
#include "sm_ohashtbl.h"
#include <stdio.h>        // FILE

class BFlatten : public Flatten {
private:     // data
  FILE *fp;               // file being read/written
  bool readMode;          // true=read, false=write

  struct OwnerMapping {
    void *ownerPtr;       // a pointer
    int intName;          // a unique integer name
  };
  OwnerHashTable<OwnerMapping> ownerTable;      // owner <-> int mapping
  int nextUniqueName;     // counter for making int names

private:     // funcs
  static void const* getOwnerPtrKeyFn(OwnerMapping *data);
  static void const* getIntNameKeyFn(OwnerMapping *data);

public:      // funcs
  BFlatten(char const *fname, bool reading);
  virtual ~BFlatten();

  // Flatten funcs
  virtual bool reading() const { return readMode; }
  virtual void xferSimple(void *var, unsigned len);
  virtual void noteOwner(void *ownerPtr);
  virtual void xferSerf(void *&serfPtr, bool nullable=false);
};

                  
// for debugging, write and then read something
template <class T>
T *writeThenRead(T &obj)
{
  char const *fname = "flattest.tmp";

  // write
  {
    BFlatten out(fname, false /*reading*/);
    obj.xfer(out);
  }

  // read
  BFlatten in(fname, true /*reading*/);
  T *ret = new T(in);
  ret->xfer(in);

  remove(fname);

  return ret;
}

#endif // BFLATTEN_H
@h=tangler('elk/sm_bit2d.h')
@select(h)
// bit2d.h            see license.txt for copyright and terms of use
// 2-d array of bits

#ifndef __BIT2D_H
#define __BIT2D_H

#include "sm_typ.h"
#include "sm_point.h"

class Flatten;

class Bit2d {        
private:     // data
  byte *data;       // bits; [0..stride-1] is first row, etc.
  bool owning;      // when false, 'data' is not owned by this object
  point size;       // size.x is # of cols, size.y is # of rows
  int stride;       // bytes between starts of adjacent rows;
                    // computable from size.x but stored for quick access

private:     // funcs
  byte *byteptr(point const &p)               { return data + p.y * stride + (p.x>>3); }
  byte const *byteptrc(point const &p) const  { return data + p.y * stride + (p.x>>3); }

  // this is the number of bytes allocated in 'data'
  int datasize() const                        { return size.y * stride; }

public:      // funcs
  // NOTE: does *not* clear the bitmap!  use 'setall' to do that
  Bit2d(point const &aSize);
  Bit2d(Bit2d const &obj);

  Bit2d& operator= (Bit2d const &obj);     // sizes must be equal already
  ~Bit2d();

  Bit2d(Flatten&);
  void xfer(Flatten &flat);

  bool okpt(point const &p) const    { return p.gtez() && p < size; }
  point const &Size() const          { return size; }

  bool operator== (Bit2d const &obj) const;     // compare sizes and data

  // bit access (these were inline earlier, but they expand to a huge amount
  // of code (more than 100 bytes), so I've un-inlined them)
  int get(point const &p) const;
  void set(point const &p);     // to 1
  void reset(point const &p);   // to 0
  void setto(point const &p, int val);
  void toggle(point const &p);

  // set the bit, but return what it was previously
  int testAndSet(point const &p);

  // set everything
  void setall(int val);

  // debugging
  void print() const;

  // bit of a hack: I want to be able to save the data as code which,
  // when compiled, will build a bit2d from static data.. for this
  // I need access to some private fields and a special ctor
  Bit2d(byte * /*serf*/ data, point const &size, int stride);
  byte *private_data() { return data; }
  int private_datasize() const { return datasize(); }
  int private_stride() const { return stride; }
};

#endif // __BIT2D_H

@h=tangler('elk/sm_bitarray.h')
@select(h)
// bitarray.h            see license.txt for copyright and terms of use
// one-dimensional array of bits

#ifndef BITARRAY_H
#define BITARRAY_H

#include "sm_xassert.h"

class Flatten;            // flatten.h

class BitArray {
private:    // data
  unsigned char *bits;
  int numBits;              // # of bits in the array

private:    // disallowed for now
  BitArray(BitArray&);
  void operator=(BitArray&);

private:    // funcs
  void bc(int i) const { xassert((unsigned)i < (unsigned)numBits); }
  int allocdBytes() const { return (numBits+7) / 8; }

public:     // funcs
  BitArray(int n);          // create with given # of bits, initially zeroed
  ~BitArray();

  BitArray(Flatten&);
  void xfer(Flatten &flat);

  // test a bit, return 0 or 1
  int test(int i) const
    { bc(i); return ((bits[i >> 3]) >> (i & 7)) & 1; }

  // set a bit to a specific value
  void set(int i)
    { bc(i); bits[i >> 3] |= (1 << (i & 7)); }
  void reset(int i)
    { bc(i); bits[i >> 3] &= ~(1 << (i & 7)); }
                                  
  // set a bit to an arbitrary value
  void setTo(int i, int val) {
    if (val) {
      set(i);
    }
    else {
      reset(i);
    }
  }

  // clear all bits
  void clearAll();
};


#endif // BITARRAY_H
@h=tangler('elk/sm_boxprint.h')
@select(h)
// boxprint.h
// another pretty-printing module, this one based on the box model
// described at http://caml.inria.fr/FAQ/format-eng.html

#ifndef BOXPRINT_H
#define BOXPRINT_H

#include "sm_str.h"
#include "sm_astlist.h"
#include "sm_array.h"
  

// fwd
class BoxPrint;


// manages the process of rendering a boxprint tree to a sm_string
class BPRender {
public:
  // output sm_string
  sm_stringBuilder sb;

  // right margin column; defaults to 72
  int margin;

  // column for next output; equal to the number of characters
  // after the last newline in 'sb'
  int curCol;

  // text to begin every line with; not counted towards column
  // counts; defaults to ""
  sm_string lineStartText;

public:
  BPRender();
  ~BPRender();

  // chars in the current line
  int getCurCol() const { return curCol; }

  // chars remaining on current line before the margin; might
  // be negative if the input didn't have enough breaks
  int remainder() const { return margin - getCurCol(); }

  // add some text (that doesn't include newlines) to the output
  void add(char const *text);

  // add a newline, plus indentation to get to column 'ind'
  void breakLine(int ind);

  // take the sm_string out of the rendering engine, replacing it
  // with the empty sm_string
  sm_string takeString() {
    sm_string ret(sb);
    reset();
    return ret;
  }

  // just clear the buffer to its original state; must do this
  // manually after changing 'lineStartText'
  void reset();

  // take the tree out of a boxprint builder, convert it to a sm_string,
  // and delete the tree
  sm_string takeAndRender(BoxPrint &bld);
};


// interface for elements in a boxprint tree
class BPElement {
public:
  // if no breaks are taken, compute the # of columns
  virtual int oneLineWidth()=0;

  // render this element as a sm_string with newlines, etc.
  virtual void render(BPRender &mgr)=0;

  // true if this element is a BPBreak and is enabled; returns false
  // by default
  virtual bool isBreak() const;

  // print the boxprint tree; for debugging code that produces them;
  // these methods do not emit leading or trailing whitespace
  virtual void debugPrint(std::ostream &os, int ind) const =0;

  // deallocate the element
  virtual ~BPElement();
};


// leaf in the tree: text to print
class BPText : public BPElement {
public:
  sm_string text;

public:
  BPText(char const *t);
  ~BPText();

  // BPElement funcs
  virtual int oneLineWidth();
  virtual void render(BPRender &mgr);
  virtual void debugPrint(std::ostream &os, int ind) const;
};


// leaf in the tree: a "break", which might end up being a
// space or a newline+indentation
class BPBreak : public BPElement {
public:
  // When true, this is a conditional break, and whether it is taken
  // or not depends on the prevailing break strategy of the box in
  // which it is located.  When false, the break is never taken, so
  // this is effectively just a space.
  bool enabled;

  // Nominally, when a break is taken, the indentation used is such
  // that the next char in the box is directly below the first char
  // in the box.  When this break is passed, however, it can add to
  // that nominal indent of 0; these adjustments accumulate as the
  // box is rendered.
  int indent;

public:
  BPBreak(bool e, int i);
  ~BPBreak();

  // BPElement funcs
  virtual int oneLineWidth();
  virtual void render(BPRender &mgr);
  virtual bool isBreak() const;
  virtual void debugPrint(std::ostream &os, int ind) const;
};


// kinds of boxes
enum BPKind {
  // enabled breaks are always taken
  BP_vertical,

  // enabled breaks are individually taken or not taken depending
  // on how much room is available; "hov"
  BP_sequence,

  // either all enabled breaks are taken, or none are taken; "h/v"
  BP_correlated,

  // # of kinds, also used to signal the end of a box in some cases
  NUM_BPKINDS
};

// internal node in the tree: a list of subtrees, some of which
// may be breaks
class BPBox : public BPElement {
public:
  // subtrees
  ASTList<BPElement> elts;

  // break strategy for this box
  BPKind kind;

public:
  BPBox(BPKind k);
  ~BPBox();

  // BPElement funcs
  virtual int oneLineWidth();
  virtual void render(BPRender &mgr);
  virtual void debugPrint(std::ostream &os, int ind) const;
};


// assists in the process of building a box tree by providing
// a number of syntactic shortcuts
class BoxPrint {
public:      // types
  // additional command besides BPKind
  enum Cmd {
    sp,          // insert disabled break
    br,          // insert enabled break
    ind,         // ibr(levelIndent)
    und,         // ibr(-levelIndent) ("unindent")
  };

  // insert enabled break with indentation
  struct IBreak {
    int indent;
    IBreak(int i) : indent(i) {}
    // use default copy ctor
  };

  // operator sequence
  struct Op {
    char const *text;
    Op(char const *t) : text(t) {}
    // default copy ctor
  };

private:     // data
  // stack of open boxes; always one open vert box at the top
  ObjArrayStack<BPBox> boxStack;

public:      // data
  // convenient names for the box kinds
  static BPKind const vert;       // = BP_vertical
  static BPKind const seq;        // = BP_sequence
  static BPKind const hv;         // = BP_correlated ("h/v")
  static BPKind const end;        // = NUM_BPKINDS

  // indentation amount for the ind/und commands; defaults to 2
  int levelIndent;

private:     // funcs
  // innermost box being built
  BPBox *box() { return boxStack.top(); }

public:      // funcs
  BoxPrint();
  ~BoxPrint();

  // append another element to the current innermost box
  void append(BPElement *elt);

  // add BPText nodes to current box
  BoxPrint& operator<< (int i);
  BoxPrint& operator<< (char const *s);

  // open/close boxes
  BoxPrint& operator<< (BPKind k);

  // insert breaks
  BoxPrint& operator<< (Cmd c);

  // insert break with indentation
  static IBreak ibr(int i) { return IBreak(i); }
  BoxPrint& operator<< (IBreak b);

  // op(text) is equivalent to sp << text << br
  static Op op(char const *text) { return Op(text); }
  BoxPrint &operator << (Op o);

  // take the accumulated box tree out; all opened boxes must have
  // been closed; the builder is left in a state where it can be used
  // to build a new tree if desired, or it can be simply destroyed
  BPBox* /*owner*/ takeTree();
  
  // print the current stack of trees
  void debugPrint(std::ostream &os) const;
  void debugPrintCout() const;      // for gdb
};


#endif // BOXPRINT_H
@h=tangler('elk/sm_breaker.h')
@select(h)
// breaker.h            see license.txt for copyright and terms of use
// function stub through which critical event code flow is directed
//   for easy breakpoints
// Scott McPeak, 1997,1998  This file is public domain.

#ifndef __BREAKER_H
#define __BREAKER_H

void breaker();

// bassert = breaker assert; failure simply calls breaker, which is
// a breakpoint in the debugger and is ignored when not in debugger;
// useful mainly for places I want to ensure something is true during
// initial testing, but after that it's ok if it's false
template <class T>          // allow possibly null pointers, etc
inline void bassert(T cond)
{
  if (!cond) {
    breaker();
  }
}


// this will call breaker on the first pass, but not any subsequent (unless
// it's called MAXINT*2 times...)
#define BREAK_FIRST_PASS     \
  {                          \
    static int passCount=0;  \
    bassert(passCount++);    \
  } /*no semicolon*/


// this is obsolete...
void _breaker_assert(char * __cond, char * __file, int __line);
  // this will be called on failed assertions instead of _assert
  // only if BREAKER_ASSERT is defined (due to a modification to
  // assert.h directly)

#endif // __BREAKER_H

@h=tangler('elk/sm_ckheap.h')
@select(h)
// ckheap.h            see license.txt for copyright and terms of use
// interface to check heap integrity, etc.

#ifndef CKHEAP_H
#define CKHEAP_H

#ifdef __cplusplus
extern "C" {
#endif


// check heap integrity, and fail an assertion if it's bad
void checkHeap();

// check that a given pointer is a valid allocated object;
// fail assertion if not
void checkHeapNode(void *node);

// prints allocation statistics to stderr
void malloc_stats();

// count # of malloc/free calls in program
unsigned numMallocCalls();
unsigned numFreeCalls();


// actions the heap walk iterator might request
enum HeapWalkOpts {
  HW_GO   = 0,         // keep going
  HW_STOP = 1,         // stop iterating
  HW_FREE = 2,         // free the block I just examined
};

// function for walking the heap
//   block:   pointer to the malloc'd block of memory
//   size:    # of bytes in the block; possibly larger than
//            what was requested
//   returns: bitwise OR of HeapWalkOpts options
// NOTE: you cannot call malloc or free inside this function
// (you can cause 'block' to be freed by returning HW_FREE)
typedef enum HeapWalkOpts (*HeapWalkFn)(void *block, int size);

// heap walk entry
void walkMallocHeap(HeapWalkFn func);


#ifdef __cplusplus
} // extern "C"
#endif

#endif // CKHEAP_H
@h=tangler('elk/sm_crc.h')
@select(h)
// crc.h            see license.txt for copyright and terms of use
// simple crc function

#ifndef __CRC_H
#define __CRC_H

unsigned long crc32(unsigned char const *data, int length);

#endif // __CRC_H

@h=tangler('elk/sm_cycles.h')
@select(h)
// cycles.h            see license.txt for copyright and terms of use
// read processor cycle count
// interface is portable, implementation is not

#ifdef __cplusplus
extern "C" {
#endif


// read the processor's cycle-count register, and store the count
// into these two 'unsigned' variables; if the count isn't available,
// yields zero in both
void getCycles(unsigned *lowp, unsigned *highp);


#ifdef __GNUC__
// if we're using gcc, so the 'long long' type is available,
// here's a more convenient version
unsigned long long getCycles_ll(void);
#endif


#ifdef __cplusplus
}
#endif

@h=tangler('elk/sm_datablok.h')
@select(h)
// datablok.h            see license.txt for copyright and terms of use
// arbitrary block of data
// Scott McPeak, 1998-2000  This file is public domain.

#ifndef __DATABLOK_H
#define __DATABLOK_H

#include "sm_typ.h"

class DataBlock {
private:      // data
  byte *data;                  // data itself (may be NULL)
  int dataLen;                 // length of data, starting at data[0]
  int allocated;               // amount of memory allocated at 'data'

  // invariants: 0 <= dataLen <= allocated
  //             (data==NULL) == (allocated==0)

  // endpost: 'data' will be kept allocated with one extra byte at the
  // end, where an endpost byte is written.  thus, we have another
  // invariant:
  //             (data!=NULL) implies data[allocated] == endpost
  static byte const endpost;

private:      // funcs
  void init(int allocatedSize);
    // base ctor

  static byte *allocate(int size);
    // allocate a block of memory, writing endpost

  void copyCtorShared(DataBlock const &obj);
    // shared by both copy constructors (actually, only one is the true
    // copy ctor...)

  void ctor(byte const *srcData, int dataLen);
  void ctor(byte const *srcData, int dataLen, int allocatedSize);
    // shared ctor calls as a workaround for char casting problems

  void selfCheck() const;
    // confirm that invariants are true

public:       // funcs
  // constructors
  DataBlock(int allocatedSize = 0);
    // make an empty datablock holder; when allocatedSize is 0, 'data'
    // is initially set to NULL

  EXPLICIT DataBlock(char const *srcString);
    // make a copy of 'srcString' data, which is null-terminated

  DataBlock(byte const *srcData, int dataLen) { ctor(srcData, dataLen); }
  DataBlock(char const *srcData, int dataLen) { ctor((byte const*)srcData, dataLen); }
    // make a copy of 'srcData', which is 'dataLen' bytes long

  DataBlock(byte const *srcData, int dataLen, int allocatedSize)
    { ctor(srcData, dataLen, allocatedSize); }
  DataBlock(char const *srcData, int dataLen, int allocatedSize)
    { ctor((byte const*)srcData, dataLen, allocatedSize); }
    // make a copy of 'srcData', which is 'dataLen' bytes long, in a buffer
    // that is 'allocatedSize' bytes long

  DataBlock(DataBlock const &obj);
    // copy data, allocate same amount as 'obj'

  DataBlock(DataBlock const &obj, int minToAllocate);
    // copy obj's contents; allocate either obj.getAllocated() or
    // minToAllocate, whichever is larger (this turns out to be a
    // common idiom)

  ~DataBlock();

  // selectors
  byte const *getDataC() const { return data; }
  int getDataLen() const { return dataLen; }
  int getAllocated() const { return allocated; }

  bool dataEqual(DataBlock const &obj) const;
    // compares data length and data-length bytes of data

  bool allEqual(DataBlock const &obj) const;
    // compares data, length, and allocation length

  bool operator== (DataBlock const &obj) const
    { return dataEqual(obj); }
  bool operator!= (DataBlock const &obj) const
    { return !operator==(obj); }
    // SM, 1/24/99: with the coding of blokutil, I've finally clarified that
    // allocation length is a concern of efficiency, not correctness, and so
    // have changed the meaning of == to just look at data.  The old behavior
    // is available as 'allEqual()'.

  // mutators
  byte *getData() { return data; }
  void setDataLen(int newLen);
    // asserts that 0 <= newLen <= allocated
  void setAllocated(int newAllocated);     // i.e. realloc
  void addNull();
    // add a null ('\0') to the end; there must be sufficient allocated space

  void changeDataLen(int changeAmount)
    { setDataLen(getDataLen() + changeAmount); }

  void ensureAtLeast(int minAllocated);
    // if 'allocated' is currently less than minAllocated, then
    // set 'allocated' to minAllocated (preserving existing contents)

  void growDataLen(int changeAmount);
    // grows allocated data if necessary, whereas changeDataLen will throw
    // an exception if there isn't already enough allocated space

  void setFromString(char const *srcString);
  void setFromBlock(byte const *srcData, int dataLen);
  void setFromBlock(char const *srcData, int dataLen)
    { setFromBlock((byte const*)srcData, dataLen); }

  DataBlock& operator= (DataBlock const &obj);
    // causes data AND allocation length equality

  // convenient file read/write
  void writeToFile(char const *fname) const;
  void readFromFile(char const *fname);

  // for debugging
  enum { DEFAULT_PRINT_BYTES = 16 };
  void print(char const *label = NULL,
             int bytesPerLine = DEFAULT_PRINT_BYTES) const;
    // write a simple representation to stdout
    // if label is not NULL, the data is surrounded by '---'-style delimiters

  void dontPrint(char const *label = NULL,
                 int bytesPerLine = DEFAULT_PRINT_BYTES) const;
    // does nothing; useful for two reasons:
    //   1. lets me define macros that expand to 'print' during debug
    //      and dontPrint during non-debug
    //   2. plays a vital role in a g++ bug workaround (g++ sucks!!)

  // utility, defined here for no good reason
  static void printHexLine(byte const *data, int length, int lineLength);
    // print 'length' bytes of 'data' in hex
    // blank-pad the output as if 'linelen' bytes were present

  static void printPrintableLine(byte const *data, int length,
                                 char unprintable = '.');
    // print 'length' bytes of 'data', substituting 'unprintable' for bytes for
    // which 'isprint' is false
};

#endif // __DATABLOK_H

@h=tangler('elk/sm_exc.h')
@select(h)
// exc.h            see license.txt for copyright and terms of use
// exception classes for SafeTP project
// Scott McPeak, 1996-1998  This file is public domain.

#ifndef __EXC_H
#define __EXC_H

#include "sm_breaker.h"
#include "sm_typ.h"
#include "sm_xassert.h"
#include "sm_str.h"
#include <iostream>    // std::ostream

// forward declarations
class sm_stringBuilder;


// by using this macro, the debugger gets a shot before the stack is unwound
#ifdef THROW
#undef THROW
#endif
#define THROW(obj) \
  { breaker(); throw (obj); }


// this function returns true if we're in the process of unwinding the
// stack, and therefore destructors may want to avoid throwing new exceptions;
// for now, may return false positives, but won't return false negatives
bool unwinding();

// inside a catch expression, the unwinding() function needs a tweak; pass
// the caught expression, and this returns whether there any *additional*
// exceptions currently in flight
class xBase;
bool unwinding_other(xBase const &x);

// using unwinding() in destructors to avoid abort()
#define CAUTIOUS_RELAY           \
  catch (xBase &x) {             \
    if (!unwinding_other(x)) {   \
      throw;   /* re-throw */    \
    }                            \
  }


// -------------------- xBase ------------------
// intent is to derive all exception objects from this
class xBase {
  sm_string msg;
    // the human-readable description of the exception

public:
  static bool logExceptions;
    // initially true; when true, we write a record of the thrown exception
    // to clog

  static int creationCount;
    // current # of xBases running about; used to support unrolling()

public:
  xBase(char const *m);    // create exception object with message 'm'
  xBase(xBase const &m);   // copy ctor
  virtual ~xBase();

  char const *why() const
    { return (char const*)msg; }

  void insert(std::ostream &os) const;
  friend std::ostream& operator << (std::ostream &os, xBase const &obj)
    { obj.insert(os); return os; }
    // print why
};

// equivalent to THROW(xBase(msg))
void xbase(char const *msg) NORETURN;


// -------------------- x_assert -----------------------
// thrown by _xassert_fail, declared in xassert.h
// throwing this corresponds to detecting a bug in the program
class x_assert : public xBase {
  sm_string condition;          // text of the failed condition
  sm_string filename;           // name of the source file
  int lineno;                // line number

public:
  x_assert(char const *cond, char const *fname, int line);
  x_assert(x_assert const &obj);
  ~x_assert();

  char const *cond() const { return (char const *)condition; }
  char const *fname() const { return (char const *)filename; }
  int line() const { return lineno; }
};


// ---------------------- xFormat -------------------
// throwing this means a formatting error has been detected
// in some input data; the program cannot process it, but it
// is not a bug in the program
class xFormat : public xBase {
  sm_string condition;          // what is wrong with the input

public:
  xFormat(char const *cond);
  xFormat(xFormat const &obj);
  ~xFormat();

  char const *cond() const { return (char const*)condition; }
};

// compact way to throw an xFormat
void xformat(char const *condition) NORETURN;

// convenient combination of condition and human-readable message
#define checkFormat(cond, message) \
  ((cond)? (void)0 : xformat(message))

// assert-like interface to xFormat
void formatAssert_fail(char const *cond, char const *file, int line) NORETURN;

#define formatAssert(cond) \
  ((cond)? (void)0 : formatAssert_fail(#cond, __FILE__, __LINE__))

  
// -------------------- XOpen ---------------------
// thrown when we fail to open a file
class XOpen : public xBase {
public:
  sm_string filename;
  
public:
  XOpen(char const *fname);
  XOpen(XOpen const &obj);
  ~XOpen();
};

void throw_XOpen(char const *fname) NORETURN;


#endif // __EXC_H

@h=tangler('elk/sm_flatten.h')
@select(h)
// flatten.h            see license.txt for copyright and terms of use
// interface to automate process of flattening structures made of objects with
//   arbitrary types, and possibly circular references
// this is a trimmed-down version of the one in 'proot'

#ifndef FLATTEN_H
#define FLATTEN_H

#include "sm_trdelete.h"

class Flatten {
public:
  Flatten();
  virtual ~Flatten();

  TRASHINGDELETE;

  // query the read/write state
  virtual bool reading() const = 0;
  bool writing() const { return !reading(); }

  // transferring xfer a simple data type of fixed length
  // 'len', in bytes
  virtual void xferSimple(void *var, unsigned len)=0;

  // syntactic sugar
  //#define xferVar(varname) xferSimple(&varname, sizeof(varname))
  //#define XFERV(varname) flat.xferVar(varname)

  // xfer various C built-in data types (will add them as I need them)
  virtual void xferChar(char &c);
  virtual void xferInt(int &i);
  virtual void xferLong(long &l);
  virtual void xferBool(bool &b);

  // read or write a null-terminated character buffer, allocated with new;
  // this works if 'str' is NULL
  virtual void xferCharString(char *&str);

  // xfer a buffer allocated with 'new', of a given length
  virtual void xferHeapBuffer(void *&buf, int len);

  // read: write the code; write: read & compare to code, fail if != ;
  // the code is arbitrary, but should be unique across the source tree
  // (I usually make the code with my Emacs' Ctl-Alt-R, which inserts a random number)
  virtual void checkpoint(int code);

  // ------------- utilities ---------
  // for when we already know whether we're reading or writing; internally,
  // these assert which state we're in
  void writeInt(int i);
  int readInt();
   
  // ------------- owner/serf ------------
  // take note of an owner pointer where we expect to xfer serfs to it
  virtual void noteOwner(void *ownerPtr) = 0;

  // xfer a serf pointer that we've previously taken note of
  virtual void xferSerf(void *&serfPtr, bool nullable=false) = 0;
  void writeSerf(void *serfPtr);
  void *readSerf();
};

#endif // FLATTEN_H
@h=tangler('elk/sm_gprintf.h')
@select(h)
/* gprintf.h
 * generalized printf interface
 * http://www.efgh.com/software/gprintf.htm 
 * this file is in the public domain */

#ifndef GPRINTF_H
#define GPRINTF_H

#include <stdarg.h>      /* va_list */

#ifdef __cplusplus
extern "C" {
#endif

/* This is called once for each output character.  It returns >=0 for
 * success or <0 for failure, in which case that code will end up as
 * the return value from general_printf.  'extra' is user-defined
 * context, and is passed the same value as the 'extra' arg to
 * general_printf.  'ch' is of course the character to output. */
typedef int (*Gprintf_output_function)(void *extra, int ch);

/* Interpret 'format' and 'args' as printf does, but calling
 * 'output' for each rendered character.  Returns the # of characters
 * output (not including final NUL), or <0 for failure (same code
 * that 'output' returns if it fails). */
int general_vprintf(Gprintf_output_function output,
                    void *extra, const char *format, va_list args);

/* same thing but accepting variable # of args directly */
int general_printf(Gprintf_output_function output,
                   void *extra, const char *format, ...);

#ifdef __cplusplus
}
#endif

#endif /* GPRINTF_H */
@h=tangler('elk/sm_growbuf.h')
@select(h)
// growbuf.h            see license.txt for copyright and terms of use
// buffer that grows as needed by doubling in size

#ifndef __GROWBUF_H
#define __GROWBUF_H

#include "sm_datablok.h"

class GrowBuffer : public DataBlock {
public:
  GrowBuffer(int allocSize=0)
    : DataBlock(allocSize) {}
  ~GrowBuffer() {}

  // append to the end, at least doubling allocated
  // size if growth is needed
  void append(byte const *str, int len);
  void append(char const *str, int len)
    { append((byte const*)str, len); }
};

#endif // __GROWBUF_H
@h=tangler('elk/sm_hashline.h')
@select(h)
// hashline.h
// module for maintaining and using #line info in source files

// terminology:
//   pp source: preprocessed source, i.e. whatever had the #line
//              info sprinkled throughout it
//   orig source: original source, the files to which the #line
//                directives refer

#ifndef HASHLINE_H
#define HASHLINE_H

#include "sm_strobjdict.h"
#include "sm_array.h"

// map from lines in some given pp source file to lines in
// orig source files; there should be one HashLineMap object
// for each pp source file of interest
class HashLineMap {
private:    // types
  // records a single #line directive
  class HashLine {
  public:
    int ppLine;              // pp source line where it appears
    int origLine;            // orig line it names
    char const *origFname;   // orig fname it names
    
  public:
    HashLine()
      : ppLine(0), origLine(0), origFname(NULL) {}
    HashLine(int pl, int ol, char const *of)
      : ppLine(pl), origLine(ol), origFname(of) {}
    HashLine(HashLine const &obj)
      : DMEMB(ppLine), DMEMB(origLine), DMEMB(origFname) {}
  };

private:    // data
  // name of the pp file; this is needed for queries to lines
  // before any #line is encountered
  sm_string ppFname;

  // map for canonical storage of orig filenames; I don't rely on
  // an external sm_string table because I don't want the extra
  // dependency
  StringObjDict<sm_string> filenames;

  // growable array of HashLine objects
  ArrayStack<HashLine> directives;

  // previously-added ppLine; used to verify the entries are
  // being added in sorted order
  int prev_ppLine;

public:     // funcs
  HashLineMap(char const *ppFname);
  ~HashLineMap();

  // call this time each time a #line directive is encountered;
  // successive calls must have strictly increasing values of 'ppLine'
  void addHashLine(int ppLine, int origLine, char const *origFname);

  // call this when all the #line directives have been added; this
  // consolidates the 'directives' array to reclaim any space created
  // during the growing process but that is now not needed
  void doneAdding();

  // map from pp line to orig line/file; note that queries exactly on
  // #line lines have undefined results
  void map(int ppLine, int &origLine, char const *&origFname) const;
  int mapLine(int ppLine) const;           // returns 'origLine'
  char const *mapFile(int ppLine) const;   // returns 'origFname'
  
  // for curiosity, find out how many unique filenames are recorded in
  // the 'filenames' dictionary
  int numUniqueFilenames() { return filenames.size(); }
};

#endif // HASHLINE_H
@h=tangler('elk/sm_hashtbl.h')
@select(h)
// hashtbl.h            see license.txt for copyright and terms of use
// hash table mapping arbitrary keys to void*, where
// the stored pointers can be used to derive the key,
// and cannot be NULL

#ifndef HASHTBL_H
#define HASHTBL_H

#include "sm_typ.h"

class HashTable {
private:    // types
  friend class HashTableIter;

public:     // types
  // given a stored data pointer, retrieve the associated key
  typedef void const* (*GetKeyFn)(void *data);

  // given a key, retrieve the associated hash value;
  // this should be a 32-bit integer ready to be mod'd by the table size
  typedef unsigned (*HashFn)(void const *key);

  // compare two keys; this is needed so we can handle collisions
  // in the hash function; return true if they are equal
  typedef bool (*EqualKeyFn)(void const *key1, void const *key2);

  // constants
  enum {
    defaultSize = 33
  };

private:    // data
  // maps
  GetKeyFn getKey;
  HashFn coreHashFn;
  EqualKeyFn equalKeys;

  // array of pointers to data, indexed by the hash value,
  // with collisions resolved by moving to adjacent entries;
  // some entries are NULL, meaning that hash value has no mapping
  void **hashTable;

  // Why use linear hashing instead of double hashing?  To support
  // deletion.  Since every probe sequence that goes through index k
  // will have a tail of k+1,k+2,... (mod tableSize) I can easily find
  // and re-insert all the elements whose position might have depended
  // on the presence of a now-deleted element.  Excessive clustering
  // is (hopefully) avoided through load factor control.

  // number of slots in the hash table
  int tableSize;

  // number of mapped (non-NULL) entries
  int numEntries;
  
  // when false, we never make the table smaller (default: true)
  bool enableShrink;

private:    // funcs
  // disallowed
  HashTable(HashTable&);
  void operator=(HashTable&);
  void operator==(HashTable&);

  // hash fn for the current table size; always in [0,tableSize-1]
  unsigned hashFunction(void const *key) const;

  // given a collision at 'index', return the next index to try
  int nextIndex(int index) const { return (index+1) % tableSize; }

  // resize the table, transferring all the entries to their
  // new positions
  void resizeTable(int newSize);

  // return the index of the entry corresponding to 'data' if it
  // is mapped, or a pointer to the entry that should be filled
  // with its mapping, if unmapped
  int getEntry(void const *key) const;

  // make a new table with the given size
  void makeTable(int size);

  // check a single entry for integrity
  void checkEntry(int entry) const;

public:     // funcs
  HashTable(GetKeyFn gk, HashFn hf, EqualKeyFn ek,
            int initSize = HashTable::defaultSize);
  ~HashTable();

  // return # of mapped entries
  int getNumEntries() const { return numEntries; }

  // if this hash value has a mapping, return it; otherwise,
  // return NULL
  void *get(void const *key) const;

  // add a mapping from 'key' to 'value'; there must not already
  // be a mapping for this key
  void add(void const *key, void *value);

  // remove the mapping for 'key' -- it must exist
  // returns the removed item
  void *remove(void const *key);

  // remove all mappings
  void empty(int initSize = HashTable::defaultSize);

  // set whether shrinkage is allowed; it's useful to be able to
  // disable this to avoid any allocation in certain situations
  void setEnableShrink(bool en) { enableShrink = en; }

  // allow external access to an accessor function
  void const *callGetKeyFn(void *data) { return getKey(data); }

  // check the data structure's invariants, and throw an exception
  // if there is a problem
  void selfCheck() const;

  // ------ useful default functions -------
  // returns its argument
  static void const* identityKeyFn(void *data);

  // puts the argument through two cycles of a linear
  // congruential pseudo-random number generator
  static unsigned lcprngHashFn(void const *key);

  // does pointer equality comparison
  static bool pointerEqualKeyFn(void const *key1, void const *key2);
};

unsigned lcprngTwoSteps(unsigned v);


// iterate over all stored values in a HashTable
// NOTE: you can't change the table while an iter exists
class HashTableIter {
private:      // data
  HashTable &table;      // table we're iterating over
  int index;             // current slot to return in adv(); -1 when done

private:      // funcs
  void moveToSth();

public:       // funcs
  HashTableIter(HashTable &table);

  bool isDone() const { return index == -1; }
  void adv();
  void *data() const;          // returns a value stored in the table
};


#endif // HASHTBL_H
@h=tangler('elk/sm_macros.h')
@select(h)
// macros.h            see license.txt for copyright and terms of use
// grab-bag of useful macros, stashed here to avoid mucking up
//   other modules with more focus; there's no clear rhyme or
//   reason for why some stuff is here and some in typ.h
// (no configuration stuff here!)

#ifndef __MACROS_H
#define __MACROS_H

#include "sm_typ.h"

// complement of ==
#define NOTEQUAL_OPERATOR(T)             \
  bool operator != (T const &obj) const  \
    { return !operator==(obj); }

// toss this into a class that already has == and < defined, to
// round out the set of relational operators (assumes a total
// order, i.e.  a < b  <=>  b < a)
#define RELATIONAL_OPERATORS(T)                    \
  NOTEQUAL_OPERATOR(T)                             \
  bool operator <= (T const &obj) const            \
    { return !obj.operator<(*this); }              \
  bool operator > (T const &obj) const             \
    { return obj.operator<(*this); }               \
  bool operator >= (T const &obj) const            \
    { return !operator<(obj); }


// member copy in constructor initializer list
#define DMEMB(var) var(obj.var)

// member copy in operator =
#define CMEMB(var) var = obj.var

// member comparison in operator ==
#define EMEMB(var) var == obj.var


// standard insert operator
// (note that you can put 'virtual' in front of the macro call if desired)
#define INSERT_OSTREAM(T)                                \
  void insertOstream(std::ostream &os) const;                 \
  friend std::ostream& operator<< (std::ostream &os, T const &obj) \
    { obj.insertOstream(os); return os; }


// usual declarations for a data object (as opposed to control object)
#define DATA_OBJ_DECL(T)                \
  T();                                  \
  T(T const &obj);                      \
  ~T();                                 \
  T& operator= (T const &obj);          \
  bool operator== (T const &obj) const; \
  NOTEQUAL_OPERATOR(T)                  \
  INSERTOSTREAM(T)


// copy this to the .cc file for implementation of DATA_OBJ_DECL
#if 0
T::T()
{}

T::T(T const &obj)
  : DMEMB(),
    DMEMB(),
    DMEMB()
{}

T::~T()
{}

T& T::operator= (T const &obj)
{
  if (this != &obj) {
    CMEMB();
  }
  return *this;
}

bool T::operator== (T const &obj) const
{
  return
    EMEMB() &&
    EMEMB();
}

void T::insertOstream(std::ostream &os) const
{}
#endif // 0


// assert something at compile time (must use this inside a function);
// works because compilers won't let us declare negative-length arrays
// (the expression below works with egcs-1.1.2, gcc-2.x, gcc-3.x)
#define STATIC_ASSERT(cond) \
  { (void)((int (*)(char failed_static_assertion[(cond)?1:-1]))0); }

// assert that a table is an expected size; the idea is to make sure
// that static data in some table gets updated when a corresponding
// symbolic constant is changed
#define ASSERT_TABLESIZE(table, size) \
  STATIC_ASSERT(TABLESIZE(table) == (size))

  
// for silencing variable-not-used warnings
template <class T>
inline void pretendUsedFn(T const &) {}
#define PRETEND_USED(arg) pretendUsedFn(arg) /* user ; */


// appended to function declarations to indicate they do not
// return control to their caller; e.g.:
//   void exit(int code) NORETURN;
#ifdef __GNUC__
  #define NORETURN __attribute__((noreturn))
#else             
  // just let the warnings roll if we can't suppress them
  #define NORETURN
#endif


// these two are a common idiom in my code for typesafe casts;
// they are essentially a roll-your-own RTTI
#define CAST_MEMBER_FN(destType)                                                \
  destType const &as##destType##C() const;                                      \
  destType &as##destType() { return const_cast<destType&>(as##destType##C()); }

#define CAST_MEMBER_IMPL(inClass, destType)         \
  destType const &inClass::as##destType##C() const  \
  {                                                 \
    xassert(is##destType());                        \
    return (destType const&)(*this);                \
  }


// same as the above, but returning pointers; I think returning
// references was a mistake
#define DOWNCAST_FN(destType)                                                   \
  destType const *as##destType##C() const;                                      \
  destType *as##destType() { return const_cast<destType*>(as##destType##C()); }

#define DOWNCAST_IMPL(inClass, destType)            \
  destType const *inClass::as##destType##C() const  \
  {                                                 \
    xassert(is##destType());                        \
    return static_cast<destType const*>(this);      \
  }


// keep track of a count and a high water mark
#define INC_HIGH_WATER(count, highWater)  \
  count++;                                \
  if (count > highWater) {                \
    highWater = count;                    \
  }


// egcs has the annoying "feature" that it warns
// about switches on enums where not all cases are
// covered .... what is this, f-ing ML??
#define INCL_SWITCH \
  default: break; /*silence warning*/ 


// for a class that maintains allocated-node stats
#define ALLOC_STATS_DECLARE                     \
  static int numAllocd;                         \
  static int maxAllocd;                         \
  static void printAllocStats(bool anyway);

// these would go in a .cc file, whereas above goes in .h file
#define ALLOC_STATS_DEFINE(classname)                      \
  int classname::numAllocd = 0;                            \
  int classname::maxAllocd = 0;                            \
  STATICDEF void classname::printAllocStats(bool anyway)   \
  {                                                        \
    if (anyway || numAllocd != 0) {                        \
      std::cout << #classname << " nodes: " << numAllocd        \
           << ", max  nodes: " << maxAllocd                \
           << std::endl;                                        \
    }                                                      \
  }

#define ALLOC_STATS_IN_CTOR                     \
  INC_HIGH_WATER(numAllocd, maxAllocd);

#define ALLOC_STATS_IN_DTOR                     \
  numAllocd--;

  
// ----------- automatic data value restorer -------------
// used when a value is to be set to one thing now, but restored
// to its original value on return (even when the return is by
// an exception being thrown)
template <class T>
class Restorer {
  T &variable;
  T prevValue;
  
public:
  Restorer(T &var, T newValue)
    : variable(var),
      prevValue(var)
  {
    variable = newValue;
  }
   
  // this one does not set it to a new value, just remembers the current
  Restorer(T &var)
    : variable(var),
      prevValue(var)
  {}

  ~Restorer()
  {
    variable = prevValue;
  }
};


// declare a bunch of a set-like operators for enum types
#define ENUM_BITWISE_AND(Type)                  \
  inline Type operator& (Type f1, Type f2)      \
    { return (Type)((int)f1 & (int)f2); }       \
  inline Type& operator&= (Type &f1, Type f2)   \
    { return f1 = f1 & f2; }

#define ENUM_BITWISE_OR(Type)                   \
  inline Type operator| (Type f1, Type f2)      \
    { return (Type)((int)f1 | (int)f2); }       \
  inline Type& operator|= (Type &f1, Type f2)   \
    { return f1 = f1 | f2; }

#define ENUM_BITWISE_XOR(Type)                  \
  inline Type operator^ (Type f1, Type f2)      \
    { return (Type)((int)f1 ^ (int)f2); }       \
  inline Type& operator^= (Type &f1, Type f2)   \
    { return f1 = f1 ^ f2; }

#define ENUM_BITWISE_NOT(Type, ALL)             \
  inline Type operator~ (Type f)                \
    { return (Type)((~(int)f) & ALL); }

#define ENUM_BITWISE_OPS(Type, ALL)             \
  ENUM_BITWISE_AND(Type)                        \
  ENUM_BITWISE_OR(Type)                         \
  ENUM_BITWISE_XOR(Type)                        \
  ENUM_BITWISE_NOT(Type, ALL)


// macro to conditionalize something on NDEBUG; I typically use this
// to hide the declaration of a variable whose value is only used by
// debugging trace statements (and thus provokes warnings about unused
// variables if NDEBUG is set)
#ifdef NDEBUG
  #define IFDEBUG(stuff)
#else
  #define IFDEBUG(stuff) stuff
#endif


// put at the top of a class for which the default copy ctor
// and operator= are not desired; then don't define these functions
#define NO_OBJECT_COPIES(name)   \
  private:                       \
    name(name&);                 \
    void operator=(name&) /*user ;*/


#endif // __MACROS_H
@h=tangler('elk/sm_missing.h')
@select(h)
// missing.h            see license.txt for copyright and terms of use
// routines that I implemented because they aren't available on all platforms
// Scott McPeak, 1998  This file is public domain.

#ifndef __MISSING_H
#define __MISSING_H

// stricmp
int missing_stricmp(char const *s1, char const *s2);

#endif // __MISSING_H

@h=tangler('elk/sm_mysig.h')
@select(h)
// mysig.h            see license.txt for copyright and terms of use
// some simple Unix signal-handling stuff

#ifndef MYSIG_H
#define MYSIG_H

#include <signal.h>     // signal stuff
#include <setjmp.h>     // jmp_buf

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

// type of a signal handler function; generally, there are
// three options for a signal handler:
//   - return, in which case the default action for the
//     signal is taken
//   - longjmp to a state where computation can resume
//   - abort(2) or exit(2)
// it's somewhat dangerous to do other system calls, but people
// do it anyway
typedef void (*SignalHandler)(int signum);


// install the given handler on the given signal
void setHandler(int signum, SignalHandler handler);


// simple handler that just prints and re-raises
void printHandler(int signum);


// to use jmpHandler, call setjmp(sane_state) before
// installing the handler
extern jmp_buf sane_state;

// handler to do a longjmp to sane_state
void jmpHandler(int signum);


// install a segfault handler that will print the address that
// caused the fault; this is very useful for debugging
void printSegfaultAddrs();


#ifdef __cplusplus
}
#endif // __cplusplus

#endif // MYSIG_H
@h=tangler('elk/sm_nonport.h')
@select(h)
// nonport.h            see license.txt for copyright and terms of use
// collection of nonportable routines (the interfaces
//   are portable, but the implementations are not)
// Scott McPeak, Dan Bonachea 1998-1999  This file is public domain.

#ifndef __NONPORT_H
#define __NONPORT_H

#include "sm_typ.h"
#include <stdarg.h>  // va_list


// I'm attempting to improve error handling in this module; this fn will be
// called when a syscall fails, *in addition* to whatever error behavior
// is documented here (e.g., a fn might call this, and then return false).
// The default behavior is to do nothing.  In sftpc and sftpd, I plan to
// point this at xSysError::xsyserror (see syserr.h).
typedef void (*NonportFailFunc)(char const *syscallName, char const *context);
  // syscallName  - name of failing system call
  // context      - current activity (maybe just calling fn's name) or NULL
extern NonportFailFunc nonportFail;

// this is default handler
void defaultNonportFail(char const *syscallName, char const *context);



// put terminal into 'raw' or 'cooked' mode
void setRawMode(bool raw);

// get the next character typed without buffering or echoing; needs the
// console to be in 'raw' mode
char getConsoleChar();


// get a millisecond count, where 0 is an unspecified event
long getMilliseconds();


// remove all priviledges to a file, except for read/write
// access by the file's owner; returns false on error
bool limitFileAccess(char const *fname);


// get process id; meaning is somewhat system-dependent, but the goal
// is to return something that can be used to correlate log output
// from (say) sftpd with log output from some other source (syslog,
// or NT event viewer, etc.)
#if 0
int getProcessId();
#endif

// create a new directory; returns false on error;
// precise naming semantics, such as use
// of 'current working directory', etc., are specified by the
// underlying OS's mkdir (or equivalent) command (it is hoped
// this underspecification will not be a problem in practice)
bool createDirectory(char const *dirname);

// change to a directory; returns false on failure
// again, current-directory semantics are unspecified
bool changeDirectory(char const *dirname);

// retrieve the name of the current working directory
// (more best effort crap, I guess)
bool getCurrentDirectory(char *dirname, int dirnameLen);


// get and process the names of files *and directories* in the current directory
typedef bool (*PerFileFunc)(char const *name, void *extra);
  // name   - file/dir being processed (contains no slashes)
  // extra  - 2nd parameter to applyToCwdContents
  // return - true to continue, false to stop iterating
void applyToCwdContents(PerFileFunc func, void *extra=NULL);

// same as above, but in an explicitly named directory
void applyToDirContents(char const *dirName,
                        PerFileFunc func, void *extra=NULL);


// return true if the given sm_string names a directory
bool isDirectory(char const *path);


// delete a file; returns false on failure
bool removeFile(char const *fname);


// retrieve the current date
void getCurrentDate(int &month, int &day, int &year);
  // month:    1 = January ... 12 = December
  // day:      1 = first day of month, ...
  // year:     1999 is when this being coded
  // e.g., February 8, 1999  is  month=2, day=8, year=1999


// sleep for a bit (low resolution)
void portableSleep(unsigned seconds);


/*
// determine usable name of current user, and write it into 'buffer'
void getCurrentUsername(char *buffer, int buflen);
*/

// read a sm_string from the console, with no echo
void readNonechoString(char *buffer, int buflen, char const *prompt);


// return true if a file or directory exists
bool fileOrDirectoryExists(char const *name);


// ensure that the pathname part of a file name exists;
// it creates missing directories as necessary, with only
// user rwx permission; if 'isDirectory' is true, the whole
// name is also verified as a directory; returns false on
// error
bool ensurePath(char const *filename, bool isDirectory);


// returns true if the system has a cryptographically-
// secure random number generator
bool hasSystemCryptoRandom();

// if the above fn returns true, this will retrieve a
// random 32-bit integer; may block until the bits
// become available
unsigned getSystemCryptoRandom();


// determine how many characters, *not* including the final NUL, would
// be written by vsprintf; this is allowed to overestimate
int vnprintf(char const *format, va_list args);

// this is implemented in terms of vnprintf, so not technically
// a function with "nonportable implementation", but it belongs
// here anyway
int nprintf(char const *format, ...);


#endif // __NONPORT_H

@h=tangler('elk/sm_objlist.h')
@select(h)
// objlist.h
// owner list of arbitrary dynamically-allocated objects
// NOTE: automatically generated from xobjlist.h -- do not edit directly

// Author: Scott McPeak, 2000

#ifndef OBJLIST_H
#define OBJLIST_H

#include "sm_voidlist.h"


// forward declarations of template classes, so we can befriend them in ObjList
// (not required by Borland C++ 4.5, but GNU wants it...)
template <class T> class ObjListIter;
template <class T> class ObjListMutator;
template <class T> class ObjListIterNC;


// the list is considered to own all of the items; it is an error to insert
// an item into more than one such list, or to insert an item more than once
// into any such list
template <class T>
class ObjList {
private:
  friend class ObjListIter<T>;
  friend class ObjListMutator<T>;
  friend class ObjListIterNC<T>;

protected:
  VoidList list;                        // list itself

private:
  // this is an owner list; these are not allowed
  ObjList(ObjList const &obj);
  ObjList& operator= (ObjList const &src);

public:
  ObjList()                            : list() {}
  ~ObjList()                           { deleteAll(); }

  // The difference function should return <0 if left should come before
  // right, 0 if they are equivalent, and >0 if right should come before
  // left.  For example, if we are sorting numbers into ascending order,
  // then 'diff' would simply be subtraction.
  typedef int (*Diff)(T const *left, T const *right, void *extra);

  // selectors
  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }
  T *nth(int which)                     { return (T*)list.nth(which); }
  T const *nthC(int which) const        { return (T const*)list.nth(which); }
  T *first()                            { return (T*)list.first(); }
  T const *firstC() const               { return (T const*)list.first(); }
  T *last()                             { return (T*)list.last(); }
  T const *lastC() const                { return (T const*)list.last(); }

  // insertion
  void prepend(T *newitem)              { list.prepend((void*)newitem); }
  void append(T *newitem)               { list.append((void*)newitem); }
  void insertAt(T *newitem, int index)  { list.insertAt((void*)newitem, index); }
  void insertSorted(T *newitem, Diff diff, void *extra=NULL)
    { list.insertSorted((void*)newitem, (VoidDiff)diff, extra); }

  // removal
  T *removeAt(int index)                { return (T*)list.removeAt(index); }
  T *removeFirst()                      { return (T*)list.removeFirst(); }
  void deleteAt(int index)              { delete (T*)list.removeAt(index); }
  void deleteAll();

  // list-as-set: selectors
  int indexOf(T const *item) const      { return list.indexOf((void*)item); }
  int indexOfF(void *item) const        { return list.indexOfF((void*)item); }
  bool contains(T const *item) const    { return list.contains((void*)item); }

  // list-as-set: mutators
  bool prependUnique(T *newitem)        { return list.prependUnique((void*)newitem); }
  bool appendUnique(T *newitem)         { return list.appendUnique((void*)newitem); }
  void removeItem(T const *item)        { list.removeItem((void*)item); }    // whether the arg should be const is debatable..
  bool removeIfPresent(T const *item)   { return list.removeIfPresent((void*)item); }

  // complex modifiers
  void reverse()                                    { list.reverse(); }
  void insertionSort(Diff diff, void *extra=NULL)   { list.insertionSort((VoidDiff)diff, extra); }
  void mergeSort(Diff diff, void *extra=NULL)       { list.mergeSort((VoidDiff)diff, extra); }

  // and a related test
  bool isSorted(Diff diff, void *extra=NULL) const  { return list.isSorted((VoidDiff)diff, extra); }

  // multiple lists
  void concat(ObjList &tail)                       { list.concat(tail.list); }
  // (we do *not* have appendAll, since these are supposed to be owner lists)

  // steal
  void stealTailAt(int index, ObjList &tail)       { list.stealTailAt(index, tail.list); }

  // equal items in equal positions
  bool equalAsLists(ObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.equalAsLists(otherList.list, (VoidDiff)diff, extra); }
  int compareAsLists(ObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.compareAsLists(otherList.list, (VoidDiff)diff, extra); }

  // last-as-set: comparisons (NOT efficient)
  bool equalAsSets(ObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.equalAsSets(otherList.list, (VoidDiff)diff, extra); }
  bool isSubsetOf(ObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.isSubsetOf(otherList.list, (VoidDiff)diff, extra); }
  bool containsByDiff(T const *item, Diff diff, void *extra=NULL) const
    { return list.containsByDiff((void*)item, (VoidDiff)diff, extra); }

  // treating the pointer values themselves as the basis for comparison
  bool equalAsPointerLists(ObjList const &otherList) const
    { return list.equalAsPointerLists(otherList.list); }
  bool equalAsPointerSets(ObjList const &otherList) const
    { return list.equalAsPointerSets(otherList.list); }

  // debugging: two additional invariants
  void selfCheck() const { 
    list.selfCheck();
    list.checkHeapDataPtrs();
    list.checkUniqueDataPtrs();
  }
};


template <class T>
void ObjList<T>::deleteAll()
{
  while (!list.isEmpty()) {
    deleteAt(0);
  }
}


// for traversing the list and modifying it (nodes and/or structure)
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists, and only one such iterator should exist for
//       any given list
template <class T>
class ObjListMutator {
  friend class ObjListIter<T>;

protected:
  VoidListMutator mut;       // underlying mutator

public:
  ObjListMutator(ObjList<T> &lst)     : mut(lst.list) { reset(); }
  ~ObjListMutator()                    {}

  void reset()                          { mut.reset(); }

  // iterator copying; safe *only* until one of the mutators modifies
  // the list structure (by inserting or removing), at which time all
  // other iterators might be in limbo
  ObjListMutator(ObjListMutator const &obj)             : mut(obj.mut) {}
  ObjListMutator& operator=(ObjListMutator const &obj)  { mut = obj.mut;  return *this; }
    // requires that 'this' and 'obj' already refer to the same 'list'

  // iterator actions
  bool isDone() const                   { return mut.isDone(); }
  void adv()                            { mut.adv(); }
  T *data()                             { return (T*)mut.data(); }
  T *&dataRef()                         { return (T*&)mut.dataRef(); }

  // insertion
  void insertBefore(T *item)            { mut.insertBefore((void*)item); }
    // 'item' becomes the new 'current', and the current 'current' is
    // pushed forward (so the next adv() will make it current again)

  void insertAfter(T *item)             { mut.insertAfter((void*)item); }
    // 'item' becomes what we reach with the next adv();
    // isDone() must be false

  void append(T *item)                  { mut.append((void*)item); }
    // only valid while isDone() is true, it inserts 'item' at the end of
    // the list, and advances such that isDone() remains true; equivalent
    // to { xassert(isDone()); insertBefore(item); adv(); }

  // removal
  T *remove()                           { return (T*)mut.remove(); }
    // 'current' is removed from the list and returned, and whatever was
    // next becomes the new 'current'

  void deleteIt()                       { delete (T*)mut.remove(); }
    // same as remove(), except item is deleted also

  // debugging
  void selfCheck() const                { mut.selfCheck(); }
};

#define MUTATE_EACH_OBJLIST(T, list, iter) \
  for(ObjListMutator< T > iter(list); !iter.isDone(); iter.adv())


// for traversing the list without modifying it (neither nodes nor structure)
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists
template <class T>
class ObjListIter {
protected:
  VoidListIter iter;      // underlying iterator

public:
  ObjListIter(ObjList<T> const &list) : iter(list.list) {}
  ObjListIter(ObjList<T> const &list, int pos) : iter(list.list, pos) {}
  ~ObjListIter()                       {}

  void reset(ObjList<T> const &list)   { iter.reset(list.list); }

  // iterator copying; generally safe
  ObjListIter(ObjListIter const &obj)             : iter(obj.iter) {}
  ObjListIter& operator=(ObjListIter const &obj)  { iter = obj.iter;  return *this; }

  // but copying from a mutator is less safe; see above
  ObjListIter(ObjListMutator<T> &obj)             : iter(obj.mut) {}

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T const *data() const                 { return (T const*)iter.data(); }
};

#define FOREACH_OBJLIST(T, list, iter) \
  for(ObjListIter< T > iter(list); !iter.isDone(); iter.adv())


// intermediate to the above two, this allows modification of the
// objects stored on the list, but not the identity or order of
// the objects in the list
template <class T>
class ObjListIterNC {
protected:
  VoidListIter iter;      // underlying iterator

public:
  ObjListIterNC(ObjList<T> &list) : iter(list.list) {}
  ObjListIterNC(ObjList<T> &list, int pos) : iter(list.list, pos) {}
  ~ObjListIterNC()                     {}

  void reset(ObjList<T> &list)         { iter.reset(list.list); }

  // iterator copying; generally safe
  ObjListIterNC(ObjListIterNC const &obj)             : iter(obj.iter) {}
  ObjListIterNC& operator=(ObjListIterNC const &obj)  { iter = obj.iter;  return *this; }

  // but copying from a mutator is less safe; see above
  ObjListIterNC(ObjListMutator<T> &obj)               : iter(obj.mut) {}

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T *data() const                       { return (T*)iter.data(); }
};

#define FOREACH_OBJLIST_NC(T, list, iter) \
  for(ObjListIterNC< T > iter(list); !iter.isDone(); iter.adv())


// iterate over the combined elements of two or more lists
template <class T>
class ObjListMultiIter {
private:
  // all the lists
  ObjList<T> **lists;                // serf array of serf list pointers
  int numLists;                      // length of this array

  // current element
  int curList;                       // which list we're working on
  ObjListIter<T> iter;               // current element of that list

  // invariant:
  //   either curList==numLists, or
  //   iter is not 'done'

public:
  ObjListMultiIter(ObjList<T> **L, int n)
    : lists(L),
      numLists(n),
      curList(0),
      iter(*(lists[0]))
  {
    xassert(n > 0);
    normalize();
  }

  // advance the iterator to the next element of the next non-empty list;
  // establishes invariant above
  void normalize();

  bool isDone() const {
    return curList == numLists;
  }

  T const *data() const {
    return iter.data();
  }

  void adv() {
    iter.adv();
    normalize();
  }
};

// this was originally inline, but that was causing some strange
// problems (compiler bug?)
template <class T>
void ObjListMultiIter<T>::normalize()
{
  while (iter.isDone() && curList < numLists) {
    curList++;
    if (curList < numLists) {
      iter.reset(*(lists[curList]));
    }
  }
}


#endif // OBJLIST_H
@h=tangler('elk/sm_objpool.h')
@select(h)
// objpool.h            see license.txt for copyright and terms of use
// custom allocator: array of objects meant to be
// re-used frequently, with high locality

#ifndef OBJPOOL_H
#define OBJPOOL_H

#include "sm_array.h"

// the class T should have:
//   // a link in the free list; it is ok for T to re-use this
//   // member while the object is not free in the pool
//   T *nextInFreeList;
//
//   // object is done being used for now
//   void deinit();
//
//   // needed so we can make arrays
//   T::T();

template <class T>
class ObjectPool {
private:     // data
  // when the pool needs to expand, it expands by allocating an
  // additional 'rackSize' objects; I use a linear (instead of
  // exponential) expansion strategy because these are supposed
  // to be used for small sets of rapidly-reused objects, not
  // things allocated for long-term storage
  int rackSize;

  // growable array of pointers to arrays of 'rackSize' T objects
  ArrayStack<T*> racks;

  // head of the free list; NULL when empty
  T *head;

private:     // funcs
  void expandPool();

public:      // funcs
  ObjectPool(int rackSize);
  ~ObjectPool();

  // yields a pointer to an object ready to be used; typically,
  // T should have some kind of init method to play the role a
  // constructor ordinarily does; this might cause the pool to
  // expand (but previously allocated objects do *not* move)
  inline T *alloc();

  // return an object to the pool of objects; dealloc internally
  // calls obj->deinit()
  inline void dealloc(T *obj);

  // same as 'dealloc', but without the call to 'deinit'
  inline void deallocNoDeinit(T *obj);

  // available for diagnostic purposes
  int freeObjectsInPool() const;
  
  // low-level access for heavily-optimized client code; clients that
  // use these functions accept the burden of possibly needing to
  // change if internals of ObjectPool change
  T *private_getHead() { return head; }
  void private_setHead(T *h) { head = h; }
};


template <class T>
ObjectPool<T>::ObjectPool(int rs)
  : rackSize(rs),
    racks(5),
    head(NULL)
{}

template <class T>
ObjectPool<T>::~ObjectPool()
{
  // deallocate all the objects in the racks
  for (int i=0; i < racks.length(); i++) {
    delete[] racks[i];
  }
}


template <class T>
inline T *ObjectPool<T>::alloc()
{
  if (!head) {
    // need to expand the pool
    expandPool();
  }

  T *ret = head;                     // prepare to return this one
  head = ret->nextInFreeList;        // move to next free node

  #ifndef NDEBUG
    ret->nextInFreeList = NULL;        // paranoia
  #endif

  return ret;
}


// this is pulled out of 'alloc' so alloc can be inlined
// without causing excessive object code bloat
template <class T>
void ObjectPool<T>::expandPool()
{
  T *rack = new T[rackSize];
  racks.push(rack);

  // thread new nodes into a free list
  for (int i=rackSize-1; i>=0; i--) {
    rack[i].nextInFreeList = head;
    head = &(rack[i]);
  }
}


// usually I want the convenience of dealloc calling deinit; however,
// in the inner loop of a performance-critical section of code, I
// want finer control
template <class T>
inline void ObjectPool<T>::deallocNoDeinit(T *obj)
{
  // I don't check that nextInFreeList == NULL, despite having set it
  // that way in alloc(), because I want to allow for users to make
  // nextInFreeList share storage (e.g. with a union) with some other
  // field that gets used while the node is allocated

  // prepend the object to the free list; will be next yielded
  obj->nextInFreeList = head;
  head = obj;
}


template <class T>
inline void ObjectPool<T>::dealloc(T *obj)
{
  // call obj's pseudo-dtor (the decision to have dealloc do this is
  // motivated by not wanting to have to remember to call deinit
  // before dealloc)
  obj->deinit();

  deallocNoDeinit(obj);
}


template <class T>
int ObjectPool<T>::freeObjectsInPool() const
{
  T *p = head;
  int ct = 0;

  while (p) {
    ct++;
    p = p->nextInFreeList;
  }

  return ct;
}


#endif // OBJPOOL_H
@h=tangler('elk/sm_objstack.h')
@select(h)
// objstack.h            see license.txt for copyright and terms of use
// stack of objects, owned by the stack

#ifndef OBJSTACK_H
#define OBJSTACK_H

#include "sm_objlist.h"

template <class T>
class ObjStack {
private:      // data
  // will implement the stack as a list, with prepend and removeAt(0)
  ObjList<T> list;

public:       // funcs
  ObjStack()                            : list() {}
  ~ObjStack()                           {}

  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }

  T const *topC() const                 { return list.firstC(); }
  T * /*serf*/ top()                    { return list.first(); }

  T * /*owner*/ pop()                   { return list.removeAt(0); }
  void delPop()                         { list.deleteAt(0); }
  void push(T *item)                    { list.prepend(item); }
  void clear()                          { list.deleteAll(); }

  bool contains(T const *item) const    { return list.contains((void*)item); }
};

#endif // OBJSTACK_H
@h=tangler('elk/sm_ohashtbl.h')
@select(h)
// ohashtbl.h            see license.txt for copyright and terms of use
// hash table that owns the values; uses void* keys
// see hashtbl.h for more detail on the semantics of the member fns

#ifndef OHASHTBL_H
#define OHASHTBL_H
#include "sm_typ.h"
#include "sm_hashtbl.h"

template <class T> class OwnerHashTableIter;

template <class T>
class OwnerHashTable {
public:     // types
  friend class OwnerHashTableIter<T>;

  // see hashtbl.h
  typedef void const* (*GetKeyFn)(T *data);
  typedef unsigned (*HashFn)(void const *key);
  typedef bool (*EqualKeyFn)(void const *key1, void const *key2);

private:    // data
  // inner table that does the hash mapping
  HashTable table;

public:     // funcs
  OwnerHashTable(GetKeyFn gk, HashFn hf, EqualKeyFn ek,
                 int initSize = HashTable::defaultSize)
    : table((HashTable::GetKeyFn)gk, hf, ek, initSize) {}
  ~OwnerHashTable() { empty(1); }

  int getNumEntries() const               { return table.getNumEntries(); }
  T *get(void const *key) const           { return (T*)table.get(key); }
  void add(void const *key, T *value)     { table.add(key, value); }
  T *remove(void const *key)              { return (T*)table.remove(key); }
  void empty(int initSize = HashTable::defaultSize);
  void setEnableShrink(bool en)           { table.setEnableShrink(en); }
  void selfCheck() const                  { table.selfCheck(); }

  // this simply drops all the entries without deleting them; it is
  // useful when the objects have been taken out via iteration
  void disownAndForgetAll(int initSize = HashTable::defaultSize)
                                          { table.empty(initSize); }
};

template <class T>
void OwnerHashTable<T>::empty(int initSize)
{
  HashTableIter iter(table);
  for (; !iter.isDone(); iter.adv()) {
    delete (T*)iter.data();
  }
  table.empty(initSize);
}


template <class T>
class OwnerHashTableIter {
private:      // data
  HashTableIter iter;      // internal iterator

public:       // funcs
  OwnerHashTableIter(OwnerHashTable<T> &table)
    : iter(table.table) {}

  bool isDone() const      { return iter.isDone(); }
  void adv()               { iter.adv(); }
  T *data()                { return (T*)iter.data(); }
};

#endif // OHASHTBL_H
@h=tangler('elk/sm_okhasharr.h')
@select(h)
// okhasharr.h            see license.txt for copyright and terms of use
// combination of an owner hash table and an array/stack
//
// in its present form, it's ideal for a worklist, but not
// for a 'finished' list, due to inability to randomly remove

#ifndef OKHASHARR_H
#define OKHASHARR_H

#include "sm_array.h"
#include "sm_okhashtbl.h"

// T is value, K is key
template <class T, class K>
class OwnerKHashArray {
private:    // data
  OwnerKHashTable<T,K> hash;
  ArrayStack<T*> stack;

public:     // funcs
  OwnerKHashArray(typename OwnerKHashTable<T,K>::GetKeyFn gk,
                  typename OwnerKHashTable<T,K>::HashFn hf,
                  typename OwnerKHashTable<T,K>::EqualKeyFn ek,
                  int initSize = HashTable::defaultSize)
    : hash(gk, hf, ek, initSize),
      stack(initSize)
  {
    hash.setEnableShrink(false);
  }
  ~OwnerKHashArray();

  // # elts in the structure
  int count() const                  { return stack.length(); }
  bool isEmpty() const               { return stack.isEmpty(); }
  bool isNotEmpty() const            { return !isEmpty(); }

  // access as a hashtable
  T *lookup(K const *key) const      { return hash.get(key); }
  K const *callGetKeyFn(T *data)     { return hash.callGetKeyFn(data); }

  // TODO: make a new base-level implementation so I can support
  // removal of arbitrary objects efficiently

  // access as a stack
  void push(K const *key, T *value) {
    hash.add(key, value);
    stack.push(value);
  }

  T *pop() {
    T *ret = stack.pop();
    hash.remove(hash.callGetKeyFn(ret));
    return ret;
  }
};


template <class T, class K>
OwnerKHashArray<T,K>::~OwnerKHashArray()
{}


#endif // OKHASHARR_H
@h=tangler('elk/sm_okhashtbl.h')
@select(h)
// okhashtbl.h            see license.txt for copyright and terms of use
// version of ohasharr.h with type-safe keys ("k" for keys)

#ifndef OKHASHTBL_H
#define OKHASHTBL_H

#include "sm_typ.h"
#include "sm_hashtbl.h"

template <class T, class K> class OwnerKHashTableIter;

// T is the value type, K is the key type
template <class T, class K>
class OwnerKHashTable {
public:     // types
  friend class OwnerKHashTableIter<T,K>;

  // see hashtbl.h
  typedef K const* (*GetKeyFn)(T *data);
  typedef unsigned (*HashFn)(K const *key);
  typedef bool (*EqualKeyFn)(K const *key1, K const *key2);

private:    // data
  // inner table that does the hash mapping
  HashTable table;

public:     // funcs
  OwnerKHashTable(GetKeyFn gk, HashFn hf, EqualKeyFn ek,
                  int initSize = HashTable::defaultSize)
    : table((HashTable::GetKeyFn)gk, 
            (HashTable::HashFn)hf, 
            (HashTable::EqualKeyFn)ek, 
            initSize) {}
  ~OwnerKHashTable() { empty(1); }

  int getNumEntries() const               { return table.getNumEntries(); }
  T *get(K const *key) const              { return (T*)table.get(key); }
  void add(K const *key, T *value)        { table.add(key, value); }
  T *remove(K const *key)                 { return (T*)table.remove(key); }
  void empty(int initSize = HashTable::defaultSize);
  void setEnableShrink(bool en)           { table.setEnableShrink(en); }
  K const *callGetKeyFn(T *data)          { return (K const*)table.callGetKeyFn(data); }
  void selfCheck() const                  { table.selfCheck(); }

  // this simply drops all the entries without deleting them; it is
  // useful when the objects have been taken out via iteration
  void disownAndForgetAll(int initSize = HashTable::defaultSize)
                                          { table.empty(initSize); }
};

template <class T, class K>
void OwnerKHashTable<T,K>::empty(int initSize)
{
  HashTableIter iter(table);
  for (; !iter.isDone(); iter.adv()) {
    delete (T*)iter.data();
  }
  table.empty(initSize);
}


template <class T, class K>
class OwnerKHashTableIter {
private:      // data
  HashTableIter iter;      // internal iterator

public:       // funcs
  OwnerKHashTableIter(OwnerKHashTable<T,K> &table)
    : iter(table.table) {}

  bool isDone() const      { return iter.isDone(); }
  void adv()               { iter.adv(); }
  T *data()                { return (T*)iter.data(); }
};

#endif // OKHASHTBL_H
@h=tangler('elk/sm_oobjmap.h')
@select(h)
// oobjmap.h            see license.txt for copyright and terms of use
// owner object map, implemented with a hash table
// maps pointer-to-key-object to pointer-to-value-object, and owns
// all instances of value-object (they are deallocated when the
// map itself goes away)
                        
// I had envisioned an interface which didn't require the function
// that maps values back to keys.. given that OwnerHashTable requires
// this, I'll suspend this line of work for now and keep using
// OwnerHashTable directly
#error This does not work quite right

#ifndef OOBJMAP_H
#define OOBJMAP_H

#include "sm_ohashtbl.h"

template <class Key, class Value> class OObjMapIter;

template <class Key, class Value>
class OObjMap {
public:     // types
  friend class OObjMapIter<Key, Value>;

private:    // data 
  OwnerHashTable<Value> table;            // implementation

public:     // funcs
  OObjMap() {}
  ~OObjMap() {}                           // deallocates Value objects

  int getNumEntries() const               { return table.getNumEntries(); }
  Value *get(Key const *key) const        { return table.get(key); }
  void add(Key const *key, Value *value)  { table.add(key, value); }
  Value *remove(Key const *key)           { return table.remove(key); }
  void empty()                            { table.empty(); }
  void selfCheck() const                  { table.selfCheck(); }
};


template <class Key, class Value>
class OObjMapIter {
private:    // data
  OwnerHashTableIter<Value> iter;         // implementation

public:
  OObjMapIter(OObjMap<Key,Value> &map)    : iter(map.table) {}

  bool isDone() const                     { return iter.isDone(); }
  void adv()                              { iter.adv(); }
  Value *data()                           { return iter.data(); }
};


#endif // OOBJMAP_H
@h=tangler('elk/sm_owner.h')
@select(h)
// owner.h            see license.txt for copyright and terms of use
// a stab at an owner ptr abstraction

#ifndef OWNER_H
#define OWNER_H

#include "sm_typ.h"

#ifdef DEBUG_OWNER
  #include <stdio.h>    // printf, temporary
  #define DBG(fn) printf("%s(%p)\n", fn, ptr)
#else
  #define DBG(fn)
#endif

template <class T>
class Owner {
private:    // data
  T *ptr;                // the real pointer

private:    // funcs
  Owner(Owner&);         // not allowed

public:     // funcs
  Owner(T *p = NULL) : ptr(p) { DBG("ctor"); }
  ~Owner() { DBG("dtor"); del(); }

  // take ownership (no transitive = here)
  void operator= (T *p) { DBG("op=ptr"); del(); ptr=p; }
  void operator= (Owner<T> &obj) { DBG("op=obj"); del(); ptr=obj.ptr; obj.ptr=NULL; }

  // release ownership
  T *xfr() { DBG("xfr"); T *temp = ptr; ptr = NULL; return temp; }

  // free
  void del() { DBG("del"); delete ptr; ptr = NULL; }    // relies on delete(NULL) being ok

  // some operators that make Owner behave more or less like
  // a native C++ pointer.. note that some compilers to really
  // bad handling the "ambiguity", so the non-const versions
  // can be disabled at compile time
  operator T const* () const { DBG("opcT*"); return ptr; }
  T const & operator* () const { DBG("opc*"); return *ptr; }
  T const * operator-> () const { DBG("opc->"); return ptr; }

  // according to http://www.google.com/search?q=cache:zCRFFDMZvVUC:people.we.mediaone.net/stanlipp/converops.htm+conversion+sequence+for+the+argument+is+better&hl=en&ie=ISO-8859-1,
  // a solution to the gcc "conversion sequence is better" complaint
  // is to define this version
  operator T const* () { DBG("opcT*_nc"); return ptr; }

  #ifndef NO_OWNER_NONCONST
  operator T* () { DBG("opT*"); return ptr; }
  T& operator* () { DBG("op*"); return *ptr; }
  T* operator-> () { DBG("op->"); return ptr; }
  #endif

  // escape hatch for when operators flake out on us
  T *get() { DBG("get"); return ptr; }
  T const *getC() const { DBG("getC"); return ptr; }

  // even more dangerous escape; only use where the caller
  // agrees to restore the owner invariant!
  T *&getRef() { DBG("getRed"); return ptr; }

  // swaps are interesting because they don't require checking
  void swapWith(Owner<T> &obj) {
    T *tmp = ptr;
    ptr = obj.ptr;
    obj.ptr = tmp;
  }
};
   

template <class T>
void swap(Owner<T> &obj1, Owner<T> &obj2)
{
  obj1.swapWith(obj2);
}


// not used with Owner objects, but rather with
// simple pointers (Foo*) that are used as owners
template <class T>
T *xfr(T *&ptr)
{
  T *ret = ptr;
  ptr = NULL;
  return ret;
}


#endif // OWNER_H
@h=tangler('elk/sm_point.h')
@select(h)
// point.h            see license.txt for copyright and terms of use
// 2-dimensional point
// derived from Melee's prmtvs2.hpp

#ifndef __POINT_H
#define __POINT_H

#include "sm_typ.h"

// point defined over arbitrary underlying types
template <class num>
class TPoint {
public:
  num x, y;

public:
  TPoint() {}
  TPoint(num nx, num ny) { set(nx,ny); }
  TPoint(TPoint<num> const &obj) : x(obj.x), y(obj.y) {}

  TPoint const& operator = (TPoint<num> const &obj)
    { x=obj.x; y=obj.y; return *this; }

  void set(num nx, num ny) { x=nx; y=ny; }
  void get(num *gx, num *gy) const { *gx=x; *gy=y; }
  bool zero() const { return x==0 && y==0; }
  bool gtez() const { return x>=0 && y>=0; }

  TPoint<num> operator - () const
    { return TPoint<num>(-x, -y); }
  TPoint<num> absval() const
    { return TPoint<num>(x<0? -x : x, y<0? -y : y); }
      // don't call abs() because that requires stdlib.h
      // also, don't call the function "abs" because abs() is usually
      //   implemented as a macro

  TPoint<num> operator + (TPoint<num> const &obj) const
    { return TPoint<num>(x+obj.x, y+obj.y); }
  TPoint<num> operator - (TPoint<num> const &obj) const
    { return TPoint<num>(x-obj.x, y-obj.y); }
  num dotprod(TPoint<num> const &obj) const
    { return x*obj.x + y*obj.y; }

  // for the arithmetic functions of the form point <op> num, <op> num is
  // applied to x and y independently

  TPoint<num> operator * (num factor) const
    { return TPoint<num>(x*factor, y*factor); }
  TPoint<num> operator / (num factor) const
    { return TPoint<num>(x/factor, y/factor); }

  TPoint<num> operator * (TPoint<num> const &factor) const
    { return TPoint<num>(x*factor.x, y*factor.y); }
  TPoint<num> operator / (TPoint<num> const &factor) const
    { return TPoint<num>(x/factor.x, y/factor.y); }

  TPoint<num> operator += (TPoint<num> const &obj)
    { x+=obj.x; y+=obj.y; return *this; }
  TPoint<num> operator -= (TPoint<num> const &obj)
    { x-=obj.x; y-=obj.y; return *this; }
  TPoint<num> operator *= (num factor)
    { x*=factor; y*=factor; return *this; }
  TPoint<num> operator /= (num factor)
    { x/=factor; y/=factor; return *this; }

  bool operator == (TPoint<num> const &obj) const
    { return x==obj.x && y==obj.y; }
  bool operator != (TPoint<num> const &obj) const
    { return ! operator==(obj); }

  // use with care; note that each relation requires the relation to hold for
  // *both* x and y for it to be true (this is different than, for example, the
  // way STL does relations between pairs)
  bool operator > (TPoint<num> const &obj) const
    { return x>obj.x && y>obj.y; }
  bool operator >= (TPoint<num> const &obj) const
    { return x>=obj.x && y>=obj.y; }
  bool operator < (TPoint<num> const &obj) const
    { return x<obj.x && y<obj.y; }
  bool operator <= (TPoint<num> const &obj) const
    { return x<=obj.x && y<=obj.y; }
};


// common incarnations
typedef TPoint<int> point;
typedef TPoint<double> fpoint;


// and we can then define sm_stringBuilder output ops for them
class sm_stringBuilder;
sm_stringBuilder& operator<< (sm_stringBuilder &sb, point const &pt);
sm_stringBuilder& operator<< (sm_stringBuilder &sb, fpoint const &pt);


// iterate: 0,0    1,0    2,0    ... x-1,0    and then
//          0,1    1,1    2,1    ... x-1,1    and then
//           .                          .
//           .                          .     (each line in succession)
//           .                          .
//          0,y-1  1,y-1  2,y-1  ... x-1,y-1  done
// can 'break' out of the loop at any time

#define FOREACH_point(size, var)   \
  if ((size).x > 0)                \
    for(point var(0,0); var.y < (size).y; ++var.x == (size).x && (var.x=0,var.y++))


#endif // ___POINT_H

@h=tangler('elk/sm_pprint.h')
@select(h)
// pprint.h
// pretty-print code while emitting it

                     

// NOTE: This module is a little simpler to use, but much less
// powerful than the 'boxprint' module.  I'm leaving this module
// here for now, but will probably delete it at some point.



// inspired by:
//   CIL's 'pretty' module
//   http://www.cs.berkeley.edu/~necula/cil/index.html
// and
//   Caml pretty-print module (boxes, etc.)
//   http://caml.inria.fr/FAQ/format-eng.html

// special characters:
//   '\n' - hard linebreak
//   '\r' - optional linebreak; is 1 space if the break isn't taken
//   '\b' - begin a break group (return to <here>)
//   '\a' - alternate begin group (return to <this_line_ind> + altIndent)
//   '\f' - finish a break group

#ifndef PPRINT_H
#define PPRINT_H

#include <iostream>      // std::ostream
#include "sm_str.h"
#include "sm_array.h"


// output interface for PPrint.. I'd like to just start using the
// C++ istd::ostreams interfaces, but reading on the net I get the
// impression they're still a little too much in flux
class PPrintOut {
public:
  virtual void write(char const *text) = 0;
  virtual ~PPrintOut(){}
};

class PPrintStringOut : public PPrintOut {
  sm_stringBuilder &sb;
public:
  PPrintStringOut(sm_stringBuilder &s) : sb(s) {}
  virtual void write(char const *text);
};

class PPrintOstreamOut : public PPrintOut {
  std::ostream &os;
public:
  PPrintOstreamOut(std::ostream &o) : os(o) {}
  virtual void write(char const *text);
};


// pretty printer formatting engine
class PPrint {
private:     // types
  // manages the line-setting algorithm
  class Setter {
  private:     // data
    // inter-line information
    PPrint &pprint;

    // emitted text in the current line
    sm_stringBuilder curLine;

    // indentation used for 'curLine'
    int curLineInd;

    // place in the 'line' buffer; all the chars up to this point
    // have been sent out
    int lineIndex;

    // stack of columns at which indent groups opened
    ArrayStack<int> indentGroups;

  private:     // funcs
    // add 'amt' spaces to 'curLine'
    void indent(int amt);

    // copy characters [lineIndex,lineIndex+p-1] from 'line' into
    // 'curLine', moving 'lineIndex' along so eventually it equals
    // 'p'; also maintain 'indentGroups'
    void emitTo(int p);

    // send all of 'curLine' to 'pprint.out', and clear 'curLine'
    void flush();

  public:      // funcs
    Setter(PPrint &p)
      : pprint(p),
        curLine(),
        curLineInd(0),
        lineIndex(0),
        indentGroups()
    {}
    ~Setter();

    void set();
  };
  friend class Setter;

private:     // data
  // the contents of each line, up to a hard linebreak, is accumulated here
  ArrayStack<char> line;

public:      // data
  // current indentation level for the beginning of a complete line
  // (one preceded by a hard linebreak)
  int lineIndent;

  // desired right margin; we'll try to set text so it doesn't go
  // beyond that many columns; defaults to 72
  int margin;

  // incremental indentation for '\a' groups; defaults to 2
  int altIndent;

  // if not NULL, text to emit at the start of every line; intended
  // for emitting text into a comment or other embedded context;
  // defaults to NULL; not counted against the margin
  char const *startText;

  // where to send output
  PPrintOut &out;

  // When true, and we find that the grouping is unbalanced at
  // the end of setting a line, pring a warning.  This defaults
  // to 'true'.  Note that while too many '\b's will only trigger
  // this warning, too many '\f's can cause an assertion failure
  // when the indentation stack underflows.
  static bool warnWhenUnbalanced;

private:     // funcs
  // take the current line buffer and break it up into output
  // lines, sending them to 'out'
  void set();

public:      // funcs
  PPrint(PPrintOut &out);
  ~PPrint();

  // basic printing routine; the text can contain the special
  // characters listed above; whenever a '\n' is seen, the current
  // line is set and emitted to 'out'
  void print(char const *text);

  // convenience
  PPrint& operator<< (int i);
  PPrint& operator<< (char const *s);

  // manage the line-start indentation
  void ind(int amt) { lineIndent += amt; }
};


class PPrintToString : public PPrint {
public:
  sm_stringBuilder sb;            // output (set) lines accumulate here
  PPrintStringOut sbOut;       // helper

public:
  PPrintToString()
    : PPrint(sbOut), sb(), sbOut(sb) {}
  ~PPrintToString();
};

class PPrintToOstream : public PPrint {
  PPrintOstreamOut osOut;

public:
  PPrintToOstream(std::ostream &os)
    : PPrint(osOut), osOut(os) {}
};


#endif // PPRINT_H
@h=tangler('elk/sm_ptrmap.h')
@select(h)
// ptrmap.h
// map from KEY* to VALUE* for arbitrary types KEY and VALUE
// (neither are owned by the table)

// for const purposes, I regard the mapping itself as the only
// thing that cannot be modified in a "const" map; in particular,
// I allow a non-const VALUE* to be extracted

#ifndef PTRMAP_H
#define PTRMAP_H

#include "sm_vptrmap.h"
#include "sm_typ.h"


template <class KEY, class VALUE>
class PtrMap {
private:     // data
  // underlying map implementation, around which this class
  // is a type-safe wrapper
  VoidPtrMap map;

public:      // funcs
  PtrMap()                         : map() {}
  ~PtrMap()                        {}

  // query # of mapped entries
  int getNumEntries() const        { return map.getNumEntries(); }
  bool isEmpty() const             { return getNumEntries() == 0; }
  bool isNotEmpty() const          { return !isEmpty(); }

  // if this key has a mapping, return it; otherwise, return NULL
  VALUE *get(KEY const *key) const { return (VALUE*)map.get((void const*)key); }

  // add a mapping from 'key' to 'value'; replaces existing
  // mapping, if any
  void add(KEY *key, VALUE *value) { map.add((void*)key, (void*)value); }

  // remove all mappings
  void empty()                     { map.empty(); }


public:      // iterators
  class Iter {
  private:     // data
    // underlying iterator state
    VoidPtrMap::Iter iter;

  public:      // fucs
    Iter(PtrMap<KEY,VALUE> const &map)   : iter(map.map) {}
    ~Iter()                              {}

    bool isDone() const            { return iter.isDone(); }
    void adv()                     { return iter.adv(); }

    // return information about the currently-referenced table entry
    KEY *key() const               { return (KEY*)iter.key(); }
    VALUE *value() const           { return (VALUE*)iter.value(); }
  };
  friend class Iter;
};


// a set based on PtrMap
template <class KEY>
class PtrSet : private PtrMap<KEY, KEY> {
  public:
  PtrSet() {}
  ~PtrSet() {}

  // query # of mapped entries
  int getNumEntries() const        { return PtrMap<KEY, KEY>::getNumEntries(); }
  bool isEmpty() const             { return PtrMap<KEY, KEY>::isEmpty(); }
  bool isNotEmpty() const          { return PtrMap<KEY, KEY>::isNotEmpty(); }

  // if this key has a mapping, return it; otherwise, return NULL
  bool contains(KEY const *key) const { return PtrMap<KEY, KEY>::get(key)!=NULL; }

  // add key to the set
  void add(KEY *key) { PtrMap<KEY, KEY>::add(key, key); }

  // make the set empty; FIX: this would be better named makeEmpty(),
  // as it could be confused with the meaning of isEmpty(); however I
  // reflect the naming of PtrMap, where the same criticism applies.
  void empty()                     { PtrMap<KEY, KEY>::empty(); }
};


#endif // PTRMAP_H
@h=tangler('elk/sm_flexlexer.h')
@select(h)
// sm_flexlexer.h
// a layer of indirection to try to work with different
// installed versions of Flex


// Basically, what has happened is the last version of flex created by
// Vern Paxson et al. is 2.5.4, and a lot of distributions use that.
// More recently some other people started a project hosted at
// Sourceforge, and their current (only?) release is flex-2.5.31.
// Unfortunately, the authors of 2.5.31 do not appear concerned with
// maintaining compatibility for C++ scanners.
//
// See bug "[ 751550 ] c++ derived scanners will not compile",
// http://sourceforge.net/tracker/index.php?func=detail&aid=751550&group_id=72099&atid=533377
//
// So in an attempt to make Elkhound/Elsa work, this file is where
// I'll put my hacks.


// workaround for flex-2.5.31 bug
#ifdef yyFlexLexer
  #undef yyFlexLexer
#endif

// now get the installed FlexLexer.h.. this nominally lives in
// /usr/include or /usr/local/include, depending on how Flex is
// installed
//#include <FlexLexer.h>


// for now I keep the rest but I think I may be able to delete
// it soon..
//#if 0     // terminates at EOF
// FELIX uses this text, never the system FlexLexer.h
#if 1


// copy of /usr/include/FlexLexer.h from flex-2.5.4


// To use this file, use the same flex version as listed above.


// Why is this file distributed with smbase?
//
// 1. I want my distribution tarballs to include the *output* of
// tools like flex/bison, but flex's output has an #include of
// FlexLexer.h.  Since I want the distribution to be self-contained,
// that means distributing the .h file as well.
//
// 2. It avoids version mismatch.  Some people have flex-2.5.31,
// some have 2.5.4.  Some of my classes depend on the internals of
// the FlexLexer class which have changed between the versions, and
// making it compatible with both is difficult.


// What is its copyright status?
//
// I've put most of smbase into the public domain.  However, the
// Regents retain copyright on this file.  I am in effect just
// providing a convenient distribution mechanism for smbase users
// (users *could* just download it themselves, for free, just like
// smbase).


// ------------------ original file below -----------------
// $Header$

// FlexLexer.h -- define interfaces for lexical analyzer classes generated
//                by flex

// Copyright (c) 1993 The Regents of the University of California.
// All rights reserved.
//
// This code is derived from software contributed to Berkeley by
// Kent Williams and Tom Epperly.
//
// Redistribution and use in source and binary forms with or without
// modification are permitted provided that: (1) source distributions retain
// this entire copyright notice and comment, and (2) distributions including
// binaries display the following acknowledgement:  ``This product includes
// software developed by the University of California, Berkeley and its
// contributors'' in the documentation or other materials provided with the
// distribution and in all advertising materials mentioning features or use
// of this software.  Neither the name of the University nor the names of
// its contributors may be used to endorse or promote products derived from
// this software without specific prior written permission.

// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.

// This file defines FlexLexer, an abstract class which specifies the
// external interface provided to flex C++ lexer objects, and yyFlexLexer,
// which defines a particular lexer class.
//
// If you want to create multiple lexer classes, you use the -P flag
// to rename each yyFlexLexer to some other xxFlexLexer.  You then
// include <FlexLexer.h> in your other sources once per lexer class:
//
//      #undef yyFlexLexer
//      #define yyFlexLexer xxFlexLexer
//      #include <FlexLexer.h>
//
//      #undef yyFlexLexer
//      #define yyFlexLexer zzFlexLexer
//      #include <FlexLexer.h>
//      ...

#ifndef __FLEX_LEXER_H
// Never included before - need to define base class.
#define __FLEX_LEXER_H
#include <iostream>

// FELIX: always C++ compiles anyhow
//extern "C++" {

struct yy_buffer_state;
typedef int yy_state_type;

class FlexLexer {
public:
        virtual ~FlexLexer()    { }

        const char* YYText()    { return yytext; }
        int YYLeng()            { return yyleng; }

        virtual void
                yy_switch_to_buffer( struct yy_buffer_state* new_buffer ) = 0;
        virtual struct yy_buffer_state*
                yy_create_buffer( std::istream* s, int size ) = 0;
        virtual void yy_delete_buffer( struct yy_buffer_state* b ) = 0;
        virtual void yyrestart( std::istream* s ) = 0;

        virtual int yylex() = 0;

        // Call yylex with new input/output sources.
        int yylex( std::istream* new_in, std::ostream* new_out = 0 )
                {
                switch_streams( new_in, new_out );
                return yylex();
                }

        // Switch to new input/output streams.  A nil stream pointer
        // indicates "keep the current one".
        virtual void switch_streams( std::istream* new_in = 0,
                                        std::ostream* new_out = 0 ) = 0;

        int lineno() const              { return yylineno; }

        int debug() const               { return yy_flex_debug; }
        void set_debug( int flag )      { yy_flex_debug = flag; }

protected:
        char* yytext;
        int yyleng;
        int yylineno;           // only maintained if you use %option yylineno
        int yy_flex_debug;      // only has effect with -d or "%option debug"
};

//FELIX: always C++
//}

#endif

#if defined(yyFlexLexer) || ! defined(yyFlexLexerOnce)
// Either this is the first time through (yyFlexLexerOnce not defined),
// or this is a repeated include to define a different flavor of
// yyFlexLexer, as discussed in the flex man page.
#define yyFlexLexerOnce

class yyFlexLexer : public FlexLexer {
public:
        // arg_yyin and arg_yyout default to the cin and cout, but we
        // only make that assignment when initializing in yylex().
        yyFlexLexer( std::istream* arg_yyin = 0, std::ostream* arg_yyout = 0 );

        virtual ~yyFlexLexer();

        void yy_switch_to_buffer( struct yy_buffer_state* new_buffer );
        struct yy_buffer_state* yy_create_buffer( std::istream* s, int size );
        void yy_delete_buffer( struct yy_buffer_state* b );
        void yyrestart( std::istream* s );

        virtual int yylex();
        virtual void switch_streams( std::istream* new_in, std::ostream* new_out );

protected:
        virtual int LexerInput( char* buf, int max_size );
        virtual void LexerOutput( const char* buf, int size );
        virtual void LexerError( const char* msg );

        void yyunput( int c, char* buf_ptr );
        int yyinput();

        void yy_load_buffer_state();
        void yy_init_buffer( struct yy_buffer_state* b, std::istream* s );
        void yy_flush_buffer( struct yy_buffer_state* b );

        int yy_start_stack_ptr;
        int yy_start_stack_depth;
        int* yy_start_stack;

        void yy_push_state( int new_state );
        void yy_pop_state();
        int yy_top_state();

        yy_state_type yy_get_previous_state();
        yy_state_type yy_try_NUL_trans( yy_state_type current_state );
        int yy_get_next_buffer();

        std::istream* yyin;  // input source for default LexerInput
        std::ostream* yyout; // output sink for default LexerOutput

        struct yy_buffer_state* yy_current_buffer;

        // yy_hold_char holds the character lost when yytext is formed.
        char yy_hold_char;

        // Number of characters read into yy_ch_buf.
        int yy_n_chars;

        // Points to current character in buffer.
        char* yy_c_buf_p;

        int yy_init;            // whether we need to initialize
        int yy_start;           // start state number

        // Flag which is used to allow yywrap()'s to do buffer switches
        // instead of setting up a fresh yyin.  A bit of a hack ...
        int yy_did_buffer_switch_on_eof;

        // The following are not always needed, but may be depending
        // on use of certain flex features (like REJECT or yymore()).

        yy_state_type yy_last_accepting_state;
        char* yy_last_accepting_cpos;

        yy_state_type* yy_state_buf;
        yy_state_type* yy_state_ptr;

        char* yy_full_match;
        int* yy_full_state;
        int yy_full_lp;

        int yy_lp;
        int yy_looking_for_trail_begin;

        int yy_more_flag;
        int yy_more_len;
        int yy_more_offset;
        int yy_prev_more_offset;
};

#endif

#endif // 0, from top of file
@h=tangler('elk/sm_regexp.h')
@select(h)
// smregexp.h
// regular expression matching, etc.

// the "sm" prefix in the name is to avoid a name conflict with something
// in my version of glibc..

// The regular expression language is, for now, the "Extended" regexp
// language described in the regex(7) man page, itself a description
// of POSIX 1003.2, section 2.8 (Regular Expression Notation).

// The interface is based on the POSIX regex functions too, but I
// don't actually include regex.h here since I want to allow a
// different implementation, if that becomes necessary.

#ifndef REGEXP_H
#define REGEXP_H

#include "sm_macros.h"


// ----------------- Regexp class -------------------
// This class represents a compiled regexp pattern.  For maximum
// efficiency, repeated uses of the same pattern should use the
// same Regexp object each time instead of making a new one.
class Regexp {
public:      // types
  // compilation flags
  enum CFlags {
    C_NONE     = 0x00,         // no flags
    ICASE      = 0x02,         // case insensitive
    NOSUB      = 0x08,         // subsm_string matches are not needed
    //NEWLINE                  // still not sure what this really means
  };

  // execution flags
  enum EFlags {
    E_NONE     = 0x00,         // no flags
    NOTBOL     = 0x01,         // treat 'str' as not including beginning of line
    NOTEOL     = 0x02,         // ............................ end of line
  };

private:     // data
  void *impl;                  // implementation data
  //int numLParens;              // # of left-parens in the pattern

private:     // funcs
  // not allowed
  Regexp(Regexp&);
  void operator=(Regexp&);

  void err(int code) NORETURN;

public:      // funcs
  Regexp(char const *exp, CFlags flags = C_NONE);
  ~Regexp();

  bool match(char const *str, EFlags flags = E_NONE);
};

// allow '|' to be used on the flags
ENUM_BITWISE_OR(Regexp::CFlags)
ENUM_BITWISE_OR(Regexp::EFlags)


// TODO: Add support for subsm_string matches by building a class to
// remember the subsm_string offsets (enable 'numLParens' above)
// efficiently.  Major question: do I always make an internal copy of
// the sm_string in which we searched?  Leaning towards yes...



// --------------- convenience functions ---------------
// The functions in this section are built on top of the
// Regexp class in the obvious way.

// return true if 'str' matches 'exp'
bool regexpMatch(char const *str, char const *exp);


#endif // REGEXP_H
@h=tangler('elk/sm_sobjlist.h')
@select(h)
// sobjlist.h
// serf list of arbitrary objects
// NOTE: automatically generated from xobjlist.h -- do not edit directly

// Author: Scott McPeak, 2000

#ifndef SOBJLIST_H
#define SOBJLIST_H

#include "sm_voidlist.h"


// forward declarations of template classes, so we can befriend them in SObjList
// (not required by Borland C++ 4.5, but GNU wants it...)
template <class T> class SObjListIter;
template <class T> class SObjListMutator;
template <class T> class SObjListIterNC;


// the list is considered to not own any of the items; it's ok to
// insert items multiple times or into multiple lists
template <class T>
class SObjList {
private:
  friend class SObjListIter<T>;
  friend class SObjListMutator<T>;
  friend class SObjListIterNC<T>;

protected:
  VoidList list;                        // list itself

public:
  // make shallow copies
  SObjList(SObjList const &obj)         : list(obj.list) {}
  SObjList& operator= (SObjList const &src)         { list = src.list; return *this; }

public:
  SObjList()                            : list() {}
  ~SObjList()                           {}    /* all items removed */

  // The difference function should return <0 if left should come before
  // right, 0 if they are equivalent, and >0 if right should come before
  // left.  For example, if we are sorting numbers into ascending order,
  // then 'diff' would simply be subtraction.
  typedef int (*Diff)(T const *left, T const *right, void *extra);

  // selectors
  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }
  T *nth(int which)                     { return (T*)list.nth(which); }
  T const *nthC(int which) const        { return (T const*)list.nth(which); }
  T *first()                            { return (T*)list.first(); }
  T const *firstC() const               { return (T const*)list.first(); }
  T *last()                             { return (T*)list.last(); }
  T const *lastC() const                { return (T const*)list.last(); }

  // insertion
  void prepend(T *newitem)              { list.prepend((void*)newitem); }
  void append(T *newitem)               { list.append((void*)newitem); }
  void insertAt(T *newitem, int index)  { list.insertAt((void*)newitem, index); }
  void insertSorted(T *newitem, Diff diff, void *extra=NULL)
    { list.insertSorted((void*)newitem, (VoidDiff)diff, extra); }

  // removal
  T *removeAt(int index)                { return (T*)list.removeAt(index); }
  T *removeFirst()                      { return (T*)list.removeFirst(); }
  void removeAll()                      { list.removeAll(); }

  // list-as-set: selectors
  int indexOf(T const *item) const      { return list.indexOf((void*)item); }
  int indexOfF(void *item) const        { return list.indexOfF((void*)item); }
  bool contains(T const *item) const    { return list.contains((void*)item); }

  // list-as-set: mutators
  bool prependUnique(T *newitem)        { return list.prependUnique((void*)newitem); }
  bool appendUnique(T *newitem)         { return list.appendUnique((void*)newitem); }
  void removeItem(T const *item)        { list.removeItem((void*)item); }    // whether the arg should be const is debatable..
  bool removeIfPresent(T const *item)   { return list.removeIfPresent((void*)item); }

  // complex modifiers
  void reverse()                                    { list.reverse(); }
  void insertionSort(Diff diff, void *extra=NULL)   { list.insertionSort((VoidDiff)diff, extra); }
  void mergeSort(Diff diff, void *extra=NULL)       { list.mergeSort((VoidDiff)diff, extra); }

  // and a related test
  bool isSorted(Diff diff, void *extra=NULL) const  { return list.isSorted((VoidDiff)diff, extra); }

  // multiple lists
  void concat(SObjList &tail)                       { list.concat(tail.list); }
  void appendAll(SObjList const &tail)              { list.appendAll(tail.list); }

  // steal
  void stealTailAt(int index, SObjList &tail)       { list.stealTailAt(index, tail.list); }

  // equal items in equal positions
  bool equalAsLists(SObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.equalAsLists(otherList.list, (VoidDiff)diff, extra); }
  int compareAsLists(SObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.compareAsLists(otherList.list, (VoidDiff)diff, extra); }

  // last-as-set: comparisons (NOT efficient)
  bool equalAsSets(SObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.equalAsSets(otherList.list, (VoidDiff)diff, extra); }
  bool isSubsetOf(SObjList const &otherList, Diff diff, void *extra=NULL) const
    { return list.isSubsetOf(otherList.list, (VoidDiff)diff, extra); }
  bool containsByDiff(T const *item, Diff diff, void *extra=NULL) const
    { return list.containsByDiff((void*)item, (VoidDiff)diff, extra); }

  // treating the pointer values themselves as the basis for comparison
  bool equalAsPointerLists(SObjList const &otherList) const
    { return list.equalAsPointerLists(otherList.list); }
  bool equalAsPointerSets(SObjList const &otherList) const
    { return list.equalAsPointerSets(otherList.list); }

  // debugging: no invariants beyond VoidList
  void selfCheck() const                { list.selfCheck(); }
  
  // but export the additional checks for cases where they apply anyway
  void checkHeapDataPtrs() const        { list.checkHeapDataPtrs(); }
  void checkUniqueDataPtrs() const      { list.checkUniqueDataPtrs(); }
};


// for traversing the list and modifying it (nodes and/or structure)
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists, and only one such iterator should exist for
//       any given list
template <class T>
class SObjListMutator {
  friend class SObjListIter<T>;

protected:
  VoidListMutator mut;       // underlying mutator

public:
  SObjListMutator(SObjList<T> &lst)     : mut(lst.list) { reset(); }
  ~SObjListMutator()                    {}

  void reset()                          { mut.reset(); }

  // iterator copying; safe *only* until one of the mutators modifies
  // the list structure (by inserting or removing), at which time all
  // other iterators might be in limbo
  SObjListMutator(SObjListMutator const &obj)             : mut(obj.mut) {}
  SObjListMutator& operator=(SObjListMutator const &obj)  { mut = obj.mut;  return *this; }
    // requires that 'this' and 'obj' already refer to the same 'list'

  // iterator actions
  bool isDone() const                   { return mut.isDone(); }
  void adv()                            { mut.adv(); }
  T *data()                             { return (T*)mut.data(); }
  T *&dataRef()                         { return (T*&)mut.dataRef(); }

  // insertion
  void insertBefore(T *item)            { mut.insertBefore((void*)item); }
    // 'item' becomes the new 'current', and the current 'current' is
    // pushed forward (so the next adv() will make it current again)

  void insertAfter(T *item)             { mut.insertAfter((void*)item); }
    // 'item' becomes what we reach with the next adv();
    // isDone() must be false

  void append(T *item)                  { mut.append((void*)item); }
    // only valid while isDone() is true, it inserts 'item' at the end of
    // the list, and advances such that isDone() remains true; equivalent
    // to { xassert(isDone()); insertBefore(item); adv(); }

  // removal
  T *remove()                           { return (T*)mut.remove(); }
    // 'current' is removed from the list and returned, and whatever was
    // next becomes the new 'current'

  // debugging
  void selfCheck() const                { mut.selfCheck(); }
};

#define SMUTATE_EACH_OBJLIST(T, list, iter) \
  for(SObjListMutator< T > iter(list); !iter.isDone(); iter.adv())


// for traversing the list without modifying it (neither nodes nor structure)
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists
template <class T>
class SObjListIter {
protected:
  VoidListIter iter;      // underlying iterator

public:
  SObjListIter(SObjList<T> const &list) : iter(list.list) {}
  SObjListIter(SObjList<T> const &list, int pos) : iter(list.list, pos) {}
  ~SObjListIter()                       {}

  void reset(SObjList<T> const &list)   { iter.reset(list.list); }

  // iterator copying; generally safe
  SObjListIter(SObjListIter const &obj)             : iter(obj.iter) {}
  SObjListIter& operator=(SObjListIter const &obj)  { iter = obj.iter;  return *this; }

  // but copying from a mutator is less safe; see above
  SObjListIter(SObjListMutator<T> &obj)             : iter(obj.mut) {}

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T const *data() const                 { return (T const*)iter.data(); }
};

#define SFOREACH_OBJLIST(T, list, iter) \
  for(SObjListIter< T > iter(list); !iter.isDone(); iter.adv())


// intermediate to the above two, this allows modification of the
// objects stored on the list, but not the identity or order of
// the objects in the list
template <class T>
class SObjListIterNC {
protected:
  VoidListIter iter;      // underlying iterator

public:
  SObjListIterNC(SObjList<T> &list) : iter(list.list) {}
  SObjListIterNC(SObjList<T> &list, int pos) : iter(list.list, pos) {}
  ~SObjListIterNC()                     {}

  void reset(SObjList<T> &list)         { iter.reset(list.list); }

  // iterator copying; generally safe
  SObjListIterNC(SObjListIterNC const &obj)             : iter(obj.iter) {}
  SObjListIterNC& operator=(SObjListIterNC const &obj)  { iter = obj.iter;  return *this; }

  // but copying from a mutator is less safe; see above
  SObjListIterNC(SObjListMutator<T> &obj)               : iter(obj.mut) {}

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T *data() const                       { return (T*)iter.data(); }
};

#define SFOREACH_OBJLIST_NC(T, list, iter) \
  for(SObjListIterNC< T > iter(list); !iter.isDone(); iter.adv())


// iterate over the combined elements of two or more lists
template <class T>
class SObjListMultiIter {
private:
  // all the lists
  SObjList<T> **lists;               // serf array of serf list pointers
  int numLists;                      // length of this array

  // current element
  int curList;                       // which list we're working on
  SObjListIter<T> iter;              // current element of that list

  // invariant:
  //   either curList==numLists, or
  //   iter is not 'done'

public:
  SObjListMultiIter(SObjList<T> **L, int n)
    : lists(L),
      numLists(n),
      curList(0),
      iter(*(lists[0]))
  {
    xassert(n > 0);
    normalize();
  }

  // advance the iterator to the next element of the next non-empty list;
  // establishes invariant above
  void normalize();

  bool isDone() const {
    return curList == numLists;
  }

  T const *data() const {
    return iter.data();
  }

  void adv() {
    iter.adv();
    normalize();
  }
};

// this was originally inline, but that was causing some strange
// problems (compiler bug?)
template <class T>
void SObjListMultiIter<T>::normalize()
{
  while (iter.isDone() && curList < numLists) {
    curList++;
    if (curList < numLists) {
      iter.reset(*(lists[curList]));
    }
  }
}


#endif // SOBJLIST_H
@h=tangler('elk/sm_sobjset.h')
@select(h)
// sobjset.h            see license.txt for copyright and terms of use
// non-owning set of objects (identified by address),
// implemented with a hashtable

#ifndef SOBJSET_H
#define SOBJSET_H
               
#include "sm_hashtbl.h"

template <class T> class SObjSetIter;


// experiment: to try to support const-polymorphism,
// I expect T to either be Foo* or Foo const *

template <class T>
class SObjSet : private HashTable {
  friend class SObjSetIter<T>;

public:
  SObjSet()
    : HashTable(identityKeyFn, lcprngHashFn, pointerEqualKeyFn) {}

  // # of distinct elements in the set
  int size() const               { return HashTable::getNumEntries(); }

  // true if 'elt' is in the set
  bool contains(T elt) const     { return !!HashTable::get((void const*)elt); }

  // add 'elt' to the set; if it is already in, this has no effect
  void add(T elt)                { if (!contains(elt)) { HashTable::add((void const*)elt, (void*)elt); } }

  // remove 'elt' from the set; if it's not there, this has no effect
  void remove(T elt)             { if (contains(elt)) { HashTable::remove((void const*)elt); } }

  // remove all elements
  void empty()                   { HashTable::empty(); }

  // debug check which throws an exception if there's a problem
  void selfCheck()               { HashTable::selfCheck(); }
};


template <class T>
class SObjSetIter : private HashTableIter {
public:
  SObjSetIter(SObjSet<T> &table)
    : HashTableIter(table) {}    // I'm a friend, I can see it's a HashTable inside

  bool isDone() const          { return HashTableIter::isDone(); }
  void adv()                   { return HashTableIter::adv(); }
  T data() const               { return (T)HashTableIter::data(); }
};


#endif // SOBJSET_H
@h=tangler('elk/sm_sobjstack.h')
@select(h)
// sobjstack.h            see license.txt for copyright and terms of use
// stack of objects, *not* owned by the stack

#ifndef SOBJSTACK_H
#define SOBJSTACK_H

#include "sm_sobjlist.h"

template <class T>
class SObjStack {
public:       // data
  // will implement the stack as a list, with prepend and removeAt(0)
  SObjList<T> list;

public:       // funcs
  SObjStack()                           : list() {}
  ~SObjStack()                          {}

  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }

  T const *topC() const                 { return list.firstC(); }
  T *top()                              { return list.first(); }

  T *pop()                              { return list.removeAt(0); }
  void push(T *item)                    { list.prepend(item); }

  bool contains(T const *item) const    { return list.contains((void*)item); }
};


// utility class for maintaining a first-class sub-stack of the AST
// stack isomorphic to the stackframe stack; Note that the fact that
// nothing happens if 'obj' is NULL is a feature: sometimes you can't
// map the need to call this class completely onto the control flow,
// and so some dataflow is involved; since the dtor for this class is
// used as a kind of finally statement, we can't nest its construction
// in an 'if' statement!  Instead pass in NULL if you want a no-op
// effect.
template<class T>
class StackMaintainer {
  SObjStack<T> &s;
  T *obj;

  StackMaintainer(StackMaintainer&); // forbid copying

public:
  explicit StackMaintainer(SObjStack<T> &s0, T *obj0)
    : s(s0)
    , obj(obj0)
  {
    if (obj) {
      s.push(obj);
    }
  }

  ~StackMaintainer() {
    if (obj) {
      T *obj0 = s.pop();
      xassert(obj0 == obj);
    }
  }
};


#endif // SOBJSTACK_H
@h=tangler('elk/sm_srcloc.h')
@select(h)
// srcloc.h            see license.txt for copyright and terms of use
// source location information, efficiently represented as one word

// The fundamental assumption in this module is that source location
// information is frequently created, stored and passed around, but
// infrequently decoded into human-readable form.  Therefore the
// module uses a single word to store the information, and appeals
// to several index structures when decoding is necessary.
//
// Since decoding, when it happens, also usually has high locality,
// the data structures include caches to make accesses to nearby
// locations fast.
//
// No attempt is made to fold creation of SourceLocs into other
// file-processing activities, such as traditional lexical analysis.
// The complexity of doing that would be substantial, with little gain
// in efficiency, due to the large buffer caches in modern OSes.  The
// main drawback is the inability to work with non-seekable inputs
// (like pipes) because we consume the whole input when its line
// counts are computed.

#ifndef SRCLOC_H
#define SRCLOC_H

#include "sm_str.h"
#include "sm_objlist.h"

class HashLineMap;    // hashline.h


// This is a source location.  It's interpreted as an integer
// specifying the byte offset within a hypothetical file created by
// concatenating all the sources together.  Its type is 'enum' so I
// can overload functions to accept SourceLoc without confusion.
// I assume the compiler will use a machine word for this (and check
// that assumption in the .cc file).
//
// I would love to be able to annotate this so that the C++ compiler
// would not allow variables of this type to be created
// uninitialized.. that's the one drawback of calling this an 'enum'
// instead of a 'class': I don't get to write a constructor.
enum SourceLoc {
  // entity is defined within the translator's initialization code
  SL_INIT=-1,
  
  // location is unknown for some reason
  SL_UNKNOWN=0
};


// This class manages all the data associated with creating and
// interpreting SourceLocs.  It's expected to be a singleton in the
// program, though within this module that assumption is confined to
// the 'toString' function at the end.
class SourceLocManager {
private:     // types
  // a triple which identifies a line boundary in a file (it's
  // implicit which file it is) with respect to all of the relevant
  // spaces
  class Marker {
  public:
    // character offset, starting with 0
    int charOffset;

    // line offset, starting with 1
    int lineOffset;

    // offset into the 'lineLengths' array; this is not simply
    // lineOffset-1 because of the possible presence of lines with
    // length longer than 254 chars
    int arrayOffset;

  public:
    Marker() {}      // for creation in arrays
    Marker(int c, int L, int a)
      : charOffset(c), lineOffset(L), arrayOffset(a) {}
    Marker(Marker const &obj)
      : DMEMB(charOffset), DMEMB(lineOffset), DMEMB(arrayOffset) {}
  };

public:      // types
  // describes a file we know about
  class File {
  public:    // data
    // file name; we consider two files to be the same if and only
    // if their names are equal, i.e. there is no checking done to
    // see if their names happen to be aliases in the filesystem
    sm_string name;

    // start offset in the SourceLoc space
    SourceLoc startLoc;

    // number of chars in the file
    int numChars;

    // number of lines in the file
    int numLines;

    // average number of chars per line; this is used for estimating
    // whether the index should be consulted for some lookups (and
    // it's stored instead of computed to save a division)
    int avgCharsPerLine;

    // known #line directives for this file; NULL if none are known
    HashLineMap *hashLines;          // (nullable owner)

  private:   // data
    // an array of line lengths; to handle lines longer than 255
    // chars, we use runs of '\xFF' chars to (in unary) encode
    // multiples of 254 (one less than 255) chars, plus the final
    // short count to give the total length
    unsigned char *lineLengths;      // (owner)

    // # of elements in 'lineLengths'
    int lineLengthsSize;

    // this marker and offset can name an arbitrary point
    // in the array, including those that are not at the
    // start of a line; we move this around when searching
    // within the array
    Marker marker;
    int markerCol;      // 1-based column; it's usually 1

    // an index built on top of 'lineLengths' for faster random access
    Marker *index;                   // (owner)

    // # of elements in 'index'
    int indexSize;

  private:   // funcs
    File(File&);                     // disallowed
    void resetMarker();
    void advanceMarker();

  public:    // funcs
    // this builds both the array and the index
    File(char const *name, SourceLoc startLoc);
    ~File();
    
    // line number to character offset
    int lineToChar(int lineNum);

    // line/col to offset, with truncation if col exceeds line length
    int lineColToChar(int lineNum, int col);

    // char offset to line/col
    void charToLineCol(int offset, int &line, int &col);

    // true if this file contains the specified location
    bool hasLoc(SourceLoc sl) const
      { return toInt(startLoc) <= sl &&
                                  sl <= toInt(startLoc) + numChars; }

    // call this time each time a #line directive is encountered;
    // same semantics as HashLineMap::addHashLine
    void addHashLine(int ppLine, int origLine, char const *origFname);
    void doneAdding();
  };

  // this is used for SourceLocs where the file isn't reliably
  // available, yet we'd like to be able to store some location
  // information anyway; the queries below just return the static
  // information stored, and incremental update is impossible
  class StaticLoc {
  public:
    sm_string name;      // file name
    int offset;       // char offset
    int line, col;    // line,col
              
  public:
    StaticLoc(char const *n, int o, int L, int c)
      : name(n), offset(o), line(L), col(c) {}
    StaticLoc(StaticLoc const &obj)
      : DMEMB(name), DMEMB(offset), DMEMB(line), DMEMB(col) {}
    ~StaticLoc();
  };

private:     // data
  // list of files; it would be possible to use a data structure
  // that is faster to search, but the cache ought to exploit
  // query locality to the extent that it doesn't matter
  ObjList<File> files;

  // most-recently accessed File; this is a cache
  File *recent;                      // (serf)

  // list of StaticLocs; any SourceLoc less than 0 is interpreted
  // as an index into this list
  ObjList<StaticLoc> statics;

  // next source location to assign
  SourceLoc nextLoc;

  // next static (negative) location
  SourceLoc nextStaticLoc;

public:      // data
  // number of static locations at which we print a warning message;
  // defaults to 100
  int maxStaticLocs;

  // when true, we automatically consult the #line maps when decoding;
  // defaults to true; NOTE: when this is true, encode and decode are
  // not necessarily inverses of each other
  bool useHashLines;

  // count the # of times we had to truncate a char offset because
  // the #line map pointed at a line shorter than the column number
  // we expected to use; this is initially 0; calling code can use
  // this to tell if the offset information across a given call or
  // sequence of calls is perfect or truncated
  static int shortLineCount;

private:     // funcs
  // let File know about these functions
  friend class SourceLocManager::File;

  static SourceLoc toLoc(int L) {
    SourceLoc ret = (SourceLoc)L;

    // in debug mode, we verify that SourceLoc is wide enough
    // to encode this integer
    xassertdb(toInt(ret) == L);

    return ret;
  }
  static int toInt(SourceLoc loc) { return (int)loc; }

  File *findFile(char const *name);
  File *getFile(char const *name);

  public:                       // dsw: I need this so I have an object to annotate with a VoidVoidDict
  File *findFileWithLoc(SourceLoc loc);
  private:
  StaticLoc const *getStatic(SourceLoc loc);

public:      // funcs
  SourceLocManager();
  ~SourceLocManager();

  // origins:
  //   character offsets start at 0
  //   lines start at 1
  //   columns start at 1

  // encode from scratch
  SourceLoc encodeOffset(char const *filename, int charOffset);
  SourceLoc encodeBegin(char const *filename)
    { return encodeOffset(filename, 0 /*offset*/); }
  SourceLoc encodeLineCol(char const *filename, int line, int col);

  // some care is required with 'encodeStatic', since each call makes
  // a new location with a new entry in the static array to back it
  // up, so the caller should ensure a given static location is not
  // encoded more than once, if possible
  SourceLoc encodeStatic(StaticLoc const &obj);
  SourceLoc encodeStatic(char const *fname, int offset, int line, int col)
    { return encodeStatic(StaticLoc(fname, offset, line, col)); }
  static bool isStatic(SourceLoc loc) { return toInt(loc) <= 0; }

  // encode incremental; these are the methods we expect are called
  // the most frequently; this interface is supposed to allow an
  // implementation which uses explicit line/col, even though that
  // is not what is used here
  static SourceLoc advCol(SourceLoc base, int colOffset)
    { xassert(!isStatic(base)); return toLoc(toInt(base) + colOffset); }
  static SourceLoc advLine(SourceLoc base)     // from end of line to beginning of next
    { xassert(!isStatic(base)); return toLoc(toInt(base) + 1); }
  static SourceLoc advText(SourceLoc base, char const * /*text*/, int textLen)
    { xassert(!isStatic(base)); return toLoc(toInt(base) + textLen); }

  // decode
  void decodeOffset(SourceLoc loc, char const *&filename, int &charOffset);
  void decodeLineCol(SourceLoc loc, char const *&filename, int &line, int &col);

  // more specialized decode
  char const *getFile(SourceLoc loc);
  int getOffset(SourceLoc loc);
  int getLine(SourceLoc loc);
  int getCol(SourceLoc loc);

  // get access to the File itself, for adding #line directives
  File *getInternalFile(char const *fname)
    { return getFile(fname); }

  // render as sm_string in "file:line:col" format
  sm_string getString(SourceLoc loc);

  // "line:col" format
  sm_string getLCString(SourceLoc loc);
};


// singleton pointer, set automatically by the constructor
extern SourceLocManager *sourceLocManager;

// dsw: So that gdb can find it please DO NOT inline this; also the
// unique public name is intensional: I don't want gdb doing
// overloading and sometimes getting it wrong, which it does
sm_string locToStr(SourceLoc sl);

inline sm_string toString(SourceLoc sl)
  { return locToStr(sl); }

inline sm_stringBuilder& operator<< (sm_stringBuilder &sb, SourceLoc sl)
  { return sb << toString(sl); }

inline sm_string toLCString(SourceLoc sl)
  { return sourceLocManager->getLCString(sl); }


// macro for obtaining a source location that points at the
// point in the source code where this macro is invoked
#define HERE_SOURCELOC \
  (sourceLocManager->encodeStatic(__FILE__, 0, __LINE__, 1))


// it's silly to demand mention of 'SourceLocManager' just to update
// the locations, esp. since SourceLoc is its own type and therefore
// overloading will avoid any possible collisions
inline SourceLoc advCol(SourceLoc base, int colOffset)
  { return SourceLocManager::advCol(base, colOffset); }
inline SourceLoc advLine(SourceLoc base)
  { return SourceLocManager::advLine(base); }
inline SourceLoc advText(SourceLoc base, char const *text, int textLen)
  { return SourceLocManager::advText(base, text, textLen); }


#endif // SRCLOC_H
@h=tangler('elk/sm_strdict.h')
@select(h)
// strdict.h            see license.txt for copyright and terms of use
// sm_string dictionary
// (c) Scott McPeak, 2000

// entire module is case sensitive

#ifndef __STRDICT_H
#define __STRDICT_H

#include <iostream>   // std::ostream
#include "sm_str.h"
#include "sm_macros.h"
#include "sm_xassert.h"
#include "sm_typ.h"

class StringDict {
private:    // types
  class Node {
  public:
    Node *next;
    sm_string key, value;

  public:
    Node(char const *k, char const *v, Node *n = NULL)
      : next(n), key(k), value(v) {}
    ~Node() {}
  };

public:     // types
  // Note: some care must be taken when dealing with Iters, because
  //       they can be invalidated when held across modifications to
  //       structure of the underlying dictionary
  class Iter {
  private:
    Node *current;

  public:
    Iter(Node *n) : current(n) {}
    Iter(StringDict &dict) { operator=(dict.getIter()); }
    Iter(Iter const &obj) : DMEMB(current) {}
    Iter& operator= (Iter const &obj) { CMEMB(current); return *this; }

    bool isDone() const { return current == NULL; }
    Iter& next() { xassert(current); current = current->next; return *this; }
      // 'next' returns a value primarily to allow use in for-loop comma exprs

    sm_string& key() const { return current->key; }
    sm_string& value() const { return current->value; }
  };
  friend class Iter;

  // iterator that can't modify the dictionary entries
  class IterC : protected Iter {
  public:
    IterC(Node const *n) : Iter(const_cast<Node*>(n)) {}
    IterC(StringDict const &dict) : Iter(const_cast<StringDict&>(dict)) {}
    IterC(IterC const &obj) : Iter(obj) {}
    IterC& operator= (IterC const &obj) { Iter::operator=(obj); return *this; }

    // some operations can be made available unchanged
    Iter::isDone;
    Iter::next;

    // others must be const-ified
    sm_string const &key() const { return Iter::key(); }
    sm_string const &value() const { return Iter::value(); }
  };

private:    // data
  Node *top;             // first list node (possibly NULL)

protected:  // funcs
  void selfCheck() const;      // throw exception if invariants violated

  void verifySorted() const;   // throw exception if list isn't sorted

  void /*mutable*/ sort();     // arrange nodes in alphabetically sorted order
    // (mutable because this isn't supposed to be visible from the outside)

  // invariants:
  //   list is well-formed structurally

public:
  StringDict();          // initializes to empty dictionary
  StringDict(StringDict const &obj);
  ~StringDict();

  StringDict& operator= (StringDict const &obj);

  bool operator== (StringDict const &obj) const;
  NOTEQUAL_OPERATOR(StringDict)

  // ------- selectors ---------
  int size() const;
    // retrieve # of mappings

  bool isEmpty() const;
    // returns true if size() is 0

  bool isNotEmpty() const
    { return !isEmpty(); }

  bool query(char const *key, sm_string &value) const;
    // if 'key' is mapped to a value, put it into 'value' and return true;
    // otherwise, return false

  sm_string queryf(char const *key) const;
    // return the value corresponding to 'key', or throw an exception of it's
    // not mapped

  bool isMapped(char const *key) const;
    // return true if 'key' is mapped to a value

  // -------- mutators -----------
  void add(char const *key, char const *value);
    // add a mapping from 'key' to 'value'; 'key' must initially be unmapped

  void modify(char const *key, char const *newValue);
    // change the existing value for 'key', which must exist, to 'newValue'

  void remove(char const *key);
    // remove the mapping from 'key', which must exist

  void empty();
    // remove all mappings

  // --------- iters -------------
  Iter getIter();
    // retrieve an iterator (the iterator remains valid only as long as
    // the structure of the dictionary does not get modified);
    // values will be iterated in *alphabetical* order

  IterC getIterC() const;
    // retrieve a const iterator

  Iter find(char const *key);
    // return an iterator pointing to 'key', or an iterator
    // that isDone() if 'key' isn't mapped

  // ------------ misc --------------
  INSERT_OSTREAM(StringDict)
  sm_string toString() const;
};

#endif // __STRDICT_H
@h=tangler('elk/sm_str.h')
@select(h)
// str.h            see license.txt for copyright and terms of use
// a sm_string class
// the representation uses just one char*, so that a smart compiler
//   can pass the entire object as a single word
// Scott McPeak, 1995-2000  This file is public domain.

#ifndef STR_H
#define STR_H

// this should eventually be put someplace more general...
#ifndef va_copy
  #ifdef __va_copy
    #define va_copy(a,b) __va_copy(a,b)
  #else
    #define va_copy(a,b) (a)=(b)
  #endif
#endif
// MOVE THE ABOVE TO PLACE MORE GENERAL 

#include "sm_typ.h"
#include <iostream>    // std::istream, std::ostream
#include <stdarg.h>      // va_list

class Flatten;           // flatten.h

class sm_string {
protected:     // data
  // 10/12/00: switching to never letting s be NULL
  char *s;                             // sm_string contents; never NULL
  static char * const empty;           // a global ""; should never be modified

protected:     // funcs
  void dup(char const *source);        // copies, doesn't dealloc first
  void kill();                         // dealloc if str != 0

public:        // funcs
  sm_string(sm_string const &src) { dup(src.s); }
  sm_string(char const *src) { dup(src); }
  sm_string(char const *src, int length);    // grab a subsm_string
  sm_string(int length) { s=empty; setlength(length); }
  sm_string() { s=empty; }

  ~sm_string() { kill(); }

  sm_string(Flatten&);
  void xfer(Flatten &flat);

  // simple queries
  int length() const;           // returns number of non-null chars in the sm_string; length of "" is 0
  bool isempty() const { return s[0]==0; }
  bool contains(char c) const;

  // array-like access
  char& operator[] (int i) { return s[i]; }
  char operator[] (int i) const { return s[i]; }

  // subsm_string
  sm_string subsm_string(int startIndex, int length) const;

  // conversions
  //operator char* () { return s; }      // ambiguities...
  operator char const* () const { return s; }
  char *pchar() { return s; }
  char const *pcharc() const { return s; }

  // assignment
  sm_string& operator=(sm_string const &src)
    { if (&src != this) { kill(); dup(src.s); } return *this; }
  sm_string& operator=(char const *src)
    { if (src != s) { kill(); dup(src); } return *this; }

  // allocate 'newlen' + 1 bytes (for null); initial contents is ""
  sm_string& setlength(int newlen);

  // comparison; return value has same meaning as strcmp's return value:
  //   <0   if   *this < src
  //   0    if   *this == src
  //   >0   if   *this > src
  int compareTo(sm_string const &src) const;
  int compareTo(char const *src) const;
  bool equals(char const *src) const { return compareTo(src) == 0; }

  #define MAKEOP(op)                                                             \
    bool operator op (sm_string const &src) const { return compareTo(src) op 0; }   \
    /*bool operator op (const char *src) const { return compareTo(src) op 0; }*/ \
    /* killed stuff with char* because compilers are too flaky; use compareTo */
  MAKEOP(==)  MAKEOP(!=)
  MAKEOP(>=)  MAKEOP(>)
  MAKEOP(<=)  MAKEOP(<)
  #undef MAKEOP

  // concatenation (properly handles sm_string growth)
  // uses '&' instead of '+' to avoid char* coercion problems
  sm_string operator& (sm_string const &tail) const;
  sm_string& operator&= (sm_string const &tail);

  // input/output
  friend std::istream& operator>> (std::istream &is, sm_string &obj)
    { obj.readline(is); return is; }
  friend std::ostream& operator<< (std::ostream &os, sm_string const &obj)
    { obj.write(os); return os; }

  // note: the read* functions are currently implemented in a fairly
  // inefficient manner (one char at a time)

  void readdelim(std::istream &is, char const *delim);
    // read from is until any character in delim is encountered; consumes that
    // character, but does not put it into the sm_string; if delim is null or
    // empty, reads until EOF

  void readall(std::istream &is) { readdelim(is, NULL); }
    // read all remaining chars of is into this

  void readline(std::istream &is) { readdelim(is, "\n"); }
    // read a line from input stream; consumes the \n, but doesn't put it into
    // the sm_string

  void write(std::ostream &os) const;
    // writes all stored characters (but not '\0')
    
  // debugging
  void selfCheck() const;
    // fail an assertion if there is a problem
};


// replace() and trimWhiteSpace() have been moved to strutil.h


// this class is specifically for appending lots of things
class sm_stringBuilder : public sm_string {
protected:
  enum { EXTRA_SPACE = 30 };    // extra space allocated in some situations
  char *end;          // current end of the sm_string (points to the NUL character)
  int size;           // amount of space (in bytes) allocated starting at 's'

protected:
  void init(int initSize);
  void dup(char const *src);

public:
  sm_stringBuilder(int length=0);    // creates an empty sm_string
  sm_stringBuilder(char const *str);
  sm_stringBuilder(char const *str, int length);
  sm_stringBuilder(sm_string const &str) { dup((char const*)str); }
  sm_stringBuilder(sm_stringBuilder const &obj) { dup((char const*)obj); }
  ~sm_stringBuilder() {}

  sm_stringBuilder& operator= (char const *src);
  sm_stringBuilder& operator= (sm_string const &s) { return operator= ((char const*)s); }
  sm_stringBuilder& operator= (sm_stringBuilder const &s) { return operator= ((char const*)s); }

  int length() const { return end-s; }
  bool isempty() const { return length()==0; }

  sm_stringBuilder& setlength(int newlen);    // change length, forget current data

  // make sure we can store 'someLength' non-null chars; grow if necessary
  void ensure(int someLength) { if (someLength >= size) { grow(someLength); } }

  // grow the sm_string's length (retaining data); make sure it can hold at least
  // 'newMinLength' non-null chars
  void grow(int newMinLength);

  // this can be useful if you modify the sm_string contents directly..
  // it's not really the intent of this class, though
  void adjustend(char* newend);

  // make the sm_string be the empty sm_string, but don't change the
  // allocated space
  void clear() { adjustend(s); }

  // concatenation, which is the purpose of this class
  sm_stringBuilder& operator&= (char const *tail);

  // useful for appending subsm_strings or sm_strings with NUL in them
  void append(char const *tail, int length);

  // append a given number of spaces; meant for contexts where we're
  // building a multi-line sm_string; returns '*this'
  sm_stringBuilder& indent(int amt);

  // sort of a mixture of Java compositing and C++ i/o strstream
  // (need the coercion versions (like int) because otherwise gcc
  // spews mountains of f-ing useless warnings)
  sm_stringBuilder& operator << (char const *text) { return operator&=(text); }
  sm_stringBuilder& operator << (char c);
  sm_stringBuilder& operator << (unsigned char c) { return operator<<((char)c); }
  sm_stringBuilder& operator << (long i);
  sm_stringBuilder& operator << (unsigned long i);
  sm_stringBuilder& operator << (int i) { return operator<<((long)i); }
  sm_stringBuilder& operator << (unsigned i) { return operator<<((unsigned long)i); }
  sm_stringBuilder& operator << (short i) { return operator<<((long)i); }
  sm_stringBuilder& operator << (unsigned short i) { return operator<<((long)i); }
  sm_stringBuilder& operator << (double d);
  sm_stringBuilder& operator << (void *ptr);     // inserts address in hex
  #ifndef LACKS_BOOL
    sm_stringBuilder& operator << (bool b) { return operator<<((long)b); }
  #endif // LACKS_BOOL

  // useful in places where long << expressions make it hard to
  // know when arguments will be evaluated, but order does matter
  typedef sm_stringBuilder& (*Manipulator)(sm_stringBuilder &sb);
  sm_stringBuilder& operator<< (Manipulator manip);

  // stream readers
  friend std::istream& operator>> (std::istream &is, sm_stringBuilder &sb)
    { sb.readline(is); return is; }
  void readall(std::istream &is) { readdelim(is, NULL); }
  void readline(std::istream &is) { readdelim(is, "\n"); }

  void readdelim(std::istream &is, char const *delim);

  // an experiment: hex formatting (something I've sometimes done by resorting
  // to sprintf in the past)
  class Hex {
  public:
    unsigned long value;

    Hex(unsigned long v) : value(v) {}
    Hex(Hex const &obj) : value(obj.value) {}
  };
  sm_stringBuilder& operator<< (Hex const &h);
  #define SBHex sm_stringBuilder::Hex
};


// the real strength of this entire module: construct sm_strings in-place
// using the same syntax as C++ istd::ostreams.  e.g.:
//   puts(sm_stringb("x=" << x << ", y=" << y));
#define sm_stringb(expr) (sm_stringBuilder() << expr)

// experimenting with dropping the () in favor of <<
// (the "c" can be interpreted as "constructor", or maybe just
// the successor to "b" above)
#define sm_stringc sm_stringBuilder()


// experimenting with using toString as a general method for datatypes
sm_string toString(int i);
sm_string toString(unsigned i);
sm_string toString(char c);
sm_string toString(long i);
sm_string toString(char const *str);
sm_string toString(float f);


// printf-like construction of a sm_string; often very convenient, since
// you can use any of the formatting characters (like %X) that your
// libc's sprintf knows about
sm_string sm_stringf(char const *format, ...);
sm_string vsm_stringf(char const *format, va_list args);


#endif // STR_H
@h=tangler('elk/sm_strhash.h')
@select(h)
// strhash.h            see license.txt for copyright and terms of use
// hash table mapping sm_strings to arbitrary pointers, where
// the stored pointers can be used to derive the key, and
// cannot be NULL

#ifndef STRHASH_H
#define STRHASH_H

#include "sm_hashtbl.h"

class StringHash : private HashTable {
public:     // types
  // given a stored data pointer, retrieve the associated key
  typedef char const* (*GetKeyFn)(void *data);

private:    // funcs
  // disallowed
  StringHash(StringHash&);
  void operator=(StringHash&);
  void operator==(StringHash&);

public:     // funcs
  StringHash(GetKeyFn getKey);
  ~StringHash();

  // utilities
  static unsigned coreHash(char const *key);
  static bool keyCompare(char const *key1, char const *key2);

  // return # of mapped entries
  int getNumEntries() const
    { return HashTable::getNumEntries(); }

  // if this key has a mapping, return it; otherwise,
  // return NULL
  void *get(char const *key) const
    { return HashTable::get(key); }

  // add a mapping from 'key' to 'value'; there must not already
  // be a mapping for this key
  void add(char const *key, void *value)
    { HashTable::add(key, value); }

  // remove the mapping for 'key' -- it must exist
  void remove(char const *key)
    { HashTable::remove(key); }

  // drop all entries
  void empty() 
    { HashTable::empty(); }  

  // check the data structure's invariants, and throw an exception
  // if there is a problem
  void selfCheck() const
    { HashTable::selfCheck(); }
};


// type-safe template wrapper          
template <class T>
class TStringHash : public StringHash {
public:      // types
  typedef char const* (*GetKeyFn)(T *data);

public:
  TStringHash(GetKeyFn fn)            : StringHash((StringHash::GetKeyFn)fn) {}
  ~TStringHash()                      {}

  int getNumEntries() const           { return StringHash::getNumEntries(); }
  T *get(char const *key) const       { return (T*)StringHash::get(key); }
  void add(char const *key, T *value) { StringHash::add(key, (void*)value); }
  void remove(char const *key)        { StringHash::remove(key); }
  void empty()                        { StringHash::empty(); }
};


#endif // STRHASH_H
@h=tangler('elk/sm_stringset.h')
@select(h)
// sm_stringset.h            see license.txt for copyright and terms of use
// set of character sm_strings

#ifndef STRINGSET_H
#define STRINGSET_H

#include "sm_strsobjdict.h"

class StringSet {
private:     // data        
  // represent using a dictionary of pointers to nothing
  StringSObjDict<int> elts;
  
public:      // funcs
  StringSet() : elts() {}
  ~StringSet();

  // # elts in the set
  int size() const                        { return elts.size(); }

  bool isEmpty() const                    { return elts.isEmpty(); }
  bool isNotEmpty() const                 { return elts.isNotEmpty(); }

  // true if elt is in the set
  bool contains(char const *elt) const    { return elts.isMapped(elt); }

  // add elt to the set; ok if it's already there
  void add(char const *elt);

  // remove elt from the set; ok if it's not there now
  void remove(char const *elt);

  // empty the set
  void empty()                            { elts.empty(); }
};

#endif // STRINGSET_H
@h=tangler('elk/sm_strobjdict.h')
@select(h)
// strobjdict.h            see license.txt for copyright and terms of use
// dictionary of objects, indexed by sm_string (case-sensitive)
// (c) Scott McPeak, 2000

#ifndef __STROBJDICT_H
#define __STROBJDICT_H

#include "sm_svdict.h"


// the dictionary object is considered to own all of the things
// contained, so constness means constness of the contained objects
// as well as the mapping from sm_strings to them

template <class T>
class StringObjDict {
public:     // types
  // 'foreach' iterator functions
  typedef bool (*ForeachCFn)(sm_string const &key, T const *value, void *extra);
  typedef bool (*ForeachFn)(sm_string const &key, T * /*serf*/ value, void *extra);

  // external iterator
  class Iter {
  private:
    StringVoidDict::IterC iter;

  public:
    Iter(StringObjDict const &dict) : iter(dict.dict) {}
    Iter(Iter const &obj) : DMEMB(iter) {}
    Iter& operator= (Iter const &obj) { CMEMB(iter); return *this; }

    bool isDone() const { return iter.isDone(); }
    Iter& next() { iter.next(); return *this; }

    sm_string const &key() const { return iter.key(); }
    T const *&value() const { return (T const *&)iter.value(); }
  };
  friend class Iter;

private:    // data
  // underlying dictionary functionality
  StringVoidDict dict;

private:    // funcs
  // disallowed
  StringObjDict(StringObjDict const &obj);
  StringObjDict& operator= (StringObjDict const &obj);
  bool operator== (StringObjDict const &obj) const;

public:     // funcs
  StringObjDict() : dict() {}
  ~StringObjDict() { empty(); }

  // due to similarity with StringVoidDict, see svdict.h for
  // details on these functions' interfaces

  // ------- selectors ---------
  int size() const                                     { return dict.size(); }

  bool isEmpty() const                                 { return dict.isEmpty(); }
  bool isNotEmpty() const                              { return !isEmpty(); }

  bool queryC(char const *key, T const *&value) const  { return dict.query(key, (void*&)value); }
  bool query(char const *key, T *&value)               { return queryC(key, (T const*&)value); }

  T const *queryfC(char const *key) const              { return (T const *)dict.queryf(key); }
  T * /*serf*/ queryf(char const *key)                 { return (T*)dict.queryf(key); }
  T * /*serf*/ queryif(char const *key)                { return (T*)dict.queryif(key); }

  bool isMapped(char const *key) const                 { return dict.isMapped(key); }

  // -------- mutators -----------
  void add(char const *key, T *value)                  { dict.add(key, value); }

  T * /*owner*/ remove(char const *key)                { return (T*)dict.remove(key); }
  void deleteAt(char const *key)                       { deleteObject(remove(key)); }

  void empty()               { dict.emptyAndDel((StringVoidDict::DelFn)deleteObject); }

  // --------- iters -------------
  void foreachC(ForeachCFn func, void *extra=NULL) const
    { dict.foreach((StringVoidDict::ForeachFn)func, extra); }
  void foreach(ForeachFn func, void *extra=NULL)
    { dict.foreach((StringVoidDict::ForeachFn)func, extra); }

  // ------------ misc --------------
  static void deleteObject(T *obj);
};


template <class T>
STATICDEF void StringObjDict<T>::deleteObject(T *obj)
{
  delete obj;
}

#endif // __STROBJDICT_H
@h=tangler('elk/sm_strsobjdict.h')
@select(h)
// strsobjdict.h            see license.txt for copyright and terms of use
// dictionary of *serf* pointers to objects, indexed by sm_string (case-sensitive)
// (c) Scott McPeak, 2000

// created by copying strobjdict and modifying.. nonideal..

#ifndef __STRSOBJDICT_H
#define __STRSOBJDICT_H

#include "sm_svdict.h"


// since the dictionary does not own the pointed-to objects,
// it has the same constness model as StringVoidDict, namely
// that const means the *mapping* is constant but not the
// pointed-to objects

template <class T>
class StringSObjDict {
public:     // types
  // 'foreach' iterator functions
  typedef bool (*ForeachFn)(sm_string const &key, T *value, void *extra);

  // external iterator
  class Iter {
  private:
    StringVoidDict::Iter iter;

  public:
    Iter(StringSObjDict &dict) : iter(dict.dict) {}
    Iter(Iter const &obj) : DMEMB(iter) {}
    Iter& operator= (Iter const &obj) { CMEMB(iter); return *this; }

    bool isDone() const { return iter.isDone(); }
    Iter& next() { iter.next(); return *this; }

    sm_string const &key() const { return iter.key(); }
    T *&value() const { return (T *&)iter.value(); }

    //int private_getCurrent() const { return iter.private_getCurrent(); }
    void *private_getCurrent() const { return iter.private_getCurrent(); }
  };
  friend class Iter;

  class IterC {
  private:
    StringVoidDict::IterC iter;

  public:
    IterC(StringSObjDict const &dict) : iter(dict.dict) {}
    IterC(IterC const &obj) : DMEMB(iter) {}
    IterC& operator= (IterC const &obj) { CMEMB(iter); return *this; }

    bool isDone() const { return iter.isDone(); }
    IterC& next() { iter.next(); return *this; }

    sm_string const &key() const { return iter.key(); }
    T *value() const { return (T *)iter.value(); }

    //int private_getCurrent() const { return iter.private_getCurrent(); }
    void *private_getCurrent() const { return iter.private_getCurrent(); }
  };
  friend class IterC;

private:    // data
  // underlying dictionary functionality
  StringVoidDict dict;

public:     // funcs
  StringSObjDict() : dict() {}
  StringSObjDict(StringSObjDict const &obj) : dict(obj.dict) {}
  ~StringSObjDict() {}

  // comparison and assignment use *pointer* comparison/assignment

  StringSObjDict& operator= (StringSObjDict const &obj)    { dict = obj.dict; return *this; }

  bool operator== (StringSObjDict const &obj) const        { return dict == obj.dict; }
  NOTEQUAL_OPERATOR(StringSObjDict)

  // due to similarity with StringVoidDict, see svdict.h for
  // details on these functions' interfaces

  // ------- selectors ---------
  int size() const                                     { return dict.size(); }

  bool isEmpty() const                                 { return dict.isEmpty(); }
  bool isNotEmpty() const                              { return !isEmpty(); }

  bool query(char const *key, T *&value) const         { return dict.query(key, (void*&)value); }
  T *queryf(char const *key) const                     { return (T*)dict.queryf(key); }
  T *queryif(char const *key) const                    { return (T*)dict.queryif(key); }

  bool isMapped(char const *key) const                 { return dict.isMapped(key); }

  // -------- mutators -----------
  void add(char const *key, T *value)                  { dict.add(key, (void*)value); }

  T *modify(char const *key, T *newValue)              { return (T*)dict.modify(key, (void*)newValue); }

  T *remove(char const *key)                           { return (T*)dict.remove(key); }

  void empty()                                         { dict.empty(); }

  // --------- iters -------------
  void foreach(ForeachFn func, void *extra=NULL) const
    { dict.foreach((StringVoidDict::ForeachFn)func, extra); }
    
  // debugging
  //int private_getTopAddr() const { return dict.private_getTopAddr(); }
  void *private_getTopAddr() const { return dict.private_getTopAddr(); }
};


#endif // __STRSOBJDICT_H
@h=tangler('elk/sm_strtokp.h')
@select(h)
// strtokp.h            see license.txt for copyright and terms of use
// using std::strtok to parse an entire sm_string at once
// Scott McPeak, 1997  This file is public domain.

#ifndef __STRTOKP_H
#define __STRTOKP_H

#include "sm_str.h"
#include <cstring>    // std::strlen

class StrtokParse {
  sm_string buf;          // locally allocated storage
  int _tokc;           // # of tokens found
  char **_tokv;        // array of tokens themselves

private:
  void validate(int which) const;
    // throw an exception if which is invalid token

public:
  StrtokParse(char const *str, char const *delim);
    // parse 'str' into tokens delimited by chars from 'delim'

  ~StrtokParse();
    // clean up'

  int tokc() const { return _tokc; }
  operator int () const { return tokc(); }
    // simple count of available tokens

  char const *tokv(int which) const;     // may throw xArrayBounds
  char const* operator[] (int which) const { return tokv(which); }
    // access to tokens; must make local copies to modify

  sm_string reassemble(int firstTok, int lastTok, char const *originalString) const;
    // return the subsm_string of the original sm_string spanned by the
    // given range of tokens; if firstTok==lastTok, only that token is
    // returned (without any separators); must be that firstTok <=
    // lastTok

  sm_string join(int firstTok, int lastTok, char const *separator) const;
    // return a sm_string created by concatenating the given range of tokens
    // together with 'separator' in between them

  int offset(int which) const;
    // return a value that, when added to the original 'str' parameter,
    // yields a pointer to where tokv(which) is, as a subsm_string, in that sm_string

  int offsetAfter(int which) const
    { return offset(which) + std::strlen(tokv(which)); }
    // offset for character just beyond last one in tokv (should be either
    // a delimiter character, or 0)

  char **spawn_tokv_array() { return _tokv; }
    // this is defined because it makes it convenient to generate
    // spawn arguments, and should be limited to use for that purpose
    // (because it exposes internal representation which is in
    // principle subject to change)
};

#endif // __STRTOKP_H

@h=tangler('elk/sm_strutil.h')
@select(h)
// strutil.h            see license.txt for copyright and terms of use
// various sm_string utilities built upon the 'str' module
// Scott McPeak, July 2000

#ifndef STRUTIL_H
#define STRUTIL_H

#include "sm_str.h"
#include <stdio.h>    // FILE

// direct sm_string replacement, replacing instances of oldstr with newstr
// (newstr may be "")
sm_string replace(char const *src, char const *oldstr, char const *newstr);

// works like unix "tr": the source sm_string is translated character-by-character,
// with occurrences of 'srcchars' replaced by corresponding characters from
// 'destchars'; further, either set may use the "X-Y" notation to denote a
// range of characters from X to Y
sm_string translate(char const *src, char const *srcchars, char const *destchars);

// a simple example of using translate; it was originally inline, but a bug
// in egcs made me move it out of line
sm_string sm_stringToupper(char const *src);
//  { return translate(src, "a-z", "A-Z"); }


// remove any whitespace at the beginning or end of the sm_string
sm_string trimWhitespace(char const *str);


// encode a block of bytes as a sm_string with C backslash escape
// sequences (but without the opening or closing quotes)
sm_string encodeWithEscapes(char const *src, int len);

// safe when the text has no NUL characters
sm_string encodeWithEscapes(char const *src);

// adds the quotes too
sm_string quoted(char const *src);


// decode an escaped sm_string; throw xFormat if there is a problem
// with the escape syntax; if 'delim' is specified, it will also
// make sure there are no unescaped instances of that
void decodeEscapes(sm_string &dest, int &destLen, char const *src,
                   char delim = 0, bool allowNewlines=false);

// given a sm_string with quotes and escapes, yield just the sm_string;
// works if there are no escaped NULs
sm_string parseQuotedString(char const *text);


// this probably belongs in a dedicated module for time/date stuff..
// returns asctime(localtime(time))
sm_string localTimeString();


// given a directory name like "a/b/c", return "c"
// renamed from 'basename' because of conflict with something in sm_string.h
sm_string sm_basename(char const *src);

// given a directory name like "a/b/c", return "a/b"; if 'src' contains
// no slashes at all, return "."
sm_string dirname(char const *src);


// return 'prefix', pluralized if n!=1; for example
//   plural(1, "egg") yields "egg", but
//   plural(2, "egg") yields "eggs";
// it knows about a few irregular pluralizations (see the source),
// and the expectation is I'll add more irregularities as I need them
sm_string plural(int n, char const *prefix);

// same as 'plural', but with the sm_stringized version of the number:
//   pluraln(1, "egg") yields "1 egg", and
//   pluraln(2, "eggs") yields "2 eggs"
sm_string pluraln(int n, char const *prefix);


// Sometimes it's useful to store a sm_string value in a static buffer;
// most often this is so 'gdb' can see the result.  This function just
// copies its input into a static buffer (of unspecified length, but
// it checks bounds internally), and returns a pointer to that buffer.
char *copyToStaticBuffer(char const *src);


// true if the first part of 'str' matches 'prefix'
bool prefixEquals(char const *str, char const *prefix);

// and similar for last part
bool suffixEquals(char const *str, char const *suffix);


// read/write sm_strings <-> files
void writeStringToFile(char const *str, char const *fname);
sm_string readStringFromFile(char const *fname);


// read the next line from a FILE* (e.g. an AutoFILE); the
// newline is returned if it is present (you can use 'chomp'
// to remove it); returns false (and "") on EOF
bool readLine(sm_string &dest, FILE *fp);


// like perl 'chomp': remove a final newline if there is one
sm_string chomp(char const *src);


#endif // STRUTIL_H
@h=tangler('elk/sm_svdict.h')
@select(h)
// svdict.h            see license.txt for copyright and terms of use
// dictionary of void*, indexed by sm_string (case-sensitive)
// (c) Scott McPeak, 2000

// created by modifying strdict; at some point strdict should
// be rewritten to use this module

#ifndef __SVDICT_H
#define __SVDICT_H

#include <iostream>   // std::ostream
#include "sm_str.h"
#include "sm_macros.h"
#include "sm_xassert.h"
#include "sm_typ.h"
#include "sm_strhash.h"
  

// constness: for this class, 'const' means the *mapping* from sm_string
// to void* won't change; but I don't prevent the thing pointed-at
// by the void* from changing (would like multiple levels of constness..)

class StringVoidDict {
private:    // types
  // 3/16/03: I believe the reason I stored the information both in a
  // hash table and in a linked list is to be able to support efficient
  // alphabetical iteration
  class Node {
  public:
    Node *next;
    sm_string key;
    void *value;

  public:
    Node(char const *k, void *v, Node *n = NULL)
      : next(n), key(k), value(v) {}
    ~Node() {}
    
    static char const *getKey(Node const *n);
  };

public:     // types
  // function for general foreach; return false to continue,
  // true to stop iterating
  typedef bool (*ForeachFn)(sm_string const &key, void *value, void *extra);

  // function type to delete void*s while emptying
  typedef void (*DelFn)(void *value);

  // Note: some care must be taken when dealing with Iters, because
  //       they can be invalidated when held across modifications to
  //       structure of the underlying dictionary
  class Iter {
  private:
    Node *current;

  public:
    Iter(Node *n) : current(n) {}
    Iter(StringVoidDict &dict) { operator=(dict.getIter()); }
    Iter(Iter const &obj) : DMEMB(current) {}
    Iter& operator= (Iter const &obj) { CMEMB(current); return *this; }

    bool isDone() const { return current == NULL; }
    Iter& next() { xassert(current); current = current->next; return *this; }
      // 'next' returns a value primarily to allow use in for-loop comma exprs

    sm_string &key() const { return current->key; }
    void *&value() const { return current->value; }
    
    //int private_getCurrent() const { return (int)current; }
    void *private_getCurrent() const { return current; }
  };
  friend class Iter;

  // iterator that can't modify the dictionary entries
  class IterC : protected Iter {
  public:
    IterC(Node const *n) : Iter(const_cast<Node*>(n)) {}
    IterC(StringVoidDict const &dict) : Iter(const_cast<StringVoidDict&>(dict)) {}
    IterC(IterC const &obj) : Iter(obj) {}
    IterC& operator= (IterC const &obj) { Iter::operator=(obj); return *this; }

    // some operations can be made available unchanged
    Iter::isDone;
    Iter::next;
    Iter::private_getCurrent;

    // others must be const-ified
    sm_string const &key() const { return Iter::key(); }
    void const *&value() const { return (void const *&)Iter::value(); }
  };

private:    // data
  // first list node (possibly NULL)
  Node *top;

  // hash table to improve lookup performance
  StringHash hash;

  // invariants:
  //   list is well-formed structurally
  //   every node is in the hash table, and vice versa

protected:  // funcs
  void selfCheck() const;      // throw exception if invariants violated

  void verifySorted() const;   // throw exception if list isn't sorted

  void /*mutable*/ sort();     // arrange nodes in alphabetically sorted order
    // (mutable because this isn't supposed to be visible from the outside)

public:
  StringVoidDict();          // initializes to empty dictionary
  StringVoidDict(StringVoidDict const &obj);
  ~StringVoidDict();

  StringVoidDict& operator= (StringVoidDict const &obj);

  // comparison is done by pointer equality of void*
  bool operator== (StringVoidDict const &obj) const;
  NOTEQUAL_OPERATOR(StringVoidDict)

  // ------- selectors ---------
  int size() const;
    // retrieve # of mappings

  bool isEmpty() const;
    // returns true if size() is 0

  bool isNotEmpty() const
    { return !isEmpty(); }

  bool query(char const *key, void *&value) const;
    // if 'key' is mapped to a value, put it into 'value' and return true;
    // otherwise, return false

  void *queryf(char const *key) const;
    // return the value corresponding to 'key', or throw an exception of it's
    // not mapped

  void *queryif(char const *key) const;
    // return the value corresponding to 'key', or return NULL

  bool isMapped(char const *key) const;
    // return true if 'key' is mapped to a value

  // -------- mutators -----------
  void add(char const *key, void *value);
    // add a mapping from 'key' to 'value'; 'key' must initially be unmapped

  void *modify(char const *key, void *newValue);
    // change the existing value for 'key', which must exist, to 'newValue';
    // the old value is returned

  void *remove(char const *key);
    // remove the mapping from 'key', which must exist; it is returned

  void emptyAndDel(DelFn func);
    // apply the deletion func to all values, during empty()

  void empty();
    // remove all mappings

  // --------- iters -------------
  Iter getIter();
    // retrieve an iterator (the iterator remains valid only as long as
    // the structure of the dictionary does not get modified);
    // values will be iterated in *alphabetical* order

  IterC getIterC() const;
    // retrieve a const iterator

  Iter find(char const *key);
    // return an iterator pointing to 'key', or an iterator
    // that isDone() if 'key' isn't mapped

  void foreach(ForeachFn func, void *extra=NULL) const;
    // apply 'func' to every mapping, in alphabetical order

  // ------------ misc --------------
  INSERT_OSTREAM(StringVoidDict)
  sm_string toString() const;
  
  // debugging...
  //int private_getTopAddr() const { return (int)top; }
  void *private_getTopAddr() const { return top; }
};

#endif // __SVDICT_H
@h=tangler('elk/sm_syserr.h')
@select(h)
// syserr.h            see license.txt for copyright and terms of use
// error-reporting exception for system calls that fail
// Scott McPeak, 1999  This file is public domain.

// The intent here is to provide a way for portable *handling* of errors
// that are generated by nonportable code.

#ifndef __SYSERR_H
#define __SYSERR_H

#include "sm_exc.h"

class xSysError : public xBase {
private:    // data
  // error sm_strings for Reasons
  static char const * const reasonStrings[];

public:     // data
  // portable failure reasons (modelled loosely on errno.h)
  // it is anticipated that, as certain errors become important on certain
  //   platforms, that this list will be extended as necessary
  enum Reason {
    R_NO_ERROR,          // no error occurred
    R_FILE_NOT_FOUND,
    R_PATH_NOT_FOUND,
    R_ACCESS_DENIED,
    R_OUT_OF_MEMORY,
    R_SEGFAULT,          // invalid address / pointer
    R_FORMAT,            // bad data format
    R_INVALID_ARGUMENT,
    R_READ_ONLY,
    R_ALREADY_EXISTS,
    R_AGAIN,             // resource temporarily unavailable
    R_BUSY,              // resource busy
    R_INVALID_FILENAME,  // too long, bad chars, etc.
    R_UNKNOWN,           // OS-specific, can't find out, just don't know, etc.
    NUM_REASONS          // (must be last item in list)
  } reason;

  // reason sm_string that corresponds to 'reason'
  char const * const reasonString;

  // nonportable error code (errno on Unix, GetLastError() on Windows)
  // (value is 0 when we don't have this information)
  int sysErrorCode;

  // reason sm_string given by the OS, if any (might be NULL)
  sm_string sysReasonString;

  // name of syscall or API function name
  sm_string syscallName;

  // error context; what was being done (e.g., "opening an.important.file")
  sm_string context;

public:    // funcs
  xSysError(Reason r, int sysCode, char const *sysReason,
            char const *syscall, char const *ctx);
  xSysError(xSysError const &obj);
  ~xSysError();

  // mapping functions used internally
  static int getSystemErrorCode();
    // retrieve the error code used by local convention
    // [nonportable implementation]

  static Reason portablize(int sysErrorCode, sm_string &sysReason);
    // return a portable equivalent of a system error code;
    // returns R_UNKNOWN if the code is esoteric or invalid;
    // sets 'sysmsg' to the system's message sm_string, if possible
    // [nonportable implementation]

  static char const *getReasonString(Reason r);
    // translate a Reason into a sm_string (if r is invalid, a sm_string
    // saying to will be returned)

  static sm_string constructWhyString(Reason r, char const *sysReason,
                                   char const *syscall, char const *ctx);
    // construct the sm_string we throw as the 'why' of xBase; if ctx is NULL,
    // the sm_string doesn't include it

  static void xsyserror(char const *syscallName, char const *context);
    // does the throw
};


// function that does the throw
inline void xsyserror(char const *syscallName, char const *context = NULL)
{
  xSysError::xsyserror(syscallName, context);
}


// get a representative sm_string, for logging etc.
sm_string sysErrorCodeString(int systemErrorCode, char const *syscallName,
                                               char const *context=NULL);

inline sm_string sysErrorString(char const *syscallName, char const *context=NULL)
{
  return sysErrorCodeString(xSysError::getSystemErrorCode(),
                            syscallName, context);
}


#endif // __SYSERR_H

@h=tangler('elk/sm_taillist.h')
@select(h)
// taillist.h; see license.txt for copyright and terms of use
// list wrapper around VoidTailList in the spirit of ASTList, but doesn't own

// taken almost verbatim from asttlist.h in smbase

#ifndef TAILLIST_H
#define TAILLIST_H

#include "sm_vdtllist.h"

template <class T> class TailListIter;
template <class T> class TailListIterNC;

// a list which does not own the items in it (will NOT deallocate
// them), and has constant-time access to the last element
template <class T>
class TailList {
private:
  friend class TailListIter<T>;        
  friend class TailListIterNC<T>;

protected:
  VoidTailList list;            // list itself

private:
  TailList(TailList const &obj); // not allowed

public:
  TailList()                             : list() {}
  ~TailList()                            {  }

  // ctor to make singleton list; often quite useful
  TailList(T *elt)                       : list() { prepend(elt); }

  // stealing ctor; among other things, since &src->list is assumed to
  // point at 'src', this class can't have virtual functions;
  // these ctors delete 'src'
  TailList(TailList<T> *src)              : list(&src->list) {}
  void steal(TailList<T> *src)           { list.steal(&src->list); }

  // selectors
  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }
  T *nth(int which)                     { return (T*)list.nth(which); }
  T const *nthC(int which) const        { return (T const*)list.nth(which); }
  T *first()                            { return (T*)list.first(); }
  T const *firstC() const               { return (T const*)list.first(); }
  T *last()                             { return (T*)list.last(); }
  T const *lastC() const                { return (T const*)list.last(); }

  // insertion
  void prepend(T *newitem)              { list.prepend(newitem); }
  void append(T *newitem)               { list.append(newitem); }
  void insertAt(T *newitem, int index)  { list.insertAt(newitem, index); }
  void concat(TailList<T> &tail)         { list.concat(tail.list); }

  // removal
  T *removeFirst()                      { return (T*)list.removeFirst(); }
  T *removeLast()                       { return (T*)list.removeLast(); }
  T *removeAt(int index)                { return (T*)list.removeAt(index); }
  void removeItem(T *item)              { list.removeItem((void*)item); }
  
  // list-as-set: selectors
  int indexOf(T const *item) const      { return list.indexOf((void*)item); }
  int indexOfF(T const *item) const     { return list.indexOfF((void*)item); }
  bool contains(T const *item) const    { return list.contains((void*)item); }

  // list-as-set: mutators
  bool prependUnique(T *newitem)        { return list.prependUnique(newitem); }
  bool appendUnique(T *newitem)         { return list.appendUnique(newitem); }

  // debugging: two additional invariants
  void selfCheck() const                { list.selfCheck(); }
};


template <class T>
class TailListIter {
protected:
  VoidTailListIter iter;        // underlying iterator

public:
  TailListIter(TailList<T> const &list) : iter(list.list) {}
  ~TailListIter()                       {}

  void reset(TailList<T> const &list)   { iter.reset(list.list); }

  // iterator copying; generally safe
  TailListIter(TailListIter const &obj)             : iter(obj.iter) {}
  TailListIter& operator=(TailListIter const &obj)  { iter = obj.iter;  return *this; }

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T const *data() const                 { return (T const*)iter.data(); }
};

#define FOREACH_TAILLIST(T, list, iter) \
  for(TailListIter<T> iter(list); !iter.isDone(); iter.adv())


// version of the above, but for non-const-element traversal
template <class T>
class TailListIterNC {
protected:
  VoidTailListIter iter;        // underlying iterator

public:
  TailListIterNC(TailList<T> &list)      : iter(list.list) {}
  ~TailListIterNC()                     {}

  void reset(TailList<T> &list)         { iter.reset(list.list); }

  // iterator copying; generally safe
  TailListIterNC(TailListIterNC const &obj)             : iter(obj.iter) {}
  TailListIterNC& operator=(TailListIterNC const &obj)  { iter = obj.iter;  return *this; }

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T *data() const                       { return (T*)iter.data(); }
  
  // iterator mutation; use with caution
  void setDataLink(T *newData)          { iter.setDataLink((void*)newData); }
};

#define FOREACH_TAILLIST_NC(T, list, iter) \
  for(TailListIterNC<T> iter(list); !iter.isDone(); iter.adv())

#endif // TailLIST_H
@h=tangler('elk/sm_test.h')
@select(h)
// test.h            see license.txt for copyright and terms of use
// utilities for test code
// Scott McPeak, 1999  This file is public domain.

#ifndef __TEST_H
#define __TEST_H

#include <iostream>      // cout
#include <stdio.h>         // printf
#include "sm_exc.h"
#include "sm_nonport.h"


// reports uncaught exceptions
//
// 12/30/02: I used to print "uncaught exception: " before
// printing the exception, but this is meaningless to the
// user and the message usually has enough info anyway
#define USUAL_MAIN                              \
void entry();                                   \
int main()                                      \
{                                               \
  try {                                         \
    entry();                                    \
    return 0;                                   \
  }                                             \
  catch (xBase &x) {                            \
    std::cout << x << std::endl;                          \
    return 4;                                   \
  }                                             \
}

// same as above, but with command-line args
#define ARGS_MAIN                               \
void entry(int argc, char *argv[]);             \
int main(int argc, char *argv[])                \
{                                               \
  try {                                         \
    entry(argc, argv);                          \
    return 0;                                   \
  }                                             \
  catch (xBase &x) {                            \
    std::cout << x << std::endl;                          \
    return 4;                                   \
  }                                             \
}


// convenient for printing the value of a variable or expression
#define PVAL(val) std::cout << #val << " = " << (val) << std::endl


// easy way to time a section of code
class TimedSection {
  char const *name;
  long start;

public:
  TimedSection(char const *n) : name(n) {
    start = getMilliseconds();
  }
  ~TimedSection() {
    std::cout << name << ": " << (getMilliseconds() - start) << " msecs\n";
  }
};


#endif // __TEST_H

@h=tangler('elk/sm_thashtbl.h')
@select(h)
// thashtbl.h            see license.txt for copyright and terms of use
// type-safe version of HashTable

#ifndef THASHTBL_H
#define THASHTBL_H

#include "sm_hashtbl.h"

template <class KEY, class DATA> class THashTableIter;

template <class KEY, class DATA>
class THashTable {
private:    // types
  friend class THashTableIter<KEY, DATA>;

public:     // types
  // given a stored data pointer, retrieve the associated key
  typedef KEY const* (*GetKeyFn)(DATA *data);

  // given a key, retrieve the associated hash value;
  // this should be a 32-bit integer ready to be mod'd by the table size
  typedef unsigned (*HashFn)(KEY const *key);

  // compare two keys; this is needed so we can handle collisions
  // in the hash function; return true if they are equal
  typedef bool (*EqualKeyFn)(KEY const *key1, KEY const *key2);

private:    // data
  // underlying table
  HashTable table;

private:    // funcs
  // disallowed
  THashTable(THashTable&);
  void operator=(THashTable&);
  void operator==(THashTable&);

public:     // funcs
  THashTable(GetKeyFn gk, HashFn hf, EqualKeyFn ek,
             int initSize = HashTable::defaultSize)
    : table((HashTable::GetKeyFn)gk,
            (HashTable::HashFn)hf,
            (HashTable::EqualKeyFn)ek,
            initSize)
  {}
  ~THashTable() {}

  // return # of mapped entries
  int getNumEntries() const                 { return table.getNumEntries(); }

  // if this hash value has a mapping, return it; otherwise,
  // return NULL
  DATA *get(KEY const *key) const           { return (DATA*)table.get(key); }

  // add a mapping from 'key' to 'value'; there must not already
  // be a mapping for this key
  void add(KEY const *key, DATA *value)     { table.add(key, value); }

  // remove the mapping for 'key' -- it must exist;
  // returns the removed item
  DATA *remove(KEY const *key)              { return (DATA*)table.remove(key); }

  // remove all mappings
  void empty(int initSize = HashTable::defaultSize)   { table.empty(initSize); }

  // set whether shrinkage is allowed; it's useful to be able to
  // disable this to avoid any allocation in certain situations
  void setEnableShrink(bool en)             { table.setEnableShrink(en); }

  // allow external access to an accessor function
  KEY const *callGetKeyFn(DATA *data)       { return (KEY const*)table.getKey(data); }

  // check the data structure's invariants, and throw an exception
  // if there is a problem
  void selfCheck() const                    { table.selfCheck(); }
};


// iterate over all stored values in a THashTable
// NOTE: you can't change the table while an iter exists
template <class KEY, class DATA>
class THashTableIter {
private:      // data         
  HashTableIter iter;            // underlying iter

public:       // funcs
  THashTableIter(THashTable<KEY,DATA> &table) : iter(table.table) {}

  bool isDone() const          { return iter.isDone(); }
  void adv()                   { return iter.adv(); }
  DATA *data() const           { return (DATA*)iter.data(); }
};


#endif // THASHTBL_H
@h=tangler('elk/sm_trace.h')
@select(h)
// trace.h            see license.txt for copyright and terms of use
// module for diagnostic tracing
// see trace.html

#ifndef TRACE_H
#define TRACE_H

#include <iostream>     // std::ostream


// add a subsystem to the list of those being traced
void traceAddSys(char const *sysName);

// remove a subsystem; must have been there
void traceRemoveSys(char const *sysName);

// see if a subsystem is among those to trace
bool tracingSys(char const *sysName);

// clear all tracing flags
void traceRemoveAll();


// trace; if the named system is active, this yields cout (after
// sending a little output to identify the system); if not, it
// yields an std::ostream attached to /dev/null; when using this
// method, it is up to you to put the newline
std::ostream &trace(char const *sysName);

// give an entire sm_string to trace; do *not* put a newline in it
// (the tracer will do that)
void trstr(char const *sysName, char const *traceString);

// trace macro which disables itself when NDEBUG is true,
// and automatically supplies 'std::endl' when it's not true
//
// dsw: debugging *weakly* implies tracing: if we are debugging, do
// tracing unless otherwise specified
#ifndef NDEBUG
  #ifndef DO_TRACE
    #define DO_TRACE 1
  #endif
#endif
// dsw: tracing *bidirectionally* configurable from the command line:
// it may be turned on *or* off: any definition other than '0' counts
// as true, such as -DDO_TRACE=1 or just -DDO_TRACE
#ifndef DO_TRACE
  #define DO_TRACE 0
#endif
#if DO_TRACE != 0
  #define TRACE(tag, exp) trace(tag) << exp << std::endl /* user ; */
#else
  #define TRACE(tag, exp) ((void)0)
#endif


// special for "progress" tracing; prints time too;
// 'level' is level of detail -- 1 is highest level, 2 is
// more refined (and therefore usually not printed), etc.
std::ostream &traceProgress(int level=1);


// add one or more subsystems, separated by commas
void traceAddMultiSys(char const *systemNames);

// if the first argument is a tracing directive, handle it, modify
// argc and argv modified to effectively remove it, and return true
// (argv[0] is assumed to be ignored by everything); this calls
// 'traceAddFromEnvVar' too
bool traceProcessArg(int &argc, char **&argv);

// so here's a simple loop that will consume any leading
// trace arguments
#define TRACE_ARGS() while (traceProcessArg(argc, argv)) {}


// add tracing flags from the environment variable "TRACE",
// unless 'ignoreTraceEnvVar' is true; this sets it to true,
// so it's idempotent
void traceAddFromEnvVar();
extern bool ignoreTraceEnvVar;    // initially false


#endif // TRACE_H
@h=tangler('elk/sm_trdelete.h')
@select(h)
// trdelete.h            see license.txt for copyright and terms of use
// objects which trash their contents upon deletion
// I would love to have implemented this as a base class and simply derive
//   things from it, but a poor implementation choice by Borland makes this
//   too costly in terms of performance

#ifdef _MSC_VER
  // this module doesn't work under msvc, I don't care to figure out why
  #define TRDELETE_H      // make it omit this file
  #define TRASHINGDELETE  // and all references to it a no-op
#endif

#ifndef TRDELETE_H
#define TRDELETE_H

#include <stddef.h>      // size_t

void trashingDelete(void *blk, size_t size);
void trashingDeleteArr(void *blk, size_t size);

// to use, include the TRASHINGDELETE macro in the public section of a class

#define TRASHINGDELETE                                                              \
  void operator delete(void *blk, size_t size) { trashingDelete(blk, size); }       \
  void operator delete[](void *blk, size_t size) { trashingDeleteArr(blk, size); }

#endif // TRDELETE_H
@h=tangler('elk/sm_typ.h')
@select(h)
// typ.h            see license.txt for copyright and terms of use
// various types and definitions, some for portability, others for convenience
// Scott McPeak, 1996-2000  This file is public domain.

#ifndef __TYP_H
#define __TYP_H

// js: this crud is required to provide an integer type
// to which a void* can be cast so the result can be
// input to a hashing function

#include "../rtl/flx_rtl_config.hpp"
typedef FLX_RAWADDRESS SM_RAWADDRESS;

// byte
typedef unsigned char byte;
typedef signed char signed_byte;


// int32 used to be here, but defined nonportably, and I don't use
// it anyway, so I ripped it out


// NULL
#ifndef NULL
#  define NULL 0
#endif // NULL


// bool
#ifdef LACKS_BOOL
  typedef int bool;
  bool const false=0;
  bool const true=1;
#endif // LACKS_BOOL


// min, max
#undef min
#undef max
       
template <class T>
inline T min(T const &a, T const &b)
{
  return a<b? a:b;
}

template <class T>
inline T max(T const &a, T const &b)
{
  return a>b? a:b;
}


#if 0   // old
  #ifndef __MINMAX_DEFINED
  # ifndef min
  #  define min(a,b) ((a)<(b)?(a):(b))
  # endif
  # ifndef max
  #  define max(a,b) ((a)>(b)?(a):(b))
  # endif
  # define __MINMAX_DEFINED
  #endif // __MINMAX_DEFINED
#endif // 0


// tag for definitions of static member functions; there is no
// compiler in existence for which this is useful, but I like
// to see *something* next to implementations of static members
// saying that they are static, and this seems slightly more
// formal than just a comment
#define STATICDEF /*static*/


// often-useful number-of-entries function
#define TABLESIZE(tbl) ((int)(sizeof(tbl)/sizeof((tbl)[0])))


// concise way to loop on an integer range
#define loopi(end) for(int i=0; i<(int)(end); i++)
#define loopj(end) for(int j=0; j<(int)(end); j++)
#define loopk(end) for(int k=0; k<(int)(end); k++)


// for using selfCheck methods
// to explicitly check invariants in debug mode
//
// dsw: debugging *weakly* implies selfchecking: if we are debugging,
// do selfcheck unless otherwise specified
#ifndef NDEBUG
  #ifndef DO_SELFCHECK
    #define DO_SELFCHECK 1
  #endif
#endif
// dsw: selfcheck *bidirectionally* configurable from the command line: it
// may be turned on *or* off: any definition other than '0' counts as
// true, such as -DDO_SELFCHECK=1 or just -DDO_SELFCHECK
#ifndef DO_SELFCHECK
  #define DO_SELFCHECK 0
#endif
#if DO_SELFCHECK != 0
  #define SELFCHECK() selfCheck()
#else
  #define SELFCHECK() ((void)0)
#endif


// division with rounding towards +inf
// (when operands are positive)
template <class T>
inline T div_up(T const &x, T const &y)
{ return (x + y - 1) / y; }


// mutable
#ifdef __BORLANDC__
#  define MUTABLE
#  define EXPLICIT
#else
#  define MUTABLE mutable
#  define EXPLICIT explicit
#endif


#define SWAP(a,b) \
  temp = a;       \
  a = b;          \
  b = temp /*user supplies semicolon*/

  
// verify something is true at compile time (will produce
// a compile error if it isn't)
// update: use STATIC_ASSERT defined in macros.h instead
//#define staticAssert(cond) extern int dummyArray[cond? 1 : 0]


#endif // __TYP_H

@h=tangler('elk/sm_unixutil.h')
@select(h)
// unixutil.h            see license.txt for copyright and terms of use
// some utilities on top of unix functions

#ifndef UNIXUTIL_H
#define UNIXUTIL_H

#ifdef __cplusplus
extern "C" {
#endif

// write entire contents of buffer to 'fd', returning 0 on failure
int writeAll(int fd, void const *buf, int len);
                                           
// read(2) some data into a buffer of 'len' bytes; null-terminate
// those bytes, and strip any trailing newline; return 0 on failure
int readString(int fd, char *str, int len);

// test if there are bytes available to be read from a file descriptor,
// returning nonzero if so

#if 0
int canRead(int fd);
#endif

#ifdef __cplusplus
}
#endif

#endif // UNIXUTIL_H
@h=tangler('elk/sm_vdtllist.h')
@select(h)
// vdtllist.h            see license.txt for copyright and terms of use
// list of void*, with a pointer maintained to the last (tail)
// element, for constant-time append

#ifndef VDTLLIST_H
#define VDTLLIST_H

#include "sm_voidlist.h"

// inherit privately so I can choose what to expose
class VoidTailList : private VoidList {
private:
  // by making this a friend, it should see VoidList as a
  // base class, and thus simply work
  // but it doesn't..
  //friend VoidListIter;

  friend class VoidTailListIter;

  // no mutator for now

protected:
  VoidNode *tail;       // (serf) last element of list, or NULL if list is empty
  VoidNode *getTop() const { return VoidList::getTop(); }

private:
  VoidTailList(VoidTailList const &obj);    // not allowed

  void adjustTail();

public:
  VoidTailList()                     { tail = NULL; }
  ~VoidTailList()                    {}
  
  // special ctor which steals the list and then deallocates the header
  VoidTailList(VoidTailList *src)    { tail = NULL; steal(src); }
  void steal(VoidTailList *src);     // deletes 'src'

  // this syntax just makes the implementation inherited from
  // 'VoidList' public, whereas it would default to private,
  // since it was inherited privately
  VoidList::count;

  // see voidlist.h for documentation of each of these functions
  VoidList::isEmpty;
  VoidList::isNotEmpty;
  VoidList::nth;
  VoidList::first;
  void *last() const                 { xassert(tail); return tail->data; }

  // insertion
  void prepend(void *newitem);
  void append(void *newitem);
  void insertAt(void *newitem, int index);
  void concat(VoidTailList &tail);

  // removal
  void *removeFirst();               // remove first, return data; must exist
  void *removeLast();
  void *removeAt(int index);
  void removeAll();
  VoidList::removeItem;

  // list-as-set: selectors
  VoidList::indexOf;
  VoidList::indexOfF;
  VoidList::contains;

  // list-as-set: mutators
  bool prependUnique(void *newitem);
  bool appendUnique(void *newitem);
  //void removeItem(void *item);
  //bool removeIfPresent(void *item);

  // debugging
  void selfCheck() const;
  VoidList::debugPrint;
};


// copied from voidlist.h because g++ won't do what I want..
class VoidTailListIter {
protected:
  VoidNode *p;                        // (serf) current item

public:
  VoidTailListIter(VoidTailList const &list)  { reset(list); }
  ~VoidTailListIter()                         {}

  void reset(VoidTailList const &list)        { p = list.getTop(); }

  // iterator copying; generally safe
  VoidTailListIter(VoidTailListIter const &obj)             { p = obj.p; }
  VoidTailListIter& operator=(VoidTailListIter const &obj)  { p = obj.p; return *this; }

  // but copying from a mutator is less safe; see above
  //VoidTailListIter(VoidListMutator &obj)      { p = obj.current; }

  // iterator actions
  bool isDone() const                         { return p == NULL; }
  void adv()                                  { p = p->next; }
  void *data() const                          { return p->data; }
  
  // iterator mutation; use with caution
  void setDataLink(void *newData)             { p->data = newData; }
};



#endif // VDTLLIST_H
@h=tangler('elk/sm_voidlist.h')
@select(h)
// voidlist.h            see license.txt for copyright and terms of use
// list of void*

// Author: Scott McPeak, 2000

#ifndef __VOIDLIST_H
#define __VOIDLIST_H

#include "sm_xassert.h"
#include "sm_typ.h"
#include "sm_trdelete.h"

// -------------------------- non-typesafe core -----------------------------
// non-typesafe list node
class VoidNode {
public:
  TRASHINGDELETE

  VoidNode *next;           // (owner) next item in list, or NULL if last item
  void *data;               // whatever it is the list is holding

  VoidNode(void *aData=NULL, VoidNode *aNext=NULL) { data=aData; next=aNext; }
};


// forward decls for 'friend' decls
class VoidListIter;
class VoidListMutator;


// The difference function should return <0 if left should come before
// right, 0 if they are equivalent, and >0 if right should come before
// left.  For example, if we are sorting numbers into ascending order,
// then 'diff' could simply be subtraction.
typedef int (*VoidDiff)(void *left, void *right, void *extra);


// list of void*; at this level, the void* are completely opaque;
// the list won't attempt to delete(), compare them, or anything else
// (well, some comparison has creeped in now... but only via VoidDiff)
class VoidList {
private:
  friend class VoidListIter;
  friend class VoidListMutator;

protected:
  VoidNode *top;                     // (owner) first node, or NULL if list is empty
  VoidNode *getTop() const { return top; } // for iterator, below

public:
  VoidList()                         { top=NULL; }
  VoidList(VoidList const &obj);     // makes a (shallow) copy of the contents
  ~VoidList()                        { removeAll(); }

  // selectors
  int count() const;                 // # of items in list
  bool isEmpty() const               { return top == NULL; }
  bool isNotEmpty() const            { return top != NULL; }
  void *nth(int which) const;        // get particular item, 0 is first (item must exist)
  void *first() const { return nth(0); }
  void *last() const { return nth(count()-1); }

  // insertion
  void prepend(void *newitem);       // insert at front
  void append(void *newitem);        // insert at rear
  void insertAt(void *newitem, int index);
    // new item is inserted such that its index becomdes 'index'
  void insertSorted(void *newitem, VoidDiff diff, void *extra=NULL);
    // insert into an already-sorted list so that the list is sorted afterwards

  // removal
  void *removeAt(int index);         // remove from list (must exist), and return removed item
  void *removeFirst()                { return removeAt(0); }
  void removeAll();

  // list-as-set: selectors
  int indexOf(void *item) const;     // returns index of *first* occurrance, or -1 if not present
  int indexOfF(void *item) const;    // same as indexOf, but throws exception if not present
  bool contains(void *item) const    // true if the item appears in the list
    { return indexOf(item) >= 0; }

  // list-as-set: mutators
  bool prependUnique(void *newitem); // prepend only if not already there
  bool appendUnique(void *newitem);  // append   "            "
  void removeItem(void *item);       // remove first occurrance -- must exist
  bool removeIfPresent(void *item);  // remove first occurrance; return true if changed

  // complex modifiers
  void reverse();
  void insertionSort(VoidDiff diff, void *extra=NULL);
  void mergeSort(VoidDiff diff, void *extra=NULL);

  // and a related test
  bool isSorted(VoidDiff diff, void *extra=NULL) const;

  // multiple lists
  void concat(VoidList &tail);           // tail is emptied, nodes appended to this
  void appendAll(VoidList const &tail);  // tail is untouched.. but its contents are now exposed to non-constness... ug... oh well
  VoidList& operator= (VoidList const &src);  // afterwards, 'this' and 'src' have same contents

  // steal (become the container for) the tail of a source list at any
  // point; if 'index' is 0, the entire 'source' is stolen (i.e.
  // index=0 is equivalent to 'concat', above); stolen items appended
  // to 'this'
  void stealTailAt(int index, VoidList &source);

  // equal items in equal positions
  bool equalAsLists(VoidList const &otherList, VoidDiff diff, void *extra=NULL) const;
  
  // if equal, returns 0; otherwise, return order (-1/+1) according to
  // the first differing pair of elements; a shorter (but otherwise
  // idential list) will compare as being less
  int compareAsLists(VoidList const &otherList, VoidDiff diff, void *extra=NULL) const;

  // last-as-set: comparisons (NOT efficient)
  bool equalAsSets(VoidList const &otherList, VoidDiff diff, void *extra=NULL) const;
    // A subset of B, and vice-versa
  bool isSubsetOf(VoidList const &otherList, VoidDiff diff, void *extra=NULL) const;
    // uses slow elementwise containment
  bool containsByDiff(void *item, VoidDiff diff, void *extra=NULL) const;

  // treating the pointer values themselves as the basis for comparison
  static int pointerAddressDiff(void *left, void *right, void*);
  bool equalAsPointerLists(VoidList const &otherList) const
    { return equalAsLists(otherList, pointerAddressDiff); }
  bool equalAsPointerSets(VoidList const &otherList) const
    { return equalAsSets(otherList, pointerAddressDiff); }

  // debugging
  void selfCheck() const;            // test this list; fail assertion if malformed
  void debugPrint() const;           // print list contents to stdout
  void checkHeapDataPtrs() const;    // fail assertion if any 'data' ptr isn't valid heap ptr
  void checkUniqueDataPtrs() const;  // fail assertion if any 'data' ptr matches any other in this list
};


// for traversing the list and modifying it
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists, and only one such iterator should exist for
//       any given list
class VoidListMutator {
  friend class VoidListIter;

protected:
  VoidList &list;         // underlying list
  VoidNode *prev;         // (serf) previous node; NULL if at list's head
  VoidNode *current;      // (serf) node we're considered to be pointing at

public:
  VoidListMutator(VoidList &lst)   : list(lst) { reset(); }
  ~VoidListMutator()               {}

  void reset()                     { prev = NULL;  current = list.top; }

  // iterator copying; safe *only* until one of the mutators modifies
  // the list structure (by inserting or removing), at which time all
  // other iterators might be in limbo
  VoidListMutator(VoidListMutator const &obj)
    : list(obj.list), prev(obj.prev), current(obj.current) {}
  VoidListMutator& operator=(VoidListMutator const &obj);
    // requires that 'this' and 'obj' already refer to the same 'list'

  // iterator actions
  bool isDone() const              { return current == NULL; }
  void adv()                       { prev = current;  current = current->next; }
  void *data()                     { return current->data; }
  void *&dataRef()                 { return current->data; }

  // insertion
  void insertBefore(void *item);
    // 'item' becomes the new 'current', and the current 'current' is
    // pushed forward (so the next adv() will make it current again)

  void insertAfter(void *item);
    // 'item' becomes what we reach with the next adv();
    // isDone() must be false

  void append(void *item);
    // only valid while isDone() is true, it inserts 'item' at the end of
    // the list, and advances such that isDone() remains true; equivalent
    // to { xassert(isDone()); insertBefore(item); adv(); }

  // removal
  void *remove();
    // 'current' is removed from the list and returned, and whatever was
    // next becomes the new 'current'

  // debugging
  void selfCheck() const
    { xassert((prev->next == current  &&  current != list.top) ||
              (prev==NULL && current==list.top)); }
};


// for traversing the list without modifying it
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists
class VoidListIter {
protected:
  VoidNode *p;                        // (serf) current item

public:
  VoidListIter(VoidList const &list)  { reset(list); }
  VoidListIter(VoidList const &list, int pos);    // advance 'pos' times
  ~VoidListIter()                     {}

  void reset(VoidList const &list)    { p = list.getTop(); }

  // iterator copying; generally safe
  VoidListIter(VoidListIter const &obj)             { p = obj.p; }
  VoidListIter& operator=(VoidListIter const &obj)  { p = obj.p;  return *this; }

  // but copying from a mutator is less safe; see above
  VoidListIter(VoidListMutator &obj)  { p = obj.current; }

  // iterator actions
  bool isDone() const                 { return p == NULL; }
  void adv()                          { p = p->next; }
  void *data() const                  { return p->data; }
};


#endif // __VOIDLIST_H
@h=tangler('elk/sm_vptrmap.h')
@select(h)
// vptrmap.h
// map from void* to void*
// interface based partly on hashtbl.h

// Design considerations:
//
// Keys are pointers to objects.  They are likely to have the same
// high bits (page) and low bits (alignment), and thus be
// distinguished primarily by the bits in the middle.  No key is NULL.
//
// Deletion of a single mapping is not supported.  To delete some
// mappings you have to rebuild the table.
//
// No adversary is present; hash function is fixed in advance.


#ifndef VPTRMAP_H
#define VPTRMAP_H


class VoidPtrMap {
private:     // types
  // single entry in the hash table
  struct Entry {
    void *key;               // NULL only for unused entries
    void *value;             // NULL if key is NULL
  };

private:     // data
  // hash table itself; collision is resolved with double hashing,
  // which is why efficient deletion is impossible
  Entry *hashTable;

  // number of (allocated) slots in the hash table; this is always a
  // power of 2
  int tableSize;
  
  // tableSize always equals 1 << tableSizeBits
  int tableSizeBits;

  // number of mappings (i.e. key!=NULL); always numEntries < tableSize
  int numEntries;

  // number of outstanding iterators; used to check that we don't
  // modify the table while one is active (experimental)
  mutable int iterators;

public:      // data
  // total # of lookups
  static int lookups;
  
  // total # of entries examined during lookups; perfect hashing
  // would yield lookups==probes
  static int probes;

private:     // funcs
  // 'bits' becomes tableSizeBits; also set hashTable and tableSize
  void alloc(int bits);

  // multiplicative hash function
  inline unsigned hashFunc(unsigned multiplier, unsigned key) const;

  // return the first entry in key's probe sequence that has either
  // a NULL key or a key equal to 'key'
  Entry &findEntry(void const *key) const;

  // make the table twice as big, and move all the entries into
  // that new table
  void expand();

  // disallowed
  VoidPtrMap(VoidPtrMap &obj);
  void operator=(VoidPtrMap &obj);
  void operator==(VoidPtrMap &obj);

public:      // funcs
  VoidPtrMap();              // empty map
  ~VoidPtrMap();

  // return # of mapped entries
  int getNumEntries() const { return numEntries; }

  // if this key has a mapping, return it; otherwise, return NULL
  void *get(void const *key) const { return findEntry(key).value; }

  // add a mapping from 'key' to 'value'; replaces existing
  // mapping, if any
  void add(void *key, void *value);

  // remove all mappings
  void empty();
  
  
public:      // iterators
  // iterate over all stored values in a VoidPtrMap
  // NOTE: you can't change the table while an iter exists
  class Iter {
  private:      // data
    VoidPtrMap const &map;       // table we're iterating over
    int index;                   // current slot to return in adv(); -1 when done

  public:       // funcs
    Iter(VoidPtrMap const &map);
    ~Iter();

    bool isDone() const { return index < 0; }
    void adv();            // must not be isDone()

    // return information about the currently-referenced table entry
    void *key() const      // key (never NULL)
      { return map.hashTable[index].key; }
    void *value() const    // associated value
      { return map.hashTable[index].value; }
  };
  friend class Iter;
};


#endif // VPTRMAP_H
@h=tangler('elk/sm_warn.h')
@select(h)
// warn.h            see license.txt for copyright and terms of use
// module to facilitate providing operational warnings to the user
// Scott McPeak, 1999  This file is public domain.

#ifndef __WARN_H
#define __WARN_H

// note: In retrospect, this module was either a bad idea, or I didn't
//       implement it well.  Either way, don't use it for anything new.

// non-disjoint warning classification scheme
// (add more classes as necessary)
enum WarnLevel {
  WARN_PERFORMANCE     = 0x01,
    // may cause suboptimal performance

  WARN_SECURITY        = 0x02,
    // possible compromise of private data, unauthrorized
    // access, authentication warning, etc.

  WARN_COMPATIBILITY   = 0x04,
    // interoperability with other software (including
    // different versions of this software) may be
    // adversely affected

  WARN_DEBUG           = 0x08,
    // of use during debugging only; setting this flag means
    // the warning handler should alert an attached debugger

  WARN_INFORMATION     = 0x10,
    // I'm not sure when/why this would be used...
    // Note: This is *not* to be used as a diagnostic 'printf'. 

  WARN_ALL             = 0x1F,
    // logical-or of all flags

  WARN_NONE            = 0x0,
    // no warnings
};


// user interface
// --------------
// call this to report a warning
//   level   - logical-or of applicable conditions
//   message - user-intelligible message (should *not* contain a newline)
void warning(WarnLevel level, char const *message);


// handler interface
// -----------------
// the warning() function calls warningHandler(), so new
// handlers are installed by changing that value
typedef void (*WarningHandler)(WarnLevel level, char const *message);
extern WarningHandler warningHandler;


// default handler
// ---------------
// the default warning handler masks the input level with two
// global variables:
//   logWarnLevel - messages are written to a log file, "warning.log"
//   displayWarnLevel - messages are written to stderr via stdio 'stderr'
extern WarnLevel logWarnLevel;       // default: WARN_ALL, minus WARN_DEBUG ifdef NDEBUG
extern WarnLevel displayWarnLevel;   // default: ifdef NDEBUG, WARN_NONE, else WARN_ALL

// handler functions (handler dispatches to logger and printer)
void defaultWarningHandler(WarnLevel level, char const *message);
void defaultWarningLogger(WarnLevel level, char const *message);
void defaultWarningPrinter(WarnLevel level, char const *message);


#endif // __WARN_H

@h=tangler('elk/sm_xassert.h')
@select(h)
// xassert.h            see license.txt for copyright and terms of use
// replacement for assert that throws an exception on failure
// (x_assert_fail is defined in exc.cpp)
// Scott McPeak, 1997-1998  This file is public domain.

#ifndef XASSERT_H
#define XASSERT_H

#include "sm_macros.h"

// linkdepend: exc.cpp

void x_assert_fail(char const *cond, char const *file, int line) NORETURN;

// Ordinary 'xassert' *can* be turned off, but the nominal intent
// is that it be left on, under the "ship what you test" theory.
// I advocate using NDEBUG_NO_ASSERTIONS only as a way to gauge the
// performance impact of the existing assertions.
#if !defined(NDEBUG_NO_ASSERTIONS)
  #define xassert(cond) \
    ((cond)? (void)0 : x_assert_fail(#cond, __FILE__, __LINE__))
#else
  #define xassert(cond) ((void)0)
#endif

// Here's a version which will turn off with ordinary NDEBUG.  It
// is for more expensive checks that need not ship.
#if !defined(NDEBUG)
  #define xassertdb(cond) xassert(cond)
#else
  #define xassertdb(cond) ((void)0)
#endif

// call when state is known to be bad; will *not* return
#define xfailure(why) x_assert_fail(why, __FILE__, __LINE__)


// Quick note: one prominent book on writing code recommends that
// assertions *not* include the failure condition, since the file
// and line number are sufficient, and the condition sm_string uses
// memory.  The problem is that sometimes a compiled binary is
// out of date w/respect to the code, and line numbers move, so
// the condition sm_string provides a good way to find the right
// assertion.


/*
  Why throw an exception after an assertion?
  
  The standard assert() calls abort() after printing its message.
  This is like throwing an exception all the way to the calling
  process.  This is fine if programs are small.

  But when a program is large enough, it may contain subsystems at
  several layers, such that a higher level module is capable of
  recovering from the failure of a lower level module.  Using abort(),
  one would have to resort to catching signals, which is messy.

  An exception is much nicer to catch, and has the added benefit that
  intermediate layers can catch and rethrow, appending little bits of
  context, if they want to make the message more informative.

  In most of my programs, the 'x_assert' exception is only caught in
  main() (implicitly, by catching 'xBase'), and hence 'xassert' acts
  very much like 'assert'.  But by using 'xassert' consistenty, any
  time I *do* have a large program with recovery, all the lower-level
  modules are all ready to cooperate.
  
  Speaking of recovery: Be aware that when a module fails an
  assertion, its internal state is most likely inconsistent.  Recovery
  actions need to be fairly conservative about what code gets
  re-entered and state re-used after a failure.  This is no different
  than with 'assert', as a program could have inconsistent state *on
  disk* that gets reactivated upon being restarted, but persistent
  (across process boundaries) inconsistent state is simply less
  common.

*/

#endif // XASSERT_H

@h=tangler('elk/sm_xobjlist.h')
@select(h)
m4_dnl // xobjlist.h            see license.txt for copyright and terms of use
m4_dnl // template file to be processed with m4 to generate one
m4_dnl // of the wrappers around VoidList
m4_dnl
m4_changequote([, ])m4_dnl      // for this section
m4_changecom[]m4_dnl            // no m4 "comments"
m4_ifelse(m4_output, sobjlist.h, [m4_dnl
// sobjlist.h
// serf list of arbitrary objects
m4_define(makeName, S[$1])m4_dnl
m4_define(outputCond, [$1])m4_dnl       // select 1st arg
m4_define(SPC, [])m4_dnl
], [m4_dnl
// objlist.h
// owner list of arbitrary dynamically-allocated objects
m4_define(makeName, [$1])m4_dnl
m4_define(outputCond, [$2])m4_dnl       // select 2nd arg
m4_define(SPC, [ ])m4_dnl               // for balancing lined-up comments
])m4_dnl
m4_define(includeLatch, makeName(OBJLIST_H))m4_dnl
m4_define(className, makeName(ObjList))m4_dnl
m4_define(iterName, makeName(ObjListIter))m4_dnl
m4_define(mutatorName, makeName(ObjListMutator))m4_dnl
m4_define(iterNameNC, makeName(ObjListIterNC))m4_dnl
m4_define(multiIterName, makeName(ObjListMultiIter))m4_dnl
m4_changequote(, )m4_dnl              // so quotes are not quoted..
m4_changequote([[[, ]]])m4_dnl        // reduce likelihood of confusion
// NOTE: automatically generated from xobjlist.h -- do not edit directly

// Author: Scott McPeak, 2000

#ifndef includeLatch
#define includeLatch

#include "sm_voidlist.h"


// forward declarations of template classes, so we can befriend them in className
// (not required by Borland C++ 4.5, but GNU wants it...)
template <class T> class iterName;
template <class T> class mutatorName;
template <class T> class iterNameNC;


outputCond([[[m4_dnl      // sobjlist
// the list is considered to not own any of the items; it's ok to
// insert items multiple times or into multiple lists
]]], [[[m4_dnl            // objlist
// the list is considered to own all of the items; it is an error to insert
// an item into more than one such list, or to insert an item more than once
// into any such list
]]])m4_dnl
template <class T>
class className {
private:
  friend class iterName<T>;
  friend class mutatorName<T>;
  friend class iterNameNC<T>;

protected:
  VoidList list;                        // list itself

outputCond([[[m4_dnl    // sobjlist
public:
  // make shallow copies
  className[[[]]](className const &obj)         : list(obj.list) {}
  className& operator= (className const &src)         { list = src.list; return *this; }
]]], [[[m4_dnl          // objlist
private:
  // this is an owner list; these are not allowed
  className[[[]]](className const &obj);
  className& operator= (className const &src);
]]])m4_dnl

public:
  className[[[]]]()                            : list() {}
  ~className[[[]]]()                      m4_dnl
     outputCond({}    /* all items removed */, { deleteAll(); })

  // The difference function should return <0 if left should come before
  // right, 0 if they are equivalent, and >0 if right should come before
  // left.  For example, if we are sorting numbers into ascending order,
  // then 'diff' would simply be subtraction.
  typedef int (*Diff)(T const *left, T const *right, void *extra);

  // selectors
  int count() const                     { return list.count(); }
  bool isEmpty() const                  { return list.isEmpty(); }
  bool isNotEmpty() const               { return list.isNotEmpty(); }
  T *nth(int which)                     { return (T*)list.nth(which); }
  T const *nthC(int which) const        { return (T const*)list.nth(which); }
  T *first()                            { return (T*)list.first(); }
  T const *firstC() const               { return (T const*)list.first(); }
  T *last()                             { return (T*)list.last(); }
  T const *lastC() const                { return (T const*)list.last(); }

  // insertion
  void prepend(T *newitem)              { list.prepend((void*)newitem); }
  void append(T *newitem)               { list.append((void*)newitem); }
  void insertAt(T *newitem, int index)  { list.insertAt((void*)newitem, index); }
  void insertSorted(T *newitem, Diff diff, void *extra=NULL)
    { list.insertSorted((void*)newitem, (VoidDiff)diff, extra); }

  // removal
  T *removeAt(int index)                { return (T*)list.removeAt(index); }
  T *removeFirst()                      { return (T*)list.removeFirst(); }
outputCond([[[m4_dnl     // sobjlist
  void removeAll()                      { list.removeAll(); }
]]], [[[m4_dnl           // objlist
  void deleteAt(int index)              { delete (T*)list.removeAt(index); }
  void deleteAll();
]]])m4_dnl

  // list-as-set: selectors
  int indexOf(T const *item) const      { return list.indexOf((void*)item); }
  int indexOfF(void *item) const        { return list.indexOfF((void*)item); }
  bool contains(T const *item) const    { return list.contains((void*)item); }

  // list-as-set: mutators
  bool prependUnique(T *newitem)        { return list.prependUnique((void*)newitem); }
  bool appendUnique(T *newitem)         { return list.appendUnique((void*)newitem); }
  void removeItem(T const *item)        { list.removeItem((void*)item); }    // whether the arg should be const is debatable..
  bool removeIfPresent(T const *item)   { return list.removeIfPresent((void*)item); }

  // complex modifiers
  void reverse()                                    { list.reverse(); }
  void insertionSort(Diff diff, void *extra=NULL)   { list.insertionSort((VoidDiff)diff, extra); }
  void mergeSort(Diff diff, void *extra=NULL)       { list.mergeSort((VoidDiff)diff, extra); }

  // and a related test
  bool isSorted(Diff diff, void *extra=NULL) const  { return list.isSorted((VoidDiff)diff, extra); }

  // multiple lists
  void concat(className &tail)                       { list.concat(tail.list); }
outputCond([[[m4_dnl    // sobjlist
  void appendAll(className const &tail)              { list.appendAll(tail.list); }
]]], [[[m4_dnl          // objlist
  // (we do *not* have appendAll, since these are supposed to be owner lists)
]]])m4_dnl

  // steal
  void stealTailAt(int index, className &tail)       { list.stealTailAt(index, tail.list); }

  // equal items in equal positions
  bool equalAsLists(className const &otherList, Diff diff, void *extra=NULL) const
    { return list.equalAsLists(otherList.list, (VoidDiff)diff, extra); }
  int compareAsLists(className const &otherList, Diff diff, void *extra=NULL) const
    { return list.compareAsLists(otherList.list, (VoidDiff)diff, extra); }

  // last-as-set: comparisons (NOT efficient)
  bool equalAsSets(className const &otherList, Diff diff, void *extra=NULL) const
    { return list.equalAsSets(otherList.list, (VoidDiff)diff, extra); }
  bool isSubsetOf(className const &otherList, Diff diff, void *extra=NULL) const
    { return list.isSubsetOf(otherList.list, (VoidDiff)diff, extra); }
  bool containsByDiff(T const *item, Diff diff, void *extra=NULL) const
    { return list.containsByDiff((void*)item, (VoidDiff)diff, extra); }

  // treating the pointer values themselves as the basis for comparison
  bool equalAsPointerLists(className const &otherList) const
    { return list.equalAsPointerLists(otherList.list); }
  bool equalAsPointerSets(className const &otherList) const
    { return list.equalAsPointerSets(otherList.list); }

outputCond([[[m4_dnl    // sobjlist
  // debugging: no invariants beyond VoidList
  void selfCheck() const                { list.selfCheck(); }
  
  // but export the additional checks for cases where they apply anyway
  void checkHeapDataPtrs() const        { list.checkHeapDataPtrs(); }
  void checkUniqueDataPtrs() const      { list.checkUniqueDataPtrs(); }
]]], [[[m4_dnl          // objlist
  // debugging: two additional invariants
  void selfCheck() const { 
    list.selfCheck();
    list.checkHeapDataPtrs();
    list.checkUniqueDataPtrs();
  }
]]])m4_dnl
};


outputCond(, [[[m4_dnl      // objlist
template <class T>
void ObjList<T>::deleteAll()
{
  while (!list.isEmpty()) {
    deleteAt(0);
  }
}


]]])m4_dnl
// for traversing the list and modifying it (nodes and/or structure)
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists, and only one such iterator should exist for
//       any given list
template <class T>
class mutatorName {
  friend class iterName<T>;

protected:
  VoidListMutator mut;       // underlying mutator

public:
  mutatorName[[[]]](className<T> &lst)     : mut(lst.list) { reset(); }
  ~mutatorName[[[]]]()                    {}

  void reset()                          { mut.reset(); }

  // iterator copying; safe *only* until one of the mutators modifies
  // the list structure (by inserting or removing), at which time all
  // other iterators might be in limbo
  mutatorName[[[]]](mutatorName const &obj)             : mut(obj.mut) {}
  mutatorName& operator=(mutatorName const &obj)  { mut = obj.mut;  return *this; }
    // requires that 'this' and 'obj' already refer to the same 'list'

  // iterator actions
  bool isDone() const                   { return mut.isDone(); }
  void adv()                            { mut.adv(); }
  T *data()                             { return (T*)mut.data(); }
  T *&dataRef()                         { return (T*&)mut.dataRef(); }

  // insertion
  void insertBefore(T *item)            { mut.insertBefore((void*)item); }
    // 'item' becomes the new 'current', and the current 'current' is
    // pushed forward (so the next adv() will make it current again)

  void insertAfter(T *item)             { mut.insertAfter((void*)item); }
    // 'item' becomes what we reach with the next adv();
    // isDone() must be false

  void append(T *item)                  { mut.append((void*)item); }
    // only valid while isDone() is true, it inserts 'item' at the end of
    // the list, and advances such that isDone() remains true; equivalent
    // to { xassert(isDone()); insertBefore(item); adv(); }

  // removal
  T *remove()                           { return (T*)mut.remove(); }
    // 'current' is removed from the list and returned, and whatever was
    // next becomes the new 'current'

outputCond(, [[[m4_dnl    // sobjlist
  void deleteIt()                       { delete (T*)mut.remove(); }
    // same as remove(), except item is deleted also

]]])m4_dnl
  // debugging
  void selfCheck() const                { mut.selfCheck(); }
};

#define makeName(MUTATE_EACH_OBJLIST)(T, list, iter) \
  for(mutatorName< T > iter(list); !iter.isDone(); iter.adv())


// for traversing the list without modifying it (neither nodes nor structure)
// NOTE: no list-modification fns should be called on 'list' while this
//       iterator exists
template <class T>
class iterName {
protected:
  VoidListIter iter;      // underlying iterator

public:
  iterName[[[]]](className<T> const &list) : iter(list.list) {}
  iterName[[[]]](className<T> const &list, int pos) : iter(list.list, pos) {}
  ~iterName[[[]]]()                       {}

  void reset(className<T> const &list)   { iter.reset(list.list); }

  // iterator copying; generally safe
  iterName[[[]]](iterName const &obj)             : iter(obj.iter) {}
  iterName& operator=(iterName const &obj)  { iter = obj.iter;  return *this; }

  // but copying from a mutator is less safe; see above
  iterName[[[]]](mutatorName<T> &obj)             : iter(obj.mut) {}

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T const *data() const                 { return (T const*)iter.data(); }
};

#define makeName(FOREACH_OBJLIST)(T, list, iter) \
  for(iterName< T > iter(list); !iter.isDone(); iter.adv())


// intermediate to the above two, this allows modification of the
// objects stored on the list, but not the identity or order of
// the objects in the list
template <class T>
class iterNameNC {
protected:
  VoidListIter iter;      // underlying iterator

public:
  iterNameNC[[[]]](className<T> &list) : iter(list.list) {}
  iterNameNC[[[]]](className<T> &list, int pos) : iter(list.list, pos) {}
  ~iterNameNC[[[]]]()                     {}

  void reset(className<T> &list)         { iter.reset(list.list); }

  // iterator copying; generally safe
  iterNameNC[[[]]](iterNameNC const &obj)             : iter(obj.iter) {}
  iterNameNC& operator=(iterNameNC const &obj)  { iter = obj.iter;  return *this; }

  // but copying from a mutator is less safe; see above
  iterNameNC[[[]]](mutatorName<T> &obj)               : iter(obj.mut) {}

  // iterator actions
  bool isDone() const                   { return iter.isDone(); }
  void adv()                            { iter.adv(); }
  T *data() const                       { return (T*)iter.data(); }
};

#define makeName(FOREACH_OBJLIST_NC)(T, list, iter) \
  for(iterNameNC< T > iter(list); !iter.isDone(); iter.adv())


// iterate over the combined elements of two or more lists
template <class T>
class multiIterName {
private:
  // all the lists
  className<T> **lists;               SPC// serf array of serf list pointers
  int numLists;                      // length of this array

  // current element
  int curList;                       // which list we're working on
  iterName<T> iter;              SPC// current element of that list

  // invariant:
  //   either curList==numLists, or
  //   iter is not 'done'

public:
  multiIterName[[[]]](className<T> **L, int n)
    : lists(L),
      numLists(n),
      curList(0),
      iter(*(lists[0]))
  {
    xassert(n > 0);
    normalize();
  }

  // advance the iterator to the next element of the next non-empty list;
  // establishes invariant above
  void normalize();

  bool isDone() const {
    return curList == numLists;
  }

  T const *data() const {
    return iter.data();
  }

  void adv() {
    iter.adv();
    normalize();
  }
};

// this was originally inline, but that was causing some strange
// problems (compiler bug?)
template <class T>
void multiIterName<T>::normalize()
{
  while (iter.isDone() && curList < numLists) {
    curList++;
    if (curList < numLists) {
      iter.reset(*(lists[curList]));
    }
  }
}


#endif // includeLatch
@h=tangler('elk/sm_autofile.cpp')
@select(h)
// autofile.cc            see license.txt for copyright and terms of use
// code for autofile.h

#include "sm_autofile.h"
#include "sm_exc.h"


FILE *xfopen(char const *fname, char const *mode)
{
  FILE *ret = fopen(fname, mode);
  if (!ret) {
    throw_XOpen(fname);
  }
  
  return ret;
}


AutoFILE::AutoFILE(char const *fname, char const *mode)
  : AutoFclose(xfopen(fname, mode))
{}

AutoFILE::~AutoFILE()
{
  // ~AutoFclose closes the file
}


// EOF
@h=tangler('elk/sm_bflatten.cpp')
@select(h)
// bflatten.cc            see license.txt for copyright and terms of use
// code for bflatten.h

#include "sm_bflatten.h"
#include "sm_exc.h"
#include "sm_syserr.h"


BFlatten::BFlatten(char const *fname, bool r)
  : readMode(r),
    ownerTable(!r? &BFlatten::getOwnerPtrKeyFn : &BFlatten::getIntNameKeyFn,
               HashTable::lcprngHashFn,
               HashTable::pointerEqualKeyFn),
    nextUniqueName(1)
{
  fp = fopen(fname, readMode? "rb" : "wb");
  if (!fp) {
    throw_XOpen(fname);
  }
}

BFlatten::~BFlatten()
{
  fclose(fp);
}


STATICDEF void const* BFlatten::getOwnerPtrKeyFn(OwnerMapping *data)
{
  return data->ownerPtr;
}

STATICDEF void const* BFlatten::getIntNameKeyFn(OwnerMapping *data)
{ 
  return (void const*)(data->intName);
}


void BFlatten::xferSimple(void *var, unsigned len)
{
  if (writing()) {
    if (fwrite(var, 1, len, fp) < len) {
      xsyserror("fwrite");
    }
  }
  else {
    if (fread(var, 1, len, fp) < len) {
      xsyserror("fread");
    }
  }
}


void BFlatten::noteOwner(void *ownerPtr)
{
  // make a new mapping
  OwnerMapping *map = new OwnerMapping;
  map->ownerPtr = ownerPtr;
  map->intName = nextUniqueName++;

  // add it to the table 
  if (writing()) {
    // index by pointer
    ownerTable.add(ownerPtr, map);
  }
  else {
    // index by int name
    ownerTable.add((void const*)(map->intName), map);
  }
}


void BFlatten::xferSerf(void *&serfPtr, bool nullable)
{
  if (writing()) {
    xassert(nullable || serfPtr!=NULL);
                                       
    if (serfPtr == NULL) {
      // encode as 0; the names start with 1
      writeInt(0);
    }
    else {
      // lookup the mapping
      OwnerMapping *map = ownerTable.get(serfPtr);

      // we must have already written the owner pointer
      xassert(map != NULL);

      // write the int name
      writeInt(map->intName);
    }
  }
  else /*reading*/ {
    // read the int name
    int name = readInt();

    if (name == 0) {      // null
      xassert(nullable);
      serfPtr = NULL;
    }
    else {
      // lookup the mapping
      OwnerMapping *map = ownerTable.get((void const*)name);
      formatAssert(map != NULL);

      // return the pointer
      serfPtr = map->ownerPtr;
    }
  }
}


// ------------------------ test code ---------------------
#ifdef TEST_BFLATTEN

#include "sm_test.h"

void entry()
{                    
  // make up some data
  int x = 9, y = 22;
  sm_string s("foo bar");
  int *px = &x, *py = &y;

  // open a file for writing them
  {
    BFlatten flat("bflat.tmp", false /*reading*/);
    flat.xferInt(x);
    flat.noteOwner(&x);
    s.xfer(flat);
    flat.xferSerf((void*&)px);
    flat.xferInt(y);
    flat.noteOwner(&y);
    flat.xferSerf((void*&)py);
  }

  // place to put the data we read
  int x2, y2;
  sm_string s2;
  int *px2, *py2;

  // read them back
  {
    BFlatten flat("bflat.tmp", true /*reading*/);
    flat.xferInt(x2);
    flat.noteOwner(&x2);
    s2.xfer(flat);
    flat.xferSerf((void*&)px2);
    flat.xferInt(y2);
    flat.noteOwner(&y2);
    flat.xferSerf((void*&)py2);
  }

  // compare
  xassert(x == x2);
  xassert(y == y2);
  xassert(s.equals(s2));
  xassert(px2 == &x2);
  xassert(py2 == &y2);

  // delete the temp file
  remove("bflat.tmp");
  
  printf("bflatten works\n");
}


USUAL_MAIN


#endif // TEST_BFLATTEN
@h=tangler('elk/sm_bit2d.cpp')
@select(h)
// bit2d.cc            see license.txt for copyright and terms of use
// code for bit2d.h

#include "sm_bit2d.h"
#include "sm_xassert.h"
#include "sm_flatten.h"

#include <cstring>     // std::memset, std::memcpy
#include <stdio.h>      // printf


Bit2d::Bit2d(point const &aSize)
  : owning(true),
    size(aSize)
{
  xassert(size.x > 0 && size.y > 0);
  stride = (size.x+7)/8;
  data = new byte[datasize()];
}


Bit2d::~Bit2d()
{
  if (owning) {
    delete data;
  }
}


Bit2d::Bit2d(Bit2d const &obj)
{
  size = obj.size;
  stride = obj.stride;
  data = new byte[datasize()];
  owning = true;
  std::memcpy(data, obj.data, datasize());
}


Bit2d& Bit2d::operator= (Bit2d const &obj)
{
  if (this != &obj) {
    xassert(size == obj.size);
    std::memcpy(data, obj.data, datasize());
  }
  return *this;
}


bool Bit2d::operator== (Bit2d const &obj) const
{
  return (size == obj.size) &&
         (0==std::memcmp(data, obj.data, datasize()));
}


Bit2d::Bit2d(Flatten &)
  : data(NULL),
    owning(true)
{}

void Bit2d::xfer(Flatten &flat)
{
  flat.xferInt(size.x);
  flat.xferInt(size.y);
  flat.xferInt(stride);

  flat.xferHeapBuffer((void*&)data, datasize());
}


void Bit2d::setall(int val)
{
  std::memset(data, val? 0xFF : 0, datasize());
}


int Bit2d::get(point const &p) const
{
  xassert(okpt(p));
  return ( *(byteptrc(p)) >> (p.x&7) ) & 1;
}

void Bit2d::set(point const &p)
{
  xassert(okpt(p));
  *(byteptr(p)) |= (byte)  ( 1 << (p.x&7) ) ;
}

void Bit2d::reset(point const &p)
{
  xassert(okpt(p));
  *(byteptr(p)) &= (byte)(~( 1 << (p.x&7) ));
}

void Bit2d::setto(point const &p, int val)
{
  if (val) { set(p); }
  else { reset(p); }
}

int Bit2d::testAndSet(point const &p)
{
  byte *b = byteptr(p);
  int ret = (*b >> (p.x&7)) & 1;
  *b |= (byte)( 1 << (p.x&7) );
  return ret;
}

void Bit2d::toggle(point const &p)
{
  xassert(okpt(p));
  *(byteptr(p)) ^= (byte) ( 1 << (p.x&7) );
}

 
// count the number of digits required to represent a positive
// integer in base 10
static int digits(int value)
{
  xassert(value > 0);
  int ct=0;
  while (value > 0) {
    ct++;
    value /= 10;
  }
  return ct;
}


/*
 * Goal is to draw something like this:
 *
 *       1  2  3
 *  1 [  0  0  0  ]
 *  2 [  0  1  1  ]
 *  3 [  0  1  0  ]
 *
 */
void Bit2d::print() const
{
  // compute column widths
  int rowLabelWidth = digits(size.y-1);
  int colLabelWidth = digits(size.x-1);

  // column legend
  printf("%*s   ", rowLabelWidth, "");
  loopi(size.x) {
    printf("%*d ", colLabelWidth, i);
  }
  printf("\n");

  for (int row=0; row<size.y; row++) {
    printf("%*d [ ", rowLabelWidth, row);
    loopi(size.x) {
      printf("%*s ", colLabelWidth, 
                     get(point(i, row))? "1" : ".");    // "." so easier to see patterns
    }
    printf("]\n");
  }
}


// hack
Bit2d::Bit2d(byte * /*serf*/ d, point const &sz, int str)
  : data(d),
    owning(false),    // since it's a serf ptr
    size(sz),
    stride(str)
{}



// ------------------------ test code ------------------------
#ifdef TEST_BIT2D

#include "sm_bflatten.h"

int main()
{
  Bit2d bits(point(17,3));
  xassert(bits.okpt(point(16,2)) &&
         !bits.okpt(point(17,3)) &&
         !bits.okpt(point(2,16)));

  bits.setall(0);
  xassert(!bits.testAndSet(point(9,1)));
  xassert(bits.testAndSet(point(9,1)));

  xassert(!bits.testAndSet(point(2,0)));
  xassert(bits.testAndSet(point(2,0)));

  xassert(!bits.testAndSet(point(16,2)));
  xassert(bits.testAndSet(point(16,2)));

  bits.toggle(point(3,2));
  xassert(bits.get(point(3,2)));

  bits.print();

  // test read/write
  Bit2d *another = writeThenRead(bits);
  xassert(*another == bits);
  delete another;

  printf("bit2d works\n");

  return 0;
}

#endif // TEST_BIT2D

@h=tangler('elk/sm_bitarray.cpp')
@select(h)
// bitarray.cc            see license.txt for copyright and terms of use
// code for bitarray.h

#include "sm_bitarray.h"
#include "sm_flatten.h"

#include <cstring>       // std::memset


BitArray::BitArray(int n)
  : numBits(n)
{
  bits = new unsigned char[allocdBytes()];
  clearAll();
}


BitArray::~BitArray()
{
  delete[] bits;
}


BitArray::BitArray(Flatten&)
  : bits(NULL)
{}

void BitArray::xfer(Flatten &flat)
{   
  flat.xferInt(numBits);

  if (flat.reading()) {
    bits = new unsigned char[allocdBytes()];
  }
  flat.xferSimple(bits, allocdBytes());
}


void BitArray::clearAll()
{
  std::memset(bits, 0, allocdBytes());
}

@h=tangler('elk/sm_boxprint.cpp')
@select(h)
// boxprint.cc
// code for boxprint.h

#include "sm_boxprint.h"
#include "sm_strutil.h"

#include <cstring>         // std::strlen


// ----------------------- BPRender ----------------------
BPRender::BPRender()
  : sb(),         // initially empty
    margin(72),   
    curCol(0),
    lineStartText("")
{}

BPRender::~BPRender()
{}


void BPRender::reset()
{
  sb.clear();
  sb << lineStartText;
}


void BPRender::add(char const *text)
{
  int len = std::strlen(text);
  sb << text;
  curCol += len;
}

void BPRender::breakLine(int ind)
{
  sb << "\n" << lineStartText;

  for (int i=0; i < ind; i++) {
    sb << ' ';
  }

  curCol = ind;
}


sm_string BPRender::takeAndRender(BoxPrint &bld)
{
  BPBox* /*owner*/ tree = bld.takeTree();
  tree->render(*this);
  sm_string ret(sb);
  sb.clear();
  delete tree;
  return ret;
}


// ----------------------- BPElement ---------------------
bool BPElement::isBreak() const
{
  return false;
}

BPElement::~BPElement()
{}


// ------------------------- BPText ----------------------
BPText::BPText(char const *t)
  : text(t)
{}

BPText::~BPText()
{}


int BPText::oneLineWidth()
{
  return text.length();
}

void BPText::render(BPRender &mgr)
{
  mgr.add(text);
}


void BPText::debugPrint(std::ostream &os, int /*ind*/) const
{
  os << "text(" << quoted(text) << ")";
}


// ------------------------ BPBreak ---------------------
BPBreak::BPBreak(bool e, int i)
  : enabled(e),
    indent(i)
{}

BPBreak::~BPBreak()
{}

int BPBreak::oneLineWidth()
{
  return 1;
}

void BPBreak::render(BPRender &mgr)
{
  // if we're being asked to render, then this break must not be taken
  mgr.add(" ");
}

bool BPBreak::isBreak() const
{
  return enabled;
}

void BPBreak::debugPrint(std::ostream &os, int /*ind*/) const
{
  os << "break(en=" << (int)enabled << ", ind=" << indent << ")";
}


// ------------------------- BPBox ------------------------
BPBox::BPBox(BPKind k)
  : elts(),      // initially empty
    kind(k)
{
  xassert((unsigned)k < NUM_BPKINDS);
}

BPBox::~BPBox()
{}


int BPBox::oneLineWidth()
{
  int sum = 0;
  FOREACH_ASTLIST_NC(BPElement, elts, iter) {
    sum += iter.data()->oneLineWidth();
  }
  return sum;
}


// this function is the heart of the rendering engine
void BPBox::render(BPRender &mgr)
{
  int startCol = mgr.getCurCol();

  if (kind == BP_vertical ||
      (kind == BP_correlated && oneLineWidth() > mgr.remainder())) {
    // take all of the breaks
    FOREACH_ASTLIST_NC(BPElement, elts, iter) {
      BPElement *elt = iter.data();
      if (elt->isBreak()) {
        startCol += static_cast<BPBreak*>(elt)->indent;
        mgr.breakLine(startCol);
      }
      else {
        elt->render(mgr);
      }
    }
    return;
  }

  if (kind == BP_correlated) {
    // if we got here, we're taking none of the breaks
    FOREACH_ASTLIST_NC(BPElement, elts, iter) {
      BPElement *elt = iter.data();
      elt->render(mgr);
    }
    return;
  }

  xassert(kind == BP_sequence);

  // this cursor points to the next element that has not been rendered
  ASTListIterNC<BPElement> cursor(elts);

  // when not NULL, the cursor has just passed a break, but we haven't
  // actually decided whether to take it or not
  BPBreak *pendingBreak = NULL;

  while (!cursor.isDone()) {
    // is there room for the elements up to the first break?
    int segmentWidth = pendingBreak? 1 : 0;
    ASTListIterNC<BPElement> lookahead(cursor);
    while (!lookahead.isDone() && !lookahead.data()->isBreak()) {
      segmentWidth += lookahead.data()->oneLineWidth();
      lookahead.adv();
    }

    if (pendingBreak && segmentWidth > mgr.remainder()) {
      // take the pending break
      startCol += pendingBreak->indent;
      mgr.breakLine(startCol);
      pendingBreak = NULL;
    }

    // the segment will be put here without a preceding break
    else if (pendingBreak) {
      pendingBreak->render(mgr);
      pendingBreak = NULL;
    }

    xassert(pendingBreak == NULL);

    // render the segment
    while (!cursor.isDone() && !cursor.data()->isBreak()) {
      cursor.data()->render(mgr);
      cursor.adv();
    }

    if (!cursor.isDone()) {
      // we stopped on a break
      pendingBreak = static_cast<BPBreak*>(cursor.data());
      cursor.adv();
    }
  }

  if (pendingBreak) {
    // ended with a break.. strange, but harmless I suppose
    pendingBreak->render(mgr);
  }
}


void BPBox::debugPrint(std::ostream &os, int ind) const
{           
  static char const * const map[] = {
    "vert",
    "seq",
    "corr"
  };

  os << "box(kind=" << map[kind] << ") {\n";
  ind += 2;
  
  FOREACH_ASTLIST(BPElement, elts, iter) {
    for (int i=0; i<ind; i++) {
      os << " ";
    }

    iter.data()->debugPrint(os, ind);
    os << "\n";
  }

  ind -= 2;
  for (int i=0; i<ind; i++) {
    os << " ";
  }
  os << "}";
}


// ------------------------ BoxPrint ----------------------
BPKind const BoxPrint::vert = BP_vertical;
BPKind const BoxPrint::seq  = BP_sequence;
BPKind const BoxPrint::hv   = BP_correlated;
BPKind const BoxPrint::end  = NUM_BPKINDS;


BoxPrint::BoxPrint()
  : boxStack(),
    levelIndent(2)
{         
  // initial vert box
  boxStack.push(new BPBox(BP_vertical));
}

BoxPrint::~BoxPrint()
{}


void BoxPrint::append(BPElement *elt)
{
  box()->elts.append(elt);
}


BoxPrint& BoxPrint::operator<< (int i)
{
  return operator<< (sm_stringc << i);
}

BoxPrint& BoxPrint::operator<< (char const *s)
{
  append(new BPText(s));
  return *this;
}


BoxPrint& BoxPrint::operator<< (BPKind k)
{
  if (k == NUM_BPKINDS) {
    // close current box
    append(boxStack.pop());
  }
  else {
    // open new box
    boxStack.push(new BPBox(k));
  }
  return *this;
}


BoxPrint& BoxPrint::operator<< (Cmd c)
{
  if (c == br || c == sp) {
    append(new BPBreak(c==br /*enabled*/, 0 /*indent*/));
  }
  else {
    append(new BPBreak(true /*enabled*/, c==ind? levelIndent : -levelIndent));
  }
  return *this;
}


BoxPrint& BoxPrint::operator<< (IBreak b)
{
  append(new BPBreak(true /*enabled*/, b.indent /*indent*/));
  return *this;
}


BoxPrint& BoxPrint::operator<< (Op o)
{
  return *this << sp << o.text << br;
}


BPBox* /*owner*/ BoxPrint::takeTree()
{
  // all boxes must be closed
  xassert(boxStack.length() == 1);

  BPBox *ret = boxStack.pop();

  // initialize the box stack again, in case the user wants
  // to build another tree
  boxStack.push(new BPBox(BP_vertical));

  return ret;
}


void BoxPrint::debugPrint(std::ostream &os) const
{                             
  for (int i=0; i < boxStack.length(); i++) {
    os << "----- frame -----\n";
    boxStack[i]->debugPrint(os, 0 /*ind*/);
    os << "\n";
  }
}

void BoxPrint::debugPrintCout() const
{
  debugPrint(std::cout);
}


// ------------------------ test code ----------------------
#ifdef TEST_BOXPRINT

#include <stdlib.h>       // atoi
#include "sm_ckheap.h"

void doit(int argc, char *argv[])
{
  BoxPrint bp;

  bp << "int foo()" << bp.br
     << "{" << bp.ind;

  bp << "printf(" << bp.seq
        << "\"hello there %d!\\n\"," << bp.br
        << "123456789"
     << bp.end << ");" << bp.br;

  bp << "bar(" << bp.seq
        << "1" << bp.op("+")
        << "2" << bp.op("+")
        << "3" << bp.op("+")
        << "4" << bp.op("+")
        << "5" << bp.op("+")
        << "6" << bp.op("+")
        << "7" << bp.op("+")
        << "8" << bp.op("+")
        << "9" << bp.op("+")
        << "10"
     << bp.end << ");" << bp.br;

  bp << "baz(" << bp.seq
        << "\"a really long line that has no optional breaks at all\""
     << bp.end << ");" << bp.br;

  bp << "zoo(" << bp.seq
        << "\"one break is here, but it is very\"," << bp.br
        << "\"far from the start\""
     << bp.end << ");" << bp.br;

  bp << "assert(" << bp.seq
        << bp.seq << "x" << bp.op("=") << "y" << bp.end << bp.op("&&")
        << bp.seq << "z" << bp.op("=") << "w" << bp.end << bp.op("&&")
        << "(" << bp.seq
           << bp.seq << "moron" << bp.op("!=") << "fool" << bp.end << bp.op("||")
           << "taxes->theRich"
        << bp.end << ")"
     << bp.end << ")" << bp.br;

  bp << bp.hv
        << "forall(" << bp.seq
           << "x," << bp.br << "y," << bp.br << "z"
        << bp.end << "). if {" << bp.ind
        << bp.seq << "x" << bp.op("==") << "yooey_more" << bp.end << ";" << bp.br
        << bp.seq << "yowza" << bp.op("!=") << "fooey" << bp.end << ";"
        << bp.und << "} /*==>*/ {" << bp.ind
        << bp.seq << "z(x,y,z)" << bp.op("==") << "3" << bp.end << ";" << bp.br
        << "ay_caramba" << ";"
        << bp.und << "};"
     << bp.end;

  bp << bp.und << "}" << bp.br;

  BPBox *tree = bp.takeTree();

  BPRender ren;
  ren.margin = 30;
  if (argc >= 2) {
    ren.margin = atoi(argv[1]);
  }
  std::cout << "margin: " << ren.margin << "\n";

  tree->render(ren);
  delete tree;

  std::cout << "         1    1    2    2    3    3    4    4    5    5    6    6    7\n";
  std::cout << "1---5----0----5----0----5----0----5----0----5----0----5----0----5----0\n";
  std::cout << ren.takeString();
}

int main(int argc, char *argv[])
{
  doit(argc, argv);
  //malloc_stats();
  return 0;
}

#endif // TEST_BOXPRINT
@h=tangler('elk/sm_cycles.cpp')
@select(h)
// cycles.c            see license.txt for copyright and terms of use
// code for cycles.h

#include "sm_cycles.h"

// -------------------- x86 -------------------------
#if defined(__i386__)
// use the 'rdtsc' (read time-stamp count) instruction
// NOTE: this entire file assumes we're compiling to a 32-bit machine
// (i.e. 'unsigned' is a 32-bit quantity)

// see also:
//   http://cedar.intel.com/software/idap/media/pdf/rdtscpm1.pdf
//   http://www.x86-64.org/lists/bugs/msg00621.html
//   http://www.dc.uba.ar/people/materias/oc2/LaboLinux/docs/intel/RDTSC.pdf


#ifdef RDTSC_SOURCE
// this function yields a 64-bit cycle count, writing into
// two variables passed by address
void getCycles(unsigned *lowp, unsigned *highp)
{
  unsigned int low, high;

  // this is gcc inline assembler syntax; it says that the
  // instruction writes to EAX ("=a") and EDX ("=d"), but that
  // I would like it to then copy those values into 'low' and
  // 'high', respectively
  asm volatile ("rdtsc" : "=a" (low), "=d" (high));

  // now copy into the variables passed by address
  *lowp = low;
  *highp = high;
}

#else // RDTSC_SOURCE

// this is the binary instructions that gcc-2.95.3 (optimization -O2)
// produces for the above code; it will work regardless of the current
// compiler's assembler syntax (even if the current compiler doesn't
// have *any* inline assembler)
static char const rdtsc_instructions[] = {
  0x55,                                 // push   %ebp
  0x89, 0xe5,                           // mov    %esp,%ebp
  0x53,                                 // push   %ebx
  0x8b, 0x4d, 0x08,                     // mov    0x8(%ebp),%ecx
  0x8b, 0x5d, 0x0c,                     // mov    0xc(%ebp),%ebx
  0x0f, 0x31,                           // rdtsc
  0x89, 0x01,                           // mov    %eax,(%ecx)
  0x89, 0x13,                           // mov    %edx,(%ebx)
  0x5b,                                 // pop    %ebx
  0xc9,                                 // leave
  0xc3,                                 // ret
  0x90,                                 // nop
};

// external entry point
void getCycles(unsigned *lowp, unsigned *highp)
{
  return ((void (*)(unsigned*, unsigned*))rdtsc_instructions)(lowp, highp);
}

#endif // RDTSC_SOURCE


// ------------------ unknown architecture -----------------
#else

// some preprocessors choke on this..
//#warn unknown architecture in cycles.c

void getCycles(unsigned *lowp, unsigned *highp)
{
  *lowp = 0;
  *highp = 0;
}

#endif // architecture


// ------------------- getCycles_ll ----------------------
#ifdef __GNUC__
// this uses gcc's "long long" to represent the 64-bit
// quantity a little more easily
unsigned long long getCycles_ll()
{
  unsigned int low, high;
  unsigned long long ret;

  getCycles(&low, &high);

  ret = high;
  ret <<= 32;
  ret += low;

  return ret;
}
#endif // __GNUC__


// ----------------------- test code ---------------------
#ifdef TEST_CYCLES

#include <stdio.h>    // printf

int main()
{
  #ifdef __GNUC__
    unsigned long long v = getCycles_ll();
    printf("getCycles: %llu\n", v);
  #endif // __GNUC__

  // this segment should work on any compiler, by virtue
  // of only using 32-bit quantities
  {
    unsigned low, high;
    getCycles(&low, &high);
    printf("getCycles high=%u, low=%u\n", high, low);
  }

  // test whether the instruction causes a privileged instruction
  // fault; on my machine I get 33 cycles per call, which clearly
  // is too few for it to be trapping on each one
  {
    unsigned low1, low2, low3, high;
    getCycles(&low1, &high);
    getCycles(&low2, &high);
    getCycles(&low3, &high);
    printf("three lows in a row: %u, %u, %u\n", low1, low2, low3);
  }

  return 0;
}
#endif // TEST_CYCLES
@h=tangler('elk/sm_flatten.cpp')
@select(h)
// flatten.cc            see license.txt for copyright and terms of use
// code for flatten.h

// basically, this file provides some reasonable defaults
// assuming we are reading/writing binary files

#include "sm_flatten.h"
#include "sm_exc.h"
#include <cstring>      // std::strlen

Flatten::Flatten()
{}

Flatten::~Flatten()
{}


void Flatten::xferChar(char &c)
{
  xferSimple(&c, sizeof(c));
}

void Flatten::xferInt(int &i)
{
  xferSimple(&i, sizeof(i));
}

void Flatten::xferLong(long &l)
{
  xferSimple(&l, sizeof(l));
}

void Flatten::xferBool(bool &b)
{
  xferSimple(&b, sizeof(b));
}


void Flatten::xferHeapBuffer(void *&buf, int len)
{
  if (reading()) {
    buf = new unsigned char[len];
  }
  xferSimple(buf, len);
}


void Flatten::xferCharString(char *&str)
{
  if (writing()) {
    if (!str) {
      writeInt(-1);     // representation of NULL
      return;
    }

    int len = std::strlen(str);
    writeInt(len);

    // write the null terminator too, as a simple
    // sanity check when reading
    xferSimple(str, len+1);
  }
  else {
    int len = readInt();
    if (len == -1) {
      str = NULL;
      return;
    }

    str = new char[len+1];
    xferSimple(str, len+1);
    formatAssert(str[len] == '\0');
  }
}


void Flatten::checkpoint(int code)
{
  if (writing()) {
    writeInt(code);
  }
  else {
    int c = readInt();
    formatAssert(c == code);
  }
}


void Flatten::writeInt(int i)
{
  xassert(writing());
  xferInt(i);
}

int Flatten::readInt()
{
  xassert(reading());
  int i;
  xferInt(i);
  return i;
}

@h=tangler('elk/sm_gprintf.cpp')
@select(h)
/* gprintf.c */
/* originally from: http://www.efgh.com/software/gprintf.htm */
/* this file is in the public domain */

/* modified by Scott McPeak, April 2003:
 *   - use va_list instead of 'const int*' for the 
 *     pointer-to-argument type (for portability)
 *   - implement conservative estimates for unknown format
 *     chars, particularly 'f' (CONSERVATIVE_ESTIMATE flag)
 *   - add a few test vectors
 */

/* NOTE: There are quite a few differences among the *printf
 * implementations running around in the various libcs.  The
 * implementation in this module doesn't know about all of those
 * variations and extensions.  So, if you're using this to estimate
 * the # of chars your libc's printf will use, be sure to compare
 * libc's printf's actual return value, to make sure something doesn't
 * slip through the cracks. */

/* Code for general_printf() */
/* Change extension to .c before compiling */

#include "sm_gprintf.h"
#include <assert.h>      /* assert */

/* when this is true, unknown fields are filled with Xs, in an attempt
 * to print at least as many characters as libc's sprintf */
#define CONSERVATIVE_ESTIMATE 1

#define BITS_PER_BYTE           8

struct parameters
{
  int number_of_output_chars;
  short minimum_field_width;
  char options;
    #define MINUS_SIGN    1
    #define RIGHT_JUSTIFY 2
    #define ZERO_PAD      4
    #define CAPITAL_HEX   8
  short edited_sm_string_length;
  short leading_zeros;
  int (*output_function)(void *, int);
  void *output_pointer;
};

static void output_and_count(struct parameters *p, int c)
{
  if (p->number_of_output_chars >= 0)
  {
    int n = (*p->output_function)(p->output_pointer, c);
    if (n>=0) p->number_of_output_chars++;
    else p->number_of_output_chars = n;
  }
}

static void output_field(struct parameters *p, char const *s)
{
  short justification_length =
    p->minimum_field_width - p->leading_zeros - p->edited_sm_string_length;
  if (p->options & MINUS_SIGN)
  {
    if (p->options & ZERO_PAD)
      output_and_count(p, '-');
    justification_length--;
  }
  if (p->options & RIGHT_JUSTIFY)
    while (--justification_length >= 0)
      output_and_count(p, p->options & ZERO_PAD ? '0' : ' ');
  if (p->options & MINUS_SIGN && !(p->options & ZERO_PAD))
    output_and_count(p, '-');
  while (--p->leading_zeros >= 0)
    output_and_count(p, '0');
  while (--p->edited_sm_string_length >= 0)
    output_and_count(p, *s++);
  while (--justification_length >= 0)
    output_and_count(p, ' ');
}


int general_vprintf(Gprintf_output_function output_function, 
                    void *output_pointer,
                    const char *control_sm_string, 
                    va_list argument_pointer)
{
  struct parameters p;
  char control_char;
  p.number_of_output_chars = 0;
  p.output_function = output_function;
  p.output_pointer = output_pointer;
  control_char = *control_sm_string++;
  while (control_char != '\0')
  {
    if (control_char == '%')
    {
      short precision = -1;
      short long_argument = 0;
      short base = 0;
      control_char = *control_sm_string++;
      p.minimum_field_width = 0;
      p.leading_zeros = 0;
      p.options = RIGHT_JUSTIFY;
      if (control_char == '-')
      {
        p.options = 0;
        control_char = *control_sm_string++;
      }
      if (control_char == '0')
      {
        p.options |= ZERO_PAD;
        control_char = *control_sm_string++;
      }
      if (control_char == '*')
      {
        p.minimum_field_width = va_arg(argument_pointer, int);
        control_char = *control_sm_string++;
      }
      else
      {
        while ('0' <= control_char && control_char <= '9')
        {
          p.minimum_field_width =
            p.minimum_field_width * 10 + control_char - '0';
          control_char = *control_sm_string++;
        }
      }
      if (control_char == '.')
      {
        control_char = *control_sm_string++;
        if (control_char == '*')
        {
          precision = va_arg(argument_pointer, int);
          control_char = *control_sm_string++;
        }
        else
        {
          precision = 0;
          while ('0' <= control_char && control_char <= '9')
          {
            precision = precision * 10 + control_char - '0';
            control_char = *control_sm_string++;
          }
        }
      }
      if (control_char == 'l')
      {
        long_argument = 1;
        control_char = *control_sm_string++;
      }
      if (control_char == 'd')
        base = 10;
      else if (control_char == 'x')
        base = 16;
      else if (control_char == 'X')
      {
        base = 16;
        p.options |= CAPITAL_HEX;
      }
      else if (control_char == 'u')
        base = 10;
      else if (control_char == 'o')
        base = 8;
      else if (control_char == 'b')
        base = 2;
      else if (control_char == 'c')
      {
        base = -1;
        p.options &= ~ZERO_PAD;
      }
      else if (control_char == 's')
      {
        base = -2;
        p.options &= ~ZERO_PAD;
      }
      if (base == 0)  /* invalid conversion type */
      {
        if (control_char != '\0')
        {
          #if !CONSERVATIVE_ESTIMATE
            /* sm: this was the original code; it just prints the
             * format character itself */
            output_and_count(&p, control_char);

          #else
            /* since my goal is actually to compute a conservative
             * upper bound on the # of chars output by sprintf, I want
             * to fill unknown fields with Xs */
            static char const * const XXX =
              "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX";  /* 50 Xs */
            assert(precision <= 30);     /* otherwise I need more Xs */

            /* I'm assuming that printing floating-point is the worst case.
             * I further assume non-fractional parts (integer part,
             * exponent, decimal, sign) won't exceed 20 chars.  Finally,
             * up to 30 characters of decimal part are supported (this
             * is checked with the assertion above). */
            if (precision == -1) {
              p.edited_sm_string_length = 20 + 6;    /* 6 is default precision for 'f' */
            }
            else {
              p.edited_sm_string_length = 20 + precision;
            }
            output_field(&p, XXX);
          #endif

          control_char = *control_sm_string++;
        }
      }
      else
      {
        if (base == -1)  /* conversion type c */
        {                
          /* 'char' is passed as 'int' through '...' */
          char c = (char)va_arg(argument_pointer, int);
          p.edited_sm_string_length = 1;
          output_field(&p, &c);
        }
        else if (base == -2)  /* conversion type s */
        {
          char *sm_string;
          p.edited_sm_string_length = 0;
          sm_string = va_arg(argument_pointer, char*);
          while (sm_string[p.edited_sm_string_length] != 0)
            p.edited_sm_string_length++;
          if (precision >= 0 && p.edited_sm_string_length > precision)
            p.edited_sm_string_length = precision;
          output_field(&p, sm_string);
        }
        else  /* conversion type d, b, o or x */
        {
          unsigned long x;
          char buffer[BITS_PER_BYTE * sizeof(unsigned long) + 1];
          p.edited_sm_string_length = 0;
          if (long_argument) 
          {
            x = va_arg(argument_pointer, unsigned long);
          }
          else if (control_char == 'd')
            x = va_arg(argument_pointer, long);
          else
            x = va_arg(argument_pointer, unsigned);
          if (control_char == 'd' && (long) x < 0)
          {
            p.options |= MINUS_SIGN;
            x = - (long) x;
          }
          do 
          {
            int c;
            c = x % base + '0';
            if (c > '9')
            {
              if (p.options & CAPITAL_HEX)
                c += 'A'-'9'-1;
              else
                c += 'a'-'9'-1;
            }
            buffer[sizeof(buffer) - 1 - p.edited_sm_string_length++] = c;
          }
          while ((x/=base) != 0);
          if (precision >= 0 && precision > p.edited_sm_string_length)
            p.leading_zeros = precision - p.edited_sm_string_length;
          output_field(&p, buffer + sizeof(buffer) - p.edited_sm_string_length);
        }
        control_char = *control_sm_string++;
      }
    }
    else
    {
      output_and_count(&p, control_char);
      control_char = *control_sm_string++;
    }
  }
  return p.number_of_output_chars;
}


int general_printf(Gprintf_output_function output,
                   void *extra, const char *format, ...)
{
  va_list args;
  int ret;

  va_start(args, format);
  ret = general_vprintf(output, extra, format, args);
  va_end(args);
  
  return ret;
}


/* ------------------ test code --------------------- */
#ifdef TEST_GPRINTF

#include <stdio.h>     /* fputc, printf, vsprintf */
#include <cstring>    /* strcmp, std::strlen */
#include <stdlib.h>    /* exit */


int sm_string_output(void *extra, int ch)
{                          
  /* the 'extra' argument is a pointer to a pointer to the
   * next character to write */
  char **s = (char**)extra;

  **s = ch;     /* write */
  (*s)++;       /* advance */

  return 0;
}

int general_vsprintf(char *dest, char const *format, va_list args)
{
  char *s = dest;
  int ret;

  ret = general_vprintf(sm_string_output, &s, format, args);
  *s = 0;

  return ret;
}


char output1[1024];    /* for libc */
char output2[1024];    /* for this module */


void expect_vector_len(int expect_len, char const *expect_output,
                       char const *format, va_list args)
{
  int len;
  static int vectors = 0;

  /* keep track of how many vectors we've tried, to make it
   * a little easier to correlate failures with the inputs
   * in this file */
  vectors++;

  /* run the generalized vsprintf */
  len = general_vsprintf(output2, format, args);

  /* compare */
  if (len!=expect_len ||
      0!=strcmp(expect_output, output2)) {
    printf("outputs differ for vector %d!\n", vectors);
    printf("  format: %s\n", format);
    printf("  expect: %s (%d)\n", expect_output, expect_len);
    printf("      me: %s (%d)\n", output2, len);
    exit(2);
  }
}


void expect_vector(char const *expect_output,
                   char const *format, ...)
{
  va_list args;
  va_start(args, format);
  expect_vector_len(std::strlen(expect_output), expect_output, format, args);
  va_end(args);
}


void vector(char const *format, ...)
{
  va_list args;
  int len;

  /* run the real vsprintf */
  va_start(args, format);
  len = vsprintf(output1, format, args);
  va_end(args);

  /* test against the generalized vsprintf */
  va_start(args, format);
  expect_vector_len(len, output1, format, args);
  va_end(args);
}


int main()
{
  printf("testing gprintf...\n");

  /* test against libc */
  vector("simple");
  vector("a %s more", "little");
  vector("some %4d more %s complicated %c stuff",
         33, "yikes", 'f');
                      
  /* test unknown format chars */
  expect_vector("XXXXXXXXXXXXXXXXXXXXXXXXXX", "%f", 3.4);
  expect_vector("XXXXXXXXXXXXXXXXXXXXXXX", "%.3f", 3.4);
  expect_vector("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%.10f", 3.4);
  expect_vector("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%.30f", 3.4);

  /* fails assertion, as it should */
  /* expect_vector("XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX", "%.31f", 3.4); */

  /* TODO: add more tests */

  printf("gprintf works\n");
  return 0;
}

#endif /* TEST_GPRINTF */
@h=tangler('elk/sm_growbuf.cpp')
@select(h)
// growbuf.cc            see license.txt for copyright and terms of use
// code for growbuf.h

#include "sm_growbuf.h"

#include <cstring>       // std::memcpy

void GrowBuffer::append(byte const *str, int len)
{
  // test length
  int newLen = getDataLen() + len;
  if (newLen > getAllocated()) {
    // must grow
    int newAlloc = max(getAllocated(), 16);
    while (newLen > newAlloc) {
      newAlloc *= 2;      // would like an overflow test here..
    }

    setAllocated(newAlloc);
  }

  // do copy
  std::memcpy(getData()+getDataLen(), str, len);
  setDataLen(newLen);
}


// ----------------- test code ----------------
#ifdef TEST_GROWBUF
#include "sm_test.h"

void entry()
{
  byte const str[] = "crazy like a mad cow!";
  int len = sizeof(str);

  GrowBuffer buf;
  loopi(10) {
    buf.append(str, len);
  }
  loopi(10) {
    if (0!=std::memcmp(str, buf.getData()+len*i, len)) {
      xfailure("buffer contents are wrong");
    }
  }
  std::cout << "growbuf ok\n";
}

USUAL_MAIN

#endif // TEST_GROWBUF
@h=tangler('elk/sm_hashline.cpp')
@select(h)
// hashline.cc
// code for hashline.h

#include "sm_hashline.h"

#include <cstring>        // std::memcpy


HashLineMap::HashLineMap(char const *pf)
  : ppFname(pf),
    filenames(),     // empty
    directives(),    // empty
    prev_ppLine(-1)  // user shouldn't have negative line numbers
{}


HashLineMap::~HashLineMap()
{}


void HashLineMap::addHashLine(int ppLine, int origLine, char const *origFname)
{
  // check that entries are being added in sorted order
  xassert(ppLine > prev_ppLine);
  prev_ppLine = ppLine;

  // map 'origFname' to a canonical reference
  sm_string *canon = filenames.queryif(origFname);
  if (!canon) {
    // add a new one
    canon = new sm_string(origFname);
    filenames.add(origFname, canon);
  }
  origFname = canon->pcharc();

  // add the entry to the array
  directives.push(HashLine(ppLine, origLine, origFname));
}


void HashLineMap::doneAdding()
{
  // make a new array of exactly the right size
  ArrayStack<HashLine> tmp(directives.length());

  // copy all the entries into the new array
  std::memcpy(tmp.getDangerousWritableArray(), directives.getArray(),
         directives.length() * sizeof(HashLine));
  tmp.setLength(directives.length());

  // swap the internal contents of the two arrays, so 'directives'
  // becomes the consolidated one
  tmp.swapWith(directives);

  // now tmp's internal storage will be automatically deleted
}


// for queries exactly on #line directives we return the specified
// origLine minus 1, but I don't specify any behavior in that case
// so it's not a problem
void HashLineMap::map(int ppLine, int &origLine, char const *&origFname) const
{
  // check for a ppLine that precedes any in the array
  if (directives.isEmpty() ||
      ppLine < directives[0].ppLine) {
    // it simply refers to the pp file
    origLine = ppLine;
    origFname = ppFname.pcharc();
    return;
  }

  // perform binary search on the 'directives' array
  int low = 0;                        // index of lowest candidate
  int high = directives.length()-1;   // index of highest candidate

  while (low < high) {
    // check the midpoint (round up to ensure progress when low+1 == high)
    int mid = (low+high+1)/2;
    if (directives[mid].ppLine > ppLine) {
      // too high
      high = mid-1;
    }
    else {
      // too low or just right
      low = mid;
    }
  }
  xassert(low == high);
  HashLine const &hl = directives[low];

  // the original line is the origLine in the array entry, plus the
  // offset between the ppLine passed in and the ppLine in the array,
  // minus 1 because the #line directive itself occupies one pp line
  origLine = hl.origLine + (ppLine - hl.ppLine - 1);

  origFname = hl.origFname;
}


int HashLineMap::mapLine(int ppLine) const
{
  int origLine;
  char const *origFname;
  map(ppLine, origLine, origFname);
  return origLine;
}

char const *HashLineMap::mapFile(int ppLine) const
{
  int origLine;
  char const *origFname;
  map(ppLine, origLine, origFname);
  return origFname;
}


// --------------------- test code ---------------------
#ifdef TEST_HASHLINE

#include <stdio.h>     // printf
#include <stdlib.h>    // exit

void query(HashLineMap &hl, int ppLine,
           int expectOrigLine, char const *expectOrigFname)
{
  int origLine;
  char const *origFname;
  hl.map(ppLine, origLine, origFname);

  if (origLine != expectOrigLine ||
      0!=strcmp(origFname, expectOrigFname)) {
    printf("map(%d) yielded %s:%d, but I expected %s:%d\n",
           ppLine, origFname, origLine,
           expectOrigFname, expectOrigLine);
    exit(2);
  }
}


int main()
{
  // insert #line directives:
  //    foo.i
  //    +----------
  //   1|// nothing; it's in the pp file
  //   2|#line 1 foo.cc
  //   3|
  //   4|
  //   5|#line 1 foo.h
  //   ..
  //  76|#line 5 foo.cc
  //   ..
  // 100|#line 101 foo.i

  HashLineMap hl("foo.i");
  hl.addHashLine(2, 1, "foo.cc");
  hl.addHashLine(5, 1, "foo.h");
  hl.addHashLine(76, 5, "foo.cc");
  hl.addHashLine(100, 101, "foo.i");
  hl.doneAdding();

  // make queries, and check for expected results
  query(hl, 1, 1, "foo.i");

  query(hl, 3, 1, "foo.cc");
  query(hl, 4, 2, "foo.cc");

  query(hl, 6, 1, "foo.h");
  query(hl, 7, 2, "foo.h");
  // ...
  query(hl, 75, 70, "foo.h");

  query(hl, 77, 5, "foo.cc");
  query(hl, 78, 6, "foo.cc");
  // ...
  query(hl, 99, 27, "foo.cc");

  query(hl, 101, 101, "foo.i");
  query(hl, 102, 102, "foo.i");
  // ...

  printf("unique filenames: %d\n", hl.numUniqueFilenames());
  printf("hashline seems to work\n");

  return 0;
}

#endif // TEST_HASHLINE
@h=tangler('elk/sm_hashtbl.cpp')
@select(h)
// hashtbl.cc            see license.txt for copyright and terms of use
// code for hashtbl.h

#include "sm_hashtbl.h"
#include "sm_xassert.h"

#include <cstring>      // std::memset


unsigned HashTable::hashFunction(void const *key) const
{
  return coreHashFn(key) % (unsigned)tableSize;
}


HashTable::HashTable(GetKeyFn gk, HashFn hf, EqualKeyFn ek, int initSize)
  : getKey(gk),
    coreHashFn(hf),
    equalKeys(ek)
{
  makeTable(initSize);
}

HashTable::~HashTable()
{
  delete[] hashTable;
}


void HashTable::makeTable(int size)
{
  hashTable = new void*[size];
  tableSize = size;
  std::memset(hashTable, 0, sizeof(void*) * tableSize);
  numEntries = 0;
}


int HashTable::getEntry(void const *key) const
{
  int index = hashFunction(key);
  int originalIndex = index;
  for(;;) {
    if (hashTable[index] == NULL) {
      // unmapped
      return index;
    }
    if (equalKeys(key, getKey(hashTable[index]))) {
      // mapped here
      return index;
    }

    // this entry is mapped, but not with this key, i.e.
    // we have a collision -- so just go to the next entry,
    // wrapping as necessary
    index = nextIndex(index);

    // detect infinite looping
    xassert(index != originalIndex);
  }
}


void *HashTable::get(void const *key) const
{
  return hashTable[getEntry(key)];
}


void HashTable::resizeTable(int newSize)
{
  // save old stuff
  void **oldTable = hashTable;
  int oldSize = tableSize;
  int oldEntries = numEntries;

  // make the new table
  makeTable(newSize);

  // move entries to the new table
  for (int i=0; i<oldSize; i++) {
    if (oldTable[i] != NULL) {
      add(getKey(oldTable[i]), oldTable[i]);
      oldEntries--;
    }
  }
  xassert(oldEntries == 0);

  // deallocate the old table
  delete[] oldTable;
}


void HashTable::add(void const *key, void *value)
{
  if (numEntries+1 > tableSize*2/3) {
    // we're over the usage threshold; increase table size
    resizeTable(tableSize * 2 + 1);
  }

  int index = getEntry(key);
  xassert(hashTable[index] == NULL);    // must not be a mapping yet

  hashTable[index] = value;
  numEntries++;
}


void *HashTable::remove(void const *key)
{
  if (enableShrink                &&
      numEntries-1 < tableSize/5  &&
      tableSize > defaultSize) {
    // we're below threshold; reduce table size
    resizeTable(tableSize / 2);
  }

  int index = getEntry(key);
  xassert(hashTable[index] != NULL);    // must be a mapping to remove

  // remove this entry
  void *retval = hashTable[index];
  hashTable[index] = NULL;
  numEntries--;

  // now, if we ever inserted something and it collided with this one,
  // leaving things like this would prevent us from finding that other
  // mapping because the search stops as soon as a NULL entry is
  // discovered; so we must examine all entries that could have
  // collided, and re-insert them
  int originalIndex = index;
  for(;;) {
    index = nextIndex(index);
    xassert(index != originalIndex);    // prevent infinite loops

    if (hashTable[index] == NULL) {
      // we've reached the end of the list of possible colliders
      break;
    }

    // remove this one
    void *data = hashTable[index];
    hashTable[index] = NULL;
    numEntries--;

    // add it back
    add(getKey(data), data);
  }
  
  return retval;
}


void HashTable::empty(int initSize)
{
  delete[] hashTable;
  makeTable(initSize);
}


void HashTable::selfCheck() const
{
  int ct=0;
  for (int i=0; i<tableSize; i++) {
    if (hashTable[i] != NULL) {
      checkEntry(i);
      ct++;
    }
  }

  xassert(ct == numEntries);
}

void HashTable::checkEntry(int entry) const
{
  int index = getEntry(getKey(hashTable[entry]));
  int originalIndex = index;
  for(;;) {
    if (index == entry) {
      // the entry lives where it will be found, so that's good
      return;
    }
    if (hashTable[index] == NULL) {
      // the search for this entry would stop before finding it,
      // so that's bad!
      xfailure("checkEntry: entry in wrong slot");
    }

    // collision; keep looking
    index = nextIndex(index);
    xassert(index != originalIndex);
  }
}


// ------------------ HashTableIter --------------------
HashTableIter::HashTableIter(HashTable &t)
  : table(t)
{
  index = 0;
  moveToSth();
}

void HashTableIter::adv()
{
  xassert(!isDone());

  // move off the current item
  index++;

  // keep moving until we find something
  moveToSth();
}

void HashTableIter::moveToSth()
{
  while (index < table.tableSize &&
         table.hashTable[index] == NULL) {
    index++;
  }
  
  if (index == table.tableSize) {
    index = -1;    // mark as done
  }
}


void *HashTableIter::data() const
{
  xassert(!isDone());
  return table.hashTable[index];
}


STATICDEF void const *HashTable::identityKeyFn(void *data)
{
  return data;
}

unsigned lcprngTwoSteps(SM_RAWADDRESS v)
{
  // this is the core of the LC PRNG in one of the many libcs
  // running around the net
  v = (v * 1103515245) + 12345;

  // do it again for good measure
  v = (v * 1103515245) + 12345;

  return v;
}

STATICDEF unsigned HashTable::lcprngHashFn(void const *key)
{
  return lcprngTwoSteps((SM_RAWADDRESS)key);
}

STATICDEF bool HashTable::
  pointerEqualKeyFn(void const *key1, void const *key2)
{
  return key1 == key2;
}

@h=tangler('elk/sm_mysig.cpp')
@select(h)
// mysig.cc            see license.txt for copyright and terms of use
// code for mysig.h

#include "sm_mysig.h"

//#include <cstring>     // strsignal
#include <stdlib.h>     // exit
#include <unistd.h>     // sleep
#include <stdio.h>      // printf

// needed on Solaris; is __sun__ a good way to detect that?
#ifdef __sun__
  #include <siginfo.h>
#endif

#ifndef __CYGWIN__      // everything here is for *not* cygwin

void setHandler(int signum, SignalHandler handler)
{
  struct sigaction sa;
  std::memset(&sa, 0, sizeof(sa));       // clear any "extra" fields
  sa.sa_handler = handler;          // handler function
  sigemptyset(&sa.sa_mask);         // don't block other signals
  sa.sa_flags = SA_RESTART;         // automatically restart syscalls

  // install the handler
  if (0 > sigaction(signum, &sa, NULL)) {
    perror("sigaction");
    exit(2);
  }
}


// simple handler that just prints and re-raises
void printHandler(int signum)
{
  fprintf(stderr, "printHandler: I caught signal %d\n", signum);
  psignal(signum, "psignal message");

  //fprintf(stderr, "I'm just going to wait a while...\n");
  //sleep(60);

  // block the signal -- doesn't work for internally-generated
  // signals (i.e. raise)
  //sigset_t mask;
  //sigemptyset(&mask);
  //sigaddset(&mask, SIGINT);

  // reset the signal handler to its default handler
  setHandler(signum, SIG_DFL);

  // re-raise, which doesn't come back to this handler because
  // the signal is blocked while we're in here -- wrong; it
  // is blocked from external signals, but not from signals
  // generated internally...
  fprintf(stderr, "re-raising...\n");
  raise(signum);
}


jmp_buf sane_state;

// handler to do a longjmp
void jmpHandler(int signum)
{
  //fprintf(stderr, "jmpHandler: I caught signal %d\n", signum);
  psignal(signum, "jmpHandler: caught signal");

  // reset the signal handler to its default handler
  setHandler(signum, SIG_DFL);

  // do it
  //fprintf(stderr, "calling longjmp...\n");
  longjmp(sane_state, 1);
}


void printAddrHandler(int signum, siginfo_t *info, void *)
{
  fprintf(stderr, "faulting address: %p\n", (info->si_addr));
  
  // reset handler and re-raise
  setHandler(signum, SIG_DFL);
  raise(signum);
}
   

// unfortunately, linux 2.4.18 seems to have some bugs w.r.t.
// sigalstack... anytime MYSZ is as small as 4096, the test program
// hangs repeatedly segfaulting once I get the first.. (but note that
// MINSIGSTKSZ is 2048, so I should be well beyond the acknowledged
// minimum); and with 8192 it works only some of the time, depending on
// how things get laid out.  so I'm going to disable the alt stack
// altogether, and rely on noticing that no "faulting address" is
// printed if I get a stack overflow...

//#define MYSZ 4096
//char mysigstack[MYSZ];

void printSegfaultAddrs()
{
  // allocate the alternate signal stack; I do this because I want
  // the handler to work even for SEGVs caused by stack-overflow
  //if (!mysigstack) {
  //  mysigstack = (char*)malloc(MINSIGSTKSZ);    // "minimum signal stack size"
  //}

  #if 0
  // tell the library about it
  struct sigaltstack sas;
  sas.ss_sp = mysigstack;
  sas.ss_size = MYSZ;
  sas.ss_flags = SS_ONSTACK;

  if (0 > sigaltstack(&sas, NULL)) {
    perror("sigaltstack");
    exit(2);
  }    
  #endif // 0


  // NOTE: I have no idea how portable this stuff is, especially the
  // 'sigaltstack' call.  It's only here as a debugging aid.  Feel
  // free to #ifdef-out the entire section if necessary, but tell me
  // (smcpeak@acm.org) about it so I can add detection logic.


  // construct the handler information struct
  struct sigaction sa;
  std::memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = printAddrHandler;
  sigemptyset(&sa.sa_mask);         // don't block other signals
  sa.sa_flags = SA_SIGINFO; // | SA_STACK;

  // install the handler
  if (0 > sigaction(SIGSEGV, &sa, NULL)) {
    perror("sigaction");
    exit(2);
  }
}


// ------------------ test code ------------------
#ifdef TEST_MYSIG

static void infiniteRecursion()
{
  char buf[1024];
  buf[0] = 4;
  buf[1] = buf[0];     // silence an icc warning
  buf[1023] = 6;
  infiniteRecursion();
}

int main(int argc, char **argv)
{
  if (argc >= 2) {
    // segfault at a given addr
    printSegfaultAddrs();

    if (0==strcmp(argv[1], "inf")) {
      // die by stack overflow.. interesting, I can't catch it..
      printf("going into infinite recursion...\n");
      infiniteRecursion();
    }

    int addr = strtoul(argv[1], NULL /*endp*/, 0 /*radix*/);
    printf("about to access 0x%08X ...\n", addr);
    *((int*)addr) = 0;
    return 0;     // won't be reached for most values of 'addr'
  }

  if (setjmp(sane_state) == 0) {   // normal flow
    setHandler(SIGINT, printHandler);
    setHandler(SIGTERM, printHandler);
    setHandler(SIGUSR1, jmpHandler);
    setHandler(SIGSEGV, jmpHandler);
    setHandler(SIGBUS, jmpHandler);   // osx gives SIBGUS instead of SIGSEGV

    //printf("I'm pid %d waiting to be killed...\n", getpid());
    //sleep(10);
    printf("about to deliberately cause a segfault ...\n");
    *((int*)0) = 0;    // segfault!

    printf("didn't segfault??\n");
    return 2;
  }

  else {         // from longjmp
    printf("came back from a longjmp!\n");
    printf("\nmysig works\n");
    return 0;
  }
}

#endif // TEST_MYSIG


#else   // cygwin -- just stubs so it compiles
void setHandler(int, SignalHandler) {}
void printHandler(int) {}
jmp_buf sane_state;
void jmpHandler(int) {}

#ifdef TEST_MYSIG
int main()
{
  printf("mysig on cygwin: nop\n");
  return 0;
}
#endif // TEST_MYSIG

#endif
@h=tangler('elk/sm_point.cpp')
@select(h)
// point.cc            see license.txt for copyright and terms of use
// code for point.h

#include "sm_point.h"
#include "sm_str.h"

sm_stringBuilder& operator<< (sm_stringBuilder &sb, point const &pt)
{
  return sb << "(" << pt.x << ", " << pt.y << ")";
}

sm_stringBuilder& operator<< (sm_stringBuilder &sb, fpoint const &pt)
{
  return sb << "(" << pt.x << ", " << pt.y << ")";
}
@h=tangler('elk/sm_pprint.cpp')
@select(h)
// pprint.cc
// code for pprint.h

#include "sm_pprint.h"
#include "sm_breaker.h"
#include <stdio.h>       // sprintf
#include <cstring>      // std::memcpy


// ---------------------- PPrintOut ----------------------
void PPrintStringOut::write(char const *text)
{
  sb << text;
}

void PPrintOstreamOut::write(char const *text)
{
  os << text;
}


// ------------------------ PPrint ----------------------
bool PPrint::warnWhenUnbalanced = true;

PPrint::PPrint(PPrintOut &o)
  : line(),
    lineIndent(0),
    margin(72),
    altIndent(2),
    startText(NULL),
    out(o)
{}

PPrint::~PPrint()
{
  if (line.length() > 0) {
    // hit a breakpoint if we're in the debugger, since this
    // is unexpected
    breaker();

    // add a final newline to get all the output out
    print("\n");
  }
}


struct BreakInfo {
  int p;        // index in the 'line' array of the '\r'
  int pCol;     // column of emitted text where the newline would go
  int pInd;     // indent for the next line

  BreakInfo(int pp, int pc, int pi)
    : p(pp), pCol(pc), pInd(pi) {}
  BreakInfo() {}      // for use in arrays
    
  // when choosing breaks, we maximize this sum: the # of chars
  // that will be on this line, and the # of chars available to
  // fill on the next line
  int sum(/*int margin*/) const {
    // except, since all the margins play the same role and will
    // all cancel, we don't need to consider it
    return pCol +                 // this line
           (/*margin*/ - pInd);   // next line
  }

  // decision between two breaks
  bool betterThan(BreakInfo const &obj /*, int margin*/) { 
    if (sum(/*margin*/) > obj.sum(/*margin*/)) 
      { return true; }
      
    // tiebreaker: prefer more space on the next line, since that's
    // likely to become the space available on the line after that,
    // etc.
    if (sum(/*margin*/) == obj.sum(/*margin*/) &&
        pInd < obj.pInd)
      { return true; }

    return false;
  }
};


void PPrint::Setter::indent(int amt)
{
  for (int i=0; i<amt; i++) {
    curLine << ' ';
  }
}


void PPrint::Setter::set()
{
  // initialize the indentation stack with the line-start indentation
  indentGroups.push(pprint.lineIndent);
    
  // loop over the actual emitted lines
  while (lineIndex < pprint.line.length()) {
    // indent the line by the amount at the top of the stack
    curLineInd = indentGroups.top();
    indent(curLineInd);

    // find all of the line breaks that would make the current line end
    // before the 'margin' column
    ArrayStack<BreakInfo> breaks;      // TODO: move up to avoid allocation

    // this will scan forward to find optional line breaks
    int p = lineIndex;

    // column at which the line would break, if we broke at 'p'
    int pCol = curLine.length();

    // the topmost entry of this stack says how far we'd indent
    // at the beginning of the next line, if we broke at 'p'
    ArrayStack<int> pInd;              // TODO: move up to avoid allocation

    // initialize 'pInd' with 'indentGroups', because what happens next
    // is we speculatively emit, as if doing it for real and consequently
    // updating 'indentGroups'
    {
      pInd.ensureAtLeast(indentGroups.length());
      for (int i=0; i < indentGroups.length(); i++) {
        pInd[i] = indentGroups[i];
      }
      pInd.setLength(indentGroups.length());
    }

    while (p < pprint.line.length()-1 && pCol < pprint.margin) {
      switch (pprint.line[p]) {
        case '\r':   // optional line break
          breaks.push(BreakInfo(p, pCol, pInd.top()));
          pCol++;    // if *not* taken, it will be a space
          break;

        case '\b':   // begin break group
          pInd.push(pCol);
          break;

        case '\a':   // alternate begin group
          pInd.push(curLineInd + pprint.altIndent);
          break;

        case '\f':   // break group end
          pInd.pop();
          break;

        default:     // printing character
          // increases output column
          pCol++;
          break;
      }

      p++;
    }

    if (pCol < pprint.margin) {
      // we got to the end of 'line' before hitting margin; emit the
      // remainder as-is
      emitTo(p+1 /*include newline*/);
      flush();
      return;
    }

    if (breaks.isEmpty()) {
      // no line breaks happen soon enough, so just find the first
      // break and take it
      while (p < pprint.line.length()-1) {
        if (pprint.line[p] == '\r') {
          emitTo(p /*not including '\r'*/);
          lineIndex++;     // skip '\r'
          curLine << '\n';
          flush();
          break;
        }

        p++;
      }

      if (p == pprint.line.length()-1) {
        // no optional line breaks at all; emit remainder
        emitTo(p+1 /*include newline*/);
        flush();
        return;
      }
    }

    else {
      // choose the best break from among those in 'breaks'
      int best = 0;
      for (int i=1; i < breaks.length(); i++) {
        if (breaks[i].betterThan(breaks[best] /*, pprint.margin*/)) {
          best = i;
        }
      }

      // break the line
      emitTo(breaks[best].p /*not including '\r'*/);
      lineIndex++;                  // skip '\r'
      curLine << '\n';
      flush();
    }
  }
}

PPrint::Setter::~Setter()
{
  if (indentGroups.length() != 1) {
    // unbalanced groups
    breaker();          
    if (warnWhenUnbalanced) {
      std::cout << "warning: unbalanced indentation grouping in pprint input\n";
    }
  }
}


void PPrint::Setter::emitTo(int p)
{
  while (lineIndex < p) {
    char ch = pprint.line[lineIndex];
    switch (ch) {
      case '\r':   // optional line break
        // not taken, it's a space
        curLine << ' ';
        break;

      case '\b':   // begin break group
        indentGroups.push(curLine.length());
        break;

      case '\a':   // alternate begin group
        indentGroups.push(curLineInd + pprint.altIndent);
        break;

      case '\f':   // break group end
        indentGroups.pop();
        break;

      default:     // printing character
        curLine << ch;
        break;
    }

    lineIndex++;
  }
}


void PPrint::Setter::flush()
{
  if (pprint.startText) {
    pprint.out.write(pprint.startText);
  }
  pprint.out.write(curLine);
  curLine.clear();
}


void PPrint::set()
{
  // on entry, 'line' contains exactly one newline, at the end
  xassert(line[line.length()-1] == '\n');

  Setter s(*this);
  s.set();

  // clear the line, ready for the next one
  line.setLength(0);
}


void append(ArrayStack<char> &line, char const *src, int len)
{
  line.ensureAtLeast(line.length() + len);
  std::memcpy(line.getArrayNC()+line.length(),     // dest
         src, len);                           // src, len
  line.setLength(line.length() + len);
}

void PPrint::print(char const *text)
{
  // any newlines?
  char const *p = text;
  while (*p != 0) {
    if (*p == '\n') {
      // transfer everything up to the newline into the setting buffer
      int copylen = p-text+1;
      append(line, text, copylen);

      // advance 'text' so the next batch will begin after what we
      // just transferred
      text += copylen;

      // set the now-complete line
      set();
    }

    p++;
  }

  // copy the remainder into the line buffer
  append(line, text, p-text);
}


PPrint& PPrint::operator<< (int i)
{
  char tmp[40];
  sprintf(tmp, "%d", i);
  print(tmp);
  return *this;
}

PPrint& PPrint::operator<< (char const *s)
{
  print(s);
  return *this;
}


PPrintToString::~PPrintToString()
{}


// --------------------- test code -----------------------
#ifdef TEST_PPRINT

PPrintToString pp;

int main()
{
  pp.margin = 30;
  pp.startText = "; ";

  std::cout << "         1    1    2    2    3\n";
  std::cout << "1---5----0----5----0----5----0\n";

  pp << "int foo()\n"
        "{\n"
        ;
  pp.ind(+2);
  pp << "printf(\b\"hello there %d!\\n\",\r123456789\f);\n";
  pp << "bar(\b1 +\r2 +\r3 +\r4 +\r5 +\r6 +\r7 +\r8 +\r9 +\r10\f);\n";
  pp << "baz(\b\"a really long line that has no optional breaks at all\"\f);\n";
  pp << "zoo(\b\"one break is here, but it is very\",\r\"far from the start\"\f);\n";
  pp << "assert(\bx ==\ry &&\rz ==\rw &&\r"
               "(\bmoron !=\rfool ||\rtaxes->theRich\f)\f);\n";
  pp << "\aforall(x, y, z). if {\r"
          "x == yooey_more;\r"
          "yowza != fooey;\f\r"
        "} {\a\r"
          "z(x,y,z)==3;\r"
          "ay_caramba;\f\r"
        "}\n";
  pp.ind(-2);
  pp << "}\n";
  
  std::cout << pp.sb;
  
  return 0;
}


#endif // TEST_PPRINT
@h=tangler('elk/sm_regexp.cpp')
@select(h)
// smregexp.cc
// code for smregexp.h

#include "sm_regexp.h"
#include "sm_str.h"
#include "sm_exc.h"

#include <stddef.h>       // size_t

// for now, I implement everything using the libc POSIX regex
// facilities
//
// linux (etc.) has proper declarations in regex.h, but FreeBSD (and
// other BSDs?) has regex.h contents that do not compile under C++,
// and apparently gnuregex.h is the substitute that does
#ifndef __FreeBSD__
  #include <regex.h>
#else
  #include <gnuregex.h>
#endif


// get an error sm_string
static sm_string regexpErrorString(regex_t const *pat, int code)
{
  // find out how long the error sm_string is; this size
  // includes the final NUL byte
  int size = regerror(code, pat, NULL, 0);

  // get the sm_string
  sm_string ret(size);
  regerror(code, pat, ret.pchar(), size);

  return ret;
}

// throw an exception
static void regexpError(regex_t const *pat, int code) NORETURN;
static void regexpError(regex_t const *pat, int code)
{
  xbase(regexpErrorString(pat, code));
}


// -------------------- Regexp --------------------------
// interpretation of 'impl' field
#define PAT ((regex_t*&)impl)

Regexp::Regexp(char const *exp, CFlags flags)
{
  PAT = new regex_t;

  int f = REG_EXTENDED;    // "extended" language
  
  // if the values I chose line up perfectly with the values used by
  // libc, then I don't have to interpret them (hopefully the
  // optimizer will discover that the 'if' test is constant
  // (gcc-2.95.3's optimizer does); I can't do it with the
  // preprocessor because it can't see the enumerator values)
  if (REG_ICASE==ICASE && REG_NOSUB==NOSUB) {
    f |= (int)flags;
  }
  else {
    // interpret my flags
    if (flags & ICASE) f |= REG_ICASE;
    if (flags & NOSUB) f |= REG_NOSUB;
  }

  int code = regcomp(PAT, exp, f);
  if (code) {
    // deallocate the pattern buffer before throwing the exception
    sm_string msg = regexpErrorString(PAT, code);
    delete PAT;
    xbase(msg);
  }
}

Regexp::~Regexp()
{
  regfree(PAT);
  delete PAT;
}


void Regexp::err(int code)
{
  regexpError(PAT, code);
}


bool Regexp::match(char const *str, EFlags flags)
{
  int f = 0;
  
  // same thing as above
  if (REG_NOTBOL==NOTBOL && REG_NOTEOL==NOTEOL) {
    f = (int)flags;
  }
  else {
    if (flags & NOTBOL) f |= REG_NOTBOL;
    if (flags & NOTEOL) f |= REG_NOTEOL;
  }

  int code = regexec(PAT, str, 0, NULL, f);
  if (code == 0) {
    return true;
  }
  else if (code == REG_NOMATCH) {
    return false;
  }
  else {
    err(code);
  }
}


#undef PAT


// --------------- convenience functions ---------------
bool regexpMatch(char const *str, char const *exp)
{
  Regexp pat(exp, Regexp::NOSUB);
  return pat.match(str);
}


// ----------------- test code --------------------
#ifdef TEST_SMREGEXP
                         
#include <stdlib.h>    // exit
#include <stdio.h>     // printf


void matchVector(char const *str, char const *exp, bool expect)
{
  bool actual = regexpMatch(str, exp);
  if (actual != expect) {       
    printf("regexp failure\n");
    printf("  str: %s\n", str);
    printf("  exp: %s\n", exp);
    printf("  expect: %s\n", (expect? "true" : "false"));
    printf("  actual: %s\n", (actual? "true" : "false"));
    exit(2);
  }
}


int main()
{
  matchVector("abc", "a", true);
  matchVector("abc", "b", true);
  matchVector("abc", "c", true);
  matchVector("abc", "d", false);

  matchVector("abc", "^a", true);
  matchVector("abc", "^b", false);
  matchVector("abc", "b$", false);
  matchVector("abc", "c$", true);
  matchVector("abc", "^d", false);

  printf("regexp works\n");
  return 0;
}


#endif // TEST_SMREGEXP
@h=tangler('elk/sm_srcloc.cpp')
@select(h)
// srcloc.cc            see license.txt for copyright and terms of use
// code for srcloc.h

#include "sm_srcloc.h"
#include "sm_autofile.h"
#include "sm_array.h"
#include "sm_syserr.h"
#include "sm_trace.h"
#include "sm_hashline.h"

#include <stdio.h>      // fprintf
#include <cstring>     // std::memcpy


// this parameter controls the frequency of Markers in 
// the marker index; lower period makes the index
// faster but use more space
enum { MARKER_PERIOD = 100 };    // 100 is about a 10% overhead


// ------------------------- File -----------------------
void addLineLength(ArrayStack<unsigned char> &lengths, int len)
{
  while (len >= 255) {
    // add a long-line marker, which represents 254 chars of input
    lengths.push(255);
    len -= 254;
  }

  // add the short count at the end
  lengths.push((unsigned char)len);
}


SourceLocManager::File::File(char const *n, SourceLoc aStartLoc)
  : name(n),
    startLoc(aStartLoc),     // assigned by SourceLocManager
    hashLines(NULL),

    // valid marker/col for the first char in the file
    marker(0, 1, 0),
    markerCol(1)
{
  AutoFILE fp(name, "r");

  // the buffering that FILE would do would be wasted, so
  // make it unbuffered (if this causes a problem on some
  // system it can be commented-out)
  setbuf(fp, NULL);

  // These are growable versions of the indexes.  They will be
  // discarded after the file has been read.  They keep track of their
  // own 'next index' values.  I chose to use a growable array instead
  // of making two passes over the file to reduce i/o.
  ArrayStack<unsigned char> lineLengths;
  ArrayStack<Marker> index;

  // put a marker at the start for uniformity
  index.push(Marker(0, 1, 0));

  // how many lines to go before I insert the next marker
  int indexDelay = MARKER_PERIOD;

  // where I am in the file
  int charOffset = 0;
  int lineNum = 1;
  int lineLen = 0;       // length of current line, so far

  // read the file, computing information about line lengths
  enum { BUFLEN=8192 };
  char buf[BUFLEN];
  for (;;) {
    // read a buffer of data
    int len = fread(buf, 1, BUFLEN, fp);
    if (len < 0) {
      xsyserror("fread", name);
    }
    if (len==0) {
      break;
    }

    // the code that follows can be seen as abstracting the data
    // contained in buf[start] through buf[end-1] and adding that
    // information to the summary variables above
    char const *start = buf;      // beginning of unaccounted-for chars
    char const *p = buf;          // scan pointer
    char const *end = buf+len;    // end of unaccounted-for chars

    // loop over the lines in 'buf'
    while (start < end) {
      // scan to the next newline
      while (p<end && *p!='\n') {
        p++;
      }
      if (p==end) {
        break;
      }
      xassert(*p == '\n');

      // account for [start,p)
      charOffset += p-start;
      lineLen += p-start;
      start = p;

      // account for the newline at '*p'
      addLineLength(lineLengths, lineLen);
      charOffset++;
      lineNum++;
      lineLen = 0;

      p++;
      start++;

      if (--indexDelay == 0) {
        // insert a marker to remember this location
        index.push(Marker(charOffset, lineNum, lineLengths.length()));
        indexDelay = MARKER_PERIOD;
      }
    }

    // move [start,p) into 'lineLen'
    charOffset += p-start;
    lineLen += p-start;
    start = p;
    xassert(start == end);
  }

  // handle the last line; in the usual case, where a newline is
  // the last character, the final line will have 0 length, but
  // we encode that anyway since it helps the decode phase below
  addLineLength(lineLengths, lineLen);
  charOffset += lineLen;

  // move computed information into 'this'
  this->numChars = charOffset;
  this->numLines = lineNum-1;
  if (numLines == 0) {
    // a file with no newlines
    this->avgCharsPerLine = numChars;
  }
  else {
    this->avgCharsPerLine = numChars / numLines;
  }

  this->lineLengthsSize = lineLengths.length();
  this->lineLengths = new unsigned char[lineLengthsSize];
  std::memcpy(this->lineLengths, lineLengths.getArray(),
         lineLengthsSize * sizeof(this->lineLengths[0]));

  this->indexSize = index.length();
  this->index = new Marker[indexSize];
  std::memcpy(this->index, index.getArray(),
         indexSize * sizeof(this->index[0]));
         
  // 'fp' closed by the AutoFILE
}


SourceLocManager::File::~File()
{
  if (hashLines) { 
    delete hashLines;
  }
  delete[] lineLengths;
}


void SourceLocManager::File::resetMarker()
{
  marker.charOffset = 0;
  marker.lineOffset = 1;
  marker.arrayOffset = 0;
  markerCol = 1;
}


// it's conceivable gcc is smart enough to recognize
// the induction variable, if I inline this..
inline void SourceLocManager::File::advanceMarker()
{
  int len = (int)lineLengths[marker.arrayOffset];
  if (len < 255) {
    // normal length line
    marker.charOffset += len+1;     // +1 for newline
    marker.lineOffset++;
    marker.arrayOffset++;
    markerCol = 1;
  }
  else {
    // fragment of a long line, representing 254 characters
    marker.charOffset += 254;
    marker.arrayOffset++;
    markerCol += 254;
  }
}


int SourceLocManager::File::lineToChar(int lineNum)
{
  if (lineNum == numLines+1) {
    // end of file location
    return numChars;
  }

  xassert(1 <= lineNum && lineNum <= numLines);

  // check to see if the marker is already close
  if (marker.lineOffset <= lineNum &&
                           lineNum < marker.lineOffset + MARKER_PERIOD) {
    // use the marker as-is
  }
  else {
    // do a binary search on the index to find the marker whose
    // lineOffset is closest to 'lineNum' without going over
    int low = 0;              // lowest index under consideration
    int high = indexSize-1;   // highest index under consideration
    while (low < high) {
      // check the midpoint (round up to ensure progress when low+1 == high)
      int mid = (low+high+1)/2;
      if (index[mid].lineOffset > lineNum) {
        // too high
        high = mid-1;
      }
      else {
        // too low or just right
        low = mid;
      }
    }

    // copy this index marker into our primary marker
    marker = index[low];
    markerCol = 1;            // all index markers implicitly have column 1
  }

  xassert(marker.lineOffset <= lineNum);

  // move the marker down the array until it arrives at
  // the desired line
  while (marker.lineOffset < lineNum) {
    advanceMarker();
  }

  // make sure we never go beyond the end of the array
  xassert(marker.arrayOffset < lineLengthsSize);

  // if we didn't move the marker, we might not be in column 1
  return marker.charOffset - (markerCol-1);
}


int SourceLocManager::File::lineColToChar(int lineNum, int col)
{
  // use the above function first
  int offset = lineToChar(lineNum);

  // now, we use an property established by the previous function:
  // the marker points at the line of interest, possibly offset from
  // the line start by 'markerCol-1' places
  if (col <= markerCol) {
    // the column we want is not even beyond the marker's column,
    // so it's surely not beyond the end of the line, so do the
    // obvious thing
    return offset + (col-1);
  }

  // we're at least as far as the marker; move the offset up to
  // this far, and subtract from 'col' so it now represents the
  // number of chars yet to traverse on this line
  offset = marker.charOffset;
  col -= markerCol;       // 'col' is now 0-based

  // march to the end of the line, looking for either the end or a
  // line length component which goes beyond 'col'; I don't move the
  // marker itself out of concern for preserving the locality of
  // future accesses
  int index = marker.arrayOffset;
  for (;;) {
    int len = (int)lineLengths[index];
    if (col <= len) {
      // 'col' doesn't go beyond this component, we're done
      // (even if len==255 it still works)
      return offset + col;
    }
    if (len < 255) {
      // the line ends here, truncate and we're done
      SourceLocManager::shortLineCount++;
      return offset + len;
    }

    // the line continues
    xassertdb(len == 255);

    col -= 254;
    offset += 254;
    xassertdb(col > 0);

    index++;
    xassert(index < lineLengthsSize);
  }
}


void SourceLocManager::File::charToLineCol(int offset, int &line, int &col)
{
  if (offset == numChars) {
    // end of file location
    line = numLines+1;
    col = 1;
    return;
  }

  xassert(0 <= offset && offset < numChars);

  // check if the marker is close enough
  if (marker.charOffset <= offset &&
                           offset < marker.charOffset + MARKER_PERIOD*avgCharsPerLine) {
    // use as-is
  }
  else {
    // binary search, like above
    int low = 0;
    int high = indexSize-1;
    while (low < high) {
      // check midpoint
      int mid = (low+high+1)/2;
      if (index[mid].charOffset > offset) {
        high = mid-1;
      }
      else {
        low = mid;
      }
    }

    // copy this marker
    marker = index[low];
    markerCol = 1;
  }

  xassert(marker.charOffset <= offset);

  // move the marker until it's within one spot of moving
  // beyond the offset
  while (marker.charOffset + lineLengths[marker.arrayOffset] < offset) {
    advanceMarker();
  }

  // make sure we never go beyond the end of the array
  xassert(marker.arrayOffset < lineLengthsSize);

  // read off line/col
  line = marker.lineOffset;
  col = markerCol + (offset - marker.charOffset);
}


void SourceLocManager::File::addHashLine
  (int ppLine, int origLine, char const *origFname)
{
  if (!hashLines) {
    hashLines = new HashLineMap(name);
  }
  hashLines->addHashLine(ppLine, origLine, origFname);
}

void SourceLocManager::File::doneAdding()
{ 
  if (hashLines) {
    hashLines->doneAdding();
  }
  else {
    // nothing to consolidate, the NULL pointer is valid and
    // will cause the map to be ignored, so do nothing
  }
}


// ----------------------- StaticLoc -------------------
SourceLocManager::StaticLoc::~StaticLoc()
{}


// ----------------------- SourceLocManager -------------------
int SourceLocManager::shortLineCount = 0;

SourceLocManager *sourceLocManager = NULL;


SourceLocManager::SourceLocManager()
  : files(),
    recent(NULL),
    statics(),
    nextLoc(toLoc(1)),
    nextStaticLoc(toLoc(0)),
    maxStaticLocs(100),
    useHashLines(true)
{
  if (!sourceLocManager) {
    sourceLocManager = this;
  }

  // slightly clever: treat SL_UNKNOWN as a static
  SourceLoc u = encodeStatic(StaticLoc("<noloc>", 0,1,1));
  xassert(u == SL_UNKNOWN);
  PRETEND_USED(u);     // silence warning in case xasserts are turned off

  // similarly for SL_INIT
  u = encodeStatic(StaticLoc("<init>", 0,1,1));
  xassert(u == SL_INIT);
  PRETEND_USED(u);
}

SourceLocManager::~SourceLocManager()
{
  if (sourceLocManager == this) {
    sourceLocManager = NULL;
  }
}


// find it, or return NULL
SourceLocManager::File *SourceLocManager::findFile(char const *name)
{
  if (!this) {
    // it's quite common to forget to do this, and this function is 
    // almost always the one which segfaults in that case, so I'll
    // make the error message a bit nicer to save a trip through
    // the debugger
    xfailure("you have to create a SourceLocManager in your main() function");
  }

  if (recent && recent->name.equals(name)) {
    return recent;
  }

  FOREACH_OBJLIST_NC(File, files, iter) {
    if (iter.data()->name.equals(name)) {
      return recent = iter.data();
    }
  }

  return NULL;
}

// find it or make it
SourceLocManager::File *SourceLocManager::getFile(char const *name)
{
  File *f = findFile(name);
  if (!f) {
    // read the file
    f = new File(name, nextLoc);
    files.append(f);

    // bump 'nextLoc' according to how long that file was,
    // plus 1 so it can own the position equal to its length
    nextLoc = toLoc(f->startLoc + f->numChars + 1);
  }

  return recent = f;
}


SourceLoc SourceLocManager::encodeOffset(
  char const *filename, int charOffset)
{
  xassert(charOffset >= 0);

  File *f = getFile(filename);
  return toLoc(f->startLoc + charOffset);
}


SourceLoc SourceLocManager::encodeLineCol(
  char const *filename, int line, int col)
{
  xassert(line >= 1);
  xassert(col >= 1);

  File *f = getFile(filename);

  // map from a line number to a char offset
  #if 1  // new
    int charOffset = f->lineColToChar(line, col);
    return toLoc(toInt(f->startLoc) + charOffset);
  #else  // old
    int charOffset = f->lineToChar(line);
    return toLoc(toInt(f->startLoc) + charOffset + (col-1));
  #endif
}


SourceLoc SourceLocManager::encodeStatic(StaticLoc const &obj)
{
  if (-toInt(nextStaticLoc) == maxStaticLocs) {
    // Each distinct static location should correspond to a single
    // place in the source code.  If one place in the source is creating
    // a given static location over and over, that's bad because it
    // quickly leads to poor performance when storing and decoding them.
    // Instead, make one and re-use it.
    //
    // If this message is being printed because the program is just
    // really big and has lots of distinct static locations, then you
    // can increase maxStaticLocs manually.
    fprintf(stderr,
      "Warning: You've created %d static locations, which is symptomatic\n"
      "of a bug.  See %s, line %d.\n",
      maxStaticLocs, __FILE__, __LINE__);
  }

  // save this location
  statics.append(new StaticLoc(obj));

  // return current index, yield next
  SourceLoc ret = nextStaticLoc;
  nextStaticLoc = toLoc(toInt(ret) - 1);
  return ret;
}


SourceLocManager::File *SourceLocManager::findFileWithLoc(SourceLoc loc)
{
  // check cache
  if (recent && recent->hasLoc(loc)) {
    return recent;
  }

  // iterative walk
  FOREACH_OBJLIST_NC(File, files, iter) {
    if (iter.data()->hasLoc(loc)) {
      return recent = iter.data();
    }
  }

  // the user gave me a value that I never made!
  xfailure("invalid source location");
  return NULL;    // silence warning
}


SourceLocManager::StaticLoc const *SourceLocManager::getStatic(SourceLoc loc)
{
  int index = -toInt(loc);
  return statics.nthC(index);
}


void SourceLocManager::decodeOffset(
  SourceLoc loc, char const *&filename, int &charOffset)
{
  // check for static
  if (isStatic(loc)) {
    StaticLoc const *s = getStatic(loc);
    filename = s->name.pcharc();
    charOffset = s->offset;
    return;
  }

  File *f = findFileWithLoc(loc);
  filename = f->name.pcharc();
  charOffset = toInt(loc) - toInt(f->startLoc);
  
  if (useHashLines && f->hashLines) {
    // we can't pass charOffsets directly through the #line map, so we
    // must first map to line/col and then back to charOffset after
    // going through the map

    // map to a pp line/col
    int ppLine, ppCol;
    f->charToLineCol(charOffset, ppLine, ppCol);

    // map to original line/file
    int origLine;
    char const *origFname;
    f->hashLines->map(ppLine, origLine, origFname);

    // get a File for the original file; this opens that file
    // and scans it for line boundaries
    File *orig = getFile(origFname);

    // use that map to get an offset, truncating columns that are
    // beyond the true line ending (happens due to macro expansion)
    charOffset = orig->lineColToChar(origLine, ppCol);
    
    // filename is whatever #line said
    filename = origFname;             
  }
}


void SourceLocManager::decodeLineCol(
  SourceLoc loc, char const *&filename, int &line, int &col)
{ 
  if (!this) {
    // didn't initialize a loc manager.. but maybe we can survive?
    if (loc == SL_UNKNOWN) {
      filename = "<noloc>";
      line = 1;
      col = 1;
      return;
    }
    else {
      xfailure("you have to create a SourceLocManager in your main() function");
    }
  }

  // check for static
  if (isStatic(loc)) {
    StaticLoc const *s = getStatic(loc);
    filename = s->name.pcharc();
    line = s->line;
    col = s->col;
    return;
  }

  File *f = findFileWithLoc(loc);
  filename = f->name.pcharc();
  int charOffset = toInt(loc) - toInt(f->startLoc);
  
  f->charToLineCol(charOffset, line, col);
  
  if (useHashLines && f->hashLines) {       
    // use the #line map to determine a new file/line pair; simply
    // assume that the column information is still correct, though of
    // course in C, due to macro expansion, it isn't always
    f->hashLines->map(line, line, filename);
  }
}


char const *SourceLocManager::getFile(SourceLoc loc)
{
  char const *name;
  int ofs;
  decodeOffset(loc, name, ofs);
  return name;
}


int SourceLocManager::getOffset(SourceLoc loc)
{
  char const *name;
  int ofs;
  decodeOffset(loc, name, ofs);
  return ofs;
}


int SourceLocManager::getLine(SourceLoc loc)
{
  char const *name;
  int line, col;
  decodeLineCol(loc, name, line, col);
  return line;
}


int SourceLocManager::getCol(SourceLoc loc)
{
  char const *name;
  int line, col;
  decodeLineCol(loc, name, line, col);
  return col;
}


sm_string SourceLocManager::getString(SourceLoc loc)
{
  char const *name;
  int line, col;
  decodeLineCol(loc, name, line, col);

  return sm_stringc << name << ":" << line << ":" << col;
}

sm_string SourceLocManager::getLCString(SourceLoc loc)
{
  char const *name;
  int line, col;
  decodeLineCol(loc, name, line, col);

  return sm_stringc << line << ":" << col;
}


sm_string locToStr(SourceLoc sl)
{
  return sourceLocManager->getString(sl);
}


// -------------------------- test code ----------------------
#ifdef TEST_SRCLOC

#include "sm_test.h"
#include "sm_strtokp.h"

#include <stdlib.h>      // rand, exit, system

SourceLocManager mgr;
int longestLen=0;

// given a location, decode it into line/col and then re-encode,
// and check that the new encoding matches the old
void testRoundTrip(SourceLoc loc)
{
  char const *fname;
  int line, col;
  mgr.decodeLineCol(loc, fname, line, col);

  if (col > longestLen) {
    longestLen = col;
  }

  SourceLoc loc2 = mgr.encodeLineCol(fname, line, col);
  
  xassert(loc == loc2);
}


// these are some long lines to test their handling
// 109: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 209: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 309: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 509: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 609: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 1210: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 2410: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 4810: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------
// 9610: 1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------1---------2---------3---------4---------5---------6---------7---------8---------9---------10--------


           
// location in SourceLoc and line/col
class BiLoc {
public:
  int line, col;
  SourceLoc loc;
};


// given a file, compute SourceLocs throughout it and verify
// that round-trip encoding works
void testFile(char const *fname)
{
  // find the file's length
  int len;
  {
    AutoFILE fp(fname, "r");

    fseek(fp, 0, SEEK_END);
    len = (int)ftell(fp);
  }

  // get locations for the start and end
  SourceLoc start = mgr.encodeOffset(fname, 0);
  SourceLoc end = mgr.encodeOffset(fname, len-1);

  // check expectations for start
  xassert(mgr.getLine(start) == 1);
  xassert(mgr.getCol(start) == 1);

  // test them
  testRoundTrip(start);
  testRoundTrip(end);

  // temporary
  //testRoundTrip((SourceLoc)11649);

  BiLoc *bi = new BiLoc[len+1];
  char const *dummy;

  // test all positions, forward sequential; also build the
  // map for the random test; note that 'len' is considered
  // a valid source location even though it corresponds to
  // the char just beyond the end
  int i;
  for (i=0; i<=len; i++) {
    SourceLoc loc = mgr.encodeOffset(fname, i);
    testRoundTrip(loc);

    bi[i].loc = loc;
    mgr.decodeLineCol(loc, dummy, bi[i].line, bi[i].col);
  }

  // backward sequential
  for (i=len; i>0; i--) {
    SourceLoc loc = mgr.encodeOffset(fname, i);
    testRoundTrip(loc);
  }

  // random access, both mapping directions
  for (i=0; i<=len; i++) {
    int j = rand()%(len+1);
    int dir = rand()%2;

    if (dir==0) {
      // test loc -> line/col map
      int line, col;
      mgr.decodeLineCol(bi[j].loc, dummy, line, col);
      xassert(line == bi[j].line);
      xassert(col == bi[j].col);
    }
    else {
      // test line/col -> loc map
      SourceLoc loc = mgr.encodeLineCol(fname, bi[j].line, bi[j].col);
      xassert(loc == bi[j].loc);
    }
  }
  
  delete[] bi;
}


// decode with given expectation, complain if it doesn't match
void expect(SourceLoc loc, char const *expFname, int expLine, int expCol)
{
  char const *fname;
  int line, col;
  mgr.decodeLineCol(loc, fname, line, col);
  
  if (0!=strcmp(fname, expFname) ||
      line != expLine ||
      col != expCol) {
    printf("expected %s:%d:%d, but got %s:%d:%d\n",
           expFname, expLine, expCol,
           fname, line, col);
    exit(2);
  }
}


// this is a macro that will expand to more text than the call site,
// to test column truncation
#define EXPANDER int blah_de_blah_de_frickin_blah;
EXPANDER


// should this be exported?
sm_string locString(char const *fname, int line, int col)
{
  return sm_stringc << fname << ":" << line << ":" << col;
}


void testHashMap()
{
  // run the preprocessor
  system("cpp -DTEST_SRCLOC srcloc.cc >srcloc.tmp");

  SourceLocManager::File *pp = mgr.getInternalFile("srcloc.tmp");
  SourceLocManager::File *orig = mgr.getInternalFile("srcloc.cc");

  // read srcloc.tmp and install the hash maps
  int expanderLine=0;
  {
    AutoFILE fp("srcloc.tmp", "r");

    enum { SZ=256 };
    char buf[SZ];
    int ppLine=0;
    while (fgets(buf, SZ, fp)) {
      if (buf[std::strlen(buf)-1] == '\n') {
        ppLine++;
      }

      if (0==std::memcmp(buf, "int blah_de_blah", 16)) {
        expanderLine = ppLine;
      }

      if (buf[0]!='#') continue;
                                       
      // break into tokens at whitespace (this isn't exactly
      // right, because the file names can have quoted spaces,
      // but it will do for testing purposes)
      StrtokParse tok(buf, " \n");
      if (tok < 3) continue;

      int origLine = atoi(tok[1]);
      char const *tok2 = tok[2];
      sm_string origFname = sm_string(tok2+1, std::strlen(tok2)-2);  // remove quotes
      pp->addHashLine(ppLine, origLine, origFname);
    }
    pp->doneAdding();
  }

  // the 2nd line in the pp source should correspond to the
  // first line in the orig src
  // update: this doesn't work with all preprocessors, and I'm
  // confident in the implementation now, so I'll turn this off
  //SourceLoc lineTwo = mgr.encodeLineCol("srcloc.tmp", 2, 1);
  //expect(lineTwo, "srcloc.cc", 1,1);

  // print decodes of first several lines (including those that
  // are technically undefined because they occur on #line lines)
  int ppLine;
  for (ppLine = 1; ppLine < 10; ppLine++) {
    SourceLoc loc = mgr.encodeLineCol("srcloc.tmp", ppLine, 1);
    std::cout << "ppLine " << ppLine << ": " << toString(loc) << std::endl;
  }

  // similar for last few lines
  for (ppLine = pp->numLines - 10; ppLine <= pp->numLines; ppLine++) {
    SourceLoc loc = mgr.encodeLineCol("srcloc.tmp", ppLine, 1);
    std::cout << "ppLine " << ppLine << ": " << toString(loc) << std::endl;
  }

  // see how the expander line behaves
  if (!expanderLine) {
    std::cout << "didn't find expander line!\n";
    exit(2);
  }
  else {
    SourceLoc loc = mgr.encodeLineCol("srcloc.tmp", expanderLine, 1);
    std::cout << "expander column 1: " << toString(loc) << std::endl;

    // in the pp file, I can advance the expander horizontally a long ways;
    // this should truncate to column 9
    loc = advCol(loc, 20);

    char const *fname;
    int offset;
    mgr.decodeOffset(loc, fname, offset);
    std::cout << "expander column 21: " << fname << ", offset " << offset << std::endl;
    xassert(0==strcmp(fname, "srcloc.cc"));

    // map that to line/col, which should show the truncation
    int line, col;
    orig->charToLineCol(offset, line, col);
    std::cout << "expander column 21: " << locString(fname, line, col) << std::endl;
    if (col != 9) {
      std::cout << "expected column 9!\n";
      exit(2);
    }
  }
}


void entry(int argc, char ** /*argv*/)
{
  traceAddSys("progress");
  traceProgress() << "begin" << std::endl;

  if (argc >= 2) {
    // set maxStaticLocs low to test the warning
    mgr.maxStaticLocs = 1;
  }

  // test my source code
  testFile("srcloc.cc");
  testFile("srcloc.h");

  // do it again, so at least one won't be the just-added file;
  // in fact do it many times so I can see results in a profiler
  for (int i=0; i<1; i++) {
    testFile("srcloc.cc");
    testFile("srcloc.h");
  }

  traceProgress() << "end" << std::endl;

  // protect against degeneracy by printing the length of
  // the longest line
  std::cout << "\n";
  std::cout << "long line len: " << longestLen << std::endl;

  // test the statics
  std::cout << "invalid: " << toString(SL_UNKNOWN) << std::endl;
  std::cout << "here: " << toString(HERE_SOURCELOC) << std::endl;
  
  std::cout << "\n";
  testHashMap();

  std::cout << "srcloc is ok\n";
}

ARGS_MAIN


#endif // TEST_SRCLOC
@h=tangler('elk/sm_strdict.cpp')
@select(h)
// strdict.cc            see license.txt for copyright and terms of use
// code for strdict.h

#include "sm_strdict.h"
#include <cstring>         // strcmp


#define FOREACH_NODE(itervar) \
  for(Node *itervar = top; itervar != NULL; itervar = itervar->next)

#define FOREACH_ITER(dict, itervar) \
  for(Iter itervar = (dict).getIter(); !itervar.isDone(); itervar.next())

#define FOREACH_ITERC(dict, itervar) \
  for(IterC itervar = (dict).getIterC(); !itervar.isDone(); itervar.next())

#define MUTABLE_SORT(obj) (const_cast<StringDict&>(obj)).sort()


StringDict::StringDict()
  : top(NULL)
{}


StringDict::StringDict(StringDict const &obj)
  : top(NULL)
{
  *this = obj;
}


StringDict::~StringDict()
{
  SELFCHECK();
  empty();
}


StringDict& StringDict::operator= (StringDict const &obj)
{
  if (this == &obj) {
    return *this;
  }

  empty();

  Node *end = top;
  FOREACH_ITERC(obj, src) {
    Node *newnode = new Node(src.key(), src.value());
    if (!end) {
      // first element of list
      end = top = newnode;
    }
    else {
      // adding to end of nonempty list
      end = end->next = newnode;
    }
  }

  SELFCHECK();
  return *this;
}


bool StringDict::operator== (StringDict const &obj) const
{
  // sort both lists
  MUTABLE_SORT(*this);
  MUTABLE_SORT(obj);

  IterC ths(*this), other(obj);
  while (!ths.isDone() && !other.isDone()) {
    if (0!=strcmp(ths.key(), other.key()) ||
        0!=strcmp(ths.value(), other.value())) {
      return false;
    }
    ths.next();
    other.next();
  }

  if (!ths.isDone() || !other.isDone()) {
    // one finished first, so they can't be equal
    return false;
  }

  return true;
}


bool StringDict::isEmpty() const
{
  return top == NULL;
}


int StringDict::size() const
{
  int ret=0;
  FOREACH_ITERC(*this, entry) {
    ret++;
  }
  return ret;
}


bool StringDict::query(char const *key, sm_string &value) const
{
  FOREACH_ITERC(*this, entry) {
    if (0==strcmp(entry.key(), key)) {
      value = entry.value();
      return true;
    }
  }

  return false;
}


sm_string StringDict::queryf(char const *key) const
{
  sm_string ret;
  bool ok = query(key, ret);
  xassert(ok);
  return ret;
}


bool StringDict::isMapped(char const *key) const
{
  sm_string dummy;
  return query(key, dummy);
}


void StringDict::add(char const *key, char const *value)
{
  xassert(!isMapped(key));

  // just prepend; we'll sort later (when an iterator is retrieved)
  top = new Node(key, value, top);

  SELFCHECK();
}


void StringDict::modify(char const *key, char const *newValue)
{
  Iter entry = find(key);
  xassert(!entry.isDone());

  entry.value() = newValue;

  SELFCHECK();
}


StringDict::Iter StringDict::find(char const *key)
{
  FOREACH_ITER(*this, entry) {
    if (0==strcmp(entry.key(), key)) {
      return entry;
    }
  }
  return Iter(NULL);
}


void StringDict::remove(char const *key)
{
  xassert(top);

  // check for removal of top element
  if (0==strcmp(top->key, key)) {
    Node *temp = top;
    top = top->next;
    delete temp;
  }

  // find node to remove in tail of list
  else {
    Node *p = top;
    while (p->next && 0!=strcmp(p->next->key, key)) {
      p = p->next;
    }

    if (!p->next) {
      // reached the end of the list without finding the key
      xfailure("failed to find key");
    }

    // remove p->next from the list
    Node *temp = p->next;
    p->next = p->next->next;
    delete temp;
  }

  SELFCHECK();
}


void StringDict::empty()
{
  while (top) {
    Node *temp = top;
    top = top->next;
    delete temp;
  }

  SELFCHECK();
}


StringDict::Iter StringDict::getIter()
{
  sort();        // must return items in sorted order
  return Iter(top);
}


StringDict::IterC StringDict::getIterC() const
{
  //sort();
  const_cast<StringDict*>(this)->sort();    // mutable
  return IterC(top);
}


// use simple insertion sort for now
/*mutable*/ void StringDict::sort()
{
  if (!top) {
    return;
  }

  // invariant: sequence of nodes from 'top' to 'walker', inclusive,
  //            is always sorted
  Node *walker = top;
  while (walker->next != NULL) {
    // see if walker->next is out of order
    if (0 <= strcmp(walker->key, walker->next->key)) {
      // it's in order
      walker = walker->next;
      continue;
    }

    // remove walker->next from where it is (note that this has
    // the effect of advancing walker, so below here we won't
    // have another movement of walker)
    Node *mover = walker->next;
    walker->next = walker->next->next;
    mover->next = NULL;       // (redundant because of (**) lines)

    // insert at head?
    if (0 < strcmp(mover->key, top->key)) {
      mover->next = top;            // (**)
      top = mover;
      continue;
    }

    // must find correct place to insert mover (will find the place
    // where we can insert mover just before searcher->next)
    Node *searcher = top;
    while (0 < strcmp(searcher->next->key, mover->key)) {
      searcher = searcher->next;
      xassert(searcher != walker);
        // otherwise how could mover have been out of order to begin with?
    }

    // insert mover before searcher->next
    mover->next = searcher->next;   // (**)
    searcher->next = mover;
  }

  SELFCHECK();

  #ifndef NDEBUG
    verifySorted();
  #endif
}


void StringDict::verifySorted() const
{
  if (!top) {
    return;
  }

  Node *p = top;
  while (p->next) {
    xassert(0 <= strcmp(p->key, p->next->key));
    p = p->next;
  }
}


// verify that the list is well structured
void StringDict::selfCheck() const
{
  Node *fast = top, *slow = top;
  while (fast && fast->next) {
    fast = fast->next->next;
    slow = slow->next;

    xassert(fast != slow);
      // if these become equal, the list is circular
  }
}


void StringDict::insertOstream(std::ostream &os) const
{
  FOREACH_ITERC(*this, entry) {
    os << entry.key() << " = " << entry.value() << std::endl;
  }
}


sm_string StringDict::toString() const
{
  sm_stringBuilder sb;
  sb << "{";
  int count=0;
  FOREACH_ITERC(*this, entry) {
    if (count++ > 0) {
      sb << ",";
    }
    sb << " " << entry.key() << "=\"" << entry.value() << "\"";
  }
  sb << " }";
  return sb;
}


// -------------------- test code ------------------------
#ifdef TEST_STRDICT

#include "sm_test.h"
#include <stdlib.h>    // rand

#define myrandom(n) (rand()%(n))

char randChar()
{
  return (char)(myrandom(127-32+1)+32);
}

sm_string randString(int len)
{
  sm_stringBuilder str;
  loopj(len) {
    str << randChar();
  }
  return str;
}

sm_string randStringRandLen(int maxlen)
{
  return randString(myrandom(maxlen)+1);
}

sm_string randKey(StringDict const &dict)
{
  int size = dict.size();
  xassert(size > 0);

  int nth = myrandom(size);
  StringDict::IterC entry(dict);
  for (; nth > 0; entry.next(), nth--)
    {}

  return entry.key();
}


void entry()
{
  StringDict dict;
  int size=0, collisions=0;

  int iters = 1000;
  loopi(iters) {
    switch (myrandom(6)) {
      case 0: {
        // insert a random element
        sm_string key = randStringRandLen(10);
        sm_string value = randStringRandLen(30);

        if (!dict.isMapped(key)) {
          dict.add(key, value);
          size++;
        }
        else {
          collisions++;
        }
        break;
      }

      case 1: {
        // remove a random element
        if (dict.isEmpty()) {
          break;
        }

        sm_string key = randKey(dict);
        dict.remove(key);
        size--;
        break;
      }

      case 2: {
        // check a random element that should not be there
        sm_string key = randStringRandLen(10);
        if (dict.isMapped(key)) {
          collisions++;
        }
        break;
      }

      case 3: {
        // verify that computed length is right
        xassert(size == dict.size());
        break;
      }

      case 4: {
        // test == and =
        StringDict dict2(dict);
        xassert(dict2 == dict);
        xassert(dict2.size() == dict.size());

        // modify it, then verify inequality
        if (!dict2.isEmpty()) {
          sm_string key = randKey(dict2);
          sm_string value = dict2.queryf(key);

          if (myrandom(2) == 0) {
            dict2.remove(key);
          }
          else {
            dict2.modify(key, value & "x");
          }
          xassert(dict2 != dict);
        }

        break;
      }

      case 5: {
        // random modification
        if (!dict.isEmpty()) {
          sm_string key = randKey(dict);
          dict.modify(key, randStringRandLen(30));
        }
        break;
      }

      default:
        xfailure("huh?");
        break;
    }
  }

  std::cout << "final size: " << size
       << "\ncollisions: " << collisions
       << "\n";

  std::cout << "all tests passed\n";
}

USUAL_MAIN

#endif // TEST_STRDICT
@h=tangler('elk/sm_strhash.cpp')
@select(h)
// strhash.cc            see license.txt for copyright and terms of use
// code for strhash.h

#include "sm_strhash.h"
#include "sm_xassert.h"

#include <cstring>      // strcmp

// notes on sm_string hash functions ****************

// We need to test the various hash functions versus each other for
// randomness.  Scott suggests simply hashing the same data and
// modding it down as a hashtable would and seeing which gives more
// collisions.

// Note that both hash functions could be improved if they were aware
// of how many of their low order bits were really going to be
// preserved and then taking the high order bits that would otherwise
// be discarded and xoring or adding them to the low order bits.

// Hash function 2:

// 1) Does not work on architectures other than 32 bit.

// 2) Will not work well or at all if the sm_strings do not start on
// 32-bit aligned boundaries.

// 3) Could be made to work faster if the sm_strings start AND end on
// 32-bit aligned boundaries and are padded out with NUL-s.  Actually,
// if we do this trick, then the code becomes portable with no
// #ifdef-s !  All you do is cast the array to an array of ints and
// then test for termination by masking off all but the last 8 bits.
// Everything else is just operations on ints.  You might want to pick
// 64-bit primes, but they will work in 32-bit mode as long as the
// compiler just truncates their high bits off.

// ****************


StringHash::StringHash(GetKeyFn gk)
  : HashTable((HashTable::GetKeyFn)gk,
              (HashTable::HashFn)coreHash,
              (HashTable::EqualKeyFn)keyCompare)
{}

StringHash::~StringHash()
{}


STATICDEF unsigned StringHash::coreHash(char const *key)
{
  // dsw: not sure if this is the best place for it, but an assertion
  // failure is better than a segfault
  //
  // sm: I don't agree; segfaults arising from NULL derefs are
  // quite fristd::endly (deref'ing random address is another story).
  // Anyway, this is fine, but I'd like it to go away in NDEBUG
  // mode so I'm changing it to use 'xassertdb'.
  xassertdb(key);

  // some more references:
  
  // http://www.cs.yorku.ca/~oz/hash.html
  //
  // Describes three well-known hashes: djb2, sdbm, and K&R ed. 1.

  // http://burtleburtle.net/bob/hash/doobs.html
  //
  // Describes a particular hash function (called simply "My Hash")
  // and provides justifications for preferring it to several others,
  // including MD4.
  
  // http://www.isthe.com/chongo/tech/comp/fnv/
  //
  // Glen Fowler, Landon Curt Noll, and Phong Vo's hash function.

  // http://mail.python.org/pipermail/python-dev/2004-April/044235.html
  //
  // Start of a discussion thread about changing the sm_string hash
  // in Python.






  #if 0
  // I pulled this out of my ass.. it's supposed to mimic
  // a linear congruential random number generator
  unsigned val = 0x42e9d115;    // arbitrary
  while (*key != 0) {
    val *= (unsigned)(*key);
    val += 1;
    key++;
  }
  return val;
  #endif // 0

  // pick a default STRHASH_ALG
  #ifndef STRHASH_ALG
    #define STRHASH_ALG 1
  #endif // STRHASH_ALG


  #if STRHASH_ALG == 1
  #ifdef SAY_STRHASH_ALG
    #warning hash function 1: Nelson 
  #endif // SAY_STRHASH_ALG
  // this one is supposed to be better
  /* An excellent sm_string hashing function.
     Adapted from glib's g_str_hash().
     Investigation by Karl Nelson <kenelson@ece.ucdavis.edu>.
     Do a web search for "g_str_hash X31_HASH" if you want to know more. */
  /* update: this is the same function as that described in Kernighan and Pike,
     "The Practice of Programming", section 2.9 */
  unsigned h = 0;
  for (; *key != '\0'; key += 1) {
    // original X31_HASH
    h = ( h << 5 ) - h + *key;       // h*31 + *key

    // dsw: this one is better because it does the multiply last;
    // otherwise the last byte has no hope of modifying the high order
    // bits
    //
    // sm: I'm not convinced it's better.  For short sm_strings, say less
    // than 6 characters, the arithmetic won't overflow a 32-bit
    // register.  In that case, by multiplying last, the hash value is
    // always a multiple of 31 and hence will suffer many more
    // collisions.  I would like more justification in the form of
    // experimental measurements before making a change.
    //h += *key;
    //h = ( h << 5 ) - h;         // h *= 31
  }
  return h;


  #elif STRHASH_ALG == 2
  #ifdef SAY_STRHASH_ALG
    #warning hash function 2: word-rotate/final-mix
  #endif // SAY_STRHASH_ALG

  // FIX:
  #warning word-rotate/final-mix hash function only works on 32-bit architectures
  #warning word-rotate/final-mix hash function still needs to be tested for randomness vs nelson

  // Word-Rotate / Final-Mix hash function by Daniel Wilkerson; A
  // slighly faster and likely more random hash function; Invented in
  // collaboration with Simon Goldsmith.
  //
  // Supposedly gcc will sometimes recognize this and generate a
  // single rotate instruction 'ROR'.  Thanks to Matt Harren for this.
  // http://groups.google.com/groups?q=rorl+x86&start=10&hl=en&lr=&ie=UTF-8&oe=UTF-8&
  // selm=359954C9.3B354F0%40cartsys.com&rnum=11
  // http://www.privacy.nb.ca/cryptography/archives/coderpunks/new/1998-10/0096.html
  #define ROTATE(n, b) (n >> b) | (n << (32 - b))

  // Note that UINT_MAX        = 4294967295U;
  // source of primes: http://www.utm.edu/research/primes/lists/small/small.html
  static unsigned const primeA = 1500450271U;
  static unsigned const primeB = 2860486313U;
  // source of primes: http://www.utm.edu/research/primes/lists/2small/0bit.html
  static unsigned const primeC = (1U<<31) - 99U;
  static unsigned const primeD = (1U<<30) - 35U;

  static int count = 0;
  ++count;

  unsigned h = primeA;

  // Stride a word at a time.  Note that this works best (or works at
  // all) if the sm_string is 32-bit aligned.  This initial 'if' block is
  // to prevent an extra unneeded rotate.
  //
  // FIX: this would be even faster if all sm_strings were NUL-padded in
  // length to a multiple of 4; we could then omit all but the last
  // 'if' and the ragged end after the loop (it doesn't matter if you
  // tile a few extra NULs into your value).
  if (!key[0]) goto end0;
  if (!key[1]) goto end1;
  if (!key[2]) goto end2;
  if (!key[3]) goto end3;
  // No rotate here.
  h += *( (unsigned *) key );
  key += 4;
  while (1) {
    // invariant: when we get here, we are ready to rotate
    if (!key[0]) {h = ROTATE(h, 5); goto end0;}
    if (!key[1]) {h = ROTATE(h, 5); goto end1;}
    if (!key[2]) {h = ROTATE(h, 5); goto end2;}
    if (!key[3]) {h = ROTATE(h, 5); goto end3;}
    h = ROTATE(h, 5);
    // FIX: if the start of the sm_string is not 4-byte aligned then this
    // will be slower on x86 and I think even illegal on MIPS and
    // perhaps others.  To be portable we should ensure this.
    h += *( (unsigned *) key ); // on my machine plus is faster than xor
    key += 4;
  }
  xfailure("shouldn't get here");

  // deal with the ragged end
  // invariant: when we get here we are ready to add
end3:
  h += *key; h = ROTATE(h, 5); key += 1;
end2:
  h += *key; h = ROTATE(h, 5); key += 1;
end1:
  h += *key;                    // No rotate nor increment here.
  #ifndef NDEBUG
    key += 1;                   // this is only needed for the assertion below
  #endif
end0:
  xassertdb(*key=='\0');

  // I will say for now that the property of hash functions that we
  // want is that a change in any input bit has a 50% chance of
  // inverting any output bit.
  //
  // At this point, compare this hash function to the Nelson hash
  // function above.  In Nelson, everytime data is added, the
  // accumulator, 'h', is "stirred" with a multiplication.  Since data
  // is being added at the low byte and since multiplication
  // propagates dependencies towards the high bytes and since after
  // ever add there is at least one multiply, every byte has a chance
  // to affect the value of every bit above the first byte.
  //
  // However, in this hash function we have saved time by simply
  // "tiling" the data across the accumulator and at this point it
  // hasn't been "stirred" at all.  Since most hashvalues are used by
  // modding off some high bits, those bits have never had a chance to
  // affect the final value, so some stirring is needed.  How much
  // "stirring" do we need?
  //
  // Consider the 32-bit word in two halves, H and L.
  //
  // 1) With a single multiply, any bit of L "has a chance" to affect
  // any bit in H.  The reverse is not true.
  h *= primeB;

  // 2) We therefore swap H and L and multiply again.  Now, any bit in
  // H has had a chance to affect any bit in L.  We are not done
  // though, since the high order bits in H have not had a chance to
  // affect the low order bits of H (yes H).  Please note however,
  // that since L affected H and H affected L, the hight order bits of
  // L *have* had a chance to affect the low order bits of L.
  h = ROTATE(h, 16);
  h *= primeC;

  // 3) Therefore we swap H and L and multiply once again.  Now the
  // high order bits of H have had a chance to affect L (in 2) which
  // now can affect H again.  Any bit now has "had a chance" to affect
  // any other bit.
  h = ROTATE(h, 16);
  h *= primeD;

  return h;

  #undef ROTATE


  #else
    #error You must pick a hash function
  #endif // STRHASH_ALG multi-switch
}


STATICDEF bool StringHash::keyCompare(char const *key1, char const *key2)
{
  return 0==strcmp(key1, key2);
}


// ---------------------- test code --------------------
#ifdef TEST_STRHASH

#include <iostream>    // std::cout
#include <stdlib.h>      // rand
#include <iostream>      // std::istream
#include <fstream>       // filebuf
#include "sm_trace.h"
#include "sm_crc.h"
#include "sm_nonport.h"
#include "sm_array.h"
#include "sm_str.h"

// pair a GrowArray with its size
struct StringArray {
  int tableSize;
  GrowArray<char*> table;
  bool appendable;

  StringArray(int tableSize0)
    : tableSize(tableSize0)
    , table(tableSize)
    , appendable(tableSize == 0)
  {}
  void append(char *str) {
    xassert(appendable);
    table.ensureIndexDoubler(tableSize);
    table[tableSize] = str;
    ++tableSize;
  }
};

// data to hash
StringArray *dataArray = NULL;


char const *id(void *p)
{
  return (char const*)p;
}

char *randomString()
{
  char *ret = new char[11];
  loopi(10) {
    ret[i] = (rand()%26)+'a';
  }
  ret[10]=0;
  return ret;
}

// fill a table with random sm_strings
void makeRandomData(int numRandStrs) {
  dataArray = new StringArray(numRandStrs);
  {loopi(dataArray->tableSize) {
    dataArray->table[i] = randomString();
  }}
}


// file the data array with whitespace-delimited sm_strings from a file
void readDataFromFile(char *inFileName) {
  dataArray = new StringArray(0);
  char *delim = " \t\n\r\v\f";
  std::filebuf fb;
  fb.open (inFileName, ios::in);
  std::istream in(&fb);
  while(true) {
    sm_stringBuilder s;
    s.readdelim(in, delim);
//      std::cout << ":" << s->pcharc() << ":" << std::endl;
    if (in.eof()) break;
//      // don't insert 0 length sm_strings
//      if (s->length() == 0) continue;
    dataArray->append(strdup(s.pcharc()));
  }
}

void writeData(std::ostream &out) {
  std::cout << "write data" << std::endl;
  for(int i=0; i<dataArray->tableSize; ++i) {
    out << dataArray->table[i] << std::endl;
  }
}

// dsw: what is the point of this?
// dealloc the test sm_strings
//  void deleteData() {
//    {loopi(dataArray->tableSize) {
//      delete[] dataArray->table[i];
//    }}
//  //    delete[] dataArray->table;
//  }

void correctnessTest() {
  traceProgress() << "start of strhash correctness testing\n";

  // insert them all into a hash table
  StringHash hash(id);
  {loopi(dataArray->tableSize) {
    hash.add(dataArray->table[i], dataArray->table[i]);
    hash.selfCheck();
  }}
  hash.selfCheck();
  xassert(hash.getNumEntries() == dataArray->tableSize);

  // verify that they are all mapped properly
  {loopi(dataArray->tableSize) {
    xassert(hash.get(dataArray->table[i]) == dataArray->table[i]);
  }}
  hash.selfCheck();

  // remove every other one
  {loopi(dataArray->tableSize) {
    if (i%2 == 0) {
      hash.remove(dataArray->table[i]);
      hash.selfCheck();
    }
  }}
  hash.selfCheck();
  xassert(hash.getNumEntries() == dataArray->tableSize / 2);

  // verify it
  {loopi(dataArray->tableSize) {
    if (i%2 == 0) {
      xassert(hash.get(dataArray->table[i]) == NULL);
    }
    else {
      xassert(hash.get(dataArray->table[i]) == dataArray->table[i]);
    }
  }}
  hash.selfCheck();

  // remove the rest
  {loopi(dataArray->tableSize) {
    if (i%2 == 1) {
      hash.remove(dataArray->table[i]);
      hash.selfCheck();
    }
  }}
  hash.selfCheck();
  xassert(hash.getNumEntries() == 0);

  traceProgress() << "end of strhash correctness testing\n";
}

void performanceTest(int numPerfRuns) {
  // test performance of the hash function
  traceProgress() << "start of strhash performance testing\n";

  long startTime = getMilliseconds();
  loopj(numPerfRuns) {
    loopi(dataArray->tableSize) {
      StringHash::coreHash(dataArray->table[i]);
      //crc32((unsigned char*)dataArray->table[i], std::strlen(dataArray->table[i]));
      //crc32((unsigned char*)dataArray->table[i], 10);
    }
  }
  long stopTime = getMilliseconds();
  long duration = stopTime - startTime;
  std::cout << "milliseconds to hash: " << duration << std::endl;
  
  traceProgress() << "end of strhash performance testing\n";
}

// command-line state
int numRandStrs = 0;
char *inFileName = NULL;
bool dump = false;
bool testCor = true;
bool testPerf = true;
int numPerfRuns = 10000;

void usage() {
  std::cout << "Test the sm_string hashing module strhash.cc\n"
       << "  --help / -h     : print this message\n"
       << "  --[no-]testCor  : run the correctness tests\n"
       << "                    will fail if data has duplicate sm_strings (?!)\n"
       << "  --[no-]testPerf : run the performance tests\n"
       << "  --numPerfRuns N : loop over data N times during performance run\n"
       << "  --file FILE     : use the whitespace-delimited sm_string contents of FILE\n"
       << "  --random N      : use N internally generated random sm_strings of length 10;\n"
       << "                    N should be even\n"
       << "  --dump          : dump out the data after generating/reading it\n"
       << "The default is '--random 300 --testCor --testPerf --numPerfRuns 10000'."
       << std::endl;
}

void initFromFlags(int &argc, char**&argv) {
  --argc; ++argv;
  for(;
      *argv;
      --argc, ++argv) {
    if (strcmp(*argv, "--help")==0 || strcmp(*argv, "-h")==0) {
      usage();
      exit(0);
    } else if (strcmp(*argv, "--testCor")==0) {
      testCor = true;
    } else if (strcmp(*argv, "--no-testCor")==0) {
      testCor = false;
    } else if (strcmp(*argv, "--testPerf")==0) {
      testPerf = true;
    } else if (strcmp(*argv, "--no-testPerf")==0) {
      testPerf = false;
    } else if (strcmp(*argv, "--random")==0) {
      if (inFileName) {
        std::cout << "do not use --random and --file together" << std::endl;
        usage();
        exit(1);
      }
      --argc; ++argv;
      if (!*argv) {
        std::cout << "supply an argument to --random" << std::endl;
        usage();
        exit(1);
      }
      numRandStrs = atoi(*argv);
      if (!(numRandStrs > 0)) {
        std::cout << "argument to --random must be > 0" << std::endl;
        usage();
        exit(1);
      }
    } else if (strcmp(*argv, "--file")==0) {
      if (numRandStrs) {
        std::cout << "do not use --random and --file together" << std::endl;
        usage();
        exit(1);
      }
      --argc; ++argv;
      if (!*argv) {
        std::cout << "supply an argument to --file" << std::endl;
        usage();
        exit(1);
      }
      inFileName = strdup(*argv);
      xassert(inFileName);
    } else if (strcmp(*argv, "--numPerfRuns")==0) {
      --argc; ++argv;
      if (!*argv) {
        std::cout << "supply an argument to --numPerfRuns" << std::endl;
        usage();
        exit(1);
      }
      numPerfRuns = atoi(*argv);
      if (!(numPerfRuns > 0)) {
        std::cout << "argument to --numPerfRuns must be > 0" << std::endl;
        usage();
        exit(1);
      }
    } else if (strcmp(*argv, "--dump")==0) {
      dump = true;
    } else {
      std::cout << "unrecognized flag " << *argv << std::endl;
      usage();
      exit(1);
    }
  }
}

int main(int argc, char **argv)
{
  traceAddSys("progress");

  #if STRHASH_ALG == 1
    std::cout << "hash function 1: Nelson" << std::endl;
  #elif STRHASH_ALG == 2
    std::cout << "hash function 2: word-rotate/final-mix" << std::endl;
  #else
    #error You must pick a hash function
  #endif // STRHASH_ALG multi-switch

  // read command line flags
  initFromFlags(argc, argv);

  // read data
  if ((!inFileName) && (!numRandStrs)) {
    numRandStrs = 300;          // default
  }
  if (numRandStrs % 2 != 0) {
    std::cout << "use an even-number argument for --random" << std::endl;
    usage();
    exit(1);
  }
  if (numRandStrs) {
    makeRandomData(numRandStrs);
  } else if (inFileName) {
    if (testCor) {
      std::cout << "Warning: The correctness test fails if sm_strings are duplicated "
        "and you are reading data from a file." << std::endl;
    }
    readDataFromFile(inFileName);
  } else {
    xfailure("goink?");
  }

  // dump data
  if (dump) {
    writeData(std::cout);
  }

  // test
  if (testCor) {
    correctnessTest();
  }
  if (testPerf) {
    performanceTest(numPerfRuns);
  }

  // delete data
//    deleteData();

  std::cout << "strhash tests finished\n";
  return 0;
}

#endif // TEST_STRHASH
@h=tangler('elk/sm_stringset.cpp')
@select(h)
// sm_stringset.cc            see license.txt for copyright and terms of use
// code for sm_stringset.h

#include "sm_stringset.h"

StringSet::~StringSet()
{}

void StringSet::add(char const *elt)
{
  if (!contains(elt)) {
    elts.add(elt, NULL);
  }
}

void StringSet::remove(char const *elt)
{
  if (contains(elt)) {
    elts.remove(elt);
  }
}

@h=tangler('elk/sm_strutil.cpp')
@select(h)
// strutil.cc            see license.txt for copyright and terms of use
// code for strutil.h

#include "sm_strutil.h"
#include "sm_exc.h"
#include "sm_autofile.h"

#include <ctype.h>       // isspace
#include <cstring>      // strstr, std::memcmp
#include <stdio.h>       // sprintf
#include <stdlib.h>      // strtoul
#include <time.h>        // time, asctime, localtime


// replace all instances of oldstr in src with newstr, return result
sm_string replace(char const *src, char const *oldstr, char const *newstr)
{
  sm_stringBuilder ret("");

  while (*src) {
    char const *next = strstr(src, oldstr);
    if (!next) {
      ret &= sm_string(src);
      break;
    }

    // make a subsm_string out of the characters between src and next
    sm_string upto(src, next-src);

    // add it to running sm_string
    ret &= upto;

    // add the replace-with sm_string
    ret &= sm_string(newstr);

    // move src to beyond replaced subsm_string
    src += (next-src) + std::strlen(oldstr);
  }

  return ret;
}


sm_string expandRanges(char const *chars)
{
  sm_stringBuilder ret;
  
  while (*chars) {
    if (chars[1] == '-' && chars[2] != 0) {
      // range specification
      if (chars[0] > chars[2]) {
        xformat("range specification with wrong collation order");
      }

      for (char c = chars[0]; c <= chars[2]; c++) {
        ret << c;
      }
      chars += 3;
    }
    else {
      // simple character specification
      ret << chars[0];
      chars++;
    }
  }

  return ret;
}


sm_string translate(char const *src, char const *srcchars, char const *destchars)
{
  // first, expand range notation in the specification sequences
  sm_string srcSpec = expandRanges(srcchars);
  sm_string destSpec = expandRanges(destchars);

  // build a translation map
  char map[256];
  int i;
  for (i=0; i<256; i++) {
    map[i] = i;
  }

  // excess characters from either sm_string are ignored ("SysV" behavior)
  for (i=0; i < srcSpec.length() && i < destSpec.length(); i++) {
    map[(unsigned char)( srcSpec[i] )] = destSpec[i];
  }

  // run through 'src', applying 'map'
  sm_string ret(std::strlen(src));
  char *dest = ret.pchar();
  while (*src) {
    *dest = map[(unsigned char)*src];
    dest++;
    src++;
  }
  *dest = 0;    // final nul terminator

  return ret;
}


// why is this necessary?
sm_string sm_stringToupper(char const *src)
  { return translate(src, "a-z", "A-Z"); }


sm_string trimWhitespace(char const *str)
{
  // trim leading whitespace
  while (isspace(*str)) {
    str++;
  }

  // trim trailing whitespace
  char const *end = str + std::strlen(str);
  while (end > str &&
         isspace(end[-1])) {
    end--;
  }

  // return it
  return sm_string(str, end-str);
}


// table of escape codes
static struct Escape {
  char actual;      // actual character in sm_string
  char escape;      // char that follows backslash to produce 'actual'
} const escapes[] = {
  { '\0', '0' },  // nul
  { '\a', 'a' },  // bell
  { '\b', 'b' },  // backspace
  { '\f', 'f' },  // form feed
  { '\n', 'n' },  // newline
  { '\r', 'r' },  // carriage return
  { '\t', 't' },  // tab
  { '\v', 'v' },  // vertical tab
  { '\\', '\\'},  // backslash
  { '"',  '"' },  // double-quote
  { '\'', '\''},  // single-quote
};


sm_string encodeWithEscapes(char const *p, int len)
{
  sm_stringBuilder sb;

  for (; len>0; len--, p++) {
    // look for an escape code
    unsigned i;
    for (i=0; i<TABLESIZE(escapes); i++) {
      if (escapes[i].actual == *p) {
        sb << '\\' << escapes[i].escape;
        break;
      }
    }
    if (i<TABLESIZE(escapes)) {
      continue;   // found it and printed it
    }

    // try itself
    if (isprint(*p)) {
      sb << *p;
      continue;
    }

    // use the most general notation
    char tmp[5];
    sprintf(tmp, "\\x%02X", (unsigned char)(*p));
    sb << tmp;
  }
  
  return sb;
}


sm_string encodeWithEscapes(char const *p)
{
  return encodeWithEscapes(p, std::strlen(p));
}


sm_string quoted(char const *src)
{
  return sm_stringc << "\""
                 << encodeWithEscapes(src, std::strlen(src))
                 << "\"";
}


void decodeEscapes(sm_string &dest, int &destLen, char const *src,
                   char delim, bool allowNewlines)
{
  // place to collect the sm_string characters
  sm_stringBuilder sb;
  destLen = 0;

  while (*src != '\0') {
    if (*src == '\n' && !allowNewlines) {
      xformat("unescaped newline (unterminated sm_string)");
    }
    if (*src == delim) {
      xformat(sm_stringc << "unescaped delimiter (" << delim << ")");
    }

    if (*src != '\\') {
      // easy case
      sb << *src;
      destLen++;
      src++;
      continue;
    }          
          
    // advance past backslash
    src++;

    // see if it's a simple one-char backslash code;
    // start at 1 so we do *not* use the '\0' code since
    // that's actually a special case of \0123', and
    // interferes with the latter
    int i;
    for (i=1; i<TABLESIZE(escapes); i++) {
      if (escapes[i].escape == *src) {
        sb << escapes[i].actual;
        destLen++;
        src++;
        break;
      }
    }
    if (i < TABLESIZE(escapes)) {
      continue;
    }
    
    if (*src == '\0') {
      xformat("backslash at end of sm_string");
    }

    if (*src == '\n') {
      // escaped newline; advance to first non-whitespace
      src++;
      while (*src==' ' || *src=='\t') {
        src++;
      }
      continue;
    }

    if (*src == 'x' || isdigit(*src)) {
      // hexadecimal or octal char (it's unclear to me exactly how to
      // parse these since it's supposedly legal to have e.g. "\x1234"
      // mean a one-char sm_string.. whatever)
      bool hex = (*src == 'x');
      if (hex) {
        src++;

        // strtoul is willing to skip leading whitespace
        if (isspace(*src)) {
          xformat("whitespace following hex (\\x) escape");
        }
      }

      char const *endptr;
      unsigned long val = strtoul(src, (char**)&endptr, hex? 16 : 8);
      if (src == endptr) {
        // this can't happen with the octal escapes because
        // there is always at least one valid digit
        xformat("invalid hex (\\x) escape");
      }

      sb << (unsigned char)val;    // possible truncation..
      destLen++;
      src = endptr;
      continue;
    }

    // everything not explicitly covered will be considered
    // an error (for now), even though the C++ spec says
    // it should be treated as if the backslash were not there
    //
    // 7/29/04: now making backslash the identity transformation in
    // this case
    //
    // copy character as if it had not been backslashed
    sb << *src;
    destLen++;
    src++;
  }

  // copy to 'dest'
  dest.setlength(destLen);       // this sets the NUL
  if (destLen > 0) {
    std::memcpy(dest.pchar(), sb.pchar(), destLen);
  }
}


sm_string parseQuotedString(char const *text)
{
  if (!( text[0] == '"' &&
         text[std::strlen(text)-1] == '"' )) {
    xformat(sm_stringc << "quoted sm_string is missing quotes: " << text);
  }

  // strip the quotes
  sm_string noQuotes = sm_string(text+1, std::strlen(text)-2);
  
  // decode escapes
  sm_string ret;
  int dummyLen;
  decodeEscapes(ret, dummyLen, noQuotes, '"');
  return ret;
}


sm_string localTimeString()
{
  time_t t = time(NULL);
  char const *p = asctime(localtime(&t));
  return sm_string(p, std::strlen(p) - 1);     // strip final newline
}


sm_string sm_basename(char const *src)
{
  char const *sl = strrchr(src, '/');   // locate last slash
  if (sl && sl[1] == 0) {
    // there is a slash, but it is the last character; ignore it
    // (this behavior is what /bin/basename does)
    return sm_basename(sm_string(src, std::strlen(src)-1));
  }

  if (sl) {
    return sm_string(sl+1);     // everything after the slash
  }
  else {
    return sm_string(src);      // entire sm_string if no slashes
  }
}

sm_string dirname(char const *src)
{
  char const *sl = strrchr(src, '/');   // locate last slash
  if (sl == src) {
    // last slash is leading slash
    return sm_string("/");
  }

  if (sl && sl[1] == 0) {
    // there is a slash, but it is the last character; ignore it
    // (this behavior is what /bin/dirname does)
    return dirname(sm_string(src, std::strlen(src)-1));
  }

  if (sl) {
    return sm_string(src, sl-src);     // everything before slash
  }
  else {
    return sm_string(".");
  }
}


// I will expand this definition as I go to get more knowledge about
// English irregularities as I need it
sm_string plural(int n, char const *prefix)
{
  if (n==1) {
    return sm_string(prefix);
  }

  if (0==strcmp(prefix, "was")) {
    return sm_string("were");
  }
  if (prefix[std::strlen(prefix)-1] == 'y') {
    return sm_stringc << sm_string(prefix, std::strlen(prefix)-1) << "ies";
  }
  else {
    return sm_stringc << prefix << "s";
  }
}

sm_string pluraln(int n, char const *prefix)
{
  return sm_stringc << n << " " << plural(n, prefix);
}


char *copyToStaticBuffer(char const *s)
{           
  enum { SZ=200 };
  static char buf[SZ+1];

  int len = std::strlen(s);
  if (len > SZ) len=SZ;
  std::memcpy(buf, s, len);
  buf[len] = 0;

  return buf;
}


bool prefixEquals(char const *str, char const *prefix)
{
  int slen = std::strlen(str);
  int plen = std::strlen(prefix);
  return slen >= plen &&
         0==std::memcmp(str, prefix, plen);
}

bool suffixEquals(char const *str, char const *suffix)
{
  int slen = std::strlen(str);
  int ulen = std::strlen(suffix);    // sUffix
  return slen >= ulen &&
         0==std::memcmp(str+slen-ulen, suffix, ulen);
}


void writeStringToFile(char const *str, char const *fname)
{
  AutoFILE fp(fname, "w");

  if (fputs(str, fp) < 0) {
    xbase("fputs: EOF");
  }
}


sm_string readStringFromFile(char const *fname)
{
  AutoFILE fp(fname, "r");

  sm_stringBuilder sb;

  char buf[4096];
  for (;;) {
    int len = fread(buf, 1, 4096, fp);
    if (len < 0) {
      xbase("fread failed");
    }
    if (len == 0) {
      break;
    }

    sb.append(buf, len);
  }

  return sb;
}


bool readLine(sm_string &dest, FILE *fp)
{
  char buf[80];

  if (!fgets(buf, 80, fp)) {
    return false;
  }

  if (buf[std::strlen(buf)-1] == '\n') {
    // read a newline, we got the whole line
    dest = buf;
    return true;
  }

  // only got part of the sm_string; need to iteratively construct
  sm_stringBuilder sb;
  while (buf[std::strlen(buf)-1] != '\n') {
    sb << buf;
    if (!fgets(buf, 80, fp)) {
      // found eof after partial; return partial *without* eof
      // indication, since we did in fact read something
      break;
    }
  }

  dest = sb;
  return true;
}


sm_string chomp(char const *src)
{
  if (src && src[std::strlen(src)-1] == '\n') {
    return sm_string(src, std::strlen(src)-1);
  }
  else {
    return sm_string(src);
  }
}


// ----------------------- test code -----------------------------
#ifdef TEST_STRUTIL

#include "sm_test.h"
#include <stdio.h>     // printf

void expRangeVector(char const *in, char const *out)
{
  printf("expRangeVector(%s, %s)\n", in, out);
  sm_string result = expandRanges(in);
  xassert(result.equals(out));
}

void trVector(char const *in, char const *srcSpec, char const *destSpec, char const *out)
{
  printf("trVector(%s, %s, %s, %s)\n", in, srcSpec, destSpec, out);
  sm_string result = translate(in, srcSpec, destSpec);
  xassert(result.equals(out));
}

void decodeVector(char const *in, char const *out, int outLen)
{
  printf("decodeVector: \"%s\"\n", in);
  sm_string dest;
  int destLen;
  decodeEscapes(dest, destLen, in, '\0' /*delim, ignored*/, false /*allowNewlines*/);
  xassert(destLen == outLen);
  xassert(0==std::memcmp(out, dest.pcharc(), destLen));
}

void basenameVector(char const *in, char const *out)
{
  printf("basenameVector(%s, %s)\n", in, out);
  sm_string result = sm_basename(in);
  xassert(result.equals(out));
}

void dirnameVector(char const *in, char const *out)
{
  printf("dirnameVector(%s, %s)\n", in, out);
  sm_string result = dirname(in);
  xassert(result.equals(out));
}

void pluralVector(int n, char const *in, char const *out)
{
  printf("pluralVector(%d, %s, %s)\n", n, in, out);
  sm_string result = plural(n, in);
  xassert(result.equals(out));
}


void entry()
{
  expRangeVector("abcd", "abcd");
  expRangeVector("a", "a");
  expRangeVector("a-k", "abcdefghijk");
  expRangeVector("0-9E-Qz", "0123456789EFGHIJKLMNOPQz");

  trVector("foo", "a-z", "A-Z", "FOO");
  trVector("foo BaR", "a-z", "A-Z", "FOO BAR");
  trVector("foo BaR", "m-z", "M-Z", "fOO BaR");

  decodeVector("\\r\\n", "\r\n", 2);
  decodeVector("abc\\0def", "abc\0def", 7);
  decodeVector("\\033", "\033", 1);
  decodeVector("\\x33", "\x33", 1);
  decodeVector("\\?", "?", 1);

  basenameVector("a/b/c", "c");
  basenameVector("abc", "abc");
  basenameVector("/", "");
  basenameVector("a/b/c/", "c");

  dirnameVector("a/b/c", "a/b");
  dirnameVector("a/b/c/", "a/b");
  dirnameVector("/a", "/");
  dirnameVector("abc", ".");
  dirnameVector("/", "/");

  pluralVector(1, "path", "path");
  pluralVector(2, "path", "paths");
  pluralVector(1, "fly", "fly");
  pluralVector(2, "fly", "flies");
  pluralVector(2, "was", "were");
}


USUAL_MAIN

#endif // TEST_STRUTIL
@h=tangler('elk/sm_svdict.cpp')
@select(h)
// svdict.cc            see license.txt for copyright and terms of use
// code for svdict.h

#include "sm_svdict.h"
#include <cstring>         // strcmp


#define FOREACH_NODE(itervar) \
  for(Node *itervar = top; itervar != NULL; itervar = itervar->next)

#define FOREACH_ITER(dict, itervar) \
  for(Iter itervar = (dict).getIter(); !itervar.isDone(); itervar.next())

#define FOREACH_ITERC(dict, itervar) \
  for(IterC itervar = (dict).getIterC(); !itervar.isDone(); itervar.next())

#define MUTABLE_SORT(obj) (const_cast<StringVoidDict&>(obj)).sort()


STATICDEF char const *StringVoidDict::Node::getKey(StringVoidDict::Node const *n)
{
  return n->key.pcharc();
}


StringVoidDict::StringVoidDict()
  : top(NULL),
    hash((StringHash::GetKeyFn)Node::getKey)
{}


StringVoidDict::StringVoidDict(StringVoidDict const &obj)
  : top(NULL),
    hash((StringHash::GetKeyFn)Node::getKey)
{
  *this = obj;
}


StringVoidDict::~StringVoidDict()
{
  SELFCHECK();
  empty();
}


StringVoidDict& StringVoidDict::operator= (StringVoidDict const &obj)
{
  if (this == &obj) {
    return *this;
  }

  empty();

  Node *end = top;
  FOREACH_ITERC(obj, src) {
    // const_cast needed because the resulting dictionary can now access
    // the data objects and modify them... hmm...
    Node *newnode = new Node(src.key(), const_cast<void*>(src.value()));
    if (!end) {
      // first element of list
      end = top = newnode;
    }
    else {
      // adding to end of nonempty list
      end = end->next = newnode;
    }
    hash.add(newnode->key, newnode);
  }

  SELFCHECK();
  return *this;
}


bool StringVoidDict::operator== (StringVoidDict const &obj) const
{
  // sort both lists
  MUTABLE_SORT(*this);
  MUTABLE_SORT(obj);

  IterC ths(*this), other(obj);
  while (!ths.isDone() && !other.isDone()) {
    if (0!=std::strcmp(ths.key(), other.key()) ||
        ths.value() != other.value()) {
      return false;
    }
    ths.next();
    other.next();
  }

  if (!ths.isDone() || !other.isDone()) {
    // one finished first, so they can't be equal
    return false;
  }

  return true;
}


bool StringVoidDict::isEmpty() const
{
  return top == NULL;
}


int StringVoidDict::size() const
{
  return hash.getNumEntries();
}


bool StringVoidDict::query(char const *key, void *&value) const
{
  Node *n = (Node*)hash.get(key);
  if (!n) {
    return false;
  }

  value = n->value;
  return true;
}


void *StringVoidDict::queryf(char const *key) const
{
  void *ret;
  bool ok = query(key, ret);
  xassert(ok);
  return ret;
}


void *StringVoidDict::queryif(char const *key) const
{
  void *ret;
  if (query(key, ret)) {
    return ret;
  }
  else {
    return NULL;
  }
}


bool StringVoidDict::isMapped(char const *key) const
{
  void *dummy;
  return query(key, dummy);
}


void StringVoidDict::add(char const *key, void *value)
{
  xassert(!isMapped(key));

  // just prepend; we'll sort later (when an iterator is retrieved)
  top = new Node(key, value, top);
  hash.add(key, top);

  SELFCHECK();
}


void *StringVoidDict::modify(char const *key, void *newValue)
{
  Iter entry = find(key);
  xassert(!entry.isDone());

  void *ret = entry.value();
  entry.value() = newValue;

  SELFCHECK();
  return ret;
}


StringVoidDict::Iter StringVoidDict::find(char const *key)
{
  Node *n = (Node*)hash.get(key);
  return Iter(n);
}


void *StringVoidDict::remove(char const *key)
{
  void *ret;     // will be previous value
  xassert(top);

  // check for removal of top element
  if (0==std::strcmp(top->key, key)) {
    Node *temp = top;
    top = top->next;
    ret = temp->value;
    hash.remove(temp->key);
    delete temp;
  }

  // find node to remove in tail of list
  else {
    Node *p = top;
    while (p->next && 0!=std::strcmp(p->next->key, key)) {
      p = p->next;
    }

    if (!p->next) {
      // reached the end of the list without finding the key
      xfailure("failed to find key");
    }

    // remove p->next from the list
    Node *temp = p->next;
    p->next = p->next->next;
    ret = temp->value;
    hash.remove(temp->key);
    delete temp;
  }

  SELFCHECK();
  return ret;
}


void StringVoidDict::empty()
{
  emptyAndDel(NULL);
}

void StringVoidDict::emptyAndDel(DelFn func)
{
  while (top) {
    Node *temp = top;
    top = top->next;

    if (func != NULL) {
      func(temp->value);
    }
    hash.remove(temp->key);
    delete temp;
  }

  SELFCHECK();
}


StringVoidDict::Iter StringVoidDict::getIter()
{
  sort();        // must return items in sorted order
  return Iter(top);
}


StringVoidDict::IterC StringVoidDict::getIterC() const
{
  //sort();
  const_cast<StringVoidDict*>(this)->sort();    // mutable
  return IterC(top);
}


void StringVoidDict::foreach(ForeachFn func, void *extra) const
{
  const_cast<StringVoidDict*>(this)->sort();    // mutable

  for (Node *n = top; n != NULL; n = n->next) {
    if (func(n->key, n->value, extra)) {
      return;
    }
  }
}


// use simple insertion sort for now
/*mutable*/ void StringVoidDict::sort()
{
  if (!top) {
    return;
  }

  // invariant: sequence of nodes from 'top' to 'walker', inclusive,
  //            is always sorted
  Node *walker = top;
  while (walker->next != NULL) {
    // see if walker->next is out of order
    if (0 <= std::strcmp(walker->key, walker->next->key)) {
      // it's in order
      walker = walker->next;
      continue;
    }

    // remove walker->next from where it is (note that this has
    // the effect of advancing walker, so below here we won't
    // have another movement of walker)
    Node *mover = walker->next;
    walker->next = walker->next->next;
    mover->next = NULL;       // (redundant because of (**) lines)

    // insert at head?
    if (0 < std::strcmp(mover->key, top->key)) {
      mover->next = top;            // (**)
      top = mover;
      continue;
    }

    // must find correct place to insert mover (will find the place
    // where we can insert mover just before searcher->next)
    Node *searcher = top;
    while (0 < std::strcmp(searcher->next->key, mover->key)) {
      searcher = searcher->next;
      xassert(searcher != walker);
        // otherwise how could mover have been out of order to begin with?
    }

    // insert mover before searcher->next
    mover->next = searcher->next;   // (**)
    searcher->next = mover;
  }

  SELFCHECK();

  #ifndef NDEBUG
    verifySorted();
  #endif
}


void StringVoidDict::verifySorted() const
{
  if (!top) {
    return;
  }

  Node *p = top;
  while (p->next) {
    xassert(0 <= std::strcmp(p->key, p->next->key));
    p = p->next;
  }
}


// verify that the list is well structured
void StringVoidDict::selfCheck() const
{
  {
    Node *fast = top, *slow = top;
    while (fast && fast->next) {
      fast = fast->next->next;
      slow = slow->next;

      xassert(fast != slow);
        // if these become equal, the list is circular
    }
  }

  // check counts, mappings
  int ct=0;
  for (Node *n = top; n != NULL; n = n->next, ct++) {
    xassert(hash.get(n->key) == n);
  }
  xassert(hash.getNumEntries() == ct);
}


void StringVoidDict::insertOstream(std::ostream &os) const
{
  FOREACH_ITERC(*this, entry) {
    os << entry.key() << " = " << entry.value() << std::endl;
  }
}


sm_string StringVoidDict::toString() const
{
  sm_stringBuilder sb;
  sb << "{";
  int count=0;
  FOREACH_ITERC(*this, entry) {
    if (count++ > 0) {
      sb << ",";
    }
    sb << " " << entry.key() << "=\"" << entry.value() << "\"";
  }
  sb << " }";
  return sb;
}


// -------------------- test code ------------------------
#ifdef TEST_SVDICT

#include "sm_test.h"
#include <stdlib.h>    // rand

#define myrandom(n) (rand()%(n))

char randChar()
{
  return (char)(myrandom(127-32+1)+32);
}

sm_string randString(int len)
{
  sm_stringBuilder str;
  loopj(len) {
    str << randChar();
  }
  return str;
}

sm_string randStringRandLen(int maxlen)
{
  return randString(myrandom(maxlen)+1);
}

sm_string randKey(StringVoidDict const &dict)
{
  int size = dict.size();
  xassert(size > 0);

  int nth = myrandom(size);
  StringVoidDict::IterC entry(dict);
  for (; nth > 0; entry.next(), nth--)
    {}

  return entry.key();
}

void *randVoidPtr()
{
  return (void*)(myrandom(100) * 8);
}


void entry()
{
  StringVoidDict dict;
  int size=0, collisions=0;

  int iters = 1000;
  loopi(iters) {
    switch (myrandom(6)) {
      case 0: {
        // insert a random element
        sm_string key = randStringRandLen(10);
        void *value = randVoidPtr();

        if (!dict.isMapped(key)) {
          dict.add(key, value);
          size++;
        }
        else {
          collisions++;
        }
        break;
      }

      case 1: {
        // remove a random element
        if (dict.isEmpty()) {
          break;
        }

        sm_string key = randKey(dict);
        dict.remove(key);
        size--;
        break;
      }

      case 2: {
        // check a random element that should not be there
        sm_string key = randStringRandLen(10);
        if (dict.isMapped(key)) {
          collisions++;
        }
        break;
      }

      case 3: {
        // verify that computed length is right
        xassert(size == dict.size());
        break;
      }

      case 4: {
        // test == and =
        StringVoidDict dict2(dict);
        xassert(dict2 == dict);
        xassert(dict2.size() == dict.size());

        // modify it, then verify inequality
        if (!dict2.isEmpty()) {
          sm_string key = randKey(dict2);
          void *value = dict2.queryf(key);

          if (myrandom(2) == 0) {
            dict2.remove(key);
          }
          else {
            dict2.modify(key, (void*)((int)value + 24));
          }
          xassert(dict2 != dict);
        }

        break;
      }

      case 5: {
        // random modification
        if (!dict.isEmpty()) {
          sm_string key = randKey(dict);
          dict.modify(key, randVoidPtr());
        }
        break;
      }

      default:
        xfailure("huh?");
        break;
    }
  }

  std::cout << "final size: " << size
       << "\ncollisions: " << collisions
       << "\n";

  std::cout << "all tests passed\n";
}

USUAL_MAIN

#endif // TEST_STRDICT
@h=tangler('elk/sm_trace.cpp')
@select(h)
// trace.cc            see license.txt for copyright and terms of use
// code for trace.h

#include "sm_trace.h"
#include "sm_objlist.h"
#include "sm_str.h"
#include "sm_strtokp.h"
#include "sm_nonport.h"

#include <fstream>   // ofstream
#include <stdlib.h>    // getenv


// auto-init
static bool inited = false;

// list of active tracers, initially empty
static ObjList<sm_string> tracers;

// stream connected to /dev/null
std::ofstream devNullObj("/dev/null");
static std::ostream *devNull = &devNullObj;


// initialize
static void init()
{
  if (inited) {
    return;
  }

  // there's a more efficient way to do this, but I don't care to dig
  // around and find out how
  // this leaks, and now that I'm checking for them, it's a little
  // annoying...
  //devNull = new ofstream("/dev/null");

  inited = true;
}


void traceAddSys(char const *sysName)
{
  init();

  tracers.prepend(new sm_string(sysName));
}


void traceRemoveSys(char const *sysName)
{
  init();

  MUTATE_EACH_OBJLIST(sm_string, tracers, mut) {
    if (mut.data()->compareTo(sysName) == 0) {
      mut.deleteIt();
      return;
    }
  }
  xfailure("traceRemoveSys: tried to remove system that isn't there");
}


bool tracingSys(char const *sysName)
{
  init();

  FOREACH_OBJLIST(sm_string, tracers, iter) {
    if (iter.data()->compareTo(sysName) == 0) {
      return true;
    }
  }
  return false;
}


void traceRemoveAll()
{
  tracers.deleteAll();
}  


std::ostream &trace(char const *sysName)
{
  init();

  if (tracingSys(sysName)) {
    std::cout << "%%% " << sysName << ": ";
    return std::cout;
  }
  else {
    return *devNull;
  }
}


void trstr(char const *sysName, char const *traceString)
{
  trace(sysName) << traceString << std::endl;
}


std::ostream &traceProgress(int level)
{
  if ( (level == 1) ||
       (level == 2 && tracingSys("progress2")) ) {
    static long progStart = getMilliseconds();

    return trace("progress") << (getMilliseconds() - progStart) << "ms: ";
  }
  else {
    return *devNull;
  }
}


void traceAddMultiSys(char const *systemNames)
{
  StrtokParse tok(systemNames, ",");
  loopi(tok) {
    if (tok[i][0] == '-') {
      // treat a leading '-' as a signal to *remove*
      // a tracing flag, e.g. from some defaults specified
      // statically      
      char const *name = tok[i]+1;
      if (tracingSys(name)) {      // be forgiving here
        traceRemoveSys(name);
      }
      else {
        std::cout << "Currently, `" << name << "' is not being traced.\n";
      }
    }
    
    else {
      // normal behavior: add things to the trace list
      traceAddSys(tok[i]);
    }
  }
}


bool traceProcessArg(int &argc, char **&argv)
{
  traceAddFromEnvVar();

  if (argc >= 3  &&  0==std::strcmp(argv[1], "-tr")) {
    traceAddMultiSys(argv[2]);
    argc -= 2;
    argv += 2;
    return true;
  }
  else {
    return false;
  }
}


bool ignoreTraceEnvVar = false;

void traceAddFromEnvVar()
{
  if (ignoreTraceEnvVar) {
    return;
  }

  char const *var = getenv("TRACE");
  if (var) {
    traceAddMultiSys(var);
  }

  ignoreTraceEnvVar = true;
}


// EOF
@h=tangler('elk/sm_trdelete.cpp')
@select(h)
// trdelete.cc            see license.txt for copyright and terms of use
// code for trdelete.h

#include <stdlib.h>       // abs
#include "sm_trdelete.h"
#include <cstring>       // std::memset
#include "sm_breaker.h"


// There is a surprising twist to our story.  When an object is created with
// 'new' on the dynamic heap, and it throws an exception, its destructor is not
// called, because the object is not fully constructed yet.  However, the
// storage allocated for that object should be freed; the exception runtimes
// do this.

// But, there is a bug (under Borland C++ 4.5) when operator delete is called
// under these circumstances, the size argument is wrong.  I've been getting
// values like 0x12fc14, which are pointers to objects on the stack.  After
// quite a bit of dump tracing, I can't find an easy way to turn this pointer
// into the desired value.

// However, the dynamic heap node format for the Borland runtimes is pretty
// simple, and an estimate of the heap size can readily be determined; the
// dword just before the passed block pointer has such an estimate.  Therefore,
// my strategy is to compare the given size with the dword at offset -4, and if
// they are within 64 of each other (I've never seen differences greater than
// 16), the size argument is considered valid.  If they aren't there isn't a
// reliable way to convert the estimate into a precise size, so I just skip
// trashing the memory altogether.


static void trash(void *blk, size_t size)
{
  #ifdef __BORLANDC__
  long guess = ((long*)blk)[-1];
  if (abs(guess - (long)size) > 64) {
    // assume the size is bogus
    breaker();     // I want to know about it, for now
    return;
  }
  #endif

  // assume the size is ok
  std::memset(blk, 0xAA, size);
    // the choice of AA is made as it is easily recognizable,
    // and 0xAAAAAAAA is pretty much always a bad pointer
}


void trashingDelete(void *blk, size_t size)
{
  trash(blk, size);

  // use the global delete operator to free the memory;
  // gratuitous cast to char* to silence gcc warning 
  // "not a pointer-to-object type"
  ::delete((char*)blk);
}


void trashingDeleteArr(void *blk, size_t size)
{
  trash(blk, size);

  // use the global delete operator to free the memory;
  // (see comment about gratuitious cast, above)
  ::delete[]((char*)blk);
}


// ------------------------ test code ---------------------
#ifdef TEST_TRDELETE

#include <stdio.h>      // printf

class Foo {
public:
  TRASHINGDELETE
  int junk[10];         // stay away from malloc's data structures
  int x;
  int moreJunk[10];     // more padding
};

class Bar {
public:
  int junk[10];         // stay away from malloc's data structures
  int x;
  int moreJunk[10];     // more padding
};


int main()
{
  printf("malloc: %p\n", malloc(10));

  Foo *f = new Foo;
  f->x = 5;
  delete f;
  if (f->x == 5) {
    printf("trashing-delete failed\n");
    return 2;
  }

  Bar *b = new Bar;
  b->x = 7;
  delete b;
  if ((unsigned)b->x == 0xAAAAAAAAu) {    // did it trash it anyway?
    printf("non-trashing-delete failed\n");
    return 2;
  }

  printf("trashing delete works\n");
  return 0;
}

#endif // TEST_TRDELETE
@h=tangler('elk/sm_tsobjlist.cpp')
@select(h)
// tsobjlist.cc            see license.txt for copyright and terms of use
// test of sobjlist.h

#include "sm_sobjlist.h"
#include <stdio.h>       // printf

int main()
{
  char const *hi = "hi there";
  char const *what = "what's up?";

  // the real purpose of this test is to make sure it's ok to
  // add a 'const' qualifier inside the angle brackets, and get
  // the effect I'm after
  SObjList<char const> list;
  
  // 'prepend' accepts a T*, which should become a char const *;
  // if it only becomes (e.g.) a char*, then this call should
  // trigger a compile error
  list.prepend(hi);

  list.append(what);
  
  // 'indexOf' accepts a T const *, so here I'm essentially verifying
  // the compiler doesn't mind seeing 'const' twice
  int i = list.indexOf(hi);
  printf("index of 'hi' is %d\n", i);

  i = list.indexOf(what);
  printf("index of 'what' is %d\n", i);

  // random test of extra 'const' outside the template context
  // (gcc-2.95.3 doesn't like it, interesting..)
  int const /*const*/ x = 5;
  printf("x is %d\n", x);

  return 0;
}
@h=tangler('elk/sm_unixutil.cpp')
@select(h)
// unixutil.c            see license.txt for copyright and terms of use
// code for unixutil.h

#include "sm_unixutil.h"

#include <unistd.h>     // write
#include <assert.h>     // assert
#include <sys/time.h>   // struct timeval
#include <sys/types.h>  // select
#include <unistd.h>     // select
#include <stdio.h>      // perror

// SKIP ALL OF THIS NOW, not using canRead
#if 0
#include <sys/select.h> // FD_ZERO etc
#include <cstring>     // required for bzero in FreeBSD 4, Darwin 6, etc.
#endif

int writeAll(int fd, void const *buf, int len)
{
  int written = 0;
  while (written < len) {
    int result = write(fd, ((char const*)buf)+written, len-written);
    if (result < 0) {
      return 0;    // failure
    }
    written += result;
  }
  assert(written == len);
  return 1;        // success
}


int readString(int fd, char *str, int len)
{ 
  int count = read(fd, str, len-1);
  if (count < 0) {
    return 0;      // failure
  }
  str[count]=0;

  // remove trailing newlines (or NULs), if any
  while (count>0 && (str[count-1] == '\n' || str[count-1] == 0)) {
    count--;
    str[count] = 0;
  }

  return 1;
}


#if 0
int canRead(int fd)
{
  fd_set set;
  struct timeval tv;
  int res;

  // check only 'fd'
  FD_ZERO(&set);
  FD_SET(fd, &set);

  // do not block at all
  tv.tv_sec = 0;
  tv.tv_usec = 0;

  res = select(fd+1, &set, NULL, NULL, &tv);
  if (res == -1) {
    perror("select");     // not ideal...
    return 0;
  }
  
  return res;             // 0 or 1
}
#endif

// EOF
@h=tangler('elk/sm_vdtllist.cpp')
@select(h)
// vdtllist.cc            see license.txt for copyright and terms of use
// code for vdtllist.h

#include "sm_vdtllist.h"

void VoidTailList::steal(VoidTailList *src)
{
  if (src) {
    top = src->top;
    tail = src->tail;
    src->top = NULL;    // paranoia
    delete src;
  }
  else {
    top = NULL;
    tail = NULL;
  }
}

void VoidTailList::prepend(void *newitem)
{
  VoidList::prepend(newitem);
  if (!tail) {
    tail = top;
  }
}

void VoidTailList::append(void *newitem)
{
  if (isEmpty()) {
    prepend(newitem);
  }
  else {
    // payoff: constant-time append
    tail->next = new VoidNode(newitem, NULL);
    tail = tail->next;
  }
}

void VoidTailList::insertAt(void *newitem, int index)
{
  VoidList::insertAt(newitem, index);
  adjustTail();
}

void VoidTailList::concat(VoidTailList &srcList)
{
  // grab what will be the tail of the concatenated list
  VoidNode *catTail = srcList.top? srcList.tail : tail;

  // build proper backbone structure
  VoidList::concat(srcList);

  // fix tails
  tail = catTail;
  srcList.tail = NULL;
}

void VoidTailList::adjustTail()
{
  if (!tail) {
    tail = top;
  }
  else if (tail->next) {
    tail = tail->next;
  }
  xassert(tail->next == NULL);
}

void *VoidTailList::removeFirst()
{
  xassert(top);
  if (top == tail) {
    tail = NULL;
  }
  void *retval = top->data;
  VoidNode *tmp = top;
  top = top->next;
  delete tmp;
  return retval;
}

void *VoidTailList::removeLast()
{
  xassert(top);
  if (top == tail) {
    return removeFirst();
  }
  
  VoidNode *before = top;
  while (before->next != tail) {
    before = before->next;
  }
  void *retval = tail->data;
  delete tail;
  tail = before;
  tail->next = NULL;
  return retval;
}

void *VoidTailList::removeAt(int index)
{
  xassert(top);
  if (index == 0) {
    return removeFirst();
  }

  VoidNode *before = top;    // will point to node before one to be removed
  index--;                    
  while (index > 0) {
    before = before->next;
    index--;
  }             
  xassert(index == 0);
  
  // fix 'tail' if necessary
  if (tail == before->next) {
    tail = before;
  }                         

  // patch around before->next
  VoidNode *toDelete = before->next;
  void *retval = toDelete->data;
  before->next = toDelete->next;
  delete toDelete;

  return retval;
}

void VoidTailList::removeAll()
{
  VoidList::removeAll();
  tail = NULL;
}

bool VoidTailList::prependUnique(void *newitem)
{
  bool retval = VoidList::prependUnique(newitem);
  adjustTail();
  return retval;
}

bool VoidTailList::appendUnique(void *newitem)
{
  bool retval = VoidList::appendUnique(newitem);
  adjustTail();
  return retval;
}

void VoidTailList::selfCheck() const
{
  VoidList::selfCheck();

  if (isNotEmpty()) {
    // get last node
    VoidNode *n = top;
    while (n->next) {
      n = n->next;
    }

    // 'tail' should be the last one
    xassert(tail == n);
  }
  else {
    xassert(tail == NULL);
  }
}


// --------------------- test code ------------------
#ifdef TEST_VDTLLIST           

#include <stdio.h>    // printf

int main()
{
  VoidTailList list;
  int zero, one, two, three;

  // This isn't a very exhaustive test; it's mainly to check that
  // selfCheck doesn't do anything really stupid (it used to).

  list.selfCheck();

  list.append(&two);     list.selfCheck();
  list.prepend(&one);    list.selfCheck();
  list.append(&three);   list.selfCheck();
  list.prepend(&zero);   list.selfCheck();

  xassert(list.nth(0) == &zero);
  xassert(list.nth(1) == &one);
  xassert(list.nth(2) == &two);
  xassert(list.nth(3) == &three);

  list.removeAll();
  list.selfCheck();

  printf("vdtllist works\n");

  return 0;
}

#endif // TEST_VDTLLIST
@h=tangler('elk/sm_voidlist.cpp')
@select(h)
// voidlist.cc            see license.txt for copyright and terms of use
// code for voidlist.h
#include <functional>

#include "sm_voidlist.h"
#include "sm_breaker.h"
#include "sm_str.h"
#include "sm_ckheap.h"

#include <stdlib.h>     // rand()
#include <stdio.h>      // printf()


VoidList::VoidList(VoidList const &obj)
  : top(NULL)
{
  *this = obj;
}


// # of items in list
int VoidList::count() const
{
  int ct=0;
  for(VoidNode *p = top; p; p = p->next) {
    ct++;
  }
  return ct;
}


// get particular item, 0 is first (item must exist)
void *VoidList::nth(int which) const
{
  VoidNode *p;
  xassert(which>=0);
  for (p = top; which > 0; which--) {
    xassert(p);
    p = p->next;
  }
  if (p == NULL) {
    xfailure(sm_stringc << "asked for list element "
                     << (count()+which) << " (0-based) but list only has "
                     << count() << " elements");
  }
  return p->data;
}


// fail assertion if list fails integrity check
void VoidList::selfCheck() const
{
  if (!top) {
    return;
  }

  // The technique here is the fast/slow list traversal to find loops (which
  // are the only way a singly-linked list can be bad). Basically, if there
  // is a loop then the fast ptr will catch up to and equal the slow one; if
  // not, the fast will simply find the terminating null. It is the only way
  // I know of to find loops in O(1) space and O(n) time.

  VoidNode *slow=top, *fast=top->next;
  while (fast && fast != slow) {
    // check heap properties
    checkHeapNode(fast);

    slow = slow->next;
    fast = fast->next;
    if (fast) {
      checkHeapNode(fast);
      fast = fast->next;      // usually, fast jumps 2 spots per slow's 1
    }
  }

  if (fast == slow) {
    xfailure("linked list has a cycle");
  }
  else {
    return;         // no loop
  }
}


void VoidList::checkHeapDataPtrs() const
{
  for (VoidNode *p=top; p!=NULL; p=p->next) {
    checkHeapNode(p->data);
  }
}


void VoidList::checkUniqueDataPtrs() const
{
  for (VoidNode *p=top; p!=NULL; p=p->next) {
    // run 'q' from 'top' to 'p', looking for any
    // collisions with 'p->data'
    for (VoidNode *q=top; q!=p; q=q->next) {
      if (q->data == p->data) {
        xfailure("linked list with duplicate element");
      }
    }
  }
}


// insert at front
void VoidList::prepend(void *newitem)
{
  top = new VoidNode(newitem, top);
}


// insert at rear
void VoidList::append(void *newitem)
{
  if (!top) {
    prepend(newitem);
  }
  else {
    VoidNode *p;
    for (p = top; p->next; p = p->next)
      {}
    p->next = new VoidNode(newitem);
  }
}


// insert at particular point, index of new node becomes 'index'
void VoidList::insertAt(void *newitem, int index)
{
  if (index == 0 || isEmpty()) {
    // special case prepending or an empty list
    xassert(index == 0);     // if it's empty, index should be 0
    prepend(newitem);
  }

  else {
    // Looking at the loop below, the key things to note are:
    //  1. If index started as 1, the loop isn't executed, and the new
    //     node goes directly after the top node.
    //  2. p is never allowed to become NULL, so we can't walk off the
    //     end of the list.

    index--;
    VoidNode *p;
    for (p = top; p->next && index; p = p->next) {
      index--;
    }
    xassert(index == 0);
      // if index isn't 0, then index was greater than count()

    // put a node after p
    VoidNode *n = new VoidNode(newitem);
    n->next = p->next;
    p->next = n;
  }
}


void VoidList::insertSorted(void *newitem, VoidDiff diff, void *extra)
{
  // put it first?
  if (!top ||
      diff(newitem, top->data, extra) <= 0) {                // newitem <= top
    prepend(newitem);
    return;
  }

  // we will be considering adding 'newitem' *after* cursor, as we go
  VoidNode *cursor = top;
  while (cursor->next != NULL &&
         diff(cursor->next->data, newitem, extra) < 0) {     // cursor->next < newitem
    cursor = cursor->next;
  }
  
  // insert 'newitem' after 'cursor'
  VoidNode *newNode = new VoidNode(newitem);
  newNode->next = cursor->next;
  cursor->next = newNode;
}


// ----------------- list-as-set stuff -------------------
// get the index of an item's first occurrance
int VoidList::indexOf(void *item) const
{
  int index = 0;
  for (VoidNode *p = top; p != NULL; p = p->next, index++) {
    if (p->data == item) {
      return index;
    }
  }
  return -1;
}


int VoidList::indexOfF(void *item) const
{
  int ret = indexOf(item);
  xassert(ret >= 0);
  return ret;
}


bool VoidList::prependUnique(void *newitem)
{
  if (!contains(newitem)) {
    prepend(newitem);
    return true;
  }
  else {
    return false;   // no change
  }
}


bool VoidList::appendUnique(void *newitem)
{
  if (!top) {
    prepend(newitem);
    return true;
  }

  // walk to the end of list, while checking to
  // see if 'newitem' is already in the list
  VoidNode *p;
  for (p = top; p->next; p = p->next) {
    if (p->data == newitem) {
      return false;      // item is already on list; no change
    }
  }
  if (p->data == newitem) {
    return false;
  }

  p->next = new VoidNode(newitem);
  return true;
}


bool VoidList::removeIfPresent(void *item)
{
  // for now, not a real fast implementation
  int index = indexOf(item);
  if (index == -1) {
    return false;   // not there
  }
  else {
    removeAt(index);
    return true;
  }
}


void VoidList::removeItem(void *item)
{
  bool wasThere = removeIfPresent(item);
  xassert(wasThere);
}

// ----------------- end of list-as-set stuff -------------------


void *VoidList::removeAt(int index)
{
  if (index == 0) {
    xassert(top != NULL);   // element must exist to remove
    VoidNode *temp = top;
    void *retval = temp->data;
    top = top->next;
    delete temp;
    return retval;
  }

  // will look for the node just before the one to delete
  index--;

  VoidNode *p;     
  for (p = top; p->next && index>0;
       p = p->next, index--)
    {}

  if (p->next) {
    // index==0, so p->next is node to remove
    VoidNode *temp = p->next;
    void *retval = temp->data;
    p->next = p->next->next;
    delete temp;
    return retval;
  }
  else {
    // p->next==NULL, so index was too large
    xfailure("Tried to remove an element not on the list");
    return NULL;    // silence warning
  }
}


void VoidList::removeAll()
{
  while (top != NULL) {
    VoidNode *temp = top;
    top = top->next;
    delete temp;
  }
}

            
void VoidList::reverse()
{
  // transfer list to a temporary
  VoidNode *oldlist = top;
  top = NULL;
  
  // prepend all nodes
  while (oldlist != NULL) {
    // take first node from oldlist
    VoidNode *node = oldlist;
    oldlist = oldlist->next;

    // prepend it to new list
    node->next = top;
    top = node;
  }
}


//   The difference function should return <0 if left should come before
// right, 0 if they are equivalent, and >0 if right should come before
// left. For example, if we are sorting numbers into ascending order,
// then 'diff' would simply be subtraction.
//   The 'extra' parameter passed to sort is passed to diff each time it
// is called.
//   O(n^2) time, O(1) space
void VoidList::insertionSort(VoidDiff diff, void *extra)
{
  VoidNode *primary = top;                   // primary sorting pointer
  while (primary && primary->next) {
    if (diff(primary->data, primary->next->data, extra) > 0) {   // must move next node?
      VoidNode *tomove = primary->next;
      primary->next = primary->next->next;    // patch around moving node

      if (diff(tomove->data, top->data, extra) < 0) {           // new node goes at top?
        tomove->next = top;
        top = tomove;
      }

      else {                                  // new node *not* at top
        VoidNode *searcher = top;
        while (diff(tomove->data, searcher->next->data, extra) > 0) {
          searcher = searcher->next;
        }

        tomove->next = searcher->next;        // insert new node into list
        searcher->next = tomove;
      }
    }

    else {
      primary = primary->next;              // go on if no changes
    }
  }
}


// O(n log n) time, O(log n) space
void VoidList::mergeSort(VoidDiff diff, void *extra)
{
  if (top == NULL || top->next == NULL) {
    return;   // base case: 0 or 1 elements, already sorted
  }

  // half-lists
  VoidList leftHalf;
  VoidList rightHalf;

  // divide the list
  {
    // to find the halfway point, we use the slow/fast
    // technique; to get the right node for short lists
    // (like 2-4 nodes), we start fast off one ahead

    VoidNode *slow = top;
    VoidNode *fast = top->next;

    while (fast && fast->next) {
      slow = slow->next;
      fast = fast->next;
      fast = fast->next;
    }

    // at this point, 'slow' points to the node
    // we want to be the last of the 'left' half;
    // the left half will either be the same length
    // as the right half, or one node longer

    // division itself
    rightHalf.top = slow->next;  // top half to right
    leftHalf.top = this->top;    // bottom half to left
    slow->next = NULL;           // cut the link between the halves
  }

  // recursively sort the halves
  leftHalf.mergeSort(diff, extra);
  rightHalf.mergeSort(diff, extra);

  // merge the halves into a single, sorted list
  VoidNode *merged = NULL;       // tail of merged list
  while (leftHalf.top != NULL &&
         rightHalf.top != NULL) {
    // see which first element to select, and remove it
    VoidNode *selected;
    if (diff(leftHalf.top->data, rightHalf.top->data, extra) < 0) {
      selected = leftHalf.top;
      leftHalf.top = leftHalf.top->next;
    }
    else {
      selected = rightHalf.top;
      rightHalf.top = rightHalf.top->next;
    }

    // append it to the merged list
    if (merged == NULL) {
      // first time; special case
      merged = this->top = selected;
    }
    else {
      // 2nd and later; normal case
      merged = merged->next = selected;
    }
  }

  // one of the halves is exhausted; concat the
  // remaining elements of the other one
  if (leftHalf.top != NULL) {
    merged->next = leftHalf.top;
    leftHalf.top = NULL;
  }
  else {
    merged->next = rightHalf.top;
    rightHalf.top = NULL;
  }

  // verify both halves are now exhausted
  xassert(leftHalf.top == NULL &&
          rightHalf.top == NULL);

  // list is sorted
}


bool VoidList::isSorted(VoidDiff diff, void *extra) const
{
  if (isEmpty()) {
    return true;
  }

  void *prev = top->data;
  VoidListIter iter(*this);
  iter.adv();
  for (; !iter.isDone(); iter.adv()) {
    void *current = iter.data();

    if (diff(prev, current, extra) <= 0) {
      // ok: prev <= current
    }
    else {
      return false;
    }

    prev = current;
  }
  
  return true;
}


// attach tail's nodes to this; empty the tail
void VoidList::concat(VoidList &tail)
{
  if (!top) {
    top = tail.top;
  }
  else {
    VoidNode *n = top;
    for(; n->next; n = n->next)
      {}
    n->next = tail.top;
  }

  tail.top = NULL;
}


// attach some of source's nodes to this, removing them from 'source'
void VoidList::stealTailAt(int index, VoidList &source)
{
  if (index == 0) {
    concat(source);
    return;
  }
  
  // find the node in 'source' just before the first one that
  // will be transferred
  VoidNode *beforeTransfer = source.top;
  index--;
  while (index--) {
    beforeTransfer = beforeTransfer->next;
  }
  
  // break off the tail
  VoidNode *tailStart = beforeTransfer->next;
  beforeTransfer->next = NULL;

  // transfer 'tailStart' and beyond to 'this'
  if (!top) {
    top = tailStart;
  }
  else {
    // find the end of 'this' list
    VoidNode *n = top;
    for(; n->next; n = n->next)
      {}
    n->next = tailStart;
  }
}


void VoidList::appendAll(VoidList const &tail)
{ 
  // make a dest iter and move it to the end
  VoidListMutator destIter(*this);
  while (!destIter.isDone()) {
    destIter.adv();
  }

  VoidListIter srcIter(tail);
  for (; !srcIter.isDone(); srcIter.adv()) {
    destIter.append(srcIter.data());
  }
}


VoidList& VoidList::operator= (VoidList const &src)
{
  if (this != &src) {
    removeAll();
    appendAll(src);
  }
  return *this;
}


bool VoidList::equalAsLists(VoidList const &otherList, VoidDiff diff, void *extra) const
{
  return 0==compareAsLists(otherList, diff, extra);
}

int VoidList::compareAsLists(VoidList const &otherList, VoidDiff diff, void *extra) const
{
  VoidListIter mine(*this);
  VoidListIter his(otherList);

  while (!mine.isDone() && !his.isDone()) {
    int cmp = diff(mine.data(), his.data(), extra);
    if (cmp == 0) {
      // they are equal; keep going
    }
    else {
      // unequal, return which way comparison went
      return cmp;
    }

    mine.adv();
    his.adv();
  }

  if (!mine.isDone() || !his.isDone()) {
    // unequal lengths: shorter compares as less
    return mine.isDone()? -1 : +1;
  }

  return 0;        // everything matches
}


bool VoidList::equalAsSets(VoidList const &otherList, VoidDiff diff, void *extra) const
{
  return this->isSubsetOf(otherList, diff, extra) &&
         otherList.isSubsetOf(*this, diff, extra);
}


bool VoidList::isSubsetOf(VoidList const &otherList, VoidDiff diff, void *extra) const
{
  for (VoidListIter iter(*this); !iter.isDone(); iter.adv()) {
    if (!otherList.containsByDiff(iter.data(), diff, extra)) {
      return false;
    }
  }
  return true;
}


bool VoidList::containsByDiff(void *item, VoidDiff diff, void *extra) const
{
  for (VoidListIter iter(*this); !iter.isDone(); iter.adv()) {
    if (0==diff(item, iter.data(), extra)) {
      return true;
    }
  }
  return false;
}


STATICDEF int VoidList::pointerAddressDiff(void *left, void *right, void*)
{
  // originally, left - right which is +ve if right < left
  return
    std::less<void*>()(right, left) ? 1 :
    ((left == right) ? 0 : -1);
}


void VoidList::debugPrint() const
{
  printf("{ ");
  for (VoidListIter iter(*this); !iter.isDone(); iter.adv()) {
    printf("%p ", iter.data());
  }
  printf("}");
}


// --------------- VoidListMutator ------------------
VoidListMutator&
  VoidListMutator::operator=(VoidListMutator const &obj)
{                             
  // we require that the underlying lists be the same
  // because we can't reset the 'list' reference if they
  // aren't
  xassert(&list == &obj.list);

  prev = obj.prev;
  current = obj.current;

  return *this;
}


void VoidListMutator::insertBefore(void *item)
{
  if (prev == NULL) {
    // insert at start of list
    list.prepend(item);
    reset();
  }
  else {
    current = prev->next = new VoidNode(item, current);
  }
}


void VoidListMutator::insertAfter(void *item)
{
  xassert(!isDone());
  current->next = new VoidNode(item, current->next);
}


void VoidListMutator::append(void *item)
{
  xassert(isDone());
  insertBefore(item);
  adv();
}


void *VoidListMutator::remove()
{
  xassert(!isDone());
  void *retval = data();
  if (prev == NULL) {
    // removing first node
    list.top = current->next;
    delete current;
    current = list.top;
  }
  else {
    current = current->next;
    delete prev->next;   // old 'current'
    prev->next = current;
  }
  return retval;
}


// --------------- VoidListIter --------------------
VoidListIter::VoidListIter(VoidList const &list, int pos)
{
  reset(list);
  while (pos--) {
    adv();
  }
}


// -------------- testing --------------
#ifdef TEST_VOIDLIST
#include "sm_test.h"

// assumes we're using pointerAddressDiff as the comparison fn
// (I don't use isSorted because this fn will throw at the disequality,
// whereas isSorted would forget that info)
void verifySorted(VoidList const &list)
{
  int prev = 0;
  VoidListIter iter(list);
  for (; !iter.isDone(); iter.adv()) {
    int current = (int)iter.data();
    xassert(prev <= current);    // numeric address test
    prev = current;
  }
}


#define PRINT(lst) printf("%s: ", #lst); lst.debugPrint(); printf("\n") /* user ; */

void testSorting()
{
  enum { ITERS=100, ITEMS=20 };

  loopi(ITERS) {
    // construct a list (and do it again if it ends up already sorted)
    VoidList list1;
    VoidList list3;     // this one will be constructed sorted one at a time
    int numItems;
    do {
      list1.removeAll();    // clear them in case we have to build it more than once
      list3.removeAll();
      numItems = rand()%ITEMS;
      loopj(numItems) {
        void *toInsert = (void*)( (rand()%ITEMS) * 4 );
        list1.prepend(toInsert);
        list3.insertSorted(toInsert, VoidList::pointerAddressDiff);
      }
    } while (list1.isSorted(VoidList::pointerAddressDiff));

    // list3 should be sorted already
    //PRINT(list3);
    verifySorted(list3);

    // duplicate it for use with other algorithm
    VoidList list2;
    list2 = list1;

    // sort them
    list1.insertionSort(VoidList::pointerAddressDiff);
    xassert(list1.equalAsPointerSets(list2));      // verify intermediate equality
    xassert(!list1.equalAsPointerLists(list2));    // but not elementwise
    list2.mergeSort(VoidList::pointerAddressDiff);
    //PRINT(list1);

    // verify structure
    list1.selfCheck();
    list2.selfCheck();

    // verify length
    xassert(list1.count() == numItems && list2.count() == numItems);

    // verify sortedness
    verifySorted(list1);
    verifySorted(list2);

    // verify equality
    xassert(list1.equalAsPointerLists(list2));
    xassert(list1.equalAsPointerLists(list3));

    // to test as-sets equality
    void *first = list1.first();
    while (list1.removeIfPresent(first))
      {}     // remove all occurrances of 'first'
    xassert(!list1.equalAsPointerSets(list2));
  }
}


void entry()
{
  // first set of tests
  {
    // some sample items
    void *a=(void*)4, *b=(void*)8, *c=(void*)12, *d=(void*)16;

    VoidList list;

    // test simple modifiers and info
    list.append(c);     PRINT(list);   // c
    list.prepend(b);    PRINT(list);   // b c
    list.append(d);     PRINT(list);   // b c d
    list.prepend(a);    PRINT(list);   // a b c d
    list.removeAt(2);   PRINT(list);   // a b d

    xassert( list.count() == 3 &&
             !list.isEmpty() &&
             list.nth(0) == a &&
             list.nth(1) == b &&
             list.nth(2) == d &&
             list.indexOf(a) == 0 &&
             list.indexOf(b) == 1 &&
             list.indexOf(c) == -1 &&
             list.indexOf(d) == 2
           );
    list.selfCheck();

    // test mutator s
    {
      VoidListMutator mut(list);
      mut.adv();
        // now it's pointing at b
      mut.insertAfter(c);
        // now list is (a b c d) and mut points at b still
      verifySorted(list);
      mut.remove();
        // now list is (a c d) and mut points at c
      xassert(mut.data() == c);

      // copy the mutator
      VoidListMutator mut2(mut);
      mut2.adv();
      xassert(mut.data() == c  &&  mut2.data() == d);

      // copy to a normal iterator
      VoidListIter iter(mut);
      iter.adv();
      xassert(iter.data() == d);
      iter.adv();
      xassert(iter.isDone()  &&  mut.data() == c);

      PRINT(list);
    }

    // test appendUnique and prependUnique
    // list starts as (a c d)
    xassert(list.appendUnique(c) == false &&
            list.prependUnique(d) == false &&
            list.prependUnique(b) == true);
      // now it is (b a c d)
    list.removeItem(a);
    xassert(list.removeIfPresent(a) == false);
      // now it is (b c d)
    verifySorted(list);
    PRINT(list);

    // test reverse
    list.reverse();
      // list is now (d c b)
    xassert(list.indexOf(d) == 0 &&
            list.indexOf(c) == 1 &&
            list.indexOf(b) == 2);
    PRINT(list);

    // test stealTailAt
    VoidList thief;
    thief.stealTailAt(1, list);
      // list is now (d)
      // thief is now (c b)
    xassert(list.count() == 1 &&
            list.indexOf(d) == 0 &&
            thief.count() == 2 &&
            thief.indexOf(c) == 0 &&
            thief.indexOf(b) == 1);
  }

  // this hits most of the remaining code
  // (a decent code coverage tool for C++ would be nice!)
  testSorting();

  printf("voidlist ok\n");
}

USUAL_MAIN

#endif // NDEBUG

@h=tangler('elk/sm_vptrmap.cpp')
@select(h)
// vptrmap.cc
// code for vptrmap.h

#include "sm_vptrmap.h"
#include "sm_xassert.h"

#include <stddef.h>      // NULL
#include <cstring>      // std::memset


// ------------------ VoidPtrMap -------------------
int VoidPtrMap::lookups = 0;
int VoidPtrMap::probes = 0;


VoidPtrMap::VoidPtrMap()
  : hashTable(NULL),
    tableSize(0),
    tableSizeBits(0),
    numEntries(0),
    iterators(0)
{
  alloc(4);    // 16 entries initially
  empty();
}

VoidPtrMap::~VoidPtrMap()
{
  delete[] hashTable;
}


void VoidPtrMap::alloc(int bits)
{
  tableSizeBits = bits;
  tableSize = 1 << bits;
  hashTable = new Entry[tableSize];
}


inline unsigned VoidPtrMap::hashFunc(unsigned multiplier, unsigned key) const
{
  // see Cormen/Leiserson/Rivest (CLR), section 12.3.2

  // multiply, throwing away the overflow high bits
  unsigned ret = key * multiplier;

  // we want to extract the 'tableSizeBits' most sigificant bits
  ret = ret >> ((sizeof(unsigned)*8) - tableSizeBits);
  ret = ret & (tableSize-1);
  
  return ret;
}


VoidPtrMap::Entry &VoidPtrMap::findEntry(void const *key) const
{
  xassert(key != NULL);
  lookups++;

  // constants used in the hash functions
  enum {
    // value is  floor(  (sqrt(5)-1)/2 * 2^32  )
    //
    // This is the golden ratio.  CLR says Knuth says it's good.
    CONST1 = 0x9E3779B9U,

    // value is  floor(  (sqrt(3)-1)/2 * 2^32  )
    //
    // Some random website claims irrational constants are good,
    // and I can't find any source (I don't have Knuth..) for
    // another constant, so I just decided to substitute 3 for
    // 5 in the golden ratio formula.  Since I trust this one
    // less, I use it for the less important role (stride).
    CONST2 = 0x5DB3D742U
  };

  // compute first hash function, which gives the starting index
  // for the probe sequence
  unsigned index = hashFunc(CONST1, (SM_RAWADDRESS)key);

  // analyze the first entry now, before computing the second
  // hash function (stride) value
  {
    probes++;
    Entry &e = hashTable[index];
    if (e.key == NULL ||
        e.key == key) {
      return e;
    }
  }

  // compute stride; it has to be odd so that it is relatively
  // prime to the table size (which is a power of 2), so I just
  // turn on the least significant bit
  unsigned stride = hashFunc(CONST2, (SM_RAWADDRESS)key) | 1;

  // uncomment this to experiment with linear hashing; when ITERS2MAX
  // is 10000, I see a small increase in avgprobes when using linear
  // hashing over double hashing
  //unsigned stride = 1;

  // collision; stride over the entries
  for (int i=0; i<tableSize; i++) {
    index = (index + stride) & (tableSize-1);

    probes++;
    Entry &e = hashTable[index];
    if (e.key == NULL ||
        e.key == key) {
      return e;
    }
  }

  // searched all entries with no success; but if this happens,
  // then our load factor must be 1, which violates the invariant
  // that numEntries < tableSize
  xfailure("findEntry traversed all entries");
  return *((Entry*)NULL);     // silence warning
}


void VoidPtrMap::add(void *key, void *value)
{
  xassert(iterators == 0);

  // if load factor would exceed 3/4, expand
  if (numEntries+1 > (tableSize/2 + tableSize/4)) {
    expand();
  }

  Entry &e = findEntry(key);
  if (e.key == NULL) {
    e.key = key;              // new mapping
    numEntries++;
  }
  else {
    xassert(e.key == key);    // update existing mapping
  }
  e.value = value;
}


void VoidPtrMap::expand()
{
  Entry *oldHashTable = hashTable;
  int oldTableSize = tableSize;

  alloc(tableSizeBits + 1);
  empty();

  // re-insert all of the old elements
  for (int i=0; i < oldTableSize; i++) {
    Entry &e = oldHashTable[i];
    if (e.key) {
      add(e.key, e.value);
    }
  }

  delete[] oldHashTable;
}


void VoidPtrMap::empty()
{
  xassert(iterators == 0);

  // establishes invariant that NULL keys have NULL values
  std::memset(hashTable, 0, sizeof(*hashTable) * tableSize);
  numEntries = 0;
}


// ------------------- VoidPtrMap::Iter ------------------
VoidPtrMap::Iter::Iter(VoidPtrMap const &m)
  : map(m),
    index(map.tableSize)
{
  map.iterators++;
  adv();
}

VoidPtrMap::Iter::~Iter()
{
  map.iterators--;
}


void VoidPtrMap::Iter::adv()
{
  xassert(index >= 0);
  index--;
  while (index >= 0 &&
         map.hashTable[index].key == NULL) {
    index--;
  }
}


// ------------------- test code ---------------------
#ifdef TEST_VPTRMAP

#include "sm_test.h"
#include "sm_array.h"
#include "sm_ckheap.h"
#include "sm_ptrmap.h"

#include <stdlib.h>    // rand, qsort
#include <stdio.h>     // printf


class Node {
public:
  int *value;
  bool found;

public:
  Node() {
    value = new int(0);
    found = false;
  }
  ~Node() {
    delete value;
  }
};


int doubleCompar(void const *dp1, void const *dp2)
{
  double d1 = *((double*)dp1);
  double d2 = *((double*)dp2);
  if (d1 < d2) return -1;
  if (d1 > d2) return +1;
  return 0;    // almost never happens
}


void test1()
{
  printf("test1: testing PtrMap\n");

  enum { ITERS1=10, ITERS2MAX=2000 };

  double avgprobes[ITERS1];

  printf("  iter  iters  entries  lookups  probes  avgprobes\n");
  printf("  ----  -----  -------  -------  ------  ---------\n");

  for (int i=0; i < ITERS1; i++) {
    // I actually test PtrMap, the type-safe wrapper on top
    // of VoidPtrMap, so I can test that class too; the casts
    // that I used to need for VoidPtrMap are now protected by
    // this CAST macro
    //#define CAST(something) (something)
    #define CAST(something) /*nothing*/

    PtrMap<Node,int> map;
    ObjArrayStack<Node> stack;

    int iters2 = rand() % ITERS2MAX;
    for (int j=0; j < iters2; j++) {
      int op = rand() % 100;

      if (op <= 40) {         // insert
        Node *n = new Node;
        stack.push(n);
        map.add(n, n->value);
      }

      else if (op <= 80) {    // find exist
        if (stack.isNotEmpty()) {
          Node *n = stack[rand() % stack.length()];
          int *v = CAST(int*)map.get(n);
          xassert(v && v == n->value);

          if (rand() % 10 == 0) {
            // reassign
            delete n->value;
            n->value = new int(0);
            map.add(n, n->value);
          }
        }
      }

      else if (op <= 90) {    // find non-exist
        Node *n = new Node;
        int *v = CAST(int*)map.get(n);
        xassert(!v);
        delete n;
      }

      else if (op <= 100) {   // traverse
        // clear all 'found'
        int k;
        for (k=0; k < stack.length(); k++) {
          stack[k]->found = false;
        }

        // walk via map; should find each one exactly once
        int numFound = 0;
        //VoidPtrMap::Iter iter(map);
        PtrMap<Node,int>::Iter iter(map);
        for (; !iter.isDone(); iter.adv()) {
          Node *n = CAST(Node*)iter.key();
          int *v = CAST(int*)iter.value();

          xassert(v == n->value);
          xassert(n->found == false);
          n->found = true;
          numFound++;
        }

        // check all 'found' (launch all 'zig')
        for (k=0; k < stack.length(); k++) {
          xassert(stack[k]->found == true);
        }
        xassert(numFound == stack.length());
      }
    }

    xassert(map.getNumEntries() == stack.length());
    //     "  iter  iters  entries  lookups  probes  avgprobes"
    avgprobes[i] = ((double)VoidPtrMap::probes) / ((double)VoidPtrMap::lookups);
    printf("  %4d  %5d  %7d  %7d  %6d    %g\n",
           i,
           iters2,
           map.getNumEntries(),
           VoidPtrMap::lookups,
           VoidPtrMap::probes,
           avgprobes[i]);

    VoidPtrMap::probes = 0;
    VoidPtrMap::lookups = 0;
  }

  // compute median of avgprobes
  qsort(avgprobes, ITERS1, sizeof(avgprobes[0]), doubleCompar);
  printf("median avgprobe: %g\n", avgprobes[ITERS1/2]);

  //malloc_stats();
}


struct A {
  int x;
  A(int x0) : x(x0) {}
};

void test2()
{
  printf("test2: testing PtrSet\n");

  PtrSet<A> s;
  xassert(s.isEmpty());
  xassert(s.getNumEntries() == 0);

  A *a1 = new A(1);
  s.add(a1);
  xassert(s.isNotEmpty());
  xassert(s.getNumEntries() == 1);

  A *a2 = new A(2);
  s.add(a2);
  xassert(s.isNotEmpty());
  xassert(s.getNumEntries() == 2);

  xassert(s.contains(a1));
  xassert(s.contains(a2));

  s.empty();                    // make empty

  xassert(!s.contains(a1));
  xassert(!s.contains(a2));
  xassert(s.isEmpty());
  xassert(s.getNumEntries() == 0);

  A *a3 = new A(3);
  s.add(a3);
  xassert(s.isNotEmpty());
  xassert(s.getNumEntries() == 1);
}


void entry()
{
  printf("testing vptrmap\n");
  test1();
  test2();
  printf("vptrmap is ok\n");
}


USUAL_MAIN

#endif // TEST_VPTRMAP
@h=tangler('elk/sm_breaker.cpp')
@select(h)
// breaker.cc            see license.txt for copyright and terms of use
// code for breaker.h
// Scott McPeak, 1997,1998  This file is public domain.

#include "sm_breaker.h"

#ifdef __BORLANDC__
# pragma warn -use
#endif

void ackackack(int*) {}

void breaker()
{
  static int i=0;
  int a=1;               // all this junk is just to make sure
                         // that this function has a complete
  ackackack(&a);         // stack frame, so the debugger can unwind
  i++;                   // the stack
}

#ifdef __BORLANDC__
#  pragma warn .use
#endif

// (tweak for CVS)
@h=tangler('elk/sm_crc.cpp')
@select(h)
// crc.cc            see license.txt for copyright and terms of use
// adapted slightly by Scott McPeak

// originally was:
/* crc32h.c -- package to compute 32-bit CRC one byte at a time using   */
/*             the high-bit first (Big-Endian) bit ordering convention  */
/*                                                                      */
/* Synopsis:                                                            */
/*  gen_crc_table() -- generates a 256-word table containing all CRC    */
/*                     remainders for every possible 8-bit byte.  It    */
/*                     must be executed (once) before any CRC updates.  */
/*                                                                      */
/*  unsigned update_crc(crc_accum, data_blk_ptr, data_blk_size)         */
/*           unsigned crc_accum; char *data_blk_ptr; int data_blk_size; */
/*           Returns the updated value of the CRC accumulator after     */
/*           processing each byte in the addressed block of data.       */
/*                                                                      */
/*  It is assumed that an unsigned long is at least 32 bits wide and    */
/*  that the predefined type char occupies one 8-bit byte of storage.   */
/*                                                                      */
/*  The generator polynomial used for this version of the package is    */
/*  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+x^0 */
/*  as specified in the Autodin/Ethernet/ADCCP protocol standards.      */
/*  Other degree 32 polynomials may be substituted by re-defining the   */
/*  symbol POLYNOMIAL below.  Lower degree polynomials must first be    */
/*  multiplied by an appropriate power of x.  The representation used   */
/*  is that the coefficient of x^0 is stored in the LSB of the 32-bit   */
/*  word and the coefficient of x^31 is stored in the most significant  */
/*  bit.  The CRC is to be appended to the data most significant byte   */
/*  first.  For those protocols in which bytes are transmitted MSB      */
/*  first and in the same order as they are encountered in the block    */
/*  this convention results in the CRC remainder being transmitted with */
/*  the coefficient of x^31 first and with that of x^0 last (just as    */
/*  would be done by a hardware shift register mechanization).          */
/*                                                                      */
/*  The table lookup technique was adapted from the algorithm described */
/*  by Avram Perez, Byte-wise CRC Calculations, IEEE Micro 3, 40 (1983).*/

#define POLYNOMIAL 0x04c11db7L

static unsigned long crc_table[256];

void gen_crc_table()
 /* generate the table of CRC remainders for all possible bytes */
 { register int i, j;  register unsigned long crc_accum;
   for ( i = 0;  i < 256;  i++ )
       { crc_accum = ( (unsigned long) i << 24 );
         for ( j = 0;  j < 8;  j++ )
              { if ( crc_accum & 0x80000000L )
                   crc_accum =
                     ( crc_accum << 1 ) ^ POLYNOMIAL;
                else
                   crc_accum =
                     ( crc_accum << 1 ); }
         crc_table[i] = crc_accum; }
   return; }

unsigned long update_crc(unsigned long crc_accum, char const *data_blk_ptr,
                                                    int data_blk_size)
 /* update the CRC on the data block one byte at a time */
 { register int i, j;
   for ( j = 0;  j < data_blk_size;  j++ )
       { i = ( (int) ( crc_accum >> 24) ^ *data_blk_ptr++ ) & 0xff;
         crc_accum = ( crc_accum << 8 ) ^ crc_table[i]; }
   return crc_accum; }


// SM: block-level application
static int made_table = 0;
unsigned long crc32(unsigned char const *data, int length)
{
  if (!made_table) {
    gen_crc_table();
    made_table = 1;
  }

  return update_crc(0xFFFFFFFF, (char*)data, length);
}


// ----------------- test code ------------------------------
#ifdef TEST_CRC

#include <stdio.h>     // printf, FILE, etc.
#include <stdlib.h>    // malloc


int errors=0;

void testCrc(char const *data, int length, unsigned long crc)
{     
  unsigned long val = crc32((unsigned char*)data, length);
  printf("computed crc is 0x%08lX, expected is 0x%08lX\n",
         val, ~crc);       // why is 'crc' inverted?
  if (val != ~crc) {
    errors++;
  }
}


int main(int argc, char *argv[])
{
  // if there's an argument, crc that
  if (argc >= 2) {
    FILE *fp = fopen(argv[1], "r");
    if (!fp) {
      printf("error opening %s: %m\n", argv[1]);
      return 2;
    }

    // get length
    fseek(fp, 0, SEEK_END);
    int len = ftell(fp);
    fseek(fp, 0, SEEK_SET);

    // read the entire contents
    unsigned char *buf = (unsigned char*)malloc(len);
    if (fread(buf, 1, len, fp) != (size_t)len) {
      printf("read error, or short count..\n");
      return 2;
    }

    // crc it
    long val = crc32(buf, len);
    printf("crc32: 0x%08lX\n", val);

    return 0;
  }

  /* 40 Octets filled with "0" */
  /* CPCS-UU = 0, CPI = 0, Length = 40, CRC-32 = 864d7f99 */
  char pkt_data1[48]={0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
                      0x00,0x00,0x00,0x28,0x86,0x4d,0x7f,0x99};

  /* 40 Octets filled with "1" */
  /* CPCS-UU = 0, CPI = 0, Length = 40, CRC-32 = c55e457a */
  char pkt_data2[48]={0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                      0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,
                      0x00,0x00,0x00,0x28,0xc5,0x5e,0x45,0x7a};

  /* 40 Octets counting: 1 to 40 */
  /* CPCS-UU = 0, CPI = 0, Length = 40, CRC-32 = bf671ed0 */
  char pkt_data3[48]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,
                      0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,
                      0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,
                      0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
                      0x00,0x00,0x00,0x28,0xbf,0x67,0x1e,0xd0};

  /* 40 Octets counting: 1 to 40 */
  /* CPCS-UU = 11, CPI = 22, CRC-32 = acba602a */
  char pkt_data4[48]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,
                      0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,
                      0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e,
                      0x1f,0x20,0x21,0x22,0x23,0x24,0x25,0x26,0x27,0x28,
                      0x11,0x22,0x00,0x28,0xac,0xba,0x60,0x2a};

  testCrc(pkt_data1, 44, 0x864d7f99);
  testCrc(pkt_data2, 44, 0xc55e457a);
  testCrc(pkt_data3, 44, 0xbf671ed0);
  testCrc(pkt_data4, 44, 0xacba602a);

  return errors;
}

#endif // TEST_CRC



@h=tangler('elk/sm_datablok.cpp')
@select(h)
// datablok.cc            see license.txt for copyright and terms of use
// code for datablok.h
// Scott McPeak, 1998-2000  This file is public domain.

#include "sm_datablok.h"
#include "sm_exc.h"
#include "sm_crc.h"
#include "sm_syserr.h"

#include <stdio.h>        // printf
#include <cstring>       // std::memcpy
#include <ctype.h>        // isprint
    
    
// define the endpost byte as something we hope is
// unlikely to coincidentally be written during an
// overrun
byte const DataBlock::endpost = 0xBB;
    
    
void DataBlock::init(int allocatedSize)
{
  xassert(allocatedSize >= 0);
  dataLen = 0;
  allocated = allocatedSize;
  if (allocated) {
    data = allocate(allocated);
  }
  else {
    data = NULL;
  }
    
  SELFCHECK();
}
    
    
STATICDEF byte *DataBlock::allocate(int size)
{
  byte *ret = new byte[size+1];
  ret[size] = endpost;
  return ret;
}
    
    
void DataBlock::selfCheck() const
{
  if (!( 0 <= dataLen && dataLen <= allocated )) {
    breaker();    // having trouble discovering the precise state under gdb
  }
  xassert(0 <= dataLen && dataLen <= allocated);
  xassert( (data==NULL) == (allocated==0) );
  xassert( data==NULL || data[allocated]==endpost );
}
    
    
DataBlock::DataBlock(int allocatedSize)
{
  init(allocatedSize);
  SELFCHECK();
}
    

DataBlock::DataBlock(char const *srcString)
{
  init(0);
  setFromString(srcString);
  SELFCHECK();
}
    
    
void DataBlock::ctor(byte const *srcData, int dataLen)
{
  init(0);
  setFromBlock(srcData, dataLen);
  SELFCHECK();
}


void DataBlock::ctor(byte const *srcData, int srcDataLen, int allocatedSize)
{
  init(allocatedSize);
  dataLen = srcDataLen;
  std::memcpy(data, srcData, dataLen);
  SELFCHECK();
}
    
    
DataBlock::DataBlock(DataBlock const &obj)
{
  init(obj.allocated);
  copyCtorShared(obj);
}

void DataBlock::copyCtorShared(DataBlock const &obj)
{
  dataLen = obj.dataLen;
  if (dataLen > 0) {
    std::memcpy(data, obj.data, dataLen);
  }
  SELFCHECK();
}


DataBlock::DataBlock(DataBlock const &obj, int minToAllocate)
{
  init(max(obj.getAllocated(), minToAllocate));
  copyCtorShared(obj);
}
    
    
DataBlock::~DataBlock()
{
  try {
    SELFCHECK();
    if (data) {
      delete[] data;
    }
  }
  CAUTIOUS_RELAY
}
    
    
bool DataBlock::allEqual(DataBlock const &obj) const
{
  SELFCHECK();
  return allocated == obj.allocated &&
         dataEqual(obj);
}


bool DataBlock::dataEqual(DataBlock const &obj) const
{
  SELFCHECK();
  if (dataLen != obj.dataLen ||
      (dataLen > 0 &&
       0 != std::memcmp(data, obj.data, dataLen))) {
    return false;
  }
  else {
    return true;
  }
}



void DataBlock::setDataLen(int newLen)
{
  SELFCHECK();
  xassert(0 <= newLen && newLen <= allocated);
  dataLen = newLen;
  SELFCHECK();
}
    
    
void DataBlock::setAllocated(int newAllocated)
{
  SELFCHECK();
  xassert(newAllocated >= 0);
  if (allocated != newAllocated) {
    // allocate new buffer
    byte *newData = NULL;
    if (newAllocated > 0) {
      newData = allocate(newAllocated);
    }

    // truncate defined data
    if (dataLen > newAllocated) {
      dataLen = newAllocated;
    }
    
    // transfer data
    if (dataLen > 0) {
      std::memcpy(newData, data, dataLen);
    }
    
    // deallocate old buffer and replace with new buffer
    delete[] data;
    data = newData;
    allocated = newAllocated;
  }
  SELFCHECK();
}
    

void DataBlock::ensureAtLeast(int minAllocated)
{
  if (allocated < minAllocated) {
    setAllocated(minAllocated);
  }
}


void DataBlock::growDataLen(int changeAmount)
{
  ensureAtLeast(getDataLen() + changeAmount);
  changeDataLen(changeAmount);
}


void DataBlock::addNull()
{
  SELFCHECK();
  data[dataLen] = 0;
  setDataLen(dataLen + 1);
  SELFCHECK();
}
    

void DataBlock::setFromString(char const *srcString)
{
  SELFCHECK();
  int len = std::strlen(srcString)+1;
    // a sm_string is its contents and the null terminator
  setFromBlock((byte const*)srcString, len);
  SELFCHECK();
}
    
void DataBlock::setFromBlock(byte const *srcData, int len)
{
  SELFCHECK();
  if (len > allocated) {
    setAllocated(len);
  }
  setDataLen(len);
  if (len > 0) {
    std::memcpy(data, srcData, len);
  }
  SELFCHECK();
}


DataBlock& DataBlock::operator= (DataBlock const &obj)
{
  SELFCHECK();
  if (this != &obj) {
    setAllocated(obj.allocated);
    dataLen = obj.dataLen;
    std::memcpy(data, obj.data, dataLen);
  }
  SELFCHECK();
  return *this;
}


void DataBlock::print(char const *label, int bytesPerLine) const
{
  xassert(bytesPerLine >= 1);
  SELFCHECK();

  if (label) {
    printf("---- %s, length = %d, crc32 = 0x%lX ---- {\n",
           label, getDataLen(),
           crc32(getDataC(), getDataLen()));
  }

  int cursor = 0;
  while (cursor < getDataLen()) {
    int linelen = min(bytesPerLine, getDataLen() - cursor);
    xassert(linelen >= 1);    // ensure can't loop infinitely

    printf("  ");     // indent
    printHexLine(getDataC() + cursor, linelen, bytesPerLine);
    printf("   ");
    printPrintableLine(getDataC() + cursor, linelen);
    printf("\n");

    cursor += linelen;
  }

  if (label) {
    printf("}\n");
  }
  SELFCHECK();
}


// print 'length' bytes of 'data' in hex
// blank-pad the output as if 'linelen' bytes were present
STATICDEF void DataBlock::printHexLine(byte const *data, int length, int linelen)
{
  xassert(data != NULL &&
          length >= 1 &&
          linelen >= length);

  for (int i=0; i<linelen; i++) {
    if (i < length) {
      printf("%02X ", (byte)*data);
      data++;
    }
    else {
      printf("   ");
    }
  }
}


// print 'length' bytes of 'data', substituting 'unprintable' for bytes for
// which 'isprint' is false
STATICDEF void DataBlock::printPrintableLine(byte const *data, int length,
                                             char unprintable)
{
  xassert(data != NULL &&
          length >= 1);

  while (length--) {
    if (isprint(*data)) {
      printf("%c", *data);
    }
    else {
      printf("%c", unprintable);
    }
    data++;
  }
}


#if 0
void DataBlock::print(char const *label) const
{
  enum { MARGIN = 70 };

  if (label) {
    printf("------ %s (length=%d) -------\n", label, getDataLen());
  }

  byte *p = data;
  int i;
  int column=0;
  for (i=0; i<dataLen; i++, p++) {
    if (isprint(*p)) {
      if (*p != '\\') {
        column += printf("%c", *p);
      }
      else {
        printf("\\\\");     // otherwise '\\','x','nn','nn' would be ambiguous
      }
    }
    else {
      column += printf("\\x%02X", *p);
    }

    if (column >= MARGIN && (i+1) < dataLen) {
      printf("\\\n");       // continuation lines end with backslash
      column = 0;
    }
  }

  // this makes spaces at the end of a buffer invisible.. oh well..
  if (column != 0) {    // if didn't just newline...
    printf("\n");
  }

  if (label) {
    printf("------ end of %s -------\n", label);
  }
}
#endif // 0


void DataBlock::dontPrint(char const *, int) const
{}


void DataBlock::writeToFile(char const *fname) const
{
  FILE *fp = fopen(fname, "wb");
  if (!fp) {
    xsyserror("fopen", fname);
  }

  // finally giving in and silencing those *stupid* g++ warnings
  // about comparing signed and unsigned for EQUALITY!!!
  // I'll get you yet, you big stinking GNU!!
  if ((int)fwrite(getDataC(), 1, getDataLen(), fp) != getDataLen()) {
    xsyserror("fwrite", fname);
  }

  if (fclose(fp) != 0) {
    xsyserror("fclose", fname);
  }
}


void DataBlock::readFromFile(char const *fname)
{
  FILE *fp = fopen(fname, "rb");
  if (!fp) {
    xsyserror("fopen", fname);
  }

  // seek to end to know how much to allocate
  if (fseek(fp, 0, SEEK_END) != 0) {
    xsyserror("fseek", fname);
  }

  long len = ftell(fp);
  if (len < 0) {
    xsyserror("ftell", fname);
  }

  setAllocated(len);

  // read data
  if (fseek(fp, 0, SEEK_SET) != 0) {
    xsyserror("fseek", fname);
  }

  if ((long)fread(getData(), 1, len, fp) != len) {
    xsyserror("fread", fname);
  }

  setDataLen(len);

  if (fclose(fp) != 0) {
    xsyserror("fclose", fname);
  }
}


// ------------- self test code --------------
#ifdef DATABLOK_TEST

int doit()
{
  // nest everything so the dtors are inside
  {
    // test printing function
    {
      DataBlock b(260);
      for (int i=0; i<260; i++) {
        b.getData()[i] = (byte)i;
      }
      b.setDataLen(260);
      b.print("all bytes plus 4 extra");
    }

    DataBlock block("yadda smacker");
    xassert(block.getDataLen() == 14);

    DataBlock block2((byte*)"yadda smacker", 13, 14);
    block2.addNull();
    xassert(block == block2);

    DataBlock block3;
    block3 = block2;
    xassert(block3 == block);

    block3.setAllocated(5);       // truncates
    block2.setAllocated(25);
    xassert(block3 != block2);

    // test file save/load
    block.writeToFile("tempfile.blk");
    DataBlock block4;
    block4.readFromFile("tempfile.blk");
    xassert(block == block4);

    // test overrun detection
    try {
      {
        DataBlock b(block);
        b.getData()[block.getAllocated()] = 0;   // overrun

        printf("this should cause an assertion failure:\n");
        // invoke selfcheck in destructor
      }
      return printf("failed to detect overrun\n");
    }
    catch (...) {}
  }
    
  printf("test succeeded\n");
  return 0;
}
    
int main()
{
  try {
    return doit();
  }
  catch (xBase &x) {
    return printf("failed: %s\n", x.why());
  }
}
    
#endif // DATABLOK_TEST

@h=tangler('elk/sm_exc.cpp')
@select(h)
// exc.cc            see license.txt for copyright and terms of use
// code for exc.h
// Scott McPeak, 1996-1998  This file is public domain.

#include "sm_exc.h"

#include <cstring>       // std::strlen, std::strcpy
#include <iostream>     // clog
#include <stdarg.h>       // va_xxx
#include <ctype.h>        // toupper, tolower


// ------------------------- xBase -----------------
bool xBase::logExceptions = true;
int xBase::creationCount = 0;


xBase::xBase(char const *m)
  : msg(m)
{
  if (logExceptions) {
    std::clog << "Exception thrown: " << m << std::endl;
  }

  // done at very end when we know this object will
  // successfully be created
  creationCount++;
}


xBase::xBase(xBase const &obj)
  : msg(obj.msg)
{
  creationCount++;
}


xBase::~xBase()
{
  creationCount--;
}


// this is obviously not perfect, since exception objects can be
// created and not thrown; I heard the C++ standard is going to,
// or already does, include (by this name?) a function that does this
// correctly; until then, this will serve as a close approximation
// (this kind of test is, IMO, not a good way to handle the underlying
// problem, but it does reasonably handle 70-90% of the cases that
// arise in practice, so I will endorse it for now)
bool unwinding()
{
  return xBase::creationCount != 0;
}


// tweaked version
bool unwinding_other(xBase const &)
{
  // we know the passed xBase exists.. any others?
  return xBase::creationCount > 1;
}


void xBase::insert(std::ostream &os) const
{
  os << why();
}


void xbase(char const *msg)
{
  xBase x(msg);
  THROW(x);
}


// ------------------- x_assert -----------------
x_assert::x_assert(char const *cond, char const *fname, int line)
  : xBase(sm_stringb(
      "Assertion failed: " << cond <<
      ", file " << fname <<
      " line " << line)),
    condition(cond),
    filename(fname),
    lineno(line)
{}

x_assert::x_assert(x_assert const &obj)
  : xBase(obj),
    condition(obj.condition),
    filename(obj.filename),
    lineno(obj.lineno)
{}

x_assert::~x_assert()
{}


// failure function, declared in xassert.h
void x_assert_fail(char const *cond, char const *file, int line)
{
  THROW(x_assert(cond, file, line));
}


// --------------- xFormat ------------------
xFormat::xFormat(char const *cond)
  : xBase(sm_stringb("Formatting error: " << cond)),
    condition(cond)
{}

xFormat::xFormat(xFormat const &obj)
  : xBase(obj),
    condition(obj.condition)
{}

xFormat::~xFormat()
{}


void xformat(char const *condition)
{
  xFormat x(condition);
  THROW(x);
}

void formatAssert_fail(char const *cond, char const *file, int line)
{
  xFormat x(sm_stringc << "format assertion failed, " 
                    << file << ":" << line << ": "
                    << cond);
  THROW(x);
}


// -------------------- XOpen -------------------
XOpen::XOpen(char const *fname)
  : xBase(sm_stringc << "failed to open file: " << fname),
    filename(fname)
{}

XOpen::XOpen(XOpen const &obj)
  : xBase(obj),
    DMEMB(filename)
{}

XOpen::~XOpen()
{}


void throw_XOpen(char const *fname)
{
  XOpen x(fname);
  THROW(x);
}


// ---------------- test code ------------------
#ifdef TEST_EXC

int main()
{
  xBase x("yadda");
  std::cout << x << std::endl;

  try {
    THROW(x);
  }
  catch (xBase &x) {
    std::cout << "caught xBase: " << x << std::endl;
  }

  return 0;
}

#endif // TEST_EXC

@h=tangler('elk/sm_missing.cpp')
@select(h)
// missing.cc            see license.txt for copyright and terms of use
// code for missing.h
// Scott McPeak, 1998  This file is public domain.

#include "sm_missing.h"

#include <ctype.h>       // tolower

int missing_stricmp(char const *s1, char const *s2)
{
  while (*s1 && *s2) {
    // the choice between tolower and toupper affects lexicographic
    // comparisons between letters and the symbols between Z and a;
    // I don't know which is the "correct" way.
    int d = tolower(*s1) - tolower(*s2);
    if (d != 0) {
      return d;
    }
    s1++;
    s2++;
  }

  // one or both are at the null terminator
  return *s1 - *s2;
}
@h=tangler('elk/sm_nonport.cpp')
@select(h)
// nonport.cpp            see license.txt for copyright and terms of use
// code for nonport.h
// Scott McPeak and Dan Bonachea, 1998-1999  This file is public domain.

#include <stdio.h>       // printf
#include <stdlib.h>      // abort, exit
#include <cstring>      // std::strncpy

#ifdef __WIN32__
#  ifdef USE_MINWIN_H
#    include "minwin.h"   // api
#  else
#    include <windows.h>  // api
#  endif

#  include <strstream>   // ostrstream
#  include <conio.h>      // getch or _getch
#  include <dos.h>        // sleep
#  include <io.h>         // chmod
#  ifdef __BORLANDC__
#    include <dir.h>      // mkdir, chdir
#    pragma warn -par     // warning: parameter not used
#  else    // MSVC
#    include <errno.h> // ENOENT
#    include <direct.h>   // _mkdir, _chdir
#    define getch _getch
#    define mkdir _mkdir    // why must VC be such an oddball?
#    define chdir _chdir
#    define chmod _chmod
     void sleep(unsigned sec) {
       Sleep(sec * 1000);
       return;
       }
#  endif
#  define DIRSLASH '\\'
#  define DIRSLASHES "\\/"

#else   // unix
#  include <sys/time.h>   // struct timeval, gettimeofday
#  include <sys/types.h>  // mkdir constants, DIR, struct dirent
#  include <fcntl.h>      // mkdir constants
#  include <unistd.h>     // mkdir, sleep, chdir, geteuid
#  include <errno.h>      // errno
#  include <pwd.h>        // getpwuid, struct passwd
#  define DIRSLASH '/'
#  define DIRSLASHES "/"

#endif

#include <sys/stat.h>     // chmod, mode macros
#include <time.h>         // tzset, localtime, time
#include <iostream>     // std::cout

#if !defined(__WIN32__) || defined(__BORLANDC__)
  #include <dirent.h>       // opendir
#endif

#include "sm_nonport.h"


NonportFailFunc nonportFail = defaultNonportFail;

void defaultNonportFail(char const *, char const *)
{}

// convenience
inline void fail(char const *call, char const *ctx=NULL)
{
  nonportFail(call, ctx);
}


void setRawMode(bool raw)
{
# ifdef __WIN32__
    // nothing necessary; getConsoleChar handles it

# else
    int res;
    if (raw) {
      // turn off UNIX term output, put in raw mode
      res = system("stty -echo raw");
    }
    else {
      // back to normal mode
      res = system("stty echo -raw");
    }

    if (res != 0) {
      //fail("system", "setRawMode");
    }
# endif
}


// get the next character typed, without any intervening interpretation
// or buffering
char getConsoleChar()
{
# ifdef __WIN32__
    // this function always bypasses 'cooked' console mode
    return (char)getch();

# else
    // relies on raw mode for console
    int ch = getchar();
    if (ch == EOF) {
      fail("getchar", "getConsoleChar");
    }
    return ch;
# endif
}


// return the # of milliseconds since some unspecified, but
// constant for the life of the program, event
long getMilliseconds()
{
# ifdef __WIN32__
    // # of milliseconds since program started
    return GetTickCount();

# else
    // some unspecified millisecond count (unspecified
    // because tv.tv_sec * 1000 will overflow a 32-bit
    // long, for typical values)
    struct timeval tv;
    gettimeofday(&tv, NULL);
      // according to HPUX man page, this always returns 0 and does
      // not have any errors defined

    //printf("tv.tv_sec = %d, tv.tv_usec = %d\n",
    //       tv.tv_sec, tv.tv_usec);
    return tv.tv_sec * 1000 + tv.tv_usec / 1000;
# endif
}


bool limitFileAccess(char const *fname)
{
  // read/write for user, nothing for group or others
  if (chmod(fname, 0600) != 0) {
    fail("chmod", fname);
    return false;
  }
  else {
    return true;
  }
}


bool createDirectory(char const *dirname)
{
  int res;
# ifdef __WIN32__
    // no 'mode' argument
    res = mkdir(dirname);
# else   // unix
    // read/write/execute permission for user, no one else
    res = mkdir(dirname, S_IRUSR | S_IWUSR | S_IXUSR);
# endif

  if (res != 0) {
    fail("mkdir", dirname);
    return false;
  }
  else {
    return true;
  }
}


bool changeDirectory(char const *dirname)
{
  if (0!=chdir(dirname)) {
    fail("chdir", dirname);
    return false;
  }
  else {
    return true;
  }
}


bool getCurrentDirectory(char *dirname, int len)
{
  bool ok = getcwd(dirname, len) != NULL;
  if (!ok) {
    fail("getcwd");
  }
  return ok;
}


bool removeFile(char const *fname)
{
  bool ok = unlink(fname) == 0;
  if (!ok) {
    fail("unlink", fname);
  }
  return ok;
}


// this may in fact use a portable subset of the standard
// C library.. but I'm not holding my breath, so that's why
// this routine is in the 'nonport' module
void getCurrentDate(int &month, int &day, int &year)
{
  // tzset is apparently required (recommended?) before
  // calling localtime()
  #if !defined(__CYGWIN__)
  tzset();
  #endif

  // retrieve standard UNIX time
  time_t unixTime;
  time(&unixTime);

  // convert to month/day/year
  struct tm *t = localtime(&unixTime);

  // write into return variables
  month = t->tm_mon + 1;
  day = t->tm_mday;
  year = t->tm_year + 1900;    // this is not a y2k bug!
}


void portableSleep(unsigned seconds)
{
  // with proper headers included (above), "sleep" works
  sleep(seconds);
}


/*
void getCurrentUsername(char *buf, int buflen)
{
  #ifdef __WIN32__
    DWORD len = buflen;
    if (!GetUserName(buf, &len)) {
      fail("GetUserName");
      std::strncpy(buf, "(unknown)", buflen);
    }

  #else    // unix (SunOS only?  we'll see..)
    #if 0     // old.. linux man page insists 'cuserid' is a bad fn to call
      char temp[L_cuserid];
      cuserid(temp);         // fail return?
    #endif // 0

    char const *temp;
    struct passwd *pw = getpwuid(geteuid());
    if (!pw) {
      fail("getpwuid(geteuid())");
      temp = "(unknown)";
    }
    else {
      temp = pw->pw_name;
    }

    std::strncpy(buf, temp, buflen);
  #endif
}
*/

// loop reading characters, return when finished
static void nonechoLoop(char *buf, int len)
{
  int cursor = 0;
  for(;;) {
    char ch = getConsoleChar();
    switch (ch) {
      case '\r':    // carriage return
        buf[cursor] = 0;
        return;

      case '\b':    // backspace
        if (cursor > 0) {
          cursor--;
        }
        break;

      default:
        buf[cursor++] = ch;
        if (cursor >= len-1) {
          // end of buffer
          buf[len-1] = 0;
          return;
        }
        break;
    }
  }
}


void readNonechoString(char *buf, int len, char const *prompt)
{
  std::cout << prompt;
  std::cout.flush();

  setRawMode(true);

  try {
    nonechoLoop(buf, len);
  }
  catch (...) {
    setRawMode(false);    // make sure it gets reset
    throw;
  }

  setRawMode(false);

  std::cout << "\n";
  std::cout.flush();
}


void applyToCwdContents(PerFileFunc func, void *extra)
{
  applyToDirContents(".", func, extra);
}


void applyToDirContents(char const *dirName,
                        PerFileFunc func, void *extra)
{
  // SM: we had find{first,next} code here for win32, but
  //     my Borland has opendir & friends, so let's see if
  //     that works everywhere.. (old code is below, in
  //     trash section)
  // DOB: VC doesn't have opendir-
  //  I think this is the only way to do it in the Win32 API
  #if defined(__WIN32__) && !defined(__BORLANDC__)
    struct _finddata_t fb;
    char* buf = new char[std::strlen(dirName)+5];
    std::strcpy(buf, dirName);
    if (buf[std::strlen(buf)-1] != '\\') strcat(buf, "\\");
    strcat(buf, "*");
    long handle = _findfirst(buf, &fb);
    delete buf;
    int done = (handle == -1);
    if (handle == -1 && errno != ENOENT) // ENOENT = no matching entries
      fail("_findfirst", dirName);
    while (!done) {
      if (!func(fb.name, extra)) {
        break;
        }
      done = _findnext(handle, &fb);
      }
    if (handle != -1) {
      if (_findclose(handle)) fail("_findclose", dirName);
      }

  #else     // unix and borland
    DIR *dir = opendir(dirName);
    if (!dir) {
      fail("opendir", dirName);
      return;
    }

    for(;;) {
      // grab next directory entry
      struct dirent *ent = readdir(dir);
      if (!ent) {
        break;     // end of listing
      }

      if (!func(ent->d_name, extra)) {
        break;     // user wants to stop listing
      }
    }

    if (closedir(dir) != 0) {
      fail("closedir", dirName);
    }
  #endif
}


bool isDirectory(char const *path)
{
  struct stat st;
  if (0!=stat(path, &st)) {
    fail("stat", path);
    return false;
  }
  #if defined(__WIN32__) && !defined(__BORLANDC__)
    return !!(st.st_mode & _S_IFDIR); // this is how it works for VC
  #else
    return S_ISDIR(st.st_mode);
  #endif
}


bool fileOrDirectoryExists(char const *path)
{
  struct stat st;
  if (0!=stat(path, &st)) {
    return false;     // assume error is because of nonexistence
  }
  else {
    return true;
  }
}


// adapted from Dan's keyutils.cpp (and indentation style
// ruthlessly changed! :) )
bool ensurePath(char const *filename, bool isDirectory)
{
  // make a temporary buffer so we can modify it safely
  int len = std::strlen(filename);
  char *temp = new char[len+1];
  std::strcpy(temp, filename);

  if (isDirectory) {
    len++;    // also consider final '\0' (strchr returns ptr to it)
  }

  // start at 1 (and not 0) because if the path starts with a slash,
  // then starting at 0 will cause us to try mkdir("")
  for (int i=1; i < len; i++) {
    if (strchr(DIRSLASHES, temp[i])) {
      // wherever there is a slash (or '\0'), truncate and test
      temp[i] = '\0';
      if (!fileOrDirectoryExists(temp)) {
        // make directory if necessary; automatically limits file access
        if (!createDirectory(temp)) {
          delete[] temp;
          return false;
        }
      }
      temp[i] = DIRSLASH;      // may kill final '\0', doesn't matter
    }
  }

  // was leaking this.. found the leak with the feudal-C instrumentor!
  delete[] temp;
  return true;
}

 
// underlying test
bool hsrcHelper()
{
/*
  #ifdef __UNIX__
    // see if /dev/random exists and is readable
    int fd = open("/dev/random", O_RDONLY);
    if (fd < 0) {
      return false;
    }

    // looks ok!
    if (close(fd) < 0) {
      perror("close");
      return false;      // seems unlikely, but..
    }

    return true;

  #else    // windows
    return false;
  #endif
*/
  return false;
}

bool hasSystemCryptoRandom()
{
  static bool cached = false;
  static bool cachedAnswer;

  if (!cached) {
    cachedAnswer = hsrcHelper();
    cached = true;
  }
  
  return cachedAnswer;
}


// assume we are only called if the above fn returned true;
// for this fn, any failure is considered fatal because we
// don't have a way to communicate it, and the possibility of
// returning nonrandom values is not tolerable (if something
// I haven't thought of is causing failure, add it to the list
// of things hasSystemCryptoRandom checks)
unsigned getSystemCryptoRandom()
{
/*
  #ifdef __UNIX__
    // open /dev/random
    int fd = open("/dev/random", O_RDONLY);
    if (!fd) {
      perror("open");
      exit(2);
    }

    // grab 4 bytes
    union {
      unsigned ret;
      char c[4];
    };
    int got = 0;

    while (got < 4) {
      int ct = read(fd, c+got, 4-got);
      if (ct < 0) {
        perror("read");
        exit(2);
      }
      if (ct == 0) {
        fprintf(stderr, "got 0 bytes from /dev/random.. it's supposed to block!!\n");
        exit(2);
      }
      got += ct;
    }

    if (close(fd) < 0) {
      perror("close");
      exit(2);
    }

    return ret;

  #else     // windows
    fprintf(stderr, "no system crypto random function available!\n");
    exit(2);
    return 0;    // silence warning
  #endif
*/
    fprintf(stderr, "no system crypto random function available!\n");
    exit(2);
    return 0;    // silence warning

}


#if 0
int getProcessId()
{
  #ifdef __UNIX__
    return getpid();

  #else // windows
    return GetCurrentProcessId();

  #endif
}
#endif

// do we have access to C99 vsnprintf?
#if defined(__GLIBC__) && defined(__GLIBC_MINOR__)
  #if __GLIBC__ >= 3 || (__GLIBC__ >= 2 && __GLIBC_MINOR__ >= 1)
    // glibc-2.1 or later: yes (glibc-2.0.6 has a function called
    // vsnprintf, but the interface is wrong)
    #define HAS_C99_VSNPRINTF
  #endif
#endif

// note to reader: if your system has C99 VSNPRINTF, feel free to add
// appropriate detection code

#ifndef HAS_C99_VSNPRINTF
  // no vsnprintf, will use gprintf (which is slow, and overestimates sometimes)
#include "sm_gprintf.h"
  
  static int counting_output_function(void *extra, int ch)
  {
    // 'extra' is a pointer to the count
    int *ct = (int*)extra;
    (*ct)++;
    return 0;    // no failure
  }
#endif // !HAS_C99_VSNPRINTF

int vnprintf(char const *format, va_list args)
{
  #ifdef HAS_C99_VSNPRINTF
    // can use this directly
    return vsnprintf(NULL, 0, format, args);

  #else
    // conservatively interpret the format sm_string using gprintf
    int count = 0;
    general_vprintf(counting_output_function, &count, format, args);
    return count;
  #endif
}


int nprintf(char const *format, ...)
{
  va_list args;
  va_start(args, format);
  int ret = vnprintf(format, args);
  va_end(args);
  return ret;
}


// ----------------- test code --------------------
#ifdef TEST_NONPORT

#include <stdio.h>       // printf


// helper for testing applyToCwdFiles
bool printFirst10(char const *name, void *extra)
{
  int &count = *((int*)extra);
  count++;
  if (count <= 10) {
    printf("  %s\n", name);
    return true;    // continue
  }
  else {
    return false;   // stop
  }
}


bool printIt(char const *name, void*)
{
  printf("%s\n", name);
  return true;    // continue
}


void testingFail(char const *call, char const *ctx)
{
  printf("FAIL: call=%s, ctx=%s, errno=%d\n",
         call, (ctx? ctx : "(null)"), errno);
}


void nprintfVector(char const *format, ...)
{
  va_list args;

  // run vnprintf to obtain estimate
  va_start(args, format);
  int est = vnprintf(format, args);
  va_end(args);

  // make that much space
  char *buf = new char[est+1 + 50 /*safety margin*/];

  // run the real vsprintf
  va_start(args, format);
  int len = vsprintf(buf, format, args);
  va_end(args);
  
  if (len > est) {
    printf("nprintf failed to conservatively estimate!\n");
    printf("    format: %s\n", format);
    printf("  estimate: %d\n", est);
    printf("    actual: %d\n", len);
    exit(2);
  }

  if (len != est) {
    // print the overestimates; they shouldn't be much noise in the
    // common case, but might hint at a problem earlier than I'd
    // otherwise notice
    printf("nprintf overestimate:\n");
    printf("    format: %s\n", format);
    printf("  estimate: %d\n", est);
    printf("    actual: %d\n", len);
  }

  delete[] buf;
}


int main(int argc, char **argv)
{
  nonportFail = testingFail;

  char s[4];
  s[0] = '-';
  s[1] = 'l';
  s[2] = 's';
  s[3] = 0;
  if (0!=std::strcmp(s, "-ls")) {
    printf("std::strcmp failed!\n");
    return 4;
  }

  // process arguments
  bool interactive = false;
  for (int i=1; i<argc; i++) {
    if (0==std::strcmp("-ls", argv[i])) {
      // do an ls, and bail
      applyToCwdContents(printIt);
      return 0;
    }
    else if (0==std::strcmp("-noninteractive", argv[i])) {
      // don't do the interactive stuff
      interactive = false;
    }
    else {
      printf("unknown option: %s\n", argv[i]);
      return 2;
    }
  }

  // trying to figure out why backspace sometimes gives ^? crap
  // (turns out Konsole sometimes sends ^? in response to BS,
  // even when the option looks unchecked)
  //char buf[80];
  //printf("type stuff and try backspace: ");
  //gets(buf);
  //printf("%s (%d chars)\n", buf, std::strlen(buf));
  //return 0;

  long startTime = getMilliseconds();

  if (interactive) {
    printf("Type some characters; you should see each\n"
           "character echoed once as you type it (q to stop):\n");
    setRawMode(true);
    char ch;
    do {
      ch = getConsoleChar();
      printf("%c", ch);
    } while (ch != 'q');

    setRawMode(false);

    printf("\n\nYou typed for %ld milliseconds\n",
           getMilliseconds() - startTime);
  }

  limitFileAccess("chmod.test");

  printf("if the current dir contains a file called "
         "chmod.test, I just attempted to limit\n"
         "its access to just the owner\n");

  createDirectory("test.dir");

  // test chdir, which also implicitly tests mkdir
  bool didFirst=false;
  if (!changeDirectory("test.dir") || (didFirst=true, false) ||
      !changeDirectory("..")) {
    printf("failed while trying to chdir to %s\n",
           (didFirst? ".." : "test.dir"));
  }

  // more straightforward
  if (!fileOrDirectoryExists("test.dir")) {
    printf("test.dir didn't get created?\n");
  }

  printf("what's more, I just tried to mkdir & chdir test.dir\n");

  // test ensurePath
  if (!ensurePath("test.dir/a/b/c/d", false /*isDirectory*/)) {
    printf("ensurePath test.dir/a/b/c/d failed\n");
  }

  // try to list partial directory contents
  printf("listing of first 10 files in this directory:\n");
  {
    int count = 0;
    applyToCwdContents(printFirst10, &count);
  }

  // test date function
  {
    int m, d, y;
    getCurrentDate(m, d, y);

    printf("I think the date is (m/d/yyyy): %d/%d/%d\n",
           m, d, y);
  }

  // test sleep (mostly just to make sure it doesn't segfault)
  printf("sleeping for 1 second...\n");
  portableSleep(1);

  /*
  // test user name
  char buf[80];
  getCurrentUsername(buf, 80);
  printf("current user name is: %s\n", buf);
  */

  if (interactive) {
    // test nonecho reading
    printf("Type something and press Enter; it won't be echoed (yet):\n");
    readNonechoString(buf, 80, "  > ");
    printf("You typed: %s\n", buf);
  }

  // test random stuff
  printf("hasSystemCryptoRandom: ");
  if (!hasSystemCryptoRandom()) {
    printf("no\n");
  }
  else {
    printf("yes\n");
    
    printf("three random numbers: %u %u %u\n",
           getSystemCryptoRandom(),
           getSystemCryptoRandom(),
           getSystemCryptoRandom());
  }

  printf("testing nprintf...\n");
  nprintfVector("simple");
  nprintfVector("a %s more", "little");
  nprintfVector("some %4d more %s complicated %c stuff",
                33, "yikes", 'f');
  nprintfVector("%f", 3.4);

  printf("nonport works\n");
  return 0;
}

#endif // TEST_NONPORT


// -------------- trash ----------------
#if 0
void limitFileAccess(char const *fname)
{
  // we'll decide whether this is possible by whether
  // or not the necessary macros are defined
#ifndef S_IRGRP     // assume rest are if this is
    // probably can't do anything
    return;
#else

  // modify file permissions (to simplify things,
  // we'll just set permissions, rather than
  // read-modify-write); don't bother testing for
  // error condition since there isn't much we
  // can do about it anyway
  chmod(fname, S_IRUSR | S_IWUSR);
# endif
}

# ifdef __WIN32__     // findfirst, findnext
#   ifdef __BORLANDC__
      struct ffblk fb;
      int done = findfirst("*", &fb, 0);
      while (!done) {
        if (!func(fb.ff_name, extra)) {
          break;
        }
        done = findnext(&fb);
      }
#   else  // DOB: VC has a totally diff interface for this
      struct _finddata_t fb;
      long handle = _findfirst("*", &fb);
      int done = (handle == -1);
      while (!done) {
        if (!func(fb.name, extra)) {
          break;
        }
        done = _findnext(handle, &fb);
      }
      if (handle != -1) _findclose(handle);
#   endif
# else    // unix     // {open,read,close}dir, stat
# endif

#endif // 0    (trash)

@h=tangler('elk/sm_str.cpp')
@select(h)
// str.cpp            see license.txt for copyright and terms of use
// code for str.h
// Scott McPeak, 1995-2000  This file is public domain.

#include "sm_str.h"

#include <stdlib.h>         // atoi
#include <stdio.h>          // sprintf
#include <ctype.h>          // isspace
#include <cstring>         // std::strcmp
#include <iostream>       // std::ostream << char*
#include <assert.h>         // assert

#include "sm_xassert.h"
#include "sm_ckheap.h"
#include "sm_flatten.h"
#include "sm_nonport.h"
#include "sm_unixutil.h"


// ----------------------- sm_string ---------------------
// ideally the compiler would arrange for 'empty', and the
// "" it points to, to live in a read-only section of mem..;
// but I can't declare it 'char const *' because I assign
// it to 's' in many places..
char * const sm_string::empty = "";


sm_string::sm_string(char const *src, int length)
{
  s=empty;
  setlength(length);       // setlength already has the +1; sets final NUL
  std::memcpy(s, src, length);
}


void sm_string::dup(char const *src)
{
  if (!src || src[0]==0) {
    s = empty;
  }
  else {
    s = new char[ std::strlen(src) + 1 ];
    xassert(s);
    std::strcpy(s, src);
  }
}

void sm_string::kill()
{
  if (s != empty) {
    delete s;
  }
}


sm_string::sm_string(Flatten&)
  : s(empty)
{}

void sm_string::xfer(Flatten &flat)
{
  flat.xferCharString(s);
}


int sm_string::length() const
{
  xassert(s);
  return std::strlen(s);
}

bool sm_string::contains(char c) const
{
  xassert(s);
  return !!strchr(s, c);
}


sm_string sm_string::subsm_string(int startIndex, int len) const
{
  xassert(startIndex >= 0 &&
          len >= 0 &&
          startIndex + len <= length());

  return sm_string(s+startIndex, len);
}


sm_string &sm_string::setlength(int length)
{
  kill();
  if (length > 0) {
    s = new char[ length+1 ];
    xassert(s);
    s[length] = 0;      // final NUL in expectation of 'length' chars
    s[0] = 0;           // in case we just wanted to set allocated length
  }
  else {
    xassert(length == 0);     // negative wouldn't make sense
    s = empty;
  }
  return *this;
}


int sm_string::compareTo(sm_string const &src) const
{
  return compareTo(src.s);
}

int sm_string::compareTo(char const *src) const
{
  if (src == NULL) {
    src = empty;
  }
  return std::strcmp(s, src);
}


sm_string sm_string::operator&(sm_string const &tail) const
{
  sm_string dest(length() + tail.length());
  std::strcpy(dest.s, s);
  strcat(dest.s, tail.s);
  return dest;
}

sm_string& sm_string::operator&=(sm_string const &tail)
{
  return *this = *this & tail;
}


void sm_string::readdelim(std::istream &is, char const *delim)
{
  sm_stringBuilder sb;
  sb.readdelim(is, delim);
  operator= (sb);
}


void sm_string::write(std::ostream &os) const
{
  os << s;     // standard char* writing routine
}


void sm_string::selfCheck() const
{ 
  if (s != empty) {
    checkHeapNode(s);
  }
}


// --------------------- sm_stringBuilder ------------------
sm_stringBuilder::sm_stringBuilder(int len)
{
  init(len);
}

void sm_stringBuilder::init(int initSize)
{
  size = initSize + EXTRA_SPACE + 1;     // +1 to be like sm_string::setlength
  s = new char[size];
  end = s;
  end[initSize] = 0;
}


void sm_stringBuilder::dup(char const *str)
{
  int len = std::strlen(str);
  init(len);
  std::strcpy(s, str);
  end += len;
}


sm_stringBuilder::sm_stringBuilder(char const *str)
{
  dup(str);
}


sm_stringBuilder::sm_stringBuilder(char const *str, int len)
{
  init(len);
  std::memcpy(s, str, len);
  end += len;
}


sm_stringBuilder& sm_stringBuilder::operator=(char const *src)
{
  if (s != src) {
    kill();
    dup(src);
  }
  return *this;
}


sm_stringBuilder& sm_stringBuilder::setlength(int newlen)
{
  kill();
  init(newlen);
  return *this;
}


void sm_stringBuilder::adjustend(char* newend) 
{
  xassert(s <= newend  &&  newend < s + size);

  end = newend;
  *end = 0;        // sm 9/29/00: maintain invariant
}


sm_stringBuilder& sm_stringBuilder::operator&= (char const *tail)
{
  append(tail, std::strlen(tail));
  return *this;
}

void sm_stringBuilder::append(char const *tail, int len)
{
  ensure(length() + len);

  std::memcpy(end, tail, len);
  end += len;
  *end = 0;
}


sm_stringBuilder& sm_stringBuilder::indent(int amt)
{
  xassert(amt >= 0);
  ensure(length() + amt);

  std::memset(end, ' ', amt);
  end += amt;
  *end = 0;
  
  return *this;
}


void sm_stringBuilder::grow(int newMinLength)
{
  // I want at least EXTRA_SPACE extra
  int newMinSize = newMinLength + EXTRA_SPACE + 1;         // compute resulting allocated size

  // I want to grow at the rate of at least 50% each time
  int suggest = size * 3 / 2;

  // see which is bigger
  newMinSize = max(newMinSize, suggest);

  // remember old length..
  int len = length();

  // realloc s to be newMinSize bytes
  char *temp = new char[newMinSize];
  xassert(len+1 <= newMinSize);    // prevent overrun
  std::memcpy(temp, s, len+1);          // copy null too
  delete[] s;
  s = temp;

  // adjust other variables
  end = s + len;
  size = newMinSize;
}


sm_stringBuilder& sm_stringBuilder::operator<< (char c)
{
  ensure(length() + 1);
  *(end++) = c;
  *end = 0;
  return *this;
}


#define MAKE_LSHIFT(Argtype, fmt)                        \
  sm_stringBuilder& sm_stringBuilder::operator<< (Argtype arg) \
  {                                                      \
    char buf[60];      /* big enough for all types */    \
    int len = sprintf(buf, fmt, arg);                    \
    if (len >= 60) {                                     \
      abort();    /* too big */                          \
    }                                                    \
    return *this << buf;                                 \
  }

MAKE_LSHIFT(long, "%ld")
MAKE_LSHIFT(unsigned long, "%lu")
MAKE_LSHIFT(double, "%g")
MAKE_LSHIFT(void*, "%p")

#undef MAKE_LSHIFT


sm_stringBuilder& sm_stringBuilder::operator<< (
  sm_stringBuilder::Hex const &h)
{
  char buf[32];        // should only need 19 for 64-bit word..
  int len = sprintf(buf, "0x%lX", h.value);
  if (len >= 20) {
    abort();
  }
  return *this << buf;

  // the length check above isn't perfect because we only find out there is
  // a problem *after* trashing the environment.  it is for this reason I
  // use 'assert' instead of 'xassert' -- the former calls abort(), while the
  // latter throws an exception in anticipation of recoverability
}


sm_stringBuilder& sm_stringBuilder::operator<< (Manipulator manip)
{
  return manip(*this);
}


// slow but reliable
void sm_stringBuilder::readdelim(std::istream &is, char const *delim)
{
  char c;
  is.get(c);
  while (!is.eof() &&
         (!delim || !strchr(delim, c))) {
    *this << c;
    is.get(c);
  }
}


// ---------------------- toString ---------------------
#define TOSTRING(type)        \
  sm_string toString(type val)   \
  {                           \
    return sm_stringc << val;    \
  }

TOSTRING(int)
TOSTRING(unsigned)
TOSTRING(char)
TOSTRING(long)
TOSTRING(float)

#undef TOSTRING

// this one is more liberal than 'sm_stringc << null' because it gets
// used by the PRINT_GENERIC macro in my astgen tool
sm_string toString(char const *str)
{
  if (!str) {
    return sm_string("(null)");
  }
  else {
    return sm_string(str);
  }
}


// ------------------- sm_stringf -----------------
sm_string sm_stringf(char const *format, ...)
{
  va_list args;
  va_start(args, format);
  sm_string ret = vsm_stringf(format, args);
  va_end(args);
  return ret;
}
 

sm_string vsm_stringf(char const *format, va_list args)
{                                  
  // estimate sm_string length
  // int est = vnprintf(format, args);

  va_list args2;
  va_copy(args2, args);
  int est = vnprintf(format, args2);
  va_end(args2);
                    
  // allocate space
  sm_string ret(est+1);
  
  // render the sm_string
  int len = vsprintf(ret.pchar(), format, args);

  // check the estimate, and fail *hard* if it was low, to avoid any
  // possibility that this might become exploitable in some context
  // (do *not* turn this check off in an NDEGUG build)
  if (len > est) {
    // don't go through fprintf, etc., because the state of memory
    // makes that risky
    static char const msg[] =
      "fatal error: vnprintf failed to provide a conservative estimate,\n"
      "memory is most likely corrupted\n";
    writeAll(2 /*stderr*/, msg, std::strlen(msg));
    abort();
  }
             
  // happy
  return ret;
}


// ------------------ test code --------------------
#ifdef TEST_STR

#include <iostream>    // std::cout

void test(unsigned long val)
{
  //std::cout << sm_stringb(val << " in hex: 0x" << sm_stringBuilder::Hex(val)) << std::endl;

  std::cout << sm_stringb(val << " in hex: " << SBHex(val)) << std::endl;
}

int main()
{
  // for the moment I just want to test the hex formatting
  test(64);
  test(0xFFFFFFFF);
  test(0);
  test((unsigned long)(-1));
  test(1);

  std::cout << "sm_stringf: " << sm_stringf("int=%d hex=%X str=%s char=%c float=%f",
                                 5, 0xAA, "hi", 'f', 3.4) << std::endl;            

  std::cout << "tests passed\n";

  return 0;
}

#endif // TEST_STR

@h=tangler('elk/sm_strtokp.cpp')
@select(h)
// strtokp.cc            see license.txt for copyright and terms of use
// code for std::strtokp.h
// Scott McPeak, 1997, 1999, 2000  This file is public domain.

#include "sm_strtokp.h"
#include "sm_exc.h"
#include <cstring>     // std::strtok


StrtokParse::StrtokParse(char const *str, char const *delim)
{
  xassert(str != NULL);

  // make local copy
  buf = str;

  // parse it first time to count # of tokens
  int ct=0;
  char *tok = std::strtok(buf.pchar(), delim);
  while (tok) {
    ct++;
    tok = std::strtok(NULL, delim);
  }

  // restore buf
  buf = str;

  // allocate storage
  _tokc = ct;
  if (ct) {
    _tokv = new char*[ct+1];
    _tokv[ct] = NULL;     // terminate argv[]-like list
  }
  else {
    _tokv = NULL;
  }

  // parse it again, this time saving the values
  ct=0;
  tok = std::strtok(buf.pchar(), delim);
  while (tok) {
    _tokv[ct] = tok;
    ct++;
    tok = std::strtok(NULL, delim);
  }

  // simple check just because it's easy
  xassert(ct == _tokc);
}


StrtokParse::~StrtokParse()
{
  // buf deletes itself

  if (_tokv) {
    delete _tokv;
  }
}


void StrtokParse::validate(int which) const
{
  xassert((unsigned)which < (unsigned)_tokc);
}


char const *StrtokParse::tokv(int which) const
{
  validate(which);
  return _tokv[which];
}


sm_string StrtokParse::
  reassemble(int firstTok, int lastTok, char const *original) const
{
  int left = offset(firstTok);
  int right = offset(lastTok) + std::strlen(tokv(lastTok));

  return sm_string(original + left, right-left);
}


sm_string StrtokParse::
  join(int firstTok, int lastTok, char const *separator) const
{
  sm_stringBuilder sb;
  
  for (int i=firstTok; i<=lastTok; i++) {
    if (i > firstTok) {
      sb << separator;
    }
    sb << tokv(i);
  }
  
  return sb;
}


int StrtokParse::offset(int which) const
{
  return tokv(which) - (char const*)buf;
}
@h=tangler('elk/sm_syserr.cpp')
@select(h)
// syserr.cpp            see license.txt for copyright and terms of use
// code for syserr.h
// Scott McPeak, 1999-2000  This file is public domain.

#include "sm_syserr.h"

// ---------------- portable code ----------------
char const * const xSysError::reasonStrings[] = {
  "No error occurred",
  "File not found",
  "Path not found",
  "Access denied",
  "Out of memory (maybe)",    // always a suspicious message
  "Invalid pointer address",
  "Invalid data format",
  "Invalid argument",
  "Attempt to modify read-only data",
  "The object already exists",
  "Resource is temporarily unavailable",
  "Resource is busy",
  "File name is invalid (too long, or bad chars, or ...)",
  "Unknown or unrecognized error",
  "(bug -- invalid reason code)"        // corresponds to NUM_REASONS
};


STATICDEF char const *xSysError::
  getReasonString(xSysError::Reason r)
{
  // at compile-time, verify consistency between enumeration and sm_string array
  // (it's in here because, at least on Borland, the preprocessor respects
  // the member access rules (strangely..))
  #ifdef __BORLANDC__
    #if TABLESIZE(reasonStrings) != NUM_REASONS+1
      #error table and enumeration do not match
    #endif
  #endif

  if ((unsigned)r < NUM_REASONS) {
    return reasonStrings[r];
  }
  else {
    return reasonStrings[NUM_REASONS];
  }
}


xSysError::xSysError(xSysError::Reason r, int sysCode, char const *sysReason,
                     char const *syscall, char const *ctx)
  : xBase(constructWhyString(r, sysReason, syscall, ctx)),
    reason(r),
    reasonString(getReasonString(r)),
    sysErrorCode(sysCode),
    sysReasonString(sysReason),
    syscallName(syscall),
    context(ctx)
{}


STATICDEF sm_string xSysError::
  constructWhyString(xSysError::Reason r, char const *sysReason,
                     char const *syscall, char const *ctx)
{
  xassert(syscall);

  // build sm_string; start with syscall that failed
  sm_stringBuilder sb;
  sb << syscall << ": ";

  // now a failure reason sm_string
  if (r != R_UNKNOWN) {
    sb << getReasonString(r);
  }
  else if ((sysReason != NULL) && (sysReason[0] != 0)) {
    sb << sysReason;
  }
  else {
    // no useful info, use the R_UNKNOWN sm_string
    sb << getReasonString(r);
  }

  // finally, the context
  if (ctx != NULL) {
    sb << ", " << ctx;
  }
  
  return sb;
}


xSysError::xSysError(xSysError const &obj)
  : xBase(obj),
    reason(obj.reason),
    reasonString(obj.reasonString),
    sysErrorCode(obj.sysErrorCode),
    sysReasonString(obj.sysReasonString),
    syscallName(obj.syscallName),
    context(obj.context)
{}


xSysError::~xSysError()
{}


STATICDEF void xSysError::
  xsyserror(char const *syscallName, char const *context)
{
  // retrieve system error code
  int code = getSystemErrorCode();

  // translate it into one of ours
  sm_string sysMsg;
  Reason r = portablize(code, sysMsg);

  // construct an object to throw
  xSysError obj(r, code, sysMsg, syscallName, context);

  // toss it
  THROW(obj);
}


sm_string sysErrorCodeString(int systemErrorCode, char const *syscallName,
                                               char const *context)
{
  sm_string sysMsg;
  xSysError::Reason r = xSysError::portablize(systemErrorCode, sysMsg);
  return xSysError::constructWhyString(
           r, sysMsg,
           syscallName, context);
}


// ----------------------- Win32 code ------------------------------------
#ifdef __WIN32__

#ifdef USE_MINWIN_H
#  include "minwin.h"   // api
#else
#  include <windows.h>  // api
#endif
#include <errno.h>      // errno

STATICDEF int xSysError::getSystemErrorCode()
{
  int ret = GetLastError();

  // update: The confusing behavior I observed was with the Borland 4.5
  // runtime libraries.  When I linked with the non-multithreaded versions,
  // GetLastError worked as expected.  But when I linked with the
  // multithreaded versions, GetLastError always returned 0, and I had to
  // consult errno instead.  Further, the errno values didn't coincide
  // exactly with expected values.  Therefore, the solution (at least for
  // now) is to link only with the non-multithreaded versions, and not
  // look to errno for anything.
  #ifdef MT
  #  error something is fishy with multithreaded..
  #endif

  // I thought something was happening, but now it seems
  // it's not..
  #if 0     // ?
  if (ret == ERROR_SUCCESS) {
    // for some calls, like mkdir, GetLastError is not
    // set, but errno is; fortunately, MS decided to
    // (mostly) overlap GetLastError codes with errno codes,
    // so let's try this:
    return errno;
  }
  #endif // 0

  return ret;
}


STATICDEF xSysError::Reason xSysError::portablize(int sysErrorCode, sm_string &sysMsg)
{
  // I'd like to put this into a static class member, but then
  // the table would have to prepend R_ constants with xSysError::,
  // which is a pain.

  // Q: how to get a sm_string from win32?
  //if (sysMsg != NULL) {
    sysMsg = NULL;
  //}

  static struct S {
    int code;
    Reason reason;
  } const arr[] = {
    { ERROR_SUCCESS,           R_NO_ERROR          },
    { ERROR_FILE_NOT_FOUND,    R_FILE_NOT_FOUND    },
    { ERROR_PATH_NOT_FOUND,    R_PATH_NOT_FOUND    },
    { ERROR_ACCESS_DENIED,     R_ACCESS_DENIED     },
    { ERROR_NOT_ENOUGH_MEMORY, R_OUT_OF_MEMORY     },
    { ERROR_OUTOFMEMORY,       R_OUT_OF_MEMORY     },
    { ERROR_INVALID_BLOCK,     R_SEGFAULT          },
    { ERROR_BAD_FORMAT,        R_FORMAT            },
    { ERROR_INVALID_DATA,      R_INVALID_ARGUMENT  },
    { ERROR_WRITE_PROTECT,     R_READ_ONLY         },
    { ERROR_ALREADY_EXISTS,    R_ALREADY_EXISTS    },
    // ???                     R_AGAIN
    { ERROR_BUSY,              R_BUSY              },
  };

  loopi(TABLESIZE(arr)) {
    if (arr[i].code == sysErrorCode) {
      // found it
      return arr[i].reason;
    }
  }

  // I don't know
  return R_UNKNOWN;
}


// ---------------------- unix ---------------------------
#else      // unix

#include <errno.h>       // errno
#include <cstring>      // std::strerror

// mappings to a set of error codes I can use below
// (I am sure I've already done this somewhere else, but I
// may have lost that file)
#ifndef EZERO
#  define EZERO 0
#endif
#ifndef ENOFILE
#  define ENOFILE ENOENT
#endif
#ifndef ENOPATH
#  define ENOPATH ENOENT
#endif
#ifndef EINVMEM
#  define EINVMEM EFAULT
#endif
#ifndef EINVFMT
#  define EINVFMT 0         // won't be seen because EZERO is first
#endif


STATICDEF int xSysError::getSystemErrorCode()
{
  return errno;          // why was this "errno()"??
}


STATICDEF xSysError::Reason xSysError::portablize(int sysErrorCode, sm_string &sysMsg)
{
  sysMsg = std::strerror(sysErrorCode);
    // operator= copies to local storage

  static struct S {
    int code;
    Reason reason;
  } const arr[] = {
    { EZERO,        R_NO_ERROR          },
    { ENOFILE,      R_FILE_NOT_FOUND    },
    { ENOPATH,      R_PATH_NOT_FOUND    },
    { EACCES,       R_ACCESS_DENIED     },
    { ENOMEM,       R_OUT_OF_MEMORY     },
    { EINVMEM,      R_SEGFAULT          },
    { EINVFMT,      R_FORMAT            },
    { EINVAL,       R_INVALID_ARGUMENT  },
    { EROFS,        R_READ_ONLY         },
    { EEXIST,       R_ALREADY_EXISTS    },
    { EAGAIN,       R_AGAIN             },
    { EBUSY,        R_BUSY              },
    { ENAMETOOLONG, R_INVALID_FILENAME  },
  };

  loopi(TABLESIZE(arr)) {
    if (arr[i].code == sysErrorCode) {
      // found it
      return arr[i].reason;
    }
  }

  // I don't know
  return R_UNKNOWN;
}


#endif  // unix


// ------------------ test code ------------------------
#ifdef TEST_SYSERR
#include "sm_test.h"
#include "sm_nonport.h"

// this is a macro because failingCall needs to be
// call-by-name so I can wrap it in a try
#define TRY_FAIL(failingCall, expectedCode)                       \
  try {                                                           \
    if (failingCall) {                                            \
      std::cout << "ERROR: " #failingCall " should have failed\n";     \
    }                                                             \
    else {                                                        \
      /* got an error to test */                                  \
      xsyserror(#failingCall);                                    \
    }                                                             \
  }                                                               \
  catch (xSysError &x) {                                          \
    if (x.reason != xSysError::expectedCode) {                    \
      std::cout << "ERROR: " #failingCall " returned '"                \
           << x.reasonString << "' but '"                         \
           << xSysError::getReasonString(xSysError::expectedCode) \
           << "' was expected\n";                                 \
      errors++;                                                   \
    }                                                             \
  }

void entry()
{
  int errors = 0;
  xBase::logExceptions = false;
  //nonportFail = xSysError::xsyserror;

  //TRY_FAIL(createDirectory("/tmp\\Scott\\"),
  //         R_ALREADY_EXISTS);

  TRY_FAIL(changeDirectory("some.strange.name/yadda"),
           R_PATH_NOT_FOUND);

  TRY_FAIL(createDirectory("/tmp"),
           R_ALREADY_EXISTS);

  TRY_FAIL(isDirectory("doesnt.exist"),
           R_FILE_NOT_FOUND);

  if (errors == 0) {
    std::cout << "success!\n";
  }
  else {
    std::cout << errors << " error(s)\n";
  }
}

USUAL_MAIN

#endif // TEST_SYSERR

@h=tangler('elk/sm_warn.cpp')
@select(h)
// warn.cc            see license.txt for copyright and terms of use
// code for warn.h
// Scott McPeak, 1999  This file is public domain.

#include "sm_warn.h"
#include "sm_typ.h"
#include "sm_breaker.h"
#include <stdio.h>      // fopen, stderr, etc.
#include <time.h>       // time, ctime

// globals
WarningHandler warningHandler = defaultWarningHandler;
#ifdef NDEBUG
  WarnLevel logWarnLevel = (WarnLevel)(WARN_ALL - WARN_DEBUG);
  WarnLevel displayWarnLevel = WARN_NONE;
#else
  WarnLevel logWarnLevel = WARN_ALL;
  WarnLevel displayWarnLevel = WARN_ALL;
#endif


void warning(WarnLevel level, char const *message)
{
  warningHandler(level, message);
}


void defaultWarningHandler(WarnLevel level, char const *message)
{
  if (level & WARN_DEBUG) {
    // hit a breakpoint if the debugger is attached
    breaker();
  }

  if (level & logWarnLevel) {
    defaultWarningLogger(level, message);
  }

  if (level & logWarnLevel) {
    defaultWarningPrinter(level, message);
  }
}


void defaultWarningLogger(WarnLevel /*level*/, char const *message)
{
  static FILE *logfile = NULL;
  static bool failedToOpen = false;

  if (!logfile && !failedToOpen) {
    logfile = fopen("warning.log", "a");
    if (!logfile) {
      // don't keep trying
      failedToOpen = true;
    }
    else {
      // start with a timestamp
      time_t t;
      time(&t);
      int len = fprintf(logfile, "\nLog started at %s", ctime(&t));
        // note: astonishingly (bad), the sm_string returned by ctime() has
        //       a newline at the end!

      while (len--) {
        fprintf(logfile, "-");
      }
      fprintf(logfile, "\n");
    }
  }

  if (logfile) {
    // append the message to the logfile
    fprintf(logfile, "warning: %s\n", message);
    fflush(logfile);
  }
}


void defaultWarningPrinter(WarnLevel /*level*/, char const *message)
{
  fprintf(stderr, "warning: %s\n", message);
  fflush(stderr);
}


// no test code because it is my judgment that bugs in this
// module will be easily evident, and it is a very simple
// module, so it isn't worth it to separately test

