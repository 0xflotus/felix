@head(1,"Desugaring")
@h = tangler("src/flx_desugar.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_pat
open Flx_srcref

let generated = ("Generated by desugaring",0,0,0,0)

let catmap f l = concat (map f l)

(* split lambdas out. Each lambda is replaced by a
   reference to a synthesised name in the original
   statement, which is prefixed by the definition.

   Blocks are replaced by a procedure definition
   and a call.

   The match statement requires all case bodies
   be replaced by calls as well.

   Actual lambdas in expressions are replaced
   by a reference and function or procedure definition.

   Attempt handler bodies are requires all handlers
   to be replaced by a call as well.
*)

(* convert a single statement into either:
   (1) an empty list and a single statement
   (2) a block procedure and a call to it

   WARNING: this is a HACK: it relies
   on the fact that (rst (AST_block ss)) 
   is a list of a single procedure (the block),
   followed by a called to it (where ss consists
   of more than one statement)
*)

(* convert an expression into a list of assembly instructions,
   plus an expression: basically, this means removing lambdas
*)
let rec rex seq msgt e = 
  let rex e = rex seq msgt e in
  let rsts sts = catmap (rst seq msgt) sts in
  match e with

  (* these cases should use the source reference for the error *)
  | AST_match_ctor _ 
    -> failwith "[rex] not expecting union component constructor matcher"
  | AST_ctor_arg _ 
    -> failwith "[rex] not expecting union component destructor"
    
  | AST_deref _ -> [],e
  | AST_name _ -> [],e
  | AST_ref _ -> [],e
  | AST_literal _ -> [],e
  | AST_get_n (sr,(n,e')) ->
    let l1,x1 = rex e' in
    l1, AST_get_n (sr,(n,x1))

  | AST_apply (sr,(fn,arg)) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, AST_apply (sr,(x1,x2))

  | AST_method_apply (sr,(fn,arg)) -> 
    let l2,x2 = rex arg in
    l2, AST_method_apply (sr,(fn,x2))
    
  | AST_tuple (sr,t) -> 
    let lss,xs = split (map rex t) in
    concat lss,AST_tuple (sr,xs)

  | AST_lambda (sr,(params,res,sts)) -> 
    let n = seq() in
    let name = "_lambda_" ^ string_of_int n in
    let argtyp = type_of_argtypes (map snd params) in
    [match res with
    | TYP_void -> Dcl (sr,name,DCL_procedure (msgt, params, rsts sts))
    | _ -> Dcl (sr,name,DCL_function (params, res, rsts sts))
    ],
    AST_name (generated,([name], type_of_argtypes (map snd params)))

  | AST_dot (sr,(obj,comp)) -> 
    let l1,x1 = rex obj in 
    l1 , AST_dot (sr,(x1,comp))

and split_st seq msgt sr s : asm_t list * asm_t =
  match rst seq msgt s with
  | [] -> [], Exe (generated,EXE_nop "")
  | [x] -> [],x
  | ss ->
    let name = "_block_" ^ string_of_int (seq()) in
    [
      Dcl (sr,name,DCL_procedure (msgt, [], ss))
    ]
    ,
    Exe (sr,EXE_call (
      AST_name (generated,([name],TYP_tuple [])), 
      AST_tuple (generated,[])
    ))

(* remove blocks *)

and rst seq msgt st : asm_t list = 
  let rst' st = rst seq msgt st in
  let rex x = rex seq msgt x in
  let rsts' sts = catmap rst' sts in
  
  match st with
  | AST_label (sr,s) -> [Exe (sr,EXE_label s)]
  | AST_goto (sr,s) -> [Exe (sr,EXE_goto s)]

  | AST_comment s -> [Exe (generated,EXE_comment s)]

  (* objects *)
  | AST_export (sr,name,cpp_name) ->
    [Iface (sr,IFACE_export (name,cpp_name))]

  | AST_var_decl (sr,name,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,DCL_var t); Exe (sr,EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,DCL_var_typeof x); Exe (sr,EXE_init (name,x))]
    | Some t,None -> [Dcl (sr,name,DCL_var t)]
    | None,None -> failwith "Expected variable to have type or initialiser"
    end

  | AST_val_decl (sr,name,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,DCL_val t); Exe (sr,EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,DCL_val_typeof x); Exe (sr,EXE_init (name,x))]
    | Some _,None 
    | None,None -> failwith "Expected value to have initialiser"
    end

  | AST_const_decl (sr,name, typ, s) -> [Dcl (sr,name,DCL_const (typ,s))]

  (* types *)
  | AST_abs_decl (sr,name,str) -> [Dcl (sr,name,DCL_abs str)]
  | AST_union (sr,name, components) -> [Dcl (sr,name,DCL_union components)]
  | AST_struct (sr,name, components) ->  [Dcl (sr,name,DCL_struct components)]
  | AST_type_alias (sr,name,typ) -> [Dcl (sr,name,DCL_type_alias typ)]

  (* functions *)
  | AST_function (sr,name, params, res, sts) -> 
    [Dcl (sr,name,DCL_function (params, res, rsts' sts))]
    
  | AST_procedure (sr,msgt, name, params, sts) -> 
    let rst' st = rst seq msgt st in
    let rsts' sts = catmap rst' sts in
    [Dcl (sr,name,DCL_procedure (msgt, params, rsts' sts))]
    
  | AST_block (sr,sts) ->
    begin match sts with
    | [] -> []
    | [x] -> rst' x 
    | _ ->
    let name = "_block_" ^ string_of_int (seq()) in
    [
      Dcl (sr,name,DCL_procedure (msgt,[], rsts' sts)); 
      Exe (sr,EXE_call (AST_name (generated,([name],TYP_tuple [])),AST_tuple (generated,[])))
    ]
    end

  | AST_except_handler (sr,name,params,sts) ->  
    failwith "Unexpected exception handler"
    
  | AST_fun_decl (sr,name,args,result,code) -> 
    [Dcl (sr,name,DCL_fun (args,result,code))]
  | AST_proc_decl (sr,name,args,code) -> 
    [Dcl (sr,name,DCL_proc(args,code))]

  (* misc *)
  | AST_module (sr,name, sts) -> 
    [
      Dcl (sr,name,DCL_module (rsts' sts));
      Exe 
      (
        sr,
        EXE_call 
          (
            AST_name (sr,([name;"_init_"^name],TYP_tuple [])),
            AST_tuple (generated,[])
          )
      )
    ]

  | AST_header (sr,s) -> 
    let n = seq() in 
    let name = "_ header_" ^ string_of_int n in 
    [Dcl (sr,name,DCL_header s)]

  (* executable *)
  | AST_attempt (sr,(sra,attempt), (srh,handlers), (srf,finally)) -> 
    let name_of_handler x = match x with 
      | AST_except_handler (sr',name,_,_) -> name
      | _ -> failwith ("System error, expected exception handler")
    in 
    let finally_seq = seq() in
    let finally_label = "_finally_label_" ^ string_of_int finally_seq in
    let rh h =
      match h with 
      | AST_except_handler (sr',name,params,sts) -> 
        let sts' = sts @ [AST_goto (srf,finally_label)] in
        Dcl (sr',name,DCL_procedure (msgt,params, rsts' sts'))
      | _ -> failwith "Expected statement to be handler"
    in
    let handlers' = List.map rh handlers in
    let f_dfs,f_st = split_st seq msgt srf (AST_block (srf,finally)) in
    let handler_names = map name_of_handler handlers in
    let a_dfs,a_st = split_st seq  msgt sra attempt in
      (* 
      Exe (EXE_comment "attempt statement") :: 
      Exe (EXE_comment "handlers") ::
      *)
      handlers' @ 
      (*
      [Exe (EXE_comment "(definitions for attempt)")] @
      *)
      a_dfs @ 
      (*
      [Exe (EXE_comment "(definitions for finally clause)")] @
      *)
      f_dfs @ 
      [
        (*
        Exe (EXE_comment "the attempt");
        *)
        a_st;
        Exe (srf,EXE_label finally_label);
        (*
        Exe (EXE_comment "finally clause");
        *)
        f_st;
        (*
        Exe (EXE_comment "end attempt statement")
        *)
      ]
    
  | AST_raise (sr,id,e) -> 
    let name = AST_name(sr,([id],TYP_none)) in
    [Exe (sr,EXE_call(name,e))]

  | AST_match (sr,e,pss) ->
    if List.length pss = 0 then failwith "Empty Pattern";

    (* step 1: evaluate e *)
    let d,x = rex e in
    let match_var_name = "_match_var_"^string_of_int (seq()) in
    let expr_src = src_of_expr e in
    let evl = 
      [
        Dcl (expr_src,match_var_name,DCL_var_typeof(x));
        Exe (expr_src,EXE_init (match_var_name,x))
      ]
    in
    let pats,_ = List.split pss in
    Flx_pat.validate_patterns pats
    ;
    let ematch_seq = seq() in
    let end_match_label = "_end_match_" ^ string_of_int ematch_seq in
    let matches = ref [Exe (generated,EXE_comment "begin match")] in
    let match_caseno = ref 1 in
    let match_seq = ref (seq()) in
    List.iter
    (fun (pat,st) -> 
      let n1 = !match_seq in
      let n2 = seq() in
      let patsrc = src_of_pattern pat in
      let stsrc = src_of_statement st in
      let match_checker_id = "_match_checker_" ^ string_of_int n1 in
      let match_handler_id = "_match_handler_" ^ string_of_int n1 in
      let match_checker = AST_name (patsrc,([match_checker_id],TYP_none)) in
      let match_handler = AST_name (stsrc,([match_handler_id],TYP_none)) in
      matches := !matches @
      [
        Dcl (patsrc,match_checker_id,DCL_match_check (pat,match_var_name));
        Dcl (stsrc,match_handler_id,DCL_match_handler (msgt,pat,match_var_name,rst' st))
      ]
      @
      [
      Exe (patsrc,EXE_comment ("match case " ^ string_of_int !match_caseno));
      Exe (patsrc,EXE_label ("_match_label_" ^ string_of_int n1));
      Exe 
      (
        patsrc,
        EXE_ifnotgoto 
        (
          AST_apply 
          (
            patsrc,
            (match_checker,AST_tuple (patsrc,[]))
          ), 
          "_match_label_" ^ string_of_int n2
        )
      )
      ;
      Exe 
      (
        patsrc,
        EXE_call (match_handler, AST_tuple (patsrc,[]))
      )
      ;
      Exe (patsrc,EXE_goto end_match_label)
      ]
      ;
      incr match_caseno;
      match_seq := n2
    )
    pss
    ;
    let failure_label = "_match_label_" ^ string_of_int !match_seq in
    d 
    @ 
    evl
    @
    !matches
    @
    [
      Exe (sr,EXE_comment "match failure");
      Exe (sr,EXE_label failure_label);
      Exe (sr,EXE_code "      assert((\"match failure\",false));\n");
      Exe (sr,EXE_comment "match exit");
      Exe (sr,EXE_label end_match_label)
    ]

  | AST_return (sr,e) ->
    let d,x = rex e in d @ [Exe (sr,EXE_return x)]
  
  | AST_nop _ -> []
  | AST_call (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,EXE_call (x1,x2))]

  | AST_if (sr,ifs, (esr,els)) -> 
    let ubc (sr,(e,s)) : asm_t list * (range_srcref * (expr_t * asm_t)) = 
      match split_st seq msgt sr s 
      with ss,s' -> 
        let d,x = rex e in 
        d @ ss,(sr,(x,s')) 
    in
    let ss,ifs' = split (map ubc ifs) 
    and s',els' = split_st seq msgt esr els in
    let endif_label = "_endif_" ^ string_of_int (seq()) in
    let ifcase (sr,(e,s)) = 
      let next_label = "_next_" ^ string_of_int (seq()) in
      [
        (*
        Exe (EXE_comment "conditional case");
        *)
        Exe (sr,EXE_ifnotgoto (e,next_label));
        s
        ;
        Exe (sr,EXE_goto endif_label);
        Exe (sr,EXE_label next_label);
      ] 
    in
    let ifs'' = catmap ifcase ifs' in
    (* 
    Exe (EXE_comment "conditional chain") ::
    Exe (EXE_comment "(definitions for conditional chain)") ::
    *)
    concat (ss @ [s']) @ 
    ifs'' @ 
    [ 
      (*
      Exe (EXE_comment "else clause");
      *)
      els'; 
      Exe (esr,EXE_label endif_label);
      (*
      Exe (EXE_comment "endif")
      *)
    ]

  | AST_while (sr,e,s) ->  
    let label1 = "_while_" ^ string_of_int (seq()) in
    let label2 = "_end_while_" ^ string_of_int (seq()) in
    let dfs,s' = 
      split_st seq msgt (src_of_statement s) s 
    in
    dfs @ [
      Exe (sr,EXE_label label1);
      Exe (sr,EXE_ifnotgoto (e, label2));
      s';
      Exe (sr,EXE_goto label1);
      Exe (sr,EXE_label label2);
    ]

  | AST_read (sr,name) ->  [Exe (sr,EXE_read name)]
  | AST_code (sr,s) -> [Exe (sr,EXE_code s)]


let desugar_program counter sts =
  let sr = 
    rsrange 
      (src_of_statement (List.hd sts)) 
      (src_of_statement (list_last sts))
  in
  let seq () = let n = !counter in incr counter; n in
  rst seq TYP_void (AST_module (sr,"",sts))


@h = tangler("src/flx_desugar.mli")
@select(h)
val desugar_program: 
  int ref ->
  Flx_types.statement_t list -> 
  Flx_types.asm_t list

@h = tangler("src/flxd.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_print
open Flx_types
;;

let get_options argv = 
  let options = ref [] in
  for i = 1 to Array.length argv - 2 do
    let s = argv.(i) in
    let n = String.length s in
    if n > 1 && s.[0]='-' then 
      if s.[1]='-' then 
      begin
        let j = ref 2 in
        while !j < n && s.[!j]<>'=' do incr j done;
        let key = String.sub s 2 (!j - 2) in
        let value = 
          if s.[!j]='=' then 
            String.sub s (!j+1) (n - !j - 1)
          else 
            ""
        in
          options := !options @ [key,value]
      end 
      else
        options := !options @ [String.sub s 1 1, String.sub s 2 (n-2)]
    else 
      print_endline ("Option '"^s^"' must start with '-': ignored")
  done;
  !options
;;

let print_help () =
  print_endline "options:";
  print_endline "  -h, --help : print this help";
  print_endline "  --version: print version info";
  print_endline "  -v, --verbose: print symbol table";
  print_endline "  -q, --quiet: no stdout";
  print_endline "  -Idir, --include=dir : append dir to include path";
  exit(0)
;;

let version_string = "1.0.0"
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let options = get_options Sys.argv in
  let include_dirs = ref [] in
  let print_flag = ref false in
  List.iter (fun (key,value) ->
    if key = "include" || key = "I"
    then include_dirs := !include_dirs @ [value]

    else if key = "verbose" || key = "v"
    then print_flag := true

    else if key = "help" || key = "h"
    then print_help ()

    else if key = "version" 
    then (print_endline ("Felix Version " ^ version_string))
  )
  options
  ;
  if !print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    !include_dirs;
    print_endline ""
  end
  ;

  let filebase = Sys.argv.(argc-1) in
  let input_file_name = filebase ^ ".flx" in

  print_endline ("//Parsing " ^ input_file_name);

  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      !include_dirs 
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  print_endline "//----------------------------";
  print_endline "//DESUGARED:";

  let counter = ref 1 in
  let deblocked = desugar_program counter parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "//----------------------------";

with x -> flush stdout; print_endline "EXCEPTION"; 
  print_endline (Printexc.to_string x)
;;

