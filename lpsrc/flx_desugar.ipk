@head(1,"Desugaring")
Two routines: one to build interfaces
from modules, and one to lift lambdas
and also blocks.
@h = tangler("src/flx_desugar.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2
val desugar_program: 
  sym_state_t ->
  string ->
  statement_t list -> 
  asm_t list

val include_file:
  sym_state_t ->
  string ->
  bool ->
  statement_t list

@h = tangler("src/flx_desugar.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_typing2
open List
open Flx_pat
open Flx_srcref
open Flx_exceptions
open Flx_macro
open Flx_filesys

let generated = ("Generated by desugaring",0,0,0,0)

let include_file syms inspec lookup =
  let force = syms.compiler_options.force_recompile in
  let this_version = !Flx_version.version_data in
  let basename = 
    let n = String.length inspec in
    if n <= 3 then inspec
    else 
      let x = String.sub inspec (n-4) 4 in
      match x with
      | ".flx" | ".par" -> String.sub inspec 0 (n-4)
      | _ -> inspec 
    
  in
  let include_dirs = syms.compiler_options.include_dirs in
  let tf = find_file lookup include_dirs (basename ^ ".flx") in
  let pf = find_file lookup include_dirs (basename ^ ".par") in
  let tf_mt = filetime tf in
  let pf_mt = filetime pf in
  let cbt = this_version.build_time_float in
  let saveit hash_include_files sts =
      let pf = 
        if pf = "" then 
          (try Filename.chop_extension tf with | _ -> tf) ^ ".par"
        else pf
      in
        let x = try Some (open_out_bin pf) with _ -> None in
        match x with 
        | Some x -> 
          if syms.compiler_options.print_flag then
          print_endline ("Written " ^ pf);
          Marshal.to_channel x this_version [];
          Marshal.to_channel x (hash_include_files,sts) [];
          close_out x
        | None -> () (* can't write, don't worry *)
  in
  let parseit() =
    let hash_include_files, sts = 
      if syms.compiler_options.print_flag then
      print_endline ("Parsing " ^ tf);
      Flx_parse_ctrl.parse_file 
        tf 
        (Filename.dirname tf)
        include_dirs 
        expand_expression
    in
      let local_prefix = Filename.basename basename in
      let tree = expand_macros local_prefix 5000 sts in
      hash_include_files, tree
  in
  let sts =
      (* -- no file ----------------------------------------- *)
    if tf_mt = 0.0 && pf_mt = 0.0 then 
        failwith 
        (
          "No .flx or .par file for name " ^ 
          basename ^
          " found in path:\n" ^ 
          String.concat "; " include_dirs
        )

      (* -- parsed file is newer or text doesn't exist ------- *)
    else 
    let include_name =
      Filename.chop_extension 
      (if tf <> "" then tf else pf)
    in
      if mem include_name !(syms.include_files) then [] else
      begin (* file not already included *)
        syms.include_files := include_name :: !(syms.include_files)
        ;
        if cbt < pf_mt && (not force) && tf_mt < pf_mt then 
        begin (* top level time stamps OK *)
          let x = open_in_bin pf in
          let that_version = Marshal.from_channel x in
          if this_version = that_version then begin
            let (hash_include_files,tree) = Marshal.from_channel x in
            close_in x;

            let hash_includes_agree = fold_left 
              (fun acc f -> 
                let ft = filetime f in
                acc && ft <> 0.0 && ft < pf_mt
              ) 
              true 
              hash_include_files
            in
            if hash_includes_agree then begin (* all time stamps OK *)
              if syms.compiler_options.print_flag then
              print_endline ("Loaded " ^ pf);
              tree
            end else begin (* include file timestamps wrong *)
              let hash_include_files, sts = parseit() in
              saveit hash_include_files sts;
              sts
            end
          end (* right version of compiler *)
          else 
          begin (* wrong version of compiler *)
            close_in x;
            let hash_include_files, sts = parseit() in
            saveit hash_include_files sts;
            sts
          end
        end 
        else 
        begin (* time stamps wrong *)
          let hash_include_files,sts = parseit() in
          saveit hash_include_files sts;
          sts
        end
      end (* process inclusion first time *)
  in
    sts

let fix_params seq (ps:params_t):vs_list_t * params_t = 
  let rec aux (ps:parameter_t list) :vs_list_t * parameter_t list =
    match ps with
    | (x,`TYP_none) :: t ->
      let v = "_v"^si (seq()) in
      let vt: typecode_t = `AST_name(generated,v,[]) in
      let vs,ps = aux t in
      ((v,`TPAT_any)::vs),((x,vt)::ps) (* a bit HACKY *)
      
    | h :: t -> 
      let vs,ps = aux t in 
      vs, (h::ps)
    | [] -> [],[]
  in 
  let ps, traint = ps in 
  let vs,ps = aux ps in
  vs,(ps,traint)

let arglist x = 
  match x with
  | `AST_tuple (_,ts) -> ts
  | _ -> [x]

let mkcurry seq sr name vs (args:params_t list) return_type kind body props =
  let return_type, postcondition = return_type in
  let vss',(args:params_t list)= split (map (fix_params seq) args) in
  let vs = concat (vs :: vss') in
  let mkfuntyp d c = `TYP_function (d,c)
  and typeoflist lst = match lst with
    | [x] -> x
    | _ -> `TYP_tuple lst
  in 
  let mkret arg ret = mkfuntyp (typeoflist (List.map snd (fst arg))) ret in
  let arity = List.length args in
  let rettype args = 
    match return_type with
    | `TYP_none -> `TYP_none
    | _ -> List.fold_right mkret args return_type 
  in

  let rec aux (args:params_t list) vs =  
    let n = List.length args in
    let name n = 
      if n = arity
      then name 
      else name^"'" ^ si (arity-n+1)
    in
    match args with 
    | [] -> 
        (match kind with
        | `NoInlineFunction
        | `InlineFunction
        | `Ctor 
        | `Function ->
          let props = match kind with
          | `InlineFunction -> `Inline::props
          | `NoInlineFunction -> `NoInline::props
          | `Ctor -> `Ctor::props
          | _ -> props
          in
          begin match return_type with
          | `AST_void _ ->
            `AST_function (sr, name n, vs, ([],None), (return_type,postcondition), props, body)
          | _ ->
            syserr sr "Function with no arguments"
          end

        | `Object ->
          `AST_object (sr, name n, vs, ([],None), body)
        )

    | h :: [] -> (* bottom level *)
        (match kind with
        | `NoInlineFunction
        | `InlineFunction
        | `Ctor 
        | `Function ->
          let props = match kind with
          | `InlineFunction -> `Inline::props
          | `NoInlineFunction -> `NoInline::props
          | `Ctor -> `Ctor::props
          | _ -> props 
          in
          `AST_function (sr, name n, vs, h, (return_type,postcondition), props, body)
        | `Object ->
          `AST_object (sr, name n, vs, h, body)
        )
    | h :: t ->
      let argt = 
        let hdt = hd t in
        let xargs,traint = hdt in
        typeoflist (map snd xargs) 
      in
      let m = List.length args in
      let body = 
        [
          aux t [];
          `AST_fun_return 
          (
            sr,
            `AST_suffix
            (
              sr,
              (
                `AST_name (sr,name (m-1),[]),argt
              )
            )
          )
        ] 
      in
        `AST_function (sr, name m, vs, h, (rettype t,None), [`Generated "curry";`Inline], body)
   in aux args vs

(* model binary operator as procedure call *)
let assign sr op l r = 
  match op with
  | "_set" -> `AST_cassign (sr,l,r)
  | _ ->
  `AST_call 
  (
    sr,
    `AST_name (sr, op,[]),
    `AST_tuple ( sr, [ l; r ])
  )



let find_methods seq sr sts =
  let methods = ref [] in
  let rec check = function 
    | `AST_curry (sr,mname,vs,pss,ret,kind,sts) ->
      check (mkcurry seq sr mname vs pss ret kind sts [])

    (*
    | `AST_object (sr,mname, vs, ps, sts) ->
       check (`AST_function (sr,mname,vs,ps,(`TYP_none,None),props,sts))
    *)

    | `AST_function (sr,mname, vs, ps, (ret,postcondition),props,sts) ->
      if vs <> [] then
      clierr sr "[process_object] Object methods may not be generic"
      ;
      let argtyp = match map snd (fst ps) with 
        | [] -> `TYP_tuple []
        | [a] -> a
        | x -> `TYP_tuple x
      in
      let typ = `TYP_function (argtyp, ret) in
      methods := (mname, typ) :: !methods
    | _ -> ()
  in
  iter check sts
  ;
  rev !methods

(* split lambdas out. Each lambda is replaced by a
   reference to a synthesised name in the original
   statement, which is prefixed by the definition.

   Blocks are replaced by a procedure definition
   and a call.

   The match statement requires all case bodies
   be replaced by calls as well.

   Actual lambdas in expressions are replaced
   by a reference and function or procedure definition.

   Attempt handler bodies are requires all handlers
   to be replaced by a call as well.
*)

(* convert an expression into a list of assembly instructions,
   plus an expression: basically, this means removing lambdas
*)

(*
  ARGGG! rex guarrantees to lift lambdas out of expressions,
  but the lifted lambda declarations also have bodies
  which might contain expression containing lambdas,
  so we have to apply rsts to these bodies..
*)

let rec rex syms name (e:expr_t) : asm_t list * expr_t = 
  let rex e = rex syms name e in
  let rsts sts = concat (map (rst syms name `Private []) sts) in
  let sr = src_of_expr e in
  let seq () = let n = !(syms.counter) in incr (syms.counter); n in
  match e with

  | `AST_sparse _ 
  | `AST_match_ctor _ 
  | `AST_match_case _ 
  | `AST_ctor_arg _ 
  | `AST_case_arg _ 
  | `AST_void _ 
  | `AST_arrow _ 
  | `AST_longarrow _ 
  | `AST_superscript _ 
  | `AST_as _
  | `AST_product _ 
  | `AST_sum _
  | `AST_andlist _
  | `AST_orlist _
  | `AST_ellipsis _
  | `AST_lvalue _
  | `AST_setunion  _
  | `AST_setintersection _
  | `AST_macro_ctor _
  | `AST_macro_statements _
    ->
    clierr sr ("[rex] Unexpected " ^ string_of_expr e)

  | `AST_type_match _ -> [],e

  | `AST_noexpand (_,e) -> rex e
  | `AST_name (sr,name,_) -> [],e

  | `AST_deref (sr,e) ->
    let l1,x1 = rex e in
    l1, `AST_deref (sr,x1)

  | `AST_ref (sr,e) ->
    let l1,x1 = rex e in
    l1, `AST_ref (sr,x1)

  | `AST_suffix _ -> [],e  (* ?? *)
  | `AST_callback _ -> [],e  (* ?? *)

  | `AST_the (_,_) -> [],e
  | `AST_index (_,_,_) -> [],e
  
  | `AST_lookup (sr,(e,id,ts)) ->
    let l1,x1 = rex e in
    l1, `AST_lookup (sr,(x1,id,ts))

  | `AST_case_tag _ -> [],e
  | `AST_typed_case _ -> [],e
  | `AST_literal _ -> [],e

  | `AST_expr _ -> [],e

  | `AST_vsprintf (sr,s) ->
    let ix = seq () in
    let id = si ix in
    let str = `AST_name (sr,"string",[]) in
    let ts = Flx_cformat.types_of_cformat_string sr s in
    let ss = Flx_print.string_of_string s in
    let fs = "flx::rtl::strutil::flx_asprintf("^ss^",$a)" in
    let req = `NREQ_atom (`AST_name (sr,"flx_strutil",[])) in
    let f = `DCL_fun([],ts,str,`StrTemplate fs,req,"primary") in
    let x=`AST_index (sr,id,ix) in
    [
      Dcl (sr,id,Some ix,`Private,[],f);
    ],x
    
  | `AST_cond (sr,(e,b1,b2)) ->
     rex 
     (
       `AST_match 
       (
         sr,
         (
           e,
           [
             `PAT_const_ctor (sr,`AST_case_tag (sr,1)),b1; (* true *)
             `PAT_any sr,b2 (* false *)
           ]
         )
       )
     )
     
  (* we have to lift lambdas out of typeof exprs,
     even though they're never called,
     so the typing works correctly
  *)
  | `AST_typeof (sr,e') ->
    let l1,x1 = rex e' in
    l1, `AST_typeof (sr,(x1))

  | `AST_get_n (sr,(n,e')) ->
    let l1,x1 = rex e' in
    l1, `AST_get_n (sr,(n,x1))

  | `AST_get_named_variable (sr,(n,e')) ->
    let l1,x1 = rex e' in
    l1, `AST_get_named_variable (sr,(n,x1))

  | `AST_get_named_method (sr,(n,mix,ts,e')) ->
    let l1,x1 = rex e' in
    l1, `AST_get_named_method (sr,(n,mix,ts,x1))

  | `AST_case_index (sr,e) -> 
    let l,x = rex e in
    l,`AST_case_index (sr,x)

  | `AST_apply (sr,(fn,arg)) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, `AST_apply (sr,(x1,x2))

  | `AST_map (sr,fn,arg) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, `AST_map (sr,x1,x2)

  | `AST_method_apply (sr,(fn,arg,ts)) -> 
    let l2,x2 = rex arg in
    l2, `AST_method_apply (sr,(fn,x2,ts))
    
  | `AST_tuple (sr,t) -> 
    let lss,xs = split (map rex t) in
    concat lss,`AST_tuple (sr,xs)

  | `AST_record (sr,es) -> 
    let ss,es = split es in
    let lss,xs = split (map rex es) in
    concat lss,`AST_record (sr,combine ss xs)

  | `AST_record_type _ -> assert false
  
  | `AST_variant (sr,(s,e)) -> 
    let l,x = rex e in
    l,`AST_variant (sr,(s,x))

  | `AST_variant_type _ -> assert false

  | `AST_arrayof (sr,t) -> 
    let lss,xs = split (map rex t) in
    concat lss,`AST_arrayof(sr,xs)

  | `AST_lambda (sr,(pps,ret,sts)) -> 
    let kind = `InlineFunction in
    let n = seq() in
    let name' = "_lam_" ^ si n in
    let access = `Private in
    let vs = [] in
    let sts = 
      rst syms name access [] (mkcurry seq sr name' vs pps (ret,None) kind sts [`Generated "lambda"])
    in
    if length pps = 0 then syserr sr "[rex] Lambda with no arguments?" else
    let t = type_of_argtypes (map snd (fst (hd pps))) in
    let e = 
      `AST_suffix 
      (
        sr,
        (
          `AST_name (sr,name',[]), t
        )
      )
    in
    sts,e

  | `AST_dot (sr,(obj,comp,ts)) -> 
    let l1,x1 = rex obj in 
    l1 , `AST_dot (sr,(x1,comp,ts))

  | `AST_coercion (sr,(e,t)) ->
    let l1,x1 = rex e in 
    l1, `AST_coercion (sr,(x1,t))
  
  | `AST_parse (sr,e,ms) ->
    (* SIMPLIFY TO ONE SYMBOL PLUS DUMMY NONTERMS *)
    let l,e = rex e in
    let n = seq() in
    let nt = "_nt_"^si n in
    let nt_name = `AST_index (sr,nt,n) in
    let l,glr_ixs = 
      fold_left 
      (fun (ll,glr_ixs) (sr,p,e) -> 
        let t = `TYP_none in
        let glr_idx = seq() in
        let dcls = handle_glr seq rex sr p e glr_idx t nt in
        dcls @ l @ ll,
        (*
        Dcl(sr,nt,Some n',`Private,[],`DCL_glr(t,(p,x))) :: l @ ll,
        *)
        glr_idx::glr_ixs
      )
      (l,[])
      ms
    in
    l,`AST_sparse (sr,e,nt,glr_ixs)
  
  | `AST_regmatch (sr,(p1,p2,cls')) ->
    let dcls = ref [] in
    let cls = ref [] in
    iter 
    (fun (re,e) -> 
      let l,x = rex e in
      dcls := l @ !dcls;
      cls := (re,x) :: !cls
    )
    cls'
    ;

    let n = seq() in
    let fname = "regmatch" ^ si n in
    let l1,p1 = rex p1 in
    let l2,p2 = rex p2 in
    let rfun = Dcl(sr,fname,Some n,`Private,[], `DCL_regmatch !cls) in
    let pp = `AST_tuple (sr,[p1;p2]) in
    rfun :: l1 @ l2 @ !dcls,
    `AST_apply(sr,(`AST_index(sr,fname,n),pp))

  | `AST_string_regmatch (sr,(s,cls)) ->
    let l1,s = rex s in
    let ssr = src_of_expr s in
    let vix = seq() in
    let vid = "_me_" ^ si vix in
    let v = `AST_index(sr,vid,vix) in
    let pa = `PAT_as (sr,`PAT_any sr,"_a") in
    let pb = `PAT_as (sr,`PAT_any sr,"_b") in
    let p = `PAT_tuple (sr,[pa;pb]) in
    let a = `AST_name (sr,"_a",[]) in
    let b = `AST_name (sr,"_b",[]) in
    let lexmod = `AST_name(sr,"Lexer",[]) in
    let sb = `AST_lookup(sr,(lexmod,"bounds",[])) in
    let se = `AST_apply(sr,(sb,v)) in
    let r =
      `AST_letin (sr,(p,se,
        `AST_regmatch (sr,(a,b,cls)))
      )
    in 
      let l2,x = rex r in
      let d1 =  
        Dcl (ssr,vid,Some vix,`Private,[], `DCL_var (`TYP_typeof(s)))
      in 
      let d2 =
        Exe (ssr,`EXE_iinit ((vid, vix),s))
      in
      d1 :: d2 :: l1 @ l2, x


  | `AST_reglex (sr,(p1,p2,cls')) ->
    let dcls = ref [] in
    let cls = ref [] in
    let le = `AST_name (sr,"lexeme_end",[]) in
    iter 
    (fun (re,e) -> 
      let l,x = rex e in
      let x = `AST_tuple (sr,[le;x]) in
      dcls := l @ !dcls;
      cls := (re,x) :: !cls
    )
    cls'
    ;

    let n = seq() in
    let fname = "reglex" ^ si n in
    let l1,p1 = rex p1 in
    let l2,p2 = rex p2 in
    let rfun = Dcl(sr,fname,Some n,`Private,[], `DCL_reglex !cls) in
    let pp = `AST_tuple (sr,[p1;p2]) in
    rfun :: l1 @ l2 @ !dcls,
    `AST_apply(sr,(`AST_index(sr,fname,n),pp))
   
  | `AST_letin (sr,(pat,e1,e2)) ->
    rex (`AST_match (sr,(e1,[pat,e2])))
    
  (* MATCH HANDLING NEEDS TO BE REWORKED, THE SWITCHING SHOULD BE
     DELAYED TO ALLOW TYPE BASED OPTIMISATION WHERE THE TOP
     LEVEL MATCH ON A UNION CAN USE A SWITCH.

     ALSO, TO ALLOW MULTIPLE PATTERNS WITH ONE HANDLER,
     GIVE THE HANDLER PARAMETERS, AND HAVE THE TOP LEVEL
     MATCH HANDLERS FOR EACH CASE FOR THAT CODE CALL IT:

     eg:
     
     match x with | A x | B x => x endmatch
  *)

 
  | `AST_match (sr,(e,pss)) ->
    if length pss = 0 then clierr sr "Empty Pattern";

    (* step 1: evaluate e *)
    let d,x = rex e in
    let match_function_index = seq() in
    let match_var_index = seq() in
    (*
    print_endline ("Match function index = " ^ si match_function_index );
    print_endline ("Match variable index = " ^ si match_var_index );
    *)

    let match_var_name = name^ "_mv_"^si match_function_index in
    let match_function_id = name^ "_mf_"^ si match_function_index in
    let match_function = `AST_index (sr,match_function_id,match_function_index) in
    let match_seq = ref (seq()) in

    let expr_src = src_of_expr e in

    (* WOE. The expr may contain a lambda, which stuffs up
       bind_expression which is called by bind_type ..
    *)
    let evl = 
      [
        Dcl (expr_src,match_var_name,Some match_var_index,`Private,[],`DCL_val (`TYP_typeof x));
        Exe (expr_src,`EXE_iinit ((match_var_name,match_var_index),x))
      ]
    in
    let pats,_ = split pss in
    Flx_pat.validate_patterns pats
    ;
    let ematch_seq = seq() in
    (*
    let end_match_label = "_em" ^ si ematch_seq in
    *)
    let matches = ref [Exe (generated,`EXE_comment "begin match")] in
    let match_caseno = ref 1 in
    let iswild = ref false in
    iter
    (fun (pat,e) -> 
      let n1 = !match_seq in
      let n2 = seq() in
      let mh_idx = seq () in
      let mc_idx = seq () in
      if !iswild then
        print_endline "WARNING, matches after wildcard ignored"
      else begin
        iswild := is_universal pat;
        let patsrc = src_of_pat pat in
        let expr_src = src_of_expr e in
        let match_checker_id = name ^ "_mc" ^ si n1 in
        let match_handler_id = name ^ "_mh" ^ si n1 in
        let match_checker = `AST_index (patsrc,match_checker_id,mc_idx) in
        let match_handler = `AST_index (expr_src,match_handler_id,mh_idx) in
        (*
        print_endline ("Match checker index = " ^ si mc_idx);
        print_endline ("Match handler index = " ^ si mh_idx);
        *)
        let sts,result_expr = rex e in
        let body = 
          sts @ 
          [Exe (expr_src,`EXE_fun_return (result_expr))] 
        in
        matches := !matches @
        [
          Dcl (patsrc,match_checker_id,Some mc_idx,`Private,[],
          `DCL_match_check (pat,(match_var_name,match_var_index)));
          Dcl 
          (
            expr_src,
            match_handler_id,Some mh_idx,
            `Private,
            [],
            `DCL_match_handler 
            (
              pat,
              (match_var_name,match_var_index),
              body
            )
          )
        ]
        @
        [
        Exe (patsrc,`EXE_comment ("match case " ^ si !match_caseno^":" ^ string_of_pattern pat))
        ]
        @
        (
        (* we dont need a label for the first case *)
        if !match_caseno <> 1 then
        [
        Exe (patsrc,`EXE_label ("_ml" ^ si n1))
        ]
        else []
        )
        @

        (* This code checks the match condition, it can be
           elided if the match is wildcard 
        *)
        (if !iswild then [] else
        [
          Exe 
          (
            patsrc,
            `EXE_ifnotgoto 
            (
              `AST_apply 
              (
                patsrc,
                (
                  match_checker,
                  `AST_tuple (patsrc,[])
                )
              ), 
              "_ml" ^ si n2
            )
          )
        ]
        )
        @
        [
        Exe 
        (
          patsrc,
          `EXE_fun_return 
          (
            `AST_apply 
            (
              patsrc,
              (
                match_handler, 
                `AST_tuple (patsrc,[])
              )
            )
          )
        )
        (*
        ;
        Exe (patsrc,`EXE_goto end_match_label)
        *)
        ]
        ;
        incr match_caseno;
        match_seq := n2
      end
    )
    pss
    ;
    let failure_label = "_ml" ^ si !match_seq in

    let match_function_body =
    d
    @
    evl
    @
    !matches
    @
    (if !iswild then [] else
      let f,sl,sc,el,ec = sr in
      let s = Flx_print.string_of_string f ^"," ^ 
        si sl ^ "," ^ si sc ^ "," ^
        si el ^ "," ^ si ec
      in
      [
        Exe (sr,`EXE_comment "match failure");
        Exe (sr,`EXE_label failure_label);
        Exe (sr,`EXE_noreturn_code (`Str ("      FLX_MATCH_FAILURE("^s^");\n")));
      ]
    )
    in
    [
      Dcl 
      (
        sr,
        match_function_id,Some match_function_index,
        `Private,
        [],
        `DCL_function 
        (
          ([],None),
          `TYP_none,
          [`Inline;`Generated "desugar:match fun"],
          match_function_body
        )
      )
    ]
    ,
    `AST_apply 
    (
      sr,
      (
        match_function, 
        `AST_tuple (sr,[])
      )
    )

(* remove blocks *)
(* parent vs is containing module vs .. only for modules *)

and maybe_tpat = function
  | `TPAT_any -> ""
  | tp -> ": " ^ string_of_tpattern tp

and string_of_vs (vs:vs_list_t) = 
  cat "," (map (fun (v,tp) -> v ^ maybe_tpat tp) vs)

and rst syms name access (parent_vs:vs_list_t) st : asm_t list = 
  (* construct an anonymous name *)
  let parent_ts sr : typecode_t list = 
    map (fun (s,tp)-> `AST_name (sr,s,[])) parent_vs 
  in
  let rqname' sr = `AST_name (sr,"_rqs_" ^ name,parent_ts sr) in

  (* Add a root to child named 'n'.
     All root requirements in the child go to this symbol, 
     and it requires our root in turn.

     parent_vs is the vs list required for us,
     it is always empty for a function.
  *)
  let bridge n sr : asm_t = 
    (*
    print_endline ("Making bridge for " ^ n ^ " -> " ^ name ^"["^string_of_vs _vs ^"]");
    *)
    let ts = map (fun (s,_)-> `AST_name (sr,s,[])) parent_vs in
    let us = `NREQ_atom (`AST_name (sr,"_rqs_" ^ name,ts)) in
    let body = `DCL_insert (`Str "",`Body,us) in
    Dcl (sr,"_rqs_"^n,None,`Public,[],body)
  in

  (* rename _root requirements *)
  let map_reqs sr (reqs : named_req_expr_t) : named_req_expr_t = 
    `NREQ_and (`NREQ_atom (rqname' sr), reqs)
  in

  (* name literal requirements *)
  let mkprop sr s = match s with
    | "needs_gc" -> `Uses_gc
    | "needs_ptf" -> `Requires_ptf
    | x -> clierr sr ("Unknown property " ^ x)
  in
  let mkreqs sr (rqs :raw_req_expr_t) : property_t list * asm_t list * named_req_expr_t =
    let ix = None in
    let props = ref [] in
    let decls = ref [] in
    let rec aux rqs = match rqs with 
    | `RREQ_or (a,b) -> `NREQ_or (aux a, aux b)
    | `RREQ_and (a,b) -> `NREQ_and (aux a, aux b)
    | `RREQ_true -> `NREQ_true
    | `RREQ_false -> `NREQ_false
    | `RREQ_atom x -> match x with
      | `Body_req s ->
        let n = !(syms.counter) in incr syms.counter;
        let n = "_req_" ^ si n in
        let dcl = Dcl (sr,n,ix,access,[],`DCL_insert (s,`Body,`NREQ_true)) in
        decls := dcl :: !decls;
        `NREQ_atom (`AST_name (sr,n,parent_ts sr))

      | `Header_req s ->
        let n = !(syms.counter) in incr syms.counter;
        let n = "_req_" ^ si n in
        let dcl = Dcl (sr,n,ix,access,[],`DCL_insert (s,`Header,`NREQ_true)) in
        decls := dcl :: !decls;
        `NREQ_atom (`AST_name (sr,n,parent_ts sr))

      | `Package_req s ->
        let n = !(syms.counter) in incr syms.counter;
        let n = "_req_" ^ si n in
        let dcl = Dcl (sr,n,ix,access,[],`DCL_insert (s,`Package,`NREQ_true)) in
        decls := dcl :: !decls;
        `NREQ_atom (`AST_name (sr,n,parent_ts sr))

      | `Named_req n -> `NREQ_atom n
      | `Property_req s -> 
        props := mkprop sr s :: !props;
        `NREQ_true
    in 
    let r = aux rqs in
    !props, !decls, r
  in

  (* rename _root headers *)
  let map_req n = if n = "_root" then "_rqs_" ^ name else n in

  let rex x = rex syms name x in
  let rsts name vs access sts = concat (map (rst syms name access vs) sts) in
  let seq () = let n = !(syms.counter) in incr (syms.counter); n in
  (* add _root headers and bodies as requirements for all
    bindings defined in this entity
  *)
  match st with
  | `AST_seq _ -> assert false
  | `AST_private (sr,st) ->
     rst syms name `Private parent_vs st
     
  | `AST_include (sr,inspec) ->
    let sts = include_file syms inspec true in
    rsts name parent_vs  access sts

  | `AST_regdef (sr,name,regexp) -> 
    [Dcl (sr,name,None,access,[],`DCL_regdef regexp)]
  | `AST_label (sr,s) -> [Exe (sr,`EXE_label s)]
  | `AST_proc_return sr -> [Exe (sr,`EXE_proc_return)]
  | `AST_goto (sr,s) -> [Exe (sr,`EXE_goto s)]
  | `AST_open (sr,name) -> [Dir (sr,DIR_open name)]
  | `AST_inject_module (sr,name) -> [Dir (sr,DIR_inject_module name)]
  | `AST_use (sr,n,qn) -> [Dir (sr,DIR_use (n,qn))]
  | `AST_comment s -> [Exe (generated,`EXE_comment s)]

  (* objects *)
  | `AST_export_fun (sr,name,cpp_name) ->
    [Iface (sr,`IFACE_export_fun (name,cpp_name))]

  | `AST_export_type (sr,typ,cpp_name) ->
    [Iface (sr,`IFACE_export_type (typ,cpp_name))]

  | `AST_var_decl (sr,name,vs,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,None,access,vs,`DCL_var t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,None,access,vs,`DCL_var (`TYP_typeof x)); Exe (sr,`EXE_init (name,x))]
    | Some t,None -> [Dcl (sr,name,None,access,vs,`DCL_var t)]
    | None,None -> failwith "Expected variable to have type or initialiser"
    end

  | `AST_val_decl (sr,name,vs,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,None,access,vs,`DCL_val t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,None,access,vs,`DCL_val (`TYP_typeof x)); Exe (sr,`EXE_init (name,x))]
    | Some t, None -> [Dcl (sr,name,None,access,vs,`DCL_val t)] (* allowed in interfaces *)
    | None,None -> failwith "Expected value to have type or initialiser"
    end

  | `AST_const_decl (sr,name, vs,typ, s, reqs) -> 
    let props,dcls, reqs = mkreqs sr reqs in
    Dcl (sr,name,None,access,vs,`DCL_const (typ,s, map_reqs sr reqs))
    :: dcls

  (* types *)
  | `AST_abs_decl (sr,name,vs,quals,s, reqs) -> 
    let props,dcls, reqs = mkreqs sr reqs in
    Dcl (sr,name,None,access,vs,`DCL_abs (quals,s,map_reqs sr reqs))
    :: dcls
  
  | `AST_union (sr,name, vs, components) -> [Dcl (sr,name,None,access,vs,`DCL_union (components))]
  | `AST_struct (sr,name, vs, components) ->  [Dcl (sr,name,None,access,vs,`DCL_struct (components))]
  | `AST_cstruct (sr,name, vs, components) ->  [Dcl (sr,name,None,access,vs,`DCL_cstruct (components))]
  | `AST_cclass (sr,name, vs, components) ->  [Dcl (sr,name,None,access,vs,`DCL_cclass (components))]

  | `AST_class (sr,name', vs', sts) -> 
    (* let asms = rsts name' (parent_vs @ vs') sts in *)
    let asms = rsts name' [] `Public sts in
    let asms = bridge name' sr :: asms in
    let mdcl =
      [ Dcl (sr,name',None,access,vs', `DCL_class asms) ]
    in mdcl


  | `AST_type_alias (sr,name,vs,typ) -> [Dcl (sr,name,None,access,vs,`DCL_type_alias (typ))]
  | `AST_inherit (sr,name,vs,qn) -> [Dcl (sr,name,None,access,vs,`DCL_inherit qn)]
  | `AST_inherit_fun (sr,name,vs,qn) -> [Dcl (sr,name,None,access,vs,`DCL_inherit_fun qn)]

  | `AST_curry (sr,name',vs,pps,ret,kind,sts) ->
    rst syms name access parent_vs (mkcurry seq sr name' vs pps ret kind sts [])

  (* The object *)
  (* THIS IS HACKY AND DOESN'T WORK PROPERLY --
    need a real object construction --
    the constructor name and object type should
    be the same .. at present the exported type
    may refer to typedefs in the constructor function,
    and these cant be found by lookup .. really
    we need to use a proper construction that will
    be bound correctly without lookup
  *)
  | `AST_object (sr,name,vs,params,sts) -> 
    let vs',params = fix_params seq params in
    let vs = vs @ vs' in
    let methods = find_methods seq sr sts in
    let mtuple =  
      `AST_tuple 
      (
        sr,
        map 
          (fun (n,t) ->
            match t with 
            | `TYP_function (d,_) ->
              `AST_suffix ( sr, ( `AST_name (sr,n,[]), d))
            | _ -> assert false
          )
          methods
      ) 
    in
    let otname = "_ot_" ^ name in
    let rtyp = `AST_name (sr,otname,[]) in
    let retval:expr_t = `AST_apply (sr,(rtyp, mtuple)) in
    let sts = sts @ [`AST_fun_return (sr,retval)] in
    let asms = rsts name [] `Public sts in
    let asms = bridge name sr :: asms in
    [
      Dcl (sr,otname,None,access,vs,`DCL_struct methods);
      Dcl (sr,name,None,access,vs,`DCL_function (params,rtyp,[],asms))
    ]
  
  (* functions *)
  | `AST_reduce (sr,name,vs,params, rsrc,rdst) ->
    [ Dcl (sr,name,None,access,vs,`DCL_reduce (params,rsrc,rdst)) ]

  | `AST_axiom (sr,name,vs,params, rsrc) ->
    [ Dcl (sr,name,None,access,vs,`DCL_axiom (params,rsrc)) ]
 
  | `AST_function (sr,name', vs, params, (res,postcondition), props, sts) -> 
    let ps,traint = params in
    begin match traint,postcondition with
    | None,None ->
      let vs',params = fix_params seq params in
      let vs = vs @ vs' in
      let asms = rsts name' [] `Public sts in
      let asms = bridge name' sr :: asms in
      [
        Dcl (sr,name',None,access,vs, 
          `DCL_function (params, res, props, asms)
        )
      ]
    | pre,post ->
      let name'' = "_wrap_" ^ name' in
      let inner = `AST_name (sr,name'',[]) in
      let un = `AST_tuple (sr,[]) in
      let sts = 
        (match pre with
        | None -> []
        | Some x -> [`AST_assert (src_of_expr x,x)]
        )
        @
        [
          `AST_function (sr,name'', [],([],None),(res,None),props,sts);
        ]
        @
        begin match res with 
        | `AST_void _ ->
           [`AST_call (sr,inner,un) ] @ 
           begin match post with
           | None -> []
           | Some y -> [`AST_assert (src_of_expr y,y)]
           end
          | _ ->
            let retval:expr_t = `AST_apply(sr,(inner,un)) in
            begin match post with
            | None ->
              [`AST_fun_return (sr,retval)]
            | Some y -> 
              [
                `AST_val_decl (sr,"result",[],None,Some retval);
                `AST_assert (src_of_expr y,y);
                `AST_fun_return (sr,`AST_name (sr,"result",[]))
              ]
            end
        end
      in 
      let st =
        `AST_function (sr,name',vs,(ps,None),(res,None),props,sts)
      in 
      rst syms name access parent_vs st
    end
      
  | `AST_fun_decl (sr,name',vs,args,result,code, reqs,prec) ->
    let props, dcls, reqs = mkreqs sr reqs in
    (* hackery *)
    let vs,args = fold_left (fun (vs,args) arg -> match arg with
        | `TYP_apply
          (
            `AST_name (_,"excl",[]),
            `AST_name (sr,name,[])
          ) ->
            let n = seq() in
            let var = "T"^si n in
            (*
            print_endline ("Implicit var " ^ var);
            *)
            let v = var,`TPAT_name (name,[]) in
            let arg = `AST_name (sr,var,[]) in 
            v::vs, arg:: args
        | x -> vs,x::args
      )
      (rev vs,[])
      args
    in
    Dcl (sr,name',None,access,rev vs,
      `DCL_fun (props,rev args,result,code,map_reqs sr reqs,prec))
    :: dcls

  | `AST_callback_decl (sr,name',args,result,reqs) ->
    let props, dcls, reqs = mkreqs sr reqs in
    Dcl (sr,name',None,access,[],
      `DCL_callback (props,args,result,map_reqs sr reqs))
    :: dcls

  (* misc *)
  | `AST_untyped_module (sr,name', vs', sts) -> 
    let asms = rsts name' (parent_vs @ vs') `Public sts in
    let asms = bridge name' sr :: asms in
    let mdcl =
      [ Dcl (sr,name',None,access,vs', `DCL_module asms) ]
    in
      (* HACK !!!! *)
    if vs' = [] then
    (
      Exe 
      (
        sr,
        `EXE_call 
        (
          `AST_suffix
          (
            sr,
            (
              `AST_lookup
              (
                sr,
                (
                  `AST_name (sr,name',[]),
                  "_init_",
                  []
                )
              ),
              `TYP_tuple []
            )
          ),
          `AST_tuple (generated,[])
        )
      )
    ) :: mdcl else mdcl

  | `AST_insert (sr,name',vs,s,kind,reqs) -> 
    let props, dcls, reqs = mkreqs sr reqs in
    (* SPECIAL case: insertion requires insertion use filo order *)
    dcls @ [
      Dcl (sr,map_req name',None,access,vs,`DCL_insert (s, kind, map_reqs sr reqs))
    ]

  (* executable *)
  | `AST_fun_return (sr,e) ->
    let d,x = rex e in d @ [Exe (sr,`EXE_fun_return x)]
  
  | `AST_assert (sr,e) -> 
    let d,x = rex e in d @ [Exe (sr,`EXE_assert x)]

  | `AST_nop _ -> []

  | `AST_cassign (sr,l,r) ->
     let l1,x1 = rex l in
     let l2,x2 = rex r in
     l1 @ l2 @ [Exe (sr,`EXE_assign (x1,x2))]
     
  | `AST_assign (sr,fid,l,r) ->
    let rec aux (l,t) r =
      match l with
      | `Expr (sr,e) -> 
        begin match e with
        | `AST_tuple (_,ls) ->
          let n = seq() in
          let vn = "_" ^ si n in
          let sts = ref [] in
          let count = ref 0 in
          iter
          (fun l ->
            let r' = `AST_get_n (sr,(!count,`AST_name (sr,vn,[]))) in
            let l' = `Expr (sr,l),None in
            let asg = aux l' r' in
            sts := !sts @ asg;
            incr count
          )
          ls
          ;
          `AST_val_decl (sr,vn,[],t,Some r) :: !sts
        | _ -> 
          if fid = "_init"
          then
            match e with
            | `AST_coercion (_,(`AST_name (_,n,[]),t')) ->
              let t = match t with 
                | None -> Some t'
                | t -> t
              in
              [`AST_val_decl (sr,n,[],t,Some r)]

            | `AST_name (_,n,[]) ->
              [`AST_val_decl (sr,n,[],t,Some r)]
            | _ -> clierr sr "identifier required in val init"
          else
            [assign sr fid e r]
        end
      | `Val (sr,n) ->
          [`AST_val_decl (sr,n,[],t,Some r)]
      | `Var (sr,n) ->
          [`AST_var_decl (sr,n,[],t,Some r)]
      | `Skip (sr) ->  []
      | `Name (sr,n) -> 
        let n = `AST_name(sr,n,[]) in
          [assign sr fid n r]
      | `List ls ->
          let n = seq() in
          let vn = "_" ^ si n in
          let sts = ref [] in
          let count = ref 0 in
          iter
          (fun l ->
            let r' = `AST_get_n (sr,(!count,`AST_name (sr,vn,[]))) in
            let asg = aux l r' in
            sts := !sts @ asg;
            incr count
          )
          ls
          ;
          `AST_val_decl (sr,vn,[],t,Some r) :: !sts
    in
      let sts = aux l r in
      rsts name parent_vs access sts

  | `AST_call (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_call (x1,x2))]

  | `AST_apply_ctor (sr,name,f,a) -> 
    let d1,f1 = rex f in
    let d2,a1 = rex a in
    let t = `TYP_typeof(f1) in
    let vs = [] in
    d1 @ d2 @ [
      Dcl (sr,name,None,access,vs,`DCL_var t);
      Exe (sr,`EXE_apply_ctor (name,f1,a1))
    ]

  | `AST_init (sr,v,e) ->
    let d,x = rex e in
    d @ [Exe (sr,`EXE_init (v,e))]

  | `AST_jump (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_jump (x1,x2))]

  | `AST_loop (sr,proc, arg) ->
    let d2,x2 = rex arg in
    d2 @ [Exe (sr,`EXE_loop (proc,x2))]

  | `AST_ifgoto (sr,e,lab)->
    let d,x = rex e in
    d @ [Exe (sr,`EXE_ifgoto (x,lab))]

  | `AST_ifnotgoto (sr,e,lab)->
    let d,x = rex e in
    d @ [Exe (sr,`EXE_ifnotgoto (x,lab))]

   
  | `AST_svc (sr,name) ->  [Exe (sr,`EXE_svc name)]
  | `AST_code (sr,s) -> [Exe (sr,`EXE_code s)]
  | `AST_noreturn_code (sr,s) -> [Exe (sr,`EXE_noreturn_code s)]

  (* split into multiple declarations *)
  | `AST_glr (sr, id, t, ms )  -> 
    let rec aux dcls ms = match ms with
    | [] ->dcls
    | (sr',p,e)::ta -> 
       let glr_idx = seq() in
       let dcls' = handle_glr seq rex sr' p e glr_idx t id in
       aux (dcls' @ dcls) ta
    in aux [] ms

  | `AST_user_statement _
  | `AST_ctypes _ 
  | `AST_expr_macro _ 
  | `AST_ifdo _ 
  | `AST_ifreturn _ 
  | `AST_macro_assign _
  | `AST_macro_forget _ 
  | `AST_macro_goto _ 
  | `AST_macro_ifgoto _ 
  | `AST_macro_label _
  | `AST_macro_proc_return _ 
  | `AST_macro_val _ 
  | `AST_macro_vals _ 
  | `AST_macro_var _ 
  | `AST_macro_name _
  | `AST_macro_names _
  (*
  | `AST_public _ 
  *)
  | `AST_stmt_macro _ 
  | `AST_macro_block _ 
  (*
  | `AST_until _ 
  | `AST_whilst _
  *)
  | `AST_macro_ifor _
  | `AST_macro_vfor _
    -> assert false

and handle_glr seq rex sr' p e glr_idx t nt_id =
  (* p can contain expressions now, we have to
    create dummy glr's for them
  *)
  let new_glrs = ref [] in
  let new_ast (qn:qualified_name_t) : qualified_name_t =
    (* qs = qn qs | epsilon -- right recursive *)
    let qt = `TYP_glr_attr_type qn in
    let typ = 
      `TYP_as 
      (
        `TYP_sum 
        [
          `TYP_tuple []; 
          `TYP_tuple [qt; `AST_name (sr',"__fix__",[])]
        ],
        "__fix__"
      )
    in
    let glr_idx = seq() in
    let nt_id = "_ast_" ^ si glr_idx in
    let nt_name = `AST_name (sr',nt_id,[]) in
    let p = [(Some "_1",qn); (Some "_2",nt_name)] in
    let e = 
      `AST_apply 
      (sr',
        (
         `AST_typed_case (sr',1,typ),
         `AST_tuple 
           (
             sr',
             [
               `AST_name (sr',"_1",[]); 
               `AST_name (sr',"_2",[])
             ]
          )
        )
      )
    in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;

    let e = `AST_typed_case (sr',0,typ) in
    let p = [] in
    let glr_idx = seq() in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;
    `AST_name (sr',nt_id,[])
  in
  let new_plus (qn:qualified_name_t) : qualified_name_t =
    (* qs = qn qs | qn -- right recursive *)
    let qt = `TYP_glr_attr_type qn in
    let typ = 
      `TYP_as 
      (
        `TYP_sum 
        [
          `TYP_tuple []; 
          `TYP_tuple [qt; `AST_name (sr',"__fix__",[])]
        ],
        "__fix__"
      )
    in
    let glr_idx = seq() in
    let nt_id = "_plus_" ^ si glr_idx in
    let nt_name = `AST_name (sr',nt_id,[]) in
    let p = [(Some "_1",qn); (Some "_2",nt_name)] in
    let e = 
      `AST_apply 
      (sr',
        (
         `AST_typed_case (sr',1,typ),
         `AST_tuple 
           (
             sr',
             [
               `AST_name (sr',"_1",[]); 
               `AST_name (sr',"_2",[])
             ]
          )
        )
      )
    in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;

    let e =
      `AST_apply 
      (sr',
        (
         `AST_typed_case (sr',1,typ),
         `AST_tuple 
           (
             sr',
             [
               `AST_name (sr',"_1",[]); 
               `AST_typed_case (sr',0,typ)
             ]
          )
        )
      )
    in

    let p = [(Some "_1",qn)] in
    let glr_idx = seq() in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;
    `AST_name (sr',nt_id,[])
  in
  let new_opt (qn:qualified_name_t) : qualified_name_t =
    (* qs = qn | epsilon *)
    let qt = `TYP_glr_attr_type qn in
    let typ = `TYP_sum [ `TYP_tuple []; qt] in
    let glr_idx = seq() in
    let nt_id = "_opt_" ^ si glr_idx in
    let nt_name = `AST_name (sr',nt_id,[]) in
    let p = [(Some "_1",qn)] in
    let e = 
      `AST_apply 
      (sr',
        (
         `AST_typed_case (sr',1,typ),
         `AST_name (sr',"_1",[])
        )
      )
    in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;

    let e = `AST_typed_case (sr',0,typ) in
    let p = [] in
    let glr_idx = seq() in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;
    `AST_name (sr',nt_id,[])
  in

  let new_seq (qs:qualified_name_t list) : qualified_name_t =
    let n = length qs in
    let typ = `TYP_tuple (map (fun qn -> `TYP_glr_attr_type qn) qs) in
    let glr_idx = seq() in
    let nt_id = "_seq_" ^ si glr_idx in
    let nt_name = `AST_name (sr',nt_id,[]) in
    let p = combine (map (fun n -> Some ("_"^ si n)) (nlist n)) qs in
    let e = 
      `AST_tuple 
      (
        sr', 
        map 
        (fun n -> `AST_name (sr',"_"^si n,[]))
        (nlist n)
      ) 
    in
    new_glrs := (p,e,glr_idx,typ,nt_id) :: !new_glrs;
    `AST_name (sr',nt_id,[])
  in

  let new_alt t = failwith "can't handle glr alt yet" in
  let rec unravel t: qualified_name_t = match t with
  | `GLR_name qn -> qn
  | `GLR_ast t -> new_ast (unravel t)
  | `GLR_plus t -> new_plus (unravel t)
  | `GLR_opt t -> new_opt (unravel t)
  | `GLR_seq ts -> new_seq (map unravel ts)
  | `GLR_alt ts -> new_alt (map unravel ts)
  in
  let p = map (fun (name,t) -> name,unravel t) p in
  let dcls = inner_handle_glr seq rex sr' p e glr_idx t nt_id in
  dcls @
  concat 
  (
    map
    (fun (p,e,glr_idx,t,nt_id) ->
      inner_handle_glr seq rex sr' p e glr_idx t nt_id 
    )
    !new_glrs
  )


and inner_handle_glr seq rex sr' p e glr_idx t nt_id =
   (* we turn the expression into a call to a function
    so any lambdas lifted out are nested in the
    function, and rely on the call to bind to the
    arguments, and we mark the function noinline,
    to stop it being inlined into the C wrapper code
  *)

  let fun_idx = seq() in
  let fun_id = nt_id ^ "_" ^ si fun_idx in
  let fun_ref = `AST_index (sr',fun_id,fun_idx) in
  let params : (string * typecode_t) list = 
    let rec aux params prod = match prod with
    | [] -> rev params
    | (None,_):: tail -> aux params tail
    | (Some n,qn) :: tail ->
      let typ = `TYP_glr_attr_type qn in
      aux ((n,typ)::params) tail
    in aux [] p
  in
  let lams,x = rex e in
  let d: asm_t = Dcl
    (
      sr',
      fun_id, Some fun_idx,
      `Private,
      [],
      `DCL_function 
      (
        (params,None),
        `TYP_none,
        [`NoInline],
        (Exe (sr',`EXE_fun_return x) :: lams)
       )
    ) 
  in
  let args = map (fun (n,_) -> `AST_name (sr',n,[])) params in
  let invoke = `AST_apply(sr',(fun_ref,`AST_tuple (sr',args))) in 
  let dcl =   `DCL_glr (t,(p,invoke)) in
  let dcl =   Dcl (sr',nt_id,Some glr_idx,`Public,[],dcl) in
  [d; dcl]

let typeofargs a = 
      match map snd a with
      | [x] -> x
      | lst -> `TYP_tuple lst


let desugar_program syms name sts =
  let sts = match sts with
    | [] -> [`AST_nop (generated, "empty module")]
    | _ -> sts
  in
  let sr = 
    rsrange 
      (src_of_stmt (hd sts)) 
      (src_of_stmt (list_last sts))
  in
  let sts = expand_macros name 5000 sts in
  (*
  let sts = `AST_body(sr,"_rqs__top",[],"",[]) :: sts in
  *)
  rst syms name `Public [] (`AST_untyped_module (sr,name,[],sts))

@h = tangler("src/flxd.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_print
open Flx_types
open Flx_getopt
open Flx_flxopt
open Flx_version
open Flx_mtypes1
open Flx_mtypes2

let print_help () = print_options(); exit(0)
;;

let reverse_return_parity = ref false
;;
try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree = 
    Flx_desugar.include_file syms input_file_name false
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  print_endline "//----------------------------";
  print_endline "//IMPLEMENTATION DESUGARED:";

  let include_dirs =  (* (Filename.dirname input_file_name) :: *) compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program syms module_name parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "//----------------------------";

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

