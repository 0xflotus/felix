@head(1,"Desugaring")
Two routines: one to build interfaces
from modules, and one to lift lambdas
and also blocks.
@h = tangler("src/flx_desugar.mli")
@select(h)
open Flx_ast
open Flx_types
val desugar_program: 
  string list ->
  string ->
  int ref ->
  statement_t list -> 
  asm_t list

val build_interface:
  statement_t list ->
  statement_t list

@h = tangler("src/flx_desugar.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_typing2
open List
open Flx_pat
open Flx_srcref
open Flx_exceptions
open Flx_macro
let this_version = !Flx_version.version_data 

let generated = ("Generated by desugaring",0,0,0,0)

let catmap f l = concat (map f l)

exception Found_file of string

let find_file_in_path incdirs f =
  try
    List.iter
    (fun d -> 
      let f = Filename.concat d f in 
      if Sys.file_exists f 
      then raise (Found_file f)
    )
    incdirs
    ;
    ""
  with Found_file s -> s 

let find_file incdirs f =
  if String.length f = 0
  then failwith "Empty include file name"
  ;
  if f.[0] = '/' then f 
  else find_file_in_path incdirs f

let filetime f =
  if f = "" then 0.0 
  else 
    try (Unix.stat f).Unix.st_mtime 
    with | _ -> 0.0

let arglist x = 
  match x with
  | `AST_tuple (_,ts) -> ts
  | _ -> [x]

(* split lambdas out. Each lambda is replaced by a
   reference to a synthesised name in the original
   statement, which is prefixed by the definition.

   Blocks are replaced by a procedure definition
   and a call.

   The match statement requires all case bodies
   be replaced by calls as well.

   Actual lambdas in expressions are replaced
   by a reference and function or procedure definition.

   Attempt handler bodies are requires all handlers
   to be replaced by a call as well.
*)

(* convert an expression into a list of assembly instructions,
   plus an expression: basically, this means removing lambdas
*)

(*
  ARGGG! rex guarrantees to lift lambdas out of expressions,
  but the lifted lambda declarations also have bodies
  which might contain expression containing lambdas,
  so we have to apply rsts to these bodies..
*)

let rec rex include_dirs seq (e:expr_t) : asm_t list * expr_t = 
  let rexx = rex include_dirs in
  let rex e = rex include_dirs seq e in
  let rst x = rst include_dirs seq x in
  let rsts sts = catmap rst sts in
  let sr = src_of_expr e in
  match e with

  (* these cases should use the source reference for the error *)
  | `AST_match_ctor _ 
    -> clierr sr "[rex] not expecting union component constructor matcher"
  | `AST_match_case _ 
    -> clierr sr "[rex] not expecting anonymous union component constructor matcher"
  | `AST_ctor_arg _ 
    -> clierr sr "[rex] not expecting union component destructor"
  | `AST_case_arg _ 
    -> clierr sr "[rex] not expecting anonymous union component destructor"
  | `AST_bound_module _
    -> clierr sr "[rex] not expecting `AST_bound_module"
  | `AST_void _ 
    -> clierr sr "[rex] not expecting `AST_void"
  | `AST_arrow _ 
    -> clierr sr "[rex] not expecting `AST_arrow"
  | `AST_as (sr,(e1,name)) 
    -> clierr sr "[rex] Can't use 'as' in expression" 

  | `AST_product (sr,xs) -> clierr sr "[rex] Unexpected product"

  | `AST_sum (sr,xs) -> clierr sr "[rex] Unexpected sum"

  | `AST_noexpand (_,e) -> rex e
  | `AST_name (sr,name,_) -> [],e

  | `AST_deref (sr,e) ->
    let l1,x1 = rex e in
    l1, `AST_deref (sr,x1)

  | `AST_ref (sr,e) ->
    let l1,x1 = rex e in
    l1, `AST_ref (sr,x1)

  | `AST_suffix _ -> [],e  (* ?? *)

  | `AST_lookup (sr,(e,id,ts)) ->
    let l1,x1 = rex e in
    l1, `AST_lookup (sr,(x1,id,ts))

  | `AST_case_tag _ -> [],e
  | `AST_typed_case _ -> [],e
  | `AST_literal _ -> [],e

  | `AST_cond (sr,(e,b1,b2)) ->
     rex 
     (
       `AST_match 
       (
         sr,
         (
           e,
           [
             `PAT_const_ctor (sr,`AST_case_tag (sr,1)),b2;
             `PAT_const_ctor (sr,`AST_case_tag (sr,2)),b1
           ]
         )
       )
     )
     
  (* we have to lift lambdas out of typeof exprs,
     even though they're never called,
     so the typing works correctly
  *)
  | `AST_typeof (sr,e') ->
    let l1,x1 = rex e' in
    l1, `AST_typeof (sr,(x1))

  | `AST_get_n (sr,(n,e')) ->
    let l1,x1 = rex e' in
    l1, `AST_get_n (sr,(n,x1))

  | `AST_apply (sr,(fn,arg)) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, `AST_apply (sr,(x1,x2))

  | `AST_method_apply (sr,(fn,arg)) -> 
    let l2,x2 = rex arg in
    l2, `AST_method_apply (sr,(fn,x2))
    
  | `AST_tuple (sr,t) -> 
    let lss,xs = split (map rex t) in
    concat lss,`AST_tuple (sr,xs)

  | `AST_lambda (sr,(params,res,sts)) -> 
    let n = seq() in
    let name = "_lambda_" ^ string_of_int n in
    let argtyp = type_of_argtypes (map snd params) in
    [match res with
    | _ -> Dcl (sr,name,[],`DCL_function (params, res, rsts sts))
    ],
    `AST_suffix 
    (
      generated,
      (
        `AST_name (generated,name,[]), 
        type_of_argtypes (map snd params)
      )
    )

  | `AST_dot (sr,(obj,comp)) -> 
    let l1,x1 = rex obj in 
    l1 , `AST_dot (sr,(x1,comp))

  | `AST_coercion (sr,(e,t)) ->
    let l1,x1 = rex e in 
    l1, `AST_coercion (sr,(x1,t))

  | `AST_regmatch (sr,(e,cls')) ->
    let dcls = ref [] in
    let cls = ref [] in
    iter 
    (fun (re,e) -> 
      let l,x = rex e in
      dcls := l @ !dcls;
      cls := (re,x) :: !cls
    )
    cls'
    ;

    let n = seq() in
    let fname = "regmatch" ^ string_of_int n in
    let l,x = rex e in
    let exes = [Exe(sr,`EXE_regmatch (x,!cls))] in
    let rfun = Dcl(sr,fname,[],`DCL_function([],`TYP_none,exes)) in
    rfun :: l @ !dcls,
    `AST_apply(sr,(`AST_name(sr,fname,[]),`AST_tuple(sr,[])))
   
  | `AST_reglex (sr,(e,cls')) ->
    let dcls = ref [] in
    let cls = ref [] in
    iter 
    (fun (re,e) -> 
      let l,x = rex e in
      dcls := l @ !dcls;
      cls := (re,x) :: !cls
    )
    cls'
    ;

    let n = seq() in
    let fname = "reglex" ^ string_of_int n in
    let l,x = rex e in
    let exes = [Exe(sr,`EXE_reglex (x,!cls))] in
    let rfun = Dcl(sr,fname,[],`DCL_function([],`TYP_none,exes)) in
    rfun :: l @ !dcls,
    `AST_apply(sr,(`AST_name(sr,fname,[]),`AST_tuple(sr,[])))
     
  | `AST_letin (sr,(pat,e1,e2)) ->
    rex (`AST_match (sr,(e1,[pat,e2])))
    
  (* MATCH HANDLING NEEDS TO BE REWORKED, THE SWITCHING SHOULD BE
     DELAYED TO ALLOW TYPE BASED OPTIMISATION WHERE THE TOP
     LEVEL MATCH ON A UNION CAN USE A SWITCH.

     ALSO, TO ALLOW MULTIPLE PATTERNS WITH ONE HANDLER,
     GIVE THE HANDLER PARAMETERS, AND HAVE THE TOP LEVEL
     MATCH HANDLERS FOR EACH CASE FOR THAT CODE CALL IT:

     eg:
     
     match x with | A x | B x => x endmatch
  *)
  
  | `AST_match (sr,(e,pss)) ->
    if length pss = 0 then clierr sr "Empty Pattern";

    (* step 1: evaluate e *)
    let d,x = rex e in
    let match_function_index = seq() in

    let match_var_name = "_match_var_"^string_of_int match_function_index in
    let match_function_id = "_match__fun_"^ string_of_int match_function_index in
    let match_function = `AST_name (sr,match_function_id,[]) in
    let match_seq = ref (seq()) in

    let expr_src = src_of_expr e in

    (* WOE. The expr may contain a lambda, which stuffs up
       bind_expression which is called by bind_type ..
    *)
    let evl = 
      [
        Dcl (expr_src,match_var_name,[],`DCL_val (`TYP_typeof x));
        Exe (expr_src,`EXE_init (match_var_name,x))
      ]
    in
    let pats,_ = split pss in
    Flx_pat.validate_patterns pats
    ;
    let ematch_seq = seq() in
    (*
    let end_match_label = "_end_match_" ^ string_of_int ematch_seq in
    *)
    let matches = ref [Exe (generated,`EXE_comment "begin match")] in
    let match_caseno = ref 1 in
    iter
    (fun (pat,e) -> 
      let n1 = !match_seq in
      let n2 = seq() in
      let patsrc = src_of_pat pat in
      let expr_src = src_of_expr e in
      let match_checker_id = "_match_checker_" ^ string_of_int n1 in
      let match_handler_id = "_match_handler_" ^ string_of_int n1 in
      let match_checker = `AST_name (patsrc,match_checker_id,[]) in
      let match_handler = `AST_name (expr_src,match_handler_id,[]) in

      let sts,result_expr = rex e in
      let body = 
        sts @ 
        [Exe (expr_src,`EXE_fun_return (result_expr))] 
      in
      matches := !matches @
      [
        Dcl (patsrc,match_checker_id,[],`DCL_match_check (pat,match_var_name));
        Dcl 
        (
          expr_src,
          match_handler_id,[],
          `DCL_match_handler 
          (
            pat,
            match_var_name,
            body
          )
        )
      ]
      @
      [
      Exe (patsrc,`EXE_comment ("match case " ^ string_of_int !match_caseno));
      Exe (patsrc,`EXE_label ("_match_label_" ^ string_of_int n1));
      Exe 
      (
        patsrc,
        `EXE_ifnotgoto 
        (
          `AST_apply 
          (
            patsrc,
            (
              match_checker,
              `AST_tuple (patsrc,[])
            )
          ), 
          "_match_label_" ^ string_of_int n2
        )
      )
      ;
      Exe 
      (
        patsrc,
        `EXE_fun_return 
        (
          `AST_apply 
          (
            patsrc,
            (
              match_handler, 
              `AST_tuple (patsrc,[])
            )
          )
        )
      )
      (*
      ;
      Exe (patsrc,`EXE_goto end_match_label)
      *)
      ]
      ;
      incr match_caseno;
      match_seq := n2
    )
    pss
    ;
    let failure_label = "_match_label_" ^ string_of_int !match_seq in

    let match_function_body =
    d
    @
    evl
    @
    !matches
    @
    [
      Exe (sr,`EXE_comment "match failure");
      Exe (sr,`EXE_label failure_label);
      Exe (sr,`EXE_noreturn_code "      assert((\"match failure\",false));\n");
      (*
      Exe (sr,`EXE_comment "match exit");
      Exe (sr,`EXE_label end_match_label)
      *)
    ]
    in
    [
      Dcl 
      (
        sr,
        match_function_id,[],
        `DCL_function 
        (
          [],
          `TYP_none,
          match_function_body
        )
      )
    ]
    ,
    `AST_apply 
    (
      sr,
      (
        match_function, 
        `AST_tuple (sr,[])
      )
    )


(* remove blocks *)
and rst include_dirs seq st : asm_t list = 
  let rexx = rex include_dirs in
  let rex x = rex include_dirs seq x in
  let rst x = rst include_dirs seq x in
  let rsts sts = catmap rst sts in

  match st with
  | `AST_include (sr,inspec) ->
    let basename = try Filename.chop_extension inspec with _ -> inspec in
    let tf = find_file_in_path include_dirs (basename ^ ".flx") in
    let pf = find_file_in_path include_dirs (basename ^ ".par") in
    let tf_mt = filetime tf in
    let pf_mt = filetime pf in
    let saveit sts =
      let pf = 
        if pf = "" then 
          (try Filename.chop_extension tf with | _ -> tf) ^ ".par"
        else pf
      in
        try (* to write Marshalled parse tree out *)
          let x = open_out pf in
          Marshal.to_channel x (this_version,sts) [];
          close_out x
        with _ -> () (* can't write, don't worry *)
    in
    let parseit() =
      let sts = 
        Flx_parse_ctrl.parse_file 
          tf 
          (Filename.dirname tf)
          include_dirs 
      in
        let local_prefix = Filename.basename basename in
        expand_macros local_prefix 5000 sts
    in
    let sts =
      (* -- no file ----------------------------------------- *)
      if tf_mt = 0.0 && pf_mt = 0.0 then 
        failwith 
        (
          "No .flx or .par file for name " ^ 
          basename ^
          " found in path:\n" ^ 
          String.concat "; " include_dirs
        )

      (* -- parsed file is newer or text doesn't exist ------- *)
      else if tf_mt < pf_mt then 
        let x = open_in pf in
        let (that_version,tree) = Marshal.from_channel x in
        close_in x;
        if this_version = that_version
        then
          tree
        else 
          let sts = parseit() in
          saveit sts;
          sts

      (* -- text file is newer or parsed file doesn't exist -- *)
      else 
        let sts = parseit() in
        saveit sts;
        sts
    in
      rsts sts

  | `AST_regdef (sr,name,regexp) -> [Dcl (sr,name,[],`DCL_regdef regexp)]
  | `AST_label (sr,s) -> [Exe (sr,`EXE_label s)]
  | `AST_proc_return sr -> [Exe (sr,`EXE_proc_return)]
  | `AST_goto (sr,s) -> [Exe (sr,`EXE_goto s)]
  | `AST_open (sr,name) -> [Dir (sr,DIR_open name)]
  | `AST_use (sr,n,qn) -> [Dir (sr,DIR_use (n,qn))]

  | `AST_comment s -> [Exe (generated,`EXE_comment s)]

  (* objects *)
  | `AST_export (sr,name,cpp_name) ->
    [Iface (sr,`IFACE_export (name,cpp_name))]

  | `AST_var_decl (sr,name,vs,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,vs,`DCL_var t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,vs,`DCL_var (`TYP_typeof x)); Exe (sr,`EXE_init (name,x))]
    | Some t,None -> [Dcl (sr,name,vs,`DCL_var t)]
    | None,None -> failwith "Expected variable to have type or initialiser"
    end

  | `AST_val_decl (sr,name,vs,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,vs,`DCL_val t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,vs,`DCL_val (`TYP_typeof x)); Exe (sr,`EXE_init (name,x))]
    | Some t, None -> [Dcl (sr,name,vs,`DCL_val t)] (* allowed in interfaces *)
    | None,None -> failwith "Expected value to have type or initialiser"
    end

  | `AST_const_decl (sr,name, vs,typ, s) -> [Dcl (sr,name,vs,`DCL_const (typ,s))]

  (* types *)
  | `AST_abs_decl (sr,name,vs,str) -> [Dcl (sr,name,vs,`DCL_abs (str))]
  | `AST_union (sr,name, vs, components) -> [Dcl (sr,name,vs,`DCL_union (components))]
  | `AST_struct (sr,name, vs, components) ->  [Dcl (sr,name,vs,`DCL_struct (components))]
  | `AST_type_alias (sr,name,vs,typ) -> [Dcl (sr,name,vs,`DCL_type_alias (typ))]
  | `AST_type (sr,name,vs) -> [Dcl (sr,name,vs,`DCL_type)]

  (* functions *)
  | `AST_function (sr,name, vs, params, res, sts) -> 
    [Dcl (sr,name,vs,`DCL_function (params, res, rsts sts))]
    
  | `AST_function_decl (sr,name,vs,typ) ->
    [Dcl (sr,name,vs,`DCL_if_fun typ)]

  | `AST_fun_decl (sr,name,vs,args,result,code) -> 
    [Dcl (sr,name,vs,`DCL_fun (args,result,code))]

  (* misc *)
  | `AST_interface (sr,name,vs,sts) ->
    [
      Dcl (sr,name,vs,`DCL_interface (rsts sts))
    ]

  | `AST_untyped_module (sr,name, vs, sts) -> 
    [
      Dcl (sr,name,vs,`DCL_module (rsts sts))
    ]
    @
      (* HACK !!!! *)
    if vs = [] then
    [
      Exe 
      (
        sr,
        `EXE_call 
        (
          `AST_suffix
          (
            sr,
            (
              `AST_lookup
              (
                sr,
                (
                  `AST_name (sr,name,[]),
                  "_init_",
                  []
                )
              ),
              `TYP_tuple []
            )
          ),
          `AST_tuple (generated,[])
        )
      )
    ] else []

  | `AST_typed_module (sr,name, vs, typ, sts) -> 
    let mname = name ^ "_impl_" in
    let mexpr = `AST_coercion 
    (
      sr,
      (
        `AST_name (sr,mname,[]), 
        typ
      )
    ) 
    in
    [
      Dcl (sr,mname,vs,`DCL_module (rsts sts));
      Dcl (sr,name,vs,`DCL_module_binding mexpr)
    ] 
    @
    (if vs = [] then [
      Exe 
      (
        sr,
        `EXE_call 
        (
          `AST_suffix 
          (sr,
            (
              `AST_lookup
              (
                sr,
                (
                  `AST_name (sr,name,[]),
                  "_init_",
                  []
                )
              ),
              `TYP_tuple []
            )
          ),
          `AST_tuple (generated,[])
        )
      )
    ] else [])

  | `AST_typed_functor (sr,name,vs,ps,typ,sts) ->
    [
      Dcl (sr,name,vs,`DCL_typed_functor (ps,typ,rsts sts));
    ]

  | `AST_untyped_functor (sr,name,vs,ps,sts) ->
    [
      Dcl (sr,name,vs,`DCL_untyped_functor (ps,rsts sts));
    ]

  | `AST_module_binding (sr,name,vs,mexpr) ->
    [Dcl (sr,name,vs,`DCL_module_binding mexpr)]


  | `AST_header (sr,s) -> 
    let n = seq() in 
    let name = "_header_" ^ string_of_int n in 
    [Dcl (sr,name,[],`DCL_header s)]

  | `AST_body (sr,s) -> 
    let n = seq() in 
    let name = "_body_" ^ string_of_int n in 
    [Dcl (sr,name,[],`DCL_body s)]

  (* executable *)
  | `AST_fun_return (sr,e) ->
    let d,x = rex e in d @ [Exe (sr,`EXE_fun_return x)]
  
  | `AST_nop _ -> []

  | `AST_call (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_call (x1,x2))]

  | `AST_jump (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_call (x1,x2))]

  | `AST_loop (sr,proc, arg) ->
    let d2,x2 = rex arg in
    d2 @ [Exe (sr,`EXE_loop (proc,x2))]

  | `AST_ifgoto (sr,e,lab)->
    let next = "_skip_" ^ string_of_int (seq()) in
    let d,x = rex e in
    d @ 
    [
      (* we have to do this, in case the clients
        goto is non-local
      *)
      Exe (sr,`EXE_ifnotgoto (x,next));
      Exe (sr,`EXE_goto lab);
      Exe (sr,`EXE_label next)
    ]

  (* client can't write this one *)
  | `AST_ifnotgoto (sr,e,lab)->
    let d,x = rex e in
    d @ [Exe (sr,`EXE_ifnotgoto (x,lab))]

   
  | `AST_read (sr,name) ->  [Exe (sr,`EXE_read name)]
  | `AST_code (sr,s) -> [Exe (sr,`EXE_code s)]
  | `AST_noreturn_code (sr,s) -> [Exe (sr,`EXE_noreturn_code s)]

  | st ->
    let sr = src_of_stmt st in
    clierr sr 
    (
      "[desugar] Unexpected statment\n" ^
      string_of_statement 0 st
    )

let typeofargs a = 
      match map snd a with
      | [x] -> x
      | lst -> `TYP_tuple lst

let rec build_if d = match d with
  | `AST_function  (sr,name,vs, ps,ret,_) -> 
    [
      `AST_function_decl 
      (
        sr,
        name,
        vs,
        `TYP_function 
        (
          typeofargs ps,
          ret
        )
      )
    ]

  | `AST_typed_module (sr,name,vs,typ,sts) -> 
    [`AST_typed_module (sr,name,vs,typ,build_interface sts)]
  | `AST_untyped_module (sr,name,vs,sts) -> 
    [`AST_untyped_module (sr,name,vs,build_interface sts)]

  | `AST_var_decl _
  | `AST_val_decl _

  | `AST_type_alias _
  | `AST_union _
  | `AST_struct _
  | `AST_const_decl _
  | `AST_fun_decl _
  | `AST_proc_decl _ 
  | `AST_abs_decl _ 
    -> [d]
  | _ -> [] 

and build_interface m =
 concat (map build_if m)
 
let desugar_program include_dirs name counter sts =
  let sr = 
    rsrange 
      (src_of_stmt (hd sts)) 
      (src_of_stmt (list_last sts))
  in
  let seq () = 
    let n = !counter in 
    incr counter; 
    n 
  in
  let sts = expand_macros name 5000 sts in
  rst include_dirs seq (`AST_untyped_module (sr,name,[],sts))

@h = tangler("src/flxd.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_print
open Flx_types
open Flx_getopt
open Flx_flxopt
open Flx_version

let print_help () = print_options(); exit(0)
;;

let reverse_return_parity = ref false
;;
try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  (* IF THERE WAS NO INTERFACE FILE, GENERATE ONE *)
  if not have_interface 
  then begin
    print_endline "//No interface file found: generating one";
    let h = open_out iface_file_name in
    let iface = build_interface parse_tree in
    List.iter 
    (
      fun x->
        output_string h
        (
          (string_of_statement 0 x)^"\n"
        )
    ) 
    iface;
    close_out h
  end
  ;

  print_endline "//----------------------------";
  print_endline "//IMPLEMENTATION DESUGARED:";

  let counter = ref 1 in
  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program include_dirs module_name counter parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "//----------------------------";

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

