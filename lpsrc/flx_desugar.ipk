@head(1,"Desugaring")
Two routines: one to build interfaces
from modules, and one to lift lambdas
and blocks.
@h = tangler("src/flx_desugar.mli")
@select(h)
open Flx_types
val desugar_program: 
  string ->
  int ref ->
  statement_t list -> 
  asm_t list

val build_interface:
  statement_t list ->
  statement_t list

@h = tangler("src/flx_desugar.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_pat
open Flx_srcref

let generated = ("Generated by desugaring",0,0,0,0)

let catmap f l = concat (map f l)

(* split lambdas out. Each lambda is replaced by a
   reference to a synthesised name in the original
   statement, which is prefixed by the definition.

   Blocks are replaced by a procedure definition
   and a call.

   The match statement requires all case bodies
   be replaced by calls as well.

   Actual lambdas in expressions are replaced
   by a reference and function or procedure definition.

   Attempt handler bodies are requires all handlers
   to be replaced by a call as well.
*)

(* convert a single statement into either:
   (1) an empty list and a single statement
   (2) a block procedure and a call to it

   WARNING: this is a HACK: it relies
   on the fact that (rst (`AST_block ss)) 
   is a list of a single procedure (the block),
   followed by a called to it (where ss consists
   of more than one statement)
*)

(* convert an expression into a list of assembly instructions,
   plus an expression: basically, this means removing lambdas
*)
let rec rex seq (e:expr_t) : asm_t list * expr_t = 
  let rex e = rex seq e in
  let rsts sts = catmap (rst seq) sts in
  match e with

  (* these cases should use the source reference for the error *)
  | `AST_match_ctor _ 
    -> failwith "[rex] not expecting union component constructor matcher"
  | `AST_ctor_arg _ 
    -> failwith "[rex] not expecting union component destructor"
  | `AST_index _ 
    -> failwith "[rex] not expecting `AST_index "
  | `AST_bound_module _
    -> failwith "[rex] not expecting `AST_bound_module"

  | `AST_void _ 
    -> failwith "[rex] not expecting `AST_void"

  | `AST_arrow _ 
    -> failwith "[rex] not expecting `AST_arrow"

  | `AST_product (sr,xs) ->
    let mul = `AST_name (sr,"mul") in
    let x = 
      List.fold_left
      (fun factor atom ->
        `AST_apply 
        (
          sr, 
          (
            mul, 
            `AST_tuple (sr,[factor; atom])
          )
        )
      )
      (List.hd xs)
      (List.tl xs)
    in rex x

  | `AST_sum (sr,xs) ->
    let mul = `AST_name (sr,"add") in
    let x = 
      List.fold_left
      (fun factor atom ->
        `AST_apply 
        (
          sr, 
          (
            mul, 
            `AST_tuple (sr,[factor; atom])
          )
        )
      )
      (List.hd xs)
      (List.tl xs)
    in rex x

  | `AST_deref _ -> [],e
  | `AST_root _ -> [],e
  | `AST_name _ -> [],e
  | `AST_case_tag _ -> [],e
  | `AST_typed_case _ -> [],e
  | `AST_suffix _ -> [],e  (* ?? *)
  | `AST_lookup _ -> [],e  (* ?? *)
  | `AST_ref _ -> [],e
  | `AST_literal _ -> [],e


  | `AST_get_n (sr,(n,e')) ->
    let l1,x1 = rex e' in
    l1, `AST_get_n (sr,(n,x1))

  | `AST_apply (sr,(fn,arg)) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, `AST_apply (sr,(x1,x2))

  | `AST_method_apply (sr,(fn,arg)) -> 
    let l2,x2 = rex arg in
    l2, `AST_method_apply (sr,(fn,x2))
    
  | `AST_tuple (sr,t) -> 
    let lss,xs = split (map rex t) in
    concat lss,`AST_tuple (sr,xs)

  | `AST_lambda (sr,(params,res,sts)) -> 
    let n = seq() in
    let name = "_lambda_" ^ string_of_int n in
    let argtyp = type_of_argtypes (map snd params) in
    [match res with
    | `AST_void _ -> Dcl (sr,name,`DCL_procedure (params, rsts sts))
    | _ -> Dcl (sr,name,`DCL_function (params, res, rsts sts))
    ],
    `AST_suffix 
    (
      generated,
      (
        `AST_name (generated,name), 
        type_of_argtypes (map snd params)
      )
    )

  | `AST_lazy (sr,e) ->
    let n = seq() in
    let name = "_lazy_" ^ string_of_int n in
    [
      Dcl (sr,name,`DCL_lazy e)
    ],
    `AST_suffix 
    (
      generated,
      (
        `AST_name (generated,name),
        `TYP_tuple []
      )
    )

  | `AST_dot (sr,(obj,comp)) -> 
    let l1,x1 = rex obj in 
    l1 , `AST_dot (sr,(x1,comp))

  | `AST_coercion (sr,(e,t)) ->
    let l1,x1 = rex e in 
    l1, `AST_coercion (sr,(x1,t))


and split_st seq sr s : asm_t list * asm_t =
  match rst seq s with
  | [] -> [], Exe (generated,`EXE_nop "")
  | [x] -> [],x
  | ss ->
    let name = "_block_" ^ string_of_int (seq()) in
    [
      Dcl (sr,name,`DCL_procedure ([], ss))
    ]
    ,
    Exe (sr,`EXE_call (
      `AST_suffix
      (
        generated,
        (
          `AST_name (generated,name),
          `TYP_tuple []
        )
      ), 
      `AST_tuple (generated,[])
    ))

    
(* remove blocks *)

and rst seq st : asm_t list = 
  let rst' st = rst seq st in
  let rex x = rex seq x in
  let rsts' sts = catmap rst' sts in
  
  match st with
  | `AST_label (sr,s) -> [Exe (sr,`EXE_label s)]
  | `AST_goto (sr,s) -> [Exe (sr,`EXE_goto s)]
  | `AST_open (sr,name) -> [Dir (sr,DIR_open name)]
  
  | `AST_comment s -> [Exe (generated,`EXE_comment s)]

  (* objects *)
  | `AST_export (sr,name,cpp_name) ->
    [Iface (sr,`IFACE_export (name,cpp_name))]

  | `AST_var_decl (sr,name,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,`DCL_var t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,`DCL_var_typeof x); Exe (sr,`EXE_init (name,x))]
    | Some t,None -> [Dcl (sr,name,`DCL_var t)]
    | None,None -> failwith "Expected variable to have type or initialiser"
    end

  | `AST_val_decl (sr,name,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,`DCL_val t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,`DCL_val_typeof x); Exe (sr,`EXE_init (name,x))]
    | Some t, None -> [Dcl (sr,name,`DCL_val t)] (* allowed in interfaces *)
    | None,None -> failwith "Expected value to have type or initialiser"
    end

  | `AST_const_decl (sr,name, typ, s) -> [Dcl (sr,name,`DCL_const (typ,s))]

  (* types *)
  | `AST_abs_decl (sr,name,str) -> [Dcl (sr,name,`DCL_abs str)]
  | `AST_union (sr,name, components) -> [Dcl (sr,name,`DCL_union components)]
  | `AST_struct (sr,name, components) ->  [Dcl (sr,name,`DCL_struct components)]
  | `AST_type_alias (sr,name,typ) -> [Dcl (sr,name,`DCL_type_alias typ)]
  | `AST_type (sr,name) -> [Dcl (sr,name,`DCL_type)]

  (* functions *)
  | `AST_function (sr,name, params, res, sts) -> 
    [Dcl (sr,name,`DCL_function (params, res, rsts' sts))]
    
  | `AST_procedure (sr,name, params, sts) -> 
    let rst' st = rst seq st in
    let rsts' sts = catmap rst' sts in
    [Dcl (sr,name,`DCL_procedure (params, rsts' sts))]
    
  | `AST_procedure_decl (sr,name,typ) ->
    [Dcl (sr,name,`DCL_if_proc (typ))]

  | `AST_function_decl (sr,name,typ) ->
    [Dcl (sr,name,`DCL_if_fun typ)]

  | `AST_block (sr,sts) ->
    begin match sts with
    | [] -> []
    | [x] -> rst' x 
    | _ ->
    let name = "_block_" ^ string_of_int (seq()) in
    [
      Dcl (sr,name,`DCL_procedure ([], rsts' sts)); 
      Exe (sr,`EXE_call (
        `AST_suffix 
        (
          generated,
          (
            `AST_name (generated,name),
            `TYP_tuple []
          )
        ),
        `AST_tuple (generated,[])
      ))
    ]
    end

  | `AST_except_handler (sr,name,params,sts) ->  
    failwith "Unexpected exception handler"
    
  | `AST_fun_decl (sr,name,args,result,code) -> 
    [Dcl (sr,name,`DCL_fun (args,result,code))]
  | `AST_proc_decl (sr,name,args,code) -> 
    [Dcl (sr,name,`DCL_proc(args,code))]

  (* misc *)
  | `AST_interface (sr,name,sts) ->
    [
      Dcl (sr,name,`DCL_interface (rsts' sts))
    ]

  | `AST_untyped_module (sr,name, sts) -> 
    [
      Dcl (sr,name,`DCL_module (rsts' sts));
      Exe 
      (
        sr,
        `EXE_call 
        (
          `AST_suffix
          (
            sr,
            (
              `AST_lookup
              (
                sr,
                (
                  `AST_name (sr,name),
                  "_init_"
                )
              ),
              `TYP_tuple []
            )
          ),
          `AST_tuple (generated,[])
        )
      )
    ]
  | `AST_typed_module (sr,name, typ, sts) -> 
    let mname = name ^ "_impl_" in
    let mexpr = `AST_coercion 
    (
      sr,
      (
        `AST_name (sr,mname), 
        typ
      )
    ) 
    in
    [
      Dcl (sr,mname,`DCL_module (rsts' sts));
      Dcl (sr,name,`DCL_module_binding mexpr);
      Exe 
      (
        sr,
        `EXE_call 
        (
          `AST_suffix 
          (sr,
            (
              `AST_lookup
              (
                sr,
                (
                  `AST_name (sr,name),
                  "_init_"
                )
              ),
              `TYP_tuple []
            )
          ),
          `AST_tuple (generated,[])
        )
      )
    ]

  | `AST_typed_functor (sr,name,ps,typ,sts) ->
    [
      Dcl (sr,name,`DCL_typed_functor (ps,typ,rsts' sts));
    ]

  | `AST_untyped_functor (sr,name,ps,sts) ->
    [
      Dcl (sr,name,`DCL_untyped_functor (ps,rsts' sts));
    ]

  | `AST_module_binding (sr,name,mexpr) ->
    [Dcl (sr,name,`DCL_module_binding mexpr)]


  | `AST_header (sr,s) -> 
    let n = seq() in 
    let name = "_ header_" ^ string_of_int n in 
    [Dcl (sr,name,`DCL_header s)]

  (* executable *)
  | `AST_attempt (sr,(sra,attempt), (srh,handlers), (srf,finally)) -> 
    let name_of_handler x = match x with 
      | `AST_except_handler (sr',name,_,_) -> name
      | _ -> failwith ("System error, expected exception handler")
    in 
    let finally_seq = seq() in
    let finally_label = "_finally_label_" ^ string_of_int finally_seq in
    let rh h =
      match h with 
      | `AST_except_handler (sr',name,params,sts) -> 
        let sts' = sts @ [`AST_goto (srf,finally_label)] in
        Dcl (sr',name,`DCL_procedure (params, rsts' sts'))
      | _ -> failwith "Expected statement to be handler"
    in
    let handlers' = List.map rh handlers in
    let f_dfs,f_st = split_st seq srf (`AST_block (srf,finally)) in
    let handler_names = map name_of_handler handlers in
    let a_dfs,a_st = split_st seq  sra attempt in
      (* 
      Exe (`EXE_comment "attempt statement") :: 
      Exe (`EXE_comment "handlers") ::
      *)
      handlers' @ 
      (*
      [Exe (`EXE_comment "(definitions for attempt)")] @
      *)
      a_dfs @ 
      (*
      [Exe (`EXE_comment "(definitions for finally clause)")] @
      *)
      f_dfs @ 
      [
        (*
        Exe (`EXE_comment "the attempt");
        *)
        a_st;
        Exe (srf,`EXE_label finally_label);
        (*
        Exe (`EXE_comment "finally clause");
        *)
        f_st;
        (*
        Exe (`EXE_comment "end attempt statement")
        *)
      ]
    
  | `AST_raise (sr,id,e) -> 
    let name = `AST_name(sr,id) in
    [Exe (sr,`EXE_call(name,e))]

  | `AST_match (sr,e,pss) ->
    if List.length pss = 0 then failwith "Empty Pattern";

    (* step 1: evaluate e *)
    let d,x = rex e in
    let match_var_name = "_match_var_"^string_of_int (seq()) in
    let expr_src = src_of_expr e in
    let evl = 
      [
        Dcl (expr_src,match_var_name,`DCL_var_typeof(x));
        Exe (expr_src,`EXE_init (match_var_name,x))
      ]
    in
    let pats,_ = List.split pss in
    Flx_pat.validate_patterns pats
    ;
    let ematch_seq = seq() in
    let end_match_label = "_end_match_" ^ string_of_int ematch_seq in
    let matches = ref [Exe (generated,`EXE_comment "begin match")] in
    let match_caseno = ref 1 in
    let match_seq = ref (seq()) in
    List.iter
    (fun (pat,st) -> 
      let n1 = !match_seq in
      let n2 = seq() in
      let patsrc = src_of_pat pat in
      let stsrc = src_of_stmt st in
      let match_checker_id = "_match_checker_" ^ string_of_int n1 in
      let match_handler_id = "_match_handler_" ^ string_of_int n1 in
      let match_checker = `AST_name (patsrc,match_checker_id) in
      let match_handler = `AST_name (stsrc,match_handler_id) in
      matches := !matches @
      [
        Dcl (patsrc,match_checker_id,`DCL_match_check (pat,match_var_name));
        Dcl (stsrc,match_handler_id,`DCL_match_handler (pat,match_var_name,rst' st))
      ]
      @
      [
      Exe (patsrc,`EXE_comment ("match case " ^ string_of_int !match_caseno));
      Exe (patsrc,`EXE_label ("_match_label_" ^ string_of_int n1));
      Exe 
      (
        patsrc,
        `EXE_ifnotgoto 
        (
          `AST_apply 
          (
            patsrc,
            (match_checker,`AST_tuple (patsrc,[]))
          ), 
          "_match_label_" ^ string_of_int n2
        )
      )
      ;
      Exe 
      (
        patsrc,
        `EXE_call (match_handler, `AST_tuple (patsrc,[]))
      )
      ;
      Exe (patsrc,`EXE_goto end_match_label)
      ]
      ;
      incr match_caseno;
      match_seq := n2
    )
    pss
    ;
    let failure_label = "_match_label_" ^ string_of_int !match_seq in
    d 
    @ 
    evl
    @
    !matches
    @
    [
      Exe (sr,`EXE_comment "match failure");
      Exe (sr,`EXE_label failure_label);
      Exe (sr,`EXE_code "      assert((\"match failure\",false));\n");
      Exe (sr,`EXE_comment "match exit");
      Exe (sr,`EXE_label end_match_label)
    ]

  | `AST_return (sr,e) ->
    let d,x = rex e in d @ [Exe (sr,`EXE_return x)]
  
  | `AST_nop _ -> []
  | `AST_call (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_call (x1,x2))]

  | `AST_if (sr,ifs, (esr,els)) -> 
    let ubc (sr,(e,s)) : asm_t list * (range_srcref * (expr_t * asm_t)) = 
      match split_st seq sr s 
      with ss,s' -> 
        let d,x = rex e in 
        d @ ss,(sr,(x,s')) 
    in
    let ss,ifs' = split (map ubc ifs) 
    and s',els' = split_st seq esr els in
    let endif_label = "_endif_" ^ string_of_int (seq()) in
    let ifcase (sr,(e,s)) = 
      let next_label = "_next_" ^ string_of_int (seq()) in
      [
        (*
        Exe (`EXE_comment "conditional case");
        *)
        Exe (sr,`EXE_ifnotgoto (e,next_label));
        s
        ;
        Exe (sr,`EXE_goto endif_label);
        Exe (sr,`EXE_label next_label);
      ] 
    in
    let ifs'' = catmap ifcase ifs' in
    (* 
    Exe (`EXE_comment "conditional chain") ::
    Exe (`EXE_comment "(definitions for conditional chain)") ::
    *)
    concat (ss @ [s']) @ 
    ifs'' @ 
    [ 
      (*
      Exe (`EXE_comment "else clause");
      *)
      els'; 
      Exe (esr,`EXE_label endif_label);
      (*
      Exe (`EXE_comment "endif")
      *)
    ]

  | `AST_while (sr,e,s) ->  
    let label1 = "_while_" ^ string_of_int (seq()) in
    let label2 = "_end_while_" ^ string_of_int (seq()) in
    let dfs,s' = 
      split_st seq (src_of_stmt s) s 
    in
    dfs @ [
      Exe (sr,`EXE_label label1);
      Exe (sr,`EXE_ifnotgoto (e, label2));
      s';
      Exe (sr,`EXE_goto label1);
      Exe (sr,`EXE_label label2);
    ]

  | `AST_read (sr,name) ->  [Exe (sr,`EXE_read name)]
  | `AST_code (sr,s) -> [Exe (sr,`EXE_code s)]

let typeofargs a = 
      match List.map snd a with
      | [x] -> x
      | lst -> `TYP_tuple lst

let rec build_if d = match d with
  | `AST_function  (sr,name,ps,ret,_) -> 
    [
      `AST_function_decl 
      (
        sr,
        name,
        `TYP_function 
        (
          typeofargs ps,
          ret
        )
      )
    ]

  | `AST_procedure (sr,name,ps,_) ->
    [
      `AST_procedure_decl 
      (
        sr,
        name,
        `TYP_function 
        (
          typeofargs ps,
          `AST_void sr
        )
      )
    ]

  | `AST_typed_module (sr,name,typ,sts) -> 
    [`AST_typed_module (sr,name,typ,build_interface sts)]
  | `AST_untyped_module (sr,name,sts) -> 
    [`AST_untyped_module (sr,name,build_interface sts)]

  | `AST_var_decl _
  | `AST_val_decl _

  | `AST_type_alias _
  | `AST_union _
  | `AST_struct _
  | `AST_const_decl _
  | `AST_fun_decl _
  | `AST_proc_decl _ 
  | `AST_abs_decl _ 
    -> [d]
  | _ -> [] 

and build_interface m =
 List.concat (List.map build_if m)
 
let desugar_program name counter sts =
  let sr = 
    rsrange 
      (src_of_stmt (List.hd sts)) 
      (src_of_stmt (list_last sts))
  in
  let seq () = let n = !counter in incr counter; n in
  rst seq (`AST_untyped_module (sr,name,sts))

@h = tangler("src/flxd.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_print
open Flx_types
;;

let get_options argv = 
  let options = ref [] in
  for i = 1 to Array.length argv - 2 do
    let s = argv.(i) in
    let n = String.length s in
    if n > 1 && s.[0]='-' then 
      if s.[1]='-' then 
      begin
        let j = ref 2 in
        while !j < n && s.[!j]<>'=' do incr j done;
        let key = String.sub s 2 (!j - 2) in
        let value = 
          if s.[!j]='=' then 
            String.sub s (!j+1) (n - !j - 1)
          else 
            ""
        in
          options := !options @ [key,value]
      end 
      else
        options := !options @ [String.sub s 1 1, String.sub s 2 (n-2)]
    else 
      print_endline ("Option '"^s^"' must start with '-': ignored")
  done;
  !options
;;

let print_help () =
  print_endline "options:";
  print_endline "  -h, --help : print this help";
  print_endline "  --version: print version info";
  print_endline "  -v, --verbose: print symbol table";
  print_endline "  -q, --quiet: no stdout";
  print_endline "  -Idir, --include=dir : append dir to include path";
  exit(0)
;;

let version_string = "1.0.0"
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let options = get_options Sys.argv in
  let include_dirs = ref [] in
  let print_flag = ref false in
  List.iter (fun (key,value) ->
    if key = "include" || key = "I"
    then include_dirs := !include_dirs @ [value]

    else if key = "verbose" || key = "v"
    then print_flag := true

    else if key = "help" || key = "h"
    then print_help ()

    else if key = "version" 
    then (print_endline ("Felix Version " ^ version_string))
  )
  options
  ;
  if !print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    !include_dirs;
    print_endline ""
  end
  ;

  let filebase = Sys.argv.(argc-1) in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let s = Buffer.create 50 in
    begin 
      try 
        let i = ref (String.length filebase) in 
        while !i>0 do
          if filebase.[!i-1] = '/'
          then raise Not_found;
          Buffer.add_char s filebase.[!i-1];
          decr i
        done
      with _ -> ()
    end;
    Buffer.contents s
  in

  let have_interface = Sys.file_exists iface_file_name in

  (* PARSE THE INTERFACE FILE IF IT EXISTS *)
  if have_interface 
  then begin
    print_endline ("//Parsing Interface " ^ iface_file_name);

    let parse_tree =
      Flx_parse_ctrl.parse_file 
        input_file_name 
        (Filename.dirname iface_file_name)
        !include_dirs 
    in
    print_endline (Flx_print.string_of_compilation_unit parse_tree);
    print_endline "//PARSE OK";
  end 
  ;

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      !include_dirs 
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  (* IF THERE WAS NO INTERFACE FILE, GENERATE ONE *)
  if not have_interface 
  then begin
    print_endline "//No interface file found: generating one";
    let h = open_out iface_file_name in
    let iface = build_interface parse_tree in
    List.iter 
    (
      fun x->
        output_string h
        (
          (string_of_statement 0 x)^"\n"
        )
    ) 
    iface;
    close_out h
  end
  ;

  print_endline "//----------------------------";
  print_endline "//IMPLEMENTATION DESUGARED:";

  let counter = ref 1 in
  let deblocked = desugar_program module_name counter parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "//----------------------------";

with x -> flush stdout; print_endline "EXCEPTION"; 
  print_endline (Printexc.to_string x)
;;

