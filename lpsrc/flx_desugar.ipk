@head(1,"Desugaring")
Two routines: one to build interfaces
from modules, and one to lift lambdas
and also blocks.
@h = tangler("src/flx_desugar.mli")
@select(h)
open Flx_ast
open Flx_types
val desugar_program: 
  sym_state_t ->
  string ->
  statement_t list -> 
  asm_t list

@h = tangler("src/flx_desugar.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_typing2
open List
open Flx_pat
open Flx_srcref
open Flx_exceptions
open Flx_macro
let this_version = !Flx_version.version_data 

let generated = ("Generated by desugaring",0,0,0,0)

exception Found_file of string

let find_file_in_path incdirs f =
  try
    List.iter
    (fun d -> 
      let f = Filename.concat d f in 
      if Sys.file_exists f 
      then raise (Found_file f)
    )
    incdirs
    ;
    ""
  with Found_file s -> s 

let find_file incdirs f =
  if String.length f = 0
  then failwith "Empty include file name"
  ;
  if f.[0] = '/' then f 
  else find_file_in_path incdirs f

let filetime f =
  if f = "" then 0.0 
  else 
    try (Unix.stat f).Unix.st_mtime 
    with | _ -> 0.0

let include_file syms inspec =
  let basename = try Filename.chop_extension inspec with _ -> inspec in
  if mem basename !(syms.include_files)
  then []
  else 
    let include_dirs = syms.compiler_options.include_dirs in
    syms.include_files := basename :: !(syms.include_files);
    let tf = find_file_in_path include_dirs (basename ^ ".flx") in
    let pf = find_file_in_path include_dirs (basename ^ ".par") in
    let tf_mt = filetime tf in
    let pf_mt = filetime pf in
    let saveit sts =
      let pf = 
        if pf = "" then 
          (try Filename.chop_extension tf with | _ -> tf) ^ ".par"
        else pf
      in
        try (* to write Marshalled parse tree out *)
          let x = open_out_bin pf in
          Marshal.to_channel x (this_version,sts) [];
          close_out x
        with _ -> () (* can't write, don't worry *)
    in
    let parseit() =
      let sts = 
        Flx_parse_ctrl.parse_file 
          tf 
          (Filename.dirname tf)
          include_dirs 
      in
        let local_prefix = Filename.basename basename in
        expand_macros local_prefix 5000 sts
    in
    let sts =
      (* -- no file ----------------------------------------- *)
      if tf_mt = 0.0 && pf_mt = 0.0 then 
        failwith 
        (
          "No .flx or .par file for name " ^ 
          basename ^
          " found in path:\n" ^ 
          String.concat "; " include_dirs
        )

      (* -- parsed file is newer or text doesn't exist ------- *)
      else if tf_mt < pf_mt then 
        let x = open_in_bin pf in
        let (that_version,tree) = Marshal.from_channel x in
        close_in x;
        if this_version = that_version
        then
          tree
        else 
          let sts = parseit() in
          saveit sts;
          sts

      (* -- text file is newer or parsed file doesn't exist -- *)
      else 
        let sts = parseit() in
        saveit sts;
        sts
    in
      sts

let  fix_params seq (ps:parameter_t list):string list * parameter_t list = 
  let rec aux (ps:parameter_t list) :string list * parameter_t list =
    match ps with
    | (x,`TYP_none) :: t ->
      let v = "_v"^si (seq()) in
      let vt: typecode_t = `AST_name(generated,v,[]) in
      let vs,ps = aux t in
      (v::vs),((x,vt)::ps)
      
    | h :: t -> 
      let vs,ps = aux t in 
      vs, (h::ps)
    | [] -> [],[]
  in aux ps

let arglist x = 
  match x with
  | `AST_tuple (_,ts) -> ts
  | _ -> [x]

let mkcurry seq sr name vs args return_type kind body =
  let vss',args= split (map (fix_params seq) args) in
  let vs = concat (vs :: vss') in
  let mkfuntyp d c = `TYP_function (d,c)
  and typeoflist lst = match lst with
    | [x] -> x
    | _ -> `TYP_tuple lst
  in 
  let mkret arg ret = mkfuntyp (typeoflist (List.map snd arg)) ret in
  let arity = List.length args in
  let rettype args = 
    match return_type with
    | `TYP_none -> `TYP_none
    | _ -> List.fold_right mkret args return_type 
  in

  let rec aux args vs =  
    let n = List.length args in
    let name n = 
      if n = arity
      then name (* top level *)
      else name^"_curry_" ^ string_of_int n
    in
    match args with 
    | [] -> 
        (match kind with
        | `InlineFunction
        | `Function ->
          let props = match kind with
          | `InlineFunction -> [`Inline]
          | _ -> []
          in
          begin match return_type with
          | `AST_void _ ->
            `AST_function (sr, name n, vs, [], return_type, props, body)
          | _ ->
            syserr sr "Function with no arguments"
          end

        | `Object ->
          `AST_object (sr, name n, vs, [], body)
        )

    | h :: [] -> (* bottom level *)
        (match kind with
        | `InlineFunction
        | `Function ->
          let props = match kind with
          | `InlineFunction -> [`Inline]
          | _ -> []
          in
          `AST_function (sr, name n, vs, h, return_type, props, body)
        | `Object ->
          `AST_object (sr, name n, vs, h, body)
        )
    | h :: t ->
      let m = List.length args in
      let body = 
        [
          aux t [];
          `AST_fun_return 
          (
            sr,
            `AST_suffix
            (
              sr,
              (
                `AST_name (sr,name (m-1),[]),
                typeoflist (List.map snd (List.hd t))
              )
            )
          )
        ] 
      in
        `AST_function (sr, name m, vs, h, rettype t, [], body)
   in aux args vs

(* model binary operator as procedure call *)
let assign sr op l r = 
  match op with
  | "_set" -> `AST_cassign (sr,l,r)
  | _ ->
  `AST_call 
  (
    sr,
    `AST_name (sr, op,[]),
    `AST_tuple 
    (
      sr, 
      [ 
        `AST_ref (src_of_expr l,l); 
        r
      ]
    )
  )



let find_methods seq sr sts =
  let methods = ref [] in
  let rec check = function 
    | `AST_curry (sr,mname,vs,pss,ret,kind,sts) ->
      check (mkcurry seq sr mname vs pss ret kind sts)

    (*
    | `AST_object (sr,mname, vs, ps, sts) ->
       check (`AST_function (sr,mname,vs,ps,`TYP_none,props,sts))
    *)

    | `AST_function (sr,mname, vs, ps, ret,props,sts) ->
      if vs <> [] then
      clierr sr "[process_object] Object methods may not be generic"
      ;
      let argtyp = match map snd ps with 
        | [] -> `TYP_tuple []
        | [a] -> a
        | x -> `TYP_tuple x
      in
      let typ = `TYP_function (argtyp, ret) in
      methods := (mname, typ) :: !methods
    | _ -> ()
  in
  iter check sts
  ;
  rev !methods

(* split lambdas out. Each lambda is replaced by a
   reference to a synthesised name in the original
   statement, which is prefixed by the definition.

   Blocks are replaced by a procedure definition
   and a call.

   The match statement requires all case bodies
   be replaced by calls as well.

   Actual lambdas in expressions are replaced
   by a reference and function or procedure definition.

   Attempt handler bodies are requires all handlers
   to be replaced by a call as well.
*)

(* convert an expression into a list of assembly instructions,
   plus an expression: basically, this means removing lambdas
*)

(*
  ARGGG! rex guarrantees to lift lambdas out of expressions,
  but the lifted lambda declarations also have bodies
  which might contain expression containing lambdas,
  so we have to apply rsts to these bodies..
*)

let rec rex syms name (e:expr_t) : asm_t list * expr_t = 
  let rex e = rex syms name e in
  let rsts sts = concat (map (rst syms name `Private) sts) in
  let sr = src_of_expr e in
  let seq () = let n = !(syms.counter) in incr (syms.counter); n in
  match e with

  | `AST_match_ctor _ 
  | `AST_match_case _ 
  | `AST_ctor_arg _ 
  | `AST_case_arg _ 
  | `AST_void _ 
  | `AST_arrow _ 
  | `AST_superscript _ 
  | `AST_as _
  | `AST_product _ 
  | `AST_sum _
  | `AST_type_match _
  | `AST_ellipsis _
    ->
    clierr sr ("[rex] Unexpected " ^ string_of_expr e)

  | `AST_noexpand (_,e) -> rex e
  | `AST_name (sr,name,_) -> [],e

  | `AST_deref (sr,e) ->
    let l1,x1 = rex e in
    l1, `AST_deref (sr,x1)

  | `AST_ref (sr,e) ->
    let l1,x1 = rex e in
    l1, `AST_ref (sr,x1)

  | `AST_suffix _ -> [],e  (* ?? *)

  | `AST_lookup (sr,(e,id,ts)) ->
    let l1,x1 = rex e in
    l1, `AST_lookup (sr,(x1,id,ts))

  | `AST_case_tag _ -> [],e
  | `AST_typed_case _ -> [],e
  | `AST_literal _ -> [],e

  | `AST_expr _ -> [],e

  | `AST_cond (sr,(e,b1,b2)) ->
     rex 
     (
       `AST_match 
       (
         sr,
         (
           e,
           [
             `PAT_const_ctor (sr,`AST_case_tag (sr,1)),b2;
             `PAT_const_ctor (sr,`AST_case_tag (sr,2)),b1
           ]
         )
       )
     )
     
  (* we have to lift lambdas out of typeof exprs,
     even though they're never called,
     so the typing works correctly
  *)
  | `AST_typeof (sr,e') ->
    let l1,x1 = rex e' in
    l1, `AST_typeof (sr,(x1))

  | `AST_get_n (sr,(n,e')) ->
    let l1,x1 = rex e' in
    l1, `AST_get_n (sr,(n,x1))

  | `AST_apply (sr,(fn,arg)) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, `AST_apply (sr,(x1,x2))

  | `AST_map (sr,fn,arg) -> 
    let l1,x1 = rex fn in 
    let l2,x2 = rex arg in
    l1 @ l2, `AST_map (sr,x1,x2)

  | `AST_method_apply (sr,(fn,arg)) -> 
    let l2,x2 = rex arg in
    l2, `AST_method_apply (sr,(fn,x2))
    
  | `AST_tuple (sr,t) -> 
    let lss,xs = split (map rex t) in
    concat lss,`AST_tuple (sr,xs)

  | `AST_lambda (sr,(params,res,sts)) -> 
    let props = [`Inline] in
    let vs, params = fix_params seq params in
    let n = seq() in
    let name = "_lam_" ^ string_of_int n in
    let argtyp = type_of_argtypes (map snd params) in
    [match res with
    | _ -> Dcl (sr,name,`Private,vs,`DCL_function (params, res, props, rsts sts))
    ],
    `AST_suffix 
    (
      generated,
      (
        `AST_name (generated,name,[]), 
        type_of_argtypes (map snd params)
      )
    )

  | `AST_dot (sr,(obj,comp)) -> 
    let l1,x1 = rex obj in 
    l1 , `AST_dot (sr,(x1,comp))

  | `AST_coercion (sr,(e,t)) ->
    let l1,x1 = rex e in 
    l1, `AST_coercion (sr,(x1,t))

  | `AST_regmatch (sr,(e,cls')) ->
    let dcls = ref [] in
    let cls = ref [] in
    iter 
    (fun (re,e) -> 
      let l,x = rex e in
      dcls := l @ !dcls;
      cls := (re,x) :: !cls
    )
    cls'
    ;

    let n = seq() in
    let fname = "regmatch" ^ string_of_int n in
    let l,x = rex e in
    let exes = [Exe(sr,`EXE_regmatch (x,!cls))] in
    let rfun = Dcl(sr,fname,`Private,[],`DCL_function([],`TYP_none,[],exes)) in
    rfun :: l @ !dcls,
    `AST_apply(sr,(`AST_name(sr,fname,[]),`AST_tuple(sr,[])))
   
  | `AST_reglex (sr,(p1,p2,cls')) ->
    let lexer_module = `AST_name(sr,"Lexer",[]) in
    let iterator_type = 
      `AST_lookup ( sr, ( lexer_module, "iterator", [])) 
    in
    let unit_type = `TYP_tuple [] in
    let unit_value = `AST_tuple (sr,[]) in
    let fetcher_type = `TYP_function [unit_type, iterator_type] in
    let params = 
      [
        "lexeme_start",iterator_type;
        "lexeme_end",iterator_type;
        "buffer_end",iterator_type
      ]
    in
    let dcls = ref [] in
    let cls = ref [] in
    let ls = `AST_expr(sr,"lexeme_start",iterator_type) in
    let le = `AST_expr (sr,"lexeme_end",iterator_type) in
    let be = `AST_expr (sr,"buffer_end",iterator_type) in
    iter 
    (fun (re,e) -> 
      let l,x = rex e in
      dcls := l @ !dcls;
      let n = seq() in
      let name = "_lam_" ^ si n in
      let x = `AST_tuple (sr,[le;x]) in
      let d = Dcl
        (
          sr,
          name,
          `Private,
          [],
          `DCL_function 
          (
            params,
            `TYP_none,
            [`Inline],
            [Exe (sr,`EXE_fun_return x)]
           )
        ) 
      in
      dcls := d :: !dcls;
      let a = `AST_apply
        (
          sr,
          (
            `AST_name (sr,name,[]),
            `AST_tuple (sr,[ls; le; be])
          )
        ) 
      in
      cls := (re,a) :: !cls
    )
    cls'
    ;

    let n = seq() in
    let fname = "reglex" ^ string_of_int n in
    let l1,x1 = rex p1 in
    let l2,x2 = rex p2 in
    let exes = [Exe(sr,`EXE_reglex (x1,x2,!cls))] in
    let rfun = Dcl(sr,fname,`Private,[],`DCL_function([],`TYP_none,[],exes)) in
    rfun :: l1 @ l2 @ !dcls,
    `AST_apply(sr,(`AST_name(sr,fname,[]),`AST_tuple(sr,[])))
     
  | `AST_letin (sr,(pat,e1,e2)) ->
    rex (`AST_match (sr,(e1,[pat,e2])))
    
  (* MATCH HANDLING NEEDS TO BE REWORKED, THE SWITCHING SHOULD BE
     DELAYED TO ALLOW TYPE BASED OPTIMISATION WHERE THE TOP
     LEVEL MATCH ON A UNION CAN USE A SWITCH.

     ALSO, TO ALLOW MULTIPLE PATTERNS WITH ONE HANDLER,
     GIVE THE HANDLER PARAMETERS, AND HAVE THE TOP LEVEL
     MATCH HANDLERS FOR EACH CASE FOR THAT CODE CALL IT:

     eg:
     
     match x with | A x | B x => x endmatch
  *)
  
  | `AST_match (sr,(e,pss)) ->
    if length pss = 0 then clierr sr "Empty Pattern";

    (* step 1: evaluate e *)
    let d,x = rex e in
    let match_function_index = seq() in

    let match_var_name = name^ "_match_var_"^string_of_int match_function_index in
    let match_function_id = name^ "_match_fun_"^ string_of_int match_function_index in
    let match_function = `AST_name (sr,match_function_id,[]) in
    let match_seq = ref (seq()) in

    let expr_src = src_of_expr e in

    (* WOE. The expr may contain a lambda, which stuffs up
       bind_expression which is called by bind_type ..
    *)
    let evl = 
      [
        Dcl (expr_src,match_var_name,`Private,[],`DCL_val (`TYP_typeof x));
        Exe (expr_src,`EXE_init (match_var_name,x))
      ]
    in
    let pats,_ = split pss in
    Flx_pat.validate_patterns pats
    ;
    let ematch_seq = seq() in
    (*
    let end_match_label = "_em" ^ string_of_int ematch_seq in
    *)
    let matches = ref [Exe (generated,`EXE_comment "begin match")] in
    let match_caseno = ref 1 in
    iter
    (fun (pat,e) -> 
      let n1 = !match_seq in
      let n2 = seq() in
      let patsrc = src_of_pat pat in
      let expr_src = src_of_expr e in
      let match_checker_id = name ^ "_mc" ^ string_of_int n1 in
      let match_handler_id = name ^ "_mh" ^ string_of_int n1 in
      let match_checker = `AST_name (patsrc,match_checker_id,[]) in
      let match_handler = `AST_name (expr_src,match_handler_id,[]) in

      let sts,result_expr = rex e in
      let body = 
        sts @ 
        [Exe (expr_src,`EXE_fun_return (result_expr))] 
      in
      matches := !matches @
      [
        Dcl (patsrc,match_checker_id,`Private,[],`DCL_match_check (pat,match_var_name));
        Dcl 
        (
          expr_src,
          match_handler_id,
          `Private,
          [],
          `DCL_match_handler 
          (
            pat,
            match_var_name,
            body
          )
        )
      ]
      @
      [
      Exe (patsrc,`EXE_comment ("match case " ^ string_of_int !match_caseno));
      Exe (patsrc,`EXE_label ("_ml" ^ string_of_int n1));
      Exe 
      (
        patsrc,
        `EXE_ifnotgoto 
        (
          `AST_apply 
          (
            patsrc,
            (
              match_checker,
              `AST_tuple (patsrc,[])
            )
          ), 
          "_ml" ^ string_of_int n2
        )
      )
      ;
      Exe 
      (
        patsrc,
        `EXE_fun_return 
        (
          `AST_apply 
          (
            patsrc,
            (
              match_handler, 
              `AST_tuple (patsrc,[])
            )
          )
        )
      )
      (*
      ;
      Exe (patsrc,`EXE_goto end_match_label)
      *)
      ]
      ;
      incr match_caseno;
      match_seq := n2
    )
    pss
    ;
    let failure_label = "_ml" ^ string_of_int !match_seq in

    let match_function_body =
    d
    @
    evl
    @
    !matches
    @
    [
      Exe (sr,`EXE_comment "match failure");
      Exe (sr,`EXE_label failure_label);
      Exe (sr,`EXE_noreturn_code "      assert((\"match failure\",false));\n");
      (*
      Exe (sr,`EXE_comment "match exit");
      Exe (sr,`EXE_label end_match_label)
      *)
    ]
    in
    [
      Dcl 
      (
        sr,
        match_function_id,
        `Private,
        [],
        `DCL_function 
        (
          [],
          `TYP_none,
          [`Inline],
          match_function_body
        )
      )
    ]
    ,
    `AST_apply 
    (
      sr,
      (
        match_function, 
        `AST_tuple (sr,[])
      )
    )

(* remove blocks *)
and rst syms name access st : asm_t list = 
  let rex x = rex syms name x in
  let rsts name sts = concat (map (rst syms name access) sts) in
  let seq () = let n = !(syms.counter) in incr (syms.counter); n in

  match st with
  | `AST_private (sr,st) ->
     rst syms name `Private st
     
  | `AST_include (sr,inspec) ->
    let sts = include_file syms inspec in
    rsts name sts

  | `AST_regdef (sr,name,regexp) -> 
    [Dcl (sr,name,access,[],`DCL_regdef regexp)]
  | `AST_label (sr,s) -> [Exe (sr,`EXE_label s)]
  | `AST_proc_return sr -> [Exe (sr,`EXE_proc_return)]
  | `AST_goto (sr,s) -> [Exe (sr,`EXE_goto s)]
  | `AST_open (sr,name) -> [Dir (sr,DIR_open name)]
  | `AST_use (sr,n,qn) -> [Dir (sr,DIR_use (n,qn))]

  | `AST_comment s -> [Exe (generated,`EXE_comment s)]

  (* objects *)
  | `AST_export_fun (sr,name,cpp_name) ->
    [Iface (sr,`IFACE_export_fun (name,cpp_name))]

  | `AST_export_type (sr,typ,cpp_name) ->
    [Iface (sr,`IFACE_export_type (typ,cpp_name))]

  | `AST_var_decl (sr,name,vs,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,access,vs,`DCL_var t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,access,vs,`DCL_var (`TYP_typeof x)); Exe (sr,`EXE_init (name,x))]
    | Some t,None -> [Dcl (sr,name,access,vs,`DCL_var t)]
    | None,None -> failwith "Expected variable to have type or initialiser"
    end

  | `AST_val_decl (sr,name,vs,typ,expr) -> 
    begin match typ,expr with
    | Some t, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,access,vs,`DCL_val t); Exe (sr,`EXE_init (name,x))]
    | None, Some e ->
      let d,x = rex e in
      d @ [Dcl (sr,name,access,vs,`DCL_val (`TYP_typeof x)); Exe (sr,`EXE_init (name,x))]
    | Some t, None -> [Dcl (sr,name,access,vs,`DCL_val t)] (* allowed in interfaces *)
    | None,None -> failwith "Expected value to have type or initialiser"
    end

  | `AST_const_decl (sr,name, vs,typ, s, reqs) -> [Dcl (sr,name,access,vs,`DCL_const (typ,s, reqs))]

  (* types *)
  | `AST_abs_decl (sr,name,vs,flag,str, reqs) -> [Dcl (sr,name,access,vs,`DCL_abs (flag,str,reqs))]
  | `AST_union (sr,name, vs, components) -> [Dcl (sr,name,access,vs,`DCL_union (components))]
  | `AST_struct (sr,name, vs, components) ->  [Dcl (sr,name,access,vs,`DCL_struct (components))]
  | `AST_type_alias (sr,name,vs,typ) -> [Dcl (sr,name,access,vs,`DCL_type_alias (typ))]

  | `AST_curry (sr,name',vs,pps,ret,kind,sts) ->
    rst syms name access (mkcurry seq sr name' vs pps ret kind sts)

  (* The object *)
  (* THIS IS HACKY AND DOESN'T WORK PROPERLY --
    need a real object construction --
    the constructor name and object type should
    be the same .. at present the exported type
    may refer to typedefs in the constructor function,
    and these cant be found by lookup .. really
    we need to use a proper construction that will
    be bound correctly without lookup
  *)
  | `AST_object (sr,name,vs,params,sts) -> 
    let vs',params = fix_params seq params in
    let vs = vs @ vs' in
    let methods = find_methods seq sr sts in
    let mtuple =  
      `AST_tuple 
      (
        sr,
        map 
          (fun (n,t) ->
            match t with 
            | `TYP_function (d,_) ->
              `AST_suffix ( sr, ( `AST_name (sr,n,[]), d))
            | _ -> assert false
          )
          methods
      ) 
    in
    let otname = "_ot_" ^ name in
    let rtyp = `AST_name (sr,otname,[]) in
    let retval:expr_t = `AST_apply (sr,(rtyp, mtuple)) in
    let sts = sts @ [`AST_fun_return (sr,retval)] in
    [
      Dcl (sr,otname,access,vs,`DCL_struct methods);
      Dcl (sr,name,access,vs,`DCL_function (params,rtyp,[],rsts name sts))
    ]
  
  (* functions *)
  | `AST_function (sr,name, vs, params, res, props, sts) -> 
    let vs',params = fix_params seq params in
    let vs = vs @ vs' in
    [Dcl (sr,name,access,vs,`DCL_function (params, res, props, rsts name sts))]
    
  | `AST_fun_decl (sr,name,vs,args,result,code, reqs) ->
    let typeoflist lst = match lst with
      | [x] -> x
      | _ -> `TYP_tuple lst
    in 
    let n = length args in
    let prim_id = "_prim_" ^ name in
    let type_args = map (fun t -> `AST_name (sr,t,[])) vs in
    let prim_name = `AST_name (sr,prim_id,type_args) in
    let argtype = typeoflist args in 
    let prim_name = `AST_suffix (sr,(prim_name,argtype)) in
    let param_names = map (fun i -> "_a" ^ si i) (nlist n) in
    let params = combine param_names args in
    let argument =
      match param_names with
      | [x] -> `AST_name (sr,x,[]) 
      | _ -> 
        let ps = map (fun x -> `AST_name (sr,x,[])) param_names in
        `AST_tuple (sr,ps) 
    in
    let body = 
      match result with
      | `AST_void _ ->
        [
          Exe (sr,`EXE_call (prim_name, argument)); 
          Exe (sr,`EXE_proc_return) 
        ]
      | _ ->
        [
          Exe 
          (
            sr,
            `EXE_fun_return 
            (
              `AST_apply(sr,(prim_name, argument))
            )
          )
        ]
    in
    [
      Dcl (sr,prim_id,access,vs,`DCL_fun (args,result,code,reqs));
      Dcl (sr,name,access,vs,`DCL_function (params,result,[`Inline],body))
    ]

  (* misc *)
  | `AST_untyped_module (sr,name, vs, sts) -> 
    [
      Dcl (sr,name,access,vs,`DCL_module (rsts name sts))
    ]
    @
      (* HACK !!!! *)
    if vs = [] then
    [
      Exe 
      (
        sr,
        `EXE_call 
        (
          `AST_suffix
          (
            sr,
            (
              `AST_lookup
              (
                sr,
                (
                  `AST_name (sr,name,[]),
                  "_init_",
                  []
                )
              ),
              `TYP_tuple []
            )
          ),
          `AST_tuple (generated,[])
        )
      )
    ] else []

  | `AST_header (sr,name,s) -> 
    [Dcl (sr,name,access,[],`DCL_header s)]

  | `AST_body (sr,name,s) -> 
    [Dcl (sr,name,access,[],`DCL_body s)]

  (* executable *)
  | `AST_fun_return (sr,e) ->
    let d,x = rex e in d @ [Exe (sr,`EXE_fun_return x)]
  
  | `AST_nop _ -> []

  | `AST_cassign (sr,l,r) ->
     let l1,x1 = rex l in
     let l2,x2 = rex r in
     l1 @ l2 @ [Exe (sr,`EXE_assign (x1,x2))]
     
  | `AST_assign (sr,fid,l,r) ->
    let rec aux (l,t) r =
      match l with
      | `Expr (sr,e) -> 
        begin match e with
        | `AST_tuple (_,ls) ->
          let n = seq() in
          let vn = "_" ^ si n in
          let sts = ref [] in
          let count = ref 0 in
          iter
          (fun l ->
            let r' = `AST_get_n (sr,(!count,`AST_name (sr,vn,[]))) in
            let l' = `Expr (sr,l),None in
            let asg = aux l' r' in
            sts := !sts @ asg;
            incr count
          )
          ls
          ;
          `AST_val_decl (sr,vn,[],t,Some r) :: !sts
        | _ -> 
          if fid = "_init"
          then
            match e with
            | `AST_coercion (_,(`AST_name (_,n,[]),t')) ->
              let t = match t with 
                | None -> Some t'
                | t -> t
              in
              [`AST_val_decl (sr,n,[],t,Some r)]

            | `AST_name (_,n,[]) ->
              [`AST_val_decl (sr,n,[],t,Some r)]
            | _ -> clierr sr "identifier required in val init"
          else
            [assign sr fid e r]
        end
      | `Val (sr,n) ->
          [`AST_val_decl (sr,n,[],t,Some r)]
      | `Var (sr,n) ->
          [`AST_var_decl (sr,n,[],t,Some r)]
      | `Skip (sr) ->  []
      | `Name (sr,n) -> 
        let n = `AST_name(sr,n,[]) in
          [assign sr fid n r]
      | `List ls ->
          let n = seq() in
          let vn = "_" ^ si n in
          let sts = ref [] in
          let count = ref 0 in
          iter
          (fun l ->
            let r' = `AST_get_n (sr,(!count,`AST_name (sr,vn,[]))) in
            let asg = aux l r' in
            sts := !sts @ asg;
            incr count
          )
          ls
          ;
          `AST_val_decl (sr,vn,[],t,Some r) :: !sts
    in
      let sts = aux l r in
      rsts name sts

  | `AST_call (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_call (x1,x2))]

  | `AST_jump (sr,proc, arg) ->
    let d1,x1 = rex proc in
    let d2,x2 = rex arg in
    d1 @ d2 @ [Exe (sr,`EXE_call (x1,x2))]

  | `AST_loop (sr,proc, arg) ->
    let d2,x2 = rex arg in
    d2 @ [Exe (sr,`EXE_loop (proc,x2))]

  | `AST_ifgoto (sr,e,lab)->
    let next = "_skip_" ^ string_of_int (seq()) in
    let d,x = rex e in
    d @ 
    [
      (* we have to do this, in case the clients
        goto is non-local
      *)
      Exe (sr,`EXE_ifnotgoto (x,next));
      Exe (sr,`EXE_goto lab);
      Exe (sr,`EXE_label next)
    ]

  (* client can't write this one *)
  | `AST_ifnotgoto (sr,e,lab)->
    let d,x = rex e in
    d @ [Exe (sr,`EXE_ifnotgoto (x,lab))]

   
  | `AST_read (sr,name) ->  [Exe (sr,`EXE_read name)]
  | `AST_code (sr,s) -> [Exe (sr,`EXE_code s)]
  | `AST_noreturn_code (sr,s) -> [Exe (sr,`EXE_noreturn_code s)]

  | st ->
    let sr = src_of_stmt st in
    clierr sr 
    (
      "[desugar] Unexpected statment\n" ^
      string_of_statement 0 st
    )

let typeofargs a = 
      match map snd a with
      | [x] -> x
      | lst -> `TYP_tuple lst


let desugar_program syms name sts =
  let sts = match sts with
    | [] -> [`AST_nop (generated, "empty module")]
    | _ -> sts
  in
  let sr = 
    rsrange 
      (src_of_stmt (hd sts)) 
      (src_of_stmt (list_last sts))
  in
  let sts = expand_macros name 5000 sts in
  rst syms "top" `Public (`AST_untyped_module (sr,name,[],sts))

@h = tangler("src/flxd.ml")
@select(h)
open Flx_util
open Flx_desugar
open Flx_print
open Flx_types
open Flx_getopt
open Flx_flxopt
open Flx_version

let print_help () = print_options(); exit(0)
;;

let reverse_return_parity = ref false
;;
try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  print_endline "//----------------------------";
  print_endline "//IMPLEMENTATION DESUGARED:";

  let counter = ref 1 in
  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in
  let deblocked = desugar_program syms module_name parse_tree in
  print_endline (Flx_print.string_of_desugared deblocked);
  print_endline "//----------------------------";

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

