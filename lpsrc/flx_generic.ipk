@head(1,'Generic support')
@h = tangler('src/flx_generic.mli')
@select(h)
open Flx_types
open Flx_mtypes2
open Flx_ast

val find_split_vs:
  sym_state_t ->
  int -> 
  (string * int * typecode_t) list *
  (string * int * typecode_t) list *
  typecode_t

val find_vs:
  sym_state_t ->
  int ->
  ivs_list_t

val adjust_ts:
  sym_state_t ->
  range_srcref ->
  int ->
  btypecode_t list ->
  btypecode_t list

val make_params:
  sym_state_t ->
  range_srcref ->
  int ->
  btypecode_t list ->
  (string * btypecode_t) list

val make_varmap:
  sym_state_t ->
  range_srcref ->
  int ->
  btypecode_t list ->
  (int, btypecode_t) Hashtbl.t

@h = tangler('src/flx_generic.ml')
@select(h)
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_util
open List
open Flx_exceptions
open Flx_print
open Flx_ast

(* Adjustment of type argument lists works much
like the activation record display, so well call
it the type display: it is just a list of all
the type variables bound by upscope quantifiers
(which should be all of them :-)

For a name without any subscripts, a sibling call, 
or upscope call is possible, and just takes the head of the
type display corresponding to the call depth.

For a downscope call (eg referencing an element of
a contained module ..) additional type must be given.

However, sibling and upscope calls can also be made
with subscripts, replacing the trailing default
values of the current display.

So: the given subscripts can vary from 0 to the number
of variables at the call level, with the remaining head
variables defaulted from the calling environment, unless
the call depth is deeper in which case the trailing
values must be given

Actually the algorithm is simpler: just get
the default display for the target, and splice
its head with the given subscript list to get a 
list the same length, if the target is longer
than the list, otherwise just take the head of the
subscript list -- this can happen when an instantiated
call calls upscope using an unindexed name.
*)

let merge_con con1 con2 =
  match con1,con2 with
  | `TYP_tuple[],`TYP_tuple[] -> `TYP_tuple[]
  | `TYP_tuple[],b -> b
  | a,`TYP_tuple[] -> a
  | `TYP_intersect a, `TYP_intersect b -> `TYP_intersect (a@b)
  | `TYP_intersect a, b -> `TYP_intersect (a @[b])
  | a,`TYP_intersect b -> `TYP_intersect (a::b)
  | a,b -> `TYP_intersect [a;b]

let merge_ivs (vs1,con1) (vs2,con2) :ivs_list_t =
  vs1 @ vs2, merge_con con1 con2

let rec find_vs syms i : ivs_list_t =
  match Hashtbl.find syms.dfns i with
  {parent=parent;vs=vs} ->
  match parent with
  | Some i -> merge_ivs (find_vs syms i) vs
  | None -> vs

let rec find_func_vs syms vs j =
  match Hashtbl.find syms.dfns j with
  | {parent=parent; vs=vs'; symdef=`SYMDEF_module } ->
    begin match parent with 
    | None -> 
      let vs = merge_ivs vs' vs in
      [],fst vs, snd vs
    | Some j -> find_func_vs syms (merge_ivs vs' vs) j
    end

  | _ ->
    let (vs',con) = find_vs syms j in
    vs',fst vs,merge_con con (snd vs)

let find_split_vs syms i =
  match Hashtbl.find syms.dfns i with
  {symdef=`SYMDEF_typevar _} -> [],[],`TYP_tuple[]
  
  | {parent=parent; vs=vs} ->
  match parent with 
  | None -> [],fst vs, snd vs
  | Some j -> find_func_vs syms vs j

let print_ivs vs = 
  catmap ", " (fun (s,i,_) -> s ^ "<" ^ si i ^ ">") vs 

let adjust_ts syms sr index ts =
  let pvs,vs,con = find_split_vs syms index in
  let k = length pvs in
  let m = length vs in 
  let n = length ts in
  if n>m then begin
    match Hashtbl.find syms.dfns index with {id=id} ->
    clierr sr 
    (
      "For "^ id^ "<" ^ si index ^ 
      "> Too many type subscripts, expected " ^ 
      si m ^ " got " ^ si n ^ 
      "=["^catmap "," (sbt syms.dfns) ts ^ "]"^
      "\nparent vs="^print_ivs pvs ^ 
      "\nvs="^print_ivs vs
    )
  end;
  if n<m then begin
    match Hashtbl.find syms.dfns index with {id=id} ->
    clierr sr 
    (
      "For "^id^"<" ^ si index ^ 
      "> Not enough type subscripts, expected " ^ 
      si m ^ " got " ^ si n ^ 
      "\nparent vs="^print_ivs pvs ^ 
      "\nvs=" ^ print_ivs vs
    )
  end;
  
  map (fun (_,i,_) -> `BTYP_var (i,`BTYP_type)) pvs @ ts
  

let make_params syms sr i ts =
  let vs,_ = find_vs syms i in
  let ts = adjust_ts syms sr i ts in
  assert (length vs = length ts);
  map2 (fun (s,i,_) t -> s,t) vs ts

(* full ts required *)
let make_varmap syms sr i ts = 
  let vs,_ = find_vs syms i in
  assert (length ts = length vs);
  let vars = map2 (fun (s,i,_) t -> i,t) vs ts in
  hashtable_of_list vars

