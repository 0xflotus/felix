@head(1,'SDL')
$Log$
Revision 1.3  2006/02/24 15:40:15  skaller
Enhance flx_pkgconfig

Revision 1.2  2006/02/24 03:15:01  rfistman
added flx_sdl_run

Revision 1.1  2006/02/23 17:06:08  skaller
Refactor build system.

Revision 1.29  2006/02/23 06:19:46  skaller
Split off some test from flx.pak, need to keep open files
under ulimit.

Revision 1.28  2006/02/22 06:02:26  skaller
Merge.

Revision 1.27  2006/02/22 05:52:23  rfistman
added sdl package's dependence on libfaio, libflx and libdemux

Revision 1.26  2006/02/22 04:53:18  skaller
sdl package requirement on libfaio added. Add new type
to the compiler, d --> c, which is C function type.

Revision 1.25  2006/02/19 05:29:15  skaller
Fiddle with SDL/GL support stuff.

Revision 1.24  2006/02/18 16:30:48  skaller
More work on new package manager.

Revision 1.23  2006/02/15 10:54:09  skaller
Build time packaging system.

Revision 1.22  2006/02/09 21:05:33  skaller
Fixed sdl to use polling.

Revision 1.21  2006/02/09 07:42:10  skaller
Try event polling for sdl100, SDL doesn't support threads
reading events on Windows ..

Revision 1.20  2006/02/06 11:59:15  skaller
Sdl stuff: Add more event blocking whilst doing video

Revision 1.19  2006/02/04 11:55:42  skaller
sdl100 increase sound buffer from 512 to 2048, hope Windows
sound quality improves. Add Escape for sdl100 so we can
exit it without going thru all 16 frames.

Revision 1.18  2006/01/31 07:54:31  skaller
Fix sdl206, make sleep_request FLX_RTL_EXTERN

Revision 1.17  2006/01/30 08:58:19  skaller
Add package support to flx script

Revision 1.16  2006/01/30 01:09:07  skaller
more open GL lessons

Revision 1.15  2006/01/29 04:37:29  skaller
Fix various stuffs.

Revision 1.14  2006/01/25 18:39:55  skaller
Add mutex to protect SDL event source. Deploy in sdl110.
Fix bug in rtl, was allocating an slist_t but telling the
gc the shape was an slist_node_t, gc now runs and checks in sdl110.

Revision 1.13  2006/01/25 06:37:27  skaller
Move all header statements in SDL stuff inside modules
so the #includes aren't triggered unless something in
the module is actually used.

Revision 1.12  2006/01/25 00:34:40  rfistman
removed a few outstanding references to SDL_image
fixed a tiny typo in flx_use.ipk
got rid of superfluous private fn in faio.

Revision 1.11  2006/01/24 19:15:49  skaller
Add openGL test sdl110. Currently crashes in gc.
Add async request counter to driver.
Add configuration hack for openGL.

Revision 1.10  2006/01/24 03:03:13  skaller
Fix bug generating offsets for a cstruct. Upgrade tut121b expected
output to handle new symbol .-> (which is just C's ->, we can't use
the symbol -> because it means 'function' in the type language and
has the wrong precedence there) Added opengl binding.

Revision 1.9  2006/01/23 13:35:03  skaller
Remove wrong tail call optimisation, replacing tail call
with jump. This is correct but not allowed at inlinling stage.

Revision 1.8  2006/01/21 17:02:13  skaller
SDL sound with Felix callback, and asynchronous multiplexor
for timeout/keypress example. COOL!

Revision 1.7  2006/01/19 17:26:45  skaller
Add sound to SDL example. Fix serious bug in synchronous
channel I/O operations.

Revision 1.6  2006/01/18 14:52:14  skaller
Wrapped SDL event source, test case in tut/examples/sdl100

Revision 1.5  2006/01/18 05:50:04  rfistman
turned sdl_event thing into a driver request

Revision 1.4  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.

Revision 1.3  2006/01/08 08:56:44  skaller
Change rtl name for MACOSX to libflx_dynamic.dylib

Revision 1.2  2006/01/08 00:25:14  skaller
Minor fix to sdl stuff

@h=tangler('rtl/flx_sdl_run.cxx')
@select(h)
#include "SDL.h"
#include "flx_run.cxx"

@h = tangler('pkg/sdl.py')
@select(h)

if HAVE_SDL:
  SDL_FAIO_CPPS = [
    "faio/faio_sdl_event",             # any platform with SDL
  ]

  # flags are compiler natives switches
  # not to be confused with platform independent lists
  # of libraries, include files, paths, etc
  cflags = SDL_CFLAGS
  dflags = SDL_LIBS
  sflags = SDL_STATIC_LIBS
  
  cpp_cpps = SDL_FAIO_CPPS
  pkg_requires = ['faio']
  rtl_interfaces = ['faio_sdl_event']
  lib_requires = ['libfaio', 'libdemux','libflx']
  demos = glob.glob('tut'+os.sep+'examples'+os.sep+'sdl*.flx')

  # should be a .pak file ..
  iscr_source = ['lpsrc/flx_sdl.ipk']

@h = tangler('pkg/gl.py')
@select(h)
#

@h = tangler('pkg/glu.py')
@select(h)
#
pkg_requires = ['gl']

@h = tangler('pkg/glut.py')
@select(h)
#
pkg_requires = ['glu']

@h = tangler('pkg/sdl_drivers.py')
@select(h)

if HAVE_SDL:
  DRIVERS = [
    ('rtl/flx_sdl_run','bin/flx_sdl_run'),
  ]
  drivers = DRIVERS
  drivers_require_libs = ['libsdl','libfaio','libdemux','libflx']
  pkg_requires = ['flx_rtl','faio','demux']
  cflags = SDL_CFLAGS
  dflags = SDL_LIBS
  sflags = SDL_STATIC_LIBS
   

@h=tangler('lib/SDL/SDL_opengl.flx')
@select(h)

header '#include "SDL_opengl.h"';

include "GL/gl_lib";
include "GL/glu_lib";

module SDL_opengl_h
{
  inherit GL_gl_h;  
  inherit GL_glu_h;  
}

@h=tangler('lib/SDL/SDL.flx')
@select(h)
//Module        : SDL_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_INIT_EVERYTHING   0x0000FFFF
//#define SDL_INIT_EVENTTHREAD  0x01000000      /* Not supported on all OS's */
//#define SDL_INIT_NOPARACHUTE  0x00100000      /* Don't catch fatal signals */
//#define SDL_INIT_JOYSTICK     0x00000200
//#define SDL_INIT_CDROM                0x00000100
//#define SDL_INIT_VIDEO                0x00000020
//#define SDL_INIT_AUDIO                0x00000010
//#define       SDL_INIT_TIMER          0x00000001
//#define _SDL_H

module SDL_h
{
  requires package "sdl";
  header '#include "SDL.h"';
  open C_hack;
  
  const SDL_INIT_EVERYTHING: uint32;
  const SDL_INIT_EVENTTHREAD: uint32;
  const SDL_INIT_NOPARACHUTE: uint32;
  const SDL_INIT_JOYSTICK: uint32;
  const SDL_INIT_CDROM : uint32;
  const SDL_INIT_VIDEO: uint32;
  const SDL_INIT_AUDIO: uint32;
  const SDL_INIT_TIMER: uint32;

  //PROCEDURES
  proc SDL_Quit: 1;
  proc SDL_QuitSubSystem: uint32;
  
  //FUNCTIONS
  fun SDL_Init: uint32 -> int;
  fun SDL_InitSubSystem: uint32 -> int;
  fun SDL_WasInit: uint32 -> uint32;
}
@h=tangler('lib/SDL/SDL_active.flx')
@select(h)
//Module        : SDL_active_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_active.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_APPACTIVE         0x04            /* The application is active */
//#define SDL_APPINPUTFOCUS     0x02            /* The app has input focus */
//#define SDL_APPMOUSEFOCUS     0x01            /* The app has mouse coverage */
//#define _SDL_active_h

module SDL_active_h
{
  requires package "sdl";
  header '#include "SDL_active.h"';
  open C_hack;
  
  //FUNCTIONS
  fun SDL_GetAppState: 1 -> uint8;
}
@h=tangler('lib/SDL/SDL_audio.flx')
@select(h)
//Module        : SDL_audio_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_audio.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';


//INCLUDES
include"SDL/SDL_rwops";

module SDL_audio_h
{
  requires package "sdl";
  header '#include "SDL_audio.h"';
  open C_hack;
  open SDL_rwops_h;

  const SDL_MIX_MAXVOLUME : int;
  const AUDIO_S16MSB : uint16;
  const AUDIO_U16MSB : uint16;
  const AUDIO_S16LSB : uint16;
  const AUDIO_U16LSB : uint16;
  const AUDIO_S16SYS : uint16;
  const AUDIO_U16SYS : uint16;
  const AUDIO_S16 : uint16;
  const AUDIO_U16 : uint16;
  const AUDIO_S8 : uint16;
  const AUDIO_U8 : uint16;
 
  //ABSTRACT TYPES
  type SDL_audiostatus = 'SDL_audiostatus';
  fun eq:SDL_audiostatus * SDL_audiostatus -> bool = "$1==$2";

  //CSTRUCTS 
  cstruct SDL_AudioCVT {
    needed: int;
    src_format: uint16;
    dst_format: uint16;
    rate_incr: double;
    buf: ptr[uint8];
    len: int;
    len_cvt: int;
    len_mult: int;
    len_ratio: double;
    filters: ptr[SDL_audio_h_cft_2];
    filter_index: int;
  }
  cstruct SDL_AudioSpec {
    freq: int;
    format: uint16;
    channels: uint8;
    silence: uint8;
    samples: uint16;
    padding: uint16;
    size: uint32;
    callback_: SDL_audio_h_cft_1;
    userdata: address;
  }
 
  fun get_callback: SDL_AudioSpec -> SDL_audio_h_cft_1 = "$1.callback";
  fun get_callback: lvalue[SDL_AudioSpec] -> lvalue[SDL_audio_h_cft_1] = "$1.callback";
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*SDL_audio_h_cft_2)(struct SDL_AudioCVT *,  Uint16);''';
  type SDL_audio_h_cft_2 = 'SDL_audio_h_cft_2';

  header '''typedef void (*SDL_audio_h_cft_1)(void *,  Uint8 *, int);''';
  type SDL_audio_h_cft_1 = 'SDL_audio_h_cft_1';
  
  typedef flx_audio_callback_arg_t = ptr[uint8] * int;
  typedef flx_audio_callback_t = flx_audio_callback_arg_t -> void;
  export type (flx_audio_callback_t) as "flx_audio_callback_t";
  export type (flx_audio_callback_arg_t) as "flx_audio_callback_arg_t";

  header """
    void SDL_audio_callback(void *obj, Uint8 *stream, int len);
  """;

  body """
    // audio callback thunk
    void SDL_audio_callback(void *obj, Uint8 *stream, int len) {
      flx_audio_callback_t callback = (flx_audio_callback_t)obj;
      flx::rtl::con_t *p =
        callback->
        clone()->
        call(0,flx_audio_callback_arg_t(stream,len))
      ;
      while(p) p = p->resume();
    }
  """;

// not working yet
//  callback proc SDL_audio_callback: SDL_audio_callback * ptr[uint8] * int;
    
  //STRUCT or UNION TAG ALIASES
  
  /*
  //TYPE ALIASES
  typedef _struct_SDL_AudioSpec = SDL_AudioSpec;
  typedef _struct_SDL_AudioCVT = SDL_AudioCVT;
  */

  //ENUMERATION CONSTANTS
  const SDL_AUDIO_PAUSED: SDL_audiostatus = 'SDL_AUDIO_PAUSED';
  const SDL_AUDIO_STOPPED: SDL_audiostatus = 'SDL_AUDIO_STOPPED';
  const SDL_AUDIO_PLAYING: SDL_audiostatus = 'SDL_AUDIO_PLAYING';
  
  //PROCEDURES
  proc SDL_AudioQuit: 1;
  proc SDL_CloseAudio: 1;
  proc SDL_FreeWAV: ptr[uint8];
  proc SDL_LockAudio: 1;
  proc SDL_MixAudio: ptr[uint8] * cptr[uint8] * uint32 * int;
  proc SDL_PauseAudio: int;
  proc SDL_UnlockAudio: 1;
  
  //FUNCTIONS
  fun SDL_AudioDriverName: ptr[char] * int -> ptr[char];
  fun SDL_AudioInit: cptr[char] -> int;
  fun SDL_BuildAudioCVT: ptr[SDL_AudioCVT] * uint16 * uint8 * int * uint16 * uint8 * int -> int;
  fun SDL_ConvertAudio: ptr[SDL_AudioCVT] -> int;
  fun SDL_GetAudioStatus: 1 -> SDL_audiostatus;
  fun SDL_LoadWAV_RW: ptr[SDL_RWops] * int * ptr[SDL_AudioSpec] * ptr[ptr[uint8]] * ptr[uint32] -> ptr[SDL_AudioSpec];
  fun SDL_OpenAudio: ptr[SDL_AudioSpec] * ptr[SDL_AudioSpec] -> int;
  fun SDL_LoadWAV: cptr[char] * ptr[SDL_AudioSpec] * ptr[ptr[uint8]] * ptr[uint32] -> ptr[SDL_AudioSpec];
}

@h=tangler('lib/SDL/SDL_cdrom.flx')
@select(h)
//Module        : SDL_cdrom_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_cdrom.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define MSF_TO_FRAMES(M, S, F)        ((M)*60*CD_FPS+(S)*CD_FPS+(F))
//#define FRAMES_TO_MSF(f, M,S,F)       {                                       \
//#define CD_FPS        75
//#define CD_INDRIVE(status)    ((int)status > 0)
//#define SDL_DATA_TRACK        0x04
//#define SDL_AUDIO_TRACK       0x00
//#define SDL_MAX_TRACKS        99
//#define _SDL_cdrom_h

module SDL_cdrom_h
{
  requires package "sdl";
  header '#include "SDL_cdrom.h"';
  open C_hack;
  
  //ABSTRACT TYPES
  type CDstatus = 'CDstatus';
  
  //CSTRUCTS 
  cstruct SDL_CD {
    id: int;
    status: CDstatus;
    numtracks: int;
    cur_track: int;
    cur_frame: int;
    track: ptr[SDL_CDtrack];
  }
  cstruct SDL_CDtrack {
    id: uint8;
    type_: uint8;
    unused: uint16;
    length: uint32;
    offset: uint32;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  /*
  //TYPE ALIASES
  typedef _struct_SDL_CD = SDL_CD;
  typedef _struct_SDL_CDtrack = SDL_CDtrack;
  */
  
  //ENUMERATION CONSTANTS
  const CD_TRAYEMPTY: int = 'CD_TRAYEMPTY';
  const CD_PLAYING: int = 'CD_PLAYING';
  const CD_ERROR: int = 'CD_ERROR';
  const CD_PAUSED: int = 'CD_PAUSED';
  const CD_STOPPED: int = 'CD_STOPPED';
  
  //PROCEDURES
  proc SDL_CDClose: ptr[SDL_CD];
  
  //FUNCTIONS
  fun SDL_CDEject: ptr[SDL_CD] -> int;
  fun SDL_CDName: int -> cptr[char];
  fun SDL_CDNumDrives: 1 -> int;
  fun SDL_CDOpen: int -> ptr[SDL_CD];
  fun SDL_CDPause: ptr[SDL_CD] -> int;
  fun SDL_CDPlay: ptr[SDL_CD] * int * int -> int;
  fun SDL_CDPlayTracks: ptr[SDL_CD] * int * int * int * int -> int;
  fun SDL_CDResume: ptr[SDL_CD] -> int;
  fun SDL_CDStatus: ptr[SDL_CD] -> CDstatus;
  fun SDL_CDStop: ptr[SDL_CD] -> int;
}
@h=tangler('lib/SDL/SDL_error.flx')
@select(h)
//Module        : SDL_error_h
//Timestamp     : 2006/1/6 2:1:27 UTC
//Timestamp     : 2006/1/6 13:1:27 (local)
//Raw Header    : SDL_error.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_OutOfMemory()     SDL_Error(SDL_ENOMEM)
//#define _SDL_error_h

module SDL_error_h
{
  requires package "sdl";
  header '#include "SDL_error.h"';
  open C_hack;
  
  //ABSTRACT TYPES
  type SDL_errorcode = 'SDL_errorcode';
  
  //ENUMERATION CONSTANTS
  const SDL_EFSEEK: int = 'SDL_EFSEEK';
  const SDL_ENOMEM: int = 'SDL_ENOMEM';
  const SDL_LASTERROR: int = 'SDL_LASTERROR';
  const SDL_EFREAD: int = 'SDL_EFREAD';
  const SDL_EFWRITE: int = 'SDL_EFWRITE';
  
  //PROCEDURES
  proc SDL_ClearError: 1;
  proc SDL_Error: SDL_errorcode;
  proc SDL_SetError[t]: t;
  
  //FUNCTIONS
  fun SDL_GetError: 1 -> ptr[char];
}
@h=tangler('lib/SDL/SDL_events.flx')
@select(h)
//Module        : SDL_events_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_events.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_ENABLE     1
//#define SDL_DISABLE    0
//#define SDL_IGNORE     0
//#define SDL_QUERY     -1
//#define SDL_ALLEVENTS         0xFFFFFFFF
//#define SDL_EVENTMASK(X)      (1<<(X))
//#define _SDL_events_h

//INCLUDES
include"SDL/SDL_keyboard";

module SDL_events_h
{
  requires package "sdl";
  header '#include "SDL_events.h"';
  open C_hack;
  open SDL_keyboard_h;
  
  //ABSTRACT TYPES
  type SDL_eventaction = 'SDL_eventaction';
  
  //CSTRUCTS 
  cstruct SDL_SysWMEvent {
    type_: uint8;
    msg: ptr[SDL_SysWMmsg];
  }
  cstruct SDL_ResizeEvent {
    type_: uint8;
    w: int;
    h: int;
  }
  cstruct SDL_KeyboardEvent {
    type_: uint8;
    which: uint8;
    state: uint8;
    keysym: SDL_keysym;
  }
  cstruct SDL_JoyBallEvent {
    type_: uint8;
    which: uint8;
    ball: uint8;
    xrel: int16;
    yrel: int16;
  }
  cstruct SDL_JoyHatEvent {
    type_: uint8;
    which: uint8;
    hat: uint8;
    value: uint8;
  }
  cstruct SDL_ExposeEvent {
    type_: uint8;
  }
  cstruct SDL_MouseButtonEvent {
    type_: uint8;
    which: uint8;
    button: uint8;
    state: uint8;
    x: uint16;
    y: uint16;
  }
  cstruct SDL_MouseMotionEvent {
    type_: uint8;
    which: uint8;
    state: uint8;
    x: uint16;
    y: uint16;
    xrel: int16;
    yrel: int16;
  }
  cstruct SDL_JoyButtonEvent {
    type_: uint8;
    which: uint8;
    button: uint8;
    state: uint8;
  }
  cstruct SDL_QuitEvent {
    type_: uint8;
  }
  cstruct SDL_JoyAxisEvent {
    type_: uint8;
    which: uint8;
    axis: uint8;
    value: int16;
  }
  cstruct SDL_UserEvent {
    type_: uint8;
    code_: int;
    data1: address;
    data2: address;
  }
  cstruct SDL_ActiveEvent {
    type_: uint8;
    gain: uint8;
    state: uint8;
  }

  // This is ACTUALLY a C union .. but the syntax is the same
  // as for a struct .. so we can model it with a struct
  cstruct SDL_Event = {
    //type_ : uint8; // type is a keyword ..
    active : SDL_ActiveEvent;
    key : SDL_KeyboardEvent;
    motion: SDL_MouseMotionEvent;
    button: SDL_MouseButtonEvent;
    jaxis : SDL_JoyAxisEvent;
    jball : SDL_JoyBallEvent;
    jhat : SDL_JoyHatEvent;
    jbutton : SDL_JoyButtonEvent;
    resize : SDL_ResizeEvent;
    expose : SDL_ExposeEvent;
    quit: SDL_QuitEvent;
    user : SDL_UserEvent;
    syswm : SDL_SysWMEvent;
  }
 
  // use name type_ instead of type ..
  fun get_type_:SDL_Event -> uint8 = "$1.type";
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_events_h_cft_1)(SDL_Event const *);''';
  type SDL_events_h_cft_1 = 'SDL_events_h_cft_1';
  
  //PURE INCOMPLETE TYPES
  type _struct_SDL_SysWMmsg = 'struct SDL_SysWMmsg'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_SysWMmsg = _struct_SDL_SysWMmsg;
  
  typedef SDL_EventMasks = int;
  typedef SDL_EventFilter = SDL_events_h_cft_1;
  typedef SDL_Events = int;
  
  // Weird
  const SDL_PEEKEVENT: uint8 = 'SDL_PEEKEVENT';
  const SDL_GETEVENT: uint8 = 'SDL_GETEVENT';
  const SDL_ADDEVENT: uint8 = 'SDL_ADDEVENT';
  const SDL_NUMEVENTS: uint8 = 'SDL_NUMEVENTS';
  
  //EVENTS
  const SDL_MOUSEBUTTONUP: uint8 = 'SDL_MOUSEBUTTONUP';
  const SDL_MOUSEBUTTONDOWN: uint8 = 'SDL_MOUSEBUTTONDOWN';
  const SDL_KEYUP: uint8 = 'SDL_KEYUP';
  const SDL_JOYBALLMOTION: uint8 = 'SDL_JOYBALLMOTION';
  const SDL_NOEVENT: uint8 = 'SDL_NOEVENT';
  const SDL_JOYAXISMOTION: uint8 = 'SDL_JOYAXISMOTION';
  const SDL_QUIT: uint8 = 'SDL_QUIT';
  const SDL_VIDEORESIZE: uint8 = 'SDL_VIDEORESIZE';
  const SDL_JOYBUTTONDOWN: uint8 = 'SDL_JOYBUTTONDOWN';
  const SDL_KEYDOWN: uint8 = 'SDL_KEYDOWN';
  const SDL_JOYBUTTONUP: uint8 = 'SDL_JOYBUTTONUP';
  const SDL_SYSWMEVENT: uint8 = 'SDL_SYSWMEVENT';
  const SDL_USEREVENT: uint8 = 'SDL_USEREVENT';
  const SDL_JOYHATMOTION: uint8 = 'SDL_JOYHATMOTION';
  const SDL_ACTIVEEVENT: uint8 = 'SDL_ACTIVEEVENT';
  const SDL_VIDEOEXPOSE: uint8 = 'SDL_VIDEOEXPOSE';
  const SDL_MOUSEMOTION: uint8 = 'SDL_MOUSEMOTION';

  // reserved
  const SDL_EVENT_RESERVED2: uint8 = 'SDL_EVENT_RESERVED2';
  const SDL_EVENT_RESERVED3: uint8 = 'SDL_EVENT_RESERVED3';
  const SDL_EVENT_RESERVED4: uint8 = 'SDL_EVENT_RESERVED4';
  const SDL_EVENT_RESERVED5: uint8 = 'SDL_EVENT_RESERVED5';
  const SDL_EVENT_RESERVED6: uint8 = 'SDL_EVENT_RESERVED6';
  const SDL_EVENT_RESERVED7: uint8 = 'SDL_EVENT_RESERVED7';
  const SDL_EVENT_RESERVEDA: uint8 = 'SDL_EVENT_RESERVEDA';
  const SDL_EVENT_RESERVEDB: uint8 = 'SDL_EVENT_RESERVEDB';

  // MASKS
  // Joystick
  const SDL_JOYBUTTONDOWNMASK: uint8 = 'SDL_JOYBUTTONDOWNMASK';
  const SDL_JOYBUTTONUPMASK: uint8 = 'SDL_JOYBUTTONUPMASK';
  const SDL_JOYHATMOTIONMASK: uint8 = 'SDL_JOYHATMOTIONMASK';
  const SDL_JOYAXISMOTIONMASK: uint8 = 'SDL_JOYAXISMOTIONMASK';
  const SDL_JOYBALLMOTIONMASK: uint8 = 'SDL_JOYBALLMOTIONMASK';
  const SDL_JOYEVENTMASK: uint8 = 'SDL_JOYEVENTMASK';

  // mouse
  const SDL_MOUSEMOTIONMASK: uint8 = 'SDL_MOUSEMOTIONMASK';
  const SDL_MOUSEEVENTMASK: uint8 = 'SDL_MOUSEEVENTMASK';
  const SDL_MOUSEBUTTONUPMASK: uint8 = 'SDL_MOUSEBUTTONUPMASK';
  const SDL_MOUSEBUTTONDOWNMASK: uint8 = 'SDL_MOUSEBUTTONDOWNMASK';

  // video
  const SDL_VIDEORESIZEMASK: uint8 = 'SDL_VIDEORESIZEMASK';
  const SDL_ACTIVEEVENTMASK: uint8 = 'SDL_ACTIVEEVENTMASK';
  const SDL_SYSWMEVENTMASK: uint8 = 'SDL_SYSWMEVENTMASK';
  const SDL_VIDEOEXPOSEMASK: uint8 = 'SDL_VIDEOEXPOSEMASK';

  // keyboard
  const SDL_KEYDOWNMASK: uint8 = 'SDL_KEYDOWNMASK';
  const SDL_KEYUPMASK: uint8 = 'SDL_KEYUPMASK';
  const SDL_QUITMASK: uint8 = 'SDL_QUITMASK';
 
  //PROCEDURES
  proc SDL_PumpEvents: 1;
  proc SDL_SetEventFilter: SDL_events_h_cft_1;
  
  //FUNCTIONS
  fun SDL_EventState: uint8 * int -> uint8;
  fun SDL_GetEventFilter: 1 -> SDL_EventFilter;
  fun SDL_PeepEvents: ptr[SDL_Event] * int * SDL_eventaction * uint32 -> int;
  fun SDL_PollEvent: ptr[SDL_Event] -> int;
  fun SDL_PushEvent: ptr[SDL_Event] -> int;
  fun SDL_WaitEvent: ptr[SDL_Event] -> int;
}
@h=tangler('lib/SDL/SDL_joystick.flx')
@select(h)
//Module        : SDL_joystick_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_joystick.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_HAT_LEFTDOWN      (SDL_HAT_LEFT|SDL_HAT_DOWN)
//#define SDL_HAT_LEFTUP                (SDL_HAT_LEFT|SDL_HAT_UP)
//#define SDL_HAT_RIGHTDOWN     (SDL_HAT_RIGHT|SDL_HAT_DOWN)
//#define SDL_HAT_RIGHTUP               (SDL_HAT_RIGHT|SDL_HAT_UP)
//#define SDL_HAT_LEFT          0x08
//#define SDL_HAT_DOWN          0x04
//#define SDL_HAT_RIGHT         0x02
//#define SDL_HAT_UP            0x01
//#define SDL_HAT_CENTERED      0x00
//#define _SDL_joystick_h

module SDL_joystick_h
{
  requires package "sdl";
  header '#include "SDL_joystick.h"';
  open C_hack;
  
  //PURE INCOMPLETE TYPES
  type _struct__SDL_Joystick = 'struct _SDL_Joystick'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_Joystick = _struct__SDL_Joystick;
  
  //PROCEDURES
  proc SDL_JoystickClose: ptr[SDL_Joystick];
  proc SDL_JoystickUpdate: 1;
  
  //FUNCTIONS
  fun SDL_JoystickEventState: int -> int;
  fun SDL_JoystickGetAxis: ptr[SDL_Joystick] * int -> int16;
  fun SDL_JoystickGetBall: ptr[SDL_Joystick] * int * ptr[int] * ptr[int] -> int;
  fun SDL_JoystickGetButton: ptr[SDL_Joystick] * int -> uint8;
  fun SDL_JoystickGetHat: ptr[SDL_Joystick] * int -> uint8;
  fun SDL_JoystickIndex: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickName: int -> cptr[char];
  fun SDL_JoystickNumAxes: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumBalls: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumButtons: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumHats: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickOpen: int -> ptr[SDL_Joystick];
  fun SDL_JoystickOpened: int -> int;
  fun SDL_NumJoysticks: 1 -> int;
}
@h=tangler('lib/SDL/SDL_keyboard.flx')
@select(h)
//Module        : SDL_keyboard_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_keyboard.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_DEFAULT_REPEAT_INTERVAL   30
//#define SDL_DEFAULT_REPEAT_DELAY      500
//#define SDL_ALL_HOTKEYS               0xFFFFFFFF
//#define _SDL_keyboard_h

//INCLUDES
include"SDL/SDL_keysym";

module SDL_keyboard_h
{
  requires package "sdl";
  header '#include "SDL_keyboard.h"';
  open C_hack;
  open SDL_keysym_h;
  
  //CSTRUCTS 
  cstruct SDL_keysym {
    scancode: uint8;
    sym: SDLKey;
    mod: SDLMod;
    unicode: uint16;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  /*
  //TYPE ALIASES
  typedef _struct_SDL_keysym = SDL_keysym;
  */

  //PROCEDURES
  proc SDL_SetModState: SDLMod;
  
  //FUNCTIONS
  fun SDL_EnableKeyRepeat: int * int -> int;
  fun SDL_EnableUNICODE: int -> int;
  fun SDL_GetKeyName: SDLKey -> ptr[char];
  fun SDL_GetKeyState: ptr[int] -> ptr[uint8];
  fun SDL_GetModState: 1 -> SDLMod;
}
@h=tangler('lib/SDL/SDL_keysym.flx')
@select(h)
//Module        : SDL_keysym_h
//Timestamp     : 2006/1/6 2:1:27 UTC
//Timestamp     : 2006/1/6 13:1:27 (local)
//Raw Header    : SDL_keysym.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define KMOD_META     (KMOD_LMETA|KMOD_RMETA)
//#define KMOD_ALT      (KMOD_LALT|KMOD_RALT)
//#define KMOD_SHIFT    (KMOD_LSHIFT|KMOD_RSHIFT)
//#define KMOD_CTRL     (KMOD_LCTRL|KMOD_RCTRL)
//#define _SDL_keysym_h

module SDL_keysym_h
{
  requires package "sdl";
  header '#include "SDL_keysym.h"';
  open C_hack;
  
  //ABSTRACT TYPES
  type SDLKey = 'SDLKey';
  type SDLMod = 'SDLMod';
  
  //ENUMERATION CONSTANTS
  const SDLK_WORLD_1: SDLKey = 'SDLK_WORLD_1';
  const SDLK_POWER: SDLKey = 'SDLK_POWER';
  const SDLK_SLASH: SDLKey = 'SDLK_SLASH';
  const SDLK_WORLD_2: SDLKey = 'SDLK_WORLD_2';
  const SDLK_WORLD_3: SDLKey = 'SDLK_WORLD_3';
  const SDLK_F1: SDLKey = 'SDLK_F1';
  const SDLK_WORLD_4: SDLKey = 'SDLK_WORLD_4';
  const SDLK_WORLD_20: SDLKey = 'SDLK_WORLD_20';
  const SDLK_F2: SDLKey = 'SDLK_F2';
  const SDLK_WORLD_5: SDLKey = 'SDLK_WORLD_5';
  const SDLK_WORLD_21: SDLKey = 'SDLK_WORLD_21';
  const SDLK_F3: SDLKey = 'SDLK_F3';
  const SDLK_KP_EQUALS: SDLKey = 'SDLK_KP_EQUALS';
  const SDLK_WORLD_6: SDLKey = 'SDLK_WORLD_6';
  const SDLK_LEFT: SDLKey = 'SDLK_LEFT';
  const SDLK_WORLD_22: SDLKey = 'SDLK_WORLD_22';
  const SDLK_F4: SDLKey = 'SDLK_F4';
  const SDLK_WORLD_7: SDLKey = 'SDLK_WORLD_7';
  const SDLK_WORLD_23: SDLKey = 'SDLK_WORLD_23';
  const SDLK_UNDO: SDLKey = 'SDLK_UNDO';
  const SDLK_F5: SDLKey = 'SDLK_F5';
  const SDLK_WORLD_8: SDLKey = 'SDLK_WORLD_8';
  const SDLK_WORLD_24: SDLKey = 'SDLK_WORLD_24';
  const SDLK_F6: SDLKey = 'SDLK_F6';
  const SDLK_WORLD_9: SDLKey = 'SDLK_WORLD_9';
  const SDLK_WORLD_25: SDLKey = 'SDLK_WORLD_25';
  const SDLK_F7: SDLKey = 'SDLK_F7';
  const SDLK_WORLD_26: SDLKey = 'SDLK_WORLD_26';
  const SDLK_F8: SDLKey = 'SDLK_F8';
  const SDLK_WORLD_27: SDLKey = 'SDLK_WORLD_27';
  const SDLK_F9: SDLKey = 'SDLK_F9';
  const SDLK_LEFTPAREN: SDLKey = 'SDLK_LEFTPAREN';
  const SDLK_WORLD_28: SDLKey = 'SDLK_WORLD_28';
  const SDLK_WORLD_29: SDLKey = 'SDLK_WORLD_29';
  const SDLK_KP_ENTER: SDLKey = 'SDLK_KP_ENTER';
  const SDLK_CAPSLOCK: SDLKey = 'SDLK_CAPSLOCK';
  const SDLK_WORLD_30: SDLKey = 'SDLK_WORLD_30';
  const SDLK_WORLD_31: SDLKey = 'SDLK_WORLD_31';
  const SDLK_COMMA: SDLKey = 'SDLK_COMMA';
  const SDLK_WORLD_32: SDLKey = 'SDLK_WORLD_32';
  const SDLK_HASH: SDLKey = 'SDLK_HASH';
  const SDLK_SPACE: SDLKey = 'SDLK_SPACE';
  const SDLK_WORLD_33: SDLKey = 'SDLK_WORLD_33';
  const SDLK_WORLD_34: SDLKey = 'SDLK_WORLD_34';
  const SDLK_WORLD_35: SDLKey = 'SDLK_WORLD_35';
  const SDLK_PLUS: SDLKey = 'SDLK_PLUS';
  const SDLK_WORLD_36: SDLKey = 'SDLK_WORLD_36';
  const SDLK_WORLD_37: SDLKey = 'SDLK_WORLD_37';
  const SDLK_WORLD_38: SDLKey = 'SDLK_WORLD_38';
  const SDLK_KP_PERIOD: SDLKey = 'SDLK_KP_PERIOD';
  const SDLK_PAUSE: SDLKey = 'SDLK_PAUSE';
  const SDLK_WORLD_39: SDLKey = 'SDLK_WORLD_39';
  const SDLK_KP_MINUS: SDLKey = 'SDLK_KP_MINUS';
  const KMOD_LALT: SDLKey = 'KMOD_LALT';
  const SDLK_TAB: SDLKey = 'SDLK_TAB';
  const SDLK_0: SDLKey = 'SDLK_0';
  const SDLK_COMPOSE: SDLKey = 'SDLK_COMPOSE';
  const SDLK_1: SDLKey = 'SDLK_1';
  const SDLK_2: SDLKey = 'SDLK_2';
  const SDLK_LALT: SDLKey = 'SDLK_LALT';
  const SDLK_3: SDLKey = 'SDLK_3';
  const SDLK_WORLD_40: SDLKey = 'SDLK_WORLD_40';
  const SDLK_4: SDLKey = 'SDLK_4';
  const SDLK_WORLD_41: SDLKey = 'SDLK_WORLD_41';
  const SDLK_5: SDLKey = 'SDLK_5';
  const SDLK_RCTRL: SDLKey = 'SDLK_RCTRL';
  const SDLK_WORLD_42: SDLKey = 'SDLK_WORLD_42';
  const SDLK_6: SDLKey = 'SDLK_6';
  const KMOD_RALT: SDLKey = 'KMOD_RALT';
  const SDLK_WORLD_43: SDLKey = 'SDLK_WORLD_43';
  const SDLK_7: SDLKey = 'SDLK_7';
  const SDLK_WORLD_44: SDLKey = 'SDLK_WORLD_44';
  const SDLK_8: SDLKey = 'SDLK_8';
  const SDLK_WORLD_45: SDLKey = 'SDLK_WORLD_45';
  const SDLK_9: SDLKey = 'SDLK_9';
  const SDLK_ESCAPE: SDLKey = 'SDLK_ESCAPE';
  const SDLK_WORLD_46: SDLKey = 'SDLK_WORLD_46';
  const SDLK_WORLD_47: SDLKey = 'SDLK_WORLD_47';
  const SDLK_BACKQUOTE: SDLKey = 'SDLK_BACKQUOTE';
  const SDLK_RALT: SDLKey = 'SDLK_RALT';
  const SDLK_WORLD_48: SDLKey = 'SDLK_WORLD_48';
  const SDLK_CARET: SDLKey = 'SDLK_CARET';
  const SDLK_WORLD_49: SDLKey = 'SDLK_WORLD_49';
  const SDLK_RIGHT: SDLKey = 'SDLK_RIGHT';
  const SDLK_DELETE: SDLKey = 'SDLK_DELETE';
  const SDLK_RSHIFT: SDLKey = 'SDLK_RSHIFT';
  const SDLK_LESS: SDLKey = 'SDLK_LESS';
  const SDLK_AMPERSAND: SDLKey = 'SDLK_AMPERSAND';
  const SDLK_BACKSLASH: SDLKey = 'SDLK_BACKSLASH';
  const SDLK_WORLD_50: SDLKey = 'SDLK_WORLD_50';
  const SDLK_WORLD_51: SDLKey = 'SDLK_WORLD_51';
  const KMOD_LSHIFT: SDLKey = 'KMOD_LSHIFT';
  const SDLK_WORLD_52: SDLKey = 'SDLK_WORLD_52';
  const SDLK_WORLD_53: SDLKey = 'SDLK_WORLD_53';
  const SDLK_WORLD_54: SDLKey = 'SDLK_WORLD_54';
  const SDLK_RMETA: SDLKey = 'SDLK_RMETA';
  const SDLK_WORLD_55: SDLKey = 'SDLK_WORLD_55';
  const SDLK_WORLD_56: SDLKey = 'SDLK_WORLD_56';
  const SDLK_LCTRL: SDLKey = 'SDLK_LCTRL';
  const SDLK_WORLD_57: SDLKey = 'SDLK_WORLD_57';
  const SDLK_WORLD_58: SDLKey = 'SDLK_WORLD_58';
  const SDLK_WORLD_59: SDLKey = 'SDLK_WORLD_59';
  const SDLK_RETURN: SDLKey = 'SDLK_RETURN';
  const SDLK_QUESTION: SDLKey = 'SDLK_QUESTION';
  const SDLK_BREAK: SDLKey = 'SDLK_BREAK';
  const SDLK_RSUPER: SDLKey = 'SDLK_RSUPER';
  const SDLK_WORLD_60: SDLKey = 'SDLK_WORLD_60';
  const SDLK_WORLD_61: SDLKey = 'SDLK_WORLD_61';
  const KMOD_MODE: SDLKey = 'KMOD_MODE';
  const SDLK_WORLD_62: SDLKey = 'SDLK_WORLD_62';
  const SDLK_UNDERSCORE: SDLKey = 'SDLK_UNDERSCORE';
  const SDLK_WORLD_63: SDLKey = 'SDLK_WORLD_63';
  const SDLK_UNKNOWN: SDLKey = 'SDLK_UNKNOWN';
  const SDLK_WORLD_64: SDLKey = 'SDLK_WORLD_64';
  const SDLK_BACKSPACE: SDLKey = 'SDLK_BACKSPACE';
  const SDLK_WORLD_65: SDLKey = 'SDLK_WORLD_65';
  const SDLK_EQUALS: SDLKey = 'SDLK_EQUALS';
  const SDLK_WORLD_66: SDLKey = 'SDLK_WORLD_66';
  const SDLK_PAGEDOWN: SDLKey = 'SDLK_PAGEDOWN';
  const SDLK_MODE: SDLKey = 'SDLK_MODE';
  const SDLK_WORLD_67: SDLKey = 'SDLK_WORLD_67';
  const SDLK_a: SDLKey = 'SDLK_a';
  const SDLK_WORLD_68: SDLKey = 'SDLK_WORLD_68';
  const SDLK_HOME: SDLKey = 'SDLK_HOME';
  const SDLK_b: SDLKey = 'SDLK_b';
  const SDLK_WORLD_69: SDLKey = 'SDLK_WORLD_69';
  const SDLK_c: SDLKey = 'SDLK_c';
  const SDLK_LMETA: SDLKey = 'SDLK_LMETA';
  const SDLK_d: SDLKey = 'SDLK_d';
  const SDLK_e: SDLKey = 'SDLK_e';
  const SDLK_RIGHTBRACKET: SDLKey = 'SDLK_RIGHTBRACKET';
  const SDLK_f: SDLKey = 'SDLK_f';
  const SDLK_g: SDLKey = 'SDLK_g';
  const SDLK_h: SDLKey = 'SDLK_h';
  const SDLK_i: SDLKey = 'SDLK_i';
  const SDLK_j: SDLKey = 'SDLK_j';
  const SDLK_k: SDLKey = 'SDLK_k';
  const SDLK_PRINT: SDLKey = 'SDLK_PRINT';
  const SDLK_l: SDLKey = 'SDLK_l';
  const SDLK_m: SDLKey = 'SDLK_m';
  const SDLK_WORLD_70: SDLKey = 'SDLK_WORLD_70';
  const SDLK_n: SDLKey = 'SDLK_n';
  const SDLK_WORLD_71: SDLKey = 'SDLK_WORLD_71';
  const SDLK_o: SDLKey = 'SDLK_o';
  const SDLK_WORLD_72: SDLKey = 'SDLK_WORLD_72';
  const SDLK_p: SDLKey = 'SDLK_p';
  const SDLK_WORLD_73: SDLKey = 'SDLK_WORLD_73';
  const SDLK_q: SDLKey = 'SDLK_q';
  const SDLK_WORLD_74: SDLKey = 'SDLK_WORLD_74';
  const SDLK_r: SDLKey = 'SDLK_r';
  const SDLK_COLON: SDLKey = 'SDLK_COLON';
  const SDLK_WORLD_75: SDLKey = 'SDLK_WORLD_75';
  const SDLK_s: SDLKey = 'SDLK_s';
  const SDLK_WORLD_76: SDLKey = 'SDLK_WORLD_76';
  const SDLK_t: SDLKey = 'SDLK_t';
  const SDLK_WORLD_77: SDLKey = 'SDLK_WORLD_77';
  const SDLK_u: SDLKey = 'SDLK_u';
  const SDLK_WORLD_78: SDLKey = 'SDLK_WORLD_78';
  const SDLK_v: SDLKey = 'SDLK_v';
  const SDLK_WORLD_79: SDLKey = 'SDLK_WORLD_79';
  const SDLK_w: SDLKey = 'SDLK_w';
  const SDLK_x: SDLKey = 'SDLK_x';
  const SDLK_PERIOD: SDLKey = 'SDLK_PERIOD';
  const SDLK_SEMICOLON: SDLKey = 'SDLK_SEMICOLON';
  const KMOD_NONE: SDLKey = 'KMOD_NONE';
  const SDLK_y: SDLKey = 'SDLK_y';
  const SDLK_EURO: SDLKey = 'SDLK_EURO';
  const SDLK_z: SDLKey = 'SDLK_z';
  const SDLK_SYSREQ: SDLKey = 'SDLK_SYSREQ';
  const SDLK_GREATER: SDLKey = 'SDLK_GREATER';
  const SDLK_DOLLAR: SDLKey = 'SDLK_DOLLAR';
  const SDLK_WORLD_80: SDLKey = 'SDLK_WORLD_80';
  const SDLK_WORLD_81: SDLKey = 'SDLK_WORLD_81';
  const SDLK_WORLD_82: SDLKey = 'SDLK_WORLD_82';
  const SDLK_F10: SDLKey = 'SDLK_F10';
  const SDLK_WORLD_83: SDLKey = 'SDLK_WORLD_83';
  const SDLK_F11: SDLKey = 'SDLK_F11';
  const SDLK_WORLD_84: SDLKey = 'SDLK_WORLD_84';
  const SDLK_LSHIFT: SDLKey = 'SDLK_LSHIFT';
  const SDLK_F12: SDLKey = 'SDLK_F12';
  const SDLK_WORLD_85: SDLKey = 'SDLK_WORLD_85';
  const SDLK_F13: SDLKey = 'SDLK_F13';
  const SDLK_PAGEUP: SDLKey = 'SDLK_PAGEUP';
  const SDLK_WORLD_86: SDLKey = 'SDLK_WORLD_86';
  const SDLK_F14: SDLKey = 'SDLK_F14';
  const SDLK_UP: SDLKey = 'SDLK_UP';
  const SDLK_WORLD_87: SDLKey = 'SDLK_WORLD_87';
  const KMOD_RCTRL: SDLKey = 'KMOD_RCTRL';
  const SDLK_F15: SDLKey = 'SDLK_F15';
  const SDLK_WORLD_88: SDLKey = 'SDLK_WORLD_88';
  const SDLK_WORLD_89: SDLKey = 'SDLK_WORLD_89';
  const SDLK_KP_MULTIPLY: SDLKey = 'SDLK_KP_MULTIPLY';
  const SDLK_END: SDLKey = 'SDLK_END';
  const SDLK_WORLD_90: SDLKey = 'SDLK_WORLD_90';
  const SDLK_CLEAR: SDLKey = 'SDLK_CLEAR';
  const SDLK_WORLD_91: SDLKey = 'SDLK_WORLD_91';
  const SDLK_AT: SDLKey = 'SDLK_AT';
  const SDLK_WORLD_92: SDLKey = 'SDLK_WORLD_92';
  const SDLK_WORLD_93: SDLKey = 'SDLK_WORLD_93';
  const SDLK_KP_DIVIDE: SDLKey = 'SDLK_KP_DIVIDE';
  const SDLK_WORLD_94: SDLKey = 'SDLK_WORLD_94';
  const SDLK_WORLD_95: SDLKey = 'SDLK_WORLD_95';
  const SDLK_ASTERISK: SDLKey = 'SDLK_ASTERISK';
  const SDLK_LSUPER: SDLKey = 'SDLK_LSUPER';
  const KMOD_RESERVED: SDLKey = 'KMOD_RESERVED';
  const KMOD_RMETA: SDLKey = 'KMOD_RMETA';
  const KMOD_LCTRL: SDLKey = 'KMOD_LCTRL';
  const SDLK_DOWN: SDLKey = 'SDLK_DOWN';
  const SDLK_NUMLOCK: SDLKey = 'SDLK_NUMLOCK';
  const SDLK_EXCLAIM: SDLKey = 'SDLK_EXCLAIM';
  const KMOD_LMETA: SDLKey = 'KMOD_LMETA';
  const SDLK_LAST: SDLKey = 'SDLK_LAST';
  const SDLK_HELP: SDLKey = 'SDLK_HELP';
  const SDLK_KP0: SDLKey = 'SDLK_KP0';
  const SDLK_KP1: SDLKey = 'SDLK_KP1';
  const SDLK_KP2: SDLKey = 'SDLK_KP2';
  const SDLK_SCROLLOCK: SDLKey = 'SDLK_SCROLLOCK';
  const SDLK_KP3: SDLKey = 'SDLK_KP3';
  const SDLK_KP_PLUS: SDLKey = 'SDLK_KP_PLUS';
  const SDLK_INSERT: SDLKey = 'SDLK_INSERT';
  const SDLK_KP4: SDLKey = 'SDLK_KP4';
  const SDLK_WORLD_10: SDLKey = 'SDLK_WORLD_10';
  const SDLK_KP5: SDLKey = 'SDLK_KP5';
  const SDLK_WORLD_11: SDLKey = 'SDLK_WORLD_11';
  const SDLK_MINUS: SDLKey = 'SDLK_MINUS';
  const SDLK_KP6: SDLKey = 'SDLK_KP6';
  const SDLK_WORLD_12: SDLKey = 'SDLK_WORLD_12';
  const SDLK_LEFTBRACKET: SDLKey = 'SDLK_LEFTBRACKET';
  const SDLK_KP7: SDLKey = 'SDLK_KP7';
  const SDLK_WORLD_13: SDLKey = 'SDLK_WORLD_13';
  const SDLK_KP8: SDLKey = 'SDLK_KP8';
  const SDLK_WORLD_14: SDLKey = 'SDLK_WORLD_14';
  const SDLK_KP9: SDLKey = 'SDLK_KP9';
  const SDLK_RIGHTPAREN: SDLKey = 'SDLK_RIGHTPAREN';
  const SDLK_WORLD_15: SDLKey = 'SDLK_WORLD_15';
  const SDLK_WORLD_16: SDLKey = 'SDLK_WORLD_16';
  const SDLK_QUOTE: SDLKey = 'SDLK_QUOTE';
  const SDLK_FIRST: SDLKey = 'SDLK_FIRST';
  const SDLK_WORLD_17: SDLKey = 'SDLK_WORLD_17';
  const KMOD_NUM: SDLKey = 'KMOD_NUM';
  const SDLK_WORLD_18: SDLKey = 'SDLK_WORLD_18';
  const SDLK_WORLD_19: SDLKey = 'SDLK_WORLD_19';
  const SDLK_QUOTEDBL: SDLKey = 'SDLK_QUOTEDBL';
  const KMOD_RSHIFT: SDLKey = 'KMOD_RSHIFT';
  const SDLK_MENU: SDLKey = 'SDLK_MENU';
  const KMOD_CAPS: SDLKey = 'KMOD_CAPS';
  const SDLK_WORLD_0: SDLKey = 'SDLK_WORLD_0';

  fun eq: SDLKey * SDLKey -> bool = "$1==$2";
  fun ne: SDLKey * SDLKey -> bool = "$1!=$2";
}

@h=tangler('lib/SDL/SDL_mouse.flx')
@select(h)
//Module        : SDL_mouse_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_mouse.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_BUTTON_RMASK      SDL_BUTTON(SDL_BUTTON_RIGHT)
//#define SDL_BUTTON_MMASK      SDL_BUTTON(SDL_BUTTON_MIDDLE)
//#define SDL_BUTTON_LMASK      SDL_BUTTON(SDL_BUTTON_LEFT)
//#define SDL_BUTTON_WHEELDOWN  5
//#define SDL_BUTTON_WHEELUP    4
//#define SDL_BUTTON_RIGHT      3
//#define SDL_BUTTON_MIDDLE     2
//#define SDL_BUTTON_LEFT               1
//#define SDL_BUTTON(X)         (SDL_PRESSED<<(X-1))
//#define _SDL_mouse_h

//INCLUDES
include"SDL/SDL_video";

module SDL_mouse_h
{
  requires package "sdl";
  header '#include "SDL_mouse.h"';
  open C_hack;
  open SDL_video_h;
  
  //CSTRUCTS 
  cstruct SDL_Cursor {
    area: SDL_Rect;
    hot_x: int16;
    hot_y: int16;
    data: ptr[uint8];
    mask: ptr[uint8];
    save: ptr[ptr[uint8]];
    wm_cursor: ptr[WMcursor];
  }
  
  //PURE INCOMPLETE TYPES
  type _struct_WMcursor = 'struct WMcursor'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef WMcursor = _struct_WMcursor;
  
  /*
  //TYPE ALIASES
  typedef _struct_SDL_Cursor = SDL_Cursor;
  */
  
  //PROCEDURES
  proc SDL_FreeCursor: ptr[SDL_Cursor];
  proc SDL_SetCursor: ptr[SDL_Cursor];
  proc SDL_WarpMouse: uint16 * uint16;
  
  //FUNCTIONS
  fun SDL_CreateCursor: ptr[uint8] * ptr[uint8] * int * int * int * int -> ptr[SDL_Cursor];
  fun SDL_GetCursor: 1 -> ptr[SDL_Cursor];
  fun SDL_GetMouseState: ptr[int] * ptr[int] -> uint8;
  fun SDL_GetRelativeMouseState: ptr[int] * ptr[int] -> uint8;
  fun SDL_ShowCursor: int -> int;
}
@h=tangler('lib/SDL/SDL_mutex.flx')
@select(h)
//Module        : SDL_mutex_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_mutex.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_MUTEX_MAXWAIT     (~(Uint32)0)
//#define SDL_MUTEX_TIMEDOUT    1
//#define _SDL_mutex_h

// DO NOT USE THIS MODULE
// FELIX HAS ITS OWN THREAD HANDLING

module SDL_mutex_h
{
  requires package "sdl";
  header '#include "SDL_mutex.h"';
  open C_hack;
  
  incomplete ctypes SDL_mutex, SDL_cond, SDL_sem;
  
  //PROCEDURES
  proc SDL_DestroyCond: ptr[SDL_cond];
  proc SDL_DestroyMutex: ptr[SDL_mutex];
  proc SDL_DestroySemaphore: ptr[SDL_sem];
  
  //FUNCTIONS
  fun SDL_CondBroadcast: ptr[SDL_cond] -> int;
  fun SDL_CondSignal: ptr[SDL_cond] -> int;
  fun SDL_CondWait: ptr[SDL_cond] * ptr[SDL_mutex] -> int;
  fun SDL_CondWaitTimeout: ptr[SDL_cond] * ptr[SDL_mutex] * uint32 -> int;
  fun SDL_CreateCond: 1 -> ptr[SDL_cond];
  fun SDL_CreateMutex: 1 -> ptr[SDL_mutex];
  fun SDL_CreateSemaphore: uint32 -> ptr[SDL_sem];
  fun SDL_SemPost: ptr[SDL_sem] -> int;
  fun SDL_SemTryWait: ptr[SDL_sem] -> int;
  fun SDL_SemValue: ptr[SDL_sem] -> uint32;
  fun SDL_SemWait: ptr[SDL_sem] -> int;
  fun SDL_SemWaitTimeout: ptr[SDL_sem] * uint32 -> int;
  fun SDL_mutexP: ptr[SDL_mutex] -> int;
  fun SDL_mutexV: ptr[SDL_mutex] -> int;
  fun SDL_LockMutex: ptr[SDL_mutex] -> int;
  fun SDL_UnlockMutex: ptr[SDL_mutex] -> int;
}
@h=tangler('lib/SDL/SDL_rwops.flx')
@select(h)
//Module        : SDL_rwops_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_rwops.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_RWclose(ctx)              (ctx)->close(ctx)
//#define SDL_RWwrite(ctx, ptr, size, n)        (ctx)->write(ctx, ptr, size, n)
//#define SDL_RWread(ctx, ptr, size, n) (ctx)->read(ctx, ptr, size, n)
//#define SDL_RWtell(ctx)                       (ctx)->seek(ctx, 0, SEEK_CUR)
//#define SDL_RWseek(ctx, offset, whence)       (ctx)->seek(ctx, offset, whence)
//#define _SDL_RWops_h

//INCLUDES

module SDL_rwops_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type _struct_SDL_RWops = 'struct SDL_RWops';
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_rwops_h_cft_1)(struct SDL_RWops *,  int, int);''';
  type SDL_rwops_h_cft_1 = 'SDL_rwops_h_cft_1';
  header '''typedef int (*SDL_rwops_h_cft_3)(struct SDL_RWops *,  void const *,  int, int);''';
  type SDL_rwops_h_cft_3 = 'SDL_rwops_h_cft_3';
  header '''typedef int (*SDL_rwops_h_cft_2)(struct SDL_RWops *,  void *, int,  int);''';
  type SDL_rwops_h_cft_2 = 'SDL_rwops_h_cft_2';
  header '''typedef int (*SDL_rwops_h_cft_4)(struct SDL_RWops *);''';
  type SDL_rwops_h_cft_4 = 'SDL_rwops_h_cft_4';
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_RWops = _struct_SDL_RWops;
  
  //PROCEDURES
  proc SDL_FreeRW: ptr[SDL_RWops];
  
  //FUNCTIONS
  fun SDL_AllocRW: 1 -> ptr[SDL_RWops];
  fun SDL_RWFromConstMem: caddress * int -> ptr[SDL_RWops];
  fun SDL_RWFromFP: ptr[FILE] * int -> ptr[SDL_RWops];
  fun SDL_RWFromFile: cptr[char] * cptr[char] -> ptr[SDL_RWops];
  fun SDL_RWFromMem: address * int -> ptr[SDL_RWops];
  
  //STRUCT and UNION FIELDS
  fun get_read: _struct_SDL_RWops -> SDL_rwops_h_cft_2 = '$1->read';
  fun get_write: _struct_SDL_RWops -> SDL_rwops_h_cft_3 = '$1->write';
  fun get_seek: _struct_SDL_RWops -> SDL_rwops_h_cft_1 = '$1->seek';
  fun get_close: _struct_SDL_RWops -> SDL_rwops_h_cft_4 = '$1->close';
  fun get_type: _struct_SDL_RWops -> uint32 = '$1->type';
}
@h=tangler('lib/SDL/SDL_timer.flx')
@select(h)
//Module        : SDL_timer_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_timer.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define TIMER_RESOLUTION      10      /* Experimentally determined */
//#define SDL_TIMESLICE         10
//#define _SDL_timer_h

//INCLUDES
include"SDL/SDL_types";

module SDL_timer_h
{
  requires package "sdl";
  header '#include "SDL_timer.h"';
  open C_hack;
  open SDL_types_h;
  
  //C FUNCTION POINTER TYPES
  header '''typedef Uint32 (*SDL_timer_h_cft_2)(Uint32,  void *);''';
  type SDL_timer_h_cft_2 = 'SDL_timer_h_cft_2';
  header '''typedef Uint32 (*SDL_timer_h_cft_1)(Uint32);''';
  type SDL_timer_h_cft_1 = 'SDL_timer_h_cft_1';
  
  //PURE INCOMPLETE TYPES
  type _struct__SDL_TimerID = 'struct _SDL_TimerID'; //local
  
  //TYPE ALIASES
  typedef SDL_NewTimerCallback = SDL_timer_h_cft_2;
  typedef SDL_TimerID = ptr[_struct__SDL_TimerID];
  typedef SDL_TimerCallback = SDL_timer_h_cft_1;
  
  //PROCEDURES
  proc SDL_Delay: uint32;
  
  //FUNCTIONS
  fun SDL_AddTimer: uint32 * SDL_timer_h_cft_2 * address -> SDL_TimerID;
  fun SDL_GetTicks: 1 -> uint32;
  fun SDL_RemoveTimer: SDL_TimerID -> SDL_bool;
  fun SDL_SetTimer: uint32 * SDL_timer_h_cft_1 -> int;
  
  //CALLBACK TYPE WRAPPERS
  //callback type SDL_timer_h_cft_2, client data at 1
  typedef _fcbat_SDL_timer_h_cft_2 = uint32;
  export type (_fcbat_SDL_timer_h_cft_2) as "_fcbat_SDL_timer_h_cft_2";
  typedef _fcbt_SDL_timer_h_cft_2 = uint32 -> uint32; 
  export type (_fcbt_SDL_timer_h_cft_2) as "_fcbt_SDL_timer_h_cft_2";
  header '''Uint32 _fcbw_SDL_timer_h_cft_2(Uint32 a1,  void *a2);''';

  const _fcbw_SDL_timer_h_cft_2: SDL_timer_h_cft_2 = "_fcbw_SDL_timer_h_cft_2";
  body '''
  Uint32 _fcbw_SDL_timer_h_cft_2(Uint32 a1,  void *a2){
    return ((_fcbt_SDL_timer_h_cft_2)a2)->apply(a1);
  }''';

  
  //CALLBACK CLIENT WRAPPERS
  //callback client SDL_AddTimer, client data at 1, callback at 2
  fun wrapper_SDL_AddTimer(a1: uint32, a2: _fcbt_SDL_timer_h_cft_2): SDL_TimerID= {
    return SDL_AddTimer(a1, _fcbw_SDL_timer_h_cft_2, C_hack::cast[address]a2);
  }
}
@h=tangler('lib/SDL/SDL_types.flx')
@select(h)
//Module        : SDL_types_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_types.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_COMPILE_TIME_ASSERT(name, x)               \
//#define SDL_HAS_64BIT_TYPE    __int64
//#define SDL_HAS_64BIT_TYPE    long long
//#define SDL_HAS_64BIT_TYPE    long
//#define SDL_TABLESIZE(table)  (sizeof(table)/sizeof(table[0]))
//#define _SDL_types_h

module SDL_types_h
{
  requires package "sdl";
  header '#include "SDL_types.h"';
  open C_hack;
  
  //ABSTRACT TYPES
  type SDL_bool = 'SDL_bool';
  type SDL_DUMMY_ENUM = 'SDL_DUMMY_ENUM';
  
  //TYPE ALIASES
  typedef Sint64 = vlong;
  typedef SDL_dummy_uint32 = ptr[int];
  typedef SDL_dummy_sint64 = ptr[int];
  typedef SDL_dummy_sint16 = ptr[int];
  typedef SDL_dummy_sint8 = ptr[int];
  typedef SDL_dummy_sint32 = ptr[int];
  typedef SDL_dummy_uint8 = ptr[int];
  typedef Uint64 = uvlong;
  typedef SDL_dummy_uint64 = ptr[int];
  typedef SDL_dummy_uint16 = ptr[int];
  typedef SDL_dummy_enum = ptr[int];
  
  //ENUMERATION CONSTANTS
  const SDL_PRESSED: int = 'SDL_PRESSED';
  const DUMMY_ENUM_VALUE: int = 'DUMMY_ENUM_VALUE';
  const SDL_RELEASED: int = 'SDL_RELEASED';
  const SDL_TRUE: int = 'SDL_TRUE';
  const SDL_FALSE: int = 'SDL_FALSE';
}
@h=tangler('lib/SDL/SDL_version.flx')
@select(h)
//Module        : SDL_version_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_version.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_VERSION_ATLEAST(X, Y, Z) \
//#define SDL_COMPILEDVERSION \
//#define SDL_VERSIONNUM(X, Y, Z)                                               \
//#define SDL_VERSION(X)                                                        \
//#define SDL_PATCHLEVEL                8
//#define SDL_MINOR_VERSION     2
//#define SDL_MAJOR_VERSION     1
//#define _SDL_version_h

module SDL_version_h
{
  requires package "sdl";
  header '#include "SDL_version.h"';
  open C_hack;
  
  //CSTRUCTS 
  cstruct SDL_version {
    major: uint8;
    minor: uint8;
    patch: uint8;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_version = SDL_version;
  
  //FUNCTIONS
  fun SDL_Linked_Version: 1 -> cptr[SDL_version];
}
@h=tangler('lib/SDL/SDL_video.flx')
@select(h)
//Module        : SDL_video_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_video.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_BlitSurface SDL_UpperBlit
//#define SDL_SaveBMP(surface, file) \
//#define SDL_AllocSurface    SDL_CreateRGBSurface
//#define SDL_PHYSPAL 0x02
//#define SDL_LOGPAL 0x01
//#define SDL_YVYU_OVERLAY  0x55595659  /* Packed mode: Y0+V0+Y1+U0 (1 plane) */
//#define SDL_UYVY_OVERLAY  0x59565955  /* Packed mode: U0+Y0+V0+Y1 (1 plane) */
//#define SDL_YUY2_OVERLAY  0x32595559  /* Packed mode: Y0+U0+Y1+V0 (1 plane) */
//#define SDL_IYUV_OVERLAY  0x56555949  /* Planar mode: Y + U + V  (3 planes) */
//#define SDL_YV12_OVERLAY  0x32315659  /* Planar mode: Y + V + U  (3 planes) */
//#define SDL_PREALLOC  0x01000000      /* Surface uses preallocated memory */
//#define SDL_SRCALPHA  0x00010000      /* Blit uses source alpha blending */
//#define SDL_RLEACCEL  0x00004000      /* Surface is RLE encoded */
//#define SDL_RLEACCELOK        0x00002000      /* Private flag */
//#define SDL_SRCCOLORKEY       0x00001000      /* Blit uses a source color key */
//#define SDL_HWACCEL   0x00000100      /* Blit uses hardware acceleration */
//#define SDL_NOFRAME   0x00000020      /* No window caption or edge frame */
//#define SDL_RESIZABLE 0x00000010      /* This video mode may be resized */
//#define SDL_OPENGLBLIT        0x0000000A      /* Create an OpenGL rendering context and use it for blitting */
//#define SDL_OPENGL      0x00000002      /* Create an OpenGL rendering context */
//#define SDL_FULLSCREEN        0x80000000      /* Surface is a full screen display */
//#define SDL_DOUBLEBUF 0x40000000      /* Set up double-buffered video mode */
//#define SDL_HWPALETTE 0x20000000      /* Surface has exclusive palette */
//#define SDL_ANYFORMAT 0x10000000      /* Allow any video depth/pixel-format */
//#define SDL_ASYNCBLIT 0x00000004      /* Use asynchronous blits if possible */
//#define SDL_HWSURFACE 0x00000001      /* Surface is in video memory */
//#define SDL_SWSURFACE 0x00000000      /* Surface is in system memory */
//#define SDL_Colour SDL_Color
//#define SDL_ALPHA_TRANSPARENT 0
//#define SDL_ALPHA_OPAQUE 255
//#define _SDL_video_h

//INCLUDES
include"SDL/SDL_rwops";
include"SDL/SDL_types";

module SDL_video_h
{
  requires package "sdl";
  header '#include "SDL_video.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_types_h;
  
  fun SDL_MUSTLOCK: ptr[SDL_Surface] -> bool;
  const SDL_PHYSPAL : uint32;
  const SDL_LOGPAL : uint32;
  const SDL_YVYU_OVERLAY  : uint32;
  const SDL_UYVY_OVERLAY  : uint32;
  const SDL_YUY2_OVERLAY  : uint32;
  const SDL_IYUV_OVERLAY  : uint32;
  const SDL_YV12_OVERLAY  : uint32;
  const SDL_PREALLOC  : uint32;
  const SDL_SRCALPHA  : uint32;
  const SDL_RLEACCEL  : uint32;
  const SDL_RLEACCELOK        : uint32;
  const SDL_SRCCOLORKEY       : uint32;
  const SDL_HWACCEL   : uint32;
  const SDL_NOFRAME   : uint32;
  const SDL_RESIZABLE : uint32;
  const SDL_OPENGLBLIT        : uint32;
  const SDL_OPENGL      : uint32;
  const SDL_FULLSCREEN        : uint32;
  const SDL_DOUBLEBUF : uint32;
  const SDL_HWPALETTE : uint32;
  const SDL_ANYFORMAT : uint32;
  const SDL_ASYNCBLIT : uint32;
  const SDL_HWSURFACE : uint32;
  const SDL_SWSURFACE : uint32;

  //ABSTRACT TYPES
  type SDL_GrabMode = 'SDL_GrabMode';
  type SDL_GLattr = 'SDL_GLattr';
  
  //CSTRUCTS 
  cstruct SDL_Color {
    r: uint8;
    g: uint8;
    b: uint8;
    unused: uint8;
  }
  cstruct SDL_Surface {
    flags: uint32;
    format: ptr[SDL_PixelFormat];
    w: int;
    h: int;
    pitch: uint16;
    pixels: address;
    offset: int;
    hwdata: ptr[_struct_private_hwdata];
    clip_rect: SDL_Rect;
    unused1: uint32;
    locked: uint32;
    map: ptr[_struct_SDL_BlitMap];
    format_version: uint;
    refcount: int;
  }
  cstruct SDL_Overlay {
    format: uint32;
    w: int;
    h: int;
    planes: int;
    pitches: ptr[uint16];
    pixels: ptr[ptr[uint8]];
    hwfuncs: ptr[_struct_private_yuvhwfuncs];
    hwdata: ptr[_struct_private_yuvhwdata];
    hw_overlay: uint32;
    UnusedBits: uint32;
  }
  cstruct SDL_Palette {
    ncolors: int;
    colors: ptr[SDL_Color];
  }
  cstruct SDL_Rect {
    x: int16;
    y: int16;
    w: uint16;
    h: uint16;
  }
  cstruct SDL_VideoInfo {
    hw_available: uint32;
    wm_available: uint32;
    UnusedBits1: uint32;
    UnusedBits2: uint32;
    blit_hw: uint32;
    blit_hw_CC: uint32;
    blit_hw_A: uint32;
    blit_sw: uint32;
    blit_sw_CC: uint32;
    blit_sw_A: uint32;
    blit_fill: uint32;
    UnusedBits3: uint32;
    video_mem: uint32;
    vfmt: ptr[SDL_PixelFormat];
  }
  cstruct SDL_PixelFormat {
    palette: ptr[SDL_Palette];
    BitsPerPixel: uint8;
    BytesPerPixel: uint8;
    Rloss: uint8;
    Gloss: uint8;
    Bloss: uint8;
    Aloss: uint8;
    Rshift: uint8;
    Gshift: uint8;
    Bshift: uint8;
    Ashift: uint8;
    Rmask: uint32;
    Gmask: uint32;
    Bmask: uint32;
    Amask: uint32;
    colorkey: uint32;
    alpha: uint8;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_video_h_cft_1)(struct SDL_Surface *,  SDL_Rect *,  struct SDL_Surface *,  SDL_Rect *);''';
  type SDL_video_h_cft_1 = 'SDL_video_h_cft_1';
  
  //EXTERNALLY COMPLETED TYPES
  //type _struct_SDL_Surface defined in SDL_video_h='SDL_video.h';
  
  //PURE INCOMPLETE TYPES
  type _struct_SDL_BlitMap = 'struct SDL_BlitMap'; //local
  type _struct_private_yuvhwfuncs = 'struct private_yuvhwfuncs'; //local
  type _struct_private_hwdata = 'struct private_hwdata'; //local
  type _struct_private_yuvhwdata = 'struct private_yuvhwdata'; //local
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_Surface = SDL_Surface;
  typedef _struct_SDL_Overlay = SDL_Overlay;
  typedef _struct_SDL_Palette = SDL_Palette;
  typedef _struct_SDL_PixelFormat = SDL_PixelFormat;
  typedef _struct_SDL_Rect = SDL_Rect;
  typedef _struct_SDL_Color = SDL_Color;
  typedef _struct_SDL_VideoInfo = SDL_VideoInfo;
  typedef SDL_blit = SDL_video_h_cft_1;
  
  //ENUMERATION CONSTANTS
  const SDL_GL_STENCIL_SIZE: int = 'SDL_GL_STENCIL_SIZE';
  const SDL_GL_MULTISAMPLEBUFFERS: int = 'SDL_GL_MULTISAMPLEBUFFERS';
  const SDL_GL_STEREO: int = 'SDL_GL_STEREO';
  const SDL_GL_ACCUM_RED_SIZE: int = 'SDL_GL_ACCUM_RED_SIZE';
  const SDL_GRAB_OFF: int = 'SDL_GRAB_OFF';
  const SDL_GL_ACCUM_GREEN_SIZE: int = 'SDL_GL_ACCUM_GREEN_SIZE';
  const SDL_GL_ACCUM_ALPHA_SIZE: int = 'SDL_GL_ACCUM_ALPHA_SIZE';
  const SDL_GL_DEPTH_SIZE: int = 'SDL_GL_DEPTH_SIZE';
  const SDL_GRAB_FULLSCREEN: int = 'SDL_GRAB_FULLSCREEN';
  const SDL_GL_RED_SIZE: int = 'SDL_GL_RED_SIZE';
  const SDL_GL_BLUE_SIZE: int = 'SDL_GL_BLUE_SIZE';
  const SDL_GL_ACCUM_BLUE_SIZE: int = 'SDL_GL_ACCUM_BLUE_SIZE';
  const SDL_GL_GREEN_SIZE: int = 'SDL_GL_GREEN_SIZE';
  const SDL_GRAB_QUERY: int = 'SDL_GRAB_QUERY';
  const SDL_GL_ALPHA_SIZE: int = 'SDL_GL_ALPHA_SIZE';
  const SDL_GL_MULTISAMPLESAMPLES: int = 'SDL_GL_MULTISAMPLESAMPLES';
  const SDL_GL_DOUBLEBUFFER: int = 'SDL_GL_DOUBLEBUFFER';
  const SDL_GL_BUFFER_SIZE: int = 'SDL_GL_BUFFER_SIZE';
  const SDL_GRAB_ON: int = 'SDL_GRAB_ON';
  
  //PROCEDURES
  proc SDL_FreeSurface: ptr[SDL_Surface];
  proc SDL_FreeYUVOverlay: ptr[SDL_Overlay];
  proc SDL_GL_Lock: 1;
  proc SDL_GL_SwapBuffers: 1;
  proc SDL_GL_Unlock: 1;
  proc SDL_GL_UpdateRects: int * ptr[SDL_Rect];
  proc SDL_GetClipRect: ptr[SDL_Surface] * ptr[SDL_Rect];
  proc SDL_GetRGB: uint32 * ptr[SDL_PixelFormat] * ptr[uint8] * ptr[uint8] * ptr[uint8];
  proc SDL_GetRGBA: uint32 * ptr[SDL_PixelFormat] * ptr[uint8] * ptr[uint8] * ptr[uint8] * ptr[uint8];
  proc SDL_UnlockSurface: ptr[SDL_Surface];
  proc SDL_UnlockYUVOverlay: ptr[SDL_Overlay];
  proc SDL_UpdateRect: ptr[SDL_Surface] * int32 * int32 * uint32 * uint32;
  proc SDL_UpdateRects: ptr[SDL_Surface] * int * ptr[SDL_Rect];
  proc SDL_VideoQuit: 1;
  proc SDL_WM_GetCaption: ptr[ptr[char]] * ptr[ptr[char]];
  proc SDL_WM_SetCaption: cptr[char] * cptr[char];
  proc SDL_WM_SetIcon: ptr[SDL_Surface] * ptr[uint8];
  
  //FUNCTIONS
  fun SDL_BlitSurface : ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_ConvertSurface: ptr[SDL_Surface] * ptr[SDL_PixelFormat] * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateRGBSurface: uint32 * int * int * int * uint32 * uint32 * uint32 * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateRGBSurfaceFrom: address * int * int * int * int * uint32 * uint32 * uint32 * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateYUVOverlay: int * int * uint32 * ptr[SDL_Surface] -> ptr[SDL_Overlay];
  fun SDL_DisplayFormat: ptr[SDL_Surface] -> ptr[SDL_Surface];
  fun SDL_DisplayFormatAlpha: ptr[SDL_Surface] -> ptr[SDL_Surface];
  fun SDL_DisplayYUVOverlay: ptr[SDL_Overlay] * ptr[SDL_Rect] -> int;
  fun SDL_FillRect: ptr[SDL_Surface] * ptr[SDL_Rect] * uint32 -> int;
  fun SDL_Flip: ptr[SDL_Surface] -> int;
  fun SDL_GL_GetAttribute: SDL_GLattr * ptr[int] -> int;
  fun SDL_GL_GetProcAddress: cptr[char] -> address;
  fun SDL_GL_LoadLibrary: cptr[char] -> int;
  fun SDL_GL_SetAttribute: SDL_GLattr * int -> int;
  fun SDL_GetGammaRamp: ptr[uint16] * ptr[uint16] * ptr[uint16] -> int;
  fun SDL_GetVideoInfo: 1 -> cptr[SDL_VideoInfo];
  fun SDL_GetVideoSurface: 1 -> ptr[SDL_Surface];
  fun SDL_ListModes: ptr[SDL_PixelFormat] * uint32 -> ptr[ptr[SDL_Rect]];
  fun SDL_LoadBMP_RW: ptr[SDL_RWops] * int -> ptr[SDL_Surface];
  fun SDL_LoadBMP:cptr[char]->ptr[SDL_Surface];
  fun SDL_LockSurface: ptr[SDL_Surface] -> int;
  fun SDL_LockYUVOverlay: ptr[SDL_Overlay] -> int;
  fun SDL_LowerBlit: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_MapRGB: ptr[SDL_PixelFormat] * uint8 * uint8 * uint8 -> uint32;
  fun SDL_MapRGBA: ptr[SDL_PixelFormat] * uint8 * uint8 * uint8 * uint8 -> uint32;
  fun SDL_SaveBMP_RW: ptr[SDL_Surface] * ptr[SDL_RWops] * int -> int;
  fun SDL_SetAlpha: ptr[SDL_Surface] * uint32 * uint8 -> int;
  fun SDL_SetClipRect: ptr[SDL_Surface] * cptr[SDL_Rect] -> SDL_bool;
  fun SDL_SetColorKey: ptr[SDL_Surface] * uint32 * uint32 -> int;
  fun SDL_SetColors: ptr[SDL_Surface] * ptr[SDL_Color] * int * int -> int;
  fun SDL_SetGamma: float * float * float -> int;
  fun SDL_SetGammaRamp: cptr[uint16] * cptr[uint16] * cptr[uint16] -> int;
  fun SDL_SetPalette: ptr[SDL_Surface] * int * ptr[SDL_Color] * int * int -> int;
  fun SDL_SetVideoMode: int * int * int * uint32 -> ptr[SDL_Surface];
  fun SDL_SoftStretch: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_UpperBlit: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_VideoDriverName: ptr[char] * int -> ptr[char];
  fun SDL_VideoInit: cptr[char] * uint32 -> int;
  fun SDL_VideoModeOK: int * int * int * uint32 -> int;
  fun SDL_WM_GrabInput: SDL_GrabMode -> SDL_GrabMode;
  fun SDL_WM_IconifyWindow: 1 -> int;
  fun SDL_WM_ToggleFullScreen: ptr[SDL_Surface] -> int;
}

@h=tangler('lib/SDL/SDL_endian.flx')
@select(h)
//Module        : SDL_endian_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_endian.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_SwapBE64(X)       (X)
//#define SDL_SwapBE32(X)       (X)
//#define SDL_SwapBE16(X)       (X)
//#define SDL_SwapLE64(X)       SDL_Swap64(X)
//#define SDL_SwapLE32(X)       SDL_Swap32(X)
//#define SDL_SwapLE16(X)       SDL_Swap16(X)
//#define SDL_SwapBE64(X)       SDL_Swap64(X)
//#define SDL_SwapBE32(X)       SDL_Swap32(X)
//#define SDL_SwapBE16(X)       SDL_Swap16(X)
//#define SDL_SwapLE64(X)       (X)
//#define SDL_SwapLE32(X)       (X)
//#define SDL_SwapLE16(X)       (X)
//#define SDL_Swap64(X) (X)
//#define _SDL_endian_h

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_types";

module SDL_endian_h
{
  requires package "sdl";
  header '#include "SDL_endian.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_types_h;
  
  //FUNCTIONS
  fun SDL_ReadBE16: ptr[SDL_RWops] -> uint16;
  fun SDL_ReadBE32: ptr[SDL_RWops] -> uint32;
  fun SDL_ReadBE64: ptr[SDL_RWops] -> Uint64;
  fun SDL_ReadLE16: ptr[SDL_RWops] -> uint16;
  fun SDL_ReadLE32: ptr[SDL_RWops] -> uint32;
  fun SDL_ReadLE64: ptr[SDL_RWops] -> Uint64;
  fun SDL_Swap16: uint16 -> uint16;
  fun SDL_Swap32: uint32 -> uint32;
  fun SDL_Swap64: Uint64 -> Uint64;
  fun SDL_WriteBE16: ptr[SDL_RWops] * uint16 -> int;
  fun SDL_WriteBE32: ptr[SDL_RWops] * uint32 -> int;
  fun SDL_WriteBE64: ptr[SDL_RWops] * Uint64 -> int;
  fun SDL_WriteLE16: ptr[SDL_RWops] * uint16 -> int;
  fun SDL_WriteLE32: ptr[SDL_RWops] * uint32 -> int;
  fun SDL_WriteLE64: ptr[SDL_RWops] * Uint64 -> int;
}

@h=tangler('lib/SDL/SDL_framerate.flx')
@select(h)
//Module        : SDL_framerate_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_framerate.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define FPS_DEFAULT           30
//#define FPS_LOWER_LIMIT               1
//#define FPS_UPPER_LIMIT               200
//#define _SDL_framerate_h

//INCLUDES
include "SDL/SDL";

module SDL_framerate_h
{
  requires package "sdl";
  header '#include "SDL_framerate.h"';
  open C_hack;
  open SDL_h;
  
  //ABSTRACT TYPES
  type FPSmanager = 'FPSmanager';
  
  //PROCEDURES
  proc SDL_framerateDelay: ptr[FPSmanager];
  proc SDL_initFramerate: ptr[FPSmanager];
  
  //FUNCTIONS
  fun SDL_getFramerate: ptr[FPSmanager] -> int;
  fun SDL_setFramerate: ptr[FPSmanager] * int -> int;
}
@h=tangler('lib/SDL/SDL_gfxPrimitives.flx')
@select(h)
//Module        : SDL_gfxPrimitives_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_gfxPrimitives.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define SDL_GFXPRIMITIVES_MINOR       0
//#define SDL_GFXPRIMITIVES_MAJOR       2
//#define M_PI  3.141592654
//#define _SDL_gfxPrimitives_h

//INCLUDES
include "SDL/SDL";
include "SDL/SDL_video";

module SDL_gfxPrimitives_h
{
  requires package "sdl";
  header '#include "SDL_gfxPrimitives.h"';
  open C_hack;
  open SDL_h;
  open SDL_video_h;
  open math_h;
  
  //FUNCTIONS
  fun aacircleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun aacircleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aaellipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aaellipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aalineColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aalineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aapolygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint32 -> int;
  fun aapolygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun aatrigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aatrigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun bezierColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int * uint32 -> int;
  fun bezierRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun boxColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun boxRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun characterColor: ptr[SDL_Surface] * int16 * int16 * char * uint32 -> int;
  fun characterRGBA: ptr[SDL_Surface] * int16 * int16 * char * uint8 * uint8 * uint8 * uint8 -> int;
  fun circleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun circleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun ellipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun ellipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledCircleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun filledCircleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledEllipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun filledEllipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledPolygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int -> int;
  fun filledPolygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledTrigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * int -> int;
  fun filledTrigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledpieColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun filledpieRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun hlineColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun hlineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun lineColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun lineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun pixelColor: ptr[SDL_Surface] * int16 * int16 * uint32 -> int;
  fun pixelRGBA: ptr[SDL_Surface] * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun polygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint32 -> int;
  fun polygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun rectangleColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun rectangleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun stringColor: ptr[SDL_Surface] * int16 * int16 * ptr[char] * uint32 -> int;
  fun stringRGBA: ptr[SDL_Surface] * int16 * int16 * ptr[char] * uint8 * uint8 * uint8 * uint8 -> int;
  fun trigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun trigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun vlineColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun vlineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
}
@h=tangler('lib/SDL/SDL_gfxPrimitives_font.flx')
@select(h)
//Module        : SDL_gfxPrimitives_font_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_gfxPrimitives_font.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define GFX_FONTDATAMAX (8*256)

module SDL_gfxPrimitives_font_h
{
  requires package "sdl";
  header '#include "SDL_gfxPrimitives_font.h"';
  open C_hack;
  
  //VARIABLES
  const gfxPrimitivesFontdata: ptr[utiny] = 'gfxPrimitivesFontdata';
}
@h=tangler('lib/SDL/SDL_image.flx')
@select(h)
//Module        : SDL_image_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_image.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define IMG_GetError  SDL_GetError
//#define IMG_SetError  SDL_SetError
//#define SDL_IMAGE_VERSION(X)                                          \
//#define SDL_IMAGE_PATCHLEVEL  4
//#define SDL_IMAGE_MINOR_VERSION       2
//#define SDL_IMAGE_MAJOR_VERSION       1
//#define _SDL_IMAGE_H

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";
include "SDL/SDL_video";

module SDL_image_h
{
  requires package "sdl";
  header '#include "SDL_image.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  open SDL_video_h;
  
  //FUNCTIONS
  fun IMG_InvertAlpha: int -> int;
  fun IMG_Linked_Version: 1 -> cptr[SDL_version];
  fun IMG_Load: cptr[char] -> ptr[SDL_Surface];
  fun IMG_LoadBMP_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadGIF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadJPG_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadLBM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPCX_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPNG_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPNM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTGA_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTIF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTyped_RW: ptr[SDL_RWops] * int * ptr[char] -> ptr[SDL_Surface];
  fun IMG_LoadXCF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadXPM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_Load_RW: ptr[SDL_RWops] * int -> ptr[SDL_Surface];
  fun IMG_ReadXPMFromArray: ptr[ptr[char]] -> ptr[SDL_Surface];
  fun IMG_isBMP: ptr[SDL_RWops] -> int;
  fun IMG_isGIF: ptr[SDL_RWops] -> int;
  fun IMG_isJPG: ptr[SDL_RWops] -> int;
  fun IMG_isLBM: ptr[SDL_RWops] -> int;
  fun IMG_isPCX: ptr[SDL_RWops] -> int;
  fun IMG_isPNG: ptr[SDL_RWops] -> int;
  fun IMG_isPNM: ptr[SDL_RWops] -> int;
  fun IMG_isTIF: ptr[SDL_RWops] -> int;
  fun IMG_isXCF: ptr[SDL_RWops] -> int;
  fun IMG_isXPM: ptr[SDL_RWops] -> int;
}
@h=tangler('lib/SDL/SDL_imageFilter.flx')
@select(h)
//Module        : SDL_imageFilter_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_imageFilter.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define _SDL_imageFilter_h

module SDL_imageFilter_h
{
  requires package "sdl";
  header '#include "SDL_imageFilter.h"';
  open C_hack;
  
  //PROCEDURES
  proc SDL_imageFilterAlignStack: 1;
  proc SDL_imageFilterMMXoff: 1;
  proc SDL_imageFilterMMXon: 1;
  proc SDL_imageFilterRestoreStack: 1;
  
  //FUNCTIONS
  fun SDL_imageFilterAbsDiff: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterAdd: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterAddByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterAddByteToHalf: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterBinarizeUsingThreshold: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterBitAnd: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterBitNegation: ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterBitOr: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterClipToRange: ptr[utiny] * ptr[utiny] * int * utiny * utiny -> int;
  fun SDL_imageFilterConvolveKernel3x3Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel3x3ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel5x5Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel5x5ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel7x7Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel7x7ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel9x9Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel9x9ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterDiv: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMMXdetect: 1 -> int;
  fun SDL_imageFilterMean: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMult: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultByByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterMultDivby2: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultDivby4: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultNor: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterNormalizeLinear: ptr[utiny] * ptr[utiny] * int * int * int * int * int -> int;
  fun SDL_imageFilterShiftLeft: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftLeftByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftRight: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftRightAndMultByByte: ptr[utiny] * ptr[utiny] * int * utiny * utiny -> int;
  fun SDL_imageFilterSobelX: ptr[utiny] * ptr[utiny] * int * int -> int;
  fun SDL_imageFilterSobelXShiftRight: ptr[utiny] * ptr[utiny] * int * int * utiny -> int;
  fun SDL_imageFilterSub: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterSubByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
}
@h=tangler('lib/SDL/SDL_mixer.flx')
@select(h)
//Module        : SDL_mixer_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_mixer.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define Mix_GetError  SDL_GetError
//#define Mix_SetError  SDL_SetError
//#define Mix_FadeInChannel(channel,chunk,loops,ms) Mix_FadeInChannelTimed(channel,chunk,loops,ms,-1)
//#define Mix_PlayChannel(channel,chunk,loops) Mix_PlayChannelTimed(channel,chunk,loops,-1)
//#define MIX_EFFECTSMAXSPEED  "MIX_EFFECTSMAXSPEED"
//#define MIX_CHANNEL_POST  -2
//#define Mix_LoadWAV(file)     Mix_LoadWAV_RW(SDL_RWFromFile(file, "rb"), 1)
//#define MIX_MAX_VOLUME                128     /* Volume of a chunk */
//#define MIX_DEFAULT_CHANNELS  2
//#define MIX_DEFAULT_FORMAT    AUDIO_S16MSB
//#define MIX_DEFAULT_FORMAT    AUDIO_S16LSB
//#define MIX_DEFAULT_FREQUENCY 22050
//#define MIX_CHANNELS  8
//#define MIX_VERSION(X)                SDL_MIXER_VERSION(X)
//#define MIX_PATCHLEVEL                SDL_MIXER_PATCHLEVEL
//#define MIX_MINOR_VERSION     SDL_MIXER_MINOR_VERSION
//#define MIX_MAJOR_VERSION     SDL_MIXER_MAJOR_VERSION
//#define SDL_MIXER_VERSION(X)                                          \
//#define SDL_MIXER_PATCHLEVEL  6
//#define SDL_MIXER_MINOR_VERSION       2
//#define SDL_MIXER_MAJOR_VERSION       1
//#define _SDL_MIXER_H

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";

module SDL_mixer_h
{
  requires package "sdl";
  header '#include "SDL_mixer.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  
  //ABSTRACT TYPES
  type Mix_MusicType = 'Mix_MusicType';
  type Mix_Chunk = 'Mix_Chunk';
  type Mix_Fading = 'Mix_Fading';
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*SDL_mixer_h_cft_3)(void *, Uint8 *, int);''';
  type SDL_mixer_h_cft_3 = 'SDL_mixer_h_cft_3';
  header '''typedef void (*SDL_mixer_h_cft_1)(int, void *, int,  void *);''';
  type SDL_mixer_h_cft_1 = 'SDL_mixer_h_cft_1';
  header '''typedef void (*SDL_mixer_h_cft_2)(int, void *);''';
  type SDL_mixer_h_cft_2 = 'SDL_mixer_h_cft_2';
  header '''typedef void (*SDL_mixer_h_cft_5)(int);''';
  type SDL_mixer_h_cft_5 = 'SDL_mixer_h_cft_5';
  header '''typedef void (*SDL_mixer_h_cft_4)(void);''';
  type SDL_mixer_h_cft_4 = 'SDL_mixer_h_cft_4';
  
  //PURE INCOMPLETE TYPES
  type _struct__Mix_Music = 'struct _Mix_Music'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef Mix_Music = _struct__Mix_Music;
  
  //TYPE ALIASES
  typedef Mix_EffectDone_t = SDL_mixer_h_cft_2;
  typedef Mix_EffectFunc_t = SDL_mixer_h_cft_1;
  
  //ENUMERATION CONSTANTS
  const MUS_CMD: int = 'MUS_CMD';
  const MIX_FADING_OUT: int = 'MIX_FADING_OUT';
  const MIX_NO_FADING: int = 'MIX_NO_FADING';
  const MIX_FADING_IN: int = 'MIX_FADING_IN';
  const MUS_WAV: int = 'MUS_WAV';
  const MUS_MID: int = 'MUS_MID';
  const MUS_OGG: int = 'MUS_OGG';
  const MUS_NONE: int = 'MUS_NONE';
  const MUS_MOD: int = 'MUS_MOD';
  const MUS_MP3: int = 'MUS_MP3';
  
  //PROCEDURES
  proc Mix_ChannelFinished: SDL_mixer_h_cft_5;
  proc Mix_CloseAudio: 1;
  proc Mix_FreeChunk: ptr[Mix_Chunk];
  proc Mix_FreeMusic: ptr[Mix_Music];
  proc Mix_HookMusic: SDL_mixer_h_cft_3 * address;
  proc Mix_HookMusicFinished: SDL_mixer_h_cft_4;
  proc Mix_Pause: int;
  proc Mix_PauseMusic: 1;
  proc Mix_Resume: int;
  proc Mix_ResumeMusic: 1;
  proc Mix_RewindMusic: 1;
  proc Mix_SetPostMix: SDL_mixer_h_cft_3 * address;
  
  //FUNCTIONS
  fun Mix_AllocateChannels: int -> int;
  fun Mix_ExpireChannel: int * int -> int;
  fun Mix_FadeInChannelTimed: int * ptr[Mix_Chunk] * int * int * int -> int;
  fun Mix_FadeInMusic: ptr[Mix_Music] * int * int -> int;
  fun Mix_FadeInMusicPos: ptr[Mix_Music] * int * int * double -> int;
  fun Mix_FadeOutChannel: int * int -> int;
  fun Mix_FadeOutGroup: int * int -> int;
  fun Mix_FadeOutMusic: int -> int;
  fun Mix_FadingChannel: int -> Mix_Fading;
  fun Mix_FadingMusic: 1 -> Mix_Fading;
  fun Mix_GetChunk: int -> ptr[Mix_Chunk];
  fun Mix_GetMusicHookData: 1 -> address;
  fun Mix_GetMusicType: cptr[Mix_Music] -> Mix_MusicType;
  fun Mix_GetSynchroValue: 1 -> int;
  fun Mix_GroupAvailable: int -> int;
  fun Mix_GroupChannel: int * int -> int;
  fun Mix_GroupChannels: int * int * int -> int;
  fun Mix_GroupCount: int -> int;
  fun Mix_GroupNewer: int -> int;
  fun Mix_GroupOldest: int -> int;
  fun Mix_HaltChannel: int -> int;
  fun Mix_HaltGroup: int -> int;
  fun Mix_HaltMusic: 1 -> int;
  fun Mix_Linked_Version: 1 -> cptr[SDL_version];
  fun Mix_LoadMUS: cptr[char] -> ptr[Mix_Music];
  fun Mix_LoadWAV_RW: ptr[SDL_RWops] * int -> ptr[Mix_Chunk];
  fun Mix_OpenAudio: int * uint16 * int * int -> int;
  fun Mix_Paused: int -> int;
  fun Mix_PausedMusic: 1 -> int;
  fun Mix_PlayChannelTimed: int * ptr[Mix_Chunk] * int * int -> int;
  fun Mix_PlayMusic: ptr[Mix_Music] * int -> int;
  fun Mix_Playing: int -> int;
  fun Mix_PlayingMusic: 1 -> int;
  fun Mix_QuerySpec: ptr[int] * ptr[uint16] * ptr[int] -> int;
  fun Mix_QuickLoad_RAW: ptr[uint8] * uint32 -> ptr[Mix_Chunk];
  fun Mix_QuickLoad_WAV: ptr[uint8] -> ptr[Mix_Chunk];
  fun Mix_RegisterEffect: int * SDL_mixer_h_cft_1 * SDL_mixer_h_cft_2 * address -> int;
  fun Mix_ReserveChannels: int -> int;
  fun Mix_SetDistance: int * uint8 -> int;
  fun Mix_SetMusicCMD: cptr[char] -> int;
  fun Mix_SetMusicPosition: double -> int;
  fun Mix_SetPanning: int * uint8 * uint8 -> int;
  fun Mix_SetPosition: int * int16 * uint8 -> int;
  fun Mix_SetReverseStereo: int * int -> int;
  fun Mix_SetSynchroValue: int -> int;
  fun Mix_UnregisterAllEffects: int -> int;
  fun Mix_UnregisterEffect: int * SDL_mixer_h_cft_1 -> int;
  fun Mix_Volume: int * int -> int;
  fun Mix_VolumeChunk: ptr[Mix_Chunk] * int -> int;
  fun Mix_VolumeMusic: int -> int;
  
  //CALLBACK TYPE WRAPPERS
  //callback type SDL_mixer_h_cft_2, client data at 1
  typedef _fcbat_SDL_mixer_h_cft_2 = int; 
  export type (_fcbat_SDL_mixer_h_cft_2) as "_fcbat_SDL_mixer_h_cft_2";
  typedef _fcbt_SDL_mixer_h_cft_2 = int -> void; 
  export type (_fcbt_SDL_mixer_h_cft_2) as "_fcbt_SDL_mixer_h_cft_2";
  header '''void _fcbw_SDL_mixer_h_cft_2(int a1, void *a2);''';

  const _fcbw_SDL_mixer_h_cft_2: SDL_mixer_h_cft_2 = "_fcbw_SDL_mixer_h_cft_2";
  body '''
  void _fcbw_SDL_mixer_h_cft_2(int a1, void *a2){
    con_t *p  = ((_fcbt_SDL_mixer_h_cft_2)a2)->call(0, a1);
    while(p) p=p->resume();
  }''';

  //callback type SDL_mixer_h_cft_3, client data at 0
  typedef _fcbat_SDL_mixer_h_cft_3 = ptr[uint8] * int; 
  export type (_fcbat_SDL_mixer_h_cft_3) as "_fcbat_SDL_mixer_h_cft_3";
  typedef _fcbt_SDL_mixer_h_cft_3 = ptr[uint8] * int -> void; 
  export type (_fcbt_SDL_mixer_h_cft_3) as "_fcbt_SDL_mixer_h_cft_3";
  header '''void _fcbw_SDL_mixer_h_cft_3(void *a1, Uint8 *a2, int a3);''';

  const _fcbw_SDL_mixer_h_cft_3: SDL_mixer_h_cft_3 = "_fcbw_SDL_mixer_h_cft_3";
  body '''
  void _fcbw_SDL_mixer_h_cft_3(void *a1, Uint8 *a2, int a3){
    con_t *p  = ((_fcbt_SDL_mixer_h_cft_3)a1)->call(0, _fcbat_SDL_mixer_h_cft_3(a2, a3));
    while(p) p=p->resume();
  }''';

  
  //CALLBACK CLIENT WRAPPERS
  //callback client Mix_HookMusic, client data at 0, callback at 1
  proc wrapper_Mix_HookMusic(a1: _fcbt_SDL_mixer_h_cft_3) {
    Mix_HookMusic(_fcbw_SDL_mixer_h_cft_3, C_hack::cast[address]a1);
  }
  //callback client Mix_RegisterEffect, client data at 2, callback at 3
  fun wrapper_Mix_RegisterEffect(a1: int, a2: SDL_mixer_h_cft_1, a3: _fcbt_SDL_mixer_h_cft_2): int= {
    return Mix_RegisterEffect(a1, a2, _fcbw_SDL_mixer_h_cft_2, C_hack::cast[address]a3);
  }
  //callback client Mix_SetPostMix, client data at 0, callback at 1
  proc wrapper_Mix_SetPostMix(a1: _fcbt_SDL_mixer_h_cft_3) {
    Mix_SetPostMix(_fcbw_SDL_mixer_h_cft_3, C_hack::cast[address]a1);
  }
}
@h=tangler('lib/SDL/SDL_sound.flx')
@select(h)
//Module        : SDL_sound_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_sound.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SOUND_VERSION(x) \
//#define SOUND_VER_PATCH 1
//#define SOUND_VER_MINOR 0
//#define SOUND_VER_MAJOR 1
//#define SNDDECLSPEC
//#define SNDDECLSPEC __declspec(dllexport)
//#define SDLCALL
//#define _INCLUDE_SDL_SOUND_H_

//INCLUDES
include "SDL/SDL_rwops";

module SDL_sound_h
{
  requires package "sdl";
  header '#include "SDL_sound.h"';
  open C_hack;
  open SDL_rwops_h;
  
  //ABSTRACT TYPES
  type Sound_Sample = 'Sound_Sample';
  type Sound_Version = 'Sound_Version';
  type Sound_AudioInfo = 'Sound_AudioInfo';
  type Sound_SampleFlags = 'Sound_SampleFlags';
  type Sound_DecoderInfo = 'Sound_DecoderInfo';
  
  //ENUMERATION CONSTANTS
  const SOUND_SAMPLEFLAG_ERROR: int = 'SOUND_SAMPLEFLAG_ERROR';
  const SOUND_SAMPLEFLAG_NONE: int = 'SOUND_SAMPLEFLAG_NONE';
  const SOUND_SAMPLEFLAG_EAGAIN: int = 'SOUND_SAMPLEFLAG_EAGAIN';
  const SOUND_SAMPLEFLAG_EOF: int = 'SOUND_SAMPLEFLAG_EOF';
  const SOUND_SAMPLEFLAG_CANSEEK: int = 'SOUND_SAMPLEFLAG_CANSEEK';
  
  //PROCEDURES
  proc Sound_ClearError: 1;
  proc Sound_FreeSample: ptr[Sound_Sample];
  proc Sound_GetLinkedVersion: ptr[Sound_Version];
  
  //FUNCTIONS
  fun Sound_AvailableDecoders: 1 -> ptr[cptr[Sound_DecoderInfo]];
  fun Sound_Decode: ptr[Sound_Sample] -> uint32;
  fun Sound_DecodeAll: ptr[Sound_Sample] -> uint32;
  fun Sound_GetError: 1 -> cptr[char];
  fun Sound_Init: 1 -> int;
  fun Sound_NewSample: ptr[SDL_RWops] * cptr[char] * ptr[Sound_AudioInfo] * uint32 -> ptr[Sound_Sample];
  fun Sound_NewSampleFromFile: cptr[char] * ptr[Sound_AudioInfo] * uint32 -> ptr[Sound_Sample];
  fun Sound_Quit: 1 -> int;
  fun Sound_Rewind: ptr[Sound_Sample] -> int;
  fun Sound_Seek: ptr[Sound_Sample] * uint32 -> int;
  fun Sound_SetBufferSize: ptr[Sound_Sample] * uint32 -> int;
}
@h=tangler('lib/SDL/SDL_rotozoom.flx')
@select(h)
//Module        : SDL_rotozoom_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_rotozoom.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define SMOOTHING_ON          1
//#define SMOOTHING_OFF         0
//#define M_PI  3.141592654
//#define _SDL_rotozoom_h

//INCLUDES
include "SDL/SDL";
include "SDL/SDL_video";

module SDL_rotozoom_h
{
  requires package "sdl";
  header '#include "SDL_rotozoom.h"';
  open C_hack;
  open SDL_h;
  open SDL_video_h;
  open math_h;
  
  //CSTRUCTS 
  cstruct tColorRGBA {
    r: uint8;
    g: uint8;
    b: uint8;
    a: uint8;
  }
  cstruct tColorY {
    y: uint8;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_tColorY = tColorY;
  typedef _struct_tColorRGBA = tColorRGBA;
  
  //PROCEDURES
  proc rotozoomSurfaceSize: int * int * double * double * ptr[int] * ptr[int];
  proc zoomSurfaceSize: int * int * double * double * ptr[int] * ptr[int];
  
  //FUNCTIONS
  fun rotozoomSurface: ptr[SDL_Surface] * double * double * int -> ptr[SDL_Surface];
  fun zoomSurface: ptr[SDL_Surface] * double * double * int -> ptr[SDL_Surface];
}
@h=tangler('lib/SDL/SDL_ttf.flx')
@select(h)
//Module        : SDL_ttf_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_ttf.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define TTF_GetError  SDL_GetError
//#define TTF_SetError  SDL_SetError
//#define TTF_RenderUNICODE(font, text, fg, bg) \
//#define TTF_RenderUTF8(font, text, fg, bg)    \
//#define TTF_RenderText(font, text, fg, bg)    \
//#define TTF_STYLE_UNDERLINE   0x04
//#define TTF_STYLE_ITALIC      0x02
//#define TTF_STYLE_BOLD                0x01
//#define TTF_STYLE_NORMAL      0x00
//#define UNICODE_BOM_SWAPPED   0xFFFE
//#define UNICODE_BOM_NATIVE    0xFEFF
//#define TTF_VERSION(X)                                                        \
//#define TTF_PATCHLEVEL                6
//#define TTF_MINOR_VERSION     0
//#define TTF_MAJOR_VERSION     2
//#define _SDLttf_h

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";
include "SDL/SDL_video";

module SDL_ttf_h
{
  requires package "sdl";
  header '#include "SDL_ttf.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  open SDL_video_h;
  
  //PURE INCOMPLETE TYPES
  type _struct__TTF_Font = 'struct _TTF_Font'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef TTF_Font = _struct__TTF_Font;
  
  //PROCEDURES
  proc TTF_ByteSwappedUNICODE: int;
  proc TTF_CloseFont: ptr[TTF_Font];
  proc TTF_Quit: 1;
  proc TTF_SetFontStyle: ptr[TTF_Font] * int;
  
  //FUNCTIONS
  fun TTF_FontAscent: ptr[TTF_Font] -> int;
  fun TTF_FontDescent: ptr[TTF_Font] -> int;
  fun TTF_FontFaceFamilyName: ptr[TTF_Font] -> ptr[char];
  fun TTF_FontFaceIsFixedWidth: ptr[TTF_Font] -> int;
  fun TTF_FontFaceStyleName: ptr[TTF_Font] -> ptr[char];
  fun TTF_FontFaces: ptr[TTF_Font] -> long;
  fun TTF_FontHeight: ptr[TTF_Font] -> int;
  fun TTF_FontLineSkip: ptr[TTF_Font] -> int;
  fun TTF_GetFontStyle: ptr[TTF_Font] -> int;
  fun TTF_GlyphMetrics: ptr[TTF_Font] * uint16 * ptr[int] * ptr[int] * ptr[int] * ptr[int] * ptr[int] -> int;
  fun TTF_Init: 1 -> int;
  fun TTF_Linked_Version: 1 -> cptr[SDL_version];
  fun TTF_OpenFont: cptr[char] * int -> ptr[TTF_Font];
  fun TTF_OpenFontIndex: cptr[char] * int * long -> ptr[TTF_Font];
  fun TTF_OpenFontIndexRW: ptr[SDL_RWops] * int * int * long -> ptr[TTF_Font];
  fun TTF_OpenFontRW: ptr[SDL_RWops] * int * int -> ptr[TTF_Font];
  fun TTF_RenderGlyph_Blended: ptr[TTF_Font] * uint16 * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderGlyph_Shaded: ptr[TTF_Font] * uint16 * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderGlyph_Solid: ptr[TTF_Font] * uint16 * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Blended: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Shaded: ptr[TTF_Font] * cptr[char] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Solid: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Blended: ptr[TTF_Font] * cptr[uint16] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Shaded: ptr[TTF_Font] * cptr[uint16] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Solid: ptr[TTF_Font] * cptr[uint16] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Blended: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Shaded: ptr[TTF_Font] * cptr[char] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Solid: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_SizeText: ptr[TTF_Font] * cptr[char] * ptr[int] * ptr[int] -> int;
  fun TTF_SizeUNICODE: ptr[TTF_Font] * cptr[uint16] * ptr[int] * ptr[int] -> int;
  fun TTF_SizeUTF8: ptr[TTF_Font] * cptr[char] * ptr[int] * ptr[int] -> int;
  fun TTF_WasInit: 1 -> int;
}
@h=tangler('lib/SDL/SDL_net.flx')
@select(h)
//Module        : SDL_net_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_net.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDL_DATA_ALIGNED      0
//#define SDL_DATA_ALIGNED      1
//#define SDLNet_GetError       SDL_GetError
//#define SDLNet_SetError       SDL_SetError
//#define SDLNet_SocketReady(sock) \
//#define SDLNet_UDP_DelSocket(set, sock) \
//#define SDLNet_TCP_DelSocket(set, sock) \
//#define SDLNet_UDP_AddSocket(set, sock) \
//#define SDLNet_TCP_AddSocket(set, sock) \
//#define SDLNET_MAX_UDPADDRESSES       4
//#define SDLNET_MAX_UDPCHANNELS        32
//#define INADDR_BROADCAST      0xFFFFFFFF
//#define INADDR_NONE           0xFFFFFFFF
//#define INADDR_ANY            0x00000000
//#define _SDLnet_h

module SDL_net_h
{
  requires package "sdl";
  header '#include "SDL_net.h"';
  open C_hack;
  
  //ABSTRACT TYPES
  type SDLNet_GenericSocket = 'SDLNet_GenericSocket';
  type IPaddress = 'IPaddress';
  type UDPpacket = 'UDPpacket';
  
  //PURE INCOMPLETE TYPES
  type _struct__UDPsocket = 'struct _UDPsocket'; //local
  type _struct__SDLNet_SocketSet = 'struct _SDLNet_SocketSet'; //local
  type _struct__TCPsocket = 'struct _TCPsocket'; //local
  
  //TYPE ALIASES
  typedef UDPsocket = ptr[_struct__UDPsocket];
  typedef TCPsocket = ptr[_struct__TCPsocket];
  typedef SDLNet_SocketSet = ptr[_struct__SDLNet_SocketSet];
  
  //PROCEDURES
  proc SDLNet_FreePacket: ptr[UDPpacket];
  proc SDLNet_FreePacketV: ptr[ptr[UDPpacket]];
  proc SDLNet_FreeSocketSet: SDLNet_SocketSet;
  proc SDLNet_Quit: 1;
  proc SDLNet_TCP_Close: TCPsocket;
  proc SDLNet_UDP_Close: UDPsocket;
  proc SDLNet_UDP_Unbind: UDPsocket * int;
  proc SDLNet_Write16: uint16 * address;
  proc SDLNet_Write32: uint32 * address;
  
  //FUNCTIONS
  fun SDLNet_AddSocket: SDLNet_SocketSet * SDLNet_GenericSocket -> int;
  fun SDLNet_AllocPacket: int -> ptr[UDPpacket];
  fun SDLNet_AllocPacketV: int * int -> ptr[ptr[UDPpacket]];
  fun SDLNet_AllocSocketSet: int -> SDLNet_SocketSet;
  fun SDLNet_CheckSockets: SDLNet_SocketSet * uint32 -> int;
  fun SDLNet_DelSocket: SDLNet_SocketSet * SDLNet_GenericSocket -> int;
  fun SDLNet_Init: 1 -> int;
  fun SDLNet_Read16: address -> uint16;
  fun SDLNet_Read32: address -> uint32;
  fun SDLNet_ResizePacket: ptr[UDPpacket] * int -> int;
  fun SDLNet_ResolveHost: ptr[IPaddress] * cptr[char] * uint16 -> int;
  fun SDLNet_ResolveIP: ptr[IPaddress] -> cptr[char];
  fun SDLNet_TCP_Accept: TCPsocket -> TCPsocket;
  fun SDLNet_TCP_GetPeerAddress: TCPsocket -> ptr[IPaddress];
  fun SDLNet_TCP_Open: ptr[IPaddress] -> TCPsocket;
  fun SDLNet_TCP_Recv: TCPsocket * address * int -> int;
  fun SDLNet_TCP_Send: TCPsocket * address * int -> int;
  fun SDLNet_UDP_Bind: UDPsocket * int * ptr[IPaddress] -> int;
  fun SDLNet_UDP_GetPeerAddress: UDPsocket * int -> ptr[IPaddress];
  fun SDLNet_UDP_Open: uint16 -> UDPsocket;
  fun SDLNet_UDP_Recv: UDPsocket * ptr[UDPpacket] -> int;
  fun SDLNet_UDP_RecvV: UDPsocket * ptr[ptr[UDPpacket]] -> int;
  fun SDLNet_UDP_Send: UDPsocket * int * ptr[UDPpacket] -> int;
  fun SDLNet_UDP_SendV: UDPsocket * ptr[ptr[UDPpacket]] * int -> int;
}

@h = tangler("faio/faio_sdl_event.hpp")
@select(h)
#ifndef __FAIO_SDL_EVENT__
#define __FAIO_SDL_EVENT__
#include <flx_rtl_config.hpp>
#include "demux_work_fifo.hpp"
#include "faio_drv.hpp"      // thread_wakeups, 
#include "faio_asyncio.hpp"  // flx_driver_request_base
#include "SDL_mutex.h"
#include "SDL_events.h"

namespace flx { namespace faio {

// ONE PROBLEM: this is faio level. It needs to know about fthreads

// get ONE SDL event
class FLX_RTL_EXTERN faio_sdl_event : public flx_driver_request_base,
  public demux::worker_task {
   thread_wakeup   fw;
   SDL_Event *e;
   SDL_mutex *m;
public:  
  faio_sdl_event() {}     // felix linkage
  faio_sdl_event(SDL_Event *_e, SDL_mutex *_m);

  // from flx_driver_request_base
  bool start_async_op(demux::demuxer& demux, flx_drv* drv,  void* f);

  // from fifo_worker_task
  void doit();
  void finished();
};

}}
#endif

@h = tangler("faio/faio_sdl_event.cpp")
@select(h)
#include <demux_work_fifo.hpp>
#include "SDL_mutex.h"
#include "SDL_events.h"
#include "faio_sdl_event.hpp"

namespace flx { namespace faio {

faio_sdl_event::faio_sdl_event(SDL_Event *_e, SDL_mutex *_m) : e(_e), m(_m) {}

bool
faio_sdl_event::start_async_op(demux::demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw);    // so we can wake up

  // get worker fifo, add this task
  drv->get_worker_fifo()->add_worker_task(this);
  return false;              // suspended
}

void faio_sdl_event::doit() { 
  if(m)SDL_LockMutex(m);
  SDL_WaitEvent(e); // blocks in pthread
  if(m)SDL_UnlockMutex(m);
} 

void faio_sdl_event::finished(){ fw.wake(); }

}}

@h=tangler('lib/flx_faio_sdl.flx')
@select(h)
#import <flx.flxh>

include "SDL/SDL";
include "SDL/SDL_events";
include "flx_faio";

module SDL_events 
{
  requires package "sdl";
  requires package "faio";
  open SDL_events_h;
  open SDL_mutex_h;

  header faio_sdl_event_hpp = '#include "faio_sdl_event.hpp"';

  private type sdl_event_request = 
    "flx::faio::faio_sdl_event"
    requires faio_sdl_event_hpp
  ;

  private fun mk_sdl_event_request: ptr[SDL_Event] * ptr[SDL_mutex] -> sdl_event_request = 
    "flx::faio::faio_sdl_event($1,$2)";

  fun event_type: SDL_Event -> uint8 = "$1.type";

  proc get_sdl_event(pe:&SDL_Event, m:ptr[SDL_mutex])
  {
    var cpe = unref pe;
    var req = mk_sdl_event_request (cpe,m);
    Faio::faio_req$ &req;
  }

  proc block_sdl_events(m:ptr[SDL_mutex])
  {
    var dummy = SDL_UserEvent(SDL_USEREVENT,0,NULL,NULL);
    ignore(SDL_PushEvent(cast [ptr[SDL_Event]] (addr dummy)));
    ignore(SDL_LockMutex(m));
  }

  proc unblock_sdl_events(m:ptr[SDL_mutex])
  {
    ignore(SDL_UnlockMutex(m));
  }
}

@h = tangler("tut/examples/sdl100.flx")
@select(h)
#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_video";
include "SDL/SDL_rwops";
//include "SDL/SDL_image";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_events";
include "SDL/SDL_mutex";
include "SDL/SDL_audio";
include "flx_faio";
include "flx_faio_sdl";

// Raw SDL interfaces
open SDL_h;
open SDL_video_h;
open SDL_rwops_h;
//open SDL_image_h;
open SDL_events_h;
open SDL_audio_h;
open SDL_mutex_h;
open SDL_keyboard_h;
open SDL_keysym_h;

open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;

// This is the Felix asynchronous event source 
open SDL_events;

proc DrawPixel(screen:ptr[SDL_Surface], x:int32, y:int32, R:uint8, G:uint8, B:uint8)
{
    color := SDL_MapRGB(screen.->format, R, G, B);

    if SDL_MUSTLOCK(screen) do
        if SDL_LockSurface(screen) < 0 return;
    done;

    match screen.->format.->BytesPerPixel with
    | 1 => 
      { /* Assuming 8-bpp */
        bufp := cast[ptr[uint8]] screen.->pixels + y*screen.->pitch + x;
        *bufp = color;
      }

    | 2 => 
      { /* Probably 15-bpp or 16-bpp */
        bufp := cast[ptr[uint16]] screen.->pixels + y*screen.->pitch/2 + x;
        *bufp = color;
      }

    | 3 => 
      { /* Slow 24-bpp mode, usually not used */
        bufp := cast[ptr[uint8]] screen.->pixels + y*screen.->pitch + x;
        *(bufp+screen.->format.->Rshift/8) = R;
        *(bufp+screen.->format.->Gshift/8) = G;
        *(bufp+screen.->format.->Bshift/8) = B;
      }

    | 4 => 
      { /* Probably 32-bpp */
        bufp := cast[ptr[uint32]] screen.->pixels + y*screen.->pitch/4 + x;
        *bufp = color;
      }
    endmatch;

    if SDL_MUSTLOCK(screen) do
        SDL_UnlockSurface(screen);
    done;
    SDL_UpdateRect(screen, x, y, 1u, 1u);
}

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var screen: ptr[SDL_Surface];
screen = SDL_SetVideoMode(640, 480, 32, SDL_SWSURFACE);
if isNULL screen do
  print "Unable to set 1024x768 video"; endl;
  System::exit(1);
done;

print "yo, we're off: ";
print screen.->format.->BytesPerPixel;
print " bytes per pixel\n";

var i = 10i32; until i == 50i32 do
      DrawPixel(screen, i,i,250u8,220u8,220u8);
      ++i;
done;      

struct sample_t {
    data : ptr[uint8];
    dpos: uint32;
    dlen: uint32;
};

macro val NUM_SOUNDS = 2;
var sounds : sample_t ^ NUM_SOUNDS;

{
  var j:int;
  forall j in 0 upto NUM_SOUNDS-1 do
    sounds.[j] = sample_t(null_ptr[uint8],0u32,0u32);
  done;
};

proc flx_mixaudio(stream : ptr[uint8], len : int)
{
  var i : int;
  var amount : uint32;
  forall i in 0 upto NUM_SOUNDS-1 do
    amount = sounds.[i].dlen - sounds.[i].dpos;
    if amount > len do amount = len; done;
    var loc : ptr[uint8] = sounds.[i].data+ cast[int] sounds.[i].dpos;
    SDL_MixAudio(stream, cast[cptr[uint8]] loc, amount, SDL_MIX_MAXVOLUME);
    sounds.[i].dpos += amount;
  done;
}

var fmt : SDL_AudioSpec;
fmt.freq=22050;
fmt.format=AUDIO_S16;
fmt.channels=2u8;
fmt.silence=0u8;
fmt.samples=2048u16;
fmt.padding=0u16;
fmt.size=0u16;

//const SDL_audio_callback : SDL_audio_h_cft_1;
get_callback fmt = code [SDL_audio_h_cft_1] 'SDL_audio_callback';
var mixer = the flx_mixaudio;
fmt.userdata= cast[address] mixer;


if SDL_OpenAudio(addr fmt, null_ptr[SDL_AudioSpec]) < 0 do
  print "Can't open Audio"; endl;
  System::exit 0;
done;

proc PlaySound(filename:string)
{
  var idx:int;
  var wave: SDL_AudioSpec;
  var data : ptr[uint8];
  var dlen : uint32;
  var cvt : SDL_AudioCVT;
  /* Look for an empty (or finished) sound slot */
  forall idx in 0 upto 2 do
    if sounds.[idx].dpos == sounds.[idx].dlen goto found;
  done;
  found:>
  if idx == NUM_SOUNDS do
    print "No free slot for music"; endl;
    return;
  done;

  if 
    SDL_LoadWAV(
      enconst (cstr filename), 
      addr wave, 
      addr data, 
      addr dlen
    ) == null_ptr[SDL_AudioSpec] 
  do
    print$ "Couldn't load Wav file " + filename; endl;
    return;
  done;
  print$ "Loaded Wav file " + filename; endl;
  print "Using slot "; print idx; endl;

  var result = SDL_BuildAudioCVT(
    addr cvt, 
    wave.format, 
    wave.channels, 
    wave.freq,
    AUDIO_S16,   
    2u8,
    22050
  );
  cvt.buf = array_alloc[uint8](dlen*cvt.len_mult);
  memcpy(as_address cvt.buf, as_address data, cast[size] dlen);
  cvt.len = dlen;
  result = SDL_ConvertAudio(addr cvt);
  SDL_FreeWAV(data);

  /* Put the sound data in the slot (it starts playing immediately) */
  if not (isNULL sounds.[idx].data) call free sounds.[idx].data;
  SDL_LockAudio();
  sounds.[idx].data = cvt.buf;
  sounds.[idx].dlen = cvt.len_cvt;
  sounds.[idx].dpos = 0u32;
  SDL_UnlockAudio();
}

SDL_PauseAudio 0;
{
  forall i in 1 upto 16 do
    filename := "media/sounds/fs" + str i + ".wav";
    print$ "Playing file " + filename; endl;
    PlaySound(filename);
  done;
};

var s: ptr[SDL_Surface] ^ 16;
{
  forall i in 1 upto 16 do
       //filename := "media/images/fc" + str i+ ".jpg"; 
       filename := "media/images/fc" + str i+ ".bmp"; 
       print$ "Loading file " + filename; endl;
       rwop := SDL_RWFromFile (enconst (cstr filename),enconst (c"rb"));
       //s.[i-1] = IMG_LoadJPG_RW(rwop);
       s.[i-1] = SDL_LoadBMP_RW(rwop,1);
  done;
};

var rcDest : SDL_Rect;
SDL_GetClipRect(screen,addr rcDest);

black := SDL_MapRGB(screen.->format, 0u8, 0u8, 0u8);

proc waitt(t:double) (f:schannel[uint8]) {
  Faio::sleep t;
  write (f,SDL_USEREVENT); // hack for timer event
}

/* function to handle key press events */
proc handle_key( keysym : SDL_keysym)
{
  match keysym.sym with
  | ?k when k == SDLK_ESCAPE => { Quit 0; }
  | ?k when k ==  SDLK_F1 =>
	    { ignore$ SDL_WM_ToggleFullScreen(screen); }
  | _ => {}
  endmatch;
}


var event_lock = SDL_CreateMutex ();

proc poll_event(e: &SDL_Event)
{
tryagain:>
  //print "Polling event"; endl;
  var result = SDL_PollEvent(unref e);
  if result > 0 do
    //print "Got event"; endl;
    return;
  done;
  Faio::sleep 0.1;
  goto tryagain;
}

proc waitk(f:schannel[uint8]) {
  // ASYNC event reading doesn't work with SDL on Windows
  // So we have busy wait ;(
  //var &e : SDL_Event <- get_sdl_event event_lock;
  var e : SDL_Event;
  poll_event(&e);

  var et = event_type e;
  whilst 
    et != SDL_KEYDOWN and 
    et != SDL_MOUSEBUTTONDOWN and
    et != SDL_QUIT 
  do
    //&e <- get_sdl_event event_lock;
    poll_event(&e);
    et = event_type e;
  done;
  if et == SDL_KEYDOWN call handle_key e.key.keysym;
  write (f,et);
}

proc waittk() {
  var w = mk_schannel[uint8] ();
  spawn_fthread { waitt 15.0 w; };
  spawn_fthread { waitk w; };
  var &i: uint8 <- read w;
}


forall i in 0 upto 15 do      
  if not (isNULL s.[i]) do
    print "Show "; print i; endl;
    var r = SDL_BlitSurface ( s.[i], null_ptr[SDL_Rect], screen, addr rcDest );
    SDL_UpdateRect(screen, 0i32,0i32,0u,0u);
    waittk;
    r = SDL_FillRect(screen, addr rcDest, black);
  else
    print "Skip "; print i; endl;
  done;
done;

print "Press any key"; endl;

{
  var x = mk_schannel[uint8] ();
  spawn_fthread { waitk x; };
  var &i : uint8 <- read x;
};

Quit 0;

proc Quit(x:int)
{
  //print "QUIT "; print x; endl;
  SDL_CloseAudio;
  SDL_Quit;
  System::exit x;
}

@h = tangler("tut/examples/sdl202.flx")
@select(h)
// REQUIRES OpenGL and GLU
/*
 * This code was created by Jeff Molofee '99 
 * (ported to Linux/SDL by Ti Leggett '01)
 *
 * If you've found this code useful, please let me know.
 *
 * Visit Jeff at http://nehe.gamedev.net/
 * 
 * or for port-specific comments, questions, bugreports etc. 
 * email to leggett@eecs.tulane.edu
 */

#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_video";
include "SDL/SDL_events";
include "SDL/SDL_timer";
include "SDL/SDL_mutex";
include "SDL/SDL_opengl";

include "flx_faio";
include "flx_faio_sdl";


open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;
open Float;

open SDL_h;
open SDL_video_h;
open SDL_keyboard_h;
open SDL_events_h;
open SDL_keysym_h;
open SDL_timer_h;
open SDL_mutex_h;

// This is the Felix asynchronous event source 
open SDL_events;

open SDL_opengl_h;

/* screen width, height, and bit depth */
val SCREEN_WIDTH  = 640;
val SCREEN_HEIGHT = 480;
val SCREEN_BPP = 16;

/* function to reset our viewport after a window resize */
proc resizeWindow( wwidth : int, hheight :int)
{
  var height = hheight;
  var width = wwidth;

  /* Protect against a divide by zero */
  if height == 0 do height = 1; done;
  var ratio = double_of width / double_of height;

  block_sdl_events event_lock;
  /* Setup our viewport. */
  glViewport( 0, 0, width, height );

  /* change to the projection matrix and set our viewing volume. */
  glMatrixMode( GL_PROJECTION );
  glLoadIdentity( );

  /* Set our perspective */
  gluPerspective( 45.0, ratio, 0.1, 100.0 );

  /* Make sure we're chaning the model view and not the projection */
  glMatrixMode( GL_MODELVIEW );

  /* Reset The View */
  glLoadIdentity( );
  unblock_sdl_events event_lock;
}

/* general OpenGL initialization function */
proc initGL()
{
  /* Enable smooth shading */
  glShadeModel( GL_SMOOTH );

  /* Set the background black */
  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

  /* Depth buffer setup */
  glClearDepth( 1.0 );

  /* Enables Depth Testing */
  glEnable( GL_DEPTH_TEST );

  /* The Type Of Depth Test To Do */
  glDepthFunc( GL_LEQUAL );

  /* Really Nice Perspective Calculations */
  glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
}

/* These are to calculate our fps */
var T0     = 0;
var Frames = 0;


/* Here goes our drawing code */
proc drawGLScene(drawing:1->0)
{
  block_sdl_events event_lock;
  drawing();
  unblock_sdl_events event_lock;

  /* Gather our frames per second */
  Frames++;
  {
    var t = SDL_GetTicks();
    if t - T0 >= 5000 do
      val seconds = double_of (t - T0) / 1000.0;
      val fps = double_of Frames / seconds;
      print Frames; print " frames in "; print seconds; 
      print " seconds = "; print fps; print " FPS"; endl;
      T0 = t;
      Frames = 0;
    done; 
  };
}

/* whether or not the window is active */
var isActive = true;

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var event_lock = SDL_CreateMutex();


proc Quit(n:int)
{
  SDL_Quit;
  System::exit 0;
}

/* Fetch the video info */
var videoInfo = SDL_GetVideoInfo();

if isNULL videoInfo do
  print "Video query failed"; endl; 
  Quit 1;
done;

/* the flags to pass to SDL_SetVideoMode */
var 
  videoFlags  = SDL_OPENGL;          /* Enable OpenGL in SDL */
  videoFlags |= cast[uint] SDL_GL_DOUBLEBUFFER; /* Enable double buffering */
  videoFlags |= SDL_HWPALETTE;       /* Store the palette in hardware */
  videoFlags |= SDL_RESIZABLE;       /* Enable window resizing */

/* This checks to see if surfaces can be stored in memory */
if  videoInfo.->hw_available != 0 do
	videoFlags |= SDL_HWSURFACE;
else
	videoFlags |= SDL_SWSURFACE;
done;

/* This checks if hardware blits can be done */
if videoInfo.->blit_hw != 0 do
	videoFlags |= SDL_HWACCEL;
done;

/* Sets up OpenGL double buffering */
ignore$ SDL_GL_SetAttribute( cast[SDL_GLattr] SDL_GL_DOUBLEBUFFER, 1 );

/* get a SDL surface */
var surface = SDL_SetVideoMode
  (SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, videoFlags )
;

/* Verify there is a surface */
if isNULL surface do
  print "Video mode set failed"; endl; 
  Quit 1;
done;

/* initialize OpenGL */
initGL();
var gl_vendor = str$ glGetString(GL_VENDOR);
var gl_renderer = str$ glGetString(GL_RENDERER);
var gl_version = str$ glGetString(GL_VERSION);
var gl_extensions = str$ glGetString(GL_EXTENSIONS);

print$ "GL vendor = " + gl_vendor; endl;
print$ "GL renderer = " + gl_renderer; endl;
print$ "GL version = " + gl_version; endl;
print$ "GL extensions = " + gl_extensions; endl;

/* resize the initial window */
resizeWindow( SCREEN_WIDTH, SCREEN_HEIGHT );

// SDL Event dispatcher
proc handle_active (e:SDL_ActiveEvent)
{
   isActive = e.gain != 0;
}

proc handle_resize(e:SDL_ResizeEvent)
{
  block_sdl_events event_lock;
  surface = SDL_SetVideoMode( 
    e.w,
    e.h,
    16, videoFlags 
  );
  if isNULL surface do
    print "Could not get a surface after resize"; endl;
  done;
  resizeWindow( e.w, e.h );
  unblock_sdl_events event_lock;
}

/* function to handle key press events */
proc handle_key( keysym : SDL_keysym)
{
  match keysym.sym with
  | ?k when k == SDLK_ESCAPE => { Quit 0; }
  | ?k when k ==  SDLK_F1 =>
	    { 
        block_sdl_events event_lock;
        ignore$ SDL_WM_ToggleFullScreen( surface ); 
        unblock_sdl_events event_lock;
      }
  | _ => {}
  endmatch;
}

/* draw the scene */
proc draw(drawing: 1->0) {
  if isActive call drawGLScene( drawing );
}

proc keychan(x:schannel[SDL_keysym])
{
  whilst true do
    var &k : SDL_keysym <- read x;
    handle_key k;
  done;
}

proc activechan(x:schannel[SDL_ActiveEvent])
{
  whilst true do
    var &k : SDL_ActiveEvent <- read x;
    handle_active k;
  done;
}

proc resizechan(x:schannel[SDL_ResizeEvent])
{
  whilst true do
    var &k : SDL_ResizeEvent <- read x;
    handle_resize k;
  done;
}

proc drawchan(x:schannel[int], drawing:1->0)
{
  whilst true do 
    var &k : int <- read x;
    draw drawing;
  done;
}

proc poll_event(e: &SDL_Event)
{
tryagain:>
  //print "Polling event"; endl;
  var result = SDL_PollEvent(unref e);
  if result > 0 do
    //print "Got event"; endl;
    return;
  done;
  Faio::sleep 0.1;
  goto tryagain;
}

proc dispatch_event(
  keyboard:schannel[SDL_keysym],
  active:schannel[SDL_ActiveEvent],
  resize:schannel[SDL_ResizeEvent]
)
{
  whilst true do
    // var &e : SDL_Event <- get_sdl_event event_lock;
    var e : SDL_Event;
    poll_event(&e);

    match e.type_ with
    | ?et when et == SDL_ACTIVEEVENT => 
      { write (active, e.active); }

    | ?et when et == SDL_VIDEORESIZE => 
      { write (resize, e.resize); }

    | ?et when et == SDL_KEYDOWN =>
      { write (keyboard, e.key.keysym); }

    | ?et when et == SDL_QUIT =>
      { Quit 0; }

    | _ => {}
    endmatch;
  done;
}

/* write ticks at the desired framerate */
proc framerate (x:schannel[int], framerate:double)
{
  whilst true do
    Faio::sleep framerate;
    write (x,1);
  done;
}

/* LINEAR CONTROL MODEL: CANNOT DEADLOCK 
  ~~> async/sync connection
  --> sync/sync connection
  
  SDL_event ~~> dispatcher 
                --> resize handler
                --> active handler
                --> key handler
  timer ~~> framerate --> draw                
*/

/* make our communication channels */
var keyboard = mk_schannel[SDL_keysym] ();
var active = mk_schannel[SDL_ActiveEvent] ();
var resize = mk_schannel[SDL_ResizeEvent] ();
var clicks = mk_schannel[int] ();

/* start up the fthreads and plug them together */
spawn_fthread { dispatch_event (keyboard, active, resize); };
spawn_fthread { resizechan resize; };
spawn_fthread { activechan active; };
spawn_fthread { keychan keyboard; };

spawn_fthread { drawchan (clicks, the Drawing); };
spawn_fthread { framerate (clicks, 0.1); };

// main thread hangs

// THE DRAWING
proc Drawing()
{
  /* Clear The Screen And The Depth Buffer */
  glClear( GL_COLOR_BUFFER_BIT \| GL_DEPTH_BUFFER_BIT );

  /* Move Left 1.5 Units And Into The Screen 6.0 */
  glLoadIdentity();
  glTranslatef( -1.5f, 0.0f, -6.0f );

  glBegin( GL_TRIANGLES );            /* Drawing Using Triangles */
    glVertex3f(  0.0f,  1.0f, 0.0f ); /* Top */
    glVertex3f( -1.0f, -1.0f, 0.0f ); /* Bottom Left */
    glVertex3f(  1.0f, -1.0f, 0.0f ); /* Bottom Right */
  glEnd( );                           /* Finished Drawing The Triangle */

  /* Move Right 3 Units */
  glTranslatef( 3.0f, 0.0f, 0.0f );

  glBegin( GL_QUADS );                /* Draw A Quad */
    glVertex3f( -1.0f,  1.0f, 0.0f ); /* Top Left */
    glVertex3f(  1.0f,  1.0f, 0.0f ); /* Top Right */
    glVertex3f(  1.0f, -1.0f, 0.0f ); /* Bottom Right */
    glVertex3f( -1.0f, -1.0f, 0.0f ); /* Bottom Left */
  glEnd( );                           /* Done Drawing The Quad */

  /* Draw it to the screen */
  SDL_GL_SwapBuffers( );
}

@h = tangler("tut/examples/sdl205.flx")
@select(h)
// REQUIRES OpenGL and GLU
/*
 * This code was created by Jeff Molofee '99 
 * (ported to Linux/SDL by Ti Leggett '01)
 *
 * If you've found this code useful, please let me know.
 *
 * Visit Jeff at http://nehe.gamedev.net/
 * 
 * or for port-specific comments, questions, bugreports etc. 
 * email to leggett@eecs.tulane.edu
 */

#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_video";
include "SDL/SDL_events";
include "SDL/SDL_timer";
include "SDL/SDL_mutex";
include "SDL/SDL_opengl";

include "flx_faio";
include "flx_faio_sdl";

open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;
open Float;

open SDL_h;
open SDL_video_h;
open SDL_keyboard_h;
open SDL_events_h;
open SDL_keysym_h;
open SDL_timer_h;
open SDL_mutex_h;

// This is the Felix asynchronous event source 
open SDL_events;

open SDL_opengl_h;

/* screen width, height, and bit depth */
val SCREEN_WIDTH  = 640;
val SCREEN_HEIGHT = 480;
val SCREEN_BPP = 16;

/* function to reset our viewport after a window resize */
proc resizeWindow( wwidth : int, hheight :int)
{
  var height = hheight;
  var width = wwidth;

  block_sdl_events event_lock;
  /* Protect against a divide by zero */
  if height == 0 do height = 1; done;
  var ratio = double_of width / double_of height;

  /* Setup our viewport. */
  glViewport( 0, 0, width, height );

  /* change to the projection matrix and set our viewing volume. */
  glMatrixMode( GL_PROJECTION );
  glLoadIdentity( );

  /* Set our perspective */
  gluPerspective( 45.0, ratio, 0.1, 100.0 );

  /* Make sure we're chaning the model view and not the projection */
  glMatrixMode( GL_MODELVIEW );

  /* Reset The View */
  glLoadIdentity( );
  unblock_sdl_events event_lock;
}

/* general OpenGL initialization function */
proc initGL()
{
  /* Enable smooth shading */
  glShadeModel( GL_SMOOTH );

  /* Set the background black */
  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

  /* Depth buffer setup */
  glClearDepth( 1.0 );

  /* Enables Depth Testing */
  glEnable( GL_DEPTH_TEST );

  /* The Type Of Depth Test To Do */
  glDepthFunc( GL_LEQUAL );

  /* Really Nice Perspective Calculations */
  glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
}

/* These are to calculate our fps */
var T0     = 0;
var Frames = 0;

var rtri = 0.0f; /* Triangle Rotation ( NEW ) */
var rquad = 0.0f; /* Quad Rotation ( NEW ) */

proc rotate()
{
  /* Increase The Rotation Variable For The Triangle ( NEW ) */
  rtri  += 0.2f;
  /* Decrease The Rotation Variable For The Quad     ( NEW ) */
  rquad -=0.15f;
}

/* Here goes our drawing code */
proc drawGLScene(drawing:1->0)
{
  block_sdl_events event_lock;
  drawing();
  unblock_sdl_events event_lock;

  /* Gather our frames per second */
  Frames++;
  {
    var t = SDL_GetTicks();
    if t - T0 >= 5000 do
      val seconds = double_of (t - T0) / 1000.0;
      val fps = double_of Frames / seconds;
      print Frames; print " frames in "; print seconds; 
      print " seconds = "; print fps; print " FPS"; endl;
      T0 = t;
      Frames = 0;
    done; 
  };
  rotate();
}

/* whether or not the window is active */
var isActive = true;

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var event_lock = SDL_CreateMutex();


proc Quit(n:int)
{
  SDL_Quit;
  System::exit 0;
}

/* Fetch the video info */
var videoInfo = SDL_GetVideoInfo();

if isNULL videoInfo do
  print "Video query failed"; endl; 
  Quit 1;
done;

/* the flags to pass to SDL_SetVideoMode */
var 
  videoFlags  = SDL_OPENGL;          /* Enable OpenGL in SDL */
  videoFlags |= cast[uint] SDL_GL_DOUBLEBUFFER; /* Enable double buffering */
  videoFlags |= SDL_HWPALETTE;       /* Store the palette in hardware */
  videoFlags |= SDL_RESIZABLE;       /* Enable window resizing */

/* This checks to see if surfaces can be stored in memory */
if  videoInfo.->hw_available != 0 do
	videoFlags |= SDL_HWSURFACE;
else
	videoFlags |= SDL_SWSURFACE;
done;

/* This checks if hardware blits can be done */
if videoInfo.->blit_hw != 0 do
	videoFlags |= SDL_HWACCEL;
done;

/* Sets up OpenGL double buffering */
ignore$ SDL_GL_SetAttribute( cast[SDL_GLattr] SDL_GL_DOUBLEBUFFER, 1 );

/* get a SDL surface */
var surface = SDL_SetVideoMode
  (SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, videoFlags )
;

/* Verify there is a surface */
if isNULL surface do
  print "Video mode set failed"; endl; 
  Quit 1;
done;

/* initialize OpenGL */
initGL();

/* resize the initial window */
resizeWindow( SCREEN_WIDTH, SCREEN_HEIGHT );

// SDL Event dispatcher
proc handle_active (e:SDL_ActiveEvent)
{
   isActive = e.gain != 0;
}

proc handle_resize(e:SDL_ResizeEvent)
{
  block_sdl_events event_lock;
  surface = SDL_SetVideoMode( 
    e.w,
    e.h,
    16, videoFlags 
  );
  if isNULL surface do
    print "Could not get a surface after resize"; endl;
  done;
  resizeWindow( e.w, e.h );
  unblock_sdl_events event_lock;
}

/* function to handle key press events */
proc handle_key( keysym : SDL_keysym)
{
  match keysym.sym with
  | ?k when k == SDLK_ESCAPE => { Quit 0; }
  | ?k when k ==  SDLK_F1 =>
	    { 
        block_sdl_events event_lock;
        ignore$ SDL_WM_ToggleFullScreen( surface ); 
        unblock_sdl_events event_lock;
      }
  | _ => {}
  endmatch;
}

/* draw the scene */
proc draw(drawing: 1->0) {
  if isActive call drawGLScene( drawing );
}

proc keychan(x:schannel[SDL_keysym])
{
  whilst true do
    var &k : SDL_keysym <- read x;
    handle_key k;
  done;
}

proc activechan(x:schannel[SDL_ActiveEvent])
{
  whilst true do
    var &k : SDL_ActiveEvent <- read x;
    handle_active k;
  done;
}

proc resizechan(x:schannel[SDL_ResizeEvent])
{
  whilst true do
    var &k : SDL_ResizeEvent <- read x;
    handle_resize k;
  done;
}

proc drawchan(x:schannel[int], drawing:1->0)
{
  whilst true do 
    var &k : int <- read x;
    draw drawing;
  done;
}

proc execute(x:schannel[int], something:1->0)
{
  whilst true do 
    var &k : int <- read x;
    something();
  done;
}

proc poll_event(e: &SDL_Event)
{
tryagain:>
  //print "Polling event"; endl;
  var result = SDL_PollEvent(unref e);
  if result > 0 do
    //print "Got event"; endl;
    return;
  done;
  Faio::sleep 0.1;
  goto tryagain;
}

proc dispatch_event(
  keyboard:schannel[SDL_keysym],
  active:schannel[SDL_ActiveEvent],
  resize:schannel[SDL_ResizeEvent]
)
{
  whilst true do
    //var &e : SDL_Event <- get_sdl_event event_lock;
    var e : SDL_Event;
    poll_event(&e);
    match e.type_ with
    | ?et when et == SDL_ACTIVEEVENT => 
      { write (active, e.active); }

    | ?et when et == SDL_VIDEORESIZE => 
      { write (resize, e.resize); }

    | ?et when et == SDL_KEYDOWN =>
      { write (keyboard, e.key.keysym); }

    | ?et when et == SDL_QUIT =>
      { Quit 0; }

    | _ => {}
    endmatch;
  done;
}

/* write ticks at the desired framerate */
proc framerate (x:schannel[int], framerate:double)
{
  whilst true do
    Faio::sleep framerate;
    write (x,1);
  done;
}

/* LINEAR CONTROL MODEL: CANNOT DEADLOCK 
  ~~> async/sync connection
  --> sync/sync connection
  
  SDL_event ~~> dispatcher 
                --> resize handler
                --> active handler
                --> key handler
  timer ~~> framerate --> draw                
*/

/* make our communication channels */
var keyboard = mk_schannel[SDL_keysym] ();
var active = mk_schannel[SDL_ActiveEvent] ();
var resize = mk_schannel[SDL_ResizeEvent] ();
var clicks = mk_schannel[int] ();
var rotation = mk_schannel[int] ();

/* start up the fthreads and plug them together */
spawn_fthread { dispatch_event (keyboard, active, resize); };
spawn_fthread { resizechan resize; };
spawn_fthread { activechan active; };
spawn_fthread { keychan keyboard; };

spawn_fthread { drawchan (clicks, the Drawing); };
spawn_fthread { framerate (clicks, 0.05); };
spawn_fthread { execute (rotation, the rotate); };
spawn_fthread { framerate (rotation, 0.1); };

// main thread hangs

/* Here goes our drawing code */
proc Drawing()
{
    /* Clear The Screen And The Depth Buffer */
    glClear( GL_COLOR_BUFFER_BIT \| GL_DEPTH_BUFFER_BIT );

    /* Move Left 1.5 Units And Into The Screen 6.0 */
    glLoadIdentity();
    glTranslatef( -1.5f, 0.0f, -6.0f );

    /* Rotate The Triangle On The Y axis ( NEW ) */
    glRotatef( rtri, 0.0f, 1.0f, 0.0f );

    glBegin( GL_TRIANGLES );             /* Drawing Using Triangles       */
      glColor3f(   1.0f,  0.0f,  0.0f ); /* Red                           */
      glVertex3f(  0.0f,  1.0f,  0.0f ); /* Top Of Triangle (Front)       */
      glColor3f(   0.0f,  1.0f,  0.0f ); /* Green                         */
      glVertex3f( -1.0f, -1.0f,  1.0f ); /* Left Of Triangle (Front)      */
      glColor3f(   0.0f,  0.0f,  1.0f ); /* Blue                          */
      glVertex3f(  1.0f, -1.0f,  1.0f ); /* Right Of Triangle (Front)     */

      glColor3f(   1.0f,  0.0f,  0.0f ); /* Red                           */
      glVertex3f(  0.0f,  1.0f,  0.0f ); /* Top Of Triangle (Right)       */
      glColor3f(   0.0f,  0.0f,  1.0f ); /* Blue                          */
      glVertex3f(  1.0f, -1.0f,  1.0f ); /* Left Of Triangle (Right)      */
      glColor3f(   0.0f,  1.0f,  0.0f ); /* Green                         */
      glVertex3f(  1.0f, -1.0f, -1.0f ); /* Right Of Triangle (Right)     */

      glColor3f(   1.0f,  0.0f,  0.0f ); /* Red                           */
      glVertex3f(  0.0f,  1.0f,  0.0f ); /* Top Of Triangle (Back)        */
      glColor3f(   0.0f,  1.0f,  0.0f ); /* Green                         */
      glVertex3f(  1.0f, -1.0f, -1.0f ); /* Left Of Triangle (Back)       */
      glColor3f(   0.0f,  0.0f,  1.0f ); /* Blue                          */
      glVertex3f( -1.0f, -1.0f, -1.0f ); /* Right Of Triangle (Back)      */

      glColor3f(   1.0f,  0.0f,  0.0f ); /* Red                           */
      glVertex3f(  0.0f,  1.0f,  0.0f ); /* Top Of Triangle (Left)        */
      glColor3f(   0.0f,  0.0f,  1.0f ); /* Blue                          */
      glVertex3f( -1.0f, -1.0f, -1.0f ); /* Left Of Triangle (Left)       */
      glColor3f(   0.0f,  1.0f,  0.0f ); /* Green                         */
      glVertex3f( -1.0f, -1.0f,  1.0f ); /* Right Of Triangle (Left)      */
    glEnd( );                            /* Finished Drawing The Triangle */

    /* Move Right 3 Units */
    glLoadIdentity( );
    glTranslatef( 1.5f, 0.0f, -6.0f );

    /* Rotate The Quad On The X axis ( NEW ) */
    glRotatef( rquad, 1.0f, 0.0f, 0.0f );

    /* Set The Color To Blue One Time Only */
    glColor3f( 0.5f, 0.5f, 1.0f);

    glBegin( GL_QUADS );                 /* Draw A Quad                      */
      glColor3f(   0.0f,  1.0f,  0.0f ); /* Set The Color To Green           */
      glVertex3f(  1.0f,  1.0f, -1.0f ); /* Top Right Of The Quad (Top)      */
      glVertex3f( -1.0f,  1.0f, -1.0f ); /* Top Left Of The Quad (Top)       */
      glVertex3f( -1.0f,  1.0f,  1.0f ); /* Bottom Left Of The Quad (Top)    */
      glVertex3f(  1.0f,  1.0f,  1.0f ); /* Bottom Right Of The Quad (Top)   */

      glColor3f(   1.0f,  0.5f,  0.0f ); /* Set The Color To Orange          */
      glVertex3f(  1.0f, -1.0f,  1.0f ); /* Top Right Of The Quad (Botm)     */
      glVertex3f( -1.0f, -1.0f,  1.0f ); /* Top Left Of The Quad (Botm)      */
      glVertex3f( -1.0f, -1.0f, -1.0f ); /* Bottom Left Of The Quad (Botm)   */
      glVertex3f(  1.0f, -1.0f, -1.0f ); /* Bottom Right Of The Quad (Botm)  */

      glColor3f(   1.0f,  0.0f,  0.0f ); /* Set The Color To Red             */
      glVertex3f(  1.0f,  1.0f,  1.0f ); /* Top Right Of The Quad (Front)    */
      glVertex3f( -1.0f,  1.0f,  1.0f ); /* Top Left Of The Quad (Front)     */
      glVertex3f( -1.0f, -1.0f,  1.0f ); /* Bottom Left Of The Quad (Front)  */
      glVertex3f(  1.0f, -1.0f,  1.0f ); /* Bottom Right Of The Quad (Front) */

      glColor3f(   1.0f,  1.0f,  0.0f ); /* Set The Color To Yellow          */
      glVertex3f(  1.0f, -1.0f, -1.0f ); /* Bottom Left Of The Quad (Back)   */
      glVertex3f( -1.0f, -1.0f, -1.0f ); /* Bottom Right Of The Quad (Back)  */
      glVertex3f( -1.0f,  1.0f, -1.0f ); /* Top Right Of The Quad (Back)     */
      glVertex3f(  1.0f,  1.0f, -1.0f ); /* Top Left Of The Quad (Back)      */

      glColor3f(   0.0f,  0.0f,  1.0f ); /* Set The Color To Blue            */
      glVertex3f( -1.0f,  1.0f,  1.0f ); /* Top Right Of The Quad (Left)     */
      glVertex3f( -1.0f,  1.0f, -1.0f ); /* Top Left Of The Quad (Left)      */
      glVertex3f( -1.0f, -1.0f, -1.0f ); /* Bottom Left Of The Quad (Left)   */
      glVertex3f( -1.0f, -1.0f,  1.0f ); /* Bottom Right Of The Quad (Left)  */

      glColor3f(   1.0f,  0.0f,  1.0f ); /* Set The Color To Violet          */
      glVertex3f(  1.0f,  1.0f, -1.0f ); /* Top Right Of The Quad (Right)    */
      glVertex3f(  1.0f,  1.0f,  1.0f ); /* Top Left Of The Quad (Right)     */
      glVertex3f(  1.0f, -1.0f,  1.0f ); /* Bottom Left Of The Quad (Right)  */
      glVertex3f(  1.0f, -1.0f, -1.0f ); /* Bottom Right Of The Quad (Right) */
    glEnd( );                            /* Done Drawing The Quad            */

    /* Draw it to the screen */
    SDL_GL_SwapBuffers( );
}

@h = tangler("tut/examples/sdl206.flx")
@select(h)
// REQUIRES OpenGL and GLU
/*
 * This code was created by Jeff Molofee '99 
 * (ported to Linux/SDL by Ti Leggett '01)
 *
 * If you've found this code useful, please let me know.
 *
 * Visit Jeff at http://nehe.gamedev.net/
 * 
 * or for port-specific comments, questions, bugreports etc. 
 * email to leggett@eecs.tulane.edu
 */

#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_video";
include "SDL/SDL_events";
include "SDL/SDL_timer";
include "SDL/SDL_mutex";
include "SDL/SDL_opengl";

include "flx_faio";
include "flx_faio_sdl";


open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;
open Float;

open SDL_h;
open SDL_video_h;
open SDL_keyboard_h;
open SDL_events_h;
open SDL_keysym_h;
open SDL_timer_h;
open SDL_mutex_h;

// This is the Felix asynchronous event source 
open SDL_events;

open SDL_opengl_h;

/* screen width, height, and bit depth */
val SCREEN_WIDTH  = 640;
val SCREEN_HEIGHT = 480;
val SCREEN_BPP = 16;

/* function to reset our viewport after a window resize */
proc resizeWindow( wwidth : int, hheight :int)
{
  var height = hheight;
  var width = wwidth;

  /* Protect against a divide by zero */
  if height == 0 do height = 1; done;
  var ratio = double_of width / double_of height;

  block_sdl_events event_lock;
  /* Setup our viewport. */
  glViewport( 0, 0, width, height );

  /* change to the projection matrix and set our viewing volume. */
  glMatrixMode( GL_PROJECTION );
  glLoadIdentity( );

  /* Set our perspective */
  gluPerspective( 45.0, ratio, 0.1, 100.0 );

  /* Make sure we're chaning the model view and not the projection */
  glMatrixMode( GL_MODELVIEW );

  /* Reset The View */
  glLoadIdentity( );
  unblock_sdl_events event_lock;
}

/* function to load in bitmap as a GL texture */
proc LoadGLTextures( )
{
  /* Create storage space for the texture */
  var TextureImage = SDL_LoadBMP(enconst c"media/textures/sdl206.bmp");
  if isNULL TextureImage do
    print "Can't load texture file media/textures/sdl206.bmp";
    Quit 1;
  done;

  /* Create The Texture */
	glGenTextures( 1, texture );

  /* Typical Texture Generation Using Data From The Bitmap */
  glBindTexture( GL_TEXTURE_2D, texture.[0] );

	/* Generate The Texture */
  glTexImage2D( GL_TEXTURE_2D, 0, 3, TextureImage.->w,
    TextureImage.->h, 0, GL_RGB,
    GL_UNSIGNED_BYTE, TextureImage.->pixels 
  );

  /* Linear Filtering */
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

  /* Free up any memory we may have used */
	SDL_FreeSurface( TextureImage );
}

/* general OpenGL initialization function */
proc initGL()
{
  /* Enable Texture Mapping ( NEW ) */
  glEnable( GL_TEXTURE_2D );

  /* Enable smooth shading */
  glShadeModel( GL_SMOOTH );

  /* Set the background black */
  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

  /* Depth buffer setup */
  glClearDepth( 1.0 );

  /* Enables Depth Testing */
  glEnable( GL_DEPTH_TEST );

  /* The Type Of Depth Test To Do */
  glDepthFunc( GL_LEQUAL );

  /* Really Nice Perspective Calculations */
  glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );
}

/* These are to calculate our fps */
var T0     = 0;
var Frames = 0;

var xrot = 0.0f; /* X Rotation ( NEW ) */
var yrot = 0.0f; /* Y Rotation ( NEW ) */
var zrot = 0.0f; /* Z Rotation ( NEW ) */

proc rotate()
{
  xrot += 0.3f; /* X Axis Rotation */
  yrot += 0.2f; /* Y Axis Rotation */
  zrot += 0.4f; /* Z Axis Rotation */
}

var f_texture : uint ^ 1; /* Storage For One Texture ( NEW ) */
var texture : ptr[uint] = carray_of f_texture;


/* Here goes our drawing code */
proc drawGLScene(drawing:1->0)
{
  block_sdl_events event_lock;
  drawing();
  unblock_sdl_events event_lock;

  /* Gather our frames per second */
  Frames++;
  {
    var t = SDL_GetTicks();
    if t - T0 >= 5000 do
      val seconds = double_of (t - T0) / 1000.0;
      val fps = double_of Frames / seconds;
      print Frames; print " frames in "; print seconds; 
      print " seconds = "; print fps; print " FPS"; endl;
      T0 = t;
      Frames = 0;
    done; 
  };
  rotate();
}

/* whether or not the window is active */
var isActive = true;

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var event_lock = SDL_CreateMutex();


proc Quit(n:int)
{
  SDL_Quit;
  System::exit 0;
}

/* Fetch the video info */
var videoInfo = SDL_GetVideoInfo();

if isNULL videoInfo do
  print "Video query failed"; endl; 
  Quit 1;
done;

/* the flags to pass to SDL_SetVideoMode */
var 
  videoFlags  = SDL_OPENGL;          /* Enable OpenGL in SDL */
  videoFlags |= cast[uint] SDL_GL_DOUBLEBUFFER; /* Enable double buffering */
  videoFlags |= SDL_HWPALETTE;       /* Store the palette in hardware */
  videoFlags |= SDL_RESIZABLE;       /* Enable window resizing */

/* This checks to see if surfaces can be stored in memory */
if  videoInfo.->hw_available != 0 do
	videoFlags |= SDL_HWSURFACE;
else
	videoFlags |= SDL_SWSURFACE;
done;

/* This checks if hardware blits can be done */
if videoInfo.->blit_hw != 0 do
	videoFlags |= SDL_HWACCEL;
done;

/* Sets up OpenGL double buffering */
ignore$ SDL_GL_SetAttribute( cast[SDL_GLattr] SDL_GL_DOUBLEBUFFER, 1 );

/* get a SDL surface */
var surface = SDL_SetVideoMode
  (SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, videoFlags )
;

/* Verify there is a surface */
if isNULL surface do
  print "Video mode set failed"; endl; 
  Quit 1;
done;

/* initialize OpenGL */
initGL();
LoadGLTextures();

/* resize the initial window */
resizeWindow( SCREEN_WIDTH, SCREEN_HEIGHT );

// SDL Event dispatcher
proc handle_active (e:SDL_ActiveEvent)
{
   isActive = e.gain != 0;
}

proc handle_resize(e:SDL_ResizeEvent)
{
  block_sdl_events event_lock;
  surface = SDL_SetVideoMode( 
    e.w,
    e.h,
    16, videoFlags 
  );
  if isNULL surface do
    print "Could not get a surface after resize"; endl;
  done;
  resizeWindow( e.w, e.h );
  unblock_sdl_events event_lock;
}

/* function to handle key press events */
proc handle_key( keysym : SDL_keysym)
{
  match keysym.sym with
  | ?k when k == SDLK_ESCAPE => { Quit 0; }
  | ?k when k ==  SDLK_F1 =>
	    { 
        block_sdl_events event_lock;
        ignore$ SDL_WM_ToggleFullScreen( surface ); 
        unblock_sdl_events event_lock;
      }
  | _ => {}
  endmatch;
}

/* draw the scene */
proc draw(drawing: 1->0) {
  if isActive call drawGLScene( drawing );
}

proc keychan(x:schannel[SDL_keysym])
{
  whilst true do
    var &k : SDL_keysym <- read x;
    handle_key k;
  done;
}

proc activechan(x:schannel[SDL_ActiveEvent])
{
  whilst true do
    var &k : SDL_ActiveEvent <- read x;
    handle_active k;
  done;
}

proc resizechan(x:schannel[SDL_ResizeEvent])
{
  whilst true do
    var &k : SDL_ResizeEvent <- read x;
    handle_resize k;
  done;
}

proc drawchan(x:schannel[int], drawing:1->0)
{
  whilst true do 
    var &k : int <- read x;
    draw drawing;
  done;
}

proc execute(x:schannel[int], something:1->0)
{
  whilst true do 
    var &k : int <- read x;
    something();
  done;
}

proc poll_event(e: &SDL_Event)
{
tryagain:>
  //print "Polling event"; endl;
  var result = SDL_PollEvent(unref e);
  if result > 0 do
    //print "Got event"; endl;
    return;
  done;
  Faio::sleep 0.1;
  goto tryagain;
}


proc dispatch_event(
  keyboard:schannel[SDL_keysym],
  active:schannel[SDL_ActiveEvent],
  resize:schannel[SDL_ResizeEvent]
)
{
  whilst true do
    //var &e : SDL_Event <- get_sdl_event event_lock;
    var e : SDL_Event;
    poll_event(&e);
    match e.type_ with
    | ?et when et == SDL_ACTIVEEVENT => 
      { write (active, e.active); }

    | ?et when et == SDL_VIDEORESIZE => 
      { write (resize, e.resize); }

    | ?et when et == SDL_KEYDOWN =>
      { write (keyboard, e.key.keysym); }

    | ?et when et == SDL_QUIT =>
      { Quit 0; }

    | _ => {}
    endmatch;
  done;
}

/* write ticks at the desired framerate */
proc framerate (x:schannel[int], framerate:double)
{
  whilst true do
    Faio::sleep framerate;
    write (x,1);
  done;
}

/* LINEAR CONTROL MODEL: CANNOT DEADLOCK 
  ~~> async/sync connection
  --> sync/sync connection
  
  SDL_event ~~> dispatcher 
                --> resize handler
                --> active handler
                --> key handler
  timer ~~> framerate --> draw                
*/

/* make our communication channels */
var keyboard = mk_schannel[SDL_keysym] ();
var active = mk_schannel[SDL_ActiveEvent] ();
var resize = mk_schannel[SDL_ResizeEvent] ();
var clicks = mk_schannel[int] ();
var rotation = mk_schannel[int] ();

/* start up the fthreads and plug them together */
spawn_fthread { dispatch_event (keyboard, active, resize); };
spawn_fthread { resizechan resize; };
spawn_fthread { activechan active; };
spawn_fthread { keychan keyboard; };

spawn_fthread { drawchan (clicks, the Drawing); };
spawn_fthread { framerate (clicks, 0.1); };
spawn_fthread { execute (rotation, the rotate); };
spawn_fthread { framerate (rotation, 0.1); };


// main thread hangs

/* Here goes our drawing code */
proc Drawing()
{
    /* Clear The Screen And The Depth Buffer */
    glClear( GL_COLOR_BUFFER_BIT \| GL_DEPTH_BUFFER_BIT );

    /* Move Into The Screen 5 Units */
    glLoadIdentity( );
    glTranslatef( 0.0f, 0.0f, -5.0f );

    glRotatef( xrot, 1.0f, 0.0f, 0.0f); /* Rotate On The X Axis */
    glRotatef( yrot, 0.0f, 1.0f, 0.0f); /* Rotate On The Y Axis */
    glRotatef( zrot, 0.0f, 0.0f, 1.0f); /* Rotate On The Z Axis */

    /* Select Our Texture */
    glBindTexture( GL_TEXTURE_2D, texture.[0] );

    /* NOTE:
     *   The x coordinates of the glTexCoord2f function need to inverted
     * for SDL because of the way SDL_LoadBmp loads the data. So where
     * in the tutorial it has glTexCoord2f( 1.0f, 0.0f ); it should
     * now read glTexCoord2f( 0.0f, 0.0f );
     */
    glBegin(GL_QUADS);
      /* Front Face */
      /* Bottom Left Of The Texture and Quad */
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f, -1.0f, 1.0f );
      /* Bottom Right Of The Texture and Quad */
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  1.0f, -1.0f, 1.0f );
      /* Top Right Of The Texture and Quad */
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f(  1.0f,  1.0f, 1.0f );
      /* Top Left Of The Texture and Quad */
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f,  1.0f, 1.0f );

      /* Back Face */
      /* Bottom Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f, -1.0f );
      /* Top Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, -1.0f );
      /* Top Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  1.0f,  1.0f, -1.0f );
      /* Bottom Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f(  1.0f, -1.0f, -1.0f );

      /* Top Face */
      /* Top Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, -1.0f );
      /* Bottom Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f( -1.0f,  1.0f,  1.0f );
      /* Bottom Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f(  1.0f,  1.0f,  1.0f );
      /* Top Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f(  1.0f,  1.0f, -1.0f );

      /* Bottom Face */
      /* Top Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f, -1.0f, -1.0f );
      /* Top Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  1.0f, -1.0f, -1.0f );
      /* Bottom Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f(  1.0f, -1.0f,  1.0f );
      /* Bottom Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f,  1.0f );

      /* Right face */
      /* Bottom Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f( 1.0f, -1.0f, -1.0f );
      /* Top Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f( 1.0f,  1.0f, -1.0f );
      /* Top Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f( 1.0f,  1.0f,  1.0f );
      /* Bottom Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f( 1.0f, -1.0f,  1.0f );

      /* Left Face */
      /* Bottom Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f( -1.0f, -1.0f, -1.0f );
      /* Bottom Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f,  1.0f );
      /* Top Right Of The Texture and Quad */
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f,  1.0f,  1.0f );
      /* Top Left Of The Texture and Quad */
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, -1.0f );
    glEnd( );

    /* Draw it to the screen */
    SDL_GL_SwapBuffers( );
}

@h = tangler("tut/examples/sdl208.flx")
@select(h)
// REQUIRES OpenGL and GLU
/*
 * This code was created by Jeff Molofee '99 
 * (ported to Linux/SDL by Ti Leggett '01)
 *
 * If you've found this code useful, please let me know.
 *
 * Visit Jeff at http://nehe.gamedev.net/
 * 
 * or for port-specific comments, questions, bugreports etc. 
 * email to leggett@eecs.tulane.edu
 */

#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_video";
include "SDL/SDL_events";
include "SDL/SDL_timer";
include "SDL/SDL_mutex";
include "SDL/SDL_opengl";

include "flx_faio";
include "flx_faio_sdl";

open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;
open Float;

open SDL_h;
open SDL_video_h;
open SDL_keyboard_h;
open SDL_events_h;
open SDL_keysym_h;
open SDL_timer_h;
open SDL_mutex_h;

// This is the Felix asynchronous event source 
open SDL_events;

open SDL_opengl_h;

/* screen width, height, and bit depth */
val SCREEN_WIDTH  = 640;
val SCREEN_HEIGHT = 480;
val SCREEN_BPP = 16;

/* function to reset our viewport after a window resize */
proc resizeWindow( wwidth : int, hheight :int)
{
  var height = hheight;
  var width = wwidth;

  /* Protect against a divide by zero */
  if height == 0 do height = 1; done;
  var ratio = double_of width / double_of height;

  block_sdl_events event_lock;
  /* Setup our viewport. */
  glViewport( 0, 0, width, height );

  /* change to the projection matrix and set our viewing volume. */
  glMatrixMode( GL_PROJECTION );
  glLoadIdentity( );

  /* Set our perspective */
  gluPerspective( 45.0, ratio, 0.1, 100.0 );

  /* Make sure we're chaning the model view and not the projection */
  glMatrixMode( GL_MODELVIEW );

  /* Reset The View */
  glLoadIdentity( );
  unblock_sdl_events event_lock;
}

/* function to load in bitmap as a GL texture */
proc LoadGLTextures( )
{
  /* Create storage space for the texture */
  var TextureImage = SDL_LoadBMP(enconst c"media/textures/sdl208.bmp");
  if isNULL TextureImage do
    print "Can't load texture file media/textures/sdl206.bmp";
    Quit 1;
  done;

  /* Create The Texture */
	glGenTextures( 3, texture );

  /* Typical Texture Generation Using Data From The Bitmap */
  glBindTexture( GL_TEXTURE_2D, texture.[0] );

	/* Generate The Texture */
  glTexImage2D( GL_TEXTURE_2D, 0, 3, TextureImage.->w,
    TextureImage.->h, 0, GL_RGB,
    GL_UNSIGNED_BYTE, TextureImage.->pixels 
  );

  /* Linear Filtering */
  glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );

  glBindTexture( GL_TEXTURE_2D, texture.[1] );

  /* Linear Filtering */
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

	/* Generate The Texture */
  glTexImage2D( GL_TEXTURE_2D, 0, 3, TextureImage.->w,
    TextureImage.->h, 0, cast[uint] GL_RGB,
    GL_UNSIGNED_BYTE, TextureImage.->pixels 
  );

  glBindTexture( GL_TEXTURE_2D, texture.[2] );

  /* Linear Filtering */
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_NEAREST );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR_MIPMAP_NEAREST );

  /* Generate The MipMapped Texture ( NEW ) */
  ignore(gluBuild2DMipmaps( 
    GL_TEXTURE_2D, 3, 
    TextureImage.->w, TextureImage.->h, 
    GL_RGB, GL_UNSIGNED_BYTE, 
    cast[caddress] TextureImage.->pixels 
  ));

  /* Free up any memory we may have used */
	SDL_FreeSurface( TextureImage );
}

/* general OpenGL initialization function */
proc initGL()
{
  /* Enable Texture Mapping ( NEW ) */
  glEnable( GL_TEXTURE_2D );

  /* Enable smooth shading */
  glShadeModel( GL_SMOOTH );

  /* Set the background black */
  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

  /* Depth buffer setup */
  glClearDepth( 1.0 );

  /* Enables Depth Testing */
  glEnable( GL_DEPTH_TEST );

  /* The Type Of Depth Test To Do */
  glDepthFunc( GL_LEQUAL );

  /* Really Nice Perspective Calculations */
  glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );

  /* Setup The Ambient Light */
  glLightfv( GL_LIGHT1, GL_AMBIENT, enconst (carray_of LightAmbient) );

  /* Setup The Diffuse Light */
  glLightfv( GL_LIGHT1, GL_DIFFUSE, enconst (carray_of LightDiffuse) );

  /* Position The Light */
  glLightfv( GL_LIGHT1, GL_POSITION, enconst (carray_of LightPosition) );

  /* Enable Light One */
  glEnable( GL_LIGHT1 );

  /* Full Brightness, 50% Alpha ( NEW ) */
  glColor4f( 1.0f, 1.0f, 1.0f, 0.5f);

  /* Blending Function For Translucency Based On Source Alpha Value  */
  glBlendFunc( GL_SRC_ALPHA, GL_ONE );
}

/* These are to calculate our fps */
var T0     = 0;
var Frames = 0;

var xrot = 0.0f; /* X Rotation ( NEW ) */
var yrot = 0.0f; /* Y Rotation ( NEW ) */
var z = -5.0f;   /* Depth Into The Screen */

var xspeed = 0.0f;
var yspeed = 0.0f;

proc rotate()
{
  xrot += xspeed; /* Add xspeed To xrot */
  yrot += yspeed; /* Add yspeed To yrot */
}


var light = false; /* Whether or not lighting is on */
var blend = false; /* Whether or not blending is on */


/* Ambient Light Values ( NEW ) */
var LightAmbient =  0.5f, 0.5f, 0.5f, 1.0f;

/* Diffuse Light Values ( NEW ) */
var LightDiffuse  = 1.0f, 1.0f, 1.0f, 1.0f;

/* Light Position ( NEW ) */
var LightPosition = 0.0f, 0.0f, 2.0f, 1.0f;

var filter = 0;

var f_texture : uint ^ 3; /* Storage For 3 Textures ( NEW ) */
var texture : ptr[uint] = carray_of f_texture;


/* Here goes our drawing code */
proc drawGLScene(drawing:1->0)
{
  block_sdl_events event_lock;
  drawing();
  unblock_sdl_events event_lock;

  /* Gather our frames per second */
  Frames++;
  {
    var t = SDL_GetTicks();
    if t - T0 >= 5000 do
      val seconds = double_of (t - T0) / 1000.0;
      val fps = double_of Frames / seconds;
      print Frames; print " frames in "; print seconds; 
      print " seconds = "; print fps; print " FPS"; endl;
      T0 = t;
      Frames = 0;
    done; 
  };
  rotate();
}

/* whether or not the window is active */
var isActive = true;

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var event_lock = SDL_CreateMutex();


proc Quit(n:int)
{
  SDL_Quit;
  System::exit 0;
}

/* Fetch the video info */
var videoInfo = SDL_GetVideoInfo();

if isNULL videoInfo do
  print "Video query failed"; endl; 
  Quit 1;
done;

/* the flags to pass to SDL_SetVideoMode */
var 
  videoFlags  = SDL_OPENGL;          /* Enable OpenGL in SDL */
  videoFlags |= cast[uint] SDL_GL_DOUBLEBUFFER; /* Enable double buffering */
  videoFlags |= SDL_HWPALETTE;       /* Store the palette in hardware */
  videoFlags |= SDL_RESIZABLE;       /* Enable window resizing */

/* This checks to see if surfaces can be stored in memory */
if  videoInfo.->hw_available != 0 do
	videoFlags |= SDL_HWSURFACE;
else
	videoFlags |= SDL_SWSURFACE;
done;

/* This checks if hardware blits can be done */
if videoInfo.->blit_hw != 0 do
	videoFlags |= SDL_HWACCEL;
done;

/* Sets up OpenGL double buffering */
ignore$ SDL_GL_SetAttribute( cast[SDL_GLattr] SDL_GL_DOUBLEBUFFER, 1 );

/* get a SDL surface */
var surface = SDL_SetVideoMode
  (SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, videoFlags )
;

/* Verify there is a surface */
if isNULL surface do
  print "Video mode set failed"; endl; 
  Quit 1;
done;

/* initialize OpenGL */
initGL();
LoadGLTextures();

/* resize the initial window */
resizeWindow( SCREEN_WIDTH, SCREEN_HEIGHT );

// SDL Event dispatcher
proc handle_active (e:SDL_ActiveEvent)
{
   isActive = e.gain != 0;
}

proc handle_resize(e:SDL_ResizeEvent)
{
  block_sdl_events event_lock;
  surface = SDL_SetVideoMode( 
    e.w,
    e.h,
    16, videoFlags 
  );
  if isNULL surface do
    print "Could not get a surface after resize"; endl;
  done;
  resizeWindow( e.w, e.h );
  unblock_sdl_events event_lock;
}

/* function to handle key press events */
proc handle_key( keysym : SDL_keysym)
{
  match keysym.sym with
  | ?k when k == SDLK_ESCAPE => { Quit 0; }
  | ?k when k ==  SDLK_F1 =>
	    { ignore$ SDL_WM_ToggleFullScreen( surface ); }
  | ?k when k == SDLK_b => 
    { 
      blend = not blend; 
      if blend do
		    glEnable( GL_BLEND );
		    glDisable( GL_DEPTH_TEST );
      else
		    glDisable( GL_BLEND );
		    glEnable( GL_DEPTH_TEST );
      done;
    }
  | ?k when k == SDLK_f => 
    {
	    filter = ( filter + 1) % 3;
      print "Filter "; print filter; endl;
    }
  | ?k when k == SDLK_l => 
    {
	    light = not light;
	    if not light do
        glDisable( GL_LIGHTING );
 	    else
        glEnable( GL_LIGHTING );
	    done;
    }
  | ?k when k == SDLK_PAGEUP => 
    {
	    z = z - 0.02f;
    }

  | ?k when k == SDLK_PAGEDOWN => 
    {
	    z = z + 0.02f;
    }

  | ?k when k == SDLK_UP => 
    {
      xspeed = xspeed - 0.01f;
    }

  | ?k when k == SDLK_DOWN => 
    {
      xspeed = xspeed + 0.01f;
    }

  | ?k when k == SDLK_RIGHT => 
    {
      yspeed = yspeed + 0.01f;
    }

  | ?k when k == SDLK_LEFT => 
    {
      yspeed = yspeed - 0.01f;
    }

  | _ => {}
  endmatch;
}

/* draw the scene */
proc draw(drawing: 1->0) {
  if isActive call drawGLScene( drawing );
}

proc keychan(x:schannel[SDL_keysym])
{
  whilst true do
    var &k : SDL_keysym <- read x;
    handle_key k;
  done;
}

proc activechan(x:schannel[SDL_ActiveEvent])
{
  whilst true do
    var &k : SDL_ActiveEvent <- read x;
    handle_active k;
  done;
}

proc resizechan(x:schannel[SDL_ResizeEvent])
{
  whilst true do
    var &k : SDL_ResizeEvent <- read x;
    handle_resize k;
  done;
}

proc drawchan(x:schannel[int], drawing:1->0)
{
  whilst true do 
    var &k : int <- read x;
    draw drawing;
  done;
}

proc execute(x:schannel[int], something:1->0)
{
  whilst true do 
    var &k : int <- read x;
    something();
  done;
}

proc poll_event(e: &SDL_Event)
{
tryagain:>
  //print "Polling event"; endl;
  var result = SDL_PollEvent(unref e);
  if result > 0 do
    //print "Got event"; endl;
    return;
  done;
  Faio::sleep 0.1;
  goto tryagain;
}

proc dispatch_event(
  keyboard:schannel[SDL_keysym],
  active:schannel[SDL_ActiveEvent],
  resize:schannel[SDL_ResizeEvent]
)
{
  whilst true do
    //var &e : SDL_Event <- get_sdl_event event_lock;
    var e : SDL_Event;
    poll_event(&e);
    match e.type_ with
    | ?et when et == SDL_ACTIVEEVENT => 
      { write (active, e.active); }

    | ?et when et == SDL_VIDEORESIZE => 
      { write (resize, e.resize); }

    | ?et when et == SDL_KEYDOWN =>
      { write (keyboard, e.key.keysym); }

    | ?et when et == SDL_QUIT =>
      { Quit 0; }

    | _ => {}
    endmatch;
  done;
}

/* write ticks at the desired framerate */
proc framerate (x:schannel[int], framerate:double)
{
  whilst true do
    Faio::sleep framerate;
    write (x,1);
  done;
}

/* LINEAR CONTROL MODEL: CANNOT DEADLOCK 
  ~~> async/sync connection
  --> sync/sync connection
  
  SDL_event ~~> dispatcher 
                --> resize handler
                --> active handler
                --> key handler
  timer ~~> framerate --> draw                
*/

/* make our communication channels */
var keyboard = mk_schannel[SDL_keysym] ();
var active = mk_schannel[SDL_ActiveEvent] ();
var resize = mk_schannel[SDL_ResizeEvent] ();
var clicks = mk_schannel[int] ();
var rotation = mk_schannel[int] ();

/* start up the fthreads and plug them together */
spawn_fthread { dispatch_event (keyboard, active, resize); };
spawn_fthread { resizechan resize; };
spawn_fthread { activechan active; };
spawn_fthread { keychan keyboard; };

spawn_fthread { drawchan (clicks, the Drawing); };
spawn_fthread { framerate (clicks, 0.05); };
spawn_fthread { execute (rotation, the rotate); };
spawn_fthread { framerate (rotation, 0.01); };


// main thread hangs

/* Here goes our drawing code */
proc Drawing()
{
  /* Clear The Screen And The Depth Buffer */
  glClear( GL_COLOR_BUFFER_BIT \| GL_DEPTH_BUFFER_BIT );

  /* Reset the view */
  glLoadIdentity( );

  /* Translate Into/Out Of The Screen By z */
  glTranslatef( 0.0f, 0.0f, z );

  glRotatef( xrot, 1.0f, 0.0f, 0.0f); /* Rotate On The X Axis By xrot */
  glRotatef( yrot, 0.0f, 1.0f, 0.0f); /* Rotate On The Y Axis By yrot */

  /* Select A Texture Based On filter */
  glBindTexture( GL_TEXTURE_2D, texture.[filter] );

  /* Start Drawing Quads */
  glBegin( GL_QUADS );
    /* Front Face */
    /* Normal Pointing Towards Viewer */
    glNormal3f( 0.0f, 0.0f, 1.0f );
    /* Point 1 (Front) */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f( -1.0f, -1.0f,  1.0f );
    /* Point 2 (Front) */
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f(  1.0f, -1.0f,  1.0f );
    /* Point 3 (Front) */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f(  1.0f,  1.0f,  1.0f );
    /* Point 4 (Front) */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f( -1.0f,  1.0f,  1.0f );

    /* Back Face */
    /* Normal Pointing Away From Viewer */
    glNormal3f( 0.0f, 0.0f, -1.0f);
    /* Point 1 (Back) */
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f, -1.0f );
    /* Point 2 (Back) */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, -1.0f );
    /* Point 3 (Back) */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  1.0f,  1.0f, -1.0f );
    /* Point 4 (Back) */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f(  1.0f, -1.0f, -1.0f );

    /* Top Face */
    /* Normal Pointing Up */
    glNormal3f( 0.0f, 1.0f, 0.0f );
    /* Point 1 (Top) */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, -1.0f );
    /* Point 2 (Top) */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f( -1.0f,  1.0f,  1.0f );
    /* Point 3 (Top) */
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f(  1.0f,  1.0f,  1.0f );
    /* Point 4 (Top) */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f(  1.0f,  1.0f, -1.0f );

    /* Bottom Face */
    /* Normal Pointing Down */
    glNormal3f( 0.0f, -1.0f, 0.0f );
    /* Point 1 (Bottom) */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f, -1.0f, -1.0f );
    /* Point 2 (Bottom) */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  1.0f, -1.0f, -1.0f );
    /* Point 3 (Bottom) */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f(  1.0f, -1.0f,  1.0f );
    /* Point 4 (Bottom) */
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f,  1.0f );

    /* Right face */
    /* Normal Pointing Right */
    glNormal3f( 1.0f, 0.0f, 0.0f);
    /* Point 1 (Right) */
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f( 1.0f, -1.0f, -1.0f );
    /* Point 2 (Right) */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f( 1.0f,  1.0f, -1.0f );
    /* Point 3 (Right) */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f( 1.0f,  1.0f,  1.0f );
    /* Point 4 (Right) */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f( 1.0f, -1.0f,  1.0f );

    /* Left Face*/
    /* Normal Pointing Left */
    glNormal3f( -1.0f, 0.0f, 0.0f );
    /* Point 1 (Left) */
    glTexCoord2f( 1.0f, 0.0f ); glVertex3f( -1.0f, -1.0f, -1.0f );
    /* Point 2 (Left) */
    glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f,  1.0f );
    /* Point 3 (Left) */
    glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f,  1.0f,  1.0f );
    /* Point 4 (Left) */
    glTexCoord2f( 1.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, -1.0f );
  glEnd();

  /* Draw it to the screen */
  SDL_GL_SwapBuffers( );

}

@h = tangler("tut/examples/sdl209.flx")
@select(h)
// REQUIRES OpenGL and GLU
/*
 * This code was created by Jeff Molofee '99 
 * (ported to Linux/SDL by Ti Leggett '01)
 *
 * If you've found this code useful, please let me know.
 *
 * Visit Jeff at http://nehe.gamedev.net/
 * 
 * or for port-specific comments, questions, bugreports etc. 
 * email to leggett@eecs.tulane.edu
 */

#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_keyboard";
include "SDL/SDL_keysym";
include "SDL/SDL_video";
include "SDL/SDL_events";
include "SDL/SDL_timer";
include "SDL/SDL_mutex";
include "SDL/SDL_opengl";

include "flx_faio";
include "flx_faio_sdl";

open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;
open Float;

open SDL_h;
open SDL_video_h;
open SDL_keyboard_h;
open SDL_events_h;
open SDL_keysym_h;
open SDL_timer_h;
open SDL_mutex_h;

// This is the Felix asynchronous event source 
open SDL_events;

open SDL_opengl_h;

/* screen width, height, and bit depth */
val SCREEN_WIDTH  = 640;
val SCREEN_HEIGHT = 480;
val SCREEN_BPP = 16;
macro val NUM = 50;

/* function to reset our viewport after a window resize */
proc resizeWindow( wwidth : int, hheight :int)
{
  var height = hheight;
  var width = wwidth;

  /* Protect against a divide by zero */
  if height == 0 do height = 1; done;
  var ratio = double_of width / double_of height;

  block_sdl_events event_lock;
  /* Setup our viewport. */
  glViewport( 0, 0, width, height );

  /* change to the projection matrix and set our viewing volume. */
  glMatrixMode( GL_PROJECTION );
  glLoadIdentity( );

  /* Set our perspective */
  gluPerspective( 45.0, ratio, 0.1, 100.0 );

  /* Make sure we're chaning the model view and not the projection */
  glMatrixMode( GL_MODELVIEW );

  /* Reset The View */
  glLoadIdentity( );
  unblock_sdl_events event_lock;
}

/* function to load in bitmap as a GL texture */
proc LoadGLTextures( )
{
  /* Create storage space for the texture */
  var TextureImage = SDL_LoadBMP(enconst c"media/textures/sdl209.bmp");
  if isNULL TextureImage do
    print "Can't load texture file media/textures/sdl209.bmp";
    Quit 1;
  done;

  /* Create The Texture */
	glGenTextures( 1, texture );

  /* Typical Texture Generation Using Data From The Bitmap */
  glBindTexture( GL_TEXTURE_2D, texture.[0] );

	/* Generate The Texture */
  glTexImage2D( GL_TEXTURE_2D, 0, 3, TextureImage.->w,
    TextureImage.->h, 0, GL_RGB,
    GL_UNSIGNED_BYTE, TextureImage.->pixels 
  );

  /* Linear Filtering */
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR );
	glTexParameteri( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR );

  /* Free up any memory we may have used */
	SDL_FreeSurface( TextureImage );
}

var twinkle = false;

/* Define the star structure */
struct star
{
  /* Stars Color */
  r : int;
  g : int;
  b : int;   
  dist : float;  /* Stars Distance From Center */
  angle : float; /* Stars Current Angle */
};

var stars : star ^ NUM; /* Make an array of size 'NUM' of stars */

var zoom = -15.0f; /* Viewing Distance Away From Stars */
var tilt = 90.0f;  /* Tilt The View */

/* general OpenGL initialization function */
proc initGL()
{
  /* Enable Texture Mapping ( NEW ) */
  glEnable( GL_TEXTURE_2D );

  /* Enable smooth shading */
  glShadeModel( GL_SMOOTH );

  /* Set the background black */
  glClearColor( 0.0f, 0.0f, 0.0f, 0.0f );

  /* Depth buffer setup */
  glClearDepth( 1.0 );

  /* Really Nice Perspective Calculations */
  glHint( GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST );

  /* Blending Function For Translucency Based On Source Alpha Value  */
  glBlendFunc( GL_SRC_ALPHA, GL_ONE );

  /* Enable Blending */
  glEnable( GL_BLEND );

  /* Create A Loop That Goes Through All The Stars */
  var i = 0; whilst i< NUM do
	  /* Start All The Stars At Angle Zero */
	  stars.[i].angle = 0.0f;

	  /* Calculate Distance From The Center */
	  stars.[i].dist = ( float_of i / float_of NUM ) * 5.0f;
	  /* Give star.[i] A Random Red Intensity */
	  stars.[i].r = Cstdlib::rand( ) % 256;
	  /* Give star.[i] A Random Green Intensity */
	  stars.[i].g = Cstdlib::rand( ) % 256;
	  /* Give star.[i] A Random Blue Intensity */
	  stars.[i].b = Cstdlib::rand( ) % 256;
    ++i;
  done;
}

/* These are to calculate our fps */
var T0     = 0;
var Frames = 0;
var spin = 0.0f;

proc rotate()
{
  var i : int;
  forall i in 0 upto NUM - 1 do
    /* Used To Spin The Stars */
    spin += 0.01f;
    /* Changes The Angle Of A Star */
    stars.[i].angle += float_of i / float_of NUM;
    /* Changes The Distance Of A Star */
    stars.[i].dist -= 0.01f;

    /* Is The Star In The Middle Yet */
    if stars.[i].dist < 0.0f do
      /* Move The Star 5 Units From The Center */
      stars.[i].dist += 5.0f;
      /* Give It A New Red Value */
      stars.[i].r = Cstdlib::rand( ) % 256;
      /* Give It A New Green Value */
      stars.[i].g = Cstdlib::rand( ) % 256;
      /* Give It A New Blue Value */
      stars.[i].b = Cstdlib::rand( ) % 256;
    done;
  done;
}

var filter = 0;

var f_texture : uint ^ 3; /* Storage For 3 Textures ( NEW ) */
var texture : ptr[uint] = carray_of f_texture;


/* Here goes our drawing code */
proc drawGLScene(drawing:1->0)
{
  block_sdl_events event_lock;
  drawing();
  unblock_sdl_events event_lock;

  /* Gather our frames per second */
  Frames++;
  {
    var t = SDL_GetTicks();
    if t - T0 >= 5000 do
      val seconds = double_of (t - T0) / 1000.0;
      val fps = double_of Frames / seconds;
      print Frames; print " frames in "; print seconds; 
      print " seconds = "; print fps; print " FPS"; endl;
      T0 = t;
      Frames = 0;
    done; 
  };
  rotate();
}

/* whether or not the window is active */
var isActive = true;

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var event_lock = SDL_CreateMutex();


proc Quit(n:int)
{
  SDL_Quit;
  System::exit 0;
}

/* Fetch the video info */
var videoInfo = SDL_GetVideoInfo();

if isNULL videoInfo do
  print "Video query failed"; endl; 
  Quit 1;
done;

/* the flags to pass to SDL_SetVideoMode */
var 
  videoFlags  = SDL_OPENGL;          /* Enable OpenGL in SDL */
  videoFlags |= cast[uint] SDL_GL_DOUBLEBUFFER; /* Enable double buffering */
  videoFlags |= SDL_HWPALETTE;       /* Store the palette in hardware */
  videoFlags |= SDL_RESIZABLE;       /* Enable window resizing */

/* This checks to see if surfaces can be stored in memory */
if  videoInfo.->hw_available != 0 do
	videoFlags |= SDL_HWSURFACE;
else
	videoFlags |= SDL_SWSURFACE;
done;

/* This checks if hardware blits can be done */
if videoInfo.->blit_hw != 0 do
	videoFlags |= SDL_HWACCEL;
done;

/* Sets up OpenGL double buffering */
ignore$ SDL_GL_SetAttribute( cast[SDL_GLattr] SDL_GL_DOUBLEBUFFER, 1 );

/* get a SDL surface */
var surface = SDL_SetVideoMode
  (SCREEN_WIDTH, SCREEN_HEIGHT, SCREEN_BPP, videoFlags )
;

/* Verify there is a surface */
if isNULL surface do
  print "Video mode set failed"; endl; 
  Quit 1;
done;

/* initialize OpenGL */
initGL();
LoadGLTextures();

/* resize the initial window */
resizeWindow( SCREEN_WIDTH, SCREEN_HEIGHT );

// SDL Event dispatcher
proc handle_active (e:SDL_ActiveEvent)
{
   isActive = e.gain != 0;
}

proc handle_resize(e:SDL_ResizeEvent)
{
  block_sdl_events event_lock;
  surface = SDL_SetVideoMode( 
    e.w,
    e.h,
    16, videoFlags 
  );
  if isNULL surface do
    print "Could not get a surface after resize"; endl;
  done;
  resizeWindow( e.w, e.h );
  unblock_sdl_events event_lock;
}

/* function to handle key press events */
proc handle_key( keysym : SDL_keysym)
{
  match keysym.sym with
  | ?k when k == SDLK_ESCAPE => { Quit 0; }
  | ?k when k ==  SDLK_F1 =>
	    { 
        block_sdl_events event_lock;
        ignore$ SDL_WM_ToggleFullScreen( surface ); 
        unblock_sdl_events event_lock;
      }
  | ?k when k == SDLK_t => 
    { 
      twinkle = not twinkle; 
    }
  | ?k when k == SDLK_PAGEUP => 
    {
	    zoom = zoom - 0.2f;
    }

  | ?k when k == SDLK_PAGEDOWN => 
    {
	    zoom = zoom + 0.2f;
    }

  | ?k when k == SDLK_UP => 
    {
      tilt = tilt - 0.5f;
    }

  | ?k when k == SDLK_DOWN => 
    {
      tilt = tilt + 0.5f;
    }

  | _ => {}
  endmatch;
}

/* draw the scene */
proc draw(drawing: 1->0) {
  if isActive call drawGLScene( drawing );
}

proc keychan(x:schannel[SDL_keysym])
{
  whilst true do
    var &k : SDL_keysym <- read x;
    handle_key k;
  done;
}

proc activechan(x:schannel[SDL_ActiveEvent])
{
  whilst true do
    var &k : SDL_ActiveEvent <- read x;
    handle_active k;
  done;
}

proc resizechan(x:schannel[SDL_ResizeEvent])
{
  whilst true do
    var &k : SDL_ResizeEvent <- read x;
    handle_resize k;
  done;
}

proc drawchan(x:schannel[int], drawing:1->0)
{
  whilst true do 
    var &k : int <- read x;
    draw drawing;
  done;
}

proc execute(x:schannel[int], something:1->0)
{
  whilst true do 
    var &k : int <- read x;
    something();
  done;
}

proc poll_event(e: &SDL_Event)
{
tryagain:>
  //print "Polling event"; endl;
  var result = SDL_PollEvent(unref e);
  if result > 0 do
    //print "Got event"; endl;
    return;
  done;
  Faio::sleep 0.1;
  goto tryagain;
}

proc dispatch_event(
  keyboard:schannel[SDL_keysym],
  active:schannel[SDL_ActiveEvent],
  resize:schannel[SDL_ResizeEvent]
)
{
  whilst true do
    //var &e : SDL_Event <- get_sdl_event event_lock;
    var e : SDL_Event;
    poll_event(&e);
    match e.type_ with
    | ?et when et == SDL_ACTIVEEVENT => 
      { write (active, e.active); }

    | ?et when et == SDL_VIDEORESIZE => 
      { write (resize, e.resize); }

    | ?et when et == SDL_KEYDOWN =>
      { write (keyboard, e.key.keysym); }

    | ?et when et == SDL_QUIT =>
      { Quit 0; }

    | _ => {}
    endmatch;
  done;
}

/* write ticks at the desired framerate */
proc framerate (x:schannel[int], framerate:double)
{
  whilst true do
    Faio::sleep framerate;
    write (x,1);
  done;
}

/* LINEAR CONTROL MODEL: CANNOT DEADLOCK 
  ~~> async/sync connection
  --> sync/sync connection
  
  SDL_event ~~> dispatcher 
                --> resize handler
                --> active handler
                --> key handler
  timer ~~> framerate --> draw                
*/

/* make our communication channels */
var keyboard = mk_schannel[SDL_keysym] ();
var active = mk_schannel[SDL_ActiveEvent] ();
var resize = mk_schannel[SDL_ResizeEvent] ();
var clicks = mk_schannel[int] ();
var rotation = mk_schannel[int] ();

/* start up the fthreads and plug them together */
spawn_fthread { dispatch_event (keyboard, active, resize); };
spawn_fthread { resizechan resize; };
spawn_fthread { activechan active; };
spawn_fthread { keychan keyboard; };

spawn_fthread { drawchan (clicks, the Drawing); };
spawn_fthread { framerate (clicks, 0.05); };
spawn_fthread { execute (rotation, the rotate); };
spawn_fthread { framerate (rotation, 0.01); };


// main thread hangs

/* Here goes our drawing code */
proc Drawing()
{
  /* Clear The Screen And The Depth Buffer */
  glClear( GL_COLOR_BUFFER_BIT \| GL_DEPTH_BUFFER_BIT );

    /* Select Our Texture */
  glBindTexture( GL_TEXTURE_2D, texture.[0] );
  glLoadIdentity( );

    /* Loop Through All The Stars */
  var i = 0;
  forall i in 0 upto NUM - 1 do
    /* Reset The View Before We Draw Each Star */
    glLoadIdentity( );
    /* Zoom Into The Screen (Using The Value In 'zoom') */
    glTranslatef( 0.0f, 0.0f, zoom );

    /* Tilt The View (Using The Value In 'tilt') */
    glRotatef( tilt, 1.0f, 0.0f, 0.0f );
    /* Rotate To The Current Stars Angle */
    glRotatef( stars.[i].angle, 0.0f, 1.0f, 0.0f );

    /* Move Forward On The X Plane */
    glTranslatef( stars.[i].dist, 0.0f, 0.0f );

    /* Cancel The Current Stars Angle */
    glRotatef( -stars.[i].angle, 0.0f, 1.0f, 0.0f );
    /* Cancel The Screen Tilt */
    glRotatef( -tilt, 1.0f, 0.0f, 0.0f );

    /* Twinkling Stars Enabled */
    if twinkle do
      /* Assign A Color Using Bytes */
      glColor4ub( utiny_of stars.[NUM - i  - 1].r,
      utiny_of stars.[NUM - i  - 1].g,
      utiny_of stars.[NUM - i  - 1].b, 255ut );
      /* Begin Drawing The Textured Quad */
      glBegin( GL_QUADS );
        glTexCoord2f( 0.0f, 0.0f );
        glVertex3f( -1.0f, -1.0f, 0.0f );
        glTexCoord2f( 1.0f, 0.0f);
        glVertex3f( 1.0f, -1.0f, 0.0f );
        glTexCoord2f( 1.0f, 1.0f );
        glVertex3f( 1.0f, 1.0f, 0.0f );
        glTexCoord2f( 0.0f, 1.0f );
        glVertex3f( -1.0f, 1.0f, 0.0f );
      glEnd( );
     done;

    /* Rotate The Star On The Z Axis */
    glRotatef( spin, 0.0f, 0.0f, 1.0f );

    /* Assign A Color Using Bytes */
    glColor4ub( utiny_of stars.[i].r, utiny_of stars.[i].g, utiny_of stars.[i].b, 255ut );

    /* Begin Drawing The Textured Quad */
    glBegin( GL_QUADS );
      glTexCoord2f( 0.0f, 0.0f ); glVertex3f( -1.0f, -1.0f, 0.0f );
      glTexCoord2f( 1.0f, 0.0f ); glVertex3f(  1.0f, -1.0f, 0.0f );
      glTexCoord2f( 1.0f, 1.0f ); glVertex3f(  1.0f,  1.0f, 0.0f );
      glTexCoord2f( 0.0f, 1.0f ); glVertex3f( -1.0f,  1.0f, 0.0f );
    glEnd( );

  done;

  /* Draw it to the screen */
  SDL_GL_SwapBuffers( );
}


