@import config

@set_title('SDL')
@head(1,'SDL')
@head(2,'SDL configuration')

@select(tangler("cpkgs/target/sdl.py"))
try:
  from config.sdl_config import *
except ImportError:
  import os
  import config
  from fbuild.flxbuild.config_support import cwrite, pa
  from fbuild.flxbuild.flxutil import xqt, ExecutionError, file_exists

  try:
    SDL_VERSION = xqt("sdl-config --version")[0].strip()
  except ExecutionError:
    HAVE_SDL = 0
    SDL_VERSION = "None"
    SDL_CFLAGS = ""
    SDL_LIBS = ""
    SDL_STATIC_LIBS = ""
    print "SDL NOT SUPPORTED"
  else:
    print "SDL SUPPORTED, version ",SDL_VERSION
    HAVE_SDL = 1
    SDL_CFLAGS = xqt("sdl-config --cflags")[0].strip()
    SDL_LIBS = xqt("sdl-config --libs")[0].strip()
    SDL_STATIC_LIBS = xqt("sdl-config --static-libs")[0].strip()

    fname = "config" + os.sep + "sdl.fpc"
    if not file_exists(fname):
      print "Creating config/sdl.fpc"
      f = open (fname,"w")
      f.write("Name: SDL\n")
      f.write("Description: Simple Direct Media Layer\n")
      f.write("Version: "+SDL_VERSION+"\n")
      f.write("cflags: "+SDL_CFLAGS+"\n")
      f.write("requires_dlibs: '"+SDL_LIBS+"'\n")
      f.write("requires_slibs: '"+SDL_STATIC_LIBS+"'\n")
      f.write("flx_requires_driver: flx_arun\n")
      f.close()
    fname = "config" + os.sep + "gl.fpc"
    if not file_exists(fname):
      print "Creating config/gl.fpc"
      f = open (fname,"w")
      f.write("Name: OpenGL\n")
      f.write("Description: open GL graphics\n")
      if config.MACOSX:
        f.write("provides_dlib: -framework OpenGL\n")
        f.write("provides_slib: -framework OpenGL\n")
      else:
        f.write("provides_dlib: -lGL\n")
        f.write("provides_slib: -lGL\n")
      f.close()
    fname = "config" + os.sep + "glu.fpc"
    if not file_exists(fname):
      print "Creating config/glu.fpc"
      f = open (fname,"w")
      f.write("Name: GLU\n")
      f.write("Description: GLU graphics \n")
      if config.MACOSX:
        f.write("provides_dlib: -framework OpenGL\n")
        f.write("provides_slib: -framework OpenGL\n")
      else:
        f.write("provides_dlib: -lGLU\n")
        f.write("provides_slib: -lGLU\n")
      f.write("Requires: gl\n")
      f.close()
    fname = "config" + os.sep + "glut.fpc"
    if not file_exists(fname):
      print "Creating config/glut.fpc"
      f = open (fname,"w")
      f.write("Name: GLUT\n")
      f.write("Description: GLUT graphics\n")
      if config.MACOSX:
        f.write("provides_dlib: -framework GLUT\n")
        f.write("provides_slib: -framework GLUT\n")
      else:
        f.write("provides_dlib: -lglut\n")
        f.write("provides_slib: -lglut\n")
      f.write("Requires: gl glu\n")
      f.close()

  print "SDL cpkgs/target/sdl.py"
  f = cwrite("sdl")
  pa(f,locals(),"HAVE_SDL")
  pa(f,locals(),"SDL_VERSION")
  pa(f,locals(),"SDL_CFLAGS")
  pa(f,locals(),"SDL_LIBS")
  pa(f,locals(),"SDL_STATIC_LIBS")
  f.close()
@doc()

@head(2,'SDL package')

@head(3,'Base package')
@select(tangler('spkgs/sdl.py'))
import os

import config
import cpkgs.target.sdl as sdl

if sdl.HAVE_SDL:
  # flags are compiler natives switches
  # not to be confused with platform independent lists
  # of libraries, include files, paths, etc
  cflags = sdl.SDL_CFLAGS
  dflags = sdl.SDL_LIBS
  sflags = sdl.SDL_STATIC_LIBS

  pkg_requires = ['faio']
  lib_requires = ['libfaio', 'libdemux','libflx_pthread','libflx']
  root = config.src_dir
  demos = [('demos', 'sdl', '*.flx')]

iscr_source = ['lpsrc/flx_sdl.pak']
build_macro = "SDL"
weaver_directory = "doc/sdl/"
@doc()

@head(3,'Driver package')
@select(tangler('spkgs/sdl_drivers.py'))
import cpkgs.target.sdl as sdl

if sdl.HAVE_SDL:
  STATIC_DRIVERS = [
    ('src/flx_drivers/flx_arun', 'lib/rtl'),
  ]
  DYNAMIC_DRIVERS = [
    ('src/flx_drivers/flx_arun', 'bin'),
  ]
  DRLIBS = [
   'libflx_async',
   'libfaio',
   'libdemux',
   'libflx_pthread',
   'libflx',
   'libflx_gc',
   'libflx_judy',
   ]

  include_path = ['src/rtl']

  static_drivers = STATIC_DRIVERS
  dynamic_drivers = DYNAMIC_DRIVERS
  drivers_require_libs = DRLIBS
  pkg_requires = ['flx_rtl','flx_async','faio','demux','flx_pthread','sdl']
  cflags = sdl.SDL_CFLAGS
  dflags = sdl.SDL_LIBS
  sflags = sdl.SDL_STATIC_LIBS
@doc()

@select(tangler("tmp/sdl_opengl.cxx",'c++'))
// for testing whether we have SDL_opengl
#include <SDL.h>            // overrides main
#include <SDL_opengl.h>

int
main(int argc, char** argv)
{
    if(SDL_Init(SDL_INIT_VIDEO) == -1
        || SDL_SetVideoMode(640, 480, 32, SDL_ANYFORMAT | SDL_OPENGL) == NULL)
    {
        return 1;       // fail
    }

    // random gl stuff to make sure we link
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    return 0;           // pass
}
@doc()

@head(2,'SDL wrapper')
@head(3,'SDL felix wrapper')
@select(tangler('lib/SDL/SDL_opengl.flx'))
header '#include "SDL_opengl.h"';

include "GL/gl_lib";
include "GL/glu_lib";

module SDL_opengl_h
{
  inherit GL_gl_h;
  inherit GL_glu_h;
}
@doc()

@select(tangler('lib/SDL/SDL.flx'))
//Module        : SDL_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_INIT_EVERYTHING   0x0000FFFF
//#define SDL_INIT_EVENTTHREAD  0x01000000      /* Not supported on all OS's */
//#define SDL_INIT_NOPARACHUTE  0x00100000      /* Don't catch fatal signals */
//#define SDL_INIT_JOYSTICK     0x00000200
//#define SDL_INIT_CDROM                0x00000100
//#define SDL_INIT_VIDEO                0x00000020
//#define SDL_INIT_AUDIO                0x00000010
//#define       SDL_INIT_TIMER          0x00000001
//#define _SDL_H

module SDL_h
{
  requires package "sdl";
  header '#include "SDL.h"';
  open C_hack;

  const SDL_INIT_EVERYTHING: uint32;
  const SDL_INIT_EVENTTHREAD: uint32;
  const SDL_INIT_NOPARACHUTE: uint32;
  const SDL_INIT_JOYSTICK: uint32;
  const SDL_INIT_CDROM : uint32;
  const SDL_INIT_VIDEO: uint32;
  const SDL_INIT_AUDIO: uint32;
  const SDL_INIT_TIMER: uint32;

  //PROCEDURES
  proc SDL_Quit: 1;
  proc SDL_QuitSubSystem: uint32;

  //FUNCTIONS
  fun SDL_Init: uint32 -> int;
  fun SDL_InitSubSystem: uint32 -> int;
  fun SDL_WasInit: uint32 -> uint32;
}
@doc()

@select(tangler('lib/SDL/SDL_active.flx'))
//Module        : SDL_active_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_active.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_APPACTIVE         0x04            /* The application is active */
//#define SDL_APPINPUTFOCUS     0x02            /* The app has input focus */
//#define SDL_APPMOUSEFOCUS     0x01            /* The app has mouse coverage */
//#define _SDL_active_h

module SDL_active_h
{
  requires package "sdl";
  header '#include "SDL_active.h"';
  open C_hack;

  //FUNCTIONS
  fun SDL_GetAppState: 1 -> uint8;
}
@doc()

@select(tangler('lib/SDL/SDL_audio.flx'))
//Module        : SDL_audio_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_audio.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1


//INCLUDES
include"SDL/SDL_rwops";

module SDL_audio_h
{
  requires package "sdl";
  header '#include "SDL_audio.h"';
  open C_hack;
  open SDL_rwops_h;

  const SDL_MIX_MAXVOLUME : int;
  const AUDIO_S16MSB : uint16;
  const AUDIO_U16MSB : uint16;
  const AUDIO_S16LSB : uint16;
  const AUDIO_U16LSB : uint16;
  const AUDIO_S16SYS : uint16;
  const AUDIO_U16SYS : uint16;
  const AUDIO_S16 : uint16;
  const AUDIO_U16 : uint16;
  const AUDIO_S8 : uint16;
  const AUDIO_U8 : uint16;

  //ABSTRACT TYPES
  type SDL_audiostatus = 'SDL_audiostatus';
  fun eq:SDL_audiostatus * SDL_audiostatus -> bool = "$1==$2";

  //CSTRUCTS
  cstruct SDL_AudioCVT {
    needed: int;
    src_format: uint16;
    dst_format: uint16;
    rate_incr: double;
    buf: ptr[uint8];
    len: int;
    len_cvt: int;
    len_mult: int;
    len_ratio: double;
    filters: ptr[SDL_audio_h_cft_2];
    filter_index: int;
  }
  cstruct SDL_AudioSpec {
    freq: int;
    format: uint16;
    channels: uint8;
    silence: uint8;
    samples: uint16;
    padding: uint16;
    size: uint32;
    callback_: SDL_audio_h_cft_1;
    userdata: address;
  }

  fun get_callback: SDL_AudioSpec -> SDL_audio_h_cft_1 = "$1.callback";
  fun get_callback: lvalue[SDL_AudioSpec] -> lvalue[SDL_audio_h_cft_1] = "$1.callback";

  //C FUNCTION POINTER TYPES
  header '''typedef void (*SDL_audio_h_cft_2)(struct SDL_AudioCVT *,  Uint16);''';
  type SDL_audio_h_cft_2 = 'SDL_audio_h_cft_2';

  header '''typedef void (*SDL_audio_h_cft_1)(void *,  Uint8 *, int);''';
  type SDL_audio_h_cft_1 = 'SDL_audio_h_cft_1';

  typedef flx_audio_callback_arg_t = ptr[uint8] * int;
  typedef flx_audio_callback_t = flx_audio_callback_arg_t -> void;
  export type (flx_audio_callback_t) as "flx_audio_callback_t";
  export type (flx_audio_callback_arg_t) as "flx_audio_callback_arg_t";

  header """
    void SDL_audio_callback(void *obj, Uint8 *stream, int len);
  """;

  body """
    // audio callback thunk
    void SDL_audio_callback(void *obj, Uint8 *stream, int len) {
      flx_audio_callback_t callback = (flx_audio_callback_t)obj;
      flx::rtl::con_t *p =
        callback->
        clone()->
        call(0,flx_audio_callback_arg_t(stream,len))
      ;
      while(p) p = p->resume();
    }
  """;

// not working yet
//  callback proc SDL_audio_callback: SDL_audio_callback * ptr[uint8] * int;

  //STRUCT or UNION TAG ALIASES

  /*
  //TYPE ALIASES
  typedef _struct_SDL_AudioSpec = SDL_AudioSpec;
  typedef _struct_SDL_AudioCVT = SDL_AudioCVT;
  */

  //ENUMERATION CONSTANTS
  const SDL_AUDIO_PAUSED: SDL_audiostatus = 'SDL_AUDIO_PAUSED';
  const SDL_AUDIO_STOPPED: SDL_audiostatus = 'SDL_AUDIO_STOPPED';
  const SDL_AUDIO_PLAYING: SDL_audiostatus = 'SDL_AUDIO_PLAYING';

  //PROCEDURES
  proc SDL_AudioQuit: 1;
  proc SDL_CloseAudio: 1;
  proc SDL_FreeWAV: ptr[uint8];
  proc SDL_LockAudio: 1;
  proc SDL_MixAudio: ptr[uint8] * cptr[uint8] * uint32 * int;
  proc SDL_PauseAudio: int;
  proc SDL_UnlockAudio: 1;

  //FUNCTIONS
  fun SDL_AudioDriverName: ptr[char] * int -> ptr[char];
  fun SDL_AudioInit: cptr[char] -> int;
  fun SDL_BuildAudioCVT: ptr[SDL_AudioCVT] * uint16 * uint8 * int * uint16 * uint8 * int -> int;
  fun SDL_ConvertAudio: ptr[SDL_AudioCVT] -> int;
  fun SDL_GetAudioStatus: 1 -> SDL_audiostatus;
  fun SDL_LoadWAV_RW: ptr[SDL_RWops] * int * ptr[SDL_AudioSpec] * ptr[ptr[uint8]] * ptr[uint32] -> ptr[SDL_AudioSpec];
  fun SDL_OpenAudio: ptr[SDL_AudioSpec] * ptr[SDL_AudioSpec] -> int;
  fun SDL_LoadWAV: cptr[char] * ptr[SDL_AudioSpec] * ptr[ptr[uint8]] * ptr[uint32] -> ptr[SDL_AudioSpec];
}
@doc()

@select(tangler('lib/SDL/SDL_cdrom.flx'))
//Module        : SDL_cdrom_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_cdrom.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define MSF_TO_FRAMES(M, S, F)        ((M)*60*CD_FPS+(S)*CD_FPS+(F))
//#define FRAMES_TO_MSF(f, M,S,F)       {                                       \
//#define CD_FPS        75
//#define CD_INDRIVE(status)    ((int)status > 0)
//#define SDL_DATA_TRACK        0x04
//#define SDL_AUDIO_TRACK       0x00
//#define SDL_MAX_TRACKS        99
//#define _SDL_cdrom_h

module SDL_cdrom_h
{
  requires package "sdl";
  header '#include "SDL_cdrom.h"';
  open C_hack;

  //ABSTRACT TYPES
  type CDstatus = 'CDstatus';

  //CSTRUCTS
  cstruct SDL_CD {
    id: int;
    status: CDstatus;
    numtracks: int;
    cur_track: int;
    cur_frame: int;
    track: ptr[SDL_CDtrack];
  }
  cstruct SDL_CDtrack {
    id: uint8;
    type_: uint8;
    unused: uint16;
    length: uint32;
    offset: uint32;
  }

  //STRUCT or UNION TAG ALIASES

  /*
  //TYPE ALIASES
  typedef _struct_SDL_CD = SDL_CD;
  typedef _struct_SDL_CDtrack = SDL_CDtrack;
  */

  //ENUMERATION CONSTANTS
  const CD_TRAYEMPTY: int = 'CD_TRAYEMPTY';
  const CD_PLAYING: int = 'CD_PLAYING';
  const CD_ERROR: int = 'CD_ERROR';
  const CD_PAUSED: int = 'CD_PAUSED';
  const CD_STOPPED: int = 'CD_STOPPED';

  //PROCEDURES
  proc SDL_CDClose: ptr[SDL_CD];

  //FUNCTIONS
  fun SDL_CDEject: ptr[SDL_CD] -> int;
  fun SDL_CDName: int -> cptr[char];
  fun SDL_CDNumDrives: 1 -> int;
  fun SDL_CDOpen: int -> ptr[SDL_CD];
  fun SDL_CDPause: ptr[SDL_CD] -> int;
  fun SDL_CDPlay: ptr[SDL_CD] * int * int -> int;
  fun SDL_CDPlayTracks: ptr[SDL_CD] * int * int * int * int -> int;
  fun SDL_CDResume: ptr[SDL_CD] -> int;
  fun SDL_CDStatus: ptr[SDL_CD] -> CDstatus;
  fun SDL_CDStop: ptr[SDL_CD] -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_error.flx'))
//Module        : SDL_error_h
//Timestamp     : 2006/1/6 2:1:27 UTC
//Timestamp     : 2006/1/6 13:1:27 (local)
//Raw Header    : SDL_error.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_OutOfMemory()     SDL_Error(SDL_ENOMEM)
//#define _SDL_error_h

module SDL_error_h
{
  requires package "sdl";
  header '#include "SDL_error.h"';
  open C_hack;

  //ABSTRACT TYPES
  type SDL_errorcode = 'SDL_errorcode';

  //ENUMERATION CONSTANTS
  const SDL_EFSEEK: int = 'SDL_EFSEEK';
  const SDL_ENOMEM: int = 'SDL_ENOMEM';
  const SDL_LASTERROR: int = 'SDL_LASTERROR';
  const SDL_EFREAD: int = 'SDL_EFREAD';
  const SDL_EFWRITE: int = 'SDL_EFWRITE';

  //PROCEDURES
  proc SDL_ClearError: 1;
  proc SDL_Error: SDL_errorcode;
  proc SDL_SetError[t]: t;

  //FUNCTIONS
  fun SDL_GetError: 1 -> ptr[char];
}
@doc()

@select(tangler('lib/SDL/SDL_events.flx'))
//Module        : SDL_events_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_events.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_ENABLE     1
//#define SDL_DISABLE    0
//#define SDL_IGNORE     0
//#define SDL_QUERY     -1
//#define SDL_ALLEVENTS         0xFFFFFFFF
//#define SDL_EVENTMASK(X)      (1<<(X))
//#define _SDL_events_h

//INCLUDES
include"SDL/SDL_keyboard";

module SDL_events_h
{
  requires package "sdl";
  header '#include "SDL_events.h"';
  open C_hack;
  open SDL_keyboard_h;

  //ABSTRACT TYPES
  type SDL_eventaction = 'SDL_eventaction';

  //CSTRUCTS
  cstruct SDL_SysWMEvent {
    type_: uint8;
    msg: ptr[SDL_SysWMmsg];
  }
  cstruct SDL_ResizeEvent {
    type_: uint8;
    w: int;
    h: int;
  }
  cstruct SDL_KeyboardEvent {
    type_: uint8;
    which: uint8;
    state: uint8;
    keysym: SDL_keysym;
  }
  cstruct SDL_JoyBallEvent {
    type_: uint8;
    which: uint8;
    ball: uint8;
    xrel: int16;
    yrel: int16;
  }
  cstruct SDL_JoyHatEvent {
    type_: uint8;
    which: uint8;
    hat: uint8;
    value: uint8;
  }
  cstruct SDL_ExposeEvent {
    type_: uint8;
  }
  cstruct SDL_MouseButtonEvent {
    type_: uint8;
    which: uint8;
    button: uint8;
    state: uint8;
    x: uint16;
    y: uint16;
  }
  cstruct SDL_MouseMotionEvent {
    type_: uint8;
    which: uint8;
    state: uint8;
    x: uint16;
    y: uint16;
    xrel: int16;
    yrel: int16;
  }
  cstruct SDL_JoyButtonEvent {
    type_: uint8;
    which: uint8;
    button: uint8;
    state: uint8;
  }
  cstruct SDL_QuitEvent {
    type_: uint8;
  }
  cstruct SDL_JoyAxisEvent {
    type_: uint8;
    which: uint8;
    axis: uint8;
    value: int16;
  }
  cstruct SDL_UserEvent {
    type_: uint8;
    code_: int;
    data1: address;
    data2: address;
  }
  cstruct SDL_ActiveEvent {
    type_: uint8;
    gain: uint8;
    state: uint8;
  }

  // This is ACTUALLY a C union .. but the syntax is the same
  // as for a struct .. so we can model it with a struct
  cstruct SDL_Event = {
    //type_ : uint8; // type is a keyword ..
    active : SDL_ActiveEvent;
    key : SDL_KeyboardEvent;
    motion: SDL_MouseMotionEvent;
    button: SDL_MouseButtonEvent;
    jaxis : SDL_JoyAxisEvent;
    jball : SDL_JoyBallEvent;
    jhat : SDL_JoyHatEvent;
    jbutton : SDL_JoyButtonEvent;
    resize : SDL_ResizeEvent;
    expose : SDL_ExposeEvent;
    quit: SDL_QuitEvent;
    user : SDL_UserEvent;
    syswm : SDL_SysWMEvent;
  }

  // use name type_ instead of type ..
  fun get_type_:SDL_Event -> uint8 = "$1.type";

  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_events_h_cft_1)(SDL_Event const *);''';
  type SDL_events_h_cft_1 = 'SDL_events_h_cft_1';

  //PURE INCOMPLETE TYPES
  type _struct_SDL_SysWMmsg = 'struct SDL_SysWMmsg'; //local

  //STRUCT or UNION TAG ALIASES
  typedef SDL_SysWMmsg = _struct_SDL_SysWMmsg;

  typedef SDL_EventMasks = int;
  typedef SDL_EventFilter = SDL_events_h_cft_1;
  typedef SDL_Events = int;

  // Weird
  const SDL_PEEKEVENT: uint8 = 'SDL_PEEKEVENT';
  const SDL_GETEVENT: uint8 = 'SDL_GETEVENT';
  const SDL_ADDEVENT: uint8 = 'SDL_ADDEVENT';
  const SDL_NUMEVENTS: uint8 = 'SDL_NUMEVENTS';

  //EVENTS
  const SDL_MOUSEBUTTONUP: uint8 = 'SDL_MOUSEBUTTONUP';
  const SDL_MOUSEBUTTONDOWN: uint8 = 'SDL_MOUSEBUTTONDOWN';
  const SDL_KEYUP: uint8 = 'SDL_KEYUP';
  const SDL_JOYBALLMOTION: uint8 = 'SDL_JOYBALLMOTION';
  const SDL_NOEVENT: uint8 = 'SDL_NOEVENT';
  const SDL_JOYAXISMOTION: uint8 = 'SDL_JOYAXISMOTION';
  const SDL_QUIT: uint8 = 'SDL_QUIT';
  const SDL_VIDEORESIZE: uint8 = 'SDL_VIDEORESIZE';
  const SDL_JOYBUTTONDOWN: uint8 = 'SDL_JOYBUTTONDOWN';
  const SDL_KEYDOWN: uint8 = 'SDL_KEYDOWN';
  const SDL_JOYBUTTONUP: uint8 = 'SDL_JOYBUTTONUP';
  const SDL_SYSWMEVENT: uint8 = 'SDL_SYSWMEVENT';
  const SDL_USEREVENT: uint8 = 'SDL_USEREVENT';
  const SDL_JOYHATMOTION: uint8 = 'SDL_JOYHATMOTION';
  const SDL_ACTIVEEVENT: uint8 = 'SDL_ACTIVEEVENT';
  const SDL_VIDEOEXPOSE: uint8 = 'SDL_VIDEOEXPOSE';
  const SDL_MOUSEMOTION: uint8 = 'SDL_MOUSEMOTION';

  // reserved
  const SDL_EVENT_RESERVED2: uint8 = 'SDL_EVENT_RESERVED2';
  const SDL_EVENT_RESERVED3: uint8 = 'SDL_EVENT_RESERVED3';
  const SDL_EVENT_RESERVED4: uint8 = 'SDL_EVENT_RESERVED4';
  const SDL_EVENT_RESERVED5: uint8 = 'SDL_EVENT_RESERVED5';
  const SDL_EVENT_RESERVED6: uint8 = 'SDL_EVENT_RESERVED6';
  const SDL_EVENT_RESERVED7: uint8 = 'SDL_EVENT_RESERVED7';
  const SDL_EVENT_RESERVEDA: uint8 = 'SDL_EVENT_RESERVEDA';
  const SDL_EVENT_RESERVEDB: uint8 = 'SDL_EVENT_RESERVEDB';

  // MASKS
  // Joystick
  const SDL_JOYBUTTONDOWNMASK: uint8 = 'SDL_JOYBUTTONDOWNMASK';
  const SDL_JOYBUTTONUPMASK: uint8 = 'SDL_JOYBUTTONUPMASK';
  const SDL_JOYHATMOTIONMASK: uint8 = 'SDL_JOYHATMOTIONMASK';
  const SDL_JOYAXISMOTIONMASK: uint8 = 'SDL_JOYAXISMOTIONMASK';
  const SDL_JOYBALLMOTIONMASK: uint8 = 'SDL_JOYBALLMOTIONMASK';
  const SDL_JOYEVENTMASK: uint8 = 'SDL_JOYEVENTMASK';

  // mouse
  const SDL_MOUSEMOTIONMASK: uint8 = 'SDL_MOUSEMOTIONMASK';
  const SDL_MOUSEEVENTMASK: uint8 = 'SDL_MOUSEEVENTMASK';
  const SDL_MOUSEBUTTONUPMASK: uint8 = 'SDL_MOUSEBUTTONUPMASK';
  const SDL_MOUSEBUTTONDOWNMASK: uint8 = 'SDL_MOUSEBUTTONDOWNMASK';

  // video
  const SDL_VIDEORESIZEMASK: uint8 = 'SDL_VIDEORESIZEMASK';
  const SDL_ACTIVEEVENTMASK: uint8 = 'SDL_ACTIVEEVENTMASK';
  const SDL_SYSWMEVENTMASK: uint8 = 'SDL_SYSWMEVENTMASK';
  const SDL_VIDEOEXPOSEMASK: uint8 = 'SDL_VIDEOEXPOSEMASK';

  // keyboard
  const SDL_KEYDOWNMASK: uint8 = 'SDL_KEYDOWNMASK';
  const SDL_KEYUPMASK: uint8 = 'SDL_KEYUPMASK';
  const SDL_QUITMASK: uint8 = 'SDL_QUITMASK';

  //PROCEDURES
  proc SDL_PumpEvents: 1;
  proc SDL_SetEventFilter: SDL_events_h_cft_1;

  //FUNCTIONS
  fun SDL_EventState: uint8 * int -> uint8;
  fun SDL_GetEventFilter: 1 -> SDL_EventFilter;
  fun SDL_PeepEvents: ptr[SDL_Event] * int * SDL_eventaction * uint32 -> int;
  fun SDL_PollEvent: ptr[SDL_Event] -> int;
  fun SDL_PushEvent: ptr[SDL_Event] -> int;
  fun SDL_WaitEvent: ptr[SDL_Event] -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_joystick.flx'))
//Module        : SDL_joystick_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_joystick.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_HAT_LEFTDOWN      (SDL_HAT_LEFT|SDL_HAT_DOWN)
//#define SDL_HAT_LEFTUP                (SDL_HAT_LEFT|SDL_HAT_UP)
//#define SDL_HAT_RIGHTDOWN     (SDL_HAT_RIGHT|SDL_HAT_DOWN)
//#define SDL_HAT_RIGHTUP               (SDL_HAT_RIGHT|SDL_HAT_UP)
//#define SDL_HAT_LEFT          0x08
//#define SDL_HAT_DOWN          0x04
//#define SDL_HAT_RIGHT         0x02
//#define SDL_HAT_UP            0x01
//#define SDL_HAT_CENTERED      0x00
//#define _SDL_joystick_h

module SDL_joystick_h
{
  requires package "sdl";
  header '#include "SDL_joystick.h"';
  open C_hack;

  //PURE INCOMPLETE TYPES
  type _struct__SDL_Joystick = 'struct _SDL_Joystick'; //local

  //STRUCT or UNION TAG ALIASES
  typedef SDL_Joystick = _struct__SDL_Joystick;

  //PROCEDURES
  proc SDL_JoystickClose: ptr[SDL_Joystick];
  proc SDL_JoystickUpdate: 1;

  //FUNCTIONS
  fun SDL_JoystickEventState: int -> int;
  fun SDL_JoystickGetAxis: ptr[SDL_Joystick] * int -> int16;
  fun SDL_JoystickGetBall: ptr[SDL_Joystick] * int * ptr[int] * ptr[int] -> int;
  fun SDL_JoystickGetButton: ptr[SDL_Joystick] * int -> uint8;
  fun SDL_JoystickGetHat: ptr[SDL_Joystick] * int -> uint8;
  fun SDL_JoystickIndex: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickName: int -> cptr[char];
  fun SDL_JoystickNumAxes: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumBalls: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumButtons: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumHats: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickOpen: int -> ptr[SDL_Joystick];
  fun SDL_JoystickOpened: int -> int;
  fun SDL_NumJoysticks: 1 -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_keyboard.flx'))
//Module        : SDL_keyboard_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_keyboard.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_DEFAULT_REPEAT_INTERVAL   30
//#define SDL_DEFAULT_REPEAT_DELAY      500
//#define SDL_ALL_HOTKEYS               0xFFFFFFFF
//#define _SDL_keyboard_h

//INCLUDES
include"SDL/SDL_keysym";

module SDL_keyboard_h
{
  requires package "sdl";
  header '#include "SDL_keyboard.h"';
  open C_hack;
  open SDL_keysym_h;

  //CSTRUCTS
  cstruct SDL_keysym {
    scancode: uint8;
    sym: SDLKey;
    mod: SDLMod;
    unicode: uint16;
  }

  //STRUCT or UNION TAG ALIASES

  /*
  //TYPE ALIASES
  typedef _struct_SDL_keysym = SDL_keysym;
  */

  //PROCEDURES
  proc SDL_SetModState: SDLMod;

  //FUNCTIONS
  fun SDL_EnableKeyRepeat: int * int -> int;
  fun SDL_EnableUNICODE: int -> int;
  fun SDL_GetKeyName: SDLKey -> ptr[char];
  fun SDL_GetKeyState: ptr[int] -> ptr[uint8];
  fun SDL_GetModState: 1 -> SDLMod;
}
@doc()

@select(tangler('lib/SDL/SDL_keysym.flx'))
//Module        : SDL_keysym_h
//Timestamp     : 2006/1/6 2:1:27 UTC
//Timestamp     : 2006/1/6 13:1:27 (local)
//Raw Header    : SDL_keysym.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define KMOD_META     (KMOD_LMETA|KMOD_RMETA)
//#define KMOD_ALT      (KMOD_LALT|KMOD_RALT)
//#define KMOD_SHIFT    (KMOD_LSHIFT|KMOD_RSHIFT)
//#define KMOD_CTRL     (KMOD_LCTRL|KMOD_RCTRL)
//#define _SDL_keysym_h

module SDL_keysym_h
{
  requires package "sdl";
  header '#include "SDL_keysym.h"';
  open C_hack;

  //ABSTRACT TYPES
  type SDLKey = 'SDLKey';
  type SDLMod = 'SDLMod';

  //ENUMERATION CONSTANTS
  const SDLK_WORLD_1: SDLKey = 'SDLK_WORLD_1';
  const SDLK_POWER: SDLKey = 'SDLK_POWER';
  const SDLK_SLASH: SDLKey = 'SDLK_SLASH';
  const SDLK_WORLD_2: SDLKey = 'SDLK_WORLD_2';
  const SDLK_WORLD_3: SDLKey = 'SDLK_WORLD_3';
  const SDLK_F1: SDLKey = 'SDLK_F1';
  const SDLK_WORLD_4: SDLKey = 'SDLK_WORLD_4';
  const SDLK_WORLD_20: SDLKey = 'SDLK_WORLD_20';
  const SDLK_F2: SDLKey = 'SDLK_F2';
  const SDLK_WORLD_5: SDLKey = 'SDLK_WORLD_5';
  const SDLK_WORLD_21: SDLKey = 'SDLK_WORLD_21';
  const SDLK_F3: SDLKey = 'SDLK_F3';
  const SDLK_KP_EQUALS: SDLKey = 'SDLK_KP_EQUALS';
  const SDLK_WORLD_6: SDLKey = 'SDLK_WORLD_6';
  const SDLK_LEFT: SDLKey = 'SDLK_LEFT';
  const SDLK_WORLD_22: SDLKey = 'SDLK_WORLD_22';
  const SDLK_F4: SDLKey = 'SDLK_F4';
  const SDLK_WORLD_7: SDLKey = 'SDLK_WORLD_7';
  const SDLK_WORLD_23: SDLKey = 'SDLK_WORLD_23';
  const SDLK_UNDO: SDLKey = 'SDLK_UNDO';
  const SDLK_F5: SDLKey = 'SDLK_F5';
  const SDLK_WORLD_8: SDLKey = 'SDLK_WORLD_8';
  const SDLK_WORLD_24: SDLKey = 'SDLK_WORLD_24';
  const SDLK_F6: SDLKey = 'SDLK_F6';
  const SDLK_WORLD_9: SDLKey = 'SDLK_WORLD_9';
  const SDLK_WORLD_25: SDLKey = 'SDLK_WORLD_25';
  const SDLK_F7: SDLKey = 'SDLK_F7';
  const SDLK_WORLD_26: SDLKey = 'SDLK_WORLD_26';
  const SDLK_F8: SDLKey = 'SDLK_F8';
  const SDLK_WORLD_27: SDLKey = 'SDLK_WORLD_27';
  const SDLK_F9: SDLKey = 'SDLK_F9';
  const SDLK_LEFTPAREN: SDLKey = 'SDLK_LEFTPAREN';
  const SDLK_WORLD_28: SDLKey = 'SDLK_WORLD_28';
  const SDLK_WORLD_29: SDLKey = 'SDLK_WORLD_29';
  const SDLK_KP_ENTER: SDLKey = 'SDLK_KP_ENTER';
  const SDLK_CAPSLOCK: SDLKey = 'SDLK_CAPSLOCK';
  const SDLK_WORLD_30: SDLKey = 'SDLK_WORLD_30';
  const SDLK_WORLD_31: SDLKey = 'SDLK_WORLD_31';
  const SDLK_COMMA: SDLKey = 'SDLK_COMMA';
  const SDLK_WORLD_32: SDLKey = 'SDLK_WORLD_32';
  const SDLK_HASH: SDLKey = 'SDLK_HASH';
  const SDLK_SPACE: SDLKey = 'SDLK_SPACE';
  const SDLK_WORLD_33: SDLKey = 'SDLK_WORLD_33';
  const SDLK_WORLD_34: SDLKey = 'SDLK_WORLD_34';
  const SDLK_WORLD_35: SDLKey = 'SDLK_WORLD_35';
  const SDLK_PLUS: SDLKey = 'SDLK_PLUS';
  const SDLK_WORLD_36: SDLKey = 'SDLK_WORLD_36';
  const SDLK_WORLD_37: SDLKey = 'SDLK_WORLD_37';
  const SDLK_WORLD_38: SDLKey = 'SDLK_WORLD_38';
  const SDLK_KP_PERIOD: SDLKey = 'SDLK_KP_PERIOD';
  const SDLK_PAUSE: SDLKey = 'SDLK_PAUSE';
  const SDLK_WORLD_39: SDLKey = 'SDLK_WORLD_39';
  const SDLK_KP_MINUS: SDLKey = 'SDLK_KP_MINUS';
  const KMOD_LALT: SDLKey = 'KMOD_LALT';
  const SDLK_TAB: SDLKey = 'SDLK_TAB';
  const SDLK_0: SDLKey = 'SDLK_0';
  const SDLK_COMPOSE: SDLKey = 'SDLK_COMPOSE';
  const SDLK_1: SDLKey = 'SDLK_1';
  const SDLK_2: SDLKey = 'SDLK_2';
  const SDLK_LALT: SDLKey = 'SDLK_LALT';
  const SDLK_3: SDLKey = 'SDLK_3';
  const SDLK_WORLD_40: SDLKey = 'SDLK_WORLD_40';
  const SDLK_4: SDLKey = 'SDLK_4';
  const SDLK_WORLD_41: SDLKey = 'SDLK_WORLD_41';
  const SDLK_5: SDLKey = 'SDLK_5';
  const SDLK_RCTRL: SDLKey = 'SDLK_RCTRL';
  const SDLK_WORLD_42: SDLKey = 'SDLK_WORLD_42';
  const SDLK_6: SDLKey = 'SDLK_6';
  const KMOD_RALT: SDLKey = 'KMOD_RALT';
  const SDLK_WORLD_43: SDLKey = 'SDLK_WORLD_43';
  const SDLK_7: SDLKey = 'SDLK_7';
  const SDLK_WORLD_44: SDLKey = 'SDLK_WORLD_44';
  const SDLK_8: SDLKey = 'SDLK_8';
  const SDLK_WORLD_45: SDLKey = 'SDLK_WORLD_45';
  const SDLK_9: SDLKey = 'SDLK_9';
  const SDLK_ESCAPE: SDLKey = 'SDLK_ESCAPE';
  const SDLK_WORLD_46: SDLKey = 'SDLK_WORLD_46';
  const SDLK_WORLD_47: SDLKey = 'SDLK_WORLD_47';
  const SDLK_BACKQUOTE: SDLKey = 'SDLK_BACKQUOTE';
  const SDLK_RALT: SDLKey = 'SDLK_RALT';
  const SDLK_WORLD_48: SDLKey = 'SDLK_WORLD_48';
  const SDLK_CARET: SDLKey = 'SDLK_CARET';
  const SDLK_WORLD_49: SDLKey = 'SDLK_WORLD_49';
  const SDLK_RIGHT: SDLKey = 'SDLK_RIGHT';
  const SDLK_DELETE: SDLKey = 'SDLK_DELETE';
  const SDLK_RSHIFT: SDLKey = 'SDLK_RSHIFT';
  const SDLK_LESS: SDLKey = 'SDLK_LESS';
  const SDLK_AMPERSAND: SDLKey = 'SDLK_AMPERSAND';
  const SDLK_BACKSLASH: SDLKey = 'SDLK_BACKSLASH';
  const SDLK_WORLD_50: SDLKey = 'SDLK_WORLD_50';
  const SDLK_WORLD_51: SDLKey = 'SDLK_WORLD_51';
  const KMOD_LSHIFT: SDLKey = 'KMOD_LSHIFT';
  const SDLK_WORLD_52: SDLKey = 'SDLK_WORLD_52';
  const SDLK_WORLD_53: SDLKey = 'SDLK_WORLD_53';
  const SDLK_WORLD_54: SDLKey = 'SDLK_WORLD_54';
  const SDLK_RMETA: SDLKey = 'SDLK_RMETA';
  const SDLK_WORLD_55: SDLKey = 'SDLK_WORLD_55';
  const SDLK_WORLD_56: SDLKey = 'SDLK_WORLD_56';
  const SDLK_LCTRL: SDLKey = 'SDLK_LCTRL';
  const SDLK_WORLD_57: SDLKey = 'SDLK_WORLD_57';
  const SDLK_WORLD_58: SDLKey = 'SDLK_WORLD_58';
  const SDLK_WORLD_59: SDLKey = 'SDLK_WORLD_59';
  const SDLK_RETURN: SDLKey = 'SDLK_RETURN';
  const SDLK_QUESTION: SDLKey = 'SDLK_QUESTION';
  const SDLK_BREAK: SDLKey = 'SDLK_BREAK';
  const SDLK_RSUPER: SDLKey = 'SDLK_RSUPER';
  const SDLK_WORLD_60: SDLKey = 'SDLK_WORLD_60';
  const SDLK_WORLD_61: SDLKey = 'SDLK_WORLD_61';
  const KMOD_MODE: SDLKey = 'KMOD_MODE';
  const SDLK_WORLD_62: SDLKey = 'SDLK_WORLD_62';
  const SDLK_UNDERSCORE: SDLKey = 'SDLK_UNDERSCORE';
  const SDLK_WORLD_63: SDLKey = 'SDLK_WORLD_63';
  const SDLK_UNKNOWN: SDLKey = 'SDLK_UNKNOWN';
  const SDLK_WORLD_64: SDLKey = 'SDLK_WORLD_64';
  const SDLK_BACKSPACE: SDLKey = 'SDLK_BACKSPACE';
  const SDLK_WORLD_65: SDLKey = 'SDLK_WORLD_65';
  const SDLK_EQUALS: SDLKey = 'SDLK_EQUALS';
  const SDLK_WORLD_66: SDLKey = 'SDLK_WORLD_66';
  const SDLK_PAGEDOWN: SDLKey = 'SDLK_PAGEDOWN';
  const SDLK_MODE: SDLKey = 'SDLK_MODE';
  const SDLK_WORLD_67: SDLKey = 'SDLK_WORLD_67';
  const SDLK_a: SDLKey = 'SDLK_a';
  const SDLK_WORLD_68: SDLKey = 'SDLK_WORLD_68';
  const SDLK_HOME: SDLKey = 'SDLK_HOME';
  const SDLK_b: SDLKey = 'SDLK_b';
  const SDLK_WORLD_69: SDLKey = 'SDLK_WORLD_69';
  const SDLK_c: SDLKey = 'SDLK_c';
  const SDLK_LMETA: SDLKey = 'SDLK_LMETA';
  const SDLK_d: SDLKey = 'SDLK_d';
  const SDLK_e: SDLKey = 'SDLK_e';
  const SDLK_RIGHTBRACKET: SDLKey = 'SDLK_RIGHTBRACKET';
  const SDLK_f: SDLKey = 'SDLK_f';
  const SDLK_g: SDLKey = 'SDLK_g';
  const SDLK_h: SDLKey = 'SDLK_h';
  const SDLK_i: SDLKey = 'SDLK_i';
  const SDLK_j: SDLKey = 'SDLK_j';
  const SDLK_k: SDLKey = 'SDLK_k';
  const SDLK_PRINT: SDLKey = 'SDLK_PRINT';
  const SDLK_l: SDLKey = 'SDLK_l';
  const SDLK_m: SDLKey = 'SDLK_m';
  const SDLK_WORLD_70: SDLKey = 'SDLK_WORLD_70';
  const SDLK_n: SDLKey = 'SDLK_n';
  const SDLK_WORLD_71: SDLKey = 'SDLK_WORLD_71';
  const SDLK_o: SDLKey = 'SDLK_o';
  const SDLK_WORLD_72: SDLKey = 'SDLK_WORLD_72';
  const SDLK_p: SDLKey = 'SDLK_p';
  const SDLK_WORLD_73: SDLKey = 'SDLK_WORLD_73';
  const SDLK_q: SDLKey = 'SDLK_q';
  const SDLK_WORLD_74: SDLKey = 'SDLK_WORLD_74';
  const SDLK_r: SDLKey = 'SDLK_r';
  const SDLK_COLON: SDLKey = 'SDLK_COLON';
  const SDLK_WORLD_75: SDLKey = 'SDLK_WORLD_75';
  const SDLK_s: SDLKey = 'SDLK_s';
  const SDLK_WORLD_76: SDLKey = 'SDLK_WORLD_76';
  const SDLK_t: SDLKey = 'SDLK_t';
  const SDLK_WORLD_77: SDLKey = 'SDLK_WORLD_77';
  const SDLK_u: SDLKey = 'SDLK_u';
  const SDLK_WORLD_78: SDLKey = 'SDLK_WORLD_78';
  const SDLK_v: SDLKey = 'SDLK_v';
  const SDLK_WORLD_79: SDLKey = 'SDLK_WORLD_79';
  const SDLK_w: SDLKey = 'SDLK_w';
  const SDLK_x: SDLKey = 'SDLK_x';
  const SDLK_PERIOD: SDLKey = 'SDLK_PERIOD';
  const SDLK_SEMICOLON: SDLKey = 'SDLK_SEMICOLON';
  const KMOD_NONE: SDLKey = 'KMOD_NONE';
  const SDLK_y: SDLKey = 'SDLK_y';
  const SDLK_EURO: SDLKey = 'SDLK_EURO';
  const SDLK_z: SDLKey = 'SDLK_z';
  const SDLK_SYSREQ: SDLKey = 'SDLK_SYSREQ';
  const SDLK_GREATER: SDLKey = 'SDLK_GREATER';
  const SDLK_DOLLAR: SDLKey = 'SDLK_DOLLAR';
  const SDLK_WORLD_80: SDLKey = 'SDLK_WORLD_80';
  const SDLK_WORLD_81: SDLKey = 'SDLK_WORLD_81';
  const SDLK_WORLD_82: SDLKey = 'SDLK_WORLD_82';
  const SDLK_F10: SDLKey = 'SDLK_F10';
  const SDLK_WORLD_83: SDLKey = 'SDLK_WORLD_83';
  const SDLK_F11: SDLKey = 'SDLK_F11';
  const SDLK_WORLD_84: SDLKey = 'SDLK_WORLD_84';
  const SDLK_LSHIFT: SDLKey = 'SDLK_LSHIFT';
  const SDLK_F12: SDLKey = 'SDLK_F12';
  const SDLK_WORLD_85: SDLKey = 'SDLK_WORLD_85';
  const SDLK_F13: SDLKey = 'SDLK_F13';
  const SDLK_PAGEUP: SDLKey = 'SDLK_PAGEUP';
  const SDLK_WORLD_86: SDLKey = 'SDLK_WORLD_86';
  const SDLK_F14: SDLKey = 'SDLK_F14';
  const SDLK_UP: SDLKey = 'SDLK_UP';
  const SDLK_WORLD_87: SDLKey = 'SDLK_WORLD_87';
  const KMOD_RCTRL: SDLKey = 'KMOD_RCTRL';
  const SDLK_F15: SDLKey = 'SDLK_F15';
  const SDLK_WORLD_88: SDLKey = 'SDLK_WORLD_88';
  const SDLK_WORLD_89: SDLKey = 'SDLK_WORLD_89';
  const SDLK_KP_MULTIPLY: SDLKey = 'SDLK_KP_MULTIPLY';
  const SDLK_END: SDLKey = 'SDLK_END';
  const SDLK_WORLD_90: SDLKey = 'SDLK_WORLD_90';
  const SDLK_CLEAR: SDLKey = 'SDLK_CLEAR';
  const SDLK_WORLD_91: SDLKey = 'SDLK_WORLD_91';
  const SDLK_AT: SDLKey = 'SDLK_AT';
  const SDLK_WORLD_92: SDLKey = 'SDLK_WORLD_92';
  const SDLK_WORLD_93: SDLKey = 'SDLK_WORLD_93';
  const SDLK_KP_DIVIDE: SDLKey = 'SDLK_KP_DIVIDE';
  const SDLK_WORLD_94: SDLKey = 'SDLK_WORLD_94';
  const SDLK_WORLD_95: SDLKey = 'SDLK_WORLD_95';
  const SDLK_ASTERISK: SDLKey = 'SDLK_ASTERISK';
  const SDLK_LSUPER: SDLKey = 'SDLK_LSUPER';
  const KMOD_RESERVED: SDLKey = 'KMOD_RESERVED';
  const KMOD_RMETA: SDLKey = 'KMOD_RMETA';
  const KMOD_LCTRL: SDLKey = 'KMOD_LCTRL';
  const SDLK_DOWN: SDLKey = 'SDLK_DOWN';
  const SDLK_NUMLOCK: SDLKey = 'SDLK_NUMLOCK';
  const SDLK_EXCLAIM: SDLKey = 'SDLK_EXCLAIM';
  const KMOD_LMETA: SDLKey = 'KMOD_LMETA';
  const SDLK_LAST: SDLKey = 'SDLK_LAST';
  const SDLK_HELP: SDLKey = 'SDLK_HELP';
  const SDLK_KP0: SDLKey = 'SDLK_KP0';
  const SDLK_KP1: SDLKey = 'SDLK_KP1';
  const SDLK_KP2: SDLKey = 'SDLK_KP2';
  const SDLK_SCROLLOCK: SDLKey = 'SDLK_SCROLLOCK';
  const SDLK_KP3: SDLKey = 'SDLK_KP3';
  const SDLK_KP_PLUS: SDLKey = 'SDLK_KP_PLUS';
  const SDLK_INSERT: SDLKey = 'SDLK_INSERT';
  const SDLK_KP4: SDLKey = 'SDLK_KP4';
  const SDLK_WORLD_10: SDLKey = 'SDLK_WORLD_10';
  const SDLK_KP5: SDLKey = 'SDLK_KP5';
  const SDLK_WORLD_11: SDLKey = 'SDLK_WORLD_11';
  const SDLK_MINUS: SDLKey = 'SDLK_MINUS';
  const SDLK_KP6: SDLKey = 'SDLK_KP6';
  const SDLK_WORLD_12: SDLKey = 'SDLK_WORLD_12';
  const SDLK_LEFTBRACKET: SDLKey = 'SDLK_LEFTBRACKET';
  const SDLK_KP7: SDLKey = 'SDLK_KP7';
  const SDLK_WORLD_13: SDLKey = 'SDLK_WORLD_13';
  const SDLK_KP8: SDLKey = 'SDLK_KP8';
  const SDLK_WORLD_14: SDLKey = 'SDLK_WORLD_14';
  const SDLK_KP9: SDLKey = 'SDLK_KP9';
  const SDLK_RIGHTPAREN: SDLKey = 'SDLK_RIGHTPAREN';
  const SDLK_WORLD_15: SDLKey = 'SDLK_WORLD_15';
  const SDLK_WORLD_16: SDLKey = 'SDLK_WORLD_16';
  const SDLK_QUOTE: SDLKey = 'SDLK_QUOTE';
  const SDLK_FIRST: SDLKey = 'SDLK_FIRST';
  const SDLK_WORLD_17: SDLKey = 'SDLK_WORLD_17';
  const KMOD_NUM: SDLKey = 'KMOD_NUM';
  const SDLK_WORLD_18: SDLKey = 'SDLK_WORLD_18';
  const SDLK_WORLD_19: SDLKey = 'SDLK_WORLD_19';
  const SDLK_QUOTEDBL: SDLKey = 'SDLK_QUOTEDBL';
  const KMOD_RSHIFT: SDLKey = 'KMOD_RSHIFT';
  const SDLK_MENU: SDLKey = 'SDLK_MENU';
  const KMOD_CAPS: SDLKey = 'KMOD_CAPS';
  const SDLK_WORLD_0: SDLKey = 'SDLK_WORLD_0';

  fun eq: SDLKey * SDLKey -> bool = "$1==$2";
  fun ne: SDLKey * SDLKey -> bool = "$1!=$2";
}
@doc()

@select(tangler('lib/SDL/SDL_mouse.flx'))
//Module        : SDL_mouse_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_mouse.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_BUTTON_RMASK      SDL_BUTTON(SDL_BUTTON_RIGHT)
//#define SDL_BUTTON_MMASK      SDL_BUTTON(SDL_BUTTON_MIDDLE)
//#define SDL_BUTTON_LMASK      SDL_BUTTON(SDL_BUTTON_LEFT)
//#define SDL_BUTTON_WHEELDOWN  5
//#define SDL_BUTTON_WHEELUP    4
//#define SDL_BUTTON_RIGHT      3
//#define SDL_BUTTON_MIDDLE     2
//#define SDL_BUTTON_LEFT               1
//#define SDL_BUTTON(X)         (SDL_PRESSED<<(X-1))
//#define _SDL_mouse_h

//INCLUDES
include"SDL/SDL_video";

module SDL_mouse_h
{
  requires package "sdl";
  header '#include "SDL_mouse.h"';
  open C_hack;
  open SDL_video_h;

  //CSTRUCTS
  cstruct SDL_Cursor {
    area: SDL_Rect;
    hot_x: int16;
    hot_y: int16;
    data: ptr[uint8];
    mask: ptr[uint8];
    save: ptr[ptr[uint8]];
    wm_cursor: ptr[WMcursor];
  }

  //PURE INCOMPLETE TYPES
  type _struct_WMcursor = 'struct WMcursor'; //local

  //STRUCT or UNION TAG ALIASES
  typedef WMcursor = _struct_WMcursor;

  /*
  //TYPE ALIASES
  typedef _struct_SDL_Cursor = SDL_Cursor;
  */

  //PROCEDURES
  proc SDL_FreeCursor: ptr[SDL_Cursor];
  proc SDL_SetCursor: ptr[SDL_Cursor];
  proc SDL_WarpMouse: uint16 * uint16;

  //FUNCTIONS
  fun SDL_CreateCursor: ptr[uint8] * ptr[uint8] * int * int * int * int -> ptr[SDL_Cursor];
  fun SDL_GetCursor: 1 -> ptr[SDL_Cursor];
  fun SDL_GetMouseState: ptr[int] * ptr[int] -> uint8;
  fun SDL_GetRelativeMouseState: ptr[int] * ptr[int] -> uint8;
  fun SDL_ShowCursor: int -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_mutex.flx'))
//Module        : SDL_mutex_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_mutex.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_MUTEX_MAXWAIT     (~(Uint32)0)
//#define SDL_MUTEX_TIMEDOUT    1
//#define _SDL_mutex_h

// DO NOT USE THIS MODULE
// FELIX HAS ITS OWN THREAD HANDLING

module SDL_mutex_h
{
  requires package "sdl";
  header '#include "SDL_mutex.h"';
  open C_hack;

  incomplete ctypes SDL_mutex, SDL_cond, SDL_sem;

  //PROCEDURES
  proc SDL_DestroyCond: ptr[SDL_cond];
  proc SDL_DestroyMutex: ptr[SDL_mutex];
  proc SDL_DestroySemaphore: ptr[SDL_sem];

  //FUNCTIONS
  fun SDL_CondBroadcast: ptr[SDL_cond] -> int;
  fun SDL_CondSignal: ptr[SDL_cond] -> int;
  fun SDL_CondWait: ptr[SDL_cond] * ptr[SDL_mutex] -> int;
  fun SDL_CondWaitTimeout: ptr[SDL_cond] * ptr[SDL_mutex] * uint32 -> int;
  fun SDL_CreateCond: 1 -> ptr[SDL_cond];
  fun SDL_CreateMutex: 1 -> ptr[SDL_mutex];
  fun SDL_CreateSemaphore: uint32 -> ptr[SDL_sem];
  fun SDL_SemPost: ptr[SDL_sem] -> int;
  fun SDL_SemTryWait: ptr[SDL_sem] -> int;
  fun SDL_SemValue: ptr[SDL_sem] -> uint32;
  fun SDL_SemWait: ptr[SDL_sem] -> int;
  fun SDL_SemWaitTimeout: ptr[SDL_sem] * uint32 -> int;
  fun SDL_mutexP: ptr[SDL_mutex] -> int;
  fun SDL_mutexV: ptr[SDL_mutex] -> int;
  fun SDL_LockMutex: ptr[SDL_mutex] -> int;
  fun SDL_UnlockMutex: ptr[SDL_mutex] -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_rwops.flx'))
//Module        : SDL_rwops_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_rwops.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_RWclose(ctx)              (ctx)->close(ctx)
//#define SDL_RWwrite(ctx, ptr, size, n)        (ctx)->write(ctx, ptr, size, n)
//#define SDL_RWread(ctx, ptr, size, n) (ctx)->read(ctx, ptr, size, n)
//#define SDL_RWtell(ctx)                       (ctx)->seek(ctx, 0, SEEK_CUR)
//#define SDL_RWseek(ctx, offset, whence)       (ctx)->seek(ctx, offset, whence)
//#define _SDL_RWops_h

//INCLUDES

module SDL_rwops_h
{
  open C_hack;

  //ABSTRACT TYPES
  type _struct_SDL_RWops = 'struct SDL_RWops';

  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_rwops_h_cft_1)(struct SDL_RWops *,  int, int);''';
  type SDL_rwops_h_cft_1 = 'SDL_rwops_h_cft_1';
  header '''typedef int (*SDL_rwops_h_cft_3)(struct SDL_RWops *,  void const *,  int, int);''';
  type SDL_rwops_h_cft_3 = 'SDL_rwops_h_cft_3';
  header '''typedef int (*SDL_rwops_h_cft_2)(struct SDL_RWops *,  void *, int,  int);''';
  type SDL_rwops_h_cft_2 = 'SDL_rwops_h_cft_2';
  header '''typedef int (*SDL_rwops_h_cft_4)(struct SDL_RWops *);''';
  type SDL_rwops_h_cft_4 = 'SDL_rwops_h_cft_4';

  //STRUCT or UNION TAG ALIASES
  typedef SDL_RWops = _struct_SDL_RWops;

  //PROCEDURES
  proc SDL_FreeRW: ptr[SDL_RWops];

  //FUNCTIONS
  fun SDL_AllocRW: 1 -> ptr[SDL_RWops];
  fun SDL_RWFromConstMem: caddress * int -> ptr[SDL_RWops];
  fun SDL_RWFromFP: ptr[FILE] * int -> ptr[SDL_RWops];
  fun SDL_RWFromFile: cptr[char] * cptr[char] -> ptr[SDL_RWops];
  fun SDL_RWFromMem: address * int -> ptr[SDL_RWops];

  //STRUCT and UNION FIELDS
  fun get_read: _struct_SDL_RWops -> SDL_rwops_h_cft_2 = '$1->read';
  fun get_write: _struct_SDL_RWops -> SDL_rwops_h_cft_3 = '$1->write';
  fun get_seek: _struct_SDL_RWops -> SDL_rwops_h_cft_1 = '$1->seek';
  fun get_close: _struct_SDL_RWops -> SDL_rwops_h_cft_4 = '$1->close';
  fun get_type: _struct_SDL_RWops -> uint32 = '$1->type';
}
@doc()

@select(tangler('lib/SDL/SDL_timer.flx'))
//Module        : SDL_timer_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_timer.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define TIMER_RESOLUTION      10      /* Experimentally determined */
//#define SDL_TIMESLICE         10
//#define _SDL_timer_h

//INCLUDES
include"SDL/SDL_types";

module SDL_timer_h
{
  requires package "sdl";
  header '#include "SDL_timer.h"';
  open C_hack;
  open SDL_types_h;

  //C FUNCTION POINTER TYPES
  header '''typedef Uint32 (*SDL_timer_h_cft_2)(Uint32,  void *);''';
  type SDL_timer_h_cft_2 = 'SDL_timer_h_cft_2';
  header '''typedef Uint32 (*SDL_timer_h_cft_1)(Uint32);''';
  type SDL_timer_h_cft_1 = 'SDL_timer_h_cft_1';

  //PURE INCOMPLETE TYPES
  type _struct__SDL_TimerID = 'struct _SDL_TimerID'; //local

  //TYPE ALIASES
  typedef SDL_NewTimerCallback = SDL_timer_h_cft_2;
  typedef SDL_TimerID = ptr[_struct__SDL_TimerID];
  typedef SDL_TimerCallback = SDL_timer_h_cft_1;

  //PROCEDURES
  proc SDL_Delay: uint32;

  //FUNCTIONS
  fun SDL_AddTimer: uint32 * SDL_timer_h_cft_2 * address -> SDL_TimerID;
  fun SDL_GetTicks: 1 -> uint32;
  fun SDL_RemoveTimer: SDL_TimerID -> SDL_bool;
  fun SDL_SetTimer: uint32 * SDL_timer_h_cft_1 -> int;

  //CALLBACK TYPE WRAPPERS
  //callback type SDL_timer_h_cft_2, client data at 1
  typedef _fcbat_SDL_timer_h_cft_2 = uint32;
  export type (_fcbat_SDL_timer_h_cft_2) as "_fcbat_SDL_timer_h_cft_2";
  typedef _fcbt_SDL_timer_h_cft_2 = uint32 -> uint32;
  export type (_fcbt_SDL_timer_h_cft_2) as "_fcbt_SDL_timer_h_cft_2";
  header '''Uint32 _fcbw_SDL_timer_h_cft_2(Uint32 a1,  void *a2);''';

  const _fcbw_SDL_timer_h_cft_2: SDL_timer_h_cft_2 = "_fcbw_SDL_timer_h_cft_2";
  body '''
  Uint32 _fcbw_SDL_timer_h_cft_2(Uint32 a1,  void *a2){
    return ((_fcbt_SDL_timer_h_cft_2)a2)->apply(a1);
  }''';


  //CALLBACK CLIENT WRAPPERS
  //callback client SDL_AddTimer, client data at 1, callback at 2
  fun wrapper_SDL_AddTimer(a1: uint32, a2: _fcbt_SDL_timer_h_cft_2): SDL_TimerID= {
    return SDL_AddTimer(a1, _fcbw_SDL_timer_h_cft_2, C_hack::cast[address]a2);
  }
}
@doc()

@select(tangler('lib/SDL/SDL_types.flx'))
//Module        : SDL_types_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_types.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_COMPILE_TIME_ASSERT(name, x)               \
//#define SDL_HAS_64BIT_TYPE    __int64
//#define SDL_HAS_64BIT_TYPE    long long
//#define SDL_HAS_64BIT_TYPE    long
//#define SDL_TABLESIZE(table)  (sizeof(table)/sizeof(table[0]))
//#define _SDL_types_h

module SDL_types_h
{
  requires package "sdl";
  header '#include "SDL_types.h"';
  open C_hack;

  //ABSTRACT TYPES
  type SDL_bool = 'SDL_bool';
  type SDL_DUMMY_ENUM = 'SDL_DUMMY_ENUM';

  //TYPE ALIASES
  typedef Sint64 = vlong;
  typedef SDL_dummy_uint32 = ptr[int];
  typedef SDL_dummy_sint64 = ptr[int];
  typedef SDL_dummy_sint16 = ptr[int];
  typedef SDL_dummy_sint8 = ptr[int];
  typedef SDL_dummy_sint32 = ptr[int];
  typedef SDL_dummy_uint8 = ptr[int];
  typedef Uint64 = uvlong;
  typedef SDL_dummy_uint64 = ptr[int];
  typedef SDL_dummy_uint16 = ptr[int];
  typedef SDL_dummy_enum = ptr[int];

  //ENUMERATION CONSTANTS
  const SDL_PRESSED: int = 'SDL_PRESSED';
  const DUMMY_ENUM_VALUE: int = 'DUMMY_ENUM_VALUE';
  const SDL_RELEASED: int = 'SDL_RELEASED';
  const SDL_TRUE: int = 'SDL_TRUE';
  const SDL_FALSE: int = 'SDL_FALSE';
}
@doc()

@select(tangler('lib/SDL/SDL_version.flx'))
//Module        : SDL_version_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_version.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_VERSION_ATLEAST(X, Y, Z) \
//#define SDL_COMPILEDVERSION \
//#define SDL_VERSIONNUM(X, Y, Z)                                               \
//#define SDL_VERSION(X)                                                        \
//#define SDL_PATCHLEVEL                8
//#define SDL_MINOR_VERSION     2
//#define SDL_MAJOR_VERSION     1
//#define _SDL_version_h

module SDL_version_h
{
  requires package "sdl";
  header '#include "SDL_version.h"';
  open C_hack;

  //CSTRUCTS
  cstruct SDL_version {
    major: uint8;
    minor: uint8;
    patch: uint8;
  }

  //STRUCT or UNION TAG ALIASES

  //TYPE ALIASES
  typedef _struct_SDL_version = SDL_version;

  //FUNCTIONS
  fun SDL_Linked_Version: 1 -> cptr[SDL_version];
}
@doc()

@select(tangler('lib/SDL/SDL_video.flx'))
//Module        : SDL_video_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_video.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_BlitSurface SDL_UpperBlit
//#define SDL_SaveBMP(surface, file) \
//#define SDL_AllocSurface    SDL_CreateRGBSurface
//#define SDL_PHYSPAL 0x02
//#define SDL_LOGPAL 0x01
//#define SDL_YVYU_OVERLAY  0x55595659  /* Packed mode: Y0+V0+Y1+U0 (1 plane) */
//#define SDL_UYVY_OVERLAY  0x59565955  /* Packed mode: U0+Y0+V0+Y1 (1 plane) */
//#define SDL_YUY2_OVERLAY  0x32595559  /* Packed mode: Y0+U0+Y1+V0 (1 plane) */
//#define SDL_IYUV_OVERLAY  0x56555949  /* Planar mode: Y + U + V  (3 planes) */
//#define SDL_YV12_OVERLAY  0x32315659  /* Planar mode: Y + V + U  (3 planes) */
//#define SDL_PREALLOC  0x01000000      /* Surface uses preallocated memory */
//#define SDL_SRCALPHA  0x00010000      /* Blit uses source alpha blending */
//#define SDL_RLEACCEL  0x00004000      /* Surface is RLE encoded */
//#define SDL_RLEACCELOK        0x00002000      /* Private flag */
//#define SDL_SRCCOLORKEY       0x00001000      /* Blit uses a source color key */
//#define SDL_HWACCEL   0x00000100      /* Blit uses hardware acceleration */
//#define SDL_NOFRAME   0x00000020      /* No window caption or edge frame */
//#define SDL_RESIZABLE 0x00000010      /* This video mode may be resized */
//#define SDL_OPENGLBLIT        0x0000000A      /* Create an OpenGL rendering context and use it for blitting */
//#define SDL_OPENGL      0x00000002      /* Create an OpenGL rendering context */
//#define SDL_FULLSCREEN        0x80000000      /* Surface is a full screen display */
//#define SDL_DOUBLEBUF 0x40000000      /* Set up double-buffered video mode */
//#define SDL_HWPALETTE 0x20000000      /* Surface has exclusive palette */
//#define SDL_ANYFORMAT 0x10000000      /* Allow any video depth/pixel-format */
//#define SDL_ASYNCBLIT 0x00000004      /* Use asynchronous blits if possible */
//#define SDL_HWSURFACE 0x00000001      /* Surface is in video memory */
//#define SDL_SWSURFACE 0x00000000      /* Surface is in system memory */
//#define SDL_Colour SDL_Color
//#define SDL_ALPHA_TRANSPARENT 0
//#define SDL_ALPHA_OPAQUE 255
//#define _SDL_video_h

//INCLUDES
include"SDL/SDL_rwops";
include"SDL/SDL_types";

module SDL_video_h
{
  requires package "sdl";
  header '#include "SDL_video.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_types_h;

  fun SDL_MUSTLOCK: ptr[SDL_Surface] -> bool;
  const SDL_PHYSPAL : uint32;
  const SDL_LOGPAL : uint32;
  const SDL_YVYU_OVERLAY  : uint32;
  const SDL_UYVY_OVERLAY  : uint32;
  const SDL_YUY2_OVERLAY  : uint32;
  const SDL_IYUV_OVERLAY  : uint32;
  const SDL_YV12_OVERLAY  : uint32;
  const SDL_PREALLOC  : uint32;
  const SDL_SRCALPHA  : uint32;
  const SDL_RLEACCEL  : uint32;
  const SDL_RLEACCELOK        : uint32;
  const SDL_SRCCOLORKEY       : uint32;
  const SDL_HWACCEL   : uint32;
  const SDL_NOFRAME   : uint32;
  const SDL_RESIZABLE : uint32;
  const SDL_OPENGLBLIT        : uint32;
  const SDL_OPENGL      : uint32;
  const SDL_FULLSCREEN        : uint32;
  const SDL_DOUBLEBUF : uint32;
  const SDL_HWPALETTE : uint32;
  const SDL_ANYFORMAT : uint32;
  const SDL_ASYNCBLIT : uint32;
  const SDL_HWSURFACE : uint32;
  const SDL_SWSURFACE : uint32;

  //ABSTRACT TYPES
  type SDL_GrabMode = 'SDL_GrabMode';
  type SDL_GLattr = 'SDL_GLattr';

  //CSTRUCTS
  cstruct SDL_Color {
    r: uint8;
    g: uint8;
    b: uint8;
    unused: uint8;
  }
  cstruct SDL_Surface {
    flags: uint32;
    format: ptr[SDL_PixelFormat];
    w: int;
    h: int;
    pitch: uint16;
    pixels: address;
    offset: int;
    hwdata: ptr[_struct_private_hwdata];
    clip_rect: SDL_Rect;
    unused1: uint32;
    locked: uint32;
    map: ptr[_struct_SDL_BlitMap];
    format_version: uint;
    refcount: int;
  }
  cstruct SDL_Overlay {
    format: uint32;
    w: int;
    h: int;
    planes: int;
    pitches: ptr[uint16];
    pixels: ptr[ptr[uint8]];
    hwfuncs: ptr[_struct_private_yuvhwfuncs];
    hwdata: ptr[_struct_private_yuvhwdata];
    hw_overlay: uint32;
    UnusedBits: uint32;
  }
  cstruct SDL_Palette {
    ncolors: int;
    colors: ptr[SDL_Color];
  }
  cstruct SDL_Rect {
    x: int16;
    y: int16;
    w: uint16;
    h: uint16;
  }
  cstruct SDL_VideoInfo {
    hw_available: uint32;
    wm_available: uint32;
    UnusedBits1: uint32;
    UnusedBits2: uint32;
    blit_hw: uint32;
    blit_hw_CC: uint32;
    blit_hw_A: uint32;
    blit_sw: uint32;
    blit_sw_CC: uint32;
    blit_sw_A: uint32;
    blit_fill: uint32;
    UnusedBits3: uint32;
    video_mem: uint32;
    vfmt: ptr[SDL_PixelFormat];
  }
  cstruct SDL_PixelFormat {
    palette: ptr[SDL_Palette];
    BitsPerPixel: uint8;
    BytesPerPixel: uint8;
    Rloss: uint8;
    Gloss: uint8;
    Bloss: uint8;
    Aloss: uint8;
    Rshift: uint8;
    Gshift: uint8;
    Bshift: uint8;
    Ashift: uint8;
    Rmask: uint32;
    Gmask: uint32;
    Bmask: uint32;
    Amask: uint32;
    colorkey: uint32;
    alpha: uint8;
  }

  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_video_h_cft_1)(struct SDL_Surface *,  SDL_Rect *,  struct SDL_Surface *,  SDL_Rect *);''';
  type SDL_video_h_cft_1 = 'SDL_video_h_cft_1';

  //EXTERNALLY COMPLETED TYPES
  //type _struct_SDL_Surface defined in SDL_video_h='SDL_video.h';

  //PURE INCOMPLETE TYPES
  type _struct_SDL_BlitMap = 'struct SDL_BlitMap'; //local
  type _struct_private_yuvhwfuncs = 'struct private_yuvhwfuncs'; //local
  type _struct_private_hwdata = 'struct private_hwdata'; //local
  type _struct_private_yuvhwdata = 'struct private_yuvhwdata'; //local

  //STRUCT or UNION TAG ALIASES

  //TYPE ALIASES
  typedef _struct_SDL_Surface = SDL_Surface;
  typedef _struct_SDL_Overlay = SDL_Overlay;
  typedef _struct_SDL_Palette = SDL_Palette;
  typedef _struct_SDL_PixelFormat = SDL_PixelFormat;
  typedef _struct_SDL_Rect = SDL_Rect;
  typedef _struct_SDL_Color = SDL_Color;
  typedef _struct_SDL_VideoInfo = SDL_VideoInfo;
  typedef SDL_blit = SDL_video_h_cft_1;

  //ENUMERATION CONSTANTS
  const SDL_GL_STENCIL_SIZE: int = 'SDL_GL_STENCIL_SIZE';
  const SDL_GL_MULTISAMPLEBUFFERS: int = 'SDL_GL_MULTISAMPLEBUFFERS';
  const SDL_GL_STEREO: int = 'SDL_GL_STEREO';
  const SDL_GL_ACCUM_RED_SIZE: int = 'SDL_GL_ACCUM_RED_SIZE';
  const SDL_GRAB_OFF: int = 'SDL_GRAB_OFF';
  const SDL_GL_ACCUM_GREEN_SIZE: int = 'SDL_GL_ACCUM_GREEN_SIZE';
  const SDL_GL_ACCUM_ALPHA_SIZE: int = 'SDL_GL_ACCUM_ALPHA_SIZE';
  const SDL_GL_DEPTH_SIZE: int = 'SDL_GL_DEPTH_SIZE';
  const SDL_GRAB_FULLSCREEN: int = 'SDL_GRAB_FULLSCREEN';
  const SDL_GL_RED_SIZE: int = 'SDL_GL_RED_SIZE';
  const SDL_GL_BLUE_SIZE: int = 'SDL_GL_BLUE_SIZE';
  const SDL_GL_ACCUM_BLUE_SIZE: int = 'SDL_GL_ACCUM_BLUE_SIZE';
  const SDL_GL_GREEN_SIZE: int = 'SDL_GL_GREEN_SIZE';
  const SDL_GRAB_QUERY: int = 'SDL_GRAB_QUERY';
  const SDL_GL_ALPHA_SIZE: int = 'SDL_GL_ALPHA_SIZE';
  const SDL_GL_MULTISAMPLESAMPLES: int = 'SDL_GL_MULTISAMPLESAMPLES';
  const SDL_GL_DOUBLEBUFFER: int = 'SDL_GL_DOUBLEBUFFER';
  const SDL_GL_BUFFER_SIZE: int = 'SDL_GL_BUFFER_SIZE';
  const SDL_GRAB_ON: int = 'SDL_GRAB_ON';

  //PROCEDURES
  proc SDL_FreeSurface: ptr[SDL_Surface];
  proc SDL_FreeYUVOverlay: ptr[SDL_Overlay];
  proc SDL_GL_Lock: 1;
  proc SDL_GL_SwapBuffers: 1;
  proc SDL_GL_Unlock: 1;
  proc SDL_GL_UpdateRects: int * ptr[SDL_Rect];
  proc SDL_GetClipRect: ptr[SDL_Surface] * ptr[SDL_Rect];
  proc SDL_GetRGB: uint32 * ptr[SDL_PixelFormat] * ptr[uint8] * ptr[uint8] * ptr[uint8];
  proc SDL_GetRGBA: uint32 * ptr[SDL_PixelFormat] * ptr[uint8] * ptr[uint8] * ptr[uint8] * ptr[uint8];
  proc SDL_UnlockSurface: ptr[SDL_Surface];
  proc SDL_UnlockYUVOverlay: ptr[SDL_Overlay];
  proc SDL_UpdateRect: ptr[SDL_Surface] * int32 * int32 * uint32 * uint32;
  proc SDL_UpdateRects: ptr[SDL_Surface] * int * ptr[SDL_Rect];
  proc SDL_VideoQuit: 1;
  proc SDL_WM_GetCaption: ptr[ptr[char]] * ptr[ptr[char]];
  proc SDL_WM_SetCaption: cptr[char] * cptr[char];
  proc SDL_WM_SetIcon: ptr[SDL_Surface] * ptr[uint8];

  //FUNCTIONS
  fun SDL_BlitSurface : ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_ConvertSurface: ptr[SDL_Surface] * ptr[SDL_PixelFormat] * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateRGBSurface: uint32 * int * int * int * uint32 * uint32 * uint32 * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateRGBSurfaceFrom: address * int * int * int * int * uint32 * uint32 * uint32 * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateYUVOverlay: int * int * uint32 * ptr[SDL_Surface] -> ptr[SDL_Overlay];
  fun SDL_DisplayFormat: ptr[SDL_Surface] -> ptr[SDL_Surface];
  fun SDL_DisplayFormatAlpha: ptr[SDL_Surface] -> ptr[SDL_Surface];
  fun SDL_DisplayYUVOverlay: ptr[SDL_Overlay] * ptr[SDL_Rect] -> int;
  fun SDL_FillRect: ptr[SDL_Surface] * ptr[SDL_Rect] * uint32 -> int;
  fun SDL_Flip: ptr[SDL_Surface] -> int;
  fun SDL_GL_GetAttribute: SDL_GLattr * ptr[int] -> int;
  fun SDL_GL_GetProcAddress: cptr[char] -> address;
  fun SDL_GL_LoadLibrary: cptr[char] -> int;
  fun SDL_GL_SetAttribute: SDL_GLattr * int -> int;
  fun SDL_GetGammaRamp: ptr[uint16] * ptr[uint16] * ptr[uint16] -> int;
  fun SDL_GetVideoInfo: 1 -> cptr[SDL_VideoInfo];
  fun SDL_GetVideoSurface: 1 -> ptr[SDL_Surface];
  fun SDL_ListModes: ptr[SDL_PixelFormat] * uint32 -> ptr[ptr[SDL_Rect]];
  fun SDL_LoadBMP_RW: ptr[SDL_RWops] * int -> ptr[SDL_Surface];
  fun SDL_LoadBMP:cptr[char]->ptr[SDL_Surface];
  fun SDL_LockSurface: ptr[SDL_Surface] -> int;
  fun SDL_LockYUVOverlay: ptr[SDL_Overlay] -> int;
  fun SDL_LowerBlit: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_MapRGB: ptr[SDL_PixelFormat] * uint8 * uint8 * uint8 -> uint32;
  fun SDL_MapRGBA: ptr[SDL_PixelFormat] * uint8 * uint8 * uint8 * uint8 -> uint32;
  fun SDL_SaveBMP_RW: ptr[SDL_Surface] * ptr[SDL_RWops] * int -> int;
  fun SDL_SetAlpha: ptr[SDL_Surface] * uint32 * uint8 -> int;
  fun SDL_SetClipRect: ptr[SDL_Surface] * cptr[SDL_Rect] -> SDL_bool;
  fun SDL_SetColorKey: ptr[SDL_Surface] * uint32 * uint32 -> int;
  fun SDL_SetColors: ptr[SDL_Surface] * ptr[SDL_Color] * int * int -> int;
  fun SDL_SetGamma: float * float * float -> int;
  fun SDL_SetGammaRamp: cptr[uint16] * cptr[uint16] * cptr[uint16] -> int;
  fun SDL_SetPalette: ptr[SDL_Surface] * int * ptr[SDL_Color] * int * int -> int;
  fun SDL_SetVideoMode: int * int * int * uint32 -> ptr[SDL_Surface];
  fun SDL_SoftStretch: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_UpperBlit: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_VideoDriverName: ptr[char] * int -> ptr[char];
  fun SDL_VideoInit: cptr[char] * uint32 -> int;
  fun SDL_VideoModeOK: int * int * int * uint32 -> int;
  fun SDL_WM_GrabInput: SDL_GrabMode -> SDL_GrabMode;
  fun SDL_WM_IconifyWindow: 1 -> int;
  fun SDL_WM_ToggleFullScreen: ptr[SDL_Surface] -> int;
}

@select(tangler('lib/SDL/SDL_endian.flx'))
//Module        : SDL_endian_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_endian.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDL_SwapBE64(X)       (X)
//#define SDL_SwapBE32(X)       (X)
//#define SDL_SwapBE16(X)       (X)
//#define SDL_SwapLE64(X)       SDL_Swap64(X)
//#define SDL_SwapLE32(X)       SDL_Swap32(X)
//#define SDL_SwapLE16(X)       SDL_Swap16(X)
//#define SDL_SwapBE64(X)       SDL_Swap64(X)
//#define SDL_SwapBE32(X)       SDL_Swap32(X)
//#define SDL_SwapBE16(X)       SDL_Swap16(X)
//#define SDL_SwapLE64(X)       (X)
//#define SDL_SwapLE32(X)       (X)
//#define SDL_SwapLE16(X)       (X)
//#define SDL_Swap64(X) (X)
//#define _SDL_endian_h

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_types";

module SDL_endian_h
{
  requires package "sdl";
  header '#include "SDL_endian.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_types_h;

  //FUNCTIONS
  fun SDL_ReadBE16: ptr[SDL_RWops] -> uint16;
  fun SDL_ReadBE32: ptr[SDL_RWops] -> uint32;
  fun SDL_ReadBE64: ptr[SDL_RWops] -> Uint64;
  fun SDL_ReadLE16: ptr[SDL_RWops] -> uint16;
  fun SDL_ReadLE32: ptr[SDL_RWops] -> uint32;
  fun SDL_ReadLE64: ptr[SDL_RWops] -> Uint64;
  fun SDL_Swap16: uint16 -> uint16;
  fun SDL_Swap32: uint32 -> uint32;
  fun SDL_Swap64: Uint64 -> Uint64;
  fun SDL_WriteBE16: ptr[SDL_RWops] * uint16 -> int;
  fun SDL_WriteBE32: ptr[SDL_RWops] * uint32 -> int;
  fun SDL_WriteBE64: ptr[SDL_RWops] * Uint64 -> int;
  fun SDL_WriteLE16: ptr[SDL_RWops] * uint16 -> int;
  fun SDL_WriteLE32: ptr[SDL_RWops] * uint32 -> int;
  fun SDL_WriteLE64: ptr[SDL_RWops] * Uint64 -> int;
}

@select(tangler('lib/SDL/SDL_framerate.flx'))
//Module        : SDL_framerate_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_framerate.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define FPS_DEFAULT           30
//#define FPS_LOWER_LIMIT               1
//#define FPS_UPPER_LIMIT               200
//#define _SDL_framerate_h

//INCLUDES
include "SDL/SDL";

module SDL_framerate_h
{
  requires package "sdl";
  header '#include "SDL_framerate.h"';
  open C_hack;
  open SDL_h;

  //ABSTRACT TYPES
  type FPSmanager = 'FPSmanager';

  //PROCEDURES
  proc SDL_framerateDelay: ptr[FPSmanager];
  proc SDL_initFramerate: ptr[FPSmanager];

  //FUNCTIONS
  fun SDL_getFramerate: ptr[FPSmanager] -> int;
  fun SDL_setFramerate: ptr[FPSmanager] * int -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_gfxPrimitives.flx'))
//Module        : SDL_gfxPrimitives_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_gfxPrimitives.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define SDL_GFXPRIMITIVES_MINOR       0
//#define SDL_GFXPRIMITIVES_MAJOR       2
//#define M_PI  3.141592654
//#define _SDL_gfxPrimitives_h

//INCLUDES
include "SDL/SDL";
include "SDL/SDL_video";

module SDL_gfxPrimitives_h
{
  requires package "sdl";
  header '#include "SDL_gfxPrimitives.h"';
  open C_hack;
  open SDL_h;
  open SDL_video_h;
  open math_h;

  //FUNCTIONS
  fun aacircleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun aacircleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aaellipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aaellipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aalineColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aalineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aapolygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint32 -> int;
  fun aapolygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun aatrigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aatrigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun bezierColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int * uint32 -> int;
  fun bezierRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun boxColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun boxRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun characterColor: ptr[SDL_Surface] * int16 * int16 * char * uint32 -> int;
  fun characterRGBA: ptr[SDL_Surface] * int16 * int16 * char * uint8 * uint8 * uint8 * uint8 -> int;
  fun circleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun circleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun ellipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun ellipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledCircleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun filledCircleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledEllipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun filledEllipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledPolygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int -> int;
  fun filledPolygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledTrigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * int -> int;
  fun filledTrigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledpieColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun filledpieRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun hlineColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun hlineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun lineColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun lineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun pixelColor: ptr[SDL_Surface] * int16 * int16 * uint32 -> int;
  fun pixelRGBA: ptr[SDL_Surface] * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun polygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint32 -> int;
  fun polygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun rectangleColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun rectangleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun stringColor: ptr[SDL_Surface] * int16 * int16 * ptr[char] * uint32 -> int;
  fun stringRGBA: ptr[SDL_Surface] * int16 * int16 * ptr[char] * uint8 * uint8 * uint8 * uint8 -> int;
  fun trigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun trigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun vlineColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun vlineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_gfxPrimitives_font.flx'))
//Module        : SDL_gfxPrimitives_font_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_gfxPrimitives_font.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define GFX_FONTDATAMAX (8*256)

module SDL_gfxPrimitives_font_h
{
  requires package "sdl";
  header '#include "SDL_gfxPrimitives_font.h"';
  open C_hack;

  //VARIABLES
  const gfxPrimitivesFontdata: ptr[utiny] = 'gfxPrimitivesFontdata';
}
@doc()

@select(tangler('lib/SDL/SDL_image.flx'))
//Module        : SDL_image_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_image.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define IMG_GetError  SDL_GetError
//#define IMG_SetError  SDL_SetError
//#define SDL_IMAGE_VERSION(X)                                          \
//#define SDL_IMAGE_PATCHLEVEL  4
//#define SDL_IMAGE_MINOR_VERSION       2
//#define SDL_IMAGE_MAJOR_VERSION       1
//#define _SDL_IMAGE_H

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";
include "SDL/SDL_video";

module SDL_image_h
{
  requires package "sdl";
  header '#include "SDL_image.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  open SDL_video_h;

  //FUNCTIONS
  fun IMG_InvertAlpha: int -> int;
  fun IMG_Linked_Version: 1 -> cptr[SDL_version];
  fun IMG_Load: cptr[char] -> ptr[SDL_Surface];
  fun IMG_LoadBMP_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadGIF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadJPG_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadLBM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPCX_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPNG_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPNM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTGA_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTIF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTyped_RW: ptr[SDL_RWops] * int * ptr[char] -> ptr[SDL_Surface];
  fun IMG_LoadXCF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadXPM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_Load_RW: ptr[SDL_RWops] * int -> ptr[SDL_Surface];
  fun IMG_ReadXPMFromArray: ptr[ptr[char]] -> ptr[SDL_Surface];
  fun IMG_isBMP: ptr[SDL_RWops] -> int;
  fun IMG_isGIF: ptr[SDL_RWops] -> int;
  fun IMG_isJPG: ptr[SDL_RWops] -> int;
  fun IMG_isLBM: ptr[SDL_RWops] -> int;
  fun IMG_isPCX: ptr[SDL_RWops] -> int;
  fun IMG_isPNG: ptr[SDL_RWops] -> int;
  fun IMG_isPNM: ptr[SDL_RWops] -> int;
  fun IMG_isTIF: ptr[SDL_RWops] -> int;
  fun IMG_isXCF: ptr[SDL_RWops] -> int;
  fun IMG_isXPM: ptr[SDL_RWops] -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_imageFilter.flx'))
//Module        : SDL_imageFilter_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_imageFilter.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define _SDL_imageFilter_h

module SDL_imageFilter_h
{
  requires package "sdl";
  header '#include "SDL_imageFilter.h"';
  open C_hack;

  //PROCEDURES
  proc SDL_imageFilterAlignStack: 1;
  proc SDL_imageFilterMMXoff: 1;
  proc SDL_imageFilterMMXon: 1;
  proc SDL_imageFilterRestoreStack: 1;

  //FUNCTIONS
  fun SDL_imageFilterAbsDiff: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterAdd: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterAddByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterAddByteToHalf: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterBinarizeUsingThreshold: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterBitAnd: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterBitNegation: ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterBitOr: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterClipToRange: ptr[utiny] * ptr[utiny] * int * utiny * utiny -> int;
  fun SDL_imageFilterConvolveKernel3x3Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel3x3ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel5x5Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel5x5ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel7x7Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel7x7ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel9x9Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel9x9ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterDiv: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMMXdetect: 1 -> int;
  fun SDL_imageFilterMean: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMult: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultByByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterMultDivby2: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultDivby4: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultNor: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterNormalizeLinear: ptr[utiny] * ptr[utiny] * int * int * int * int * int -> int;
  fun SDL_imageFilterShiftLeft: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftLeftByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftRight: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftRightAndMultByByte: ptr[utiny] * ptr[utiny] * int * utiny * utiny -> int;
  fun SDL_imageFilterSobelX: ptr[utiny] * ptr[utiny] * int * int -> int;
  fun SDL_imageFilterSobelXShiftRight: ptr[utiny] * ptr[utiny] * int * int * utiny -> int;
  fun SDL_imageFilterSub: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterSubByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_mixer.flx'))
//Module        : SDL_mixer_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_mixer.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define Mix_GetError  SDL_GetError
//#define Mix_SetError  SDL_SetError
//#define Mix_FadeInChannel(channel,chunk,loops,ms) Mix_FadeInChannelTimed(channel,chunk,loops,ms,-1)
//#define Mix_PlayChannel(channel,chunk,loops) Mix_PlayChannelTimed(channel,chunk,loops,-1)
//#define MIX_EFFECTSMAXSPEED  "MIX_EFFECTSMAXSPEED"
//#define MIX_CHANNEL_POST  -2
//#define Mix_LoadWAV(file)     Mix_LoadWAV_RW(SDL_RWFromFile(file, "rb"), 1)
//#define MIX_MAX_VOLUME                128     /* Volume of a chunk */
//#define MIX_DEFAULT_CHANNELS  2
//#define MIX_DEFAULT_FORMAT    AUDIO_S16MSB
//#define MIX_DEFAULT_FORMAT    AUDIO_S16LSB
//#define MIX_DEFAULT_FREQUENCY 22050
//#define MIX_CHANNELS  8
//#define MIX_VERSION(X)                SDL_MIXER_VERSION(X)
//#define MIX_PATCHLEVEL                SDL_MIXER_PATCHLEVEL
//#define MIX_MINOR_VERSION     SDL_MIXER_MINOR_VERSION
//#define MIX_MAJOR_VERSION     SDL_MIXER_MAJOR_VERSION
//#define SDL_MIXER_VERSION(X)                                          \
//#define SDL_MIXER_PATCHLEVEL  6
//#define SDL_MIXER_MINOR_VERSION       2
//#define SDL_MIXER_MAJOR_VERSION       1
//#define _SDL_MIXER_H

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";

module SDL_mixer_h
{
  requires package "sdl";
  header '#include "SDL_mixer.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;

  //ABSTRACT TYPES
  type Mix_MusicType = 'Mix_MusicType';
  type Mix_Chunk = 'Mix_Chunk';
  type Mix_Fading = 'Mix_Fading';

  //C FUNCTION POINTER TYPES
  header '''typedef void (*SDL_mixer_h_cft_3)(void *, Uint8 *, int);''';
  type SDL_mixer_h_cft_3 = 'SDL_mixer_h_cft_3';
  header '''typedef void (*SDL_mixer_h_cft_1)(int, void *, int,  void *);''';
  type SDL_mixer_h_cft_1 = 'SDL_mixer_h_cft_1';
  header '''typedef void (*SDL_mixer_h_cft_2)(int, void *);''';
  type SDL_mixer_h_cft_2 = 'SDL_mixer_h_cft_2';
  header '''typedef void (*SDL_mixer_h_cft_5)(int);''';
  type SDL_mixer_h_cft_5 = 'SDL_mixer_h_cft_5';
  header '''typedef void (*SDL_mixer_h_cft_4)(void);''';
  type SDL_mixer_h_cft_4 = 'SDL_mixer_h_cft_4';

  //PURE INCOMPLETE TYPES
  type _struct__Mix_Music = 'struct _Mix_Music'; //local

  //STRUCT or UNION TAG ALIASES
  typedef Mix_Music = _struct__Mix_Music;

  //TYPE ALIASES
  typedef Mix_EffectDone_t = SDL_mixer_h_cft_2;
  typedef Mix_EffectFunc_t = SDL_mixer_h_cft_1;

  //ENUMERATION CONSTANTS
  const MUS_CMD: int = 'MUS_CMD';
  const MIX_FADING_OUT: int = 'MIX_FADING_OUT';
  const MIX_NO_FADING: int = 'MIX_NO_FADING';
  const MIX_FADING_IN: int = 'MIX_FADING_IN';
  const MUS_WAV: int = 'MUS_WAV';
  const MUS_MID: int = 'MUS_MID';
  const MUS_OGG: int = 'MUS_OGG';
  const MUS_NONE: int = 'MUS_NONE';
  const MUS_MOD: int = 'MUS_MOD';
  const MUS_MP3: int = 'MUS_MP3';

  //PROCEDURES
  proc Mix_ChannelFinished: SDL_mixer_h_cft_5;
  proc Mix_CloseAudio: 1;
  proc Mix_FreeChunk: ptr[Mix_Chunk];
  proc Mix_FreeMusic: ptr[Mix_Music];
  proc Mix_HookMusic: SDL_mixer_h_cft_3 * address;
  proc Mix_HookMusicFinished: SDL_mixer_h_cft_4;
  proc Mix_Pause: int;
  proc Mix_PauseMusic: 1;
  proc Mix_Resume: int;
  proc Mix_ResumeMusic: 1;
  proc Mix_RewindMusic: 1;
  proc Mix_SetPostMix: SDL_mixer_h_cft_3 * address;

  //FUNCTIONS
  fun Mix_AllocateChannels: int -> int;
  fun Mix_ExpireChannel: int * int -> int;
  fun Mix_FadeInChannelTimed: int * ptr[Mix_Chunk] * int * int * int -> int;
  fun Mix_FadeInMusic: ptr[Mix_Music] * int * int -> int;
  fun Mix_FadeInMusicPos: ptr[Mix_Music] * int * int * double -> int;
  fun Mix_FadeOutChannel: int * int -> int;
  fun Mix_FadeOutGroup: int * int -> int;
  fun Mix_FadeOutMusic: int -> int;
  fun Mix_FadingChannel: int -> Mix_Fading;
  fun Mix_FadingMusic: 1 -> Mix_Fading;
  fun Mix_GetChunk: int -> ptr[Mix_Chunk];
  fun Mix_GetMusicHookData: 1 -> address;
  fun Mix_GetMusicType: cptr[Mix_Music] -> Mix_MusicType;
  fun Mix_GetSynchroValue: 1 -> int;
  fun Mix_GroupAvailable: int -> int;
  fun Mix_GroupChannel: int * int -> int;
  fun Mix_GroupChannels: int * int * int -> int;
  fun Mix_GroupCount: int -> int;
  fun Mix_GroupNewer: int -> int;
  fun Mix_GroupOldest: int -> int;
  fun Mix_HaltChannel: int -> int;
  fun Mix_HaltGroup: int -> int;
  fun Mix_HaltMusic: 1 -> int;
  fun Mix_Linked_Version: 1 -> cptr[SDL_version];
  fun Mix_LoadMUS: cptr[char] -> ptr[Mix_Music];
  fun Mix_LoadWAV_RW: ptr[SDL_RWops] * int -> ptr[Mix_Chunk];
  fun Mix_OpenAudio: int * uint16 * int * int -> int;
  fun Mix_Paused: int -> int;
  fun Mix_PausedMusic: 1 -> int;
  fun Mix_PlayChannelTimed: int * ptr[Mix_Chunk] * int * int -> int;
  fun Mix_PlayMusic: ptr[Mix_Music] * int -> int;
  fun Mix_Playing: int -> int;
  fun Mix_PlayingMusic: 1 -> int;
  fun Mix_QuerySpec: ptr[int] * ptr[uint16] * ptr[int] -> int;
  fun Mix_QuickLoad_RAW: ptr[uint8] * uint32 -> ptr[Mix_Chunk];
  fun Mix_QuickLoad_WAV: ptr[uint8] -> ptr[Mix_Chunk];
  fun Mix_RegisterEffect: int * SDL_mixer_h_cft_1 * SDL_mixer_h_cft_2 * address -> int;
  fun Mix_ReserveChannels: int -> int;
  fun Mix_SetDistance: int * uint8 -> int;
  fun Mix_SetMusicCMD: cptr[char] -> int;
  fun Mix_SetMusicPosition: double -> int;
  fun Mix_SetPanning: int * uint8 * uint8 -> int;
  fun Mix_SetPosition: int * int16 * uint8 -> int;
  fun Mix_SetReverseStereo: int * int -> int;
  fun Mix_SetSynchroValue: int -> int;
  fun Mix_UnregisterAllEffects: int -> int;
  fun Mix_UnregisterEffect: int * SDL_mixer_h_cft_1 -> int;
  fun Mix_Volume: int * int -> int;
  fun Mix_VolumeChunk: ptr[Mix_Chunk] * int -> int;
  fun Mix_VolumeMusic: int -> int;

  //CALLBACK TYPE WRAPPERS
  //callback type SDL_mixer_h_cft_2, client data at 1
  typedef _fcbat_SDL_mixer_h_cft_2 = int;
  export type (_fcbat_SDL_mixer_h_cft_2) as "_fcbat_SDL_mixer_h_cft_2";
  typedef _fcbt_SDL_mixer_h_cft_2 = int -> void;
  export type (_fcbt_SDL_mixer_h_cft_2) as "_fcbt_SDL_mixer_h_cft_2";
  header '''void _fcbw_SDL_mixer_h_cft_2(int a1, void *a2);''';

  const _fcbw_SDL_mixer_h_cft_2: SDL_mixer_h_cft_2 = "_fcbw_SDL_mixer_h_cft_2";
  body '''
  void _fcbw_SDL_mixer_h_cft_2(int a1, void *a2){
    con_t *p  = ((_fcbt_SDL_mixer_h_cft_2)a2)->call(0, a1);
    while(p) p=p->resume();
  }''';

  //callback type SDL_mixer_h_cft_3, client data at 0
  typedef _fcbat_SDL_mixer_h_cft_3 = ptr[uint8] * int;
  export type (_fcbat_SDL_mixer_h_cft_3) as "_fcbat_SDL_mixer_h_cft_3";
  typedef _fcbt_SDL_mixer_h_cft_3 = ptr[uint8] * int -> void;
  export type (_fcbt_SDL_mixer_h_cft_3) as "_fcbt_SDL_mixer_h_cft_3";
  header '''void _fcbw_SDL_mixer_h_cft_3(void *a1, Uint8 *a2, int a3);''';

  const _fcbw_SDL_mixer_h_cft_3: SDL_mixer_h_cft_3 = "_fcbw_SDL_mixer_h_cft_3";
  body '''
  void _fcbw_SDL_mixer_h_cft_3(void *a1, Uint8 *a2, int a3){
    con_t *p  = ((_fcbt_SDL_mixer_h_cft_3)a1)->call(0, _fcbat_SDL_mixer_h_cft_3(a2, a3));
    while(p) p=p->resume();
  }''';


  //CALLBACK CLIENT WRAPPERS
  //callback client Mix_HookMusic, client data at 0, callback at 1
  proc wrapper_Mix_HookMusic(a1: _fcbt_SDL_mixer_h_cft_3) {
    Mix_HookMusic(_fcbw_SDL_mixer_h_cft_3, C_hack::cast[address]a1);
  }
  //callback client Mix_RegisterEffect, client data at 2, callback at 3
  fun wrapper_Mix_RegisterEffect(a1: int, a2: SDL_mixer_h_cft_1, a3: _fcbt_SDL_mixer_h_cft_2): int= {
    return Mix_RegisterEffect(a1, a2, _fcbw_SDL_mixer_h_cft_2, C_hack::cast[address]a3);
  }
  //callback client Mix_SetPostMix, client data at 0, callback at 1
  proc wrapper_Mix_SetPostMix(a1: _fcbt_SDL_mixer_h_cft_3) {
    Mix_SetPostMix(_fcbw_SDL_mixer_h_cft_3, C_hack::cast[address]a1);
  }
}
@doc()

@select(tangler('lib/SDL/SDL_sound.flx'))
//Module        : SDL_sound_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_sound.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SOUND_VERSION(x) \
//#define SOUND_VER_PATCH 1
//#define SOUND_VER_MINOR 0
//#define SOUND_VER_MAJOR 1
//#define SNDDECLSPEC
//#define SNDDECLSPEC __declspec(dllexport)
//#define SDLCALL
//#define _INCLUDE_SDL_SOUND_H_

//INCLUDES
include "SDL/SDL_rwops";

module SDL_sound_h
{
  requires package "sdl";
  header '#include "SDL_sound.h"';
  open C_hack;
  open SDL_rwops_h;

  //ABSTRACT TYPES
  type Sound_Sample = 'Sound_Sample';
  type Sound_Version = 'Sound_Version';
  type Sound_AudioInfo = 'Sound_AudioInfo';
  type Sound_SampleFlags = 'Sound_SampleFlags';
  type Sound_DecoderInfo = 'Sound_DecoderInfo';

  //ENUMERATION CONSTANTS
  const SOUND_SAMPLEFLAG_ERROR: int = 'SOUND_SAMPLEFLAG_ERROR';
  const SOUND_SAMPLEFLAG_NONE: int = 'SOUND_SAMPLEFLAG_NONE';
  const SOUND_SAMPLEFLAG_EAGAIN: int = 'SOUND_SAMPLEFLAG_EAGAIN';
  const SOUND_SAMPLEFLAG_EOF: int = 'SOUND_SAMPLEFLAG_EOF';
  const SOUND_SAMPLEFLAG_CANSEEK: int = 'SOUND_SAMPLEFLAG_CANSEEK';

  //PROCEDURES
  proc Sound_ClearError: 1;
  proc Sound_FreeSample: ptr[Sound_Sample];
  proc Sound_GetLinkedVersion: ptr[Sound_Version];

  //FUNCTIONS
  fun Sound_AvailableDecoders: 1 -> ptr[cptr[Sound_DecoderInfo]];
  fun Sound_Decode: ptr[Sound_Sample] -> uint32;
  fun Sound_DecodeAll: ptr[Sound_Sample] -> uint32;
  fun Sound_GetError: 1 -> cptr[char];
  fun Sound_Init: 1 -> int;
  fun Sound_NewSample: ptr[SDL_RWops] * cptr[char] * ptr[Sound_AudioInfo] * uint32 -> ptr[Sound_Sample];
  fun Sound_NewSampleFromFile: cptr[char] * ptr[Sound_AudioInfo] * uint32 -> ptr[Sound_Sample];
  fun Sound_Quit: 1 -> int;
  fun Sound_Rewind: ptr[Sound_Sample] -> int;
  fun Sound_Seek: ptr[Sound_Sample] * uint32 -> int;
  fun Sound_SetBufferSize: ptr[Sound_Sample] * uint32 -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_rotozoom.flx'))
//Module        : SDL_rotozoom_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_rotozoom.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define SMOOTHING_ON          1
//#define SMOOTHING_OFF         0
//#define M_PI  3.141592654
//#define _SDL_rotozoom_h

//INCLUDES
include "SDL/SDL";
include "SDL/SDL_video";

module SDL_rotozoom_h
{
  requires package "sdl";
  header '#include "SDL_rotozoom.h"';
  open C_hack;
  open SDL_h;
  open SDL_video_h;
  open math_h;

  //CSTRUCTS
  cstruct tColorRGBA {
    r: uint8;
    g: uint8;
    b: uint8;
    a: uint8;
  }
  cstruct tColorY {
    y: uint8;
  }

  //STRUCT or UNION TAG ALIASES

  //TYPE ALIASES
  typedef _struct_tColorY = tColorY;
  typedef _struct_tColorRGBA = tColorRGBA;

  //PROCEDURES
  proc rotozoomSurfaceSize: int * int * double * double * ptr[int] * ptr[int];
  proc zoomSurfaceSize: int * int * double * double * ptr[int] * ptr[int];

  //FUNCTIONS
  fun rotozoomSurface: ptr[SDL_Surface] * double * double * int -> ptr[SDL_Surface];
  fun zoomSurface: ptr[SDL_Surface] * double * double * int -> ptr[SDL_Surface];
}
@doc()

@select(tangler('lib/SDL/SDL_ttf.flx'))
//Module        : SDL_ttf_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_ttf.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define TTF_GetError  SDL_GetError
//#define TTF_SetError  SDL_SetError
//#define TTF_RenderUNICODE(font, text, fg, bg) \
//#define TTF_RenderUTF8(font, text, fg, bg)    \
//#define TTF_RenderText(font, text, fg, bg)    \
//#define TTF_STYLE_UNDERLINE   0x04
//#define TTF_STYLE_ITALIC      0x02
//#define TTF_STYLE_BOLD                0x01
//#define TTF_STYLE_NORMAL      0x00
//#define UNICODE_BOM_SWAPPED   0xFFFE
//#define UNICODE_BOM_NATIVE    0xFEFF
//#define TTF_VERSION(X)                                                        \
//#define TTF_PATCHLEVEL                6
//#define TTF_MINOR_VERSION     0
//#define TTF_MAJOR_VERSION     2
//#define _SDLttf_h

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";
include "SDL/SDL_video";

module SDL_ttf_h
{
  requires package "sdl";
  header '#include "SDL_ttf.h"';
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  open SDL_video_h;

  //PURE INCOMPLETE TYPES
  type _struct__TTF_Font = 'struct _TTF_Font'; //local

  //STRUCT or UNION TAG ALIASES
  typedef TTF_Font = _struct__TTF_Font;

  //PROCEDURES
  proc TTF_ByteSwappedUNICODE: int;
  proc TTF_CloseFont: ptr[TTF_Font];
  proc TTF_Quit: 1;
  proc TTF_SetFontStyle: ptr[TTF_Font] * int;

  //FUNCTIONS
  fun TTF_FontAscent: ptr[TTF_Font] -> int;
  fun TTF_FontDescent: ptr[TTF_Font] -> int;
  fun TTF_FontFaceFamilyName: ptr[TTF_Font] -> ptr[char];
  fun TTF_FontFaceIsFixedWidth: ptr[TTF_Font] -> int;
  fun TTF_FontFaceStyleName: ptr[TTF_Font] -> ptr[char];
  fun TTF_FontFaces: ptr[TTF_Font] -> long;
  fun TTF_FontHeight: ptr[TTF_Font] -> int;
  fun TTF_FontLineSkip: ptr[TTF_Font] -> int;
  fun TTF_GetFontStyle: ptr[TTF_Font] -> int;
  fun TTF_GlyphMetrics: ptr[TTF_Font] * uint16 * ptr[int] * ptr[int] * ptr[int] * ptr[int] * ptr[int] -> int;
  fun TTF_Init: 1 -> int;
  fun TTF_Linked_Version: 1 -> cptr[SDL_version];
  fun TTF_OpenFont: cptr[char] * int -> ptr[TTF_Font];
  fun TTF_OpenFontIndex: cptr[char] * int * long -> ptr[TTF_Font];
  fun TTF_OpenFontIndexRW: ptr[SDL_RWops] * int * int * long -> ptr[TTF_Font];
  fun TTF_OpenFontRW: ptr[SDL_RWops] * int * int -> ptr[TTF_Font];
  fun TTF_RenderGlyph_Blended: ptr[TTF_Font] * uint16 * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderGlyph_Shaded: ptr[TTF_Font] * uint16 * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderGlyph_Solid: ptr[TTF_Font] * uint16 * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Blended: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Shaded: ptr[TTF_Font] * cptr[char] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Solid: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Blended: ptr[TTF_Font] * cptr[uint16] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Shaded: ptr[TTF_Font] * cptr[uint16] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Solid: ptr[TTF_Font] * cptr[uint16] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Blended: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Shaded: ptr[TTF_Font] * cptr[char] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Solid: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_SizeText: ptr[TTF_Font] * cptr[char] * ptr[int] * ptr[int] -> int;
  fun TTF_SizeUNICODE: ptr[TTF_Font] * cptr[uint16] * ptr[int] * ptr[int] -> int;
  fun TTF_SizeUTF8: ptr[TTF_Font] * cptr[char] * ptr[int] * ptr[int] -> int;
  fun TTF_WasInit: 1 -> int;
}
@doc()

@select(tangler('lib/SDL/SDL_net.flx'))
//Module        : SDL_net_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_net.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1

//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDL_DATA_ALIGNED      0
//#define SDL_DATA_ALIGNED      1
//#define SDLNet_GetError       SDL_GetError
//#define SDLNet_SetError       SDL_SetError
//#define SDLNet_SocketReady(sock) \
//#define SDLNet_UDP_DelSocket(set, sock) \
//#define SDLNet_TCP_DelSocket(set, sock) \
//#define SDLNet_UDP_AddSocket(set, sock) \
//#define SDLNet_TCP_AddSocket(set, sock) \
//#define SDLNET_MAX_UDPADDRESSES       4
//#define SDLNET_MAX_UDPCHANNELS        32
//#define INADDR_BROADCAST      0xFFFFFFFF
//#define INADDR_NONE           0xFFFFFFFF
//#define INADDR_ANY            0x00000000
//#define _SDLnet_h

module SDL_net_h
{
  requires package "sdl";
  header '#include "SDL_net.h"';
  open C_hack;

  //ABSTRACT TYPES
  type SDLNet_GenericSocket = 'SDLNet_GenericSocket';
  type IPaddress = 'IPaddress';
  type UDPpacket = 'UDPpacket';

  //PURE INCOMPLETE TYPES
  type _struct__UDPsocket = 'struct _UDPsocket'; //local
  type _struct__SDLNet_SocketSet = 'struct _SDLNet_SocketSet'; //local
  type _struct__TCPsocket = 'struct _TCPsocket'; //local

  //TYPE ALIASES
  typedef UDPsocket = ptr[_struct__UDPsocket];
  typedef TCPsocket = ptr[_struct__TCPsocket];
  typedef SDLNet_SocketSet = ptr[_struct__SDLNet_SocketSet];

  //PROCEDURES
  proc SDLNet_FreePacket: ptr[UDPpacket];
  proc SDLNet_FreePacketV: ptr[ptr[UDPpacket]];
  proc SDLNet_FreeSocketSet: SDLNet_SocketSet;
  proc SDLNet_Quit: 1;
  proc SDLNet_TCP_Close: TCPsocket;
  proc SDLNet_UDP_Close: UDPsocket;
  proc SDLNet_UDP_Unbind: UDPsocket * int;
  proc SDLNet_Write16: uint16 * address;
  proc SDLNet_Write32: uint32 * address;

  //FUNCTIONS
  fun SDLNet_AddSocket: SDLNet_SocketSet * SDLNet_GenericSocket -> int;
  fun SDLNet_AllocPacket: int -> ptr[UDPpacket];
  fun SDLNet_AllocPacketV: int * int -> ptr[ptr[UDPpacket]];
  fun SDLNet_AllocSocketSet: int -> SDLNet_SocketSet;
  fun SDLNet_CheckSockets: SDLNet_SocketSet * uint32 -> int;
  fun SDLNet_DelSocket: SDLNet_SocketSet * SDLNet_GenericSocket -> int;
  fun SDLNet_Init: 1 -> int;
  fun SDLNet_Read16: address -> uint16;
  fun SDLNet_Read32: address -> uint32;
  fun SDLNet_ResizePacket: ptr[UDPpacket] * int -> int;
  fun SDLNet_ResolveHost: ptr[IPaddress] * cptr[char] * uint16 -> int;
  fun SDLNet_ResolveIP: ptr[IPaddress] -> cptr[char];
  fun SDLNet_TCP_Accept: TCPsocket -> TCPsocket;
  fun SDLNet_TCP_GetPeerAddress: TCPsocket -> ptr[IPaddress];
  fun SDLNet_TCP_Open: ptr[IPaddress] -> TCPsocket;
  fun SDLNet_TCP_Recv: TCPsocket * address * int -> int;
  fun SDLNet_TCP_Send: TCPsocket * address * int -> int;
  fun SDLNet_UDP_Bind: UDPsocket * int * ptr[IPaddress] -> int;
  fun SDLNet_UDP_GetPeerAddress: UDPsocket * int -> ptr[IPaddress];
  fun SDLNet_UDP_Open: uint16 -> UDPsocket;
  fun SDLNet_UDP_Recv: UDPsocket * ptr[UDPpacket] -> int;
  fun SDLNet_UDP_RecvV: UDPsocket * ptr[ptr[UDPpacket]] -> int;
  fun SDLNet_UDP_Send: UDPsocket * int * ptr[UDPpacket] -> int;
  fun SDLNet_UDP_SendV: UDPsocket * ptr[ptr[UDPpacket]] * int -> int;
}
@doc()

@select(tangler("rtl/flx_sdl_config.hpp"))
#ifndef __FLX_SDL_CONFIG_GUARD__
#define __FLX_SDL_CONFIG_GUARD__
#include "flx_rtl_config.hpp"
#ifdef BUILD_SDL
#define SDL_EXTERN FLX_EXPORT
#else
#define SDL_EXTERN FLX_IMPORT
#endif
#endif
@doc()

@select(tangler('lib/flx_faio_sdl.flx'))
include "SDL/SDL";
include "SDL/SDL_events";
include "SDL/SDL_mutex";
include "flx_faio";

module SDL_events
{
  requires package "sdl";
  open SDL_events_h;
  open SDL_mutex_h;
  open C_hack;

  fun event_type: SDL_Event -> uint8 = "$1.type";

  proc block_sdl_events(m:ptr[SDL_mutex])
  {
    var dummy = SDL_UserEvent(SDL_USEREVENT,0,NULL,NULL);
    ignore(SDL_PushEvent(cast [ptr[SDL_Event]] (addr dummy)));
    ignore(SDL_LockMutex(m));
  }

  proc unblock_sdl_events(m:ptr[SDL_mutex])
  {
    ignore(SDL_UnlockMutex(m));
  }
}
@doc()
