@head(1,'Garbage collector')

@p()
The Felix garbage collector consists of two components: the collector
abstraction, and a concrete collector.
@p()
The abstraction consists of an abstract class collector_t,
which models the collector,
an abstract class allocator_t, which models an allocator,
and two concrete classes:
shape_t, which defines a type shape descriptor, and frame_t,
which describes an allocated memory block, called a frame.
@p()
The frame_t data is stored at the beginning of every block
the collector manages, this is called the header part. 
The rest of the block is for client data, and is called the client part.
The collector manages frames in terms of pointers to the whole block,
which are also pointers to the header. The client only sees a pointer
to the client part.
@p()
The header contains links to other frames, so the collector can navigate 
the set of blocks, and a pointer to a shape object, 
which describes where in the client part pointers reside, so that the
collector can chase down all the reachable blocks.
@p()
The collector mechanism provides resources for a simple
mark and sweep collector, reference counting, and manual
deletion. It also provides for user written finalisers,
in particular C++ class destructors.
@p()
Note that the collector is a 'world stop' synchronous collector.
Collection only occurs when you call the collect() method of the
collector object.
@p()
Note the Felix allocator abstraction is not compatible with 
the C++ allocator concept; instead, it is a simple wrapper
around the malloc/free interface. It is provided primarily
to allow instrumentation of allocations, although it is possible
to supply a user written allocator.

@execfile('config'+os.sep+'flx_data.py')
@h = tangler('spkgs/flx_gc.py')
@select(h)
cpp_cpps = ['rtl/flx_gc','rtl/flx_collector']
provides_lib = "libflx_gc"
pkg_requires = ['flx_judy']
lib_requires = ['flx_judy']
iscr_source = ['lpsrc/flx_gc.pak']
build_macro = "FLX_GC"
weaver_directory = 'doc/rtl/flx_gc/'

@h = tangler('config/flx_gc.fpc')
@select(h)
Name: flx_gc
Description: Felix default garbage collector
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_gc_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_gc_static")
 else:
   tangle("provides_dlib: -lflx_gc_dynamic")
   tangle("provides_slib: -lflx_gc_static")

Requires: flx_judy

@h=tangler('rtl/flx_gc_config.hpp')
@select(h)
#ifndef __FLX_GC_CONFIG_H__
#define __FLX_GC_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FLX_GC
#define GC_EXTERN FLX_EXPORT
#else
#define GC_EXTERN FLX_IMPORT
#endif
#endif

@h = tangler('rtl/flx_gc.hpp')
@select(h)
#ifndef __FLX_GC_H__
#define __FLX_GC_H__

#include <cstdlib>
#include "flx_gc_config.hpp"

// we use an STL set to hold the collection of roots
#include <set>

namespace flx {
namespace gc {
namespace generic {
// Here are the types we refer to:

struct GC_EXTERN frame_t;      // the type of all collectable objects
struct GC_EXTERN gc_shape_t;   // the shape of collectable objects
struct GC_EXTERN collector_t;  // the collector itself
struct GC_EXTERN allocator_t;  // the collector itself

enum gc_shape_flags_t {
  gc_flags_default    = 0,            //< collectable and mobile
  gc_flags_immobile   = 1,            //< cannot be moved
  gc_flags_persistent = 2             //< cannot be deallocated
};

/// Describes runtime object shape.
struct GC_EXTERN gc_shape_t
{
  gc_shape_t *next_shape;         ///< pointer to next shape in list or NULL
  char const *cname;              ///< C++ typename
  std::size_t count;              ///< array element count
  std::size_t amt;                ///< bytes allocated
  void (*finaliser)(collector_t*, void*);  ///< finalisation function
  std::size_t n_offsets;          ///< number of offsets
  std::size_t *offsets;           ///< actual offsets
  gc_shape_flags_t flags;         ///< flags
#if 0
  // convenience constructor
  gc_shape_t(
    gc_shape_t *ns,
    char const *cn,
    std::size_t count_a,
    std::size_t amt_a,
    void (*finaliser_a)(collector_t*, void*),
    std::size_t n_offsets_a,
    std::size_t *offsets_a
  );
  gc_shape_t(
    gc_shape_t *ns,
    char const *cn,
    std::size_t count_a,
    std::size_t amt_a,
    void (*finaliser_a)(collector_t*, void*),
    std::size_t n_offsets_a,
    std::size_t *offsets_a,
    gc_shape_flags_t flags_a
  );
#endif
};
@doc()
The following template is provided as a standard wrapper
for C++ class destructors. The term
@begin_displayed_code()
  std_finaliser<T>
@end_displayed_code()
denotes a function pointer to the wrapper for the destructor
of class T, which can be used as a finaliser in the shape
descriptor of a T. The client is cautioned than the order
of finalisation may not be what is expected. Finalisers
should be provided for all C++ objects managed by the Felix
collector and not refering to Felix objects, 
but which contain pointers to other objects that need 
to be deleted when the main object is destroyed;
for example a string class managing an array of char
requires its destructor be invoked to delete the managed
array, and so a finaliser wrapping the destructor must
be provided.
@p()
C data types may, of course, also require destruction,
and Felix therefore can provide programmers with
the convenience of C++ destructors, even for C data types.

@select(h)
template<class T>
void std_finaliser(collector_t*, void *t)
{
  static_cast<T*>(t) -> ~T();
}

@doc()
Here is the allocator abstraction.
@select(h)

/// Allocator abstraction.

struct allocator_t {
  bool debug;
  allocator_t():debug(false){}
  virtual void *allocate(std::size_t)=0;
  virtual void deallocate(void *)=0;
  virtual void *reallocate(void *, std::size_t)=0;
  virtual ~allocator_t(){};
  void set_debug(bool d){debug=d;}
};

@doc()
And here is the collector abstraction.
@select(h)

/// Collector abstraction.
struct GC_EXTERN collector_t
{
  bool debug;
  void set_debug(bool d){debug=d;}
  collector_t();
  virtual ~collector_t(){}

@doc()
These routines just provide statistics.
@select(h)
  unsigned long get_allocation_count()const {
    return v_get_allocation_count(); 
  }

  unsigned long get_root_count()const { 
    return v_get_root_count(); 
  }

  unsigned long get_allocation_amt()const { 
    return v_get_allocation_amt(); 
  }

@doc()
Hooks for the supplied allocator, which operate in
terms of shape objects rather than raw memory amounts.
@select(h)
  void *allocate(gc_shape_t *shape, unsigned long x) {
    return v_allocate(shape,x);
  }

  void deallocate(frame_t *fp) {
    v_deallocate(fp);
  }

@doc()
The mark and sweep collector algorithm.
@select(h)
  unsigned long collect() { 
    return v_collect(); 
  }

@doc()
Routines to add and remove roots.
@select(h)
  void add_root(void *memory) {
    v_add_root(memory);
  }

  void remove_root(void *memory) {
    v_remove_root(memory);
  }

@doc()
Integrity check for the data structure being managed.
@select(h)
  void check() {
    v_check();
  }

private:
  virtual unsigned long v_get_allocation_count()const=0;
  virtual unsigned long v_get_root_count()const=0;
  virtual unsigned long v_get_allocation_amt()const=0;
  virtual void *v_allocate(gc_shape_t *shape, unsigned long)=0;
  virtual void v_deallocate(frame_t *fp)=0;
  virtual unsigned long v_collect()=0;
  virtual void v_add_root(void *memory)=0;
  virtual void v_remove_root(void *memory)=0;
  virtual void v_check()=0;

@doc()
It doesn't make any sense to copy collector objects
about.
@select(h)
  void operator=(collector_t const&);
  collector_t(collector_t const&);
};


@doc()
The destroy function unconditionally deletes an object,
so it must only be used when there are no managed pointers
to the object. Other pointers might exist, and that is normally
OK provided they're not dereferenced.

@select(h)
void GC_EXTERN destroy(void *b);

@doc()
The following routines are provided to help
safely manage pointers. The can be used
to initialise, assign and destroy, and delete 
pointer variables, where delete implies
both NULLing out the variable and also deleting
the object pointed to. 
@p()
Each untyped routine has a corresponding
template to provide a type safe interface.

@select(h)
void GC_EXTERN _init_ptr(void **a, void *b);
void GC_EXTERN _set_ptr(void **a, void *b);
void GC_EXTERN _release_ptr(void **a);
void GC_EXTERN _destroy_ptr(void **a);

template<class T>
void init_ptr(T **a, T *b)
{
  _init_ptr
  (
    reinterpret_cast<void**>(a),
    reinterpret_cast<void*>(b)
  );
}

template<class T>
void set_ptr(T **a, T *b)
{
  _set_ptr
  (
    reinterpret_cast<void**>(a),
    reinterpret_cast<void*>(b)
  );
}

template<class T>
void release_ptr(T **a)
{
  _release_ptr
  (
    reinterpret_cast<void**>(a)
  );
}

template<class T>
void destroy_ptr(T **a)
{
  _destroy_ptr
  (
    reinterpret_cast<void**>(a)
  );
}

@doc()
These two routines are used to reset the type
of object an memory block hold, and reset the
length of an array, respectively.

@select(h)
GC_EXTERN void set_used(void *memory, unsigned long); 
GC_EXTERN void incr_used(void *memory, unsigned long); 
GC_EXTERN unsigned long get_used(void *memory); 
GC_EXTERN unsigned long get_count(void *memory); 
GC_EXTERN void *create_empty_array(
  collector_t &collector,
  gc_shape_t &shape,
  unsigned long count
);

}}} // end namespaces

@doc()
The following two routines are used to provide
C++ type safe heap allocation. There are no corresponding
delete routines, please use the destroy function.
@p()
Note these routines are now placed
in the global namespace to accomodate Metrowerks
compiler on Mac OS. 

@select(h)
/// Allocate collectable object
GC_EXTERN void *operator new
(
  std::size_t, 
  flx::gc::generic::collector_t &, 
  flx::gc::generic::gc_shape_t &
);
#endif

@h=tangler('rtl/flx_gc_private.hpp')
@select(h)
// THIS IS A HACK .. required by generic pointer
// manipulators -- but really should be private to the Felix
// default collector implementation

namespace flx {
namespace gc {
namespace generic { // SHOULD BE NAMESPACE collector

/// Heap Frame header
struct frame_t
{
  gc_shape_t *shape;       // the shape of each object
  unsigned long n_objects; // how many slots max 
  unsigned long n_used;    // how many slots used 
#ifndef JUDYGC  
  frame_t *next;          // the next and previous objects
  frame_t *prev;          // in the collectors list
#endif
  collector_t *collector; // the managing collector
  bool garbage;           // the garbage flag
  bool finalised;         // whether the object is finalised
};

}}} // end namespaces

// ----------------------------------------------------

#define _ROUNDUP(i,n) ((i + n - 1) / n * n)
#define _ALIGN(i) _ROUNDUP(i,FLX_MAX_ALIGN)

#define FRAMESIZE int(_ALIGN(sizeof(flx::gc::generic::frame_t)))
#define FRAME_TO_CLIENT(p) \
  ((void*)((unsigned char*)(void*)p + FRAMESIZE))
#define CLIENT_TO_FRAME(p) \
  ((frame_t*)(void*)((unsigned char*)p - FRAMESIZE))


@h=tangler('rtl/flx_gc.cpp')
@select(h)

#include "flx_gc.hpp"
#include <cstdio>
#include <cassert>
#include "flx_gc_private.hpp"

namespace flx {
namespace gc {
namespace generic {

#if 0
// create a shape object given an array of offsets
gc_shape_t::gc_shape_t
(
  gc_shape_t *ns,
  char const *cn,
  std::size_t count_a,
  std::size_t amt_a,
  void (*finaliser_a)(collector_t*, void*),
  std::size_t n_offsets_a,
  std::size_t *offsets_a,
  gc_shape_flags_t flags_a
)
  :
  next_shape(ns),
  cname(cn),
  count(count_a),
  amt(amt_a),
  finaliser(finaliser_a),
  n_offsets(n_offsets_a),
  offsets(offsets_a),
  flags(flags_a)
{}

// with flags defaulted
gc_shape_t::gc_shape_t
(
  gc_shape_t *ns,
  char const *cn,
  std::size_t count_a,
  std::size_t amt_a,
  void (*finaliser_a)(collector_t*, void*),
  std::size_t n_offsets_a,
  std::size_t *offsets_a
)
  :
  next_shape(ns),
  cname(cn),
  count(count_a),
  amt(amt_a),
  finaliser(finaliser_a),
  n_offsets(n_offsets_a),
  offsets(offsets_a),
  flags(gc_flags_default)
{}
#endif

void destroy(void *p)
{
  if(p)
  {
    frame_t *fp = CLIENT_TO_FRAME(p);
    if(!fp->finalised)
      fp->collector->deallocate(fp);
   }
}

// b may be 0
void _init_ptr(void **a, void *b)
{
  *a = b;
}

// *a or b may be 0
void _set_ptr(void **a, void *b)
{
  *a = b;
}

// *a may be 0
void _release_ptr(void **a)
{
  *a = 0;
}

void _destroy_ptr(void **a)
{
  void *b = *a; // save the pointer value
  *a=0;         // null out the variable
  destroy(b);
}

/*
void reset_shape(void *memory, gc_shape_t &shape)
{
  assert(memory);
  CLIENT_TO_FRAME(memory)->shape = &shape;
}
*/

void set_used(void *memory, unsigned long n)
{
  assert(memory);
  assert(n>=0);
  assert(n<=get_count(memory));
  CLIENT_TO_FRAME(memory)->n_used = n;
}

void incr_used(void *memory, unsigned long n)
{
  set_used(memory, get_used(memory)+n);
}

unsigned long get_used(void *memory)
{
  assert(memory);
  return CLIENT_TO_FRAME(memory)->n_used;
}

unsigned long get_count(void *memory)
{
  assert(memory);
  return CLIENT_TO_FRAME(memory)->n_objects;
}

collector_t::collector_t() : debug(false) {}

void *create_empty_array(
  flx::gc::generic::collector_t &collector,
  flx::gc::generic::gc_shape_t &shape,
  unsigned long count
)
{
  void *p = collector.allocate(&shape,count);
  set_used (p, 0);
  return p;
}

}}} // end namespaces

// in global namespace now ..
void *operator new(
  std::size_t amt,
  flx::gc::generic::collector_t &collector,
  flx::gc::generic::gc_shape_t &shape
)
{
  if (amt != shape.amt)
  {
    fprintf(stderr,"Shape size error: allocator size = %ld\n",amt);
    fprintf(stderr,"Shape %s size = %ld\n",shape.cname,shape.amt);
    abort();
  }
  void *p = collector.allocate(&shape,1);
  flx::gc::generic::set_used (p, 1);
  return p;
}

@select(tangler('rtl/flx_collector.hpp'))
#ifndef __FLX_COLLECTOR_H__
#define __FLX_COLLECTOR_H__
#include "flx_gc.hpp"
#include "flx_gc_private.hpp"
#include <map>

#ifdef JUDYGC
#include <Judy.h>
#endif

namespace flx {
namespace gc {
namespace collector {
using namespace generic;

struct GC_EXTERN malloc_free;
struct GC_EXTERN flx_collector_t;

/// Allocator using malloc and free.
struct GC_EXTERN malloc_free : public virtual allocator_t 
{
  void *allocate(std::size_t);
  void *reallocate(void *, std::size_t);
  void deallocate(void *);
};


/// Naive Mark and Sweep Collector.
struct GC_EXTERN flx_collector_t : public collector_t
{
  flx_collector_t(allocator_t *);
  ~flx_collector_t();

  // special to this collector ..?
  bool check_client_pointer(void *);
  bool check_frame_pointer(frame_t *);

  // RF: added to allow implementation of non-leaky drivers.
  void free_all_mem(); // clear all roots, sweep.

protected:

  /// allocator
  void *impl_allocate(gc_shape_t *ptr_map, unsigned long);
  void impl_deallocate(frame_t *frame);

  /// collector (returns number of objects collected)
  unsigned long impl_collect();

  // add and remove roots
  void impl_add_root(void *memory);
  void impl_remove_root(void *memory);

  //
  void check();

  // statistics
  unsigned long impl_get_allocation_count()const;
  unsigned long impl_get_root_count()const;
  unsigned long impl_get_allocation_amt()const;

  void impl_check();

private:
  /// allocator
  void *v_allocate(gc_shape_t *ptr_map, unsigned long);
  void v_deallocate(frame_t *frame);

  /// collector (returns number of objects collected)
  unsigned long v_collect();

  // add and remove roots
  void v_add_root(void *memory);
  void v_remove_root(void *memory);

  //
  void v_check();
  // statistics
  unsigned long v_get_allocation_count()const;
  unsigned long v_get_root_count()const;
  unsigned long v_get_allocation_amt()const;

private:
  bool collecting;
  unsigned long allocation_count;
  unsigned long root_count;
  unsigned long allocation_amt;

 
  void unlink(frame_t *frame);
  void dispose(frame_t *frame);
    // calls post_delete or delete_frame

  void post_delete(frame_t *frame);
  void delete_frame(frame_t *frame);
  unsigned long reap();

  void mark();
  unsigned long sweep(); // calls scan_object
  void scan_object(frame_t *frame);

  frame_t *first;
  frame_t *to_delete;
  typedef std::map<frame_t*,unsigned long, std::less<frame_t*> > rootmap_t;
  rootmap_t roots;
  bool parity;
  allocator_t *allocator;

#ifdef JUDYGC  
  // JudyL array and error object
  void *ja;
  void *jb;
  JError_t je;
#endif

};

}}} // end namespaces
#endif

@select(tangler('rtl/flx_collector.cpp'))
#include <cstdlib>
#include <map>
#include <limits.h>
#include <cassert>
#include <cstdio>
#include <cstddef>
#include "flx_rtl_config.hpp"
#include "flx_collector.hpp"
namespace flx {
namespace gc {
namespace collector {

static int mcount FLX_UNUSED = 0;
#if FLX_HAVE_GNU_X86
register void *sp __asm__("esp");
#else
// this was getting us unused variable warnings
// static void *sp = 0;
#endif

void *low_sp = 0;
void *hi_sp = 0;

void *malloc_free::allocate(std::size_t amt)
{
  void *p = malloc(amt);
  if(debug)fprintf(stderr,"Malloc %ld bytes, address = %p\n",amt,p);
  //++mcount;
  //void *x = sp;
  //if (low_sp == NULL) low_sp = x,hi_sp = x;
  //else { 
  //  if (x < low_sp) low_sp = x;
  //  if (x > hi_sp) hi_sp = x;
  //}
  //if(mcount%100==0)printf("malloc %p, count=%d,stack size = %ld\n",p,mcount,(char*)hi_sp - (char*)low_sp);
  if(p)return p;
  else {
    fprintf(stderr,"Felix: Malloc out of memory, blk=%ld\n",long(amt));
    abort();
  }
}


void *malloc_free::reallocate(void *p, size_t amt)
{
  void *q = realloc(p,amt);
  if(q) return p;
  else {
    fprintf(stderr,"Felix: Realloc out of memory, blk=%ld\n",long(amt));
    abort();
  }
}

void malloc_free::deallocate(void *p)
{
  //printf("free %p\n",p);
  if(debug)fprintf(stderr,"Free %p\n",p);
  free(p);
}

void *flx_collector_t::v_allocate(gc_shape_t *ptr_map, unsigned long x) {
  return impl_allocate(ptr_map, x);
}

void flx_collector_t::v_deallocate(frame_t *frame) {
  impl_deallocate(frame);
}

unsigned long flx_collector_t::v_collect() {
  return impl_collect();
}

void flx_collector_t::v_add_root(void *memory) {
  impl_add_root(memory);
}

void flx_collector_t::v_remove_root(void *memory) {
  impl_remove_root(memory);
}

void flx_collector_t::v_check() {
  impl_check();
}

unsigned long flx_collector_t::v_get_allocation_count()const {
  return impl_get_allocation_count();
}

unsigned long flx_collector_t::v_get_root_count()const {
  return impl_get_root_count();
}

unsigned long flx_collector_t::v_get_allocation_amt()const {
  return impl_get_allocation_amt();
}

unsigned long flx_collector_t::impl_get_allocation_count()const
{
  return allocation_count;
}

unsigned long flx_collector_t::impl_get_root_count()const
{
  return root_count;
}

unsigned long flx_collector_t::impl_get_allocation_amt()const
{
  return allocation_amt;
}


flx_collector_t::flx_collector_t(allocator_t *a) :
  collecting(false),
  allocation_count(0),
  root_count(0),
  allocation_amt(0),
  first(0),
  to_delete(0),
  parity(false),
  allocator(a)
#ifdef JUDYGC  
  ,ja(0)
  ,jb(0)
#endif
{}

void * flx_collector_t::impl_allocate(gc_shape_t *shape, unsigned long nobj)
{
  // calculate how much memory to request
  std::size_t amt = nobj * shape->amt * shape->count + FRAMESIZE;

  // allocate a block
  frame_t *fp = (frame_t*)allocator->allocate(amt);
  assert(fp); // Got some memory!

  if(debug)fprintf(stderr,"Allocated %p-0x%x= new %s\n", FRAME_TO_CLIENT(fp),FRAMESIZE,shape->cname);
  // initialise the shape, garbage flag, and refcount
  fp->shape = shape;
  fp->garbage = parity;
  fp->finalised = false;
  fp->n_objects = nobj;
  fp->n_used = 0;
  fp->collector = this;

#ifndef JUDYGC  
  // link the frame into the collectors list
  fp->prev = 0;
  fp->next = first;
  if(first) first->prev = fp;
  first = fp;
#else
  Word_t *p = (Word_t*)(void*)JudyLIns(&ja,(Word_t)(void*)fp,&je);
  *p = amt;
#endif

  // update statistics
  allocation_count++;
  allocation_amt += amt;
  //fprintf(stderr,"ADDING %ld to allocation amt, result %ld\n",long(amt),long(allocation_amt));
  // return client memory pointer
  return FRAME_TO_CLIENT(fp);
}

void flx_collector_t::impl_deallocate(frame_t *fp)
{
  unlink(fp);
  dispose(fp);
}

void flx_collector_t::unlink(frame_t *fp)
{
  // check we have a pointer to an object
  assert(fp);

  // flag the object as finalised, even before
  // actually calling the finaliser, to
  // prevent recursion via destroy
  fp->finalised = true;

  // call the finaliser if there is one
  void (*finaliser)(collector_t*, void*) = fp->shape->finaliser;
  if (finaliser)  
  {
    unsigned char *cp = (unsigned char*)FRAME_TO_CLIENT(fp);
    unsigned long n_used = fp->n_used * fp->shape->count;
    unsigned long eltsize = fp->shape->amt;
    for(unsigned long j = 0; j<n_used; ++j)
    {
      (*finaliser)(this,(void*)cp);
      cp += eltsize;
    }
      
  }
  // unlink the frame from the collectors list
#ifndef JUDYGC
  if(fp->prev)
    fp->prev->next = fp->next;
  else {
    assert(first==fp);
    first=fp->next;
  }
  if(fp->next)
    fp->next->prev = fp->prev;
#else
  JudyLDel(&ja, (Word_t)(void*)fp, &je);
#endif

}

void flx_collector_t::post_delete(frame_t *fp)
{
  assert(collecting);
  // link into list of objects to delete
  // this list uses the prev pointer!
#ifndef JUDYGC  
  fp->prev = to_delete;
  to_delete = fp;
#else
  Judy1Set(&jb,(Word_t)fp,&je);
#endif
}

void flx_collector_t::dispose(frame_t *fp)
{
  if(collecting) post_delete(fp);
  else delete_frame(fp);
}

void flx_collector_t::delete_frame(frame_t *fp)
{
  // update statistics
  allocation_count--;
  gc_shape_t *shape = fp->shape;
  unsigned long nobj = shape -> count * fp -> n_objects;
  std::size_t size = shape->amt * nobj + FRAMESIZE;
  //fprintf(stderr,"Raw frame %p size %ld\n",fp,long(size));
  allocator->deallocate(fp);

  allocation_amt -= size;
  //fprintf(stderr,"Subtracting %ld result is %ld\n",long(size),long(allocation_amt));
  //fprintf(stderr, "delete frame %p: nalloc=%ld, alloc=%ld, size = %ld\n",
  //  fp, allocation_count, allocation_amt,long(size)
  //);
}

unsigned long flx_collector_t::reap ()
{
  unsigned long count = 0;
#ifndef JUDYGC  
  while(to_delete)
  {
    frame_t *next = to_delete-> prev;
    delete_frame(to_delete);
    to_delete = next;
    ++count;
  }
#else
  Word_t next=(Word_t)NULL;
  int res = Judy1First(jb,&next,&je);
  while(res) {
    delete_frame((frame_t*)(void*)next);
    ++count;
    res = Judy1Next(jb,&next,&je);
  }
  Judy1FreeArray(&jb,&je);
#endif
  return count;
}


unsigned long flx_collector_t::sweep()
{
  if(debug)fprintf(stderr,"Collector: Sweep\n");
  collecting=true;
#ifndef JUDYGC  
  frame_t *current = first;
  while(current)
  {
    if(current->garbage == parity)
    {
      if(debug)fprintf(stderr,"Garbage %p=%s\n",current,current->shape->cname);
      unlink(current);
      post_delete(current);
    }
    current = current->next;
  }
#else
  Word_t *pval;
  frame_t *current = (frame_t*)NULL;
  pval = (Word_t*)JudyLFirst(ja,(Word_t*)(void*)&current,&je);
  while(pval)
  {
    if(current->garbage == parity)
    {
      if(debug)fprintf(stderr,"Garbage %p=%s\n",current,current->shape->cname);
      unlink(current);
      post_delete(current);
    }
    pval = (Word_t*)JudyLNext(ja,(Word_t*)(void*)&current,&je);
  }
#endif

  parity = !parity;
  collecting = false;
  return reap();
}

void flx_collector_t::impl_add_root(void *memory)
{
  if(!memory)
  {
    fprintf(stderr, "GC ERROR: ADD NULL ROOT\n");
    abort();
  }
  frame_t *p =  CLIENT_TO_FRAME(memory);
  rootmap_t::iterator iter = roots.find(p);
  if(iter == roots.end())
  {
    std::pair<frame_t *const, unsigned long> entry(p,1UL);
    roots.insert (entry);
    root_count++;
  }
  else
    ++(*iter).second;
}

void flx_collector_t::impl_remove_root(void *memory)
{
  frame_t *p =  CLIENT_TO_FRAME(memory);
  rootmap_t::iterator iter = roots.find(p);
  if(iter == roots.end())
  {
    fprintf(stderr, "GC ERROR: REMOVE ROOT WHICH IS NOT ROOT\n");
    abort();
  }
  if((*iter).second == 1UL)
  {
    roots.erase(iter);
    root_count--;
  }
  else
    --(*iter).second;
}

void flx_collector_t::scan_object(frame_t *frame)
{
  if(debug)fprintf(stderr,"Scanning %p\n",frame);
  if(debug)fprintf(stderr,"Scanning [valid] %p=%s\n",frame,frame->shape->cname);
  if(frame->garbage == parity)
  {
    if(debug){
      fprintf(stderr,"Reachable %p\n",frame);
      gc_shape_t * shape = frame->shape;
      fprintf(stderr,"Reachable [valid] %p=%s\n",frame,shape->cname);
      for(unsigned int i=0; i<shape->n_offsets; ++i)
      {
        unsigned long offset = shape->offsets[i];
        unsigned char *p = (unsigned char*)FRAME_TO_CLIENT(frame);
        void *x = *(void**)(p+offset);
        if(x) {
          bool valid = check_client_pointer(x);
          fprintf(stderr," offset: 0x%04lx %p->[%p-0x%x] %s\n",
            offset,p+offset,x,FRAMESIZE,
            valid?"[valid]":"INVALID"
          );
          if(!valid) abort();
        }
        else
          fprintf(stderr," offset: 0x%04lx %p->[%p] NULL\n",
            offset,p+offset,x);
      }
    }
    frame->garbage = !parity; // reachable!
    gc_shape_t *shape = frame->shape;
    unsigned long n_used = frame->n_used * shape->count;
    std::size_t obj_size = shape->amt;
    std::size_t n_offsets = shape->n_offsets;
    std::size_t *offsets = shape->offsets;
    unsigned char *p = (unsigned char*)FRAME_TO_CLIENT(frame);

    for(unsigned long j=0; j<n_used; ++j)
    {
      for(unsigned int i=0; i<n_offsets; ++i)
      {
        void **q = (void**)(void*)(p + offsets[i]);
#ifndef JUDYGC        
        if(*q)
          scan_object(CLIENT_TO_FRAME(*q));
#else         
        Word_t cand = (Word_t)*q;
        if(cand) 
        {
          Word_t fp=cand;
          Word_t *plen = (Word_t*)JudyLLast(ja,&fp,&je);
          // this is only true for object pointers..
          // not interior pointers -- FOR TESTING ONLY!
          assert(fp == (Word_t)CLIENT_TO_FRAME((void*)cand));
          if(plen && fp<=cand && cand < fp+*plen)
            scan_object((frame_t*)(void*)fp);
        }
#endif          
      }
      p+=obj_size;
    }
  }
}

void flx_collector_t::mark()
{
  if(debug)fprintf(stderr,"Collector: Running mark\n");
  assert (root_count == roots.size());

  rootmap_t::iterator const end = roots.end();
  for(
    rootmap_t::iterator i = roots.begin();
    i != end;
    ++i
  )
    scan_object((*i).first);
}

unsigned long flx_collector_t::impl_collect()
{
  if(debug)fprintf(stderr,"Running collector\n");
  mark();
  unsigned long r = sweep();
  if(debug)impl_check();
  return r;
}

static int vpcompare(void const *a, void const *b) {
  void *aa = *(void**)a;
  void *bb = *(void**)b;
  if (std::less<void*>()(aa,bb)) return -1;
  if (std::equal_to<void*>()(aa,bb)) return 0;
  return 1;
}

// scan all known objects, and check every pointer
// is either NULL or points to one of them

void flx_collector_t::impl_check()
{
  if(debug)fprintf(stderr,"RUNNING HEAP INTEGRITY CHECK\n");
  unsigned long nobj = allocation_count;
  void **ctrl = (void**)malloc(nobj * sizeof(void*));
  unsigned long handled = 0;
  unsigned long allocated = 0;
#ifndef JUDYGC  
  frame_t *lfirst = first;
#else
  frame_t *lfirst = 0;
  JudyLFirst(ja,(Word_t*)(void*)&lfirst, &je);
#endif
  long outofarena=0L;
  while(lfirst) {
    ctrl[handled++]=lfirst;
    gc_shape_t *shape = lfirst->shape;
    unsigned long n_objects = lfirst->n_objects * shape->count;
    unsigned long size = n_objects * shape->amt + FRAMESIZE;
    outofarena++;
    //fprintf(stderr,"Object %p size %ld type %s\n",lfirst,long(size),shape->cname);
    allocated += size;
#ifndef JUDYGC
    lfirst = lfirst->next;
#else
    JudyLNext(ja,(Word_t*)(void*)&lfirst,&je);
#endif    
  }

  if(handled != nobj)
  {
    fprintf(stderr,"Wrong number of objects\n");
    abort();
  }

  if(allocated != allocation_amt)
  {
    fprintf(stderr,"Wrong allocation amount: recorded as %ld, counted as %ld\n",
      allocation_amt, allocated
    );
    fprintf(stderr, "objects = %ld\n", outofarena);
    abort();
  }
  qsort(ctrl,nobj,sizeof(void*),vpcompare);

  for(unsigned int i = 0; i<nobj; ++i) {
    frame_t *frame = (frame_t*) ctrl[i];
    gc_shape_t *shape = frame->shape;
    unsigned long n_used = frame->n_used * shape->count;

    // scan the frame for pointers and adjust them
    unsigned char *client = (unsigned char*)FRAME_TO_CLIENT(frame);
    size_t *offsets = shape -> offsets;
    for(unsigned int nel = 0; nel < n_used; nel++)
    {
      for(unsigned int k = 0; k<shape->n_offsets; ++k) 
      {
        size_t offset = offsets[k];
        void **loc = (void**)(client + offset);
        void *client_ptr = *loc;
        if (client_ptr) // leave NULL alone 
        {
          void *address= CLIENT_TO_FRAME(client_ptr);
          void **res = (void**) bsearch(
            &address,
            ctrl,nobj,
            sizeof(void*),
            vpcompare
          );
          if(!res) {
            fprintf(stderr, 
              "CHECK: In object frame=%p, type %s, subobject #%d,\n"
              "offset #%d->%ld, at address %p,\n"
              "pointer [frame=%p, client=%p] NOT IN GC LIST\n",
              frame, shape->cname,nel,k,offset,loc,address,client_ptr);
            abort();
          }
        }
      }
      client += shape->amt;
    }
  }

  rootmap_t::iterator last = roots.end();
  for(
    rootmap_t::iterator iter = roots.begin();
    iter != last;
    ++iter
  )
  {
    std::pair<frame_t *const, unsigned long> root_record = *iter;
    void **res = (void**) bsearch(
      &root_record.first,
      ctrl,nobj,
      sizeof(void*),
      vpcompare
    );
    if(!res) {
      fprintf(stderr,"CHECK: WOOPS CANNOT FIND ROOT! %p\n",root_record.first);
      abort();
    }
  }
  free(ctrl);
}

bool flx_collector_t::check_frame_pointer(frame_t *p)
{
#ifndef JUDYGC
  frame_t *current = first;
  while(current)
  {
    if(current == p) return true;
    current = current->next;
  }
  return false;
#else
  return NULL != JudyLGet(ja,(Word_t)p,&je);
#endif
}

bool flx_collector_t::check_client_pointer(void *p)
{
  return p?check_frame_pointer (CLIENT_TO_FRAME(p)):true;
}

void flx_collector_t::free_all_mem()
{
  roots.clear();
  root_count = 0;
  sweep();
}

flx_collector_t::~flx_collector_t()
{
  //THIS IS VERY DANGEROUS! What if don't want to collect
  //the garbage for efficiency reasons???
  //
  // ELIDED .. already caused a bug!
  //
  //free_all_mem();
}

}}} // end namespaces

@select(tangler('rtl/flx_ts_collector.hpp'))
#ifndef __FLX_TS_COLLECTOR_H__
#define __FLX_TS_COLLECTOR_H__
#include "flx_collector.hpp"
#include "pthread_mutex.hpp"

namespace flx {
namespace gc {
namespace collector {

/// Naive thread safe Mark and Sweep Collector.
struct PTHREAD_EXTERN flx_ts_collector_t : 
  public flx::gc::collector::flx_collector_t
{
  flx_ts_collector_t(allocator_t *);
  ~flx_ts_collector_t();

private:
  /// allocator
  void *v_allocate(gc_shape_t *ptr_map, unsigned long);
  void v_deallocate(frame_t *frame);

  /// collector (returns number of objects collected)
  unsigned long v_collect();

  // add and remove roots
  void v_add_root(void *memory);
  void v_remove_root(void *memory);

  //
  void v_check();
  // statistics
  unsigned long v_get_allocation_count()const;
  unsigned long v_get_root_count()const;
  unsigned long v_get_allocation_amt()const;

private:
  mutable flx::pthread::flx_mutex_t mut;
};

}}} // end namespaces
#endif

@select(tangler('rtl/flx_ts_collector.cpp'))
#include "flx_rtl_config.hpp"
#include "flx_ts_collector.hpp"

namespace flx {
namespace gc {
namespace collector {

flx_ts_collector_t::flx_ts_collector_t(allocator_t *a) : 
  flx_collector_t(a) 
{}

flx_ts_collector_t::~flx_ts_collector_t(){}

void *flx_ts_collector_t::v_allocate(gc_shape_t *ptr_map, unsigned long x) {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_allocate(ptr_map,x);
}

void flx_ts_collector_t::v_deallocate(frame_t *frame) {
  flx::pthread::flx_mutex_locker_t l(mut);
  impl_deallocate(frame);
}

unsigned long flx_ts_collector_t::v_collect() {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_collect();
}

void flx_ts_collector_t::v_add_root(void *memory) {
  flx::pthread::flx_mutex_locker_t l(mut);
  impl_add_root(memory);
}

void flx_ts_collector_t::v_remove_root(void *memory) {
  flx::pthread::flx_mutex_locker_t l(mut);
  impl_remove_root(memory);
}

void flx_ts_collector_t::v_check() {
  flx::pthread::flx_mutex_locker_t l(mut);
  impl_check();
}

unsigned long flx_ts_collector_t::v_get_allocation_count()const {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_get_allocation_count();
}

unsigned long flx_ts_collector_t::v_get_root_count()const {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_get_root_count();
}

unsigned long flx_ts_collector_t::v_get_allocation_amt()const {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_get_allocation_amt();
}

}}} // end namespaces


