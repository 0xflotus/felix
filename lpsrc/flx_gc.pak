@head(1,'Garbage collector')

@p()
The Felix garbage collector consists of two components: the collector
abstraction, and a concrete collector.
@p()
The abstraction consists of an abstract class collector_t,
which models the collector,
an abstract class allocator_t, which models an allocator,
and two concrete classes:
shape_t, which defines a type shape descriptor, and void *,
which describes an allocated memory block, called a frame.
@p()
The void *data is stored at the beginning of every block
the collector manages, this is called the header part. 
The rest of the block is for client data, and is called the client part.
The collector manages frames in terms of pointers to the whole block,
which are also pointers to the header. The client only sees a pointer
to the client part.
@p()
The header contains links to other frames, so the collector can navigate 
the set of blocks, and a pointer to a shape object, 
which describes where in the client part pointers reside, so that the
collector can chase down all the reachable blocks.
@p()
The collector mechanism provides resources for a simple
mark and sweep collector, reference counting, and manual
deletion. It also provides for user written finalisers,
in particular C++ class destructors.
@p()
Note that the collector is a 'world stop' synchronous collector.
Collection only occurs when you call the collect() method of the
collector object.
@p()
Note the Felix allocator abstraction is not compatible with 
the C++ allocator concept; instead, it is a simple wrapper
around the malloc/free interface. It is provided primarily
to allow instrumentation of allocations, although it is possible
to supply a user written allocator.

@execfile('config'+os.sep+'flx_data.py')
@h = tangler('spkgs/flx_gc.py')
@select(h)
cpp_cpps = ['rtl/flx_gc','rtl/flx_collector']
provides_lib = "libflx_gc"
pkg_requires = ['flx_judy']
lib_requires = ['libflx_judy']
iscr_source = ['lpsrc/flx_gc.pak']
build_macro = "FLX_GC"
weaver_directory = 'doc/rtl/flx_gc/'

@h = tangler('config/flx_gc.fpc')
@select(h)
Name: flx_gc
Description: Felix default garbage collector
Version: $Id$
@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_gc_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_gc_static")
 else:
   tangle("provides_dlib: -lflx_gc_dynamic")
   tangle("provides_slib: -lflx_gc_static")

Requires: flx_judy

@h=tangler('rtl/flx_gc_config.hpp')
@select(h)
#ifndef __FLX_GC_CONFIG_H__
#define __FLX_GC_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FLX_GC
#define GC_EXTERN FLX_EXPORT
#else
#define GC_EXTERN FLX_IMPORT
#endif
#endif

@h = tangler('rtl/flx_gc.hpp')
@select(h)
#ifndef __FLX_GC_H__
#define __FLX_GC_H__

#include <cstdlib>
#include "flx_gc_config.hpp"

// we use an STL set to hold the collection of roots
#include <set>

namespace flx {
namespace gc {
namespace generic {
// Here are the types we refer to:

struct GC_EXTERN gc_shape_t;   // the shape of collectable objects
struct GC_EXTERN collector_t;  // the collector itself
struct GC_EXTERN allocator_t;  // the collector itself

enum gc_shape_flags_t {
  gc_flags_default    = 0,            //< collectable and mobile
  gc_flags_immobile   = 1,            //< cannot be moved
  gc_flags_persistent = 2             //< cannot be deallocated
};

/// Describes runtime object shape.
struct GC_EXTERN gc_shape_t
{
  gc_shape_t *next_shape;         ///< pointer to next shape in list or NULL
  char const *cname;              ///< C++ typename
  std::size_t count;              ///< array element count
  std::size_t amt;                ///< bytes allocated
  void (*finaliser)(collector_t*, void*);  ///< finalisation function
  std::size_t n_offsets;          ///< number of offsets
  std::size_t *offsets;           ///< actual offsets
  gc_shape_flags_t flags;         ///< flags
};
@doc()
The following template is provided as a standard wrapper
for C++ class destructors. The term
@begin_displayed_code()
  std_finaliser<T>
@end_displayed_code()
denotes a function pointer to the wrapper for the destructor
of class T, which can be used as a finaliser in the shape
descriptor of a T. The client is cautioned than the order
of finalisation may not be what is expected. Finalisers
should be provided for all C++ objects managed by the Felix
collector and not refering to Felix objects, 
but which contain pointers to other objects that need 
to be deleted when the main object is destroyed;
for example a string class managing an array of char
requires its destructor be invoked to delete the managed
array, and so a finaliser wrapping the destructor must
be provided.
@p()
C data types may, of course, also require destruction,
and Felix therefore can provide programmers with
the convenience of C++ destructors, even for C data types.

@select(h)
template<class T>
void std_finaliser(collector_t*, void *t)
{
  static_cast<T*>(t) -> ~T();
}

@doc()
Here is the allocator abstraction.
@select(h)

/// Allocator abstraction.

struct allocator_t {
  bool debug;
  allocator_t():debug(false){}
  virtual void *allocate(std::size_t)=0;
  virtual void deallocate(void *)=0;
  virtual void *reallocate(void *, std::size_t)=0;
  virtual ~allocator_t(){};
  void set_debug(bool d){debug=d;}
};

@doc()
And here is the collector abstraction.
@select(h)

/// Collector abstraction.
struct GC_EXTERN collector_t
{
  bool debug;
  void set_debug(bool d){debug=d;}
  collector_t();
  virtual ~collector_t(){}

@doc()
These routines just provide statistics.
@select(h)
  unsigned long get_allocation_count()const {
    return v_get_allocation_count(); 
  }

  unsigned long get_root_count()const { 
    return v_get_root_count(); 
  }

  unsigned long get_allocation_amt()const { 
    return v_get_allocation_amt(); 
  }

@doc()
Hooks for the supplied allocator, which operate in
terms of shape objects rather than raw memory amounts.
@select(h)
  void *allocate(gc_shape_t *shape, unsigned long x) {
    return v_allocate(shape,x);
  }

@doc()
The mark and sweep collector algorithm.
@select(h)
  unsigned long collect() { 
    return v_collect(); 
  }

@doc()
Routines to add and remove roots.
@select(h)
  void add_root(void *memory) {
    v_add_root(memory);
  }

  void remove_root(void *memory) {
    v_remove_root(memory);
  }

  void finalise(void *frame) {
    v_finalise(frame);
  }

@doc()
Integrity check for the data structure being managed.
@select(h)
  //array management
  virtual void set_used(void *memory, unsigned long)=0; 
  virtual void incr_used(void *memory, unsigned long)=0; 
  virtual unsigned long get_used(void *memory)=0; 
  virtual unsigned long get_count(void *memory)=0; 
  virtual void *create_empty_array( gc_shape_t *shape, unsigned long count)=0;
private:
  virtual unsigned long v_get_allocation_count()const=0;
  virtual unsigned long v_get_root_count()const=0;
  virtual unsigned long v_get_allocation_amt()const=0;
  virtual void *v_allocate(gc_shape_t *shape, unsigned long)=0;
  virtual void v_finalise(void *fp)=0;
  virtual unsigned long v_collect()=0;
  virtual void v_add_root(void *memory)=0;
  virtual void v_remove_root(void *memory)=0;

@doc()
It doesn't make any sense to copy collector objects
about.
@select(h)
  void operator=(collector_t const&);
  collector_t(collector_t const&);
};

@doc()
The gc_profile_t is a grab bag of controls related to the collector.

@select(h)

struct GC_EXTERN gc_profile_t {
  bool debug_allocations;     ///< allocator debug on/off
  bool debug_collections;     ///< collector debug on/off
  bool allow_collection_anywhere; ///< enable collect on allocate

  unsigned long gc_freq;      ///< how often to collect
  unsigned long gc_counter;   ///< counter to check if time to collect

  unsigned long min_mem;      ///< min memory before collection
  unsigned long max_mem;      ///< throw out of memory if above here
  unsigned long threshhold;   ///< collection trigger point
  double free_factor;         ///< reset threshhold to used memory 
                              ///< by this factor after collection

  unsigned long collections;  ///< number of collections done
  bool finalise;              ///< whether Felix should collect on exit
  flx::gc::generic::collector_t *collector;

  unsigned long maybe_collect(); ///< function which maybe collects
  unsigned long actually_collect(); ///< function which actually collects

  void *allocate(
    flx::gc::generic::gc_shape_t *shape, 
    unsigned long count, 
    bool allow_gc
  );

  gc_profile_t (
    bool debug_allocations_, 
    bool debug_collections_, 
    bool allow_collection_anywhere_, 
    unsigned long gc_freq_,
    unsigned long min_mem_,
    unsigned long max_mem_,
    double free_factor_,
    bool finalise_,
    flx::gc::generic::collector_t *collector
  );
  ~gc_profile_t();
};


@select(h)

}}} // end namespaces

@doc()
The following two routines are used to provide
C++ type safe heap allocation. There are no corresponding
delete routines, please use the destroy function.
@p()
Note these routines are now placed
in the global namespace to accomodate Metrowerks
compiler on Mac OS. 

@select(h)
/// Allocate collectable object
GC_EXTERN void *operator new
(
  std::size_t, 
  flx::gc::generic::gc_profile_t &, 
  flx::gc::generic::gc_shape_t &,
  bool
);
#endif

@h=tangler('rtl/flx_gc_private.hpp')
@select(h)
// ----------------------------------------------------

#define _ROUNDUP(i,n) ((i + n - 1) / n * n)
#define _ALIGN(i) _ROUNDUP(i,FLX_MAX_ALIGN)

@h=tangler('rtl/flx_gc.cpp')
@select(h)

#include "flx_gc.hpp"
#include "flx_rtl.hpp"
#include <cstdlib>
#include <cstdio>
#include <cassert>
#include "flx_gc_private.hpp"

namespace flx {
namespace gc {
namespace generic {

collector_t::collector_t() : debug(false) {}

gc_profile_t::gc_profile_t (
  bool debug_allocations_, 
  bool debug_collections_, 
  bool allow_collection_anywhere_,
  unsigned long gc_freq_,
  unsigned long min_mem_,
  unsigned long max_mem_,
  double free_factor_,
  bool finalise_,
  flx::gc::generic::collector_t *collector_
) :
  debug_allocations(debug_allocations_),
  debug_collections(debug_collections_),
  allow_collection_anywhere(allow_collection_anywhere_),
  gc_freq(gc_freq_),
  gc_counter(0),
  min_mem(min_mem_),
  max_mem(max_mem_),
  threshhold(min_mem_),
  free_factor(free_factor),
  collections(0),
  finalise(finalise_),
  collector(collector_)
{
}

gc_profile_t::~gc_profile_t() { }

unsigned long gc_profile_t::maybe_collect() {
  ++gc_counter;
  if(debug_collections) fprintf(stderr,"Maybe collect?\n");
  if (gc_counter < gc_freq) return 0;
  if(collector->get_allocation_amt() < threshhold) return 0;
  return actually_collect();
}

unsigned long gc_profile_t::actually_collect() {
  if(debug_collections) fprintf(stderr,"Actually collect\n");
  gc_counter = 0;
  unsigned long collected = collector-> collect();
  unsigned long allocated = collector->get_allocation_amt();
  if (allocated > max_mem) throw flx::rtl::flx_out_of_memory_t();
  threshhold = std::max ( min_mem, 
    (unsigned long) (free_factor * (double)allocated))
  ;
  fprintf(stderr, "actually collected %ld bytes\n",collected);
  return collected;
}

void *gc_profile_t::allocate(
  flx::gc::generic::gc_shape_t *shape, 
  unsigned long amt, 
  bool allow_gc
) 
{
  /* 
  fprintf(stderr,"gc_profile_t::allocate(): allow_collection_anywhere=%s, allow_gc=%s\n",
    (allow_collection_anywhere?"True":"False"), (allow_gc?"True":"false")
  );
  */
  if (allow_collection_anywhere && allow_gc) 
  {
    maybe_collect();
    try {
      return collector -> allocate(shape,amt);
    }
    catch (flx::rtl::flx_out_of_memory_t&) {
      actually_collect();
      return collector -> allocate(shape,amt);
    }
  }
  else
    return collector -> allocate(shape,amt);
}

}}} // end namespaces

// in global namespace now ..
void *operator new(
  std::size_t amt,
  flx::gc::generic::gc_profile_t &gcp,
  flx::gc::generic::gc_shape_t &shape,
  bool allow_gc
)
{
  if (amt != shape.amt)
  {
    fprintf(stderr,"Shape size error: allocator size = %ld\n",amt);
    fprintf(stderr,"Shape %s size = %ld\n",shape.cname,shape.amt);
    abort();
  }
  void *p = gcp.allocate(&shape,1,allow_gc);
  return p;
}

@select(tangler('rtl/flx_collector.hpp'))
#ifndef __FLX_COLLECTOR_H__
#define __FLX_COLLECTOR_H__
#include "flx_gc.hpp"
#include "flx_gc_private.hpp"
#include <map>
#include "pthread_thread.hpp"
#include <Judy.h>

namespace flx {
namespace gc {
namespace collector {
using namespace generic;

struct GC_EXTERN malloc_free;
struct GC_EXTERN flx_collector_t;

/// Allocator using malloc and free.
struct GC_EXTERN malloc_free : public virtual allocator_t 
{
  void *allocate(std::size_t);
  void *reallocate(void *, std::size_t);
  void deallocate(void *);
};


/// Naive Mark and Sweep Collector.
struct GC_EXTERN flx_collector_t : public collector_t
{
  flx_collector_t(allocator_t *, flx::pthread::thread_control_t *);
  ~flx_collector_t();

  // RF: added to allow implementation of non-leaky drivers.
  void free_all_mem(); // clear all roots, sweep.

  void set_used(void *memory, unsigned long); 
  void incr_used(void *memory, unsigned long); 
  unsigned long get_used(void *memory); 
  unsigned long get_count(void *memory); 
  void *create_empty_array( gc_shape_t *shape, unsigned long count);
  gc_shape_t *get_shape(void *memory); 

protected:

  /// allocator
  void *impl_allocate(gc_shape_t *ptr_map, unsigned long);

  /// collector (returns number of objects collected)
  unsigned long impl_collect();

  // add and remove roots
  void impl_add_root(void *memory);
  void impl_remove_root(void *memory);

  //
  void check();

  // statistics
  unsigned long impl_get_allocation_count()const;
  unsigned long impl_get_root_count()const;
  unsigned long impl_get_allocation_amt()const;
  void impl_finalise(void *fp);

private:
  /// allocator
  void *v_allocate(gc_shape_t *ptr_map, unsigned long);

  /// collector (returns number of objects collected)
  unsigned long v_collect();

  // add and remove roots
  void v_add_root(void *memory);
  void v_remove_root(void *memory);

  // statistics
  unsigned long v_get_allocation_count()const;
  unsigned long v_get_root_count()const;
  unsigned long v_get_allocation_amt()const;

private:
  void judyerror(char const*);
  unsigned long allocation_count;
  unsigned long root_count;
  unsigned long allocation_amt;

 
  void unlink(void *frame);
  void v_finalise(void *frame);
  void post_delete(void *frame);
  void delete_frame(void *frame);
  unsigned long reap();

  void mark();
  unsigned long sweep(); // calls scan_object
  void scan_object(void *memory);

  typedef std::map<void *,unsigned long, std::less<void *> > rootmap_t;
  rootmap_t roots;
  bool parity;
  allocator_t *allocator;
  flx::pthread::thread_control_t *thread_control;

  // JudyL array and error object
  void *j_shape;
  void *j_nalloc;
  void *j_nused;

  void *j_tmp;
  JError_t je;
};

}}} // end namespaces
#endif

@select(tangler('rtl/flx_collector.cpp'))
#include <cstdlib>
#include <map>
#include <limits.h>
#include <cassert>
#include <cstdio>
#include <cstddef>
#include "flx_rtl_config.hpp"
#include "flx_collector.hpp"
#include "flx_rtl.hpp"
namespace flx {
namespace gc {
namespace collector {

static int mcount FLX_UNUSED = 0;
#if FLX_HAVE_GNU_X86
register void *sp __asm__("esp");
#else
// this was getting us unused variable warnings
// static void *sp = 0;
#endif

void *low_sp = 0;
void *hi_sp = 0;

void *malloc_free::allocate(std::size_t amt)
{
  void *p = malloc(amt);
  if(debug)
    fprintf(stderr,"Malloc %ld bytes, address = %p\n",amt,p);
  if(p)return p;
  else {
    fprintf(stderr,"Felix: Malloc out of memory, blk=%ld\n",long(amt));
    throw flx::rtl::flx_out_of_memory_t();
  }
}


void *malloc_free::reallocate(void *p, size_t amt)
{
  void *q = realloc(p,amt);
  if(q) return p;
  else {
    fprintf(stderr,"Felix: Realloc out of memory, blk=%ld\n",long(amt));
    abort();
  }
}

void malloc_free::deallocate(void *p)
{
  if(debug)
    fprintf(stderr,"Free %p\n",p);
  free(p);
}

void *flx_collector_t::v_allocate(gc_shape_t *ptr_map, unsigned long x) {
  return impl_allocate(ptr_map, x);
}

void flx_collector_t::v_finalise(void *frame) {
  impl_finalise(frame);
}

unsigned long flx_collector_t::v_collect() {
  // NO MUTEX
  return impl_collect();
}

void flx_collector_t::v_add_root(void *memory) {
  impl_add_root(memory);
}

void flx_collector_t::v_remove_root(void *memory) {
  impl_remove_root(memory);
}

unsigned long flx_collector_t::v_get_allocation_count()const {
  return impl_get_allocation_count();
}

unsigned long flx_collector_t::v_get_root_count()const {
  return impl_get_root_count();
}

unsigned long flx_collector_t::v_get_allocation_amt()const {
  return impl_get_allocation_amt();
}

unsigned long flx_collector_t::impl_get_allocation_count()const
{
  return allocation_count;
}

unsigned long flx_collector_t::impl_get_root_count()const
{
  return root_count;
}

unsigned long flx_collector_t::impl_get_allocation_amt()const
{
  return allocation_amt;
}


flx_collector_t::flx_collector_t(allocator_t *a, pthread::thread_control_t *tc) 
  :allocation_count(0)
  ,root_count(0)
  ,allocation_amt(0)
  ,parity(false)
  ,allocator(a)
  ,thread_control(tc)
  ,j_shape(0)
  ,j_nalloc(0)
  ,j_nused(0)
  ,j_tmp(0)
{}

void flx_collector_t::judyerror(char const *loc)
{
  fprintf(stderr, "JUDY ERROR %d in %s\n",je.je_Errno,loc);
  abort();
}

void * flx_collector_t::impl_allocate(gc_shape_t *shape, unsigned long nobj)
{
  // calculate how much memory to request
  std::size_t amt = nobj * shape->amt * shape->count;
  //fprintf(stderr, "req amt = %ld\n",amt);
  if(amt & 1) ++amt; // round up to even number
  //fprintf(stderr, "rounded req amt = %ld\n",amt);

  // allocate a block
  void *fp = (void *)allocator->allocate(amt);
  assert(fp); // Got some memory!

  if(debug)
    fprintf(stderr,"Allocated %p, shape=%p = new %s\n", fp,shape,shape->cname);

  Word_t *p = (Word_t*)(void*)JudyLIns(&j_shape,(Word_t)fp,&je);
  *p = ((Word_t)(void*)shape) | (parity & 1);
  if (nobj != 1uL) // array
  {
    Word_t *p = (Word_t*)(void*)JudyLIns(&j_nalloc,(Word_t)fp,&je);
    *p = nobj;
  }

  // update statistics
  allocation_count++;
  allocation_amt += amt;
  //fprintf(stderr,"ADDING %ld to allocation amt, result %ld\n",long(amt),long(allocation_amt));
  // return client memory pointer
  return fp;
}

void flx_collector_t::set_used(void *memory, unsigned long n)
{
  assert(memory);
  assert(n>=0);

  // this check is expensive, but set_used is not used often
  assert(n<=get_count(memory)); 
  //fprintf(stderr,"Set used of %p to %ld\n",memory,n);
  Word_t *p = (Word_t*)(void*)JudyLGet(j_nused,(Word_t)memory,&je);
  if(p==(Word_t*)PPJERR)judyerror("set_used");
  if(p==NULL)
  {
    //fprintf(stderr,"No recorded usage! Creating store for data\n");
    p = (Word_t*)(void*)JudyLIns(&j_nused,(Word_t)memory,&je);
  }
  //fprintf(stderr,"Slot for %p usage is address %p\n",memory,p);
  *p = (Word_t)n;
}

void flx_collector_t::incr_used(void *memory, unsigned long n)
{
  assert(memory);
  assert(n>=0);
  //fprintf(stderr,"Incr used of %p by %ld\n",memory,n);
  assert(get_used(memory) + n <= get_count(memory));
  Word_t *p = (Word_t*)(void*)JudyLGet(j_nused,(Word_t)memory,&je);
  if(p==(Word_t*)PPJERR)judyerror("incr_used");
  if(p==NULL)
  {
    p = (Word_t*)(void*)JudyLIns(&j_nused,(Word_t)memory,&je);
    *p = n;
  }
  else *p+=n;
}

// actual number of used slots in an array
unsigned long flx_collector_t::get_used(void *memory)
{
  assert(memory);
  //fprintf(stderr, "Get used of %p\n",memory);
  Word_t *p = (Word_t*)(void*)JudyLGet(j_nused,(Word_t)memory,&je);
  if(p==(Word_t*)PPJERR)judyerror("get_used");
  //fprintf(stderr, "Used slot at address %p\n",memory);
  unsigned long z = p!=NULL?*p:1; // defaults to 1 for non-array support
  //fprintf(stderr,"Used of %p is %ld\n",memory,z);
  return z;
}

// max number of available slots in an array
unsigned long flx_collector_t::get_count(void *memory)
{
  assert(memory);
  Word_t *p = (Word_t*)(void*)JudyLGet(j_nalloc,(Word_t)memory,&je);
  if(p==(Word_t*)PPJERR)judyerror("get_count");
  return p!=NULL?*p:1; // defaults to 1 for non-array support
}

gc_shape_t *flx_collector_t::get_shape(void *memory)
{
  assert(memory);
  Word_t *pshape= (Word_t*)JudyLGet(j_shape,(Word_t)memory,&je);
  if(pshape==(Word_t*)PPJERR)judyerror("get_shape");
  if(pshape==NULL) abort();
  return (gc_shape_t*)(*pshape & (~1ul));
}

void *flx_collector_t::create_empty_array(
  flx::gc::generic::gc_shape_t *shape,
  unsigned long count
)
{
  //fprintf(stderr,"create empty array length %ld\n",count);
  void *p = allocate(shape,count);
  set_used (p, 0); // make sure to override default 1 slot usage
  //fprintf(stderr,"Array at %p, used = %ld, max=%ld\n",p,get_used(p), get_count(p));
  return p;
}


void flx_collector_t::impl_finalise(void *fp)
{
  assert(fp!=NULL);
  gc_shape_t *shape = get_shape(fp);
  void (*finaliser)(collector_t*, void*) = shape->finaliser;
  if (finaliser)  
  {
    unsigned char *cp = (unsigned char*)fp;
    unsigned long n_used = get_count(fp) * shape->count;
    unsigned long eltsize = shape->amt;
    for(unsigned long j = 0; j<n_used; ++j)
    {
      (*finaliser)(this,(void*)cp);
      cp += eltsize;
    }
  }
}

void flx_collector_t::unlink(void *fp)
{
  // check we have a pointer to an object
  assert(fp!=NULL);

  // call the finaliser if there is one
  impl_finalise(fp);

  allocation_count--;
  gc_shape_t *shape = get_shape(fp);
  unsigned long n_objects = get_count(fp);
  unsigned long nobj = shape -> count * n_objects;
  std::size_t size = shape->amt * nobj;
  allocation_amt -= size;

  // unlink the frame from the collectors list
  JudyLDel(&j_shape, (Word_t)fp, &je);
  JudyLDel(&j_nused, (Word_t)fp, &je);
  JudyLDel(&j_nalloc, (Word_t)fp, &je);
}

void flx_collector_t::post_delete(void *fp)
{
  Judy1Set(&j_tmp,(Word_t)fp,&je);
}

void flx_collector_t::delete_frame(void *fp)
{
  allocator->deallocate(fp);
}

unsigned long flx_collector_t::reap ()
{
  unsigned long count = 0;
  Word_t next=(Word_t)NULL;
  int res = Judy1First(j_tmp,&next,&je);
  while(res) {
    delete_frame((void *)(void*)next);
    ++count;
    res = Judy1Next(j_tmp,&next,&je);
  }
  Judy1FreeArray(&j_tmp,&je);
  if(debug)
    fprintf(stderr,"Reaped %lu objects\n",count);
  return count;
}

void flx_collector_t::mark()
{
  if(debug)fprintf(stderr,"Collector: Running mark\n");
  assert (root_count == roots.size());

  rootmap_t::iterator const end = roots.end();
  for(
    rootmap_t::iterator i = roots.begin();
    i != end;
    ++i
  )
    scan_object((*i).first);
}



unsigned long flx_collector_t::sweep()
{
  if(debug)
    fprintf(stderr,"Collector: Sweep, garbage bit value=%d\n",(int)parity);
  unsigned long sweeped = 0;
  void *current = NULL;
  Word_t *pshape = (Word_t*)JudyLFirst(j_shape,(Word_t*)&current,&je);
  if(pshape==(Word_t*)PPJERR)judyerror("sweep");
  
  while(pshape!=NULL)
  {
    if((*pshape & 1) == (parity & 1UL))
    {
      if(debug)
        fprintf(stderr,"Garbage %p=%s\n",current,((gc_shape_t*)(*pshape & ~1UL))->cname);
      ++ sweeped;
      unlink(current);
      post_delete(current);
    }
    else
      if(debug)
        fprintf(stderr,"Reachable %p=%s\n",current,((gc_shape_t*)(*pshape & ~1UL))->cname);

    pshape = (Word_t*)JudyLNext(j_shape,(Word_t*)(void*)&current,&je);
  }

  parity = !parity;
  if(debug)
    fprintf(stderr,"Sweeped %ld\n",sweeped);
  return reap();
}

void flx_collector_t::impl_add_root(void *memory)
{
  if(!memory)
  {
    fprintf(stderr, "GC ERROR: ADD NULL ROOT\n");
    abort();
  }
  rootmap_t::iterator iter = roots.find(memory);
  if(iter == roots.end())
  {
    std::pair<void *const, unsigned long> entry(memory,1UL);
    roots.insert (entry);
    root_count++;
  }
  else
    ++(*iter).second;
}

void flx_collector_t::impl_remove_root(void *memory)
{
  rootmap_t::iterator iter = roots.find(memory);
  if(iter == roots.end())
  {
    fprintf(stderr, "GC ERROR: REMOVE ROOT WHICH IS NOT ROOT\n");
    abort();
  }
  if((*iter).second == 1UL)
  {
    roots.erase(iter);
    root_count--;
  }
  else
    --(*iter).second;
}

void flx_collector_t::scan_object(void *p)
{
  Word_t reachable = (parity & 1UL) ^ 1UL;
  if(debug)
    fprintf(stderr,"Scan object %p, reachable bit value = %d\n",p,(int)reachable);
  Word_t cand = (Word_t)p;
  Word_t fp=cand;
  Word_t *w = (Word_t*)JudyLLast(j_shape,&fp,&je);
  if(p==(Word_t*)PPJERR)judyerror("scan_object");
  if(w == NULL) return; // no lower object
  if(debug)
    fprintf(stderr,"Found candidate object %p, &shape=%p, shape(1) %p!\n",(void*)fp,(void*)w,(void*)(*w));
  if( (*w & 1UL) == reachable) return;   // already handled

  gc_shape_t *shape = (gc_shape_t*)(*w & ~1UL);
  if(debug)
    fprintf(stderr,"Found candidate UNMARKED object %p, shape %p, type=%s\n",(void*)fp,shape,shape->cname);
  unsigned long n = get_count((void*)fp) * shape->count * shape->amt;
  if(cand >= (Word_t)(void*)((unsigned char*)(void*)fp+n)) return; // not interior
  if(debug)
    fprintf(stderr,"Found reachable umarked object!\n");

  *w = (*w & ~1uL) | reachable;

  unsigned long n_used = get_used((void*)fp) * shape->count;
  std::size_t n_offsets = shape->n_offsets;
  std::size_t *offsets = shape->offsets;

  for(unsigned long j=0; j<n_used; ++j)
  {
    for(unsigned int i=0; i<n_offsets; ++i)
    {
      void **pq = (void**)(void*)((unsigned char*)p + offsets[i]);
      void *q = *pq;
      if(q)scan_object(q);
    }
    p=(void*)((unsigned char*)p+shape->amt);
  }
}

unsigned long flx_collector_t::impl_collect()
{
  fprintf(stderr,"Request to collect, thread %lx\n", pthread_self());
  if (thread_control == NULL || thread_control->world_stop())
  {
    //if(debug)
      fprintf(stderr,"Running collector\n");
    mark();
    unsigned long collected = sweep();
    if(thread_control) thread_control->world_start();
    return collected;
  }
  else {
    if(debug)
      fprintf(stderr,"RACE: someone else is collecting, just yield\n");
    thread_control->yield();
    return 0ul;
  }
}

// scan all known objects, and check every pointer
// is either NULL or points to one of them

void flx_collector_t::free_all_mem()
{
  roots.clear();
  root_count = 0;
  sweep();
}

flx_collector_t::~flx_collector_t()
{
  //THIS IS VERY DANGEROUS! What if don't want to collect
  //the garbage for efficiency reasons???
  //
  // ELIDED .. already caused a bug!
  //
  //free_all_mem();
}

}}} // end namespaces

@select(tangler('rtl/flx_ts_collector.hpp'))
#ifndef __FLX_TS_COLLECTOR_H__
#define __FLX_TS_COLLECTOR_H__
#include "flx_collector.hpp"
#include "pthread_mutex.hpp"
#include "pthread_thread.hpp"

namespace flx {
namespace gc {
namespace collector {

/// Naive thread safe Mark and Sweep Collector.
struct PTHREAD_EXTERN flx_ts_collector_t : 
  public flx::gc::collector::flx_collector_t
{
  flx_ts_collector_t(allocator_t *, flx::pthread::thread_control_t *);
  ~flx_ts_collector_t();

private:
  /// allocator
  void *v_allocate(gc_shape_t *ptr_map, unsigned long);

  /// collector (returns number of objects collected)
  unsigned long v_collect();

  // add and remove roots
  void v_add_root(void *memory);
  void v_remove_root(void *memory);

  // statistics
  unsigned long v_get_allocation_count()const;
  unsigned long v_get_root_count()const;
  unsigned long v_get_allocation_amt()const;

private:
  mutable flx::pthread::flx_mutex_t mut;
};


}}} // end namespaces
#endif

@select(tangler('rtl/flx_ts_collector.cpp'))
#include "flx_rtl_config.hpp"
#include "flx_ts_collector.hpp"

namespace flx {
namespace gc {
namespace collector {

flx_ts_collector_t::flx_ts_collector_t(allocator_t *a, flx::pthread::thread_control_t *tc) : 
  flx_collector_t(a,tc)
{}

flx_ts_collector_t::~flx_ts_collector_t(){}

void *flx_ts_collector_t::v_allocate(gc_shape_t *ptr_map, unsigned long x) {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_allocate(ptr_map,x);
}

unsigned long flx_ts_collector_t::v_collect() {
  // NO MUTEX
  return impl_collect();
}

void flx_ts_collector_t::v_add_root(void *memory) {
  flx::pthread::flx_mutex_locker_t l(mut);
  impl_add_root(memory);
}

void flx_ts_collector_t::v_remove_root(void *memory) {
  flx::pthread::flx_mutex_locker_t l(mut);
  impl_remove_root(memory);
}

unsigned long flx_ts_collector_t::v_get_allocation_count()const {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_get_allocation_count();
}

unsigned long flx_ts_collector_t::v_get_root_count()const {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_get_root_count();
}

unsigned long flx_ts_collector_t::v_get_allocation_amt()const {
  flx::pthread::flx_mutex_locker_t l(mut);
  return impl_get_allocation_amt();
}


}}} // end namespaces


