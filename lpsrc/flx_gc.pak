@import config

@head(1,'Garbage collector')

@p()
The Felix garbage collector consists of two components: the collector
abstraction, and a concrete collector.
@p()
The abstraction consists of an abstract class collector_t,
which models the collector,
an abstract class allocator_t, which models an allocator,
and two concrete classes:
shape_t, which defines a type shape descriptor, and void *,
which describes an allocated memory block, called a frame.
@p()
The void *data is stored at the beginning of every block
the collector manages, this is called the header part.
The rest of the block is for client data, and is called the client part.
The collector manages frames in terms of pointers to the whole block,
which are also pointers to the header. The client only sees a pointer
to the client part.
@p()
The header contains links to other frames, so the collector can navigate
the set of blocks, and a pointer to a shape object,
which describes where in the client part pointers reside, so that the
collector can chase down all the reachable blocks.
@p()
The collector mechanism provides resources for a simple
mark and sweep collector, reference counting, and manual
deletion. It also provides for user written finalisers,
in particular C++ class destructors.
@p()
Note that the collector is a 'world stop' synchronous collector.
Collection only occurs when you call the collect() method of the
collector object.
@p()
Note the Felix allocator abstraction is not compatible with
the C++ allocator concept; instead, it is a simple wrapper
around the malloc/free interface. It is provided primarily
to allow instrumentation of allocations, although it is possible
to supply a user written allocator.

@h = tangler('spkgs/flx_gc.py')
@select(h)
import os

cpp_cpps = [
  'src/gc/flx_gc',
  'src/gc/flx_collector',
  'src/gc/flx_ts_collector'
  ]

rtl_interfaces = [
  'src/gc/flx_gc.hpp',
  'src/gc/flx_collector.hpp',
  'src/gc/flx_gc_private.hpp',
  'src/gc/flx_ts_collector.hpp'
]

provides_lib = "libflx_gc"
pkg_requires = ['flx_judy', 'flx_exceptions', 'flx_pthread']
lib_requires = ['libflx_judy', 'libflx_exceptions', 'libflx_pthread']
iscr_source = ['lpsrc/flx_gc.pak']
build_macro = "FLX_GC"
weaver_directory = 'doc/rtl/flx_gc/'
xfiles = [os.path.join('src', 'gc', '*')]

@h = tangler('config/flx_gc.fpc')
@select(h)
Name: flx_gc
Description: Felix default garbage collector
Version: $Id$
@if config.HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_gc_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_gc_static")
 else:
   tangle("provides_dlib: -lflx_gc_dynamic")
   tangle("provides_slib: -lflx_gc_static")

includes: "flx_gc.hpp"
Requires: flx_judy

@h=tangler('config/target/flx_gc_config.hpp')
@select(h)
#ifndef __FLX_GC_CONFIG_H__
#define __FLX_GC_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_FLX_GC
#define GC_EXTERN FLX_EXPORT
#else
#define GC_EXTERN FLX_IMPORT
#endif
#endif


