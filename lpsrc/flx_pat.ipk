@head(1,"Pattern matching utilities")
@h = tangler("src/flx_pat.mli")
@select(h)
val validate_patterns:
  Flx_types.pattern_t list -> unit

@h = tangler("src/flx_pat.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_srcref

(* These routine just check that the shape of a list
  of patterns match the pattern class indicated by their names.

  These routines are used for class based desugaring.
  Note that type correctness isn't checked, since
  type binding isn't done yet.
*)

let rec check_match_int pats =
  let rec check pat = match pat with
  | `PAT_any _
  | `PAT_int _
  | `PAT_int_range _
  | `PAT_name _ -> ()
  | `PAT_as (_,pat,_) -> check pat
  | `PAT_when (_,pat,_) -> check pat
  | _ -> 
    failwith 
    (
      short_string_of_src (src_of_pat pat) ^ 
      ": Integer pattern expected"
    )
  in
  List.iter check pats
  
and check_match_string pats =
  let rec check pat = match pat with
  | `PAT_any _
  | `PAT_string _
  | `PAT_string_range _
  | `PAT_regexp _ 
  | `PAT_name _ -> ()
  | `PAT_as (_,pat,_) -> check pat
  | `PAT_when (_,pat,_) -> check pat
  | _ -> 
    failwith 
    (
      short_string_of_src (src_of_pat pat) ^ 
      ": String pattern expected"
    )
  in
  List.iter check pats

and check_match_float pats =
  let rec check pat = match pat with
  | `PAT_nan _
  | `PAT_any _
  | `PAT_float_range _
  | `PAT_name _ -> ()
  | `PAT_as (_,pat,_) -> check pat
  | `PAT_when (_,pat,_) -> check pat
  | _ -> 
    failwith 
    (
      short_string_of_src (src_of_pat pat) ^ 
     ": Float pattern expected"
    )
  in
  List.iter check pats

and check_match_tuple n pats =
  let rec check n pat = match pat with
  | `PAT_any _ 
  | `PAT_name _ -> ()
  | `PAT_tuple (sr,pats) ->
    if List.length pats <> n
    then failwith 
      (
        short_string_of_src sr ^ 
        ": Tuple pattern wrong length"
      )
  | `PAT_as (_,pat,_) -> check n pat
  | `PAT_when (_,pat,_) -> check n pat
  | _ -> 
    failwith 
    (
      short_string_of_src (src_of_pat pat) ^ 
      ": Tuple pattern expected"
    )
  in
  List.iter (check n) pats
  ;
  let rec match_split pat = match pat with
  | `PAT_any _ -> [] 
  | `PAT_name _ -> []
  | `PAT_as (_,pat,_) -> match_split pat
  | `PAT_when (_,pat,_) -> match_split pat
  | `PAT_tuple (_,ps) -> ps
  | _ -> 
    failwith 
    (
      short_string_of_src (src_of_pat pat) ^ 
      ": Tuple pattern expected"
    )
  in let tpats = 
    try 
      Flx_util.transpose 
      (
        List.filter 
        (function | [] -> false | _ -> true)
        (List.map match_split pats)
      )
    with _ -> failwith "Transpose failed"
  in 
  List.iter
  (fun pats -> 
    if List.length pats = 0 
    then failwith "Null list?"
    else find_match_type (List.hd pats) pats
  )
  tpats

and check_match_union pats =
  let rec check pat = match pat with
  | `PAT_any  _
  | `PAT_nonconst_ctor _ 
  | `PAT_const_ctor _ 
  | `PAT_name _ -> ()
  | `PAT_as (_,pat,_) -> check pat
  | `PAT_when (_,pat,_) -> check pat
  | _ -> 
    failwith 
    (
      short_string_of_src (src_of_pat pat) ^ 
      ": union pattern expected"
    )
  in 
  List.iter check pats

and renaming pats = ()

(* This routine finds the checker routine for given
   pattern. Note that 'renaming' checks nothing:
   if this kind is the head of a match list,
   the following matches will never be executed.
   [They should be checked for correctness anyhow ..
    but instead, we consider this an error temporarily
   ]
*)
and find_match_type pat = match pat with
  | `PAT_nan _ -> check_match_float
  | `PAT_int _ -> check_match_int 
  | `PAT_string _ -> check_match_string

  (* ranges *)
  | `PAT_int_range _ -> check_match_int
  | `PAT_string_range _ -> check_match_string
  | `PAT_float_range _ -> check_match_float

  (* other *)
  | `PAT_name _ -> renaming
  | `PAT_tuple (_,pats) -> check_match_tuple (List.length pats)
  | `PAT_any _ -> renaming
  | `PAT_regexp _ -> check_match_string
  | `PAT_const_ctor _ -> check_match_union
  | `PAT_nonconst_ctor _ -> check_match_union
  | `PAT_as (_,pat,_) -> find_match_type pat
  | `PAT_when (_,pat,_) -> find_match_type pat

(* This routine is used to check all but the last
   pattern match isn't a match all
*)

let rec check_terminal pat = match pat with
  | `PAT_any sr -> 
    failwith 
    (
      "'Any' pattern '_' must be last in match in " ^ 
      short_string_of_src sr
    )
  | `PAT_name (sr,x) -> 
    failwith 
    (
      "'Name' pattern '"^x^"' must be last in match in " ^
      short_string_of_src sr
    )
  | `PAT_float_range (sr, Float_minus_inf, Float_inf) ->
    failwith 
    (
      "Whole floating range must be last in match in " ^ 
      short_string_of_src sr
    )
  | `PAT_as (_,pat,_) -> check_terminal pat
  | _ -> ()
  
let validate_patterns pats =
  if List.length pats = 0
  then failwith "Empty pattern list";
  let hpat = List.hd pats in
  let checker = find_match_type hpat in
  checker pats;
  List.iter check_terminal (List.tl (List.rev pats));
  List.iter 
  (fun x -> match x with
    | `PAT_nan sr ->
      failwith 
      (
        "NaN test must be first in match in " ^
        short_string_of_src sr
      )
    | _ -> ()
  )
  (List.tl pats)
