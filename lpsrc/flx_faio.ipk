@head(1,"Faio")
Asynch I/O interface pack.
$Log$
Revision 1.27  2006/01/25 00:34:40  rfistman
removed a few outstanding references to SDL_image
fixed a tiny typo in flx_use.ipk
got rid of superfluous private fn in faio.

Revision 1.26  2006/01/24 13:21:10  rfistman
fixed race condition in posix asynchronous connect
and made test output for same a little more obvious

Revision 1.25  2006/01/18 05:50:04  rfistman
turned sdl_event thing into a driver request

Revision 1.24  2006/01/16 01:25:43  rfistman
factored faio posix accept and connect back demux as control blocks
removed pthread cancel from code - implicit cancel points are no longer used.
instead the threads are convinced to return from their mains via specially
formatted inputs.

Revision 1.22  2006/01/08 03:44:13  rfistman
fixed bogus SIGPIPE ignore warning
added missing namespace to solaris evtport_demuxer.cpp file

Revision 1.21  2006/01/07 17:24:57  skaller
Added SDL binding. Fixed bug in function return type so
that lvalue return types now return C++ references.
Added _deref primitive, define deref to use it for Felix refs,
and defined a primitive for C pointers.

Revision 1.20  2006/01/05 23:27:00  rfistman
added missing FLX_SOCKLEN_T
dual CYGWIN WIN32 stuff commented out for now (not working needs further work)

Revision 1.19  2006/01/05 04:00:35  rfistman
fixed problem in solaris evtports where adding both reading and
writing sockets caused a race condition (now we have two two
"half-demuxers", for input and output)

pc listener create function can now let winsock choose the port,
just like the posix version.

much factoring:
  overlapped calls factored back to demux as control blocks
  posix socket code factored in preparation for UDP/dgram and IPv6 sockets.

Revision 1.18  2006/01/03 04:29:21  rfistman
fixed win32 tests by a) initing winsock in flx_run and using
the correct return value.

Revision 1.17  2005/12/31 07:06:32  skaller
Changed user statement parser so that special keywords
expr, statement, statements, etc are only recognized parsing
the preprocessor directives statement and nonterminal.
Note ident is already a proper keyword for the
macro processor  though.

Revision 1.16  2005/12/31 03:20:22  rfistman
working on flx_stream stuff + writing tests

Revision 1.15  2005/12/30 14:57:40  skaller
Fix some win32 issues with namespaces.

Revision 1.14  2005/12/30 04:39:32  skaller
Fixed copipes to be 'portable'

Revision 1.13  2005/12/29 18:16:04  skaller
Namespaces and modules added ..

Revision 1.12  2005/12/29 13:52:07  skaller
Added log to rtl and faio.


@execfile('config'+os.sep+'config.py')

@h=tangler('faio/faio_asyncio.hpp')
@select(h)
#ifndef __ASYNCIO__
#define __ASYNCIO__
#include <flx_rtl_config.hpp>

// this file acts as go-between for my asynchronous interface for felix
// programmes. 

// portable. Not that asynchronous.
    
#include "demux_demuxer.hpp"        // sel_param, demuxer base
#include "faio_drv.hpp"

namespace flx { namespace faio {

class FLX_RTL_EXTERN flx_driver_request_base {
public:
    virtual ~flx_driver_request_base() {}       // so destructors work
    // returns finished flag (async may fail or immediately finish)
    virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f) = 0;
};  
    
// not actually asynchronous as such since the threads are woken synchronously
// definitely portable. look out for this shared structure when flx threads
// are run pre-emptively. start_async_op will need to be serialised.
class FLX_RTL_EXTERN async_copipe : public flx_driver_request_base {
public:
    enum { WINDWARD, LEEWARD, NUM_CHANNELS };
    
    virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);
    void connect(void* f, demux::sel_param* pb, bool reading, int channel);
    void close_channel(int which);      // WINDWARD or LEEWARD
    void disconnect();                  // will be used by close
    
    static async_copipe* create_copipe() { return new async_copipe; }
    bool debug;
    void set_debug(bool);

private: 
    enum { READER, WRITER, NUM_CNXNS };
    
    // if there's a thread here, it's sleeping
    void*   thread[NUM_CNXNS];
    demux::sel_param*  pb[NUM_CNXNS];
    int         num_users;
    
    bool        channel_open[NUM_CHANNELS];
    int         current_channel;
    void wake_thread(int n, flx_drv* drv);
    void wake_all_threads(flx_drv* drv);
    
    async_copipe();                     // to control alloc/dealloc
};

class FLX_RTL_EXTERN copipe_endpt {
    int             read_channel;       // the channel this endpt reads on
    
    copipe_endpt(async_copipe* p, int rchan) : 
      read_channel(rchan), pipe(p), debug(false)
    {}

public:
    async_copipe*   pipe;               // endpt's copy (flx accessible)
    
    // 0 = no reads, 1 = no writes, 2 = no nothing (! = close, however)
    void shutdown(int how);
    int get_channel(bool reading);
    bool debug; 
    void set_debug(bool d) { debug = d; }

    ~copipe_endpt() { pipe->disconnect(); } 
    static void pipe_pair(copipe_endpt* pair[2]);
};

// sleeping
class sleep_request 
  : public flx_driver_request_base, public demux::sleep_task
{
  thread_wakeup fw;
  double      delta;
public:
  sleep_request() {}        // flx linkage

  sleep_request(double d) : delta(d) {}

  // from driver request
  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  // from sleep_task
  virtual void fire();  
};

}} // namespace faio, flx
#endif  // __ASYNCIO__

@h=tangler('faio/faio_asyncio.cpp')
@select(h)
#include "faio_asyncio.hpp"
#include <string.h>     // memmove
#include <stdio.h>      // debugging

using namespace flx::demux;
namespace flx { namespace faio {
// cooperative pipes

// this is a bit interesting because the copipes are not asynchronous and
// their work is actually all done in this function (once both ends have
// read & written)

void
async_copipe::set_debug(bool d) { debug = d; }

bool
async_copipe::start_async_op(demux::demuxer& demux, flx_drv* drv, void* f)
{
// this is where a big lock will go for multithreaded driver
    // we don't want to wake anyone twice
    bool wake_caller = (f != thread[READER] && f != thread[WRITER]);

    // no channel => shutdown was called with no-one reading or writing
    if(-1 == current_channel)
        return true;                // wake caller

    // we may have one reader/writer (or even 2 with a multithreaded driver)
    if(!channel_open[current_channel])
    {
        wake_all_threads(drv);
        current_channel = -1;       // channel now undefined
        return wake_caller;
    }
    // channel closed situations handled

    // if we don't have both endpts, then the op isn't finished
    if(!(thread[READER] && thread[WRITER])) return wake_caller;
    
    // we have both ends. one or both must wake after this
if(wake_caller) fprintf(stderr,"we should never have a 3rd party here!\n");
    
    // move data from writer to reader
    long    len;
    long    nb1 = pb[READER]->buffer_size-pb[READER]->bytes_written;
    long    nb2 = pb[WRITER]->buffer_size-pb[WRITER]->bytes_written;
    
    // min(read bytes, write bytes)
    len = (nb1 < nb2) ? nb1 : nb2;
    
    // write buf -> read buf
    memmove(pb[READER]->buffer + pb[READER]->bytes_written,
        pb[WRITER]->buffer + pb[WRITER]->bytes_written, len);
    pb[READER]->bytes_written += len;
    pb[WRITER]->bytes_written += len;
    
    // I could let the driver wake one of the threads, but it makes for
    // easier reading if I do it myself:
    int     num_woken = 0;
    for(int i = 0; i < NUM_CNXNS; i++)
    {   
        // wake up!
        if(pb[i]->bytes_written == pb[i]->buffer_size)
        {   
            wake_thread(i, drv);
            num_woken++;
        }
    }
    
    if(num_woken == NUM_CNXNS)  // everyone woke up
        current_channel = -1;   // channel now undefined
    
    // we're doing our own waking, so just say no, it isn't finished.
    // not strictly honest, is it? driver waking is kind of lame anyway.
    // it's our job.
    return false;
}

void
async_copipe::wake_thread(int n, flx_drv* drv)
{   
    drv->sched(thread[n]);  
    thread[n] = 0;          // not ours anymore
}

void
async_copipe::wake_all_threads(flx_drv* drv)
{   
    for(int i = 0; i < NUM_CNXNS; i++)
    {   
        if(thread[i]) wake_thread(i, drv);
    }
}

async_copipe::async_copipe() : debug(false) 
{
    thread[READER] = 0;
    thread[WRITER] = 0;
    channel_open[WINDWARD] = true;  // both channels open = duplex io
    channel_open[LEEWARD] = true;   
    current_channel = -1;           // current channel undefined
    num_users = 2;                  // we delete this after 2 disconnects
}

// this requires a driver request to make anything actually happen
void
async_copipe::close_channel(int which)
{   
    // this should wake up the threads, but I don't have the queue.
    // my choice is for the felix code to do an async op on this and
    // re-evaluate, waking as necessary or hang on to the queue
    channel_open[which] = false;
}

void
async_copipe::disconnect()
{   
    if(debug)fprintf(stderr,"num_users before disconnect: %i\n", num_users);
    if(--num_users == 0)
    {   
        if(debug)fprintf(stderr,"deleting this!\n");
        delete this;
    }
}

void
async_copipe::connect(void* f, sel_param* inpb, bool reading, int channel)
{
    int i = (reading) ? READER : WRITER;

    if(-1 == current_channel)
    {
        current_channel = channel;
    }
    else if(current_channel != channel) // channel must agree if already chosen
    {
        if(debug)fprintf(stderr,"conflicting channels! make sure this causes a wake up!\n");
        current_channel = -1;           // causes this thread to wake up
        return;
    }
        
    // there shouldn't be anything already there
    if(f && thread[i]) 
        if(debug)fprintf(stderr,"copipe conflict! results undefined!\n");
    
    thread[i] = f;
    pb[i] = inpb;
}

// copipe endpoints, just like socketpair. static.
void
copipe_endpt::pipe_pair(copipe_endpt* pair[2])
{
//fprintf(stderr,"this will leak if one fails, you buffoon!\n");
// can just delete in that case. eh.
    async_copipe* p = async_copipe::create_copipe();
    // initialize with pipe and the channel they'll read on.
    pair[0] = new copipe_endpt(p, async_copipe::WINDWARD);
    pair[1] = new copipe_endpt(p, async_copipe::LEEWARD);
}

int
copipe_endpt::get_channel(bool reading)
{   
    if(reading) return read_channel;
    
    return (read_channel == async_copipe::WINDWARD) ?
            async_copipe::LEEWARD : async_copipe::WINDWARD;
}

// this requires a driver request to make anything actually happen
void
copipe_endpt::shutdown(int how)
{   
    int write_channel = get_channel(false);
    
    switch(how)
    {   
        case 0:
            // no further reads, shut read channel
            pipe->close_channel(read_channel);
        break;
        case 1:
            pipe->close_channel(write_channel);
        break;
        case 2:
            // shut both channels, regardless
            pipe->close_channel(async_copipe::WINDWARD);
            pipe->close_channel(async_copipe::LEEWARD);
        break;
    }
}

// sleep task prio queue thing

bool
sleep_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  // fprintf(stderr,"driver called sleep_task start_async_op code\n");
  // important: copy down the thread and the driver
  RECORD_THREAD_INFO(fw);

  drv->get_sleepers()->add_sleep_request(this, delta);

  return false;   // no wakeup
}

// from async io thread
void
sleep_request::fire()
{
  fw.wake();    // wake thread
}

}}

@h=tangler('faio/faio_drv.hpp')
@select(h)
#ifndef __FLXDRV__
#define __FLXDRV__
#include <flx_rtl_config.hpp>

#include "demux_sleep_queue.hpp"
#include "demux_timer_queue.hpp"
#include "demux_work_fifo.hpp"
#include "demux_demuxer.hpp"

namespace flx { namespace faio {
// vestigal driver class is all that remains of the embedded driver from
// which faio came. all it is now is a pointer to a queue. 
// watch this space.
class FLX_RTL_EXTERN flx_drv {
    demux::sleep_queue&    ready_queue;
    demux::worker_fifo     work_fifo;
public:
    flx_drv(demux::sleep_queue& q);
    virtual ~flx_drv();

    void sched(void* f);

    demux::worker_fifo* get_worker_fifo() { return &work_fifo; }
    virtual demux::timer_queue* get_sleepers() = 0;
};

// this becomes socket thread wakeup. um.
class FLX_RTL_EXTERN thread_wakeup {
public:
    void wake() { drv->sched(f); }

    void*           f;              // thread to be woken
    flx_drv*        drv;            // in which driver
};

// to be called inside every start_async_op
// note: the windows version often needs the demuxer, but the posix one
// doesn't. I forget why.
#define RECORD_THREAD_INFO(w) (w).f=f;\
                              (w).drv=drv;

}}
#endif              //__FLXDRV__


@h=tangler('faio/faio_drv.cpp')
@select(h)
#include <stdio.h>              // debug printf
#include "faio_drv.hpp"

using namespace flx::demux;
namespace flx { namespace faio {
flx_drv::flx_drv(sleep_queue& q)
    : ready_queue(q)
{   
}

flx_drv::~flx_drv()
{   
}

void
flx_drv::sched(void* f)
{   
    ready_queue.enqueue(f);
}

}}

@h=tangler('faio/faio_pdrv.hpp')
@select(h)
#ifndef __FAIO_PDRV__
#define __FAIO_PDRV__

#include <flx_rtl_config.hpp>
#include "demux_pfileio.hpp"
#include "demux_posix_timer_queue.hpp"
#include "faio_drv.hpp"
namespace flx { namespace faio {

// same as flx_drv, but with an async file io worker fifo.
class FLX_RTL_EXTERN pflx_drv : public flx_drv {
    // this will be called asynchronously, so better be careful
//  pasync_fileio*  file_aio_worker;
    // make it direct so we don't have to protect the code that would
    // create the pointer. This is a bit heavy, I would prefer on demand.
    demux::pasync_fileio       file_aio_worker;
    demux::posix_timer_queue   sleepers;
public:
    pflx_drv(demux::sleep_queue& q);

    demux::pasync_fileio* get_aio_worker() { return &file_aio_worker; }
    demux::timer_queue* get_sleepers() { return &sleepers; }
    bool debug;
    void set_debug(bool d) { debug = d; }
};
}}
#endif

@h=tangler('faio/faio_pdrv.cpp')
@select(h)
#include "faio_pdrv.hpp"
#include <signal.h>     // for SIGPIPE portable ignoring
#include <stdio.h>      // printf

using namespace flx::demux;
namespace flx { namespace faio {

pflx_drv::pflx_drv(sleep_queue& q)
    : flx_drv(q)
{
    // we might actually like to ignore SIGPIPE's conditionally,
    // e.g. when a flx prog actually requests socket io, we could even
    // transform it into a flx level signal (if those exist, signals are
    // pretty lame & don't work well for library code - would you want them
    // to exist?) (osx has a per socket sockopt that does this, linux has
    // the send flag MSG_NOSIGNAL)

    // this is actually demux/flxasync io's problem, so shift it there
    if(debug)fprintf(stderr,"pdrv installing SIGPIPE ignorer\n");
    if(debug)fprintf(stderr,"OSX/bsd only: setsockopt(SO_NOSIGPIPE) -> EPIPE\n");
    // sig_t   prev_handler;
    void (*prev_handler)(int);  // solaris is FUN.
    prev_handler = signal(SIGPIPE, SIG_IGN);

    if(SIG_ERR == prev_handler)
    {
        fprintf(stderr, "failed to install SIGPIPE ignorer\n");
        throw -1;
    }
    else if(prev_handler != SIG_IGN && prev_handler != SIG_DFL)
    {
        fprintf(stderr,"warning: blew away prev SIGPIPE handler: %p\n",
            prev_handler);
    }
}

}}

@h=tangler('faio/faio_posixio.hpp')
@select(h)
#ifndef __FAIO_POSIXIO__
#define __FAIO_POSIXIO__
#include <flx_rtl_config.hpp>

#include "faio_asyncio.hpp"
#include "faio_drv.hpp" 

// we don't need to piggyback much data at all. for now just the demuxer,
// so that we can be woken up, and the buffer info (this replaces the
// felix "socket" thread type, which was ugly.

#include "demux_posix_demuxer.hpp" 

// a new sort of demuxer/event source: file io completions
// haven't given up on using the socket style demuxers yet.
#include "demux_pfileio.hpp"

#include "demux_timer_queue.hpp"

namespace flx { namespace faio {
 
class FLX_RTL_EXTERN socketio_wakeup : public demux::socket_wakeup {
public:
    demux::sel_param       pb;         // in: what you want, out: what you get
    thread_wakeup   fw; 
    bool        read;

    virtual void wakeup(demux::posix_demuxer& demux);
};

// this can handle most unix style io, that is, read & write on sockets,
// files & pipes. NICE. the fact that the socket is now in here may mean
// I can get rid of the epoll hack
// Not sure if this can be used for file fds.
class FLX_RTL_EXTERN socketio_request : public flx_driver_request_base {
public:
    socketio_wakeup sv;
    
    socketio_request() {}       // Lord Felix demands it. Like STL.
    
    socketio_request(int s, char* buf, long len, bool r);
    virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv,  void* f);
};

class FLX_RTL_EXTERN connect_request
  : public flx_driver_request_base, public demux::connect_control_block {
public:
  thread_wakeup fw;

  connect_request() {}      // flx linkage

  connect_request(const char* addr, int port) { addy = addr; p = port; s=-1; }
  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv,  void* f);
  virtual void wakeup(demux::posix_demuxer& demux);
};

class FLX_RTL_EXTERN accept_request
  : public flx_driver_request_base, public demux::accept_control_block {
public:
  // we sometimes know that there'll be several connections to accept.
  // this'll need a different wakeup - and a different interface between
  // event source & wakeups
  thread_wakeup fw;

  accept_request() {} // flx linkage

  // eeh, give that a better name
  accept_request(int listener) { s = listener; }

  // from flx_driver_request_base
  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  // from accept_control_block
  virtual void wakeup(demux::posix_demuxer& demux);
};


// separate pthread file io
// hum. multiple inheritance
class FLX_RTL_EXTERN flxfileio_request
    : public flx_driver_request_base, public demux::fileio_request
{
    thread_wakeup   fw;
public:
    flxfileio_request() {}          // flx linkage

    flxfileio_request(int f, char* buf, long len, long off, bool rd)
        : fileio_request(f, buf, len, off, rd) {}

    // from driver request
    virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

    // from async io thread
    virtual void finished();
};

}}
#endif

@h=tangler('faio/faio_posixio.cpp')
@select(h)
#include <stdio.h>      // printf
#include "faio_posixio.hpp"
#include "demux_sockety.hpp"    // async_connect

// pthread async file io stuff
#include "faio_pdrv.hpp"


#include <sys/types.h>  // getsockopt & co
#include <sys/socket.h>

#include <unistd.h>     // close
#include <string.h>     // strerror - probably not portable

using namespace flx::demux;
namespace flx { namespace faio {
socketio_request::socketio_request(int s, char* buf, long len, bool r)
{
    sv.s = s;
    sv.read = r;

    sv.pb.buffer = buf;
    sv.pb.buffer_size = len;
    sv.pb.bytes_written = 0;        // really bytes_processed
}

bool
socketio_request::start_async_op(demux::demuxer& demux, flx_drv* drv, void* f)
{
    // printf("adding wakeup: len %i, done %i\n",
    //   sv.pb.buffer_size, sv.pb.bytes_written);

    // important: copy down the thread and the driver
    RECORD_THREAD_INFO(sv.fw);

    posix_demuxer*  pd = (posix_demuxer*)&demux;

    // wake thread if call failed
    return (pd->add_socket_wakeup(&sv, sv.read) == -1);
}


void
socketio_wakeup::wakeup(posix_demuxer& demux)
{
    // handle read/write, return true if not finished.
    // otherwise wakeup return false.
    bool    connection_closed;

    // printf("prehandle wakeup, this: %p, read: %i, len: %i, done %i\n",
    //  this, read, pb.buffer_size, pb.bytes_written);
    
    if(read)
    {   
        connection_closed = posix_demuxer::socket_recv(s, &pb);
    }
    else
    {   
        connection_closed = posix_demuxer::socket_send(s, &pb);
    }
    
    // printf("posthandle wakeup, this: %p, read: %i, len: %i, done %i\n",
    //  this, read, pb.buffer_size, pb.bytes_written);
    // printf("wakeup of %p, closed = %i\n", this, connection_closed);
    
    // wake up: time to process some data
    if(connection_closed || pb.bytes_written == pb.buffer_size)
    {   
        // printf("schedding %p, drv: %p, f: %p\n", this, drv, f);
        //drv->sched(f);
        fw.wake();
        return;
    }
    
    // printf("not schedding %p\n", this); 
    if(demux.add_socket_wakeup(this, read) == -1)
        fprintf(stderr,"failed to re-add_socket_wakeup\n");
}

// asynchronous connect
bool
connect_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    // important: copy down the thread and the driver
  RECORD_THREAD_INFO(fw);

  posix_demuxer*  pd = (posix_demuxer*)&demux;

  // call failed, wake up thread
  if(start(*pd) == -1) return true; 

  // NONONONONO! Referring to this's variables after a successful start
  // gives rise to a race condition, which is bad.
  return false;     // do not reschedule after a successful start
/*
  // I've not seen this yet, don't know why.
  if(socket_err == 0) fprintf(stderr, "WOW, instant CONNECT\n");

  // call didn't fail, could be pending or finished.
  // return socket_err != EINPROGRESS, the contrapositive, sort of
  return socket_err == 0;   // no err => finished immediately
*/
}

void
connect_request::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"connect woke up\n");
  connect_control_block::wakeup(demux);

  // felix thread can pick out error itself.
  fw.wake();
}


// async accept
bool
accept_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    // important: copy down the thread and the driver
  RECORD_THREAD_INFO(fw);

  posix_demuxer*  pd = (posix_demuxer*)&demux;
    return (start(*pd) == -1);      // accept_control_block function
}

void
accept_request::wakeup(posix_demuxer& demux)
{
  // does the leg work.
  accept_control_block::wakeup(demux);

  if(accepted == -1)
  {
    // I don't know if this is a good idea...
    fprintf(stderr, "accept request failed (%i), retrying...\n",
      socket_err);
    // didn't get it - go back to sleep
    if(start(demux) == -1)
      fprintf(stderr, "failed again... probably was a bad idea\n");
    return; 
  }

  fw.wake();
}

// from driver request
bool
flxfileio_request::start_async_op(demux::demuxer& demux, flx_drv* drv, void* f)
{
    // printf("driver called fileio start_async_op code\n");
    // important: copy down the thread and the driver
    RECORD_THREAD_INFO(fw);
    
    // need to create the async io thing here, or ask the driver for it
    // driver needs to go a little less portable
    pflx_drv*   pdrv = (pflx_drv*)drv;
    pdrv->get_aio_worker()->add_fileio_request(this);
    
    return false;       // no wakeup
}

// from async io thread
void
flxfileio_request::finished()
{
    // fprintf(stderr,"async fileio got finished callback\n");
    fw.wake();    // wake thread
}


}}

@h=tangler('faio/faio_winio.hpp')
@select(h)
#ifndef __DWINIO__
#define __DWINIO__
#include <flx_rtl_config.hpp>

// visual studio is quite sensitve about how you do these includes.
// THIS is the way (WinSock2.h must include Windows.h).
#include <WinSock2.h>
#include <MSWSock.h>        // AcceptEx, TF_REUSE_SOCKET, etc

#include "faio_asyncio.hpp" // flx driver requests
#include "demux_overlapped.hpp"   // nicely wrapped async windows calls
    
namespace flx { namespace faio {

// interestingly, because in windows the async objects are associated
// with an IOCP before their use, we don't actually need a demuxer here
// at all. That's kind of nice. (actually iocp_associator uses it now)

// a flx driver request to the add socket s to the drivers iocp
// this is currently the only windows driver request that uses the demuxer.
class FLX_RTL_EXTERN iocp_associator : public flx_driver_request_base {
  SOCKET  s;
public:
  // should have result & errcode
  iocp_associator() {}
  iocp_associator(SOCKET associatee) : s(associatee) {}

  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);
};

// flx <-> c++ stuff for async io (well, it was)

// transition to new windows async control block
class FLX_RTL_EXTERN waio_base : public flx_driver_request_base {
protected:
  thread_wakeup fw;
public:
  bool  success;          // eh?

  waio_base() : success(false) {}

  // actually wakes up thread
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};


// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class FLX_RTL_EXTERN wasync_accept
  : public waio_base, public demux::acceptex_control_block
{
public:
  wasync_accept()   // felix linkage demands it
    : acceptex_control_block(INVALID_SOCKET, INVALID_SOCKET) {}       

  wasync_accept(SOCKET l, SOCKET a) 
    : acceptex_control_block(l, a) {}

  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

class FLX_RTL_EXTERN connect_ex
  : public waio_base, public demux::connectex_control_block
{
public:

  connect_ex()    // flx linkage
    : connectex_control_block(INVALID_SOCKET, NULL, 0) {}

  connect_ex(SOCKET soc, const char* addr, int port)
    : connectex_control_block(soc, addr, port) {}

  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// TransmitFile here (requires file handle)
class FLX_RTL_EXTERN wasync_transmit_file
  : public waio_base, public demux::transmitfile_control_block
{
public:
  wasync_transmit_file() 
    : transmitfile_control_block(INVALID_SOCKET, NULL) {}   // flx linkage

  wasync_transmit_file(SOCKET dst)      // for reuse of socket
    : transmitfile_control_block(dst) {}

  wasync_transmit_file(SOCKET dst, HANDLE src)  // actual transmitfile
    : transmitfile_control_block(dst, src) {}

  // from flx_request_base
  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// handles both WSASend & WSARecv
class FLX_RTL_EXTERN wsa_socketio
  : public waio_base, public demux::wsasocketio_control_block
{
public:
  wsa_socketio()
    : wsasocketio_control_block(INVALID_SOCKET, NULL, 0, false) {}

  wsa_socketio(SOCKET src, void* buf, int len, bool read)
    : wsasocketio_control_block(src, buf, len, read) {}

  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// looks a bit like wsa_socketio (bad name, sends too)
class FLX_RTL_EXTERN winfile_io
  : public waio_base, public demux::winfileio_control_block
{
public:
  winfile_io()      // flx linkage
    : winfileio_control_block(NULL, NULL, 0, false){}
  
  // offset?
  winfile_io(HANDLE f, void* buf, int len, bool read)
    : winfileio_control_block(f, buf, len, read) {}

  virtual bool start_async_op(demux::demuxer& demux, flx_drv* drv, void* f);

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};


}}
#endif  // __DWINIO__

@h=tangler('faio/faio_winio.cpp')
@select(h)
#include "faio_winio.hpp"
#include <stdio.h>      // printf
using namespace flx::demux;
namespace flx { namespace faio {

// way of adding sockets to the IOCP.
bool
iocp_associator::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  iocp_demuxer* iod = (iocp_demuxer*)&demux;
  if(iod->associate_with_iocp((HANDLE)s, 0) != 0)
    fprintf(stderr,"associate request failed - get result here!\n");

  return true;      // wake caller
}

void
waio_base::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  // fprintf(stderr,"general wakeup thing - rescheduling\n");
  //fprintf(stderr,"this: %p, q: %p, f: %p, err: %i\n", this, q, f, err);

  // this tells us when things went wrong (store it)
  if(NO_ERROR != err)
    fprintf(stderr,"catchall wakeup got error: %i (should store it)\n", err);

  success = (NO_ERROR == err);  // this works pretty well
  fw.wake();
}

bool
wasync_accept::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw);   // records enough info for wakeup
  return start_overlapped();
}

void
wasync_accept::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}


bool
connect_ex::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw);   // records enough info for wakeup
  return start_overlapped();
}

void
connect_ex::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}


bool
wasync_transmit_file::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw);   // records enough info for wakeup
  return start_overlapped();
}

void
wasync_transmit_file::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}

bool
wsa_socketio::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw); // records enough info for wakeup
  return start_overlapped();    // start overlapped op
}

// this could be factored into demux... or it might need
// to stay here... this is really a finished that isn't finished
// same goes for winfileio (I think)
void
wsa_socketio::iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  // fprintf(stderr,"wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );

  // keep track of bytes received.
  pb.bytes_written += nbytes;

  // if we're not finished, we have to reinstall our request
  // zero bytes indicates shutdown/closure, right?
  // might be using this for WSASend. Instead of broken pipes on win32, 
  // instead we get WSAECONNRESET (pretty sure) on write. On read?
  if(0 == nbytes || pb.bytes_written == pb.buffer_size)
  {
    // this'll wake us up
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
  }
  else
  {
    // go back around again
    // this returns a finished flag (bad idea). it can also fail.
    // I think it would be better to know that.
    if(start_overlapped())
      fprintf(stderr, "socketio restart finished! WHAT TO DO!?!\n");
  }
}

/*
void
wsa_socketio::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
  LPOVERLAPPED olp, int err)
{
  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}
*/

// file io

bool
winfile_io::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw);   // records enough info for wakeup
  return start_overlapped();  // go
}

// this too could be factored back, I think. that waio_base finished
// would have to change. it's just asking for for some fn to realise
// that it's finished.
// the byte count shouldn't need to be updated here...
void
winfile_io::iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  fprintf(stderr,"winfile_io wakeup, nb: %li, err: %i\n", nbytes, err );

  // fprintf(stderr,"THIS WAKEUP SHOULD BE THE SAME AS SEND/RECV make it so\n");
  // actually, I don't think it should be. the SOCKET stuff goes around
  // the loop again (and ignores errors, check it doesn't hammer).

  // keep track of bytes received.
  pb.bytes_written += nbytes;

  waio_base::iocp_op_finished(nbytes, udat, olp, err);
}

}}


@h=tangler('lib/flx_faio.flx')
@select(h)
#import <flx.flxh>

module Faio {
open C_hack;

proc faio_req[t](x:&t) {
  // svc_general takes an arbitrary machine
  // address as an argument: the _ref_ denotes
  // that address. It does NOT point to an 'address'
  // but to an faio request .. however the svc doesn't
  // know the type of such requests objects .. so we use
  // the type 'address' as a convenient dummy
  val y : &address = reinterpret[&address] x;
  svc (svc_general y);
}

// Faio library bindings
// this file should be portable. it currently defines only a few simple
// driver interactions and copipes. no stream wrappers in here.
    
// get thread self from driver
proc get_thread(thread: ptr[fthread]) {
    svc (svc_get_fthread thread );
}

//header stdlib_h = '#include <stdlib.h>';            // malloc, free
    
// be careful of this being optimized away 
//JS: why? it isn't used .. and its in C_hack anyhow :)
//RF: I'm not seeing it.
fun malloc: int -> address = 'malloc($1)' requires stdlib_h;
proc free: address = 'free($1);' requires stdlib_h; 
    
//header asyncio_h = '#include "faio_asyncio.hpp"';
// could go through and conditionally require this header, but I'm
// not going to right now.
// this pulls in sel_params & demuxers & so on
header = '#include "faio_asyncio.hpp"';

type sel_param = "flx::demux::sel_param";
type sel_param_ptr = "flx::demux::sel_param*";

// this is felix coding at its least subtle
fun to_ptr : sel_param -> sel_param_ptr = '&$1';


fun get_bytes_done : sel_param_ptr -> int = '$1->bytes_written';
proc init_pb : sel_param*address*int
= '{$1.buffer=(char*)$2;$1.buffer_size=$3;$1.bytes_written=0;}';

// this way when I realise that my eof calc is wrong, I can change it
// everywhere at once. so, should exactly n of n bytes read be eof?
// it currently isn't. 
proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)
{
    var bytes_done = pb.bytes_done;
    *eof = (bytes_done != *len);
    *len = bytes_done;
}

// this is a no-op hack to make it look like the argument t
// is actually being used. useful for a few hairy svc/gc interactions
proc gc_collect_me_not_hack[t]: t = ';';

// copipe interface.

// copipes are actually implemented as end_point_a <= pipe => end_point_b
// felix only needs to know about endpoints, which we'll call pipes.
type copipe = 'flx::faio::copipe_endpt*';

// private calls
proc connect : copipe*fthread*sel_param*bool
 = '$1->pipe->connect((void*)$2, &$3, $4, $1->get_channel($4));';
fun pipe_request : copipe -> address = '$1->pipe';
fun to_ptr : copipe -> address = '$1';      // easier than cast
proc priv_shutdown : copipe*int = '$1->shutdown($2);';
proc priv_delete : copipe = 'delete $1;';

// this is awful but I don't know how to interact with flx ptrs
// via the c interface. YUK!
//JS: check out C_hack and _ref_ in the rtl
header 'typedef struct{ flx::faio::copipe_endpt* foo[2]; }sorry_awful;';
type co_awful = 'sorry_awful';
proc init_awful_pair : co_awful = 'flx::faio::copipe_endpt::pipe_pair($1.foo);';
fun get : co_awful*int -> copipe = '$1.foo[$2]';

proc flx_copipe_pair(p1: &copipe, p2: &copipe)
{   
    var awful: co_awful;
    init_awful_pair(awful);
    *p1 = get(awful, 0);
    *p2 = get(awful, 1);
}

// not for public consumption
//JS -- then make it private
// the c++ copipe code figures out what you wanted from the pipe itself.
private proc copipe_driver_request(pipe: copipe)
{   
    var request = pipe_request pipe;
    faio_req$ &request;
}

proc co_rw(pipe: copipe, len: &int, buf: address, eof: &bool, read_flag: bool)
{
    // Suppose I could move this to start_async_op, it knows the thread, but
    // not whether it's reading or writing
    var thread : fthread;
    get_thread(addr thread);                    // ask driver for thread pointer
    
    var pb: sel_param;
    init_pb(pb, buf, *len);
    
    // connect thread to its apropriate read/write channel
    connect(pipe, thread, pb, read_flag);
    
    copipe_driver_request(pipe);
    
    calc_eof(to_ptr(pb), len, eof);
}

// public copipe calls

// shutdown pipe endpoint. no matter what how is, pipe must still be closed
// how = 0 => no more reads, 1 no more writes, 2 no more anything
proc co_shutdown(pipe: copipe, how: int)
{   
    priv_shutdown(pipe, how);
    // let pipe request be evaluated
    copipe_driver_request(pipe);
}

proc co_close(pipe: copipe)
{   
    co_shutdown(pipe, 2);                   // no more io, eof those waiting
    priv_delete(pipe);
    // the end!
}

proc co_read(pipe: copipe, len: &int, buf: address, eof: &bool)
{   
    co_rw(pipe, len, buf, eof, true);       // read
}

proc co_write(pipe: copipe, len: &int, buf: address, eof: &bool)
{   
    co_rw(pipe, len, buf, eof, false);      // read
}

// sleep! finally!

type sleep_request = 'flx::faio::sleep_request';
fun mk_sleep_request: double -> sleep_request = 'flx::faio::sleep_request($1)';

proc sleep(delta: double)
{
  var sr = mk_sleep_request delta;
  faio_req$ &sr;
}


} // module faio

@h=tangler('lib/flx_faio_posix.flx')
@select(h)
#import <flx.flxh>
// contains posix async socket io & copipes, all wrapped up streams
header faio_posixio_hpp = '#include "faio_posixio.hpp"';

include "flx_faio";
module Faio_posix  {
open C_hack;        // cast, address
open Faio;

// some random stuff, sorta unixy
header unistd_h = '#include <unistd.h>';            // close
header fcntl_h = '#include <fcntl.h>';              // fcntl for O_NONBLOCK
header sys_socket_h = '#include <sys/socket.h>';    // shutdown
header sockety_h = '#include "demux_sockety.hpp"';  // my socket utils

proc close: int = 'close($1);' requires unistd_h;
proc shutdown: int*int = 'shutdown($a);' requires sys_socket_h;

// this too can be optimised away to nothing
// mucking around with pushing file fd through the async socket code
fun aio_ropen: charp -> int = 'open($1, O_RDONLY | O_NONBLOCK, 0)'
    requires fcntl_h;

// blocking, read only
fun ropen: charp -> int = 'open($1, O_RDONLY, 0)' requires fcntl_h;


header = '#include "faio_posixio.hpp"';

// socketio_request should be renamed to be async_fd_request
type socketio_request = "flx::faio::socketio_request";

fun mk_socketio_request: int*address*int*bool -> socketio_request
    = 'flx::faio::socketio_request($1, (char*)$2, $3, $4)';

fun get_pb: socketio_request -> sel_param_ptr = '&$1.sv.pb';

// read & write differ only by a flag
proc async_rw(fd: int, len: &int, buf: address, eof: &bool, read_flag: bool)
{
    var asyncb = mk_socketio_request(fd, buf, *len, read_flag);

    // magic! (break to driver, wake up when it's all over)
    faio_req$ &asyncb;

    calc_eof(asyncb.pb, len, eof);
}

proc async_read(fd: int, len: &int, buf: address,
    eof: &bool)
{   
    async_rw(fd, len, buf, eof, true);      // read
}

proc async_write(fd: int, len: &int, buf: address, eof: &bool)
{   
    async_rw(fd, len, buf, eof, false);     // write
}

type flxfileio_request = "flx::faio::flxfileio_request";

// offset ? let it be for a moment
fun mk_faio: int*address*int*int*bool -> flxfileio_request
    = 'flx::faio::flxfileio_request($1, (char*)$2, $3, $4, $5)';
fun get_pb: flxfileio_request -> sel_param_ptr = '&$1.pb';

proc faio_rw(fd: int, len: &int, buf: address, eof: &bool, read_flag: bool)
{   
    // constant offset for now, rushing to get this in flx_stream
    var faio = mk_faio(fd, buf, *len, 0, read_flag);
    faio_req$ &faio;
    calc_eof(faio.pb, len, eof);
}

proc faio_read(fd: int, len: &int, buf: address,
    eof: &bool)
{   
    faio_rw(fd, len, buf, eof, true);       // read
}

proc faio_write(fd: int, len: &int, buf: address, eof: &bool)
{   
    faio_rw(fd, len, buf, eof, false);      // write
}

// connect!
type async_connect = 'flx::faio::connect_request';

fun mk_async_connect: charp*int -> async_connect = 'flx::faio::connect_request($a)';
fun get_socket: async_connect -> int = '$1.s';

// could do multi connects for capable drivers
proc connect(s: &int, addr: charp, port: int)
{   
    var ac = mk_async_connect(addr, port);
    faio_req$ &ac;
    *s = ac.socket;
}

type accept_request = "flx::faio::accept_request";

fun mk_accept: int -> accept_request = 'flx::faio::accept_request($1)';
fun get_socket: accept_request -> int = '$1.accepted';

// arg1 = returned socket, arg2 is port, pass 0 to have one assigned
proc mk_listener: lvalue[int]*lvalue[int]*int
    = '$1 = flx::demux::create_async_listener(&$2, $3);' requires sockety_h;

proc accept(s: &int, listener: int)
{   
    var acc = mk_accept listener ;
    faio_req$ &acc;
    *s = acc.socket;
}



} // module faio

@h=tangler('lib/flx_faio_win32.flx')
@select(h)
#import <flx.flxh>
include "flx_faio";     // defines copipes & some driver interaction

module Faio_win32 {
// contains windows overlapped/iocp io & copipes. no stream wrapper yet.
open C_hack;
open Faio;
header '#include "faio_winio.hpp"'; // this has everything (includes asyncio.h)


ctypes SOCKET;

// maybe don't use this - let the socket be passed in already associated
// with an IOCP. do I have to make this explicitly overlapped? If we
// want async io I think I'll need to associate this with the iocp.
fun cmk_socket : unit -> SOCKET = '::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)';

// well that didn't help.
//fun cmk_socket : unit -> SOCKET = 'WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED)';
// must associate with iocp to do overlapped io with s (WSASend/Recv)
proc mk_socket(s: &SOCKET)
{
    *s = cmk_socket();
    associate_with_iocp(*s);                // associate with iocp (errors?).
}


type wasync_accept = "flx::faio::wasync_accept";

fun mk_accept: SOCKET*SOCKET -> wasync_accept = 'flx::faio::wasync_accept($a)';
// make this a parameterised type
fun get_success[t]: t -> bool = '$1.success';

// this feels silly
const INVALID_SOCKET: SOCKET = 'INVALID_SOCKET';
// oops, no good if we can't check against it
fun eq : SOCKET*SOCKET -> bool = '($1 == $2)';

// windows style accept. accepted is an already created socket, unbound
proc Accept(success: &bool, listener: SOCKET, accepted: SOCKET)
{
    var acc = mk_accept(listener, accepted);

    faio_req$ &acc;    // causes AcceptEx to be called

    *success = get_success(acc);
}

type connect_ex="flx::faio::connect_ex";
fun mk_connect_ex: SOCKET*charp*int -> connect_ex = 'flx::faio::connect_ex($a)';

// for use on sockets you make yourself, who knows, maybe you want to
// reuse them
proc Connect(success: &bool, s: SOCKET, addr: charp, port: int)
{   
    var con = mk_connect_ex(s, addr, port);  
     faio_req$ &con;    // causes ConnectEx to be called
    *success = get_success(con);
}

proc Connect(s: &SOCKET, addr: charp, port: int)
{   
    mk_socket s;            // error handling?
    var success: bool;
    Connect(&success, *s, addr, port);
    // print "CONNECT success: "; print success; endl;
    // error handling?
}

// listens on all interfaces, I guess
proc cmk_listener: lvalue[SOCKET]*lvalue[int]*int
    = '$1 = flx::demux::create_listener_socket(&$2, $3);';

proc mk_listener(listener: &SOCKET, port: &int, backlog: int)
{   
    *listener <- cmk_listener(*port, backlog);
    associate_with_iocp(*listener);
}

// ignores return value
proc closesocket: SOCKET = 'closesocket($1);';

const SD_RECEIVE:int = 'SD_RECEIVE';
const SD_SEND:int = 'SD_SEND';
const SD_BOTH:int = 'SD_BOTH';

proc shutdown: SOCKET*int = 'shutdown($1, $2);';

type wasync_transmit_file = "flx::faio::wasync_transmit_file";

// I could just use HANDLEs everywhere, but I want to see how this goes
type WFILE = 'HANDLE';

// hacked for ro atm. the 0 means exclusive (not good, but I haven't deciphered
// the flags yet. NULL for non inheritable security attributes.
// OPEN_EXISTING is to make sure it doesn't create the file
// Geez, FILE_ATTRIBUTE_NORMAL? not hidden, not temp, etc. 
// final NULL is for template file. not sure what it does, but I don't want it.
// notice that it's opened for SHARED reading
proc OpenFile: lvalue[WFILE]*string =
  '$1 = CreateFile($2.c_str(), FILE_READ_DATA, FILE_SHARE_READ, NULL,\
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);';

// error handling?
proc CloseFile: WFILE = 'CloseHandle($1);';

fun mk_transmit_file : SOCKET*WFILE -> wasync_transmit_file
    = 'flx::faio::wasync_transmit_file($a)';

// toylike interface for now, but still fun
proc TransmitFile(s: SOCKET, f: WFILE)
{   
    var tf = mk_transmit_file(s, f); 
    faio_req$ &tf;
}

// by passing special flags to TransmitFile we can transform a connected
// socket into a socket ready for use with AcceptEx. DisconnectEx explicitly
// does this and without the warning that accept-style & connect-style sockets
// cannot be reused as the other type (which isn't a problem for my use)
// however I already have TransmitFile code in place.
fun mk_reuse_socket : SOCKET -> wasync_transmit_file
    = 'flx::faio::wasync_transmit_file($a)';

proc ReuseSocket(s: SOCKET)
{   
    var tf = mk_reuse_socket(s);
    faio_req$ &tf;
}

type wsa_socketio = "flx::faio::wsa_socketio";
fun mk_wsa_socketio: SOCKET*address*int*bool->wsa_socketio = 'flx::faio::wsa_socketio($a)';
fun get_pb[t]: t -> sel_param_ptr = '&$1.pb';

proc WSARecv(s: SOCKET, len: &int, buf: address, eof: &bool)
{   
    var rev = mk_wsa_socketio(s, buf, *len, true);  // reading
    faio_req$ &rev;
// we do have a success flag
    calc_eof(rev.pb, len, eof);
}

proc WSASend(s: SOCKET, len: &int, buf: address, eof: &bool)
{   
    var rev = mk_wsa_socketio(s, buf, *len, false); // writing
    faio_req$ &rev;
    calc_eof(rev.pb, len, eof);
}

type winfile_io = "flx::faio::winfile_io";

fun mk_winfile_io: WFILE*address*int*bool->winfile_io = 'flx::faio::winfile_io($a)';

// no offset - just for streams now. write probably doesn't work

proc ReadFile(f: WFILE, len: &int, buf: address, eof: &bool)
{   
    var io = mk_winfile_io(f, buf, *len, true); // reading
    faio_req$ &io;
// we do have a success flag
    calc_eof(io.pb, len, eof);
}

proc WriteFile(f: WFILE, len: &int, buf: address, eof: &bool)
{
    var io = mk_winfile_io(f, buf, *len, false);    // writing
    faio_req$ &io;
    calc_eof(io.pb, len, eof);
}


// general request for addition of socket to iocp. might be better to
// just create them that way.
type iocp_associator = "flx::faio::iocp_associator";
fun mk_iocp_associator: SOCKET -> iocp_associator = 'flx::faio::iocp_associator($1)';

proc associate_with_iocp(s: SOCKET)
{
    // results? err code?
    var req = mk_iocp_associator(s);
    faio_req$ &req;
}

} // module win32_faio

@h = tangler("lib/flx_stream.flx")
@select(h)
include "flx_faio";
include "flx_faio_posix";
include "flx_faio_win32";
#import <flx_platform.flxh>

open Faio;  // copipes

#if POSIX
open Faio_posix;
#endif

#if WIN32
open Faio_win32;
#endif


module Flx_stream {
//JS: the type name should be flx_stream_t by convention ..
union flx_stream =
    | CO of copipe     // copipe
    | DEVNULL          // nothing
#if POSIX
    | UFD of int       // Unix file
    | USOCK of int     // Unix socket
#endif
// isn't this covered by the fact that under cygwin POSIX AND WIN32 are true?
//#if WIN32 or CYWGIN
#if WIN32
    | WSOCK of SOCKET  // Windows socket
    | WFD of WFILE     // Windows file
#endif

// MISSING CASES: strstreams  -- strings as streams
// FILE* streams, C++ iostreams as streams. kind of messy ..

;



// will be ambiguous for file fd, will need name. do I even need these
// when the conversion is unambiguous?

//JS: use the constructor, no need for a separate
//JS: function to make things, that's what
//JS: type constructors are for .. maybe the names
//JS: should be changed to FLX_STRM_UFD or something ..

//fun to_stream (p: copipe): flx_stream = { return CO p; }
//fun new_devnull (): flx_stream = { return DEVNULL; }
//fun file_to_stream (fd: int): flx_stream = { return UFD fd; }
//fun to_stream (fd: int): flx_stream = { return USOCK fd; }
//fun to_stream (f: WFILE): flx_stream = { return WFD f; }
//fun to_stream (s: SOCKET): flx_stream = { return WSOCK s; }

proc flx_read(strm: flx_stream, len: &int, buf: address, eof: &bool)
{
    match strm with
    | CO ?pipe => { co_read(pipe, len, buf, eof); }
    | DEVNULL => { *len = 0; *eof = true; }
#if POSIX
    | USOCK ?fd => { async_read(fd, len, buf, eof); }
    | UFD ?fd => { faio_read(fd, len, buf, eof); }
#endif
//#if WIN32 or CYGWIN
#if WIN32
    | WSOCK ?s => { WSARecv(s, len, buf, eof); }
    | WFD ?file => { ReadFile(file, len, buf, eof); }
#endif
    endmatch;
}

proc flx_write(strm: flx_stream, len: &int, buf: address, eof: &bool)
{   
    match strm with 
    | CO ?pipe => { co_write(pipe, len, buf, eof); }
    | DEVNULL => { /* nothing to do */ }
#if POSIX
    | USOCK ?fd => { async_write(fd, len, buf, eof); }
    | UFD ?fd => { faio_write(fd, len, buf, eof); }
#endif
//#if WIN32 or CYGWIN
#if WIN32
    | WSOCK ?s => { WSASend(s, len, buf, eof); }
    | WFD ?file => { WriteFile(file, len, buf, eof); }
#endif
    endmatch;
}

proc flx_shutdown(strm: flx_stream, how: int)
{
    match strm with
    | CO ?pipe => { co_shutdown(pipe, how); }
    | DEVNULL => { /* nothing to do? */ }
#if POSIX
    | USOCK ?socket => { shutdown(socket, how); }
    | UFD => { /* nuthin */ }
#endif
//#if WIN32 or CYGWIN
#if WIN32
    | WFD => { /* nothing to do */ }
    | WSOCK ?socket => { shutdown(socket, how); }
#endif
    endmatch;
}

proc flx_close(strm: flx_stream)
{
    match strm with
    | CO ?pipe => { co_close(pipe); }
    | DEVNULL => { /* nothing to do */ }
#if POSIX
    | USOCK ?socket => { close(socket); }    // error check?
    | UFD ?fd => { close(fd); }          // error check?
#endif
//#if WIN32 or CYGWIN
#if WIN32
    | WSOCK ?socket => { closesocket(socket); }
    | WFD ?file => { CloseFile(file); }
#endif    
    endmatch;
}

proc flx_popen(ourend: &flx_stream, p:flx_stream->0)
{   
    var a: copipe;
    var b: copipe;
    
    flx_copipe_pair(&a, &b);
    *ourend = CO a;
    var theirend = CO b;
    spawn_fthread { p theirend; };
}


//#if WIN32 or CYGWIN
#if WIN32
proc flx_connect_win32(strm: &flx_stream, addr: charp, port: int)
{   
    var s: SOCKET;
    Connect( &s, addr, port );
    // nice error handling
    *strm = to_stream s;
}
#endif

#if POSIX
proc flx_connect_posix(strm: &flx_stream, addr: charp, port: int)
{   
    var s: int;
    connect( &s, addr, port );
    // nice error handling
    *strm = USOCK s;
}
#endif

// unified name, ipv4, cygwin gets posix (?)
proc flx_connect(strm: &flx_stream, addr: charp, port: int)
{
#if WIN32
    flx_connect_win32(strm, addr, port);
#else
    flx_connect_posix(strm, addr, port);
#endif
}

// fun things that probably need renaming
proc cat(infd: flx_stream, outfd: flx_stream, buf: address, bufsize: int) {
    var eof = false;
    var weof = false;
    var len: int;

    // if we finish input, stop. if output eofs, don't keep hammering on it!
    while{not(eof) and not(weof)} {
        len = bufsize;
// print "catting in "; print len; print " bytes\n";
        flx_read(infd, &len, buf, &eof);
// print "catting out "; print len; print " bytes\n";
        flx_write(outfd, &len, buf, &weof);
    };
};

proc cat(infd: flx_stream, outfd: flx_stream)
{
    val BUFSIZE = 10*1024;
    var buf = malloc(BUFSIZE);

    // that's some nice error checking
    cat(infd, outfd, buf, BUFSIZE);
    free(buf);
}

open List;

// if these are all file descriptors, one might not like to have them
// all open at once. would a generator be better?
// could make this supercat, with multiple in, multiple out (multiout
// in the sense of tee)
proc cat(in_fds: list[flx_stream], outfd: flx_stream,
    buf: address, bufsize: int)
{
    match in_fds with
    | Empty[flx_stream] => {}               // finished
    | Cons[flx_stream] (?fd, ?l) =>
        {
            cat(fd, outfd, buf, bufsize);   // cat first
            cat(l, outfd, buf, bufsize);    // cat the rest
        }
    endmatch
    ;
}

// try the stream interface
proc echo(fd: flx_stream, buf: address, bufsize: int)
{
    // echo a = cat a a. that's deep, man.
    cat(fd, fd, buf, bufsize);
};

// playing around. need to be able to control io buffers in a more
// global way. I like the supercat idea. need to be careful not to hammer
// multiple outputs. move tee to own file
proc tee(infd: flx_stream, outfd: flx_stream, outfd2: flx_stream)
{
    var eof = false;
    var weof = false;
    var weof2 = false;
    var len: int;

    val BUFSIZE = 10*1024;
    var buf = malloc(BUFSIZE);

    // don't hammer!
    while{not(eof) and not(weof) and not(weof2)} {
        len = BUFSIZE;
        flx_read(infd, &len, buf, &eof);
        flx_write(outfd, &len, buf, &weof);
        flx_write(outfd2, &len, buf, &weof2);
    };
    free buf;
}


} // module Flx_Stream

