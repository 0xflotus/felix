@head(1,"Faio")
Asynch I/O interface pack.
@execfile('config'+os.sep+'config.py')

@h=tangler('faio/faio_asyncio.hpp')
@select(h)
#ifndef __ASYNCIO__
#define __ASYNCIO__
#include <flx_rtl_config.hpp>

// this file acts as go-between for my asynchronous interface for felix
// programmes. 

// portable. Not that asynchronous.
    
#include "demux_demuxer.hpp"        // sel_param, demuxer base
#include "faio_drv.hpp"
    
class FLX_RTL_EXTERN flx_driver_request_base {
public:
    virtual ~flx_driver_request_base() {}       // so destructors work
    // returns finished flag (async may fail or immediately finish)
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f) = 0;
};  
    
// not actually asynchronous as such since the threads are woken synchronously
// definitely portable. look out for this shared structure when flx threads
// are run pre-emptively. start_async_op will need to be serialised.
class FLX_RTL_EXTERN async_copipe : public flx_driver_request_base {
public:
    enum { WINDWARD, LEEWARD, NUM_CHANNELS };
    
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
    void connect(void* f, sel_param* pb, bool reading, int channel);
    void close_channel(int which);      // WINDWARD or LEEWARD
    void disconnect();                  // will be used by close
    
    static async_copipe* create_copipe() { return new async_copipe; }
    bool debug;
    void set_debug(bool);

private: 
    enum { READER, WRITER, NUM_CNXNS };
    
    // if there's a thread here, it's sleeping
    void*   thread[NUM_CNXNS];
    sel_param*  pb[NUM_CNXNS];
    int         num_users;
    
    bool        channel_open[NUM_CHANNELS];
    int         current_channel;
    void wake_thread(int n, flx_drv* drv);
    void wake_all_threads(flx_drv* drv);
    
    async_copipe();                     // to control alloc/dealloc
};

class FLX_RTL_EXTERN copipe_endpt {
    int             read_channel;       // the channel this endpt reads on
    
    copipe_endpt(async_copipe* p, int rchan) : 
      read_channel(rchan), pipe(p), debug(false)
    {}

public:
    async_copipe*   pipe;               // endpt's copy (flx accessible)
    
    // 0 = no reads, 1 = no writes, 2 = no nothing (! = close, however)
    void shutdown(int how);
    int get_channel(bool reading);
    bool debug; 
    void set_debug(bool d) { debug = d; }

    ~copipe_endpt() { pipe->disconnect(); } 
    static void pipe_pair(copipe_endpt* pair[2]);
};

#endif  // __ASYNCIO__

@h=tangler('faio/faio_asyncio.cpp')
@select(h)
#include "faio_asyncio.hpp"
#include <string.h>     // memmove
#include <stdio.h>      // debugging

// cooperative pipes

// this is a bit interesting because the copipes are not asynchronous and
// their work is actually all done in this function (once both ends have
// read & written)

void
async_copipe::set_debug(bool d) { debug = d; }

bool
async_copipe::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
// this is where a big lock will go for multithreaded driver
    // we don't want to wake anyone twice
    bool wake_caller = (f != thread[READER] && f != thread[WRITER]);

    // no channel => shutdown was called with no-one reading or writing
    if(-1 == current_channel)
        return true;                // wake caller

    // we may have one reader/writer (or even 2 with a multithreaded driver)
    if(!channel_open[current_channel])
    {
        wake_all_threads(drv);
        current_channel = -1;       // channel now undefined
        return wake_caller;
    }
    // channel closed situations handled

    // if we don't have both endpts, then the op isn't finished
    if(!(thread[READER] && thread[WRITER])) return wake_caller;
    
    // we have both ends. one or both must wake after this
if(wake_caller) fprintf(stderr,"we should never have a 3rd party here!\n");
    
    // move data from writer to reader
    long    len;
    long    nb1 = pb[READER]->buffer_size-pb[READER]->bytes_written;
    long    nb2 = pb[WRITER]->buffer_size-pb[WRITER]->bytes_written;
    
    // min(read bytes, write bytes)
    len = (nb1 < nb2) ? nb1 : nb2;
    
    // write buf -> read buf
    memmove(pb[READER]->buffer + pb[READER]->bytes_written,
        pb[WRITER]->buffer + pb[WRITER]->bytes_written, len);
    pb[READER]->bytes_written += len;
    pb[WRITER]->bytes_written += len;
    
    // I could let the driver wake one of the threads, but it makes for
    // easier reading if I do it myself:
    int     num_woken = 0;
    for(int i = 0; i < NUM_CNXNS; i++)
    {   
        // wake up!
        if(pb[i]->bytes_written == pb[i]->buffer_size)
        {   
            wake_thread(i, drv);
            num_woken++;
        }
    }
    
    if(num_woken == NUM_CNXNS)  // everyone woke up
        current_channel = -1;   // channel now undefined
    
    // we're doing our own waking, so just say no, it isn't finished.
    // not strictly honest, is it? driver waking is kind of lame anyway.
    // it's our job.
    return false;
}

void
async_copipe::wake_thread(int n, flx_drv* drv)
{   
    drv->sched(thread[n]);  
    thread[n] = 0;          // not ours anymore
}

void
async_copipe::wake_all_threads(flx_drv* drv)
{   
    for(int i = 0; i < NUM_CNXNS; i++)
    {   
        if(thread[i]) wake_thread(i, drv);
    }
}

async_copipe::async_copipe() : debug(false) 
{
    thread[READER] = 0;
    thread[WRITER] = 0;
    channel_open[WINDWARD] = true;  // both channels open = duplex io
    channel_open[LEEWARD] = true;   
    current_channel = -1;           // current channel undefined
    num_users = 2;                  // we delete this after 2 disconnects
}

// this requires a driver request to make anything actually happen
void
async_copipe::close_channel(int which)
{   
    // this should wake up the threads, but I don't have the queue.
    // my choice is for the felix code to do an async op on this and
    // re-evaluate, waking as necessary or hang on to the queue
    channel_open[which] = false;
}

void
async_copipe::disconnect()
{   
    if(debug)fprintf(stderr,"num_users before disconnect: %i\n", num_users);
    if(--num_users == 0)
    {   
        if(debug)fprintf(stderr,"deleting this!\n");
        delete this;
    }
}

void
async_copipe::connect(void* f, sel_param* inpb, bool reading, int channel)
{
    int i = (reading) ? READER : WRITER;

    if(-1 == current_channel)
    {
        current_channel = channel;
    }
    else if(current_channel != channel) // channel must agree if already chosen
    {
        if(debug)fprintf(stderr,"conflicting channels! make sure this causes a wake up!\n");
        current_channel = -1;           // causes this thread to wake up
        return;
    }
        
    // there shouldn't be anything already there
    if(f && thread[i]) 
        if(debug)fprintf(stderr,"copipe conflict! results undefined!\n");
    
    thread[i] = f;
    pb[i] = inpb;
}

// copipe endpoints, just like socketpair. static.
void
copipe_endpt::pipe_pair(copipe_endpt* pair[2])
{
//fprintf(stderr,"this will leak if one fails, you buffoon!\n");
// can just delete in that case. eh.
    async_copipe* p = async_copipe::create_copipe();
    // initialize with pipe and the channel they'll read on.
    pair[0] = new copipe_endpt(p, async_copipe::WINDWARD);
    pair[1] = new copipe_endpt(p, async_copipe::LEEWARD);
}

int
copipe_endpt::get_channel(bool reading)
{   
    if(reading) return read_channel;
    
    return (read_channel == async_copipe::WINDWARD) ?
            async_copipe::LEEWARD : async_copipe::WINDWARD;
}

// this requires a driver request to make anything actually happen
void
copipe_endpt::shutdown(int how)
{   
    int write_channel = get_channel(false);
    
    switch(how)
    {   
        case 0:
            // no further reads, shut read channel
            pipe->close_channel(read_channel);
        break;
        case 1:
            pipe->close_channel(write_channel);
        break;
        case 2:
            // shut both channels, regardless
            pipe->close_channel(async_copipe::WINDWARD);
            pipe->close_channel(async_copipe::LEEWARD);
        break;
    }
}


@h=tangler('faio/faio_drv.hpp')
@select(h)
#ifndef __FLXDRV__
#define __FLXDRV__
#include <flx_rtl_config.hpp>

#include "demux_sleep_queue.hpp"
#include "demux_demuxer.hpp"

// vestigal driver class is all that remains of the embedded driver from
// which faio came. all it is now is a pointer to a queue. 
// watch this space.
class FLX_RTL_EXTERN flx_drv {
    sleep_queue&    ready_queue;
public:
    flx_drv(sleep_queue& q);
    virtual ~flx_drv();

    void sched(void* f);
};

#endif              //__FLXDRV__


@h=tangler('faio/faio_drv.cpp')
@select(h)
#include <stdio.h>              // debug printf
#include "faio_drv.hpp"

flx_drv::flx_drv(sleep_queue& q)
    : ready_queue(q)
{   
}

flx_drv::~flx_drv()
{   
}

void
flx_drv::sched(void* f)
{   
    ready_queue.enqueue(f);
}


@h=tangler('faio/faio_pdrv.hpp')
@select(h)
#ifndef __FAIO_PDRV__
#define __FAIO_PDRV__

#include <flx_rtl_config.hpp>
#include "demux_pfileio.hpp"
#include "demux_sleep_task.hpp"
#include "faio_drv.hpp"

// same as flx_drv, but with an async file io worker fifo.
class FLX_RTL_EXTERN pflx_drv : public flx_drv {
    // this will be called asynchronously, so better be careful
//  pasync_fileio*  file_aio_worker;
    // make it direct so we don't have to protect the code that would
    // create the pointer. This is a bit heavy, I would prefer on demand.
    pasync_fileio       file_aio_worker;
    sleep_task_queue    sleepers;
public:
    pflx_drv(sleep_queue& q);

    pasync_fileio* get_aio_worker() { return &file_aio_worker; }
    sleep_task_queue* get_sleepers() { return &sleepers; }
    bool debug;
    void set_debug(bool d) { debug = d; }
};
#endif

@h=tangler('faio/faio_pdrv.cpp')
@select(h)
#include "faio_pdrv.hpp"
#include <signal.h>     // for SIGPIPE portable ignoring
#include <stdio.h>      // printf

pflx_drv::pflx_drv(sleep_queue& q)
    : flx_drv(q)
{
    // we might actually like to ignore SIGPIPE's conditionally,
    // e.g. when a flx prog actually requests socket io, we could even
    // transform it into a flx level signal (if those exist, signals are
    // pretty lame & don't work well for library code - would you want them
    // to exist?) (osx has a per socket sockopt that does this, linux has
    // the send flag MSG_NOSIGNAL)

    // this is actually demux/flxasync io's problem, so shift it there
    if(debug)fprintf(stderr,"pdrv installing SIGPIPE ignorer\n");
    if(debug)fprintf(stderr,"OSX/bsd only: setsockopt(SO_NOSIGPIPE) -> EPIPE\n");
    // sig_t   prev_handler;
    void (*prev_handler)(int);  // solaris is FUN.
    prev_handler = signal(SIGPIPE, SIG_IGN);

    if(prev_handler)
        fprintf(stderr,"warning: blew away prev SIGPIPE handler: %p\n", prev_handler);
}

@h=tangler('faio/faio_posixio.hpp')
@select(h)
#ifndef __FAIO_POSIXIO__
#define __FAIO_POSIXIO__
#include <flx_rtl_config.hpp>

#include "faio_asyncio.hpp"
#include "faio_drv.hpp" 

// we don't need to piggyback much data at all. for now just the demuxer,
// so that we can be woken up, and the buffer info (this replaces the
// felix "socket" thread type, which was ugly.

#include "demux_posix_demuxer.hpp" 

// a new sort of demuxer/event source: file io completions
// haven't given up on using the socket style demuxers yet.
#include "demux_pfileio.hpp"

// a sleep prioqueue
#include "demux_sleep_task.hpp"

// this becomes socket thread wakeup. um. 
// class thread_wakeup : public socket_wakeup {
class FLX_RTL_EXTERN thread_wakeup {
public:
    void wake() { drv->sched(f); }

    void*       f;          // thread to be woken
    flx_drv*    drv;        // in which driver
};

    
class FLX_RTL_EXTERN socketio_wakeup : public socket_wakeup {
public:
    sel_param       pb;         // in: what you want, out: what you get
    thread_wakeup   fw; 
    bool        read;

    virtual void wakeup(posix_demuxer& demux);
};

// this can handle most unix style io, that is, read & write on sockets,
// files & pipes. NICE. the fact that the socket is now in here may mean
// I can get rid of the epoll hack
// Not sure if this can be used for file fds.
class FLX_RTL_EXTERN socketio_request : public flx_driver_request_base {
public:
    socketio_wakeup sv;
    
    socketio_request() {}       // Lord Felix demands it. Like STL.
    
    socketio_request(int s, char* buf, long len, bool r);
    virtual bool start_async_op(demuxer& demux, flx_drv* drv,  void* f);
};

// move wakeup to thread_wakeup and get rid of class altogether
class FLX_RTL_EXTERN connect_wakeup : public socketio_wakeup {
public:
    int     socket_err;     // the error, if s == -1
    virtual void wakeup(posix_demuxer& demux);
};


class FLX_RTL_EXTERN connect_request : public flx_driver_request_base {
    const char*     addy;
    int             p;
public:
    connect_wakeup  sv;

    connect_request() {}            // flx linkage

    connect_request(const char* addr, int port) : addy(addr), p(port) { sv.s=-1; }
    virtual bool start_async_op(demuxer& demux, flx_drv* drv,  void* f);
};

class FLX_RTL_EXTERN accept_wakeup : public socketio_wakeup {
public:
    int     acceptee;       // listener socket
    int     socket_err;     // the error, if acceptee == -1
    virtual void wakeup(posix_demuxer& demux);
};

class FLX_RTL_EXTERN accept_request : public flx_driver_request_base {
public:
    // we sometimes know that there'll be several connections to accept.
    // this'll need a different wakeup - and a different interface between
    // event source & wakeups
    accept_wakeup   sv;     // could use connect wakeup...

    accept_request() {} // flx linkage

    // note that the listener is the s socket
    accept_request(int listener) {sv.s = listener; sv.acceptee = -1; }
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
};


// separate pthread file io
// hum. multiple inheritance
class FLX_RTL_EXTERN flxfileio_request
    : public flx_driver_request_base, public fileio_request
{
    thread_wakeup   fw;
public:
    flxfileio_request() {}          // flx linkage

    flxfileio_request(int f, char* buf, long len, long off, bool rd)
        : fileio_request(f, buf, len, off, rd) {}

    // from driver request
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);

    // from async io thread
    virtual void finished();
};

// sleeping
class FLX_RTL_EXTERN sleep_request
    : public flx_driver_request_base, public sleep_task
{
    thread_wakeup   fw;
    double          delta;
public:
    sleep_request() {}              // flx linkage

    sleep_request(double d) : delta(d) {}

    // from driver request
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);

    // from sleep_task
    virtual void fire();
};

#endif

@h=tangler('faio/faio_posixio.cpp')
@select(h)
#include <stdio.h>      // printf
#include "faio_posixio.hpp"
#include "demux_sockety.hpp"    // async_connect

// pthread async file io stuff
#include "faio_pdrv.hpp"


#include <sys/types.h>  // getsockopt & co
#include <sys/socket.h>

#include <unistd.h>     // close
#include <string.h>     // strerror - probably not portable

socketio_request::socketio_request(int s, char* buf, long len, bool r)
{
    sv.s = s;
    sv.read = r;

    sv.pb.buffer = buf;
    sv.pb.buffer_size = len;
    sv.pb.bytes_written = 0;        // really bytes_processed
}

bool
socketio_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    // printf("adding wakeup: len %i, done %i\n",
    //   sv.pb.buffer_size, sv.pb.bytes_written);

    // important: copy down the thread and the driver
    sv.fw.drv = drv;
    sv.fw.f = f;

    posix_demuxer*  pd = (posix_demuxer*)&demux;

    // wake thread if call failed
    return (pd->add_socket_wakeup(&sv, sv.read) == -1);
}


void
socketio_wakeup::wakeup(posix_demuxer& demux)
{
    // handle read/write, return true if not finished.
    // otherwise wakeup return false.
    bool    connection_closed;

    // printf("prehandle wakeup, this: %p, read: %i, len: %i, done %i\n",
    //  this, read, pb.buffer_size, pb.bytes_written);
    
    if(read)
    {   
        connection_closed = posix_demuxer::handle_socket_read(s, &pb);
    }
    else
    {   
        connection_closed = posix_demuxer::handle_socket_write(s, &pb);
    }
    
    // printf("posthandle wakeup, this: %p, read: %i, len: %i, done %i\n",
    //  this, read, pb.buffer_size, pb.bytes_written);
    // printf("wakeup of %p, closed = %i\n", this, connection_closed);
    
    // wake up: time to process some data
    if(connection_closed || pb.bytes_written == pb.buffer_size)
    {   
        // printf("schedding %p, drv: %p, f: %p\n", this, drv, f);
        //drv->sched(f);
        fw.wake();
        return;
    }
    
    // printf("not schedding %p\n", this); 
    if(demux.add_socket_wakeup(this, read) == -1)
        fprintf(stderr,"failed to re-add_socket_wakeup\n");
}

// asynchronous connect
bool
connect_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    // printf("async connect start\n");

    int finished;
    sv.s = async_connect(addy, p, &finished);
    sv.socket_err = 0;

// printf("async_connect returned s: %i, finished: %i\n", sv.s, finished);
    if(-1 == sv.s)      // failed!
    {   
        fprintf(stderr,"async_connect failed, waking\n");
        return true;    // wakeup thread
    }
    
    if(finished)
    {   
        // I think on windows I set a success flag here
        // printf("async_connect finished immediately, waking\n");
        return true;
    }
    
    // printf("connect_request didn't finish immediatly, sleeping\n");
    
    // important: copy down the thread and the driver
    sv.fw.drv = drv;
    sv.fw.f = f;
    
    posix_demuxer*  pd = (posix_demuxer*)&demux;
    
    // add to demuxer as writing socket - see man 2 connect
    // wake thread if call failed
    return (pd->add_socket_wakeup(&sv, false) == -1);
}

@tangle("typedef " + FLX_SOCKLEN_T + " FLX_SOCKLEN_T;")

void
connect_wakeup::wakeup(posix_demuxer& demux)
{
    // printf("connect woke up\n");
    // this is how we check the success of async socket calls
    // god knows what the level should be. socket level seems sensible.
    // no socklen_t on 10.2.8, this works though, albeit with a warning
    // was unsigned - I'll probably have to change that back
    // unsigned int    len = sizeof(socket_err);
    FLX_SOCKLEN_T    len = sizeof(socket_err);
    int res = getsockopt(s, SOL_SOCKET, SO_ERROR, &socket_err, &len);
    
    if(-1 == res)
        perror("getsockopt");
    
    // failed, throw away socket
    if(0 != socket_err)
    {   
        printf("async connect error: %s (%i), closing\n",
            strerror(socket_err), socket_err);
// this is not a good place to close as after the wakeup the socket
// is often operated on via the event code (remove from kqueue, etc)
// moving the closing to the flx code 
// printf("ouch - closing is actually bad to do here\n"); 
        // this should be ok now, as the rule is that the socket is removed
        // before the wakeup, so close away!
        if(close(s) != 0) 
            perror("async socket close");
        
        s = -1;     // the result
    }
    
    //drv->sched(f);
    fw.wake();
}

// async accept
bool
accept_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
   // printf("async accept start\n");

    // important: copy down the thread and the driver
    sv.fw.drv = drv;
    sv.fw.f = f;
    
    posix_demuxer*  pd = (posix_demuxer*)&demux;
    
    // add listener to demuxer as reading socket - see man 2 accept
    // wake thread if call failed
    return (pd->add_socket_wakeup(&sv, true) == -1);
}

void
accept_wakeup::wakeup(posix_demuxer& demux)
{   
    // printf("accept woke up\n");
    
    acceptee = nice_accept(s);      // remember, s is the listener
    
    if(acceptee == -1)
    {   
        perror("nice_accept");
        // didn't get it - go back to sleep
        demux.add_socket_wakeup(this, true);    // reading = accept
        return;
    }
    
    // drv->sched(f);
    fw.wake();
}

// from driver request
bool
flxfileio_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    // printf("driver called fileio start_async_op code\n");
    // important: copy down the thread and the driver
    fw.drv = drv;
    fw.f = f;
    
    // need to create the async io thing here, or ask the driver for it
    // driver needs to go a little less portable
    pflx_drv*   pdrv = (pflx_drv*)drv;
    pdrv->get_aio_worker()->add_fileio_request(this);
    
    return false;       // no wakeup
}

// from async io thread
void
flxfileio_request::finished()
{   
    // printf("async fileio got finished callback\n");
    fw.wake();      // wake thread
}

// sleep task prio queue thing

bool
sleep_request::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{   
   // printf("driver called sleep_task start_async_op code\n");
    // important: copy down the thread and the driver
    fw.drv = drv;
    fw.f = f;
    
    // need to create the async io thing here, or ask the driver for it
    // driver needs to go a little less portable
    pflx_drv*   pdrv = (pflx_drv*)drv;
    pdrv->get_sleepers()->add_sleep_request(this, delta);
    
    return false;       // no wakeup
}

// from async io thread
void
sleep_request::fire()
{   
    fw.wake();      // wake thread
}



@h=tangler('faio/faio_winio.hpp')
@select(h)
#ifndef __DWINIO__
#define __DWINIO__
#include <flx_rtl_config.hpp>

// visual studio is quite sensitve about how you do these includes.
// THIS is the way (WinSock2.h must include Windows.h).
#include <WinSock2.h>
#include <MSWSock.h>        // AcceptEx, TF_REUSE_SOCKET, etc
#include "faio_asyncio.hpp" // flx driver requests

#include "demux_iocp_demuxer.hpp"   // all sorts of great stuff
    
// interestingly, because in windows the async objects are associated
// with an IOCP before their use, we don't actually need a demuxer here
// at all. That's kind of nice. (actually iocp_associator uses it now)
        
// a flx driver request to the add socket s to the drivers iocp
// this is currently the only windows driver request that uses the demuxer.
class FLX_RTL_EXTERN iocp_associator : public flx_driver_request_base {
    SOCKET  s;
public:
    // should have result & errcode
    iocp_associator() {}            
    iocp_associator(SOCKET associatee) : s(associatee) {}

    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
};  
    
// flx <-> c++ stuff for async io (well, it was)
class FLX_RTL_EXTERN waio_base : public flx_driver_request_base, public iocp_wakeup {
protected:
    // these three should provide enough info to wake a thread
    void*       f;                      // give this a better name
    flx_drv*    driver;
    demuxer*    demux;
public:
    bool    success;
    
    waio_base() : f(0), success(false) {}
    
    // from iocp_wakeup (start_op is from flx_driver_request_base)
    virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
        LPOVERLAPPED olp, int err);
};
    

// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class FLX_RTL_EXTERN wasync_accept : public waio_base {
    enum { ACCEPTEX_ADDR_SIZE = sizeof(SOCKADDR_IN) + 16 };
    
    SOCKET  listener, acceptor;
    // there are two of these!
    char    accept_buf[2*ACCEPTEX_ADDR_SIZE];
public:
    
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
    
    wasync_accept() {}              // felix linkage demands it
    wasync_accept(SOCKET l, SOCKET a) 
        : listener(l), acceptor(a) { }
};

class FLX_RTL_EXTERN connect_ex : public waio_base
{   
    SOCKET      s;                  // previously unbound socket
    // can have buffer to be sent on connection
    const char* addy;               // ipv4 address
    int         p;                  // port number
public:
    
    connect_ex() {}                 // flx linkage
    connect_ex(SOCKET soc, const char* addr, int port)
        : s(soc), addy(addr), p(port) {}
    
    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
};

// TransmitFile here (requires file handle)
class FLX_RTL_EXTERN wasync_transmit_file : public waio_base {
    SOCKET  s;
    HANDLE  file;
    DWORD   flags;                              // for possible socket reuse.
public:
    wasync_transmit_file() {}                   // flx linkage
    
    wasync_transmit_file(SOCKET dst)            // for reuse of socket
        : s(dst), file(NULL), flags(TF_DISCONNECT | TF_REUSE_SOCKET) {}
    
    wasync_transmit_file(SOCKET dst, HANDLE src)    // actual transmitfile
        : s(dst), file(src), flags(0) {}

    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
};

// handles both WSASend & WSARecv
class FLX_RTL_EXTERN wsa_socketio : public waio_base {
    enum { NUM_WBUFS = 1 }; // just one for now, but can do scattered send/recvs
    WSABUF      wbufs[NUM_WBUFS];
    SOCKET      s;
    bool        reading;    // else use WSASend
public:
    sel_param   pb;         // what you wanted & later, what you got

    wsa_socketio() {}
    wsa_socketio(SOCKET src, void* buf, int len, bool read);

    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
    virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
        LPOVERLAPPED olp, int err);
};

// looks a bit like wsa_socketio (bad name, sends too)
class FLX_RTL_EXTERN winfile_io : public waio_base {
    HANDLE      file;
    bool        reading;
public:
    sel_param   pb;

    winfile_io() {}         // flx linkage

    // offset?
    winfile_io(HANDLE f, void* buf, int len, bool read);

    virtual bool start_async_op(demuxer& demux, flx_drv* drv, void* f);
    virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
        LPOVERLAPPED olp, int err);
};

#endif  // __DWINIO__

@h=tangler('faio/faio_winio.cpp')
@select(h)
#include "faio_winio.hpp"
#include <stdio.h>      // printf

// way of adding sockets to the IOCP.
bool
iocp_associator::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{   
    iocp_demuxer* iod = (iocp_demuxer*)&demux;
    if(iod->associate_with_iocp((HANDLE)s, 0) != 0)
       fprintf(stderr,"associate request failed - get result here!\n");

    return true;            // wake caller
}

void
waio_base::iocp_op_finished( DWORD nbytes, ULONG_PTR udat, 
    LPOVERLAPPED olp, int err)
{
    // printf("general wakeup thing - rescheduling\n");
    //printf("this: %p, q: %p, f: %p, err: %i\n", this, q, f, err);

    // this tells us when things went wrong (store it)
    if(NO_ERROR != err)
        fprintf(stderr,"catchall wakeup got error: %i (should store it)\n", err);

    success = (NO_ERROR == err);    // this works pretty well
    driver->sched(f);
}

// to be called inside every start_async_op
#define WAIO_START_INIT this->f=f;\
                        this->driver=drv;\
                        this->demux=&demux

// return async finished flag (error flags - can be transmitted via class)
// AcceptEx is the way to get accept connections via the IOCP
bool
wasync_accept::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    WAIO_START_INIT;            // records enough info for wakeup
    clear_overlapped();

// I've seen two examples get the pointer to AcceptEx, just in case it
// isn't implemented...
    // printf("AcceptExing: listen backlog => can succeed immediately\n");
    
    DWORD   nbytes;
    BOOL    success;
    
    // note that in order to get the wakeup packet, the listener must
    // already be associated with the iocp. for future async io, the acceptor
    // must be associated too.
    success = AcceptEx(listener, acceptor,
        accept_buf,             // required - near/far address
        0,                      // receive data size - don't yet want this
        ACCEPTEX_ADDR_SIZE,     // must be nonzero
        ACCEPTEX_ADDR_SIZE,     // must be nonzero
        &nbytes,                // only set if fn completes. should be 0
        &ol);                   // oblig. gets us back to the this ptr
    
    // if there is a backlog of connections, AcceptEx can return immediately
    if(success)
    {   
        // must clear the wait 
        fprintf(stderr,"WHOA! AcceptEx RETURNED SUCCESS IMMEDIATELY!\n");
        // handle the successful wakeup
        // complete_async_op(demux, drv, nbytes, NO_ERROR); 
        // I hope they don't want the udat pointer, because I
        // just made it up (0=NULL). Not using it anyway.
        iocp_op_finished(nbytes, 0, &ol, NO_ERROR);
        return false;
    }
    else
    {
        int err = WSAGetLastError();
        // can also return WSACONNRESET, which isn't so bad
        if(ERROR_IO_PENDING == err)
        {   
            // printf("AcceptEx returned ERROR_IO_PENDING - that's normal\n");
            // This is the normal situation, fall through, leaving thread
            // to sleep on wakeup call.
        }
        else
        {   
            fprintf(stderr,"AcceptEx failed: %i\n", err);
            fprintf(stderr,"returning true should wake thread to detect failure.\n");
            return true;        // have self woken
        }
    }
    return false;               // async not finished
}

#if 0
// apparently we're supposed to do this now to make the acceptee inherit
// the listener's state. it is currently in the default state
//err = setsockopt( sAcceptSocket,
//  SOL_SOCKET, 
//  SO_UPDATE_ACCEPT_CONTEXT,
//  (char *)&sListenSocket, 
//  sizeof(sListenSocket) );
#endif

// what a pain in the arse (zzz)
static int
GetConnectExAddr(SOCKET s, LPFN_CONNECTEX* conn_fn)
{
    *conn_fn = NULL;
    GUID            GuidConnectEx = WSAID_CONNECTEX;
    DWORD           dwBytes;
    int             err;

    err = WSAIoctl(s,       // why do I need this?
        SIO_GET_EXTENSION_FUNCTION_POINTER,
        &GuidConnectEx,
        sizeof(GuidConnectEx),
        conn_fn,
        sizeof(*conn_fn),
        &dwBytes,
        NULL, NULL);        // no overlapped, no completion fun ptr
//  printf("Get addr dwbytes: %li\n", dwBytes);
    return err;
}

// this is the weirdest. To use ConnectEx, the socket must be already bound.
// By trial and error, I found that it had to be bound to INADDR_ANY: 0.
// So strange. Apparently I don't have to do it again if I want to reuse.
static int
bind_socket(SOCKET s)
{   
    SOCKADDR_IN     addr;
    
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = htonl(INADDR_ANY);
    addr.sin_port = htons(0);
    
    return bind(s, (LPSOCKADDR)&addr, sizeof(addr));
}

bool
connect_ex::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{   
    WAIO_START_INIT;            // records enough info for wakeup
    clear_overlapped();
    
    DWORD   bytes_sent = 0;     // we're not sending data on connect (yet)
    BOOL    success;
    
    LPFN_CONNECTEX  pfConnectEx;
    
    // unfortunate, will fix up later.
    // printf("Getting ConnectEx address\n");

    // Turns out that ConnectEx isn't defined anywhere; I have to load its
    // addr via WSAIoctl
    // this is a bad way. make the driver cache it. why on earth is this
    // call per-socket? does it really need to be that way?
    if(GetConnectExAddr(s, &pfConnectEx) == SOCKET_ERROR)
    {
        fprintf(stderr,"GetConnectExAddr failed: %i\n", WSAGetLastError());
        return true;
    }

    // printf("about to connectex to %s:%i, %i\n", addy, p, s);

    // this is so strange - I have to bind the socket to the localhost.
    // if I don't, ConnectEx returns EINVAL. in any case, I won't need
    // to do this again if I reuse this socket.
    if(bind_socket(s) == SOCKET_ERROR)
        fprintf(stderr,"ConnectEx bind failed: %i\n", WSAGetLastError());

    // I hope ConnectEx doesn't want this to hang around, because it's
    // going to drop off the stack after this.
    SOCKADDR_IN     addr;

    // some examples don't zero the addr. That makes me nervous.
    ZeroMemory(&addr, sizeof(addr));
    addr.sin_family = AF_INET;
    addr.sin_addr.s_addr = inet_addr(addy);
    addr.sin_port = htons(p);

    // in order to receive the wakeup packet, s must already be associated
    // with the iocp. this is best done at socket creation time. for these
    // sockets it's probably best to also bind them at the same time.
    // that requires "purposed" sockets (CreateConnectSocket?).
    // p.s. the default (waio_base) wakeup is doing fine for now.
    
    success = (*pfConnectEx)(s, // socket
        (LPSOCKADDR)&addr,      // connect address
        sizeof(addr),           // size thereof
        NULL,                   // not sending any data yet, but we could
        0,                      // ditto
        NULL,                   // should be zero until this changes
        &ol);                   // oblig. gets us back to the this ptr

// there's a caveat about the type of socket s becomes after ConnectEx.
// It's in some kind of default state and cannot be used with shutdown
// change it with setsockopt (?)
    if(success)
    {   
        fprintf(stderr,"WHOA! ConnectEx RETURNED SUCCESS IMMEDIATELY!\n");
        // handle the successful wakeup. (udat=0, olp=&ol)
        iocp_op_finished(bytes_sent, 0, &ol, NO_ERROR);
        return false;       // already woken up
    }
    else
    {   
        int err = WSAGetLastError();
        
        if(ERROR_IO_PENDING == err)
        {   
            // printf("ConnectEx pending...\n");
            // This is the normal situation, fall through, leaving thread
            // to sleep on wakeup call.
        }
        else
        {   
            // maybe store the error here. that could work for all
            // windows wakeups
            fprintf(stderr,"ConnectEx failed: %i\n", err);
            return true;        // have self woken
        }
    }
    return false;               // not finished
}

bool
wasync_transmit_file::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{   
    WAIO_START_INIT;            // records enough info for wakeup
    clear_overlapped();
    
    // 0 bytes => transmit entire file
    // the second zero means use the default chunk size
    // the NULL is for mem buffers to bookend the file with. nothing yet.
    // the final zero is for various flags, including a way of doing
    // DisconnectEx style socket reuse (more widely compatible?)
    
    // in order to receive the wakeup, s must already be associated with the
    // iocp. this is best done at socket creation time.
    if(TransmitFile(s, file, 0, 0, &ol, NULL, flags))
    {
        fprintf(stderr,"Transmit file succeeded immediately! waking...\n");
        return true;
    }
    else
    {
        DWORD   err = WSAGetLastError();

        // will need to actually signal something
        // printf("signal TransmitFile failure!\n");
        if(ERROR_IO_PENDING != err && WSA_IO_PENDING != err)
            fprintf(stderr,"genuine error from TransmitFile: %li\n", err);
    }
    return false;
}

wsa_socketio::wsa_socketio(SOCKET src, void* buf, int len, bool inread)
    : s(src), reading(inread)
{   
    // pb is not so useful here. we only want to
    // know num bytes written/processed.
    pb.buffer = (char*)buf;
    pb.buffer_size = len;
    pb.bytes_written = 0;
}

bool
wsa_socketio::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{
    WAIO_START_INIT;            // records enough info for wakeup
    clear_overlapped();

    // num bytes received IF recv completes immediately.
    DWORD   imm_bytes;
    int     recv_res;

    // set up the single wbuf, bearing in mind we may be part way.
    wbufs[0].len = pb.buffer_size - pb.bytes_written;
    wbufs[0].buf = pb.buffer + pb.bytes_written;
    
    // Ideally, we would like to be able to use MSG_WAITALL, which would
    // let us only get a completion packet when either all the data was
    // available or the connection had been closed or shutdown.
    // Unfortunately this is not possible for non-blocking sockets, so
    // we have to take whatever we get and then call WSARecv again.
    
    //#define MSG_WAITALL 0     // not defined in cygwin - apparently this
    //DWORD flags = MSG_WAITALL;
    
    // ah, unfortunately MSG_WAITALL is not supported for non blocking sockets
    // we'll just have to do it ourselves
    DWORD   flags = MSG_PARTIAL;
    
    // completion routines! (unused)
    if(reading)
        recv_res = WSARecv(s, wbufs, NUM_WBUFS, &imm_bytes, &flags, &ol, NULL);
    else
        recv_res = WSASend(s, wbufs, NUM_WBUFS, &imm_bytes, flags, &ol, NULL);
    
    // don't know if I need to check non winsock errs
    
    switch(recv_res)    {
        case 0:
       {
           // flags are updated to indicate what? if there was a callback, it
           // would be scheduled to be called when this thread is in the
           // waitable state, whatever that means.
           // printf("WSA%s completed immediately!!! numbytes: %li, flags: %lx\n",
            //  (reading) ? "Recv" : "Send", imm_bytes, flags);
            
            // looks like we get the completion packet even if we do finish
            // immediately so let the iocp wake us.
            // this updates pb & wakes us up
            // complete_async_op(demux, drv, imm_bytes, NO_ERROR);
        
            return false;
        }
        break;
        case SOCKET_ERROR:
        {
            DWORD   err = WSAGetLastError();
            
            // normal mode - wait for completion
            // fyi, xp pro seems to mostly give us ERROR_IO_PENDING
            if(ERROR_IO_PENDING == err || WSA_IO_PENDING == err)
            {   
                // printf("WSA%s pending completion (%li)\n",
                //  (reading) ? "Recv" : "Send", err);
                return false;
            }
            
            fprintf(stderr,"WSARecv/Send returned SOCKET_ERR: %li\n", err);
            return true;        // assume it's bad and we won't get a wakeup
        }
        break;
        default:
        {       
            fprintf(stderr,"WSARecv/Send returned other error: %i, GetLastError: %li\n",
                recv_res, GetLastError());
            return true;                // wake up
        }
        break;
    }

    return false;
}

void
wsa_socketio::iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
{   
    // printf("wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );
    
    // keep track of bytes received.
    pb.bytes_written += nbytes;
    
    // if we're not finished, we have to reinstall our request
    // zero bytes indicates shutdown/closure, right?
    // might be using this for WSASend. Instead of broken pipes on win32,
    // instead we get WSAECONNRESET (pretty sure) on write. On read?
    if(0 == nbytes || pb.bytes_written == pb.buffer_size)
    {   
        // this'll wake us up
        waio_base::iocp_op_finished(nbytes, udat, olp, err);
    }
    else
    {   
        // go back around again
        // this returns a finished flag (bad idea). it can also fail.
        // I think it would be better to know that.
        start_async_op(*demux, driver, f);
    }
}

// file io

winfile_io::winfile_io(HANDLE f, void* buf, int len, bool inread)
    : file(f), reading(inread)
{   
    // pb is not so useful here. we only want to
    // know num bytes written/processed.
    pb.buffer = (char*)buf;
    pb.buffer_size = len;
    pb.bytes_written = 0;
}

// if file is opened with FILE_FLAG_OVERLAPPED, we can do "immutable file ptr"
// ops & set the desired offset within the overlapped. can also stick an
// event to signal in there.
bool
winfile_io::start_async_op(demuxer& demux, flx_drv* drv, void* f)
{   
    fprintf(stderr,"trying out some read/write file\n");
    
    // factor this out - everyone does it.
    clear_overlapped();         
    this->f = f;                // need this for wakeup. quite general.
    
    // DWORD    imm_bytes;
    BOOL    success;
    
    // don't need bytes read, written when we have an OVERLAPPED
    if(reading)
        // success = ReadFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
        success = ReadFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
    else
        //success = WriteFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
        success = WriteFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
    
    // printf("immbytes = %li\n", imm_bytes);
    
    if(!success)
    {
// this is probably going to be IOPENDING
        fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
            GetLastError());
        fprintf(stderr,"do I still get completion packet???\n");
        // assume not           
        return true;            // ask for wakeup
    }
    
    return false;               // sleep on
}

void
winfile_io::iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
{
    fprintf(stderr,"winfile_io wakeup, nb: %li, err: %i\n", nbytes, err );
    
    // printf("THIS WAKEUP SHOULD BE THE SAME AS SEND/RECV make it so\n");
    // actually, I don't think it should be. the SOCKET stuff goes around
    // the loop again (and ignores errors, check it doesn't hammer).
    
    // keep track of bytes received.
    pb.bytes_written += nbytes;
    
    waio_base::iocp_op_finished(nbytes, udat, olp, err);
}



@h=tangler('lib/flx_faio.flx')
@select(h)
include "std";

proc faio_req[t](x:&t) {
  // svc_general takes an arbitrary machine
  // address as an argument: the _ref_ denotes
  // that address. It does NOT point to an 'address'
  // but to an faio request .. however the svc doesn't
  // know the type of such requests objects .. so we use
  // the type 'address' as a convenient dummy
  val y : &address = reinterpret[&address] x;
  svc (svc_general y);
}

// Faio library bindings
// this file should be portable. it currently defines only a few simple
// driver interactions and copipes. no stream wrappers in here.
    
// get thread self from driver
proc get_thread(thread: ptr[fthread]) {
    //var x = svc_get_fthread (address_of( *thread ));
    //svc( x );
    svc (svc_get_fthread thread );
}

// lame - argv gives a string, I might do my own. 
fun cargv:int -> charp = '(char*)($1<0||$1>=ptf->argc??"":ptf->argv[$1])';


header stdlib_h = '#include <stdlib.h>';            // malloc, free
    
// be careful of this being optimized away 
fun malloc: int -> address = 'malloc($1)' requires stdlib_h;
proc free: address = 'free($1);' requires stdlib_h; 
    
//header asyncio_h = '#include "faio_asyncio.hpp"';
// could go through and conditionally require this header, but I'm
// not going to right now.
// this pulls in sel_params & demuxers & so on
header = '#include "faio_asyncio.hpp"';

// looks like it has to be ctypes, even if there's only one
ctypes sel_param;

// shouldn't have to do this, but I'm not allowed to take & of get_pb...
// can define pointer, but then felix doesn't know the relationship between
// pointer & pointed to type. what to do?
type sel_param_ptr = 'sel_param*';

// this is felix coding at its least subtle
fun to_ptr : sel_param -> sel_param_ptr = '&$1';


fun get_bytes_done : sel_param_ptr -> int = '$1->bytes_written';
proc init_pb : sel_param*address*int
= '{$1.buffer=(char*)$2;$1.buffer_size=$3;$1.bytes_written=0;}';

// this way when I realise that my eof calc is wrong, I can change it
// everywhere at once. so, should exactly n of n bytes read be eof?
// it currently isn't. 
proc calc_eof(pb: sel_param_ptr, len: &int, eof: &bool)
{
    var bytes_done = pb.bytes_done;
    *eof = (bytes_done != *len);
    *len = bytes_done;
}

// this is a no-op hack to make it look like the argument t
// is actually being used. useful for a few hairy svc/gc interactions
proc gc_collect_me_not_hack[t]: t = ';';

// thread spawning! go wild!

// this is so much better now that I can pass a curried unit proc () -> ()
proc spawn_thread(p:1->0)
{
    var con = start p;              // get continuation of p
    var fthr = mk_thread con;
    svc$ svc_spawn_detached fthr;
}

// copipe interface.

// copipes are actually implemented as end_point_a <= pipe => end_point_b
// felix only needs to know about endpoints, which we'll call pipes.
type copipe = 'copipe_endpt*';

// private calls
proc connect : copipe*fthread*sel_param*bool
 = '$1->pipe->connect((void*)$2, &$3, $4, $1->get_channel($4));';
fun pipe_request : copipe -> address = '$1->pipe';
fun to_ptr : copipe -> address = '$1';      // easier than cast
proc priv_shutdown : copipe*int = '$1->shutdown($2);';
proc priv_delete : copipe = 'delete $1;';

// this is awful but I don't know how to interact with flx ptrs
// via the c interface. YUK!
header 'typedef struct{ copipe_endpt* foo[2]; }sorry_awful;';
type co_awful = 'sorry_awful';
proc init_awful_pair : co_awful = 'copipe_endpt::pipe_pair($1.foo);';
fun get : co_awful*int -> copipe = '$1.foo[$2]';

proc flx_copipe_pair(p1: &copipe, p2: &copipe)
{   
    var awful: co_awful;
    init_awful_pair(awful);
    *p1 = get(awful, 0);
    *p2 = get(awful, 1);
}

// not for public consumption
// the c++ copipe code figures out what you wanted from the pipe itself.
proc copipe_driver_request(pipe: copipe)
{   
    var request = pipe_request pipe;
    faio_req$ &request;
}

proc co_rw(pipe: copipe, len: &int, buf: address, eof: &bool, read_flag: bool)
{
    // Suppose I could move this to start_async_op, it knows the thread, but
    // not whether it's reading or writing
    var thread : fthread;
    get_thread(addr thread);                    // ask driver for thread pointer
    
    var pb: sel_param;
    init_pb(pb, buf, *len);
    
    // connect thread to its apropriate read/write channel
    connect(pipe, thread, pb, read_flag);
    
    copipe_driver_request(pipe);
    
    calc_eof(to_ptr(pb), len, eof);
}

// public copipe calls

// shutdown pipe endpoint. no matter what how is, pipe must still be closed
// how = 0 => no more reads, 1 no more writes, 2 no more anything
proc co_shutdown(pipe: copipe, how: int)
{   
    priv_shutdown(pipe, how);
    // let pipe request be evaluated
    copipe_driver_request(pipe);
}

proc co_close(pipe: copipe)
{   
    co_shutdown(pipe, 2);                   // no more io, eof those waiting
    priv_delete(pipe);
    // the end!
}

proc co_read(pipe: copipe, len: &int, buf: address, eof: &bool)
{   
    co_rw(pipe, len, buf, eof, true);       // read
}

proc co_write(pipe: copipe, len: &int, buf: address, eof: &bool)
{   
    co_rw(pipe, len, buf, eof, false);      // read
}


@h=tangler('lib/flx_faio_posix.flx')
@select(h)
include "std";
// contains posix async socket io & copipes, all wrapped up streams
open C_hack;        // cast, address

// some random stuff, sorta unixy
header unistd_h = '#include <unistd.h>';            // close
header fcntl_h = '#include <fcntl.h>';              // fcntl for O_NONBLOCK
header sys_socket_h = '#include <sys/socket.h>';    // shutdown
header sockety_h = '#include "demux_sockety.hpp"';  // my socket utils

proc close: int = 'close($1);' requires unistd_h;
proc shutdown: int*int = 'shutdown($a);' requires sys_socket_h;

// this too can be optimised away to nothing
// mucking around with pushing file fd through the async socket code
fun aio_ropen: charp -> int = 'open($1, O_RDONLY | O_NONBLOCK, 0)'
    requires fcntl_h;

// blocking, read only
fun ropen: charp -> int = 'open($1, O_RDONLY, 0)' requires fcntl_h;

// trying to factor out portable driver interaction code
include "flx_faio";

header = '#include "faio_posixio.hpp"';

// socketio_request should be renamed to be async_fd_request
ctypes socketio_request;

fun mk_socketio_request: int*address*int*bool -> socketio_request
    = 'socketio_request($1, (char*)$2, $3, $4)';

fun get_pb: socketio_request -> sel_param_ptr = '&$1.sv.pb';

// read & write differ only by a flag
proc async_rw(fd: int, len: &int, buf: address, eof: &bool, read_flag: bool)
{
    var asyncb = mk_socketio_request(fd, buf, *len, read_flag);

    // magic! (break to driver, wake up when it's all over)
    faio_req$ &asyncb;

    calc_eof(asyncb.pb, len, eof);
}

proc async_read(fd: int, len: &int, buf: address,
    eof: &bool)
{   
    async_rw(fd, len, buf, eof, true);      // read
}

proc async_write(fd: int, len: &int, buf: address, eof: &bool)
{   
    async_rw(fd, len, buf, eof, false);     // write
}

ctypes flxfileio_request;

// offset ? let it be for a moment
fun mk_faio: int*address*int*int*bool -> flxfileio_request
    = 'flxfileio_request($1, (char*)$2, $3, $4, $5)';
fun get_pb: flxfileio_request -> sel_param_ptr = '&$1.pb';

proc faio_rw(fd: int, len: &int, buf: address, eof: &bool, read_flag: bool)
{   
    // constant offset for now, rushing to get this in flx_stream
    var faio = mk_faio(fd, buf, *len, 0, read_flag);
    faio_req$ &faio;
    calc_eof(faio.pb, len, eof);
}

proc faio_read(fd: int, len: &int, buf: address,
    eof: &bool)
{   
    faio_rw(fd, len, buf, eof, true);       // read
}

proc faio_write(fd: int, len: &int, buf: address, eof: &bool)
{   
    faio_rw(fd, len, buf, eof, false);      // write
}

// sleep! finally!
// pod type sleep_request = "sleep_request";
ctypes sleep_request; 
fun mk_sleep_request: double -> sleep_request = 'sleep_request($1)';

proc sleep(delta: double)
{   
    var sr = mk_sleep_request delta; 
    faio_req$ &sr;
}

// connect!
type async_connect = 'connect_request';

fun mk_async_connect: charp*int -> async_connect = 'connect_request($a)';
fun get_socket: async_connect -> int = '$1.sv.s';

// could do multi connects for capable drivers
proc connect(s: &int, addr: charp, port: int)
{   
    var ac = mk_async_connect(addr, port);
    faio_req$ &ac;
    *s = ac.socket;
}

ctypes accept_request;

fun mk_accept: int -> accept_request = 'accept_request($1)';
fun get_socket: accept_request -> int = '$1.sv.acceptee';

// arg1 = returned socket, arg2 is port, pass 0 to have one assigned
proc mk_listener: lvalue[int]*lvalue[int]*int
    = '$1 = nice_create_listener(&$2, $3);' requires sockety_h;

proc accept(s: &int, listener: int)
{   
    var acc = mk_accept listener ;
    faio_req$ &acc;
    *s = acc.socket;
}

// the following code wraps up both copipes and unix style sockets. 
// this could present a portability problem as with this interface, all the
// code is dumped into the c++ file, which won't work for windows. either
// I can not use the unified interface or make it so that it pulls in
// windows code on windows (preprocessor?). in any case, I should split
// the copipe stuff off from the socket code.

// could use this stuff to make file descriptors distinct from
// socket descriptors.

// unify the io types
union flx_stream =          
    | SOCK of int           // socket file descriptors (non blocking)
    | CO of copipe
    | FILEFD of int         // file file descriptors (blocking?)
    | DEVNULL
;

// will be ambiguous for file fd, will need name. do I even need these
// when the conversion is unambiguous?
fun to_stream (fd: int): flx_stream = { return SOCK fd; }
fun to_stream (p: copipe): flx_stream = { return CO p; }
fun new_devnull (): flx_stream = { return DEVNULL; }
fun file_to_stream (fd: int): flx_stream = { return FILEFD fd; }

proc flx_read(strm: flx_stream, len: &int, buf: address, eof: &bool)
{
    match strm with 
    | SOCK ?fd => { async_read(fd, len, buf, eof); }
    | CO ?pipe => { co_read(pipe, len, buf, eof); }
    | DEVNULL => { *len = 0; *eof = true; }
    | FILEFD ?fd => { faio_read(fd, len, buf, eof); }
    endmatch;
}

proc flx_write(strm: flx_stream, len: &int, buf: address, eof: &bool)
{   
    match strm with 
    | SOCK ?fd => { async_write(fd, len, buf, eof); }
    | CO ?pipe => { co_write(pipe, len, buf, eof); }
    | DEVNULL => { /* nothing to do */ }
    | FILEFD ?fd => { faio_write(fd, len, buf, eof); }
    endmatch;
}

proc flx_shutdown(strm: flx_stream, how: int)
{   
    match strm with
    | SOCK ?socket => { shutdown(socket, how); }
    | CO ?pipe => { co_shutdown(pipe, how); }
    | DEVNULL => { /* nothing to do? */ }
    | FILEFD => { /* nuthin */ }
    endmatch;
}

proc flx_close(strm: flx_stream)
{   
    match strm with
    | SOCK ?socket => { close(socket); }    // error check?
    | CO ?pipe => { co_close(pipe); }
    | DEVNULL => { /* nothing to do */ }    
    | FILEFD ?fd => { close(fd); }          // error check?
    endmatch;
}

// much less lame (this is completely portable, if flx_stream is defined)
proc flx_popen(ourend: &flx_stream, p:flx_stream->0)
{   
    var a: copipe;
    var b: copipe;
    
    flx_copipe_pair(&a, &b);
    *ourend = to_stream(a);
    var theirend = to_stream(b);
    spawn_thread { p theirend; };
}

proc flx_connect(strm: &flx_stream, addr: charp, port: int)
{   
    var s: int;
    connect( &s, addr, port );
    // nice error handling
    *strm = to_stream s;
}



@h=tangler('lib/flx_faio_win32.flx')
@select(h)
include "std";
// contains windows overlapped/iocp io & copipes. no stream wrapper yet.
open C_hack;

header '#include "faio_winio.hpp"'; // this has everything (includes asyncio.h)

include "flx_faio";     // defines copipes & some driver interaction

ctypes SOCKET;

// maybe don't use this - let the socket be passed in already associated
// with an IOCP. do I have to make this explicitly overlapped? If we
// want async io I think I'll need to associate this with the iocp.
fun cmk_socket : unit -> SOCKET = '::socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)';

// well that didn't help.
//fun cmk_socket : unit -> SOCKET = 'WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, WSA_FLAG_OVERLAPPED)';
// must associate with iocp to do overlapped io with s (WSASend/Recv)
proc mk_socket(s: &SOCKET)
{
    *s = cmk_socket();
    associate_with_iocp(*s);                // associate with iocp (errors?).
}


ctypes wasync_accept;

fun mk_accept: SOCKET*SOCKET -> wasync_accept = 'wasync_accept($a)';
// make this a parameterised type
fun get_success[t]: t -> bool = '$1.success';

// this feels silly
const INVALID_SOCKET: SOCKET = 'INVALID_SOCKET';
// oops, no good if we can't check against it
fun eq : SOCKET*SOCKET -> bool = '($1 == $2)';

// windows style accept. accepted is an already created socket, unbound
proc Accept(success: &bool, listener: SOCKET, accepted: SOCKET)
{
    var acc = mk_accept(listener, accepted);

    faio_req$ &acc;    // causes AcceptEx to be called

    *success = get_success(acc);
}

ctypes connect_ex; 
fun mk_connect_ex: SOCKET*charp*int -> connect_ex = 'connect_ex($a)';

// for use on sockets you make yourself, who knows, maybe you want to
// reuse them
proc Connect(success: &bool, s: SOCKET, addr: charp, port: int)
{   
    var con = mk_connect_ex(s, addr, port);  
     faio_req$ &con;    // causes ConnectEx to be called
    *success = get_success(con);
}

proc Connect(s: &SOCKET, addr: charp, port: int)
{   
    mk_socket s;            // error handling?
    var success: bool;
    Connect(&success, *s, addr, port);
    // print "CONNECT success: "; print success; endl;
    // error handling?
}

// listens on all interfaces, I guess
proc cmk_listener: lvalue[SOCKET]*int*int
    = '$1 = create_listener_socket($2, $3);';

proc mk_listener(listener: &SOCKET, port: int, backlog: int)
{   
    *listener <- cmk_listener(port, backlog);
    associate_with_iocp(*listener);
}

// ignores return value
proc closesocket: SOCKET = 'closesocket($1);';

const SD_RECEIVE:int = 'SD_RECEIVE';
const SD_SEND:int = 'SD_SEND';
const SD_BOTH:int = 'SD_BOTH';

proc shutdown: SOCKET*int = 'shutdown($1, $2);';

ctypes wasync_transmit_file;
// I could just use HANDLEs everywhere, but I want to see how this goes
type WFILE = 'HANDLE';

// hacked for ro atm. the 0 means exclusive (not good, but I haven't deciphered
// the flags yet. NULL for non inheritable security attributes.
// OPEN_EXISTING is to make sure it doesn't create the file
// Geez, FILE_ATTRIBUTE_NORMAL? not hidden, not temp, etc. 
// final NULL is for template file. not sure what it does, but I don't want it.
// notice that it's opened for SHARED reading
proc OpenFile: lvalue[WFILE]*string =
  '$1 = CreateFile($2.c_str(), FILE_READ_DATA, FILE_SHARE_READ, NULL,\
    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);';

// error handling?
proc CloseFile: WFILE = 'CloseHandle($1);';

fun mk_transmit_file : SOCKET*WFILE -> wasync_transmit_file
    = 'wasync_transmit_file($a)';

// toylike interface for now, but still fun
proc TransmitFile(s: SOCKET, f: WFILE)
{   
    var tf = mk_transmit_file(s, f); 
    faio_req$ &tf;
}

// by passing special flags to TransmitFile we can transform a connected
// socket into a socket ready for use with AcceptEx. DisconnectEx explicitly
// does this and without the warning that accept-style & connect-style sockets
// cannot be reused as the other type (which isn't a problem for my use)
// however I already have TransmitFile code in place.
fun mk_reuse_socket : SOCKET -> wasync_transmit_file
    = 'wasync_transmit_file($a)';

proc ReuseSocket(s: SOCKET)
{   
    var tf = mk_reuse_socket(s);
    faio_req$ &tf;
}

ctypes wsa_socketio; 
fun mk_wsa_socketio: SOCKET*address*int*bool->wsa_socketio = 'wsa_socketio($a)';
fun get_pb[t]: t -> sel_param_ptr = '&$1.pb';

proc WSARecv(s: SOCKET, len: &int, buf: address, eof: &bool)
{   
    var rev = mk_wsa_socketio(s, buf, *len, true);  // reading
    faio_req$ &rev;
// we do have a success flag
    calc_eof(rev.pb, len, eof);
}

proc WSASend(s: SOCKET, len: &int, buf: address, eof: &bool)
{   
    var rev = mk_wsa_socketio(s, buf, *len, false); // writing
    faio_req$ &rev;
    calc_eof(rev.pb, len, eof);
}

ctypes winfile_io; 
fun mk_winfile_io: WFILE*address*int*bool->winfile_io = 'winfile_io($a)';

// no offset - just for streams now. write probably doesn't work

proc ReadFile(f: WFILE, len: &int, buf: address, eof: &bool)
{   
    var io = mk_winfile_io(f, buf, *len, true); // reading
    faio_req$ &io;
// we do have a success flag
    calc_eof(io.pb, len, eof);
}

proc WriteFile(f: WFILE, len: &int, buf: address, eof: &bool)
{
    var io = mk_winfile_io(f, buf, *len, false);    // writing
    faio_req$ &io;
    calc_eof(io.pb, len, eof);
}


// general request for addition of socket to iocp. might be better to
// just create them that way.
ctypes iocp_associator;
fun mk_iocp_associator: SOCKET -> iocp_associator = 'iocp_associator($1)';

proc associate_with_iocp(s: SOCKET)
{
    // results? err code?
    var req = mk_iocp_associator(s);
    faio_req$ &req;
}


// this totally sucks, but I wanted to try out the flx_streams on windows
// unify the io types
// add wine FILE
union flx_stream =
    | WSOCK of SOCKET
    | CO of copipe
    | DEVNULL
    | FD of WFILE           // new, actually just a HANDLE to a file
;

// will be ambiguous for file fd, will need name. do I even need these
// when the conversion is unambiguous?
fun to_stream (s: SOCKET): flx_stream = { return WSOCK s; }
fun to_stream (p: copipe): flx_stream = { return CO p; }
fun new_devnull (): flx_stream = { return DEVNULL; }
fun to_stream (f: WFILE): flx_stream = { return FD f; }

proc flx_read(strm: flx_stream, len: &int, buf: address, eof: &bool)
{
    match strm with
    | WSOCK ?s => { WSARecv(s, len, buf, eof); }
    | CO ?pipe => { co_read(pipe, len, buf, eof); }
    | DEVNULL => { *len = 0; *eof = true; }
    | FD ?file => { ReadFile(file, len, buf, eof); }
    endmatch;
}

proc flx_write(strm: flx_stream, len: &int, buf: address, eof: &bool)
{   
    match strm with 
    | WSOCK ?s => { WSASend(s, len, buf, eof); }
    | CO ?pipe => { co_write(pipe, len, buf, eof); }
    | DEVNULL => { /* nothing to do */ }
    | FD ?file => { WriteFile(file, len, buf, eof); }
    endmatch;
}

proc flx_shutdown(strm: flx_stream, how: int)
{
    match strm with
    | WSOCK ?socket => { shutdown(socket, how); }
    | CO ?pipe => { co_shutdown(pipe, how); }
    | DEVNULL => { /* nothing to do? */ }
    | FD => { /* nothing to do */ }
    endmatch;
}

proc flx_close(strm: flx_stream)
{
    match strm with
    | WSOCK ?socket => { closesocket(socket); }
    | CO ?pipe => { co_close(pipe); }
    | DEVNULL => { /* nothing to do */ }
    | FD ?file => { CloseFile(file); }
    endmatch;
}

// THIS SUCKS EVEN MORE BECAUSE THE CODE IS PORTABLE YET DEFINED IN TWO PLACES!
// much less lame (this is completely portable, if flx_stream is defined)
proc flx_popen(ourend: &flx_stream, p:flx_stream->0)
{   
    var a: copipe;
    var b: copipe;
    
    flx_copipe_pair(&a, &b);
    *ourend = to_stream(a);
    var theirend = to_stream(b);
    spawn_thread { p theirend; };
}

proc flx_connect(strm: &flx_stream, addr: charp, port: int)
{   
    var s: SOCKET;
    Connect( &s, addr, port );
    // nice error handling
    *strm = to_stream s;
}



