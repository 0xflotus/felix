@head(1,'C++ Code generator')
@h = tangler('src/flx_gen.mli')
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_label

val gen_functions:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  IntSet.t ->
  string

val gen_execute_methods:
  string ->
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  IntSet.t ->
  label_map_t * label_usage_t ->
  int ref ->
  out_channel ->
  unit

val find_members:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  int ->
  btypecode_t list ->
  string

val gen_biface_headers:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string

val gen_biface_bodies:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string
  
val format_vars:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  bid_t list ->
  btypecode_t list ->
  string

val gen_elk_parser:
  string ->
  string ->
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  range_srcref ->
  btypecode_t ->
  int ->
  int list -> 
  unit

val gen_elk_lexer:
  string ->
  string ->
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  range_srcref ->
  tbexpr_t ->
  int ->
  unit

@h = tangler('src/flx_gen.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_name
open Flx_tgen
open Flx_unify
open Flx_csubst
open Flx_exceptions
open Flx_display
open List
open Flx_generic
open Flx_label
open Flx_unravel
open Flx_ogen
open Flx_ctypes
open Flx_cexpr
open Flx_maps

let string_of_string = Flx_string.c_quote_of_string

(* HACKERY: this assumes library dependent things:
  but we can't add literals in the library code :-(
*)
let csuffix_of_type s = match s with
  | "tiny" -> ""
  | "short" -> ""
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "ll"
  | "utiny" -> "u"
  | "ushort" -> "u"
  | "uint" -> "u"
  | "ulong" -> "lu"
  | "uvlong" -> "llu"
  | "int8" -> ""
  | "int16" -> ""
  | "int32" -> "l"
  | "int64" -> "ll"
  | "uint8" -> "u"
  | "uint16" -> "u"
  | "uint32" -> "lu"
  | "uint64" -> "llu"
  | "double" -> ""
  | "float" -> "f"
  | "ldouble" -> "l"
  | _ -> failwith ("[csuffix_of_type]: Unexpected Type " ^ s)

let cstring_of_literal e = match e with
  | `AST_int (s,i) -> (Big_int.string_of_big_int i)^csuffix_of_type s 
  | `AST_float (s,x) -> x ^ csuffix_of_type s
  | `AST_string s -> string_of_string s
  | `AST_cstring s -> string_of_string s
  | `AST_wstring s -> "L" ^ string_of_string s
  | `AST_ustring s -> "L" ^ string_of_string s

(* a native literal is one not needing a cast to get the type right *)
let is_native_literal e = match e with
  | `AST_int ("int",_) 
  | `AST_int ("long",_) 
  | `AST_int ("uint",_) 
  | `AST_int ("ulong",_) 
  | `AST_int ("vlong",_) 
  | `AST_int ("uvlong",_) 
  | `AST_float ("double",_) -> true
  | _ -> false

let find_variable_indices syms (child_map,bbdfns) index = 
  let children = 
    try 
      Hashtbl.find child_map index 
    with Not_found -> [] 
  in
  filter
  (fun i -> 
    try match Hashtbl.find bbdfns i with _,_,_,entry ->
      match entry with 
      | `BBDCL_var _ 
      | `BBDCL_val _ -> true
      | _ -> false
    with Not_found -> false
  )
  children

let get_variable_typename syms bbdfns i ts =
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_var (vs,t)
  | `BBDCL_val (vs,t) ->
    let t = lower t in
    if length ts <> length vs then 
    failwith 
    (
      "[get_variable_typename} wrong number of args, expected vs = " ^ 
      si (length vs) ^ 
      ", got ts=" ^ 
      si (length ts)
    );
    let t = reduce_type (lstrip syms.dfns (tsubst vs ts t)) in
    cpp_typename syms t

  | _ -> 
    failwith "[get_variable_typename] Expected variable"

let format_vars syms bbdfns vars ts =
  catmap  ""
  (fun idx -> 
    let instname = 
      try Some (cpp_instance_name syms bbdfns idx ts) 
      with _ -> None
    in 
      match instname with
      | Some instname ->
        let typename = get_variable_typename syms bbdfns idx ts in
        "  " ^ typename ^ " " ^ instname ^ ";\n"
      | None -> "" (* ignore unused variables *)
  )
  vars
 
let find_members syms (child_map,bbdfns) index ts = 
  let variables = find_variable_indices syms (child_map,bbdfns) index in
  match format_vars syms bbdfns variables ts with
  | "" -> ""
  | x -> "  //variables\n" ^x

let typeof_bparams ps: btypecode_t  = 
  typeoflist 
  (map
  (fun (id,(ix,t)) ->t) 
  ps
  )

let get_type bbdfns index = 
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_type] Can't find index " ^ si index)
  in
  match entry with
  | `BBDCL_function (props,vs,ps,ret,_) -> 
      `BTYP_function (typeof_bparams ps,ret)
  | `BBDCL_procedure (props,vs,ps,_) -> 
      `BTYP_function (typeof_bparams ps,`BTYP_void)
  | _ -> failwith "Only function and procedure types handles by get_type"


(* vs here is the (name,index) list of type variables *)
let gen_function syms (child_map,bbdfns) all_closures index id vs bps ret' ts instance_no =
  let ps = map (fun (id,(ix,t)) -> id,t) bps in
  if syms.compiler_options.print_flag then
  print_endline 
  (
    "//Generating function inst " ^ 
    si instance_no ^ "=" ^ 
    id ^ "<" ^si index^">" ^
    (
      if length ts = 0 then "" 
      else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
    )
  );
  let argtype = lower(typeof_bparams bps) in
  if length ts <> length vs then 
  failwith 
  (
    "[gen_function} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let argtype = reduce_type (lstrip syms.dfns (tsubst vs ts argtype)) in
  let ret = lower ret' in
  let ret = reduce_type (lstrip syms.dfns (tsubst vs ts ret)) in
  let funtype = fold syms.dfns (`BTYP_function (argtype, ret)) in

  let argtypename = cpp_typename syms argtype in
  let funtypename = 
    if IntSet.mem index all_closures then
      try Some (cpp_type_classname syms funtype) 
      with _ -> None 
    else None
  in 
  let display = get_display_list bbdfns index in
  let frame_dcls = 
    "  FLX_FMEM_DECL\n"
  in
  let display_string = match display with
    | [] -> ""
    | display -> 
      cat "" 
      (
        map
        (fun (i, vslen) -> 
         try
         let instname = cpp_instance_name syms bbdfns i (list_prefix ts vslen) in
         "  " ^ instname ^ " *ptr" ^ instname ^ ";\n"
         with _ -> failwith "Can't cal display name"
         )
        display
      )
  and ctor_dcl name =  
    "  " ^name^
    (if length display = 0 
    then "(FLX_FPAR_DECL_ONLY);\n"
    else (
    "  (\n" ^
    "    FLX_FPAR_DECL\n " ^
    cat ",\n"
      (
        map 
        (
          fun (i,vslen) -> 
          let instname = cpp_instance_name syms bbdfns i (list_prefix ts vslen) in
          "    " ^ instname ^ "*"
        )
        display
      )^
      "\n  );\n" 
    ))
  (*
  and dtor_dcl name =
    "  ~" ^ name ^"();\n"
  *)
  in
  let members = find_members syms (child_map,bbdfns) index ts in
  match ret with
  | `BTYP_void ->
    let name = cpp_instance_name syms bbdfns index ts in
    let ctor = ctor_dcl name in
    "struct " ^ name ^
    (match funtypename with 
    | Some x -> ": "^x
    | None -> ": con_t"
    )
    ^
    " {\n" ^
    "  //os frames\n" ^
    frame_dcls ^
    "  //display\n" ^
    display_string ^ "\n" ^
    members ^
    "  //constructor\n" ^
    ctor ^
    (
      if IntSet.mem index all_closures then
      "  //clone\n" ^
      "  " ^name^"* clone()const;\n" 
      else ""
    )
    ^
    "  //call\n" ^
    (if argtype = `BTYP_tuple [] 
    then
    "  con_t *call(con_t*);\n" 
    else
    "  con_t *call(con_t*,"^argtypename^" const &);\n"
    ) ^
    "  //resume\n" ^
    "  con_t *resume();\n"  ^
    "};\n"

  | _ ->
    let name = cpp_instance_name syms bbdfns index ts in
    let rettypename = cpp_typename syms ret in
    let ctor = ctor_dcl name in
    "struct " ^ name ^
    (match funtypename with 
    | Some x -> ": "^x
    | None -> ""
    )
    ^
    " {\n" ^
    "  //os frames\n" ^
    frame_dcls ^
    "  //display\n" ^
    display_string ^ "\n" ^
    members ^
    "  //constructor\n" ^
    ctor ^
    (
      if IntSet.mem index all_closures then
      "  //clone\n" ^
      "  " ^name^"* clone()const;\n" 
      else ""
    )
    ^
    "  //apply\n" ^
    "  "^rettypename^" apply(" ^
    (if argtype = `BTYP_tuple[] then ""
    else argtypename^" const &")^ 
    ");\n"  ^
    "};\n"


(* This code generates the class declarations *)
let gen_functions syms (child_map,bbdfns) all_closures = 
  let xxdfns = ref [] in
  Hashtbl.iter
  (fun x i -> 
    (* if proper_descendant syms.dfns parent then  *)
    xxdfns := (i,x) :: !xxdfns
  )
  syms.instances
  ;
  
  let s = Buffer.create 2000 in
  iter
  (fun (i,(index,ts)) ->
    let tss = 
      if length ts = 0 then "" else 
      "[" ^ catmap "," (string_of_btypecode syms.dfns) ts^ "]"
    in
    match Hashtbl.find bbdfns index with (id,parent,sr,entry) -> 
    match entry with
    | `BBDCL_function (props,vs,ps, ret, _) -> 
      bcat s ("\n//------------------------------\n");
      bcat s ("//FUNCTION " ^ qualified_name_of_index syms.dfns index ^ tss ^ "\n");
      bcat s 
      (gen_function syms (child_map,bbdfns) all_closures index id vs ps ret ts i)

    | `BBDCL_procedure (props,vs,ps,_) -> 
      bcat s ("\n//------------------------------\n");
      bcat s ("//PROC " ^ qualified_name_of_index syms.dfns index ^ tss ^ "\n");
      bcat s 
      (gen_function syms (child_map,bbdfns) all_closures index id vs ps `BTYP_void ts i)
    | _ -> () (* bcat s ("//SKIPPING " ^ id ^ "\n") *)
  )
  (sort compare !xxdfns)
  ;
  Buffer.contents s

let gen_ctor syms bbdfns name display funs extra_args extra_inits ts =
  name^"::"^name^
  (if length display + length extra_args = 0 then
  "(FLX_FPAR_DECL_ONLY)"
  else
  "\n  (\n" ^
  "    FLX_FPAR_DECL\n" ^
  cat ",\n"
  (
    map 
    (
      fun (i,vslen) -> 
        let instname = cpp_instance_name syms bbdfns i (list_prefix ts vslen) in
      "    " ^ instname ^ " *pptr" ^ instname
    )
    display
    @
    map
    (
      fun (t,a) -> "    " ^ t ^ " _"^a
    )
    extra_args
  )^
  "\n  )\n" 
  )
  ^
  (if length display + length funs + length extra_args + length extra_inits = 0 then "FLX_FMEM_INIT_ONLY"
  else
  "  FLX_FMEM_INIT " ^
  cat ",\n"
  (
    map 
    (
      fun (i,vslen) -> let instname = cpp_instance_name syms bbdfns i (list_prefix ts vslen) in
      "  ptr" ^ instname ^ "(pptr"^instname^")"
    )
    display
    @
    map 
    (fun (index,t)-> 
      cpp_instance_name syms bbdfns index ts
      ^ "(0)"
    )
    funs
    @
    map 
    (fun (t,a) -> "  " ^a ^ "(_"^a^")")
    extra_args
    @
    map 
    (fun x -> "  " ^x) 
    extra_inits
  )) ^ 
  " {}\n"

(*
let gen_dtor syms bbdfns name display ts =
  name^"::~"^name^"(){}\n"
*)
let is_closure_var bbdfns index =
  let var_type bbdfns index =
    let id,_,entry = 
      try Hashtbl.find bbdfns index
      with Not_found -> failwith ("[var_type] ]Can't get index " ^ si index)
    in match entry with 
    | `BBDCL_var (_,t) 
    | `BBDCL_val (_,t) -> lower t
    | _ -> failwith ("[var_type] expected "^id^" to be variable")
  in
  match var_type bbdfns index with
  | `BTYP_function _ -> true
  | _ -> false
  
let get_var_ref syms bbdfns this index ts : string =
  match 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_var_ref] Can't find index " ^ si index)
  with (id,parent,sr,entry) ->
  (*
  print_endline ("get var ref for " ^ id ^ "<" ^ si index ^ ">["^catmap "," (string_of_btypecode syms.dfns) ts^"]");
  *)
  match entry with
  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t) ->
    begin match parent with
    | None -> (* print_endline "No parent ...?"; *)
      "PTF " ^ cpp_instance_name syms bbdfns index ts
    | Some i -> 
      (*
      print_endline ("Parent " ^ si i);
      *)
      (
        if i <> this 
        then "ptr" ^ cpp_instance_name syms bbdfns i ts ^ "->" 
        else ""
      ) ^
      cpp_instance_name syms bbdfns index ts
    end
  | _ -> failwith ("[get_var_ref(3)] Expected name "^id^" to be variable or value")

let get_var_frame syms bbdfns this index ts : string =
  match 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_var_frame(1)] Can't find index " ^ si index)
  with (id,parent,sr,entry) -> 
  match entry with
  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t) ->
    begin match parent with
    | None -> "0"
    | Some i ->
      if i <> this
      then "ptr" ^ cpp_instance_name syms bbdfns i ts
      else "this"
    end
  | _ -> failwith ("[get_var_frame] Expected name "^id^" to be variable or value")

(* NOTE: it isn't possible to pass an explicit tuple as a single 
argument to a primitive, nor a single value of tuple/array type.
In the latter case a cast/abstraction can defeat this, for the
former you'll need to make a dummy variable.
*)

let shape_of bbdfns tn t =
  match t with
  | `BTYP_inst (i,ts) ->
    let id,parent,sr,entry = Hashtbl.find bbdfns i in
    begin match entry with
    | `BBDCL_union (vs,idts) ->
      let varmap = mk_varmap vs ts in
      let cpts = map (fun (_,t) -> varmap_subst varmap t) idts in
      if all_voids cpts then "_int_ptr_map"
      else "_uctor_ptr_map"
     | _ -> tn t ^ "_ptr_map"
     end
  | `BTYP_pointer _ -> "_ref_ptr_map"
  | _ -> tn t ^ "_ptr_map"
  
let gen_prim_call 
  syms bbdfns tsub ge ct ts (arg,argt as a) ret sr sr2 prec
=
  (*
  print_endline ("ts= "^catmap "," (sbt syms.dfns) ts);
  print_endline ("argt = " ^ sbt syms.dfns argt);
  *)
  let tn t = cpp_typename syms t in
  let rt t = reduce_type (lstrip syms.dfns (tsub t)) in
  let rtn t = tn (rt t) in

  let ts = map rtn ts in
  let argt = rt argt in
  let tt = tn argt in
  let sh t = shape_of bbdfns tn t in
  let ashape = sh argt in

  match arg,argt with

  (* the argument is explicitly a tuple *)
  | (`BEXPR_tuple es,_) ->
    let ess = map (ge sr) es in
    let ets,ashapes = 
      match argt with
      | `BTYP_tuple typs -> map rtn typs, map sh typs
      | `BTYP_array (t,`BTYP_unitsum n) ->
        let t = tn t 
        and s = sh t
        in rev_map (fun _ -> t) (nlist n), rev_map (fun _ -> s) (nlist n)
      | _ -> assert false
    in
    csubst sr sr2 ct ess ets tt ret ts prec ashape ashapes
  
  (* the argument isnt a tuple, but the type is *)
  | (_,`BTYP_tuple typs) as x ->
    let n = length typs in
    let typs = map rt typs in
    let es = 
      map2 
      (fun i t -> `BEXPR_get_n (i,x),t) 
      (nlist n) typs
    in
    let ess = map (ge sr) es in
    let ets = map tn typs in
    csubst sr sr2 ct ess ets tt ret ts prec ashape (map sh typs)

  (* the argument isnt a tuple, but the type is an array *)
  | (_,(`BTYP_array(t,`BTYP_unitsum n) as ta)) as x ->
    let t = rt t in
    let typs = map (fun _ -> rt t) (nlist n) in
    let es = 
      map 
      (fun i -> `BEXPR_get_n (i,x),t) 
      (nlist n)
    in
    let ess = map (ge sr) es in
    let ets = map tn typs in
    csubst sr sr2 ct ess ets tt ret ts prec ashape (map sh typs)

  (* the argument isn't an explicit tuple, and the type
     is neither an array nor tuple
  *)
  | (_,typ) -> 
    let a = ge sr a in
    csubst sr sr2 ct [a] [tt] tt ret ts prec ashape [ashape]

let strd the_display =
  if length the_display = 0 then
  "(FLX_FPAR_PASS_ONLY)"
  else
  "(FLX_FPAR_PASS " ^ cat ", " the_display ^ ")"
 
let rec gen_expr' syms bbdfns this (e,t) vs ts sr : cexpr_t =
  (*
  print_endline ("Generating expression " ^ string_of_bound_expression_with_type syms.dfns (e,t));
  *)
  let ge' e = gen_expr' syms bbdfns this e vs ts sr in
  let ge e = gen_expr syms bbdfns this e vs ts sr in
  let ge'' sr e = gen_expr' syms bbdfns this e vs ts sr in
  if length ts <> length vs then 
  failwith 
  (
    "[gen_expr} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let tsub t = reduce_type (tsubst vs ts t) in
  let tn t = cpp_typename syms (tsub (lower t)) in
  let raw_typename t = cpp_typename syms (tsubst vs ts (lower t)) in
  let ge_arg a = 
    match a with
    | _,`BTYP_tuple [] -> ""
    | x -> ge x 
  in
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_expr] Can't find this = " ^ si this)
  in
  let our_display = get_display_list bbdfns this in
  let our_level = length our_display in
  let rt t = reduce_type (lstrip syms.dfns (tsub t)) in
  let t = rt t in
  match e with
  | `BEXPR_parse ((_,t')as e,ii) -> 
    let pn = Hashtbl.find syms.parsers (this,t',ii) in
    let ln = Hashtbl.find syms.lexers (this,e) in
    let the_display = 
      let d' = 
        map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
        our_display
      in 
        if length d' > our_level
        then "this" :: tl d'
        else d'
    in

    let pdisplay = strd the_display in
    let ldisplay = strd (the_display @[ge e]) in
    let callstr = 
    "(Elk_" ^ si pn ^ pdisplay ^
    ".apply((new ElkLex_" ^ si ln^ldisplay^")->init()))"
    in
      print_endline ("Parse call : " ^ callstr);
      ce_atom callstr

  | `BEXPR_expr (s,_) -> ce_top s

  | `BEXPR_get_n (n,(e',t as e)) -> 
    begin match rt t with
    | `BTYP_array (_,`BTYP_unitsum _) -> 
      ce_dot (ge' e) ("data["^si n^"]")
    | _ -> ce_dot (ge' e) ("mem_" ^ si n)
    end

  | `BEXPR_match_case (n,((e',t') as e)) -> 
    if is_unitsum t' then
      ce_infix "==" (ge' e) (ce_atom (si (n-1)))
    else
      ce_infix "==" 
      (ce_dot (ge' e) "variant")
      (ce_atom (si (n-1)))

  | `BEXPR_case_arg (n,e) ->
    let cast = tn t ^ "*" in
    ce_prefix "*" (ce_cast cast (ce_dot (ge' e) "data"))
     
  | `BEXPR_deref ((`BEXPR_ref index),`BTYP_pointer t) -> 
    ge' (`BEXPR_name index,t)

  | `BEXPR_deref e -> 
    let cast = tn t ^ "*" in
    ce_prefix "*" (ce_cast cast (ce_dot (ge' e) "data"))

  | `BEXPR_literal v ->
    if is_native_literal v
    then ce_atom (cstring_of_literal v)
    else
    let t = tn t in
    ce_atom (t ^ "(" ^ cstring_of_literal v ^ ")")
    
  | `BEXPR_case (v,t') ->
    begin match unfold syms.dfns t' with
    | `BTYP_unitsum n ->
      if v<1 or v>n
      then 
        failwith 
        (
          "Invalid case index " ^ si v ^
          " of " ^ si n ^ " cases  in unitsum"
        )
     else ce_atom (si (v-1))

    | `BTYP_sum ls ->
       let s = 
         let n = length ls in
         if v<1 or v>n
         then 
           failwith 
           (
             "Invalid case index " ^ si v ^
             " of " ^ si n ^ " cases"
           )
         else let t' = nth ls (v-1) in
         if t' = `BTYP_tuple []
         then (* closure of const ctor is just the const value ???? *)
           if is_unitsum t then
             si (v-1)
           else
             "_uctor_(" ^ si (v-1) ^ ",0)"
         else 
           failwith 
           ( 
              "Can't handle closure of case " ^ 
              si v ^ 
              " of " ^
              string_of_btypecode syms.dfns t
           )
       in ce_atom s
       (* "(" ^ tn (lower t) ^ "*)_uctor_" *)

    | _ -> failwith "Case tag must have sum type"
    end 
   
  | `BEXPR_name (index,ts') -> 
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> 
        match Hashtbl.find syms.dfns index with
        {id=id; sr=sr} -> syserr sr
        ("[gen_expr(name)] Can't find "^ id ^ "<" ^ si index ^ ">")
    in
    let ts = map tsub ts' in
    begin match entry with
      | `BBDCL_var (_,t)
      | `BBDCL_val (_,t) ->
          ce_atom (get_var_ref syms bbdfns this index ts)

      | `BBDCL_const (_,_,ct,_) -> 
        let ts = map tn ts in
        csubst sr sr2 ct [] [] "Error" "Error" ts "expr" "Error" ["Error"]

      | `BBDCL_cstruct _ 
      | `BBDCL_struct _ 
      | `BBDCL_function _
      | `BBDCL_procedure _ 
      | `BBDCL_fun _
      | `BBDCL_proc _ ->
         failwith 
         (
           "[gen_expr: name] Open function '" ^ 
           id ^ "'<"^si index^
           "> in expression (closure required)"
         )
      | _ -> 
        failwith 
        (
          "[gen_expr: name] Cannot use this kind of name '"^
          id^"' in expression"
        )
    end

  | `BEXPR_closure (index,ts') -> 
    let id,parent,sr,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    (*
    Should not be needed now .. 
    let ts = adjust_ts syms index ts' in
    *)
    let ts = map tsub ts' in
    begin match entry with
    | `BBDCL_function _ 
    | `BBDCL_procedure _ ->
      let the_display = 
        let d' = 
          map (fun (i,vslen) -> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")" ^ strd the_display ^")"
      )

    | `BBDCL_cstruct _ 
    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith ("[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression")
    end

  | `BEXPR_ref (index,ts') -> 
    let ts = map tsub ts' in
    let t = lower t in
    let ref_type = tn (lower t) in
    let var_ptr = "&" ^ get_var_ref syms bbdfns this index ts  in
    let frame_ptr = get_var_frame syms bbdfns this index ts in
    let reference = ref_type ^ 
      "(" ^ frame_ptr ^ ", " ^ var_ptr ^ ")" 
    in
    ce_atom reference

  | `BEXPR_apply 
     (
       (`BEXPR_case (v,t),t'),
       (a,t'') 
     ) ->
       (* t is the type of the sum, 
          t' is the function type of the constructor,
          t'' is the type of the argument
       *)
       let 
         arg_typename = tn (lower t'') 
       and
         union_typename = tn (lower t)
       in
       let aval = 
         "new (gc, "^arg_typename^"_ptr_map) " ^
         arg_typename ^ "(" ^ ge (a,t'') ^ ")"
       in
       let uval = "_uctor_(" ^ si (v-1) ^ ", " ^ aval ^")" in
       let s = "(" ^ union_typename ^ ")" ^ uval in
       ce_atom s

       (*
       failwith 
       (
         "Trapped application, case " ^ 
         si v ^
         " of " ^ string_of_btypecode syms.dfns t ^
         "\ntype " ^ string_of_btypecode syms.dfns t' ^
         "\nargument=" ^ 
         string_of_bound_expression syms.dfns (a,t'') ^
         "\ntype " ^ string_of_btypecode syms.dfns t''
       )
      *) 


  | `BEXPR_apply_prim (index,ts,(arg,argt as a)) ->
    let argt = tsub argt in
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct,_,prec) -> 
      if length vs <> length ts then
      failwith 
      (
        "[get_expr:apply closure of fun] function " ^ 
        id ^ "<" ^ si index ^">" ^
        ", wrong number of args, expected vs = " ^ 
        si (length vs) ^ 
        ", got ts=" ^ 
        si (length ts)
      );
      let ts = map tsub ts in
      let retyp = reduce_type (lstrip syms.dfns (tsubst vs ts retyp)) in
      let retyp = tn retyp in
      gen_prim_call syms bbdfns tsub ge'' ct ts (arg,argt) retyp sr sr2 prec

    (* not sure whether these will be prims or directs or what .. *)
    | `BBDCL_cstruct (vs,_) ->
     ce_atom ("(*("^ id ^"*)(void*)&(" ^ ge a ^ "))")
       
    (* not sure whether these will be prims or directs or what .. *)
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then
        (* argument must be an lvalue *)
        ce_atom ("(*("^ name ^"*)(void*)&(" ^ ge a ^ "))")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    (* but can't be a Felix function *)
    | _ -> 
      failwith 
      (
        "[gen_expr: apply prim] Expected '"^id^"' to be primitive function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply_direct (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_function (props,vs,ps,retyp,_) ->
      let ts = map tsub ts in
      let the_display = 
        let d' = 
          map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")"^ strd the_display ^")"^
      "\n      ->apply(" ^ ge_arg a ^ ")"
      )

    | `BBDCL_cstruct (vs,_) ->
      ce_atom ( "(*("^ id ^"*)(void*)&(" ^ ge a ^ "))")
       
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then 
        (* argument must be an lvalue *)
        ce_atom ("(*("^ name ^"*)(void*)&(" ^ ge a ^ "))")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    | `BBDCL_fun _ ->
      ge' (`BEXPR_apply_prim (index,ts,a),t)

    | `BBDCL_nonconst_ctor (vs,uidx,udt,cidx,ct) ->
      let ts = map tsub ts in
      let ct = reduce_type (tsubst vs ts ct) in
      let ctt = tn ct in
      let ptrmap = shape_of bbdfns tn ct in 
      ce_atom (
        "(_uctor_(" ^ si cidx ^ ", new(gc,"^ ptrmap^")"^
        ctt ^"("^ ge a ^")))"
      )

    | _ -> 
      failwith 
      (
        "[gen_expr: apply_direct] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply_stack (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_function (props,vs,ps,retyp,_) ->
      let ts = map tsub ts in
      let the_display = 
        let d' = 
          map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      let s = 
      name^ strd the_display 
      ^
      "\n      .apply(" ^ ge_arg a ^ ")"
      in ce_atom s

    | `BBDCL_cstruct (vs,_) ->
       ce_atom (
         "(*("^ id ^"*)(void*)&(" ^ ge a ^ "))"
       )
       
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then
        (* argument must be an lvalue *)
        ce_atom ("(*("^ name ^"*)(void*)&(" ^ ge a ^ "))")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    | _ -> 
      failwith 
      (
        "[gen_expr: apply_direct] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply ((`BEXPR_closure (index,ts),_),a) ->
    assert false (* should have been factored out *)

  (* General application*)
  | `BEXPR_apply (f,a) ->
    ce_atom (
    (ge f) ^ "->clone()\n      ->apply(" ^ ge_arg a ^ ")"
    )

  | `BEXPR_tuple es ->
    (* just apply the tuple type ctor to the arguments *)
    begin match t with
    | `BTYP_array (t',`BTYP_unitsum n) ->
      let tuple = 
        let t'' = `BTYP_tuple (map (fun _ -> t') (nlist n)) in
        let ctyp = raw_typename t'' in
        ce_atom (
        ctyp ^ "(" ^
        cat ", " (map ge es) ^
        ")"
        )
      in
        (* cast a tuple which is an array type to an array *)
        let atyp = tn (lower t) in
        ce_cast 
          (atyp ^ "&")
          (ce_infix "," (ce_atom "0") tuple)

    | `BTYP_tuple _ ->
      let ctyp = tn (lower t) in
      ce_atom (
      ctyp ^ "(" ^
      cat ", " (map ge es) ^
      ")"
      )
    | _ -> assert false
    end

and gen_expr syms bbdfns this e vs ts sr =
  let e = Flx_maps.reduce_tbexpr bbdfns e in
  let s = 
    try gen_expr' syms bbdfns this e vs ts sr  
    with Unknown_prec p -> clierr sr 
    ("[gen_expr] Unknown precedence name '"^p^"' in " ^ sbe syms.dfns e)
  in
  string_of_cexpr s

let gen_elk_lexer filebase module_name syms bbdfns this sr ((_,t') as e) n  =
  let lexer_name = "ElkLex_"^si n in
  let ge e = gen_expr syms bbdfns this e [] [] sr in
  let tn t = cpp_typename syms t in
  let get_token_fun_type = tn t' in

  let display = get_display_list bbdfns this in
  let frame_dcls = 
    "  FLX_FMEM_DECL\n"
  in
  let display_string = match display with
    | [] -> ""
    | display -> 
      cat "" 
      (
        map
        (fun (i, vslen) -> 
         try
         let instname = cpp_instance_name syms bbdfns i [] in
         "  " ^ instname ^ " *ptr" ^ instname ^ ";\n"
         with _ -> failwith "Can't cal display name"
         )
        display
      )
  and ctor_dcl =  
    "  "^lexer_name ^ 
    (if length display = 0 
    then "(FLX_FPAR_DECL "^get_token_fun_type^");\n"
    else (
    "  (\n" ^
    "    FLX_FPAR_DECL\n " ^ get_token_fun_type ^ ",\n" ^
    cat ",\n"
      (
        map 
        (
          fun (i,vslen) -> 
          let instname = cpp_instance_name syms bbdfns i [] in
          "    " ^ instname ^ "*"
        )
        display
      )^
      ", "^get_token_fun_type ^"\n  );\n" 
    ))
  in
  let filename = filebase ^ "_lexer_" ^ si n ^ ".hpp" in
  if syms.compiler_options.print_flag then
  print_endline ("Generating Elkhound lexer " ^ lexer_name ^ " in " ^ filename);
  
  let f = open_out filename in
  let pe s = output_string f (s ^ "\n") in

  let token_type, token_type_name, token_id, cts =
    match t' with
    | `BTYP_function (`BTYP_tuple [],`BTYP_inst(i,[])) ->
      let id,parent,sr',entry = Hashtbl.find bbdfns i in
      let token_type = `BTYP_inst(i,[]) in
      let token_type_name = tn token_type in
      begin match entry with
      | `BBDCL_union ([],cts) -> token_type, token_type_name, id, cts
      | _ -> assert false
      end
    | _ -> assert false
  in
  pe ("#ifndef ELKLEX_"^si n);
  pe ("#define ELKLEX_"^si n);
  pe "#include \"elk_lexerint.h\"";
  pe "";
  pe ("struct "^lexer_name^": public LexerInterface {");
  pe frame_dcls;
  pe display_string;
  pe ctor_dcl;
  pe ("  collector_t &gc;");
  pe ("  " ^ get_token_fun_type ^ " get_token;");
  pe "  void setToken();";
  pe "  static void nextToken(LexerInterface *lex);";
  pe "  NextTokenFunc getTokenFunc() const { return &nextToken; }";
  pe ("  "^lexer_name^" *init();");
  pe "  string tokenDesc() const;";
  pe "  string tokenKindDesc(int kind) const;";
  pe "};";
  pe "#endif";
  close_out f;

  let filename = filebase ^ "_lexer_" ^ si n ^ ".cpp" in
  let f = open_out filename in
  let pe s = output_string f (s ^ "\n") in
  pe ("#include \""^module_name^"_lexer_"^si n^".hpp\"");
  pe ("//token type = " ^ token_type_name);
  pe ("static char *"^token_id^"_desc["^si (length cts)^"]={");
  iter (fun (nm,_) -> pe ("   \""^nm^"\",")) cts;
  pe ("};");
  pe "";
  pe (gen_ctor syms bbdfns lexer_name display [] [get_token_fun_type,"get_token"] ["gc(*PTF gc)"] []);
  pe ("string " ^ lexer_name ^ "::tokenDesc() const { return tokenKindDesc(type); }");
  pe "";
  pe ("string " ^ lexer_name ^ "::tokenKindDesc(int kind) const {");
  pe ("  return "^token_id^"_desc[kind];");
  pe ("}");
  pe "";
  pe ("void " ^ lexer_name ^ "::setToken() {");
  pe ("  _uctor_ token = get_token->apply();");
  pe ("  type = token.variant;");
  pe ("  sval =  (SemanticValue)token.data;");
  pe ("}");
  pe "";
  pe ("void " ^ lexer_name ^ "::nextToken(LexerInterface *lex) {");
  pe ("  (("^lexer_name^"*)lex)->setToken();");
  pe ("}");
  pe "";
  pe (lexer_name^" *"^lexer_name^"::init(){");
  pe ("  nextToken(this);");
  pe ("  return this;");
  pe ("}");

  close_out f

let gen_elk_parser filebase module_name syms bbdfns this sr t' n ii =
  let filename = filebase ^ "_parser_" ^ si n ^ ".gr" in
  let parser_name = "_" ^ si n in
  if syms.compiler_options.print_flag then
  print_endline ("Generating Elkhound parser " ^ filename)
  ;
  let f = open_out filename in
  let pe s = output_string f (s ^ "\n") in
  let ps s = output_string f s in
  let ge e = gen_expr syms bbdfns this e [] [] sr in
  let tn t = cpp_typename syms (reduce_type t) in
  let string_of_bprod (n,g) =
    (match n with | None -> "" | Some n -> n ^ ":") ^
    (match g with 
    | `Term k ->
      (match Hashtbl.find syms.dfns k with {id=id}->id)
    | `Nonterm (k::_) ->
      (match Hashtbl.find syms.dfns k with {id=id}->id)
    | _ -> assert false
    )
  in
  let print_production (p,xs) =
    match xs with
    | [`BEXE_fun_return (_,((_,t) as e))] ->
      let t = tn t in
      ps ("  -> ");
      ps (catmap " " string_of_bprod p);
      pe "";
      pe "    {";
      pe ("       "^t^" *x = new "^t^"(" ^ ge e ^ ");");
      iter 
      (function 
        | Some n, `Nonterm _ -> pe ("       delete " ^ n^";")
        | _ -> ()
      )
      p;
      pe ("       return x;");
      pe "    }";
    | _ -> assert false 
  in
  let set_of_list ii : IntSet.t = fold_left (fun s elt ->IntSet.add elt s) IntSet.empty ii in
  let nts_of_prod p : IntSetSet.t = 
    fold_left
    (fun x (_,k) -> match k with
      | `Nonterm ii -> IntSetSet.add (set_of_list ii) x
      | `Term _ -> x
    ) 
    IntSetSet.empty 
    p 
  in
  let prod_of_glr i =
    try
    match Hashtbl.find bbdfns i with
    | _,_,_,`BBDCL_glr (_,(p,_)) -> p
    | id,_,_,entry -> failwith
      ("Expected "^si i^"->BBDCL_glr, got " ^ string_of_bbdcl syms.dfns entry i)
    
    with Not_found -> failwith ("Can't find BBDCL_glr " ^ si i)
  in
  let nts_of_glr i : IntSetSet.t = nts_of_prod (prod_of_glr i) in
  let nt_uses x : IntSetSet.t = 
    IntSet.fold 
    (fun i nts ->
      IntSetSet.union nts (nts_of_glr i)
    )
    x 
    IntSetSet.empty 
  in
  let make_closure ii = 
    let been_done = ref (IntSetSet.singleton (set_of_list ii)) in
    let to_do = ref (nt_uses (set_of_list ii)) in
    while not (IntSetSet.is_empty !to_do) do
      let x = IntSetSet.choose !to_do in
      to_do := IntSetSet.remove x !to_do;
      if not (IntSetSet.mem x !been_done) then begin
        been_done := IntSetSet.add x !been_done;
        to_do := IntSetSet.union !to_do (nt_uses x)
      end
    done;
    !been_done
  in
  let print_nonterm x = 
    let j = IntSet.choose x in 
    let id,parent,sr'',entry = Hashtbl.find bbdfns j in
    begin match entry with
    | `BBDCL_glr (t,(p,xs)) ->
      let tt = tn t in
      pe ("nonterm("^tt^"*) "^id^" {");
      IntSet.iter (fun i ->
        let id,parent,sr'',entry = Hashtbl.find bbdfns i in
        match entry with
        | `BBDCL_glr (t,(p,xs)) -> print_production (p,xs)
        | _ -> assert false
      )
      x;
      pe "}";
    | _ -> assert false
    end
  in
  let display = get_display_list bbdfns this in
  let frame_dcls = 
    "  FLX_FMEM_DECL"
  in
  let display_string = match display with
    | [] -> ""
    | display -> 
      cat "" 
      (
        map
        (fun (i, vslen) -> 
         try
         let instname = cpp_instance_name syms bbdfns i [] in
         "  " ^ instname ^ " *ptr" ^ instname ^ ";\n"
         with _ -> failwith "Can't cal display name"
         )
        display
      )
  and ctor_dcl =  
    "  Elk" ^parser_name^
    (if length display = 0 
    then "(FLX_FPAR_DECL_ONLY);\n"
    else (
    "  (\n" ^
    "    FLX_FPAR_DECL\n " ^
    cat ",\n"
      (
        map 
        (
          fun (i,vslen) -> 
          let instname = cpp_instance_name syms bbdfns i [] in
          "    " ^ instname ^ "*"
        )
        display
      )^
      "\n  );\n" 
    ))
  in
    begin match t' with
    | `BTYP_function (`BTYP_tuple [],`BTYP_inst(i,[])) ->
      let id,parent,sr',entry = Hashtbl.find bbdfns i in
      let token_type = `BTYP_inst(i,[]) in
      let token_type_name = tn token_type in
      begin match entry with
      | `BBDCL_union ([],cts) ->
        pe ("//Elkhound parser Elk" ^ parser_name);
        pe ("//Token type " ^ id ^ " -> " ^ token_type_name);
        pe "terminals {";
        let i = ref 0 in
        iter (fun (id,t) -> 
          pe ("  " ^ si !i^" : "^ id ^ ";"); incr i
        ) 
        cts;
      
      pe "";
      iter (fun (id,t) -> 
        if t <> `BTYP_void then
        pe ("  token("^tn t^"*) " ^ id ^ ";") 
      )
      cts;
      
      pe "}";
      pe "";
      pe ("context_class Elk"^parser_name^": public UserActions {");
      pe ("public:");
      pe frame_dcls;
      ps display_string;
      pe ctor_dcl;
      pe ("  collector_t &gc;");
      pe "  _uctor_ apply(LexerInterface *lex);";
      pe "};";
      pe "";
      pe "impl_verbatim {";
      pe (gen_ctor syms bbdfns ("Elk"^parser_name) display [] [] ["gc(*PTF gc)"] []);
      pe "}";
      pe "";
      pe "impl_verbatim {";
      pe "// Felix function to apply the parser to a lexer";
      pe "// This returns a polymorphic option";
      pe "// case 0- Parse failed";
      pe "// case 1- Argument contains parser result";
      pe ("_uctor_ Elk"^parser_name^"::apply(LexerInterface *lex) {");
      pe "  _uctor_ result(0,0);";
      pe "  result.variant = ";
      pe "    !GLR(this,this->makeTables())";
      pe "    .glrParse(*lex,*(SemanticValue*)(result.data))";
      pe "  ;";
      pe "  return result;";
      pe "  }";
      pe "}";
      pe "";

      let j = hd ii in 
      let id,parent,sr'',entry = Hashtbl.find bbdfns j in
      begin match entry with
      | `BBDCL_glr (t,(p,xs)) ->
        let tt = tn t in
        pe ("nonterm("^tt^"*) elk"^parser_name^" {");
        print_production (p,xs);
        iter (fun i ->
          let id,parent,sr'',entry = Hashtbl.find bbdfns i in
          match entry with
          | `BBDCL_glr (t,(p,xs)) -> print_production (p,xs)
          | _ -> assert false
        )
        (tl ii)
        ;
        pe "}";
        let cls = make_closure ii in
        IntSetSet.iter print_nonterm cls;
        pe "//End grammar"

      | _ -> assert false (* must be glr *)
      end

    | _ -> 
      clierr sr 
      "Parser function must have unit domain and return a non-polymorphic union"
    end
  | _ -> 
    clierr sr 
    "Parser function must have unit domain and return a non-polymorphic union"
  end
  ;
  close_out f
  ;
  let retval = Unix.system("flx_elkhound " ^ filename) in
  begin match retval with
  | Unix.WEXITED 0 -> ()
  | _ -> failwith "Error executing flx_elkhound"
  end


type kind_t = Function | Procedure
 
let gen_exe filename syms 
  (child_map,bbdfns) (label_map,label_usage_map) 
  counter this vs ts instance_no needs_switch (exe:bexe_t) : string =
  if length ts <> length vs then 
  failwith 
  (
    "[gen_exe} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let sr = ("dummy",0,0,0,0) in
  let src_str = string_of_bexe syms.dfns 0 exe in
  (*
  print_endline ("generating exe " ^ string_of_bexe syms.dfns 0 exe);
  print_endline ("vs = " ^ catmap "," (fun (s,i) -> s ^ "->" ^ si i) vs);
  print_endline ("ts = " ^ catmap ","  (string_of_btypecode syms.dfns) ts);
  *)
  let tsub t = reduce_type (tsubst vs ts t) in
  let ge sr e : string = gen_expr syms bbdfns this e vs ts sr in
  let ge' sr e : cexpr_t = gen_expr' syms bbdfns this e vs ts sr in
  let tn t : string = cpp_typename syms (reduce_type (tsubst vs ts (lower t))) in
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_exe] Can't find this " ^ si this)
  in
  let our_display = get_display_list bbdfns this in
  let kind = match entry with
    | `BBDCL_function (_,_,_,_,_) -> Function
    | `BBDCL_procedure (_,_,_,_) -> Procedure
    | _ -> failwith "Expected executable code to be in function or procedure"
  in let our_level = length our_display in

  let handle_closure sr is_jump index ts subs a =
    let subs = 
      catmap ""
      (fun ((_,t) as e,s) ->
        let t = cpp_ltypename syms t in
        let e = ge sr e in
        "      " ^ t ^ " " ^ s ^ " = " ^ e ^ ";\n"
      )
      subs
    in
    let sub_start =
      if String.length subs = 0 then ""
      else "      {\n" ^ subs
    and sub_end =
      if String.length subs = 0 then ""
      else "      }\n"
    in
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_exe(call)] Can't find index " ^ si index)
    in
    begin 
    match entry with
    | `BBDCL_proc (vs,_,ct,_) -> 
      assert (not is_jump);

      if length vs <> length ts then
      clierr sr "[gen_prim_call] Wrong number of type arguments"
      ;
      let s = gen_prim_call syms bbdfns tsub ge' ct ts a "Error" sr sr2 "atom" in
      let s = sc "expr" s in
      "      // " ^ src_str ^ "\n" ^
      sub_start ^
      "      " ^ s ^ "\n" ^
      sub_end


    | `BBDCL_procedure (props,vs,ps,bexes) ->
      if bexes = []
      then 
      "      //call to empty procedure " ^ id ^ " elided\n"
      else begin
        let n = !counter in
        incr counter;
        let the_display = 
          let d' = 
            map (fun (i,vslen) -> "ptr"^cpp_instance_name syms bbdfns i (list_prefix ts vslen))
            (get_display_list bbdfns index)
          in 
            if length d' > our_level
            then "this" :: tl d'
            else d'
        in
        (* if we're calling from inside a function,
           we pass a 0 continuation as the caller 'return address'
           otherwise pass 'this' as the caller 'return address'
        *)
        let this = match kind with
          | Function -> 
            if is_jump 
            then 
              clierr sr "can't jump inside function" 
            else "0"
          | Procedure -> 
            if is_jump then "tmp"
            else "this"
        in

        let args = match a with
          | _,`BTYP_tuple [] -> this
          | _ -> this ^ ", " ^ ge sr a
        in

        let name = cpp_instance_name syms bbdfns index ts in
        let ptrmap = name ^ "_ptr_map" in
        begin 
          match kind with
          | Function ->
            "      //run procedure " ^ src_str ^ "\n" ^
            "      {\n" ^
            subs ^
            "      con_t *_p =\n" ^
            "      (FLX_NEWP(" ^ name ^ ")" ^ strd the_display ^ ")\n" ^
            "      ->call(" ^ args ^ ");\n" ^
            "      while(_p) _p=_p->resume();\n" ^
            "      }\n"

          | Procedure ->
            let call_string =
              "      return (FLX_NEWP(" ^ name ^ ")"^strd the_display ^ ")" ^
              "\n      ->call(" ^ args ^ ");\n"
            in
            if is_jump
            then
              "      //jump to procedure " ^ src_str ^ "\n" ^
              "      {\n" ^
              subs ^
              "      con_t *tmp = _caller;\n" ^
              "      _caller = 0;\n" ^
              call_string ^
              "      }\n"
            else
            (
              needs_switch := true;
              "      //call procedure " ^ src_str ^ "\n" ^
              sub_start ^
              "      FLX_SET_PC(" ^ si n ^ ")\n" ^
              call_string ^
              sub_end ^
              "    FLX_CASE_LABEL(" ^ si n ^ ")\n"
            )
        end
      end

    | _ -> 
      failwith 
      (
        "[gen_exe] Expected '"^id^"' to be procedure constant, got " ^
        string_of_bbdcl syms.dfns entry index 
      )
    end
  in
  let gen_nonlocal_goto pc frame s =
    (* WHAT THIS CODE DOES: we pop the call stack until
       we find the first ancestor containing the target label,
       set the pc there, and return its continuation to the
       driver; we know the address of this frame because
       it must be in this function's display.
    *)
    let target_instance = 
      try Hashtbl.find syms.instances (frame, ts) 
      with Not_found -> failwith "Woops, bugged code, wrong type arguments for instance?"
    in
    let frame_ptr = "ptr" ^ cpp_instance_name syms bbdfns frame ts in
    "      // non local goto " ^ s ^ "\n" ^
    "      {\n" ^
    "        con_t *tmp1 = this;\n" ^
    "        while(tmp1 && " ^ frame_ptr ^ "!= tmp1)\n" ^
    "        {\n" ^
    "          con_t *tmp2 = tmp1->_caller;\n" ^
    "          tmp1 -> _caller = 0;\n" ^
    "          tmp1 = tmp2;\n" ^
    "        }\n" ^
    "      }\n" ^
    "      " ^ frame_ptr ^ "->pc = FLX_FARTARGET("^si pc^","^si target_instance^","^s^");\n" ^
    "      return " ^ frame_ptr ^ ";\n"
  in
  let rec gexe exe = 
    match exe with
    | `BEXE_code (_,s) -> s
    | `BEXE_nonreturn_code (_,s) -> s
    | `BEXE_comment (_,s) -> "\n/*" ^ s ^ "*/\n"
    | `BEXE_label (_,s) -> 
      let local_labels = 
        try Hashtbl.find label_map this 
        with _ -> failwith ("[gen_exe] Can't find label map of " ^ si this)
      in
      let label_index = 
        try Hashtbl.find local_labels s 
        with _ -> failwith ("[gen_exe] In " ^ id ^ ": Can't find label " ^ s)
      in
      let label_kind = get_label_kind_from_index label_usage_map label_index in
      (match kind with
        | Procedure ->
          begin match label_kind with
          | `Far ->
            needs_switch := true;
            "    FLX_LABEL(" ^ si label_index ^ ","^si instance_no ^","^s^")\n" 
          | `Near ->
            "    " ^ s ^ ":;\n"
          | `Unused -> ""
          end

        | Function ->
          begin match label_kind with
          | `Far -> assert false
          | `Near ->
            "    " ^ s ^ ":;\n"
          | `Unused -> ""
          end
      )

    (* FIX THIS TO PUT SOURCE REFERENCE IN *)
    | `BEXE_halt (sr,s) -> 
       "      // halt " ^ s ^ "\n" ^
       "      throw flx::rtl::flx_exec_failure(\n" ^
       "        \"" ^ filename ^ "\",\n" ^
       "        \"halt\",\n" ^
       "        " ^ s ^ ",\n" ^
       "      );\n"

    | `BEXE_goto (sr,s) -> 
      begin match find_label bbdfns label_map this s with
      | `Local _ -> "      goto " ^ s ^ ";\n"
      | `Nonlocal (pc,frame) -> gen_nonlocal_goto pc frame s
      | `Unreachable -> 
        clierr sr ("Jump to unreachable label " ^ s)
      end

    | `BEXE_ifgoto (sr,e,s) -> 
      begin match find_label bbdfns label_map this s with
      | `Local _ -> 
        "      if(" ^ ge sr e ^ ")goto " ^ s ^ ";\n"
      | `Nonlocal (pc,frame) ->
        let skip = "_" ^ si !(syms.counter) in
        incr syms.counter;
        let not_e = ce_prefix "!" (ge' sr e) in
        let not_e = string_of_cexpr not_e in
        "      if("^not_e^")goto " ^ skip ^ ";\n"  ^
        gen_nonlocal_goto pc frame s ^
        "    " ^ skip ^ ":;\n"
         
      | `Unreachable -> 
        clierr sr ("Jump to unreachable label " ^ s)
      end

    | `BEXE_ifnotgoto (sr,e,s) ->
      begin match find_label bbdfns label_map this s with
      | `Local _ -> 
        let not_e = ce_prefix "!" (ge' sr e) in
        let not_e = string_of_cexpr not_e in
        "      if("^not_e^")goto " ^ s ^ ";\n" 

      | `Nonlocal (pc,frame) ->
        let skip = "_" ^ si !(syms.counter) in
        incr syms.counter;
        "      if(" ^ ge sr e ^ ")goto " ^ skip ^ ";\n" ^
        gen_nonlocal_goto pc frame  s ^
        "    " ^ skip ^ ":;\n"

      | `Unreachable -> 
        clierr sr ("Jump to unreachable label " ^ s)
      end 
      
    (* Hmmm .. stack calls ?? *)
    | `BEXE_call_stack (sr,index,ts,a)  -> assert false

    | `BEXE_call_prim (sr,index,ts,a)
    | `BEXE_call_direct (sr,index,ts,a) 
    | `BEXE_call (sr,(`BEXPR_closure (index,ts),_),a) ->
      let a = match a with (a,t) -> a, tsub t in
      let subs,x = unravel syms bbdfns a in
      let ts = map tsub ts in
      handle_closure sr false index ts subs x

    | `BEXE_jump (sr,((`BEXPR_closure (index,ts),_)),a) 
    | `BEXE_jump_direct (sr,index,ts,a) ->
      let a = match a with (a,t) -> a, tsub t in
      let subs,x = unravel syms bbdfns a in
      let ts = map tsub ts in
      handle_closure sr true index ts subs x

    | `BEXE_loop (sr,i,a) ->
      let ptr = 
        if i= this then "this"
        else "ptr"^cpp_instance_name syms bbdfns i ts
      in
        print_endline ("Looping to " ^ ptr);
        let args = ptr ^ "->" ^ 
          (match a with
          | _,`BTYP_tuple [] -> "_caller"
          | _ -> "_caller, " ^ ge sr a
          )
        in
        "      //"^ src_str ^ "\n" ^
        (
          if i <> this then
          "      {\n" ^
          "        con_t *res = " ^ ptr ^ "\n      ->call(" ^ args ^");\n" ^
          "        printf(\"unwinding from %p to %p\\n\",this,"^ptr^");\n" ^
          "        con_t *p = this;\n" ^
          "        while(res && res != "^ptr^") { res = p->_caller; printf(\"called by %p\\n\",p); }\n"^
          "        for(con_t *tmp=this; tmp != (con_t*)"^ptr^";){//unwind stack\n" ^
          "           con_t *tmp2 = tmp->_caller;\n" ^
          "           printf(\"unwinding %p, caller is %p\\n\",tmp,tmp2);\n" ^
          "           tmp->_caller = 0;\n" ^
          "           tmp = tmp2;\n"^
          "        }\n" ^
          "        return res;\n" ^
          "      }\n"
          else 
          "      return " ^ ptr ^ "\n      ->call(" ^ args ^");\n"
        )

    (* If p is a variable containing a closure,
       and p recursively invokes the same closure,
       then the program counter and other state 
       of the closure would be lost, so we clone it
       instead .. the closure variables is never
       used (a waste if it isn't re-entered .. oh well)
     *)

    | `BEXE_call (sr,p,a) ->
      let args = 
        let this = match kind with
          | Procedure -> "this"
          | Function -> "0"
        in
        match a with
        | _,`BTYP_tuple [] -> this
        | _ -> this ^ ", " ^ ge sr a
      in
      begin match kind with
      | Function ->
        "      //run procedure " ^ src_str ^ "\n" ^
        "      {\n" ^
        "        con_t *_p = "^ge sr p ^ "->clone()\n      ->call("^args^");\n" ^
        "        while(_p) _p=_p->resume();\n" ^
        "      }\n"
        


      | Procedure ->
        needs_switch := true;
        let n = !counter in
        incr counter;
        "      //"^ src_str ^ "\n" ^
        "      FLX_SET_PC(" ^ si n ^ ")\n" ^
        "      return " ^ ge sr p ^ "->clone()\n      ->call(" ^ args ^");\n" ^
        "    FLX_CASE_LABEL(" ^ si n ^ ")\n"
      end

    | `BEXE_jump (sr,p,a) ->
      let args = match a with
        | _,`BTYP_tuple [] -> "tmp"
        | _ -> "tmp, " ^ ge sr a
      in
      "      //"^ src_str ^ "\n" ^
      "      {\n" ^
      "        con_t *tmp = _caller;\n" ^
      "        _caller=0;\n" ^
      "        return " ^ ge sr p ^ "\n      ->call(" ^ args ^");\n" ^
      "      }\n"

    | `BEXE_proc_return _ -> "      FLX_RETURN\n"

    | `BEXE_read (sr,index) -> 
      let id,parent,sr,entry = 
        try Hashtbl.find bbdfns index 
        with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
      in
      let t =
        match entry with
        | `BBDCL_var (_,t) -> t
        | `BBDCL_val (_,t) -> t
        | _ -> syserr sr "Expected read argument to be variable"
      in
      let n = !counter in incr counter;
      needs_switch := true;
      "      //read variable\n" ^
      "      p_message = &" ^ get_var_ref syms bbdfns this index ts^";\n" ^
      "      action = wait_action;\n" ^
      "      FLX_SET_PC(" ^ si n ^ ")\n" ^
      "      return this;\n" ^
      "    FLX_CASE_LABEL(" ^ si n ^ ")\n"

      
    | `BEXE_regmatch (sr,e,reargs) ->
      let b = Buffer.create 500 in
      Flx_regen.regen b reargs (`regmatch e) (ge sr);
      Buffer.contents b

    | `BEXE_reglex (sr,p1,p2,reargs) ->
      let b = Buffer.create 500 in
      Flx_regen.regen b reargs (`reglex (p1,p2)) (ge sr);
      Buffer.contents b
      
    | `BEXE_fun_return (sr,e) -> 
      let _,t = e in
      "      //" ^ src_str ^ ": type "^tn t^"\n" ^
      "      return "^ge sr e^";\n" 

    | `BEXE_nop (_,s) -> "      //Nop: " ^ s ^ "\n"

    | `BEXE_assign (sr,e1,e2) ->
      "      //"^src_str^"\n" ^
      "      "^ ge sr e1 ^ " = " ^ ge sr e2 ^
      ";\n"
      
    | `BEXE_init (sr,v,e) -> 
      (*
      print_endline ("INIT of " ^ si v ^ " inside " ^ si this);
      *)
      "      //"^src_str^"\n" ^
      "      "^
      get_var_ref syms bbdfns this v ts^ 
      " = " ^ 
      ge sr e ^
      ";\n"
  in gexe exe

let gen_exes filename syms bbdfns display label_info counter index exes vs ts instance_no =
  let needs_switch = ref false in
  let s = cat ""
    (map (gen_exe filename syms bbdfns label_info counter index vs ts instance_no needs_switch) exes)
  in
  s,!needs_switch

(* PROCEDURES are implemented by continuations.
   The constructor accepts the display vector to
   form the closure object. The call method accepts
   the callers continuation object as a return address,
   and the procedure argument, and returns a continuation.
   The resume method runs the continuation until
   it returns a continuation to some object, possibly
   the same object. A flag in the continuation object
   determines whether the yield of control is a request
   for data or not (if so, the dispatcher must place the data
   in the nominated place before calling the resume method again.
*)
 
(* FUNCTIONS are implemented as functoids:
  the constructor accepts the display vector so as
  to form a closure object, the apply method
  accepts the argument and runs the function.
  The machine stack is used for functions.
*)
let gen_function_methods filename syms (child_map,bbdfns) 
  all_closures label_info counter index ts instance_no 
= 
  let id,parent,sr,entry = Hashtbl.find bbdfns index in
  if syms.compiler_options.print_flag then
  print_endline 
  (
    "//Generating function body inst " ^ 
    si instance_no ^ "=" ^ 
    id ^ "<" ^si index^">" ^
    (
      if length ts = 0 then "" 
      else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
    )
  );
  match entry with 
  | `BBDCL_function (props,vs,bps,ret',exes) ->
    if length ts <> length vs then 
    failwith 
    (
      "[get_function_methods} wrong number of args, expected vs = " ^ 
      si (length vs) ^ 
      ", got ts=" ^ 
      si (length ts)
    );
    let argtype = lower (typeof_bparams bps) in
    let argtype = reduce_type (tsubst vs ts argtype) in
    let ret = reduce_type (tsubst vs ts (lower ret')) in
    let funtype = fold syms.dfns (`BTYP_function (argtype, ret)) in

    let argtypename = cpp_typename syms argtype in
    let name = cpp_instance_name syms bbdfns index ts in

    let display = get_display_list bbdfns index in

    let rettypename = cpp_typename syms ret in

    let ctor = 
      let vars =  find_references syms (child_map,bbdfns) index ts in
      let funs = filter 
        (fun (i,t) -> match t with 
        | `BTYP_function _ -> true 
        | _ -> false
        ) vars 
      in
      gen_ctor syms bbdfns name display funs [] [] ts 
    in
    (*
    let dtor = gen_dtor syms bbdfns name display ts in
    *)
    let params = map (fun (id,(ix,t)) -> ix) bps in
    let exe_string,_ =
      try 
        gen_exes filename syms (child_map,bbdfns) display label_info counter index exes vs ts instance_no
      with x -> 
        print_endline (Printexc.to_string x);
        print_endline (catmap "\n" (string_of_bexe syms.dfns 1) exes);
        print_endline "Can't gen exes ..";
        raise x
    in
    let cont = "con_t *" in
    let apply =
      rettypename^ " " ^name^
      "::apply("^
      (if argtype = `BTYP_tuple []
      then ""
      else argtypename ^" const &_arg ")^
      "){\n" ^
      "  collector_t &gc = *PTF gc;\n" ^
      (
        match length params with
        | 0 -> ""
        | 1 -> 
          let i = hd params in
          if Hashtbl.mem syms.instances (i, ts)
          && not (argtype = `BTYP_tuple [])
          then
            "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg;\n"
          else ""
        | _ -> 
          let counter = ref 0 in fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem syms.instances (i,ts)
            then 
              let memexpr =
                match argtype with
                | `BTYP_array _ -> ".data["^si n^"]"
                | `BTYP_tuple _ -> ".mem_"^ si n
                | _ -> assert false
              in
              s ^ "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg"^ memexpr ^";\n"
            else s (* elide initialisation of elided variable *)
          )
          "" params 
      )^
      exe_string ^
      "}\n"
    and clone =
      "  " ^ name ^ "* "^name^"::clone()const {\n"^
      "  return new(*PTF gc,"^name^"_ptr_map) "^name^"(*this);\n"^
      "}\n"
    in
      let q = qualified_name_of_index syms.dfns index in
      "//FUNC " ^ q ^ ": Constructor\n" ^
      ctor^ "\n" ^
      (
        if IntSet.mem index all_closures then
        "\n//FUNC " ^ q ^ ": Clone method\n" ^
        clone^ "\n" 
        else ""
      )
      ^
      "//FUNC " ^ q ^ ": Apply method\n" ^
      apply^ "\n"

  | _ -> failwith "function expected"

let gen_procedure_methods filename syms (child_map,bbdfns) 
  all_closures label_info counter index ts instance_no 
= 
  let id,parent,sr,entry = Hashtbl.find bbdfns index in (* can't fail *)
  if syms.compiler_options.print_flag then
  print_endline 
  (
    "//Generating procedure body inst " ^ 
    si instance_no ^ "=" ^ 
    id ^ "<" ^si index^">" ^
    (
      if length ts = 0 then "" 
      else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
    )
  );
  match entry with 
  | `BBDCL_procedure (props,vs,bps,exes) ->
    if length ts <> length vs then 
    failwith 
    (
      "[get_procedure_methods} wrong number of args, expected vs = " ^ 
      si (length vs) ^ 
      ", got ts=" ^ 
      si (length ts)
    );
    let argtype = lower (typeof_bparams bps) in
    let argtype = reduce_type (tsubst vs ts argtype) in
    let funtype = fold syms.dfns (`BTYP_function (argtype, `BTYP_void)) in

    let argtypename = cpp_typename syms argtype in
    let name = cpp_instance_name syms bbdfns index ts in

    let display = get_display_list bbdfns index in

    let ctor = 
      let vars =  find_references syms (child_map,bbdfns) index ts in
      let funs = filter 
        (fun (i,t) -> match t with 
        | `BTYP_function _ -> true 
        | _ -> false
        ) vars 
      in
      gen_ctor syms bbdfns name display funs [] [] ts 
    in

    (*
    let dtor = gen_dtor syms bbdfns name display ts in
    *)
    let ps = map (fun (id,(ix,t)) -> id,t) bps in
    let params = map (fun (id,(ix,t)) -> ix) bps in

    let exe_string,needs_switch =
      gen_exes filename syms (child_map,bbdfns) display label_info counter index exes vs ts instance_no
    in
    let cont = "con_t *" in
    let arg_sig = 
      match argtype with
      | `BTYP_tuple [] ->
      "  " ^ cont ^ "_ptr_caller"
      | _ ->
      "  " ^ cont ^ "_ptr_caller,\n"^
      "  " ^ argtypename ^" const &_arg\n"
    in
    let call =
      cont ^name^
      "::call(" ^ arg_sig ^ "){\n" ^
      (
        "  _caller = _ptr_caller;\n" ^
        (match length bps with
        | 0 -> ""
        | 1 -> 
          let _,(i,_) = hd bps in
          if Hashtbl.mem syms.instances (i,ts)
          && not (argtype = `BTYP_tuple[])
          then
            "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg;\n"
          else ""

        | _ -> let counter = ref 0 in fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem syms.instances (i,ts)
            then
              let memexpr =
                match argtype with
                | `BTYP_array _ -> ".data["^si n^"]"
                | `BTYP_tuple _ -> ".mem_"^ si n
                | _ -> assert false
              in
              s ^ "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg" ^ memexpr ^";\n"
            else s (* elide initialisation of elided variables *)
          )
          "" params
          ) ^
          "  INIT_PC\n" ^
          "  return this;\n"
      )^
      "}\n"
    and resume = 
      if exes = []
      then
        cont^name^"::resume(){//empty\n"^
        "     FLX_RETURN\n" ^ 
        "}\n"
      else
        cont^name^"::resume(){\n"^
        "  collector_t &gc = *PTF gc;\n" ^
        (if needs_switch then 
        "  FLX_START_SWITCH\n" else ""
        ) ^
        exe_string ^
        "    FLX_RETURN\n" ^ (* HACK .. should be in exe_string .. *)
        (if needs_switch then
        "  FLX_END_SWITCH\n" else ""
        )^
        "}\n" 
    and clone =
      "  " ^name^"* "^name^"::clone()const {\n" ^
        "  return new(*PTF gc,"^name^"_ptr_map) "^name^"(*this);\n" ^
        "}\n"
    in
      let q = 
        try qualified_name_of_index syms.dfns index 
        with Not_found -> 
          si instance_no ^ "=" ^ 
          id ^ "<" ^si index^">" ^
          (
            if length ts = 0 then "" 
            else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
          )
      in
      "\n//PROC " ^ q ^ "\n" ^
      "//PROC " ^ q ^ ": Constructor\n" ^
      ctor^
      (
        if IntSet.mem index all_closures then
        "\n//PROC " ^ q ^ ": Clone method\n" ^
        clone
        else ""
      )
      ^
      "\n//PROC " ^ q ^ ": Call method\n" ^
      call^
      "\n//PROC " ^ q ^ ": Resume method\n" ^
      resume

  | _ -> failwith "procedure expected"


let gen_execute_methods filename syms (child_map,bbdfns) all_closures label_info counter bf =
  let s = Buffer.create 2000 in
  Hashtbl.iter
  (fun (index,ts) instance_no -> 
  let id,parent,sr,entry = Hashtbl.find bbdfns index in 
  begin match entry with
  | `BBDCL_function (props,vs,ps, ret, _) -> 
    bcat s ("//------------------------------\n");
    bcat s (
      gen_function_methods filename syms (child_map,bbdfns) all_closures label_info counter index ts instance_no
    )
    
    
  | `BBDCL_procedure (props,vs,ps,_) -> 
    bcat s ("//------------------------------\n");
    bcat s (
      gen_procedure_methods filename syms (child_map,bbdfns) all_closures label_info counter index ts instance_no
    )
  | _ -> ()
  end
  ;
  output_string bf (Buffer.contents s);
  Buffer.clear s
  )
  syms.instances

let gen_biface_header syms bbdfns biface = match biface with
  | `BIFACE_export_fun (sr,index, export_name) ->
    let id,parent,sr,entry = Hashtbl.find bbdfns index in
    begin match entry with
    | `BBDCL_function (props,vs,ps, ret, _) ->
      let display = get_display_list bbdfns index in
      if length display <> 0
      then clierr sr "Can't export nested function";

      let argtypes = 
        map 
        (fun (_,(_,x)) -> cpp_typename syms x) 
        ps 
      in
      let arglist = "  " ^ 
        (if length argtypes = 0 then "FLX_FPAR_DECL_ONLY"
        else "FLX_FPAR_DECL\n" ^ cat ",\n  " argtypes
        ) 
      in
      let rettypename = cpp_typename syms ret in

      "//EXPORT FUNCTION " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" " ^ rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | `BBDCL_procedure (props,vs,ps, _) ->
      let display = get_display_list bbdfns index in
      if length display <> 0
      then clierr sr "Can't export nested proc";

      let argtypes = 
        map 
        (fun (_,(_,x)) -> cpp_typename syms x) 
        ps 
      in
      let arglist = "  " ^ 
        (if length argtypes = 0 then "FLX_FPAR_DECL_ONLY"
        else "FLX_FPAR_DECL\n" ^ cat ",\n  " argtypes
        ) 
      in
      
      "//EXPORT PROCEDURE " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" con_t * "  ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"
  
    | _ -> failwith "Not implemented: export non-function/procedure"
    end
  
  | `BIFACE_export_type (sr, typ, export_name) ->
    "//EXPORT type " ^ sbt  syms.dfns typ ^ " as " ^ export_name  ^ "\n" ^
    "typedef " ^ cpp_type_classname syms typ ^ " " ^ export_name ^ "_class;\n" ^
    "typedef " ^ cpp_typename syms typ ^ " " ^ export_name ^ ";\n"
      
let gen_biface_body syms bbdfns biface = match biface with
  | `BIFACE_export_fun (sr,index, export_name) ->
    let id,parent,sr,entry = Hashtbl.find bbdfns index in
    begin match entry with
    | `BBDCL_function (props,vs,ps, ret, _) ->
      if length vs <> 0
      then clierr sr ("Can't export generic function " ^ id)
      ;
      let display = get_display_list bbdfns index in
      if length display <> 0
      then clierr sr "Can't export nested function";

      let argtypes = 
        map 
        (fun (id,(ix,t)) -> cpp_typename syms t ^ " " ^ id) 
        ps 
      in
      let arglist = "  " ^ 
        (if length argtypes = 0 then "FLX_FPAR_DECL_ONLY"
        else "FLX_FPAR_DECL\n" ^ cat ",\n  " argtypes
        ) 
      in
      let rettypename = cpp_typename syms ret in
      let class_name = cpp_instance_name syms bbdfns index [] in

      "//EXPORT FUNCTION " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*_PTF gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(_PTFV))\n" ^
      "    ->apply(" ^ cat ", " (map fst ps) ^ ");\n" ^
      "}\n"

    | `BBDCL_procedure (props,vs,ps,_) ->
      if length vs <> 0
      then clierr sr ("Can't export generic procedure " ^ id)
      ;
      let display = get_display_list bbdfns index in
      if length display <> 0
      then clierr sr "Can't export nested function";

      let argtypes = 
        map 
        (fun (id,(_,t)) -> cpp_typename syms t ^ " " ^ id) 
        ps 
      in
      let arglist = "  " ^ 
        (if length argtypes = 0 then "FLX_FPAR_DECL_ONLY"
        else "FLX_FPAR_DECL\n" ^ cat ",\n  " argtypes
        ) 
      in
      let class_name = cpp_instance_name syms bbdfns index [] in

      "//EXPORT PROC " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      "con_t *" ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*_PTF gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(_PTFV))" ^
      "\n      ->call(" ^ cat ", " ("0"::(map fst ps)) ^ ");\n" ^
      "}\n"

    | _ -> failwith "Not implemented: export non-function/procedure"
    end

  | `BIFACE_export_type _ -> ""

let gen_biface_headers syms bbdfns bifaces = 
  cat "" (map (gen_biface_header syms bbdfns) bifaces)

let gen_biface_bodies syms bbdfns bifaces = 
  cat "" (map (gen_biface_body syms bbdfns) bifaces)

@h = tangler('src/flxg.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_srcref
open Flx_desugar
open Flx_bbind
open Flx_name
open Flx_tgen
open Flx_gen
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_exceptions
open Flx_flxopt
open Flx_ogen
;;

let print_help () = print_options(); exit(0)
;;

let reverse_return_parity = ref false
;;

let last_time = ref 0.0
;;
let tim() = 
  let now = (Unix.times()).Unix.tms_utime in
  let elapsed = now -. !last_time in
  last_time := now;
  elapsed
;;

let format_time tm = 
  si (tm.Unix.tm_year + 1900) ^ "/" ^
  si (tm.Unix.tm_mon + 1) ^ "/" ^
  si tm.Unix.tm_mday ^ " " ^
  si tm.Unix.tm_hour ^ ":" ^
  si tm.Unix.tm_min ^ ":" ^
  si tm.Unix.tm_sec 
;;
try
  let compile_start = Unix.time () in
  let compile_start_gm = Unix.gmtime compile_start in
  let compile_start_local = Unix.localtime compile_start in
  let compile_start_gm_string = format_time compile_start_gm ^ " UTC" in
  let compile_start_local_string = format_time compile_start_local ^ " (local)" in
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in
  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

 let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and header_file_name = filebase ^ ".hpp"
  and body_file_name = filebase ^ ".cpp" 
  and report_file_name = filebase ^ ".xref" 
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  let include_dirs =  (* (Filename.dirname input_file_name) :: *) compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in

  (* PARSE THE IMPLEMENTATION FILE *)

  if compiler_options.print_flag
  then print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree = 
    Flx_desugar.include_file syms input_file_name false
  in
  if compiler_options.print_flag
  then print_endline (Flx_print.string_of_compilation_unit parse_tree);

  let parse_time = tim() in
  if compiler_options.print_flag
  then print_endline ("//PARSE OK time " ^ string_of_float parse_time);

  if compiler_options.print_flag 
  then print_endline "//DESUGARING";

  let deblocked = 
    desugar_program syms module_name parse_tree 
  in
  let desugar_time = tim() in
  if compiler_options.print_flag 
  then print_endline ("//DESUGAR time " ^ string_of_float desugar_time);

  (* THIS IS A HACK! *)
  let root = !(syms.counter) in
  if compiler_options.print_flag 
  then print_endline ("//Top level module '"^module_name^"' has index " ^ si root);


  if compiler_options.print_flag 
  then print_endline "//BUILDING TABLES";

  let pubtab, _, exes, ifaces,dirs = 
    build_tables syms "root" 0 None None root deblocked 
  in
  let build_table_time = tim() in
  if compiler_options.print_flag 
  then print_endline ("//BUILDING TABLES time " ^ string_of_float build_table_time);


  if compiler_options.print_flag 
  then print_endline "//BINDING EXECUTABLE CODE"
  ;
  let bbdfns = bbind syms in
  let child_map = cal_children syms bbdfns in
  let bifaces = bind_ifaces syms ifaces in
  Hashtbl.clear syms.ticache;

  let binding_time = tim() in

  if compiler_options.print_flag 
  then print_endline ("//Binding complete time " ^ string_of_float binding_time);

  if compiler_options.print_flag 
  then print_endline "//CHECKING ROOT";

  let root_proc = 
    match 
      try Hashtbl.find syms.dfns root 
      with Not_found ->
        failwith 
        (
          "Can't find root module " ^ si root ^
          " in symbol table?"
        )
    with {id=id; sr=sr; parent=parent;vs=vs;pubmap=name_map;symdef=entry} ->
    begin match entry with
      | `SYMDEF_module -> ()
      | _ -> failwith "Expected to find top level module ''"
    end
    ;
    let entry = 
      try Hashtbl.find name_map "_init_" 
      with Not_found ->
        failwith "Can't find name _init_ in top level module's name map"
    in
    let index = match entry with
      | FunctionEntry [x] -> x
      | FunctionEntry [] -> failwith "Couldn't find '_init_'"
      | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
      | NonFunctionEntry _ -> failwith "_init_ found but not procedure"
    in 
    if compiler_options.print_flag 
    then print_endline ("//root module's init procedure has index " ^ si index);
    index
  in

  if compiler_options.print_flag 
  then print_endline "//OPTIMISING";
  let () = Flx_use.find_roots syms bbdfns root_proc bifaces in
  let bbdfns = Flx_useless.elide_unused syms (child_map,bbdfns) in
  let child_map = cal_children syms bbdfns in
  (*
  let bbdfns = Flx_useless.elide_unused syms (child_map,bbdfns) in
  let child_map = cal_children syms bbdfns in
  *)

  let bbdfns = ref bbdfns in
  let child_map = ref child_map in
  if compiler_options.heavy_inlining then
  begin
    if compiler_options.print_flag then
    print_endline "//INLINING";
    Flx_inline.heavy_inlining syms (!child_map,!bbdfns) root_proc bifaces;
    child_map := cal_children syms !bbdfns;
    bbdfns := Flx_useless.elide_unused syms (!child_map,!bbdfns);
    child_map := cal_children syms !bbdfns
  end
  ;
  let bbdfns = !bbdfns in
  let child_map = !child_map in

  if compiler_options.print_flag 
  then print_endline "//Calculating stackable calls";
  let label_map = Flx_label.create_label_map bbdfns syms.counter in
  let label_usage = Flx_label.create_label_usage bbdfns label_map in
  let label_info = label_map, label_usage in

  let bbdfns = Flx_stack_calls.make_stack_calls syms (child_map,bbdfns) in

  let opt_time = tim() in

  if compiler_options.print_flag 
  then print_endline ("//Optimisation complete time " ^ string_of_float opt_time);


  if compiler_options.print_flag 
  then print_endline "//Generating primitive wrapper closures";
  let all_closures = Flx_mkcls.make_closures syms bbdfns in
  (* well, this adds non-functions to the set of closures, but
    I guess it doesn't matter
  *)
  let all_closures = IntSet.union all_closures !(syms.roots) in
  let child_map = cal_children syms bbdfns in

  if compiler_options.print_flag then 
  begin
    let f = open_out report_file_name in
    Flx_call.print_call_report bbdfns f;
    close_out f
  end
  ;

  if compiler_options.print_flag 
  then print_endline "//instantiating";

  Flx_inst.instantiate syms bbdfns root_proc bifaces;
  let top_class =
    try cpp_instance_name syms bbdfns root_proc []
    with Not_found -> 
      failwith ("can't name instance of root _init_ procedure index " ^ si root_proc)
  in
  if compiler_options.print_flag 
  then print_endline ("//root module's init procedure has name " ^ top_class);
  let instantiation_time = tim() in

  if compiler_options.print_flag 
  then print_endline ("//instantiation time " ^ string_of_float instantiation_time);
 
  if compiler_options.compile_only
  then exit (if compiler_options.reverse_return_parity then 1 else 0)
  ;

  let find_parsers this e = match e with 
    | `BEXPR_parse ((_,t') as e,ii),_ -> 
      if not (Hashtbl.mem syms.parsers (this,t',ii)) then begin
        let n = !(syms.counter) in incr syms.counter;
        Hashtbl.add syms.parsers (this,t',ii) n;
        print_endline ("PARSER " ^ si n)
      end
      ;
      if not (Hashtbl.mem syms.lexers (this,e)) then begin
        let n = !(syms.counter) in incr syms.counter;
        Hashtbl.add syms.lexers (this,e) n;
        print_endline ("LEXER " ^ si n ^ " = " ^ sbe syms.dfns e);
      end
    | _ -> ()
  in 
  let nul x = () in
  Hashtbl.iter
  (fun i (_,_,_,entry) -> match entry with
  | `BBDCL_function (_,_,_,_,exes)
  | `BBDCL_procedure (_,_,_,exes) ->
    List.iter (Flx_maps.iter_bexe nul (find_parsers i) nul nul nul) exes
  | _ -> ()
  )
  bbdfns
  ;

  let sr = ("unknown",0,0,0,0) in
  Hashtbl.iter
  (fun (this,t',ii) n ->  gen_elk_parser filebase module_name syms bbdfns this sr t' n ii)
  syms.parsers
  ;

  Hashtbl.iter
  (fun (this,e) n ->  gen_elk_lexer filebase module_name syms bbdfns this sr e n)
  syms.lexers 
  ;
    
  let hf = open_out header_file_name in
  let bf = open_out body_file_name in 
  let psh s = output_string hf s in
  let psb s = output_string bf s in
  let plh s = psh s; psh  "\n" in
  let plb s = psb s; psb "\n" in

  if compiler_options.print_flag 
  then print_endline "//GENERATING C++: user headers";
  
  plh ("#ifndef _FLX_GUARD_" ^ module_name);
  plh ("#define _FLX_GUARD_" ^ module_name);
  plh ("//Input file: " ^ input_file_name);
  plh ("//Generated by Felix Version " ^ !version_data.version_string);
  plh ("//Timestamp: " ^ compile_start_gm_string);
  plh ("//Timestamp: " ^ compile_start_local_string);
  plh "";
  plh "//FELIX RUNTIME";
  plh "#include \"flx_rtl.hpp\"";
  plh "using namespace flx::rtl;";
  plh "#include \"flx_gc.hpp\"";
  plh "using namespace flx::gc::generic;";
  plh "";

  plh "\n//-----------------------------------------";
  plh "//USER HEADERS";
  (* These must be in order: build a list and sort it *)
  begin
    let dfnlist = ref [] in
    Hashtbl.iter
    (fun (i,ts) _ -> dfnlist := (i,ts) :: !dfnlist)
    syms.instances
    ;
    let insts = Hashtbl.create 97 in
    List.iter 
    (fun (i,ts)->
      match Hashtbl.find bbdfns i
      with (id,parent,sr,entry) ->
      match entry with
      | `BBDCL_header (_,s,_) -> 
        if s <> "" then 
        begin
          (* do we need tsubst vs ts t? *)
          let tn t = cpp_typename syms (Flx_typing.lower t) in
          let ts = List.map tn ts in
          let s = Flx_csubst.csubst sr sr s [] [] "Error" "Error" ts "atom" "Error" ["Error"] in
          let s = Flx_cexpr.sc "expr" s in
          if not (Hashtbl.mem insts s) then
          begin
            Hashtbl.add insts s ();
            plh s
          end
        end
      | _ -> ()
    )
    (List.sort compare !dfnlist)
  end
  ;

  plh "\n//-----------------------------------------";
  List.iter plh [
  "//FELIX SYSTEM";

  "struct thread_frame_t;"
  ]
  ;
  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: collect types";
  let types = ref [] in 
    Hashtbl.iter 
    (fun t index-> types := (index, t) :: !types)
    syms.registry
  ;
  let types = 
    List.sort 
    (
      fun a1 a2 -> compare (fst a1) (fst a2)
    ) 
    !types
  in
  (*
  List.iter
  (fun (_,t) -> print_endline (string_of_btypecode dfns t))
  types
  ;
  *)

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: type class names";
  plh "\n//-----------------------------------------";
  plh "//NAME THE TYPES";
  plh  (gen_type_names syms bbdfns types);

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: type class definitions";
  plh "\n//-----------------------------------------";
  plh  "//DEFINE THE TYPES";
  plh  (gen_types syms bbdfns types);

  if not (Hashtbl.length syms.parsers + Hashtbl.length syms.lexers = 0) then begin
  plh "\n//-----------------------------------------";
  plh  "//INCLUDE ELKHOUND PARSERS";
  Hashtbl.iter
  (fun _ n -> plh ("#include \""^module_name^"_lexer_"^si n^".hpp\""))
  syms.lexers 
  ;
  Hashtbl.iter
  (fun _ n -> plh ("#include \""^module_name^"_parser_"^si n^".h\""))
  syms.parsers
  end
  ;
  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: function and procedure classes";
  plh "\n//-----------------------------------------";
  plh  "//DEFINE FUNCTION CLASSES";
  plh  (gen_functions syms (child_map,bbdfns) all_closures);

  let topvars_with_type = find_thread_vars_with_type bbdfns in
  let topvars = List.map fst topvars_with_type in
  List.iter plh 
  [
  "struct thread_frame_t {";
  "  int argc;";
  "  char **argv;";
  "  collector_t *gc;";
  "  thread_frame_t(";
  "    collector_t*";
  "  );";
  ]
  ;
  plh (format_vars syms bbdfns topvars []);
  plh "};";
  plh "";
  plh "FLX_DCL_THREAD_FRAME";
  plh "";

  (* BODY *)
  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: GC ptr maps & offsets";

  plb ("//Input file: " ^ input_file_name);
  plb ("//Generated by Felix Version " ^ !version_data.version_string);
  plb ("//Timestamp: " ^ compile_start_gm_string);
  plb ("//Timestamp: " ^ compile_start_local_string);

  plb ("#include \"" ^ module_name ^ ".hpp\"");
  plb "#include <stdio.h>"; (* for diagnostics *)
  plb "#define comma ,";
  plb "\n//-----------------------------------------";
  plb "//EMIT USER BODY CODE";
  (* These must be in order: build a list and sort it *)
  begin
    let dfnlist = ref [] in
    Hashtbl.iter
    (fun (i,ts) _ -> dfnlist := (i,ts) :: !dfnlist)
    syms.instances
    ;
    let insts = Hashtbl.create 97 in
    List.iter 
    (fun (i,ts) ->
      match Hashtbl.find bbdfns i
      with (id,parent,sr,entry) ->
      match entry with
      | `BBDCL_body (_,s,_) -> 
        if s <> "" then 
        begin
          (* do we need tsubst vs ts t? *)
          let tn t = cpp_typename syms (Flx_typing.lower t) in
          let ts = List.map tn ts in
          let s = Flx_csubst.csubst sr sr s [] [] "Error" "Error" ts "atom" "Error" ["Error"] in
          let s = Flx_cexpr.sc "expr" s in
          if not (Hashtbl.mem insts s) then
          begin
            Hashtbl.add insts s ();
            plb s
          end
        end
      | _ -> ()
    )
    (List.sort compare !dfnlist)
  end
  ;
  
  plb "\n//-----------------------------------------";
  plb "FLX_DEF_THREAD_FRAME";
  plb "//Thread Frame Constructor";

  let topfuns = List.filter 
    (fun (i,t) -> match t with 
    | `BTYP_function _ -> true 
    | _ -> false
    ) topvars_with_type
  in
  let topfuns = List.map fst topfuns in
  let topinits =
    [
      "  gc(gc_a)"
    ]
    @
    List.map
    (fun index -> 
      "  " ^ 
      cpp_instance_name syms bbdfns index [] ^ 
      "(0)"
    )
    topfuns
  in
  let topinits = String.concat ",\n" topinits in
  List.iter plb
  [
  "thread_frame_t::thread_frame_t(";
  "  collector_t *gc_a";
  ") :";
  topinits;
  "{}"
  ];



  plb "\n//-----------------------------------------";
  plb "//DEFINE OFFSET tables for GC";

  plb (Flx_ogen.gen_offset_tables syms (child_map,bbdfns) all_closures);

  plb "\n//-----------------------------------------";
  plb "#ifdef FLX_CGOTO";
  plb "//DEFINE LABELS for GNUC ASSEMBLER LABEL HACK";
  Hashtbl.iter
  (fun (fno,_) inst ->
    try 
      let labels = Hashtbl.find label_map fno in
      Hashtbl.iter
      (fun lab lno ->
        match Flx_label.get_label_kind_from_index label_usage lno with
        | `Far ->
          plb ("FLX_DECLARE_LABEL(" ^ si lno ^ ","^ si inst ^ "," ^ lab^")")
        | `Near -> ()
        | `Unused -> () 
      )
      labels
    with Not_found -> ()
  )
  syms.instances
  ;
  plb "#endif";

  if not (Hashtbl.length syms.parsers + Hashtbl.length syms.lexers = 0) then begin
  plb "\n//-----------------------------------------";
  plb  "//INCLUDE ELKHOUND PARSERS";
  Hashtbl.iter
  (fun _ n -> plb ("#include \""^module_name^"_lexer_"^si n^".cpp\""))
  syms.lexers 
  ;

  plb "#include \"elk_glr.h\"";
  Hashtbl.iter
  (fun _ n -> plb ("#include \""^module_name^"_parser_"^si n^".cc\""))
  syms.parsers
  end
  ;

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: method bodies";

  plb "\n//-----------------------------------------";
  plb "//DEFINE FUNCTION CLASS METHODS";
  gen_execute_methods body_file_name syms (child_map,bbdfns) all_closures label_info syms.counter bf;

  if compiler_options.print_flag then print_endline "//GENERATING C++: interface";
  plb "\n//-----------------------------------------";
  plb "//CREATE STANDARD EXTERNAL INTERFACE";
  plb "FLX_FRAME_WRAPPERS";
  plb ("FLX_START_WRAPPER("^top_class^")");
  plb "\n//-----------------------------------------";
  plh "//DECLARE USER EXPORTS";
  plh (gen_biface_headers syms bbdfns bifaces);
  plb "//DEFINE EXPORTS";
  plb (gen_biface_bodies syms bbdfns bifaces);

  plh "//header complete";
  plh "#endif";
  plb "//body complete";
  close_out hf;
  close_out bf;
  let code_generation_time = tim() in
  if compiler_options.print_flag then 
  print_endline ("//code generation time " ^ string_of_float code_generation_time);

  let total_time = 
    parse_time +.
    desugar_time +.
    build_table_time +.
    binding_time +.
    opt_time +.
    instantiation_time +.
    code_generation_time
  in  
  if compiler_options.print_flag then 
  print_endline ("//Felix compiler time " ^ string_of_float total_time);
  let fname = "flxg_stats.txt" in
  let 
    old_parse_time,
    old_desugar_time,
    old_build_table_time,
    old_binding_time,
    old_opt_time,
    old_instantiation_time,
    old_code_generation_time,
    old_total_time
  = 
  let zeroes = 0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0 in
  let f = try Some (open_in fname) with _ -> None in
  begin match f with
  | None -> zeroes
  | Some f ->
    let x =
      try
        let id x1 x2 x3 x4 x5 x6 x7 x8 = x1, x2, x3, x4, x5, x6, x7, x8 in
        Scanf.fscanf f 
        "parse=%f desugar=%f build=%f bind=%f opt=%f inst=%f gen=%f tot=%f"
        id
      with _ -> zeroes
    in close_in f; x
  end
  in
    let f = open_out fname in
    Printf.fprintf 
      f
      "parse=%f\ndesugar=%f\nbuild=%f\nbind=%f\nopt=%f\ninst=%f\ngen=%f\ntot=%f\n"
      (old_parse_time +. parse_time)
      (old_desugar_time +. desugar_time)
      (old_build_table_time +. build_table_time)
      (old_binding_time +. binding_time)
      (old_opt_time +. opt_time)
      (old_instantiation_time +. instantiation_time)
      (old_code_generation_time +. code_generation_time)
      (old_total_time +. total_time)
    ;
    close_out f
  ;
  exit (if compiler_options.reverse_return_parity then 1 else 0)

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

