@h = tangler('src/flx_gen.mli')
@select(h)
open Flx_types
val gen_functions:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  string

val gen_offset_tables:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  string

val gen_execute_methods:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ref ->
  string

val find_members:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  string

val gen_biface_headers:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string

val gen_biface_bodies:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string
  
@h = tangler('src/flx_gen.ml')
@select(h)
open Flx_types
open Flx_print
open Flx_typing
open Flx_name
open Flx_tgen
open Flx_unify
open Flx_csubst

let string_of_string = Flx_string.c_quote_of_string

(* HACKERY: this assumes library dependent things:
  but we can't add literals in the library code :-(
*)
let csuffix_of_type s = match s with
  | "tiny" -> ""
  | "short" -> ""
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "ll"
  | "utiny" -> "u"
  | "ushort" -> "u"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "llu"
  | "int8" -> ""
  | "int16" -> ""
  | "int32" -> "l"
  | "int64" -> "ll"
  | "uint8" -> "u"
  | "uint16" -> "u"
  | "uint32" -> "lu"
  | "uint64" -> "llu"
  | "double" -> ""
  | "float" -> "f"
  | "ldouble" -> "l"
  | _ -> failwith ("[csuffix_of_type]: Unexpected Type " ^ s)

let cstring_of_literal e = match e with
(*   | `AST_bool i -> (match i with | true -> "true" | false -> "false") *)
  | `AST_int (s,i) -> (Big_int.string_of_big_int i)^csuffix_of_type s 
  | `AST_float (s,x) -> x ^ csuffix_of_type s
  | `AST_string s -> string_of_string s

let find_references bbdfns name_map = 
  let references = ref [] in
  Hashtbl.iter
  (fun id entryset -> 
    try
      match entryset with
      | FunctionEntry _ -> ()
      | NonFunctionEntry (Bound _) -> 
        failwith "Not expecting bound entry"

      | NonFunctionEntry (Simple idx) ->
      let _,_,bbdfn = 
        (* try *)
        Hashtbl.find bbdfns idx
        (*
        with Not_found -> 
          failwith 
          (
            "[find_references] can't find index " ^ 
            string_of_int idx ^
            " for name '" ^ id ^ "'"
          )
        *)
      in
      match bbdfn with
      | `BBDCL_var ((`BTYP_pointer _) as t)
        -> references := (idx,lower t) :: !references
      | `BBDCL_val ((`BTYP_pointer _) as t)
        -> references := (idx,lower t) :: !references
      | _ -> ()
    with Not_found -> ()
  ) 
  name_map
  ;
  !references

let dummy_name_map = Hashtbl.create 97

(* SHOULD USE ROUTINE IN LOOKUP FOR THIS *)
let get_name_map symdef name = match symdef with 
    | `SYMDEF_function (_,_,_,name_map,dirs) -> name_map
    | `SYMDEF_procedure (_,_,name_map,dirs) -> name_map
    | `SYMDEF_module (name_map,dirs) -> name_map
    | `SYMDEF_interface (name_map,dirs) -> name_map
    | `SYMDEF_match_check _ -> dummy_name_map
    | _ -> 
      failwith 
      (
        "[get_name_map] Expected entity with scope, got " ^
        string_of_symdef symdef name
      )

(* self's child's parent is normally self,
  but there could be a module stuck in between,
  so the child's parent is the module whose
  parent is a module ... whose parent is self
*)
  
   
(* WARNING WARNING:

  this algorithm makes a list, assuming
  that name -> index is unique on the index

  this won't be the case when we inject
  entries

  even though we check that the denoted
  entity is a child, an actual child can
  have a second name, and so occurs twice
  in the name->index map

  we need to use a SET here, not a list
*)

let find_variable_indices dfns index = 
  let rec extract parent name_map = 
    let variables = ref [] in
    Hashtbl.iter
    (fun id entryset -> 
      match entryset with
      | FunctionEntry _ -> ()
      | NonFunctionEntry (Bound _) ->
        failwith "Not expecting bound entry"
      | NonFunctionEntry (Simple idx) ->
      let id2,_,parent',symdef = 
        try Hashtbl.find dfns idx 
        with _ -> failwith ("[find_variable_indices(2)] can't find index " ^ string_of_int index)
      in

      (* make sure the entity is actually a child of index,
        and not say a link to root, parent, or self.
      *)
      let sp p = match p with | None -> "none" | Some i -> string_of_int i in
      if parent' = parent
      then 
        begin
          match symdef with
          | `SYMDEF_parameter _
          | `SYMDEF_var _ 
          | `SYMDEF_val _
            -> 
      (* print_endline (string_of_int index ^ ": " ^id ^"="^id2^ "<" ^ string_of_int idx ^">"^" member parent=" ^sp parent'); *)
              variables := idx :: !variables

          (* variables of a nested module are lifted into the function *)
          | `SYMDEF_module (table,dirs)
            -> 
      (* print_endline (string_of_int index ^ ": " ^id ^ "="^id2^"<" ^ string_of_int idx ^">"^" nested module parent=" ^sp parent'); *)
              variables := extract (Some idx) table @ !variables
          | _ -> ()
        end
    ) 
    name_map
    ;
    !variables
  in 
  let id,_,_,symdef = 
    try Hashtbl.find dfns index 
    with _ -> failwith ("[find_variable_indices(1)] Can't find index " ^ string_of_int index)
  in
  (* print_endline ("Finding members of " ^ id ^ " index " ^ string_of_int index); *)
  let name_map = get_name_map symdef id in
  extract (Some index) name_map

let find_members sym_state bbdfns index = 
  let variables = find_variable_indices sym_state.dfns index in
  let members = 
  String.concat ""
  (
    List.map 
    (fun idx -> 
      try
        let id,parent,entry = 
          (* try  *)
            Hashtbl.find bbdfns idx 
          (*
          with _ -> 
            failwith 
            (
              "[find_members] Can't find index " ^ string_of_int idx ^ 
              " member of " ^ string_of_int index
            )
          *)
        in
        match entry with
        | `BBDCL_var t
        | `BBDCL_val t ->
          (*
          print_endline 
          (
            "Found variable or value " ^
            id ^ 
            " of (lowered) type " ^ string_of_btypecode dfns (lower t)
          );
          *)
          let typename = cpp_typename sym_state bbdfns (lower t) in
          "  " ^ typename ^ " " ^ cpp_name bbdfns idx ^ ";\n"
        | _ -> failwith "[find members] Expected variable or value"
      with Not_found -> "" (* ignore unused variables *)
    )
    variables
  )
  in if members <> "" then "  //variables\n" ^ members
  else ""

let rec cal_display dfns parent display : bid_t list =
  match parent with 
  | None -> display
  | Some parent ->
  let id,sr,parent',entry = Hashtbl.find dfns parent in
  match entry with
  | `SYMDEF_function _
  | `SYMDEF_procedure _
  | `SYMDEF_match_check _
    -> cal_display dfns parent' (parent::display)
  | _ -> cal_display dfns parent' display
   
let get_display_list dfns index : bid_t list =
  let id,sr,parent,entry = Hashtbl.find dfns index in
  match entry with
  | `SYMDEF_function _
  | `SYMDEF_procedure _
  | `SYMDEF_match_check _
    -> List.rev (cal_display dfns parent [])

  | _ -> 
    failwith 
    (
      "Only functions and procedures have a display, got: " ^
      string_of_symdef entry id
    )

let get_type bbdfns index = 
  let id,parent,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_type] Can't find index " ^ string_of_int index)
  in
  match entry with
  | `BBDCL_function (ps,ret,_,_) -> 
      `BTYP_function (typeoflist (List.map snd ps),ret)
  | `BBDCL_procedure (ps,_,_) -> 
      `BTYP_function (typeoflist (List.map snd ps),`BTYP_void)
  | _ -> failwith "Only function and procedure types handles by get_type"


let gen_function sym_state bbdfns index id ps ret' =
  (*
  print_endline ("generating function " ^ id ^ "[" ^string_of_int index^"]");
  flush stdout;
  *)
  let argtype = lower(typeoflist (List.map snd ps)) in
  let ret = lower ret' in
  let funtype = `BTYP_function (argtype, ret) in
  let argtypename = cpp_typename sym_state bbdfns argtype
  and funtypename = cpp_classname sym_state bbdfns funtype
  and display = get_display_list sym_state.dfns index 
  and frame_dcls = 
    "  //OS frames\n" ^
    "  global_frame_t *pgf;\n" ^
    "  process_frame_t *ppf;\n" ^
    "  thread_frame_t *ptf;\n"
  in
  let display_string = match display with
    | [] -> ""
    | display -> 
      "  //display\n" ^
      String.concat "" 
      (
        List.map
        (fun i-> 
         let name = cpp_name bbdfns i in
         "  " ^ name ^ " *ptr" ^ name ^ ";\n"
         )
        display
      )
  and ctor_dcl name =  
    "  " ^name^
    "  (\n" ^
    String.concat ",\n"
      (
        "    global_frame_t *_pgf" ::
        "    process_frame_t *_ppf" ::
        "    thread_frame_t *_ptf" ::
        List.map 
        (
          fun i -> let name = cpp_name bbdfns i in
          "    " ^ name ^ " *pptr" ^ name
        )
        display
      )^
      "\n  );\n" 
  in
  let members = find_members sym_state bbdfns index in
  match ret with
  | `BTYP_void ->
    let name = cpp_name bbdfns index in
    "struct " ^ name ^
    ": "^funtypename^" {\n" ^
    (if argtype = `BTYP_tuple [] 
    then
    "  continuation_t *call(continuation_t*);\n" 
    else
    "  continuation_t *call(continuation_t*,"^argtypename^" const &);\n"
    ) ^
    "  continuation_t *resume();\n"  ^
    "  continuation_t *_caller; // callers return address\n" ^
    frame_dcls ^
    display_string ^ "\n" ^
    "  //constructor\n" ^
    ctor_dcl name ^
    members ^
    "};\n"

  | _ ->
    let name = cpp_name bbdfns index
    and rettypename = cpp_typename sym_state bbdfns ret
    in
    let ctor = ctor_dcl name in
    "struct " ^ name ^
    ": "^funtypename^" {\n" ^
    "  "^rettypename^" apply(" ^
    (if argtype = `BTYP_tuple[] then ""
    else argtypename^" const &")^ 
    ");\n"  ^
    frame_dcls ^
    display_string ^ "\n" ^
    "  //constructor\n" ^
    ctor ^
    members ^
    "};\n"


(* This code generates the class declarations *)
let gen_functions sym_state bbdfns = 
  let xxdfns = ref [] in
  Hashtbl.iter
  (fun index (id,parent,entry) -> 
    (* if proper_descendant sym_state.dfns parent then  *)
    xxdfns := index :: !xxdfns
  )
  bbdfns
  ;
  
  flush stdout;
  let s = Buffer.create 2000 in
  List.iter
  (fun index ->
    match Hashtbl.find bbdfns index with (id,parent,entry) -> 
    match entry with
    | `BBDCL_function (ps, ret, _,_) -> 
      Buffer.add_string s ("//------------------------------\n");
      Buffer.add_string s ("//FUNCTION " ^ id ^ "\n");
      Buffer.add_string s 
      (gen_function sym_state bbdfns index id ps ret)
    | `BBDCL_procedure (ps,_,_) -> 
      Buffer.add_string s ("//------------------------------\n");
      Buffer.add_string s ("//PROCEDURE " ^ id ^ "\n");
      Buffer.add_string s 
      (gen_function sym_state bbdfns index id ps `BTYP_void)
    | _ -> () (* Buffer.add_string s ("//SKIPPING " ^ id ^ "\n") *)
  )
  (List.sort compare !xxdfns)
  ;
  Buffer.contents s

let gen_ctor bbdfns name display =
  name^"::"^name^
  "\n  (\n" ^
  String.concat ",\n"
  (
    "    global_frame_t *_pgf" ::
    "    process_frame_t *_ppf" ::
    "    thread_frame_t *_ptf" ::
    List.map 
    (
      fun i -> let name = cpp_name bbdfns i in
      "    " ^ name ^ " *pptr" ^ name
    )
    display
  )^
  "\n  ):\n" ^
  String.concat ",\n"
  (
    "  pgf(_pgf)" ::
    "  ppf(_ppf)" ::
    "  ptf(_ptf)" ::
    List.map 
    (
      fun i -> let name = cpp_name bbdfns i in
      "  ptr" ^ name ^ "(pptr"^name^")"
    )
    display
  ) ^ 
  "\n  {}\n"

let get_var_ref (dfns:symbol_table_t) bbdfns this index : string =
  let id,sr,parent,entry = 
    try Hashtbl.find dfns index 
    with _ -> failwith ("[get_var_ref] Can't find index " ^ string_of_int index)
  in  
  match entry with
  | `SYMDEF_parameter _
  | `SYMDEF_var _
  | `SYMDEF_val _ ->
    let rec chase_tail parent =
      match parent with
      | None -> "ptf->" ^ cpp_name bbdfns  index
      | Some i ->
        let _,sr,parent,entry = 
          try Hashtbl.find dfns i 
          with _ -> failwith ( "[get_var_ref(1)] Can't find index " ^ string_of_int i)
        in
        match entry with
        | `SYMDEF_function _
        | `SYMDEF_procedure _ 
          ->
          (if i <> this
          then 
            "ptr" ^ cpp_name bbdfns i ^ "->"
          else ""
          ) ^ cpp_name bbdfns index 
        | `SYMDEF_module _ -> chase_tail parent
        | _ -> failwith "[get_var_ref(2)] Expected variable to live in procedure or function"
    in 
      chase_tail parent
  | _ -> failwith ("[get_var_ref(3)] Expected name "^id^" to be variable or value")

let get_var_frame (dfns: symbol_table_t) bbdfns this index : string =
  let id,sr,parent,entry = 
    try Hashtbl.find dfns index 
    with _ -> failwith ("[get_var_frame(1)] Can't find index " ^ string_of_int index)
  in
  match entry with
  | `SYMDEF_parameter _
  | `SYMDEF_var _
  | `SYMDEF_val _
  ->
    let rec chase_tail parent =
      match parent with
      | None -> "((void*)0)"
      | Some i ->
        let _,sr,parent,entry = Hashtbl.find dfns i in
        match entry with
        | `SYMDEF_function _
        | `SYMDEF_procedure _ 
          ->
          if i <> this
          then "ptr" ^ cpp_name bbdfns i
          else "this"
        | `SYMDEF_module _ -> chase_tail parent
        | _ -> failwith "[get_var_frame] Expected variable to live in procedure or function"
    in
      chase_tail parent
  | _ -> failwith ("[get_var_frame] Expected name "^id^" to be variable or value")

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls -> 
    List.fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

  | _ -> false

let rec gen_expr syms bbdfns this (e,t) =
  (* print_endline ("Gen expr " ^ string_of_bound_expression dfns (e,t)); *)
  let ge e = gen_expr syms bbdfns this e in
  let ge_arg a = 
    match a with
    | _,`BTYP_tuple [] -> ""
    | x -> ge x 
  in
  let id,parent,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_expr] Can't find this = " ^ string_of_int this)
  in
  let our_display = get_display_list syms.dfns this in
  let our_level = List.length our_display in
  match e with
  | `BEXPR_coercion (e,t) -> 
    (* generate a function style cast *)
    cpp_typename syms bbdfns (lower t) ^ "(" ^ ge e ^ ")"
    
  | `BEXPR_get_n (n,e) -> 
    "(" ^ ge e ^ ").mem_" ^ string_of_int n
    
  | `BEXPR_match_case (n,((e',t') as e)) -> 
    if is_unitsum t' then
      "((" ^ ge e ^ ") == " ^ string_of_int (n-1) ^ ")"
    else
      "((" ^ ge e ^ ").variant == " ^ string_of_int (n-1) ^ ")"

  | `BEXPR_case_arg (n,e) ->
    (* NOTE that the index is not used ... *)
    let _,t = e in
    let t = 
      match t with 
      | `BTYP_sum ls -> List.nth ls (n-1)
      | _ -> assert false
    in
      let t = cpp_typename syms bbdfns (lower t) in
      (* really ugly brackets .. *)
      "(*("^t^"*)((" ^ ge e ^ ").data))"
     
  | `BEXPR_deref ((`BEXPR_ref index),`BTYP_pointer t) -> 
    ge (`BEXPR_name index,t)

  | `BEXPR_deref e -> 
    "*(" ^ ge e ^ ".data)"

  | `BEXPR_literal v ->
    let t = cpp_typename syms bbdfns (lower t) in
    t ^ "(" ^ cstring_of_literal v ^ ")"
    
  | `BEXPR_case (v,t) ->
    begin match t with
    | `BTYP_sum ls ->
       let n = List.length ls in
       if v<1 or v>n
       then 
         failwith 
         (
           "Invalid case index " ^ string_of_int v ^
           " of " ^ string_of_int n ^ " cases"
         )
       else let t' = List.nth ls (v-1) in
       if t' = `BTYP_tuple []
       then (* closure of const ctor is just the const value ???? *)
         if is_unitsum t then
           string_of_int (v-1)
         else
           "_uctor_(" ^ string_of_int (v-1) ^ ",0)"
       else 
         failwith 
         ( 
            "Can't handle closure of case " ^ 
            string_of_int v ^ 
            " of " ^
            string_of_btypecode syms.dfns t
         )
       (* "(" ^ cpp_typename syms bbdfns (lower t) ^ "*)_uctor_" *)

    | _ -> failwith "Case tag must have sum type"
    end 
   
  | `BEXPR_name index -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
      | `BBDCL_var t ->
          get_var_ref syms.dfns bbdfns this index

      | `BBDCL_val _ ->
          get_var_ref syms.dfns bbdfns this index
      | `BBDCL_const (_,ct) -> ct

      | `BBDCL_struct _ 
      | `BBDCL_function _
      | `BBDCL_procedure _ 
      | `BBDCL_fun _
      | `BBDCL_proc _ ->
         failwith 
         (
           "[gen_expr: name] Open function '" ^ 
           id ^ "'<"^string_of_int index^
           "> in expression (closure required)"
         )
      | _ -> 
        failwith 
        (
          "[gen_expr: name] Cannot use this kind of name '"^
          id^"' in expression"
        )
    end

  | `BEXPR_closure index -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_function _ ->
      let the_display = 
        let d' = 
          List.map (fun i-> "ptr"^ cpp_name bbdfns i)
          (get_display_list syms.dfns index)
        in 
          if List.length d' > our_level
          then "this" :: List.tl d'
          else d'
      in
      let os_frames = [
        "pgf";
        "ppf";
        "ptf"
      ] in
      let name = cpp_name bbdfns index in
      "(new(gc,"^name^"_ptr_map)\n" ^ name ^
      "(" ^ String.concat ", " (os_frames @ the_display) ^
      "))"

    | `BBDCL_procedure _ ->
      let the_display = 
        let d' = 
          List.map (fun i-> "ptr"^ cpp_name bbdfns i)
          (get_display_list syms.dfns index)
        in 
          if List.length d' > our_level
          then "this" :: List.tl d'
          else d'
      in
      let os_frames = [
        "pgf";
        "ppf";
        "ptf"
      ] in
      let name = cpp_name bbdfns index in
      "(new(gc,"^name^"_ptr_map)\n" ^ name ^
      "(" ^ String.concat ", " (os_frames @ the_display) ^
      "))"

    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith "[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression"
    end

  | `BEXPR_ref index -> 
    let ref_type = cpp_typename syms bbdfns (lower t) in
    let var_ptr = "&(" ^ get_var_ref syms.dfns bbdfns this index ^ ")" in
    let frame_ptr = get_var_frame syms.dfns bbdfns this index in
    let reference = ref_type ^ 
      "((void*)" ^ frame_ptr ^ ", " ^ var_ptr ^ ")" 
    in
    reference

  | `BEXPR_apply 
     (
       (`BEXPR_case (v,t),t'),
       (a,t'') 
     ) ->
       (* t is the type of the sum, 
          t' is the function type of the constructor,
          t'' is the type of the argument
       *)
       let 
         arg_typename = cpp_typename syms bbdfns (lower t'') 
       and
         union_typename = cpp_typename syms bbdfns (lower t)
       in

       let aval = 
         "new (gc, "^arg_typename^"_ptr_map) " ^
         arg_typename ^ "(" ^ ge (a,t'') ^ ")"
       in
       let uval = "_uctor_(" ^ string_of_int (v-1) ^ ", " ^ aval ^")" in
       "(" ^ union_typename ^ ")" ^ uval
       (*
       failwith 
       (
         "Trapped application, case " ^ 
         string_of_int v ^
         " of " ^ string_of_btypecode syms.dfns t ^
         "\ntype " ^ string_of_btypecode syms.dfns t' ^
         "\nargument=" ^ 
         string_of_bound_expression syms.dfns (a,t'') ^
         "\ntype " ^ string_of_btypecode syms.dfns t''
       )
      *) 


  (* special case when function expression is a name *)
  | `BEXPR_apply ((`BEXPR_closure index,_) as f,a) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply closure)] Can't find index " ^ string_of_int index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct) -> 
      if List.length vs = 0
      then
        (* print_endline "--- CASE OF PRIMITIVE"; *)
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          (* 
          print_endline "--- ARGS ARE TUPLE";
          print_endline ("N params = " ^ (string_of_int (List.length ps)));
          *)
          let args = List.map ge es in
          "(" ^ csubst syms bbdfns ct args typs retyp []^ ")"
        | (_,typ) -> 
          (*
          print_endline ("--- ARGS ARE NOT TUPLE: type=" ^ string_of_btypecode syms.dfns typ);
          print_endline ("N params = " ^ (string_of_int (List.length ps)));
          *)
          "(" ^ csubst syms bbdfns ct [ge a] [typ] retyp []^ ")"
        end
      else failwith "Generic function requires type arguments"

    | `BBDCL_function (ps,_,_,_) ->
      (ge f) ^ "->apply(" ^ ge_arg a ^ ")"

    | `BBDCL_struct _ ->
      let name = cpp_typename syms bbdfns (`BTYP_name index) in
      name ^ "(" ^ ge a ^ ")"
    
    | _ -> 
      failwith 
      (
        "[gen_expr] Expected '"^id^"' to be function constant or variable, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end
  
  (* special case when function expression is a generic instance *)
  | `BEXPR_apply ((`BEXPR_ginst (index,ts),_) as f,a) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ string_of_int index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct) -> 
      if List.length vs = List.length ts
      then
        (* print_endline "--- CASE OF PRIMITIVE"; *)
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          (* 
          print_endline "--- ARGS ARE TUPLE";
          print_endline ("N params = " ^ (string_of_int (List.length ps)));
          *)
          let args = List.map ge es in
          "(" ^ csubst syms bbdfns ct args typs retyp ts ^")"
        | (_,typ) -> 
          (*
          print_endline ("--- ARGS ARE NOT TUPLE: type=" ^ string_of_btypecode syms.dfns typ);
          print_endline ("N params = " ^ (string_of_int (List.length ps)));
          *)
          "(" ^ csubst syms bbdfns ct [ge a] [typ] retyp ts ^ ")"
        end
      else failwith "Wrong number of type arguments to generic function"

    | _ -> 
      failwith 
      (
        "[gen_expr] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  (* General application*)
  | `BEXPR_apply (f,a) ->
    (ge f) ^ "->apply(" ^ ge_arg a ^ ")"
    
  | `BEXPR_tuple es ->
    (* just apply the tuple type ctor to the arguments *)
    let ctyp = cpp_typename syms bbdfns (lower t) in
    ctyp ^ "(" ^
    String.concat ", " (List.map ge es) ^
    ")"

  | `BEXPR_dot (e,index) -> "Can't handle unions yet"
    (* structure component: the Felix and C++ names
       of the component are the same
    *)
    (* "(" ^ ge e ^ ")." ^ name *)

  | `BEXPR_ginst (i,ts) ->
    failwith 
    (
      "can't evaluate unapplied generic instance " ^
      string_of_bound_expression syms.dfns (e,t)
    )
    
let get_labels bbdfns counter exes =
  let labels = Hashtbl.create 97 in
  List.iter
    (fun exe -> match exe with 
      | `BEXE_label s -> Hashtbl.add labels s !counter; incr counter
      | _ -> ()
    )
    exes
  ;
  labels

let create_label_map bbdfns counter =
  let label_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun index (id,parent,entry) ->
    match entry with
    | `BBDCL_function (_,_,exes,_) -> 
      Hashtbl.add label_map index (get_labels bbdfns counter exes)
    | `BBDCL_procedure (_,exes,_) -> 
      Hashtbl.add label_map index (get_labels bbdfns counter exes)
    | _ -> ()
  ) 
  bbdfns
  ;
  label_map

let get_parameters dfns index =
  let variables = find_variable_indices dfns index in
  let params = 
    List.filter
    (fun i -> let id,sr,parent,entry = 
      try Hashtbl.find dfns i 
      with _ -> failwith ("[get_parameters] Can't find index " ^ string_of_int i)
      in
      match entry with 
      | `SYMDEF_parameter _ -> true
      | _ -> false
    )
    variables
  in 
    List.sort compare params

type kind_t = Function | Procedure

let gen_exe sym_state bbdfns label_map counter this (exe:bexe_t) =
  (*
  print_endline ("generating exe " ^ string_of_bexe dfns 0 exe);
  *)
  let ge e = gen_expr sym_state bbdfns this e in
  let id,parent,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_exe] Can't find this " ^ string_of_int this)
  in
  let our_display = get_display_list sym_state.dfns this in
  let kind = match entry with
    | `BBDCL_function (_,_,_,_) -> Function
    | `BBDCL_procedure (_,_,_) -> Procedure
    | _ -> failwith "Expected executable code to be in function or procedure"
  in let our_level = List.length our_display in
  match exe with
  | `BEXE_code s -> s
  | `BEXE_comment s -> "\n/*" ^ s ^ "*/\n"
  | `BEXE_label s -> 
    let local_labels = 
      try Hashtbl.find label_map this 
      with _ -> failwith ("[gen_exe] Can't find label map of " ^ string_of_int this)
    in
    let label_index = 
      try Hashtbl.find local_labels s 
      with _ -> failwith ("[gen_exe] In " ^ id ^ ": Can't find label " ^ s)
    in
    (match kind with
      | Procedure ->
      "    case " ^ string_of_int label_index ^ ":\n" 
      | Function -> "" 
        (* labels mus be allowed in functions, to support
           local gotos
        *)
    )
    ^
    "    " ^ s ^ ":;\n"
  | `BEXE_goto s -> 
    let local_labels = 
      try Hashtbl.find label_map this 
      with _ -> failwith ("Can't find label map of " ^ string_of_int this)
    in
    if Hashtbl.mem local_labels s
    then "      goto " ^ s ^ ";\n"
    else let rec aux parent =
      match parent with
      | None -> failwith ("[gen_exe(goto)] In " ^ id ^ ": Can't find label " ^ s)
      | Some i -> 
         let id, sr, parent, entry = 
           try Hashtbl.find sym_state.dfns i 
           with _ -> failwith ("Can't find parent " ^ string_of_int i)
         in
         match entry with
         | `SYMDEF_procedure _ ->
           let local_map = 
             try Hashtbl.find label_map i 
             with _ -> failwith ("Can't find label map for " ^ string_of_int i)
           in
           begin try i, Hashtbl.find local_map s
           with Not_found -> aux parent
           end
         | `SYMDEF_module  _ -> aux parent
         | `SYMDEF_function _ -> failwith ("goto "^s^" can't out of function")
         | _ -> failwith "Unknown parent kind"
    in 
      begin match kind with
      | Function -> failwith ("goto "^s^": can't jump out of function")
      | Procedure ->
      let id,parent,entry = 
        try Hashtbl.find bbdfns this 
        with _ -> failwith ("[gen_exe(goto)] Can't find this = " ^ string_of_int this)
      in
      let frame, pc = aux parent in
      let id,_,_ =
        try Hashtbl.find bbdfns frame 
        with _ -> failwith ("[gen_exe(goto)] Can't find frame " ^ string_of_int frame)
      in
        let frame_ptr = "ptr" ^ cpp_name bbdfns frame in
        "      // non local goto " ^ s ^ "\n" ^
        "      " ^ frame_ptr ^ "->pc="^string_of_int pc^";\n" ^
        "      return " ^ frame_ptr ^ ";\n"
      end

  (* conditional gotos are always local *)
  | `BEXE_ifgoto (e,s) -> "      if(" ^ ge e ^ ")goto " ^ s ^ ";\n"
  | `BEXE_ifnotgoto (e,s) ->"      if(!("^ge e^"))goto " ^ s ^ ";\n" 
  
  | `BEXE_call ((`BEXPR_ginst (index,ts),_) as f,a) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_exe(call)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_proc (vs,_,ct) -> 
      if List.length vs = List.length ts 
      then
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          let args = List.map ge es in
          "      //call multi (or no) -arg generic primitive " ^ id ^ "\n" ^
          "      {" ^ csubst sym_state bbdfns ct args typs `BTYP_void ts^ "}\n"
        | (_,typ) -> 
          "      //call single-arg generic primitive " ^ id ^ "\n" ^
          "      {" ^ csubst sym_state bbdfns ct [ge a] [typ] `BTYP_void ts^ "}\n"
        end
      else failwith "Generic procedure has wrong number of type arguments"
    | _ -> failwith "Expected generic instance procedure"
    end
 
  | `BEXE_call ((`BEXPR_closure index,_) as f,a) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_exe(call)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_proc (vs,_,ct) -> 
      if List.length vs = 0
      then
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          let args = List.map ge es in
          "      //call multi (or no) -arg primitive " ^ id ^ "\n" ^
          "      {" ^ csubst sym_state bbdfns ct args typs `BTYP_void []^ "}\n"
        | (_,typ) -> 
          "      //call single-arg primitive " ^ id ^ "\n" ^
          "      {" ^ csubst sym_state bbdfns ct [ge a] [typ] `BTYP_void []^ "}\n"
        end
      else failwith "Generic procedure requires type arguments"

    | `BBDCL_procedure (ps,bexes,nmap) ->
      if bexes = []
      then 
      "      //call to empty procedure " ^ id ^ " elided\n"
      else begin
        let n = !counter in
        incr counter;
        let the_display = 
          let d' = 
            List.map (fun i -> "ptr"^cpp_name bbdfns i)
            (get_display_list sym_state.dfns index)
          in 
            if List.length d' > our_level
            then "this" :: List.tl d'
            else d'
        and os_frames = [
          "pgf";
          "ppf";
          "ptf"
        ]
        in
        (* if we're calling from inside a function,
           we pass a 0 continuation as the caller 'return address'
           otherwise pass 'this' as the caller 'return address'
        *)
        let this = match kind with
        | Function -> "0"
        | Procedure -> "this"
        in
        let args = match a with
        | _,`BTYP_tuple [] -> this
        | _ -> this ^ ", " ^ ge a
        in
        let name = cpp_name bbdfns index in
        "      //call procedure " ^ id ^ "\n" ^
        (match kind with
        | Function ->
          "      continuation_t *_p =\n" ^
          "      (new(gc,"^ name^"_ptr_map)\n" ^ 
          "      " ^ name ^
          "(" ^ String.concat ",\n      " (os_frames @ the_display) ^
          "))->call(\n      " ^ args ^ "\n      );\n" ^
          "      while(_p) _p=_p->resume();\n"

        | Procedure ->
          "      pc = " ^ string_of_int n ^ ";\n" ^
          "      return (new(gc,"^ name^"_ptr_map)\n" ^ 
          "      " ^ name ^
          "(" ^ String.concat ",\n      " (os_frames @ the_display) ^
          "))->call(\n      " ^ args ^ "\n      );\n" ^
          "    case " ^ string_of_int n ^ ":\n"
        )
      end

    | _ -> 
      failwith 
      (
        "[gen_exe] Expected '"^id^"' to be procedure constant, got " ^
        string_of_bbdcl sym_state.dfns entry index 
      )
    end

  | `BEXE_call (p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "this"
      | _ -> "this, " ^ ge a
    in
    let n = !counter in
    incr counter;
    "      pc = " ^ string_of_int n ^ ";\n" ^
    "      return " ^ ge p ^ "->call(" ^ args ^");\n" ^
    "    case " ^ string_of_int n ^ ":\n"
    
  | `BEXE_read index -> 
    let n = !counter in
    incr counter;
    "      //read variable\n" ^
    "      p_message = &(" ^ get_var_ref sym_state.dfns bbdfns this index ^");\n" ^
    "      action = wait_action;\n" ^
    "      pc=" ^ string_of_int n ^ ";\n" ^
    "      return this;\n" ^
    "    case " ^ string_of_int n ^ ":\n"

    
  | `BEXE_regmatch (e,alpha,nstates,cases,matrix) ->
    let b = Buffer.create 500 in
    let tack s = Buffer.add_string b s in

    tack ("  // regmatch: nstates= "^string_of_int nstates^"\n");

    (* transition matrix *)
    let d = Array.make_matrix 256 nstates (-1) in
    Hashtbl.iter
    (fun (c,s1) s2 -> 
      d.(c).(s1) <- s2
    )
    matrix
    ;

    (* find equivalent chars *)
    let canon = Array.make 256 0 in
    for i = 0 to 255 do
      try
        for j = 0 to i do
          if d.(i) = d.(j) then 
          begin
            canon.(i) <- j;
            if i = j then
            begin
              tack("  static int s"^string_of_int i^"["^string_of_int nstates^"]=\n");
              tack "  {\n"
              ;
              for state = 0 to nstates - 1 do
                if state mod 16 = 0 then tack "      ";
                let s = "     " ^ string_of_int (d.(i).(state)+1) in
                let n = String.length s in
                let s = String.sub s (n-3) 3 in
                tack s;
                if state <> nstates - 1 then tack ", ";
                if state mod 16 = 15 then tack "\n"
              done
              ;
              tack "\n";
              tack "  };\n"
            end;
            raise Not_found;
          end
        done (* j *)
      with Not_found -> ()
    done (* i *)
    ;
    tack ("  static int *matrix[256] =\n");
    tack "  {\n";
    for i = 0 to 255 do
      if i mod 16 = 0 then tack "      ";
      let s = "     s" ^ string_of_int canon.(i) in
      let n = String.length s in
      let s = String.sub s (n-4) 4 in
      tack s;
      if i <> 255 then tack ", ";
      if i mod 16 = 15 then tack "\n"
    done;
    tack "  };\n\n";

    (* eval argument as a C++ string *)
    tack "  string s = ";
    tack (ge e);
    tack ";\n";
    tack "  char *start = s.begin();\n";
    tack "  char *end = s.end();\n";
    tack "  int state = 1;\n";
    
    tack "  while(state && start != end)\n";
    tack "    state = matrix[*start++][state-1];\n";
    
    tack "  switch (state)\n";
    tack "  {\n";
    Hashtbl.iter
    (fun state expr ->
      tack ("    case " ^ string_of_int (state + 1)^ ": return " ^ ge expr ^ ";\n")
    )
    cases 
    ;
    tack "    case 0: assert((\"regmatch failure\",0));\n";
    tack "    default: assert((\"system failure in regmatch\",0));\n";
    tack "  }\n";

    Buffer.contents b
    
  | `BEXE_return e -> "      return "^ge e^";\n"
  | `BEXE_nop s -> "      //Nop: " ^ s ^ "\n"
  | `BEXE_init (v,e) -> 
    "      //initialisation "^string_of_bexe sym_state.dfns 0 exe ^"\n" ^
    "      "^
    get_var_ref sym_state.dfns bbdfns this v ^ 
    " = " ^ 
    ge e ^
    ";\n"

let gen_exes sym_state bbdfns display label_map counter index exes =
  (* print_endline ("// generating exes for index " ^ string_of_int index); *)
  String.concat ""
  (List.map (gen_exe sym_state bbdfns label_map counter index) exes)

(* PROCEDURES are implemented by continuations.
   The constructor accepts the display vector to
   form the closure object. The call method accepts
   the callers continuation object as a return address,
   and the procedure argument, and returns a continuation.
   The resume method runs the continuation until
   it returns a continuation to some object, possibly
   the same object. A flag in the continuation object
   determines whether the yield of control is a request
   for data or not (if so, the dispatcher must place the data
   in the nominated place before calling the resume method again.
*)
 
(* FUNCTIONS are implemented as functoids:
  the constructor accepts the display vector so as
  to form a closure object, the apply method
  accepts the argument and runs the function.
  The machine stack is used for functions.
*)
let gen_function_methods sym_state bbdfns label_map counter index = 
  let id,parent,entry = Hashtbl.find bbdfns index in
  (*
  print_endline ("Generating body for " ^ id ^ "<"^string_of_int index^">");
  flush stdout;
  *)
  (*
  print_endline ("function " ^ id ^ " methods");
  *)
  match entry with 
  | `BBDCL_function (ps,ret',exes,_) ->
    let name = cpp_name bbdfns index 
    and display = get_display_list sym_state.dfns index
    and argtype = unfold (lower (typeoflist (List.map snd ps)))
    and ret = unfold (lower ret') in
    let argtypename = cpp_typename sym_state bbdfns argtype 
    and rettypename = cpp_typename sym_state bbdfns ret
    and ctor = gen_ctor bbdfns name display 
    and params = get_parameters sym_state.dfns index in
    (* print_endline "GOT TYPE NAMES"; *)
    let apply =
      rettypename^ " " ^name^
      "::apply("^
      (if argtype = `BTYP_tuple []
      then ""
      else argtypename ^" const &_arg ")^
      "){\n" ^
      "  flx::gc::generic::collector_t &gc = *ptf->gc;\n" ^
      (
        match List.length params with
        | 0 -> ""
        | 1 -> 
          let i = List.hd params in
          if Hashtbl.mem bbdfns i 
          then
            "  " ^ cpp_name bbdfns i ^ " = _arg;\n"
          else ""
        | _ -> 
          let counter = ref 0 in List.fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem bbdfns i
            then 
              s ^ "  " ^ cpp_name bbdfns i ^ " = _arg.mem_"^ string_of_int n ^";\n"
            else s (* elide initialisation of elided variable *)
          )
          "" params 
      )^
      gen_exes sym_state bbdfns display label_map counter index exes ^
      "}\n"
    in
      "//FUNCTION " ^ id ^ ": Constructor\n" ^
      ctor^ "\n" ^
      "//FUNCTION " ^ id ^ ": Apply method\n" ^
      apply^ "\n"

  | _ -> failwith "function expected"

let gen_procedure_methods sym_state bbdfns label_map counter index = 
  let id,parent,entry = Hashtbl.find bbdfns index in (* can't fail *)
  match entry with 
  | `BBDCL_procedure (ps,exes,_) ->
    (*
    print_endline ("procedure " ^ id ^ " methods");
    *)
    let name = cpp_name bbdfns index  
    and display = get_display_list sym_state.dfns index 
    and argtype = unfold (lower (typeoflist (List.map snd ps))) in
    let argtypename = cpp_typename sym_state bbdfns argtype 
    and ctor = gen_ctor bbdfns name display 
    and params = get_parameters sym_state.dfns index 
    and cont = "continuation_t *"
    in
    let arg_sig = 
      match argtype with
      | `BTYP_tuple [] ->
      "  " ^ cont ^ "_ptr_caller"
      | _ ->
      "  " ^ cont ^ "_ptr_caller,\n"^
      "  " ^ argtypename ^" const &_arg\n"
    in
    let call =
      cont ^name^
      "::call(\n" ^ arg_sig ^
      "){\n" ^
      (
        "  _caller = _ptr_caller;\n" ^
        (match List.length params with
        | 0 -> ""
        | 1 -> 
          let i = List.hd params in
          if Hashtbl.mem bbdfns i 
          then
            "  " ^ cpp_name bbdfns i ^ " = _arg;\n"
          else ""

        | _ -> let counter = ref 0 in List.fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem bbdfns i
            then
              s ^ "  " ^ cpp_name bbdfns i ^ " = _arg.mem_"^ string_of_int n ^";\n"
            else s (* elide initialisation of elided variables *)
          )
          "" params
          ) ^
          "  pc = 0;\n" ^
          "  return this;\n"
      )^
      "}\n"
    and resume = 
      if exes = []
      then
        cont^name^"::resume(){//empty\n"^
        "      continuation_t *tmp = _caller;\n" ^
        "      _caller = 0; // make caller unreachable from here\n" ^ 
        "      return tmp;\n" ^
        "}\n"
      else
        cont^name^"::resume(){\n"^
        "  flx::gc::generic::collector_t &gc = *ptf->gc;\n" ^
        "  switch(pc){\n" ^
        "    case 0:\n" ^
        gen_exes sym_state bbdfns display label_map counter index exes ^
        "    default: {\n" ^
        "      continuation_t *tmp = _caller;\n" ^
        "      _caller = 0; // make caller unreachable from here\n" ^ 
        "      return tmp;\n" ^
        "    }\n" ^
        "  }\n" ^
        "}\n"
    in
      "\n//PROC " ^ id ^ "\n" ^
      "//PROC " ^ id ^ ": Constructor\n" ^
      ctor^
      "\n//PROC " ^ id ^ ": Call method\n" ^
      call^
      "\n//PROC " ^ id ^ ": Resume method\n" ^
      resume

  | _ -> failwith "prcoedure expected"


let gen_execute_methods sym_state bbdfns counter =
  let label_map = create_label_map bbdfns counter in
  let s = Buffer.create 2000 in
  Hashtbl.iter
  (fun index (id,parent,entry) -> 
  
  match entry with
  | `BBDCL_function (ps, ret, _,_) -> 
    (* print_endline ("//generating methods for " ^ id ^ "<"^string_of_int index^">"); *)
    Buffer.add_string s ("//------------------------------\n");
    Buffer.add_string s (
      gen_function_methods sym_state bbdfns label_map counter index
    )
  | `BBDCL_procedure (ps,_,_) -> 
    (* print_endline ("//generating methods for " ^ id ^ "<"^string_of_int index^">"); *)
    Buffer.add_string s ("//------------------------------\n");
    Buffer.add_string s (
      gen_procedure_methods sym_state bbdfns label_map counter index
    )
  | _ -> ()
  )
  bbdfns
  ;
  Buffer.contents s

(* this code handles tuples and pointers *)
let rec get_offsets sym_state bbdfns typ : string list =
  let tname = cpp_typename sym_state bbdfns typ in
  match unfold typ with
  | `BTYP_pointer t -> 
    ["offsetof("^tname^",frame)"]

  | `BTYP_tuple args -> 
    let n = ref 0 in
    let lst = ref [] in
    List.iter 
    (fun t ->
      let prefix = 
        "offsetof("^tname^",mem_"^string_of_int !n^")+" 
      in
      List.iter
      (fun s -> lst := !lst @ [prefix ^ s])
      (get_offsets sym_state bbdfns t)
      ;
      incr n
    )
    args
    ;
    !lst

  | _ -> []

let gen_offset_tables sym_state bbdfns =
  let primitive_shapes = Hashtbl.create 97 in
  let s = Buffer.create 2000 in
  (*
  print_endline "Function and procedure offsets";
  *)
  Hashtbl.iter
  (fun index (id,parent,entry) -> match entry with
  | `BBDCL_function (ps, ret,_,name_map) -> 
    let refnames = 
      List.map 
      (fun (index,t)-> 
        cpp_name bbdfns index,
        cpp_typename sym_state bbdfns t
      )
      (find_references bbdfns name_map)
    in
    let name = cpp_name bbdfns index in
    let display = get_display_list sym_state.dfns index in
    let offsets = 
      List.map
      (fun didx ->
      let dptr = "ptr" ^ cpp_name bbdfns didx in
      "offsetof("^name^","^dptr^")"
      )
      display
      @
      List.map 
      (fun (mem,reftyp)->
        "offsetof("^name^","^mem^")" ^
        "+offsetof("^reftyp^",frame)") 
      refnames
    in
    let n = List.length offsets in
    Buffer.add_string s ("\n//OFFSETS for function " ^ name ^ "\n");
    Buffer.add_string s ("static size_t " ^ name ^ "_offsets[]={\n  ");
    Buffer.add_string s ("  " ^ String.concat ",\n  " offsets);
    Buffer.add_string s "};\n";
    Buffer.add_string s ( "static flx::gc::generic::gc_shape_t "^ name ^"_ptr_map(\n");
    Buffer.add_string s ("  sizeof("^name^"),\n  0,\n  "^string_of_int n^",\n  "^name^"_offsets\n");
    Buffer.add_string s ");\n"

  | `BBDCL_procedure (ps,_,name_map) -> 
    let refnames = 
      List.map 
      (fun (index,t)-> 
        cpp_name bbdfns index,
        cpp_typename sym_state bbdfns t
      )
      (find_references bbdfns name_map)
    in
    let name = cpp_name bbdfns index in
    let display = get_display_list sym_state.dfns index in
    let offsets = ("offsetof(" ^ name ^ ",_caller)") :: 
      List.map
      (fun didx ->
      let dptr = "ptr" ^ cpp_name bbdfns didx in
      "offsetof("^name^","^dptr^")"
      )
      display
      @
      List.map 
      (fun (mem,reftyp)->
        "offsetof("^name^","^mem^")" ^
        "+offsetof("^reftyp^",frame)") 
      refnames
    in
    let n = List.length offsets in
    Buffer.add_string s ("\n//OFFSETS for procedure " ^ name ^ "\n");
    Buffer.add_string s ("static size_t " ^ name ^ "_offsets[]={\n");
    Buffer.add_string s ("  " ^ String.concat ",\n  " offsets);
    Buffer.add_string s "\n};\n";
    Buffer.add_string s ("static void " ^ name ^ "_finaliser(flx::gc::generic::collector_t *, void *p){\n");
    Buffer.add_string s ("  (("^ name ^ "*)p)->"^name^"::~" ^ name ^ "();\n");
    Buffer.add_string s "\n};\n";
    Buffer.add_string s ( "static flx::gc::generic::gc_shape_t " ^ name ^ "_ptr_map(\n") ;
    Buffer.add_string s ("  sizeof("^name^"),\n  " ^ name ^ "_finaliser,\n  "^
      string_of_int n^
      ",\n  "^name^"_offsets\n"
    );
    Buffer.add_string s ");\n"

  | `BBDCL_abs (vs,ct) ->
    (* These use the actual C++ type name of the primitive type,
       so they might not be unique: therefore, we have to track
       which ones have been generated
    *)
    if List.length vs = 0
    then
      let name = cpp_typename sym_state bbdfns (`BTYP_name index) in
      if not (Hashtbl.mem primitive_shapes name) then 
      begin
        Hashtbl.add primitive_shapes name true; 
        Buffer.add_string s ("\n//OFFSETS for abstract type " ^ name ^ "\n");
        Buffer.add_string s ( "static flx::gc::generic::gc_shape_t " ^ name ^ "_ptr_map(\n") ;
        Buffer.add_string s ("  sizeof("^name^"),0,0,0\n");
        Buffer.add_string s ");\n"
      end else begin
        Buffer.add_string s ("\n//OFFSETS for abstract type " ^ name ^ "\n");
        Buffer.add_string s ("//Use "^name^"_ptr_map\n");
      end

  | _ -> () (* this is NOT right, we need offsets for all data
               structures *)
  )
  bbdfns
  ;

  (* We're not finished: we need offsets for tuple and pointer types too *)
  (*
  print_endline "Tuple and pointer offsets";
  *)
  Hashtbl.iter
  (fun btyp index -> 
    (*
    print_endline ("type --> " ^ string_of_btypecode sym_state.dfns btyp);
    *)
    match unfold btyp with
    | `BTYP_tuple args ->
      let name = cpp_typename sym_state bbdfns btyp in
      let offsets = get_offsets sym_state bbdfns btyp in
      let n = List.length offsets in 
      Buffer.add_string s ("\n//OFFSETS for tuple type " ^ string_of_int index ^ "\n");
      if n>0 then begin
        Buffer.add_string s ("static size_t " ^ name ^ "_offsets[]={\n  ");
        Buffer.add_string s ("  " ^ String.concat ",\n  " offsets);
        Buffer.add_string s "};\n"
      end;
      Buffer.add_string s ("static void " ^ name ^ "_finaliser(flx::gc::generic::collector_t *, void *p){\n");
      Buffer.add_string s ("  (("^ name ^ "*)p)->"^name^"::~" ^ name ^ "();\n");
      Buffer.add_string s "\n};\n";
      Buffer.add_string s ( "static flx::gc::generic::gc_shape_t "^ name ^"_ptr_map(\n");
      Buffer.add_string s 
        (
          "  sizeof("^name^"),\n  "^
          name^"_finaliser,\n  "^
          string_of_int n^",\n  "^
          (if n>0 then name^"_offsets" else "0")^"\n"
        );
      Buffer.add_string s ");\n"

   | `BTYP_pointer t ->
      let name = cpp_typename sym_state bbdfns btyp in
      let offsets = get_offsets sym_state bbdfns btyp in
      let n = List.length offsets in 
      Buffer.add_string s ("\n//OFFSETS for pointer type " ^ string_of_int index ^ "\n");
      Buffer.add_string s ("static size_t " ^ name ^ "_offsets[]={\n  ");
      Buffer.add_string s ("  " ^ String.concat ",\n  " offsets);
      Buffer.add_string s "};\n";
      Buffer.add_string s ( "static flx::gc::generic::gc_shape_t "^ name ^"_ptr_map(\n");
      Buffer.add_string s ("  sizeof("^name^"),\n  0,\n  "^string_of_int n^",\n  "^name^"_offsets\n");
      Buffer.add_string s ");\n"
   | _ -> () 
  )
  sym_state.registry
  ;
  Buffer.contents s

let gen_biface_header sym_state bbdfns biface = match biface with
  | `BIFACE_export (index, export_name) ->
    let id,parent,entry = Hashtbl.find bbdfns index in
    match entry with
    | `BBDCL_function (ps, ret, _,_) ->
      let display = get_display_list sym_state.dfns index in
      if List.length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        List.map 
        (fun x -> cpp_typename sym_state bbdfns (snd x)) 
        ps 
      and fixed_args = 
        [
          "global_frame_t *";
          "process_frame_t *";
          "thread_frame_t *"
        ]
      in
      let arglist = "  " ^ String.concat ",\n  " (fixed_args @ argtypes) in
      let rettypename = cpp_typename sym_state bbdfns ret in

      "//EXPORT FUNCTION " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" " ^ rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | `BBDCL_procedure (ps, _,_) ->
      let display = get_display_list sym_state.dfns index in
      if List.length display <> 0
      then failwith "Can't export nested proc";

      let argtypes = 
        List.map 
        (fun x -> cpp_typename sym_state bbdfns (snd x)) 
        ps 
      and fixed_args = 
        [
          "global_frame_t *";
          "process_frame_t *";
          "thread_frame_t *"
        ]
      in
      let arglist = 
        "  " ^ String.concat ",\n  " (fixed_args @ argtypes) 
      in 
      
      "//EXPORT PROCEDURE " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" continuation_t * "  ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | _ -> failwith "Not implemented: export non-function/procedure"
  
let gen_biface_body sym_state bbdfns biface = match biface with
  | `BIFACE_export (index, export_name) ->
    let id,parent,entry = Hashtbl.find bbdfns index in
    match entry with
    | `BBDCL_function (ps, ret, _,_) ->
      let display = get_display_list sym_state.dfns index in
      if List.length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        List.map 
        (fun x -> cpp_typename sym_state bbdfns (snd x) ^ " " ^ fst x) 
        ps 
      and fixed_args = 
        [
          "global_frame_t *gf";
          "process_frame_t *pf";
          "thread_frame_t *tf"
        ]
      in
      let arglist = "  " ^ String.concat ",\n  " (fixed_args @ argtypes) in
      let rettypename = cpp_typename sym_state bbdfns ret in
      let class_name = cpp_name bbdfns index in

      "//EXPORT FUNCTION " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*tf->gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(gf,pf,tf))" ^
      "->apply(" ^ String.concat ", " (List.map fst ps) ^ ");\n" ^
      "}\n"

    | `BBDCL_procedure (ps,_,_) ->
      let display = get_display_list sym_state.dfns index in
      if List.length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        List.map 
        (fun x -> cpp_typename sym_state bbdfns (snd x) ^ " " ^ fst x) 
        ps 
      and fixed_args = 
        [
          "global_frame_t *gf";
          "process_frame_t *pf";
          "thread_frame_t *tf"
        ]
      in
      let arglist = "  " ^ String.concat ",\n  " (fixed_args @ argtypes) in
      let class_name = cpp_name bbdfns index in

      "//EXPORT PROC " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      "continuation_t *" ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*tf->gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(gf,pf,tf))" ^
      "->call(" ^ String.concat ", " ("0"::(List.map fst ps)) ^ ");\n" ^
      "}\n"

    | _ -> failwith "Not implemented: export non-function/procedure"

let gen_biface_headers sym_state bbdfns bifaces = 
  String.concat "" (List.map (gen_biface_header sym_state bbdfns) bifaces)

let gen_biface_bodies sym_state bbdfns bifaces = 
  String.concat "" (List.map (gen_biface_body sym_state bbdfns) bifaces)

@h = tangler('src/flxg.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_srcref
open Flx_desugar
open Flx_bbind
open Flx_name
open Flx_tgen
open Flx_gen
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_exceptions
;;

let print_help () =
  print_endline "options:";
  print_endline "  -h, --help : print this help";
  print_endline "  --version: print version info";
  print_endline "  -v, --verbose: print symbol table";
  print_endline "  -q, --quiet: no stdout";
  print_endline "  -Idir, --include=dir : append dir to include path";
  print_endline "  -e: return 0 if error, 1 if no error";
  exit(0)
;;

let return_parity = ref true
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let options = get_options Sys.argv in
  let include_dirs = ref [] in
  let print_flag = ref false in
  List.iter (fun (key,value) ->
    if key = "include" || key = "I"
    then include_dirs := !include_dirs @ [value]

    else if key = "verbose" || key = "v"
    then print_flag := true

    else if key = "help" || key = "h"
    then print_help ()

    else if key = "version" 
    then (print_endline ("Felix Version " ^ version_string))

    else if key = "e"
    then return_parity := false
  )
  options
  ;
  if !print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    !include_dirs;
    print_endline ""
  end
  ;

  if argc = 0 then exit(0);
  let filebase = Sys.argv.(argc-1) in
  if filebase.[0] = '-' then exit(0);
  let module_name = 
    let n = String.length filebase in 
    let i = ref n in 
    begin try while !i>0 do
      if filebase.[!i-1] = '/'
      then raise Not_found; 
      decr i
    done with _ -> () end;
    String.sub filebase !i (n - !i)
  in

  let input_file_name = filebase ^ ".flx" in
  let header_file_name = filebase ^ ".hpp" in
  let body_file_name = filebase ^ ".cpp" in

  let hf = open_out header_file_name in
  let bf = open_out body_file_name in 
  let psh s = output_string hf s in
  let psb s = output_string bf s in
  let plh s = psh s; psh  "\n" in
  let plb s = psb s; psb "\n" in
  if !print_flag then print_endline ("//Parsing " ^ filebase);
  
  let parse_tree = 
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      !include_dirs 
  in
  if !print_flag then print_endline "//DESUGARING";

  let syms = 
    {
      registry = Hashtbl.create 97;
      counter = ref 1;
      freg = Hashtbl.create 97;
      dfns = Hashtbl.create 97;
      varmap = Hashtbl.create 97;
      ticache = Hashtbl.create 97;
      env_cache = Hashtbl.create 97;
      prim_inst = Hashtbl.create 97;
      rev_prim_inst = Hashtbl.create 97;
      instantiated_types = Hashtbl.create 97;
    }
  in
  let deblocked = desugar_program module_name syms.counter parse_tree in
  if !print_flag then print_endline "//BUILDING TABLES";
  let root = !(syms.counter) in (* hackery .. *)
  let table, exes, ifaces,dirs = 
    build_tables !print_flag syms.dfns syms.counter "<top level>" 0 None None root deblocked 
  in
    if !print_flag then
    Hashtbl.iter 
    (fun name entry ->  
      print_endline 
      (
        "//TOPLEVEL:'" ^ 
        name ^ "'->" ^ 
        match entry with
        | NonFunctionEntry (Simple index) -> string_of_int index
        | NonFunctionEntry _ -> "UNEXPECTED BOUND ENTRY"
        | FunctionEntry _ -> "UNEXPECTED FUNCTION SET"
      )
    )
    table
    ;
    if !print_flag 
    then print_endline ("//Top level module ''"^module_name^" has index " ^ string_of_int root);
    if !print_flag then print_endline "//BINDING ";
    let bbdfns = bbind syms in
    (*
    print_endline "BINDING IS DONE"; flush stdout;
    *)
    let bifaces = bind_ifaces syms ifaces in

    let top_class, root_proc = 
      let id,sr,parent,entry = Hashtbl.find syms.dfns root in
      let name_map = match entry with
        | `SYMDEF_module (table,dirs) -> table
        | _ -> failwith "Expected to find top level module ''"
      in let entry = Hashtbl.find name_map "_init_" in
      let index = match entry with
        | FunctionEntry [Simple x] -> x
        | FunctionEntry [] -> failwith "Couldn't find '_init_'"
        | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
        | NonFunctionEntry _ -> failwith "_init_found but not procedure"
      in cpp_name bbdfns index, index
    in

    if !print_flag then print_endline "//Eliding useless things";
    let bbdfns = Flx_use.elide_unused bbdfns root_proc bifaces in
    let bbdfns = Flx_use.elide_unused bbdfns root_proc bifaces in

    if !print_flag then print_endline "//GENERATING C++: user headers";
    plh "#include \"rtl/flx_rtl.hpp\"";
    plh "#include \"rtl/flx_collector.hpp\"";
    plh "using namespace flx::rtl;";
    plh "";

    plh "//USER HEADERS";
    (* These must be in order: build a list and sort it *)
    let dfnlist = ref [] in
    Hashtbl.iter
    (fun index data -> dfnlist := index :: !dfnlist)
    bbdfns
    ;
    List.iter 
    (fun index ->
      match Hashtbl.find bbdfns index 
      with (id,parent,entry) ->
      match entry with
      | `BBDCL_header s -> plh s
      | _ -> ()
    )
    (List.sort compare !dfnlist)
    ;

    List.iter plh [
    "//FELIX SYSTEM";

    (* GLOBAL FRAME *)
    "struct global_frame_t {";
    " // put global values here";
    "};";
    "struct process_frame_t {";
    "  global_frame_t *global_frame;";
    "  process_frame_t(";
    "    global_frame_t *_global_frame";
    "  ) :";
    "    global_frame(_global_frame)";
    "  {}";
    "};";

    "struct thread_frame_t;"
    ]
    ;
    if !print_flag then print_endline "//GENERATING C++: collect types";
    collect_types syms bbdfns;
    let types = ref [] in 
      Hashtbl.iter 
      (fun t index-> types := (index, t) :: !types)
      syms.registry
    ;
    let types = 
      List.sort 
      (
        fun a1 a2 -> compare (fst a1) (fst a2)
      ) 
      !types
    in
    (*
    List.iter
    (fun (_,t) -> print_endline (string_of_btypecode dfns t))
    types
    ;
    *)

    if !print_flag then print_endline "//GENERATING C++: type class names";
    plh "//TYPE CLASS NAMES";
    plh  (gen_type_names syms bbdfns types);
    if !print_flag then print_endline "//GENERATING C++: type class definitions";
    plh  "//TYPE CLASS DEFINITIONS";
    plh  (gen_types syms bbdfns types);

    if !print_flag then print_endline "//GENERATING C++: function and procedure classes";
    plh  "//FUNCTION and PROCEDURE CLASS DEFINITIONS";
    plh  (gen_functions syms bbdfns);
    List.iter plh 
    [
    "struct thread_frame_t {";
    "  global_frame_t *global_frame;";
    "  process_frame_t *process_frame;";
    "  flx::gc::generic::collector_t *gc;";
    "  thread_frame_t(";
    "    global_frame_t *global_frame_a,";
    "    process_frame_t *process_frame_a,";
    "    flx::gc::generic::collector_t *gc_a";
    "  ) : ";
    "    process_frame(process_frame_a),";
    "    global_frame(global_frame_a),";
    "    gc(gc_a)";
    "  {}"
    ];
    (*
    print_endline "Finding top level variables";
    *)
    List.iter plh
    [
    (find_members syms bbdfns root);
    "};"
    ];


    (* BODY *)
    if !print_flag then print_endline "//GENERATING C++: GC ptr maps & offsets";
    plb ("#include \"" ^ module_name ^ ".hpp\"");
    plb "";
    plh "//USER BODY CODE";
    (* These must be in order: build a list and sort it *)
    let dfnlist = ref [] in
    Hashtbl.iter
    (fun index data -> dfnlist := index :: !dfnlist)
    bbdfns
    ;
    List.iter 
    (fun index ->
      match Hashtbl.find bbdfns index 
      with (id,parent,entry) ->
      match entry with
      | `BBDCL_body s -> plb s
      | _ -> ()
    )
    (List.sort compare !dfnlist)
    ;

    plb "//OFFSET tables for GC";
    plb "static size_t _uctor_offsets[1]= { offsetof(_uctor_,data) };";
    plb "static flx::gc::generic::gc_shape_t _uctor_ptr_map ("; 
    plb "  sizeof(_uctor_),";
    plb "  0,";
    plb "  1,";
    plb "  _uctor_offsets";
    plb ");";

    plb (gen_offset_tables syms bbdfns);

    if !print_flag then print_endline "//GENERATING C++: method bodies";
    plb "//FUNCTION METHODS";
    plb (gen_execute_methods syms bbdfns syms.counter);

    if !print_flag then print_endline "//GENERATING C++: interface";
    plb "//EXTERNAL INTERFACE";
    plb "extern \"C\" global_frame_t *create_global_frame() {";
    plb "  return new global_frame_t;";
    plb "}";

    plb "extern \"C\" void destroy_global_frame(";
    plb "  global_frame_t *gf";
    plb ") {";
    plb "  delete gf;";
    plb "}";

    plb "extern \"C\" process_frame_t *create_process_frame(";
    plb "  global_frame_t *gf";
    plb  ") {";
    plb "  return new process_frame_t(gf);";
    plb "}";

    plb "extern \"C\" void destroy_process_frame(";
    plb "  process_frame_t *pf";
    plb  ") {";
    plb "  delete pf;";
    plb "}";

    plb "extern \"C\" thread_frame_t *create_thread_frame(";
    plb "  global_frame_t *gf,";
    plb "  process_frame_t *pf,";
    plb "  flx::gc::generic::collector_t *gc";
    plb ") {";
    plb "  return new thread_frame_t(gf,pf,gc);";
    plb "}";

    plb "extern \"C\" void destroy_thread_frame(";
    plb "  thread_frame_t *tf";
    plb ") {";
    plb "  delete tf;";
    plb "}";

    plb "extern \"C\" continuation_t *start(";
    plb "  global_frame_t *gf,";
    plb "  process_frame_t *pf,";
    plb "  thread_frame_t *tf";
    plb ") {";
    plb ("  return (new(*tf->gc,"^top_class^"_ptr_map) " ^ top_class ^ "(gf,pf,tf))->call(0);");
    plb "}";

    plh "//EXPORTS";
    plh (gen_biface_headers syms bbdfns bifaces);
    plb "//EXPORTS";
    plb (gen_biface_bodies syms bbdfns bifaces);

    close_out hf;
    close_out bf;
    exit (if !return_parity then 0 else 1)

with 
  | LexError s ->
    flush stdout; print_endline "LEX ERROR";
    print_endline s;
    exit (if !return_parity then 1 else 0)

  | TokenError s ->
    flush stdout; print_endline "TOKEN ERROR";
    print_endline s;
    exit (if !return_parity then 1 else 0)

  | SyntaxError s ->
    flush stdout; print_endline "SYNTAX ERROR";
    print_endline s;
    exit (if !return_parity then 1 else 0)

  | ParseError s ->
    flush stdout; print_endline "PARSE ERROR";
    print_endline s;
    exit (if !return_parity then 1 else 0)

  | ClientError (sr,s) ->
    flush stdout; print_endline "CLIENT ERROR";
    print_endline ("In " ^ short_string_of_src sr);
    print_endline s;
    exit (if !return_parity then 1 else 0)


  | Failure s -> 
    flush stdout; print_endline "SYSTEM FAILURE";
    print_endline s;
    exit (if !return_parity then 1 else 0)

  | x -> 
    flush stdout; print_endline "EXCEPTION"; 
    print_endline (Printexc.to_string x);
    exit (if !return_parity then 1 else 0)
;;

