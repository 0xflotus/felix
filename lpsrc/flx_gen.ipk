@head(1,'GC shape object generator')
@h = tangler('src/flx_display.mli')
@select(h)
open Flx_types
open Flx_ast
val get_display_list:
  sym_state_t ->
  bid_t ->
  bid_t list


@h = tangler('src/flx_display.ml')
@select(h)
open Flx_ast
open Flx_types

let rec cal_display dfns parent display : bid_t list =
  match parent with 
  | None -> display
  | Some parent ->
  let id,sr,parent',vs,_,_,entry = Hashtbl.find dfns parent in
  match entry with
  | `SYMDEF_function _
  | `SYMDEF_match_check _
    -> cal_display dfns parent' (parent::display)
  | _ -> cal_display dfns parent' display
   
let get_display_list syms index : bid_t list =
  let dfns = syms.dfns in
  let id,sr,parent,vs,_,_,entry = Hashtbl.find dfns index in
  match entry with
  | `SYMDEF_function _
  | `SYMDEF_match_check _
    -> List.rev (cal_display dfns parent [])

  | _ -> 
    failwith 
    (
      "Only functions and procedures have a display, got: " ^
      Flx_print.string_of_symdef entry id vs
    )


@h = tangler('src/flx_ogen.mli')
@select(h)
open Flx_ast
open Flx_types
val gen_offset_tables:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  string

@h = tangler('src/flx_ogen.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_name
open Flx_unify
open Flx_typing
open Flx_tgen
open List

let find_references bbdfns name_map ts = 
  let references = ref [] in
  Hashtbl.iter
  (fun id entryset -> 
    try
      match entryset with
      | FunctionEntry _ -> ()
      | NonFunctionEntry (Bound _) -> 
        failwith "Not expecting bound entry"

      | NonFunctionEntry (Simple idx) ->
      let _,_,bbdfn = 
        (* try *)
        Hashtbl.find bbdfns idx
        (*
        with Not_found -> 
          failwith 
          (
            "[find_references] can't find index " ^ 
            si idx ^
            " for name '" ^ id ^ "'"
          )
        *)
      in
      match bbdfn with
      | `BBDCL_var (vs,(`BTYP_pointer _ as t))
      | `BBDCL_val (vs,(`BTYP_pointer _ as t))
        -> 
        if length ts <> length vs then 
        failwith 
        (
          "[find_references} wrong number of args, expected vs = " ^ 
          si (length vs) ^ 
          ", got ts=" ^ 
          si (length ts)
        );
        let t = tsubst vs ts (lower t) in
        references := (idx,t) :: !references
      | _ -> ()
    with Not_found -> ()
  ) 
  name_map
  ;
  !references

let comma_sub s = 
  let rec aux l r =
    try  
      let i = String.index r ',' in
      let n = String.length r in
      aux (l ^ String.sub r 0 i ^ " comma ") (String.sub r (i+1) (n-i-1))
    with Not_found -> l ^ r
  in
  aux "" s
 
(* this code handles tuples and pointers *)
let rec get_offsets syms bbdfns typ : string list =
  let tname = cpp_typename syms typ in
  match unfold typ with
  | `BTYP_pointer t -> 
    ["offsetof("^tname^",frame)"]

  | `BTYP_tuple args -> 
    let n = ref 0 in
    let lst = ref [] in
    iter 
    (fun t ->
      let prefix = 
        "offsetof("^tname^",mem_"^si !n^")+" 
      in
      iter
      (fun s -> lst := !lst @ [prefix ^ s])
      (get_offsets syms bbdfns t)
      ;
      incr n
    )
    args
    ;
    !lst

  | _ -> []

let gen_offset_data s n name offsets =
  if n <> 0 then
  begin
    bcat s ("static size_t " ^ name ^ "_offsets["^si n^"]={\n  ");
    bcat s ("  " ^ cat ",\n  " offsets);
    bcat s ("\n" ^  "};\n");
  end;
  bcat s ("static void " ^ name ^ "_finaliser(collector_t *, void *p){\n");
  bcat s ("  (("^ name ^ "*)p)->~" ^ name ^ "();\n}\n");
  bcat s (  "static gc_shape_t "^ name ^"_ptr_map (\n");
  bcat s ( "  sizeof("^name^"),\n  "^name^"_finaliser,\n  "^si n^",\n  "^
  (if n<>0 then name^"_offsets\n" else "0\n"));
  bcat s ( ");\n")

let gen_fun_offsets s syms bbdfns index vs ps ret name_map ts instance = 
  let refnames = 
    map 
    (fun (index,t)-> 
      cpp_instance_name syms bbdfns index ts,
      cpp_typename syms t
    )
    (find_references bbdfns name_map ts)
  in
  let name = cpp_instance_name syms bbdfns index ts in
  let display = Flx_display.get_display_list syms index in
  let offsets = 
    (match ret with 
      | `BTYP_void -> [ ("offsetof(" ^ name ^ ",_caller)")  ] 
      | _ -> []
    ) 
    @
    map
    (fun didx ->
    let dptr = "ptr" ^ cpp_instance_name syms bbdfns didx ts in
    "offsetof("^name^","^dptr^")"
    )
    display
    @
    map 
    (fun (mem,reftyp)->
      "offsetof("^name^","^mem^")" ^
      "+offsetof("^comma_sub reftyp^",frame)") 
    refnames
  in
  let n = length offsets in
  bcat s 
  (
    "\n//OFFSETS for "^
    (match ret with |`BTYP_void -> "procedure " | _ -> "function ") ^ 
    name ^ "\n"
  );
  gen_offset_data s n name offsets

let gen_offset_tables syms bbdfns=
  let primitive_shapes = Hashtbl.create 97 in
  let s = Buffer.create 20000 in

  (* print_endline "Function and procedure offsets"; *)
  Hashtbl.iter
  (fun (index,ts) instance ->
  let id,parent,entry = Hashtbl.find bbdfns index in 
  match entry with
  | `BBDCL_function (vs,ps, ret,_,name_map) -> 
    gen_fun_offsets s syms bbdfns index vs ps ret name_map ts instance
      
  | `BBDCL_procedure (vs,ps,_,name_map) -> 
    gen_fun_offsets s syms bbdfns index vs ps `BTYP_void name_map ts instance
  | _ -> ()
  )
  syms.instances
  ;

  (* We're not finished: we need offsets for tuple and pointer types too *)
  (* print_endline "Tuple and pointer offsets"; *)
  Hashtbl.iter
  (fun btyp index -> 
    (*
    print_endline ("type --> " ^ string_of_btypecode syms.dfns btyp);
    *)
    match unfold btyp with
    | `BTYP_tuple args ->
      let name = cpp_type_classname syms btyp in
      let offsets = get_offsets syms bbdfns btyp in
      let n = length offsets in 
      let classname = cpp_type_classname syms btyp in
      bcat s ("\n//OFFSETS for tuple type " ^ si index ^ "\n");
      gen_offset_data s n name offsets

    | `BTYP_pointer t ->
      let name = cpp_typename syms btyp in
      let offsets = get_offsets syms bbdfns btyp in
      let n = length offsets in 
      bcat s ("\n//OFFSETS for pointer type " ^ si index ^ "\n");
      bcat s ("static size_t " ^ name ^ "_offsets[]={\n  ");
      bcat s ("  " ^ cat ",\n  " offsets);
      bcat s "};\n";
      bcat s ( "static gc_shape_t "^ name ^"_ptr_map(\n");
      bcat s ("  sizeof("^name^"),\n  0,\n  "^si n^",\n  "^name^"_offsets\n");
      bcat s ");\n"

    | `BTYP_inst (i,ts) ->
      let name = cpp_typename syms btyp in
      let id,parent,entry = Hashtbl.find bbdfns i in 
      begin match entry with
      | `BBDCL_abs (_,_) ->
        if not (Hashtbl.mem primitive_shapes name) then 
        begin
          Hashtbl.add primitive_shapes name true; 
          bcat s ("\n//OFFSETS for abstract type " ^ name ^ " instance\n");
          bcat s ( "static gc_shape_t " ^ name ^ "_ptr_map(\n") ;
          bcat s ("  sizeof("^name^"),0,0,0\n");
          bcat s ");\n"
        end else begin
          bcat s ("\n//OFFSETS for abstract type " ^ name ^ " instance\n");
          bcat s ("//Use "^name^"_ptr_map\n");
        end
      | `BBDCL_struct (vs,cps) ->
        bcat s ("\n//OFFSETS for struct type " ^ name ^ " instance\n");
        bcat s ("//CANT HANDLE YET!\n");
      | _ -> ()
    end

   | _ -> () 
  )
  syms.registry
  ;
  Buffer.contents s

@head(1,'C++ Code generator')
@h = tangler('src/flx_gen.mli')
@select(h)
open Flx_ast
open Flx_types
val gen_functions:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  string

val gen_execute_methods:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ref ->
  out_channel ->
  unit

val find_members:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  btypecode_t list ->
  string

val gen_biface_headers:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string

val gen_biface_bodies:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string
  
@h = tangler('src/flx_gen.ml')
@doc()
Ref counting notes. 
@p()
Call: the callers frame count is up by 1,
since the callee has a link to it.
The callee count should probably go up by 1 too.
@p()
Return: the callers count goes down,
because the callee no longer has a link to it.
The callee's count should go down by 1.
@p()
Jump: we give the callee our own callers
address, so that should remain the same.
Our own count goes down by 1, the new frame's up by 1.
@p()
Loop. Nothing changes if we loop to ourself.
If we loop up scope, the stack must be unwound
by the equivalent of a lot of returns.
@p()
Issue: The driver holds the current frame's address (old)
and then get the new one (new). Logically it should
increment new, and decrement old (in that order in case
its the same frame). Unfortunately, this cannot work
in the return case, since the calling code decrements
the callers frame to zero before it is returned
to the driver, and it is too late to increment it
back again.
@p()
This means the driver cannot do the increment
on the frame it gets, and so it has to be done
by the client.
@p()
On the other hand, its OK for the driver to
decrement a frame it is losing. On a return,
this deletes the callee. On a call, the callers
count goes down by one, but only after the increment
due to the callee acquiring it. It is also possible
to 'decref(this)' on the client side, since we actually
know the driver is holding a pointer to us, and will
soon lose it.
@p()
Call: increment new frame. The link in the new frame to 
us replaces the one the driver holds, so our refcount
doesn't change.
@p()
Return: decrement this. Although the link to 
the caller is no longer valid, the driver is about
to acquire the caller, so leave the caller count alone.
@p()
Jump: increment the new frame and decrement this.

@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_typing
open Flx_name
open Flx_tgen
open Flx_unify
open Flx_csubst
open Flx_exceptions
open Flx_display
open List

let string_of_string = Flx_string.c_quote_of_string

(* HACKERY: this assumes library dependent things:
  but we can't add literals in the library code :-(
*)
let csuffix_of_type s = match s with
  | "tiny" -> ""
  | "short" -> ""
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "ll"
  | "utiny" -> "u"
  | "ushort" -> "u"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "llu"
  | "int8" -> ""
  | "int16" -> ""
  | "int32" -> "l"
  | "int64" -> "ll"
  | "uint8" -> "u"
  | "uint16" -> "u"
  | "uint32" -> "lu"
  | "uint64" -> "llu"
  | "double" -> ""
  | "float" -> "f"
  | "ldouble" -> "l"
  | _ -> failwith ("[csuffix_of_type]: Unexpected Type " ^ s)

let cstring_of_literal e = match e with
  | `AST_int (s,i) -> (Big_int.string_of_big_int i)^csuffix_of_type s 
  | `AST_float (s,x) -> x ^ csuffix_of_type s
  | `AST_string s -> string_of_string s
  | `AST_wstring s -> "L" ^ string_of_string s
  | `AST_ustring s -> "L" ^ string_of_string s

let dummy_name_map = Hashtbl.create 97

(* self's child's parent is normally self,
  but there could be a module stuck in between,
  so the child's parent is the module whose
  parent is a module ... whose parent is self
*)
  
   
(* WARNING WARNING:

  this algorithm makes a list, assuming
  that name -> index is unique on the index

  this won't be the case when we inject
  entries

  even though we check that the denoted
  entity is a child, an actual child can
  have a second name, and so occurs twice
  in the name->index map

  we need to use a SET here, not a list
*)

let find_variable_indices syms index = 
  let rec extract parent name_map = 
    let variables = ref [] in
    Hashtbl.iter
    (fun id entryset -> 
      match entryset with
      | FunctionEntry _ -> ()
      | NonFunctionEntry (Bound _) ->
        failwith "Not expecting bound entry"
      | NonFunctionEntry (Simple idx) ->
      let id2,_,parent',vs,name_map2,_,symdef = 
        try Hashtbl.find syms.dfns idx 
        with _ -> failwith ("[find_variable_indices(2)] can't find index " ^ si index)
      in

      (* make sure the entity is actually a child of index,
        and not say a link to root, parent, or self.
      *)
      let sp p = match p with | None -> "none" | Some i -> si i in
      if parent' = parent
      then 
        begin
          match symdef with
          | `SYMDEF_parameter _
          | `SYMDEF_var _ 
          | `SYMDEF_val _
            -> 
      (*
      print_endline (si index ^ ": " ^id ^"="^id2^ "<" ^ si idx ^">"^" member parent=" ^sp parent'); 
      *)
              variables := idx :: !variables

          (* variables of a nested module are lifted into the function *)
          | `SYMDEF_module
            -> 
      (* print_endline (si index ^ ": " ^id ^ "="^id2^"<" ^ si idx ^">"^" nested module parent=" ^sp parent'); *)
              variables := extract (Some idx) name_map2 @ !variables
          | _ -> ()
        end
    ) 
    name_map
    ;
    !variables
  in 
  let id,_,_,_,name_map,_,symdef = 
    try Hashtbl.find syms.dfns index 
    with _ -> failwith ("[find_variable_indices(1)] Can't find index " ^ si index)
  in
  extract (Some index) name_map 

let get_variable_typename syms bbdfns i ts =
  let id,parent,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_var (vs,t)
  | `BBDCL_val (vs,t) ->
    let t = lower t in
    if length ts <> length vs then 
    failwith 
    (
      "[get_variable_typename} wrong number of args, expected vs = " ^ 
      si (length vs) ^ 
      ", got ts=" ^ 
      si (length ts)
    );
    let t = tsubst vs ts t in
    cpp_typename syms t

  | _ -> 
    failwith "[get_variable_typename] Expected variable"

let get_fun_tn syms vs ps ret ts =
  let pts = map (fun (_,(_,t)) -> t) ps in
  let pt = typeoflist pts in
  let ft = fold (lower (`BTYP_function (pt,ret))) in
  if length ts <> length vs then 
  failwith 
  (
    "[get_fun_tn} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let t = tsubst vs ts ft in
  cpp_typename syms t

let get_function_typename syms bbdfns i ts =
  let id,parent,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (vs,ps,ret,_,_) ->
     get_fun_tn syms vs ps ret ts

  | `BBDCL_procedure (vs,ps,_,_) ->
     get_fun_tn syms vs ps `BTYP_void ts
  | _ -> failwith "[get_function_typename] Expected function"

let find_members syms bbdfns index ts = 
  let variables = find_variable_indices syms index in
  let members = 
  cat ""
  (
    map 
    (fun idx -> 
        let instname = 
          try Some (cpp_instance_name syms bbdfns idx ts) 
          with _ -> None
        in match instname with
        | Some instname ->
          let typename = get_variable_typename syms bbdfns idx ts in
          "  " ^ typename ^ " " ^ instname ^ ";\n"
        | None -> "" (* ignore unused variables *)
    )
    variables
  )
  in 
    let member_string =
      if members <> "" then "  //variables\n" ^ members
      else ""
    in
      member_string

let typeof_bparams ps: btypecode_t  = 
  typeoflist 
  (map
  (fun (id,(ix,t)) ->t) 
  ps
  )

let get_type bbdfns index = 
  let id,parent,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_type] Can't find index " ^ si index)
  in
  match entry with
  | `BBDCL_function (vs,ps,ret,_,_) -> 
      `BTYP_function (typeof_bparams ps,ret)
  | `BBDCL_procedure (vs,ps,_,_) -> 
      `BTYP_function (typeof_bparams ps,`BTYP_void)
  | _ -> failwith "Only function and procedure types handles by get_type"


(* vs here is the (name,index) list of type variables *)
let gen_function syms bbdfns index id vs bps ret' ts instance_no =
  let ps = map (fun (id,(ix,t)) -> id,t) bps in
  if syms.compiler_options.print_flag then
  print_endline 
  (
    "//Generating function inst " ^ 
    si instance_no ^ "=" ^ 
    id ^ "<" ^si index^">" ^
    (
      if length ts = 0 then "" 
      else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
    )
  );
  let argtype = lower(typeof_bparams bps) in
  if length ts <> length vs then 
  failwith 
  (
    "[gen_function} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let argtype = tsubst vs ts argtype in
  let ret = lower ret' in
  let ret = tsubst vs ts ret in
  let funtype = fold (`BTYP_function (argtype, ret)) in

  let argtypename = cpp_typename syms argtype in
  let funtypename = cpp_type_classname syms funtype in 
  let display = get_display_list syms index in
  let frame_dcls = 
    "  //OS frames\n" ^
    "  FLX_FMEM_DECL\n"
  in
  let display_string = match display with
    | [] -> ""
    | display -> 
      "  //display\n" ^
      cat "" 
      (
        map
        (fun i-> 
         let instname = cpp_instance_name syms bbdfns i ts in
         "  " ^ instname ^ " *ptr" ^ instname ^ ";\n"
         )
        display
      )
  and ctor_dcl name =  
    "  " ^name^
    "  (\n" ^
    cat ",\n"
      (
        "    FLX_FPAR_DECL " ::
        map 
        (
          fun i -> 
          let instname = cpp_instance_name syms bbdfns i ts in
          "    " ^ instname ^ "*"
        )
        display
      )^
      "\n  );\n" 
  in
  let members = find_members syms bbdfns index ts in
  match ret with
  | `BTYP_void ->
    let name = cpp_instance_name syms bbdfns index ts in
    "struct " ^ name ^
    ": "^funtypename^" {\n" ^
    (if argtype = `BTYP_tuple [] 
    then
    "  con_t *call(con_t*);\n" 
    else
    "  con_t *call(con_t*,"^argtypename^" const &);\n"
    ) ^
    "  con_t *resume();\n"  ^
    "  con_t *_caller; // callers return address\n" ^
    frame_dcls ^
    display_string ^ "\n" ^
    "  //constructor\n" ^
    ctor_dcl name ^
    members ^
    "};\n"

  | _ ->
    let name = cpp_instance_name syms bbdfns index ts in
    let rettypename = cpp_typename syms ret in
    let ctor = ctor_dcl name in
    "struct " ^ name ^
    ": "^funtypename^" {\n" ^
    "  "^rettypename^" apply(" ^
    (if argtype = `BTYP_tuple[] then ""
    else argtypename^" const &")^ 
    ");\n"  ^
    frame_dcls ^
    display_string ^ "\n" ^
    "  //constructor\n" ^
    ctor ^
    members ^
    "};\n"


(* This code generates the class declarations *)
let gen_functions syms bbdfns = 
  let xxdfns = ref [] in
  Hashtbl.iter
  (fun x i -> 
    (* if proper_descendant syms.dfns parent then  *)
    xxdfns := (i,x) :: !xxdfns
  )
  syms.instances
  ;
  
  flush stdout;
  let s = Buffer.create 2000 in
  iter
  (fun (i,(index,ts)) ->
    let tss = 
      if length ts = 0 then "" else 
      "[" ^ catmap "," (string_of_btypecode syms.dfns) ts^ "]"
    in
    match Hashtbl.find bbdfns index with (id,parent,entry) -> 
    match entry with
    | `BBDCL_function (vs,ps, ret, _,_) -> 
      bcat s ("\n//------------------------------\n");
      bcat s ("//FUNCTION " ^ id ^ tss ^ "\n");
      bcat s 
      (gen_function syms bbdfns index id vs ps ret ts i)

    | `BBDCL_procedure (vs,ps,_,_) -> 
      bcat s ("\n//------------------------------\n");
      bcat s ("//PROCEDURE " ^ id ^ tss ^ "\n");
      bcat s 
      (gen_function syms bbdfns index id vs ps `BTYP_void ts i)
    | _ -> () (* bcat s ("//SKIPPING " ^ id ^ "\n") *)
  )
  (sort compare !xxdfns)
  ;
  Buffer.contents s

let gen_ctor syms bbdfns name display ts =
  name^"::"^name^
  "\n  (\n" ^
  cat ",\n"
  (
    "    FLX_FPAR_DECL" ::
    map 
    (
      fun i -> 
        let instname = cpp_instance_name syms bbdfns i ts in
      "    " ^ instname ^ " *pptr" ^ instname
    )
    display
  )^
  "\n  ):\n" ^
  cat ",\n"
  (
    "  FLX_FMEM_INIT" ::
    map 
    (
      fun i -> let instname = cpp_instance_name syms bbdfns i ts in
      "  ptr" ^ instname ^ "(pptr"^instname^")"
    )
    display
  ) ^ 
  "\n  {}\n"

let is_closure_var bbdfns index =
  let var_type bbdfns index =
    let id,_,entry = 
      try Hashtbl.find bbdfns index
      with Not_found -> failwith ("[var_type] ]Can't get index " ^ si index)
    in match entry with 
    | `BBDCL_var (_,t) 
    | `BBDCL_val (_,t) -> lower t
    | _ -> failwith ("[var_type] expected "^id^" to be variable")
  in
  match var_type bbdfns index with
  | `BTYP_function _ -> true
  | _ -> false
  
let get_var_ref syms bbdfns this index ts : string =
  let id,sr,parent,vs,_,_,entry = 
    try Hashtbl.find syms.dfns index 
    with _ -> failwith ("[get_var_ref] Can't find index " ^ si index)
  in  
  (*
  print_endline ("get var ref for " ^ id ^ "<" ^ si index ^ ">["^catmap "," (string_of_btypecode syms.dfns) ts^"]");
  *)
  match entry with
  | `SYMDEF_parameter t
  | `SYMDEF_var (t)
  | `SYMDEF_val (t) ->
    let rec chase_tail parent =
      match parent with
      | None -> "ptf->" ^ cpp_instance_name syms bbdfns index ts
      | Some i ->
        let _,sr,parent,_,_,_,entry = 
          try Hashtbl.find syms.dfns i 
          with _ -> failwith ( "[get_var_ref(1)] Can't find index " ^ si i)
        in
        match entry with
        | `SYMDEF_function _
          ->
          (if i <> this then "ptr" ^ cpp_instance_name syms bbdfns i ts ^ "->" else "") ^
          cpp_instance_name syms bbdfns index ts
          
        | `SYMDEF_module -> chase_tail parent
        | _ -> failwith "[get_var_ref(2)] Expected variable to live in procedure or function"
    in 
      chase_tail parent
  | _ -> failwith ("[get_var_ref(3)] Expected name "^id^" to be variable or value")

let get_var_frame syms bbdfns this index ts : string =
  let id,sr,parent,vs,_,_,entry = 
    try Hashtbl.find syms.dfns index 
    with _ -> failwith ("[get_var_frame(1)] Can't find index " ^ si index)
  in
  match entry with
  | `SYMDEF_parameter _
  | `SYMDEF_var _
  | `SYMDEF_val _
  ->
    let rec chase_tail parent =
      match parent with
      | None -> "((void*)0)"
      | Some i ->
        let _,sr,parent,vs,_,_,entry = Hashtbl.find syms.dfns i in
        match entry with
        | `SYMDEF_function _
          ->
          if i <> this
          then "ptr" ^ cpp_instance_name syms bbdfns i ts
          else "this"
        | `SYMDEF_module -> chase_tail parent
        | _ -> failwith "[get_var_frame] Expected variable to live in procedure or function"
    in
      chase_tail parent
  | _ -> failwith ("[get_var_frame] Expected name "^id^" to be variable or value")

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls -> 
    fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

  | _ -> false

let rec gen_expr syms bbdfns this (e,t) vs ts =
  (*
  print_endline ("Generating expression " ^ string_of_bound_expression syms.dfns (e,t));
  *)
  let ge e = gen_expr syms bbdfns this e vs ts in
  if length ts <> length vs then 
  failwith 
  (
    "[gen_expr} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let tsub t = tsubst vs ts t in
  let tn t = cpp_typename syms (tsub (lower t)) in
  let ge_arg a = 
    match a with
    | _,`BTYP_tuple [] -> ""
    | x -> ge x 
  in
  let id,parent,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_expr] Can't find this = " ^ si this)
  in
  let our_display = get_display_list syms this in
  let our_level = length our_display in
  match e with
  | `BEXPR_coercion (e,t) -> 
    (* generate a function style cast *)
    tn t ^ "(" ^ ge e ^ ")"
    
  | `BEXPR_get_n (n,e) -> 
    "(" ^ ge e ^ ").mem_" ^ si n
    
  | `BEXPR_match_case (n,((e',t') as e)) -> 
    if is_unitsum t' then
      "((" ^ ge e ^ ") == " ^ si (n-1) ^ ")"
    else
      "((" ^ ge e ^ ").variant == " ^ si (n-1) ^ ")"

  | `BEXPR_case_arg (n,e) ->
    (* NOTE that the index is not used ... *)
    let _,t = e in
    let t = 
      match t with 
      | `BTYP_sum ls -> nth ls (n-1)
      | _ -> assert false
    in
      let t = tn t in
      (* really ugly brackets .. *)
      "(*("^t^"*)((" ^ ge e ^ ").data))"
     
  | `BEXPR_deref ((`BEXPR_ref index),`BTYP_pointer t) -> 
    ge (`BEXPR_name index,t)

  | `BEXPR_deref e -> 
    begin match e with (_,t) ->
    "*("^tn t^"*)(" ^ ge e ^ ".data)"
    end

  | `BEXPR_literal v ->
    let t = tn t in
    t ^ "(" ^ cstring_of_literal v ^ ")"
    
  | `BEXPR_case (v,t) ->
    begin match t with
    | `BTYP_sum ls ->
       let n = length ls in
       if v<1 or v>n
       then 
         failwith 
         (
           "Invalid case index " ^ si v ^
           " of " ^ si n ^ " cases"
         )
       else let t' = nth ls (v-1) in
       if t' = `BTYP_tuple []
       then (* closure of const ctor is just the const value ???? *)
         if is_unitsum t then
           si (v-1)
         else
           "_uctor_(" ^ si (v-1) ^ ",0)"
       else 
         failwith 
         ( 
            "Can't handle closure of case " ^ 
            si v ^ 
            " of " ^
            string_of_btypecode syms.dfns t
         )
       (* "(" ^ tn (lower t) ^ "*)_uctor_" *)

    | _ -> failwith "Case tag must have sum type"
    end 
   
  | `BEXPR_name (index,ts') -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> 
        let id,sr,parent,vs,_,_,entry = Hashtbl.find syms.dfns index in
        syserr sr
        ("[gen_expr(name)] Can't find "^ id ^ "<" ^ si index ^ ">")
    in
    let ts = map tsub ts' in
    begin match entry with
      | `BBDCL_var (_,t)
      | `BBDCL_val (_,t) ->
          get_var_ref syms bbdfns this index ts

      | `BBDCL_const (_,_,ct) -> ct

      | `BBDCL_struct _ 
      | `BBDCL_function _
      | `BBDCL_procedure _ 
      | `BBDCL_fun _
      | `BBDCL_proc _ ->
         failwith 
         (
           "[gen_expr: name] Open function '" ^ 
           id ^ "'<"^si index^
           "> in expression (closure required)"
         )
      | _ -> 
        failwith 
        (
          "[gen_expr: name] Cannot use this kind of name '"^
          id^"' in expression"
        )
    end

  | `BEXPR_closure (index,ts') -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    let ts = map tsub ts' in
    begin match entry with
    | `BBDCL_function _ 
    | `BBDCL_procedure _ ->
      let the_display = 
        let d' = 
          map (fun i-> "ptr"^ cpp_instance_name syms bbdfns i ts)
          (get_display_list syms index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      "(new(gc,"^name^"_ptr_map)\n        " ^ name ^
      "(" ^ cat ", " ("FLX_FPAR_PASS" :: the_display) ^
      "))"

    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith "[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression"
    end

  | `BEXPR_ref (index,ts') -> 
    let ts = map tsub ts' in
    let t = lower t in
    let ref_type = tn (lower t) in
    let var_ptr = "&(" ^ get_var_ref syms bbdfns this index ts ^ ")" in
    let frame_ptr = get_var_frame syms bbdfns this index ts in
    let reference = ref_type ^ 
      "((void*)" ^ frame_ptr ^ ", " ^ var_ptr ^ ")" 
    in
    reference

  | `BEXPR_apply 
     (
       (`BEXPR_case (v,t),t'),
       (a,t'') 
     ) ->
       (* t is the type of the sum, 
          t' is the function type of the constructor,
          t'' is the type of the argument
       *)
       let 
         arg_typename = tn (lower t'') 
       and
         union_typename = tn (lower t)
       in

       let aval = 
         "new (gc, "^arg_typename^"_ptr_map) " ^
         arg_typename ^ "(" ^ ge (a,t'') ^ ")"
       in
       let uval = "_uctor_(" ^ si (v-1) ^ ", " ^ aval ^")" in
       "(" ^ union_typename ^ ")" ^ uval
       (*
       failwith 
       (
         "Trapped application, case " ^ 
         si v ^
         " of " ^ string_of_btypecode syms.dfns t ^
         "\ntype " ^ string_of_btypecode syms.dfns t' ^
         "\nargument=" ^ 
         string_of_bound_expression syms.dfns (a,t'') ^
         "\ntype " ^ string_of_btypecode syms.dfns t''
       )
      *) 


  | `BEXPR_apply ((`BEXPR_closure (index,ts),_) as f,a) ->
    (*
    print_endline "Apply closure ..";
    *)
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct) -> 
      if length vs <> length ts then
      failwith 
      (
        "[get_expr:apply closure of fun] function " ^ 
        id ^ "<" ^ si index ^">" ^
        ", wrong number of args, expected vs = " ^ 
        si (length vs) ^ 
        ", got ts=" ^ 
        si (length ts)
      );
      let ts = map tsub ts in
      let retyp = tsubst vs ts retyp in
      let retyp = tn retyp in
      let ts = map tn ts in
      begin
        (*
        print_endline "--- CASE OF PRIMITIVE"; 
        *)
        match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          let ess = map ge es in
          let ets = map tn typs in
          let tt = tn (`BTYP_tuple typs) in
          "(" ^ csubst ct ess ets tt retyp ts ^")"
        | (_,typ) -> 
          let typ = tn typ in
          let a = ge a in
          "(" ^ csubst ct [a] [typ] typ retyp ts ^ ")"
      end

    | `BBDCL_function (vs,ps,retyp,_,_) ->
      (ge f) ^ "->apply(" ^ ge_arg a ^ "/* MAY NEED INCREF */)"

    | `BBDCL_struct (vs,_) ->
      let name = tn (`BTYP_inst (index,ts)) in
      name ^ "(" ^ ge a ^ ")"

    | _ -> 
      failwith 
      (
        "[gen_expr] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  (* General application*)
  | `BEXPR_apply (f,a) ->
    (ge f) ^ "->apply(" ^ ge_arg a ^ "/* MAY NEED INCREF */)"
    
  | `BEXPR_tuple es ->
    (* just apply the tuple type ctor to the arguments *)
    let ctyp = tn (lower t) in
    ctyp ^ "(" ^
    cat ", " (map ge es) ^
    ")"

  | `BEXPR_dot (e,index) -> "Can't handle unions yet"
    (* structure component: the Felix and C++ names
       of the component are the same
    *)
    (* "(" ^ ge e ^ ")." ^ name *)

  (*
  | `BEXPR_name (index,ts) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    begin match entry with
    | `BBDCL_function _ 
    | `BBDCL_procedure _ ->
      let the_display = 
        let d' = 
          map (fun i-> "ptr"^ cpp_instance_name syms bbdfns i ts)
          (get_display_list syms index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      let ptr_map = name ^ name^"_ptr_map"in
      "(new(gc,"^ptr_map^")\n        " ^ name ^ 
      "(" ^ cat ", " ("FLX_FPAR_PASS" :: the_display) ^
      "))"

    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith "[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression"
    end
  *)

let get_labels bbdfns counter exes =
  let labels = Hashtbl.create 97 in
  iter
    (fun exe -> match exe with 
      | `BEXE_label s -> Hashtbl.add labels s !counter; incr counter
      | _ -> ()
    )
    exes
  ;
  labels

let create_label_map bbdfns counter =
  let label_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun index (id,parent,entry) ->
    match entry with
    | `BBDCL_function (_,_,_,exes,_) -> 
      Hashtbl.add label_map index (get_labels bbdfns counter exes)
    | `BBDCL_procedure (_,_,exes,_) -> 
      Hashtbl.add label_map index (get_labels bbdfns counter exes)
    | _ -> ()
  ) 
  bbdfns
  ;
  label_map

let get_parameters syms index : int list =
  let variables = find_variable_indices syms index in
  let params = 
    filter
    (fun i -> let id,sr,parent,vs,_,_,entry = 
      try Hashtbl.find syms.dfns i 
      with _ -> failwith ("[get_parameters] Can't find index " ^ si i)
      in
      match entry with 
      | `SYMDEF_parameter _ -> true
      | _ -> false
    )
    variables
  in 
    sort compare params

type kind_t = Function | Procedure

let gen_exe syms bbdfns label_map counter this vs ts (exe:bexe_t) : string =
  if length ts <> length vs then 
  failwith 
  (
    "[gen_exe} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let sr = ("dummy",0,0,0,0) in
  let src_str = string_of_bexe syms.dfns 0 exe in
  (*
  print_endline ("generating exe " ^ string_of_bexe syms.dfns 0 exe);
  print_endline ("vs = " ^ catmap "," (fun (s,i) -> s ^ "->" ^ si i) vs);
  print_endline ("ts = " ^ catmap ","  (string_of_btypecode syms.dfns) ts);
  *)
  let tsub t = tsubst vs ts t in
  let ret_string = "      FLX_RETURN\n" in
  let ge e : string = gen_expr syms bbdfns this e vs ts in
  let tn t : string = cpp_typename syms (tsubst vs ts (lower t)) in
  let id,parent,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_exe] Can't find this " ^ si this)
  in
  let our_display = get_display_list syms this in
  let kind = match entry with
    | `BBDCL_function (_,_,_,_,_) -> Function
    | `BBDCL_procedure (_,_,_,_) -> Procedure
    | _ -> failwith "Expected executable code to be in function or procedure"
  in let our_level = length our_display in

  let handle_closure is_jump index ts a =
    (* DISABLE JUMP OPTIMISATION *)
    let was_jump = is_jump in
    let is_jump = false in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_exe(call)] Can't find index " ^ si index)
    in
    begin 
    match entry with
    | `BBDCL_proc (vs,_,ct) -> 
      (*
      print_endline "Handling call to primitive ..";
      *)
      let s = begin
        if length vs = length ts 
        then 
          let ts = map tn ts in
          begin match a with
          | (`BEXPR_tuple es,`BTYP_tuple typs) ->
            let ess = map ge es in
            let ets = map tn typs in
            let tt = tn (`BTYP_tuple typs) in
            "      //call multi (or no) -arg primitive " ^ src_str ^ "\n" ^
            "      {" ^ csubst ct ess ets tt "Error" ts^ "}\n"
          | (_,typ) -> 
            (*
            print_endline ("One argument primitive .. type is " ^ string_of_btypecode syms.dfns typ);
            *)
            let typ = tn typ in
            (*
            print_endline (" .. C++ type name is " ^ typ);
            *)
            let a = ge a in
            "      //call single-arg primitive " ^ src_str ^ "\n" ^
            "      {" ^ csubst ct [a] [typ] typ "Error" ts^ "}\n"
          end
          ^
          begin
            if is_jump then ret_string
            else ""
          end
        else failwith "[handle_closure] Wrong number of type arguments"
      end
      in 
        (*
        print_endline ".. done with call to primitive";
        *)
        s

    | `BBDCL_procedure (vs,ps,bexes,nmap) ->
      if bexes = []
      then 
      "      //call to empty procedure " ^ id ^ " elided\n"
      else begin
        let n = !counter in
        incr counter;
        let the_display = 
          let d' = 
            map (fun i -> "ptr"^cpp_instance_name syms bbdfns i ts)
            (get_display_list syms index)
          in 
            if length d' > our_level
            then "this" :: tl d'
            else d'
        in
        (* if we're calling from inside a function,
           we pass a 0 continuation as the caller 'return address'
           otherwise pass 'this' as the caller 'return address'
        *)
        let this = match kind with
          | Function -> 
            if is_jump 
            then 
              clierr sr "can't jump inside function" 
            else "0"
          | Procedure -> 
            if is_jump then "tmp"
            else "this"
        in

        let args = match a with
          | _,`BTYP_tuple [] -> this
          | _ -> this ^ ", " ^ ge a
        in

        let name = cpp_instance_name syms bbdfns index ts in
        let ptrmap = name ^ "_ptr_map" in
        begin 
          match kind with
          | Function ->
            "      //run procedure " ^ src_str ^ "\n" ^
            "      con_t *_p =\n" ^
            "      (new(gc,"^ ptrmap^")\n" ^ 
            "      " ^ name ^ 
            "(" ^ cat ",\n      " ("FLX_FPAR_PASS":: the_display) ^
            "))->call(\n      " ^ args ^ "\n      );\n" ^
            "      while(_p) _p=_p->resume();\n"

          | Procedure ->
            let call_string =
              "      return (new(gc,"^ ptrmap^")\n" ^ 
              "      " ^ name ^ 
              "(" ^ cat ",\n      " ("FLX_FPAR_PASS":: the_display) ^
              "))->call(\n      " ^ args ^ "\n      );\n"
            in
            if is_jump
            then
              "     //jump to procedure " ^ src_str ^ "\n" ^
              "     {\n" ^
              "       con_t *tmp = _caller;\n" ^
              "       _caller = 0;\n" ^
              "      decref(this);\n" ^
              call_string ^
              "      }\n"
            else
              "     //call procedure " ^ src_str ^ "\n" ^
              "      pc = " ^ si n ^ ";\n" ^
              call_string ^
              "    case " ^ si n ^ ":\n"
        end
      end
      ^ (if was_jump then "FLX_RETURN // optimisation defeated\n" else "")

    | _ -> 
      failwith 
      (
        "[gen_exe] Expected '"^id^"' to be procedure constant, got " ^
        string_of_bbdcl syms.dfns entry index 
      )
    end
  in
  match exe with
  | `BEXE_code s -> s
  | `BEXE_comment s -> "\n/*" ^ s ^ "*/\n"
  | `BEXE_label s -> 
    let local_labels = 
      try Hashtbl.find label_map this 
      with _ -> failwith ("[gen_exe] Can't find label map of " ^ si this)
    in
    let label_index = 
      try Hashtbl.find local_labels s 
      with _ -> failwith ("[gen_exe] In " ^ id ^ ": Can't find label " ^ s)
    in
    (match kind with
      | Procedure ->
      "    case " ^ si label_index ^ ":\n" 
      | Function -> "" 
        (* labels mus be allowed in functions, to support
           local gotos
        *)
    )
    ^
    "    " ^ s ^ ":;\n"

  | `BEXE_goto s -> 
    let local_labels = 
      try Hashtbl.find label_map this 
      with _ -> failwith ("Can't find label map of " ^ si this)
    in
    if Hashtbl.mem local_labels s
    then "      goto " ^ s ^ ";\n"
    else let rec aux parent =
      match parent with
      | None -> failwith ("[gen_exe(goto)] In " ^ id ^ ": Can't find label " ^ s)
      | Some i -> 
         let id, sr, parent, vs,_,_,entry = 
           try Hashtbl.find syms.dfns i 
           with _ -> failwith ("Can't find parent " ^ si i)
         in
         match entry with
         | `SYMDEF_function (_,`AST_void _,_) ->
           let local_map = 
             try Hashtbl.find label_map i 
             with _ -> failwith ("Can't find label map for " ^ si i)
           in
           begin try i, Hashtbl.find local_map s
           with Not_found -> aux parent
           end
         | `SYMDEF_module  -> aux parent
         | `SYMDEF_function _ -> failwith ("goto "^s^" can't out of function")
         | _ -> failwith "Unknown parent kind"
    in 
      begin match kind with
      | Function -> failwith ("goto "^s^": can't jump out of function")
      | Procedure ->
      let id,parent,entry = 
        try Hashtbl.find bbdfns this 
        with _ -> failwith ("[gen_exe(goto)] Can't find this = " ^ si this)
      in
      let frame, pc = aux parent in
      let id,_,_ =
        try Hashtbl.find bbdfns frame 
        with _ -> failwith ("[gen_exe(goto)] Can't find frame " ^ si frame)
      in
        let frame_ptr = "ptr" ^ cpp_instance_name syms bbdfns frame ts in
        "      // non local goto " ^ s ^ "\n" ^
        "      {\n" ^
        "        con_t *tmp1 = this;\n" ^
        "        while(tmp1 && " ^ frame_ptr ^ "!= tmp1)\n" ^
        "        {\n" ^
        "          con_t *tmp2 = tmp1->_caller;\n" ^
        "          tmp1 -> _caller = 0;\n" ^
        "          decref(tmp1);\n" ^
        "          tmp1 = tmp2;\n" ^
        "        }\n" ^
        "      }\n" ^
        "      " ^ frame_ptr ^ "->pc="^si pc^";\n" ^
        "      return " ^ frame_ptr ^ ";\n"
      end

  (* conditional gotos are always local *)
  | `BEXE_ifgoto (e,s) -> "      if(" ^ ge e ^ ")goto " ^ s ^ ";\n"
  | `BEXE_ifnotgoto (e,s) ->"      if(!("^ge e^"))goto " ^ s ^ ";\n" 
  
  (*
  | `BEXE_jump ((`BEXPR_name (index,ts),_) as f,a) ->
    handle_ginst true index ts a

  | `BEXE_call ((`BEXPR_name (index,ts),_) as f,a) ->
    handle_ginst false index ts a
  *)

  | `BEXE_jump ((`BEXPR_closure (index,ts),_) as f,a) ->
    let ts = map tsub ts in
    handle_closure true index ts a
    
  | `BEXE_call ((`BEXPR_closure (index,ts),_) as f,a) ->
    let ts = map tsub ts in
    handle_closure false index ts a

  | `BEXE_loop (i,a) ->
    let ptr = 
      if i= 0 then "this"
      else 
        let k = nth our_display (i-1) in 
        "ptr"^cpp_instance_name syms bbdfns k ts
    in
      print_endline ("Looping to " ^ ptr);
      let args = match a with
        | _,`BTYP_tuple [] -> "_caller"
        | _ -> "_caller, " ^ ge a
      in
      "      //"^ src_str ^ "\n" ^
      "      return " ^ ptr ^ "->call(" ^ args ^");\n"

  (* BUG?!? if p is a variable containing a closure,
     and p recursively invokes the same closure,
     then the program counter and other state 
     of the closure is lost: the closure will return
     to its on previous state; that is, simply continue on:
     there's only one frame
   *)

  (* SEE HANDLE GINST ... *)
  (*
  | `BEXE_call ((`BEXPR_name (index,ts),`BTYP_function _) as p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "this"
      | _ -> "this, " ^ ge a
    in
    let n = !counter in
    incr counter;
    "// VARIABLE OF TYPE FUNCTION: NEED INCREF HERE\n" ^
    "      //"^ src_str ^ "\n" ^
    "      pc = " ^ si n ^ ";\n" ^
    "      return incref(" ^ ge p ^ ")->call(" ^ args ^");\n" ^
    "    case " ^ si n ^ ":\n"
  *)

  | `BEXE_call (p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "this"
      | _ -> "this, " ^ ge a
    in
    let n = !counter in
    incr counter;
    "// MAYBE NEED INCREF HERE\n" ^
    "      //"^ src_str ^ "\n" ^
    "      pc = " ^ si n ^ ";\n" ^
    "      return " ^ ge p ^ "->call(" ^ args ^");\n" ^
    "    case " ^ si n ^ ":\n"

  | `BEXE_jump (p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "tmp"
      | _ -> "tmp, " ^ ge a
    in
    "      //"^ src_str ^ "\n" ^
    "      {\n" ^
    "        con_t *tmp = _caller;\n" ^
    "        _caller=0;\n" ^
    "        decref(this);\n" ^
    "        return " ^ ge p ^ "->call(" ^ args ^");\n" ^
    "      }\n"

  | `BEXE_proc_return -> ret_string

  | `BEXE_read index -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    let t =
      match entry with
      | `BBDCL_var (_,t) -> t
      | `BBDCL_val (_,t) -> t
      | _ -> failwith "Expected read argument to be variable"
    in
    let n = !counter in
    incr counter;
    "      //read variable\n" ^
    "      p_message = &(" ^ get_var_ref syms bbdfns this index ts^");\n" ^
    "      action = wait_action;\n" ^
    "      pc=" ^ si n ^ ";\n" ^
    "      return this;\n" ^
    "    case " ^ si n ^ ":\n"

    
  | `BEXE_reglex (e,alpha,nstates,cases,matrix)
  | `BEXE_regmatch (e,alpha,nstates,cases,matrix) ->
    let b = Buffer.create 500 in
    let tack s = bcat b s in

    tack ("  // regmatch/lex: error state=0, start state=1, valid states=1 to "^si nstates^"\n");

    (* transition matrix *)
    let d = Array.make_matrix 256 nstates (-1) in
    Hashtbl.iter
    (fun (c,s1) s2 -> 
      d.(c).(s1) <- s2
    )
    matrix
    ;
    begin match exe with | `BEXE_reglex _ ->
    tack ("  // accepting states\n");
    tack ("  static int accept["^si (nstates+1)^"]={\n");
    tack (
      "    0," ^
      catmap "," 
      (fun i -> match Hashtbl.mem cases i with
      | true -> "1" | false -> "0"
      )
      (nlist nstates)
    );
    tack "\n  };\n";
    | _ -> ()
    end
    ;
    (* find equivalent chars *)
    tack "  // state->state transition vectors for canonical characters\n";
    let canon = Array.make 256 0 in
    for i = 0 to 255 do
      try
        for j = 0 to i do
          if d.(i) = d.(j) then 
          begin
            canon.(i) <- j;
            if i = j then
            begin
              tack("  static int s"^si i^"["^si (nstates+1)^"]=\n");
              tack "  {0, // error\n"
              ;
              for state = 0 to nstates - 1 do
                if state mod 16 = 0 then tack "      ";
                let s = "     " ^ si (d.(i).(state)+1) in
                let n = String.length s in
                let s = String.sub s (n-3) 3 in
                tack s;
                if state <> nstates - 1 then tack ", ";
                if state mod 16 = 15 then tack "\n"
              done
              ;
              tack "\n";
              tack "  };\n"
            end;
            raise Not_found;
          end
        done (* j *)
      with Not_found -> ()
    done (* i *)
    ;
    tack ("  //char -> (state->state) lookup\n");
    tack ("  static int *matrix[256] =\n");
    tack "  {\n";
    for i = 0 to 255 do
      if i mod 16 = 0 then tack "      ";
      let s = "     s" ^ si canon.(i) in
      let n = String.length s in
      let s = String.sub s (n-4) 4 in
      tack s;
      if i <> 255 then tack ", ";
      if i mod 16 = 15 then tack "\n"
    done;
    tack "  };\n\n";

    (* eval argument as a C++ string *)
    tack "  string s = ";
    tack (ge e);
    tack ";\n";
    tack "  char const *start = s.data();\n";
    tack "  char const *end = start + s.size();\n";
    begin match exe with
    | `BEXE_regmatch _ ->
      tack "  int state = 1;\n";
      tack "  while(state && start != end)\n";
      tack "    state = matrix[*start++][state];\n";
      tack "  switch (state)\n"
    | `BEXE_reglex _ ->
      tack "  int state = 1;\n";
      tack "  int last_state = 0;\n";
      tack "  char const *last_ptr = NULL;\n";
      tack "  if(accept[state]){\n";
      tack "    last_state = state;\n";
      tack "    last_ptr = start;\n";
      tack "  }\n";
      tack "  while(state && start != end) {\n";
      tack "    state = matrix[*start++][state];\n";
      tack "    if(accept[state]){\n";
      tack "      last_state = state;\n";
      tack "      last_ptr = start;\n";
      tack "    }\n";
      tack "  }\n";
      tack "  switch (last_state)\n"
    | _ -> assert false 
    end
    ;
    tack "  {\n";
    Hashtbl.iter
    (fun state expr ->
      tack 
      (
        "    case " ^ si (state + 1)^ ":"^
        " return " ^ ge expr ^ ";\n"
      )
    )
    cases 
    ;
    tack "    case 0: assert((\"regmatch failure\",0));\n";
    tack "    default: assert((\"system failure in regmatch\",0));\n";
    tack "  }\n";

    Buffer.contents b
    
  | `BEXE_fun_return e -> 
    "      //" ^ src_str ^ "\n" ^
    "      return "^ge e^";\n"
  | `BEXE_nop s -> "      //Nop: " ^ s ^ "\n"
  | `BEXE_init (v,e) -> 
    "      //initialisation "^src_str^"\n" ^
    "      "^
    get_var_ref syms bbdfns this v ts^ 
    " = " ^ 
    ge e ^
    ";\n"

let gen_exes syms bbdfns display label_map counter index exes vs ts =
  (* print_endline ("// generating exes for index " ^ si index); *)
  cat ""
  (map (gen_exe syms bbdfns label_map counter index vs ts) exes)

(* PROCEDURES are implemented by continuations.
   The constructor accepts the display vector to
   form the closure object. The call method accepts
   the callers continuation object as a return address,
   and the procedure argument, and returns a continuation.
   The resume method runs the continuation until
   it returns a continuation to some object, possibly
   the same object. A flag in the continuation object
   determines whether the yield of control is a request
   for data or not (if so, the dispatcher must place the data
   in the nominated place before calling the resume method again.
*)
 
(* FUNCTIONS are implemented as functoids:
  the constructor accepts the display vector so as
  to form a closure object, the apply method
  accepts the argument and runs the function.
  The machine stack is used for functions.
*)
let gen_function_methods syms bbdfns label_map counter index ts instance_no = 
  let id,parent,entry = Hashtbl.find bbdfns index in
  if syms.compiler_options.print_flag then
  print_endline 
  (
    "//Generating function body inst " ^ 
    si instance_no ^ "=" ^ 
    id ^ "<" ^si index^">" ^
    (
      if length ts = 0 then "" 
      else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
    )
  );
  match entry with 
  | `BBDCL_function (vs,bps,ret',exes,_) ->
    if length ts <> length vs then 
    failwith 
    (
      "[get_function_methods} wrong number of args, expected vs = " ^ 
      si (length vs) ^ 
      ", got ts=" ^ 
      si (length ts)
    );
    let argtype = lower (typeof_bparams bps) in
    let argtype = tsubst vs ts argtype in
    let ret = tsubst vs ts (lower ret') in
    let funtype = fold(`BTYP_function (argtype, ret)) in

    let argtypename = cpp_typename syms argtype in
    let name = cpp_instance_name syms bbdfns index ts in

    let display = get_display_list syms index in

    let rettypename = cpp_typename syms ret in
    let ctor = gen_ctor syms bbdfns name display ts in
    let params = get_parameters syms index in
    let exe_string =
      try 
        gen_exes syms bbdfns display label_map counter index exes vs ts
      with x -> 
        print_endline (Printexc.to_string x);
        failwith "Can't gen exes .."
    in
    let apply =
      rettypename^ " " ^name^
      "::apply("^
      (if argtype = `BTYP_tuple []
      then ""
      else argtypename ^" const &_arg ")^
      "){\n" ^
      "  collector_t &gc = *ptf->gc;\n" ^
      (
        match length params with
        | 0 -> ""
        | 1 -> 
          let i = hd params in
          if Hashtbl.mem syms.instances (i, ts)
          then
            "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg;\n"
          else ""
        | _ -> 
          let counter = ref 0 in fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem syms.instances (i,ts)
            then 
              s ^ "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg.mem_"^ si n ^";\n"
            else s (* elide initialisation of elided variable *)
          )
          "" params 
      )^
      exe_string ^
      "}\n"
    in
      "//FUNCTION " ^ id ^ ": Constructor\n" ^
      ctor^ "\n" ^
      "//FUNCTION " ^ id ^ ": Apply method\n" ^
      apply^ "\n"

  | _ -> failwith "function expected"

let gen_procedure_methods syms bbdfns label_map counter index ts instance_no = 
  let id,parent,entry = Hashtbl.find bbdfns index in (* can't fail *)
  if syms.compiler_options.print_flag then
  print_endline 
  (
    "//Generating procedure body inst " ^ 
    si instance_no ^ "=" ^ 
    id ^ "<" ^si index^">" ^
    (
      if length ts = 0 then "" 
      else "[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]"
    )
  );
  match entry with 
  | `BBDCL_procedure (vs,bps,exes,_) ->
    if length ts <> length vs then 
    failwith 
    (
      "[get_procedure_methods} wrong number of args, expected vs = " ^ 
      si (length vs) ^ 
      ", got ts=" ^ 
      si (length ts)
    );
    let argtype = lower (typeof_bparams bps) in
    let argtype = tsubst vs ts argtype in
    let funtype = fold(`BTYP_function (argtype, `BTYP_void)) in

    let argtypename = cpp_typename syms argtype in
    let name = cpp_instance_name syms bbdfns index ts in

    let display = get_display_list syms index in

    let ctor = gen_ctor syms bbdfns name display ts in
    let params = get_parameters syms index in
    let ps = map (fun (id,(ix,t)) -> id,t) bps in

    let exe_string =
      gen_exes syms bbdfns display label_map counter index exes vs ts 
    in
    let cont = "con_t *"
    in
    let arg_sig = 
      match argtype with
      | `BTYP_tuple [] ->
      "  " ^ cont ^ "_ptr_caller"
      | _ ->
      "  " ^ cont ^ "_ptr_caller,\n"^
      "  " ^ argtypename ^" const &_arg\n"
    in
    let call =
      cont ^name^
      "::call(\n" ^ arg_sig ^
      "){\n" ^
      (
        "  _caller = _ptr_caller;\n" ^
        (match length params with
        | 0 -> ""
        | 1 -> 
          let i = hd params in
          if Hashtbl.mem syms.instances (i,ts)
          then
            "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg;\n"
          else ""

        | _ -> let counter = ref 0 in fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem syms.instances (i,ts)
            then
              s ^ "  " ^ cpp_instance_name syms bbdfns i ts ^ " = _arg.mem_"^ si n ^";\n"
            else s (* elide initialisation of elided variables *)
          )
          "" params
          ) ^
          "  pc = 0;\n" ^
          "  return this;\n"
      )^
      "}\n"
    and resume = 
      if exes = []
      then
        cont^name^"::resume(){//empty\n"^
        "     FLX_RETURN\n" ^ 
        "}\n"
      else
        cont^name^"::resume(){\n"^
        "  collector_t &gc = *ptf->gc;\n" ^
        "  switch(pc){\n" ^
        "    case 0:\n" ^
        exe_string ^
        "    default: FLX_RETURN\n" ^
        "  }\n" ^
        "}\n"
    in
      "\n//PROC " ^ id ^ "\n" ^
      "//PROC " ^ id ^ ": Constructor\n" ^
      ctor^
      "\n//PROC " ^ id ^ ": Call method\n" ^
      call^
      "\n//PROC " ^ id ^ ": Resume method\n" ^
      resume

  | _ -> failwith "prcoedure expected"


let gen_execute_methods syms bbdfns counter bf =
  let label_map = create_label_map bbdfns counter in
  let s = Buffer.create 2000 in
  Hashtbl.iter
  (fun (index,ts) instance_no -> 
  let id,parent,entry = Hashtbl.find bbdfns index in 
  begin match entry with
  | `BBDCL_function (vs,ps, ret, _,_) -> 
    bcat s ("//------------------------------\n");
    bcat s (
      gen_function_methods syms bbdfns label_map counter index ts instance_no
    )
    
    
  | `BBDCL_procedure (vs,ps,_,_) -> 
    bcat s ("//------------------------------\n");
    bcat s (
      gen_procedure_methods syms bbdfns label_map counter index ts instance_no
    )
  | _ -> ()
  end
  ;
  output_string bf (Buffer.contents s);
  Buffer.clear s
  )
  syms.instances

let gen_biface_header syms bbdfns biface = match biface with
  | `BIFACE_export (index, export_name) ->
    let id,parent,entry = Hashtbl.find bbdfns index in
    match entry with
    | `BBDCL_function (vs,ps, ret, _,_) ->
      let display = get_display_list syms index in
      if length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        map 
        (fun (_,(_,x)) -> cpp_typename syms x) 
        ps 
      in
      let arglist = "  " ^ cat ",\n  " ("FLX_FPAR_DECL":: argtypes) in
      let rettypename = cpp_typename syms ret in

      "//EXPORT FUNCTION " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" " ^ rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | `BBDCL_procedure (vs,ps, _,_) ->
      let display = get_display_list syms index in
      if length display <> 0
      then failwith "Can't export nested proc";

      let argtypes = 
        map 
        (fun (_,(_,x)) -> cpp_typename syms x) 
        ps 
      in
      let arglist = 
        "  " ^ cat ",\n  " ("FLX_FPAR_DECL"::argtypes) 
      in 
      
      "//EXPORT PROCEDURE " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" con_t * "  ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | _ -> failwith "Not implemented: export non-function/procedure"
  
let gen_biface_body syms bbdfns biface = match biface with
  | `BIFACE_export (index, export_name) ->
    let id,parent,entry = Hashtbl.find bbdfns index in
    match entry with
    | `BBDCL_function (vs,ps, ret, _,_) ->
      if length vs <> 0
      then failwith ("Can't export generic function " ^ id)
      ;
      let display = get_display_list syms index in
      if length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        map 
        (fun (id,(ix,t)) -> cpp_typename syms t ^ " " ^ id) 
        ps 
      in
      let arglist = "  " ^ cat ",\n  " ("FLX_FPAR_DECL":: argtypes) in
      let rettypename = cpp_typename syms ret in
      let class_name = cpp_instance_name syms bbdfns index [] in

      "//EXPORT FUNCTION " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*_ptf->gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(_pgf,_ppf,_ptf))" ^
      "->apply(" ^ cat ", " (map fst ps) ^ ");\n" ^
      "}\n"

    | `BBDCL_procedure (vs,ps,_,_) ->
      if length vs <> 0
      then failwith ("Can't export generic procedure " ^ id)
      ;
      let display = get_display_list syms index in
      if length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        map 
        (fun (id,(_,t)) -> cpp_typename syms t ^ " " ^ id) 
        ps 
      in
      let arglist = "  " ^ cat ",\n  " ("FLX_FPAR_DECL" ::argtypes) in
      let class_name = cpp_instance_name syms bbdfns index [] in

      "//EXPORT PROC " ^ cpp_instance_name syms bbdfns index [] ^ 
      " as " ^ export_name ^ "\n" ^
      "con_t *" ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*_ptf->gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(_pgf,_ppf,_ptf))" ^
      "->call(" ^ cat ", " ("0"::(map fst ps)) ^ ");\n" ^
      "}\n"

    | _ -> failwith "Not implemented: export non-function/procedure"

let gen_biface_headers syms bbdfns bifaces = 
  cat "" (map (gen_biface_header syms bbdfns) bifaces)

let gen_biface_bodies syms bbdfns bifaces = 
  cat "" (map (gen_biface_body syms bbdfns) bifaces)

@h = tangler('src/flxg.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_srcref
open Flx_desugar
open Flx_bbind
open Flx_name
open Flx_tgen
open Flx_gen
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_exceptions
open Flx_flxopt
;;

let print_help () = print_options(); exit(0)
;;

let reverse_return_parity = ref false
;;

let last_time = ref 0.0
;;
let tim() = 
  let now = (Unix.times()).Unix.tms_utime in
  let elapsed = now -. !last_time in
  last_time := now;
  elapsed
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in
  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

 let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and header_file_name = filebase ^ ".hpp"
  and body_file_name = filebase ^ ".cpp" 
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in

  (* PARSE THE IMPLEMENTATION FILE *)
  if compiler_options.print_flag
  then print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  if compiler_options.print_flag
  then print_endline (Flx_print.string_of_compilation_unit parse_tree);

  let parse_time = tim() in
  if compiler_options.print_flag
  then print_endline ("//PARSE OK time " ^ string_of_float parse_time);

  (* IF THERE WAS NO INTERFACE FILE, GENERATE ONE *)
  if not have_interface 
  then begin

    if compiler_options.print_flag
    then print_endline "//No interface file found: generating one";
    let h = open_out iface_file_name in
    let iface = build_interface parse_tree in
    List.iter 
    (
      fun x->
        output_string h
        (
          (string_of_statement 0 x)^"\n"
        )
    ) 
    iface;
    close_out h
  end
  ;

  if compiler_options.print_flag 
  then print_endline "//DESUGARING";

  let deblocked = 
    desugar_program include_dirs module_name syms.counter parse_tree 
  in
  let desugar_time = tim() in
  if compiler_options.print_flag 
  then print_endline ("//DESUGAR time " ^ string_of_float desugar_time);

  (* THIS IS A HACK! *)
  let root = !(syms.counter) in
  if compiler_options.print_flag 
  then print_endline ("//Top level module '"^module_name^"' has index " ^ si root);


  if compiler_options.print_flag 
  then print_endline "//BUILDING TABLES";

  let table, exes, ifaces,dirs = 
    build_tables syms "<top level>" 0 None None root deblocked 
  in
  let build_table_time = tim() in
  if compiler_options.print_flag 
  then print_endline ("//BUILDING TABLES time " ^ string_of_float build_table_time);


  if compiler_options.print_flag 
  then print_endline "//BINDING EXECUTABLE CODE"
  ;
  let bbdfns = bbind syms in
  let bifaces = bind_ifaces syms ifaces in
  let binding_time = tim() in

  if compiler_options.print_flag 
  then print_endline ("//Binding complete time " ^ string_of_float binding_time);

  if compiler_options.print_flag 
  then print_endline "//CHECKING ROOT";

  let root_proc = 
    let id,sr,parent,vs,name_map,_,entry = 
      try Hashtbl.find syms.dfns root 
      with Not_found ->
        failwith 
        (
          "Can't find root module " ^ si root ^
          " in symbol table?"
        )
    in
    begin match entry with
      | `SYMDEF_module -> ()
      | _ -> failwith "Expected to find top level module ''"
    end
    ;
    let entry = 
      try Hashtbl.find name_map "_init_" 
      with Not_found ->
        failwith "Can't find name _init_ in top level module's name map"
    in
    let index = match entry with
      | FunctionEntry [Simple x] -> x
      | FunctionEntry [] -> failwith "Couldn't find '_init_'"
      | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
      | NonFunctionEntry _ -> failwith "_init_ found but not procedure"
    in 
    if compiler_options.print_flag 
    then print_endline ("//root module's init procedure has index " ^ si index);
    index
  in

  if compiler_options.print_flag 
  then print_endline "//instantiating";

  Flx_inst.instantiate syms bbdfns root_proc bifaces;
  let top_class =
    try cpp_instance_name syms bbdfns root_proc []
    with Not_found -> 
      failwith ("can't name instance of root _init_ procedure index " ^ si root_proc)
  in
  if compiler_options.print_flag 
  then print_endline ("//root module's init procedure has name " ^ top_class);
  let instantiation_time = tim() in

  if compiler_options.print_flag 
  then print_endline ("//instantiation time " ^ string_of_float instantiation_time);
  
  let hf = open_out header_file_name in
  let bf = open_out body_file_name in 
  let psh s = output_string hf s in
  let psb s = output_string bf s in
  let plh s = psh s; psh  "\n" in
  let plb s = psb s; psb "\n" in

  if compiler_options.print_flag 
  then print_endline "//GENERATING C++: user headers";
  
  plh ("#ifndef " ^ module_name);
  plh ("#define " ^ module_name);
  plh ("//" ^ input_file_name);
  plh ("//Generated by Felix Version " ^ !version_data.version_string);
  plh "";
  plh "//FELIX RUNTIME";
  plh "#include \"rtl/flx_rtl.hpp\"";
  plh "using namespace flx::rtl;";
  plh "#include \"rtl/flx_collector.hpp\"";
  plh "using namespace flx::gc::generic;";
  plh "";

  plh "#define FLX_FMEM_DECL \\";
  plh "  global_frame_t *pgf;\\";
  plh "  process_frame_t *ppf;\\";
  plh "  thread_frame_t *ptf;";
  
  plh "#define FLX_FPAR_DECL \\";
  plh "    global_frame_t *_pgf,\\";
  plh "    process_frame_t *_ppf,\\";
  plh "    thread_frame_t *_ptf";

  plh "\n//-----------------------------------------";
  plh "//USER HEADERS";
  (* These must be in order: build a list and sort it *)
  let dfnlist = ref [] in
  Hashtbl.iter
  (fun index data -> dfnlist := index :: !dfnlist)
  bbdfns
  ;
  List.iter 
  (fun index ->
    match Hashtbl.find bbdfns index 
    with (id,parent,entry) ->
    match entry with
    | `BBDCL_header s -> plh s
    | _ -> ()
  )
  (List.sort compare !dfnlist)
  ;

  plh "\n//-----------------------------------------";
  List.iter plh [
  "//FELIX SYSTEM";

  (* GLOBAL FRAME *)
  "struct global_frame_t {";
  " // put global values here";
  "};";
  "struct process_frame_t {";
  "  global_frame_t *global_frame;";
  "  process_frame_t(";
  "    global_frame_t *_global_frame";
  "  ) :";
  "    global_frame(_global_frame)";
  "  {}";
  "};";

  "struct thread_frame_t;"
  ]
  ;
  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: collect types";
  let types = ref [] in 
    Hashtbl.iter 
    (fun t index-> types := (index, t) :: !types)
    syms.registry
  ;
  let types = 
    List.sort 
    (
      fun a1 a2 -> compare (fst a1) (fst a2)
    ) 
    !types
  in
  (*
  List.iter
  (fun (_,t) -> print_endline (string_of_btypecode dfns t))
  types
  ;
  *)

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: type class names";
  plh "\n//-----------------------------------------";
  plh "//NAME THE TYPES";
  plh  (gen_type_names syms bbdfns types);

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: type class definitions";
  plh "\n//-----------------------------------------";
  plh  "//DEFINE THE TYPES";
  plh  (gen_types syms bbdfns types);

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: function and procedure classes";
  plh "\n//-----------------------------------------";
  plh  "//DEFINE FUNCTION CLASSES";
  plh  (gen_functions syms bbdfns);
  List.iter plh 
  [
  "struct thread_frame_t {";
  "  global_frame_t *global_frame;";
  "  process_frame_t *process_frame;";
  "  collector_t *gc;";
  "  thread_frame_t(";
  "    global_frame_t *global_frame_a,";
  "    process_frame_t *process_frame_a,";
  "    collector_t *gc_a";
  "  ) : ";
  "    process_frame(process_frame_a),";
  "    global_frame(global_frame_a),";
  "    gc(gc_a)";
  "  {}"
  ];
  (*
  print_endline "Finding top level variables";
  *)
  List.iter plh
  [
  (find_members syms bbdfns root []);
  "};"
  ];


  (* BODY *)
  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: GC ptr maps & offsets";

  plb ("#include \"" ^ module_name ^ ".hpp\"");
  plb "#include <stdio.h>"; (* for diagnostics *)
  plb "#define comma ,";
  plb "\n//-----------------------------------------";
  plb "//EMIT USER BODY CODE";
  (* These must be in order: build a list and sort it *)
  let dfnlist = ref [] in
  Hashtbl.iter
  (fun index data -> dfnlist := index :: !dfnlist)
  bbdfns
  ;
  List.iter 
  (fun index ->
    match Hashtbl.find bbdfns index 
    with (id,parent,entry) ->
    match entry with
    | `BBDCL_body s -> plb s
    | _ -> ()
  )
  (List.sort compare !dfnlist)
  ;

  plb "\n//-----------------------------------------";
  plb "//DEFINE OFFSET tables for GC";
  plb "static size_t _uctor_offsets[1]= { offsetof(_uctor_,data) };";
  plb "static gc_shape_t _uctor_ptr_map ("; 
  plb "  sizeof(_uctor_),";
  plb "  0,";
  plb "  1,";
  plb "  _uctor_offsets";
  plb ");";

  plb (Flx_ogen.gen_offset_tables syms bbdfns);

  if compiler_options.print_flag then 
  print_endline "//GENERATING C++: method bodies";

  plb "#define FLX_RETURN \\";
  plb "{ \\";
  plb "  con_t *tmp = _caller; \\";
(*    plb "  printf(\"returning from %p to %p\\n\",this,tmp);\\"; *)
  plb "  decref(this); \\";
  plb "  _caller = 0; \\";
  plb "  return tmp; \\";
  plb "}";
  
  plb "#define FLX_FMEM_INIT \\";
  plb "  pgf(_pgf),\\";
  plb "  ppf(_ppf),\\";
  plb "  ptf(_ptf)";

  plb "#define FLX_FPAR_PASS \\";
  plb "  pgf,\\";
  plb "  ppf,\\";
  plb "  ptf";


  plb "\n//-----------------------------------------";
  plb "//DEFINE FUNCTION CLASS METHODS";
  gen_execute_methods syms bbdfns syms.counter bf;

  if compiler_options.print_flag then print_endline "//GENERATING C++: interface";
  plb "\n//-----------------------------------------";
  plb "//CREATE STANDARD EXTERNAL INTERFACE";
  plb "extern \"C\" global_frame_t *create_global_frame() {";
  plb "  return new global_frame_t;";
  plb "}";

  plb "extern \"C\" void destroy_global_frame(";
  plb "  global_frame_t *pgf";
  plb ") {";
  plb "  delete pgf;";
  plb "}";

  plb "extern \"C\" process_frame_t *create_process_frame(";
  plb "  global_frame_t *pgf";
  plb  ") {";
  plb "  return new process_frame_t(pgf);";
  plb "}";

  plb "extern \"C\" void destroy_process_frame(";
  plb "  process_frame_t *ppf";
  plb  ") {";
  plb "  delete ppf;";
  plb "}";

  plb "extern \"C\" thread_frame_t *create_thread_frame(";
  plb "  global_frame_t *pgf,";
  plb "  process_frame_t *ppf,";
  plb "  collector_t *gc";
  plb ") {";
  plb "  return new thread_frame_t(pgf,ppf,gc);";
  plb "}";

  plb "extern \"C\" void destroy_thread_frame(";
  plb "  thread_frame_t *ptf";
  plb ") {";
  plb "  delete ptf;";
  plb "}";

  plb "extern \"C\" con_t *start(";
  plb "  global_frame_t *pgf,";
  plb "  process_frame_t *ppf,";
  plb "  thread_frame_t *ptf";
  plb ") {";
  plb ("  return (new(*ptf->gc,"^top_class^"_ptr_map) " ^ top_class ^ "(pgf,ppf,ptf))->call(0);");
  plb "}";

  plb "\n//-----------------------------------------";
  plh "//DECLARE USER EXPORTS";
  plh (gen_biface_headers syms bbdfns bifaces);
  plb "//DEFINE EXPORTS";
  plb (gen_biface_bodies syms bbdfns bifaces);

  plh "//header complete";
  plh "#endif";
  plb "//body complete";
  close_out hf;
  close_out bf;
  let code_generation_time = tim() in
  if compiler_options.print_flag then 
  print_endline ("//code generation time " ^ string_of_float code_generation_time);
  let total_time = 
    parse_time +.
    desugar_time +.
    build_table_time +.
    binding_time +.
    instantiation_time +.
    code_generation_time
  in  
  if compiler_options.print_flag then 
  print_endline ("//Felix compiler time " ^ string_of_float total_time);
  exit (if compiler_options.reverse_return_parity then 1 else 0)

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

