@head(1,'GC shape object generator')
@h = tangler('src/flx_display.mli')
@select(h)
open Flx_types
val get_display_list:
  sym_state_t ->
  bid_t ->
  bid_t list


@h = tangler('src/flx_display.ml')
@select(h)
open Flx_types

let rec cal_display dfns parent display : bid_t list =
  match parent with 
  | None -> display
  | Some parent ->
  let id,sr,parent',entry = Hashtbl.find dfns parent in
  match entry with
  | `SYMDEF_function _
  (*
  | `SYMDEF_procedure _
  *)
  | `SYMDEF_match_check _
    -> cal_display dfns parent' (parent::display)
  | _ -> cal_display dfns parent' display
   
let get_display_list syms index : bid_t list =
  let dfns = syms.dfns in
  let id,sr,parent,entry = Hashtbl.find dfns index in
  match entry with
  | `SYMDEF_function _
  (*
  | `SYMDEF_procedure _
  *)
  | `SYMDEF_match_check _
    -> List.rev (cal_display dfns parent [])

  | _ -> 
    failwith 
    (
      "Only functions and procedures have a display, got: " ^
      Flx_print.string_of_symdef entry id
    )


@h = tangler('src/flx_ogen.mli')
@select(h)
open Flx_types
val gen_offset_tables:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  string

@h = tangler('src/flx_ogen.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_name
open Flx_unify
open Flx_typing
open Flx_tgen
open List

let find_references bbdfns name_map = 
  let references = ref [] in
  Hashtbl.iter
  (fun id entryset -> 
    try
      match entryset with
      | FunctionEntry _ -> ()
      | NonFunctionEntry (Bound _) -> 
        failwith "Not expecting bound entry"

      | NonFunctionEntry (Simple idx) ->
      let _,_,bbdfn = 
        (* try *)
        Hashtbl.find bbdfns idx
        (*
        with Not_found -> 
          failwith 
          (
            "[find_references] can't find index " ^ 
            string_of_int idx ^
            " for name '" ^ id ^ "'"
          )
        *)
      in
      match bbdfn with
      | `BBDCL_var ((`BTYP_pointer _) as t)
        -> references := (idx,lower t) :: !references
      | `BBDCL_val ((`BTYP_pointer _) as t)
        -> references := (idx,lower t) :: !references
      | _ -> ()
    with Not_found -> ()
  ) 
  name_map
  ;
  !references

(* this code handles tuples and pointers *)
let rec get_offsets sym_state bbdfns typ : string list =
  let tname = cpp_typename sym_state bbdfns typ in
  match unfold typ with
  | `BTYP_pointer t -> 
    ["offsetof("^tname^",frame)"]

  | `BTYP_tuple args -> 
    let n = ref 0 in
    let lst = ref [] in
    iter 
    (fun t ->
      let prefix = 
        "offsetof("^tname^",mem_"^string_of_int !n^")+" 
      in
      iter
      (fun s -> lst := !lst @ [prefix ^ s])
      (get_offsets sym_state bbdfns t)
      ;
      incr n
    )
    args
    ;
    !lst

  | _ -> []

let gen_offset_data_nontemplate s n name classname offsets =
  if n <> 0 then
  begin
    bcat s ("static size_t " ^ name ^ "_offsets["^si n^"]={\n  ");
    bcat s ("  " ^ cat ",\n  " offsets);
    bcat s ("\n" ^  "};\n");
  end;
  bcat s ("static void " ^ name ^ "_finaliser(collector_t *, void *p){\n");
  bcat s ("  (("^ name ^ "*)p)->~" ^ name ^ "();\n}\n");
  bcat s (  "static gc_shape_t "^ name ^"_ptr_map (\n");
  bcat s ( "  sizeof("^classname^"),\n  "^name^"_finaliser,\n  "^string_of_int n^",\n  "^
  (if n<>0 then name^"_offsets\n" else "0\n"));
  bcat s ( ");\n")

let gen_offset_data_template s m n name classname template targs offsets =
  (* the class *)
  bcat s template;
  bcat s ("struct " ^ name ^ "_offset_data {\n");
  if n <> 0 then
    bcat s ("  static size_t " ^ name ^ "_offsets["^si n^"];\n");
  bcat s ("  static void " ^ name ^ "_finaliser(collector_t *, void *p);\n");
  bcat s ("  static gc_shape_t "^ name ^"_ptr_map;\n");
  bcat s "};\n";

  (* offset member *)
  let instname = name^"_offset_data"^targs in
  if n <> 0 then
  begin
    bcat s template;
    bcat s ("size_t " ^ instname^"::"^name ^ "_offsets["^si n^"]={\n  ");
    bcat s ("  " ^ cat ",\n  " offsets);
    bcat s "\n};\n";
  end;

  (* finaliser member *)
  bcat s template;
  bcat s ("void " ^ instname ^ "::" ^name ^ "_finaliser(collector_t *, void *p){\n");
  bcat s ("  (("^ name ^ targs ^"*)p)->~" ^ name ^ "();\n}\n");

  (* shape member *)
  bcat s template;
  bcat s ("gc_shape_t "^ instname ^ "::"^name^"_ptr_map(\n");
  bcat s ("  sizeof("^classname^"),\n  "^name^"_finaliser,\n  "^string_of_int n^",\n  "^
  (if n<>0 then name^"_offsets\n" else "0\n"));
  bcat s ");\n"

let gen_offset_data s m n name classname template targs offsets =
  if m = 0 then 
    gen_offset_data_nontemplate s n name classname offsets
  else
    gen_offset_data_template s m n name classname template targs offsets

let gen_fun_offsets s sym_state bbdfns index vs ps ret name_map = 
    let m = length vs in
    let vars = map (fun (s,i) -> s) vs in
    let template = template_header vars "\n" in
    let targs = template_args vars in
    let offsetof_targs = template_args_comma vars in
    let refnames = 
      map 
      (fun (index,t)-> 
        cpp_name bbdfns index,
        cpp_typename sym_state bbdfns t
      )
      (find_references bbdfns name_map)
    in
    let name = cpp_name bbdfns index in
    let classname = cpp_instance_name bbdfns index vars in
    let display = Flx_display.get_display_list sym_state index in
    let oname = name ^ offsetof_targs in 
    let offsets = 
      (match ret with 
        | `BTYP_void -> [ ("offsetof(" ^ oname ^ ",_caller)")  ] 
        | _ -> []
      ) 
      @
      map
      (fun didx ->
      let dptr = "ptr" ^ cpp_name bbdfns didx in
      "offsetof("^oname^","^dptr^")"
      )
      display
      @
      map 
      (fun (mem,reftyp)->
        "offsetof("^oname^","^mem^")" ^
        "+offsetof("^reftyp^",frame)") 
      refnames
    in
    let n = length offsets in
    bcat s 
    (
      "\n//OFFSETS for "^
      (if m = 0 then "" else "GENERIC ") ^
      (match ret with |`BTYP_void -> "procedure " | _ -> "function ") ^ 
      name ^ "\n"
    );
    gen_offset_data s m n name classname template targs offsets

let gen_offset_tables sym_state bbdfns =
  let primitive_shapes = Hashtbl.create 97 in
  let s = Buffer.create 2000 in
  (*
  print_endline "Function and procedure offsets";
  *)
  Hashtbl.iter
  (fun index (id,parent,entry) -> match entry with
  | `BBDCL_function (vs,ps, ret,_,name_map) -> 
    gen_fun_offsets s sym_state bbdfns index vs ps ret name_map
      
  | `BBDCL_procedure (vs,ps,_,name_map) -> 
    gen_fun_offsets s sym_state bbdfns index vs ps `BTYP_void name_map

  | `BBDCL_abs (vs,ct) ->
    (* These use the actual C++ type name of the primitive type,
       so they might not be unique: therefore, we have to track
       which ones have been generated
    *)
    if length vs = 0
    then
      let name = cpp_typename sym_state bbdfns (`BTYP_name index) in
      if not (Hashtbl.mem primitive_shapes name) then 
      begin
        Hashtbl.add primitive_shapes name true; 
        bcat s ("\n//OFFSETS for abstract type " ^ name ^ "\n");
        bcat s ( "static gc_shape_t " ^ name ^ "_ptr_map(\n") ;
        bcat s ("  sizeof("^name^"),0,0,0\n");
        bcat s ");\n"
      end else begin
        bcat s ("\n//OFFSETS for abstract type " ^ name ^ "\n");
        bcat s ("//Use "^name^"_ptr_map\n");
      end

  | _ -> () (* this is NOT right, we need offsets for all data
               structures *)
  )
  bbdfns
  ;

  (* We're not finished: we need offsets for tuple and pointer types too *)
  (*
  print_endline "Tuple and pointer offsets";
  *)
  Hashtbl.iter
  (fun btyp index -> 
    (*
    print_endline ("type --> " ^ string_of_btypecode sym_state.dfns btyp);
    *)
    match unfold btyp with
    | `BTYP_tuple args ->
      let varmap,t = normalise_type btyp in
      let m = length varmap in
      let vars = map (fun i -> "T" ^ si i) varmap in
      let ivars = map (fun i -> i,"T" ^ si i) varmap in
      let template = template_header vars "\n" in
      let targs = template_args vars in
      let name = cpp_type_classname sym_state bbdfns btyp in
      let offsets = get_offsets sym_state bbdfns btyp in
      let n = length offsets in 
      let classname = cpp_type_class_instance sym_state bbdfns btyp ivars in
      bcat s ("\n//OFFSETS for tuple type " ^ string_of_int index ^ "\n");
      gen_offset_data s m n name classname template targs offsets

   | `BTYP_pointer t ->
      let name = cpp_typename sym_state bbdfns btyp in
      let offsets = get_offsets sym_state bbdfns btyp in
      let n = length offsets in 
      bcat s ("\n//OFFSETS for pointer type " ^ string_of_int index ^ "\n");
      bcat s ("static size_t " ^ name ^ "_offsets[]={\n  ");
      bcat s ("  " ^ cat ",\n  " offsets);
      bcat s "};\n";
      bcat s ( "static gc_shape_t "^ name ^"_ptr_map(\n");
      bcat s ("  sizeof("^name^"),\n  0,\n  "^string_of_int n^",\n  "^name^"_offsets\n");
      bcat s ");\n"
   | _ -> () 
  )
  sym_state.registry
  ;
  Buffer.contents s

@head(1,'C++ Code generator')
@h = tangler('src/flx_gen.mli')
@select(h)
open Flx_types
val gen_functions:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  string

val gen_execute_methods:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ref ->
  string

val find_members:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  (int * string) list ->
  string

val gen_biface_headers:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string

val gen_biface_bodies:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  biface_t list ->
  string
  
@h = tangler('src/flx_gen.ml')
@doc()
Ref counting notes. 
@p()
Call: the callers frame count is up by 1,
since the callee has a link to it.
The callee count should probably go up by 1 too.
@p()
Return: the callers count goes down,
because the callee no longer has a link to it.
The callee's count should go down by 1.
@p()
Jump: we give the callee our own callers
address, so that should remain the same.
Our own count goes down by 1, the new frame's up by 1.
@p()
Loop. Nothing changes if we loop to ourself.
If we loop up scope, the stack must be unwound
by the equivalent of a lot of returns.
@p()
Issue: The driver holds the current frame's address (old)
and then get the new one (new). Logically it should
increment new, and decrement old (in that order in case
its the same frame). Unfortunately, this cannot work
in the return case, since the calling code decrements
the callers frame to zero before it is returned
to the driver, and it is too late to increment it
back again.
@p()
This means the driver cannot do the increment
on the frame it gets, and so it has to be done
by the client.
@p()
On the other hand, its OK for the driver to
decrement a frame it is losing. On a return,
this deletes the callee. On a call, the callers
count goes down by one, but only after the increment
due to the callee acquiring it. It is also possible
to 'decref(this)' on the client side, since we actually
know the driver is holding a pointer to us, and will
soon lose it.
@p()
Call: increment new frame. The link in the new frame to 
us replaces the one the driver holds, so our refcount
doesn't change.
@p()
Return: decrement this. Although the link to 
the caller is no longer valid, the driver is about
to acquire the caller, so leave the caller count alone.
@p()
Jump: increment the new frame and decrement this.

@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_typing
open Flx_name
open Flx_tgen
open Flx_unify
open Flx_csubst
open Flx_exceptions
open Flx_display
open List

let string_of_string = Flx_string.c_quote_of_string

(* HACKERY: this assumes library dependent things:
  but we can't add literals in the library code :-(
*)
let csuffix_of_type s = match s with
  | "tiny" -> ""
  | "short" -> ""
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "ll"
  | "utiny" -> "u"
  | "ushort" -> "u"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "llu"
  | "int8" -> ""
  | "int16" -> ""
  | "int32" -> "l"
  | "int64" -> "ll"
  | "uint8" -> "u"
  | "uint16" -> "u"
  | "uint32" -> "lu"
  | "uint64" -> "llu"
  | "double" -> ""
  | "float" -> "f"
  | "ldouble" -> "l"
  | _ -> failwith ("[csuffix_of_type]: Unexpected Type " ^ s)

let cstring_of_literal e = match e with
  | `AST_int (s,i) -> (Big_int.string_of_big_int i)^csuffix_of_type s 
  | `AST_float (s,x) -> x ^ csuffix_of_type s
  | `AST_string s -> string_of_string s
  | `AST_wstring s -> "L" ^ string_of_string s
  | `AST_ustring s -> "L" ^ string_of_string s

let dummy_name_map = Hashtbl.create 97

(* SHOULD USE ROUTINE IN LOOKUP FOR THIS *)
let get_name_map symdef name = match symdef with 
    | `SYMDEF_function (_,_,_,_,name_map,dirs) -> name_map
    (*
    | `SYMDEF_procedure (_,_,_,name_map,dirs) -> name_map
    *)
    | `SYMDEF_module (name_map,dirs) -> name_map
    | `SYMDEF_interface (name_map,dirs) -> name_map
    | `SYMDEF_match_check _ -> dummy_name_map
    | _ -> 
      failwith 
      (
        "[get_name_map] Expected entity with scope, got " ^
        string_of_symdef symdef name
      )

(* self's child's parent is normally self,
  but there could be a module stuck in between,
  so the child's parent is the module whose
  parent is a module ... whose parent is self
*)
  
   
(* WARNING WARNING:

  this algorithm makes a list, assuming
  that name -> index is unique on the index

  this won't be the case when we inject
  entries

  even though we check that the denoted
  entity is a child, an actual child can
  have a second name, and so occurs twice
  in the name->index map

  we need to use a SET here, not a list
*)

let find_variable_indices dfns index = 
  let rec extract parent name_map = 
    let variables = ref [] in
    Hashtbl.iter
    (fun id entryset -> 
      match entryset with
      | FunctionEntry _ -> ()
      | NonFunctionEntry (Bound _) ->
        failwith "Not expecting bound entry"
      | NonFunctionEntry (Simple idx) ->
      let id2,_,parent',symdef = 
        try Hashtbl.find dfns idx 
        with _ -> failwith ("[find_variable_indices(2)] can't find index " ^ string_of_int index)
      in

      (* make sure the entity is actually a child of index,
        and not say a link to root, parent, or self.
      *)
      let sp p = match p with | None -> "none" | Some i -> string_of_int i in
      if parent' = parent
      then 
        begin
          match symdef with
          | `SYMDEF_parameter _
          | `SYMDEF_var _ 
          | `SYMDEF_val _
            -> 
      (* print_endline (string_of_int index ^ ": " ^id ^"="^id2^ "<" ^ string_of_int idx ^">"^" member parent=" ^sp parent'); *)
              variables := idx :: !variables

          (* variables of a nested module are lifted into the function *)
          | `SYMDEF_module (table,dirs)
            -> 
      (* print_endline (string_of_int index ^ ": " ^id ^ "="^id2^"<" ^ string_of_int idx ^">"^" nested module parent=" ^sp parent'); *)
              variables := extract (Some idx) table @ !variables
          | _ -> ()
        end
    ) 
    name_map
    ;
    !variables
  in 
  let id,_,_,symdef = 
    try Hashtbl.find dfns index 
    with _ -> failwith ("[find_variable_indices(1)] Can't find index " ^ string_of_int index)
  in
  (* print_endline ("Finding members of " ^ id ^ " index " ^ string_of_int index); *)
  let name_map = get_name_map symdef id in
  extract (Some index) name_map

let find_members sym_state bbdfns index vs = 
  let variables = find_variable_indices sym_state.dfns index in
  let members = 
  cat ""
  (
    map 
    (fun idx -> 
      try
        let id,parent,entry = 
          (* try  *)
            Hashtbl.find bbdfns idx 
          (*
          with _ -> 
            failwith 
            (
              "[find_members] Can't find index " ^ string_of_int idx ^ 
              " member of " ^ string_of_int index
            )
          *)
        in
        match entry with
        | `BBDCL_var t
        | `BBDCL_val t ->
          (*
          print_endline 
          (
            "Found variable or value " ^
            id ^ 
            " of (lowered) type " ^ string_of_btypecode dfns (lower t)
          );
          *)
          let typename = cpp_type_instance sym_state bbdfns (lower t) vs in
          "  " ^ typename ^ " " ^ cpp_name bbdfns idx ^ ";\n"
        | _ -> failwith "[find members] Expected variable or value"
      with Not_found -> "" (* ignore unused variables *)
    )
    variables
  )
  in if members <> "" then "  //variables\n" ^ members
  else ""

let typeof_bparams ps: btypecode_t  = 
  typeoflist 
  (map
  (fun (id,(ix,t)) ->t) 
  ps
  )

let get_type bbdfns index = 
  let id,parent,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_type] Can't find index " ^ string_of_int index)
  in
  match entry with
  | `BBDCL_function (vs,ps,ret,_,_) -> 
      `BTYP_function (typeof_bparams ps,ret)
  | `BBDCL_procedure (vs,ps,_,_) -> 
      `BTYP_function (typeof_bparams ps,`BTYP_void)
  | _ -> failwith "Only function and procedure types handles by get_type"


(* vs here is the (name,index) list of type variables *)
let gen_function sym_state bbdfns index id vs bps ret' =

  let template = template_header (map fst vs) "\n" in
  let ps = map (fun (id,(ix,t)) -> id,t) bps in
  (*
  print_endline ("generating function " ^ id ^ "[" ^string_of_int index^"]");
  flush stdout;
  *)
  let argtype = lower(typeof_bparams bps) in
  let ret = lower ret' in
  let funtype = `BTYP_function (argtype, ret) in
  let rev_vs = map (fun (s,i)->i,s) vs in
  let argtypename = cpp_type_instance sym_state bbdfns argtype rev_vs
  and funtypename = cpp_type_class_instance sym_state bbdfns funtype rev_vs
  and display = get_display_list sym_state index 
  and frame_dcls = 
    "  //OS frames\n" ^
    "  FLX_FMEM_DECL\n"
  in
  let display_string = match display with
    | [] -> ""
    | display -> 
      "  //display\n" ^
      cat "" 
      (
        map
        (fun i-> 
         let name = cpp_name bbdfns i in
         "  " ^ name ^ " *ptr" ^ name ^ ";\n"
         )
        display
      )
  and ctor_dcl name =  
    "  " ^name^
    "  (\n" ^
    cat ",\n"
      (
        "    FLX_FPAR_DECL " ::
        map 
        (
          fun i -> let name = cpp_name bbdfns i in
          "    " ^ name ^ " *pptr" ^ name
        )
        display
      )^
      "\n  );\n" 
  in
  let members = find_members sym_state bbdfns index rev_vs in
  match ret with
  | `BTYP_void ->
    let name = cpp_name bbdfns index in
    template ^
    "struct " ^ name ^
    ": "^funtypename^" {\n" ^
    (if argtype = `BTYP_tuple [] 
    then
    "  con_t *call(con_t*);\n" 
    else
    "  con_t *call(con_t*,"^argtypename^" const &);\n"
    ) ^
    "  con_t *resume();\n"  ^
    "  con_t *_caller; // callers return address\n" ^
    frame_dcls ^
    display_string ^ "\n" ^
    "  //constructor\n" ^
    ctor_dcl name ^
    members ^
    "};\n"

  | _ ->
    let name = cpp_name bbdfns index
    and rettypename = cpp_type_instance sym_state bbdfns ret rev_vs
    in
    let ctor = ctor_dcl name in
    template ^
    "struct " ^ name ^
    ": "^funtypename^" {\n" ^
    "  "^rettypename^" apply(" ^
    (if argtype = `BTYP_tuple[] then ""
    else argtypename^" const &")^ 
    ");\n"  ^
    frame_dcls ^
    display_string ^ "\n" ^
    "  //constructor\n" ^
    ctor ^
    members ^
    "};\n"


(* This code generates the class declarations *)
let gen_functions sym_state bbdfns = 
  let xxdfns = ref [] in
  Hashtbl.iter
  (fun index (id,parent,entry) -> 
    (* if proper_descendant sym_state.dfns parent then  *)
    xxdfns := index :: !xxdfns
  )
  bbdfns
  ;
  
  flush stdout;
  let s = Buffer.create 2000 in
  iter
  (fun index ->
    match Hashtbl.find bbdfns index with (id,parent,entry) -> 
    match entry with
    | `BBDCL_function (vs,ps, ret, _,_) -> 
      bcat s ("\n//------------------------------\n");
      bcat s ("//"^(if length vs=0 then "" else "GENERIC ") ^"FUNCTION " ^ id ^ "\n");
      bcat s 
      (gen_function sym_state bbdfns index id vs ps ret)
    | `BBDCL_procedure (vs,ps,_,_) -> 
      bcat s ("\n//------------------------------\n");
      bcat s ("//"^(if length vs=0 then "" else "GENERIC ") ^"PROCEDURE " ^ id ^ "\n");
      bcat s 
      (gen_function sym_state bbdfns index id vs ps `BTYP_void)
    | _ -> () (* bcat s ("//SKIPPING " ^ id ^ "\n") *)
  )
  (sort compare !xxdfns)
  ;
  Buffer.contents s

let gen_ctor bbdfns name1 name2 display =
  name1^"::"^name2^
  "\n  (\n" ^
  cat ",\n"
  (
    "    FLX_FPAR_DECL" ::
    map 
    (
      fun i -> let name = cpp_name bbdfns i in
      "    " ^ name ^ " *pptr" ^ name
    )
    display
  )^
  "\n  ):\n" ^
  cat ",\n"
  (
    "  FLX_FMEM_INIT" ::
    map 
    (
      fun i -> let name = cpp_name bbdfns i in
      "  ptr" ^ name ^ "(pptr"^name^")"
    )
    display
  ) ^ 
  "\n  {}\n"

let var_type bbdfns index =
  let id,_,entry = 
    try Hashtbl.find bbdfns index
    with Not_found -> failwith ("[var_type] ]Can't get index " ^ string_of_int index)
  in match entry with 
  | `BBDCL_var t 
  | `BBDCL_val t -> lower t
  | _ -> failwith ("[var_type] expected "^id^" to be variable")

let is_closure_var bbdfns index =
  match var_type bbdfns index with
  | `BTYP_function _ -> true
  | _ -> false
  
let get_var_ref (dfns:symbol_table_t) bbdfns this index : string =
  let id,sr,parent,entry = 
    try Hashtbl.find dfns index 
    with _ -> failwith ("[get_var_ref] Can't find index " ^ string_of_int index)
  in  
  match entry with
  | `SYMDEF_parameter t
  | `SYMDEF_var t
  | `SYMDEF_val t ->
    let rec chase_tail parent =
      match parent with
      | None -> "ptf->" ^ cpp_name bbdfns  index
      | Some i ->
        let _,sr,parent,entry = 
          try Hashtbl.find dfns i 
          with _ -> failwith ( "[get_var_ref(1)] Can't find index " ^ string_of_int i)
        in
        match entry with
        | `SYMDEF_function _
        (*
        | `SYMDEF_procedure _ 
        *)
          ->
          (if i <> this then "ptr" ^ cpp_name bbdfns i ^ "->" else "") ^
          cpp_name bbdfns index
          
        | `SYMDEF_module _ -> chase_tail parent
        | _ -> failwith "[get_var_ref(2)] Expected variable to live in procedure or function"
    in 
      chase_tail parent
  | _ -> failwith ("[get_var_ref(3)] Expected name "^id^" to be variable or value")

let get_var_frame (dfns: symbol_table_t) bbdfns this index : string =
  let id,sr,parent,entry = 
    try Hashtbl.find dfns index 
    with _ -> failwith ("[get_var_frame(1)] Can't find index " ^ string_of_int index)
  in
  match entry with
  | `SYMDEF_parameter _
  | `SYMDEF_var _
  | `SYMDEF_val _
  ->
    let rec chase_tail parent =
      match parent with
      | None -> "((void*)0)"
      | Some i ->
        let _,sr,parent,entry = Hashtbl.find dfns i in
        match entry with
        | `SYMDEF_function _
        (*
        | `SYMDEF_procedure _ 
        *)
          ->
          if i <> this
          then "ptr" ^ cpp_name bbdfns i
          else "this"
        | `SYMDEF_module _ -> chase_tail parent
        | _ -> failwith "[get_var_frame] Expected variable to live in procedure or function"
    in
      chase_tail parent
  | _ -> failwith ("[get_var_frame] Expected name "^id^" to be variable or value")

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls -> 
    fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

  | _ -> false

let rec gen_expr syms bbdfns this (e,t) =
  (* print_endline ("Gen expr " ^ string_of_bound_expression dfns (e,t)); *)
  let ge e = gen_expr syms bbdfns this e in
  let ge_arg a = 
    match a with
    | _,`BTYP_tuple [] -> ""
    | x -> ge x 
  in
  let id,parent,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_expr] Can't find this = " ^ string_of_int this)
  in
  let our_display = get_display_list syms this in
  let our_level = length our_display in
  match e with
  | `BEXPR_coercion (e,t) -> 
    (* generate a function style cast *)
    cpp_typename syms bbdfns (lower t) ^ "(" ^ ge e ^ ")"
    
  | `BEXPR_get_n (n,e) -> 
    "(" ^ ge e ^ ").mem_" ^ string_of_int n
    
  | `BEXPR_match_case (n,((e',t') as e)) -> 
    if is_unitsum t' then
      "((" ^ ge e ^ ") == " ^ string_of_int (n-1) ^ ")"
    else
      "((" ^ ge e ^ ").variant == " ^ string_of_int (n-1) ^ ")"

  | `BEXPR_case_arg (n,e) ->
    (* NOTE that the index is not used ... *)
    let _,t = e in
    let t = 
      match t with 
      | `BTYP_sum ls -> nth ls (n-1)
      | _ -> assert false
    in
      let t = cpp_typename syms bbdfns (lower t) in
      (* really ugly brackets .. *)
      "(*("^t^"*)((" ^ ge e ^ ").data))"
     
  | `BEXPR_deref ((`BEXPR_ref index),`BTYP_pointer t) -> 
    ge (`BEXPR_name index,t)

  | `BEXPR_deref e -> 
    "*(" ^ ge e ^ ".data)"

  | `BEXPR_literal v ->
    let t = cpp_typename syms bbdfns (lower t) in
    t ^ "(" ^ cstring_of_literal v ^ ")"
    
  | `BEXPR_case (v,t) ->
    begin match t with
    | `BTYP_sum ls ->
       let n = length ls in
       if v<1 or v>n
       then 
         failwith 
         (
           "Invalid case index " ^ string_of_int v ^
           " of " ^ string_of_int n ^ " cases"
         )
       else let t' = nth ls (v-1) in
       if t' = `BTYP_tuple []
       then (* closure of const ctor is just the const value ???? *)
         if is_unitsum t then
           string_of_int (v-1)
         else
           "_uctor_(" ^ string_of_int (v-1) ^ ",0)"
       else 
         failwith 
         ( 
            "Can't handle closure of case " ^ 
            string_of_int v ^ 
            " of " ^
            string_of_btypecode syms.dfns t
         )
       (* "(" ^ cpp_typename syms bbdfns (lower t) ^ "*)_uctor_" *)

    | _ -> failwith "Case tag must have sum type"
    end 
   
  | `BEXPR_name index -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> 
        let id,sr,parent,entry = Hashtbl.find syms.dfns index in
        syserr sr
        ("[gen_expr(name)] Can't find "^ id ^ "<" ^ string_of_int index ^ ">")
    in
    begin match entry with
      | `BBDCL_var t
      | `BBDCL_val t ->
          get_var_ref syms.dfns bbdfns this index

      | `BBDCL_const (_,ct) -> ct

      | `BBDCL_struct _ 
      | `BBDCL_function _
      | `BBDCL_procedure _ 
      | `BBDCL_fun _
      | `BBDCL_proc _ ->
         failwith 
         (
           "[gen_expr: name] Open function '" ^ 
           id ^ "'<"^string_of_int index^
           "> in expression (closure required)"
         )
      | _ -> 
        failwith 
        (
          "[gen_expr: name] Cannot use this kind of name '"^
          id^"' in expression"
        )
    end

  | `BEXPR_closure index -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_function _ 
    | `BBDCL_procedure _ ->
      let the_display = 
        let d' = 
          map (fun i-> "ptr"^ cpp_name bbdfns i)
          (get_display_list syms index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_name bbdfns index in
      "(new(gc,"^name^"_ptr_map)\n        " ^ name ^
      "(" ^ cat ", " ("FLX_FPAR_PASS" :: the_display) ^
      "))"

    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith "[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression"
    end

  | `BEXPR_ref index -> 
    let t = lower t in
    let ref_type = cpp_typename syms bbdfns (lower t) in
    let var_ptr = "&(" ^ get_var_ref syms.dfns bbdfns this index ^ ")" in
    let frame_ptr = get_var_frame syms.dfns bbdfns this index in
    let reference = ref_type ^ 
      "((void*)" ^ frame_ptr ^ ", " ^ var_ptr ^ ")" 
    in
    reference

  | `BEXPR_apply 
     (
       (`BEXPR_case (v,t),t'),
       (a,t'') 
     ) ->
       (* t is the type of the sum, 
          t' is the function type of the constructor,
          t'' is the type of the argument
       *)
       let 
         arg_typename = cpp_typename syms bbdfns (lower t'') 
       and
         union_typename = cpp_typename syms bbdfns (lower t)
       in

       let aval = 
         "new (gc, "^arg_typename^"_ptr_map) " ^
         arg_typename ^ "(" ^ ge (a,t'') ^ ")"
       in
       let uval = "_uctor_(" ^ string_of_int (v-1) ^ ", " ^ aval ^")" in
       "(" ^ union_typename ^ ")" ^ uval
       (*
       failwith 
       (
         "Trapped application, case " ^ 
         string_of_int v ^
         " of " ^ string_of_btypecode syms.dfns t ^
         "\ntype " ^ string_of_btypecode syms.dfns t' ^
         "\nargument=" ^ 
         string_of_bound_expression syms.dfns (a,t'') ^
         "\ntype " ^ string_of_btypecode syms.dfns t''
       )
      *) 


  (* special case when function expression is a name *)
  | `BEXPR_apply ((`BEXPR_closure index,_) as f,a) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply closure)] Can't find index " ^ string_of_int index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct) -> 
      if length vs = 0
      then
        (* print_endline "--- CASE OF PRIMITIVE"; *)
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          (* 
          print_endline "--- ARGS ARE TUPLE";
          print_endline ("N params = " ^ (string_of_int (length ps)));
          *)
          "(" ^ csubst ge syms bbdfns ct es typs retyp []^ ")"
        | (_,typ) -> 
          (*
          print_endline ("--- ARGS ARE NOT TUPLE: type=" ^ string_of_btypecode syms.dfns typ);
          print_endline ("N params = " ^ (string_of_int (length ps)));
          *)
          "(" ^ csubst ge syms bbdfns ct [a] [typ] retyp []^ ")"
        end
      else failwith "Generic function requires type arguments"

    | `BBDCL_function (vs,ps,_,_,_) ->
      (ge f) ^ "->apply(" ^ ge_arg a ^ ")"

    | `BBDCL_struct _ ->
      let name = cpp_typename syms bbdfns (`BTYP_name index) in
      name ^ "(" ^ ge a ^ ")"
    
    | _ -> 
      failwith 
      (
        "[gen_expr] Expected '"^id^"' to be function constant or variable, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end
  
  (* special case when function expression is a generic instance *)
  | `BEXPR_apply ((`BEXPR_ginst (index,ts),_) as f,a) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ string_of_int index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct) -> 
      if length vs = length ts
      then
        (* print_endline "--- CASE OF PRIMITIVE"; *)
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          (* 
          print_endline "--- ARGS ARE TUPLE";
          print_endline ("N params = " ^ (string_of_int (length ps)));
          *)
          "(" ^ csubst ge syms bbdfns ct es typs retyp ts ^")"
        | (_,typ) -> 
          (*
          print_endline ("--- ARGS ARE NOT TUPLE: type=" ^ string_of_btypecode syms.dfns typ);
          print_endline ("N params = " ^ (string_of_int (length ps)));
          *)
          "(" ^ csubst ge syms bbdfns ct [a] [typ] retyp ts ^ ")"
        end
      else failwith "Wrong number of type arguments to generic function"

    | `BBDCL_function (vs,ps,retyp,_,_) ->
      (ge f) ^ "->apply(" ^ ge_arg a ^ "/* MAY NEED INCREF */)"

    | _ -> 
      failwith 
      (
        "[gen_expr] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  (* General application*)
  | `BEXPR_apply (f,a) ->
    (ge f) ^ "->apply(" ^ ge_arg a ^ "/* MAY NEED INCREF */)"
    
  | `BEXPR_tuple es ->
    (* just apply the tuple type ctor to the arguments *)
    let ctyp = cpp_typename syms bbdfns (lower t) in
    ctyp ^ "(" ^
    cat ", " (map ge es) ^
    ")"

  | `BEXPR_dot (e,index) -> "Can't handle unions yet"
    (* structure component: the Felix and C++ names
       of the component are the same
    *)
    (* "(" ^ ge e ^ ")." ^ name *)

  | `BEXPR_ginst (index,ts) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_function _ 
    | `BBDCL_procedure _ ->
      let targs = map (cpp_typename syms bbdfns) ts in
      let targs = template_args targs in
      let the_display = 
        let d' = 
          map (fun i-> "ptr"^ cpp_name bbdfns i)
          (get_display_list syms index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_name bbdfns index in
      let ptr_map = name ^ "_offset_data"^targs^"::"^name^"_ptr_map"in
      "(new(gc,"^ptr_map^")\n        " ^ name ^ targs ^
      "(" ^ cat ", " ("FLX_FPAR_PASS" :: the_display) ^
      "))"

    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith "[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression"
    end

let get_labels bbdfns counter exes =
  let labels = Hashtbl.create 97 in
  iter
    (fun exe -> match exe with 
      | `BEXE_label s -> Hashtbl.add labels s !counter; incr counter
      | _ -> ()
    )
    exes
  ;
  labels

let create_label_map bbdfns counter =
  let label_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun index (id,parent,entry) ->
    match entry with
    | `BBDCL_function (_,_,_,exes,_) -> 
      Hashtbl.add label_map index (get_labels bbdfns counter exes)
    | `BBDCL_procedure (_,_,exes,_) -> 
      Hashtbl.add label_map index (get_labels bbdfns counter exes)
    | _ -> ()
  ) 
  bbdfns
  ;
  label_map

let get_parameters dfns index =
  let variables = find_variable_indices dfns index in
  let params = 
    filter
    (fun i -> let id,sr,parent,entry = 
      try Hashtbl.find dfns i 
      with _ -> failwith ("[get_parameters] Can't find index " ^ string_of_int i)
      in
      match entry with 
      | `SYMDEF_parameter _ -> true
      | _ -> false
    )
    variables
  in 
    sort compare params

type kind_t = Function | Procedure

let gen_exe sym_state bbdfns label_map counter this (exe:bexe_t) =
  let sr = ("dummy",0,0,0,0) in
  let src_str = string_of_bexe sym_state.dfns 0 exe in
  (*
  print_endline ("generating exe " ^ string_of_bexe sym_state.dfns 0 exe);
  *)
  let ret_string = "      FLX_RETURN\n" in
  let ge e = gen_expr sym_state bbdfns this e in
  let id,parent,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_exe] Can't find this " ^ string_of_int this)
  in
  let our_display = get_display_list sym_state this in
  let kind = match entry with
    | `BBDCL_function (_,_,_,_,_) -> Function
    | `BBDCL_procedure (_,_,_,_) -> Procedure
    | _ -> failwith "Expected executable code to be in function or procedure"
  in let our_level = length our_display in

  let handle_closure is_jump index ts a =
    (* DISABLE JUMP OPTIMISATION *)
    let was_jump = is_jump in
    let is_jump = false in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_exe(call)] Can't find index " ^ string_of_int index)
    in
    begin 
    match entry with
    | `BBDCL_proc (vs,_,ct) -> 
      if length vs = 0
      then 
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          "      //call multi (or no) -arg primitive " ^ src_str ^ "\n" ^
          "      {" ^ csubst ge sym_state bbdfns ct es typs `BTYP_void []^ "}\n"
        | (_,typ) -> 
          "      //call single-arg primitive " ^ src_str ^ "\n" ^
          "      {" ^ csubst ge sym_state bbdfns ct [a] [typ] `BTYP_void []^ "}\n"
        end
        ^
        begin
          if is_jump then ret_string
          else ""
        end
      else failwith "Generic procedure requires type arguments"

    | `BBDCL_procedure (vs,ps,bexes,nmap) ->
      if bexes = []
      then 
      "      //call to empty procedure " ^ id ^ " elided\n"
      else begin
        let n = !counter in
        incr counter;
        let the_display = 
          let d' = 
            map (fun i -> "ptr"^cpp_name bbdfns i)
            (get_display_list sym_state index)
          in 
            if length d' > our_level
            then "this" :: tl d'
            else d'
        in
        (* if we're calling from inside a function,
           we pass a 0 continuation as the caller 'return address'
           otherwise pass 'this' as the caller 'return address'
        *)
        let this = match kind with
          | Function -> 
            if is_jump 
            then 
              clierr sr "can't jump inside function" 
            else "0"
          | Procedure -> 
            if is_jump then "tmp"
            else "this"
        in

        let args = match a with
          | _,`BTYP_tuple [] -> this
          | _ -> this ^ ", " ^ ge a
        in

        let name = cpp_name bbdfns index in
        begin 
          match kind with
          | Function ->
            "      //run procedure " ^ src_str ^ "\n" ^
            "      con_t *_p =\n" ^
            "      (new(gc,"^ name^"_ptr_map)\n" ^ 
            "      " ^ name ^
            "(" ^ cat ",\n      " ("FLX_FPAR_PASS":: the_display) ^
            "))->call(\n      " ^ args ^ "\n      );\n" ^
            "      while(_p) _p=_p->resume();\n"

          | Procedure ->
            let call_string =
              "      return (new(gc,"^ name^"_ptr_map)\n" ^ 
              "      " ^ name ^
              "(" ^ cat ",\n      " ("FLX_FPAR_PASS":: the_display) ^
              "))->call(\n      " ^ args ^ "\n      );\n"
            in
            if is_jump
            then
              "     //jump to procedure " ^ src_str ^ "\n" ^
              "     {\n" ^
              "       con_t *tmp = _caller;\n" ^
              "       _caller = 0;\n" ^
              "      decref(this);\n" ^
              call_string ^
              "      }\n"
            else
              "     //call procedure " ^ src_str ^ "\n" ^
              "      pc = " ^ string_of_int n ^ ";\n" ^
              call_string ^
              "    case " ^ string_of_int n ^ ":\n"
        end
      end
      ^ (if was_jump then "FLX_RETURN // optimisation defeated\n" else "")

    | _ -> 
      failwith 
      (
        "[gen_exe] Expected '"^id^"' to be procedure constant, got " ^
        string_of_bbdcl sym_state.dfns entry index 
      )
    end
  in
  let handle_ginst is_jump index ts a =
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_exe(call)] Can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_proc (vs,_,ct) ->
      if length vs = length ts 
      then
        begin match a with
        | (`BEXPR_tuple es,`BTYP_tuple typs) ->
          "      //call multi (or no) -arg generic primitive " ^ src_str ^ "\n" ^
          "      {" ^ csubst ge sym_state bbdfns ct es typs `BTYP_void ts^ "}\n"
        | (_,typ) -> 
          "      //call single-arg generic primitive " ^ src_str ^ "\n" ^
          "      {" ^ csubst ge sym_state bbdfns ct [a] [typ] `BTYP_void ts^ "}\n"
        end
        ^ 
        begin
          if is_jump then ret_string
          else ""
        end
      else failwith "Generic procedure has wrong number of type arguments"
    | `BBDCL_procedure (vs,ps,_,_) -> handle_closure is_jump index ts a 

    | _ -> failwith "Expected generic instance procedure"
    end

  in
  match exe with
  | `BEXE_code s -> s
  | `BEXE_comment s -> "\n/*" ^ s ^ "*/\n"
  | `BEXE_label s -> 
    let local_labels = 
      try Hashtbl.find label_map this 
      with _ -> failwith ("[gen_exe] Can't find label map of " ^ string_of_int this)
    in
    let label_index = 
      try Hashtbl.find local_labels s 
      with _ -> failwith ("[gen_exe] In " ^ id ^ ": Can't find label " ^ s)
    in
    (match kind with
      | Procedure ->
      "    case " ^ string_of_int label_index ^ ":\n" 
      | Function -> "" 
        (* labels mus be allowed in functions, to support
           local gotos
        *)
    )
    ^
    "    " ^ s ^ ":;\n"

  | `BEXE_goto s -> 
    let local_labels = 
      try Hashtbl.find label_map this 
      with _ -> failwith ("Can't find label map of " ^ string_of_int this)
    in
    if Hashtbl.mem local_labels s
    then "      goto " ^ s ^ ";\n"
    else let rec aux parent =
      match parent with
      | None -> failwith ("[gen_exe(goto)] In " ^ id ^ ": Can't find label " ^ s)
      | Some i -> 
         let id, sr, parent, entry = 
           try Hashtbl.find sym_state.dfns i 
           with _ -> failwith ("Can't find parent " ^ string_of_int i)
         in
         match entry with
         | `SYMDEF_function (_,_,`AST_void _,_,_,_) ->
           let local_map = 
             try Hashtbl.find label_map i 
             with _ -> failwith ("Can't find label map for " ^ string_of_int i)
           in
           begin try i, Hashtbl.find local_map s
           with Not_found -> aux parent
           end
         | `SYMDEF_module  _ -> aux parent
         | `SYMDEF_function _ -> failwith ("goto "^s^" can't out of function")
         | _ -> failwith "Unknown parent kind"
    in 
      begin match kind with
      | Function -> failwith ("goto "^s^": can't jump out of function")
      | Procedure ->
      let id,parent,entry = 
        try Hashtbl.find bbdfns this 
        with _ -> failwith ("[gen_exe(goto)] Can't find this = " ^ string_of_int this)
      in
      let frame, pc = aux parent in
      let id,_,_ =
        try Hashtbl.find bbdfns frame 
        with _ -> failwith ("[gen_exe(goto)] Can't find frame " ^ string_of_int frame)
      in
        let frame_ptr = "ptr" ^ cpp_name bbdfns frame in
        "      // non local goto " ^ s ^ "\n" ^
        "      {\n" ^
        "        con_t *tmp1 = this;\n" ^
        "        while(tmp1 && " ^ frame_ptr ^ "!= tmp1)\n" ^
        "        {\n" ^
        "          con_t *tmp2 = tmp1->_caller;\n" ^
        "          tmp1 -> _caller = 0;\n" ^
        "          decref(tmp1);\n" ^
        "          tmp1 = tmp2;\n" ^
        "        }\n" ^
        "      }\n" ^
        "      " ^ frame_ptr ^ "->pc="^string_of_int pc^";\n" ^
        "      return " ^ frame_ptr ^ ";\n"
      end

  (* conditional gotos are always local *)
  | `BEXE_ifgoto (e,s) -> "      if(" ^ ge e ^ ")goto " ^ s ^ ";\n"
  | `BEXE_ifnotgoto (e,s) ->"      if(!("^ge e^"))goto " ^ s ^ ";\n" 
  
  | `BEXE_jump ((`BEXPR_ginst (index,ts),_) as f,a) ->
    handle_ginst true index ts a

  | `BEXE_call ((`BEXPR_ginst (index,ts),_) as f,a) ->
    handle_ginst false index ts a
    
  | `BEXE_jump ((`BEXPR_closure index,_) as f,a) ->
    handle_closure true index [] a
    
  | `BEXE_call ((`BEXPR_closure index,_) as f,a) ->
    handle_closure false index [] a

  | `BEXE_loop (i,a) ->
    let ptr = 
      if i= 0 then "this"
      else 
        let k = nth our_display (i-1) in 
        "ptr"^cpp_name bbdfns k
    in
      print_endline ("Looping to " ^ ptr);
      let args = match a with
        | _,`BTYP_tuple [] -> "_caller"
        | _ -> "_caller, " ^ ge a
      in
      "      //"^ src_str ^ "\n" ^
      "      return " ^ ptr ^ "->call(" ^ args ^");\n"

  (* BUG?!? if p is a variable containing a closure,
     and p recursively invokes the same closure,
     then the program counter and other state 
     of the closure is lost: the closure will return
     to its on previous state; that is, simply continue on:
     there's only one frame
   *)

  | `BEXE_call ((`BEXPR_name index,`BTYP_function _) as p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "this"
      | _ -> "this, " ^ ge a
    in
    let n = !counter in
    incr counter;
    "// VARIABLE OF TYPE FUNCTION: NEED INCREF HERE\n" ^
    "      //"^ src_str ^ "\n" ^
    "      pc = " ^ string_of_int n ^ ";\n" ^
    "      return incref(" ^ ge p ^ ")->call(" ^ args ^");\n" ^
    "    case " ^ string_of_int n ^ ":\n"

  | `BEXE_call (p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "this"
      | _ -> "this, " ^ ge a
    in
    let n = !counter in
    incr counter;
    "// MAYBE NEED INCREF HERE\n" ^
    "      //"^ src_str ^ "\n" ^
    "      pc = " ^ string_of_int n ^ ";\n" ^
    "      return " ^ ge p ^ "->call(" ^ args ^");\n" ^
    "    case " ^ string_of_int n ^ ":\n"

  | `BEXE_jump (p,a) ->
    let args = match a with
      | _,`BTYP_tuple [] -> "tmp"
      | _ -> "tmp, " ^ ge a
    in
    "      //"^ src_str ^ "\n" ^
    "      {\n" ^
    "        con_t *tmp = _caller;\n" ^
    "        _caller=0;\n" ^
    "        decref(this);\n" ^
    "        return " ^ ge p ^ "->call(" ^ args ^");\n" ^
    "      }\n"

  | `BEXE_proc_return -> ret_string

  | `BEXE_read index -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ string_of_int index)
    in
    let t =
      match entry with
      | `BBDCL_var t -> t
      | `BBDCL_val t -> t
      | _ -> failwith "Expected read argument to be variable"
    in
    let n = !counter in
    incr counter;
    "      //read variable\n" ^
    "      p_message = &(" ^ get_var_ref sym_state.dfns bbdfns this index ^");\n" ^
    "      action = wait_action;\n" ^
    "      pc=" ^ string_of_int n ^ ";\n" ^
    "      return this;\n" ^
    "    case " ^ string_of_int n ^ ":\n"

    
  | `BEXE_regmatch (e,alpha,nstates,cases,matrix) ->
    let b = Buffer.create 500 in
    let tack s = bcat b s in

    tack ("  // regmatch: nstates= "^string_of_int nstates^"\n");

    (* transition matrix *)
    let d = Array.make_matrix 256 nstates (-1) in
    Hashtbl.iter
    (fun (c,s1) s2 -> 
      d.(c).(s1) <- s2
    )
    matrix
    ;

    (* find equivalent chars *)
    let canon = Array.make 256 0 in
    for i = 0 to 255 do
      try
        for j = 0 to i do
          if d.(i) = d.(j) then 
          begin
            canon.(i) <- j;
            if i = j then
            begin
              tack("  static int s"^string_of_int i^"["^string_of_int nstates^"]=\n");
              tack "  {\n"
              ;
              for state = 0 to nstates - 1 do
                if state mod 16 = 0 then tack "      ";
                let s = "     " ^ string_of_int (d.(i).(state)+1) in
                let n = String.length s in
                let s = String.sub s (n-3) 3 in
                tack s;
                if state <> nstates - 1 then tack ", ";
                if state mod 16 = 15 then tack "\n"
              done
              ;
              tack "\n";
              tack "  };\n"
            end;
            raise Not_found;
          end
        done (* j *)
      with Not_found -> ()
    done (* i *)
    ;
    tack ("  static int *matrix[256] =\n");
    tack "  {\n";
    for i = 0 to 255 do
      if i mod 16 = 0 then tack "      ";
      let s = "     s" ^ string_of_int canon.(i) in
      let n = String.length s in
      let s = String.sub s (n-4) 4 in
      tack s;
      if i <> 255 then tack ", ";
      if i mod 16 = 15 then tack "\n"
    done;
    tack "  };\n\n";

    (* eval argument as a C++ string *)
    tack "  string s = ";
    tack (ge e);
    tack ";\n";
    tack "  char *start = s.begin();\n";
    tack "  char *end = s.end();\n";
    tack "  int state = 1;\n";
    
    tack "  while(state && start != end)\n";
    tack "    state = matrix[*start++][state-1];\n";
    
    tack "  switch (state)\n";
    tack "  {\n";
    Hashtbl.iter
    (fun state expr ->
      tack 
      (
        "    case " ^ string_of_int (state + 1)^ ":"^
        " return " ^ ge expr ^ ";\n"
      )
    )
    cases 
    ;
    tack "    case 0: assert((\"regmatch failure\",0));\n";
    tack "    default: assert((\"system failure in regmatch\",0));\n";
    tack "  }\n";

    Buffer.contents b
    
  | `BEXE_fun_return e -> 
    "      //" ^ src_str ^ "\n" ^
    "      return "^ge e^";\n"
  | `BEXE_nop s -> "      //Nop: " ^ s ^ "\n"
  | `BEXE_init (v,e) -> 
    "      //initialisation "^src_str^"\n" ^
    "      "^
    get_var_ref sym_state.dfns bbdfns this v^ 
    " = " ^ 
    ge e ^
    ";\n"

let gen_exes sym_state bbdfns display label_map counter index exes =
  (* print_endline ("// generating exes for index " ^ string_of_int index); *)
  cat ""
  (map (gen_exe sym_state bbdfns label_map counter index) exes)

(* PROCEDURES are implemented by continuations.
   The constructor accepts the display vector to
   form the closure object. The call method accepts
   the callers continuation object as a return address,
   and the procedure argument, and returns a continuation.
   The resume method runs the continuation until
   it returns a continuation to some object, possibly
   the same object. A flag in the continuation object
   determines whether the yield of control is a request
   for data or not (if so, the dispatcher must place the data
   in the nominated place before calling the resume method again.
*)
 
(* FUNCTIONS are implemented as functoids:
  the constructor accepts the display vector so as
  to form a closure object, the apply method
  accepts the argument and runs the function.
  The machine stack is used for functions.
*)
let gen_function_methods sym_state bbdfns label_map counter index = 
  let id,parent,entry = Hashtbl.find bbdfns index in
  (*
  print_endline ("Generating body for " ^ id ^ "<"^string_of_int index^">");
  flush stdout;
  *)
  (*
  print_endline ("function " ^ id ^ " methods");
  *)
  match entry with 
  | `BBDCL_function (vs,bps,ret',exes,_) ->
    let vargs = map fst vs in
    let template = template_header vargs "\n" in
    let targs = template_args vargs in

    let ps = map (fun (id,(ix,t)) -> id,t) bps in
    let argtype = unfold(lower(typeof_bparams bps)) in
    let ret = unfold(lower ret') in
    let funtype = fold(`BTYP_function (argtype, ret)) in
    let rev_vs = map (fun (s,i)->i,s) vs in
    let argtypename = cpp_type_instance sym_state bbdfns argtype rev_vs in

    let name = cpp_name bbdfns index in
    let instname = name ^ targs in
    let display = get_display_list sym_state index in
    (*
    let argtypename = cpp_typename sym_state bbdfns argtype 
    *)
    let rev_vs = map (function (s,i) -> i,s) vs in
    let rettypename = cpp_type_instance sym_state bbdfns ret rev_vs in
    let ctor = gen_ctor bbdfns instname name display in
    let params = get_parameters sym_state.dfns index in
    (* print_endline "GOT TYPE NAMES"; *)
    let apply =
      rettypename^ " " ^instname^
      "::apply("^
      (if argtype = `BTYP_tuple []
      then ""
      else argtypename ^" const &_arg ")^
      "){\n" ^
      "  collector_t &gc = *ptf->gc;\n" ^
      (
        match length params with
        | 0 -> ""
        | 1 -> 
          let i = hd params in
          if Hashtbl.mem bbdfns i 
          then
            "  " ^ cpp_name bbdfns i ^ " = _arg;\n"
          else ""
        | _ -> 
          let counter = ref 0 in fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem bbdfns i
            then 
              s ^ "  " ^ cpp_name bbdfns i ^ " = _arg.mem_"^ string_of_int n ^";\n"
            else s (* elide initialisation of elided variable *)
          )
          "" params 
      )^
      gen_exes sym_state bbdfns display label_map counter index exes ^
      "}\n"
    in
      "//FUNCTION " ^ id ^ ": Constructor\n" ^
      template ^
      ctor^ "\n" ^
      "//FUNCTION " ^ id ^ ": Apply method\n" ^
      template ^
      apply^ "\n"

  | _ -> failwith "function expected"

let gen_procedure_methods sym_state bbdfns label_map counter index = 
  let id,parent,entry = Hashtbl.find bbdfns index in (* can't fail *)
  match entry with 
  | `BBDCL_procedure (vs,bps,exes,_) ->
    let vargs = map fst vs in
    let template = template_header vargs "\n" in
    let targs = template_args vargs in

    let ps = map (fun (id,(ix,t)) -> id,t) bps in
    let argtype = unfold(lower(typeof_bparams bps)) in
    let funtype = fold(`BTYP_function (argtype, `BTYP_void)) in
    let rev_vs = map (fun (s,i)->i,s) vs in
    let argtypename = cpp_type_instance sym_state bbdfns argtype rev_vs in

    let name = cpp_name bbdfns index in
    let instname = name ^ targs in
    let display = get_display_list sym_state index in
    (*
    let argtypename = cpp_typename sym_state bbdfns argtype 
    *)
    let rev_vs = map (function (s,i) -> i,s) vs in
    let ctor = gen_ctor bbdfns instname name display in
    let params = get_parameters sym_state.dfns index in

    let cont = "con_t *"
    in
    let arg_sig = 
      match argtype with
      | `BTYP_tuple [] ->
      "  " ^ cont ^ "_ptr_caller"
      | _ ->
      "  " ^ cont ^ "_ptr_caller,\n"^
      "  " ^ argtypename ^" const &_arg\n"
    in
    let call =
      cont ^name^
      "::call(\n" ^ arg_sig ^
      "){\n" ^
      (
        "  _caller = _ptr_caller;\n" ^
        (match length params with
        | 0 -> ""
        | 1 -> 
          let i = hd params in
          if Hashtbl.mem bbdfns i 
          then
            "  " ^ cpp_name bbdfns i ^ " = _arg;\n"
          else ""

        | _ -> let counter = ref 0 in fold_left 
          (fun s i -> 
            let n = !counter in incr counter; 
            if Hashtbl.mem bbdfns i
            then
              s ^ "  " ^ cpp_name bbdfns i ^ " = _arg.mem_"^ string_of_int n ^";\n"
            else s (* elide initialisation of elided variables *)
          )
          "" params
          ) ^
          "  pc = 0;\n" ^
          "  return this;\n"
      )^
      "}\n"
    and resume = 
      if exes = []
      then
        cont^name^"::resume(){//empty\n"^
        "     FLX_RETURN\n" ^ 
        "}\n"
      else
        cont^name^"::resume(){\n"^
        "  collector_t &gc = *ptf->gc;\n" ^
        "  switch(pc){\n" ^
        "    case 0:\n" ^
        gen_exes sym_state bbdfns display label_map counter index exes ^
        "    default: FLX_RETURN\n" ^
        "  }\n" ^
        "}\n"
    in
      "\n//PROC " ^ id ^ "\n" ^
      "//PROC " ^ id ^ ": Constructor\n" ^
      ctor^
      "\n//PROC " ^ id ^ ": Call method\n" ^
      call^
      "\n//PROC " ^ id ^ ": Resume method\n" ^
      resume

  | _ -> failwith "prcoedure expected"


let gen_execute_methods sym_state bbdfns counter =
  let label_map = create_label_map bbdfns counter in
  let s = Buffer.create 2000 in
  Hashtbl.iter
  (fun index (id,parent,entry) -> 
  
  match entry with
  | `BBDCL_function (vs,ps, ret, _,_) -> 
    (* print_endline ("//generating methods for " ^ id ^ "<"^string_of_int index^">"); *)
    bcat s ("//------------------------------\n");
    bcat s (
      gen_function_methods sym_state bbdfns label_map counter index
    )
  | `BBDCL_procedure (vs,ps,_,_) -> 
    (* print_endline ("//generating methods for " ^ id ^ "<"^string_of_int index^">"); *)
    bcat s ("//------------------------------\n");
    bcat s (
      gen_procedure_methods sym_state bbdfns label_map counter index
    )
  | _ -> ()
  )
  bbdfns
  ;
  Buffer.contents s

let gen_biface_header sym_state bbdfns biface = match biface with
  | `BIFACE_export (index, export_name) ->
    let id,parent,entry = Hashtbl.find bbdfns index in
    match entry with
    | `BBDCL_function (vs,ps, ret, _,_) ->
      let display = get_display_list sym_state index in
      if length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        map 
        (fun (_,(_,x)) -> cpp_typename sym_state bbdfns x) 
        ps 
      in
      let arglist = "  " ^ cat ",\n  " ("FLX_FPAR_DECL":: argtypes) in
      let rettypename = cpp_typename sym_state bbdfns ret in

      "//EXPORT FUNCTION " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" " ^ rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | `BBDCL_procedure (vs,ps, _,_) ->
      let display = get_display_list sym_state index in
      if length display <> 0
      then failwith "Can't export nested proc";

      let argtypes = 
        map 
        (fun (_,(_,x)) -> cpp_typename sym_state bbdfns x) 
        ps 
      in
      let arglist = 
        "  " ^ cat ",\n  " ("FLX_FPAR_DECL"::argtypes) 
      in 
      
      "//EXPORT PROCEDURE " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      "extern \"C\" con_t * "  ^ export_name ^ "(\n" ^ arglist ^ "\n);\n"

    | _ -> failwith "Not implemented: export non-function/procedure"
  
let gen_biface_body sym_state bbdfns biface = match biface with
  | `BIFACE_export (index, export_name) ->
    let id,parent,entry = Hashtbl.find bbdfns index in
    match entry with
    | `BBDCL_function (vs,ps, ret, _,_) ->
      let display = get_display_list sym_state index in
      if length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        map 
        (fun (id,(ix,t)) -> cpp_typename sym_state bbdfns t ^ " " ^ id) 
        ps 
      in
      let arglist = "  " ^ cat ",\n  " ("FLX_FPAR_DECL":: argtypes) in
      let rettypename = cpp_typename sym_state bbdfns ret in
      let class_name = cpp_name bbdfns index in

      "//EXPORT FUNCTION " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      rettypename ^" " ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*_ptf->gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(_pgf,_ppf,_ptf))" ^
      "->apply(" ^ cat ", " (map fst ps) ^ ");\n" ^
      "}\n"

    | `BBDCL_procedure (vs,ps,_,_) ->
      let display = get_display_list sym_state index in
      if length display <> 0
      then failwith "Can't export nested function";

      let argtypes = 
        map 
        (fun (id,(_,t)) -> cpp_typename sym_state bbdfns t ^ " " ^ id) 
        ps 
      in
      let arglist = "  " ^ cat ",\n  " ("FLX_FPAR_DECL" ::argtypes) in
      let class_name = cpp_name bbdfns index in

      "//EXPORT PROC " ^ cpp_name bbdfns index ^ 
      " as " ^ export_name ^ "\n" ^
      "con_t *" ^ export_name ^ "(\n" ^ arglist ^ "\n){\n" ^
      "  return (new(*_ptf->gc,"^class_name^"_ptr_map)\n" ^
      "    " ^ class_name ^ "(_pgf,_ppf,_ptf))" ^
      "->call(" ^ cat ", " ("0"::(map fst ps)) ^ ");\n" ^
      "}\n"

    | _ -> failwith "Not implemented: export non-function/procedure"

let gen_biface_headers sym_state bbdfns bifaces = 
  cat "" (map (gen_biface_header sym_state bbdfns) bifaces)

let gen_biface_bodies sym_state bbdfns bifaces = 
  cat "" (map (gen_biface_body sym_state bbdfns) bifaces)

@h = tangler('src/flxg.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_srcref
open Flx_desugar
open Flx_bbind
open Flx_name
open Flx_tgen
open Flx_gen
open Flx_symtab
open Flx_getopt
open Flx_version
open Flx_exceptions
open Flx_flxopt
;;

let print_help () = print_options(); exit(0)
;;

let reverse_return_parity = ref false
;;

try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in
  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

 let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and header_file_name = filebase ^ ".hpp"
  and body_file_name = filebase ^ ".cpp" 
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in
  let syms = { syms with compiler_options = compiler_options } in

  (* PARSE THE IMPLEMENTATION FILE *)
  if compiler_options.print_flag
  then print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  let have_interface = Sys.file_exists iface_file_name in
  if compiler_options.print_flag
  then print_endline (Flx_print.string_of_compilation_unit parse_tree);

  if compiler_options.print_flag
  then print_endline "//PARSE OK";

  (* IF THERE WAS NO INTERFACE FILE, GENERATE ONE *)
  if not have_interface 
  then begin

    if compiler_options.print_flag
    then print_endline "//No interface file found: generating one";
    let h = open_out iface_file_name in
    let iface = build_interface parse_tree in
    List.iter 
    (
      fun x->
        output_string h
        (
          (string_of_statement 0 x)^"\n"
        )
    ) 
    iface;
    close_out h
  end
  ;

  if compiler_options.print_flag 
  then print_endline "//DESUGARING";

  let deblocked = 
    desugar_program include_dirs module_name syms.counter parse_tree 
  in

  let root = !(syms.counter) in
  if compiler_options.print_flag 
  then print_endline ("//Top level module ''"^module_name^" has index " ^ string_of_int root);


  if compiler_options.print_flag 
  then print_endline "//BUILDING TABLES";

  let table, exes, ifaces,dirs = 
    build_tables syms "<top level>" 0 None None root deblocked 
  in

  if compiler_options.print_flag 
  then print_endline "//BINDING EXECUTABLE CODE"
  ;
  let bbdfns = bbind syms in
  let bifaces = bind_ifaces syms ifaces in

  if compiler_options.print_flag 
  then print_endline "//Binding complete";

  if compiler_options.print_flag 
  then print_endline "//CHECKING ROOT";

  let top_class, root_proc = 
    let id,sr,parent,entry = Hashtbl.find syms.dfns root in
    let name_map = match entry with
      | `SYMDEF_module (table,dirs) -> table
      | _ -> failwith "Expected to find top level module ''"
    in let entry = Hashtbl.find name_map "_init_" in
    let index = match entry with
      | FunctionEntry [Simple x] -> x
      | FunctionEntry [] -> failwith "Couldn't find '_init_'"
      | FunctionEntry _ -> failwith "Too many top level procedures called '_init_'"
      | NonFunctionEntry _ -> failwith "_init_found but not procedure"
    in cpp_name bbdfns index, index
  in


  if compiler_options.print_flag 
  then print_endline "//Eliding useless things";

  let bbdfns = Flx_use.elide_unused bbdfns root_proc bifaces in
  let bbdfns = Flx_use.elide_unused bbdfns root_proc bifaces in

  let hf = open_out header_file_name in
  let bf = open_out body_file_name in 
  let psh s = output_string hf s in
  let psb s = output_string bf s in
  let plh s = psh s; psh  "\n" in
  let plb s = psb s; psb "\n" in

    if compiler_options.print_flag 
    then print_endline "//GENERATING C++: user headers";
    
    plh ("//" ^ input_file_name);
    plh ("//Generated by Felix Version " ^ !version_data.version_string);
    plh "";
    plh "//FELIX RUNTIME";
    plh "#include \"rtl/flx_rtl.hpp\"";
    plh "using namespace flx::rtl;";
    plh "#include \"rtl/flx_collector.hpp\"";
    plh "using namespace flx::gc::generic;";
    plh "";

    plh "#define FLX_FMEM_DECL \\";
    plh "  global_frame_t *pgf;\\";
    plh "  process_frame_t *ppf;\\";
    plh "  thread_frame_t *ptf;";
    
    plh "#define FLX_FPAR_DECL \\";
    plh "    global_frame_t *_pgf,\\";
    plh "    process_frame_t *_ppf,\\";
    plh "    thread_frame_t *_ptf";

    plh "\n//-----------------------------------------";
    plh "//USER HEADERS";
    (* These must be in order: build a list and sort it *)
    let dfnlist = ref [] in
    Hashtbl.iter
    (fun index data -> dfnlist := index :: !dfnlist)
    bbdfns
    ;
    List.iter 
    (fun index ->
      match Hashtbl.find bbdfns index 
      with (id,parent,entry) ->
      match entry with
      | `BBDCL_header s -> plh s
      | _ -> ()
    )
    (List.sort compare !dfnlist)
    ;

    plh "\n//-----------------------------------------";
    List.iter plh [
    "//FELIX SYSTEM";

    (* GLOBAL FRAME *)
    "struct global_frame_t {";
    " // put global values here";
    "};";
    "struct process_frame_t {";
    "  global_frame_t *global_frame;";
    "  process_frame_t(";
    "    global_frame_t *_global_frame";
    "  ) :";
    "    global_frame(_global_frame)";
    "  {}";
    "};";

    "struct thread_frame_t;"
    ]
    ;
    if compiler_options.print_flag then print_endline "//GENERATING C++: collect types";
    collect_types syms bbdfns;
    let types = ref [] in 
      Hashtbl.iter 
      (fun t index-> types := (index, t) :: !types)
      syms.registry
    ;
    let types = 
      List.sort 
      (
        fun a1 a2 -> compare (fst a1) (fst a2)
      ) 
      !types
    in
    (*
    List.iter
    (fun (_,t) -> print_endline (string_of_btypecode dfns t))
    types
    ;
    *)

    plh "\n//TUPLES";
    plh (gen_tuples syms);

    if compiler_options.print_flag then print_endline "//GENERATING C++: type class names";
    plh "\n//-----------------------------------------";
    plh "//NAME THE TYPES";
    plh  (gen_type_names syms bbdfns types);

    if compiler_options.print_flag then print_endline "//GENERATING C++: type class definitions";
    plh "\n//-----------------------------------------";
    plh  "//DEFINE THE TYPES";
    plh  (gen_types syms bbdfns types);

    if compiler_options.print_flag then print_endline "//GENERATING C++: function and procedure classes";
    plh "\n//-----------------------------------------";
    plh  "//DEFINE FUNCTION CLASSES";
    plh  (gen_functions syms bbdfns);
    List.iter plh 
    [
    "struct thread_frame_t {";
    "  global_frame_t *global_frame;";
    "  process_frame_t *process_frame;";
    "  collector_t *gc;";
    "  thread_frame_t(";
    "    global_frame_t *global_frame_a,";
    "    process_frame_t *process_frame_a,";
    "    collector_t *gc_a";
    "  ) : ";
    "    process_frame(process_frame_a),";
    "    global_frame(global_frame_a),";
    "    gc(gc_a)";
    "  {}"
    ];
    (*
    print_endline "Finding top level variables";
    *)
    List.iter plh
    [
    (find_members syms bbdfns root []);
    "};"
    ];


    (* BODY *)
    if compiler_options.print_flag then print_endline "//GENERATING C++: GC ptr maps & offsets";
    plb ("#include \"" ^ module_name ^ ".hpp\"");
    plb "#include <stdio.h>"; (* for diagnostics *)
    plb "#define comma ,";
    plb "\n//-----------------------------------------";
    plb "//EMIT USER BODY CODE";
    (* These must be in order: build a list and sort it *)
    let dfnlist = ref [] in
    Hashtbl.iter
    (fun index data -> dfnlist := index :: !dfnlist)
    bbdfns
    ;
    List.iter 
    (fun index ->
      match Hashtbl.find bbdfns index 
      with (id,parent,entry) ->
      match entry with
      | `BBDCL_body s -> plb s
      | _ -> ()
    )
    (List.sort compare !dfnlist)
    ;

    plb "\n//-----------------------------------------";
    plb "//DEFINE OFFSET tables for GC";
    plb "static size_t _uctor_offsets[1]= { offsetof(_uctor_,data) };";
    plb "static gc_shape_t _uctor_ptr_map ("; 
    plb "  sizeof(_uctor_),";
    plb "  0,";
    plb "  1,";
    plb "  _uctor_offsets";
    plb ");";

    plb (Flx_ogen.gen_offset_tables syms bbdfns);

    if compiler_options.print_flag then print_endline "//GENERATING C++: method bodies";

    plb "#define FLX_RETURN \\";
    plb "{ \\";
    plb "  con_t *tmp = _caller; \\";
(*    plb "  printf(\"returning from %p to %p\\n\",this,tmp);\\"; *)
    plb "  decref(this); \\";
    plb "  _caller = 0; \\";
    plb "  return tmp; \\";
    plb "}";
    
    plb "#define FLX_FMEM_INIT \\";
    plb "  pgf(_pgf),\\";
    plb "  ppf(_ppf),\\";
    plb "  ptf(_ptf)";

    plb "#define FLX_FPAR_PASS \\";
    plb "  pgf,\\";
    plb "  ppf,\\";
    plb "  ptf";


    plb "\n//-----------------------------------------";
    plb "//DEFINE FUNCTION CLASS METHODS";
    plb (gen_execute_methods syms bbdfns syms.counter);

    if compiler_options.print_flag then print_endline "//GENERATING C++: interface";
    plb "\n//-----------------------------------------";
    plb "//CREATE STANDARD EXTERNAL INTERFACE";
    plb "extern \"C\" global_frame_t *create_global_frame() {";
    plb "  return new global_frame_t;";
    plb "}";

    plb "extern \"C\" void destroy_global_frame(";
    plb "  global_frame_t *pgf";
    plb ") {";
    plb "  delete pgf;";
    plb "}";

    plb "extern \"C\" process_frame_t *create_process_frame(";
    plb "  global_frame_t *pgf";
    plb  ") {";
    plb "  return new process_frame_t(pgf);";
    plb "}";

    plb "extern \"C\" void destroy_process_frame(";
    plb "  process_frame_t *ppf";
    plb  ") {";
    plb "  delete ppf;";
    plb "}";

    plb "extern \"C\" thread_frame_t *create_thread_frame(";
    plb "  global_frame_t *pgf,";
    plb "  process_frame_t *ppf,";
    plb "  collector_t *gc";
    plb ") {";
    plb "  return new thread_frame_t(pgf,ppf,gc);";
    plb "}";

    plb "extern \"C\" void destroy_thread_frame(";
    plb "  thread_frame_t *ptf";
    plb ") {";
    plb "  delete ptf;";
    plb "}";

    plb "extern \"C\" con_t *start(";
    plb "  global_frame_t *pgf,";
    plb "  process_frame_t *ppf,";
    plb "  thread_frame_t *ptf";
    plb ") {";
    plb ("  return (new(*ptf->gc,"^top_class^"_ptr_map) " ^ top_class ^ "(pgf,ppf,ptf))->call(0);");
    plb "}";

    plb "\n//-----------------------------------------";
    plh "//DECLARE USER EXPORTS";
    plh (gen_biface_headers syms bbdfns bifaces);
    plb "//DEFINE EXPORTS";
    plb (gen_biface_bodies syms bbdfns bifaces);

    plh "//header complete";
    plh "//#endif";
    plb "//body complete";
    close_out hf;
    close_out bf;
    exit (if compiler_options.reverse_return_parity then 1 else 0)

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

