@h = tangler('src/flx_name.mli')
@select(h)
open Flx_types
val cpp_name :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  string

val cpp_instance_name :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  btypecode_t list ->
  string

val cpp_type_classname :
  sym_state_t ->
  btypecode_t -> 
  string

val cpp_typename :
  sym_state_t ->
  btypecode_t -> 
  string


@h = tangler('src/flx_name.ml')
@select(h)
open Flx_types
open Flx_unify
open Flx_print
open Flx_util
open Flx_csubst
open List

let cvt s = 
  let n = String.length s in
  let id = Buffer.create (n+10) in
  for i=0 to n - 1 do
    match s.[i] with
    | '\'' -> Buffer.add_string id "__p"
    | '\\' -> Buffer.add_string id "__"
    | x -> Buffer.add_char id x
  done;
  Buffer.contents id

(* mangle a C++ type name into an identifier *)
let mangle_cpp_typename ct =
  let n = String.length ct in
  let buf = Buffer.create (n+20) in
  let tack_ch ch = Buffer.add_char buf ch in
  let tack_str str = Buffer.add_string buf str in
  for i=0 to n - 1 do
    match ct.[i] with
    | '*' -> tack_str "_p"
    | ':' 
    | '<'
    | '>'
    | ' '
    | '?'
    | '$'
    | '@'
    | '#'
    | '`'
      -> tack_ch '_'
    | x -> tack_ch x
  done;
  Buffer.contents buf

(* basic name mangler *)
let cpp_name syms bbdfns index =
  let id,parent,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[cpp_name] Can't find index " ^ si index)
  in
  (match entry with
  | `BBDCL_function _ -> "_f"   
  | `BBDCL_procedure _  -> "_p"
  | `BBDCL_var _ -> "_v"
  | `BBDCL_val _ -> "_v"
  | _ -> failwith "cpp_name expected func,proc,var or val"
  ) ^ si index ^ "_" ^ cvt id

let cpp_instance_name syms bbdfns index ts =
  let inst = 
    try Hashtbl.find syms.instances (index,ts) 
    with Not_found -> 
    let id = 
      try 
        let id,_,_ = Hashtbl.find bbdfns index in id
      with Not_found -> "unknown"
    in
    let has_variables = 
      fold_left 
      (fun truth t -> truth || var_occurs t)
      false
      ts
    in
    failwith 
    (
      "[cpp_intance_name] unable to find instance " ^ id ^
      "<" ^ si index ^ ">[" ^catmap ", " (string_of_btypecode syms.dfns) ts ^ "]"
      ^ (if has_variables then " .. a subscript contains a type variable" else "")
    )
  in
  "_i" ^ si inst ^ cpp_name syms bbdfns index 

let rec cpp_type_classname syms t = 
  let registry = syms.registry in
  let t = fold t in
  try match unfold t with
  | `BTYP_var i -> failwith ("[cpp_type_classname] Can't name type variable " ^ si i) 
  | `BTYP_fix i -> failwith "[cpp_type_classname] Can't name type fixpoint"
  | `BTYP_binding _ -> failwith "[cpp_type_classname] Unexpected binding type"
  | `BTYP_void -> failwith "void doesn't have a classname"
  | `BTYP_tuple [] -> "unit"

  | `BTYP_pointer t' -> 
    "_rt" ^ cpp_type_classname syms t' 

  | `BTYP_function (_,`BTYP_void) -> 
    "_pt" ^ si (Hashtbl.find registry t) 

  | `BTYP_function _ -> 
    "_ft" ^ si (Hashtbl.find registry t)

  | `BTYP_tuple _ -> 
    "_tt" ^ si (Hashtbl.find registry t)
  
  | `BTYP_sum _ -> 
    "_st" ^ si (Hashtbl.find registry t)

    
  | `BTYP_inst (i,_) -> 
    let id,sr,parent,vs,tabl,dirs,entry = Hashtbl.find syms.dfns i in
    let prefix =
      match entry with
      | `SYMDEF_struct _  -> "_s"
      | `SYMDEF_union _  -> "_u"
      | `SYMDEF_abs _ -> "_a"
      | _ -> "_unk_"
    in 
      prefix ^ si i ^ "t_" ^ si (Hashtbl.find registry t) 

  | _ -> 
    failwith 
    (
      "[cpp_type_classname] Unexpected " ^
      string_of_btypecode syms.dfns t
    )
  with Not_found -> 
    failwith 
    (
      "[cpp_type_classname] Expected type "^ 
      string_of_btypecode syms.dfns t ^ 
      " to be in registry"
    )


let cpp_typename syms t = 
  match unfold t with
  | `BTYP_function _ -> cpp_type_classname syms t ^ "*"
  | _ -> cpp_type_classname syms t


