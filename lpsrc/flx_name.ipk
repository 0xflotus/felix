@h = tangler('src/flx_name.mli')
@select(h)
open Flx_types
val cpp_name :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  string

val cpp_instance_name :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  btypecode_t list ->
  string

val cpp_type_classname :
  sym_state_t ->
  btypecode_t -> 
  string

val cpp_typename :
  sym_state_t ->
  btypecode_t -> 
  string

val tsubst :
  (string * int) list ->
  btypecode_t list ->
  btypecode_t ->
  btypecode_t

@h = tangler('src/flx_name.ml')
@select(h)
open Flx_types
open Flx_unify
open Flx_print
open Flx_util
open Flx_csubst
open List

let cvt s = 
  let n = String.length s in
  let id = Buffer.create (n+10) in
  for i=0 to n - 1 do
    match s.[i] with
    | '\'' -> Buffer.add_string id "__p"
    | '\\' -> Buffer.add_string id "__"
    | x -> Buffer.add_char id x
  done;
  Buffer.contents id

(* mangle a C++ type name into an identifier *)
let mangle_cpp_typename ct =
  let n = String.length ct in
  let buf = Buffer.create (n+20) in
  let tack_ch ch = Buffer.add_char buf ch in
  let tack_str str = Buffer.add_string buf str in
  for i=0 to n - 1 do
    match ct.[i] with
    | '*' -> tack_str "_p"
    | ':' 
    | '<'
    | '>'
    | ' '
    | '?'
    | '$'
    | '@'
    | '#'
    | '`'
      -> tack_ch '_'
    | x -> tack_ch x
  done;
  Buffer.contents buf

(* basic name mangler *)
let cpp_name syms bbdfns index =
  let id,parent,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[cpp_name] Can't find index " ^ si index)
  in
  (match entry with
  | `BBDCL_function _ -> "_fun_"   
  | `BBDCL_procedure _  -> "_proc_"
  | `BBDCL_var _ -> "_var_"
  | `BBDCL_val _ -> "_val_"
  | _ -> failwith "cpp_name expected func,proc,var or val"
  ) ^ si index ^ "_" ^ cvt id

let cpp_instance_name syms bbdfns index ts =
  let inst = 
    try Hashtbl.find syms.instances (index,ts) 
    with Not_found -> 
    let id = 
      try 
        let id,_,_ = Hashtbl.find bbdfns index in id
      with Not_found -> "unknown"
    in
    failwith 
    (
      "[cpp_intance_name] unable to find instance " ^ id ^
      "<" ^ si index ^ ">[" ^catmap ", " (string_of_btypecode syms.dfns) ts ^ "]"
    )
  in
  "_inst_" ^ si inst ^ "_" ^ cpp_name syms bbdfns index 

let rec cpp_type_classname syms t = 
  let registry = syms.registry in
  let t = fold t in
  try match unfold t with
  | `BTYP_var i -> failwith ("[cpp_type_classname] Can't name type variable " ^ si i) 
  | `BTYP_fix i -> failwith "[cpp_type_classname] Can't name type fixpoint"
  | `BTYP_binding _ -> failwith "[cpp_type_classname] Unexpected binding type"
  | `BTYP_void -> failwith "void doesn't have a classname"
  | `BTYP_tuple [] -> "unit"

  | `BTYP_pointer t' -> 
    "_ref_" ^ cpp_type_classname syms t' 

  | `BTYP_function (_,`BTYP_void) -> 
    "_proc_type_" ^ si (Hashtbl.find registry t) 

  | `BTYP_function _ -> 
    "_fun_type_" ^ si (Hashtbl.find registry t)

  | `BTYP_tuple _ -> 
    "_tuple_type_" ^ si (Hashtbl.find registry t)
  
  | `BTYP_sum _ -> 
    "_sum_type_" ^ si (Hashtbl.find registry t)

    
  | `BTYP_inst (i,_) -> 
    let id,sr,parent,vs,tabl,dirs,entry = Hashtbl.find syms.dfns i in
    let prefix =
      match entry with
      | `SYMDEF_struct _  -> "_struct_"
      | `SYMDEF_union _  -> "_union_"
      | `SYMDEF_abs _ -> "_abs_"
      | _ -> "_unk_"
    in 
      prefix ^ si i ^ "_type_" ^ si (Hashtbl.find registry t) 

  | _ -> 
    failwith 
    (
      "[cpp_type_classname] Unexpected " ^
      string_of_btypecode syms.dfns t
    )
  with Not_found -> 
    failwith 
    (
      "[cpp_type_classname] Expected type "^ 
      string_of_btypecode syms.dfns t ^ 
      " to be in registry"
    )


let cpp_typename syms t = 
  match unfold t with
  | `BTYP_function _ -> cpp_type_classname syms t ^ "*"
  | _ -> cpp_type_classname syms t

(* the type arguments are matched up with the type
  variables in order so that
  vs_i -> ts_i
  where vs_t might be (fred,var j)
*)
let tsubst 
  (vs:(string * int) list) 
  (ts:btypecode_t list)
  (t:btypecode_t) 
=
  if length ts <> length vs
  then failwith "[tsubst] wrong number of type args"
  ;
  let tvs = combine vs ts in
  let varmap = Hashtbl.create 97 in
  iter
  (fun ((name, varidx),typ) -> Hashtbl.add varmap varidx typ)
  tvs
  ;
  varmap_subst varmap t

