@h = tangler('src/flx_name.mli')
@select(h)
open Flx_types
open Flx_mtypes2

val cpp_name :
  fully_bound_symbol_table_t ->
  int ->
  string

val cpp_instance_name :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  btypecode_t list ->
  string

val cpp_type_classname :
  sym_state_t ->
  btypecode_t -> 
  string

val cpp_typename :
  sym_state_t ->
  btypecode_t -> 
  string


val cpp_ltypename :
  sym_state_t ->
  btypecode_t -> 
  string


(** mangle a Felix identifier to a C one *)
val cid_of_flxid:  
 string-> string

@h = tangler('src/flx_name.ml')
@select(h)
open Flx_types
open Flx_mtypes2
open Flx_unify
open Flx_print
open Flx_util
open Flx_exceptions
open List

(* these words are either keywords or peculiar to the
   compiler code generator, so we have to avoid a clash.
   This list has been constructed by trial and error ..

   note the RHS value is irrelevant, it just has to be different
   to the LHS value ..
*)

let fixups = [
  (* C++ keywords *)
  "true","_true";
  "false","_false";
  
  (* special names in thread frame *)
  "argc","_argc";
  "argv","_argv";
  "flx_stdin","_flx_stdin";
  "flx_stdout","_flx_stdout";
  "flx_stderr","_flx_stderr";
  "gc","_gc";
  
  (*
  "read","_read";
  "write","_write";
  *)

  (* C keywords shouldnt occur because they should all be Felix keywords *)
  "while","_while";
  "continue","_continue";
  "break","_break";
  "for","_for";
  "return","_return";
]

let cvt s = 
  let n = String.length s in
  let id = Buffer.create (n+10) in
  for i=0 to n - 1 do
    match s.[i] with
    | '\'' -> Buffer.add_string id "__p"
    | '\\' -> Buffer.add_string id "__"
    | x -> Buffer.add_char id x
  done;
  let name = Buffer.contents id in
  try assoc name fixups with Not_found -> name

let cid_of_flxid s = cvt s

(* mangle a C++ type name into an identifier *)
let mangle_cpp_typename ct =
  let n = String.length ct in
  let buf = Buffer.create (n+20) in
  let tack_ch ch = Buffer.add_char buf ch in
  let tack_str str = Buffer.add_string buf str in
  for i=0 to n - 1 do
    match ct.[i] with
    | '*' -> tack_str "_p"
    | ':' 
    | '<'
    | '>'
    | ' '
    | '?'
    | '$'
    | '@'
    | '#'
    | '`'
      -> tack_ch '_'
    | x -> tack_ch x
  done;
  Buffer.contents buf

(* basic name mangler *)
let cpp_name bbdfns index =
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[cpp_name] Can't find index " ^ si index)
  in
  (match entry with
  | `BBDCL_function _ -> "_f"   
  | `BBDCL_callback _ -> "_cf"   
  | `BBDCL_procedure _  -> "_p"
  | `BBDCL_regmatch _  -> "_rm"
  | `BBDCL_reglex _  -> "_rl"
  | `BBDCL_var _ -> "_v"
  | `BBDCL_val _ -> "_v"
  | `BBDCL_ref _ -> "_v"
  | `BBDCL_tmp _ -> "_tmp"
  | `BBDCL_class _ -> "_cl"
  | _ -> syserr sr "cpp_name expected func,proc,var,val,class,reglex or regmatch"
  ) ^ si index ^ "_" ^ cvt id

let cpp_instance_name' syms bbdfns index ts =
  let inst = 
    try Hashtbl.find syms.instances (index,ts) 
    with Not_found -> 
    let id = 
      try 
        let id,parent,sr,entry = Hashtbl.find bbdfns index in id
      with Not_found -> 
      try
        match Hashtbl.find syms.dfns index with
        {id=id} -> id ^ "[unbound]"
      with Not_found -> 
      "unknown"
    in
    let has_variables = 
      fold_left 
      (fun truth t -> truth || var_occurs t)
      false
      ts
    in
    failwith 
    (
      "[cpp_instance_name] unable to find instance " ^ id ^
      "<" ^ si index ^ ">[" ^catmap ", " (string_of_btypecode syms.dfns) ts ^ "]"
      ^ (if has_variables then " .. a subscript contains a type variable" else "")
    )
  in
  "_i" ^ si inst ^ cpp_name bbdfns index 

let is_export syms id =
  let bifaces = syms.bifaces in
  try 
    iter 
    (function
      | `BIFACE_export_fun (_,_,s)
      | `BIFACE_export_type (_,_,s) -> 
        if id = s then raise Not_found
     )
     bifaces; 
     false 
  with Not_found -> true
  
let cpp_instance_name syms bbdfns index ts =
  let long_name = cpp_instance_name' syms bbdfns index ts in
  if syms.compiler_options.mangle_names then long_name else
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[cpp_name] Can't find index " ^ si index)
  in
  let id' = cvt id in
  if id = id' then 
  begin
    let inst = 
      try Hashtbl.find syms.quick_names id 
      with Not_found -> 
        Hashtbl.add syms.quick_names id (index,ts);
        index,ts
    in
      if (index,ts) <> inst then long_name else
      if is_export syms id then long_name else id
  end
  else long_name

let tix syms t = 
  try Hashtbl.find syms.registry t
  with Not_found -> 
    failwith ("Cannot find type " ^sbt syms.dfns t ^" in registry")

let rec cpp_type_classname syms t = 
  let tix t = tix syms t in
  let t = fold syms.dfns (lstrip syms.dfns t) in
  try match unfold syms.dfns t with
  | `BTYP_var (i,mt) -> failwith ("[cpp_type_classname] Can't name type variable " ^ si i ^":"^ sbt syms.dfns mt) 
  | `BTYP_fix i -> failwith "[cpp_type_classname] Can't name type fixpoint"
  | `BTYP_void -> "void" (* failwith "void doesn't have a classname" *)
  | `BTYP_tuple [] -> "unit"

  | `BTYP_pointer t' -> 
    "_rt" ^ cpp_type_classname syms t' 

  | `BTYP_function (_,`BTYP_void) -> 
    "_pt" ^ si (tix t) 

  | `BTYP_function _ -> 
    "_ft" ^ si (tix t)

  | `BTYP_cfunction _ -> 
    "_cft" ^ si (tix t)

  | `BTYP_array _ -> 
    "_at" ^ si (tix t)

  | `BTYP_tuple _ -> 
    "_tt" ^ si (tix t)

  | `BTYP_record _ -> 
    "_art" ^ si (tix t)

  | `BTYP_variant _ -> 
    "_avt" ^ si (tix t)
  
  | `BTYP_sum _ -> 
    "_st" ^ si (tix t)

  | `BTYP_unitsum k -> 
    "_us" ^ si k

    
  | `BTYP_inst (i,ts) -> 
    let cal_prefix = function
      | `SYMDEF_struct _  -> "_s"
      | `SYMDEF_union _   -> "_u"
      | `SYMDEF_abs _  -> "_a"
      | `SYMDEF_class -> "_cl"
      | _ -> "_unk_"
    in
    if ts = [] then
      match
        try
          match Hashtbl.find syms.dfns i with 
          { id=id; symdef=symdef } -> Some (id,symdef )
        with Not_found -> None
      with
      | Some (id,`SYMDEF_cstruct _) -> id
      | Some (id,`SYMDEF_cclass _) -> id^"*"
      | Some (_,`SYMDEF_abs (_,`Str "char",_)) -> "char" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`Str "int",_)) -> "int" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`Str "short",_)) -> "short" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`Str "long",_)) -> "long" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`Str "float",_)) -> "float" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`Str "double",_)) -> "double" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`StrTemplate "char",_)) -> "char" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`StrTemplate "int",_)) -> "int" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`StrTemplate "short",_)) -> "short" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`StrTemplate "long",_)) -> "long" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`StrTemplate "float",_)) -> "float" (* hack .. *)
      | Some (_,`SYMDEF_abs (_,`StrTemplate "double",_)) -> "double" (* hack .. *)
      | Some (_,data)  -> 
        let prefix = cal_prefix data in
        prefix ^ si i ^ "t_" ^ si (tix t) 
      | None -> 
         "_unk_" ^ si i ^ "t_" ^ si (tix t) 
    else
      "_poly_" ^ si i ^ "t_" ^ si (tix t) 

  | _ -> 
    failwith 
    (
      "[cpp_type_classname] Unexpected " ^
      string_of_btypecode syms.dfns t
    )
  with Not_found -> 
    failwith 
    (
      "[cpp_type_classname] Expected type "^ 
      string_of_btypecode syms.dfns t ^ 
      " to be in registry"
    )


let cpp_typename syms t = 
  match unfold syms.dfns (lstrip syms.dfns t) with
  | `BTYP_function _ -> cpp_type_classname syms t ^ "*"
  | `BTYP_cfunction _ -> cpp_type_classname syms t ^ "*"
  (*
  | `BTYP_inst (i,ts) -> 
    begin match
      try
        match Hashtbl.find syms.dfns i with 
        { symdef=symdef } -> Some ( symdef )
      with Not_found -> None
    with
    | Some (`SYMDEF_class ) -> cpp_type_classname syms t ^ "*"
    | _ -> cpp_type_classname syms t
    end
  *)
  | _ -> cpp_type_classname syms t

let cpp_ltypename syms t = 
 cpp_typename syms t ^
 (
   match t with 
   | `BTYP_lvalue _ -> "&"
   | _ -> ""
 )
  


