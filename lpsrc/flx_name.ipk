@h = tangler('src/flx_name.mli')
@select(h)
open Flx_types
open Flx_mtypes2

val cpp_name :
  fully_bound_symbol_table_t ->
  int ->
  string

val cpp_instance_name :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  btypecode_t list ->
  string

val cpp_type_classname :
  sym_state_t ->
  btypecode_t -> 
  string

val cpp_typename :
  sym_state_t ->
  btypecode_t -> 
  string


val cpp_ltypename :
  sym_state_t ->
  btypecode_t -> 
  string


(** mangle a Felix identifier to a C one *)
val cid_of_flxid:  
 string-> string

@h = tangler('src/flx_name.ml')
@select(h)
open Flx_types
open Flx_mtypes2
open Flx_unify
open Flx_print
open Flx_util
open Flx_exceptions
open List

let cvt s = 
  let n = String.length s in
  let id = Buffer.create (n+10) in
  for i=0 to n - 1 do
    match s.[i] with
    | '\'' -> Buffer.add_string id "__p"
    | '\\' -> Buffer.add_string id "__"
    | x -> Buffer.add_char id x
  done;
  Buffer.contents id

let cid_of_flxid s = cvt s

(* mangle a C++ type name into an identifier *)
let mangle_cpp_typename ct =
  let n = String.length ct in
  let buf = Buffer.create (n+20) in
  let tack_ch ch = Buffer.add_char buf ch in
  let tack_str str = Buffer.add_string buf str in
  for i=0 to n - 1 do
    match ct.[i] with
    | '*' -> tack_str "_p"
    | ':' 
    | '<'
    | '>'
    | ' '
    | '?'
    | '$'
    | '@'
    | '#'
    | '`'
      -> tack_ch '_'
    | x -> tack_ch x
  done;
  Buffer.contents buf

(* basic name mangler *)
let cpp_name bbdfns index =
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[cpp_name] Can't find index " ^ si index)
  in
  (match entry with
  | `BBDCL_function _ -> "_f"   
  | `BBDCL_procedure _  -> "_p"
  | `BBDCL_regmatch _  -> "_rm"
  | `BBDCL_reglex _  -> "_rl"
  | `BBDCL_var _ -> "_v"
  | `BBDCL_val _ -> "_v"
  | _ -> syserr sr "cpp_name expected func,proc,var or val"
  ) ^ si index ^ "_" ^ cvt id

let cpp_instance_name syms bbdfns index ts =
  let inst = 
    try Hashtbl.find syms.instances (index,ts) 
    with Not_found -> 
    let id = 
      try 
        let id,parent,sr,entry = Hashtbl.find bbdfns index in id
      with Not_found -> 
      try
        match Hashtbl.find syms.dfns index with
        {id=id} -> id ^ "[unbound]"
      with Not_found -> 
      "unknown"
    in
    let has_variables = 
      fold_left 
      (fun truth t -> truth || var_occurs t)
      false
      ts
    in
    failwith 
    (
      "[cpp_instance_name] unable to find instance " ^ id ^
      "<" ^ si index ^ ">[" ^catmap ", " (string_of_btypecode syms.dfns) ts ^ "]"
      ^ (if has_variables then " .. a subscript contains a type variable" else "")
    )
  in
  "_i" ^ si inst ^ cpp_name bbdfns index 

let rec cpp_type_classname syms t = 
  let registry = syms.registry in
  let t = fold syms.dfns (lstrip syms.dfns t) in
  try match unfold syms.dfns t with
  | `BTYP_var i -> failwith ("[cpp_type_classname] Can't name type variable " ^ si i) 
  | `BTYP_fix i -> failwith "[cpp_type_classname] Can't name type fixpoint"
  | `BTYP_void -> failwith "void doesn't have a classname"
  | `BTYP_tuple [] -> "unit"

  | `BTYP_pointer t' -> 
    "_rt" ^ cpp_type_classname syms t' 

  | `BTYP_function (_,`BTYP_void) -> 
    "_pt" ^ si (Hashtbl.find registry t) 

  | `BTYP_function _ -> 
    "_ft" ^ si (Hashtbl.find registry t)

  | `BTYP_array _ -> 
    "_at" ^ si (Hashtbl.find registry t)

  | `BTYP_tuple _ -> 
    "_tt" ^ si (Hashtbl.find registry t)
  
  | `BTYP_sum _ -> 
    "_st" ^ si (Hashtbl.find registry t)

  | `BTYP_unitsum k -> 
    "_us" ^ si k

    
  | `BTYP_inst (i,_) -> 
    begin try match
      match Hashtbl.find syms.dfns i with 
      { id=id; symdef=symdef } -> id,symdef 
    with
    | id,`SYMDEF_cstruct _ -> id
    | _,`SYMDEF_abs (_,"int",_) -> "int" (* hack .. *)
    | _,`SYMDEF_abs (_,"long",_) -> "long" (* hack .. *)
    | _,`SYMDEF_abs (_,"float",_) -> "float" (* hack .. *)
    | _,`SYMDEF_abs (_,"double",_) -> "double" (* hack .. *)
    | _,data  ->
      let prefix =
        match data with
        | `SYMDEF_struct _  -> "_s"
        | `SYMDEF_union _   -> "_u"
        | `SYMDEF_abs _  -> "_a"
        | _ -> "_unk_"
      in 
        prefix ^ si i ^ "t_" ^ si (Hashtbl.find registry t) 
    with 
    | Not_found -> 
       "_unk_" ^ si i ^ "t_" ^ si (Hashtbl.find registry t) 
    end

  | _ -> 
    failwith 
    (
      "[cpp_type_classname] Unexpected " ^
      string_of_btypecode syms.dfns t
    )
  with Not_found -> 
    failwith 
    (
      "[cpp_type_classname] Expected type "^ 
      string_of_btypecode syms.dfns t ^ 
      " to be in registry"
    )


let cpp_typename syms t = 
  match unfold syms.dfns (lstrip syms.dfns t) with
  | `BTYP_function _ -> cpp_type_classname syms t ^ "*"
  | _ -> cpp_type_classname syms t

let cpp_ltypename syms t = 
 cpp_typename syms t ^
 (
   match t with 
   | `BTYP_lvalue _ -> "&"
   | _ -> ""
 )
  


