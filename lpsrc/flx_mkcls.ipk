@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_mkcls.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_typing
open Flx_mtypes1
open Flx_mtypes2

val make_closures:
  sym_state_t ->
  fully_bound_symbol_table_t  -> unit

@h = tangler("src/flx_mkcls.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_exceptions

let gen_closure syms bbdfns i =
  let j = !(syms.counter) in incr syms.counter;
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_proc (props,vs,ps,c,reqs) ->
    let arg_t = 
      match ps with | [t] -> t | ps -> `BTYP_tuple ps
    in
    let ts = map (fun (_,i) -> `BTYP_var (i,`BTYP_type)) vs in
    let ps,a = 
      let n = !(syms.counter) in incr syms.counter;
      let name = "_a" ^ si n in
      let ventry = `BBDCL_val (vs,arg_t) in
      Hashtbl.add bbdfns n (name,Some j,sr,ventry);
      [name,(n,arg_t)],(`BEXPR_name (n,ts),arg_t)
    in
    
    let exes : bexe_t list = 
      [
        `BEXE_call_prim (sr,i,ts,a); 
        `BEXE_proc_return sr
      ] 
    in
    let entry = `BBDCL_procedure ([],vs,(ps,None),exes) in
    Hashtbl.add bbdfns j (id,parent,sr,entry);
    j

  | `BBDCL_fun (props,vs,ps,ret,c,reqs,_) ->
    let ts = map (fun (_,i) -> `BTYP_var (i,`BTYP_type)) vs in
    let arg_t = 
      match ps with | [t] -> t | ps -> `BTYP_tuple ps
    in
    let ps,a = 
      let n = !(syms.counter) in incr syms.counter;
      let name = "_a" ^ si n in
      let ventry = `BBDCL_val (vs,arg_t) in
      Hashtbl.add bbdfns n (name,Some j,sr,ventry);
      [name,(n,arg_t)],(`BEXPR_name (n,ts),arg_t)
    in
    let e = `BEXPR_apply_prim (i,ts,a),ret in
    let exes : bexe_t list = [`BEXE_fun_return (sr,e)] in
    let entry = `BBDCL_function ([],vs,(ps,None),ret,exes) in
    Hashtbl.add bbdfns j (id,parent,sr,entry);
    j

  | _ -> assert false

  
let mkcls syms bbdfns all_closures i ts =
  let j =
    try Hashtbl.find syms.wrappers i 
    with Not_found -> 
      let j = gen_closure syms bbdfns i in
      Hashtbl.add syms.wrappers i j;
      j
  in 
    all_closures := IntSet.add j !all_closures;
    `BEXPR_closure (j,ts)

let check_prim syms bbdfns all_closures i ts =
  let _,_,_,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_proc _ 
  | `BBDCL_fun _ -> 
    mkcls syms bbdfns all_closures i ts
  | _ -> 
    all_closures := IntSet.add i !all_closures;
    `BEXPR_closure (i,ts)
  
let idt t = t 

let ident x = x 

let rec adj_cls syms bbdfns all_closures e = 
  let adj e = adj_cls syms bbdfns all_closures e in
  match Flx_maps.map_tbexpr ident adj idt e with
  | `BEXPR_closure (i,ts),t -> 
    check_prim syms bbdfns all_closures i ts,t

  (* Direct calls to non-stacked functions require heap
     but not a clone .. 
  *)
  | `BEXPR_apply_direct (i,ts,a),t as x -> 
    all_closures := IntSet.add i !all_closures;
    x

  (* Class method -- ASSUMED NOT A PRIMITIVE -- seem to require
     heap closures: not sure why this should be. They cannot
     be inlined into their parent at the moment, since it is a class,
     and any 'inlined' version would be an actual C++ class method.
     Which would also be a kind of stack call. In any case
     we cannot optimise this yet.
  *)
  | `BEXPR_method_closure (_,i,_),_ as x ->
    all_closures := IntSet.add i !all_closures;
    x

  | x -> x


let process_exe syms bbdfns all_closures (exe : bexe_t) : bexe_t =
  let ue e = adj_cls syms bbdfns all_closures e in 
  match exe with
  | `BEXE_call_prim (sr,i,ts,e2)  -> `BEXE_call_prim (sr,i,ts, ue e2)

  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    all_closures := IntSet.add i !all_closures;
    `BEXE_call_direct (sr,i,ts, ue e2)

  | `BEXE_call_method_direct (sr,e1,i,ts,e2)  -> 
    all_closures := IntSet.add i !all_closures;
    `BEXE_call_method_direct (sr,ue e1,i,ts, ue e2)

  | `BEXE_jump_direct (sr,i,ts,e2)  -> 
    all_closures := IntSet.add i !all_closures;
    `BEXE_jump_direct (sr,i,ts, ue e2)

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    (* stack calls do use closures -- but not heap allocated ones *)
    `BEXE_call_stack (sr,i,ts, ue e2)

  | `BEXE_apply_ctor (sr,i1,i2,ts,i3,e2) ->
    all_closures := IntSet.add i2 !all_closures;
    all_closures := IntSet.add i3 !all_closures;
    `BEXE_apply_ctor(sr,i1,i2,ts,i3,ue e2)

  | `BEXE_call (sr,e1,e2)  -> `BEXE_call (sr,ue e1, ue e2)
  | `BEXE_jump (sr,e1,e2)  -> `BEXE_jump (sr,ue e1, ue e2)
    
  | `BEXE_loop (sr,i,e) -> `BEXE_loop (sr,i, ue e)
  | `BEXE_ifgoto (sr,e,l) -> `BEXE_ifgoto (sr, ue e,l)
  | `BEXE_ifnotgoto (sr,e,l) -> `BEXE_ifnotgoto (sr, ue e,l)
  | `BEXE_fun_return (sr,e) -> `BEXE_fun_return (sr,ue e)

  | `BEXE_init (sr,i,e) -> `BEXE_init (sr,i,ue e)
  | `BEXE_assign (sr,e1,e2) -> `BEXE_assign (sr, ue e1, ue e2)
  | `BEXE_assert (sr,e) -> `BEXE_assert (sr, ue e)

  | `BEXE_svc (sr,i) -> exe

  | `BEXE_label _
  | `BEXE_halt _
  | `BEXE_goto _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_comment _
  | `BEXE_nop _
  | `BEXE_proc_return _
  | `BEXE_begin
  | `BEXE_end
    -> exe

let process_exes syms bbdfns all_closures exes = 
  map (process_exe syms bbdfns all_closures) exes

let process_entry syms bbdfns all_closures i =
  let ue e = adj_cls syms bbdfns all_closures e in 
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    let exes = process_exes syms bbdfns all_closures exes in
    let entry = `BBDCL_function (props,vs,ps,ret,exes) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)
    
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = process_exes syms bbdfns all_closures exes in
    let entry = `BBDCL_procedure (props,vs,ps,exes) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)

  | `BBDCL_glr (props,vs,t,(p,exes)) ->
    let exes = process_exes syms bbdfns all_closures exes in
    let entry = `BBDCL_glr (props,vs,t,(p,exes)) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)

  | `BBDCL_regmatch (props,vs,ps,t,(a,j,h,m)) ->
    Hashtbl.iter (fun i e -> Hashtbl.replace h i (ue e)) h

  | `BBDCL_reglex (props,vs,ps,i,t,(a,j,h,m)) ->
    Hashtbl.iter (fun i e -> Hashtbl.replace h i (ue e)) h

  | _ -> ()

let set_closure bbdfns p i =
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
   match entry with
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    let entry = `BBDCL_function (p :: props,vs,ps,ret,exes) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry);

  | `BBDCL_procedure (props,vs,ps,exes) ->
    let entry = `BBDCL_procedure (p :: props,vs,ps,exes) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)

  | `BBDCL_regmatch (props,vs,ps,t,x) ->
    let entry = `BBDCL_regmatch (p :: props, vs, ps, t, x) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)

  | `BBDCL_reglex (props,vs,ps,le,t,x) ->
    let entry = `BBDCL_reglex (p :: props, vs, ps, le, t, x) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)

  | `BBDCL_glr (props, vs, t, x) -> 
    let entry = `BBDCL_glr (p :: props, vs, t, x) in
    Hashtbl.replace bbdfns i (id,parent,sr,entry)

  | _ -> ()

let make_closures syms bbdfns =
  let used = ref IntSet.empty in
  let all_closures = ref IntSet.empty in
  let uses i = Flx_use.uses syms used bbdfns i in
  IntSet.iter uses !(syms.roots);
  IntSet.iter (process_entry syms bbdfns all_closures ) !used;
  IntSet.iter (set_closure bbdfns `Heap_closure) (IntSet.union !all_closures !(syms.roots));
  
 

