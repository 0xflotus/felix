@import config
@from config.flx_data import flx_keywords, flx_syms, cpp_keywords
@set_title('Felix ' + config.flx_version)

@head(1,'The Felix Compiler')

@select(tangler('src/compiler/flx_backend/flx_backend_config.ml'))
let cpp_keywords = [
@for k in cpp_keywords:
  tangle('  "%s";' % k)
@#
]

@head(1,'Purpose')
Felix is a procedural language designed to implement
ultra lightweight threads. An ultra-lightweight thread
is a thread of control which provides cooperative
multitasking and event driven scheduling. It is designed
to support running millions of threads of control on
multiple processors with low overhead
in context switching achieved by event driven dispatch.
@p()
Target applications include graphical user interfaces,
telephony and other asynchronous signalling systems,
and web and other servers.

@head(1,'Language')
Felix is a powerful C++ code generator which uses
a blend of Pascal, C, C++, and ML syntax in the hope
that the power of the ML system can be provided to
C/C++ programmers, together with control inversion.

@head(1,'The tutorial')
The tutorial is found at
@cite_url('../../tutorial/introduction/en_flx_tutorial_top.html')
@p()
The macro processor now has a separate tutorial at
@cite_url('../../tutorial/macros/en_flx_tut_macro_top.html')
@p()
The binding and embedding system now has a separate tutorial at
@cite_url('../../tutorial/embedding/en_flx_tut_bind_top.html')
@p()
The c and c++ migration now has a separate tutorial at
@cite_url('../../tutorial/migration/en_flx_tut_migrate_top.html')

@head(1,'The Felix Compiler')
Basic phase diagram:
@begin_displayed_code()
  Lexer ->
  Token Filter ->
  Parser ->
  Syntax Macro Processor ->
  Desugaring/Lambda Lifting ->
  Unbound Symbol Table Construction ->
  Lookup/Binding/Use analysis ->
  Optimisation ->
  Code generation
@end_displayed_code()
The lexer generates tokens, which are passed
to the token filter to strip out white spaces
(since these make LR(1) parsing almost impossible
by eating up lookaheads). Any token stream macro
processing will be inserted here. The parser then
builds the Abstract Syntax Treee from the filtered
token stream.
@p()
The syntax macro processor is a basic term calculator
for generating and reducing terms. The macro
processing phase includes constant folding,
with special handling for conditionals so that
conditional compilation of syntactically correct
phrases doesn't require any special syntax.
@p()
Lambda lifting replaces each anonymous function
used in an expressions with a fresh name and
defines the name in some context including
the expression.
@p()
Desugaring includes lambda lifting and a few
other rewrites. For example, the if/then/else/endif
expression is replaced by an equivalent match.
[We want to put this in the library eventually]
@p()
The unbound symbol table is a map from indexes
to symbol definitions, and is a convolution
of the hierarchical input structure of the AST.
Each symbol has a unique index, a link to
its parent context, and each context containing
definitions has a map from names to indexes.
However, the uses of symbols are unbound.
@p()
The binding phase performs lookups on the
types, expressions,  directives, and executable
statements to replace each names with its
index in the symbol table, resulting
in the fully bound symbol table.
@p()
This phase is extremely complex, since the binding
of all components must be done on the unbound symbol
table. Whilst simple lookups present no problem,
functions can be overloaded. This means the type
of an application cannot be determined until the
overload is resolved, which requires typing the
argument of the function, which in turn depends
on overloading.
@p()
In addition, the open directive adds considerable
complication, since in Felix everything in the
same scope is considered to be mutually recursive.
This means the argument of the open directive
requires lookup of the name in a context enriched
by all the other open directives, but the enrichment
requires lookup of the argument of those open
directives.
@p()
Even more complicated: Felix has module expressions,
and so the prefix part of a name doesn't have to
be a module name .. it can be a module expression.
Module expressions include functor applications,
and functors can be overloaded. The argument
type of a functor must be matched to the supplied
module, which requires binding every element of
the interface and and the signatures of the elements
of the module.
@p()
The binding and lookup is driven by a flow analyser
than is iniialised with the root procedure (the
init routine of the top level module) plus any
exported procedures or functions. By chasing
down all calls, it discovers all instances types used
in the program, and all instances of
functions and procedures. An instances is a binding
of a type or function to a list of types, which is
the basic mechanism for generic programming.
@p()
The code generator constructs classes
for each type, function and procedure,
and generates descriptors for each entity
which includes a list of offsets at which
frame object pointers are located so
the garbage collector can operate.
@p()
Finally, the code generator makes C wrappers for
exported functions, and provides initialisation and termination
functions to construct and destroy the
instance frame objects (global, process,
and thread frames at present).

@head(2,'Configuration loader')
There is a separate package "flx_config.pak" which should
be used to create the configuration creator script.
@import traceback
@try:
    import config.flx_data
 except:
    xt,xv,tb = sys.exc_info()
    print "ERROR IN config/flx_data.py"
    traceback.print_exception(xt,xv,tb)
    print "You must either"
    print "(a) edit config/__init__.py and fix the error, or,"
    print "(b) i) delete it, and,"
    print "    ii) run 'python script/make_config.py'"
    print "       again to reset it:"
    print "       this is done automatically by 'make boot'"
    sys.exit(1)


@h=tangler('src/compiler/flx_version_hook/flx_version_hook.ml')
@select(h)
@python("//")
def get_buildno():
  fname = "config/buildno.txt"
  try:
    f = open(fname)
    s = f.readline()
    s = s[0:-1]
    i = int(s) + 1
    f.close()
  except:
    i = 1
  s = str(i)
  try: os.mkdir("config")
  except: pass
  f = open(fname,"w")
  f.write("%d\n" % i)
  f.close()
  return s
//
@import time
@now = time.time()
@gmtime = time.gmtime(now)
@short_time = time.strftime("%a %d %b %Y",gmtime)
@buildno = get_buildno()
@print "BUILDNO",buildno
open Flx_version
let version_data: version_data_t =
{
@tangle('  buildno = '+buildno+";")
@tangle('  version_string = "%s";' % config.flx_version)
@tangle('  build_time_float = %s;' % now)
@tangle('  build_time = "%s";' % time.ctime(now))
@f = open ("VERSION","w")
@f.write(config.flx_version+"\n")
@f.close()
}
;;
let set_version () =
  Flx_version.version_data := version_data
;;

@head(2,'The front end')
@push_head()
@include_file ('flx_pdoc.ipk')
@include_file ('flx_preparser.ipk')
@include_file ('flx_parser.ipk')
@include_file ('flx_tokeniser.ipk')
@include_file ('flx_tcdoc.ipk')
@pop_head()

@head(2,'Stub mainline')
This is a just a file for writing
mini tests of various ocaml functions
of the compiler. I should probably
create a file here for unit tests.
@include_file ('flx_stub.ipk')

@head(2,'Tools')
@include_file ('flx_docgen.ipk')
