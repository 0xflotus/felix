@bc = begin_displayed_code
@ec = end_displayed_code
@flx_version = '1.0.9'
@godi_revision = '0'
@set_title('Felix '+flx_version)
@head(1,'Purpose')
Felix is a procedural language designed to implement
ultra lightweight threads. An ultra-lightweight thread
is a thread of control which provides cooperative
multitasking and event driven scheduling. It is designed
to support running millions of threads of control on
multiple processors with low overhead
in context switching achieved by event driven dispatch.
@p()
Target applications include graphical user interfaces,
telephony and other asynchronous signalling systems,
and web and other servers.

@head(1,'Language')
Felix is a powerful C++ code generator which uses
a blend of Pascal, C, C++, and ML syntax in the hope
that the power of the ML system can be provided to
C/C++ programmers, together with control inversion.

@head(1,'The tutorial')
The tutorial is found at
@cite_url('../tut/doc/en_flx_tutorial_top.html')
@p()
The macro processor now has a separate tutorial at
@cite_url('../tut/doc/en_flx_tut_macro_top.html')
@p()
The binding and embedding system now has a separate tutorial at
@cite_url('../tut/doc/en_flx_tut_bind_top.html')

@head(1,'The Felix Compiler')
Basic phase diagram:
@begin_displayed_code()
  Lexer -> 
  Token Filter ->
  Parser -> 
  Syntax Macro Processor ->
  Desugaring/Lambda Lifting ->
  Unbound Symbol Table Construction ->
  Lookup/Binding/Use analysis ->
  Optimisation ->
  Code generation
@end_displayed_code()
The lexer generates tokens, which are passed
to the token filter to strip out white spaces
(since these make LR(1) parsing almost impossible
by eating up lookaheads). Any token stream macro
processing will be inserted here. The parser then
builds the Abstract Syntax Treee from the filtered
token stream.
@p()
The syntax macro processor is a basic term calculator
for generating and reducing terms. The macro
processing phase includes constant folding,
with special handling for conditionals so that
conditional compilation of syntactically correct
phrases doesn't require any special syntax.
@p()
Lambda lifting replaces each anonymous function
used in an expressions with a fresh name and
defines the name in some context including
the expression.
@p()
Desugaring includes lambda lifting and a few
other rewrites. For example, the if/then/else/endif
expression is replaced by an equivalent match.
[We want to put this in the library eventually]
@p()
The unbound symbol table is a map from indexes
to symbol definitions, and is a convolution
of the hierarchical input structure of the AST.
Each symbol has a unique index, a link to
its parent context, and each context containing
definitions has a map from names to indexes.
However, the uses of symbols are unbound.
@p()
The binding phase performs lookups on the
types, expressions,  directives, and executable
statements to replace each names with its
index in the symbol table, resulting
in the fully bound symbol table.
@p()
This phase is extremely complex, since the binding
of all components must be done on the unbound symbol
table. Whilst simple lookups present no problem,
functions can be overloaded. This means the type
of an application cannot be determined until the
overload is resolved, which requires typing the
argument of the function, which in turn depends
on overloading.
@p()
In addition, the open directive adds considerable
complication, since in Felix everything in the
same scope is considered to be mutually recursive.
This means the argument of the open directive
requires lookup of the name in a context enriched
by all the other open directives, but the enrichment
requires lookup of the argument of those open
directives.
@p()
Even more complicated: Felix has module expressions,
and so the prefix part of a name doesn't have to
be a module name .. it can be a module expression.
Module expressions include functor applications,
and functors can be overloaded. The argument
type of a functor must be matched to the supplied
module, which requires binding every element of
the interface and and the signatures of the elements
of the module.
@p()
The binding and lookup is driven by a flow analyser
than is iniialised with the root procedure (the 
init routine of the top level module) plus any
exported procedures or functions. By chasing
down all calls, it discovers all instances types used
in the program, and all instances of
functions and procedures. An instances is a binding
of a type or function to a list of types, which is
the basic mechanism for generic programming.
@p()
The code generator constructs classes
for each type, function and procedure,
and generates descriptors for each entity
which includes a list of offsets at which
frame object pointers are located so
the garbage collector can operate.
@p()
Finally, the code generator makes C wrappers for 
exported functions, and provides initialisation and termination
functions to construct and destroy the
instance frame objects (global, process,
and thread frames at present).

@head(2,'Configuration loader')
There is a separate package "flx_config.pak" which should
be used to create the configuration creator script.
@try:
    execfile("config/config.py")
 except:
    print "ERROR IN config/config.py"
    print "You must either"
    print "(a) edit config/config.py and fix the error, or,"
    print "(b) i) delete it, and,"
    print "    ii) run 'python script/make_config.py'"
    print "       again to reset it:"
    print "       this is done automatically by 'make boot'"
    sys.exit(1)


@head(2,'Version control')
We need a special hack for version control.
Since every build results in a changed
version control record, we have to put
the record in the last module in the
compiler list to avoid unnecessary compilations.
Unfortunately, that means no modules can reference
it due to a limitation in Ocaml. Therefore,
we make the first module a reference to the version
control data, initialised with a dummy value,
put the real data in the last module, and store
it in the reference when the last module is
initialised. Note that this means the version
information will not be available until
the mainline module begins.

@h=tangler('src/flx_version.mli')
@select(h)
open Flx_types
val version_data: version_data_t ref

@h=tangler('src/flx_version.ml')
@select(h)
open Flx_types
let version_data = ref
{
  version_string = "no version";
  build_time_float = -1.0;
  build_time = "0000-00-00";
  buildno = -1;
}

@h=tangler('src/flx_version_hook.ml')
@select(h)
@python("//")
def get_buildno():
  fname = "config/buildno.txt"
  try:
    f = open(fname)
    s = f.readline()
    s = s[0:-1]
    i = int(s) + 1
    f.close()
  except:
    i = 1
  s = str(i)
  try: os.mkdir("config")
  except: pass
  f = open(fname,"w")
  f.write("%d\n" % i)
  f.close()
  return s
//
@import time
@now = time.time()
@gmtime = time.gmtime(now)
@short_time = time.strftime("%a %d %b %Y",gmtime)
@buildno = get_buildno()
@print "BUILDNO",buildno
open Flx_types
let version_data: version_data_t =
{
@tangle('  buildno = '+buildno+";")
@tangle('  version_string = "'+flx_version+'";')
@tangle('  build_time_float = '+str(now)+";")
@tangle('  build_time = "'+time.ctime(now)+'";')
@f = open ("VERSION","w")
@f.write(flx_version+"\n")
@f.close()
} 
;;
Flx_version.version_data := version_data
;;

@flx_keywords = [
    ["all", "ALL"],
    ["and", "AND"],
    ["as", "AS"],
    ["body", "BODY"],
    ["call", "CALL"],
    ["case", "CASE"],
    ["class", "CLASS"],
    ["code", "CODE"],
    ["comment", "COMMENT_KEYWORD"],
    ["const", "CONST"],
    ["cstruct", "CSTRUCT"],
    ["ctypes", "CTYPES"],
    ["def", "DEF"],
    ["elif", "ELIF"],
    ["else", "ELSE"],
    ["endif", "ENDIF"],
    ["endmatch", "ENDMATCH"],
    ["enum", "ENUM"],
    ["export", "EXPORT"],
    ["forget", "FORGET"],
    ["fork", "FORK"],
    ["functor", "FUNCTOR"],
    ["fun", "FUNCTION"],
    ["goto", "GOTO"],
    ["header", "HEADER"],
    ["ident", "IDENT"],
    ["if", "IF"],
    ["include","INCLUDE"],
    ["incomplete", "INCOMPLETE"],
    ["inf", "INF"],
    ["in", "IN"],
    ["inherit", "INHERIT"],
    ["inline", "INLINE"],
    ["jump", "JUMP"],
    ["let", "LET"],
    ["loop", "LOOP"],
    ["macro", "MACRO"],
    ["match", "MATCH"],
    ["module", "MODULE"],
    ["NaN", "NAN"],
    ["new", "NEW"],
    ["noinline", "NOINLINE"],
    ["not", "NOT"],
    ["obj", "OBJECT"],
    ["of", "OF"],
    ["open","OPEN"],
    ["or", "OR"],
    ["pod", "POD"],
    ["private", "PRIVATE"],
    ["proc", "PROCEDURE"],
    ["public", "PUBLIC"],
    ["publish", "PUBLISH"],
    ["read", "READ"],
    ["regexp", "REGEXP"],
    ["reglex", "REGLEX"],
    ["regmatch", "REGMATCH"],
    ["rename", "RENAME"],
    ["requires", "REQUIRES"],
    ["return", "RETURN"],
    ["set","SET"],
    ["struct", "STRUCT"],
    ["then", "THEN"],
    ["todo", "TODO"],
    ["to", "TO"],
    ["typedef", "TYPEDEF"],
    ["typematch", "TYPEMATCH"],
    ["type", "TYPE"],
    ["union", "UNION"],
    ["use","USE"],
    ["val", "VAL"],
    ["var", "VAR"],
    ["when", "WHEN"],
    ["with", "WITH"],
    ["_", "UNDERSCORE"],
  ]

@tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress" : "void volatile*",
  "caddress" : "void const*",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  "charp"   : "char*",
  "charcp"  : "char const*",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

@if HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"
 else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

@if HAVE_LONGDOUBLE:
   tmap["ldouble"]="long double"
 else:
   tmap["ldouble"]="double"

@if HAVE_LONGLONG:
   tmap["vlong"]="long long"
   tmap["uvlong"]="unsigned long long"
 else:
   tmap["vlong"]="long"
   tmap["uvlong"]="unsigned long"

@if HAVE_STDINT:
   tmap["int8"]="int8_t"
   tmap["uint8"]="uint8_t"
   tmap["int16"]="int16_t"
   tmap["uint16"]="uint16_t"
   tmap["int32"]="int32_t"
   tmap["uint32"]="uint32_t"
   tmap["int64"]="int64_t"
   tmap["uint64"]="uint64_t"
 else:
   tmap["int8"]="signed char"
   tmap["uint8"]="unsigned char"
   sizes = { 
     SIZEOF_SHORT*8 : "short",
     SIZEOF_INT*8: "int",
     SIZEOF_LONG*8 : "long",
   }
   if HAVE_LONGLONG:
     sizes[SIZEOF_LONGLONG*8]="long long"
   for size in [16,32,64]:
     try:
       t = sizes[size]
       tmap["int"+str(size)]=t
       tmap["uint"+str(size)]="unsigned " + t
     except:
       tmap["int"+str(size)]="emul_int"+str(size)
       tmap["uint"+str(size)]="emul_uint"+str(size)

@tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

 
@head(2,'The front end')
@push_head()
@include_file ('flx_util.ipk')
@include_file ('flx_types.ipk')
@include_file ('flx_ctypes.ipk')
@include_file ('flx_frontc.ipk')
@include_file ('flx_cil.ipk')
@include_file ('flx_unify.ipk')
@include_file ('flx_parser.ipk')
@include_file ('flx_string.ipk')
@include_file ('flx_keywords.ipk')
@include_file ('flx_lexer.ipk')
@include_file ('flx_tokeniser.ipk')
@include_file ('flx_pat.ipk')
@include_file ('flx_constfld.ipk')
@include_file ('flx_macro.ipk')
@include_file ('flx_desugar.ipk')
@include_file ('flx_symtab.ipk')
@include_file ('flx_beta.ipk')
@include_file ('flx_treg.ipk')
@include_file ('flx_generic.ipk')
@include_file ('flx_overload.ipk')
@include_file ('flx_lookup.ipk')
@include_file ('flx_mbind.ipk')
@include_file ('flx_bexe.ipk')
@include_file ('flx_bbind.ipk')
@include_file ('flx_label.ipk')
@include_file ('flx_call.ipk')
@include_file ('flx_use.ipk')
@include_file ('flx_useless.ipk')
@include_file ('flx_inline.ipk')
@include_file ('flx_opt4.ipk')
@include_file ('flx_mkcls.ipk')
@include_file ('flx_inst.ipk')
@pop_head()

@head(2,'The back end')
@push_head()
@include_file ('flx_name.ipk')
@include_file ('flx_tgen.ipk')
@include_file ('flx_csubst.ipk')
@include_file ('flx_regexp.ipk')
@include_file ('flx_regen.ipk')
@include_file ('flx_unravel.ipk')
@include_file ('flx_display.ipk')
@include_file ('flx_ogen.ipk')
@include_file ('flx_gen.ipk')
@include_file ('flx_getopt.ipk')
@pop_head()

@head(2,'The Felix Run time')
@include_file ('flx_rtl.ipk')
@include_file ('flx_gc.ipk')
@include_file ('flx_lib.ipk')
@include_file ('flx_lex_lib.ipk')

@head(2,'The Tests')
@include_file ('flx_test.ipk')
@include_file ('flx_regress.ipk')
@include_file ('flx_bagley.ipk')

@head(2,'Stub mainline')
This is a just a file for writing
mini tests of various ocaml functions
of the compiler. I should probably 
create a file here for unit tests.
@include_file ('flx_stub.ipk')

@head(2,'Wrapper generator mainline')
@include_file ('flx_flxcc.ipk')

@head(2,'The Unix Build system')
@include_file ('flx_man.ipk')
@include_file ('flx_maker.ipk')

@head(2,'Misc')
@include_file ('flx_vim.ipk')
@include_file ('flx_highlight.ipk')


