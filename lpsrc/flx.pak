@bc = begin_displayed_code
@ec = end_displayed_code
@set_title('Felix')
@head(1,'Purpose')
Felix is a procedural language designed to implement
ultra lightweight threads. An ultra-lightweight thread
is a thread of control which provides cooperative
multitasking and event driven scheduling. It is designed
to support running millions of threads of control on
multiple processors with low overhead
in context switching achieved by event driven dispatch.
@p()
Target applications include graphical user interfaces,
telephony and other asynchronous signalling systems,
and web and other servers.

@head(1,'Language')
Felix is a powerful C++ code generator which uses
a blend of Pascal, C, C++, and ML syntax in the hope
that the power of the ML system can be provided to
C/C++ programmers, together with control inversion.

@head(2,'Hello World')
We will begin with the customary hello world program:
@h = tangler("test/ex_hello.flx","data")
@select(h)
// include headers
header """
#include <stdio.h>
"""

// define the type string
type string = "char*"; 

# define a procedure to print a string
proc print: string = 'printf("%s", $1);';

/* print the /* string */ */
print "Hello World\n";
@doc()
There are several things to note here. 
First, note that Felix supports three kinds of
comments: C++/shell script style comments
starting with // or # and ending at the end of the line,
and nestable C style comments.
@p()
The next thing to note is that Felix supports a very
wide range of string literals. Strings can be delimited
with either a single or double quote, in which case
they cannot extend beyond the end of the line.

@head(3,'More about string literals')
Strings can also be delimited by Python style triple
quotes, either triple single or double quotes can be used,
in this case, the string may span line boundaries,
the end of line is replaced by a newline character.
@p()
All these string literals also support the
C slosh (\, aka backslash) escapes \a, \t (tab), \n (newline),
\r (return), \v (vtab), \f (formfeed), \b (bell),
and in addition, any punctuation mark can be escaped, including
\\ (slosh), \" (double quote) and \' (single quote).
@p()
In addition, byte values can be encoded numerically
with \xFF, \d999 and \o777 forms, where F is a hex
digit (upper or lower case), 9 is a decimal digit,
and 7 is an octal digit. The 'o' may be omitted in the
octal form for C compatibility, but is strongly
discouraged. In each case, the encoding stops after the
first non-digit of the radix (including end of line), 
the end of the string, or the maximum number of digits required 
to represent the value 255.

@head(3,'International Character set support')
To support international character sets, Felix also provides
two additional escapes: \uFFFF and \UFFFFFFFF which represent
ISO-10646 code points represented as a string of 1 to 6 bytes
in UTF-8 encoding. These escapes must have exactly 4 and 8
hex digits, respectively. Note that UTF-8 encoded values
may be included directly in strings, because Felix string
literals are 8 bit clean. Other encodings are not supported,
but they may work, however they will NOT be 
compatible with the \u and \U escapes.
@p()
Be aware that \x80 is not the same as \u0080, the latter
being a two byte UTF-8 encoding of ISO-10646 code point 128.
@p()
Any departure from the rules for escaping is a fatal error:
Felix is not permissive: any character other than those mentioned
as well defined escapes is reserved for future use of the
implementation.

@head(3,'Trailing whitespace trimming')
There is one more thing to be aware of: Felix trims all
trailing space off the end of a line before processing.
The reason is that Felix, like C, allows a line
to be continued by ending the line with a trailing \
character (anywhere, not just in strings). To avoid
the common error arising when invisible spaces follow
the \, trailing spaces are removed.
@p()
Therefore triple quoted string spanning line ends
will not preserve any trailing spaces --- the only way to
get spaces at the end of a line is to include them before
a newline escape (\n). 

@head(3,'Raw strings')
There is a second form of string literal, one preceded
by an r or R character:
@bc()
  r'a\(b*\)'
  R"Hello"
  r"""Hi
  There"""
@ec()
This form is similar to Python 'raw' strings,
no escapes are supported, instead \ is treated as an ordinary
character. This allows regular expressions to be encoded
more easily.

@head(2,'Dissecting Hello World')
Lets examine the hello world program now.
The line
@bc()
  type string = "char*"; 
@ec()
defines the Felix type string as the C++ type char*.
A type defined by this mechanism is known as a 
primitive type, sometimes called an opaque type
or abstract type. 
@p()
The Felix back end uses the supplied
type declarator when generating C++ code, but otherwise
has no knowledge of any primitive types.
@p()
In order to do some work with the types, we must define
functions and procedures that accept or return them.
The line:
@bc()
  proc print: string = 'printf("%s", $1);';
@ec()
is used to define a primitive procedure, print, 
which outputs its string argument, which is
named '$1'. If the procedure accepts an argument tuple,
then $1, $2, ... $9 denote up to nine components
of the tuple. Note that there are TWO semicolons:
the first one ends the C++ statement, the second
one ends the Felix statement.
@p()
The line:
@bc()
  print "Hello World\n";
@ec()
actually prints the hello world string.
Note that calling a procedure doesn't require
parentheses, as in it does in C.
@p()
Finally, note that the lines:
@bc()
  header """
  #include <stdio.h>
  """
@ec()
do nothing more than cause the back end to emit
the denoted string into the output file,
this is useful for including C++ code in 
Felix code without Felix processing it.
@p()
Be very careful with this feature, since
the string will be emitted roughly where it
is written: the order of emission is guarranteed
to be the same as the order of writing,
but headers included in places other than at the 
top of the Felix file may turn up in inappropriate
places.

@head(2,'A more complex example')
Now we shall write a more complex piece of code.
We will concentrate on establishing a set of
useful primitive types, to demonstrate how to use
the primitive type definition feature, which is
one of the basic ways Felix supports abstraction,
in this case, a notion of abstract types.
@p()
Such definitions are commonly called 'prolog' codes,
since they are written before the main Felix application.
However, they can be written anywhere statements are
allowed, and the names defined are scoped correctly.

@h = tangler('test/ex_2.flx','data')
@select(h)
header """
  #include <string>
  #include <iostream>
  using namespace std;
"""

// bool
type bool = "bool";
const true : bool = "true";
const false : bool = "false";
proc print: bool = 'cout << ($1 ? "true" : "false");';
fun land : bool * bool -> bool = "$1 && $2";
fun lor : bool * bool -> bool = "$1 || $2";
fun not : bool -> bool = "!$1";

// int
type int = "int";
fun add : int * int -> int = "$1+$2";
fun sub : int * int -> int = "$1-$2";
fun mul : int * int -> int = "$1*$2";
fun div : int * int -> int = "$1/$2";
fun mod: int * int -> int = "$1%$2";

// string
type string = "string";
proc print : string = 'cout << $1;';
header """
string strapp(string a, string b) {
  a.append(b); return a;
}
"""
fun add : string * string -> string = "strapp($1,$2)"

proc print_eol : unit = "cout << endl; ";

val x = 1;
val y : int = 2;
val z = x + y - 1 + mul(3,4);
print "Result is"; print z; print_eol ();

@doc()
This example shows a suitable prolog for bool, int,
and string. Note that we have introduced functions.
The type of a function is denoted:
@bc()
  domain -> codomain
@ec()
All functions and procedures accept exactly one argument.
The argument is either a single value, or a tuple.
In the example, print_eol accepts the empty tuple (),
which has builtin type unit. The comma operator is
used to build tuples. Because function and procedure
application has a higher precedence than tuple formation,
it is usual to see tuples enclosed in parentheses like:
@bc()
  (3,4)
@ec()
however, this is a single value of type 
@bc()
  int * int
@ec()
To see that this is really so, you can try this:
@bc()
  val x = (3,4);
  val z = mul x;
@ec()
and z will be 12.
@p()
The next thing to note is that when one writes:
@bc()
  x + y
@ec()
the infix notation is translated by the parser to
@bc()
  add(x, y)
@ec()
so that a function 'add' defines an action of
the infix + operator.
@p()
Notice that I said 'an' rather than 'the'.
Felix supports overloading (mainly to allow
operators to be overloaded). Unlike C++, however,
overload resolution in Felix is always simple:
the types of the arguments must match _exactly_.
@p()
Note that Felix does NOT generally support automatic
conversions: they're not compatible with overloading,
and they tend to obsure the actual semantics of
a program. (There are a few special exceptions to
this rule: one is that a 'function' or 'procedure'
is implicitly converted to a closure).
@p()
Finally, note the 'val' construction, which is used
bind a name to a value: the type may be given,
and if so must agree with the RHS expression type exactly,
otherwise the type is that of the expression. Values
are 'immutable' and cannot be addressed.

@head(3,'Special types')
Actually, Felix does know about four types: string,
int, float, and bool. These types are ascribed
to string, int, float, and bool literals, and these
types must be defined by the client programmer if
literals of these types are used; furthermore,
the C++ constructor for the type must accept a 
C++ char*, int and long, float and double,
or bool value, respectively.
In addition, bool is required in conditionals,
including if and while statements.

@head(4,'String')
It is strongly recommened that a suitable string
class be used for strings (NOT char*, despite
its use in the hello world program), for example
std::basic_string<char> (aka 'string').

@head(4,'Bool')
A suitable declaration of bool is always required, and
C++ bool is the only choice if it is supported,
otherwise an integer value will do. In addition 
the names 'true' and 'false' must be defined in
in Felix and the chosen C++ type must accept the
chosen C++ values of true and false as an 
argument to its constructor. The standard
definition is:
@bc()
  type bool = "bool";
  const true : bool = "true";
  const false : bool = "false";
@ec()
but if your C++ compiler does not yet support
bool, you can use:
@bc()
  type bool = "int";
  const true : bool = "1";
  const false : bool = "0";
@ec()

@head(4,'Float')
A floating type can be chosen as either float,
double, or long double, or some other type
that accepts a double argument (such as a BCD
class type).

@head(4,'Int')
Finally, it is recommended that int be defined
as one of the signed types short, int, long, or long long. 
Felix itself records only 31 bits for integer literals,
(on a 32 bit machine, or 63 bits on a 64 bit machine),
but records millions of digits for long literals.

@head(1,'Implementation')
@head(2,'The Felix Compiler')
@include_file ('flx_types.ipk')
@include_file ('flx_parser.ipk')
@include_file ('flx_string.ipk')
@include_file ('flx_lexer.ipk')
@include_file ('flx_tokeniser.ipk')
@include_file ('flx_pat.ipk')
@include_file ('flx_desugar.ipk')
@include_file ('flx_lookup.ipk')
@include_file ('flx_overload.ipk')
@include_file ('flx_tbind.ipk')
@include_file ('flx_ebind.ipk')
@include_file ('flx_bind.ipk')
@include_file ('flx_mbind.ipk')
@include_file ('flx_bbind.ipk')
@include_file ('flx_name.ipk')
@include_file ('flx_tgen.ipk')
@include_file ('flx_gen.ipk')

@head(2,'The Felix Run time')
@include_file ('flx_lib.ipk')
@include_file ('flx_test.ipk')
@include_file ('flx_regress.ipk')

@head(2,'The Unix Build system')
@include_file ('flx_maker.ipk')

