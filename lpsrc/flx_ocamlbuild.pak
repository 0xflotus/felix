@select(tangler('_tags'))
<{build,speed,test,tmp,tools,tut}>: not_hygienic

@select(tangler('src/compiler/_tags'))
<**/*.ml*>: warn_yzex

@select(tangler('src/compiler/drivers/_tags'))
<*.{byte,native}>: use_nums, use_unix, use_str

@select(tangler('src/compiler/flxlib/_tags'))
<flx_{,pre}parse.dyp>: pv-obj, no-emit-token-type

@select(tangler('src/compiler/dyp/generators/dypgen/_tags'))
<dypgen_parser.dyp>: use_pgen
#<dypgen.{ml,byte,native}>: use_dyplib
#<dypgen_parser.{ml}>: use_dyplib

@select(tangler('src/compiler/dyp/generators/pgen/_tags'))
#<pgen.{ml,byte,native}>: use_dyplib

@select(tangler('src/compiler/dyp/dyplib/dyplib.mllib'))
automaton
dyp
gs
priority_by_relation

@select(tangler('src/compiler/ocs/_tags'))
<ocs_main.{byte,native}>: use_nums, use_unix

@select(tangler('src/compiler/drivers.itarget'))
drivers/flxb.byte
drivers/flxd.byte
drivers/flxg.byte
drivers/flxl.byte
drivers/flxm.byte
drivers/flxp.byte
drivers/stub.byte
drivers/flxcc.byte
drivers/flxb.native
drivers/flxd.native
drivers/flxg.native
drivers/flxl.native
drivers/flxm.native
drivers/flxp.native
drivers/stub.native
drivers/flxcc.native

@select(tangler('myocamlbuild.ml'))
open Ocamlbuild_plugin;;
open Ocamlbuild_pack;;
open Ocamlbuild_pack.Hygiene;;
open Command;;


(* set up the ocamlbuild search paths for the subdirectories *)
Pathname.define_context "src/compiler/dyp/generators/pgen" [ "src/compiler/dyp/dyplib" ];;
Pathname.define_context "src/compiler/dyp/generators/dypgen" [ "src/compiler/dyp/dyplib" ];;
Pathname.define_context "src/compiler/sex" [ "src/compiler/ocs"; "src/compiler/dyp/dyplib" ];;
Pathname.define_context "src/compiler/flxcclib" [ "src/compiler/cil" ];;
Pathname.define_context "src/compiler/flx_version_hook" [ "src/compiler/flx_version" ];;

Pathname.define_context "src/compiler/flxlib" [
  "src/compiler/flx_version";
  "src/compiler/cil";
  "src/compiler/dyp/dyplib";
  "src/compiler/flxcclib";
  "src/compiler/flx_version";
  "src/compiler/misclib";
  "src/compiler/ocs";
  "src/compiler/sex";
];;

Pathname.define_context "src/compiler/drivers" [
  "src/compiler/flx_version";
  "src/compiler/cil";
  "src/compiler/dyp/dyplib";
  "src/compiler/flxlib";
  "src/compiler/flxcclib";
  "src/compiler/flx_version";
  "src/compiler/ocs";
  "src/compiler/flx_version_hook";
];;


(* declare all of our libraries *)
ocaml_lib ~dir:"src/compiler/dyp/dyplib"       "src/compiler/dyp/dyplib/dyplib";;
ocaml_lib ~dir:"src/compiler/ocs"              "src/compiler/ocs/ocslib";;
ocaml_lib ~dir:"src/compiler/sex"              "src/compiler/sex/sexlib";;
ocaml_lib ~dir:"src/compiler/cil"              "src/compiler/cil/cillib";;
ocaml_lib ~dir:"src/compiler/misclib"          "src/compiler/misclib/misclib";;
ocaml_lib ~dir:"src/compiler/flx_version"      "src/compiler/flx_version/flx_version";;
ocaml_lib ~dir:"src/compiler/flx_version_hook" "src/compiler/flx_version_hook/flx_version_hook";;
ocaml_lib ~dir:"src/compiler/flxcclib"         "src/compiler/flxcclib/flxcclib";;
ocaml_lib ~dir:"src/compiler/flxlib"           "src/compiler/flxlib/flxlib";;


(* declare the extra tags *)
flag ["ocaml"; "parser"; "dypgen"; "pv-obj"] (A"--pv-obj");;
flag ["ocaml"; "parser"; "dypgen"; "no-emit-token-type"] (A"--noemit-token-type");;
flag ["ocaml"; "compile"; "warn_yzex"] (S[A"-w"; A"yzex"]);;


let laws =
  [
    { law_name = "Leftover dypgen-generated files";
    law_rules = [Implies_not(".dyp",".ml"); Implies_not(".dyp",".mli")];
    law_penalty = Fail }
  ]
;;


dispatch begin function
  | Before_rules ->
      begin
        let evil = ref false in
        match !Options.entry with
        | None -> ();
        | Some entry ->
            match check
              ?sanitize:
                begin
                  if !Options.sanitize then
                    Some(!Options.sanitization_script)
                  else
                    None
                end
              laws entry
            with
            | [] -> ()
            | stuff ->
                List.iter
                begin fun (law, msgs) ->
                  Printf.printf "%s: %s:\n"
                  (match law.law_penalty with
                  | Warn -> "Warning"
                  | Fail ->
                      if not !evil then
                        begin
                          Printf.printf "IMPORTANT: I cannot work with leftover compiled files.\n%!";
                          evil := true;
                        end;
                        "ERROR")
                  law.law_name;
                  List.iter (Printf.printf "  %s\n") msgs
                end
                stuff;
                if !evil then raise Fda.Exit_hygiene_failed;
      end

  | After_rules ->
      rule "dypgen: .dyp -> .ml & .mli"
        ~deps:["%.dyp"]
        ~prods:["%.ml"; "%.mli"]
        begin fun env build ->
          let dyp = env "%.dyp" in
          let tags = tags_of_pathname dyp++"ocaml"++"parser" in

          (* Since pgen and dypgen programs use the same extension, we need
           * to be able to switch between the two. Do this by tagging the pgen
           * files with "use_pgen".
           * I'm not sure how we should do byte/native, so we'll just use the
           * native. *)
          let dypgen, tags =
            if Tags.mem "use_pgen" tags
            then "src/compiler/dyp/generators/pgen/pgen.native", tags++"pgen"
            else "src/compiler/dyp/generators/dypgen/dypgen.native", tags++"dypgen"
          in

          (* try to build the parser if it doesn't exist yet *)
          List.iter Outcome.ignore_good (build [[dypgen]]);

          Cmd(S[A dypgen; T tags; Px dyp])
        end;
  | _ -> ()
end;;
