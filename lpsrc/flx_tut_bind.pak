@set_title('Felix Tutorial: Embedding')
@tdir = 'tut/examples/'

@h = tangler('spkgs/flx_tut_bind.py')
@select(h)
TESTS = glob.glob('tut'+os.sep+'examples'+os.sep+'tut_bind*.flx')

unit_tests = TESTS
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','faio']
iscr_source = [ 'lpsrc/flx_tut_bind.pak' ]
weaver_directory = 'doc/tutorial/embedding/'

@head(1,'Embedding')
Felix is designed to integrate smoothly with C and C++.

@head(2,'Basic Bindings')
In the previous examples, we've use the Felix standard
library. It's time to look at how it works.
@p()
The Felix language is somewhat novel in that there
are no primitive data types, not even bool.
Instead, Felix uses binding definitions to declare
abstract primitive data types, and bind them to
concrete C++ data type.
@p()
Here is an example of a binding. 
@select(tangler(tdir+'tut_bind130.flx'))
#import <flx.flxh>
header """
// This is C++ code!
class gauss;

struct gauss {
  int x;
  int y;

  gauss() : x(0), y(0) {}
  gauss(int _x, int _y) : x(_x), y(_y) {}

  gauss operator +(gauss z) const 
  {
    return gauss(x+z.x, y+z.y);
  }
  gauss operator *(gauss z) const
  {
    return gauss (x *z.x - y*z.y, x*z.y + y*z.x);
  }
};
""";

// Now the Felix binding
type gauss = "gauss";
proc _set : &gauss * gauss = "*$1 = $2;";
fun add: gauss * gauss -> gauss = "$1 + $2";
fun mul: gauss * gauss -> gauss = "$1 * $2";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";
fun real: gauss -> int = "$1.x";
fun imag: gauss -> int = "$1.y";

// Now a pure Felix procedure
proc gprint(z:gauss) { 
  print "(";
  print (real z);
  print ", ";
  print (imag z);
  print ")";
}

// And two pure Felix functions
fun sqr(z:gauss):gauss = {
  return z * z;
}

fun norm(z:gauss): int = {
  return 
    real z * real z + imag z * imag z
  ;
}

// Finally, some test code
val z1 = mkgauss(1,2);
val z2 = z1 + z1;
val z3 = sqr z2;
val n = norm z3;
gprint z1; endl;
gprint z2; endl;
gprint z3; endl;
print n; endl;

@doc()
There are lots of things to note here.
@p()
First, the header statement

@begin_displayed_code()
  header """ .... """;
@end_displayed_code()

specifies text to
be emitted literally in the generated C++ header file:
note the trailing semicolon.
In this case, we emit a C++ class defining
a basic gaussian integer type. There is also a 
'body' keyword to literally emit code in the
generated implementation (body) file.
@p()
Next, we define the felix type gauss.

@begin_displayed_code()
  type gauss = "gauss";
@end_displayed_code()

The definition specifies the Felix name, gauss,
and then the C++ name, which also happens to be
gauss.
@p()
Then we define the semantics of our new primitive
by primitive functions and procedures which allow
us to manipulate it. Theses consists of a function
or procedure name, a type, and the C++ code to
generate when the function or procedure is called.

@begin_displayed_code()
proc _set : &gauss * gauss = "*$1 = $2;";
fun add: gauss * gauss -> gauss = "$1 + $2";
fun mul: gauss * gauss -> gauss = "$1 * $2";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";
fun real: gauss -> int = "$1.x";
fun imag: gauss -> int = "$1.y";
@end_displayed_code()

In the definition string, $1 means the first argument
of the argument tuple, and $2 means the second, etc.
@p()
If the type of an argument component is prefixed
by a &, this means that a pointer is passed.
@p()
You should note that there is a predefined
correspondence between Felix operators and certain
function or procedure names. The ones we have
used here are:
@begin_displayed_code()
  Operator  Name
  =         set
  +         add
  *         mul
  ==        eq
@end_displayed_code()
@p()
Finally, note carefully that functions bind to C++
expressions, whilst procedures bind to C++ statements.
This is why the set procedure binding contains
a ; inside the string, as well as after it.
You can use a compound statement as well.

@head(2,'Seamless Binding')
Felix purports to support a property called seamless binding.
What this means is that the boundary between C++ and Felix
code is fluid. To illustrate this, lets consider
a version of the above code written entirely in Felix.

@select(tangler(tdir+'tut_bind131.flx'))
#import <flx.flxh>
struct gauss = {
  x : int;
  y : int;
}

proc _set ( lhs: &gauss, rhs: gauss )
{
  (*lhs).x = rhs.x;
  (*lhs).y = rhs.y;
}

fun add (a:gauss, b:gauss): gauss = {
  return gauss(a.x+b.x, a.y+b.y);
}

fun mul (a:gauss, b:gauss): gauss = {
  return gauss(a.x+b.x - a.y+b.y, a.x*b.y + a.y*b.x);
}

fun mkgauss (a:int,b:int):gauss = { return gauss(a,b); }
fun real (z:gauss):int = { return z.x; } 
fun imag (z:gauss):int = { return z.y; }

proc gprint(z:gauss) { 
  print "(";
  print (real z);
  print ", ";
  print (imag z);
  print ")";
}

fun sqr(z:gauss):gauss = {
  return z * z;
}

fun norm(z:gauss): int = {
  return 
    real z * real z + imag z * imag z
  ;
}

val z1 = mkgauss(1,2);
val z2 = z1 + z1;
val z3 = sqr z2;
val n = norm z3;
gprint z1; endl;
gprint z2; endl;
gprint z3; endl;
print n; endl;

@doc()
The difference between these two programs is that
in the second one, gauss is a concrete 
non-primitive Felix data type.
In the first program, gauss is an abstract 
data type, together with a binding specifying
the semantics in C++.
@p()
As you can guess, the whole of the program
could have been written in C++ rather than 
Felix.
@p()
It's up to you to choose what parts of your Felix
program are written directly in C++, and which parts
are written in Felix: since Felix is a C++ code generator,
it all ends up as C++ anyhow.
@p()
Usually, you'll write Felix, except when you have 
an existing code base containing useful types
you need to work with. 

@head(2,'Binding Shortcuts')
For your convenience, the ctypes declaration
allows multiple type bindings to be defined
at once. Each Felix name must also be a c identifier
representing a type in C.

@select(tangler(tdir+'tut_bind131a.flx'))
header "#include <cstdio>";
ctypes int, long;
proc print:int = 'printf("%d\\n",$1);';
print 1;
print 2;

@head(2,'Embedding C++')
We have seen that we can use binding definitions to
embed C++ constants, expressions, and procedures
into Felix code, and we can use the 
@begin_code()
header
@end_code()
statement
to embed header text in the header (.hpp) file generated by Felix.
@p()
You can also use the 
@begin_code()
body
@end_code()
statement to embed C++ definitons
in the body file Felix generates. Header text is concatenated
and emitted in the header file after Felix standard definitions
but before any bindings, and so is often used to 
embed include directives.
@p()
Body code is also collected and emitted at the top of 
the body (.cpp) file.
@p()
It is also possible to use the
@begin_code()
code
@end_code()
statement to embed statements directly in procedures.
This is much the same as the body statement, except
that it is an executable Felix statement, and is emitted
in the place it is written.
For example:
@select(tangler(tdir+'tut_bind132.flx'))
#import <flx.flxh>
header "#include<stdio.h>";
print 1; endl;
code 'printf("%d\\n",2);';
print 3; endl;


@head(2,'Operator dot')
It may look as if Felix knows how to access
the components of a Felix struct value using
operator dot. Strangely enough, this is not the
case! When you write:
@begin_displayed_code()
  expr.name
@end_displayed_code()
in a value context, it is translated to the
function application:
@begin_displayed_code()
  get_name expr
@end_displayed_code()
To illustrate this is really the case,
consider the following example.

@select(tangler(tdir+'tut_bind133.flx'))
#import <flx.flxh>

// part 1
header """
struct gauss 
{ 
  int x; 
  int y; 
  gauss() : x(0), y(0) {}
  gauss(int _x, int _y) : x(_x), y(_y) {}

};
""";

type gauss = "gauss";
fun get_x: gauss -> int = "$1.x";
fun get_y: gauss -> int = "$1.y";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";

val z = mkgauss(1,2);
print z.x;
print ", ";
print z.y;
endl;

// part 2
struct X {
  x : int;
}
val i = X(1);
print (get_x i);
endl;

@doc()
In part 1, the functions get_x and get_y
are defined by binding, but the dot notation
is used to call them.
@p()
In part 2, the functions get_x and get_y are
defined by defining a struct, and they're
called directly, without the dot notation.
@p()
The dot notation is just syntactic sugar for
calling a get function.
@p()
What is more, the struct definition is just
syntactic sugar for defining an abstract type
with some get functions (as well as a 
constructor).
@p()
What this means is that for an arbitrary C++ type,
you can create an abstract binding, and define
get methods which can be called using dot notation.
Just name the methods 'get_' something.
@p()
It is also possible to access a Felix struct from
C++, although we'll defer disucssion of the C++
representation of Felix data structures until later.
[The C++ name of the struct type is not the same
as the Felix name]

@head(2,'Generic primitive bindings')
Felix provides a way of creating generic primitive bindings.
A generic binding is a binding to a family of C++ types,
functions, or procedured, parameterised by one or more
types. Generic bindings are roughly equivalent to 
templates, and can be used to bind to templates, 
although that isn't the only use.
@p()
Here is a simple example illustrating
generic primitive bindings.
@select(tangler(tdir+'tut_bind134.flx'))

// include STL vector template
header """
#include <iostream>
#include <vector>
""";

// declare non-generic primitives int and long
// and some output procedures
type int = "int";
type long = "long";
proc endl:1= "std::cout << std::endl;";
proc print: long = "std::cout << $1;";

// define a generic cast
// here ?2 means the second generic type parameter

fun cast[t1,t2]:t1->t2 = "(?2)($1)";
print (cast [int,long] 1); endl;

// declare generic binding for vector
// ?1 is replaced by the first type argument
// when the type vector is instantiated
// the name t is a placeholder used for consistency

type vector[t] = "std::vector<?1>";

// declare print routine for vector
// notice that the type 'vector t'
// describes a vector of objects 
// of type t, the type of the generic parameter
// 
// in a type expression, the generic type vector
// is used 'as a function' and applied to the
// its argument, the parameter t in this case,
// with the same syntax

proc vprint[t]: vector[t] = """
  { 
    std::vector<?1> v = $1;
    for(
      std::vector<?1>::iterator p = v.begin();
      p != v.end();
      ++p
    )
      std::cout << *p << " ";
  }
""";

// a generic procedure for appending to a vector
// this procedure takes a pointer to a vector of t
// and a value of type t and appends the value
// to the vector
proc append[t]:&(vector[t])*t="$1->push_back($2);";

// make an empty vector of int
var v : vector[int];

// put 1,2,3 into the vector
append[int](&v,1);
append[int](&v,2);
append[int](&v,3);

// print the vector
vprint[int] v; endl();

@head(2,'Header and body tags')
Header and body statements may include tag names
which can be refered to in requires clauses of
binding definitions.
@p()
Tagged bodies and headers
are only emitted if a used primitive type, constant,
function or procedure requires them.
@p()
Untagged headers and bodies are tagged with the 
synthesised name _root.
Every primitive function, procedure, type, or constant
requires all visible untagged headers and bodies, that is,
they all implicitly require _root.
@p()
Root requirements are inherited: each untagged header
or body requires its parents _root (if it has one).
@p()
The effect is that if no primitives are used, no
header or body code will be generated. If you really
need to unconditionally force execution of
some C code, you should be using the 'code' primitive.
Header and body statements are intended for declarations
and definitions.
@p()
The same tag can be used on more than one code insertion
statements: this is typically useful on a header-body pair.

@select(tangler(tdir+'tut_bind135.flx'))
body "#include <stdio.h>";
body xprint = "void printx(char *fmt, char *s) { printf(fmt,s);}";
body printu = 'void print(char *s) { printx("%s\\n",s); }';

proc hello:1='print("Hello");' requires xprint, printu;
hello;

@doc()
Header and body statements can also have requirements.
We can reorganise the previous example using this fact.

@select(tangler(tdir+'tut_bind136.flx'))
body "#include <stdio.h>";
body xprint = "void printx(char *fmt, char *s) { printf(fmt,s);}";
body printu = 'void print(char *s) { printx("%s\\n",s); }' 
  requires xprint;

proc hello:1='print("Hello");' requires printu;
hello;

@doc()
Naked requires clauses can also be used.
They can define dependencies, or simply specify
existing tagged requirements are roots.

@select(tangler(tdir+'tut_bind137.flx'))
body "#include <stdio.h>";
body xprint = "void printx(char *fmt, char *s) { printf(fmt,s);}";
body printu = 'void print(char *s) { printx("%s\\n",s); }';
requires xprint;
xxxx requires printu;

proc hello:1='print("Hello");' requires xxxx;
hello;

@doc()
You can also use qualified names to refer to tags defined
inside modules, unless they're marked private of course.

@select(tangler(tdir+'tut_bind138.flx'))
body "#include <stdio.h>";
body xprint = "void printx(char *fmt, char *s) { printf(fmt,s);}";
module fred {
  body printu = 'void print(char *s) { printx("%s\\n",s); }';
}
requires xprint;

proc hello:1='print("Hello");' requires fred::printu;
hello;

@doc()
The next example demonstrates untagged bodies at work.
@select(tangler(tdir+'tut_bind138a.flx'))
#import <flx.flxh>

body top = 'int ptop() { printf("TOP\\n"); return 1; }';
body 'int top = ptop();' requires top;

proc f() {
  body pf = 'int pf(){ printf("f used\\n"); return 1;}';
  body 'int x = pf();' requires pf;
  print "Using f"; endl; 
}

module A {
  body p = 'int p() { printf("A will be used\\n"); return 1;}';
  body 'int y = p();' requires p;
  proc f: unit = 'printf("A is used\\n");';
}

module B {
  body p = 'int p() { printf("B will be used\\n"); return 1;}';
  body 'int y = p();' requires p;
  proc f: unit = 'printf("B is used\\n");';
}

A::f(); 
print "Done"; endl;
// B is not used .. (would cause y,p to be defined twice)

@doc()
Here you can see that insertions can be given
literally too:
@select(tangler(tdir+'tut_bind138b.flx'))

proc f: 1 = 'printf("A is used\\n");'
  requires header '#include <stdio.h>';

f();

@doc()
Here's an example demonstrating polymorphic insertions.
@select(tangler(tdir+'tut_bind138c.flx'))
pod type int="int";
pod type double="double";

body prb[t] = "void pr(?1 x) { std::cout << x << std::endl; }"
  requires header "#include <iostream>";

proc pr[t]:t = "pr($1);" requires prb[t];
pr 1; pr 1.1;

@head(2,'cstruct declaration')
The cstruct keyword can be used like struct,
and has the same effect, except that no struct
is actually generated by Felix, instead, the nominated struct
is assumed to be defined in embedded C/C++ header
code somewhere.
@select(tangler(tdir+'tut_bind150.flx'))
#import <flx.flxh>

header """
struct X { int a; int b; };
""";
body """
X rev(X x) { X y; y.a=x.b; y.b=x.a; return y; }
""";

cstruct X { a: int; b: int; };
fun rev: X -> X = "rev($a)";
val x:X = X(1,2);
print x.a; print " "; print x.b; endl;
val y:X = rev x;
print y.a; print " "; print y.b; endl;

@head(2,'bodyless fun, proc, const declarations')
It is allowed to omit the C definition of
primitive functions, procedures, and constants.
Felix will generate the body for a function
or procedure to call the C function or procedure
with the same name and given arguments,
and a const will refer to a C entity of the
same name.

@select(tangler(tdir+'tut_bind151.flx'))
#import <flx.flxh>

body """
int n = 3;
void ff() { n++; }
int g(int a) { return a * a; }
#define N 4
""";

proc ff: unit;
fun g: int-> int;
const n:int;
const N:int;

print n; endl;
ff();  print n; endl;
print N; endl;
print (g N); endl;

@head(2,'Binding Classes')
C++ classes are bound using the cclass construction.

@select(tangler(tdir+'tut_bind160.flx'))
#import <flx.flxh>
open Long;

header """#include <stdio.h>""";

header """ 
struct Y { 
  int c;
  int x; 
  long y;
  Y() : c(-1) {}
  Y(int _x) : c(-50), x(_x) {}
  int h()const { return x + y + c; }
  int f(int z)const { return z + x + y; }
  int g(int z,int a)const { return z + x + y+a; }

  void setx(int _x){ x= _x;}
  void setxy(int _x, long _y) {x = _x; y= _y;}
  void yprint() { printf("Y=%d,%ld\\n",x,y); }
}; 
""";

cclass Y {
  val c : int;
  var x : int;
  var y : long;
  fun h: unit -> int;
  fun f: int -> int;
  fun g: int * int -> int;
  proc setx: int;
  proc setxy: int * long;
  proc yprint: unit;
  proc setc: int = "$1->c = $2;";
  ctor : unit;
  ctor : int;
};

var b = Y(99);
b.x = 2;
b.y = 3L;
print b.c; endl;
print b.x; endl;
print b.y; endl;

print$ b.f 100; endl;
print$ b.g$ 100,1000; endl;
b.yprint ();

b.setx 20;
print b.x; endl;
print b.y; endl;

b.setxy$ 20,42L;
b.setc 10000;
print b.x; endl;
print b.y; endl;

print$ b.h (); endl;
print$ b.f 100; endl;
print$ b.g$ 100,1000; endl;

anEff := b.f;
print$ anEff 100; endl;

header """
template <class T> 
struct V
{ 
  T x; 
  T get()const { return x; }
  void sset(T _x) { x = _x; }
};
""";

cclass V[t] {
  fun get: unit -> t;
  proc sset: t;
  ctor : unit;
};

v := V[int]();

v.sset 1;
print (v.get ()); endl;

header """
template<class T> struct X { T x; };
""";

cstruct X[t] { x : t; }
xx := X(1);
print$ xx.x; endl;


header """
struct Z {
  template<class T> T sum(T a, T b)const { return a + b; }
};
""";

cclass Z {
  fun sum[t]: t * t -> t;
  ctor : unit;
};

var z  = Z();
print$ z.sum[int] (12,13); endl; // 25

@head(2,'Callbacks')
@select(tangler(tdir+'tut_bind180.flx'))
#import <flx.flxh>

callback fun f: int * f -> int;

fun g(x:int)=> x + x + 1;

print$ f(2, the g); endl;

callback proc p: int * p;

proc q(x:int){ print x; endl; }

p(31,the q);

typedef cf = int --> int;

proc h(y:cf, x:int) {
  print$ y x; endl;
}

body """
  int yyy(int x) { return x + 3; }
""";

const yyy: int --> int;

h(yyy,2);


@head(2,"tut/examples/tut_bind130.expect")
@select(tangler("tut/examples/tut_bind130.expect","data"))
(1, 2)
(2, 4)
(-12, 16)
400
@head(2,"tut/examples/tut_bind131.expect")
@select(tangler("tut/examples/tut_bind131.expect","data"))
(1, 2)
(2, 4)
(4, 16)
272
@head(2,"tut/examples/tut_bind131a.expect")
@select(tangler("tut/examples/tut_bind131a.expect","data"))
1
2
@head(2,"tut/examples/tut_bind132.expect")
@select(tangler("tut/examples/tut_bind132.expect","data"))
1
2
3
@head(2,"tut/examples/tut_bind133.expect")
@select(tangler("tut/examples/tut_bind133.expect","data"))
1, 2
1
@head(2,"tut/examples/tut_bind134.expect")
@select(tangler("tut/examples/tut_bind134.expect","data"))
1
1 2 3 
@head(2,"tut/examples/tut_bind135.expect")
@select(tangler("tut/examples/tut_bind135.expect","data"))
Hello
@head(2,"tut/examples/tut_bind136.expect")
@select(tangler("tut/examples/tut_bind136.expect","data"))
Hello
@head(2,"tut/examples/tut_bind137.expect")
@select(tangler("tut/examples/tut_bind137.expect","data"))
Hello
@head(2,"tut/examples/tut_bind138.expect")
@select(tangler("tut/examples/tut_bind138.expect","data"))
Hello
@head(2,"tut/examples/tut_bind138a.expect")
@select(tangler("tut/examples/tut_bind138a.expect","data"))
TOP
A will be used
A is used
Done
@head(2,"tut/examples/tut_bind138b.expect")
@select(tangler("tut/examples/tut_bind138b.expect","data"))
A is used
@head(2,"tut/examples/tut_bind138c.expect")
@select(tangler("tut/examples/tut_bind138c.expect","data"))
1
1.1
@head(2,"tut/examples/tut_bind150.expect")
@select(tangler("tut/examples/tut_bind150.expect","data"))
1 2
2 1
@head(2,"tut/examples/tut_bind151.expect")
@select(tangler("tut/examples/tut_bind151.expect","data"))
3
4
4
16
@head(2,"tut/examples/tut_bind160.expect")
@select(tangler("tut/examples/tut_bind160.expect","data"))
-50
2
3
105
1105
Y=2,3
20
3
20
42
10062
162
1162
162
1
1
25
@head(2,"tut/examples/tut_bind180.expect")
@select(tangler("tut/examples/tut_bind180.expect","data"))
5
31
5
@#
