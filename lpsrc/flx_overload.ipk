@head(1,"Overloading")
Name binding, pass 1.

@h = tangler("src/flx_overload.mli")
@select(h)
open Flx_types
val resolve_overload:
  symbol_table_t ->
  bound_symbol_table_t ->
  int list ->  
  id_t -> 
  btypecode_t ->
  int option

@h = tangler("src/flx_overload.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List

let rec resolve_overload dfns bdfns fs name (suf : btypecode_t) =
  let typlist params = List.map snd params in
  let paramtype params = typeoflist (typlist params)
  in let fun_defs = List.map
    (fun i ->
      match Hashtbl.find bdfns i with
      | (_,_,(BDCL_function (ps,t,_,_,_))) -> i,paramtype ps
      | (_,_,(BDCL_lazy (_,_))) -> i,BTYP_tuple []
      | (_,_,(BDCL_match_check (_,_,_))) ->
        i,BTYP_tuple []

      | (_,_,(BDCL_match_handler (_,_,_,_,_,_))) ->
        i,BTYP_tuple[]

      | (_,_,(BDCL_fun (ps,t,_))) -> i,typeoflist ps
      | (_,_,(BDCL_procedure (ps,_,_,_))) -> i,paramtype ps
      | (_,_,(BDCL_proc (ps,_))) -> i,typeoflist ps
      | _ -> 
        failwith (
          "[resolve_overload] Expected "^
          name
          ^" to be function or procedure"
        )
    )
    fs
  in match List.filter 
    (fun (i,ps) -> ps = suf) 
    fun_defs
  with 
  | [i,_] -> Some i
  | [] -> None
  | _ -> failwith ("Too many candidates match in overloading " ^ name)
  

