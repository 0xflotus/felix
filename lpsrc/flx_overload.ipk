@head(1,"Overloading")
Name binding, pass 1.

@h = tangler("src/flx_overload.mli")
@select(h)
open Flx_types
val resolve_overload:
  symbol_table_t ->
  bound_symbol_table_t ->
  entry_kind_t list ->  
  id_t -> 
  btypecode_t ->
  entry_kind_t option

@h = tangler("src/flx_overload.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List

let rec lift t = match t with
  | BTYP_binding (i,t) -> BTYP_name i
  | BTYP_pointer t -> BTYP_pointer (lift t)
  | BTYP_tuple ts -> BTYP_tuple (List.map lift ts)
  | BTYP_none -> BTYP_none
  | BTYP_void -> BTYP_void
  | BTYP_function (a,b) -> BTYP_function (lift a, lift b)
  | BTYP_name i -> BTYP_name i

type result = 
  | Unique of int * btypecode_t
  | Pair of (int * btypecode_t) * int

let rec resolve_overload dfns bdfns fs name (suf : btypecode_t) =
  let typlist params = List.map snd params in
  let paramtype params = typeoflist (typlist params) in 
  let rec resolve i =
    match Hashtbl.find bdfns i with
    | (_,_,(BDCL_function (ps,t,_,_,_))) -> i,paramtype ps
    | (_,_,(BDCL_lazy (_,_))) -> i,BTYP_tuple []
    | (_,_,(BDCL_match_check (_,_,_))) ->
      i,BTYP_tuple []

    | (_,_,(BDCL_match_handler (_,_,_,_,_,_))) ->
      i,BTYP_tuple[]
    | (_,_,(BDCL_if_fun (t,_))) -> 
      begin match t with
      | BTYP_function (a,r) -> i,a
      | _ -> failwith "[resolve overload] Expected function to have function type"
      end
    | (_,_,(BDCL_if_proc (_,t,_))) -> i,t
    
    | (_,_,(BDCL_fun (ps,t,_))) -> i,typeoflist ps
    | (_,_,(BDCL_procedure (ps,_,_,_))) -> i,paramtype ps
    | (_,_,(BDCL_proc (ps,_))) -> i,typeoflist ps
    | (_,_,(BDCL_binding (src,dst))) ->
      print_endline "Found binding, recursing ..";
      resolve src 
    | (_,_,bdcl) -> 
      failwith (
        "[resolve_overload] Expected "^
        name
        ^" to be function or procedure, got " ^
       string_of_bdcl dfns 0 i bdcl 
      )
  in
  let rec aux i =  
    match i with
    | Simple i -> 
      let i,t = resolve i in
      Unique (i,t)
    | Bound (i,j) ->
      let i,t = resolve i in
      Pair ((i,t),j)
  in
  let fun_defs = List.map aux fs in
  match 
    let lift_suf = lift suf in
    List.filter 
    (fun result -> match result with
      | Unique (_,t) 
      | Pair ((_,t),_) -> 
        lift t = lift_suf
    ) 
    fun_defs
  with 
  | [Unique (i,_)] -> 
    (*
    print_endline ("..resolved to basic function " ^ string_of_int i); 
    *)
    Some (Simple i)

  | [Pair ((i,_),j)] ->
    (*
    print_endline (
      "..resolved to binding " ^ string_of_int i ^
      " ==> " ^ string_of_int j
    ); 
    *)
    Some (Bound (i,j))

  | [] -> None

  | _ -> failwith ("Too many candidates match in overloading " ^ name)
  

