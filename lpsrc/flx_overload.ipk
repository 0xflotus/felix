@head(1,"overload resolution")
@h = tangler("src/flx_overload.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2

val overload:
  sym_state_t -> 
  (range_srcref  -> int -> typecode_t -> btypecode_t) ->
  range_srcref ->
  entry_kind_t list ->
  string ->
  btypecode_t list ->
  btypecode_t list ->
  (
    entry_kind_t * 
    btypecode_t * 
    (int * btypecode_t) list * 
    btypecode_t list
  ) option

@h = tangler("src/flx_overload.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_exceptions
open Flx_typing
open Flx_typing2
open List
open Flx_srcref
open Flx_unify
open Flx_beta
open Flx_generic
open Flx_name
open Flx_tconstraint
open Flx_tpat

type overload_result = 
 int *  (* index of function *)
 btypecode_t * (* type of function signature *)
 (int * btypecode_t) list * (* mgu *)
 btypecode_t list (* ts *)

type result = 
  | Unique of overload_result
  | Fail


let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_lookup.get_data] No definition of <" ^ string_of_int index ^ ">")

let sig_of_symdef symdef sr name i = match symdef with 
  | `SYMDEF_match_check (_) 
    -> `TYP_tuple[],`TYP_sum [`TYP_tuple[];`TYP_tuple[]] (* bool *)

  (* primitives *)
  | `SYMDEF_fun (_,ps,r,_,_,_)
    -> typeof_list ps,r

  | `SYMDEF_callback (_,ts_orig,r,_)
    -> 
      let ts_f = 
        filter 
        (function 
          | `AST_name (_,id,[]) when id = name -> false
          | t -> true
        ) 
        ts_orig 
      in
      let tf_args = match ts_f with
        | [x] -> x
        | lst -> `TYP_tuple lst
      in
      let tf = `TYP_function (tf_args, r) in

      (* The type of the arguments Felix thinks the raw
         C function has on a call. A closure of this
         function is a Felix function .. NOT the raw
         C function.
      *)
      let ts_cf =
        map
        (function 
          | `AST_name (_,id,[]) when id = name -> tf
          | t -> t
        ) 
        ts_orig 
      in
      typeof_list ts_cf,r

  | `SYMDEF_function (ps,r,_,_)
    -> paramtype (fst ps),r

  | `SYMDEF_cstruct ls
  | `SYMDEF_struct ls ->
    typeof_list (map snd ls),`AST_index (sr,name,i)

  | `SYMDEF_const_ctor (_,r,_) -> `AST_void sr,r
  | `SYMDEF_nonconst_ctor (_,r,_,t) -> t,r
  | `SYMDEF_type_alias t ->
    begin match t with
    | `TYP_typefun (ps,r,b) -> typeof_list (map snd ps),r
    | symdef -> 
      clierr sr (
        "[sig_of_symdef] Expected "^
        name
        ^" to be a type function, got " ^
        string_of_typecode t
      )
    end
  
  | symdef -> 
    clierr sr (
      "[sig_of_symdef] Expected "^
      name
      ^" to be function or procedure, got " ^
     string_of_symdef symdef name []
    )    

let resolve syms i =
  match get_data syms.dfns i with 
  {id=id; sr=sr;parent=parent;privmap=table;dirs=dirs;symdef=symdef} ->
  let pvs,vs = find_split_vs syms i in
  let t,r = sig_of_symdef symdef sr id i in
  id,sr,parent,vs,pvs,t,r

let rec unravel_ret tin dts = 
  match tin with
  | `BTYP_function (a,b) -> unravel_ret b (a::dts)
  | _ -> rev dts

let consider syms bt i ts signs call_sr =
    let bt sr t = bt sr i t in
    let id,sr,p,vs,pvs,t,r = resolve syms i in
    (*
    print_endline ("Candidate "^si i^" sig is " ^ string_of_typecode t);
    *)
    let t = bt sr t in
    let dms = 
      try unravel_ret (bt sr r) []
      with _ -> print_endline "Failed to bind candidate return type!"; []
    in
    let tdms = t :: dms in

    (*
    print_endline ("Argument  sigs= " ^  catmap "->" (sbt syms.dfns) signs);
    print_endline ("Candidate sigs= " ^  catmap "->" (sbt syms.dfns) tdms);
    print_endline ("pvs = " ^ catmap ", " (fun (s,i,_) ->s ^ "=" ^ si i) pvs);
    print_endline ("vs = " ^ catmap ", " (fun (s,i,_) ->s ^ "=" ^ si i) vs);
    print_endline ("type constraint = " ^ sbt syms.dfns type_constraint);
    *)
    (* Here we have a parameter list vs of m type variables,
       a signature type t, containing these variables,
       and a list ts of type expressions of length n which are
       bindings to first n of the m type variables.

       Because of recursion, it is possible the ts also
       contain the type variables in vs, however, these
       are quite distinct.

       To fix this problem we must 'alpha convert'
       the type expression by replacing the vs variables
       in t with fresh variables, and also assigning the
       first n of these to the ts values.

       Matching requires a solution for all the fresh variables.
       The return type must be converted to use the fresh variables,
       and then the solution plugged in to eliminate them: any
       remaining variables from the original vs list are actually
       from the environment of a recursive function call
    *)
    (* Step1: make equations for the ts *)
   
    let k = length pvs in
    let m = length vs in 
    let n = length ts in
    (* This is actually NOT an error .. it should just 
      cause this candidate to be rejected
    *)
    (*
    if n>m then clierr sr 
    (
      "[overload] Overloading " ^ name ^ 
      "\nToo many type subscripts for index "^si i^", expected " ^ 
      si m ^ ", got:\n" ^
      catmap "," (sbt syms.dfns) ts
    )
    ;
    *)
    if n>m then None else

    (* Currently, vs lists can only specify TYPE variables *)
    let base = !(syms.counter) in
    syms.counter := base + k + m;
    let lhs = map (fun i -> `BTYP_var ((i+base),`BTYP_type)) (nlist (k + m)) in
    let rhs = (map (fun (_,i,_) -> `BTYP_var (i,`BTYP_type)) pvs) @ ts in
    let eqns = combine (list_prefix lhs (k+n)) rhs in

    (* Step 2: convert t to use variables 0 to m-1 
      instead of those in vs
    *)
    let bvs = map (fun (s,i,tp) -> s,i) (pvs @ vs) in
    let tdms' = map (tsubst bvs lhs) tdms in
    let rec rfld res x y = match x,y with
    | [],_ | _,[] -> res
    | h::t,h'::t' -> rfld ((h,h'):: res) t t'
    in 
    let eqns = rfld eqns tdms' signs in
    (*
    let eqns = (t',sign) :: eqns in
    *)
    (*
    print_endline "EQUATIONS ARE:";
    iter (fun (t1,t2) -> print_endline (sbt syms.dfns t1 ^ " = " ^ sbt syms.dfns t2))
    eqns
    ;
    print_endline "...";
    *)
    let mgu = maybe_specialisation syms.dfns eqns in
    (match mgu with
    | Some mgu -> 
      let mgu = ref mgu in
      (*
      print_endline "Specialisation detected";
      print_endline (" .. mgu = " ^ string_of_varlist syms.dfns mgu);
      *)
      (* each universally quantified variable must be fixed
        by the mgu .. if it doesn't its an error .. hmmm

        THIS CANNOT HAPPEN NOW!
        JS: 13/3/2006 .. oh yes it can!
        
      *)
      (* Below algorithm is changed! We now make list
         of unresolved dependent variables, and see
         if the constraint resolution can help.
         Actually, at this point, we can even try
         to see if the return type can help
       *)

      let unresolved = ref (
        fold_left2 
        (fun acc (s,i,tp) k ->
          if not (mem_assoc (k+base) !mgu) then (s,i,tp,k)::acc else acc
        )
        [] vs (nlist m)
      )
      in

      let th i = match i with 
        | 0 -> "first"
        | 1 -> "second"
        | 2 -> "third"
        | _ -> si (i+1) ^ "'th"
      in

      let report_unresolved = 
        let maybe_tp tp = match tp with
          | `TPAT_any -> ""
          | tp -> ": " ^ string_of_tpattern tp
        in
        fold_left (fun acc (s,i,tp,k) -> acc ^
          "  The " ^th k ^" subscript  " ^ s ^ "["^si i^"]" ^
           maybe_tp tp ^ "\n"
        ) "" !unresolved
      in
      if length !unresolved > 0 then
        print_endline (
        "WARNING: experimental feature coming up\n" ^
        "Below would be an error, but we try now to do more work\n" ^
        (* clierr call_sr ( *)
          "[resolve_overload] In application of " ^ id ^ 
          " cannot resolve:\n" ^
          report_unresolved ^ 
         "Try using explicit subscript" ^
         "\nMost General Unifier(mgu)=\n" ^ string_of_varlist syms.dfns !mgu 
        )
      ;

      (* HACKERY to try to get more values from type patterns*)
      if length !unresolved > 0 then 
      begin
        let extra_eqns = ref [] in
        let dvars = ref IntSet.empty in
        print_endline ("BASE=" ^ si base);
        let counter = ref 0 in
        iter (fun (s,j',tp) ->
           let et,explicit_vars1,any_vars1, as_vars1, eqns1 = 
            type_of_tpattern syms tp
           in
           let et = bt sr et in
           let j = !counter + base in 
           incr counter;
           print_endline ("Analysing "^s^"<"^si j^">: " ^ string_of_tpattern tp);
           print_endline (si j ^ (if mem_assoc j !mgu then " IS IN MGU" else " IS NOT IN MGU"));
           if mem_assoc j !mgu then begin
             let t1 = assoc j !mgu in
             let t2 = et in
             print_endline ("Adding equation " ^ sbt syms.dfns t1 ^ " = " ^ sbt syms.dfns t2);
             extra_eqns := (t1,t2) :: !extra_eqns
           end
           ; 
           print_endline ("Equivalen type is:\n  " ^ sbt syms.dfns et);

           let et = list_subst !mgu et in
           let et = beta_reduce syms [] et in
           print_endline ("After substitution of mgu, Reduced type is:\n  " ^ 
             sbt syms.dfns et)
           ;

           if length explicit_vars1 > 0 then
           print_endline ("Explicit ?variables: " ^ 
             catmap "," (fun (i,s) -> s ^ "<" ^ si i ^ ">") explicit_vars1)
           ;
           let pos_ix vs k = 
              let rec aux vs i = match vs with
              | (_,k',_) :: tl -> if k = k' then i else aux tl (i+1)
              | _ -> failwith "WOOPS not in vs list??"
              in
              aux vs 0
           in
           iter
           (fun (i,s) -> 
             let coupled = filter (fun (s',_,_) -> s = s') vs in
             match coupled with
             | [] -> ()
             | [s',k,pat] -> 
                print_endline (
                    "Coupled " ^ s ^ ": " ^ si k ^ "(vs var) <--> " ^ si i ^" (pat var)" ^ 
                  " pat=" ^ string_of_tpattern pat);
             let q = pos_ix vs k in
             print_endline ("Position in vs list is " ^ si q);
             let q = q+base in
             print_endline ("Alpha converted index is " ^ si q);
             let t1 = `BTYP_var (i,`BTYP_type) in 
             let t2 = `BTYP_var (q,`BTYP_type) in 
             print_endline ("Adding equation " ^ sbt syms.dfns t1 ^ " = " ^ sbt syms.dfns t2);
             extra_eqns := (t1,t2) :: !extra_eqns;
             dvars := IntSet.add i !dvars;
             dvars := IntSet.add q !dvars;

             | _ -> assert false (* vs should have distinct names *)
           )
           explicit_vars1
           ;
           if length as_vars1 > 0 then
           print_endline ("As variables: " ^ 
             catmap "," (fun (i,s) -> s ^ "<" ^ si i ^ ">") as_vars1)
           ;
           if length any_vars1 > 0 then
           print_endline ("Wildcard variables: " ^ 
             catmap "," (fun i -> "<" ^ si i ^ ">") any_vars1)
           ;
           if length eqns1 > 0 then
           print_endline ("Equations for as terms (unbound): " ^ 
             catmap "\n" (fun (i,t) -> si i ^ " -> " ^ string_of_typecode t) eqns1)
           ;
        )
        vs
        ;
        let maybe_extra_mgu = 
          try Some (unification false syms.dfns !extra_eqns !dvars)
          with Not_found -> None
        in
        match maybe_extra_mgu with
        | None -> print_endline "COULDN'T RESOLVE EQUATIONS"
        | Some extra_mgu -> 
           print_endline ("Resolved equations with mgu:\n  " ^
              string_of_varlist syms.dfns extra_mgu)
           ;
           let ur = !unresolved in 
           unresolved := [];
           iter (fun ((s,i,_,k) as u) -> 
             let j = base + k in
             if mem_assoc j extra_mgu 
             then begin
                let t = assoc j extra_mgu in 
                print_endline ("CAN NOW RESOLVE " ^ 
                  th k ^ " vs term " ^ s ^ "<"^ si i^"> ---> " ^ sbt syms.dfns t)
                ;
                mgu := (j,t) :: !mgu
             end 
             else begin
               print_endline ("STILL CANNOT RESOLVE " ^ th k ^ " vs term " ^ s ^ "<"^si i^">");
               unresolved := u :: !unresolved
             end
           )
           ur
      end
      ;
      if length !unresolved > 0 then failwith "STOP";
      iter 
      (fun sign ->
        if sign <> list_subst !mgu sign then
        clierr call_sr 
        (
          "[resolve_overload] Unification of function " ^ 
          id ^ "<" ^ si i ^ "> signature " ^
          sbt syms.dfns t ^ 
          "\nwith argument type " ^ sbt syms.dfns sign ^
          "\nhas mgu " ^ string_of_varlist syms.dfns !mgu ^
          "\nwhich specialises a variable of the argument type"
        )
      )
      signs
      ;
      (*
      print_endline ("Matched with mgu = " ^ string_of_varlist syms.dfns !mgu);
      *)
      (* RIGHT! *)
      let ts = map (fun i -> assoc (base+i) !mgu) (nlist (m+k)) in
      
      (*
      print_endline ("Matched candidate " ^ si i ^ 
        " mgu=" ^ string_of_varlist syms.dfns !mgu ^ 
        ", ts=" ^ catmap ", " (sbt syms.dfns) ts
      );
      *)

      (* we need to check the type constraint, it uses the
        raw vs type variable indicies. We need to substitute
        in the corresponding ts values. First we need to build
        a map of the correspondence
      *)

      assert (length bvs = length ts);
      let type_constraint = build_type_constraints syms (bt sr) sr vs in
      let type_constraint = tsubst bvs ts type_constraint in
      (*
      print_endline ("Substituted type constraint " ^ sbt syms.dfns type_constraint);
      *)
      let reduced_constraint = beta_reduce syms [] type_constraint in
      (*
      print_endline ("Reduced type constraint " ^ sbt syms.dfns reduced_constraint);
      *)
      begin match reduced_constraint with
      | `BTYP_void -> 
        (*
        print_endline "Constraint failure, rejecting candidate";
        *)
        None
      | `BTYP_tuple [] -> Some (i,t,!mgu,ts)
      | _ -> 
        clierr sr 
        ("[overload] Cannot resolve type constraint! " ^
          sbt syms.dfns type_constraint
        )
      end

    | None -> 
      (*
      print_endline "No match"; 
      *)
      None
    )
 
let overload 
  syms 
  bt 
  call_sr 
  (fs : entry_kind_t list)
  (name: string)
  (sufs : btypecode_t list) 
  (ts:btypecode_t list) 
: (entry_kind_t * btypecode_t * (int * btypecode_t) list * btypecode_t list) option =

  (*
  print_endline ("Argument sigs are " ^ catmap ", " (sbt syms.dfns) sufs);
  print_endline ("Candidates are " ^ catmap "," (string_of_entry_kind) fs);
  print_endline ("Input ts = " ^ catmap ", " (sbt syms.dfns) ts);
  *)
  (* HACK for the moment *)
  let rec aux i =  
    match consider syms bt i ts sufs call_sr with
    | Some x -> Unique x
    | None -> Fail
  in
  let fun_defs = List.map aux fs in
  let candidates = 
    List.filter 
    (fun result -> match result with
      | Unique _ -> true
      | Fail -> false
    ) 
    fun_defs
  in
    (*
    print_endline "Got matching candidates .. ";
    *)
  (* start with an empty list, and fold one result
  at a time into it, as follows: if one element
  of the list is greater (more general) than the candidate,
  then add the candidate to the list and remove all
  element greater than the candidate,

  otherwise, if one element of the list is less then
  the candidate, keep the list and discard the candidate.

  The list starts off empty, so that all elements in
  it are vacuously incomparable. It follows either
  the candidate is not less than all the list,
  or not less than all the list: that is, there cannot
  be two element a,b such that a < c < b, since by
  transitivity a < c would follow, contradicting
  the assumption the list contains no ordered pairs.

  If in case 1, all the greater element are removed and c added,
  all the elements must be less or not comparable to c,
  thus the list remains without comparable pairs,
  otherwise in case 2, the list is retained and c discarded
  and so trivially remains unordered.

  *)

  let candidates = fold_left
  (fun oc r ->
     match r with Unique (j,c,_,_) -> 
     (*
     print_endline ("Considering candidate sig " ^ sbt syms.dfns c);
     *)
     let rec aux lhs rhs =
       match rhs with
       | [] -> 
         (*
         print_endline "return elements plus candidate";
         *)
         r::lhs (* return all non-greater elements plus candidate *)
       | (Unique(i,typ,mgu,ts) as x)::t 
       ->
         (*
         print_endline (" .. comparing with " ^ sbt syms.dfns typ);
         *)
         begin match compare_sigs syms.dfns typ c with
         | `Less -> 
           (*
           print_endline "Candidate is more general, discard it, retain whole list";
           *)
           lhs @ rhs (* keep whole list, discard c *) 
         | `Equal -> 
           let sr = match Hashtbl.find syms.dfns i with {sr=sr} -> sr in
           let sr2 = match Hashtbl.find syms.dfns j with {sr=sr} -> sr in
           clierrn [call_sr; sr2; sr]
           (
             "[resolve_overload] Ambiguous call: Not expecting equal signatures" ^
             "\n(1) " ^ sbt syms.dfns typ ^
             "\n(2) " ^ sbt syms.dfns c
           )

         | `Greater -> 
           (*
           print_endline "Candidate is less general: discard this element";
           *)
           aux lhs t (* discard greater element *)
         | `Incomparable -> 
           (*
           print_endline "Candidate is comparable, retail element";
           *)
           aux (x::lhs) t (* keep element *)
       end
       | Fail::_ -> assert false
     in aux [] oc
     | Fail -> assert false
  )
  []
  candidates in
  match candidates with
  | [Unique (i,t,mgu,ts)] -> 
    (*
    print_endline ("[overload] Got unique result " ^ si i);
    *)
    Some (i,t,mgu,ts)

  | [] -> None
  | _ -> 
    clierr call_sr 
    (
      "Too many candidates match in overloading " ^ name ^
      " with argument types " ^ catmap "," (sbt syms.dfns) sufs ^
      "\nOf the matching candidates, the following are most specialised ones are incomparable\n" ^
      catmap "\n" (function 
        | Unique (i,t,_,_) ->
          qualified_name_of_index syms.dfns i ^ "<" ^ si i ^ "> sig " ^ 
          sbt syms.dfns t
        | Fail -> assert false
      ) 
      candidates
      ^ 
      "\nPerhaps you need to define a function more specialised than all these?"
    )

(* FINAL NOTE: THIS STILL WON'T BE ENOUGH: THE SEARCH ALGORITHM
NEEDS TO BE MODIFIED TO FIND **ALL** FUNCTIONS .. alternatively,
keep the results from overload resolution for each scope, and resubmit
in a deeper scope: then if there is a conflict between signatures
(equal or unordered) the closest is taken if that resolves the 
conflict
*)


