@head(1,'Monomorphisation')
This requires the instantiator to have been run.
@h = tangler("src/flx_mono.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_call

val monomorphise:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  unit
 

@h = tangler("src/flx_mono.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child
open Flx_reparent
open Flx_spexes
open Flx_beta

let get_vs bbdfns i =
  let _,_,_,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) -> vs
  | `BBDCL_procedure (props,vs,(ps,traint), exes) -> vs
  | `BBDCL_val (vs,t) -> vs
  | `BBDCL_var (vs,t) -> vs
  | `BBDCL_ref (vs,t) -> vs
  | `BBDCL_tmp (vs,t) -> vs
  | `BBDCL_glr (props,vs,ret, (p,exes)) -> vs
  | `BBDCL_regmatch (props,vs,(ps,traint),ret,(alpha,states,h,mx))  -> vs
  | `BBDCL_reglex (props,vs,(ps,traint),le,ret,(alpha,states,h,mx)) -> vs
  | `BBDCL_class (props,vs) -> vs
  | `BBDCL_union (vs,ps) -> vs
  | `BBDCL_struct (vs,ps) -> vs
  | `BBDCL_cstruct (vs,ps) -> vs
  | `BBDCL_newtype (vs,t) -> vs
  | `BBDCL_cclass (vs,ps) -> vs
  | `BBDCL_const (vs,t,ct,reqs) -> vs
  | `BBDCL_insert (vs,s,ikind,reqs) -> vs
  | `BBDCL_fun (props,vs,argtypes,ret,ct,reqs,prec) -> vs
  | `BBDCL_callback (props,vs,argtypes_cf,argtypes_c,k,ret,reqs,prec) -> vs
  | `BBDCL_proc (props,vs,argtypes,ct,reqs) -> vs
  | `BBDCL_abs (vs,tqual,ct,reqs) ->  vs
  | `BBDCL_nonconst_ctor (vs,uidx,udt, ctor_idx, ctor_argt, evs, etraint) -> vs
  | `BBDCL_typeclass (props,vs) ->  vs
  | `BBDCL_instance (props,vs,con,tc,ts) -> vs


let cal_parent syms bbdfns i' ts' =
  let id,parent,sr,_ = Hashtbl.find bbdfns i' in
  match parent with
  | None -> None
  | Some i -> 
    let vsc = get_vs bbdfns i' in
    assert (length vsc = length ts');
    if not (Hashtbl.mem bbdfns i) then None else
    let vsp = get_vs bbdfns i in
    let n = length vsp in
    assert (n <= length vsc);
    let ts = list_prefix ts' n in
    let k =
       try (Hashtbl.find syms.instances (i,ts))
       with Not_found -> 
        print_endline ("Wah? Not found parent of " ^ 
          id ^ "<" ^ si i' ^ ">" ^
          "[" ^ catmap "," (sbt syms.dfns) ts ^ "]\n" ^
          "Which should be " ^ si i ^ 
          "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"
        )
        ;
        assert false
    in
      if ts = [] then assert (i=k);
      (*
      print_endline ("Parent of " ^ si i' ^ " was " ^ si i ^ " is now " ^ si k);
      *)
      Some k

let fixup_type' syms bbdfns fi t =
  match t with
  | `BTYP_inst (i,ts) -> 
    let i,ts = fi i ts in
    `BTYP_inst (i,ts)
  | x -> x

let rec fixup_type syms bbdfns fi t =
  let ft t = fixup_type syms bbdfns fi t in
  let ft' t = fixup_type' syms bbdfns fi t in
  let t = map_btype ft t in
  ft' t
 
let fixup_expr' syms bbdfns fi mt (e:bexpr_t) =
  (*
  print_endline ("FIXUP EXPR(up) " ^ sbe syms.dfns (e,`BTYP_void));
  *)
  let x = match e with
  | `BEXPR_apply_prim (i',ts,a) ->
    let i,ts = fi i' ts in
    if i = i' then
      `BEXPR_apply_prim (i,ts,a)
    else
      `BEXPR_apply_direct (i,ts,a)

  | `BEXPR_apply_direct (i,ts,a) ->
    let i,ts = fi i ts in
    `BEXPR_apply_direct (i,ts,a)

  | `BEXPR_apply_struct (i,ts,a) ->
    let i,ts = fi i ts in
    `BEXPR_apply_struct (i,ts,a)

  | `BEXPR_apply_stack (i,ts,a) ->
    let i,ts = fi i ts in
    `BEXPR_apply_stack (i,ts,a)

  | `BEXPR_apply_method_direct (obj,i,ts,a) ->
    let i,ts = fi i ts in
    `BEXPR_apply_method_direct (obj,i,ts,a) 

  | `BEXPR_apply_method_stack (obj,i,ts,a) ->
    let i,ts = fi i ts in
    `BEXPR_apply_method_stack (obj,i,ts,a) 

  | `BEXPR_ref (i,ts)  ->
    let i,ts = fi i ts in
    `BEXPR_ref (i,ts)

  | `BEXPR_name (i',ts') ->
    let i,ts = fi i' ts' in
    (*
    print_endline (
      "Ref to Variable " ^ si i' ^ "[" ^ catmap "," (sbt syms.dfns) ts' ^"]" ^
      " mapped to " ^ si i ^ "[" ^ catmap "," (sbt syms.dfns) ts ^"]"
    );
    *)
    `BEXPR_name (i,ts)

  | `BEXPR_closure (i,ts) ->
    let i,ts = fi i ts in
    `BEXPR_closure (i,ts)
   
  | `BEXPR_method_closure (e,i,ts) ->
    let i,ts = fi i ts in
    `BEXPR_method_closure (e,i,ts)
  | x -> x
  in
  (*
  print_endline ("FIXed UP EXPR " ^ sbe syms.dfns (x,`BTYP_void));
  *)
  x

let id x = x 

let rec fixup_expr syms bbdfns fi mt e =
  (*
  print_endline ("FIXUP EXPR(down) " ^ sbe syms.dfns e);
  *)
  let fe e = fixup_expr syms bbdfns fi mt e in
  let fe' (e,t) = fixup_expr' syms bbdfns fi mt e,t in
  (* this is deviant case: implied ts is vs of parent!,
     it has to be done FIRST before the type is remapped
  *)
  let e = match e with
  | `BEXPR_get_named (i,(e,t)),t' ->
    print_endline ("REMAPPING component variable " ^ si i);
    let vs = get_vs bbdfns i in
    print_endline ("vs = " ^ catmap "," (fun (s,i) -> s ^ "<" ^ si i ^ ">") vs);
    begin match t with
    | `BTYP_inst (j,ts) 
    | `BTYP_lvalue (`BTYP_inst (j,ts)) ->
      print_endline ("type=" ^ si j ^ ", ts = " ^ catmap "," (sbt syms.dfns) ts);
      let i,ts = fi i ts in
      print_endline ("Remapped to " ^ si i);
      `BEXPR_get_named (i,(e,t)),t'
    | _ -> assert false
    end
  | x -> x
  in
  let e = map_tbexpr id fe mt e in
  fe' e
  
let fixup_exe syms bbdfns fi mt exe = 
  let fe e = fixup_expr syms bbdfns fi mt e in
  match map_bexe id fe mt id id exe with
  | `BEXE_call_direct (sr, i,ts,a) ->
    let i,ts = fi i ts in
    `BEXE_call_direct (sr,i,ts,a)

  | `BEXE_jump_direct (sr, i,ts,a) ->
    let i,ts = fi i ts in
    `BEXE_jump_direct (sr,i,ts,a)

  | `BEXE_call_prim (sr, i',ts,a) ->
    let i,ts = fi i' ts in
    if i = i' then
      `BEXE_call_prim (sr,i,ts,a)
    else
      `BEXE_call_direct (sr,i,ts,a)


  | `BEXE_call_stack (sr, i,ts,a) ->
    let i,ts = fi i ts in
    `BEXE_call_stack (sr,i,ts,a)

  | `BEXE_call_method_direct (sr,o,i,ts,a) ->
    let i,ts = fi i ts in
    `BEXE_call_method_direct (sr,o, i,ts,a)

  | `BEXE_call_method_stack (sr, o, i,ts,a) ->
    let i,ts = fi i ts in
    `BEXE_call_method_stack (sr,o, i,ts,a)

  (* this is deviant case: implied ts is vs of parent! *)
  | `BEXE_init (sr,i,e) ->
    let vs = get_vs bbdfns i in
    let ts = map (fun (s,j) -> mt (`BTYP_var (j,`BTYP_type 0))) vs in
    let i,ts = fi i ts in
    `BEXE_init (sr,i,e)

  | `BEXE_apply_ctor (sr,dst,cls,clsts,ctor,ctorarg) ->
    print_endline ("ORIGINAL: apply ctor " ^ si ctor ^ " class " ^ si cls ^ " ts = " ^ catmap "," (sbt syms.dfns) clsts);
    let cls,clsts = fi cls clsts and ctor,_ = fi ctor clsts in
    print_endline ("REMAPPED: apply ctor " ^ si ctor ^ " class " ^ si cls ^ " ts = " ^ catmap "," (sbt syms.dfns) clsts);
    let dstvs = get_vs bbdfns dst in
    let dstts = map (fun (s,j) -> mt (`BTYP_var (j,`BTYP_type 0))) dstvs in
    let dst,dstts = fi dst dstts in
    `BEXE_apply_ctor (sr,dst,cls,clsts,ctor,ctorarg)

  | `BEXE_apply_ctor_stack (sr,dst,cls,clsts,ctor,ctorarg) ->
    print_endline ("ORIGINAL: apply ctor " ^ si ctor ^ " class " ^ si cls ^ " ts = " ^ catmap "," (sbt syms.dfns) clsts);
    let cls,clsts = fi cls clsts and ctor,_ = fi ctor clsts in
    print_endline ("REMAPPED: apply ctor " ^ si ctor ^ " class " ^ si cls ^ " ts = " ^ catmap "," (sbt syms.dfns) clsts);
    let dstvs = get_vs bbdfns dst in
    let dstts = map (fun (s,j) -> mt (`BTYP_var (j,`BTYP_type 0))) dstvs in
    let dst,dstts = fi dst dstts in
    `BEXE_apply_ctor_stack (sr,dst,cls,clsts,ctor,ctorarg)


  | x -> x
  
let fixup_exes syms bbdfns fi mt exes =
  map (fixup_exe syms bbdfns fi mt) exes

let mono syms (bbdfns: fully_bound_symbol_table_t) fi i ts n =
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
   
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) -> 
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let ret = mt ret in
    let ps = map (fun {pkind=pk; pid=s;pindex=i; ptyp=t} -> 
      {pkind=pk;pid=s;pindex=fst (fi i ts);ptyp=mt t}) ps 
    in
    let traint = match traint with | None -> None | Some x -> Some (fixup_expr syms bbdfns fi mt x) in
    let exes = fixup_exes syms bbdfns fi mt exes in
    let entry = `BBDCL_function (props,[],(ps,traint),ret,exes) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)
 
  | `BBDCL_procedure (props,vs,(ps,traint), exes) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let ps = map (fun {pkind=pk; pid=s;pindex=i; ptyp=t} -> 
      let k = fst (fi i ts) in
      let u = mt t in
      (*
      print_endline ("Remap parameter " ^ s ^"<"^ si i ^ "> (type " ^
        sbt syms.dfns t ^
      ")to " ^ si k ^ " type " ^ sbt syms.dfns u);
      *)
      {pkind=pk;pid=s;pindex=k;ptyp=u}) ps 
    in
    let traint = match traint with | None -> None | Some x -> Some (fixup_expr syms bbdfns fi mt x) in
    let exes = fixup_exes syms bbdfns fi mt exes in
    let entry = `BBDCL_procedure (props,[],(ps,traint), exes) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  | `BBDCL_val (vs,t) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let t = mt t in
    let entry = `BBDCL_val ([],t) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  | `BBDCL_var (vs,t) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let t = mt t in
    let entry = `BBDCL_var ([],t) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  | `BBDCL_ref (vs,t) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let t = mt t in
    let entry = `BBDCL_ref ([],t) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  | `BBDCL_tmp (vs,t) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let t = mt t in
    let entry = `BBDCL_tmp ([],t) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  | `BBDCL_class (props,vs) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let entry = `BBDCL_class (props,[]) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  (* we have tp replace types in interfaces like Vector[int]
    with monomorphic versions if any .. even if we don't
    monomorphise the entry itself.

    This is weak .. it's redone for each instance, relies
    on mt being idempotent..
  *)
  | `BBDCL_fun (props,vs,argtypes,ret,ct,reqs,prec) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let argtypes = map mt argtypes in
    let ret = mt ret in
    let entry = `BBDCL_fun (props,vs,argtypes,ret,ct,reqs,prec) in
    Hashtbl.replace bbdfns i (id,parent, sr, entry)


  | `BBDCL_proc (props,vs,argtypes,ct,reqs) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let argtypes = map mt argtypes in
    let entry = `BBDCL_proc (props,vs,argtypes,ct,reqs) in
    Hashtbl.replace bbdfns i (id,parent, sr, entry)

  | `BBDCL_const (vs,t,`Str "#this",reqs) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = reduce_type (beta_reduce syms sr (fixup_type syms bbdfns fi (list_subst vars t))) in
    let t = mt t in
    let entry = `BBDCL_const([],t,`Str "#this",reqs) in
    let parent = cal_parent syms bbdfns i ts in
    Hashtbl.replace bbdfns n (id,parent,sr,entry)

  (*
  | `BBDCL_glr (props,vs,ret, (p,exes)) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let ret = mt ret in
    let exes = fixup_exes syms bbdfns mt exes in
    `BBDCL_glr (props,[],ret,(p,exes))

  | `BBDCL_regmatch (props,vs,(ps,traint),ret,(alpha,states,h,mx))  ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let traint = match traint with | None -> None | Some x -> Some (fixup_expr syms bbdfns mt x) in
    let ret = mt ret in
    `BBDCL_regmatch (props,[],(ps,traint),ret,(alpha,states,h,mx))

  | `BBDCL_reglex (props,vs,(ps,traint),le,ret,(alpha,states,h,mx)) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let traint = match traint with | None -> None | Some x -> Some (fixup_expr syms bbdfns mt x) in
    let ret = mt ret in
    `BBDCL_reglex (props,[],(ps,traint),le,ret,(alpha,states,h,mx)) 

  | `BBDCL_union (vs,ps) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let ps = map (fun (i,j,t) -> i,j,mt t) ps in
    `BBDCL_union ([],ps) 

  | `BBDCL_struct (vs,ps) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let ps = map (fun (i,t) -> i,mt t) ps in
    `BBDCL_struct ([],ps) 

  | `BBDCL_cstruct (vs,ps) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let ps = map (fun (i,t) -> i,mt t) ps in
    `BBDCL_cstruct ([],ps) 

  | `BBDCL_newtype (vs,t) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let mt t = list_subst vars t in
    let t = mt t in
    `BBDCL_newtype ([],t) 

  | `BBDCL_cclass (vs,ps) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_cclass ([],ps) 

  | `BBDCL_const (vs,t,ct,reqs) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_const ([],t,ct,reqs) 
 
  | `BBDCL_insert (vs,s,ikind,reqs) -> 
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_insert ([],s,ikind,reqs)  


  | `BBDCL_callback (props,vs,argtypes_cf,argtypes_c,k,ret,reqs,prec) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_callback (props,[],argtypes_cf,argtypes_c,k,ret,reqs,prec)

  | `BBDCL_abs (vs,tqual,ct,reqs) -> 
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_abs ([],tqual,ct,reqs)  

  | `BBDCL_nonconst_ctor (vs,uidx,udt, ctor_idx, ctor_argt, evs, etraint) ->
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_nonconst_ctor ([],uidx,udt, ctor_idx, ctor_argt, evs, etraint)
 
  | `BBDCL_typeclass (props,vs) ->  entry
    (*
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_typeclass (props,[])  
    *)

  | `BBDCL_instance (props,vs,con,tc,ts) ->  entry
    (*
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    `BBDCL_instance (props,[],con,tc,ts) -> 
    *)
  *)

  | _ -> ()

let chk_mono syms (bbdfns: fully_bound_symbol_table_t) i =
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->  true
  | `BBDCL_procedure (props,vs,(ps,traint), exes) -> true
  | `BBDCL_val (vs,t) -> true
  | `BBDCL_var (vs,t) -> true
  | `BBDCL_ref (vs,t) -> true
  | `BBDCL_tmp (vs,t) -> true
  | `BBDCL_class (props,vs) -> true
  | `BBDCL_const (_,_,`Str "#this",_) -> true

 
  | `BBDCL_glr (props,vs,ret, (p,exes)) -> false
  | `BBDCL_regmatch (props,vs,(ps,traint),ret,(alpha,states,h,mx))  -> false
  | `BBDCL_reglex (props,vs,(ps,traint),le,ret,(alpha,states,h,mx)) -> false
  | `BBDCL_union (vs,ps) -> false
  | `BBDCL_struct (vs,ps) -> false
  | `BBDCL_cstruct (vs,ps) -> false
  | `BBDCL_newtype (vs,t) -> false
  | `BBDCL_cclass (vs,ps) -> false
  | `BBDCL_const (vs,t,ct,reqs) -> false
  | `BBDCL_insert (vs,s,ikind,reqs) ->  false
  | `BBDCL_fun (props,vs,argtypes,ret,ct,reqs,prec) -> false
  | `BBDCL_callback (props,vs,argtypes_cf,argtypes_c,k,ret,reqs,prec) -> false
  | `BBDCL_proc (props,vs,argtypes,ct,reqs) -> false
  | `BBDCL_abs (vs,tqual,ct,reqs) ->  false
  | `BBDCL_nonconst_ctor (vs,uidx,udt, ctor_idx, ctor_argt, evs, etraint) -> false
  | `BBDCL_typeclass (props,vs) ->  false
  | `BBDCL_instance (props,vs,con,tc,ts) ->  false
  
(* monomorphic instances are already equal to their indices ..
  replace some polymorphic instances with monomorphic ones
*)
let monomorphise syms bbdfns =
  let polyinst = Hashtbl.create 97 in
  Hashtbl.iter
  (fun (i,ts) n -> 
   if ts = [] then assert (i = n )
   else 
     if chk_mono syms bbdfns i 
     then begin
       (*
       print_endline ("polyinst " ^ si n ^ " = " ^ 
       si i ^ "["^catmap "," (sbt syms.dfns) ts^"]");
       *)
       Hashtbl.add polyinst (i,ts) n
     end else begin
       (*
       print_endline ("*** NO polyinst " ^ si n ^ " = " ^ 
       si i ^ "["^catmap "," (sbt syms.dfns) ts^"]");
       *)
     end

  )
  syms.instances
  ;

  let fi i ts = 
    let ts = map reduce_type ts in
    let i,ts = Flx_typeclass.maybe_fixup_typeclass_instance syms bbdfns i ts in
    try Hashtbl.find polyinst (i,ts),[]
    with Not_found ->  i,ts
  in

  Hashtbl.iter
  (fun (i,ts) n -> 
    if (n <> i) then
    (*
    print_endline (
       "[monomorphise] Adding instance " ^ si n ^ " = " ^ 
       si i ^ "["^catmap "," (sbt syms.dfns) ts^"]"
    );
    *)
    mono syms bbdfns fi i ts n;
  )
  syms.instances
  ;

  Hashtbl.iter (fun (i,ts) n -> 
    Hashtbl.remove syms.instances (i,ts);
    Hashtbl.add syms.instances (n,[]) n;
  )
  polyinst
  ;
 
