@set_title("Extension Experiment")
@h = tangler('spkgs/sex.py')
@select(h)
SEX_MODULES = [
  'src/compiler/sex/sex_types',
  'src/compiler/sex/sex_token',
  'src/compiler/sex/sex_parse',
  'src/compiler/sex/sex_lex',
  'src/compiler/sex/sex_print',
  'src/compiler/sex/sex_map',
  'src/compiler/sex/ocs2sex',
  ]

caml_raw_interfaces = ['src/compiler/sex/sex_types','src/compiler/sex/sex_token']
caml_interfaces = ['src/compiler/sex/sex_types', 'src/compiler/sex/sex_token', 'src/compiler/sex/sex_parse']
caml_implementations = SEX_MODULES
caml_lexes = ['src/compiler/sex/sex_lex']
caml_dyparses = ['src/compiler/sex/sex_parse']
caml_include_paths = ['src/compiler/ocs','src/compiler/dyp/dyplib','src/compiler/sex']
caml_provide_lib = 'src/compiler/sex/sexlib'
caml_require_libs = ['flx_version','dyplib','ocslib','sexlib']
pkg_requires = ['flx_version','ocs','dypgen']
caml_exes = ['src/compiler/sex/sex']
iscr_src = ['lpsrc/sex.pak']
weaver_directory='doc/sex'
tmpdir = ['sex']

@head(1,"Lexer")
A simple lexer.
@select(tangler("src/compiler/sex/sex_lex.mll"))
{
open Sex_token
open Sex_parse
let lexeme = Lexing.lexeme
let substr = String.sub
let len = String.length
}
(* special characters *)
let quote = '\''
let dquote = '"'
let slosh = '\\'
let linefeed = '\n'
let tab = '\t'
let space = ' '
let formfeed = '\012'
let vtab = '\011'
let carriage_return = '\013'
let underscore = '_'

(* character sets *)
let bindigit = ['0'-'1']
let octdigit = ['0'-'7']
let digit = ['0'-'9']
let hexdigit = digit | ['A'-'F'] | ['a'-'f']
let lower = ['a'-'z']
let upper = ['A'-'Z']
let letter = lower | upper
let hichar = ['\128'-'\255']
let white = space | tab
let idletter = letter | underscore

(* nasty: form control characters *)
let form_control = linefeed | carriage_return | vtab | formfeed
let newline_prefix = linefeed | carriage_return
let newline = formfeed | linefeed  | carriage_return linefeed
let hash = '#'

let lb = "("
let rb = ")"

let symchar =
  '!' | '$' | '%' | '&' | '*' |
  '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
  '=' | '>' | '?' | '@' | '[' | ']' | '^' |
  '`' | '{' | '|' | '}' | '~' | '#' | '\\'

let ordinary = letter | digit | hichar | symchar | lb | rb

let printable = ordinary | quote | dquote

let alphanum = idletter | digit
let identifier = letter alphanum *
let integer = digit +
let sqstring = quote ordinary * quote
let dqstring = dquote ordinary * dquote
let string = sqstring | dqstring

let whitespace = (white | newline) +

rule sex_lex state = parse
| whitespace { sex_lex state lexbuf }
| identifier { ID (lexeme lexbuf) }
| string  { STR (lexeme lexbuf) }
| integer { INT (lexeme lexbuf) }
| lb { LB }
| rb { RB }
| symchar + { SYM (lexeme lexbuf) }
| eof { EOF }
| _ { failwith "lexing failed" }

{
}

@select(tangler("src/compiler/sex/sex_token.mli"))
type token =
 | LB
 | RB
 | EOF
 | STR of string
 | SYM of string
 | ID of string
 | INT of string

@select(tangler("src/compiler/sex/sex_parse.dyp"))
%mltop { open Sex_token }
{
open Sex_types
}

%token LB
%token RB
%token EOF
%token <string> STR
%token <string> SYM
%token <string> ID
%token <string> INT

%start <Sex_types.sexp_t> sex_parse

%%

sex_parse: sexp EOF { $1 }

sexp:
  | INT { Int $1 }
  | STR { Str $1 }
  | SYM { Sym $1 }
  | ID  { Id $1 }
  | LB sexps RB { Lst $2 }

sexps:
  | sexp sexps { $1 :: $2 }
  | { [] }

%mlitop { open Sex_token }

@select(tangler("src/compiler/sex/sex_types.mli"))
type sexp_t =
  | Int of string
  | Str of string
  | Sym of string
  | Id of string
  | Lst of sexp_t list

@select(tangler("src/compiler/sex/sex_print.ml"))
open Sex_types
open List

let emit p () = 
  let maxcol = 40 in
  let col = ref 0 in
  let newline () = p "\n"; col := 0 in
  fun s ->
    let n = String.length s in
    if !col <> 0 && !col + n > maxcol then newline();
    if !col <> 0 then p " ";
    p s;
    col := !col + n + 1

let sex_out p sex =
  let emit = emit p () in
  let rec pr sex = match sex with
  | Int s
  | Sym s
  | Id s -> emit s
  | Str s -> emit ("\"" ^ s ^ "\"")
  | Lst sex -> emit "("; iter pr sex; emit ")"
  in 
  pr sex;
  p "\n"

let sex_print sex = sex_out print_string sex

let string_of_sex s = 
  let b = Buffer.create 200 in
  sex_out (Buffer.add_string b) s;
  Buffer.contents b

@select(tangler("src/compiler/sex/sex_map.ml"))
open Sex_types
open List

let rec sex_map f (x:sexp_t): sexp_t = 
  match x with
  | Lst xs -> f (Lst (map (sex_map f) xs))
  | x -> f x

let rec subst fresh env x = 
  match x with
  | Lst [Id "lambda"; Id name; y] -> 
    let z = Id ("_" ^ string_of_int (fresh())) in
    Lst [Id "lambda"; z; subst fresh ((name,z)::env) y]

  | Id y as z -> (try assoc y env with Not_found -> z)
  | Lst xs -> Lst (map (subst fresh env) xs)
  | x -> x

let rec eval fresh env x = 
  (*
  print_string "Eval "; Sex_print.sex_print x;
  *)
  match x with
  | Lst [Id "apply"; f; arg] ->
    (*
    print_endline "Application = "; Sex_print.sex_print term;
    *)
    let f = subst fresh env f in
    let arg = subst fresh env arg in
    (*
    print_string "f = "; Sex_print.sex_print f; 
    print_string "a = "; Sex_print.sex_print arg; 
    *)
    begin match f with
    | Lst [Id "lambda"; Id name; body] ->
      let body = subst fresh ((name,arg)::env) body in
      (*
      print_string "body(after sub) = "; Sex_print.sex_print body;
      *)
      eval fresh env body

    | _ -> Lst [Id "apply"; f; arg]
    end

  | Lst [Id "letin"; Id name; y; body] ->
    let y = subst fresh env y in
    eval fresh ((name,y)::env) body

  | Lst [Id "defin"; Id name; y; body] ->
    eval fresh ((name,y)::env) body

  | Lst [Id "ifelse"; c; t; f] ->
    let c = eval fresh env c in
    let r = if c = Int "0" then f else t in
    (*
    print_string "After cond="; Sex_print.sex_print r;
    *)
    eval fresh env r

  | Lst (Sym "+" :: t) as x ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc + int_of_string y 
        | _ -> raise Not_found
      )
      0 t
      ))
    with Not_found -> x
    end

  | Lst (Sym "-" :: h :: t1 :: tt) as x ->
    let h = eval fresh env h in 
    begin match h with
    | Int h ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc - int_of_string y 
        | _ -> raise Not_found
      )
      (int_of_string h) (t1::tt)
      ))
    with Not_found -> x
    end
    | _ -> x
    end

  | Lst [Sym "-" ; Int s] ->
    Int (string_of_int (- (int_of_string s)))

  | Lst (Sym "*" :: h :: t) as x ->
    let h = eval fresh env h in 
    begin match h with
    | Int h ->
    begin try Int (string_of_int (fold_left 
      (fun acc x -> match eval fresh env x with 
        | Int y -> acc * int_of_string y 
        | _ -> raise Not_found
      )
      (int_of_string h) t
      ))
    with Not_found -> x
    end
    | _ -> x
    end
  | Id y as z -> (try assoc y env with Not_found -> z)
  | Lst xs -> Lst (map (eval fresh env) xs)
  | x -> x

@select(tangler("src/compiler/sex/ocs2sex.ml"))
open Sex_types
open Ocs_types

let rec ocs2sex (s:sval) : sexp_t =
  match s with
  | Sunbound
    -> failwith "unmapped ocs type Sunbound"
  | Seof 
    -> failwith "unmapped ocs type Seof"
  | Sreal _
    -> failwith "unmapped ocs type Sreal"
  | Scomplex _
    -> failwith "unmapped ocs type Scomplex"
  | Srational _
    -> failwith "unmapped ocs type Srational"
  | Schar _
    -> failwith "unmapped ocs type Schar"
  | Sport _
    -> failwith "unmapped ocs type Sport"
  | Sprim _
    -> failwith "unmapped ocs type Sprim"
  | Svalues _
    -> failwith "unmapped ocs type Svalues"
  | Sesym _
    -> failwith "unmapped ocs type Sesym"
  | Swrapped _
    -> failwith "unmapped ocs type Swrapped"
  | Sunspec
    -> failwith "unmapped ocs type Sunspec"
  | Spromise _
    -> failwith "unmapped ocs type Spromise"
  | Sproc _
    -> failwith "unmapped ocs type Sproc"

  | Snull -> Lst []
  | Strue -> Id "true"
  | Sfalse -> Id "false"
  | Sstring s -> Str s 
  | Ssymbol s -> Id s
  | Sint i -> Int (string_of_int i)
  | Sbigint i -> Int (Big_int.string_of_big_int i)
  | Spair _ -> 
    let svs = Ocs_misc.list_to_caml s in
    let sexs = List.map ocs2sex svs in
    Lst sexs

  | Svector a -> Lst (List.map ocs2sex (Array.to_list a))

@select(tangler("src/compiler/sex/sex.ml"))
open Sex_types
open List

let main() =
  let mk_fresh () = 
    let counter = ref 0 in 
    fun x -> let y = !counter in incr counter; y
  in
  let fresh = mk_fresh () in
  let filename = Sys.argv.(1) in
  print_endline ("Processing " ^ filename);
  let file = open_in filename in
  let lexbuf = Lexing.from_channel file in
  let sexes = Sex_parse.sex_parse (Sex_lex.sex_lex 1) lexbuf in
  close_in file;

  let sex = match sexes with
  | (sex,_) :: _ -> sex
  | _ -> assert false (* ambiguous parse not expected! *)
  in
  Sex_print.sex_print sex;
  print_endline "Done"
  ;
  let sex = Sex_map.eval fresh [] sex in 
  print_endline "Evaluated:";
  Sex_print.sex_print sex
  ;

  let filename = "test2.sex" in
  print_endline ("Processing " ^ filename);
  let file = open_in filename in
  let lexbuf = Lexing.from_channel file in
  let sexes = Sex_parse.sex_parse (Sex_lex.sex_lex 1) lexbuf in
  close_in file;
  let sex = match sexes with
  | (sex,_) :: _ -> sex
  | _ -> assert false (* ambiguous parse not expected! *)
  in
  Sex_print.sex_print sex;
  (*
  let sr = "test2.sex",0,0,0,0 in
  let flxe : Flx_ast.expr_t = Sex2flx.xexpr_t sr 1 [] sex in
  print_endline ("e=" ^ Flx_print.string_of_expr flxe)
  *)
;;

main()
;;

@select(tangler("src/compiler/sex/test2.sex"))
(
  AST_apply (add (AST_tuple (1 2)))
)
@select(tangler("src/compiler/sex/test.sex"))
(
  "Hello" fred 1 (2 3) (+ 30 (+ 6 4) 2)
  (lambda x (+ x x))
  (apply (lambda x (+ x x)) 42)
  (defin fact 
    (lambda x 
      (ifelse x 
        (* x (apply fact (- x 1)))
        1
      )
    )
    (apply fact 4)
  )
)

@select(tangler("src/compiler/sex/Makefile"))
@srcs = [
   ('sex_types',''),
   ('sex_print',''),
   ('sex_map',''),
   ('ocs2sex','-I ../../ocs'),
   ('sex_parse','-I ../../dypgen/dyplib'),
   ('sex_lex','-I ../../dypgen/dyplib'),
 ]
@#

all:
@tangle('\tpython ../../interscript/bin/iscr.py sex.pak')
@tangle('\tocamllex sex_lex.mll')
@tangle('\t../../bin/dypgen sex_parse.dyp')
@tangle('\trm sex_parse.mli')
@for src,flags in srcs:
  tangle('\tocamlopt '+flags+' -c '+src+'.ml')
@objs = ''
@for src,flags in srcs:
  objs = objs + src + '.cmx '
@tangle('\tocamlopt -a -o sexlib.cmxa '+objs)
@tangle('\tocamlopt -I ../../src -c sex.ml')
@tangle('\tocamlopt -o sex nums.cmxa ../../dypgen/dyplib/dyplib.cmxa ../../ocs/ocslib.cmxa ../../src/flxlib.cmxa sexlib.cmxa sex.cmx')
clean:
@tangle('\trm -f *.a *.o *.cmi *.cmx *.cmxa *.ml *.mli *.dyp *.mll *.cache sex tmp.tmp *.sex')

test:
@tangle('\t./sex test.sex')

