@head(1,'String handling')
@h = tangler('src/flx_string.ml')
@select(h)
let hexchar_of_int i = 
  if i < 10 
  then char_of_int (i + (int_of_char '0'))
  else char_of_int (i- 10 + (int_of_char 'A'))

let hex8 i = 
  let j = ref i in 
  let s = String.create 8 in
  for k = 0 to 7 do 
    s.[7-k]  <- hexchar_of_int (!j mod 16); 
    j := !j / 16 
  done;
  s

let hex4 i = 
  let j = ref i in 
  let s = String.create 4 in
  for k = 0 to 3 do 
    s.[3-k]  <- hexchar_of_int (!j mod 16); 
    j := !j / 16 
  done;
  s

let hex2 i = 
  let j = ref i in 
  let s = String.create 2 in
  for k = 0 to 1 do 
    s.[1-k]  <- hexchar_of_int (!j mod 16); 
    j := !j / 16 
  done;
  s

let escape_of_char quote ch =
  if ch = '\\' then "\\\\"
  else if ch = quote then "\\" ^ (String.make 1 quote)
  else if ch = '\n' then "\\n"
  else if ch < ' ' 
  or ch > char_of_int 126
  then "\\x" ^ (hex2 (Char.code ch))
  else String.make 1 ch

let escape_of_string quote x =
  let esc = escape_of_char quote in
  let res = ref "" in
  for i = 0 to (String.length x -1) do
    res := !res ^ (esc x.[i])
  done;
  (String.make 1) quote ^ !res ^ (String.make 1 quote)

let py_dquote_of_string = escape_of_string '"';;
let c_quote_of_string = escape_of_string '"';;
let py_quote_of_string = escape_of_string '\'';;

let string_of_char c = String.make 1 c;;

let bin_char2int s =
  let c = Char.code s in 
  match s with 
  | '0' -> 0 
  | '1' -> 1
  | _ -> raise (Flx_exceptions.LexError ("'" ^ (string_of_char s) ^ "' not binary digit"))

let oct_char2int s =
  let c = Char.code s in 
  match s with
    _ when (s >= '0' & s <= '7') ->
      c - (Char.code '0') 
  | _ -> raise (Flx_exceptions.LexError ("'" ^ (string_of_char s) ^ "' not octal digit"))

let dec_char2int s =
  let c = Char.code s in 
  match s with
    _ when (s >= '0' & s <= '9') ->
      c - (Char.code '0') 
  | _ -> raise (Flx_exceptions.LexError ("'" ^ (string_of_char s) ^ "' not decimal digit"))

let hex_char2int s =
  let c = Char.code s in 
  match s with
    _ when (s >= '0' & s <= '9') ->
      c - (Char.code '0') 
  | _ when (s >= 'a' & s <= 'f') ->
      (c - (Char.code 'a')) + 10 
  | _ when (s >= 'A' & s <= 'F') ->
      (c - (Char.code 'A')) + 10 
  | _ -> raise (Flx_exceptions.LexError ("'" ^ (string_of_char s) ^ "' not hexadecimal digit"))


let len = String.length;;

let binint_of_string s =
  let len = len s in
  let value = ref 0 in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := !value * 2 + (bin_char2int s.[i])
  done;
  !value

let octint_of_string s =
  let len = len s in
  let value = ref 0 in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := !value * 8 + (oct_char2int s.[i])
  done;
  !value

let decint_of_string s =
  let len = len s in
  let value = ref 0 in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := !value * 10 + (dec_char2int s.[i])
  done;
  !value

let hexint_of_string s =
  let len = len s in
  let value = ref 0 in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := !value * 16 + (hex_char2int s.[i])
  done;
  !value

let binbig_int_of_string s =
  let len = len s in
  let value = ref (Big_int.big_int_of_int 0) in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := 
      Big_int.add_int_big_int 
        (bin_char2int s.[i]) 
        (Big_int.mult_int_big_int 2 !value)
  done;
  !value

let octbig_int_of_string s =
  let len = len s in
  let value = ref (Big_int.big_int_of_int 0) in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := 
      Big_int.add_int_big_int 
        (oct_char2int s.[i]) 
        (Big_int.mult_int_big_int 8 !value)
  done;
  !value

let decbig_int_of_string s =
  let len = len s in
  let value = ref (Big_int.big_int_of_int 0) in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := 
      Big_int.add_int_big_int 
        (dec_char2int s.[i]) 
        (Big_int.mult_int_big_int 10 !value)
  done;
  !value

let hexbig_int_of_string s =
  let len = len s in
  let value = ref (Big_int.big_int_of_int 0) in 
  for i = 0 to (len - 1) do
    if s.[i] <> '_' 
    then value := 
      Big_int.add_int_big_int 
        (hex_char2int s.[i]) 
        (Big_int.mult_int_big_int 16 !value)
  done;
  !value

let floating_of_string s' = 
  let dst = ref 0 in
  let s = String.copy s' in
  for src = 0 to (String.length s) - 1 do
    if s.[src] <> '_'
    then begin
      s.[!dst] <- s.[src];
      incr dst
    end
  done;
  float_of_string (String.sub s 0 !dst)
      
(* WARNING: THIS CODE WILL NOT WORK FOR THE HIGHER PLANES
  BECAUSE OCAML ONLY SUPPORTS 31 bit signed integers;
  THIS CODE REQUIRES 32 bits [This can be fixed by using 
  negative codes but hasn't been done]

  HAPPINESS: Since the above note was posted,
  ISO10646/Unicode has agreed on a 20 bit address
  space for code points.
*)

(* parse the first utf8 encoded character of a string s
  starting at index position i, return a pair
  consisting of the decoded integers, and the position 
  of the first character not decoded.

  If the first character is bad, it is returned,
  otherwise if the encoding is bad, the result is
  an unspecified value.

  Fails if the index is past or at
  the end of the string.

  COMPATIBILITY NOTE: if this function is called
  with a SINGLE character string, it will return
  the usual value for the character, in range
  0 .. 255
*)

let parse_utf8 (s : string)  (i : int) : int * int =
  let ord = int_of_char 
  and n = (String.length s)  - i
  in 
  if n <= 0 then 
    failwith 
    (
      "parse_utf8: index "^ string_of_int i^
      " >= "^string_of_int (String.length s)^
      " = length of '" ^ s ^ "'"
    )
  else let lead = ord (s.[i]) in
    if (lead land 0x80) = 0 then 
      lead land 0x7F,i+1 (* ASCII *)
    else if lead land 0xE0 = 0xC0 && n > 1 then
      ((lead land 0x1F)  lsl  6) lor
        (ord(s.[i+1]) land 0x3F),i+2
    else if lead land 0xF0 = 0xE0 && n > 2 then
      ((lead land 0x1F) lsl 12) lor
        ((ord(s.[i+1]) land 0x3F)  lsl 6) lor
        (ord(s.[i+2]) land 0x3F),i+3
    else if lead land 0xF8 = 0xF0 && n > 3 then
      ((lead land 0x1F) lsl 18) lor
        ((ord(s.[i+1]) land 0x3F)  lsl 12) lor
        ((ord(s.[i+2]) land 0x3F)  lsl 6) lor
        (ord(s.[i+3]) land 0x3F),i+4
    else if lead land 0xFC = 0xF8 && n > 4 then
      ((lead land 0x1F) lsl 24) lor 
        ((ord(s.[i+1]) land 0x3F)  lsl 18) lor
        ((ord(s.[i+2]) land 0x3F)  lsl 12) lor
        ((ord(s.[i+3]) land 0x3F)  lsl 6) lor
        (ord(s.[i+4]) land 0x3F),i+5
    else if lead land 0xFE = 0xFC && n > 5 then
      ((lead land 0x1F) lsl 30) lor
        ((ord(s.[i+1]) land 0x3F)  lsl 24) lor
        ((ord(s.[i+2]) land 0x3F)  lsl 18) lor
        ((ord(s.[i+3]) land 0x3F)  lsl 12) lor
        ((ord(s.[i+4]) land 0x3F)  lsl 6) lor
        (ord(s.[i+5]) land 0x3F),i+6
    else lead, i+1  (* error, just use bad character *)

(* convert an integer into a utf-8 encoded string of bytes *)
let utf8_of_int i =
  let chr x = String.make 1 (Char.chr x) in
  if i < 0x80 then 
     chr(i)
  else if i < 0x800 then 
     chr(0xC0 lor ((i lsr 6) land 0x1F))  ^
      chr(0x80 lor (i land 0x3F))
  else if i < 0x10000 then 
     chr(0xE0 lor ((i lsr 12) land 0xF)) ^
      chr(0x80 lor ((i lsr 6) land 0x3F)) ^
      chr(0x80 lor (i land 0x3F))
  else if i < 0x200000 then 
     chr(0xF0 lor ((i lsr 18) land 0x7)) ^
      chr(0x80 lor ((i lsr 12) land 0x3F)) ^
      chr(0x80 lor ((i lsr 6) land 0x3F)) ^
      chr(0x80 lor (i land 0x3F))
  else if i < 0x4000000 then 
     chr(0xF8 lor ((i lsr 24) land 0x3)) ^
      chr(0x80 lor ((i lsr 18) land 0x3F)) ^
      chr(0x80 lor ((i lsr 12) land 0x3F)) ^
      chr(0x80 lor ((i lsr 6) land 0x3F)) ^
      chr(0x80 lor (i land 0x3F))
  else chr(0xFC lor ((i lsr 30) land 0x1)) ^
    chr(0x80 lor ((i lsr 24) land 0x3F)) ^
    chr(0x80 lor ((i lsr 18) land 0x3F)) ^
    chr(0x80 lor ((i lsr 12) land 0x3F)) ^
    chr(0x80 lor ((i lsr 6) land 0x3F)) ^
    chr(0x80 lor (i land 0x3F))

let unescape s = 
  let hex_limit = 2 in
  let n = len s in
  let s' = Buffer.create 1000 in
  let deferred = ref 0 in

  (* tack char deferres tacking spaces until
     the next non-space is received
  *)
  let tack_char ch = 
    if ch = ' ' then incr deferred
    else begin
      if !deferred<>0 then begin
        Buffer.add_string s' (String.make !deferred ' ');
        deferred := 0
      end;
      Buffer.add_char s' ch
    end
  in

  (* tack string always flushes deferred characters *)
  let tack_string ss = 
    if !deferred<> 0 then begin
       Buffer.add_string s' (String.make !deferred ' ');
       deferred := 0
     end;
     Buffer.add_string s' ss 
  in 
  let tack_utf8 code = tack_string (utf8_of_int code) in
  let i= ref 0 in 
  while !i< n do let ch = s.[!i] in
    if ch = '\\' then begin
      tack_string ""; (* flush spaces before any slosh *)
      incr i;
      if !i = n then tack_char '\\'
      else match s.[!i] with
      | 'a'  -> tack_char  '\007'; incr i   (* 7 : bell *)
      | 'b'  -> tack_char  '\008'; incr i   (* 8 : backspace *)
      | 't'  -> tack_char  '\t'; incr i     (* 9 : horizontal tab *)

      (* Note that \n flushes deferred spaces! *)
      | 'n'  -> tack_char  '\n'; incr i     (* 10 : linefeed *)
      | 'r'  -> tack_char  '\r'; incr i     (* 13 : return *)
      | 'v'  -> tack_char  '\011'; incr i   (* vertical tab *)
      | 'f'  -> tack_char  '\012'; incr i   (* form feed *)
      | 'e'  -> tack_char  '\033'; incr i   (* 27: x1b: escape *)

      | '\\' -> tack_char  '\\'; incr i
      | '"'  -> tack_char  '"'; incr i (* NOTE OCAMLLEX BUG: TWO SPACES REQUIRED *)
      | '\'' -> tack_char  '\''; incr i

      (* this is the special case of \ spaces:
         if the spaces are followed by a newline,
         discard the spaces (and the newline!)
         otherwise we keep the spaces
      *)
      | ' ' ->
        while !i<n && s.[!i]=' ' do
           incr deferred;
           incr i
        done;
        if !i<n && s.[!i]='\n' then begin
          deferred :=0;
          incr i
        end

      (* \newline is thrown out, but defered spaces are output *)
      | '\n' -> incr i
      | 'x' -> 
        begin 
          incr i;
          let j = ref 0 and value = ref 0 in
          while 
            (!i < n) & 
            (!j < hex_limit) &
            (String.contains "0123456789ABCDEFabcdef" s.[!i]) do
            value := !value * 16 + (hex_char2int s.[!i]); 
            incr i;
            incr j
          done;
          tack_utf8 !value
        end
      | 'u' -> 
        begin 
          incr i;
          let j = ref 0 and value = ref 0 in
          while 
            (!i < n) & 
            (!j < 4) &
            (String.contains "0123456789ABCDEFabcdef" s.[!i]) do
            value := !value * 16 + (hex_char2int s.[!i]); 
            incr i;
            incr j
          done;
          tack_utf8 !value
        end
      | 'U' -> 
        begin 
          incr i;
          let j = ref 0 and value = ref 0 in
          while 
            (!i < n) & 
            (!j < 8) &
            (String.contains "0123456789ABCDEFabcdef" s.[!i]) do
            value := !value * 16 + (hex_char2int s.[!i]); 
            incr i;
            incr j
          done;
          tack_utf8 !value
        end
      | 'd' -> 
        begin 
          incr i;
          let j = ref 0 and value = ref 0 in
          while 
            (!i < n) & 
            (!j < 3) &
            (String.contains "0123456789" s.[!i]) do
            value := !value * 10 + (dec_char2int s.[!i]); 
            incr i;
            incr j
          done;
          tack_utf8 !value
        end
      | 'o' -> 
        begin 
          incr i;
          let j = ref 0 and value = ref 0 in
          while 
            (!i < n) & 
            (!j < 3) &
            (String.contains "01234567" s.[!i]) do
            value := !value * 8 + (oct_char2int s.[!i]); 
            incr i;
            incr j
          done;
          tack_utf8 !value
        end
      | '0' 
      | '1' 
      | '2' 
      | '3' 
      | '4' 
      | '5' 
      | '6' 
      | '7' ->
        begin 
          let j = ref 0 and value = ref 0 in
          while 
            (!i < n) & 
            (!j < 3) &
            (String.contains "01234567" s.[!i]) do
            value := !value * 8 + (oct_char2int s.[!i]); 
            incr i;
            incr j
          done;
          tack_utf8 !value
        end


      | x -> tack_char '\\'; tack_char x;
        incr i;
    end else begin

      (* if we get a newline character, emit it
         without preceding spaces
      *)
      if s.[!i]='\n' then deferred :=0;
      tack_char s.[!i];  
      incr i
    end
  done;
  tack_string "";  (* flush any deferred spaces *)
  Buffer.contents s' 

(* this routine converts strings containing
   utf8 and/or \U \u escapes to a normalised
   ASCII form using \U and \u escapes
   for all codes in the range 0-1F, and >80
*)

@h = tangler('src/flx_string.mli')
@select(h)
val bin_char2int : char -> int
val oct_char2int : char -> int
val dec_char2int : char -> int
val hex_char2int : char -> int

val binint_of_string : string -> int
val octint_of_string : string -> int
val decint_of_string : string -> int
val hexint_of_string : string -> int

val binbig_int_of_string : string -> Big_int.big_int 
val octbig_int_of_string : string -> Big_int.big_int 
val decbig_int_of_string : string -> Big_int.big_int 
val hexbig_int_of_string : string -> Big_int.big_int 

val floating_of_string : string -> float

val unescape : string -> string
val escape_of_string : char -> string -> string
val py_dquote_of_string : string -> string
val py_quote_of_string : string -> string
val c_quote_of_string : string -> string
val utf8_of_int : int -> string
val parse_utf8 : string -> int -> int * int
val hex2 : int -> string
val hex4 : int -> string
val hex8 : int -> string

@head(1,'Internationalised Identifier support')
@h = tangler('src/flx_id.ml')
@select(h)

(* Universal Character Names in identifiers:
   Below, a table of letters acceptable in identifiers.

   Source: ISO Standard C++, Appendix E.
   Which came from ISO/IEC PDTR 10176, produced by
   ISO/IEC JTC1/SC22/WG20 (internationalisation)

   Characters must be in the range shown 
   inclusive. This list must be strictly ordered.
   
   Felix also allows 
   underscore, prime, and digits in identifiers.
   Digits must not be first.
*)
open Flx_string

let ucs_id_ranges = [
  (* ASCII *)
  (0x0041,0x005a);
  (0x0061,0x007a);

  (* Latin *)
  (0x00c0,0x00d6);
  (0x00d8,0x00f6);
  (0x00f8,0x01f5);
  (0x01fa,0x0217);
  (0x0250,0x02a8);

  (* Greek *)
  (0x0384,0x0384);
  (0x0388,0x038a);
  (0x038c,0x038c);
  (0x038e,0x03a1);
  (0x03a3,0x03ce);
  (0x03d0,0x03d6);
  (0x03da,0x03da);
  (0x03dc,0x03dc);
  (0x03de,0x03de);
  (0x03e0,0x03e0);
  (0x03e2,0x03f3);

  (* Cyrillic *)
  (0x0401,0x040d);
  (0x040f,0x044f);
  (0x0451,0x045c);
  (0x045e,0x0481);
  (0x0490,0x04c4);
  (0x04c7,0x04c4);
  (0x04cb,0x04cc);
  (0x04d0,0x04eb);
  (0x04ee,0x04f5);
  (0x04f8,0x04f9);

  (* Armenian *)
  (0x0531,0x0556);
  (0x0561,0x0587);
  (0x04d0,0x04eb);

  (* Hebrew *)
  (0x05d0,0x05ea);
  (0x05f0,0x05f4);

  (* Arabic *)
  (0x0621,0x063a);
  (0x0640,0x0652);
  (0x0670,0x06b7);
  (0x06ba,0x06be);
  (0x06c0,0x06ce);
  (0x06e5,0x06e7);

  (* Devanagari *) 
  (0x0905,0x0939);
  (0x0958,0x0962);

  (* Bengali *)
  (0x0985,0x098c);
  (0x098f,0x0990);
  (0x0993,0x09a8);
  (0x09aa,0x09b0);
  (0x09b2,0x09b2);
  (0x09b6,0x09b9);
  (0x09dc,0x09dd);
  (0x09df,0x09e1);
  (0x09f0,0x09f1);

  (* Gurmukhi *)
  (0x0a05,0x0a0a);
  (0x0a0f,0x0a10);
  (0x0a13,0x0a28);
  (0x0a2a,0x0a30);
  (0x0a32,0x0a33);
  (0x0a35,0x0a36);
  (0x0a38,0x0a39);
  (0x0a59,0x0a5c);
  (0x0a5e,0x0a5e);

  (* Gunjarati *)
  (0x0a85,0x0a8b);
  (0x0a8d,0x0a8d);
  (0x0a8f,0x0a91);
  (0x0a93,0x0aa8);
  (0x0aaa,0x0ab0);
  (0x0ab2,0x0ab3);
  (0x0ab5,0x0ab9);
  (0x0ae0,0x0ae0);

  (* Oriya *)
  (0x0b05,0x0b0c);
  (0x0b0f,0x0b10);
  (0x0b13,0x0b28);
  (0x0b2a,0x0b30);
  (0x0b32,0x0b33);
  (0x0b36,0x0b39);
  (0x0b5c,0x0b5d);
  (0x0b5f,0x0b61);

  (* Tamil *)
  (0x0b85,0x0b8a);
  (0x0b8e,0x0b90);
  (0x0b92,0x0b95);
  (0x0b99,0x0b9a);
  (0x0b9c,0x0b9c);
  (0x0b9e,0x0b9f);
  (0x0ba3,0x0ba4);
  (0x0ba8,0x0baa);
  (0x0bae,0x0bb5);
  (0x0bb7,0x0bb9);

  (* Telugu *)
  (0x0c05,0x0c0c);
  (0x0c0e,0x0c10);
  (0x0c12,0x0c28);
  (0x0c2a,0x0c33);
  (0x0c35,0x0c39);
  (0x0c60,0x0c61);

  (* Kannada *)
  (0x0c85,0x0c8c);
  (0x0c8e,0x0c90);
  (0x0c92,0x0ca8);
  (0x0caa,0x0cb3);
  (0x0cb5,0x0cb9);
  (0x0ce0,0x0ce1);

  (* Malayam *)
  (0x0d05,0x0d0c);
  (0x0d0e,0x0d10);
  (0x0d12,0x0d28);
  (0x0d2a,0x0d39);
  (0x0d60,0x0d61);

  (* Thai *)
  (0x0e01,0x0e30);
  (0x0e32,0x0e33);
  (0x0e40,0x0e46);
  (0x0e4f,0x0e5b);

  (* Lao *)
  (0x0e81,0x0e82);
  (0x0e84,0x0e84);
  (0x0e87,0x0e88);
  (0x0e8a,0x0e8a);
  (0x0e0d,0x0e0d);
  (0x0e94,0x0e97);
  (0x0e99,0x0e9f);
  (0x0ea1,0x0ea3);
  (0x0ea5,0x0ea5);
  (0x0ea7,0x0ea7);
  (0x0eaa,0x0eab);
  (0x0ead,0x0eb0);
  (0x0eb2,0x0eb3);
  (0x0ebd,0x0ebd);
  (0x0ec0,0x0ec4);
  (0x0ec6,0x0ec6);

  (* Georgian *)
  (0x10a0,0x10c5);
  (0x10d0,0x10f6);

  (* Hangul Jamo *)
  (0x1100,0x1159);
  (0x1161,0x11a2);
  (0x11a8,0x11f9);
  (0x11d0,0x11f6);

  (* Latin extensions *)
  (0x1e00,0x1e9a);
  (0x1ea0,0x1ef9);

  (* Greek extended *)
  (0x1f00,0x1f15);
  (0x1f18,0x1f1d);
  (0x1f20,0x1f45);
  (0x1f48,0x1f4d);
  (0x1f50,0x1f57);
  (0x1f59,0x1f59);
  (0x1f5b,0x1f5b);
  (0x1f5d,0x1f5d);
  (0x1f5f,0x1f7d);
  (0x1f80,0x1fb4);
  (0x1fb6,0x1fbc);
  (0x1fc2,0x1fc4);
  (0x1fc6,0x1fcc);
  (0x1fd0,0x1fd3);
  (0x1fd6,0x1fdb);
  (0x1fe0,0x1fec);
  (0x1ff2,0x1ff4);
  (0x1ff6,0x1ffc);


  (* Hiragana *)
  (0x3041,0x3094);
  (0x309b,0x309e);

  (* Katakana *)
  (0x30a1,0x30fe); 

  (* Bopmofo *)
  (0x3105,0x312c);

  (* CJK Unified Ideographs *)
  (0x4e00,0x9fa5);

  (* CJK Compatibility Ideographs *)
  (0xf900,0xfa2d);

  (* Arabic Presentation Forms *)
  (0xfb1f,0xfb36);
  (0xfb38,0xfb3c);
  (0xfb3e,0xfb3e);
  (0xfb40,0xfb41);
  (0xfb42,0xfb44);
  (0xfb46,0xfbb1);
  (0xfbd3,0xfd35);

  (* Arabic Presentation Forms-A *)
  (0xfd50,0xfd85);
  (0xfd92,0xfbc7);
  (0xfdf0,0xfdfb);

  (* Arabic Presentation Forms-B *)
  (0xfe70,0xfe72);
  (0xfe74,0xfe74);
  (0xfe76,0xfefc);

  (* Half width and Fullwidth Forms *)
  (0xff21,0xff3a);
  (0xff41,0xff5a);
  (0xff66,0xffbe);
  (0xffc2,0xffc7);
  (0xffca,0xffcf);
  (0xffd2,0xffd7);
  (0xffd2,0xffd7);
  (0xffda,0xffdc)
]

exception Found
let check_code x =
  try
    List.iter
    (fun (first, last) -> 
      (* print_endline ((hex4 first) ^"-"^(hex4 last)); *)
      if x < first
      then raise (Flx_exceptions.LexError ("Bad letter \\U"^hex8 x^" in identifier"))
      ;
      if x <= last 
      then raise Found
    )
    ucs_id_ranges
    ;
    raise (Flx_exceptions.LexError ("Bad letter \\U"^hex8 x^" in identifier"))
  with Found -> ()

let utf8_to_ucn s =
  let s' = Buffer.create 1000 in
  let n = String.length s in
  let i = ref 0 in
  while !i < n do
    let u,i' =
      if s.[!i]='\\'
      then begin
        incr i;
        if !i>n 
        then failwith ("Slosh at end of identifier " ^ s)
        else if s.[!i] = 'u' 
        then begin
          incr i;
          if n - !i < 4 
          then failwith 
          (
            "\\u at col "^
            string_of_int !i ^
            " must be followed by 4 hex digits"
          )
          else 
            let u = hexint_of_string (String.sub s !i 4) in
            u,!i + 4
        end else if s.[!i] = 'U'
        then begin
          incr i;
          if n - !i < 8 
          then failwith 
          (
            "\\U at col "^
            string_of_int !i ^
            " must be followed by 8 hex digits"
          )
          else
            let u = Flx_string.hexint_of_string (String.sub s !i 8) in
            u,!i + 8
        end else failwith 
        (
          "Slosh in identifier '"^
          s^
          "' col "^
          string_of_int (!i+1)^
          "must be followed by u or U"
        )
      end 
      else
       parse_utf8 s !i
    in
      i := i';
      if (u <> 0x27) (* apostrophe *)
      && (u <> 0x5F) (* underscore *)
      && ((u < 0x30) or (u > 0x39)) (* digits *)
      then check_code u;
      match u with
      | x when x < 127 && x >= 0x20 ->
        Buffer.add_char s' (char_of_int x)
      | x when x<= 0xFFFF ->
        Buffer.add_string s' ("\\u" ^ hex4 x)
      | x ->
        Buffer.add_string s' ("\\U" ^ hex8 x)
  done;
  Buffer.contents s'

@h = tangler('src/flx_id.mli')
@select(h)
val ucs_id_ranges : (int * int) list
val utf8_to_ucn : string -> string

