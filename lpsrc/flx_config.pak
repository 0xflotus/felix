@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '2'
@flx_version_release = '_rc7'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch+flx_version_release
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'

@head(2,'CVS log')
$Log$
Revision 1.196  2006/06/22 07:21:29  rfistman
updated mkdemux.py. hopefully it won't be needed soon, as
  flx_demux becomes the "main" demux.

added poll ts_poll demuxer.

conditionalised demuxer usage, so linux no longer implies epoll,
and solaris no longer implies evtports. this means that older
systems will fall back to select and that we may get the rare
nice surprise of finding a system that supports an unusual
demuxer (like osx10.4 with poll) or a linux with kqueues. who knows.

Revision 1.195  2006/06/20 14:35:56  rfistman


changed archmap exception catch to all, instead of EnvironmentError,
 which wasn't being thrown by bad dict lookup which should => detect.
 still something wrong there, as cygwin is known, shouldn't need to
 be detected.

fixed optimisation/cut'n'paste error in which TARGET_* stuff got
  rebaptised as HOST_*

Revision 1.194  2006/06/19 06:55:31  idadesub
missed a quote

Revision 1.193  2006/06/19 03:26:32  idadesub
adding lookups for freebsd, netbsd, and openbsd to the archmap

Revision 1.192  2006/06/19 02:07:57  idadesub
initial support for x86 solaris

Revision 1.191  2006/06/16 17:11:54  idadesub
minor change to make sure configure is executable

Revision 1.190  2006/06/16 07:29:44  idadesub
forgot to make sure the right use was being set

Revision 1.189  2006/06/16 05:23:57  idadesub
removed the boot files so that they can be used to kickstart the build

Revision 1.188  2006/06/14 08:57:30  idadesub
now will reuse previous builders if we aren't cross compiling, resulting in
reducing the configure time by 2/3rds

Revision 1.187  2006/06/12 17:15:55  idadesub
should be catching an IndexError not an EnvironmentError

Revision 1.186  2006/06/11 19:38:14  idadesub
added support a c compiler as well
the builders have been massively refactored to reduce code duplication
renamed some functions and arguments to be clearer on intent
eliminated empty "except:" clauses. It's possible I'm not catching all the
right exceptions though.
fixed a couple bugs

Revision 1.185  2006/06/06 11:59:08  rfistman
--target had disappeared from the configure script, put it back.
still, unknown options should be an error.

Revision 1.184  2006/06/05 07:46:01  idadesub
pulled out the c++ specific code from compiler_base, and moved it into
cxx_base. then derrived ocaml from compiler_base. Then pulled some common
functionality into compiler base to reduce redundant code

Revision 1.183  2006/06/05 06:54:52  idadesub
pulling the config builders into it's own separate .ipk file as it makes
a nice config subpackage. It'll also make maintaining and upgrading the
two separate codebases a little easier to manage. Finally, it'll help me
and my attempt to get rid of all the empty try-except exception catching

Revision 1.182  2006/05/20 23:27:48  idadesub
make sure we're converting to a string first

Revision 1.181  2006/05/20 23:11:56  idadesub
turns out that "print >> sys.stderr" is python 2.0+ behavior :( rolling back
to python 1.5 compatible code

Revision 1.180  2006/05/14 09:22:20  idadesub
switched make_config.py to use getopt instead of manually parsing the
arguments

Revision 1.179  2006/05/07 08:11:17  idadesub
cleaned up the maker script and surrounding make scripts
made the flx_maker.pak completely cross platform regards to the paths. there
were a couple missed the last time this occurred.
replaced some common path operations with the python standard ops
(1.5 compatible)
replaced +os.sep+ with os.path.join calls, as it makes it a little more obvious
(to me) what exactly is going on.
this builds on my machine from a virgin build, so hopefully these changes won't
break anyone else's build

Revision 1.178  2006/04/30 02:09:37  rfistman
got rid of suckitnsee kqueue config (too complicated with pthread use)
added a quitter to ts_select_demuxer to fix crash
fixed string exception in demo web server caused by POSTs

Revision 1.177  2006/04/25 09:28:32  rfistman
added "solaris" back to list of known models. solaris build now configures

Revision 1.176  2006/04/08 03:53:44  skaller
Detect vsnprintf.. some Windows don't provide it even though
MSDN says it is available. The MS variation when available
doesn't work correctly anyhow.

Revision 1.175  2006/03/30 01:59:29  skaller
Add C prinf formatting stuff

Revision 1.174  2006/03/27 01:38:40  skaller
Add 'axioms': parse and bind (not used yet)

Revision 1.173  2006/03/25 01:27:31  skaller
Add more stuff to gmp library binding. Start phasing config.

Revision 1.172  2006/03/24 02:46:26  skaller
Change case n of m to zero origin. Looks horrible but more
consistent.

Revision 1.171  2006/03/17 17:53:42  skaller
Window mainline config.

Revision 1.170  2006/03/17 16:10:06  skaller
Added anonymous structs aka. records. a'la Ocaml.

Revision 1.169  2006/03/15 10:22:57  rfistman
fixing 64bit cl build

Revision 1.168  2006/03/15 06:28:28  skaller
Revamp build system so conditional building works better.

Revision 1.167  2006/03/14 01:05:18  skaller
Now we have interscript breaking on error some things break
the build when they shouldn't. Fixed the speed thing
to not error the build out just because the speed tests
haven't been run yet.

Revision 1.166  2006/03/10 15:48:24  skaller
Add pretty printer for C++.

Revision 1.165  2006/03/10 11:50:09  skaller
Interscript felix tangler: colour symbols, comments.

Revision 1.164  2006/03/09 17:27:12  skaller
Modularise documentation a bit: build with package system now.

Revision 1.163  2006/03/09 13:51:04  skaller
Add 2 new options to make: reqs and deps.
Reqs builds all the packages which the selected packages depend on.
Deps builds all the packages which depend on the selected packages.
Dependency is based on 'pkg_requires' field in the spkgs file.
This is fairly crude: for example the Felix compiler requires
Elkhound to run. But there is no build dependency.

Revision 1.162  2006/03/09 11:33:39  skaller
Add 'manifest' target to extract pak/ipk and product dependency
information. Write time stamps after successful build of a package,
to allow subsequent optimisation of rebuilding.

Revision 1.161  2006/03/08 22:30:49  skaller
Add requires package "flx_pthread" to module Pthread

@head(1,'configure')
A shell script to run the config step.
@select(tangler('configure'))
export PYTHONPATH=.:$PYTHONPATH
echo "Configuring Felix"
FLX_LPARCHIVE=${FLX_LPARCHIVE:-.}
PREFIX=$PREFIX
ARGS=""

grab=1
while  [ "$grab" -eq 1 ]
do
  case x$1 in
  x--prefix=*)
     #PREFIX="`echo \"$1\" | sed 's/--prefix=\(.*\)/\\1/'`"
     PREFIX=${1:9}
     shift
  ;;

  x--prefix)
    shift
    PREFIX="$1"
    shift
  ;;

  x--lparchive=*)
   FLX_LPARCHIVE=${1:12}
   shift
  ;;

  x--lparchive)
   shift
   FLX_LPARCHIVE="$1"
   shift
  ;;

  x)
    grab=0
  ;;

  x*)
    ARGS="${ARGS} $1"
    shift
  ;;

  esac
done

echo FLX_LPARCHIVE at $FLX_LPARCHIVE

rm $FLX_LPARCHIVE/lpsrc/*.cache
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_config.pak
if [ $? != 0 ]
then
  echo "ERROR EXTRACTING CONFIGURATION PROGRAM"
  exit 1
fi

python -O script/make_config.py --quiet --prefix=${PREFIX} --lparchive=$FLX_LPARCHIVE ${ARGS}
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_maker.pak
if [ $? != 0 ]
then
  echo "ERROR EXTRACTING MAKER PROGRAM"
  exit 1
fi

@select(tangler('tmp/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here

@select(tangler('tmp/xlators.py','python'))
import os
execfile('speed'+os.sep+'xlators_default.py')
execfile('config'+os.sep+'xlators_local.py')

# this table defines the actual translators
# which the performance tester will use
#
# comment out the lines you don't want,
# or add new ones if desired
#
# the translators selected by default should be available
# since they're required to build Felix .. but actually
# we preselect gcc for C compiler and ocamlopt for ocaml ..
# 
# this should really depend on the config for those things
#

# this is set up for PERSONAL USE
# this config is NOT suitable for submission to website
# you must use VERSIONED translators for submissions
#
xlators = [

# generic translators
  ('felix',mk_felix,'felix'),
  ('gcc',mk_gcc,'c'),
  ('gccopt',mk_gccopt,'c'),
  ('ocamlopt',mk_ocamlopt,'ocaml'),
  ('gnat',mk_gnat,"ada"),
  ('ghc',mk_ghc,'haskell'),
  ('gcj',mk_gcj,'java'),

# GNU C and C++ compilers
#  ('gcc-3.3',mk_gcc_3_3,'c'),
#  ('gcc-3.3-O3',mk_gcc_3_3_opt,'c'),
#  ('gcc-4.0',mk_gcc_4_0,'c'),
#  ('gcc-4.0-O3',mk_gcc_4_0_opt,'c'),
#  ('g++-3.3',mk_gpp_3_3,'c'),
#  ('g++-3.3-O3',mk_gpp_3_3_opt,'c'),
#  ('g++-4_0',mk_gpp_4_0,'c'),
#  ('g++-4.0-O3',mk_gpp_4_0_opt,'c'),

# GNU Java
#  ('gcj-4_0',mk_gcj_4_0_opt,'java'),

# GNU Ada
#  ('gnat-4.0',mk_gnat,"ada"),

# Free Pascal
#  ('fpc-2.0.0',mk_fpc_2_0_0,"pascal"),

# GNU Pascal
#  ('gpc-2.1-3.3',mk_gpc_2_1_3_3,"pascal"),

# Glasgow Haskell
#  ('ghc-6.2.2',mk_ghc_6_2_2,'haskell'),
#  ('ghc-6.4.1',mk_ghc_6_4_1,'haskell'),

# Inria's Ocaml
#  ('ocamlopt-3.08_3',mk_ocamlopt_3_08_3,'ocaml'),
#  ('ocamlc-3.08.3',mk_ocamlc_3_08_3,'ocaml'),
]

@include_file('flx_config_builders.ipk')

@h=tangler("flxbuild/__init__.py")
@select(h)
#package base

@h=tangler("flxbuild/flxutil.py")
@select(h)
# build system utility module
import os
import glob
import stat
import string
import time

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except EnvironmentError:
    t = 0
  return t

# returns the time of the newest file of a set
# if a file is missing, the time is in the future
# (since we have no record of when it was deleted,
# we assume it was vey recently :)

def newest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: return time.time()+1000.0
    m = max(m,x) 
  return m

# returns the time of the oldest file of a set
# if a file is missing, the time is before the
# birth of the universe .. well PC's anyhow :)

def oldest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: raise MakeError # missing files not allowed
    m = max(m,x) 
  return m

def fmtime(t):
    s = "%04d %02d %02d %02d %02d %02d" % (time.localtime(t)[:6])
    return s

def append_unique(s,x):
  if x not in s: return s+[x]
  else: return s

def closure1(d,i,o):
  if i not in o:
    o = o + [i]
    e = d.get(i,[])
    for k in e:
      if k not in o:
        o = closure1(d,k,o)
  return o
 
# d is a dictionary T -> T list
# s is a list
# closure (d,s) returns the closure of s wrt d
#
# normally d is a dependency map for packages 
# and s is set of root packages to be rebuilt
# result is the all the packages that need rebuild

def closure(d,s):
  o = []
  for i in s:
    o = closure1(d,i,o)
  return o

# given a map T -> T list
# return the inverse map

def invert(d):
  m = {}
  for k in d.keys():
    for v in d[k]:
      m[v] = append_unique(m.get(v,[]),k)
  return m

def erasefile(f):
  try: os.unlink(f)
  except EnvironmentError: pass

def unix2native(f):
  return string.join(string.split(f,"/"),os.sep)

def deletefile(f): 
  erasefile(unix2native(f))

def mkdirs(x):
  if x and not os.path.exists(x):
    os.makedirs(x)

def erasedir(d):
  fs = glob.glob(d+os.sep+"*")
  for f in fs: erasefile(f)
  try: os.rmdir(d)
  except EnvironmentError: pass

def filecopy(a,b):
  f = open(a)
  g = open(b,"w")
  g.write(f.read())
  g.close()
  f.close()

def filecopy2dir(a,d):
  mkdirs(d)
  base = string.split(a,os.sep)[-1]
  filecopy(a,d+os.sep+base)

def get_stdout(x):
  if os.name == "nt": # popen doesn't work on Windows
    result = os.system(x + " >tmp.out")
    fout = open("tmp.out")
    output = fout.readlines()
    fout.close()
  else:
    fout = os.popen(x,"r")
    output = fout.readlines()
    result = fout.close()
  return result,output

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except EnvironmentError: return 0

class MakeError(EnvironmentError): pass
  
@select(tangler("cpkgs/target/libgc.py"))
#    'Boehm-Demers-Weiser Conservative Garbage Collector',
#    'http://www.hpl.hp.com/personal/Hans_Boehm/gc/'
HAVE_LIBGC = TARGET_CXX.check_header_exists(xqt,"gc.h")

@select(tangler("cpkgs/target/windowsh.py"))
#    "Microsoft Windows core CAPI",
#    "http://microsoft.com"
HAVE_WINDOWS_H = TARGET_CXX.check_header_exists(xqt,"windows.h")

@select(tangler("cpkgs/target/opengl.py"))
#    'Open GL Graphics Rendering Toolkit',
#    "http://www.opengl.org"
if MACOSX:
  HAVE_OPENGL = TARGET_CXX.check_header_exists(xqt,"OpenGL"+os.sep+"gl.h")
else:
  HAVE_OPENGL = TARGET_CXX.check_header_exists(xqt,"GL"+os.sep+"gl.h")


@select(tangler("cpkgs/target/pthread.py"))
# try to use Linux getconf to find the pthread version
# Ubuntu/Breezy returns "NPTL 2.3.5"
result,output = get_stdout("getconf GNU_LIBPTHREAD_VERSION")
if result: # getconf failed
  PTHREAD_MODEL = "Unknown"
else:
  PTHREAD_MODEL = string.strip(output[0])

print "Pthread model=",PTHREAD_MODEL

@select(tangler("cpkgs/build/interscript.py"))
execfile("config"+os.sep+"build_config.py")
# see if we have interscript
try:
  cload(globals(),"iscr")
except:
  try:
    xqt("iscr")
    ISCR="iscr "
  except EnvironmentError:
    ISCR="python -O interscript"+os.sep+"bin"+os.sep+"iscr.py "
  print "Storing Interscript configuration"
  f = cwrite("iscr")
  pr(f,"#Interscript support")
  pa(f,locals(),"ISCR")
  f.close()
  cload(globals(),"iscr")


@select(tangler("cpkgs/host/pkgconfig.py"))
# see if we have pkg-config
try:
  cload(globals(),"pkgconfig")
except:
  try:
    xqt("pkg-config --version")
    HAVE_PKGCONFIG=1
  except EnvironmentError:
    HAVE_PKGCONFIG=0
  print "Storing pkgconfig configuration"
  f = cwrite("pkgconfig")
  pr(f,"#pkgconfig support")
  pa(f,locals(),"HAVE_PKGCONFIG")
  f.close()
  cload(globals(),"pkgconfig")

 
@select(tangler("cpkgs/build/python_misc.py"))
try:
  cload(globals(),"filename")
  cload(globals(),"python")
except:
  PYTHON_VERSION=sys.version
  PYTHON_OS_NAME=os.name
  PYTHON_OS_CURDIR=os.curdir
  PYTHON_OS_PARDIR=os.pardir
  PYTHON_OS_SEP=os.sep
  PYTHON_OS_PATHSEP=os.pathsep

  print "Storing Python Filename separators"
  f = cwrite("filename")
  pa(f,locals(),"PYTHON_OS_NAME")
  pa(f,locals(),"PYTHON_OS_CURDIR")
  pa(f,locals(),"PYTHON_OS_PARDIR")
  pa(f,locals(),"PYTHON_OS_SEP")
  pa(f,locals(),"PYTHON_OS_PATHSEP")
  f.close()

  print "Storing Python configuration"
  f = cwrite("python")
  pr(f,"#Python config")
  pa(f,locals(),"PYTHON_VERSION")
  f.close()
  cload(globals(),"filename")
  cload(globals(),"python")

@select(tangler("script/config_support.py"))
# must be executed in global namespace

def pr(f,x):
  print x
  f.write(x+"\n")

def pa(f,this,s):
  try:
    x = s + "=" + repr(this[s])
    pr(f,x)
  except (KeyError, EnvironmentError):
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def pne(f,s):
  try:
    x = s + "=" + repr(this[s])
    f.write(x+"\n")
  except EnvironmentError:
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def gs(x):
  r,o = get_stdout(x)
  try: o = string.strip(o[0])
  except IndexError: pass
  return r,o


def cwrite(c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  f= open(f,"w")
  return f

def cload(d,c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Loading "+f
  execfile(f,globals(),d)

@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import string
import time
import glob
import getopt
import signal # try to force ctrl-C to this process 
this = globals()

if '' not in sys.path: sys.path = [''] + sys.path
import flxbuild
from flxbuild.flxutil import *
execfile("script/config_support.py")


@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'flx_version_major',flx_version_major
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)



#---------- utilities -------------------
# We're screwed if popen doesn't work ..

def xxqt(x,print_cmd=0,print_on_error=1):
  result = os.system(x)
  if result != 0: 
    if print_on_error:
      print "FAIL:",x
    raise MakeError(x)
  else: 
    if print_cmd:
      print x

def xqt(x,print_on_error=0,print_cmd=0,print_output=0): 
 if not print_output:
   if os.name == "posix":
     x = x + " >/dev/null 2>&1"
   elif os.name == "nt":
     x = x + " >NUL"
 xxqt(x,print_cmd,print_on_error)

#----------------------------------------

# make doc directories to stop 'cp' complaining
mkdirs("config")
mkdirs("doc")
mkdirs("impldoc")
mkdirs("tut")
mkdirs("man")
mkdirs("htmlman")
 
quiet = 0
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

PREFIX=os.environ.get("PREFIX",default_prefix)
if PREFIX:
  print "Default Installation Root from environment: ",PREFIX

overrides = {}

# supported platforms

platforms = [
  "posix",
  "cygwin",
  "nocygwin",
  "mingw",
  "win32",
  "win64",
  "osx",
  "detect"
  "solaris",
  "bsd",
  "linux"
  ]

# map other names for them, obtained from
# various place like os.platform, os.system("mname -u"), etc

archmap = {
  "unix":"posix",
  "posix":"posix",
  "linux":"linux",
  "gnu/linux":"linux",
  "solaris":"solaris",
  "sunos":"solaris",
  "cygwin":"cygwin",
  "nocygwin":"nocygwin",
  "mingw":"mingw",
  "windows":"win32",
  "nt":"win32",
  "win32":"win32",
  "win64":"win64",
  "darwin":"osx",
  "freebsd":"bsd",
  "netbsd":"bsd",
  "openbsd":"bsd",
  "osx":"osx",
  "detect":"detect"
  }

# attempt to find the Felix name for the build OS
# using uname -s, or, if that fails, Python os.name
# if the final result isn't a name we recognize
# set the build_model to 'detect' to indicate C level
# testing is to be used. Note that these C tests are
# done anyhow, and may verify, refine, or otherwise
# munge this result .. however we need some initial
# indication HOW to perform these tests.

try:
  result,output = get_stdout("uname -s")  # os x uname flag (works in solaris)
  print result,output
  if result: # uname -s failed
    output = [os.name] # so use Python's idea
  output = string.lower(string.strip(output[0]))
  build_model = archmap[output]
  print "Build platform: " + build_model
# RF: EnvironmentError was not catching the the failed archmap[] lookup,
# halting the configure. What's the EnvironmentError stuff for, Erick? 
# except EnvironmentError:
except:
  print "uname -s and Python returns unknown OS type, assuming 'detect'"
  build_model = "detect"

# RF: noone seems to be using the results of this
# JS: Not yet: policy is to test it out anyhow, in case needed
#
# uname -s: kernel name "linux" on linux
# uname -n: network node name "rosella" on JS box
# uname -r: kernel-release "2.6.12-10-amd64-k8" on JS box 
# uname -v: kernel-version " #1 Thu Dec 22 11:12:06 UTC 2005" on JS box
# uname -m: machine hardware name: "x86_64" on JS box
# uname -o: operating system: "GNU/Linux" on JS box
# uname -p: OSX only? on osx reports broad cpu type (e.g. powerpc)
# not sure what it reports on intel macs. 
# machine command reports very specific cpu type, e.g. ppc7450, ppc7400

result,output = get_stdout("uname -m")
if not result:
  ARCH = string.lower(string.strip(output[0]))
else:
  ARCH = "unknown"
print "CPU=",ARCH

if build_model == 'osx':
  result,output = get_stdout("uname -p")
else:
  result,output = get_stdout("uname -o")
if not result:
  OS = string.lower(string.strip(output[0]))
else:
  OS = "unknown"

print "OS=",OS


print "Detected Build model:",build_model

host_model = None
target_model = None
run_model = None

def check_model(m):
  try:
    m = archmap[m]
  except KeyError:
    print "Unknown model '"+m+"' please choose one of:"
    for m in platforms: print " * " + m
    sys.exit(1)
  return m

SAVE_CONFIG=""
LOAD_CONFIG=""
BOOTFILE=""

include_paths=None
lib_paths=None

BUILDCC=None
HOSTCC=None
TARGETCC=None

BUILDCXX=None
HOSTCXX=None
TARGETCXX=None

FLX_LPARCHIVE=os.environ.get("FLX_LPARCHIVE",os.curdir)

ALL_PHASES=["build","host","target","run"]

PHASES = []

try:
  opts, args = getopt.getopt(sys.argv[1:], 'hvq', 
      ['help', 'verbose', 'quiet', 'force', 'refresh', 'upgrade', 
      'prefix=', 'set-int=', 'set-string=', 
      'include_paths=', 'lib_paths=',
      'build=', 'host=', 'target=', 'run=',
      'buildcc=', 'hostcc=', 'targetcc=', 'boot=', 'save-config=', 
      'load-config=', 'lparchive=', 'phase='])
      #'set-int', 
except getopt.error, e:
  sys.stderr.write(str(e) + '\n')
  sys.exit(1)

for o, a in opts:
  if o in ['-h', '--help']:
    print """\
usage: configure [options]

flags:
  -h, --help      print this help message
  -v, --verbose   print out extra debugging info
  -q, --quiet     do not print out extra debugging info

  --force
  --refresh
  --upgrade
  --prefix
  --set-int
  --set-string
  --include_paths
  --lib_paths
  --build
  --host
  --target
  --run
  --buildcc
  --hostcc
  --targetcc
  --buildcxx
  --hostcxx
  --targetcxx
  --boot
  --save-config
  --load-config
  --lparchive
  --phase
"""
    sys.exit(0)
  elif o in ['-v', '--verbose']:
    verbose = verbose + 1
  elif o in ['-q', '--quiet']:
    verbose = 0
  elif o in ['--force']:
    force = 1
  elif o in ['--refresh']:
    refresh = 1
  elif o in ['--upgrade']:
    upgrade = 1
  elif o in ['--prefix']:
    PREFIX = a
  elif o in ['--set-int']:
    v, a = string.split(a, '=', 1)
    overrides[v] = int(a)
  elif o in ['--set-string']:
    v, a = string.split(a, '=', 1)
    overrides[v] = a
  elif o in ['--include_paths']:
    include_paths = a
  elif o in ['--lib_paths']:
    lib_paths = a
  elif o in ['--build']:
    print "Specified build model", a
    build_model = check_model(a)
  elif o in ['--host']:
    print "Specified host model:", a
    host_model = check_model(a)
  elif o in ['--target']:
    print "Specified target model:", a
    target_model = check_model(a)
  elif o in ['--run']:
    print "Specified run model", a
    run_model = check_model(a)
  elif o in ['--buildcc']:
    BUILDCC = a
  elif o in ['--hostcc']:
    HOSTCC = a
  elif o in ['--targetcc']:
    TARGETCC = a
  elif o in ['--buildcxx']:
    BUILDCXX = a
  elif o in ['--hostcxx']:
    HOSTCXX = a
  elif o in ['--targetcxx']:
    TARGETCXX = a
  elif o in ['--boot']:
    BOOTFILE = a
  elif o in ['--save-config']:
    SAVE_CONFIG = a
  elif o in ['--load-config']:
    LOAD_CONFIG = a
  elif o in ['--lparchive']:
    FLX_LPARCHIVE = a
  elif o in ['--phase']:
    if a not in ALL_PHASES:
      print "UNKNOWN PHASE",a,"not in",ALL_PHASES
      sys.exit(1)
    if a not in PHASES: PHASES.append(a)
  else:
    print "UNKNOWN CONFIGURE OPTION", o, a
    sys.exit(1)

if args:
  print "UNKNOWN CONFIGURE ARGS", args
  sys.exit(1)

if PHASES == []: PHASES = ALL_PHASES

if BOOTFILE:
  try:
    execfile(BOOTFILE)
    print "Loaded",BOOTFILE
  except:
    print "Cannot execute specified bootstrap file: ", BOOTFILE
    sys.exit(1) 

if PREFIX=='': PREFIX=default_prefix
print "INSTALL PREFIX="+PREFIX
if FLX_LPARCHIVE=='': FLX_LPARCHIVE = os.curdir
print "FLX_LPARCHIVE="+FLX_LPARCHIVE

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

import flxbuild.ocaml_class
import flxbuild.gcc_class
import flxbuild.gxx_class
import flxbuild.msvcc_class
import flxbuild.msvcxx_class

#
# Detect the native build model
# 
# This model has two uses: first, to build any build time
# tools needed to assist in generating the sources
# and second, to aid in selecting the options to cross-compile
# for the chosen host and target
#

if "build" in PHASES:
  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking BUILD MODEL",build_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if build_model == "win32":
    BUILD_CC=flxbuild.msvcc_class.msvcc()
    BUILD_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    BUILD_CC=flxbuild.gcc_class.gcc()
    BUILD_CXX=flxbuild.gxx_class.gxx()

  BUILD_CC.set_options(
      COM=BUILDCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CC.check_options(xqt,get_stdout)
  BUILD_CC.report_config()
  BUILD_CC.save_options("config/build_cc.py")
  build_model=BUILD_CC.options.model

  BUILD_CXX.set_options(
      COM=BUILDCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CXX.check_options(xqt,get_stdout)
  BUILD_CXX.report_config()
  BUILD_CXX.save_options("config/build_cxx.py")
  build_model=BUILD_CXX.options.model

  try:
    mkdirs("config")

    print "Writing build config file"
    f = open("config"+os.sep+"build_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    print "WRITE STEP 0"
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    print "WRITE STEP 1"
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,'execfile("script/config_support.py")')

    pa(f,this,"build_model")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")
 
    print "WRITE STEP 2"
   
    cc = BUILD_CC.__class__.__name__
    pr(f,"BUILD_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"BUILD_CC.load_options("+repr('config'+os.sep+'build_cc.py')+")")

    cxx = BUILD_CXX.__class__.__name__
    pr(f,"BUILD_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"BUILD_CXX.load_options("+repr('config'+os.sep+'build_cxx.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"build_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"build_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"build"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "build CONFIGURING",cpkg
    execfile(cpkgf)



if "host" in PHASES:
  HOST_OCAML = flxbuild.ocaml_class.ocaml()
  HOST_OCAML.autodetect(xqt,get_stdout)
  HOST_OCAML.report_config()
  HOST_OCAML.save_options("config/ocaml_config.py")


  #
  # Now create the host model: the compiler has to run
  # on the build machine, but can cross compile for
  # the host (if so, we can build but not test Felix)
  #
  # Cross compilation of the host tools may prevent any
  # testing of the tools
  #


  if not host_model: 
    host_model=build_model
    print "Defaulting host model to build model",host_model
  if not target_model: 
    target_model = host_model
    print "Defaulting target model to host model:",target_model


  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking HOST MODEL",host_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if host_model in ["win32"]:
    HOST_CC=flxbuild.msvcc_class.msvcc()
    HOST_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    HOST_CC=flxbuild.gcc_class.gcc()
    HOST_CXX=flxbuild.gxx_class.gxx()

  HOST_CC.set_options(
      COM=HOSTCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CC.options.COM == BUILD_CC.options.COM and \
      HOST_CC.options.model == BUILD_CC.options.model and \
      HOST_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the HOST_CC'
    HOST_CC.load_options("config"+os.sep+"build_cc.py")
    HOST_CC.options.use = "host"
  else:
    HOST_CC.check_options(xqt,get_stdout)
    HOST_CC.report_config()
  HOST_CC.save_options("config"+os.sep+"host_cc.py")

  HOST_CXX.set_options(
      COM=HOSTCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CXX.options.COM == BUILD_CXX.options.COM and \
      HOST_CXX.options.model == BUILD_CXX.options.model and \
      HOST_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the HOST_CXX'
    HOST_CXX.load_options("config"+os.sep+"build_cxx.py")
    HOST_CXX.options.use = "host"
  else:
    HOST_CXX.check_options(xqt,get_stdout)
    HOST_CXX.report_config()
  HOST_CXX.save_options("config"+os.sep+"host_cxx.py")

  host_model = HOST_CXX.options.model
  try:
    mkdirs("config")

    print "Writing host config file"
    f = open("config"+os.sep+"host_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,'execfile("script/config_support.py")')

    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"host_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"host_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"host"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "host CONFIGURING",cpkg
    execfile(cpkgf)



if "target" in PHASES:
  #
  # Now create the target model: the compiler has to run
  # on the build machine, but can cross compile for
  # the target 
  #
  # cross compilation of C++ generated by Felix allows us to
  # check the generated code compiles, but not that it runs
  # [but the output is largely portable so we can still try]
  #

  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking TARGET MODEL",target_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if target_model in ["win32","win64"]:
    TARGET_CC=flxbuild.msvcc_class.msvcc()
    TARGET_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    TARGET_CC=flxbuild.gcc_class.gcc()
    TARGET_CXX=flxbuild.gxx_class.gxx()

  TARGET_CC.set_options(
      COM=TARGETCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CC.options.COM == BUILD_CC.options.COM and \
      TARGET_CC.options.model == BUILD_CC.options.model and \
      TARGET_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"build_cc.py")
    TARGET_CC.options.use = "target"
  elif \
      TARGET_CC.options.COM == HOST_CC.options.COM and \
      TARGET_CC.options.model == HOST_CC.options.model and \
      TARGET_CC.options.build == HOST_CC.options.build:
    print 'using the HOST_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"host_cc.py")
  else:
    TARGET_CC.check_options(xqt,get_stdout)
    TARGET_CC.report_config()
  TARGET_CC.save_options("config"+os.sep+"target_cc.py")

  TARGET_CXX.set_options(
      COM=TARGETCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CXX.options.COM == BUILD_CXX.options.COM and \
      TARGET_CXX.options.model == BUILD_CXX.options.model and \
      TARGET_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"build_cxx.py")
    TARGET_CXX.options.use = "target"
  elif \
      TARGET_CXX.options.COM == HOST_CXX.options.COM and \
      TARGET_CXX.options.model == HOST_CXX.options.model and \
      TARGET_CXX.options.build == HOST_CXX.options.build:
    print 'using the HOST_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"host_cxx.py")
    TARGET_CXX.options.use = "target"
     
  else:
    TARGET_CXX.check_options(xqt,get_stdout)
    TARGET_CXX.report_config()
  TARGET_CXX.save_options("config"+os.sep+"target_cxx.py")

  if target_model in ["win32","win64"]:
    FLX_SOCKLEN_T = "int"
    HAVE_PTHREADS = 0
    PTHREAD_SWITCH = ""
    HAVE_MSVC = 1
    HAVE_GNU = 0
    HAVE_KQUEUE_DEMUXER = 0 #windows doesn't have kqueues.
    # nor these. does this really need to be said?
    HAVE_POLL = 0
    HAVE_EPOLL = 0
    HAVE_EVTPORTS = 0
  else:
    FLX_SOCKLEN_T = TARGET_CXX.options.FLX_SOCKLEN_T
    HAVE_PTHREADS =  TARGET_CXX.options.HAVE_PTHREADS
    PTHREAD_SWITCH =  TARGET_CXX.options.PTHREAD_SWITCH
    HAVE_KQUEUE_DEMUXER = TARGET_CXX.options.HAVE_KQUEUE_DEMUXER
    # EH?
    HAVE_POLL = TARGET_CXX.options.HAVE_POLL
    HAVE_EPOLL = TARGET_CXX.options.HAVE_EPOLL
    HAVE_EVTPORTS = TARGET_CXX.options.HAVE_EVTPORTS
    
    HAVE_MSVC = 0
    HAVE_GNU = 1

  # target model switches
  CYGWIN = TARGET_CXX.options.CYGWIN
  MACOSX = TARGET_CXX.options.MACOSX
  WIN32 =  TARGET_CXX.options.WIN32
  WIN64 =  TARGET_CXX.options.WIN32
  LINUX =  TARGET_CXX.options.LINUX
  SOLARIS =  TARGET_CXX.options.SOLARIS
  POSIX =  TARGET_CXX.options.POSIX
  BSD =  TARGET_CXX.options.BSD

  target_model = TARGET_CXX.options.model
  if not run_model: 
    run_model = target_model
    print "Defaulting run model to target model:",run_model

  SUPPORT_DYNAMIC_LOADING = TARGET_CXX.options.SUPPORT_DYNAMIC_LOADING

  if SUPPORT_DYNAMIC_LOADING:
    DEFAULT_LINK_MODEL="dynamic"
  else:
    DEFAULT_LINK_MODEL="static"


  try:
    mkdirs("config")

    print "Writing main config file"
    f = open("config"+os.sep+"config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"try:")
    pr(f,"  execfile('config/config_bootstrap.py')")
    pr(f,"except: pass")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,'execfile("script/config_support.py")')

    pr(f,"")
    pr(f,"#User configurable section")
    pa(f,this,"SUPPORT_DYNAMIC_LOADING")
    pr(f,"SUPPORT_STATIC_LINKAGE = 1")
    pa(f,this,"DEFAULT_LINK_MODEL")
    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"target_model")
    pa(f,this,"run_model")
    pa(f,this,"CYGWIN")
    pa(f,this,"MACOSX")
    pa(f,this,"HAVE_KQUEUE_DEMUXER")
    pa(f,this,"HAVE_POLL")
    pa(f,this,"HAVE_EPOLL")
    pa(f,this,"HAVE_EVTPORTS")
    pa(f,this,"WIN32")
    pa(f,this,"WIN64")
    pa(f,this,"POSIX")
    pa(f,this,"SOLARIS")
    pa(f,this,"BSD")
    pa(f,this,"LINUX")
    pa(f,this,"PREFIX")
    pa(f,this,"FLX_SOCKLEN_T")
    pa(f,this,"HAVE_PTHREADS")
    pa(f,this,"PTHREAD_SWITCH")
    pa(f,this,"HAVE_PKGCONFIG")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")
    cc = TARGET_CC.__class__.__name__
    pr(f,"TARGET_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"TARGET_CC.load_options("+repr('config'+os.sep+'target_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    cxx = TARGET_CXX.__class__.__name__
    pr(f,"TARGET_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"TARGET_CXX.load_options("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"")
    pa(f,this,"HAVE_GNU")
    pr(f,"FLXCC_CPP='cpp '")
    pa(f,this,"HAVE_MSVC")
    pr(f,"# HACK to get all the target variables into global namespace")
    pr(f,"execfile("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
    f.close()
    if BOOTFILE:
      print "Copying bootfile :  "+ BOOTFILE
      filecopy(BOOTFILE,"config"+os.sep+"config_bootstrap.py")
  except EnvironmentError:
    print "Unable to create config"+os.sep+"config.py"
    sys.exit(1)

  print "Created config"+os.sep+"config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"target"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "target CONFIGURING",cpkg
    execfile(cpkgf)

@h = tangler('config/flx_data.py')
@select(h)
import os
execfile("config"+os.sep+"config.py")

cpp_keywords = [
  'asm',
  'auto',
  'bool',
  'break',
  'case',
  'catch',
  'char'
  'class',
  'const',
  'const_cast',
  'continue',
  'default',
  'delete',
  'do',
  'double',
  'dynamic_cast',
  'else',
  'enum',
  'explicit',
  'extern',
  'false',
  'float',
  'for',
  'friend',
  'goto',
  'if',
  'inline',
  'int',
  'long',
  'mutable',
  'namespace',
  'new',
  'operator',
  'private',
  'protected',
  'public',
  'register',
  'reinterpret_cast',
  'return',
  'short',
  'signed',
  'sizeof',
  'static',
  'static_cast',
  'struct',
  'switch',
  'template',
  'this',
  'throw',
  'true',
  'try',
  'typedef',
  'typeid',
  'typename',
  'union',
  'unsigned',
  'using',
  'virtual',
  'void',
  'volatile',
  'wchar_t',
  'while',
  ]

flx_expr_terminator_keywords = [
    ("all", "ALL"),
    ("assert", "ASSERT"),
    ("axiom", "AXIOM"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("class", "CLASS"),
    ("comment", "COMMENT_KEYWORD"),
    ("compound", "COMPOUND"),
    ("const", "CONST"),
    ("cclass", "CCLASS"),
    ("cstruct", "CSTRUCT"),
    ("ctor", "CTOR"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("expect", "EXPECT"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("goto", "GOTO"),
    ("header", "HEADER"),
    ("ident", "IDENT"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("module", "MODULE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("open","OPEN"),
    ("package", "PACKAGE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
#    ("public", "PUBLIC"),
#    ("publish", "PUBLISH"),
    ("reduce", "REDUCE"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("struct", "STRUCT"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("type", "TYPE"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("when", "WHEN"),
#    ("whilst", "WHILST"),
    ("with", "WITH"),
#    ("until", "UNTIL"),
    ("_", "UNDERSCORE"),
    ("_gc_pointer", "GC_POINTER"),
    ("_svc", "SVC"),
    ("_deref", "DEREF"),
  ]

flx_other_keywords = [
    ("and", "AND"),
    ("as", "AS"),
    ("callback", "CALLBACK"),
    ("code", "CODE"),
    ("if", "IF"),
    ("isin", "ISIN"),
    ("match", "MATCH"),
    ("noexpand", "NOEXPAND"),
    ("of", "OF"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("the", "THE"),
    ("typematch", "TYPEMATCH"),
  ]

flx_parser_keywords = [
    ("expr","EXPRESSION"),
    ("float_literal", "FLOAT_LITERAL"),
    ("integer_literal", "INTEGER_LITERAL"),
    ("string_literal", "STRING_LITERAL"),
    ("statement", "STATEMENT"),
    ("statements", "STATEMENTS"),
  ]

flx_keywords = flx_expr_terminator_keywords + flx_other_keywords

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
    ("HASH","#"),
  ]

flx_2_char_syms = [
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),

    ("LSQANGLE","[<"),
    ("RSQANGLE",">]"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),

    ("AMPERAMPER","&&"),
    ("VBARVBAR","||"),
    ("SLOSHAMPER","\\\\&"),
    ("SLOSHVBAR","\\\\|"),
    ("SLOSHCIRCUMFLEX","\\\\^"),
    ("HASHBANG","#!"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
    ("DOTRIGHTARROW",".->"),
    ("LONGRIGHTARROW","-->"),
    ("PARSE_ACTION","=>#"),
    ("HASHBANGSLASH","#!/"),
  ]

flx_syms = flx_1_char_syms + flx_2_char_syms + flx_3_char_syms

rmap = {}

tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress" : "void volatile*",
  "caddress" : "void const*",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if TARGET_CXX.options.HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if TARGET_CXX.options.HAVE_LONGDOUBLE:
   tmap["ldouble"]="long double"
else:
   tmap["ldouble"]="double"

if TARGET_CXX.options.HAVE_LONGLONG:
   tmap["vlong"]="long long"
   tmap["uvlong"]="unsigned long long"
else:
   tmap["vlong"]="long"
   tmap["uvlong"]="unsigned long"

if TARGET_CXX.options.HAVE_STDINT:
   tmap["int8"]="int8_t"
   tmap["uint8"]="uint8_t"
   tmap["int16"]="int16_t"
   tmap["uint16"]="uint16_t"
   tmap["int32"]="int32_t"
   tmap["uint32"]="uint32_t"
   tmap["int64"]="int64_t"
   tmap["uint64"]="uint64_t"

   # requirements
   rmap["int8"]="c99_stdint_h"
   rmap["uint8"]="c99_stdint_h"
   rmap["int16"]="c99_stdint_h"
   rmap["uint16"]="c99_stdint_h"
   rmap["int32"]="c99_stdint_h"
   rmap["uint32"]="c99_stdint_h"
   rmap["int64"]="c99_stdint_h"
   rmap["uint64"]="c99_stdint_h"
else:
   tmap["int8"]="signed char"
   tmap["uint8"]="unsigned char"
   sizes = { 
     TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
     TARGET_CXX.options.SIZEOF_INT*8: "int",
     TARGET_CXX.options.SIZEOF_LONG*8 : "long",
   }
   if TARGET_CXX.options.HAVE_LONGLONG:
     sizes[TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
   for size in [16,32,64]:
     try:
       t = sizes[size]
       tmap["int"+str(size)]=t
       tmap["uint"+str(size)]="unsigned " + t
     except KeyError:
       tmap["int"+str(size)]="emul_int"+str(size)
       tmap["uint"+str(size)]="emul_uint"+str(size)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

@head(1,'Finish up')
Just cleaning up script now.
@try:
   os.system('chmod u+x configure')
 except:pass
