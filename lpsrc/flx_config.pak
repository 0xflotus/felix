@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '3'
@flx_version_release = '_rc1'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch+flx_version_release
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'


@head(2,'CVS log')
$Log$
Revision 1.230  2006/08/13 04:11:25  idadesub
fixed detecting int64 on machines without stdint.h
retabbed some python code

Revision 1.229  2006/08/12 17:04:05  skaller
Fix CVS confusion about this file.

Revision 1.228  2006/08/12 14:41:53  skaller
Revert the ALIAS changes because they didn't work, leaves an
open problem on Solaris with intptr etc.
Rewrite pthread stuff to use a portable interface, using a
wrapper which also catches exceptions which would otherwise
try to escape the thread.

Revision 1.227  2006/08/11 07:37:17  idadesub
use tmap instead of the ALIAS's, as occasionally an alias doesn't exist,
such as intmax on solaris

Revision 1.226  2006/08/11 05:49:21  idadesub
make sure we use the right size to lookup the void pointer aliases

Revision 1.225  2006/08/11 00:45:48  skaller
Add (u)intptr and (u)intmax aliases (because I documented them :)

Revision 1.224  2006/08/09 09:56:13  skaller
Change release version to '_rc1'

Revision 1.223  2006/08/09 04:26:38  skaller
Resolve conflict in Erick's quick patches and mine.

Revision 1.222  2006/08/09 03:45:04  idadesub
there were a couple bugs in skaller's last commit. this should fix them
enough to run on my machine :)

Revision 1.221  2006/08/09 03:09:07  skaller
Add quiet flag to plugins etc to tone down output more.

Revision 1.220  2006/08/08 16:26:43  idadesub
made sure that we define verbose in make_config.py
allowed Tee to have specified what stdout to use, instead of the now default
sys.stdout

Revision 1.219  2006/08/07 15:14:31  skaller
Head moves to 1.1.3_rc1

Revision 1.218  2006/08/04 08:59:49  skaller
Commit CVS to version 1.1.2

Revision 1.217  2006/08/02 15:11:42  skaller
Fix result inversion in make script, so None is also considered
as false.

Revision 1.216  2006/07/31 12:45:17  skaller
Add _gc_type t type qualifier which tells that t is an allocable
type and requires a shape. Add magic substitution encoding @?n
which refers to the shape of the n'th type argument.
Fixed faulty declaration of C++ array new operator used
for allocation of a gc scannable array. Provided type
Varray::varray[t] for variable length array, this is only
a first cut: it's actually an immobile bounded length
array with size variable up to the bound.

Revision 1.215  2006/07/25 17:20:14  idadesub
this patch adds support for a unit test to fail, but not stop the entire
build. It does it by logging the output from the unit test, and storing it
if it errored. Then at the end of the maker script, there's a summarize
function that prints out any errors again. Unfortunately, I can't seem to
get this summary to include the stderr, as it's difficult to get this info
without causing deadlocks on windows.

Revision 1.214  2006/07/25 07:31:29  idadesub
fixed a couple command line arguments to make_config so that --verbose,
--include_paths and --lib_paths work
added a little more documentation to some of the command line arguments

Revision 1.213  2006/07/21 06:45:40  skaller
Config script check for epoll now actually executes
create_epoll() in case it is defined but isn't implemented.

Revision 1.212  2006/07/14 09:31:17  idadesub
we can catch LookupError to catch failed indexing

Revision 1.211  2006/07/13 17:27:38  idadesub
uses sed to split up --foo=bar type arguments for configure. Also, cleaned
up how we pass arguments to make_config.py

Revision 1.210  2006/07/12 21:05:22  idadesub
missed a export call to make it sh compatible

Revision 1.209  2006/07/12 07:20:55  idadesub
fixed so it runs with regular sh

Revision 1.208  2006/07/12 06:13:36  idadesub
we need to use bash, instead of sh on machines that don't just symlink bash
to sh

Revision 1.207  2006/07/09 05:19:14  skaller
Reinstated mkdir of tmp directory.

Revision 1.206  2006/07/08 16:04:32  rfistman

explicitly ignoring return val of SetErrorMode in flx_rtl.pak
made configure script appear executable under cygwin/bash/fat32
removed simpleline_server which didn't do anything

Revision 1.205  2006/07/05 20:25:33  skaller
Tweak speed measurements to use localised list of translators,
to avoid running too many and messing up the graph.

Revision 1.204  2006/07/05 14:34:20  skaller
Fix some tests to not repeat.

Revision 1.203  2006/07/03 15:00:04  skaller
Add -f to rm command in configure script to suppress warning.

Revision 1.202  2006/07/03 04:23:07  skaller
Allow macro process to replace into named requirements as
expressions (the expression must resolve to a qualified name)

Revision 1.201  2006/07/01 04:11:11  skaller
Add irix and irix64 as python names of posix platforms.

Revision 1.200  2006/06/28 02:59:24  skaller
Fix compiler selection for host build to check for win64 as well as win32

Revision 1.199  2006/06/26 07:23:11  skaller
Fix bug (new boot script named configure by mistake).

Revision 1.198  2006/06/26 05:30:39  skaller
Fiddle with bootup

Revision 1.197  2006/06/23 00:35:16  skaller
Upgrade release to rc8

Revision 1.196  2006/06/22 07:21:29  rfistman
updated mkdemux.py. hopefully it won't be needed soon, as
  flx_demux becomes the "main" demux.

added poll ts_poll demuxer.

conditionalised demuxer usage, so linux no longer implies epoll,
and solaris no longer implies evtports. this means that older
systems will fall back to select and that we may get the rare
nice surprise of finding a system that supports an unusual
demuxer (like osx10.4 with poll) or a linux with kqueues. who knows.

Revision 1.195  2006/06/20 14:35:56  rfistman


changed archmap exception catch to all, instead of EnvironmentError,
 which wasn't being thrown by bad dict lookup which should => detect.
 still something wrong there, as cygwin is known, shouldn't need to
 be detected.

fixed optimisation/cut'n'paste error in which TARGET_* stuff got
  rebaptised as HOST_*

Revision 1.194  2006/06/19 06:55:31  idadesub
missed a quote

Revision 1.193  2006/06/19 03:26:32  idadesub
adding lookups for freebsd, netbsd, and openbsd to the archmap

Revision 1.192  2006/06/19 02:07:57  idadesub
initial support for x86 solaris

Revision 1.191  2006/06/16 17:11:54  idadesub
minor change to make sure configure is executable

Revision 1.190  2006/06/16 07:29:44  idadesub
forgot to make sure the right use was being set

Revision 1.189  2006/06/16 05:23:57  idadesub
removed the boot files so that they can be used to kickstart the build

Revision 1.188  2006/06/14 08:57:30  idadesub
now will reuse previous builders if we aren't cross compiling, resulting in
reducing the configure time by 2/3rds

Revision 1.187  2006/06/12 17:15:55  idadesub
should be catching an IndexError not an EnvironmentError

Revision 1.186  2006/06/11 19:38:14  idadesub
added support a c compiler as well
the builders have been massively refactored to reduce code duplication
renamed some functions and arguments to be clearer on intent
eliminated empty "except:" clauses. It's possible I'm not catching all the
right exceptions though.
fixed a couple bugs

Revision 1.185  2006/06/06 11:59:08  rfistman
--target had disappeared from the configure script, put it back.
still, unknown options should be an error.

Revision 1.184  2006/06/05 07:46:01  idadesub
pulled out the c++ specific code from compiler_base, and moved it into
cxx_base. then derrived ocaml from compiler_base. Then pulled some common
functionality into compiler base to reduce redundant code

Revision 1.183  2006/06/05 06:54:52  idadesub
pulling the config builders into it's own separate .ipk file as it makes
a nice config subpackage. It'll also make maintaining and upgrading the
two separate codebases a little easier to manage. Finally, it'll help me
and my attempt to get rid of all the empty try-except exception catching

Revision 1.182  2006/05/20 23:27:48  idadesub
make sure we're converting to a string first

Revision 1.181  2006/05/20 23:11:56  idadesub
turns out that "print >> sys.stderr" is python 2.0+ behavior :( rolling back
to python 1.5 compatible code

Revision 1.180  2006/05/14 09:22:20  idadesub
switched make_config.py to use getopt instead of manually parsing the
arguments

Revision 1.179  2006/05/07 08:11:17  idadesub
cleaned up the maker script and surrounding make scripts
made the flx_maker.pak completely cross platform regards to the paths. there
were a couple missed the last time this occurred.
replaced some common path operations with the python standard ops
(1.5 compatible)
replaced +os.sep+ with os.path.join calls, as it makes it a little more obvious
(to me) what exactly is going on.
this builds on my machine from a virgin build, so hopefully these changes won't
break anyone else's build

Revision 1.178  2006/04/30 02:09:37  rfistman
got rid of suckitnsee kqueue config (too complicated with pthread use)
added a quitter to ts_select_demuxer to fix crash
fixed string exception in demo web server caused by POSTs

Revision 1.177  2006/04/25 09:28:32  rfistman
added "solaris" back to list of known models. solaris build now configures

Revision 1.176  2006/04/08 03:53:44  skaller
Detect vsnprintf.. some Windows don't provide it even though
MSDN says it is available. The MS variation when available
doesn't work correctly anyhow.

Revision 1.175  2006/03/30 01:59:29  skaller
Add C prinf formatting stuff

Revision 1.174  2006/03/27 01:38:40  skaller
Add 'axioms': parse and bind (not used yet)

Revision 1.173  2006/03/25 01:27:31  skaller
Add more stuff to gmp library binding. Start phasing config.

Revision 1.172  2006/03/24 02:46:26  skaller
Change case n of m to zero origin. Looks horrible but more
consistent.

Revision 1.171  2006/03/17 17:53:42  skaller
Window mainline config.

Revision 1.170  2006/03/17 16:10:06  skaller
Added anonymous structs aka. records. a'la Ocaml.

Revision 1.169  2006/03/15 10:22:57  rfistman
fixing 64bit cl build

Revision 1.168  2006/03/15 06:28:28  skaller
Revamp build system so conditional building works better.

Revision 1.167  2006/03/14 01:05:18  skaller
Now we have interscript breaking on error some things break
the build when they shouldn't. Fixed the speed thing
to not error the build out just because the speed tests
haven't been run yet.

Revision 1.166  2006/03/10 15:48:24  skaller
Add pretty printer for C++.

Revision 1.165  2006/03/10 11:50:09  skaller
Interscript felix tangler: colour symbols, comments.

Revision 1.164  2006/03/09 17:27:12  skaller
Modularise documentation a bit: build with package system now.

Revision 1.163  2006/03/09 13:51:04  skaller
Add 2 new options to make: reqs and deps.
Reqs builds all the packages which the selected packages depend on.
Deps builds all the packages which depend on the selected packages.
Dependency is based on 'pkg_requires' field in the spkgs file.
This is fairly crude: for example the Felix compiler requires
Elkhound to run. But there is no build dependency.

Revision 1.162  2006/03/09 11:33:39  skaller
Add 'manifest' target to extract pak/ipk and product dependency
information. Write time stamps after successful build of a package,
to allow subsequent optimisation of rebuilding.

Revision 1.161  2006/03/08 22:30:49  skaller
Add requires package "flx_pthread" to module Pthread

@head(1,'configure')
A shell script to run the config step.
@select(tangler('configure'))
#!/bin/sh
# RF: added above line to make configure script tab
# completable as exe under cygwin/fat32 fs. chmod
# does NOT work in this case.
PYTHONPATH=.:$PYTHONPATH
export PYTHONPATH
echo "Configuring Felix"
FLX_LPARCHIVE=${FLX_LPARCHIVE:-.}
PREFIX=$PREFIX
ARGS="$*" # save the arguments

while :; do
  if [ $# -lt 1 ]; then
    break
  fi

  case $1 in
  --prefix=*)
    PREFIX="`echo \"$1\" | sed 's/^--prefix=\(.*\)/\\1/'`"
  ;;

  --prefix)
    shift
    PREFIX="$1"
  ;;

  --lparchive=*)
    FLX_LPARCHIVE="`echo \"$1\" | sed 's/^--lparchive=\(.*\)/\\1/'`"
  ;;

  --lparchive)
    shift
    FLX_LPARCHIVE="$1"
  ;;

  --)
    break # respect request to stop parsing args
  ;;
  esac
  shift
done

echo FLX_LPARCHIVE at $FLX_LPARCHIVE

rm -f $FLX_LPARCHIVE/lpsrc/*.cache
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_config.pak
if [ $? != 0 ];
then
  echo "ERROR EXTRACTING CONFIGURATION PROGRAM"
  exit 1
fi

python -O script/make_config.py --quiet ${ARGS}
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_maker.pak
if [ $? != 0 ];
then
  echo "ERROR EXTRACTING MAKER PROGRAM"
  exit 1
fi

@head(1,'boot')
A shell script to run the config step.
@select(tangler('boot'))
PYTHONPATH=.:$PYTHONPATH
export PYTHONPATH
echo "Booting Felix"
FLX_LPARCHIVE=${FLX_LPARCHIVE:-.}
PREFIX=$PREFIX
ARGS=""

grab=1
while  [ "$grab" -eq 1 ]
do
  case x$1 in
  x--prefix=*)
     #PREFIX="`echo \"$1\" | sed 's/--prefix=\(.*\)/\\1/'`"
     PREFIX=${1:9}
     shift
  ;;

  x--prefix)
    shift
    PREFIX="$1"
    shift
  ;;

  x--lparchive=*)
   FLX_LPARCHIVE=${1:12}
   shift
  ;;

  x--lparchive)
   shift
   FLX_LPARCHIVE="$1"
   shift
  ;;

  x)
    grab=0
  ;;

  x*)
    ARGS="${ARGS} $1"
    shift
  ;;

  esac
done

echo FLX_LPARCHIVE at $FLX_LPARCHIVE

rm -f $FLX_LPARCHIVE/lpsrc/*.cache
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_config.pak
if [ $? != 0 ]
then
  echo "ERROR EXTRACTING CONFIGURATION PROGRAM"
  exit 1
fi

python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_maker.pak
if [ $? != 0 ]
then
  echo "ERROR EXTRACTING MAKER PROGRAM"
  exit 1
fi

./mk extract

@select(tangler('config/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here
selected_xlators = [
  'ocamlopt',
  'gccopt',
  'gnat',
  'gjc',
  'felix'
]

@include_file('flx_config_builders.ipk')

@h=tangler("flxbuild/__init__.py")
@select(h)
#package base

@h=tangler("flxbuild/flxutil.py")
@select(h)
# build system utility module
import os
import sys
import glob
import stat
import string
import time
import StringIO

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except EnvironmentError:
    t = 0
  return t

# returns the time of the newest file of a set
# if a file is missing, the time is in the future
# (since we have no record of when it was deleted,
# we assume it was vey recently :)

def newest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: return time.time()+1000.0
    m = max(m,x) 
  return m

# returns the time of the oldest file of a set
# if a file is missing, the time is before the
# birth of the universe .. well PC's anyhow :)

def oldest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: raise MakeError # missing files not allowed
    m = max(m,x) 
  return m

def fmtime(t):
    s = "%04d %02d %02d %02d %02d %02d" % (time.localtime(t)[:6])
    return s

def append_unique(s,x):
  if x not in s: return s+[x]
  else: return s

def closure1(d,i,o):
  if i not in o:
    o = o + [i]
    e = d.get(i,[])
    for k in e:
      if k not in o:
        o = closure1(d,k,o)
  return o
 
# d is a dictionary T -> T list
# s is a list
# closure (d,s) returns the closure of s wrt d
#
# normally d is a dependency map for packages 
# and s is set of root packages to be rebuilt
# result is the all the packages that need rebuild

def closure(d,s):
  o = []
  for i in s:
    o = closure1(d,i,o)
  return o

# given a map T -> T list
# return the inverse map

def invert(d):
  m = {}
  for k in d.keys():
    for v in d[k]:
      m[v] = append_unique(m.get(v,[]),k)
  return m

def erasefile(f):
  try: os.unlink(f)
  except EnvironmentError: pass

def unix2native(f):
  return string.join(string.split(f,"/"),os.sep)

def deletefile(f): 
  erasefile(unix2native(f))

def mkdirs(x):
  if x and not os.path.exists(x):
    os.makedirs(x)

def erasedir(d):
  fs = glob.glob(d+os.sep+"*")
  for f in fs: erasefile(f)
  try: os.rmdir(d)
  except EnvironmentError: pass

def filecopy(a,b):
  f = open(a)
  g = open(b,"w")
  g.write(f.read())
  g.close()
  f.close()

def filecopy2dir(a,d):
  mkdirs(d)
  base = string.split(a,os.sep)[-1]
  filecopy(a,d+os.sep+base)

def get_stdout(x):
  """We're screwed if popen doesn't work .."""

  if os.name == "nt": # popen doesn't work on Windows
    result = os.system(x + " >tmp.out")
    fout = open("tmp.out")
    output = fout.readlines()
    fout.close()
  else:
    fout = os.popen(x,"r")
    output = fout.readlines()
    result = fout.close()
  return result,output

# hack because can't yet get stderr easily from windows yet
get_stdouterr = get_stdout

def flush():
  try: 
    sys.stdin.flush()
  except: 
    pass

  sys.stdout.flush()
  sys.stderr.flush()

def xqt(x, 
    verbose=0, 
    quiet=0, 
    invert_result=0, 
    log=None):
  if log is None: log = sys.stdout

  if verbose and not quiet: log.write('%s\n' % x)
  flush()

  try:
    result, stdout = get_stdouterr(x)
  except (IOError, OSError), e:
    if not verbose: log.write('%s failed! raised exception: %s\n' % (x, e))
    flush()
    raise MakeError(x)

  flush()

  if invert_result:
    if result:
      result = 0
    else:
      result = 1

  if quiet < 2:
    if result:
      if not verbose: log.write('%s failed!\n' % x)

    if stdout and (result or (verbose and not quiet)):
      log.write(string.join(stdout, ""))

    if result and not invert_result:
      log.write("  .. ERROR CODE %s\n" % hex(result))

  flush()

  if result:
    raise MakeError(x, stdout)

  return stdout

def xqtq(x, **kwds):
  """quiet execution"""
  kwds['quiet'] = 1
  return apply(xqt, (x,), kwds)

def xqtqq(x, **kwds):
  """quiet execution"""
  kwds['verbose'] = 0
  kwds['quiet'] = 2
  return apply(xqt, (x,), kwds)

def nxqt(x, **kwds):
  """
  used when a negative result is expected (return code is supposed to be nonzero)
  used for a grep which is supposed to fail
  """
  kwds['invert_result'] = 1
  return apply(xqt, (x,), kwds)

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except EnvironmentError: return 0

class Tee:
  def __init__(self, stdout=sys.stdout):
    self.stdout = stdout
    self.file = StringIO.StringIO()

  def write(self, s, quiet=0):
    if not quiet:
      self.stdout.write(s)
    self.file.write(s)

  def getvalue(self):
    return self.file.getvalue()

class MakeError(EnvironmentError): 
  def __init__(self, command=None, stdout=[], stderr=[]):
    self.command = command
    self.stdout = string.join(stdout, "")
    self.stderr = string.join(stderr, "")

  def __str__(self):
    s = []
    if self.command is not None:
      s.append('COMMAND: ' + self.command)

    if self.stdout:
      s.append('STDOUT:\n' + self.stdout)

    if self.stderr:
      s.append('STDERR:\n' + self.stderr)

    return string.join(s, "\n")
  
@select(tangler("cpkgs/target/libgc.py"))
#    'Boehm-Demers-Weiser Conservative Garbage Collector',
#    'http://www.hpl.hp.com/personal/Hans_Boehm/gc/'
HAVE_LIBGC = TARGET_CXX.check_header_exists(shell,"gc.h")

@select(tangler("cpkgs/target/windowsh.py"))
#    "Microsoft Windows core CAPI",
#    "http://microsoft.com"
HAVE_WINDOWS_H = TARGET_CXX.check_header_exists(shell,"windows.h")

@select(tangler("cpkgs/target/opengl.py"))
#    'Open GL Graphics Rendering Toolkit',
#    "http://www.opengl.org"
if MACOSX:
  HAVE_OPENGL = TARGET_CXX.check_header_exists(shell,"OpenGL"+os.sep+"gl.h")
else:
  HAVE_OPENGL = TARGET_CXX.check_header_exists(shell,"GL"+os.sep+"gl.h")


@select(tangler("cpkgs/target/pthread.py"))
# try to use Linux getconf to find the pthread version
# Ubuntu/Breezy returns "NPTL 2.3.5"
result,output = get_stdout("getconf GNU_LIBPTHREAD_VERSION")
if result: # getconf failed
  PTHREAD_MODEL = "Unknown"
else:
  PTHREAD_MODEL = string.strip(output[0])

print "Pthread model=",PTHREAD_MODEL

@select(tangler("cpkgs/build/interscript.py"))
execfile("config"+os.sep+"build_config.py")
# see if we have interscript
try:
  cload(globals(),"iscr")
except:
  try:
    shell("iscr")
    ISCR="iscr "
  except EnvironmentError:
    ISCR="python -O interscript"+os.sep+"bin"+os.sep+"iscr.py "
  print "Storing Interscript configuration"
  f = cwrite("iscr")
  pr(f,"#Interscript support")
  pa(f,locals(),"ISCR")
  f.close()
  cload(globals(),"iscr")


@select(tangler("cpkgs/host/pkgconfig.py"))
# see if we have pkg-config
try:
  cload(globals(),"pkgconfig")
except:
  try:
    shell("pkg-config --version")
    HAVE_PKGCONFIG=1
  except EnvironmentError:
    HAVE_PKGCONFIG=0
  print "Storing pkgconfig configuration"
  f = cwrite("pkgconfig")
  pr(f,"#pkgconfig support")
  pa(f,locals(),"HAVE_PKGCONFIG")
  f.close()
  cload(globals(),"pkgconfig")

 
@select(tangler("cpkgs/build/python_misc.py"))
try:
  cload(globals(),"filename")
  cload(globals(),"python")
except:
  PYTHON_VERSION=sys.version
  PYTHON_OS_NAME=os.name
  PYTHON_OS_CURDIR=os.curdir
  PYTHON_OS_PARDIR=os.pardir
  PYTHON_OS_SEP=os.sep
  PYTHON_OS_PATHSEP=os.pathsep

  print "Storing Python Filename separators"
  f = cwrite("filename")
  pa(f,locals(),"PYTHON_OS_NAME")
  pa(f,locals(),"PYTHON_OS_CURDIR")
  pa(f,locals(),"PYTHON_OS_PARDIR")
  pa(f,locals(),"PYTHON_OS_SEP")
  pa(f,locals(),"PYTHON_OS_PATHSEP")
  f.close()

  print "Storing Python configuration"
  f = cwrite("python")
  pr(f,"#Python config")
  pa(f,locals(),"PYTHON_VERSION")
  f.close()
  cload(globals(),"filename")
  cload(globals(),"python")

@select(tangler("script/config_support.py"))
# must be executed in global namespace

def pr(f,x):
  print x
  f.write(x+"\n")

def pa(f,this,s):
  try:
    x = s + "=" + repr(this[s])
    pr(f,x)
  except (KeyError, EnvironmentError):
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def pne(f,s):
  try:
    x = s + "=" + repr(this[s])
    f.write(x+"\n")
  except EnvironmentError:
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def gs(x):
  r,o = get_stdout(x)
  try: o = string.strip(o[0])
  except IndexError: pass
  return r,o


def cwrite(c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  f= open(f,"w")
  return f

def cload(d,c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Loading "+f
  execfile(f,globals(),d)

@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import string
import time
import glob
import getopt
import signal # try to force ctrl-C to this process 
this = globals()

if '' not in sys.path: sys.path = [''] + sys.path
import flxbuild
from flxbuild.flxutil import *
execfile("script/config_support.py")


@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'flx_version_major',flx_version_major
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)

#----------------------------------------

mkdirs("misc")
mkdirs("tmp")
mkdirs("config")
mkdirs("doc")

verbose = 1
quiet = 0
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

PREFIX=os.environ.get("PREFIX",default_prefix)
if PREFIX:
  print "Default Installation Root from environment: ",PREFIX

overrides = {}

# supported platforms

platforms = [
  "posix",
  "cygwin",
  "nocygwin",
  "mingw",
  "win32",
  "win64",
  "osx",
  "detect"
  "solaris",
  "bsd",
  "linux"
  ]

# map other names for them, obtained from
# various place like os.platform, os.system("mname -u"), etc

archmap = {
  "irix":"posix",
  "irix64":"posix",
  "unix":"posix",
  "posix":"posix",
  "linux":"linux",
  "gnu/linux":"linux",
  "solaris":"solaris",
  "sunos":"solaris",
  "cygwin":"cygwin",
  "nocygwin":"nocygwin",
  "mingw":"mingw",
  "windows":"win32",
  "nt":"win32",
  "win32":"win32",
  "win64":"win64",
  "darwin":"osx",
  "freebsd":"bsd",
  "netbsd":"bsd",
  "openbsd":"bsd",
  "osx":"osx",
  "detect":"detect"
  }

# attempt to find the Felix name for the build OS
# using uname -s, or, if that fails, Python os.name
# if the final result isn't a name we recognize
# set the build_model to 'detect' to indicate C level
# testing is to be used. Note that these C tests are
# done anyhow, and may verify, refine, or otherwise
# munge this result .. however we need some initial
# indication HOW to perform these tests.

try:
  result,output = get_stdout("uname -s")  # os x uname flag (works in solaris)
  print result,output
  if result: # uname -s failed
    output = [os.name] # so use Python's idea
  output = string.lower(string.strip(output[0]))
  build_model = archmap[output]
  print "Build platform: " + build_model
# RF: EnvironmentError was not catching the the failed archmap[] lookup,
# halting the configure. What's the EnvironmentError stuff for, Erick? 
# ET: the lookup error is for the get_stdout, which should throw something
# derived from EnvironmentError, namely IOError, OSError, and MakeError.
# I just missed catching LookupError (which is a superclass of IndexError and
# KeyError)
except (EnvironmentError, LookupError):
  print "uname -s and Python returns unknown OS type, assuming 'detect'"
  build_model = "detect"

# RF: noone seems to be using the results of this
# JS: Not yet: policy is to test it out anyhow, in case needed
#
# uname -s: kernel name "linux" on linux
# uname -n: network node name "rosella" on JS box
# uname -r: kernel-release "2.6.12-10-amd64-k8" on JS box 
# uname -v: kernel-version " #1 Thu Dec 22 11:12:06 UTC 2005" on JS box
# uname -m: machine hardware name: "x86_64" on JS box
# uname -o: operating system: "GNU/Linux" on JS box
# uname -p: OSX only? on osx reports broad cpu type (e.g. powerpc)
# not sure what it reports on intel macs. 
# machine command reports very specific cpu type, e.g. ppc7450, ppc7400

result,output = get_stdout("uname -m")
if not result:
  ARCH = string.lower(string.strip(output[0]))
else:
  ARCH = "unknown"
print "CPU=",ARCH

if build_model == 'osx':
  result,output = get_stdout("uname -p")
else:
  result,output = get_stdout("uname -o")
if not result:
  OS = string.lower(string.strip(output[0]))
else:
  OS = "unknown"

print "OS=",OS


print "Detected Build model:",build_model

host_model = None
target_model = None
run_model = None

def check_model(m):
  try:
    m = archmap[m]
  except KeyError:
    print "Unknown model '"+m+"' please choose one of:"
    for m in platforms: print " * " + m
    sys.exit(1)
  return m

SAVE_CONFIG=""
LOAD_CONFIG=""
BOOTFILE=""

include_paths=[]
lib_paths=[]

BUILDCC=None
HOSTCC=None
TARGETCC=None

BUILDCXX=None
HOSTCXX=None
TARGETCXX=None

FLX_LPARCHIVE=os.environ.get("FLX_LPARCHIVE",os.curdir)

ALL_PHASES=["build","host","target","run"]

PHASES = []

try:
  opts, args = getopt.getopt(sys.argv[1:], 'hvq', 
      ['help', 'verbose', 'quiet', 'force', 'refresh', 'upgrade', 
      'prefix=', 'set-int=', 'set-string=', 
      'include_paths=', 'lib_paths=',
      'build=', 'host=', 'target=', 'run=',
      'buildcc=', 'hostcc=', 'targetcc=', 'boot=', 'save-config=', 
      'load-config=', 'lparchive=', 'phase='])
      #'set-int', 
except getopt.error, e:
  sys.stderr.write(str(e) + '\n')
  sys.exit(1)

for o, a in opts:
  if o in ['-h', '--help']:
    print """\
usage: configure [options]

flags:
  -h, --help      print this help message
  -v, --verbose   print out extra debugging info
  -q, --quiet     do not print out extra debugging info

  --force
  --refresh
  --upgrade
  --prefix        install in this prefixed directory
  --set-int
  --set-string
  --include_paths additionally search these paths for headers
  --lib_paths     additionally search these paths for libraries
  --build
  --host
  --target
  --run
  --buildcc
  --hostcc
  --targetcc
  --buildcxx
  --hostcxx
  --targetcxx
  --boot
  --save-config
  --load-config
  --lparchive
  --phase
"""
    sys.exit(0)
  elif o in ['-v', '--verbose']:
    verbose = verbose + 1
  elif o in ['-q', '--quiet']:
    verbose = 0
  elif o in ['--force']:
    force = 1
  elif o in ['--refresh']:
    refresh = 1
  elif o in ['--upgrade']:
    upgrade = 1
  elif o in ['--prefix']:
    PREFIX = a
  elif o in ['--set-int']:
    v, a = string.split(a, '=', 1)
    overrides[v] = int(a)
  elif o in ['--set-string']:
    v, a = string.split(a, '=', 1)
    overrides[v] = a
  elif o in ['--include_paths']:
    include_paths.append(a)
  elif o in ['--lib_paths']:
    lib_paths.append(a)
  elif o in ['--build']:
    print "Specified build model", a
    build_model = check_model(a)
  elif o in ['--host']:
    print "Specified host model:", a
    host_model = check_model(a)
  elif o in ['--target']:
    print "Specified target model:", a
    target_model = check_model(a)
  elif o in ['--run']:
    print "Specified run model", a
    run_model = check_model(a)
  elif o in ['--buildcc']:
    BUILDCC = a
  elif o in ['--hostcc']:
    HOSTCC = a
  elif o in ['--targetcc']:
    TARGETCC = a
  elif o in ['--buildcxx']:
    BUILDCXX = a
  elif o in ['--hostcxx']:
    HOSTCXX = a
  elif o in ['--targetcxx']:
    TARGETCXX = a
  elif o in ['--boot']:
    BOOTFILE = a
  elif o in ['--save-config']:
    SAVE_CONFIG = a
  elif o in ['--load-config']:
    LOAD_CONFIG = a
  elif o in ['--lparchive']:
    FLX_LPARCHIVE = a
  elif o in ['--phase']:
    if a not in ALL_PHASES:
      print "UNKNOWN PHASE",a,"not in",ALL_PHASES
      sys.exit(1)
    if a not in PHASES: PHASES.append(a)
  else:
    print "UNKNOWN CONFIGURE OPTION", o, a
    sys.exit(1)

if args:
  print "UNKNOWN CONFIGURE ARGS", args
  sys.exit(1)

if verbose:
  shell = xqt
else:
  shell = xqtqq

if PHASES == []: PHASES = ALL_PHASES

if BOOTFILE:
  try:
    execfile(BOOTFILE)
    print "Loaded",BOOTFILE
  except:
    print "Cannot execute specified bootstrap file: ", BOOTFILE
    sys.exit(1) 

if PREFIX=='': PREFIX=default_prefix
print "INSTALL PREFIX="+PREFIX
if FLX_LPARCHIVE=='': FLX_LPARCHIVE = os.curdir
print "FLX_LPARCHIVE="+FLX_LPARCHIVE

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

import flxbuild.ocaml_class
import flxbuild.gcc_class
import flxbuild.gxx_class
import flxbuild.msvcc_class
import flxbuild.msvcxx_class

#
# Detect the native build model
# 
# This model has two uses: first, to build any build time
# tools needed to assist in generating the sources
# and second, to aid in selecting the options to cross-compile
# for the chosen host and target
#

if "build" in PHASES:
  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking BUILD MODEL",build_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if build_model in ["win32","win64"]:
    BUILD_CC=flxbuild.msvcc_class.msvcc()
    BUILD_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    BUILD_CC=flxbuild.gcc_class.gcc()
    BUILD_CXX=flxbuild.gxx_class.gxx()

  BUILD_CC.set_options(
      COM=BUILDCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CC.check_options(shell,get_stdout)
  BUILD_CC.report_config()
  BUILD_CC.save_options("config/build_cc.py")
  build_model=BUILD_CC.options.model

  BUILD_CXX.set_options(
      COM=BUILDCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CXX.check_options(shell,get_stdout)
  BUILD_CXX.report_config()
  BUILD_CXX.save_options("config/build_cxx.py")
  build_model=BUILD_CXX.options.model

  try:
    mkdirs("config")

    print "Writing build config file"
    f = open("config"+os.sep+"build_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    print "WRITE STEP 0"
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    print "WRITE STEP 1"
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,'execfile("script/config_support.py")')

    pa(f,this,"build_model")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")
 
    print "WRITE STEP 2"
   
    cc = BUILD_CC.__class__.__name__
    pr(f,"BUILD_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"BUILD_CC.load_options("+repr('config'+os.sep+'build_cc.py')+")")

    cxx = BUILD_CXX.__class__.__name__
    pr(f,"BUILD_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"BUILD_CXX.load_options("+repr('config'+os.sep+'build_cxx.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"build_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"build_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"build"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "build CONFIGURING",cpkg
    execfile(cpkgf)



if "host" in PHASES:
  HOST_OCAML = flxbuild.ocaml_class.ocaml()
  HOST_OCAML.autodetect(shell,get_stdout)
  HOST_OCAML.report_config()
  HOST_OCAML.save_options("config/ocaml_config.py")


  #
  # Now create the host model: the compiler has to run
  # on the build machine, but can cross compile for
  # the host (if so, we can build but not test Felix)
  #
  # Cross compilation of the host tools may prevent any
  # testing of the tools
  #


  if not host_model: 
    host_model=build_model
    print "Defaulting host model to build model",host_model
  if not target_model: 
    target_model = host_model
    print "Defaulting target model to host model:",target_model


  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking HOST MODEL",host_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if host_model in ["win32","win64"]:
    HOST_CC=flxbuild.msvcc_class.msvcc()
    HOST_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    HOST_CC=flxbuild.gcc_class.gcc()
    HOST_CXX=flxbuild.gxx_class.gxx()

  HOST_CC.set_options(
      COM=HOSTCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CC.options.COM == BUILD_CC.options.COM and \
      HOST_CC.options.model == BUILD_CC.options.model and \
      HOST_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the HOST_CC'
    HOST_CC.load_options("config"+os.sep+"build_cc.py")
    HOST_CC.options.use = "host"
  else:
    HOST_CC.check_options(shell,get_stdout)
    HOST_CC.report_config()
  HOST_CC.save_options("config"+os.sep+"host_cc.py")

  HOST_CXX.set_options(
      COM=HOSTCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CXX.options.COM == BUILD_CXX.options.COM and \
      HOST_CXX.options.model == BUILD_CXX.options.model and \
      HOST_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the HOST_CXX'
    HOST_CXX.load_options("config"+os.sep+"build_cxx.py")
    HOST_CXX.options.use = "host"
  else:
    HOST_CXX.check_options(shell,get_stdout)
    HOST_CXX.report_config()
  HOST_CXX.save_options("config"+os.sep+"host_cxx.py")

  host_model = HOST_CXX.options.model
  try:
    mkdirs("config")

    print "Writing host config file"
    f = open("config"+os.sep+"host_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,'execfile("script/config_support.py")')

    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"host_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"host_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"host"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "host CONFIGURING",cpkg
    execfile(cpkgf)



if "target" in PHASES:
  #
  # Now create the target model: the compiler has to run
  # on the build machine, but can cross compile for
  # the target 
  #
  # cross compilation of C++ generated by Felix allows us to
  # check the generated code compiles, but not that it runs
  # [but the output is largely portable so we can still try]
  #

  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking TARGET MODEL",target_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if target_model in ["win32","win64"]:
    TARGET_CC=flxbuild.msvcc_class.msvcc()
    TARGET_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    TARGET_CC=flxbuild.gcc_class.gcc()
    TARGET_CXX=flxbuild.gxx_class.gxx()

  TARGET_CC.set_options(
      COM=TARGETCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CC.options.COM == BUILD_CC.options.COM and \
      TARGET_CC.options.model == BUILD_CC.options.model and \
      TARGET_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"build_cc.py")
    TARGET_CC.options.use = "target"
  elif \
      TARGET_CC.options.COM == HOST_CC.options.COM and \
      TARGET_CC.options.model == HOST_CC.options.model and \
      TARGET_CC.options.build == HOST_CC.options.build:
    print 'using the HOST_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"host_cc.py")
  else:
    TARGET_CC.check_options(shell,get_stdout)
    TARGET_CC.report_config()
  TARGET_CC.save_options("config"+os.sep+"target_cc.py")

  TARGET_CXX.set_options(
      COM=TARGETCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CXX.options.COM == BUILD_CXX.options.COM and \
      TARGET_CXX.options.model == BUILD_CXX.options.model and \
      TARGET_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"build_cxx.py")
    TARGET_CXX.options.use = "target"
  elif \
      TARGET_CXX.options.COM == HOST_CXX.options.COM and \
      TARGET_CXX.options.model == HOST_CXX.options.model and \
      TARGET_CXX.options.build == HOST_CXX.options.build:
    print 'using the HOST_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"host_cxx.py")
    TARGET_CXX.options.use = "target"
     
  else:
    TARGET_CXX.check_options(shell,get_stdout)
    TARGET_CXX.report_config()
  TARGET_CXX.save_options("config"+os.sep+"target_cxx.py")

  if target_model in ["win32","win64"]:
    FLX_SOCKLEN_T = "int"
    HAVE_PTHREADS = 0
    PTHREAD_SWITCH = ""
    HAVE_MSVC = 1
    HAVE_GNU = 0
    HAVE_KQUEUE_DEMUXER = 0 #windows doesn't have kqueues.
    # nor these. does this really need to be said?
    HAVE_POLL = 0
    HAVE_EPOLL = 0
    HAVE_EVTPORTS = 0
  else:
    FLX_SOCKLEN_T = TARGET_CXX.options.FLX_SOCKLEN_T
    HAVE_PTHREADS =  TARGET_CXX.options.HAVE_PTHREADS
    PTHREAD_SWITCH =  TARGET_CXX.options.PTHREAD_SWITCH
    HAVE_KQUEUE_DEMUXER = TARGET_CXX.options.HAVE_KQUEUE_DEMUXER
    # EH?
    HAVE_POLL = TARGET_CXX.options.HAVE_POLL
    HAVE_EPOLL = TARGET_CXX.options.HAVE_EPOLL
    HAVE_EVTPORTS = TARGET_CXX.options.HAVE_EVTPORTS
    
    HAVE_MSVC = 0
    HAVE_GNU = 1

  # target model switches
  CYGWIN = TARGET_CXX.options.CYGWIN
  MACOSX = TARGET_CXX.options.MACOSX
  WIN32 =  TARGET_CXX.options.WIN32
  WIN64 =  TARGET_CXX.options.WIN32
  LINUX =  TARGET_CXX.options.LINUX
  SOLARIS =  TARGET_CXX.options.SOLARIS
  POSIX =  TARGET_CXX.options.POSIX
  BSD =  TARGET_CXX.options.BSD

  target_model = TARGET_CXX.options.model
  if not run_model: 
    run_model = target_model
    print "Defaulting run model to target model:",run_model

  SUPPORT_DYNAMIC_LOADING = TARGET_CXX.options.SUPPORT_DYNAMIC_LOADING

  if SUPPORT_DYNAMIC_LOADING:
    DEFAULT_LINK_MODEL="dynamic"
  else:
    DEFAULT_LINK_MODEL="static"


  try:
    mkdirs("config")

    print "Writing main config file"
    f = open("config"+os.sep+"config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"try:")
    pr(f,"  execfile('config/config_bootstrap.py')")
    pr(f,"except: pass")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,'execfile("script/config_support.py")')

    pr(f,"")
    pr(f,"#User configurable section")
    pa(f,this,"SUPPORT_DYNAMIC_LOADING")
    pr(f,"SUPPORT_STATIC_LINKAGE = 1")
    pa(f,this,"DEFAULT_LINK_MODEL")
    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"target_model")
    pa(f,this,"run_model")
    pa(f,this,"CYGWIN")
    pa(f,this,"MACOSX")
    pa(f,this,"HAVE_KQUEUE_DEMUXER")
    pa(f,this,"HAVE_POLL")
    pa(f,this,"HAVE_EPOLL")
    pa(f,this,"HAVE_EVTPORTS")
    pa(f,this,"WIN32")
    pa(f,this,"WIN64")
    pa(f,this,"POSIX")
    pa(f,this,"SOLARIS")
    pa(f,this,"BSD")
    pa(f,this,"LINUX")
    pa(f,this,"PREFIX")
    pa(f,this,"FLX_SOCKLEN_T")
    pa(f,this,"HAVE_PTHREADS")
    pa(f,this,"PTHREAD_SWITCH")
    pa(f,this,"HAVE_PKGCONFIG")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")
    cc = TARGET_CC.__class__.__name__
    pr(f,"TARGET_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"TARGET_CC.load_options("+repr('config'+os.sep+'target_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    cxx = TARGET_CXX.__class__.__name__
    pr(f,"TARGET_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"TARGET_CXX.load_options("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"")
    pa(f,this,"HAVE_GNU")
    pr(f,"FLXCC_CPP='cpp '")
    pa(f,this,"HAVE_MSVC")
    pr(f,"# HACK to get all the target variables into global namespace")
    pr(f,"execfile("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
    f.close()
    if BOOTFILE:
      print "Copying bootfile :  "+ BOOTFILE
      filecopy(BOOTFILE,"config"+os.sep+"config_bootstrap.py")
  except EnvironmentError:
    print "Unable to create config"+os.sep+"config.py"
    sys.exit(1)

  print "Created config"+os.sep+"config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"target"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "target CONFIGURING",cpkg
    execfile(cpkgf)

@h = tangler('config/flx_data.py')
@select(h)
import os
execfile("config"+os.sep+"config.py")

cpp_keywords = [
  'asm',
  'auto',
  'bool',
  'break',
  'case',
  'catch',
  'char'
  'class',
  'const',
  'const_cast',
  'continue',
  'default',
  'delete',
  'do',
  'double',
  'dynamic_cast',
  'else',
  'enum',
  'explicit',
  'extern',
  'false',
  'float',
  'for',
  'friend',
  'goto',
  'if',
  'inline',
  'int',
  'long',
  'mutable',
  'namespace',
  'new',
  'operator',
  'private',
  'protected',
  'public',
  'register',
  'reinterpret_cast',
  'return',
  'short',
  'signed',
  'sizeof',
  'static',
  'static_cast',
  'struct',
  'switch',
  'template',
  'this',
  'throw',
  'true',
  'try',
  'typedef',
  'typeid',
  'typename',
  'union',
  'unsigned',
  'using',
  'virtual',
  'void',
  'volatile',
  'wchar_t',
  'while',
  ]

flx_expr_terminator_keywords = [
    ("all", "ALL"),
    ("assert", "ASSERT"),
    ("axiom", "AXIOM"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("class", "CLASS"),
    ("comment", "COMMENT_KEYWORD"),
    ("compound", "COMPOUND"),
    ("const", "CONST"),
    ("cclass", "CCLASS"),
    ("cstruct", "CSTRUCT"),
    ("ctor", "CTOR"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("expect", "EXPECT"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("goto", "GOTO"),
    ("header", "HEADER"),
    ("ident", "IDENT"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("module", "MODULE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("open","OPEN"),
    ("package", "PACKAGE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
#    ("public", "PUBLIC"),
#    ("publish", "PUBLISH"),
    ("reduce", "REDUCE"),
    ("ref", "REF"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("struct", "STRUCT"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("type", "TYPE"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("when", "WHEN"),
#    ("whilst", "WHILST"),
    ("with", "WITH"),
#    ("until", "UNTIL"),
    ("_", "UNDERSCORE"),
    ("_gc_pointer", "GC_POINTER"),
    ("_gc_type", "GC_TYPE"),
    ("_svc", "SVC"),
    ("_deref", "DEREF"),
  ]

flx_other_keywords = [
    ("and", "AND"),
    ("as", "AS"),
    ("callback", "CALLBACK"),
    ("code", "CODE"),
    ("if", "IF"),
    ("isin", "ISIN"),
    ("match", "MATCH"),
    ("noexpand", "NOEXPAND"),
    ("of", "OF"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("the", "THE"),
    ("typematch", "TYPEMATCH"),
  ]

flx_parser_keywords = [
    ("expr","EXPRESSION"),
    ("float_literal", "FLOAT_LITERAL"),
    ("integer_literal", "INTEGER_LITERAL"),
    ("string_literal", "STRING_LITERAL"),
    ("statement", "STATEMENT"),
    ("statements", "STATEMENTS"),
  ]

flx_keywords = flx_expr_terminator_keywords + flx_other_keywords

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
    ("HASH","#"),
  ]

flx_2_char_syms = [
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),

    ("LSQANGLE","[<"),
    ("RSQANGLE",">]"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),

    ("AMPERAMPER","&&"),
    ("VBARVBAR","||"),
    ("SLOSHAMPER","\\\\&"),
    ("SLOSHVBAR","\\\\|"),
    ("SLOSHCIRCUMFLEX","\\\\^"),
    ("HASHBANG","#!"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
    ("DOTRIGHTARROW",".->"),
    ("LONGRIGHTARROW","-->"),
    ("PARSE_ACTION","=>#"),
    ("HASHBANGSLASH","#!/"),
  ]

flx_syms = flx_1_char_syms + flx_2_char_syms + flx_3_char_syms

rmap = {}

tmap = {
  # addressing
  "byte"      : "unsigned char",
  "size"      : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress"  : "void volatile*",
  "caddress"  : "void const*",
  "address"   : "void *",
  "offset"    : "ptrdiff_t",
  "ptrdiff"   : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if TARGET_CXX.options.HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if TARGET_CXX.options.HAVE_LONGDOUBLE:
  tmap["ldouble"]="long double"
else:
  tmap["ldouble"]="double"

if TARGET_CXX.options.HAVE_LONGLONG:
  tmap["vlong"]="long long"
  tmap["uvlong"]="unsigned long long"
else:
  tmap["vlong"]="long"
  tmap["uvlong"]="unsigned long"

if TARGET_CXX.options.HAVE_STDINT:
  tmap["int8"]="int8_t"
  tmap["uint8"]="uint8_t"
  tmap["int16"]="int16_t"
  tmap["uint16"]="uint16_t"
  tmap["int32"]="int32_t"
  tmap["uint32"]="uint32_t"
  tmap["int64"]="int64_t"
  tmap["uint64"]="uint64_t"
  tmap["intptr"]="intptr_t"
  tmap["uintptr"]="uintptr_t"
  tmap["intmax"]="intmax_t"
  tmap["uintmax"]="uintmax_t"

  # requirements
  rmap["int8"]="c99_stdint_h"
  rmap["uint8"]="c99_stdint_h"
  rmap["int16"]="c99_stdint_h"
  rmap["uint16"]="c99_stdint_h"
  rmap["int32"]="c99_stdint_h"
  rmap["uint32"]="c99_stdint_h"
  rmap["int64"]="c99_stdint_h"
  rmap["uint64"]="c99_stdint_h"
  rmap["intptr"]="c99_stdint_h"
  rmap["uintptr"]="c99_stdint_h"
  rmap["intmax"]="c99_stdint_h"
  rmap["uintmax"]="c99_stdint_h"
else:
  tmap["int8"]="signed char"
  tmap["uint8"]="unsigned char"
  sizes = { 
    TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
    TARGET_CXX.options.SIZEOF_INT*8: "int",
    TARGET_CXX.options.SIZEOF_LONG*8 : "long",
  }
  tmap["intmax"]="long"
  tmap["uintmax"]="unsigned long"
  if TARGET_CXX.options.HAVE_LONGLONG:
    sizes[TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
    tmap["intmax"]="long long"
    tmap["uintmax"]="unsigned long long"
  for size in [16,32,64]:
    try:
      t = sizes[size]
    except KeyError:
      tmap["int"+str(size)]="emul_int"+str(size)
      tmap["uint"+str(size)]="emul_uint"+str(size)
    else:
      tmap["int"+str(size)]=t
      tmap["uint"+str(size)]="unsigned " + t
  try:
    tmap["intptr"]=sizes[TARGET_CXX.options.SIZEOF_VOIDP*8]
    tmap["uintptr"]="unsigned "+sizes[TARGET_CXX.options.SIZEOF_VOIDP*8]
  except:
    print "NO INTEGER THE SIZE OF A VOID*!"
    sys.exit(1)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

@head(1,'Finish up')
Just cleaning up script now.
@try:
   os.system('chmod u+x configure')
   os.system('chmod u+x boot')
 except:pass
