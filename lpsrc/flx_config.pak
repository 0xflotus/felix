@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '3'
@flx_version_release = '_rc1'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch+flx_version_release
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'


@head(2,'CVS log')
@head(1,'configure')
A shell script to run the config step.
@select(tangler('configure'))
#!/bin/sh
# RF: added above line to make configure script tab
# completable as exe under cygwin/fat32 fs. chmod
# does NOT work in this case.
PYTHONPATH=.:$PYTHONPATH
export PYTHONPATH
echo "Configuring Felix"
FLX_LPARCHIVE=${FLX_LPARCHIVE:-.}
PREFIX=$PREFIX
ARGS="$*" # save the arguments

while :; do
  if [ $# -lt 1 ]; then
    break
  fi

  case $1 in
  --prefix=*)
    PREFIX="`echo \"$1\" | sed 's/^--prefix=\(.*\)/\\1/'`"
  ;;

  --prefix)
    shift
    PREFIX="$1"
  ;;

  --lparchive=*)
    FLX_LPARCHIVE="`echo \"$1\" | sed 's/^--lparchive=\(.*\)/\\1/'`"
  ;;

  --lparchive)
    shift
    FLX_LPARCHIVE="$1"
  ;;

  --)
    break # respect request to stop parsing args
  ;;
  esac
  shift
done

echo FLX_LPARCHIVE at $FLX_LPARCHIVE

rm -f $FLX_LPARCHIVE/lpsrc/*.cache
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_config.pak
if [ $? != 0 ];
then
  echo "ERROR EXTRACTING CONFIGURATION PROGRAM"
  exit 1
fi

python -O script/make_config.py --quiet ${ARGS}
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_maker.pak
if [ $? != 0 ];
then
  echo "ERROR EXTRACTING MAKER PROGRAM"
  exit 1
fi

@head(1,'boot')
A shell script to run the config step.
@select(tangler('boot'))
PYTHONPATH=.:$PYTHONPATH
export PYTHONPATH
echo "Booting Felix"
FLX_LPARCHIVE=${FLX_LPARCHIVE:-.}
PREFIX=$PREFIX
ARGS=""

grab=1
while  [ "$grab" -eq 1 ]
do
  case x$1 in
  x--prefix=*)
     #PREFIX="`echo \"$1\" | sed 's/--prefix=\(.*\)/\\1/'`"
     PREFIX=${1:9}
     shift
  ;;

  x--prefix)
    shift
    PREFIX="$1"
    shift
  ;;

  x--lparchive=*)
   FLX_LPARCHIVE=${1:12}
   shift
  ;;

  x--lparchive)
   shift
   FLX_LPARCHIVE="$1"
   shift
  ;;

  x)
    grab=0
  ;;

  x*)
    ARGS="${ARGS} $1"
    shift
  ;;

  esac
done

echo FLX_LPARCHIVE at $FLX_LPARCHIVE

rm -f $FLX_LPARCHIVE/lpsrc/*.cache
python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_config.pak
if [ $? != 0 ]
then
  echo "ERROR EXTRACTING CONFIGURATION PROGRAM"
  exit 1
fi

python interscript/bin/iscr.py --break-on-error $FLX_LPARCHIVE/lpsrc/flx_maker.pak
if [ $? != 0 ]
then
  echo "ERROR EXTRACTING MAKER PROGRAM"
  exit 1
fi

./mk extract

@select(tangler('config/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here
selected_xlators = [
  'ocamlopt',
  'gccopt',
  'gnat',
  'gjc',
  'felix'
]

@include_file('flx_config_builders.ipk')

@h=tangler("flxbuild/__init__.py")
@select(h)
#package base

@h=tangler("flxbuild/flxutil.py")
@select(h)
# build system utility module
import os
import sys
import glob
import stat
import string
import time
import StringIO

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except EnvironmentError:
    t = 0
  return t

# returns the time of the newest file of a set
# if a file is missing, the time is in the future
# (since we have no record of when it was deleted,
# we assume it was vey recently :)

def newest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: return time.time()+1000.0
    m = max(m,x) 
  return m

# returns the time of the oldest file of a set
# if a file is missing, the time is before the
# birth of the universe .. well PC's anyhow :)

def oldest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: raise MakeError # missing files not allowed
    m = max(m,x) 
  return m

def fmtime(t):
    s = "%04d %02d %02d %02d %02d %02d" % (time.localtime(t)[:6])
    return s

def append_unique(s,x):
  if x not in s: return s+[x]
  else: return s

def closure1(d,i,o):
  if i not in o:
    o = o + [i]
    e = d.get(i,[])
    for k in e:
      if k not in o:
        o = closure1(d,k,o)
  return o
 
# d is a dictionary T -> T list
# s is a list
# closure (d,s) returns the closure of s wrt d
#
# normally d is a dependency map for packages 
# and s is set of root packages to be rebuilt
# result is the all the packages that need rebuild

def closure(d,s):
  o = []
  for i in s:
    o = closure1(d,i,o)
  return o

# given a map T -> T list
# return the inverse map

def invert(d):
  m = {}
  for k in d.keys():
    for v in d[k]:
      m[v] = append_unique(m.get(v,[]),k)
  return m

def erasefile(f):
  try: os.unlink(f)
  except EnvironmentError: pass

def unix2native(f):
  return string.join(string.split(f,"/"),os.sep)

def deletefile(f): 
  erasefile(unix2native(f))

def mkdirs(x):
  if x and not os.path.exists(x):
    os.makedirs(x)

def erasedir(d):
  fs = glob.glob(d+os.sep+"*")
  for f in fs: erasefile(f)
  try: os.rmdir(d)
  except EnvironmentError: pass

def filecopy(a,b):
  f = open(a)
  g = open(b,"w")
  g.write(f.read())
  g.close()
  f.close()

def filecopy2dir(a,d):
  mkdirs(d)
  base = string.split(a,os.sep)[-1]
  filecopy(a,d+os.sep+base)

def get_stdout(x):
  """We're screwed if popen doesn't work .."""

  if os.name == "nt": # popen doesn't work on Windows
    result = os.system(x + " >tmp.out")
    fout = open("tmp.out")
    output = fout.readlines()
    fout.close()
  else:
    fout = os.popen(x,"r")
    output = fout.readlines()
    result = fout.close()
  return result,output

# hack because can't yet get stderr easily from windows yet
get_stdouterr = get_stdout

def flush():
  try: 
    sys.stdin.flush()
  except: 
    pass

  sys.stdout.flush()
  sys.stderr.flush()

def xqt(x, 
    verbose=0, 
    quiet=0, 
    invert_result=0, 
    log=None):
  if log is None: log = sys.stdout

  if verbose and not quiet: log.write('%s\n' % x)
  flush()

  try:
    result, stdout = get_stdouterr(x)
  except (IOError, OSError), e:
    if not verbose: log.write('%s failed! raised exception: %s\n' % (x, e))
    flush()
    raise MakeError(x)

  flush()

  if invert_result:
    if result:
      result = 0
    else:
      result = 1

  if quiet < 2:
    if result:
      if not verbose: log.write('%s failed!\n' % x)

    if stdout and (result or (verbose and not quiet)):
      log.write(string.join(stdout, ""))

    if result and not invert_result:
      log.write("  .. ERROR CODE %s\n" % hex(result))

  flush()

  if result:
    raise MakeError(x, stdout)

  return stdout

def xqtq(x, **kwds):
  """quiet execution"""
  kwds['quiet'] = 1
  return apply(xqt, (x,), kwds)

def xqtqq(x, **kwds):
  """quiet execution"""
  kwds['verbose'] = 0
  kwds['quiet'] = 2
  return apply(xqt, (x,), kwds)

def nxqt(x, **kwds):
  """
  used when a negative result is expected (return code is supposed to be nonzero)
  used for a grep which is supposed to fail
  """
  kwds['invert_result'] = 1
  return apply(xqt, (x,), kwds)

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except EnvironmentError: return 0

class Tee:
  def __init__(self, stdout=sys.stdout):
    self.stdout = stdout
    self.file = StringIO.StringIO()

  def write(self, s, quiet=0):
    if not quiet:
      self.stdout.write(s)
    self.file.write(s)

  def getvalue(self):
    return self.file.getvalue()

class MakeError(EnvironmentError): 
  def __init__(self, command=None, stdout=[], stderr=[]):
    self.command = command
    self.stdout = string.join(stdout, "")
    self.stderr = string.join(stderr, "")

  def __str__(self):
    s = []
    if self.command is not None:
      s.append('COMMAND: ' + self.command)

    if self.stdout:
      s.append('STDOUT:\n' + self.stdout)

    if self.stderr:
      s.append('STDERR:\n' + self.stderr)

    return string.join(s, "\n")
  
@select(tangler("cpkgs/target/libgc.py"))
#    'Boehm-Demers-Weiser Conservative Garbage Collector',
#    'http://www.hpl.hp.com/personal/Hans_Boehm/gc/'
HAVE_LIBGC = TARGET_CXX.check_header_exists(shell,"gc.h")

@select(tangler("cpkgs/target/windowsh.py"))
#    "Microsoft Windows core CAPI",
#    "http://microsoft.com"
HAVE_WINDOWS_H = TARGET_CXX.check_header_exists(shell,"windows.h")

@select(tangler("cpkgs/target/opengl.py"))
#    'Open GL Graphics Rendering Toolkit',
#    "http://www.opengl.org"
if MACOSX:
  HAVE_OPENGL = TARGET_CXX.check_header_exists(shell,"OpenGL"+os.sep+"gl.h")
else:
  HAVE_OPENGL = TARGET_CXX.check_header_exists(shell,"GL"+os.sep+"gl.h")


@select(tangler("cpkgs/target/pthread.py"))
# try to use Linux getconf to find the pthread version
# Ubuntu/Breezy returns "NPTL 2.3.5"
# IEEE Std 1003.1-2001 for getconf uses the variable: _POSIX_THREADS
# if the system does not support Pthreads, getconf returns 0
# if the system supports Pthreads, getconf returns nonzero
# on RedHat Linux, "getconf _POSIX_THREADS" returns 1
# on Darwin (Mac OS X), "getconf _POSIX_THREADS" returns 200112
# result,output = get_stdout("getconf GNU_LIBPTHREAD_VERSION")
result,output = get_stdout("getconf _POSIX_THREADS")
if result: 			# getconf failed
  PTHREAD_MODEL = "Unknown"
elif int(string.strip(output[0])) != 0:
  PTHREAD_MODEL = "POSIX"
else:
  PTHREAD_MODEL = "Unknown"

print "Pthread model=",PTHREAD_MODEL


@select(tangler("cpkgs/build/interscript.py"))
execfile("config"+os.sep+"build_config.py")
# see if we have interscript
try:
  cload(globals(),"iscr")
except:
  try:
    shell("iscr")
    ISCR="iscr "
  except EnvironmentError:
    ISCR="python -O interscript"+os.sep+"bin"+os.sep+"iscr.py "
  print "Storing Interscript configuration"
  f = cwrite("iscr")
  pr(f,"#Interscript support")
  pa(f,locals(),"ISCR")
  f.close()
  cload(globals(),"iscr")


@select(tangler("cpkgs/host/pkgconfig.py"))
# see if we have pkg-config
try:
  cload(globals(),"pkgconfig")
except:
  try:
    shell("pkg-config --version")
    HAVE_PKGCONFIG=1
  except EnvironmentError:
    HAVE_PKGCONFIG=0
  print "Storing pkgconfig configuration"
  f = cwrite("pkgconfig")
  pr(f,"#pkgconfig support")
  pa(f,locals(),"HAVE_PKGCONFIG")
  f.close()
  cload(globals(),"pkgconfig")

 
@select(tangler("cpkgs/build/python_misc.py"))
try:
  cload(globals(),"filename")
  cload(globals(),"python")
except:
  PYTHON_VERSION=sys.version
  PYTHON_OS_NAME=os.name
  PYTHON_OS_CURDIR=os.curdir
  PYTHON_OS_PARDIR=os.pardir
  PYTHON_OS_SEP=os.sep
  PYTHON_OS_PATHSEP=os.pathsep

  print "Storing Python Filename separators"
  f = cwrite("filename")
  pa(f,locals(),"PYTHON_OS_NAME")
  pa(f,locals(),"PYTHON_OS_CURDIR")
  pa(f,locals(),"PYTHON_OS_PARDIR")
  pa(f,locals(),"PYTHON_OS_SEP")
  pa(f,locals(),"PYTHON_OS_PATHSEP")
  f.close()

  print "Storing Python configuration"
  f = cwrite("python")
  pr(f,"#Python config")
  pa(f,locals(),"PYTHON_VERSION")
  f.close()
  cload(globals(),"filename")
  cload(globals(),"python")

@select(tangler("script/config_support.py"))
# must be executed in global namespace

def pr(f,x):
  print x
  f.write(x+"\n")

def pa(f,this,s):
  try:
    x = s + "=" + repr(this[s])
    pr(f,x)
  except (KeyError, EnvironmentError):
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def pne(f,s):
  try:
    x = s + "=" + repr(this[s])
    f.write(x+"\n")
  except EnvironmentError:
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def gs(x):
  r,o = get_stdout(x)
  try: o = string.strip(o[0])
  except IndexError: pass
  return r,o


def cwrite(c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  f= open(f,"w")
  return f

def cload(d,c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Loading "+f
  execfile(f,globals(),d)

# needs to be conditionalised on Unix
def locate_file(fname):
  print "Try to find",fname
  n = len(fname)
  cmd = "locate " + fname
  result, lines = get_stdout(cmd)
  if not result:
    candidates = []
    for line in lines:
      candidate = string.strip(line)
      if candidate[-n:] == fname:
        candidates.append(candidate[0:-n])
    if len(candidates) == 0:
      print "Cannot find directory containing file",fname
      return None 
    if len(candidates) == 1:
      print "Found unique directory ",candidates[0],"containing file",fname
      return candidates[0]
    else:
      print "Found multiple directories containing file",fname
      s = candidates[0] 
      for k in candidates:
        print "Dir: ",k
        if len(k) < len(s): s = k
      print "Using shortest one:",s
      return s
  else:
    print "Cannot execute Unix locate command to find file",fname
    return None

@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import string
import time
import glob
import getopt
import signal # try to force ctrl-C to this process 
this = globals()

if '' not in sys.path: sys.path = [''] + sys.path
import flxbuild
from flxbuild.flxutil import *
execfile("script/config_support.py")


@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'flx_version_major',flx_version_major
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)

#----------------------------------------

mkdirs("misc")
mkdirs("tmp")
mkdirs("config")
mkdirs("doc")

verbose = 1
quiet = 0
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

PREFIX=os.environ.get("PREFIX",default_prefix)
if PREFIX:
  print "Default Installation Root from environment: ",PREFIX

overrides = {}

# supported platforms

platforms = [
  "posix",
  "cygwin",
  "nocygwin",
  "mingw",
  "win32",
  "win64",
  "osx",
  "detect"
  "solaris",
  "bsd",
  "linux"
  ]

# map other names for them, obtained from
# various place like os.platform, os.system("mname -u"), etc

archmap = {
  "irix":"posix",
  "irix64":"posix",
  "unix":"posix",
  "posix":"posix",
  "linux":"linux",
  "gnu/linux":"linux",
  "solaris":"solaris",
  "sunos":"solaris",
  "cygwin":"cygwin",
  "nocygwin":"nocygwin",
  "mingw":"mingw",
  "windows":"win32",
  "nt":"win32",
  "win32":"win32",
  "win64":"win64",
  "darwin":"osx",
  "freebsd":"bsd",
  "netbsd":"bsd",
  "openbsd":"bsd",
  "osx":"osx",
  "detect":"detect"
  }

# attempt to find the Felix name for the build OS
# using uname -s, or, if that fails, Python os.name
# if the final result isn't a name we recognize
# set the build_model to 'detect' to indicate C level
# testing is to be used. Note that these C tests are
# done anyhow, and may verify, refine, or otherwise
# munge this result .. however we need some initial
# indication HOW to perform these tests.

try:
  result,output = get_stdout("uname -s")  # os x uname flag (works in solaris)
  print result,output
  if result: # uname -s failed
    output = [os.name] # so use Python's idea
  output = string.lower(string.strip(output[0]))
  build_model = archmap[output]
  print "Build platform: " + build_model
# RF: EnvironmentError was not catching the the failed archmap[] lookup,
# halting the configure. What's the EnvironmentError stuff for, Erick? 
# ET: the lookup error is for the get_stdout, which should throw something
# derived from EnvironmentError, namely IOError, OSError, and MakeError.
# I just missed catching LookupError (which is a superclass of IndexError and
# KeyError)
except (EnvironmentError, LookupError):
  print "uname -s and Python returns unknown OS type, assuming 'detect'"
  build_model = "detect"

# RF: noone seems to be using the results of this
# JS: Not yet: policy is to test it out anyhow, in case needed
#
# uname -s: kernel name "linux" on linux
# uname -n: network node name "rosella" on JS box
# uname -r: kernel-release "2.6.12-10-amd64-k8" on JS box 
# uname -v: kernel-version " #1 Thu Dec 22 11:12:06 UTC 2005" on JS box
# uname -m: machine hardware name: "x86_64" on JS box
# uname -o: operating system: "GNU/Linux" on JS box
# uname -p: OSX only? on osx reports broad cpu type (e.g. powerpc)
# not sure what it reports on intel macs. 
# machine command reports very specific cpu type, e.g. ppc7450, ppc7400

result,output = get_stdout("uname -m")
if not result:
  ARCH = string.lower(string.strip(output[0]))
else:
  ARCH = "unknown"
print "CPU=",ARCH

if build_model == 'osx':
  result,output = get_stdout("uname -p")
else:
  result,output = get_stdout("uname -o")
if not result:
  OS = string.lower(string.strip(output[0]))
else:
  OS = "unknown"

print "OS=",OS


print "Detected Build model:",build_model

host_model = None
target_model = None
run_model = None

def check_model(m):
  try:
    m = archmap[m]
  except KeyError:
    print "Unknown model '"+m+"' please choose one of:"
    for m in platforms: print " * " + m
    sys.exit(1)
  return m

SAVE_CONFIG=""
LOAD_CONFIG=""
BOOTFILE=""

include_paths=[]
lib_paths=[]

BUILDCC=None
HOSTCC=None
TARGETCC=None

BUILDCXX=None
HOSTCXX=None
TARGETCXX=None

FLX_LPARCHIVE=os.environ.get("FLX_LPARCHIVE",os.curdir)

ALL_PHASES=["build","host","target","run"]

PHASES = []

try:
  opts, args = getopt.getopt(sys.argv[1:], 'hvq', 
      ['help', 'verbose', 'quiet', 'force', 'refresh', 'upgrade', 
      'prefix=', 'set-int=', 'set-string=', 
      'include_paths=', 'lib_paths=',
      'build=', 'host=', 'target=', 'run=',
      'buildcc=', 'hostcc=', 'targetcc=', 'boot=', 'save-config=', 
      'load-config=', 'lparchive=', 'phase='])
      #'set-int', 
except getopt.error, e:
  sys.stderr.write(str(e) + '\n')
  sys.exit(1)

for o, a in opts:
  if o in ['-h', '--help']:
    print """\
usage: configure [options]

flags:
  -h, --help      print this help message
  -v, --verbose   print out extra debugging info
  -q, --quiet     do not print out extra debugging info

  --force
  --refresh
  --upgrade
  --prefix        install in this prefixed directory
  --set-int
  --set-string
  --include_paths additionally search these paths for headers
  --lib_paths     additionally search these paths for libraries
  --build
  --host
  --target
  --run
  --buildcc
  --hostcc
  --targetcc
  --buildcxx
  --hostcxx
  --targetcxx
  --boot
  --save-config
  --load-config
  --lparchive
  --phase
"""
    sys.exit(0)
  elif o in ['-v', '--verbose']:
    verbose = verbose + 1
  elif o in ['-q', '--quiet']:
    verbose = 0
  elif o in ['--force']:
    force = 1
  elif o in ['--refresh']:
    refresh = 1
  elif o in ['--upgrade']:
    upgrade = 1
  elif o in ['--prefix']:
    PREFIX = a
  elif o in ['--set-int']:
    v, a = string.split(a, '=', 1)
    overrides[v] = int(a)
  elif o in ['--set-string']:
    v, a = string.split(a, '=', 1)
    overrides[v] = a
  elif o in ['--include_paths']:
    include_paths.append(a)
  elif o in ['--lib_paths']:
    lib_paths.append(a)
  elif o in ['--build']:
    print "Specified build model", a
    build_model = check_model(a)
  elif o in ['--host']:
    print "Specified host model:", a
    host_model = check_model(a)
  elif o in ['--target']:
    print "Specified target model:", a
    target_model = check_model(a)
  elif o in ['--run']:
    print "Specified run model", a
    run_model = check_model(a)
  elif o in ['--buildcc']:
    BUILDCC = a
  elif o in ['--hostcc']:
    HOSTCC = a
  elif o in ['--targetcc']:
    TARGETCC = a
  elif o in ['--buildcxx']:
    BUILDCXX = a
  elif o in ['--hostcxx']:
    HOSTCXX = a
  elif o in ['--targetcxx']:
    TARGETCXX = a
  elif o in ['--boot']:
    BOOTFILE = a
  elif o in ['--save-config']:
    SAVE_CONFIG = a
  elif o in ['--load-config']:
    LOAD_CONFIG = a
  elif o in ['--lparchive']:
    FLX_LPARCHIVE = a
  elif o in ['--phase']:
    if a not in ALL_PHASES:
      print "UNKNOWN PHASE",a,"not in",ALL_PHASES
      sys.exit(1)
    if a not in PHASES: PHASES.append(a)
  else:
    print "UNKNOWN CONFIGURE OPTION", o, a
    sys.exit(1)

if args:
  print "UNKNOWN CONFIGURE ARGS", args
  sys.exit(1)

if verbose:
  shell = xqt
else:
  shell = xqtqq

if PHASES == []: PHASES = ALL_PHASES

if BOOTFILE:
  try:
    execfile(BOOTFILE)
    print "Loaded",BOOTFILE
  except:
    print "Cannot execute specified bootstrap file: ", BOOTFILE
    sys.exit(1) 

if PREFIX=='': PREFIX=default_prefix
print "INSTALL PREFIX="+PREFIX
if FLX_LPARCHIVE=='': FLX_LPARCHIVE = os.curdir
print "FLX_LPARCHIVE="+FLX_LPARCHIVE

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

import flxbuild.ocaml_class
import flxbuild.gcc_class
import flxbuild.gxx_class
import flxbuild.msvcc_class
import flxbuild.msvcxx_class

#
# Detect the native build model
# 
# This model has two uses: first, to build any build time
# tools needed to assist in generating the sources
# and second, to aid in selecting the options to cross-compile
# for the chosen host and target
#

if "build" in PHASES:
  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking BUILD MODEL",build_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if build_model in ["win32","win64"]:
    BUILD_CC=flxbuild.msvcc_class.msvcc()
    BUILD_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    BUILD_CC=flxbuild.gcc_class.gcc()
    BUILD_CXX=flxbuild.gxx_class.gxx()

  BUILD_CC.set_options(
      COM=BUILDCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CC.check_options(shell,get_stdout)
  BUILD_CC.report_config()
  BUILD_CC.save_options("config/build_cc.py")
  build_model=BUILD_CC.options.model

  BUILD_CXX.set_options(
      COM=BUILDCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CXX.check_options(shell,get_stdout)
  BUILD_CXX.report_config()
  BUILD_CXX.save_options("config/build_cxx.py")
  build_model=BUILD_CXX.options.model

  try:
    mkdirs("config")

    print "Writing build config file"
    f = open("config"+os.sep+"build_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    print "WRITE STEP 0"
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    print "WRITE STEP 1"
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,'execfile("script/config_support.py")')

    pa(f,this,"build_model")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")
 
    print "WRITE STEP 2"
   
    cc = BUILD_CC.__class__.__name__
    pr(f,"BUILD_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"BUILD_CC.load_options("+repr('config'+os.sep+'build_cc.py')+")")

    cxx = BUILD_CXX.__class__.__name__
    pr(f,"BUILD_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"BUILD_CXX.load_options("+repr('config'+os.sep+'build_cxx.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"build_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"build_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"build"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "build CONFIGURING",cpkg
    execfile(cpkgf)



if "host" in PHASES:
  HOST_OCAML = flxbuild.ocaml_class.ocaml()
  HOST_OCAML.autodetect(shell,get_stdout)
  HOST_OCAML.report_config()
  HOST_OCAML.save_options("config/ocaml_config.py")


  #
  # Now create the host model: the compiler has to run
  # on the build machine, but can cross compile for
  # the host (if so, we can build but not test Felix)
  #
  # Cross compilation of the host tools may prevent any
  # testing of the tools
  #


  if not host_model: 
    host_model=build_model
    print "Defaulting host model to build model",host_model
  if not target_model: 
    target_model = host_model
    print "Defaulting target model to host model:",target_model


  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking HOST MODEL",host_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if host_model in ["win32","win64"]:
    HOST_CC=flxbuild.msvcc_class.msvcc()
    HOST_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    HOST_CC=flxbuild.gcc_class.gcc()
    HOST_CXX=flxbuild.gxx_class.gxx()

  HOST_CC.set_options(
      COM=HOSTCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CC.options.COM == BUILD_CC.options.COM and \
      HOST_CC.options.model == BUILD_CC.options.model and \
      HOST_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the HOST_CC'
    HOST_CC.load_options("config"+os.sep+"build_cc.py")
    HOST_CC.options.use = "host"
  else:
    HOST_CC.check_options(shell,get_stdout)
    HOST_CC.report_config()
  HOST_CC.save_options("config"+os.sep+"host_cc.py")

  HOST_CXX.set_options(
      COM=HOSTCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CXX.options.COM == BUILD_CXX.options.COM and \
      HOST_CXX.options.model == BUILD_CXX.options.model and \
      HOST_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the HOST_CXX'
    HOST_CXX.load_options("config"+os.sep+"build_cxx.py")
    HOST_CXX.options.use = "host"
  else:
    HOST_CXX.check_options(shell,get_stdout)
    HOST_CXX.report_config()
  HOST_CXX.save_options("config"+os.sep+"host_cxx.py")

  host_model = HOST_CXX.options.model
  try:
    mkdirs("config")

    print "Writing host config file"
    f = open("config"+os.sep+"host_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,'execfile("script/config_support.py")')

    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"host_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"host_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"host"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "host CONFIGURING",cpkg
    execfile(cpkgf)



if "target" in PHASES:
  #
  # Now create the target model: the compiler has to run
  # on the build machine, but can cross compile for
  # the target 
  #
  # cross compilation of C++ generated by Felix allows us to
  # check the generated code compiles, but not that it runs
  # [but the output is largely portable so we can still try]
  #

  print 
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking TARGET MODEL",target_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if target_model in ["win32","win64"]:
    TARGET_CC=flxbuild.msvcc_class.msvcc()
    TARGET_CXX=flxbuild.msvcxx_class.msvcxx()
  else:
    TARGET_CC=flxbuild.gcc_class.gcc()
    TARGET_CXX=flxbuild.gxx_class.gxx()

  TARGET_CC.set_options(
      COM=TARGETCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CC.options.COM == BUILD_CC.options.COM and \
      TARGET_CC.options.model == BUILD_CC.options.model and \
      TARGET_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"build_cc.py")
    TARGET_CC.options.use = "target"
  elif \
      TARGET_CC.options.COM == HOST_CC.options.COM and \
      TARGET_CC.options.model == HOST_CC.options.model and \
      TARGET_CC.options.build == HOST_CC.options.build:
    print 'using the HOST_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"host_cc.py")
  else:
    TARGET_CC.check_options(shell,get_stdout)
    TARGET_CC.report_config()
  TARGET_CC.save_options("config"+os.sep+"target_cc.py")

  TARGET_CXX.set_options(
      COM=TARGETCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CXX.options.COM == BUILD_CXX.options.COM and \
      TARGET_CXX.options.model == BUILD_CXX.options.model and \
      TARGET_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"build_cxx.py")
    TARGET_CXX.options.use = "target"
  elif \
      TARGET_CXX.options.COM == HOST_CXX.options.COM and \
      TARGET_CXX.options.model == HOST_CXX.options.model and \
      TARGET_CXX.options.build == HOST_CXX.options.build:
    print 'using the HOST_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"host_cxx.py")
    TARGET_CXX.options.use = "target"
     
  else:
    TARGET_CXX.check_options(shell,get_stdout)
    TARGET_CXX.report_config()
  TARGET_CXX.save_options("config"+os.sep+"target_cxx.py")

  if target_model in ["win32","win64"]:
    FLX_SOCKLEN_T = "int"
    HAVE_PTHREADS = 0
    PTHREAD_SWITCH = ""
    HAVE_MSVC = 1
    HAVE_GNU = 0
    HAVE_KQUEUE_DEMUXER = 0 #windows doesn't have kqueues.
    # nor these. does this really need to be said?
    HAVE_POLL = 0
    HAVE_EPOLL = 0
    HAVE_EVTPORTS = 0
  else:
    FLX_SOCKLEN_T = TARGET_CXX.options.FLX_SOCKLEN_T
    HAVE_PTHREADS =  TARGET_CXX.options.HAVE_PTHREADS
    PTHREAD_SWITCH =  TARGET_CXX.options.PTHREAD_SWITCH
    HAVE_KQUEUE_DEMUXER = TARGET_CXX.options.HAVE_KQUEUE_DEMUXER
    # EH?
    HAVE_POLL = TARGET_CXX.options.HAVE_POLL
    HAVE_EPOLL = TARGET_CXX.options.HAVE_EPOLL
    HAVE_EVTPORTS = TARGET_CXX.options.HAVE_EVTPORTS
    
    HAVE_MSVC = 0
    HAVE_GNU = 1

  # target model switches
  CYGWIN = TARGET_CXX.options.CYGWIN
  MACOSX = TARGET_CXX.options.MACOSX
  WIN32 =  TARGET_CXX.options.WIN32
  WIN64 =  TARGET_CXX.options.WIN32
  LINUX =  TARGET_CXX.options.LINUX
  SOLARIS =  TARGET_CXX.options.SOLARIS
  POSIX =  TARGET_CXX.options.POSIX
  BSD =  TARGET_CXX.options.BSD

  target_model = TARGET_CXX.options.model
  if not run_model: 
    run_model = target_model
    print "Defaulting run model to target model:",run_model

  SUPPORT_DYNAMIC_LOADING = TARGET_CXX.options.SUPPORT_DYNAMIC_LOADING

  if SUPPORT_DYNAMIC_LOADING:
    DEFAULT_LINK_MODEL="dynamic"
  else:
    DEFAULT_LINK_MODEL="static"


  try:
    mkdirs("config")

    print "Writing main config file"
    f = open("config"+os.sep+"config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"try:")
    pr(f,"  execfile('config/config_bootstrap.py')")
    pr(f,"except: pass")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,'execfile("script/config_support.py")')

    pr(f,"")
    pr(f,"#User configurable section")
    pa(f,this,"SUPPORT_DYNAMIC_LOADING")
    pr(f,"SUPPORT_STATIC_LINKAGE = 1")
    pa(f,this,"DEFAULT_LINK_MODEL")
    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"target_model")
    pa(f,this,"run_model")
    pa(f,this,"CYGWIN")
    pa(f,this,"MACOSX")
    pa(f,this,"HAVE_KQUEUE_DEMUXER")
    pa(f,this,"HAVE_POLL")
    pa(f,this,"HAVE_EPOLL")
    pa(f,this,"HAVE_EVTPORTS")
    pa(f,this,"WIN32")
    pa(f,this,"WIN64")
    pa(f,this,"POSIX")
    pa(f,this,"SOLARIS")
    pa(f,this,"BSD")
    pa(f,this,"LINUX")
    pa(f,this,"PREFIX")
    pa(f,this,"FLX_SOCKLEN_T")
    pa(f,this,"HAVE_PTHREADS")
    pa(f,this,"PTHREAD_SWITCH")
    pa(f,this,"HAVE_PKGCONFIG")
    pa(f,this,"FLX_LPARCHIVE")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")
    cc = TARGET_CC.__class__.__name__
    pr(f,"TARGET_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"TARGET_CC.load_options("+repr('config'+os.sep+'target_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    cxx = TARGET_CXX.__class__.__name__
    pr(f,"TARGET_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"TARGET_CXX.load_options("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"")
    pa(f,this,"HAVE_GNU")
    pr(f,"FLXCC_CPP='cpp '")
    pa(f,this,"HAVE_MSVC")
    pr(f,"# HACK to get all the target variables into global namespace")
    pr(f,"execfile("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
    f.close()
    if BOOTFILE:
      print "Copying bootfile :  "+ BOOTFILE
      filecopy(BOOTFILE,"config"+os.sep+"config_bootstrap.py")
  except EnvironmentError:
    print "Unable to create config"+os.sep+"config.py"
    sys.exit(1)

  print "Created config"+os.sep+"config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"target"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = string.split(cpkgf,os.sep)[2][:-3]
    print "target CONFIGURING",cpkg
    execfile(cpkgf)

@h = tangler('config/flx_data.py')
@select(h)
import os
execfile("config"+os.sep+"config.py")

cpp_keywords = [
  'asm',
  'auto',
  'bool',
  'break',
  'case',
  'catch',
  'char'
  'class',
  'const',
  'const_cast',
  'continue',
  'default',
  'delete',
  'do',
  'double',
  'dynamic_cast',
  'else',
  'enum',
  'explicit',
  'extern',
  'false',
  'float',
  'for',
  'friend',
  'goto',
  'if',
  'inline',
  'int',
  'long',
  'mutable',
  'namespace',
  'new',
  'operator',
  'private',
  'protected',
  'public',
  'register',
  'reinterpret_cast',
  'return',
  'short',
  'signed',
  'sizeof',
  'static',
  'static_cast',
  'struct',
  'switch',
  'template',
  'this',
  'throw',
  'true',
  'try',
  'typedef',
  'typeid',
  'typename',
  'union',
  'unsigned',
  'using',
  'virtual',
  'void',
  'volatile',
  'wchar_t',
  'while',
  ]

flx_expr_terminator_keywords = [
    ("all", "ALL"),
    ("assert", "ASSERT"),
    ("axiom", "AXIOM"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("class", "CLASS"),
    ("comment", "COMMENT_KEYWORD"),
    ("compound", "COMPOUND"),
    ("const", "CONST"),
    ("cclass", "CCLASS"),
    ("cstruct", "CSTRUCT"),
    ("ctor", "CTOR"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endcase", "ENDCASE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("expect", "EXPECT"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("gen", "GENERATOR"),
    ("goto", "GOTO"),
    ("header", "HEADER"),
    ("ident", "IDENT"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("module", "MODULE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("open","OPEN"),
    ("package", "PACKAGE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
#    ("public", "PUBLIC"),
#    ("publish", "PUBLISH"),
    ("reduce", "REDUCE"),
    ("ref", "REF"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("struct", "STRUCT"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("type", "TYPE"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("when", "WHEN"),
#    ("whilst", "WHILST"),
    ("with", "WITH"),
#    ("until", "UNTIL"),
    ("_gc_pointer", "GC_POINTER"),
    ("_gc_type", "GC_TYPE"),
    ("_svc", "SVC"),
    ("_deref", "DEREF"),
  ]

flx_other_keywords = [
    ("and", "AND"),
    ("as", "AS"),
    ("callback", "CALLBACK"),
    ("code", "CODE"),
    ("if", "IF"),
    ("isin", "ISIN"),
    ("match", "MATCH"),
    ("noexpand", "NOEXPAND"),
    ("of", "OF"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("the", "THE"),
    ("typematch", "TYPEMATCH"),
    ("typecase", "TYPECASE"),
    ("_", "UNDERSCORE"),
  ]

flx_parser_keywords = [
    ("expr","EXPRESSION"),
    ("float_literal", "FLOAT_LITERAL"),
    ("integer_literal", "INTEGER_LITERAL"),
    ("string_literal", "STRING_LITERAL"),
    ("statement", "STATEMENT"),
    ("statements", "STATEMENTS"),
  ]

# symbols that can't be followed by a keyword
flx_leadin_keywords = [
  "COLONCOLON",
  "DOT",
  "RIGHTARROW",
  "STRUCT",
  "UNION",
  "CLASS",
  "FUNCTION",
  "PROCEDURE",
  "GENERATOR",
]

flx_keywords = flx_expr_terminator_keywords + flx_other_keywords

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
    ("HASH","#"),
  ]

flx_2_char_syms = [
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),

    ("LSQANGLE","[<"),
    ("RSQANGLE",">]"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),

    ("AMPERAMPER","&&"),
    ("VBARVBAR","||"),
    ("SLOSHAMPER","\\\\&"),
    ("SLOSHVBAR","\\\\|"),
    ("SLOSHCIRCUMFLEX","\\\\^"),
    ("HASHBANG","#!"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
    ("DOTRIGHTARROW",".->"),
    ("LONGRIGHTARROW","-->"),
    ("PARSE_ACTION","=>#"),
    ("HASHBANGSLASH","#!/"),
  ]

flx_syms = flx_1_char_syms + flx_2_char_syms + flx_3_char_syms

rmap = {}

tmap = {
  # addressing
  "byte"      : "unsigned char",
  "size"      : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress"  : "void volatile*",
  "caddress"  : "void const*",
  "address"   : "void *",
  "offset"    : "ptrdiff_t",
  "ptrdiff"   : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if TARGET_CXX.options.HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if TARGET_CXX.options.HAVE_LONGDOUBLE:
  tmap["ldouble"]="long double"
else:
  tmap["ldouble"]="double"

if TARGET_CXX.options.HAVE_LONGLONG:
  tmap["vlong"]="long long"
  tmap["uvlong"]="unsigned long long"
else:
  tmap["vlong"]="long"
  tmap["uvlong"]="unsigned long"

if TARGET_CXX.options.HAVE_STDINT:
  tmap["int8"]="int8_t"
  tmap["uint8"]="uint8_t"
  tmap["int16"]="int16_t"
  tmap["uint16"]="uint16_t"
  tmap["int32"]="int32_t"
  tmap["uint32"]="uint32_t"
  tmap["int64"]="int64_t"
  tmap["uint64"]="uint64_t"
  tmap["intptr"]="intptr_t"
  tmap["uintptr"]="uintptr_t"
  tmap["intmax"]="intmax_t"
  tmap["uintmax"]="uintmax_t"

  # requirements
  rmap["int8"]="c99_stdint_h"
  rmap["uint8"]="c99_stdint_h"
  rmap["int16"]="c99_stdint_h"
  rmap["uint16"]="c99_stdint_h"
  rmap["int32"]="c99_stdint_h"
  rmap["uint32"]="c99_stdint_h"
  rmap["int64"]="c99_stdint_h"
  rmap["uint64"]="c99_stdint_h"
  rmap["intptr"]="c99_stdint_h"
  rmap["uintptr"]="c99_stdint_h"
  rmap["intmax"]="c99_stdint_h"
  rmap["uintmax"]="c99_stdint_h"
else:
  tmap["int8"]="signed char"
  tmap["uint8"]="unsigned char"
  sizes = { 
    TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
    TARGET_CXX.options.SIZEOF_INT*8: "int",
    TARGET_CXX.options.SIZEOF_LONG*8 : "long",
  }
  tmap["intmax"]="long"
  tmap["uintmax"]="unsigned long"
  if TARGET_CXX.options.HAVE_LONGLONG:
    sizes[TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
    tmap["intmax"]="long long"
    tmap["uintmax"]="unsigned long long"
  for size in [16,32,64]:
    try:
      t = sizes[size]
    except KeyError:
      tmap["int"+str(size)]="emul_int"+str(size)
      tmap["uint"+str(size)]="emul_uint"+str(size)
    else:
      tmap["int"+str(size)]=t
      tmap["uint"+str(size)]="unsigned " + t
  try:
    tmap["intptr"]=sizes[TARGET_CXX.options.SIZEOF_VOIDP*8]
    tmap["uintptr"]="unsigned "+sizes[TARGET_CXX.options.SIZEOF_VOIDP*8]
  except:
    print "NO INTEGER THE SIZE OF A VOID*!"
    sys.exit(1)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

@head(1,'Finish up')
Just cleaning up script now.
@try:
   os.system('chmod u+x configure')
   os.system('chmod u+x boot')
 except:pass
