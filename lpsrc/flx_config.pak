@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '1'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'

@select(tangler('tmp/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here

@select(tangler('tmp/xlators.py','python'))
import os
execfile('speed'+os.sep+'xlators_default.py')
execfile('config'+os.sep+'xlators_local.py')

# this table defines the actual translators
# which the performance tester will use
#
# comment out the lines you don't want,
# or add new ones if desired
#
# the translators selected by default should be available
# since they're required to build Felix .. but actually
# we preselect gcc for C compiler and ocamlopt for ocaml ..
# 
# this should really depend on the config for those things
#

# this is set up for PERSONAL USE
# this config is NOT suitable for submission to website
# you must use VERSIONED translators for submissions
#
xlators = [

# generic translators
  ('felix',mk_felix,'felix'),
  ('gcc',mk_gcc,'c'),
  ('gccopt',mk_gccopt,'c'),
  ('ocamlopt',mk_ocamlopt,'ocaml'),
#  ('gnat',mk_gnat,"ada"),
#  ('ghc',mk_ghc,'haskell'),

# GNU C and C++ compilers
#  ('gcc-3.3',mk_gcc_3_3,'c'),
#  ('gcc-3.3-O3',mk_gcc_3_3_opt,'c'),
#  ('gcc-4.0',mk_gcc_4_0,'c'),
#  ('gcc-4.0-O3',mk_gcc_4_0_opt,'c'),
#  ('g++-3.3',mk_gpp_3_3,'c'),
#  ('g++-3.3-O3',mk_gpp_3_3_opt,'c'),
#  ('g++-4_0',mk_gpp_4_0,'c'),
#  ('g++-4.0-O3',mk_gpp_4_0_opt,'c'),

# GNU Java
#  ('gcj-4_0',mk_gcj_4_0_opt,'java'),

# GNU Ada
#  ('gnat-4.0',mk_gnat,"ada"),

# Free Pascal
#  ('fpc-2.0.0',mk_fpc_2_0_0,"pascal"),

# GNU Pascal
#  ('gpc-2.1-3.3',mk_gpc_2_1_3_3,"pascal"),

# Glasgow Haskell
#  ('ghc-6.2.2',mk_ghc_6_2_2,'haskell'),
#  ('ghc-6.4.1',mk_ghc_6_4_1,'haskell'),

# Inria's Ocaml
#  ('ocamlopt-3.08_3',mk_ocamlopt_3_08_3,'ocaml'),
#  ('ocamlc-3.08.3',mk_ocamlc_3_08_3,'ocaml'),
]

@h = tangler("tmp/check_cygwin.cxx",'c++')
@select(h)
int main(int,char*[]) { 
   int x = __CYGWIN__;
   return 0;
}

@h = tangler("tmp/check_win32.cxx",'c++')
@select(h)
int main(int,char*[]) { 
   int x = _WIN32;
   return 0;
}

@h = tangler("tmp/check_osx.cxx",'c++')
@select(h)
// RF: I think this implies the presence of OS X
int main(int,char*[]) { 
   int x = __APPLE__;
   return 0;
}


@h = tangler("tmp/dummy.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummyc.c",'c')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummy_lib.cxx",'c++')
@select(h)
extern "C" int fred(int,char*[]) { return 0; }

@h = tangler("tmp/dummy_main.cxx",'c++')
@select(h)
#include <dlfcn.h>
#include <stdlib.h>

int main(int,char*argv[]) { 
   void *lib = dlopen(argv[1],RTLD_NOW);
   if(!lib) exit(1);
   void *fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}

@h = tangler("tmp/win32_dummy_lib.cxx",'c++')
@select(h)
extern "C" __declspec(dllexport) int fred(int,char*[]) { return 0; }

@h = tangler("tmp/win32_dummy_main.cxx",'c++')
@select(h)
#include <windows.h>
#include <stdlib.h>

int main(int,char*argv[]) { 
   HMODULE lib = LoadLibrary(argv[1]);
   if(!lib) exit(1);
   void *fred = (void*)GetProcAddress(lib,"fred");
   if(!fred) exit(1);
   return 0;
}

@h = tangler("tmp/gxx_x86.cxx",'c++')
@select(h)
#include <cstdio>
register void *sp __asm__ ("esp");

int main(int,char*[]) { 
   std::printf("Sp = %p\n",sp);
   return 0;
}

@h = tangler("tmp/gxx_hash.cxx",'c++')
@select(h)
#include <iostream>

// we only bother to check the include file exists
#include <ext/hash_map>
using namespace __gnu_cxx;

int main(int,char*[]) { 
   return 0;
}

@h = tangler("tmp/dummy_nan.cxx",'c++')
@select(h)
#include <cmath>

int main(int,char*[]) { 
  float f = 0.0;
  std::isnan(f);
  return 0;
}

@h = tangler("tmp/dummy_nan2.cxx",'c++')
@select(h)
#include <ieeefp.h>

int main(int,char*[]) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}

@h = tangler("tmp/dummy_stdint.cxx",'c++')
@select(h)
#include <stdint.h>

int main(int,char*[]) { 
  {int8_t i;}
  {int16_t i;}
  {int32_t i;}
  {int64_t i;}
  {uint8_t i;}
  {uint16_t i;}
  {uint32_t i;}
  {uint64_t i;}
  return 0;
}

@h = tangler("tmp/intsizes.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

enum enum_t {e_tag};
typedef void (*fp_t)(void);

struct BOOL {
  char x;
  bool y;
};

struct SHORT {
  char x;
  short y;
};

struct INT {
  char x;
  int y;
};

struct LONG {
  char x;
  long y;
};

struct FLOAT {
  char x;
  float y;
};

struct DOUBLE {
  char x;
  double y;
};

struct VOIDP {
  char x;
  void *y;
};

struct WCHAR {
  char x;
  wchar_t y;
};

struct ENUM {
  char x;
  enum_t y;
};

struct FUNCP {
  char x;
  fp_t y;
};

union endian_t {
  unsigned long x;
  unsigned char y[sizeof(unsigned long)];
} endian;

int main(int,char*[]) { 
  printf("SIZEOF_BOOL=%d\n",sizeof(bool));
  printf("SIZEOF_CBOOL=%d\n",sizeof(int)); // fallback
  printf("SIZEOF_SHORT=%d\n",sizeof(short));
  printf("SIZEOF_INT=%d\n",sizeof(int));
  printf("SIZEOF_LONG=%d\n",sizeof(long));
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long)); // fallback
  printf("SIZEOF_FLOAT=%d\n",sizeof(float));
  printf("SIZEOF_DOUBLE=%d\n",sizeof(double));
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_WCHAR=%d\n",sizeof(wchar_t));
  printf("SIZEOF_ENUM=%d\n",sizeof(enum_t));
  printf("SIZEOF_SIZEOF=%d\n",sizeof(sizeof(int)));

  printf("SIZEOF_COMPLEX=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_IMAGINARY=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_VOIDP=%d\n",sizeof(void*));
  printf("SIZEOF_FUNCP=%d\n",sizeof(fp_t));

  printf("ALIGNOF_BOOL=%d\n",offsetof(BOOL,y));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(BOOL,y)); // fallback
  printf("ALIGNOF_SHORT=%d\n",offsetof(SHORT,y));
  printf("ALIGNOF_INT=%d\n",offsetof(INT,y));
  printf("ALIGNOF_LONG=%d\n",offsetof(LONG,y));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONG,y)); // fallback
  
  printf("ALIGNOF_FLOAT=%d\n",offsetof(FLOAT,y));
  printf("ALIGNOF_DOUBLE=%d\n",offsetof(DOUBLE,y));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(DOUBLE,y)); // fallback
  
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_IMAGINARY=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_WCHAR=%d\n",offsetof(WCHAR,y));
  printf("ALIGNOF_ENUM=%d\n",offsetof(ENUM,y));
  printf("ALIGNOF_FUNCP=%d\n",offsetof(FUNCP,y));
  printf("ALIGNOF_VOIDP=%d\n",offsetof(VOIDP,y));

  printf("CHAR_IS_UNSIGNED=%d\n",((char)0xFF)>0?1:0);
  endian.x = 1ul;
  printf("LITTLE_ENDIAN=%d\n", endian.y[0]);
  printf("BIG_ENDIAN=%d\n", endian.y[sizeof(unsigned long)-1]);

  return 0;
}

@h = tangler("tmp/longlong.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGLONG {
  char x;
  long long y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long long));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONGLONG,y));
  return 0;
}

@h = tangler("tmp/longdouble.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGDOUBLE {
  char x;
  long double y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(long double));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(LONGDOUBLE,y));
  return 0;
}

@h = tangler("tmp/complex.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct COMPLEX {
  char x;
  _Complex y;
};

struct DOUBLECOMPLEX {
  char x;
  double _Complex y;
};

struct LONGDOUBLECOMPLEX {
  char x;
  long double _Complex y;
};

int main(int,char*[]) { 
  printf("SIZEOF_COMPLEX=%d\n",sizeof(_Complex));
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double _Complex));
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(long double _Complex));
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(COMPLEX,y));
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLECOMPLEX,y));
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(LONGDOUBLECOMPLEX,y));
  return 0;
}

@h = tangler("tmp/cbool.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct CBOOL {
  char x;
  _Bool y;
};

int main(int,char*[]) { 
  printf("SIZEOF_CBOOL=%d\n",sizeof(_Bool));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(CBOOL,y));
  return 0;
}

@h = tangler("tmp/cgoto.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { 
  void *label = &&label2;
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}

@h = tangler("tmp/asm_labels.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { 
  void *label = &&label2;
  __asm__(".global fred");
  __asm__("fred:");
  __asm__(""::"g"(&&label1));
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}

@h = tangler("tmp/check_inclass.cxx",'c++')
@select(h)
struct X {
  static const int i = 1;
};

int main(int,char*[]) { 
  return 0;
}

@h = tangler("script/ocaml_class.py")
@select(h)
#---------------------------------------------------
# discover which ocaml compilers are available
class ocaml:
  def __init__(self):
    pass

  def autodetect(self, shell, get_stdout):
    try: # check if the client bootstrapped the native code compiler
      shell('ocamlopt.opt')
      self.OCAMLCC = 'ocamlopt.opt '
      self.OCAMLLEX = 'ocamllex.opt '
      self.OCAMLYACC = 'ocamlyacc '
      self.NATIVE_CODE_COMPILER = 1
    except:
      try: # check if the client has unbootstrapped native code compiler
        shell('ocamlopt')
        self.OCAMLCC = 'ocamlopt '
        self.OCAMLLEX = 'ocamllex '
        self.OCAMLYACC = 'ocamlyacc '
        self.NATIVE_CODE_COMPILER = 1
      except:
        self.NATIVE_CODE_COMPILER = 0
        try: # check if the client has ocaml at all ..
          shell('ocamlc')
          self.OCAMLCC = 'ocamlc '
          self.OCAMLLEX = 'ocamllex '
          self.OCAMLYACC = 'ocamlyacc '
          self.OCAMLDOC = 'ocamldoc '
        except:
          print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
          self.OCAMLCC = '#ocamlc '
          self.OCAMLLEX = '#ocamllex '
          self.OCAMLYACC = '#ocamlyacc '

    try: # check if there is a native code version of the bytecode compiler
      shell('ocamlc.opt')
      self.OCAMLB = 'ocamlc.opt '
    except:
      try: # check if the client has ocaml at all
        shell('ocamlc')
        self.OCAMLB = 'ocamlc '
      except:
        print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
        self.OCAMLB = '#ocamlc '

    try:
      shell('ocamldoc.opt')
      self.OCAMLDOC = 'ocamldoc.opt '
    except:
      try:
        shell('ocamldoc')
        self.OCAMLDOC = 'ocamldoc '
      except:
        print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
        self.OCAMLDOC = '#ocamldoc '

    # set the default ocaml compiler
    if self.OCAMLCC[0] != '#':
      self.OCAMLC = self.OCAMLCC
    else:
      self.OCAMLC = self.OCAMLB

    self.OCAMLCP = "ocamlcp "
    # where the ocaml is installed
    result,x = get_stdout(self.OCAMLC + " -where")
    if result:
      print "Woops, Can't run",self.OCAMLC
      sys.exit(1)
    self.OCAML_INCLUDE_DIRECTORY= x[0][0:-1]

    result,x = get_stdout(self.OCAMLB + " -v")
    if result:
      print "Woops, Can't run",self.OCAMLB
      sys.exit(1)
    x=x[0][0:-1]
    self.OCAMLB_DESCRIPTION,y = string.split(x,",")
    y = string.strip(y)
    self.OCAML_VERSION=y

    result,x = get_stdout(self.OCAMLC + " -v")
    if result:
      print "Woops, Can't run",self.OCAMLC
      sys.exit(1)
    x=x[0][0:-1]
    self.OCAMLC_DESCRIPTION,y = string.split(x,",")
    y = string.strip(y)
    if self.OCAML_VERSION <> y:
      print "Inconsistent Ocaml tool versions"
      print "Ocaml: bytecode compiler",self.OCAML_VERSION
      print "Ocaml: compiler         ",y
      sys.exit(1)
    
    
  def report_config(self):
    print
    print "OCAML tool configuration"
    print "************************"
    print
    print "Ocaml Version",self.OCAML_VERSION
    if self.NATIVE_CODE_COMPILER:
      print "Using Native code Compiler"
    else:
      print "Using Bytecode Compiler"
    print "Lexer generator .............. ",self.OCAMLLEX
    print "Parser generator ............. ",self.OCAMLYACC
    print "Bytecode and Interface compiler",self.OCAMLB
    print "   ",self.OCAMLB_DESCRIPTION
    print "Compiler ..................... ",self.OCAMLC
    print "   ",self.OCAMLC_DESCRIPTION
    print "Profiling Compiler ........... ",self.OCAMLCP
    print "Document Generator ........... ",self.OCAMLDOC
    print "C include directory .......... ",self.OCAML_INCLUDE_DIRECTORY
    print
   
  def save_config(self,filename):
    f = open(filename,"w")
    f.write("OCAML_VERSION="+repr(self.OCAML_VERSION)+"\n")
    f.write("NATIVE_CODE_COMPILER="+str(self.NATIVE_CODE_COMPILER)+"\n")
    f.write("OCAMLLEX="+repr(self.OCAMLLEX)+"\n")
    f.write("OCAMLYACC="+repr(self.OCAMLYACC)+"\n")
    f.write("OCAMLB="+repr(self.OCAMLB)+"\n")
    f.write("OCAMLB_DESCRIPTION="+repr(self.OCAMLB_DESCRIPTION)+"\n")
    f.write("OCAMLC="+repr(self.OCAMLC)+"\n")
    f.write("OCAMLC_DESCRIPTION="+repr(self.OCAMLC_DESCRIPTION)+"\n")
    f.write("OCAMLCP="+repr(self.OCAMLCP)+"\n")
    f.write("OCAMLDOC="+repr(self.OCAMLDOC)+"\n")
    f.write("OCAML_INCLUDE_DIRECTORY="+repr(self.OCAML_INCLUDE_DIRECTORY)+"\n")
    f.close()
  
  def load_config(self,filename):
    f = open(filename)
    exec f in self.__dict__
    f.close()

@h = tangler("script/object_class.py")
@select (h)
class object:pass

@h = tangler("script/gxx_class.py")
@select (h)
import string
import os
execfile("script"+os.sep+"object_class.py")

class gxx:

  def __init__(self):
    self.options = object()

  # these options are model dependent and have to
  # be supplied by the client

  def set_options(self,
    CXX="g++",
    AR="ar -rc",
    RANLIB="ranlib",
    STRIP="strip",
    build="posix",
    model="detect",
    flags= "",
    use="generic"
    ):
    opt = self.options
    opt.model = model
    if model == "nocygwin": 
      opt.CXX = CXX + " -mno-cygwin "
    else:
      opt.CXX = CXX+" "
    print "CXX=",opt.CXX
    opt.AR = AR +" "
    opt.RANLIB = RANLIB +" "
    opt.STRIP = STRIP +" "
    opt.flags = flags
    opt.use = use
    opt.SPEC_OBJ_FILENAME = "-o "
    opt.SPEC_EXE_FILENAME = "-o "

  def detect_gxx_language_extensions(self,shell):
    opt = self.options
    CXX = opt.CXX
    # find if we have g++ on 32 bit x86 platform with named registers
    try:
      shell(CXX +"-w tmp"+os.sep+"gxx_x86.cxx -o tmp"+os.sep+"x86_check")
      shell("tmp"+os.sep+"x86_check")
      opt.HAVE_GXX_X86 = 1
      print "g++ x86 support detected"
    except:
      opt.HAVE_GXX_X86 = 0

    if opt.HAVE_GXX_X86:
      opt.USE_REGPARM3=1
      print "regparm3 supported"
    else:
      opt.USE_REGPARM3=0

    # find if we have g++ supporting computed jumps
    try:
      shell(CXX+" tmp"+os.sep+"cgoto.cxx -o tmp"+os.sep+"cgoto")
      shell("tmp"+os.sep+"cgoto")
      opt.HAVE_CGOTO = 1
      print "Computed goto supported"
    except:
      opt.HAVE_CGOTO = 0

    # find if we have g++ supporting computed jumps and asm labels
    try:
      shell(CXX+"tmp"+os.sep+"asm_labels.cxx -o tmp"+os.sep+"asm_labels")
      shell("tmp"+os.sep+"asm_labels")
      opt.HAVE_ASM_LABELS = 1
      print "Asm labels supported"
    except:
      opt.HAVE_ASM_LABELS = 0

    # find if we have static const init in class
    # [not so much an extension as a bug if we don't]
    try:
      shell(opt.CXX+" -w -c tmp"+os.sep+"check_inclass.cxx -o tmp"+os.sep+"dummy.o")
      opt.HAVE_INCLASS_MEMBER_INITIALIZATION=1
      print "Inclass member initialisation supported"
    except:
      opt.HAVE_INCLASS_MEMBER_INITIALIZATION=0
      print "Inclass member initialisation NOT supported"


  def detect_gxx_flags(self,shell):
    opt = self.options
    CXX = opt.CXX
    # find if we have g++ with -Wno-invalid-offsetof
    try:
      shell(CXX+"-Wno-invalid-offsetof tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      opt.NO_INVALID_OFFSETOF_WARNING="-Wall -Wno-invalid-offsetof "
      print "-Wno-invalid-offsetof supported"
    except:
      opt.NO_INVALID_OFFSETOF_WARNING = "-w "

    # find if we can use -fPIC without a warning
    # if a warning is generated it will say something like 
    # 'all code is relocatable on this platform' 
    # so we make that into an error, detect it, and say -fPIC only
    # if it would not generate this warning
    try:
      shell(CXX+"-Werror -fPIC tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      opt.PIC = "-fPIC "
      print "-fPIC supported"
    except:
      opt.PIC = ""
      print "All code is position independent"

  def detect_win32(self,shell):
    CXX = self.options.CXX
    try:
      shell(CXX+"-w -c tmp"+os.sep+"check_win32.cxx -o tmp"+os.sep+"dummy.o")
      print "WIN32 detected"
      return 1
    except:
      print "WIN32 NOT detected"
      return 0

  def detect_cygwin(self,shell):
    CXX = self.options.CXX
    try:
      shell(CXX+"-w -c tmp"+os.sep+"check_cygwin.cxx -o tmp"+os.sep+"dummy.o")
      print "CYGWIN detected"
      return 1
    except:
      print "CYGWIN NOT detected"
      return 0

  def detect_osx(self,shell):
    CXX = self.options.CXX
    try:
      shell(CXX+"-w -c tmp"+os.sep+"check_osx.cxx -o tmp"+os.sep+"dummy.o")
      print "MACOSX detected"
      return 1
    except:
      print "MACOSX NOT detected"
      return 0

  # only allows 4 models: cygwin, osx, win32 and posix
  # nocygwin = mingw = win32
  def detect_model(self,shell):
    opt = self.options
    opt.MACOSX = self.detect_osx(shell)
    opt.WIN32 = self.detect_win32(shell)
    opt.CYGWIN = self.detect_cygwin(shell)
    sum = opt.MACOSX + opt.WIN32 + opt.CYGWIN
    if sum > 1:
      print "INCOMPATIBLE MODELS DETECTED"
      print "MACOSX",opt.MACOSX
      print "CYGWIN",opt.CYGWIN
      print "WIN32",opt.WIN32
    else:
     if opt.model == "detect":
       if opt.CYGWIN: opt.model = "cygwin"
       if opt.MACOSX: opt.model = "osx"
       if opt.WIN32: opt.model = "win32"
       if opt.model == "detect": opt.model = "posix"
    if opt.model in ["mingw","nocygwin"]: opt.model = "win32"
    if opt.model in ["posix"] and opt.CYGWIN: opt.model = "cygwin"
    assert opt.model in ["cygwin","osx","win32","posix"]

  def check_options(self,shell):
    opt = self.options
    CXX = opt.CXX

    # check we have g++
    shell(CXX+"-w -c tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
    self.detect_gxx_language_extensions(shell)

    # see if we have strip: it isn't considered essential
    if opt.STRIP:
      shell(opt.STRIP + "tmp"+os.sep+"dummy.o")
    else:
      opt.STRIP="#strip "

    # see if we have ar
    shell(opt.AR+"tmp"+os.sep+"dummy.a tmp"+os.sep+"dummy.o")

    # see if we have ranlib, it isn't considered essential
    # (a totally brain dead Unix idea: AR should do this)
    try:
      shell(opt.RANLIB + "tmp"+os.sep+"dummy.a")
    except:
      opt.RANLIB="#ranlib "

    self.detect_gxx_flags(shell)
    # find if we have g++ supported ext/ with STL extensions
    try:
      shell(CXX+"tmp"+os.sep+"gxx_hash.cxx -o tmp"+os.sep+"gxx_hash")
      shell("tmp"+os.sep+"gxx_hash")
      opt.HAVE_STL_GNU_CXX = 1
      print "Gnu ext/ templates supported"
    except:
      opt.HAVE_STL_GNU_CXX = 0

    self.detect_model(shell)
    print "MODEL =",opt.model

    if opt.model=="cygwin":
      opt.EXT_LIB = ".a"
      opt.EXT_EXE= ".exe"
      opt.EXT_SHLIB = ".dll"
      opt.EXT_OBJ = ".o"
      opt.SHLIB_DIR="bin"
      
      COMPILE_DYNAMIC_RTL = opt.PIC+ "-c "
      #LINK_DYNAMIC_RTL = "-shared -Wl,--disable-auto-import "
      LINK_DYNAMIC_RTL = "-shared  "

      
      COMPILE_DYNAMIC_MAIN = "-c "
      #LINK_DYNAMIC_MAIN = "-Wl,--disable-auto-import "
      LINK_DYNAMIC_MAIN = ""
      
      COMPILE_DYNAMIC_FLX = opt.PIC+ "-c "
      #LINK_DYNAMIC_FLX = opt.PIC+"-shared -Wl,--disable-auto-import "
      LINK_DYNAMIC_FLX = opt.PIC+"-shared "

    elif opt.model=="win32":
      opt.EXT_LIB = ".a"
      opt.EXT_EXE= ".exe"
      opt.EXT_SHLIB = ".dll"
      opt.EXT_OBJ = ".obj"
      opt.SHLIB_DIR="bin"
      
      COMPILE_DYNAMIC_RTL = opt.PIC+ "-c "
      LINK_DYNAMIC_RTL = "-shared -Wl,--disable-auto-import "
      
      COMPILE_DYNAMIC_MAIN = "-c "
      LINK_DYNAMIC_MAIN = "-Wl,--disable-auto-import "
      
      COMPILE_DYNAMIC_FLX = opt.PIC+ "-c "
      LINK_DYNAMIC_FLX = opt.PIC+"-shared -Wl,--disable-auto-import "

    elif opt.model=="osx":
      opt.EXT_LIB = ".a"
      opt.EXT_EXE= ""
      opt.EXT_SHLIB = ".so"
      opt.EXT_OBJ = ".o"
      opt.SHLIB_DIR="rtl"
      
      COMPILE_DYNAMIC_RTL = opt.PIC + "-dynamic -c "
      LINK_DYNAMIC_RTL = "-bundle "
      
      COMPILE_DYNAMIC_MAIN = "-c "
      LINK_DYNAMIC_MAIN = ""
      
      COMPILE_DYNAMIC_FLX = opt.PIC + "-dynamic -c "
      LINK_DYNAMIC_FLX = "-bundle "

    elif opt.model=="posix":
      opt.EXT_LIB = ".a"
      opt.EXT_EXE= ""
      opt.EXT_SHLIB = ".so"
      opt.EXT_OBJ = ".o"
      opt.SHLIB_DIR="rtl"
      
      COMPILE_DYNAMIC_RTL = opt.PIC+ "-c "
      LINK_DYNAMIC_RTL = "-shared "
      
      COMPILE_DYNAMIC_MAIN = "-c "
      LINK_DYNAMIC_MAIN = ""

      COMPILE_DYNAMIC_FLX = opt.PIC+"-c "
      LINK_DYNAMIC_FLX = "-shared "
    else:
      print "UNKNOWN MODEL",model
      sys.exit(1)

    opt.CCOBJ_DYNAMIC_FLX = CXX + COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = CXX + LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = CXX + COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = CXX + LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = CXX + COMPILE_DYNAMIC_MAIN
    opt.CCLINK_DYNAMIC_MAIN = CXX + LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = CXX + "-c "
    opt.CCOBJ_STATIC_RTL = CXX + "-c "
    opt.CCOBJ_STATIC_MAIN = CXX + "-c "

    opt.CCOBJ_DYNAMIC_RTL=opt.CCOBJ_DYNAMIC_RTL+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_DYNAMIC_FLX=opt.CCOBJ_DYNAMIC_FLX+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_RTL=opt.CCOBJ_STATIC_RTL+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX=opt.CCOBJ_STATIC_FLX+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCLINK_STATIC = CXX

    #check if we can get dlopen to work without -ldl (BSD, Cygwin don't need)
    opt.SUPPORT_DYNAMIC_LOADING = 0
    opt.HAVE_DLOPEN = 0
    opt.HAVE_LOADLIBRARY = 0
    opt.DLLIB=""
    if opt.model in ["cygwin","posix","osx"]:
      try:
        shell(opt.CCOBJ_DYNAMIC_FLX+"tmp"+os.sep+"dummy_lib.cxx -o tmp"+os.sep+"dummy_lib.o")
        shell(opt.CCOBJ_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.cxx -o tmp"+os.sep+"dummy_main.o")
        shell(opt.CCLINK_DYNAMIC_FLX+"tmp"+os.sep+"dummy_lib.o -o tmp"+os.sep+"dummy_lib"+opt.EXT_SHLIB)
        shell(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.o -o tmp"+os.sep+"dlmain")
        shell("tmp"+os.sep+"dlmain tmp"+os.sep+"dummy_lib"+opt.EXT_SHLIB)
        opt.SUPPORT_DYNAMIC_LOADING = 1
        opt.HAVE_DLOPEN = 1
      except:
        try: # nope, try with -ldl
          shell(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.o -o tmp"+os.sep+"dlmain -ldl")
          shell("tmp"+os.sep+"dlmain tmp"+os.sep+"dummy_lib"+opt.EXT_SHLIB)
          opt.HAVE_DLOPEN = 1
          opt.SUPPORT_DYNAMIC_LOADING = 1
          opt.DLLIB="dl"
          print "Dynamic Loading Supported (with -ldl)"
        except:
          pass

    else:
    # check if can get LoadLibrary to work
      try:
        shell(opt.CCOBJ_DYNAMIC_FLX+"tmp"+os.sep+"win32_dummy_lib.cxx -o tmp"+os.sep+"win32_dummy_lib.o")
        shell(opt.CCOBJ_DYNAMIC_MAIN+"tmp"+os.sep+"win32_dummy_main.cxx -o tmp"+os.sep+"win32_dummy_main.o")
        shell(opt.CCLINK_DYNAMIC_FLX+"tmp"+os.sep+"win32_dummy_lib.o -o tmp"+os.sep+"win32_dummy_lib"+opt.EXT_SHLIB)
        shell(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"win32_dummy_main.o -o tmp"+os.sep+"dlmain")
        shell("tmp"+os.sep+"dlmain tmp"+os.sep+"win32_dummy_lib"+opt.EXT_SHLIB)
        opt.SUPPORT_DYNAMIC_LOADING = 1
        opt.HAVE_LOADLIBRARY = 1
        print "Dynamic Loading Supported (with LoadLibrary)"
      except:
        pass

    if not opt.SUPPORT_DYNAMIC_LOADING:
      print "DYNAMIC LOADING NOT SUPPORTED"
      print "Temporarily this is mandatory [during config debugging]"
      sys.exit(1)
    

    # find if we have BSD isnan in <cmath> (NAUGHTY!)
    try:
      shell(opt.CXX+" -w -c tmp"+os.sep+"dummy_nan.cxx -o tmp"+os.sep+"dummy_nan.o")
      opt.HAVE_ISNAN_IN_CMATH=1
      print "Isnan found in <cmath>"
    except:
      opt.HAVE_ISNAN_IN_CMATH=0

    # find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
    try:
      shell(opt.CXX+" -w -c tmp"+os.sep+"dummy_nan2.cxx -o tmp"+os.sep+"dummy_nan2.o")
      opt.HAVE_ISNAN_IN_IEEEFP=1
      print "Isnan found in <ieeefp.h>"
    except:
      opt.HAVE_ISNAN_IN_IEEEFP=0

    if opt.HAVE_ISNAN_IN_CMATH or opt.HAVE_ISNAN_IN_IEEEFP:
      print "Isnan supported"
    else:
      print "Isnan NOT supported"

    # find if we have stdint.h
    try:
      shell(opt.CXX+" -w -c tmp"+os.sep+"dummy_stdint.cxx -o tmp"+os.sep+"dummy_stdint.o")
      opt.HAVE_STDINT=1
      print "Have stdint.h support"
    except:
      opt.HAVE_STDINT=0
      print "stdint.h NOT supported"

    # find sizes of ints
    try:
      shell(opt.CXX+" -w tmp"+os.sep+"intsizes.cxx -o tmp"+os.sep+"intsizes")
      # THIS CALL CANNOT USE THE SHELL BECAUSE IT REDIRECTS OUTPUT
      os.system("tmp"+os.sep+"intsizes > tmp"+os.sep+"intsizes.py")
      f = open("tmp"+os.sep+"intsizes.py")
      exec f in opt.__dict__
      f.close()
    except:
      print "FATAL: can't determine sizes of ints"
      sys.exit(1)
      
    # find if we have long long
    try:
      shell(opt.CXX+" -w tmp"+os.sep+"longlong.cxx -o tmp"+os.sep+"longlong")
      os.system("tmp"+os.sep+"longlong >tmp"+os.sep+"longlong.py")
      f = open("tmp"+os.sep+"longlong.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_LONGLONG=1
    except:
      opt.HAVE_LONGLONG=0

    # find if we have long double
    try:
      shell(opt.CXX+" -w tmp"+os.sep+"longdouble.cxx -o tmp"+os.sep+"longdouble")
      os.system("tmp"+os.sep+"longdouble >tmp"+os.sep+"longdouble.py")
      f = open("tmp"+os.sep+"longdouble.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_LONGDOUBLE=1
    except:
      opt.HAVE_LONGDOUBLE=0

    # find if we have _Bool
    try:
      shell(opt.CXX+" -w tmp"+os.sep+"bool.c -o tmp"+os.sep+"bool")
      os.system("tmp"+os.sep+"bool >tmp"+os.sep+"bool.py")
      f = open("tmp"+os.sep+"bool.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_CBOOL=1
    except:
      opt.HAVE_CBOOL=0

    # find if we have _Complex
    try:
      shell(opt.CXX + " -w tmp"+os.sep+"complex.c -o tmp"+os.sep+"complex")
      os.system("tmp"+os.sep+"complex >tmp"+os.sep+"complex.py")
      f = open("tmp"+os.sep+"complex.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_COMPLEX=1
    except:
      opt.HAVE_COMPLEX=0

    #calculate alignment tables
    vbls = [
      ("ALIGNOF_BOOL","bool"),
      ("ALIGNOF_SHORT","short"),
      ("ALIGNOF_INT","int"),
      ("ALIGNOF_LONG","long"),
      ("ALIGNOF_LONGLONG","long long"),
      
      ("ALIGNOF_FLOAT","float"),
      ("ALIGNOF_DOUBLE","double"),
      ("ALIGNOF_LONGDOUBLE","long double"),

      ("ALIGNOF_WCHAR","wchar_t"),
      ("ALIGNOF_VOIDP","void*"),
      ]

    opt.MAX_ALIGN = 1
    opt.flx_aligns = {}
    for k,t in vbls:
      v = opt.__dict__[k]
      opt.flx_aligns[v]=t
      if v > opt.MAX_ALIGN: opt.MAX_ALIGN = v
    opt.flx_aligns[1]="char"

    opt.DEBUG_FLAGS = "-g "
    opt.OPTIMISE = "-O3 -fomit-frame-pointer --inline -DNDEBUG "

  def report_config(self):
    opt = self.options
    print "**********************************************"
    print "g++",opt.use,"configuration"
    print "**********************************************"
    print "model=",opt.model
    print "static library tool #1                  : " + opt.AR
    print "static library tool #2                  : " + opt.RANLIB
    print
    print "Command to compile static Felix rtl     : " + opt.CCOBJ_STATIC_RTL
    print "Command to compile shared Felix rtl     : " + opt.CCOBJ_DYNAMIC_RTL
    print "Command to link shared Felix rtl        : " + opt.CCLINK_DYNAMIC_RTL
    print
    print "Command to compile static Felix driver  : " + opt.CCOBJ_STATIC_MAIN
    print "Command to compile dynamic Felix driver : " + opt.CCOBJ_DYNAMIC_MAIN
    print "Command to link dynamic Felix driver    : " + opt.CCLINK_DYNAMIC_MAIN

    print "Command to compile static Felix object  : " + opt.CCOBJ_STATIC_FLX
    print "Command to compile loadable Felix object: " + opt.CCOBJ_DYNAMIC_FLX
    print "Command to link loadable Felix object   : " + opt.CCLINK_DYNAMIC_FLX
    print

    print "Extension for object file               : " + opt.EXT_OBJ
    print "Extension for static archive            : " + opt.EXT_LIB
    print "Extension for loadable RTL              : " + opt.EXT_SHLIB
    print "Extension for executable                : " + opt.EXT_EXE
    print "RTL in directory                        : " + opt.SHLIB_DIR

    print
    if opt.SUPPORT_DYNAMIC_LOADING:
      if opt.HAVE_DLOPEN:
        if opt.DLLIB:
          print "Dynamic Loading Supported               : with dlopen() in -l"+opt.DLLIB
        else:
          print "Dynamic Loading Supported               : with dlopen() [native]"
      if opt.HAVE_LOADLIBRARY:
          print "Dynamic Loading Supported               : with LoadLibrary"
    else:
      print "Dynamic Loading                         : NOT SUPPORTED"
    print
    if opt.HAVE_ISNAN_IN_CMATH:
      print "NaN Support in                          : <cmath>"
    if opt.HAVE_ISNAN_IN_IEEEFP:
      print "NaN Support in                          : <ifpeee.h>"
    if not opt.HAVE_ISNAN_IN_IEEEFP and not opt.HAVE_ISNAN_IN_CMATH:
      print "NaN                                     : NOT SUPPORTED"
    print "**********************************************"


  def save_options(self, filename):
    f = open(filename,"w")
    ks = self.options.__dict__.keys()
    ks.sort()
    for k in ks:
      if k[0] != '_': # do not save __builtins__
        v = self.options.__dict__[k]
        f.write(k+'='+repr(v)+"\n")
    f.close()

  def load_options(self,filename):
    f = open(filename)
    exec f in self.options.__dict__
    f.close()

  # compile a file to an object suitable for inclusion in a shared 
  # library version of RTL
  def compile_shared_rtl(self,shell,indir,basename,outdir=None,include_path=[],macros=[],flags="",optimise=1,debug=0):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = opt.CCOBJ_DYNAMIC_RTL
    if flags: cmd = cmd + flags + " "

    # debug symbols
    if debug: cmd = cmd + "-g "

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE

    # include path
    for i in include_path: cmd = cmd +"-I"+i+" "

    # output file
    cmd = cmd + "-o "
    if outdir: cmd = cmd + outdir + os.sep
    cmd = cmd + basename + "_dynamic"+opt.EXT_OBJ+" "

    # macros
    for i in macros: cmd=cmd + "-D"+i+" "
    #input file
    if  indir: cmd = cmd + indir + os.sep
    cmd = cmd + basename
    cmd = cmd + ".cpp"

    # compile it
    shell(cmd)

  # compile a file to an object suitable for inclusion in a mainline
  # which links to shared libraries
  compile_shared_main = compile_shared_rtl
  compile_felix_dll = compile_shared_rtl

  # compile a file to an object suitable for inclusion in a static link 
  # version of the RTL 
  def compile_static_rtl(self,shell,indir,basename,outdir=None,include_path=[],macros=[],flags="",optimise=1,debug=0):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = opt.CCOBJ_STATIC_RTL
    if flags: cmd = cmd + flags + " "

    # debug symbols
    if debug: cmd = cmd + "-g "

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE+ " "

    # include path
    for i in include_path: cmd = cmd +"-I"+i+" "

    # output file
    cmd = cmd + "-o "
    if outdir: cmd = cmd + outdir + os.sep
    cmd = cmd + basename + "_static"+opt.EXT_OBJ+" "

    #macros
    for i in macros: cmd=cmd + "-D"+i+" "

    #input file
    if  indir: cmd = cmd + indir + os.sep
    cmd = cmd + basename
    cmd = cmd + ".cpp"

    # compile it
    shell(cmd)

  compile_static_main = compile_static_rtl
  compile_felix_static = compile_static_rtl

  def link_static_archive(self,shell,objects,archive):
    opt = self.options
    cmd = opt.AR +" "+ archive + opt.EXT_LIB+" " 
    for i in objects: cmd = cmd + i + opt.EXT_OBJ + " "
    shell(cmd)
    if opt.RANLIB:
      shell(opt.RANLIB+" "+archive+opt.EXT_LIB)
  
  def link_static_program(self,shell,objects,outfile,lib_path,libs):
    opt = self.options
    cmd = opt.CCLINK_STATIC
    for i in objects: cmd = cmd +i+opt.EXT_OBJ +" "
    cmd = cmd + "-o " +outfile + " "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    shell(cmd)
    
  def link_shared_rtl(self,shell,objects,outfile,lib_path=[],libs=[]):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_RTL
    cmd = cmd + "-o " +outfile + opt.EXT_SHLIB + " "
    if opt.CYGWIN:
      cmd = cmd + "-Wl,--out-implib="+outfile+".dll.a "
    for i in objects: cmd = cmd +i+opt.EXT_OBJ +" "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    if opt.DLLIB:
      cmd = cmd + "-l"+opt.DLLIB+" "
    shell(cmd)

  def link_felix_dll(self,shell,objects,outfile,lib_path=[],libs=[]):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_RTL
    cmd = cmd + "-o " +outfile + opt.EXT_SHLIB + " "
    for i in objects: cmd = cmd +i+opt.EXT_OBJ +" "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    if opt.DLLIB:
      cmd = cmd + "-l"+opt.DLLIB+" "
    shell(cmd)
    
  def link_dynamic_program(self,shell,objects,outfile,lib_path,libs):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_MAIN
    cmd = cmd + "-o " +outfile + " "
    for i in objects: cmd = cmd +i+opt.EXT_OBJ+" "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    if opt.DLLIB:
      cmd = cmd + "-l"+opt.DLLIB+" "
    shell(cmd)

@h = tangler("script/msvcxx_class.py")
@select (h)
import string
import os
execfile("script"+os.sep+"object_class.py")

class msvcxx:

  def __init__(self):
    self.options = object()

  # these options are model dependent and have to
  # be supplied by the client

  def set_options(self,
    CXX="cl",
    LIB="lib",
    build="posix",
    model="detect",
    flags= "",
    use="generic"
    ):
    opt = self.options
    opt.model = model
    opt.CXX = CXX+" "
    opt.AR = LIB+" "
    opt.RANLIB = "#"
    opt.flags = flags
    opt.use = use
    opt.SUPPORT_DYNAMIC_LOADING=1
    opt.SPEC_OBJ_FILENAME = "/Fo"
    opt.SPEC_EXE_FILENAME = "/Fe"

  def detect_msvcxx_language_extensions(self,shell):
    opt = self.options
    CXX = opt.CXX
    opt.HAVE_GXX_X86 = 0
    opt.USE_REGPARM3=0
    opt.HAVE_CGOTO = 0
    opt.HAVE_ASM_LABELS = 0
    opt.HAVE_STL_GNU_CXX = 0

    # find if we have static const init in class
    # [not so much an extension as a bug if we don't]
    try:
      shell(opt.CXX+" /w /c tmp"+os.sep+"check_inclass.cxx /Fotmp"+os.sep+"dummy.o")
      opt.HAVE_INCLASS_MEMBER_INITIALIZATION=1
      print "Inclass member initialisation supported"
    except:
      opt.HAVE_INCLASS_MEMBER_INITIALIZATION=0
      print "Inclass member initialisation NOT supported"


  def detect_msvcxx_flags(self,shell):
    opt = self.options
    CXX = opt.CXX
    opt.NO_INVALID_OFFSETOF_WARNING="/w "

  def check_options(self,shell):
    opt = self.options
    CXX = opt.CXX

    # check we have g++
    shell(CXX+"/w /c tmp"+os.sep+"dummy.cxx /Fotmp"+os.sep+"dummy.o")
    self.detect_msvcxx_language_extensions(shell)

    self.detect_msvcxx_flags(shell)
    if opt.model == "detect": opt.model = "win32" 

    print "MODEL =",opt.model
    opt.EXT_LIB = ".lib"
    opt.EXT_EXE= ".exe"
    opt.EXT_SHLIB = ".dll"
    opt.EXT_OBJ = ".obj"

    COMPILE_DYNAMIC_RTL = "/nologo /MD /c /EHs "
    LINK_DYNAMIC_RTL = "/nologo /MD /LD "
      
    COMPILE_DYNAMIC_MAIN = "/nologo /MT /c /EHs "
    LINK_DYNAMIC_MAIN = "/nologo /MT "

    COMPILE_DYNAMIC_FLX = "/nologo /MD /c /EHs "
    LINK_DYNAMIC_FLX = "/nologo /MT /LD "

    opt.CCOBJ_DYNAMIC_FLX = CXX + COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = CXX + LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = CXX + COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = CXX + LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = CXX + COMPILE_DYNAMIC_MAIN
    opt.CCLINK_DYNAMIC_MAIN = CXX + LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = CXX + "/nologo /MT /EHs /c "
    opt.CCOBJ_STATIC_RTL = CXX + "/nologo /MT /EHs /c "
    opt.CCOBJ_STATIC_MAIN = CXX + "/nologo /MT /EHs /c "

    opt.CCOBJ_DYNAMIC_RTL=opt.CCOBJ_DYNAMIC_RTL+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_DYNAMIC_FLX=opt.CCOBJ_DYNAMIC_FLX+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_RTL=opt.CCOBJ_STATIC_RTL+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX=opt.CCOBJ_STATIC_FLX+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCLINK_STATIC = CXX + "/nologo /MT "

    opt.HAVE_DLOPEN = 0
    opt.DLLIB=""

    # where to put the rtl: Cygwin requires the dll be in the PATH
    opt.SHLIB_DIR="bin"
    print "rtl located in bin directory"

    # find if we have BSD isnan in <cmath> (NAUGHTY!)
    try:
      shell(opt.CXX+" /w /c tmp"+os.sep+"dummy_nan.cxx /o tmp"+os.sep+"dummy_nan.o")
      opt.HAVE_ISNAN_IN_CMATH=1
      print "Isnan found in <cmath>"
    except:
      opt.HAVE_ISNAN_IN_CMATH=0

    # find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
    try:
      shell(opt.CXX+" /w /c tmp"+os.sep+"dummy_nan2.cxx /o tmp"+os.sep+"dummy_nan2.o")
      opt.HAVE_ISNAN_IN_IEEEFP=1
      print "Isnan found in <ieeefp.h>"
    except:
      opt.HAVE_ISNAN_IN_IEEEFP=0

    if opt.HAVE_ISNAN_IN_CMATH or opt.HAVE_ISNAN_IN_IEEEFP:
      print "Isnan supported"
    else:
      print "Isnan NOT supported"

    # find if we have stdint.h
    try:
      shell(opt.CXX+" /w /c tmp"+os.sep+"dummy_stdint.cxx /o tmp"+os.sep+"dummy_stdint.o")
      opt.HAVE_STDINT=1
      print "Have stdint.h support"
    except:
      opt.HAVE_STDINT=0
      print "stdint.h NOT supported"

    # find sizes of ints
    try:
      shell(opt.CXX+" /ML /w tmp"+os.sep+"intsizes.cxx /Fetmp"+os.sep+"intsizes.exe")
      # THIS CALL CANNOT USE THE SHELL BECAUSE IT REDIRECTS OUTPUT
      os.system("tmp"+os.sep+"intsizes > tmp"+os.sep+"intsizes.py")
      f = open("tmp"+os.sep+"intsizes.py")
      exec f in opt.__dict__
      f.close()
    except:
      print "FATAL: can't determine sizes of ints"
      sys.exit(1)
      
    # find if we have long long
    try:
      shell(opt.CXX+" /ML /w tmp"+os.sep+"longlong.cxx /Fetmp"+os.sep+"longlong.exe")
      os.system("tmp"+os.sep+"longlong >tmp"+os.sep+"longlong.py")
      f = open("tmp"+os.sep+"longlong.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_LONGLONG=1
    except:
      opt.HAVE_LONGLONG=0

    # find if we have long double
    try:
      shell(opt.CXX+" /ML /w tmp"+os.sep+"longdouble.cxx /Fetmp"+os.sep+"longdouble.exe")
      os.system("tmp"+os.sep+"longdouble >tmp"+os.sep+"longdouble.py")
      f = open("tmp"+os.sep+"longdouble.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_LONGDOUBLE=1
    except:
      opt.HAVE_LONGDOUBLE=0

    # find if we have _Bool
    try:
      shell(opt.CXX+" /ML /w tmp"+os.sep+"bool.c /Fetmp"+os.sep+"bool.exe")
      os.system("tmp"+os.sep+"bool >tmp"+os.sep+"bool.py")
      f = open("tmp"+os.sep+"bool.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_CBOOL=1
    except:
      opt.HAVE_CBOOL=0

    # find if we have _Complex
    try:
      shell(opt.CXX + " /ML /w tmp"+os.sep+"complex.c /Fetmp"+os.sep+"complex.exe")
      os.system("tmp"+os.sep+"complex >tmp"+os.sep+"complex.py")
      f = open("tmp"+os.sep+"complex.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_COMPLEX=1
    except:
      opt.HAVE_COMPLEX=0

    #calculate alignment tables
    vbls = [
      ("ALIGNOF_BOOL","bool"),
      ("ALIGNOF_SHORT","short"),
      ("ALIGNOF_INT","int"),
      ("ALIGNOF_LONG","long"),
      ("ALIGNOF_LONGLONG","long long"),
      
      ("ALIGNOF_FLOAT","float"),
      ("ALIGNOF_DOUBLE","double"),
      ("ALIGNOF_LONGDOUBLE","long double"),

      ("ALIGNOF_WCHAR","wchar_t"),
      ("ALIGNOF_VOIDP","void*"),
      ]

    opt.MAX_ALIGN = 1
    opt.flx_aligns = {}
    for k,t in vbls:
      v = opt.__dict__[k]
      opt.flx_aligns[v]=t
      if v > opt.MAX_ALIGN: opt.MAX_ALIGN = v
    opt.flx_aligns[1]="char"

    opt.DEBUG_FLAGS = "/g "
    opt.OPTIMISE = "/Ox /DNDEBUG "

  def report_config(self):
    opt = self.options
    print "**********************************************"
    print "msvc++",opt.use,"configuration"
    print "**********************************************"
    print "model=",opt.model
    print "static library tool #1                  : " + opt.AR
    print "static library tool #2                  : " + opt.RANLIB
    print
    print "Command to compile static Felix rtl     : " + opt.CCOBJ_STATIC_RTL
    print "Command to compile shared Felix rtl     : " + opt.CCOBJ_DYNAMIC_RTL
    print "Command to link shared Felix rtl        : " + opt.CCLINK_DYNAMIC_RTL
    print
    print "Command to compile static Felix driver  : " + opt.CCOBJ_STATIC_MAIN
    print "Command to compile dynamic Felix driver : " + opt.CCOBJ_DYNAMIC_MAIN
    print "Command to link dynamic Felix driver    : " + opt.CCLINK_DYNAMIC_MAIN

    print "Command to compile static Felix object  : " + opt.CCOBJ_STATIC_FLX
    print "Command to compile loadable Felix object: " + opt.CCOBJ_DYNAMIC_FLX
    print "Command to link loadable Felix object   : " + opt.CCLINK_DYNAMIC_FLX
    print

    print "Extension for object file               : " + opt.EXT_OBJ
    print "Extension for static archive            : " + opt.EXT_LIB
    print "Extension for loadable RTL              : " + opt.EXT_SHLIB
    print "Extension for executable                : " + opt.EXT_EXE
    print "RTL in directory                        : " + opt.SHLIB_DIR

    print
    if opt.SUPPORT_DYNAMIC_LOADING:
      print "Dynamic Loading Supported               : [Windows native]"
    else:
      print "Dynamic Loading                         : NOT SUPPORTED"
    print
    if opt.HAVE_ISNAN_IN_CMATH:
      print "NaN Support in                          : <cmath>"
    if opt.HAVE_ISNAN_IN_IEEEFP:
      print "NaN Support in                          : <ifpeee.h>"
    if not opt.HAVE_ISNAN_IN_IEEEFP and not opt.HAVE_ISNAN_IN_CMATH:
      print "NaN                                     : NOT SUPPORTED"
    print "**********************************************"


  def save_options(self, filename):
    f = open(filename,"w")
    ks = self.options.__dict__.keys()
    ks.sort()
    for k in ks:
      if k[0] != '_': # do not save __builtins__
        v = self.options.__dict__[k]
        f.write(k+'='+repr(v)+"\n")
    f.close()

  def load_options(self,filename):
    f = open(filename)
    exec f in self.options.__dict__
    f.close()

  # compile a file to an object suitable for inclusion in a shared 
  # library version of RTL
  def compile_shared_rtl(self,shell,indir,basename,outdir=None,include_path=[],macros=[],flags="",optimise=1,debug=0):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = opt.CCOBJ_DYNAMIC_RTL
    if flags: cmd = cmd + flags + " "

    # debug symbols
    if debug: cmd = cmd + "/Yd /Zi /RTC "

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE

    # include path
    for i in include_path: cmd = cmd +"-I"+i+" "

    # output file
    cmd = cmd + "/Fo"
    if outdir: cmd = cmd + outdir + os.sep
    cmd = cmd + basename + "_dynamic"+opt.EXT_OBJ+" "

    # macros
    for i in macros: cmd=cmd + "-D"+i+" "
    #input file
    if  indir: cmd = cmd + indir + os.sep
    cmd = cmd + basename
    cmd = cmd + ".cpp"

    # compile it
    shell(cmd)

  # compile a file to an object suitable for inclusion in a mainline
  # which links to shared libraries
  compile_shared_main = compile_shared_rtl
  compile_felix_dll = compile_shared_rtl

  # compile a file to an object suitable for inclusion in a static link 
  # version of the RTL 
  def compile_static_rtl(self,shell,indir,basename,outdir=None,include_path=[],macros=[],flags="",optimise=1,debug=0):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = opt.CCOBJ_STATIC_RTL
    if flags: cmd = cmd + flags + " "

    # debug symbols
    if debug: cmd = cmd + "/Yd "

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE+ " "

    # include path
    for i in include_path: cmd = cmd +"/I"+i+" "

    # output file
    cmd = cmd + "/Fo"
    if outdir: cmd = cmd + outdir + os.sep
    cmd = cmd + basename + "_static"+opt.EXT_OBJ+" "

    #macros
    for i in macros: cmd=cmd + "-D"+i+" "

    #input file
    if  indir: cmd = cmd + indir + os.sep
    cmd = cmd + basename
    cmd = cmd + ".cpp"

    # compile it
    shell(cmd)

  compile_static_main = compile_static_rtl
  compile_felix_static = compile_static_rtl

  def link_static_archive(self,shell,objects,archive):
    opt = self.options
    cmd = opt.AR +" /OUT:"+ archive + opt.EXT_LIB+" " 
    for i in objects: cmd = cmd + i + opt.EXT_OBJ + " "
    shell(cmd)
  
  def link_static_program(self,shell,objects,outfile,lib_path,libs):
    opt = self.options
    cmd = opt.CCLINK_STATIC
    for i in objects: cmd = cmd +i+opt.EXT_OBJ +" "
    cmd = cmd + "/Fe" +outfile + opt.EXT_EXE + " "
    cmd = cmd + "/link "
    for i in lib_path: cmd = cmd + "/LIBPATH:"+i+" "
    for i in libs: cmd = cmd + "/DEFAULTLIB:lib"+i+" "
    shell(cmd)
    
  def link_shared_rtl(self,shell,objects,outfile,lib_path=[],libs=[]):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_RTL
    cmd = cmd + "/Fe" +outfile + opt.EXT_SHLIB + " "
    for i in objects: cmd = cmd +i+opt.EXT_OBJ +" "
    cmd = cmd + "/link "
    for i in lib_path: cmd = cmd + "/LIBPATH:"+i+" "
    for i in libs: cmd = cmd + "/DEFAULTLIB:lib"+i+" "
    shell(cmd)
  
  link_felix_dll = link_shared_rtl
  
  def link_dynamic_program(self,shell,objects,outfile,lib_path,libs):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_MAIN
    cmd = cmd + "/Fe" +outfile  + opt.EXT_EXE + " "
    for i in objects: cmd = cmd +i+opt.EXT_OBJ+" "
    cmd = cmd + "/link "
    for i in lib_path: cmd = cmd + "/LIBPATH:"+i+" "
    for i in libs: cmd = cmd + "/DEFAULTLIB:lib"+i+" "
    shell(cmd)

@h=tangler("flxbuild/__init__.py")
@select(h)
#package base

@h=tangler("flxbuild/flxutil.py")
@select(h)
# build system utility module
import os
import glob
import stat
import string

def filetime(f):
  try:
    t = os.stat(f)[stat.ST_MTIME]
  except:
    t = 0
  return t

def erasefile(f):
  try: os.unlink(f)
  except: pass

def erasedir(d):
  fs = glob.glob(d+os.sep+"*")
  for f in fs: erasefile(f)
  try: os.rmdir(d)
  except: pass

def filecopy(a,b):
  f = open(a)
  g = open(b,"w")
  g.write(f.read())
  g.close()
  f.close()

def filecopy2dir(a,d):
  base = string.split(a,os.sep)[-1]
  filecopy(a,d+os.sep+base)

def get_stdout(x):
  fout = os.popen(x,"r")
  output = fout.readlines()
  result = fout.close()
  return result,output
  
@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import string
import time
import glob
if '' not in sys.path: sys.path = [''] + sys.path
import flxbuild
from flxbuild.flxutil import *

# user defined bootstrap to set up environment
try:
  execfile("bootstrap/init.py")
except:
  pass

#---------- utilities -------------------
# We're screwed if popen doesn't work ..

def xxqt(x):
  result = os.system(x)
  if result != 0: 
    print "FAIL:",x
    raise Error
  else: print x

def xqt(x): 
 if os.name == "posix":
   xxqt(x + " >/dev/null 2>&1")
 elif os.name == "nt":
   xxqt(x + " >NUL")
 else:
   xxqt(x)

def mkdirs(x):
  cps = string.split(x,os.sep)
  path = ""
  for d in cps:
    path = path + d + os.sep
    try: os.mkdir(path)
    except: pass

#----------------------------------------
time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)

class Error: pass
this = sys.modules[__name__]

# make doc directories to stop 'cp' complaining
try: os.mkdir("doc")
except: pass

try: os.mkdir("impldoc")
except: pass

try: os.mkdir("tut")
except: pass

try: os.mkdir("man")
except: pass

try: os.mkdir("htmlman")
except: pass

try: os.mkdir("tut"+os.sep+"doc")
except: pass

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except: return 0

def has_prefix(prefix,v):
  n = len (prefix)
  return prefix == v[:n]
  
quiet = 0
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

try: 
  xqt("apt-get -v")
  DEBIAN = 1
except:
  DEBIAN = 0

if DEBIAN:
  default_prefix='/usr'
  print "DEBIAN detected"

result,output = get_stdout("uname -m")
if not result:
  ARCH = output[0]
  print "CPU=",ARCH
else:
  print "Unknown CPU architecture"
  ARCH = None

result,output = get_stdout("uname -o")
if not result:
  OS = output[0]
  print "OS=",OS
else:
  print "Unknown OS"
  OS = None

PREFIX=os.getenv("PREFIX",default=default_prefix)
if PREFIX:
  print "Default Installation Root from environment: ",PREFIX

overrides = {}

# supported platforms

platforms = [
  "posix",
  "cygwin",
  "nocygwin",
  "mingw",
  "win32",
  "win64",
  "osx",
  "detect"
  ]

# map other names for them, obtained from
# various place like os.platform, os.system("mname -u"), etc

archmap = {
  "posix":"posix",
  "linux":"posix",
  "solaris":"posix",
  "cygwin":"cygwin",
  "nocygwin":"nocygwin",
  "mingw":"mingw",
  "nt":"win32",
  "win32":"win32",
  "osx":"osx",
  "detect":"detect"
  }

try:
  build_model = archmap[os.name]
  print "Build platform: " + build_model
except:
  print "Python returns unknown OS type, assuming 'detect'"
  build_model = "detect"

print "Detected Build model:",build_model

host_model = None
target_model = None

def check_model(m):
  try:
    m = archmap[m]
  except:
    print "Unknown model '"+m+"' please choose one of:"
    for m in platforms: print " * " + m
    sys.exit(1)
  return m

SAVE_CONFIG=""
LOAD_CONFIG=""
BOOTFILE=""

i = 1
while(i < len (sys.argv)):
  arg = sys.argv[i]
  if arg == "--quiet":
    quiet = 1
  elif arg == "--force":
    force = 1
  elif arg == "--refresh":
    refresh = 1
  elif arg == "--upgrade":
    upgrade = 1
  elif has_prefix("--prefix=", arg):
    maybe_prefix=arg[9:]
    if maybe_prefix !=  '': 
      PREFIX=maybe_prefix
  elif has_prefix("--set-int-",arg):
    x=arg[10:]
    i = string.index(x,'=')
    v = x[:i]
    a = x[i+1:]
    overrides[v]=eval(a)
  elif has_prefix("--set-string-",arg):
    x=arg[13:]
    i = string.index(x,'=')
    v = x[:i]
    a = x[i+1:]
    overrides[v]=a
  elif has_prefix("--build=",arg):
    build_model=check_model(arg[8:])
  elif has_prefix("--host=",arg):
    print "Specified host model:",host_model
    host_model=check_model(arg[7:])
  elif has_prefix("--target=",arg):
    target_model=check_model(arg[9:])
    print "Specified target model",target_model
  elif has_prefix("--boot=",arg):
    BOOTFILE=arg[7:]
  elif has_prefix("--save-config=",arg):
    SAVE_CONFIG=arg[14:]
  elif has_prefix("--load-config=",arg):
    LOAD_CONFIG=arg[14:]
  else:
    print "UNKNOWN CONFIGURE OPTION",arg
    sys.exit(1)
  i = i + 1

if BOOTFILE:
  try:
    execfile(BOOTFILE)
    print "Loaded",BOOTFILE
  except:
    print "Cannot execute specified bootstrap file: ", BOOTFILE
    sys.exit(1) 

if PREFIX=='': PREFIX=default_prefix

print "INSTALL PREFIX="+PREFIX

if LOAD_CONFIG:
  g = LOAD_CONFIG+os.sep+"*"
  files = glob.glob(g)
  for f in files:
    base = string.split(f,os.sep)[-1]
    out = 'config' + os.sep + base
    print "Copying ",f,"-->",out
    filecopy(f,out)

def save_config():
  if SAVE_CONFIG:
    print "*** SAVING configuration to ",SAVE_CONFIG
    mkdirs(SAVE_CONFIG)
    g = "config"+os.sep+"*"
    files = glob.glob(g)
    for f in files:
      base = string.split(f,os.sep)[-1]
      out = SAVE_CONFIG+ os.sep + base
      print "Copying ",f,"-->",out
      filecopy(f,out)

if not file_exists("config"+os.sep+"xlators_local.py"):
  filecopy2dir('tmp'+os.sep+'xlators_local.py','config')
  print "*** Created dummy local translator definitions for speed tests ***"
  print "   Edit config/xlators_local.py to suit your platform"
  print "   This file will never be clobbered, even on a reconfigure"
  print "   delete it to force reinstallation of the default"

if not file_exists("config"+os.sep+"xlators.py"):
  filecopy2dir("tmp"+os.sep+"xlators.py","config")
  print "*** Created new translator list for speed tests ***"
  print "   Edit config/xlators.py to suit your platform and testing needs"
  print "   This file will never be clobbered, even on a reconfigure"
  print "   delete it to force reinstallation of the default"

if file_exists("config"+os.sep+"config.py"):
  if force or upgrade:
    print "**** upgrading configuration"
  elif refresh:
    print "**** CLOBBERING old configuration"
  else:
    print "**** using old configuration!"
    if not quiet:
      print "*** config/config.py already exists"
      print "*** It is assumed to container client configuration data"
      print "*** and so will not be clobbered."
      print
      print "*** To upgrade the configuration use the --upgrade option"
      print
      print "*** To recreate the default configuration"
      print "*** delete config/config.py first"
    save_config()
    sys.exit(0)
else:
  if upgrade:
    print "**** Can't upgrade non-existent configuration"
    sys.exit(1)
  else:
    print "**** creating new configuration"

if force or refresh:
  a = file_exists("config"+os.sep+"speed_xlators.py")
  b = file_exists("config"+os.sep+"speed_xlators.py.old")
  if a and not b:
    filecopy("config"+os.sep+"speed_xlators.py","config"+os.sep+"speed_xlators.py.old")
    print "*** Created config/speed_xlators.py.old"

  filecopy('tmp'+os.sep+'speed_xlators.py.default','config'+os.sep+'speed_xlators.py')
  print "***Clobbered configuration for speed tests***"
  print "   Edit config/speed_xlators.py to suit your platform"



#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

execfile("script/ocaml_class.py")
HOST_OCAML = ocaml()
HOST_OCAML.autodetect(xqt,get_stdout)
HOST_OCAML.report_config()
HOST_OCAML.save_config("config/ocaml_config.py")

execfile("script/gxx_class.py")
execfile("script/msvcxx_class.py")
#
# Detect the native build model
# 
# This model has two uses: first, to build any build time
# tools needed to assist in generating the sources
# and second, to aid in selecting the options to cross-compile
# for the chosen host and target
#

print 
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print "Checking BUILD MODEL",build_model
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print

if build_model == "win32":
  BUILD_CXX=msvcxx()
else:
  BUILD_CXX=gxx()
BUILD_CXX.set_options(use="build",model=build_model,build=build_model)
BUILD_CXX.check_options(xqt)
BUILD_CXX.report_config()
BUILD_CXX.save_options("config/build_cxx.py")
build_model=BUILD_CXX.options.model

#
# Now create the host model: the compiler has to run
# on the build machine, but can cross compile for
# the host (if so, we can build but not test Felix)
#
# Cross compilation of the host tools may prevent any
# testing of the tools
#

if not host_model: 
  host_model=build_model
  print "Defaulting host model to build model",host_model
if not target_model: 
  target_model = host_model
  print "Defaulting target model to host model:",target_model


print 
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print "Checking HOST MODEL",host_model
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print

if host_model in ["posix","cygwin","nocygwin","mingw","detect"]:
  HOST_CXX=gxx()
  HOST_CXX.set_options(use="host",model=host_model,build=build_model)
  HOST_CXX.check_options(xqt)
  HOST_CXX.report_config()
  HOST_CXX.save_options("config/host_cxx.py")
elif host_model in ["win32"]:
  HOST_CXX=msvcxx()
  HOST_CXX.set_options(use="host",model=host_model,build=build_model)
  HOST_CXX.check_options(xqt)
  HOST_CXX.report_config()
  HOST_CXX.save_options("config/host_cxx.py")
else:
  print "Sorry only gnu and msvc++ tool chain supported at the moment"
  exit(1)

host_model = HOST_CXX.options.model

#
# Now create the target model: the compiler has to run
# on the build machine, but can cross compile for
# the target 
#
# cross compilation of C++ generated by Felix allows us to
# check the generated code compiles, but not that it runs
# [but the output is largely portable so we can still try]
#

print 
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print "Checking TARGET MODEL",target_model
print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
print

if target_model in ["posix","cygwin","nocygwin","mingw","detect"]:
  TARGET_CXX=gxx()
  TARGET_CXX.set_options(use="target",model=target_model,build=build_model)
  TARGET_CXX.check_options(xqt)
  TARGET_CXX.report_config()
  TARGET_CXX.save_options("config/target_cxx.py")
  CYGWIN = TARGET_CXX.options.CYGWIN
  MACOSX = TARGET_CXX.options.MACOSX
  WIN32 =  TARGET_CXX.options.WIN32
  HAVE_MSVC=0
  HAVE_GXX=1
elif target_model in ["win32"]:
  TARGET_CXX=msvcxx()
  TARGET_CXX.set_options(use="target",model=target_model,build=build_model)
  TARGET_CXX.check_options(xqt)
  TARGET_CXX.report_config()
  TARGET_CXX.save_options("config/target_cxx.py")
  CYGWIN=0
  MACOSX=0
  WIN32=1
  HAVE_MSVC=1
  HAVE_GXX=0
else:
  print "Sorry only gnu and msvc++ tool chain supported at the moment"
  exit(1)

target_model = TARGET_CXX.options.model

# see if we have interscript
try:
  xqt("iscr")
  ISCR="iscr "
except:
  ISCR="python -O interscript"+os.sep+"bin"+os.sep+"iscr.py "

SUPPORT_DYNAMIC_LOADING = TARGET_CXX.options.SUPPORT_DYNAMIC_LOADING

if SUPPORT_DYNAMIC_LOADING:
  DEFAULT_LINK_MODEL="dynamic"
else:
  DEFAULT_LINK_MODEL="static"

PYTHON_VERSION=sys.version
PYTHON_OS_NAME=os.name
PYTHON_OS_CURDIR=os.curdir
PYTHON_OS_PARDIR=os.pardir
PYTHON_OS_SEP=os.sep
PYTHON_OS_PATHSEP=os.pathsep

print "ESTABLISHED DEFAULT CONFIGURATION"

# attempt to clobber the configuration with old values
if not refresh:
  try:
    execfile("config"+os.sep+"config.py")
    print "Clobbered with old configuration"
  except: pass

# reclobber version details to this version
@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

# clobber with command line overrides now
g = globals()
for k in overrides.keys():
  g[k]=overrides[k]

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'flx_version_major',flx_version_major
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

def pr(f,x):
  print x
  f.write(x+"\n")

def p(f,s):
  try:
    x = s + "=" + repr(getattr(this,s))
    pr(f,x)
  except:
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!")

def pne(f,s):
  try:
    x = s + "=" + repr(getattr(this,s))
    f.write(x+"\n")
  except:
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!")


cf_reg = []

def copen(c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  cf_reg.append(f)
  f= open(f,"w")
  pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
  pr(f,'#'+CONFIG_TIME)
  return f

try:
  try: os.mkdir("config")
  except: pass

  print "Storing Interscript configuration"
  f = copen("iscr")
  pr(f,"#Interscript support")
  p(f,"ISCR")
  f.close()

  print "Storing Python configuration"
  f = copen("python")
  pr(f,"#Python config")
  p(f,"PYTHON_VERSION")
  p(f,"ISCR")
  f.close()

  print "Storing Python Filename separators"
  f = copen("filename")
  p(f,"PYTHON_OS_NAME")
  p(f,"PYTHON_OS_CURDIR")
  p(f,"PYTHON_OS_PARDIR")
  p(f,"PYTHON_OS_SEP")
  p(f,"PYTHON_OS_PATHSEP")
  f.close()


  print "Writing main config file"
  f = open("config"+os.sep+"config.py","w")
  pr(f,'import sys')
  pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
  pr(f,'#'+CONFIG_TIME)
  pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
  p(f,"CONFIG_GENERATOR_CVS_ID")
  p(f,"CONFIG_TIME")
  p(f,"flx_version")
  p(f,"flx_version_major")
  p(f,"godi_revision")
  p(f,"debian_revision")
  pr(f,"try:")
  pr(f,"  execfile('config/config_bootstrap.py')")
  pr(f,"except: pass")
  for fn in cf_reg:
    pr(f,"execfile("+repr(fn)+")")

  pr(f,"")
  pr(f,"#User configurable section")
  p(f,"SUPPORT_DYNAMIC_LOADING")
  pr(f,"SUPPORT_STATIC_LINKAGE = 1")
  p(f,"DEFAULT_LINK_MODEL")
  p(f,"CYGWIN")
  p(f,"MACOSX")
  p(f,"WIN32")
  p(f,"PREFIX")
  pr(f,"")

  pr(f,"execfile("+repr('script'+os.sep+'gxx_class.py')+")")
  pr(f,"execfile("+repr('script'+os.sep+'msvcxx_class.py')+")")
  pr(f,"execfile('script"+os.sep+"ocaml_class.py')")
  pr(f,"HOST_OCAML=ocaml()")
  pr(f,"HOST_OCAML.load_config("+repr('config'+os.sep+'ocaml_config.py')+")")
  pr(f,"HOST_CXX="+HOST_CXX.__class__.__name__+"()")
  pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
  pr(f,"TARGET_CXX="+TARGET_CXX.__class__.__name__+"()")
  pr(f,"TARGET_CXX.load_options("+repr('config'+os.sep+'target_cxx.py')+")")
  pr(f,"")
  p(f,"HAVE_GXX")
  pr(f,"FLXCC_CPP='cpp '")
  p(f,"HAVE_MSVC")
  pr(f,"# HACK to get all the target variables into global namespace")
  pr(f,"execfile("+repr('config'+os.sep+'target_cxx.py')+")")
  pr(f,"execfile("+repr('config'+os.sep+'ocaml_config.py')+")")
  f.close()
  if BOOTFILE:
    print "Copying bootfile :  "+ BOOTFILE
    filecopy(BOOTFILE,"config"+os.sep+"config_bootstrap.py")
except:
  print "Unable to create config"+os.sep+"config.py"
  sys.exit(1)

print "Created config"+os.sep+"config.py"
print "Edit this file to set your preferences"
print "This file will not be clobbered by the Felix build process"

save_config()


@h = tangler('config/flx_data.py')
@select(h)
import os
execfile("config"+os.sep+"config.py")

flx_keywords = [
    ("all", "ALL"),
    ("and", "AND"),
    ("as", "AS"),
    ("assert", "ASSERT"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("class", "CLASS"),
    ("code", "CODE"),
    ("comment", "COMMENT_KEYWORD"),
    ("const", "CONST"),
    ("cstruct", "CSTRUCT"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("expect", "EXPECT"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("goto", "GOTO"),
    ("header", "HEADER"),
    #("ident", "IDENT"),
    ("if", "IF"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("is", "IS"),
    ("isin", "ISIN"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("match", "MATCH"),
    ("module", "MODULE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noexpand", "NOEXPAND"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("of", "OF"),
    ("open","OPEN"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
    ("public", "PUBLIC"),
    ("publish", "PUBLISH"),
    ("read", "READ"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("set","SET"),
    ("struct", "STRUCT"),
    ("the", "THE"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("typematch", "TYPEMATCH"),
    ("type", "TYPE"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("when", "WHEN"),
    ("whilst", "WHILST"),
    ("with", "WITH"),
    ("until", "UNTIL"),
    ("_", "UNDERSCORE"),
  ]

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
  ]

flx_2_char_syms = [
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),

    ("LSQANGLE","[<"),
    ("RSQANGLE",">]"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
  ]


rmap = {}

tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress" : "void volatile*",
  "caddress" : "void const*",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if TARGET_CXX.options.HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if TARGET_CXX.options.HAVE_LONGDOUBLE:
   tmap["ldouble"]="long double"
else:
   tmap["ldouble"]="double"

if TARGET_CXX.options.HAVE_LONGLONG:
   tmap["vlong"]="long long"
   tmap["uvlong"]="unsigned long long"
else:
   tmap["vlong"]="long"
   tmap["uvlong"]="unsigned long"

if TARGET_CXX.options.HAVE_STDINT:
   tmap["int8"]="int8_t"
   tmap["uint8"]="uint8_t"
   tmap["int16"]="int16_t"
   tmap["uint16"]="uint16_t"
   tmap["int32"]="int32_t"
   tmap["uint32"]="uint32_t"
   tmap["int64"]="int64_t"
   tmap["uint64"]="uint64_t"

   # requirements
   rmap["int8"]="c99_stdint_h"
   rmap["uint8"]="c99_stdint_h"
   rmap["int16"]="c99_stdint_h"
   rmap["uint16"]="c99_stdint_h"
   rmap["int32"]="c99_stdint_h"
   rmap["uint32"]="c99_stdint_h"
   rmap["int64"]="c99_stdint_h"
   rmap["uint64"]="c99_stdint_h"
else:
   tmap["int8"]="signed char"
   tmap["uint8"]="unsigned char"
   sizes = { 
     TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
     TARGET_CXX.options.SIZEOF_INT*8: "int",
     TARGET_CXX.options.SIZEOF_LONG*8 : "long",
   }
   if TARGET_CXX.options.HAVE_LONGLONG:
     sizes[TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
   for size in [16,32,64]:
     try:
       t = sizes[size]
       tmap["int"+str(size)]=t
       tmap["uint"+str(size)]="unsigned " + t
     except:
       tmap["int"+str(size)]="emul_int"+str(size)
       tmap["uint"+str(size)]="emul_uint"+str(size)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

 
