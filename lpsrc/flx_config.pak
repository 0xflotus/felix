@head(1,'Configure')
@CVS_ID='$Id$'
@CVS_DATE='$Date$'
@CVS_REVISION='$Revision$'
@print 'CVS_REVISION='+CVS_REVISION+' on ' + CVS_DATE + ' UTC'

@h = tangler("tmp/check_cygwin.cxx",'c++')
@select(h)
int main(int,char*[]) { 
   int x = __CYGWIN__;
   return 0;
}

@h = tangler("tmp/dummy.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummyc.c",'c')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummy_lib.cxx",'c++')
@select(h)
extern "C" int fred(int,char*[]) { return 0; }

@h = tangler("tmp/dummy_main.cxx",'c++')
@select(h)
#include <dlfcn.h>
#include <stdlib.h>

int main(int,char*[]) { 
   void *lib = dlopen("tmp/dummy_lib.so",RTLD_NOW);
   if(!lib) exit(1);
   void *fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}

@h = tangler("tmp/dummy_nan.cxx",'c++')
@select(h)
#include <cmath>

int main(int,char*[]) { 
  float f = 0.0;
  std::isnan(f);
  return 0;
}

@h = tangler("tmp/dummy_nan2.cxx",'c++')
@select(h)
#include <ieeefp.h>

int main(int,char*[]) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}

@h = tangler("tmp/dummy_stdint.cxx",'c++')
@select(h)
#include <stdint.h>

int main(int,char*[]) { 
  {int8_t i;}
  {int16_t i;}
  {int32_t i;}
  {int64_t i;}
  {uint8_t i;}
  {uint16_t i;}
  {uint32_t i;}
  {uint64_t i;}
  return 0;
}

@h = tangler("tmp/intsizes.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct SHORT {
  char x;
  short y;
};

struct INT {
  char x;
  int y;
};

struct LONG {
  char x;
  long y;
};

struct FLOAT {
  char x;
  float y;
};

struct DOUBLE {
  char x;
  double y;
};

struct VOIDP {
  char x;
  void *y;
};

int main(int,char*[]) { 
  printf("SIZEOF_SHORT=%d\n",sizeof(short));
  printf("SIZEOF_INT=%d\n",sizeof(int));
  printf("SIZEOF_LONG=%d\n",sizeof(long));
  printf("SIZEOF_FLOAT=%d\n",sizeof(float));
  printf("SIZEOF_DOUBLE=%d\n",sizeof(double));
  printf("SIZEOF_VOIDP=%d\n",sizeof(void*));
  printf("ALIGNOF_SHORT=%d\n",offsetof(SHORT,y));
  printf("ALIGNOF_INT=%d\n",offsetof(INT,y));
  printf("ALIGNOF_LONG=%d\n",offsetof(LONG,y));
  printf("ALIGNOF_FLOAT=%d\n",offsetof(FLOAT,y));
  printf("ALIGNOF_DOUBLE=%d\n",offsetof(DOUBLE,y));
  printf("ALIGNOF_VOIDP=%d\n",offsetof(VOIDP,y));
  return 0;
}

@h = tangler("tmp/longlong.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGLONG {
  char x;
  long long y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long long));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONGLONG,y));
  return 0;
}

@h = tangler("tmp/longdouble.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGDOUBLE {
  char x;
  long double y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(long double));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(LONGDOUBLE,y));
  return 0;
}

@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# YOU SHOULD EDIT THIS FILE TO SUIT YOUR REQUIREMENTS

import sys
import os
import traceback

class Error: pass
this = sys.modules[__name__]

# make doc directories to stop 'cp' complaining
try: os.mkdir("doc")
except: pass

try: os.mkdir("impldoc")
except: pass

try: os.mkdir("tut")
except: pass

try: os.mkdir("man")
except: pass

try: os.mkdir("htmlman")
except: pass

try: os.mkdir("tut/doc")
except: pass

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except: return 0

quiet = 0
if len(sys.argv) > 1:
  if sys.argv[1] == "quiet":
    quiet = 1
    

if file_exists("config/config.py"):
  if not quiet:
    print "config/config.py already exists"
    print "It is assumed to container client configuration data"
    print "and so will not be clobbered."
    print "To recreate the default configuration"
    print "you must delete config/config.py and rerun this"
    print "script/make_config.py script"
  sys.exit(0)

# We're screwed if popen doesn't work ..
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  return result,output


# we cannot do anything fancy here like redirect
# stdout/stderr because we don't know what OS we're on

def xxqt(x):
  result = os.system(x)
  if result != 0: 
    print "FAIL:",x
    raise Error
  else: print x

def xqt(x): 
  xxqt(x + " >/dev/null 2>&1")


#---------------------------------------------------
# discover which ocaml compilers are available

try: # check if the client bootstrapped the native code compiler
  xqt('ocamlopt.opt')
  OCAMLCC = 'ocamlopt.opt '
  OCAMLLEX = 'ocamllex.opt '
  OCAMLYACC = 'ocamlyacc '
  NATIVE_CODE_COMPILER = 1
except:
  try: # check if the client has unbootstrapped native code compiler
    xqt('ocamlopt')
    OCAMLCC = 'ocamlopt '
    OCAMLLEX = 'ocamllex '
    OCAMLYACC = 'ocamlyacc '
    NATIVE_CODE_COMPILER = 1
  except:
    NATIVE_CODE_COMPILER = 0
    try: # check if the client has ocaml at all ..
      xqt('ocamlc')
      OCAMLCC = 'ocamlc '
      OCAMLLEX = 'ocamllex '
      OCAMLYACC = 'ocamlyacc '
      OCAMLDOC = 'ocamldoc '
    except:
      print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
      OCAMLCC = '#ocamlc '
      OCAMLLEX = '#ocamllex '
      OCAMLYACC = '#ocamlyacc '

try: # check if there is a native code version of the bytecode compiler
  xqt('ocamlc.opt')
  OCAMLB = 'ocamlc.opt '
except:
  try: # check if the client has ocaml at all
    xqt('ocamlc')
    OCAMLB = 'ocamlc '
  except:
    print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
    OCAMLB = '#ocamlc '

try:
  xqt('ocamldoc.opt')
  OCAMLDOC = 'ocamldoc.opt '
except:
  try:
    xqt('ocamldoc')
    OCAMLDOC = 'ocamldoc '
  except:
    print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
    OCAMLDOC = '#ocamldoc '

# set the default ocaml compiler
if OCAMLCC[0] != '#':
  OCAMLC = OCAMLCC
else:
  OCAMLC = OCAMLB

# where the ocaml is installed
result,x = get_stdout(OCAMLC + " -where")
OCAML_INCLUDE_DIRECTORY= x[0][0:-1]

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

# find if we have g++
try:
  xqt("g++ -w -c tmp/dummy.cxx -o tmp/dummy.o")
  CXX = "g++ " 
except:
  # just call the system CC if we don't have g++
  try:
    xqt("CC -c tmp/dummy.cxx -o tmp/dummy.o")
    CXX= "CC "
  except:
    print "WARNING: CANT FIND C++ COMPILER"
    CXX="#CC "

# find if we have CYGWIN
try:
  xqt("g++ -w -c tmp/check_cygwin.cxx -o tmp/dummy.o")
  CYGWIN=1
except:
  CYGWIN=0

# set C++ compilation commands
# for CYGWIN, this isn't enough, it needs to generate
# an additional output stub link library .. this is handled
# directly in the script/maker at the moment
#
# down the track, we should replace these variables
# with a Python function def, since that's more flexible
if CYGWIN:
  CCOBJ_DLLIB = CXX + "-w -g -c "
  CCOBJ_DLMAIN = CXX + "-w -g -c "
  CCLINK_DLLIB = CXX + "-w -Wl,-shared -Wl,--export-all-symbols -Wl,--enable-auto-import "
  CCLINK_DLMAIN = CXX + "-w "
else:
  CCOBJ_DLLIB = CXX + "-w -g -fPIC -c "
  CCOBJ_DLMAIN = CXX + "-w -g -fPIC -c "
  CCLINK_DLLIB = CXX + "-w -Wl,-shared -Wl,--export-dynamic "
  CCLINK_DLMAIN = CXX + "-w -Wl,-Bdynamic -Wl,--export-dynamic "

CCOBJ_STATIC_LIB = CXX + "-w -g -c "
CCOBJ_STATIC_MAIN = CXX + "-w -g -c "

# NOTE: static here means linking felix libraries with drivers
# it does NOT mean not to do dynamic loading at load time
CCLINK_STATIC = CXX  + "-w "

#check if we can get dlopen to work without -ldl (BSD doesn't need)
try:
  xqt(CCOBJ_DLLIB+"tmp/dummy_lib.cxx -o tmp/dummy_lib.o")
  xqt(CCOBJ_DLMAIN+"tmp/dummy_main.cxx -o tmp/dummy_main.o")
  xqt(CCLINK_DLLIB+"tmp/dummy_lib.o -o tmp/dummy_lib.so")
  xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
  xqt("tmp/dlmain tmp/dummy_lib.so")
  SUPPORT_DYNAMIC_LOADING = 1
except:
  try: # nope, try with -ldl
    CCLINK_DLMAIN = CCLINK_DLMAIN + "-ldl "
    xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
    xqt("tmp/dlmain tmp/dummy_lib.so")
    SUPPORT_DYNAMIC_LOADING = 1
  except:
    try: #again with --shared
      CCLINK_DLLIB = CXX + "-w --shared "
      CCLINK_DLMAIN = CXX + "-w -Wl,-Bdynamic -ldl "
      xqt(CCLINK_DLLIB+"tmp/dummy_lib.o -o tmp/dummy_lib.so")
      xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
      xqt("tmp/dlmain tmp/dummy_lib.so")
      SUPPORT_DYNAMIC_LOADING = 1
    except:
      SUPPORT_DYNAMIC_LOADING = 0

# see if we have strip
try:
  xqt("strip tmp/dummy.o")
  STRIP="strip"
except:
  STRIP="#strip"

# see if we have ar
try:
  xqt("ar -rc tmp/dummy.a tmp/dummy.o")
  AR="ar -rc "
except:
  AR="#ar -rc "

# see if we have ranlib
try:
  xqt("ranlib tmp/dummy.a")
  RANLIB="ranlib "
except:
  RANLIB="#ranlib "

# see if we have interscript
try:
  xqt("iscr")
  ISCR="iscr "
except:
  ISCR='env PYTHONPATH=. python -O interscript/bin/iscr.py '

# find if we have BSD isnan in <cmath> (NAUGHTY!)
try:
  xqt("g++ -w -c tmp/dummy_nan.cxx -o tmp/dummy_nan.o")
  HAVE_ISNAN_IN_CMATH=1
except:
  HAVE_ISNAN_IN_CMATH=0

# find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
try:
  xqt("g++ -w -c tmp/dummy_nan2.cxx -o tmp/dummy_nan2.o")
  HAVE_ISNANF_IN_IEEEFP=1
except:
  HAVE_ISNANF_IN_IEEEFP=0

# find if we have stdint.h
try:
  xqt("g++ -w -c tmp/dummy_stdint.cxx -o tmp/dummy_stdint.o")
  HAVE_STDINT=1
except:
  HAVE_STDINT=0

# find sizes of ints
try:
  xqt("g++ -w tmp/intsizes.cxx -o tmp/intsizes")
  xxqt("tmp/intsizes > tmp/intsizes.py")
  execfile("tmp/intsizes.py")
except:
  pass

# find if we have long long
try:
  xqt("g++ -w tmp/longlong.cxx -o tmp/longlong")
  xxqt("tmp/longlong >tmp/longlong.py")
  execfile("tmp/longlong.py")
  HAVE_LONGLONG=1
except:
  HAVE_LONGLONG=0

# find if we have long double
try:
  xqt("g++ -w tmp/longdouble.cxx -o tmp/longdouble")
  xxqt("tmp/longdouble >tmp/longdouble.py")
  execfile("tmp/longdouble.py")
  HAVE_LONGDOUBLE=1
except:
  HAVE_LONGDOUBLE=0

DEBUG_SYMBOLS = "-g "
CCOPT1 = "-O1 -DNDEBUG "
CCOPT2 = "-O3 --inline -DNDEBUG "

if SUPPORT_DYNAMIC_LOADING:
  DEFAULT_LINK_MODEL="dynamic"
else:
  DEFAULT_LINK_MODEL="static"


def pr(f,x):
  print x
  f.write(x+"\n")

def p(f,s):
  x = s + "=" + repr(getattr(this,s))
  pr(f,x)

try:
  try: os.mkdir("config")
  except: pass
  f = open("config/config.py","w")
  pr(f,"#Interscript support")
  p(f,"ISCR")
  pr(f,"")
  pr(f,"#Ocaml tools")
  p(f,"OCAMLC")
  p(f,"OCAMLB")
  p(f,"OCAMLLEX")
  p(f,"OCAMLYACC")
  p(f,"OCAMLDOC")
  p(f,"NATIVE_CODE_COMPILER")
  p(f,"OCAML_INCLUDE_DIRECTORY")
  pr(f,"")
  pr(f,"#C++ tools")
  p(f,"STRIP")
  p(f,"AR")
  p(f,"RANLIB")
  p(f,"CCOBJ_DLLIB")
  p(f,"CCOBJ_DLMAIN")
  p(f,"CCLINK_DLLIB")
  p(f,"CCLINK_DLMAIN")
  p(f,"CCOBJ_STATIC_LIB")
  p(f,"CCOBJ_STATIC_MAIN")
  p(f,"CCLINK_STATIC")
  p(f,"DEBUG_SYMBOLS")
  p(f,"CCOPT1")
  p(f,"CCOPT2")
  pr(f,"")
  pr(f,"# Data types")
  p(f,"HAVE_STDINT")
  p(f,"HAVE_LONGLONG")
  p(f,"HAVE_LONGDOUBLE")
  p(f,"SIZEOF_SHORT")
  p(f,"SIZEOF_INT")
  p(f,"SIZEOF_LONG")
  p(f,"SIZEOF_FLOAT")
  p(f,"SIZEOF_DOUBLE")
  p(f,"SIZEOF_VOIDP")
  p(f,"ALIGNOF_SHORT")
  p(f,"ALIGNOF_INT")
  p(f,"ALIGNOF_LONG")
  p(f,"ALIGNOF_FLOAT")
  p(f,"ALIGNOF_DOUBLE")
  p(f,"ALIGNOF_VOIDP")
  if HAVE_LONGLONG:
    p(f,"SIZEOF_LONGLONG")
    p(f,"ALIGNOF_LONGLONG")

  if HAVE_LONGDOUBLE:
    p(f,"SIZEOF_LONGDOUBLE")
    p(f,"ALIGNOF_LONGDOUBLE")

  p(f,"HAVE_ISNAN_IN_CMATH")
  p(f,"HAVE_ISNANF_IN_IEEEFP")

  pr(f,"")
  pr(f,"#User configurable section")
  p(f,"SUPPORT_DYNAMIC_LOADING")
  pr(f,"SUPPORT_STATIC_LINKAGE = 1")
  p(f,"DEFAULT_LINK_MODEL")
  p(f,"CYGWIN")
  pr(f,'PREFIX = "/usr/local"')
  f.close()
except:
  print "Unable to create config/config.py"
  sys.exit(1)

print "Created config/config.py"
print "Edit this file to set your preferences"
print "This file will not be clobbered by the Felix build process"

