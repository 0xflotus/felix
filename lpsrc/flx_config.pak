@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version = '1.1.0'
@godi_revision = '0'
@debian_revision = '1'

@select(tangler('script/gnatmaker.py'))
import os
import sys
import string
def xqt(x):
  print x
  os.system(x)

filebase = sys.argv[1]
split = string.split(filebase,'/')
filebase = split[-1]
indir =  string.join(split[:-1],'/')
curdir = os.getcwd()
os.chdir(indir)
outdir = sys.argv[2]
f = os.popen('gnatchop -w ' + filebase + '.ada | grep \\.adb')
units = f.readlines()
f.close()
units = [string.strip (x) for x in units]
for f in units:
  xqt("gcc -c "+ f)
xqt("gnatbind " + filebase)
xqt("gnatlink " + filebase)
os.chdir(curdir)
xqt("mv "+indir+'/'+filebase+" "+outdir)

@select(tangler('speed/xlators_default.py','python'))
# this file defines default translators
# do NOT edit this config file, instead:
#
# edit config/xlators_local.py to define local translators
# edit config/xlators.py to define the translators actually used

# for some weird reason: k is the source language, p is the test name
#
def mk_gcc(k,p):
  return "gcc -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gccopt(k,p):
  x = "gcc -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gcc_3_3(k,p):
  return "gcc-3.3 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gcc_3_3_opt(k,p):
  x = "gcc-3.3 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gcc_4_0(k,p):
  return "gcc-4.0 -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gcc_4_0_opt(k,p):
  x = "gcc-4.0 -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gpp_3_3(k,p):
  return "g++-3.3 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gpp_3_3_opt(k,p):
  x = "g++-3.3 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_gpp_4_0(k,p):
  return "g++-4.0 -x c++ -o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)

def mk_gpp_4_0_opt(k,p):
  x = "g++-4.0 -x c++ -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s speed/src/c/%s.c" % (k,p,p)
  return x

def mk_ocamlopt(k,p):
  return "ocamlopt.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)

def mk_ocamlb(k,p):
  return "ocamlc.opt -o speed/exes/%s/%s speed/src/ocaml/%s.ml" % (k,p,p)

def mk_felix(k,p):
  x = "bin/flx --test --force --static --optimise -c -DFLX_PTF_STATIC_POINTER "
  x = x + "speed/src/felix/%s && " % p
  x = x + "mv speed/src/felix/%s speed/exes/%s/%s" % (p,k,p)
  return x

def mk_ghc(k,p):
  return "ghc -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)

def mk_ghc_6_2_2(k,p):
  return "ghc-6.2.2 -O3 -fvia-C -optc -O3 -o speed/exes/%s/%s speed/src/haskell/%s.hs" % (k,p,p)

def mk_gnat(k,p):
  return "python script/gnatmaker.py speed/src/ada/%s speed/exes/%s " % (p,k)

def mk_gcj_4_0(k,p):
  x = "gcj-4.0  -O3 -fomit-frame-pointer -funroll-loops "
  x = x + "-o speed/exes/%s/%s --main=%s speed/src/java/%s.java" % (k,p,p,p)
  return x

@select(tangler('tmp/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here

@select(tangler('tmp/xlators.py','python'))
execfile('speed/xlators_default.py')
execfile('config/xlators_local.py')

# this table defines the actual translators
# which the performance tester will use
# comment out the lines you don't want,
# or add new ones if desired

xlators = [
  ('felix',mk_felix,'felix'),
  ('gcc',mk_gcc,'c'),
  ('gccopt',mk_gccopt,'c'),
#  ('gcc_3_3',mk_gcc_3_3,'c'),
#  ('gccopt_3_3',mk_gcc_3_3_opt,'c'),
#  ('gcc_4_0',mk_gcc_4_0,'c'),
#  ('gccopt_4_0',mk_gcc_4_0_opt,'c'),
#  ('gcj_4_0',mk_gcj_4_0_opt,'java'),
#  ('gnat',mk_gnat,"ada"),
#  ('gpp_3_3',mk_gpp_3_3,'c'),
#  ('gppopt_3_3',mk_gpp_3_3_opt,'c'),
#  ('gpp_4_0',mk_gpp_4_0,'c'),
#  ('gppopt_4_0',mk_gpp_4_0_opt,'c'),
#  ('ghc',mk_ghc,'haskell'),
#  ('ghc_6_2_2',mk_ghc_6_2_2,'haskell'),
  ('ocamlopt',mk_ocamlopt,'ocaml'),
#  ('ocamlb',mk_ocamlb,'ocaml'),
]

@h = tangler("tmp/check_cygwin.cxx",'c++')
@select(h)
int main(int,char*[]) { 
   int x = __CYGWIN__;
   return 0;
}

@h = tangler("tmp/dummy.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummyc.c",'c')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummy_lib.cxx",'c++')
@select(h)
extern "C" int fred(int,char*[]) { return 0; }

@h = tangler("tmp/dummy_main.cxx",'c++')
@select(h)
#include <dlfcn.h>
#include <stdlib.h>

int main(int,char*[]) { 
   void *lib = dlopen("tmp/dummy_lib.so",RTLD_NOW);
   if(!lib) exit(1);
   void *fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}

@h = tangler("tmp/gxx_x86.cxx",'c++')
@select(h)
#include <cstdio>
register void *sp __asm__ ("esp");

int main(int,char*[]) { 
   std::printf("Sp = %p\n",sp);
   return 0;
}

@h = tangler("tmp/gxx_hash.cxx",'c++')
@select(h)
#include <iostream>

// we only bother to check the include file exists
#include <ext/hash_map>
using namespace __gnu_cxx;

int main(int,char*[]) { 
   return 0;
}

@h = tangler("tmp/dummy_nan.cxx",'c++')
@select(h)
#include <cmath>

int main(int,char*[]) { 
  float f = 0.0;
  std::isnan(f);
  return 0;
}

@h = tangler("tmp/dummy_nan2.cxx",'c++')
@select(h)
#include <ieeefp.h>

int main(int,char*[]) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}

@h = tangler("tmp/dummy_stdint.cxx",'c++')
@select(h)
#include <stdint.h>

int main(int,char*[]) { 
  {int8_t i;}
  {int16_t i;}
  {int32_t i;}
  {int64_t i;}
  {uint8_t i;}
  {uint16_t i;}
  {uint32_t i;}
  {uint64_t i;}
  return 0;
}

@h = tangler("tmp/intsizes.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

enum enum_t {e_tag};
typedef void (*fp_t)(void);

struct BOOL {
  char x;
  bool y;
};

struct SHORT {
  char x;
  short y;
};

struct INT {
  char x;
  int y;
};

struct LONG {
  char x;
  long y;
};

struct FLOAT {
  char x;
  float y;
};

struct DOUBLE {
  char x;
  double y;
};

struct VOIDP {
  char x;
  void *y;
};

struct WCHAR {
  char x;
  wchar_t y;
};

struct ENUM {
  char x;
  enum_t y;
};

struct FUNCP {
  char x;
  fp_t y;
};

union endian_t {
  unsigned long x;
  unsigned char y[sizeof(unsigned long)];
} endian;

int main(int,char*[]) { 
  printf("SIZEOF_BOOL=%d\n",sizeof(bool));
  printf("SIZEOF_CBOOL=%d\n",sizeof(int)); // fallback
  printf("SIZEOF_SHORT=%d\n",sizeof(short));
  printf("SIZEOF_INT=%d\n",sizeof(int));
  printf("SIZEOF_LONG=%d\n",sizeof(long));
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long)); // fallback
  printf("SIZEOF_FLOAT=%d\n",sizeof(float));
  printf("SIZEOF_DOUBLE=%d\n",sizeof(double));
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_WCHAR=%d\n",sizeof(wchar_t));
  printf("SIZEOF_ENUM=%d\n",sizeof(enum_t));
  printf("SIZEOF_SIZEOF=%d\n",sizeof(sizeof(int)));

  printf("SIZEOF_COMPLEX=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_IMAGINARY=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_VOIDP=%d\n",sizeof(void*));
  printf("SIZEOF_FUNCP=%d\n",sizeof(fp_t));

  printf("ALIGNOF_BOOL=%d\n",offsetof(BOOL,y));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(BOOL,y)); // fallback
  printf("ALIGNOF_SHORT=%d\n",offsetof(SHORT,y));
  printf("ALIGNOF_INT=%d\n",offsetof(INT,y));
  printf("ALIGNOF_LONG=%d\n",offsetof(LONG,y));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONG,y)); // fallback
  
  printf("ALIGNOF_FLOAT=%d\n",offsetof(FLOAT,y));
  printf("ALIGNOF_DOUBLE=%d\n",offsetof(DOUBLE,y));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(DOUBLE,y)); // fallback
  
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_IMAGINARY=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_WCHAR=%d\n",offsetof(WCHAR,y));
  printf("ALIGNOF_ENUM=%d\n",offsetof(ENUM,y));
  printf("ALIGNOF_FUNCP=%d\n",offsetof(FUNCP,y));
  printf("ALIGNOF_VOIDP=%d\n",offsetof(VOIDP,y));

  printf("CHAR_IS_UNSIGNED=%d\n",((char)0xFF)>0?1:0);
  endian.x = 1ul;
  printf("LITTLE_ENDIAN=%d\n", endian.y[0]);
  printf("BIG_ENDIAN=%d\n", endian.y[sizeof(unsigned long)-1]);

  return 0;
}

@h = tangler("tmp/longlong.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGLONG {
  char x;
  long long y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long long));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONGLONG,y));
  return 0;
}

@h = tangler("tmp/longdouble.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGDOUBLE {
  char x;
  long double y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(long double));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(LONGDOUBLE,y));
  return 0;
}

@h = tangler("tmp/complex.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct COMPLEX {
  char x;
  _Complex y;
};

struct DOUBLECOMPLEX {
  char x;
  double _Complex y;
};

struct LONGDOUBLECOMPLEX {
  char x;
  long double _Complex y;
};

int main(int,char*[]) { 
  printf("SIZEOF_COMPLEX=%d\n",sizeof(_Complex));
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double _Complex));
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(long double _Complex));
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(COMPLEX,y));
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLECOMPLEX,y));
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(LONGDOUBLECOMPLEX,y));
  return 0;
}

@h = tangler("tmp/cbool.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct CBOOL {
  char x;
  _Bool y;
};

int main(int,char*[]) { 
  printf("SIZEOF_CBOOL=%d\n",sizeof(_Bool));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(CBOOL,y));
  return 0;
}

@h = tangler("tmp/cgoto.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { 
  void *label = &&label2;
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}

@h = tangler("tmp/asm_labels.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { 
  void *label = &&label2;
  __asm__(".global fred");
  __asm__("fred:");
  __asm__(""::"g"(&&label1));
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}

@h = tangler("tmp/check_inclass.cxx",'c++')
@select(h)
struct X {
  static const int i = 1;
};

int main(int,char*[]) { 
  return 0;
}

@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import string
import time

#---------- utilities -------------------
# We're screwed if popen doesn't work ..
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  if not result: result = 0
  return result,output


# we cannot do anything fancy here like redirect
# stdout/stderr because we don't know what OS we're on

def xxqt(x):
  result = os.system(x)
  if result != 0: 
    print "FAIL:",x
    raise Error
  else: print x

def xqt(x): 
  xxqt(x + " >/dev/null 2>&1")

#----------------------------------------
time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)

class Error: pass
this = sys.modules[__name__]

# make doc directories to stop 'cp' complaining
try: os.mkdir("doc")
except: pass

try: os.mkdir("impldoc")
except: pass

try: os.mkdir("tut")
except: pass

try: os.mkdir("man")
except: pass

try: os.mkdir("htmlman")
except: pass

try: os.mkdir("tut/doc")
except: pass

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except: return 0

def has_prefix(prefix,v):
  n = len (prefix)
  return prefix == v[:n]
  
quiet = 0
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

DEBIAN=0
if DEBIAN:
  default_prefix='/usr'

PREFIX=os.getenv("PREFIX",default=default_prefix)

overrides = {}

i = 1
while(i < len (sys.argv)):
  arg = sys.argv[i]
  if arg == "--quiet":
    quiet = 1
  elif arg == "--force":
    force = 1
  elif arg == "--refresh":
    refresh = 1
  elif arg == "--upgrade":
    upgrade = 1
  elif has_prefix("--prefix=", arg):
    maybe_prefix=arg[9:]
    if maybe_prefix !=  '': PREFIX=maybe_prefix
  elif has_prefix("--set-int-",arg):
    x=arg[10:]
    i = string.index(x,'=')
    v = x[:i]
    a = x[i+1:]
    overrides[v]=eval(a)
  elif has_prefix("--set-string-",arg):
    x=arg[13:]
    i = string.index(x,'=')
    v = x[:i]
    a = x[i+1:]
    overrides[v]=a
  else:
    print "UNKNOWN CONFIGURE OPTION",arg
    sys.exit(1)
  i = i + 1

if PREFIX=='': PREFIX=default_prefix

if not file_exists("config/xlators_local.py"):
  xqt('cp tmp/xlators_local.py config')
  print "*** Created dummy local translator definitions for speed tests ***"
  print "   Edit config/xlators_local.py to suit your platform"
  print "   This file will never be clobbered, even on a reconfigure"
  print "   delete it to force reinstallation of the default"

if not file_exists("config/xlators.py"):
  xqt('cp tmp/xlators.py config')
  print "*** Created new translator list for speed tests ***"
  print "   Edit config/xlators.py to suit your platform and testing needs"
  print "   This file will never be clobbered, even on a reconfigure"
  print "   delete it to force reinstallation of the default"

if file_exists("config/config.py"):
  if force or upgrade:
    print "**** upgrading configuration"
  elif refresh:
    print "**** CLOBBERING old configuration"
  else:
    print "**** using old configuration!"
    if not quiet:
      print "*** config/config.py already exists"
      print "*** It is assumed to container client configuration data"
      print "*** and so will not be clobbered."
      print
      print "*** To upgrade the configuration use the --upgrade option"
      print
      print "*** To recreate the default configuration"
      print "*** delete config/config.py first"
    sys.exit(0)
else:
  if upgrade:
    print "**** Can't upgrade non-existent configuration"
    sys.exit(1)
  else:
    print "**** creating new configuration"

if force or refresh:
  a = file_exists("config/speed_xlators.py")
  b = file_exists("config/speed_xlators.py.old")
  if a and not b:
    xqt('cp config/speed_xlators.py config/speed_xlators.py.old')
    print "*** Created config/speed_xlators.py.old"

  xqt('cp tmp/speed_xlators.py.default config/speed_xlators.py')
  print "***Clobbered configuration for speed tests***"
  print "   Edit config/speed_xlators.py to suit your platform"


#---------------------------------------------------
# discover which ocaml compilers are available

try: # check if the client bootstrapped the native code compiler
  xqt('ocamlopt.opt')
  OCAMLCC = 'ocamlopt.opt '
  OCAMLLEX = 'ocamllex.opt '
  OCAMLYACC = 'ocamlyacc '
  NATIVE_CODE_COMPILER = 1
except:
  try: # check if the client has unbootstrapped native code compiler
    xqt('ocamlopt')
    OCAMLCC = 'ocamlopt '
    OCAMLLEX = 'ocamllex '
    OCAMLYACC = 'ocamlyacc '
    NATIVE_CODE_COMPILER = 1
  except:
    NATIVE_CODE_COMPILER = 0
    try: # check if the client has ocaml at all ..
      xqt('ocamlc')
      OCAMLCC = 'ocamlc '
      OCAMLLEX = 'ocamllex '
      OCAMLYACC = 'ocamlyacc '
      OCAMLDOC = 'ocamldoc '
    except:
      print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
      OCAMLCC = '#ocamlc '
      OCAMLLEX = '#ocamllex '
      OCAMLYACC = '#ocamlyacc '

try: # check if there is a native code version of the bytecode compiler
  xqt('ocamlc.opt')
  OCAMLB = 'ocamlc.opt '
except:
  try: # check if the client has ocaml at all
    xqt('ocamlc')
    OCAMLB = 'ocamlc '
  except:
    print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
    OCAMLB = '#ocamlc '

try:
  xqt('ocamldoc.opt')
  OCAMLDOC = 'ocamldoc.opt '
except:
  try:
    xqt('ocamldoc')
    OCAMLDOC = 'ocamldoc '
  except:
    print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
    OCAMLDOC = '#ocamldoc '

# set the default ocaml compiler
if OCAMLCC[0] != '#':
  OCAMLC = OCAMLCC
else:
  OCAMLC = OCAMLB

OCAMLCP = "ocamlcp "
# where the ocaml is installed
result,x = get_stdout(OCAMLC + " -where")
OCAML_INCLUDE_DIRECTORY= x[0][0:-1]

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

# find if we have MSVC++
try:
  xqt("cl tmp/dummy.cxx /Fetmp/dummy_ms.exe")
  MSVC="cl "
  HAVE_MSVC = 1
except:
  MSVC="#cl "
  HAVE_MSVC = 0
  
# find if we have cpp
try:
  xqt("cpp tmp/dummyc.c tmp/dummy_cpp.out")
  CPP = "cpp " 
  HAVE_CPP = 1
except:
  HAVE_CPP = 0

# find if we have gcc
try:
  xqt("gcc -w -c tmp/dummyc.c -o tmp/dummy.o")
  GCC = "gcc " 
  HAVE_GCC = 1
except:
  HAVE_GCC = 0

# find if we have g++
try:
  xqt("g++ -w -c tmp/dummy.cxx -o tmp/dummy.o")
  GXX = "g++ " 
  HAVE_GXX = 1
except:
  HAVE_GXX = 0

# find if we have g++ on 32 bit x86 platform with named registers
try:
  xqt("g++ -w tmp/gxx_x86.cxx -o tmp/x86_check")
  xqt('tmp/x86_check')
  HAVE_GXX_X86 = 1
except:
  HAVE_GXX_X86 = 0

if HAVE_GXX_X86:
  USE_REGPARM3=1
else:
  USE_REGPARM3=0


# find if we have g++ supporting computed jumps
try:
  xqt("g++ tmp/cgoto.cxx -o tmp/cgoto")
  xqt("tmp/cgoto")
  HAVE_CGOTO = 1
except:
  HAVE_CGOTO = 0

# find if we have g++ supporting computed jumps and asm labels
try:
  xqt("g++ tmp/asm_labels.cxx -o tmp/asm_labels")
  xqt("tmp/asm_labels")
  HAVE_ASM_LABELS = 1
except:
  HAVE_ASM_LABELS = 0

# find if we have g++ supported ext/ with STL extensions
try:
  xqt("g++ tmp/gxx_hash.cxx -o tmp/gxx_hash")
  xqt("tmp/gxx_hash")
  HAVE_STL_GNU_CXX = 1
except:
  HAVE_STL_GNU_CXX = 0


# find if we have cc
try:
  xqt("cc -c tmp/dummyc.c -o tmp/dummy.o")
  CC = "cc "
  HAVE_CC=1
except:
  HAVE_CC=0

# find if we have CC (not 'cc' but 'CC')
try:
  xqt("CC -c tmp/dummy.cxx -o tmp/dummy.o")
  CCCC = "CC "
  HAVE_CCCC=1
except:
  HAVE_CCCC = 0

# choose compiler
if HAVE_MSVC: CXX = MSVC
elif HAVE_GXX: CXX = GXX
elif HAVE_CCCC: CXX = CCCC
else:
  CXX = "#g++ "
  print "WARNING: CANT FIND C++ COMPILER"

if HAVE_MSVC: CC = MSVC
elif HAVE_GXX: CC = GCC
elif HAVE_CCC: CC = CC
else:
  CC = "#gcc "
  print "WARNING: CANT FIND C COMPILER"

# set preprocessor
if HAVE_GCC:
  CPP = CXX + "-E "

# find if we have CYGWIN
try:
  xqt("g++ -w -c tmp/check_cygwin.cxx -o tmp/dummy.o")
  CYGWIN=1
except:
  CYGWIN=0

# find if we have static const init in class
try:
  xqt(CXX+" -w -c tmp/check_inclass.cxx -o tmp/dummy.o")
  HAVE_INCLASS_MEMBER_INITIALIZATION=1
except:
  HAVE_INCLASS_MEMBER_INITIALIZATION=0

# find if we have pkg-config
if 1:
  result,output=get_stdout("pkg-config --list-all")
  if result==0:
    HAVE_PKGCONFIG=1
    PKGCONFIG_PACKAGES = {}
    for line in output:
      w = string.index(line,' ')
      if w != -1:
        key = line[0:w]
        data= line[w:-1]
        data = string.strip(data)
        PKGCONFIG_PACKAGES[key]=data
  else:
    HAVE_PKGCONFIG=0
    PKGCONFIG_PACKAGES = {}

# set preprocessing command for flxcc (tricky!)
FLXCC_CPP = CPP
if HAVE_PKGCONFIG:
  pkgs = ""
  for i in PKGCONFIG_PACKAGES.keys(): pkgs = pkgs + i + " "
  # This hack was needed by me to find python2.3 on my old box ..
  # this is bad stuff ..
  #FLXCC_CPP = FLXCC_CPP + "-I/usr/local/include/python2.3 `pkg-config --cflags "+pkgs+"`"

# set C++ compilation commands
# for CYGWIN, this isn't enough, it needs to generate
# an additional output stub link library .. this is handled
# directly in the script/maker at the moment
#
# down the track, we should replace these variables
# with a Python function def, since that's more flexible
#FORCE_DEBUG="-g "
FORCE_DEBUG=""

if CYGWIN:
  CCOBJ_DLLIB = CXX + "-w "+FORCE_DEBUG+"-c "
  CCOBJ_DLMAIN = CXX + "-w "+FORCE_DEBUG+"-c "
  CCLINK_DLLIB = CXX + "-w -Wl,-shared -Wl,--export-all-symbols -Wl,--enable-auto-import "
  CCLINK_DLMAIN = CXX + "-w "
else:
  CCOBJ_DLLIB = CXX + "-w "+FORCE_DEBUG+"-fPIC -c "
  CCOBJ_DLMAIN = CXX + "-w "+FORCE_DEBUG+"-fPIC -c "
#  CCLINK_DLLIB = CXX + "-w -Wl,-shared -Wl,--export-dynamic "
  CCLINK_DLLIB = CXX + "-w -shared  "
  CCLINK_DLMAIN = CXX + "-w -Wl,-Bdynamic -Wl,--export-dynamic "

CCOBJ_STATIC_LIB = CXX + "-w "+FORCE_DEBUG+"-c "
CCOBJ_STATIC_MAIN = CXX + "-w "+FORCE_DEBUG+"-c "

# NOTE: static here means linking felix libraries with drivers
# it does NOT mean not to do dynamic loading at load time
CCLINK_STATIC = CXX  + "-w "

#check if we can get dlopen to work without -ldl (BSD doesn't need)
HAVE_DLOPEN = 0
try:
  xqt(CCOBJ_DLLIB+"tmp/dummy_lib.cxx -o tmp/dummy_lib.o")
  xqt(CCOBJ_DLMAIN+"tmp/dummy_main.cxx -o tmp/dummy_main.o")
  xqt(CCLINK_DLLIB+"tmp/dummy_lib.o -o tmp/dummy_lib.so")
  xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
  xqt("tmp/dlmain tmp/dummy_lib.so")
  SUPPORT_DYNAMIC_LOADING = 1
  HAVE_DLOPEN = 1
except:
  try: # nope, try with -ldl
    CCLINK_DLMAIN = CCLINK_DLMAIN + "-ldl "
    xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
    xqt("tmp/dlmain tmp/dummy_lib.so")
    HAVE_DLOPEN = 1
    SUPPORT_DYNAMIC_LOADING = 1
  except:
    try: #again with --shared
      CCLINK_DLLIB = CXX + "-w --shared "
      CCLINK_DLMAIN = CXX + "-w -Wl,-Bdynamic -ldl "
      xqt(CCLINK_DLLIB+"tmp/dummy_lib.o -o tmp/dummy_lib.so")
      xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
      xqt("tmp/dlmain tmp/dummy_lib.so")
      HAVE_DLOPEN = 1
      SUPPORT_DYNAMIC_LOADING = 1
    except:
      SUPPORT_DYNAMIC_LOADING = 0

# see if we have strip
try:
  xqt("strip tmp/dummy.o")
  STRIP="strip"
except:
  STRIP="#strip"

# see if we have ar
try:
  xqt("ar -rc tmp/dummy.a tmp/dummy.o")
  AR="ar -rc "
except:
  AR="#ar -rc "

# see if we have ranlib
try:
  xqt("ranlib tmp/dummy.a")
  RANLIB="ranlib "
except:
  RANLIB="#ranlib "

# see if we have interscript
try:
  xqt("iscr")
  ISCR="iscr "
except:
  ISCR='env PYTHONPATH=. python -O interscript/bin/iscr.py '

# find if we have BSD isnan in <cmath> (NAUGHTY!)
try:
  xqt(CXX+" -w -c tmp/dummy_nan.cxx -o tmp/dummy_nan.o")
  HAVE_ISNAN_IN_CMATH=1
except:
  HAVE_ISNAN_IN_CMATH=0

# find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
try:
  xqt(CXX+" -w -c tmp/dummy_nan2.cxx -o tmp/dummy_nan2.o")
  HAVE_ISNANF_IN_IEEEFP=1
except:
  HAVE_ISNANF_IN_IEEEFP=0

# find if we have stdint.h
try:
  xqt(CXX+" -w -c tmp/dummy_stdint.cxx -o tmp/dummy_stdint.o")
  HAVE_STDINT=1
except:
  HAVE_STDINT=0

# find sizes of ints
try:
  xqt(CXX+" -w tmp/intsizes.cxx -o tmp/intsizes")
  xxqt("tmp/intsizes > tmp/intsizes.py")
  execfile("tmp/intsizes.py")
except:
  print "FATAL: can't determine sizes of ints"
  sys.exit(1)
  
# find if we have long long
try:
  xqt(CXX+" -w tmp/longlong.cxx -o tmp/longlong")
  xxqt("tmp/longlong >tmp/longlong.py")
  execfile("tmp/longlong.py")
  HAVE_LONGLONG=1
except:
  HAVE_LONGLONG=0

# find if we have long double
try:
  xqt(CXX+" -w tmp/longdouble.cxx -o tmp/longdouble")
  xxqt("tmp/longdouble >tmp/longdouble.py")
  execfile("tmp/longdouble.py")
  HAVE_LONGDOUBLE=1
except:
  HAVE_LONGDOUBLE=0

# find if we have _Bool
try:
  xqt(CC+" -w tmp/bool.c -o tmp/bool")
  xxqt("tmp/bool >tmp/bool.py")
  execfile("tmp/bool.py")
  HAVE_CBOOL=1
except:
  HAVE_CBOOL=0

# find if we have _Complex
try:
  xqt("gcc -w tmp/complex.c -o tmp/complex")
  xxqt("tmp/complex >tmp/complex.py")
  execfile("tmp/complex.py")
  HAVE_COMPLEX=1
except:
  HAVE_COMPLEX=0

#calculate alignment tables
vbls = [
  ("ALIGNOF_BOOL","bool"),
  ("ALIGNOF_SHORT","short"),
  ("ALIGNOF_INT","int"),
  ("ALIGNOF_LONG","long"),
  ("ALIGNOF_LONGLONG","long long"),
  
  ("ALIGNOF_FLOAT","float"),
  ("ALIGNOF_DOUBLE","double"),
  ("ALIGNOF_LONGDOUBLE","long double"),

  ("ALIGNOF_WCHAR","wchar_t"),
  ("ALIGNOF_VOIDP","void*"),
  ]

MAX_ALIGN = 1
aligns = {}
for k,t in vbls:
  v = eval(k)
  aligns[v]=t
  if v > MAX_ALIGN: MAX_ALIGN = v
aligns[1]="char"

DEBUG_SYMBOLS = "-g "
CCOPT1 = "-O1 -DNDEBUG "
CCOPT2 = "-O3 --inline -DNDEBUG "

if SUPPORT_DYNAMIC_LOADING:
  DEFAULT_LINK_MODEL="dynamic"
else:
  DEFAULT_LINK_MODEL="static"

PYTHON_VERSION=sys.version
PYTHON_OS_NAME=os.name
PYTHON_OS_CURDIR=os.curdir
PYTHON_OS_PARDIR=os.pardir
PYTHON_OS_SEP=os.sep
PYTHON_OS_PATHSEP=os.pathsep

print "ESTABLISHED DEFAULT CONFIGURATION"

# attempt to clobber the configuration with old values
if not refresh:
  try:
    execfile("config/config.py")
  except: pass

# reclobber version details to this version
@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

# clobber with command line overrides now
g = globals()
for k in overrides.keys():
  g[k]=overrides[k]

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

FLX_SONAME = 'libflx_dynamic.so.'+flx_version[0:string.index(flx_version,'.')]


def pr(f,x):
  print x
  f.write(x+"\n")

def p(f,s):
  x = s + "=" + repr(getattr(this,s))
  pr(f,x)

def pne(f,s):
  x = s + "=" + repr(getattr(this,s))
  f.write(x+"\n")

cf_reg = []

def copen(c):
  f = "config/"+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  cf_reg.append(f)
  f= open(f,"w")
  pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
  pr(f,'#'+CONFIG_TIME)
  return f

try:
  try: os.mkdir("config")
  except: pass
  f = copen("math")
  pr(f,"# Data types")
  p(f,"HAVE_STDINT")
  p(f,"HAVE_LONGLONG")
  p(f,"HAVE_LONGDOUBLE")
  p(f,"HAVE_COMPLEX")
  p(f,"HAVE_CBOOL")

  p(f,"SIZEOF_SIZEOF")
  p(f,"SIZEOF_BOOL")
  p(f,"SIZEOF_CBOOL")
  p(f,"SIZEOF_SHORT")
  p(f,"SIZEOF_INT")
  p(f,"SIZEOF_LONG")
  p(f,"SIZEOF_LONGLONG")

  p(f,"SIZEOF_FLOAT")
  p(f,"SIZEOF_DOUBLE")
  p(f,"SIZEOF_LONGDOUBLE")

  p(f,"SIZEOF_COMPLEX")
  p(f,"SIZEOF_DOUBLECOMPLEX")
  p(f,"SIZEOF_LONGDOUBLECOMPLEX")

  p(f,"SIZEOF_IMAGINARY")
  p(f,"SIZEOF_DOUBLEIMAGINARY")
  p(f,"SIZEOF_LONGDOUBLEIMAGINARY")

  p(f,"SIZEOF_VOIDP")
  p(f,"SIZEOF_WCHAR")
  p(f,"SIZEOF_ENUM")
  p(f,"SIZEOF_FUNCP")

  p(f,"ALIGNOF_BOOL")
  p(f,"ALIGNOF_CBOOL")
  p(f,"ALIGNOF_SHORT")
  p(f,"ALIGNOF_INT")
  p(f,"ALIGNOF_LONG")
  p(f,"ALIGNOF_LONGLONG")

  p(f,"ALIGNOF_FLOAT")
  p(f,"ALIGNOF_DOUBLE")
  p(f,"ALIGNOF_LONGDOUBLE")

  p(f,"ALIGNOF_COMPLEX")
  p(f,"ALIGNOF_DOUBLECOMPLEX")
  p(f,"ALIGNOF_LONGDOUBLECOMPLEX")

  p(f,"ALIGNOF_IMAGINARY")
  p(f,"ALIGNOF_DOUBLEIMAGINARY")
  p(f,"ALIGNOF_LONGDOUBLEIMAGINARY")

  p(f,"ALIGNOF_VOIDP")
  p(f,"ALIGNOF_WCHAR")
  p(f,"ALIGNOF_ENUM")
  p(f,"ALIGNOF_FUNCP")
  p(f,"MAX_ALIGN")

  pr(f,"flx_aligns = "+repr(aligns))

  p(f,"HAVE_ISNAN_IN_CMATH")
  p(f,"HAVE_ISNANF_IN_IEEEFP")

  p(f,"CHAR_IS_UNSIGNED")
  p(f,"LITTLE_ENDIAN")
  p(f,"BIG_ENDIAN")
  f.close()

  f = copen("ocaml")
  pr(f,"#Ocaml tools")
  p(f,"OCAMLC")
  p(f,"OCAMLB")
  p(f,"OCAMLCP")
  p(f,"OCAMLLEX")
  p(f,"OCAMLYACC")
  p(f,"OCAMLDOC")
  p(f,"NATIVE_CODE_COMPILER")
  p(f,"OCAML_INCLUDE_DIRECTORY")
  f.close()

  f = copen("c")
  pr(f,"#C++ tools")
  p(f,"HAVE_CPP")
  p(f,"HAVE_CC")
  p(f,"HAVE_CCCC")
  p(f,"HAVE_MSVC")
  p(f,"HAVE_GXX")
  p(f,"HAVE_GXX_X86")
  p(f,"USE_REGPARM3")
  p(f,"HAVE_CGOTO")
  p(f,"HAVE_ASM_LABELS")
  p(f,"HAVE_INCLASS_MEMBER_INITIALIZATION")
  p(f,"HAVE_PKGCONFIG")
  p(f,"HAVE_DLOPEN")
  p(f,"CXX")
  p(f,"CPP")
  p(f,"FLXCC_CPP")
  p(f,"CCOBJ_DLLIB")
  p(f,"CCOBJ_DLMAIN")
  p(f,"CCLINK_DLLIB")
  p(f,"CCLINK_DLMAIN")
  p(f,"CCOBJ_STATIC_LIB")
  p(f,"CCOBJ_STATIC_MAIN")
  p(f,"CCLINK_STATIC")
  p(f,"DEBUG_SYMBOLS")
  p(f,"CCOPT1")
  p(f,"CCOPT2")
  p(f,"HAVE_STL_GNU_CXX")
  f.close()

  f = copen("posix")
  p(f,"STRIP")
  p(f,"AR")
  p(f,"RANLIB")
  f.close()

  f = copen("pkgconfig")
  p(f,"HAVE_PKGCONFIG")
  pne(f,"PKGCONFIG_PACKAGES")
  f.close()

  f = copen("iscr")
  pr(f,"#Interscript support")
  p(f,"ISCR")
  f.close()

  f = copen("python")
  pr(f,"#Python config")
  p(f,"PYTHON_VERSION")
  p(f,"ISCR")
  f.close()

  f = copen("filename")
  p(f,"PYTHON_OS_NAME")
  p(f,"PYTHON_OS_CURDIR")
  p(f,"PYTHON_OS_PARDIR")
  p(f,"PYTHON_OS_SEP")
  p(f,"PYTHON_OS_PATHSEP")
  f.close()


  f = open("config/config.py","w")
  pr(f,'#'+CONFIG_TIME)
  pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
  p(f,"CONFIG_GENERATOR_CVS_ID")
  p(f,"CONFIG_TIME")
  p(f,"flx_version")
  p(f,"godi_revision")
  p(f,"debian_revision")
  p(f,"FLX_SONAME")
  for fn in cf_reg:
    pr(f,"execfile('"+fn+"')")

  pr(f,"")
  pr(f,"#User configurable section")
  p(f,"SUPPORT_DYNAMIC_LOADING")
  pr(f,"SUPPORT_STATIC_LINKAGE = 1")
  p(f,"DEFAULT_LINK_MODEL")
  p(f,"CYGWIN")
  p(f,"PREFIX")
  f.close()
except:
  print "Unable to create config/config.py"
  sys.exit(1)

print "Created config/config.py"
print "Edit this file to set your preferences"
print "This file will not be clobbered by the Felix build process"

@h = tangler('config/flx_data.py')
@select(h)
execfile('config/config.py')

flx_keywords = [
    ("all", "ALL"),
    ("and", "AND"),
    ("as", "AS"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("class", "CLASS"),
    ("code", "CODE"),
    ("comment", "COMMENT_KEYWORD"),
    ("const", "CONST"),
    ("cstruct", "CSTRUCT"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("goto", "GOTO"),
    ("header", "HEADER"),
    #("ident", "IDENT"),
    ("if", "IF"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("match", "MATCH"),
    ("module", "MODULE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("of", "OF"),
    ("open","OPEN"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
    ("public", "PUBLIC"),
    ("publish", "PUBLISH"),
    ("read", "READ"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("set","SET"),
    ("struct", "STRUCT"),
    ("the", "THE"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("typematch", "TYPEMATCH"),
    ("type", "TYPE"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("when", "WHEN"),
    ("whilst", "WHILST"),
    ("with", "WITH"),
    ("until", "UNTIL"),
    ("_", "UNDERSCORE"),
  ]

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
  ]

flx_2_char_syms = [
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),
    ("LSQANGLE","[<"),
    ("RSQANGLE",">]"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
  ]


rmap = {}

tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress" : "void volatile*",
  "caddress" : "void const*",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if HAVE_LONGDOUBLE:
   tmap["ldouble"]="long double"
else:
   tmap["ldouble"]="double"

if HAVE_LONGLONG:
   tmap["vlong"]="long long"
   tmap["uvlong"]="unsigned long long"
else:
   tmap["vlong"]="long"
   tmap["uvlong"]="unsigned long"

if HAVE_STDINT:
   tmap["int8"]="int8_t"
   tmap["uint8"]="uint8_t"
   tmap["int16"]="int16_t"
   tmap["uint16"]="uint16_t"
   tmap["int32"]="int32_t"
   tmap["uint32"]="uint32_t"
   tmap["int64"]="int64_t"
   tmap["uint64"]="uint64_t"

   # requirements
   rmap["int8"]="c99_stdint_h"
   rmap["uint8"]="c99_stdint_h"
   rmap["int16"]="c99_stdint_h"
   rmap["uint16"]="c99_stdint_h"
   rmap["int32"]="c99_stdint_h"
   rmap["uint32"]="c99_stdint_h"
   rmap["int64"]="c99_stdint_h"
   rmap["uint64"]="c99_stdint_h"
else:
   tmap["int8"]="signed char"
   tmap["uint8"]="unsigned char"
   sizes = { 
     SIZEOF_SHORT*8 : "short",
     SIZEOF_INT*8: "int",
     SIZEOF_LONG*8 : "long",
   }
   if HAVE_LONGLONG:
     sizes[SIZEOF_LONGLONG*8]="long long"
   for size in [16,32,64]:
     try:
       t = sizes[size]
       tmap["int"+str(size)]=t
       tmap["uint"+str(size)]="unsigned " + t
     except:
       tmap["int"+str(size)]="emul_int"+str(size)
       tmap["uint"+str(size)]="emul_uint"+str(size)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

 
