@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '4'
@flx_version_release = '_rc2'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch+flx_version_release
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'


@head(2,'CVS log')
@select(tangler('config/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here
selected_xlators = [
  'ocamlopt',
  'gccopt',
  'gnat',
  'gjc',
  'felix'
]

@select(tangler("cpkgs/__init__.py"))
@select(tangler("cpkgs/build/__init__.py"))
@select(tangler("cpkgs/host/__init__.py"))
@select(tangler("cpkgs/target/__init__.py"))
@select(tangler("cpkgs/target/libgc.py"))
import config

#    'Boehm-Demers-Weiser Conservative Garbage Collector',
#    'http://www.hpl.hp.com/personal/Hans_Boehm/gc/'
HAVE_LIBGC = config.TARGET_CXX.check_header_exists("gc.h")

@select(tangler("cpkgs/target/windowsh.py"))
import config

#    "Microsoft Windows core CAPI",
#    "http://microsoft.com"
HAVE_WINDOWS_H = config.TARGET_CXX.check_header_exists("windows.h")

@select(tangler("cpkgs/target/opengl.py"))
import os

import config

#    'Open GL Graphics Rendering Toolkit',
#    "http://www.opengl.org"
if config.MACOSX:
  HAVE_OPENGL = config.TARGET_CXX.check_header_exists("OpenGL"+os.sep+"gl.h")
else:
  HAVE_OPENGL = config.TARGET_CXX.check_header_exists("GL"+os.sep+"gl.h")


@select(tangler("cpkgs/target/pthread.py"))
from fbuild.flxbuild.flxutil import xqt, ExecutionError

# try to use Linux getconf to find the pthread version
# Ubuntu/Breezy returns "NPTL 2.3.5"
# IEEE Std 1003.1-2001 for getconf uses the variable: _POSIX_THREADS
# if the system does not support Pthreads, getconf returns 0
# if the system supports Pthreads, getconf returns nonzero
# on RedHat Linux, "getconf _POSIX_THREADS" returns 1
# on Darwin (Mac OS X), "getconf _POSIX_THREADS" returns 200112
try:
  output = xqt('getconf', '_POSIX_THREADS')
except ExecutionError, TypeError:
  # getconf failed
  PTHREAD_MODEL = 'Unknown'
else:
  if int(output[0].strip()) != 0:
    PTHREAD_MODEL = 'POSIX'
  else:
    PTHREAD_MODEL = 'Unknown'


print "Pthread model according to linuxy getconf=", PTHREAD_MODEL


@select(tangler("cpkgs/host/pkgconfig.py"))
from fbuild.flxbuild.flxutil import ExecutionError
# see if we have pkg-config
try:
  from config.pkgconfig_config import *
except ImportError:
  from fbuild.flxbuild.flxutil import xqt
  from fbuild.flxbuild.config_support import cwrite, pr, pa

  try:
    xqt("pkg-config --version")
    HAVE_PKGCONFIG = 1
  except ExecutionError:
    HAVE_PKGCONFIG = 0

  print "Storing pkgconfig configuration"
  f = cwrite("pkgconfig")
  pr(f,"#pkgconfig support")
  pa(f,locals(),"HAVE_PKGCONFIG")
  f.close()

@select(tangler('version.py'))
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")
@doc()

@select(tangler('config/flx_data.py'))
import os
import config

cprecedence = [
  "atom",
  "primary",
  "postfix",
  "unary",
  "cast",
  "pm",
  "mult",
  "add",
  "shift",
  "rel",
  "eq",
  "band",
  "bxor",
  "bor",
  "and",
  "xor",
  "or",
  "cond",
  "assign",
  "comma",
  "expr"
]

cpp_keywords = [
  'asm',
  'auto',
  'bool',
  'break',
  'case',
  'catch',
  'char'
  'class',
  'const',
  'const_cast',
  'continue',
  'default',
  'delete',
  'do',
  'double',
  'dynamic_cast',
  'else',
  'enum',
  'explicit',
  'extern',
  'false',
  'float',
  'for',
  'friend',
  'goto',
  'if',
  'inline',
  'int',
  'long',
  'mutable',
  'namespace',
  'new',
  'operator',
  'private',
  'protected',
  'public',
  'register',
  'reinterpret_cast',
  'return',
  'short',
  'signed',
  'sizeof',
  'static',
  'static_cast',
  'struct',
  'switch',
  'template',
  'this',
  'throw',
  'true',
  'try',
  'typedef',
  'typeid',
  'typename',
  'union',
  'unsigned',
  'using',
  'virtual',
  'void',
  'volatile',
  'wchar_t',
  'while',
  ]

flx_expr_terminator_keywords = [
    ("all", "ALL"),
    ("assert", "ASSERT"),
    ("axiom", "AXIOM"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("cclass", "CCLASS"),
    ("cfun", "CFUNCTION"),
    ("class", "CLASS"),
    ("comment", "COMMENT_KEYWORD"),
    ("compound", "COMPOUND"),
    ("const", "CONST"),
    ("cparse", "CPARSE"),
    ("cproc", "CPROCEDURE"),
    ("cstruct", "CSTRUCT"),
    ("ctor", "CTOR"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endcase", "ENDCASE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("expect", "EXPECT"),
    ("export", "EXPORT"),
    ("extern", "EXTERN"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("gen", "GENERATOR"),
    ("goto", "GOTO"),
    ("halt", "HALT"),
    ("header", "HEADER"),
    ("ident", "IDENT"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("instance", "INSTANCE"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("lemma", "LEMMA"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("module", "MODULE"),
    ("namespace", "NAMESPACE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("open","OPEN"),
    ("package", "PACKAGE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
#    ("public", "PUBLIC"),
#    ("publish", "PUBLISH"),
    ("reduce", "REDUCE"),
    ("ref", "REF"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("SCHEME", "SCHEME"),
    ("syntax", "SYNTAX"),
    ("static", "STATIC"),
    ("struct", "STRUCT"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("type", "TYPE"),
    ("typeclass", "TYPECLASS"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("virtual", "VIRTUAL"),
    ("where", "WHERE"),
    ("when", "WHEN"),
#    ("whilst", "WHILST"),
    ("with", "WITH"),
#    ("until", "UNTIL"),
    ("yield", "YIELD"),
    ("_gc_pointer", "GC_POINTER"),
    ("_gc_type", "GC_TYPE"),
    ("_svc", "SVC"),
    ("_deref", "DEREF"),
  ]

flx_other_keywords = [
    ("and", "AND"),
    ("as", "AS"),
    ("callback", "CALLBACK"),
    ("code", "CODE"),
    ("false", "FALSE"),
    ("if", "IF"),
    ("isin", "ISIN"),
    ("match", "MATCH"),
    ("noexpand", "NOEXPAND"),
    ("of", "OF"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("the", "THE"),
    ("true", "TRUE"),
    ("typematch", "TYPEMATCH"),
    ("typecase", "TYPECASE"),
    ("whence", "WHENCE"),
    ("unless", "UNLESS"),
    ("_", "UNDERSCORE"),
  ]

# symbols that can't be followed by a keyword
flx_leadin_keywords = [
  "COLONCOLON",
  "DOT",
  "RIGHTARROW",
  "STRUCT",
  "UNION",
  "CLASS",
  "FUNCTION",
  "PROCEDURE",
  "GENERATOR",
]

flx_keywords = flx_expr_terminator_keywords + flx_other_keywords

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
    ("HASH","#"),
  ]

flx_2_char_syms = [
    ("DOLLARDOLLAR","$$"),
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),

    ("AMPERAMPER","&&"),
    ("VBARVBAR","||"),
    ("SLOSHAMPER","\\\\&"),
    ("SLOSHVBAR","\\\\|"),
    ("SLOSHCIRCUMFLEX","\\\\^"),
    ("HASHBANG","#!"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
#    ("DOTRIGHTARROW",".->"),
    ("LONGRIGHTARROW","-->"),
    ("PARSE_ACTION","=>#"),
    ("HASHBANGSLASH","#!/"),
  ]

flx_syms = flx_1_char_syms + flx_2_char_syms + flx_3_char_syms

rmap = {}

tmap = {
  # addressing
  "byte"      : "unsigned char",
  "size"      : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress"  : "void volatile*",
  "caddress"  : "void const*",
  "address"   : "void *",
  "offset"    : "ptrdiff_t",
  "ptrdiff"   : "ptrdiff_t",

  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

#if config.TARGET_CXX.options.HAVE_COMPLEX:
if False:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["fcomplex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["fcomplex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["fcomplex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["fcomplex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if config.TARGET_CXX.options.HAVE_LONGDOUBLE:
  tmap["ldouble"]="long double"
else:
  tmap["ldouble"]="double"

if config.TARGET_CXX.options.HAVE_LONGLONG:
  tmap["vlong"]="long long"
  tmap["uvlong"]="unsigned long long"
else:
  tmap["vlong"]="long"
  tmap["uvlong"]="unsigned long"

if config.TARGET_CXX.options.HAVE_STDINT:
  tmap["int8"]="int8_t"
  tmap["uint8"]="uint8_t"
  tmap["int16"]="int16_t"
  tmap["uint16"]="uint16_t"
  tmap["int32"]="int32_t"
  tmap["uint32"]="uint32_t"
  tmap["int64"]="int64_t"
  tmap["uint64"]="uint64_t"
  tmap["intptr"]="intptr_t"
  tmap["uintptr"]="uintptr_t"
  tmap["intmax"]="intmax_t"
  tmap["uintmax"]="uintmax_t"

  # requirements
  rmap["int8"]="c99_stdint_h"
  rmap["uint8"]="c99_stdint_h"
  rmap["int16"]="c99_stdint_h"
  rmap["uint16"]="c99_stdint_h"
  rmap["int32"]="c99_stdint_h"
  rmap["uint32"]="c99_stdint_h"
  rmap["int64"]="c99_stdint_h"
  rmap["uint64"]="c99_stdint_h"
  rmap["intptr"]="c99_stdint_h"
  rmap["uintptr"]="c99_stdint_h"
  rmap["intmax"]="c99_stdint_h"
  rmap["uintmax"]="c99_stdint_h"
else:
  tmap["int8"]="signed char"
  tmap["uint8"]="unsigned char"
  sizes = {
    config.TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
    config.TARGET_CXX.options.SIZEOF_INT*8: "int",
    config.TARGET_CXX.options.SIZEOF_LONG*8 : "long",
  }
  tmap["intmax"]="long"
  tmap["uintmax"]="unsigned long"
  if config.TARGET_CXX.options.HAVE_LONGLONG:
    sizes[config.TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
    tmap["intmax"]="long long"
    tmap["uintmax"]="unsigned long long"
  for size in [16,32,64]:
    try:
      t = sizes[size]
    except KeyError:
      tmap["int"+str(size)]="emul_int"+str(size)
      tmap["uint"+str(size)]="emul_uint"+str(size)
    else:
      tmap["int"+str(size)]=t
      tmap["uint"+str(size)]="unsigned " + t
  try:
    tmap["intptr"]=sizes[config.TARGET_CXX.options.SIZEOF_VOIDP*8]
    tmap["uintptr"]="unsigned "+sizes[config.TARGET_CXX.options.SIZEOF_VOIDP*8]
  except:
    print "NO INTEGER THE SIZE OF A VOID*!"
    sys.exit(1)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

@select(tangler('iscrutil.py'))
import os
import sys
import pickle

import interscript.frames.inputf

def unix2native(f):
    if os.path.splitdrive(f)[0] or f.startswith(os.sep):
        return f

    return os.path.join(*f.split('/'))

class setup_test:
    def __init__(self, iframe, root,
            zfill_pattern=[1],
            zfill_default=2):
        self.iframe = iframe
        self.root = root
        self.zfill_pattern = zfill_pattern
        self.zfill_default = 2

        self.native_root = unix2native(self.root)
        self.levels = []
        self.testcount = 0
        self.argcount = 0

        self.names_written = {}

        self.katfile = self.root + 'categories'

        if os.path.exists(self.katfile):
            f = open(self.katfile)
            try:
                self.registry_in = pickle.load(f)
            finally:
                f.close()
        else:
            self.registry_in = {}

        self.registry_out = {}


    def head(self, level, title=None):
        if not self.levels and level > 1:
            self.levels = [1]

        self.testcount = 0
        self.argcount = 0

        while len(self.levels) < level:
            self.levels.append(0)

        self.levels[level - 1] = self.levels[level - 1] + 1
        self.levels = self.levels[:level]

        if title is None:
            title = self.root + self.level_str()

        return self.iframe.head(level, title)


    def level_str(self):
        levels = []
        for i in range(len(self.levels)):
            try:
                z = self.zfill_pattern[i]
            except IndexError:
                z = self.zfill_default

            levels.append(str(self.levels[i]).zfill(z))

        return '.'.join(levels)


    def filename(self):
        return self.root + self.level_str()


    def tangler(self, name,
            extension='',
            filetype=interscript.frames.inputf.deduce):

        path = name + extension
        if path in self.names_written:
            print 'file:', path, 'already created!'

            # XXX: NEED TO GENERATE A NEW FILE NAME
            # XXX: what's the proper way to error out an interscript file?
            sys.exit(1)

        h = self.iframe.tangler(path, filetype)
        self.names_written[path] = h

        return h


    def test(self, *args, **kwds):
        name = '%s-%s' % (self.filename(), self.testcount)


        # if categories are specified, write them out
        categories = []
        if 'categories' in kwds:
            categories = kwds['categories']
            del kwds['categories']

        # construct the tangler
        tangler = apply(self.tangler, (name,) + args, kwds)
        for cat in categories: self.kat(tangler,cat)

        self.testcount = self.testcount + 1
        return tangler

    def expect(self):
        name = '%s-%s' % (self.filename(), self.testcount - 1)

        return self.tangler(name, '.expect', 'data')


    def args(self, arguments):
        name = '%s-%s-%s' % (self.filename(), self.testcount - 1, self.argcount)
        self.argcount = self.argcount + 1

        a = self.tangler(name, '.args', 'data')

        select(a)
        tangle(arguments)
        doc()

        return a


    def test_args(self, arglist, *args, **kwds):
        t = apply(self.test, args, kwds)

        for arguments in arglist:
            self.args(arguments)

        return t


    def expect_args(self, arguments):
        self.args(arguments)

        name = '%s-%s-%s' % (self.filename(), self.testcount - 1, self.argcount - 1)

        return self.tangler(name, '.argexpect', 'data')


    def kat(self, tangler, code):
        tangler.writeline(
            "//Check " + code,
            self.iframe.original_filename,
            self.iframe.original_count
        )

        f = tangler.sink.filename
        ff = f.split('/')[-1][:-4]
        v = self.registry_out.get(code,[])
        if ff not in v:
            self.iframe.set_anchor(ff)
            v.append(ff)
            self.registry_out[code]=v


    def emit_katlist(self):
        self.iframe.begin_list("keyed")
        keys = self.registry_in.keys()
        keys.sort()
        for k in keys:
            v = self.registry_in[k]
            self.iframe.item(k)
            first = 1
            for i in v:
                if first: first = 0
                else: self.iframe.weave(", ")
                self.iframe.ref_anchor(i)
        self.iframe.end_list()


    def write_katfile(self):
        dirname = os.path.split(self.katfile)[0]
        if not os.path.exists(dirname):
            os.makedirs(dirname)

        f = open(self.katfile, 'w')
        try:
            pickle.dump(self.registry_out, f)
        finally:
            f.close()
