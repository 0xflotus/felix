@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID

@h = tangler("tmp/check_cygwin.cxx",'c++')
@select(h)
int main(int,char*[]) { 
   int x = __CYGWIN__;
   return 0;
}

@h = tangler("tmp/dummy.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummyc.c",'c')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummy_lib.cxx",'c++')
@select(h)
extern "C" int fred(int,char*[]) { return 0; }

@h = tangler("tmp/dummy_main.cxx",'c++')
@select(h)
#include <dlfcn.h>
#include <stdlib.h>

int main(int,char*[]) { 
   void *lib = dlopen("tmp/dummy_lib.so",RTLD_NOW);
   if(!lib) exit(1);
   void *fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}

@h = tangler("tmp/dummy_nan.cxx",'c++')
@select(h)
#include <cmath>

int main(int,char*[]) { 
  float f = 0.0;
  std::isnan(f);
  return 0;
}

@h = tangler("tmp/dummy_nan2.cxx",'c++')
@select(h)
#include <ieeefp.h>

int main(int,char*[]) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}

@h = tangler("tmp/dummy_stdint.cxx",'c++')
@select(h)
#include <stdint.h>

int main(int,char*[]) { 
  {int8_t i;}
  {int16_t i;}
  {int32_t i;}
  {int64_t i;}
  {uint8_t i;}
  {uint16_t i;}
  {uint32_t i;}
  {uint64_t i;}
  return 0;
}

@h = tangler("tmp/intsizes.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

enum enum_t {e_tag};
typedef void (*fp_t)(void);

struct BOOL {
  char x;
  bool y;
};

struct SHORT {
  char x;
  short y;
};

struct INT {
  char x;
  int y;
};

struct LONG {
  char x;
  long y;
};

struct FLOAT {
  char x;
  float y;
};

struct DOUBLE {
  char x;
  double y;
};

struct VOIDP {
  char x;
  void *y;
};

struct WCHAR {
  char x;
  wchar_t y;
};

struct ENUM {
  char x;
  enum_t y;
};

struct FUNCP {
  char x;
  fp_t y;
};

union endian_t {
  unsigned long x;
  unsigned char y[sizeof(unsigned long)];
} endian;

int main(int,char*[]) { 
  printf("SIZEOF_BOOL=%d\n",sizeof(bool));
  printf("SIZEOF_CBOOL=%d\n",sizeof(int)); // fallback
  printf("SIZEOF_SHORT=%d\n",sizeof(short));
  printf("SIZEOF_INT=%d\n",sizeof(int));
  printf("SIZEOF_LONG=%d\n",sizeof(long));
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long)); // fallback
  printf("SIZEOF_FLOAT=%d\n",sizeof(float));
  printf("SIZEOF_DOUBLE=%d\n",sizeof(double));
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_WCHAR=%d\n",sizeof(wchar_t));
  printf("SIZEOF_ENUM=%d\n",sizeof(enum_t));
  printf("SIZEOF_SIZEOF=%d\n",sizeof(sizeof(int)));

  printf("SIZEOF_COMPLEX=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_IMAGINARY=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_VOIDP=%d\n",sizeof(void*));
  printf("SIZEOF_FUNCP=%d\n",sizeof(fp_t));

  printf("ALIGNOF_BOOL=%d\n",offsetof(BOOL,y));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(BOOL,y)); // fallback
  printf("ALIGNOF_SHORT=%d\n",offsetof(SHORT,y));
  printf("ALIGNOF_INT=%d\n",offsetof(INT,y));
  printf("ALIGNOF_LONG=%d\n",offsetof(LONG,y));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONG,y)); // fallback
  
  printf("ALIGNOF_FLOAT=%d\n",offsetof(FLOAT,y));
  printf("ALIGNOF_DOUBLE=%d\n",offsetof(DOUBLE,y));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(DOUBLE,y)); // fallback
  
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_IMAGINARY=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_WCHAR=%d\n",offsetof(WCHAR,y));
  printf("ALIGNOF_ENUM=%d\n",offsetof(ENUM,y));
  printf("ALIGNOF_FUNCP=%d\n",offsetof(FUNCP,y));
  printf("ALIGNOF_VOIDP=%d\n",offsetof(VOIDP,y));

  printf("CHAR_IS_UNSIGNED=%d\n",((char)0xFF)>0?1:0);
  endian.x = 1ul;
  printf("LITTLE_ENDIAN=%d\n", endian.y[0]);
  printf("BIG_ENDIAN=%d\n", endian.y[sizeof(unsigned long)-1]);

  return 0;
}

@h = tangler("tmp/longlong.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGLONG {
  char x;
  long long y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long long));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONGLONG,y));
  return 0;
}

@h = tangler("tmp/longdouble.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGDOUBLE {
  char x;
  long double y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(long double));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(LONGDOUBLE,y));
  return 0;
}

@h = tangler("tmp/complex.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct COMPLEX {
  char x;
  _Complex y;
};

struct DOUBLECOMPLEX {
  char x;
  double _Complex y;
};

struct LONGDOUBLECOMPLEX {
  char x;
  long double _Complex y;
};

int main(int,char*[]) { 
  printf("SIZEOF_COMPLEX=%d\n",sizeof(_Complex));
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double _Complex));
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(long double _Complex));
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(COMPLEX,y));
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLECOMPLEX,y));
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(LONGDOUBLECOMPLEX,y));
  return 0;
}

@h = tangler("tmp/cbool.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct CBOOL {
  char x;
  _Bool y;
};

int main(int,char*[]) { 
  printf("SIZEOF_CBOOL=%d\n",sizeof(_Bool));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(CBOOL,y));
  return 0;
}

@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# YOU SHOULD EDIT THIS FILE TO SUIT YOUR REQUIREMENTS

@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
print CONFIG_GENERATOR_CVS_ID
import sys
import os
import traceback
import string

class Error: pass
this = sys.modules[__name__]

# make doc directories to stop 'cp' complaining
try: os.mkdir("doc")
except: pass

try: os.mkdir("impldoc")
except: pass

try: os.mkdir("tut")
except: pass

try: os.mkdir("man")
except: pass

try: os.mkdir("htmlman")
except: pass

try: os.mkdir("tut/doc")
except: pass

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except: return 0

quiet = 0
if len(sys.argv) > 1:
  if sys.argv[1] == "quiet":
    quiet = 1
    

if file_exists("config/config.py"):
  if not quiet:
    print "config/config.py already exists"
    print "It is assumed to container client configuration data"
    print "and so will not be clobbered."
    print "To recreate the default configuration"
    print "you must delete config/config.py and rerun this"
    print "script/make_config.py script"
  sys.exit(0)

# We're screwed if popen doesn't work ..
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  if not result: result = 0
  return result,output


# we cannot do anything fancy here like redirect
# stdout/stderr because we don't know what OS we're on

def xxqt(x):
  result = os.system(x)
  if result != 0: 
    print "FAIL:",x
    raise Error
  else: print x

def xqt(x): 
  xxqt(x + " >/dev/null 2>&1")


#---------------------------------------------------
# discover which ocaml compilers are available

try: # check if the client bootstrapped the native code compiler
  xqt('ocamlopt.opt')
  OCAMLCC = 'ocamlopt.opt '
  OCAMLLEX = 'ocamllex.opt '
  OCAMLYACC = 'ocamlyacc '
  NATIVE_CODE_COMPILER = 1
except:
  try: # check if the client has unbootstrapped native code compiler
    xqt('ocamlopt')
    OCAMLCC = 'ocamlopt '
    OCAMLLEX = 'ocamllex '
    OCAMLYACC = 'ocamlyacc '
    NATIVE_CODE_COMPILER = 1
  except:
    NATIVE_CODE_COMPILER = 0
    try: # check if the client has ocaml at all ..
      xqt('ocamlc')
      OCAMLCC = 'ocamlc '
      OCAMLLEX = 'ocamllex '
      OCAMLYACC = 'ocamlyacc '
      OCAMLDOC = 'ocamldoc '
    except:
      print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
      OCAMLCC = '#ocamlc '
      OCAMLLEX = '#ocamllex '
      OCAMLYACC = '#ocamlyacc '

try: # check if there is a native code version of the bytecode compiler
  xqt('ocamlc.opt')
  OCAMLB = 'ocamlc.opt '
except:
  try: # check if the client has ocaml at all
    xqt('ocamlc')
    OCAMLB = 'ocamlc '
  except:
    print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
    OCAMLB = '#ocamlc '

try:
  xqt('ocamldoc.opt')
  OCAMLDOC = 'ocamldoc.opt '
except:
  try:
    xqt('ocamldoc')
    OCAMLDOC = 'ocamldoc '
  except:
    print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
    OCAMLDOC = '#ocamldoc '

# set the default ocaml compiler
if OCAMLCC[0] != '#':
  OCAMLC = OCAMLCC
else:
  OCAMLC = OCAMLB

# where the ocaml is installed
result,x = get_stdout(OCAMLC + " -where")
OCAML_INCLUDE_DIRECTORY= x[0][0:-1]

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

# find if we have MSVC++
try:
  xqt("cl tmp/dummy.cxx /Fetmp/dummy_ms.exe")
  MSVC="cl "
  HAVE_MSVC = 1
except:
  MSVC="#cl "
  HAVE_MSVC = 0
  
# find if we have cpp
try:
  xqt("cpp tmp/dummyc.c tmp/dummy_cpp.out")
  CPP = "cpp " 
  HAVE_CPP = 1
except:
  HAVE_CPP = 0

# find if we have gcc
try:
  xqt("gcc -w -c tmp/dummyc.c -o tmp/dummy.o")
  GCC = "gcc " 
  HAVE_GCC = 1
except:
  HAVE_GCC = 0

# find if we have g++
try:
  xqt("g++ -w -c tmp/dummy.cxx -o tmp/dummy.o")
  GXX = "g++ " 
  HAVE_GXX = 1
except:
  HAVE_GXX = 0

# find if we have cc
try:
  xqt("cc -c tmp/dummyc.c -o tmp/dummy.o")
  CC = "cc "
  HAVE_CC=1
except:
  HAVE_CC = 0

# find if we have CC (not 'cc' but 'CC')
try:
  xqt("CC -c tmp/dummy.cxx -o tmp/dummy.o")
  CCCC = "CC "
  HAVE_CCCC=1
except:
  HAVE_CCCC = 0

# choose compiler
if HAVE_MSVC: CXX = MSVC
elif HAVE_GXX: CXX = GXX
elif HAVE_CCCC: CXX = CCCC
else:
  CXX = "#g++ "
  print "WARNING: CANT FIND C++ COMPILER"

# set preprocessor
if not HAVE_CPP:
  CPP = CXX + "-E "

# find if we have CYGWIN
try:
  xqt("g++ -w -c tmp/check_cygwin.cxx -o tmp/dummy.o")
  CYGWIN=1
except:
  CYGWIN=0

# find if we have pkg-config
if 1:
  result,output=get_stdout("pkg-config --list-all")
  if result==0:
    HAVE_PKGCONFIG=1
    PKGCONFIG_PACKAGES = {}
    for line in output:
      w = string.index(line,' ')
      if w != -1:
        key = line[0:w]
        data= line[w:-1]
        data = string.strip(data)
        PKGCONFIG_PACKAGES[key]=data
  else:
    HAVE_PKGCONFIG=0
    PKGCONFIG_PACKAGES = {}

# set C++ compilation commands
# for CYGWIN, this isn't enough, it needs to generate
# an additional output stub link library .. this is handled
# directly in the script/maker at the moment
#
# down the track, we should replace these variables
# with a Python function def, since that's more flexible
if CYGWIN:
  CCOBJ_DLLIB = CXX + "-w -g -c "
  CCOBJ_DLMAIN = CXX + "-w -g -c "
  CCLINK_DLLIB = CXX + "-w -Wl,-shared -Wl,--export-all-symbols -Wl,--enable-auto-import "
  CCLINK_DLMAIN = CXX + "-w "
else:
  CCOBJ_DLLIB = CXX + "-w -g -fPIC -c "
  CCOBJ_DLMAIN = CXX + "-w -g -fPIC -c "
  CCLINK_DLLIB = CXX + "-w -Wl,-shared -Wl,--export-dynamic "
  CCLINK_DLMAIN = CXX + "-w -Wl,-Bdynamic -Wl,--export-dynamic "

CCOBJ_STATIC_LIB = CXX + "-w -g -c "
CCOBJ_STATIC_MAIN = CXX + "-w -g -c "

# NOTE: static here means linking felix libraries with drivers
# it does NOT mean not to do dynamic loading at load time
CCLINK_STATIC = CXX  + "-w "

#check if we can get dlopen to work without -ldl (BSD doesn't need)
try:
  xqt(CCOBJ_DLLIB+"tmp/dummy_lib.cxx -o tmp/dummy_lib.o")
  xqt(CCOBJ_DLMAIN+"tmp/dummy_main.cxx -o tmp/dummy_main.o")
  xqt(CCLINK_DLLIB+"tmp/dummy_lib.o -o tmp/dummy_lib.so")
  xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
  xqt("tmp/dlmain tmp/dummy_lib.so")
  SUPPORT_DYNAMIC_LOADING = 1
except:
  try: # nope, try with -ldl
    CCLINK_DLMAIN = CCLINK_DLMAIN + "-ldl "
    xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
    xqt("tmp/dlmain tmp/dummy_lib.so")
    SUPPORT_DYNAMIC_LOADING = 1
  except:
    try: #again with --shared
      CCLINK_DLLIB = CXX + "-w --shared "
      CCLINK_DLMAIN = CXX + "-w -Wl,-Bdynamic -ldl "
      xqt(CCLINK_DLLIB+"tmp/dummy_lib.o -o tmp/dummy_lib.so")
      xqt(CCLINK_DLMAIN+"tmp/dummy_main.o -o tmp/dlmain")
      xqt("tmp/dlmain tmp/dummy_lib.so")
      SUPPORT_DYNAMIC_LOADING = 1
    except:
      SUPPORT_DYNAMIC_LOADING = 0

# see if we have strip
try:
  xqt("strip tmp/dummy.o")
  STRIP="strip"
except:
  STRIP="#strip"

# see if we have ar
try:
  xqt("ar -rc tmp/dummy.a tmp/dummy.o")
  AR="ar -rc "
except:
  AR="#ar -rc "

# see if we have ranlib
try:
  xqt("ranlib tmp/dummy.a")
  RANLIB="ranlib "
except:
  RANLIB="#ranlib "

# see if we have interscript
try:
  xqt("iscr")
  ISCR="iscr "
except:
  ISCR='env PYTHONPATH=. python -O interscript/bin/iscr.py '

# find if we have BSD isnan in <cmath> (NAUGHTY!)
try:
  xqt("g++ -w -c tmp/dummy_nan.cxx -o tmp/dummy_nan.o")
  HAVE_ISNAN_IN_CMATH=1
except:
  HAVE_ISNAN_IN_CMATH=0

# find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
try:
  xqt("g++ -w -c tmp/dummy_nan2.cxx -o tmp/dummy_nan2.o")
  HAVE_ISNANF_IN_IEEEFP=1
except:
  HAVE_ISNANF_IN_IEEEFP=0

# find if we have stdint.h
try:
  xqt("g++ -w -c tmp/dummy_stdint.cxx -o tmp/dummy_stdint.o")
  HAVE_STDINT=1
except:
  HAVE_STDINT=0

# find sizes of ints
try:
  xqt("g++ -w tmp/intsizes.cxx -o tmp/intsizes")
  xxqt("tmp/intsizes > tmp/intsizes.py")
  execfile("tmp/intsizes.py")
except:
  print "FATAL: can't determine sizes of ints"
  sys.exit(1)
  
# find if we have long long
try:
  xqt("g++ -w tmp/longlong.cxx -o tmp/longlong")
  xxqt("tmp/longlong >tmp/longlong.py")
  execfile("tmp/longlong.py")
  HAVE_LONGLONG=1
except:
  HAVE_LONGLONG=0

# find if we have long double
try:
  xqt("g++ -w tmp/longdouble.cxx -o tmp/longdouble")
  xxqt("tmp/longdouble >tmp/longdouble.py")
  execfile("tmp/longdouble.py")
  HAVE_LONGDOUBLE=1
except:
  HAVE_LONGDOUBLE=0

# find if we have _Bool
try:
  xqt("gcc -w tmp/bool.c -o tmp/bool")
  xxqt("tmp/bool >tmp/bool.py")
  execfile("tmp/bool.py")
  HAVE_CBOOL=1
except:
  HAVE_CBOOL=0

# find if we have _Complex
try:
  xqt("gcc -w tmp/complex.c -o tmp/complex")
  xxqt("tmp/complex >tmp/complex.py")
  execfile("tmp/complex.py")
  HAVE_COMPLEX=1
except:
  HAVE_COMPLEX=0

DEBUG_SYMBOLS = "-g "
CCOPT1 = "-O1 -DNDEBUG "
CCOPT2 = "-O3 --inline -DNDEBUG "

if SUPPORT_DYNAMIC_LOADING:
  DEFAULT_LINK_MODEL="dynamic"
else:
  DEFAULT_LINK_MODEL="static"


def pr(f,x):
  print x
  f.write(x+"\n")

def p(f,s):
  x = s + "=" + repr(getattr(this,s))
  pr(f,x)

def pne(f,s):
  x = s + "=" + repr(getattr(this,s))
  f.write(x+"\n")

try:
  try: os.mkdir("config")
  except: pass
  f = open("config/config.py","w")
  p(f,"CONFIG_GENERATOR_CVS_ID")
  pr(f,"#Interscript support")
  p(f,"ISCR")
  pr(f,"")
  pr(f,"#Ocaml tools")
  p(f,"OCAMLC")
  p(f,"OCAMLB")
  p(f,"OCAMLLEX")
  p(f,"OCAMLYACC")
  p(f,"OCAMLDOC")
  p(f,"NATIVE_CODE_COMPILER")
  p(f,"OCAML_INCLUDE_DIRECTORY")
  pr(f,"")
  pr(f,"#C++ tools")
  p(f,"HAVE_CPP")
  p(f,"HAVE_CC")
  p(f,"HAVE_CCCC")
  p(f,"HAVE_MSVC")
  p(f,"HAVE_GXX")
  p(f,"HAVE_PKGCONFIG")
  p(f,"CXX")
  p(f,"CPP")
  p(f,"STRIP")
  p(f,"AR")
  p(f,"RANLIB")
  p(f,"CCOBJ_DLLIB")
  p(f,"CCOBJ_DLMAIN")
  p(f,"CCLINK_DLLIB")
  p(f,"CCLINK_DLMAIN")
  p(f,"CCOBJ_STATIC_LIB")
  p(f,"CCOBJ_STATIC_MAIN")
  p(f,"CCLINK_STATIC")
  p(f,"DEBUG_SYMBOLS")
  p(f,"CCOPT1")
  p(f,"CCOPT2")
  pr(f,"")

  pr(f,"# Data types")
  p(f,"HAVE_STDINT")
  p(f,"HAVE_LONGLONG")
  p(f,"HAVE_LONGDOUBLE")
  p(f,"HAVE_COMPLEX")
  p(f,"HAVE_CBOOL")

  p(f,"SIZEOF_SIZEOF")
  p(f,"SIZEOF_BOOL")
  p(f,"SIZEOF_CBOOL")
  p(f,"SIZEOF_SHORT")
  p(f,"SIZEOF_INT")
  p(f,"SIZEOF_LONG")
  p(f,"SIZEOF_LONGLONG")

  p(f,"SIZEOF_FLOAT")
  p(f,"SIZEOF_DOUBLE")
  p(f,"SIZEOF_LONGDOUBLE")

  p(f,"SIZEOF_COMPLEX")
  p(f,"SIZEOF_DOUBLECOMPLEX")
  p(f,"SIZEOF_LONGDOUBLECOMPLEX")

  p(f,"SIZEOF_IMAGINARY")
  p(f,"SIZEOF_DOUBLEIMAGINARY")
  p(f,"SIZEOF_LONGDOUBLEIMAGINARY")

  p(f,"SIZEOF_VOIDP")
  p(f,"SIZEOF_WCHAR")
  p(f,"SIZEOF_ENUM")
  p(f,"SIZEOF_FUNCP")

  p(f,"ALIGNOF_BOOL")
  p(f,"ALIGNOF_CBOOL")
  p(f,"ALIGNOF_SHORT")
  p(f,"ALIGNOF_INT")
  p(f,"ALIGNOF_LONG")
  p(f,"ALIGNOF_LONGLONG")

  p(f,"ALIGNOF_FLOAT")
  p(f,"ALIGNOF_DOUBLE")
  p(f,"ALIGNOF_LONGDOUBLE")

  p(f,"ALIGNOF_COMPLEX")
  p(f,"ALIGNOF_DOUBLECOMPLEX")
  p(f,"ALIGNOF_LONGDOUBLECOMPLEX")

  p(f,"ALIGNOF_IMAGINARY")
  p(f,"ALIGNOF_DOUBLEIMAGINARY")
  p(f,"ALIGNOF_LONGDOUBLEIMAGINARY")

  p(f,"ALIGNOF_VOIDP")
  p(f,"ALIGNOF_WCHAR")
  p(f,"ALIGNOF_ENUM")
  p(f,"ALIGNOF_FUNCP")



  p(f,"HAVE_ISNAN_IN_CMATH")
  p(f,"HAVE_ISNANF_IN_IEEEFP")

  p(f,"CHAR_IS_UNSIGNED")
  p(f,"LITTLE_ENDIAN")
  p(f,"BIG_ENDIAN")
  p(f,"HAVE_PKGCONFIG")
  pne(f,"PKGCONFIG_PACKAGES")

  pr(f,"")
  pr(f,"#User configurable section")
  p(f,"SUPPORT_DYNAMIC_LOADING")
  pr(f,"SUPPORT_STATIC_LINKAGE = 1")
  p(f,"DEFAULT_LINK_MODEL")
  p(f,"CYGWIN")
  pr(f,'PREFIX = "/usr/local"')
  f.close()
except:
  print "Unable to create config/config.py"
  sys.exit(1)

print "Created config/config.py"
print "Edit this file to set your preferences"
print "This file will not be clobbered by the Felix build process"

