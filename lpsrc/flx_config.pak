@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '1'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'

@select(tangler('tmp/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here

@select(tangler('tmp/xlators.py','python'))
import os
execfile('speed'+os.sep+'xlators_default.py')
execfile('config'+os.sep+'xlators_local.py')

# this table defines the actual translators
# which the performance tester will use
#
# comment out the lines you don't want,
# or add new ones if desired
#
# the translators selected by default should be available
# since they're required to build Felix .. but actually
# we preselect gcc for C compiler and ocamlopt for ocaml ..
# 
# this should really depend on the config for those things
#

# this is set up for PERSONAL USE
# this config is NOT suitable for submission to website
# you must use VERSIONED translators for submissions
#
xlators = [

# generic translators
  ('felix',mk_felix,'felix'),
  ('gcc',mk_gcc,'c'),
  ('gccopt',mk_gccopt,'c'),
  ('ocamlopt',mk_ocamlopt,'ocaml'),
#  ('gnat',mk_gnat,"ada"),
#  ('ghc',mk_ghc,'haskell'),

# GNU C and C++ compilers
#  ('gcc-3.3',mk_gcc_3_3,'c'),
#  ('gcc-3.3-O3',mk_gcc_3_3_opt,'c'),
#  ('gcc-4.0',mk_gcc_4_0,'c'),
#  ('gcc-4.0-O3',mk_gcc_4_0_opt,'c'),
#  ('g++-3.3',mk_gpp_3_3,'c'),
#  ('g++-3.3-O3',mk_gpp_3_3_opt,'c'),
#  ('g++-4_0',mk_gpp_4_0,'c'),
#  ('g++-4.0-O3',mk_gpp_4_0_opt,'c'),

# GNU Java
#  ('gcj-4_0',mk_gcj_4_0_opt,'java'),

# GNU Ada
#  ('gnat-4.0',mk_gnat,"ada"),

# Free Pascal
#  ('fpc-2.0.0',mk_fpc_2_0_0,"pascal"),

# GNU Pascal
#  ('gpc-2.1-3.3',mk_gpc_2_1_3_3,"pascal"),

# Glasgow Haskell
#  ('ghc-6.2.2',mk_ghc_6_2_2,'haskell'),
#  ('ghc-6.4.1',mk_ghc_6_4_1,'haskell'),

# Inria's Ocaml
#  ('ocamlopt-3.08_3',mk_ocamlopt_3_08_3,'ocaml'),
#  ('ocamlc-3.08.3',mk_ocamlc_3_08_3,'ocaml'),
]

@h = tangler("tmp/check_cygwin.cxx",'c++')
@select(h)
int main(int,char*[]) { 
   int x = __CYGWIN__;
   return 0;
}

@h = tangler("tmp/check_osx.cxx",'c++')
@select(h)
// RF: I think this implies the presence of OS X
int main(int,char*[]) { 
   int x = __APPLE__;
   return 0;
}


@h = tangler("tmp/dummy.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummyc.c",'c')
@select(h)
int main(int argc, char*argv[]) { return 0; }

@h = tangler("tmp/dummy_lib.cxx",'c++')
@select(h)
extern "C" int fred(int,char*[]) { return 0; }

@h = tangler("tmp/dummy_main.cxx",'c++')
@select(h)
#include <dlfcn.h>
#include <stdlib.h>

int main(int,char*argv[]) { 
   void *lib = dlopen(argv[1],RTLD_NOW);
   if(!lib) exit(1);
   void *fred = dlsym(lib,"fred");
   if(!fred) exit(1);
   return 0;
}

@h = tangler("tmp/gxx_x86.cxx",'c++')
@select(h)
#include <cstdio>
register void *sp __asm__ ("esp");

int main(int,char*[]) { 
   std::printf("Sp = %p\n",sp);
   return 0;
}

@h = tangler("tmp/gxx_hash.cxx",'c++')
@select(h)
#include <iostream>

// we only bother to check the include file exists
#include <ext/hash_map>
using namespace __gnu_cxx;

int main(int,char*[]) { 
   return 0;
}

@h = tangler("tmp/dummy_nan.cxx",'c++')
@select(h)
#include <cmath>

int main(int,char*[]) { 
  float f = 0.0;
  std::isnan(f);
  return 0;
}

@h = tangler("tmp/dummy_nan2.cxx",'c++')
@select(h)
#include <ieeefp.h>

int main(int,char*[]) { 
  float f = 0.0;
  isnanf(f);
  return 0;
}

@h = tangler("tmp/dummy_stdint.cxx",'c++')
@select(h)
#include <stdint.h>

int main(int,char*[]) { 
  {int8_t i;}
  {int16_t i;}
  {int32_t i;}
  {int64_t i;}
  {uint8_t i;}
  {uint16_t i;}
  {uint32_t i;}
  {uint64_t i;}
  return 0;
}

@h = tangler("tmp/intsizes.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

enum enum_t {e_tag};
typedef void (*fp_t)(void);

struct BOOL {
  char x;
  bool y;
};

struct SHORT {
  char x;
  short y;
};

struct INT {
  char x;
  int y;
};

struct LONG {
  char x;
  long y;
};

struct FLOAT {
  char x;
  float y;
};

struct DOUBLE {
  char x;
  double y;
};

struct VOIDP {
  char x;
  void *y;
};

struct WCHAR {
  char x;
  wchar_t y;
};

struct ENUM {
  char x;
  enum_t y;
};

struct FUNCP {
  char x;
  fp_t y;
};

union endian_t {
  unsigned long x;
  unsigned char y[sizeof(unsigned long)];
} endian;

int main(int,char*[]) { 
  printf("SIZEOF_BOOL=%d\n",sizeof(bool));
  printf("SIZEOF_CBOOL=%d\n",sizeof(int)); // fallback
  printf("SIZEOF_SHORT=%d\n",sizeof(short));
  printf("SIZEOF_INT=%d\n",sizeof(int));
  printf("SIZEOF_LONG=%d\n",sizeof(long));
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long)); // fallback
  printf("SIZEOF_FLOAT=%d\n",sizeof(float));
  printf("SIZEOF_DOUBLE=%d\n",sizeof(double));
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_WCHAR=%d\n",sizeof(wchar_t));
  printf("SIZEOF_ENUM=%d\n",sizeof(enum_t));
  printf("SIZEOF_SIZEOF=%d\n",sizeof(sizeof(int)));

  printf("SIZEOF_COMPLEX=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_IMAGINARY=%d\n",sizeof(float)); // fallback
  printf("SIZEOF_DOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback
  printf("SIZEOF_LONGDOUBLEIMAGINARY=%d\n",sizeof(double)); // fallback

  printf("SIZEOF_VOIDP=%d\n",sizeof(void*));
  printf("SIZEOF_FUNCP=%d\n",sizeof(fp_t));

  printf("ALIGNOF_BOOL=%d\n",offsetof(BOOL,y));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(BOOL,y)); // fallback
  printf("ALIGNOF_SHORT=%d\n",offsetof(SHORT,y));
  printf("ALIGNOF_INT=%d\n",offsetof(INT,y));
  printf("ALIGNOF_LONG=%d\n",offsetof(LONG,y));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONG,y)); // fallback
  
  printf("ALIGNOF_FLOAT=%d\n",offsetof(FLOAT,y));
  printf("ALIGNOF_DOUBLE=%d\n",offsetof(DOUBLE,y));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(DOUBLE,y)); // fallback
  
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_IMAGINARY=%d\n",offsetof(FLOAT,y)); // fallback
  printf("ALIGNOF_DOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback
  printf("ALIGNOF_LONGDOUBLEIMAGINARY=%d\n",offsetof(DOUBLE,y)); // fallback

  printf("ALIGNOF_WCHAR=%d\n",offsetof(WCHAR,y));
  printf("ALIGNOF_ENUM=%d\n",offsetof(ENUM,y));
  printf("ALIGNOF_FUNCP=%d\n",offsetof(FUNCP,y));
  printf("ALIGNOF_VOIDP=%d\n",offsetof(VOIDP,y));

  printf("CHAR_IS_UNSIGNED=%d\n",((char)0xFF)>0?1:0);
  endian.x = 1ul;
  printf("LITTLE_ENDIAN=%d\n", endian.y[0]);
  printf("BIG_ENDIAN=%d\n", endian.y[sizeof(unsigned long)-1]);

  return 0;
}

@h = tangler("tmp/longlong.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGLONG {
  char x;
  long long y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGLONG=%d\n",sizeof(long long));
  printf("ALIGNOF_LONGLONG=%d\n",offsetof(LONGLONG,y));
  return 0;
}

@h = tangler("tmp/longdouble.cxx",'c++')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct LONGDOUBLE {
  char x;
  long double y;
};

int main(int,char*[]) { 
  printf("SIZEOF_LONGDOUBLE=%d\n",sizeof(long double));
  printf("ALIGNOF_LONGDOUBLE=%d\n",offsetof(LONGDOUBLE,y));
  return 0;
}

@h = tangler("tmp/complex.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct COMPLEX {
  char x;
  _Complex y;
};

struct DOUBLECOMPLEX {
  char x;
  double _Complex y;
};

struct LONGDOUBLECOMPLEX {
  char x;
  long double _Complex y;
};

int main(int,char*[]) { 
  printf("SIZEOF_COMPLEX=%d\n",sizeof(_Complex));
  printf("SIZEOF_DOUBLECOMPLEX=%d\n",sizeof(double _Complex));
  printf("SIZEOF_LONGDOUBLECOMPLEX=%d\n",sizeof(long double _Complex));
  printf("ALIGNOF_COMPLEX=%d\n",offsetof(COMPLEX,y));
  printf("ALIGNOF_DOUBLECOMPLEX=%d\n",offsetof(DOUBLECOMPLEX,y));
  printf("ALIGNOF_LONGDOUBLECOMPLEX=%d\n",offsetof(LONGDOUBLECOMPLEX,y));
  return 0;
}

@h = tangler("tmp/cbool.c",'c')
@select(h)
#include <stdio.h>
#include <stddef.h>

struct CBOOL {
  char x;
  _Bool y;
};

int main(int,char*[]) { 
  printf("SIZEOF_CBOOL=%d\n",sizeof(_Bool));
  printf("ALIGNOF_CBOOL=%d\n",offsetof(CBOOL,y));
  return 0;
}

@h = tangler("tmp/cgoto.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { 
  void *label = &&label2;
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}

@h = tangler("tmp/asm_labels.cxx",'c++')
@select(h)
int main(int argc, char*argv[]) { 
  void *label = &&label2;
  __asm__(".global fred");
  __asm__("fred:");
  __asm__(""::"g"(&&label1));
  goto *label;
  label1: 
    return 1;
  label2:
    return 0; 
}

@h = tangler("tmp/check_inclass.cxx",'c++')
@select(h)
struct X {
  static const int i = 1;
};

int main(int,char*[]) { 
  return 0;
}

@h = tangler("script/ocaml_class.py")
@select(h)
#---------------------------------------------------
# discover which ocaml compilers are available
class ocaml:
  def __init__(self):
    pass

  def autodetect(self, xqt, get_stdout):
    try: # check if the client bootstrapped the native code compiler
      xqt('ocamlopt.opt')
      self.OCAMLCC = 'ocamlopt.opt '
      self.OCAMLLEX = 'ocamllex.opt '
      self.OCAMLYACC = 'ocamlyacc '
      self.NATIVE_CODE_COMPILER = 1
    except:
      try: # check if the client has unbootstrapped native code compiler
        xqt('ocamlopt')
        self.OCAMLCC = 'ocamlopt '
        self.OCAMLLEX = 'ocamllex '
        self.OCAMLYACC = 'ocamlyacc '
        self.NATIVE_CODE_COMPILER = 1
      except:
        self.NATIVE_CODE_COMPILER = 0
        try: # check if the client has ocaml at all ..
          xqt('ocamlc')
          self.OCAMLCC = 'ocamlc '
          self.OCAMLLEX = 'ocamllex '
          self.OCAMLYACC = 'ocamlyacc '
          self.OCAMLDOC = 'ocamldoc '
        except:
          print "WARNING: CANT FIND OCAML TOOLS (ocamlc, ocamllex, ocamlyacc)"
          self.OCAMLCC = '#ocamlc '
          self.OCAMLLEX = '#ocamllex '
          self.OCAMLYACC = '#ocamlyacc '

    try: # check if there is a native code version of the bytecode compiler
      xqt('ocamlc.opt')
      self.OCAMLB = 'ocamlc.opt '
    except:
      try: # check if the client has ocaml at all
        xqt('ocamlc')
        self.OCAMLB = 'ocamlc '
      except:
        print "WARNING: CANT FIND OCAML TOOL 'ocamlc'"
        self.OCAMLB = '#ocamlc '

    try:
      xqt('ocamldoc.opt')
      self.OCAMLDOC = 'ocamldoc.opt '
    except:
      try:
        xqt('ocamldoc')
        self.OCAMLDOC = 'ocamldoc '
      except:
        print "WARNING: CANT FIND OCAML TOOL 'ocamldoc'"
        self.OCAMLDOC = '#ocamldoc '

    # set the default ocaml compiler
    if self.OCAMLCC[0] != '#':
      self.OCAMLC = self.OCAMLCC
    else:
      self.OCAMLC = self.OCAMLB

    self.OCAMLCP = "ocamlcp "
    # where the ocaml is installed
    result,x = get_stdout(self.OCAMLC + " -where")
    if result:
      print "Woops, Can't run",self.OCAMLC
      sys.exit(1)
    self.OCAML_INCLUDE_DIRECTORY= x[0][0:-1]

    result,x = get_stdout(self.OCAMLB + " -v")
    if result:
      print "Woops, Can't run",self.OCAMLB
      sys.exit(1)
    x=x[0][0:-1]
    self.OCAMLB_DESCRIPTION,y = string.split(x,",")
    y = string.strip(y)
    self.OCAML_VERSION=y

    result,x = get_stdout(self.OCAMLC + " -v")
    if result:
      print "Woops, Can't run",self.OCAMLC
      sys.exit(1)
    x=x[0][0:-1]
    self.OCAMLC_DESCRIPTION,y = string.split(x,",")
    y = string.strip(y)
    if self.OCAML_VERSION <> y:
      print "Inconsistent Ocaml tool versions"
      print "Ocaml: bytecode compiler",self.OCAML_VERSION
      print "Ocaml: compiler         ",y
      sys.exit(1)
    
    
  def report_config(self):
    print
    print "OCAML tool configuration"
    print "************************"
    print
    print "Ocaml Version",self.OCAML_VERSION
    if self.NATIVE_CODE_COMPILER:
      print "Using Native code Compiler"
    else:
      print "Using Bytecode Compiler"
    print "Lexer generator .............. ",self.OCAMLLEX
    print "Parser generator ............. ",self.OCAMLYACC
    print "Bytecode and Interface compiler",self.OCAMLB
    print "   ",self.OCAMLB_DESCRIPTION
    print "Compiler ..................... ",self.OCAMLC
    print "   ",self.OCAMLC_DESCRIPTION
    print "Profiling Compiler ........... ",self.OCAMLCP
    print "Document Generator ........... ",self.OCAMLDOC
    print "C include directory .......... ",self.OCAML_INCLUDE_DIRECTORY
    print
   
  def save_config(self,filename):
    f = open(filename,"w")
    f.write("OCAML_VERSION='"+self.OCAML_VERSION+"'\n")
    f.write("NATIVE_CODE_COMPILER="+str(self.NATIVE_CODE_COMPILER)+"\n")
    f.write("OCAMLLEX='"+self.OCAMLLEX+"'\n")
    f.write("OCAMLYACC='"+self.OCAMLYACC+"'\n")
    f.write("OCAMLB='"+self.OCAMLB+"'\n")
    f.write("OCAMLB_DESCRIPTION='"+self.OCAMLB_DESCRIPTION+"'\n")
    f.write("OCAMLC='"+self.OCAMLC+"'\n")
    f.write("OCAMLC_DESCRIPTION='"+self.OCAMLC_DESCRIPTION+"'\n")
    f.write("OCAMLCP='"+self.OCAMLCP+"'\n")
    f.write("OCAMLDOC='"+self.OCAMLDOC+"'\n")
    f.write("OCAML_INCLUDE_DIRECTORY='"+self.OCAML_INCLUDE_DIRECTORY+"'\n")
    f.close()
  
  def load_config(self,filename):
    f = open(filename)
    exec f in self.__dict__
    f.close()

@h = tangler("script/gxx_class.py")
@select (h)
import string
import os

class object: pass

class gxx:

  def __init__(self):
    self.options = object()

  # these options are model dependent and have to
  # be supplied by the client

  def set_options(self,
    CXX="g++",
    AR="ar -rc",
    RANLIB="ranlib",
    STRIP="strip",
    model="detect",
    dll_extension=".so",
    exe_extension="",
    obj_extension=".o",
    lib_extension=".a",
    dll_binding_extension=None, # .dll.a for Cygwin -nocygwin
    dll_prefix="lib", #lib for unix, cyg for Cygwin -nocygwin
    dll_binding_prefix=None, #lib for Cygwin -nocygwin
    flags= ""
    ):
    opt = self.options
    opt.obj_extension = obj_extension
    opt.dll_extension = dll_extension
    opt.exe_extension = exe_extension
    opt.dll_binding_extension=dll_binding_extension
    opt.CXX = CXX+" "
    opt.AR = AR +" "
    opt.RANLIB = RANLIB +" "
    opt.STRIP = STRIP +" "
    opt.flags = flags
    opt.model = model

  def check_options(self,xqt):
    opt = self.options
    CXX = opt.CXX

    # check we have g++
    xqt(CXX+"-w -c tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")

    # see if we have strip: it isn't considered essential
    if opt.STRIP:
      xqt(opt.STRIP + "tmp"+os.sep+"dummy.o")
    else:
      opt.STRIP="#strip "

    # see if we have ar
    xqt(opt.AR+"tmp"+os.sep+"dummy.a tmp"+os.sep+"dummy.o")

    # see if we have ranlib, it isn't considered essential
    # (a totally brain dead Unix idea: AR should do this)
    try:
      xqt(opt.RANLIB + "tmp"+os.sep+"dummy.a")
    except:
      opt.RANLIB="#ranlib "

    # find if we have g++ on 32 bit x86 platform with named registers
    try:
      xqt(CXX +"-w tmp"+os.sep+"gxx_x86.cxx -o tmp"+os.sep+"x86_check")
      xqt("tmp"+os.sep+"x86_check")
      opt.HAVE_GXX_X86 = 1
      print "g++ x86 support detected"
    except:
      opt.HAVE_GXX_X86 = 0

    if opt.HAVE_GXX_X86:
      opt.USE_REGPARM3=1
      print "regparm3 supported"
    else:
      opt.USE_REGPARM3=0

    # find if we have g++ supporting computed jumps
    try:
      xqt(CXX+" tmp"+os.sep+"cgoto.cxx -o tmp"+os.sep+"cgoto")
      xqt("tmp"+os.sep+"cgoto")
      opt.HAVE_CGOTO = 1
      print "Computed goto supported"
    except:
      opt.HAVE_CGOTO = 0

    # find if we have g++ supporting computed jumps and asm labels
    try:
      xqt(CXX+"tmp"+os.sep+"asm_labels.cxx -o tmp"+os.sep+"asm_labels")
      xqt("tmp"+os.sep+"asm_labels")
      opt.HAVE_ASM_LABELS = 1
      print "Asm labels supported"
    except:
      opt.HAVE_ASM_LABELS = 0

    # find if we have g++ supported ext/ with STL extensions
    try:
      xqt(CXX+"tmp"+os.sep+"gxx_hash.cxx -o tmp"+os.sep+"gxx_hash")
      xqt("tmp"+os.sep+"gxx_hash")
      opt.HAVE_STL_GNU_CXX = 1
      print "Gnu ext/ templates supported"
    except:
      opt.HAVE_STL_GNU_CXX = 0

    # find if we have g++ with -Wno-invalid-offsetof
    try:
      xqt(CXX+"-Wno-invalid-offsetof tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      opt.NO_INVALID_OFFSETOF_WARNING="-Wall -Wno-invalid-offsetof "
      print "-Wno-invalid-offsetof supported"
    except:
      opt.NO_INVALID_OFFSETOF_WARNING = "-w "

    # find if we can use -fPIC without a warning
    # if a warning is generated it will say something like 
    # 'all code is relocatable on this platform' 
    # so we make that into an error, detect it, and say -fPIC only
    # if it would not generate this warning
    try:
      xqt(CXX+"-Werror -fPIC tmp"+os.sep+"dummy.cxx -o tmp"+os.sep+"dummy.o")
      opt.PIC = "-fPIC "
      print "-fPIC supported"
    except:
      opt.PIC = ""
      print "All code is position independent"

    # find if we have CYGWIN
    try:
      xqt(CXX+"-w -c tmp"+os.sep+"check_cygwin.cxx -o tmp"+os.sep+"dummy.o")
      opt.CYGWIN=1
      print "Cygwin detected"
      if opt.model in ["posix","cygwin","nocygwin","detect"]:
        if opt.model == "detect": opt.model = "cygwin"
        if opt.model == "posix": opt.model = "cygwin"
      else:
        print "INVALID MODEL",opt.model,"SPECIFIED"
        sys.exit(1)
    except:
      opt.CYGWIN=0

    #find if we have OS X
    try:
      xqt(CXX+"-w -c tmp"+os.sep+"check_osx.cxx -o tmp"+os.sep+"dummy.o")
      opt.MACOSX=1
      print "MACOSX detected"
      if model in ["posix","osx","detect"]:
        opt.model = "osx"
      else:
        print "INVALID MODEL",opt.model,"SPECIFIED"
        sys.exit(1)
    except:
      opt.MACOSX=0
    
    print "MODEL =",opt.model

    if opt.CYGWIN:
      opt.EXT_EXE= ".exe"
      opt.EXT_SHARED = ".dll"
      
      opt.COMPILE_DYNAMIC_RTL = opt.PIC+ "-c "
      opt.LINK_DYNAMIC_RTL = "-shared "
      
      opt.COMPILE_DYNAMIC_MAIN = "-c "
      opt.LINK_DYNAMIC_MAIN = ""
      
      opt.COMPILE_DYNAMIC_FLX = opt.PIC+ "-c "
      opt.LINK_DYNAMIC_FLX = opt.PIC+"-shared "

      #hysterical note:
      #opt.CCLINK_DLLIB = CXX + "-shared -Wl,--enable-auto-import "

    elif opt.MACOSX:
      opt.EXT_EXE= ""
      opt.EXT_SHARED = ".so"
      
      opt.COMPILE_DYNAMIC_RTL = opt.PIC + "-dynamic -c "
      opt.LINK_DYNAMIC_RTL = "-bundle "
      
      opt.COMPILE_DYNAMIC_MAIN = "-c "
      opt.LINK_DYNAMIC_MAIN = ""
      
      opt.COMPILE_DYNAMIC_FLX = opt.PIC + "-dynamic -c "
      opt.LINK_DYNAMIC_FLX = "-bundle "

    else:
      opt.EXT_EXE= ""
      opt.EXT_SHARED = ".so"
      
      opt.COMPILE_DYNAMIC_RTL = opt.PIC+ "-c "
      opt.LINK_DYNAMIC_RTL = "-shared "
      
      opt.COMPILE_DYNAMIC_MAIN = "-c "
      #hysterical note: this crap should not be needed
      #opt.LINK_DYNAMIC_MAIN = "-Wl,-Bdynamic -Wl,--export-dynamic "
      opt.LINK_DYNAMIC_MAIN = ""

      opt.COMPILE_DYNAMIC_FLX = opt.PIC+"-c "
      opt.LINK_DYNAMIC_FLX = "-shared "

    opt.CCOBJ_DYNAMIC_FLX = CXX + opt.COMPILE_DYNAMIC_FLX
    opt.CCLINK_DYNAMIC_FLX = CXX + opt.LINK_DYNAMIC_FLX

    opt.CCOBJ_DYNAMIC_RTL = CXX + opt.COMPILE_DYNAMIC_RTL
    opt.CCLINK_DYNAMIC_RTL = CXX + opt.LINK_DYNAMIC_RTL

    opt.CCOBJ_DYNAMIC_MAIN = CXX + opt.COMPILE_DYNAMIC_MAIN
    opt.CCLINK_DYNAMIC_MAIN = CXX + opt.LINK_DYNAMIC_MAIN

    opt.CCOBJ_STATIC_FLX = opt.CXX + "-c "
    opt.CCOBJ_STATIC_RTL = opt.CXX + "-c "
    opt.CCOBJ_STATIC_MAIN = opt.CXX + "-c "

    opt.CCOBJ_DYNAMIC_RTL=opt.CCOBJ_DYNAMIC_RTL+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_DYNAMIC_FLX=opt.CCOBJ_DYNAMIC_FLX+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_RTL=opt.CCOBJ_STATIC_RTL+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCOBJ_STATIC_FLX=opt.CCOBJ_STATIC_FLX+opt.NO_INVALID_OFFSETOF_WARNING
    opt.CCLINK_STATIC = opt.CXX


    print "Command to compile static Felix rtl     : " + opt.CCOBJ_STATIC_RTL
    print "Command to compile shared Felix rtl     : " + opt.CCOBJ_DYNAMIC_RTL
    print "Command to link shared Felix rtl        : " + opt.CCLINK_DYNAMIC_RTL

    print "Command to compile static Felix driver  : " + opt.CCOBJ_STATIC_MAIN
    print "Command to compile dynamic Felix driver : " + opt.CCOBJ_DYNAMIC_MAIN
    print "Command to link dynamic Felix driver    : " + opt.CCLINK_DYNAMIC_MAIN

    print "Command to compile static Felix object  : " + opt.CCOBJ_STATIC_FLX
    print "Command to compile loadable Felix object: " + opt.CCOBJ_DYNAMIC_FLX
    print "Command to link loadable Felix object   : " + opt.CCLINK_DYNAMIC_FLX

    print "Extension for loadable Felix object     : " + opt.EXT_SHARED
    print "Extension for executable                : " + opt.EXT_EXE

    # where to put the rtl: Cygwin requires the dll be in the PATH
    if opt.CYGWIN:
      opt.SHLIB_DIR="bin"
      print "rtl located in bin directory"
    else:
      print "rtl located in rtl directory"
      opt.SHLIB_DIR="rtl"



    #check if we can get dlopen to work without -ldl (BSD, Cygwin don't need)
    opt.HAVE_DLOPEN = 0
    opt.DLLIB=""
    try:
      xqt(opt.CCOBJ_DYNAMIC_FLX+"tmp"+os.sep+"dummy_lib.cxx -o tmp"+os.sep+"dummy_lib.o")
      xqt(opt.CCOBJ_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.cxx -o tmp"+os.sep+"dummy_main.o")
      xqt(opt.CCLINK_DYNAMIC_FLX+"tmp"+os.sep+"dummy_lib.o -o tmp"+os.sep+"dummy_lib"+opt.EXT_SHARED)
      xqt(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.o -o tmp"+os.sep+"dlmain")
      xqt("tmp"+os.sep+"dlmain tmp"+os.sep+"dummy_lib"+opt.EXT_SHARED)
      opt.SUPPORT_DYNAMIC_LOADING = 1
      opt.HAVE_DLOPEN = 1
      print "Dynamic Loading Supported (without -ldl)"
    except:
      try: # nope, try with -ldl
        opt.DLLIB="dl"
        xqt(opt.CCLINK_DYNAMIC_MAIN+"tmp"+os.sep+"dummy_main.o -o tmp"+os.sep+"dlmain -ldl")
        xqt("tmp"+os.sep+"dlmain tmp"+os.sep+"dummy_lib"+opt.EXT_SHARED)
        opt.HAVE_DLOPEN = 1
        opt.SUPPORT_DYNAMIC_LOADING = 1
        print "Dynamic Loading Supported (with -ldl)"
      except:
        opt.SUPPORT_DYNAMIC_LOADING = 0    # or give up on dynamic loading
        print "Dynamic Loading NOT SUPPORTED"
        sys.exit(1)

    # find if we have static const init in class
    try:
      xqt(opt.CXX+" -w -c tmp"+os.sep+"check_inclass.cxx -o tmp"+os.sep+"dummy.o")
      opt.HAVE_INCLASS_MEMBER_INITIALIZATION=1
      print "Inclass member initialisation supported"
    except:
      opt.HAVE_INCLASS_MEMBER_INITIALIZATION=0
      print "Inclass member initialisation NOT supported"

    # find if we have BSD isnan in <cmath> (NAUGHTY!)
    try:
      xqt(opt.CXX+" -w -c tmp"+os.sep+"dummy_nan.cxx -o tmp"+os.sep+"dummy_nan.o")
      opt.HAVE_ISNAN_IN_CMATH=1
      print "Isnan found in <cmath>"
    except:
      opt.HAVE_ISNAN_IN_CMATH=0

    # find if we have BSD isnanf in <ieeefp.h> (NAUGHTY!)
    try:
      xqt(opt.CXX+" -w -c tmp"+os.sep+"dummy_nan2.cxx -o tmp"+os.sep+"dummy_nan2.o")
      opt.HAVE_ISNAN_IN_IEEEFP=1
      print "Isnan found in <ieeefp.h>"
    except:
      opt.HAVE_ISNAN_IN_IEEEFP=0

    if opt.HAVE_ISNAN_IN_CMATH or opt.HAVE_ISNAN_IN_IEEEFP:
      print "Isnan supported"
    else:
      print "Isnan NOT supported"

    # find if we have stdint.h
    try:
      xqt(opt.CXX+" -w -c tmp"+os.sep+"dummy_stdint.cxx -o tmp"+os.sep+"dummy_stdint.o")
      opt.HAVE_STDINT=1
      print "Have stdint.h support"
    except:
      opt.HAVE_STDINT=0
      print "stdint.h NOT supported"

    # find sizes of ints
    try:
      xqt(opt.CXX+" -w tmp"+os.sep+"intsizes.cxx -o tmp"+os.sep+"intsizes")
      xxqt("tmp"+os.sep+"intsizes > tmp"+os.sep+"intsizes.py")
      f = open("tmp"+os.sep+"intsizes.py")
      exec f in opt.__dict__
      f.close()
    except:
      print "FATAL: can't determine sizes of ints"
      sys.exit(1)
      
    # find if we have long long
    try:
      xqt(opt.CXX+" -w tmp"+os.sep+"longlong.cxx -o tmp"+os.sep+"longlong")
      xxqt("tmp"+os.sep+"longlong >tmp"+os.sep+"longlong.py")
      f = open("tmp"+os.sep+"longlong.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_LONGLONG=1
    except:
      opt.HAVE_LONGLONG=0

    # find if we have long double
    try:
      xqt(opt.CXX+" -w tmp"+os.sep+"longdouble.cxx -o tmp"+os.sep+"longdouble")
      xxqt("tmp"+os.sep+"longdouble >tmp"+os.sep+"longdouble.py")
      f = open("tmp"+os.sep+"longdouble.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_LONGDOUBLE=1
    except:
      opt.HAVE_LONGDOUBLE=0

    # find if we have _Bool
    try:
      xqt(opt.CC+" -w tmp"+os.sep+"bool.c -o tmp"+os.sep+"bool")
      xxqt("tmp"+os.sep+"bool >tmp"+os.sep+"bool.py")
      f = open("tmp"+os.sep+"bool.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_CBOOL=1
    except:
      opt.HAVE_CBOOL=0

    # find if we have _Complex
    try:
      xqt(opt.CC + " -w tmp"+os.sep+"complex.c -o tmp"+os.sep+"complex")
      xxqt("tmp"+os.sep+"complex >tmp"+os.sep+"complex.py")
      f = open("tmp"+os.sep+"complex.py")
      exec f in opt.__dict__
      f.close()
      opt.HAVE_COMPLEX=1
    except:
      opt.HAVE_COMPLEX=0

    #calculate alignment tables
    vbls = [
      ("ALIGNOF_BOOL","bool"),
      ("ALIGNOF_SHORT","short"),
      ("ALIGNOF_INT","int"),
      ("ALIGNOF_LONG","long"),
      ("ALIGNOF_LONGLONG","long long"),
      
      ("ALIGNOF_FLOAT","float"),
      ("ALIGNOF_DOUBLE","double"),
      ("ALIGNOF_LONGDOUBLE","long double"),

      ("ALIGNOF_WCHAR","wchar_t"),
      ("ALIGNOF_VOIDP","void*"),
      ]

    opt.MAX_ALIGN = 1
    opt.flx_aligns = {}
    for k,t in vbls:
      v = opt.__dict__[k]
      opt.flx_aligns[v]=t
      if v > opt.MAX_ALIGN: opt.MAX_ALIGN = v
    opt.flx_aligns[1]="char"

    opt.DEBUG_SYMBOLS = "-g "
    opt.OPTIMISE = "-O3 -fomit-frame-pointer --inline -DNDEBUG "

  def save_options(self, filename):
    f = open(filename,"w")
    ks = self.options.__dict__.keys()
    ks.sort()
    for k in ks:
      if k[0] != '_': # do not save __builtins__
        v = self.options.__dict__[k]
        f.write(k+'='+repr(v)+"\n")
    f.close()

  def load_options(self,filename):
    f = open(filename)
    exec f in self.options.__dict__
    f.close()

  # compile a file to an object suitable for inclusion in a shared 
  # library version of RTL
  def compile_shared_rtl(self,shell,indir,basename,outdir=None,include_path=[],macros=[],flags="",optimise=1,debug=0):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = opt.CCOBJ_DYNAMIC_RTL
    if flags: cmd = cmd + flags + " "

    # debug symbols
    if debug: cmd = cmd + "-g "

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE

    # include path
    for i in include_path: cmd = cmd +"-I"+i+" "

    # output file
    cmd = cmd + "-o "
    if outdir: cmd = cmd + outdir + os.sep
    cmd = cmd + basename + "_dynamic"+opt.obj_extension+" "

    # macros
    for i in macros: cmd=cmd + "-D"+i+" "
    #input file
    if  indir: cmd = cmd + indir + os.sep
    cmd = cmd + basename
    cmd = cmd + ".cpp"

    # compile it
    return shell(cmd)

  # compile a file to an object suitable for inclusion in a mainline
  # which links to shared libraries
  compile_shared_main = compile_shared_rtl
  compile_felix_dll = compile_shared_rtl

  # compile a file to an object suitable for inclusion in a static link 
  # version of the RTL 
  def compile_static_rtl(self,shell,indir,basename,outdir=None,include_path=[],macros=[],flags="",optimise=1,debug=0):
    opt = self.options
    # compile for a dll: position independent code etc
    cmd = opt.CCOBJ_STATIC_RTL
    if flags: cmd = cmd + flags + " "

    # debug symbols
    if debug: cmd = cmd + "-g "

    # optimisation
    if optimise: cmd = cmd + opt.OPTIMISE+ " "

    # include path
    for i in include_path: cmd = cmd +"-I"+i+" "

    # output file
    cmd = cmd + "-o "
    if outdir: cmd = cmd + outdir + os.sep
    cmd = cmd + basename + "_static"+opt.obj_extension+" "

    #macros
    for i in macros: cmd=cmd + "-D"+i+" "

    #input file
    if  indir: cmd = cmd + indir + os.sep
    cmd = cmd + basename
    cmd = cmd + ".cpp"

    # compile it
    return shell(cmd)

  compile_static_main = compile_static_rtl
  compile_felix_static = compile_static_rtl

  def link_static_archive(self,shell,objects,archive):
    opt = self.options
    cmd = opt.AR +" "+ archive + " " 
    for i in objects: cmd = cmd + i + ".o "
    result = shell(cmd)
    if result:
      if opt.RANLIB:
        result = shell(opt.RANLIB+" "+archive)
    return result
  
  def link_static_program(self,shell,objects,outfile,lib_path,libs):
    opt = self.options
    cmd = opt.CCLINK_STATIC
    for i in objects: cmd = cmd +i+opt.obj_extension+" "
    cmd = cmd + "-o " +outfile + " "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    shell(cmd)
    
  def convert_static_archive_to_shared_library(self,shell,archive,soname,dll):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_RTL + "-o " + dll + " "
    cmd = cmd + "-Wl,-soname="+soname+ " "
    cmd = cmd + "-Wl,--whole-archive " + archive + " " 
    cmd = cmd + "-Wl,--no-whole-archive "
    if opt.DLLIB:
      cmd = cmd + "-l"+opt.DLLIB+" "
    return shell(cmd)

  def link_shared_rtl(self,shell,objects,outfile,lib_path,libs):
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_RTL
    cmd = cmd + "-o " +outfile + " "
    for i in objects: cmd = cmd +i+opt.obj_extension+" "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    if opt.DLLIB:
      cmd = cmd + "-l"+opt.DLLIB+" "
    return shell(cmd)
  
  link_felix_dll = link_shared_rtl
  
  def link_dynamic_program(self,shell,objects,outfile,lib_path,libs):
    #cmd = self.CXX +" -fPIC -Wl,-Bdynamic -Wl,--export-dynamic "
    opt = self.options
    cmd = opt.CCLINK_DYNAMIC_MAIN
    cmd = cmd + "-o " +outfile + " "
    for i in objects: cmd = cmd +i+opt.obj_extension+" "
    for i in lib_path: cmd = cmd + "-L"+i+" "
    for i in libs: cmd = cmd + "-l"+i+" "
    if opt.DLLIB:
      cmd = cmd + "-l"+opt.DLLIB+" "
    shell(cmd)
  
@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/config.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import string
import time

#---------- utilities -------------------
# We're screwed if popen doesn't work ..
def get_stdout(x):
  f = os.popen(x,"r")
  output = f.readlines()
  result = f.close()
  if not result: result = 0
  return result,output


# we cannot do anything fancy here like redirect
# stdout/stderr because we don't know what OS we're on

def xxqt(x):
  result = os.system(x)
  if result != 0: 
    print "FAIL:",x
    raise Error
  else: print x

def xqt(x): 
 if os.name == "posix":
   xxqt(x + " >/dev/null 2>&1")
 elif os.name == "nt":
   xxqt(x + " >NUL")
 else:
   xxqt(x)

def filecopy(a,b):
  f = open(a)
  g = open(b,"w")
  g.write(f.read())
  g.close()
  f.close()

def filecopy2dir(a,d):
  base = string.split(a,os.sep)[-1]
  filecopy(a,d+os.sep+base)

#----------------------------------------
time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)

class Error: pass
this = sys.modules[__name__]

# make doc directories to stop 'cp' complaining
try: os.mkdir("doc")
except: pass

try: os.mkdir("impldoc")
except: pass

try: os.mkdir("tut")
except: pass

try: os.mkdir("man")
except: pass

try: os.mkdir("htmlman")
except: pass

try: os.mkdir("tut"+os.sep+"doc")
except: pass

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except: return 0

def has_prefix(prefix,v):
  n = len (prefix)
  return prefix == v[:n]
  
quiet = 0
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

DEBIAN = 0 == os.system("apt-get -v >/dev/null")
if DEBIAN:
  default_prefix='/usr'
  print "DEBIAN detected"

result,output = get_stdout("uname -m")
if not result:
  ARCH = output[0]
  print "CPU=",ARCH
else:
  print "Unknown CPU architecture"
  ARCH = None

result,output = get_stdout("uname -o")
if not result:
  OS = output[0]
  print "OS=",OS
else:
  print "Unknown OS"
  OS = None

PREFIX=os.getenv("PREFIX",default=default_prefix)
if PREFIX:
  print "Default Installation Root from environment: ",PREFIX

overrides = {}

host = None # guess

archmap = {
  "posix":"posix",
  "linux":"posix",
  "solaris":"posix",
  "cygwin":"cygwin",
  "nocygwin":"nocygwin",
  "mingw":"mingw",
  "nt":"win32",
  "win32":"win32",
  "osx":"osx",
  }

try:
  build_model = archmap[os.name]
except:
  print "Python returns unknown OS type, assuming 'posix'"
  build_model = "posix"

host_model = None
target_model = None


models = [
  "posix/posix",
  "cygwin/cygwin",
  "cygwin/nocygwin",
  "nocygwin/nocygwin",
  "migw/mingw",
  "win32/win32",
  ]

def check_model(m):
  try: 
    h,t = string.split(m,"/")
  except:
    h,t=m,m
  h = archmap[h]
  t = archmap[t]
  m = h + "/" + t
  if not m in models:
    print "Unknown model, please choose one of:"
    for m in models: print " * " + m
    sys.exit(1)
  return h,t

install_styles = [
  ("kernel","[/sbin] for kernel modules"),
  ("system","[/bin] for init scripts"),
  ("root","[/usr/bin] for system applications"),
  ("local","[/usr/local/bin, /opt] for user applications"),
  ("personal","[~]for personal use only"),
  ("none","For developers: do not install")
  ]

install_keys = []
for i,j in install_styles:
  install_keys.append(i)

def check_install_style(x):
  if x not in install_keys:
   print "Unknown install style",x
   print "Please use --install-style=<key>"
   print "  where key is chosen from"
   for k,d in install_styles:
     s = "  %-10s : %s" % (k,d)
     print s
   print
   sys.exit(1)


install_style = None

i = 1
while(i < len (sys.argv)):
  arg = sys.argv[i]
  if arg == "--quiet":
    quiet = 1
  elif arg == "--force":
    force = 1
  elif arg == "--refresh":
    refresh = 1
  elif arg == "--upgrade":
    upgrade = 1
  elif has_prefix("--prefix=", arg):
    maybe_prefix=arg[9:]
    if maybe_prefix !=  '': 
      PREFIX=maybe_prefix
      if install_style == None:
        install_style = "root"
    else:
      if install_style == None:
        install_style="none"

  elif has_prefix("--set-int-",arg):
    x=arg[10:]
    i = string.index(x,'=')
    v = x[:i]
    a = x[i+1:]
    overrides[v]=eval(a)
  elif has_prefix("--set-string-",arg):
    x=arg[13:]
    i = string.index(x,'=')
    v = x[:i]
    a = x[i+1:]
    overrides[v]=a
  elif has_prefix("--model=",arg):
    host_model,target_model = check_model(arg[8:])
  elif has_prefix("--install-style=",arg):
    install_style = check_install_style(arg[16:])
  else:
    print "UNKNOWN CONFIGURE OPTION",arg
    sys.exit(1)
  i = i + 1

if not host_model: host_model=build_model
if not target_model: target_model = host_model

print "HOST=",host_model
print "TARGET=",target_model

if PREFIX=='': PREFIX=default_prefix

if install_style == None:
  if PREFIX == "/usr":
    install_style = "system"
  elif PREFIX == "/usr/local":
    install_style = "local"
  else:
    if DEBIAN:
      install_style = "root"
    else:
      print
      print "Install prefix is set, but style not recognized"
      print
      print "Please use --install-style=<key>"
      print "  where key is chosen from"
      for k in install_styles:
        d = install_styles[k]
        s = "%-10s : %s" % (k,d)
        print s
      print
      print "Or, do not specify an install prefix"
      print
      sys.exit(1)

print "Installation Style",install_style

if not file_exists("config"+os.sep+"xlators_local.py"):
  filecopy2dir('tmp'+os.sep+'xlators_local.py','config')
  print "*** Created dummy local translator definitions for speed tests ***"
  print "   Edit config/xlators_local.py to suit your platform"
  print "   This file will never be clobbered, even on a reconfigure"
  print "   delete it to force reinstallation of the default"

if not file_exists("config"+os.sep+"xlators.py"):
  filecopy2dir("tmp"+os.sep+"xlators.py","config")
  print "*** Created new translator list for speed tests ***"
  print "   Edit config/xlators.py to suit your platform and testing needs"
  print "   This file will never be clobbered, even on a reconfigure"
  print "   delete it to force reinstallation of the default"

if file_exists("config"+os.sep+"config.py"):
  if force or upgrade:
    print "**** upgrading configuration"
  elif refresh:
    print "**** CLOBBERING old configuration"
  else:
    print "**** using old configuration!"
    if not quiet:
      print "*** config/config.py already exists"
      print "*** It is assumed to container client configuration data"
      print "*** and so will not be clobbered."
      print
      print "*** To upgrade the configuration use the --upgrade option"
      print
      print "*** To recreate the default configuration"
      print "*** delete config/config.py first"
    sys.exit(0)
else:
  if upgrade:
    print "**** Can't upgrade non-existent configuration"
    sys.exit(1)
  else:
    print "**** creating new configuration"

if force or refresh:
  a = file_exists("config"+os.sep+"speed_xlators.py")
  b = file_exists("config"+os.sep+"speed_xlators.py.old")
  if a and not b:
    filecopy("config"+os.sep+"speed_xlators.py","config"+os.sep+"speed_xlators.py.old")
    print "*** Created config/speed_xlators.py.old"

  filecopy('tmp'+os.sep+'speed_xlators.py.default','config'+os.sep+'speed_xlators.py')
  print "***Clobbered configuration for speed tests***"
  print "   Edit config/speed_xlators.py to suit your platform"



#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

## find if we have MSVC++
#try:
#  xqt("cl tmp"+os.sep+"dummy.cxx "+os.sep+"Fetmp"+os.sep+"dummy_ms.exe")
#  MSVC="cl "
#  HAVE_MSVC = 1
#except:
#  MSVC="#cl "
#  HAVE_MSVC = 0

# or rather don't, because it breaks stuff at the moment
MSVC="#cl "
HAVE_MSVC = 0

execfile("script/ocaml_class.py")
HOST_OCAML = ocaml()
HOST_OCAML.autodetect(xqt,get_stdout)
HOST_OCAML.report_config()
HOST_OCAML.save_config("config/ocaml_config.py")

execfile("script/gxx_class.py")
  
if host_model in ["posix","cygwin","nocygwin","mingw"]:
  HOST_CXX=gxx()
  HOST_CXX.set_options()
  HOST_CXX.check_options(xqt)
  HOST_CXX.save_options("config/host_cxx.py")
  CYGWIN = HOST_CXX.options.CYGWIN
  MACOSX = HOST_CXX.options.MACOSX
else:
  print "Sorry only gnu tool chain supported at the moment"
  exit(1)

if target_model in ["posix","cygwin","nocygwin","mingw"]:
  TARGET_CXX=gxx()
  TARGET_CXX.set_options()
  TARGET_CXX.check_options(xqt)
  TARGET_CXX.save_options("config/target_cxx.py")
else:
  print "Sorry only gnu tool chain supported at the moment"
  exit(1)

# set C++ compilation commands
# for CYGWIN, this isn't enough, it needs to generate
# an additional output stub link library .. this is handled
# directly in the script/maker at the moment
#
# down the track, we should replace these variables
# with a Python function def, since that's more flexible
#FORCE_DEBUG="-g "
FORCE_DEBUG=""

# see if we have interscript
try:
  xqt("iscr")
  ISCR="iscr "
except:
  ISCR="env PYTHONPATH=. python -O interscript"+os.sep+"bin"+os.sep+"iscr.py "

SUPPORT_DYNAMIC_LOADING = TARGET_CXX.options.SUPPORT_DYNAMIC_LOADING

if SUPPORT_DYNAMIC_LOADING:
  DEFAULT_LINK_MODEL="dynamic"
else:
  DEFAULT_LINK_MODEL="static"

PYTHON_VERSION=sys.version
PYTHON_OS_NAME=os.name
PYTHON_OS_CURDIR=os.curdir
PYTHON_OS_PARDIR=os.pardir
PYTHON_OS_SEP=os.sep
PYTHON_OS_PATHSEP=os.pathsep

print "ESTABLISHED DEFAULT CONFIGURATION"

# attempt to clobber the configuration with old values
if not refresh:
  try:
    execfile("config"+os.sep+"config.py")
  except: pass

# reclobber version details to this version
@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

# clobber with command line overrides now
g = globals()
for k in overrides.keys():
  g[k]=overrides[k]

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'flx_version_major',flx_version_major
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

# Not used in Cygwin
FLX_SONAME = 'libflx_dynamic.so.'+flx_version_major


def pr(f,x):
  print x
  f.write(x+"\n")

def p(f,s):
  x = s + "=" + repr(getattr(this,s))
  pr(f,x)

def pne(f,s):
  x = s + "=" + repr(getattr(this,s))
  f.write(x+"\n")

cf_reg = []

def copen(c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  cf_reg.append(f)
  f= open(f,"w")
  pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
  pr(f,'#'+CONFIG_TIME)
  return f

try:
  try: os.mkdir("config")
  except: pass

  f = copen("iscr")
  pr(f,"#Interscript support")
  p(f,"ISCR")
  f.close()

  f = copen("python")
  pr(f,"#Python config")
  p(f,"PYTHON_VERSION")
  p(f,"ISCR")
  f.close()

  f = copen("filename")
  p(f,"PYTHON_OS_NAME")
  p(f,"PYTHON_OS_CURDIR")
  p(f,"PYTHON_OS_PARDIR")
  p(f,"PYTHON_OS_SEP")
  p(f,"PYTHON_OS_PATHSEP")
  f.close()


  f = open("config"+os.sep+"config.py","w")
  pr(f,'#'+CONFIG_TIME)
  pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
  p(f,"CONFIG_GENERATOR_CVS_ID")
  p(f,"CONFIG_TIME")
  p(f,"flx_version")
  p(f,"flx_version_major")
  p(f,"godi_revision")
  p(f,"debian_revision")
  p(f,"FLX_SONAME")
  for fn in cf_reg:
    pr(f,"execfile("+repr(fn)+")")

  pr(f,"")
  pr(f,"#User configurable section")
  p(f,"SUPPORT_DYNAMIC_LOADING")
  pr(f,"SUPPORT_STATIC_LINKAGE = 1")
  p(f,"DEFAULT_LINK_MODEL")
  p(f,"CYGWIN")
  p(f,"MACOSX")
  p(f,"PREFIX")
  pr(f,"")
  pr(f,"# CROSS COMPILATION OPTIONS")
  pr(f,"")
  pr(f,"# choose development host: either posix or win32")
  pr(f,"# This determines the build for the Felix compiler and Elkhound executables")
  pr(f,"# Set this to posix for full CYGWIN system")
  pr(f,"# Set this to win32 for Mingw (cygwin1.dll free) build")
  pr(f,"HOST_PLATFORM='posix'")
  pr(f,"#HOST_PLATFORM='win32'")
  pr(f,"")
  pr(f,"# choose development target: either posix or win32")
  pr(f,"# This determines the build for the Felix run time library and C++ generated by Felix")
  pr(f,"TARGET_PLATFORM='posix'")
  pr(f,"#TARGET_PLATFORM='win32'")

  pr(f,"execfile('script"+os.sep+"gxx_class.py')")
  pr(f,"execfile('script"+os.sep+"ocaml_class.py')")
  pr(f,"HOST_OCAML=ocaml()")
  pr(f,"HOST_OCAML.load_config('config"+os.sep+"ocaml_config.py')")
  pr(f,"HOST_CXX=gxx()")
  pr(f,"HOST_CXX.load_options('config"+os.sep+"host_cxx.py')")
  pr(f,"TARGET_CXX=gxx()")
  pr(f,"TARGET_CXX.load_options('config"+os.sep+"target_cxx.py')")
  pr(f,"")
  pr(f,"")
  pr(f,"#hacks")
  pr(f,"HAVE_GXX=1")
  pr(f,"FLXCC_CPP='cpp '")
  pr(f,"HAVE_MSVC=0")
  pr(f,"execfile('config"+os.sep+"target_cxx.py')")
  pr(f,"execfile('config"+os.sep+"ocaml_config.py')")
  f.close()
except:
  print "Unable to create config"+os.sep+"config.py"
  sys.exit(1)

print "Created config"+os.sep+"config.py"
print "Edit this file to set your preferences"
print "This file will not be clobbered by the Felix build process"

@h = tangler('config/flx_data.py')
@select(h)
import os
execfile("config"+os.sep+"config.py")

flx_keywords = [
    ("all", "ALL"),
    ("and", "AND"),
    ("as", "AS"),
    ("assert", "ASSERT"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("class", "CLASS"),
    ("code", "CODE"),
    ("comment", "COMMENT_KEYWORD"),
    ("const", "CONST"),
    ("cstruct", "CSTRUCT"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("goto", "GOTO"),
    ("header", "HEADER"),
    #("ident", "IDENT"),
    ("if", "IF"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("match", "MATCH"),
    ("module", "MODULE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noexpand", "NOEXPAND"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("of", "OF"),
    ("open","OPEN"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
    ("public", "PUBLIC"),
    ("publish", "PUBLISH"),
    ("read", "READ"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("set","SET"),
    ("struct", "STRUCT"),
    ("the", "THE"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("typematch", "TYPEMATCH"),
    ("type", "TYPE"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("when", "WHEN"),
    ("whilst", "WHILST"),
    ("with", "WITH"),
    ("until", "UNTIL"),
    ("_", "UNDERSCORE"),
  ]

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
  ]

flx_2_char_syms = [
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),
    ("LSQANGLE","[<"),
    ("RSQANGLE",">]"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
  ]


rmap = {}

tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress" : "void volatile*",
  "caddress" : "void const*",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if TARGET_CXX.options.HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if TARGET_CXX.options.HAVE_LONGDOUBLE:
   tmap["ldouble"]="long double"
else:
   tmap["ldouble"]="double"

if TARGET_CXX.options.HAVE_LONGLONG:
   tmap["vlong"]="long long"
   tmap["uvlong"]="unsigned long long"
else:
   tmap["vlong"]="long"
   tmap["uvlong"]="unsigned long"

if TARGET_CXX.options.HAVE_STDINT:
   tmap["int8"]="int8_t"
   tmap["uint8"]="uint8_t"
   tmap["int16"]="int16_t"
   tmap["uint16"]="uint16_t"
   tmap["int32"]="int32_t"
   tmap["uint32"]="uint32_t"
   tmap["int64"]="int64_t"
   tmap["uint64"]="uint64_t"

   # requirements
   rmap["int8"]="c99_stdint_h"
   rmap["uint8"]="c99_stdint_h"
   rmap["int16"]="c99_stdint_h"
   rmap["uint16"]="c99_stdint_h"
   rmap["int32"]="c99_stdint_h"
   rmap["uint32"]="c99_stdint_h"
   rmap["int64"]="c99_stdint_h"
   rmap["uint64"]="c99_stdint_h"
else:
   tmap["int8"]="signed char"
   tmap["uint8"]="unsigned char"
   sizes = { 
     TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
     TARGET_CXX.options.SIZEOF_INT*8: "int",
     TARGET_CXX.options.SIZEOF_LONG*8 : "long",
   }
   if TARGET_CXX.options.HAVE_LONGLONG:
     sizes[TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
   for size in [16,32,64]:
     try:
       t = sizes[size]
       tmap["int"+str(size)]=t
       tmap["uint"+str(size)]="unsigned " + t
     except:
       tmap["int"+str(size)]="emul_int"+str(size)
       tmap["uint"+str(size)]="emul_uint"+str(size)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!

 
