@head(1,'Configure')
@FLX_CONFIG_CVS_ID='$Id$'
@print FLX_CONFIG_CVS_ID
@flx_version_major = '1'
@flx_version_minor = '1'
@flx_version_patch = '4'
@flx_version_release = '_rc2'
@flx_version = flx_version_major+'.'+flx_version_minor+'.'+flx_version_patch+flx_version_release
@godi_revision = '0'
@debian_revision = '1'
@rpm_revision = '1'


@head(2,'CVS log')
@select(tangler('config/xlators_local.py','python'))
# reconfigure translator definitions for your
# local system here
selected_xlators = [
  'ocamlopt',
  'gccopt',
  'gnat',
  'gjc',
  'felix'
]

@include_file('flx_config_builders.ipk')

@select(tangler("flxbuild/__init__.py"))
@doc()

@select(tangler('flxbuild/iscrutil.py'))
import sys
import os
import pickle

if '' not in sys.path: sys.path = [''] + sys.path
import flxbuild
from flxbuild.flxutil import *

import flxbuild.flxutil
import interscript.frames.inputf

class setup_test:
  def __init__(self, iframe, root,
      zfill_pattern=[1],
      zfill_default=2):
    self.iframe = iframe
    self.root = root
    self.zfill_pattern = zfill_pattern
    self.zfill_default = 2

    self.levels = []
    self.testcount = 0
    self.argcount = 0

    self.names_written = {}

    self.katfile = unix2native(self.root + 'categories')

    if os.path.exists(self.katfile):
      f = open(self.katfile)
      try:
        self.registry_in = pickle.load(f)
      finally:
        f.close()
    else:
      self.registry_in = {}

    self.registry_out = {}


  def head(self, level, title=None):
    if not self.levels and level > 1:
      self.levels = [1]

    self.testcount = 0
    self.argcount = 0

    while len(self.levels) < level:
      self.levels.append(0)

    self.levels[level - 1] = self.levels[level - 1] + 1
    self.levels = self.levels[:level]

    if title is None:
      title = self.root + self.level_str()

    return self.iframe.head(level, title)


  def level_str(self):
    levels = []
    for i in range(len(self.levels)):
      try:
        z = self.zfill_pattern[i]
      except IndexError:
        z = self.zfill_default

      levels.append(str(self.levels[i]).zfill(z))

    return '.'.join(levels)


  def filename(self):
    return self.root + self.level_str()


  def tangler(self, name,
      extension='',
      filetype=interscript.frames.inputf.deduce):

    path = name + extension
    if path in self.names_written:
      print 'file:', path, 'already created!'

      # XXX: NEED TO GENERATE A NEW FILE NAME
      # XXX: what's the proper way to error out an interscript file?
      sys.exit(1)

    h = self.iframe.tangler(path, filetype)
    self.names_written[path] = h

    return h


  def test(self, *args, **kwds):
    name = '%s-%s' % (self.filename(), self.testcount)


    # if categories are specified, write them out
    categories = []
    if 'categories' in kwds:
      categories = kwds['categories']
      del kwds['categories']

    # construct the tangler
    tangler = apply(self.tangler, (name,) + args, kwds)
    for cat in categories: self.kat(tangler,cat)

    self.testcount = self.testcount + 1
    return tangler

  def expect(self):
    name = '%s-%s' % (self.filename(), self.testcount - 1)

    return self.tangler(name, '.expect', 'data')


  def args(self, arguments):
    name = '%s-%s-%s' % (self.filename(), self.testcount - 1, self.argcount)
    self.argcount = self.argcount + 1

    a = self.tangler(name, '.args', 'data')

    select(a)
    tangle(arguments)
    doc()

    return a


  def test_args(self, arglist, *args, **kwds):
    t = apply(self.test, args, kwds)

    for arguments in arglist:
      self.args(arguments)

    return t


  def expect_args(self, arguments):
    self.args(arguments)

    name = '%s-%s-%s' % (self.filename(), self.testcount - 1, self.argcount - 1)

    return self.tangler(name, '.argexpect', 'data')


  def kat(self, tangler, code):
    tangler.writeline(
      "//Check " + code,
      self.iframe.original_filename,
      self.iframe.original_count
    )

    f = tangler.sink.filename
    ff = f.split('/')[-1][:-4]
    v = self.registry_out.get(code,[])
    if ff not in v:
      self.iframe.set_anchor(ff)
      v.append(ff)
      self.registry_out[code]=v


  def emit_katlist(self):
    self.iframe.begin_list("keyed")
    keys = self.registry_in.keys()
    keys.sort()
    for k in keys:
      v = self.registry_in[k]
      self.iframe.item(k)
      first = 1
      for i in v:
        if first: first = 0
        else: self.iframe.weave(", ")
        self.iframe.ref_anchor(i)
    self.iframe.end_list()


  def write_katfile(self):
    dirname = os.path.split(self.katfile)[0]
    if not os.path.exists(dirname):
      os.makedirs(dirname)

    f = open(self.katfile, 'w')
    try:
      pickle.dump(self.registry_out, f)
    finally:
      f.close()
@doc()

@h=tangler("flxbuild/flxutil.py")
@select(h)
# build system utility module
import os
import sys
import glob
import time
import StringIO
import shutil

def filetime(f):
  try:
    return os.path.getmtime(f)
  except EnvironmentError:
    return 0

# returns the time of the newest file of a set
# if a file is missing, the time is in the future
# (since we have no record of when it was deleted,
# we assume it was vey recently :)

def newest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: return time.time()+1000.0
    m = max(m,x)
  return m

# returns the time of the oldest file of a set
# if a file is missing, the time is before the
# birth of the universe .. well PC's anyhow :)

def oldest_filetime(fs):
  m = 0
  for f in fs:
    x = filetime(f)
    if x == 0: raise MakeError # missing files not allowed
    m = max(m,x)
  return m

def fmtime(t):
    s = "%04d %02d %02d %02d %02d %02d" % (time.localtime(t)[:6])
    return s

def append_unique(s,x):
  if x not in s: return s+[x]
  else: return s

def closure1(d,i,o):
  if i not in o:
    o = o + [i]
    e = d.get(i,[])
    for k in e:
      if k not in o:
        o = closure1(d,k,o)
  return o

# d is a dictionary T -> T list
# s is a list
# closure (d,s) returns the closure of s wrt d
#
# normally d is a dependency map for packages
# and s is set of root packages to be rebuilt
# result is the all the packages that need rebuild

def closure(d,s):
  o = []
  for i in s:
    o = closure1(d,i,o)
  return o

# given a map T -> T list
# return the inverse map

def invert(d):
  m = {}
  for k in d.keys():
    for v in d[k]:
      m[v] = append_unique(m.get(v,[]),k)
  return m

def erasefile(f):
  try: os.unlink(f)
  except EnvironmentError: pass

def unix2native(f):
  return os.path.join(*f.split('/'))

def deletefile(f):
  erasefile(unix2native(f))

def mkdirs(x):
  if x and not os.path.exists(x):
    os.makedirs(x)

def erasedir(d):
  fs = glob.glob(d+os.sep+"*")
  for f in fs: erasefile(f)
  try: os.rmdir(d)
  except EnvironmentError: pass

def execute(cmd, verbose=False, quiet=False, invert_result=False, log=None):
  if log is None: log = sys.stdout

  if verbose and not quiet: print >> log, '>', cmd
  log.flush()

  fout = os.popen(cmd, 'r')
  stdout = []
  try:
    for line in fout:
      stdout.append(line)

      if verbose and not quiet:
        log.write(line)
  finally:
    result = fout.close()

  log.flush()

  if invert_result:
    if result:
      result = 0
    else:
      result = 1

  if quiet < 2:
    if result and not verbose:
      print >> log, cmd, 'failed!'

    if result and not invert_result:
      print >> log, '  .. ERROR CODE', hex(result), ':', cmd

  log.flush()

  if result:
    raise ExecutionError(cmd, result)

  return stdout

def xqt(*commands, **kwds):
  return execute(' '.join(commands), **kwds)

def file_exists(f):
  try:
    os.stat(f)
    return 1
  except EnvironmentError: return 0

class Tee(object):
  def __init__(self, stdout=sys.stdout):
    self.stdout = stdout
    self.file = StringIO.StringIO()

  def write(self, s, quiet=0):
    if not quiet:
      self.stdout.write(s)
    self.file.write(s)

  def flush(self):
    self.stdout.flush()
    self.file.flush()

  def getvalue(self):
    return self.file.getvalue()

def tee_cmd(cmd, stdout, bufsize=1024):
  # we try to use subprocess because we can get the exit code on windows
  try:
    import subprocess
  except ImportError:
    p = os.popen(' '.join(cmd), 'r', bufsize)
    while 1:
      buf = os.read(p.fileno(), bufsize)
      if buf:
        stdout.write(buf)
      else:
        break
    return p.close()
  else:
    p = subprocess.Popen(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        bufsize=bufsize)
    while True:
      buf = os.read(p.stdout.fileno(), bufsize)
      if buf:
        stdout.write(buf)
      else:
        break

    return p.wait()


class MakeError(EnvironmentError):
  def __init__(self, command=None, stdout=[], stderr=[]):
    self.command = command
    self.stdout = ''.join(stdout)
    self.stderr = ''.join(stderr)

  def __str__(self):
    s = []
    if self.command is not None:
      s.append('COMMAND: ' + self.command)

    if self.stdout:
      s.append('STDOUT:\n' + self.stdout)

    if self.stderr:
      s.append('STDERR:\n' + self.stderr)

    return '\n'.join(s)

class ExecutionError(Exception):
  def __init__(self, command, returncode=None):
    self.command = command
    self.returncode = returncode

  def __str__(self):
    if self.returncode is None:
      return 'Command failed: %s' % self.command
    else:
      return 'Command failed [%s]: %s' % (self.returncode, self.command)

@select(tangler('flxbuild/path.py'))
import os
import fnmatch

def splitall(path):
  paths = []
  old_path = path

  while True:
    path, filename = os.path.split(path)

    if path == old_path:
      if path:
        paths.append(path)
      break
    else:
      old_path = path
      paths.append(filename)
  paths.reverse()
  return paths

def relativepath(root, path):
  roots = splitall(os.path.abspath(root))
  paths = splitall(os.path.abspath(path))

  for i, (r, p) in enumerate(zip(roots, paths)):
    j = i
    if r != p:
      break
  else:
    i += 1
    j = len(roots)

  new_paths = ['..'] * (len(roots) - i) + paths[j:]

  if not new_paths:
    return '.'
  else:
    return os.path.join(*new_paths)

def find(path, name=None, include_dirs=True):
  for root, dirs, files in os.walk(path):
    if include_dirs:
      files += dirs

    for f in files:
      if name is not None and not fnmatch.fnmatch(f, name):
        continue

      yield os.path.join(root, f)

@select(tangler("cpkgs/__init__.py"))
@select(tangler("cpkgs/build/__init__.py"))
@select(tangler("cpkgs/host/__init__.py"))
@select(tangler("cpkgs/target/__init__.py"))

@select(tangler("cpkgs/target/libgc.py"))
import config

#    'Boehm-Demers-Weiser Conservative Garbage Collector',
#    'http://www.hpl.hp.com/personal/Hans_Boehm/gc/'
HAVE_LIBGC = config.TARGET_CXX.check_header_exists("gc.h")

@select(tangler("cpkgs/target/windowsh.py"))
import config

#    "Microsoft Windows core CAPI",
#    "http://microsoft.com"
HAVE_WINDOWS_H = config.TARGET_CXX.check_header_exists("windows.h")

@select(tangler("cpkgs/target/opengl.py"))
import os

import config

#    'Open GL Graphics Rendering Toolkit',
#    "http://www.opengl.org"
if config.MACOSX:
  HAVE_OPENGL = config.TARGET_CXX.check_header_exists("OpenGL"+os.sep+"gl.h")
else:
  HAVE_OPENGL = config.TARGET_CXX.check_header_exists("GL"+os.sep+"gl.h")


@select(tangler("cpkgs/target/pthread.py"))
from flxbuild.flxutil import xqt, ExecutionError

# try to use Linux getconf to find the pthread version
# Ubuntu/Breezy returns "NPTL 2.3.5"
# IEEE Std 1003.1-2001 for getconf uses the variable: _POSIX_THREADS
# if the system does not support Pthreads, getconf returns 0
# if the system supports Pthreads, getconf returns nonzero
# on RedHat Linux, "getconf _POSIX_THREADS" returns 1
# on Darwin (Mac OS X), "getconf _POSIX_THREADS" returns 200112
try:
  output = xqt('getconf', '_POSIX_THREADS')
except ExecutionError, TypeError:
  # getconf failed
  PTHREAD_MODEL = 'Unknown'
else:
  if int(output[0].strip()) != 0:
    PTHREAD_MODEL = 'POSIX'
  else:
    PTHREAD_MODEL = 'Unknown'


print "Pthread model according to linuxy getconf=", PTHREAD_MODEL


@select(tangler("cpkgs/host/pkgconfig.py"))
from flxbuild.flxutil import ExecutionError
# see if we have pkg-config
try:
  from config.pkgconfig_config import *
except ImportError:
  from flxbuild.flxutil import xqt
  from flxbuild.config_support import cwrite, pr, pa

  try:
    xqt("pkg-config --version")
    HAVE_PKGCONFIG = 1
  except ExecutionError:
    HAVE_PKGCONFIG = 0

  print "Storing pkgconfig configuration"
  f = cwrite("pkgconfig")
  pr(f,"#pkgconfig support")
  pa(f,locals(),"HAVE_PKGCONFIG")
  f.close()


@select(tangler("flxbuild/config_support.py"))
import os
from flxbuild.flxutil import xqt, ExecutionError

def pr(f,x):
  print x
  f.write(x+"\n")

def pa(f,this,s):
  try:
    x = s + "=" + repr(this[s])
    pr(f,x)
  except (KeyError, EnvironmentError):
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")

def pne(f,s):
  try:
    x = s + "=" + repr(this[s])
    f.write(x+"\n")
  except EnvironmentError:
    print "UNABLE TO FIND VALUE FOR ATTRIBUTE '"+s+"'"
    f.write(s+"= None # EDIT ME!!\n")


def cwrite(c):
  f = "config"+os.sep+""+c+"_config.py"
  print "--------------------------"
  print "Creating "+f
  f= open(f,"w")
  return f

# needs to be conditionalised on Unix
def locate_file(fname):
  print "Try to find",fname
  n = len(fname)
  cmd = "locate " + fname
  try:
    lines = xqt(cmd)
  except ExecutionError:
    print "Cannot execute Unix locate command to find file",fname
    return None

  candidates = []
  for line in lines:
    candidate = line.strip()
    if candidate[-n:] == fname:
      candidates.append(candidate[0:-n])

  if len(candidates) == 0:
    print "Cannot find directory containing file",fname
    return None

  if len(candidates) == 1:
    print "Found unique directory ",candidates[0],"containing file",fname
    return candidates[0]
  else:
    print "Found multiple directories containing file",fname
    s = candidates[0]
    for k in candidates:
      print "Dir: ",k
      if len(k) < len(s): s = k
    print "Using shortest one:",s
    return s


@h = tangler("script/make_config.py")
@select(h)
# THIS PROGRAM CREATES THE DEFAULT CONFIGURATION FILE
# config/__init__.py
# WHICH YOU SHOULD EDIT TO SUIT YOUR REQUIREMENTS

import sys
import os
import os.path
import traceback
import time
import glob
import getopt
import signal # try to force ctrl-C to this process
import shutil

this = globals()

if '' not in sys.path: sys.path = [''] + sys.path
import flxbuild
from flxbuild.flxutil import *
from flxbuild.config_support import *


@tangle("CONFIG_GENERATOR_CVS_ID='"+FLX_CONFIG_CVS_ID+"'")
@tangle("flx_version = '"+flx_version+"'")
@tangle("flx_version_major = '"+flx_version_major+"'")
@tangle("godi_revision = '"+godi_revision+"'")
@tangle("debian_revision = '"+debian_revision+"'")

print CONFIG_GENERATOR_CVS_ID
print 'flx_version',flx_version
print 'flx_version_major',flx_version_major
print 'godi_revision',godi_revision
print 'debian_revision',debian_revision

time_stamp_format = "%Y/%m/%d %H:%M:%S UTC"
config_time=time.gmtime(time.time())
CONFIG_TIME = time.strftime(time_stamp_format, config_time)

#----------------------------------------

mkdirs("misc")
mkdirs("tmp")
mkdirs("config")
mkdirs("doc")

verbose = 1
quiet = 1
force = 0
upgrade = 0
refresh = 0
default_prefix='/usr/local'

PREFIX=os.environ.get("PREFIX",default_prefix)
if PREFIX:
  print "Default Installation Root from environment: ",PREFIX

overrides = {}

# supported platforms

platforms = [
  "posix",
  "cygwin",
  "nocygwin",
  "mingw",
  "win32",
  "win64",
  "osx",
  "detect"
  "solaris",
  "bsd",
  "linux"
  ]

# map other names for them, obtained from
# various place like os.platform, os.system("mname -u"), etc

archmap = {
  "irix":"posix",
  "irix64":"posix",
  "unix":"posix",
  "posix":"posix",
  "linux":"linux",
  "gnu/linux":"linux",
  "solaris":"solaris",
  "sunos":"solaris",
  "cygwin":"cygwin",
  "nocygwin":"nocygwin",
  "mingw":"mingw",
  "windows":"win32",
  "nt":"win32",
  "win32":"win32",
  "win64":"win64",
  "darwin":"osx",
  "freebsd":"bsd",
  "netbsd":"bsd",
  "openbsd":"bsd",
  "osx":"osx",
  "detect":"detect"
  }

# attempt to find the Felix name for the build OS
# using uname -s, or, if that fails, Python os.name
# if the final result isn't a name we recognize
# set the build_model to 'detect' to indicate C level
# testing is to be used. Note that these C tests are
# done anyhow, and may verify, refine, or otherwise
# munge this result .. however we need some initial
# indication HOW to perform these tests.

try:
  output = xqt('uname', '-s')
except ExecutionError:
  try:
    build_model = archmap[os.name]
  except KeyError:
    print "uname -s and Python returns unknown OS type, assuming 'detect'"
    build_model = "detect"
else:
  output = output[0].strip().lower()
  build_model = archmap[output]

print "Build platform: " + build_model

# RF: noone seems to be using the results of this
# JS: Not yet: policy is to test it out anyhow, in case needed
#
# uname -s: kernel name "linux" on linux
# uname -n: network node name "rosella" on JS box
# uname -r: kernel-release "2.6.12-10-amd64-k8" on JS box
# uname -v: kernel-version " #1 Thu Dec 22 11:12:06 UTC 2005" on JS box
# uname -m: machine hardware name: "x86_64" on JS box
# uname -o: operating system: "GNU/Linux" on JS box
# uname -p: OSX only? on osx reports broad cpu type (e.g. powerpc)
# not sure what it reports on intel macs.
# machine command reports very specific cpu type, e.g. ppc7450, ppc7400

try:
  output = xqt('uname', '-m')
except ExecutionError:
  ARCH = "unknown"
else:
  ARCH = output[0].strip().lower()

print "CPU=",ARCH

try:
  if build_model == 'osx':
    output = xqt('uname -p')
  else:
    output = xqt('uname -o')
except ExecutionError:
  OS = 'unknown'
else:
  OS = output[0].strip().lower()

print "OS=",OS


print "Detected Build model:",build_model

host_model = None
target_model = None
run_model = None

def check_model(m):
  try:
    m = archmap[m]
  except KeyError:
    print "Unknown model '"+m+"' please choose one of:"
    for m in platforms: print " * " + m
    sys.exit(1)
  return m

SAVE_CONFIG=""
LOAD_CONFIG=""
BOOTFILE=""

include_paths=[]
lib_paths=[]

BUILDCC=None
HOSTCC=None
TARGETCC=None

BUILDCXX=None
HOSTCXX=None
TARGETCXX=None

FLX_DIR=os.environ.get("FLX_DIR",os.curdir)
FLX_LPARCHIVE=os.environ.get("FLX_LPARCHIVE",os.curdir)
FLX_RTL_DIR=os.path.join('lib', 'rtl')
FLX_TARGET_CONFIG_DIR=os.path.join('config', 'target')
FLX_HOST_CONFIG_DIR=os.path.join('config', 'host')

ALL_PHASES=["build","host","target","run"]

PHASES = []

try:
  opts, args = getopt.getopt(sys.argv[1:], 'hvq',
      ['help', 'verbose', 'quiet', 'force', 'refresh', 'upgrade',
      'prefix=', 'set-int=', 'set-string=',
      'include_paths=', 'lib_paths=',
      'build=', 'host=', 'target=', 'run=',
      'buildcc=', 'hostcc=', 'targetcc=', 'targetcxx=',
      'boot=', 'save-config=',
      'load-config=', 'lparchive=', 'phase='])
      #'set-int',
except getopt.error, e:
  sys.stderr.write(str(e) + '\n')
  sys.exit(1)

for o, a in opts:
  if o in ['-h', '--help']:
    print """\
usage: configure [options]

flags:
  -h, --help      print this help message
  -v, --verbose   print out extra debugging info
  -q, --quiet     do not print out extra debugging info

  --force
  --refresh
  --upgrade
  --prefix        install in this prefixed directory
  --set-int
  --set-string
  --include_paths additionally search these paths for headers
  --lib_paths     additionally search these paths for libraries
  --build
  --host
  --target
  --run
  --buildcc
  --hostcc
  --targetcc
  --buildcxx
  --hostcxx
  --targetcxx
  --boot
  --save-config
  --load-config
  --lparchive
  --phase
"""
    sys.exit(0)
  elif o in ['-v', '--verbose']:
    verbose = verbose + 1
    quiet = 0
  elif o in ['-q', '--quiet']:
    verbose = 0
  elif o in ['--force']:
    force = 1
  elif o in ['--refresh']:
    refresh = 1
  elif o in ['--upgrade']:
    upgrade = 1
  elif o in ['--prefix']:
    PREFIX = a
  elif o in ['--set-int']:
    v, a = a.split('=', 1)
    overrides[v] = int(a)
  elif o in ['--set-string']:
    v, a = a.split('=', 1)
    overrides[v] = a
  elif o in ['--include_paths']:
    include_paths.append(a)
  elif o in ['--lib_paths']:
    lib_paths.append(a)
  elif o in ['--build']:
    print "Specified build model", a
    build_model = check_model(a)
  elif o in ['--host']:
    print "Specified host model:", a
    host_model = check_model(a)
  elif o in ['--target']:
    print "Specified target model:", a
    target_model = check_model(a)
  elif o in ['--run']:
    print "Specified run model", a
    run_model = check_model(a)
  elif o in ['--buildcc']:
    BUILDCC = a
  elif o in ['--hostcc']:
    HOSTCC = a
  elif o in ['--targetcc']:
    TARGETCC = a
  elif o in ['--buildcxx']:
    BUILDCXX = a
  elif o in ['--hostcxx']:
    HOSTCXX = a
  elif o in ['--targetcxx']:
    TARGETCXX = a
  elif o in ['--boot']:
    BOOTFILE = a
  elif o in ['--save-config']:
    SAVE_CONFIG = a
  elif o in ['--load-config']:
    LOAD_CONFIG = a
  elif o in ['--lparchive']:
    FLX_LPARCHIVE = a
  elif o in ['--phase']:
    if a not in ALL_PHASES:
      print "UNKNOWN PHASE",a,"not in",ALL_PHASES
      sys.exit(1)
    if a not in PHASES: PHASES.append(a)
  else:
    print "UNKNOWN CONFIGURE OPTION", o, a
    sys.exit(1)

if args:
  print "UNKNOWN CONFIGURE ARGS", args
  sys.exit(1)

if not verbose:
  quiet = 2

if PHASES == []: PHASES = ALL_PHASES

if BOOTFILE:
  try:
    execfile(BOOTFILE)
    print "Loaded",BOOTFILE
  except:
    print "Cannot execute specified bootstrap file: ", BOOTFILE
    sys.exit(1)

if PREFIX=='': PREFIX=default_prefix
print "INSTALL PREFIX="+PREFIX
if FLX_DIR=='': FLX_DIR = os.curdir
if FLX_LPARCHIVE=='': FLX_LPARCHIVE = os.curdir
print "FLX_DIR="+FLX_DIR
print "FLX_LPARCHIVE="+FLX_LPARCHIVE
print "FLX_RTL_DIR="+FLX_RTL_DIR
print "FLX_TARGET_CONFIG_DIR="+FLX_TARGET_CONFIG_DIR
print "FLX_HOST_CONFIG_DIR="+FLX_HOST_CONFIG_DIR

#---------------------------------------------------
# Discover C/C++ compilers, linker, and other 'binutils'

import flxbuild.ocaml_class
import flxbuild.gcc_class
import flxbuild.gxx_class
import flxbuild.msvcc_class
import flxbuild.msvcxx_class

#
# Detect the native build model
#
# This model has two uses: first, to build any build time
# tools needed to assist in generating the sources
# and second, to aid in selecting the options to cross-compile
# for the chosen host and target
#

if "build" in PHASES:
  print
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking BUILD MODEL",build_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if build_model in ["win32","win64"]:
    BUILD_CC=flxbuild.msvcc_class.msvcc(verbose=verbose, quiet=quiet)
    BUILD_CXX=flxbuild.msvcxx_class.msvcxx(verbose=verbose, quiet=quiet)
  else:
    BUILD_CC=flxbuild.gcc_class.gcc(verbose=verbose, quiet=quiet)
    BUILD_CXX=flxbuild.gxx_class.gxx(verbose=verbose, quiet=quiet)

  BUILD_CC.set_options(
      COM=BUILDCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CC.check_options()
  BUILD_CC.report_config()
  BUILD_CC.save_options("config/build_cc.py")
  build_model=BUILD_CC.options.model

  BUILD_CXX.set_options(
      COM=BUILDCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="build",
      model=build_model,
      build=build_model)

  BUILD_CXX.check_options()
  BUILD_CXX.report_config()
  BUILD_CXX.save_options("config/build_cxx.py")
  build_model=BUILD_CXX.options.model

  try:
    mkdirs("config")

    print "Writing build config file"
    f = open("config"+os.sep+"build_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    print "WRITE STEP 0"
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    print "WRITE STEP 1"
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"from flxbuild.config_support import *")

    pa(f,this,"build_model")
    pa(f,this,"FLX_DIR")
    pa(f,this,"FLX_LPARCHIVE")
    pa(f,this,"FLX_RTL_DIR")
    pa(f,this,"FLX_TARGET_CONFIG_DIR")
    pa(f,this,"FLX_HOST_CONFIG_DIR")
    pr(f,"")

    print "WRITE STEP 2"

    cc = BUILD_CC.__class__.__name__
    pr(f,"BUILD_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"BUILD_CC.load_options("+repr('config'+os.sep+'build_cc.py')+")")

    cxx = BUILD_CXX.__class__.__name__
    pr(f,"BUILD_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"BUILD_CXX.load_options("+repr('config'+os.sep+'build_cxx.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"build_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"build_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"build"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = os.path.splitext(os.path.basename(cpkgf))[0]
    print "build CONFIGURING", cpkg
    __import__('cpkgs.build.' + cpkg)


if "host" in PHASES:
  #
  # Now create the host model: the compiler has to run
  # on the build machine, but can cross compile for
  # the host (if so, we can build but not test Felix)
  #
  # Cross compilation of the host tools may prevent any
  # testing of the tools
  #


  if not host_model:
    host_model=build_model
    print "Defaulting host model to build model",host_model
  if not target_model:
    target_model = host_model
    print "Defaulting target model to host model:",target_model


  print
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking HOST MODEL",host_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if host_model in ["win32","win64"]:
    HOST_CC=flxbuild.msvcc_class.msvcc(verbose=verbose, quiet=quiet)
    HOST_CXX=flxbuild.msvcxx_class.msvcxx(verbose=verbose, quiet=quiet)
  else:
    HOST_CC=flxbuild.gcc_class.gcc(verbose=verbose, quiet=quiet)
    HOST_CXX=flxbuild.gxx_class.gxx(verbose=verbose, quiet=quiet)

  HOST_CC.set_options(
      COM=HOSTCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CC.options.COM == BUILD_CC.options.COM and \
      HOST_CC.options.model == BUILD_CC.options.model and \
      HOST_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the HOST_CC'
    HOST_CC.load_options("config"+os.sep+"build_cc.py")
    HOST_CC.options.use = "host"
  else:
    HOST_CC.check_options()
    HOST_CC.report_config()
  HOST_CC.save_options("config"+os.sep+"host_cc.py")

  HOST_CXX.set_options(
      COM=HOSTCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="host",
      model=host_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      HOST_CXX.options.COM == BUILD_CXX.options.COM and \
      HOST_CXX.options.model == BUILD_CXX.options.model and \
      HOST_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the HOST_CXX'
    HOST_CXX.load_options("config"+os.sep+"build_cxx.py")
    HOST_CXX.options.use = "host"
  else:
    HOST_CXX.check_options()
    HOST_CXX.report_config()
  HOST_CXX.save_options("config"+os.sep+"host_cxx.py")

  HOST_OCAML = flxbuild.ocaml_class.ocaml(verbose=verbose, quiet=quiet)

  camllinkopts = ""
  if HOST_CXX.options.CYGWIN:
    camllinkopts = '-ccopt "-Wl,--stack -Wl,10485760" '

  HOST_OCAML.autodetect(camllinkopts)
  HOST_OCAML.report_config()
  HOST_OCAML.save_options("config/ocaml_config.py")


  host_model = HOST_CXX.options.model
  try:
    mkdirs("config")

    print "Writing host config file"
    f = open("config"+os.sep+"host_config.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,"from flxbuild.config_support import *")

    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"FLX_DIR")
    pa(f,this,"FLX_LPARCHIVE")
    pa(f,this,"FLX_RTL_DIR")
    pa(f,this,"FLX_HOST_CONFIG_DIR")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    f.close()
  except EnvironmentError:
    print "Unable to create config"+os.sep+"host_config.py"
    sys.exit(1)

  print "Created config"+os.sep+"host_config.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"host"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = os.path.splitext(os.path.basename(cpkgf))[0]
    print "host CONFIGURING", cpkg
    __import__('cpkgs.host.' + cpkg)


if "target" in PHASES:
  #
  # Now create the target model: the compiler has to run
  # on the build machine, but can cross compile for
  # the target
  #
  # cross compilation of C++ generated by Felix allows us to
  # check the generated code compiles, but not that it runs
  # [but the output is largely portable so we can still try]
  #

  print
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print "Checking TARGET MODEL",target_model
  print "++++++++++++++++++++++++++++++++++++++++++++++++++++++++"
  print

  if target_model in ["win32","win64"]:
    TARGET_CC=flxbuild.msvcc_class.msvcc(verbose=verbose, quiet=quiet)
    TARGET_CXX=flxbuild.msvcxx_class.msvcxx(verbose=verbose, quiet=quiet)
  else:
    TARGET_CC=flxbuild.gcc_class.gcc(verbose=verbose, quiet=quiet)
    TARGET_CXX=flxbuild.gxx_class.gxx(verbose=verbose, quiet=quiet)

  TARGET_CC.set_options(
      COM=TARGETCC,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CC.options.COM == BUILD_CC.options.COM and \
      TARGET_CC.options.model == BUILD_CC.options.model and \
      TARGET_CC.options.build == BUILD_CC.options.build:
    print 'using the BUILD_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"build_cc.py")
    TARGET_CC.options.use = "target"
  elif \
      TARGET_CC.options.COM == HOST_CC.options.COM and \
      TARGET_CC.options.model == HOST_CC.options.model and \
      TARGET_CC.options.build == HOST_CC.options.build:
    print 'using the HOST_CC options for the TARGET_CC'
    TARGET_CC.load_options("config"+os.sep+"host_cc.py")
  else:
    TARGET_CC.check_options()
    TARGET_CC.report_config()
  TARGET_CC.save_options("config"+os.sep+"target_cc.py")

  TARGET_CXX.set_options(
      COM=TARGETCXX,
      include_paths=include_paths,
      lib_paths=lib_paths,
      use="target",
      model=target_model,
      build=build_model)

  # check if we can just copy the build compiler
  if \
      TARGET_CXX.options.COM == BUILD_CXX.options.COM and \
      TARGET_CXX.options.model == BUILD_CXX.options.model and \
      TARGET_CXX.options.build == BUILD_CXX.options.build:
    print 'using the BUILD_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"build_cxx.py")
    TARGET_CXX.options.use = "target"
  elif \
      TARGET_CXX.options.COM == HOST_CXX.options.COM and \
      TARGET_CXX.options.model == HOST_CXX.options.model and \
      TARGET_CXX.options.build == HOST_CXX.options.build:
    print 'using the HOST_CXX options for the TARGET_CXX'
    TARGET_CXX.load_options("config"+os.sep+"host_cxx.py")
    TARGET_CXX.options.use = "target"

  else:
    TARGET_CXX.check_options()
    TARGET_CXX.report_config()
  TARGET_CXX.save_options("config"+os.sep+"target_cxx.py")

  if target_model in ["win32","win64"]:
    FLX_SOCKLEN_T = "int"
    HAVE_PTHREADS = 0
    PTHREAD_SWITCH = ""
    HAVE_MSVC = 1
    HAVE_GNU = 0
    HAVE_KQUEUE_DEMUXER = 0 #windows doesn't have kqueues.
    # nor these. does this really need to be said?
    HAVE_POLL = 0
    HAVE_EPOLL = 0
    HAVE_EVTPORTS = 0
    HAVE_OPENMP = 0
    DIFF = 'FC /L /W'
  else:
    FLX_SOCKLEN_T = TARGET_CXX.options.FLX_SOCKLEN_T
    HAVE_PTHREADS =  TARGET_CXX.options.HAVE_PTHREADS
    PTHREAD_SWITCH =  TARGET_CXX.options.PTHREAD_SWITCH
    HAVE_KQUEUE_DEMUXER = TARGET_CXX.options.HAVE_KQUEUE_DEMUXER
    # EH?
    HAVE_POLL = TARGET_CXX.options.HAVE_POLL
    HAVE_EPOLL = TARGET_CXX.options.HAVE_EPOLL
    HAVE_EVTPORTS = TARGET_CXX.options.HAVE_EVTPORTS
    HAVE_OPENMP = TARGET_CXX.options.HAVE_OPENMP

    HAVE_MSVC = 0
    HAVE_GNU = 1

    #DIFF = "diff -a -b " # build system is Unix Python
    # RF - trying out args that work on solaris (-a = not cool)
    # could use that sys type stuff here?
    DIFF = 'diff -b'

    ISCR = sys.executable + ' ' + \
      os.path.join(FLX_DIR, 'interscript', 'bin', 'iscr.py') + \
      ' --cache-prefix=lpsrc-cache'

  # target model switches
  CYGWIN = TARGET_CXX.options.CYGWIN
  MACOSX = TARGET_CXX.options.MACOSX
  WIN32 =  TARGET_CXX.options.WIN32
  WIN64 =  TARGET_CXX.options.WIN32
  LINUX =  TARGET_CXX.options.LINUX
  SOLARIS =  TARGET_CXX.options.SOLARIS
  POSIX =  TARGET_CXX.options.POSIX
  BSD =  TARGET_CXX.options.BSD

  target_model = TARGET_CXX.options.model
  if not run_model:
    run_model = target_model
    print "Defaulting run model to target model:",run_model

  SUPPORT_DYNAMIC_LOADING = TARGET_CXX.options.SUPPORT_DYNAMIC_LOADING

  if SUPPORT_DYNAMIC_LOADING:
    DEFAULT_LINK_MODEL="dynamic"
  else:
    DEFAULT_LINK_MODEL="static"


  try:
    mkdirs("config")

    print "Writing main config file"
    f = open("config"+os.sep+"__init__.py","w")
    pr(f,'import sys')
    pr(f,"if '' not in sys.path: sys.path = [''] + sys.path")
    pr(f,'#'+CONFIG_TIME)
    pr(f,'#'+CONFIG_GENERATOR_CVS_ID)
    pa(f,this,"CONFIG_GENERATOR_CVS_ID")
    pa(f,this,"CONFIG_TIME")
    pa(f,this,"flx_version")
    pa(f,this,"flx_version_major")
    pa(f,this,"godi_revision")
    pa(f,this,"debian_revision")
    if BOOTFILE:
      pr(f,"try:")
      pr(f,"  execfile('config/config_bootstrap.py')")
      pr(f,"except: pass")
    pr(f,"import flxbuild")
    pr(f,"import flxbuild.gcc_class")
    pr(f,"import flxbuild.msvcc_class")
    pr(f,"import flxbuild.gxx_class")
    pr(f,"import flxbuild.msvcxx_class")
    pr(f,"import flxbuild.ocaml_class")
    pr(f,"from flxbuild.config_support import *")

    pr(f,"")
    pr(f,"#User configurable section")
    pa(f,this,"SUPPORT_DYNAMIC_LOADING")
    pr(f,"SUPPORT_STATIC_LINKAGE = 1")
    pa(f,this,"DEFAULT_LINK_MODEL")
    pa(f,this,"build_model")
    pa(f,this,"host_model")
    pa(f,this,"target_model")
    pa(f,this,"run_model")
    pa(f,this,"CYGWIN")
    pa(f,this,"MACOSX")
    pa(f,this,"HAVE_KQUEUE_DEMUXER")
    pa(f,this,"HAVE_POLL")
    pa(f,this,"HAVE_EPOLL")
    pa(f,this,"HAVE_EVTPORTS")
    pa(f,this,"HAVE_OPENMP")
    pa(f,this,"WIN32")
    pa(f,this,"WIN64")
    pa(f,this,"POSIX")
    pa(f,this,"SOLARIS")
    pa(f,this,"BSD")
    pa(f,this,"LINUX")
    pa(f,this,"PREFIX")
    pa(f,this,"FLX_SOCKLEN_T")
    pa(f,this,"HAVE_PTHREADS")
    pa(f,this,"PTHREAD_SWITCH")
    pa(f,this,"HAVE_PKGCONFIG")
    pa(f,this,"FLX_DIR")
    pa(f,this,"FLX_LPARCHIVE")
    pa(f,this,"FLX_RTL_DIR")
    pa(f,this,"FLX_HOST_CONFIG_DIR")
    pa(f,this,"FLX_TARGET_CONFIG_DIR")
    pr(f,"")

    pr(f,"HOST_OCAML=flxbuild.ocaml_class.ocaml()")
    pr(f,"HOST_OCAML.load_options("+repr('config'+os.sep+'ocaml_config.py')+")")

    cc = HOST_CC.__class__.__name__
    pr(f,"HOST_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"HOST_CC.load_options("+repr('config'+os.sep+'host_cc.py')+")")
    cc = TARGET_CC.__class__.__name__
    pr(f,"TARGET_CC=flxbuild."+cc+"_class."+cc+"()")
    pr(f,"TARGET_CC.load_options("+repr('config'+os.sep+'target_cc.py')+")")

    cxx = HOST_CXX.__class__.__name__
    pr(f,"HOST_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"HOST_CXX.load_options("+repr('config'+os.sep+'host_cxx.py')+")")
    cxx = TARGET_CXX.__class__.__name__
    pr(f,"TARGET_CXX=flxbuild."+cxx+"_class."+cxx+"()")
    pr(f,"TARGET_CXX.load_options("+repr('config'+os.sep+'target_cxx.py')+")")
    pr(f,"")
    pa(f,this,"HAVE_GNU")
    pr(f,"FLXCC_CPP='cpp '")
    pa(f,this,"HAVE_MSVC")
    pa(f,this,"DIFF")
    pa(f,this,"ISCR")
    pr(f,"")
    pr(f,"# HACK to get all the target variables into global namespace")
    f.close()
    if BOOTFILE:
      print "Copying bootfile :  "+ BOOTFILE
      shutil.copy(BOOTFILE, os.path.join('config', 'config_bootstrap.py'))
  except EnvironmentError:
    print "Unable to create config"+os.sep+"__init__.py"
    sys.exit(1)

  print "Created config"+os.sep+"__init__.py"
  print "Edit this file to set your preferences"
  print "This file will not be clobbered by the Felix build process"

  cpkgs =  glob.glob("cpkgs"+os.sep+"target"+os.sep+"*.py")
  for cpkgf in cpkgs:
    cpkg = os.path.splitext(os.path.basename(cpkgf))[0]
    print "target CONFIGURING", cpkg
    __import__('cpkgs.target.' + cpkg)

@h = tangler('config/flx_data.py')
@select(h)
import os
import config

cprecedence = [
  "atom",
  "primary",
  "postfix",
  "unary",
  "cast",
  "pm",
  "mult",
  "add",
  "shift",
  "rel",
  "eq",
  "band",
  "bxor",
  "bor",
  "and",
  "xor",
  "or",
  "cond",
  "assign",
  "comma",
  "expr"
]

cpp_keywords = [
  'asm',
  'auto',
  'bool',
  'break',
  'case',
  'catch',
  'char'
  'class',
  'const',
  'const_cast',
  'continue',
  'default',
  'delete',
  'do',
  'double',
  'dynamic_cast',
  'else',
  'enum',
  'explicit',
  'extern',
  'false',
  'float',
  'for',
  'friend',
  'goto',
  'if',
  'inline',
  'int',
  'long',
  'mutable',
  'namespace',
  'new',
  'operator',
  'private',
  'protected',
  'public',
  'register',
  'reinterpret_cast',
  'return',
  'short',
  'signed',
  'sizeof',
  'static',
  'static_cast',
  'struct',
  'switch',
  'template',
  'this',
  'throw',
  'true',
  'try',
  'typedef',
  'typeid',
  'typename',
  'union',
  'unsigned',
  'using',
  'virtual',
  'void',
  'volatile',
  'wchar_t',
  'while',
  ]

flx_expr_terminator_keywords = [
    ("all", "ALL"),
    ("assert", "ASSERT"),
    ("axiom", "AXIOM"),
    ("body", "BODY"),
    ("call", "CALL"),
    ("case", "CASE"),
    ("caseno", "CASENO"),
    ("cclass", "CCLASS"),
    ("cfun", "CFUNCTION"),
    ("class", "CLASS"),
    ("comment", "COMMENT_KEYWORD"),
    ("compound", "COMPOUND"),
    ("const", "CONST"),
    ("cparse", "CPARSE"),
    ("cproc", "CPROCEDURE"),
    ("cstruct", "CSTRUCT"),
    ("ctor", "CTOR"),
    ("ctypes", "CTYPES"),
    ("def", "DEF"),
    ("do", "DO"),
    ("done", "DONE"),
    ("elif", "ELIF"),
    ("else", "ELSE"),
    ("endcase", "ENDCASE"),
    ("endif", "ENDIF"),
    ("endmatch", "ENDMATCH"),
    ("enum", "ENUM"),
    ("expect", "EXPECT"),
    ("export", "EXPORT"),
    ("for", "FOR"),
    ("forget", "FORGET"),
    ("fork", "FORK"),
    ("functor", "FUNCTOR"),
    ("fun", "FUNCTION"),
    ("gen", "GENERATOR"),
    ("goto", "GOTO"),
    ("halt", "HALT"),
    ("header", "HEADER"),
    ("ident", "IDENT"),
    ("include","INCLUDE"),
    ("incomplete", "INCOMPLETE"),
    ("inf", "INF"),
    ("in", "IN"),
    ("instance", "INSTANCE"),
    ("is", "IS"),
    ("inherit", "INHERIT"),
    ("inline", "INLINE"),
    ("jump", "JUMP"),
    ("lemma", "LEMMA"),
    ("let", "LET"),
    ("loop", "LOOP"),
    ("lval", "LVAL"),
    ("macro", "MACRO"),
    ("module", "MODULE"),
    ("namespace", "NAMESPACE"),
    ("NaN", "NAN"),
    ("new", "NEW"),
    ("noinline", "NOINLINE"),
    ("nonterm", "NONTERM"),
    ("noreturn", "NORETURN"),
    ("not", "NOT"),
    ("obj", "OBJECT"),
    ("open","OPEN"),
    ("package", "PACKAGE"),
    ("pod", "POD"),
    ("private", "PRIVATE"),
    ("proc", "PROCEDURE"),
    ("property", "PROPERTY"),
#    ("public", "PUBLIC"),
#    ("publish", "PUBLISH"),
    ("reduce", "REDUCE"),
    ("ref", "REF"),
    ("rename", "RENAME"),
    ("requires", "REQUIRES"),
    ("return", "RETURN"),
    ("SCHEME", "SCHEME"),
    ("syntax", "SYNTAX"),
    ("struct", "STRUCT"),
    ("then", "THEN"),
    ("todo", "TODO"),
    ("to", "TO"),
    ("typedef", "TYPEDEF"),
    ("type", "TYPE"),
    ("typeclass", "TYPECLASS"),
    ("union", "UNION"),
    ("use","USE"),
    ("val", "VAL"),
    ("var", "VAR"),
    ("virtual", "VIRTUAL"),
    ("where", "WHERE"),
    ("when", "WHEN"),
#    ("whilst", "WHILST"),
    ("with", "WITH"),
#    ("until", "UNTIL"),
    ("yield", "YIELD"),
    ("_gc_pointer", "GC_POINTER"),
    ("_gc_type", "GC_TYPE"),
    ("_svc", "SVC"),
    ("_deref", "DEREF"),
  ]

flx_other_keywords = [
    ("and", "AND"),
    ("as", "AS"),
    ("callback", "CALLBACK"),
    ("code", "CODE"),
    ("false", "FALSE"),
    ("if", "IF"),
    ("isin", "ISIN"),
    ("match", "MATCH"),
    ("noexpand", "NOEXPAND"),
    ("of", "OF"),
    ("or", "OR"),
    ("parse", "PARSE"),
    ("regexp", "REGEXP"),
    ("reglex", "REGLEX"),
    ("regmatch", "REGMATCH"),
    ("the", "THE"),
    ("true", "TRUE"),
    ("typematch", "TYPEMATCH"),
    ("typecase", "TYPECASE"),
    ("whence", "WHENCE"),
    ("unless", "UNLESS"),
    ("_", "UNDERSCORE"),
  ]

# symbols that can't be followed by a keyword
flx_leadin_keywords = [
  "COLONCOLON",
  "DOT",
  "RIGHTARROW",
  "STRUCT",
  "UNION",
  "CLASS",
  "FUNCTION",
  "PROCEDURE",
  "GENERATOR",
]

flx_keywords = flx_expr_terminator_keywords + flx_other_keywords

flx_1_char_syms = [
    ("DOLLAR","$"),
    ("QUEST","?"),
    ("EXCLAMATION","!"),
    ("LPAR","("),
    ("RPAR",")"),
    ("LSQB","["),
    ("RSQB","]"),
    ("LBRACE","{"),
    ("RBRACE","}"),
    ("COLON",":"),
    ("COMMA",","),
    ("SEMI",";"),
    ("PLUS","+"),
    ("MINUS","-"),
    ("STAR","*"),
    ("SLASH","/"),
    ("VBAR","|"),
    ("AMPER","&"),
    ("LESS","<"),
    ("GREATER",">"),
    ("EQUAL","="),
    ("DOT","."),
    ("PERCENT","%"),
    ("BACKQUOTE","`"),
    ("TILDE","~"),
    ("CIRCUMFLEX","^"),
    ("HASH","#"),
  ]

flx_2_char_syms = [
    ("DOLLARDOLLAR","$$"),
    ("ANDLESS","&<"),
    ("ANDGREATER","&>"),
    ("EQEQUAL","=="),
    ("NOTEQUAL","!="),
    ("LESSEQUAL","<="),
    ("GREATEREQUAL",">="),
    ("LEFTSHIFT","<<"),
    ("RIGHTSHIFT",">>"),
    ("STARSTAR","**"),
    ("LESSCOLON","<:"),
    ("COLONGREATER",":>"),
    ("DOTDOT",".."),
    ("COLONCOLON","::"),

    ("PLUSPLUS","++"),
    ("MINUSMINUS","--"),
    ("PLUSEQUAL","+="),
    ("MINUSEQUAL","-="),
    ("STAREQUAL","*="),
    ("SLASHEQUAL","/="),
    ("PERCENTEQUAL","%="),
    ("CARETEQUAL","^="),
    ("VBAREQUAL","|="),
    ("AMPEREQUAL","&="),
    ("TILDEEQUAL","~="),
    ("COLONEQUAL",":="),
    ("RIGHTARROW","->"),
    ("EQRIGHTARROW","=>"),
    ("LEFTARROW","<-"),

    ("LSQBAR","[|"),
    ("RSQBAR","|]"),

    ("AMPERAMPER","&&"),
    ("VBARVBAR","||"),
    ("SLOSHAMPER","\\\\&"),
    ("SLOSHVBAR","\\\\|"),
    ("SLOSHCIRCUMFLEX","\\\\^"),
    ("HASHBANG","#!"),
  ]

flx_3_char_syms = [
    ("LEFTSHIFTEQUAL","<<="),
    ("RIGHTSHIFTEQUAL",">>="),
    ("LEFTRIGHTARROW","<->"),
    ("ANDEQEQUAL","&=="),
    ("ANDNOTEQUAL","&!="),
    ("ANDLESSEQUAL","&<="),
    ("ANDGREATEREQUAL","&>="),
    ("DOTDOTDOT","..."),
#    ("DOTRIGHTARROW",".->"),
    ("LONGRIGHTARROW","-->"),
    ("PARSE_ACTION","=>#"),
    ("HASHBANGSLASH","#!/"),
  ]

flx_syms = flx_1_char_syms + flx_2_char_syms + flx_3_char_syms

rmap = {}

tmap = {
  # addressing
  "byte"      : "unsigned char",
  "size"      : "size_t",
  "cvaddress" : "void const volatile*",
  "vaddress"  : "void volatile*",
  "caddress"  : "void const*",
  "address"   : "void *",
  "offset"    : "ptrdiff_t",
  "ptrdiff"   : "ptrdiff_t",

  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double"
 }

if config.TARGET_CXX.options.HAVE_COMPLEX:
  tmap["imaginary"]="float _Imaginary"
  tmap["dimaginary"]="double _Imaginary"
  tmap["limaginary"]="long double _Imaginary"
  tmap["complex" ]="float _Complex"
  tmap["dcomplex"]="double _Complex"
  tmap["lcomplex"]="long double _Complex"

  rmap["imaginary" ]="c99_complex_h"
  rmap["dimaginary" ]="c99_complex_h"
  rmap["limaginary" ]="c99_complex_h"
  rmap["complex" ]="c99_complex_h"
  rmap["dcomplex"]="c99_complex_h"
  rmap["lcomplex"]="c99_complex_h"
else:
  tmap["imaginary"]="float"
  tmap["dimaginary"]="double"
  tmap["limaginary"]="long double"
  tmap["complex" ]="std::complex<float>"
  tmap["dcomplex"]="std::complex<double>"
  tmap["lcomplex"]="std::complex<long double>"

  rmap["complex" ]="complex_hxx"
  rmap["dcomplex"]="complex_hxx"
  rmap["lcomplex"]="complex_hxx"

if config.TARGET_CXX.options.HAVE_LONGDOUBLE:
  tmap["ldouble"]="long double"
else:
  tmap["ldouble"]="double"

if config.TARGET_CXX.options.HAVE_LONGLONG:
  tmap["vlong"]="long long"
  tmap["uvlong"]="unsigned long long"
else:
  tmap["vlong"]="long"
  tmap["uvlong"]="unsigned long"

if config.TARGET_CXX.options.HAVE_STDINT:
  tmap["int8"]="int8_t"
  tmap["uint8"]="uint8_t"
  tmap["int16"]="int16_t"
  tmap["uint16"]="uint16_t"
  tmap["int32"]="int32_t"
  tmap["uint32"]="uint32_t"
  tmap["int64"]="int64_t"
  tmap["uint64"]="uint64_t"
  tmap["intptr"]="intptr_t"
  tmap["uintptr"]="uintptr_t"
  tmap["intmax"]="intmax_t"
  tmap["uintmax"]="uintmax_t"

  # requirements
  rmap["int8"]="c99_stdint_h"
  rmap["uint8"]="c99_stdint_h"
  rmap["int16"]="c99_stdint_h"
  rmap["uint16"]="c99_stdint_h"
  rmap["int32"]="c99_stdint_h"
  rmap["uint32"]="c99_stdint_h"
  rmap["int64"]="c99_stdint_h"
  rmap["uint64"]="c99_stdint_h"
  rmap["intptr"]="c99_stdint_h"
  rmap["uintptr"]="c99_stdint_h"
  rmap["intmax"]="c99_stdint_h"
  rmap["uintmax"]="c99_stdint_h"
else:
  tmap["int8"]="signed char"
  tmap["uint8"]="unsigned char"
  sizes = {
    config.TARGET_CXX.options.SIZEOF_SHORT*8 : "short",
    config.TARGET_CXX.options.SIZEOF_INT*8: "int",
    config.TARGET_CXX.options.SIZEOF_LONG*8 : "long",
  }
  tmap["intmax"]="long"
  tmap["uintmax"]="unsigned long"
  if config.TARGET_CXX.options.HAVE_LONGLONG:
    sizes[config.TARGET_CXX.options.SIZEOF_LONGLONG*8]="long long"
    tmap["intmax"]="long long"
    tmap["uintmax"]="unsigned long long"
  for size in [16,32,64]:
    try:
      t = sizes[size]
    except KeyError:
      tmap["int"+str(size)]="emul_int"+str(size)
      tmap["uint"+str(size)]="emul_uint"+str(size)
    else:
      tmap["int"+str(size)]=t
      tmap["uint"+str(size)]="unsigned " + t
  try:
    tmap["intptr"]=sizes[config.TARGET_CXX.options.SIZEOF_VOIDP*8]
    tmap["uintptr"]="unsigned "+sizes[config.TARGET_CXX.options.SIZEOF_VOIDP*8]
  except:
    print "NO INTEGER THE SIZE OF A VOID*!"
    sys.exit(1)

tmap["uchar"]=tmap["int32"] # Unicode/ISO10646, note: SIGNED!
