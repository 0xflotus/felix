@head(1,'Macro Expansion')
@head(2,'Notes')
Felix macros have 3 flavours:
@begin_table('keyword','kind','subst')
@table_row('ident','name','exe expr+dcl')
@table_row('fun','expr','exe expr')
@table_row('proc','statement','exe stmt')
@end_table()
@p()
Name macros allow renaming of functions, procedures,
values, consts, variables, the body must be an identifier
or the keyword new.
Expression macros replace applications in expressions.
Statement macros replace call statement.
@p()
Macros are expanded by evaluating the arguments if any,
substituting the arguments into the body,
and then evaluating the body.
@p()
Evaluation is by recursive descent with rescanning.
@p()
Note: name macros replace names in executable code,
including macro bodies, but they cannot be used
to rename macros.

@head(2,'Implementation')
@h = tangler('src/flx_macro.mli')
@select(h)
open Flx_ast
val expand_macros:
  string -> 
  int -> 
  statement_t list -> 
  statement_t list

(** [expand_expr] is a special hook used to perform
  constant folding and desugaring in the preprocessor
*)
val expand_expression:
  string -> expr_t -> expr_t
  
@h = tangler('src/flx_macro.ml')
@select(h)
open Flx_ast
open Flx_mtypes2
open Flx_print
open Flx_exceptions
open List
open Flx_constfld
open Flx_srcref
open Flx_typing2 
open Flx_util

exception Macro_return

let truthof x = match x with
  | `AST_typed_case (_,1,`TYP_unitsum 2) -> Some false
  | `AST_typed_case (_,2,`TYP_unitsum 2) -> Some true
  | _ -> None

(* 
 There are no type macros: use typedef facility.
 There are no regexp macros: use regdef facility.
*)

type macro_t = 
 | MVar of expr_t ref
 | MVal of expr_t 
 | MVals of expr_t list
 | MExpr of macro_parameter_t list * expr_t 
 | MStmt of macro_parameter_t list * statement_t list
 | MName of id_t
 | MNames of id_t list

type macro_dfn_t = id_t * macro_t

let print_mpar (id,t) = 
  id ^ ":" ^ 
  (
    match t with 
    | Expr -> "fun"
    | Stmt -> "proc"
    | Ident -> "ident"
  )

let print_mpars x = 
  "(" ^ String.concat ", " (map print_mpar x) ^ ")"

let print_macro (id,t) = 
 match t with
 | MVar v -> "MVar " ^ id ^ " = " ^ string_of_expr !v
 | MVal v -> "MVal " ^ id ^ " = " ^ string_of_expr v
 | MVals vs -> "MVals " ^ id ^ " = " ^ catmap "," string_of_expr vs
 | MExpr (ps,e) -> 
   "MExpr " ^ id ^ 
   print_mpars ps ^ 
   " = " ^ 
   string_of_expr e
   
 | MStmt (ps,sts) -> 
   "MStmt " ^ id ^ 
   print_mpars ps ^ 
   " = " ^ 
   String.concat "\n" (map (string_of_statement 1) sts)

 | MName id -> "MName " ^ id ^ " = " ^ id
 | MNames ids -> "MNames " ^ id ^ " = " ^ cat "," ids

let string_of_macro_env x = String.concat "\n" (map print_macro x)

(* ident expansion: guarranteed to terminate,
  expansion of x given x -> x is just x
*)
let rec expand_ident sr macros noexpand id =
  try 
    if mem id noexpand then id else
    match assoc id macros with
    | MName id2 -> expand_ident sr macros (id::noexpand) id2
    | _ -> id 
  with Not_found -> id
 
(* Find variable names in patterns so as to protect them *)
let rec get_pattern_vars pat =
  match pat with
  | `PAT_name (_,v) -> [v]
  | `PAT_as (_,p,v) -> v :: get_pattern_vars p
  | `PAT_when (_,p,_) -> get_pattern_vars p
  | `PAT_nonconst_ctor (_,_,p) -> get_pattern_vars p
  | `PAT_tuple (_,ps) -> concat (map get_pattern_vars ps)
  | _ -> []
  
(* protect parameter names, to prevent gratuitous substitions *)
let protect sr (ps:id_t list) : macro_dfn_t list =
  let rec aux t macs = 
    match t with
    | [] -> macs 
    | h :: t -> 
      let mac = h, MVal (`AST_noexpand (sr,`AST_name (sr,h,[]))) in
      aux t (mac::macs)
  in 
    aux ps []

let build_args sr ps args =
  map2
  (fun (p,t) a ->
    match t with
    | Ident -> 
      begin match a with
      | `AST_name (_,name,[]) -> (p,MName name)
      | _ -> 
        clierr sr 
        (
          "[build_args] Wrong argument type, expected Identifier, got:\n" ^ 
          string_of_expr a
        )
      end

    | Expr -> (p,MVal a)
    | Stmt ->
      begin match a with
      | `AST_lambda (_,([[],_],`TYP_none,sts)) -> (p,MStmt ([],sts))
      | `AST_name(_,name,[]) ->(p,MVal a)
      | _ -> 
        clierr sr 
        (
          "[build_args] Wrong argument type, expected {} enclosed statement list or macro procedure name, got\n" ^
          string_of_expr a
        )
      end
  )
  ps args

(* alpha convert parameter names *)
let rec alpha_expr sr local_prefix seq ps e =
  let psn, pst = split ps in
  let psn' =  (* new parameter names *)
    map 
    (fun _ -> let b = !seq in incr seq; "_" ^ string_of_int b) 
    psn
  in
  let remap = 
    map2
    (fun x y -> (x,MName y))
    psn psn'
  in
    let e = expand_expr 50 local_prefix seq remap e in
    let ps = combine psn' pst in
    ps,e

and alpha_stmts sr local_prefix seq ps sts =
  let psn, pst = split ps in
  let psn' =  (* new parameter names *)
    map 
    (fun _ -> let b = !seq in incr seq; "_" ^ local_prefix ^ "_" ^ string_of_int b) 
    psn
  in
  let remap = 
    map2
    (fun x y -> (x,MName y))
    psn psn'
  in
    let sts = subst_statements 50 local_prefix seq (ref true) remap sts in
    let ps = combine psn' pst in
    ps,sts
  
and expand_type_expr sr recursion_limit local_prefix seq (macros:macro_dfn_t list) (t:typecode_t):typecode_t=
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recursion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let mt t : typecode_t = expand_type_expr sr recursion_limit local_prefix seq macros t in
  let mi sr i = expand_ident sr macros [] i in
  match Flx_maps.map_type mt t with

  (* Name expansion *)
  | `AST_name (sr, name,[]) as t ->
    begin try 
      match List.assoc name macros with
      | MVar b -> typecode_of_expr (me !b)
      | MVal b -> typecode_of_expr (me b)
      | MExpr(ps,b) -> t
      | MName _ -> `AST_name (sr,mi sr name,[])
      | MStmt (ps,b) -> t
      | MVals xs -> t
      | MNames idts -> t
    with 
    | Not_found -> t
    end

  | `AST_name (sr, name,ts) as t -> 
    let ts = map mt ts in
    begin try 
      match List.assoc name macros with
      | MName _ -> `AST_name (sr,mi sr name,ts)
      | _ -> `AST_name (sr,name,ts)
    with 
    | Not_found -> t
    end

  | `TYP_typeof e -> `TYP_typeof (me e)

  | x -> x

(* expand expression *)
and expand_expr recursion_limit local_prefix seq (macros:macro_dfn_t list) (e:expr_t):expr_t =
  (*
  print_endline ("expand expr " ^ string_of_expr e);
  *)
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recursion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let mt sr e = expand_type_expr sr recursion_limit local_prefix seq macros e in
  let mi sr i = expand_ident sr macros [] i in
  let cf e = const_fold e in
  let e = cf e in
  match e with

  | `AST_strexpr (sr,e) -> 
    let s = string_of_expr e in
    `AST_literal (sr,`AST_string s)
    
  (* Expansion block: don't even fold constants *)
  | `AST_noexpand _ -> e 

  (* and desugaring: x and y and z and ... *)
  | `AST_andlist (sr, es) ->  
    begin match es with
    | [] -> failwith "Unexpected empty and list"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"land",[]),
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end

  (* or desugaring: x or y or z or ... *)
  | `AST_orlist (sr, es) ->  
    begin match es with
    | [] -> failwith "Unexpected empty alternative list"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"lor",[]),
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end

  (* Sum desugaring: x+y+z+ ... *)
  | `AST_sum (sr, es) ->  
    begin match es with
    | [] -> failwith "Unexpected empty addition"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"add",[]),
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end
        
  (* Product desugaring: x*y*z* ... *)
  | `AST_product (sr, es) ->
    begin match es with
    | [] -> failwith "Unexpected empty multiply"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"mul",[]), 
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end

  (* Setunion desugaring: x || y || z || ... *)
  | `AST_setunion (sr, es) ->
    begin match es with
    | [] -> failwith "Unexpected empty setunion "
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"setunion",[]), 
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end

  (* Setintersection desugaring: x && y && z && ... *)
  | `AST_setintersection (sr, es) ->
    begin match es with
    | [] -> failwith "Unexpected empty set intersection"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"setintersect",[]), 
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end
 
  (* Name expansion *)
  | `AST_name (sr, name,[]) ->
    begin try 
      match List.assoc name macros with
      | MVar b -> me !b
      | MVal b -> me b
      | MVals bs -> `AST_tuple (sr,(map me bs))
      | MExpr(ps,b) -> e
      | MName _ -> `AST_name (sr,mi sr name,[])
      | MNames _ -> clierr sr "Cannot use macro name list here"
      | MStmt (ps,b) -> e
    with 
    | Not_found -> e
    end

  | `AST_name (sr, name,ts) -> 
    let ts = map (mt sr) ts in
    begin try 
      match List.assoc name macros with
      | MName _ -> `AST_name (sr,mi sr name,ts)
      | _ -> `AST_name (sr,name,ts)
    with 
    | Not_found -> e
    end

   (* Name application *)
   (* NOTE: Felix doesn't support shortcut applications
      for executable expressions, however these
      ARE available for macro expansion: this is in
      fact completely basic: the expression
        id
      is indeed expanded and is of course
      equivalent to
        id ()
   *)
   | `AST_apply (sr, (e1', e2')) -> 
    let 
      e1 = me e1' and 
      e2 = me e2' 
    in
      begin match e1 with
      | `AST_name(srn,name,[]) ->
        begin try 
          match List.assoc name macros with
          | MName _ 
          | MNames _ 
          | MVar _ 
          | MVal _ 
          | MVals _ -> assert false

          | MExpr(ps,b) ->
            let args = 
              match e2 with
              | `AST_tuple (_,ls) -> ls
              | x -> [x]
            in
            let np = length ps and na = length args in
            if na = np 
            then
              begin
                let args = map me args in
                let args = build_args sr ps args in
                let b = expand_expr recursion_limit local_prefix (ref 0) args b in
                me b
              end
            else 
              clierr sr 
              (
                "[expand_expr:apply] In application:\n" ^
                "  fun = " ^string_of_expr e1'^" --> "^string_of_expr e1^"\n"^
                "  arg = " ^string_of_expr e2'^" --> "^string_of_expr e2^"\n"^
                "Macro "^name^
                " requires "^string_of_int np^" arguments," ^
                " got " ^ string_of_int na
              )
          | MStmt (ps,b) ->
            (* replace the application with a lambda wrapping
              of the corresponding procedure call
            *)
            let sts = [`AST_call (sr,e1, e2)] in
            let sts = expand_statements recursion_limit local_prefix seq (ref true) macros sts in
            `AST_lambda(sr,([[],None],`TYP_none,sts))
            (*
            clierr sr 
            (
              "[expand_expr:apply] In application:\n" ^
              "  fun = " ^string_of_expr e1'^" --> "^string_of_expr e1^"\n"^
              "  arg = " ^string_of_expr e2'^" --> "^string_of_expr e2^"\n"^
              "Macro "^name^
              " is a procedure macro" 
            )
            *)
        with 
        | Not_found ->
          cf (`AST_apply(sr,(e1, e2)))
        end
      | _ ->
        `AST_apply(sr,(e1, e2))
      end

  | `AST_cond (sr, (e1, e2, e3)) -> 
    let cond = me e1 in
    begin match cond with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c=2 then me e2 else me e3
    | _ ->
      `AST_cond (sr,(cond,me e2,me e3))
    end

  | `AST_expr (sr,s,t) -> `AST_expr (sr,s,t)

  (* Lambda hook *)
  | `AST_lambda (sr, (pss, t, sts)) -> 
    let pr = concat (map (map fst) (map fst pss)) in
    let pr = protect sr pr in
    let sts = 
      expand_statements recursion_limit local_prefix seq (ref true) 
      (pr @ macros) sts 
    in
    `AST_lambda (sr, (pss, t, sts))

  (* Name lookup *)
  | `AST_the (sr, qn) -> 
    let qn = Flx_typing.qualified_name_of_expr (me (qn:>expr_t)) in
    `AST_the (sr,qn)

  (* the name here is just for diagnostics *)
  | `AST_index (sr, n, i) -> `AST_index (sr,n,i)

  | `AST_lookup (sr, (e1, name,ts)) -> `AST_lookup (sr,(me e1, mi sr name,ts))

  | `AST_case_tag (sr, i) -> e
  | `AST_typed_case (sr, i, t) -> e
  | `AST_case_index (sr,e) -> `AST_case_index (sr,me e)

  | `AST_tuple (sr, es) -> `AST_tuple (sr, map me es)
  | `AST_arrayof (sr, es) -> `AST_arrayof (sr, map me es)
  | `AST_coercion (sr, (e1, t)) -> `AST_coercion (sr, (me e1,mt sr t)) 
  | `AST_suffix (sr, (qn, t)) -> 
    let qn = Flx_typing.qualified_name_of_expr (me (qn:>expr_t)) in
    `AST_suffix (sr, (qn,t)) 

  | `AST_arrow (sr, (e1, e2)) ->  `AST_arrow (sr,(me e1, me e2))
  | `AST_superscript (sr, (e1, e2)) ->  `AST_superscript (sr,(me e1, me e2))

  | `AST_literal (sr, literal) ->  e
  | `AST_map (sr, f, e) -> `AST_map (sr, me f, me e)
  | `AST_deref (sr, e1) -> `AST_deref (sr, me e1)
  | `AST_ref (sr, e1) ->  `AST_ref (sr, me e1)
  | `AST_method_apply (sr, (id, e1,ts)) -> `AST_method_apply (sr,(mi sr id, me e1,map (mt sr) ts))
  | `AST_dot (sr, (e1, id, ts)) ->  `AST_dot (sr,(me e1,mi sr id, ts))
  | `AST_match_ctor (sr, (qn, e1)) -> `AST_match_ctor (sr,(qn,me e1))
  | `AST_match_case (sr, (i, e1)) ->  `AST_match_case (sr,(i, me e1))
  | `AST_ctor_arg (sr, (qn, e1)) -> `AST_ctor_arg (sr,(qn, me e1))
  | `AST_case_arg (sr, (i, e1)) ->  `AST_case_arg (sr,(i,me e1))
  | `AST_letin (sr, (pat, e1, e2)) -> `AST_letin (sr, (pat, me e1, me e2))

  | `AST_get_n (sr, (i, e1)) ->  `AST_get_n (sr,(i,me e1))
  | `AST_get_named_variable (sr, (i, e1)) ->  `AST_get_named_variable (sr,(i,me e1))
  | `AST_get_named_method (sr, (i,j,ts, e1)) ->  
     `AST_get_named_method (sr,(i,j,map (mt sr) ts,me e1))
  | `AST_as (sr, (e1, id)) ->  `AST_as (sr,(me e1, mi sr id))

  | `AST_parse (sr, e1, ms) -> 
    let ms = map (fun (sr,p,e) -> sr,p,me e) ms in
    `AST_parse (sr, me e1, ms)

  | `AST_sparse _ -> assert false

  | `AST_match (sr, (e1, pes)) -> 
    let pes = 
      map 
      (fun (pat,e) -> 
        pat, 
        let pvs = get_pattern_vars pat in
        let pr = protect sr pvs in
        expand_expr recursion_limit local_prefix seq (pr @ macros) e
      ) 
      pes 
    in
    `AST_match (sr,(me e1, pes))
    
  | `AST_regmatch (sr, (p1, p2, res)) -> 
    let res = map (fun (rexp,e) -> rexp, me e) res in
    `AST_regmatch (sr,(me p1, me p2, res))

  | `AST_string_regmatch (sr, (s, res)) -> 
    let res = map (fun (rexp,e) -> rexp, me e) res in
    `AST_string_regmatch (sr,(me s, res))

  | `AST_reglex (sr, (e1, e2, res)) -> 
    let res = map (fun (rexp,e) -> rexp, me e) res in
    `AST_reglex (sr,(me e1, me e2, res))

  | `AST_type_match (sr, (e,ps)) ->
    let ps = map (fun (pat,e) -> pat, mt sr e) ps in
    `AST_type_match (sr,(mt sr e,ps))
  
  | `AST_ellipsis _
  | `AST_void _ -> e

  | `AST_lvalue (sr,e) -> `AST_lvalue (sr, me e)

  | `AST_typeof (sr,e) -> `AST_typeof (sr, me e)

  (*
    -> syserr (Flx_srcref.src_of_expr e) ("Expand expr: expected expresssion, got type: " ^ string_of_expr e)
  *)

(* ---------------------------------------------------------------------
  do the common work of both subst_statement and expand_statement,
  recursion to the appropriate one as indicated by the argument 'recurse'

  The flag 'reachable' is set to false on exit if the instruction
  does not drop through. The flag may be true or false on entry.
  Whilst the flag is false, no code is generated. Once the flag
  is false, a label at the low level can cause subsequent code to become
  reachble.
*)
and subst_or_expand recurse recursion_limit local_prefix seq reachable macros (st:statement_t):statement_t list = 
  (*
  print_endline ("Subst or expand: " ^ string_of_statement 0 st);
  *)
  let recurion_limit = recursion_limit - 1 in
  let mt sr e = expand_type_expr sr recursion_limit local_prefix seq macros e in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let ms s = recurse recursion_limit local_prefix seq (ref true) macros s in
  let ms' reachable s = recurse recursion_limit local_prefix seq reachable macros s in
  let msp sr ps ss = 
    let pr = protect sr ps in
    recurse recursion_limit local_prefix seq (ref true) (pr @ macros) ss 
  in
  let mi sr id = expand_ident sr macros [] id in
  let result = ref [] in
  let tack x = result := x :: !result in
  let ctack x = if !reachable then tack x in

  begin match st with
  (* cheat for now and ignore public and private decls *)
  | `AST_public (_,_,st) -> iter tack (ms [st])
  | `AST_private (sr,st) -> 
    iter (fun st -> tack (`AST_private (sr,st))) (ms [st])

  | `AST_seq (_,sts) -> 
    iter tack (ms sts)

  | `AST_include (sr, s) -> tack st

  (* FIX TO SUPPORT IDENTIFIER RENAMING *)
  | `AST_open (sr, qn) -> tack st
  | `AST_inject_module (sr, qn) -> tack st

  (* FIX TO SUPPORT IDENTIFIER RENAMING *)
  | `AST_use (sr, id, qn) -> tack (`AST_use (sr,mi sr id,qn))

  | `AST_cassign (sr,l,r) -> tack (`AST_cassign (sr, me l, me r))

  | `AST_assign (sr,name,l,r) ->
    let l = match l with
      | `Expr (sr,e),t -> `Expr (sr,me e),t
      | l -> l
    in
    tack (`AST_assign (sr, name, l, me r))

  | `AST_comment _  ->  tack st

  (* IDENTIFIER RENAMING NOT SUPPORTED IN REGDEF *)
  | `AST_regdef (sr, id, re)  ->  tack st

  | `AST_glr (sr, id, t, ms )  -> 
    (* add protection code later .. see AST_match *)
    let ms = map (fun (sr',p,e) -> sr',p,me e) ms in
    tack (`AST_glr (sr, mi sr id, mt sr t, ms ))

  | `AST_union (sr, id, vs, idts ) ->  
    let idts = map (fun (id,t) -> id,mt sr t) idts in
    tack (`AST_union (sr, mi sr id, vs, idts))
    
  | `AST_struct (sr, id, vs, idts) ->  
    let idts = map (fun (id,t) -> id,mt sr t) idts in
    tack (`AST_struct (sr, mi sr id, vs, idts))
    
  | `AST_cstruct (sr, id, vs, idts) ->  
    let idts = map (fun (id,t) -> id,mt sr t) idts in
    tack (`AST_cstruct (sr, mi sr id, vs, idts))

  | `AST_cclass (sr, id, vs, idts) ->  
    let idts = map (function 
      | `MemberVar (id,t,cc) -> `MemberVar (id,mt sr t,cc)
      | `MemberVal (id,t,cc) -> `MemberVal (id,mt sr t,cc)
      | `MemberFun (id,mix,vs,t,cc) -> `MemberFun (id,mix,vs,mt sr t,cc)
      | `MemberProc (id,mix,vs,t,cc) -> `MemberProc (id,mix,vs,mt sr t,cc)
      | `MemberCtor (id,mix,t,cc) -> `MemberCtor (id,mix,mt sr t,cc)
      ) idts 
    in
    tack (`AST_cclass (sr, mi sr id, vs, idts))

  | `AST_typeclass (sr, id, vs, idts) ->  
    let idts = map (function 
      | `TypeClassMemberFun (id,t) -> `TypeClassMemberFun (id,mt sr t)
      | `TypeClassMemberProc (id,t) -> `TypeClassMemberProc (id,mt sr t)
      ) idts 
    in
    tack (`AST_typeclass (sr, mi sr id, vs, idts))

  (* IDENTIFIER RENAMING NOT SUPPORTED IN TYPES *)
  | `AST_type_alias (sr, id, vs, t) ->  
    tack (`AST_type_alias (sr,id,vs, mt sr t))
  
  | `AST_inherit (sr, id, vs, t) ->  tack st
  | `AST_inherit_fun (sr, id, vs, t) ->  tack st
 
  | `AST_ctypes (sr, ids, qs, reqs) ->  
    iter 
    (fun (sr,id) -> 
      let sr = slift sr in
      let st = `AST_abs_decl (sr,id, [], qs, `Str id, reqs) in
      tack st
    ) 
    ids

  | `AST_abs_decl (sr,id,vs,typs,v,rqs) ->  
    tack (`AST_abs_decl (sr,id,vs,typs,v, rqs))

  | `AST_const_decl (sr, id, vs, t, c, reqs) -> 
     tack (`AST_const_decl (sr, mi sr id, vs, mt sr t, c, reqs))
    
  | `AST_fun_decl (sr, id, vs, ts, t, c, reqs,prec) -> 
    tack (`AST_fun_decl (sr, mi sr id, vs, map (mt sr) ts, mt sr t, c, reqs,prec))

  | `AST_insert (sr, n, vs, s, ikind, reqs) ->  
    tack (`AST_insert (sr,n,vs,s, ikind, reqs))
  
    (* 
      NOTE: c code is embedded even  though it isn't
      reachable because it might contain declarations or 
      even labels
    *)
  | `AST_code (sr, s) ->  
    tack st; 
    reachable := true

  | `AST_noreturn_code (sr, s) ->  
    tack st;
    reachable := false

  (* IDENTIFIER RENAMING NOT SUPPORTED IN EXPORT *)
  | `AST_export_fun (sr, sn, s) ->  tack st
  | `AST_export_type (sr, sn, s) ->  tack st

  | `AST_label (sr, id) ->  
    reachable:=true; 
    tack (`AST_label (sr, mi sr id))

  | `AST_goto (sr, id) ->  
    ctack (`AST_goto (sr, mi sr id)); 
    reachable := false

  | `AST_svc (sr, id) ->  ctack (`AST_svc (sr, mi sr id))
  | `AST_proc_return (sr)  ->  ctack st; reachable := false
  | `AST_nop (sr, s) ->  ()

  | `AST_function (sr, id, vs, (ps,traits), (t,post), props, sts ) ->
    let pr = map fst ps in
    let post = match post with | None -> None | Some x -> Some (me x) in
    let traits = match traits with | None -> None | Some x -> Some (me x) in
    let ps = map (fun (id,t) -> id,mt sr t) ps in
    tack(`AST_function (sr, mi sr id, vs, (ps,traits), (mt sr t, post), props, msp sr pr sts ))

  | `AST_curry (sr,id,vs,pss,(ret,post),kind,sts) ->
    let pr = map fst (concat (map fst pss)) in
    let post = match post with | None -> None | Some x -> Some (me x) in
    let pss = 
      map (fun (ps,traint) ->
        (
          map (fun (id,t) -> id,mt sr t)) ps,
          match traint with | None -> None | Some x -> Some (me x)
        )
      pss 
    in
    tack(`AST_curry(sr, mi sr id, vs, pss, (ret,post),kind, msp sr pr sts ))

  | `AST_object (sr, id, vs, ps, sts ) ->
    let pr = map fst (fst ps) in
    let ps = map (fun (id,t) -> id,mt sr t) (fst ps),snd ps in
    tack(`AST_object (sr, mi sr id, vs, ps, msp sr pr sts ))

  | `AST_val_decl (sr, id, vs, optt, opte) -> 
    let opte = match opte with
    | Some x -> Some (me x)
        (* 
          this *will be* an error if unreachable,
          provided the containing function is used
        *)
    | None -> None
        (* this is actually a syntax error in a module,
          but not in an interface: unfortunately,
          we can't tell the difference here
        *)
    in
    let optt = match optt with
    | Some t -> Some (mt sr t)
    | None -> None
    in
      tack (`AST_val_decl (sr, mi sr id, vs, optt, opte))

  | `AST_var_decl (sr, id, vs, optt, opte) -> 
    let opte = 
      match opte with
      | Some x -> Some (me x)
        (* unreachable var initialisations are legal *)

      | None -> None 
        (* vars don't have to be initialised *)
    in
    let optt = match optt with
    | Some t -> Some (mt sr t)
    | None -> None
    in
      tack (`AST_var_decl (sr, mi sr id, vs, optt, opte))
  
  | `AST_untyped_module (sr, id, vs, sts) ->
    tack (`AST_untyped_module (sr, mi sr id, vs, ms sts))

  | `AST_class (sr, id, vs, sts) ->
    tack (`AST_class (sr, mi sr id, vs, ms sts))

  | `AST_ifgoto (sr, e , id) -> 
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 2 then 
      ( 
        ctack (`AST_goto (sr,id));
        reachable := false
      )
    | _ ->
      ctack (`AST_ifgoto (sr, e, mi sr id))
    end

  | `AST_apply_ctor (sr,i,f,a) ->
    let i = mi sr i in
    let f = me f in
    let a = me a in
    ctack (`AST_apply_ctor (sr, i, f, a))

  | `AST_init (sr,v,e) ->
    ctack (`AST_init (sr, mi sr v, me e))
    
  | `AST_assert (sr,e) ->
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 2 (* assertion proven true *)
      then () 
      else (* assertion proven false *)
        begin
          reachable := false;
          ctack (`AST_assert (sr,e))
        end

    | _ -> (* check at run time *)
        ctack (`AST_assert (sr,e))
    end

  | `AST_whilst (sr, e , sts) -> 
    let e = me e in
    let n = !seq in incr seq;
    let start = "_" ^ string_of_int n in
    let n = !seq in incr seq;
    let fin = "_" ^ string_of_int n in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 2 then (* infinite loop *)
      begin
        ctack (`AST_label(sr,start));
        iter ctack (ms sts);
        ctack (`AST_goto (sr,start))
      end

    | _ ->
      ctack (`AST_label(sr,start));
      ctack (`AST_ifnotgoto (sr,e,fin));
      iter ctack (ms sts);
      ctack (`AST_goto (sr,start));
      ctack (`AST_label(sr,fin))
    end

  | `AST_until (sr, e , sts) -> 
    let e = me e in
    let n = !seq in incr seq;
    let start = "_" ^ string_of_int n in
    let n = !seq in incr seq;
    let fin = "_" ^ string_of_int n in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 1 then (* infinite loop *)
      begin
        ctack (`AST_label(sr,start));
        iter ctack (ms sts);
        ctack (`AST_goto (sr,start))
      end

    | _ ->
      ctack (`AST_label(sr,start));
      ctack (`AST_ifgoto (sr,e,fin));
      iter ctack (ms sts);
      ctack (`AST_goto (sr,start));
      ctack (`AST_label(sr,fin))
    end


  | `AST_ifnotgoto (sr, e, id) -> 
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 1 then 
      (
        ctack (`AST_goto (sr,id)); 
        reachable := false
      )
    | _ ->
      ctack (`AST_ifnotgoto (sr, e, mi sr id))
    end
  
  | `AST_ifreturn (sr, e) -> 
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 2 then 
      ( 
        ctack (`AST_proc_return sr);
        reachable := false
      )
    | _ ->
      let n = !seq in incr seq;
      let lab = "_" ^ string_of_int n in
      ctack (`AST_ifnotgoto (sr, e, lab));
      ctack (`AST_proc_return sr);
      ctack (`AST_label (sr,lab))
    end

  | `AST_ifdo (sr, e, sts1, sts2) -> 
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_unitsum 2) ->
      if c = 2 then
        iter ctack (ms sts1)
      else
        iter ctack (ms sts2)

    | _ ->
      let n1 = !seq in incr seq;
      let n2 = !seq in incr seq;
      let lab1 = "_" ^ string_of_int n1 in
      let lab2 = "_" ^ string_of_int n2 in
      (*
      print_endline ("Assigned labels " ^ lab1 ^ " and " ^ lab2);
      *)

      (* each branch has the initial reachability we start with.
         NOTE! Labels are allowed inside primitive conditionals!
         So even if the initial condition is 'unreachable',
         the end of a branch can still be reachable!!

         So we must tack, not ctack, the code of the inner
         compound statements, they're NOT blocks.
      *)
      ctack (`AST_ifnotgoto (sr, e, lab1));
      let r1 = ref !reachable in
      iter tack (ms' r1 sts1);
      if !r1 then tack (`AST_goto (sr,lab2));

      (* this is a ctack, because it can only be targetted by prior ifnotgoto *)
      ctack (`AST_label (sr,lab1));
      let r2 = ref !reachable in
      iter tack (ms' r2 sts2);
      if !r1 then tack (`AST_label (sr,lab2));
      reachable := !r1 or !r2
    end


  | `AST_jump (sr, e1, e2) ->
    ctack (`AST_jump (sr, me e1, me e2));
    reachable := false
  
  | `AST_loop (sr, id, e2) ->
    ctack (`AST_loop (sr, mi sr id, me e2));
    reachable := false

  | `AST_fun_return (sr, e)  ->
    ctack (`AST_fun_return (sr, me e));
    reachable := false

  | st -> failwith ("[subst_or_expand] Unhandled case " ^ string_of_statement 0 st)
  end
  ;
  rev !result


(* ---------------------------------------------------------------------
  expand, without defining new macros 
  this routine is used to replace parameters
  in statement macros with already expanded arguments
  prior to expansion, therefore neither the arguments
  nor context in which they're used need any expansion
*)
and subst_statement recursion_limit local_prefix seq reachable macros (st:statement_t):statement_t list = 
  (*
  print_endline ("subst statement " ^ string_of_statement 0 st);
  print_endline ("Macro context length " ^ si (length macros));
  print_endline (string_of_macro_env macros);
  *)
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recurion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let ms ss = subst_statement recursion_limit local_prefix seq (ref true) macros ss in
  let mss ss = subst_statements recursion_limit local_prefix seq (ref true) macros ss in
  let mi sr id = expand_ident sr macros [] id in
  let result = ref [] in
  let tack x = result := x :: !result in
  let ctack x = if !reachable then tack x in

  begin match st with
  | `AST_expr_macro (sr, id, ps, e) ->
    let ps,e = alpha_expr sr local_prefix seq ps e in
    tack (`AST_expr_macro (sr, id, ps, me e))
    
  | `AST_stmt_macro (sr, id, ps, sts) ->
    let ps,sts = alpha_stmts sr local_prefix seq ps sts in
    let sts = expand_statements recursion_limit local_prefix seq (ref true) macros sts in
    tack (`AST_stmt_macro (sr,id,ps,sts))

  | `AST_macro_name (sr, id1, id2) ->
    tack (`AST_macro_name (sr, id1, mi sr id2))

  | `AST_macro_names (sr, id1, id2) ->
    tack (`AST_macro_names (sr, id1, map (mi sr) id2))

  | `AST_macro_val (sr, id, e) ->
    tack (`AST_macro_val (sr, id, me e))

  | `AST_macro_vals (sr, id, e) ->
    tack (`AST_macro_vals (sr, id, map me e))

  | `AST_macro_var (sr, id, e) ->
    tack (`AST_macro_var (sr, id, me e))

  | `AST_macro_assign (sr, id, e) ->
    tack (`AST_macro_assign (sr, id, me e))

  | `AST_macro_ifor (sr,id,ids,sts) ->
    tack (`AST_macro_ifor (sr,id,ids,mss sts))
    
  | `AST_macro_vfor (sr,id,es,sts) ->
    tack (`AST_macro_vfor (sr,id,map me es,mss sts))
  
  (* during parameter replacement,
    we don't know if a call is executable or not,
    so we can't elide it even if unreachable:
    it might expand to declarations or macros
  *)
  | `AST_call (sr, (`AST_name(srn,name,[]) as e1), e2) ->
    (* let e1 = `AST_name(srn, name,[]) in *)
    begin try
      match assoc name macros with
      | MStmt ([],b) ->
        iter tack (mss b)
      | _ -> 
        tack (`AST_call (sr, me e1, me e2))
    with Not_found ->
      tack (`AST_call (sr, me e1, me e2))
    end

  | `AST_call (sr, e1, e2) ->
    tack (`AST_call (sr, me e1, me e2))

  | `AST_user_statement (sr,name,term) -> 
    print_endline "Replacing into user statement call";
    let rec aux term = match term with
      | `Statement_term s -> `Statements_term (ms s)
      | `Statements_term ss -> `Statements_term (mss ss)
      | `Expression_term e -> `Expression_term (me e)
      | `Identifier_term s -> `Identifier_term (mi sr s)

      (* ONLY SUBSTITUTE INTO PARAMETERS? *)
      | `Apply_term (t,ts) -> `Apply_term (t, map aux ts)

      (* invariant -- for the moment *)
      | `Keyword_term _ 
      | `Nonterminal_term _ 
      | `Tokens_term _ -> term
    in 
    tack (`AST_user_statement (sr,name,aux term))


  | `AST_macro_label _
  | `AST_macro_goto _
  | `AST_macro_ifgoto _
  | `AST_macro_proc_return _
  | `AST_macro_forget _
    -> tack st

  | st -> 
    iter tack 
    (
      subst_or_expand subst_statements recursion_limit local_prefix seq reachable macros st
    )
  end
  ;
  rev !result

and subst_statements recursion_limit local_prefix seq reachable macros (ss:statement_t list) =
  concat (map (subst_statement recursion_limit local_prefix seq reachable macros) ss)

(* ---------------------------------------------------------------------
  expand statement : process macros
*)
and expand_statement recursion_limit local_prefix seq reachable ref_macros macros (st:statement_t) = 
  (*
  print_endline ("Expand statement " ^ string_of_statement 0 st);
  print_endline ("Macro context length " ^ si (length macros));
  print_endline (string_of_macro_env macros);
  *)
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recurion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq (!ref_macros @ macros) e in
  let ms ss = expand_statements recursion_limit local_prefix seq (ref true) (!ref_macros @ macros) ss in
  let mi sr id = expand_ident sr (!ref_macros @ macros) [] id in
  let result = ref [] in
  let tack x = result := x :: !result in
  let ctack x = if !reachable then tack x in
  let ses ss =
    special_expand_statements recursion_limit local_prefix seq (ref true) ref_macros macros ss
  in
  let rec expand_names sr (names:string list):string list =
    concat
    ( 
      map
      (fun name ->
        let name = mi sr name in
        let d = 
          try Some (assoc name (!ref_macros @ macros)) 
          with Not_found -> None 
        in
        match d with
        | Some (MNames es) -> expand_names sr es
        | Some (MName x) -> [x]
        | Some(_) -> clierr sr "[expand_names] Name list required"
        | None -> [name]
      )
      names
    )
  in
  let rec expand_exprs sr (exprs: expr_t list):expr_t list =
    (*
    print_endline ("Expand exprs: [" ^ catmap ", " string_of_expr exprs ^ "]");
    *)
    concat
    ( 
      map
      (fun expr -> match expr with
      | `AST_name (sr',name,[]) -> 
        print_endline ("Name " ^ name);
        let name = mi sr name in
        let d = 
          try Some (assoc name (!ref_macros @ macros)) 
          with Not_found -> None 
        in
        begin match d with
        | Some (MNames es) -> 
          expand_exprs sr 
          (map (fun name -> `AST_name (sr,name,[])) es)

        | Some (MName x) ->
          expand_exprs sr [`AST_name(sr,x,[])]

        | Some(MVals xs) -> xs
        | Some(_) -> [expr]
        | None -> [expr]
        end

      | `AST_tuple (sr',xs) -> map me xs
      | x -> [me x]
      )
      exprs 
    )
  in
  begin match st with
  | `AST_macro_forget (sr,ids) ->
    begin 
      match ids with 
      | [] -> ref_macros := []
      | _ -> ref_macros := filter (fun (x,_) -> mem x ids) !ref_macros
    end
    
  | `AST_expr_macro (sr, id, ps, e) ->
    let ps,e = alpha_expr sr local_prefix seq ps e in
    ref_macros := (id,MExpr (ps, e)) :: !ref_macros

  | `AST_macro_val (sr, id, e) ->
    ref_macros := (id,MVal (me e)) :: !ref_macros

  | `AST_macro_vals (sr, id, es) ->
    ref_macros := (id,MVals (map me es)) :: !ref_macros

  | `AST_macro_var (sr, id, e) ->
    ref_macros := (id,MVar (ref (me e))) :: !ref_macros

  | `AST_macro_assign (sr, id, e) ->
    begin 
      try 
        let r = assoc id (!ref_macros @ macros) in
        match r with
        | MVar p -> p := me e
        | _ -> clierr sr "Assignment to wrong kind of macro"
      with Not_found -> clierr sr "Assignment requires macro var"
    end
      
  | `AST_macro_ifor (sr, id, names, sts) ->
    let names = expand_names sr names in
    iter (fun name ->
      let saved_macros = !ref_macros in
      ref_macros := (id,MName name) :: saved_macros;
      iter tack (ms sts);
      ref_macros := saved_macros
    ) names

  | `AST_macro_vfor (sr, id, exprs, sts) ->
    let vals = expand_exprs sr exprs in
    iter (fun expr ->
      let name = me expr in
      let saved_macros = !ref_macros in
      ref_macros := (id,MVal expr) :: saved_macros;
      iter tack (ms sts);
      ref_macros := saved_macros
    ) vals

  | `AST_stmt_macro (sr, id, ps, sts) ->
    let ps,sts = alpha_stmts sr local_prefix seq ps sts in
    ref_macros := (id, MStmt (ps,sts)) :: !ref_macros

  | `AST_macro_name (sr, id1, id2) ->
    let id2 = mi sr id2 in
    let id2 = 
      match id2 with 
      | "" -> 
        let n = !seq in incr seq; 
        "_" ^ local_prefix^ "_" ^ string_of_int n
      | _ -> id2
    in
    ref_macros := (id1,MName id2) :: !ref_macros

  | `AST_macro_names (sr, id, ids) ->
    let ids = map (mi sr) ids in
    ref_macros := (id,MNames ids) :: !ref_macros

  | `AST_call (sr, e1', e2') ->
    let 
      e1 = me e1' and 
      e2 = me e2'
    in
      begin match e1 with
      | `AST_name(srn,name,[]) ->
        begin try 
          match List.assoc name (!ref_macros @ macros) with
          | MName _
            -> failwith ("Unexpected MName " ^ name) 
          | MNames _
            -> failwith ("Unexpected MNames " ^ name) 
          | MVar _
            -> failwith ("Unexpected MVar " ^ name) 
          | MVal _ 
            ->
            failwith 
            (
              "Unexpected MVal " ^ name ^ " expansion\n" ^
              string_of_expr e1' ^ " --> " ^ string_of_expr e1
            )

          | MVals _
            -> 
            failwith 
            (
              "Unexpected MVals " ^ name ^ " expansion\n" ^
              string_of_expr e1' ^ " --> " ^ string_of_expr e1
            )
            

          (* 
            The executable syntax allows the statement

            <atom>;

            to mean

            call <atom> ();

            which means <atom> here must be a procedure
            of type unit->void. The case:

            <atom1> <atom2>;

            however requires <atom1> to be a procedure,
            it can't be a function even if the application

            <atom1> <atom2>

            would return a procedure: the insertion of the
            trailing () is purely syntactic.

            This isn't the case for the macro processor,
            since it does 'type' analysis. We can allow
            <atom1> to be a function which when applied
            to <atom2> returns an expression denoting
            a procedure, and apply it to ().
          *)

          | MExpr (ps,b) ->
            let result = me (`AST_apply (sr,(e1,e2))) in
            let u = `AST_tuple (sr,[]) in
            iter tack (ms [`AST_call(sr,result,u)])

          | MStmt(ps,b) ->
            let args = 
              match e2 with
              | `AST_tuple (_,ls) -> ls
              | x -> [x]
            in
            let np = length ps and na = length args in
            if na = np 
            then 
              begin
                let args= map me args in
                let args = build_args sr ps args in
                let b = subst_statements recursion_limit local_prefix seq reachable args b in
                let b = ses b in
                iter ctack b
              end
            else 
              clierr sr 
              (
                "[expand_expr:call] Statement Macro "^name^
                " requires "^string_of_int np^" arguments," ^
                " got " ^ string_of_int na
              )
        with 
        | Not_found ->
          ctack (`AST_call (sr, e1, e2))
        end

      | _ -> ctack (`AST_call (sr,e1,e2))
      end

  | `AST_user_statement (sr,name,term) ->
    let substitute_statement_terms sr ss ts =
      let args = 
        let rec aux terms res count = 
          let id = "_" ^ si count in 
          match terms with
          | h :: t -> 
            begin match h with
            | `Expression_term  e -> aux t ((id,MVal e)::res) (count+1)
            | `Identifier_term s -> aux t ((id,MName s)::res) (count+1)
            | `Statement_term s -> aux t ((id,MStmt ([],[s]))::res) (count+1)
            | `Statements_term ss -> aux t ((id,MStmt ([],ss))::res) (count+1)
            | `Keyword_term _ ->
              print_endline ("[substitute statement terms] Keyword arg dropped " ^ id);
              aux t res (count+1)
            | `Nonterminal_term _ ->
              print_endline ("[substitute statement terms] Nonterminal arg dropped " ^ id);
              print_endline (string_of_ast_term 1 h);
              aux t res (count+1)
            | `Tokens_term _ ->
              print_endline ("[substitute statement terms] Tokens arg dropped " ^ id);
              aux t res (count+1)
            | `Apply_term _ ->
              print_endline ("[substitute statement terms] Apply arg dropped " ^ id);
              aux t res (count+1)
            end
          | [] -> res
        in aux ts [] 1
      in
      let string_of_statements sts =
        String.concat "\n" (map (string_of_statement 1) sts)
      in

      print_endline "Got arguments ..";
      print_endline (string_of_macro_env args);
      print_endline "WE SHOULD EXPAND THE ARGS BUT AREN'T AT THE MOMENT";
      print_endline ("Body is" ^ string_of_statements ss);
      print_endline "SUBSTITUTING";
      let ss = subst_statements recursion_limit local_prefix seq reachable args ss in
      print_endline ("Body after substitution is" ^ string_of_statements ss);
      print_endline "EXECUTING STATEMENTS NOW";
      let ss = ses ss in
      print_endline ("Body after execution is" ^ string_of_statements ss);
      iter ctack ss
    in
    print_endline ("Expand Statement: Processing user defined statement " ^ name);
    let rec aux term = match term with
      | `Statement_term s -> ctack s
      | `Statements_term ss -> iter ctack ss (* reverse order is correct *)
      | `Expression_term e -> clierr sr ( "User statement: expected statement got expression " ^ string_of_expr e) 
      | `Identifier_term s -> clierr sr ( "User statement: expected statement got identifier " ^ s)
      | `Keyword_term s -> clierr sr ( "User statement: expected statement got keyword " ^ s)
      | `Nonterminal_term _ -> clierr sr ( "User statement: expected statement got nonterminal ")
      | `Tokens_term _ -> clierr sr ( "User statement: expected statement got token sequence ")
      | `Apply_term (t,ts) ->
        begin match t with
        | `Statement_term s -> 
          substitute_statement_terms sr [s] ts

        | `Statements_term ss ->
          substitute_statement_terms sr ss ts

        | _ -> 
          clierr sr 
          (
            "User statement: In application, expected statement "
          )
        end
    in aux term


  | st -> 
    iter tack 
    (
      subst_or_expand expand_statements recursion_limit local_prefix seq reachable (!ref_macros @ macros) st
    )
  end
  ;
  rev !result




and expand_statements recursion_limit local_prefix seq reachable macros (ss:statement_t list) =
  let ref_macros = ref [] in
  special_expand_statements recursion_limit local_prefix seq reachable ref_macros macros ss

and special_expand_statements recursion_limit local_prefix seq reachable ref_macros macros ss =
  if ss = [] then []
  else
  let sr = 
    rsrange
    (src_of_stmt (List.hd ss))
    (src_of_stmt (Flx_util.list_last ss)) 
  in

  let expansion = ref [] in
  let tack x = expansion := x :: !expansion in
  let tacks xs = iter tack xs in
  let pc = ref 0 in
  let label_map = Hashtbl.create 23 in
  let count = 
    fold_left
    (fun count x -> 
      match x with 
      | `AST_macro_label (sr,s) -> Hashtbl.add label_map s (sr,count+1) ; count
      | _ -> count+1
    )
    0
    ss
  in
  let program = 
    Array.of_list 
    (
      filter 
      (function | `AST_macro_label _ -> false | _ -> true)
      ss
    )
  in
  try
    for i = 1 to 100000 do
      begin match program.(!pc) with
      | `AST_macro_goto (sr,label) -> 
        begin 
          try 
            pc := snd (Hashtbl.find label_map label)
          with 
          | Not_found -> 
            clierr sr "Undefined macro label"
        end

      | `AST_macro_proc_return _ -> raise Macro_return

      | `AST_macro_ifgoto (sr,e,label) ->
        let result = 
          expand_expr 
            recursion_limit 
            local_prefix 
            seq 
            (!ref_macros @ macros) 
            e
        in
          begin match truthof result with
          | Some false -> incr pc
          | Some true ->
            begin 
              try 
                pc := snd (Hashtbl.find label_map label)
              with
              | Not_found -> 
                clierr sr "Undefined macro label"
            end

          | None ->
            clierr sr "Constant expression required"
          end

      | st ->
         let sts =
           expand_statement 
             recursion_limit 
             local_prefix 
             seq 
             reachable 
             ref_macros 
             macros
             st
         in
           tacks sts;
           incr pc
      end
      ;
      if !pc = count then raise Macro_return
    done;
    clierr sr "macro execution step limit exceeded"
  with 
    Macro_return -> rev !expansion

and expand_macros local_prefix recursion_limit ss = 
  expand_statements recursion_limit local_prefix (ref 1) (ref true) [] ss


let expand_expression local_prefix e =
  let seq = ref 1 in
  expand_expr 20 local_prefix seq [] e

@h = tangler("src/flxm.ml")
@select(h)
open Flx_util
open Flx_macro
open Flx_print
open Flx_ast
open Flx_getopt
open Flx_version
open Flx_flxopt
open Flx_types
open Flx_mtypes1
open Flx_mtypes2

let print_help () = print_options(); exit(0)
;;
let reverse_return_parity = ref false
;;
try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  print_endline "//----------------------------";
  print_endline "//IMPLEMENTATION EXPANDED:";

  let local_prefix = module_name in
  let expanded = expand_macros local_prefix 5000 parse_tree in
  print_endline (Flx_print.string_of_compilation_unit expanded);
  print_endline "//----------------------------";

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

