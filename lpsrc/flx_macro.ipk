@head(1,'Macro Expansion')
@head(2,'Notes')
Felix macros have 3 flavours:
@begin_table('keyword','kind','subst')
@table_row('ident','name','exe expr+dcl')
@table_row('fun','expr','exe expr')
@table_row('proc','statement','exe stmt')
@end_table()
@p()
Name macros allow renaming of functions, procedures,
values, consts, variables, the body must be an identifier
or the keyword new.
Expression macros replace applications in expressions.
Statement macros replace call statement.
@p()
Macros are expanded by evaluating the arguments if any,
substituting the arguments into the body,
and then evaluating the body.
@p()
Evaluation is by recursive descent with rescanning.
@p()
Note: name macros replace names in executable code,
including macro bodies, but they cannot be used
to rename macros.

@head(2,'Implementation')
@h = tangler('src/flx_macro.mli')
@select(h)
open Flx_ast
val expand_macros:
  string -> 
  int -> 
  statement_t list -> 
  statement_t list

@h = tangler('src/flx_macro.ml')
@select(h)
open Flx_ast
open Flx_print
open Flx_exceptions
open List
open Flx_constfld
open Flx_srcref

exception Macro_return

let truthof x = match x with
  | `AST_typed_case (_,1,`TYP_sum [`TYP_tuple[]; `TYP_tuple[]]) -> Some false
  | `AST_typed_case (_,2,`TYP_sum [`TYP_tuple[]; `TYP_tuple[]]) -> Some true
  | _ -> None

(* 
 There are no type macros: use typedef facility.
 There are no regexp macros: use regdef facility.
*)

type macro_t = 
 | MVar of expr_t ref
 | MVal of expr_t 
 | MExpr of macro_parameter_t list * expr_t 
 | MStmt of macro_parameter_t list * statement_t list
 | MName of id_t

type macro_dfn_t = id_t * macro_t

let print_mpar (id,t) = 
  id ^ ":" ^ 
  (
    match t with 
    | Expr -> "fun"
    | Stmt -> "proc"
    | Ident -> "ident"
  )

let print_mpars x = 
  "(" ^ String.concat ", " (map print_mpar x) ^ ")"

let print_macro (id,t) = 
 match t with
 | MVar v -> "MVar " ^ id ^ " = " ^ string_of_expr !v
 | MVal v -> "Mval " ^ id ^ " = " ^ string_of_expr v
 | MExpr (ps,e) -> 
   "MExpr " ^ id ^ 
   print_mpars ps ^ 
   " = " ^ 
   string_of_expr e
   
 | MStmt (ps,sts) -> 
   "MStmt " ^ id ^ 
   print_mpars ps ^ 
   " = " ^ 
   String.concat "\n" (map (string_of_statement 1) sts)

 | MName id -> "MName " ^ id ^ " = " ^ id

let string_of_macro_env x = String.concat "\n" (map print_macro x)

(* ident expansion: guarranteed to terminate,
  expansion of x given x -> x is just x
*)
let rec expand_ident sr macros noexpand id =
  try 
    if mem id noexpand then id else
    match assoc id macros with
    | MName id2 -> expand_ident sr macros (id::noexpand) id2
    | _ -> id 
  with Not_found -> id
 
(* Find variable names in patterns so as to protect them *)
let rec get_pattern_vars pat =
  match pat with
  | `PAT_name (_,v) -> [v]
  | `PAT_as (_,p,v) -> v :: get_pattern_vars p
  | `PAT_when (_,p,_) -> get_pattern_vars p
  | `PAT_nonconst_ctor (_,_,p) -> get_pattern_vars p
  | `PAT_tuple (_,ps) -> concat (map get_pattern_vars ps)
  | _ -> []
  
(* protect parameter names, to prevent gratuitous substitions *)
let protect sr (ps:id_t list) : macro_dfn_t list =
  let rec aux t macs = 
    match t with
    | [] -> macs 
    | h :: t -> 
      let mac = h, MVal (`AST_noexpand (sr,`AST_name (sr,h,[]))) in
      aux t (mac::macs)
  in 
    aux ps []

let build_args sr ps args =
  map2
  (fun (p,t) a ->
    match t with
    | Ident -> 
      begin match a with
      | `AST_name (_,name,[]) -> (p,MName name)
      | _ -> 
        clierr sr 
        (
          "[build_args] Wrong argument type, expected Identifier, got:\n" ^ 
          string_of_expr a
        )
      end

    | Expr -> (p,MVal a)
    | Stmt ->
      begin match a with
      | `AST_lambda (_,([],`TYP_none,sts)) -> (p,MStmt ([],sts))
      | `AST_name(_,name,[]) ->(p,MVal a)
      | _ -> 
        clierr sr 
        (
          "[build_args] Wrong argument type, expected {} enclosed statement list or macro procedure name, got\n" ^
          string_of_expr a
        )
      end
  )
  ps args

(* alpha convert parameter names *)
let rec alpha_expr sr local_prefix seq ps e =
  let psn, pst = split ps in
  let psn' =  (* new parameter names *)
    map 
    (fun _ -> let b = !seq in incr seq; "_" ^ string_of_int b) 
    psn
  in
  let remap = 
    map2
    (fun x y -> (x,MName y))
    psn psn'
  in
    let e = expand_expr 50 local_prefix seq remap e in
    let ps = combine psn' pst in
    ps,e

and alpha_stmts sr local_prefix seq ps sts =
  let psn, pst = split ps in
  let psn' =  (* new parameter names *)
    map 
    (fun _ -> let b = !seq in incr seq; "_" ^ local_prefix ^ "_" ^ string_of_int b) 
    psn
  in
  let remap = 
    map2
    (fun x y -> (x,MName y))
    psn psn'
  in
    let sts = subst_statements 50 local_prefix seq (ref true) remap sts in
    let ps = combine psn' pst in
    ps,sts
  
(* expand expression *)
and expand_expr recursion_limit local_prefix seq (macros:macro_dfn_t list) (e:expr_t):expr_t =
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recursion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let mi sr i = expand_ident sr macros [] i in
  let cf e = const_fold e in
  let e = cf e in
  match e with

  (* Expansion block: don't even fold constants *)
  | `AST_noexpand _ -> e 

  (* Sum desugaring: x+y+z+ ... *)
  | `AST_sum (sr, es) ->  
    begin match es with
    | [] -> failwith "Unexpected empty addition"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"add",[]),
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end
        
  (* Product desugaring: x*y*z* ... *)
  | `AST_product (sr, es) ->
    begin match es with
    | [] -> failwith "Unexpected empty multiply"
    | h::t ->
      List.fold_left
      (fun x y ->
        me 
        (
          `AST_apply
          (
            sr,
            (
              `AST_name ( sr,"mul",[]), 
              `AST_tuple (sr,[me x; me y])
            )
          )
        )
      )
      h t
    end
 
  (* Name expansion *)
  | `AST_name (sr, name,[]) ->
    begin try 
      match List.assoc name macros with
      | MVar b -> me !b
      | MVal b -> me b
      | MExpr(ps,b) -> e
      | MName _ -> `AST_name (sr,mi sr name,[])
      | MStmt (ps,b) -> e
    with 
    | Not_found -> e
    end

  | `AST_name (sr, name,ts) -> 
    begin try 
      match List.assoc name macros with
      | MName _ -> `AST_name (sr,mi sr name,ts)
      | _ -> e
    with 
    | Not_found -> e
    end

   (* Name application *)
   (* NOTE: Felix doesn't support shortcut applications
      for executable expressions, however these
      ARE available for macro expansion: this is in
      fact completely basic: the expression
        id
      is indeed expanded and is of course
      equivalent to
        id ()
   *)
   | `AST_apply (sr, (e1', e2')) -> 
    let 
      e1 = me e1' and 
      e2 = me e2' 
    in
      begin match e1 with
      | `AST_name(srn,name,[]) ->
        begin try 
          match List.assoc name macros with
          | MName _ 
          | MVar _ 
          | MVal _ -> assert false

          | MExpr(ps,b) ->
            let args = 
              match e2 with
              | `AST_tuple (_,ls) -> ls
              | x -> [x]
            in
            let np = length ps and na = length args in
            if na = np 
            then
              begin
                let args = map me args in
                let args = build_args sr ps args in
                let b = expand_expr recursion_limit local_prefix (ref 0) args b in
                me b
              end
            else 
              clierr sr 
              (
                "[expand_expr:apply] In application:\n" ^
                "  fun = " ^string_of_expr e1'^" --> "^string_of_expr e1^"\n"^
                "  arg = " ^string_of_expr e2'^" --> "^string_of_expr e2^"\n"^
                "Macro "^name^
                " requires "^string_of_int np^" arguments," ^
                " got " ^ string_of_int na
              )
          | MStmt (ps,b) ->
            (* replace the application with a lambda wrapping
              of the corresponding procedure call
            *)
            let sts = [`AST_call (sr,e1, e2)] in
            let sts = expand_statements recursion_limit local_prefix seq (ref true) macros sts in
            `AST_lambda(sr,([],`TYP_none,sts))
            (*
            clierr sr 
            (
              "[expand_expr:apply] In application:\n" ^
              "  fun = " ^string_of_expr e1'^" --> "^string_of_expr e1^"\n"^
              "  arg = " ^string_of_expr e2'^" --> "^string_of_expr e2^"\n"^
              "Macro "^name^
              " is a procedure macro" 
            )
            *)
        with 
        | Not_found ->
          cf (`AST_apply(sr,(e1, e2)))
        end
      | _ ->
        `AST_apply(sr,(e1, e2))
      end

  | `AST_cond (sr, (e1, e2, e3)) -> 
    let cond = me e1 in
    begin match cond with
    | `AST_typed_case (_,c,`TYP_sum [`TYP_tuple[]; `TYP_tuple[]]) ->
      if c=2 then me e2 else me e3
    | _ ->
      `AST_cond (sr,(cond,me e2,me e3))
    end

  | `AST_expr (sr,s,t) -> `AST_expr (sr,s,t)

  (* Lambda hook *)
  | `AST_lambda (sr, (ps, t, sts)) -> 
    let pr = map fst ps in
    let pr = protect sr pr in
    let sts = expand_statements recursion_limit local_prefix seq (ref true) (pr @ macros) sts in
    `AST_lambda (sr, (ps, t, sts))

  (* Name lookup *)
  | `AST_lookup (sr, (e1, name,ts)) -> `AST_lookup (sr,(me e1, mi sr name,ts))

  | `AST_case_tag (sr, i) -> e
  | `AST_typed_case (sr, i, t) -> e
  | `AST_bound_module _ -> failwith "Unexpected bound module"


  | `AST_tuple (sr, es) -> `AST_tuple (sr, map me es)
  | `AST_coercion (sr, (e1, t)) -> `AST_coercion (sr, (me e1,t)) 
  | `AST_suffix (sr, (qn, t)) -> 
    let qn = Flx_typing.qualified_name_of_expr (me (qn:>expr_t)) in
    `AST_suffix (sr, (qn,t)) 

  | `AST_void sr -> e
  | `AST_arrow (sr, (e1, e2)) ->  `AST_arrow (sr,(me e1, me e2))

  | `AST_literal (sr, literal) ->  e
  | `AST_deref (sr, e1) -> `AST_deref (sr, me e1)
  | `AST_ref (sr, e1) ->  `AST_ref (sr, me e1)
  | `AST_method_apply (sr, (id, e1)) -> `AST_method_apply (sr,(mi sr id, me e1))
  | `AST_dot (sr, (e1, id)) ->  `AST_dot (sr,(me e1,mi sr id))
  | `AST_match_ctor (sr, (qn, e1)) -> `AST_match_ctor (sr,(qn,me e1))
  | `AST_match_case (sr, (i, e1)) ->  `AST_match_case (sr,(i, me e1))
  | `AST_ctor_arg (sr, (qn, e1)) -> `AST_ctor_arg (sr,(qn, me e1))
  | `AST_case_arg (sr, (i, e1)) ->  `AST_case_arg (sr,(i,me e1))
  | `AST_letin (sr, (pat, e1, e2)) -> `AST_letin (sr, (pat, me e1, me e2))

  | `AST_get_n (sr, (i, e1)) ->  `AST_get_n (sr,(i,me e1))
  | `AST_as (sr, (e1, id)) ->  `AST_as (sr,(me e1, mi sr id))

  | `AST_match (sr, (e1, pes)) -> 
    let pes = 
      map 
      (fun (pat,e) -> 
        pat, 
        let pvs = get_pattern_vars pat in
        let pr = protect sr pvs in
        expand_expr recursion_limit local_prefix seq (pr @ macros) e
      ) 
      pes 
    in
    `AST_match (sr,(me e1, pes))
    
  | `AST_regmatch (sr, (e1, res)) -> 
    let res = map (fun (rexp,e) -> rexp, me e) res in
    `AST_regmatch (sr,(me e1, res))

  | `AST_reglex (sr, (e1, e2, res)) -> 
    let res = map (fun (rexp,e) -> rexp, me e) res in
    `AST_reglex (sr,(me e1, me e2, res))

  | `AST_typeof (sr, e1) -> `AST_typeof(sr, me e1)

(* ---------------------------------------------------------------------
  do the common work of both subst_statement and expand_statement,
  recursion to the appropriate one as indicated by the argument 'recurse'
*)
and subst_or_expand recurse recursion_limit local_prefix seq reachable macros (st:statement_t):statement_t list = 
  let recurion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let ms ss = recurse recursion_limit local_prefix seq (ref true) macros ss in
  let msp sr ps ss = 
    let pr = protect sr ps in
    recurse recursion_limit local_prefix seq (ref true) (pr @ macros) ss 
  in
  let mi sr id = expand_ident sr macros [] id in
  let result = ref [] in
  let tack x = result := x :: !result in
  let ctack x = if !reachable then tack x in

  begin match st with
  | `AST_include (sr, s) -> tack st

  (* FIX TO SUPPORT IDENTIFIER RENAMING *)
  | `AST_open (sr, qn) -> tack st

  (* FIX TO SUPPORT IDENTIFIER RENAMING *)
  | `AST_use (sr, id, qn) -> tack (`AST_use (sr,mi sr id,qn))

  | `AST_assign (sr,name,l,r) ->
    tack (`AST_assign (sr, name, me l, me r))

  | `AST_comment _  ->  tack st

  (* IDENTIFIER RENAMING NOT SUPPORTED IN REGDEF *)
  | `AST_regdef (sr, id, re)  ->  tack st

  | `AST_union (sr, id, vs, idts ) ->  tack (`AST_union (sr, mi sr id, vs, idts))
  | `AST_struct (sr, id, vs, idts) ->  tack (`AST_struct (sr, mi sr id, vs, idts))

  (* IDENTIFIER RENAMING NOT SUPPORTED IN TYPES *)
  | `AST_type_alias (sr, id, vs, t) ->  tack st

  | `AST_abs_decl (sr, id, vs, c) ->  tack st
  | `AST_const_decl (sr, id, vs, t, c) -> 
     tack (`AST_const_decl (sr, mi sr id, vs, t, c))
    
  | `AST_fun_decl (sr, id, vs, ts, t, c) -> 
     tack (`AST_fun_decl (sr, mi sr id, vs, ts, t, c))
    
  | `AST_header (sr, s) ->  tack st
  | `AST_body (sr, s) ->  tack st

    (* 
      NOTE: c code is embedded even  though it isn't
      reachable because it might contain declarations or 
      even labels
    *)
  | `AST_code (sr, s) ->  
    tack st; 
    reachable := true

  | `AST_noreturn_code (sr, s) ->  
    tack st;
    reachable := false

  (* IDENTIFIER RENAMING NOT SUPPORTED IN EXPORT *)
  | `AST_export (sr, sn, s) ->  tack st

  (* IDENTIFIER RENAMING NOT SUPPORTED IN TYPES *)
  | `AST_type (sr, id, vs)  ->  tack st

  | `AST_function_decl (sr, id, vs, t) ->  
    tack (`AST_function_decl (sr,mi sr id, vs, t))

  | `AST_label (sr, id) ->  
    reachable:=true; 
    tack (`AST_label (sr, mi sr id))

  | `AST_goto (sr, id) ->  
    ctack (`AST_goto (sr, mi sr id)); 
    reachable := false

  | `AST_read (sr, id) ->  ctack (`AST_read (sr, mi sr id))
  | `AST_proc_return (sr)  ->  ctack st; reachable := false
  | `AST_nop (sr, s) ->  ()

  | `AST_function (sr, id, vs, ps, t, sts ) ->
    let pr = map fst ps in
    tack(`AST_function (sr, mi sr id, vs, ps, t, msp sr pr sts ))

  | `AST_curry (sr,id,vs,pss,ret,kind,sts) ->
    let pr = map fst (concat pss) in
    tack(`AST_curry(sr, mi sr id, vs, pss, ret,kind, msp sr pr sts ))

  | `AST_object (sr, id, vs, ps, sts ) ->
    let pr = map fst ps in
    tack(`AST_object (sr, mi sr id, vs, ps, msp sr pr sts ))

  | `AST_val_decl (sr, id, vs, optt, opte) -> 
    let opte = match opte with
    | Some x -> Some (me x)
        (* 
          this *will be* an error if unreachable,
          provided the containing function is used
        *)
    | None -> None
        (* this is actually a syntax error in a module,
          but not in an interface: unfortunately,
          we can't tell the difference here
        *)
    in
      tack (`AST_val_decl (sr, mi sr id, vs, optt, opte))

  | `AST_var_decl (sr, id, vs, optt, opte) -> 
    let opte = 
      match opte with
      | Some x -> Some (me x)
        (* unreachable var initialisations are legal *)

      | None -> None 
        (* vars don't have to be initialised *)
    in
      tack (`AST_var_decl (sr, mi sr id, vs, optt, opte))
  
  | `AST_untyped_module (sr, id, vs, sts) ->
    tack (`AST_untyped_module (sr, mi sr id, vs, ms sts))

  | `AST_typed_module (sr, id, vs, t, sts) ->
    tack (`AST_typed_module (sr, mi sr id, vs, t, ms sts))

  | `AST_module_binding (sr, id, vs, e) ->
    tack (`AST_module_binding (sr, mi sr id, vs, me e))

  | `AST_typed_functor (sr, id, vs, ps, t, sts) ->
    tack (`AST_typed_functor (sr, mi sr id, vs, ps, t, ms sts))

  | `AST_untyped_functor (sr, id, vs, ps, sts) ->
    tack (`AST_untyped_functor (sr, mi sr id, vs, ps, ms sts))

  | `AST_interface (sr, id, vs, sts) ->
    tack (`AST_interface (sr, mi sr id, vs, ms sts))
  
  | `AST_ifgoto (sr, e , id) -> 
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_sum [`TYP_tuple[]; `TYP_tuple[]]) ->
      if c = 2 then 
      ( 
        ctack (`AST_goto (sr,id));
        reachable := false
      )
    | _ ->
      ctack (`AST_ifgoto (sr, me e, mi sr id))
    end

  | `AST_ifnotgoto (sr, e, id) -> 
    let e = me e in
    begin match e with
    | `AST_typed_case (_,c,`TYP_sum [`TYP_tuple[]; `TYP_tuple[]]) ->
      if c = 1 then 
      (
        ctack (`AST_goto (sr,id)); 
        reachable := false
      )
    | _ ->
      ctack (`AST_ifnotgoto (sr, me e, mi sr id))
    end

  | `AST_jump (sr, e1, e2) ->
    ctack (`AST_jump (sr, me e1, me e2));
    reachable := false
  
  | `AST_loop (sr, id, e2) ->
    ctack (`AST_loop (sr, mi sr id, me e2));
    reachable := false

  | `AST_fun_return (sr, e)  ->
    ctack (`AST_fun_return (sr, me e));
    reachable := false

  | st -> failwith ("[subst_or_expand] Unhandled case " ^ string_of_statement 0 st)
  end
  ;
  rev !result


(* ---------------------------------------------------------------------
  expand, without defining new macros 
  this routine is used to replace parameters
  in statement macros with already expanded arguments
  prior to expansion, therefore neither the arguments
  nor context in which they're used need any expansion
*)
and subst_statement recursion_limit local_prefix seq reachable macros (st:statement_t):statement_t list = 
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recurion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq macros e in
  let ms ss = subst_statements recursion_limit local_prefix seq (ref true) macros ss in
  let mi sr id = expand_ident sr macros [] id in
  let result = ref [] in
  let tack x = result := x :: !result in
  let ctack x = if !reachable then tack x in

  begin match st with
  | `AST_expr_macro (sr, id, ps, e) ->
    let ps,e = alpha_expr sr local_prefix seq ps e in
    tack (`AST_expr_macro (sr, id, ps, me e))
    
  | `AST_stmt_macro (sr, id, ps, sts) ->
    let ps,sts = alpha_stmts sr local_prefix seq ps sts in
    let sts = expand_statements recursion_limit local_prefix seq (ref true) macros sts in
    tack (`AST_stmt_macro (sr,id,ps,sts))

  | `AST_name_macro (sr, id1, id2) ->
    tack (`AST_name_macro (sr, id1, mi sr id2))

  | `AST_macro_val (sr, id, e) ->
    tack (`AST_macro_val (sr, id, me e))

  | `AST_macro_var (sr, id, e) ->
    tack (`AST_macro_var (sr, id, me e))

  | `AST_macro_assign (sr, id, e) ->
    tack (`AST_macro_assign (sr, id, me e))

  (* during parameter replacement,
    we don't know if a call is executable or not,
    so we can't elide it even if unreachable:
    it might expand to declarations or macros
  *)
  | `AST_call (sr, `AST_name(srn,name,[]), e2) ->
    let e1 = `AST_name(srn, name,[]) in
    begin try
      match assoc name macros with
      | MStmt ([],b) ->
        iter tack (ms b)
      | _ -> 
        tack (`AST_call (sr, me e1, me e2))
    with Not_found ->
      tack (`AST_call (sr, me e1, me e2))
    end

  | `AST_call (sr, e1, e2) ->
    tack (`AST_call (sr, me e1, me e2))

  | `AST_macro_label _
  | `AST_macro_goto _
  | `AST_macro_ifgoto _
  | `AST_macro_proc_return _
  | `AST_macro_forget _
    -> tack st

  | st -> 
    iter tack 
    (
      subst_or_expand subst_statements recursion_limit local_prefix seq reachable macros st
    )
  end
  ;
  rev !result

and subst_statements recursion_limit local_prefix seq reachable macros (ss:statement_t list) =
  concat (map (subst_statement recursion_limit local_prefix seq reachable macros) ss)

(* ---------------------------------------------------------------------
  expand statement : process macros
*)
and expand_statement recursion_limit local_prefix seq reachable ref_macros macros (st:statement_t) = 
  if recursion_limit < 1 
  then failwith "Recursion limit exceeded expanding macros";
  let recurion_limit = recursion_limit - 1 in
  let me e = expand_expr recursion_limit local_prefix seq (!ref_macros @ macros) e in
  let ms ss = expand_statements recursion_limit local_prefix seq (ref true) (!ref_macros @ macros) ss in
  let mi sr id = expand_ident sr (!ref_macros @ macros) [] id in
  let result = ref [] in
  let tack x = result := x :: !result in
  let ctack x = if !reachable then tack x in
  let ses ss =
    special_expand_statements recursion_limit local_prefix seq (ref true) ref_macros macros ss
  in
  begin match st with
  | `AST_macro_forget (sr,ids) ->
    begin 
      match ids with 
      | [] -> ref_macros := []
      | _ -> ref_macros := filter (fun (x,_) -> mem x ids) !ref_macros
    end
    
  | `AST_expr_macro (sr, id, ps, e) ->
    let ps,e = alpha_expr sr local_prefix seq ps e in
    ref_macros := (id,MExpr (ps, e)) :: !ref_macros

  | `AST_macro_val (sr, id, e) ->
    ref_macros := (id,MVal (me e)) :: !ref_macros

  | `AST_macro_var (sr, id, e) ->
    ref_macros := (id,MVar (ref (me e))) :: !ref_macros

  | `AST_macro_assign (sr, id, e) ->
    begin 
      try 
        let r = assoc id (!ref_macros @ macros) in
        match r with
        | MVar p -> p := me e
        | _ -> clierr sr "Assignment to wrong kind of macro"
      with Not_found -> clierr sr "Assignment requires macro var"
    end
      
  | `AST_stmt_macro (sr, id, ps, sts) ->
    let ps,sts = alpha_stmts sr local_prefix seq ps sts in
    ref_macros := (id, MStmt (ps,sts)) :: !ref_macros

  | `AST_name_macro (sr, id1, id2) ->
    let id2 = mi sr id2 in
    let id2 = 
      match id2 with 
      | "" -> 
        let n = !seq in 
        incr seq; 
        "_" ^ local_prefix^ "_" ^ string_of_int n
      | _ -> id2
    in
    ref_macros := (id1,MName id2) :: !ref_macros

  | `AST_call (sr, e1', e2') ->
    let 
      e1 = me e1' and 
      e2 = me e2'
    in
      begin match e1 with
      | `AST_name(srn,name,[]) ->
        begin try 
          match List.assoc name (!ref_macros @ macros) with
          | MName _
            -> failwith ("Unexpected MName " ^ name) 
          | MVar _
            -> failwith ("Unexpected MVar " ^ name) 
          | MVal _
            -> 
            failwith 
            (
              "Unexpected MVal " ^ name ^ " expansion\n" ^
              string_of_expr e1' ^ " --> " ^ string_of_expr e1
            )
            

          (* 
            The executable syntax allows the statement

            <atom>;

            to mean

            call <atom> ();

            which means <atom> here must be a procedure
            of type unit->void. The case:

            <atom1> <atom2>;

            however requires <atom1> to be a procedure,
            it can't be a function even if the application

            <atom1> <atom2>

            would return a procedure: the insertion of the
            trailing () is purely syntactic.

            This isn't the case for the macro processor,
            since it does 'type' analysis. We can allow
            <atom1> to be a function which when applied
            to <atom2> returns an expression denoting
            a procedure, and apply it to ().
          *)

          | MExpr (ps,b) ->
            let result = me (`AST_apply (sr,(e1,e2))) in
            let u = `AST_tuple (sr,[]) in
            iter tack (ms [`AST_call(sr,result,u)])

          | MStmt(ps,b) ->
            let args = 
              match e2 with
              | `AST_tuple (_,ls) -> ls
              | x -> [x]
            in
            let np = length ps and na = length args in
            if na = np 
            then 
              begin
                let args= map me args in
                let args = build_args sr ps args in
                let b = subst_statements recursion_limit local_prefix seq reachable args b in
                let b = ses b in
                iter ctack b
              end
            else 
              clierr sr 
              (
                "[expand_expr:call] Statement Macro "^name^
                " requires "^string_of_int np^" arguments," ^
                " got " ^ string_of_int na
              )
        with 
        | Not_found ->
          ctack (`AST_call (sr, e1, e2))
        end

      | _ -> ctack (`AST_call (sr,e1,e2))
      end

  | st -> 
    iter tack 
    (
      subst_or_expand expand_statements recursion_limit local_prefix seq reachable (!ref_macros @ macros) st
    )
  end
  ;
  rev !result




and expand_statements recursion_limit local_prefix seq reachable macros (ss:statement_t list) =
  let ref_macros = ref [] in
  special_expand_statements recursion_limit local_prefix seq reachable ref_macros macros ss

and special_expand_statements recursion_limit local_prefix seq reachable ref_macros macros ss =
  if ss = [] then []
  else
  let sr = 
    rsrange
    (src_of_stmt (List.hd ss))
    (src_of_stmt (Flx_util.list_last ss)) 
  in

  let expansion = ref [] in
  let tack x = expansion := x :: !expansion in
  let tacks xs = iter tack xs in
  let pc = ref 0 in
  let label_map = Hashtbl.create 23 in
  let count = 
    fold_left
    (fun count x -> 
      match x with 
      | `AST_macro_label (sr,s) -> Hashtbl.add label_map s (sr,count+1) ; count
      | _ -> count+1
    )
    0
    ss
  in
  let program = 
    Array.of_list 
    (
      filter 
      (function | `AST_macro_label _ -> false | _ -> true)
      ss
    )
  in
  try
    for i = 1 to 10000 do
      begin match program.(!pc) with
      | `AST_macro_goto (sr,label) -> 
        begin 
          try 
            pc := snd (Hashtbl.find label_map label)
          with 
          | Not_found -> 
            clierr sr "Undefined macro label"
        end

      | `AST_macro_proc_return _ -> raise Macro_return

      | `AST_macro_ifgoto (sr,e,label) ->
        let result = 
          expand_expr 
            recursion_limit 
            local_prefix 
            seq 
            (!ref_macros @ macros) 
            e
        in
          begin match truthof result with
          | Some false -> incr pc
          | Some true ->
            begin 
              try 
                pc := snd (Hashtbl.find label_map label)
              with
              | Not_found -> 
                clierr sr "Undefined macro label"
            end

          | None ->
            clierr sr "Constant expression required"
          end

      | st ->
         let sts =
           expand_statement 
             recursion_limit 
             local_prefix 
             seq 
             reachable 
             ref_macros 
             macros
             st
         in
           tacks sts;
           incr pc
      end
      ;
      if !pc = count then raise Macro_return
    done;
    clierr sr "macro execution step limit exceeded"
  with 
    Macro_return -> rev !expansion

and expand_macros local_prefix recursion_limit ss = 
  expand_statements recursion_limit local_prefix (ref 1) (ref true) [] ss

@h = tangler("src/flxm.ml")
@select(h)
open Flx_util
open Flx_macro
open Flx_print
open Flx_ast
open Flx_getopt
open Flx_version
open Flx_flxopt
open Flx_types

let print_help () = print_options(); exit(0)
;;
let reverse_return_parity = ref false
;;
try
  let argc = Array.length Sys.argv in
  if argc <= 1 
  then begin
    print_endline "usage: flxg --key=value ... filename; -h for help";
    exit 0
  end
  ;
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  reverse_return_parity := compiler_options.reverse_return_parity
  ;
  let syms = make_syms compiler_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;
  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" 
  and iface_file_name = filebase ^ ".fix"
  and module_name = 
    let n = String.length filebase in 
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in

  (* PARSE THE IMPLEMENTATION FILE *)
  print_endline ("//Parsing Implementation " ^ input_file_name);
  let parse_tree =
    Flx_parse_ctrl.parse_file 
      input_file_name 
      (Filename.dirname input_file_name)
      compiler_options.include_dirs 
  in
  print_endline (Flx_print.string_of_compilation_unit parse_tree);
  print_endline "//PARSE OK";

  print_endline "//----------------------------";
  print_endline "//IMPLEMENTATION EXPANDED:";

  let local_prefix = module_name in
  let expanded = expand_macros local_prefix 5000 parse_tree in
  print_endline (Flx_print.string_of_compilation_unit expanded);
  print_endline "//----------------------------";

with x -> Flx_terminate.terminate !reverse_return_parity x
;;

