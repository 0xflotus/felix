@head(1,'Cil package')
The copyright following applies to this sub-package.
@begin_displayed_code()
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)
@end_displayed_code()


@h=tangler('src/flx_cil_escape.ml')
@select(h)
(** OCaml types used to represent wide characters and strings *)
type wchar = int64
type wstring = wchar list


let escape_char = function
  | '\007' -> "\\a"
  | '\b' -> "\\b"
  | '\t' -> "\\t"
  | '\n' -> "\\n"
  | '\011' -> "\\v"
  | '\012' -> "\\f"
  | '\r' -> "\\r"
  | '"' -> "\\\""
  | '\'' -> "\\'"
  | '\\' -> "\\\\"
  | ' ' .. '~' as printable -> String.make 1 printable
  | unprintable -> Printf.sprintf "\\%03o" (Char.code unprintable)

let escape_string str =
  let length = String.length str in
  let buffer = Buffer.create length in
  for index = 0 to length - 1 do
    Buffer.add_string buffer (escape_char (String.get str index))
  done;
  Buffer.contents buffer

(* a wide char represented as an int64 *)
let escape_wchar =
  (* limit checks whether upper > probe *)
  let limit upper probe = (Int64.to_float (Int64.sub upper probe)) > 0.5 in
  let fits_byte = limit (Int64.of_int 0x100) in
  let fits_octal_escape = limit (Int64.of_int 0o1000) in
  let fits_universal_4 = limit (Int64.of_int 0x10000) in
  let fits_universal_8 = limit (Int64.of_string "0x100000000") in
  fun charcode ->
    if fits_byte charcode then
      escape_char (Char.chr (Int64.to_int charcode))
    else if fits_octal_escape charcode then
      Printf.sprintf "\\%03Lo" charcode
    else if fits_universal_4 charcode then
      Printf.sprintf "\\u%04Lx" charcode
    else if fits_universal_8 charcode then
      Printf.sprintf "\\u%04Lx" charcode
    else
      invalid_arg "Flx_cil_cprint.escape_string_intlist"

(* a wide string represented as a list of int64s *)
let escape_wstring (str : int64 list) =
  let length = List.length str in
  let buffer = Buffer.create length in
  let append charcode =
    let addition = escape_wchar charcode in
    Buffer.add_string buffer addition
  in
  List.iter append str;
  Buffer.contents buffer

@h=tangler('src/flx_cil_escape.mli')
@select(h)
(*
 * Character and string escaping utilities
 *)

(** OCaml types used to represent wide characters and strings *)
type wchar = int64
type wstring = wchar list

(** escape various constructs in accordance with C lexical rules *)
val escape_char : char -> string
val escape_string : string -> string
val escape_wchar : wchar -> string
val escape_wstring : wstring -> string

@h=tangler('src/flx_cil_cabs.mli')
@select(h)

(** This file was originally part of Hugues Casee's frontc 2.0, and has been 
 * extensively changed since. 
**
** 1.0  3.22.99 Hugues Cass√©    First version.
** 2.0  George Necula 12/12/00: Many extensions
 **)

(*
** Types
*)

type cabsloc = {
 lineno : int;
 filename: string;
 byteno: int;

}                                                                     

type lang_t = [`C | `Cxx]

type typeSpecifier = (* Merge all specifiers into one type *)
  | Tvoid                             (* Type specifier ISO 6.7.2 *)
  | Tbool
  | Tchar
  | Tshort
  | Tint
  | Tlong
  | Tint64
  | Tfloat
  | Tdouble
  | Tsigned
  | Tunsigned
  | Tcomplex
  | Timaginary
  | Tnamed of string
  (* each of the following three kinds of specifiers contains a field 
   * or item list iff it corresponds to a definition (as opposed to
   * a forward declaration or simple reference to the type); they
   * also have a list of __attribute__s that appeared between the
   * keyword and the type name (definitions only) *)
  | Tstruct of string * field_group list option * attribute list
  | Tunion of string * field_group list option * attribute list
  | Tenum of string * enum_item list option * attribute list
  | TtypeofE of expression                      (* GCC __typeof__ *)
  | TtypeofT of specifier * decl_type       (* GCC __typeof__ *)

and storage =
    NO_STORAGE | AUTO | STATIC | EXTERN | REGISTER

and funspec = 
    INLINE | VIRTUAL | EXPLICIT

and cvspec =
    CV_CONST | CV_VOLATILE | CV_RESTRICT

(* Type specifier elements. These appear at the start of a declaration *)
(* Everywhere they appear in this file, they appear as a 'spec_elem list', *)
(* which is not interpreted by cabs -- rather, this "word soup" is passed *)
(* on to the compiler.  Thus, we can represent e.g. 'int long float x' even *)
(* though the compiler will of course choke. *)
and spec_elem =
    SpecTypedef          
  | SpecCV of cvspec            (* const/volatile *)
  | SpecAttr of attribute       (* __attribute__ *)
  | SpecStorage of storage
  | SpecInline
  | SpecType of typeSpecifier
  | SpecPattern of string       (* specifier pattern variable *)

(* decided to go ahead and replace 'spec_elem list' with specifier *)
and specifier = spec_elem list


(* Declarator type. They modify the base type given in the specifier. Keep
 * them in the order as they are printed (this means that the top level
 * constructor for ARRAY and PTR is the inner-level in the meaning of the
 * declared type) *)
and decl_type =
 | JUSTBASE                               (* Prints the declared name *)
 | PARENTYPE of attribute list * decl_type * attribute list
                                          (* Prints "(attrs1 decl attrs2)".
                                           * attrs2 are attributes of the
                                           * declared identifier and it is as
                                           * if they appeared at the very end
                                           * of the declarator. attrs1 can
                                           * contain attributes for the
                                           * identifier or attributes for the
                                           * enclosing type.  *)
 | ARRAY of decl_type * attribute list * expression
                                          (* Prints "decl [ attrs exp ]".
                                           * decl is never a PTR. *)
 | PTR of attribute list * decl_type      (* Prints "* attrs decl" *)
 | PROTO of decl_type * single_name list * bool 
                                          (* Prints "decl (args[, ...])".
                                           * decl is never a PTR.*)

(* The base type and the storage are common to all names. Each name might
 * contain type or storage modifiers *)
(* e.g.: int x, y; *)
and name_group = specifier * name list

(* The optional expression is the bitfield *)
and field_group = specifier * (name * expression option) list

(* like name_group, except the declared variables are allowed to have initializers *)
(* e.g.: int x=1, y=2; *)
and init_name_group = specifier * init_name list

(* The decl_type is in the order in which they are printed. Only the name of
 * the declared identifier is pulled out. The attributes are those that are
 * printed after the declarator *)
(* e.g: in "int *x", "*x" is the declarator; "x" will be pulled out as *)
(* the string, and decl_type will be PTR([], JUSTBASE) *)
and name = string * decl_type * attribute list * cabsloc

(* A variable declarator ("name") with an initializer *)
and init_name = name * init_expression

(* Single names are for declarations that cannot come in groups, like
 * function parameters and functions *)
and single_name = specifier * name


and enum_item = string * expression * cabsloc

(*
** Declaration definition (at toplevel)
*)
and definition =
   FUNDEF of single_name * block * cabsloc * cabsloc
 | DECDEF of init_name_group * cabsloc        (* global variable(s), or function prototype *)
 | TYPEDEF of name_group * cabsloc
 | ONLYTYPEDEF of specifier * cabsloc
 | GLOBASM of string * cabsloc
 | PRAGMA of expression * cabsloc
 | LINKAGE of string * cabsloc * definition list (* extern "C" { ... } *)
 (* toplevel form transformer, from the first definition to the *)
 (* second group of definitions *)
 | TRANSFORMER of definition * definition list * cabsloc
 (* expression transformer: source and destination *)
 | EXPRTRANSFORMER of expression * expression * cabsloc


(* the string is a file name, and then the list of toplevel forms *)
and file = string * definition list


(*
** statements
*)

(* A block contains a list of local label declarations ( GCC's ({ __label__ 
 * l1, l2; ... }) ) , a list of definitions and a list of statements  *)
and block = 
    { blabels: string list;
      battrs: attribute list;
      bstmts: statement list
    } 

and statement =
   NOP of cabsloc
 | COMPUTATION of expression * cabsloc
 | BLOCK of block * cabsloc
 | SEQUENCE of statement * statement * cabsloc
 | IF of expression * statement * statement * cabsloc
 | WHILE of expression * statement * cabsloc
 | DOWHILE of expression * statement * cabsloc
 | FOR of for_clause * expression * expression * statement * cabsloc
 | BREAK of cabsloc
 | CONTINUE of cabsloc
 | RETURN of expression * cabsloc
 | SWITCH of expression * statement * cabsloc
 | CASE of expression * statement * cabsloc
 | CASERANGE of expression * expression * statement * cabsloc
 | DEFAULT of statement * cabsloc
 | LABEL of string * statement * cabsloc
 | GOTO of string * cabsloc
 | COMPGOTO of expression * cabsloc (* GCC's "goto *exp" *)
 | DEFINITION of definition (*definition or declaration of a variable or type*)

 | ASM of attribute list * (* typically only volatile and const *)
         string list * (* template *)
       (string * expression) list * (* list of constraints and expressions for 
                                   * outputs *)
       (string * expression) list * (* same for inputs *)
       string list * (* clobbered registers *)
       cabsloc

   (** MS SEH *)
 | TRY_EXCEPT of block * expression * block * cabsloc
 | TRY_FINALLY of block * block * cabsloc
 
and for_clause = 
   FC_EXP of expression
 | FC_DECL of definition

(*
** Expressions
*)
and binary_operator =
    ADD | SUB | MUL | DIV | MOD
  | AND | OR
  | BAND | BOR | XOR | SHL | SHR
  | EQ | NE | LT | GT | LE | GE
  | ASSIGN
  | ADD_ASSIGN | SUB_ASSIGN | MUL_ASSIGN | DIV_ASSIGN | MOD_ASSIGN
  | BAND_ASSIGN | BOR_ASSIGN | XOR_ASSIGN | SHL_ASSIGN | SHR_ASSIGN

and unary_operator =
    MINUS | PLUS | NOT | BNOT | MEMOF | ADDROF
  | PREINCR | PREDECR | POSINCR | POSDECR

and expression =
    NOTHING
  | UNARY of unary_operator * expression
  | LABELADDR of string  (* GCC's && Label *)
  | BINARY of binary_operator * expression * expression
  | QUESTION of expression * expression * expression

   (* A CAST can actually be a constructor expression *)
  | CAST of (specifier * decl_type) * init_expression

    (* There is a special form of CALL in which the function called is
       __builtin_va_arg and the second argument is sizeof(T). This 
       should be printed as just T *)
  | CALL of expression * expression list
  | COMMA of expression list
  | CONSTANT of constant
  | VARIABLE of string
  | EXPR_SIZEOF of expression
  | TYPE_SIZEOF of specifier * decl_type
  | EXPR_ALIGNOF of expression
  | TYPE_ALIGNOF of specifier * decl_type
  | INDEX of expression * expression
  | MEMBEROF of expression * string
  | MEMBEROFPTR of expression * string
  | GNU_BODY of block
  | EXPR_PATTERN of string     (* pattern variable, and name *)

and constant =
  | CONST_INT of string   (* the textual representation *)
  | CONST_FLOAT of string (* the textual representaton *)
  | CONST_CHAR of int64 list
  | CONST_WCHAR of int64 list
  | CONST_STRING of string
  | CONST_WSTRING of int64 list 
    (* ww: wstrings are stored as an int64 list at this point because
     * we might need to feed the wide characters piece-wise into an 
     * array initializer (e.g., wchar_t foo[] = L"E\xabcd";). If that
     * doesn't happen we will convert it to an (escaped) string before
     * passing it to Flx_cil_cil. *) 

and init_expression =
  | NO_INIT
  | SINGLE_INIT of expression
  | COMPOUND_INIT of (initwhat * init_expression) list

and initwhat =
    NEXT_INIT
  | INFIELD_INIT of string * initwhat
  | ATINDEX_INIT of expression * initwhat
  | ATINDEXRANGE_INIT of expression * expression
 

                                        (* Each attribute has a name and some
                                         * optional arguments *)
and attribute = string * expression list
                                              
@h = tangler("src/flx_cil_cabs_helper.mli")
@select(h)
val cabslu : Flx_cil_cabs.cabsloc
val missingFieldDecl :
  string * Flx_cil_cabs.decl_type * 'a list * Flx_cil_cabs.cabsloc
val isStatic : Flx_cil_cabs.spec_elem list -> bool
val isExtern : Flx_cil_cabs.spec_elem list -> bool
val isInline : Flx_cil_cabs.spec_elem list -> bool
val isTypedef : Flx_cil_cabs.spec_elem list -> bool
val get_definitionloc : Flx_cil_cabs.definition -> Flx_cil_cabs.cabsloc
val get_statementloc : Flx_cil_cabs.statement -> Flx_cil_cabs.cabsloc
val explodeStringToInts : string -> int64 list
val valueOfDigit : char -> int64
val d_cabsloc : unit -> Flx_cil_cabs.cabsloc -> Flx_cil_pretty.doc

@h = tangler("src/flx_cil_cabs_helper.ml")
@select(h)
open Flx_cil_cabs

let cabslu = {lineno = -10; filename = "cabs loc unknown"; byteno = -10;}


(*********** HELPER FUNCTIONS **********)

let missingFieldDecl = ("___missing_field_name", JUSTBASE, [], cabslu)

let rec isStatic = function
    [] -> false
  | (SpecStorage STATIC) :: _ -> true
  | _ :: rest -> isStatic rest

let rec isExtern = function
    [] -> false
  | (SpecStorage EXTERN) :: _ -> true
  | _ :: rest -> isExtern rest

let rec isInline = function
    [] -> false
  | SpecInline :: _ -> true
  | _ :: rest -> isInline rest

let rec isTypedef = function
    [] -> false
  | SpecTypedef :: _ -> true
  | _ :: rest -> isTypedef rest


let get_definitionloc (d : definition) : cabsloc =
  match d with
  | FUNDEF(_, _, l, _) -> l
  | DECDEF(_, l) -> l
  | TYPEDEF(_, l) -> l
  | ONLYTYPEDEF(_, l) -> l
  | GLOBASM(_, l) -> l
  | PRAGMA(_, l) -> l
  | TRANSFORMER(_, _, l) -> l
  | EXPRTRANSFORMER(_, _, l) -> l
  | LINKAGE (_, l, _) -> l

let get_statementloc (s : statement) : cabsloc =
begin
  match s with
  | NOP(loc) -> loc
  | COMPUTATION(_,loc) -> loc
  | BLOCK(_,loc) -> loc
  | SEQUENCE(_,_,loc) -> loc
  | IF(_,_,_,loc) -> loc
  | WHILE(_,_,loc) -> loc
  | DOWHILE(_,_,loc) -> loc
  | FOR(_,_,_,_,loc) -> loc
  | BREAK(loc) -> loc
  | CONTINUE(loc) -> loc
  | RETURN(_,loc) -> loc
  | SWITCH(_,_,loc) -> loc
  | CASE(_,_,loc) -> loc
  | CASERANGE(_,_,_,loc) -> loc
  | DEFAULT(_,loc) -> loc
  | LABEL(_,_,loc) -> loc
  | GOTO(_,loc) -> loc
  | COMPGOTO (_, loc) -> loc
  | DEFINITION d -> get_definitionloc d
  | ASM(_,_,_,_,_,loc) -> loc
  | TRY_EXCEPT(_, _, _, loc) -> loc
  | TRY_FINALLY(_, _, loc) -> loc
end


let explodeStringToInts (s: string) : int64 list =  
  let rec allChars i acc = 
    if i < 0 then acc
    else allChars (i - 1) (Int64.of_int (Char.code (String.get s i)) :: acc)
  in
  allChars (-1 + String.length s) []

let valueOfDigit chr =
  let int_value = 
    match chr with
      '0'..'9' -> (Char.code chr) - (Char.code '0')
    | 'a'..'z' -> (Char.code chr) - (Char.code 'a') + 10
    | 'A'..'Z' -> (Char.code chr) - (Char.code 'A') + 10
    | _ -> Flx_cil_errormsg.s (Flx_cil_errormsg.bug "not a digit") in
  Int64.of_int int_value
  
    
open Flx_cil_pretty
let d_cabsloc () cl = 
  text cl.filename ++ text ":" ++ num cl.lineno
@h=tangler('src/flx_cil_cabsvisit.ml')
@select(h)

(* cabsvisit.ml *)
(* tree visitor and rewriter for cabs *)

open Flx_cil_cabs
open Flx_cil_cabs_helper
open Flx_cil_trace
open Flx_cil_pretty
module E = Flx_cil_errormsg

(* basic interface for a visitor object *)

(* Different visiting actions. 'a will be instantiated with exp, instr, etc. *)
type 'a visitAction = 
    SkipChildren                        (* Do not visit the children. Return 
                                         * the node as it is *)
  | ChangeTo of 'a                      (* Replace the expression with the 
                                         * given one *)
  | DoChildren                          (* Continue with the children of this 
                                         * node. Rebuild the node on return 
                                         * if any of the children changes 
                                         * (use == test) *)
  | ChangeDoChildrenPost of 'a * ('a -> 'a) (* First consider that the entire 
                                          * exp is replaced by the first 
                                          * paramenter. Then continue with 
                                          * the children. On return rebuild 
                                          * the node if any of the children 
                                          * has changed and then apply the 
                                          * function on the node *)

type nameKind = 
    NVar                                (* Variable or function prototype 
                                           name *)
  | NFun                                (* A function definition name *)
  | NField                              (* The name of a field *)
  | NType                               (* The name of a type *)

(* All visit methods are called in preorder! (but you can use 
 * ChangeDoChildrenPost to change the order) *)
class type cabsVisitor = object
  method vexpr: expression -> expression visitAction   (* expressions *)
  method vinitexpr: init_expression -> init_expression visitAction   
  method vstmt: statement -> statement list visitAction
  method vblock: block -> block visitAction
  method vvar: string -> string                  (* use of a variable 
                                                        * names *)
  method vdef: definition -> definition list visitAction
  method vtypespec: typeSpecifier -> typeSpecifier visitAction
  method vdecltype: decl_type -> decl_type visitAction

      (* For each declaration we call vname *)
  method vname: nameKind -> specifier -> name -> name visitAction
  method vspec: specifier -> specifier visitAction     (* specifier *)
  method vattr: attribute -> attribute list visitAction

  method vEnterScope: unit -> unit
  method vExitScope: unit -> unit
end
    
let visitorLocation = ref { filename = ""; lineno = -1; byteno = -1; }
    
        (* a default visitor which does nothing to the tree *)
class nopFlx_cil_cabsVisitor : cabsVisitor = object
  method vexpr (e:expression) = DoChildren
  method vinitexpr (e:init_expression) = DoChildren
  method vstmt (s: statement) = 
    visitorLocation := get_statementloc s;
    DoChildren
  method vblock (b: block) = DoChildren
  method vvar (s: string) = s
  method vdef (d: definition) = 
    visitorLocation := get_definitionloc d;
    DoChildren
  method vtypespec (ts: typeSpecifier) = DoChildren
  method vdecltype (dt: decl_type) = DoChildren
  method vname k (s:specifier) (n: name) = DoChildren
  method vspec (s:specifier) = DoChildren
  method vattr (a: attribute) = DoChildren
      
  method vEnterScope () = ()
  method vExitScope () = ()
end
        
        (* Map but try not to copy the list unless necessary *)
let rec mapNoCopy (f: 'a -> 'a) = function
    [] -> []
  | (i :: resti) as li -> 
      let i' = f i in
      let resti' = mapNoCopy f resti in
      if i' != i || resti' != resti then i' :: resti' else li 
        
let rec mapNoCopyList (f: 'a -> 'a list) = function
    [] -> []
  | (i :: resti) as li -> 
      let il' = f i in
      let resti' = mapNoCopyList f resti in
      match il' with
        [i'] when i' == i && resti' == resti -> li
      | _ -> il' @ resti'
                     
let doVisit (vis: cabsVisitor)
    (startvisit: 'a -> 'a visitAction) 
    (children: cabsVisitor -> 'a -> 'a) 
    (node: 'a) : 'a = 
  let action = startvisit node in
  match action with
    SkipChildren -> node
  | ChangeTo node' -> node'
  | _ ->  
      let nodepre = match action with
        ChangeDoChildrenPost (node', _) -> node'
      | _ -> node
      in
      let nodepost = children vis nodepre in
      match action with
        ChangeDoChildrenPost (_, f) -> f nodepost
      | _ -> nodepost
            
(* A visitor for lists *)
let doVisitList (vis: cabsVisitor)
                (startvisit: 'a -> 'a list visitAction)
                (children: cabsVisitor -> 'a -> 'a)
                (node: 'a) : 'a list = 
  let action = startvisit node in
  match action with
    SkipChildren -> [node]
  | ChangeTo nodes' -> nodes'
  | _ -> 
      let nodespre = match action with
        ChangeDoChildrenPost (nodespre, _) -> nodespre
      | _ -> [node]
      in
      let nodespost = mapNoCopy (children vis) nodespre in
      match action with
        ChangeDoChildrenPost (_, f) -> f nodespost
      | _ -> nodespost

            
let rec visitFlx_cil_cabsTypeSpecifier (vis: cabsVisitor) (ts: typeSpecifier) = 
  doVisit vis vis#vtypespec childrenTypeSpecifier ts
    
and childrenTypeSpecifier vis ts = 
  let childrenFieldGroup ((s, nel) as input) = 
    let s' = visitFlx_cil_cabsSpecifier vis s in
    let doOneField ((n, eo) as input) = 
      let n' = visitFlx_cil_cabsName vis NField s' n in
      let eo' = 
        match eo with
          None -> None
        | Some e -> let e' = visitFlx_cil_cabsExpression vis e in
          if e' != e then Some e' else eo
      in
      if n' != n || eo' != eo then (n', eo') else input
    in
    let nel' = mapNoCopy doOneField nel in
    if s' != s || nel' != nel then (s', nel) else input
  in
  match ts with
    Tstruct (n, Some fg, extraAttrs) ->
      (*(trace "sm" (dprintf "visiting struct %s\n" n));*)
      let fg' = mapNoCopy childrenFieldGroup fg in
      if fg' != fg then Tstruct( n, Some fg', extraAttrs) else ts
  | Tunion (n, Some fg, extraAttrs) ->
      let fg' = mapNoCopy childrenFieldGroup fg in
      if fg' != fg then Tunion( n, Some fg', extraAttrs) else ts
  | Tenum (n, Some ei, extraAttrs) ->
      let doOneEnumItem ((s, e, loc) as ei) =
        let e' = visitFlx_cil_cabsExpression vis e in
        if e' != e then (s, e', loc) else ei
      in
      vis#vEnterScope ();
      let ei' = mapNoCopy doOneEnumItem ei in
      vis#vExitScope();
      if ei' != ei then Tenum( n, Some ei', extraAttrs) else ts
  | TtypeofE e ->
      let e' = visitFlx_cil_cabsExpression vis e in   
      if e' != e then TtypeofE e' else ts
  | TtypeofT (s, dt) -> 
      let s' = visitFlx_cil_cabsSpecifier vis s in
      let dt' = visitFlx_cil_cabsDeclType vis false dt in
      if s != s' || dt != dt' then TtypeofT (s', dt') else ts
  | ts -> ts
        
and childrenSpecElem (vis: cabsVisitor) (se: spec_elem) : spec_elem = 
  match se with
    SpecTypedef | SpecInline | SpecStorage _ | SpecPattern _ -> se
  | SpecCV _ -> se    (* cop out *)
  | SpecAttr a -> begin
      let al' = visitFlx_cil_cabsAttribute vis a in
      match al' with
        [a''] when a'' == a -> se
      | [a''] -> SpecAttr a''
      | _ -> E.s (E.unimp "childrenSpecElem: visitFlx_cil_cabsAttribute returned a list")
  end
  | SpecType ts -> 
      let ts' = visitFlx_cil_cabsTypeSpecifier vis ts in
      if ts' != ts then SpecType ts' else se
        
and visitFlx_cil_cabsSpecifier (vis: cabsVisitor) (s: specifier) : specifier = 
  doVisit vis vis#vspec childrenSpec s
and childrenSpec vis s = mapNoCopy (childrenSpecElem vis) s 
    

and visitFlx_cil_cabsDeclType vis (isfundef: bool) (dt: decl_type) : decl_type = 
  doVisit vis vis#vdecltype (childrenDeclType isfundef) dt
and childrenDeclType isfundef vis dt = 
  match dt with
    JUSTBASE -> dt
  | PARENTYPE (prea, dt1, posta) -> 
      let prea' = mapNoCopyList (visitFlx_cil_cabsAttribute vis)  prea in
      let dt1' = visitFlx_cil_cabsDeclType vis isfundef dt1 in
      let posta'= mapNoCopyList (visitFlx_cil_cabsAttribute vis)  posta in
      if prea' != prea || dt1' != dt1 || posta' != posta then 
        PARENTYPE (prea', dt1', posta') else dt
  | ARRAY (dt1, al, e) -> 
      let dt1' = visitFlx_cil_cabsDeclType vis isfundef dt1 in
      let al' = mapNoCopy (childrenAttribute vis) al in
      let e'= visitFlx_cil_cabsExpression vis e in
      if dt1' != dt1 || al' != al || e' != e then ARRAY(dt1', al', e') else dt
  | PTR (al, dt1) -> 
      let al' = mapNoCopy (childrenAttribute vis) al in
      let dt1' = visitFlx_cil_cabsDeclType vis isfundef dt1 in
      if al' != al || dt1' != dt1 then PTR(al', dt1') else dt
  | PROTO (dt1, snl, b) ->
      (* Do not propagate isfundef further *)
      let dt1' = visitFlx_cil_cabsDeclType vis false dt1 in
      let _ = vis#vEnterScope () in
      let snl' = mapNoCopy (childrenSingleName vis NVar) snl in
      (* Exit the scope only if not in a function definition *)
      let _ = if not isfundef then vis#vExitScope () in
      if dt1' != dt1 || snl' != snl then PROTO(dt1', snl', b) else dt
         

and childrenNameGroup vis (kind: nameKind) ((s, nl) as input) = 
  let s' = visitFlx_cil_cabsSpecifier vis s in
  let nl' = mapNoCopy (visitFlx_cil_cabsName vis kind s') nl in
  if s' != s || nl' != nl then (s', nl') else input

    
and childrenInitNameGroup vis ((s, inl) as input) = 
  let s' = visitFlx_cil_cabsSpecifier vis s in
  let inl' = mapNoCopy (childrenInitName vis s') inl in
  if s' != s || inl' != inl then (s', inl') else input
    
and visitFlx_cil_cabsName vis (k: nameKind) (s: specifier) 
                      (n: name) : name = 
  doVisit vis (vis#vname k s) (childrenName s k) n
and childrenName (s: specifier) (k: nameKind) vis (n: name) : name = 
  let (sn, dt, al, loc) = n in
  let dt' = visitFlx_cil_cabsDeclType vis (k = NFun) dt in
  let al' = mapNoCopy (childrenAttribute vis) al in
  if dt' != dt || al' != al then (sn, dt', al', loc) else n
    
and childrenInitName vis (s: specifier) (inn: init_name) : init_name = 
  let (n, ie) = inn in
  let n' = visitFlx_cil_cabsName vis NVar s n in
  let ie' = visitFlx_cil_cabsInitExpression vis ie in
  if n' != n || ie' != ie then (n', ie') else inn
    
and childrenSingleName vis (k: nameKind) (sn: single_name) : single_name =
  let s, n = sn in
  let s' = visitFlx_cil_cabsSpecifier vis s in
  let n' = visitFlx_cil_cabsName vis k s' n in
  if s' != s || n' != n then (s', n') else sn
    
and visitFlx_cil_cabsDefinition vis (d: definition) : definition list = 
  doVisitList vis vis#vdef childrenDefinition d
and childrenDefinition vis d = 
  match d with 
    FUNDEF (sn, b, l, lend) -> 
      let sn' = childrenSingleName vis NFun sn in
      let b' = visitFlx_cil_cabsBlock vis b in
      (* End the scope that was started by childrenFunctionName *)
      vis#vExitScope ();
      if sn' != sn || b' != b then FUNDEF (sn', b', l, lend) else d
        
  | DECDEF ((s, inl), l) -> 
      let s' = visitFlx_cil_cabsSpecifier vis s in
      let inl' = mapNoCopy (childrenInitName vis s') inl in
      if s' != s || inl' != inl then DECDEF ((s', inl'), l) else d
  | TYPEDEF (ng, l) -> 
      let ng' = childrenNameGroup vis NType ng in
      if ng' != ng then TYPEDEF (ng', l) else d
  | ONLYTYPEDEF (s, l) -> 
      let s' = visitFlx_cil_cabsSpecifier vis s in
      if s' != s then ONLYTYPEDEF (s', l) else d
  | GLOBASM _ -> d
  | PRAGMA (e, l) -> 
      let e' = visitFlx_cil_cabsExpression vis e in
      if e' != e then PRAGMA (e', l) else d
  | LINKAGE (n, l, dl) -> 
      let dl' = mapNoCopyList (visitFlx_cil_cabsDefinition vis) dl in
      if dl' != dl then LINKAGE (n, l, dl') else d
      
  | TRANSFORMER _ -> d
  | EXPRTRANSFORMER _ -> d
        
and visitFlx_cil_cabsBlock vis (b: block) : block = 
  doVisit vis vis#vblock childrenBlock b

and childrenBlock vis (b: block) : block = 
  let _ = vis#vEnterScope () in
  let battrs' = mapNoCopyList (visitFlx_cil_cabsAttribute vis) b.battrs in
  let bstmts' = mapNoCopyList (visitFlx_cil_cabsStatement vis) b.bstmts in
  let _ = vis#vExitScope () in
  if battrs' != b.battrs || bstmts' != b.bstmts then 
    { blabels = b.blabels; battrs = battrs'; bstmts = bstmts' }
  else
    b
    
and visitFlx_cil_cabsStatement vis (s: statement) : statement list = 
  doVisitList vis vis#vstmt childrenStatement s
and childrenStatement vis s = 
  let ve e = visitFlx_cil_cabsExpression vis e in
  let vs l s = 
    match visitFlx_cil_cabsStatement vis s with
      [s'] -> s'
    | sl -> BLOCK ({blabels = []; battrs = []; bstmts = sl }, l)
  in
  match s with
    NOP _ -> s
  | COMPUTATION (e, l) ->
      let e' = ve e in
      if e' != e then COMPUTATION (e', l) else s
  | BLOCK (b, l) -> 
      let b' = visitFlx_cil_cabsBlock vis b in
      if b' != b then BLOCK (b', l) else s
  | SEQUENCE (s1, s2, l) -> 
      let s1' = vs l s1 in
      let s2' = vs l s2 in
      if s1' != s1 || s2' != s2 then SEQUENCE (s1', s2', l) else s
  | IF (e, s1, s2, l) -> 
      let e' = ve e in
      let s1' = vs l s1 in
      let s2' = vs l s2 in
      if e' != e || s1' != s1 || s2' != s2 then IF (e', s1', s2', l) else s
  | WHILE (e, s1, l) -> 
      let e' = ve e in
      let s1' = vs l s1 in
      if e' != e || s1' != s1 then WHILE (e', s1', l) else s
  | DOWHILE (e, s1, l) -> 
      let e' = ve e in
      let s1' = vs l s1 in
      if e' != e || s1' != s1 then DOWHILE (e', s1', l) else s
  | FOR (fc1, e2, e3, s4, l) -> 
      let _ = vis#vEnterScope () in
      let fc1' = 
        match fc1 with
          FC_EXP e1 -> 
            let e1' = ve e1 in
            if e1' != e1 then FC_EXP e1' else fc1
        | FC_DECL d1 -> 
            let d1' = 
              match visitFlx_cil_cabsDefinition vis d1 with
                [d1'] -> d1'
              | _ -> E.s (E.unimp "visitFlx_cil_cabs: for can have only one definition")
            in
            if d1' != d1 then FC_DECL d1' else fc1
      in
      let e2' = ve e2 in
      let e3' = ve e3 in
      let s4' = vs l s4 in
      let _ = vis#vExitScope () in
      if fc1' != fc1 || e2' != e2 || e3' != e3 || s4' != s4 
      then FOR (fc1', e2', e3', s4', l) else s
  | BREAK _ | CONTINUE _ | GOTO _ -> s
  | RETURN (e, l) ->
      let e' = ve e in
      if e' != e then RETURN (e', l) else s
  | SWITCH (e, s1, l) -> 
      let e' = ve e in
      let s1' = vs l s1 in
      if e' != e || s1' != s1 then SWITCH (e', s1', l) else s
  | CASE (e, s1, l) -> 
      let e' = ve e in
      let s1' = vs l s1 in
      if e' != e || s1' != s1 then CASE (e', s1', l) else s
  | CASERANGE (e1, e2, s3, l) -> 
      let e1' = ve e1 in
      let e2' = ve e2 in
      let s3' = vs l s3 in
      if e1' != e1 || e2' != e2 || s3' != s3 then 
        CASERANGE (e1', e2', s3', l) else s
  | DEFAULT (s1, l) ->
      let s1' = vs l s1 in
      if s1' != s1 then DEFAULT (s1', l) else s
  | LABEL (n, s1, l) ->
      let s1' = vs l s1 in
      if s1' != s1 then LABEL (n, s1', l) else s
  | COMPGOTO (e, l) -> 
      let e' = ve e in
      if e' != e then COMPGOTO (e', l) else s
  | DEFINITION d -> begin
      match visitFlx_cil_cabsDefinition vis d with
          [d'] when d' == d -> s
        | dl -> let l = get_definitionloc d in
          let dl' = List.map (fun d' -> DEFINITION d') dl in
          BLOCK ({blabels = []; battrs = []; bstmts = dl' }, l)
    end
  | ASM (sl, b, inl, outl, clobs, l) -> 
      let childrenStringExp ((s, e) as input) = 
        let e' = ve e in
        if e' != e then (s, e') else input
      in
      let inl' = mapNoCopy childrenStringExp inl in
      let outl' = mapNoCopy childrenStringExp outl in
      if inl' != inl || outl' != outl then 
        ASM (sl, b, inl', outl', clobs, l) else s
  | TRY_FINALLY (b1, b2, l) -> 
      let b1' = visitFlx_cil_cabsBlock vis b1 in
      let b2' = visitFlx_cil_cabsBlock vis b2 in
      if b1' != b1 || b2' != b2 then TRY_FINALLY(b1', b2', l) else s
  | TRY_EXCEPT (b1, e, b2, l) -> 
      let b1' = visitFlx_cil_cabsBlock vis b1 in
      let e' = visitFlx_cil_cabsExpression vis e in
      let b2' = visitFlx_cil_cabsBlock vis b2 in
      if b1' != b1 || e' != e || b2' != b2 then TRY_EXCEPT(b1', e', b2', l) else s
      
          
and visitFlx_cil_cabsExpression vis (e: expression) : expression = 
  doVisit vis vis#vexpr childrenExpression e
and childrenExpression vis e = 
  let ve e = visitFlx_cil_cabsExpression vis e in
  match e with 
    NOTHING | LABELADDR _ -> e
  | UNARY (uo, e1) -> 
      let e1' = ve e1 in
      if e1' != e1 then UNARY (uo, e1') else e
  | BINARY (bo, e1, e2) -> 
      let e1' = ve e1 in
      let e2' = ve e2 in
      if e1' != e1 || e2' != e2 then BINARY (bo, e1', e2') else e
  | QUESTION (e1, e2, e3) -> 
      let e1' = ve e1 in
      let e2' = ve e2 in
      let e3' = ve e3 in
      if e1' != e1 || e2' != e2 || e3' != e3 then 
        QUESTION (e1', e2', e3') else e
  | CAST ((s, dt), ie) -> 
      let s' = visitFlx_cil_cabsSpecifier vis s in
      let dt' = visitFlx_cil_cabsDeclType vis false dt in
      let ie' = visitFlx_cil_cabsInitExpression vis ie in
      if s' != s || dt' != dt || ie' != ie then CAST ((s', dt'), ie') else e
  | CALL (f, el) -> 
      let f' = ve f in
      let el' = mapNoCopy ve el in
      if f' != f || el' != el then CALL (f', el') else e
  | COMMA el -> 
      let el' = mapNoCopy ve el in
      if el' != el then COMMA (el') else e
  | CONSTANT _ -> e
  | VARIABLE s -> 
      let s' = vis#vvar s in
      if s' != s then VARIABLE s' else e
  | EXPR_SIZEOF (e1) -> 
      let e1' = ve e1 in
      if e1' != e1 then EXPR_SIZEOF (e1') else e
  | TYPE_SIZEOF (s, dt) -> 
      let s' = visitFlx_cil_cabsSpecifier vis s in
      let dt' = visitFlx_cil_cabsDeclType vis false dt in
      if s' != s || dt' != dt then TYPE_SIZEOF (s' ,dt') else e
  | EXPR_ALIGNOF (e1) -> 
      let e1' = ve e1 in
      if e1' != e1 then EXPR_ALIGNOF (e1') else e
  | TYPE_ALIGNOF (s, dt) -> 
      let s' = visitFlx_cil_cabsSpecifier vis s in
      let dt' = visitFlx_cil_cabsDeclType vis false dt in
      if s' != s || dt' != dt then TYPE_ALIGNOF (s' ,dt') else e
  | INDEX (e1, e2) -> 
      let e1' = ve e1 in
      let e2' = ve e2 in
      if e1' != e1 || e2' != e2 then INDEX (e1', e2') else e
  | MEMBEROF (e1, n) -> 
      let e1' = ve e1 in
      if e1' != e1 then MEMBEROF (e1', n) else e
  | MEMBEROFPTR (e1, n) -> 
      let e1' = ve e1 in
      if e1' != e1 then MEMBEROFPTR (e1', n) else e
  | GNU_BODY b -> 
      let b' = visitFlx_cil_cabsBlock vis b in
      if b' != b then GNU_BODY b' else e
  | EXPR_PATTERN _ -> e
        
and visitFlx_cil_cabsInitExpression vis (ie: init_expression) : init_expression = 
  doVisit vis vis#vinitexpr childrenInitExpression ie
and childrenInitExpression vis ie = 
  let rec childrenInitWhat iw = 
    match iw with
      NEXT_INIT -> iw
    | INFIELD_INIT (n, iw1) -> 
        let iw1' = childrenInitWhat iw1 in
        if iw1' != iw1 then INFIELD_INIT (n, iw1') else iw
    | ATINDEX_INIT (e, iw1) -> 
        let e' = visitFlx_cil_cabsExpression vis e in
        let iw1' = childrenInitWhat iw1 in
        if e' != e || iw1' != iw1 then ATINDEX_INIT (e', iw1') else iw
    | ATINDEXRANGE_INIT (e1, e2) -> 
        let e1' = visitFlx_cil_cabsExpression vis e1 in
        let e2' = visitFlx_cil_cabsExpression vis e2 in
        if e1' != e1 || e2' != e2 then ATINDEXRANGE_INIT (e1, e2) else iw
  in
  match ie with 
    NO_INIT -> ie
  | SINGLE_INIT e -> 
      let e' = visitFlx_cil_cabsExpression vis e in
      if e' != e then SINGLE_INIT e' else ie
  | COMPOUND_INIT il -> 
      let childrenOne ((iw, ie) as input) = 
        let iw' = childrenInitWhat iw in
        let ie' = visitFlx_cil_cabsInitExpression vis ie in
        if iw' != iw || ie' != ie then (iw', ie') else input
      in
      let il' = mapNoCopy childrenOne il in
      if il' != il then COMPOUND_INIT il' else ie
        

and visitFlx_cil_cabsAttribute vis (a: attribute) : attribute list = 
  doVisitList vis vis#vattr childrenAttribute a

and childrenAttribute vis ((n, el) as input) = 
  let el' = mapNoCopy (visitFlx_cil_cabsExpression vis) el in
  if el' != el then (n, el') else input
    
and visitFlx_cil_cabsAttributes vis (al: attribute list) : attribute list = 
  mapNoCopyList (visitFlx_cil_cabsAttribute vis) al

let visitFlx_cil_cabsFile (vis: cabsVisitor) ((fname, f): file) : file =  
  (fname, mapNoCopyList (visitFlx_cil_cabsDefinition vis) f)

    (* end of file *)
    
@h=tangler('src/flx_cil_cabsvisit.mli')
@select(h)

(* cabsvisit.mli *)
(* interface for cabsvisit.ml *)

(* Different visiting actions. 'a will be instantiated with exp, instr, etc. *)
type 'a visitAction = 
    SkipChildren                        (* Do not visit the children. Return 
                                         * the node as it is *)
  | ChangeTo of 'a                      (* Replace the expression with the 
                                         * given one *)
  | DoChildren                          (* Continue with the children of this 
                                         * node. Rebuild the node on return 
                                         * if any of the children changes 
                                         * (use == test) *)
  | ChangeDoChildrenPost of 'a * ('a -> 'a) (* First consider that the entire 
                                          * exp is replaced by the first 
                                          * paramenter. Then continue with 
                                          * the children. On return rebuild 
                                          * the node if any of the children 
                                          * has changed and then apply the 
                                          * function on the node *)

type nameKind = 
    NVar                                (** Variable or function prototype 
                                           name *)
  | NFun                                (** Function definition name *)
  | NField                              (** The name of a field *)
  | NType                               (** The name of a type *)


(* All visit methods are called in preorder! (but you can use 
 * ChangeDoChildrenPost to change the order) *)
class type cabsVisitor = object
  method vexpr: Flx_cil_cabs.expression -> Flx_cil_cabs.expression visitAction   (* expressions *)
  method vinitexpr: Flx_cil_cabs.init_expression -> Flx_cil_cabs.init_expression visitAction   
  method vstmt: Flx_cil_cabs.statement -> Flx_cil_cabs.statement list visitAction
  method vblock: Flx_cil_cabs.block -> Flx_cil_cabs.block visitAction
  method vvar: string -> string                  (* use of a variable 
                                                        * names *)
  method vdef: Flx_cil_cabs.definition -> Flx_cil_cabs.definition list visitAction
  method vtypespec: Flx_cil_cabs.typeSpecifier -> Flx_cil_cabs.typeSpecifier visitAction
  method vdecltype: Flx_cil_cabs.decl_type -> Flx_cil_cabs.decl_type visitAction

      (* For each declaration we call vname *)
  method vname: nameKind -> Flx_cil_cabs.specifier -> Flx_cil_cabs.name -> Flx_cil_cabs.name visitAction
  method vspec: Flx_cil_cabs.specifier -> Flx_cil_cabs.specifier visitAction     (* specifier *)
  method vattr: Flx_cil_cabs.attribute -> Flx_cil_cabs.attribute list visitAction


  method vEnterScope: unit -> unit
  method vExitScope: unit -> unit
end


class nopFlx_cil_cabsVisitor: cabsVisitor


val visitFlx_cil_cabsTypeSpecifier: cabsVisitor -> 
                            Flx_cil_cabs.typeSpecifier -> Flx_cil_cabs.typeSpecifier
val visitFlx_cil_cabsSpecifier: cabsVisitor -> Flx_cil_cabs.specifier -> Flx_cil_cabs.specifier

(** Visits a decl_type. The bool argument is saying whether we are ina 
  * function definition and thus the scope in a PROTO should extend until the 
  * end of the function *)
val visitFlx_cil_cabsDeclType: cabsVisitor -> bool -> Flx_cil_cabs.decl_type -> Flx_cil_cabs.decl_type
val visitFlx_cil_cabsDefinition: cabsVisitor -> Flx_cil_cabs.definition -> Flx_cil_cabs.definition list
val visitFlx_cil_cabsBlock: cabsVisitor -> Flx_cil_cabs.block -> Flx_cil_cabs.block
val visitFlx_cil_cabsStatement: cabsVisitor -> Flx_cil_cabs.statement -> Flx_cil_cabs.statement list
val visitFlx_cil_cabsExpression: cabsVisitor -> Flx_cil_cabs.expression -> Flx_cil_cabs.expression
val visitFlx_cil_cabsAttributes: cabsVisitor -> Flx_cil_cabs.attribute list 
                                     -> Flx_cil_cabs.attribute list
val visitFlx_cil_cabsName: cabsVisitor -> nameKind 
                   -> Flx_cil_cabs.specifier -> Flx_cil_cabs.name -> Flx_cil_cabs.name
val visitFlx_cil_cabsFile: cabsVisitor -> Flx_cil_cabs.file -> Flx_cil_cabs.file



(** Set by the visitor to the current location *)
val visitorLocation: Flx_cil_cabs.cabsloc ref
@h=tangler('src/flx_cil_clexer.mli')
@select(h)


(* This interface is generated manually. The corresponding .ml file is 
 * generated automatically and is placed in ../obj/clexer.ml. The reason we 
 * want this interface is to avoid confusing make with freshly generated 
 * interface files *)


val init: filename:string -> lang:Flx_cil_cabs.lang_t -> Lexing.lexbuf
val finish: unit -> unit

(* This is the main parser function *)
val initial: Lexing.lexbuf -> Flx_cil_cparser.token


val push_context: unit -> unit (* Start a context  *)
val add_type: string -> unit (* Add a new string as a type name  *)
val add_identifier: string -> unit (* Add a new string as a variable name  *)
val pop_context: unit -> unit (* Remove all names added in this context  *)

@h=tangler('src/flx_cil_clexer.mll','data')
@select(h)
(* FrontC -- lexical analyzer
**
** 1.0  3.22.99 Hugues Cass√©    First version.
** 2.0  George Necula 12/12/00: Many extensions
*)
{
open Flx_cil_cparser
open Flx_cil_pretty
exception Eof
exception InternalError of string
module E = Flx_cil_errormsg
module H = Hashtbl

let currentLoc () = 
  let l, f, c = E.getPosition () in
  { Flx_cil_cabs.lineno   = l;
    Flx_cil_cabs.filename = f;
    Flx_cil_cabs.byteno   = c; }

(* Some debugging support for line numbers *)
let dbgToken (t: token) = 
  if false then begin
    ignore (E.log "%a" insert
              (match t with 
                IDENT (n, l) -> dprintf "IDENT(%s,%d)\n" n l.Flx_cil_cabs.lineno
              | LBRACE l -> dprintf "LBRACE(%d)\n" l.Flx_cil_cabs.lineno
              | RBRACE l -> dprintf "RBRACE(%d)\n" l.Flx_cil_cabs.lineno
              | IF l -> dprintf "IF(%d)\n" l.Flx_cil_cabs.lineno
              | SWITCH l -> dprintf "SWITCH(%d)\n" l.Flx_cil_cabs.lineno
              | RETURN l -> dprintf "RETURN(%d)\n" l.Flx_cil_cabs.lineno
              | _ -> nil));
    t
  end else
    t

(*
** Keyword hashtable
*)

let c_keywords =
    [ 
      ("_Bool", fun loc -> BOOL loc);
      ("_Imaginary", fun loc -> IMAGINARY loc);
      ("_Complex", fun loc -> COMPLEX loc);
      ("auto", fun loc -> AUTO loc);
      ("const", fun loc -> CONST loc);
      ("__const", fun loc -> CONST loc);
      ("__const__", fun loc -> CONST loc);
      ("static", fun loc -> STATIC loc);
      ("extern", fun loc -> EXTERN loc);
      ("long", fun loc -> LONG loc);
      ("short", fun loc -> SHORT loc);
      ("register", fun loc -> REGISTER loc);
      ("signed", fun loc -> SIGNED loc);
      ("__signed", fun loc -> SIGNED loc);
      ("unsigned", fun loc -> UNSIGNED loc);
      ("volatile", fun loc -> VOLATILE loc);
      ("__volatile", fun loc -> VOLATILE loc);
      (* WW: see /usr/include/sys/cdefs.h for why __signed and __volatile
       * are accepted GCC-isms *)
      ("char", fun loc -> CHAR loc);
      ("int", fun loc -> INT loc);
      ("float", fun loc -> FLOAT loc);
      ("double", fun loc -> DOUBLE loc);
      ("void", fun loc -> VOID loc);
      ("enum", fun loc -> ENUM loc);
      ("struct", fun loc -> STRUCT loc);
      ("typedef", fun loc -> TYPEDEF loc);
      ("union", fun loc -> UNION loc);
      ("break", fun loc -> BREAK loc);
      ("continue", fun loc -> CONTINUE loc);
      ("goto", fun loc -> GOTO loc); 
      ("return", fun loc -> dbgToken (RETURN loc));
      ("switch", fun loc -> dbgToken (SWITCH loc));
      ("case", fun loc -> CASE loc); 
      ("default", fun loc -> DEFAULT loc);
      ("while", fun loc -> WHILE loc);  
      ("do", fun loc -> DO loc);  
      ("for", fun loc -> FOR loc);
      ("if", fun loc -> dbgToken (IF loc));
      ("else", fun _ -> ELSE);
      (*** Implementation specific keywords ***)
      ("__signed__", fun loc -> SIGNED loc);
      ("__inline__", fun loc -> INLINE loc);
      ("inline", fun loc -> INLINE loc); 
      ("__inline", fun loc -> INLINE loc);
      ("_inline", fun loc -> INLINE loc);
      ("__attribute__", fun loc -> ATTRIBUTE loc);
      ("__attribute", fun loc -> ATTRIBUTE loc);
      ("__blockattribute__", fun _ -> BLOCKATTRIBUTE);
      ("__blockattribute", fun _ -> BLOCKATTRIBUTE);
      ("__asm__", fun loc -> ASM loc);
      ("asm", fun loc -> ASM loc);
      ("__typeof__", fun loc -> TYPEOF loc);
      ("__typeof", fun loc -> TYPEOF loc);
      ("typeof", fun loc -> TYPEOF loc); 
      ("__alignof", fun loc -> ALIGNOF loc);
      ("__alignof__", fun loc -> ALIGNOF loc);
      ("__volatile__", fun loc -> VOLATILE loc);
      ("__volatile", fun loc -> VOLATILE loc);

      ("__FUNCTION__", fun loc -> FUNCTION__ loc);
      ("__func__", fun loc -> FUNCTION__ loc); (* ISO 6.4.2.2 *)
      ("__PRETTY_FUNCTION__", fun loc -> PRETTY_FUNCTION__ loc);
      ("__label__", fun _ -> LABEL__);
      (*** weimer: GCC arcana ***)
      ("__restrict", fun loc -> RESTRICT loc);
      ("restrict", fun loc -> RESTRICT loc);
(*      ("__extension__", EXTENSION); *)
      (**** MS VC ***)
      ("__int64", fun _ -> INT64 (currentLoc ()));
      ("__int32", fun loc -> INT loc);
      ("_cdecl",  fun _ -> MSATTR ("_cdecl", currentLoc ())); 
      ("__cdecl", fun _ -> MSATTR ("__cdecl", currentLoc ()));
      ("_stdcall", fun _ -> MSATTR ("_stdcall", currentLoc ())); 
      ("__stdcall", fun _ -> MSATTR ("__stdcall", currentLoc ()));
      ("_fastcall", fun _ -> MSATTR ("_fastcall", currentLoc ())); 
      ("__fastcall", fun _ -> MSATTR ("__fastcall", currentLoc ()));
      ("__w64", fun _ -> MSATTR("__w64", currentLoc ()));
      ("__declspec", fun loc -> DECLSPEC loc);
      ("__forceinline", fun loc -> INLINE loc); (* !! we turn forceinline 
                                                 * into inline *)
      ("__try", fun loc -> TRY loc);
      ("__except", fun loc -> EXCEPT loc);
      ("__finally", fun loc -> FINALLY loc);
      (* weimer: some files produced by 'GCC -E' expect this type to be
       * defined *)
      ("__builtin_va_list", 
       fun _ -> NAMED_TYPE ("__builtin_va_list", currentLoc ()));
      ("__builtin_va_arg", fun loc -> BUILTIN_VA_ARG loc);
      (* On some versions of GCC __thread is a regular identifier *)
      ("__thread", fun loc -> 
                      if Flx_cil_machdep.__thread_is_keyword then 
                         THREAD loc
                       else 
                         IDENT ("__thread", loc));
    ]

let cxx_extra_keywords = [
      ("class", fun loc -> CLASS loc);
      ("namespace", fun loc -> NAMESPACE loc);
      ("using", fun loc -> USING loc);
      ("typename", fun loc -> TYPENAME loc);
      ("templatename", fun loc -> TEMPLATENAME loc);
      ("public", fun loc -> PUBLIC loc);
      ("private", fun loc -> PRIVATE loc);
      ("protected", fun loc -> PROTECTED loc);
      ("virtual", fun loc -> VIRTUAL loc);
]

let lexicon = H.create 211
let init_lexicon (langind : Flx_cil_cabs.lang_t) =
  H.clear lexicon;
  List.iter 
    (fun (key, builder) -> H.add lexicon key builder)
    c_keywords
  ;
  if langind = `Cxx then
   List.iter 
    (fun (key, builder) -> H.add lexicon key builder)
    cxx_extra_keywords
;;

(* Mark an identifier as a type name. The old mapping is preserved and will 
 * be reinstated when we exit this context *)
let add_type name =
   (* ignore (print_string ("adding type name " ^ name ^ "\n"));  *)
   H.add lexicon name (fun loc -> NAMED_TYPE (name, loc))

let context : string list list ref = ref []

let push_context _ = context := []::!context

let pop_context _ = 
  match !context with
    [] -> raise (InternalError "Empty context stack")
  | con::sub ->
                (context := sub;
                List.iter (fun name -> 
                           (* ignore (print_string ("removing lexicon for " ^ name ^ "\n")); *)
                            H.remove lexicon name) con)

(* Mark an identifier as a variable name. The old mapping is preserved and 
 * will be reinstated when we exit this context  *)
let add_identifier name =
  match !context with
    [] -> () (* Just ignore raise (InternalError "Empty context stack") *)
  | con::sub ->
      (context := (name::con)::sub;
       (*                print_string ("adding IDENT for " ^ name ^ "\n"); *)
       H.add lexicon name (fun loc -> 
         dbgToken (IDENT (name, loc))))


(*
** Useful primitives
*)
let scan_ident id =
  let here = currentLoc () in
  try (H.find lexicon id) here
  (* default to variable name, as opposed to type *)
  with Not_found -> dbgToken (IDENT (id, here))


(*
** Buffer processor
*)
 
let attribDepth = ref 0 (* Remembers the nesting level when parsing 
                         * attributes *)


let init ~(filename: string) ~(lang: Flx_cil_cabs.lang_t) : Lexing.lexbuf =
  attribDepth := 0;
  init_lexicon lang;
  (* Inititialize the pointer in Flx_cil_errormsg *)
  Flx_cil_lexerhack.add_type := add_type;
  Flx_cil_lexerhack.push_context := push_context;
  Flx_cil_lexerhack.pop_context := pop_context;
  Flx_cil_lexerhack.add_identifier := add_identifier;
  E.startParsing filename


let finish () = 
  E.finishParsing ()

(*** Error handling ***)
let error msg =
  E.parse_error msg


(*** escape character management ***)
let scan_escape (char: char) : int64 =
  let result = match char with
    'n' -> '\n'
  | 'r' -> '\r'
  | 't' -> '\t'
  | 'b' -> '\b'
  | 'f' -> '\012'  (* ASCII code 12 *)
  | 'v' -> '\011'  (* ASCII code 11 *)
  | 'a' -> '\007'  (* ASCII code 7 *)
  | 'e' -> '\027'  (* ASCII code 27. This is a GCC extension *)
  | '\'' -> '\''    
  | '"'-> '"'     (* '"' *)
  | '?' -> '?'
  | '\\' -> '\\' 
  | other -> error ("Unrecognized escape sequence: \\" ^ (String.make 1 other))
  in
  Int64.of_int (Char.code result)

let scan_hex_escape str =
  let radix = Int64.of_int 16 in
  let the_value = ref Int64.zero in
  (* start at character 2 to skip the \x *)
  for i = 2 to (String.length str) - 1 do
    let thisDigit = Flx_cil_cabs_helper.valueOfDigit (String.get str i) in
    (* the_value := !the_value * 16 + thisDigit *)
    the_value := Int64.add (Int64.mul !the_value radix) thisDigit
  done;
  !the_value

let scan_oct_escape str =
  let radix = Int64.of_int 8 in
  let the_value = ref Int64.zero in
  (* start at character 1 to skip the \x *)
  for i = 1 to (String.length str) - 1 do
    let thisDigit = Flx_cil_cabs_helper.valueOfDigit (String.get str i) in
    (* the_value := !the_value * 8 + thisDigit *)
    the_value := Int64.add (Int64.mul !the_value radix) thisDigit
  done;
  !the_value

let lex_hex_escape remainder lexbuf =
  let prefix = scan_hex_escape (Lexing.lexeme lexbuf) in
  prefix :: remainder lexbuf

let lex_oct_escape remainder lexbuf =
  let prefix = scan_oct_escape (Lexing.lexeme lexbuf) in
  prefix :: remainder lexbuf

let lex_simple_escape remainder lexbuf =
  let lexchar = Lexing.lexeme_char lexbuf 1 in
  let prefix = scan_escape lexchar in
  prefix :: remainder lexbuf

let lex_unescaped remainder lexbuf =
  let prefix = Int64.of_int (Char.code (Lexing.lexeme_char lexbuf 0)) in
  prefix :: remainder lexbuf

let make_char (i:int64):char =
  let min_val = Int64.zero in
  let max_val = Int64.of_int 255 in
  (* if i < 0 || i > 255 then error*)
  if compare i min_val < 0 || compare i max_val > 0 then begin
    let msg = Printf.sprintf "clexer:make_char: character 0x%Lx too big" i in
    error msg
  end;
  Char.chr (Int64.to_int i)


(* ISO standard locale-specific function to convert a wide character
 * into a sequence of normal characters. Here we work on strings. 
 * We convert L"Hi" to "H\000i\000" 
  matth: this seems unused.
let wbtowc wstr =
  let len = String.length wstr in 
  let dest = String.make (len * 2) '\000' in 
  for i = 0 to len-1 do 
    dest.[i*2] <- wstr.[i] ;
  done ;
  dest
*)

(* This function converst the "Hi" in L"Hi" to { L'H', L'i', L'\0' }
  matth: this seems unused.
let wstr_to_warray wstr =
  let len = String.length wstr in
  let res = ref "{ " in
  for i = 0 to len-1 do
    res := !res ^ (Printf.sprintf "L'%c', " wstr.[i])
  done ;
  res := !res ^ "}" ;
  !res
*)

(* Pragmas get explicit end-of-line tokens.
 * Elsewhere they are silently discarded as whitespace. *)
let pragmaLine = ref false

}

let decdigit = ['0'-'9']
let octdigit = ['0'-'7']
let hexdigit = ['0'-'9' 'a'-'f' 'A'-'F']
let letter = ['a'- 'z' 'A'-'Z']


let usuffix = ['u' 'U']
let lsuffix = "l"|"L"|"ll"|"LL"
let intsuffix = lsuffix | usuffix | usuffix lsuffix | lsuffix usuffix

let hexprefix = '0' ['x' 'X']

let intnum = decdigit+ intsuffix?
let octnum = '0' octdigit+ intsuffix?
let hexnum = hexprefix hexdigit+ intsuffix?

let exponent = ['e' 'E']['+' '-']? decdigit+
let fraction  = '.' decdigit+
let decfloat = (intnum? fraction)
              |(intnum exponent)
              |(intnum? fraction exponent)
              | (intnum '.') 
              | (intnum '.' exponent) 

let hexfraction = hexdigit* '.' hexdigit+ | hexdigit+
let binexponent = ['p' 'P'] ['+' '-']? decdigit+
let hexfloat = hexprefix hexfraction binexponent
             | hexprefix hexdigit+   binexponent

let floatsuffix = ['f' 'F' 'l' 'L']
let floatnum = (decfloat | hexfloat) floatsuffix?

let ident = (letter|'_')(letter|decdigit|'_')* 
let attribident = (letter|'_')(letter|decdigit|'_'|':')
let blank = [' ' '\t' '\012' '\r']+
let escape = '\\' _
let hex_escape = '\\' ['x' 'X'] hexdigit+
let oct_escape = '\\' octdigit octdigit? octdigit? 

rule initial =
        parse   "/*"                    { let _ = comment lexbuf in 
                                          initial lexbuf}
|               "//"                    { endline lexbuf }
|               blank                   {initial lexbuf}
|               '\n'                    { E.newline ();
                                          if !pragmaLine then
                                            begin
                                              pragmaLine := false;
                                              PRAGMA_EOL
                                            end
                                          else
                                            initial lexbuf }
|               '#'                     { hash lexbuf}
|               "_Pragma"               { PRAGMA (currentLoc ()) }
|               '\''                    { CST_CHAR (chr lexbuf, currentLoc ())}
|               "L'"                    { CST_WCHAR (chr lexbuf, currentLoc ()) }
|               '"'                     { (* '"' *)
(* matth: BUG:  this could be either a regular string or a wide string.
 *  e.g. if it's the "world" in 
 *     L"Hello, " "world"
 *  then it should be treated as wide even though there's no L immediately
 *  preceding it.  See test/small1/wchar5.c for a failure case. *)
                                          try CST_STRING (str lexbuf, currentLoc ())
                                          with e -> 
                                             raise (InternalError 
                                                     ("str: " ^ 
                                                      Printexc.to_string e))}
|               "L\""                   { (* weimer: wchar_t string literal *)
                                          try CST_WSTRING(str lexbuf, currentLoc ())
                                          with e -> 
                                             raise (InternalError 
                                                     ("wide string: " ^ 
                                                      Printexc.to_string e))}
|               floatnum                {CST_FLOAT (Lexing.lexeme lexbuf, currentLoc ())}
|               hexnum                  {CST_INT (Lexing.lexeme lexbuf, currentLoc ())}
|               octnum                  {CST_INT (Lexing.lexeme lexbuf, currentLoc ())}
|               intnum                  {CST_INT (Lexing.lexeme lexbuf, currentLoc ())}
|               "!quit!"                {EOF}
|               "..."                   {ELLIPSIS}
|               "+="                    {PLUS_EQ}
|               "-="                    {MINUS_EQ}
|               "*="                    {STAR_EQ}
|               "/="                    {SLASH_EQ}
|               "%="                    {PERCENT_EQ}
|               "|="                    {PIPE_EQ}
|               "&="                    {AND_EQ}
|               "^="                    {CIRC_EQ}
|               "<<="                   {INF_INF_EQ}
|               ">>="                   {SUP_SUP_EQ}
|               "<<"                    {INF_INF}
|               ">>"                    {SUP_SUP}
|               "=="                    {EQ_EQ}
|               "!="                    {EXCLAM_EQ}
|               "<="                    {INF_EQ}
|               ">="                    {SUP_EQ}
|               "="                             {EQ}
|               "<"                             {INF}
|               ">"                             {SUP}
|               "++"                    {PLUS_PLUS (currentLoc ())}
|               "--"                    {MINUS_MINUS (currentLoc ())}
|               "->"                    {ARROW}
|               '+'                             {PLUS (currentLoc ())}
|               '-'                             {MINUS (currentLoc ())}
|               '*'                             {STAR (currentLoc ())}
|               '/'                             {SLASH}
|               '%'                             {PERCENT}
|               '!'                     {EXCLAM (currentLoc ())}
|               "&&"                    {AND_AND (currentLoc ())}
|               "||"                    {PIPE_PIPE}
|               '&'                             {AND (currentLoc ())}
|               '|'                             {PIPE}
|               '^'                             {CIRC}
|               '?'                             {QUEST}
|               ':'                             {COLON}
|               '~'                    {TILDE (currentLoc ())}
        
|               '{'                    {dbgToken (LBRACE (currentLoc ()))}
|               '}'                    {dbgToken (RBRACE (currentLoc ()))}
|               '['                             {LBRACKET}
|               ']'                             {RBRACKET}
|               '('                    {dbgToken (LPAREN (currentLoc ())) }
|               ')'                             {RPAREN}
|               ';'                    {dbgToken (SEMICOLON (currentLoc ())) }
|               ','                             {COMMA}
|               '.'                             {DOT}
|               "sizeof"                {SIZEOF (currentLoc ())}
|               "__asm"                 { if !Flx_cil_cprint.msvcMode then 
                                             MSASM (msasm lexbuf, currentLoc ()) 
                                          else (ASM (currentLoc ())) }
      
(* sm: tree transformation keywords *)
|               "@transform"            {AT_TRANSFORM (currentLoc ())}
|               "@transformExpr"        {AT_TRANSFORMEXPR (currentLoc ())}
|               "@specifier"            {AT_SPECIFIER (currentLoc ())}
|               "@expr"                 {AT_EXPR (currentLoc ())}
|               "@name"                 {AT_NAME}

(* __extension__ is a black. The parser runs into some conflicts if we let it
 * pass *)
|               "__extension__"         {initial lexbuf }
|               ident                   {scan_ident (Lexing.lexeme lexbuf)}
|               eof                     {EOF}
|               _                       {E.parse_error
                                                "Invalid symbol"
                                                (Lexing.lexeme_start lexbuf)
                                                (Lexing.lexeme_end lexbuf);
                                                initial lexbuf}
and comment =
    parse       
      "*/"                              { () }
|     '\n'                              { E.newline (); comment lexbuf }
|               _                       { comment lexbuf }

(* # <line number> <file name> ... *)
and hash = parse
  '\n'          { E.newline (); initial lexbuf}
| blank         { hash lexbuf}
| intnum        { (* We are seeing a line number. This is the number for the 
                   * next line *)
                  E.setCurrentLine (int_of_string (Lexing.lexeme lexbuf) - 1);
                  (* A file name must follow *)
                  file lexbuf }
| "line"        { hash lexbuf } (* MSVC line number info *)
                (* MSVC warning pragmas have very irregular syntax. We parse 
                 * them as a whole line. *)
| "pragma" blank "warning" { let here = currentLoc () in
                             PRAGMA_LINE ("warning" ^ pragma lexbuf, here)
                           }
| "pragma" blank "GCC"     { let here = currentLoc () in
                             PRAGMA_LINE ("GCC" ^ pragma lexbuf, here)
                           }
| "pragma"      { pragmaLine := true; PRAGMA (currentLoc ()) }
| _             { endline lexbuf}

and file =  parse 
        '\n'                    {E.newline (); initial lexbuf}
|       blank                   {file lexbuf}
|       '"' [^ '\012' '\t' '"']* '"'    { (* '"' *)
                                   let n = Lexing.lexeme lexbuf in
                                   let n1 = String.sub n 1 
                                       ((String.length n) - 2) in
                                   E.setCurrentFile n1;
                                 endline lexbuf}

|       _                       {endline lexbuf}

and endline = parse 
        '\n'                    { E.newline (); initial lexbuf}
|   eof                         { EOF }
|       _                       { endline lexbuf}

and pragma = parse
   '\n'                 { E.newline (); "" }
|   _                   { let cur = Lexing.lexeme lexbuf in 
                          cur ^ (pragma lexbuf) }  

and str = parse
        '"'             {[]} (* no nul terminiation in CST_STRING *)
|       hex_escape      {lex_hex_escape str lexbuf}
|       oct_escape      {lex_oct_escape str lexbuf}
|       escape          {lex_simple_escape str lexbuf}
|       _               {lex_unescaped str lexbuf}

and chr =  parse
        '\''            {[]}
|       hex_escape      {lex_hex_escape chr lexbuf}
|       oct_escape      {lex_oct_escape chr lexbuf}
|       escape          {lex_simple_escape chr lexbuf}
|       _               {lex_unescaped chr lexbuf}
        
and msasm = parse
    blank               { msasm lexbuf }
|   '{'                 { msasminbrace lexbuf }
|   _                   { let cur = Lexing.lexeme lexbuf in 
                          cur ^ (msasmnobrace lexbuf) }

and msasminbrace = parse
    '}'                 { "" }
|   _                   { let cur = Lexing.lexeme lexbuf in 
                          cur ^ (msasminbrace lexbuf) }  
and msasmnobrace = parse
   ['}' ';' '\n']       { lexbuf.Lexing.lex_curr_pos <- 
                               lexbuf.Lexing.lex_curr_pos - 1;
                          "" }
|  "__asm"              { lexbuf.Lexing.lex_curr_pos <- 
                               lexbuf.Lexing.lex_curr_pos - 5;
                          "" }
|  _                    { let cur = Lexing.lexeme lexbuf in 

                          cur ^ (msasmnobrace lexbuf) }

and attribute = parse
   '\n'                 { E.newline (); attribute lexbuf }
|  blank                { attribute lexbuf }
|  '('                  { incr attribDepth; LPAREN (currentLoc ()) }
|  ')'                  { decr attribDepth;
                          if !attribDepth = 0 then
                            initial lexbuf (* Skip the last closed paren *)
                          else
                            RPAREN }
|  attribident          { IDENT (Lexing.lexeme lexbuf, currentLoc ()) }

|  '\''                 { CST_CHAR (chr lexbuf, currentLoc ())}
|  '"'                  { (* '"' *)
                                          try CST_STRING (str lexbuf, currentLoc ())
                                          with e -> 
                                             raise (InternalError "str")}
|  floatnum             {CST_FLOAT (Lexing.lexeme lexbuf, currentLoc ())}
|  hexnum               {CST_INT (Lexing.lexeme lexbuf, currentLoc ())}
|  octnum               {CST_INT (Lexing.lexeme lexbuf, currentLoc ())}
|  intnum               {CST_INT (Lexing.lexeme lexbuf, currentLoc ())}


{

}

@h=tangler('src/flx_cil_cparser.mly','data')
@select(h)
/*
(**
** 1.0  3.22.99 Hugues Cass√©    First version.
** 2.0  George Necula 12/12/00: Many extensions
*)
*/
%{
open Flx_cil_cabs
open Flx_cil_cabs_helper
module E = Flx_cil_errormsg

let parse_error msg : unit =       (* sm: c++-mode highlight hack: -> ' <- *)
  E.parse_error msg

let print = print_string


let currentLoc () = 
  let l, f, c = E.getPosition () in
  { lineno   = l; filename = f; byteno   = c; }

let cabslu = {lineno = -10; filename = "cabs loc unknown"; byteno = -10;}

(*
** Expression building
*)
let smooth_expression lst =
  match lst with
    [] -> NOTHING
  | [expr] -> expr
  | _ -> COMMA (lst)


let currentFunctionName = ref "<outside any function>"
    
let announceFunctionName ((n, decl, _, _):name) =
  !Flx_cil_lexerhack.add_identifier n;
  (* Start a context that includes the parameter names and the whole body. 
   * Will pop when we finish parsing the function body *)
  !Flx_cil_lexerhack.push_context ();
  (* Go through all the parameter names and mark them as identifiers *)
  let rec findProto = function
      PROTO (d, args, _) when isJUSTBASE d -> 
        List.iter (fun (_, (an, _, _, _)) -> !Flx_cil_lexerhack.add_identifier an) args

    | PROTO (d, _, _) -> findProto d
    | PARENTYPE (_, d, _) -> findProto d
    | PTR (_, d) -> findProto d
    | ARRAY (d, _, _) -> findProto d
    | _ -> parse_error "Cannot find the prototype in a function definition";
           raise Parsing.Parse_error 

  and isJUSTBASE = function
      JUSTBASE -> true
    | PARENTYPE (_, d, _) -> isJUSTBASE d
    | _ -> false
  in
  findProto decl;
  currentFunctionName := n



let applyPointer (ptspecs: attribute list list) (dt: decl_type)  
       : decl_type = 
  (* Outer specification first *)
  let rec loop = function
      [] -> dt
    | attrs :: rest -> PTR(attrs, loop rest)
  in
  loop ptspecs

let doDeclaration (loc: cabsloc) (specs: spec_elem list) (nl: init_name list) : definition = 
  if isTypedef specs then begin
    (* Tell the lexer about the new type names *)
    List.iter (fun ((n, _, _, _), _) -> !Flx_cil_lexerhack.add_type n) nl;
    TYPEDEF ((specs, List.map (fun (n, _) -> n) nl), loc)
  end else
    if nl = [] then
      ONLYTYPEDEF (specs, loc)
    else begin
      (* Tell the lexer about the new variable names *)
      List.iter (fun ((n, _, _, _), _) -> !Flx_cil_lexerhack.add_identifier n) nl;
      DECDEF ((specs, nl), loc)  
    end


let doFunctionDef (loc: cabsloc)
                  (lend: cabsloc)
                  (specs: spec_elem list) 
                  (n: name) 
                  (b: block) : definition = 
  let fname = (specs, n) in
  FUNDEF (fname, b, loc, lend)


let doOldParDecl (names: string list)
                 ((pardefs: name_group list), (isva: bool)) 
    : single_name list * bool =
  let findOneName n =
    (* Search in pardefs for the definition for this parameter *)
    let rec loopGroups = function
        [] -> ([SpecType Tint], (n, JUSTBASE, [], cabslu))
      | (specs, names) :: restgroups ->
          let rec loopNames = function
              [] -> loopGroups restgroups
            | ((n',_, _, _) as sn) :: _ when n' = n -> (specs, sn)
            | _ :: restnames -> loopNames restnames
          in
          loopNames names
    in
    loopGroups pardefs
  in
  let args = List.map findOneName names in
  (args, isva)

let checkConnective (s : string) : unit =
begin
  (* checking this means I could possibly have more connectives, with *)
  (* different meaning *)
  if (s <> "to") then (
    parse_error "transformer connective must be 'to'";
    raise Parsing.Parse_error
  )
  else ()
end

(* takes a not-nul-terminated list, and converts it to a string. *)
let rec intlist_to_string (str: int64 list):string =
  match str with
    [] -> ""  (* add nul-termination *)
  | value::rest ->
      let this_char = 
        if (compare value (Int64.of_int 255) > 0) 
           || (compare value Int64.zero < 0)
        then begin
          let msg = Printf.sprintf "cparser:intlist_to_string: character 0x%Lx too big" value in
          parse_error msg;
          raise Parsing.Parse_error
        end 
        else 
          String.make 1 (Char.chr (Int64.to_int value))
      in
      this_char ^ (intlist_to_string rest)

let fst3 (result, _, _) = result
let snd3 (_, result, _) = result
let trd3 (_, _, result) = result

%}

%token <string * Flx_cil_cabs.cabsloc> IDENT
%token <int64 list * Flx_cil_cabs.cabsloc> CST_CHAR
%token <int64 list * Flx_cil_cabs.cabsloc> CST_WCHAR
%token <string * Flx_cil_cabs.cabsloc> CST_INT
%token <string * Flx_cil_cabs.cabsloc> CST_FLOAT
%token <string * Flx_cil_cabs.cabsloc> NAMED_TYPE

/* Each character is its own list element, and the terminating nul is not
   included in this list. */
%token <int64 list * Flx_cil_cabs.cabsloc> CST_STRING   
%token <int64 list * Flx_cil_cabs.cabsloc> CST_WSTRING

%token EOF
%token<Flx_cil_cabs.cabsloc> BOOL CHAR INT DOUBLE FLOAT COMPLEX IMAGINARY VOID INT64 INT32
%token<Flx_cil_cabs.cabsloc> ENUM STRUCT TYPEDEF UNION
%token<Flx_cil_cabs.cabsloc> SIGNED UNSIGNED LONG SHORT
%token<Flx_cil_cabs.cabsloc> VOLATILE EXTERN STATIC CONST RESTRICT AUTO REGISTER
%token<Flx_cil_cabs.cabsloc> THREAD
%token<Flx_cil_cabs.cabsloc> CLASS NAMESPACE USING 
%token<Flx_cil_cabs.cabsloc> TYPENAME TEMPLATENAME
%token<Flx_cil_cabs.cabsloc> PUBLIC PRIVATE PROTECTED VIRTUAL

%token<Flx_cil_cabs.cabsloc> SIZEOF ALIGNOF

%token EQ PLUS_EQ MINUS_EQ STAR_EQ SLASH_EQ PERCENT_EQ
%token AND_EQ PIPE_EQ CIRC_EQ INF_INF_EQ SUP_SUP_EQ
%token ARROW DOT

%token EQ_EQ EXCLAM_EQ INF SUP INF_EQ SUP_EQ
%token<Flx_cil_cabs.cabsloc> PLUS MINUS STAR
%token SLASH PERCENT
%token<Flx_cil_cabs.cabsloc> TILDE AND
%token PIPE CIRC
%token<Flx_cil_cabs.cabsloc> EXCLAM AND_AND
%token PIPE_PIPE
%token INF_INF SUP_SUP
%token<Flx_cil_cabs.cabsloc> PLUS_PLUS MINUS_MINUS

%token RPAREN 
%token<Flx_cil_cabs.cabsloc> LPAREN RBRACE
%token<Flx_cil_cabs.cabsloc> LBRACE
%token LBRACKET RBRACKET
%token COLON
%token<Flx_cil_cabs.cabsloc> SEMICOLON
%token COMMA ELLIPSIS QUEST

%token<Flx_cil_cabs.cabsloc> BREAK CONTINUE GOTO RETURN
%token<Flx_cil_cabs.cabsloc> SWITCH CASE DEFAULT
%token<Flx_cil_cabs.cabsloc> WHILE DO FOR
%token<Flx_cil_cabs.cabsloc> IF TRY EXCEPT FINALLY
%token ELSE 

%token<Flx_cil_cabs.cabsloc> ATTRIBUTE INLINE ASM TYPEOF FUNCTION__ PRETTY_FUNCTION__
%token LABEL__
%token<Flx_cil_cabs.cabsloc> BUILTIN_VA_ARG
%token BUILTIN_VA_LIST
%token BLOCKATTRIBUTE
%token<Flx_cil_cabs.cabsloc> DECLSPEC
%token<string * Flx_cil_cabs.cabsloc> MSASM MSATTR
%token<Flx_cil_cabs.cabsloc> PRAGMA
%token<string * Flx_cil_cabs.cabsloc> PRAGMA_LINE
%token PRAGMA_EOL

/* sm: cabs tree transformation specification keywords */
%token<Flx_cil_cabs.cabsloc> AT_TRANSFORM AT_TRANSFORMEXPR AT_SPECIFIER AT_EXPR
%token AT_NAME

/* operator precedence */
%nonassoc       IF
%nonassoc       ELSE


%left   COMMA
%right  EQ PLUS_EQ MINUS_EQ STAR_EQ SLASH_EQ PERCENT_EQ
                AND_EQ PIPE_EQ CIRC_EQ INF_INF_EQ SUP_SUP_EQ
%right  QUEST COLON
%left   PIPE_PIPE
%left   AND_AND
%left   PIPE
%left   CIRC
%left   AND
%left   EQ_EQ EXCLAM_EQ
%left   INF SUP INF_EQ SUP_EQ
%left   INF_INF SUP_SUP
%left   PLUS MINUS
%left   STAR SLASH PERCENT CONST RESTRICT VOLATILE
%right  EXCLAM TILDE PLUS_PLUS MINUS_MINUS CAST RPAREN ADDROF SIZEOF ALIGNOF
%left   LBRACKET
%left   DOT ARROW LPAREN LBRACE
%right  NAMED_TYPE     /* We'll use this to handle redefinitions of
                        * NAMED_TYPE as variables */
%left   IDENT

/* Non-terminals informations */
%start interpret file
%type <Flx_cil_cabs.definition list> file interpret globals

%type <Flx_cil_cabs.definition> global


%type <Flx_cil_cabs.attribute list> attributes attributes_with_asm asmattr
%type <Flx_cil_cabs.statement> statement
%type <Flx_cil_cabs.constant * cabsloc> constant
%type <string * cabsloc> string_constant
%type <Flx_cil_cabs.expression * cabsloc> expression
%type <Flx_cil_cabs.expression> opt_expression
%type <Flx_cil_cabs.init_expression> init_expression
%type <Flx_cil_cabs.expression list * cabsloc> comma_expression
%type <Flx_cil_cabs.expression list * cabsloc> paren_comma_expression
%type <Flx_cil_cabs.expression list> arguments
%type <Flx_cil_cabs.expression list> bracket_comma_expression
%type <int64 list * cabsloc> string_list 
%type <int64 list * cabsloc> wstring_list

%type <Flx_cil_cabs.initwhat * Flx_cil_cabs.init_expression> initializer
%type <(Flx_cil_cabs.initwhat * Flx_cil_cabs.init_expression) list> initializer_list
%type <Flx_cil_cabs.initwhat> init_designators init_designators_opt

%type <spec_elem list * cabsloc> decl_spec_list
%type <typeSpecifier * cabsloc> type_spec
%type <Flx_cil_cabs.field_group list> struct_decl_list


%type <Flx_cil_cabs.name> old_proto_decl
%type <Flx_cil_cabs.single_name> parameter_decl
%type <Flx_cil_cabs.enum_item> enumerator
%type <Flx_cil_cabs.enum_item list> enum_list
%type <Flx_cil_cabs.definition> declaration function_def
%type <cabsloc * spec_elem list * name> function_def_start
%type <Flx_cil_cabs.spec_elem list * Flx_cil_cabs.decl_type> type_name
%type <Flx_cil_cabs.block * cabsloc * cabsloc> block
%type <Flx_cil_cabs.statement list> block_element_list
%type <string list> local_labels local_label_names
%type <string list> old_parameter_list_ne

%type <Flx_cil_cabs.init_name> init_declarator
%type <Flx_cil_cabs.init_name list> init_declarator_list
%type <Flx_cil_cabs.name> declarator
%type <Flx_cil_cabs.name * expression option> field_decl
%type <(Flx_cil_cabs.name * expression option) list> field_decl_list
%type <string * Flx_cil_cabs.decl_type> direct_decl
%type <Flx_cil_cabs.decl_type> abs_direct_decl abs_direct_decl_opt
%type <Flx_cil_cabs.decl_type * Flx_cil_cabs.attribute list> abstract_decl

 /* (* Each element is a "* <type_quals_opt>". *) */
%type <attribute list list * cabsloc> pointer pointer_opt
%type <Flx_cil_cabs.cabsloc> location
%type <Flx_cil_cabs.spec_elem * cabsloc> cvspec
%%

interpret:
  file EOF                              {$1}
;
file: globals                           {$1}
;
globals:
  /* empty */                           { [] }
| global globals                        { $1 :: $2 }
| SEMICOLON globals                     { $2 }
;

location:
   /* empty */                  { currentLoc () }  %prec IDENT


/*** Global Definition ***/
global:
| declaration                           { $1 }
| function_def                          { $1 } 
/*(* Some C header files ar shared with the C++ compiler and have linkage 
   * specification *)*/
| EXTERN string_constant declaration    { LINKAGE (fst $2, snd $2, [ $3 ]) }
| EXTERN string_constant LBRACE globals RBRACE 
                                        { LINKAGE (fst $2, snd $2, $4)  }
| ASM LPAREN string_constant RPAREN SEMICOLON
                                        { GLOBASM (fst $3, $1) }
| PRAGMA attr PRAGMA_EOL                { PRAGMA ($2, $1) }
| PRAGMA attr SEMICOLON PRAGMA_EOL      { PRAGMA ($2, $1) }
| PRAGMA_LINE                           { PRAGMA (VARIABLE (fst $1), 
                                                  snd $1) }
/* (* Old-style function prototype. This should be somewhere else, like in
    * "declaration". For now we keep it at global scope only because in local
    * scope it looks too much like a function call  *) */
| IDENT LPAREN old_parameter_list_ne RPAREN old_pardef_list SEMICOLON
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl $3 $5 in 
                             (* Make the function declarator *)
                             doDeclaration (snd $1) []
                               [((fst $1, PROTO(JUSTBASE, pardecl,isva), [], cabslu),
                                 NO_INIT)]
                            }
/* (* Old style function prototype, but without any arguments *) */
| IDENT LPAREN RPAREN  SEMICOLON
                           { (* Make the function declarator *)
                             doDeclaration (snd $1) []
                               [((fst $1, PROTO(JUSTBASE,[],false), [], cabslu),
                                 NO_INIT)]
                            }
/* transformer for a toplevel construct */
| AT_TRANSFORM LBRACE global RBRACE  IDENT/*to*/  LBRACE globals RBRACE {
    checkConnective(fst $5);
    TRANSFORMER($3, $7, $1)
  }
/* transformer for an expression */
| AT_TRANSFORMEXPR LBRACE expression RBRACE  IDENT/*to*/  LBRACE expression RBRACE {
    checkConnective(fst $5);
    EXPRTRANSFORMER(fst $3, fst $7, $1)
  }
| location error SEMICOLON { PRAGMA (VARIABLE "parse_error", $1) }
;

id_or_typename:
    IDENT                               {fst $1}
|   NAMED_TYPE                          {fst $1}
|   AT_NAME LPAREN IDENT RPAREN         { "@name(" ^ fst $3 ^ ")" }     /* pattern variable name */
;

maybecomma:
   /* empty */                          { () }
|  COMMA                                { () }
;

/* *** Expressions *** */


expression:
                constant
                        {CONSTANT (fst $1), snd $1}
|               IDENT
                        {VARIABLE (fst $1), snd $1}
|               SIZEOF expression
                        {EXPR_SIZEOF (fst $2), $1}
|               SIZEOF LPAREN type_name RPAREN
                        {let b, d = $3 in TYPE_SIZEOF (b, d), $1}
|               ALIGNOF expression
                        {EXPR_ALIGNOF (fst $2), $1}
|               ALIGNOF LPAREN type_name RPAREN
                        {let b, d = $3 in TYPE_ALIGNOF (b, d), $1}
|               PLUS expression
                        {UNARY (PLUS, fst $2), $1}
|               MINUS expression
                        {UNARY (MINUS, fst $2), $1}
|               STAR expression
                        {UNARY (MEMOF, fst $2), $1}
|               AND expression                          %prec ADDROF
                        {UNARY (ADDROF, fst $2), $1}
|               EXCLAM expression
                        {UNARY (NOT, fst $2), $1}
|               TILDE expression
                        {UNARY (BNOT, fst $2), $1}
|               PLUS_PLUS expression                    %prec CAST
                        {UNARY (PREINCR, fst $2), $1}
|               expression PLUS_PLUS
                        {UNARY (POSINCR, fst $1), snd $1}
|               MINUS_MINUS expression                  %prec CAST
                        {UNARY (PREDECR, fst $2), $1}
|               expression MINUS_MINUS
                        {UNARY (POSDECR, fst $1), snd $1}
|               expression ARROW id_or_typename
                        {MEMBEROFPTR (fst $1, $3), snd $1}
|               expression DOT id_or_typename
                        {MEMBEROF (fst $1, $3), snd $1}
|               LPAREN block RPAREN
                        { GNU_BODY (fst3 $2), $1 }
|               paren_comma_expression
                        {smooth_expression (fst $1), snd $1}
|               expression LPAREN arguments RPAREN
                        {CALL (fst $1, $3), snd $1}
|               BUILTIN_VA_ARG LPAREN expression COMMA type_name RPAREN
                        { let b, d = $5 in
                          CALL (VARIABLE "__builtin_va_arg", 
                                [fst $3; TYPE_SIZEOF (b, d)]), $1 }
|               expression bracket_comma_expression
                        {INDEX (fst $1, smooth_expression $2), snd $1}
|               expression QUEST opt_expression COLON expression
                        {QUESTION (fst $1, $3, fst $5), snd $1}
|               expression PLUS expression
                        {BINARY(ADD, fst $1, fst $3), snd $1}
|               expression MINUS expression
                        {BINARY(SUB, fst $1, fst $3), snd $1}
|               expression STAR expression
                        {BINARY(MUL, fst $1, fst $3), snd $1}
|               expression SLASH expression
                        {BINARY(DIV, fst $1, fst $3), snd $1}
|               expression PERCENT expression
                        {BINARY(MOD, fst $1, fst $3), snd $1}
|               expression AND_AND expression
                        {BINARY(AND, fst $1, fst $3), snd $1}
|               expression PIPE_PIPE expression
                        {BINARY(OR, fst $1, fst $3), snd $1}
|               expression AND expression
                        {BINARY(BAND, fst $1, fst $3), snd $1}
|               expression PIPE expression
                        {BINARY(BOR, fst $1, fst $3), snd $1}
|               expression CIRC expression
                        {BINARY(XOR, fst $1, fst $3), snd $1}
|               expression EQ_EQ expression
                        {BINARY(EQ, fst $1, fst $3), snd $1}
|               expression EXCLAM_EQ expression
                        {BINARY(NE, fst $1, fst $3), snd $1}
|               expression INF expression
                        {BINARY(LT, fst $1, fst $3), snd $1}
|               expression SUP expression
                        {BINARY(GT, fst $1, fst $3), snd $1}
|               expression INF_EQ expression
                        {BINARY(LE, fst $1, fst $3), snd $1}
|               expression SUP_EQ expression
                        {BINARY(GE, fst $1, fst $3), snd $1}
|               expression  INF_INF expression
                        {BINARY(SHL, fst $1, fst $3), snd $1}
|               expression  SUP_SUP expression
                        {BINARY(SHR, fst $1, fst $3), snd $1}
|               expression EQ expression
                        {BINARY(ASSIGN, fst $1, fst $3), snd $1}
|               expression PLUS_EQ expression
                        {BINARY(ADD_ASSIGN, fst $1, fst $3), snd $1}
|               expression MINUS_EQ expression
                        {BINARY(SUB_ASSIGN, fst $1, fst $3), snd $1}
|               expression STAR_EQ expression
                        {BINARY(MUL_ASSIGN, fst $1, fst $3), snd $1}
|               expression SLASH_EQ expression
                        {BINARY(DIV_ASSIGN, fst $1, fst $3), snd $1}
|               expression PERCENT_EQ expression
                        {BINARY(MOD_ASSIGN, fst $1, fst $3), snd $1}
|               expression AND_EQ expression
                        {BINARY(BAND_ASSIGN, fst $1, fst $3), snd $1}
|               expression PIPE_EQ expression
                        {BINARY(BOR_ASSIGN, fst $1, fst $3), snd $1}
|               expression CIRC_EQ expression
                        {BINARY(XOR_ASSIGN, fst $1, fst $3), snd $1}
|               expression INF_INF_EQ expression        
                        {BINARY(SHL_ASSIGN, fst $1, fst $3), snd $1}
|               expression SUP_SUP_EQ expression
                        {BINARY(SHR_ASSIGN, fst $1, fst $3), snd $1}
|               LPAREN type_name RPAREN expression
                         { CAST($2, SINGLE_INIT (fst $4)), $1 }
/* (* We handle GCC constructor expressions *) */
|               LPAREN type_name RPAREN LBRACE initializer_list_opt RBRACE
                         { CAST($2, COMPOUND_INIT $5), $1 }
/* (* GCC's address of labels *)  */
|               AND_AND IDENT  { LABELADDR (fst $2), $1 }
|               AT_EXPR LPAREN IDENT RPAREN         /* expression pattern variable */
                         { EXPR_PATTERN(fst $3), $1 }
;

constant:
    CST_INT                             {CONST_INT (fst $1), snd $1}
|   CST_FLOAT                           {CONST_FLOAT (fst $1), snd $1}
|   CST_CHAR                            {CONST_CHAR (fst $1), snd $1}
|   CST_WCHAR                           {CONST_WCHAR (fst $1), snd $1}
|   string_constant                     {CONST_STRING (fst $1), snd $1}
|   wstring_list                        {CONST_WSTRING (fst $1), snd $1}
;

string_constant:
/* Now that we know this constant isn't part of a wstring, convert it
   back to a string for easy viewing. */
    string_list                         {intlist_to_string (fst $1), snd $1 }
;
one_string_constant:
/* Don't concat multiple strings.  For asm templates. */
    CST_STRING                          {intlist_to_string (fst $1) }
;
string_list:
    one_string                          { $1 }
|   string_list one_string              { (fst $1) @ (fst $2), snd $1 }
;

wstring_list:
    CST_WSTRING                         { $1 }
|   wstring_list one_string             { (fst $1) @ (fst $2), snd $1 }
|   wstring_list CST_WSTRING            { (fst $1) @ (fst $2), snd $1 }
/* Only the first string in the list needs an L, so L"a" "b" is the same
 * as L"ab" or L"a" L"b". */

one_string: 
    CST_STRING                          {$1}
|   FUNCTION__                          {(Flx_cil_cabs_helper.explodeStringToInts 
                                            !currentFunctionName), $1}
|   PRETTY_FUNCTION__                   {(Flx_cil_cabs_helper.explodeStringToInts 
                                            !currentFunctionName), $1}
;    

init_expression:
     expression         { SINGLE_INIT (fst $1) }
|    LBRACE initializer_list_opt RBRACE
                        { COMPOUND_INIT $2}

initializer_list:    /* ISO 6.7.8. Allow a trailing COMMA */
    initializer                             { [$1] }
|   initializer COMMA initializer_list_opt  { $1 :: $3 }
;
initializer_list_opt:
    /* empty */                             { [] }
|   initializer_list                        { $1 }
;
initializer: 
    init_designators eq_opt init_expression { ($1, $3) }
|   gcc_init_designators init_expression { ($1, $2) }
|                       init_expression { (NEXT_INIT, $1) }
;
eq_opt: 
   EQ                        { () }
   /*(* GCC allows missing = *)*/
|  /*(* empty *)*/               { () }
;
init_designators: 
    DOT id_or_typename init_designators_opt      { INFIELD_INIT($2, $3) }
|   LBRACKET  expression RBRACKET init_designators_opt
                                        { ATINDEX_INIT(fst $2, $4) }
|   LBRACKET  expression ELLIPSIS expression RBRACKET
                                        { ATINDEXRANGE_INIT(fst $2, fst $4) }
;         
init_designators_opt:
   /* empty */                          { NEXT_INIT }
|  init_designators                     { $1 }
;

gcc_init_designators:  /*(* GCC supports these strange things *)*/
   id_or_typename COLON                 { INFIELD_INIT($1, NEXT_INIT) }
;

arguments: 
                /* empty */         { [] }
|               comma_expression    { fst $1 }
;

opt_expression:
                /* empty */
                        {NOTHING}
|               comma_expression
                        {smooth_expression (fst $1)}
;

comma_expression:
                expression                        {[fst $1], snd $1}
|               expression COMMA comma_expression { fst $1 :: fst $3, snd $1 }
|               error COMMA comma_expression      { $3 }
;

comma_expression_opt:
                /* empty */         { NOTHING }
|               comma_expression    { smooth_expression (fst $1) }
;

paren_comma_expression:
  LPAREN comma_expression RPAREN                   { $2 }
| LPAREN error RPAREN                              { [], $1 }
;

bracket_comma_expression:
  LBRACKET comma_expression RBRACKET                   { fst $2 }
| LBRACKET error RBRACKET                              { [] }
;


/*** statements ***/
block: /* ISO 6.8.2 */
    block_begin local_labels block_attrs block_element_list RBRACE
                                         {!Flx_cil_lexerhack.pop_context();
                                          { blabels = $2;
                                            battrs = $3;
                                            bstmts = $4 },
                                            $1, $5
                                         } 
|   error location RBRACE                { { blabels = [];
                                             battrs  = [];
                                             bstmts  = [] },
                                             $2, $3
                                         }
;
block_begin:
    LBRACE                               {!Flx_cil_lexerhack.push_context (); $1}
;

block_attrs:
   /* empty */                                              { [] }
|  BLOCKATTRIBUTE paren_attr_list_ne
                                        { [("__blockattribute__", $2)] }
;

/* statements and declarations in a block, in any order (for C99 support) */
block_element_list:
    /* empty */                          { [] }
|   declaration block_element_list       { DEFINITION($1) :: $2 }
|   statement block_element_list         { $1 :: $2 }
/*(* GCC accepts a label at the end of a block *)*/
|   IDENT COLON                          { [ LABEL (fst $1, NOP (snd $1), 
                                                    snd $1)] }
;

local_labels:
   /* empty */                                       { [] }
|  LABEL__ local_label_names SEMICOLON local_labels  { $2 @ $4 }
;
local_label_names: 
   IDENT                                 { [ fst $1 ] }
|  IDENT COMMA local_label_names         { fst $1 :: $3 }
;



statement:
    SEMICOLON           {NOP $1 }
|   comma_expression SEMICOLON
                        {COMPUTATION (smooth_expression (fst $1), snd $1)}
|   block               {BLOCK (fst3 $1, snd3 $1)}
|   IF paren_comma_expression statement                    %prec IF
                        {IF (smooth_expression (fst $2), $3, NOP $1, $1)}
|   IF paren_comma_expression statement ELSE statement
                        {IF (smooth_expression (fst $2), $3, $5, $1)}
|   SWITCH paren_comma_expression statement
                        {SWITCH (smooth_expression (fst $2), $3, $1)}
|   WHILE paren_comma_expression statement
                        {WHILE (smooth_expression (fst $2), $3, $1)}
|   DO statement WHILE paren_comma_expression SEMICOLON
                                 {DOWHILE (smooth_expression (fst $4), $2, $1)}
|   FOR LPAREN for_clause opt_expression
                SEMICOLON opt_expression RPAREN statement
                                 {FOR ($3, $4, $6, $8, $1)}
|   IDENT COLON statement
                                 {LABEL (fst $1, $3, snd $1)}
|   CASE expression COLON
                                 {CASE (fst $2, NOP $1, $1)}
|   CASE expression ELLIPSIS expression COLON
                                 {CASERANGE (fst $2, fst $4, NOP $1, $1)}
|   DEFAULT COLON
                                 {DEFAULT (NOP $1, $1)}
|   RETURN SEMICOLON             {RETURN (NOTHING, $1)}
|   RETURN comma_expression SEMICOLON
                                 {RETURN (smooth_expression (fst $2), $1)}
|   BREAK SEMICOLON     {BREAK $1}
|   CONTINUE SEMICOLON   {CONTINUE $1}
|   GOTO IDENT SEMICOLON
                                 {GOTO (fst $2, $1)}
|   GOTO STAR comma_expression SEMICOLON 
                                 { COMPGOTO (smooth_expression (fst $3), $1) }
|   ASM asmattr LPAREN asmtemplate asmoutputs RPAREN SEMICOLON
                        { let (outs,ins,clobs) = $5 in
                          ASM ($2, $4, outs, ins, clobs, $1) }
|   MSASM               { ASM ([], [fst $1], [], [], [], snd $1)}
|   TRY block EXCEPT paren_comma_expression block
                        { let b, _, _ = $2 in
                          let h, _, _ = $5 in
                          if not !Flx_cil_cprint.msvcMode then 
                            parse_error "try/except in GCC code";
                          TRY_EXCEPT (b, COMMA (fst $4), h, $1) }
|   TRY block FINALLY block 
                        { let b, _, _ = $2 in
                          let h, _, _ = $4 in
                          if not !Flx_cil_cprint.msvcMode then 
                            parse_error "try/finally in GCC code";
                          TRY_FINALLY (b, h, $1) }

|   error location   SEMICOLON   { (NOP $2)}
;


for_clause: 
    opt_expression SEMICOLON     { FC_EXP $1 }
|   declaration                  { FC_DECL $1 }
;

declaration:                                /* ISO 6.7.*/
    decl_spec_list init_declarator_list SEMICOLON
                                       { doDeclaration (snd $1) (fst $1) $2 }
|   decl_spec_list SEMICOLON           { doDeclaration (snd $1) (fst $1) [] }
;
init_declarator_list:                       /* ISO 6.7 */
    init_declarator                              { [$1] }
|   init_declarator COMMA init_declarator_list   { $1 :: $3 }

;
init_declarator:                             /* ISO 6.7 */
    declarator                          { ($1, NO_INIT) }
|   declarator EQ init_expression
                                        { ($1, $3) }
;

decl_spec_list:                         /* ISO 6.7 */
                                        /* ISO 6.7.1 */
|   TYPEDEF decl_spec_list_opt          { SpecTypedef :: $2, $1  }    
|   EXTERN decl_spec_list_opt           { SpecStorage EXTERN :: $2, $1 }
|   STATIC  decl_spec_list_opt          { SpecStorage STATIC :: $2, $1 }
|   AUTO   decl_spec_list_opt           { SpecStorage AUTO :: $2, $1 }
|   REGISTER decl_spec_list_opt         { SpecStorage REGISTER :: $2, $1}
                                        /* ISO 6.7.2 */
|   type_spec decl_spec_list_opt_no_named { SpecType (fst $1) :: $2, snd $1 }
                                        /* ISO 6.7.4 */
|   INLINE decl_spec_list_opt           { SpecInline :: $2, $1 }
|   cvspec decl_spec_list_opt           { (fst $1) :: $2, snd $1 }
|   attribute_nocv decl_spec_list_opt   { SpecAttr (fst $1) :: $2, snd $1 }
/* specifier pattern variable (must be last in spec list) */
|   AT_SPECIFIER LPAREN IDENT RPAREN    { [ SpecPattern(fst $3) ], $1 }
;
/* (* In most cases if we see a NAMED_TYPE we must shift it. Thus we declare 
    * NAMED_TYPE to have right associativity  *) */
decl_spec_list_opt: 
    /* empty */                         { [] } %prec NAMED_TYPE
|   decl_spec_list                      { fst $1 }
;
/* (* We add this separate rule to handle the special case when an appearance 
    * of NAMED_TYPE should not be considered as part of the specifiers but as 
    * part of the declarator. IDENT has higher precedence than NAMED_TYPE  *)
 */
decl_spec_list_opt_no_named: 
    /* empty */                         { [] } %prec IDENT
|   decl_spec_list                      { fst $1 }
;
type_spec:   /* ISO 6.7.2 */
    VOID            { Tvoid, $1}
|   BOOL            { Tbool, $1 }
|   CHAR            { Tchar, $1 }
|   SHORT           { Tshort, $1 }
|   INT             { Tint, $1 }
|   LONG            { Tlong, $1 }
|   INT64           { Tint64, $1 }
|   FLOAT           { Tfloat, $1 }
|   COMPLEX         { Tcomplex, $1 }
|   IMAGINARY       { Timaginary, $1 }
|   DOUBLE          { Tdouble, $1 }
|   SIGNED          { Tsigned, $1 }
|   UNSIGNED        { Tunsigned, $1 }

|   STRUCT                 id_or_typename
                                                   { Tstruct ($2, None,    []), $1 }
|   STRUCT                 id_or_typename LBRACE struct_decl_list RBRACE
                                                   { Tstruct ($2, Some $4, []), $1 }
|   STRUCT                                LBRACE struct_decl_list RBRACE
                                                   { Tstruct ("", Some $3, []), $1 }
|   STRUCT just_attributes id_or_typename LBRACE struct_decl_list RBRACE
                                                   { Tstruct ($3, Some $5, $2), $1 }
|   STRUCT just_attributes                LBRACE struct_decl_list RBRACE
                                                   { Tstruct ("", Some $4, $2), $1 }
|   CLASS                 id_or_typename
                                                   { Tstruct ($2, None,    []), $1 }
|   CLASS                 id_or_typename LBRACE struct_decl_list RBRACE
                                                   { Tstruct ($2, Some $4, []), $1 }
|   CLASS                                LBRACE struct_decl_list RBRACE
                                                   { Tstruct ("", Some $3, []), $1 }
|   CLASS just_attributes id_or_typename LBRACE struct_decl_list RBRACE
                                                   { Tstruct ($3, Some $5, $2), $1 }
|   CLASS just_attributes                LBRACE struct_decl_list RBRACE
                                                   { Tstruct ("", Some $4, $2), $1 }
|   UNION                  id_or_typename
                                                   { Tunion  ($2, None,    []), $1 }
|   UNION                  id_or_typename LBRACE struct_decl_list RBRACE
                                                   { Tunion  ($2, Some $4, []), $1 }
|   UNION                                 LBRACE struct_decl_list RBRACE
                                                   { Tunion  ("", Some $3, []), $1 }
|   UNION  just_attributes id_or_typename LBRACE struct_decl_list RBRACE
                                                   { Tunion  ($3, Some $5, $2), $1 }
|   UNION  just_attributes                LBRACE struct_decl_list RBRACE
                                                   { Tunion  ("", Some $4, $2), $1 }
|   ENUM                   id_or_typename
                                                   { Tenum   ($2, None,    []), $1 }
|   ENUM                   id_or_typename LBRACE enum_list maybecomma RBRACE
                                                   { Tenum   ($2, Some $4, []), $1 }
|   ENUM                                  LBRACE enum_list maybecomma RBRACE
                                                   { Tenum   ("", Some $3, []), $1 }
|   ENUM   just_attributes id_or_typename LBRACE enum_list maybecomma RBRACE
                                                   { Tenum   ($3, Some $5, $2), $1 }
|   ENUM   just_attributes                LBRACE enum_list maybecomma RBRACE
                                                   { Tenum   ("", Some $4, $2), $1 }
|   NAMED_TYPE      { Tnamed (fst $1), snd $1 }
|   TYPEOF LPAREN expression RPAREN     { TtypeofE (fst $3), $1 }
|   TYPEOF LPAREN type_name RPAREN      { let s, d = $3 in
                                          TtypeofT (s, d), $1 }
;
struct_decl_list: /* (* ISO 6.7.2. Except that we allow empty structs. We 
                      * also allow missing field names. *)
                   */
   /* empty */                           { [] }
|  decl_spec_list                 SEMICOLON struct_decl_list
                                         { (fst $1, 
                                            [(missingFieldDecl, None)]) :: $3 }
/*(* GCC allows extra semicolons *)*/
|                                 SEMICOLON struct_decl_list
                                         { $2 }
|  decl_spec_list field_decl_list SEMICOLON struct_decl_list
                                          { (fst $1, $2) 
                                            :: $4 }
|  error                          SEMICOLON struct_decl_list
                                          { $3 } 
;
field_decl_list: /* (* ISO 6.7.2 *) */
    field_decl                           { [$1] }
|   field_decl COMMA field_decl_list     { $1 :: $3 }
;
field_decl: /* (* ISO 6.7.2. Except that we allow unnamed fields. *) */
|   declarator                      { ($1, None) }
|   declarator COLON expression     { ($1, Some (fst $3)) }    
|              COLON expression     { (missingFieldDecl, Some (fst $2)) }
;

enum_list: /* (* ISO 6.7.2.2 *) */
    enumerator                          {[$1]}
|   enum_list COMMA enumerator          {$1 @ [$3]}
|   enum_list COMMA error               { $1 } 
;
enumerator:     
    IDENT                       {(fst $1, NOTHING, snd $1)}
|   IDENT EQ expression         {(fst $1, fst $3, snd $1)}
;


declarator:  /* (* ISO 6.7.5. Plus Microsoft declarators.*) */
   pointer_opt direct_decl attributes_with_asm
                                         { let (n, decl) = $2 in
                                           (n, applyPointer (fst $1) decl, $3, snd $1) }
;


direct_decl: /* (* ISO 6.7.5 *) */
                                   /* (* We want to be able to redefine named
                                    * types as variable names *) */
|   id_or_typename                 { ($1, JUSTBASE) }

|   LPAREN attributes declarator RPAREN
                                   { let (n,decl,al,loc) = $3 in
                                     (n, PARENTYPE($2,decl,al)) }

|   direct_decl LBRACKET attributes comma_expression_opt RBRACKET
                                   { let (n, decl) = $1 in
                                     (n, ARRAY(decl, $3, $4)) }
|   direct_decl LBRACKET attributes error RBRACKET
                                   { let (n, decl) = $1 in
                                     (n, ARRAY(decl, $3, NOTHING)) }
|   direct_decl parameter_list_startscope rest_par_list RPAREN
                                   { let (n, decl) = $1 in
                                     let (params, isva) = $3 in
                                     !Flx_cil_lexerhack.pop_context ();
                                     (n, PROTO(decl, params, isva))
                                   }
;
parameter_list_startscope: 
    LPAREN                         { !Flx_cil_lexerhack.push_context () }
;
rest_par_list:
|   /* empty */                    { ([], false) }
|   parameter_decl rest_par_list1  { let (params, isva) = $2 in 
                                     ($1 :: params, isva) 
                                   }
;
rest_par_list1: 
    /* empty */                         { ([], false) }
|   COMMA ELLIPSIS                      { ([], true) }
|   COMMA parameter_decl rest_par_list1 { let (params, isva) = $3 in 
                                          ($2 :: params, isva)
                                        }  
;    


parameter_decl: /* (* ISO 6.7.5 *) */
   decl_spec_list declarator              { (fst $1, $2) }
|  decl_spec_list abstract_decl           { let d, a = $2 in
                                            (fst $1, ("", d, a, cabslu)) }
|  decl_spec_list                         { (fst $1, ("", JUSTBASE, [], cabslu)) }
|  LPAREN parameter_decl RPAREN           { $2 } 
;

/* (* Old style prototypes. Like a declarator *) */
old_proto_decl:
  pointer_opt direct_old_proto_decl   { let (n, decl, a) = $2 in
                                          (n, applyPointer (fst $1) decl, a, snd $1) }
;
direct_old_proto_decl:
  direct_decl LPAREN old_parameter_list_ne RPAREN old_pardef_list
                                   { let par_decl, isva = doOldParDecl $3 $5 in
                                     let n, decl = $1 in
                                     (n, PROTO(decl, par_decl, isva), [])
                                   }
| direct_decl LPAREN                       RPAREN
                                   { let n, decl = $1 in
                                     (n, PROTO(decl, [], false), [])
                                   }
;

old_parameter_list_ne:
|  IDENT                                       { [fst $1] }
|  IDENT COMMA old_parameter_list_ne           { let rest = $3 in
                                                 (fst $1 :: rest) }
;

old_pardef_list: 
   /* empty */                            { ([], false) }
|  decl_spec_list old_pardef SEMICOLON ELLIPSIS
                                          { ([(fst $1, $2)], true) }  
|  decl_spec_list old_pardef SEMICOLON old_pardef_list  
                                          { let rest, isva = $4 in
                                            ((fst $1, $2) :: rest, isva) 
                                          }
;

old_pardef: 
   declarator                             { [$1] }
|  declarator COMMA old_pardef            { $1 :: $3 }
|  error                                  { [] }
;


pointer: /* (* ISO 6.7.5 *) */ 
   STAR attributes pointer_opt  { $2 :: fst $3, $1 }
;
pointer_opt:
   /**/                          { [], currentLoc () }
|  pointer                       { $1 }
;

type_name: /* (* ISO 6.7.6 *) */
  decl_spec_list abstract_decl { let d, a = $2 in
                                 if a <> [] then begin
                                   parse_error "attributes in type name";
                                   raise Parsing.Parse_error
                                 end;
                                 (fst $1, d) 
                               }
| decl_spec_list               { (fst $1, JUSTBASE) }
;
abstract_decl: /* (* ISO 6.7.6. *) */
  pointer_opt abs_direct_decl attributes  { applyPointer (fst $1) $2, $3 }
| pointer                                 { applyPointer (fst $1) JUSTBASE, [] }
;

abs_direct_decl: /* (* ISO 6.7.6. We do not support optional declarator for 
                     * functions. Plus Microsoft attributes. See the 
                     * discussion for declarator. *) */
|   LPAREN attributes abstract_decl RPAREN
                                   { let d, a = $3 in
                                     PARENTYPE ($2, d, a)
                                   }
            
|   LPAREN error RPAREN
                                   { JUSTBASE } 
            
|   abs_direct_decl_opt LBRACKET comma_expression_opt RBRACKET
                                   { ARRAY($1, [], $3) }
/*(* The next shoudl be abs_direct_decl_opt but we get conflicts *)*/
|   abs_direct_decl  parameter_list_startscope rest_par_list RPAREN
                                   { let (params, isva) = $3 in
                                     !Flx_cil_lexerhack.pop_context ();
                                     PROTO ($1, params, isva)
                                   } 
;
abs_direct_decl_opt:
    abs_direct_decl                 { $1 }
|   /* empty */                     { JUSTBASE }
;
function_def:  /* (* ISO 6.9.1 *) */
  function_def_start block   
          { let (loc, specs, decl) = $1 in
            currentFunctionName := "<__FUNCTION__ used outside any functions>";
            !Flx_cil_lexerhack.pop_context (); (* The context pushed by 
                                    * announceFunctionName *)
            doFunctionDef loc (trd3 $2) specs decl (fst3 $2)
          } 


function_def_start:  /* (* ISO 6.9.1 *) */
  decl_spec_list declarator   
                            { announceFunctionName $2;
                              (snd $1, fst $1, $2)
                            } 

/* (* Old-style function prototype *) */
| decl_spec_list old_proto_decl 
                            { announceFunctionName $2;
                              (snd $1, fst $1, $2)
                            } 
/* (* New-style function that does not have a return type *) */
| IDENT parameter_list_startscope rest_par_list RPAREN 
                           { let (params, isva) = $3 in
                             let fdec = 
                               (fst $1, PROTO(JUSTBASE, params, isva), [], snd $1) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                             (snd $1, defSpec, fdec)
                           }

/* (* No return type and old-style parameter list *) */
| IDENT LPAREN old_parameter_list_ne RPAREN old_pardef_list
                           { (* Convert pardecl to new style *)
                             let pardecl, isva = doOldParDecl $3 $5 in
                             (* Make the function declarator *)
                             let fdec = (fst $1,
                                         PROTO(JUSTBASE, pardecl,isva), 
                                         [], snd $1) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                             (snd $1, defSpec, fdec) 
                            }
/* (* No return type and no parameters *) */
| IDENT LPAREN                      RPAREN
                           { (* Make the function declarator *)
                             let fdec = (fst $1,
                                         PROTO(JUSTBASE, [], false), 
                                         [], snd $1) in
                             announceFunctionName fdec;
                             (* Default is int type *)
                             let defSpec = [SpecType Tint] in
                             (snd $1, defSpec, fdec)
                            }
;

/* const/volatile as type specifier elements */
cvspec:
    CONST                               { SpecCV(CV_CONST), $1 }
|   VOLATILE                            { SpecCV(CV_VOLATILE), $1 }
|   RESTRICT                            { SpecCV(CV_RESTRICT), $1 }
;

/*** GCC attributes ***/
attributes:
    /* empty */                         { []}
|   attribute attributes                { fst $1 :: $2 }
;

/* (* In some contexts we can have an inline assembly to specify the name to 
    * be used for a global. We treat this as a name attribute *) */
attributes_with_asm:
    /* empty */                         { [] }
|   attribute attributes_with_asm       { fst $1 :: $2 }
|   ASM LPAREN string_constant RPAREN attributes        
                                        { ("__asm__", 
                                           [CONSTANT(CONST_STRING (fst $3))]) :: $5 }
;

/* things like __attribute__, but no const/volatile */
attribute_nocv:
    ATTRIBUTE LPAREN paren_attr_list_ne RPAREN  
                                        { ("__attribute__", $3), $1 }
|   DECLSPEC paren_attr_list_ne         { ("__declspec", $2), $1 }
|   MSATTR                              { (fst $1, []), snd $1 }
                                        /* ISO 6.7.3 */
|   THREAD                              { ("__thread",[]), $1 }
;

/* __attribute__ plus const/volatile */
attribute:
    attribute_nocv                      { $1 }
|   CONST                               { ("const", []), $1 }
|   RESTRICT                            { ("restrict",[]), $1 }
|   VOLATILE                            { ("volatile",[]), $1 }
;

/* (* sm: I need something that just includes __attribute__ and nothing more,
 *  to support them appearing between the 'struct' keyword and the type name. 
 * Actually, a declspec can appear there as well (on MSVC) *)  */
just_attribute:
    ATTRIBUTE LPAREN paren_attr_list_ne RPAREN
                                        { ("__attribute__", $3) }
|   DECLSPEC paren_attr_list_ne         { ("__declspec", $2) }
;

/* this can't be empty, b/c I folded that possibility into the calling
 * productions to avoid some S/R conflicts */
just_attributes:
    just_attribute                      { [$1] }
|   just_attribute just_attributes      { $1 :: $2 }
;

/** (* PRAGMAS and ATTRIBUTES *) ***/
/* (* We want to allow certain strange things that occur in pragmas, so we 
    * cannot use directly the language of expressions *) */ 
attr: 
|   id_or_typename                       { VARIABLE $1 }
|   IDENT IDENT                          { CALL(VARIABLE (fst $1), [VARIABLE (fst $2)]) }
|   IDENT COLON CST_INT                  { VARIABLE (fst $1 ^ ":" ^ fst $3) }

|   CST_INT COLON CST_INT                { VARIABLE (fst $1 ^ ":" ^ fst $3) } 
|   DEFAULT COLON CST_INT                { VARIABLE ("default:" ^ fst $3) }
                                         /* (* use a VARIABLE "" so that the 
                                             * parentheses are printed *) */
|   IDENT LPAREN  RPAREN                 { CALL(VARIABLE (fst $1), [VARIABLE ""]) }
|   IDENT paren_attr_list_ne             { CALL(VARIABLE (fst $1), $2) }

|   CST_INT                              { CONSTANT(CONST_INT (fst $1)) }
|   string_constant                      { CONSTANT(CONST_STRING (fst $1)) }
                                           /*(* Const when it appears in 
                                            * attribute lists, is translated 
                                            * to aconst *)*/
|   CONST                                { VARIABLE "aconst" }
|   SIZEOF expression                     {EXPR_SIZEOF (fst $2)}
|   SIZEOF LPAREN type_name RPAREN
                                         {let b, d = $3 in TYPE_SIZEOF (b, d)}

|   ALIGNOF expression                   {EXPR_ALIGNOF (fst $2)}
|   ALIGNOF LPAREN type_name RPAREN      {let b, d = $3 in TYPE_ALIGNOF (b, d)}
|   PLUS expression                      {UNARY (PLUS, fst $2)}
|   MINUS expression                    {UNARY (MINUS, fst $2)}
|   STAR expression                     {UNARY (MEMOF, fst $2)}
|   AND expression                                               %prec ADDROF
                                        {UNARY (ADDROF, fst $2)}
|   EXCLAM expression                   {UNARY (NOT, fst $2)}
|   TILDE expression                    {UNARY (BNOT, fst $2)}
|   attr PLUS attr                      {BINARY(ADD ,$1 , $3)} 
|   attr MINUS attr                     {BINARY(SUB ,$1 , $3)}
|   attr STAR expression                {BINARY(MUL ,$1 , fst $3)}
|   attr SLASH attr                     {BINARY(DIV ,$1 , $3)}
|   attr PERCENT attr                   {BINARY(MOD ,$1 , $3)}
|   attr AND_AND attr                   {BINARY(AND ,$1 , $3)}
|   attr PIPE_PIPE attr                 {BINARY(OR ,$1 , $3)}
|   attr AND attr                       {BINARY(BAND ,$1 , $3)}
|   attr PIPE attr                      {BINARY(BOR ,$1 , $3)}
|   attr CIRC attr                      {BINARY(XOR ,$1 , $3)}
|   attr EQ_EQ attr                     {BINARY(EQ ,$1 , $3)}
|   attr EXCLAM_EQ attr                 {BINARY(NE ,$1 , $3)}
|   attr INF attr                       {BINARY(LT ,$1 , $3)}
|   attr SUP attr                       {BINARY(GT ,$1 , $3)}
|   attr INF_EQ attr                    {BINARY(LE ,$1 , $3)}
|   attr SUP_EQ attr                    {BINARY(GE ,$1 , $3)}
|   attr INF_INF attr                   {BINARY(SHL ,$1 , $3)}
|   attr SUP_SUP attr                   {BINARY(SHR ,$1 , $3)}
|   attr ARROW id_or_typename           {MEMBEROFPTR ($1, $3)} 
|   attr DOT id_or_typename             {MEMBEROF ($1, $3)}  
|   LPAREN attr RPAREN                  { $2 } 
;

attr_list_ne:
|  attr                                  { [$1] }
|  attr COMMA attr_list_ne               { $1 :: $3 }
|  error COMMA attr_list_ne              { $3 }
;
paren_attr_list_ne: 
   LPAREN attr_list_ne RPAREN            { $2 }
|  LPAREN error RPAREN                   { [] }
;
/*** GCC ASM instructions ***/
asmattr:
     /* empty */                        { [] }
|    VOLATILE  asmattr                  { ("volatile", []) :: $2 }
|    CONST asmattr                      { ("const", []) :: $2 } 
;
asmtemplate: 
    one_string_constant                          { [$1] }
|   one_string_constant asmtemplate              { $1 :: $2 }
;
asmoutputs: 
  /* empty */           { ([], [], []) }
| COLON asmoperands asminputs
                        { let (ins, clobs) = $3 in
                          ($2, ins, clobs) }
;
asmoperands:
     /* empty */                        { [] }
|    asmoperandsne                      { List.rev $1 }
;
asmoperandsne:
     asmoperand                         { [$1] }
|    asmoperandsne COMMA asmoperand     { $3 :: $1 }
;
asmoperand:
     string_constant LPAREN expression RPAREN    { (fst $1, fst $3) }
|    string_constant LPAREN error RPAREN         { (fst $1, NOTHING ) } 
; 
asminputs: 
  /* empty */                { ([], []) }
| COLON asmoperands asmclobber
                        { ($2, $3) }
;
asmclobber:
    /* empty */                         { [] }
| COLON asmcloberlst_ne                 { $2 }
;
asmcloberlst_ne:
   one_string_constant                           { [$1] }
|  one_string_constant COMMA asmcloberlst_ne     { $1 :: $3 }
;
  
%%



@h=tangler('src/flx_cil_cprint.mli')
@select(h)

val version : string
type loc = { line : int; file : string; }
val lu : loc
val cabslu : Flx_cil_cabs.cabsloc
val curLoc : Flx_cil_cabs.cabsloc ref
val msvcMode : bool ref
val printLn : bool ref
val printLnComment : bool ref
val printCounters : bool ref
val printComments : bool ref
val out : out_channel ref
val width : int ref
val tab : int ref
val max_indent : int ref
val line : string ref
val line_len : int ref
val current : string ref
val current_len : int ref
val spaces : int ref
val follow : int ref
val roll : int ref
val print_tab : int -> unit
val flush : 'a -> unit
val commit : 'a -> unit
val addline : unit -> unit
val new_line : 'a -> unit
val force_new_line : 'a -> unit
val indent : 'a -> unit
val indentline : 'a -> unit
val unindent : 'a -> unit
val space : 'a -> unit
val print : string -> unit
val print_unescaped_string : string -> unit
val setLoc : Flx_cil_cabs.cabsloc -> unit
val print_list : (unit -> unit) -> ('a -> 'b) -> 'a list -> unit
val print_commas : bool -> ('a -> 'b) -> 'a list -> unit
val print_string : string -> unit
val print_wstring : Flx_cil_escape.wstring -> unit
val print_specifiers : Flx_cil_cabs.specifier -> unit
val print_type_spec : Flx_cil_cabs.typeSpecifier -> unit
val print_struct_name_attr :
  string -> string -> Flx_cil_cabs.attribute list -> unit
val print_decl : string -> Flx_cil_cabs.decl_type -> unit
val print_fields : Flx_cil_cabs.field_group list -> unit
val print_enum_items : Flx_cil_cabs.enum_item list -> unit
val print_onlytype : Flx_cil_cabs.specifier * Flx_cil_cabs.decl_type -> unit
val print_name : Flx_cil_cabs.name -> unit
val print_init_name : Flx_cil_cabs.init_name -> unit
val print_name_group : Flx_cil_cabs.name_group -> unit
val print_field_group : Flx_cil_cabs.field_group -> unit
val print_field : Flx_cil_cabs.name * Flx_cil_cabs.expression option -> unit
val print_init_name_group : Flx_cil_cabs.init_name_group -> unit
val print_single_name : Flx_cil_cabs.single_name -> unit
val print_params : Flx_cil_cabs.single_name list -> bool -> unit
val print_old_params : string list -> bool -> unit
val get_operator : Flx_cil_cabs.expression -> string * int
val print_comma_exps : Flx_cil_cabs.expression list -> unit
val print_init_expression : Flx_cil_cabs.init_expression -> unit
val print_expression : Flx_cil_cabs.expression -> unit
val print_expression_level : int -> Flx_cil_cabs.expression -> unit
val print_statement : Flx_cil_cabs.statement -> unit
val print_block : Flx_cil_cabs.block -> unit
val print_substatement : Flx_cil_cabs.statement -> unit
val print_attribute : Flx_cil_cabs.attribute -> unit
val print_attributes : Flx_cil_cabs.attribute list -> unit
val print_defs : Flx_cil_cabs.definition list -> unit
val print_def : Flx_cil_cabs.definition -> unit
val comprint : string -> unit
val comstring : string -> string
val printFile : out_channel -> Flx_cil_cabs.file -> unit
val set_tab : int -> unit
val set_width : int -> unit

@h=tangler('src/flx_cil_cprint.ml')
@select(h)
(* cprint -- pretty printer of C program from abstract syntax
**
** Project:     FrontC
** File:        cprint.ml
** Version:     2.1e
** Date:        9.1.99
** Author:      Hugues Cass√©
**
**      1.0             2.22.99 Hugues Cass√©    First version.
**      2.0             3.18.99 Hugues Cass√©    Compatible with Flx_cil_frontc 2.1, use of CAML
**                                                                      pretty printer.
**      2.1             3.22.99 Hugues Cass√©    More efficient custom pretty printer used.
**      2.1a    4.12.99 Hugues Cass√©    Correctly handle:
**                                                                      char *m, *m, *p; m + (n - p)
**      2.1b    4.15.99 Hugues Cass√©    x + (y + z) stays x + (y + z) for
**                                                                      keeping computation order.
**      2.1c    7.23.99 Hugues Cass√©    Improvement of case and default display.
**      2.1d    8.25.99 Hugues Cass√©    Rebuild escape sequences in string and
**                                                                      characters.
**      2.1e    9.1.99  Hugues Cass√©    Fix, recognize and correctly display '\0'.
*)

(* George Necula: I changed this pretty dramatically since CABS changed *)
open Flx_cil_cabs
open Flx_cil_cabs_helper
open Flx_cil_escape
let version = "Flx_cil_cprint 2.1e 9.1.99 Hugues Cass√©"

type loc = { line : int; file : string }

let lu = {line = -1; file = "loc unknown";}
let cabslu = {lineno = -10; filename = "cabs loc unknown"; byteno = -10;}

let curLoc = ref cabslu

let msvcMode = ref false

let printLn = ref true
let printLnComment = ref false

let printCounters = ref false
let printComments = ref false

(*
** FrontC Flx_cil_pretty printer
*)
let out = ref stdout
let width = ref 80
let tab = ref 2
let max_indent = ref 60

let line = ref ""
let line_len = ref 0
let current = ref ""
let current_len = ref 0
let spaces = ref 0
let follow = ref 0
let roll = ref 0

let print_tab size =
        for i = 1 to size / 8 do
                output_char !out '\t'
        done;
        for i  = 1 to size mod 8 do
                output_char !out ' '
        done

let flush _ =
        if !line <> "" then begin
                print_tab (!spaces + !follow);
                output_string !out !line;
                line := "";
                line_len := 0
        end

let commit _ =
  if !current <> "" then begin
    if !line = "" then begin
      line := !current;
      line_len := !current_len
    end else begin
      line := (!line ^ " " ^ !current);
      line_len := !line_len + 1 + !current_len
    end;
    current := "";
    current_len := 0
  end


let addline () =
  curLoc := {lineno = !curLoc.lineno+1;
              filename = !curLoc.filename;
              byteno = -1; (*sfg: can we do better than this?*) }
       
       
let new_line _ =
  commit ();
  if !line <> "" then begin
    flush ();
    addline();
    output_char !out '\n'
  end;
  follow := 0
       
let force_new_line _ =
  commit ();
  flush ();
  addline();
  output_char !out '\n';
  follow := 0
       
let indent _ =
  new_line ();
  spaces := !spaces + !tab;
  if !spaces >= !max_indent then begin
    spaces := !tab;
    roll := !roll + 1
  end
      
let indentline _ =
  new_line ();
  if !spaces >= !max_indent then begin
    spaces := !tab;
    roll := !roll + 1
  end
      
let unindent _ =
  new_line ();
  spaces := !spaces - !tab;
  if (!spaces <= 0) && (!roll > 0) then begin
    spaces := ((!max_indent - 1) / !tab) * !tab;
    roll := !roll - 1
  end
      
let space _ = commit ()

let print str =
  current := !current ^ str;
  current_len := !current_len + (String.length str);
  if (!spaces + !follow + !line_len + 1 + !current_len) > !width
  then begin
    if !line_len = 0 then commit ();
    flush ();
    addline();
    output_char !out '\n';
    if !follow = 0 then follow := !tab
  end

(* sm: for some reason I couldn't just call print from frontc.... ? *)
let print_unescaped_string str = print str

let setLoc (l : cabsloc) =
  let tempcur = current in
  if !printLn then  
    if (l.lineno <> !curLoc.lineno) || l.filename <> !curLoc.filename then 
      begin
        let oldspaces = !spaces in
        (* sm: below, we had '//#' instead of '#', which means printLnComment was disregarded *)
        if !printLnComment then print "//" else print "#";
        if !msvcMode then print "line";
        print " ";
        print (string_of_int l.lineno);
        if (l.filename <> !curLoc.filename) then begin
          print (" \"" ^ l.filename ^ "\"")
        end;
        spaces := oldspaces;
        new_line();
        curLoc := l
      end



(*
** Useful primitives
*)
let print_list print_sep print_elt lst = 
  let _ = List.fold_left
      (fun com elt ->
        if com then print_sep ();
        print_elt elt;
        true)
      false
      lst in
  ()

let print_commas nl fct lst =
  print_list (fun () -> print ","; if nl then new_line() else space()) fct lst
        
let print_string (s:string) =
  print ("\"" ^ escape_string s ^ "\"")

let print_wstring (s: int64 list ) =
  print ("L\"" ^ escape_wstring s ^ "\"")

(*
** Base Type Printing
*)

let rec print_specifiers (specs: spec_elem list) =
  comprint "specifier(";
  let print_spec_elem = function
      SpecTypedef -> print "typedef "
    | SpecInline -> print "__inline "
    | SpecStorage sto ->
        print (match sto with
          NO_STORAGE -> (comstring "/*no storage*/")
        | AUTO -> "auto "
        | STATIC -> "static "
        | EXTERN -> "extern "
        | REGISTER -> "register ")
    | SpecCV cv -> 
        print (match cv with
        | CV_CONST -> "const "
        | CV_VOLATILE -> "volatile "
        | CV_RESTRICT -> "restrict ")
    | SpecAttr al -> print_attribute al; space ()
    | SpecType bt -> print_type_spec bt
    | SpecPattern name -> print ("@specifier(" ^ name ^ ") ")
  in
  List.iter print_spec_elem specs
  ;comprint ")"


and print_type_spec = function
    Tvoid -> print "void "
  | Tbool -> print "_Bool "
  | Tchar -> print "char "
  | Tshort -> print "short "
  | Tint -> print "int "
  | Tlong -> print "long "
  | Tint64 -> print "__int64 "
  | Tfloat -> print "float "
  | Tdouble -> print "double "
  | Tcomplex -> print "_Complex "
  | Timaginary -> print "_Imaginary "
  | Tsigned -> print "signed "
  | Tunsigned -> print "unsigned "
  | Tnamed s -> comprint "tnamed"; print s; space ();
  | Tstruct (n, None, _) -> print ("struct " ^ n ^ " ")
  | Tstruct (n, Some flds, extraAttrs) ->
      (print_struct_name_attr "struct" n extraAttrs);
      (print_fields flds)
  | Tunion (n, None, _) -> print ("union " ^ n ^ " ")
  | Tunion (n, Some flds, extraAttrs) ->
      (print_struct_name_attr "union" n extraAttrs);
      (print_fields flds)
  | Tenum (n, None, _) -> print ("enum " ^ n ^ " ")
  | Tenum (n, Some enum_items, extraAttrs) ->
      (print_struct_name_attr "enum" n extraAttrs);
      (print_enum_items enum_items)
  | TtypeofE e -> print "__typeof__("; print_expression e; print ") "
  | TtypeofT (s,d) -> print "__typeof__("; print_onlytype (s, d); print ") "


(* print "struct foo", but with specified keyword and a list of
 * attributes to put between keyword and name *)
and print_struct_name_attr (keyword: string) (name: string) (extraAttrs: attribute list) =
begin
  if extraAttrs = [] then
    print (keyword ^ " " ^ name)
  else begin
    (print (keyword ^ " "));
    (print_attributes extraAttrs);    (* prints a final space *)
    (print name);
  end
end


(* This is the main printer for declarations. It is easy bacause the 
 * declarations are laid out as they need to be printed. *)
and print_decl (n: string) = function
    JUSTBASE -> if n <> "___missing_field_name" then 
                  print n
                else
                  comprint "missing field name"
  | PARENTYPE (al1, d, al2) ->
      print "(";
      print_attributes al1; space ();
      print_decl n d; space ();
      print_attributes al2; print ")"
  | PTR (al, d) ->
      print "* ";
      print_attributes al; space ();
      print_decl n d
  | ARRAY (d, al, e) ->
      print_decl n d;
      print "[";
      print_attributes al;
      if e <> NOTHING then print_expression e;
      print "]"
  | PROTO(d, args, isva) ->
      comprint "proto(";
      print_decl n d;
      print "(";
      print_params args isva;
      print ")";
      comprint ")"


and print_fields (flds : field_group list) =
  if flds = [] then print " { } "
  else begin
    print " {";
    indent ();
    List.iter
      (fun fld -> print_field_group fld; print ";"; new_line ())
      flds;
    unindent ();
    print "} "
  end

and print_enum_items items =
  if items = [] then print " { } "
  else begin
    print " {";
    indent ();
    print_commas
      true
      (fun (id, exp, loc) -> print id;
        if exp = NOTHING then ()
        else begin
          space ();
          print "= ";
          print_expression exp
        end)
      items;
    unindent ();
    print "} ";
  end

  
and print_onlytype (specs, dt) =
  print_specifiers specs;
  print_decl "" dt
    
and print_name ((n, decl, attrs, _) : name) =
  print_decl n decl;
  space ();
  print_attributes attrs

and print_init_name ((n, i) : init_name) =
  print_name n;
  if i <> NO_INIT then begin
    space ();
    print "= ";
    print_init_expression i
  end
            
and print_name_group (specs, names) =
  print_specifiers specs;
  print_commas false print_name names
    
and print_field_group (specs, fields) =
  print_specifiers specs;
  print_commas false print_field fields
    

and print_field (name, widtho) = 
  print_name name;
  (match widtho with 
    None -> ()
  | Some w -> print " : ";  print_expression w)

and print_init_name_group (specs, names) =
  print_specifiers specs;
  print_commas false print_init_name names
    
and print_single_name (specs, name) =
  print_specifiers specs;
  print_name name

and print_params (pars : single_name list) (ell : bool) =
  print_commas false print_single_name pars;
  if ell then print (if pars = [] then "..." else ", ...") else ()
    
and print_old_params pars ell =
  print_commas false (fun id -> print id) pars;
  if ell then print (if pars = [] then "..." else ", ...") else ()
    

(*
** Expression printing
**              Priorities
**              16      variables
**              15      . -> [] call()
**              14  ++, -- (post)
**              13      ++ -- (pre) ~ ! - + & *(cast)
**              12      * / %
**              11      + -
**              10      << >>
**              9       < <= > >=
**              8       == !=
**              7       &
**              6       ^
**              5       |
**              4       &&
**              3       ||
**              2       ? :
**              1       = ?=
**              0       ,                               
*)
and get_operator exp =
  match exp with
    NOTHING -> ("", 16)
  | UNARY (op, _) ->
      (match op with
        MINUS -> ("-", 13)
      | PLUS -> ("+", 13)
      | NOT -> ("!", 13)
      | BNOT -> ("~", 13)
      | MEMOF -> ("*", 13)
      | ADDROF -> ("&", 13)
      | PREINCR -> ("++", 13)
      | PREDECR -> ("--", 13)
      | POSINCR -> ("++", 14)
      | POSDECR -> ("--", 14))
  | LABELADDR s -> ("", 16)  (* Like a constant *)
  | BINARY (op, _, _) ->
      (match op with
        MUL -> ("*", 12)
      | DIV -> ("/", 12)
      | MOD -> ("%", 12)
      | ADD -> ("+", 11)
      | SUB -> ("-", 11)
      | SHL -> ("<<", 10)
      | SHR -> (">>", 10)
      | LT -> ("<", 9)
      | LE -> ("<=", 9)
      | GT -> (">", 9)
      | GE -> (">=", 9)
      | EQ -> ("==", 8)
      | NE -> ("!=", 8)
      | BAND -> ("&", 7)
      | XOR -> ("^", 6)
      | BOR -> ("|", 5)
      | AND -> ("&&", 4)
      | OR -> ("||", 3)
      | ASSIGN -> ("=", 1)
      | ADD_ASSIGN -> ("+=", 1)
      | SUB_ASSIGN -> ("-=", 1)
      | MUL_ASSIGN -> ("*=", 1)
      | DIV_ASSIGN -> ("/=", 1)
      | MOD_ASSIGN -> ("%=", 1)
      | BAND_ASSIGN -> ("&=", 1)
      | BOR_ASSIGN -> ("|=", 1)
      | XOR_ASSIGN -> ("^=", 1)
      | SHL_ASSIGN -> ("<<=", 1)
      | SHR_ASSIGN -> (">>=", 1))
  | QUESTION _ -> ("", 2)
  | CAST _ -> ("", 13)
  | CALL _ -> ("", 15)
  | COMMA _ -> ("", 0)
  | CONSTANT _ -> ("", 16)
  | VARIABLE name -> ("", 16)
  | EXPR_SIZEOF exp -> ("", 16)
  | TYPE_SIZEOF _ -> ("", 16)
  | EXPR_ALIGNOF exp -> ("", 16)
  | TYPE_ALIGNOF _ -> ("", 16)
  | INDEX (exp, idx) -> ("", 15)
  | MEMBEROF (exp, fld) -> ("", 15)
  | MEMBEROFPTR (exp, fld) -> ("", 15)
  | GNU_BODY _ -> ("", 17)
  | EXPR_PATTERN _ -> ("", 16)     (* sm: not sure about this *)

and print_comma_exps exps =
  print_commas false print_expression exps
    
and print_init_expression (iexp: init_expression) : unit = 
  match iexp with 
    NO_INIT -> ()
  | SINGLE_INIT e -> print_expression e
  | COMPOUND_INIT  initexps ->
      let doinitexp = function
          NEXT_INIT, e -> print_init_expression e
        | i, e -> 
            let rec doinit = function
                NEXT_INIT -> ()
              | INFIELD_INIT (fn, i) -> print ("." ^ fn); doinit i
              | ATINDEX_INIT (e, i) -> 
                  print "[";
                  print_expression e;
                  print "]";
                  doinit i
              | ATINDEXRANGE_INIT (s, e) -> 
                  print "["; 
                  print_expression s;
                  print " ... ";
                  print_expression e;
                  print "]"
                in
            doinit i; print " = "; 
            print_init_expression e
      in
      print "{";
      print_commas false doinitexp initexps;
      print "}"

and print_expression (exp: expression) = print_expression_level 1 exp

and print_expression_level (lvl: int) (exp : expression) =
  let (txt, lvl') = get_operator exp in
  let _ = if lvl > lvl' then print "(" else () in
  let _ = match exp with
    NOTHING -> ()
  | UNARY (op, exp') ->
      (match op with
        POSINCR | POSDECR ->
          print_expression_level lvl' exp';
          print txt
      | _ ->
          print txt; space (); (* Print the space to avoid --5 *)
          print_expression_level lvl' exp')
  | LABELADDR l -> print ("&& " ^ l)
  | BINARY (op, exp1, exp2) ->
                        (*if (op = SUB) && (lvl <= lvl') then print "(";*)
      print_expression_level lvl' exp1;
      space ();
      print txt;
      space ();
                        (*print_expression exp2 (if op = SUB then (lvl' + 1) else lvl');*)
      print_expression_level (lvl' + 1) exp2 
                        (*if (op = SUB) && (lvl <= lvl') then print ")"*)
  | QUESTION (exp1, exp2, exp3) ->
      print_expression_level 2 exp1;
      space ();
      print "? ";
      print_expression_level 2 exp2;
      space ();
      print ": ";
      print_expression_level 2 exp3;
  | CAST (typ, iexp) ->
      print "(";
      print_onlytype typ;
      print ")"; 
     (* Always print parentheses. In a small number of cases when we print 
      * constants we don't need them  *)
      (match iexp with
        SINGLE_INIT e -> print_expression_level 15 e
      | COMPOUND_INIT _ -> (* print "("; *) 
          print_init_expression iexp 
          (* ; print ")" *)
      | NO_INIT -> print "<NO_INIT in cast. Should never arise>")

  | CALL (VARIABLE "__builtin_va_arg", [arg; TYPE_SIZEOF (bt, dt)]) -> 
      comprint "variable";
      print "__builtin_va_arg";
      print "(";
      print_expression_level 1 arg;
      print ",";
      print_onlytype (bt, dt);
      print ")"
  | CALL (exp, args) ->
      print_expression_level 16 exp;
      print "(";
      print_comma_exps args;
      print ")"
  | COMMA exps ->
      print_comma_exps exps
  | CONSTANT cst ->
      (match cst with
        CONST_INT i -> print i
      | CONST_FLOAT r -> print r
      | CONST_CHAR c -> print ("'" ^ escape_wstring c ^ "'")
      | CONST_WCHAR c -> print ("L'" ^ escape_wstring c ^ "'")
      | CONST_STRING s -> print_string s
      | CONST_WSTRING ws -> print_wstring ws)
  | VARIABLE name ->
      comprint "variable";
      print name
  | EXPR_SIZEOF exp ->
      print "sizeof(";
      print_expression_level 0 exp;
      print ")"
  | TYPE_SIZEOF (bt,dt) ->
      print "sizeof(";
      print_onlytype (bt, dt);
      print ")"
  | EXPR_ALIGNOF exp ->
      print "__alignof__(";
      print_expression_level 0 exp;
      print ")"
  | TYPE_ALIGNOF (bt,dt) ->
      print "__alignof__(";
      print_onlytype (bt, dt);
      print ")"
  | INDEX (exp, idx) ->
      print_expression_level 16 exp;
      print "[";
      print_expression_level 0 idx;
      print "]"
  | MEMBEROF (exp, fld) ->
      print_expression_level 16 exp;
      print ("." ^ fld)
  | MEMBEROFPTR (exp, fld) ->
      print_expression_level 16 exp;
      print ("->" ^ fld)
  | GNU_BODY (blk) ->
      print "(";
      print_block blk;
      print ")"
  | EXPR_PATTERN (name) ->
      print ("@expr(" ^ name ^ ") ")
  in
  if lvl > lvl' then print ")" else ()
    

(*
** Statement printing
*)
and print_statement stat =
  match stat with
    NOP (loc) ->
      setLoc(loc);
      print ";";
      new_line ()
  | COMPUTATION (exp, loc) ->
      setLoc(loc);
      print_expression exp;
      print ";";
      new_line ()
  | BLOCK (blk, loc) -> print_block blk

  | SEQUENCE (s1, s2, loc) ->
      setLoc(loc);
      print_statement s1;
      print_statement s2;
  | IF (exp, s1, s2, loc) ->
      setLoc(loc);
      print "if(";
      print_expression_level 0 exp;
      print ")";
      print_substatement s1;
      (match s2 with
      | NOP(_) -> ()
      | _ -> begin
          print "else";
          print_substatement s2;
        end)
  | WHILE (exp, stat, loc) ->
      setLoc(loc);
      print "while(";
      print_expression_level 0 exp;
      print ")";
      print_substatement stat
  | DOWHILE (exp, stat, loc) ->
      setLoc(loc);
      print "do";
      print_substatement stat;
      print "while(";
      print_expression_level 0 exp;
      print ");";
      new_line ();
  | FOR (fc1, exp2, exp3, stat, loc) ->
      setLoc(loc);
      print "for(";
      (match fc1 with
        FC_EXP exp1 -> print_expression_level 0 exp1; print ";"
      | FC_DECL dec1 -> print_def dec1);
      space ();
      print_expression_level 0 exp2;
      print ";";
      space ();
      print_expression_level 0 exp3;
      print ")";
      print_substatement stat
  | BREAK (loc)->
      setLoc(loc);
      print "break;"; new_line ()
  | CONTINUE (loc) ->
      setLoc(loc);
      print "continue;"; new_line ()
  | RETURN (exp, loc) ->
      setLoc(loc);
      print "return";
      if exp = NOTHING
      then ()
      else begin
        print " ";
        print_expression_level 1 exp
      end;
      print ";";
      new_line ()
  | SWITCH (exp, stat, loc) ->
      setLoc(loc);
      print "switch(";
      print_expression_level 0 exp;
      print ")";
      print_substatement stat
  | CASE (exp, stat, loc) ->
      setLoc(loc);
      unindent ();
      print "case ";
      print_expression_level 1 exp;
      print ":";
      indent ();
      print_substatement stat
  | CASERANGE (expl, exph, stat, loc) ->
      setLoc(loc);
      unindent ();
      print "case ";
      print_expression expl;
      print " ... ";
      print_expression exph;
      print ":";
      indent ();
      print_substatement stat
  | DEFAULT (stat, loc) ->
      setLoc(loc);
      unindent ();
      print "default :";
      indent ();
      print_substatement stat
  | LABEL (name, stat, loc) ->
      setLoc(loc);
      print (name ^ ":");
      space ();
      print_substatement stat
  | GOTO (name, loc) ->
      setLoc(loc);
      print ("goto " ^ name ^ ";");
      new_line ()
  | COMPGOTO (exp, loc) -> 
      setLoc(loc);
      print ("goto *"); print_expression exp; print ";"; new_line ()
  | DEFINITION d ->
      print_def d
  | ASM (attrs, tlist, outs, ins, clobs, loc) ->
      setLoc(loc);
      let print_asm_operand (cnstr, e) =
        print_string cnstr; space (); print_expression_level 100 e
      in
      if !msvcMode then begin
        print "__asm {";
        print_list (fun () -> new_line()) print tlist; (* templates *)
        print "};"
      end else begin
        print "__asm__ "; 
        print_attributes attrs;
        print "(";
        print_list (fun () -> new_line()) print_string tlist; (* templates *)
        if outs <> [] || ins <> [] || clobs <> [] then begin
          print ":"; space ();
          print_commas false print_asm_operand outs;
          if ins <> [] || clobs <> [] then begin
            print ":"; space ();
            print_commas false print_asm_operand ins;
            if clobs <> [] then begin
              print ":"; space ();
              print_commas false print_string clobs
            end;                          
          end
        end;      
        print ");"
      end;
      new_line ()
  | TRY_FINALLY (b, h, loc) -> 
      setLoc loc;
      print "__try ";
      print_block b;
      print "__finally ";
      print_block h

  | TRY_EXCEPT (b, e, h, loc) -> 
      setLoc loc;
      print "__try ";
      print_block b;
      print "__except("; print_expression e; print ")";
      print_block h
      
and print_block blk = 
  new_line();
  print "{";
  indent ();
  if blk.blabels <> [] then begin
    print "__label__ ";
    print_commas false print blk.blabels;
    print ";";
    new_line ();
  end;
  if blk.battrs <> [] then begin
    List.iter print_attribute blk.battrs;
    new_line ();
  end;
  List.iter print_statement blk.bstmts;
  unindent ();
  print "}";
  new_line ()
  
and print_substatement stat =
  match stat with
    IF _
  | SEQUENCE _
  | DOWHILE _ ->
      new_line ();
      print "{";
      indent ();
      print_statement stat;
      unindent ();
      print "}";
      new_line ();
  | BLOCK _ ->
      print_statement stat
  | _ ->
      indent ();
      print_statement stat;
      unindent ()


(*
** GCC Attributes
*)
and print_attribute (name,args) = 
  if args = [] then print (
    match name with 
      "restrict" -> "__restrict" 
      (* weimer: Fri Dec  7 17:12:35  2001
       * must not print 'restrict' and the code below does allows some
       * plain 'restrict's to slip though! *)
    | x -> x)
  else begin
    print name;
    print "("; if name = "__attribute__" then print "(";
    (match args with
      [VARIABLE "aconst"] -> print "const"
    | [VARIABLE "restrict"] -> print "__restrict"
    | _ -> print_commas false (fun e -> print_expression e) args);
    print ")"; if name = "__attribute__" then print ")"
  end

(* Print attributes. *)
and print_attributes attrs =
  List.iter (fun a -> print_attribute a; space ()) attrs

(*
** Declaration printing
*)
and print_defs defs =
  let prev = ref false in
  List.iter
    (fun def ->
      (match def with
        DECDEF _ -> prev := false
      | _ ->
          if not !prev then force_new_line ();
          prev := true);
      print_def def)
    defs

and print_def def =
  match def with
    FUNDEF (proto, body, loc, _) ->
      comprint "fundef";
      if !printCounters then begin
        try
          let fname =
            match proto with
              (_, (n, _, _, _)) -> n
          in
          print_def (DECDEF (([SpecType Tint],
                              [(fname ^ "__counter", JUSTBASE, [], cabslu),
                                NO_INIT]), loc));
        with Not_found -> print "/* can't print the counter */"
      end;
      setLoc(loc);
      print_single_name proto;
      print_block body;
      force_new_line ();

  | DECDEF (names, loc) ->
      comprint "decdef";
      setLoc(loc);
      print_init_name_group names;
      print ";";
      new_line ()

  | TYPEDEF (names, loc) ->
      comprint "typedef";
      setLoc(loc);
      print_name_group names;
      print ";";
      new_line ();
      force_new_line ()

  | ONLYTYPEDEF (specs, loc) ->
      comprint "onlytypedef";
      setLoc(loc);
      print_specifiers specs;
      print ";";
      new_line ();
      force_new_line ()

  | GLOBASM (asm, loc) ->
      setLoc(loc);
      print "__asm__ (";  print_string asm; print ");";
      new_line ();
      force_new_line ()

  | PRAGMA (a,loc) ->
      setLoc(loc);
      force_new_line ();
      print "#pragma ";
      let oldwidth = !width in
      width := 1000000;  (* Do not wrap pragmas *)
      print_expression a;
      width := oldwidth;
      force_new_line ()

  | LINKAGE (n, loc, dl) -> 
      setLoc (loc);
      force_new_line ();
      print "extern "; print_string n; print_string "  {";
      List.iter print_def dl;
      print_string "}";
      force_new_line ()

  | TRANSFORMER(srcdef, destdeflist, loc) ->
      setLoc(loc);
      print "@transform {";
      force_new_line();
      print "{";
        force_new_line();
        indent ();
        print_def srcdef;
        unindent();
      print "}";
      force_new_line();
      print "to {";
        force_new_line();
        indent();
        List.iter print_def destdeflist;
        unindent();
      print "}";
      force_new_line()

  | EXPRTRANSFORMER(srcexpr, destexpr, loc) ->
      setLoc(loc);
      print "@transformExpr { ";
      print_expression srcexpr;
      print " } to { ";
      print_expression destexpr;
      print " }";
      force_new_line()


(* sm: print a comment if the printComments flag is set *)
and comprint (str : string) : unit =
begin
  if (!printComments) then (
    print "/*";
    print str;
    print "*/ "
  )
  else
    ()
end

(* sm: yield either the given string, or "", depending on printComments *)
and comstring (str : string) : string =
begin
  if (!printComments) then
    str
  else
    ""
end


(*  print abstrac_syntax -> ()
**              Flx_cil_pretty printing the given abstract syntax program.
*)
let printFile (result : out_channel) ((fname, defs) : file) =
  out := result;
  print_defs defs;
  flush ()     (* sm: should do this here *)

let set_tab t = tab := t
let set_width w = width := w

@h=tangler('src/flx_cil_frontc.ml')
@select(h)


module E = Flx_cil_errormsg
open Flx_cil_trace
open Flx_cil_pretty

(* Output management *)
let out : out_channel option ref = ref None
let close_me = ref false

let close_output _ =
  match !out with
    None -> ()
  | Some o -> begin
      flush o;
      if !close_me then close_out o else ();
      close_me := false
  end

let set_output filename =
  close_output ();
  (try out := Some (open_out filename)
  with (Sys_error msg) ->
    output_string stderr ("Error while opening output: " ^ msg); exit 1);
  close_me := true

   (* Signal that we are in MS VC mode *)
let setMSVCMode () =
  Flx_cil_cprint.msvcMode := true

(* filename for patching *)
let patchFileName : string ref = ref ""      (* by default do no patching *)

(* patching file contents *)
let patchFile : Flx_cil_cabs.file option ref = ref None

(* whether to print the patched CABS files *)
let printFlx_cil_patchedFiles : bool ref = ref false

(* whether to print a file of prototypes after parsing *)
let doPrintProtos : bool ref = ref false

(* this seems like something that should be built-in.. *)
let isNone (o : 'a option) : bool =
begin
  match o with
  | Some _ -> false
  | None -> true
end

(*
** Argument definition
*)
let args : (string * Arg.spec * string) list =
[
  "--cabsonly", Arg.String set_output, "<fname>: CABS output file name";
  "--printComments", Arg.Unit (fun _ -> Flx_cil_cprint.printComments := true),
             ": print cabs tree structure in comments in cabs output";
  "--patchFile", Arg.String (fun pf -> patchFileName := pf),
             "<fname>: name the file containing patching transformations";
  "--printFlx_cil_patched", Arg.Unit (fun _ -> printFlx_cil_patchedFiles := true),
             ": print patched CABS files after patching, to *.patched";
  "--printProtos", Arg.Unit (fun _ -> doPrintProtos := true),
             ": print prototypes to safec.proto.h after parsing";
]

exception ParseError of string
exception Flx_cil_cabsOnly

(* parse, and apply patching *)
let rec parse_to_cabs fname lang =
begin
  (* parse the patch file if it isn't parsed already *)
  if ((!patchFileName <> "") && (isNone !patchFile)) then (
    (* parse the patch file *)
    patchFile := Some(parse_to_cabs_inner !patchFileName lang);
    if !E.hadErrors then
      (failwith "There were parsing errors in the patch file")
  );

  (* now parse the file we came here to parse *)
  let cabs = parse_to_cabs_inner fname lang in
  if !E.hadErrors then 
    E.s (E.error "There were parsing errors in %s\n" fname);

  (* and apply the patch file, return transformed file *)
  let patched = match !patchFile with

    | Some(pf) -> (
        (* save old value of out so I can use it for debugging during patching *)
        let oldOut = !out in

        (* reset out so we don't try to print the patch file to it *)
        out := None;

        (trace "patch" (dprintf "newpatching %s\n" fname));
        let result = (Flx_cil_stats.time "newpatch" (Flx_cil_patch.applyFlx_cil_patch pf) cabs) in

        if (!printFlx_cil_patchedFiles) then begin                              
          let outFname:string = fname ^ ".patched" in
          (trace "patch" (dprintf "printing patched version of %s to %s\n"
                                  fname outFname));
          let o = (open_out outFname) in
          (Flx_cil_cprint.printFile o result);
          (close_out o)
        end;

        (* restore out *)
        Flx_cil_cprint.flush ();
        out := oldOut;

        result
      )
    | None -> cabs
  in

  (* print it ... *)
  (match !out with
    Some o -> begin
      (trace "sm" (dprintf "writing the cabs output\n"));
      output_string o ("/* Generated by Flx_cil_frontc */\n");
      Flx_cil_stats.time "printCABS" (Flx_cil_cprint.printFile o) patched;
      close_output ();
      raise Flx_cil_cabsOnly
    end
  | None -> ());
  if !E.hadErrors then
    raise Parsing.Parse_error;

  (* and return the patched source *)
  patched
end


(* just parse *)
and parse_to_cabs_inner (fname : string) (lang : Flx_cil_cabs.lang_t) =
  try
    if !E.verboseFlag then ignore (E.log "Flx_cil_frontc is parsing %s\n" fname);
    flush !E.logChannel;
    E.hadErrors := false;
    let lexbuf = Flx_cil_clexer.init fname lang in
    let cabs = Flx_cil_stats.time "parse" (Flx_cil_cparser.file Flx_cil_clexer.initial) lexbuf in
    Flx_cil_clexer.finish ();
    (fname, cabs)
  with (Sys_error msg) -> begin
    ignore (E.log "Cannot open %s : %s\n" fname msg);
    close_output ();
    raise (ParseError("Cannot open " ^ fname ^ ": " ^ msg ^ "\n"))
  end
  | Parsing.Parse_error -> begin
      ignore (E.log "Parsing error\n");
      close_output ();
      raise (ParseError("Parse error"))
  end
  | e -> begin
      ignore (E.log "Caught %s while parsing\n" (Printexc.to_string e));
      raise e
  end

  
(* print to safec.proto.h the prototypes of all functions that are defined *)
let printPrototypes ((fname, file) : Flx_cil_cabs.file) : unit =
begin
  (*ignore (E.log "file has %d defns\n" (List.length file));*)

  let chan = open_out "safec.proto.h" in
  ignore (fprintf chan "/* generated prototypes file, %d defs */\n" (List.length file));
  Flx_cil_cprint.out := chan;

  let counter : int ref = ref 0 in

  let rec loop (d : Flx_cil_cabs.definition) = begin
    match d with
    | Flx_cil_cabs.FUNDEF(name, _, loc, _) -> (
        match name with
        | (_, (funcname, Flx_cil_cabs.PROTO(_,_,_), _, _)) -> (
            incr counter;          
            ignore (fprintf chan "\n/* %s from %s:%d */\n"
                                 funcname loc.Flx_cil_cabs.filename loc.Flx_cil_cabs.lineno);
            flush chan;
            Flx_cil_cprint.print_single_name name;
            Flx_cil_cprint.print_unescaped_string ";";
            Flx_cil_cprint.force_new_line ();
            Flx_cil_cprint.flush ()
          )
        | _ -> ()
      )

    | _ -> ()
  end in
  (List.iter loop file);

  ignore (fprintf chan "\n/* wrote %d prototypes */\n" !counter);
  close_out chan;
  ignore (E.log "printed %d prototypes from %d defns to safec.proto.h\n"
                !counter (List.length file))
end



let parse fname lang =
  (trace "sm" (dprintf "parsing %s to Flx_cil_cabs\n" fname));
  let cabs = parse_to_cabs fname lang in
  (* Now (return a function that will) convert to CIL *)
  fun _ ->
    (trace "sm" (dprintf "converting %s from Flx_cil_cabs to CIL\n" fname));
    let cil = Flx_cil_stats.time "conv" Flx_cil_cabs2cil.convFile cabs in
    if !doPrintProtos then (printPrototypes cabs);
    cil


@h=tangler('src/flx_cil_frontc.mli')
@select(h)


   (* Signal that we are in MS VC mode *)
val setMSVCMode: unit -> unit


   (* Parse a file in *)
exception ParseError of string

   (* Raised when the front-end is requested to print the CABS and return *)
exception Flx_cil_cabsOnly

    (* additional command line arguments *)
val args: (string * Arg.spec * string) list

    (* the main command to parse a file. Return a thunk that can be used to 
     * convert the AST to CIL. *)
val parse: string -> Flx_cil_cabs.lang_t -> (unit -> Flx_cil_cil.file)

@h=tangler('src/flx_cil_lexerhack.mli')
@select(h)
val add_identifier : (string -> unit) ref
val add_type : (string -> unit) ref
val push_context : (unit -> unit) ref
val pop_context : (unit -> unit) ref
val currentPattern : string ref

@h=tangler('src/flx_cil_lexerhack.ml')
@select(h)

module E = Flx_cil_errormsg

(* We provide here a pointer to a function. It will be set by the lexer and 
 * used by the parser. In Ocaml lexers depend on parsers, so we we have put 
 * such functions in a separate module. *)
let add_identifier: (string -> unit) ref = 
  ref (fun _ -> E.s (E.bug "You called an uninitialized add_identifier")) 

let add_type: (string -> unit) ref = 
  ref (fun _ -> E.s (E.bug "You called an uninitialized add_type")) 

let push_context: (unit -> unit) ref = 
  ref (fun _ -> E.s (E.bug "You called an uninitialized push_context")) 

let pop_context: (unit -> unit) ref = 
  ref (fun _ -> E.s (E.bug "You called an uninitialized pop_context")) 


(* Keep here the current pattern for formatparse *)
let currentPattern = ref ""

