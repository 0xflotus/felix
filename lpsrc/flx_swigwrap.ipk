@head(1,"Felix swig interfaces")
These files are used to build wrappers for 
C libraries using the felix language module
of swig.
@p()
Hack for missing config file, copy to usr/lib/pkconfig
if its missing from your system, as it is mine.
@select(tangler('misc/libgsf-1.pc','data'))
prefix=/usr
exec_prefix=/usr
libdir=/usr/lib
includedir=/usr/include

Name: libgsf-1
Description: Replace missing file
Version: 0.0.0
Requires: glib-2.0 
Libs: -L${libdir} -lgsf-1
Cflags: -I${includedir}/libgsf-1

@h = tangler('swig/makewrap','data')
@select(h)
@interfaces = [
  ('glib-2.0',()),
  ('gobject-2.0',('glib-2.0',)),
  ('gmodule-2.0',('glib-2.0',)),
  ('gdk-2.0',('glib-2.0',)),
  ('pango',()),
  ('gtk+-2.0',('gdk-2.0','pango')),
  ('slack',()),
  ('gmp',())
  ]

@tests = [
  ("gdk_runme",["gdk-2.0"]),
  ("gtk_runme",["gtk+-2.0"]),
  ]

@flxs = ""
@for i,deps in interfaces: flxs = flxs + " " + i + ".flx"
@tangle("all: "+flxs)

@for i,deps in interfaces:
  ds = i
  for j in deps: ds = ds + " " + j
  tangle("")
  tangle(i +".flx: "+i+".i")
  tangle("\t./dynswig -extend=./felix.so -felix -I. -I/usr/include `pkg-config --cflags "+ds+"` -o "+i+".flx "+i+".i")

clean:
@for i,deps in interfaces:
  tangle("\trm -f "+i+".flx "+i+".fix")
@for i,p in tests:
  tangle("\trm -f "+i+".hpp "+i+".cpp "+i+".so")

@tangle("test: "+flxs)
@tangle('\techo "WARNING: tests invoked by installed system"')
@for i,p in tests:
  pkgs = ""
  for pkg in p: pkgs = "--pkg="+pkg+" "
  tangle("\tflx  "+pkgs+i)


@head(1,'Common Gnu stuff')
@h = tangler("swig/gnu.swg","data")
@select(h)
// General notes
//
// We try to eliminate all the GNU, Glib, and other
// crap from the interface: Glib/Gdk/Gtk is very C
// dependent and highly fragile .. macros and casts
// abound 

// get rid of GNU crap
#define G_GNUC_CONST
#define G_CONST_RETURN const
#define G_BEGIN_DECLS
#define G_END_DECLS
#define G_GNUC_PRINTF(x,y)

// replace glib type names with standard ones
/*
#define gint int
#define guint unsigned int
#define gchar char
#define guchar unsigned char
#define gboolean int
#define gshort short
#define gushort unsigned short
#define gulong unsigned long

#define gint8 int8_t
#define gint16 int16_t
#define gint32 int32_t
#define gint64 int64_t

#define guint8 uint8_t
#define guint16 uint16_t
#define guint32 uint32_t
#define guint64 uint64_t

#define gfloat float
#define gdouble double
#define gldouble long double
#define gpointer void*
*/

@head(1,"glib")
@h = tangler("swig/glib-2.0.i","data")
@select(h)
%module glib2
%header %{
#include <glib/glib.h>
%}

%include gnu.swg

#define GLIB_SYSDEF_POLLIN =1
#define GLIB_SYSDEF_POLLOUT =4
#define GLIB_SYSDEF_POLLPRI =2
#define GLIB_SYSDEF_POLLHUP =16
#define GLIB_SYSDEF_POLLERR =8
#define GLIB_SYSDEF_POLLNVAL =32

%define read(name)
%felix %{
open g##name;
module g#name 
{
%}
/*
%include glib/g##name.h
*/
%include glib/g##name.h
%felix %{}
%}
%enddef

read(alloca);
read(array);
read(asyncqueue);
read(backtrace);
read(cache);
read(completion);
read(convert);
read(dataset);
read(date);
read(dir);
read(error);
read(fileutils);
read(hash);
read(hook);
read(iochannel);
read(list);
read(macros);
read(main);
read(markup);
read(mem);
read(messages);
read(node);
read(pattern);
read(primes);
read(qsort);
read(quark);
read(queue);
read(rand);
read(rel);
read(scanner);
read(shell);
read(slist);
read(spawn);
read(strfuncs);
read(string);
read(thread);
read(threadpool);
read(timer);
read(tree);
read(types);
read(unicode);
read(utils);

#ifdef G_PLATFORM_WIN32
#include <glib/gwin32.h>
#endif

@head(1,"gobject")
@h = tangler("swig/gobject-2.0.i","data")
@select(h)
%module gobject2
%header %{
#include <glib/gobject.h>
%}

%include gnu.swg

%define read(name)
%felix %{
open gobject##name;
module gobject#name 
{
%}
/*
%include gobject/g##name.h
*/
%include gobject/g##name.h
%felix %{}
%}
%enddef

%read(boxed);
%read(closure);
%read(enums);
%read(marshal);
%read(object);
%read(param);
%read(paramspecs);
%read(signal);
%read(sourceclosure);
%read(type);
%read(typemodule);
%read(typeplugin);
%read(valuearray);
%read(valuecollector);
%read(value);
%read(valuetypes);

@head(1,"gmodule")
@h = tangler("swig/gmodule-2.0.i","data")
@select(h)
%module gmodule2
%header %{
#include <gmodule.h>
%}

%include gnu.swg

%bitmask(GModuleFlags)

%felix %{
open gmodule;
module gmodule {
%}

/*
%include gmodule.h
*/
%include gmodule.h
%felix %{
}
%}

@head(1,"gdk")

@h = tangler("swig/gdk-2.0.i","data")
@select(h)
%module gdk2
%header %{
#include <gdk/gdk.h>
%}

%include gnu.swg

%bitmask(GdkGCValuesMask)
%bitmask(GdkDragAction)
%bitmask(GdkEventMask)
%bitmask(GdkWindowAttributesType)

%callback_type(GdkInputFunction,1)
%callback_type(GdkEventFunc,2)
%callback_type(GdkFilterFunc,3)
%callback_type(GdkDestroyNotify,1)
%callback_type(GdkSpanFunc,2)

%callback_client(gdk_input_add_full,3,4)

%alias(GdkWChar)
%abstract(GdkAtom)
%abstract(GdkNativeWindow)

// X windows stuff
%felix %{
ctypes
  Display,
  XID,
  Cursor,
  Visual,
  Screen,
  Colormap,
  Atom,
  XImage,
  GC,
  Window,
  VisualID
;
%}

// cant handle this one, its weird (two callbacks and no client data)
%ignore gdk_input_add_full;

// this is hacked in gdkevents, by a typedef to void,
// the idea is to cast it
// -- to XEvent (in unix) or
// -- to MSG (in Windows)
// GdkFilterFunc uses a pointer to this type,
// which becomes a void*.
//
// Felix cant tolerate GdkXEvent as a type,
// because it tries to model it as an abstraction:
// even if it isn't used, we get a ptr_map (RTTI)
// structure generated which tries to take the sizeof void
//
%ignore GdkXEvent;
%felix %{
  incomplete ctypes GdkXEvent;
%}

// dont expose mutex variable
%ignore gdk_threads_mutex;

// Glib crap: these things are macroish, not real types
%felix %{
ctypes 
  GObject, 
  GObjectClass
;
%}


// Glib types
// we will have to wrap this one .. later
%felix %{
ctypes 
  GValue,
  GList,
  GSList,
  GDestroyNotify
;
%}

// gdk has some deliberately incomplete types
// we need to wrap them somehow .. this is a hack
// since it will be universally useless, need to
// figure out the correct technique a bit later ..
%felix %{
ctypes 
  _GdkDisplayManager,
  _GdkRegion
;
%}

// pixbufs -- temporarily make them abstract
// need to fix I guess ..
%felix %{
ctypes 
  GdkPixbuf,
  GdkPixbufAlphaMode
;
%}

// Pango things
// need to fix I guess ..
%felix %{
ctypes 
  PangoFont, 
  PangoFontDescription, 
  PangoGlyphString,
  PangoLayout,
  PangoLayoutLine,
  PangoDirection,
  PangoContext,
  PangoAttribute
;
%}

%define read(name)
%felix %{
open gdk##name;
module gdk##name 
{
%}
/*
%include gdk/gdk##name.h
*/
%include gdk/gdk##name.h
%felix %{}
%}
%enddef

%felix %{
typedef GType = ulong;
%}

%felix %{
open gdktypes;
module gdktypes
{
%}
%include gdk/gdktypes.h
%felix %{
}%}


#undef GDKVAR
#define GDKVAR
%felix %{
open gdk;
module gdk 
{
%}
%include gdk/gdk.h
%felix %{
}%}
#undef GDKVAR
#define GDKVAR

read(color);
read(cursor);
read(display);
read(displaymanager);
read(dnd);
read(drawable);
read(enumtypes);
read(events);
read(font);
read(gc);
read(i18n);
read(image);
read(input);
read(keys);
read(keysyms);
read(pango);
read(pixbuf);
read(pixmap);
read(private);
read(property);
read(region);
read(rgb);
read(screen);
read(selection);
read(visual);
read(window);
read(x);

@select(tangler('swig/gdk_runme.flx','C'))
include "std";
include "gdk-2.0.";

// build args in C
body 'char *args[] = {"STRING1","STRING2"};';
const args : ptr[charp] = 'args';
val argv : ptr[charp] = args;
var pargv: ptr[ptr[charp]] = addr(argv);

var argc: int = 2;
val pargc: ptr[int] = addr(argc);

print "Initialising gdk\n";

val result = gdk_init_check(pargc,pargv);

print "gdk initialised with result ";
print result;
endl;

val sw = gdk_screen_width();
val sh = gdk_screen_height();

print "Screen size = "; print sw; print " x "; print sh; endl;

// from example 2, gdk reference manual
val display : ptr[GdkDisplay] = gdk_display_get_default();
val num_screen = gdk_display_get_n_screens(display);
val displayname = gdk_display_get_name(display);

if (num_screen <= 1) then
  {
    print "This Xserver (";
    print displayname;
    print ") manages only one screen. exiting...\n";
  }
else
  {
    print "This Xserver (";
    print displayname;
    print ") manages ";
    print num_screen;
    print " screens.\n";
  }  
endif;

val my_parent = null_ptr[GdkWindow];
const my_winname : charp = '"My Window"';

val my_attributes_mask = _bor (_bor (GDK_WA_TITLE, GDK_WA_X),  GDK_WA_Y);
var my_attributes =  dflt[GdkWindowAttr]();
val p = addr(my_attributes);
set_title(p, my_winname);
set_x(p,10);
set_y(p,10);
set_width(p,100);
set_height(p,100);
set_wclass(p,GDK_INPUT_OUTPUT);
set_window_type(p,GDK_WINDOW_TOPLEVEL);
set_override_redirect(p,0);
var w = 
  gdk_window_new
  (
    my_parent, 
    p, 
    int_of(my_attributes_mask)
  )
;

gdk_window_set_cursor(w,null_ptr[GdkCursor]);

gdk_window_show(w);

gdk_notify_startup_complete();

gdk::gdk_exit(0);

@head(1,"pango")
@h = tangler("swig/pango.i","data")
@select(h)
%module pango
%include gnu.swg

%define read(name)
%felix %{
open pango#name;
module pango##name 
{
%}
/*
%include pango/pango-##name.h
*/
%include pango/pango-##name.h
%felix %{}
%}
%enddef

read(attributes)
read(break)
read(context)
read(coverage)
read(engine)
read(enum-types);
read(font);
read(fontmap);
read(glyph);
read(item);
read(layout);
read(types);


@head(1,"gtk")
@h = tangler("swig/gtk+-2.0.i","data")
@select(h)
%module gtk2
%include gnu.swg

%felix %{
open gdk;
open pango;
%}

%define read(name)
%felix %{
open gtk##name;
module gtk##name 
{
%}
/*
%include gtk/gtk##name.h
*/
%include gtk/gtk##name.h
%felix %{}
%}
%enddef


read(main);
read(typebuiltins);
/*read(typeutils);*/

read(accelgroup);
read(accellabel);
read(accelmap);
read(accessible);
read(adjustment);
read(alignment);
read(arrow);
read(aspectframe);
read(bbox);
read(bindings);
read(bin);
read(box);
read(button);
read(calendar);
read(celleditable);
read(cellrenderer);
read(cellrendererpixbuf);
read(cellrenderertext);
read(cellrenderertoggle);
read(checkbutton);
read(checkmenuitem);
read(clipboard);
read(clist);
read(colorseldialog);
read(colorsel);
read(combo);
read(container);
read(ctree);
read(curve);
read(debug);
read(dialog);
read(dnd);
read(drawingarea);
read(editable);
read(entry);
read(enums);
read(eventbox);
read(filesel);
read(fixed);
read(fontsel);
read(frame);
read(gamma);
read(gc);
read(handlebox);
read(hbbox);
read(hbox);
read(hpaned);
read(hruler);
read(hscale);
read(hscrollbar);
read(hseparator);
read(iconfactory);
read(image);
read(imagemenuitem);
read(imcontext);
read(imcontextsimple);
read(immodule);
read(immulticontext);
read(inputdialog);
read(invisible);
read(itemfactory);
read(item);
read(label);
read(layout);
read(list);
read(listitem);
read(liststore);
read(marshal);
read(menubar);
read(menu);
read(menuitem);
read(menushell);
read(messagedialog);
read(misc);
read(notebook);
read(object);
read(oldeditable);
read(optionmenu);
read(paned);
read(pixmap);
read(plug);
read(preview);
read(private);
read(progressbar);
read(progress);
read(radiobutton);
read(radiomenuitem);
read(range);
read(rc);
read(ruler);
read(scale);
read(scrollbar);
read(scrolledwindow);
read(selection);
read(separator);
read(separatormenuitem);
read(settings);
read(signal);
read(sizegroup);
read(socket);
read(spinbutton);
read(statusbar);
read(stock);
read(style);
read(table);
read(tearoffmenuitem);
read(textbuffer);
read(textchild);
read(textdisplay);
read(text);
read(textiter);
read(textlayout);
read(textmark);
read(texttag);
read(texttagtable);
read(textview);
read(tipsquery);
read(togglebutton);
read(toolbar);
read(tooltips);
read(treednd);
read(tree);
read(treeitem);
read(treemodel);
read(treemodelsort);
read(treeselection);
read(treesortable);
read(treestore);
read(treeviewcolumn);
read(treeview);
read(vbbox);
read(vbox);
read(version);
read(viewport);
read(vpaned);
read(vruler);
read(vscale);
read(vscrollbar);
read(vseparator);
read(widget);
read(window);

@select(tangler('swig/gtk_runme.flx','C'))
include "std";
include "gtk+-2.0.";

/* Hello world from gtk tutorial */

/* This is a callback function. The data arguments are ignored
 * in this example. More on callbacks below. */

proc hello(widget:ptr[GtkWidget])
{
    print ("Hello World\n");
}

fun delete_event
( 
  widget: ptr[GtkWidget],
  event: ptr[GdkEvent]
) 
: int = 
{
    /* If you return FALSE in the "delete_event" signal handler,
     * GTK will emit the "destroy" signal. Returning TRUE means
     * you don't want the window to be destroyed.
     * This is useful for popping up 'are you sure you want to quit?'
     * type dialogs. */

    print ("delete event occurred\n");

    /* Change TRUE to FALSE and the main window will be destroyed with
     * a "delete_event". */

    return 1;
}

/* Another callback */
proc destroy( widget: ptr[GtkWidget])
{
    gtk_main_quit ();
}

/* mainline */

    /* GtkWidget is the storage type for widgets */
    var window: ptr[GtkWidget];
    var button: ptr[GtkWidget];
    
    /* This is called in all GTK applications. Arguments are parsed
     * from the command line and are returned to the application. */
    body 'char *args[] = {"STRING1","STRING2"};';
    const args : ptr[charp] = 'args';
    val argv : ptr[charp] = args;
    var pargv: ptr[ptr[charp]] = addr(argv);

    var argc: int = 2;
    val pargc: ptr[int] = addr(argc);

    print "Initialising gtk\n";
    gtk_init(pargc,pargv);

    /* create a new window */
    window = gtk_window_new (GTK_WINDOW_TOPLEVEL);
    
/*
    /* When the window is given the "delete_event" signal (this is given
     * by the window manager, usually by the "close" option, or on the
     * titlebar), we ask it to call the delete_event () function
     * as defined above. The data passed to the callback
     * function is NULL and is ignored in the callback function. */
    g_signal_connect (G_OBJECT (window), "delete_event",
		      G_CALLBACK (delete_event), NULL);
    
    /* Here we connect the "destroy" event to a signal handler.  
     * This event occurs when we call gtk_widget_destroy() on the window,
     * or if we return FALSE in the "delete_event" callback. */
    g_signal_connect (G_OBJECT (window), "destroy",
		      G_CALLBACK (destroy), NULL);
    
    /* Sets the border width of the window. */
    gtk_container_set_border_width (GTK_CONTAINER (window), 10);
*/    
    /* Creates a new button with the label "Hello World". */
    button = gtk_button_new_with_label ("Hello World");
/* 
    /* When the button receives the "clicked" signal, it will call the
     * function hello() passing it NULL as its argument.  The hello()
     * function is defined above. */
    g_signal_connect (G_OBJECT (button), "clicked",
		      G_CALLBACK (hello), NULL);
    
    /* This will cause the window to be destroyed by calling
     * gtk_widget_destroy(window) when "clicked".  Again, the destroy
     * signal could come from here, or the window manager. */
    g_signal_connect_swapped (G_OBJECT (button), "clicked",
			      G_CALLBACK (gtk_widget_destroy),
                              G_OBJECT (window));
    
    /* This packs the button into the window (a gtk container). */
    gtk_container_add (GTK_CONTAINER (window), button);
*/  
    /* The final step is to display this newly created widget. */
    gtk_widget_show (button);
    
    /* and the window */
    gtk_widget_show (window);
    
    /* All GTK applications must have a gtk_main(). Control ends here
     * and waits for an event to occur (like a key press or
     * mouse event). */
    gtk_main ();
    

@head(1,"slack")
Raf's libslack utilities.
NOTE: we ran the tool (in tools directory)

prefix slack

to prepend all names with 'slack_'.
You need that, for the below stuff to work.
@select(tangler('misc/slack.pc','data'))
prefix=/usr
exec_prefix=/usr/local
libdir=/usr/local/lib
includedir=/usr/local/include

Name: slack
Description: Replace missing file
Version: 0.6.0
Requires: 
Libs: -L${libdir} -lslack
Cflags: -I${includedir}

@h = tangler("swig/slack.i","data")
@select(h)
%module slack
#define __STDC__
%import <slack/hdr.h>

%callback_type(slack_agent_action_t,2)
%callback_type(slack_agent_reaction_t,2)
%callback_type(slack_daemon_config_parser_t,1)

%include slack/agent.h
%include slack/coproc.h
%include slack/daemon.h
%include slack/fio.h
%include slack/hsort.h
%include slack/lim.h
%include slack/link.h
%include slack/list.h
%include slack/locker.h
%include slack/map.h
%include slack/mem.h
%include slack/msg.h
%include slack/net.h
%include slack/prog.h
%include slack/prop.h
%include slack/pseudo.h
%include slack/sig.h
%include slack/socks.h
%include slack/str.h

@head(1,'gmp')
Warning .. there is a bug in swig 1.1.20 preprocessor
handling trailing \ in preprocessor directives.
Please use 1.1.21 or the CVS version of swig patched
for felix, or apply the swig preprocessor patch provided.

@select(tangler('misc/gmp.pc','data'))
prefix=/usr
exec_prefix=/usr
libdir=/usr/lib
includedir=/usr/include

Name: gmp
Description: GNU Multiple precision arithmetic
Requires:
Version: 3.3.2 
Libs: -L${libdir} -lgmp
Cflags: -I${includedir}


@h = tangler("swig/gmp.i","data")
@select(h)
%module gmp
%header %{
#include <gmp.h>
%}

%ignore __GMP_HAVE_HOST_CPU_FAMILY_power;
%ignore __GMP_HAVE_HOST_CPU_FAMILY_powerpc;
%ignore __GMP_LIBGMP_DLL;
%ignore __GMP_HAVE_CONST;
%ignore __GMP_HAVE_PROTOTYPES;
%ignore __GMP_HAVE_TOKEN_PASTE;
%ignore __GMP_INLINE_PROTOTYPES;
%ignore __GMP_MP_SIZE_T_INT;

%abstract(mp_limb_t)
%abstract(mp_limb_signed_t)
%alias(mp_ptr)
%alias(mp_srcptr)

%abstract(mpz_t)
%abstract(mpq_t)
%abstract(mpf_t)

%alias(mpz_ptr)
%alias(mpz_srcptr)
%alias(mpq_ptr)
%alias(mpq_srcptr)
%alias(mpf_ptr)
%alias(mpf_srcptr)

%alias(mp_size_t)
%alias(mp_exp_t)
#define __STDC__


%include <gmp.h>

