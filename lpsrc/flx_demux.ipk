@head(1,'demux')
@execfile('config'+os.sep+'config.py')
@h=tangler('demux/demux_demuxer.hpp')
@select(h)
#ifndef __DEMUXER__
#define __DEMUXER__
#include <flx_rtl_config.hpp>

typedef struct {
  char*   buffer;           // set on input
  long    buffer_size;        // set on input
  long    bytes_written;        // set on input and output
}sel_param;

// abstract base class(gee - it doesn't do much)
class FLX_RTL_EXTERN demuxer {
protected:
public:
  virtual ~demuxer() {}
};

#endif  /* __DEMUXER__ */

@h=tangler('demux/demux_epoll_demuxer.hpp')
@select(h)
#ifndef __EPOLL_DEMUXER__
#define __EPOLL_DEMUXER__

#include <flx_rtl_config.hpp>
#include "demux_posix_demuxer.hpp"

class FLX_RTL_EXTERN epoll_demuxer : public posix_demuxer {
  int   epoll_fd;

  virtual void  thread_loop_body();
  void    cleanup();

  void  remove_socket(int s, bool read);

public:
  epoll_demuxer();
  virtual ~epoll_demuxer();
  
  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

#endif

@h=tangler('demux/demux_evtport_demuxer.hpp')
@select(h)
#ifndef __EVTPORT_DEMUXER__
#define __EVTPORT_DEMUXER__

// driver for solaris 10 event port notifications

#include <flx_rtl_config.hpp>
#include "demux_posix_demuxer.hpp"

class FLX_RTL_EXTERN evtport_demuxer : public posix_demuxer {
    int     evtport;
  void  cleanup();
protected:
    virtual void    thread_loop_body();

  void remove_reading_fd(int s);
  void remove_writing_fd(int s);
public:
  evtport_demuxer();
  virtual ~evtport_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

#endif

@h=tangler('demux/demux_iocp_demuxer.hpp')
@select(h)
#ifndef __IOCP_DEMUXER__
#define __IOCP_DEMUXER__

// includes WinBase.h, where CreateIOCompletionPort lives
// May need to define _WIN32_WINNT = 0x0350? Or not.
#include <Windows.h>
#include <flx_rtl_config.hpp>

#include "demux_demuxer.hpp"
#include "demux_sleep_queue.hpp"


// not here? returns INVALID_SOCKET on failure (unlike posix version,
// this doesn't let the os choose the port - make it so).
SOCKET create_listener_socket(int port, int backlog);


// this thing isn't actually being used by the iocp code. it should be.
class FLX_RTL_EXTERN win_thread {
  HANDLE    thread;
  HANDLE    cancel_evt;

public:
  win_thread();
  ~win_thread();
  int init(LPTHREAD_START_ROUTINE, LPVOID lParam);
  void deinit();
};

// iocp_wakeup base class FLX_RTL_EXTERN for users of iocp_demuxer
class FLX_RTL_EXTERN iocp_wakeup {
public:
  OVERLAPPED  ol;
  // I didn't want this to be felixy, useful though.
protected:            // folks need to use these in win 32 calls
  void clear_overlapped();  // zero the OVERLAPPED structure
public:
  // 2 possibilities for piggybacking data. who could ask for more?
  // why don't I need this in the posix version?
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err) = 0;

  // retrieves this pointer from OVERLAPPED pointer
  static iocp_wakeup* from_overlapped(LPOVERLAPPED olp);
};

class FLX_RTL_EXTERN iocp_demuxer : public demuxer {
  HANDLE    iocp;     // the io completion queue
  win_thread  iocp_thread;  // our "select" thread

  // necessary windows magic for CreateThread
  // see CreateThread example code on MSDN
  static DWORD WINAPI worker_thread_stub(LPVOID lParam);
  void    worker_thread_body();

  void    cleanup();
public:
  iocp_demuxer();
  virtual ~iocp_demuxer();

  // udat is a spare user cookie - probably not used very often
  // the OVERLAPPED retrieved from the iocp is assumed to be part of
  // an iocp_wakeup - beware!
  int associate_with_iocp(HANDLE obj, ULONG_PTR udat);
};

// synchronisation stuff
class FLX_RTL_EXTERN win_locker {
  HANDLE  m;
public:
  win_locker(HANDLE mutex);
  ~win_locker();
};

class FLX_RTL_EXTERN win_queue  : public sleep_queue {
  HANDLE    member_lock;  // protects member data
  HANDLE    nz_elts_cond; // wakes up threads waiting on resource
  void*     lame_opaque;  // when will I ever learn?
  void      cleanup();
public:
  win_queue();
  ~win_queue();

  virtual void enqueue(void*);  // re-entrant
  virtual void* dequeue();    // re-entrant, sleeps on empty queue
};

#endif

@h=tangler('demux/demux_kqueue_demuxer.hpp')
@select(h)
#ifndef __KQUEUE_DEMUXER__
#define __KQUEUE_DEMUXER__

#include "demux_posix_demuxer.hpp"

class FLX_RTL_EXTERN kqueue_demuxer : public posix_demuxer {
  int   kq;
protected:
  virtual void  thread_loop_body();

  void remove_reading_fd(int s);
  void remove_writing_fd(int s);

  int add_reading_socket(socket_wakeup* sv);
  int add_writing_socket(socket_wakeup* sv);

  void cleanup();
public:
  kqueue_demuxer();
  virtual ~kqueue_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

#endif

@h=tangler('demux/demux_mutexlite.hpp')
@select(h)
#ifndef __MUTEXLITE__
#define __MUTEXLITE__
#include <flx_rtl_config.hpp>

// simple mutex. call lock, unlock
// not sure that I'm locking properly. may need cancel handlers.

#include <pthread.h>

class FLX_RTL_EXTERN pmut {
public:
  pthread_mutex_t m;        // be nice, don't touch

  pmut(bool recursive);
  ~pmut();
  void lock();
  void unlock();
};

// simple locker
class FLX_RTL_EXTERN pmut_locker {
  pmut& p;
public:
  pmut_locker(pmut& pm) : p(pm) { p.lock(); }
  ~pmut_locker() { p.unlock(); }
};

// auto pthread, because I forget how to deallocate them nicely
// could init in the constructor, but ultimately you don't want the thread
// barging in before you've finished doing other stuff
// Addendum (20051128): doing stdio in turns out to be not very safe.
// I don't know if printf et al are supposed to be thread safe (most impls
// seem to try to be) but I sometimes get deadlocks in ppc64 os x 10.4.2
// with 4.0.1 when printfing to stdout. Nasty.
class FLX_RTL_EXTERN apthread {
  pthread_t   thr;        // the thread
  bool      inited;       // do I need this or is pthread_t a pointer?
public:
  apthread() : inited(false) {}
  ~apthread();

  pthread_t get() { return thr; }
  
  int init(void* (*start)(void*), void* udat);
  void deinit();  
  int cancel();
};

#endif

@h=tangler('demux/demux_pfileio.hpp')
@select(h)
#ifndef __PFILEIO__
#define __PFILEIO__
#include <flx_rtl_config.hpp>

#include "demux_demuxer.hpp"
#include "demux_posix_queue.hpp"
#include "demux_mutexlite.hpp"
// #include <sys/types.h> // off_t (don't have flx iface to this yet)
              // can just add new constructor
#include "demux_work_fifo.hpp"

// like another event source. this is basically a wrapped pread, pwrite
// should probably be derived from posix_wakeup or something like that.
// or have the same signature. abstract - users overload "finished
class FLX_RTL_EXTERN fileio_request : public worker_task
{
  long    offset;   // make this a proper offset (64bit)
  // off_t    offset; // in: offset, for use with pread, pwrite
  int     fd;     // in: fd in question
  bool    read_flag;  // in: read else write

  int     err;    // out:
public:
  // public so it can be got in felix
  sel_param pb;   // in & out: what you want, what you get (64bit len?)

  virtual ~fileio_request() {}  // c++ should do this automatically
  fileio_request()  {}      // flx linkage
  fileio_request(int f, char* buf, long len, long off, bool rd);

  virtual void doit();      // sync
};

// could do separate threads for in & out. or implement some form of cache.
class FLX_RTL_EXTERN pasync_fileio : public worker_fifo
{
public:
  // compatibility only. don't need this class anymore.
  void add_fileio_request(fileio_request* req) { add_worker_task(req); } 
};

#endif  // __PFILEIO__

@h=tangler('demux/demux_posix_demuxer.hpp')
@select(h)
#ifndef __POSIX_DEMUXER__
#define __POSIX_DEMUXER__

// this is simply a demuxer with a pthread that calls thread_loop_body
// with a thread cancel hook and a hopefully correct destructor. hoof!
// it also owns an optional listener socket. imagine that!s

#include <pthread.h>
#include "demux_demuxer.hpp"
#include "demux_mutexlite.hpp"

class FLX_RTL_EXTERN posix_demuxer;            // fwd decl

// abc
class FLX_RTL_EXTERN posix_wakeup {
public:
  virtual ~posix_wakeup() {}

  // when called, the wakeup has finished and been removed.
  virtual void wakeup(posix_demuxer& demux) = 0;
};

class FLX_RTL_EXTERN socket_wakeup : public posix_wakeup {
public:
  int   s;                // the non blocking socket
};

class FLX_RTL_EXTERN posix_demuxer : public demuxer {
  apthread    evt_pthr;       // the event loop thread
  static void*  thread_start(void*);  // bootstrap thread callback

protected:
  virtual void  thread_loop_body() = 0;
  int       init_pthread();
  void      deinit_pthread();
  
public:
  virtual ~posix_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, bool read) = 0;
  
  // to be called when we can read & write without blocking
  // return true if connection closed, update pb
  static bool   handle_socket_read(int s, sel_param* pb);
  static bool   handle_socket_write(int s, sel_param* pb);
};

#endif

@h=tangler('demux/demux_posix_queue.hpp')
@select(h)
#ifndef __POSIX_QUEUE__
#define __POSIX_QUEUE__
#include "demux_mutexlite.hpp"
#include "demux_sleep_queue.hpp"
#include <flx_rtl_config.hpp>

class FLX_RTL_EXTERN posix_queue  : public sleep_queue {
  pmut      member_lock;  // protects member data
  pthread_cond_t  nz_elts_cond; // wakes up threads waiting on resource
  void*     lame_opaque;  // when will I ever learn?
public:
  posix_queue();
  ~posix_queue();

  virtual void enqueue(void*);    // re-entrant
  virtual void* dequeue();      // re-entrant, sleeps on empty queue
};

#endif  // __POSIX_QUEUE__

@h=tangler('demux/demux_select_demuxer.hpp')
@select(h)
#ifndef __SELECT_DEMUXER__
#define __SELECT_DEMUXER__

#include "demux_posix_demuxer.hpp"
#include "demux_mutexlite.hpp"
#include <sys/select.h>   // for fd_set

class FLX_RTL_EXTERN select_demuxer : public posix_demuxer {
  // still using these, but they're not virtual - make them private &
  // remove the locks?
  void  remove_reading_fd(int s);
  void  remove_writing_fd(int s);


  pmut      ham_fist;       // big conservative hamfisted lock
  
  // thanks Beej!
  fd_set      master_read_set;    // all the threads we're watching, reading
  fd_set      master_write_set;   // writing
  socket_wakeup*  read_svs[FD_SETSIZE]; // read sveglias
  socket_wakeup*  write_svs[FD_SETSIZE];  // write wakeups

  int       fdmax;          // high watermark for select
  
  virtual void  thread_loop_body();

public:
  select_demuxer();
  ~select_demuxer() { deinit_pthread(); }

  virtual int   add_socket_wakeup(socket_wakeup* sv, bool read);
};

#endif

@h=tangler('demux/demux_sleep_queue.hpp')
@select(h)
#ifndef __SLEEPQUEUE__
#define __SLEEPQUEUE__
#include <flx_rtl_config.hpp>


// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

class FLX_RTL_EXTERN sleep_queue {
public:
  virtual ~sleep_queue() {}

  virtual void enqueue(void*) = 0;  // re-entrant
  virtual void* dequeue() = 0;    // re-entrant, sleeps on empty queue
};

#endif

@h=tangler('demux/demux_sleep_task.hpp')
@select(h)
#ifndef __SLEEP_TASK__
#define __SLEEP_TASK__
#include <flx_rtl_config.hpp>

// this is a sort of worker_fifo, but with a prio queue that never sleeps
#include "demux_work_fifo.hpp"

#include "demux_mutexlite.hpp"

// class sleep_task : public worker_task
// may not need time in here - just the wakeup - something I surely have
// somewhere else.
class FLX_RTL_EXTERN sleep_task
{
public:
  virtual ~sleep_task() {}

  virtual void fire() = 0;
};

// not quite the right thing - this isn't a work queue
// it needs a prio queue
// class sleep_task_queue : public worker_fifo
// don't want a worker_fifo
class FLX_RTL_EXTERN sleep_task_queue
{
  // ATTENZIONE: the thread uses this & so it must outlive it
  // for this it is declared before the thread (I would've expected
  // an error to be returned from pthread_mutex_lock instead of
  // deadlock but whatever).
  // update: I was getting deadlock in a broken stdlib version
  // gcc4.0.1, ppc64, osx10.4.2 in printf, however the above still
  // stands: the lock must outlive the thread that uses it.
  pmut    lock;         // factor to prio queue?

  apthread  sleep_thread;
  static void* thread_start(void*); // passed "this"
  void thread_loop_body();

  void*   opaque_prio_queue;    // less fat

  pthread_cond_t  sleep_cond;     // this could be cool.
  int setup_sleep_cond();
  void takedown_sleep_cond();

  void wakeup_thread();       // we can do this!
public:
  sleep_task_queue();
  ~sleep_task_queue();

  void add_sleep_request(sleep_task* st, double delta);
};

#endif // __SLEEP_TASK__
@h=tangler('demux/demux_sockety.hpp')
@select(h)
#ifndef __SOCKETY__
#define __SOCKETY__
#include <flx_rtl_config.hpp>
int create_listener_socket(int* io_port, int q_len);
int nice_create_listener(int* io_port, int q_len);
int nice_accept(int listener);
int nice_connect(const char* addr, int port);
int async_connect(const char* addr, int port, int* finished);
#endif

@h=tangler('demux/demux_work_fifo.hpp')
@select(h)
#ifndef __WORKER_FIFO__
#define __WORKER_FIFO__
#include <flx_rtl_config.hpp>

#include "demux_posix_queue.hpp"
#include "demux_mutexlite.hpp"

// abstract 
class FLX_RTL_EXTERN worker_task
{
public:
  virtual ~worker_task() {}   // c++ should do this automatically

  virtual void doit() = 0;    // doit, synchronously
  virtual void finished() = 0;  // finished hook (mi serve start gancia?)
};

// make this into a general work queue
class FLX_RTL_EXTERN worker_fifo
{
  apthread  io_thread;
  
  static void* thread_start(void*); // io thread entry point, passed this

  void thread_loop_body();

  posix_queue fifo;         // reentrant fifo!
public:
  worker_fifo();

  void add_worker_task(worker_task* task);  // re-entrant?
};

#endif  // __WORKER_FIFO__
@h=tangler('demux/demux_demuxer.cpp')
@select(h)
#include "demux_demuxer.hpp"

// nothing here atm ..

@h=tangler('demux/demux_epoll_demuxer.cpp')
@select(h)
// epoll interface. does epoll support ordinary files in addition to sockets?

// cool! EPOLLONESHOT
// BUGGER! doesn't seem to exist! and doing this doesn't make it so!
// #ifndef EPOLLONESHOT
// #define EPOLLONESHOT (1<<30)
// #endif

#include "demux_epoll_demuxer.hpp"

#include <sys/epoll.h>  // for epoll_*
#include <stdio.h>  // for perror
#include <unistd.h> // for close

epoll_demuxer::epoll_demuxer()
  : epoll_fd(-1)
{
#ifdef EPOLLONESHOT
  printf("WARNING: EPOLLONESHOT AVAILABLE!!!\n");
#endif

  // god knows what the maximum size will be, I'll just say 1 for now
  epoll_fd = epoll_create(1);
  if(-1 == epoll_fd)
  {
    perror("epoll_create");
    cleanup();
    throw -1;
  }

  int res = init_pthread();
  if(res != 0)
  {
    cleanup();
    throw res;
  }
}

void
epoll_demuxer::cleanup() {
  deinit_pthread();

  if(-1 != epoll_fd)
  {
    if(close(epoll_fd) != 0)
      perror("epoll close");
  }
}

epoll_demuxer::~epoll_demuxer()
{
  cleanup();
}

int
epoll_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  int s = sv->s;

  struct epoll_event  evt;
  // printf("add_socket_wakeup: %sing on %i (sv=%p)\n",
  //  (read) ? "read" : "writ", s, sv);

  // EPOLLONESHOT saves us not only a system call to remove epoll evts,
  // which aren't intrinsically one-shot, but having to do it ourselves
  // would have been a pain as epoll doesn't tell you which fd had the event
  // this way we can get away with not knowing & not losing our user cookie
  evt.events = (read) ? EPOLLIN : EPOLLOUT; // can get errs, hup, whatever
  // FUCK!
#ifdef EPOLLONESHOT
  evt.events |= EPOLLONESHOT;         // yes!
#endif
  evt.events |= EPOLLHUP | EPOLLERR;        // I think I want this

  evt.data.ptr = sv;              // our user data
  // uffa but that's lame!
  // pb->epoll_hack = s;      // I hate this - there must be a better way

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, s, &evt) == -1)
  {
    perror("epoll_ctl (add)");
    return -1;
  }
  return 0;
}

void
epoll_demuxer::remove_socket(int s, bool read)
{
  struct epoll_event  evt;
  evt.events = (read) ? EPOLLIN : EPOLLOUT;

  // printf("removing %sing socket %i\n", (read) ? "read" : "writ", s);

  if(epoll_ctl(epoll_fd, EPOLL_CTL_DEL, s, &evt) == -1)
  {
    const char* str = (read) ? "epoll_ctl (remove read)"
      : "epoll_ctl (remove write)";
    perror(str);
  }
}

void
epoll_demuxer::thread_loop_body()
{
  struct epoll_event  evt;

  // no timeout
  if(epoll_wait(epoll_fd, &evt, 1, -1) == -1)
  {
    perror("epoll_wait");
    return;
  }

  // damn! it doesn't tell me the socket! I'd have to store that
  // myself!
  // int      s = pb->epoll_hack;     // nooooo
  // if I don't need to explicitly add the stuff back in,
  // I might be able to get away with not knowing the socket (?)

  socket_wakeup* sv = (socket_wakeup*)evt.data.ptr;
  
  // printf("wakeup!\n");
  
  // it might be possible to get both a read & write event...
  // in which case I should take out the else below
  if(evt.events & EPOLLIN)                // I think this is how you do it
  {
    // epoll events are not one shot, so evt must be removed
    // looks like I do need to know how - can I make them one shot?
    // printf("wakeup of reader %p\n", sv);
    remove_socket(sv->s, true);
    sv->wakeup(*this);
  }
  else if(evt.events & EPOLLOUT)
  {
    // printf("wakeup of writer %p\n", sv);
    remove_socket(sv->s, false);
    // ditto.
    sv->wakeup(*this);
  }
#ifndef EPOLLONESHOT
  else if(evt.events & EPOLLERR)
  {
    // I need to remove it, but which one am I removing?
    // I guess I'll just have to remove both. Note that a working
    // one-shot would fix this, I think. One of these will cause
    // an error
    printf("epoll error: don't know from who, removing both\n");
    remove_socket(sv->s, true);
    remove_socket(sv->s, false);
  }
#endif
    else
    {
        printf("unknown events in epoll_demuxer (err?)\n");
    }
}


@h=tangler('demux/demux_evtport_demuxer.cpp')
@select(h)

#include "demux_evtport_demuxer.hpp"

// looks like this stuff is only in solaris10, and not SunOS 5.8. Damn.

#include <port.h>
#include <poll.h> // POLLIN/POLLOUT
#include <stdio.h>  // printf
#include <unistd.h> // close
#include <assert.h>

// header files for this stuff?
// can use port_send for user defined events, to wake up reap loop
// truss to see what's happening

evtport_demuxer::evtport_demuxer()
{
  if((evtport = port_create()) < 0)
  {
    perror("port_create");
    cleanup();
    throw -1;
  }

  // silly virtual function stuff - must be done here.

  if(init_pthread() != 0)
  {
    cleanup();
    throw -1;
  }
}

void
evtport_demuxer::cleanup()
{
printf("do you use close to close an event port?\n");
  deinit_pthread();

  if(-1 != evtport)
  {
    if(close(evtport) != 0)
      perror("evtport close");
  }
}

evtport_demuxer::~evtport_demuxer()
{
  cleanup();
}


int
evtport_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  int events = (read) ? POLLIN : POLLOUT;
  int s = sv->s;

  //printf("add_socket_wakeup: %i, sv: %p, %s\n", s, sv,
  //  (read) ? "reading" : "writing");

  // register for event we are interested in...
  // works for files, sockets, timers...
  // is this the right one for sockets? that's all I care about for now
// IS POLLIN what I want? or will that actually POLL?
  if(port_associate(evtport, PORT_SOURCE_FD, (uintptr_t)s, events, sv) == -1)
  {
    perror("socket_wakeup/port_associate");
    return -1;
  }

  return 0;
}

// note that these two functions are exactly the same
// we have to remove after a read or write else we can get multiple
// wakeups - usually with a dud user cookie. the fact that there is
// no differentiation between POLLIN & POLLOUT could be a problem for
// mixed read/write things (rare). note that evt_ports let me associate
// the samething twice. I don't know if this means you have to dissociate
// (disassociate) twice.
void
evtport_demuxer::remove_reading_fd(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("reading port_dissociate");
}

void
evtport_demuxer::remove_writing_fd(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("writing port_dissociate");
}

static void
print_port_evt(port_event_t* e)
{
  char* srcstr[PORT_SOURCE_ALERT-PORT_SOURCE_AIO+1]
    = { "ALERT", "TIMER", "USER", "FD", "AIO"};
  printf("e: %p\n\t", e);
  //printf("portev_events: %x\n\t", e->portev_events);
  printf("portev_events: ");
  if(e->portev_events & POLLIN) printf("POLLIN, ");
  if(e->portev_events & POLLOUT) printf("POLLOUT, ");
  if(e->portev_events & POLLERR) printf("POLLERR");
  printf(" (%x)\n\t", e->portev_events);
  
  int src = e->portev_source;
  if(PORT_SOURCE_AIO <= src && src <= PORT_SOURCE_ALERT)
  {
    printf("portev_source: PORT_SOURCE_%s (%x)\n\t",
      srcstr[src-PORT_SOURCE_AIO], src);
  }
  else
  {
    printf("portev_source: %x\n\t", e->portev_source);
  }

  printf("portev_pad: %x\n\t", e->portev_pad);
  printf("portev_object: %x\n\t", e->portev_object);
  printf("portev_user: %p\n", e->portev_user);
}

void
evtport_demuxer::thread_loop_body()
{
  //printf("evtport thread loop body!!!\n");
// Block until a single event appears on the port
// event will not fire again, so must re-add it, that is, it automatically
// dissociates, which is going to make remove interesting... remove never
// (currently) happens except in response to receiving an event, so making
// it a nop should be ok.
// this means we have to add it back if we're not finished, i.e. if 
// we're looking for more data

  port_event_t  evt;

// I think that although port_get seems to be one-shot, it sometimes isn't.
// what to do?
// I'm definitely getting two in a row type events. I'll try explicitly
// removing... the port_create manpage says this should definitely not
// happen
  // is this the right return val? and the right behaviour?
  // has my evt been dissociated? which one? return val num events?
  if(port_get(evtport, &evt, NULL) < 0)
  {
    perror("port_get");
    return;
  }

  // printf("PORT_GET RETURNED: "); print_port_evt(&evt);

  // get wakeup obj tucked away in the user cookie.
  socket_wakeup*  sv = (socket_wakeup*)evt.portev_user;
  int       s = evt.portev_object;

  if(evt.portev_events & POLLERR)
  {
    printf("ERRORS on s = %i, sv = %p\n", s, sv); 
    //evt.portev_events &= ~POLLERR;
    //return;
  }


  if(evt.portev_source != PORT_SOURCE_FD)
    printf("got non PORT_SOURCE_FD (%i, %p)\n", s, sv);

  if(evt.portev_events & POLLIN)
  {
    // printf("GOT READ EVT FOR %p\n", sv);
    assert(sv);
    sv->wakeup(*this);
  }

  if(evt.portev_events & POLLOUT)
  {
    //printf("GOT WRITE EVT FOR %p\n", sv);
    assert(sv);
    sv->wakeup(*this);
  }

  // I never asked for POLLERR, but anyway
  if(evt.portev_events & ~(POLLIN | POLLOUT | POLLERR))
    {
        printf("UNSOLICITED events in evtport_demuxer (%x)\n",
      evt.portev_events);
    }
}


@h=tangler('demux/demux_iocp_demuxer.cpp')
@select(h)
#include "demux_iocp_demuxer.hpp"

#include <stdio.h>      // for printf debugging
#include <stddef.h>

// this could really do with auto objs. steal the strat stuff?

// add windows error processing macros. It's a bore otherwise.

// WaitForSingleObject on an kill event in the thread for thread cancel
// kill_event = CreateEvent(NULL, TRUE, FALSE, NULL); (what's that)
// SetEvent(kill_event) to invoke (?): SetEvent sets the event to the 
// signalled state. Return value is success flag. GetLastError.

// do auto SOCKET wrapper, check closesocket return code.

// a completion port is a queue into which the os puts notifications of
// completed overlapped io requests. once the operation completes, a
// notification is sent to a worker thread that can process the result.
// a socket may be associated with a completion port at any point after
// creation.


// I don't see how to nicely stop a thread, I may have to have my own protocol
// to ask it to exit.

// PostQueuedCompletionStatus can be used by threads to wake up a worker
// thread. Could be handy replacement for timeout. "useful for notifying
// worker threads of external events"

// working through this: http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/
// example of worker thread here
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/i_o_completion_ports.asp
// nono, use this onec
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// oh, wait they're the same
// FormatMessge


// iocp_wakeup base class for users of iocp_demuxer
//static
iocp_wakeup*
iocp_wakeup::from_overlapped(LPOVERLAPPED olp)
{
  // calculate the address of this from overlapped member
  // suffer an obligatory offsestof warning from broken gccs.
  return (iocp_wakeup*)((char*)olp-offsetof(iocp_wakeup, ol));
}

void
iocp_wakeup::clear_overlapped()
{
  ZeroMemory(&ol, sizeof(ol));  // much better than memset, right?
}


iocp_demuxer::iocp_demuxer()
  : iocp(NULL)
{
  // Create the completion port
  // not sure what first 3 args do, but by specifying INVALID_HANDLE_VALUE
  // for the first I think I can ignore the rest (apart from the last, numthreads)
  // I still have to create the threads, but only NumberOfConcurrentThreads
  // will wake up from GetQueuedCompletionStatus at a time. This looks to be
  // slightly elastic...
// NT 3.51 doesn't let you pass null filehandle, you've got to have a dummy
// socket. keep that in mind. see InitializeIOCP in IOCPServer.cpp example
// taken from codeproject. GetSystemInfo to find out num CPUs
  printf("CreateIoCompletionPort with ONE WORKER THREAD\n");
  iocp = CreateIoCompletionPort(
    INVALID_HANDLE_VALUE,
    NULL,
    (ULONG_PTR)0,
    1       // 1 thread (zero means one for each CPU)
  );

  if(NULL == iocp)
  {
    DWORD err = GetLastError();
    printf("failed to create completion port: %li\n", err);
    // zzz now...
    cleanup();
    throw -1;
  }

  // do this last
  if(iocp_thread.init(worker_thread_stub, this) == -1)
  {
    DWORD err = GetLastError();
    printf("failed to create thread: %li\n", err);
    cleanup();
    throw -1;
  }
}

iocp_demuxer::~iocp_demuxer()
{
  cleanup();
}

void
iocp_demuxer::cleanup()
{
  printf("iocp cleanup\n");

  iocp_thread.deinit();

  if(NULL != iocp && !CloseHandle(iocp))
  {
    DWORD err = GetLastError();
    // zzz do something with this
    printf("failed cleanup iocp: %li\n", err);
  }
}

int
iocp_demuxer::associate_with_iocp(HANDLE obj, ULONG_PTR udat)
{
  // printf("associating with iocp: %p, udat: %lx\n", obj, udat);

  // Any overlapped operations performed on the object will use the
  // completion port for notification. The 3rd param can be used to pass
  // per object context information. we'll just pass that back.
  if(CreateIoCompletionPort(obj, iocp, udat, 0) == NULL) {
    // adding the same obj twice without an intervening get completion
    // status wakup gets an error 87, ERROR_INVALID_PARAMETER
    printf("CreateIoCompletionPort failed to register object: %li\n",
      GetLastError());
    return -1;
  }

  return 0;
}

// windows thread proc
// some code examples imply that it's risky to use the CRT (C runtime) here.
// maybe I should get rid of that printf... and use conio
DWORD
iocp_demuxer::worker_thread_stub(LPVOID lParam) {
  // will printf work here or do I have to use windows' conio? (WriteConsole)
  iocp_demuxer* demuxer = (iocp_demuxer*)lParam;

  printf("how to allow thread cancel in windows?\n");
  while(1) {
    // I would call cancel here we were using pthreads here 
    demuxer->worker_thread_body();
  }
  return 0;   // I think this means good.
}

void
iocp_demuxer::worker_thread_body() {
  // with multiple threads, this will actually wake up the last to
  // block (lifo)

  // get context, call worker_thread 
  // need to be able to tell which thing completed, can have extra data
  // following some kind of struct
  // get this pointer

  // I guess to avoid swapping of thread context. By calling this on a given
  // completion port this thread is associated with it until exit or respec
  DWORD     nbytes;   // number of bytes in io transaction
  ULONG     udat;   // user data - not using this atm
  LPOVERLAPPED  olp;    // we get iocp_wakeup from this.

// If a socket handle associated with a completion port is closed,
// GetQueuedCompletionStatus returns ERROR_SUCCESS, with *lpOverlapped
// non-NULL and lpNumberOfBytes equal zero.
  
  int err = NO_ERROR;

  // No timeout. What does false mean? Eh. Could need a timeout to bring
  // the thread down.
  if(!GetQueuedCompletionStatus(iocp, &nbytes, &udat, &olp, INFINITE))
  {
    // That's strange - I sometimes get my ConnectEx errors popping
    // out here (ERROR_SEM_TIMEOUT=121, ERROR_CONNECTION_REFUSED=1225)
    // it looks like my args (overlapped, etc) are still filled out, so
    // I can still awake the sleeper
    err = GetLastError();   // doco says this & not WSALastError.

    // printf("GetQueuedCompletionStatus returned false: %i\n", err);

    // let's see: yep - there's my overlapped
    // printf("nbytes=%li, udat=%lx, io=%p\n", nbytes, udat, olp);
    // return;
  }
// An IOCP is a very general event mechanism. It tells you not only about
// the completion of reads & writes, but also of pretty much any asynchronous
// event's completion. It doesn't quite fit in with my select style interfaces.
// I've got general overlapped things completing here. I don't want them to
// know about demuxers & so forth so I'll have to know about them.

  // printf("HOLEY! Woke up!\n");
  // printf("nbytes=%li, udat=%lx, olp=%p, err=%i\n", nbytes, udat, olp, err);

  if(NULL == olp)
  {
    printf("failed to get iocp_wakeup: %p (err: %i)\n", olp, err);
    return;
  }

  // tell someone that some overlapped op finished
  iocp_wakeup*  wakeup = iocp_wakeup::from_overlapped(olp);
  // passing olp may be redundant, seeing as it's contained in iocp_wakeup
  wakeup->iocp_op_finished(nbytes, udat, olp, err);
}


// thread stuff

win_thread::win_thread()
  : thread(NULL), cancel_evt(NULL)
{
}

// this should be idempotent
void
win_thread::deinit()
{
  printf("win_thread::deinit: how do I get my return status?\n");
  printf("also, how do I implement a cancel request?\n");

  // ask thread to stop
  if(cancel_evt)
  {
    printf("this cancel_evt isn't actually used - it should be\n");
    if(!SetEvent(cancel_evt))
      printf("cancel event failed: %li\n", GetLastError());

    if(!CloseHandle(cancel_evt))
      printf("failed to close cancel evt: %li\n", GetLastError());

    cancel_evt = NULL;
  }

  if(thread)
  {
    // Let's try and wait for the thread to finish, however first I have to
    // tell it to finish up.
    DWORD wait_res;
    // we'll wait as long as we have to for the thread to terminate
    wait_res = WaitForSingleObject(thread, INFINITE);

    // will this give me my return status? how do I get that?
    if(WAIT_FAILED == wait_res)
    {
      // something went wrong, have a cry
      printf("thread wait failed (%li)\n", GetLastError());
    }

    // I've already tried waiting on the  thread's exit
    if(!CloseHandle(thread))
    {
      // have a cry
      printf("failed to delete thread (%li)\n", GetLastError());
    }

    thread = NULL;
  } 
}

win_thread::~win_thread()
{
  printf("win_thread dtor (killing thread!)\n");
  deinit();
}

int
win_thread::init(LPTHREAD_START_ROUTINE fn, LPVOID lParam)
{
  DWORD thread_id = 0;

  // we create a cancel event so that we can nicely ask the thread to stop
  // start it in nonsignalled state with manual reset
  cancel_evt = CreateEvent(NULL, TRUE, FALSE, NULL);

  if(NULL == cancel_evt)
  {
    printf("failed to create cancel event\n");
    return -1;
  }

  // thread id... (?)
  // I have no idea why I have to cast the fn to what it already is
  // absolutely none
  thread = (HANDLE)CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)fn, lParam, 0, &thread_id);  

  if(NULL == thread)
    return -1;

  return 0;     // success!
}

win_locker::win_locker(HANDLE mutex)
  : m(mutex)
{
  DWORD res = WaitForSingleObject(m, INFINITE);

  if(WAIT_OBJECT_0 != res)
  {
    printf("Wait for mutex didn't do as expected, got: %li\n", res);
    throw res;
  }
}

win_locker::~win_locker()
{
  if(!ReleaseMutex(m))
    printf("Error releasing mutex: %li\n", GetLastError());
}

// shoving the win_queue in here for now
#include <queue>          // stl to the bloated rescue

using namespace std;

typedef queue<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

win_queue::win_queue() 
  : member_lock(0), nz_elts_cond(0), lame_opaque(0)
{
  DWORD err;
  
  // allocate queue
  lame_opaque = new void_queue;

  // default security attributes, manual reset, non-signalled, nameless
  // signalled corresponds to num(elts) > 0
  nz_elts_cond = CreateEvent(NULL, TRUE, FALSE, NULL);
  
  if(NULL == nz_elts_cond)
  {
    err = GetLastError();
    printf("CreateEvent returned: %li\n", err);
    cleanup();
    throw err;
  }

  // default security attr, not initiallly owned/locked, nameless.
  member_lock = CreateMutex(NULL, FALSE, NULL);

  if(NULL == member_lock)
  {
    err = GetLastError();
    printf("CreateMutex returned: %li\n", err);
    cleanup();
    throw err;
  }
}

void
win_queue::cleanup()
{
  if(ELTQ) delete ELTQ;
  if(nz_elts_cond && !CloseHandle(nz_elts_cond))
    printf("Failed to close event: %li\n", GetLastError());
  if(member_lock && !CloseHandle(member_lock))
    printf("Failed to close mutex: %li\n", GetLastError());
}

win_queue::~win_queue()
{
  cleanup();
}

void
win_queue::enqueue(void* elt)
{
  // lock so our member data doesn't get bent out of shape
  win_locker    l(member_lock);

  // this is the simple case, add the elt, protected by lock
  // and signal suckas, who oughta recognize, but don't.
  ELTQ->push(elt);

  // we've got the mutex and we've just added an elt, therefore
  // we have > 0 elts. That sounds like a good enough reason to
  // put the condition into the signalled state. It may already
  // be in the signalled stated. Hope that's not a problem.
  // Might be an optimization to skip this if it became nonempty.
  if(!SetEvent(nz_elts_cond))
    printf("Set condition failed: %li\n", GetLastError());
}

void*
win_queue::dequeue()
{
  void*     elt = NULL;

  do
  {
    // exclusively examine queue
    {
      win_locker    l(member_lock);

      if(!ELTQ->empty())
      {
        elt = ELTQ->front();
        ELTQ->pop();
        // if the queue is now empty, make condition reflect it
        // this failing will probably lock the app up...
        if(!ResetEvent(nz_elts_cond)) // non-signalled state
          printf("Reset condition failed: %li\n", GetLastError());
        break;
      }
    }

    // otherwise there's nothing in the queue or something
    // may have turned up in the intervening moments
    DWORD   res;
    res = WaitForSingleObject(nz_elts_cond, INFINITE);

    if(WAIT_OBJECT_0 != res)
    {
      printf("Wait on condition failed: %li\n", GetLastError());
      throw res;
    }

  } while(1);

  return elt;           // should never return NULL
}

// simple utility fn, shouldn't be here. creates listener on any interface.
// this could benifit from a SOCKET class. in failure returns INVALID_SOCKET
SOCKET
create_listener_socket(int port, int backlog)
{
  printf("creating_listener_socket\n");
  SOCKET        listener = INVALID_SOCKET;

  // could use WSASocket, but these seem to be turning out overlapped anyway
  listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if (INVALID_SOCKET == listener)
  {
    printf("listener create failed: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  SOCKADDR_IN   addr;

  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(port);

  // bind our name to the socket
  int         res;
  res = bind(listener, (LPSOCKADDR)&addr, sizeof(addr));

  if (SOCKET_ERROR == res)
  {
    printf("bind() failed %i\n", WSAGetLastError());
    if(closesocket(listener) == SOCKET_ERROR)
      printf("closesocket failed on listener: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  // Set the socket to listen
  res = listen(listener, backlog);
  if (SOCKET_ERROR == res)
  {
    printf("listen() failed %i\n", WSAGetLastError());

    if(closesocket(listener) == SOCKET_ERROR)
      printf("closesocket failed on listener: %i\n", WSAGetLastError());

    return INVALID_SOCKET;
  }

  return listener;
}


// testing out some timer stuff
static VOID CALLBACK
timer_proc(
  LPVOID udat,
  DWORD dwTimerLowValue,
  DWORD dwTimerHighValue
)
{
  printf("timerproc callback! udat: %p\n", udat);
}

/*
static void
blah()
{
  // timer with default security, manual reset & no name (I know his name).
  HANDLE  timer = CreateWaitableTimer(NULL, true, NULL);

  {
    printf("couldn't create waitable timer: %li\n", GetLastError());
    return;
  }

  // fill this out
  LARGE_INTEGER due;
  printf("ACTUALLY INIT due\n");

  // zero period => signal once only (I'll reinstall)
  // note callback + void*, passing timer for now.
  // the final false seems to have something to do with waking the machine
  // from hibernation mode. I don't want to have anything to do with that.
  if(!SetWaitableTimer(timer, &due, 0, timer_proc, timer, false))
  {
    printf("couldn't set waitable timer: %li\n", GetLastError());
    if(!CloseHandle(timer))
      printf("couldn't close timer: %li\n", GetLastError());
  }
}
*/

@h=tangler('demux/demux_kqueue_demuxer.cpp')
@select(h)

// kqueue demuxer for bsd/os x
// N.B. calling close on a file descriptor will remove any kevents that
// reference that descriptor. that would explain remove complaining from
// time to time.
// try EV_EOF to pick up eofs, useful for async file io.

#include "demux_kqueue_demuxer.hpp"

#include <stdio.h>      // for perror
#include <unistd.h>     // for close

#include <sys/types.h>    // from the kqueue manpage
#include <sys/event.h>    // kernel events
#include <sys/socket.h>   // for send/recv

#include <sys/syscall.h>  // for non clib close

kqueue_demuxer::kqueue_demuxer()
  : kq(-1)
{
  // Not that you care, but this event queue is not inherited by
  // forked children.
  kq = kqueue();
  if(-1 == kq)
  {
    perror("kqueue");
    cleanup();
    throw -1;
  }

  int res = init_pthread();
  if(res != 0)
  {
    cleanup();
    throw res;
  }
}

void
kqueue_demuxer::cleanup()
{
  deinit_pthread();

  //if(syscall(SYS_close, kq) == -1)
  // I don't seem to be able to close a kq. can't fstat it either
  if(-1 != kq && close(kq) == -1)
    perror("kqueue close");
}

kqueue_demuxer::~kqueue_demuxer()
{
  cleanup();
}


// Events of interest to us ERead, EWrite.
// ERead has fflags: NOTE_LOWAT, NOTE_EOF. ident is a descriptor (any?) 
int
kqueue_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  if(read) return add_reading_socket(sv);
  else return add_writing_socket(sv);
}

int
kqueue_demuxer::add_reading_socket(socket_wakeup* sv)
{
  int s = sv->s;
  struct kevent read_evt;
  
  // this works just like select if the s is a listening socket
  // *except* works with all types of fds, including pipes, files & fifos
  // can set low water mark for reads with NOTE_LOWAT in fflags and size
  // in data. on return data contains number of bytes available to read
  // on return sets EV_EOF in flags if read dir socket has shutdown and
  // returns a possible socket err in fflags
  // should that be EV_ENABLE | EV_ADD. fflags zero cos I don't know what
  // to put there. pass pb in udata
  
  // adding EV_ONESHOT to save me removing on wakeup (a syscall).
  // I now require that during the evt be removed before wakeup fn.
  
  EV_SET(&read_evt, s, EVFILT_READ, EV_ADD | EV_ONESHOT, 0, 0, sv);
  // trying to detect when have reached eof with async file io using kq
  //EV_SET(&read_evt, s, EVFILT_READ, EV_ADD, | EV_ONESHOT NOTE_LOWAT, 16*1024, sv);

  // I think this is how you add an event
  if(kevent(kq, &read_evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent read add");
    return -1;
  }
  return 0;
}

int
kqueue_demuxer::add_writing_socket(socket_wakeup* sv)
{
  int s = sv->s;
  struct kevent write_evt;
  
  // for sockets the low water mark stuff is identical to EVFILT_READ
  // see the add_reading_socket notes for EV_ONESHOT reasoning
  EV_SET(&write_evt, s, EVFILT_WRITE, EV_ADD | EV_ONESHOT, 0, 0, sv);

  // this is how you add an event
  if(kevent(kq, &write_evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent write add");
    return -1;
  }
  return 0;
}

// useful, but unused atm
void
kqueue_demuxer::remove_reading_fd(int s)
{
  struct kevent ev;
  
  EV_SET(&ev, s, EVFILT_READ, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &ev, 1, NULL, 0, NULL) < 0)
    perror("read evt remove");
}

void
kqueue_demuxer::remove_writing_fd(int s)
{
  struct kevent ev;

  EV_SET(&ev, s, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &ev, 1, NULL, 0, NULL) < 0)
    perror("write evt remove");
}

/*
    printf("readevt on %i, EOF = %s\n",
      s, (ev.flags & EV_EOF) ? "TRUE" : "FALSE");
 */

// do that thing where you get the events. can I get them one at a time?
// I bet I can.
void
kqueue_demuxer::thread_loop_body()
{
  // event seems to remain unless we remove it
  struct kevent ev;
  struct timespec timeout;
  int       nevts;

  timeout.tv_sec = 1;   // timeout every second
  timeout.tv_nsec = 0;  // 10^9 nanoseconds per second

  nevts = kevent(kq, NULL, 0, &ev, 1, &timeout);
  if(nevts <= 0)
  {
    // error, else timeout & return to allow cancel
    if(nevts < 0)
      perror("kevent event fetch");

    return;
  }

  // printf("kqueue wakeup!\n");

  socket_wakeup*  sv = (socket_wakeup*)ev.udata;
  // int        s = ev.ident;

  if(ev.filter == EVFILT_READ)
  {
  // this capability is lost for the moment, as we have no way
  // of explaining it to felix. the event stuff isn't so good right now
/*
    // can chunk up on accepts. nice one kqueue
    if(NULL == sv)      // => listener
    {
      int backlog = (int)ev.data;   
      // printf("kq listen backlog: %i\n", backlog);
      for(int i = 0; i < backlog; i++) handle_connection();
    }
    else
*/
    // printf("EVFILT_READ: got %i bytes coming\n", (int)ev.data);
    // remove_reading_fd(s);  // now useing EV_ONESHOT
    sv->wakeup(*this);
  }
  else if(ev.filter == EVFILT_WRITE)
  {
    // printf("EVFILT_WRITE: can write (?) %i bytes\n", (int)ev.data);
    // remove_writing_fd(s);
    sv->wakeup(*this);
  }
  else
  {
    printf("kqueue returned something else (requires remove?)...\n");
  }
}

@h=tangler('demux/demux_mutexlite.cpp')
@select(h)
#include "demux_mutexlite.hpp"
#include <stdio.h>        // printf debugging

class auto_attr
{
  pthread_mutexattr_t* a;
public:

  auto_attr(pthread_mutexattr_t* attr) : a(attr) {}
  ~auto_attr()
  {
    int res = pthread_mutexattr_destroy(a);
    if(0 != res)
      printf("pthread_mutexattr_destroy failed: %i\n", res);
  }
};

pmut::pmut(bool recursive)
{
  pthread_mutexattr_t attr;
  int res;

  res = pthread_mutexattr_init(&attr);  // default attrs

  if(0 != res) throw res;

  auto_attr aa(&attr);          // cleans up always

  if(recursive)
  {
    res = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    if(0 != res)
    {
      printf("phtread_mutexattr_settype failed: %i\n", res);
      throw res;
    }
  }

  res = pthread_mutex_init(&m, &attr);
  if(res != 0) throw res;
}

pmut::~pmut()
{
  int res;
  // printf("MUTEX DESTROY!!!\n");
  // fflush(stdout);
  res = pthread_mutex_destroy(&m);
  if(0 != res) printf("mutex_destroy failed: %i\n", res);
}

void
pmut::lock()
{
  int res = pthread_mutex_lock(&m);
if(res != 0) printf("lockres: %i\n", res);
  if(res != 0) throw res;
}

void
pmut::unlock()
{
  int res = pthread_mutex_unlock(&m);
  if(res != 0) throw res; 
}

// auto pthread

int 
apthread::init(void* (*start)(void*), void* udat)
{
  // printf("apthread::init(this=%p, fn=%p, udat=%p)\n",
  //  this, start, udat);

  // default attrs. hope they're good
  int res = pthread_create(&thr, NULL, start, udat);
  if(0 == res) inited = true;   // success!
  return res;
}

void
apthread::deinit()
{
  printf("apthread::deinit(this=%p, inited=%i)\n", this, inited);

  if(!inited) return;
// What if I cancel while someone (select thread) holds the mutex.
// I think I need to push cleanup stuff... wait, cancel won't happen
// in the mutex. If others start using this pre-emptively then it could
// happen. We've got another problem then, as the object is being
// destructed. Should I go for the lock? What to do? HELP!
// do experiment...
  // cancel thread, then "join" to wait for it to exit. if we summarily
  // killed the thread, we could kill it during something important,
  // like  a mutex or select op, screwing up global state.
  // we shouldn't have to wait long
  // ignoring errors, thread not found seems to be the worst

  int   res;

  res = cancel();             // send cancel msg
  printf("cancel res: %i, joining...\n", res);


  res = pthread_join(thr, NULL);      // wait for cancel pt, ignor res
  printf("join res: %i\n", res);

  // is that all you have to do to free up a pthread?

  inited = false;
}

// set thread cancel flag
int
apthread::cancel()
{
  return pthread_cancel(thr);       // send cancel msg
}

apthread::~apthread()
{
  deinit();
}

@h=tangler('demux/demux_pfileio.cpp')
@select(h)
#include <stdio.h>    // printf
#include <errno.h>    // errno
#include "demux_pfileio.hpp"

// blocking reads & writes that use a worker fifo. users overload
// finished flag to implement wakeup

// if we could group the requests, we could do a scattered read
// or we could do single reads if the requests were of a similar
// nature, i.e. the whole file, of popular files.

// for pwrite/pread, I'm supposed to include the following three (osx man page)
// they don't appear to be necessary, but let's play it safe
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

// fileio_request stuff follows

// read or write in a blocking fashion. I like the idea of using pread
// which doesn't change the file pointer. this could allow reuse of the same
// file descriptor & block caching

fileio_request::fileio_request(int f, char* buf, long len, long off, bool rd)
  : offset(off), fd(f), read_flag(rd), err(0)
{
  pb.buffer = buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// synchronously process read/write
void
fileio_request::doit()
{
  // printf("faio about to try to %s %i bytes from fd=%i\n",
  //  (read_flag) ? "read" : "write", pb.buffer_size, fd);

// switching off (explicit) seeks for now because I'm not using them
// in the flx code & I'm not passing around enough info (just the fd)
  ssize_t res;

  if(read_flag)
  {
    // res = pread(fd, pb.buffer, pb.buffer_size, offset);
    res = read(fd, pb.buffer, pb.buffer_size);
  }
  else
  {
    // res = pwrite(fd, pb.buffer, pb.buffer_size, offset);
    res = write(fd, pb.buffer, pb.buffer_size);
  }
  
  // zero return value indicates end of file. that should just work.
  if(-1 == res)
  {
    err = errno;    // grab errno
    printf("faio error: %i\n", err);
  }
  else
  {
    // printf("faio %s %i bytes\n", (read_flag) ? "read" : "write", res);
    pb.bytes_written = res;
  }
}

@h=tangler('demux/demux_posix_demuxer.cpp')
@select(h)
#include "demux_posix_demuxer.hpp"
#include "demux_sockety.hpp"

#include <stdio.h>        // "printf"
#include <fcntl.h>        // for making non blocking sockets
#include <unistd.h>       // close
#include <assert.h>       // assert

#include <sys/types.h>      // for send/recv
#include <sys/socket.h>

int
posix_demuxer::init_pthread() {
  return evt_pthr.init(thread_start, this);
}

// this MUST be called by sub classes in their destructors.
// what cack-handed object orientedism
// need to wake up event sleep for exiting. many of the event sources
// have a way to do this, or at least a time out after which we can
// test cancel state (pthread_testcancel)
void
posix_demuxer::deinit_pthread()
{
  evt_pthr.deinit();
}

// delete thread
posix_demuxer::~posix_demuxer()
{
  // no, it's required that the subclasses do it, as they have methods
  // called by the pthread. if we get here & they're still being called,
  // then we've got Trouble.
  // printf("shouldn't I be deleting the thread in ~posix_demuxer?\n");
}

// static pthread callback bootstrap
void*
posix_demuxer::thread_start(void* data)
{
  // why's this called sel?
  posix_demuxer*  sel = (posix_demuxer*)data;   // get this ptr
  while(1)
  {
    // to not screw up state/leak mutexes, we need to provide
    // kill/cancel points. This is one.
    pthread_testcancel();           // allow cancellability.
    sel->thread_loop_body();          // one select
  }
  return 0;                   // (exit status) never happens
}

bool
posix_demuxer::handle_socket_read(int s, sel_param* pb)
{
  assert(pb != NULL);
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;
  
  // if this were read then this fn would work with non-sockets
  nbytes = recv(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written, 0);

  if(nbytes <= 0)
  {
    if(nbytes == 0)
    {
      return true;        // connection closed
    }
    else
    {
      perror("recv");       // can get reset connection here
      return true;        // so say closed, yeah?
    }
  }
  else
  {
    // got some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

bool
posix_demuxer::handle_socket_write(int s, sel_param* pb)
{
  // can know how much to write... imagine that!

  assert(pb != NULL);
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;

  nbytes = send(s, pb->buffer + pb->bytes_written,
    pb->buffer_size - pb->bytes_written, 0);

  // similar story here, with send vs write?

  // what's the story with zero? Is that allowed or does it signal
  // that the connection closed?
  if(-1 == nbytes)
  {
    perror("send");
    return true;          // I guess the connection closed
  }
  else
  {
    // sent some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

#if 0
  //nbytes = recv(s, pb->buffer + pb->bytes_written,
  //      pb->buffer_size - pb->bytes_written, 0);

  // select and kqueue know when non socket fds have data.
  // recv only works with sockets, but read works with both files
  // and sockets and who knows what else. is there any disadvantage
  // to using read instead? apart from losing flags arg?
  // does read get the same 0 bytes = close behaviour
  nbytes = read(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written);
#endif

@h=tangler('demux/demux_posix_queue.cpp')
@select(h)
#include <pthread.h>
#include "demux_posix_queue.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror

using namespace std;

typedef queue<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

posix_queue::posix_queue()
  : member_lock(false)      // shouldn't need to be recursive
{
  lame_opaque = new void_queue;
  int res = pthread_cond_init(&nz_elts_cond, NULL);

  if(0 != res)
  {
    delete ELTQ;
    throw res;
  }
}

posix_queue::~posix_queue()
{
  int res = pthread_cond_destroy(&nz_elts_cond);
  if(0 != res)
    printf("pthread_cond_destroy failed: %i (%s)\n",
      res, strerror(res));
  delete ELTQ;
}

void
posix_queue::enqueue(void* elt)
{
  // lock so our member data doesn't get bent out of shape
  pmut_locker   l(member_lock);
  // this is the simple case, add the elt, protected by lock
  // and signal suckas, who oughta recognize, but don't.
  ELTQ->push(elt);

  // we've just added one elt, therefore we have > 0 elts
  // a signal should do just fine here - I don't think I need
  // broadcast unless I were adding more than one item in a go.
  // if there were already elts in the queue there wouldn't be
  // threads waiting on the signal and if there were no elts then
  // there would be no point waking up more than one thread now.
  // right? 
  int       res;
  res = pthread_cond_signal(&nz_elts_cond);
  if(0 != res)
    printf("pthread_cond_signal failed %i\n", res);
}

void*
posix_queue::dequeue()
{
  // protect member data
  pmut_locker   l(member_lock);
  void*     elt = NULL;

  // sleep until something is there
  do
  {
    if(!ELTQ->empty())
    {
      elt = ELTQ->front();
      ELTQ->pop();
      break;
    }

    // otherwise queue empty, wait on condition
    int res;
    // wait on elt added condition signal. mutex is unlocked on
    // on wait and relocked on wake.
    res = pthread_cond_wait(&nz_elts_cond, &member_lock.m);
    if(res != 0)
      printf("pthread_cond_wait nonzero elts failed: %i\n", res);

  } while(1);

  return elt;           // should never return NULL
}

@h=tangler('demux/demux_select_demuxer.cpp')
@select(h)
// P.S. for current impl don't need the pthreads. WHOO!!!

// A very light wrapper around select, that allows the addition
// of new sockets and returns status in a queue.
// on the powerbook with 10.3, FD_SETSIZE is 1024, that means
// max 1024 sockets. That's kind of lame. See IO completion ports
// on NT for a better solution.

// see epoll, kqueue & IOCPs

// so this is asynchronously watching sockets and doing stuff. I could
// pass the stuff off to another thread, which could then do things, like
// process, run a flx thread or whatever, but I don't want to lose the
// "not polling" nature of this. If I post this stuff to a queue, how
// do I get the client to wake up and process that stuff? Is that what
// condition variables are for? Put the decision off and give it a
// callback
// If I only read some of the available data will the next select return
// immediately? It probably ought to.

#include <assert.h>

#include <sys/types.h>
#include <sys/socket.h>

#include "demux_select_demuxer.hpp"

#include <string.h>       // for memset

#include <stdio.h>        // for printf debug
#include <stdlib.h>

select_demuxer::select_demuxer()
  : ham_fist(true)
{
  // clear these guys. after the thread starts, access to them will have
  // to be via the lock
  FD_ZERO(&master_read_set);
  FD_ZERO(&master_write_set);
  fdmax = 0;        // corresponds to stdin, which we're not using

  // clear this possibly quite large list
  memset(read_svs, 0, sizeof(read_svs));
  memset(write_svs, 0, sizeof(write_svs));
  
  int res = init_pthread();
  
  if(res != 0) throw res;
}

// one select, must not block indefinitely, so choose a timeslice
// or find a way to make it wake on command, like a dummy socket
void
select_demuxer::thread_loop_body()
{
  // make a copy that select can modify
  fd_set      read_set = master_read_set;
  fd_set      write_set = master_write_set;
  
  // this is depending on my fake socket to wakeup. perhaps use the timer for now.
  // timing out every 100th of a second. seems reasonable.
  struct timeval  tv;
  tv.tv_sec = 0;
  tv.tv_usec = 1000000/100;
  
  // the return value here actually has significance
  // sometimes I have to try again, or weed out bad fds.
  if(select(fdmax+1, &read_set, &write_set, NULL, &tv) == -1)
  {
    // not the ideal reaction. I think this is where I weed out the bad socket(s).
    perror("select");
    exit(1);
  }

  // about to read and write master_set and pending reads.
  // lock until end of function. pretty coarse.
  // the simple choice of allowing the handle_read/write has meant
  // that I have to use a recursive lock to protect my member vars
  pmut_locker     l(ham_fist);

  // might be worth keeping a lowwater mark as well.
  // I guess this is why select sucks. On osx we can only watch
  // about 1024 sockets. That sucks too.
  for(int i = 0; i <= fdmax; i++)
  {
    if(!FD_ISSET(i, &read_set)) continue;

    // we now always remove before giving wakeup, which can
    // always add it back if need be.
    socket_wakeup*  sv = read_svs[i];
    remove_reading_fd(i);
    sv->wakeup(*this);
  }

  // should combine loops. very heavy indentation
  for(int i = 0; i <= fdmax; i++)
  {
    if(!FD_ISSET(i, &write_set)) continue;

    socket_wakeup*  sv = write_svs[i];
    remove_writing_fd(i);
    sv->wakeup(*this);
  }
}

int
select_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  int s = sv->s;

  if(s < 0 || s >= FD_SETSIZE) return -1;   // weakness of select

  pmut_locker     l(ham_fist);      // lock it all off

  if(read)
  {
    FD_SET(s, &master_read_set);
    assert(read_svs[s] == NULL);      // sanity check
    read_svs[s] = sv;
  }
  else
  {
    FD_SET(s, &master_write_set);
    assert(write_svs[s] == NULL);     // sanity check
    write_svs[s] = sv;
  }

  if(s > fdmax) fdmax = s;          // update highwater mark

  return 0;
}

void
select_demuxer::remove_reading_fd(int s)
{
  assert(s >= 0 && s < FD_SETSIZE);

  pmut_locker     l(ham_fist);      // lock it all off

  FD_CLR(s, &master_read_set);        // we're finished with this
  read_svs[s] = NULL;
}

void
select_demuxer::remove_writing_fd(int s)
{
  assert(s >= 0 && s < FD_SETSIZE);

  pmut_locker     l(ham_fist);      // lock it all off

  FD_CLR(s, &master_write_set);       // we're finished with this
  write_svs[s] = NULL;
}


@h=tangler('demux/demux_sleep_task.cpp')
@select(h)
#include "demux_sleep_task.hpp"

// a prio queue that executes tasks in a given order
// factor out prio_queue? could be like queue.

// try to make work like the worker thread thing, fix it do so?.
// remove time from sleep task...

#include <queue>    // stl seems to have a prio_queue
#include <sys/time.h> // gettimeofday for calculating "now"
// #include <errno.h> // ETIMEDOUT - don't actually need to know this

using namespace std;

// it could happen!
class future_evt
{
public:
  timespec  when; 
  sleep_task* task;

  // ignore the direction, just trying to sort with smallest first
  bool operator<(const future_evt& rhs) const
  {
    if(when.tv_sec != rhs.when.tv_sec)  // precedence to more significant
      return when.tv_sec > rhs.when.tv_sec;
    else                // else check the less significant
      return when.tv_nsec > rhs.when.tv_nsec;
  }
};

typedef priority_queue<future_evt> void_prio_queue;

#define PRIOQ ((void_prio_queue*)opaque_prio_queue)

int
sleep_task_queue::setup_sleep_cond()
{
  printf("setup_sleep_cond\n");
  int res;
  res = pthread_cond_init(&sleep_cond, NULL);

  if(0 != res)
    printf("pthread_cond_init failed: %i\n", res);

  return res;
}

void
sleep_task_queue::takedown_sleep_cond()
{
  printf("sleep cond taking down\n");
  int res;
  res = pthread_cond_destroy(&sleep_cond);
  if(0 != res) printf("condition destroy failed: %i\n", res);
}

sleep_task_queue::sleep_task_queue()
  : lock(false)     // lock shouldn't need to be recursive
{
  // printf("sleep_task_queue ctor\n");
  int res;
  res = setup_sleep_cond();
  if(0 != res) throw res;

  // do the thread last because it uses all this stuff
  printf("initing sleep thread\n");
  opaque_prio_queue = new void_prio_queue;
  res = sleep_thread.init(thread_start, this);
printf("will leak if thread or condition init fails.\n");
  if(0 != res) throw res;
  // not good to do much else after this as the thread is running

}

sleep_task_queue::~sleep_task_queue()
{
  // the sleep_thread uses the prioq, so we must explicitly shut it
  // down now, before we delete the prioq. left to its own devices,
  // c++ destructs it at the end of this destructor.

  // take down the thread first because it uses all the other stuff.
  // I actually don't need to do anything special to bring the thread
  // down because all pthread_cond_*wait* are cancel aware. Or so they
  // should be. As far as I can tell only the 64bit osx10.4.2 is, so
  // for now the explicit cancel + wakeup followed by explicit 
  // cancel test stays.

  // printf("setting thread cancel flag\n");
  sleep_thread.cancel();      // set cancel flag
  // printf("waking up thread!\n");
  wakeup_thread();        // wakeup, cause to goto a cancel pt

  sleep_thread.deinit();      // will cancel again and join
  printf("about to delete PRIOQ\n");
  delete PRIOQ;

  takedown_sleep_cond();
}

static void
get_now(timespec* now)
{
  struct timeval tp;

  if(gettimeofday(&tp, NULL) == -1)
    perror("gettimeofday");

  // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
  now->tv_sec = tp.tv_sec;
  now->tv_nsec = tp.tv_usec*1000;   // fits!

  // printf("get_now = %li, %li\n", now->tv_sec, now->tv_nsec);
}

// offset delta from "now" and store in "when"
static void
calc_when(timespec* when, double delta)
{
// how to use the posix abstime versions of timed waits? what kind of absolute
// is abstime? pthread_get_expiration_np looks useful, but it too is np.
// abstime is apparently in seconds since the Epoch, UTC.
// To get now there's clock_gettime (not portable) or gettimeofday with
// null timezone.

  const long MIL = 1000000;   // one million
  const long BIL = MIL*1000;    // one billion

  timespec  now;
  get_now(&now);

  // limit!
  // seconds to microseconds - signed this gives a bit over half an hour
  long  wait_musec = (long)(delta*MIL);
  timespec  delay = { wait_musec / MIL, (wait_musec % MIL)*1000 };
  
  // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
  when->tv_sec = now.tv_sec + delay.tv_sec;
  when->tv_nsec = now.tv_nsec + delay.tv_nsec;

  if(when->tv_nsec >= BIL)      // overflow of nanoseconds?
  {
    // printf("OVERFLOW = %li, %li\n", when->tv_sec, when->tv_nsec);
    // x, y < BIL, x + y < 2BIL
    when->tv_sec++;
    when->tv_nsec -= BIL;
    // when->tv_sec += when->tv_nsec/BIL;
    // when->tv_nsec %= BIL;
  }

  // printf("when = %li, %li\n", when->tv_sec, when->tv_nsec);
  // tp contains tv_sec (seconds) & tv_usec (microseconds) both longs.
  // however, if nonposix works everywhere...
}

// note: may not need time to be in sleep_task. could pass time here.
void
sleep_task_queue::add_sleep_request(sleep_task* st, double delta)
{
  // printf("add_sleep_request: %lf\n", delta);

  future_evt  evt;
  evt.task = st;
  calc_when(&evt.when, delta);    // calculate when (t a delta)

  pmut_locker locker(lock);

  PRIOQ->push(evt);

  // we may have inserted at sooner than any other evt, so wake up thread
  // to figure it out (if need be). I seemed to be getting more wakeups
  // with this. Turned off for now. Not sure how that works.
  if(1 || PRIOQ->top().task == st)
  {
//    printf("WE PUSHED IN - waking thread\n");
    wakeup_thread();
  }
}

void
sleep_task_queue::wakeup_thread()
{
  // printf("waking sleeper thread with pthread_cond_signal\n");
  int res;
  // we don't need broadcast because we're only ever waking
  // one thread, the sleeper thread.
  res = pthread_cond_signal(&sleep_cond);
  if(0 != res) printf("condition signal failed: %i\n", res);
}

void*
sleep_task_queue::thread_start(void* udat)
{
  sleep_task_queue* q = (sleep_task_queue*)udat;
  printf("sleeper thread\n");

  while(1)
  {
    // printf("sleep thread testing cancel\n");
    pthread_testcancel();   // not actually necessary
    q->thread_loop_body();
  }
  return 0;           // could happen
}

void
sleep_task_queue::thread_loop_body()
{
  pmut_locker locker(lock); // lock on. lock off when waiting on condition

  int   res;

  // pthread_cond_wait & pthread_cond_timedwait (& np rel version?) are
  // cancellation points. doco notes for timed & untimed waits that the
  // predicate should be rechecked as there can be spurious wakeups.
  // no worries, when we wakeup the lock has been acquired.

  while(!PRIOQ->empty())
  {
    future_evt  evt = PRIOQ->top();

    future_evt  now;    // "now' has no task, just a dummy.
    get_now(&now.when);

    // if(evt < now)    // would prefer <=, eh.
    // < is arse backwards because I don't know how to use the stl
    if(now < evt)   // would prefer <=, eh.
    {
      // printf("firing of (%li, %li) at (%li, %li)!\n",
      //  evt.when.tv_sec, evt.when.tv_nsec,
      //  now.when.tv_sec, now.when.tv_nsec);
      evt.task->fire();
      PRIOQ->pop();
    }
    else  // we have an event in future, so sleep for that long
    {
      // remember that condition waits are exit points...
      // so I don't need to test - check that.
      // printf("sleeping from %li, %li until %li, %li\n",
      //  now.when.tv_sec, now.when.tv_nsec,
      //  evt.when.tv_sec, evt.when.tv_nsec);
      res = pthread_cond_timedwait(&sleep_cond, &lock.m, &evt.when);

      // if using posix abstime timed wait we make get EINVAL here for 
      // abstimes in the past. must handle this.
 
      // printf("pthread_cond_timedwait woke up! (%i)\n", res);
    }
  }

  // if we got here then the queue is empty, so sleep indefinitely
  // that we don't really need the mainloop testcancel because the condition
  // wait functions are cancellation points.
  // printf("no sleep task, sleeping indefinitely\n");
  res = pthread_cond_wait(&sleep_cond, &lock.m);
  // printf("pthread_cond_wait woke up! (%i)\n", res);

  // lock released here
}

@h=tangler('demux/demux_work_fifo.cpp')
@select(h)
#include <stdio.h>    // printf
#include "demux_work_fifo.hpp"

// a fifo of tasks & a thread (threads?) to serve them.
// users overload finished function to implement wakeup

worker_fifo::worker_fifo()
{
  printf("async worker fifo io module constructor\n");
  // fifo already inited and ready to go, so get pthread going
  int res = io_thread.init(thread_start, this);

  if(0 != res) throw res;

#if 0
  printf("hey, trying multi threads here (leakingly)\n");
  for(int i = 1; i < 1; i++)
  {
    printf("extra io thread\n");
    apthread* pt = new apthread;
    res = pt->init(thread_start, this);
    if(0 != res) throw res;
  }
#endif
}

// io thread entry point, passed this
void*
worker_fifo::thread_start(void* udat)
{ 
  worker_fifo*  fio = (worker_fifo*)udat;
  printf("posix worker_fifo thread started! this=%p\n", fio);

  while(1)
  {
    pthread_testcancel();     // make cancellable
    fio->thread_loop_body();    // the real thing
  }
  return 0;             // return status. could happen.
}

void
worker_fifo::thread_loop_body()
{
  worker_task*  req = (worker_task*)fifo.dequeue();
  // printf("dequeued worker_task (%p)\n", req);
  req->doit();
  req->finished();          // finish hook. I find this handy
}

void
worker_fifo::add_worker_task(worker_task* task)
{
  fifo.enqueue(task);         // don't worry, fifo is re-entrant
}

@h=tangler('demux/demux_sockety.cpp')
@select(h)
#include <stdio.h>        /* for perror */
#include <fcntl.h>        /* for making non blocking sockets */
#include <netinet/in.h>     /* for sockaddr_in (used when accepting) */
#include <arpa/inet.h>      /* for inet_addr */
#include <unistd.h>       /* for close */

#include <sys/types.h>      /* for accept */
#include <sys/socket.h>
#include <sys/errno.h>      /* EINPROGRESS */

#include <errno.h>        /* errno */

#include <string.h>       /* for memset */

@tangle("typedef " + FLX_SOCKLEN_T + " FLX_SOCKLEN_T;")

/*
 returns a socket ready for listening (AF_INET, SOCK_STREAM for now).
 0 in for port means let kernel decide, result in *io_port
 portable, can be factored out. listens on all NICs?
*/
int
create_listener_socket(int* io_port, int q_len)
{
  int         fdForListening;
  struct sockaddr_in  serverAddress;
  FLX_SOCKLEN_T    namelen = sizeof(serverAddress);
  int         yes = 1;

  if((fdForListening = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    return -1;

  if(setsockopt(fdForListening, SOL_SOCKET, SO_REUSEADDR,
    &yes, sizeof(int)) == -1)
  {
    perror("setsockopt");
    close(fdForListening);
    return -1;
  }

  memset(&serverAddress, 0, sizeof(serverAddress));
  serverAddress.sin_family = AF_INET;
  serverAddress.sin_addr.s_addr = htonl(INADDR_ANY);
  serverAddress.sin_port = htons(*io_port);

  /* bind to port */
  if (bind(fdForListening, (struct sockaddr *)&serverAddress, namelen) < 0) {
    close (fdForListening);   /* THIS masks the error */
    return -1;
  }

  /* we don't need to do this when the port was specified */
  if(0 == *io_port) {
    /* Find out what port number was chosen */
    if (getsockname(fdForListening, (struct sockaddr *)&serverAddress,
      &namelen) < 0) {
      close(fdForListening);  /* um, this masks the error. */
      return -1;
    }

    *io_port = ntohs(serverAddress.sin_port);
  }

  /* set listen queue length for socket */
  if(listen(fdForListening, q_len) != 0) {
    close(fdForListening);
    return -1;
  }
  return fdForListening;
}

/* create listener, make it non-blocking */
int
nice_create_listener(int* io_port, int q_len)
{
  int   listener;

  listener = create_listener_socket(io_port, q_len);

  if(-1 == listener) return -1;

  if(fcntl(listener, F_SETFL, O_NONBLOCK) == -1)
  {
    if(close(listener) != 0)
      perror("nice_create_listener close");
    return -1;
  }

  return listener;
}

/* ps, sets resulting socket to non-block */
int
nice_accept(int listener)
{
  struct sockaddr_in  remoteaddr;
  /*socklen_t     addrlen = sizeof(remoteaddr);*/
  /* os x 10.2.8 doesn't have socklen_t. will this work elsewhere? */
  /* 10.4 (gcc 4.0) complains about signedeness, so now unsigned */
  FLX_SOCKLEN_T addrlen = sizeof(remoteaddr);
  int         newfd;
  
  newfd = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);
  if(-1 == newfd) {
    perror("accept");
  }
  else
  {
    /*I think 0's the result I want*/
    if(fcntl(newfd, F_SETFL, O_NONBLOCK) == -1)
    {
      perror("fcntl");
      close(newfd);
      newfd = -1;
    }
  }
  return newfd;
}

static int
connect_sock(int s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

/* also make non-blocking AFTER connect */
int
nice_connect(const char* addr, int port)
{
  int     s = -1;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != -1
    && connect_sock(s, addr, port) == 0
    && fcntl(s, F_SETFL, O_NONBLOCK) != -1)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  perror("connect_sock");

  if(-1 != s && close(s) != 0)
    perror("nice close");

  return -1;
}

/* makes the socket non-blocking BEFORE connect, returns result */
/* from which can be determined if it finished immediately */
/* returns the socket & finished flag or -1 on failure */
int
async_connect(const char* addr, int port, int* finished)
{
  int     s = -1;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != -1
    && fcntl(s, F_SETFL, O_NONBLOCK) != -1)
  {
    if(connect_sock(s, addr, port) == 0)
    {
      *finished = 1;        /* finished */
      return s;
    }

    if(EINPROGRESS == errno)
    {
      *finished = 0;        /* not finished, in progress */
      return s;
    }
  }
  
  /* otherwise something happened (not as good as catch 22) */
  perror("async_connect");

  if(-1 != s && close(s) != 0)
    perror("async_connect close");

  *finished = 1;            /* for completeness */
  return -1;
}

