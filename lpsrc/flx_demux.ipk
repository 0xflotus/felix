@head(1,'demux')
$Log$
Revision 1.25  2006/01/26 10:04:28  rfistman
fixed failure to wake fthread after connects that finish immediately.
this fast connect only ever shows up on solaris, so full marks to them.

Revision 1.24  2006/01/21 23:45:10  rfistman
fixed potential leak and warning in posix_timer_queue constructor

Revision 1.23  2006/01/16 01:25:43  rfistman
factored faio posix accept and connect back demux as control blocks
removed pthread cancel from code - implicit cancel points are no longer used.
instead the threads are convinced to return from their mains via specially
formatted inputs.

Revision 1.22  2006/01/13 05:16:50  rfistman
made worker_fifo portable

Revision 1.21  2006/01/11 01:16:32  rfistman
added win_timer_queue to demux

Revision 1.20  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.

@execfile('config'+os.sep+'config.py')
@h=tangler('demux/demux_demuxer.hpp')
@select(h)
#ifndef __DEMUXER__
#define __DEMUXER__
#include <flx_rtl_config.hpp>

namespace flx { namespace demux {

struct sel_param {
  char*   buffer;           // set on input
  long    buffer_size;        // set on input
  long    bytes_written;        // set on input and output
};

// abstract base class(gee - it doesn't do much)
class FLX_RTL_EXTERN demuxer {
protected:
public:
  virtual ~demuxer() {}
};

}} // namespace demux, flx
#endif  /* __DEMUXER__ */

@h=tangler('demux/demux_epoll_demuxer.hpp')
@select(h)
#ifndef __EPOLL_DEMUXER__
#define __EPOLL_DEMUXER__

#include <flx_rtl_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {
class FLX_RTL_EXTERN epoll_demuxer : public posix_demuxer {
  int   epoll_fd;

  virtual void  thread_loop_body();
  void    cleanup();

  void  remove_socket(int s, bool read);

public:
  epoll_demuxer();
  virtual ~epoll_demuxer();
  
  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_evtport_demuxer.hpp')
@select(h)
#ifndef __EVTPORT_DEMUXER__
#define __EVTPORT_DEMUXER__

// driver for solaris 10 event port notifications

#include <flx_rtl_config.hpp>
#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {

// oops - have found out that you can't separately associate
// the same fd with POLLIN and POLLOUT without doing it at
// the same time (separately just overwrites the last). It's
// not often that you add the same fd for both reading and
// writing, but I've done it, so I'm making the old
// evtport demuxer a "half" demuxer, that handles either
// in or out and wrap them both in single demuxer for now.
// kinda yuk, as we'll have 3 pthreads, one which exits
// immediately.
class FLX_RTL_EXTERN evtport_half_demuxer : public posix_demuxer {
    int     evtport;
  void  cleanup();
protected:
    virtual void  thread_loop_body();

  void remove_reading_fd(int s);
  void remove_writing_fd(int s);
public:
  evtport_half_demuxer();
  virtual ~evtport_half_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

class FLX_RTL_EXTERN evtport_demuxer : public posix_demuxer {
    virtual void  thread_loop_body();   // trivial, exits

  evtport_half_demuxer  in;
  evtport_half_demuxer  out;
public:
  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_iocp_demuxer.hpp')
@select(h)
#ifndef __IOCP_DEMUXER__
#define __IOCP_DEMUXER__

// includes WinBase.h, where CreateIOCompletionPort lives
// May need to define _WIN32_WINNT = 0x0350? Or not.
#include <Windows.h>
#include <flx_rtl_config.hpp>

#include "demux_demuxer.hpp"
#include "demux_sleep_queue.hpp"


namespace flx { namespace demux {

// not here? returns INVALID_SOCKET on failure
SOCKET FLX_RTL_EXTERN create_listener_socket(int* io_port, int backlog);


// this thing isn't actually being used by the iocp code. it should be.
class FLX_RTL_EXTERN win_thread {
  HANDLE    thread;

public:
  win_thread();
  ~win_thread();

  // some msdn code examples imply that it's risky to use the CRT
  // (C runtime) in a thread. would conio be better?
  int init(LPTHREAD_START_ROUTINE, LPVOID lParam);
  void deinit();
};

// make sure you instantion ONE (1) of these before using winsock
class FLX_RTL_EXTERN winsock_initer
{
public:
  winsock_initer();
  ~winsock_initer();
};

// iocp_wakeup base class for users of iocp_demuxer
// becoming an overlapped call control block
class FLX_RTL_EXTERN iocp_wakeup {
protected:            // folks need to use these in win 32 calls
  OVERLAPPED  ol;
  // I didn't want this to be felixy, useful though.
  void clear_overlapped();  // zero the OVERLAPPED structure
public:
  // 2 possibilities for piggybacking data. who could ask for more?
  // udat = per iocp association, olp = per overlapped function call.
  // why don't I need this in the posix version?
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err) = 0;

  // start overlapped async operation. returns true if it finished
  // immediately. in this case there will be no iocp_finished wakeup.
  // assumes all args ready for call.
  virtual bool start_overlapped() = 0;

  // retrieves this pointer from OVERLAPPED pointer
  static iocp_wakeup* from_overlapped(LPOVERLAPPED olp);
};

class FLX_RTL_EXTERN iocp_demuxer : public demuxer {
  HANDLE    iocp;     // the io completion queue
  win_thread  iocp_thread;  // our "select" thread

  // necessary windows magic for CreateThread
  // see CreateThread example code on MSDN
  static DWORD WINAPI worker_thread_stub(LPVOID lParam);
  void    worker_thread_body();

  void    cleanup();
public:
  iocp_demuxer();
  virtual ~iocp_demuxer();

  // udat is the per IOCP object user cookie & the overlapped pointer
  // is the per overlapped operation cookie (sort of), so in the case
  // of acceptex, udat is set when the listener is associated with the
  // iocp and is passed to the subsequent acceptex iocp wakeups.
  // probably won't be used very often
  // the OVERLAPPED retrieved from the iocp is assumed to be part of
  // an iocp_wakeup - beware! returns 0 on success, -1 on failure.
  int associate_with_iocp(HANDLE obj, ULONG_PTR udat);
};

// synchronisation stuff
class FLX_RTL_EXTERN win_locker {
  HANDLE  m;
public:
  win_locker(HANDLE mutex);
  ~win_locker();
};

class FLX_RTL_EXTERN win_queue  : public sleep_queue {
  HANDLE    member_lock;  // protects member data
  HANDLE    nz_elts_cond; // wakes up threads waiting on resource
  void*     lame_opaque;  // when will I ever learn?
  void      cleanup();
public:
  win_queue();
  ~win_queue();

  virtual void enqueue(void*);  // re-entrant
  virtual void* dequeue();    // re-entrant, sleeps on empty queue
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_kqueue_demuxer.hpp')
@select(h)
#ifndef __KQUEUE_DEMUXER__
#define __KQUEUE_DEMUXER__

#include "demux_posix_demuxer.hpp"

namespace flx { namespace demux {
class FLX_RTL_EXTERN kqueue_demuxer : public posix_demuxer {
  int   kq;
protected:
  virtual void  thread_loop_body();

  void remove_reading_fd(int s);
  void remove_writing_fd(int s);

  int add_reading_socket(socket_wakeup* sv);
  int add_writing_socket(socket_wakeup* sv);

  void cleanup();
public:
  kqueue_demuxer();
  virtual ~kqueue_demuxer();

  virtual int add_socket_wakeup(socket_wakeup* sv, bool read);
};

}} // namespace demux, flx
#endif
@h=tangler('demux/demux_mutexlite.hpp')
@select(h)
#ifndef __MUTEXLITE__
#define __MUTEXLITE__
#include <flx_rtl_config.hpp>

// simple mutex. call lock, unlock
// not sure that I'm locking properly. may need cancel handlers.

#include <pthread.h>
namespace flx { namespace demux {

class FLX_RTL_EXTERN pmut {
public:
  pthread_mutex_t m;        // be nice, don't touch

  pmut(bool recursive);
  ~pmut();
  void lock();
  void unlock();
};

// simple locker
class FLX_RTL_EXTERN pmut_locker {
  pmut& p;
public:
  pmut_locker(pmut& pm) : p(pm) { p.lock(); }
  ~pmut_locker() { p.unlock(); }
};

// auto pthread, because I forget how to deallocate them nicely
// could init in the constructor, but ultimately you don't want the thread
// barging in before you've finished doing other stuff
// Addendum (20051128): doing stdio in turns out to be not very safe.
// I don't know if printf et al are supposed to be thread safe (most impls
// seem to try to be) but I sometimes get deadlocks in ppc64 os x 10.4.2
// with 4.0.1 when printfing to stdout. Nasty.
class FLX_RTL_EXTERN apthread {
  pthread_t   thr;        // the thread
  bool      inited;       // do I need this or is pthread_t a pointer?
public:
  apthread() : inited(false) {}
  ~apthread();

  pthread_t get() { return thr; }
  
  int init(void* (*start)(void*), void* udat);
  void deinit();  
  // int cancel();            // phase this out
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_pfileio.hpp')
@select(h)
#ifndef __PFILEIO__
#define __PFILEIO__
#include <flx_rtl_config.hpp>

#include "demux_demuxer.hpp"
#include "demux_posix_queue.hpp"
#include "demux_mutexlite.hpp"
// #include <sys/types.h> // off_t (don't have flx iface to this yet)
              // can just add new constructor
#include "demux_work_fifo.hpp"
namespace flx { namespace demux {

// like another event source. this is basically a wrapped pread, pwrite
// should probably be derived from posix_wakeup or something like that.
// or have the same signature. abstract - users overload "finished
class FLX_RTL_EXTERN fileio_request : public worker_task
{
  long    offset;   // make this a proper offset (64bit)
  // off_t    offset; // in: offset, for use with pread, pwrite
  int     fd;     // in: fd in question
  bool    read_flag;  // in: read else write

  int     err;    // out:
public:
  // public so it can be got in felix
  sel_param pb;   // in & out: what you want, what you get (64bit len?)

  virtual ~fileio_request() {}  // c++ should do this automatically
  fileio_request()  {}      // flx linkage
  fileio_request(int f, char* buf, long len, long off, bool rd);

  virtual void doit();      // sync
};

// could do separate threads for in & out. or implement some form of cache.
class FLX_RTL_EXTERN pasync_fileio : public worker_fifo
{
public:
  // compatibility only. don't need this class anymore.
  void add_fileio_request(fileio_request* req) { add_worker_task(req); } 
};

}} // namespace demux, flx
#endif  // __PFILEIO__
@h=tangler('demux/demux_posix_demuxer.hpp')
@select(h)
#ifndef __POSIX_DEMUXER__
#define __POSIX_DEMUXER__

// this is simply a demuxer with a pthread that calls thread_loop_body
// with a thread cancel hook and a hopefully correct destructor. hoof!
// it also owns an optional listener socket. imagine that!s

#include <pthread.h>
#include "demux_demuxer.hpp"
#include "demux_mutexlite.hpp"

namespace flx { namespace demux {
class FLX_RTL_EXTERN posix_demuxer;            // fwd decl

// abc
class FLX_RTL_EXTERN posix_wakeup {
public:
  virtual ~posix_wakeup() {}

  // when called, the wakeup has finished and been removed.
  virtual void wakeup(posix_demuxer& demux) = 0;
};

class FLX_RTL_EXTERN socket_wakeup : public posix_wakeup {
public:
  int   s;                // the non blocking socket
  // thinking about putting a read flag here - everyone has to
  // do their own anyway and the current model doesn't allow both
  // for a single socket_wakeup, even if some event sources support it.
};

class FLX_RTL_EXTERN posix_demuxer : public demuxer {
  apthread    evt_pthr;       // the event loop thread
  static void*  thread_start(void*);  // bootstrap thread callback

protected:
  virtual void  thread_loop_body() = 0;
  int       init_pthread();
  void      deinit_pthread();
  
public:
  virtual ~posix_demuxer();

  virtual int   add_socket_wakeup(socket_wakeup* sv, bool read) = 0;
  
  // to be called when we can read & write without blocking
  // return true if connection closed, update pb
  // sort of a strange place to have this..., more a socket wakeup
  // thing, even if static
  static bool   socket_recv(int s, sel_param* pb);
  static bool   socket_send(int s, sel_param* pb);
};

// some handy control blocks for common non-blocking socket operations
class FLX_RTL_EXTERN accept_control_block : public socket_wakeup {
public:
  int   accepted;   // accepted socket (out)
  int   socket_err;   // the error, if acceptee == -1, else 0 (out)
  
  accept_control_block() : accepted(-1), socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);
};

class FLX_RTL_EXTERN connect_control_block : public socket_wakeup {
public:
  int     socket_err;   // outgoing error (on start or wake)
  // this should probably be a sockaddr type
  const char* addy;     // addr (dotted quad) (in)
  int     p;        // port (in)
  
  connect_control_block() : socket_err(0) {}

  virtual int start(posix_demuxer& demux);
  virtual void wakeup(posix_demuxer& demux);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_posix_queue.hpp')
@select(h)
#ifndef __POSIX_QUEUE__
#define __POSIX_QUEUE__
#include "demux_mutexlite.hpp"
#include "demux_sleep_queue.hpp"
#include <flx_rtl_config.hpp>

namespace flx { namespace demux {
class FLX_RTL_EXTERN posix_queue  : public sleep_queue {
  pmut      member_lock;  // protects member data
  pthread_cond_t  nz_elts_cond; // wakes up threads waiting on resource
  void*     lame_opaque;  // when will I ever learn?
public:
  posix_queue();
  ~posix_queue();

  virtual void enqueue(void*);    // re-entrant
  virtual void* dequeue();      // re-entrant, sleeps on empty queue
};

}} // namespace demux, flx
#endif  // __POSIX_QUEUE__

@h=tangler('demux/demux_select_demuxer.hpp')
@select(h)
#ifndef __SELECT_DEMUXER__
#define __SELECT_DEMUXER__

#include "demux_posix_demuxer.hpp"
#include "demux_mutexlite.hpp"
#include <sys/select.h>   // for fd_set

namespace flx { namespace demux {
class FLX_RTL_EXTERN select_demuxer : public posix_demuxer {
  // still using these, but they're not virtual - make them private &
  // remove the locks?
  void  remove_reading_fd(int s);
  void  remove_writing_fd(int s);


  pmut      ham_fist;       // big conservative hamfisted lock
  
  // thanks Beej!
  fd_set      master_read_set;    // all the threads we're watching, reading
  fd_set      master_write_set;   // writing
  socket_wakeup*  read_svs[FD_SETSIZE]; // read sveglias
  socket_wakeup*  write_svs[FD_SETSIZE];  // write wakeups

  int       fdmax;          // high watermark for select
  
  virtual void  thread_loop_body();

public:
  select_demuxer();
  ~select_demuxer() { deinit_pthread(); }

  virtual int   add_socket_wakeup(socket_wakeup* sv, bool read);
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_sleep_queue.hpp')
@select(h)
#ifndef __SLEEPQUEUE__
#define __SLEEPQUEUE__
#include <flx_rtl_config.hpp>


// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace demux {
class FLX_RTL_EXTERN sleep_queue {
public:
  virtual ~sleep_queue() {}

  virtual void enqueue(void*) = 0;  // re-entrant
  virtual void* dequeue() = 0;    // re-entrant, sleeps on empty queue
};

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_sockety.hpp')
@select(h)
#ifndef __SOCKETY__
#define __SOCKETY__
#include <flx_rtl_config.hpp>
namespace flx { namespace demux {
int create_listener_socket(int* io_port, int q_len);
int create_async_listener(int* io_port, int q_len);
int nice_accept(int listener, int* err);
int nice_connect(const char* addr, int port);
int async_connect(const char* addr, int port, int* finished, int* err);

/* handy socket building blocks */

int connect_sock(int s, const char* addr, int port);

/* this could possibly do with NIC addr as well as port */
int bind_sock(int s, int* io_port);

int make_nonblock(int s);

}} // namespace demux, flx
#endif

@h=tangler('demux/demux_work_fifo.hpp')
@select(h)
#ifndef __WORKER_FIFO__
#define __WORKER_FIFO__
#include <flx_rtl_config.hpp>

#ifdef _WIN32     // quick hack
#include "demux_iocp_demuxer.hpp"
#else           // else posix
#include "demux_posix_queue.hpp"
#include "demux_mutexlite.hpp"
#endif

namespace flx { namespace demux {
// abstract 
class FLX_RTL_EXTERN worker_task
{
public:
  virtual ~worker_task() {}   // c++ should do this automatically

  virtual void doit() = 0;    // doit, synchronously
  virtual void finished() = 0;  // finished hook (mi serve start gancia?)
};

// make this into a general work queue
class FLX_RTL_EXTERN worker_fifo
{
  // this thread is destructed very carefully to make sure that all
  // the objects in this class outlive its execution.
#ifdef _WIN32
  win_thread  thread;
  win_queue fifo;
#else
  apthread  thread;
  posix_queue fifo;         // reentrant fifo!
#endif

  static void* thread_start(void*); // thread entry point, passed this
  bool thread_loop_body();      // returns keep going flag

public:
  worker_fifo();
  ~worker_fifo();

  void add_worker_task(worker_task* task);  // also re-entrant

  // those deriving from this class might like to stop the
  // thread in their destructors, so that their objects used
  // by the worker thread can outlive it
  void stop_worker_thread();
  };

}} // namespace demux, flx
#endif  // __WORKER_FIFO__
@h=tangler('demux/demux_timer_queue.hpp')
@select(h)
#ifndef __TIMER_QUEUE__
#define __TIMER_QUEUE__

#include <flx_rtl_config.hpp>

namespace flx { namespace demux {

// trying to factor out code to share between pc & posix versions

// class sleep_task : public worker_task
// may not need time in here - just the wakeup - something I surely have
// somewhere else.
class FLX_RTL_EXTERN sleep_task
{
public:
    virtual ~sleep_task() {}

    virtual void fire() = 0;
};

class FLX_RTL_EXTERN timer_queue
{
public:
    virtual ~timer_queue() {}

    virtual void add_sleep_request(sleep_task* st, double delta) = 0;
};
}} // namespace demux, flx

#endif
@h=tangler('demux/demux_posix_timer_queue.hpp')
@select(h)
#ifndef __POSIX_TIMER_QUEUE__
#define __POSIX_TIMER_QUEUE__

#include "demux_mutexlite.hpp"
#include "demux_timer_queue.hpp"

namespace flx { namespace demux {

// looks like a worker queue, but couldn't quite mash it into one
class FLX_RTL_EXTERN posix_timer_queue : public timer_queue
{
  // ATTENZIONE: the thread uses this & so it must outlive it
  // for this it is declared before the thread (I would've expected
  // an error to be returned from pthread_mutex_lock instead of
  // deadlock but whatever).
  // update: I was getting deadlock in a broken stdlib version
  // gcc4.0.1, ppc64, osx10.4.2 in printf, however the above still
  // stands: the lock must outlive the thread that uses it.
  pmut    lock;         // factor to prio queue?

  apthread  sleep_thread;
  static void* thread_start(void*); // passed "this"
  bool thread_loop_body();

  void*   opaque_prio_queue;    // less fat

  pthread_cond_t  sleep_cond;     // this could be cool.
  int setup_sleep_cond();
  void takedown_sleep_cond();     // deallocate the condition

  void wakeup_thread();       // we can do this!
public:
  posix_timer_queue();
  ~posix_timer_queue();

  // thread safe.
  virtual void add_sleep_request(sleep_task* st, double delta);
};

}}

#endif // __POSIX_TIMER_QUEUE__
@h=tangler('demux/demux_win_timer_queue.hpp')
@select(h)
#ifndef __WIN_TIMER_QUEUE__
#define __WIN_TIMER_QUEUE__

// note: NOT include Windows.h here as the .cpp file needs to up the
// the _WIN32_WINNT version, something that must be done before the
// inclusion of Windows.h, but I don't want to force that on users
// of this file, hence this file must follow windows.h.
//#include <Windows.h>

#include "demux_timer_queue.hpp"

namespace flx { namespace demux {

class FLX_RTL_EXTERN win_timer_queue : public timer_queue
{
  HANDLE    timer_queue;

  static VOID CALLBACK timer_callback(PVOID, BOOLEAN);
public:
  win_timer_queue();
  ~win_timer_queue();

  virtual void add_sleep_request(sleep_task* st, double delta);
};

}}

#endif // __SLEEP_TASK__
@h=tangler('demux/demux_demuxer.cpp')
@select(h)
#include "demux_demuxer.hpp"

// nothing here atm ..

@h=tangler('demux/demux_epoll_demuxer.cpp')
@select(h)
// epoll interface. does epoll support ordinary files in addition to sockets?
// EPOLLET to make epoll edgetriggered. I guess the default is level triggered.

// cool! EPOLLONESHOT
// BUGGER! doesn't seem to exist! and doing this doesn't make it so!
// #ifndef EPOLLONESHOT
// #define EPOLLONESHOT (1<<30)
// #endif

#include "demux_epoll_demuxer.hpp"

#include <sys/epoll.h>  // for epoll_*
#include <stdio.h>  // for perror
#include <unistd.h> // for close

namespace flx { namespace demux {

epoll_demuxer::epoll_demuxer()
  : epoll_fd(-1)
{
#ifdef EPOLLONESHOT
  fprintf(stderr,"WARNING: EPOLLONESHOT AVAILABLE!!!\n");
#endif

  // god knows what the maximum size will be, I'll just say 1 for now
  epoll_fd = epoll_create(1);
  if(-1 == epoll_fd)
  {
    perror("epoll_create");
    cleanup();
    throw -1;
  }

  int res = init_pthread();
  if(res != 0)
  {
    cleanup();
    throw res;
  }
}

void
epoll_demuxer::cleanup() {
  deinit_pthread();

  if(-1 != epoll_fd)
  {
    if(close(epoll_fd) != 0)
      perror("epoll close");
  }
}

epoll_demuxer::~epoll_demuxer()
{
  cleanup();
}

int
epoll_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  int s = sv->s;

  struct epoll_event  evt;
  // fprintf(stderr,"add_socket_wakeup: %sing on %i (sv=%p)\n",
  //  (read) ? "read" : "writ", s, sv);

  // EPOLLONESHOT saves us not only a system call to remove epoll evts,
  // which aren't intrinsically one-shot, but having to do it ourselves
  // would have been a pain as epoll doesn't tell you which fd had the event
  // this way we can get away with not knowing & not losing our user cookie
  evt.events = (read) ? EPOLLIN : EPOLLOUT; // can get errs, hup, whatever
  // FUCK!
#ifdef EPOLLONESHOT
  evt.events |= EPOLLONESHOT;         // yes!
#endif
  evt.events |= EPOLLHUP | EPOLLERR;        // I think I want this

  evt.data.ptr = sv;              // our user data
  // uffa but that's lame!
  // pb->epoll_hack = s;      // I hate this - there must be a better way

  if(epoll_ctl(epoll_fd, EPOLL_CTL_ADD, s, &evt) == -1)
  {
    perror("epoll_ctl (add)");
    return -1;
  }
  return 0;
}

void
epoll_demuxer::remove_socket(int s, bool read)
{
  struct epoll_event  evt;
  evt.events = (read) ? EPOLLIN : EPOLLOUT;

  // fprintf(stderr,"removing %sing socket %i\n", (read) ? "read" : "writ", s);

  if(epoll_ctl(epoll_fd, EPOLL_CTL_DEL, s, &evt) == -1)
  {
    const char* str = (read) ? "epoll_ctl (remove read)"
      : "epoll_ctl (remove write)";
    perror(str);
  }
}

void
epoll_demuxer::thread_loop_body()
{
  struct epoll_event  evt;

  // no timeout
  if(epoll_wait(epoll_fd, &evt, 1, -1) == -1)
  {
    perror("epoll_wait");
    return;
  }

  // damn! it doesn't tell me the socket! I'd have to store that
  // myself!
  // int      s = pb->epoll_hack;     // nooooo
  // if I don't need to explicitly add the stuff back in,
  // I might be able to get away with not knowing the socket (?)

  socket_wakeup* sv = (socket_wakeup*)evt.data.ptr;
  
  // fprintf(stderr,"wakeup!\n");
  
  // it might be possible to get both a read & write event...
  // in which case I should take out the else below
  if(evt.events & EPOLLIN)                // I think this is how you do it
  {
    // epoll events are not one shot, so evt must be removed
    // looks like I do need to know how - can I make them one shot?
    // fprintf(stderr,"wakeup of reader %p\n", sv);
    remove_socket(sv->s, true);
    sv->wakeup(*this);
  }
  else if(evt.events & EPOLLOUT)
  {
    // fprintf(stderr,"wakeup of writer %p\n", sv);
    remove_socket(sv->s, false);
    // ditto.
    sv->wakeup(*this);
  }
#ifndef EPOLLONESHOT
  else if(evt.events & EPOLLERR)
  {
    // I need to remove it, but which one am I removing?
    // I guess I'll just have to remove both. Note that a working
    // one-shot would fix this, I think. One of these will cause
    // an error
    fprintf(stderr,"epoll error: don't know from who, removing both\n");
    remove_socket(sv->s, true);
    remove_socket(sv->s, false);
  }
#endif
    else
    {
        fprintf(stderr,"unknown events in epoll_demuxer (err?)\n");
    }
}

}}

@h=tangler('demux/demux_evtport_demuxer.cpp')
@select(h)

#include "demux_evtport_demuxer.hpp"

// looks like this stuff is only in solaris10, and not SunOS 5.8. Damn.

#include <port.h>
#include <poll.h> // POLLIN/POLLOUT
#include <stdio.h>  // printf
#include <unistd.h> // close
#include <assert.h>

namespace flx { namespace demux {

// wrapping two "real" evtport_demuxers into one, so I can
// have simultaneously reading and writing sockets.
// see comments in header file

// unfortunate side effect of deriving this from posix demuxer...
// I get an unwanted pthread
void
evtport_demuxer::thread_loop_body()
{
  fprintf(stderr, "trival evtport_demuxer thread, exiting...\n");
  pthread_exit(0);
}

int
evtport_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  if(read) return in.add_socket_wakeup(sv, read);
  else return out.add_socket_wakeup(sv, read);
}

// header files for this stuff?
// can use port_send for user defined events, to wake up reap loop
// truss to see what's happening

evtport_half_demuxer::evtport_half_demuxer()
{
  if((evtport = port_create()) < 0)
  {
    perror("port_create");
    cleanup();
    throw -1;
  }

  // silly virtual function stuff - must be done here.

  if(init_pthread() != 0)
  {
    cleanup();
    throw -1;
  }
}

void
evtport_half_demuxer::cleanup()
{
  // fprintf(stderr,"do you use close to close an event port?\n");
  deinit_pthread();

  if(-1 != evtport)
  {
    if(close(evtport) != 0)
      perror("evtport close");
  }
}

evtport_half_demuxer::~evtport_half_demuxer()
{
  cleanup();
}


int
evtport_half_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  int events = (read) ? POLLIN : POLLOUT;
  int s = sv->s;

  // fprintf(stderr,"add_socket_wakeup: %i, sv: %p, %s\n", s, sv,
  //  (read) ? "reading" : "writing");

  // register for event we are interested in...
  // works for files, sockets, timers...
  // is this the right one for sockets? that's all I care about for now
// IS POLLIN what I want? or will that actually POLL?
  if(port_associate(evtport, PORT_SOURCE_FD, (uintptr_t)s, events, sv) == -1)
  {
    perror("socket_wakeup/port_associate");
    return -1;
  }

  return 0;
}

// note that these two functions are exactly the same
// we have to remove after a read or write else we can get multiple
// wakeups - usually with a dud user cookie. the fact that there is
// no differentiation between POLLIN & POLLOUT could be a problem for
// mixed read/write things (rare). note that evt_ports let me associate
// the samething twice. I don't know if this means you have to dissociate
// (disassociate) twice.
void
evtport_half_demuxer::remove_reading_fd(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("reading port_dissociate");
}

void
evtport_half_demuxer::remove_writing_fd(int s)
{
  if(port_dissociate(evtport, PORT_SOURCE_FD, s) == -1)
    perror("writing port_dissociate");
}

static void
print_port_evt(port_event_t* e)
{
  char* srcstr[PORT_SOURCE_ALERT-PORT_SOURCE_AIO+1]
    = { "ALERT", "TIMER", "USER", "FD", "AIO"};
  fprintf(stderr,"e: %p\n\t", e);
  //fprintf(stderr,"portev_events: %x\n\t", e->portev_events);
  fprintf(stderr,"portev_events: ");
  if(e->portev_events & POLLIN) fprintf(stderr,"POLLIN, ");
  if(e->portev_events & POLLOUT) fprintf(stderr,"POLLOUT, ");
  if(e->portev_events & POLLERR) fprintf(stderr,"POLLERR");
  fprintf(stderr," (%x)\n\t", e->portev_events);
  
  int src = e->portev_source;
  if(PORT_SOURCE_AIO <= src && src <= PORT_SOURCE_ALERT)
  {
    fprintf(stderr,"portev_source: PORT_SOURCE_%s (%x)\n\t",
      srcstr[src-PORT_SOURCE_AIO], src);
  }
  else
  {
    fprintf(stderr,"portev_source: %x\n\t", e->portev_source);
  }

  fprintf(stderr,"portev_pad: %x\n\t", e->portev_pad);
  fprintf(stderr,"portev_object: %x\n\t", e->portev_object);
  fprintf(stderr,"portev_user: %p\n", e->portev_user);
}

void
evtport_half_demuxer::thread_loop_body()
{
  // fprintf(stderr,"evtport thread loop body!!!\n");
// Block until a single event appears on the port
// event will not fire again, so must re-add it, that is, it automatically
// dissociates, which is going to make remove interesting... remove never
// (currently) happens except in response to receiving an event, so making
// it a nop should be ok.
// this means we have to add it back if we're not finished, i.e. if 
// we're looking for more data

  port_event_t  evt;

// I think that although port_get seems to be one-shot, it sometimes isn't.
// what to do?
// I'm definitely getting two in a row type events. I'll try explicitly
// removing... the port_create manpage says this should definitely not
// happen
  // is this the right return val? and the right behaviour?
  // has my evt been dissociated? which one? return val num events?
  if(port_get(evtport, &evt, NULL) < 0)
  {
    perror("port_get");
    return;
  }

  // fprintf(stderr,"PORT_GET RETURNED: "); print_port_evt(&evt);

  // get wakeup obj tucked away in the user cookie.
  socket_wakeup*  sv = (socket_wakeup*)evt.portev_user;
  int       s = evt.portev_object;

  if(evt.portev_events & POLLERR)
  {
    fprintf(stderr,"ERRORS on s = %i, sv = %p\n", s, sv); 
    //evt.portev_events &= ~POLLERR;
    //return;
  }


  if(evt.portev_source != PORT_SOURCE_FD)
    fprintf(stderr,"got non PORT_SOURCE_FD (%i, %p)\n", s, sv);

  // we'd better hope that they're not both, or we could get two
  // wakeups at once...
  // update: when events like POLLIN and POLLOUT are added, in separate
  // invocations of port_associate, for the same file descriptor, the
  // later one overwrites the earlier, so POLLIN followed by POLLOUT
  // will never get its POLLIN. The simplest solution to this that I
  // could see was to wrap two evtport_demuxers (now called half demuxers)
  // into one, with each respectively minding input and output. It's not
  // the best solution to a rare problem (and needlessly increases the
  // number of threads), but it works. This assert should definitely never
  // happen now, so I may as well leave it there.
 
  assert(!((evt.portev_events & POLLIN) && (evt.portev_events & POLLOUT)));

  if(evt.portev_events & POLLIN)
  {
    // fprintf(stderr,"GOT READ EVT FOR %p\n", sv);
    assert(sv);
    sv->wakeup(*this);
  }

  if(evt.portev_events & POLLOUT)
  {
    // fprintf(stderr,"GOT WRITE EVT FOR %p\n", sv);
    assert(sv);
    sv->wakeup(*this);
  }

  // I never asked for POLLERR, but anyway
  if(evt.portev_events & ~(POLLIN | POLLOUT | POLLERR))
    {
        fprintf(stderr,"UNSOLICITED events in evtport_half_demuxer (%x)\n",
      evt.portev_events);
    }
}
}}

@h=tangler('demux/demux_iocp_demuxer.cpp')
@select(h)
#include "demux_iocp_demuxer.hpp"

#include <stdio.h>      // for printf debugging
#include <stddef.h>     // offsetof
// shoving the win_queue in here for now
#include <queue>          // stl to the bloated rescue

using namespace std;

namespace flx { namespace demux {

// this could really do with auto objs. steal the strat stuff?

// add windows error processing macros. It's a bore otherwise.

// WaitForSingleObject on an kill event in the thread for thread cancel
// kill_event = CreateEvent(NULL, TRUE, FALSE, NULL); (what's that)
// SetEvent(kill_event) to invoke (?): SetEvent sets the event to the 
// signalled state. Return value is success flag. GetLastError.

// do auto SOCKET wrapper, check closesocket return code.

// a completion port is a queue into which the os puts notifications of
// completed overlapped io requests. once the operation completes, a
// notification is sent to a worker thread that can process the result.
// a socket may be associated with a completion port at any point after
// creation.


// I don't see how to nicely stop a thread, I may have to have my own protocol
// to ask it to exit.

// PostQueuedCompletionStatus can be used by threads to wake up a worker
// thread. Could be handy replacement for timeout. "useful for notifying
// worker threads of external events"

// working through this: http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/
// example of worker thread here
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/i_o_completion_ports.asp
// nono, use this onec
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// oh, wait they're the same
// FormatMessge

winsock_initer::winsock_initer()
{
  WSADATA wsaData;

  // apparently 2.2's the way to go
  if(WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
  {
    int err = WSAGetLastError();
    fprintf(stderr,"couldn't find usable winsock dll: %i\n", err);
    throw err;
  }
}

winsock_initer::~winsock_initer()
{
  if(WSACleanup() != 0)
  {
    fprintf(stderr,"WSACleanup failed %i\n", WSAGetLastError());
  }
}

// iocp_wakeup base class for users of iocp_demuxer
//static
iocp_wakeup*
iocp_wakeup::from_overlapped(LPOVERLAPPED olp)
{
  // calculate the address of this from overlapped member
  // suffer an obligatory offsestof warning from broken gccs.
  return (iocp_wakeup*)((char*)olp-offsetof(iocp_wakeup, ol));
}

void
iocp_wakeup::clear_overlapped()
{
  ZeroMemory(&ol, sizeof(ol));  // much better than memset, right?
}


iocp_demuxer::iocp_demuxer()
  : iocp(NULL)
{
  // Create the completion port
  // not sure what first 3 args do, but by specifying INVALID_HANDLE_VALUE
  // for the first I think I can ignore the rest (apart from the last, numthreads)
  // I still have to create the threads, but only NumberOfConcurrentThreads
  // will wake up from GetQueuedCompletionStatus at a time. This looks to be
  // slightly elastic...
// NT 3.51 doesn't let you pass null filehandle, you've got to have a dummy
// socket. keep that in mind. see InitializeIOCP in IOCPServer.cpp example
// taken from codeproject. GetSystemInfo to find out num CPUs
  fprintf(stderr,"CreateIoCompletionPort with ONE WORKER THREAD\n");
  iocp = CreateIoCompletionPort(
    INVALID_HANDLE_VALUE,
    NULL,
    (ULONG_PTR)0,
    1       // 1 thread (zero means one for each CPU)
  );

  if(NULL == iocp)
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed to create completion port: %li\n", err);
    // zzz now...
    cleanup();
    throw -1;
  }

  // do this last
  if(iocp_thread.init(worker_thread_stub, this) == -1)
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed to create thread: %li\n", err);
    cleanup();
    throw -1;
  }
}

iocp_demuxer::~iocp_demuxer()
{
  cleanup();
}

void
iocp_demuxer::cleanup()
{
  fprintf(stderr,"iocp cleanup\n");

  iocp_thread.deinit();

  if(NULL != iocp && !CloseHandle(iocp))
  {
    DWORD err = GetLastError();
    // zzz do something with this
    fprintf(stderr,"failed cleanup iocp: %li\n", err);
  }
}

int
iocp_demuxer::associate_with_iocp(HANDLE obj, ULONG_PTR udat)
{
  // fprintf(stderr,"associating with iocp: %p, udat: %lx\n", obj, udat);

  // Any overlapped operations performed on the object will use the
  // completion port for notification. The 3rd param can be used to pass
  // per object context information. we'll just pass that back.
  if(CreateIoCompletionPort(obj, iocp, udat, 0) == NULL) {
    // adding the same obj twice without an intervening get completion
    // status wakup gets an error 87, ERROR_INVALID_PARAMETER
    fprintf(stderr,"CreateIoCompletionPort failed to register object: %li\n",
      GetLastError());
    return -1;
  }

  return 0;
}

// windows thread proc
// some code examples imply that it's risky to use the CRT (C runtime) here.
// maybe I should get rid of that printf... and use conio
DWORD
iocp_demuxer::worker_thread_stub(LPVOID lParam) {
  // will printf work here or do I have to use windows' conio? (WriteConsole)
  iocp_demuxer* demuxer = (iocp_demuxer*)lParam;

  fprintf(stderr,"how to allow thread cancel in windows?\n");
  while(1) {
    // I would call cancel here we were using pthreads here 
    demuxer->worker_thread_body();
  }
  return 0;   // I think this means good.
}


void
iocp_demuxer::worker_thread_body() {
  // with multiple threads, this will actually wake up the last to
  // block (lifo)

  // get context, call worker_thread 
  // need to be able to tell which thing completed, can have extra data
  // following some kind of struct
  // get this pointer

  // I guess to avoid swapping of thread context. By calling this on a given
  // completion port this thread is associated with it until exit or respec
  DWORD     nbytes;   // number of bytes in io transaction
  ULONG     udat;   // user data - not using this atm
  LPOVERLAPPED  olp;    // we get iocp_wakeup from this.

// If a socket handle associated with a completion port is closed,
// GetQueuedCompletionStatus returns ERROR_SUCCESS, with *lpOverlapped
// non-NULL and lpNumberOfBytes equal zero.
  
  int err = NO_ERROR;

  // No timeout. What does false mean? Eh. Could need a timeout to bring
  // the thread down.
  if(!GetQueuedCompletionStatus(iocp, &nbytes, &udat, &olp, INFINITE))
  {
    // That's strange - I sometimes get my ConnectEx errors popping
    // out here (ERROR_SEM_TIMEOUT=121, ERROR_CONNECTION_REFUSED=1225)
    // it looks like my args (overlapped, etc) are still filled out, so
    // I can still awake the sleeper
    err = GetLastError();   // doco says this & not WSALastError.

    // fprintf(stderr,"GetQueuedCompletionStatus returned false: %i\n", err);

    // let's see: yep - there's my overlapped
    // fprintf(stderr,"nbytes=%li, udat=%lx, io=%p\n", nbytes, udat, olp);
    // return;
  }
// An IOCP is a very general event mechanism. It tells you not only about
// the completion of reads & writes, but also of pretty much any asynchronous
// event's completion. It doesn't quite fit in with my select style interfaces.
// I've got general overlapped things completing here. I don't want them to
// know about demuxers & so forth so I'll have to know about them.

  // fprintf(stderr,"HOLEY! Woke up!\n");
  // fprintf(stderr,"nbytes=%li, udat=%lx, olp=%p, err=%i\n", nbytes, udat, olp, err);

  if(NULL == olp)
  {
    fprintf(stderr,"failed to get iocp_wakeup: %p (err: %i)\n", olp, err);
    return;
  }

  // tell someone that some overlapped op finished
  iocp_wakeup*  wakeup = iocp_wakeup::from_overlapped(olp);
  // passing olp may be redundant, seeing as it's contained in iocp_wakeup
  wakeup->iocp_op_finished(nbytes, udat, olp, err);
}


// thread stuff

win_thread::win_thread()
  : thread(NULL)
{
}

// this should be idempotent
void
win_thread::deinit()
{
  fprintf(stderr,"win_thread::deinit: how do I get my return status?\n");

  if(thread)
  {
    // Let's try and wait for the thread to finish, however first I have to
    // tell it to finish up.
    DWORD wait_res;
    // we'll wait as long as we have to for the thread to terminate
    wait_res = WaitForSingleObject(thread, INFINITE);

    // will this give me my return status? how do I get that?
    if(WAIT_FAILED == wait_res)
    {
      // something went wrong, have a cry
      fprintf(stderr,"thread wait failed (%li)\n", GetLastError());
    }

    // I've already tried waiting on the  thread's exit
    if(!CloseHandle(thread))
    {
      // have a cry
      fprintf(stderr,"failed to delete thread (%li)\n", GetLastError());
    }

    thread = NULL;
  } 
}

win_thread::~win_thread()
{
  fprintf(stderr,"win_thread dtor (killing thread!)\n");
  deinit();
}

// returns -1 on failure with error in GetLastError, 0 if all good.
int
win_thread::init(LPTHREAD_START_ROUTINE fn, LPVOID lParam)
{
  DWORD thread_id = 0;

  // thread id... (?)
  // I have no idea why I have to cast the fn to what it already is
  // absolutely none
  thread = (HANDLE)CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)fn, lParam, 0, &thread_id);  

  if(NULL == thread)
    return -1;

  return 0;     // success!
}

win_locker::win_locker(HANDLE mutex)
  : m(mutex)
{
  DWORD res = WaitForSingleObject(m, INFINITE);

  if(WAIT_OBJECT_0 != res)
  {
    fprintf(stderr,"Wait for mutex didn't do as expected, got: %li\n", res);
    throw res;
  }
}

win_locker::~win_locker()
{
  if(!ReleaseMutex(m))
    fprintf(stderr,"Error releasing mutex: %li\n", GetLastError());
}


typedef queue<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

win_queue::win_queue() 
  : member_lock(0), nz_elts_cond(0), lame_opaque(0)
{
  DWORD err;
  
  // allocate queue
  lame_opaque = new void_queue;

  // default security attributes, manual reset, non-signalled, nameless
  // signalled corresponds to num(elts) > 0
  nz_elts_cond = CreateEvent(NULL, TRUE, FALSE, NULL);
  
  if(NULL == nz_elts_cond)
  {
    err = GetLastError();
    fprintf(stderr,"CreateEvent returned: %li\n", err);
    cleanup();
    throw err;
  }

  // default security attr, not initiallly owned/locked, nameless.
  member_lock = CreateMutex(NULL, FALSE, NULL);

  if(NULL == member_lock)
  {
    err = GetLastError();
    fprintf(stderr,"CreateMutex returned: %li\n", err);
    cleanup();
    throw err;
  }
}

void
win_queue::cleanup()
{
  if(ELTQ) delete ELTQ;
  if(nz_elts_cond && !CloseHandle(nz_elts_cond))
    fprintf(stderr,"Failed to close event: %li\n", GetLastError());
  if(member_lock && !CloseHandle(member_lock))
    fprintf(stderr,"Failed to close mutex: %li\n", GetLastError());
}

win_queue::~win_queue()
{
  cleanup();
}

void
win_queue::enqueue(void* elt)
{
  // lock so our member data doesn't get bent out of shape
  win_locker    l(member_lock);

  // this is the simple case, add the elt, protected by lock
  // and signal suckas, who oughta recognize, but don't.
  ELTQ->push(elt);

  // we've got the mutex and we've just added an elt, therefore
  // we have > 0 elts. That sounds like a good enough reason to
  // put the condition into the signalled state. It may already
  // be in the signalled stated. Hope that's not a problem.
  // Might be an optimization to skip this if it became nonempty.
  if(!SetEvent(nz_elts_cond))
    fprintf(stderr,"Set condition failed: %li\n", GetLastError());
}

void*
win_queue::dequeue()
{
  void*     elt = NULL;

  do
  {
    // exclusively examine queue
    {
      win_locker    l(member_lock);

      if(!ELTQ->empty())
      {
        elt = ELTQ->front();
        ELTQ->pop();
        // if the queue is now empty, make condition reflect it
        // this failing will probably lock the app up...
        if(!ResetEvent(nz_elts_cond)) // non-signalled state
          fprintf(stderr,"Reset condition failed: %li\n", GetLastError());
        break;
      }
    }

    // otherwise there's nothing in the queue or something
    // may have turned up in the intervening moments
    DWORD   res;
    res = WaitForSingleObject(nz_elts_cond, INFINITE);

    if(WAIT_OBJECT_0 != res)
    {
      fprintf(stderr,"Wait on condition failed: %li\n", GetLastError());
      throw res;
    }

  } while(1);

  return elt;           // should never return NULL
}

// simple utility fn, shouldn't be here. creates listener on any interface.
// this could benifit from a SOCKET class. in failure returns INVALID_SOCKET
SOCKET
create_listener_socket(int* io_port, int backlog)
{
  fprintf(stderr,"creating_listener_socket\n");
  SOCKET        listener;

  // could use WSASocket, but these seem to be turning out overlapped anyway
  // at least after tangling with overlapped functions.
  // socket returns INVALID_SOCKET on failure.
  listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if (INVALID_SOCKET == listener)
  {
    fprintf(stderr,"listener create failed: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  SOCKADDR_IN   addr;

  // msdn code examples don't zero the sockaddr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(*io_port);

  // bind our name to the socket
  int         res;
  res = bind(listener, (LPSOCKADDR)&addr, sizeof(addr));

  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"bind() failed %i\n", WSAGetLastError());
    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }
    return INVALID_SOCKET;
  }

  // if user wanted port chosen tell them what it turned out to be
  if(0 == *io_port)
  {
    int namelen;

    if (getsockname(listener, (struct sockaddr *)&addr, &namelen) 
      == SOCKET_ERROR)
    {
      fprintf(stderr, "getsockname failed (%i)\n", WSAGetLastError());

      if(closesocket(listener) == SOCKET_ERROR)
      {
        fprintf(stderr,"closesocket failed on listener: %i\n",
          WSAGetLastError());
      }
      return INVALID_SOCKET;
    }

    *io_port = ntohs(addr.sin_port);
  }

  // Set the socket to listen
  res = listen(listener, backlog);
  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"listen() failed %i\n", WSAGetLastError());

    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }

    return INVALID_SOCKET;
  }

  return listener;
}

}}

@h=tangler('demux/demux_overlapped.cpp')
@select(h)
#include "demux_overlapped.hpp"
#include <stdio.h>      // fprintf

namespace flx { namespace demux {

// windows includes files here? vs will be fussy.

// AcceptEx

// return async finished flag (error flags - can be transmitted via class)
// AcceptEx is the way to get accept connections via the IOCP
bool
acceptex_control_block::start_overlapped()
{
  clear_overlapped();

// I've seen two examples get the pointer to AcceptEx, just in case it
// isn't implemented...
  // fprintf(stderr,"AcceptExing: listen backlog => can succeed immediately\n");

  // this is only set when acceptex receives data and returns immediately.
  // can't hurt to set it.
  DWORD nbytes = 0;
  BOOL  success;

  // note that in order to get the wakeup packet, the listener must
  // already be associated with the iocp. for future async io, the acceptor
  // must be associated too.
  success = AcceptEx(listener, acceptor,
    accept_buf,       // required - near/far address
    0,            // receive data size - don't yet want this
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    &nbytes,        // only set if fn completes. should be 0
    &ol);         // oblig. gets us back to the this ptr

  // if there is a backlog of connections, AcceptEx can return immediately
  if(success)
  {
    // must clear the wait
    fprintf(stderr,"WHOA! AcceptEx RETURNED SUCCESS IMMEDIATELY!\n");
    // handle the successful wakeup
    // complete_async_op(demux, drv, nbytes, NO_ERROR); 
    // I hope they don't want the udat pointer, because I
    // just made it up (0=NULL). Not using it anyway.
    iocp_op_finished(nbytes, 0, &ol, NO_ERROR); 
    return false;
  }
  else
  {
    int err = WSAGetLastError();
    // can also return WSACONNRESET, which isn't so bad
    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"AcceptEx returned ERROR_IO_PENDING - that's normal\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      fprintf(stderr,"AcceptEx failed: %i\n", err);
      fprintf(stderr,"returning true should wake thread to detect failure.\n");
      return true;    // have self woken
    }
  }
  return false;       // async not finished

}

// ConnectEx
#if 0
// apparently we're supposed to do this now to make the acceptee inherit
// the listener's state. it is currently in the default state
//err = setsockopt( sAcceptSocket, 
//  SOL_SOCKET, 
//  SO_UPDATE_ACCEPT_CONTEXT, 
//  (char *)&sListenSocket, 
//  sizeof(sListenSocket) );
#endif

// what a pain in the arse (zzz)
static int
GetConnectExAddr(SOCKET s, LPFN_CONNECTEX* conn_fn)
{
  *conn_fn = NULL;
  GUID      GuidConnectEx = WSAID_CONNECTEX;   
  DWORD     dwBytes;
  int       err;

  err = WSAIoctl(s,   // why do I need this?
    SIO_GET_EXTENSION_FUNCTION_POINTER,
    &GuidConnectEx,
    sizeof(GuidConnectEx),
    conn_fn,
    sizeof(*conn_fn),
    &dwBytes,
    NULL, NULL);    // no overlapped, no completion fun ptr
//  fprintf(stderr,"Get addr dwbytes: %li\n", dwBytes);
  return err;
}

// this is the weirdest. To use ConnectEx, the socket must be already bound.
// By trial and error, I found that it had to be bound to INADDR_ANY: 0.
// So strange. Apparently I don't have to do it again if I want to reuse.
static int
bind_socket(SOCKET s)
{
  SOCKADDR_IN   addr;

  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(0);

  return bind(s, (LPSOCKADDR)&addr, sizeof(addr));
}

bool
connectex_control_block::start_overlapped()
{
  clear_overlapped();

  DWORD bytes_sent = 0;   // we're not sending data on connect (yet)
  BOOL  success;

  LPFN_CONNECTEX  pfConnectEx;

  // unfortunate, will fix up later.
  // fprintf(stderr,"Getting ConnectEx address\n");

  // Turns out that ConnectEx isn't defined anywhere; I have to load its
  // addr via WSAIoctl
  // this is a bad way. make the driver cache it. why on earth is this
  // call per-socket? does it really need to be that way?
  if(GetConnectExAddr(s, &pfConnectEx) == SOCKET_ERROR)
  {
    fprintf(stderr,"GetConnectExAddr failed: %i\n", WSAGetLastError());
    return true;
  }

  // fprintf(stderr,"about to connectex to %s:%i, %i\n", addy, p, s);

  // this is so strange - I have to bind the socket to the localhost.
  // if I don't, ConnectEx returns EINVAL. in any case, I won't need
  // to do this again if I reuse this socket.
  if(bind_socket(s) == SOCKET_ERROR)
    fprintf(stderr,"ConnectEx bind failed: %i\n", WSAGetLastError());

  // I hope ConnectEx doesn't want this to hang around, because it's
  // going to drop off the stack after this.
  SOCKADDR_IN   addr;

  // some examples don't zero the addr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr(addy);
  addr.sin_port = htons(p);

  // in order to receive the wakeup packet, s must already be associated
  // with the iocp. this is best done at socket creation time. for these
  // sockets it's probably best to also bind them at the same time.
  // that requires "purposed" sockets (CreateConnectSocket?).
  // p.s. the default (waio_base) wakeup is doing fine for now.

  success = (*pfConnectEx)(s, // socket
    (LPSOCKADDR)&addr,    // connect address
    sizeof(addr),     // size thereof
    NULL,         // not sending any data yet, but we could
    0,            // ditto
    NULL,         // should be zero until this changes
    &ol);         // oblig. gets us back to the this ptr

// there's a caveat about the type of socket s becomes after ConnectEx.
// It's in some kind of default state and cannot be used with shutdown
// change it with setsockopt (?)
  if(success)
  {
    fprintf(stderr,"WHOA! ConnectEx RETURNED SUCCESS IMMEDIATELY!\n");
    // handle the successful wakeup. (udat=0, olp=&ol)
    iocp_op_finished(bytes_sent, 0, &ol, NO_ERROR); 
    return false;   // already woken up
  }
  else
  {
    int err = WSAGetLastError();

    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"ConnectEx pending...\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      // maybe store the error here. that could work for all
      // windows wakeups
      fprintf(stderr,"ConnectEx failed: %i\n", err);
      return true;    // have self woken
    }
  }
  return false;       // not finished
}

// TransmitFile

bool
transmitfile_control_block::start_overlapped()
{
  clear_overlapped();

  // 0 bytes => transmit entire file
  // the second zero means use the default chunk size
  // the NULL is for mem buffers to bookend the file with. nothing yet.
  // the final zero is for various flags, including a way of doing
  // DisconnectEx style socket reuse (more widely compatible?)

  // in order to receive the wakeup, s must already be associated with the
  // iocp. this is best done at socket creation time.
  if(TransmitFile(s, file, 0, 0, &ol, NULL, flags))
  {
    fprintf(stderr,"Transmit file succeeded immediately! waking...\n");
    return true;
  }
  else
  {
    DWORD err = WSAGetLastError();

    // will need to actually signal something
    // fprintf(stderr,"signal TransmitFile failure!\n");
    if(ERROR_IO_PENDING != err && WSA_IO_PENDING != err)
      fprintf(stderr,"genuine error from TransmitFile: %li\n", err);
  }
  return false;
}


// SOCKET io using WSASend and WSARecv

// windows style control blocks
wsasocketio_control_block::wsasocketio_control_block(SOCKET src, void* buf, int len, bool inread)
  : s(src), reading(inread)
{
  // pb is not so useful here. we only want to
  // know num bytes written/processed.
  pb.buffer = (char*)buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

bool
wsasocketio_control_block::start_overlapped()
{
  clear_overlapped();

  // num bytes received IF recv completes immediately.
  DWORD imm_bytes;
  int   recv_res;

  // set up the single wbuf, bearing in mind we may be part way.
  wbufs[0].len = pb.buffer_size - pb.bytes_written;
  wbufs[0].buf = pb.buffer + pb.bytes_written;

  // Ideally, we would like to be able to use MSG_WAITALL, which would
  // let us only get a completion packet when either all the data was
  // available or the connection had been closed or shutdown.
  // Unfortunately this is not possible for non-blocking sockets, so
  // we have to take whatever we get and then call WSARecv again.

  //#define MSG_WAITALL 0   // not defined in cygwin - apparently this
  //DWORD flags = MSG_WAITALL;

  // ah, unfortunately MSG_WAITALL is not supported for non blocking sockets
  // we'll just have to do it ourselves
  DWORD flags = MSG_PARTIAL;

  // completion routines! (unused)
  if(reading)
    recv_res = WSARecv(s, wbufs, NUM_WBUFS, &imm_bytes, &flags, &ol, NULL);
  else
    recv_res = WSASend(s, wbufs, NUM_WBUFS, &imm_bytes, flags, &ol, NULL);

  // don't know if I need to check non winsock errs

  switch(recv_res)
  {
    case 0:
    {
      // flags are updated to indicate what? if there was a callback, it
      // would be scheduled to be called when this thread is in the
      // waitable state, whatever that means.
      // fprintf(stderr,"WSA%s completed immediately!!! numbytes: %li, flags: %lx\n",
      //  (reading) ? "Recv" : "Send", imm_bytes, flags);

      // looks like we get the completion packet even if we do finish
      // immediately so let the iocp wake us.
      // this updates pb & wakes us up
      // complete_async_op(demux, drv, imm_bytes, NO_ERROR);

      return false;
    }
    break;
    case SOCKET_ERROR:
    {
      DWORD err = WSAGetLastError();

      // normal mode - wait for completion
      // fyi, xp pro seems to mostly give us ERROR_IO_PENDING
      if(ERROR_IO_PENDING == err || WSA_IO_PENDING == err)
      {
        // fprintf(stderr,"WSA%s pending completion (%li)\n",
        //  (reading) ? "Recv" : "Send", err);
        return false;     
      }

      fprintf(stderr,"WSARecv/Send returned SOCKET_ERR: %li\n", err);
      return true;    // assume it's bad and we won't get a wakeup
    }
    break;
    default:
    {
      fprintf(stderr,"WSARecv/Send returned other error: %i, GetLastError: %li\n",
        recv_res, GetLastError());
      return true;        // wake up
    }
    break;
  }

  return false;
}


// file io using ReadFile and WriteFile

winfileio_control_block::winfileio_control_block(HANDLE f, void* buf, int len, bool inread)
  : file(f), reading(inread)
{
  // pb is not so useful here. we only want to
  // know num bytes written/processed.
  pb.buffer = (char*)buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// if file is opened with FILE_FLAG_OVERLAPPED, we can do "immutable file ptr"
// ops & set the desired offset within the overlapped. can also stick an
// event to signal in there.
bool
winfileio_control_block::start_overlapped()
{
  fprintf(stderr,"trying out some read/write file\n");
  clear_overlapped();

  // DWORD  imm_bytes;
  BOOL  success;

  // don't need bytes read, written when we have an OVERLAPPED
  if(reading)
    // success = ReadFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = ReadFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
  else
    //success = WriteFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = WriteFile(file, pb.buffer, pb.buffer_size, NULL, &ol);

  // fprintf(stderr,"immbytes = %li\n", imm_bytes);

  if(!success)
  {
// this is probably going to be IOPENDING
    fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
      GetLastError());
    fprintf(stderr,"do I still get completion packet???\n");
    // assume not
    return true;      // ask for wakeup
  }

  return false;       // sleep on
}

}}

@h=tangler('demux/demux_overlapped.hpp')
@select(h)
#ifndef __DEMUX_OVERLAPPED__
#define __DEMUX_OVERLAPPED__

#include "demux_iocp_demuxer.hpp"
// visual studio is quite sensitve about how you do these includes.
// THIS is the way (WinSock2.h includes Windows.h? iocp_demuxer.h is.).
#include <WinSock2.h>
#include <MSWSock.h>  // AcceptEx, TF_REUSE_SOCKET, etc


namespace flx { namespace demux {

// rename these to control block something or other
// get rid of default constructors - faio can worry about that.

// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class FLX_RTL_EXTERN acceptex_control_block : public iocp_wakeup {
  enum { ACCEPTEX_ADDR_SIZE = sizeof(SOCKADDR_IN) + 16 };

  SOCKET  listener, acceptor;
  // there are two of these!
  char  accept_buf[2*ACCEPTEX_ADDR_SIZE];
public:

  virtual bool start_overlapped();

  acceptex_control_block(SOCKET l, SOCKET a) : listener(l), acceptor(a) { }
};

class FLX_RTL_EXTERN connectex_control_block : public iocp_wakeup
{
  SOCKET    s;          // previously unbound socket
  // can have buffer to be sent on connection
  const char* addy;       // ipv4 address
  int     p;          // port number
public:

  connectex_control_block(SOCKET soc, const char* addr, int port)
    : s(soc), addy(addr), p(port) {}

  virtual bool start_overlapped();
};

// TransmitFile here (requires file handle)
class FLX_RTL_EXTERN transmitfile_control_block : public iocp_wakeup {
  SOCKET  s;
  HANDLE  file;
  DWORD flags;                // for possible socket reuse.
public:

  transmitfile_control_block(SOCKET dst)      // for reuse of socket
    : s(dst), file(NULL), flags(TF_DISCONNECT | TF_REUSE_SOCKET) {}

  transmitfile_control_block(SOCKET dst, HANDLE src)  // actual transmitfile
    : s(dst), file(src), flags(0) {}

  virtual bool start_overlapped();
};


// handles both WSASend & WSARecv
class FLX_RTL_EXTERN wsasocketio_control_block : public iocp_wakeup {
protected:
  enum { NUM_WBUFS = 1 }; // just one for now, but can do scattered send/recvs
  WSABUF    wbufs[NUM_WBUFS];
  SOCKET    s;
  bool    reading;  // else use WSASend
public:
  sel_param pb;     // what you wanted & later, what you got

  wsasocketio_control_block(SOCKET src, void* buf, int len, bool read);

  virtual bool start_overlapped();

// have here?
//  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
//    LPOVERLAPPED olp, int err);
};

// looks a bit like wsasocketio_control_block (bad name, sends too)
class FLX_RTL_EXTERN winfileio_control_block : public iocp_wakeup {
  HANDLE    file;
  bool    reading;
public:
  sel_param pb;

  // offset?
  winfileio_control_block(HANDLE f, void* buf, int len, bool read);

  virtual bool start_overlapped();

  //virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
  //  LPOVERLAPPED olp, int err);
};

}}

#endif
@h=tangler('demux/demux_kqueue_demuxer.cpp')
@select(h)
// kqueue demuxer for bsd/os x
// N.B. calling close on a file descriptor will remove any kevents that
// reference that descriptor. that would explain remove complaining from
// time to time.
// try EV_EOF to pick up eofs, useful for async file io.

#include "demux_kqueue_demuxer.hpp"

#include <stdio.h>      // for perror
#include <unistd.h>     // for close

#include <sys/types.h>    // from the kqueue manpage
#include <sys/event.h>    // kernel events
#include <sys/socket.h>   // for send/recv

#include <sys/syscall.h>  // for non clib close

namespace flx { namespace demux {
kqueue_demuxer::kqueue_demuxer()
  : kq(-1)
{
  // Not that you care, but this event queue is not inherited by
  // forked children.
  kq = kqueue();
  if(-1 == kq)
  {
    perror("kqueue");
    cleanup();
    throw -1;
  }

  int res = init_pthread();
  if(res != 0)
  {
    cleanup();
    throw res;
  }
}

void
kqueue_demuxer::cleanup()
{
  deinit_pthread();

  //if(syscall(SYS_close, kq) == -1)
  // I don't seem to be able to close a kq. can't fstat it either
  if(-1 != kq && close(kq) == -1)
    perror("kqueue close");
}

kqueue_demuxer::~kqueue_demuxer()
{
  cleanup();
}


// Events of interest to us ERead, EWrite.
// ERead has fflags: NOTE_LOWAT, NOTE_EOF. ident is a descriptor (any?) 
int
kqueue_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
  if(read) return add_reading_socket(sv);
  else return add_writing_socket(sv);
}

int
kqueue_demuxer::add_reading_socket(socket_wakeup* sv)
{
  int s = sv->s;
  struct kevent read_evt;
  
  // this works just like select if the s is a listening socket
  // *except* works with all types of fds, including pipes, files & fifos
  // can set low water mark for reads with NOTE_LOWAT in fflags and size
  // in data. on return data contains number of bytes available to read
  // on return sets EV_EOF in flags if read dir socket has shutdown and
  // returns a possible socket err in fflags
  // should that be EV_ENABLE | EV_ADD. fflags zero cos I don't know what
  // to put there. pass pb in udata
  
  // adding EV_ONESHOT to save me removing on wakeup (a syscall).
  // I now require that during the evt be removed before wakeup fn.
  
  EV_SET(&read_evt, s, EVFILT_READ, EV_ADD | EV_ONESHOT, 0, 0, sv);
  // trying to detect when have reached eof with async file io using kq
  //EV_SET(&read_evt, s, EVFILT_READ, EV_ADD, | EV_ONESHOT NOTE_LOWAT, 16*1024, sv);

  // I think this is how you add an event
  if(kevent(kq, &read_evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent read add");
    return -1;
  }
  return 0;
}

int
kqueue_demuxer::add_writing_socket(socket_wakeup* sv)
{
  int s = sv->s;
  struct kevent write_evt;
  
  // for sockets the low water mark stuff is identical to EVFILT_READ
  // see the add_reading_socket notes for EV_ONESHOT reasoning
  EV_SET(&write_evt, s, EVFILT_WRITE, EV_ADD | EV_ONESHOT, 0, 0, sv);

  // this is how you add an event
  if(kevent(kq, &write_evt, 1, NULL, 0, NULL) < 0)
  {
    perror("kevent write add");
    return -1;
  }
  return 0;
}

// useful, but unused atm
void
kqueue_demuxer::remove_reading_fd(int s)
{
  struct kevent ev;
  
  EV_SET(&ev, s, EVFILT_READ, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &ev, 1, NULL, 0, NULL) < 0)
    perror("read evt remove");
}

void
kqueue_demuxer::remove_writing_fd(int s)
{
  struct kevent ev;

  EV_SET(&ev, s, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);
  if(kevent(kq, &ev, 1, NULL, 0, NULL) < 0)
    perror("write evt remove");
}

// from "advanced macos programming", on reading shutdown causes
// the EV_EOF flag to be set in the flags field and returns errno
// in the fflags field. There may still be pending data to read
// when EV_EOF is set. The data field says how many bytes available.
// for writing data says how much you can write. EV_EOF is set
// when the reader "disconnects". Says nothing about errno/fflags
// in this case.
/*
    fprintf(stderr,"readevt on %i, EOF = %s\n",
      s, (ev.flags & EV_EOF) ? "TRUE" : "FALSE");
 */

// do that thing where you get the events. can I get them one at a time?
// I bet I can.
void
kqueue_demuxer::thread_loop_body()
{
  // event seems to remain unless we remove it
  struct kevent ev;
  struct timespec timeout;
  int       nevts;

  timeout.tv_sec = 1;   // timeout every second
  timeout.tv_nsec = 0;  // 10^9 nanoseconds per second

  nevts = kevent(kq, NULL, 0, &ev, 1, &timeout);
  if(nevts <= 0)
  {
    // error, else timeout & return to allow cancel
    if(nevts < 0)
      perror("kevent event fetch");

    return;
  }

  // fprintf(stderr,"kqueue wakeup!\n");

  socket_wakeup*  sv = (socket_wakeup*)ev.udata;
  // int        s = ev.ident;

  if(ev.filter == EVFILT_READ)
  {
  // this capability is lost for the moment, as we have no way
  // of explaining it to felix. the event stuff isn't so good right now
/*
    // can chunk up on accepts. nice one kqueue
    if(NULL == sv)      // => listener
    {
      int backlog = (int)ev.data;   
      // fprintf(stderr,"kq listen backlog: %i\n", backlog);
      for(int i = 0; i < backlog; i++) handle_connection();
    }
    else
*/
    if(ev.flags & EV_EOF)
    {
      // errno in fflags!
      //fprintf(stderr,
      //  "got EV_EOF on read, %i bytes remain in buffer, errno=%i\n",
      //  (int)ev.data, ev.fflags);
    }
    // fprintf(stderr,"EVFILT_READ: got %i bytes coming\n", (int)ev.data);
    // remove_reading_fd(s);  // now useing EV_ONESHOT
    sv->wakeup(*this);
  }
  else if(ev.filter == EVFILT_WRITE)
  {
    // fprintf(stderr,"EVFILT_WRITE: can write (?) %i bytes\n", (int)ev.data);

    // using oneshot mode now.
    // remove_writing_fd(s);

    if(ev.flags & EV_EOF)
    {
      // errno in fflags? data should be zero bytes, right?
      // can't write anything
      //fprintf(stderr,
      //  "got EV_EOF on write, data bytes =%i (0?), errno/fflags?=%i\n",
      //  (int)ev.data, ev.fflags);
    }
    sv->wakeup(*this);
  }
  else
  {
    fprintf(stderr,"unsolicited event from kqueue...\n");
  }
}
}}

@h=tangler('demux/demux_mutexlite.cpp')
@select(h)
#include "demux_mutexlite.hpp"
#include <stdio.h>        // printf debugging

namespace flx { namespace demux {
class auto_attr
{
  pthread_mutexattr_t* a;
public:

  auto_attr(pthread_mutexattr_t* attr) : a(attr) {}
  ~auto_attr()
  {
    int res = pthread_mutexattr_destroy(a);
    if(0 != res)
      fprintf(stderr,"pthread_mutexattr_destroy failed: %i\n", res);
  }
};

pmut::pmut(bool recursive)
{
  pthread_mutexattr_t attr;
  int res;

  res = pthread_mutexattr_init(&attr);  // default attrs

  if(0 != res) throw res;

  auto_attr aa(&attr);          // cleans up always

  if(recursive)
  {
    res = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE);
    if(0 != res)
    {
      fprintf(stderr,"phtread_mutexattr_settype failed: %i\n", res);
      throw res;
    }
  }

  res = pthread_mutex_init(&m, &attr);
  if(res != 0) throw res;
}

pmut::~pmut()
{
  int res;
  // fprintf(stderr,"MUTEX DESTROY!!!\n");
  // fflush(stdout);
  res = pthread_mutex_destroy(&m);
  if(0 != res) fprintf(stderr,"mutex_destroy failed: %i\n", res);
}

void
pmut::lock()
{
  int res = pthread_mutex_lock(&m);
if(res != 0) fprintf(stderr,"lockres: %i\n", res);
  if(res != 0) throw res;
}

void
pmut::unlock()
{
  int res = pthread_mutex_unlock(&m);
  if(res != 0) throw res; 
}

// auto pthread

int 
apthread::init(void* (*start)(void*), void* udat)
{
  // fprintf(stderr,"apthread::init(this=%p, fn=%p, udat=%p)\n",
  //  this, start, udat);

  // default attrs. hope they're good
  int res = pthread_create(&thr, NULL, start, udat);
  if(0 == res) inited = true;   // success!
  return res;
}

void
apthread::deinit()
{
  fprintf(stderr,"apthread::deinit(this=%p, inited=%i)\n", this, inited);

  if(!inited) return;
// What if I cancel while someone (select thread) holds the mutex.
// I think I need to push cleanup stuff... wait, cancel won't happen
// in the mutex. If others start using this pre-emptively then it could
// happen. We've got another problem then, as the object is being
// destructed. Should I go for the lock? What to do? HELP!
// do experiment...
  // cancel thread, then "join" to wait for it to exit. if we summarily
  // killed the thread, we could kill it during something important,
  // like  a mutex or select op, screwing up global state.
  // we shouldn't have to wait long
  // ignoring errors, thread not found seems to be the worst

  int   res;

  //res = cancel();             // send cancel msg
  //fprintf(stderr,"cancel res: %i, joining...\n", res);


  res = pthread_join(thr, NULL);      // wait for cancel pt, ignor res
  fprintf(stderr,"join res: %i\n", res);

  // is that all you have to do to free up a pthread?

  inited = false;
}

// not using this - cancellation is bad. I now prefer to convince the thread
// to exit through nonviolent methods. I'd like to use pthread_setcancelstate
// + PTHREAD_CANCEL_DISABLE but that needs to be done from each thread which
// would require them an annoying thunk. Not using pthread_cancel should
// be enough.
#if 0
// set thread cancel flag
int
apthread::cancel()
{
  return pthread_cancel(thr);       // send cancel msg
}
#endif

apthread::~apthread()
{
  deinit();
}
}}

@h=tangler('demux/demux_pfileio.cpp')
@select(h)
#include <stdio.h>    // printf
#include <errno.h>    // errno
#include "demux_pfileio.hpp"

// blocking reads & writes that use a worker fifo. users overload
// finished flag to implement wakeup

// if we could group the requests, we could do a scattered read
// or we could do single reads if the requests were of a similar
// nature, i.e. the whole file, of popular files.

// for pwrite/pread, I'm supposed to include the following three (osx man page)
// they don't appear to be necessary, but let's play it safe
#include <sys/types.h>
#include <sys/uio.h>
#include <unistd.h>

namespace flx { namespace demux {
// fileio_request stuff follows

// read or write in a blocking fashion. I like the idea of using pread
// which doesn't change the file pointer. this could allow reuse of the same
// file descriptor & block caching

fileio_request::fileio_request(int f, char* buf, long len, long off, bool rd)
  : offset(off), fd(f), read_flag(rd), err(0)
{
  pb.buffer = buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// synchronously process read/write
void
fileio_request::doit()
{
  // fprintf(stderr,"faio about to try to %s %i bytes from fd=%i\n",
  //  (read_flag) ? "read" : "write", pb.buffer_size, fd);

// switching off (explicit) seeks for now because I'm not using them
// in the flx code & I'm not passing around enough info (just the fd)
  ssize_t res;

  if(read_flag)
  {
    // res = pread(fd, pb.buffer, pb.buffer_size, offset);
    res = read(fd, pb.buffer, pb.buffer_size);
  }
  else
  {
    // res = pwrite(fd, pb.buffer, pb.buffer_size, offset);
    res = write(fd, pb.buffer, pb.buffer_size);
  }
  
  // zero return value indicates end of file. that should just work.
  if(-1 == res)
  {
    err = errno;    // grab errno
    fprintf(stderr,"faio error: %i\n", err);
  }
  else
  {
    // fprintf(stderr,"faio %s %i bytes\n", (read_flag) ? "read" : "write", res);
    pb.bytes_written = res;
  }
}
}}

@h=tangler('demux/demux_posix_demuxer.cpp')
@select(h)
#include "demux_posix_demuxer.hpp"
#include "demux_sockety.hpp"

#include <stdio.h>        // "printf"
#include <assert.h>       // assert
#include <string.h>       // strerror
#include <unistd.h>       // close

#include <sys/types.h>      // send/recv
#include <sys/socket.h>

#include <errno.h>

namespace flx { namespace demux {

@tangle("typedef " + FLX_SOCKLEN_T + " FLX_SOCKLEN_T;")

int
posix_demuxer::init_pthread() {
  return evt_pthr.init(thread_start, this);
}

// this MUST be called by sub classes in their destructors.
// what cack-handed object orientedism
// need to wake up event sleep for exiting. many of the event sources
// have a way to do this, or at least a time out after which we can
// test cancel state (pthread_testcancel)
void
posix_demuxer::deinit_pthread()
{
  evt_pthr.deinit();
}

// delete thread
posix_demuxer::~posix_demuxer()
{
}

// static pthread callback bootstrap
void*
posix_demuxer::thread_start(void* data)
{
  // why's this called sel?
  posix_demuxer*  sel = (posix_demuxer*)data;   // get this ptr
  while(1)
  {
    // to not screw up state/leak mutexes, we need to provide
    // kill/cancel points. This is one.
    pthread_testcancel();           // allow cancellability.
    sel->thread_loop_body();          // one select
  }
  return 0;                   // (exit status) never happens
}

bool
posix_demuxer::socket_recv(int s, sel_param* pb)
{
  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;
  
  // if this were read then this fn would work with non-sockets
  nbytes = recv(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written, 0);

  if(nbytes <= 0)
  {
    if(nbytes == 0)
    {
      return true;        // connection closed
    }
    else
    {
      perror("recv");       // can get reset connection here
      return true;        // so say closed, yeah?
    }
  }
  else
  {
    // got some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

bool
posix_demuxer::socket_send(int s, sel_param* pb)
{
  // kqueue (and some of the other ones) can let you know know how much
  // to write... imagine that!

  // why do I have the zero buffer size?
  assert(pb->buffer_size > pb->bytes_written || 0 == pb->buffer_size);

  ssize_t     nbytes;

  nbytes = send(s, pb->buffer + pb->bytes_written,
    pb->buffer_size - pb->bytes_written, 0);

  // similar story here, with send vs write?

  // what's the story with zero? Is that allowed or does it signal
  // that the connection closed?
  if(-1 == nbytes)
  {
    perror("send");
    return true;          // I guess the connection closed
  }
  else
  {
    // sent some data
    pb->bytes_written += nbytes;
  }
  return false;           // connection didn't close
}

#if 0
  //nbytes = recv(s, pb->buffer + pb->bytes_written,
  //      pb->buffer_size - pb->bytes_written, 0);

  // select and kqueue know when non socket fds have data.
  // recv only works with sockets, but read works with both files
  // and sockets and who knows what else. is there any disadvantage
  // to using read instead? apart from losing flags arg?
  // does read get the same 0 bytes = close behaviour
  nbytes = read(s, pb->buffer + pb->bytes_written,
        pb->buffer_size - pb->bytes_written);
#endif

// handy posix control blocks for accept, connect.

int
accept_control_block::start(posix_demuxer& demux)
{
  // add listener to demuxer as reading socket - see man 2 accept
  // returns 0 on success, -1 on failure. not sure how to communicate
  // the error.
    return demux.add_socket_wakeup(this, true);
}

void
accept_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"accept_control_block woke up\n");

  // we can now accept without blocking
  // s is the listener, ambiguously named in parent socket_wakeup class
  accepted = nice_accept(s, &socket_err);

  if(accepted == -1)
  {
    fprintf(stderr, "nice_accept failed, err (%i)\n", socket_err);
  }
}

// returns -1 on failure, 0 on success. on success the call is finished
// (and so no wakeup) if socket_err == 0.
int
connect_control_block::start(posix_demuxer& demux)
{
  // fprintf(stderr,"async connect start\n");

  int finished;

  // returns either finished and err, or not finished
  // and (no err || EINPROGRESS)
  s = async_connect(addy, p, &finished, &socket_err);

  // fprintf(stderr,"async_connect returned s: %i, finished: %i\n",
  //    sv.s, finished);

  if(-1 == s)   // failed!
  {
    fprintf(stderr,"async_connect failed (%i)\n", socket_err);
    return -1;  // error in socket_err
  }

  if(finished)
  {
    // this actually happens on solaris when connecting to localhost!
    fprintf(stderr,"async_connect finished immediately, waking\n");
    fprintf(stderr, "No wakeup coming...\n");
    // this does not indicate an error, but that there is no wakeup
    // coming. this could be done by a wakeup, all that happens is
    // getsockopt is called to check the socket's error state.
    return -1;          
  }

  // fprintf(stderr,"connect_request didn't finish immediatly, sleeping\n");

  // add to demuxer as writing socket - see man 2 connect
  // how do they get the error?
    return demux.add_socket_wakeup(this, false);
}

void
connect_control_block::wakeup(posix_demuxer& demux)
{
  // fprintf(stderr,"connect woke up\n");
  // this is how we check the success of async socket calls
  // god knows what the level should be. socket level seems sensible.
  FLX_SOCKLEN_T  len = sizeof(socket_err);
  int res = getsockopt(s, SOL_SOCKET, SO_ERROR, &socket_err, &len);

  // I've heard of impls of getsockopt(SO_ERROR) acting as they they
  // had the socket error (i.e. returning -1 and the sock err in errno)
  if(-1 == res)
  {
    socket_err = errno;   // don't think its ours
    fprintf(stderr, "getsockopt failed - is that our error? (%i)\n",
      socket_err);
  }

  // failed, throw away socket
  if(0 != socket_err)
  {
    fprintf(stderr,"async connect error: %s (%i), closing\n",
      strerror(socket_err), socket_err);
    // we created the connect socket, so we close it too.
    if(close(s) != 0)
      perror("async socket close");

    s = -1;   // the result
  }

  // resulting connected socket in s
}
}}

@h=tangler('demux/demux_posix_queue.cpp')
@select(h)
#include <pthread.h>
#include "demux_posix_queue.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror

using namespace std;

namespace flx { namespace demux {
typedef queue<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

posix_queue::posix_queue()
  : member_lock(false)      // shouldn't need to be recursive
{
  lame_opaque = new void_queue;
  int res = pthread_cond_init(&nz_elts_cond, NULL);

  if(0 != res)
  {
    delete ELTQ;
    throw res;
  }
}

posix_queue::~posix_queue()
{
  int res = pthread_cond_destroy(&nz_elts_cond);
  if(0 != res)
    fprintf(stderr,"pthread_cond_destroy failed: %i (%s)\n",
      res, strerror(res));
  delete ELTQ;
}

void
posix_queue::enqueue(void* elt)
{
  // lock so our member data doesn't get bent out of shape
  pmut_locker   l(member_lock);
  // this is the simple case, add the elt, protected by lock
  // and signal suckas, who oughta recognize, but don't.
  ELTQ->push(elt);

  // we've just added one elt, therefore we have > 0 elts
  // a signal should do just fine here - I don't think I need
  // broadcast unless I were adding more than one item in a go.
  // if there were already elts in the queue there wouldn't be
  // threads waiting on the signal and if there were no elts then
  // there would be no point waking up more than one thread now.
  // right? 
  int       res;
  res = pthread_cond_signal(&nz_elts_cond);
  if(0 != res)
    fprintf(stderr,"pthread_cond_signal failed %i\n", res);
}

void*
posix_queue::dequeue()
{
  // protect member data
  pmut_locker   l(member_lock);
  void*     elt = NULL;

  // sleep until something is there
  do
  {
    if(!ELTQ->empty())
    {
      elt = ELTQ->front();
      ELTQ->pop();
      break;
    }

    // otherwise queue empty, wait on condition
    int res;
    // wait on elt added condition signal. mutex is unlocked on
    // on wait and relocked on wake.
    res = pthread_cond_wait(&nz_elts_cond, &member_lock.m);
    if(res != 0)
      fprintf(stderr,"pthread_cond_wait nonzero elts failed: %i\n", res);

  } while(1);

  return elt;           // should never return NULL
}
}}

@h=tangler('demux/demux_select_demuxer.cpp')
@select(h)
// P.S. for current impl don't need the pthreads. WHOO!!!

// A very light wrapper around select, that allows the addition
// of new sockets and returns status in a queue.
// on the powerbook with 10.3, FD_SETSIZE is 1024, that means
// max 1024 sockets. That's kind of lame. See IO completion ports
// on NT for a better solution.

// see epoll, kqueue & IOCPs

// so this is asynchronously watching sockets and doing stuff. I could
// pass the stuff off to another thread, which could then do things, like
// process, run a flx thread or whatever, but I don't want to lose the
// "not polling" nature of this. If I post this stuff to a queue, how
// do I get the client to wake up and process that stuff? Is that what
// condition variables are for? Put the decision off and give it a
// callback
// If I only read some of the available data will the next select return
// immediately? It probably ought to.

#include <assert.h>

#include <sys/types.h>
#include <sys/socket.h>

#include "demux_select_demuxer.hpp"

#include <string.h>       // for memset

#include <stdio.h>        // for printf debug
#include <stdlib.h>
namespace flx { namespace demux {

select_demuxer::select_demuxer()
  : ham_fist(true)
{
  // clear these guys. after the thread starts, access to them will have
  // to be via the lock
  FD_ZERO(&master_read_set);
  FD_ZERO(&master_write_set);
  fdmax = 0;        // corresponds to stdin, which we're not using

  // clear this possibly quite large list
  memset(read_svs, 0, sizeof(read_svs));
  memset(write_svs, 0, sizeof(write_svs));
  
  int res = init_pthread();
  
  if(res != 0) throw res;
}

// one select, must not block indefinitely, so choose a timeslice
// or find a way to make it wake on command, like a dummy socket
void
select_demuxer::thread_loop_body()
{
  // make a copy that select can modify
// race condition - master_*_set modified under lock
  fd_set      read_set = master_read_set;
  fd_set      write_set = master_write_set;
  
  // this is depending on my fake socket to wakeup. perhaps use the timer
  // for now.
  // timing out every 100th of a second. seems reasonable.
  struct timeval  tv;
  tv.tv_sec = 0;
  tv.tv_usec = 1000000/100;
  
  // the return value here actually has significance
  // sometimes I have to try again, or weed out bad fds.
  if(select(fdmax+1, &read_set, &write_set, NULL, &tv) == -1)
  {
    // not the ideal reaction. I think this is where I weed out
    // the bad socket(s). would need error set.
    perror("select");
    exit(1);      // that's not a nice thing for a library to do.
  }

  // about to read and write master_set and pending reads.
  // lock until end of function. pretty coarse.
  // the simple choice of allowing the handle_read/write has meant
  // that I have to use a recursive lock to protect my member vars
  pmut_locker     l(ham_fist);

  // might be worth keeping a low water mark as well.
  // I guess this is why select sucks. On osx we can only watch
  // about 1024 sockets. That sucks too.
  for(int i = 0; i <= fdmax; i++)
  {
    if(!FD_ISSET(i, &read_set)) continue;

    // we now always remove before giving wakeup, which can
    // always add it back if need be.
    socket_wakeup*  sv = read_svs[i];
    remove_reading_fd(i);
    sv->wakeup(*this);
  }

  // should combine loops. very heavy indentation
  for(int i = 0; i <= fdmax; i++)
  {
    if(!FD_ISSET(i, &write_set)) continue;

    socket_wakeup*  sv = write_svs[i];
    remove_writing_fd(i);
    sv->wakeup(*this);
  }
}

int
select_demuxer::add_socket_wakeup(socket_wakeup* sv, bool read)
{
// This isn't right: there are race conditions with the select thread
// and the new socket isn't selected until select times out
// (currently 1/100 of a second). This could explain the poor performance
// seen when using this demuxer.
  int s = sv->s;

  if(s < 0 || s >= FD_SETSIZE) return -1;   // weakness of select

  pmut_locker     l(ham_fist);      // lock it all off

  if(read)
  {
    FD_SET(s, &master_read_set);
    assert(read_svs[s] == NULL);      // sanity check
    read_svs[s] = sv;
  }
  else
  {
    FD_SET(s, &master_write_set);
    assert(write_svs[s] == NULL);     // sanity check
    write_svs[s] = sv;
  }

// fdmax used without locking in select thread
  if(s > fdmax) fdmax = s;          // update highwater mark

  return 0;
}

void
select_demuxer::remove_reading_fd(int s)
{
  assert(s >= 0 && s < FD_SETSIZE);

  pmut_locker     l(ham_fist);      // lock it all off

  FD_CLR(s, &master_read_set);        // we're finished with this
  read_svs[s] = NULL;
}

void
select_demuxer::remove_writing_fd(int s)
{
  assert(s >= 0 && s < FD_SETSIZE);

  pmut_locker     l(ham_fist);      // lock it all off

  FD_CLR(s, &master_write_set);       // we're finished with this
  write_svs[s] = NULL;
}
}}

@h=tangler('demux/demux_work_fifo.cpp')
@select(h)
#include <stdio.h>    // printf
#include "demux_work_fifo.hpp"
namespace flx { namespace demux {

// a fifo of tasks & a thread (threads?) to serve them.
// users overload finished function to implement wakeup

worker_fifo::worker_fifo()
{
  fprintf(stderr,"async worker fifo io module constructor\n");
  // fifo already inited and ready to go, so get pthread going
#ifdef _WIN32
  int res = thread.init((LPTHREAD_START_ROUTINE)thread_start, this);
#else
  int res = thread.init(thread_start, this);
#endif

  if(0 != res) throw res;

// do it properly or not at all
#if 0
  fprintf(stderr,"hey, trying multi threads here (leakingly)\n");
  for(int i = 1; i < 1; i++)
  {
    fprintf(stderr,"extra io thread\n");
    apthread* pt = new apthread;
    res = pt->init(thread_start, this);
    if(0 != res) throw res;
  }
#endif
}

// To get rid of thread cancel we could have a simple finished flag
// that's set by the class and set by the thread. Since both are executed
// synchronously w.r.t the same thread, we wouldn't need to protect anything
// that won't work if we have multiple worker threads, however.

// better idea - add a null task to front of queue to mean quit. queue
// is already threadsafe. If there are n worker threads, add n nulls.

// stopping the worker thread turns out to be trickier than it sounds
// because it's hard to wake up on an empty queue. 
void
worker_fifo::stop_worker_thread()
{
  add_worker_task(NULL);    // thread safe takedown.
                // for n worker threads add n times
  thread.deinit();      // deinit waits for thread to exit.
                // which should happen eventually
}

worker_fifo::~worker_fifo()
{
  // the thread must be brought down before the objects it
  // uses are destructed. lets hope anyone deriving from this
  // class knows that and let them call this function in their
  // destructor.
  stop_worker_thread();
}

// io thread entry point, passed this
void*
worker_fifo::thread_start(void* udat)
{ 
  worker_fifo*  fio = (worker_fifo*)udat;
  fprintf(stderr,"posix worker_fifo thread started! this=%p\n", fio);

  while(fio->thread_loop_body()) ;

  return 0;             // return status.
}

// dequeues one task and executes it, calling finished hook. interprest
// null task as a request to exit.
bool
worker_fifo::thread_loop_body()
{
  worker_task*  req = (worker_task*)fifo.dequeue();
  // fprintf(stderr,"dequeued worker_task (%p)\n", req);

  if(!req) return false;        // finished, got quit signal

  req->doit();
  req->finished();          // finish hook. I find this handy

  return true;            // keep going
}

void
worker_fifo::add_worker_task(worker_task* task)
{
  fifo.enqueue(task);         // don't worry, fifo is re-entrant
}

}}

@h=tangler('demux/demux_sockety.cpp')
@select(h)
#include "demux_sockety.hpp" /* for this stuff */

#include <stdio.h>        /* for perror */
#include <fcntl.h>        /* for making non blocking sockets */
#include <netinet/in.h>     /* for sockaddr_in */
#include <arpa/inet.h>      /* for inet_addr */
#include <unistd.h>       /* for close */

#include <sys/types.h>      /* for accept */
#include <sys/socket.h>
#include <sys/errno.h>      /* EINPROGRESS */

#include <errno.h>        /* errno */

#include <string.h>       /* for memset */
namespace flx { namespace demux {

@tangle("typedef " + FLX_SOCKLEN_T + " FLX_SOCKLEN_T;")

/*
 returns a socket ready for listening (AF_INET, SOCK_STREAM for now).
 0 in for port means let kernel decide, result in *io_port
 portable, can be factored out. listens on all NICs.
 returns -1 on failure, sometimes eats errno.
 p.s. sets SO_REUSEADDR.
*/
int
create_listener_socket(int* io_port, int q_len)
{
  int         listener;
  int         yes = 1;  /* for address reuse */

  if((listener = socket(AF_INET, SOCK_STREAM, 0)) == -1)
    return -1;

  /* get rid of those *pesky* "address already in use" errors. */
  /* for when you don't cleanly shutdown the server */
  if(setsockopt(listener, SOL_SOCKET, SO_REUSEADDR, &yes, sizeof(yes)) == -1)
    goto listener_fail;

  /* bind listener to local interface (ANY) */
  if(bind_sock(listener, io_port) == -1)
    goto listener_fail;

  /* set listen queue length for socket */
  if(listen(listener, q_len) == -1)
    goto listener_fail;

  return listener;

listener_fail:
  perror("create_listener_socket"); /* eats errno! */
  if(close(listener) == -1)
    perror("create_listener_socket close");
  return -1;
}

/* create listener, make it non-blocking */
int
create_async_listener(int* io_port, int q_len)
{
  int   listener;

  listener = create_listener_socket(io_port, q_len);

  if(-1 == listener) return -1;

  if(make_nonblock(listener) == -1)
  {
    if(close(listener) != 0)
      perror("create_async_listener close");
    return -1;
  }

  return listener;
}

/* ps, sets resulting socket to non-block. some people would say that */
/* this WASN'T nice, so change the name some time. returns socket or -1 */
/* on failure, with *err containing the error code */
int
nice_accept(int listener, int* err)
{
  struct sockaddr_in  remoteaddr;
  /*socklen_t     addrlen = sizeof(remoteaddr);*/
  /* os x 10.2.8 doesn't have socklen_t. will this work elsewhere? */
  /* 10.4 (gcc 4.0) complains about signedeness, so now unsigned */
  FLX_SOCKLEN_T addrlen = sizeof(remoteaddr);
  int         newfd;
  
  newfd = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);
  if(-1 == newfd) {
    *err = errno;
    return -1;
  }
  else
  {
    /*I think 0's the result I want*/
    if(make_nonblock(newfd) == -1)
    {
      *err = errno;

      /* bizarre case, note that close's errno is lost */
      if(close(newfd) == -1) 
        perror("nice_accept close");
      newfd = -1;
    }
  }
  return newfd;
}

/* call this connect_ipv4? would its interface work for ipv6? */
/* this connect can be either asynchronous or synchronous, */
/* depending on whether or not the socket is non blocking */
/* returns -1 with err in errno on failure */
int
connect_sock(int s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;     /* host byte order */
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

/* bind s to local address with given port number, or zero to let OS */
/* choose. can you bind to non-local addresses? not sure, but you might */
/* like to choose which local interface... (ADD OTHER INTERFACES HERE) */
/* returns -1 on failure with error code in errno */
int
bind_sock(int s, int* io_port)
{
  struct sockaddr_in  addr;
  FLX_SOCKLEN_T namelen = sizeof(addr);

  memset(&addr, 0, sizeof(addr));
  addr.sin_family = AF_INET;      /* host byte order */
  /* make the NIC an argument */
  addr.sin_addr.s_addr = htonl(INADDR_ANY); /* allow multihomed */
  addr.sin_port = htons(*io_port);

  /* bind to port */
  if (bind(s, (struct sockaddr *)&addr, namelen) < 0)
  {
    return -1;
  }

  /* we don't need to do this when the port was specified */
  if(0 == *io_port)
  {
    /* Find out what port number was chosen */
    if (getsockname(s, (struct sockaddr *)&addr, &namelen) < 0)
    {
      return -1;
    }

    *io_port = ntohs(addr.sin_port);
  }

  return 0; /* success! */
}

/* simple wrapper for fcntl for those too lazy to look it up */
/* returns -1 on failure with errno set or non -1  otherwise */
int
make_nonblock(int s)
{
  return fcntl(s, F_SETFL, O_NONBLOCK);
}

/* also make non-blocking AFTER connect, that is, */
/* this is a synchronous connect */
/* is eating errno, fix */
int
nice_connect(const char* addr, int port)
{
  int     s;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != -1
    && connect_sock(s, addr, port) == 0
    && make_nonblock(s) != -1)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  perror("nice_connect");

  if(-1 != s && close(s) != 0)
    perror("nice close");

  return -1;
}

/* makes the socket non-blocking BEFORE connect, returns result */
/* from which can be determined if it finished immediately */
/* returns the socket & finished flag or -1 on failure, with the */
/* error returned in *err */
int
async_connect(const char* addr, int port, int* finished, int* err)
{
  int     s = -1;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != -1 && make_nonblock(s) != -1)
  {
    /* no error we now have s, a non-blocking socket */
    if(connect_sock(s, addr, port) == 0)
    {
      *err = 0;         /* no error */
      *finished = 1;        /* finished */
      return s;
    }

    *err = errno;         /* connect failed or in-progress */

    if(EINPROGRESS == *err)
    {
      *finished = 0;        /* not finished, in progress */
      return s;
    }
    /* some other failure, fall through and clean up */
  }

  /* hope you can read same errno twice in threaded apps! */
  *err = errno;           /* pass back error */

  if(-1 != s && close(s) != 0)    /* we lose the close error */
    perror("async_connect close");

  *finished = 1;            /* for completeness */
  return -1;
}
}}

@h=tangler('demux/demux_posix_timer_queue.cpp')
@select(h)
#include "demux_posix_timer_queue.hpp"

// a prio queue that executes tasks in a given order
// factor out prio_queue? could be like queue.

// try to make work like the worker thread thing, fix it do so?.
// remove time from sleep task...

#include <queue>    // stl seems to have a prio_queue
#include <sys/time.h> // gettimeofday for calculating "now"
// #include <errno.h> // ETIMEDOUT - don't actually need to know this

namespace flx { namespace demux {

using namespace std;

// it could happen!
// factor
class future_evt
{
public:
  timespec  when; 
  sleep_task* task;

  // ignore the direction, just trying to sort with smallest first
  bool operator<(const future_evt& rhs) const
  {
    if(when.tv_sec != rhs.when.tv_sec)  // precedence to more significant
      return when.tv_sec > rhs.when.tv_sec;
    else                // else check the less significant
      return when.tv_nsec > rhs.when.tv_nsec;
  }
};

typedef priority_queue<future_evt> void_prio_queue;
#define PRIOQ ((void_prio_queue*)opaque_prio_queue)

int
posix_timer_queue::setup_sleep_cond()
{
  fprintf(stderr,"setup_sleep_cond\n");
  int res;
  res = pthread_cond_init(&sleep_cond, NULL);

  if(0 != res)
    fprintf(stderr,"pthread_cond_init failed: %i\n", res);

  return res;
}

void
posix_timer_queue::takedown_sleep_cond()
{
  fprintf(stderr,"sleep cond taking down\n");
  int res;
  res = pthread_cond_destroy(&sleep_cond);
  if(0 != res) fprintf(stderr,"condition destroy failed: %i\n", res);
}

posix_timer_queue::posix_timer_queue()
  : lock(false)     // lock shouldn't need to be recursive
{
  // fprintf(stderr,"posix_timer_queue ctor\n");

  // if this throws, no harm done
  opaque_prio_queue = new void_prio_queue;    // a.k.a. PRIOQ

  int res;
  res = setup_sleep_cond();
  if(0 != res)
  {
      delete PRIOQ;                           // cleanup, carry on
      throw res;
  }

  // do the thread last because it uses all of the above
  fprintf(stderr,"initing sleep thread\n");

  res = sleep_thread.init(thread_start, this);

  if(0 != res)
  {
      delete PRIOQ;
      takedown_sleep_cond();
      throw res;
  }
  // not good to do much else after this as the thread is running
}

posix_timer_queue::~posix_timer_queue()
{
  // the sleep_thread uses the prioq, so we must explicitly shut it
  // down now, before we delete the prioq. left to its own devices,
  // c++ destructs it at the end of this destructor.

  // take down the thread first because it uses all the other stuff.
  // I actually don't need to do anything special to bring the thread
  // down because all pthread_cond_*wait* are cancel aware. Or so they
  // should be. As far as I can tell only the 64bit osx10.4.2 is, so
  // for now the explicit cancel + wakeup followed by explicit 
  // cancel test stays.

  // fprintf(stderr, "asking timer thread to quit\n");
  add_sleep_request(NULL, 0.0); // super secret quit thread quit request
  wakeup_thread();        // wakeup, cause to goto a cancel pt

  sleep_thread.deinit();      // will join
  fprintf(stderr,"about to delete PRIOQ\n");
  delete PRIOQ;

  takedown_sleep_cond();
}

static void
get_now(timespec* now)
{
  struct timeval tp;

  if(gettimeofday(&tp, NULL) == -1)
    perror("gettimeofday");

  // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
  now->tv_sec = tp.tv_sec;
  now->tv_nsec = tp.tv_usec*1000;   // fits!

  // fprintf(stderr,"get_now = %li, %li\n", now->tv_sec, now->tv_nsec);
}

// offset delta from "now" and store in "when"
static void
calc_when(timespec* when, double delta)
{
// how to use the posix abstime versions of timed waits? what kind of absolute
// is abstime? pthread_get_expiration_np looks useful, but it too is np.
// abstime is apparently in seconds since the Epoch, UTC.
// To get now there's clock_gettime (not portable) or gettimeofday with
// null timezone.

  const long MIL = 1000000;   // one million
  const long BIL = MIL*1000;    // one billion

  timespec  now;
  get_now(&now);

  // limit!
  // seconds to microseconds - signed this gives a bit over half an hour
  long  wait_musec = (long)(delta*MIL);
  timespec  delay = { wait_musec / MIL, (wait_musec % MIL)*1000 };
  
  // (10^6-1)*1000 = 3B9AC618 = max usec -> nsec fits in a 32bit long.
  when->tv_sec = now.tv_sec + delay.tv_sec;
  when->tv_nsec = now.tv_nsec + delay.tv_nsec;

  if(when->tv_nsec >= BIL)      // overflow of nanoseconds?
  {
    // fprintf(stderr,"OVERFLOW = %li, %li\n", when->tv_sec, when->tv_nsec);
    // x, y < BIL, x + y < 2BIL
    when->tv_sec++;
    when->tv_nsec -= BIL;
    // when->tv_sec += when->tv_nsec/BIL;
    // when->tv_nsec %= BIL;
  }

  // fprintf(stderr,"when = %li, %li\n", when->tv_sec, when->tv_nsec);
  // tp contains tv_sec (seconds) & tv_usec (microseconds) both longs.
  // however, if nonposix works everywhere...
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
posix_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
  // fprintf(stderr,"add_sleep_request: %lf\n", delta);

  future_evt  evt;
  evt.task = st;
  calc_when(&evt.when, delta);    // calculate when (t a delta)

  pmut_locker locker(lock);

  PRIOQ->push(evt);

  // we may have inserted at sooner than any other evt, so wake up thread
  // to figure it out (if need be). I seemed to be getting more wakeups
  // with this. Turned off for now. Not sure how that works.
  if(1 || PRIOQ->top().task == st)
  {
//    fprintf(stderr,"WE PUSHED IN - waking thread\n");
    wakeup_thread();
  }
}

// cause the timer wait thread to wake up. useful for asking it to
// exit or re-evaluate a changed sleep queue.
void
posix_timer_queue::wakeup_thread()
{
  // fprintf(stderr,"waking sleeper thread with pthread_cond_signal\n");
  int res;
  // we don't need broadcast because we're only ever waking
  // one thread, the sleeper thread.
  res = pthread_cond_signal(&sleep_cond);
  if(0 != res) fprintf(stderr,"condition signal failed: %i\n", res);
}

void*
posix_timer_queue::thread_start(void* udat)
{
  posix_timer_queue*  q = (posix_timer_queue*)udat;
  fprintf(stderr,"sleeper thread\n");

  while(q->thread_loop_body()) ;

  return 0;
}

bool
posix_timer_queue::thread_loop_body()
{
  pmut_locker locker(lock); // lock on. lock off when waiting on condition

  int   res;

  // pthread_cond_wait & pthread_cond_timedwait (& np rel version?) are
  // cancellation points. doco notes for timed & untimed waits that the
  // predicate should be rechecked as there can be spurious wakeups.
  // no worries, when we wakeup the lock has been acquired.

  while(!PRIOQ->empty())
  {
    future_evt  evt = PRIOQ->top();

    // quit request
    if(!evt.task) return false;

    future_evt  now;    // "now' has no task, just a dummy.
    get_now(&now.when);

    // if(evt < now)    // would prefer <=, eh.
    // < is arse backwards because I don't know how to use the stl
    if(now < evt)   // would prefer <=, eh.
    {
      // fprintf(stderr,"firing of (%li, %li) at (%li, %li)!\n",
      //  evt.when.tv_sec, evt.when.tv_nsec,
      //  now.when.tv_sec, now.when.tv_nsec);
      evt.task->fire();
      PRIOQ->pop();
    }
    else  // we have an event in future, so sleep for that long
    {
      // remember that condition waits are exit points...
      // so I don't need to test - check that.
      // fprintf(stderr,"sleeping from %li, %li until %li, %li\n",
      //  now.when.tv_sec, now.when.tv_nsec,
      //  evt.when.tv_sec, evt.when.tv_nsec);
      res = pthread_cond_timedwait(&sleep_cond, &lock.m, &evt.when);

      // if using posix abstime timed wait we make get EINVAL here for 
      // abstimes in the past. must handle this.
 
      // fprintf(stderr,"pthread_cond_timedwait woke up! (%i)\n", res);
    }
  }

  // if we got here then the queue is empty, so sleep indefinitely
  // that we don't really need the mainloop testcancel because the condition
  // wait functions are cancellation points.
  // fprintf(stderr,"no sleep task, sleeping indefinitely\n");
  res = pthread_cond_wait(&sleep_cond, &lock.m);
  // fprintf(stderr,"pthread_cond_wait woke up! (%i)\n", res);

  // lock released here
  // lock released here
  return true;          // keep going
}
}}


@h=tangler('demux/demux_win_timer_queue.cpp')
@select(h)

// this api needs nt version 4 and above headers. vs is often more strict
// about this sort of thing than mingw. 
// Is this how you do it?
#define _WIN32_WINNT 0x500
#include <Windows.h>

// simply wrapped windows timer queue. requires windows 5.00, which is 
// quite high (xp?) because I couldn't get the waitable timers to work.
// must be careful with this stuff lest it create millions of threads.
#include "demux_win_timer_queue.hpp"

#include <stdio.h>

using namespace std;

namespace flx { namespace demux {

typedef struct
{
  sleep_task* st;       // so we can make it fire
  HANDLE    timer;      // we need to delete the timer, so we need it
  HANDLE    timer_queue;  // AND its queue (no back ptrs, I guess)
} timer_cookie;

win_timer_queue::win_timer_queue()
{
  // fprintf(stderr,"win_timer_queue ctor\n");

  timer_queue = CreateTimerQueue();
  if(!timer_queue)
  {
    fprintf(stderr, "CreateTimerQueue failed: %i\n", GetLastError());
    throw -1;
  }
  // fprintf(stderr, "created timer queue: %p\n", timer_queue);
}


win_timer_queue::~win_timer_queue()
{
  // INVALID_HANDLE_VALUE indicates that DeleteTimerQueueEx should wait for
  // all callback functions to complete before returning. One would hope that
  // calling this causes all the timers to go off before their time (what
  // else would the "actually fired" callback flag be for?). The alternative
  // of waiting for some ever distant timer to go off would be too stupid
  // for words. As usual, the msdn glosses over the important details like
  // this one. Anyway, it's easy to test out... No, that flag's always true
  // for timers, and this wait option doesn't work - maybe with other types
  // flags for CreateTimerQueueTimer?
  if(!DeleteTimerQueueEx(timer_queue, INVALID_HANDLE_VALUE))
  {
    fprintf(stderr, "DeleteTimerQueueEx failed: %i\n", GetLastError());
    // whatcha gonna do about it?
  }
  // fprintf(stderr, "finished - did it wait?\n");
}

// note: may not need time to be in sleep_task. could pass time here.
// thread safe
void
win_timer_queue::add_sleep_request(sleep_task* st, double delta)
{
  // fprintf(stderr,"add_sleep_request: %lf to %p\n", delta, timer_queue);

  timer_cookie* tc = new timer_cookie;

  // copy in the sleep_task and the timer queue
  tc->st = st;
  tc->timer_queue = timer_queue;

  // the timer thread may not be the best solution as nothing is stopping
  // anyone from performing long operations with this structure, however
  // in all likelihood, it'll just be felix adding threads back to its queue.
  if(!CreateTimerQueueTimer(
    &tc->timer,         // resulting timer in timer_cookie
    timer_queue,
    //NULL,           // add to default timer queue
    timer_callback,       // should get called in delta seconds
    tc,             // timer cookie is user data
    (DWORD)(delta*1000),    // millisecond timer
    0,              // zero period => signal once
    WT_EXECUTEINTIMERTHREAD)) // NB: for short tasks (will this do?)
  {
    fprintf(stderr, "CreateTimerQueueTimer failed: %i\n", GetLastError());
    delete tc;          // at least try not to leak
    return;
  }
}

// this is a c callback - all the c++ code should probably be wrapped
// in a try/catch. timer_or_wait_fired is always true for timers.
VOID CALLBACK
win_timer_queue::timer_callback(PVOID udat, BOOLEAN timer_or_wait_fired)
{
  timer_cookie* tc = (timer_cookie*)udat;
  
  // fprintf(stderr, "timer queue callback fired: %p, %i\n",
  //  tc, timer_or_wait_fired);

  if(!tc)
  {
    // Nothing that we can do in this situation.
    fprintf(stderr, "WHOA - NULL queue cookie! (fired: %i)\n",
      timer_or_wait_fired);
    return;           // outta here
  }

  // NULL means delete the thing now, INVALID_HANDLE_VALUE means wait until
  // callback finishes. We're in the callback, so we can't do that (=deadlock
  // of the timer thread, which isn't good). We're all adults here, the timer
  // has expired, we know what we're doing, so lets just delete it.
  tc->st->fire();

  // on my box this returns ERROR_IO_PENDING, on others it doesn't
  // msdn says this should be ok, but I'm not so sure.
  if(!DeleteTimerQueueTimer(tc->timer_queue, tc->timer, NULL))
  {
    int err = GetLastError();

    if( ERROR_IO_PENDING != err)
    {
      fprintf(stderr, "DeleteTimerQueueTimer of %p failed: %i\n",
        tc->timer, err);
    }
    else
    {
      // I'm not so sure, see if it leaks.
      fprintf(stderr, "DeleteTimerQueueTimer = ERROR_IO_PENDING\n");
      fprintf(stderr, "Apparently this is ok...\n");
    }
  }
  delete tc;

  // fprintf(stderr, "leaving timer callback\n");
}

}}

