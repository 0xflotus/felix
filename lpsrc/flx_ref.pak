@h = tangler('spkgs/flx_ref.py')
@select(h)
iscr_source = ['lpsrc/flx_ref.pak']
weaver_directory = 'doc/refman/'

@set_title("Felix Reference")
@head(1,"Types")
Felix provides a rich type system. It consists of the types
and features described below.
@begin_list("keyed")

@item("1. System Types")
These are system intrinsic types supported by the compiler.
The most important of these are the function and procedure
types, but also include special system intrinsics such
as procedure continuations.

@item("2. Standard Library Types")
These are standard types provided by the library. They include
primitives such as boolean, integral and floating numeric types, 
algebraic types including lists, arrays, and options,
and various containers.

@item("3. Type Constructors")
These are not types, but methods of combining types. There are two
classes:
@begin_list("keyed")
@item("1. Anonymous Types")
These are types denoted by an expression. Whilst they may
be given aliases or abbreviations with a typedef, these types
are identified by their structure.

@item("2. Nominal Types")
These are types specified by a declaration which gives
them an identifying name. Each declaration denotes a
distinct types. Nominal types include structs and unions.
@end_list()

@item("4. Type Bindings")
Type bindings specify types mapping C++ types into the
Felix type system. There are several kinds of binding and
associated infrastructure, including primitive (abstract)
types, cstructs (which are mappings of C structs and unions),

@item("5. Parameterised types: polymorphism")
Most type constructors in Felix can be polymorphic.

@item("6. Metatyping")
These are not types, but functions which generate types.
The type language is a superset of the typed lambda calculus,
type functions providing abstraction. However the system
also supports the notions of products and sums of types,
intersection types, and constraints. The types of these types
are called kinds, and kinds themselves are metatyped with the
same metatyping system.

@item("7. Type Constraints")

@item("8. Overloading")
@end_list()

@head(2,"Function Types",nospawn=1)
Felix provides two function types, Felix and C function types.
@head(3,"Felix Function Types",nospawn=1)
Felix function closure types are denoted by:
@begin_displayed_code()
   D -> C
@end_displayed_code()
where D is the domain and C the codomain types. The binary
combinator -> is left associative. Values of such a type
are constructed by forming closures of function classes 
which are denoted by a function definition. 
@p()
Closures bind to the instance of their environment
denoted by lexical scoping together with control flow rules,
and remain live at least while there is a live reference to them.
The local part of a closure denoted by a function is called
the stack frame for historical reasons, and the list of stack 
frames comprising that of the function and its ancestors
is known as the display, also for historical reasons.
@p()
Closures are applicative objects which can be applied to a value
of their domain type D, and which return a value of their
codomain type C.
@p()
Neither the domain D nor codomain C of a function type may be void.
@p()
Functions may not have side effects. See
@ref_anchor("fundef")
for details of defining function classes.

@head(3,"C Function Types",nospawn=1)
Felix also provides direct access to C functions, whose type
is denoted by:
@begin_displayed_code()
   D --> C
@end_displayed_code()
Note that C function closures certainly exist, however they bind
only to their primitive static environment.

@head(3,"Procedure Types",nospawn=1)
A procedure is a subroutine which may and generally should have 
side-effects and which does not return a value. Procedures
have types denoted by one of:
@begin_displayed_code()
   D -> 0
   D -> void
@end_displayed_code()
where D may not be void. (void is an alias for 0 defined
in the standard library).
@p()
Felix procedures values are constructed by
forming the closure of a procedure class. Procedures are quite
distinct from functions, since they may participate in synchronous
multithreading, whereas functions may not. See
@ref_anchor("sync")
for details on synchronous threading. See 
@ref_anchor("procdef")
for details of defining procedure classes.

@head(2,"Anonymous Types",nospawn=1)
An anonymous type is one which is identified by its structure
rather than a declared name.

@head(3,"Tuple Types",nospawn=1)
A tuple is a categorical products whose projection functions
are identified positionally, using non-negative integer constant
indicies. n-ary tuples exist for all non-negative values of n
other than 1. Tuples of one component of type T are identified
with type T. The nullary tuple type is denoted by
@begin_displayed_code()
  1 
  unit
@end_displayed_code()
where 'unit' is aliased to 1 in the standard library. The sole value
of unit type is denoted:
@begin_displayed_code()
  ()
@end_displayed_code()
An n-ary tuple type, of components T0, T1, ... is denoted by:
@begin_displayed_code()
  T0 * T1 * T2 * ...
@end_displayed_code()
and values are denoted:
@begin_displayed_code()
  v0, v1, v2, ...
@end_displayed_code()
You should note that the chain operator * is not associative,
although it is associative up to isomorphism. 
@p()
Tuples support two destructors. The form
@begin_displayed_code()
  x.(0)
  x.(1)
  ...
@end_displayed_code()
can be used with a constant expression denoting the projection.
You can also use a tuple pattern in a match expression
@begin_displayed_code()
  match x with
  | ?v1,?v2, .. => ..
  endmatch
@end_displayed_code()

@head(3,"Array Types",nospawn=1)
A tuple of 2 more or more components, all of which are
the same type T, is known as an array. The special sugar
@begin_displayed_code()
  T ^ n 
@end_displayed_code()
may be used for arrays of manifestly fixed length, where n is a 
literally given integer constant. Array values are the same
as tuple values, since arrays are just special cases of
tuples. However the special notation like:
@begin_displayed_code()
  [| 1,2,3 |]
@end_displayed_code()
can be used for arrays, which results in a compile time
error if the component values are not all the same type.

@head(3,"Record Types",nospawn=1)
A record type is a variant on a tuple, in which the 
components are named rather than numbered. The types
are denoted like:
@begin_displayed_code()
  struct {
    a:int;
    b:string;
    c:double;
  }
@end_displayed_code()
and values are constructed like:
@begin_displayed_code()
  struct {
    a=1;
    c= 9.2;
    b:string="Hello";
  }
@end_displayed_code()
Record types support a generic coercion operation
which allows the formation of a new record with
a subset of the fields of the argument record,
the type of this record is a subtype. See 
@ref_anchor("record coercion")
.
@p()
Records can be accessed by the usual dot notation:
@begin_displayed_code()
  x.a
@end_displayed_code()
or using pattern matches:
@begin_displayed_code()
  match x with
  | struct { a=?i; b=?s; } =>
  ...
@end_displayed_code()
Note that record patterns need only match a subtype
of the record, that is, only some of the field names
need be given.

@head(3,"Sum Types",nospawn=1)
Sum types are use to express numbered cases.
An n-ary sum type, of case types T0, T1, ... is denoted by:
@begin_displayed_code()
  T0 + T1 + T2 + ...
@end_displayed_code()
and variant values are denoted by
@begin_displayed_code()
  (case 0 of T0 + T2 ...) v0
  (case 1 of T0 + T2 ...) v1
  (case 2 of T0 + T2 ...) v2
  ...
@end_displayed_code()
In addition, a sum of n units has the special name:
@begin_displayed_code()
  n
@end_displayed_code()
where n is an non-negative integral constant.
Three of these have standard names given by these typedefs:
@begin_displayed_code()
  typedef void = 0; 
  typedef unit = 1; 
  typedef bool = 2; 
@end_displayed_code()
These two variants have standard names:
@begin_displayed_code()
  case 0 of 2 // false
  case 1 of 2 // true
@end_displayed_code()
Sums can be destroyed in pattern matches:
@begin_displayed_code()
  match x with
  | (case 1) ?a => ...
@end_displayed_code()
Note that the sum type does not need to be named, since it
is determined by the match argument type.
@p()
Note that sum type constructors can also be used as functions,
like Haskell but unlike Ocaml. The compiler generates a wrapper
function to form the closure automatically on such usage.
@p()
The standard function caseno can be used to obtain the 
zero origin ariant index:
@begin_displayed_code()
  var x : int = caseno (case 1 of 2); // x is 1
@end_displayed_code()

@head(3,"Pointer Types",nospawn=1)

@head(2,"Nominal Types",nospawn=1)
A nominal type is one which is declared and identified by
its name. Two nominal types may have the same structure
and representation, but remain distinct.

@head(3,"Struct Types",nospawn=1)
Felix struct type definitions resemble C++:
@begin_displayed_code()
  struct X {
    a : int;
    b : long;
  };
@end_displayed_code()
All structs are provided with constructors with the same name
as the struct, and which take a tuple argument with the same components
in order:
@begin_displayed_code()
  var x = X(1,2L);
@end_displayed_code()
This construction is efficient: tuple and all struct types with
the same sequence of components always have the members 
at the same offsets, and thus are representation compatible.

@head(3,"Union Types",nospawn=1)
Felix union type definitions come in two flavours: the ML form:
@begin_displayed_code()
  union X = 
    | a of int
    | b of long
  ;
@end_displayed_code()
and the C form:
@begin_displayed_code()
  union X {
    a : int;
    b : long;
  };
@end_displayed_code()
These flavours are equivalent. However the ML form 
also supports constructors without arguments:
@begin_displayed_code()
  union X = 
    | a of int
    | b of long
    | c
  ;
@end_displayed_code()
Values of a union type are written like function applications,
or constants:
@begin_displayed_code()
  var x1 : X = a 1;
  var x2 : X = b 1L;
  var x3 : X = c;
@end_displayed_code()
Constructor names can be overloaded like ordinary functions.
Unions can be decoded with pattern matches:
@begin_displayed_code()
  match x with
  | a ?x1 => ..
  | b ?x2 => ..
  | c => ..
@end_displayed_code()
and the zero origin case number can be found with the caseno function:
@begin_displayed_code()
  var x : int = caseno (a ?1) ; // x is 0
@end_displayed_code()

@head(3,"Enumeration Types",nospawn=1)
If all the variants of a union have no arguments,
the shorthand:
@begin_displayed_code()
  enum X { a, b=7, c };
@end_displayed_code()
can be used. In this form, an equal sign followed by
an non-negative integral constant provides a way of
fixing the case index. Case indicies are assigned
as in C, starting at zero, and each component other
than the first being assigned an index one higher
than the previous one. Note duplicates and missing
cases are both permitted.

@head(3,"Class Types",nospawn=1)
Felix classes are defined like:
@begin_displayed_code()
class Y {
  val c : int;
  private var x : int;
  
  fun fetchc():int =>c+1;
  private fun fetchx():int =>x;
  proc setx(a:int) { x = a; }
  ctor (a:int): x(20000),c(1000) { x = a; }
};
@end_displayed_code()
Classes may contain, val, var, fun and proc definitions.
Val's may be initialised in constructors but not otherwise
modified. The special function introduced by the ctor
keyword introduces a constructor, with C++ style member 
initialiser list.
@p()
Class members are all public by default. Var, val, proc
and fun members can be declared private, in which case
they can only be accessed within a method of the class.
@p()
Unlike structs, classes are always passed by reference,
that is, a class value is actually a pointer.
@p()
Unlike C++, Felix supports method object closures:
@begin_displayed_code()
  var y <- new Y;
  val f = y.fetchc;  // object closure
  print (f 1); endl; // value of y's c variable + 1
@end_displayed_code()
A special new statement is used to construct classes
with the form shown above. Constructors are overloaded
in the usual way. As a special case one default
constructor may be given and called without arguments,
even though it really has a unit argument. Note that
constructors exist in the scope containing a class
definition and are not methods.
@p()
Methods exist within class scope and cannot be overloaded.

@head(2,"Primitive Types",nospawn=1)
Felix provides a method for importing C/C++ types into
Felix:
@begin_displayed_code()
  type myint = "int";
@end_displayed_code()
Such definitions provide the user a way to introduce
new primitive types into Felix. Such types are
considered abstract. The C++ type must be allocable,
default and copy constructible, copy assignable, 
and destructible, that is, they must be first class data types.
@p()
It is also possible to introduce non-first class types, 
with the adjective incomplete:
@begin_displayed_code()
  incomplete type myvoid = "void";
@end_displayed_code()
Such types can only be used as the argument of some kind
of pointer type constructor, or to instantiate a 
type variable in binding context for which it is
suitable.
@p()
See 
@ref_anchor("bindings")
 for more information on bindings.

@head(2,"Standard Types",nospawn=1)
@head(3,"System Types",nospawn=1)
@head(3,"Arithmetic Types",nospawn=1)
Felix provides the following standard C arithmetic types. They can
be named with any of the usual C names with contractions,
or using a Felix alias:
@begin_table("Felix name","Full C name")
@table_row("tiny","signed char")
@table_row("utiny","unsigned char")
@table_row("short","signed short int")
@table_row("ushort","unsigned short int")
@table_row("int","signed int")
@table_row("uint","unsigned int")
@table_row("long","signed long int")
@table_row("ulong","unsigned long int")
@table_row("vlong","signed long long")
@table_row("uvlong","unsigned long long")
@table_row("float","float")
@table_row("double","double float")
@table_row("ldouble","long double float")
@end_table()
The following aliases are also provided, in this
case the C name may not be used:
@begin_table("Felix name","C name")
@table_row("size","size_t")
@table_row("ptrdiff","ptrdiff_t")
@table_row("intptr","intptr_t")
@table_row("uintptr","uintptr_t")
@table_row("intmax","intmax_t")
@table_row("uintmax","uintmax_t")
@end_table()

The following aliases for exact integers are also provided, in this
case the C name may not be used:
@begin_table("Felix name","C name")
@table_row("int8","int8_t")
@table_row("uint8","uint8_t")
@table_row("int16","int8_t")
@table_row("uint16","uint16_t")
@table_row("int32","int32_t")
@table_row("uint32","uint32_t")
@table_row("int64","int64_t")
@table_row("uint64","uint64_t")
@end_table()
Felix guarantees all these integer aliases exist,
even if the C99 counterparts do not.

@head(3,"String Types",nospawn=1)
@head(3,"Container Types",nospawn=1)

@head(1,"Applicative classes")
Felix provides several constructions which are called class
constructions (and their C++ representations are typically
C++ classes).
@p()
Of these, the most commonly used are the two kinds of
applicative class: functions and procedures. Objects
of these classes are known as closures.

@head(2,"Defining Functions",key="fundef")
Felix supports three syntactic forms for definining functions.
The simplest form is illustrated by:
@begin_displayed_code()
  fun f[t] (x:t, y:int): int * t => y,x;
@end_displayed_code()
You will note this function is polymorphic with one type
argument t, it accepts a single argument of tuple type t * int,
and returns a tuple of type int * t. The return type can be
omitted in this case because it can be deduced:

@begin_displayed_code()
  fun f[t] (x:t, y:int)=> y,x;
@end_displayed_code()

In this form, the function body is just an expression whose
elaboration yields the value returned by the function.
@p()
The second form allows procedural code in a function,
provided its side effects are limited to the scope
of the function, so that the function itself has no
side effects:

@begin_displayed_code()
  fun f[t] (x:t, y:int): int * t =
  {
    var z = y;
    z++;
    return z,x;
  }
@end_displayed_code()

In this form, the returned value is the argument of
the first return statement elaborated by the flow
of control. Again, the return type can be omitted if the
function type can be deduced. This is the most general
form, the first form is just synactic sugar for
@begin_displayed_code()
  fun f[t] (x:t, y:int): int * t =
  {
    return y,x;
  }
@end_displayed_code()
saving a few keystrokes, but greatly simplifying code
layout, and improving the ability of the programmer
to reason that the function has no side effects.
@p()
This form supports an extension to curry form:

@begin_displayed_code()
  fun f[t] (x:t) (y:int) int * t =
  {
    return y,x;
  }
@end_displayed_code()

which is short hand for

@begin_displayed_code()
  fun f[t] (x:t): int -> int * t =
  {
    fun g(y:int): int * t =
    {
      return y,x;
    }
    return g;
  }
@end_displayed_code()

Similarly, the first form also supports this extension.
@p()
The final form is 
@begin_displayed_code()
  fun f: u -> int  =
    | Empty => 0
    | Cons (_,?tail) => 1 + f tail
  ;
@end_displayed_code()

which is short hand for:

@begin_displayed_code()
  fun f(x:u):int =
    match x with
    | Empty => 0
    | Cons (_,?tail) => 1 + f tail
    endmatch
  ;
@end_displayed_code()

All these forms can be used anonymously wherever a
function closure is required, by simply enclosing them
in parentheses and omitting the function name:

@begin_displayed_code()
  print$ (fun f[t] (x:t, y:int)=> y,x) (1,2);
@end_displayed_code()

This is called the lambda form of the function,
such lambda forms are first class expressions.
@p()
Two special cases of the lambda forms can be used for functions:

@begin_displayed_code()
  { x }
@end_displayed_code()

is a function with unit argument, returning value x, and is short
hand for:
@begin_displayed_code()
  (fun()=>x)
@end_displayed_code()

and

@begin_displayed_code()
  { var y = x; ++x; return x; }
@end_displayed_code()

is short hand for

@begin_displayed_code()
  (fun () { var y = x; ++x; return x; })
@end_displayed_code()

You should note very carefully the following
are NOT equivalent:

@begin_displayed_code()
  fun f()=>x;
  val f = { x };
@end_displayed_code()

The first line defines a function f, but does not
form a closure. The second line stores a closure of
an anonymous function into value f. Although any
application of either f is equivalent, the lookup
rules for variable and function names are distinct.
Function names can be overloaded, and lookup choses
the right function to use in an application based
on the function argument.
@p()
Variable names, even if used applicatively, are never
overloaded and do not participate in overload resolution.
@p()
Felix also allows functions to provide pre-conditions
and post-conditions. Here is an example:

@begin_displayed_code()
  fun f(x: int, y:int when x+y>0): int expect result > 0 =
  {
    return x + y;
  }
@end_displayed_code()
The special identifier result is used to denote the 
value returned by the function. Pre and post conditions are
part of the intuitive function type, but they are not part of the 
formal type. Instead, pre and post conditions are checked prior
to and after function application, respectively, and abort the
program if the conditions are not met.

@head(3,"Lazy value Types",nospawn=1)
A lazy value type is a function type with the domain 0 or void.
A value of such a type can be constructed and used with syntax like:
@begin_displayed_code()
   var y = 1.0;
   fun x = sin y;
   print x; endl;
   var y = 0.5;
   print x; endl;
@end_displayed_code()
The function x is semantically equivalent to a function taking
unit argument, however each reference to x is automatically
applied to the unit value () wherever it is written. In effect,
such a function looks like a value whose body is substituted
for each reference to it. This is also how it is implemented.
In particular in the example, the output will be the
value sin 1.0 and sin 0.5.


@head(2,"Defining Procedures",key="procdef")
Felix supports three syntactic forms for definining procedures.
The simplest form is illustrated by:
@begin_displayed_code()
  proc f[t] (x:t, y:int) { print y; h x; }
@end_displayed_code()
You will note this function is polymorphic with one type
argument t, it accepts a single argument of tuple type t * int.
@p()
This form supports an extension to curry form:

@begin_displayed_code()
  proc f[t] (x:t) (y:int) 
  {
    print y; h x;
  }
@end_displayed_code()

which is short hand for

@begin_displayed_code()
  fun f[t] (x:t): t -> (int -> void) =
  {
    proc g(y:int) =
    {
      print y; h x;
    }
    return g;
  }
@end_displayed_code()
Procedures also support lambda abstraction:

@begin_displayed_code()
  (proc (x:int, y:int) { print y; h x; }) (1,2);
@end_displayed_code()
A special form can be used for procedures with unit argument:
@begin_displayed_code()
  { print "Hello"; endl; }
@end_displayed_code()

is a procedure with unit argument, and is short hand for:
@begin_displayed_code()
  (proc(){print "Hello"; endl; })
@end_displayed_code()

You should note very carefully the following
are NOT equivalent:

@begin_displayed_code()
  proc f(){ print "Hello"; endl; }
  val f = { print "Hello"; endl; }
@end_displayed_code()

The first line defines a procedure f, but does not
form a closure. The second line stores a closure of
an anonymous procedure into value f. Although any
application of either f is equivalent, the lookup
rules for variable and function names are distinct.
Procedure names can be overloaded, and lookup choses
the right procedure to use in an application based
on the procedure argument.
@p()
Variable names, even if used applicatively, are never
overloaded and do not participate in overload resolution.
@p()
Felix also allows procedures to provide pre-conditions.
Here is an example:

@begin_displayed_code()
  proc f(x: int, y:int when x+y>0)
  {
    print (x + y); endl;
  }
@end_displayed_code()

@head(1,"Bindings")
Felix provides extensive support for binding C/C++.
Whilst many languages provide an FFI (Foreign Function
Interface) which allows glue logic to be written in C, 
Felix uses the C/C++ object model directly, and provides
the ability to bind to C/C++ data types and functions
directly in the language. In most cases these bindings
do not require any executable glue code, instead,
the bindings simply provide a map between the type systems.

@head(2,"Binding types")
Felix allows you to bind types like:
@begin_displayed_code()
  type myint = "int";
@end_displayed_code()
When the target and source names are the same, the
source string can be elided, and multiple type
named at once:
@begin_displayed_code()
  ctypes int, long, complex;
@end_displayed_code()
The type must be a first class type, that is,
allocable, default initialisable, copy constructible,
copy assignable, and destructible. 
@p()
Non-first class type may also be introduced with
the keyword incomplete:

@begin_displayed_code()
  incomplete type myvoid = "void";
@end_displayed_code()

and may only be used as the argument of a pointer 
type constructor or argument to a binding construction
for which the type makes sense in C/C++ context.
For example:

@begin_displayed_code()
  type pt[t]="?1*";
  typedef voidp = pt[void];
@end_displayed_code()

is acceptable usage because void* is a first class
data type.
@p()
It is also possible to state that a type is a C++ POD,
or Plain Old Data type:

@begin_displayed_code()
  pod type int = "int";
@end_displayed_code()

In such a case, the garbage collector may elide applying
a finalisation function to the type, improving performance.
@p()
The decoration:
@begin_displayed_code()
  _gc_pointer type int = "X*";
@end_displayed_code()

tells the garbage collector the type is a pointer
to Felix heap storage, and should be traced by the
collector sweep when determining if storage is reachable.
In this case, the pointer may be NULL, otherwise it must
point to the client data part of a storage frame
allocated by the collector. Such an type this denotes
managed storage. This annotation is primarily provided
so programmers developing Felix types in C++ can tell
the Felix compiler the type is Felix compliant.
@p()
Type abstractions can be polymorphic. For example:
@begin_displayed_code()
  type vector[t] = "vector<?1>";
@end_displayed_code()
Here the special encoding ?1 refers to the first
type parameter. 
@p()
Type bindings may also have a requirements clause:
@begin_displayed_code()
  type vector[t] = "vector<?1>" requires vector_h;
@end_displayed_code()
See 
@ref_anchor("requirements")
 for more details.

@head(2,"Binding constants")
Felix provides a way to lift C/C++ expressions directly
into Felix:
@begin_displayed_code()
  const pi : double = "M_PI";
  const M_PI : double;
  const myval[t] : int = "(?1)(x+y)";
@end_displayed_code()
When the target and source names are the same,
the source string can be elided.
@p()
When used in an expression, the Felix symbol is 
replaced by the correspondong C code, with substitution
of type variables if necessary.
@p()
The const declaration is a short form for a function
with no arguments. Const definitions can also have
requirements clauses. See 
@ref_anchor("requirements")
 for more details.

@head(2,"Requirements Specifications",key="requirements")
@head(1,"Expressions",key="expr")
@head(2,"Coercions",key="coercion")
@head(2,"Record Coercions",key="record coercion")

@begin_displayed_code()
  typedef isd = 
    struct 
    {
      a:int;
      b:string;
      c:double;
    }
  ;

  typedef id = 
    struct 
    {
      a:int;
      c:double;
    }
  ;
  val x : isd = struct { a=1; b="Hello"; c=9.2; };
  val y : id = x : id; // coercion
@end_displayed_code()

@head(2,"Pattern match",key="expr")
@head(1,"Statements",nospawn=1)
@head(2,"Definitions",nospawn=1)
@head(3,"Modules",nospawn=1)
@head(2,"Executable Statements",nospawn=1)
@head(3,"Goto",nospawn=1)
@head(3,"Call",nospawn=1)
@head(3,"Return",nospawn=1)
@head(3,"Assignment",nospawn=1)

@head(1,"Synchronous Multithreading",key="sync")
@head(1,"First order polymorphism",key="poly1")

