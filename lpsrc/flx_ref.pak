@h = tangler('spkgs/flx_ref.py')
@select(h)
iscr_source = ['lpsrc/flx_ref.pak']
weaver_directory = 'doc/refman/'

@set_title("Felix Reference")
@head(1,"Conformance Model")
This document purports to be a descripton of required behaviour
of Felix language translators, programs, and components.
It also provides semantic information in terms of C++ representations.
@p()
Thus, it presents several distinct semantics for Felix.
To distinguish the two key facets, we refer
to the Abstract and Concrete semantics.
@p()
The Concrete Semantics is a semi-formal description of
Felix semantics in terms of the C++ code it generates:
the full semantic interpretation thereby depends on the
semantics of ISO C++. This description is more formal than the
Abstract Semantics, but it is also more fragile,
dependent on the implementation, and likely to change
in ongoing releases.
@p()
The Abstract Semantics are specified in terms of a loose
common understanding of programming systems, without
resort to formal mathematical description: this manual
is intended primarily for programmers, and C++ programmers
in particular. The Abstract semantics, whilst not set in
concrete (g) are considerably more stable and more likely
to be extended in future releases than modified.
@p()
The key distinction between Abstract and Concrete semantics
is manifest in a set of extensions to the Abstract Language,
in which binding constructions bridging the Felix/C++ interfaces
are provided. These constructions are a core part of the 
implementation: they're not only used to provide some
of the required abstract semantics, they're also available
for end users to extend, modify, or even largely replace
much of the abstract semantics.
@p()
Nevertheless the Abstract Semantics are not to be ignored,
since they reflect a particular programming model whose
invariants may be broken by arbitrary modifications
to the standard library.

@head(1,"Types")
Felix provides a rich type system. It consists of the types
and features described below.
@begin_list("keyed")

@item("1. System Types")
These are system intrinsic types supported by the compiler.
The most important of these are the function and procedure
types, but also include special system intrinsics such
as procedure continuations.

@item("2. Standard Library Types")
These are standard types provided by the library. They include
primitives such as boolean, integral and floating numeric types, 
algebraic types including lists, arrays, and options,
and various containers.

@item("3. Type Constructors")
These are not types, but methods of combining types. There are two
classes:
@begin_list("keyed")
@item("1. Anonymous Types")
These are types denoted by an expression. Whilst they may
be given aliases or abbreviations with a typedef, these types
are identified by their structure.

@item("2. Nominal Types")
These are types specified by a declaration which gives
them an identifying name. Each declaration denotes a
distinct types. Nominal types include structs and unions.
@end_list()

@item("4. Type Bindings")
Type bindings specify types mapping C++ types into the
Felix type system. There are several kinds of binding and
associated infrastructure, including primitive (abstract)
types, cstructs (which are mappings of C structs and unions),

@item("5. Parameterised types: polymorphism")
Most type constructors in Felix can be polymorphic.

@item("6. Metatyping")
These are not types, but functions which generate types.
The type language is a superset of the typed lambda calculus,
type functions providing abstraction. However the system
also supports the notions of products and sums of types,
intersection types, and constraints. The types of these types
are called kinds, and kinds themselves are metatyped with the
same metatyping system.

@item("7. Type Constraints")

@item("8. Overloading")
@end_list()

@head(2,"Function Types",nospawn=1)
Felix provides two function types, Felix and C function types.
@head(3,"Felix Function Types",nospawn=1)
Felix function closure types are denoted by:
@begin_displayed_code()
   D -> C
@end_displayed_code()
where D is the domain and C the codomain types. The binary
combinator -> is left associative. Values of such a type
are constructed by forming closures of function classes 
which are denoted by a function definition. 
@p()
Closures bind to the instance of their environment
denoted by lexical scoping together with control flow rules,
and remain live at least while there is a live reference to them.
The local part of a closure denoted by a function is called
the stack frame for historical reasons, and the list of stack 
frames comprising that of the function and its ancestors
is known as the display, also for historical reasons.
@p()
Closures are applicative objects which can be applied to a value
of their domain type D, and which return a value of their
codomain type C.
@p()
Neither the domain D nor codomain C of a function type may be void.
@p()
The special abbreviation:
@begin_displayed_code()
   {C}
@end_displayed_code()
may be used to denote the function type:
@begin_displayed_code()
   unit -> C
@end_displayed_code()
and thus represents lazy evaluation of the function. For example:
@begin_displayed_code()
  {2}
@end_displayed_code()
is the encoding of a boolean predicated on the environment.
@p()
Functions may not have side effects. See
@ref_anchor("fundef")
for details of defining function classes.

@head(3,"C Function Types",nospawn=1)
Felix also provides direct access to C functions, whose type
is denoted by:
@begin_displayed_code()
   D --> C
@end_displayed_code()
Note that C function closures certainly exist, however they bind
only to their primitive static environment.

@head(3,"Procedure Types",nospawn=1)
A procedure is a subroutine which may and generally should have 
side-effects and which does not return a value. Procedures
have types denoted by one of:
@begin_displayed_code()
   D -> 0
   D -> void
@end_displayed_code()
where D may not be void. (void is an alias for 0 defined
in the standard library).
@p()
Felix procedures values are constructed by
forming the closure of a procedure class. Procedures are quite
distinct from functions, since they may participate in synchronous
multithreading, whereas functions may not. See
@ref_anchor("sync")
for details on synchronous threading. See 
@ref_anchor("procdef")
for details of defining procedure classes.

@head(2,"Anonymous Types",nospawn=1)
An anonymous type is one which is identified by its structure
rather than a declared name.

@head(3,"Tuple Types",nospawn=1)
A tuple is a categorical products whose projection functions
are identified positionally, using non-negative integer constant
indicies. n-ary tuples exist for all non-negative values of n
other than 1. Tuples of one component of type T are identified
with type T. The nullary tuple type is denoted by
@begin_displayed_code()
  1 
  unit
@end_displayed_code()
where 'unit' is aliased to 1 in the standard library. The sole value
of unit type is denoted:
@begin_displayed_code()
  ()
@end_displayed_code()
An n-ary tuple type, of components T0, T1, ... is denoted by:
@begin_displayed_code()
  T0 * T1 * T2 * ...
@end_displayed_code()
and values are denoted:
@begin_displayed_code()
  v0, v1, v2, ...
@end_displayed_code()
You should note that the chain operator * is not associative,
although it is associative up to isomorphism. 
@p()
Tuples support two destructors. The form
@begin_displayed_code()
  x.(0)
  x.(1)
  ...
@end_displayed_code()
can be used with a constant expression denoting the projection.
You can also use a tuple pattern in a match expression
@begin_displayed_code()
  match x with
  | ?v1,?v2, .. => ..
  endmatch
@end_displayed_code()

@head(3,"Array Types",nospawn=1)
A tuple of 2 more or more components, all of which are
the same type T, is known as an array. The special sugar
@begin_displayed_code()
  T ^ n 
@end_displayed_code()
may be used for arrays of manifestly fixed length, where n is a 
literally given integer constant. Array values are the same
as tuple values, since arrays are just special cases of
tuples. However the special notation like:
@begin_displayed_code()
  [| 1,2,3 |]
@end_displayed_code()
can be used for arrays, which results in a compile time
error if the component values are not all the same type.

@head(3,"Record Types",nospawn=1)
A record type is a variant on a tuple, in which the 
components are named rather than numbered. The types
are denoted like:
@begin_displayed_code()
  struct {
    a:int;
    b:string;
    c:double;
  }
@end_displayed_code()
and values are constructed like:
@begin_displayed_code()
  struct {
    a=1;
    c= 9.2;
    b:string="Hello";
  }
@end_displayed_code()
Record types support a generic coercion operation
which allows the formation of a new record with
a subset of the fields of the argument record,
the type of this record is a subtype. See 
@ref_anchor("record coercion")
.
@p()
Records can be accessed by the usual dot notation:
@begin_displayed_code()
  x.a
@end_displayed_code()
or using pattern matches:
@begin_displayed_code()
  match x with
  | struct { a=?i; b=?s; } =>
  ...
@end_displayed_code()
Note that record patterns need only match a subtype
of the record, that is, only some of the field names
need be given.

@head(3,"Sum Types",nospawn=1)
Sum types are use to express numbered cases.
An n-ary sum type, of case types T0, T1, ... is denoted by:
@begin_displayed_code()
  T0 + T1 + T2 + ...
@end_displayed_code()
and variant values are denoted by
@begin_displayed_code()
  (case 0 of T0 + T2 ...) v0
  (case 1 of T0 + T2 ...) v1
  (case 2 of T0 + T2 ...) v2
  ...
@end_displayed_code()
In addition, a sum of n units has the special name:
@begin_displayed_code()
  n
@end_displayed_code()
where n is an non-negative integral constant.
Three of these have standard names given by these typedefs:
@begin_displayed_code()
  typedef void = 0; 
  typedef unit = 1; 
  typedef bool = 2; 
@end_displayed_code()
These two variants have standard names:
@begin_displayed_code()
  case 0 of 2 // false
  case 1 of 2 // true
@end_displayed_code()
Sums can be destroyed in pattern matches:
@begin_displayed_code()
  match x with
  | (case 1) ?a => ...
@end_displayed_code()
Note that the sum type does not need to be named, since it
is determined by the match argument type.
@p()
Note that sum type constructors can also be used as functions,
like Haskell but unlike Ocaml. The compiler generates a wrapper
function to form the closure automatically on such usage.
@p()
The standard function caseno can be used to obtain the 
zero origin ariant index:
@begin_displayed_code()
  var x : int = caseno (case 1 of 2); // x is 1
@end_displayed_code()

@head(3,"Pointer Types",nospawn=1)
A Felix pointer to T is denoted by the notation:
@begin_displayed_code()
  &T
@end_displayed_code()
A pointer can be formed by addressing a var kind of variable, and
dereferenced in the usual way:
@begin_displayed_code()
  var x : int = 1;
  var px : &int = &x;
  var y : int = *px; // y is now 1
@end_displayed_code()
Pointers cannot dangle: it is safe to address a local variable.
Pointers cannot be set to NULL in the abstract language,
although they can become NULL by use of facilities
in the C_hack module of the standard library. They cannot
be incremented or added to.

@head(3,"Type Recursion",nospawn=1)
Felix provides a fixpoint operator for typing:
@begin_displayed_code()
  t as v
@end_displayed_code()
where v is an identifier in t. For example a list of int
may be given by:
@begin_displayed_code()
  1 + int * ilist as ilist
@end_displayed_code()
The postfix fixpoint operator has a low precedence.
This encoding is equivalent to:
@begin_displayed_code()
  typedef ilist = 1 + int * ilist;
@end_displayed_code()
except that the former is an expression, allowing the
type to be used in combinator form without defining
a named alias.

@head(2,"Nominal Types",nospawn=1)
A nominal type is one which is declared and identified by
its name. Two nominal types may have the same structure
and representation, but remain distinct.

@head(3,"Struct Types",nospawn=1)
Felix struct type definitions resemble C++:
@begin_displayed_code()
  struct X {
    a : int;
    b : long;
  };
@end_displayed_code()
All structs are provided with constructors with the same name
as the struct, and which take a tuple argument with the same components
in order:
@begin_displayed_code()
  var x = X(1,2L);
@end_displayed_code()
This construction is efficient: tuple and all struct types with
the same sequence of components always have the members 
at the same offsets, and thus are representation compatible.

@head(3,"Union Types",nospawn=1)
Felix union type definitions come in two flavours: the ML form:
@begin_displayed_code()
  union X = 
    | a of int
    | b of long
  ;
@end_displayed_code()
and the C form:
@begin_displayed_code()
  union X {
    a : int;
    b : long;
  };
@end_displayed_code()
These flavours are equivalent. However the ML form 
also supports constructors without arguments:
@begin_displayed_code()
  union X = 
    | a of int
    | b of long
    | c
  ;
@end_displayed_code()
Values of a union type are written like function applications,
or constants:
@begin_displayed_code()
  var x1 : X = a 1;
  var x2 : X = b 1L;
  var x3 : X = c;
@end_displayed_code()
Constructor names can be overloaded like ordinary functions.
Unions can be decoded with pattern matches:
@begin_displayed_code()
  match x with
  | a ?x1 => ..
  | b ?x2 => ..
  | c => ..
@end_displayed_code()
and the zero origin case number can be found with the caseno function:
@begin_displayed_code()
  var x : int = caseno (a ?1) ; // x is 0
@end_displayed_code()

@head(3,"Enumeration Types",nospawn=1)
If all the variants of a union have no arguments,
the shorthand:
@begin_displayed_code()
  enum X { a, b=7, c };
@end_displayed_code()
can be used. In this form, an equal sign followed by
an non-negative integral constant provides a way of
fixing the case index. Case indicies are assigned
as in C, starting at zero, and each component other
than the first being assigned an index one higher
than the previous one. Note duplicates and missing
cases are both permitted.

@head(3,"Class Types",nospawn=1)
Felix classes are defined like:
@begin_displayed_code()
class Y {
  val c : int;
  private var x : int;
  
  fun fetchc():int =>c+1;
  private fun fetchx():int =>x;
  proc setx(a:int) { x = a; }
  ctor (a:int): x(20000),c(1000) { x = a; }
};
@end_displayed_code()
Classes may contain, val, var, fun and proc definitions.
Val's may be initialised in constructors but not otherwise
modified. The special function introduced by the ctor
keyword introduces a constructor, with C++ style member 
initialiser list.
@p()
Class members are all public by default. Var, val, proc
and fun members can be declared private, in which case
they can only be accessed within a method of the class.
@p()
Unlike structs, classes are always passed by reference,
that is, a class value is actually a pointer.
@p()
Unlike C++, Felix supports method object closures:
@begin_displayed_code()
  var y <- new Y;
  val f = y.fetchc;  // object closure
  print (f 1); endl; // value of y's c variable + 1
@end_displayed_code()
A special new statement is used to construct classes
with the form shown above. Constructors are overloaded
in the usual way. As a special case one default
constructor may be given and called without arguments,
even though it really has a unit argument. Note that
constructors exist in the scope containing a class
definition and are not methods.
@p()
Methods exist within class scope and cannot be overloaded.

@head(2,"Primitive Types",nospawn=1)
Felix provides a method for importing C/C++ types into
Felix:
@begin_displayed_code()
  type myint = "int";
@end_displayed_code()
Such definitions provide the user a way to introduce
new primitive types into Felix. Such types are
considered abstract. The C++ type must be allocable,
default and copy constructible, copy assignable, 
and destructible, that is, they must be first class data types.
@p()
It is also possible to introduce non-first class types, 
with the adjective incomplete:
@begin_displayed_code()
  incomplete type myvoid = "void";
@end_displayed_code()
Such types can only be used as the argument of some kind
of pointer type constructor, or to instantiate a 
type variable in binding context for which it is
suitable.
@p()
See 
@ref_anchor("bindings")
 for more information on bindings.

@head(2,"Standard Types",nospawn=1)
@head(3,"System Types",nospawn=1)
@head(4,"Fibres",nospawn=1)
Felix provides a system of cooperative multithreading
based on resumable procedural continuations and channels.
@p()
The following basic types are defined as bindings to the underlying
C++ technology. They are:
@begin_table("Type", "Role")
@table_row("Control::fthread","Thread of control")
@table_row("Control::cont","Procedural Continuation")
@table_row("Control::schannel[t]","Bidirectional Channel")
@table_row("Control::ischannel[t]","Input Channel")
@table_row("Control::oschannel[t]","Output Channel")
@end_table()
@p()
The following operations are used to manage these entities.
...

@head(3,"Arithmetic Types",nospawn=1)
Felix provides the following standard C arithmetic types. They can
be named with any of the usual C names with contractions,
or using a Felix alias:
@p()
@begin_table("Felix name","Full C name")
@table_row("tiny","signed char")
@table_row("utiny","unsigned char")
@table_row("short","signed short int")
@table_row("ushort","unsigned short int")
@table_row("int","signed int")
@table_row("uint","unsigned int")
@table_row("long","signed long int")
@table_row("ulong","unsigned long int")
@table_row("vlong","signed long long")
@table_row("uvlong","unsigned long long")
@table_row("float","float")
@table_row("double","double float")
@table_row("ldouble","long double float")
@end_table()
@p()
The following aliases are also provided, in this
case the C name may not be used:
@p()
@begin_table("Felix name","C name")
@table_row("size","size_t")
@table_row("ptrdiff","ptrdiff_t")
@table_row("intptr","intptr_t")
@table_row("uintptr","uintptr_t")
@table_row("intmax","intmax_t")
@table_row("uintmax","uintmax_t")
@end_table()
@p()

The following aliases for exact integers are also provided, in this
case the C name may not be used:
@p()
@begin_table("Felix name","C name")
@table_row("int8","int8_t")
@table_row("uint8","uint8_t")
@table_row("int16","int8_t")
@table_row("uint16","uint16_t")
@table_row("int32","int32_t")
@table_row("uint32","uint32_t")
@table_row("int64","int64_t")
@table_row("uint64","uint64_t")
@end_table()
@p()
Felix guarantees all these integer aliases exist,
even if the C99 counterparts do not.
@p()
Complex number are provided with one of the follwing
bindings, dependent on the configuration.
@begin_table("Felix name","C name")
@table_row("complex","float _Complex")
@table_row("dcomplex","double _Complex")
@table_row("lcomplex","long double _Complex")
@end_table()
@p()
OR
@p()
@begin_table("Felix name","C++ name")
@table_row("complex","std::complex<float>")
@table_row("dcomplex","std::complex<double>")
@table_row("lcomplex","std::complex<long double>")
@end_table()
@p()
The choice between C99 and C++ complex types is
implementation dependent and very unfortunate.
@p()
In all these cases, where a long version of a type
is not provided by C or C++, such as long long and
long double, a distinct replacement type is used instead,
to ensure C++ level overloads are distinct.
@p()
[NOTE: THIS IS NOT IMPLEMENTED. The current system
just uses an alias.]
@p()
Arithmetic types support the same operations as ISO C99.
For the purpose of specifying bitwise operations on signed
types, they use a full two's complement representation.
Systems on machines with other representations must 
provide the appropriate glue logic.
@p()
Overflow of operations on signed types is undefined
behaviour. Operations on unsigned types cannot overflow
because it is defined as the modular residual of the
underlying operation on integers.
@p()
Thus, operations on exact unsigned integral types are fully
deterministic, and operations on signed integral types
are also deterministic when it does not overflow.
@p()
Felix also guarantees 'long' is at least twice the
length of 'short'.
@p()
[NOTE: THIS IS NOT IMPLEMENTED. Config check required.]

@head(3,"Character and String Types",nospawn=1)
Felix provides 3 character types and 3 corresponding
string types.
@p()
@begin_table("Felix name","C++ name")
@table_row("char","char")
@table_row("wchar","wchar_t")
@table_row("wchar","int32_t")
@table_row("string","std::basic_string<char>")
@table_row("wstring","std::basic_string<wchar_t>")
@table_row("ustring","std::basic_string<int32_t>")
@end_table()
Use of wchar and wstring is strongly discouraged,
and is only provided for compatibility. Char is guaranteed
to be an 8 bit clean representation. Note that unicode
character type uchar is signed two's complement full
32 bit encoding. Characters support comparison and
addition and subtraction of int.

@head(3,"Container Types",nospawn=1)

@head(1,"Applicative classes")
Felix provides several constructions which are called class
constructions (and their C++ representations are typically
C++ classes).
@p()
Of these, the most commonly used are the two kinds of
applicative class: functions and procedures. Objects
of these classes are known as closures.

@head(2,"Defining Functions",key="fundef")
Felix supports three syntactic forms for definining functions.
The simplest form is illustrated by:
@begin_displayed_code()
  fun f[t] (x:t, y:int): int * t => y,x;
@end_displayed_code()
You will note this function is polymorphic with one type
argument t, it accepts a single argument of tuple type t * int,
and returns a tuple of type int * t. The return type can be
omitted in this case because it can be deduced:

@begin_displayed_code()
  fun f[t] (x:t, y:int)=> y,x;
@end_displayed_code()

In this form, the function body is just an expression whose
elaboration yields the value returned by the function.
@p()
The second form allows procedural code in a function,
provided its side effects are limited to the scope
of the function, so that the function itself has no
side effects:

@begin_displayed_code()
  fun f[t] (x:t, y:int): int * t =
  {
    var z = y;
    z++;
    return z,x;
  }
@end_displayed_code()

In this form, the returned value is the argument of
the first return statement elaborated by the flow
of control. Again, the return type can be omitted if the
function type can be deduced. This is the most general
form, the first form is just synactic sugar for
@begin_displayed_code()
  fun f[t] (x:t, y:int): int * t =
  {
    return y,x;
  }
@end_displayed_code()
saving a few keystrokes, but greatly simplifying code
layout, and improving the ability of the programmer
to reason that the function has no side effects.
@p()
This form supports an extension to curry form:

@begin_displayed_code()
  fun f[t] (x:t) (y:int): int * t =
  {
    return y,x;
  }
@end_displayed_code()

which is short hand for

@begin_displayed_code()
  fun f[t] (x:t): int -> int * t =
  {
    fun g(y:int): int * t =
    {
      return y,x;
    }
    return g;
  }
@end_displayed_code()

Similarly, the first form also supports this extension.
@p()
The final form is 
@begin_displayed_code()
  fun f: u -> int  =
    | Empty => 0
    | Cons (_,?tail) => 1 + f tail
  ;
@end_displayed_code()

which is short hand for:

@begin_displayed_code()
  fun f(x:u):int =
    match x with
    | Empty => 0
    | Cons (_,?tail) => 1 + f tail
    endmatch
  ;
@end_displayed_code()

All these forms can be used anonymously wherever a
function closure is required, by simply enclosing them
in parentheses and omitting the function name:

@begin_displayed_code()
  print$ (fun f[t] (x:t, y:int)=> y,x) (1,2);
@end_displayed_code()

This is called the lambda form of the function,
such lambda forms are first class expressions.
@p()
Two special cases of the lambda forms can be used for functions:

@begin_displayed_code()
  { x }
@end_displayed_code()

is a function with unit argument, returning value x, and is short
hand for:
@begin_displayed_code()
  (fun()=>x)
@end_displayed_code()

and

@begin_displayed_code()
  { var y = x; ++x; return x; }
@end_displayed_code()

is short hand for

@begin_displayed_code()
  (fun () = { var y = x; ++x; return x; })
@end_displayed_code()

You should note very carefully the following
are NOT equivalent:

@begin_displayed_code()
  fun f()=>x;
  val f = { x };
@end_displayed_code()

The first line defines a function f, but does not
form a closure. The second line stores a closure of
an anonymous function into value f. Although any
application of either f is equivalent, the lookup
rules for variable and function names are distinct.
Function names can be overloaded, and lookup choses
the right function to use in an application based
on the function argument.
@p()
Variable names, even if used applicatively, 
do not participate in overload resolution.
@p()
Felix also allows functions to provide pre-conditions
and post-conditions. Here is an example:

@begin_displayed_code()
  fun f(x: int, y:int when x+y>0): int expect result > 0 =
  {
    return x + y;
  }
@end_displayed_code()
The special identifier result is used to denote the 
value returned by the function. Pre and post conditions are
part of the intuitive function type, but they are not part of the 
formal type. Instead, pre and post conditions are checked prior
to and after function application, respectively, and abort the
program if the conditions are not met.

@head(3,"Lazy value Types",nospawn=1)
A lazy value type is a function type with the domain 0 or void.
A value of such a type can be constructed and used with syntax like:
@begin_displayed_code()
   var y = 1.0;
   fun x = sin y;
   print x; endl;
   var y = 0.5;
   print x; endl;
@end_displayed_code()
The function x is semantically equivalent to a function taking
unit argument, however each reference to x is automatically
applied to the unit value () wherever it is written. In effect,
such a function looks like a value whose body is substituted
for each reference to it. This is also how it is implemented.
In particular in the example, the output will be the
value sin 1.0 and sin 0.5.


@head(2,"Defining Procedures",key="procdef")
Felix supports three syntactic forms for definining procedures.
The simplest form is illustrated by:
@begin_displayed_code()
  proc f[t] (x:t, y:int) { print y; h x; }
@end_displayed_code()
You will note this function is polymorphic with one type
argument t, it accepts a single argument of tuple type t * int.
@p()
This form supports an extension to curry form:

@begin_displayed_code()
  proc f[t] (x:t) (y:int) 
  {
    print y; h x;
  }
@end_displayed_code()

which is short hand for

@begin_displayed_code()
  fun f[t] (x:t): t -> (int -> void) =
  {
    proc g(y:int) =
    {
      print y; h x;
    }
    return g;
  }
@end_displayed_code()
Procedures also support lambda abstraction:

@begin_displayed_code()
  (proc (x:int, y:int) { print y; h x; }) (1,2);
@end_displayed_code()
A special form can be used for procedures with unit argument:
@begin_displayed_code()
  { print "Hello"; endl; }
@end_displayed_code()

is a procedure with unit argument, and is short hand for:
@begin_displayed_code()
  (proc(){print "Hello"; endl; })
@end_displayed_code()

You should note very carefully the following
are NOT equivalent:

@begin_displayed_code()
  proc f(){ print "Hello"; endl; }
  val f = { print "Hello"; endl; }
@end_displayed_code()

The first line defines a procedure f, but does not
form a closure. The second line stores a closure of
an anonymous procedure into value f. Although any
application of either f is equivalent, the lookup
rules for variable and function names are distinct.
Procedure names can be overloaded, and lookup choses
the right procedure to use in an application based
on the procedure argument.
@p()
Variable names, even if used applicatively, are never
overloaded and do not participate in overload resolution.
@p()
Felix also allows procedures to provide pre-conditions.
Here is an example:

@begin_displayed_code()
  proc f(x: int, y:int when x+y>0)
  {
    print (x + y); endl;
  }
@end_displayed_code()

@head(1,"Bindings")
Felix provides extensive support for binding C/C++.
Whilst many languages provide an FFI (Foreign Function
Interface) which allows glue logic to be written in C, 
Felix uses the C/C++ object model directly, and provides
the ability to bind to C/C++ data types and functions
directly in the language. In most cases these bindings
do not require any executable glue code, instead,
the bindings simply provide a map between the type systems.

@head(2,"Binding types")
Felix allows you to bind types like:
@begin_displayed_code()
  type myint = "int";
@end_displayed_code()
When the target and source names are the same, the
source string can be elided, and multiple type
named at once:
@begin_displayed_code()
  ctypes int, long, complex;
@end_displayed_code()
The type must be a first class type, that is,
allocable, default initialisable, copy constructible,
copy assignable, and destructible. 
@p()
Non-first class type may also be introduced with
the keyword incomplete:

@begin_displayed_code()
  incomplete type myvoid = "void";
@end_displayed_code()

and may only be used as the argument of a pointer 
type constructor or argument to a binding construction
for which the type makes sense in C/C++ context.
For example:

@begin_displayed_code()
  type pt[t]="?1*";
  typedef voidp = pt[void];
@end_displayed_code()

is acceptable usage because void* is a first class
data type.
@p()
It is also possible to state that a type is a C++ POD,
or Plain Old Data type:

@begin_displayed_code()
  pod type int = "int";
@end_displayed_code()

In such a case, the garbage collector may elide applying
a finalisation function to the type, improving performance.
@p()
The decoration:
@begin_displayed_code()
  _gc_pointer type int = "X*";
@end_displayed_code()

tells the garbage collector the type is a pointer
to Felix heap storage, and should be traced by the
collector sweep when determining if storage is reachable.
In this case, the pointer may be NULL, otherwise it must
point to the client data part of a storage frame
allocated by the collector. Such an type this denotes
managed storage. This annotation is primarily provided
so programmers developing Felix types in C++ can tell
the Felix compiler the type is Felix compliant.
@p()
Type abstractions can be polymorphic. For example:
@begin_displayed_code()
  type vector[t] = "vector<?1>";
@end_displayed_code()
Here the special encoding ?1 refers to the first
type parameter. 
@p()
Type bindings may also have a requirements clause:
@begin_displayed_code()
  type vector[t] = "vector<?1>" requires vector_h;
@end_displayed_code()
See 
@ref_anchor("requirements")
 for more details.

@head(2,"Binding constants")
Felix provides a way to lift C/C++ expressions directly
into Felix:
@begin_displayed_code()
  const pi : double = "M_PI";
  const M_PI : double;
  const myval[t] : int = "(?1)(x+y)";
@end_displayed_code()
When the target and source names are the same,
the source string can be elided.
@p()
When used in an expression, the Felix symbol is 
replaced by the correspondong C code, with substitution
of type variables if necessary.
@p()
The const declaration is a short form for a function
with no arguments. Const definitions can also have
requirements clauses. See 
@ref_anchor("requirements")
 for more details.

@head(2,"Requirements Specifications",key="requirements")

@head(1,"Expressions",key="expr")
The principal syntactic combinator used to construct expressions
are application and pattern matching, however Felix 
also has a rich set of builtin operator patterns, and there
is support for extensible grammar productions which allow
arbitrary bracket operators, and binary operators at 
pre-determined precedences. See also
@ref_anchor("preprocessor")
 for more details on syntax extensions.
@p()
@begin_table("operation "," associativity "," symbols "," function name "," description")
@table_row("let ","left ","let in")
@table_row("lambda ","left ","fun proc")
@table_row("dollar_apply ","left ","$")
@table_row("tuple ","nary ",",")
@table_row("or_condition ","nary ","or ","lor ","logical or")
@table_row("and_condition ","nary ","and ","land ","logical and")
@table_row("not condition ","prefix ","not ","lnot ","logical not")
@table_row("comparison ","chain ","< ","lt ","less than")
@table_row("","","<= ","le ","less or equal")
@table_row("","","== ","eq ","equal")
@table_row("",""," != ","ne ","not equal")
@table_row("","",">= ","ge ","greater or equal")
@table_row("","","> ","gt ","greater")
@table_row("","","&< &<= &== &!= &>= &>")
@table_row("as_expr ","left ","as")
@table_row("setunion ","nary ","|| ","","union")
@table_row("user 10 ","left ","user defined")
@table_row("setintersection ","nary ","&& ","","intersection")
@table_row("arrow ","right ","-> ","","function (type)")
@table_row("case_literal ","","case of ","","case selector")
@table_row("bor ","left ","\\| ","bor ","bitwise or")
@table_row("bxor ","left ","\\^ ","bxor ","bitwise exclusive or")
@table_row("band ","left ","\\& ","band ","bitwise and")
@table_row("shift ","left ","<< ","shl ","left shift")
@table_row("","",">> ","shr ","right shift")
@table_row("sum ","nary ","+ ","add ","addition")
@table_row("subtraction ","left ","- ","sub ","subtraction")
@table_row("product ","nary ","* ","mul ","multiplication")
@table_row("term ","left ","/ ","div ","quotient")
@table_row("","","% ","mod ","remainder")
@table_row("prefixed ","prefix ","lval ","lvalue (type)")
@table_row("","","+ ","unary plus ","")
@table_row("","","- ","neg ","negation")
@table_row("","","~ ","compl ","bitwise complement")
@table_row("power ","right ","** ","pow ","real power")
@table_row("superscript ","left ","^ ","","exponential")
@table_row("refr ","prefix ","& ","","address")
@table_row("","","* ","","dereference")
@table_row("application ","left ","whitespace ","function application")
@table_row("","","caseno ","","case number")
@table_row("coercion ","left "," : of ","","annotation (type)")
@table_row("factor ","postfix ",". ","","struct component")
@table_row("","",".[] ","subscript ","array component")
@table_row("","",".() ","","tuple component")
@table_row("","","noexpand ","","macro inhibitor")
@table_row("atom")
@table_row("")
@table_row("")
@table_row("")
@end_table()

@head(2,'Let/In')
The let/in construction is modelled on Ocaml: it has the lowest
operator precedence.
@begin_displayed_code()
  let pattern = expr1 in expr2
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  match expr1 with pattern => expr2 endmatch
@end_displayed_code()


@head(2,"Coercions",key="coercion")
@head(2,"Record Coercions",key="record coercion")

@begin_displayed_code()
  typedef isd = 
    struct 
    {
      a:int;
      b:string;
      c:double;
    }
  ;

  typedef id = 
    struct 
    {
      a:int;
      c:double;
    }
  ;
  val x : isd = struct { a=1; b="Hello"; c=9.2; };
  val y : id = x : id; // coercion
@end_displayed_code()

@head(2,"Pattern match")

[Needs attention]

To be written.
@head(1,"Statements")
@head(2,"Definitions",nospawn=1)
@head(3,"Modules",nospawn=1)
@head(2,"Executable Statements",nospawn=1)
Conditions in macros, including chains, conditional
goto, call, and return, are subject to constant folding.
If the condition is constant, and can be folded, Felix
guarantees compile time shortcut evaluation, eliminating
branches which can never execute.
@p()
It is therefore required that code in such branches
be well formed syntactically, and meet syntactic
constraints, but the code is not subject to lookup
and in particular does not have to be correctly typed.
@p()
Other conditions, such as those used by higher order
functions, may be determined to be uni-valued
and a branch optimised away, however this is done
after type checking. In such cases, the code does not
need to bind to C/C++ correctly, and in particular
incorrect bindings will not cause C++ compile time errors.
Be warned that such optimisations are fragile, and small
changes to the program may suddenly introduce C++
compile time errors in code that previously appeared
to be correct at the C++ level.

@head(3,"No operation",nospawn=1)
There are three forms of no-op in Felix:
@begin_displayed_code()
    ; // lone ;
    todo "Comment";
    comment "Comment";
@end_displayed_code()
The todo and comment statements are identical in
the abstract semantics, however the todo statement
may be used to indicate an incomplete section of
code, and a compiler switch may permit tracing
execution of such code, and perhaps aborting
with a diagnostic.

@head(3,"Goto",nospawn=1)
The goto statement is used to transfer control to any
visible label.
@begin_displayed_code()
  label:>
    goto label;
@end_displayed_code()
There may be a label before or after any executable statement.
There is also a conditional form:
@begin_displayed_code()
  label:>
    if cond goto label;
@end_displayed_code()

@head(3,"Call",nospawn=1)
Felix provides the call statement to execute a procedure:
@begin_displayed_code()
  call f x;
@end_displayed_code()
This may be shortened to the form:
@begin_displayed_code()
  f x;
@end_displayed_code()
A call of the form:
@begin_displayed_code()
  call f ();
@end_displayed_code()
may be shortened even more to just:
@begin_displayed_code()
  f;
@end_displayed_code()
You should not in particular that:
@begin_displayed_code()
  { var x = 1; print x; };
@end_displayed_code()
is an instance of this shortform. Although this
looks like a block in C, with gratuitous trailing
semi-colon ";", it is in fact a shortform anonymous
procedure (lambda) with shortform call, equivalent to:
@begin_displayed_code()
  (proc(){ var x = 1; print x; })();
@end_displayed_code()
but terser. This explains that the trailing semi-colon
is not in fact gratuitous: it is required to terminate
the statement.
@p()
A call of the form:
@begin_displayed_code()
  f (x,y,z);
@end_displayed_code()
may be written as
@begin_displayed_code()
  f$ x,y,z;
@end_displayed_code()
in the same manner as for dollar-application operator
in expressions.
@p()
There is also a conditional call:
@begin_displayed_code()
  if cond call f x;
@end_displayed_code()
The argument of call, and the shortened forms 
have the syntax of an expression. If the expression is
an application, it is taken as a call applying the
first argument of the application to the second,
if the expression is not an application, it is taken
as an application of the whole expression to ().
@p()
The special form:
@begin_displayed_code()
  jump f x;
@end_displayed_code()
is equivalent to:
@begin_displayed_code()
  call f x;
  return;
@end_displayed_code()
but is explicitly a tail call. The special form
@begin_displayed_code()
  loop f x;
@end_displayed_code()
is a special tail call, subject to the constraint that
f must be the name of this procedure, or one of its ascendants,
which is explicitly a tail recursive call. Felix optimised both
kinds of tail calls, however they are recognized even if the
explict tail call syntax is not used. 
@p()
If the first projection of the argument of a procedure
which is a tuple type is a pointer type, then the procedure
may also be called as indicated with the following syntax:
@begin_displayed_code()
  proc f(a:&int,b:string) ..
  var &x:int <- f "Hello";
@end_displayed_code()
The arrow form suggests that return values from procedures
with a pointer as the first parameter should be used to
return values, however the syntax precludes the use of
such a procedure in an expression: it looks like a
function returning a value, but the procedure above
actually just stores a result in the variable x
and returns.

@head(3,"Return",nospawn=1)
The return statement:
@begin_displayed_code()
  return;
@end_displayed_code()
is used to return control to the caller of a procedure.
If the procedure an initial procedure, control is returned
to the embedding driver, usually flx_run.
@p()
The return statement:
@begin_displayed_code()
  return expr;
@end_displayed_code()
is used to return a value from a function.
@p()
There are also conditional return shortforms:
@begin_displayed_code()
  if cond return expr;
@end_displayed_code()

@head(3,"Assignment",nospawn=1)
An lvalue pattern is either a single variable, or a tuple
of lvalue patterns.
@p()
Felix supports two assignment operators:
@begin_displayed_code()
  lval = expr;
  lval <-> lval;
@end_displayed_code()
The first form is a traditional assignment. The LHS must
be an lvalue pattern matching the RHS. The semantics are value 
preserving for Felix types, and use C++ assignment for C++ types.
@p()
The second form requires two lvalues patterns, and exchanges
the values store in the two lvalues in parallel.

@head(3,"Assertions",nospawn=1)
Felix supports several kinds of assertions.
@head(4,"assert",nospawn=1)
@head(4,"reduce",nospawn=1)
@head(4,"check",nospawn=1)
@head(4,"Axiom",nospawn=1)
@head(3,"Standard Control Macros",nospawn=1)
Felix provides a number of standard control macros.
Each of these is defined in terms of conditional gotos.
Note in particular that bodies of these macros are not blocks:
any symbol declared in such a block is visible in the whole
of the current scope.

@head(3,"Condition chain",nospawn=1)
The standard conditional chain looks like:
@begin_displayed_code()
  if expr do 
    statement;
    ...
  elif expr do
    statement;
    ..
  else
    statement;
    ..
  done;
@end_displayed_code()
The else and elif clauses are optional.

@head(3,"loops",nospawn=1)
Felix provides several general loops.
@p()
The whilst loop has the form:
@begin_displayed_code()
  whilst cond do statement; .. done;
@end_displayed_code()
which tests cond, then executes the statements
between do and done and repeats, provided the 
condition is true.
@p()
The until loop has the form:
@begin_displayed_code()
  until expr do statement; .. done;
@end_displayed_code()
which tests cond, then executes the statements
between do and done and repeates, provided the
condition is false.
@p()
The counting loops:
@begin_displayed_code()
  forall id in e1 upto e2 do statement; .. done;
  forall id in e2 downto e1 do statement; .. done;
@end_displayed_code()
execute statements for all values of the integer 
variable id between e1 and e2 inclusively, differing
only in the order of iteration. The terminal expression 
is re-evaluated every pass of the loop.

@head(3,"Standard Control Procedures",nospawn=1)
Felix also provides higher order functions (HOFs) in the
library, which provide a higher level, more
structured set of control operators. These are
prefered to the low level control macros, since
they properly localise variables in branches
and loop bodies.
@p()
The function while is declared:
@begin_displayed_code()
  proc while (cond:unit->bool) (bdy:unit->void)
@end_displayed_code()
The first argument is a function returning a bool
and is known as the condition, the second is
a procedure of unit. The condition is applied to ()
and if the result is true the procedure is applied to (),
repeatedly until the condition application returns false.
It is used with the C like syntax:
@begin_displayed_code()
  while { cond } { body; .. };
@end_displayed_code()
Note the terminal ; is required to actually execute
the loop.
@p()
The function for_each emulates a C for loop:
@begin_displayed_code()
  proc for_each
    (init:unit->void)
    (cond:unit->bool)
    (incr:unit->void)
    (bdy:unit->void)
@end_displayed_code()
It executes the initial condition first.
Then it tests the condition, then if the
condition is true, executes the body, then executes the 
increment and repeats.

@head(1,"Processing Phases")
Like C, Felix processes code in well defined phases,
however the phasing is not per program as in C,
but per parse unit for early phases, and per program
for late phases.
@begin_list("keyed")
@item("Hash-pre-processor")
This processor lexes on a linewise bases. Lines beginning
with the # symbol are managed by the hash-pre-processor.
Other lines may also be skipped as a result of # conditional
compilation. The # pre-processor may also recursively
include files, which by convention use ".flxh" suffix.
The # preprocessor outputs a token stream.

@item("Token-pre-processor")
The token pre-processor accepts the hash-preprocessor
output token stream and produces another token stream
as its output. It is used to prepare the input stream
for the parser, by rewriting certain constructs
which are not parsable by an LALR parser.
@p()
It currently consists of a sequence
of filters:
@begin_list("keyed")
@item("White filter")
White filtering elides whitespace, end of line,
and free form comments.

@item("Int filter")
The 'int' filter replaces sequences of tokens representing
ISO C99 arithmetic type names with the corresponding
Felix equivalent. For example "long long" is replaced
by "vlong".
@end_list()

@item("Parser")
The parser accepts a token stream constructed by the
token level preprocessor, parses it, applies syntactic
constraints, and generates an Syntax Tree (AST).
[The tree is technically not abstract but we call
it an AST anyhow]

@item("Syntax Macro Processor")
The syntax macro processor is a high end macro processor
which operates on the AST. In particular it respects scope
and syntactic kind, so that, for example, the result of
macros in a subexpression are restricted to that subexpression,
and the result is an expression.
@p()
In particular, syntax macros 
also respect block scope and file scope. Therefore, if you
prepare syntax macros in a separate file, you must
#import or #include the file, to export the macros. Macros defined in
a file included by an include directive are only recognized
within that file (after other phases of processing of course).

@item("Desugarer")
The desugarer is responsible for mapping some higher
level constructions of the grammar to lower level 
primitives, and also for recognizing certain special
identifiers in certain contexts, and performing
rewriting operations, thus avoiding the introduction
of too many keywords. 
@p()
It also handles elision of
conditional constructions nased on constant conditions,
and the
recursive conditional desugaring of files denoted
by include directives. The include facility caches
the results of syntax macro processing, and inclusion
is subject to time-stamp checking to relieve the
compiler from expensive front end processing.
The caches have the extension ".par". 
@p()
Desugaring
is also responsible for splitting scoped entities
into one of three kinds of statement forms: directives,
definitions and executable. Some statements, notably
variable initialisations, can generate both a definition
and an executable component.

@item("Symbol Table construction")
The symbol table contructor is responsible for
translation of the hierarchical forms output
by the desugarer

@item("Name Binder")
The name binding (lookup) phase is responsible for
translating the AST into a set of bound definitions.
This is the slowest phase of compilation, and involves
all overload resolution. The name binder is fully
polymorphic. Note in Felix, definitions are not
sequential: all definitions may depend on definitions
in the same scope or any definition in an ancestor.
There is no need to provide forward declarations
to support recursion (and indeed there is no syntax
for it).

@item("Optimiser")
Felix has a high end optimiser which primarily
functions by inlining and substitution. However
the optimiser also does usage analysis, and
eliminates unused components.

@item("Code Generator")
The code generator is responsible for translating
optimised sets of definitions into files which
are subsequently processed by the C++ compiler.
The code generator also applies the instantiator,
which is used to instantiate polymorphic entities.
This instantiation is transient and purely functional:
no instantiated definitions are ever created, 
except in the ouput C++ code.

@item("C++ Compilation")
This phase invokes the client C++ compiler and linker
to generate object files, libraries, shared libraries
and/or programs. It may include or link to 
standard Felix run time library (RTL) support code,
and/or standard Felix driver routines.

@item("Execution")
The binaries generated by C++ compilation are finally
executed. If dynamic linkage was chose in the 
C++ compile/link phase, this phase includes loading
of the support code, and loading of the user application
code by the chosen driver.

@end_list()

@head(1,'Hash Preprocessor')
The hash preprocessor parses and acts on lines
whose first non-whitespace character is #.
It includes support for conditional compilation,
file inclusion, and introduction of user defined
keywords, statements and expressions.

@head(2,'Conditional compilation',nospawn=1)
@begin_list("keyed")
@item("#define")
@item("#if")
@item("#ifdef")
@item("#ifndef")
@item("#elif")
@item("#else")
@item("#endif")
@end_list()

@head(2,'File inclusion',nospawn=1)
@begin_list("keyed")
@item("#include")
@item("#import")
@end_list()

@head(2,'User defined Syntax',nospawn=1)
@begin_list("keyed")
@item("#keyword")
@item("#statement")
@item("#infix")
@item("#bracket")
@end_list()

@head(2,'User defined Statements',nospawn=1)
@head(2,'User defined Operators',nospawn=1)

@head(1,'Syntax Macro Processor')
@head(2,'Special constructions',nospawn=1)
@head(3,"Generic Iterator",nospawn=1)
Felix also provides a generic iterator, for examle:
@begin_displayed_code()
  forall id in 1,2,3 do print i; endl; done;
@end_displayed_code()
This is actually a shortcut for:
@begin_displayed_code()
  macro for val i in in 1,2,3 do print i; endl; done;
@end_displayed_code()
which generates:
@begin_displayed_code()
  print 1; endl; 
  print 2; endl; 
  print 3; endl; 
@end_displayed_code()
The generic iterator is built from a combination
of user defined syntax and the syntax macro processor.

@head(1,"Synchronous Multithreading",key="sync")
Felix provides a simple but model of synchronous threading.
It is especially designed so this threading is extremely
fast and lightweight. Millions of threads can easily be
supported on desktop machines, and contest switching
times are roughly the same time as subroutine calling.
@p()
Synchronous threads are sometimes called fibres. Sets of such
threads fibrate a single pre-emptive thread. Each fibre is
guarranteed to interleave execution serially within
the same pre-emptive thread, so that no low level synchronisation
primitives are required to ensure data is accessed atomically.
You should not that at high levels of abstraction, context
switches may still occur within what logically must be treated
as an atomic operation: mutual exclusion is still required.
However we do not provide any locking primitives for fibres.
Instead, the sole synchronisation primitive consists of an
object called a schannel, together with two functions, read
and write, which purport to read or write data from or to
the channel.
@p()
In fact, synchronous channels are not buffers and never
hold or transmit any data, rather they are are used
to synchronise and control flow in one or more fibres.
@p()
A fibre is created by the spawn_fthread procedure
which accepts a procedure of type
@begin_displayed_code()
  1 -> 0 
@end_displayed_code()
as an argument. It is typically used like:
@begin_displayed_code()
  spawn_fthread { thread_routine; .. };
@end_displayed_code()
It is unspecified whether the spawned routine or the
spawning routine resumes execution first.
@p()
A bidirectional synchronous channel and associated
read and write operations have types:
@begin_displayed_code()
  fun mk_schannel[t]: unit -> schannel[t];
  proc read: &t * schannel[t];
  proc write: schannel[t] * t;
@end_displayed_code()
  

@head(1,"First order polymorphism",key="poly1")
All Felix nominal types support first order
polymorphism by way of type schema:

@begin_displayed_code()
type x[U,V] ..
fun f[U,V] ..
proc g[U,V] ..
class k[U,V] ..
struct s[U,V] ..
union u[U,V] ..
cstruct c[U,V] ..
cclass k[U,B] ..
@end_displayed_code()
All such definitions are intrinsically polymorphic:
the lack of an explicit schema designator:
@begin_displayed_code()
  fun f(x:int)=>x;
@end_displayed_code()
is simply shorthand for a unit schema:
@begin_displayed_code()
  fun f[](x:int)=>x;
@end_displayed_code()
@p()
In addition, modules may also have type schema, however
this is just sugar. The semantics are to prepend the schema to the 
schema of every definition in the module:
@begin_displayed_code()
  module X[T] {
    fun f(x:int)=>x;
    fun g[U](x:int)=>x;
  }
@end_displayed_code()
is equivalent to:
@begin_displayed_code()
  module X {
    fun f[T](x:int)=>x;
    fun g[T,U](x:int)=>x;
  }
@end_displayed_code()
@p()
In addition, typdefs may have schema:
@begin_displayed_code()
  typedef pair[T] = T * T;
@end_displayed_code()
Such a parameterised type alias is a special kind
of type function or type functor:
@begin_displayed_code()
  typedef fun pair(T:TYPE):TYPE => T * T;
@end_displayed_code()
@p()
Type schema parameters also individual constraints:
@begin_displayed_code()
  fun f[I:fast_sints] ..
@end_displayed_code()
says that the type variable I must be instantiated
with a member of the typeset of fast_sints. Discrete
typesets can be named by a typedef:
@begin_displayed_code()
  typedef fast_sints = typesetof (tiny, short, int, long, vlong);
@end_displayed_code()
The union and intersection of such sets may be calculated
with the setwise union and intersection operators:
@begin_displayed_code()
typedef A = B || C && D;
@end_displayed_code()
with the usual precedence.

