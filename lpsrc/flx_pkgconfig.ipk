@head(1,'pkg-config replacement')
This program provides roughly the same functionality as
the pkg-config program. It isn't the same, however,
and it uses its own files. As usual other people's software
is harder to modify so it work right than to do it oneself;(
@p()
This program should be compiled static with Felix, as early
as possible, since it is needed to compile Felix code
which uses extensions, plugins, or whatever.
Maybe the tarball should even include the C++ sources,
so it can be built early enough.

@h = tangler("pkg/flx_pkgconfig.py")
@select(h)

# 
# we can't use flx_pkgconfig to supply platform
# libraries .. because this IS flx_pkgconfig --
# so it isn't built yet!!
#
FLXFLAGS = ""
if WIN32:
  if HAVE_MSVC:
    FLXFLAGS = "/DEFAULTLIB:ws2_32 /DEFAULTLIB:mswsock "
  else:
    FLXFLAGS = "-lws2_32 -lmswsock "
    
pkg_requires = ['flx_compiler','flx_drivers']
felix_tools = [('tools/flx_pkgconfig','bin/flx_pkgconfig')]
felix_requires_linkflags = FLXFLAGS
iscr_source = ['lpsrc/flx_pkgconfig.ipk']

@h = tangler("tools/flx_pkgconfig.flx","data")
@select(h)
#import <flx.flxh>
open String;
open List;
open System;
open Env;
open Filename;
open Text_file;

var path=getenv("PKG_CONFIG_PATH");

// parse arguments
var fields = Empty[string];
var pkgs = Empty[string];
var i = 1;
var arg = argv i; 

var hide = false; // only find first file in path
var require_pkg_exists = false; // fail if file not found
var require_field_exists = false; // fail if file doesn't contain field
var recursive = false;

whilst arg != "" do
  if "--field=" == arg.[0 to 8] do
    fields = fields + arg.[8 to];

  elif "--hide" == arg.[0 to 6] do
    hide = true;

  elif "--pkg-exists" == arg.[0 to 12] do
    require_pkg_exists = true;

  elif "--field-exists" == arg.[0 to 14] do
    require_field_exists = true;

  elif "--recursive" == arg.[0 to 11] do
    recursive = true;

  elif "--path=" == arg.[0 to 7] do
    path= arg.[7 to];

  elif "--path+=" == arg.[0 to 8] do
    val x = arg.[8 to];
    if path != "" do
      path= path + ":" + x;
    else
      path= x;
    done;

  else
    pkgs = pkgs + arg;
  done;

next:>
  ++i;
  arg = argv i;
done;

fun str: list[string] -> string =
  | Cons (?e,?t) => e + " " + str t
  | Empty => ""
;

//print$ "Fields   = " + str fields; endl;
//print$ "Packages = " + str pkgs; endl;

val dirs=split(path, chr ':');

//print$ "Path = " + str dirs; endl;

var result = Empty[string];

fun get_field(line:string):string * string = 
{
  var n = find (line,chr ':');
  return
    if n != npos then
        trim line.[to n],
        trim line.[n+1 to]
    else
      "",""
    endif
  ;
}

var handled_pkgs = Empty[string];

proc handle_pkg (pkg:string){
   var found = false;
   iter(proc (dir:string){
     val filename = if dir=="" then "." else dir endif + sep + pkg + ".fpc";
     //print filename; endl;
     // examine lines of one file
     file := fopen_input filename;
     if valid file do
       var line = readln file;
       whilst line != "" do
         //print line;
         var n = find (line,chr ':');
         def val key, val value = get_field(line);
         if mem (eq of (string * string)) fields key do
           if not (mem (eq of (string * string)) result value) do
             result = result + value;
           done;
         done;
         if 
           recursive and key == "Requires" and
           not mem (eq of (string * string)) pkgs key and
           not mem (eq of (string * string)) handled_pkgs key
           do
             pkgs = Cons (value, pkgs);
         done;
         line = readln file;
       done;
       fclose file;
       found = true;
       if hide return; // only find first file in path
     done;
   })
   dirs;
   if not found and require_pkg_exists call System::exit 1;
}

whilst not is_empty pkgs do
  match pkgs with
  | Empty => {}
  | Cons (?pkg,?tail) => 
    { 
      pkgs = tail;
      handled_pkgs = Cons(pkg,handled_pkgs);
      handle_pkg(pkg); 
    }
  endmatch;
done;

print$ str result; endl;
System::exit 0;

