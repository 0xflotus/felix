@import config

@set_title('STL')
@head(1,'Stl library')
@h=tangler('lib/stl.flx','data')
@select(h)
include "std";
header std_stl_vector = "#include <vector>";
header std_stl_list = "#include <list>";
header std_stl_deque = "#include <deque>";
header std_stl_queue = "#include <queue>";
header std_stl_set = "#include <set>";
header std_stl_map = "#include <map>";
header std_stl_stack = "#include <stack>";
@if config.TARGET_CXX.options.HAVE_STL_GNU_CXX:
  tangle('header ext_hash_set = "#include <ext/hash_set>";')
  tangle('header ext_hash_map = "#include <ext/hash_map>";')
  tangle('header ext_slist = "#include <ext/slist>";')

// hash for std::string for use with hash containers
header ext_string_hash = """
  namespace __gnu_cxx {
    template<> struct hash<std::string> {
      size_t operator()(std::string const& s)const;
    };
  }
""";

body ext_string_hash = """
// this is a sick hash .. fix it!
size_t __gnu_cxx::hash<std::string>::
  operator()(std::string const& s)const {
    char const *p = s.data();
    int n = s.size();
    int h = 0;
    for(; n; --n,++p) h+= 5 * *p;
    return h;
  }
""";

@#------------- STL CONTAINERS -----------------------
@def mkseq(n,ns='std'):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'

  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1>";')
  tangle('    fun create : unit -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>())";')
  tangle('    fun create : int * t -> '+c+'= "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>($1,$2))";')
  tangle('    fun create[i] : i * i -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>($1,$2))";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1>::iterator";');

@def mkrseq(n,ns='std'):
  mkseq(n,ns)
  c = 'stl_'+n+'[t]'
  rit = 'stl_'+n+'_reverse_iterator[t]'
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1>::reverse_iterator";');


@def mkinsat(n):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'
  tangle('    proc insert: '+c+' * '+it+' *  t  = "$1.insert($2,$3);";')

@def mkpuf(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc push_front : '+c+' *  t  = "$1.push_front($2);";')

@def mkpub(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc push_back : '+c+' *  t  = "$1.push_back($2);";')

@def mkpof(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc pop_front : '+c+' = "$1.pop_back();";')

@def mkpob(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc pop_back : '+c+' = "$1.pop_back();";')

@def mkfront(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun front : '+c+' -> t = "$1.front()";')

@def mkback(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun front : '+c+' -> t = "$1.front()";')

@def mksub(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun subscript : lvalue['+c+'] * int -> lvalue[t] = "$1.at($2)";')
  tangle('    fun subscript : '+c+' * int -> t = "$1.at($2)";')

@def mkset(n,ns='std'):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'
  rit = 'stl_'+n+'_reverse_iterator[t]'
  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1>";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1>::iterator";')
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1>::reverse_iterator";')
  tangle('    fun create : unit -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>())";')

  tangle('    proc insert : '+c+' * t = "$1.insert($2);";')
  tangle('    fun find : '+c+' * t ->  '+it+' = "$1.find($2)";')
  tangle('    fun mem : '+c+' * t -> bool = "$1.find($2) != $1.end()";')

@def mkass(n,ns='std'):
  c = 'stl_'+n+'[k,v]'
  it = 'stl_'+n+'_iterator[k,v]'
  rit = 'stl_'+n+'_reverse_iterator[k,v]'
  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1,?2>";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1,?2>::iterator";')
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1,?2>::reverse_iterator";')

  tangle('    fun create : unit -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1,?2>())";')
  tangle('    fun subscript: '+c+' * k -> lvalue[v] = "$1[$2]";')
  tangle('    fun find : '+c+' * k ->  '+it+' = "$1.find($2)";')
  tangle('    fun mem : '+c+' * k -> bool = "$1.find($2) != $1.end()";')
  tangle('    proc insert : '+c+' * k * v = "$1.insert(std::make_pair($2,$3));";')

@def mkfor(it,ts,kv=None):
  if kv == None: kv = ts
  tangle('  instance Eq['+it+'] {')
  tangle('    fun eq: '+it+' * '+it+' -> bool = "$1==$2";')
  tangle('  }')

  tangle('  instance Tord['+it+'] {')
  tangle('    fun lt: '+it+' * '+it+' -> bool = "$1<$2";')
  tangle('  }')

  tangle('  instance Iterator['+it+','+kv+'] {')
  tangle('    fun deref : '+it+' ->  lvalue['+kv+']  = "*(#0*)(void*)&*$1";')
  tangle('  }')

  tangle('  instance Forward['+it+'] {')
  tangle('    fun succ: '+it+' -> '+it+' = "$1+1";')
  tangle('    proc pre_incr : lvalue['+it+'] = "++$1;";')
  tangle('    proc post_incr : lvalue['+it+'] = "++$1;";')
  tangle('  }')

  tangle('  instance Forward_iterator['+it+','+kv+'] {}')

@def mkbidir(it,ts,kv=None):
  if kv == None: kv = ts
  mkfor(it,ts,kv)
  tangle('  instance Bidirectional['+it+'] {')
  tangle('    fun pred: '+it+' -> '+it+' = "$1-11;";')
  tangle('    proc pre_decr : lvalue['+it+'] = "--$1;";')
  tangle('    proc post_decr : lvalue['+it+'] = "--$1;";')
  tangle('  }')

  tangle('  instance Bidirectional_iterator['+it+','+kv+'] {}')

@def tcmkseq(n):
  c = n+'[t]'
  it = n+'_iterator[t]'
  tangle('  instance Eq['+n+'[t]] {')
  tangle('    fun eq: '+c+' * '+c+' -> bool = "$1==$2";')
  tangle('  }')

  tangle('  instance Container['+c+',t] {')
  tangle('    fun len: '+c+' -> size = "$1.size()";')
  tangle('    fun empty: '+c+' -> bool = "$1.empty()";')
  tangle('  }')

  tangle('  instance Sequence['+c+','+it+',t] {')
  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    proc erase : lvalue['+c+'] * '+it+' = "$1.erase($1);";')
  tangle('    proc erase_between : lvalue['+c+'] * '+it+' * '+it+' = "$1.erase($1,$2);";')
  tangle('    proc clear : lvalue['+c+'] = "$1.clear();";')
  tangle('  }')

@def tcmkrseq(n):
  c = n+'[t]'
  it = n+'_iterator[t]'
  rit = n+'_reverse_iterator[t]'

  tangle('  instance Reversible_Sequence['+c+','+it+','+rit+',t] {')
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')
  tangle('  }')

@def tcmkass(n):
  c = n+'[k,v]'
  it = n+'_iterator[k,v]'
  tangle('  instance Eq['+n+'[k,v]] {')
  tangle('    fun eq: '+c+' * '+c+' -> bool = "$1==$2";')
  tangle('  }')

  tangle('  instance Container['+c+',k*v] {')
  tangle('    fun len: '+c+' -> size = "$1.size()";')
  tangle('    fun empty: '+c+' -> bool = "$1.empty()";')
  tangle('  }')

  tangle('  instance Sequence['+c+','+it+',k*v] {')
  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    proc erase : lvalue['+c+'] * '+it+' = "$1.erase($1);";')
  tangle('    proc erase_between : lvalue['+c+'] * '+it+' * '+it+' = "$1.erase($1,$2);";')
  tangle('    proc clear : lvalue['+c+'] = "$1.clear();";')
  tangle('  }')

  rit = n+'_reverse_iterator[k,v]'

  tangle('  instance Reversible_Sequence['+c+','+it+','+rit+',k*v] {')
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')
  tangle('  }')

module Stl
{
  type pair[k,v] = "std::pair<?1 const,?2>";
  fun make_pair[k,v]: k * v ->pair[k,v] = "std::make_pair($1,$2)";

  module Vector[t]
  {
    requires std_stl_vector;
@mkrseq('vector')
@mkinsat('vector')
@mkpub('vector')
@mkfront('vector')
@mkback('vector')
@mksub('vector')
    fun add: stl_vector_iterator[t] * int -> stl_vector_iterator[t] = "$1+$2";
    fun sub: stl_vector_iterator[t] * int -> stl_vector_iterator[t] = "$1-$2";
    proc pluseq: lvalue[stl_vector_iterator[t]] * int = "$1+=$2;";
    proc minuseq: lvalue[stl_vector_iterator[t]] * int -> stl_vector_iterator[t] = "$1-=$2;";
    fun subscript: stl_vector_iterator[t] * int -> lvalue[t] = "$1[$2]";
// Vector
@tcmkseq('stl_vector')
@tcmkrseq('stl_vector')

// Vector iterator
@mkbidir('stl_vector_iterator[t]','t')

// Vector reverse iterator
@mkbidir('stl_vector_reverse_iterator[t]','t')

  }
  module List[t]
  {
    requires std_stl_list;
@mkrseq('list')
@mkinsat('list')
@mkpuf('list')
@mkpub('list')
@mkfront('list')
@mkback('list')
@mkpof('list')
// List
@tcmkseq('stl_list')
@tcmkrseq('stl_list')

// List iterator
@mkbidir('stl_list_iterator[t]','t')

// List reverse iterator
@mkbidir('stl_list_reverse_iterator[t]','t')

  }
  module Deque[t]
  {
    requires std_stl_deque;
@mkrseq('deque')
@mkinsat('deque')
@mkpuf('deque')
@mkpub('deque')
@mkpof('deque')
@mkfront('deque')
@mkback('deque')
@mksub('deque')
// Deque
@tcmkseq('stl_deque')
@tcmkrseq('stl_deque')

// Deque iterator
@mkbidir('stl_deque_iterator[t]','t')

// Deque reverse iterator
@mkbidir('stl_deque_reverse_iterator[t]','t')

  }
  module Set[t]
  {
    requires std_stl_set;
@mkset('set')
// Set
@tcmkseq('Set::stl_set')
@tcmkrseq('Set::stl_set')

// Set iterator
@mkbidir('stl_set_iterator[t]','t')

// Set reverse iterator
@mkbidir('stl_set_reverse_iterator[t]','t')

  }
  module MultiSet[t]
  {
    requires std_stl_set;
@mkset('multiset')
// MultiSet
@tcmkseq('stl_multiset')
@tcmkrseq('stl_multiset')

// MultiSet iterator
@mkbidir('stl_multiset_iterator[t]','t')

// MultiSet reverse iterator
@mkbidir('stl_multiset_reverse_iterator[t]','t')

  }
  module Map[k,v]
  {
    requires std_stl_map;
@mkass('map')
// Map
@tcmkass('stl_map')

// Map iterator
@mkbidir('stl_map_iterator[k,v]','k,v','k*v')

// Map reverse iterator
@mkbidir('stl_map_reverse_iterator[k,v]','k,v','k*v')

  }
  module MultiMap[k,v]
  {
    requires std_stl_map;
@mkass('multimap')
// MultiMap
@tcmkass('stl_multimap')

// MultiMap iterator
@mkbidir('stl_multimap_iterator[k,v]','k,v','k*v')

//MultiMap reverse iterator
@mkbidir('stl_multimap_reverse_iterator[k,v]','k,v','k*v')

  }

@if config.TARGET_CXX.options.HAVE_STL_GNU_CXX:
  tangle('  module Slist[t]')
  tangle('  {')
  tangle('    requires ext_slist;')
  mkseq('slist','__gnu_cxx')
  mkpuf('slist')
  mkfront('slist')
  mkpof('slist')
  tangle('    proc insert_after : stl_slist[t] * stl_slist_iterator[t] *  t  = "$1.insert_after($2,$3);";')
  tangle('    proc erase_after : stl_slist[t] * stl_slist_iterator[t] = "$1.erase_after($1);";')
  tangle('  }')

@if config.TARGET_CXX.options.HAVE_STL_GNU_CXX:
  tangle('// HASHTABLE based containers assume')
  tangle('// these classes will be added to C++ via TR1 in the future.')
  tangle('// g++ 3.2.2 at least has these classes')
  tangle('// The free SGI implementation may suffice as a replacement,')
  tangle('// this is what my version of g++ uses.')
  tangle('')
  tangle('  module HashSet[t]')
  tangle('  {')
  tangle('    requires ext_hash_set;')
  mkset('hash_set','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMultiSet[t]')
  tangle('  {')
  tangle('    requires ext_hash_set;')
  mkseq('hash_multiset','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMap[k,v]')
  tangle('  {')
  tangle('    requires ext_hash_map;')
  mkass('hash_map','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMultiMap[k,v]')
  tangle('  {')
  tangle('    requires ext_hash_map;')
  mkass('hash_multimap','__gnu_cxx')
  tangle('  }')
}

open Stl;
open Stl::Vector;
open[t] Reversible_Sequence[
  Stl::Vector::stl_vector[t],
  Stl::Vector::stl_vector_iterator[t],
  Stl::Vector::stl_vector_reverse_iterator[t],t];
open[t] Bidirectional_iterator[Stl::Vector::stl_vector_iterator[t],t];
open[t] Bidirectional_iterator[Stl::Vector::stl_vector_reverse_iterator[t],t];

open Stl::List;
open[t] Reversible_Sequence[
  Stl::List::stl_list[t],
  Stl::List::stl_list_iterator[t],
  Stl::List::stl_list_reverse_iterator[t],t];
open[t] Bidirectional_iterator[Stl::List::stl_list_iterator[t],t];
open[t] Bidirectional_iterator[Stl::List::stl_list_reverse_iterator[t],t];

open Stl::Deque;
open[t] Reversible_Sequence[
  Stl::Deque::stl_deque[t],
  Stl::Deque::stl_deque_iterator[t],
  Stl::Deque::stl_deque_reverse_iterator[t],t];
open[t] Bidirectional_iterator[Stl::Deque::stl_deque_iterator[t],t];
open[t] Bidirectional_iterator[Stl::Deque::stl_deque_reverse_iterator[t],t];

open Stl::Set;
open[t] Reversible_Sequence[
  Stl::Set::stl_set[t],
  Stl::Set::stl_set_iterator[t],
  Stl::Set::stl_set_reverse_iterator[t],t];
open[t] Bidirectional_iterator[Stl::Set::stl_set_iterator[t],t];
open[t] Bidirectional_iterator[Stl::Set::stl_set_reverse_iterator[t],t];

open Stl::MultiSet;
open[t] Reversible_Sequence[
  Stl::MultiSet::stl_multiset[t],
  Stl::MultiSet::stl_multiset_iterator[t],
  Stl::MultiSet::stl_multiset_reverse_iterator[t],t];
open[t] Bidirectional_iterator[Stl::MultiSet::stl_multiset_iterator[t],t];
open[t] Bidirectional_iterator[Stl::MultiSet::stl_multiset_reverse_iterator[t],t];

open Stl::Map;
open[k,v] Reversible_Sequence[
  Stl::Map::stl_map[k,v],
  Stl::Map::stl_map_iterator[k,v],
  Stl::Map::stl_map_reverse_iterator[k,v],k*v];
open[k,v] Bidirectional_iterator[Stl::Map::stl_map_iterator[k,v],k*v];
open[k,v] Bidirectional_iterator[Stl::Map::stl_map_reverse_iterator[k,v],k*v];

open Stl::MultiMap;
open[k,v] Reversible_Sequence[
  Stl::MultiMap::stl_multimap[k,v],
  Stl::MultiMap::stl_multimap_iterator[k,v],
  Stl::MultiMap::stl_multimap_reverse_iterator[k,v],k*v];
open[k,v] Bidirectional_iterator[Stl::MultiMap::stl_multimap_iterator[k,v],k*v];
open[k,v] Bidirectional_iterator[Stl::MultiMap::stl_multimap_reverse_iterator[k,v],k*v];

@head(1, 'Packages')
@select(tangler('spkgs/flx_stl_tests.py'))
import config

root = config.FLX_DIR
unit_tests = [('test', 'regress', 'stl', '*.flx')]

pkg_requires = ['flx_stdlib','flx_compiler']
iscr_source = ['lpsrc/flx_stl.pak']

weaver_directory = 'doc/test/stl'
@doc()
