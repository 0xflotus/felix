@head(1,"Build Symbol tables")
Name binding, pass 1.
@p()
This module is responsible for converting
the AST into a symbol table, type 1.
This table represents the raw information,
nesting structure, and associates each 
entity with a unique index.
@p()
Types, expressions, and bodies
of functions remain unbound.

@h = tangler("src/flx_symtab.mli")
@select(h)
open Flx_types
val build_tables:
  bool ->
  symbol_table_t ->
  int ref ->
  string ->
  int ->
  int option ->
  asm_t list ->
  (
    name_map_t *  
    exe_t list * 
    (iface_t * int option) list *
    dir_t list
  )

@h = tangler("src/flx_symtab.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_srcref
open List
open Flx_lookup

let split_asms asms : 
  (range_srcref * id_t * dcl_t) list * 
  exe_t list *
  iface_t list *
  dir_t list
= 
  let rec aux asms dcls exes ifaces dirs =
    match asms with
    | [] -> (dcls,exes,ifaces, dirs)
    | h :: t -> 
      match h with 
      | Exe (sr,exe) -> aux t dcls (exe :: exes) ifaces dirs
      | Dcl (sr,id,dcl) -> aux t ((sr,id,dcl) :: dcls) exes ifaces dirs
      | Iface (sr,iface) -> aux t dcls exes (iface :: ifaces) dirs
      | Dir (sr,dir) -> aux t dcls exes ifaces (dir::dirs)
  in 
    aux asms [] [] [] []
 
let dump_name_to_int_map level name name_map =
  let spc = spaces level in
  print_endline (spc ^ "//Name to int map for " ^ name);
  print_endline (spc ^ "//---------------");
  Hashtbl.iter
  (
    fun id n ->
      print_endline ( "//" ^ spc ^ id ^ ": " ^ string_of_int n) 
  ) 
  name_map
  ;
  print_endline ""

  
 
let add_unique table key value =
  try 
    Hashtbl.find table key;
    failwith ("Duplicate key " ^ key)
  with Not_found -> Hashtbl.add table key (NonFunctionEntry (Simple value))

let add_function table key value =
  try 
    match Hashtbl.find table key with
    | NonFunctionEntry _ -> 
      failwith ("Cannot overload " ^ key ^ " with non-function")
    | FunctionEntry fs ->
      Hashtbl.remove table key;
      Hashtbl.add table key (FunctionEntry (Simple value :: fs))
  with Not_found -> 
    Hashtbl.add table key (FunctionEntry [Simple value])

(* this routine takes a partially filled unbound definition table,
  'dfns' and a counter 'counter', and adds entries to the table
  at locations equal to and above the counter
*)
let rec build_tables print_flag dfns counter name level parent asms = 
  let dcls,exes,ifaces,dirs = split_asms asms in
  let dcls,exes,ifaces,dirs = 
    List.rev dcls,List.rev exes,List.rev ifaces, List.rev dirs
  in
  let ifaces = List.map (fun i-> i,parent) ifaces in
  let interfaces = ref ifaces in
  let spc = spaces level in
  let name_map = Hashtbl.create 97 in
  begin 
    List.iter
    (
      fun (sr,id,dcl) -> 
        let n = !counter in 
        incr counter; 
        if print_flag then 
          print_endline 
          (
            "//" ^ spc ^ string_of_int n ^ " -> " ^ id ^ 
            " " ^ short_string_of_src sr
          )
        ;
        begin match dcl with
        | `DCL_regdef re ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n


        | `DCL_module_binding e -> 
          Hashtbl.add dfns n (id, sr, parent,
            `SYMDEF_module_binding e 
          );
          add_unique name_map id n;
          interfaces := !interfaces @ ifaces

        | `DCL_typed_functor (ps,ret,asms) -> 
          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables print_flag dfns counter id (level+1) (Some n) 
            asms
          in
          Hashtbl.add dfns fun_index (id, sr, parent,
            `SYMDEF_typed_functor (ps,ret,exes,table, dirs) 
          );
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ string_of_int n ^ " -> " ^ name^ " (parameter)");
            Hashtbl.add dfns n (name,sr,Some fun_index,`SYMDEF_parameter typ);
            add_unique table name n
          ) ps
          ;

          let n' = !counter in
          incr counter;
          let init_def = 
            `SYMDEF_procedure 
            (
              [], 
              exes, 
              Hashtbl.create 97,
              [] 
            ) 
          in
          Hashtbl.add dfns n' ("_init_",sr,Some fun_index, init_def);
          if print_flag then
          print_endline ("//  "^spc ^ string_of_int n' ^ " -> _init_ (functor "^id^")");
          (* NOTE: NO CALL TO INIT ROUTINE HERE! *)
          add_function table ("_init_") n';

          add_function name_map id fun_index ;
          interfaces := !interfaces @ ifaces

        | `DCL_untyped_functor (ps,asms) -> 
          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables print_flag dfns counter id (level+1) (Some n) 
            asms
          in
          Hashtbl.add dfns fun_index (id, sr, parent,
            `SYMDEF_untyped_functor (ps,exes,table, dirs) 
          );
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ string_of_int n ^ " -> " ^ name^ " (parameter)");
            Hashtbl.add dfns n (name,sr,Some fun_index,`SYMDEF_parameter typ);
            add_unique table name n
          ) ps
          ;

          let n' = !counter in
          incr counter;
          let init_def = 
            `SYMDEF_procedure 
            (
              [], 
              exes, 
              Hashtbl.create 97,
              [] 
            ) 
          in
          Hashtbl.add dfns n' ("_init_",sr,Some fun_index, init_def);
          if print_flag then
          print_endline ("//  "^spc ^ string_of_int n' ^ " -> _init_ (functor "^id^")");
          (* NOTE: NO CALL TO INIT ROUTINE HERE! *)
          add_function table ("_init_") n';

          add_function name_map id fun_index ;
          interfaces := !interfaces @ ifaces

        | `DCL_function (ps,t,asms) ->   
          let fun_index = n in
          let t = if t = `TYP_none then `TYP_var fun_index else t in
          let table, exes, ifaces,dirs =  
            build_tables print_flag dfns counter id (level+1) 
            (Some fun_index) asms 
          in
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ string_of_int n ^ " -> " ^ name^ " (parameter)");
            Hashtbl.add dfns n (name,sr,Some fun_index,`SYMDEF_parameter typ);
            add_unique table name n
          ) ps
          ; 
          Hashtbl.add dfns fun_index (id, sr,parent,
            `SYMDEF_function (ps, t, exes, table, dirs)
          )
          ;
          add_function name_map id fun_index ;
          interfaces := !interfaces @ ifaces


        | `DCL_match_check (pat,mvname) ->
          let fun_index = n in
          let match_var_index = 
            match Hashtbl.find name_map mvname with
            | NonFunctionEntry (Simple idx) -> idx
            | _ -> assert false
          in 
          Hashtbl.add dfns fun_index (id, sr, parent,
            `SYMDEF_match_check (pat, match_var_index)
          );
          add_function name_map id fun_index ;
          interfaces := !interfaces @ ifaces
        
        | `DCL_match_handler (pat,mvname,asms) ->
          let vars = Hashtbl.create 97 in
          Flx_mbind.get_pattern_vars vars pat [];
          (*
          print_endline ("PATTERN IS " ^ string_of_pattern pat ^ ", VARIABLE=" ^ mvname);
          print_endline "VARIABLES ARE";
          Hashtbl.iter (fun vname (sr,extractor) ->
            let component = 
              Flx_mbind.gen_extractor extractor (`AST_name (sr,mvname)) 
            in
            print_endline ("  " ^ vname ^ " := " ^ string_of_expr component);
          ) vars;
          *)

          let new_asms = ref asms in
          Hashtbl.iter
          (fun vname (sr,extractor) ->
            let component = 
              Flx_mbind.gen_extractor extractor 
              (`AST_name (sr,mvname)) 
            in
            let dcl = Dcl (sr, vname, `DCL_val (`TYP_typeof (component))) 
            and instr = Exe (sr, `EXE_init (vname, component)) 
            in
              new_asms := dcl :: instr :: !new_asms;
          )
          vars;

          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables print_flag dfns counter id (level+1) 
            (Some fun_index) !new_asms 
          in
          Hashtbl.add dfns fun_index (id, sr, parent,
            `SYMDEF_function ([],`TYP_var fun_index, exes, table, dirs)
          );
          add_function name_map id fun_index;
          interfaces := !interfaces @ ifaces


        | `DCL_header s ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n

        | `DCL_body s ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n

        | `DCL_module asms ->
          let table, exes,ifaces,dirs = 
            build_tables print_flag dfns counter id (level+1) (Some n) 
            asms
          in
          Hashtbl.add dfns n (id, sr,parent,`SYMDEF_module (table,dirs));
          let n' = !counter in
          incr counter;
          let init_def = 
            `SYMDEF_procedure 
            (
              [], 
              exes, 
              Hashtbl.create 97,
              []
            ) 
          in
          if print_flag then
          print_endline ("//  "^spc ^ string_of_int n' ^ " -> _init_  (module "^id^")");
          Hashtbl.add dfns n' ("_init_",sr,Some n, init_def);

          add_unique name_map id n;
          add_function table ("_init_") n';
          interfaces := !interfaces @ ifaces
        
        | `DCL_interface asms ->
          let table, exes,ifaces,dirs = 
            build_tables print_flag dfns counter id (level+1) (Some n) 
            asms
          in
          Hashtbl.add dfns n (id, sr,parent,`SYMDEF_interface (table, dirs));
          let n' = !counter in
          incr counter;
          let init_def = 
            `SYMDEF_if_proc ( `TYP_tuple []) 
          in
          Hashtbl.add dfns n' ("_init_",sr,Some n, init_def);
          if print_flag then
          print_endline ("//  "^spc ^ string_of_int n' ^ " -> _init_ (interface "^id^")");
          add_unique name_map id n;
          add_function table ("_init_") n';
          interfaces := !interfaces @ ifaces

        | `DCL_procedure (ps,asms) -> 
          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables print_flag dfns counter id 
            (level+1) (Some fun_index) asms 
          in
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag
            then print_endline ("//  "^spc ^ string_of_int n ^ " -> " ^ name^" (parameter)" );
            Hashtbl.add dfns n (name,sr,Some fun_index,`SYMDEF_parameter typ);
            add_unique table name n
          ) ps
          ; 
          Hashtbl.add dfns fun_index (id, sr,parent,
            `SYMDEF_procedure (ps, exes, table, dirs))
          ;
          add_function name_map id fun_index;
          interfaces := !interfaces @ ifaces
        
        | `DCL_if_fun t ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_if_fun t)
          ;
          add_function name_map id n
          
        | `DCL_if_proc (t) ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_if_proc t)
          ;
          add_function name_map id n

        | `DCL_type ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_if_type)
          ;
          add_unique name_map id n

        | `DCL_val t ->
          let t = match t with | `TYP_none -> `TYP_var n | _ -> t in
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_val t)
          ;
          add_unique name_map id n

        | `DCL_var t ->       
          let t = if t = `TYP_none then `TYP_var n else t in
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_var t)
          ;
          add_unique name_map id n

        | `DCL_type_alias t ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | `DCL_abs c ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | `DCL_const (t,c) ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | `DCL_fun (ts,t,c) ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_function name_map id n

        | `DCL_proc (ts,c) ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_function name_map id n


        | `DCL_union its ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
          ;
          (* assignment *)
          let asgn_idx = !counter in incr counter;
          let asgn_name = "set" in
          let asgn_dcl = 
            `DCL_proc 
            (
              [
                `TYP_pointer (`AST_name (sr,id));
                `AST_name (sr,id)
              ],
              "*$1=$2;"
            ) 
          in
          if print_flag then print_endline ("//  " ^ spc ^ string_of_int asgn_idx ^ " -> " ^ asgn_name); 
          Hashtbl.add dfns asgn_idx (asgn_name,sr,parent,`SYMDEF_dcl asgn_dcl);
          add_function name_map asgn_name asgn_idx
          ; 
          let ccount = ref 0 in (* count component constructors *)
          List.iter
          (fun (component_name,t) ->
            let dfn_idx = !counter in incr counter; (* constructor *)
            let match_idx = !counter in incr counter; (* matcher *)
            let ctor_idx = !ccount in incr ccount; (* ctor sequence in union *)
            let ctor_dcl =
              match t with
              | `AST_void _ -> (* constant constructor *)
                add_unique name_map component_name dfn_idx;
                `DCL_const (`AST_name (sr,id),
                  "_uctor_(" ^ string_of_int ctor_idx ^ ",0)"
                )
              | `TYP_tuple ts -> (* non-constant constructor or 2 or more arguments *)
                add_function name_map component_name dfn_idx;
                let dcl = 
                  `DCL_fun 
                  (
                    ts,
                    `AST_name (sr,id),
                    "_uctor_(" ^ string_of_int ctor_idx ^ 
                    ", new(gc,@t) #t($t))"
                  )
                in 
                  dcl
              | _ -> (* non-constant constructor of 1 argument *)
                add_function name_map component_name dfn_idx;
                `DCL_fun ([t],`AST_name (sr,id),
                  "_uctor_(" ^ string_of_int ctor_idx ^ 
                  ", new(gc,@1) #1($1))"
                )
            in
              let ctor_match = 
                `DCL_fun (
                  [`AST_name (sr,id)],
                  flx_bool,
                  "($1.variant==" ^ string_of_int ctor_idx ^")"
                )
              and ctor_match_name ="_match_ctor_" ^ component_name 
              in

              if print_flag then print_endline ("//  " ^ spc ^ string_of_int dfn_idx ^ " -> " ^ component_name); 
              Hashtbl.add dfns dfn_idx (component_name,sr,parent,`SYMDEF_dcl ctor_dcl);

              if print_flag then print_endline ("//  " ^ spc ^ string_of_int match_idx ^ " -> " ^ ctor_match_name); 
              Hashtbl.add dfns match_idx (ctor_match_name,sr,parent,`SYMDEF_dcl ctor_match);

              add_function name_map ctor_match_name match_idx;

              (* destructor *)
              match t with
              | `AST_void _ -> ()
              | _ -> (* non-constant constructor *)
                let dtor_idx = !counter in incr counter;
                let dtor_name = "_ctor_arg_" ^ component_name in
                let dtor_dcl = `DCL_fun ([`AST_name (sr,id)],t,"*(#0*)`1.data") in
                if print_flag then print_endline ("//  " ^ spc ^ string_of_int dtor_idx ^ " -> " ^ dtor_name); 
                Hashtbl.add dfns dtor_idx (dtor_name,sr,parent,`SYMDEF_dcl dtor_dcl);
                add_function name_map dtor_name dtor_idx
          )
          its
 
        | `DCL_struct sts ->
          Hashtbl.add dfns n (id,sr,parent,`SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
          ;
          List.iter
          (fun (component_name,t) ->
            let getn = !counter in incr counter;
            let get_name = "get_" ^ component_name in
            let get_dcl = `DCL_fun ([`AST_name (sr,id)],t,"$1." ^ component_name) in
            Hashtbl.add dfns getn (get_name,sr,parent,`SYMDEF_dcl get_dcl);
            add_function name_map get_name getn
            ;

            let refn = !counter in incr counter;
            let ref_name = "ref_" ^ component_name in
            let ref_dcl = `DCL_fun (
              [`TYP_pointer (`AST_name (sr,id))],
              `TYP_pointer t,
              "_make_ref_(`1.frame,&($1->" ^ component_name ^"))"
            ) 
            in
            Hashtbl.add dfns refn (ref_name,sr,parent,`SYMDEF_dcl ref_dcl) ;
            add_function name_map ref_name refn
          )
          sts
          ;
        end
    ) 
    dcls
  end
  ;
  name_map,exes,!interfaces, dirs

