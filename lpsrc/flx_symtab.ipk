@head(1,"Build Symbol tables")
Name binding, pass 1.
@p()
This module is responsible for converting
the AST into a symbol table, type 1.
This table represents the raw information,
nesting structure, and associates each 
entity with a unique index.
@p()
Types, expressions, and bodies
of functions remain unbound.

@h = tangler("src/flx_symtab.mli")
@select(h)
open Flx_ast
open Flx_types
val build_tables:
  sym_state_t ->
  string ->
  int ->
  int option -> (* parent index *)
  int option -> (* grandparent index *)
  int -> (* root index *)
  asm_t list ->
  (
    name_map_t *  
    exe_t list * 
    (iface_t * int option) list *
    dir_t list
  )

@h = tangler("src/flx_symtab.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_srcref
open List
open Flx_lookup
open Flx_exceptions

let split_asms asms : 
  (range_srcref * id_t * id_t list * dcl_t) list * 
  exe_t list *
  iface_t list *
  dir_t list
= 
  let rec aux asms dcls exes ifaces dirs =
    match asms with
    | [] -> (dcls,exes,ifaces, dirs)
    | h :: t -> 
      match h with 
      | Exe (sr,exe) -> aux t dcls (exe :: exes) ifaces dirs
      | Dcl (sr,id,vs,dcl) -> aux t ((sr,id,vs,dcl) :: dcls) exes ifaces dirs
      | Iface (sr,iface) -> aux t dcls exes (iface :: ifaces) dirs
      | Dir (sr,dir) -> aux t dcls exes ifaces (dir::dirs)
  in 
    aux asms [] [] [] []
 
let dump_name_to_int_map level name name_map =
  let spc = spaces level in
  print_endline (spc ^ "//Name to int map for " ^ name);
  print_endline (spc ^ "//---------------");
  Hashtbl.iter
  (
    fun id n ->
      print_endline ( "//" ^ spc ^ id ^ ": " ^ si n) 
  ) 
  name_map
  ;
  print_endline ""

  
 
let add_unique syms sr table key value =
  try 
    let entry = Hashtbl.find table key in
    match entry with 
    | NonFunctionEntry (Simple idx) 
    | FunctionEntry (Simple idx :: _ ) ->
      let id,sr2,parent,vs,table,dirs,entry = 
        Hashtbl.find syms.dfns idx 
      in
       clierr2 sr sr2 ("[build_tables] Duplicate non-function name declared " ^ key)
     | _ ->
       clierr sr ("[build_tables] Duplicate non-function name declared " ^ key)

  with Not_found -> 
    Hashtbl.add table key (NonFunctionEntry (Simple value))

let add_function sr table key value =
  try 
    match Hashtbl.find table key with
    | NonFunctionEntry entry -> 
      clierr sr 
      ("[build_tables] Cannot overload " ^ key ^ "<" ^ si value ^
      "> with non-function" ^ string_of_entry_kind entry)
    | FunctionEntry fs ->
      Hashtbl.remove table key;
      Hashtbl.add table key (FunctionEntry (Simple value :: fs))
  with Not_found -> 
    Hashtbl.add table key (FunctionEntry [Simple value])

(* this routine takes a partially filled unbound definition table,
  'dfns' and a counter 'counter', and adds entries to the table
  at locations equal to and above the counter

  Each entity is also added to the name map of the parent entity.

  We use recursive descent, noting that the whilst an entity
  is not registered until its children are completely registered,
  its index is allocated before descending into child structures,
  so the index of children is always higher than its parent numerically

  The parent index is passed down so an uplink to the parent can
  be created in the child, but it cannot be followed until
  registration of all the children and their parent is complete
*)

let null_tab = Hashtbl.create 3 

let rec build_tables syms name level parent grandparent root asms = 
  let 
    print_flag = syms.compiler_options.print_flag and
    dfns = syms.dfns and
    counter = syms.counter
  in
  let dcls,exes,ifaces,dirs = split_asms asms in
  let dcls,exes,ifaces,dirs = 
    List.rev dcls,List.rev exes,List.rev ifaces, List.rev dirs
  in
  let ifaces = List.map (fun i-> i,parent) ifaces in
  let interfaces = ref ifaces in
  let spc = spaces level in
  let name_map = Hashtbl.create 97 in

  (* check root index *)
  if level = 0 
  then begin
    if root <> !counter
    then failwith "Wrong value for root index";
    begin match dcls with
    | [x] -> ()
    | _ -> failwith "Expected top level to contain exactly one module declaration"
    end
  end
  ;
  Hashtbl.add name_map "root" (NonFunctionEntry (Simple root))
  ;
  begin 
    List.iter
    (
      fun (sr,id,vs',dcl) -> 
        let table = Hashtbl.create 3 in (* dummy-ish table could contain type vars *)
        let add_unique table id idx = add_unique syms sr table id idx in
        let n = !counter in 
        incr counter; 
        if print_flag then 
          print_endline 
          (
            "//" ^ spc ^ si n ^ " -> " ^ id ^ 
            " " ^ short_string_of_src sr
          )
        ;
        let vs = 
          List.map 
          (
            fun tid-> let n = !counter in incr counter; 
            if print_flag then
            print_endline ("//  "^spc ^ si n ^ " -> " ^ tid^ " (type variable)");
            tid,n
          ) 
          vs'
        in
        let add_tvars table =        
          List.iter
          (fun (tvid,i) ->
            Hashtbl.add dfns i (tvid,sr,Some n,[],null_tab,[],`SYMDEF_typevar `TYP_type);
            add_unique table tvid i 
          )
          vs
        in
        begin match (dcl:dcl_t) with
        | `DCL_regdef re ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_regdef re)
          ;
          add_unique name_map id n
          ;
          add_tvars table


        | `DCL_module_binding (e) -> 
          Hashtbl.add dfns n (id, sr, parent,vs,table,dirs,
            `SYMDEF_module_binding e 
          );
          add_unique name_map id n;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table

        | `DCL_typed_functor (ps,ret,asms) -> 
          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables syms id (level+1) (Some n) parent root
            asms
          in
          Hashtbl.add dfns fun_index (id, sr, parent,vs,table,dirs,
            `SYMDEF_typed_functor (ps,ret,exes) 
          );
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ si n ^ " -> " ^ name^ " (parameter)");
            let vs = [] in (* KLUDGE *)
            Hashtbl.add dfns n (name,sr,Some fun_index,vs,null_tab,[],`SYMDEF_parameter (typ));
            add_unique table name n
          ) ps
          ;

          let n' = !counter in
          incr counter;
          let init_def = 
            `SYMDEF_function
            (
              [], `AST_void sr,
              exes
            ) 
          in
          Hashtbl.add dfns n' ("_init_",sr,Some fun_index, vs,null_tab,[],init_def);
          if print_flag then
          print_endline ("//  "^spc ^ si n' ^ " -> _init_ (functor "^id^")");
          (* NOTE: NO CALL TO INIT ROUTINE HERE! *)
          add_function sr table ("_init_") n';

          add_function sr name_map id fun_index ;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table

        | `DCL_untyped_functor (ps,asms) -> 
          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables syms id (level+1) (Some n) parent root
            asms
          in
          Hashtbl.add dfns fun_index (id, sr, parent,vs,table,dirs,
            `SYMDEF_untyped_functor (ps,exes) 
          );
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ si n ^ " -> " ^ name^ " (parameter)");
            let vs = [] in (* KLUDGE *)
            Hashtbl.add dfns n (name,sr,Some fun_index,vs,null_tab,[],`SYMDEF_parameter (typ));
            add_unique table name n
          ) ps
          ;

         let n' = !counter in
          incr counter;
          let init_def = `SYMDEF_function ( [], `AST_void sr, exes) in
          Hashtbl.add dfns n' ("_init_",sr,Some fun_index, vs,null_tab,[],init_def);
          if print_flag then
          print_endline ("//  "^spc ^ si n' ^ " -> _init_ (functor "^id^")");
          (* NOTE: NO CALL TO INIT ROUTINE HERE! *)
          add_function sr table ("_init_") n';

          add_function sr name_map id fun_index ;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table

        | `DCL_function (ps,t,asms) ->   
          let fun_index = n in
          let t = if t = `TYP_none then `TYP_var fun_index else t in
          let table, exes, ifaces,dirs =  
            build_tables syms id (level+1) 
            (Some fun_index) parent root asms 
          in
          let ips = ref [] in
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ si n ^ " -> " ^ name^ " (parameter)");
            Hashtbl.add dfns n (name,sr,Some fun_index,[],null_tab,[],`SYMDEF_parameter (typ));
            add_unique table name n;
            ips := (name,typ) :: !ips 
          ) ps
          ; 
          Hashtbl.add dfns fun_index (id, sr,parent,vs,table,dirs,
            `SYMDEF_function (List.rev !ips, t, exes)
          )
          ;
          add_function sr name_map id fun_index ;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table

        | `DCL_match_check (pat,mvname) ->
          assert (length vs = 0);
          let fun_index = n in
          let match_var_index = 
            match Hashtbl.find name_map mvname with
            | NonFunctionEntry (Simple idx) -> idx
            | _ -> assert false
          in 
          Hashtbl.add dfns fun_index (id, sr, parent,vs,table,dirs,
            `SYMDEF_match_check (pat, match_var_index)
          );
          add_function sr name_map id fun_index ;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table

        | `DCL_match_handler (pat,mvname,asms) ->
          assert (length vs = 0);
          let vars = Hashtbl.create 97 in
          Flx_mbind.get_pattern_vars vars pat [];
          (*
          print_endline ("PATTERN IS " ^ string_of_pattern pat ^ ", VARIABLE=" ^ mvname);
          print_endline "VARIABLES ARE";
          Hashtbl.iter (fun vname (sr,extractor) ->
            let component = 
              Flx_mbind.gen_extractor extractor (`AST_name (sr,mvname,[])) 
            in
            print_endline ("  " ^ vname ^ " := " ^ string_of_expr component);
          ) vars;
          *)

          let new_asms = ref asms in
          Hashtbl.iter
          (fun vname (sr,extractor) ->
            let component = 
              Flx_mbind.gen_extractor extractor 
              (`AST_name (sr,mvname,[])) 
            in
            let empty_vs = [] in
            let dcl = Dcl (sr, vname, empty_vs,`DCL_val (`TYP_typeof (component))) 
            and instr = Exe (sr, `EXE_init (vname, component)) 
            in
              new_asms := dcl :: instr :: !new_asms;
          )
          vars;

          let fun_index = n in
          let table, exes,ifaces,dirs = 
            build_tables syms id (level+1) 
            (Some fun_index) parent root !new_asms 
          in
          Hashtbl.add dfns fun_index (id, sr, parent,vs,table,dirs,
            `SYMDEF_function ([],`TYP_var fun_index, exes)
          );
          add_function sr name_map id fun_index;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table


        | `DCL_header s ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_header s)
          ;
          add_unique name_map id n

        | `DCL_body s ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_body s)
          ;
          add_unique name_map id n

        | `DCL_module asms ->
          let table, exes,ifaces,dirs = 
            build_tables syms id (level+1) (Some n) parent root
            asms
          in
          Hashtbl.add dfns n (id, sr,parent,vs,table,dirs,`SYMDEF_module);
          let n' = !counter in
          incr counter;
          let init_def = `SYMDEF_function ( [],`AST_void sr, exes) in
          if print_flag then
          print_endline ("//  "^spc ^ si n' ^ " -> _init_  (module "^id^")");
          Hashtbl.add dfns n' ("_init_",sr,Some n, vs,null_tab,[],init_def);

          add_unique name_map id n;
          add_function sr table ("_init_") n';
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table
        
        | `DCL_interface asms ->
          let table, exes,ifaces,dirs = 
            build_tables syms id (level+1) (Some n) parent root
            asms
          in
          Hashtbl.add dfns n (id, sr,parent,vs,table,dirs,`SYMDEF_interface);
          let n' = !counter in
          incr counter;
          let init_def = 
            `SYMDEF_if_fun ( `TYP_function (`TYP_tuple [], `AST_void sr))
          in
          Hashtbl.add dfns n' ("_init_",sr,Some n, vs,null_tab,[],init_def);
          if print_flag then
          print_endline ("//  "^spc ^ si n' ^ " -> _init_ (interface "^id^")");
          add_unique name_map id n;
          add_function sr table ("_init_") n';
          interfaces := !interfaces @ ifaces
          ;
          add_tvars table

 
        | `DCL_if_fun t ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_if_fun t)
          ;
          add_function sr name_map id n
          ;
          add_tvars table
          
        | `DCL_type ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_if_type)
          ;
          add_unique name_map id n
          ;
          add_tvars table

        | `DCL_val t ->
          let t = match t with | `TYP_none -> `TYP_var n | _ -> t in
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_val (t))
          ;
          add_unique name_map id n
          ;
          add_tvars table

        | `DCL_var t ->       
          let t = if t = `TYP_none then `TYP_var n else t in
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_var (t))
          ;
          add_unique name_map id n
          ;
          add_tvars table

        | `DCL_type_alias (t) ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_type_alias t)
          ;
          add_unique name_map id n
          ;
          add_tvars table

        | `DCL_abs (c) ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_abs c)
          ;
          add_unique name_map id n
          ;
          add_tvars table

        | `DCL_const (t,c) ->
          let t = if t = `TYP_none then `TYP_var n else t in
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_const (t,c))
          ;
          add_unique name_map id n
          ;
          add_tvars table

        | `DCL_fun (ts,t,c) ->
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_fun (ts,t,c))
          ;
          add_function sr name_map id n
          ;
          add_tvars table

        | `DCL_union (its) ->
          let tvars = map (fun (s,_)-> `AST_name (sr,s,[])) vs in
          let utype = `AST_name(sr,id, tvars) in
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_union (its))
          ;
          add_unique name_map id n
          ;
          (* assignment *)
          let asgn_idx = !counter in incr counter;
          let asgn_name = "set" in
          let asgn_dcl = 
            `SYMDEF_fun
            (
              [ `TYP_pointer utype; utype ],
              `AST_void sr,
              "*$1=$2;"
            ) 
          in
          if print_flag then print_endline ("//  " ^ spc ^ si asgn_idx ^ " -> " ^ asgn_name); 
          Hashtbl.add dfns asgn_idx (asgn_name,sr,parent,vs,table,dirs,asgn_dcl);
          add_function sr name_map asgn_name asgn_idx
          ; 

          let unit_sum = 
            List.fold_left 
            (fun v (_,t) -> v && (match t with `AST_void _ -> true | _ -> false) )
            true 
            its
          in
          let ccount = ref 0 in (* count component constructors *)
          List.iter
          (fun (component_name,t) ->
            let dfn_idx = !counter in incr counter; (* constructor *)
            let match_idx = !counter in incr counter; (* matcher *)
            let ctor_idx = !ccount in incr ccount; (* ctor sequence in union *)
            let ctor_dcl =
              if unit_sum
              then begin
                  add_unique name_map component_name dfn_idx;
                  `SYMDEF_const 
                  (
                    utype,
                    si ctor_idx
                  )
              end
              else
                match t with
                | `AST_void _ -> (* constant constructor *)
                  add_unique name_map component_name dfn_idx;
                  `SYMDEF_const 
                  (
                    utype,
                    "_uctor_(" ^ si ctor_idx ^ ",0)"
                  )
                | `TYP_tuple ts -> (* non-constant constructor or 2 or more arguments *)
                  add_function sr name_map component_name dfn_idx;
                  let dcl = 
                    `SYMDEF_fun 
                    (
                      ts,
                      utype,
                      "_uctor_(" ^ si ctor_idx ^ 
                      ", new(gc,@t) #t($t))"
                    )
                  in 
                    dcl
                | _ -> (* non-constant constructor of 1 argument *)
                  add_function sr name_map component_name dfn_idx;
                  `SYMDEF_fun (
                    [t],
                    utype,
                    "_uctor_(" ^ si ctor_idx ^ 
                    ", new(gc,@1) #1($1))"
                  )
            and ctor_match = 
              if unit_sum
              then
                `SYMDEF_fun 
                (
                  [utype],
                  flx_bool,
                  "($1 ==" ^ si ctor_idx ^")"
                )
              else
                `SYMDEF_fun 
                (
                  [utype],
                  flx_bool,
                  "($1.variant==" ^ si ctor_idx ^")"
                )
            and ctor_match_name ="_match_ctor_" ^ component_name 
            in

            if print_flag then print_endline ("//  " ^ spc ^ si dfn_idx ^ " -> " ^ component_name); 
            Hashtbl.add dfns dfn_idx (component_name,sr,parent,vs,table,dirs,ctor_dcl);

            if print_flag then print_endline ("//  " ^ spc ^ si match_idx ^ " -> " ^ ctor_match_name); 
            Hashtbl.add dfns match_idx (ctor_match_name,sr,parent,vs,table,dirs,ctor_match);

            add_function sr name_map ctor_match_name match_idx;

            (* destructor *)
            match t with
            | `AST_void _ -> ()
            | _ -> (* non-constant constructor *)
              let dtor_idx = !counter in incr counter;
              let dtor_name = "_ctor_arg_" ^ component_name in
              let dtor_dcl = `SYMDEF_fun ([utype],t,"*(#0*)$1.data") in
              if print_flag then print_endline ("//  " ^ spc ^ si dtor_idx ^ " -> " ^ dtor_name); 
              Hashtbl.add dfns dtor_idx (dtor_name,sr,parent,vs,table,dirs,dtor_dcl);
              add_function sr name_map dtor_name dtor_idx
          )
          its
          ;
          add_tvars table
 
        | `DCL_struct (sts) ->
          let tvars = map (fun (s,_)-> `AST_name (sr,s,[])) vs in
          let stype = `AST_name(sr,id,tvars) in
          Hashtbl.add dfns n (id,sr,parent,vs,table,dirs,`SYMDEF_struct (sts))
          ;
          add_unique name_map id n
          ;
          (* assignment *)
          let asgn_idx = !counter in incr counter;
          let asgn_name = "set" in
          let asgn_dcl = 
            `SYMDEF_fun
            (
              [ `TYP_pointer stype; stype ],
              `AST_void sr,
              "*$1=$2;"
            ) 
          in
          if print_flag then print_endline ("//  " ^ spc ^ si asgn_idx ^ " -> " ^ asgn_name); 
          Hashtbl.add dfns asgn_idx (asgn_name,sr,parent,vs,table,dirs,asgn_dcl);
          add_function sr name_map asgn_name asgn_idx
          ; 
          (* projections *)
          List.iter
          (fun (component_name,t) ->
            let getn = !counter in incr counter;
            let get_name = "get_" ^ component_name in
            let get_dcl = `SYMDEF_fun ([stype],t,"$1." ^ component_name) in
            Hashtbl.add dfns getn (get_name,sr,parent,vs,table,dirs,get_dcl);
            add_function sr name_map get_name getn
            ;
            if print_flag then print_endline ("//  " ^ spc ^ si getn ^ " -> " ^ get_name)
            ; 
            let refn = !counter in incr counter;
            let ref_name = "ref_" ^ component_name in
            let ref_dcl = `SYMDEF_fun (
              [`TYP_pointer stype],
              `TYP_pointer t,
              "_ref_($1.frame,&($1->" ^ component_name ^"))"
            ) 
            in
            Hashtbl.add dfns refn (ref_name,sr,parent,vs,table,dirs,ref_dcl) ;
            add_function sr name_map ref_name refn
            ;
            if print_flag then print_endline ("//  " ^ spc ^ si refn ^ " -> " ^ ref_name)
          )
          sts
          ;
          add_tvars table

          (* NOTE: we don't add a type constructor, because 
          it would have the same name as the struct type ..
          we just check this case as required ..
          *)
        end
    ) 
    dcls
  end
  ;
  name_map,exes,!interfaces, dirs

