@head(1,"Build Symbol tables")
Name binding, pass 1.
@p()
This module is responsible for converting
the AST into a symbol table, type 1.
This table represents the raw information,
nesting structure, and associates each 
entity with a unique index.
@p()
Types, expressions, and bodies
of functions remain unbound.

@h = tangler("src/flx_symtab.mli")
@select(h)
open Flx_ast
open Flx_types
val build_tables:
  sym_state_t ->
  string ->
  int ->
  int option -> (* parent index *)
  int option -> (* grandparent index *)
  int -> (* root index *)
  asm_t list ->
  (
    name_map_t *  
    name_map_t *  
    sexe_t list * 
    (range_srcref * iface_t * int option) list *
    dir_t list
  )

@h = tangler("src/flx_symtab.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_typing
open Flx_srcref
open List
open Flx_lookup
open Flx_exceptions
open Flx_cil_cabs

let split_asms asms : 
  (range_srcref * id_t * access_t * id_t list * dcl_t) list * 
  sexe_t list *
  (range_srcref * iface_t) list *
  dir_t list
= 
  let rec aux asms dcls exes ifaces dirs =
    match asms with
    | [] -> (dcls,exes,ifaces, dirs)
    | h :: t -> 
      match h with 
      | Exe (sr,exe) -> aux t dcls ((sr,exe) :: exes) ifaces dirs
      | Dcl (sr,id,access,vs,dcl) -> aux t ((sr,id,access,vs,dcl) :: dcls) exes ifaces dirs
      | Iface (sr,iface) -> aux t dcls exes ((sr,iface) :: ifaces) dirs
      | Dir (sr,dir) -> aux t dcls exes ifaces (dir::dirs)
  in 
    aux asms [] [] [] []
 
let dump_name_to_int_map level name name_map =
  let spc = spaces level in
  print_endline (spc ^ "//Name to int map for " ^ name);
  print_endline (spc ^ "//---------------");
  Hashtbl.iter
  (
    fun id n ->
      print_endline ( "//" ^ spc ^ id ^ ": " ^ si n) 
  ) 
  name_map
  ;
  print_endline ""

  
 
let add_unique syms sr table key value =
  try 
    let entry = Hashtbl.find table key in
    match entry with 
    | NonFunctionEntry (idx) 
    | FunctionEntry (idx :: _ ) ->
       (match Hashtbl.find syms.dfns idx  with 
       | { sr=sr2 } ->
         clierr2 sr sr2 
         ("[build_tables] Duplicate non-function name declared " ^ key)
       )
     | _ ->
       clierr sr ("[build_tables] Duplicate non-function name declared " ^ key)

  with Not_found -> 
    Hashtbl.add table key (NonFunctionEntry (value))

let add_function syms sr table key value =
  try 
    match Hashtbl.find table key with
    | NonFunctionEntry entry -> 
      clierr sr 
      ("[build_tables] Cannot overload " ^ key ^ "<" ^ si value ^
      "> with non-function" ^ string_of_entry_kind entry)
    | FunctionEntry fs ->
      Hashtbl.remove table key;
      Hashtbl.add table key (FunctionEntry (value :: fs))
  with Not_found -> 
    Hashtbl.add table key (FunctionEntry [value])

let handle_cabs cabs =
  let is_complete = function | Some _ -> true | None -> false in
  let is_def fglo = match is_complete fglo with 
    | true -> "definition" 
    | false -> "incomplete"
  in
  let type_of_se = function
    | SpecType ts -> 
      begin match ts with
      | Tnamed s -> print_endline ("Alias " ^ s)
      | Tstruct (s,fglo,_) -> 
        print_endline ("struct " ^ s ^ " " ^ is_def fglo)
      | Tunion (s,fglo,_) -> 
        print_endline ("union " ^ s ^ " " ^ is_def fglo)
      | Tenum (s,fglo,_) -> 
        print_endline ("enum " ^ s ^ " " ^ is_def fglo)
      | _ -> ()
      end
    | _ -> ()
  in
  let types_in sp = List.iter type_of_se sp in

  let rec find_type d =
    let ns (s,_,_,_) = s in
    match d with
    | FUNDEF ((spec,s),b,_,_) -> 
      print_endline ("fun " ^ns s);
      types_in spec

    | DECDEF ((spec,ss),_) -> 
      List.iter 
      (fun (s,_)-> print_endline ("Decl " ^ ns s)) 
      ss
      ;
      types_in spec

    | TYPEDEF ((sp,ss),_)-> 
      List.iter 
      (fun s -> 
        print_endline ("typedef " ^ ns s);
      ) 
      ss
      ;
      types_in sp
     
    | LINKAGE (s,_,cabs') ->
      if s = "C"
      then List.iter find_type cabs'
      else print_endline ("Unknown linkage " ^s)
      
    | ONLYTYPEDEF (spec,_) -> types_in spec
    | GLOBASM _  
    | PRAGMA _ 
    | TRANSFORMER _
    | EXPRTRANSFORMER _ -> ()
  in
  List.iter find_type cabs

(* this routine takes a partially filled unbound definition table,
  'dfns' and a counter 'counter', and adds entries to the table
  at locations equal to and above the counter

  Each entity is also added to the name map of the parent entity.

  We use recursive descent, noting that the whilst an entity
  is not registered until its children are completely registered,
  its index is allocated before descending into child structures,
  so the index of children is always higher than its parent numerically

  The parent index is passed down so an uplink to the parent can
  be created in the child, but it cannot be followed until
  registration of all the children and their parent is complete
*)

let null_tab = Hashtbl.create 3 

let rec build_tables syms name level parent grandparent root asms = 
  let 
    print_flag = syms.compiler_options.print_flag and
    dfns = syms.dfns and
    counter = syms.counter
  in
  let dcls,exes,ifaces,dirs = split_asms asms in
  let dcls,exes,ifaces,dirs = 
    rev dcls,rev exes,rev ifaces, rev dirs
  in
  let ifaces = map (fun (i,j)-> i,j,parent) ifaces in
  let interfaces = ref ifaces in
  let spc = spaces level in
  let pub_name_map = Hashtbl.create 97 in
  let priv_name_map = Hashtbl.create 97 in

  (* check root index *)
  if level = 0 
  then begin
    if root <> !counter
    then failwith "Wrong value for root index";
    begin match dcls with
    | [x] -> ()
    | _ -> failwith "Expected top level to contain exactly one module declaration"
    end
  end
  ;
  Hashtbl.add priv_name_map "root" (NonFunctionEntry (root))
  ;
  begin 
    iter
    (
      fun (sr,id,access,vs',dcl) -> 
        let pubtab = Hashtbl.create 3 in (* dummy-ish table could contain type vars *)
        let privtab = Hashtbl.create 3 in (* dummy-ish table could contain type vars *)
        let add_unique table id idx = add_unique syms sr table id idx in
        let add_function table id idx = add_function syms sr table id idx in
        let n = !counter in 
        incr counter; 
        if print_flag then 
          print_endline 
          (
            "//" ^ spc ^ si n ^ " -> " ^ id ^ 
            " " ^ short_string_of_src sr
          )
        ;
        let vs = 
          map 
          (
            fun tid-> let n = !counter in incr counter; 
            if print_flag then
            print_endline ("//  "^spc ^ si n ^ " -> " ^ tid^ " (type variable)");
            tid,n
          ) 
          vs'
        in
        let add_tvars table =        
          iter
          (fun (tvid,i) ->
            Hashtbl.add dfns i 
            {
              id=tvid; 
              sr=sr; 
              parent=Some n;
              vs=[];
              pubmap=null_tab;
              privmap=null_tab;
              dirs=[];
              symdef=`SYMDEF_typevar `TYP_type
            };
            add_unique table tvid i 
          )
          vs
        in
        begin match (dcl:dcl_t) with
        | `DCL_regdef re ->
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_regdef re};
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          add_tvars privtab


        | `DCL_function (ps,t,props,asms) ->   
          let fun_index = n in
          let t = if t = `TYP_none then `TYP_var fun_index else t in
          let pubtab,privtab, exes, ifaces,dirs =  
            build_tables syms id (level+1) 
            (Some fun_index) parent root asms 
          in
          let ips = ref [] in
          iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ si n ^ " -> " ^ name^ " (parameter)");
            Hashtbl.add dfns n {id=name;sr=sr;parent=Some fun_index;vs=[];pubmap=null_tab;privmap=null_tab;dirs=[];symdef=`SYMDEF_parameter (typ)};
            if access = `Public then add_unique pubtab name n;
            add_unique privtab name n;
            ips := (name,typ) :: !ips 
          ) ps
          ; 
          Hashtbl.add dfns fun_index {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;
            symdef=`SYMDEF_function (rev !ips, t, props, exes)};
          if access = `Public then add_function pub_name_map id fun_index;
          add_function priv_name_map id fun_index;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars privtab

        | `DCL_match_check (pat,mvname) ->
          assert (length vs = 0);
          let fun_index = n in
          let match_var_index = 
            match Hashtbl.find priv_name_map mvname with
            | NonFunctionEntry (idx) -> idx
            | _ -> assert false
          in 
          Hashtbl.add dfns fun_index {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_match_check (pat, match_var_index)};
          if access = `Public then add_function pub_name_map id fun_index ;
          add_function priv_name_map id fun_index ;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars privtab

        | `DCL_match_handler (pat,mvname,asms) ->
          assert (length vs = 0);
          let vars = Hashtbl.create 97 in
          Flx_mbind.get_pattern_vars vars pat [];
          (*
          print_endline ("PATTERN IS " ^ string_of_pattern pat ^ ", VARIABLE=" ^ mvname);
          print_endline "VARIABLES ARE";
          Hashtbl.iter (fun vname (sr,extractor) ->
            let component = 
              Flx_mbind.gen_extractor extractor (`AST_name (sr,mvname,[])) 
            in
            print_endline ("  " ^ vname ^ " := " ^ string_of_expr component);
          ) vars;
          *)

          let new_asms = ref asms in
          Hashtbl.iter
          (fun vname (sr,extractor) ->
            let component = 
              Flx_mbind.gen_extractor extractor 
              (`AST_name (sr,mvname,[])) 
            in
            let empty_vs = [] in
            let dcl = Dcl (sr, vname, `Private, empty_vs,`DCL_val (`TYP_typeof (component))) 
            and instr = Exe (sr, `EXE_init (vname, component)) 
            in
              new_asms := dcl :: instr :: !new_asms;
          )
          vars;

          let fun_index = n in
          let pubtab,privtab, exes,ifaces,dirs = 
            build_tables syms id (level+1) 
            (Some fun_index) parent root !new_asms 
          in
          Hashtbl.add dfns fun_index {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;
            symdef=`SYMDEF_function ([],`TYP_var fun_index, [],exes)};
          if access = `Public then add_function pub_name_map id fun_index;
          add_function priv_name_map id fun_index;
          interfaces := !interfaces @ ifaces
          ;
          add_tvars privtab


        | `DCL_header (s,reqs) ->
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;
            symdef=`SYMDEF_header (s,reqs)
          };
          if access = `Public then add_function pub_name_map id n;
          add_function priv_name_map id n

        | `DCL_body (s,reqs) ->
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;
            symdef=`SYMDEF_body (s,reqs)
          };
          if access = `Public then add_function pub_name_map id n;
          add_function priv_name_map id n

        | `DCL_cabs cabs -> handle_cabs cabs

        | `DCL_module asms ->
          let pubtab,privtab, exes,ifaces,dirs = 
            build_tables syms id (level+1) (Some n) parent root
            asms
          in
          Hashtbl.add dfns n {
            id=id;sr=sr;
            parent=parent;vs=vs;
            pubmap=pubtab;privmap=privtab;
            dirs=dirs;
            symdef=`SYMDEF_module
          };
          let n' = !counter in
          incr counter;
          let init_def = `SYMDEF_function ( [],`AST_void sr, [],exes) in
          if print_flag then
          print_endline ("//  "^spc ^ si n' ^ " -> _init_  (module "^id^")");
          Hashtbl.add dfns n' {id="_init_";sr=sr;parent=Some n;vs=vs;pubmap=null_tab;privmap=null_tab;dirs=[];symdef=init_def};

          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n;
          if access = `Public then add_function pubtab ("_init_") n';
          add_function privtab ("_init_") n';
          interfaces := !interfaces @ ifaces
          ;
          add_tvars privtab
        
        | `DCL_val t ->
          let t = match t with | `TYP_none -> `TYP_var n | _ -> t in
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_val (t)}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          add_tvars privtab

        | `DCL_var t ->       
          let t = if t = `TYP_none then `TYP_var n else t in
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_var (t)}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          add_tvars privtab

        | `DCL_type_alias (t) ->
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_type_alias t}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          add_tvars privtab

        | `DCL_abs (flag,c, reqs) ->
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_abs (flag,c,reqs)}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          add_tvars privtab

        | `DCL_const (t,c, reqs) ->
          let t = if t = `TYP_none then `TYP_var n else t in
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_const (t,c,reqs)}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          add_tvars privtab

        | `DCL_fun (ts,t,c,reqs) ->
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;
            symdef=`SYMDEF_fun (ts,t,c,reqs)}
          ;
          if access = `Public then add_function pub_name_map id n;
          add_function priv_name_map id n
          ;
          add_tvars privtab

        | `DCL_union (its) ->
          let tvars = map (fun (s,_)-> `AST_name (sr,s,[])) vs in
          let utype = `AST_name(sr,id, tvars) in
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_union (its)}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          (* ASSIGNMENT NOT REQUIRED NOW
          (* assignment *)
          let asgn_idx = !counter in incr counter;
          let asgn_name = "_set" in
          let asgn_dcl = 
            `SYMDEF_fun
            (
              [ `TYP_pointer utype; utype ],
              `AST_void sr,
              "*$1=$2;",[]
            ) 
          in
          if print_flag then print_endline ("//  " ^ spc ^ si asgn_idx ^ " -> " ^ asgn_name); 
          Hashtbl.add dfns asgn_idx {id=asgn_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=asgn_dcl};
          if access = `Public then add_function pub_name_map asgn_name asgn_idx;
          add_function priv_name_map asgn_name asgn_idx
          ; 
          *)

          let unit_sum = 
            fold_left 
            (fun v (_,t) -> v && (match t with `AST_void _ -> true | _ -> false) )
            true 
            its
          in
          let ccount = ref 0 in (* count component constructors *)
          iter
          (fun (component_name,t) ->
            let dfn_idx = !counter in incr counter; (* constructor *)
            let match_idx = !counter in incr counter; (* matcher *)
            let ctor_idx = !ccount in incr ccount; (* ctor sequence in union *)
            let ctor_dcl =
              if unit_sum
              then begin
                  if access = `Public then add_unique pub_name_map component_name dfn_idx;
                  add_unique priv_name_map component_name dfn_idx;
                  `SYMDEF_const 
                  (
                    utype,
                    si ctor_idx,
                    []
                  )
              end
              else
                match t with
                | `AST_void _ -> (* constant constructor *)
                  if access = `Public then add_unique pub_name_map component_name dfn_idx;
                  add_unique priv_name_map component_name dfn_idx;
                  `SYMDEF_const 
                  (
                    utype,
                    "_uctor_(" ^ si ctor_idx ^ ",0)",
                    []
                  )
                | `TYP_tuple ts -> (* non-constant constructor or 2 or more arguments *)
                  if access = `Public then add_function pub_name_map component_name dfn_idx;
                  add_function priv_name_map component_name dfn_idx;
                  let dcl = 
                    `SYMDEF_fun 
                    (
                      ts,
                      utype,
                      "_uctor_(" ^ si ctor_idx ^ 
                      ", new(gc,@t) #t($t))",[]
                    )
                  in 
                    dcl
                | _ -> (* non-constant constructor of 1 argument *)
                  if access = `Public then add_function pub_name_map component_name dfn_idx;
                  add_function priv_name_map component_name dfn_idx;
                  `SYMDEF_fun (
                    [t],
                    utype,
                    "_uctor_(" ^ si ctor_idx ^ 
                    ", new(gc,@1) #1($1))",[]
                  )
            and ctor_match = 
              if unit_sum
              then
                `SYMDEF_fun 
                (
                  [utype],
                  flx_bool,
                  "($1 ==" ^ si ctor_idx ^")",[]
                )
              else
                `SYMDEF_fun 
                (
                  [utype],
                  flx_bool,
                  "($1.variant==" ^ si ctor_idx ^")",[]
                )
            and ctor_match_name ="_match_ctor_" ^ component_name 
            in

            if print_flag then print_endline ("//  " ^ spc ^ si dfn_idx ^ " -> " ^ component_name); 
            Hashtbl.add dfns dfn_idx {id=component_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=ctor_dcl};

            if print_flag then print_endline ("//  " ^ spc ^ si match_idx ^ " -> " ^ ctor_match_name); 
            Hashtbl.add dfns match_idx {id=ctor_match_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=ctor_match};

            if access = `Public then add_function pub_name_map ctor_match_name match_idx;
            add_function priv_name_map ctor_match_name match_idx;

            (* destructor *)
            match t with
            | `AST_void _ -> ()
            | _ -> (* non-constant constructor *)
              let dtor_idx = !counter in incr counter;
              let dtor_name = "_ctor_arg_" ^ component_name in
              let dtor_dcl = `SYMDEF_fun ([utype],t,"*(#0*)$1.data",[]) in
              if print_flag then print_endline ("//  " ^ spc ^ si dtor_idx ^ " -> " ^ dtor_name); 
              Hashtbl.add dfns dtor_idx {id=dtor_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=dtor_dcl};
              if access = `Public then add_function pub_name_map dtor_name dtor_idx;
              add_function priv_name_map dtor_name dtor_idx
          )
          its
          ;
          add_tvars privtab
 
        | `DCL_struct (sts) ->
          let tvars = map (fun (s,_)-> `AST_name (sr,s,[])) vs in
          let stype = `AST_name(sr,id,tvars) in
          Hashtbl.add dfns n {id=id;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=`SYMDEF_struct (sts)}
          ;
          if access = `Public then add_unique pub_name_map id n;
          add_unique priv_name_map id n
          ;
          (* ASSIGNMENT NOT REQUIRED NOW
          (* assignment *)
          let asgn_idx = !counter in incr counter;
          let asgn_name = "_set" in
          let asgn_dcl = 
            `SYMDEF_fun
            (
              [ `TYP_pointer stype; stype ],
              `AST_void sr,
              "*$1=$2;",[]
            ) 
          in
          if print_flag then print_endline ("//  " ^ spc ^ si asgn_idx ^ " -> " ^ asgn_name); 
          Hashtbl.add dfns asgn_idx {id=asgn_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=asgn_dcl};
          add_function name_map asgn_name asgn_idx
          ; 
          *)
          (* projections *)
          iter
          (fun (component_name,t) ->
            let getn = !counter in incr counter;
            let get_name = "get_" ^ component_name in
            let get_dcl = `SYMDEF_fun ([stype],t,"$1." ^ component_name,[]) in
            Hashtbl.add dfns getn {id=get_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=get_dcl};
            if access = `Public then add_function pub_name_map get_name getn;
            add_function priv_name_map get_name getn
            ;
            if print_flag then print_endline ("//  " ^ spc ^ si getn ^ " -> " ^ get_name)
            ; 
            let refn = !counter in incr counter;
            let ref_name = "ref_" ^ component_name in
            let ref_dcl = `SYMDEF_fun (
              [`TYP_pointer stype],
              `TYP_pointer t,
              "_ref_($1.frame,&($1->" ^ component_name ^"))",
              []
            ) 
            in
            Hashtbl.add dfns refn {id=ref_name;sr=sr;parent=parent;vs=vs;pubmap=pubtab;privmap=privtab;dirs=dirs;symdef=ref_dcl};
            if access = `Public then add_function pub_name_map ref_name refn;
            add_function priv_name_map ref_name refn
            ;
            if print_flag then print_endline ("//  " ^ spc ^ si refn ^ " -> " ^ ref_name)
          )
          sts
          ;
          add_tvars privtab

          (* NOTE: we don't add a type constructor, because 
          it would have the same name as the struct type ..
          we just check this case as required ..
          *)
        end
    ) 
    dcls
  end
  ;
  pub_name_map,priv_name_map,exes,!interfaces, dirs

