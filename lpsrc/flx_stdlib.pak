@import config
@from config.flx_data import rmap, tmap

@head(1,'Felix Standard Library')

@select(tangler('spkgs/flx_stdlib.py'))
import config

root = config.src_dir
unit_tests = [('test', 'stdlib', 'slrt-*.flx')]
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_gc','flx_pthread','demux','faio']
pkg_provides = ['flx_stdlib']

iscr_source = ['lpsrc/flx_stdlib.pak']
@doc()

@head(2,"Code")
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::rtl::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::rtl::strutil","Python style substring support")
@table_row("rtl/flx_ioutil","C++","flx::rtl::ioutil","Standard IO support")
@table_row("rtl/flx_executil","C++","flx::rtl::executil","Fibre suport")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()

@fc = {'float':'f', 'double':'','ldouble':'l'}

@def gen_nan(t):
  if config.TARGET_CXX.options.HAVE_CXX_ISNAN_IN_CMATH:
    tangle('  fun isnan: '+t+' -> bool = "std::isnan($1)" is postfix requires cmath;')
  elif config.TARGET_CXX.options.HAVE_C99_ISNAN_IN_MATH:
    tangle('  fun isnan: '+t+' -> bool = "isnan($1)" is postfix requires math_h;')
  elif config.TARGET_CXX.options.HAVE_BSD_ISNAN_IN_MATH:
    tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)" is postfix requires math_h;')
  elif config.TARGET_CXX.options.HAVE_BSD_ISNAN_IN_IEEEFP:
    tangle('  fun isnan: '+t+' -> bool = "isnanf'+fc[t]+'($1)" is postfix requires ieeefp_h;')
  else:
    tangle('  fun isnan: '+t+' -> bool = "!($1==$1)" is unary;')

  if config.TARGET_CXX.options.HAVE_CXX_ISINF_IN_CMATH:
    tangle('  fun isinf: '+t+' -> bool = "std::isinf($1)" is postfix requires cmath;')
  elif config.TARGET_CXX.options.HAVE_C99_ISINF_IN_MATH:
    tangle('  fun isinf: '+t+' -> bool = "isinf($1)" is postfix requires math_h;')
  elif config.TARGET_CXX.options.HAVE_BSD_ISINF_IN_MATH:
    tangle('  fun isinf: '+t+' -> bool = "isinf'+fc[t]+'($1)" is postfix requires math_h;')
  elif config.TARGET_CXX.options.HAVE_BSD_ISINF_IN_IEEEFP:
    tangle('  fun isinf: '+t+' -> bool = "isinf'+fc[t]+'($1)" is postfix requires ieeefp_h;')
  else:
    tangle('  fun isinf: '+t+' -> bool = "($1==$1 && $1+$1+1.0==$1)" is unary;')

  if config.TARGET_CXX.options.HAVE_CXX_ISFINITE_IN_CMATH:
    tangle('  fun isfinite: '+t+' -> bool = "std::isfinite($1)" is postfix requires cmath;')
  elif config.TARGET_CXX.options.HAVE_C99_ISFINITE_IN_MATH:
    tangle('  fun isfinite: '+t+' -> bool = "isfinite($1)" is postfix requires math_h;')
  elif config.TARGET_CXX.options.HAVE_BSD_FINITE_IN_MATH:
    tangle('  fun isfinite: '+t+' -> bool = "finite'+fc[t]+'($1)" is postfix requires math_h;')
  elif config.TARGET_CXX.options.HAVE_BSD_FINITE_IN_IEEEFP:
    tangle('  fun isfinite: '+t+' -> bool = "finite'+fc[t]+'($1)" is postfix requires ieeefp_h')
  else:
    tangle('  fun isfinite: '+t+' -> bool = "($1==$1 && $1!==0.0 && $1+$1!=$1)" is unary;')



@h=tangler('lib/flx.flxh','data')
@select(h)
open syntax felix;

@plats = ["WIN32","POSIX","LINUX","MACOSX","CYGWIN","SOLARIS","BSD"]

@for i in plats:
  if getattr(config, i):
    tangle("macro val " + i + " = true;")
  else:
    tangle("macro val " + i + " = false;")

@ctypes=tangler('lib/flx_ctypes.flx','data')
@select(ctypes)
header cctype_hxx = '#include <cctype>';
header string_hxx = '#include <string>';
header complex_hxx = '#include <complex>';
header c99_complex_h = '#include <complex.h>';

@if config.TARGET_CXX.options.HAVE_STDINT:
  tangle('header c99_stdint_h = "#include <stdint.h>";')
 else:
  tangle('header c99_stdint_h = "";')

header cstdlib = "#include <cstdlib>";
header cstring = "#include <cstring>";

@chars = ["char", "wchar", "uchar"]
@fast_sints = [
  "tiny", "short", "int", "long", "vlong"
  ]
@fast_uints = [
  "utiny", "ushort", "uint", "ulong", "uvlong"
  ]
@exact_sints = [
  "int8","int16","int32","int64"
  ]
@exact_uints = [
  "uint8","uint16","uint32","uint64"
  ]
@sints = fast_sints + exact_sints
@uints = fast_uints + exact_uints
@fast_ints = fast_sints + fast_uints
@exact_ints = exact_sints + exact_uints
@ints = uints + sints

@floats = ["float", "double", "ldouble"]

@complex = ["fcomplex","dcomplex","lcomplex"]
@imaginary= ["imaginary", "dimaginary", "limaginary"]
@all = [
  "byte", "address","caddress","vaddress","cvaddress",
  "offset",
  ] + chars + fast_ints + floats + complex + imaginary

@def gen_type(t):
  d = rmap.get(t,None)
  if d:
    tangle('pod type '+t+' = "'+tmap[t]+'" requires '+d+';')
  else:
    tangle('pod type '+t+' = "'+tmap[t]+'";')

@for t in all:
  gen_type(t)

_gc_pointer type gcaddress = "void*";
_gc_pointer type gcptr[t]= "?1*";

@fint2cint={
  'tiny':'signed char',
  'short':'short',
  'int':'int',
  'long':'long',
  'vlong':'long long',
  'utiny':'unsigned char',
  'ushort':'unsigned short',
  'uint':'unsigned int',
  'ulong':'unsigned long',
  'uvlong':'unsigned long long',
  }

@cint2fint = {}
@for f in fint2cint.keys(): cint2fint[fint2cint[f]]=f

@def alias_sint(t):
  if t == 'int8': size = 1
  elif t == 'int16': size = 2
  elif t == 'int32': size = 4
  elif t == 'int64': size = 8
  if SIZEOF_CHAR == size: return 'tiny'
  if SIZEOF_SHORT == size: return 'short'
  if SIZEOF_INT == size: return 'int'
  if SIZEOF_LONG == size: return 'long'
  if SIZEOF_LONGLONG == size: return 'vlong'

@def alias_uint(t):
  if t == 'uint8': size = 1
  elif t == 'uint16': size = 2
  elif t == 'uint32': size = 4
  elif t == 'uint64': size = 8
  if SIZEOF_CHAR == size: return 'utiny'
  if SIZEOF_SHORT == size: return 'ushort'
  if SIZEOF_INT == size: return 'uint'
  if SIZEOF_LONG == size: return 'ulong'
  if SIZEOF_LONGLONG == size: return 'uvlong'

@# mandatory in C
@for t in ['ptrdiff','size','intmax','uintmax','intptr','uintptr']:
  equiv = cint2fint[getattr(config.TARGET_CXX.options, 'ALIAS_'+t+'_t')]
  tangle('typedef ' + t + ' = ' + equiv + ';')

@# optional in C
@for t in exact_ints:
  equiv = cint2fint[getattr(config.TARGET_CXX.options, 'ALIAS_'+t+'_t')]
  tangle('typedef ' + t + ' = ' + equiv + ';')
  tangle('rename ' + string.capitalize(t) + ' = ' + string.capitalize(equiv) + ';')

typedef addressing = typesetof (
  byte,offset,
  address,caddress,vaddress,cvaddress
);

typedef chars = typesetof (char, wchar, uchar);

typedef fast_sints = typesetof (tiny, short, int, long, vlong);
typedef exact_sints = typesetof(int8,int16,int32,int64);
typedef fast_uints = typesetof (utiny, ushort, uint, ulong,uvlong);
typedef exact_uints = typesetof (uint8,uint16,uint32,uint64);

typedef sints = fast_sints || exact_sints;
typedef uints = fast_uints || exact_uints;

typedef fast_ints = fast_sints || fast_uints;
typedef exact_ints = exact_sints || exact_uints;

typedef ints = sints || uints;

typedef floats = typesetof (float, double, ldouble);
typedef reals = ints || floats;

typedef complexes = typesetof (fcomplex,dcomplex,lcomplex);
typedef complex[t in floats] = typematch t with
  | float => fcomplex
  | double => dcomplex
  | ldouble => lcomplex
  endmatch
;
// typedef imaginaries = typesetof (imaginary, dimaginary, limaginary);

typedef numbers = reals || /* imaginaries || */ complexes;

typedef basic_types = bool || numbers || chars || addressing;
include "plat/arithmax";

@select(tangler('lib/plat/arithmax.flx','data'))
// arithmetic conversion rule
typedef fun arithmax(l: TYPE, r: TYPE): TYPE =>
  typematch integral_promotion l, integral_promotion r with
@for f1 in fint2cint.keys():
  if f1 not in ['tiny','short','utiny','ushort']:
    for f2 in fint2cint.keys():
      if f2 not in ['tiny','short','utiny','ushort']:
        f3 = cint2fint[config.TARGET_CXX.options.arith_conv[(fint2cint[f1],fint2cint[f2])]]
        comment = ""
        if f1 == f2:
          if f2 <> f1: comment = "// ERROR"
        if (f1 == 'uvlong' or f2 == 'uvlong') and f3 <> 'uvlong':
          comment = "// ERROR, uvlong expected"
        elif f3 <> f1 and f3 <> f2:
          comment = "// SPECIAL PROMOTION"
        elif f1 == 'uint' and f2=='long' or f1=='long' and f2=='uint':
          comment = '// Representation Dependent (long or ulong)'
        if f1 == 'uvlong' or f2 == 'uvlong' or f3 == 'int':
          pass
        else:
          tangle('  | '+f1+','+f2+' => '+f3+' '+comment)
@#
  | uvlong,_ => uvlong
  | _,uvlong => uvlong
  | _,_ => int
  endmatch
;

include "plat/float";

@select(tangler('lib/plat/float.flx','data'))
@for t in floats:
  tangle("open module " + string.capitalize(t))
  tangle("{")
  tangle('  fun _ctor_'+t+': string -> '+t+' = "static_cast<'+tmap[t]+'>(std::atof($1.data()))" requires cstdlib;')
  tangle('  fun _ctor_'+t+'[T:reals]: T -> '+t+' = "static_cast<'+tmap[t]+'>($1)";')
  gen_nan(t)
  tangle('  proc fprint: ostream * '+t+' = "*$1<<$2;" requires iostream;')
  tangle("}")
  tangle("")


@select(ctypes)

fun _ctor_int: size -> int = "$1";
fun _ctor_size: int -> size = "$1";


instance [t in basic_types] Eq[t] {
  fun eq: t * t -> bool = "$1==$2";
}

instance Tord[address] {
  fun lt: address * address -> bool = "std::less<?1>($1,$2)";
}


instance[t in reals] Tord[t] {
  fun lt: t * t -> bool = "$1<$2";
}

instance[t in numbers] FloatAddgrp[t] {
  fun zero: unit -> t = "(?1)0" ;
  fun add: t * t -> t = "$1+$2" ;
  fun neg: t -> t = "-$1" ;
  fun sub: t * t -> t = "$1-$2" ;
  proc pluseq: lvalue[t] * t = "$1+=$2;";
  proc minuseq: lvalue[t] * t = "$1-=$2;";
}

instance[t in numbers] FloatMultSemi1[t] {
  fun one: unit -> t = "(?1)1";
  fun mul: t * t -> t = "$1*$2";
  proc muleq: lvalue[t] * t = "$1*=$2;";
}

instance[t in numbers] FloatRing[t] {}
instance[t in numbers] FloatDring[t] {
  fun div: t * t -> t = "$1/$2";
  fun mod: t * t -> t = "$1%$2";
  proc diveq: lvalue[t] * t = "$1/=$2;";
  proc modeq: lvalue[t] * t = "$1%=$2;";
}
include "std/bool";
include "std/int";

instance[T in addressing] Str[T] {
  fun str (t:T) : string => vsprintf (c"%i", t);
}

// Do we want this to be hex?
//instance[T in addressing] Repr[T] {
//  fun repr (t:T) : string => vsprintf (c"0x%x", t);
//}

include "std/mixedint";
include "std/float_format";
include "std/float_math";
include "std/char";

open Eq[byte];

open Tord[bool];
open Tord[address];
open Eq[caddress];
open Eq[vaddress];
open Eq[cvaddress];

open Eq[char];
open Eq[wchar];
open Eq[uchar];

open Signed_integer[tiny];
open Signed_integer[short];
open Signed_integer[int];
open Signed_integer[long];
open Signed_integer[vlong];
open Unsigned_integer[utiny];
open Unsigned_integer[ushort];
open Unsigned_integer[uint];
open Unsigned_integer[ulong];
open Unsigned_integer[uvlong];
open Real[float];
open Real[double];
open Real[ldouble];
open Complex[fcomplex, float];
open Complex[dcomplex, double];
open Complex[lcomplex, ldouble];
open CartComplex[float];
open CartComplex[double];
open CartComplex[ldouble];

//open FloatAddgrp[imaginary];
//open FloatAddgrp[dimaginary];
//open FloatAddgrp[limaginary];

open[T in basic_types] Show[T];
open Show[bool];
@doc()

@std=tangler('lib/std.flx','data')
@select(std)
header '#include "flx_rtl_config.hpp"';

header iostream = "#include <iostream>";
header cmath = "#include <cmath>";
header math_h = "#include <math.h>";
header ieeefp_h = """
extern "C" {
#include <ieeefp.h>
}
""";

header """
#include <cstdio>
#include <cstddef>
#include <cassert>
#include <climits>
using namespace std;
""";

header flx_ioutil = '#include "flx_ioutil.hpp"';
header flx_executil = '#include "flx_executil.hpp"';
header flx_dynlink = '#include "flx_dynlink.hpp"';
header flx_i18n = '#include "flx_i18n.hpp"';
header stdexcept = '#include <stdexcept>';

// note -- this code is templated, we include
// it in the header file because that's where
// most C++ compilers need it (ISO requires
// separate compilation of templates but most
// compilers as at 2004 don't implement it)

header flx_strutil = '#include "flx_strutil.hpp"';

include "flx_tclass";
include "flx_ctypes";

@absmap = {
  "tiny":"abs",
  "short":"abs",
  "int":"abs",
  "long":"labs",
  "vlong":"llabs"
  }

body swapper[t] = """
  void swapper(?1 &a, ?1 &b){
    ?1 tmp = a; a = b; b = tmp;
  }
""";

proc _swap[t]: lvalue[t] * lvalue[t] =
  "swapper($1,$2);"
  requires swapper[t];

typedef charp = C_hack::ptr[char];
typedef charcp = C_hack::cptr[char];

typedef ucharp = C_hack::ptr[utiny];
typedef ucharcp = C_hack::cptr[utiny];

publish "option type"
  union opt[T] =
    | None
    | Some of T
  ;

instance[T with Show[T]] Str[opt[T]] {
  fun str (x:opt[T]) =>
    match x with
    | Some ?x => "Some " + (str x)
    | None[T] => "None"
    endmatch
  ;
}

publish "slice type"
  union slice[T] =
    | Slice_all
    | Slice_from of T
    | Slice_to of T
    | Slice_range of T * T
    | Slice_one of T
  ;

publish "Universal type 'x as x'"
  typedef any = any;

publish "Lvalue hack"
  //typedef lvalue[t] = lval t;
  typedef lvalue[t] = t;

publish "Deref hack"
  //inline fun deref[t](p:&t):lval t => _deref p;
  inline fun deref[t](p:&t):t => _deref p;


@#------------- Pointers ---------------------------
open module Pointer
{
  fun eq[t]: &t * &t -> 2 = "$1==$2";
  fun ne[t]: &t * &t -> 2 = "$1!=$2";
}

@#------------- TYPING ---------------------------
open module Typing
{
  typedef fun dom(t:TYPE):TYPE =>
    typematch t with
    | ?a -> _ => a
    endmatch
  ;

  typedef fun cod(t:TYPE):TYPE =>
    typematch t with
    | _ -> ?b => b
    endmatch
  ;

  typedef fun prj1(t:TYPE):TYPE =>
    typematch t with
    | ?a * _ => a
    endmatch
  ;

  typedef fun prj2(t:TYPE):TYPE =>
    typematch t with
    | _ * ?b => b
    endmatch
  ;

  typedef fun type_land(x:TYPE, y:TYPE):TYPE =>
    typematch (x,  y) with
    | 0, _ => 0
    | _,0 => 0
    | _,_ => 1
    endmatch
  ;

  typedef fun type_lor(x:TYPE, y:TYPE):TYPE=>
    typematch (x,  y) with
    | 0, 0 => 0
    | _,_ => 1
    endmatch
  ;

  typedef fun eq(x:TYPE, y:TYPE):TYPE=>
    typematch x with
    | y => typematch y with | x => 1 | _ => 0 endmatch
    | _ => 0
    endmatch
  ;


  const memcount[t] : int = "#memcount";
}

@select(std)
include "c_hack";
include "debug";
include "std/carray";
include "std/system";
@h = tangler("lib/std/system.flx")
@select(h)
publish "System Interface"
module System
{
  const argc:int = "PTF argc";
  const _argv:&charp= "PTF argv";

  fun argv:int -> string = 'std::string($1<0||$1>=PTF argc??"":PTF argv[$1])';
  fun args () => List::map (the argv) (List::range argc);
@tangle('  const felix_version : string = \'std::string("'+config.flx_version+'")\';')
  fun system: string -> int = "std::system($1.data())"
    requires cstdlib;
  proc exit: int = "std::exit($1);";
  proc abort: 1 = "std::abort($1);";
  type ptf_t = "thread_frame_t*";
  const ptf:ptf_t = "FLX_POINTER_TO_THEAD_FRAME";
}

@select(std)
include "std/env";
include "std/dynlink";

@#------------- Filename -------------------
@select(std)
include "std/filename";
@h = tangler("lib/std/filename.flx")
@select(h)
module Filename
{
@if os.sep == '\\':
   # FFS!!! we put \\\\\\\\ here:
   # Python reduces it to \\\\             !!!
   # Felix then reduces it to \\           !!!
   # and finally C reduces it to plain \   !!!
   # don't remove the !!! because \ at eol is continuation .. argg
   tangle('  const sep : charp = c"\"\\\\\\\\\"";')
 else:
   tangle('  const sep : charp = c"\\"'+os.sep+'\\"";')
}

@select(std)
include "std/cstdio";
include "std/textio";
include "std/stdout";
include "std/string";
include "control";
include "std/list";
include "std/array";
include "std/varray";
include "std/avl";
include "std/lexer";
include "std/arith_casts";
include "std/cstdlib";

@select(std)
// ------ Open common modules -------------
open Arith_casts;
open Control;


