@head(1,'Felix Standard Library')

@execfile('config'+os.sep+'flx_data.py')
@include_file ('flx_stdlib_lex.ipk')

@select(tangler('spkgs/flx_stdlib.py'))
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','flx_gc','flx_pthread','demux','faio']
pkg_provides = ['flx_stdlib']

iscr_source = ['lpsrc/flx_stdlib.pak']
@doc()

@head(2,"Code")
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::rtl::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::rtl::strutil","Python style substring support")
@table_row("rtl/flx_ioutil","C++","flx::rtl::ioutil","Standard IO support")
@table_row("rtl/flx_executil","C++","flx::rtl::executil","Fibre suport")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()


@select(tangler('lib/flx_tclass.flxh', 'data'))
// Core types and type classes

typedef void = 0;
typedef unit = 1;
typedef bool = 2;


// equality
typeclass Eq[t] {
  virtual fun eq: t * t -> bool;
  virtual fun ne (x:t,y:t):bool => not (eq (x,y));
  axiom reflex(x:t): eq(x,x);
  axiom sym(x:t, y:t): eq(x,y) == eq(y,x);
  axiom trans(x:t, y:t, z:t): implies(eq(x,y) and eq(y,z), eq(x,z));
}

// this is a pain .. equality for pairs
instance[t,u with Eq[t], Eq[u]] Eq[t*u] {
  fun eq: (t * u) * (t * u) -> bool =
  | (?x1,?y1),(?x2,?y2) => x1==x2 and y1 == y2
  ;
}

open[t,u] Eq[t*u];

// equality for triples
instance[t,u,v with Eq[t], Eq[u], Eq[v]] Eq[t*u*v] {
  fun eq: (t * u * v) * (t * u * v) -> bool =
  | (?x1,?y1,?z1),(?x2,?y2,?z2) => x1==x2 and y1 == y2 and z1 == z2
  ;
}

open[t,u,v] Eq[t*u*v];


// total order
typeclass Tord[t]{
  inherit Eq[t];
  virtual fun lt: t * t -> bool; 
  virtual fun gt(x:t,y:t):bool =>lt(y,x);
  virtual fun le(x:t,y:t):bool => not (gt(x,y));
  virtual fun ge(x:t,y:t):bool => not (lt(x,y));
  virtual fun max(x:t,y:t):t=> if lt(x,y) then y else x endif;
  virtual fun min(x:t,y:t):t => if lt(x,y) then x else y endif;
}

// additive symmetric group
typeclass FloatAddgrp[t] {
  inherit Eq[t];
  virtual fun zero: 1 -> t;
  virtual fun add: t * t -> t;
  virtual fun neg: t -> t;
  virtual fun sub(x:t,y:t):t => add (x,neg y);
  virtual proc pluseq (x:lvalue[t],y:t){ x = x + y; }
  virtual proc minuseq (x:lvalue[t],y:t){ x = x - y; }

  reduce id (x:t): x+zero() => x;
  reduce id (x:t): zero()+x => x;
  reduce inv(x:t): x-x => zero();
  reduce inv(x:t): - (-x) => x;
  axiom sym (x:t,y:t): x+y == y+x;
}

typeclass Addgrp[t] {
  inherit FloatAddgrp[t];
  axiom assoc (x:t,y:t,z:t): (x+y)+z == x+(y+z);
  reduce inv(x:t,y:t): x+y-y => x;
}


typeclass Bits[t] {
  virtual fun bxor: t * t -> t;
  virtual fun bor: t * t -> t;
  virtual fun band: t * t -> t;
  virtual fun bnot: t -> t;
  virtual proc bxoreq: lvalue[t] * t;
  virtual proc boreq: lvalue[t] * t; 
  virtual proc bandeq: lvalue[t] * t;
}

// mult semi group with unit
typeclass FloatMultSemi1[t] {
  inherit Eq[t];
  virtual fun one: unit -> t;
  virtual fun mul: t * t -> t;
  virtual proc muleq: lvalue[t] * t;
  reduce id (x:t): x*one() => x;
  reduce id (x:t): one()*x => x;
}

// mult semi group with unit
typeclass MultSemi1[t] {
  inherit FloatMultSemi1[t];
  axiom assoc (x:t,y:t,z:t): (x*y)*z == x*(y*z);
  reduce cancel (x:t,y:t,z:t): x * z ==  y * z => x == y;
}

// ring
typeclass FloatRing[t] {
  inherit FloatAddgrp[t];
  inherit FloatMultSemi1[t];
}

// ring
typeclass Ring[t] {
  inherit Addgrp[t];
  inherit MultSemi1[t];
  axiom distrib (x:t,y:t,z:t): x * ( y + z) == x * y + x * z;
}

// division ring
typeclass FloatDring[t] {
  inherit FloatRing[t];
  virtual fun div: t * t -> t; // pre t != 0
  virtual proc diveq: lvalue[t] * t;
  virtual fun mod : t * t -> t;
  virtual proc modeq: lvalue[t] * t;
}

// division ring
typeclass Dring[t] {
  inherit Ring[t];
  inherit FloatDring[t];
}

typeclass Forward[t] {
  virtual fun succ: t -> t;
  virtual proc pre_incr: lvalue[t];
  virtual proc post_incr: lvalue[t];
}

typeclass Bidirectional[t] {
  inherit Forward[t];
  virtual fun pred: t -> t;
  virtual proc pre_decr: lvalue[t];
  virtual proc post_decr: lvalue[t];
}

typeclass IStream[f,t] {
  virtual gen read: f -> t;
}

typeclass OStream[f,t] {
  virtual proc write: f * t;
}

typeclass IOStream[f,t] {
  inherit IStream[f,t];
  inherit OStream[f,t];
}

typeclass IFile[f,t] {
  inherit IStream [f,opt[t]];
}

typeclass OFile[f,t] {
  inherit OStream;
  virtual proc close: f; // invalidates write operation
}

typeclass IBuffer [f] {
  virtual gen read: f -> address * int -> int * bool;
}

typeclass OBuffer [f] {
  virtual gen write : f -> address * int -> int * bool;
}

typeclass Iterator[it,t] {
  virtual fun deref: it -> lvalue[t];
}

typeclass Forward_iterator[it,t] {
  inherit Tord[it];
  inherit Forward[it];
  inherit Iterator[it,t];
}

typeclass Bidirectional_iterator[it,t] {
  inherit Forward_iterator[it,t];
  inherit Bidirectional[it];
}

typeclass Integer[t] {
  inherit Tord[t];
  inherit Dring[t];
  inherit Bidirectional[t];
}

// Signed Integers
typeclass Signed_integer[t] {
  inherit Integer[t];
  virtual fun sgn: t -> int;
  virtual fun abs: t -> t;
}

// Unsigned Integers
typeclass Unsigned_integer[t] {
  inherit Integer[t];
  inherit Bits[t];
}


typeclass Trig[t] {
  virtual fun sin: t -> t;
  virtual fun cos: t -> t;
  virtual fun tan: t -> t;
  virtual fun asin: t -> t;
  virtual fun acos: t -> t;
  virtual fun atan: t -> t;
  virtual fun sinh: t -> t;
  virtual fun cosh: t -> t;
  virtual fun tanh: t -> t;
  virtual fun asinh: t -> t;
  virtual fun acosh: t -> t;
  virtual fun atanh: t -> t;
  virtual fun exp: t -> t;
  virtual fun log: t -> t;
  virtual fun pow: t * t -> t;
}

typeclass Real[t] {
  inherit Tord[t];
  inherit Trig[t];
  inherit FloatDring[t];
  virtual fun log10: t -> t;
  virtual fun abs: t -> t;
  virtual fun sqrt: t -> t;
  virtual fun ceil: t -> t;
  virtual fun floor: t -> t;
  virtual fun trunc: t -> t;
}

typeclass Complex[t] {
  inherit Eq[t];
  inherit Trig[t];
  virtual fun arg: t -> t;
}

typeclass Container [c,v]
{
  virtual fun len: c -> size;
  virtual fun empty(x: c): bool => len x == size(0);
}

typeclass Sequence[c,it,v] {
  inherit Eq[c];
  inherit Forward_iterator[it,v];
  inherit Container[c,v];
  virtual gen begin: c -> it;
  virtual gen end: c -> it;
  virtual proc erase: lvalue[c] * it;
  virtual proc erase_between: lvalue[c] * it * it;
  virtual proc clear: lvalue[c];
  virtual fun fold[i]: (i->v->i) -> i -> c -> i;
}

typeclass Reversible_Sequence[c,it,rit,v] {
  inherit Sequence[c,it,v];
  inherit Bidirectional_iterator[it,v];
  inherit Bidirectional_iterator[rit,v];
  virtual gen rbegin: c -> rit;
  virtual gen rend: c -> rit;
  virtual fun rfold[i]: (i->v->i) -> i -> c -> i;
}

typeclass Monad [M: TYPE->TYPE] {
  virtual fun bind[a,b]: M a * (a -> M b) -> M b;
  virtual fun ret[a]: a -> M a;
}

typeclass Str [T] {
  virtual fun str: T -> string;
}

typeclass Repr [T with Str[T]] {
  virtual fun repr (t:T) : string => str t;
}

typeclass Show [T] {
  inherit Str[T];
  inherit Repr[T];
}

@fc = {'float':'f', 'double':'','ldouble':'l'}

@def gen_nan(t):
  if HAVE_ISNAN_IN_CMATH:
    tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)" is postfix requires cmath;')
  elif HAVE_ISNAN_IN_IEEEFP:
    tangle('  fun isnan: '+t+' -> bool = "isnanf'+fc[t]+'($1)" is postfix requires cmath;')
  else:
    tangle('  fun isnan: '+t+' -> bool = "!($1==$1)" is unary requires cmath;')


@h=tangler('lib/flx.flxh','data')
@select(h)
#import <flx_syntax.flxh>
#import <flx_macros.flxh>
#import <flx_platform.flxh>
include "std";

@h=tangler('lib/flx_macros.flxh','data')
@select(h)
macro val true = case 1 of 2;
macro val false = case 0 of 2;
macro fun print_line (x) = { fprint (cout,x); Stdout::endl cout; };
macro fun print(x) = { fprint (cout,x); };

@h=tangler('lib/flx_syntax.flxh','data')
@select(h)
#infix 10 "/\\" wedge
#infix 10 "\\/" vee
#infix 10 ">>=" bind


#statement#
  whilst expr do statements done ; =># 
  macro {
    macro lab1 is new;
    macro lab2 is new;
    lab1:> 
      if not _1 goto lab2;
      _3;
      goto lab1;
    lab2:>
  };
#

#statement#
  until expr do statements done; =># 
  macro {
    macro lab1 is new;
    macro lab2 is new;
    lab1:> 
      if _1 goto lab2;
      _3;
      goto lab1;
    lab2:>
  };
#

#statement#
  forall ident in expr do statements done ; =># 
    macro for val _1 in _3 do _5; done;
#

#keyword upto
#statement# 
  forall ident in expr upto expr do statements done ; =># 
  _1 = _3;
  whilst _1 <= _5 do _7; ++_1; done;
#

#keyword downto
#statement# 
  forall ident in expr downto expr do statements done ; =># 
  _1 = _3;
  whilst _1 >= _5 do _7; --_1; done;
#

#statement publish #
  string_literal statement =># _2;
#
  
@h=tangler('lib/flx_platform.flxh','data')
@select(h)
#define true case 1 of 2
#define false case 0 of 2

@plats = ["WIN32","POSIX","LINUX","MACOSX","CYGWIN","SOLARIS","BSD"]
@for i in plats:
  if(eval(i)==1):
    tangle("#define " + i + " true")
  else:
    tangle("#define " + i + " false")
@#

macro val true = case 1 of 2;
macro val false = case 0 of 2;

@for i in plats:
  x = eval(i)
  if x == 1: y = "true"
  else: y = "false" 
  tangle("macro val " + i + " = " + y + ";")

@h=tangler('lib/flx_ctypes.flxh','data')
@select(h)
#import <flx_syntax.flxh>

header cctype_hxx = '#include <cctype>';
header string_hxx = '#include <string>';
header complex_hxx = '#include <complex>';
header c99_complex_h = '#include <complex.h>';

@if HAVE_STDINT:
  tangle('header c99_stdint_h = "#include <stdint.h>";')
 else:
  tangle('header c99_stdint_h = "";')

header cstdlib = "#include <cstdlib>";
header cstring = "#include <cstring>";

@chars = ["char", "wchar", "uchar"]
@fast_sints = [
  "tiny", "short", "int", "long", "vlong"
  ]
@fast_uints = [
  "utiny", "ushort", "uint", "ulong", "uvlong"
  ]
@exact_sints = [
  "int8","int16","int32","int64"
  ]
@exact_uints = [
  "uint8","uint16","uint32","uint64"
  ]
@sints = fast_sints + exact_sints
@uints = fast_uints + exact_uints
@fast_ints = fast_sints + fast_uints
@exact_ints = exact_sints + exact_uints
@ints = uints + sints

@floats = ["float", "double", "ldouble"]

@complex = ["complex","dcomplex","lcomplex"]
@imaginary= ["imaginary", "dimaginary", "limaginary"]
@all = [
  "byte", "address","caddress","vaddress","cvaddress",
  "offset", 
  ] + chars + fast_ints + floats + complex + imaginary

@def gen_type(t):
  d = rmap.get(t,None)
  if d:
    tangle('pod type '+t+' = "'+tmap[t]+'" requires '+d+';')
  else:
    tangle('pod type '+t+' = "'+tmap[t]+'";')

@for t in all:
  gen_type(t)

_gc_pointer type gcaddress = "void*";
_gc_pointer type gcptr[t]= "?1*";

@fint2cint={
  'tiny':'signed char',
  'short':'short',
  'int':'int',
  'long':'long',
  'vlong':'long long',
  'utiny':'unsigned char',
  'ushort':'unsigned short',
  'uint':'unsigned int',
  'ulong':'unsigned long',
  'uvlong':'unsigned long long',
  }

@cint2fint = {}
@for f in fint2cint.keys(): cint2fint[fint2cint[f]]=f

@def alias_sint(t):
  if t == 'int8': size = 1
  elif t == 'int16': size = 2
  elif t == 'int32': size = 4
  elif t == 'int64': size = 8
  if SIZEOF_CHAR == size: return 'tiny'
  if SIZEOF_SHORT == size: return 'short'
  if SIZEOF_INT == size: return 'int'
  if SIZEOF_LONG == size: return 'long'
  if SIZEOF_LONGLONG == size: return 'vlong'

@def alias_uint(t):
  if t == 'uint8': size = 1
  elif t == 'uint16': size = 2
  elif t == 'uint32': size = 4
  elif t == 'uint64': size = 8
  if SIZEOF_CHAR == size: return 'utiny'
  if SIZEOF_SHORT == size: return 'ushort'
  if SIZEOF_INT == size: return 'uint'
  if SIZEOF_LONG == size: return 'ulong'
  if SIZEOF_LONGLONG == size: return 'uvlong'

@# mandatory in C
@for t in ['ptrdiff','size','intmax','uintmax','intptr','uintptr']:
  equiv = cint2fint[eval('ALIAS_'+t+'_t')]
  tangle('typedef ' + t + ' = ' + equiv + ';')

@# optional in C
@for t in exact_ints:
  equiv = cint2fint[eval('ALIAS_'+t+'_t')]
  tangle('typedef ' + t + ' = ' + equiv + ';')
  tangle('rename ' + string.capitalize(t) + ' = ' + string.capitalize(equiv) + ';')

typedef addressing = typesetof (
  byte,offset,
  address,caddress,vaddress,cvaddress
);

typedef chars = typesetof (char, wchar, uchar);

typedef fast_sints = typesetof (tiny, short, int, long, vlong);
typedef exact_sints = typesetof(int8,int16,int32,int64);
typedef fast_uints = typesetof (utiny, ushort, uint, ulong,uvlong);
typedef exact_uints = typesetof (uint8,uint16,uint32,uint64);

typedef sints = fast_sints || exact_sints;
typedef uints = fast_uints || exact_uints;

typedef fast_ints = fast_sints || fast_uints;
typedef exact_ints = exact_sints || exact_uints;

typedef ints = sints || uints;

typedef floats = typesetof (float, double, ldouble);
typedef reals = ints || floats;

typedef complexes = typesetof (complex,dcomplex,lcomplex);
typedef imaginaries = typesetof (imaginary, dimaginary, limaginary);

typedef numbers = reals || imaginaries || complexes;

typedef basic_types = bool || numbers || chars || addressing;

// C integer promotion rule
typedef fun integral_promotion: TYPE -> TYPE =
  | tiny => int
  | utiny => int
  | short => int
  | ushort => int
  | int => int
  | uint => uint
  | long => long
  | ulong => ulong
  | vlong => vlong
  | uvlong => uvlong
;

// arithmetic conversion rule 
typedef fun arithmax(l: TYPE, r: TYPE): TYPE =>
  typematch integral_promotion l, integral_promotion r with
@for f1 in fint2cint.keys():
  if f1 not in ['tiny','short','utiny','ushort']:
    for f2 in fint2cint.keys():
      if f2 not in ['tiny','short','utiny','ushort']:
        f3 = cint2fint[arith_conv[(fint2cint[f1],fint2cint[f2])]]
        comment = ""
        if f1 == f2:
          if f2 <> f1: comment = "// ERROR"
        if (f1 == 'uvlong' or f2 == 'uvlong') and f3 <> 'uvlong':
          comment = "// ERROR, uvlong expected"
        elif f3 <> f1 and f3 <> f2:
          comment = "// SPECIAL PROMOTION"
        elif f1 == 'uint' and f2=='long' or f1=='long' and f2=='uint':
          comment = '// Representation Dependent (long or ulong)'
        if f1 == 'uvlong' or f2 == 'uvlong' or f3 == 'int':
          pass
        else:
          tangle('  | '+f1+','+f2+' => '+f3+' '+comment)
@#
  | uvlong,_ => uvlong
  | _,uvlong => uvlong
  | _,_ => int
  endmatch
;

fun _ctor_int: size -> int = "$1";
fun _ctor_size: int -> size = "$1";


instance [t in basic_types] Eq[t] {
  fun eq: t * t -> bool = "$1==$2";
}

instance[t in reals] Tord[t] {
  fun lt: t * t -> bool = "$1<$2";
}

instance[t in numbers] FloatAddgrp[t] {
  fun zero: 1 -> t = "(?1)0" ;
  fun add: t * t -> t = "$1+$2" ;
  fun neg: t -> t = "-$1" ;
  fun sub: t * t -> t = "$1-$2" ;
  proc pluseq: lvalue[t] * t = "$1+=$2;";
  proc minuseq: lvalue[t] * t = "$1-=$2;";
}
instance[t in ints] Addgrp[t] {}

instance[t in numbers] FloatMultSemi1[t] {
  fun one: unit -> t = "(?1)1";
  fun mul: t * t -> t = "$1*$2";
  proc muleq: lvalue[t] * t = "$1*=$2;";
}
instance[t in ints] MultSemi1[t] {}

instance[t in numbers] FloatRing[t] {}
instance[t in ints] Ring[t] {}

instance[t in numbers] FloatDring[t] {
  fun div: t * t -> t = "$1/$2";
  fun mod: t * t -> t = "$1%$2";
  proc diveq: lvalue[t] * t = "$1/=$2;";
  proc modeq: lvalue[t] * t = "$1%=$2;";
}
instance[t in ints] Dring[t] {}

instance [t in fast_uints] Bits [t] {
  fun bxor: t * t -> t = "$1^$2";
  fun bor: t * t -> t = "$1|$2";
  fun band: t * t -> t = "$1&$2";
  fun bnot: t -> t = "~$1";
  proc bxoreq: lvalue[t] * t = "$1^=$2;";
  proc boreq: lvalue[t] * t = "$1|=$2;";
  proc bandeq: lvalue[t] * t = "$1&=$2;";
}

instance[t in ints] Forward[t] {
  fun succ: t -> t = "$1+1";
  proc pre_incr: lvalue[t] = "++$1;";
  proc post_incr: lvalue[t] = "$1++;";
}

instance[t in ints] Bidirectional[t] {
  fun pred: t -> t = "$1-1";
  proc pre_decr: lvalue[t] = "--$1;";
  proc post_decr: lvalue[t] = "$1--;";
}

instance[t in ints] Integer[t] { }

instance[t in fast_sints] Signed_integer[t] {
  fun sgn: t -> int = "$1<0??-1:$1>0??1:0";
  fun abs: t -> t = "$1<0??-$1:$1";
}

instance[t in fast_uints] Unsigned_integer[t] {}

@#------------- BOOL -------------------
open module Bool 
{

  fun land: bool * bool -> bool = "$1&&$2";
  fun nand: bool * bool -> bool = "!($1&&$2)";
  fun lor: bool * bool -> bool = "$1||$2";
  fun nor: bool * bool -> bool = "!($1||$2)";
  fun xor: bool * bool -> bool = "$1!=$2";
  fun lnot: bool -> bool = "!$1";
  fun implies: bool * bool -> bool = "!$1||$2";
  fun eq: bool * bool -> bool = "$1==$2";
  fun ne: bool * bool -> bool = "$1!=$2";
  proc fprint: ostream * bool = '*$1<<($2??"true":"false");' requires iostream;
}

instance Str[bool] {
  fun str (b:bool) : string => if b then "true" else "false" endif;
}

type string = "std::string";
@for t in fast_ints:
  tangle("open module " + string.capitalize(t))
  tangle("{")
  tangle('  fun _ctor_'+t+': string -> '+t+' = "static_cast<'+tmap[t]+'>(std::atoi($1.data()))" requires cstdlib;')
  tangle('  fun _ctor_'+t+'[T in reals]: T -> '+t+' = "static_cast<'+tmap[t]+'>($1)";')
  #if t in fast_sints:
  #  tangle('  fun abs: '+t+' -> '+t+' = "'+absmap[t]+'($1)";')
  if t == "tiny":
    tangle('  proc fprint: ostream * tiny = "*$1<<(int)$2;" requires iostream;')
  elif t == "utiny":
    tangle('  proc fprint: ostream * utiny = "*$1<<(unsigned int)$2;" requires iostream;')
  else:
    tangle('  proc fprint: ostream * '+t+' = "*$1<<$2;" requires iostream;')
  tangle("}")
  tangle("")

instance Str[tiny] {
  fun str: tiny -> string = "flx::rtl::strutil::str<int>($1)" requires flx_strutil;
}

instance Str[utiny] {
  fun str: utiny -> string = "flx::rtl::strutil::str<unsigned int>($1)" requires flx_strutil;
}

instance[T in short||ushort||int||uint||long||ulong||vlong||uvlong||float||double||ldouble] Str[T] {
  fun str: T -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;
}

instance Repr[tiny]   { fun repr[with Str[tiny]] (t:tiny)   : string => (str t) + "t";  }
instance Repr[utiny]  { fun repr[with Str[utiny]] (t:utiny)  : string => (str t) + "ut"; }
instance Repr[short]  { fun repr[with Str[short]] (t:short)  : string => (str t) + "s";  }
instance Repr[ushort] { fun repr[with Str[ushort]] (t:ushort) : string => (str t) + "us"; }
instance Repr[uint]   { fun repr[with Str[uint]] (t:uint)   : string => (str t) + "u";  }
instance Repr[long]   { fun repr[with Str[long]] (t:long)   : string => (str t) + "l";  }
instance Repr[ulong]  { fun repr[with Str[ulong]] (t:ulong)  : string => (str t) + "ul"; }
instance Repr[vlong]  { fun repr[with Str[vlong]] (t:vlong)  : string => (str t) + "v";  }
instance Repr[uvlong] { fun repr[with Str[uvlong]] (t:uvlong) : string => (str t) + "uv"; }

instance[T in addressing] Str[T] {
  fun str (t:T) : string => vsprintf (c"%i", t);
}

// Do we want this to be hex?
//instance[T in addressing] Repr[T] {
//  fun repr (t:T) : string => vsprintf (c"0x%x", t);
//}

@#------------- INTEGER MODULES -------------------

publish "Mixed Mode arithmentic"
module MixedInt 
{
  fun add[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1+$2";
  fun sub[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1-$2";
  fun mul[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1*$2";
  fun div[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1/$2";
  fun mod[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1%$2";

  fun band[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1&$2";
  fun bor[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1|$2";
  fun bxor[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1^$2";
  fun shl[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1<<$2";
  fun shr[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1>>$2";

  fun lt[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> bool = "$1<$2";
  fun le[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> bool = "$1<=$2";
  fun eq[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> bool = "$1==$2";
  fun ne[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> bool = "$1!=$2";
  fun gt[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> bool = "$1>$2";
  fun ge[t1 in fast_ints, t2 in fast_ints]: t1 * t2 -> bool = "$1>=$2";
}

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("open module " + string.capitalize(t))
  tangle("{")
  tangle('  fun _ctor_'+t+': string -> '+t+' = "static_cast<'+tmap[t]+'>(std::atof($1.data()))" requires cstdlib;')
  tangle('  fun _ctor_'+t+'[T:reals]: T -> '+t+' = "static_cast<'+tmap[t]+'>($1)";')
  gen_nan(t)
  tangle('  proc fprint: ostream * '+t+' = "*$1<<$2;" requires iostream;')
  tangle('  //fun str: '+t+' -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;')
  tangle("}")
  tangle("")

instance[t in floats] Trig[t] {
  requires cmath;
  fun sin: t -> t = "std::sin($1)";
  fun cos: t -> t = "std::cos($1)";
  fun tan: t -> t = "std::tan($1)";
  fun asin: t -> t = "std::asin($1)";
  fun acos: t -> t = "std::acos($1)";
  fun atan: t -> t = "std::atan($1)";
  fun sinh: t -> t = "std::sinh($1)";
  fun cosh: t -> t = "std::cosh($1)";
  fun tanh: t -> t = "std::tanh($1)";
  fun asinh: t -> t = "std::asinh($1)";
  fun acosh: t -> t = "std::acosh($1)";
  fun atanh: t -> t = "std::atanh($1)";
  fun exp: t -> t = "std::exp($1)";
  fun log: t -> t = "std::log($1)";
  fun pow: t * t -> t = "std::pow($1,$2)";
}

instance[t in floats] Real[t] {
  fun abs: t -> t = "std::abs($1)";
  fun log10: t -> t = "std::log10($1)";
  fun sqrt: t -> t = "std::sqrt($1)";
  fun ceil: t -> t = "std::ceil($1)";
  fun floor: t -> t = "std::floor($1)";
  fun trunc: t -> t = "std::trunc($1)";
}

@#------------- CHARACTER MODULES -------------------
// ordinary value of chars

open module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun _ctor_char: int -> char = "(char)$1";
  //fun str: char -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;
  proc fprint: ostream * char = "*$1<<$2;" requires iostream;
}

open module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun _ctor_wchar: long -> wchar = "(wchar_t)$1";
  //fun str: wchar -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;
  proc fprint: ostream * wchar = "*$1<<$2;" requires iostream;
}

open module Unicode
{
  fun ord: uchar -> uint32 ="$1";
  fun _ctor_uchar: uint32 -> uchar = "$1";
  //fun str: uchar -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;" requires iostream;
}

instance[T in chars] Str[T] {
  fun str: T -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;
}

instance[T in chars] Repr[T] {
  fun repr[with Str[T]] (c:T) : string = {
    val s = str c;
    return
      match s with
      | "'" =>  "\\'"
      | '\t' => '\\t'
      | '\n' => '\\n'
      | '\r' => '\\r'
      | '\f' => '\\f'
      | '\v' => '\\v'
      | _    => s
      endmatch
    ;
  }
}

open Eq[byte];

open Eq[address];
open Eq[caddress];
open Eq[vaddress];
open Eq[cvaddress];

open Eq[char];
open Eq[wchar];
open Eq[uchar];

open Signed_integer[tiny];
open Signed_integer[short];
open Signed_integer[int];
open Signed_integer[long];
open Signed_integer[vlong];
open Unsigned_integer[utiny];
open Unsigned_integer[ushort];
open Unsigned_integer[uint];
open Unsigned_integer[ulong];
open Unsigned_integer[uvlong];
open Real[float];
open Real[double];
open Real[ldouble];
open FloatAddgrp[complex];
open FloatAddgrp[dcomplex];
open FloatAddgrp[lcomplex];
open FloatAddgrp[imaginary];
open FloatAddgrp[dimaginary];
open FloatAddgrp[limaginary];

open[T in basic_types] Show[T];
@doc()
  
@h=tangler('lib/std.flx','data')
@# use data tangler to prevent line number generation
@select(h)
#import <flx_syntax.flxh>
#import <flx_platform.flxh>
#import <flx_macros.flxh>

header '#include "flx_rtl_config.hpp"';

header iostream = "#include <iostream>";
header cmath = """
#include <cmath>
#ifdef HAVE_ISNAN_IN_IEEEFP
extern "C" {
#include <ieeefp.h>
}
#endif
""";

header """
#include <cstdio>
#include <cstddef>
#include <cassert>
#include <climits>
using namespace std;
""";

header flx_ioutil = '#include "flx_ioutil.hpp"';
header flx_executil = '#include "flx_executil.hpp"';
header flx_dynlink = '#include "flx_dynlink.hpp"';
header flx_i18n = '#include "flx_i18n.hpp"';
header stdexcept = '#include <stdexcept>';

// note -- this code is templated, we include
// it in the header file because that's where
// most C++ compilers need it (ISO requires
// separate compilation of templates but most
// compilers as at 2004 don't implement it)

header flx_strutil = '#include "flx_strutil.hpp"';

#import <flx_tclass.flxh>
#import <flx_ctypes.flxh>

@absmap = { 
  "tiny":"abs",
  "short":"abs",
  "int":"abs",
  "long":"labs",
  "vlong":"llabs"
  }

body swapper[t] = """
  void swapper(?1 &a, ?1 &b){
    ?1 tmp = a; a = b; b = tmp;
  }
""";

proc _swap[t]: lvalue[t] * lvalue[t] = 
  "swapper($1,$2);"
  requires swapper[t];

typedef charp = C_hack::ptr[char];
typedef charcp = C_hack::cptr[char];

typedef ucharp = C_hack::ptr[utiny];
typedef ucharcp = C_hack::cptr[utiny];

publish "option type"
  union opt[T] =
    | None
    | Some of T
  ;

publish "slice type"
  union slice[T] =
    | Slice_all
    | Slice_from of T
    | Slice_to of T
    | Slice_range of T * T
    | Slice_one of T
  ;

publish "Universal type 'x as x'"
  typedef any = any;

publish "Lvalue hack"
  typedef lvalue[t] = lval t;

publish "Deref hack"
  inline fun deref[t](p:&t):lval t => _deref p;
 

@#------------- Pointers ---------------------------
open module Pointer
{
  fun eq[t]: &t * &t -> 2 = "$1==$2";
  fun ne[t]: &t * &t -> 2 = "$1!=$2";
}

@#------------- TYPING ---------------------------
open module Typing
{
  typedef fun dom(t:TYPE):TYPE =>
    typematch t with
    | ?a -> _ => a
    endmatch
  ;

  typedef fun cod(t:TYPE):TYPE =>
    typematch t with
    | _ -> ?b => b
    endmatch
  ;
  
  typedef fun prj1(t:TYPE):TYPE =>
    typematch t with
    | ?a * _ => a
    endmatch
  ;

  typedef fun prj2(t:TYPE):TYPE =>
    typematch t with
    | _ * ?b => b
    endmatch
  ;

  typedef fun type_land(x:TYPE, y:TYPE):TYPE => 
    typematch (x,  y) with
    | 0, _ => 0
    | _,0 => 0
    | _,_ => 1
    endmatch
  ;

  typedef fun type_lor(x:TYPE, y:TYPE):TYPE=>
    typematch (x,  y) with
    | 0, 0 => 0
    | _,_ => 1
    endmatch
  ;
  
  typedef fun eq(x:TYPE, y:TYPE):TYPE=>
    typematch x with
    | y => typematch y with | x => 1 | _ => 0 endmatch
    | _ => 0
    endmatch
  ;


  const memcount[t] : int = "#memcount";
}
  
@#------------- CASTS and C HACKERY ---------------
publish """
This module provides access to raw C/C++ encodings.
Incorrect typing is likely to pass by Felix and
be trapped by the C/C++ compiler. Incorrect management
of storage can lead to corruption. The use of the
C_hack module is necessary for interfacing.
"""
module C_hack
{
  publish "C void"
  incomplete type void_t = "void";

  publish "standard variable argument list pointer type"
  type va_list = "va_list";

  publish """
  GCC specific valist thingo: it will
  be optimised away if not used (eg on MSVC)
  """
  type __builtin_va_list = '__builtin_va_list';

  publish """
  Throw away result of a function call:
  only useful for C functions that are mainly
  called for side effects.
  """
  proc ignore[t]:t = "(void)$t;";
  
  fun cast[dst,src]: src->dst = '(?1)($1)';
  fun static_cast[dst,src]: src->dst = 'static_cast<?1>($1)';
  fun dynamic_cast[dst,src]: src->dst = 'dynamic_cast<?1>($1)';
  fun const_cast[dst,src]: src->dst = 'const_cast<?1>($1)';
  fun reinterpret_cast[dst,src]: src->dst = 'reinterpret_cast<?1>($1)';
  fun reinterpret[dst,src]: src->dst = 'reinterpret<?1>($1)';

  const sizeof[t]:size = 'sizeof(?1)';

  // deprecated
  fun int_of:size->int='$1';
  fun size_of:int->size='$1';

  fun eq: address * address -> bool = "$1==$2";
  fun ne: address * address -> bool = "$1!=$2";

  publish "Abstract type for C pointer"
  pod type ptr[t]="?1 *";

  publish "Abstract type for C pointer to const"
  pod type cptr[t]="?1 const *";

  publish "Convert pointer to pointer to const"
  fun enconst[t]: ptr[t]->cptr[t] = "(?1 const*)$1";

  publish """
  Unsafe function to get C pointer from Felix reference.
  The pointer may dangle if the collector deletes the 
  frame containing the object. 
  """
  fun unref[t]: &t->ptr[t] = "(?1*)($1.get_data())";

  publish """
  Function to make Felix reference from C pointer.
  This function is only safe if the C pointer
  was not allocated by the Felix collector:
  the resulting reference will never be collected
  (because the frame pointer is set to 0)
  """
  fun mkref[t]: ptr[t]->&t = "(#0 const&)flx::rtl::_ref_(0,(void*)$1-NULL)";
  fun mkref[t]: gcptr[t]->&t = "(#0 const&)flx::rtl::_ref_(0,(void*)$1-NULL)";

  publish """
  Dereference a C pointer. If the expression is an
  an lvalue, the result is an lvalue. Assignments
  to const lvalues are trapped by the C/C++ compiler.
  """
  fun deref[t]: ptr[t] -> lvalue[t] = "*$1";
  fun deref[t]: cptr[t] -> lvalue[t] = "*$1";
  fun deref[t]: gcptr[t] -> lvalue[t] = "*$1";

  publish """
  Function to take the address of a C lvalue,
  fails in C/C++ compiler if the argument isn't an lvalue.
  Addresses of Felix variables are safe to use provided the
  containing frame won't be collected. 
  Addresses of temporaries must not be taken.
  """
  fun _ctor_ptr[t]: lvalue[t] -> ptr[t] = "&$1";
  fun _ctor_cptr[t]: lvalue[t] -> cptr[t] = "(void*)&$1";
  fun _ctor_address[t]: ptr[t] -> address = "(void*)$1";
  fun _ctor_address[t]: lvalue[t] -> address = "(void*)&$1";

  // deprecated
  fun addr[t]: lvalue[t] -> ptr[t] = "&$1";
  fun caddr[t]: lvalue[t] -> cptr[t] ="(?1 const*)&$1";

  fun as_address[t]: ptr[t]->address = "(void*)$1";
  fun address_of[t]: lvalue[t]-> address = "(void*)&$1";


  fun isNULL: address -> bool = "(NULL==$1)";
  fun isNULL[t]: ptr[t] -> bool = "(NULL==$1)";
  fun isNULL[t]: cptr[t] -> bool = "(NULL==$1)";
  fun isNULL[t]: gcptr[t] -> bool = "(NULL==$1)";
  
  publish """
  Polymorphic null pointer constant
  """
  const null_ptr[t]:ptr[t] = "(?1*)NULL";
  const null_gcptr[t]:gcptr[t] = "(?1*)NULL";
  const null_cptr[t]:ptr[t] = "(?1 const*)NULL";
  const NULL : address = "NULL";

  publish """
  Unsafe output of hopefully null terminated C strings
  """
  proc fprint: ostream * charp = "*$1<<$2;" requires iostream;
  proc fprint: ostream * charcp = "*$1<<$2;" requires iostream;

  publish """ print an address in hex """
  proc fprint: ostream * address = "*$1<<$2;" requires iostream;

  header dflt_h = "template<class T> T dflt() { return T(); }";
  publish """
  Workaround for g++ 3.2.2 parsing bug,
  it can parse T() as a default ctor call,
  but screws up on (T())
  """
  fun dflt[t]:1->t = "dflt<?1>()" requires dflt_h;

  // this hackery is here to force Felix to make 
  // a suitable shape object
  private union _dummy[t] = | _new of t;
  private fun _udata[t]: _dummy[t]->gcptr[t] = "(?1*)$1.data";
  fun xnew[t](x:t) => _udata$ _new x;

  // raw allocation and deallocation
  fun malloc: int -> address = 'malloc($1)' requires stdlib_h;
  proc free: address = 'free($1);' requires stdlib_h; 
}


// the internal representation of a Felix source location
// has to be global to simplify compiler hack
type flx_location_t = "flx::rtl::flx_range_srcref_t";

module Debug 
{
  const FLX_SRCLOC : flx_location_t = "#srcloc";
  fun filename: flx_location_t -> charp = "$1.filename";
  fun startline: flx_location_t -> int = "$1.startline";
  fun startcol: flx_location_t -> int = "$1.startcol";
  fun endline: flx_location_t -> int = "$1.endline";
  fun endcol: flx_location_t -> int = "$1.endcol";

  // hack to emit C++ source file locations
  const CPP_FUNCTION : charp = "__FUNCTION__";
  const CPP_FILE: charp = "__FILE__";
  const CPP_LINE: int = "__LINE__";

  // hack to emit C code an expression would generate
  fun repr_expr[t]: t -> string = '\\"$a:?1\\"';
  
  // hack to emit C typename of a Felix type
  const repr_type[t]:string = '\\"?1\\"';
}

module Carray
{
  requires cstdlib;
  open C_hack;

  publish "Carray type"
  typedef carray[T] = ptr[T];

  publish "Convert Felix array to C array"
  fun _ctor_carray[T,N]: array[T,N] -> carray[T] = "$t.data";

  fun array_alloc[T]: int -> carray[T] = '(?1*)std::malloc(sizeof(?1)*$1)'; 
  fun array_calloc[T]: int -> carray[T] = '(?1*)std::calloc(sizeof(?1),$1)'; 
  proc free[T]: carray[T] = "std::free($1);";
  fun subscript[T]: carray[T] * int -> lvalue[T] = '$1[$2]';

  fun add[T]: carray[T] * int -> carray[T]= '$1+$2';
  fun sub[T]: carray[T] * int -> carray[T] = '$1-$2';
  fun sub[T]: carray[T] * carray[T]-> int = '$1-$2';

  proc pre_incr[T]: lvalue[carray[T]] = '++$1;'; 
  proc post_incr[T]: lvalue[carray[T]] = '$1++;'; 
  proc pre_decr[T]: lvalue[carray[T]] = '--$1;'; 
  proc post_decr[T]: lvalue[carray[T]] = '$1--;'; 
  proc pluseq[T]: lvalue[carray[T]] * int = '$1+=$2;'; 
  proc minuseq[T]: lvalue[carray[T]] * int = '$1-=$2;'; 

  fun eq[T]: carray[T] * carray[T] -> bool = '$1==$2';
  fun ne[T]: carray[T] * carray[T] -> bool = '$1!=$2';
  fun lt[T]: carray[T] * carray[T] -> bool = '$1<$2';
  fun le[T]: carray[T] * carray[T] -> bool = '$1<=$2';
  fun gt[T]: carray[T] * carray[T] -> bool = '$1>$2';
  fun ge[T]: carray[T] * carray[T] -> bool = '$1>=$2';

  publish "Convert C array to Felix array"
  fun array_of[T,N]: carray[T] -> ptr[array[T,N]] = "*(#0*)(void*)$1";
  
  proc memcpy: address * address * size = 
    "{if($1 && $2 && $3)std::memcpy($1,$2,$3);}"
    requires cstring
  ;
}

publish "System Interface"
module System
{
  const argc:int = "ptf->argc";
  fun argv:int -> string = 'std::string($1<0||$1>=ptf->argc??"":ptf->argv[$1])';
  fun args () => List::map (the argv) (List::range argc);
@tangle('  const felix_version : string = \'std::string("'+flx_version+'")\';')
  fun system: string -> int = "std::system($1.data())"
    requires cstdlib;
  proc exit: int = "std::exit($1);";
  proc abort: 1 = "std::abort($1);";
  type ptf_t = "thread_frame_t*";
  const ptf:ptf_t = "ptf"; 
    // note this will NOT work if ptf is a struct,
    // then we'd need (&ptf) instead ..
    // however this model isn't supported fully yet and probably never will be
    // we may, however, make ptf a machine register
}

@#------------- Environment -------------------
module Env
{
  fun getenv:string -> string = 
    "flx::rtl::strutil::atostr(getenv($1.data()))" 
    requires flx_strutil, cstdlib;
}

module Dynlink
{
  requires flx_dynlink;
  type flx_library = "flx::rtl::flx_dynlink_t*";
  type flx_instance = "flx::rtl::flx_libinit_t*";
  proc dlopen:flx_library * string = "$1->link($2.data());";
  proc dlclose:flx_library = "$1->unlink();";

  // this is a procedure, so maybe the caller is too
  // which means the thread frame must be available
  proc create: flx_library * flx_instance = 
    "_create($1,$2,PTF gc,$1->main_sym,PTF argc,PTF argv,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr);"
    requires property "needs_gc",
    body """
    void _create
    (
      flx::rtl::flx_dynlink_t *library,
      flx::rtl::flx_libinit_t *instance,
      flx::gc::generic::collector_t *gc,
      flx::rtl::main_t main_sym,
      int argc, char **argv, 
      FILE *stdin_, FILE *stdout_, FILE *stderr_
    )
    { 
      instance->create(library,gc,main_sym,argc,argv,stdin_,stdout_,stderr_); 
    }
    """;
  
  private fun get_init: flx_instance -> cont = "$1->start_proc";
  private fun get_library: flx_instance -> flx_library = "$1->lib";
  proc destroy: flx_instance = "$1->destroy();";
  
  fun create_library_handle: unit->flx_library=
    "new flx::rtl::flx_dynlink_t()";

  fun create_instance_handle: unit->flx_instance=
    "new flx::rtl::flx_libinit_t()";

  proc delete_library_handle: flx_library =
    "delete $1;";

  proc delete_instance_handle: flx_instance =
    "delete $1;";
    
  noinline fun init_lib(filename:string):flx_instance = {
    var library = create_library_handle();
    var linstance =  create_instance_handle();
    dlopen(library,filename);
    create (library,linstance);
    var init = get_init linstance;
    Control::run init;
    return linstance;
  }

  publish """ Run a Felix program. 
    WARNING!! All data created by the target
    program must be destroyed 
    before the library code is unlinked.
  """
  proc run_lib(filename:string) 
  {
    var linstance = init_lib(filename);
    destroy_lib linstance;
  }

  noinline proc destroy_lib(linstance:flx_instance)
  {
    destroy linstance;
    Control::collect();
    dl := get_library linstance;
    delete_instance_handle linstance;
    dlclose dl;
    delete_library_handle dl;
  }

  publish "dlsym wrapper, returns any symbol"
  fun dlsym:flx_library * string->address = 
      "SDLSYM($1->library,$2.data())";

  publish """
    execute an address representing a top
    level exported felix procedure's C wrapper,
    this creates a 'read to run' continuation object
    by both constructing the object using the thread
    frame of the instance as an argument, and calling
    it to fix a null return address and an arbitrary
    client data pointer as arguments to the call method.
  """
  fun bind_proc: flx_instance * address * address -> cont = 
    "$1->bind_proc($2,$3)";

  fun dlib_of : flx_library -> address = "(void*)$1->library";

  proc dlsym_err:flx_library*string="""
    throw flx::rtl::flx_link_failure_t($1->filename,$2,"symbol not found");
  """;

  noinline proc run_proc (linstance:flx_instance, p: string, data: address) 
  {
    var lib = get_library linstance;
    var sym = dlsym(lib, p);
    if C_hack::isNULL(sym) do dlsym_err(lib,p); done;
    var f = bind_proc(linstance, sym, data);
    run f;
  }

}

@#------------- Filename -------------------
module Filename
{
@if os.sep == '\\':
   # FFS!!! we put \\\\\\\\ here:
   # Python reduces it to \\\\             !!!
   # Felix then reduces it to \\           !!! 
   # and finally C reduces it to plain \   !!!
   # don't remove the !!! because \ at eol is continuation .. argg
   tangle("  const sep : charp = c'\"\\\\\\\\\"';")
 else:
   tangle("  const sep : charp = c'\""+os.sep+"\"';")
}

@#------------- C I/O -------------------
open module Cstdio
{
  header "#include <cstdio>";
  incomplete type FILE = "std::FILE";
}

@#------------- Text I/O ------------------
module Text_file
{
  requires flx_ioutil;
  fun load: string -> string = "flx::rtl::ioutil::load_file($1)";
  fun load: text_file -> string = "flx::rtl::ioutil::load_file($1)";

  pod type text_file = "FILE*"; // its a macro?

  fun fopen_input: string -> text_file = 'std::fopen($1.data(),"rt")';
  fun fopen_output: string -> text_file = 'std::fopen($1.data(),"wt")';
  proc fclose: text_file = '(void)std::fclose($1);';
  fun readln: text_file -> string ="flx::rtl::ioutil::readln($1)";
  proc writeln : text_file * string ="flx::rtl::ioutil::writeln($1,$2);";
  proc write : text_file * string ="flx::rtl::ioutil::write($1,$2);";
  fun valid : text_file -> bool = "$1!=(FILE*)0";
  const stdin: text_file = "PTF flx_stdin";
  const stdout: text_file = "PTF flx_stdout";
  const stderr: text_file = "PTF flx_stderr";
}


@#------------- STDOUT UTILITY -------------------
open module Stdout 
{
  requires iostream;
  type ostream = "std::ostream*";
  const cout: ostream = "&cout";
  proc endl: ostream = "*$1<<std::endl;";
  proc endl: unit = "std::cout << std::endl;";
  proc space: int = "std::cout << ' ';";
  proc flush: unit = "std::cout.flush(); ";
}

@#------------- STRING MODULES -------------------

typedef strings = typesetof (string,ustring);

instance[t in strings] Eq[t] {
  fun eq: t * t -> bool = "$1==$2";
}

open Eq[string];
open Eq[ustring];

open module String
{
  requires string_hxx;
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[string] * string = "$1.append($2);";
  proc pluseq: lvalue[string] * charcp = "$1.append($2);";
  proc pluseq: lvalue[string] * charp = "$1.append($2);";
  proc pluseq: lvalue[string] * char = "$1 += $2;";

  //fun str: charp -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;
  //fun str: charcp -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;
  //fun str: ucharp -> string = 'flx::rtl::strutil::atostr((char const*)$1)' requires flx_strutil;
  //fun str: ucharcp -> string = 'flx::rtl::strutil::atostr((char const*)$1)' requires flx_strutil;
  //fun str: string -> string = '$1';

  // we need to cast to an int so that c++ won't complain
  fun len: string -> int = "static_cast<int>($1.size())";

  fun add: string * string -> string = "$1+$2";
  fun add: string * charp -> string = "$1+$2";
  fun add: charp * string -> string = "$1+$2";
  fun add: string * char -> string = "$1+$2";
  fun add: char * string -> string = "$1+$2";
  fun add: string * int -> string = "$1+flx::rtl::i18n::utf8($2)" requires flx_i18n;
  fun mul: string * int -> string = "flx::rtl::strutil::mul($1,$2)" requires flx_strutil;
  fun mul: char * int -> string = "std::string($2,$1)";
  
  fun apply (x:string, y:string):string => x + y;
  fun apply (x:string, y:int):string => x + y;
 
  fun _ctor_char (x:string) => x.[0];
  fun _ctor_string (c:char) => ""+c;

  fun subscript: string * int -> char = 
    "flx::rtl::strutil::subscript($1,$2)" requires flx_strutil;
  fun copyfrom: string * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$1.size())" requires flx_strutil;
  fun copyto: string * int -> string = 
    "flx::rtl::strutil::substr($1,0,$2)" requires flx_strutil;
  fun substring: string * int * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$3)" requires flx_strutil;

  fun subscript (x:string, s:slice[int]):string =>
    match s with
    | Slice_all[int] => substring (x, 0, len x)
    | Slice_from (?start) => copyfrom (x, start)
    | Slice_to (?end) => copyto (x, end)
    | Slice_range (?start, ?end) => substring (x, start, end)
    | Slice_one (?index) => string x.[index]
    endmatch
  ;

  // comparisons
  //gen_cmp string;

  // Note we use int instead of size here: size is correct,
  // but that would requires heaps of casts in Felix

  const stl_npos: int = "static_cast<int>(std::string::npos)";

@stringfuncs = ["find", "rfind", "find_first_of", "find_first_not_of", \
      "find_last_of", "find_last_not_of"]
@stringtypes = ["string", "charp", "char"]
@for i, f in zip(range(len(stringfuncs)), stringfuncs):
    if i != 0:
      tangle('')

    for t in stringtypes:
      tangle('  fun stl_%s: string * %s -> int = "$1.%s($2)";' % (f, t, f))
      tangle('  fun stl_%s: string * %s * int -> int = "$1.%s($2,$3)";' % (f, t, f))

    tangle('')

    for t in stringtypes:
      tangle('  fun %s (s:string, e:%s) : opt[int] => match stl_%s (s, e) with | ?i when i == stl_npos => None[int] | ?i => Some i endmatch;' % (f, t, f))
      tangle('  fun %s (s:string, e:%s, i:int) : opt[int] => match stl_%s (s, e, i) with | ?i when i == stl_npos => None[int] | ?i => Some i endmatch;' % (f, t, f))
@#

  fun startswith (x:string) (e:string) : bool =
  {
    if len x < len e do
      return false;
    done;

    var i: int; forall i in 0 upto (len e) - 1 do
      if e.[i] != x.[i] do
        return false;
      done;
    done;

    return true;
  }

  fun endswith (x:string) (e:string) : bool =
  {
    val len_x = len x;
    val len_e = len e;

    if len_x < len_e do
      return false;
    done;

    var i: int; forall i in 0 upto (len_e) - 1 do
      if e.[len_e - i - 1] != x.[len_x - i - 1] do
        return false;
      done;
    done;

    return true;
  }

  fun startswith (x:string) (e:char) : bool => x.[0] == e;
  fun endswith (x:string) (e:char) : bool => x.[len x - 1] == e;

  fun ltrim (x:string) (e:string) : string =
  {
    if len x < len e do
      return x;
    done;

    var i: int; forall i in 0 upto (len e) - 1 do
      if e.[i] != x.[i] do
        // failed to find the substring, so just return the first string
        return x;
      done;
    done;

    return x.[len e to];
  }

  fun rtrim (x:string) (e:string) : string =
  {
    val len_x = len x;
    val len_e = len e;

    if len_x < len_e do
      return x;
    done;

    var i: int; forall i in 0 upto (len_e) - 1 do
      if e.[len_e - i - 1] != x.[len_x - i - 1] do
        return x;
      done;
    done;

    return x.[to len_x - len_e];
  }

  fun trim (x:string) (e:string) : string => ltrim (rtrim x e) e;


  // strip whitespace
  fun lstrip (x:string, e:string) : string = 
  {
    var i: int; forall i in 0 upto (len x) - 1 do
      var found = false;
      var j: int; forall j in 0 upto (len e) - 1 do
        if x.[i] == e.[j] do
          found = true;
        done; 
      done; 

      if not found do
        return x.[i to];
      done;
    done;

    return '';
  }

  fun rstrip (x:string, e:string) : string = 
  {
    var i: int; forall i in (len x) - 1 downto 0 do
      var found = false;
      var j: int; forall j in 0 upto (len e) - 1 do
        if x.[i] == e.[j] do
          found = true;
        done; 
      done;

      if not found do
        return x.[to i + 1];
      done;
    done;

    return '';
  }

  fun strip (x:string, e:string) : string => lstrip(rstrip(x, e), e);

  fun lstrip (x:string) : string => lstrip(x, " \t\n\r\f\v");
  fun rstrip (x:string) : string => rstrip(x, " \t\n\r\f\v");
  fun strip (x:string) : string => lstrip$ rstrip x;

  fun ljust(x:string, width:int) : string =>
    if len x >= width
      then x
      else x + (' ' * (width - len x))
    endif;
  ;

  fun rjust(x:string, width:int) : string =>
    if len x >= width
      then x
      else (' ' * (width - len x)) + x
    endif;
  ;

  fun split (x:string, d:char): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find (x, d) with
      | None => List::rev$ List::Cons (x, y)
      | Some ?n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }
  
  fun split (x:string, d:string): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find_first_of (x, d) with
      | None => List::rev$ List::Cons (x, y)
      | Some ?n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }

  fun split (x:string, d:charp): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find_first_of (x, d) with
      | None => List::rev$ List::Cons (x, y)
      | Some ?n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }

  // Note: pos, length!
  proc erase: string * int * int = "$1.erase($2,$3);";
  proc insert: string * int * string = "$1.insert($2,$3);";
  proc replace: string * int * int * string = "$1.replace($2,$3,$4);";

  proc fprint: ostream * C_hack::ptr[char] = "*$1<<$2;" requires iostream;
  proc fprint: ostream * C_hack::cptr[char] = "*$1<<$2;" requires iostream;
  proc fprint: ostream * string = "*$1<<$2;" requires iostream;
  fun atoi: string -> int = "std::atoi($1.data())" requires cstdlib;
  fun atol: string -> long = "std::atol($1.data())" requires cstdlib;
  fun atof: string -> double = "std::atof($1.data())" requires cstdlib;

  proc reserve: lvalue[string] * int = "$1.reserve($2);";

  publish "Unsafe extract buffer pointer"
  fun cstr: string -> C_hack::cptr[char] = "$1.data()";

  fun vsprintf[t]: C_hack::ptr[char] * t -> string = 
    "flx::rtl::strutil::flx_asprintf($1,$2)" requires flx_strutil
  ;

  fun vsprintf[t]: string * t -> string = 
    "flx::rtl::strutil::flx_asprintf(const_cast<char*>($1.c_str()),$2)" requires flx_strutil
  ;
}

instance Str[string] {
  fun str (s:string) : string => s;
}

instance[T in charp||charcp] Str[T] {
  fun str: T -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;
}

instance[T in ucharp||ucharcp] Str[T] {
  fun str: T -> string = 'flx::rtl::strutil::atostr((char const*)$1)' requires flx_strutil;
}

instance Repr[string] {
  fun repr (x:string) : string = {
    var o = "'";
    var i: int; forall i in 0 upto (String::len x) - 1 do
      o += repr x.[i];
    done;
    return o + "'";
  }
}

type ustring = "basic_string<uint32_t>" requires string_hxx;
open module Ustring
{
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[ustring] * ustring = "$1.append($2);";

  fun len: ustring -> int = "$1.size()";
  fun add: ustring * ustring -> ustring = "$1+$2";
  fun mul: ustring * int -> ustring = "flx::lib::mul($1,$2)";
  fun mul: char * int -> ustring = "ustring($2,$1)";

  fun apply (x:ustring, y:ustring):ustring => x + y;
 
  fun subscript: ustring * int -> char = 
    "$1[$2<0??$1.size()+$2 : $2]";
  fun copyfrom: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$1.size())" requires flx_strutil;
  fun copyto: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,0,$2)" requires flx_strutil;
  fun subustring: ustring * int * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$3)" requires flx_strutil;

  // comparisons
  //gen_cmp ustring;

  proc fprint: ostream * ustring = "*$1<<$2;" requires iostream;
}

open[T in strings] Show[T];

publish """
All the arithmetic casts between standard C arithmetic types.
"""
module Arith_casts
{
@for t1 in ints+floats:
  tangle('  fun '+t1+'_of[t2 in reals]: t2 -> '+t1+' = "('+tmap[t1]+')$1:cast" is cast;')
}

open module Cstdlib
{
  requires cstdlib;
  const RAND_MAX:long;

  proc srand: uint = 'std::srand($1);';
  fun rand: 1 -> int = 'std::rand()';
}


@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  open C_hack;
  publish 'infinite loop'
  proc forever (bdy:unit->void)
  {
    rpeat:>
      bdy();
      goto rpeat;
    dummy:> // fool reachability checker
  }

  publish 'C style while loop'
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    rpeat:>
      if not (cond()) goto finish;
      bdy();
      goto rpeat;
    finish:>
  }

  /* DISABLED: replaced by UNTIL statement until the optimiser is working
  publish """
  C style while loop with reversed condition
  note the until is tested first -- zero iterations are possible
  """
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeatx:>
      if cond() goto finish;
      bdy();
      goto repeatx;
    finish:>
  }
  */

  publish "do nothing [the name pass comes from Python]"
  proc pass(){}

  publish 'C style for loop'
  proc for_each
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    rpeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto rpeat;
    finish:>
  }

  publish 'abnormal termination with message'
  proc fail:string = 'throw std::runtime_error($1);' requires stdexcept;

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:1->t = 'throw std::runtime_error(""),*(?1*)0' requires stdexcept;

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:string->t = 'throw std::runtime_error($1),*(?1*)0' requires stdexcept;

  publish "Felix procedural continuation type"
  _gc_pointer type cont = "flx::rtl::con_t*";

  publish "Current continuation"
  fun current_continuation: 1 -> cont = "this";

  publish "Felix fthread"
  _gc_pointer type fthread = "flx::rtl::fthread_t*";

 
  publish """
    Throw a continuation. This is unsafe. It should
    work from a top level procedure, or any function
    called by such a procedure, but may fail
    if thrown from a procedure called by a function.
    The library run and driver will catch the
    continuation and execute it instead of the
    current continuation. If the library run is used
    and the continuation being executed is down the
    C stack, the C stack will not have been correctly
    popped. Crudely, nested drivers should rethrow
    the exception until the C stack is in the correct
    state to execute the continuation, but there is no
    way to determine that at the moment.

    Compiler generated runs ignore the exception,
    the library run catches it. Exceptions typically
    use a non-local goto, and they cannot pass across
    a function boundary.
  """
  proc throw(x: unit->void) { _throw (C_hack::cast[cont] x); }
  private proc _throw: cont = "throw $1;";

  // THESE VALUES MUST SYNC WITH THE RTL
  union svc_req_t =
  /*0*/ | svc_yield                          
  /*1*/ | svc_get_fthread         of ptr[fthread] 
  /*2*/ | svc_read                of address              
  /*3*/ | svc_general             of &address          
  /*4*/ | svc_reserved1
  /*5*/ | svc_spawn_pthread       of fthread
  /*6*/ | svc_spawn_detached      of fthread
  /*7*/ | svc_sread               of _schannel * &gcaddress
  /*8*/ | svc_swrite              of _schannel * &gcaddress
  /*9*/ | svc_kill                of fthread 
  /*10*/ | svc_compact
  /*11*/ | svc_collect
  /*12*/ | svc_collect_and_compact
  ;

  publish "Call Supervisor"
  // this interface just gets rid of the horrible requirement
  // the request be in a variable so it is addressable
  proc svc(x:svc_req_t) {
    var y=x;
    _svc y;
  }

  _gc_pointer type schannel[t] = "flx::rtl::schannel_t*";
  _gc_pointer type ischannel[t] = "flx::rtl::schannel_t*";
  _gc_pointer type oschannel[t] = "flx::rtl::schannel_t*";

  private _gc_pointer type _schannel = "flx::rtl::schannel_t*";
  gen mk_schannel[t]: 1->schannel[t] = 
    "new(*PTF gc,flx::rtl::schannel_ptr_map) flx::rtl::schannel_t(PTF gc)"
    requires property "needs_gc"
  ; 

  // safe casts from bidirectional to unidirectional channels
  fun _ctor_oschannel[t](x:schannel[t]):oschannel[t]=> C_hack::cast[oschannel[t]] x;
  fun _ctor_ischannel[t](x:schannel[t]):ischannel[t]=> C_hack::cast[ischannel[t]] x;

  fun mk_ioschannel_pair[t](var ch:schannel[t]) => 
    ischannel[t] ch, oschannel[t] ch
  ;

  fun mk_ioschannel_pair[t]() => 
    mk_ioschannel_pair[t]$ mk_schannel[t] ()
  ;

  // THIS IS THE DESIRED FORMULATION .. but it doesn't currently work.
  // The typematch implied by the typeset is failing during
  // overload resolution .. probably because unification indicates
  // it is OK to proceed BEFORE t is substituted out.

  typedef i_schannel[t] = typesetof(ischannel[t], schannel[t]);
  typedef o_schannel[t] = typesetof(oschannel[t], schannel[t]);

  proc _read[t](chan:schannel[t],loc:&gcptr[t]) {
    svc$ svc_sread$ cast[_schannel] chan, reinterpret[&gcaddress] loc;
  }


  proc read[t,CHAN:i_schannel[t]](v:&t,chan:CHAN) {
    var x: gcptr[t];
    _read(cast[schannel[t]] chan,&x);
    *v = *x;
  }

  proc write[t,CHAN:o_schannel[t]](chan:CHAN,v:t) {
    var ps = cast[gcaddress]$ xnew v;
    svc$ svc_swrite$ cast[_schannel] chan, &ps;
  }

  publish "Read primitive"
  // finds the machine address of the read buffer
  // then does a supervisor read specifying that address
  // DEPRECATED!
  proc read[t](x:&t) { 
    val vadr : address = C_hack::as_address$ C_hack::unref x;
    req  := svc_read vadr;
    svc req;
  }

  private gen _start[t]: (t->0)*t->cont = "$1->clone()->call(0,$2)";
  gen start[t] (p:t->0) (x:t) = { return _start (p,x); }
  private fun _start0: (1->0)->cont = "$1->clone()->call(0)";
  gen start (p:1->0) = { return _start0 (p); }

  gen mk_thread: cont->fthread = "new(*PTF gc,_fthread_ptr_map) flx::rtl::fthread_t($1)";

  proc spawn_fthread(p:1->0)
  {
      var con = start p;              // get continuation of p
      var fthr = mk_thread con;
      svc$ svc_spawn_detached fthr;
  }

  publish "Resume a continuation until it yields"
  gen step: cont -> cont = "$1->resume()";
  proc kill: fthread = "$1->cc = 0;";

  publish """
  Run a continuation until it terminates.
  Do not use this proc if the underlying
  procedure attempts to read messages.
  
  This is a low level primitive, bypassing fthreads.
  """
  proc run: cont = "flx::rtl::executil::run($1);" requires flx_executil;

  private proc _send[t]: &cont * t = 
  """
  {
    using namespace flx::rtl;
    con_t *tmp = *(con_t**)$1.get_data();
    // run target until it reaches a service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // check it is alive and making the expected service request
    if (!tmp) 
      throw flx_exec_failure_t (__FILE__,"send","Send to terminated procedure");
    if (!tmp->p_svc) 
      throw flx_exec_failure_t (__FILE__,"send","Send to unready Procedure");
    if (tmp->p_svc->variant != svc_read) 
      throw flx_exec_failure_t (__FILE__,"send","Send to Procedure which is not trying to read");
    // store the message
    **(?1**)tmp->p_svc->data= $2;
    // clear the service request
    tmp->p_svc = 0;
    // run the target until the next service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // save the new continuation
    *(con_t**)$1.get_data() = tmp;

  }
  """;

  publish """Send a message to a continuation.
  There is no type checking on the message type.
  The procedure is executed until
  the next wait_state, then the message is stored.

  Low level primitive, bypassing fthreads.
  """
  proc send[t] (p:&cont) (x:t)
  {
    _send (p,x);
  }

  publish """
  Invoke the garbage collector inside a procedure run
  by the top level (external) driver.

  Don't call this procedure in a procedure which is run
  with 'run', because such procedures do not link to their
  caller with frame pointers -- unless of course a such a
  procedure has a private collector.

  Note procedure called by functions are run with 
  code equivalent to 'run'.
  """
  proc collect() { svc svc_collect; }

}

@#------------- List -------------------
publish "List manipulation"
module List
{
  union list[T] = | Empty | Cons of T * list[T];

  fun _ctor_list[T] () => Empty[T];

  fun _ctor_list[T] (x:T) => Cons(x, Empty[T]);

  fun _ctor_list[T, N] (x:Array::array[T, N]) = {
    var o = Empty[T];
    var i:int; forall i in Array::len(x) - 1 downto 0 do
      o += x.[i];
    done;

    return o;
  }

  fun len[T] (x:list[T]) = {
    fun aux (acc:int) (x:list[T]) =>
      match x with
      | Empty => acc
      | Cons (_,?t) => aux (acc + 1) t
      endmatch
    ;
    return aux 0 x;
  }

  fun is_empty[T] : list[T] -> 2 =
    | Empty => true
    | _ => false
  ;

  fun map[T,U] (_f:T->U) (x:list[T]): list[U] = {
    return
      match x with
      | Empty[T] => Empty[U]
      | Cons[T] (?h, ?t) => Cons (_f(h), map[T,U] _f t)
      endmatch
    ;
  }

  noinline fun rev[T] (x:list[T]):list[T]= {
    fun aux (x:list[T]) (y:list[T]) : list[T] =
    {
      return 
        match x with
        | Empty[T] => y
        | Cons[T] (?h, ?t) => aux t (Cons (h, y))
        endmatch
      ;
    }
    return aux x Empty[T];
  }

  proc iter[T] (_f:T->void) (x:list[T]) {
    match x with
    | Empty[T] => {} 
    | Cons[T] (?h,?t) => { _f h; iter _f t; }
    endmatch
    ;
  }

  fun fold_left[T,U] (_f:U->T->U) (init:U) (x:list[T]):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_left _f (_f init h) t
      endmatch
    ;
  }

  fun fold_right[T,U] (_f:T->U->U) (x:list[T]) (init:U):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => _f h (fold_right _f t init)
      endmatch
    ;
  }

  fun range (low:int, high:int, step:int) =
  {
    fun inner(low:int, high:int, step:int, values:list[int]) =
    {
      return
        if high < low
          then values
          else inner(low, high - step, step, Cons(high, values))
          endif
      ;
    }
  
    // reverse low and high so we can do negative steps
    lo, hi, s := if low < high
      then low, high, step
      else high, low, -step
      endif;
  
    // adjust the high to be the actual last value so we don't
    // have to reverse the list
    n := hi - lo - 1;
  
    return if s <= 0
      then Empty[int]
      else inner(lo, lo + n - (n % s), s, Empty[int])
      endif
    ;
  }

  fun range (low:int, high:int) => range(low, high, 1);

  fun range (num:int) => range(0, num, 1);
  
  noinline fun join[T] (x:list[T]) (y:list[T]):list[T] = 
  {
    return
      match x with
      | Empty[T] => y
      | Cons[T] (?h,?t) => Cons (h, join t y)
      endmatch
    ;
  }

  fun add[T] (x:list[T], y: list[T]):list[T] => join x y;

  fun add[T] (x:list[T], y:T):list[T] => Cons (y, x);

  // very slow, adding to end ..
  noinline fun add[T] (x:T, y:list[T]):list[T] => rev$ Cons (x, rev y);

  proc pluseq[T] (x:lvalue[list[T]], y:T) { x = x + y; }

  noinline fun cat[T] (x:list[list[T]]):list[T] =
  {
     return 
       match x with
       | Empty[list[T]] => Empty[T]
       | Cons[list[T]] (?h,?t) => fold_left join of (list[T]) h t
       endmatch
     ;
   }

  fun cat (sep:string) (x:list[string]):string = 
  {
    return
      match x with
      | Empty[string] => ''
      | Cons[string] (?h, ?t) => 
          fold_left (fun (a:string) (b:string) => a + sep + b) h t
      endmatch
    ;
  }

  fun mem[T] (eq:T -> bool) (x:list[T]) : bool =>
    match x with
      | Empty => false
      | Cons (?h,?t) => if eq(h) then true else mem eq t endif
    endmatch
  ;

  fun mem[T, U] (eq:T * U -> bool) (x:list[T]) (e:U) : bool =>
    mem (fun (i:T) => eq(i, e)) x
  ;

  fun find[T, U] (eq:T * U -> bool) (x:list[T]) (e:U) : opt[T] =>
    match x with
      | Empty => None[T]
      | Cons (?h,?t) => if eq(h, e) then Some h else find eq t e endif
    endmatch
  ;

  fun find[T] (eq:T -> bool) (x:list[T]) : opt[T] =>
    match x with
      | Empty => None[T]
      | Cons (?h,?t) => if eq(h) then Some h else find eq t endif
    endmatch
  ;

  noinline fun filter[T] (P:T -> bool) (x:list[T]) : list[T] = 
  {
    fun aux (inp:list[T], out: list[T]) =>
      match inp with
      | Empty => rev out
      | Cons(?h,?t) => 
        if P(h) then aux(t,Cons(h,out))
        else aux (t,out)
        endif
      endmatch
    ;
    return aux (x,Empty[T]);
  }
  
  fun prepend_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] =>
    if mem eq x e then x else Cons (e,x) endif 
  ;

  fun insert_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] =>
    if mem eq x e then x else rev$ Cons (e,rev x) endif
  ;

  fun remove[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] =>
    filter (fun (y:T) => not eq (e,y)) x
  ;

  noinline fun append_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] = { 
    fun aux (inp:list[T], out: list[T]) =>
      match inp with
      | Empty => rev$ Cons(e,out)
      | Cons(?h,?t) => 
        if not eq (h, e) then aux(t,Cons(h,out))
        else aux (t,out)
        endif
      endmatch
    ;
    return aux (x,Empty[T]);
  } 
}

instance[T with Show[T]] Str[List::list[T]] {
  fun str (xs:List::list[T]) =>
    '[' +
      match xs with
      | Empty[T] => ''
      | Cons(?o, ?os) =>
          List::fold_left (
            fun (a:string) (b:T):string => a + ', ' + (repr b)
          ) (repr o) os
      endmatch
    + ']'
  ;
}

publish "Association Lists (lists of pairs)"
module Assoc_list
{
  typedef assoc_list[A,B] = List::list[(A,B)];
}

@#------------- Array -------------------
publish "Array manipulation"

open module Array 
{
  publish "Array type"
  typedef array[t,n] = t ^ n;

  publish "Array constructors"
  fun _ctor_array[T,N] (x:array[T,N]) => x;

  publish "Array access: works on LHS of assignment too"
  fun subscript[t,n]: array[t, n] * int -> t = "$1.data[$2]";
  fun subscript[t,n]: lvalue[array[t, n]] * int -> lvalue[t] = "$1.data[$2]";
  
  /*
  THIS HACK IS NASTY because we get the error:

    Too many candidates match in overloading subscript with argument types lvalue[(string<1498>)] * lvalue[(int<709>)]
    Of the matching candidates, the following are most specialised ones are incomparable
    String::subscript<2115><2115> sig string<1498> * int<709>
    Array::subscript<3461><3461> sig lvalue[(<T3462>)] * int<709>
    Perhaps you need to define a function more specialised than all these?

  and it is RIGHT. There's no lvalue form of String::subscript.
  We would HAVE to define one to resolve the conflict.

  I have no idea what I changed .. this used to work .. hmm ..
  I fiddled with overloading ..

  // hack to make subscript of non-array work: ignores index
  fun subscript[t]: lvalue[t] * int -> lvalue[t] = "$1";
  fun subscript[t]: t * int -> t = "$1";
  */


  publish "Explicit array store function"
  proc store[t,n]: &array[t,n] * int * t = "((?1*)($1.get_data()))[$2]=$3;";

  fun len[T, N] (x:array[T, N]): int => Typing::memcount[N];

  proc iter[T, N] (_f:T->void) (x:array[T, N]) {
    var i : int;

    forall i in 0 upto len(x) - 1 do
      _f x.[i];
    done;
  }

  fun map[T, N, U] (_f:T->U) (x:array[T, N]): array[U, N] = {
    var o : array[U, N];
    var i : int;

    forall i in 0 upto len(x) - 1 do
      o.[i] = _f x.[i];
    done;

    return o;
  }

  fun fold_left[T, N, U] (_f:U->T->U) (init:U) (x:array[T, N]): U = {
    var o = init;
    var i : int;

    forall i in 0 upto len(x) - 1 do 
      o = _f o x.[i];
    done;

    return o;
  }

  fun fold_right[T, N, U] (_f:T->U->U) (x:array[T, N]) (init:U): U = {
    var o = init;
    var i : int;

    forall i in len(x) - 1 downto 0 do 
      o = _f x.[i] o;
    done;

    return o;
  }

/*
  fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, _flatten(N + M)] = {
    var o = array[T, _flatten(N + M)];
    val i : int;

    forall i in 0 upto len(x) - 1 do
      o.[i] = x.[i];
    done;

    val j : int;

    forall k in 0 upto len(y) - 1 do
      o.[i + j] = y.[i];
    done;

    return o;
  }
*/

  fun mem[T, N] (eq:T->bool) (x:array[T, N]): bool = {
    var i : int;

    forall i in 0 upto len(x) - 1 do
      if eq(x.[i]) do
        return true;
      done;
    done;

    return false;
  }

  fun mem[T, N, U] (eq:T*U->bool) (x:array[T, N]) (e:U): bool =>
    mem (fun (i:T) => eq(i, e)) x
  ;

  fun find[T, N] (eq:T*T->bool) (x:array[T, N]) (e:T): opt[T] = {
    var i : int;

    forall i in 0 upto len(x) - 1 do
      if eq(x.[i], e) do
        return Some x.[i];
      done;
    done;

    return None[T];
  }

  fun find[T, N] (eq:T->bool) (x:array[T, N]): opt[T] = {
    var i : int;

    forall i in 0 upto len(x) - 1 do
      if eq(x.[i]) do
        return Some x.[i];
      done;
    done;

    return None[T];
  }

  fun rev[T, N] (x:array[T, N]): array[T, N] = {
    var o : array[T, N];
    var i : int;
    var length = len x;

    forall i in 0 upto length - 1 do
      o.[length - 1 - i] = x.[i];
    done;

    return o;  
  }
}

publish "Bounded Variable length arrays"

open module Varray
{
  _gc_pointer _gc_type t type varray[t] = "?1*";

  gen _ctor_varray[t]: ulong -> varray[t] = 
    "(?1*)(PTF gc->allocate(&@?1,$1))"
    requires property "needs_gc"
  ;
  private proc set_used[t]: varray[t] * ulong =
    "flx::gc::generic::set_used($1,$2);"
  ;
 
  fun subscript[t]: varray[t] * !ints -> lvalue[t] = 
    "$1[$2]"
  ;
  fun len[t]: varray[t] -> ulong = "flx::gc::generic::get_used($1)";
  fun maxlen[t]: varray[t] -> ulong = "flx::gc::generic::get_count($1)";
  proc pluseq[t] : varray[t] * t = """
    {
      ?1 * _p = $1;
      unsigned long n = flx::gc::generic::get_used(_p);
      flx::gc::generic::incr_used(_p,1L);
      new(_p+n) ?1($2);
    }
  """;
}

instance[T with Show[T]] Str[Varray::varray[T]] {
  fun str (xs:varray[T]) = {
    var o = 'varray(';
    var i : ulong;

    if Varray::len(xs) > 0ul do
      o += str xs.[0];

      forall i in 1 upto Varray::len(xs) - 1ul do
        o += ', ' + str xs.[i];
      done;
    done;

    return o + ')';
  }
}

open[T] Show[Varray::varray[T]];

module Avl
{
  union avl[T] =
    | Nil
    | Tree of int * T * avl[T] * avl[T] // (Height,Object,Left,Right)
  ;

  //==============================

  fun _ctor_avl[T] () => Nil[T];

  fun _ctor_avl[T] (x : T, left : avl[T], right : avl[T]) =>
    Tree (max(height(left), height(right)) + 1, x, left, right)
  ;

  //==============================

  private fun height[T] : avl[T]->int =
    | Nil => 0
    | Tree(?H, _, _, _) => H
  ;

  private fun slope[T] : avl[T]->int = 
    | Nil => 0
    | Tree(_, _, ?left, ?right) => height(left) - height(right)
  ;

  private fun rot_l[T](tree : avl[T]) =>
    match tree with
      | Tree(_, ?x, ?leftL, Tree(_, ?y, ?rightL, ?rightR)) =>
        avl(y, avl(x, leftL, rightL), rightR)
      | ?x => x
    endmatch
  ;

  private fun shift_l[T](tree : avl[T]) =>
    match tree with
      | Tree(?H, ?x, ?left, ?right) =>
        if (slope(right) == 1) then
          rot_l(avl(x, left, rot_r(right)))
        else
          rot_l(tree)
        endif
      | ?x => x
    endmatch
  ;

  private fun rot_r[T](tree : avl[T]) =>
    match tree with
      | Tree(_, ?x, Tree(_, ?y, ?leftL, ?leftR), ?rightR) =>
        avl(y, leftL, avl(x, leftR, rightR))
      | ?x => x
    endmatch
  ;

  private fun shift_r[T](tree : avl[T]) =>
    match tree with
      | Tree(?H, ?x, ?left, ?right) =>
        if (slope(right) == -1) then
          rot_r(avl(x, rot_r(left), right))
        else
          rot_r(tree)
        endif
      | ?x => x
    endmatch
  ;

  private fun balance[T](tree : avl[T]) =>
    match slope(tree) with
      |-2 => shift_l(tree)
      | 2 => shift_r(tree)
      | _ => tree
    endmatch
  ;

  //==============================

  fun insert[T] (tree : avl[T], y : T, cmp : T*T->int) =>
    match tree with
      | Nil =>
        Tree(1, y, Nil[T], Nil[T])
      | Tree(?H, ?x, ?left, ?right) =>
        if cmp(x, y) > 0 then
          balance(avl(x, (insert(left, y, cmp)), right))
        elif cmp(x, y) < 0 then
          balance(avl(x, left, insert(right, y, cmp)))
        else
          Tree(H, x, left, right)
        endif
    endmatch
  ;

  fun insert[T] (y : T, cmp : T*T->int) =>
    insert(Nil[T], y, cmp)
  ;

  //=================================

  fun find[T] (tree : avl[T], y : T, cmp : T*T->int) : opt[T] =>
      match tree with
        | Nil => None[T]
        | Tree(?H, ?x, ?left, ?right) =>
          if cmp(x, y) > 0 then
            find(left, y, cmp)
          elif cmp(x, y) < 0 then
            find(right, y, cmp)
          else
            Some x
          endif
      endmatch
    ;

  //=================================

  fun last[T] : avl[T]->T =
    | Tree(_, ?x, _, Nil[T]) => x
    | Tree(_, _, _, ?right) => last(right)
  ;

  fun all_but_last[T] : avl[T]->avl[T] =
    | Tree(_, _, ?left, Nil) => left
    | Tree(_, ?x, ?left, ?right) => balance(avl(x, left, all_but_last(right)))
  ;

  //=================================

  fun first[T] : avl[T]->T =
    | Tree(_, ?x, Nil[T], _) => x
    | Tree(_, _, ?left, _) => first(left)
  ;

  fun all_but_first[T] : avl[T]->avl[T] =
    | Tree(_, _, Nil, ?right) => right
    | Tree(_, ?x, ?left, ?right) => balance(avl(x, all_but_first(left), right))
  ;

  //=================================

  fun join[T] (A : avl[T], B : avl[T]) =>
    match A with
      | Nil => B
      | ?x => balance(avl(last(A), all_but_last(A), B))
    endmatch
  ;

  fun remove[T] (tree : avl[T], y : T, cmp : T*T->int) =>
    match tree with
      |Nil => Nil[T]
      |Tree(_, ?x, ?left, ?right) =>
        if cmp(x, y) == 1 then
          balance(avl(x, remove(left, y, cmp), right))
        elif cmp(x, y) == -1 then
          balance(avl(x, left, remove(right, y, cmp)))
        else
          join(left, right)
        endif
    endmatch
  ;

  //==============================

  fun fold_left[T, U] (f:U->T->U) (accumulated:U) (tree:avl[T]):U =>
    match tree with
      |Nil => accumulated
      | Tree (_, ?x, ?left, ?right) =>
        fold_left f  (f (fold_left f accumulated left)  x) right
    endmatch
  ;

  fun fold_right[T, U] (f:T->U->U) (tree:avl[T]) (accumulated:U) =>
    match tree with
      | Nil => accumulated
      | Tree (_, ?x, ?left, ?right) =>
        fold_right f left (f x (fold_right f right accumulated))
    endmatch
  ;

  //==============================

  proc iter[T] (f:T->void, tree:avl[T])
  {
    match tree with
      | Nil => {}
      | Tree (?H, ?x, ?left, ?right) => {
        iter(f, left);
        f(x);
        iter(f, right);
      }
    endmatch;
  }

  proc iter[T] (f:int*T->void, tree:avl[T])
  {
    proc aux (depth:int, f:int*T->void, tree:avl[T]) {
      match tree with
        | Nil => {}
        | Tree (?H, ?x, ?left, ?right) => {
          aux(depth + 1, f, left);
          f(depth, x);
          aux(depth + 1, f, right);
        }
      endmatch;
    }
    aux(0, f, tree);
  }
}

@#------------- Lexer -------------------
// This module provides functions to 
// use in conjunction with the reglex construction
module Lexer
{
  pod type iterator = "char const*";
  fun start_iterator : lvalue[string] -> iterator = "$1.data()";
  fun end_iterator: lvalue[string] -> iterator = "$1.data()+$1.size()";
  fun bounds (x:lvalue[string]): iterator * iterator = {
    return 
      start_iterator x,
      end_iterator x
    ;
  }
  fun string_between: iterator * iterator -> string =
   "std::string($1,$2)";

  fun add: iterator * int -> iterator = "$1 + $2";
  fun sub: iterator * int -> iterator = "$1 - $2";
  fun sub: iterator * iterator -> int = "$1 - $2";
}

instance Eq[Lexer::iterator] {
  fun eq:Lexer::iterator * Lexer::iterator -> bool = "$1==$2";
}

instance Tord[Lexer::iterator] {
  fun lt:Lexer::iterator * Lexer::iterator -> bool = "$1<$2";
}

instance Iterator[Lexer::iterator, char] {
  fun deref: Lexer::iterator -> lvalue[char] = "*$1";
}

open Eq[Lexer::iterator];
open Iterator[Lexer::iterator, char];

// ------ Open common modules -------------
//open Bool;
//open Int;
//open Double;
//open Char;
//open String;
open Array;
//open Stdout;
open Arith_casts;
open Control;
open Cstdio;


