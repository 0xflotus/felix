@head(1,"Name Binding")
Name binding, pass 1.

@h = tangler("src/flx_bind.mli")
@select(h)
open Flx_types
val build_tables:
  bool ->
  symbol_table_t ->
  int ref ->
  string ->
  int ->
  int option ->
  int list ->
  typecode_t ->
  asm_t list ->
  (
    name_map_t *  
    exe_t list * 
    (iface_t * int option) list
  )

val bind_entry:
  bound_symbol_table_t ->
  symbol_table_t ->
  int -> 
  unit

val bind_ifaces:
  symbol_table_t ->
  bound_symbol_table_t ->
  (iface_t * int option) list ->
  biface_t list 

val build_env:
  symbol_table_t ->
  int option ->
  env_t

@h = tangler("src/flx_bind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_srcref
open List
open Flx_overload
open Flx_lookup
open Flx_ebind
open Flx_tbind

let split_asms asms : 
  (range_srcref * id_t * dcl_t) list * 
  exe_t list *
  iface_t list
= 
  let rec aux asms dcls exes ifaces =
    match asms with
    | [] -> (dcls,exes,ifaces)
    | h :: t -> 
      match h with 
      | Exe (sr,exe) -> aux t dcls (exe :: exes) ifaces
      | Dcl (sr,id,dcl) -> aux t ((sr,id,dcl) :: dcls) exes ifaces
      | Iface (sr,iface) -> aux t dcls exes (iface :: ifaces)
  in 
    aux asms [] [] []
 
let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_bind.get_data] No definition of <" ^ string_of_int index ^ ">")


let dump_name_to_int_map level name name_map =
  let spc = spaces level in
  print_endline (spc ^ "//Name to int map for " ^ name);
  print_endline (spc ^ "//---------------");
  Hashtbl.iter
  (
    fun id n ->
      print_endline ( "//" ^ spc ^ id ^ ": " ^ string_of_int n) 
  ) 
  name_map
  ;
  print_endline ""

  
 
let add_unique table key value =
  try 
    Hashtbl.find table key;
    failwith ("Duplicate key " ^ key)
  with Not_found -> Hashtbl.add table key (NonFunctionEntry value)

let add_function table key value =
  try 
    match Hashtbl.find table key with
    | NonFunctionEntry _ -> 
      failwith ("Cannot overload " ^ key ^ " with non-function")
    | FunctionEntry fs ->
      Hashtbl.remove table key;
      Hashtbl.add table key (FunctionEntry (value :: fs))
  with Not_found -> 
    Hashtbl.add table key (FunctionEntry [value])

(* this routine takes a partially filled unbound definition table,
  'dfns' and a counter 'counter', and adds entries to the table
  at locations equal to and above the counter
*)
let rec build_tables print_flag dfns counter name level parent display msgt asms = 
  let dcls,exes,ifaces = split_asms asms in
  let dcls,exes,ifaces = List.rev dcls,List.rev exes,List.rev ifaces in
  let ifaces = List.map (fun i-> i,parent) ifaces in
  let interfaces = ref ifaces in
  let spc = spaces level in
  let name_map = Hashtbl.create 97 in
  begin 
    List.iter
    (
      fun (sr,id,dcl) -> 
        let n = !counter in 
        incr counter; 
        if print_flag then 
          print_endline 
          (
            "//" ^ spc ^ string_of_int n ^ " -> " ^ id ^ 
            " " ^ short_string_of_src sr
          )
        ;
        begin match dcl with
        | DCL_match_check (pat,mvname) ->
          let fun_index = n in
          let match_var_index = 
            match Hashtbl.find name_map mvname with
            | NonFunctionEntry idx -> idx
            | _ -> assert false
          in 
          Hashtbl.add dfns fun_index (id, sr, parent,
            SYMDEF_match_check (pat, 
              match_var_index, display
            )
          );
          add_function name_map id fun_index ;
          interfaces := !interfaces @ ifaces
        
        | DCL_match_handler (msgt, pat,mvname,asms) ->
          let fun_index = n in
          let table, exes,ifaces = 
            build_tables print_flag dfns counter id (level+1) 
            (Some fun_index) (fun_index :: display) msgt asms 
          in
          let match_var_index = 
            match Hashtbl.find name_map mvname with
            | NonFunctionEntry idx -> idx
            | _ -> assert false
          in 
          Hashtbl.add dfns fun_index (id, sr, parent,
            SYMDEF_match_handler (msgt, pat, 
              match_var_index, display, exes, table)
            )
          ;
          add_function name_map id fun_index;
          interfaces := !interfaces @ ifaces
 
        | DCL_header s ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n

        | DCL_module asms ->
          let table, exes,ifaces = 
            build_tables print_flag dfns counter id (level+1) (Some n) 
            display msgt asms
          in
          Hashtbl.add dfns n (id, sr,parent,SYMDEF_module table)
          ;
          let n' = !counter in
          incr counter;
          let init_def = SYMDEF_procedure (TYP_void,[], display, exes, Hashtbl.create 97) in
          Hashtbl.add dfns n' ("_init_" ^ id,sr,Some n, init_def)
          ;
          add_unique name_map id n;
          add_function table ("_init_"^id) n';
          interfaces := !interfaces @ ifaces
        
        | DCL_function (ps,t,asms) ->   
          let fun_index = n in
          let table, exes, ifaces =  
            build_tables print_flag dfns counter id (level+1) 
            (Some fun_index) (fun_index :: display) msgt asms 
          in
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag then
            print_endline ("//  "^spc ^ string_of_int n ^ " -> " ^ name^ " (parameter)");
            Hashtbl.add dfns n (name,sr,Some fun_index,SYMDEF_parameter typ);
            add_unique table name n
          ) ps
          ; 
          Hashtbl.add dfns fun_index (id, sr,parent,
            SYMDEF_function (ps, t, display, exes, table)
          )
          ;
          add_function name_map id fun_index ;
          interfaces := !interfaces @ ifaces

        | DCL_procedure (msgt, ps,asms) -> 
          let fun_index = n in
          let table, exes,ifaces = 
            build_tables print_flag dfns counter id 
            (level+1) (Some fun_index) (fun_index :: display) msgt asms 
          in
          List.iter (fun (name,typ) -> 
            let n = !counter in
            incr counter;
            if print_flag
            then print_endline ("//  "^spc ^ string_of_int n ^ " -> " ^ name^" (parameter)" );
            Hashtbl.add dfns n (name,sr,Some fun_index,SYMDEF_parameter typ);
            add_unique table name n
          ) ps
          ; 
          Hashtbl.add dfns fun_index (id, sr,parent,
            SYMDEF_procedure (msgt, ps, display, exes, table))
          ;
          add_function name_map id fun_index;
          interfaces := !interfaces @ ifaces
        
        | DCL_val t ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_val_typeof e -> 
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_var t ->       
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_var_typeof e ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_type_alias t ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_abs c ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_const (t,c) ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
        | DCL_fun (ts,t,c) ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_function name_map id n
        | DCL_proc (ts,c) ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_function name_map id n

        | DCL_union its ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
          ;
          (* assignment *)
          let asgn_idx = !counter in incr counter;
          let asgn = "set" in
          let asgn_dcl = 
            DCL_proc 
            (
              [
                TYP_pointer (TYP_name [id]);
                TYP_name [id]
              ],
              "*$1=$2;"
            ) 
          in
          Hashtbl.add dfns asgn_idx (asgn,sr,parent,SYMDEF_dcl asgn_dcl);
          add_function name_map asgn asgn_idx
          ; 
          let ccount = ref 0 in (* count component constructors *)
          List.iter
          (fun (component_name,t) ->
            let dfn_idx = !counter in incr counter; (* constructor *)
            let match_idx = !counter in incr counter; (* matcher *)
            let ctor_idx = !ccount in incr ccount; (* ctor sequence in union *)
            let ctor_dcl =
              match t with
              | TYP_void -> (* constant constructor *)
                add_unique name_map component_name dfn_idx;
                DCL_const (TYP_name [id],
                  "_uctor_(" ^ string_of_int ctor_idx ^ ",0)"
                )
              | TYP_tuple ts -> (* non-constant constructor or 2 or more arguments *)
                add_function name_map component_name dfn_idx;
                (* print_endline ("Creating constructor " ^ id ^ " of tuple length " ^ string_of_int (List.length ts)); *)
                DCL_fun (ts,TYP_name [id],
                  "_uctor_(" ^ string_of_int ctor_idx ^ 
                  ", new(gc,@t) #t($t))"
                )
              | _ -> (* non-constant constructor of 1 argument *)
                add_function name_map component_name dfn_idx;
                (* print_endline ("Creating constructor " ^ id ^ " of non-tuple "); *)
                DCL_fun ([t],TYP_name [id],
                  "_uctor_(" ^ string_of_int ctor_idx ^ 
                  ", new(gc,@1) #1($1))"
                )
            in
              let ctor_match = 
                DCL_fun (
                  [TYP_name [id]],
                  TYP_name ["";"bool"],
                  "($1.variant==" ^ string_of_int ctor_idx ^")"
                )
              and ctor_match_name ="_match_ctor_" ^ component_name 
              in
              Hashtbl.add dfns dfn_idx (component_name,sr,parent,SYMDEF_dcl ctor_dcl);
              Hashtbl.add dfns match_idx (ctor_match_name,sr,parent,SYMDEF_dcl ctor_match);
              add_function name_map ctor_match_name match_idx;

              (* destructor *)
              match t with
              | TYP_void -> ()
              | _ -> (* non-constant constructor *)
                let dtor_idx = !counter in incr counter;
                let dtor = "ctor_arg_" ^ component_name in
                let dtor_dcl = DCL_fun ([TYP_name [id]],t,"*(#0*)`1.data") in
                Hashtbl.add dfns dtor_idx (dtor,sr,parent,SYMDEF_dcl dtor_dcl);
                add_function name_map dtor dtor_idx
          )
          its
 
        | DCL_struct sts ->
          Hashtbl.add dfns n (id,sr,parent,SYMDEF_dcl dcl)
          ;
          add_unique name_map id n
          ;
          List.iter
          (fun (component_name,t) ->
            let getn = !counter in incr counter;
            let get_name = "get_" ^ component_name in
            let get_dcl = DCL_fun ([TYP_name [id]],t,"$1." ^ component_name) in
            Hashtbl.add dfns getn (get_name,sr,parent,SYMDEF_dcl get_dcl);
            add_function name_map get_name getn
            ;

            let refn = !counter in incr counter;
            let ref_name = "ref_" ^ component_name in
            let ref_dcl = DCL_fun (
              [TYP_pointer (TYP_name [id])],
              TYP_pointer t,
              "_make_ref_(`1.frame,&($1->" ^ component_name ^"))"
            ) 
            in
            Hashtbl.add dfns refn (ref_name,sr,parent,SYMDEF_dcl ref_dcl) ;
            add_function name_map ref_name refn
          )
          sts
          ;
        end
    ) 
    dcls
  end
  ;
  name_map,exes,!interfaces

(* an environment is a list of hastables, mapping
   names to definition indicies. Each entity defining
   a scope contains one hashtable, and a pointer to
   its parent, if any. The name 'top' is special,
   it is the name of the single top level module
   created by the desugaring phase. We have to be
   able to find this name, so if when we run out
   of parents, which is when we hit the top module,
   we create a parent name map with a single entry
   'top'->NonFunctionEntry 0. 
*)
let rec build_env dfns parent =
  match parent with
  | None -> 
    (*
    let table = Hashtbl.create 97 in
    Hashtbl.add table "" (NonFunctionEntry 0);
    [table]
    *)
    []

  | Some index ->
  match get_data dfns index with
  | (id,sr,parent,entry) ->
    let table = 
      match entry with
      | SYMDEF_module table -> table
      | SYMDEF_function (ps,t,d,e,table) -> table
      | SYMDEF_match_handler (_,pat,ex,d,e,table) -> table
      | SYMDEF_procedure (_,ps,d,e,table) -> table
      | SYMDEF_match_check _ -> Hashtbl.create 97 
      | SYMDEF_parameter _ -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup function, procedure or module as parent, got parameter "^id^"??"
        )
      | SYMDEF_dcl d -> 
        failwith 
        (
          "[build_env] " ^
          short_string_of_src sr ^
          ": Lookup of requires function, procedure or module as parent, got " ^ id
        )
    in 
        table :: build_env dfns parent
   
let rec bind_entry bdfns dfns index =  
  match get_data dfns index with id,sr,parent,dfn ->
  let env = build_env dfns parent in
  let bt t = bind_type dfns env [] t in 
  match dfn with
  | SYMDEF_parameter t ->
    let bdcl = BDCL_val (bt t) in 
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_module table -> ()

  | SYMDEF_procedure (msgt,ps,display,exes,name_map) ->
    let ps' = List.map
    (fun (name,t) -> (name, bt t))
    ps
    in 
    Hashtbl.add bdfns index (id,parent,
      BDCL_procedure (ps', display,exes, name_map)
    )

  | SYMDEF_match_check (pat,mvindex,display) -> 
    let bdcl = BDCL_match_check (pat,mvindex,display) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_match_handler (msgt,pat,mvindex,display,exes,name_map) ->
    (* print_endline ("BEGIN: Name map of match handler[SYMDEF]" ^ string_of_int index);
    Hashtbl.iter
    (fun id entry_set -> print_endline ("  --> " ^ id))
    name_map;
    print_endline ("END: Name map of match handler[SYMDEF]" ^ string_of_int index);
    *)
    let bdcl = BDCL_match_handler (bt msgt,pat,mvindex,display,exes,name_map) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_function (ps,ret, display, exes, name_map) ->
    let ps' = List.map
      (fun (name,t) -> (name, bt t))
    ps
    in 
    let ret' = bind_type dfns env [] ret in
    Hashtbl.add bdfns index (id,parent,
      BDCL_function (ps',ret',display,exes,name_map)
    )

  | SYMDEF_dcl dcl -> 
    match dcl with

    | DCL_header s -> let bdcl = BDCL_header s in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_val t -> let bdcl = BDCL_val (bt t) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_var t -> let bdcl = BDCL_var (bt t) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    (* primitives *)
    | DCL_abs c -> let bdcl = BDCL_abs c in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_const (t,c) -> let bdcl = BDCL_const (bt t,c) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_fun (ts,t,c) -> let bdcl = BDCL_fun (List.map bt ts, bt t,c) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_proc (ts,c) -> let bdcl = BDCL_proc (List.map bt ts,c) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_union idts -> let bdcl = BDCL_union (List.map (fun (name,t) -> (name, bt t)) idts) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_struct idts -> let bdcl = BDCL_struct (List.map (fun (name,t) -> (name, bt t)) idts) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    (* type inference needed. We try to compute the type, but
       and use a typed declaration if we can. But it might
       not be possible, if the expression depends on an as yet
       unbound variable or type.
    *)
    | DCL_val_typeof e -> 
      let bdcl = 
        try BDCL_val (snd (
          bind_expression dfns bdfns env [] e 
        ))
        with _ -> BDCL_val_typeof e
      in
      Hashtbl.add bdfns index (id,parent,bdcl)
    | DCL_var_typeof e -> 
      let bdcl = 
        try BDCL_var (snd (
          bind_expression dfns bdfns env [] e
        ))
        with _ -> BDCL_var_typeof e
      in
      Hashtbl.add bdfns index (id,parent,bdcl)
    | DCL_type_alias _ -> ()
    
    (* these should have been special cased out *)
    | DCL_function _ -> failwith "Unexpected function"
    | DCL_procedure  _ -> failwith "Unexpected procedure"
    | DCL_module _ -> failwith "Unexpected module"
    | DCL_match_handler _ -> failwith "Unexpected match handler"
    | DCL_match_check _ -> failwith "Unexpected match checker"

 

let bind_ifaces dfns bdfns ifaces = 
  let luqn env sr n = lookup_qn_in_env dfns env sr n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | IFACE_export ((qn,suf), cpp_name), parent ->
        let name = string_of_qualified_name qn in
        let env = build_env dfns parent in
        let entries = luqn env dummy_sr qn in
        let index = 
          match entries with
          | FunctionEntry fs ->
            let bound_suffix =  bind_type dfns env [] suf in
            (match resolve_overload dfns bdfns env fs name bound_suffix with
            | Some i -> i
            | None -> failwith 
              (
                "[flx_bbind] Can't find match to export " ^ name
              )
            )
          | NonFunctionEntry index -> index
        in BIFACE_export (index, cpp_name) 
     )
     ifaces
   in bound_ifaces


