@head(1,"Name Binding")
Name binding, pass 2.
@p()
This module is responsible for
converting the raw type 1 symbol table
into a partially bound symbol table
of type 2.
@p()
All type expressions are bound in this table.
This is possible because all type names
and the environment structure are bound in the
type 1 symbol table.
@p()
Because of this, it is also possible to bind
the types of all functions and procedures,
since their types must be explicitly specified.
@p()
It is not possible to bind the types of all values
and variables, however, since the type may depend
on being able to calulcate the type of an expression.
This in turn may depend on overload resolution,
which depends on the type of all functions and argument
values and variables being bound. 
@p()
Because this pass is strictly sequential,
it is possible for an expression to call a function
which has not yet had its type bound: such calling
is necessary to support call recursion.

@h = tangler("src/flx_bind.mli")
@select(h)
open Flx_types

val bind_entry:
  bound_symbol_table_t ->
  symbol_table_t ->
  int -> 
  unit

val bind_ifaces:
  symbol_table_t ->
  bound_symbol_table_t ->
  (iface_t * int option) list ->
  biface_t list 

@h = tangler("src/flx_bind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_srcref
open List
open Flx_overload
open Flx_lookup
open Flx_ebind
open Flx_env

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_bind.get_data] No definition of <" ^ string_of_int index ^ ">")

let rec bind_entry bdfns dfns index =  
  match get_data dfns index with id,sr,parent,dfn ->
  let env = build_env dfns parent in
  let bt t = bind_type dfns env [] t in 
  match dfn with
  | SYMDEF_if_fun (t,display) ->
    let bdcl = BDCL_if_fun (bt t,display) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_if_proc (msgt,t,display) ->
    let bdcl = BDCL_if_proc (bt msgt, bt t,display) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_module_binding e ->
    let bdcl = BDCL_module_binding e in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_if_type ->
    let bdcl = BDCL_type_parameter in 
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_functor (ps,ret,display,exes,name_map) ->
    let ps' = List.map
      (fun (name,t) -> (name, bt t))
    ps
    in 
    let ret' = bind_type dfns env [] ret in
    Hashtbl.add bdfns index (id,parent,
      BDCL_functor (ps',ret',exes,name_map)
    )

  | SYMDEF_parameter t ->
    let bdcl = BDCL_val (bt t) in 
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_module table ->
    Hashtbl.add bdfns index (id,parent, BDCL_module table )

  | SYMDEF_interface table -> 
    Hashtbl.add bdfns index (id,parent, BDCL_interface table)

  | SYMDEF_procedure (msgt,ps,display,exes,name_map) ->
    let ps' = List.map
    (fun (name,t) -> (name, bt t))
    ps
    in 
    Hashtbl.add bdfns index (id,parent,
      BDCL_procedure (ps', display,exes, name_map)
    )

  | SYMDEF_match_check (pat,mvindex,display) -> 
    let bdcl = BDCL_match_check (pat,mvindex,display) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_match_handler (msgt,pat,mvindex,display,exes,name_map) ->
    (* print_endline ("BEGIN: Name map of match handler[SYMDEF]" ^ string_of_int index);
    Hashtbl.iter
    (fun id entry_set -> print_endline ("  --> " ^ id))
    name_map;
    print_endline ("END: Name map of match handler[SYMDEF]" ^ string_of_int index);
    *)
    let bdcl = BDCL_match_handler (bt msgt,pat,mvindex,display,exes,name_map) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_function (ps,ret, display, exes, name_map) ->
    let ps' = List.map
      (fun (name,t) -> (name, bt t))
    ps
    in 
    let ret' = bind_type dfns env [] ret in
    Hashtbl.add bdfns index (id,parent,
      BDCL_function (ps',ret',display,exes,name_map)
    )

  | SYMDEF_lazy (display,e) -> let bdcl = BDCL_lazy (display,e) in
    Hashtbl.add bdfns index (id,parent,bdcl)

  | SYMDEF_dcl dcl -> 
    match dcl with

    | DCL_header s -> let bdcl = BDCL_header s in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_val t -> let bdcl = BDCL_val (bt t) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_var t -> let bdcl = BDCL_var (bt t) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    (* primitives *)
    | DCL_abs c -> let bdcl = BDCL_abs c in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_const (t,c) -> let bdcl = BDCL_const (bt t,c) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_fun (ts,t,c) -> let bdcl = BDCL_fun (List.map bt ts, bt t,c) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_proc (ts,c) -> let bdcl = BDCL_proc (List.map bt ts,c) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_union idts -> let bdcl = BDCL_union (List.map (fun (name,t) -> (name, bt t)) idts) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    | DCL_struct idts -> let bdcl = BDCL_struct (List.map (fun (name,t) -> (name, bt t)) idts) in
      Hashtbl.add bdfns index (id,parent,bdcl)

    (* type inference needed. We try to compute the type, but
       and use a typed declaration if we can. But it might
       not be possible, if the expression depends on an as yet
       unbound variable or type.
    *)
    
    | DCL_val_typeof e -> 
      let bdcl = 
        (*
        try BDCL_val (snd (
          bind_expression dfns bdfns env [] e 
        ))
        with _ ->
        *)
        BDCL_val_typeof e
      in
      Hashtbl.add bdfns index (id,parent,bdcl)
    | DCL_var_typeof e -> 
      let bdcl = 
        (*
        try BDCL_var (snd (
          bind_expression dfns bdfns env [] e
        ))
        with _ -> 
        *)
        BDCL_var_typeof e
      in
      Hashtbl.add bdfns index (id,parent,bdcl)
    | DCL_type_alias _ -> ()
    
    (* these should have been special cased out *)
    | DCL_type -> failwith "[bind_entry] Unexpected type"
    | DCL_if_fun _ -> failwith "[bind_entry] Unexpected function decl"
    | DCL_if_proc _ -> failwith "[bind_entry] Unexpected procedure decl"
    | DCL_interface _ -> failwith "[bind_entry] Unexpected interface"
    | DCL_module_binding _ -> failwith "[bind_entry] Unexpected module binding"
    | DCL_functor _ -> failwith "[bind_entry] Unexpected functor"
    | DCL_function _ -> failwith "[bind_entry] Unexpected function"
    | DCL_procedure  _ -> failwith "[bind_entry] Unexpected procedure"
    | DCL_module _ -> failwith "[bind_entry] Unexpected module"
    | DCL_match_handler _ -> failwith "[bind_entry] Unexpected match handler"
    | DCL_match_check _ -> failwith "[bind_entry] Unexpected match checker"
    | DCL_lazy _ -> failwith "[bind_entry] Unexpected lazy"
 

let bind_ifaces dfns bdfns ifaces = 
  let luqn env sr n = lookup_qn_in_env dfns env sr n in
  let dummy_sr = ("bind_ifaces",0,0,0,0) in
  let bound_ifaces = 
    List.map
    (function 
      | IFACE_export ((qn,suf), cpp_name), parent ->
        let name = string_of_qualified_name qn in
        let env = build_env dfns parent in
        let entries = luqn env dummy_sr qn in
        let index = 
          match entries with
          | FunctionEntry fs ->
            let bound_suffix =  bind_type dfns env [] suf in
            (match resolve_overload dfns bdfns fs name bound_suffix with
            | Some i -> i
            | None -> failwith 
              (
                "[flx_bbind] Can't find match to export " ^ name
              )
            )
          | NonFunctionEntry index -> index
        in BIFACE_export (index, cpp_name) 
     )
     ifaces
   in bound_ifaces


