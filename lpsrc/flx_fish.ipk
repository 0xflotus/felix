@head(2,"environments_fish.mli")
environments_fish.mli.
@select(tangler("src/environments_fish.mli"))
module TyEnv :
  sig
    type key = Terms_fish.Ordered_vars.t
    type 'a t = 'a Map.Make(Terms_fish.Ordered_vars).t
    val empty : 'a t
    val add : key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  end
type shapeEnv =
  (Terms_fish.term_variable * (Terms_fish.fish_term * Terms_fish.fish_term))
  list
type globalEnv =
  (Terms_fish.term_variable *
   (Types_fish.phraseType * Terms_fish.fish_term * Terms_fish.fish_term))
  list
val getFreeTyVars : Types_fish.fishTyScheme TyEnv.t -> Types_fish.tyVarSet
val closTy :
  Types_fish.phraseType ->
  Types_fish.fishTyScheme TyEnv.t -> Types_fish.fishTyScheme
val global2type : (TyEnv.key * ('a * 'b * 'c)) list -> 'a TyEnv.t
val global2shape : ('a * ('b * 'c * 'd)) list -> ('a * ('c * 'd)) list

@head(2,"infer_fish.mli")
infer_fish.mli.
@select(tangler("src/infer_fish.mli"))
exception UnboundVariable of Terms_fish.term_variable
val infer :
  Types_fish.fishTyScheme Environments_fish.TyEnv.t ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term * Types_fish.phraseType * Type_subs_fish.tySub

@head(2,"lex_fish.mli")
lex_fish.mli.
@select(tangler("src/lex_fish.mli"))
exception UnterminatedComment
val buf_pos : int ref
val last_buf_pos : int ref
val comment_depth : int ref
val line_number : int ref
val hash_table_from_list : int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
val keyword_table : (string, Parse_fish.token) Hashtbl.t
val primconst_table : (string, Primitive_fish.prim_constant) Hashtbl.t
val primbinconst_table : (string, Primitive_fish.prim_constant) Hashtbl.t
val hex_char2int : char -> int
val hexint_of_string : string -> int
val incr_lex_counters : Lexing.lexbuf -> unit
val mainLex : Lexing.lexbuf -> Parse_fish.token
val commentLex : Lexing.lexbuf -> unit
val lineCommentLex : Lexing.lexbuf -> unit
exception FishSyntaxError of int * int * string
val runParser : ('a -> Lexing.lexbuf -> 'b) -> 'a -> Lexing.lexbuf -> 'b
val makeParserForFile : (Lexing.lexbuf -> 'a) -> string -> 'a
val makeParserForConsole : (Lexing.lexbuf -> 'a) -> 'a
val makeParserForString : (Lexing.lexbuf -> 'a) -> string -> 'a
val makeParser :
  ((Lexing.lexbuf -> Parse_fish.token) -> Lexing.lexbuf -> 'a) ->
  Lexing.lexbuf -> 'a
val parseShell : Lexing.lexbuf -> Util_fish.fish_shell_action
val parseShellFromFile : string -> Util_fish.fish_shell_action
val parseShellFromConsole : unit -> Util_fish.fish_shell_action
val parseShellFromString : string -> Util_fish.fish_shell_action
val parseShellList : Lexing.lexbuf -> Util_fish.fish_shell_action list
val parseShellListFromConsole : unit -> Util_fish.fish_shell_action list
val parseShellListFromFile : string -> Util_fish.fish_shell_action list
val parseShellListFromString : string -> Util_fish.fish_shell_action list
val parseForFish : Lexing.lexbuf -> Terms_fish.fish_term
val parseFishFromConsole : unit -> Terms_fish.fish_term
val parseFishFromFile : string -> Terms_fish.fish_term
val parseFishFromString : string -> Terms_fish.fish_term

@head(2,"parse_fish.mli")
CRAP HERE ...
@select(tangler("tmp/parse_fish.mli"))
type token =
    TTwiddle
  | TBangOp
  | THashOp
  | TId of string
  | TIntConst of int
  | TFloatConst of float
  | TBoolConst of bool
  | TCharConst of char
  | TString of string
  | TDand
  | TCheck
  | TDo
  | TDone
  | TElse
  | TEnd
  | TFill
  | TFor
  | TFun
  | TIf
  | TIn
  | TLet
  | TNew
  | TRec
  | TThen
  | TWhere
  | TWhile
  | TWith
  | TQuit
  | TReturn
  | TRun
  | TShow
  | TTo
  | TTurbot
  | TUse
  | TSub
  | TGet
  | TZerodim
  | TSuccdim
  | TUndim
  | TLendim
  | TPreddim
  | TNumdim
  | EQ
  | HashEQ
  | TOutput
  | TSkip
  | TAbort
  | TAssign
  | TSeq
  | TForall
  | TWhiletrue
  | TFix
  | TNewvar
  | TNewexp
  | TCond
  | TPrimrec
  | TError
  | TShape
  | TPrimConst of Primitive_fish.prim_constant
  | TPrimBinConst of Primitive_fish.prim_constant
  | TInt
  | TFloat
  | TBool
  | TChar
  | TSize
  | TCost
  | TFact
  | TMark
  | TComm
  | TVec
  | TExp
  | TVar
  | TBangInt
  | TBangFloat
  | TBangBool
  | TBangChar
  | TAddOp of Primitive_fish.prim_constant
  | TSubOp of Primitive_fish.prim_constant
  | TMultOp of Primitive_fish.prim_constant
  | TDivOp of Primitive_fish.prim_constant
  | TModOp of Primitive_fish.prim_constant
  | LT of Primitive_fish.prim_constant
  | LEQ of Primitive_fish.prim_constant
  | GT of Primitive_fish.prim_constant
  | GEQ of Primitive_fish.prim_constant
  | TAddOpFloat of Primitive_fish.prim_constant
  | TMultOpFloat of Primitive_fish.prim_constant
  | TSubOpFloat of Primitive_fish.prim_constant
  | TDivOpFloat of Primitive_fish.prim_constant
  | EQFloat of Primitive_fish.prim_constant
  | LTFloat of Primitive_fish.prim_constant
  | LEQFloat of Primitive_fish.prim_constant
  | GTFloat of Primitive_fish.prim_constant
  | GEQFloat of Primitive_fish.prim_constant
  | TAnd of Primitive_fish.prim_constant
  | TOr of Primitive_fish.prim_constant
  | EQBool of Primitive_fish.prim_constant
  | Percent
  | Semicolon
  | DoubleSemicolon
  | Colon
  | ColonEqual
  | Comma
  | Dot
  | VerticalBar
  | LSquareBrace
  | RSquareBrace
  | LCurlyBrace
  | RCurlyBrace
  | LParen
  | RParen
  | RArrow
  | TEof
type newDecl = ShapeDecl | ExpDecl
val make_nested_new :
  (newDecl * Substitution_fish.Term_subst.key * Terms_fish.fish_term) list ->
  Terms_fish.fish_term -> Terms_fish.fish_term
val make_newvar :
  (newDecl * Substitution_fish.Term_subst.key * Terms_fish.fish_term) list ->
  Terms_fish.fish_term ->
  Substitution_fish.Term_subst.key -> Terms_fish.fish_term
val make_nested_where :
  (Terms_fish.term_variable * Terms_fish.fish_term) list ->
  Terms_fish.fish_term -> Terms_fish.fish_term
val fixof : int -> Terms_fish.fish_term -> Terms_fish.fish_term
val make_rec_fun :
  Terms_fish.term_variable ->
  Terms_fish.term_variable list ->
  Terms_fish.fish_term -> Terms_fish.fish_term
val make_zerodim_term : Terms_fish.fish_term -> Terms_fish.fish_term
val make_succdim_term : Terms_fish.fish_term list -> Terms_fish.fish_term
val fill_shape :
  Terms_fish.fish_term -> Terms_fish.fish_term list -> Terms_fish.fish_term
val parse_string : string -> Terms_fish.fish_term
type run_flag = Quiet_flag | Compile_flag
type show_mode = Show_on | Show_off
type fish_shell_action =
    Let_decl of Terms_fish.term_variable * Terms_fish.fish_term
  | Turbot_directive of Terms_fish.term_variable * run_flag list
  | Run_directive of Terms_fish.term_variable * run_flag list * string
  | Show_directive of show_mode * string
  | Use_directive of string
  | Quit_directive
val is_nonempty_prefix : string -> string -> bool
val set_mode : string -> show_mode -> unit
val get_mode : string -> show_mode
val yytransl_const : int array
val yytransl_block : int array
val yylhs : string
val yylen : string
val yydefred : string
val yydgoto : string
val yysindex : string
val yyrindex : string
val yygindex : string
val yytablesize : int
val yytable : string
val yycheck : string
val yynames_const : string
val yynames_block : string
val yyact : (Parsing.parser_env -> Obj.t) array
val yytables : Parsing.parse_tables
val parseFish :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> Terms_fish.fish_term
val parseShellAction :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> fish_shell_action
val parseShellActionList :
  (Lexing.lexbuf -> token) -> Lexing.lexbuf -> fish_shell_action list

@head(2,"partial_ev_fish.mli")
partial_ev_fish.mli.
@select(tangler("src/partial_ev_fish.mli"))
val part_ev :
  (string * Util_fish.show_mode) list ->
  (Terms_fish.term_variable * (Terms_fish.fish_term * Terms_fish.fish_term))
  list -> Terms_fish.fish_term -> Terms_fish.fish_term

@head(2,"pretty_fish.mli")
pretty_fish.mli.
@select(tangler("src/pretty_fish.mli"))
val ps : string -> unit
val format_prim_type : Primitive_fish.prim_type -> unit
val format_static_prim_type : Primitive_fish.prim_type -> unit
val format_prim_constant : Primitive_fish.prim_constant -> unit
val formatArrayTyVar : Types_fish.arrayTyVar -> unit
val formatPhraseTyVar : Types_fish.phraseTyVar -> unit
val format_untidy_array_type : Types_fish.arrayType -> unit
val format_phrase_type : bool -> Types_fish.phraseType -> unit
val format_tidy_phrase_type : Types_fish.phraseType -> unit
val format_untidy_phrase_type : Types_fish.phraseType -> unit
val format_type_scheme : Types_fish.fishTyScheme -> unit
val formatPrimTypeError :
  string -> Primitive_fish.prim_type -> Primitive_fish.prim_type -> unit
val formatArrayTypeError :
  string -> Types_fish.arrayType -> Types_fish.arrayType -> unit
val formatPhraseTypeError :
  string -> Types_fish.phraseType -> Types_fish.phraseType -> unit
val formatInvalidRunType : Types_fish.phraseType -> unit
val format_term_variable : Terms_fish.term_variable -> unit
val format_term : Terms_fish.fish_term -> unit
val format_shape_term : Terms_fish.fish_term -> unit
val format_shape_term : Terms_fish.fish_term -> unit
val format_parsed_term : Terms_fish.fish_term -> unit
val format_inferred_term : Terms_fish.fish_term -> unit
val format_declaration :
  Terms_fish.term_variable -> Types_fish.fishTyScheme -> unit
val format_shape_declaration :
  Terms_fish.term_variable ->
  Terms_fish.fish_term -> Types_fish.fishTyScheme -> unit

@head(2,"primitive_fish.mli")
primitive_fish.mli.
@select(tangler("src/primitive_fish.mli"))
exception Fish_error of string
type prim_type = | IntTy | BoolTy | FloatTy | CharTy
type prim_value = | Int of int | Bool of bool | Float of float | Char of char
type prim_constant =
  | Prim_value of prim_value
  | Pconst of prim_type list * bool * string
val string_of_prim_type : prim_type -> string
val string_of_static_prim_type : prim_type -> string
val type_prim_value : prim_value -> prim_type
val types_prim_constant : prim_constant -> prim_type list
val return_type_prim_constant : prim_constant -> prim_type
val string_of_prim_value : prim_value -> string
val is_polymorphic : string -> bool
val instantiate_polymorphic_op : string -> prim_type -> string
val prim_int_negative : prim_constant
val prim_float_negative : prim_constant
val prim_int_plus : prim_constant
val prim_int_times : prim_constant
val prim_int_minus : prim_constant
val prim_int_divide : prim_constant
val prim_int_modulo : prim_constant
val prim_int_equal : prim_constant
val prim_int_less_than : prim_constant
val prim_int_less_than_or_equal : prim_constant
val prim_int_greater_than : prim_constant
val prim_int_greater_than_or_equal : prim_constant
val prim_int2float : prim_constant
val prim_float_plus : prim_constant
val prim_float_times : prim_constant
val prim_float_minus : prim_constant
val prim_float_divide : prim_constant
val prim_float_equal : prim_constant
val prim_float_less_than : prim_constant
val prim_float_less_than_or_equal : prim_constant
val prim_float_greater_than : prim_constant
val prim_float_greater_than_or_equal : prim_constant
val prim_not : prim_constant
val prim_and : prim_constant
val prim_or : prim_constant
val prim_bool_equal : prim_constant
val prim_bool_less_than : prim_constant
val prim_bool_less_than_or_equal : prim_constant
val prim_bool_greater_than : prim_constant
val prim_bool_greater_than_or_equal : prim_constant
val prim_char_equal : prim_constant
val prim_char_less_than : prim_constant
val prim_char_less_than_or_equal : prim_constant
val prim_char_greater_than : prim_constant
val prim_char_greater_than_or_equal : prim_constant
val mk_mathop_1 : string -> prim_constant
val mk_mathop_2 : string -> prim_constant
val prim_acos : prim_constant
val prim_asin : prim_constant
val prim_atan : prim_constant
val prim_ceil : prim_constant
val prim_cos : prim_constant
val prim_cosh : prim_constant
val prim_exp : prim_constant
val prim_fabs : prim_constant
val prim_floor : prim_constant
val prim_log : prim_constant
val prim_log10 : prim_constant
val prim_sin : prim_constant
val prim_sinh : prim_constant
val prim_sqrt : prim_constant
val prim_tan : prim_constant
val prim_tanh : prim_constant
val prim_truncate : prim_constant
val prim_atan2 : prim_constant
val prim_fmod : prim_constant
val prim_pow : prim_constant
val apply_delta : prim_constant -> prim_value list -> prim_value

@head(2,"hook_fish.mli")
hook_fish.mli.
@select(tangler("src/hook_fish.mli"))
val version_number : string
val fish : unit -> unit

@head(2,"substitution_fish.mli")
substitution_fish.mli.
@select(tangler("src/substitution_fish.mli"))
module Term_subst :
  sig
    type key = Terms_fish.Ordered_vars.t
    type 'a t = 'a Map.Make(Terms_fish.Ordered_vars).t
    val empty : 'a t
    val add : key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  end
val id_term_subst : 'a Term_subst.t
val substitute :
  Term_subst.key ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val free_vars : Terms_fish.fish_term -> Terms_fish.term_variable list
val incrStringCounter : string -> char -> char -> string
val list_diff : 'a list -> 'a list -> 'a list
val tidy_term : Terms_fish.fish_term -> Terms_fish.fish_term

@head(2,"sugar_fish.mli")
sugar_fish.mli.
@select(tangler("src/sugar_fish.mli"))
val int_shape : Terms_fish.fish_term
val bool_shape : Terms_fish.fish_term
val float_shape : Terms_fish.fish_term
val tvar : string -> Terms_fish.fish_term
val mvar : int -> Terms_fish.fish_term
val ap : Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val ap2 :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val ap3 :
  Terms_fish.fish_term ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val ap4 :
  Terms_fish.fish_term ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val lam :
  Terms_fish.term_variable -> Terms_fish.fish_term -> Terms_fish.fish_term
val get_term : unit -> Terms_fish.fish_term
val get : Terms_fish.fish_term -> Terms_fish.fish_term
val condsh_term : Terms_fish.fish_term
val condsh :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val cond_term : Terms_fish.fish_term
val cond :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val condexp_term : Terms_fish.fish_term
val condexp :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val skip : Terms_fish.fish_term
val abort : Terms_fish.fish_term
val assign :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val seq :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val forall :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val whiletrue :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val fix : int -> Terms_fish.fish_term -> Terms_fish.fish_term
val newvar :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val output : Terms_fish.fish_term -> Terms_fish.fish_term
val var2exp_term : unit -> Terms_fish.fish_term
val var2exp : unit -> Terms_fish.fish_term -> Terms_fish.fish_term
val prim_true : Primitive_fish.prim_constant
val prim_false : Primitive_fish.prim_constant
val prim_zero : Primitive_fish.prim_constant
val prim_one : Primitive_fish.prim_constant
val prim_int : int -> Primitive_fish.prim_constant
val prim_char : char -> Primitive_fish.prim_constant
val newexp :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val bang : Primitive_fish.prim_type -> Terms_fish.fish_term
val zerodim : Terms_fish.fish_term -> Terms_fish.fish_term
val succdim :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val undim : Terms_fish.fish_term -> Terms_fish.fish_term
val lendim : Terms_fish.fish_term -> Terms_fish.fish_term
val preddim : Terms_fish.fish_term -> Terms_fish.fish_term
val numdim : Terms_fish.fish_term -> Terms_fish.fish_term
val equal :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val primrec :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val shape : Terms_fish.fish_term -> Terms_fish.fish_term
val null : Terms_fish.fish_term -> Terms_fish.fish_term
val len : Terms_fish.fish_term -> Terms_fish.fish_term
val is_length : Terms_fish.fish_term -> Terms_fish.fish_term
val ent_shape : Terms_fish.fish_term -> Terms_fish.fish_term
val check :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val bang_term : unit -> Terms_fish.fish_term
val identity : Terms_fish.fish_term
val wf : Terms_fish.fish_term -> Terms_fish.fish_term
val exp2comm : Terms_fish.fish_term
val multilam :
  Terms_fish.term_variable list ->
  Terms_fish.fish_term -> Terms_fish.fish_term
val multiseq : Terms_fish.fish_term list -> Terms_fish.fish_term

@head(2,"terms_fish.mli")
terms_fish.mli.
@select(tangler("src/terms_fish.mli"))
exception NoType
type term_variable =
  | Var of string
  | TypedVar of string * Types_fish.phraseType
  | Mvar of int
  | TypedMvar of int * Types_fish.phraseType
module Ordered_vars :
  sig
    type t = term_variable
    val compare : term_variable -> term_variable -> int
  end
val nextvar : unit -> term_variable
val nextTypedVar : Types_fish.phraseType -> term_variable
val var2string : term_variable -> string
val raw : term_variable -> term_variable
val declaredType : term_variable -> Types_fish.phraseType
val offerVarTy : term_variable -> term_variable
val assertIntTy : term_variable -> term_variable
type fish_term =
  | Tvar of term_variable
  | Apply of fish_term * fish_term
  | Lam of term_variable * fish_term
  | Where of fish_term * term_variable * fish_term
  | Op of Primitive_fish.prim_constant * fish_term list 
  | Get of fish_term
  | Sub of fish_term * fish_term
  | Condsh of fish_term * fish_term * fish_term
  | Cond of fish_term * fish_term * fish_term
  | Condexp of fish_term * fish_term * fish_term
  | Typed of fish_term * Types_fish.phraseType
  | Skip
  | Abort
  | Assign
  | Seq
  | Forall
  | Whiletrue
  | Fix of int
  | Newvar
  | Output
  | Dyn of Primitive_fish.prim_type
  | Newexp
  | Bang of Primitive_fish.prim_type
  | Zerodim
  | Succdim
  | Undim
  | Lendim
  | Preddim
  | Numdim
  | Equal
  | Primrec
  | Error
  | Shape
exception Shape_error of fish_term list * string
val isBang : fish_term -> bool
val shape2Pair : fish_term -> int list list * Primitive_fish.prim_type
val fishShape2Pair : fish_term -> fish_term list list * fish_term
val fishPair2Shape : fish_term list list * fish_term -> fish_term
val combinator_tyscheme : fish_term -> Types_fish.fishTyScheme

@head(2,"turbot2C_fish.mli")
turbot2C_fish.mli.
@select(tangler("src/turbot2C_fish.mli"))
val translateToFile : string -> Terms_fish.fish_term -> unit

@head(2,"types_fish.mli")
types_fish.mli.
@select(tangler("src/types_fish.mli"))
type arrayTyVar = | ArrayTyVar of int | UserATV of string
type phraseTyVar = | PhraseTyVar of int | UserPTV of string
val next_ty_count : unit -> int
val next_array_tyvar : unit -> arrayTyVar
val next_phrase_tyvar : unit -> phraseTyVar
module OrderedArrayTyVars :
  sig type t = arrayTyVar val compare : arrayTyVar -> arrayTyVar -> int end
module ArrayTyVarSet :
  sig
    type elt = OrderedArrayTyVars.t
    type t = Set.Make(OrderedArrayTyVars).t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val cardinal : t -> int
    val elements : t -> elt list
    val choose : t -> elt
  end
module OrderedPhraseTyVars :
  sig
    type t = phraseTyVar
    val compare : phraseTyVar -> phraseTyVar -> int
  end
module PhraseTyVarSet :
  sig
    type elt = OrderedPhraseTyVars.t
    type t = Set.Make(OrderedPhraseTyVars).t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val cardinal : t -> int
    val elements : t -> elt list
    val choose : t -> elt
  end
type tyVarSet = | Allvars of PhraseTyVarSet.t * ArrayTyVarSet.t
val emptyTyVarSet : tyVarSet
val unionTyVarSet : tyVarSet -> tyVarSet -> tyVarSet
val diffTyVarSet : tyVarSet -> tyVarSet -> tyVarSet
type arrayType =
  | ArrayTV of arrayTyVar
  | DatumTy of Primitive_fish.prim_type
  | ArrayTy of arrayType
type shapeType =
  | StaticTy of Primitive_fish.prim_type
  | HashArrayTy of arrayType
type dataType = | AT of arrayType | ShT of shapeType
type phraseType =
  | PhraseTV of phraseTyVar
  | HashPhraseTy of phraseTyVar
  | CommTy
  | VarTy of arrayType
  | ExpTy of dataType
  | FunTy of phraseType * phraseType
type fishTyScheme =
  | TyScheme of phraseTyVar list * arrayTyVar list * phraseType
val getTyVarsInPhrase : phraseType -> tyVarSet
val isShapeTy : phraseType -> bool
val get_datum_ty : phraseType -> Primitive_fish.prim_type
val arrayVarOccursInArray : ArrayTyVarSet.elt -> arrayType -> bool
val phraseVarOccursInPhrase : PhraseTyVarSet.elt -> phraseType -> bool
val freeVarsInTyScheme : fishTyScheme -> tyVarSet
val shp : phraseType -> phraseType
val mk_datum_ty : Primitive_fish.prim_type -> phraseType
val int : phraseType
val bool : phraseType
val float : phraseType
val char : phraseType
val mk_static_ty : Primitive_fish.prim_type -> phraseType
val size : phraseType
val fact : phraseType
val cost : phraseType
val mark : phraseType
val hashint : phraseType
val mk_data_ty : bool * Primitive_fish.prim_type -> phraseType
val datumty : Primitive_fish.prim_type -> dataType
val arrayty : arrayType -> dataType
val staticty : Primitive_fish.prim_type -> dataType
val hasharrayty : arrayType -> dataType
val commty : phraseType
val varty : arrayType -> phraseType
val expty : dataType -> phraseType
val funty : phraseType -> phraseType -> phraseType
val funty3 : phraseType -> phraseType -> phraseType -> phraseType
val funty4 :
  phraseType -> phraseType -> phraseType -> phraseType -> phraseType
val hashphrasety : phraseType -> phraseType
val tysch : phraseTyVar list -> arrayTyVar list -> phraseType -> fishTyScheme
val forall_U : (phraseType -> phraseType) -> fishTyScheme
val forall_X : (arrayType -> phraseType) -> fishTyScheme
val build_prim_const_type :
  (Primitive_fish.prim_type -> dataType) ->
  Primitive_fish.prim_constant -> phraseType
val datum_prim_const_type : Primitive_fish.prim_constant -> phraseType
val shape_prim_const_type : Primitive_fish.prim_constant -> phraseType

@head(2,"type_subs_fish.mli")
type_subs_fish.mli.
@select(tangler("src/type_subs_fish.mli"))
type array_tysub = (Types_fish.arrayTyVar * Types_fish.arrayType) list
type phrase_tysub = (Types_fish.phraseTyVar * Types_fish.phraseType) list
type tySub = | BothSubs of (phrase_tysub * array_tysub)
val addArrayTySub :
  Types_fish.arrayTyVar -> Types_fish.arrayType -> tySub -> tySub
val addArrayTySubs :
  Types_fish.arrayType -> tySub -> Types_fish.arrayTyVar list -> tySub
val addPhraseTySub :
  Types_fish.phraseTyVar -> Types_fish.phraseType -> tySub -> tySub
val addPhraseTySubs :
  Types_fish.phraseType -> tySub -> Types_fish.phraseTyVar list -> tySub
val inst_tyscheme : Types_fish.fishTyScheme -> Types_fish.phraseType
val applyTySub : tySub -> Types_fish.phraseType -> Types_fish.phraseType
val applyTySubToTyScheme :
  tySub -> Types_fish.fishTyScheme -> Types_fish.fishTyScheme
val applyTySubToEnv :
  tySub ->
  Types_fish.fishTyScheme Environments_fish.TyEnv.t ->
  Types_fish.fishTyScheme Environments_fish.TyEnv.t
val applyTySubToTermVar :
  tySub -> Terms_fish.term_variable -> Terms_fish.term_variable
val applyTySubToTerm : tySub -> Terms_fish.fish_term -> Terms_fish.fish_term
val idTySub : tySub
val o_ts : tySub -> tySub -> tySub

@head(2,"unify_fish.mli")
unify_fish.mli.
@select(tangler("src/unify_fish.mli"))
exception Incompatible_datum_types of Primitive_fish.prim_type *
                                        Primitive_fish.prim_type
exception UnifyArrayError of Types_fish.arrayType * Types_fish.arrayType
exception UnifyPhraseError of Types_fish.phraseType * Types_fish.phraseType
exception OccursPhraseError of Types_fish.phraseType * Types_fish.phraseType
exception OccursArrayError of Types_fish.arrayType * Types_fish.arrayType
val unifyLoop :
  (Types_fish.phraseType * Types_fish.phraseType) list * 
    Type_subs_fish.tySub ->
      Type_subs_fish.tySub 

@head(2,"lex_fish.mll")
lex_fish.mll.
@select(tangler("src/lex_fish.mll"))
(* lex_fish.mll -- OCaml lex file *)

{ 

(* header code *)      

open Lexing
open Parsing

open Primitive_fish
open Terms_fish
open Environments_fish
open Parse_fish

exception UnterminatedComment

(* globals *)

let buf_pos = ref 0
let last_buf_pos = ref 0
let comment_depth = ref 0
let line_number = ref 1    (* line number tracking for %use *)
;;

(* generates an Ocaml Hashtbl from a list of key/value pairs  *)

let hash_table_from_list n lst =
  let tbl = Hashtbl.create n
  in let addEntry (s,kw) = Hashtbl.add tbl s kw
  in 
  List.iter addEntry lst;
  tbl
;;      

(* keywords *)

let keyword_table =          (* number argument should be 
                                a prime larger than table size *)
  hash_table_from_list 97 [  

  (* FiSh keywords *) 


(* terms other than combinators *)

  "and",     TDand; 
  "check",   TCheck; 
  "do",      TDo;
  "done",    TDone;
  "else",    TElse;
  "end",     TEnd;
  "fill",    TFill;
  "for",     TFor;
  "fun",     TFun;
  "if",      TIf;
  "in",      TIn;
  "let",     TLet;
  "new",     TNew;
  "rec",     TRec;
  "return",  TReturn;
  "then",    TThen;
  "where",   TWhere;
  "while",   TWhile;
  "with",    TWith;



   (* shell directives *)

  "quit",    TQuit;
  "run",     TRun;
  "show",    TShow;
  "to",      TTo;
  "turbot",  TTurbot;
  "use",     TUse;

   (* boolean constants *)

  "true",    TBoolConst true;
  "false",   TBoolConst false; 

   (* datum shapes *)

  "int_shape",   TBangInt;
  "float_shape", TBangFloat;
  "bool_shape",  TBangBool;
  "char_shape",  TBangChar;

   (* type keywords *)

  "int",    TInt; 
  "float",  TFloat;
  "bool",   TBool; 
  "char",   TChar;
  "size",   TSize;
  "cost",   TCost;
  "fact",   TFact;
  "mark",   TMark;
  "exp",    TExp; 
  "var",    TVar;
  "comm",   TComm;

  (* FISh constructors *)

  "get",      TGet;
  "sub",      TSub;

  (* FISh combinators *)

  "zerodim",  TZerodim;
  "succdim",  TSuccdim;
  "undim",    TUndim;
  "lendim",   TLendim;
  "preddim",  TPreddim;
  "numdim",   TNumdim;
  "output",   TOutput;
  "skip",     TSkip;
  "abort",    TAbort;
  "assign",   TAssign;
  "seq",      TSeq;
  "cond",     TCond;
  "forall",   TForall;
  "whiletrue",TWhiletrue;
  "fix",      TFix;
  "newvar",   TNewvar;
  "newexp",   TNewexp;
  "primrec",  TPrimrec;
  "error",    TError;
  "shape",    TShape;
] 
;;

let primconst_table =              (* number argument should be 
                                      a prime larger than table size *)
  hash_table_from_list 29 [

  (* alphanumeric, prefix primitive constants *)
  (* handled by general case in the parser    *)

  "acos",   prim_acos;
  "asin",   prim_asin;
  "atan",   prim_atan;
  "ceil",   prim_ceil;
  "cos",    prim_cos;
  "cosh",   prim_cosh;
  "expt",   prim_exp;
  "fabs",   prim_fabs;
  "floor",  prim_floor;
  "int2float", prim_int2float;
  "log",    prim_log;
  "log10",  prim_log10;
  "not",    prim_not;
  "sin",    prim_sin;
  "sinh",   prim_sinh;
  "sqrt",   prim_sqrt;
  "tan",    prim_tan;
  "tanh",   prim_tanh;
  "truncate", prim_truncate
] 
;;

let primbinconst_table =           (* number argument should 
                                      a be prime larger than table size *)
  hash_table_from_list 5 [

  (* alphanumeric, infix primitive constants *)
  (* handled by general case in the parser    *)

  "atan2",  prim_atan2;
  "fmod",   prim_fmod;
  "pow",    prim_pow
] 
;;

let hex_char2int s =
  let c = Char.code s
  in 
  match s with
    _ when (s >= '0' & s <= '9') ->
      c - (Char.code '0') 
  | _ when (s >= 'a' & s <= 'f') ->
      (c - (Char.code 'a')) + 10 
  | _ when (s >= 'A' & s <= 'F') ->
      (c - (Char.code 'A')) + 10 
  | _ -> raise (Fish_error "in hexadecimal character")
;; 


(* hexint_of_string : string -> int *)

(* converts a string representing a hex number to integer value *)
(* assumes that string begins with "0x" or "0X"                 *)

let hexint_of_string s =
  let len = String.length s
  in if (s.[0] = '-') then 
    let value = ref (- (hex_char2int s.[3]))
    in 
    for i = 4 to (len - 1) do
      value := !value * 16 - (hex_char2int s.[i])
    done;
    !value
  else
    let value = ref (hex_char2int s.[2])
    in 
    for i = 3 to (len - 1) do
      value := !value * 16 + (hex_char2int s.[i])
    done;
    !value
;;

(* increment counters on newline *)

let incr_lex_counters lexbuf =
  incr line_number;
  last_buf_pos := !buf_pos;
  buf_pos := lexeme_end lexbuf
;;

} 

(* lexing rules *)

rule mainLex = parse

    (* whitespace *)

    [' ' '\t' ] + 
    { mainLex lexbuf }

|   "\n"
    { incr_lex_counters lexbuf; mainLex lexbuf }

    (* begin comment *)

| "(*"                
    { comment_depth := 1;
      commentLex lexbuf; 
      mainLex lexbuf }

    (* begin line comment *)

| "//"                
    { lineCommentLex lexbuf; 
      mainLex lexbuf }

    (* characters and strings *)

| "'\\b'" { TCharConst '\b' } 
| "'\\n'" { TCharConst '\n' } 
| "'\\r'" { TCharConst '\r' } 
| "'\\t'" { TCharConst '\t' } 
| "'\\\\'"{ TCharConst '\\' } 
| "'\''"  { TCharConst '\'' }


| "'" [^ '\039'] "'"     (* anything but single quote  *)

     { TCharConst  (String.get (lexeme lexbuf) 1) } 


|  '"' ([^ '"']*  | "\\\"")* '"'       (* anything but double quote  *)

    { let s = lexeme lexbuf in 
      TString (String.sub s 1 ((String.length s) - 2))
    }




    (* numerics *)

  (* hexadecimal *)

| ("0x" | "0X")['0' - '9' 'A' - 'F' 'a' - 'f']+ 
   { TIntConst (hexint_of_string (lexeme lexbuf)) }

  (* floating-point -- can omit decimal part, or exponential part, not both *)

| ['0' - '9']+ ('.' ['0' - '9']* ) (('e' | 'E') ('+' | '-')? ['0' - '9']+)
   { TFloatConst (float_of_string (lexeme lexbuf)) }

| ['0' - '9']+ ('.' ['0' - '9']* )                      
   { TFloatConst (float_of_string (lexeme lexbuf)) }

| ['0' - '9']+ (('e' | 'E') ('+' | '-')? ['0' - '9']+) 
   { TFloatConst (float_of_string (lexeme lexbuf)) }

  (* decimal *)

| [ '0' - '9' ]+  
   { TIntConst (int_of_string (lexeme lexbuf)) }

(* infix primitive constants - datum versions *)

| "+"   { TAddOp prim_int_plus }
| "-"   { TSubOp prim_int_minus } (* care with negation ! *)
| "*"   { TMultOp prim_int_times }
| "div"   { TDivOp prim_int_divide }
| "mod" { TModOp prim_int_modulo }
| "<"   { LT prim_int_less_than }
| "<="  { LEQ prim_int_less_than_or_equal }
| ">"   { GT prim_int_greater_than }
| ">="  { GEQ prim_int_greater_than_or_equal }
| "+."  { TAddOpFloat prim_float_plus }
| "*."  { TMultOpFloat prim_float_times }
| "-."  { TSubOpFloat prim_float_minus }
| "/"   { TDivOpFloat prim_float_divide }
| "/."  { TDivOpFloat prim_float_divide }
| "=."  { EQFloat prim_float_equal }
| "<."  { LTFloat prim_float_less_than }
| "<=." { LEQFloat prim_float_less_than_or_equal }
| ">."  { GTFloat prim_float_greater_than }
| ">=." { GEQFloat prim_float_greater_than_or_equal }
| "#="  { HashEQ }
| "&&"  { TAnd prim_and }
| "||"  { TOr prim_or }

(* shape versions *)

| "~+"   { TAddOp prim_int_plus }
| "~-"   { TSubOp prim_int_minus } (* care with negation ! *)
| "~*"   { TMultOp prim_int_times }
| "~/"   { TDivOp prim_int_divide }
| "~mod" { TModOp prim_int_modulo }
| "~<"   { LT prim_int_less_than }
| "~<="  { LEQ prim_int_less_than_or_equal }
| "~>"   { GT prim_int_greater_than }
| "~>="  { GEQ prim_int_greater_than_or_equal }
| "~+."  { TAddOpFloat prim_float_plus }
| "~*."  { TMultOpFloat prim_float_times }
| "~-."  { TSubOpFloat prim_float_minus }
| "~/."  { TDivOpFloat prim_float_divide }
| "~<."  { LTFloat prim_float_less_than }
| "~<=." { LEQFloat prim_float_less_than_or_equal }
| "~>."  { GTFloat prim_float_greater_than }
| "~>=." { GEQFloat prim_float_greater_than_or_equal }
| "~&&"  { TAnd prim_and }
| "~||"  { TOr prim_or }


(* unary ops *)

| "!"   { TBangOp }      
| "#"   { THashOp }


(* other tokens *)

| "="   { EQ }
| "~"   { TTwiddle }
| "%"   { Percent }
| "->"  { RArrow }
| ";"   { Semicolon }
| ":"   { Colon }
| ":="  { ColonEqual }
| ","   { Comma }
| "."   { Dot }
| "|"   { VerticalBar }
| "["   { LSquareBrace }
| "]"   { RSquareBrace }
| "{"   { LCurlyBrace }
| "}"   { RCurlyBrace }
| "("   { LParen }
| ")"   { RParen }
| eof   { TEof }

| ";;" [' ' '\t' ]* ("\n" | eof)
  { incr_lex_counters lexbuf;
    DoubleSemicolon }

  (* keyword, combinators, coercions, type keyword, primitive
  constants, identifiers. This case must follow other cases with
  alphanumerics, such as "and", "or", "mod" *)

| [ 'A' - 'Z' 'a' - 'z'] [ 'A' - 'Z' 'a' - 'z' '_' '0' - '9'] *

{ let lex_item = lexeme lexbuf
  in try Hashtbl.find keyword_table lex_item
     with Not_found ->
       try let prim_const = Hashtbl.find primconst_table lex_item
           in TPrimConst prim_const
       with Not_found -> 
         try let prim_const = Hashtbl.find primbinconst_table lex_item
             in TPrimBinConst prim_const
         with Not_found -> 
           TId lex_item
} 

and commentLex = parse

    "(*" 
    { incr comment_depth; commentLex lexbuf }

  | "*)" 
    { decr comment_depth;
      if !comment_depth == 0 then () else commentLex lexbuf }

  | "\n"
    { incr_lex_counters lexbuf; commentLex lexbuf }

  | eof 
    { raise UnterminatedComment }

  | _ 
    { commentLex lexbuf }

and lineCommentLex = parse

   "\n"
    { incr_lex_counters lexbuf; () }

  | eof
    { () }

  | _ 
    { lineCommentLex lexbuf }

(* trailer code *)      

{ 
(* interface_fish.ml *)


exception FishSyntaxError of int * int * string (* line, column *)

let runParser pr lexer lexbuf =
  line_number := 1;
  buf_pos := lexeme_end lexbuf;
  try pr lexer lexbuf
  with 
    Parse_error -> 
      let cur_pos = lexeme_start lexbuf 
      in        
      if (cur_pos >= !buf_pos)
      then raise 
          (FishSyntaxError 
             (!line_number,cur_pos - !buf_pos + 1,""))
      else raise (* last valid lexeme on previous line *)
          (FishSyntaxError 
             (!line_number - 1,cur_pos - !last_buf_pos + 1,""))
  | Failure message -> 
      let cur_pos = lexeme_start lexbuf 
      in        
      if (cur_pos >= !buf_pos)
      then raise 
          (FishSyntaxError 
             (!line_number,cur_pos - !buf_pos + 1,message))
      else raise (* last valid lexeme on previous line *)
          (FishSyntaxError 
             (!line_number - 1,cur_pos - !last_buf_pos + 1,message))
;;

(* supply lexical buffers to parsers *)

let makeParserForFile pr fileName =
    pr (from_channel (open_in fileName))
;;

let makeParserForConsole pr =
    pr (from_channel stdin)
;;

let makeParserForString pr s =
    pr (from_string s)
;;

let makeParser pr lexbuf =
  runParser pr mainLex lexbuf
;;

(* parsers for shell interaction *)

let parseShell : lexbuf -> Util_fish.fish_shell_action =
  makeParser parseShellAction
;;

let parseShellFromFile fileName =
  makeParserForFile parseShell fileName
;;

let parseShellFromConsole () =
  makeParserForConsole parseShell 
;;

let parseShellFromString s =
  makeParserForString parseShell s
;;

(* parsers for list of shell actions *)

let parseShellList  : lexbuf -> Util_fish.fish_shell_action list =
  makeParser parseShellActionList

let parseShellListFromConsole () =
  makeParserForConsole parseShellList
;;

let parseShellListFromFile fileName =
  makeParserForFile parseShellList fileName
;;

let parseShellListFromString s =
  makeParserForString parseShellList s
;;

(* parsers for fish terms *)

let parseForFish : lexbuf -> fish_term =
  makeParser parseFish

let parseFishFromConsole () =
  makeParserForConsole parseForFish
;;

let parseFishFromFile fileName =
  makeParserForFile parseForFish fileName
;;

let parseFishFromString s =
  makeParserForString parseForFish s
;;
}

@head(2,"util_fish.mli")
util_fish.mli.
@select(tangler("src/util_fish.mli"))
type run_flag = Quiet_flag | Compile_flag
type show_mode = Show_on | Show_off
type fish_shell_action =
    Let_decl of Terms_fish.term_variable * Terms_fish.fish_term
  | Turbot_directive of Terms_fish.term_variable * run_flag list
  | Run_directive of Terms_fish.term_variable * run_flag list * string
  | Show_directive of show_mode * string
  | Use_directive of string
  | Quit_directive
exception No_such_mode
val modes : (string * show_mode) list ref
val set_mode: string -> show_mode -> unit
val get_mode: string -> show_mode

@head(2,"util_fish.ml")
util_fish.ml.
@select(tangler("src/util_fish.ml"))
type run_flag = Quiet_flag | Compile_flag
type show_mode = Show_on | Show_off
type fish_shell_action =
    Let_decl of Terms_fish.term_variable * Terms_fish.fish_term
  | Turbot_directive of Terms_fish.term_variable * run_flag list
  | Run_directive of Terms_fish.term_variable * run_flag list * string
  | Show_directive of show_mode * string
  | Use_directive of string
  | Quit_directive


exception No_such_mode
let modes = ref [         (* list of string/default pairs *)
  "parse",Show_off ;      (* do not display parse trees *)
  "infer",Show_off ;      (* do not display inferred term *)
  "loop_opt",Show_on ;    (* do lift newvar from loops  *)
  "datum_opt",Show_on ;   (* do lift newexp from datum operations *)
  "assign_opt",Show_on    (* do lift newexp from assignments *)
] ;;


let is_nonempty_prefix s1 s2 =  (* prefixes of mode names will suffice, 
                                   except for "assign" *)
  let s1_len = String.length s1
  and s2_len = String.length s2
  in 

  if s1_len = 0 or s1_len > s2_len 
  then false
  else s1 = String.sub s2 0 s1_len
;;  

let set_mode s mode =
  let rec loop lst =
    match lst with
      [] -> raise No_such_mode
    | (name,curr)::t ->
        if is_nonempty_prefix s name
        then (name,mode)::t
        else (name,curr)::(loop t)
  in 

  modes := loop (!modes)
;;

let get_mode s = 
  try List.assoc s !modes
  with Not_found -> raise (Primitive_fish.Fish_error "unrecognised mode")
;;


@head(2,"parse_fish.mly")
parse_fish.mly.
@select(tangler("src/parse_fish.mly"))
/* parse_fish.mly

   OCaml yacc source 

   To generate ML source,

        execute 

                ocamlyacc -v parse_fish.mly        

        (this is now done automagically by the Makefile)

   User syntax is described in Fish/Alpha/Docs/syntax.txt. 

   Notes: 

          Stratification into fishTerm and simpleFishTerm, to
          facilitate making application left-associative, borrowed
          from the O'Caml grammar for itself.

  References: 
              "bison for yacc - see school home pages"
              "O'Reilly book on lex and yacc". 

*/

%{ (* header *)

open List

open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Substitution_fish
open Util_fish

type newDecl = ShapeDecl | ExpDecl

let rec make_nested_new decls body =

  let new_with_init x e t =
    let ty = try (declaredType x)
              with NoType -> VarTy (ArrayTV (next_array_tyvar())) in 
    let z = nextTypedVar ty in  

    newvar 
        (shape e)
        (lam z (seq (assign (Tvar z) e) (substitute x (Tvar z) t)))    
      
  and new_without_init x sh t =
    let x' = offerVarTy x in
    newvar sh (lam x' t)

  in           

  match decls with

    [(ShapeDecl,x,sh)] -> 
      new_without_init x sh body

  | [(ExpDecl,x,e)] -> 
      new_with_init x e body

  | (ShapeDecl,x,sh)::rest -> 
      new_without_init x sh (make_nested_new rest body)

  | (ExpDecl,x,e)::rest -> 
      new_with_init x e (make_nested_new rest body)

  | [] -> body 
;;


let make_newvar decls body returnId = 

  let newvar_without_init x sh body =
    let x' = offerVarTy x in
    newexp sh (lam x' body)

  and newvar_with_init x e body =

    let z = nextvar()
    and x' = offerVarTy x in
    let f = 
      lam x' (seq (assign (Tvar x) (Tvar z)) body)
    in 
    newexp (shape e) (substitute z e f)

  and (c,x,t) = hd decls
  and tl_decls = tl decls 
  in 
  
  if x <> returnId
  then raise (Fish_error ":wrong return identifier");

  match (c,tl_decls) with

    ShapeDecl,[] -> 
      newvar_without_init x t body

  | ExpDecl,[] -> 
      newvar_with_init x t body

  | ShapeDecl,_ ->  
      newvar_without_init x t
        (make_nested_new tl_decls body)

  | ExpDecl,_ ->  
      newvar_with_init x t
        (make_nested_new tl_decls body)
;;

let make_nested_where bindings body =
  let rec loop lst =
    match lst with
      [(x,t)] -> Where(body,x,t)
    | (x,t)::bs -> Where(loop bs,x,t)
    | _ -> raise (Fish_error "in where-clause")
  in loop bindings
;;
  
let fixof k f =

(*

fixof k f x0 x1 ... x(k-1) = 
  new y0 = x0 ;
      ...
      y(k-1) := x(k-1) 
  in
  let g z0 z1 ... z(k-1) = 
  y0 := z0 ;
  ...
  y(k-1) := z(k-1) ;
    new 
      y'0 = y0 ;
      ...
      y'(k-1) = y(k-1)       (* c.f. caller save registers protocol  *) 
    in 
      C ;
      y0 := y'0 ;
      ...
      y(k-1) := y'(k-1) 
    end
  in 
  let P C = f g y0 y1 ... y(k-1) in 
    fix(0) P 
  end 
*)
 


  let makeVarTriple () =
    let x = nextTypedVar(ExpTy (AT (ArrayTV (next_array_tyvar()))))
    and y = nextvar()
    and z = nextvar()
    in (x,y,z)
  in

  let makeVars () = 
    let vars = ref []
    in
    for i = 1 to k do
      vars := makeVarTriple() :: !vars
    done;
    !vars
  in

  let make_comm_functional bigP yzs = 

    let bigC = nextvar()
    and bang_ys = map (fun (y,_) -> (Tvar y)) yzs (* var2exp deleted *)
    and zs = map (fun (_,z) -> z) yzs
    and assigns = map (fun (y,z) -> assign (Tvar y) (Tvar z)) yzs
    and y_primes = map (fun _ -> nextvar()) yzs
    in
    
    let push_ys = 
      map2 (fun (y,_) -> fun y' -> (ExpDecl,y',Tvar y)) yzs y_primes
    and pop_ys = 
      map2 (fun (y,_) -> fun y' -> assign (Tvar y) (Tvar y')) yzs y_primes
    in 
    
    let littleG = 
      multilam zs 
        (make_nested_new
           push_ys
           (multiseq (assigns @ [Tvar bigC] @ pop_ys)))

    in lam bigC (List.fold_left ap bigP (littleG::bang_ys))
      
  in 

  let xyzs = makeVars()
  in

  let xs = map (fun (x,_,_) -> x) xyzs
  and yzs = map (fun (_,y,z) -> (y,z)) xyzs
  and inits = map (fun (x,y,_) -> (ExpDecl,y,Tvar x)) xyzs
  in

  let fnal = make_comm_functional f yzs
  in
  
  multilam xs (make_nested_new inits (fix(0) fnal))
;;


let make_rec_fun f args body =
  let the_fun = multilam args body
  in let fvs = free_vars the_fun 
  in
  if mem f fvs (* really a recursive fun *)
  then fixof (length args) (lam f the_fun)
  else the_fun
;;


let make_zerodim_term t =
  let x = offerVarTy(nextvar())
  in 
  newexp 
    (zerodim (shape t)) 
    (lam x (assign (Get (Tvar x)) t))
;;

let make_succdim_term t =
  let x = offerVarTy(nextvar())
  and counter = ref 0
  in let mk_assn h n = 
    assign (Sub(Tvar x, Op (Prim_value (Int n),[]))) h
  in let assns = 
    multiseq 
      (map (fun t -> let v = mk_assn t !counter in incr counter;v) t)
  in 
  newexp 
    (succdim (Op (Prim_value (Int (length t)),[])) (shape (hd t)))
    (lam x assns)
;;

let fill_shape sh ts =

  let (ndxs,_) = 
    try shape2Pair sh
    with _ -> raise (Fish_error "not a static shape")
        
  and data_fills_shape shlst data =
    let slots = fold_left (fun x -> fun y -> x * y) 1 (flatten shlst)
    in slots = length data
      
  and x = offerVarTy(nextvar()) in

  match (ndxs,ts) with

  | _ when not (data_fills_shape ndxs ts) ->
      raise (Fish_error "wrong number of array entries")

  | (_,[]) -> newexp sh (lam x skip)

  | ([],[t]) -> newexp sh (lam x (assign (Tvar x) t))

  | _ -> 

      let flat_ndxs = flatten ndxs
      in let num_ndxs = length flat_ndxs
      in let ndx_array = Array.of_list flat_ndxs  

      and counters = Array.create num_ndxs 0

      in let incr_counters() =

        let i = ref (Array.length ndx_array - 1)
        and flag = ref false
        in 

        if (!i >= 0) then (* may have empty index array *)

        while not (!flag)  do
          flag := true;
          counters.(!i) <- (counters.(!i) + 1) mod ndx_array.(!i);
          if (counters.(!i) = 0 & !i > 0)
          then (i := !i - 1;flag := false)
        done 

      and boundaries = 

        (* boundaries.(i) = n means need to insert n get's
           after applying the i'th index        
        *)

        let r = Array.create (num_ndxs + 1) 0 
        and n = ref 0
        in 
        iter (fun lst -> n := !n + (length lst);r.(!n) <- r.(!n) + 1) ndxs;
        r

      in let gets_at_ndx ndx = 
           Array.to_list (Array.create boundaries.(ndx) (get_term()))

      in let inner_term = List.fold_right ap (gets_at_ndx 0) (Tvar x) 

      in let next_sub() = 
        let curr_ndx = ref 1
        in let mk_sub t n = 
          let gets = gets_at_ndx !curr_ndx
          in let the_sub = 
            List.fold_right ap gets (Sub(t, Op (Prim_value (Int n),[]))) 
          in 
          incr curr_ndx;
          the_sub
        in let v = Array.fold_left mk_sub inner_term counters
        in 
        incr_counters();
        v

      in let mk_assn h = 
        assign (next_sub()) h
      in let assns = multiseq (map mk_assn ts)
      in 
      
      newexp sh (lam x assns)
;;

let parse_string str = 
  let n = String.length str   (* end-quotes already removed *)
        and x = nextvar() 
        and b = ref true      (* b records non-escaped characters *)
        and body = ref skip   (* the body of the eventual assignment *)
        and e = ref skip in   (* the primitive character to be assigned *)
        let k = ref n         (* the number of actual characters 
                                 after deleting escapes *)
        in 

        for i=0 to n-1 do 
          if !b 
          then ( 
            let j = Op(prim_int i,[])
            and c = String.get str i in 
            (if c = '\\' 
            then 
              (let d = 
                (match String.get str (i+1) with
                  'b' -> '\b'
                | 'n' -> '\n'
                | 'r' -> '\r'
                | 't' -> '\t'
                | '"' -> '"'
                | _ -> raise (Fish_error "not a valid escape character") 
                ) in 
              e := Op(prim_char d,[]) ;
              b := false ; 
              decr k 
              )

            else e:= Op(prim_char c,[]) 
            ) ;
            body := seq (assign (Get (Sub(Tvar x,j))) !e) !body 
          )
          else  b:= true 
        done ;

        newexp (succdim (Op(prim_int !k,[])) (zerodim (Bang CharTy)))
               (lam x !body)


(* some shell stuff needed by the parser  *)


%}

/* static flag */

%token TTwiddle

/* operators */

%token TBangOp,THashOp

/* identifier */

%token <string> TId 

/* constants */

%token <int>   TIntConst
%token <float> TFloatConst
%token <bool>  TBoolConst
%token <char>  TCharConst
%token <string>TString 

/* strings (for filenames) */

%token <string> TString

/* keywords */ 

%token TDand,TCheck,TDo,TDone,TElse,TEnd,TFill,TFor,TFun,TIf,TIn,TLet,
       TNew,TRec,TThen,TWhere,TWhile,TWith

/* shell directives */

%token TQuit,TReturn,TRun,TShow,TTo,TTurbot,TUse


/* FiSh combinators */

%token TSub,TGet,TZerodim,TSuccdim,TUndim,TLendim,TPreddim,     
       TNumdim,EQ,HashEQ,TOutput,TSkip,TAbort,TAssign,TSeq,
       TForall,TWhiletrue,TFix,TNewvar,TNewexp,
       TCond,TPrimrec,TError,TShape

/* primitive constants = d's in paper, excluding infix ops */

%token <Primitive_fish.prim_constant> TPrimConst, TPrimBinConst

/* type-related */

%token TInt,TFloat,TBool,TChar,TSize,TCost,TFact,TMark,TComm,TVec,TExp,TVar 
/* unused currently */
%token TBangInt,TBangFloat,TBangBool, TBangChar

/* infix primitive constants 

   argument is a function that builds either a
   Datum_const or Shape_const, given a prim_constant
*/

%token <Primitive_fish.prim_constant> 
       TAddOp,TSubOp,TMultOp,TDivOp,TModOp,
       LT,LEQ,GT,GEQ,
       TAddOpFloat,TMultOpFloat,TSubOpFloat,TDivOpFloat,
       EQFloat,LTFloat,LEQFloat,GTFloat,GEQFloat,
       TAnd,TOr,EQBool

/* punctuation */

%token Percent,Semicolon,DoubleSemicolon,
       Colon,ColonEqual,
       Comma,Dot,VerticalBar,
       LSquareBrace,RSquareBrace,
       LCurlyBrace,RCurlyBrace
       LParen,RParen 
       RArrow

/* end of file */

%token TEof

/* precedences */

%left DoubleSemicolon

%right prec_fun

%left prec_binding_list

%right prec_let

%right prec_cond

%right Semicolon

%left prec_binding

%left TWhere

%right ColonEqual 

%right Dot

%left TAnd 
%left TOr 

%left EQ HashEQ LEQ LT GEQ GT EQFloat LEQFloat LTFloat GEQFloat GTFloat EQBool prec_rel

%left TAddOp TSubOp TAddOpFloat TSubOpFloat prec_add

%left TMultOp TDivOp TMultOpFloat TDivOpFloat TModOp prec_mult

%left  prec_app           /* application precedence */

%right prec_unop          /* unary ops */ 
%left  LSquareBrace       /* for x[n] */

/* entry point for FiSh parser */

%type <Terms_fish.fish_term> parseFish
%start parseFish  

/* entry point for shell parser */

%type <Util_fish.fish_shell_action> parseShellAction
%start parseShellAction        

/* alternate entry point for shell parser */

%type <Util_fish.fish_shell_action list> parseShellActionList
%start parseShellActionList 

%%        

parseShellAction :

    shellAction 
      { $1 }

  | TEof
      { Quit_directive }
;

parseShellActionList :

    shellActionList
      { $1 }
;

shellAction :

    TLet binding DoubleSemicolon
      { let (x,t) = $2 in Let_decl (x,t) }

  | TLet TRec recBinding DoubleSemicolon
      { let (x,t) = $3 in Let_decl (x,t) }        

  | fishTerm DoubleSemicolon
      { Let_decl(Var "J",$1) }

  | Percent directive DoubleSemicolon
      { $2 }
;

shellActionList :

    TEof
      { [] }

  | shellAction shellActionList
      { $1::$2 }

parseFish :

    fishTerm  
      { $1 }
;

parameter :

      TId 
      { Var $1 }

  | LParen TId Colon fishPhraseType RParen 
      { TypedVar ($2,$4) }

parameterList :

    parameter 
      { [$1] }

  | parameter parameterList
      { (* no duplicates allowed *)
        if mem (var2string $1) (map var2string $2) 
        then raise Parse_error 
        else $1::$2
      }

;

directive :

  | TRun runFlagList
      { Run_directive (Var "main",$2,"main") }

  | TRun runFlagList TId
      { Run_directive (Var $3,$2,$3) }

  | TRun runFlagList TTo TId
      { Run_directive (Var "main",$2,$4) }

  | TRun runFlagList TId TTo TId
      { Run_directive (Var $3,$2,$5) }

  | TTurbot runFlagList 
      { Turbot_directive (Var "main",$2) }

  | TTurbot runFlagList TId
      { Turbot_directive (Var $3,$2) }

  | TQuit 
      { Quit_directive }

  | TShow plusOrMinus TId
      { Show_directive ($2,$3) }

  | TUse TString
      { Use_directive $2 }
;

runFlag :

    TSubOp TId
      { match $2 with
          "q" -> Quiet_flag
        | "c" -> Compile_flag
        | _ -> raise Parse_error
      }                         
;

runFlagList :

   { [] }

  | runFlag runFlagList
   { $1::$2 }
;

plusOrMinus :

    TAddOp
      { Util_fish.Show_on }

  | TSubOp
      { Util_fish.Show_off }
;




fishTerm :

    simpleFishTerm 
      { $1 }

  | simpleFishTerm simpleFishTermList %prec prec_app
      { List.fold_left ap $1 (rev $2) }

  | negOp simpleFishTerm %prec prec_unop
      { Op($1,[ $2 ]) (* all ops are shape ops by default *) }

  | fishTerm addOp fishTerm %prec prec_add
      { Op($2, [$1; $3]) }

  | fishTerm multOp fishTerm %prec prec_mult 
      { Op($2, [$1; $3]) }

  | fishTerm relOp fishTerm %prec prec_rel
      { Op($2, [$1; $3]) }

  | fishTerm TAnd fishTerm 
      { Op (prim_and, [$1; $3]) }

  | fishTerm TOr fishTerm 
      { Op (prim_or, [$1; $3]) }

  | TPrimConst fishTerm %prec prec_unop 
      { Op($1,[ $2 ]) }

  | fishTerm HashEQ fishTerm 
      { equal $1 $3 }

  | TIf fishTerm TThen fishTerm TElse fishTerm %prec prec_cond
      { Condsh($2,$4,$6) (* assume conditionals are shapely 
                            until type inference *) }

  | TIf fishTerm TThen fishTerm TElse  %prec prec_cond
      { Condsh($2,$4,skip) }

  | TIf fishTerm TThen TElse fishTerm %prec prec_cond
      { Condsh($2,skip,$5)  }

  | TIf fishTerm TThen TElse  %prec prec_cond
      { Condsh($2,skip,skip)  }

  | TCheck simpleFishTerm fishTerm
      { Condsh($2,$3,Error) }

  | TNew newDeclList TIn fishTerm TEnd
      { make_nested_new $2 $4 }

  | TNew newDeclList TIn TEnd
      { make_nested_new $2 skip  }

  | TNew newDeclList TIn fishTerm TReturn TId 
      { make_newvar $2 $4 (Var $6) }

  | TNew newDeclList TIn TReturn TId 
      { make_newvar $2 skip (Var $5) }

  | TLet bindingList TIn fishTerm %prec prec_let
      { make_nested_where $2 $4 }

  | TLet TRec recBindingList TIn fishTerm %prec prec_let
      { make_nested_where $3 $5 }

  | fishTerm Semicolon fishTerm
      { seq $1 $3 }

  | fishTerm Semicolon      
      { seq $1 skip }        

  | fishTerm ColonEqual fishTerm 
      { assign $1 $3 }

  | TFor forBounds TDo fishTerm TDone
      { let (x,lo,hi) = $2 in
        let x' = assertIntTy x in 
          forall lo hi (lam x' $4) }

  | TFor forBounds TDo  TDone
      { let (x,lo,hi) = $2 in 
        let x' = assertIntTy x in 
          forall lo hi (lam x' skip) }

  | TWhile fishTerm TDo fishTerm TDone
      { whiletrue $2 $4 }

  | TWhile fishTerm TDo  TDone
      { whiletrue $2 skip }

  | fishTerm TWhere bindingList
      { make_nested_where (rev $3) $1 (* reverse binding order *) }

  | fishTerm TWhere TRec recBindingList
      { make_nested_where (rev $4) $1 (* ditto *) }

  | TFun parameter RArrow fishTerm %prec prec_fun
      { Lam($2,$4) }

  | fishComposition
      { $1 }

  | zeroDimTerm
      { $1 }

  | fillTerm
      { $1 }
;

binding :

    parameterList EQ fishTerm %prec prec_binding
      { match $1 with 
          h::t -> (h ,multilam t $3) 
        | [] -> raise Parse_error }

;

bindingList :

    binding                       %prec prec_binding_list
      { [$1] }

  | binding TDand bindingList %prec prec_binding_list
      { $1::$3  } 
;

recBinding :

    parameterList EQ fishTerm %prec prec_binding
      { match $1 with 
        h::t -> (h,make_rec_fun h t $3)  
        | [] -> raise Parse_error }

;

recBindingList :

    recBinding                          %prec prec_binding_list
      { [$1] }

  | recBinding TDand recBindingList %prec prec_binding_list
      { $1::$3 } 
;

forBounds :

    fishTerm LEQ TId LT fishTerm 
      { (Var $3,$1,$5) }

  | TId LT fishTerm              
      { (Var $1,Op (prim_zero,[]),$3) }

  | LParen forBounds RParen
      { $2 }
;

simpleFishTerm :

    unTypedFishTerm 
      { $1 }

  | LParen fishTerm Colon fishPhraseType RParen
      { match $4 with 
          ExpTy(ShT (HashArrayTy(DatumTy _))) 
      |        _ -> Typed ($2,$4) }
;

unTypedFishTerm : 

    LParen fishTerm RParen
      { $2 }

  | TId 
      { Tvar (Var $1) }

  | fishPrimValue
      { Op(Prim_value $1,[]) (* all primitives are shapes now *)} 

  | TTwiddle fishPrimValue %prec prec_unop
      { Op(Prim_value $2,[]) }

  | fishUnop simpleFishTerm %prec prec_unop
      { ap $1 $2 }

  | TString
      { parse_string $1 }  

  | simpleFishTerm TPrimBinConst simpleFishTerm %prec prec_unop
      { Op($2,[ $1 ; $3 ]) }

  | simpleFishTerm bracedFishTermList
      { Get (fold_left (fun t -> fun t' -> Sub(t,t')) $1 $2) }

  | fishBang
      { Bang $1 }

  | TGet simpleFishTerm
      { Get $2   }

  | TSub LParen fishTerm Comma fishTerm RParen 
      { Sub ($3,$5) }

  | fishCombinator
      { $1 }

  | bracedShapeList 
      { $1 }

  | succDimTerm
      { $1 }

/* for later ? 


  | TString
      { let n = String.length $1 in 
        let aty = VarTy (ArrayTV (next_array_tyvar())) in 
        let x = nextTypedVar(aty) in 
        let t = ref skip in 

        for i = 1 to n-1 do
          t := seq (assign (Get(Sub(Tvar x,Op(prim_int (i-1),[])))) 
                           (Op(prim_char (String.get $1 i),[]))) 
               !t 
        done ;

        newexp (succdim (Op(prim_int (n - 2),[])) (zerodim (Bang CharTy)))
          (lam x !t)
      }        
*/

fishDatumType :

  | TInt 
      { IntTy }

  | TFloat 
      { FloatTy }

  | TBool
      { BoolTy }

  | TChar
      { CharTy }


fishArrayType : 

  | fishDatumType
      { DatumTy $1 }

  | LSquareBrace TId RSquareBrace
      { ArrayTy (ArrayTV (UserATV $2)) }

  | LSquareBrace fishArrayType RSquareBrace
      { ArrayTy $2 }
;

fishShapeType:

   TSize 
      { StaticTy IntTy }

  | TCost
      { StaticTy FloatTy }

  | TFact
      { StaticTy BoolTy }

  | TMark
      { StaticTy CharTy }

  | THashOp fishArrayType 
      { HashArrayTy $2 }
;

fishDataType :

  | fishArrayType 
      { AT $1 }

  | fishShapeType
      { ShT $1 }
;

fishPhraseType:

    LParen fishPhraseType RParen
      { $2 }

  | TId
      { PhraseTV (UserPTV $1) }

  | THashOp TId
      {HashPhraseTy (UserPTV $2) }

  | TExp TId
      { ExpTy (AT (ArrayTV (UserATV $2))) } 

  | TExp THashOp TId
      { ExpTy (ShT (HashArrayTy (ArrayTV (UserATV $3)))) } 

  | TExp fishDataType
      { ExpTy $2 } 

  | fishDataType 
      { ExpTy $1 }

  | TVar TId
      { VarTy (ArrayTV (UserATV $2)) } 

  | TVar fishArrayType 
      { VarTy $2 }

  | TComm
      { CommTy }

  | fishPhraseType RArrow fishPhraseType
      { FunTy ($1,$3) }
;      

fishPrimValue :

    TIntConst 
      { Int $1 }

  | TBoolConst 
      { Bool $1 }

  | TFloatConst 
      { Float $1 }

  | TCharConst
      { Char $1 }

;

simpleFishTermList :

    simpleFishTerm 
      { [$1] }

  | simpleFishTermList simpleFishTerm
      { $2::$1 }
;

bracedFishTermList :

    LSquareBrace fishTermCommaList RSquareBrace
      { $2 }
;

fishUnop :

    TBangOp    { bang_term() }
  | THashOp    { Shape     }  
;

fishBang :

    TBangInt   { IntTy   }
  | TBangFloat { FloatTy }
  | TBangBool  { BoolTy  }
  | TBangChar  { CharTy  }

fishCombinator :

    TNewexp      { Newexp   }

  | TZerodim     { Zerodim  }
  | TSuccdim     { Succdim  }
  | TUndim       { Undim    }
  | TLendim      { Lendim   }
  | TPreddim     { Preddim  }
  | TNumdim      { Numdim   }

  | TOutput      { Output   }
  | TSkip        { Skip     }
  | TAbort       { Abort    }
  | TAssign      { Assign   }
  | TSeq         { Seq      }
  | TCond        { condsh_term}
  | TForall      { Forall   }
  | TWhiletrue   { Whiletrue}
  | TFix         { Fix 0    }
  | TNewvar      { Newvar   }

  | TPrimrec     { Primrec  }
  | TError       { Error    }
  | TShape       { Shape    }
;

fishComposition :

    fishTerm Dot fishTerm
      { let x = nextvar() in lam x (ap $1 (ap $3 (Tvar x))) }
;

negOp :

    TSubOp           { prim_int_negative   }
  | TSubOpFloat      { prim_float_negative }
;

addOp :

    TAddOp           { prim_int_plus }
  | TSubOp           { prim_int_minus }
  | TAddOpFloat      { prim_float_plus }
  | TSubOpFloat      { prim_float_minus }
;

multOp :

    TMultOp           { prim_int_times }
  | TDivOp            { prim_int_divide }
  | TModOp            { prim_int_modulo }
  | TMultOpFloat      { prim_float_times }
  | TDivOpFloat       { prim_float_divide }
;

relOp :

    EQ       { prim_int_equal }
  | GT       { prim_int_greater_than }
  | GEQ      { prim_int_greater_than_or_equal }
  | LT       { prim_int_less_than }
  | LEQ      { prim_int_less_than_or_equal }
  | EQFloat  { prim_float_equal }
  | GTFloat  { prim_float_greater_than }
  | GEQFloat { prim_float_greater_than_or_equal }
  | LTFloat  { prim_float_less_than }
  | LEQFloat { prim_float_less_than_or_equal }
;

fishTermCommaList :

    { [] }

  | fishTerm
    { [$1] }

  | fishTerm Comma fishTermCommaList
    { $1::$3 }
;

bracedShapeList :

    LCurlyBrace shapeList RCurlyBrace
      { $2 }
;


shapeList :

    fishTerm
      { fishPair2Shape([],$1) }

  | Colon shapeList
      { fishPair2Shape([[]],$2) }

  | fishTermCommaList Colon shapeList
      { let (lst,b) = fishShape2Pair $3
        in 
        fishPair2Shape($1::lst,b) 
      }
;

shapeDecl :

    THashOp TId EQ fishTerm
      { (ShapeDecl,Var $2,$4) }
;

expDecl :

    TId EQ fishTerm
      { (ExpDecl,Var $1,$3) }
;

newDecl :

    shapeDecl
      { $1 }

  | expDecl
      { $1 }
;

newDeclList :

    newDecl 
      { [$1] }

  | newDecl TDand newDeclList
      { $1::$3 } 
;

simpleFishOrZeroDimTerm :

    simpleFishTerm 
      { $1 }

  | zeroDimTerm
      { $1 }
;      

arraySemicolonList :

   simpleFishOrZeroDimTerm
    { [$1] }

  | simpleFishOrZeroDimTerm Semicolon arraySemicolonList
    { $1::$3 }
;

zeroDimTerm :

    LSquareBrace fishTerm RSquareBrace
    { make_zerodim_term $2 }
;

succDimTerm :

    VerticalBar arraySemicolonList VerticalBar
    { make_succdim_term $2 }
;

fillTerm :

    TFill simpleFishTerm TWith LSquareBrace fishTermCommaList RSquareBrace
    { fill_shape $2 $5 }

%% 

(* trailer *)


@head(2,"environments_fish.ml")
environments_fish.ml.
@select(tangler("src/environments_fish.ml"))
(* type environments and all stuff required before parsing *)

open List

open Primitive_fish
open Types_fish
open Terms_fish

module TyEnv = Map.Make(Ordered_vars) (* for type environments *)

type globalEnv = 
    (term_variable * (phraseType * fish_term * fish_term)) list
;;

(*
These are used to house all type and shape information about
variables. To each variable is associated its 

  type, 
  shape and 
  (partially evaluated) term.

*)

type shapeEnv = (term_variable * (fish_term * fish_term)) list
;;

(* Shape environments, used in partial evaluation. 
   To each variable is associated its 
   
   shape and 
   (partially evaluated) term.
*) 



(* type environments *)


let getFreeTyVars tyEnv =
  let theVars = ref emptyTyVarSet in 
  let doEntry _ tyScheme = 
    theVars := unionTyVarSet 
                 (freeVarsInTyScheme tyScheme) 
                 (!theVars)
  in 
    TyEnv.iter doEntry tyEnv;
    !theVars
;;
    

(* close a type in a type environment *)

let closTy ty tyEnv =
  let tyVars = getTyVarsInPhrase ty
  and freeTyVars = getFreeTyVars tyEnv
  in let boundTyVarSet = diffTyVarSet tyVars freeTyVars
  in 
  match boundTyVarSet with 
  | Allvars (s1,s2) -> 
      TyScheme (
      PhraseTyVarSet.elements s1, 
      ArrayTyVarSet.elements s2,
      ty)
;;


(* global environments *)

let global2type glEnv = 
  let f (x,(y,_,_)) tyEnv  = TyEnv.add x y tyEnv 
  in 
    fold_right f glEnv TyEnv.empty
;;

let global2shape glEnv = 
  let f (x,(_,y,z)) = (x,(y,z)) 
  in 
    map f glEnv
;;



@head(2,"fish_top.ml")
fish_top.ml.
@select(tangler("src/fish_top.ml"))
(* fish_top.ml -- load fish into O'Caml interpreter *)

(* generated from fish.m4 *)



#use "primitive_fish.ml";;
#load "primitive_fish.cmo";;

#use "types_fish.ml";;
#load "types_fish.cmo";;

#use "terms_fish.ml";;
#load "terms_fish.cmo";;

#use "sugar_fish.ml";;
#load "sugar_fish.cmo";;

#use "environments_fish.ml";;
#load "environments_fish.cmo";;

#use "type_subs_fish.ml";;
#load "type_subs_fish.cmo";;

#use "substitution_fish.ml";;
#load "substitution_fish.cmo";;

#use "pretty_fish.ml";;
#load "pretty_fish.cmo";;

#use "parse_fish.ml";;
#load "parse_fish.cmo";;

#use "lex_fish.ml";;
#load "lex_fish.cmo";;

#use "unify_fish.ml";;
#load "unify_fish.cmo";;

#use "infer_fish.ml";;
#load "infer_fish.cmo";;

#use "partial_ev_fish.ml";;
#load "partial_ev_fish.cmo";;

#use "turbot2C_fish.ml";;
#load "turbot2C_fish.cmo";;

#use "fish.ml";;
#load "fish.cmo";;


@head(2,"infer_fish.ml")
infer_fish.ml.
@select(tangler("src/infer_fish.ml"))
(* infer_fish.ml *)


open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Type_subs_fish
open Substitution_fish
open Pretty_fish
open Unify_fish

exception UnboundVariable of term_variable

(* type inference (algorithm W)
   given a term and type environment, 
   returns a type/type substitution pair *)


(* Coercions complicate shape computations: #(3:size) = 3 while
#(3:int) = int_shape. To resolve this, all terms will be explicitly
typed, and these types used during partial evaluation. *)

let rec coerced (term,ty0,tySub) ty1 = 
let (ty0',ty1') = (applyTySub tySub ty0,applyTySub tySub ty1) in 
let term2 = 
  match (ty0',ty1') with 
    _ when ty0' = ty1' -> term
  | ExpTy (ShT (StaticTy pty)), ExpTy (AT (DatumTy _)) -> 
      ap (Dyn pty) term
  | ExpTy (ShT (StaticTy pty)), ExpTy (ShT (HashArrayTy _)) -> 
      shape (ap (Dyn pty) term)
  | FunTy (ty00,ty01), FunTy(ty10,ty11) ->
      let x = nextvar() in 
      let (arg,ty2,_) = coerced (Tvar x,ty10,tySub) ty00 in 
      let (body, ty3, _) = coerced (ap term arg, ty01,tySub) ty11 in 
      lam x body
  | _ -> term (* shouldn't happen *)
in 
(term2, ty1',tySub) 
;;

let rec infer_with_tysub tyEnv term e tySub = 

let rec inf (term, e, tySub) = 

(* Find a type substitution tySub' and a coerced variant t' of t such
   that t' : tySub' e *)

  match term with 

   (* term variables *)

    | Tvar x -> 

        let x_ty_env = 
          try (inst_tyscheme (TyEnv.find (raw x) tyEnv))
          with Not_found -> raise (UnboundVariable x) in 
        let x_ty_dec = 
          try (declaredType x)
          with NoType ->  x_ty_env
        in
        let tySub2 = 
          unifyLoop([x_ty_env , x_ty_dec ; x_ty_dec , e ] , tySub) 
        in 
        coerced (coerced(Tvar x,x_ty_env,tySub2) x_ty_dec) e

        (* 
           The environment type is definitive.
           The declared type is coercive. 
        *)


    (* application *)

    | Apply (rator,rand) ->

        let tv1 = PhraseTV (next_phrase_tyvar()) in 
        let (rator2, _, tySub2) = inf (rator, funty tv1 e, tySub)  in  
        let (rand2,  _, tySub3) = inf (rand, tv1, tySub2)  
        in 
        (Apply (rator2,rand2), applyTySub tySub3 e , tySub3)

    (* functions *)

    | Lam (x,body) ->

        let tv1 = 
          try (declaredType x)
          with NoType -> PhraseTV (next_phrase_tyvar()) in 
        let tv2 = PhraseTV (next_phrase_tyvar()) in 
        let naturalTy = funty tv1 tv2 in 
        let tySub2 = unifyLoop ([ naturalTy, e ], tySub) in 
        let (body2,e2,tySub3) = 
          infer_with_tysub
           (TyEnv.add (raw x) (TyScheme ([],[],tv1)) tyEnv)
           body tv2 tySub2 in 
        coerced
          (Lam (x,body2),
           naturalTy,
           tySub3)
          e
        
    (* polymorphic binder *) 

    | Where (body,x,wTerm) ->
        let tv = PhraseTV (next_phrase_tyvar()) in 
        let (wTerm2,wTy,wTs) = inf (wTerm, tv, tySub) in 
        let wTyEnv = applyTySubToEnv wTs tyEnv in 
        let newTyEnv = TyEnv.add (raw x) (closTy wTy wTyEnv) wTyEnv in 
        let (body2,_,tySub2) = infer_with_tysub newTyEnv body e wTs in 
        (Where(body2,x,wTerm2),applyTySub tySub2 e,tySub2)

    (* constructors *)

    | Op(Prim_value v,[]) -> 
        let naturalTy = mk_static_ty (type_prim_value v) in 
        let tySub2 = unifyLoop([naturalTy,e] , tySub) in
         coerced (term, naturalTy, tySub2) e

    | Op(Pconst([pty0;pty2],b,name),[t]) ->   
        let tv0 = PhraseTV (next_phrase_tyvar()) in 
        let (t2,ty0,tySub2) = inf (t, tv0, tySub)
        and ty1 = ExpTy(AT(DatumTy pty2)) in

        let (naturalTy,us) = 
          if is_polymorphic name 
          then 
            try 
              match get_datum_ty ty0 with 
                FloatTy -> (if isShapeTy ty0 then cost else float),[]
              | _       -> (if isShapeTy ty0 then size else int),[]
            with _ -> ty1, [ ty0 , ty1 ] (* default is dynamic *)
        
          else 
            try 
              if get_datum_ty ty0 = pty0 
              then 
                if isShapeTy ty0 
                then (ExpTy (ShT (StaticTy pty2)) , [])
                else (ty1, [])
              else ty1, [ ty0 , ty1 ]  (* failure *)
               
            with _ -> (ty1, [ ty0 , ty1 ])
        in
        let tySub3 = unifyLoop ((naturalTy , e) :: us, tySub2)
        and newname = instantiate_polymorphic_op name pty0
        in 
        coerced 
          (Op(Pconst([pty0;pty2],b,newname),[t2]),
           naturalTy,
           tySub3) 
          e


    | Op(Pconst([pty0;pty1;pty2],_,name),[t0;t1]) ->
                                                    
        let tv0 = PhraseTV (next_phrase_tyvar())  
        and tv1 = PhraseTV (next_phrase_tyvar()) in 
        let (t2,ty0,tySub1) = inf (t0,tv0, tySub) in
        let (t3,ty1,tySub2) = inf (t1, tv1, tySub1) in 

        let (argTy,naturalTy) =
          if is_polymorphic name 
          then 
            let pty = 
              try get_datum_ty ty0 
              with _ -> 
              try get_datum_ty ty1 
              with _ -> IntTy (* default datum type *)
            in 
              match (pty2 = BoolTy, isShapeTy ty0 && isShapeTy ty1) with 
                (true,true)   -> mk_static_ty pty, fact
              | (true,false)  -> mk_datum_ty  pty, bool
              | (false,true)  -> mk_static_ty pty, mk_static_ty pty
              | (false,false) -> mk_datum_ty  pty, mk_datum_ty  pty    

          else
            if isShapeTy ty0 && isShapeTy ty1
            then (mk_static_ty pty0, mk_static_ty pty2)
            else (mk_datum_ty  pty0, mk_datum_ty  pty2)

        in 
        let tySub3 = 
          unifyLoop([ty0, argTy ; ty1, argTy ; naturalTy, e], tySub2) 
        and newname = instantiate_polymorphic_op name pty0 in 
        let d = Pconst([pty0;pty1;pty2],true,newname)
        in 
        let (t4,_,_) = coerced (t2,ty0,tySub3) argTy 
        and (t5,_,_) = coerced (t3,ty1,tySub3) argTy 
        in 
        coerced (Op(d,[t4;t5]), naturalTy, tySub3) e

    | Op (s,_) -> raise (Fish_error "unknown operation")

    | Get t1 -> 
       let tv1 = PhraseTV (next_phrase_tyvar()) 
       and tv2 = ArrayTV (next_array_tyvar ()) in 
       let (t2,e2,tySub2) = inf (t1, tv1, tySub) in 
         let (argTy,naturalTy) = 
           match e2 with 
           ExpTy _ -> (ExpTy (AT (ArrayTy tv2)), ExpTy (AT tv2))
         | VarTy _ -> (VarTy     (ArrayTy tv2) , VarTy     tv2)
         | _ -> raise (Fish_error "cannot resolve type of get")
         in 
         let tySub3 = unifyLoop ([ naturalTy, e], tySub2) in 
         let (t3,e3,tySub4) = inf (t2, argTy, tySub3) 
         in 
         coerced 
           (Get t3,
            naturalTy, 
            tySub4) 
           e

    | Sub (t1,t2) -> 
       let tv1 = PhraseTV (next_phrase_tyvar()) 
       and tv2 = ArrayTV (next_array_tyvar ()) in 
       let (t3,e2,tySub2) = inf (t1, tv1, tySub)  in 
         let naturalTy = 
           match e2 with 
           ExpTy _ -> ExpTy (AT (ArrayTy tv2))
         | VarTy _ -> VarTy     (ArrayTy tv2)
         | _ -> raise (Fish_error "cannot resolve type of get")
         in 
         let tySub3 = unifyLoop ([naturalTy, e], tySub2) in 
         let (t4,e3,tySub4) = inf (t1, naturalTy, tySub3) in
         let (t5,e4,tySub5) = inf (t2, int, tySub4) 
         in 
         coerced
           (Sub(t4,t5),
            naturalTy,
            tySub5)
           e

    | Condsh(t0,t1,t2) -> (

       (* this condsh may in fact be a datum conditional *)

        let tv0 = PhraseTV (next_phrase_tyvar())  
        and tv1 = PhraseTV (next_phrase_tyvar())  
        and tv2 = PhraseTV (next_phrase_tyvar()) 
        and tv3 = ExpTy (AT (ArrayTV (next_array_tyvar())))  
        in 
        let (t00,e0,tySub2) = inf (t0, tv0, tySub)  in 
        let (t3,e3, tySub3) = inf (t1, tv1, tySub2) in 
        let (t4,e4, tySub4) = inf (t2, tv2, tySub3) in 

        let ch,tySub5 =    (* ch is the choice of conditional form *)
          match e0,e3,e4 with 

            ExpTy(ShT (StaticTy BoolTy)),_,_  
          | _,FunTy _,_
          | _,_,FunTy _ -> 
              (condsh_term,
                try 
                  unifyLoop([ e0, fact ; tv1, tv2 ; tv2 , e ] , tySub4) 
                with _ -> (* reverse unification *)
                  unifyLoop([ e0, fact ; tv2, tv1 ; tv1 , e ] , tySub4) 
                    )
          | _ -> 
              try  
                (cond_term, unifyLoop([ e0, bool ;       
                             e3, CommTy ; 
                             e4, CommTy ; 
                             CommTy, e ] , tySub4))
              with _ -> 
                try 
                  (condexp_term,unifyLoop([ tv0, bool ;      
                               e3, e4 ; 
                               e4, tv3 ;
                               tv3, e ] , tySub4))
                with _ -> (* reverse unification *)

                  (condexp_term, 
                      unifyLoop([ tv0, bool ; 
                               e4, e3 ; 
                               e3, tv3 ;
                               tv3, e ] , tySub4))
        in 
        let (t5,_,_) = coerced(t3,e3,tySub5) e
        and (t6,_,_) = coerced(t4,e4,tySub5) e
        in 
        (ap3 ch t00 t5 t6,applyTySub tySub5 e,tySub5)
                  )


    | Typed (t1,ty) -> 
        let tySub2 = unifyLoop  ([ty,e], tySub) in 
        coerced (inf (t1, ty, tySub2)) e

        (* user declared  types are checked and discarded *)


    (* array expressions *) 

    | _ -> 
        let naturalTy = inst_tyscheme (combinator_tyscheme term) in 
        let tySub2 = unifyLoop([naturalTy,e],tySub)  in 
        coerced 
          (term, 
           naturalTy, 
           tySub2) 
          e
in inf (term, e, tySub);;


let rec infer tyEnv term = 
  let e = PhraseTV (next_phrase_tyvar()) in
  let (term2,ty,tysub) = infer_with_tysub tyEnv term e idTySub in 
  (applyTySubToTerm tysub term2,ty,tysub)
;;





@head(2,"partial_ev_fish.ml")
partial_ev_fish.ml.
@select(tangler("src/partial_ev_fish.ml"))

(* 
   Partial Evaluation of Fish terms
   ================================

This will follow the format of the language definition:

 - perform all beta reductions, 
 - eliminate all phrase polymorphic constants, especially #
 - reduce  all shape expressions to normal form
 - eliminate civilised expression constants, i.e. newexp 

The intermediate terms vtc and vte have been treated as auxiliary
functions.

The problem of distinguishing static from dynamic data means that
there are two forms of partial evaluation. Where sizes appear in types
(of primrec and succdim) then the value of "static" is true. For the
other constants "static" = false. Functions are not affected by the
value of static and so it is left unchanged. Function arguments cannot
be evaluated until their context is known, so evaluation is by
name. This could be changed to greedy at a later date.

*)


open List

open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Substitution_fish
open Pretty_fish
open Parse_fish


(* 
   auxiliary functions for handling non-primitive indices,
   e.g. newexp. is_nasty extracts the indices from an array variable,
   which are then checked by is_civil, which is true if there is a
   newexp or conditional within.  If so, then vtc or vte is invoked,
   to move these blocks to the outside.  
*)

let rec is_civil t = 
  match t with 
    Op(_,ts) -> exists is_civil ts 
  | Get t1 -> is_civil t1 
  | Sub(t1,t2) -> is_civil t1 || is_civil t2
  | Cond _  
  | Condexp _  
  | Typed _   
  | Apply(Apply(Newexp,_),_) -> true (* first and third shouldn't happen *)
  | _ -> false
;;

let rec is_nasty t = (* looking for complex indices in a pe array variable *)
  match t with 
    Get t1 -> is_nasty t1
  | Sub(t1,t2) -> is_nasty t1 || is_civil t2
  | Typed(t1,_) -> is_nasty t1  (* shouldn't happen *)
  | _ -> false
;;



let rec vtc term1 term2 = 
  match term2 with

    Get t -> 
      let x = nextvar() in 
      vtc (lam x (ap term1 (Get (Tvar x)))) t

  | Sub(t,i) when is_civil i -> 
      let x = nextvar() 
      and j = nextvar() in 
      vtc (lam x (
             newvar (Bang IntTy) (lam j (
             seq (assign (Tvar j) i)
                 (ap term1 (Sub(Tvar x,Tvar j))))))) t
      
  | Sub(t,i)  -> 
      let x = nextvar() in 
      vtc (lam x (ap term1 (Sub(Tvar x,i)))) t

  |  _ -> 
      ap term1 term2
;;

let rec vte term1 term2 = 
  match term2 with

    Get t -> 
      let x = nextvar() in 
      vte (lam x (ap term1 (Get (Tvar x)))) t

  | Sub(t,i) when is_civil i -> 
      let x = nextvar() 
      and y = nextvar()  
      and j = nextvar() in 
      vte (lam x (
             newexp (preddim (shape t)) (lam y (
               newvar (Bang IntTy) (lam j (
                 seq (assign (Tvar j) i)
                     (assign (Tvar y) (ap term1 (Sub(Tvar x,Tvar j)))))))))) t

  | Sub(t,i) -> 
      let x = nextvar() 
      and y = nextvar() in 
      vte (lam x (
             newexp (preddim (shape t)) (lam y (
               newvar (Bang IntTy) 
                     (assign (Tvar y) (ap term1 (Sub(Tvar x,i)))))))) t

  | _ -> 
      ap term1 term2
;;


(*
        Partial Evaluator
        =================

mutual recurson of 

some auxillary functions for evaluating blocks
a general partial evaluator, pe  
one for applications, peap 
one for shapes, pesh
one for shaping under lambdas, propagate_shape

*)


let rec part_ev modes shEnv  = 

let rec pe term =
  match term with 

  | Tvar x -> (try let (_,exp) = assoc x shEnv in exp (* a value *)
               with Not_found -> term )      (* when evaluating the body *)

  | Apply(x,y) -> (
      let x1 = pe x in 
      match x1 with 
        Lam(z,t) ->                      (* if a lambda *)
          let y1 = (
            try pe y                     (* evaluate y *)
            with Shape_error _ -> y)     (* unless error *)
          in pe (substitute z y1 t)      (* and reduce *)
      |        _ -> peap x1 (pe y)              (* otherwise peap 
                                            peap takes values as args *)
            )

(* 
  | Lam(x,t) 
  | Op(dconst,[]) are handled by default 
*)

  | Where(x,y,z) -> 
      let z1 = (
        try pe z 
        with Shape_error _ -> z)
      in 
      pe (substitute y z1 x)


  (* some expression reductions here - the rest are in peap *)

  | Op (Pconst([pty0;pty],_,_) as dconst, [x]) -> 
      let x1 = pe x in 
          (match x1 with 

            Apply(Apply(Newexp,sh),f) -> 
              let y = nextvar() in 
              let g = lam y (Op(dconst,[Tvar y])) in
              if    pty0 = pty 
                 && List.assoc "datum_opt" modes = Util_fish.Show_on
              then addExp  sh            f g  
              else addTwo  (Bang pty) sh f g
                
          | Cond(t0,t1,t2) -> Cond(t0,
                                   pe (Op(dconst,[t1])), 
                                   pe (Op(dconst,[t2])))

          | Condexp(t0,t1,t2) -> Condexp(t0,
                                   pe (Op(dconst,[t1])), 
                                   pe (Op(dconst,[t2])))

          | Op(Prim_value v,[]) ->         (* optimisation *)
                Op(Prim_value (apply_delta dconst [v]),[])

          | Apply(Dyn pty,x2) -> ap (Dyn pty) (pe (Op(dconst,[x2])))

          | _ when is_nasty x1 -> 
              let x = nextvar() in 
              pe (vte (lam x (Op(dconst,[Tvar x]))) x1)
 
          | _ -> Op (dconst, [x1]) 
          )

  | Op (Pconst([pty0;pty1;pty],_,_) as dconst, [x;y]) -> 
      let x1 = pe x
      and y1 = pe y in 
          (match (x1,y1) with 

            Apply(Apply(Newexp,sh),f), _ -> 
              let x2 = nextvar() in 
              let g = lam x2 (Op(dconst,[Tvar x2;y1])) in 
              if pty0 = pty && List.assoc "datum_opt" modes = Util_fish.Show_on
              then addExp  sh            f g  
              else addTwo  (Bang pty) sh f g

          | Cond(t0,t1,t2), _ -> Cond(t0, 
                                      pe (Op(dconst,[t1;y1])),
                                      pe (Op(dconst,[t2;y1])))

          | Condexp(t0,t1,t2), _ -> Condexp(t0, 
                                      pe (Op(dconst,[t1;y1])),
                                      pe (Op(dconst,[t2;y1])))

          | Apply(Dyn _,x2),  Apply(Dyn _,y2) -> 
              let pty = return_type_prim_constant dconst in 
              ap (Dyn pty) (pe (Op(dconst,[x2;y2])))

          | Apply(Dyn _,x2), _ -> 
              let pty = return_type_prim_constant dconst in 
              ap (Dyn pty) (pe (Op(dconst,[x2;y1])))

          | _ when is_nasty x1 ->
              let u = nextvar() in 
              pe (vte (lam u (Op(dconst,[Tvar u;y1]))) x1)

          | _, Apply(Apply(Newexp,sh),f) -> 
                let y2 = nextvar() in 
                let g = lam y2 (Op(dconst,[x1;Tvar y2])) in 
                if pty0 = pty && List.assoc "datum_opt" modes = Util_fish.Show_on
                then addExp  sh            f g  
                else addTwo  (Bang pty) sh f g

          | _, Cond(t0,t1,t2) -> Cond(t0, 
                                      pe (Op(dconst,[x1;t1])),
                                      pe (Op(dconst,[x1;t2])))

          | _, Condexp(t0,t1,t2) -> Condexp(t0, 
                                      pe (Op(dconst,[x1;t1])),
                                      pe (Op(dconst,[x1;t2])))

          | _, Apply(Dyn pty,y2) -> 
              let pty = return_type_prim_constant dconst in 
              ap (Dyn pty) (pe (Op(dconst,[x1;y2])))

          | _ when is_nasty y1 ->
              let u = nextvar() in 
              pe (vte (lam u (Op(dconst,[x1;Tvar u]))) y1)

          | Op(Prim_value v1,[]), Op(Prim_value v2,[]) -> 
                                                  (* optimisation *)
              Op(Prim_value (apply_delta dconst [v1;v2]),[])

          | _,_ -> Op (dconst,[x1;y1])
          )

  | Op (_,_::_) -> raise (Fish_error "invalid primitive application")

  | Get term2 ->  
      let term3 = pe term2 in 
      (match term3 with 
        
      | Apply(Apply(Newexp, sh), f) -> 
          addTwo  (pe (undim sh)) sh 
            f 
            (get_term())

      | Condexp(t0,t1,t2) ->
          Condexp(t0, pe (Get t1), pe (Get t2))

      | _ -> Get term3
      )

  | Sub (t1,t2) ->          
      let t3 = pe t1
      and t4 = pe t2 in 

      (match t3 with 

      | Apply(Apply(Newexp, sh), f)   -> 
                  let x = nextvar() in 
                  addTwo  (pe (preddim sh)) sh 
                    f 
                    (lam x (Sub (Tvar x,t4)))
  
      |        Condexp(s0,s1,s2) -> Condexp(s0, 
                                    pe (Sub(s1,t4)), 
                                    pe (Sub(s2,t4)))

            (* cannot do subexp t0 (newexp sh f) here as it may be a sub. 
               Mix this with the vtc cases below *)

      |        _ -> Sub (t3,t4) 
      )

  | Condsh(x,y,z) -> (
      let x1 = pe x in 
      match x1 with 
        
      |        Op (Prim_value (Bool true) ,[]) -> pe y  
      |        Op (Prim_value (Bool false),[]) when z = Error -> 
          raise (Shape_error ([x],"became false in check"))
      |        Op (Prim_value (Bool false),[]) -> pe z
      |        _ -> Condsh(x1, (try pe y with _ -> Error),try pe z with _ -> Error) 
          )

  | Cond(x,y,z) -> 
      let x1 = pe x
      and y1 = pe y
      and z1 = pe z in 
      let y2 = pesh y1
      and z2 = pesh z1 in 
          if not (pe (equal y2 z2) = 
                Op (Prim_value (Bool true),[]))
          then raise (
            Shape_error ([y2 ; z2 ], 
                 "are different shapes for branches of a datum conditional"))
          else 
            (match (x1,y1,z1) with 
        
            | Apply(Dyn _,Op (Prim_value (Bool true) ,[])),_,_ -> y1  
            | Apply(Dyn _,Op (Prim_value (Bool false),[])),_,_ -> z1
    
             (* an optimisation for data conditionals *)

            | Apply(Apply(Newexp,sh),f),_,_ -> 
                let u = nextvar() in 
                addVar sh f (lam u (Cond(Tvar u, y1, z1)))

            |        Condexp(b,s1,s2),_,_ -> 
                Cond(b, 
                       pe(Cond(s1,y1,z1)), 
                       pe(Cond(s2,y1,z1)))

            | _ when is_nasty x1 ->
                let u = nextvar() in 
                pe (vtc (lam u (Cond(Tvar u,y1,z1))) x1)

            | _,Apply(Apply(Newexp,sh),f),_ -> 
                let u = nextvar() in 
                bodyEval (ap Newvar sh) sh 
                  (pe (lam u (Cond(x1,ap f (Tvar u),z1))))

            | _ when is_nasty y1 ->
                let u = nextvar() in 
                pe (vtc (lam u (Cond(x1,Tvar u,z1))) y1)

            | _,_,Apply(Apply(Newexp,sh),f) -> 
                let u = nextvar() in 
                bodyEval (ap Newvar sh) sh 
                  (pe (lam u (Cond(x1,y1,ap f (Tvar u)))))

            | _ when is_nasty z1 ->
                let u = nextvar() in 
                pe (vtc (lam u (Cond(x1,y1,Tvar u))) z1)


            | _ -> Cond(x1,y1,z1) 
                  )

  | Condexp(x,y,z) -> 
      let x1 = pe x
      and y1 = pe y
      and z1 = pe z in 
      let ysh = pesh y1
      and zsh = pesh z1 in 
          if not (pe (equal ysh zsh) = 
                Op (Prim_value (Bool true),[]))
          then raise (
            Shape_error ([ysh ; zsh ], 
                 "are different shapes for branches of a datum conditional"))
          else 
            (match (x1,y1,z1) with 
        
            | Apply(Dyn _,Op (Prim_value (Bool true) ,[])),_,_ -> y1  
            | Apply(Dyn _,Op (Prim_value (Bool false),[])),_,_ -> z1
    
             (* an optimisation for data conditionals *)

            | Apply(Apply(Newexp,sh),f),_,_ -> 
                let u = nextvar() in 
                addTwo ysh sh f (lam u (Condexp(Tvar u, y1, z1)))

            |        Condexp(b,s1,s2),_,_ -> 
                Condexp(b, 
                       pe(Condexp(s1,y1,z1)), 
                       pe(Condexp(s2,y1,z1)))

            | _ when is_nasty x1 ->
                let u = nextvar() in 
                pe (vte (lam u (Condexp(Tvar u,y1,z1))) x1)

            | _,Apply(Apply(Newexp,sh),f),_ -> 
                let u = nextvar() in 
                addExp sh f (lam u 
                             (Cond(x1,
                                     ap f (Tvar u),   
                                     assign (Tvar u) z1)))

            | _ when is_nasty y1 ->
                let u = nextvar() in 
                pe (vte (lam u (Condexp(x1,Tvar u,z1))) y1)

            | _,_,Apply(Apply(Newexp,sh),f) -> 
                let u = nextvar() in 
                addExp sh f (lam u 
                             (Cond(x1,
                                   assign (Tvar u) y1,
                                   ap f (Tvar u) 
                                     )))

            | _ when is_nasty z1 ->
                let u = nextvar() in 
                pe (vte (lam u (Condexp(x1,y1,Tvar u))) z1)


            | _ -> Condexp(x1,y1,z1) 
                  )

  | Typed(t,ty) -> pe t (* shouldn't happen *)

  | Error -> raise (Shape_error ([Error],"appears explicitly"))

  | _ -> term               (* lambda's and constants are values *)


     (* Application Evaluation *)


and peap term1 term2 =       (* term1 and term2 are values *)

  match term1 with 

    (* beta reduction *)

  | Lam(x,term3) -> pe (substitute x term2 term3)

    (* commands *)

  | Apply(Assign,term3) when is_nasty term3 ->
      let x = nextvar() in 
      pe (vtc (lam x (assign (Tvar x) term2)) term3)

  | Apply(Assign,term3) -> (
      match term2 with  

      |        Apply(Apply(Newexp,sh),f) ->
          if List.assoc "assign_opt" modes = Util_fish.Show_on
              &&
            let vars3 = free_vars term3
            and vars2 = free_vars term2 in 
            let g y =  mem y vars2 
            in 
            not (exists g vars3) 
          then 
            pe (check (equal (shape term3) sh) 
                             (ap f term3)
                     )
          else addVar sh f term1
                     
      | Condexp(t0,t1,t2) ->  
          Condexp(t0, peap term1 t1, peap term1 t2)

      | _ when is_nasty term2 -> 
          let x = nextvar() in 
          pe (vte (lam x (ap term1 (Tvar x))) term2)
      | _ -> ap term1 term2
        )

  | Forall -> (
      match term2 with  
        Apply(Apply(Newexp, sh), f) ->  
          let x = nextvar() 
          and y = nextvar() 
          and z = nextvar() in
          lam y (lam z (newvar sh (lam x (
                        seq 
                          (ap f (Tvar x)) 
                          (forall (Tvar x) (Tvar y) (Tvar z))
                          ))))
                        
      | Condexp(b,t0,t1) -> 
           let y = nextvar() 
          and z = nextvar() in
          lam y (lam z (Cond(b, 
               forall t0 (Tvar y) (Tvar z),
               forall t1 (Tvar y) (Tvar z))))

      | _ when is_nasty term2 ->
          let x = nextvar() 
          and y = nextvar() 
          and z = nextvar() in 
          (lam y (lam z (
           vte (lam x (forall (Tvar x) (Tvar y) (Tvar z))) term2)))
      | _ -> ap term1 term2
            )

  | Apply(Forall,x) -> (
      match term2 with  
        Apply(Apply(Newexp, sh), f) ->  
          let y = nextvar() 
          and z = nextvar() in
          lam z (newvar sh (lam y (
                            seq (ap f (Tvar y))
                              (forall x (Tvar y) (Tvar z))
                          )))
                        
      | Condexp(b,t0,t1) -> 
          let z = nextvar() in 
          lam z (Cond(b,
                      forall x t0 (Tvar z),
                      forall x t1 (Tvar z)))          

      | _ when is_nasty term2 ->
          let y = nextvar() 
          and z = nextvar() in 
          lam z (
           vte (lam y (forall x (Tvar y) (Tvar z))) term2)
      | _ -> ap term1 term2
            )

  | Apply(Apply(Forall,_),_) -> 
      let term3 = bodyEval term1 (Bang IntTy) term2 in 
      if List.assoc "loop_opt" modes = Util_fish.Show_on
      then 
        match term3 with 
          Apply(Apply(Apply(Forall,_),_),Lam(i,Apply(Apply(Newvar,sh),f))) ->
            let y = nextvar() in
            pe (newvar sh (lam y (ap term1 (lam i (ap f (Tvar y))))))
(*
            bodyEval (ap Newvar sh) sh 
              (lam y (ap term1 (lam i (ap f (Tvar y)))))
*)
        | _ -> term3
      else term3

  | Whiletrue -> (
      match term2 with  

        Apply(Dyn _,Op(Prim_value (Bool true),[])) -> 
          raise (Shape_error ([],"infinite while loop"))

      | Apply(Dyn _,Op(Prim_value (Bool false),[])) -> 
          let z = nextvar() in 
          lam z Skip

      | Apply(Apply(Newexp, sh), f) -> 
                 let x = nextvar() 
          and z = nextvar() in
          lam z (newvar sh (
                 lam x (seq 
                          (ap f (Tvar x))
                          (whiletrue (Tvar x) 
                             (seq (Tvar z) (ap f (Tvar x)))
                          ))))

      | Condexp(t0,t1,t2) ->
          let mix = pe (
            Op(prim_or,
              [ Op(prim_and, [t0;t1]) ;
                Op(prim_and, [
                  Op(prim_not,[t0]) ; 
                   t2
                ]) 
              ]        
            ))
          in ap Whiletrue mix

      | _ when is_nasty term2 ->
          let x = nextvar() 
          and y = nextvar() in 
          lam y (vte (lam x (whiletrue (Tvar x) (Tvar y))) term2)
      | _ -> ap term1 term2
            )
        
  | Apply(Whiletrue,x) -> (
      match term2 with 
        Apply(Apply(Newvar,sh),f) 
          when List.assoc "loop_opt" modes = Util_fish.Show_on -> 
            let y = nextvar() in
            bodyEval (ap Newvar sh) sh  
              (lam y (ap term1 (ap f (Tvar y))))
 
      | _ -> ap term1 term2
              )

  | Fix 0 ->            (* !! k>0 ?? *)                             
      bodyEval term1 (Op(Prim_value (Bool true),[])) 
        (pe term2)

  | Apply(Newvar,sh) ->         
      bodyEval term1 sh (pe term2)

  | Output -> (
      match term2 with 
        Apply(Apply(Newexp,sh),f) ->
          addVar sh f term1
                
      | Condexp(t0,t1,t2) ->
          Cond(t0, peap term1 t1, peap term1 t2)
      | _ -> ap term1 term2
    )

    (* array expressions *)

  | Apply(Newexp,sh) ->         
      bodyEval term1 sh (pe term2)


     (* shape expressions *)

  | Undim -> (
      match term2 with 
        Apply(Zerodim,x) -> x
      | Apply(Apply(Succdim,_),_) -> 
          raise (Shape_error ([term2],"cannot have undim applied"))
      | _ -> ap term1 term2
            )

  | Lendim -> (
      match term2 with  
        Apply(Zerodim,x) -> 
          raise (Shape_error ([term2],"cannot have lendim applied"))
      | Apply(Apply(Succdim,x),y) -> x
      | _ -> ap term1 term2
            )

  | Preddim -> (
      match term2 with  
        Apply(Zerodim,x) -> 
          raise (Shape_error ([term2],"cannot have preddim applied"))
      | Apply(Apply(Succdim,x),y) -> y
      | _ -> ap term1 term2
            )

  | Numdim -> (
      match term2 with  
        Apply(Zerodim,x) -> Op(prim_zero,[])
      | Apply(Apply(Succdim,x),y) -> 
          pe (Op(prim_int_plus,
                      [numdim y; 
                       Op(prim_one,[])
                      ]
                        ))
      | _ -> ap term1 term2
            )

  | Apply(Equal,x) -> (
      match (x, term2) with 

      | Bang _ , Bang _  
      |        Op _, Op _ -> Op(prim_true,[])   

         (* The only cases expected are equal Bang's or equal true's
            bodyEval (ap Newvar sh) sh  (for command shapes).
            It might be worth tighteing this up, just to be sure. *)

      | Apply(Zerodim,t0), Apply(Zerodim,t1) -> 
          pe (equal t0 t1)

      | Apply(Apply(Succdim,s0),t0), 
          Apply(Apply(Succdim,s1),t1) ->
            if pe (Op(prim_int_equal,[s0;s1])) = Op(prim_true,[])
            then pe (equal t0 t1)
             else Op(prim_false,[])    

      | _,_ -> ap term1 term2
            )

    (* polymorphic constants *)

  | Apply(Apply(Primrec,f),x) -> (
      match term2 with
        Op(Prim_value (Int n),_) when n>0 -> 
          let n' = Op(Prim_value (Int (n-1)),[]) in 
          pe (ap2 f n' (primrec f x n') )

      | Op(Prim_value (Int 0),_)  -> x

      |        Op(Prim_value (Int n),_) when n<0 -> 
          raise (Shape_error 
                   ([term2],
                    "is a negative iterator for primrec"))
      | _ -> ap term1 term2 
            )

  | Shape -> pesh term2                 



        
        (* index reductions *)

        (* these have been embedded within the cases above, to
           maintain a one-pass approach. The use of vtc is flagged by
           assign. The absence of var2exp means that coercion must be
           detected by the later use of the term, in an assignment,
           conditional (any position), for-loop (twice), while-loop or
           op. *)


  | _ -> ap term1 term2



     (* end peap *) 


(* 
        Shape Reduction 
        ===============

*)

and pesh term = (  (* term is a value *) 

  match term with 
  
  | Tvar x -> (try let (sh,_) = assoc x shEnv in sh 
               with Not_found -> shape term ) (* should not happen  *)

  | Apply(Dyn pty,t2) -> 
      let t3 = pesh t2 in             (* look for shape errors - 
                                         if not exceptions then ... *)  
      Bang pty

  | Apply(t1,t2) -> peap (pesh t1) (pesh t2) 
        
  | Lam(_,_) -> propagate_shape [] term

  | Op(_,[]) -> term                  (* assume static *)

  | Op(d,ts) ->                       (* must be dynamic *)
      let ts' = map pesh ts in        (* look for shape errors - 
                                         if not exceptions then ... *)  
      Bang (return_type_prim_constant d)  
        
  | Get x -> peap Undim (pesh x) 
             
  | Sub (t1,t2) -> 
      pe (check (wf (pesh t2))
                      (ap Preddim (pesh t1)))

  | Cond(t0,t1,t2) ->
      pe (
      check (wf (pesh t0)) (
      check (equal (pesh t1) (pesh t2))
        (pesh t1))
      )

  | Condexp(t0,t1,t2) ->
      pe (
      check (wf (pesh t0)) (
      check (equal (pesh t1) (pesh t2))
        (pesh t1))
      )

  | Skip 
  | Abort -> Op(prim_true,[])
        
  | Assign -> Equal

  | Seq -> 
      let x = nextvar() 
      and y = nextvar() in  
      lam x (lam y (Op(prim_int_equal,[Tvar x;Tvar y])))
        
  | Forall -> 
      let x = nextvar() 
      and y = nextvar() 
      and z = nextvar() in
      lam x (lam y (lam z
        (check (equal (Tvar x) (Tvar y))
               (ap (Tvar z) (Bang IntTy)) )))

  | Whiletrue -> 
      let x = nextvar() 
      and y = nextvar() in 
      lam x (lam y (
             check (wf (Tvar x)) (Tvar y) ))
        
  | Fix k ->                

      let rec f n = 
        (match n with 
          _ when n<0 -> raise (Fish_error "negative argument to fix")
        | 0 -> Op(prim_true,[])
        | _ -> lam (nextvar()) (f (n-1)))
      in 
      let x = nextvar() in 
      lam x (ap (Tvar x) (f k))
        
  | Newvar -> 
      let x = nextvar() 
      and y = nextvar() in 
      lam x (lam y (ap (Tvar y) (Tvar x) ))

  | Output ->
      let x = nextvar() in
      lam x (check (wf (Tvar x))
               (Op(prim_true,[])) )

  | Newexp -> 
      let x = nextvar() 
      and y = nextvar() in 
      lam x (lam y 
             (check (ap (Tvar y) (Tvar x)) (Tvar x) ))

  | Succdim -> 
      let x = nextvar() in 
      lam x (check (is_length (Tvar x))
               (ap Succdim (Tvar x)))

  | Primrec -> 
      let f = nextvar() 
      and x = nextvar() 
      and n = nextvar() in 
      lam f (lam x (lam n
                      (check (is_length (Tvar n))
                         (primrec (Tvar f) (Tvar x) (Tvar n) ))))

   | Shape -> identity

  | _ -> term )

                  
     (* end pesh *)

and propagate_shape vars = 

      (* This performs a strictly limited partial evaluation under the
         lambda (propagates shape analysis). Full partial evaluation
         under the lambda does not work because of missing type
         information (unresolved shape conditionals are treated as
         datum conditionals, and lead to spurious errors). Earlier
         versions used a null term as placemarker, but null is an
         "empty" concept for function types and is better out of the
         language.

         Bound variables (in vars) are left alone, 
         but their types have changed! 
         Other variables are free, and so mapped to their shapes. *)

let rec psh t = 

  (match t with
    
    Tvar x when mem x vars -> t 
  | Tvar x -> shape t 
  | Apply(Dyn pty,t2) -> shape (ap (Dyn pty) (psh t2)) 
                               (* nb psh t2 may be of static type! *)
  | Apply(t1,t2) -> Apply(psh t1, psh t2)
  | Lam(x,t0) -> lam x (propagate_shape (x::vars) t0)  
  | Where(t2,x,t1) -> Where(propagate_shape (x::vars) t2,x,psh t1)
  | Op(d,ts) -> shape (Op(d,List.map psh ts)) (* apply d to int_shape, etc? *)
  | Get t0 -> Apply(Undim, (psh t0))
  | Sub(t1,t2) -> check (wf (psh t2)) 
                        (preddim (psh t1))
  | Condsh(t0,t1,t2) -> Condsh(psh t0, psh t1,psh t2)
  | Cond(t0,t1,t2) -> 
      check (wf (psh t0)) (
      check (equal (psh t1) 
                   (psh t2)) 
        (psh t1))
  | Condexp(t0,t1,t2) -> 
      check (wf (psh t0)) (
      check (equal (psh t1) 
                   (psh t2)) 
        (psh t1))
  |  _ -> shape t
        )
        
in psh  

  (* auxilliary functions for handling blocks. 

     Shape information about local variables must be added to the
     shape environment before partial evaluation *)

and bodyEval outer sh f  =    (* outer must be a constructor *)
    let x = nextvar() in 
    let shEnv' = (x,(sh,Tvar x))::shEnv in       (* #x = sh *)
    let body = 
      part_ev modes shEnv'   
        (ap f (Tvar x)) in                       (* pe f x *)
    ap outer (lam x body)

and bodyEval2 outer sh f g = 
    let x = nextvar() in
    bodyEval outer sh 
      (lam x (seq (ap f (Tvar x)) 
                  (ap g (Tvar x))                (* pe (f x; g x) *)
      ))

and addVar sh f g = bodyEval2 (ap Newvar sh) sh f g

and addExp sh f g = 
  let x = nextvar() in
  let g2 = lam x (assign (Tvar x) (ap g (Tvar x))) in 
  bodyEval2 (ap Newexp sh) sh f g2

and addTwo sh sh' f g =                 (* now two variables *)
    let z = nextvar()     
    and x = nextvar() in 
    let shEnv' = 
      (x,(sh',Tvar x))::
      (z,(sh,Tvar z)):: shEnv in   
    let body =                      
      part_ev modes shEnv' 
        (seq (ap f (Tvar x)) 
           (assign (Tvar z) (ap g (Tvar x)))    (* pe (f x; z := g x) *)
    )
    in       
    newexp sh (lam z (                                (* #z = sh  *)
    newvar sh'(lam x body)))                    (* #x = sh' *)

in pe 
;;

(* end *)


@head(2,"pretty_fish.ml")
pretty_fish.ml.
@select(tangler("src/pretty_fish.ml"))
(* pretty_fish.ml *)

open Format
open List
open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Type_subs_fish
open Substitution_fish 


(* formatting - for pretty_fish.ml *)

let ps = Format.print_string
;;

let lpn() = 
   ps "("
;;

let rpn() = 
   ps ")"
;;

(* how many spaces to indent if line break *) 

let termIndent = 2
;;

let tyIndent = 2
;;

(* primitives *)

let format_prim_type ty = ps (string_of_prim_type ty) ;;

let format_static_prim_type ty = ps (string_of_static_prim_type ty) ;; 

let format_prim_constant c =
  match c with
    Prim_value v -> ps (string_of_prim_value v)
  | Pconst (_,_,s) -> ps s
;;

(* type vars *)

let formatArrayTyVar ty = 
  match ty with 
  | ArrayTyVar n-> ps ("a_ty_" ^ (string_of_int n))
  | UserATV x -> ps ("a_ty_" ^ x)
;;

let formatPhraseTyVar ty = 
  match ty with 
  | PhraseTyVar n-> ps ("ph_ty_" ^ (string_of_int n))
  | UserPTV x -> ps ("ph_ty_" ^ x)
;;


(* types *)

let prec_funty = 1;; 

(* 
   format_tidy... formats to produce tidy types.
   format_untidy... formats to produce untidy types  
   (when reporting type errors).

   tidy formatting of array and phrase variables are handled within a
   single function. The code for format_tidy_array is local to
   format_phrase 

   precedences are used to decide about parenthetisation.
*)

let rec format_untidy_array_type ty =

  match ty with

    ArrayTV x -> 
      formatArrayTyVar x;

  | DatumTy ty' -> format_prim_type ty'

  | ArrayTy ty' ->
      ps "[";
      open_box tyIndent;
      format_untidy_array_type ty';
      close_box();
      ps "]"
;;

let format_phrase_type tidy ty = 
  let alpha_counter = ref ""
  and theta_counter = ref ""
  and array_string_tbl = ref []
  and phrase_string_tbl = ref []
  in 
  let next_array_string()  = 
    alpha_counter := incrStringCounter !alpha_counter 'a' 'e';
    !alpha_counter
  and next_phrase_string() = 
    theta_counter := incrStringCounter !theta_counter 'x' 'z';
    !theta_counter
  in

  let format_tidy_tyvar x tbl new_fun =
    let s = 
      try assoc x !tbl
      with Not_found ->
        let s' = new_fun()
        in
        tbl := (x,s') :: !tbl;
        s'
    in

    ps s
  in

  let rec format_array_type ty =

    match ty with

      ArrayTV x -> 
        if tidy then
          format_tidy_tyvar x array_string_tbl next_array_string
        else
          formatArrayTyVar x;

    | DatumTy ty' -> format_prim_type ty'

    | ArrayTy ty' ->
        ps "[";
        open_box tyIndent;
        format_array_type ty';
        close_box();
        ps "]"

  and format_data_type do_ty =
    match do_ty with 
      AT ty' -> format_array_type ty'
    | ShT ty' -> format_shape_type ty'

  and format_shape_type do_ty = 
    match do_ty with 
    | StaticTy ty' -> format_static_prim_type ty'
    | HashArrayTy ty' ->
        ps "#";
        format_array_type ty'

  and ftphty do_ty left_prec right_prec =

    match do_ty with 
          
      PhraseTV x -> 
        if tidy then
          format_tidy_tyvar x phrase_string_tbl next_phrase_string
        else
          formatPhraseTyVar x

    | HashPhraseTy x ->
        ps "#";
        if tidy then 
          format_tidy_tyvar x phrase_string_tbl next_phrase_string
        else
          formatPhraseTyVar x

    | CommTy ->
        open_box tyIndent;
        ps "comm";
        close_box()
          
    | VarTy ty' ->
        ps "var ";
        open_box tyIndent;
        format_array_type ty' ;
        close_box()
          
    | ExpTy ty' ->
        open_box tyIndent;
        format_data_type ty'; 
        close_box()
          
    | FunTy (ty1,ty2) ->
        let needsParens = 
          prec_funty < left_prec 
                (* never happens currently, 
                   as FunTy is right-associative *)
            or prec_funty <= right_prec
                (* if there is, say, a FunTy to the right *)
        in
        open_box tyIndent;      
        if needsParens 
        then (
          lpn();
          ftphty ty1 0 prec_funty
            )
        else (
          ftphty ty1 left_prec prec_funty
            );
        print_space();
        ps "->";
        print_space();
        if needsParens 
        then (
          ftphty ty2 prec_funty 0;
          rpn()
          )
        else (
          ftphty ty2 prec_funty right_prec
            );
        close_box()

  in

  ftphty ty 0 0;
  print_flush()
;;

let format_tidy_phrase_type =
  format_phrase_type true
;;

let format_untidy_phrase_type =
  format_phrase_type false
;;

let format_type_scheme ty = 
  Format.open_hovbox tyIndent;
  format_tidy_phrase_type (inst_tyscheme ty) ;
  Format.close_box();

;;

let formatPrimTypeError s pty1 pty2 =

  let form_in_box pty = 
    Format.open_box tyIndent;
    format_prim_type pty;
    Format.close_box()
  in

  Format.open_box 0;
  ps s;
  Format.print_space();
  form_in_box pty1;
  ps " and ";
  form_in_box pty2;
  Format.close_box();
  Format.print_newline()
;;

let formatArrayTypeError s ty1 ty2 =

  let form_in_box ty = 
    Format.open_box tyIndent;
    format_untidy_array_type ty;
    Format.close_box()
  in

  Format.open_box 0;
  ps s;
  Format.print_space();
  form_in_box ty1;
  ps " and ";
  form_in_box ty2;
  Format.close_box();
  Format.print_newline()
;;

let formatPhraseTypeError s ty1 ty2 =

  let form_in_box ty = 
    Format.open_box tyIndent;
    format_untidy_phrase_type ty;
    Format.close_box()
  in

  Format.open_box 0;
  ps s;
  Format.print_space();
  form_in_box ty1;
  ps " and ";
  form_in_box ty2;
  Format.close_box();
  Format.print_newline()
;;

let formatInvalidRunType ty =
      Format.open_box 0;
      ps "Invalid run type:";
      Format.print_space();
      Format.open_box tyIndent;
      format_tidy_phrase_type ty;
      Format.close_box();
      Format.close_box();
      Format.print_newline()
;;



(* terms *)

(* precedences *)

let prec_fun =    1
let prec_cond =   1   (* conditionals extend as far to the right as possible, 
>                     like functions *) 
let prec_where =  2
let prec_app =    10

let prec_equal = 2
let prec_get = 2
let prec_sub = 2 
let prec_type = 2

let prec_op c = 
  match c with 
    Pconst ([ty],_,_) -> 7
  | Pconst(_,_,s) -> 
      (match s with 
          | "mod" 
          | "="
          | "<"
          | "<="
          | ">"
          | ">=" 
          | "<."
          | "<=."
          | ">."
          | ">=." 
          | "not"   -> 6

          | "+" 
          | "-" 
          | "+." 
          | "-." 
          | "||" 
          | "acos"
          | "asin"
          | "atan"
          | "atan2"
          | "ceil"
          | "cos"
          | "cosh"
          | "exp"
          | "fabs"
          | "floor"
          | "fmod"
          | "int2float"
          | "log"
          | "log10"
          | "pow"
          | "sin"
          | "sinh"
          | "sqrt"
          | "tan"
          | "tanh"
          | "truncate"    -> 7

          | "*" 
          | "/" 
          | "div"
          | "*." 
          | "/." 
          | "&&"    -> 8
          | _ -> raise (Fish_error 
                  (String.concat ":" ["unrecognised primitive operation";s]))
      )

  | _ -> raise (Fish_error "this is a value")
        

(* formatting *) 

let format_term_variable x =
  match x with
    Var y -> ps y

  | TypedVar (y,ty) -> 
      lpn() ;
      ps y ;
      ps ":" ;
      format_phrase_type false ty ;
      rpn() ;

  | Mvar n -> ps ("mvar_" ^ (string_of_int n))

  | TypedMvar (n,ty) -> 
      lpn() ;
      ps ("mvar_" ^ (string_of_int n)) ;
      ps ":" ;
      format_phrase_type false ty ;
      rpn() ;

;;


let format_term t = 

  let rec do_format t' left_prec right_prec =

    match t' with

      Tvar x -> 
        format_term_variable x

    | Apply(Dyn pty,t2) ->
        open_box 0;
        lpn();
        do_format t2 0 0;
        ps " :" ;
        format_prim_type pty ;
        rpn();
        close_box()
  
    | Apply(t1,t2) ->
        let needParens = 
          prec_app <= left_prec or
          prec_app < right_prec
        in
        open_box 0;
        if needParens 
        then (
          lpn();
          do_format t1 0 prec_app
            )
        else (
          do_format t1 left_prec prec_app
            );
        close_box();
        print_space();
        open_box 0;
        if needParens 
        then (
          do_format t2 prec_app 0;
          rpn()
            )
        else (
          do_format t2 prec_app right_prec
            );
        close_box()
          
    | Lam(x,t') ->
        let needParens = left_prec > prec_fun or right_prec > 0 
        in
        open_box termIndent;
        if needParens then lpn();
        ps "fun";
        print_space();
        format_term_variable x;
        print_space();
        ps "->";
        print_space();
        if needParens 
        then (
          do_format t' prec_fun 0;
          rpn()
            )
        else (
          do_format t' prec_fun right_prec
            );
        close_box()
        
    | Where (t1,x,t2) ->
        let needParens = 
          left_prec > prec_where or 
          right_prec >= prec_where
        in
        if needParens then (
          lpn();
          do_format t1 0 prec_where
          )
        else (
          do_format t1 left_prec prec_where
          );
        force_newline();
        ps "where";
        print_space();
        format_term_variable x;
        ps " = ";
        if needParens 
        then (
          do_format t2 0 0;
          rpn()
            )
        else (
          do_format t2 0 right_prec;
          )

   | Op (c,ts) -> 
       (match ts with 
         [] -> format_prim_constant c 
       | [t] ->
           let prec = prec_op c in 
           let needsParen =
             left_prec  >  prec or 
             right_prec >= prec
       in
       if needsParen then (
         lpn() ;
         format_prim_constant c ; (* all unary ops are prefix *)
         print_space() ;
         do_format t prec 0 ;
         rpn()
       )
       else (
         format_prim_constant c ;
         print_space() ;
         do_format t prec right_prec ; )

       | [t0;t1] -> 
           let prec = prec_op c in 
           let needsParen =
             left_prec  >  prec or 
             right_prec >= prec
       in
       if needsParen then (
         lpn() ;
         do_format t0 0 prec ;  (* all binary ops are infix *)
         print_space() ;
         format_prim_constant c ;
         print_space() ;
         do_format t1 prec 0 ;
         rpn()
       )
       else (
         do_format t0 left_prec prec ;
         print_space() ;
         format_prim_constant c ;
         print_space() ;
         do_format t1 prec right_prec ; )

       |  _ -> raise (Fish_error "too many arguments for a primitive operation")

       )

   | Get t -> 
         ps "get(" ;
         do_format t prec_get right_prec ;
         rpn() ; 

   | Sub(t1,t2) -> 
         ps "sub(" ;
         do_format t1 0 0  ;
         ps "," ;
         do_format t2 0 0 ;
         rpn() ; 
                
   | Condsh(x,y,z) -> 
       let needsParen =
        left_prec  >  prec_cond or 
        right_prec >= prec_cond
       in
       if needsParen then (
        lpn() ;
        ) ;
       ps "if " ; 
       do_format x 0 0 ; 
       ps " then " ; 
       do_format y 0 0 ; 
       ps " else " ; 
       do_format z 0 0 ;
       if needsParen then (
        rpn() ;
        ) 

   | Cond(x,y,z) -> 
       let needsParen =
        left_prec  >  prec_cond or 
        right_prec >= prec_cond
       in
       if needsParen then (
        lpn() ;
        ) ;
       ps "if " ; 
       do_format x 0 0 ; 
       ps " then " ; 
       do_format y 0 0 ; 
       ps " else " ; 
       do_format z 0 0 ;
       if needsParen then (
        rpn() ;
        ) 

   | Condexp(x,y,z) -> 
       let needsParen =
        left_prec  >  prec_cond or 
        right_prec >= prec_cond
       in
       if needsParen then (
        lpn() ;
        ) ;
       ps "if " ; 
       do_format x 0 0 ; 
       ps " then " ; 
       do_format y 0 0 ; 
       ps " else " ; 
       do_format z 0 0 ;
       if needsParen then (
        rpn() ;
        ) 

   | Typed (t'',ty) -> 
       lpn() ;
       do_format t'' 0 0 ;
       ps " : " ;
       format_untidy_phrase_type ty ;
       rpn() 

  (* commands *)

  | Skip -> ps "skip"
  | Abort -> ps "abort"
  | Assign -> ps "assign"
  | Seq -> ps "seq"
  | Forall -> ps "forall"
  | Whiletrue -> ps "whiletrue"
  | Fix k -> ps "fix("; Format.print_int k ; ps ")"
  | Newvar -> ps "newvar"
  | Output -> ps "output"

  (* array expressions *)

  | Dyn pty -> ps "dyn"  (* shouldn't happen! *)
  | Newexp -> ps "newexp"

  (* shape expression *)

  | Bang ty -> format_prim_type ty; ps "_shape"
  | Zerodim -> ps "zerodim"
  | Succdim -> ps "succdim"
  | Undim -> ps "undim"
  | Lendim -> ps "lendim"
  | Preddim -> ps "preddim"
  | Numdim -> ps "numdim"
  | Equal -> ps "shequal"

  (* phrase polymorphic terms *)
     
  | Primrec -> ps "primrec"
  | Error -> ps "error"
  | Shape -> ps "#"

  in
          
  open_box 0;
  do_format t 0 0;
  close_box();
  print_flush()
;;
          
let format_shape_term t =

  match t with

    Op _ 
  | Error -> 
      format_term t
        
  | _ -> 
      
      let print_as_size n = 
        Format.print_int n
      in let rec format_size_list ns =
        match ns with
          [] -> ()
        | [n] -> print_as_size n
        | h::ns' -> 
            print_as_size h;
            ps ",";
            format_size_list ns'
      in let format_one_layer dims = 
        if length dims > 0
        then (
          open_box 0;
          print_space();
          format_size_list dims;
          print_space();
          close_box()
            );
        ps ":"
      in

      let (dims_lst,b) = shape2Pair t
      in

      match dims_lst with

        [] ->
          format_prim_type b; ps "_shape"

      | _ ->
          ps "{";
          if length dims_lst > 0 & length (hd dims_lst) = 0
          then ps " ";
          iter format_one_layer dims_lst;
          ps " ";
          format_prim_type b; 
          ps "_shape }"
;;


let format_parsed_term term = 
  Format.print_string "Parse tree : ";
  Format.print_newline();
  format_term term;
  Format.print_newline()
;;

let format_inferred_term term = 
  Format.print_string "Inferred term : ";
  Format.print_newline();
  format_term term;
  Format.print_newline()
;;

let format_declaration identifier tyScheme = 
  format_term_variable identifier;
  Format.print_string " : ";
  format_type_scheme tyScheme; 
  Format.print_newline()
;;

let format_shape_declaration identifier shape tyScheme = 

  let fsd identifier shape = 
  Format.print_string "#";
  format_term_variable identifier;
  Format.print_string " = ";
  format_shape_term shape;
  Format.print_newline()
  in 

  match (tyScheme,shape) with
    _,Error ->                                 fsd identifier shape 
  | TyScheme(_,_,ExpTy (AT (DatumTy _))), _ -> ()
  | TyScheme(_,_,ExpTy ty),_ ->                fsd identifier shape 
  | _,_ ->                                     ()
;;

@head(2,"primitive_fish.ml")
primitive_fish.ml.
@select(tangler("src/primitive_fish.ml"))
(* Primitive Fish Datum Operations and Relations *)
 

(* Other files containing information about primitives:

 - turbot2C_fish.ml: 

   c_string_for_prim_type 
   c_prim_type_bytes
   c_print_prim_value 
   c_print_bang

*)


exception Fish_error of string;;

type prim_type = 
    IntTy 
  | BoolTy 
  | FloatTy 
  | CharTy
;;

type prim_value =
    Int of int
  | Bool of bool
  | Float of float
  | Char of char
;;

type prim_constant =
    Prim_value of prim_value 
  | Pconst of prim_type list * bool * string  
;;

(* holds type info, static flag (always true at present), name and name in C.  *)


(* names of types *)

let string_of_prim_type ty = 
  match ty with
    IntTy -> "int"
  | BoolTy -> "bool"
  | FloatTy -> "float"
  | CharTy -> "char"
;;

let string_of_static_prim_type ty = 
  match ty with
    IntTy -> "size"
  | BoolTy -> "fact"
  | FloatTy -> "cost"
  | CharTy -> "mark"
;;



(* map prim_values to prim_types *)

let type_prim_value v =
  match v with
    Int _ -> IntTy
  | Float _ -> FloatTy
  | Bool _ -> BoolTy
  | Char _ -> CharTy
;;

let types_prim_constant c = 
  match c with 
    Prim_value v -> [type_prim_value v] 
  | Pconst (tys,_,_) -> tys
;;

let return_type_prim_constant c = 
  List.hd (List.rev (types_prim_constant c));;

let string_of_prim_value v = 
  match v with
    Int n -> string_of_int n 
  | Bool b -> if b then "true" else "false"
  | Float f -> string_of_float f 
  | Char c -> "'c'" 
;;



(* pconst definitions *)

(* construction tools *)

let mk_uss ty name  =  
  (* unary, single-sorted operations *)
  Pconst ([ty;ty],true,name);;

let mk_int_uss = mk_uss IntTy;; 
let mk_float_uss = mk_uss FloatTy;; 
let mk_bool_uss = mk_uss BoolTy ;;

let mk_bss ty name = 
  (* binary, single-sorted operations *)
  Pconst ([ty;ty;ty],true,name)

let mk_int_bss = mk_bss IntTy;; 
let mk_float_bss = mk_bss FloatTy;; 
let mk_bool_bss = mk_bss BoolTy;;
let mk_char_bss = mk_bss CharTy;; 

let mk_rss ty name = 
  (* single-sorted relations *)
  Pconst ([ty;ty;BoolTy],true,name);;

let mk_int_rss = mk_rss IntTy;;
let mk_float_rss = mk_rss FloatTy;;
let mk_char_rss = mk_rss CharTy;; 


(* ad hoc polymorphism *)

let is_polymorphic x = 
  List.mem x ["+" ; "*" ; "-" ; "=" ; "<" ; "<=" ; ">" ; ">=" ] ;;

let instantiate_polymorphic_op name pty = 
  name ^ (
    if is_polymorphic name
    then 
      match pty with 
        IntTy -> ""
      | FloatTy -> "."
      | BoolTy -> "b"
      | CharTy -> "c"
    else ""
        )
    

(* integer examples *)

let prim_int_negative = mk_int_uss "-" ;;
      (* Use the argument list to determine the status of "-" *)
let prim_float_negative = mk_float_uss "-." ;;

let prim_int_plus = mk_int_bss "+" ;;
let prim_int_times = mk_int_bss "*" ;;
let prim_int_minus = mk_int_bss "-" ;;
let prim_int_divide = mk_int_bss "div" ;;
let prim_int_modulo = mk_int_bss "mod" ;;


let prim_int_equal = mk_int_rss "=" ;;
let prim_int_less_than = mk_int_rss "<" ;;
let prim_int_less_than_or_equal = mk_int_rss "<=" ;;
let prim_int_greater_than = mk_int_rss ">" ;;
let prim_int_greater_than_or_equal = mk_int_rss ">=" ;;

let prim_int2float = 
  Pconst ([IntTy;FloatTy],true,"int2float");;

(* float examples *)

let prim_float_plus = mk_float_bss "+." ;;
let prim_float_times = mk_float_bss "*." ;;
let prim_float_minus = mk_float_bss "-." ;;
let prim_float_divide = mk_float_bss "/." ;;

let prim_float_equal = mk_float_rss "=." ;;
let prim_float_less_than = mk_float_rss "<." ;;
let prim_float_less_than_or_equal = mk_float_rss "<=." ;;
let prim_float_greater_than = mk_float_rss ">." ;;
let prim_float_greater_than_or_equal = mk_float_rss ">=." ;;


(* boolean examples *)

let prim_not = mk_bool_uss "not"  ;;
let prim_and = mk_bool_bss "&&" ;;
let prim_or  = mk_bool_bss "||" ;;

let prim_bool_equal                 = mk_bool_bss "=b"  ;;
let prim_bool_less_than             = mk_bool_bss "<b"  ;;
let prim_bool_less_than_or_equal    = mk_bool_bss "<=b" ;;
let prim_bool_greater_than          = mk_bool_bss ">b"  ;;
let prim_bool_greater_than_or_equal = mk_bool_bss ">=b" ;;

(* character examples *)

let prim_char_equal                 = mk_char_rss "=c"  ;;
let prim_char_less_than             = mk_char_rss "<c"  ;;
let prim_char_less_than_or_equal    = mk_char_rss "<=c" ;;
let prim_char_greater_than          = mk_char_rss ">c"  ;;
let prim_char_greater_than_or_equal = mk_char_rss ">=c" ;;



(* maths operations *)

(* Currently, these operations will all be performed statically, if
possible. Set the boolean flag to false to force run-time computation.
*)

let mk_mathop_1 name = 
  Pconst ([FloatTy;FloatTy],true,name);;
let mk_mathop_2 name = 
  Pconst ([FloatTy;FloatTy;FloatTy],true,name);;

let prim_acos = mk_mathop_1 "acos" ;;
let prim_asin = mk_mathop_1 "asin" ;;
let prim_atan = mk_mathop_1 "atan" ;;
let prim_ceil = mk_mathop_1 "ceil" ;;
let prim_cos  = mk_mathop_1 "cos"  ;;
let prim_cosh = mk_mathop_1 "cosh" ;;
let prim_exp  = mk_mathop_1 "exp"  ;;
let prim_fabs = mk_mathop_1 "fabs" ;;
let prim_floor= mk_mathop_1 "floor";;
let prim_log  = mk_mathop_1 "log"  ;;
let prim_log10= mk_mathop_1 "log10";;
let prim_sin  = mk_mathop_1 "sin"  ;;
let prim_sinh = mk_mathop_1 "sinh" ;;
let prim_sqrt = mk_mathop_1 "sqrt" ;;
let prim_tan  = mk_mathop_1 "tan"  ;;
let prim_tanh = mk_mathop_1 "tanh" ;;

let prim_truncate = Pconst ([FloatTy;IntTy],true,"truncate");;

let prim_atan2= mk_mathop_2 "atan2";;
let prim_fmod = mk_mathop_2 "fmod" ;;
let prim_pow  = mk_mathop_2 "pow"  ;;

(* delta rules - for evaluating primitive operationsn statically *)

let apply_delta dconst args = 

  match dconst with

    Prim_value _ -> raise (Fish_error "invalid primitive application")

  | Pconst (_,_,s) -> 

      match (s,args) with

      (* integer ops *)
            
      |        "-",  [Int m]       -> Int (- m)
      | "+",  [Int m;Int n] -> Int(m + n) 
      | "*",  [Int m;Int n] -> Int(m * n) 
      | "-",  [Int m;Int n] -> Int(m - n) 
      | "div",[Int m;Int n] -> Int(m / n) 
      | "mod",[Int m;Int n] -> Int(m mod n)
            
     (* integer rels *)
            
      | "=",  [Int m;Int n] -> Bool (m = n) 
      | "=",  [Int m;Float n] -> Bool (float m = n) 
      | "=",  [Bool m;Bool n] -> Bool (m = n) 
      | "=",  [Char m;Char n] -> Bool (m = n) 
      | "<",  [Int m;Int n] -> Bool (m < n) 
      | "<",  [Float m;Float n] -> Bool (m <  n) 
      | "<",  [Bool m;Bool n] -> Bool (m < n) 
      | "<",  [Char m;Char n] -> Bool (m < n) 
      | "<=", [Int m;Int n] -> Bool (m <= n) 
      | "<=", [Float m;Float n] -> Bool (m <=  n) 
      | "<=", [Bool m;Bool n] -> Bool (m <= n) 
      | "<=", [Char m;Char n] -> Bool (m <= n) 
      | ">",  [Int m;Int n] -> Bool (m > n) 
      | ">",  [Float m;Float n] -> Bool (m >  n) 
      | ">",  [Bool m;Bool n] -> Bool (m > n) 
      | ">",  [Char m;Char n] -> Bool (m > n) 
      | ">=", [Int m;Int n] -> Bool (m >= n) 
      | ">=", [Float m;Float n] -> Bool (m >=  n) 
      | ">=", [Bool m;Bool n] -> Bool (m >= n) 
      | ">=", [Char m;Char n] -> Bool (m >= n) 
            
     (* float ops *)

      |        "-.",  [Float m]         -> Float (-. m) 
      |        "+.",  [Float m;Float n] -> Float (m +. n) 
      |        "-.",  [Float m;Float n] -> Float (m -. n) 
      |        "*.",  [Float m;Float n] -> Float (m *. n) 
      |        "/.",  [Float m;Float n] -> Float (m /. n) 

      (* float rels *)

      |        "=.",  [Float m;Float n] -> Bool (m = n) 
      |        "<.",  [Float m;Float n] -> Bool (m < n) 
      |        "<=.", [Float m;Float n] -> Bool (m <= n) 
      |        ">.",  [Float m;Float n] -> Bool (m > n) 
      |        ">=.", [Float m;Float n] -> Bool (m >= n) 

      (* bool ops *)
            
      | "not", [Bool m]        -> Bool (not m)
      | "&&",  [Bool m;Bool n] -> Bool (m & n) 
      | "||",  [Bool m;Bool n] -> Bool (m or n)

      |        "=b",  [Bool m;Bool n] -> Bool (m = n) 
      |        "<b",  [Bool m;Bool n] -> Bool (m < n) 
      |        "<=b", [Bool m;Bool n] -> Bool (m <= n) 
      |        ">b",  [Bool m;Bool n] -> Bool (m > n) 
      |        ">=b", [Bool m;Bool n] -> Bool (m >= n) 

      (* char ops *)

      |        "=c",  [Char m;Char n] -> Bool (m = n) 
      |        "<c",  [Char m;Char n] -> Bool (m < n) 
      |        "<=c", [Char m;Char n] -> Bool (m <= n) 
      |        ">c",  [Char m;Char n] -> Bool (m > n) 
      |        ">=c", [Char m;Char n] -> Bool (m >= n) 



      (* mixed-sort *)
            
      | "int2float",[Int n] -> Float (Pervasives.float n)

      (* math ops *)
            
      | "acos", [Float n] -> Float (acos n)
      | "asin", [Float n] -> Float (asin n)
      | "atan", [Float n] -> Float (atan n)
      |        "atan2",[Float m;Float n] 
                          -> Float (atan (m/.n))
      | "ceil", [Float n] -> Float (ceil n)
      | "cos",  [Float n] -> Float (cos n)
      | "cosh", [Float n] -> Float (cosh n)
      | "exp",  [Float n] -> Float (exp n)
      | "fabs", [Float n] -> Float (abs_float n)
      | "floor",[Float n] -> Float (floor n)
      | "fmod", [Float m;Float n] 
                          -> Float (mod_float m n)
      | "log",  [Float n] -> Float (log n)
      | "log10",[Float n] -> Float (log10 n)
      | "pow",  [Float m;Float n] 
                          -> Float (m**n)
      | "sin",  [Float n] -> Float (sin n)
      | "sinh", [Float n] -> Float (sinh n)
      | "sqrt", [Float n] -> Float (sqrt n)
      | "tan",  [Float n] -> Float (tan n)
      | "tanh", [Float n] -> Float (tanh n)

      |        "truncate",[Float n] -> Int (truncate n)    

      | _ -> raise (Fish_error "invalid primitive application")
;;
 
      (* end of delta rules *)
            

@head(2,"hook_fish.ml")
hook_fish.ml.
@select(tangler("src/hook_fish.ml"))
(* type of user commands in shell *)

open Printf
open Lexing
open Parsing
open List



open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Pretty_fish
open Type_subs_fish
open Substitution_fish
open Parse_fish
open Lex_fish
open Unify_fish
open Infer_fish
open Partial_ev_fish
open Turbot2C_fish
open Util_fish

exception InvalidRunType of phraseType


(* version_fish.ml *)

let version_number =
  "1.6" (* ^ "02 Nov 1998" *) 
;;
 


(* functions for executing shell commands *)

(* let  *)

let get_type_scheme tyEnv identifier theType tysub = 
  match identifier with 
  | TypedVar (rx,x_ty0) -> 
      let bestType = 
        applyTySub 
          (unifyLoop ([ theType , x_ty0 ], tysub)) 
          x_ty0 
      in closTy bestType tyEnv
  | TypedMvar (rx,x_ty0) -> 
      let bestType = 
        applyTySub 
          (unifyLoop ([ theType , x_ty0 ],tysub))
          x_ty0 
      in closTy bestType tyEnv
  | _ -> closTy theType tyEnv
;;      

let global_env = ref [] 
;; 

let global_ev t = part_ev  !Util_fish.modes (global2shape !global_env)  t
;;
      
let declare identifier sourceTerm =
(* freshen free type variables in identifier? *)

  if (get_mode "parse" = Util_fish.Show_on) 
  then format_parsed_term sourceTerm ;
  
  let tyEnv = global2type !global_env in 
  let (inferredTerm,inferredType, tysub) = 
    infer tyEnv sourceTerm 
  in 
  if (get_mode "infer" = Util_fish.Show_on) 
  then format_inferred_term inferredTerm ;
  
  let theTypeScheme = 
    get_type_scheme tyEnv identifier inferredType tysub 
  in 
  format_declaration identifier theTypeScheme ;
  
  let theTerm = global_ev inferredTerm in  
  let theShape = global_ev (shape theTerm) 
  in 
  format_shape_declaration identifier theShape theTypeScheme;      
  global_env := 
     (raw identifier,(theTypeScheme,theShape,theTerm)) 
     :: !global_env


let fish2turbot v flags =
  let qflag = List.mem Quiet_flag flags
  and (tyScheme,_,_) = assoc v !global_env in 
  let ty = inst_tyscheme tyScheme in
  let theTerm = 
    match (ty,qflag) with
      (CommTy,_) -> Tvar v
    | (ExpTy (AT _),true) -> ap  exp2comm (Tvar v)
    | (ExpTy (AT _),false) -> ap Output (Tvar v)
    | _ -> raise (InvalidRunType ty)
  in
  tidy_term (global_ev theTerm)
;;

let format_fish_as_turbot t flags = 
  format_term (fish2turbot t flags);
  Format.print_newline()
;;

(* %run *)

let fileInCurrentDirectory filename = 
  "./" ^ filename  (* Unix *)
;;

let compile_to_C_and_run v flags filename = (* v is a variable *)
  let cFile = fileInCurrentDirectory (filename ^ ".c")
  and turbotTerm = fish2turbot v flags
  in
  translateToFile cFile turbotTerm;
  ignore(Sys.command("fcc " ^ cFile));

  if (List.mem Compile_flag flags) 
  then ignore(Sys.command(fileInCurrentDirectory filename)) 
;;

(* %use *)

let posStack = Stack.create()
;;

let pushLineStack() =
  Stack.push (!line_number) posStack;
  line_number := 1
;;

let popLineStack() =
  line_number := Stack.pop posStack
;;

(* shell commands *)

let fish_process_action file_parser sa  =  (* sa = shell action *)

  let rec do_action action = (* file_parser is fixed *)

    match action with

      Let_decl(identifier,sourceTerm) -> 
        declare identifier sourceTerm 

    | Turbot_directive (x,flags) -> 
        format_fish_as_turbot x flags;()

    | Run_directive (x,flags,basename) -> 
        compile_to_C_and_run x flags basename;()

    | Show_directive (mode,s) ->
        set_mode s mode

    | Use_directive s  ->  
        printf "Opening file \"%s\" ...\n" s;flush stdout;
        pushLineStack();
        List.iter do_action (file_parser s);
        popLineStack()

    | Quit_directive -> 
        printf "... glub glub glub ...\n";
        exit 0

  in do_action sa
;;

(* start_fish.ml *)




(* old start_fish.ml begins here *)

(* print a string to console, flush standard output *)

let pf s = 
  printf "%s\n" s;flush stdout
;;

(* handle exception in readEvalPrint loop *)

let handleTopLoopException exn =
  match exn with

  (* system-defined *) 

  | Invalid_argument s -> pf (sprintf "Invalid_argument %s" s)
  | Sys_error s -> pf s
  | Sys.Break -> pf "Break ...";raise (Sys.Break) 
  | Not_found -> pf "Not_found"

  (* failures in named O'Caml functions *)

  | Failure s -> pf (sprintf "Failure in %s" s)

  (* exported from source files, in alpha order *)

  | Primitive_fish.Fish_error s -> pf (sprintf "FISh_error: %s" s)

  (* from partial_ev_fish.ml *)

  | Shape_error (ts,s) ->
      pf (sprintf "%s" "shape error -- ") ;
      (match ts with 
        [t] -> format_term t ;
      | [t1;t2] -> 
          format_term t1 ;
          pf (sprintf "\nand") ;
          format_term t2 ;
      | _ -> ()
      ) ;
      pf (sprintf "\n%s" s)

  (* from infer_fish.ml *) 

  | UnboundVariable v -> pf (sprintf "Unbound variable %s" (var2string v))

  (* from interface_fish.ml *)

  | FishSyntaxError (line,col,message) -> 
      pf (sprintf "Syntax error at line %d, column %d : %s" line col message)
            
  (* from lex_fish.ml *)

  | UnterminatedComment -> pf "Unterminated comment"

  (* from shell_fish.ml *)

  | No_such_mode -> pf "No such mode" 

  | InvalidRunType ty -> formatInvalidRunType ty

  (* from terms_fish *)
  | NoType -> pf "Raw term variable found"

  (* from unify_fish.ml *)      

  | UnifyPhraseError (ty1,ty2) -> 
      formatPhraseTypeError "Error unifying" ty1 ty2
  | UnifyArrayError (ty1,ty2) -> 
      formatArrayTypeError "Error unifying" ty1 ty2 
  | OccursPhraseError (ty1,ty2) -> 
      formatPhraseTypeError "Occurs-check error when unifying" ty1 ty2
  | OccursArrayError (ty1,ty2) -> 
      formatArrayTypeError "Occurs-check error when unifying" ty1 ty2
  | Incompatible_datum_types (pty0,pty1) -> 
      formatPrimTypeError "Error unifying" pty0 pty1 

  (* anything else *)

  | _ -> pf "Uncaught exception, continuing ..."
;;


let readEvalPrint () =
  let lexbuf = ref (Lexing.from_channel stdin) 
  in
  while (true) do
    printf ">-|> ";
    flush stdout;
    try 
      let action = parseShell !lexbuf
      in fish_process_action parseShellListFromFile action 
    with exn -> 
      handleTopLoopException exn;
      lexbuf := Lexing.from_channel stdin (* new buffer *)
  done
;;

let fish () =
  let startUps = ["standard_prelude.fsh"]
  and fishLibDir = 
    try Sys.getenv "FISH_LIB_DIR" with
      Not_found -> "."
  in 
  pf "Loading startup files ... ";
  global_env := [];
  let actionLists =
    List.map 
      (fun s -> 
        try parseShellListFromFile s
        with _ ->
          try parseShellListFromFile (fishLibDir ^ "/" ^ s)
          with _ ->
            pf ("Error loading " ^ s ^ ", continuing ...");[])
      startUps
  in
  List.iter
    (fun actions ->
      try List.iter 
            (fish_process_action parseShellListFromFile)
            actions
      with exn -> handleTopLoopException exn)
    actionLists;
  pf "" ;
  pf "" ;
  pf ("Welcome to FISh v. " ^ version_number);
  pf "(C) Copyright 1998, C. Barry Jay";
  pf "No warranty expressed or implied" ;
  pf "See README for details" ;
  readEvalPrint()
;;

@head(2,"fish.ml")
fish.ml.
@select(tangler("src/fish.ml"))
open Hook_fish
;;
fish()
;;

@head(2,"substitution_fish.ml")
substitution_fish.ml.
@select(tangler("src/substitution_fish.ml"))
(*

        Substitution
        ============


substitute0 applies a substitution while respecting bound variables.

substitute is the external version. 

rename_variable replaces a variable by its image under the
substitution, if applicable, and leaves it unchanged otherwise.

apply_term_subst applies a substitution to *all* variables, both free
and bound.


variables_in produces a list of free and of bound variables. 

*) 

open Char
open List

open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish

module Term_subst = Map.Make(Ordered_vars)

let id_term_subst = Term_subst.empty 
;;


let rec substitute0 term_subst  =
  let rec sub (term:fish_term) = 
    match term with 

     Tvar z -> 
       (try (Term_subst.find (raw z) term_subst) 
       with Not_found -> term)
         
       (* Assume that any given type for z matches that of the
          substitution!  This may lose type information about the
          declared type of the variable z. *)
        
    | Apply (a,b) -> Apply(sub a,sub b)

    | Lam(z,t) -> 
        let z' = 
          (try nextTypedVar (declaredType z)
           with NoType -> nextvar() 
          ) in 
        let ts = Term_subst.add (raw z) (Tvar z') term_subst
        in 
        Lam(z',substitute0 ts t)        
        
    | Op(c,ts) -> Op(c, List.map sub ts)

    | Get t -> Get (sub t) 

    | Sub (t1,t2) -> Sub (sub t1,sub t2) 

    | Condsh(t1,t2,t3) -> Condsh (sub t1, sub t2, sub t3) 

    | Cond(t1,t2,t3) -> Cond (sub t1, sub t2, sub t3) 

    | Condexp(t1,t2,t3) -> Condexp (sub t1, sub t2, sub t3) 

    | Where(a,z,d) -> 
        let z' = 
          (try nextTypedVar (declaredType z)
           with NoType -> nextvar()
          ) in 
        let ts = Term_subst.add (raw z) (Tvar z') term_subst
        in 
        Where (substitute0 ts a,z',sub d) 

    | Typed(t,ty) -> Typed(sub t,ty) 

    |  _ -> term

  in sub ;;

  (* end *) 

let substitute x term1 term2 =  
  substitute0
    (Term_subst.add (raw x) term1 id_term_subst) 
    term2 
;;


(* these functions are used for pretty-printing *)

let rename_variable term_subst x =      
        try 
            match Term_subst.find (raw x) term_subst with
                  Tvar y -> y
                | _ -> x

        with Not_found -> x 
;;

let rec apply_term_subst term_subst = 
            (* this is used to produce turbot. 
               We strip  off explicit type declarations. *)

  let rv = rename_variable term_subst
  in 

  let rec ats (term:fish_term) =
    match term with 

      Tvar z -> 
        (try Term_subst.find (raw z) term_subst
            with Not_found -> term )

    | Apply (a,b) -> Apply(ats a,ats b)

    | Lam(z,t) -> Lam (rv z ,ats t)     

    | Op(c,ts) -> Op(c, List.map ats ts)

    | Get t -> Get (ats t) 

    | Sub (t1,t2) -> Sub (ats t1, ats t2) 

    | Condsh (t0,t1,t2) -> Condsh (ats t0, ats t1, ats t2)

    | Cond (t0,t1,t2) -> Cond (ats t0, ats t1, ats t2)

    | Condexp (t0,t1,t2) -> Condexp (ats t0, ats t1, ats t2)

    | Where(a,b,d) -> Where (ats a,
                             rv b,
                             ats d
                               ) 

    | Typed(t,ty) -> Typed(ats t,ty)
        
    | _ -> term

  in ats 
;;



let rec variables_in term = var_in [] [] term

and var_in free bound t =       (*   vi t        *)

 let rec vi t = 

      match t with 

          Tvar x -> 
            if mem (raw x) bound        
            then (free, bound)
            else (raw x::free, bound)

        | Apply(t1,t2) -> vin [t1;t2]

        | Lam(x,t) -> var_in free (raw x::bound) t

        | Op(c, ts) -> vin ts

        | Get t -> vi t

        | Sub (t1,t2) -> vin [t1;t2]

        | Condsh (t1,t2,t3) -> vin [t1;t2;t3]

        | Cond (t1,t2,t3) -> vin [t1;t2;t3]

        | Condexp (t1,t2,t3) -> vin [t1;t2;t3]

        | Where(t2,x,t1) -> bind x t1 t2 
              
        | Typed(t,ty) -> vi t

        | _ -> finished

  (* end vi *)

  and finished = (free,bound)
  and vi2 (t1,t2) = 
        let (f1,b1) = vi t1 
        and (f2,b2) = vi t2 
        in (f1@f2, b1@b2)

  and f1 (x,y) t = 
     let (z,w) = vi t in 
     (x@z,y@w) 

  and vin ts1 = List.fold_left f1 ([],[]) ts1
 
  and bind x t1 t2 =
        let (f1,b1) = var_in free (raw x::bound) t1
        and (f2,b2) = vi t2
        in (f1@f2,b1@b2)


  in vi t
;;


(* free variables with no duplicates *)


let remove_duplicates xs = (* removes duplicate items in a list *)

  let rec rd xs ys = 
    match xs with
          [] -> ys
        | x::xs' ->     if List.mem x ys 
                        then rd xs' ys 
                        else rd xs' (x::ys)
  in rd xs []
;;


let free_vars t = let (raw_fvs,_) = variables_in t
                in remove_duplicates raw_fvs 
;;

(* getTermVarsInLeafOrder takes a fish_term, and returns 

   a list of variables in leaf order, except for-bound variables

   paired with 

   the term where the for-bound variables have been
   renamed according to their nesting level

   NB: it's possible that a term has variables with
   the same names in distinct scopes, which identification
   is preserved after tidying -- not an error, just confusing
   to the reader

*)

(* string_fish.ml -- string primitives *)

let incrStringCounter ctr minc maxc = (* for incrementing term and type variables *)
  let ndx = ref (String.length ctr - 1)
  and flag = ref false
  and newCtr = String.copy ctr
  in 
  while (!ndx >= 0 & !flag = false) do
    flag := true;
    let c = Char.chr ((Char.code newCtr.[!ndx]) + 1)
    in
    if c <= maxc
    then 
      newCtr.[!ndx] <- c
    else (* carry *) 
      (flag := false;
       newCtr.[!ndx] <- minc;
       ndx := !ndx - 1)
  done;
  if (!flag = false) (* need to extend string *)
  then
    (String.make 1 minc) ^ newCtr
  else
    newCtr
;;



let list_diff lst1 lst2 = (* filters lst2 elts from lst1 *)
  let rec loop lst =
    match lst with
      [] -> []
    | h::t -> 
        let t' = loop t
        in 
        if (List.mem h lst2)
        then t'
        else h::t'
  in loop lst1
;;

let mergeLeafLists lst1 lst2 = (* merges lists of subtree info *)
  lst1 @ (list_diff lst2 lst1)
;;

let rec getTermVarsInLeafOrder t =

  let rec gtv t ts ctr = 

    (* t = a term, ts = a term substitution, 
       ctr = a string used as for-loop index variable counter 
    *)

    match t with

    (* term and phrase variables *)

      Tvar x -> 
        (try ([],Term_subst.find (raw x) ts)
        with Not_found -> ([raw x],t))
          
    | Apply(Apply(Apply(Forall,t1),t2),Lam(x,t3)) -> (* handle specially *)
        let (lst,(t1',t2')) = gtv2 t1 t2 ts ctr
        and new_ctr = incrStringCounter ctr 'i' 'l'
        in let new_var = Var new_ctr
        in let (lst',t3') =
          gtv t3 (Term_subst.add (raw x) (Tvar new_var) ts) new_ctr
        in (mergeLeafLists lst lst',
            Apply(Apply(Apply(Forall,t1'),t2'),Lam(new_var,t3')))

    | Apply (t1,t2) -> 
        let (lst,(t1',t2')) = gtv2 t1 t2 ts ctr
        in (lst,Apply (t1',t2'))

    | Lam (x,t') -> 
        let ts' = Term_subst.remove (raw x) ts
        in let (lst,t'') = gtv t' ts' ctr
        in (mergeLeafLists [raw x] lst,Lam (x,t''))

    | Op(c,ts1) -> 
        let (lst,ts') = gtvn ts1 ts ctr in
        (lst, Op(c,ts'))

    | Get t1 -> 
        let (lst, t1') = gtv t1 ts ctr in 
        (lst, Get t1')

    | Sub (t1,t2) -> 
        let (lst,(t1',t2')) = gtv2 t1 t2 ts ctr
        in (lst,Sub (t1',t2'))

    | Condsh (t1,t2,t3)  -> 
        let (lst,(t1',t2',t3')) = gtv3 t1 t2 t3 ts ctr
        in (lst, Condsh(t1',t2',t3'))

    | Cond (t1,t2,t3)  -> 
        let (lst,(t1',t2',t3')) = gtv3 t1 t2 t3 ts ctr
        in (lst, Cond(t1',t2',t3'))

    | Condexp (t1,t2,t3)  -> 
        let (lst,(t1',t2',t3')) = gtv3 t1 t2 t3 ts ctr
        in (lst, Condexp(t1',t2',t3'))

    | Where (t1,x,t2) -> 
        let ts' = Term_subst.remove (raw x) ts
        in let (lst,t1') = gtv t1 ts' ctr
        in let (lst',t2') = gtv t2 ts ctr
        in (mergeLeafLists
              lst 
              (mergeLeafLists [raw x] lst'),
            Where (t1',x,t2'))

    | Typed(t1,ty) -> gtv t1 ts ctr

    (* datum expressions *) 

    | _ -> ([],t) 

  and gtv2 t1 t2 ts ctr = 

    let (lst1,t1') = gtv t1 ts ctr
    and (lst2,t2') = gtv t2 ts ctr

    in

    (mergeLeafLists lst1 lst2,(t1',t2'))

  and gtv3 t1 t2 t3 ts ctr = 

    let (lst1,t1') = gtv t1 ts ctr
    and (lst2,t2') = gtv t2 ts ctr
    and (lst3,t3') = gtv t3 ts ctr

    in (mergeLeafLists (mergeLeafLists lst1 lst2) lst3,(t1',t2',t3'))

  and gtvn ts1 ts ctr = 

      let f t1 (lst,ts')  = 
        (let (lst1,t1') = gtv t1 ts ctr
        in (mergeLeafLists lst1 lst,t1'::ts') )

      in List.fold_right f ts1 ([],[]) 

  in

  gtv t Term_subst.empty ""
;;

let newTermName vars = 
  let termSub = ref id_term_subst
  and termCounter = ref ""
  in 
  let newVar v = 
    termCounter := (incrStringCounter !termCounter 'A' 'Z') ;
    Tvar (Var !termCounter)
  in 
  List.iter 
    (fun v -> termSub := Term_subst.add v (newVar v) !termSub) 
    vars;
  !termSub
;;

let tidy_term t = 
  let (termVars,t') = getTermVarsInLeafOrder t
  in 
  apply_term_subst (newTermName termVars) t'
;;



@head(2,"sugar_fish.ml")
sugar_fish.ml.
@select(tangler("src/sugar_fish.ml"))
(* sugar_fish.ml -- syntactic sugar for internal FiSh compiler use *)

open Primitive_fish
open Types_fish
open Terms_fish

let int_shape   = Bang IntTy;;
let bool_shape  = Bang BoolTy;;
let float_shape = Bang FloatTy;;

(* contractions of lambda calculus *)

let tvar x = Tvar (Var x)
let mvar x = Tvar (Mvar x)
let ap f x = Apply(f,x)
let ap2 f x y = ap (ap f x) y
let ap3 f x y z = ap (ap2 f x y) z
let ap4 f x y z t = ap (ap3 f x y z) t
let lam x y = Lam(x,y)


(* contractions of constructors *)

let get_term() =   (* for var types *)
  let ty = ArrayTV (next_array_tyvar()) in 
  let x = TypedVar("x",VarTy(ArrayTy ty)) in 
  lam x (Get(Tvar x))
let get = ap (get_term())

let condsh_term = 
  let x = Var "x"
  and y = Var "y"
  and z = Var "z" in 
  lam x (lam y (lam z ( Condsh(Tvar x,Tvar y,Tvar z))))
let condsh x y z = Condsh(x,y,z)

let cond_term = 
  let x = Var "x"
  and y = Var "y"
  and z = Var "z" in 
  lam x (lam y (lam z ( Cond(Tvar x,Tvar y,Tvar z))))
let cond x y z = Cond(x,y,z)

let condexp_term = 
  let x = Var "x"
  and y = Var "y"
  and z = Var "z" in 
  lam x (lam y (lam z ( Condexp(Tvar x,Tvar y,Tvar z))))
let condexp x y z = Condexp(x,y,z)

(* contractions of constants *)

let skip = Skip
let abort = Abort
let assign = ap2 Assign
let seq = ap2 Seq
let forall = ap3 Forall 
let whiletrue = ap2 Whiletrue 
let fix k = ap (Fix k)
let newvar = ap2 Newvar 
let output = ap Output

let var2exp_term() = 
  let aty = ArrayTV (next_array_tyvar()) in 
  lam (TypedVar ("x", VarTy     aty )) 
  (Tvar(TypedVar ("x", ExpTy (AT aty))))
let var2exp() = ap (var2exp_term())
let prim_true = Prim_value (Bool true) 
let prim_false = Prim_value (Bool false)
let prim_zero = Prim_value (Int 0)
let prim_one = Prim_value (Int 1)
let prim_int n = Prim_value (Int n)
let prim_char c = Prim_value (Char c)
let newexp = ap2 Newexp

let bang ty = Bang ty 
let zerodim = ap Zerodim
let succdim = ap2 Succdim 
let undim = ap Undim
let lendim = ap Lendim
let preddim = ap Preddim
let numdim = ap Numdim
let equal = ap2 Equal

let primrec = ap3 Primrec
let shape = ap Shape

(* null is only for creating array expressions - not functions etc *)

let null sh = 
  let ty = ArrayTV (next_array_tyvar()) in 
  let x = TypedVar("x",VarTy(ArrayTy ty)) in 
  newexp sh (lam x skip)

(* other *)

let len t = lendim (shape t)
let is_length x = Op(prim_int_greater_than_or_equal, 
                     [x; Op(prim_zero,[])])
let ent_shape t = preddim (shape t)
let check x y   = Condsh(x,y,Error)

let bang_term() =   
  let ty = ArrayTV (next_array_tyvar()) in 
  let x  = TypedVar("x",VarTy ty) in 
  lam x (Typed(Tvar x, ExpTy(AT ty)))


let identity = lam (Var "x") (tvar "x")
let wf x =  equal x x 

let exp2comm = 
  lam (Var "x") 
    (newvar (shape (tvar "x"))
      (lam (Var "y") (assign (tvar "y") (tvar "x"))))

let multilam = List.fold_right lam ;;
let multiseq ts = List.fold_right seq ts skip ;;


@head(2,"terms_fish.ml")
terms_fish.ml.
@select(tangler("src/terms_fish.ml"))
(* 
        The Fish Terms 
        ===============

*)

open List
open Primitive_fish
open Types_fish

exception NoType ;;


type term_variable =
    Var of string                     (* user variables *)
  | TypedVar of string * phraseType  (* ... with type *)
  | Mvar of int                      (* machine variables *)
  | TypedMvar of int * phraseType    (* ... with type *)

module Ordered_vars =                (* term variables *)
  struct 
    type t = term_variable

    let compare v1 v2 =
      match (v1,v2) with 
          (Var x1,Var x2) -> compare x1 x2
        | (Var _,_) -> 1
        | (_,Var _) -> -1
        | (TypedVar (x1,_),TypedVar (x2,_)) -> compare x1 x2 
                                          (* don't check types *)
        | (TypedVar _,_) -> 1
        | (_,TypedVar _) -> -1
        | (Mvar x1,Mvar x2) -> compare x1 x2
        | (Mvar _,_) -> 1
        | (_,Mvar _) -> -1
        | (TypedMvar (n1,_),TypedMvar (n2,_)) -> compare n1 n2 
                                          (* don't check types *)

  end
;;

let fvc = ref 0 (* free variable counter *)

let nextvar() = incr fvc ; Mvar !fvc ;;
let nextTypedVar ty = incr fvc ; TypedMvar (!fvc,ty) ;;

let var2string x = 
  match x with
    Var y -> y
  | TypedVar (y,ty) -> y
  | Mvar n -> "mvar_" ^ (string_of_int n)
  | TypedMvar (n,ty) -> "mvar_" ^ (string_of_int n)

;;

let raw x = 
  match x with
    TypedVar (y,ty) -> Var y
  | TypedMvar (n,ty) -> Mvar n
  | _ -> x
;;

let declaredType x =
   match x with
    TypedVar (y,ty) -> ty
  | TypedMvar (n,ty) -> ty
  | _ -> raise NoType
;;

let offerVarTy x = 
  let aty = next_array_tyvar() in 
  let ty = VarTy (ArrayTV aty) in 
  match x with
    Var y -> TypedVar(y,ty)
  | Mvar y -> TypedMvar(y,ty)
  | _ -> x
;;


let assertIntTy x = 
  match x with 
    Var y         -> TypedVar(y,int)
  | TypedVar(y,_) -> TypedVar(y,int)
  | Mvar y        -> TypedMvar(y,int)
  | TypedMvar(y,_)-> TypedMvar(y,int)


type fish_term = (* constants listed last due to sheer number *)

        (* term and phrase variables *)

        | Tvar of term_variable

        (* application *)

        | Apply of fish_term * fish_term

        (* functions *)

        | Lam of term_variable * fish_term

        (* polymorphic binding construct *)   

        | Where of fish_term * term_variable * fish_term

        (* constructors *)

        | Op of prim_constant * fish_term list 

        | Get of fish_term

        | Sub of fish_term * fish_term 

         | Condsh of fish_term * fish_term * fish_term (* shape conditional *)

         | Cond of fish_term * fish_term * fish_term (* commands *)

         | Condexp of fish_term * fish_term * fish_term (* expressions *)

        | Typed of fish_term * phraseType  

        (* constants by type class *)

        (* commands *)

        | Skip
        | Abort
        | Assign
        | Seq
        | Forall
        | Whiletrue
        | Fix of int  (* the int is the number of parameters 
                         to the procedure, 
                         currently only 0 is supported below! *)
        | Newvar
        | Output


        (* array expressions *)

        | Dyn of prim_type
        | Newexp

        (* shape expression *)

        | Bang of prim_type
        | Zerodim
        | Succdim
        | Undim
        | Lendim
        | Preddim
        | Numdim
        | Equal    (* on array shapes:  #a -> #a -> fact *)


        (* phrase polymorphic terms *)
     
        | Primrec
        | Error
        | Shape
;;


exception Shape_error of fish_term list * string


(* predicates and selectors, some used in turbot2C, not well-structured *)

let isBang shape =
  match shape with
    Bang _ -> true |
    _ -> false
;;


let pair_from_shape f sh =

  let rec loop sh =

    match sh with

      Bang ty -> 
        ([],ty)

    | Apply (Zerodim,sh') -> 
        let (lst,b) = loop sh'
        in ([]::lst,b)

    | Apply (Apply (Succdim,x), sh') ->
        (let pr = loop sh'
        in match pr with
          (h::rest,d) -> 
            (((f x)::h)::rest,d)
        | _ -> raise (Fish_error "in pair_from_shape:1")
        )
          
    | _ -> raise (Shape_error ([sh],"is not an array shape"))

  in loop sh
    
;;
    

let mk_int_from_shape t = 
  match t with
    Op (Prim_value (Int n),[]) -> n
  | _ -> raise (Fish_error "in mk_int_from_shape") 
and mk_fish_from_shape t = t


let shape2Pair = pair_from_shape mk_int_from_shape
and fishShape2Pair sh = 
  match pair_from_shape mk_fish_from_shape sh with 
    (lst,b) -> (lst, Bang b)
;;

let shape_from_pair f (lst,b) =
  let rec loop lst b =
    match lst with
      [] -> b
    | h::t -> 
        List.fold_right f h (Apply(Zerodim,loop t b))
  in loop lst b
;;



let mk_shape_with_int x y = 
  Apply(Apply(Succdim,Op (Prim_value (Int x),[])),y)
and mk_shape_with_fish x y = 
  Apply(Apply(Succdim,x),y)

let fishPair2Shape = shape_from_pair mk_shape_with_fish


(* combinator types and type schemes *)

let combinator_tyscheme comb =           
  match comb with 

    Skip -> tysch [] [] commty 

  | Abort -> tysch [] [] commty 

  | Assign -> forall_X (fun x -> 
      funty3 (varty x) (expty (AT x)) commty)

  | Seq -> tysch [] [] (funty3 commty commty commty)

  | Forall -> tysch [] [] (funty4 int int (funty int commty) commty)

  | Whiletrue -> tysch [] [] (funty3 bool commty commty)

  | Fix k ->  
      let rec f n = 
        (match n with 
          _ when n<0 -> raise (Fish_error "negative argument to fix") 
        | 0 -> commty
        | _ -> 
            funty (ExpTy (AT (ArrayTV(next_array_tyvar())))) (f (n-1))
        ) in 
      let x = f k in 
      tysch [] [] (funty (funty x x) x) 
              (* this should be a proper tyscheme for k>0!!*)

  | Newvar -> forall_X (fun x -> 
    funty3 (expty (hasharrayty x)) (funty (varty x) commty) commty)

  | Output -> forall_X (fun x -> 
      funty (expty (AT x)) commty)

  | Dyn pty -> tysch [] [] (
      funty 
        (ExpTy (ShT (StaticTy pty))) 
        (ExpTy (AT  (DatumTy  pty))) 
        )                              

  | Newexp -> forall_X (fun x -> 
      funty3 
        (expty (hasharrayty x)) 
        (funty (varty x) commty) 
        (expty (AT x)))

  | Bang pty -> tysch [] [] (ExpTy (ShT (HashArrayTy (DatumTy pty))))

  | Zerodim -> forall_X (fun x -> 
      funty (expty (hasharrayty x)) (expty (hasharrayty (ArrayTy x))))

  | Succdim -> forall_X (fun x -> 
    let ty = expty (hasharrayty (ArrayTy x)) in 
    funty3 size ty ty)

  | Undim -> forall_X (fun x -> 
    let ty = expty (hasharrayty (ArrayTy x)) in 
    funty ty (expty (hasharrayty x)))

  | Lendim -> forall_X (fun x -> 
      let ty = expty (hasharrayty (ArrayTy x)) in 
      funty ty size)

  | Preddim -> forall_X (fun x -> 
      let ty = expty (hasharrayty (ArrayTy x)) in 
      funty ty ty )

  | Numdim -> forall_X (fun x -> 
    funty (expty (hasharrayty (ArrayTy x))) size)

  | Equal -> forall_X (fun x -> 
      funty3 
        (expty (hasharrayty x))
        (expty (hasharrayty x)) 
        fact)

  | Primrec -> forall_U (fun u -> 
      funty4 (funty3 size u u) u size u)

  | Error -> forall_U (fun u ->
    u)

  | Shape -> forall_U (fun u ->
      funty u (hashphrasety u))

  | _ -> raise (Fish_error "not a combinator")




@head(2,"turbot2C_fish.ml")
turbot2C_fish.ml.
@select(tangler("src/turbot2C_fish.ml"))
(* turbot2c.ml
   
   This file produces some C wrapper functions for translating fish-terms
   (Turbot terms) to C programs. 
   
   The core function is t2c which does a depth first traversal of a
   turbot term and outputs a C string (fprintf)
   
   translate calls t2c and wraps its result inside a C program inside of
   a main.
   
   *)
  
open Printf
open Map
open List
  
open Primitive_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Substitution_fish
open Partial_ev_fish
open Parse_fish

(* C runtime stack simulation for making heap allocation decisions *)
  
let pointerSize = 4
let theStack = Stack.create ()
let maxStack =  ref 16000     (* maximum size of stack allocated variables *)
let currStackSize = ref 0     (* current stack size *)
    
let clearStack () =
  Stack.clear theStack;
  currStackSize := 0  
       ;;
    
(* try to push a shape of size n on the stack 
   return value is true iff allocated on the heap instead
   *)
    
let pushStack sh n = 
  let tentativeStackSize = !currStackSize + n
  in
  
  (* always stack-allocate datum types *)
  
  if (isBang sh) or tentativeStackSize <= !maxStack
  then
    (Stack.push (n,false) theStack;
     currStackSize := tentativeStackSize; 
     false)
  else (* push pointer instead *)
    (Stack.push (pointerSize,true) theStack;
     currStackSize := !currStackSize + pointerSize;
     true)
      ;;
    
(* pop a size from the stack
   return value is true iff that size was heap-allocated
   *)
    
let popStack () =
  let (n,b) = Stack.pop theStack
  in 
  currStackSize := !currStackSize - n;
  b
    ;;
    
(* channel for printing of compiled code *)

let outchan = ref stdout
;;

(* I/O primitive for printing of compiled code *)

let pp fmt = Printf.fprintf !outchan fmt 
;;
let pp_ndx ndx = pp "[%d]" ndx



(* C printing *)

(* for primitives *)

let print_prim_type_c t =
  match t with
    IntTy -> "int"
  | BoolTy -> "BOOL"
  | FloatTy -> "double"
  | CharTy -> "char"
;;    

(* machine-dependent datum sizes -- these are for Sun Sparc *)

let prim_type_c_bytes t = 
  match t with 
    IntTy -> 4
  | BoolTy -> 4
  | FloatTy -> 8
  | CharTy -> 1
;;


let print_prim_value_c v = 

  match v with 
    | Int n -> pp "%d" n
    | Bool b -> pp "%s" (if b then "TRUE" else "FALSE") 
    | Float n -> pp "%f" n
    | Char c -> 
        pp "'" ; 
        (match c with 
          '\b' -> pp "\\b" 
        | '\n' -> pp "\\n"  
        | '\r' -> pp "\\r"  
        | '\t' -> pp "\\t"
        | '\\' -> pp "\\\\"
        | '\'' -> pp "\\\'"
        | _ -> pp "%c" c
        ) ; 
        pp "'" 
;;

let print_prim_op_c s =
  match s with 
    "-." -> "-"
  | "div" -> "/"
  | "mod" -> "%"
  | "=" -> "==" 
  | "int2float" -> "(double)" 
  | "+." -> "+"
  | "*." -> "*" 
  | "/." -> "/"
  | "=." -> "==" 
  | "<." -> "<"
  | "<=." -> "<="
  | ">." -> ">"
  | ">=." -> ">="
  | "not" -> "!"
  | "truncate" -> "" 
  | _ -> s

let is_infix d = 
  match d with 
    Pconst([pty0;pty1;pty2],_,s) -> 
      (match s with 
        "atan2" 
      | "fmod" 
      | "pow" -> false 
      | _ -> true 
            )
  | _ -> false

let print_prim_constant_c d = 
  match d with 
    Prim_value v -> print_prim_value_c v
  | Pconst(ptys,_,s) -> pp "%s" (print_prim_op_c s)


let print_bang_c t =
  match t with
    IntTy -> pp "INT_SHAPE"
  | BoolTy -> pp "BOOL_SHAPE"
  | FloatTy -> pp "FLOAT_SHAPE"
  | CharTy -> pp "CHAR_SHAPE"
;;

(* end of C printing for primitives *)

(* formatting of C output *)
    
let indent_spacing = 2
let indent_level = ref 0
    
let resetIndent() =
  indent_level := 0
;;
    
let tab() = incr indent_level;;
let untab() = decr indent_level;;
    
let comma() = pp ",";;
let lParen() = pp "(";;
let rParen() = pp ")";;
    
let indent() = 
  for i = 1 to indent_spacing - 1 do
    pp " "
  done
;;

let nli() = (* newline with indent *)
  pp "\n";
  for i = 1 to indent_spacing * !indent_level do
    pp " "
  done
;;
    
let open_block_c() = 
  pp "{";
  tab();
;;
    
let close_block_c() = 
  untab();
  nli();
  pp "}"
;;


(* array information *)

let times x y = x*y ;;
let product = fold_left times 1 ;;

(* array_desc returns 

   variable name, 
   shape (via shape2Pair), 
   offset from source 
   
e.g. 
   if x is a 2x6x3 array of ints 
   then x[1,5] -> (x, #x,(1x6x3 + 5x3)*sizeof(int)) 

It only works for proper arrays and their entries, 
not for trivial arrays or datum variables 

*)

let rec array_desc sh_env = 

  let rec ad t  = 
    match t with
      
      Tvar x -> 
        let (sh,_) = assoc x sh_env in 
        let (lst,b) = shape2Pair sh in 
        if flatten lst = [] 
        then raise (Shape_error 
                      ([t], 
                       " is a trivial array"))
        else (x,(lst,b),Op(prim_int 0,[]))

    | Get t' -> 
        let (x,(lsts,b),n) = ad t' 
        in 
        (match List.hd lsts with
          [] -> (x,(List.tl lsts,b),n)
        | _ -> raise (Shape_error 
                        ([t], 
                         " cannot have get applied"))
              )
          
    | Sub(t',i) ->    
        let (x,(lsts,b),n) = ad t' 
        and (s,_) = array_size sh_env t'
        in (
        match lsts with 
          (h :: t1) :: t2 -> 
            let offset = 
             match (n,s/h) with 
               (Op(Prim_value (Int m),_),p) when m=0 && p=1 -> i
             | (Op(Prim_value (Int m),_),p) when m=0  -> 
                 Op(prim_int_times, [i;Op(prim_int p,[])])
             | (_,p) when p=1  -> Op(prim_int_plus, [n;i])
             | _ -> 
                 Op(prim_int_plus, 
                       [ n; 
                         Op(prim_int_times, 
                            [ i; 
                              Op(prim_int (s/h),[])
                                  ])])
            in (x,(t1 :: t2,b), offset)

        | _ -> raise (Shape_error ([t],"does not have subarrays"))
              )
          
    | _ -> raise (Fish_error "not an identifier or proper array") 
  in 
  ad  
          
and array_size  sh_env t = 
  let (_,(lst,b),n) = array_desc sh_env t 
  in 
  (fold_left (fun x -> fun ys -> x * (product ys)) 1 lst, b)
      
and is_proper_array sh_env t = 

(* 
   is true for proper arrays, 
   false for their entries and 
   otherwise raises an exception 
*)

    let (_,(lst,_),_) = array_desc sh_env t in 
    flatten lst <> []
;;





(* main translation routine, print Turbot terms as C.

List of auxiliary functions appearing within the nested recursion. 

print_id 
   print_rec_fun_call 
print_pconst 
print_subarray 
print_getarray 
print_exp_cond 
print_skip 
print_abort
print_seq
print_assign
print_comm_cond
print_for
print_while
print_fix
   push_regs
   pop_regs 
     mk_assn 
     mk_reg_var
     initialise_pda 
print_newvar
   print_block_decl
   print_block_undecl
print_output 

*)
        
let rec turbot2c  sh_env rec_funs fv_env t =
  
  let rec t2c t =
    
    match t with
      
      (* follows description of Turbot in the paper *)
      
      Tvar x ->                              print_id x   
    | Op(d,ts) ->                            print_pconst d ts
    | Sub(t1,t2) ->                          print_array t
    | Get t' ->                              print_array t' 
    | Cond(t1,t2,t3) ->                      print_comm_cond t1 t2 t3 
    | Condexp(t1,t2,t3) ->                   print_comm_cond t1 t2 t3 
    | Typed(t1,ty) ->                        t2c t1 
    | Skip ->                                print_skip () 
    | Abort ->                               print_abort () 
    | Apply(Apply(Assign,t1),t2) ->          print_assign t1 t2 
    | Apply(Apply(Seq,t1),t2) ->             print_seq t1 t2 
    | Apply(Apply(Apply(Forall,lo),hi),
            Lam(x,body)) ->                  print_for x lo hi body
    | Apply(Apply(Whiletrue,b),t') ->        print_while b t'
    | Apply(Fix 0,Lam(x,body)) ->            print_fix x body
          (* !! what about k >0 ?? *)
    | Apply(Apply(Newvar,sh),Lam(x,body)) -> print_newvar x sh body
    | Apply(Output,t') ->                    print_output t' 
    | Apply(Dyn _,t') ->                     t2c t'
    | Bang b ->                              print_bang_c b
          
    (* error *)
          
    | _ -> raise (Fish_error "in translating to C")

  (* multi-purpose auxiliaries *)

  and print_id x  =

(* 
   if a free variable in a rec fn 
   then print regs.name 
   else if a rec fn 
        then print name()
        else print name 
*)

    if (mem x rec_funs)              (* x is recursive fun *)
    then print_rec_fun_call x
    else (
      (try 
        let regs = assoc x fv_env in (* fv in recursive fun *)
        pp "%s." regs 
      with Not_found -> () ) ;
    pp "%s" (var2string x) )
        

  and print_rec_fun_call x = 
    nli();
    pp "%s();" (var2string x) 
 
  and print_pconst d ts = 
    
    match ts with 
      
      [] -> print_prim_constant_c d

    | [t] -> 
        print_prim_constant_c d;
        pp "(" ;
        print_data t;
        pp ")"

    | [t1;t2] -> 
        
        if is_infix d
 
        then (
            
        pp "(" ;   
        print_data t1;
        print_prim_constant_c d;
        print_data t2 ;
        pp ")" ; )

        else (

        print_prim_constant_c d; 
        pp "(" ;
        print_data t1 ;
        comma();
        print_data t2 ;
        pp ")" )
          
    | _ -> raise (Fish_error "when printing a constant in C")


  and print_array t =  

(* used in prim ops and assignment.
   if a proper array then use an offset from the pointer, A+n
   if an array entry then use array notation A[n] 
   otherwise use the name A
*)

    try 
      let (x,(lst,b),n) = array_desc sh_env t in 

      print_id x; 

      if is_proper_array sh_env t ||
         mem_assoc x fv_env
      then ( 
        if n = Op(Prim_value (Int 0),[]) 
        then () 
        else (pp " + " ; t2c n )
            )
      else   (pp "["   ; t2c n ; pp "]" ) ;

    with _ -> t2c t (* a trivial array or a datum variable *)
  
  and print_data t = 
    begin 
      let (x,(lst,b),n) = array_desc sh_env t in 
      if mem_assoc x fv_env then
      (pp "*(" ; print_array t ; pp ")") (* get the pointer value *)
      else print_array t
    end

  and print_exp_cond ifpart thenpart elsepart  =
    lParen();
    t2c ifpart ;
    pp ") ? (";
    t2c thenpart ;
    pp ") : (";
    t2c elsepart ;
    rParen()

  (* command auxiliaries *)

  and print_skip () = ()
      
  and print_abort () = 
    nli();
    pp "exit(ABORT_CODE);"
      
  and print_seq t1 t2  =
    t2c t1 ;
    t2c t2 
      
  and print_assign t1 t2  = 

(* 
   If a proper array then use memcpy.
   Otherwise use assignment (=).

*)

    nli();

    try 
      if (is_proper_array sh_env t1)
      then (
        let (s,b) = array_size sh_env t1 
        in
        pp "memcpy(";
        print_array t1 ;
        pp ","; 
        print_array t2 ;
        pp ",%d); /* copy %d entries */" (prim_type_c_bytes b *s) s; 
        )
      else (raise (Failure ""))

    with _ -> 
      print_data t1 ;
      pp " = ";
      print_data t2 ;
      pp ";" ;
        

  and print_comm_cond testpart thenpart elsepart  = 
    nli();
    pp "if (";
    t2c testpart ;
    pp ") ";
    open_block_c();
    t2c thenpart ;
    close_block_c();
    nli(); 
    pp "else ";
    open_block_c();
    t2c elsepart ;
    close_block_c()

  and print_for x lo hi body  = 

    let decl_for_bound s t =
      ignore(pushStack int_shape (prim_type_c_bytes IntTy));
      nli();
      pp "int %s = " s; 
      t2c t;
      pp ";"
    and x_str = var2string x 
    in 

    nli();
    open_block_c();
    indent();
    pp "int %s;" x_str ;  
    
    ignore(pushStack int_shape (prim_type_c_bytes IntTy));

    let numBounds = ref 0 
    in
    nli();
   pp "for (%s = " x_str ; 
    t2c lo ;
    pp "; %s < " x_str ;
    t2c hi ;
    pp "; %s++) " x_str ;      
    
    open_block_c();
    
    turbot2c  ((x,(int_shape,Tvar x)) :: sh_env) rec_funs fv_env body ;
    
    ignore(popStack());  (* index variable *)
    for i = 1 to !numBounds do
      ignore(popStack()) (* bounds variables *)
    done;
    
    close_block_c();
    close_block_c()

  and print_while b t  = 
    nli();
    pp "while (";
    t2c b ;
    pp ") ";
    open_block_c();
    t2c t ;
    close_block_c()

  and print_fix x t =

    let fvs = list_diff (free_vars (lam x t)) rec_funs
    and regs = sprintf "%s_regs" (var2string x)
    in 
    push_regs regs fvs;
    print_rec_fun_call x;
    pop_regs regs fvs

  and push_regs regs  = 
      iter 
      (fun v -> 
        nli();
        print_reg_id regs v;
        pp " = " ;
        print_id v;
        pp ";"
        )

  and pop_regs regs = 
      iter 
      (fun v ->
        try 
          if is_proper_array sh_env (Tvar v) 
          then ()
           else raise (Failure "") 
         with _ -> 
           nli();
           print_id v;
           pp " = " ;
           print_reg_id regs v;
           pp ";" 
        )

  and print_reg_id regs v = pp "%s.%s" regs (var2string v)

  and print_newvar x sh body  = 

    let x_str = var2string x
    and (lst,b) = shape2Pair sh
    in
    let f_lst = flatten lst
    in 
    let shapeSize = 
      fold_left (fun x -> fun y -> x * y) (prim_type_c_bytes b) f_lst
    in 

    nli();
    open_block_c();
    print_block_decl (pushStack sh shapeSize) x_str f_lst b;
    turbot2c  ((x,(sh, Tvar x)) :: sh_env) rec_funs fv_env body;
    print_block_undecl (popStack()) x_str f_lst; 
    close_block_c();

and print_block_decl use_heap x_str f_lst b =

      indent();  

      match f_lst 

      with

        [] -> pp "%s %s;" (print_prim_type_c b) x_str

      | _ -> 

          let blocksize = product f_lst in 
 
          pp "%s " (print_prim_type_c b);

          if use_heap
          then ( 
            pp "*%s;" x_str ;
            if length f_lst =1 
            then ()
            else (
              pp " /* represents %s" x_str ;
              iter pp_ndx f_lst ;
              pp " */" ) ;
            nli();
            pp "%s = xmalloc(%d); /* make %d entries */" 
              x_str (prim_type_c_bytes b * blocksize) blocksize;
              )
          else  (
            pp "%s" x_str;
            pp_ndx blocksize; 
            pp ";" ;
            if length f_lst =1 
            then ()
            else (
              pp " /* represents %s" x_str ;
              iter pp_ndx f_lst ;
              pp " */" ) ;
              )

and print_block_undecl use_heap x_str f_lst =
  
      match f_lst with
    
        [] -> () 
        
      | _ when use_heap ->
          nli();
          pp "free(%s);" x_str;
        
      | _ -> ()

  and print_output t  = 

    let (lst,b) = shape2Pair (part_ev !Util_fish.modes sh_env (shape t))
    in

    nli();
    pp "fish_print(_argc,_argv,";

    print_bang_c b;  (* C wants the bang first *)
    pp ",";

    List.iter 
      (fun sublist -> 
        List.iter (fun n -> pp "%d," n) sublist;
        pp "%s" "ARRAY_BOUNDARY,")
      lst ;

    pp "END_OF_SHAPE,";
    
    if length (flatten lst) > 0 (* represented by C array *)
    then pp "(char *)";

    t2c t;
    pp ");"




  (* end mutual recursions with t2c *)

  in t2c t
;;


(* code for recursive functions at C top level.
List of auxiliary functions :

print_fun_prototype 
print_rec_fun 
decl_regs_var 

 *)

let rec define_c_rec_funs  sh_env rec_funs t =

  let rec d_rfuns t' =

    match t' with
  
     (* most interesting case *)

      Apply(Fix 0,Lam(x,body)) -> (* !! k>0 ?? *)
        print_fun_prototype x;
        define_c_rec_funs  sh_env (x::rec_funs) body;
        print_rec_fun x body;

     (* cases with extended shape environment *)

    | Apply(Apply(Newvar,sh),Lam(x,body)) -> 
        define_c_rec_funs  
          ((x,(sh, Tvar x)) :: sh_env) rec_funs body

    | Apply(Apply(Apply(Forall,_),_),Lam(x,body)) -> 
        define_c_rec_funs  
          ((x,(int_shape,Tvar x)) :: sh_env) rec_funs body

     (* all other Turbot combinator applications *)

    | Apply (t1,t2) ->
        d_rfuns t1;d_rfuns t2

    | Op(d,ts) -> iter d_rfuns ts

    | Cond(t0,t1,t2) -> 
        d_rfuns t0; 
        d_rfuns t1; 
        d_rfuns t2 

    | Condexp(t0,t1,t2) -> 
        d_rfuns t0; 
        d_rfuns t1; 
        d_rfuns t2 


    (* nothing to do for constants, nullary combinators 
       invalid Turbot will be caught by turbot2c, so ignore it here 
    *)

    | _ -> () (* This catches all of the term constructors!! *)

  and print_fun_prototype x = (* needed by inner functions *)
    nli();pp "void %s(void);\n" (var2string x)
  
  and print_rec_fun x t =

    let fvs = list_diff (free_vars (lam x t)) rec_funs
    and x_str = var2string x
    and regs = sprintf "%s_regs" (var2string x)
    in

    (* C struct for free variables *)

    if length fvs > 0 then (
      nli();
      pp "struct ";
      open_block_c();
      iter decl_regs_var fvs;
      close_block_c();
      pp " %s;\n" regs
        );

    (* C function *)

    nli();
    pp "void %s(void) " x_str;
    open_block_c();
    turbot2c  sh_env (x::rec_funs) (map (fun y -> (y,regs)) fvs) t;
    close_block_c();
    nli();

  and decl_regs_var v =

    let v_str = var2string v
    and (sh,_) = assoc v sh_env
    in let (lst,b) = shape2Pair sh
    in let f_lst = flatten lst 
    in
    nli();
    pp "%s " (print_prim_type_c b) ;
    match f_lst with 
      [] -> pp "%s;" v_str 
    |   _ ->  pp "*(%s);" v_str

  in

  d_rfuns t
;;


(* translate_fish.ml *)


(* output parameters *)

let setOutchanToConsole () =
   outchan := stdout
;;

let openTranslateFile s = 
   outchan := open_out s
;;

let closeTranslateFile() =
  close_out !outchan
;;

(* translate wraps a Turbot term inside a C program *)

let translate t = 

  let sys_includes = ["math.h";"stdio.h";"stdlib.h";"string.h";"sys/stat.h"]
  in

  resetIndent();
  clearStack();

  pp "/* translated by fish */\n\n";

  List.iter (fun s -> pp "#include <%s>\n" s) sys_includes;

  nli();
    
  pp "#include \"fish.h\"\n\n";

  (* global versions of argc, argv *)

  pp "int _argc;";
  nli();
  pp "char **_argv;\n";
  nli();

  (* recursive functions at C top level *)

  define_c_rec_funs  [] [] t;  
  nli();

  pp "int main(int argc,char *argv[]) {";

  tab();
  nli();

  pp "_argc = argc;";
  nli();
  pp "_argv = argv;";
  nli();

  turbot2c [] [] [] t;

  nli(); 
  untab();

  pp "return 0;\n}\n";

;;

(* interface functions for generating C code *)

let translateToFile s t =
  let currDir = Sys.getcwd()
  in let fileName = currDir ^ "/" ^ s
  in
  openTranslateFile fileName;
  translate t;
  closeTranslateFile()
;;

 
let translateToConsole t =
  setOutchanToConsole();
  translate t;
;;

 

@head(2,"types_fish.ml")
types_fish.ml.
@select(tangler("src/types_fish.ml"))
(* types_fish.ml -- types *)

open Primitive_fish


type arrayTyVar = ArrayTyVar of int | UserATV of string
and phraseTyVar = PhraseTyVar of int | UserPTV of string
;;

let tyVarCounter = ref 0
;;

let next_ty_count () = incr tyVarCounter;!tyVarCounter
;;

let next_array_tyvar() = ArrayTyVar (next_ty_count()) ;;
let next_phrase_tyvar() = PhraseTyVar (next_ty_count()) ;;

(* array type variables *)

module OrderedArrayTyVars = 
  struct 
    type t = arrayTyVar
  
        let compare v1 v2 =
      match (v1,v2) with 
          (ArrayTyVar x1,ArrayTyVar x2) -> compare x1 x2
        | (ArrayTyVar _,_) -> 1
        | (_,ArrayTyVar _) -> -1
        | (UserATV n1,UserATV n2) -> compare n1 n2 


  end;;

module ArrayTyVarSet = Set.Make(OrderedArrayTyVars);; 


let rec arrayVarListToSet vs =
 
 (* convert type scheme type variable binder list to Set *)

  match vs with
    [] -> ArrayTyVarSet.empty |
    v::tl -> ArrayTyVarSet.add v (arrayVarListToSet tl)
;;



(* phrase type variables *)

module OrderedPhraseTyVars = (* ordering on array type variables *)
  struct 
    type t = phraseTyVar
  
            let compare v1 v2 =
      match (v1,v2) with 
          (PhraseTyVar x1,PhraseTyVar x2) -> compare x1 x2
        | (PhraseTyVar _,_) -> 1
        | (_,PhraseTyVar _) -> -1
        | (UserPTV n1,UserPTV n2) -> compare n1 n2 

  end;;

module PhraseTyVarSet = Set.Make(OrderedPhraseTyVars);; 

let rec phraseVarListToSet vs =
 
 (* convert type scheme type variable binder list to Set *)

  match vs with
    [] -> PhraseTyVarSet.empty |
    v::tl -> PhraseTyVarSet.add v (phraseVarListToSet tl)
;;



(* Both kinds of type variables *)

type tyVarSet = Allvars of PhraseTyVarSet.t * ArrayTyVarSet.t
;;

let emptyTyVarSet = Allvars (PhraseTyVarSet.empty, ArrayTyVarSet.empty)
;;

let unionTyVarSet set1 set2 = 
  match set1,set2 with
  | Allvars (s11,s12) , Allvars (s21,s22) ->
      Allvars (
      PhraseTyVarSet.union s11 s21,
      ArrayTyVarSet.union  s12 s22)
;;

let diffTyVarSet set1 set2 = 
  match set1,set2 with
  | Allvars (s11,s12) , Allvars (s21,s22) ->
      Allvars (
      PhraseTyVarSet.diff s11 s21,
      ArrayTyVarSet.diff  s12 s22)
;;

let addPhraseVar tv set = 
  match set with 
  | Allvars (s1,s2) -> Allvars ((PhraseTyVarSet.add tv s1), s2)
;;

let addArrayVar tv set = 
  match set with 
  | Allvars (s1,s2) -> Allvars (s1, (ArrayTyVarSet.add tv s2))
;;

(* actual types *)


type arrayType =  

  (* array types *)
        
  | ArrayTV of arrayTyVar          (* alpha ::= X_alpha *)
  | DatumTy of prim_type           (* alpha ::= delta *)
  | ArrayTy of arrayType           (* alpha ::= [alpha] *)
        
and shapeType = 

  | StaticTy of prim_type          (* sigma ::= Stat delta *)
  | HashArrayTy of arrayType       (* sigma ::= #alpha *)

and dataType = 

  | AT of arrayType                (* tau ::= alpha *)
  | ShT of shapeType               (* tau ::= sigma *)

and phraseType =

  | PhraseTV of phraseTyVar        (* theta ::= X_theta *)
  | HashPhraseTy of phraseTyVar    (* theta ::= #X_theta *)
  | CommTy                         (* theta ::= comm *)
  | VarTy of arrayType             (* theta ::= var alpha *)
  | ExpTy of dataType              (* theta ::= exp tau *)
  | FunTy of phraseType * phraseType (* theta ::= theta -> theta *)


and fishTyScheme = 
    TyScheme of (phraseTyVar list) * (arrayTyVar list) * phraseType
;;

    
(* get all type variables in a type *)

let rec getTyVarsInArray ty =
  match ty with

  | ArrayTV  tv -> addArrayVar tv emptyTyVarSet
  | DatumTy _  -> emptyTyVarSet
  | ArrayTy ty'  -> getTyVarsInArray ty'
;;

let getTyVarsInShape ty = 
  match ty with 

  | StaticTy _ -> emptyTyVarSet
  | HashArrayTy ty'  -> getTyVarsInArray ty'
;;

let getTyVarsInData ty =
  match ty with 

  | AT ty' -> getTyVarsInArray ty'
  | ShT ty' -> getTyVarsInShape ty'
;;


let rec getTyVarsInPhrase ty =
  match ty with 

  | PhraseTV tv -> addPhraseVar tv emptyTyVarSet
  | HashPhraseTy tv -> addPhraseVar tv emptyTyVarSet
  | CommTy -> emptyTyVarSet
  | VarTy ty' -> getTyVarsInArray ty'
  | ExpTy ty' -> getTyVarsInData ty'
  | FunTy (ty1,ty2) ->
      unionTyVarSet 
        (getTyVarsInPhrase ty1) 
        (getTyVarsInPhrase ty2) 
;;

let isShapeTy ty = 
  match ty with 
    ExpTy (ShT _) -> true 
  | _ -> false 
;; 

let get_datum_ty ty = 
  match ty with 
    VarTy (DatumTy pty) -> pty 
  | ExpTy (AT (DatumTy pty)) -> pty
  | ExpTy (ShT (StaticTy pty)) -> pty 
  |  _ -> raise (Fish_error "not coerceable to exp of a datum type")

(* occurs check *)

let arrayVarOccursInArray tv ty =  
  let set = getTyVarsInArray ty in
  match set with 
  | Allvars (s1, s2) -> ArrayTyVarSet.mem tv s2
;;

let phraseVarOccursInPhrase tv ty =  
  let set = getTyVarsInPhrase ty in
  match set with 
  | Allvars (s1, s2) -> PhraseTyVarSet.mem tv s1
;;

(*
let arrayVarOccursInPhrase tv ty =  
  let set = getTyVarsArray ty in
  match set with 
  | Allvars (s1, s2) -> ArrayTyVarSet.mem tv s2
;;
*)


(* find free type variables in a type environment *)

let freeVarsInTyScheme (TyScheme (phvs,avs,ty)) =
  diffTyVarSet 
    (getTyVarsInPhrase ty) 
    (Allvars (phraseVarListToSet phvs, arrayVarListToSet avs))
;;


(* shape of phrase types *)

let rec shp ty =
  match ty with
    | PhraseTV tyv -> HashPhraseTy tyv
    | HashPhraseTy _ -> ty               
    | CommTy -> ExpTy (ShT(StaticTy BoolTy))
    | VarTy ty' -> ExpTy (ShT(HashArrayTy ty'))
    | ExpTy (AT ty') -> ExpTy (ShT(HashArrayTy ty') )
    | ExpTy (ShT _) -> ty
    | FunTy (ty',ty'') -> FunTy (shp ty',shp ty'')
;;




(* type sugar *)

let mk_datum_ty pty =
  ExpTy (AT(DatumTy pty))
;;

let int = mk_datum_ty IntTy;;
let bool = mk_datum_ty BoolTy;;
let float = mk_datum_ty FloatTy;; (* note this shadows Pervasives.float *)
let char = mk_datum_ty CharTy

let mk_static_ty pty =
  ExpTy (ShT(StaticTy pty))
;;

let size = mk_static_ty IntTy
let fact = mk_static_ty BoolTy
let cost = mk_static_ty FloatTy
let mark = mk_static_ty CharTy

let hashint = ExpTy (ShT (HashArrayTy (DatumTy IntTy)))
;;

let mk_data_ty (b,pty) = 
  if b then mk_datum_ty pty else mk_static_ty pty  
;;

let datumty pty = AT (DatumTy pty)
let arrayty ty = AT (ArrayTy ty)
let staticty pty = ShT (StaticTy pty)
let hasharrayty ty = ShT (HashArrayTy ty)
let commty = CommTy
let varty ty = VarTy ty
let expty ty = ExpTy ty
let funty ty1 ty2 = FunTy(ty1,ty2)
let funty3 ty1 ty2 ty3 = FunTy(ty1,funty ty2 ty3)
let funty4 ty1 ty2 ty3 ty4 = FunTy(ty1,funty3 ty2 ty3 ty4)


let hashphrasety ty = (* HashPhraseTy works on type variables, 
                         not types *)
  match ty with 
  |  PhraseTV tv -> HashPhraseTy tv 
  | _ -> raise (Fish_error "in hashphrasety")

let tysch vars1 vars2 ty = TyScheme(vars1,vars2,ty)


(* build type schemes with single type variable *)

let forall_U f = 
  let u = next_phrase_tyvar()
  in tysch [u] [] (f (PhraseTV u))

let forall_X f = 
  let x = next_array_tyvar()
  in tysch [] [x] (f (ArrayTV x))


(* build function type for primitive constants *)

let build_prim_const_type f p =
  let mk_exp ty = expty (f ty)
  in 
  let rec loop lst =
    match lst with
    | [] -> raise (Fish_error "in build_prim_const_type")
    | [ty] -> mk_exp ty
    | h::t -> funty (mk_exp h) (loop t)
  in
  loop (types_prim_constant p)
;;

let datum_prim_const_type p =
  build_prim_const_type datumty p

let shape_prim_const_type p =
  build_prim_const_type staticty p

@head(2,"type_subs_fish.ml")
type_subs_fish.ml.
@select(tangler("src/type_subs_fish.ml"))
(* type subsubstitutions *)

open Char
open List

open Types_fish
open Terms_fish
open Environments_fish

(* type substitutions *)

type array_tysub = (arrayTyVar * arrayType) list

type phrase_tysub = (phraseTyVar * phraseType) list
;;

(* Pairs of substitutions, from array type variables to arrays, and
phrase type variables to phrases *)

type tySub = BothSubs of (phrase_tysub * array_tysub)
;;

let addArrayTySub old gnu (BothSubs (sub1,sub2)) =
  BothSubs (sub1, (old,gnu) :: sub2)
;;

let addArrayTySubs gnu tysub = 
  let f sub x = addArrayTySub x gnu tysub in 
  fold_left f tysub 
;;

let addPhraseTySub old gnu (BothSubs (sub1,sub2)) = 
  BothSubs ((old,gnu) :: sub1, sub2)
;;

let addPhraseTySubs gnu tysub = 
  let f sub x = addPhraseTySub x gnu tysub in 
  fold_left f tysub 
;;


(* substitute new name for old in type variables in a type *)

let rec renameArrayTyVarsArray gnu old theType = 

  let rec renTV ty =
    match ty with

    | ArrayTV tv when (tv = old) -> 
      ArrayTV gnu
    | ArrayTy ty' -> ArrayTy (renTV ty') 
    | _ -> ty
  in

  renTV theType
;;

let renameArrayTyVarsShape gnu old theType = 
    match theType with

    | StaticTy _  -> theType 
    | HashArrayTy ty' -> 
        HashArrayTy (renameArrayTyVarsArray gnu old ty')
;;

let renameArrayTyVarsData gnu old theType = 
    match theType with

    | AT ty' -> AT (renameArrayTyVarsArray gnu old ty')
    | ShT ty' -> ShT (renameArrayTyVarsShape gnu old ty')
;;

let renamePhraseTyVarsPhrase gnu old theType = 

  let rec renTV ty =
    match ty with

    | PhraseTV tv when (tv = old) -> PhraseTV gnu
    | HashPhraseTy tv when (tv = old) -> HashPhraseTy gnu
    | FunTy (argTy,resultTy)->
        FunTy(renTV argTy,renTV resultTy)
    | _ -> ty
  in

  renTV theType
;;

let renameArrayTyVarsPhrase gnu old theType = 

  let rec renTV ty =
    match ty with

      VarTy ty' -> VarTy (renameArrayTyVarsArray gnu old ty')
    | ExpTy ty' -> ExpTy (renameArrayTyVarsData gnu old ty') 
    | FunTy (argTy,resultTy) ->
        FunTy(renTV argTy,renTV resultTy)
    | _ -> ty
  in

  renTV theType
;;

(* instantiate a type scheme by using fresh type variables *)

let rec inst_tyscheme tyscheme =
  match tyscheme with

  | TyScheme ([],[],ty) -> ty 
  | TyScheme ([],old::tl,ty) -> 
      let gnu = next_array_tyvar() in 
      inst_tyscheme 
        (TyScheme([],tl,renameArrayTyVarsPhrase gnu old ty))
  | TyScheme (old::tl,avs,ty) ->
      let gnu = next_phrase_tyvar() in 
      inst_tyscheme 
        (TyScheme(tl,avs,renamePhraseTyVarsPhrase gnu old ty)) 
;;

let rec applyArrayTySubArray tySub theType =
  
  let rec appTS ty =
    match ty with

    | ArrayTV tv -> 
        (try assoc tv tySub
        with Not_found -> ty) 
    | DatumTy _ -> ty 
    | ArrayTy ty' -> ArrayTy (appTS ty') 

  in appTS theType
;;

let applyArrayTySubShape tySub theType =
    match theType with

    | StaticTy _ -> theType 
    | HashArrayTy ty' -> HashArrayTy (applyArrayTySubArray tySub ty') 
;;

let applyArrayTySubData tySub theType =
      match theType with

      | AT ty' -> AT (applyArrayTySubArray tySub ty')
      | ShT ty' -> ShT (applyArrayTySubShape tySub ty')
;;

let applyArrayTySubPhrase tySub theType =

  let rec appTS ty =
    match ty with 

    | PhraseTV _ 
    | HashPhraseTy _ -> ty
    | CommTy -> ty
    | VarTy ty' -> VarTy(applyArrayTySubArray tySub ty')
    | ExpTy ty' -> ExpTy (applyArrayTySubData tySub ty')
    | FunTy (ty',ty'') -> FunTy (appTS ty',appTS ty'' ) 

  in appTS theType
;;

let applyPhraseTySubPhrase tySub theType =

  let rec appTS ty =
    match ty with 

    |  PhraseTV tv -> 
        (try assoc tv tySub
        with Not_found -> ty) 
    | HashPhraseTy tv -> 
      (try let ty' = assoc tv tySub
      in shp ty'
      with Not_found -> ty) 
    | CommTy 
    | VarTy _ 
    | ExpTy _ -> ty
    | FunTy (ty',ty'') -> FunTy (appTS ty',appTS ty'') 

  in appTS theType
;;

let applyTySub tySub ty = 
  match tySub with
  |  BothSubs(tySub1, tySub2) -> 
         applyArrayTySubPhrase tySub2 
        (applyPhraseTySubPhrase tySub1 ty)
;;


let alphaRenameTyScheme (TyScheme(phvs,avs,ty)) =
  let phvs' = List.map (fun x -> next_phrase_tyvar() ) phvs in 
  let avs' = List.map (fun x -> next_array_tyvar() ) avs in 
  let phvpairs = 
    List.combine phvs (List.map (fun v -> PhraseTV v) phvs') in 
  let avpairs = 
    List.combine avs (List.map (fun v -> ArrayTV v) avs') in 
  let tySub = ref (BothSubs ([],[])) in 
  let phraseUpdate (old,gnu) = 
    tySub := addPhraseTySub old gnu (!tySub) in 
  let arrayUpdate (old,gnu) = 
    tySub := addArrayTySub old gnu (!tySub) in 
  List.iter phraseUpdate phvpairs;
  List.iter arrayUpdate avpairs;
  TyScheme(phvs',avs', applyTySub (!tySub) ty)
;;

(* apply a type substitution to a type scheme *)

let applyTySubToTyScheme tySub tySch =
  let TyScheme(phvs,avs,ty) = alphaRenameTyScheme tySch
  in TyScheme(phvs,avs,applyTySub tySub ty)
;;

(* apply a type substitution to a type environment *)

let applyTySubToEnv tySub tyEnv =
  let newTyEnv = ref TyEnv.empty
  in let update x tySch = 
    newTyEnv := 
       TyEnv.add x (applyTySubToTyScheme tySub tySch) (!newTyEnv)
  in TyEnv.iter update tyEnv;
     !newTyEnv
;;


let applyTySubToTermVar tySub t = 
  match t with 
    TypedVar(x,ty) -> TypedVar(x,applyTySub tySub ty)
  | TypedMvar(x,ty) -> TypedMvar(x,applyTySub tySub ty)
  | _ -> t

let applyTySubToTerm tySub =

  let rec aux t = 
  (match t with 

    Tvar x -> Tvar (applyTySubToTermVar tySub x)
  | Apply(t1,t2) -> Apply(aux t1, aux t2)
  | Lam(x,t1) -> Lam(applyTySubToTermVar tySub x, aux t1)
  | Where(t1,x,t2) -> Where(aux t1, applyTySubToTermVar tySub x, aux t2)
  | Op(c,ts) -> Op(c,List.map aux ts)
  | Get(t1) -> Get(aux t1)
  | Sub(t1,t2) -> Sub(aux t1,aux t2)
  | Condsh(t1,t2,t3) -> Condsh (aux t1,aux t2,aux t3)
  | Cond(t1,t2,t3) -> Cond (aux t1,aux t2,aux t3)
  | Condexp(t1,t2,t3) -> Condexp (aux t1,aux t2,aux t3)
  | Typed(t1,ty) -> Typed(aux t1,applyTySub tySub ty)
  | _ -> t
  )
  in aux
;;

(* identity and composition of type substitutions *)   

let idTySub = BothSubs([],[])
;;

let o_phrase_ts ts1 ts2 = 
  let add_new_val (k,v) = 
    (k,applyPhraseTySubPhrase ts1 v) 
  in (map add_new_val ts2) @ ts1
;;

let o_array_ts ts1 ts2 = 
  let add_new_val (k,v) = 
    (k,applyArrayTySubArray ts1 v) 
  in (map add_new_val ts2) @ ts1
;;

let o_ts ts1 ts2 = 
  
(* o_ts produces the effect of ts2 followed by ts1.
   It is achieved by extending ts1 by substitutions on the domain of
   ts2, by iterating addNewVal over the graph of ts2.  Variables in
   range(ts2) and domain(ts1) are handled by "(applyTySub ts1 v)" below.
*)

  match (ts1,ts2) with
  | BothSubs (sub11,sub12), BothSubs (sub21,sub22) -> 
      BothSubs(o_phrase_ts sub11 sub21, o_array_ts sub12 sub22)
;;






@head(2,"unify_fish.ml")
unify_fish.ml.
@select(tangler("src/unify_fish.ml"))
(* unify_fish.ml *)

(* 

More or less the standard unification technique. Novelties arise due
to

1. the use of two kinds of type variables 

2. possible ambiguities when considering shapes of phrase variables

3. implicit coercions from var alpha to exp alpha, and static to dynamic. 

Ambiguities are handled by default choices. Alternatives must be
specified by explicit types in the program. 

makeUnifyList looks at one unification pair. unifyLoop uses this in
one step of a loop that passes through a list of unification pairs.

*)



open Primitive_fish
open Types_fish
open Type_subs_fish


exception Incompatible_datum_types of prim_type * prim_type 

exception Unify                                        (* internal *)
exception UnifyArrayError of arrayType * arrayType     (* external *)
exception UnifyPhraseError of phraseType * phraseType  (* external *)

exception OccursPhrase of phraseTyVar * phraseType     (* internal *)
exception OccursArray of arrayTyVar * arrayType        (* internal *)
exception OccursPhraseError of phraseType * phraseType (* external *) 
exception OccursArrayError of arrayType * arrayType    (* external *) 

let immediate = ([],idTySub)
let continue pairs = (pairs,idTySub)


let add_array_subst_check tv ty3 = 

           match ty3 with
           | ArrayTV tv' when tv = tv' -> immediate 
           | _ when arrayVarOccursInArray tv ty3 -> 
               raise (OccursArray (tv,ty3))
           | _ -> ([],addArrayTySub tv ty3 idTySub)

let add_phrase_subst_check tv ty3 = 

           match ty3 with
           | PhraseTV tv' when tv = tv' -> immediate 
           | _ when phraseVarOccursInPhrase tv ty3 -> 
               raise (OccursPhrase (tv,ty3))
           | _ -> ([],addPhraseTySub tv ty3 idTySub)

let datumUnify (x,y) = 
  if x = y                  (* || (x = IntTy && y = FloatTy) 
                               NO coercion from ints to floats *)
  then immediate 
  else raise (Incompatible_datum_types (x,y))
;;


let rec arrayUnify (ty,ty') = 
    match (ty,ty') with 

    | (ArrayTV x,_) -> add_array_subst_check x ty'      
    | (_,ArrayTV _) -> arrayUnify (ty',ty)
    | (DatumTy x,DatumTy y) ->  datumUnify (x,y)
    | (ArrayTy ty1,ArrayTy ty2) -> arrayUnify (ty1, ty2)
    |  _ -> raise (UnifyArrayError (ty,ty'))

let shapeUnify (ty,ty')  = 
    match (ty,ty') with 

    | (StaticTy x, StaticTy y) -> datumUnify (x,y)  

          (* coercions for size, #int etc *)

    | (StaticTy x, HashArrayTy y) -> 
        (match y with 
          ArrayTV _ -> arrayUnify (DatumTy x,y)  
        | DatumTy z -> datumUnify (x,z) 
        | _ -> raise Unify
        )
    | (HashArrayTy ty1,HashArrayTy ty2) -> arrayUnify (ty1, ty2) 
    |  _ -> raise Unify

let dataUnify (ty,ty') =
    match (ty,ty') with 

    | (AT ty1,AT ty2) -> arrayUnify (ty1,ty2) 
    | (ShT ty1,ShT ty2) -> shapeUnify (ty1,ty2)  

        (* coercions for size, int etc *)

    | (ShT (StaticTy ty1), AT ty2) -> 
        arrayUnify (DatumTy ty1, ty2) 

    | _ -> raise Unify


let rec makeUnifyList (ty,ty') = 

  match (ty,ty') with

(* type variable - type   *)
(* type - type variable *)
(* hash phrase type variable - type *)
(* type  - hash phrase type var *)
(* other cases *)

    | (PhraseTV tv,_) -> add_phrase_subst_check tv ty'  

    | (_,PhraseTV _) -> makeUnifyList (ty',ty)  

    | (HashPhraseTy tv, HashPhraseTy tv') -> 
        continue [ PhraseTV tv, PhraseTV tv' ]

    | (HashPhraseTy tv, ExpTy (ShT (StaticTy BoolTy))) -> 
        add_phrase_subst_check tv CommTy 

    | (HashPhraseTy tv, ExpTy (ShT (StaticTy _))) -> 
            ([], addPhraseTySub tv ty' idTySub)

    | (HashPhraseTy tv, ExpTy (ShT(HashArrayTy x))) -> 
        continue [ PhraseTV tv, ExpTy (AT x) ] 

    | (HashPhraseTy (PhraseTyVar x), FunTy (theta,theta')) 
            when (not (phraseVarOccursInPhrase (PhraseTyVar x) ty')) -> 
              let argVarName = next_phrase_tyvar()
              in let resVarName = next_phrase_tyvar()
              in  ( [ theta , 
                           HashPhraseTy argVarName;
                           HashPhraseTy resVarName ,
                           theta' 
                         ],
                   addPhraseTySub 
                     (PhraseTyVar x) 
                     (FunTy (PhraseTV argVarName,
                             PhraseTV resVarName))
                     idTySub )

    | (HashPhraseTy tv, _) -> raise (UnifyPhraseError (ty,ty'))

    | (t,HashPhraseTy _) ->  makeUnifyList (ty',ty)   


    | (ExpTy ty1,ExpTy ty2) -> dataUnify (ty1,ty2)  
    | (VarTy ty1,VarTy ty2) -> arrayUnify (ty1,ty2) 
                                       (*no coercions allowed *)
    | (CommTy,CommTy) -> immediate 
    | (FunTy (ty1,ty2),FunTy (ty3,ty4)) ->
                continue [(ty3,ty1) ; 
                          (ty2,ty4) ]

    (* coercions *)

    | (VarTy ty1,ExpTy ty2) -> dataUnify (AT ty1, ty2)  



    (* failure  *)

    | _ -> raise Unify
;;


let rec unifyLoop (toDo,tySub) =
   (* toDo is a list of unification pairs *)

  match toDo  with               

  | [] -> tySub 
  | (ty1,ty2)::rest  ->

      let (newToDo,newTySub) = 
        let ty3 = applyTySub tySub ty1 
        and ty4 = applyTySub tySub ty2 in 
        try makeUnifyList (ty3,ty4) 
        with
 
        | OccursPhrase (tv,ty) -> 
            raise (OccursPhraseError (PhraseTV tv,ty))
        | OccursArray (tv,ty) -> 
            raise (OccursArrayError (ArrayTV tv,ty))
        | _ -> raise (UnifyPhraseError (ty3,ty4))

      in 
      unifyLoop (newToDo @ rest, o_ts newTySub tySub)
;;



