@head(1,'FISh 1.6')
Derived from Barry Jays FISh 1.6 language with permission
to release under Felix FFAU licence.

@select(tangler("licences/fish_licence.txt",'data'))
(C) Copyright 1998, C. Barry Jay
Derived from Barry Jays FISh 1.6 language with permission
to redistribute for any use.

@head(2,"primitive_fish.mli")
primitive_fish.mli.
@select(tangler("src/primitive_fish.mli"))
exception Fish_error of string
type prim_type = | IntTy | BoolTy | FloatTy | CharTy
type prim_value = | Int of int | Bool of bool | Float of float | Char of char
type prim_constant =
  | Prim_value of prim_value
  | Pconst of prim_type list * bool * string
val string_of_prim_type : prim_type -> string
val string_of_static_prim_type : prim_type -> string
val type_prim_value : prim_value -> prim_type
val types_prim_constant : prim_constant -> prim_type list
val return_type_prim_constant : prim_constant -> prim_type
val string_of_prim_value : prim_value -> string
val is_polymorphic : string -> bool
val instantiate_polymorphic_op : string -> prim_type -> string
val prim_int_negative : prim_constant
val prim_float_negative : prim_constant
val prim_int_plus : prim_constant
val prim_int_times : prim_constant
val prim_int_minus : prim_constant
val prim_int_divide : prim_constant
val prim_int_modulo : prim_constant
val prim_int_equal : prim_constant
val prim_int_less_than : prim_constant
val prim_int_less_than_or_equal : prim_constant
val prim_int_greater_than : prim_constant
val prim_int_greater_than_or_equal : prim_constant
val prim_int2float : prim_constant
val prim_float_plus : prim_constant
val prim_float_times : prim_constant
val prim_float_minus : prim_constant
val prim_float_divide : prim_constant
val prim_float_equal : prim_constant
val prim_float_less_than : prim_constant
val prim_float_less_than_or_equal : prim_constant
val prim_float_greater_than : prim_constant
val prim_float_greater_than_or_equal : prim_constant
val prim_not : prim_constant
val prim_and : prim_constant
val prim_or : prim_constant
val prim_bool_equal : prim_constant
val prim_bool_less_than : prim_constant
val prim_bool_less_than_or_equal : prim_constant
val prim_bool_greater_than : prim_constant
val prim_bool_greater_than_or_equal : prim_constant
val prim_char_equal : prim_constant
val prim_char_less_than : prim_constant
val prim_char_less_than_or_equal : prim_constant
val prim_char_greater_than : prim_constant
val prim_char_greater_than_or_equal : prim_constant
val mk_mathop_1 : string -> prim_constant
val mk_mathop_2 : string -> prim_constant
val prim_acos : prim_constant
val prim_asin : prim_constant
val prim_atan : prim_constant
val prim_ceil : prim_constant
val prim_cos : prim_constant
val prim_cosh : prim_constant
val prim_exp : prim_constant
val prim_fabs : prim_constant
val prim_floor : prim_constant
val prim_log : prim_constant
val prim_log10 : prim_constant
val prim_sin : prim_constant
val prim_sinh : prim_constant
val prim_sqrt : prim_constant
val prim_tan : prim_constant
val prim_tanh : prim_constant
val prim_truncate : prim_constant
val prim_atan2 : prim_constant
val prim_fmod : prim_constant
val prim_pow : prim_constant
val apply_delta : prim_constant -> prim_value list -> prim_value

@head(2,"primitive_fish.ml")
primitive_fish.ml.
@select(tangler("src/primitive_fish.ml"))
(* Primitive Fish Datum Operations and Relations *)
 

(* Other files containing information about primitives:

 - turbot2C_fish.ml: 

   c_string_for_prim_type 
   c_prim_type_bytes
   c_print_prim_value 
   c_print_bang

*)


exception Fish_error of string;;

type prim_type = 
    IntTy 
  | BoolTy 
  | FloatTy 
  | CharTy
;;

type prim_value =
    Int of int
  | Bool of bool
  | Float of float
  | Char of char
;;

type prim_constant =
    Prim_value of prim_value 
  | Pconst of prim_type list * bool * string  
;;

(* holds type info, static flag (always true at present), name and name in C.  *)


(* names of types *)

let string_of_prim_type ty = 
  match ty with
    IntTy -> "int"
  | BoolTy -> "bool"
  | FloatTy -> "float"
  | CharTy -> "char"
;;

let string_of_static_prim_type ty = 
  match ty with
    IntTy -> "size"
  | BoolTy -> "fact"
  | FloatTy -> "cost"
  | CharTy -> "mark"
;;



(* map prim_values to prim_types *)

let type_prim_value v =
  match v with
    Int _ -> IntTy
  | Float _ -> FloatTy
  | Bool _ -> BoolTy
  | Char _ -> CharTy
;;

let types_prim_constant c = 
  match c with 
    Prim_value v -> [type_prim_value v] 
  | Pconst (tys,_,_) -> tys
;;

let return_type_prim_constant c = 
  List.hd (List.rev (types_prim_constant c));;

let string_of_prim_value v = 
  match v with
    Int n -> string_of_int n 
  | Bool b -> if b then "true" else "false"
  | Float f -> string_of_float f 
  | Char c -> "'c'" 
;;



(* pconst definitions *)

(* construction tools *)

let mk_uss ty name  =  
  (* unary, single-sorted operations *)
  Pconst ([ty;ty],true,name);;

let mk_int_uss = mk_uss IntTy;; 
let mk_float_uss = mk_uss FloatTy;; 
let mk_bool_uss = mk_uss BoolTy ;;

let mk_bss ty name = 
  (* binary, single-sorted operations *)
  Pconst ([ty;ty;ty],true,name)

let mk_int_bss = mk_bss IntTy;; 
let mk_float_bss = mk_bss FloatTy;; 
let mk_bool_bss = mk_bss BoolTy;;
let mk_char_bss = mk_bss CharTy;; 

let mk_rss ty name = 
  (* single-sorted relations *)
  Pconst ([ty;ty;BoolTy],true,name);;

let mk_int_rss = mk_rss IntTy;;
let mk_float_rss = mk_rss FloatTy;;
let mk_char_rss = mk_rss CharTy;; 


(* ad hoc polymorphism *)

let is_polymorphic x = 
  List.mem x ["+" ; "*" ; "-" ; "=" ; "<" ; "<=" ; ">" ; ">=" ] ;;

let instantiate_polymorphic_op name pty = 
  name ^ (
    if is_polymorphic name
    then 
      match pty with 
        IntTy -> ""
      | FloatTy -> "."
      | BoolTy -> "b"
      | CharTy -> "c"
    else ""
        )
    

(* integer examples *)

let prim_int_negative = mk_int_uss "-" ;;
      (* Use the argument list to determine the status of "-" *)
let prim_float_negative = mk_float_uss "-." ;;

let prim_int_plus = mk_int_bss "+" ;;
let prim_int_times = mk_int_bss "*" ;;
let prim_int_minus = mk_int_bss "-" ;;
let prim_int_divide = mk_int_bss "div" ;;
let prim_int_modulo = mk_int_bss "mod" ;;


let prim_int_equal = mk_int_rss "=" ;;
let prim_int_less_than = mk_int_rss "<" ;;
let prim_int_less_than_or_equal = mk_int_rss "<=" ;;
let prim_int_greater_than = mk_int_rss ">" ;;
let prim_int_greater_than_or_equal = mk_int_rss ">=" ;;

let prim_int2float = 
  Pconst ([IntTy;FloatTy],true,"int2float");;

(* float examples *)

let prim_float_plus = mk_float_bss "+." ;;
let prim_float_times = mk_float_bss "*." ;;
let prim_float_minus = mk_float_bss "-." ;;
let prim_float_divide = mk_float_bss "/." ;;

let prim_float_equal = mk_float_rss "=." ;;
let prim_float_less_than = mk_float_rss "<." ;;
let prim_float_less_than_or_equal = mk_float_rss "<=." ;;
let prim_float_greater_than = mk_float_rss ">." ;;
let prim_float_greater_than_or_equal = mk_float_rss ">=." ;;


(* boolean examples *)

let prim_not = mk_bool_uss "not"  ;;
let prim_and = mk_bool_bss "&&" ;;
let prim_or  = mk_bool_bss "||" ;;

let prim_bool_equal                 = mk_bool_bss "=b"  ;;
let prim_bool_less_than             = mk_bool_bss "<b"  ;;
let prim_bool_less_than_or_equal    = mk_bool_bss "<=b" ;;
let prim_bool_greater_than          = mk_bool_bss ">b"  ;;
let prim_bool_greater_than_or_equal = mk_bool_bss ">=b" ;;

(* character examples *)

let prim_char_equal                 = mk_char_rss "=c"  ;;
let prim_char_less_than             = mk_char_rss "<c"  ;;
let prim_char_less_than_or_equal    = mk_char_rss "<=c" ;;
let prim_char_greater_than          = mk_char_rss ">c"  ;;
let prim_char_greater_than_or_equal = mk_char_rss ">=c" ;;



(* maths operations *)

(* Currently, these operations will all be performed statically, if
possible. Set the boolean flag to false to force run-time computation.
*)

let mk_mathop_1 name = 
  Pconst ([FloatTy;FloatTy],true,name);;
let mk_mathop_2 name = 
  Pconst ([FloatTy;FloatTy;FloatTy],true,name);;

let prim_acos = mk_mathop_1 "acos" ;;
let prim_asin = mk_mathop_1 "asin" ;;
let prim_atan = mk_mathop_1 "atan" ;;
let prim_ceil = mk_mathop_1 "ceil" ;;
let prim_cos  = mk_mathop_1 "cos"  ;;
let prim_cosh = mk_mathop_1 "cosh" ;;
let prim_exp  = mk_mathop_1 "exp"  ;;
let prim_fabs = mk_mathop_1 "fabs" ;;
let prim_floor= mk_mathop_1 "floor";;
let prim_log  = mk_mathop_1 "log"  ;;
let prim_log10= mk_mathop_1 "log10";;
let prim_sin  = mk_mathop_1 "sin"  ;;
let prim_sinh = mk_mathop_1 "sinh" ;;
let prim_sqrt = mk_mathop_1 "sqrt" ;;
let prim_tan  = mk_mathop_1 "tan"  ;;
let prim_tanh = mk_mathop_1 "tanh" ;;

let prim_truncate = Pconst ([FloatTy;IntTy],true,"truncate");;

let prim_atan2= mk_mathop_2 "atan2";;
let prim_fmod = mk_mathop_2 "fmod" ;;
let prim_pow  = mk_mathop_2 "pow"  ;;

(* delta rules - for evaluating primitive operationsn statically *)

let apply_delta dconst args = 

  match dconst with

    Prim_value _ -> raise (Fish_error "invalid primitive application")

  | Pconst (_,_,s) -> 

      match (s,args) with

      (* integer ops *)
            
      |        "-",  [Int m]       -> Int (- m)
      | "+",  [Int m;Int n] -> Int(m + n) 
      | "*",  [Int m;Int n] -> Int(m * n) 
      | "-",  [Int m;Int n] -> Int(m - n) 
      | "div",[Int m;Int n] -> Int(m / n) 
      | "mod",[Int m;Int n] -> Int(m mod n)
            
     (* integer rels *)
            
      | "=",  [Int m;Int n] -> Bool (m = n) 
      | "=",  [Int m;Float n] -> Bool (float m = n) 
      | "=",  [Bool m;Bool n] -> Bool (m = n) 
      | "=",  [Char m;Char n] -> Bool (m = n) 
      | "<",  [Int m;Int n] -> Bool (m < n) 
      | "<",  [Float m;Float n] -> Bool (m <  n) 
      | "<",  [Bool m;Bool n] -> Bool (m < n) 
      | "<",  [Char m;Char n] -> Bool (m < n) 
      | "<=", [Int m;Int n] -> Bool (m <= n) 
      | "<=", [Float m;Float n] -> Bool (m <=  n) 
      | "<=", [Bool m;Bool n] -> Bool (m <= n) 
      | "<=", [Char m;Char n] -> Bool (m <= n) 
      | ">",  [Int m;Int n] -> Bool (m > n) 
      | ">",  [Float m;Float n] -> Bool (m >  n) 
      | ">",  [Bool m;Bool n] -> Bool (m > n) 
      | ">",  [Char m;Char n] -> Bool (m > n) 
      | ">=", [Int m;Int n] -> Bool (m >= n) 
      | ">=", [Float m;Float n] -> Bool (m >=  n) 
      | ">=", [Bool m;Bool n] -> Bool (m >= n) 
      | ">=", [Char m;Char n] -> Bool (m >= n) 
            
     (* float ops *)

      |        "-.",  [Float m]         -> Float (-. m) 
      |        "+.",  [Float m;Float n] -> Float (m +. n) 
      |        "-.",  [Float m;Float n] -> Float (m -. n) 
      |        "*.",  [Float m;Float n] -> Float (m *. n) 
      |        "/.",  [Float m;Float n] -> Float (m /. n) 

      (* float rels *)

      |        "=.",  [Float m;Float n] -> Bool (m = n) 
      |        "<.",  [Float m;Float n] -> Bool (m < n) 
      |        "<=.", [Float m;Float n] -> Bool (m <= n) 
      |        ">.",  [Float m;Float n] -> Bool (m > n) 
      |        ">=.", [Float m;Float n] -> Bool (m >= n) 

      (* bool ops *)
            
      | "not", [Bool m]        -> Bool (not m)
      | "&&",  [Bool m;Bool n] -> Bool (m & n) 
      | "||",  [Bool m;Bool n] -> Bool (m or n)

      |        "=b",  [Bool m;Bool n] -> Bool (m = n) 
      |        "<b",  [Bool m;Bool n] -> Bool (m < n) 
      |        "<=b", [Bool m;Bool n] -> Bool (m <= n) 
      |        ">b",  [Bool m;Bool n] -> Bool (m > n) 
      |        ">=b", [Bool m;Bool n] -> Bool (m >= n) 

      (* char ops *)

      |        "=c",  [Char m;Char n] -> Bool (m = n) 
      |        "<c",  [Char m;Char n] -> Bool (m < n) 
      |        "<=c", [Char m;Char n] -> Bool (m <= n) 
      |        ">c",  [Char m;Char n] -> Bool (m > n) 
      |        ">=c", [Char m;Char n] -> Bool (m >= n) 



      (* mixed-sort *)
            
      | "int2float",[Int n] -> Float (Pervasives.float n)

      (* math ops *)
            
      | "acos", [Float n] -> Float (acos n)
      | "asin", [Float n] -> Float (asin n)
      | "atan", [Float n] -> Float (atan n)
      |        "atan2",[Float m;Float n] 
                          -> Float (atan (m/.n))
      | "ceil", [Float n] -> Float (ceil n)
      | "cos",  [Float n] -> Float (cos n)
      | "cosh", [Float n] -> Float (cosh n)
      | "exp",  [Float n] -> Float (exp n)
      | "fabs", [Float n] -> Float (abs_float n)
      | "floor",[Float n] -> Float (floor n)
      | "fmod", [Float m;Float n] 
                          -> Float (mod_float m n)
      | "log",  [Float n] -> Float (log n)
      | "log10",[Float n] -> Float (log10 n)
      | "pow",  [Float m;Float n] 
                          -> Float (m**n)
      | "sin",  [Float n] -> Float (sin n)
      | "sinh", [Float n] -> Float (sinh n)
      | "sqrt", [Float n] -> Float (sqrt n)
      | "tan",  [Float n] -> Float (tan n)
      | "tanh", [Float n] -> Float (tanh n)

      |        "truncate",[Float n] -> Int (truncate n)    

      | _ -> raise (Fish_error "invalid primitive application")
;;
 
      (* end of delta rules *)
            
@head(2,"types_fish.mli")
types_fish.mli.
@select(tangler("src/types_fish.mli"))
type arrayTyVar = | ArrayTyVar of int | UserATV of string
type phraseTyVar = | PhraseTyVar of int | UserPTV of string
val next_ty_count : unit -> int
val next_array_tyvar : unit -> arrayTyVar
val next_phrase_tyvar : unit -> phraseTyVar
module OrderedArrayTyVars :
  sig type t = arrayTyVar val compare : arrayTyVar -> arrayTyVar -> int end
module ArrayTyVarSet :
  sig
    type elt = OrderedArrayTyVars.t
    type t = Set.Make(OrderedArrayTyVars).t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val cardinal : t -> int
    val elements : t -> elt list
    val choose : t -> elt
  end
module OrderedPhraseTyVars :
  sig
    type t = phraseTyVar
    val compare : phraseTyVar -> phraseTyVar -> int
  end
module PhraseTyVarSet :
  sig
    type elt = OrderedPhraseTyVars.t
    type t = Set.Make(OrderedPhraseTyVars).t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val cardinal : t -> int
    val elements : t -> elt list
    val choose : t -> elt
  end
type tyVarSet = | Allvars of PhraseTyVarSet.t * ArrayTyVarSet.t
val emptyTyVarSet : tyVarSet
val unionTyVarSet : tyVarSet -> tyVarSet -> tyVarSet
val diffTyVarSet : tyVarSet -> tyVarSet -> tyVarSet
type arrayType =
  | ArrayTV of arrayTyVar
  | DatumTy of Primitive_fish.prim_type
  | ArrayTy of arrayType
type shapeType =
  | StaticTy of Primitive_fish.prim_type
  | HashArrayTy of arrayType
type dataType = | AT of arrayType | ShT of shapeType
type phraseType =
  | PhraseTV of phraseTyVar
  | HashPhraseTy of phraseTyVar
  | CommTy
  | VarTy of arrayType
  | ExpTy of dataType
  | FunTy of phraseType * phraseType
type fishTyScheme =
  | TyScheme of phraseTyVar list * arrayTyVar list * phraseType
val getTyVarsInPhrase : phraseType -> tyVarSet
val isShapeTy : phraseType -> bool
val get_datum_ty : phraseType -> Primitive_fish.prim_type
val arrayVarOccursInArray : ArrayTyVarSet.elt -> arrayType -> bool
val phraseVarOccursInPhrase : PhraseTyVarSet.elt -> phraseType -> bool
val freeVarsInTyScheme : fishTyScheme -> tyVarSet
val shp : phraseType -> phraseType
val mk_datum_ty : Primitive_fish.prim_type -> phraseType
val int : phraseType
val bool : phraseType
val float : phraseType
val char : phraseType
val mk_static_ty : Primitive_fish.prim_type -> phraseType
val size : phraseType
val fact : phraseType
val cost : phraseType
val mark : phraseType
val hashint : phraseType
val mk_data_ty : bool * Primitive_fish.prim_type -> phraseType
val datumty : Primitive_fish.prim_type -> dataType
val arrayty : arrayType -> dataType
val staticty : Primitive_fish.prim_type -> dataType
val hasharrayty : arrayType -> dataType
val commty : phraseType
val varty : arrayType -> phraseType
val expty : dataType -> phraseType
val funty : phraseType -> phraseType -> phraseType
val funty3 : phraseType -> phraseType -> phraseType -> phraseType
val funty4 :
  phraseType -> phraseType -> phraseType -> phraseType -> phraseType
val hashphrasety : phraseType -> phraseType
val tysch : phraseTyVar list -> arrayTyVar list -> phraseType -> fishTyScheme
val forall_U : (phraseType -> phraseType) -> fishTyScheme
val forall_X : (arrayType -> phraseType) -> fishTyScheme
val build_prim_const_type :
  (Primitive_fish.prim_type -> dataType) ->
  Primitive_fish.prim_constant -> phraseType
val datum_prim_const_type : Primitive_fish.prim_constant -> phraseType
val shape_prim_const_type : Primitive_fish.prim_constant -> phraseType

@head(2,"types_fish.ml")
types_fish.ml.
@select(tangler("src/types_fish.ml"))
(* types_fish.ml -- types *)

open Primitive_fish


type arrayTyVar = ArrayTyVar of int | UserATV of string
and phraseTyVar = PhraseTyVar of int | UserPTV of string
;;

let tyVarCounter = ref 0
;;

let next_ty_count () = incr tyVarCounter;!tyVarCounter
;;

let next_array_tyvar() = ArrayTyVar (next_ty_count()) ;;
let next_phrase_tyvar() = PhraseTyVar (next_ty_count()) ;;

(* array type variables *)

module OrderedArrayTyVars = 
  struct 
    type t = arrayTyVar
  
        let compare v1 v2 =
      match (v1,v2) with 
          (ArrayTyVar x1,ArrayTyVar x2) -> compare x1 x2
        | (ArrayTyVar _,_) -> 1
        | (_,ArrayTyVar _) -> -1
        | (UserATV n1,UserATV n2) -> compare n1 n2 


  end;;

module ArrayTyVarSet = Set.Make(OrderedArrayTyVars);; 


let rec arrayVarListToSet vs =
 
 (* convert type scheme type variable binder list to Set *)

  match vs with
    [] -> ArrayTyVarSet.empty |
    v::tl -> ArrayTyVarSet.add v (arrayVarListToSet tl)
;;



(* phrase type variables *)

module OrderedPhraseTyVars = (* ordering on array type variables *)
  struct 
    type t = phraseTyVar
  
            let compare v1 v2 =
      match (v1,v2) with 
          (PhraseTyVar x1,PhraseTyVar x2) -> compare x1 x2
        | (PhraseTyVar _,_) -> 1
        | (_,PhraseTyVar _) -> -1
        | (UserPTV n1,UserPTV n2) -> compare n1 n2 

  end;;

module PhraseTyVarSet = Set.Make(OrderedPhraseTyVars);; 

let rec phraseVarListToSet vs =
 
 (* convert type scheme type variable binder list to Set *)

  match vs with
    [] -> PhraseTyVarSet.empty |
    v::tl -> PhraseTyVarSet.add v (phraseVarListToSet tl)
;;



(* Both kinds of type variables *)

type tyVarSet = Allvars of PhraseTyVarSet.t * ArrayTyVarSet.t
;;

let emptyTyVarSet = Allvars (PhraseTyVarSet.empty, ArrayTyVarSet.empty)
;;

let unionTyVarSet set1 set2 = 
  match set1,set2 with
  | Allvars (s11,s12) , Allvars (s21,s22) ->
      Allvars (
      PhraseTyVarSet.union s11 s21,
      ArrayTyVarSet.union  s12 s22)
;;

let diffTyVarSet set1 set2 = 
  match set1,set2 with
  | Allvars (s11,s12) , Allvars (s21,s22) ->
      Allvars (
      PhraseTyVarSet.diff s11 s21,
      ArrayTyVarSet.diff  s12 s22)
;;

let addPhraseVar tv set = 
  match set with 
  | Allvars (s1,s2) -> Allvars ((PhraseTyVarSet.add tv s1), s2)
;;

let addArrayVar tv set = 
  match set with 
  | Allvars (s1,s2) -> Allvars (s1, (ArrayTyVarSet.add tv s2))
;;

(* actual types *)


type arrayType =  

  (* array types *)
        
  | ArrayTV of arrayTyVar          (* alpha ::= X_alpha *)
  | DatumTy of prim_type           (* alpha ::= delta *)
  | ArrayTy of arrayType           (* alpha ::= [alpha] *)
        
and shapeType = 

  | StaticTy of prim_type          (* sigma ::= Stat delta *)
  | HashArrayTy of arrayType       (* sigma ::= #alpha *)

and dataType = 

  | AT of arrayType                (* tau ::= alpha *)
  | ShT of shapeType               (* tau ::= sigma *)

and phraseType =

  | PhraseTV of phraseTyVar        (* theta ::= X_theta *)
  | HashPhraseTy of phraseTyVar    (* theta ::= #X_theta *)
  | CommTy                         (* theta ::= comm *)
  | VarTy of arrayType             (* theta ::= var alpha *)
  | ExpTy of dataType              (* theta ::= exp tau *)
  | FunTy of phraseType * phraseType (* theta ::= theta -> theta *)


and fishTyScheme = 
    TyScheme of (phraseTyVar list) * (arrayTyVar list) * phraseType
;;

    
(* get all type variables in a type *)

let rec getTyVarsInArray ty =
  match ty with

  | ArrayTV  tv -> addArrayVar tv emptyTyVarSet
  | DatumTy _  -> emptyTyVarSet
  | ArrayTy ty'  -> getTyVarsInArray ty'
;;

let getTyVarsInShape ty = 
  match ty with 

  | StaticTy _ -> emptyTyVarSet
  | HashArrayTy ty'  -> getTyVarsInArray ty'
;;

let getTyVarsInData ty =
  match ty with 

  | AT ty' -> getTyVarsInArray ty'
  | ShT ty' -> getTyVarsInShape ty'
;;


let rec getTyVarsInPhrase ty =
  match ty with 

  | PhraseTV tv -> addPhraseVar tv emptyTyVarSet
  | HashPhraseTy tv -> addPhraseVar tv emptyTyVarSet
  | CommTy -> emptyTyVarSet
  | VarTy ty' -> getTyVarsInArray ty'
  | ExpTy ty' -> getTyVarsInData ty'
  | FunTy (ty1,ty2) ->
      unionTyVarSet 
        (getTyVarsInPhrase ty1) 
        (getTyVarsInPhrase ty2) 
;;

let isShapeTy ty = 
  match ty with 
    ExpTy (ShT _) -> true 
  | _ -> false 
;; 

let get_datum_ty ty = 
  match ty with 
    VarTy (DatumTy pty) -> pty 
  | ExpTy (AT (DatumTy pty)) -> pty
  | ExpTy (ShT (StaticTy pty)) -> pty 
  |  _ -> raise (Fish_error "not coerceable to exp of a datum type")

(* occurs check *)

let arrayVarOccursInArray tv ty =  
  let set = getTyVarsInArray ty in
  match set with 
  | Allvars (s1, s2) -> ArrayTyVarSet.mem tv s2
;;

let phraseVarOccursInPhrase tv ty =  
  let set = getTyVarsInPhrase ty in
  match set with 
  | Allvars (s1, s2) -> PhraseTyVarSet.mem tv s1
;;

(*
let arrayVarOccursInPhrase tv ty =  
  let set = getTyVarsArray ty in
  match set with 
  | Allvars (s1, s2) -> ArrayTyVarSet.mem tv s2
;;
*)


(* find free type variables in a type environment *)

let freeVarsInTyScheme (TyScheme (phvs,avs,ty)) =
  diffTyVarSet 
    (getTyVarsInPhrase ty) 
    (Allvars (phraseVarListToSet phvs, arrayVarListToSet avs))
;;


(* shape of phrase types *)

let rec shp ty =
  match ty with
    | PhraseTV tyv -> HashPhraseTy tyv
    | HashPhraseTy _ -> ty               
    | CommTy -> ExpTy (ShT(StaticTy BoolTy))
    | VarTy ty' -> ExpTy (ShT(HashArrayTy ty'))
    | ExpTy (AT ty') -> ExpTy (ShT(HashArrayTy ty') )
    | ExpTy (ShT _) -> ty
    | FunTy (ty',ty'') -> FunTy (shp ty',shp ty'')
;;




(* type sugar *)

let mk_datum_ty pty =
  ExpTy (AT(DatumTy pty))
;;

let int = mk_datum_ty IntTy;;
let bool = mk_datum_ty BoolTy;;
let float = mk_datum_ty FloatTy;; (* note this shadows Pervasives.float *)
let char = mk_datum_ty CharTy

let mk_static_ty pty =
  ExpTy (ShT(StaticTy pty))
;;

let size = mk_static_ty IntTy
let fact = mk_static_ty BoolTy
let cost = mk_static_ty FloatTy
let mark = mk_static_ty CharTy

let hashint = ExpTy (ShT (HashArrayTy (DatumTy IntTy)))
;;

let mk_data_ty (b,pty) = 
  if b then mk_datum_ty pty else mk_static_ty pty  
;;

let datumty pty = AT (DatumTy pty)
let arrayty ty = AT (ArrayTy ty)
let staticty pty = ShT (StaticTy pty)
let hasharrayty ty = ShT (HashArrayTy ty)
let commty = CommTy
let varty ty = VarTy ty
let expty ty = ExpTy ty
let funty ty1 ty2 = FunTy(ty1,ty2)
let funty3 ty1 ty2 ty3 = FunTy(ty1,funty ty2 ty3)
let funty4 ty1 ty2 ty3 ty4 = FunTy(ty1,funty3 ty2 ty3 ty4)


let hashphrasety ty = (* HashPhraseTy works on type variables, 
                         not types *)
  match ty with 
  |  PhraseTV tv -> HashPhraseTy tv 
  | _ -> raise (Fish_error "in hashphrasety")

let tysch vars1 vars2 ty = TyScheme(vars1,vars2,ty)


(* build type schemes with single type variable *)

let forall_U f = 
  let u = next_phrase_tyvar()
  in tysch [u] [] (f (PhraseTV u))

let forall_X f = 
  let x = next_array_tyvar()
  in tysch [] [x] (f (ArrayTV x))


(* build function type for primitive constants *)

let build_prim_const_type f p =
  let mk_exp ty = expty (f ty)
  in 
  let rec loop lst =
    match lst with
    | [] -> raise (Fish_error "in build_prim_const_type")
    | [ty] -> mk_exp ty
    | h::t -> funty (mk_exp h) (loop t)
  in
  loop (types_prim_constant p)
;;

let datum_prim_const_type p =
  build_prim_const_type datumty p

let shape_prim_const_type p =
  build_prim_const_type staticty p



@head(2,"terms_fish.mli")
terms_fish.mli.
@select(tangler("src/terms_fish.mli"))
exception NoType
type term_variable =
  | Var of string
  | TypedVar of string * Types_fish.phraseType
  | Mvar of int
  | TypedMvar of int * Types_fish.phraseType
module Ordered_vars :
  sig
    type t = term_variable
    val compare : term_variable -> term_variable -> int
  end
val nextvar : unit -> term_variable
val nextTypedVar : Types_fish.phraseType -> term_variable
val var2string : term_variable -> string
val raw : term_variable -> term_variable
val declaredType : term_variable -> Types_fish.phraseType
val offerVarTy : term_variable -> term_variable
val assertIntTy : term_variable -> term_variable
type fish_term =
  | Tvar of term_variable
  | Apply of fish_term * fish_term
  | Lam of term_variable * fish_term
  | Where of fish_term * term_variable * fish_term
  | Op of Primitive_fish.prim_constant * fish_term list 
  | Get of fish_term
  | Sub of fish_term * fish_term
  | Condsh of fish_term * fish_term * fish_term
  | Cond of fish_term * fish_term * fish_term
  | Condexp of fish_term * fish_term * fish_term
  | Typed of fish_term * Types_fish.phraseType
  | Skip
  | Abort
  | Assign
  | Seq
  | Forall
  | Whiletrue
  | Fix of int
  | Newvar
  | Output
  | Dyn of Primitive_fish.prim_type
  | Newexp
  | Bang of Primitive_fish.prim_type
  | Zerodim
  | Succdim
  | Undim
  | Lendim
  | Preddim
  | Numdim
  | Equal
  | Primrec
  | Error
  | Shape
exception Shape_error of fish_term list * string
val isBang : fish_term -> bool
val shape2Pair : fish_term -> int list list * Primitive_fish.prim_type
val fishShape2Pair : fish_term -> fish_term list list * fish_term
val fishPair2Shape : fish_term list list * fish_term -> fish_term
val combinator_tyscheme : fish_term -> Types_fish.fishTyScheme

@head(2,"terms_fish.ml")
terms_fish.ml.
@select(tangler("src/terms_fish.ml"))
(* 
        The Fish Terms 
        ===============

*)

open List
open Primitive_fish
open Types_fish

exception NoType ;;


type term_variable =
    Var of string                     (* user variables *)
  | TypedVar of string * phraseType  (* ... with type *)
  | Mvar of int                      (* machine variables *)
  | TypedMvar of int * phraseType    (* ... with type *)

module Ordered_vars =                (* term variables *)
  struct 
    type t = term_variable

    let compare v1 v2 =
      match (v1,v2) with 
          (Var x1,Var x2) -> compare x1 x2
        | (Var _,_) -> 1
        | (_,Var _) -> -1
        | (TypedVar (x1,_),TypedVar (x2,_)) -> compare x1 x2 
                                          (* don't check types *)
        | (TypedVar _,_) -> 1
        | (_,TypedVar _) -> -1
        | (Mvar x1,Mvar x2) -> compare x1 x2
        | (Mvar _,_) -> 1
        | (_,Mvar _) -> -1
        | (TypedMvar (n1,_),TypedMvar (n2,_)) -> compare n1 n2 
                                          (* don't check types *)

  end
;;

let fvc = ref 0 (* free variable counter *)

let nextvar() = incr fvc ; Mvar !fvc ;;
let nextTypedVar ty = incr fvc ; TypedMvar (!fvc,ty) ;;

let var2string x = 
  match x with
    Var y -> y
  | TypedVar (y,ty) -> y
  | Mvar n -> "mvar_" ^ (string_of_int n)
  | TypedMvar (n,ty) -> "mvar_" ^ (string_of_int n)

;;

let raw x = 
  match x with
    TypedVar (y,ty) -> Var y
  | TypedMvar (n,ty) -> Mvar n
  | _ -> x
;;

let declaredType x =
   match x with
    TypedVar (y,ty) -> ty
  | TypedMvar (n,ty) -> ty
  | _ -> raise NoType
;;

let offerVarTy x = 
  let aty = next_array_tyvar() in 
  let ty = VarTy (ArrayTV aty) in 
  match x with
    Var y -> TypedVar(y,ty)
  | Mvar y -> TypedMvar(y,ty)
  | _ -> x
;;


let assertIntTy x = 
  match x with 
    Var y         -> TypedVar(y,int)
  | TypedVar(y,_) -> TypedVar(y,int)
  | Mvar y        -> TypedMvar(y,int)
  | TypedMvar(y,_)-> TypedMvar(y,int)


type fish_term = (* constants listed last due to sheer number *)

        (* term and phrase variables *)

        | Tvar of term_variable

        (* application *)

        | Apply of fish_term * fish_term

        (* functions *)

        | Lam of term_variable * fish_term

        (* polymorphic binding construct *)   

        | Where of fish_term * term_variable * fish_term

        (* constructors *)

        | Op of prim_constant * fish_term list 

        | Get of fish_term

        | Sub of fish_term * fish_term 

         | Condsh of fish_term * fish_term * fish_term (* shape conditional *)

         | Cond of fish_term * fish_term * fish_term (* commands *)

         | Condexp of fish_term * fish_term * fish_term (* expressions *)

        | Typed of fish_term * phraseType  

        (* constants by type class *)

        (* commands *)

        | Skip
        | Abort
        | Assign
        | Seq
        | Forall
        | Whiletrue
        | Fix of int  (* the int is the number of parameters 
                         to the procedure, 
                         currently only 0 is supported below! *)
        | Newvar
        | Output


        (* array expressions *)

        | Dyn of prim_type
        | Newexp

        (* shape expression *)

        | Bang of prim_type
        | Zerodim
        | Succdim
        | Undim
        | Lendim
        | Preddim
        | Numdim
        | Equal    (* on array shapes:  #a -> #a -> fact *)


        (* phrase polymorphic terms *)
     
        | Primrec
        | Error
        | Shape
;;


exception Shape_error of fish_term list * string


(* predicates and selectors, some used in turbot2C, not well-structured *)

let isBang shape =
  match shape with
    Bang _ -> true |
    _ -> false
;;


let pair_from_shape f sh =

  let rec loop sh =

    match sh with

      Bang ty -> 
        ([],ty)

    | Apply (Zerodim,sh') -> 
        let (lst,b) = loop sh'
        in ([]::lst,b)

    | Apply (Apply (Succdim,x), sh') ->
        (let pr = loop sh'
        in match pr with
          (h::rest,d) -> 
            (((f x)::h)::rest,d)
        | _ -> raise (Fish_error "in pair_from_shape:1")
        )
          
    | _ -> raise (Shape_error ([sh],"is not an array shape"))

  in loop sh
    
;;
    

let mk_int_from_shape t = 
  match t with
    Op (Prim_value (Int n),[]) -> n
  | _ -> raise (Fish_error "in mk_int_from_shape") 
and mk_fish_from_shape t = t


let shape2Pair = pair_from_shape mk_int_from_shape
and fishShape2Pair sh = 
  match pair_from_shape mk_fish_from_shape sh with 
    (lst,b) -> (lst, Bang b)
;;

let shape_from_pair f (lst,b) =
  let rec loop lst b =
    match lst with
      [] -> b
    | h::t -> 
        List.fold_right f h (Apply(Zerodim,loop t b))
  in loop lst b
;;



let mk_shape_with_int x y = 
  Apply(Apply(Succdim,Op (Prim_value (Int x),[])),y)
and mk_shape_with_fish x y = 
  Apply(Apply(Succdim,x),y)

let fishPair2Shape = shape_from_pair mk_shape_with_fish


(* combinator types and type schemes *)

let combinator_tyscheme comb =           
  match comb with 

    Skip -> tysch [] [] commty 

  | Abort -> tysch [] [] commty 

  | Assign -> forall_X (fun x -> 
      funty3 (varty x) (expty (AT x)) commty)

  | Seq -> tysch [] [] (funty3 commty commty commty)

  | Forall -> tysch [] [] (funty4 int int (funty int commty) commty)

  | Whiletrue -> tysch [] [] (funty3 bool commty commty)

  | Fix k ->  
      let rec f n = 
        (match n with 
          _ when n<0 -> raise (Fish_error "negative argument to fix") 
        | 0 -> commty
        | _ -> 
            funty (ExpTy (AT (ArrayTV(next_array_tyvar())))) (f (n-1))
        ) in 
      let x = f k in 
      tysch [] [] (funty (funty x x) x) 
              (* this should be a proper tyscheme for k>0!!*)

  | Newvar -> forall_X (fun x -> 
    funty3 (expty (hasharrayty x)) (funty (varty x) commty) commty)

  | Output -> forall_X (fun x -> 
      funty (expty (AT x)) commty)

  | Dyn pty -> tysch [] [] (
      funty 
        (ExpTy (ShT (StaticTy pty))) 
        (ExpTy (AT  (DatumTy  pty))) 
        )                              

  | Newexp -> forall_X (fun x -> 
      funty3 
        (expty (hasharrayty x)) 
        (funty (varty x) commty) 
        (expty (AT x)))

  | Bang pty -> tysch [] [] (ExpTy (ShT (HashArrayTy (DatumTy pty))))

  | Zerodim -> forall_X (fun x -> 
      funty (expty (hasharrayty x)) (expty (hasharrayty (ArrayTy x))))

  | Succdim -> forall_X (fun x -> 
    let ty = expty (hasharrayty (ArrayTy x)) in 
    funty3 size ty ty)

  | Undim -> forall_X (fun x -> 
    let ty = expty (hasharrayty (ArrayTy x)) in 
    funty ty (expty (hasharrayty x)))

  | Lendim -> forall_X (fun x -> 
      let ty = expty (hasharrayty (ArrayTy x)) in 
      funty ty size)

  | Preddim -> forall_X (fun x -> 
      let ty = expty (hasharrayty (ArrayTy x)) in 
      funty ty ty )

  | Numdim -> forall_X (fun x -> 
    funty (expty (hasharrayty (ArrayTy x))) size)

  | Equal -> forall_X (fun x -> 
      funty3 
        (expty (hasharrayty x))
        (expty (hasharrayty x)) 
        fact)

  | Primrec -> forall_U (fun u -> 
      funty4 (funty3 size u u) u size u)

  | Error -> forall_U (fun u ->
    u)

  | Shape -> forall_U (fun u ->
      funty u (hashphrasety u))

  | _ -> raise (Fish_error "not a combinator")


@head(2,"sugar_fish.mli")
sugar_fish.mli.
@select(tangler("src/sugar_fish.mli"))
val int_shape : Terms_fish.fish_term
val bool_shape : Terms_fish.fish_term
val float_shape : Terms_fish.fish_term
val tvar : string -> Terms_fish.fish_term
val mvar : int -> Terms_fish.fish_term
val ap : Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val ap2 :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val ap3 :
  Terms_fish.fish_term ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val ap4 :
  Terms_fish.fish_term ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val lam :
  Terms_fish.term_variable -> Terms_fish.fish_term -> Terms_fish.fish_term
val get_term : unit -> Terms_fish.fish_term
val get : Terms_fish.fish_term -> Terms_fish.fish_term
val condsh_term : Terms_fish.fish_term
val condsh :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val cond_term : Terms_fish.fish_term
val cond :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val condexp_term : Terms_fish.fish_term
val condexp :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val skip : Terms_fish.fish_term
val abort : Terms_fish.fish_term
val assign :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val seq :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val forall :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val whiletrue :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val fix : int -> Terms_fish.fish_term -> Terms_fish.fish_term
val newvar :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val output : Terms_fish.fish_term -> Terms_fish.fish_term
val var2exp_term : unit -> Terms_fish.fish_term
val var2exp : unit -> Terms_fish.fish_term -> Terms_fish.fish_term
val prim_true : Primitive_fish.prim_constant
val prim_false : Primitive_fish.prim_constant
val prim_zero : Primitive_fish.prim_constant
val prim_one : Primitive_fish.prim_constant
val prim_int : int -> Primitive_fish.prim_constant
val prim_char : char -> Primitive_fish.prim_constant
val newexp :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val bang : Primitive_fish.prim_type -> Terms_fish.fish_term
val zerodim : Terms_fish.fish_term -> Terms_fish.fish_term
val succdim :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val undim : Terms_fish.fish_term -> Terms_fish.fish_term
val lendim : Terms_fish.fish_term -> Terms_fish.fish_term
val preddim : Terms_fish.fish_term -> Terms_fish.fish_term
val numdim : Terms_fish.fish_term -> Terms_fish.fish_term
val equal :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val primrec :
  Terms_fish.fish_term ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val shape : Terms_fish.fish_term -> Terms_fish.fish_term
val null : Terms_fish.fish_term -> Terms_fish.fish_term
val len : Terms_fish.fish_term -> Terms_fish.fish_term
val is_length : Terms_fish.fish_term -> Terms_fish.fish_term
val ent_shape : Terms_fish.fish_term -> Terms_fish.fish_term
val check :
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val bang_term : unit -> Terms_fish.fish_term
val identity : Terms_fish.fish_term
val wf : Terms_fish.fish_term -> Terms_fish.fish_term
val exp2comm : Terms_fish.fish_term
val multilam :
  Terms_fish.term_variable list ->
  Terms_fish.fish_term -> Terms_fish.fish_term
val multiseq : Terms_fish.fish_term list -> Terms_fish.fish_term


@head(2,"sugar_fish.ml")
sugar_fish.ml.
@select(tangler("src/sugar_fish.ml"))
(* sugar_fish.ml -- syntactic sugar for internal FiSh compiler use *)

open Primitive_fish
open Types_fish
open Terms_fish

let int_shape   = Bang IntTy;;
let bool_shape  = Bang BoolTy;;
let float_shape = Bang FloatTy;;

(* contractions of lambda calculus *)

let tvar x = Tvar (Var x)
let mvar x = Tvar (Mvar x)
let ap f x = Apply(f,x)
let ap2 f x y = ap (ap f x) y
let ap3 f x y z = ap (ap2 f x y) z
let ap4 f x y z t = ap (ap3 f x y z) t
let lam x y = Lam(x,y)


(* contractions of constructors *)

let get_term() =   (* for var types *)
  let ty = ArrayTV (next_array_tyvar()) in 
  let x = TypedVar("x",VarTy(ArrayTy ty)) in 
  lam x (Get(Tvar x))
let get = ap (get_term())

let condsh_term = 
  let x = Var "x"
  and y = Var "y"
  and z = Var "z" in 
  lam x (lam y (lam z ( Condsh(Tvar x,Tvar y,Tvar z))))
let condsh x y z = Condsh(x,y,z)

let cond_term = 
  let x = Var "x"
  and y = Var "y"
  and z = Var "z" in 
  lam x (lam y (lam z ( Cond(Tvar x,Tvar y,Tvar z))))
let cond x y z = Cond(x,y,z)

let condexp_term = 
  let x = Var "x"
  and y = Var "y"
  and z = Var "z" in 
  lam x (lam y (lam z ( Condexp(Tvar x,Tvar y,Tvar z))))
let condexp x y z = Condexp(x,y,z)

(* contractions of constants *)

let skip = Skip
let abort = Abort
let assign = ap2 Assign
let seq = ap2 Seq
let forall = ap3 Forall 
let whiletrue = ap2 Whiletrue 
let fix k = ap (Fix k)
let newvar = ap2 Newvar 
let output = ap Output

let var2exp_term() = 
  let aty = ArrayTV (next_array_tyvar()) in 
  lam (TypedVar ("x", VarTy     aty )) 
  (Tvar(TypedVar ("x", ExpTy (AT aty))))
let var2exp() = ap (var2exp_term())
let prim_true = Prim_value (Bool true) 
let prim_false = Prim_value (Bool false)
let prim_zero = Prim_value (Int 0)
let prim_one = Prim_value (Int 1)
let prim_int n = Prim_value (Int n)
let prim_char c = Prim_value (Char c)
let newexp = ap2 Newexp

let bang ty = Bang ty 
let zerodim = ap Zerodim
let succdim = ap2 Succdim 
let undim = ap Undim
let lendim = ap Lendim
let preddim = ap Preddim
let numdim = ap Numdim
let equal = ap2 Equal

let primrec = ap3 Primrec
let shape = ap Shape

(* null is only for creating array expressions - not functions etc *)

let null sh = 
  let ty = ArrayTV (next_array_tyvar()) in 
  let x = TypedVar("x",VarTy(ArrayTy ty)) in 
  newexp sh (lam x skip)

(* other *)

let len t = lendim (shape t)
let is_length x = Op(prim_int_greater_than_or_equal, 
                     [x; Op(prim_zero,[])])
let ent_shape t = preddim (shape t)
let check x y   = Condsh(x,y,Error)

let bang_term() =   
  let ty = ArrayTV (next_array_tyvar()) in 
  let x  = TypedVar("x",VarTy ty) in 
  lam x (Typed(Tvar x, ExpTy(AT ty)))


let identity = lam (Var "x") (tvar "x")
let wf x =  equal x x 

let exp2comm = 
  lam (Var "x") 
    (newvar (shape (tvar "x"))
      (lam (Var "y") (assign (tvar "y") (tvar "x"))))

let multilam = List.fold_right lam ;;
let multiseq ts = List.fold_right seq ts skip ;;

@head(2,"environments_fish.mli")
environments_fish.mli.
@select(tangler("src/environments_fish.mli"))
module TyEnv :
  sig
    type key = Terms_fish.Ordered_vars.t
    type 'a t = 'a Map.Make(Terms_fish.Ordered_vars).t
    val empty : 'a t
    val add : key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  end
type shapeEnv =
  (Terms_fish.term_variable * (Terms_fish.fish_term * Terms_fish.fish_term))
  list
type globalEnv =
  (Terms_fish.term_variable *
   (Types_fish.phraseType * Terms_fish.fish_term * Terms_fish.fish_term))
  list
val getFreeTyVars : Types_fish.fishTyScheme TyEnv.t -> Types_fish.tyVarSet
val closTy :
  Types_fish.phraseType ->
  Types_fish.fishTyScheme TyEnv.t -> Types_fish.fishTyScheme
val global2type : (TyEnv.key * ('a * 'b * 'c)) list -> 'a TyEnv.t
val global2shape : ('a * ('b * 'c * 'd)) list -> ('a * ('c * 'd)) list


@head(2,"environments_fish.ml")
environments_fish.ml.
@select(tangler("src/environments_fish.ml"))
(* type environments and all stuff required before parsing *)

open List

open Primitive_fish
open Types_fish
open Terms_fish

module TyEnv = Map.Make(Ordered_vars) (* for type environments *)

type globalEnv = 
    (term_variable * (phraseType * fish_term * fish_term)) list
;;

(*
These are used to house all type and shape information about
variables. To each variable is associated its 

  type, 
  shape and 
  (partially evaluated) term.

*)

type shapeEnv = (term_variable * (fish_term * fish_term)) list
;;

(* Shape environments, used in partial evaluation. 
   To each variable is associated its 
   
   shape and 
   (partially evaluated) term.
*) 



(* type environments *)


let getFreeTyVars tyEnv =
  let theVars = ref emptyTyVarSet in 
  let doEntry _ tyScheme = 
    theVars := unionTyVarSet 
                 (freeVarsInTyScheme tyScheme) 
                 (!theVars)
  in 
    TyEnv.iter doEntry tyEnv;
    !theVars
;;
    

(* close a type in a type environment *)

let closTy ty tyEnv =
  let tyVars = getTyVarsInPhrase ty
  and freeTyVars = getFreeTyVars tyEnv
  in let boundTyVarSet = diffTyVarSet tyVars freeTyVars
  in 
  match boundTyVarSet with 
  | Allvars (s1,s2) -> 
      TyScheme (
      PhraseTyVarSet.elements s1, 
      ArrayTyVarSet.elements s2,
      ty)
;;


(* global environments *)

let global2type glEnv = 
  let f (x,(y,_,_)) tyEnv  = TyEnv.add x y tyEnv 
  in 
    fold_right f glEnv TyEnv.empty
;;

let global2shape glEnv = 
  let f (x,(_,y,z)) = (x,(y,z)) 
  in 
    map f glEnv
;;

@head(2,"type_subs_fish.mli")
type_subs_fish.mli.
@select(tangler("src/type_subs_fish.mli"))
type array_tysub = (Types_fish.arrayTyVar * Types_fish.arrayType) list
type phrase_tysub = (Types_fish.phraseTyVar * Types_fish.phraseType) list
type tySub = | BothSubs of (phrase_tysub * array_tysub)
val addArrayTySub :
  Types_fish.arrayTyVar -> Types_fish.arrayType -> tySub -> tySub
val addArrayTySubs :
  Types_fish.arrayType -> tySub -> Types_fish.arrayTyVar list -> tySub
val addPhraseTySub :
  Types_fish.phraseTyVar -> Types_fish.phraseType -> tySub -> tySub
val addPhraseTySubs :
  Types_fish.phraseType -> tySub -> Types_fish.phraseTyVar list -> tySub
val inst_tyscheme : Types_fish.fishTyScheme -> Types_fish.phraseType
val applyTySub : tySub -> Types_fish.phraseType -> Types_fish.phraseType
val applyTySubToTyScheme :
  tySub -> Types_fish.fishTyScheme -> Types_fish.fishTyScheme
val applyTySubToEnv :
  tySub ->
  Types_fish.fishTyScheme Environments_fish.TyEnv.t ->
  Types_fish.fishTyScheme Environments_fish.TyEnv.t
val applyTySubToTermVar :
  tySub -> Terms_fish.term_variable -> Terms_fish.term_variable
val applyTySubToTerm : tySub -> Terms_fish.fish_term -> Terms_fish.fish_term
val idTySub : tySub
val o_ts : tySub -> tySub -> tySub


@head(2,"type_subs_fish.ml")
type_subs_fish.ml.
@select(tangler("src/type_subs_fish.ml"))
(* type subsubstitutions *)

open Char
open List

open Types_fish
open Terms_fish
open Environments_fish

(* type substitutions *)

type array_tysub = (arrayTyVar * arrayType) list

type phrase_tysub = (phraseTyVar * phraseType) list
;;

(* Pairs of substitutions, from array type variables to arrays, and
phrase type variables to phrases *)

type tySub = BothSubs of (phrase_tysub * array_tysub)
;;

let addArrayTySub old gnu (BothSubs (sub1,sub2)) =
  BothSubs (sub1, (old,gnu) :: sub2)
;;

let addArrayTySubs gnu tysub = 
  let f sub x = addArrayTySub x gnu tysub in 
  fold_left f tysub 
;;

let addPhraseTySub old gnu (BothSubs (sub1,sub2)) = 
  BothSubs ((old,gnu) :: sub1, sub2)
;;

let addPhraseTySubs gnu tysub = 
  let f sub x = addPhraseTySub x gnu tysub in 
  fold_left f tysub 
;;


(* substitute new name for old in type variables in a type *)

let rec renameArrayTyVarsArray gnu old theType = 

  let rec renTV ty =
    match ty with

    | ArrayTV tv when (tv = old) -> 
      ArrayTV gnu
    | ArrayTy ty' -> ArrayTy (renTV ty') 
    | _ -> ty
  in

  renTV theType
;;

let renameArrayTyVarsShape gnu old theType = 
    match theType with

    | StaticTy _  -> theType 
    | HashArrayTy ty' -> 
        HashArrayTy (renameArrayTyVarsArray gnu old ty')
;;

let renameArrayTyVarsData gnu old theType = 
    match theType with

    | AT ty' -> AT (renameArrayTyVarsArray gnu old ty')
    | ShT ty' -> ShT (renameArrayTyVarsShape gnu old ty')
;;

let renamePhraseTyVarsPhrase gnu old theType = 

  let rec renTV ty =
    match ty with

    | PhraseTV tv when (tv = old) -> PhraseTV gnu
    | HashPhraseTy tv when (tv = old) -> HashPhraseTy gnu
    | FunTy (argTy,resultTy)->
        FunTy(renTV argTy,renTV resultTy)
    | _ -> ty
  in

  renTV theType
;;

let renameArrayTyVarsPhrase gnu old theType = 

  let rec renTV ty =
    match ty with

      VarTy ty' -> VarTy (renameArrayTyVarsArray gnu old ty')
    | ExpTy ty' -> ExpTy (renameArrayTyVarsData gnu old ty') 
    | FunTy (argTy,resultTy) ->
        FunTy(renTV argTy,renTV resultTy)
    | _ -> ty
  in

  renTV theType
;;

(* instantiate a type scheme by using fresh type variables *)

let rec inst_tyscheme tyscheme =
  match tyscheme with

  | TyScheme ([],[],ty) -> ty 
  | TyScheme ([],old::tl,ty) -> 
      let gnu = next_array_tyvar() in 
      inst_tyscheme 
        (TyScheme([],tl,renameArrayTyVarsPhrase gnu old ty))
  | TyScheme (old::tl,avs,ty) ->
      let gnu = next_phrase_tyvar() in 
      inst_tyscheme 
        (TyScheme(tl,avs,renamePhraseTyVarsPhrase gnu old ty)) 
;;

let rec applyArrayTySubArray tySub theType =
  
  let rec appTS ty =
    match ty with

    | ArrayTV tv -> 
        (try assoc tv tySub
        with Not_found -> ty) 
    | DatumTy _ -> ty 
    | ArrayTy ty' -> ArrayTy (appTS ty') 

  in appTS theType
;;

let applyArrayTySubShape tySub theType =
    match theType with

    | StaticTy _ -> theType 
    | HashArrayTy ty' -> HashArrayTy (applyArrayTySubArray tySub ty') 
;;

let applyArrayTySubData tySub theType =
      match theType with

      | AT ty' -> AT (applyArrayTySubArray tySub ty')
      | ShT ty' -> ShT (applyArrayTySubShape tySub ty')
;;

let applyArrayTySubPhrase tySub theType =

  let rec appTS ty =
    match ty with 

    | PhraseTV _ 
    | HashPhraseTy _ -> ty
    | CommTy -> ty
    | VarTy ty' -> VarTy(applyArrayTySubArray tySub ty')
    | ExpTy ty' -> ExpTy (applyArrayTySubData tySub ty')
    | FunTy (ty',ty'') -> FunTy (appTS ty',appTS ty'' ) 

  in appTS theType
;;

let applyPhraseTySubPhrase tySub theType =

  let rec appTS ty =
    match ty with 

    |  PhraseTV tv -> 
        (try assoc tv tySub
        with Not_found -> ty) 
    | HashPhraseTy tv -> 
      (try let ty' = assoc tv tySub
      in shp ty'
      with Not_found -> ty) 
    | CommTy 
    | VarTy _ 
    | ExpTy _ -> ty
    | FunTy (ty',ty'') -> FunTy (appTS ty',appTS ty'') 

  in appTS theType
;;

let applyTySub tySub ty = 
  match tySub with
  |  BothSubs(tySub1, tySub2) -> 
         applyArrayTySubPhrase tySub2 
        (applyPhraseTySubPhrase tySub1 ty)
;;


let alphaRenameTyScheme (TyScheme(phvs,avs,ty)) =
  let phvs' = List.map (fun x -> next_phrase_tyvar() ) phvs in 
  let avs' = List.map (fun x -> next_array_tyvar() ) avs in 
  let phvpairs = 
    List.combine phvs (List.map (fun v -> PhraseTV v) phvs') in 
  let avpairs = 
    List.combine avs (List.map (fun v -> ArrayTV v) avs') in 
  let tySub = ref (BothSubs ([],[])) in 
  let phraseUpdate (old,gnu) = 
    tySub := addPhraseTySub old gnu (!tySub) in 
  let arrayUpdate (old,gnu) = 
    tySub := addArrayTySub old gnu (!tySub) in 
  List.iter phraseUpdate phvpairs;
  List.iter arrayUpdate avpairs;
  TyScheme(phvs',avs', applyTySub (!tySub) ty)
;;

(* apply a type substitution to a type scheme *)

let applyTySubToTyScheme tySub tySch =
  let TyScheme(phvs,avs,ty) = alphaRenameTyScheme tySch
  in TyScheme(phvs,avs,applyTySub tySub ty)
;;

(* apply a type substitution to a type environment *)

let applyTySubToEnv tySub tyEnv =
  let newTyEnv = ref TyEnv.empty
  in let update x tySch = 
    newTyEnv := 
       TyEnv.add x (applyTySubToTyScheme tySub tySch) (!newTyEnv)
  in TyEnv.iter update tyEnv;
     !newTyEnv
;;


let applyTySubToTermVar tySub t = 
  match t with 
    TypedVar(x,ty) -> TypedVar(x,applyTySub tySub ty)
  | TypedMvar(x,ty) -> TypedMvar(x,applyTySub tySub ty)
  | _ -> t

let applyTySubToTerm tySub =

  let rec aux t = 
  (match t with 

    Tvar x -> Tvar (applyTySubToTermVar tySub x)
  | Apply(t1,t2) -> Apply(aux t1, aux t2)
  | Lam(x,t1) -> Lam(applyTySubToTermVar tySub x, aux t1)
  | Where(t1,x,t2) -> Where(aux t1, applyTySubToTermVar tySub x, aux t2)
  | Op(c,ts) -> Op(c,List.map aux ts)
  | Get(t1) -> Get(aux t1)
  | Sub(t1,t2) -> Sub(aux t1,aux t2)
  | Condsh(t1,t2,t3) -> Condsh (aux t1,aux t2,aux t3)
  | Cond(t1,t2,t3) -> Cond (aux t1,aux t2,aux t3)
  | Condexp(t1,t2,t3) -> Condexp (aux t1,aux t2,aux t3)
  | Typed(t1,ty) -> Typed(aux t1,applyTySub tySub ty)
  | _ -> t
  )
  in aux
;;

(* identity and composition of type substitutions *)   

let idTySub = BothSubs([],[])
;;

let o_phrase_ts ts1 ts2 = 
  let add_new_val (k,v) = 
    (k,applyPhraseTySubPhrase ts1 v) 
  in (map add_new_val ts2) @ ts1
;;

let o_array_ts ts1 ts2 = 
  let add_new_val (k,v) = 
    (k,applyArrayTySubArray ts1 v) 
  in (map add_new_val ts2) @ ts1
;;

let o_ts ts1 ts2 = 
  
(* o_ts produces the effect of ts2 followed by ts1.
   It is achieved by extending ts1 by substitutions on the domain of
   ts2, by iterating addNewVal over the graph of ts2.  Variables in
   range(ts2) and domain(ts1) are handled by "(applyTySub ts1 v)" below.
*)

  match (ts1,ts2) with
  | BothSubs (sub11,sub12), BothSubs (sub21,sub22) -> 
      BothSubs(o_phrase_ts sub11 sub21, o_array_ts sub12 sub22)
;;


@head(2,"substitution_fish.mli")
substitution_fish.mli.
@select(tangler("src/substitution_fish.mli"))
module Term_subst :
  sig
    type key = Terms_fish.Ordered_vars.t
    type 'a t = 'a Map.Make(Terms_fish.Ordered_vars).t
    val empty : 'a t
    val add : key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  end
val id_term_subst : 'a Term_subst.t
val substitute :
  Term_subst.key ->
  Terms_fish.fish_term -> Terms_fish.fish_term -> Terms_fish.fish_term
val free_vars : Terms_fish.fish_term -> Terms_fish.term_variable list
val incrStringCounter : string -> char -> char -> string
val list_diff : 'a list -> 'a list -> 'a list
val tidy_term : Terms_fish.fish_term -> Terms_fish.fish_term


@head(2,"substitution_fish.ml")
substitution_fish.ml.
@select(tangler("src/substitution_fish.ml"))
(*

        Substitution
        ============


substitute0 applies a substitution while respecting bound variables.

substitute is the external version. 

rename_variable replaces a variable by its image under the
substitution, if applicable, and leaves it unchanged otherwise.

apply_term_subst applies a substitution to *all* variables, both free
and bound.


variables_in produces a list of free and of bound variables. 

*) 

open Char
open List

open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish

module Term_subst = Map.Make(Ordered_vars)

let id_term_subst = Term_subst.empty 
;;


let rec substitute0 term_subst  =
  let rec sub (term:fish_term) = 
    match term with 

     Tvar z -> 
       (try (Term_subst.find (raw z) term_subst) 
       with Not_found -> term)
         
       (* Assume that any given type for z matches that of the
          substitution!  This may lose type information about the
          declared type of the variable z. *)
        
    | Apply (a,b) -> Apply(sub a,sub b)

    | Lam(z,t) -> 
        let z' = 
          (try nextTypedVar (declaredType z)
           with NoType -> nextvar() 
          ) in 
        let ts = Term_subst.add (raw z) (Tvar z') term_subst
        in 
        Lam(z',substitute0 ts t)        
        
    | Op(c,ts) -> Op(c, List.map sub ts)

    | Get t -> Get (sub t) 

    | Sub (t1,t2) -> Sub (sub t1,sub t2) 

    | Condsh(t1,t2,t3) -> Condsh (sub t1, sub t2, sub t3) 

    | Cond(t1,t2,t3) -> Cond (sub t1, sub t2, sub t3) 

    | Condexp(t1,t2,t3) -> Condexp (sub t1, sub t2, sub t3) 

    | Where(a,z,d) -> 
        let z' = 
          (try nextTypedVar (declaredType z)
           with NoType -> nextvar()
          ) in 
        let ts = Term_subst.add (raw z) (Tvar z') term_subst
        in 
        Where (substitute0 ts a,z',sub d) 

    | Typed(t,ty) -> Typed(sub t,ty) 

    |  _ -> term

  in sub ;;

  (* end *) 

let substitute x term1 term2 =  
  substitute0
    (Term_subst.add (raw x) term1 id_term_subst) 
    term2 
;;


(* these functions are used for pretty-printing *)

let rename_variable term_subst x =      
        try 
            match Term_subst.find (raw x) term_subst with
                  Tvar y -> y
                | _ -> x

        with Not_found -> x 
;;

let rec apply_term_subst term_subst = 
            (* this is used to produce turbot. 
               We strip  off explicit type declarations. *)

  let rv = rename_variable term_subst
  in 

  let rec ats (term:fish_term) =
    match term with 

      Tvar z -> 
        (try Term_subst.find (raw z) term_subst
            with Not_found -> term )

    | Apply (a,b) -> Apply(ats a,ats b)

    | Lam(z,t) -> Lam (rv z ,ats t)     

    | Op(c,ts) -> Op(c, List.map ats ts)

    | Get t -> Get (ats t) 

    | Sub (t1,t2) -> Sub (ats t1, ats t2) 

    | Condsh (t0,t1,t2) -> Condsh (ats t0, ats t1, ats t2)

    | Cond (t0,t1,t2) -> Cond (ats t0, ats t1, ats t2)

    | Condexp (t0,t1,t2) -> Condexp (ats t0, ats t1, ats t2)

    | Where(a,b,d) -> Where (ats a,
                             rv b,
                             ats d
                               ) 

    | Typed(t,ty) -> Typed(ats t,ty)
        
    | _ -> term

  in ats 
;;



let rec variables_in term = var_in [] [] term

and var_in free bound t =       (*   vi t        *)

 let rec vi t = 

      match t with 

          Tvar x -> 
            if mem (raw x) bound        
            then (free, bound)
            else (raw x::free, bound)

        | Apply(t1,t2) -> vin [t1;t2]

        | Lam(x,t) -> var_in free (raw x::bound) t

        | Op(c, ts) -> vin ts

        | Get t -> vi t

        | Sub (t1,t2) -> vin [t1;t2]

        | Condsh (t1,t2,t3) -> vin [t1;t2;t3]

        | Cond (t1,t2,t3) -> vin [t1;t2;t3]

        | Condexp (t1,t2,t3) -> vin [t1;t2;t3]

        | Where(t2,x,t1) -> bind x t1 t2 
              
        | Typed(t,ty) -> vi t

        | _ -> finished

  (* end vi *)

  and finished = (free,bound)
  and vi2 (t1,t2) = 
        let (f1,b1) = vi t1 
        and (f2,b2) = vi t2 
        in (f1@f2, b1@b2)

  and f1 (x,y) t = 
     let (z,w) = vi t in 
     (x@z,y@w) 

  and vin ts1 = List.fold_left f1 ([],[]) ts1
 
  and bind x t1 t2 =
        let (f1,b1) = var_in free (raw x::bound) t1
        and (f2,b2) = vi t2
        in (f1@f2,b1@b2)


  in vi t
;;


(* free variables with no duplicates *)


let remove_duplicates xs = (* removes duplicate items in a list *)

  let rec rd xs ys = 
    match xs with
          [] -> ys
        | x::xs' ->     if List.mem x ys 
                        then rd xs' ys 
                        else rd xs' (x::ys)
  in rd xs []
;;


let free_vars t = let (raw_fvs,_) = variables_in t
                in remove_duplicates raw_fvs 
;;

(* getTermVarsInLeafOrder takes a fish_term, and returns 

   a list of variables in leaf order, except for-bound variables

   paired with 

   the term where the for-bound variables have been
   renamed according to their nesting level

   NB: it's possible that a term has variables with
   the same names in distinct scopes, which identification
   is preserved after tidying -- not an error, just confusing
   to the reader

*)

(* string_fish.ml -- string primitives *)

let incrStringCounter ctr minc maxc = (* for incrementing term and type variables *)
  let ndx = ref (String.length ctr - 1)
  and flag = ref false
  and newCtr = String.copy ctr
  in 
  while (!ndx >= 0 & !flag = false) do
    flag := true;
    let c = Char.chr ((Char.code newCtr.[!ndx]) + 1)
    in
    if c <= maxc
    then 
      newCtr.[!ndx] <- c
    else (* carry *) 
      (flag := false;
       newCtr.[!ndx] <- minc;
       ndx := !ndx - 1)
  done;
  if (!flag = false) (* need to extend string *)
  then
    (String.make 1 minc) ^ newCtr
  else
    newCtr
;;



let list_diff lst1 lst2 = (* filters lst2 elts from lst1 *)
  let rec loop lst =
    match lst with
      [] -> []
    | h::t -> 
        let t' = loop t
        in 
        if (List.mem h lst2)
        then t'
        else h::t'
  in loop lst1
;;

let mergeLeafLists lst1 lst2 = (* merges lists of subtree info *)
  lst1 @ (list_diff lst2 lst1)
;;

let rec getTermVarsInLeafOrder t =

  let rec gtv t ts ctr = 

    (* t = a term, ts = a term substitution, 
       ctr = a string used as for-loop index variable counter 
    *)

    match t with

    (* term and phrase variables *)

      Tvar x -> 
        (try ([],Term_subst.find (raw x) ts)
        with Not_found -> ([raw x],t))
          
    | Apply(Apply(Apply(Forall,t1),t2),Lam(x,t3)) -> (* handle specially *)
        let (lst,(t1',t2')) = gtv2 t1 t2 ts ctr
        and new_ctr = incrStringCounter ctr 'i' 'l'
        in let new_var = Var new_ctr
        in let (lst',t3') =
          gtv t3 (Term_subst.add (raw x) (Tvar new_var) ts) new_ctr
        in (mergeLeafLists lst lst',
            Apply(Apply(Apply(Forall,t1'),t2'),Lam(new_var,t3')))

    | Apply (t1,t2) -> 
        let (lst,(t1',t2')) = gtv2 t1 t2 ts ctr
        in (lst,Apply (t1',t2'))

    | Lam (x,t') -> 
        let ts' = Term_subst.remove (raw x) ts
        in let (lst,t'') = gtv t' ts' ctr
        in (mergeLeafLists [raw x] lst,Lam (x,t''))

    | Op(c,ts1) -> 
        let (lst,ts') = gtvn ts1 ts ctr in
        (lst, Op(c,ts'))

    | Get t1 -> 
        let (lst, t1') = gtv t1 ts ctr in 
        (lst, Get t1')

    | Sub (t1,t2) -> 
        let (lst,(t1',t2')) = gtv2 t1 t2 ts ctr
        in (lst,Sub (t1',t2'))

    | Condsh (t1,t2,t3)  -> 
        let (lst,(t1',t2',t3')) = gtv3 t1 t2 t3 ts ctr
        in (lst, Condsh(t1',t2',t3'))

    | Cond (t1,t2,t3)  -> 
        let (lst,(t1',t2',t3')) = gtv3 t1 t2 t3 ts ctr
        in (lst, Cond(t1',t2',t3'))

    | Condexp (t1,t2,t3)  -> 
        let (lst,(t1',t2',t3')) = gtv3 t1 t2 t3 ts ctr
        in (lst, Condexp(t1',t2',t3'))

    | Where (t1,x,t2) -> 
        let ts' = Term_subst.remove (raw x) ts
        in let (lst,t1') = gtv t1 ts' ctr
        in let (lst',t2') = gtv t2 ts ctr
        in (mergeLeafLists
              lst 
              (mergeLeafLists [raw x] lst'),
            Where (t1',x,t2'))

    | Typed(t1,ty) -> gtv t1 ts ctr

    (* datum expressions *) 

    | _ -> ([],t) 

  and gtv2 t1 t2 ts ctr = 

    let (lst1,t1') = gtv t1 ts ctr
    and (lst2,t2') = gtv t2 ts ctr

    in

    (mergeLeafLists lst1 lst2,(t1',t2'))

  and gtv3 t1 t2 t3 ts ctr = 

    let (lst1,t1') = gtv t1 ts ctr
    and (lst2,t2') = gtv t2 ts ctr
    and (lst3,t3') = gtv t3 ts ctr

    in (mergeLeafLists (mergeLeafLists lst1 lst2) lst3,(t1',t2',t3'))

  and gtvn ts1 ts ctr = 

      let f t1 (lst,ts')  = 
        (let (lst1,t1') = gtv t1 ts ctr
        in (mergeLeafLists lst1 lst,t1'::ts') )

      in List.fold_right f ts1 ([],[]) 

  in

  gtv t Term_subst.empty ""
;;

let newTermName vars = 
  let termSub = ref id_term_subst
  and termCounter = ref ""
  in 
  let newVar v = 
    termCounter := (incrStringCounter !termCounter 'A' 'Z') ;
    Tvar (Var !termCounter)
  in 
  List.iter 
    (fun v -> termSub := Term_subst.add v (newVar v) !termSub) 
    vars;
  !termSub
;;

let tidy_term t = 
  let (termVars,t') = getTermVarsInLeafOrder t
  in 
  apply_term_subst (newTermName termVars) t'
;;


@head(2,"pretty_fish.mli")
pretty_fish.mli.
@select(tangler("src/pretty_fish.mli"))
val ps : string -> unit
val format_prim_type : Primitive_fish.prim_type -> unit
val format_static_prim_type : Primitive_fish.prim_type -> unit
val format_prim_constant : Primitive_fish.prim_constant -> unit
val formatArrayTyVar : Types_fish.arrayTyVar -> unit
val formatPhraseTyVar : Types_fish.phraseTyVar -> unit
val format_untidy_array_type : Types_fish.arrayType -> unit
val format_phrase_type : bool -> Types_fish.phraseType -> unit
val format_tidy_phrase_type : Types_fish.phraseType -> unit
val format_untidy_phrase_type : Types_fish.phraseType -> unit
val format_type_scheme : Types_fish.fishTyScheme -> unit
val formatPrimTypeError :
  string -> Primitive_fish.prim_type -> Primitive_fish.prim_type -> unit
val formatArrayTypeError :
  string -> Types_fish.arrayType -> Types_fish.arrayType -> unit
val formatPhraseTypeError :
  string -> Types_fish.phraseType -> Types_fish.phraseType -> unit
val formatInvalidRunType : Types_fish.phraseType -> unit
val format_term_variable : Terms_fish.term_variable -> unit
val format_term : Terms_fish.fish_term -> unit
val format_shape_term : Terms_fish.fish_term -> unit
val format_shape_term : Terms_fish.fish_term -> unit
val format_parsed_term : Terms_fish.fish_term -> unit
val format_inferred_term : Terms_fish.fish_term -> unit
val format_declaration :
  Terms_fish.term_variable -> Types_fish.fishTyScheme -> unit
val format_shape_declaration :
  Terms_fish.term_variable ->
  Terms_fish.fish_term -> Types_fish.fishTyScheme -> unit

@head(2,"pretty_fish.ml")
pretty_fish.ml.
@select(tangler("src/pretty_fish.ml"))
(* pretty_fish.ml *)

open Format
open List
open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Type_subs_fish
open Substitution_fish 


(* formatting - for pretty_fish.ml *)

let ps = Format.print_string
;;

let lpn() = 
   ps "("
;;

let rpn() = 
   ps ")"
;;

(* how many spaces to indent if line break *) 

let termIndent = 2
;;

let tyIndent = 2
;;

(* primitives *)

let format_prim_type ty = ps (string_of_prim_type ty) ;;

let format_static_prim_type ty = ps (string_of_static_prim_type ty) ;; 

let format_prim_constant c =
  match c with
    Prim_value v -> ps (string_of_prim_value v)
  | Pconst (_,_,s) -> ps s
;;

(* type vars *)

let formatArrayTyVar ty = 
  match ty with 
  | ArrayTyVar n-> ps ("a_ty_" ^ (string_of_int n))
  | UserATV x -> ps ("a_ty_" ^ x)
;;

let formatPhraseTyVar ty = 
  match ty with 
  | PhraseTyVar n-> ps ("ph_ty_" ^ (string_of_int n))
  | UserPTV x -> ps ("ph_ty_" ^ x)
;;


(* types *)

let prec_funty = 1;; 

(* 
   format_tidy... formats to produce tidy types.
   format_untidy... formats to produce untidy types  
   (when reporting type errors).

   tidy formatting of array and phrase variables are handled within a
   single function. The code for format_tidy_array is local to
   format_phrase 

   precedences are used to decide about parenthetisation.
*)

let rec format_untidy_array_type ty =

  match ty with

    ArrayTV x -> 
      formatArrayTyVar x;

  | DatumTy ty' -> format_prim_type ty'

  | ArrayTy ty' ->
      ps "[";
      open_box tyIndent;
      format_untidy_array_type ty';
      close_box();
      ps "]"
;;

let format_phrase_type tidy ty = 
  let alpha_counter = ref ""
  and theta_counter = ref ""
  and array_string_tbl = ref []
  and phrase_string_tbl = ref []
  in 
  let next_array_string()  = 
    alpha_counter := incrStringCounter !alpha_counter 'a' 'e';
    !alpha_counter
  and next_phrase_string() = 
    theta_counter := incrStringCounter !theta_counter 'x' 'z';
    !theta_counter
  in

  let format_tidy_tyvar x tbl new_fun =
    let s = 
      try assoc x !tbl
      with Not_found ->
        let s' = new_fun()
        in
        tbl := (x,s') :: !tbl;
        s'
    in

    ps s
  in

  let rec format_array_type ty =

    match ty with

      ArrayTV x -> 
        if tidy then
          format_tidy_tyvar x array_string_tbl next_array_string
        else
          formatArrayTyVar x;

    | DatumTy ty' -> format_prim_type ty'

    | ArrayTy ty' ->
        ps "[";
        open_box tyIndent;
        format_array_type ty';
        close_box();
        ps "]"

  and format_data_type do_ty =
    match do_ty with 
      AT ty' -> format_array_type ty'
    | ShT ty' -> format_shape_type ty'

  and format_shape_type do_ty = 
    match do_ty with 
    | StaticTy ty' -> format_static_prim_type ty'
    | HashArrayTy ty' ->
        ps "#";
        format_array_type ty'

  and ftphty do_ty left_prec right_prec =

    match do_ty with 
          
      PhraseTV x -> 
        if tidy then
          format_tidy_tyvar x phrase_string_tbl next_phrase_string
        else
          formatPhraseTyVar x

    | HashPhraseTy x ->
        ps "#";
        if tidy then 
          format_tidy_tyvar x phrase_string_tbl next_phrase_string
        else
          formatPhraseTyVar x

    | CommTy ->
        open_box tyIndent;
        ps "comm";
        close_box()
          
    | VarTy ty' ->
        ps "var ";
        open_box tyIndent;
        format_array_type ty' ;
        close_box()
          
    | ExpTy ty' ->
        open_box tyIndent;
        format_data_type ty'; 
        close_box()
          
    | FunTy (ty1,ty2) ->
        let needsParens = 
          prec_funty < left_prec 
                (* never happens currently, 
                   as FunTy is right-associative *)
            or prec_funty <= right_prec
                (* if there is, say, a FunTy to the right *)
        in
        open_box tyIndent;      
        if needsParens 
        then (
          lpn();
          ftphty ty1 0 prec_funty
            )
        else (
          ftphty ty1 left_prec prec_funty
            );
        print_space();
        ps "->";
        print_space();
        if needsParens 
        then (
          ftphty ty2 prec_funty 0;
          rpn()
          )
        else (
          ftphty ty2 prec_funty right_prec
            );
        close_box()

  in

  ftphty ty 0 0;
  print_flush()
;;

let format_tidy_phrase_type =
  format_phrase_type true
;;

let format_untidy_phrase_type =
  format_phrase_type false
;;

let format_type_scheme ty = 
  Format.open_hovbox tyIndent;
  format_tidy_phrase_type (inst_tyscheme ty) ;
  Format.close_box();

;;

let formatPrimTypeError s pty1 pty2 =

  let form_in_box pty = 
    Format.open_box tyIndent;
    format_prim_type pty;
    Format.close_box()
  in

  Format.open_box 0;
  ps s;
  Format.print_space();
  form_in_box pty1;
  ps " and ";
  form_in_box pty2;
  Format.close_box();
  Format.print_newline()
;;

let formatArrayTypeError s ty1 ty2 =

  let form_in_box ty = 
    Format.open_box tyIndent;
    format_untidy_array_type ty;
    Format.close_box()
  in

  Format.open_box 0;
  ps s;
  Format.print_space();
  form_in_box ty1;
  ps " and ";
  form_in_box ty2;
  Format.close_box();
  Format.print_newline()
;;

let formatPhraseTypeError s ty1 ty2 =

  let form_in_box ty = 
    Format.open_box tyIndent;
    format_untidy_phrase_type ty;
    Format.close_box()
  in

  Format.open_box 0;
  ps s;
  Format.print_space();
  form_in_box ty1;
  ps " and ";
  form_in_box ty2;
  Format.close_box();
  Format.print_newline()
;;

let formatInvalidRunType ty =
      Format.open_box 0;
      ps "Invalid run type:";
      Format.print_space();
      Format.open_box tyIndent;
      format_tidy_phrase_type ty;
      Format.close_box();
      Format.close_box();
      Format.print_newline()
;;



(* terms *)

(* precedences *)

let prec_fun =    1
let prec_cond =   1   (* conditionals extend as far to the right as possible, 
>                     like functions *) 
let prec_where =  2
let prec_app =    10

let prec_equal = 2
let prec_get = 2
let prec_sub = 2 
let prec_type = 2

let prec_op c = 
  match c with 
    Pconst ([ty],_,_) -> 7
  | Pconst(_,_,s) -> 
      (match s with 
          | "mod" 
          | "="
          | "<"
          | "<="
          | ">"
          | ">=" 
          | "<."
          | "<=."
          | ">."
          | ">=." 
          | "not"   -> 6

          | "+" 
          | "-" 
          | "+." 
          | "-." 
          | "||" 
          | "acos"
          | "asin"
          | "atan"
          | "atan2"
          | "ceil"
          | "cos"
          | "cosh"
          | "exp"
          | "fabs"
          | "floor"
          | "fmod"
          | "int2float"
          | "log"
          | "log10"
          | "pow"
          | "sin"
          | "sinh"
          | "sqrt"
          | "tan"
          | "tanh"
          | "truncate"    -> 7

          | "*" 
          | "/" 
          | "div"
          | "*." 
          | "/." 
          | "&&"    -> 8
          | _ -> raise (Fish_error 
                  (String.concat ":" ["unrecognised primitive operation";s]))
      )

  | _ -> raise (Fish_error "this is a value")
        

(* formatting *) 

let format_term_variable x =
  match x with
    Var y -> ps y

  | TypedVar (y,ty) -> 
      lpn() ;
      ps y ;
      ps ":" ;
      format_phrase_type false ty ;
      rpn() ;

  | Mvar n -> ps ("mvar_" ^ (string_of_int n))

  | TypedMvar (n,ty) -> 
      lpn() ;
      ps ("mvar_" ^ (string_of_int n)) ;
      ps ":" ;
      format_phrase_type false ty ;
      rpn() ;

;;


let format_term t = 

  let rec do_format t' left_prec right_prec =

    match t' with

      Tvar x -> 
        format_term_variable x

    | Apply(Dyn pty,t2) ->
        open_box 0;
        lpn();
        do_format t2 0 0;
        ps " :" ;
        format_prim_type pty ;
        rpn();
        close_box()
  
    | Apply(t1,t2) ->
        let needParens = 
          prec_app <= left_prec or
          prec_app < right_prec
        in
        open_box 0;
        if needParens 
        then (
          lpn();
          do_format t1 0 prec_app
            )
        else (
          do_format t1 left_prec prec_app
            );
        close_box();
        print_space();
        open_box 0;
        if needParens 
        then (
          do_format t2 prec_app 0;
          rpn()
            )
        else (
          do_format t2 prec_app right_prec
            );
        close_box()
          
    | Lam(x,t') ->
        let needParens = left_prec > prec_fun or right_prec > 0 
        in
        open_box termIndent;
        if needParens then lpn();
        ps "fun";
        print_space();
        format_term_variable x;
        print_space();
        ps "->";
        print_space();
        if needParens 
        then (
          do_format t' prec_fun 0;
          rpn()
            )
        else (
          do_format t' prec_fun right_prec
            );
        close_box()
        
    | Where (t1,x,t2) ->
        let needParens = 
          left_prec > prec_where or 
          right_prec >= prec_where
        in
        if needParens then (
          lpn();
          do_format t1 0 prec_where
          )
        else (
          do_format t1 left_prec prec_where
          );
        force_newline();
        ps "where";
        print_space();
        format_term_variable x;
        ps " = ";
        if needParens 
        then (
          do_format t2 0 0;
          rpn()
            )
        else (
          do_format t2 0 right_prec;
          )

   | Op (c,ts) -> 
       (match ts with 
         [] -> format_prim_constant c 
       | [t] ->
           let prec = prec_op c in 
           let needsParen =
             left_prec  >  prec or 
             right_prec >= prec
       in
       if needsParen then (
         lpn() ;
         format_prim_constant c ; (* all unary ops are prefix *)
         print_space() ;
         do_format t prec 0 ;
         rpn()
       )
       else (
         format_prim_constant c ;
         print_space() ;
         do_format t prec right_prec ; )

       | [t0;t1] -> 
           let prec = prec_op c in 
           let needsParen =
             left_prec  >  prec or 
             right_prec >= prec
       in
       if needsParen then (
         lpn() ;
         do_format t0 0 prec ;  (* all binary ops are infix *)
         print_space() ;
         format_prim_constant c ;
         print_space() ;
         do_format t1 prec 0 ;
         rpn()
       )
       else (
         do_format t0 left_prec prec ;
         print_space() ;
         format_prim_constant c ;
         print_space() ;
         do_format t1 prec right_prec ; )

       |  _ -> raise (Fish_error "too many arguments for a primitive operation")

       )

   | Get t -> 
         ps "get(" ;
         do_format t prec_get right_prec ;
         rpn() ; 

   | Sub(t1,t2) -> 
         ps "sub(" ;
         do_format t1 0 0  ;
         ps "," ;
         do_format t2 0 0 ;
         rpn() ; 
                
   | Condsh(x,y,z) -> 
       let needsParen =
        left_prec  >  prec_cond or 
        right_prec >= prec_cond
       in
       if needsParen then (
        lpn() ;
        ) ;
       ps "if " ; 
       do_format x 0 0 ; 
       ps " then " ; 
       do_format y 0 0 ; 
       ps " else " ; 
       do_format z 0 0 ;
       if needsParen then (
        rpn() ;
        ) 

   | Cond(x,y,z) -> 
       let needsParen =
        left_prec  >  prec_cond or 
        right_prec >= prec_cond
       in
       if needsParen then (
        lpn() ;
        ) ;
       ps "if " ; 
       do_format x 0 0 ; 
       ps " then " ; 
       do_format y 0 0 ; 
       ps " else " ; 
       do_format z 0 0 ;
       if needsParen then (
        rpn() ;
        ) 

   | Condexp(x,y,z) -> 
       let needsParen =
        left_prec  >  prec_cond or 
        right_prec >= prec_cond
       in
       if needsParen then (
        lpn() ;
        ) ;
       ps "if " ; 
       do_format x 0 0 ; 
       ps " then " ; 
       do_format y 0 0 ; 
       ps " else " ; 
       do_format z 0 0 ;
       if needsParen then (
        rpn() ;
        ) 

   | Typed (t'',ty) -> 
       lpn() ;
       do_format t'' 0 0 ;
       ps " : " ;
       format_untidy_phrase_type ty ;
       rpn() 

  (* commands *)

  | Skip -> ps "skip"
  | Abort -> ps "abort"
  | Assign -> ps "assign"
  | Seq -> ps "seq"
  | Forall -> ps "forall"
  | Whiletrue -> ps "whiletrue"
  | Fix k -> ps "fix("; Format.print_int k ; ps ")"
  | Newvar -> ps "newvar"
  | Output -> ps "output"

  (* array expressions *)

  | Dyn pty -> ps "dyn"  (* shouldn't happen! *)
  | Newexp -> ps "newexp"

  (* shape expression *)

  | Bang ty -> format_prim_type ty; ps "_shape"
  | Zerodim -> ps "zerodim"
  | Succdim -> ps "succdim"
  | Undim -> ps "undim"
  | Lendim -> ps "lendim"
  | Preddim -> ps "preddim"
  | Numdim -> ps "numdim"
  | Equal -> ps "shequal"

  (* phrase polymorphic terms *)
     
  | Primrec -> ps "primrec"
  | Error -> ps "error"
  | Shape -> ps "#"

  in
          
  open_box 0;
  do_format t 0 0;
  close_box();
  print_flush()
;;
          
let format_shape_term t =

  match t with

    Op _ 
  | Error -> 
      format_term t
        
  | _ -> 
      
      let print_as_size n = 
        Format.print_int n
      in let rec format_size_list ns =
        match ns with
          [] -> ()
        | [n] -> print_as_size n
        | h::ns' -> 
            print_as_size h;
            ps ",";
            format_size_list ns'
      in let format_one_layer dims = 
        if length dims > 0
        then (
          open_box 0;
          print_space();
          format_size_list dims;
          print_space();
          close_box()
            );
        ps ":"
      in

      let (dims_lst,b) = shape2Pair t
      in

      match dims_lst with

        [] ->
          format_prim_type b; ps "_shape"

      | _ ->
          ps "{";
          if length dims_lst > 0 & length (hd dims_lst) = 0
          then ps " ";
          iter format_one_layer dims_lst;
          ps " ";
          format_prim_type b; 
          ps "_shape }"
;;


let format_parsed_term term = 
  Format.print_string "Parse tree : ";
  Format.print_newline();
  format_term term;
  Format.print_newline()
;;

let format_inferred_term term = 
  Format.print_string "Inferred term : ";
  Format.print_newline();
  format_term term;
  Format.print_newline()
;;

let format_declaration identifier tyScheme = 
  format_term_variable identifier;
  Format.print_string " : ";
  format_type_scheme tyScheme; 
  Format.print_newline()
;;

let format_shape_declaration identifier shape tyScheme = 

  let fsd identifier shape = 
  Format.print_string "#";
  format_term_variable identifier;
  Format.print_string " = ";
  format_shape_term shape;
  Format.print_newline()
  in 

  match (tyScheme,shape) with
    _,Error ->                                 fsd identifier shape 
  | TyScheme(_,_,ExpTy (AT (DatumTy _))), _ -> ()
  | TyScheme(_,_,ExpTy ty),_ ->                fsd identifier shape 
  | _,_ ->                                     ()
;;


@head(2,"util_fish.mli")
util_fish.mli.
@select(tangler("src/util_fish.mli"))
type run_flag = Quiet_flag | Compile_flag
type show_mode = Show_on | Show_off
type fish_shell_action =
    Let_decl of Terms_fish.term_variable * Terms_fish.fish_term
  | Turbot_directive of Terms_fish.term_variable * run_flag list
  | Run_directive of Terms_fish.term_variable * run_flag list * string
  | Show_directive of show_mode * string
  | Use_directive of string
  | Quit_directive
exception No_such_mode
val modes : (string * show_mode) list ref
val set_mode: string -> show_mode -> unit
val get_mode: string -> show_mode

@head(2,"util_fish.ml")
util_fish.ml.
@select(tangler("src/util_fish.ml"))
type run_flag = Quiet_flag | Compile_flag
type show_mode = Show_on | Show_off
type fish_shell_action =
    Let_decl of Terms_fish.term_variable * Terms_fish.fish_term
  | Turbot_directive of Terms_fish.term_variable * run_flag list
  | Run_directive of Terms_fish.term_variable * run_flag list * string
  | Show_directive of show_mode * string
  | Use_directive of string
  | Quit_directive


exception No_such_mode
let modes = ref [         (* list of string/default pairs *)
  "felix",Show_off ;      (* felix mode off *)
  "batch",Show_on ;       (* do display *)
  "parse",Show_off ;      (* do not display parse trees *)
  "infer",Show_off ;      (* do not display inferred term *)
  "loop_opt",Show_on ;    (* do lift newvar from loops  *)
  "datum_opt",Show_on ;   (* do lift newexp from datum operations *)
  "assign_opt",Show_on    (* do lift newexp from assignments *)
] ;;


let is_nonempty_prefix s1 s2 =  (* prefixes of mode names will suffice, 
                                   except for "assign" *)
  let s1_len = String.length s1
  and s2_len = String.length s2
  in 

  if s1_len = 0 or s1_len > s2_len 
  then false
  else s1 = String.sub s2 0 s1_len
;;  

let set_mode s mode =
  let rec loop lst =
    match lst with
      [] -> raise No_such_mode
    | (name,curr)::t ->
        if is_nonempty_prefix s name
        then (name,mode)::t
        else (name,curr)::(loop t)
  in 

  modes := loop (!modes)
;;

let get_mode s = 
  try List.assoc s !modes
  with Not_found -> raise (Primitive_fish.Fish_error "unrecognised mode")
;;

@head(2,"parse_fish.mly")
parse_fish.mly.
@select(tangler("src/parse_fish.mly","data"))
/* parse_fish.mly

   OCaml yacc source 

   To generate ML source,

        execute 

                ocamlyacc -v parse_fish.mly        

        (this is now done automagically by the Makefile)

   User syntax is described in Fish/Alpha/Docs/syntax.txt. 

   Notes: 

          Stratification into fishTerm and simpleFishTerm, to
          facilitate making application left-associative, borrowed
          from the O'Caml grammar for itself.

  References: 
              "bison for yacc - see school home pages"
              "O'Reilly book on lex and yacc". 

*/

%{ (* header *)

open List

open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Substitution_fish
open Util_fish

type newDecl = ShapeDecl | ExpDecl

let rec make_nested_new decls body =

  let new_with_init x e t =
    let ty = try (declaredType x)
              with NoType -> VarTy (ArrayTV (next_array_tyvar())) in 
    let z = nextTypedVar ty in  

    newvar 
        (shape e)
        (lam z (seq (assign (Tvar z) e) (substitute x (Tvar z) t)))    
      
  and new_without_init x sh t =
    let x' = offerVarTy x in
    newvar sh (lam x' t)

  in           

  match decls with

    [(ShapeDecl,x,sh)] -> 
      new_without_init x sh body

  | [(ExpDecl,x,e)] -> 
      new_with_init x e body

  | (ShapeDecl,x,sh)::rest -> 
      new_without_init x sh (make_nested_new rest body)

  | (ExpDecl,x,e)::rest -> 
      new_with_init x e (make_nested_new rest body)

  | [] -> body 
;;


let make_newvar decls body returnId = 

  let newvar_without_init x sh body =
    let x' = offerVarTy x in
    newexp sh (lam x' body)

  and newvar_with_init x e body =

    let z = nextvar()
    and x' = offerVarTy x in
    let f = 
      lam x' (seq (assign (Tvar x) (Tvar z)) body)
    in 
    newexp (shape e) (substitute z e f)

  and (c,x,t) = hd decls
  and tl_decls = tl decls 
  in 
  
  if x <> returnId
  then raise (Fish_error ":wrong return identifier");

  match (c,tl_decls) with

    ShapeDecl,[] -> 
      newvar_without_init x t body

  | ExpDecl,[] -> 
      newvar_with_init x t body

  | ShapeDecl,_ ->  
      newvar_without_init x t
        (make_nested_new tl_decls body)

  | ExpDecl,_ ->  
      newvar_with_init x t
        (make_nested_new tl_decls body)
;;

let make_nested_where bindings body =
  let rec loop lst =
    match lst with
      [(x,t)] -> Where(body,x,t)
    | (x,t)::bs -> Where(loop bs,x,t)
    | _ -> raise (Fish_error "in where-clause")
  in loop bindings
;;
  
let fixof k f =

(*

fixof k f x0 x1 ... x(k-1) = 
  new y0 = x0 ;
      ...
      y(k-1) := x(k-1) 
  in
  let g z0 z1 ... z(k-1) = 
  y0 := z0 ;
  ...
  y(k-1) := z(k-1) ;
    new 
      y'0 = y0 ;
      ...
      y'(k-1) = y(k-1)       (* c.f. caller save registers protocol  *) 
    in 
      C ;
      y0 := y'0 ;
      ...
      y(k-1) := y'(k-1) 
    end
  in 
  let P C = f g y0 y1 ... y(k-1) in 
    fix(0) P 
  end 
*)
 


  let makeVarTriple () =
    let x = nextTypedVar(ExpTy (AT (ArrayTV (next_array_tyvar()))))
    and y = nextvar()
    and z = nextvar()
    in (x,y,z)
  in

  let makeVars () = 
    let vars = ref []
    in
    for i = 1 to k do
      vars := makeVarTriple() :: !vars
    done;
    !vars
  in

  let make_comm_functional bigP yzs = 

    let bigC = nextvar()
    and bang_ys = map (fun (y,_) -> (Tvar y)) yzs (* var2exp deleted *)
    and zs = map (fun (_,z) -> z) yzs
    and assigns = map (fun (y,z) -> assign (Tvar y) (Tvar z)) yzs
    and y_primes = map (fun _ -> nextvar()) yzs
    in
    
    let push_ys = 
      map2 (fun (y,_) -> fun y' -> (ExpDecl,y',Tvar y)) yzs y_primes
    and pop_ys = 
      map2 (fun (y,_) -> fun y' -> assign (Tvar y) (Tvar y')) yzs y_primes
    in 
    
    let littleG = 
      multilam zs 
        (make_nested_new
           push_ys
           (multiseq (assigns @ [Tvar bigC] @ pop_ys)))

    in lam bigC (List.fold_left ap bigP (littleG::bang_ys))
      
  in 

  let xyzs = makeVars()
  in

  let xs = map (fun (x,_,_) -> x) xyzs
  and yzs = map (fun (_,y,z) -> (y,z)) xyzs
  and inits = map (fun (x,y,_) -> (ExpDecl,y,Tvar x)) xyzs
  in

  let fnal = make_comm_functional f yzs
  in
  
  multilam xs (make_nested_new inits (fix(0) fnal))
;;


let make_rec_fun f args body =
  let the_fun = multilam args body
  in let fvs = free_vars the_fun 
  in
  if mem f fvs (* really a recursive fun *)
  then fixof (length args) (lam f the_fun)
  else the_fun
;;


let make_zerodim_term t =
  let x = offerVarTy(nextvar())
  in 
  newexp 
    (zerodim (shape t)) 
    (lam x (assign (Get (Tvar x)) t))
;;

let make_succdim_term t =
  let x = offerVarTy(nextvar())
  and counter = ref 0
  in let mk_assn h n = 
    assign (Sub(Tvar x, Op (Prim_value (Int n),[]))) h
  in let assns = 
    multiseq 
      (map (fun t -> let v = mk_assn t !counter in incr counter;v) t)
  in 
  newexp 
    (succdim (Op (Prim_value (Int (length t)),[])) (shape (hd t)))
    (lam x assns)
;;

let fill_shape sh ts =

  let (ndxs,_) = 
    try shape2Pair sh
    with _ -> raise (Fish_error "not a static shape")
        
  and data_fills_shape shlst data =
    let slots = fold_left (fun x -> fun y -> x * y) 1 (flatten shlst)
    in slots = length data
      
  and x = offerVarTy(nextvar()) in

  match (ndxs,ts) with

  | _ when not (data_fills_shape ndxs ts) ->
      raise (Fish_error "wrong number of array entries")

  | (_,[]) -> newexp sh (lam x skip)

  | ([],[t]) -> newexp sh (lam x (assign (Tvar x) t))

  | _ -> 

      let flat_ndxs = flatten ndxs
      in let num_ndxs = length flat_ndxs
      in let ndx_array = Array.of_list flat_ndxs  

      and counters = Array.create num_ndxs 0

      in let incr_counters() =

        let i = ref (Array.length ndx_array - 1)
        and flag = ref false
        in 

        if (!i >= 0) then (* may have empty index array *)

        while not (!flag)  do
          flag := true;
          counters.(!i) <- (counters.(!i) + 1) mod ndx_array.(!i);
          if (counters.(!i) = 0 & !i > 0)
          then (i := !i - 1;flag := false)
        done 

      and boundaries = 

        (* boundaries.(i) = n means need to insert n get's
           after applying the i'th index        
        *)

        let r = Array.create (num_ndxs + 1) 0 
        and n = ref 0
        in 
        iter (fun lst -> n := !n + (length lst);r.(!n) <- r.(!n) + 1) ndxs;
        r

      in let gets_at_ndx ndx = 
           Array.to_list (Array.create boundaries.(ndx) (get_term()))

      in let inner_term = List.fold_right ap (gets_at_ndx 0) (Tvar x) 

      in let next_sub() = 
        let curr_ndx = ref 1
        in let mk_sub t n = 
          let gets = gets_at_ndx !curr_ndx
          in let the_sub = 
            List.fold_right ap gets (Sub(t, Op (Prim_value (Int n),[]))) 
          in 
          incr curr_ndx;
          the_sub
        in let v = Array.fold_left mk_sub inner_term counters
        in 
        incr_counters();
        v

      in let mk_assn h = 
        assign (next_sub()) h
      in let assns = multiseq (map mk_assn ts)
      in 
      
      newexp sh (lam x assns)
;;

let parse_string str = 
  let n = String.length str   (* end-quotes already removed *)
        and x = nextvar() 
        and b = ref true      (* b records non-escaped characters *)
        and body = ref skip   (* the body of the eventual assignment *)
        and e = ref skip in   (* the primitive character to be assigned *)
        let k = ref n         (* the number of actual characters 
                                 after deleting escapes *)
        in 

        for i=0 to n-1 do 
          if !b 
          then ( 
            let j = Op(prim_int i,[])
            and c = String.get str i in 
            (if c = '\\' 
            then 
              (let d = 
                (match String.get str (i+1) with
                  'b' -> '\b'
                | 'n' -> '\n'
                | 'r' -> '\r'
                | 't' -> '\t'
                | '"' -> '"'
                | _ -> raise (Fish_error "not a valid escape character") 
                ) in 
              e := Op(prim_char d,[]) ;
              b := false ; 
              decr k 
              )

            else e:= Op(prim_char c,[]) 
            ) ;
            body := seq (assign (Get (Sub(Tvar x,j))) !e) !body 
          )
          else  b:= true 
        done ;

        newexp (succdim (Op(prim_int !k,[])) (zerodim (Bang CharTy)))
               (lam x !body)


(* some shell stuff needed by the parser  *)


%}

/* static flag */

%token TTwiddle

/* operators */

%token TBangOp,THashOp

/* identifier */

%token <string> TId 

/* constants */

%token <int>   TIntConst
%token <float> TFloatConst
%token <bool>  TBoolConst
%token <char>  TCharConst
%token <string>TString 

/* strings (for filenames) */

%token <string> TString

/* keywords */ 

%token TDand,TCheck,TDo,TDone,TElse,TEnd,TFill,TFor,TFun,TIf,TIn,TLet,
       TNew,TRec,TThen,TWhere,TWhile,TWith

/* shell directives */

%token TQuit,TReturn,TRun,TShow,TTo,TTurbot,TUse


/* FiSh combinators */

%token TSub,TGet,TZerodim,TSuccdim,TUndim,TLendim,TPreddim,     
       TNumdim,EQ,HashEQ,TOutput,TSkip,TAbort,TAssign,TSeq,
       TForall,TWhiletrue,TFix,TNewvar,TNewexp,
       TCond,TPrimrec,TError,TShape

/* primitive constants = d's in paper, excluding infix ops */

%token <Primitive_fish.prim_constant> TPrimConst, TPrimBinConst

/* type-related */

%token TInt,TFloat,TBool,TChar,TSize,TCost,TFact,TMark,TComm,TVec,TExp,TVar 
/* unused currently */
%token TBangInt,TBangFloat,TBangBool, TBangChar

/* infix primitive constants 

   argument is a function that builds either a
   Datum_const or Shape_const, given a prim_constant
*/

%token <Primitive_fish.prim_constant> 
       TAddOp,TSubOp,TMultOp,TDivOp,TModOp,
       LT,LEQ,GT,GEQ,
       TAddOpFloat,TMultOpFloat,TSubOpFloat,TDivOpFloat,
       EQFloat,LTFloat,LEQFloat,GTFloat,GEQFloat,
       TAnd,TOr,EQBool

/* punctuation */

%token Percent,Semicolon,DoubleSemicolon,
       Colon,ColonEqual,
       Comma,Dot,VerticalBar,
       LSquareBrace,RSquareBrace,
       LCurlyBrace,RCurlyBrace
       LParen,RParen 
       RArrow

/* end of file */

%token TEof

/* precedences */

%left DoubleSemicolon

%right prec_fun

%left prec_binding_list

%right prec_let

%right prec_cond

%right Semicolon

%left prec_binding

%left TWhere

%right ColonEqual 

%right Dot

%left TAnd 
%left TOr 

%left EQ HashEQ LEQ LT GEQ GT EQFloat LEQFloat LTFloat GEQFloat GTFloat EQBool prec_rel

%left TAddOp TSubOp TAddOpFloat TSubOpFloat prec_add

%left TMultOp TDivOp TMultOpFloat TDivOpFloat TModOp prec_mult

%left  prec_app           /* application precedence */

%right prec_unop          /* unary ops */ 
%left  LSquareBrace       /* for x[n] */

/* entry point for FiSh parser */

%type <Terms_fish.fish_term> parseFish
%start parseFish  

/* entry point for shell parser */

%type <Util_fish.fish_shell_action> parseShellAction
%start parseShellAction        

/* alternate entry point for shell parser */

%type <Util_fish.fish_shell_action list> parseShellActionList
%start parseShellActionList 

%%        

parseShellAction :

  | shellAction 
      { $1 }

  | TEof
      { Quit_directive }
;

parseShellActionList :

  | shellActionList
      { $1 }
;

shellAction :

  | TLet binding DoubleSemicolon
      { let (x,t) = $2 in Let_decl (x,t) }

  | TLet TRec recBinding DoubleSemicolon
      { let (x,t) = $3 in Let_decl (x,t) }        

  | fishTerm DoubleSemicolon
      { Let_decl(Var "J",$1) }

  | Percent directive DoubleSemicolon
      { $2 }
;

shellActionList :

  | TEof
      { [] }

  | shellAction shellActionList
      { $1::$2 }

parseFish :

  | fishTerm  
      { $1 }
;

parameter :

  |   TId 
      { Var $1 }

  | LParen TId Colon fishPhraseType RParen 
      { TypedVar ($2,$4) }

parameterList :

  | parameter 
      { [$1] }

  | parameter parameterList
      { (* no duplicates allowed *)
        if mem (var2string $1) (map var2string $2) 
        then raise Parse_error 
        else $1::$2
      }

;

directive :

  | TRun runFlagList
      { Run_directive (Var "main",$2,"main") }

  | TRun runFlagList TId
      { Run_directive (Var $3,$2,$3) }

  | TRun runFlagList TTo TId
      { Run_directive (Var "main",$2,$4) }

  | TRun runFlagList TId TTo TId
      { Run_directive (Var $3,$2,$5) }

  | TTurbot runFlagList 
      { Turbot_directive (Var "main",$2) }

  | TTurbot runFlagList TId
      { Turbot_directive (Var $3,$2) }

  | TQuit 
      { Quit_directive }

  | TShow plusOrMinus TId
      { Show_directive ($2,$3) }

  | TUse TString
      { Use_directive $2 }
;

runFlag :

  | TSubOp TId
      { match $2 with
          "q" -> Quiet_flag
        | "c" -> Compile_flag
        | _ -> raise Parse_error
      }                         
;

runFlagList :

  | { [] }

  | runFlag runFlagList
   { $1::$2 }
;

plusOrMinus :

  | TAddOp
      { Util_fish.Show_on }

  | TSubOp
      { Util_fish.Show_off }
;




fishTerm :

  | simpleFishTerm 
      { $1 }

  | simpleFishTerm simpleFishTermList %prec prec_app
      { List.fold_left ap $1 (rev $2) }

  | negOp simpleFishTerm %prec prec_unop
      { Op($1,[ $2 ]) (* all ops are shape ops by default *) }

  | fishTerm addOp fishTerm %prec prec_add
      { Op($2, [$1; $3]) }

  | fishTerm multOp fishTerm %prec prec_mult 
      { Op($2, [$1; $3]) }

  | fishTerm relOp fishTerm %prec prec_rel
      { Op($2, [$1; $3]) }

  | fishTerm TAnd fishTerm 
      { Op (prim_and, [$1; $3]) }

  | fishTerm TOr fishTerm 
      { Op (prim_or, [$1; $3]) }

  | TPrimConst fishTerm %prec prec_unop 
      { Op($1,[ $2 ]) }

  | fishTerm HashEQ fishTerm 
      { equal $1 $3 }

  | TIf fishTerm TThen fishTerm TElse fishTerm %prec prec_cond
      { Condsh($2,$4,$6) (* assume conditionals are shapely 
                            until type inference *) }

  | TIf fishTerm TThen fishTerm TElse  %prec prec_cond
      { Condsh($2,$4,skip) }

  | TIf fishTerm TThen TElse fishTerm %prec prec_cond
      { Condsh($2,skip,$5)  }

  | TIf fishTerm TThen TElse  %prec prec_cond
      { Condsh($2,skip,skip)  }

  | TCheck simpleFishTerm fishTerm
      { Condsh($2,$3,Error) }

  | TNew newDeclList TIn fishTerm TEnd
      { make_nested_new $2 $4 }

  | TNew newDeclList TIn TEnd
      { make_nested_new $2 skip  }

  | TNew newDeclList TIn fishTerm TReturn TId 
      { make_newvar $2 $4 (Var $6) }

  | TNew newDeclList TIn TReturn TId 
      { make_newvar $2 skip (Var $5) }

  | TLet bindingList TIn fishTerm %prec prec_let
      { make_nested_where $2 $4 }

  | TLet TRec recBindingList TIn fishTerm %prec prec_let
      { make_nested_where $3 $5 }

  | fishTerm Semicolon fishTerm
      { seq $1 $3 }

  | fishTerm Semicolon      
      { seq $1 skip }        

  | fishTerm ColonEqual fishTerm 
      { assign $1 $3 }

  | TFor forBounds TDo fishTerm TDone
      { let (x,lo,hi) = $2 in
        let x' = assertIntTy x in 
          forall lo hi (lam x' $4) }

  | TFor forBounds TDo  TDone
      { let (x,lo,hi) = $2 in 
        let x' = assertIntTy x in 
          forall lo hi (lam x' skip) }

  | TWhile fishTerm TDo fishTerm TDone
      { whiletrue $2 $4 }

  | TWhile fishTerm TDo  TDone
      { whiletrue $2 skip }

  | fishTerm TWhere bindingList
      { make_nested_where (rev $3) $1 (* reverse binding order *) }

  | fishTerm TWhere TRec recBindingList
      { make_nested_where (rev $4) $1 (* ditto *) }

  | TFun parameter RArrow fishTerm %prec prec_fun
      { Lam($2,$4) }

  | fishComposition
      { $1 }

  | zeroDimTerm
      { $1 }

  | fillTerm
      { $1 }
;

binding :

  | parameterList EQ fishTerm %prec prec_binding
      { match $1 with 
          h::t -> (h ,multilam t $3) 
        | [] -> raise Parse_error }

;

bindingList :

  | binding                       %prec prec_binding_list
      { [$1] }

  | binding TDand bindingList %prec prec_binding_list
      { $1::$3  } 
;

recBinding :

  | parameterList EQ fishTerm %prec prec_binding
      { match $1 with 
        h::t -> (h,make_rec_fun h t $3)  
        | [] -> raise Parse_error }

;

recBindingList :

  | recBinding                          %prec prec_binding_list
      { [$1] }

  | recBinding TDand recBindingList %prec prec_binding_list
      { $1::$3 } 
;

forBounds :

  | fishTerm LEQ TId LT fishTerm 
      { (Var $3,$1,$5) }

  | TId LT fishTerm              
      { (Var $1,Op (prim_zero,[]),$3) }

  | LParen forBounds RParen
      { $2 }
;

simpleFishTerm :

  | unTypedFishTerm 
      { $1 }

  | LParen fishTerm Colon fishPhraseType RParen
      { match $4 with 
          ExpTy(ShT (HashArrayTy(DatumTy _))) 
      |        _ -> Typed ($2,$4) }
;

unTypedFishTerm : 

  | LParen fishTerm RParen
      { $2 }

  | TId 
      { Tvar (Var $1) }

  | fishPrimValue
      { Op(Prim_value $1,[]) (* all primitives are shapes now *)} 

  | TTwiddle fishPrimValue %prec prec_unop
      { Op(Prim_value $2,[]) }

  | fishUnop simpleFishTerm %prec prec_unop
      { ap $1 $2 }

  | TString
      { parse_string $1 }  

  | simpleFishTerm TPrimBinConst simpleFishTerm %prec prec_unop
      { Op($2,[ $1 ; $3 ]) }

  | simpleFishTerm bracedFishTermList
      { Get (fold_left (fun t -> fun t' -> Sub(t,t')) $1 $2) }

  | fishBang
      { Bang $1 }

  | TGet simpleFishTerm
      { Get $2   }

  | TSub LParen fishTerm Comma fishTerm RParen 
      { Sub ($3,$5) }

  | fishCombinator
      { $1 }

  | bracedShapeList 
      { $1 }

  | succDimTerm
      { $1 }

/* for later ? 


  | TString
      { let n = String.length $1 in 
        let aty = VarTy (ArrayTV (next_array_tyvar())) in 
        let x = nextTypedVar(aty) in 
        let t = ref skip in 

        for i = 1 to n-1 do
          t := seq (assign (Get(Sub(Tvar x,Op(prim_int (i-1),[])))) 
                           (Op(prim_char (String.get $1 i),[]))) 
               !t 
        done ;

        newexp (succdim (Op(prim_int (n - 2),[])) (zerodim (Bang CharTy)))
          (lam x !t)
      }        
*/

fishDatumType :

  | TInt 
      { IntTy }

  | TFloat 
      { FloatTy }

  | TBool
      { BoolTy }

  | TChar
      { CharTy }


fishArrayType : 

  | fishDatumType
      { DatumTy $1 }

  | LSquareBrace TId RSquareBrace
      { ArrayTy (ArrayTV (UserATV $2)) }

  | LSquareBrace fishArrayType RSquareBrace
      { ArrayTy $2 }
;

fishShapeType:

  | TSize 
      { StaticTy IntTy }

  | TCost
      { StaticTy FloatTy }

  | TFact
      { StaticTy BoolTy }

  | TMark
      { StaticTy CharTy }

  | THashOp fishArrayType 
      { HashArrayTy $2 }
;

fishDataType :

  | fishArrayType 
      { AT $1 }

  | fishShapeType
      { ShT $1 }
;

fishPhraseType:

  | LParen fishPhraseType RParen
      { $2 }

  | TId
      { PhraseTV (UserPTV $1) }

  | THashOp TId
      {HashPhraseTy (UserPTV $2) }

  | TExp TId
      { ExpTy (AT (ArrayTV (UserATV $2))) } 

  | TExp THashOp TId
      { ExpTy (ShT (HashArrayTy (ArrayTV (UserATV $3)))) } 

  | TExp fishDataType
      { ExpTy $2 } 

  | fishDataType 
      { ExpTy $1 }

  | TVar TId
      { VarTy (ArrayTV (UserATV $2)) } 

  | TVar fishArrayType 
      { VarTy $2 }

  | TComm
      { CommTy }

  | fishPhraseType RArrow fishPhraseType
      { FunTy ($1,$3) }
;      

fishPrimValue :

  | TIntConst 
      { Int $1 }

  | TBoolConst 
      { Bool $1 }

  | TFloatConst 
      { Float $1 }

  | TCharConst
      { Char $1 }

;

simpleFishTermList :

  | simpleFishTerm 
      { [$1] }

  | simpleFishTermList simpleFishTerm
      { $2::$1 }
;

bracedFishTermList :

  | LSquareBrace fishTermCommaList RSquareBrace
      { $2 }
;

fishUnop :

  | TBangOp    { bang_term() }
  | THashOp    { Shape     }  
;

fishBang :

  | TBangInt   { IntTy   }
  | TBangFloat { FloatTy }
  | TBangBool  { BoolTy  }
  | TBangChar  { CharTy  }

fishCombinator :

  | TNewexp      { Newexp   }

  | TZerodim     { Zerodim  }
  | TSuccdim     { Succdim  }
  | TUndim       { Undim    }
  | TLendim      { Lendim   }
  | TPreddim     { Preddim  }
  | TNumdim      { Numdim   }

  | TOutput      { Output   }
  | TSkip        { Skip     }
  | TAbort       { Abort    }
  | TAssign      { Assign   }
  | TSeq         { Seq      }
  | TCond        { condsh_term}
  | TForall      { Forall   }
  | TWhiletrue   { Whiletrue}
  | TFix         { Fix 0    }
  | TNewvar      { Newvar   }

  | TPrimrec     { Primrec  }
  | TError       { Error    }
  | TShape       { Shape    }
;

fishComposition :

  | fishTerm Dot fishTerm
      { let x = nextvar() in lam x (ap $1 (ap $3 (Tvar x))) }
;

negOp :

  | TSubOp           { prim_int_negative   }
  | TSubOpFloat      { prim_float_negative }
;

addOp :

  | TAddOp           { prim_int_plus }
  | TSubOp           { prim_int_minus }
  | TAddOpFloat      { prim_float_plus }
  | TSubOpFloat      { prim_float_minus }
;

multOp :

  | TMultOp           { prim_int_times }
  | TDivOp            { prim_int_divide }
  | TModOp            { prim_int_modulo }
  | TMultOpFloat      { prim_float_times }
  | TDivOpFloat       { prim_float_divide }
;

relOp :

  | EQ       { prim_int_equal }
  | GT       { prim_int_greater_than }
  | GEQ      { prim_int_greater_than_or_equal }
  | LT       { prim_int_less_than }
  | LEQ      { prim_int_less_than_or_equal }
  | EQFloat  { prim_float_equal }
  | GTFloat  { prim_float_greater_than }
  | GEQFloat { prim_float_greater_than_or_equal }
  | LTFloat  { prim_float_less_than }
  | LEQFloat { prim_float_less_than_or_equal }
;

fishTermCommaList :

  | { [] }

  | fishTerm
    { [$1] }

  | fishTerm Comma fishTermCommaList
    { $1::$3 }
;

bracedShapeList :

  | LCurlyBrace shapeList RCurlyBrace
      { $2 }
;


shapeList :

  | fishTerm
      { fishPair2Shape([],$1) }

  | Colon shapeList
      { fishPair2Shape([[]],$2) }

  | fishTermCommaList Colon shapeList
      { let (lst,b) = fishShape2Pair $3
        in 
        fishPair2Shape($1::lst,b) 
      }
;

shapeDecl :

  | THashOp TId EQ fishTerm
      { (ShapeDecl,Var $2,$4) }
;

expDecl :

  | TId EQ fishTerm
      { (ExpDecl,Var $1,$3) }
;

newDecl :

  | shapeDecl
      { $1 }

  | expDecl
      { $1 }
;

newDeclList :

  | newDecl 
      { [$1] }

  | newDecl TDand newDeclList
      { $1::$3 } 
;

simpleFishOrZeroDimTerm :

  | simpleFishTerm 
      { $1 }

  | zeroDimTerm
      { $1 }
;      

arraySemicolonList :

  | simpleFishOrZeroDimTerm
    { [$1] }

  | simpleFishOrZeroDimTerm Semicolon arraySemicolonList
    { $1::$3 }
;

zeroDimTerm :

  | LSquareBrace fishTerm RSquareBrace
    { make_zerodim_term $2 }
;

succDimTerm :

  |  VerticalBar arraySemicolonList VerticalBar
    { make_succdim_term $2 }
;

fillTerm :

  |  TFill simpleFishTerm TWith LSquareBrace fishTermCommaList RSquareBrace
    { fill_shape $2 $5 }

%% 

(* trailer *)

@head(2,"lex_fish.mli")
lex_fish.mli.
@select(tangler("src/lex_fish.mli"))
exception UnterminatedComment
val buf_pos : int ref
val last_buf_pos : int ref
val comment_depth : int ref
val line_number : int ref
val hash_table_from_list : int -> ('a * 'b) list -> ('a, 'b) Hashtbl.t
val keyword_table : (string, Parse_fish.token) Hashtbl.t
val primconst_table : (string, Primitive_fish.prim_constant) Hashtbl.t
val primbinconst_table : (string, Primitive_fish.prim_constant) Hashtbl.t
val hex_char2int : char -> int
val hexint_of_string : string -> int
val incr_lex_counters : Lexing.lexbuf -> unit
val mainLex : Lexing.lexbuf -> Parse_fish.token
val commentLex : Lexing.lexbuf -> unit
val lineCommentLex : Lexing.lexbuf -> unit
exception FishSyntaxError of int * int * string
val runParser : ('a -> Lexing.lexbuf -> 'b) -> 'a -> Lexing.lexbuf -> 'b
val makeParserForFile : (Lexing.lexbuf -> 'a) -> string -> 'a
val makeParserForConsole : (Lexing.lexbuf -> 'a) -> 'a
val makeParserForString : (Lexing.lexbuf -> 'a) -> string -> 'a
val makeParser :
  ((Lexing.lexbuf -> Parse_fish.token) -> Lexing.lexbuf -> 'a) ->
  Lexing.lexbuf -> 'a
val parseShell : Lexing.lexbuf -> Util_fish.fish_shell_action
val parseShellFromFile : string -> Util_fish.fish_shell_action
val parseShellFromConsole : unit -> Util_fish.fish_shell_action
val parseShellFromString : string -> Util_fish.fish_shell_action
val parseShellList : Lexing.lexbuf -> Util_fish.fish_shell_action list
val parseShellListFromConsole : unit -> Util_fish.fish_shell_action list
val parseShellListFromFile : string -> Util_fish.fish_shell_action list
val parseShellListFromString : string -> Util_fish.fish_shell_action list
val parseForFish : Lexing.lexbuf -> Terms_fish.fish_term
val parseFishFromConsole : unit -> Terms_fish.fish_term
val parseFishFromFile : string -> Terms_fish.fish_term
val parseFishFromString : string -> Terms_fish.fish_term

@head(2,"lex_fish.mll")
lex_fish.mll.
@select(tangler("src/lex_fish.mll","data"))
(* lex_fish.mll -- OCaml lex file *)

{ 

(* header code *)      

open Lexing
open Parsing

open Primitive_fish
open Terms_fish
open Environments_fish
open Parse_fish

exception UnterminatedComment

(* globals *)

let buf_pos = ref 0
let last_buf_pos = ref 0
let comment_depth = ref 0
let line_number = ref 1    (* line number tracking for %use *)
;;

(* generates an Ocaml Hashtbl from a list of key/value pairs  *)

let hash_table_from_list n lst =
  let tbl = Hashtbl.create n
  in let addEntry (s,kw) = Hashtbl.add tbl s kw
  in 
  List.iter addEntry lst;
  tbl
;;      

(* keywords *)

let keyword_table =          (* number argument should be 
                                a prime larger than table size *)
  hash_table_from_list 97 [  

  (* FiSh keywords *) 


(* terms other than combinators *)

  "and",     TDand; 
  "check",   TCheck; 
  "do",      TDo;
  "done",    TDone;
  "else",    TElse;
  "end",     TEnd;
  "fill",    TFill;
  "for",     TFor;
  "fun",     TFun;
  "if",      TIf;
  "in",      TIn;
  "let",     TLet;
  "new",     TNew;
  "rec",     TRec;
  "return",  TReturn;
  "then",    TThen;
  "where",   TWhere;
  "while",   TWhile;
  "with",    TWith;



   (* shell directives *)

  "quit",    TQuit;
  "run",     TRun;
  "show",    TShow;
  "to",      TTo;
  "turbot",  TTurbot;
  "use",     TUse;

   (* boolean constants *)

  "true",    TBoolConst true;
  "false",   TBoolConst false; 

   (* datum shapes *)

  "int_shape",   TBangInt;
  "float_shape", TBangFloat;
  "bool_shape",  TBangBool;
  "char_shape",  TBangChar;

   (* type keywords *)

  "int",    TInt; 
  "float",  TFloat;
  "bool",   TBool; 
  "char",   TChar;
  "size",   TSize;
  "cost",   TCost;
  "fact",   TFact;
  "mark",   TMark;
  "exp",    TExp; 
  "var",    TVar;
  "comm",   TComm;

  (* FISh constructors *)

  "get",      TGet;
  "sub",      TSub;

  (* FISh combinators *)

  "zerodim",  TZerodim;
  "succdim",  TSuccdim;
  "undim",    TUndim;
  "lendim",   TLendim;
  "preddim",  TPreddim;
  "numdim",   TNumdim;
  "output",   TOutput;
  "skip",     TSkip;
  "abort",    TAbort;
  "assign",   TAssign;
  "seq",      TSeq;
  "cond",     TCond;
  "forall",   TForall;
  "whiletrue",TWhiletrue;
  "fix",      TFix;
  "newvar",   TNewvar;
  "newexp",   TNewexp;
  "primrec",  TPrimrec;
  "error",    TError;
  "shape",    TShape;
] 
;;

let primconst_table =              (* number argument should be 
                                      a prime larger than table size *)
  hash_table_from_list 29 [

  (* alphanumeric, prefix primitive constants *)
  (* handled by general case in the parser    *)

  "acos",   prim_acos;
  "asin",   prim_asin;
  "atan",   prim_atan;
  "ceil",   prim_ceil;
  "cos",    prim_cos;
  "cosh",   prim_cosh;
  "expt",   prim_exp;
  "fabs",   prim_fabs;
  "floor",  prim_floor;
  "int2float", prim_int2float;
  "log",    prim_log;
  "log10",  prim_log10;
  "not",    prim_not;
  "sin",    prim_sin;
  "sinh",   prim_sinh;
  "sqrt",   prim_sqrt;
  "tan",    prim_tan;
  "tanh",   prim_tanh;
  "truncate", prim_truncate
] 
;;

let primbinconst_table =           (* number argument should 
                                      a be prime larger than table size *)
  hash_table_from_list 5 [

  (* alphanumeric, infix primitive constants *)
  (* handled by general case in the parser    *)

  "atan2",  prim_atan2;
  "fmod",   prim_fmod;
  "pow",    prim_pow
] 
;;

let hex_char2int s =
  let c = Char.code s
  in 
  match s with
    _ when (s >= '0' & s <= '9') ->
      c - (Char.code '0') 
  | _ when (s >= 'a' & s <= 'f') ->
      (c - (Char.code 'a')) + 10 
  | _ when (s >= 'A' & s <= 'F') ->
      (c - (Char.code 'A')) + 10 
  | _ -> raise (Fish_error "in hexadecimal character")
;; 


(* hexint_of_string : string -> int *)

(* converts a string representing a hex number to integer value *)
(* assumes that string begins with "0x" or "0X"                 *)

let hexint_of_string s =
  let len = String.length s
  in if (s.[0] = '-') then 
    let value = ref (- (hex_char2int s.[3]))
    in 
    for i = 4 to (len - 1) do
      value := !value * 16 - (hex_char2int s.[i])
    done;
    !value
  else
    let value = ref (hex_char2int s.[2])
    in 
    for i = 3 to (len - 1) do
      value := !value * 16 + (hex_char2int s.[i])
    done;
    !value
;;

(* increment counters on newline *)

let incr_lex_counters lexbuf =
  incr line_number;
  last_buf_pos := !buf_pos;
  buf_pos := lexeme_end lexbuf
;;

} 

(* lexing rules *)

rule mainLex = parse

    (* whitespace *)

    [' ' '\t' ] + 
    { mainLex lexbuf }

|   "\n"
    { incr_lex_counters lexbuf; mainLex lexbuf }

    (* begin comment *)

| "(*"                
    { comment_depth := 1;
      commentLex lexbuf; 
      mainLex lexbuf }

    (* begin line comment *)

| "//"                
    { lineCommentLex lexbuf; 
      mainLex lexbuf }

    (* characters and strings *)

| "'\\b'" { TCharConst '\b' } 
| "'\\n'" { TCharConst '\n' } 
| "'\\r'" { TCharConst '\r' } 
| "'\\t'" { TCharConst '\t' } 
| "'\\\\'"{ TCharConst '\\' } 
| "'\''"  { TCharConst '\'' }


| "'" [^ '\039'] "'"     (* anything but single quote  *)

     { TCharConst  (String.get (lexeme lexbuf) 1) } 


|  '"' ([^ '"']*  | "\\\"")* '"'       (* anything but double quote  *)

    { let s = lexeme lexbuf in 
      TString (String.sub s 1 ((String.length s) - 2))
    }




    (* numerics *)

  (* hexadecimal *)

| ("0x" | "0X")['0' - '9' 'A' - 'F' 'a' - 'f']+ 
   { TIntConst (hexint_of_string (lexeme lexbuf)) }

  (* floating-point -- can omit decimal part, or exponential part, not both *)

| ['0' - '9']+ ('.' ['0' - '9']* ) (('e' | 'E') ('+' | '-')? ['0' - '9']+)
   { TFloatConst (float_of_string (lexeme lexbuf)) }

| ['0' - '9']+ ('.' ['0' - '9']* )                      
   { TFloatConst (float_of_string (lexeme lexbuf)) }

| ['0' - '9']+ (('e' | 'E') ('+' | '-')? ['0' - '9']+) 
   { TFloatConst (float_of_string (lexeme lexbuf)) }

  (* decimal *)

| [ '0' - '9' ]+  
   { TIntConst (int_of_string (lexeme lexbuf)) }

(* infix primitive constants - datum versions *)

| "+"   { TAddOp prim_int_plus }
| "-"   { TSubOp prim_int_minus } (* care with negation ! *)
| "*"   { TMultOp prim_int_times }
| "div"   { TDivOp prim_int_divide }
| "mod" { TModOp prim_int_modulo }
| "<"   { LT prim_int_less_than }
| "<="  { LEQ prim_int_less_than_or_equal }
| ">"   { GT prim_int_greater_than }
| ">="  { GEQ prim_int_greater_than_or_equal }
| "+."  { TAddOpFloat prim_float_plus }
| "*."  { TMultOpFloat prim_float_times }
| "-."  { TSubOpFloat prim_float_minus }
| "/"   { TDivOpFloat prim_float_divide }
| "/."  { TDivOpFloat prim_float_divide }
| "=."  { EQFloat prim_float_equal }
| "<."  { LTFloat prim_float_less_than }
| "<=." { LEQFloat prim_float_less_than_or_equal }
| ">."  { GTFloat prim_float_greater_than }
| ">=." { GEQFloat prim_float_greater_than_or_equal }
| "#="  { HashEQ }
| "&&"  { TAnd prim_and }
| "||"  { TOr prim_or }

(* shape versions *)

| "~+"   { TAddOp prim_int_plus }
| "~-"   { TSubOp prim_int_minus } (* care with negation ! *)
| "~*"   { TMultOp prim_int_times }
| "~/"   { TDivOp prim_int_divide }
| "~mod" { TModOp prim_int_modulo }
| "~<"   { LT prim_int_less_than }
| "~<="  { LEQ prim_int_less_than_or_equal }
| "~>"   { GT prim_int_greater_than }
| "~>="  { GEQ prim_int_greater_than_or_equal }
| "~+."  { TAddOpFloat prim_float_plus }
| "~*."  { TMultOpFloat prim_float_times }
| "~-."  { TSubOpFloat prim_float_minus }
| "~/."  { TDivOpFloat prim_float_divide }
| "~<."  { LTFloat prim_float_less_than }
| "~<=." { LEQFloat prim_float_less_than_or_equal }
| "~>."  { GTFloat prim_float_greater_than }
| "~>=." { GEQFloat prim_float_greater_than_or_equal }
| "~&&"  { TAnd prim_and }
| "~||"  { TOr prim_or }


(* unary ops *)

| "!"   { TBangOp }      
| "#"   { THashOp }


(* other tokens *)

| "="   { EQ }
| "~"   { TTwiddle }
| "%"   { Percent }
| "->"  { RArrow }
| ";"   { Semicolon }
| ":"   { Colon }
| ":="  { ColonEqual }
| ","   { Comma }
| "."   { Dot }
| "|"   { VerticalBar }
| "["   { LSquareBrace }
| "]"   { RSquareBrace }
| "{"   { LCurlyBrace }
| "}"   { RCurlyBrace }
| "("   { LParen }
| ")"   { RParen }
| eof   { TEof }

| ";;" [' ' '\t' ]* ("\n" | eof)
  { incr_lex_counters lexbuf;
    DoubleSemicolon }

  (* keyword, combinators, coercions, type keyword, primitive
  constants, identifiers. This case must follow other cases with
  alphanumerics, such as "and", "or", "mod" *)

| [ 'A' - 'Z' 'a' - 'z'] [ 'A' - 'Z' 'a' - 'z' '_' '0' - '9'] *

{ let lex_item = lexeme lexbuf
  in try Hashtbl.find keyword_table lex_item
     with Not_found ->
       try let prim_const = Hashtbl.find primconst_table lex_item
           in TPrimConst prim_const
       with Not_found -> 
         try let prim_const = Hashtbl.find primbinconst_table lex_item
             in TPrimBinConst prim_const
         with Not_found -> 
           TId lex_item
} 

and commentLex = parse

    "(*" 
    { incr comment_depth; commentLex lexbuf }

  | "*)" 
    { decr comment_depth;
      if !comment_depth == 0 then () else commentLex lexbuf }

  | "\n"
    { incr_lex_counters lexbuf; commentLex lexbuf }

  | eof 
    { raise UnterminatedComment }

  | _ 
    { commentLex lexbuf }

and lineCommentLex = parse

   "\n"
    { incr_lex_counters lexbuf; () }

  | eof
    { () }

  | _ 
    { lineCommentLex lexbuf }

(* trailer code *)      

{ 
(* interface_fish.ml *)


exception FishSyntaxError of int * int * string (* line, column *)

let runParser pr lexer lexbuf =
  line_number := 1;
  buf_pos := lexeme_end lexbuf;
  try pr lexer lexbuf
  with 
    Parse_error -> 
      let cur_pos = lexeme_start lexbuf 
      in        
      if (cur_pos >= !buf_pos)
      then raise 
          (FishSyntaxError 
             (!line_number,cur_pos - !buf_pos + 1,""))
      else raise (* last valid lexeme on previous line *)
          (FishSyntaxError 
             (!line_number - 1,cur_pos - !last_buf_pos + 1,""))
  | Failure message -> 
      let cur_pos = lexeme_start lexbuf 
      in        
      if (cur_pos >= !buf_pos)
      then raise 
          (FishSyntaxError 
             (!line_number,cur_pos - !buf_pos + 1,message))
      else raise (* last valid lexeme on previous line *)
          (FishSyntaxError 
             (!line_number - 1,cur_pos - !last_buf_pos + 1,message))
;;

(* supply lexical buffers to parsers *)

let makeParserForFile pr fileName =
    pr (from_channel (open_in fileName))
;;

let makeParserForConsole pr =
    pr (from_channel stdin)
;;

let makeParserForString pr s =
    pr (from_string s)
;;

let makeParser pr lexbuf =
  runParser pr mainLex lexbuf
;;

(* parsers for shell interaction *)

let parseShell : lexbuf -> Util_fish.fish_shell_action =
  makeParser parseShellAction
;;

let parseShellFromFile fileName =
  makeParserForFile parseShell fileName
;;

let parseShellFromConsole () =
  makeParserForConsole parseShell 
;;

let parseShellFromString s =
  makeParserForString parseShell s
;;

(* parsers for list of shell actions *)

let parseShellList  : lexbuf -> Util_fish.fish_shell_action list =
  makeParser parseShellActionList

let parseShellListFromConsole () =
  makeParserForConsole parseShellList
;;

let parseShellListFromFile fileName =
  makeParserForFile parseShellList fileName
;;

let parseShellListFromString s =
  makeParserForString parseShellList s
;;

(* parsers for fish terms *)

let parseForFish : lexbuf -> fish_term =
  makeParser parseFish

let parseFishFromConsole () =
  makeParserForConsole parseForFish
;;

let parseFishFromFile fileName =
  makeParserForFile parseForFish fileName
;;

let parseFishFromString s =
  makeParserForString parseForFish s
;;
}


@head(2,"unify_fish.mli")
unify_fish.mli.
@select(tangler("src/unify_fish.mli"))
exception Incompatible_datum_types of Primitive_fish.prim_type *
                                        Primitive_fish.prim_type
exception UnifyArrayError of Types_fish.arrayType * Types_fish.arrayType
exception UnifyPhraseError of Types_fish.phraseType * Types_fish.phraseType
exception OccursPhraseError of Types_fish.phraseType * Types_fish.phraseType
exception OccursArrayError of Types_fish.arrayType * Types_fish.arrayType
val unifyLoop :
  (Types_fish.phraseType * Types_fish.phraseType) list * 
    Type_subs_fish.tySub ->
      Type_subs_fish.tySub 



@head(2,"unify_fish.ml")
unify_fish.ml.
@select(tangler("src/unify_fish.ml"))
(* unify_fish.ml *)

(* 

More or less the standard unification technique. Novelties arise due
to

1. the use of two kinds of type variables 

2. possible ambiguities when considering shapes of phrase variables

3. implicit coercions from var alpha to exp alpha, and static to dynamic. 

Ambiguities are handled by default choices. Alternatives must be
specified by explicit types in the program. 

makeUnifyList looks at one unification pair. unifyLoop uses this in
one step of a loop that passes through a list of unification pairs.

*)



open Primitive_fish
open Types_fish
open Type_subs_fish


exception Incompatible_datum_types of prim_type * prim_type 

exception Unify                                        (* internal *)
exception UnifyArrayError of arrayType * arrayType     (* external *)
exception UnifyPhraseError of phraseType * phraseType  (* external *)

exception OccursPhrase of phraseTyVar * phraseType     (* internal *)
exception OccursArray of arrayTyVar * arrayType        (* internal *)
exception OccursPhraseError of phraseType * phraseType (* external *) 
exception OccursArrayError of arrayType * arrayType    (* external *) 

let immediate = ([],idTySub)
let continue pairs = (pairs,idTySub)


let add_array_subst_check tv ty3 = 

           match ty3 with
           | ArrayTV tv' when tv = tv' -> immediate 
           | _ when arrayVarOccursInArray tv ty3 -> 
               raise (OccursArray (tv,ty3))
           | _ -> ([],addArrayTySub tv ty3 idTySub)

let add_phrase_subst_check tv ty3 = 

           match ty3 with
           | PhraseTV tv' when tv = tv' -> immediate 
           | _ when phraseVarOccursInPhrase tv ty3 -> 
               raise (OccursPhrase (tv,ty3))
           | _ -> ([],addPhraseTySub tv ty3 idTySub)

let datumUnify (x,y) = 
  if x = y                  (* || (x = IntTy && y = FloatTy) 
                               NO coercion from ints to floats *)
  then immediate 
  else raise (Incompatible_datum_types (x,y))
;;


let rec arrayUnify (ty,ty') = 
    match (ty,ty') with 

    | (ArrayTV x,_) -> add_array_subst_check x ty'      
    | (_,ArrayTV _) -> arrayUnify (ty',ty)
    | (DatumTy x,DatumTy y) ->  datumUnify (x,y)
    | (ArrayTy ty1,ArrayTy ty2) -> arrayUnify (ty1, ty2)
    |  _ -> raise (UnifyArrayError (ty,ty'))

let shapeUnify (ty,ty')  = 
    match (ty,ty') with 

    | (StaticTy x, StaticTy y) -> datumUnify (x,y)  

          (* coercions for size, #int etc *)

    | (StaticTy x, HashArrayTy y) -> 
        (match y with 
          ArrayTV _ -> arrayUnify (DatumTy x,y)  
        | DatumTy z -> datumUnify (x,z) 
        | _ -> raise Unify
        )
    | (HashArrayTy ty1,HashArrayTy ty2) -> arrayUnify (ty1, ty2) 
    |  _ -> raise Unify

let dataUnify (ty,ty') =
    match (ty,ty') with 

    | (AT ty1,AT ty2) -> arrayUnify (ty1,ty2) 
    | (ShT ty1,ShT ty2) -> shapeUnify (ty1,ty2)  

        (* coercions for size, int etc *)

    | (ShT (StaticTy ty1), AT ty2) -> 
        arrayUnify (DatumTy ty1, ty2) 

    | _ -> raise Unify


let rec makeUnifyList (ty,ty') = 

  match (ty,ty') with

(* type variable - type   *)
(* type - type variable *)
(* hash phrase type variable - type *)
(* type  - hash phrase type var *)
(* other cases *)

    | (PhraseTV tv,_) -> add_phrase_subst_check tv ty'  

    | (_,PhraseTV _) -> makeUnifyList (ty',ty)  

    | (HashPhraseTy tv, HashPhraseTy tv') -> 
        continue [ PhraseTV tv, PhraseTV tv' ]

    | (HashPhraseTy tv, ExpTy (ShT (StaticTy BoolTy))) -> 
        add_phrase_subst_check tv CommTy 

    | (HashPhraseTy tv, ExpTy (ShT (StaticTy _))) -> 
            ([], addPhraseTySub tv ty' idTySub)

    | (HashPhraseTy tv, ExpTy (ShT(HashArrayTy x))) -> 
        continue [ PhraseTV tv, ExpTy (AT x) ] 

    | (HashPhraseTy (PhraseTyVar x), FunTy (theta,theta')) 
            when (not (phraseVarOccursInPhrase (PhraseTyVar x) ty')) -> 
              let argVarName = next_phrase_tyvar()
              in let resVarName = next_phrase_tyvar()
              in  ( [ theta , 
                           HashPhraseTy argVarName;
                           HashPhraseTy resVarName ,
                           theta' 
                         ],
                   addPhraseTySub 
                     (PhraseTyVar x) 
                     (FunTy (PhraseTV argVarName,
                             PhraseTV resVarName))
                     idTySub )

    | (HashPhraseTy tv, _) -> raise (UnifyPhraseError (ty,ty'))

    | (t,HashPhraseTy _) ->  makeUnifyList (ty',ty)   


    | (ExpTy ty1,ExpTy ty2) -> dataUnify (ty1,ty2)  
    | (VarTy ty1,VarTy ty2) -> arrayUnify (ty1,ty2) 
                                       (*no coercions allowed *)
    | (CommTy,CommTy) -> immediate 
    | (FunTy (ty1,ty2),FunTy (ty3,ty4)) ->
                continue [(ty3,ty1) ; 
                          (ty2,ty4) ]

    (* coercions *)

    | (VarTy ty1,ExpTy ty2) -> dataUnify (AT ty1, ty2)  



    (* failure  *)

    | _ -> raise Unify
;;


let rec unifyLoop (toDo,tySub) =
   (* toDo is a list of unification pairs *)

  match toDo  with               

  | [] -> tySub 
  | (ty1,ty2)::rest  ->

      let (newToDo,newTySub) = 
        let ty3 = applyTySub tySub ty1 
        and ty4 = applyTySub tySub ty2 in 
        try makeUnifyList (ty3,ty4) 
        with
 
        | OccursPhrase (tv,ty) -> 
            raise (OccursPhraseError (PhraseTV tv,ty))
        | OccursArray (tv,ty) -> 
            raise (OccursArrayError (ArrayTV tv,ty))
        | _ -> raise (UnifyPhraseError (ty3,ty4))

      in 
      unifyLoop (newToDo @ rest, o_ts newTySub tySub)
;;


@head(2,"infer_fish.mli")
infer_fish.mli.
@select(tangler("src/infer_fish.mli"))
exception UnboundVariable of Terms_fish.term_variable
val infer :
  Types_fish.fishTyScheme Environments_fish.TyEnv.t ->
  Terms_fish.fish_term ->
  Terms_fish.fish_term * Types_fish.phraseType * Type_subs_fish.tySub

@head(2,"infer_fish.ml")
infer_fish.ml.
@select(tangler("src/infer_fish.ml"))
(* infer_fish.ml *)


open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Type_subs_fish
open Substitution_fish
open Pretty_fish
open Unify_fish

exception UnboundVariable of term_variable

(* type inference (algorithm W)
   given a term and type environment, 
   returns a type/type substitution pair *)


(* Coercions complicate shape computations: #(3:size) = 3 while
#(3:int) = int_shape. To resolve this, all terms will be explicitly
typed, and these types used during partial evaluation. *)

let rec coerced (term,ty0,tySub) ty1 = 
let (ty0',ty1') = (applyTySub tySub ty0,applyTySub tySub ty1) in 
let term2 = 
  match (ty0',ty1') with 
    _ when ty0' = ty1' -> term
  | ExpTy (ShT (StaticTy pty)), ExpTy (AT (DatumTy _)) -> 
      ap (Dyn pty) term
  | ExpTy (ShT (StaticTy pty)), ExpTy (ShT (HashArrayTy _)) -> 
      shape (ap (Dyn pty) term)
  | FunTy (ty00,ty01), FunTy(ty10,ty11) ->
      let x = nextvar() in 
      let (arg,ty2,_) = coerced (Tvar x,ty10,tySub) ty00 in 
      let (body, ty3, _) = coerced (ap term arg, ty01,tySub) ty11 in 
      lam x body
  | _ -> term (* shouldn't happen *)
in 
(term2, ty1',tySub) 
;;

let rec infer_with_tysub tyEnv term e tySub = 

let rec inf (term, e, tySub) = 

(* Find a type substitution tySub' and a coerced variant t' of t such
   that t' : tySub' e *)

  match term with 

   (* term variables *)

    | Tvar x -> 

        let x_ty_env = 
          try (inst_tyscheme (TyEnv.find (raw x) tyEnv))
          with Not_found -> raise (UnboundVariable x) in 
        let x_ty_dec = 
          try (declaredType x)
          with NoType ->  x_ty_env
        in
        let tySub2 = 
          unifyLoop([x_ty_env , x_ty_dec ; x_ty_dec , e ] , tySub) 
        in 
        coerced (coerced(Tvar x,x_ty_env,tySub2) x_ty_dec) e

        (* 
           The environment type is definitive.
           The declared type is coercive. 
        *)


    (* application *)

    | Apply (rator,rand) ->

        let tv1 = PhraseTV (next_phrase_tyvar()) in 
        let (rator2, _, tySub2) = inf (rator, funty tv1 e, tySub)  in  
        let (rand2,  _, tySub3) = inf (rand, tv1, tySub2)  
        in 
        (Apply (rator2,rand2), applyTySub tySub3 e , tySub3)

    (* functions *)

    | Lam (x,body) ->

        let tv1 = 
          try (declaredType x)
          with NoType -> PhraseTV (next_phrase_tyvar()) in 
        let tv2 = PhraseTV (next_phrase_tyvar()) in 
        let naturalTy = funty tv1 tv2 in 
        let tySub2 = unifyLoop ([ naturalTy, e ], tySub) in 
        let (body2,e2,tySub3) = 
          infer_with_tysub
           (TyEnv.add (raw x) (TyScheme ([],[],tv1)) tyEnv)
           body tv2 tySub2 in 
        coerced
          (Lam (x,body2),
           naturalTy,
           tySub3)
          e
        
    (* polymorphic binder *) 

    | Where (body,x,wTerm) ->
        let tv = PhraseTV (next_phrase_tyvar()) in 
        let (wTerm2,wTy,wTs) = inf (wTerm, tv, tySub) in 
        let wTyEnv = applyTySubToEnv wTs tyEnv in 
        let newTyEnv = TyEnv.add (raw x) (closTy wTy wTyEnv) wTyEnv in 
        let (body2,_,tySub2) = infer_with_tysub newTyEnv body e wTs in 
        (Where(body2,x,wTerm2),applyTySub tySub2 e,tySub2)

    (* constructors *)

    | Op(Prim_value v,[]) -> 
        let naturalTy = mk_static_ty (type_prim_value v) in 
        let tySub2 = unifyLoop([naturalTy,e] , tySub) in
         coerced (term, naturalTy, tySub2) e

    | Op(Pconst([pty0;pty2],b,name),[t]) ->   
        let tv0 = PhraseTV (next_phrase_tyvar()) in 
        let (t2,ty0,tySub2) = inf (t, tv0, tySub)
        and ty1 = ExpTy(AT(DatumTy pty2)) in

        let (naturalTy,us) = 
          if is_polymorphic name 
          then 
            try 
              match get_datum_ty ty0 with 
                FloatTy -> (if isShapeTy ty0 then cost else float),[]
              | _       -> (if isShapeTy ty0 then size else int),[]
            with _ -> ty1, [ ty0 , ty1 ] (* default is dynamic *)
        
          else 
            try 
              if get_datum_ty ty0 = pty0 
              then 
                if isShapeTy ty0 
                then (ExpTy (ShT (StaticTy pty2)) , [])
                else (ty1, [])
              else ty1, [ ty0 , ty1 ]  (* failure *)
               
            with _ -> (ty1, [ ty0 , ty1 ])
        in
        let tySub3 = unifyLoop ((naturalTy , e) :: us, tySub2)
        and newname = instantiate_polymorphic_op name pty0
        in 
        coerced 
          (Op(Pconst([pty0;pty2],b,newname),[t2]),
           naturalTy,
           tySub3) 
          e


    | Op(Pconst([pty0;pty1;pty2],_,name),[t0;t1]) ->
                                                    
        let tv0 = PhraseTV (next_phrase_tyvar())  
        and tv1 = PhraseTV (next_phrase_tyvar()) in 
        let (t2,ty0,tySub1) = inf (t0,tv0, tySub) in
        let (t3,ty1,tySub2) = inf (t1, tv1, tySub1) in 

        let (argTy,naturalTy) =
          if is_polymorphic name 
          then 
            let pty = 
              try get_datum_ty ty0 
              with _ -> 
              try get_datum_ty ty1 
              with _ -> IntTy (* default datum type *)
            in 
              match (pty2 = BoolTy, isShapeTy ty0 && isShapeTy ty1) with 
                (true,true)   -> mk_static_ty pty, fact
              | (true,false)  -> mk_datum_ty  pty, bool
              | (false,true)  -> mk_static_ty pty, mk_static_ty pty
              | (false,false) -> mk_datum_ty  pty, mk_datum_ty  pty    

          else
            if isShapeTy ty0 && isShapeTy ty1
            then (mk_static_ty pty0, mk_static_ty pty2)
            else (mk_datum_ty  pty0, mk_datum_ty  pty2)

        in 
        let tySub3 = 
          unifyLoop([ty0, argTy ; ty1, argTy ; naturalTy, e], tySub2) 
        and newname = instantiate_polymorphic_op name pty0 in 
        let d = Pconst([pty0;pty1;pty2],true,newname)
        in 
        let (t4,_,_) = coerced (t2,ty0,tySub3) argTy 
        and (t5,_,_) = coerced (t3,ty1,tySub3) argTy 
        in 
        coerced (Op(d,[t4;t5]), naturalTy, tySub3) e

    | Op (s,_) -> raise (Fish_error "unknown operation")

    | Get t1 -> 
       let tv1 = PhraseTV (next_phrase_tyvar()) 
       and tv2 = ArrayTV (next_array_tyvar ()) in 
       let (t2,e2,tySub2) = inf (t1, tv1, tySub) in 
         let (argTy,naturalTy) = 
           match e2 with 
           ExpTy _ -> (ExpTy (AT (ArrayTy tv2)), ExpTy (AT tv2))
         | VarTy _ -> (VarTy     (ArrayTy tv2) , VarTy     tv2)
         | _ -> raise (Fish_error "cannot resolve type of get")
         in 
         let tySub3 = unifyLoop ([ naturalTy, e], tySub2) in 
         let (t3,e3,tySub4) = inf (t2, argTy, tySub3) 
         in 
         coerced 
           (Get t3,
            naturalTy, 
            tySub4) 
           e

    | Sub (t1,t2) -> 
       let tv1 = PhraseTV (next_phrase_tyvar()) 
       and tv2 = ArrayTV (next_array_tyvar ()) in 
       let (t3,e2,tySub2) = inf (t1, tv1, tySub)  in 
         let naturalTy = 
           match e2 with 
           ExpTy _ -> ExpTy (AT (ArrayTy tv2))
         | VarTy _ -> VarTy     (ArrayTy tv2)
         | _ -> raise (Fish_error "cannot resolve type of get")
         in 
         let tySub3 = unifyLoop ([naturalTy, e], tySub2) in 
         let (t4,e3,tySub4) = inf (t1, naturalTy, tySub3) in
         let (t5,e4,tySub5) = inf (t2, int, tySub4) 
         in 
         coerced
           (Sub(t4,t5),
            naturalTy,
            tySub5)
           e

    | Condsh(t0,t1,t2) -> (

       (* this condsh may in fact be a datum conditional *)

        let tv0 = PhraseTV (next_phrase_tyvar())  
        and tv1 = PhraseTV (next_phrase_tyvar())  
        and tv2 = PhraseTV (next_phrase_tyvar()) 
        and tv3 = ExpTy (AT (ArrayTV (next_array_tyvar())))  
        in 
        let (t00,e0,tySub2) = inf (t0, tv0, tySub)  in 
        let (t3,e3, tySub3) = inf (t1, tv1, tySub2) in 
        let (t4,e4, tySub4) = inf (t2, tv2, tySub3) in 

        let ch,tySub5 =    (* ch is the choice of conditional form *)
          match e0,e3,e4 with 

            ExpTy(ShT (StaticTy BoolTy)),_,_  
          | _,FunTy _,_
          | _,_,FunTy _ -> 
              (condsh_term,
                try 
                  unifyLoop([ e0, fact ; tv1, tv2 ; tv2 , e ] , tySub4) 
                with _ -> (* reverse unification *)
                  unifyLoop([ e0, fact ; tv2, tv1 ; tv1 , e ] , tySub4) 
                    )
          | _ -> 
              try  
                (cond_term, unifyLoop([ e0, bool ;       
                             e3, CommTy ; 
                             e4, CommTy ; 
                             CommTy, e ] , tySub4))
              with _ -> 
                try 
                  (condexp_term,unifyLoop([ tv0, bool ;      
                               e3, e4 ; 
                               e4, tv3 ;
                               tv3, e ] , tySub4))
                with _ -> (* reverse unification *)

                  (condexp_term, 
                      unifyLoop([ tv0, bool ; 
                               e4, e3 ; 
                               e3, tv3 ;
                               tv3, e ] , tySub4))
        in 
        let (t5,_,_) = coerced(t3,e3,tySub5) e
        and (t6,_,_) = coerced(t4,e4,tySub5) e
        in 
        (ap3 ch t00 t5 t6,applyTySub tySub5 e,tySub5)
                  )


    | Typed (t1,ty) -> 
        let tySub2 = unifyLoop  ([ty,e], tySub) in 
        coerced (inf (t1, ty, tySub2)) e

        (* user declared  types are checked and discarded *)


    (* array expressions *) 

    | _ -> 
        let naturalTy = inst_tyscheme (combinator_tyscheme term) in 
        let tySub2 = unifyLoop([naturalTy,e],tySub)  in 
        coerced 
          (term, 
           naturalTy, 
           tySub2) 
          e
in inf (term, e, tySub);;


let rec infer tyEnv term = 
  let e = PhraseTV (next_phrase_tyvar()) in
  let (term2,ty,tysub) = infer_with_tysub tyEnv term e idTySub in 
  (applyTySubToTerm tysub term2,ty,tysub)
;;


@head(2,"partial_ev_fish.mli")
partial_ev_fish.mli.
@select(tangler("src/partial_ev_fish.mli"))
val part_ev :
  (string * Util_fish.show_mode) list ->
  (Terms_fish.term_variable * (Terms_fish.fish_term * Terms_fish.fish_term))
  list -> Terms_fish.fish_term -> Terms_fish.fish_term

@head(2,"partial_ev_fish.ml")
partial_ev_fish.ml.
@select(tangler("src/partial_ev_fish.ml"))

(* 
   Partial Evaluation of Fish terms
   ================================

This will follow the format of the language definition:

 - perform all beta reductions, 
 - eliminate all phrase polymorphic constants, especially #
 - reduce  all shape expressions to normal form
 - eliminate civilised expression constants, i.e. newexp 

The intermediate terms vtc and vte have been treated as auxiliary
functions.

The problem of distinguishing static from dynamic data means that
there are two forms of partial evaluation. Where sizes appear in types
(of primrec and succdim) then the value of "static" is true. For the
other constants "static" = false. Functions are not affected by the
value of static and so it is left unchanged. Function arguments cannot
be evaluated until their context is known, so evaluation is by
name. This could be changed to greedy at a later date.

*)


open List

open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Substitution_fish
open Pretty_fish
open Parse_fish


(* 
   auxiliary functions for handling non-primitive indices,
   e.g. newexp. is_nasty extracts the indices from an array variable,
   which are then checked by is_civil, which is true if there is a
   newexp or conditional within.  If so, then vtc or vte is invoked,
   to move these blocks to the outside.  
*)

let rec is_civil t = 
  match t with 
    Op(_,ts) -> exists is_civil ts 
  | Get t1 -> is_civil t1 
  | Sub(t1,t2) -> is_civil t1 || is_civil t2
  | Cond _  
  | Condexp _  
  | Typed _   
  | Apply(Apply(Newexp,_),_) -> true (* first and third shouldn't happen *)
  | _ -> false
;;

let rec is_nasty t = (* looking for complex indices in a pe array variable *)
  match t with 
    Get t1 -> is_nasty t1
  | Sub(t1,t2) -> is_nasty t1 || is_civil t2
  | Typed(t1,_) -> is_nasty t1  (* shouldn't happen *)
  | _ -> false
;;



let rec vtc term1 term2 = 
  match term2 with

    Get t -> 
      let x = nextvar() in 
      vtc (lam x (ap term1 (Get (Tvar x)))) t

  | Sub(t,i) when is_civil i -> 
      let x = nextvar() 
      and j = nextvar() in 
      vtc (lam x (
             newvar (Bang IntTy) (lam j (
             seq (assign (Tvar j) i)
                 (ap term1 (Sub(Tvar x,Tvar j))))))) t
      
  | Sub(t,i)  -> 
      let x = nextvar() in 
      vtc (lam x (ap term1 (Sub(Tvar x,i)))) t

  |  _ -> 
      ap term1 term2
;;

let rec vte term1 term2 = 
  match term2 with

    Get t -> 
      let x = nextvar() in 
      vte (lam x (ap term1 (Get (Tvar x)))) t

  | Sub(t,i) when is_civil i -> 
      let x = nextvar() 
      and y = nextvar()  
      and j = nextvar() in 
      vte (lam x (
             newexp (preddim (shape t)) (lam y (
               newvar (Bang IntTy) (lam j (
                 seq (assign (Tvar j) i)
                     (assign (Tvar y) (ap term1 (Sub(Tvar x,Tvar j)))))))))) t

  | Sub(t,i) -> 
      let x = nextvar() 
      and y = nextvar() in 
      vte (lam x (
             newexp (preddim (shape t)) (lam y (
               newvar (Bang IntTy) 
                     (assign (Tvar y) (ap term1 (Sub(Tvar x,i)))))))) t

  | _ -> 
      ap term1 term2
;;


(*
        Partial Evaluator
        =================

mutual recurson of 

some auxillary functions for evaluating blocks
a general partial evaluator, pe  
one for applications, peap 
one for shapes, pesh
one for shaping under lambdas, propagate_shape

*)


let rec part_ev modes shEnv  = 

let rec pe term =
  match term with 

  | Tvar x -> (try let (_,exp) = assoc x shEnv in exp (* a value *)
               with Not_found -> term )      (* when evaluating the body *)

  | Apply(x,y) -> (
      let x1 = pe x in 
      match x1 with 
        Lam(z,t) ->                      (* if a lambda *)
          let y1 = (
            try pe y                     (* evaluate y *)
            with Shape_error _ -> y)     (* unless error *)
          in pe (substitute z y1 t)      (* and reduce *)
      |        _ -> peap x1 (pe y)              (* otherwise peap 
                                            peap takes values as args *)
            )

(* 
  | Lam(x,t) 
  | Op(dconst,[]) are handled by default 
*)

  | Where(x,y,z) -> 
      let z1 = (
        try pe z 
        with Shape_error _ -> z)
      in 
      pe (substitute y z1 x)


  (* some expression reductions here - the rest are in peap *)

  | Op (Pconst([pty0;pty],_,_) as dconst, [x]) -> 
      let x1 = pe x in 
          (match x1 with 

            Apply(Apply(Newexp,sh),f) -> 
              let y = nextvar() in 
              let g = lam y (Op(dconst,[Tvar y])) in
              if    pty0 = pty 
                 && List.assoc "datum_opt" modes = Util_fish.Show_on
              then addExp  sh            f g  
              else addTwo  (Bang pty) sh f g
                
          | Cond(t0,t1,t2) -> Cond(t0,
                                   pe (Op(dconst,[t1])), 
                                   pe (Op(dconst,[t2])))

          | Condexp(t0,t1,t2) -> Condexp(t0,
                                   pe (Op(dconst,[t1])), 
                                   pe (Op(dconst,[t2])))

          | Op(Prim_value v,[]) ->         (* optimisation *)
                Op(Prim_value (apply_delta dconst [v]),[])

          | Apply(Dyn pty,x2) -> ap (Dyn pty) (pe (Op(dconst,[x2])))

          | _ when is_nasty x1 -> 
              let x = nextvar() in 
              pe (vte (lam x (Op(dconst,[Tvar x]))) x1)
 
          | _ -> Op (dconst, [x1]) 
          )

  | Op (Pconst([pty0;pty1;pty],_,_) as dconst, [x;y]) -> 
      let x1 = pe x
      and y1 = pe y in 
          (match (x1,y1) with 

            Apply(Apply(Newexp,sh),f), _ -> 
              let x2 = nextvar() in 
              let g = lam x2 (Op(dconst,[Tvar x2;y1])) in 
              if pty0 = pty && List.assoc "datum_opt" modes = Util_fish.Show_on
              then addExp  sh            f g  
              else addTwo  (Bang pty) sh f g

          | Cond(t0,t1,t2), _ -> Cond(t0, 
                                      pe (Op(dconst,[t1;y1])),
                                      pe (Op(dconst,[t2;y1])))

          | Condexp(t0,t1,t2), _ -> Condexp(t0, 
                                      pe (Op(dconst,[t1;y1])),
                                      pe (Op(dconst,[t2;y1])))

          | Apply(Dyn _,x2),  Apply(Dyn _,y2) -> 
              let pty = return_type_prim_constant dconst in 
              ap (Dyn pty) (pe (Op(dconst,[x2;y2])))

          | Apply(Dyn _,x2), _ -> 
              let pty = return_type_prim_constant dconst in 
              ap (Dyn pty) (pe (Op(dconst,[x2;y1])))

          | _ when is_nasty x1 ->
              let u = nextvar() in 
              pe (vte (lam u (Op(dconst,[Tvar u;y1]))) x1)

          | _, Apply(Apply(Newexp,sh),f) -> 
                let y2 = nextvar() in 
                let g = lam y2 (Op(dconst,[x1;Tvar y2])) in 
                if pty0 = pty && List.assoc "datum_opt" modes = Util_fish.Show_on
                then addExp  sh            f g  
                else addTwo  (Bang pty) sh f g

          | _, Cond(t0,t1,t2) -> Cond(t0, 
                                      pe (Op(dconst,[x1;t1])),
                                      pe (Op(dconst,[x1;t2])))

          | _, Condexp(t0,t1,t2) -> Condexp(t0, 
                                      pe (Op(dconst,[x1;t1])),
                                      pe (Op(dconst,[x1;t2])))

          | _, Apply(Dyn pty,y2) -> 
              let pty = return_type_prim_constant dconst in 
              ap (Dyn pty) (pe (Op(dconst,[x1;y2])))

          | _ when is_nasty y1 ->
              let u = nextvar() in 
              pe (vte (lam u (Op(dconst,[x1;Tvar u]))) y1)

          | Op(Prim_value v1,[]), Op(Prim_value v2,[]) -> 
                                                  (* optimisation *)
              Op(Prim_value (apply_delta dconst [v1;v2]),[])

          | _,_ -> Op (dconst,[x1;y1])
          )

  | Op (_,_::_) -> raise (Fish_error "invalid primitive application")

  | Get term2 ->  
      let term3 = pe term2 in 
      (match term3 with 
        
      | Apply(Apply(Newexp, sh), f) -> 
          addTwo  (pe (undim sh)) sh 
            f 
            (get_term())

      | Condexp(t0,t1,t2) ->
          Condexp(t0, pe (Get t1), pe (Get t2))

      | _ -> Get term3
      )

  | Sub (t1,t2) ->          
      let t3 = pe t1
      and t4 = pe t2 in 

      (match t3 with 

      | Apply(Apply(Newexp, sh), f)   -> 
                  let x = nextvar() in 
                  addTwo  (pe (preddim sh)) sh 
                    f 
                    (lam x (Sub (Tvar x,t4)))
  
      |        Condexp(s0,s1,s2) -> Condexp(s0, 
                                    pe (Sub(s1,t4)), 
                                    pe (Sub(s2,t4)))

            (* cannot do subexp t0 (newexp sh f) here as it may be a sub. 
               Mix this with the vtc cases below *)

      |        _ -> Sub (t3,t4) 
      )

  | Condsh(x,y,z) -> (
      let x1 = pe x in 
      match x1 with 
        
      |        Op (Prim_value (Bool true) ,[]) -> pe y  
      |        Op (Prim_value (Bool false),[]) when z = Error -> 
          raise (Shape_error ([x],"became false in check"))
      |        Op (Prim_value (Bool false),[]) -> pe z
      |        _ -> Condsh(x1, (try pe y with _ -> Error),try pe z with _ -> Error) 
          )

  | Cond(x,y,z) -> 
      let x1 = pe x
      and y1 = pe y
      and z1 = pe z in 
      let y2 = pesh y1
      and z2 = pesh z1 in 
          if not (pe (equal y2 z2) = 
                Op (Prim_value (Bool true),[]))
          then raise (
            Shape_error ([y2 ; z2 ], 
                 "are different shapes for branches of a datum conditional"))
          else 
            (match (x1,y1,z1) with 
        
            | Apply(Dyn _,Op (Prim_value (Bool true) ,[])),_,_ -> y1  
            | Apply(Dyn _,Op (Prim_value (Bool false),[])),_,_ -> z1
    
             (* an optimisation for data conditionals *)

            | Apply(Apply(Newexp,sh),f),_,_ -> 
                let u = nextvar() in 
                addVar sh f (lam u (Cond(Tvar u, y1, z1)))

            |        Condexp(b,s1,s2),_,_ -> 
                Cond(b, 
                       pe(Cond(s1,y1,z1)), 
                       pe(Cond(s2,y1,z1)))

            | _ when is_nasty x1 ->
                let u = nextvar() in 
                pe (vtc (lam u (Cond(Tvar u,y1,z1))) x1)

            | _,Apply(Apply(Newexp,sh),f),_ -> 
                let u = nextvar() in 
                bodyEval (ap Newvar sh) sh 
                  (pe (lam u (Cond(x1,ap f (Tvar u),z1))))

            | _ when is_nasty y1 ->
                let u = nextvar() in 
                pe (vtc (lam u (Cond(x1,Tvar u,z1))) y1)

            | _,_,Apply(Apply(Newexp,sh),f) -> 
                let u = nextvar() in 
                bodyEval (ap Newvar sh) sh 
                  (pe (lam u (Cond(x1,y1,ap f (Tvar u)))))

            | _ when is_nasty z1 ->
                let u = nextvar() in 
                pe (vtc (lam u (Cond(x1,y1,Tvar u))) z1)


            | _ -> Cond(x1,y1,z1) 
                  )

  | Condexp(x,y,z) -> 
      let x1 = pe x
      and y1 = pe y
      and z1 = pe z in 
      let ysh = pesh y1
      and zsh = pesh z1 in 
          if not (pe (equal ysh zsh) = 
                Op (Prim_value (Bool true),[]))
          then raise (
            Shape_error ([ysh ; zsh ], 
                 "are different shapes for branches of a datum conditional"))
          else 
            (match (x1,y1,z1) with 
        
            | Apply(Dyn _,Op (Prim_value (Bool true) ,[])),_,_ -> y1  
            | Apply(Dyn _,Op (Prim_value (Bool false),[])),_,_ -> z1
    
             (* an optimisation for data conditionals *)

            | Apply(Apply(Newexp,sh),f),_,_ -> 
                let u = nextvar() in 
                addTwo ysh sh f (lam u (Condexp(Tvar u, y1, z1)))

            |        Condexp(b,s1,s2),_,_ -> 
                Condexp(b, 
                       pe(Condexp(s1,y1,z1)), 
                       pe(Condexp(s2,y1,z1)))

            | _ when is_nasty x1 ->
                let u = nextvar() in 
                pe (vte (lam u (Condexp(Tvar u,y1,z1))) x1)

            | _,Apply(Apply(Newexp,sh),f),_ -> 
                let u = nextvar() in 
                addExp sh f (lam u 
                             (Cond(x1,
                                     ap f (Tvar u),   
                                     assign (Tvar u) z1)))

            | _ when is_nasty y1 ->
                let u = nextvar() in 
                pe (vte (lam u (Condexp(x1,Tvar u,z1))) y1)

            | _,_,Apply(Apply(Newexp,sh),f) -> 
                let u = nextvar() in 
                addExp sh f (lam u 
                             (Cond(x1,
                                   assign (Tvar u) y1,
                                   ap f (Tvar u) 
                                     )))

            | _ when is_nasty z1 ->
                let u = nextvar() in 
                pe (vte (lam u (Condexp(x1,y1,Tvar u))) z1)


            | _ -> Condexp(x1,y1,z1) 
                  )

  | Typed(t,ty) -> pe t (* shouldn't happen *)

  | Error -> raise (Shape_error ([Error],"appears explicitly"))

  | _ -> term               (* lambda's and constants are values *)


     (* Application Evaluation *)


and peap term1 term2 =       (* term1 and term2 are values *)

  match term1 with 

    (* beta reduction *)

  | Lam(x,term3) -> pe (substitute x term2 term3)

    (* commands *)

  | Apply(Assign,term3) when is_nasty term3 ->
      let x = nextvar() in 
      pe (vtc (lam x (assign (Tvar x) term2)) term3)

  | Apply(Assign,term3) -> (
      match term2 with  

      |        Apply(Apply(Newexp,sh),f) ->
          if List.assoc "assign_opt" modes = Util_fish.Show_on
              &&
            let vars3 = free_vars term3
            and vars2 = free_vars term2 in 
            let g y =  mem y vars2 
            in 
            not (exists g vars3) 
          then 
            pe (check (equal (shape term3) sh) 
                             (ap f term3)
                     )
          else addVar sh f term1
                     
      | Condexp(t0,t1,t2) ->  
          Condexp(t0, peap term1 t1, peap term1 t2)

      | _ when is_nasty term2 -> 
          let x = nextvar() in 
          pe (vte (lam x (ap term1 (Tvar x))) term2)
      | _ -> ap term1 term2
        )

  | Forall -> (
      match term2 with  
        Apply(Apply(Newexp, sh), f) ->  
          let x = nextvar() 
          and y = nextvar() 
          and z = nextvar() in
          lam y (lam z (newvar sh (lam x (
                        seq 
                          (ap f (Tvar x)) 
                          (forall (Tvar x) (Tvar y) (Tvar z))
                          ))))
                        
      | Condexp(b,t0,t1) -> 
           let y = nextvar() 
          and z = nextvar() in
          lam y (lam z (Cond(b, 
               forall t0 (Tvar y) (Tvar z),
               forall t1 (Tvar y) (Tvar z))))

      | _ when is_nasty term2 ->
          let x = nextvar() 
          and y = nextvar() 
          and z = nextvar() in 
          (lam y (lam z (
           vte (lam x (forall (Tvar x) (Tvar y) (Tvar z))) term2)))
      | _ -> ap term1 term2
            )

  | Apply(Forall,x) -> (
      match term2 with  
        Apply(Apply(Newexp, sh), f) ->  
          let y = nextvar() 
          and z = nextvar() in
          lam z (newvar sh (lam y (
                            seq (ap f (Tvar y))
                              (forall x (Tvar y) (Tvar z))
                          )))
                        
      | Condexp(b,t0,t1) -> 
          let z = nextvar() in 
          lam z (Cond(b,
                      forall x t0 (Tvar z),
                      forall x t1 (Tvar z)))          

      | _ when is_nasty term2 ->
          let y = nextvar() 
          and z = nextvar() in 
          lam z (
           vte (lam y (forall x (Tvar y) (Tvar z))) term2)
      | _ -> ap term1 term2
            )

  | Apply(Apply(Forall,_),_) -> 
      let term3 = bodyEval term1 (Bang IntTy) term2 in 
      if List.assoc "loop_opt" modes = Util_fish.Show_on
      then 
        match term3 with 
          Apply(Apply(Apply(Forall,_),_),Lam(i,Apply(Apply(Newvar,sh),f))) ->
            let y = nextvar() in
            pe (newvar sh (lam y (ap term1 (lam i (ap f (Tvar y))))))
(*
            bodyEval (ap Newvar sh) sh 
              (lam y (ap term1 (lam i (ap f (Tvar y)))))
*)
        | _ -> term3
      else term3

  | Whiletrue -> (
      match term2 with  

        Apply(Dyn _,Op(Prim_value (Bool true),[])) -> 
          raise (Shape_error ([],"infinite while loop"))

      | Apply(Dyn _,Op(Prim_value (Bool false),[])) -> 
          let z = nextvar() in 
          lam z Skip

      | Apply(Apply(Newexp, sh), f) -> 
                 let x = nextvar() 
          and z = nextvar() in
          lam z (newvar sh (
                 lam x (seq 
                          (ap f (Tvar x))
                          (whiletrue (Tvar x) 
                             (seq (Tvar z) (ap f (Tvar x)))
                          ))))

      | Condexp(t0,t1,t2) ->
          let mix = pe (
            Op(prim_or,
              [ Op(prim_and, [t0;t1]) ;
                Op(prim_and, [
                  Op(prim_not,[t0]) ; 
                   t2
                ]) 
              ]        
            ))
          in ap Whiletrue mix

      | _ when is_nasty term2 ->
          let x = nextvar() 
          and y = nextvar() in 
          lam y (vte (lam x (whiletrue (Tvar x) (Tvar y))) term2)
      | _ -> ap term1 term2
            )
        
  | Apply(Whiletrue,x) -> (
      match term2 with 
        Apply(Apply(Newvar,sh),f) 
          when List.assoc "loop_opt" modes = Util_fish.Show_on -> 
            let y = nextvar() in
            bodyEval (ap Newvar sh) sh  
              (lam y (ap term1 (ap f (Tvar y))))
 
      | _ -> ap term1 term2
              )

  | Fix 0 ->            (* !! k>0 ?? *)                             
      bodyEval term1 (Op(Prim_value (Bool true),[])) 
        (pe term2)

  | Apply(Newvar,sh) ->         
      bodyEval term1 sh (pe term2)

  | Output -> (
      match term2 with 
        Apply(Apply(Newexp,sh),f) ->
          addVar sh f term1
                
      | Condexp(t0,t1,t2) ->
          Cond(t0, peap term1 t1, peap term1 t2)
      | _ -> ap term1 term2
    )

    (* array expressions *)

  | Apply(Newexp,sh) ->         
      bodyEval term1 sh (pe term2)


     (* shape expressions *)

  | Undim -> (
      match term2 with 
        Apply(Zerodim,x) -> x
      | Apply(Apply(Succdim,_),_) -> 
          raise (Shape_error ([term2],"cannot have undim applied"))
      | _ -> ap term1 term2
            )

  | Lendim -> (
      match term2 with  
        Apply(Zerodim,x) -> 
          raise (Shape_error ([term2],"cannot have lendim applied"))
      | Apply(Apply(Succdim,x),y) -> x
      | _ -> ap term1 term2
            )

  | Preddim -> (
      match term2 with  
        Apply(Zerodim,x) -> 
          raise (Shape_error ([term2],"cannot have preddim applied"))
      | Apply(Apply(Succdim,x),y) -> y
      | _ -> ap term1 term2
            )

  | Numdim -> (
      match term2 with  
        Apply(Zerodim,x) -> Op(prim_zero,[])
      | Apply(Apply(Succdim,x),y) -> 
          pe (Op(prim_int_plus,
                      [numdim y; 
                       Op(prim_one,[])
                      ]
                        ))
      | _ -> ap term1 term2
            )

  | Apply(Equal,x) -> (
      match (x, term2) with 

      | Bang _ , Bang _  
      |        Op _, Op _ -> Op(prim_true,[])   

         (* The only cases expected are equal Bang's or equal true's
            bodyEval (ap Newvar sh) sh  (for command shapes).
            It might be worth tighteing this up, just to be sure. *)

      | Apply(Zerodim,t0), Apply(Zerodim,t1) -> 
          pe (equal t0 t1)

      | Apply(Apply(Succdim,s0),t0), 
          Apply(Apply(Succdim,s1),t1) ->
            if pe (Op(prim_int_equal,[s0;s1])) = Op(prim_true,[])
            then pe (equal t0 t1)
             else Op(prim_false,[])    

      | _,_ -> ap term1 term2
            )

    (* polymorphic constants *)

  | Apply(Apply(Primrec,f),x) -> (
      match term2 with
        Op(Prim_value (Int n),_) when n>0 -> 
          let n' = Op(Prim_value (Int (n-1)),[]) in 
          pe (ap2 f n' (primrec f x n') )

      | Op(Prim_value (Int 0),_)  -> x

      |        Op(Prim_value (Int n),_) when n<0 -> 
          raise (Shape_error 
                   ([term2],
                    "is a negative iterator for primrec"))
      | _ -> ap term1 term2 
            )

  | Shape -> pesh term2                 



        
        (* index reductions *)

        (* these have been embedded within the cases above, to
           maintain a one-pass approach. The use of vtc is flagged by
           assign. The absence of var2exp means that coercion must be
           detected by the later use of the term, in an assignment,
           conditional (any position), for-loop (twice), while-loop or
           op. *)


  | _ -> ap term1 term2



     (* end peap *) 


(* 
        Shape Reduction 
        ===============

*)

and pesh term = (  (* term is a value *) 

  match term with 
  
  | Tvar x -> (try let (sh,_) = assoc x shEnv in sh 
               with Not_found -> shape term ) (* should not happen  *)

  | Apply(Dyn pty,t2) -> 
      let t3 = pesh t2 in             (* look for shape errors - 
                                         if not exceptions then ... *)  
      Bang pty

  | Apply(t1,t2) -> peap (pesh t1) (pesh t2) 
        
  | Lam(_,_) -> propagate_shape [] term

  | Op(_,[]) -> term                  (* assume static *)

  | Op(d,ts) ->                       (* must be dynamic *)
      let ts' = map pesh ts in        (* look for shape errors - 
                                         if not exceptions then ... *)  
      Bang (return_type_prim_constant d)  
        
  | Get x -> peap Undim (pesh x) 
             
  | Sub (t1,t2) -> 
      pe (check (wf (pesh t2))
                      (ap Preddim (pesh t1)))

  | Cond(t0,t1,t2) ->
      pe (
      check (wf (pesh t0)) (
      check (equal (pesh t1) (pesh t2))
        (pesh t1))
      )

  | Condexp(t0,t1,t2) ->
      pe (
      check (wf (pesh t0)) (
      check (equal (pesh t1) (pesh t2))
        (pesh t1))
      )

  | Skip 
  | Abort -> Op(prim_true,[])
        
  | Assign -> Equal

  | Seq -> 
      let x = nextvar() 
      and y = nextvar() in  
      lam x (lam y (Op(prim_int_equal,[Tvar x;Tvar y])))
        
  | Forall -> 
      let x = nextvar() 
      and y = nextvar() 
      and z = nextvar() in
      lam x (lam y (lam z
        (check (equal (Tvar x) (Tvar y))
               (ap (Tvar z) (Bang IntTy)) )))

  | Whiletrue -> 
      let x = nextvar() 
      and y = nextvar() in 
      lam x (lam y (
             check (wf (Tvar x)) (Tvar y) ))
        
  | Fix k ->                

      let rec f n = 
        (match n with 
          _ when n<0 -> raise (Fish_error "negative argument to fix")
        | 0 -> Op(prim_true,[])
        | _ -> lam (nextvar()) (f (n-1)))
      in 
      let x = nextvar() in 
      lam x (ap (Tvar x) (f k))
        
  | Newvar -> 
      let x = nextvar() 
      and y = nextvar() in 
      lam x (lam y (ap (Tvar y) (Tvar x) ))

  | Output ->
      let x = nextvar() in
      lam x (check (wf (Tvar x))
               (Op(prim_true,[])) )

  | Newexp -> 
      let x = nextvar() 
      and y = nextvar() in 
      lam x (lam y 
             (check (ap (Tvar y) (Tvar x)) (Tvar x) ))

  | Succdim -> 
      let x = nextvar() in 
      lam x (check (is_length (Tvar x))
               (ap Succdim (Tvar x)))

  | Primrec -> 
      let f = nextvar() 
      and x = nextvar() 
      and n = nextvar() in 
      lam f (lam x (lam n
                      (check (is_length (Tvar n))
                         (primrec (Tvar f) (Tvar x) (Tvar n) ))))

   | Shape -> identity

  | _ -> term )

                  
     (* end pesh *)

and propagate_shape vars = 

      (* This performs a strictly limited partial evaluation under the
         lambda (propagates shape analysis). Full partial evaluation
         under the lambda does not work because of missing type
         information (unresolved shape conditionals are treated as
         datum conditionals, and lead to spurious errors). Earlier
         versions used a null term as placemarker, but null is an
         "empty" concept for function types and is better out of the
         language.

         Bound variables (in vars) are left alone, 
         but their types have changed! 
         Other variables are free, and so mapped to their shapes. *)

let rec psh t = 

  (match t with
    
    Tvar x when mem x vars -> t 
  | Tvar x -> shape t 
  | Apply(Dyn pty,t2) -> shape (ap (Dyn pty) (psh t2)) 
                               (* nb psh t2 may be of static type! *)
  | Apply(t1,t2) -> Apply(psh t1, psh t2)
  | Lam(x,t0) -> lam x (propagate_shape (x::vars) t0)  
  | Where(t2,x,t1) -> Where(propagate_shape (x::vars) t2,x,psh t1)
  | Op(d,ts) -> shape (Op(d,List.map psh ts)) (* apply d to int_shape, etc? *)
  | Get t0 -> Apply(Undim, (psh t0))
  | Sub(t1,t2) -> check (wf (psh t2)) 
                        (preddim (psh t1))
  | Condsh(t0,t1,t2) -> Condsh(psh t0, psh t1,psh t2)
  | Cond(t0,t1,t2) -> 
      check (wf (psh t0)) (
      check (equal (psh t1) 
                   (psh t2)) 
        (psh t1))
  | Condexp(t0,t1,t2) -> 
      check (wf (psh t0)) (
      check (equal (psh t1) 
                   (psh t2)) 
        (psh t1))
  |  _ -> shape t
        )
        
in psh  

  (* auxilliary functions for handling blocks. 

     Shape information about local variables must be added to the
     shape environment before partial evaluation *)

and bodyEval outer sh f  =    (* outer must be a constructor *)
    let x = nextvar() in 
    let shEnv' = (x,(sh,Tvar x))::shEnv in       (* #x = sh *)
    let body = 
      part_ev modes shEnv'   
        (ap f (Tvar x)) in                       (* pe f x *)
    ap outer (lam x body)

and bodyEval2 outer sh f g = 
    let x = nextvar() in
    bodyEval outer sh 
      (lam x (seq (ap f (Tvar x)) 
                  (ap g (Tvar x))                (* pe (f x; g x) *)
      ))

and addVar sh f g = bodyEval2 (ap Newvar sh) sh f g

and addExp sh f g = 
  let x = nextvar() in
  let g2 = lam x (assign (Tvar x) (ap g (Tvar x))) in 
  bodyEval2 (ap Newexp sh) sh f g2

and addTwo sh sh' f g =                 (* now two variables *)
    let z = nextvar()     
    and x = nextvar() in 
    let shEnv' = 
      (x,(sh',Tvar x))::
      (z,(sh,Tvar z)):: shEnv in   
    let body =                      
      part_ev modes shEnv' 
        (seq (ap f (Tvar x)) 
           (assign (Tvar z) (ap g (Tvar x)))    (* pe (f x; z := g x) *)
    )
    in       
    newexp sh (lam z (                                (* #z = sh  *)
    newvar sh'(lam x body)))                    (* #x = sh' *)

in pe 
;;

(* end *)


@head(2,"turbot2C_fish.mli")
turbot2C_fish.mli.
@select(tangler("src/turbot2C_fish.mli"))
val translateToFile : string -> Terms_fish.fish_term -> unit

@head(2,"turbot2C_fish.ml")
turbot2C_fish.ml.
@select(tangler("src/turbot2C_fish.ml"))

(* turbot2c.ml
   
   This file produces some C wrapper functions for translating fish-terms
   (Turbot terms) to C programs. 
   
   The core function is t2c which does a depth first traversal of a
   turbot term and outputs a C string (fprintf)
   
   translate calls t2c and wraps its result inside a C program inside of
   a main.
   
   *)
  
open Printf
open Map
open List
  
open Primitive_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Substitution_fish
open Partial_ev_fish
open Parse_fish
open Util_fish

(* C runtime stack simulation for making heap allocation decisions *)
  
let pointerSize = 4
let theStack = Stack.create ()
let maxStack =  ref 16000     (* maximum size of stack allocated variables *)
let currStackSize = ref 0     (* current stack size *)
    
let clearStack () =
  Stack.clear theStack;
  currStackSize := 0  
       ;;
    
(* try to push a shape of size n on the stack 
   return value is true iff allocated on the heap instead
   *)
    
let pushStack sh n = 
  let tentativeStackSize = !currStackSize + n
  in
  
  (* always stack-allocate datum types *)
  
  if (isBang sh) or tentativeStackSize <= !maxStack
  then
    (Stack.push (n,false) theStack;
     currStackSize := tentativeStackSize; 
     false)
  else (* push pointer instead *)
    (Stack.push (pointerSize,true) theStack;
     currStackSize := !currStackSize + pointerSize;
     true)
      ;;
    
(* pop a size from the stack
   return value is true iff that size was heap-allocated
   *)
    
let popStack () =
  let (n,b) = Stack.pop theStack
  in 
  currStackSize := !currStackSize - n;
  b
    ;;
    
(* channel for printing of compiled code *)

let outchan = ref stdout
;;

(* I/O primitive for printing of compiled code *)

let pp fmt = Printf.fprintf !outchan fmt 
;;
let pp_ndx ndx = pp "[%d]" ndx



(* C printing *)

(* for primitives *)

let print_prim_type_c t =
  match t with
    IntTy -> "int"
  | BoolTy -> "BOOL"
  | FloatTy -> "double"
  | CharTy -> "char"
;;    

(* machine-dependent datum sizes -- these are for Sun Sparc *)

let prim_type_c_bytes t = 
  match t with 
    IntTy -> 4
  | BoolTy -> 4
  | FloatTy -> 8
  | CharTy -> 1
;;


let print_prim_value_c v = 

  match v with 
    | Int n -> pp "%d" n
    | Bool b -> pp "%s" (if b then "TRUE" else "FALSE") 
    | Float n -> pp "%f" n
    | Char c -> 
        pp "'" ; 
        (match c with 
          '\b' -> pp "\\b" 
        | '\n' -> pp "\\n"  
        | '\r' -> pp "\\r"  
        | '\t' -> pp "\\t"
        | '\\' -> pp "\\\\"
        | '\'' -> pp "\\\'"
        | _ -> pp "%c" c
        ) ; 
        pp "'" 
;;

let print_prim_op_c s =
  match s with 
    "-." -> "-"
  | "div" -> "/"
  | "mod" -> "%"
  | "=" -> "==" 
  | "int2float" -> "(double)" 
  | "+." -> "+"
  | "*." -> "*" 
  | "/." -> "/"
  | "=." -> "==" 
  | "<." -> "<"
  | "<=." -> "<="
  | ">." -> ">"
  | ">=." -> ">="
  | "not" -> "!"
  | "truncate" -> "" 
  | _ -> s

let is_infix d = 
  match d with 
    Pconst([pty0;pty1;pty2],_,s) -> 
      (match s with 
        "atan2" 
      |        "fmod" 
      |        "pow" -> false 
      |        _ -> true 
            )
  | _ -> false

let print_prim_constant_c d = 
  match d with 
    Prim_value v -> print_prim_value_c v
  | Pconst(ptys,_,s) -> pp "%s" (print_prim_op_c s)


let print_bang_c t =
  match t with
    IntTy -> pp "INT_SHAPE"
  | BoolTy -> pp "BOOL_SHAPE"
  | FloatTy -> pp "FLOAT_SHAPE"
  | CharTy -> pp "CHAR_SHAPE"
;;

(* end of C printing for primitives *)

(* formatting of C output *)
    
let indent_spacing = 2
let indent_level = ref 0
    
let resetIndent() =
  indent_level := 0
;;
    
let tab() = incr indent_level;;
let untab() = decr indent_level;;
    
let comma() = pp ",";;
let lParen() = pp "(";;
let rParen() = pp ")";;
    
let indent() = 
  for i = 1 to indent_spacing - 1 do
    pp " "
  done
;;

let nli() = (* newline with indent *)
  pp "\n";
  for i = 1 to indent_spacing * !indent_level do
    pp " "
  done
;;
    
let open_block_c() = 
  pp "{";
  tab();
;;
    
let close_block_c() = 
  untab();
  nli();
  pp "}"
;;


(* array information *)

let times x y = x*y ;;
let product = fold_left times 1 ;;

(* array_desc returns 

   variable name, 
   shape (via shape2Pair), 
   offset from source 
   
e.g. 
   if x is a 2x6x3 array of ints 
   then x[1,5] -> (x, #x,(1x6x3 + 5x3)*sizeof(int)) 

It only works for proper arrays and their entries, 
not for trivial arrays or datum variables 

*)

let rec array_desc sh_env = 

  let rec ad t  = 
    match t with
      
      Tvar x -> 
        let (sh,_) = assoc x sh_env in 
        let (lst,b) = shape2Pair sh in 
        if flatten lst = [] 
        then raise (Shape_error 
                      ([t], 
                       " is a trivial array"))
        else (x,(lst,b),Op(prim_int 0,[]))

    | Get t' -> 
        let (x,(lsts,b),n) = ad t' 
        in 
        (match List.hd lsts with
          [] -> (x,(List.tl lsts,b),n)
        | _ -> raise (Shape_error 
                        ([t], 
                         " cannot have get applied"))
              )
          
    | Sub(t',i) ->    
        let (x,(lsts,b),n) = ad t' 
        and (s,_) = array_size sh_env t'
        in (
        match lsts with 
          (h :: t1) :: t2 -> 
            let offset = 
             match (n,s/h) with 
               (Op(Prim_value (Int m),_),p) when m=0 && p=1 -> i
             | (Op(Prim_value (Int m),_),p) when m=0  -> 
                 Op(prim_int_times, [i;Op(prim_int p,[])])
             | (_,p) when p=1  -> Op(prim_int_plus, [n;i])
             | _ -> 
                 Op(prim_int_plus, 
                       [ n; 
                         Op(prim_int_times, 
                            [ i; 
                              Op(prim_int (s/h),[])
                                  ])])
            in (x,(t1 :: t2,b), offset)

        | _ -> raise (Shape_error ([t],"does not have subarrays"))
              )
          
    | _ -> raise (Fish_error "not an identifier or proper array") 
  in 
  ad  
          
and array_size  sh_env t = 
  let (_,(lst,b),n) = array_desc sh_env t 
  in 
  (fold_left (fun x -> fun ys -> x * (product ys)) 1 lst, b)
      
and is_proper_array sh_env t = 

(* 
   is true for proper arrays, 
   false for their entries and 
   otherwise raises an exception 
*)

    let (_,(lst,_),_) = array_desc sh_env t in 
    flatten lst <> []
;;





(* main translation routine, print Turbot terms as C.

List of auxiliary functions appearing within the nested recursion. 

print_id 
   print_rec_fun_call 
print_pconst 
print_subarray 
print_getarray 
print_exp_cond 
print_skip 
print_abort
print_seq
print_assign
print_comm_cond
print_for
print_while
print_fix
   push_regs
   pop_regs 
     mk_assn 
     mk_reg_var
     initialise_pda 
print_newvar
   print_block_decl
   print_block_undecl
print_output 

*)
        
let rec turbot2c  sh_env rec_funs fv_env t =
  
  let rec t2c t =
    
    match t with
      
      (* follows description of Turbot in the paper *)
      
      Tvar x ->                              print_id x   
    | Op(d,ts) ->                            print_pconst d ts
    | Sub(t1,t2) ->                          print_array t
    | Get t' ->                              print_array t' 
    | Cond(t1,t2,t3) ->                      print_comm_cond t1 t2 t3 
    | Condexp(t1,t2,t3) ->                   print_comm_cond t1 t2 t3 
    | Typed(t1,ty) ->                        t2c t1 
    | Skip ->                                print_skip () 
    | Abort ->                               print_abort () 
    | Apply(Apply(Assign,t1),t2) ->          print_assign t1 t2 
    | Apply(Apply(Seq,t1),t2) ->             print_seq t1 t2 
    | Apply(Apply(Apply(Forall,lo),hi),
            Lam(x,body)) ->                  print_for x lo hi body
    | Apply(Apply(Whiletrue,b),t') ->        print_while b t'
    | Apply(Fix 0,Lam(x,body)) ->            print_fix x body
          (* !! what about k >0 ?? *)
    | Apply(Apply(Newvar,sh),Lam(x,body)) -> print_newvar x sh body
    | Apply(Output,t') ->                    print_output t' 
    | Apply(Dyn _,t') ->                     t2c t'
    | Bang b ->                              print_bang_c b
          
    (* error *)
          
    | _ -> raise (Fish_error "in translating to C")

  (* multi-purpose auxiliaries *)

  and print_id x  =

(* 
   if a free variable in a rec fn 
   then print regs.name 
   else if a rec fn 
        then print name()
        else print name 
*)

    if (mem x rec_funs)              (* x is recursive fun *)
    then print_rec_fun_call x
    else (
      (try 
        let regs = assoc x fv_env in (* fv in recursive fun *)
        pp "%s." regs 
      with Not_found -> () ) ;
    pp "%s" (var2string x) )
        

  and print_rec_fun_call x = 
    nli();
    pp "%s();" (var2string x) 
 
  and print_pconst d ts = 
    
    match ts with 
      
      [] -> print_prim_constant_c d

    | [t] -> 
        print_prim_constant_c d;
        pp "(" ;
        print_data t;
        pp ")"

    | [t1;t2] -> 
        
        if is_infix d
 
        then (
            
        pp "(" ;   
        print_data t1;
        print_prim_constant_c d;
        print_data t2 ;
        pp ")" ; )

        else (

        print_prim_constant_c d; 
        pp "(" ;
        print_data t1 ;
        comma();
        print_data t2 ;
        pp ")" )
          
    | _ -> raise (Fish_error "when printing a constant in C")


  and print_array t =  

(* used in prim ops and assignment.
   if a proper array then use an offset from the pointer, A+n
   if an array entry then use array notation A[n] 
   otherwise use the name A
*)

    try 
      let (x,(lst,b),n) = array_desc sh_env t in 

      print_id x; 

      if (is_proper_array sh_env t) || mem_assoc x fv_env
      then ( 
        if n = Op(Prim_value (Int 0),[]) 
        then () 
        else (pp " + " ; t2c n )
            )
      else   (pp "["   ; t2c n ; pp "]" ) ;

    with _ -> t2c t (* a trivial array or a datum variable *)
  
  and print_data t = 
    try 
      let (x,(lst,b),n) = array_desc sh_env t in 
      ignore(assoc x fv_env) ; 
      pp "*(" ; print_array t ; pp ")" (* get the pointer value *)
    with _ -> print_array t

  and print_exp_cond ifpart thenpart elsepart  =
    lParen();
    t2c ifpart ;
    pp ") ? (";
    t2c thenpart ;
    pp ") : (";
    t2c elsepart ;
    rParen()

  (* command auxiliaries *)

  and print_skip () = ()
      
  and print_abort () = 
    nli();
    pp "exit(ABORT_CODE);"
      
  and print_seq t1 t2  =
    t2c t1 ;
    t2c t2 
      
  and print_assign t1 t2  = 

(* 
   If a proper array then use memcpy.
   Otherwise use assignment (=).

*)

    nli();

    try 
      if (is_proper_array sh_env t1)
      then (
        let (s,b) = array_size sh_env t1 
        in
        pp "memcpy(";
        print_array t1 ;
        pp ","; 
        print_array t2 ;
        pp ",%d); /* copy %d entries */" (prim_type_c_bytes b *s) s; 
        )
      else (raise (Failure ""))

    with _ -> 
      print_data t1 ;
      pp " = ";
      print_data t2 ;
      pp ";" ;
        

  and print_comm_cond testpart thenpart elsepart  = 
    nli();
    pp "if (";
    t2c testpart ;
    pp ") ";
    open_block_c();
    t2c thenpart ;
    close_block_c();
    nli(); 
    pp "else ";
    open_block_c();
    t2c elsepart ;
    close_block_c()

  and print_for x lo hi body  = 

    let decl_for_bound s t =
      ignore(pushStack int_shape (prim_type_c_bytes IntTy));
      nli();
      pp "int %s = " s; 
      t2c t;
      pp ";"
    and x_str = var2string x 
    in 

    nli();
    open_block_c();
    indent();
    pp "int %s;" x_str ;  
    
    ignore(pushStack int_shape (prim_type_c_bytes IntTy));

    let numBounds = ref 0 
    in
    nli();
   pp "for (%s = " x_str ; 
    t2c lo ;
    pp "; %s < " x_str ;
    t2c hi ;
    pp "; %s++) " x_str ;      
    
    open_block_c();
    
    turbot2c  ((x,(int_shape,Tvar x)) :: sh_env) rec_funs fv_env body ;
    
    ignore(popStack());  (* index variable *)
    for i = 1 to !numBounds do
      ignore(popStack()) (* bounds variables *)
    done;
    
    close_block_c();
    close_block_c()

  and print_while b t  = 
    nli();
    pp "while (";
    t2c b ;
    pp ") ";
    open_block_c();
    t2c t ;
    close_block_c()

  and print_fix x t =

    let fvs = list_diff (free_vars (lam x t)) rec_funs
    and regs = sprintf "%s_regs" (var2string x)
    in 
    push_regs regs fvs;
    print_rec_fun_call x;
    pop_regs regs fvs

  and push_regs regs  = 
      iter 
      (fun v -> 
        nli();
        print_reg_id regs v;
        pp " = " ;
        print_id v;
        pp ";"
        )

  and pop_regs regs = 
      iter 
      (fun v ->
        try 
          if is_proper_array sh_env (Tvar v) 
          then ()
           else raise (Failure "") 
         with _ -> 
           nli();
           print_id v;
           pp " = " ;
           print_reg_id regs v;
           pp ";" 
        )

  and print_reg_id regs v = pp "%s.%s" regs (var2string v)

  and print_newvar x sh body  = 

    let x_str = var2string x
    and (lst,b) = shape2Pair sh
    in
    let f_lst = flatten lst
    in 
    let shapeSize = 
      fold_left (fun x -> fun y -> x * y) (prim_type_c_bytes b) f_lst
    in 

    nli();
    open_block_c();
    print_block_decl (pushStack sh shapeSize) x_str f_lst b;
    turbot2c  ((x,(sh, Tvar x)) :: sh_env) rec_funs fv_env body;
    print_block_undecl (popStack()) x_str f_lst; 
    close_block_c();

and print_block_decl use_heap x_str f_lst b =

      indent();  

      match f_lst 

      with

        [] -> pp "%s %s;" (print_prim_type_c b) x_str

      | _ -> 

          let blocksize = product f_lst in 
 
          pp "%s " (print_prim_type_c b);

          if use_heap
          then ( 
               pp "*%s;" x_str ;
            if length f_lst =1 
            then ()
            else (
              pp " /* represents %s" x_str ;
              iter pp_ndx f_lst ;
              pp " */" ) ;
            nli();
            pp "%s = xmalloc(%d); /* make %d entries */" 
              x_str (prim_type_c_bytes b * blocksize) blocksize;
              )
          else  (
            pp "%s" x_str;
            pp_ndx blocksize; 
            pp ";" ;
            if length f_lst =1 
            then ()
            else (
              pp " /* represents %s" x_str ;
              iter pp_ndx f_lst ;
              pp " */" ) ;
              )

and print_block_undecl use_heap x_str f_lst =
  
      match f_lst with
    
        [] -> () 
        
      | _ when use_heap ->
          nli();
          pp "free(%s);" x_str;
        
      | _ -> ()

  and print_output t  = 

    let (lst,b) = shape2Pair (part_ev !modes sh_env (shape t))
    in

    nli();
    pp "fish_print(_argc,_argv,";

    print_bang_c b;  (* C wants the bang first *)
    pp ",";

    List.iter 
      (fun sublist -> 
        List.iter (fun n -> pp "%d," n) sublist;
        pp "%s" "ARRAY_BOUNDARY,")
      lst ;

    pp "END_OF_SHAPE,";
    
    if length (flatten lst) > 0 (* represented by C array *)
    then pp "(char *)";

    t2c t;
    pp ");"




  (* end mutual recursions with t2c *)

  in t2c t
;;


(* code for recursive functions at C top level.
List of auxiliary functions :

print_fun_prototype 
print_rec_fun 
decl_regs_var 

 *)

let rec define_c_rec_funs  sh_env rec_funs t =

  let rec d_rfuns t' =

    match t' with
  
     (* most interesting case *)

      Apply(Fix 0,Lam(x,body)) -> (* !! k>0 ?? *)
        print_fun_prototype x;
        define_c_rec_funs  sh_env (x::rec_funs) body;
        print_rec_fun x body;

     (* cases with extended shape environment *)

    | Apply(Apply(Newvar,sh),Lam(x,body)) -> 
        define_c_rec_funs  
          ((x,(sh, Tvar x)) :: sh_env) rec_funs body

    | Apply(Apply(Apply(Forall,_),_),Lam(x,body)) -> 
        define_c_rec_funs  
          ((x,(int_shape,Tvar x)) :: sh_env) rec_funs body

     (* all other Turbot combinator applications *)

    | Apply (t1,t2) ->
        d_rfuns t1;d_rfuns t2

    | Op(d,ts) -> iter d_rfuns ts

    | Cond(t0,t1,t2) -> 
        d_rfuns t0; 
        d_rfuns t1; 
        d_rfuns t2 

    | Condexp(t0,t1,t2) -> 
        d_rfuns t0; 
        d_rfuns t1; 
        d_rfuns t2 


    (* nothing to do for constants, nullary combinators 
       invalid Turbot will be caught by turbot2c, so ignore it here 
    *)

    | _ -> () (* This catches all of the term constructors!! *)

  and print_fun_prototype x = (* needed by inner functions *)
    nli();pp "void %s(void);\n" (var2string x)
  
  and print_rec_fun x t =

    let fvs = list_diff (free_vars (lam x t)) rec_funs
    and x_str = var2string x
    and regs = sprintf "%s_regs" (var2string x)
    in

    (* C struct for free variables *)

    if length fvs > 0 then (
      nli();
      pp "struct ";
      open_block_c();
      iter decl_regs_var fvs;
      close_block_c();
      pp " %s;\n" regs
        );

    (* C function *)

    nli();
    pp "void %s(void) " x_str;
    open_block_c();
    turbot2c  sh_env (x::rec_funs) (map (fun y -> (y,regs)) fvs) t;
    close_block_c();
    nli();

  and decl_regs_var v =

    let v_str = var2string v
    and (sh,_) = assoc v sh_env
    in let (lst,b) = shape2Pair sh
    in let f_lst = flatten lst 
    in
    nli();
    pp "%s " (print_prim_type_c b) ;
    match f_lst with 
      [] -> pp "%s;" v_str 
    |        _ ->  pp "*(%s);" v_str

  in

  d_rfuns t
;;


(* translate_fish.ml *)


(* output parameters *)

let setOutchanToConsole () =
   outchan := stdout
;;

let openTranslateFile s = 
   outchan := open_out s
;;

let closeTranslateFile() =
  close_out !outchan
;;

(* translate wraps a Turbot term inside a C program *)

let translate t = 

  let sys_includes = ["math.h";"stdio.h";"stdlib.h";"string.h";"sys/stat.h"]
  in

  resetIndent();
  clearStack();

  pp "/* translated by fish */\n\n";

  List.iter (fun s -> pp "#include <%s>\n" s) sys_includes;

  nli();
    
  pp "#include \"fish.h\"\n\n";

  (* global versions of argc, argv *)

  pp "int _argc;";
  nli();
  pp "char **_argv;\n";
  nli();

  (* recursive functions at C top level *)

  define_c_rec_funs  [] [] t;  
  nli();

  pp "int main(int argc,char *argv[]) {";

  tab();
  nli();

  pp "_argc = argc;";
  nli();
  pp "_argv = argv;";
  nli();

  turbot2c [] [] [] t;

  nli(); 
  untab();

  pp "return 0;\n}\n";

;;

(* interface functions for generating C code *)

let translateToFile s t =
  let currDir = Sys.getcwd()
  in let fileName = currDir ^ "/" ^ s
  in
  openTranslateFile fileName;
  translate t;
  closeTranslateFile()
;;

 
let translateToConsole t =
  setOutchanToConsole();
  translate t;
;;

 
@head(2,"hook_fish.mli")
hook_fish.mli.
@select(tangler("src/hook_fish.mli"))
open Types_fish
open Terms_fish

val version_number : string
val global_env :
 (Environments_fish.TyEnv.key *
 (fishTyScheme * fish_term * fish_term))
 list ref
val get_type_scheme :
  Types_fish.fishTyScheme Environments_fish.TyEnv.t ->
  Terms_fish.term_variable ->
  Types_fish.phraseType -> Type_subs_fish.tySub -> Types_fish.fishTyScheme
val global_env :
  (Environments_fish.TyEnv.key *
   (Types_fish.fishTyScheme * Terms_fish.fish_term * Terms_fish.fish_term))
  list ref
val global_ev : Terms_fish.fish_term -> Terms_fish.fish_term
val declare : Terms_fish.term_variable -> Terms_fish.fish_term -> unit
val fish2turbot :
  Environments_fish.TyEnv.key ->
  Util_fish.run_flag list -> Terms_fish.fish_term
val format_fish_as_turbot :
  Environments_fish.TyEnv.key -> Util_fish.run_flag list -> unit
val fileInCurrentDirectory : string -> string
val compile_to_C_and_run :
  string list ->
  Environments_fish.TyEnv.key -> Util_fish.run_flag list -> string -> unit
val posStack : int Stack.t
val pushLineStack : unit -> unit
val popLineStack : unit -> unit
val fish_process_action :
  string list ->
  (string -> Util_fish.fish_shell_action list) ->
  Util_fish.fish_shell_action -> unit
val pf : string -> unit
val handleTopLoopException : exn -> unit
val readEvalPrint : unit -> unit
val fish : unit -> unit

@head(2,"hook_fish.ml")
hook_fish.ml.
@select(tangler("src/hook_fish.ml"))
(* type of user commands in shell *)

open Printf
open Lexing
open Parsing
open List



open Primitive_fish
open Types_fish
open Terms_fish
open Sugar_fish
open Environments_fish
open Pretty_fish
open Type_subs_fish
open Substitution_fish
open Parse_fish
open Lex_fish
open Unify_fish
open Infer_fish
open Partial_ev_fish
open Turbot2C_fish
open Util_fish

exception InvalidRunType of phraseType


(* version_fish.ml *)

let version_number =
  "1.7" (* ^ "04 Oct 2004 " *) 
;;
 


(* functions for executing shell commands *)

(* let  *)

let get_type_scheme tyEnv identifier theType tysub = 
  match identifier with 
  | TypedVar (rx,x_ty0) -> 
      let bestType = 
        applyTySub 
          (unifyLoop ([ theType , x_ty0 ], tysub)) 
          x_ty0 
      in closTy bestType tyEnv
  | TypedMvar (rx,x_ty0) -> 
      let bestType = 
        applyTySub 
          (unifyLoop ([ theType , x_ty0 ],tysub))
          x_ty0 
      in closTy bestType tyEnv
  | _ -> closTy theType tyEnv
;;      

let global_env = ref [] 
;; 

let global_ev t = part_ev  !Util_fish.modes (global2shape !global_env)  t
;;
      
let declare identifier sourceTerm =
(* freshen free type variables in identifier? *)

  if (get_mode "parse" = Util_fish.Show_on) 
  then format_parsed_term sourceTerm ;
  
  let tyEnv = global2type !global_env in 
  let (inferredTerm,inferredType, tysub) = 
    infer tyEnv sourceTerm 
  in 
  if (get_mode "infer" = Util_fish.Show_on) 
  then format_inferred_term inferredTerm ;
  
  let theTypeScheme = 
    get_type_scheme tyEnv identifier inferredType tysub 
  in 

  if get_mode "batch" = Util_fish.Show_on
  then format_declaration identifier theTypeScheme ;
  
  let theTerm = global_ev inferredTerm in  
  let theShape = global_ev (shape theTerm) 
  in 
  if get_mode "batch" = Util_fish.Show_on
  then format_shape_declaration identifier theShape theTypeScheme;      
  global_env := 
     (raw identifier,(theTypeScheme,theShape,theTerm)) 
     :: !global_env


let fish2turbot v flags =
  let qflag = List.mem Quiet_flag flags
  and (tyScheme,_,_) = assoc v !global_env in 
  let ty = inst_tyscheme tyScheme in
  let theTerm = 
    match (ty,qflag) with
      (CommTy,_) -> Tvar v
    | (ExpTy (AT _),true) -> ap  exp2comm (Tvar v)
    | (ExpTy (AT _),false) -> ap Output (Tvar v)
    | _ -> raise (InvalidRunType ty)
  in
  tidy_term (global_ev theTerm)
;;

let format_fish_as_turbot t flags = 
  format_term (fish2turbot t flags);
  Format.print_newline()
;;

(* %run *)

let fileInCurrentDirectory filename = 
  "./" ^ filename  (* Unix *)
;;

let compile_to_C_and_run include_dirs v flags filename = (* v is a variable *)
  let cFile = fileInCurrentDirectory (filename ^ ".c")
  and turbotTerm = fish2turbot v flags
  in
  translateToFile cFile turbotTerm;

  if get_mode "felix" = Util_fish.Show_on
  then
    let s = 
      String.concat " " 
      (map (fun x -> "-I"^x^ " -L"^x) include_dirs)
    in
    ignore(Sys.command("fishcc " ^ s ^ " " ^ cFile));
  else
    ignore(Sys.command("fcc " ^ cFile));

  if (List.mem Compile_flag flags = false) 
  then ignore(Sys.command(fileInCurrentDirectory filename)) 
;;

(* %use *)

let posStack = Stack.create()
;;

let pushLineStack() =
  Stack.push (!line_number) posStack;
  line_number := 1
;;

let popLineStack() =
  line_number := Stack.pop posStack
;;

(* shell commands *)

let resolve_fish_includes include_dirs s =
  Flx_filesys.find_file true include_dirs s

let fish_process_action include_dirs file_parser sa  =  (* sa = shell action *)

  let rec do_action action = (* file_parser is fixed *)

    match action with

      Let_decl(identifier,sourceTerm) -> 
        declare identifier sourceTerm 

    | Turbot_directive (x,flags) -> 
        format_fish_as_turbot x flags;()

    | Run_directive (x,flags,basename) -> 
        compile_to_C_and_run include_dirs x flags basename;()

    | Show_directive (mode,s) ->
        set_mode s mode

    | Use_directive s  ->  
        if get_mode "batch" = Util_fish.Show_on
        then (printf "Opening file \"%s\" ...\n" s;flush stdout);
        pushLineStack();
        let s = resolve_fish_includes include_dirs s in
        List.iter do_action (file_parser s);
        popLineStack()

    | Quit_directive -> 
        if get_mode "batch" = Util_fish.Show_on
        then printf "... glub glub glub ...\n";
        exit 0

  in do_action sa
;;

(* start_fish.ml *)




(* old start_fish.ml begins here *)

(* print a string to console, flush standard output *)

let pf s = 
  printf "%s\n" s;flush stdout
;;

(* handle exception in readEvalPrint loop *)

let handleTopLoopException exn =
  match exn with

  (* system-defined *) 

  | Invalid_argument s -> pf (sprintf "Invalid_argument %s" s)
  | Sys_error s -> pf s
  | Sys.Break -> pf "Break ...";raise (Sys.Break) 
  | Not_found -> pf "Not_found"

  (* failures in named O'Caml functions *)

  | Failure s -> pf (sprintf "Failure in %s" s)

  (* exported from source files, in alpha order *)

  | Primitive_fish.Fish_error s -> pf (sprintf "FISh_error: %s" s)

  (* from partial_ev_fish.ml *)

  | Shape_error (ts,s) ->
      pf (sprintf "%s" "shape error -- ") ;
      (match ts with 
        [t] -> format_term t ;
      | [t1;t2] -> 
          format_term t1 ;
          pf (sprintf "\nand") ;
          format_term t2 ;
      | _ -> ()
      ) ;
      pf (sprintf "\n%s" s)

  (* from infer_fish.ml *) 

  | UnboundVariable v -> pf (sprintf "Unbound variable %s" (var2string v))

  (* from interface_fish.ml *)

  | FishSyntaxError (line,col,message) -> 
      pf (sprintf "Syntax error at line %d, column %d : %s" line col message)
            
  (* from lex_fish.ml *)

  | UnterminatedComment -> pf "Unterminated comment"

  (* from shell_fish.ml *)

  | No_such_mode -> pf "No such mode" 

  | InvalidRunType ty -> formatInvalidRunType ty

  (* from terms_fish *)
  | NoType -> pf "Raw term variable found"

  (* from unify_fish.ml *)      

  | UnifyPhraseError (ty1,ty2) -> 
      formatPhraseTypeError "Error unifying" ty1 ty2
  | UnifyArrayError (ty1,ty2) -> 
      formatArrayTypeError "Error unifying" ty1 ty2 
  | OccursPhraseError (ty1,ty2) -> 
      formatPhraseTypeError "Occurs-check error when unifying" ty1 ty2
  | OccursArrayError (ty1,ty2) -> 
      formatArrayTypeError "Occurs-check error when unifying" ty1 ty2
  | Incompatible_datum_types (pty0,pty1) -> 
      formatPrimTypeError "Error unifying" pty0 pty1 

  (* anything else *)

  | _ -> pf "Uncaught exception, continuing ..."
;;


let readEvalPrint () =
  let lexbuf = ref (Lexing.from_channel stdin) 
  in
  while (true) do
    printf ">-|> ";
    flush stdout;
    try 
      let action = parseShell !lexbuf
      in fish_process_action ["."] parseShellListFromFile action 
    with exn -> 
      handleTopLoopException exn;
      lexbuf := Lexing.from_channel stdin (* new buffer *)
  done
;;

let fish () =
  let startUps = ["standard_prelude.fsh"]
  and fishLibDir = 
    try Sys.getenv "FISH_LIB_DIR" with
      Not_found -> "."
  in 
  pf "Loading startup files ... ";
  global_env := [];
  let actionLists =
    List.map 
      (fun s -> 
        try parseShellListFromFile s
        with _ ->
          try parseShellListFromFile (fishLibDir ^ "/" ^ s)
          with _ ->
            pf ("Error loading " ^ s ^ ", continuing ...");[])
      startUps
  in
  List.iter
    (fun actions ->
      try List.iter 
            (fish_process_action [fishLibDir] parseShellListFromFile)
            actions
      with exn -> handleTopLoopException exn)
    actionLists;
  pf "" ;
  pf "" ;
  pf ("Welcome to FISh v. " ^ version_number);
  pf "(C) Copyright 1998, C. Barry Jay";
  pf "Included in Felix with permission.";
  pf "No warranty expressed or implied" ;
  readEvalPrint()
;;

@head(2,"fish.ml")
fish.ml.
@select(tangler("src/fish.ml"))
Hook_fish.fish();;

@head(2,"flxf.ml")
fish.ml.
@select(tangler("src/flxf.ml"))
open Flx_types
open Flx_flxopt
open Flx_getopt
open Flx_mtypes2
open Flx_version

let print_help () = print_options(); exit(0)
;;

begin
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version"
  then (print_endline ("Felix FISh Version " ^ !version_data.version_string))
  ;
  Util_fish.set_mode "felix" Util_fish.Show_on;
  Util_fish.set_mode "batch" Util_fish.Show_off;
  if compiler_options.print_flag then begin
    Util_fish.set_mode "batch" Util_fish.Show_on;
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename =
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0 
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".fsh"
  (*
  and header_file_name = filebase ^ ".hpp"
  and body_file_name = filebase ^ ".cpp"
  and report_file_name = filebase ^ ".xref"
  *)
  and module_name =
    let n = String.length filebase in
    let i = ref (n-1) in
    while !i <> -1 && filebase.[!i] <> '/' do decr i done;
    String.sub filebase (!i+1) (n - !i - 1)
  in
  let include_dirs =  (Filename.dirname input_file_name) :: compiler_options.include_dirs in
  let compiler_options = { compiler_options with include_dirs = include_dirs } in

  Hook_fish.global_env := [];
  let parse_tree = 
    try Lex_fish.parseShellListFromFile input_file_name 
    with _ -> exit 1
  in
  begin
    try
      List.iter
      (Hook_fish.fish_process_action include_dirs Lex_fish.parseShellListFromFile)
      parse_tree
    with exn -> 
      Hook_fish.handleTopLoopException exn; exit 1
  end
  ;
  exit 0
end
;;

@head(2,"fish.h")
fish.h.
@select(tangler("rtl/fish.h"))
/* fish.h */

#include <sys/types.h>

#define FALSE 0
#define TRUE  1

#define MAXDIMS 32

#define ARRAY_BOUNDARY (-1)
#define END_OF_SHAPE   (-2)

#define ABORT_CODE (-1)

typedef char BOOL;

typedef enum { _hold } SPECIALS;

typedef enum { INT_SHAPE,FLOAT_SHAPE,BOOL_SHAPE,CHAR_SHAPE } DATUM_SHAPE;

typedef int DIM;


/* runtime library functions in libfish.a */

extern void fish_print(int,char **,DATUM_SHAPE,...);
extern char *out_name(char *);
extern void fish_print_to_console(int,char **,off_t);
extern off_t out_filesize(int,char **);
extern char *out_filename(int,char **);
extern void print_value(void);
extern void *xmalloc(size_t);

@head(2,"printval_fish.cpp")
printval_fish.c.
@select(tangler("rtl/printval_fish.cpp"))
/* printval.c */

#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>

#include "fish.h"

static void print_int(int *);
static void print_float(double *);
static void print_bool(BOOL *);
static void print_char(char *);
static void print_char_naked(char *);
static void print_string();

static char *bang_string(DATUM_SHAPE);

/* global parameters */

static void (*pDatumFun)(void *); /* pointer to a function for printing one datum */ 
static void *v_val;               /* pointer to one datum value                   */ 
static int bang_size;             /* bytes in one datum                           */
static DIM dims[MAXDIMS];         /* complete shape description                   */
static int num_dims;              /* length of shape description                  */
static int num_entries;           /* total number of data entries                 */
static int inner_loop;            /* entries in outermost dimension               */
static int outer_loop;            /* entries in other dimensions                  */
static FILE *fp;                  /* I/O stream                                   */

void fish_print_to_console(int argc,char *argv[],off_t fsize) {
  char *outputFile;

  if ((fp = fopen(out_filename(argc,argv),"rb")) == NULL) {
    fprintf(stderr,"Can't read output file %s\n",outputFile);
    exit(1);
  }

  fseek(fp,(long)fsize,SEEK_SET);

  print_value();

  fclose(fp);
}

static char *bang_string(DATUM_SHAPE b) {

  switch(b) {
    
  case INT_SHAPE : 
    
    return "int_shape";
    
  case FLOAT_SHAPE : 
    
    return "float_shape";
        
  case BOOL_SHAPE : 

    return "bool_shape";

  case CHAR_SHAPE :

    return "char_shape";
  }}


static void print_data(void) {
  int i,j;

  for (i = 0; i < outer_loop; i++) {

    printf ("  ");

    for (j = 0; j < inner_loop; j++) {
      fread(v_val,bang_size,1,fp);
      (*pDatumFun)(v_val);

      if (i < outer_loop - 1 || j < inner_loop - 1) {
        printf(",");
      }
    }

    printf ("\n");
  }
}

void print_value(void) {
  DATUM_SHAPE b;
  DIM dim;
  BOOL is_array;
  int i,j;
  double f_val;
  int   i_val;
  BOOL  b_val;
  char  c_val;
  int num_zeroes;

  /* get datum type */

  fread(&b,sizeof(DATUM_SHAPE),1,fp);

  switch (b) {

  case INT_SHAPE : 

    bang_size = sizeof(int);
    v_val = &i_val;
    pDatumFun = (void (*)(void *))print_int;

    break;

  case FLOAT_SHAPE : 

    bang_size = sizeof(double);
    v_val = &f_val;
    pDatumFun = (void (*)(void *))print_float;

    break;

  case BOOL_SHAPE : 

    bang_size = sizeof(BOOL);
    v_val = &b_val;
    pDatumFun = (void (*)(void *))print_bool;

    break;

  case CHAR_SHAPE : 

    bang_size = sizeof(char);
    v_val = &c_val;
    pDatumFun = (void (*)(void *))print_char;

    break;

  default :

    fprintf(stderr,"Unknown datum type in output file\n");
    exit(1);

  }

  /* get array dimensions */

  num_dims = 0;
  is_array = FALSE;

  while (1) {

    fread(&dim,sizeof(dim),1,fp);

    if (dim == END_OF_SHAPE) {
      break;
    }

    if (dim == ARRAY_BOUNDARY) {
      is_array = TRUE;
    }

    dims[num_dims++] = dim;

    if (num_dims > MAXDIMS) {
      fprintf(stderr,"Shape description too long");
      exit(1);
    }
  }

  /* datum */

  if (is_array == FALSE) {
    fread(v_val,bang_size,1,fp);
    (*pDatumFun)(v_val);
    puts("");

    return;
  }

  /* proper array */

  /* calculate loop sizes */

  inner_loop = 1; 
  outer_loop = 1;

  for (i = num_dims - 1; i >= 0; i--) { 
    if (dims[i] != ARRAY_BOUNDARY) {
      inner_loop = dims[i];
      for (j = i-1; j >= 0; j--) {
        if (dims[j] != ARRAY_BOUNDARY) {
          outer_loop *= dims[j];
        }
      }
      break;
    }
  }

    /* strings */

  if (b == CHAR_SHAPE && num_dims == 2) {
    print_string() ;
  }

  else {


printf("fill { ");

  for (i = 0; i < num_dims; i++) {

    if (dims[i] >= 0) {
      printf("%u",dims[i]);
      if (dims[i + 1] != ARRAY_BOUNDARY) {
        printf(",");
      }
    }

    if (dims[i] == ARRAY_BOUNDARY) {
      if (i > 0 && dims[i-1] != ARRAY_BOUNDARY) {
        printf(" ");
      }
      printf(":");
      if (i < num_dims - 1 && dims[i+1] != ARRAY_BOUNDARY) {
        printf(" ");
      }
    }
  }

  printf(" %s }\n",bang_string(b));

  /* now print value */

  printf("with [\n");

  print_data();

  printf("]\n");

  }
}

static void print_int(int *n) {
  printf("%d",*n);
}

static void print_float(double *n) {
  printf("%f",*n);
}

static void print_bool(BOOL *b) {
  printf(*b ? "true" : "false");
}

static void print_char(char *c) {
  printf("'%c'",*c);
}

static void print_char_naked(char *c) {
  printf("%c",*c);
}

static void print_string(void) {
  int i,j;
  pDatumFun = (void (*)(void *))print_char_naked;

  for (i = 0; i < outer_loop; i++) {
    printf("\"") ;
    for (j = 0; j < inner_loop; j++) {
      fread(v_val,bang_size,1,fp);
      (*pDatumFun)(v_val);
    }
    printf ("\"\n");
  }
}


off_t out_filesize(int argc,char *argv[]) {
  struct stat buf;
  
  if (stat(out_filename(argc,argv),&buf) == -1) {
    return (off_t)0;
  }

  return (buf.st_size);

}

@head(2,"out_fish.cpp")
MAINLINE: out_fish.cpp.
@select(tangler("src/out_fish.cpp"))

/* out_fish.c -- print Fish dump file */

#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>

main (int argc,char *argv[]) {
  FILE *fp;
  struct stat buf;
  off_t filesize;
  long currpos;

  if (argc != 2) {
    fprintf(stderr,"Syntax: %s file\n",argv[0]);
    exit(1);
  }

  if ((fp = fopen(argv[1],"rb")) == NULL) {
    fprintf(stderr,"Can't open dump file\n");
    exit(1);
  }

  stat(argv[1],&buf);
  filesize = buf.st_size;

  while ((currpos = ftell(fp)) < filesize && currpos >= 0) { 
    print_value(fp);
  }

  fclose(fp);
}

@head(2,"saveval_fish.cpp")
saveval_fish.c.
@select(tangler("rtl/saveval_fish.cpp"))

/* dumpval.c */

#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <sys/stat.h>

#include "fish.h"

/* static functions */

static char *make_out_name(char *s) {  /* replace any file extension by .out */
  static char buff[256];
  char *p,*q;

  strncpy(buff,s,sizeof(buff) - 1);
  
  q = p = buff + strlen(buff);

  p--;

  while (*p != '.' && p > buff) {
    p--;
  }

  if (*p != '.') {
    p = q;
  }

  strcpy(p,".out");

  return buff;
}

static FILE *out_stream(int argc,char *argv[]) {  /* return pointer to open FILE */

  FILE *fp;

  if ((fp = fopen(out_filename(argc,argv),"ab")) == NULL) {
    fprintf(stderr,"Can't open output file\n");
    exit(1);
  }

  fseek(fp,0L,SEEK_END);

  return fp;
}

/* exported functions */

/* given argc, argv, get the output filename */ 

char *out_filename(int argc,char *argv[]) {
  if (argc == 1) {
    /* no command line args, use program + extension */
    return make_out_name(argv[0]);
  }
  else if (argc == 3 && strcmp(argv[1],"-o") == 0) {
    /* -o flag */
    return argv[2];
  }
  else {
    fprintf(stderr,"Syntax: %s [-o file]\n",argv[0]);
    exit(1);
  }
}


void fish_print(int argc,char *argv[],DATUM_SHAPE b,...) {
  off_t fsize;
  FILE *fp;
  DIM n;
  BOOL is_bool;
  BOOL seen_size;
  int datum_size;
  unsigned long num_elements;
  va_list p;
  int i_val;
  double f_val;
  BOOL b_val;
  char c_val;
  void *v_val;

  /* get current file size, before writing */

  fsize = out_filesize(argc,argv);
  fp = out_stream(argc,argv);

  /* write the datum type */

  if (fwrite(&b,sizeof(DATUM_SHAPE),1,fp) == 0) {
    fprintf(stderr,"fish_print: Error writing datum type\n"); exit(1);
  }

  is_bool = FALSE;

  switch(b) { 
    case INT_SHAPE : datum_size = sizeof(int); break;
    case FLOAT_SHAPE : datum_size = sizeof(double); break;
    case BOOL_SHAPE : datum_size = sizeof(BOOL); break;
    case CHAR_SHAPE : datum_size = sizeof(char); break;
    default : fprintf(stderr,"fish_print: \n") ; exit(1);
  }

  va_start(p,NULL);

  num_elements = 1;
  seen_size = FALSE;

  /* write each dimension */

  while((n = va_arg(p,int)) != END_OF_SHAPE) {

    if (n != ARRAY_BOUNDARY) {
      num_elements *= n;
      seen_size = TRUE;
    }

    if (fwrite(&n,sizeof(n),1,fp) == 0) {
      fprintf(stderr,"fish_print: Error writing array dimension\n"); 
      exit(1);
    }
  }

  /* write end-of-shape marker */

  fwrite(&n,sizeof(n),1,fp);

  /* write the value or array */

  if (seen_size == TRUE) {
    fwrite(va_arg(p,char *),datum_size,num_elements,fp) ;

    /* removed the error message because of 0-dimensional arrays 

       == 0) {
      fprintf(stderr,"fish_print: Error writing array\n");
      exit(1);
    }
    */

  }
  else {
    switch (b) {

    case INT_SHAPE : i_val = va_arg(p,int); v_val = &i_val; break;

      /* a FiSh float is a C double */

    case FLOAT_SHAPE : f_val = va_arg(p,double); v_val = &f_val; break;

      /* a BOOL is typedef'd to char, but coerced to int by C */

    case BOOL_SHAPE : b_val = (BOOL)(va_arg(p,int)); v_val = &b_val; break; 

      /* a char is coerced to int by C */

    case CHAR_SHAPE : c_val = (char)(va_arg(p,int)) ; v_val = &c_val; break; 

    }
    if (fwrite(v_val,datum_size,1,fp) == 0) {
      fprintf(stderr,"fish_print: Error writing datum\n");
      exit(1);
    }
  }

  va_end(p);

  fclose(fp);

  /* now print by starting at old end of file position */

  fish_print_to_console(argc,argv,fsize);
}

@head(2,"xmalloc_fish.cpp")
xmalloc_fish.c.
@select(tangler("rtl/xmalloc_fish.cpp"))
/* xmalloc.c */

#include <stdio.h>
#include <stdlib.h>
#include <sys/stat.h>

#include "fish.h"

void *xmalloc(size_t n) {
  void *p;

  p = malloc(n);

  if (p == NULL) {
    fprintf (stderr,"Heap allocation error\n");
    exit(1);
  }

  return p;
}

@head(2,"fish_top.ml")
fish_top.ml.
@select(tangler("src/fish_top.ml"))
(* fish_top.ml -- load fish into O'Caml interpreter *)

(* generated from fish.m4 *)



#use "primitive_fish.ml";;
#load "primitive_fish.cmo";;

#use "types_fish.ml";;
#load "types_fish.cmo";;

#use "terms_fish.ml";;
#load "terms_fish.cmo";;

#use "sugar_fish.ml";;
#load "sugar_fish.cmo";;

#use "environments_fish.ml";;
#load "environments_fish.cmo";;

#use "type_subs_fish.ml";;
#load "type_subs_fish.cmo";;

#use "substitution_fish.ml";;
#load "substitution_fish.cmo";;

#use "pretty_fish.ml";;
#load "pretty_fish.cmo";;

#use "parse_fish.ml";;
#load "parse_fish.cmo";;

#use "lex_fish.ml";;
#load "lex_fish.cmo";;

#use "unify_fish.ml";;
#load "unify_fish.cmo";;

#use "infer_fish.ml";;
#load "infer_fish.cmo";;

#use "partial_ev_fish.ml";;
#load "partial_ev_fish.cmo";;

#use "turbot2C_fish.ml";;
#load "turbot2C_fish.cmo";;

#use "fish.ml";;
#load "fish.cmo";;


@head(2,'Standard prelude')
@select(tangler("lib/standard_prelude.fsh",'data'))
(* 
%use "standard_prelude.fsh" ;;
*)

(* some basic functions *)

(* composition and identity *)

let comp g f x = g (f x) ;;
let identity x = x ;;


(* curried projections *)

let fst x y = x ;;
let snd x y = y ;;


(* incrementing and decrementing *)

let incr x = x := x+1 ;;
let decr x = x := x-1 ;;


(* Shape operations *)

(* 
check x y 
checks that the fact x is true 
and then evaluates y 
*)

(* well_shaped x checks that x is not error 

let well_shaped (x: exp a) = check (#x #= #x) true
;;

*)

(* 
folddim : (#a -> x) 
          -> (size -> x -> x) 
          -> #[a] -> x

The shape of an array is essentially 
a list of sizes, paired with a shape 
for the entries. Corresponding to
this is a foldright operation, called 
folddim. Perhaps it should be 
the primitive, instead of numdim.
*)

let folddim f0 f1 xsh = 
  let h x = f0 (undim x)
  and g n f x = 
        f1 (lendim x) (f (preddim x))
  in primrec g h (numdim xsh) xsh
;;

(* 
zeroShape : #[a] -> #a
extracts the shape of the entry 
of a zero dimensional array 
*)

let zeroShape = 
  folddim identity snd
;;

(*
extendShape : #[a] -> #b -> #[b]
uses the "outer" shape of its first argument
to augment the shape of its second argument.
For example, 
extendShape {2,3:int_shape} {4:bool_shape} =
{ 2,3 : 4 : bool_shape }
*)

let extendShape =
  folddim f0 f1
  where 
      f0 x y = zerodim y
  and f1 n h y = succdim n (h y) 
;;

(*
extendShape2 : #[a] -> #[b] -> #[b]
is like extendShape, 
but does not introduce a zerodim. For example,
extendShape2 {2,3:int_shape} {4:bool_shape} =
{ 2,3,4 : bool_shape }
*)

let extendShape2 = 
  folddim f0 f1
  where
      f0 x y = y
  and f1 n h y = succdim n (h y) 
;;


(* number_of_entries: #[a] -> size *)

let number_of_entries = 
  folddim (fun (x: exp #a) -> 1) (fun (x:size) -> fun (y:size) -> x* y) 
;;

(* shape_zipop : (#a -> #[b] -> #[c]) -> 
                 (size -> size -> size) -> 
                 #[a] -> #[b] -> #[c]

allows one to manipulate shapes as if they were lists  
*)


let shape_zipop f g = 
  folddim f f1 
where
  f1 n h b = succdim (g n (lendim b)) (h (preddim b)) 
;;

(*
snocdim : size -> #[a] -> #[a]
adds the new size as an innermost dimension.
For example,
snocdim 4 {2,3:int_shape} = { 2,3,4 : int_shape }
*)

let snocdim n sh = 
  extendShape2 sh (succdim n (zerodim (zeroShape sh)))
;;


(* 
shape2array : #[a] -> [int]
converts a shape to an array of integers 
representing sizes. For example,
shape2array {2,3:bool_shape} = 
  fill { 2 : int_shape } with [2,3]
*)

let shape2array sh = 
  new #x = succdim (numdim sh) (zerodim int_shape)
  and  i = 0 in 
    folddim f0 f1 sh
    where
      f0 sh0 = skip 
    and 
      f1 (m:size) C = 
          (x[i] := m ;
          incr i ;
          C) 
  return x 
;;


(* Procedures *)



(* doall, doall2 and doall3 

doall allow procedures to be applied to 
all the entries in an array, 
(without using the index as a parameter)
like a multi-dimensional forall. 
doallk does the same for a procedure
taking k arguments. 
*)


let doall pr (x: var [a]) = 
  primrec g (do_nonce pr) (numdim #x) x
  where 
      g n = do_once
  and do_once pr1 (x1: var [a]) =         // 1dim 
    for i< lendim #x1 do
      pr1 sub(x1,i) 
    done 
  and do_nonce pr0 (x0: var [a]) = pr0 (get x0)          // 0dim 
;;

(*
idoall : (var [int] -> var a -> comm) -> var [a] -> comm

is an indexed version of doall, i.e. allows the procedure to access
the array index as first argument.  
*)

let idoall pr (x:var [a]) = 
let m = numdim #x in 
new #ndx = {m:int_shape} in 
let g n pr1 (x1:var[a]) =                 
      for (i< (lendim #x1)) do
        ndx[(m-n)-1] := i ;
        pr1 sub(x1,i) 
      done 
in
  primrec g (fun (x:var [a]) -> pr ndx (get x)) (numdim #x) x
end
;;

(* doall2 is a two array version of doall - indexing is done using the
second array argument *)

let doall2 pr (x:var[a]) (y:var[b]) = 
  primrec g (do_nonce2 pr) (numdim #y) x y
  where 
      g n = do_once2 
  and do_once2 pr1 (x1:var[a]) (y1:var[b]) = 
    for (i< (lendim #y1)) do
      pr1 sub(x1,i) sub(y1,i)
    done 
  and do_nonce2 pr0 (x0:var[a]) (y0:var[b]) = 
    pr0 (get x0) (get y0)
;;

let idoall2 pr (x:var[a]) (y:var[b]) = 
let m = numdim #x in 
new #ndx = {m:int_shape} in 
let do_nonce2 pr0 ndx (x0:var[a]) (y0:var[b]) =     
      pr0 ndx (get x0) (get y0) 
and g n pr1 (x1:var[a]) (y1:var[b]) =                 
      for (i< (lendim #x1)) do
        ndx[(m-n)-1] := i ;
        pr1 sub(x1,i) sub(y1,i)
      done 
in
  primrec g (do_nonce2 pr ndx) (numdim #x) x y
end
;;


let doall2_offset left pr (x:var[a]) (y:var[b]) = 
  primrec g (do_nonce2 pr) (numdim #y) left x y
  where 
      g n pr1 left1 (x1:var[a]) (y1:var[b])  = 
        for (i< (lendim #y1)) do
          pr1 (preddim left1) sub(x1,lendim left1 + i) sub(y1,i)
        done 
  and do_nonce2 pr0 left0 (x0:var[a]) (y0:var[b]) = 
    pr0 (get x0) (get y0)
;;


let doall3 pr (x:var[a]) (y:var[b]) (z: var[c]) = 
  primrec g (do_nonce3 pr) (numdim #x) x y z
  where 
      g n = do_once3 
  and do_once3 pr1 (x1:var[a]) (y1:var[b]) (z1: var[c]) =
    for (i< (lendim #z1)) do
      pr1 sub(x1,i) sub(y1,i) sub(z1,i) 
    done 
  and do_nonce3 pr0 (x0:var[a]) (y0:var[b]) (z0: var[c]) =
    pr0 (get x0) (get y0) (get z0)
;;


let doall3_offset (left1: var[int]) (left2:var[int]) 
                  pr 
                  (x:var[a]) (y:var[b]) (z: var[c]) =
  primrec g (do_nonce3 pr) (numdim #x) x y z
  where 
      g n = do_once3_offset 
                left1[(lendim #left1 - n - 1 )] 
                left2[(lendim #left2 - n - 1 )] 
  and do_once3_offset (offset1: int) (offset2: int) 
                        pr1 (x1:var[a]) (y1:var[b]) (z1: var[c]) =
    for (i< (lendim #z1)) do
      pr1 sub(x1,offset1 + i) 
          sub(y1,offset2 + i) 
             sub(z1,i) 
    done 
  and do_nonce3 pr0 (x0:var[a]) (y0:var[b]) (z0: var[c]) =
    pr0 (get x0) (get y0) (get z0)
;;


(* functions from procedures and shapes *)

let ap2exp f x = new y = x in f y end 
;;


(*
proc2fun : (var a -> var b -> comm) 
                -> (#b -> #a) 
                -> b -> a

Note that in f = proc2fun f_pr f_sh 
the first argument to f_pr is a variable 
whose data type is that output of f.
Also, f_pr should *not* write to 
its second argument.
*)

let proc2fun f_pr f_sh x = 
  new #y = f_sh #x
  and z = x in 
    f_pr y z
  return y
;;

(* 
proc2fun2 : (var a -> var b -> var c -> comm) 
                -> (#b -> #c -> #a) 
                -> b -> c -> a

proc2fun2 is like proc2fun 
but produces a function of two arguments. 
*)

let proc2fun2 f_pr f_sh x y =
  new #z = f_sh #x #y 
  and x0 = x
  and y0 = y in  
  f_pr z x0 y0
  return z
;;

(* 
ap2er : (var a -> comm) -> a -> a
e2ap : (a -> a) -> var a -> comm

Variations on ap2exp 
*)

let ap2er proc arg = 
        new aux = arg 
        in proc aux 
        return aux ;;


let e2ap f (x:var a) = x:= f x ;;



(* Second-Order Functions *)


(* Mapping *)

(* the procedure *)
let map_pr f  = 
  let pr (y:var b) (x:var a) = y := f !x in 
  doall2 pr
;;

(* in-place update *)
let update f x = map_pr f x x ;;


(* the shape *)
let map_sh fsh =
  folddim (zerodim . fsh) succdim
;;

(* the function 
map : (a -> b) -> [a] -> [b]
*)
let map f = proc2fun (map_pr f) (map_sh #f) 
;;


(* selfmap : (a -> a) -> [a] -> [a]
will use update instead of map_pr if the shapes allow it. *)

let selfmap f x = 
  let sh = zeroShape #x in 
  if         #f sh #= sh 
  then         new y = x in 
          update f y 
        return y
  else map f x
;;


(*
imap : ([int] -> a -> b) -> [a] -> [b]

is an indexed map (see idoall above)
*)

let imap_pr f  = 
   let pr (ndx:var [int]) y x = 
        y := f !ndx !x in 
  idoall2 pr
;;

let imap f x = proc2fun (imap_pr f) (map_sh (#f {numdim #x : int_shape})) x
;;

(*
map_pr_offset : var [int] -> (a -> b) -> var [b] -> var [a] -> comm
*)

let map_pr_offset left f =
  let pr y (x:var a) = y := f !x in 
  doall2_offset left pr
;;

(* 
map_offset : var [int] -> (a -> b) -> var [b] -> [a] -> comm
  *)

let map_offset left f y = 
  ap2exp (map_pr_offset left f y) 
;;

(* 
zipop : (a -> b -> c) 
        -> [a] -> [b] -> [c]
takes a function of two arguments, 
and two arrays of the same outer shape, 
and produces a third array 
of the same outer shape, 
whose entries are obtained by applying 
the function to corresponding entries.

zip is not defined as the language 
does not currently support pairing.
*)

let zipop_pr f =

  let pr z (x:var a) (y:var b) = z := f !x !y
  in
  doall3 pr
;;

let zipop_sh fsh  =
  let f0 x y = 
    zerodim (fsh x (undim y)) 
  and f1 (n:size) h y = 
    check (n = (lendim y))
    (succdim n (h (preddim y)))
  in 
    folddim f0 f1 
;;

let zipop f = 
  proc2fun2 (zipop_pr f) (zipop_sh #f) 
;;


(* reduction 

Reduction of a function f is like folding 
of f except that f is required to have 
the property that #(f x y) = #x.
This is true for datum operations, 
but also for many array operations,
such as pointwise multiplication 
occuring in inner product.
*)

(* accum : (a -> b -> a) 
           -> var a -> var [b] -> comm
reduces in place, 
c.f. update above 
*)
let accum f z = 
  let pr y = z:= f !z !y 
  in 
    doall pr
;;

let reduce_pr f x z y = 
  (z := x ;
  accum f z y)
;;

let reduce_sh fsh (xsh: exp #a) ysh =
  check (fsh xsh (zeroShape ysh) #= xsh )
                xsh 
;;                

let reduce f x = 
  proc2fun (reduce_pr f x) (reduce_sh #f #x)         
;;


(* 
fold : (x -> a -> x) 
        -> x -> [a] -> x
can be applied to operations like append
which produce values having new shapes. 
These are computed by unwinding 
a primitive recursion. 
*)

let fold f x y  =
  if #f #x (zeroShape #y) #= #x 
  then reduce f x y 
  else 
  primrec g (fold_nonce f) (numdim #y) x y
  where 
      g n = fold_once 
  and fold_once h x y = 
    primrec (foldsucc h y) x (lendim #y) 
  and foldsucc h (y:exp b) i x = h x sub(y,i) 
  and fold_nonce f x (y:exp b) = f x (get y)
;;


(* Basic Datum Functions *)

(* integers *)

let zero_int = (0:int) ;;
let plus_int (x:int) y = x + y ;;        
let subtract_int (x:int) y = x-y;;
let times_int (x:int) y = x * y ;;
let divide_int (x:int) y = x div y ;;
let equal_int (x:int) y = x = y ;;
let less_than_int (x:int) y = x< y ;;
let less_than_or_equal_int (x:int) y = x<= y ;;
let sum_int = reduce plus_int 0 ;;
let inner_product_int x y = sum_int (zipop times_int x y) ;;

let modulus (x:int) y = x - (x div y * y) ;;

(* booleans *)

let conjunction (x:bool) y = x && y ;;
let disjunction (x:bool) y = x || y ;;
let eq_bool (x:bool) y = x=y ;;    

let bool2int (x:bool) = if x then 1 else 0 ;;
let all = reduce conjunction true ;;


(* floats *)

let zero_float = 0.0 ;;
let plus_float x y = x +. y ;;
let subtract_float x y = x -. y;;
let times_float x y = x *. y ;;
let less_than_float x y = x<. y ;;
let less_than_or_equal_float x y = x<=. y ;;

let sum_float = reduce plus_float zero_float ;;
let inner_product_float x y = sum_float (zipop times_float x y) ;; 



(* Initialising arrays *)

(* copy : #[a] -> b -> [b] *)

let copy_pr (y:var [a]) (x: var a) = 
  let pr z = z := x in 
   doall pr y
;;

let copy sh = proc2fun copy_pr (extendShape sh)
;;



(* Diagonal indexing *)

let diagvector k = 
        new #x = { k: int_shape} in 
        for (i < k) do
          x[i] := i 
        done
        return x
;;

(* reversing a vector *)

let reverse_pr (y:var b) (x:var a) = 
  for (i < n ) do
      sub(y,i) := sub(x,n-1-i)
    done
  where n = (lendim #!x)
;;

let reverse = proc2fun reverse_pr identity
;;


(* 
indexFill : #[a] -> #[int] -> [[int]]
fills an array shape with arrays 
containing the index information at
each entry.

No longer used. Better to use imap. 
 

let indexFill_pr sh = 
  primrec indexFill_step indexFill_pr0 m
  where
    indexFill_step n pr indices iA = 
        for (i<(lendim #!iA)) do
        indices[m - n - 1] := i ;        (* set index entry to be i *)
        pr indices sub(iA,i)                 (* set the other indices *)
      done 
  and indexFill_pr0 indices iA = 
      get iA := indices                 (* set iA entry to indices *)
  and m = numdim sh ;;

let indexFill sh sh1 =
  new #iA = extendShape sh sh1  
  and #indices = sh1 in 
  indexFill_pr sh indices iA
  return iA
;;

*)


(* No longer used. Try imap 

let indexArray sh =         
        (* puts index array at each entry, 
           e.g. the (i,j) position in a matrix has array [i,j] *)
  indexFill sh {(numdim sh) : int_shape}
;;

*)

(* Array entry techniques *)

let multi_sub (indices: exp [int]) array =
  let g n (x:var [a]) = sub(x,indices[n]) in 
  primrec g array (lendim #indices)
;;

let entry indices array = 
  get (multi_sub indices array)
;;

let entry2 array indices = 
  entry indices array 
;;


let multi_subexp_pr y indices x = 
    y := multi_sub indices x 
;;

let multi_subexp_sh ndx_sh array_sh = 
    primrec (fun x -> preddim) 
        array_sh (lendim ndx_sh) 
;;

let multi_subexp = proc2fun2 multi_subexp_pr multi_subexp_sh  
;;

(* 
entryexp : [int] -> [a] -> a
*)

let entryexp_pr y indices array = 
  y:= entry indices array 
;;

let entryexp_sh x = zeroShape 
;;

let entryexp = 
  proc2fun2 entryexp_pr  entryexp_sh
;;


let entryexp2 array indices = 
  entryexp indices array 
;;


(* 
transpose : [a] -> [a]
moves entries to the position 
obtained by reversing their indices.
*)

let transpose_pr y x = 
  let pr xs ndx y1 = 
    new xdn = reverse !ndx in 
        y1 := entry xdn xs 
    end
  in 
    idoall (pr x) y
;;


let transpose_sh = 
    folddim zerodim snocdim 
;;

let transpose = proc2fun transpose_pr transpose_sh 
;;


@head(2,"tfish.fsh")
tfish.fsh.
@select(tangler("fish/tfish.fsh",'data'))
(* quick test of fish:
flxf -Ilib tfish
*)
%use "standard_prelude.fsh";;
let f x = x*x;;
let mat = fill {2,3:int_shape} with [0,1,2,3,4,5];;
let mat2 = map f mat;;
%run mat2;;

@head(2,"map1.fsh")
map1.fsh.
@select(tangler("fish/map1.fsh",'data'))
let map1_pr f (y: var b) (x: var a) = 
  for i<(lendim #x) do
    sub(y,i) := f (sub(!x,i))
  done 
;;

let map1_sh f_sh x_sh = 
  succdim (lendim x_sh) (f_sh (preddim x_sh))
;;

let map1 f = proc2fun (map1_pr f) (map1_sh #f) ;;

let col k = map1 (fun (x:exp [a]) -> sub(x,k) ) ;;

(* tests 

let w = fill {2,3:int_shape} with [0,1,2,3,4,5] ;;
let w1 = col 1 w;;

*)

@head(2,"scan.fsh")
scan.fsh.
@select(tangler("fish/scan.fsh",'data'))
(* 

%use "BMF/scan.fsh" ;;

only for vectors.  *)


let scan_pr f u (y:var b) (x: var a) = 
  (y[0] := u ;
  for 1<= i< lendim #x do
    y[i] := f !y[i-1] !x[i-1]
  done)
;;

let scan f u = proc2fun (scan_pr f u) identity
;;
 

let scan_back_pr f u (y:var b) (x:var a) = 
  let n = lendim #x in 
  y[n-1] := u ;
  for (1<= i< n ) do
    y[n-i-1] := f !y[n-i] !x[n-i]
  done
;;


let scan_back f u = proc2fun (scan_back_pr f u) identity
;; 

(* ----------- *)


let scan_no_unit_pr f (y:var b) (x:var a) = 
  (y[0] := x[0] ;
  for 1<= i< lendim #x do
    y[i] := f !y[i-1] !x[i]
  done)
;;

let scan_no_unit f = proc2fun (scan_no_unit_pr f) identity
;;
 

let scan_back_no_unit_pr f (y:var b) (x:var a) = 
  let n = lendim #x in 
  y[n-1] := x[n-1] ;
  for 1<= i< n  do
    y[n-i-1] := f !y[n-i] !x[n-i-1]
  done
;;


let scan_back_no_unit f = proc2fun (scan_back_no_unit_pr f) identity
;; 


(*

let scantest = scan plus_int 0 (fill {3:int_shape} with [1,2,3]) ;;

let scan_backtest = scan_back plus_int 0 (fill {3:int_shape} with [1,2,3]) ;;

*)
@head(2,"reverse.fsh")
reverse.fsh.
@select(tangler("fish/reverse.fsh",'data'))
let reverse_pr (z:var a) (x:var a) =
  let n =  lendim #x 
  in 
    for i<n do
      sub(z,i) := sub(x,n-i-1) 
    done
;;

let reverse = proc2fun reverse_pr identity ;;

(*

let revtest = reverse (fill {3:int_shape} with [1,2,3]) ;;

*)

@head(2,"boolean.fsh")
boolean.fsh.
@select(tangler("fish/boolean.fsh",'data'))
(* Boolean algebra *)

(* 
%use "/homes/cbj/Languages/Fish/Datum/boolean.fsh" ;; 
*)

let zero = (false:bool) ;;
let plus (x:bool) y = x || y ;;
let times (x:bool) y = x && y ;;
let less_than (x:bool) (y:bool) = if x then false else y ;;
let less_than_or_equal (x:bool) (y:bool) = if x then y else true ;;



@head(2,"complex.fsh")
complex.fsh.
@select(tangler("fish/complex.fsh",'data'))
let zero = zero_complex ;;
let plus = plus_complex ;;
let subtract = subtract_complex ;;
let one = one_complex ;;
let times = times_complex ;;

let sum = sum_complex ;;
let inner_product = inner_product_float ;;


@head(2,"factorial.fsh")
factorial.fsh.
@select(tangler("fish/factorial.fsh",'data'))
let factorial n = 
  new y = 1 
  and x = n in 
  let rec C = 
        if x=0 
        then skip 
        else y := y*x; decr x ; C  
  in C 
  return y
;;


let factorial2 n = 
  new y = 1 in 
  let rec f x = 
        if x=0 then skip 
        else y := y*x; f (x-1)
  in f n
  return y
;;

(*

This doesn't work because of the limitations on let rec. 

let rec factorial n = 
  if n = 0 
  then 1 
  else n * factorial (n-1) ;;

*)

(*

let factorialtest = factorial 5 ;;

let factorial2test = factorial2 5;;

*)


@head(2,"fibonacci.fsh")
fibonacci.fsh.
@select(tangler("fish/fibonacci.fsh",'data'))
let fib x = 
  new y = 0 in 
    let rec f z = 
      if z <2
      then incr y
      else f (z-2) ; f(z-1)
    in f x
  return y
;;


let fib2 x =

(* z0 and z1 each hold half the fibonacci series, 
   with z0 holding the half containing the result. *)

new z0 = 1 
and z1 = 1 
and y = x 
in 
let rec C = 
  if y>1 
  then 
    (if y mod 2 = 0 
        then z0 := z0 + z1 
        else z1 := z0 + z1 ) ;
    decr y ;
    C
  else skip 
in C
return z0
;;


@head(2,"float.fsh")
float.fsh.
@select(tangler("fish/float.fsh",'data'))
(* Float operations *)

(* %use "/homes/cbj/Languages/Fish/Datum/float.fsh" ;; *)

let zero = zero_float ;;
let plus = plus_float ;; 
let subtract = subtract_float ;;
let times = times_float ;;
let sum = sum_float ;;
let inner_product = inner_product_float ;;



@head(2,"integer.fsh")
integer.fsh.
@select(tangler("fish/integer.fsh",'data'))
(* Integer operations *)

(* 
%use "/homes/cbj/Languages/Fish/Datum/integer.fsh" ;; 
*)

(* Datum Operations *)

let zero = zero_int;;
let plus = plus_int ;;
let subtract = subtract_int ;;
let times = times_int ;;
let divide = divide_int ;;
(* let equal = equal_int ;; *)
let less_than = less_than_int ;;
let less_than_or_equal = less_than_or_equal_int ;;
let sum = sum_int ;;
let inner_product = inner_product_int ;;



@head(2,"op_tests.fsh")
op_tests.fsh.
@select(tangler("fish/op_tests.fsh",'data'))
(*
%use "Datum/op_tests.fsh" ;;
*)

(* tests for correctness of coercions on primitive operations *)

(* static terms *)

(* typing sucesses *)

(* polymorphic integer ops *)

-3;;
-3.0;;


3 + 4 ;;

3.0 + 4.0;;

(* float ops *)

-.3.0;;


3.0 +. 4.0;;

(* polymorphic binary relations *)

3 > 4 ;;

3.0 > 4.0;;

true>false;;

'a'>'b';;

(* other ops *)

3 div 4 ;;


true&&false;;


(* typing failures 

-true;;
-'a';;

3 + 4.0 ;;
3 + true;;
3 + 'a';;

3.0 + 4;;
3.0+true;;
3.0+'a';;

true+3;;
true+4.0;;
true+false;;
true+'a';;

'a'+3;;
'a'+3.0;;
'a'+true;;
'a'+'b';;

-.3;;
-.true;;
-.'a';;

3 +. 4 ;;
3 +. 4.0 ;;
3 +. true;;
3 +. 'a';;

3.0 +. 4;;

3.0+.true;;
3.0+.'a';;

true+.3;;
true+.4.0;;
true+.false;;
true+.'a';;

'a'+.3;;
'a'+.3.0;;
'a'+.true;;
'a'+.'b';;

3 > 4.0 ;;
3 > true;;
3 > 'a';;

3.0 > 4;;

3.0>true;;
3.0>'a';;

true>3;;
true>4.0;;
        
true>'a';;

'a'>3;;
'a'>3.0;;
'a'>true;;

3 div 4.0 ;;
3 div true;;
3 div 'a';;

3.0 div 4;;
3.0 div 4.0;;
3.0 div true;;
3.0 div'a';;

true div 3;;
true div 4.0;;
true div false;;
true div 'a';;

'a' div 3;;
'a' div 3.0;;
'a' div true;;
'a' div 'b';;

3 && 4 ;;
3 && 4.0 ;;
3 && true;;
3 && 'a';;

3.0 && 4;;
3.0 && 4.0;;
3.0&&true;;
3.0&&'a';;

true&&3;;
true&&4.0;;

true&&'a';;

'a'&&3;;
'a'&&3.0;;
'a'&&true;;
'a'&&'b';;

*)

(* left term dynamic *)

(* typing sucesses *)

(* polymorphic integer ops *)

-(3:int);;
-(3.0:float);;


(3:int) + 4 ;;

(3.0:float) + 4.0;;

(* float ops *)

-.(3.0:float);;


(3.0:float) +. 4.0;;

(* polymorphic binary relations *)

(3:int) > 4 ;;

(3.0:float) > 4.0;;

(true:bool)>false;;

('a':char)>'b';;

(* other ops *)

(3:int) div 4 ;;


(true:bool)&&false;;


(* typing failures 

-(true:bool);;
-('a':char);;

(3:int) + 4.0 ;;
(3:int) + true;;
(3:int) + 'a';;

(3.0:float) + 4;;
(3.0:float)+true;;
(3.0:float)+'a';;

(true:bool)+3;;
(true:bool)+4.0;;
(true:bool)+false;;
(true:bool)+'a';;

('a':char)+3;;
('a':char)+3.0;;
('a':char)+true;;
('a':char)+'b';;

-.3;;
-.(true:bool);;
-.('a':char);;

(3:int) +. 4 ;;
(3:int) +. 4.0 ;;
(3:int) +. true;;
(3:int) +. 'a';;

(3.0:float) +. 4;;

(3.0:float)+.true;;
(3.0:float)+.'a';;

(true:bool)+.3;;
(true:bool)+.4.0;;
(true:bool)+.false;;
(true:bool)+.'a';;

('a':char)+.3;;
('a':char)+.3.0;;
('a':char)+.true;;
('a':char)+.'b';;

(3:int) > 4.0 ;;
(3:int) > true;;
(3:int) > 'a';;

(3.0:float) > 4;;

(3.0:float)>true;;
(3.0:float)>'a';;

(true:bool)>3;;
(true:bool)>4.0;;
        
(true:bool)>'a';;

('a':char)>3;;
('a':char)>3.0;;
('a':char)>true;;

(3:int) div 4.0 ;;
(3:int) div true;;
(3:int) div 'a';;

(3.0:float) div 4;;
(3.0:float) div 4.0;;
(3.0:float) div true;;
(3.0:float) div'a';;

(true:bool) div 3;;
(true:bool) div 4.0;;
(true:bool) div false;;
(true:bool) div 'a';;

('a':char) div 3;;
('a':char) div 3.0;;
('a':char) div true;;
('a':char) div 'b';;

(3:int) && 4 ;;
(3:int) && 4.0 ;;
(3:int) && true;;
(3:int) && 'a';;

(3.0:float) && 4;;
(3.0:float) && 4.0;;
(3.0:float)&&true;;
(3.0:float)&&'a';;

(true:bool)&&3;;
(true:bool)&&4.0;;

(true:bool)&&'a';;

('a':char)&&3;;
('a':char)&&3.0;;
('a':char)&&true;;
('a':char)&&'b';;

*)

(* right term dynamic - check that dynamic code block is entered *)

3 + (4:int) ;;

(* both dynamic - check that dynamic code block is entered *)

(true:bool) > (false : bool) ;;
@head(2,"takc.fsh")
takc.fsh.
@select(tangler("fish/takc.fsh",'data'))
(* Not sure if this is correct *)

let takc x y z =
  new #u = int_shape in  
  let rec tak x y z = 
    if x > y 
    then 
      new #x1 = int_shape ;
          #y1 = int_shape ;
          #z1 = int_shape 
      in 
        tak (x-1) y z ;
        x1 := !u ;
        tak (y-1) z x ;
        y1 := !u ;
        tak (z-1) x y ;
        z1 := !u ;
        tak x1 y1 z1
      end 
    else u:= z
  in tak x y z
  return u
;;



let repeat n =
new #u = int_shape in 
  let rec rpt k = 
    if k <= 0 
    then u:=0 
    else u:= takc 18 12 6 ; rpt(k-1)
  in rpt n 
return u
;;

let _ = print_int (repeat 50); print_newline(); exit 0

@head(2,"difference.fsh")
difference.fsh.
@select(tangler("fish/difference.fsh",'data'))
(* 
%use "Difference_equations/difference.fsh";;
*)

(* Difference equations 

diff_solver_inner : ([a] -> a) ->
                #[b] ->
                  #[c] ->
                    (var bool -> var [a] -> var [a] -> bool) -> [a] -> [a]

diff_solver_inner eqn left right converged initial acts as follows.  

left and right specify the offsets from the central point of a mask.
eqn is used to produce new entries from the associated masks. 
converged determines whether the new array is "the same as" the old array 
        (the boolean argument is usually ignored).
initial is the initial value of the array.

diff_solver_inner uses inner stencils, and so does not change the
boundary values during computation.

diff_solver_outer uses an outer stencil to supply the necessary
values.

See life.fsh for  examples. 

*)

%use "Distributions/stencil.fsh" ;; 


let diff_solver_inner_pr
        diff_eqn         // acts on masks to produce new values 
        left                 // the mask shape (size to left of centre) 
        right                 // the mask shape (size to right of centre)
        near                 // intermediate output/criterion for termination
        final                // the result 
        (initial:var [a]) =        // initial conditions

new 
  initial_latest = true // initial is the latest value
in 
let pr y = (map_offset left diff_eqn y) . 
        (stencil_inner left right)
in         
  final := initial ;         // set the boundary of final
  pr final initial ;                
  while not (near !initial_latest !initial !final) do         
   initial_latest := not initial_latest ;         
   if initial_latest                
   then pr final initial        
   else pr initial final        
  done                         
end
;;

let diff_solver_inner diff_eqn left right near         
  = proc2fun 
        (diff_solver_inner_pr diff_eqn left right near)
        identity 
;;


let diff_solver_outer_pr 
        boundary_fn        // produces boundary values 
        diff_eqn         // acts on masks to produce new values 
        left                 // the mask shape (size to left of centre) 
        right                 // the mask shape (size to right of centre)
        near                 // intermediate output/criterion for termination
        final                // final value
        (initial:var [a]) =        // initial conditions
new 
  initial_latest = true // initial is the latest value
in 
let f = (map diff_eqn) . (stencil_outer boundary_fn left right)
in 
  final := f initial ;                
  while not (near !initial_latest !initial !final) do         
   initial_latest := not initial_latest ;
   if initial_latest                
   then final := f !initial        
   else initial := f !final  
  done                         
end
;;

let diff_solver_outer boundary_fn diff_eqn left right near = 
  proc2fun (diff_solver_outer_pr boundary_fn diff_eqn left right near) 
           identity
;;


(*

let initial = map (fun x -> int2float x) 
  (fill {5,5:int_shape} with 
  [         0,1,2,3,4,
        5,6,7,8,9,
           10,11,12,13,14,
        15,16,17,18,19,
           20,21,22,23,24
  ] )
;;


let max_float x y = if x >=. y then x else y ;;
let max_array_float = reduce max_float 0.0 ;;

let l1_norm x y = max_array_float (zipop f x y) 
  where f x y = fabs (x-.y) 
;;

let mean x = sum_float x /. (int2float (number_of_entries #x)) ;;

let dso epsilon = 
  diff_solver_outer 
        (fun x -> 0.0)
        (fun x -> sqrt (mean x))
        {1,1:int_shape}
         {1,1:int_shape} 
        (fun b -> fun x -> fun y -> l1_norm x y <. epsilon)
        initial
;;


let dso2 = dso 0.1
;;

let dso3 = dso2;;

*)
@head(2,"life.fsh")
life.fsh.
@select(tangler("fish/life.fsh",'data'))
(*
%use "Difference_equations/life.fsh";; 
*)

(* Conway's Game of Life  *)


%use "Difference_equations/difference.fsh";;


let life_or_death_pr (life: var a) (mask:var [a]) =         
                                        // computes new status of cell
  new centre = copy {numdim #mask : int_shape} 1   
                                        // mask centre
  and #n = int_shape                         // no. of live neighbours
  in
    life := entry centre mask ;                // current status 
    n := sum_int mask - life ;                
    if life=1 
    then 
        if n<2 || n>3 
        then life := 0
        else skip
    else 
        if n=3 
        then life:=1 
        else skip
  end
;;

let life_or_death_sh mask_sh = int_shape 
;;

let life_or_death = proc2fun life_or_death_pr life_or_death_sh
;;

let display_and_test even bde bdo =
  new #b = bool_shape in                // the test result
    (if even                                 // bde is the latest
    then output bdo                         // output is one step behind
                                        // to display the initial state 
    else output bde) ;                        // output the current value
    b := all(zipop equal_int bde bdo)         // stop if equal 
  return b
;;

let no_display_and_test even bde bdo =
  all(zipop equal_int bde bdo) // stop if equal 
;;

let continuing_life_inner board = 
   diff_solver_inner 
        life_or_death 
        (ones #board) 
        (ones #board)
        display_and_test
        board
;;

let continuing_life_outer board = 
   diff_solver_outer
        (fun x -> 0) 
        life_or_death 
        (ones #board) 
        (ones #board)
        display_and_test
        board
;;

let quiet_life board = 
   diff_solver_inner 
        life_or_death 
        (ones #board) 
        (ones #board)
        no_display_and_test
        board
;;


let short_life_pr (bd2:var [a]) (bd1:var [a]) = 
  new #mask = {3,3:int_shape} in
    for i< lendim #bd1 - 2 do
      for j< lendim (preddim #bd1) -2 do
        for k<3 do
          for l<3 do
            mask[k,l] := bd1[i+k+1,j+k+1] 
          done
            done ;
        bd2[i,j] := life_or_death mask
      done
    done
  end
;;

let short_life board = 
  proc2fun short_life_pr identity
;;

let continuing_short_life_pr (final:var[a]) (initial:var[a])  = 
  new         even = false                                 // final will be latest
  in                         
    final := initial ;                                // set the boundary
    short_life_pr final initial ;                // first computation 
    whiletrue 
        (not (display_and_test even initial final))          // work to do
    (        if even                                 // if initial is freshest
            then short_life_pr final initial        // then update final
        else short_life_pr initial final         // else update initial
    )
  end
;;

let continuing_short_life  = 
  proc2fun continuing_short_life_pr identity 
;;

let quiet_short_life_pr (final:var[a]) (initial:var[a]) =
  new         even = false                                 // final will be latest
  in                         
    final := initial ;                                // set the boundary
    short_life_pr final initial ;                // first computation 
    whiletrue 
        (not (no_display_and_test even initial final))          // work to do
    (        if even                                 // if initial is freshest
            then short_life_pr final initial        // then update final
        else short_life_pr initial final         // else update initial
    )
  end
;;

let quiet_short_life  = 
  proc2fun quiet_short_life_pr identity 
;;




(* An example 

let life_test1 = 
        continuing_life_inner
        (copy {10,10:int_shape} 0)
;;        

let x = fill {100:int_shape} with 
[
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0,
1,2,3,4,5,6,7,8,9,0
]
;;



let life_test1a = 
        quiet_life 
        (copy {10,10:int_shape} 0)
;;

let short_test1a = quiet_short_life 
        (copy {10,10:int_shape} 0)
;;


let life_test2 = 
  new board = copy {10,10:int_shape} 0 in 
    board[2,3] := 1 ;
    board [2,4] := 1 ;
    board := continuing_life_inner board 
  end 
;;

let life_test2a = 
  new board = copy {10,10:int_shape} 0 in 
    board[2,3] := 1 ;
    board [2,4] := 1 ;
    board := continuing_life_outer board 
  end 
;;


let life_test3 = 
  new board = 
    fill {10,10:int_shape} 
    with 
        [0,0,0,0,0,0,0,0,0,0,
         0,1,0,1,1,0,1,1,1,0,
         0,1,0,1,0,1,0,0,0,0,
         0,1,1,1,0,1,1,0,0,0,
         0,1,0,1,1,0,1,1,1,0,
         0,1,0,1,0,1,0,0,0,0,
         0,1,1,1,0,1,1,0,0,0,
         0,1,0,1,1,0,1,1,1,0,
         0,1,0,1,0,1,0,0,0,0,
         0,0,0,0,0,0,0,0,0,0 ] 
  in 
    board := continuing_life_inner board
  end 
;;


let life_test4 = 
  new board = 
    fill {5,5:int_shape} 
    with 
        [0,0,0,0,0,
         0,0,1,0,0,
         0,0,1,0,0,
         0,0,1,0,0,
         0,0,0,0,0] 
  in 
    board := continuing_life_inner board
  end 
;;

let life_test4a = 
  new board = 
    fill {3,3:int_shape} 
    with 
        [0,1,0,
         0,1,0,
         0,1,0] 
  in 
    board := continuing_life_outer board
  end 
;;

let life_test5 = 
  new board = 
    fill {4,4:int_shape} 
    with 
        [0,1,0,0,
         1,0,1,0,
         1,0,0,1,
         0,1,1,0] 
  in 
    board := continuing_life_outer board
  end 
;;


let life_test6 = 
  new board = 
    fill {3,3,3:int_shape} 
    with 
        [0,0,0,
         0,1,0,
         0,0,0,
         
         0,0,0,
         0,1,0,
         0,0,0,
         
         0,0,0,
         0,1,0,
         0,0,0,
] 
  in 
    board := continuing_life_outer board
  end 
;;



*)



@head(2,"block.fsh")
block.fsh.
@select(tangler("fish/block.fsh",'data'))
(*
%use "Distributions/block.fsh";;
*)


(* some auxiliary functions *)

let ones = 
  folddim zerodim f1
  where f1 n = succdim 1     
;;

let zeroes = folddim zerodim f1
  where f1 n = succdim ~0
;;

let add_shapes = 
  folddim  f0 f1
  where f0 x y = zerodim (undim y) 
  and f1 (n:size) h z = succdim (n + (lendim z)) (h (preddim z))
;;

let add_shapes_plus_one = 
        (* add one to the sum of each pair of sizes *)
  folddim  f0 f1
  where f0 x y = zerodim (undim y) 
  and f1 (n:size) h z = succdim (n+1 +(lendim z)) (h (preddim z))
;;



(* unblock converts an array of arrays to an array, by treating the
entries as blocks of the result.  *)


let unblock_sh sh = extendShape 
                        (add_shapes sh (zeroShape sh)) 
                        (zeroShape (zeroShape sh))
;;

let unblock_pr (y:var b) (x:var a) = 
new z = shape2array (zeroShape #x) in 
let pr1 ndx0 ndx1 a = 
  new ndx = zipop plus_int ndx1 
                  (zipop times_int ndx0 z)
  in 
    entry ndx y := !a
  end 
in
  let pr0 ndx0 = idoall (pr1 ndx0) 
in 
  idoall pr0 x
end
;;
 
 
let unblock = 
proc2fun unblock_pr unblock_sh 
;;

(*

let test = unblock (fill {2,2:2,2:int_shape} with 
                [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) ;;

*)


(* block : #[a] -> [b] -> [[b]] is the partial converse,. The first
argument is the shape of the result - ignoring the entryshape.  If the
block division is not exact then the remainder will be filled with
rubbish! There is no flag for marking null entries as yet. *)

let block_sh proc x_sh = 
  extendShape proc 
  (extendShape (shape_zipop snd ceiling_divide proc x_sh) 
  (zeroShape x_sh))
where 
  ceiling_divide (n:size) (s:size) =                 
  let p = s div n in 
  if p * n = s 
  then p
  else p + 1 
;;


let block_pr (y:var b) (x:var a) = 
new z = shape2array (zeroShape #y)
in 
  idoall pr0 y
where pr0 ndx0  = idoall (pr1 ndx0) 
and pr1 ndx0 ndx1 a = 
    new ndx =         zipop plus_int ndx1 (
                  zipop times_int ndx0 z)        
    in 
      a := entry ndx x 
    end 
end
;;
 


let block proc = proc2fun block_pr (block_sh proc) ;;

(*
let test = block {2,2:int_shape} (fill {4,4:int_shape} with
                 [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]) ;;
*)
@head(2,"implode_shape.fsh")
implode_shape.fsh.
@select(tangler("fish/implode_shape.fsh",'data'))
(*
%use "Distributions/implode_shape.fsh" ;;
*)



(* implode_shape : [a] -> [a]

converts multi-dimensional arrays into 1d arrays - 
not to be confused with implode_type : [[a]] -> [a] 

*)

%use "BMF/scan.fsh" ;;

let entry_offset = (scan_back times_int 1) . shape2array
;;


let implode_shape_pr (ys: var b) (xs: var a) =
  new offset =  entry_offset #xs 
  and #k = int_shape in 
  let pr k ndx x = 
    (k := inner_product_int 
                !offset
                !ndx ;
    ys[k] := x)
  in 
    idoall (pr k) xs 
  end 
;;

let implode_shape_sh x = 
  succdim (number_of_entries x) (zerodim (zeroShape x)) 
;;
       
let implode_shape = 
  proc2fun implode_shape_pr implode_shape_sh ;;



(* explode_shape : #[a] -> [a] -> [a] is a partial inverse to
implode_shape. it takes the shape of the result, and some inputs, and
pours them into the desired shape.

*)



let fillup_pr sh y (x:var a) = 
  let pr k (ndxi:var [int]) yi = 
    (k := inner_product_int 
                (entry_offset sh)
                ndxi ;
    yi := x[k])
  in 
  new #k = int_shape in 
    idoall (pr k)  y 
  end
;;


let fillup sh = proc2fun (fillup_pr sh) (fst sh) 
;;

let explode_shape sh x = fillup sh (implode_shape x)
;;

(* Note: this is rather inefficient, due to the presence of an
intermediate data structure. See the incomplete file pour.fsh *)

@head(2,"implode_type.fsh")
implode_type.fsh.
@select(tangler("fish/implode_type.fsh",'data'))
(* 

%use "Distributions/implode_type.fsh" ;;

*)

(* implode_type : [[a]] -> [a] 

removes the (outermost) type boundary in an array of arrays. 

*)

let reverse_shape =
  folddim zerodim snocdim 
;;

let implode_type_sh xsh = 
  extendShape2 xsh (zeroShape xsh) 
;;

let implode_type_pr (y:var b) (x:var a) = 
  
primrec g (fun y -> fun (x:var a) -> y:= get x) (numdim #x) y x
where 
g n h (y: var b) (x:var a) = for 0 <= i < lendim #x do 
                h sub(y,i) sub(x,i) done
;;

let implode_type = 
  proc2fun implode_type_pr implode_type_sh
;;


let explode_type_sh k xsh = 
  primrec f (zerodim xsh) k 
  where 
    f n x = extendShape2 
            x
            (succdim  (lendim (zeroShape x)) 
            (zerodim (preddim (zeroShape x))))
;;


let explode_type_pr y x = 
  let pr ndx yi = 
    yi := multi_sub ndx x
  in 
  idoall pr y 
;;

let explode_type k = 
  proc2fun explode_type_pr (explode_type_sh k) ;;


@head(2,"permute.fsh")
permute.fsh.
@select(tangler("fish/permute.fsh",'data'))
(*
%use "Distributions/permute.fsh" ;;
*)

(* 
permutation is a special case of replacing. Two version are
given. The first is polydimensional, the second only descends one
level (and works on sub-arrays, not entries)
*)


let replace_pr (x:var a) p  y = 
let pr ndx z = 
  z := entry (entry ndx p) x
in 
  idoall pr y 
;;

let replace x p = ap2er (replace_pr x p)
;;

let replace_1 p x =
new #y = #x in
  for i< lendim #x do
    sub(y,i) := sub(x,entryexp |[i]| p) 
  done
return y
;;

@head(2,"stencil.fsh")
stencil.fsh.
@select(tangler("fish/stencil.fsh",'data'))
(* 
%use "Distributions/stencil.fsh";;
*)

%use "Distributions/block.fsh" ;;

(*

Stencilling produces an array of neighbourhoods. Inner stencilling
shrinks the shape of the outer array to ensure that the neighbourhoods
do not trigger array bounds. For example,

>-|> stencil_inner_sh {1,1:int_shape}  {1,1:int_shape} {9,9:int_shape};;
J : #[[int]]
#J = { ~7,~7 : ~3,~3 : int_shape }

Inner stencilling is also used for broadcasting, as follows. If the
proclaimed "mask" is bigger than the array in a given dimension then
the actual mask size will be that of the original array, with all
entries broadcast.

>-|> stencil_inner_sh {10,10:int_shape}  {1,1:int_shape} {9,9:int_shape};;
J : #[[int]]
#J = { ~9,~9 : ~9,~9 : int_shape }

These can be mixed, as follows: 

>-|> stencil_inner_sh {1,10:int_shape}  {1,1:int_shape} {9,9:int_shape};;
J : #[[int]]
#J = { ~7,~9 : ~3,~9 : int_shape }

Outer stencilling does not change the shape of the outer array, and so
must choose values for the location sbeyond the boundaries. One
alternative would be to use null values, but these are not yet part of
the language. Another is to use a function to create new boundary
values as a function of the existing boundary. The idea is to work out
from the innermost dimensions. For a matrix the diagrammatic
description is as follows.

        -------------------------
        |                        |
        -------------------------
        |                        |
        -------------------------
        | | |                      | |
        |-|-|-----------------|-|
        | | |                      | |
        |-|-|-----Matrix -----|-|
        | | |                      | |
        |-|-|-----------------|-|
        | | |                      | |
        -------------------------
        |                        |
        -------------------------

This clumsy diagram indicates that first the rows (as innermost
dimension) are extended, and then the columns. Note that at each stage
new entries are only neighbours to a single entry of the earlier
matrix. Thus a function f:a -> a suffices for an array of type [a].

An example is 

>-|> stencil_outer (fun x -> 0)
        {1,1:int_shape}
        {1,1:int_shape}
        (fill {4,4:int_shape} with 
        [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
;;
J : [[int]]
#J = { ~4,~4 : ~3,~3 : int_shape }

The programs are all poly-dimensional. 
*)

(* Some auxiliary functions *)


(* wides : #[a] -> #[b] -> [int]

produces an array which marks (by 0) the dimensions in which the
mask shape (the first argument) is wider than the array.
*)

let wides mask_sh sh =   
  new #ws = {numdim sh : int_shape} 
  and ndx = 0 in 
  let f0 m sh1 = skip 
  and f1 (n:size) h sh1 = (
        ws[ndx] := 
          (if n <= (lendim sh1)
           then 1 
           else 0) ;
        incr ndx ;
        h (preddim sh1) )
  in 
  folddim f0 f1 mask_sh sh
  return ws 
;;

(* the inner stencil *)

let stencil_inner_sh =
folddim f0 f1 
  where f0 left right sh = zerodim sh 
  and f1 (n:size) h right sh = 
    let p = n + (lendim right) 
    and q = lendim sh 
    and base = h (preddim right) (preddim sh)
    in 
      if p < q 
      then succdim (q-p)
           (extendShape base (succdim (p+1) (zeroShape base)))
      else succdim q
           (extendShape base (succdim q (zeroShape base)))
;;


let stencil_inner_pr (target:var [a]) (source:var a) = 
new ndx0 = wides (zeroShape #target) #source 
and #ndx = #ndx0 in 
let h (ndx1:var [int]) (ndx2:var[int]) =
  ndx := zipop plus_int ndx2 (                                // the inner index
         zipop times_int ndx1 ndx0                        // the outer index
         ) in 
let pr0 ndx1 ndx2 y = (
      h ndx1 ndx2 ;
      y:= entry ndx source )                // get the entry 
and pr ndx1 = idoall (pr0 ndx1) 
in 
  idoall pr target 
end
;;


let stencil_inner left right = 
  proc2fun (stencil_inner_pr) 
        (stencil_inner_sh left right)
;;

(* add_boundary *)

let skip3 x y z = skip ;;

let update_boundary f left right (target:var a) = 
  let g n h lt rt (x:var b) = 
    let m1 = lendim #x
    and        kl = lendim lt
    and kr = lendim rt
  in 
  for kl <= i < m1-kr do
    h (preddim lt) (preddim rt) sub(x,i)
  done ;                                // the inner dimensions 
  for i < kl do
    map_pr f sub(x,kl-i-1) sub(x,kl-i)         // the left extension
  done ;
  for m1-kr <= i < m1 do                 // the right extension 
    map_pr f sub(x,i) sub(x,i-1)
  done
in 
  primrec g skip3 (numdim #target) left right target
;;

let add_boundary_pr f left right target source = 
  (map_pr_offset left identity target source ;
  update_boundary f left right target)
;;
 

let add_boundary_sh left right sh = 
  add_shapes (add_shapes left right) sh
;;

let add_boundary f left right = 
  proc2fun (add_boundary_pr f left right) (add_boundary_sh left right)
;;


(* the outer stencil *)

let stencil_outer f left right = 
  (stencil_inner left right) . (add_boundary f left right)
;;

(*

let st_test = 
  stencil_inner 
        {1,1:int_shape}
        {1,1:int_shape}
        (fill {4,4:int_shape} with 
        [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
;;


let mat = add_boundary (plus_int 1) {1,1:int_shape} {1,1:int_shape} 
                (fill {2,3:int_shape} with [0,1,2,3,4,5])
;;

let three_d = add_boundary  (plus_int 1){1,1,1:int_shape} {1,1,1:int_shape} 
        (fill {2,3,2:int_shape} with [0,1,2,3,4,5,0,1,2,3,4,5])
;;

let sto2 = 
  stencil_outer (fun x -> 0)
        {1,1:int_shape}
        {1,1:int_shape}
        (fill {4,4:int_shape} with 
        [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15])
;;

let 


*)
@head(2,"hotspot.fsh")
hotspot.fsh.
@select(tangler("fish/hotspot.fsh",'data'))
(*
%use "Hotspot/hotspot.fsh";;
*)

(* A simple example of the use of the difference equation solver *)

%use "Difference_equations/difference.fsh";;
%use "Statistics/statistics.fsh" ;;
%use "Statistics/norms.fsh" ;;

let epsilon = 0.1 ;;

let near b x y = 
  l2_norm (zipop subtract_float x y) <. epsilon 
;; 

let hotspot x = 

  diff_solver_outer
          (fun x -> 0.0)                // temperature on boundary is 0.0
        (fun x -> mean x +. 1.0) // new temperature is average of neighbours +1
        (ones #x)
        (ones #x)                 // nearest neighbours only
        near                         // convergence test
        x                        // initial value 
;;

let hotspot1 = hotspot (copy {4:float_shape} 0.0) ;;
let hotspot2 = hotspot (copy {3,4:float_shape} 0.0) ;;

@head(2,"fft.fsh")
fft.fsh.
@select(tangler("fish/fft.fsh",'data'))
(*
 %use "/homes/cbj/public_html/FISh-1.1/Samples/Matrix/fft.fsh";;
*)

(* fft.fsh - modified version of Leroy's fft.ml *)

let pi = 3.14159265358979323846
;;

let tpi = 2.0 *. pi
;;

let fft px py np =
  new i = 2
  and m = 1 
  in

  while (!i < np) do 
    i := !i + !i; 
    m := !m + 1
  done ;

  new n = !i 
  in  
    if (not (n = np)) then (* checks that np is power of 2 *)
      let f = (fun t -> 0.0)
      in 
        update f px;
        update f py
    else skip ;

    new n2 = n+n 
    in
    for (1 <= k < !m) do 
      n2 := !n2 div 2; 
      new n4 = !n2 div 4 
      in
        new e = tpi /. (int2float(!n2))
        in
          for (1 <= j < n4 + 1) do 
              new a = e *. (int2float(j - 1))  
              and a3 = 3.0 *. a  
              and cc1 = cos(a) 
              and ss1 = sin(a) 
              and cc3 = cos(a3)
              and ss3 = sin(a3)
              and is = j 
              and id = 2 * !n2
              in
                while (!is < n) do 
                new i0r = !is
                  in 
                  while (!i0r < n) do 
                    new i0 = !i0r 
                    and i1 = i0 + n4 
                    and i2 = i1 + n4 
                    and i3 = i2 + n4 
                    and r1 = px[i0] -. px[i2] 
                    in
                       px[i0] := px[i0] +. px[i2];
                      new r2 = px[i1] -. px[i3] 
                      in
                        px[i1] := px[i1] +. px[i3];
                           new s1 = py[i0] -. py[i2] 
                        in
                          py[i0] := py[i0] +. py[i2];
                            new s2 = py[i1] -. py[i3] 
                            in
                              py[i1] := py[i1] +. py[i3];
                               new s3 = r1 -. s2 
                              and r1 = r1 +. s2 
                              and s2 = r2 -. s1 
                              and r2 = r2 +. s1 
                                in
                                 px[i2] := r1 *. cc1 -. s2 *. ss1; 
                                   py[i2] := (0.0 -. s2 *. cc1) -. r1 *. ss1;
                                  px[i3] := s3 *. cc3 +. r2*.ss3;
                                 py[i3] := r2 *. cc3 -. s3*.ss3;
                                 i0r := i0 + !id
                              end (* new s3,r1,s2,r2 *)
                            end (* new s2 *) 
                          end (* new s1 *)
                        end (* new r2 *)
                      end (* new i0,i1,i2,i3,r1 *)
                  done ; (* while !i0r *)
                  is := 2 * !id - !n2 + j;
                  id := 4 * !id
                end (* new i0r *)
              done (* while is *)
            end (* new a, a3, cc1, ss1,cc3,ss3,is,id *)
          done
          end (* new e *)
        end (* new n4 *) 
      done
      end ; (* new n2 *)

     (************************************)
     (*  Last stage, length=2 butterfly  *)
     (************************************)

      new is = 1
      and id = 4
      in
        while (!is < n) do 
          new i0r = !is 
          in
            while (!i0r <= n) do 
              new i0 = !i0r 
              and i1 = i0 + 1
              and r1 = px[i0]
              in  
                px[i0] := r1 +. px[i1];
                px[i1] := r1 -. px[i1];
                new r1 = py[i0]
                in
                  py[i0] := r1 +. py[i1];
                  py[i1] := r1 -. py[i1];
                  i0r := i0 + !id
                end (* new r1 *) 
              end (* new i0,i1,r1 *)
            done ;
            is := 2 * !id - 1; 
            id := 4 * !id
          end (* new i0r *)
        done 
        end ; (* new is, id *)

        (*************************)
        (*  Bit reverse counter  *)
        (*************************)

        new j = 1 
        in
        for (1 <= i < n) do
          if (i < !j) then 
            new xt = px[!j]
            in
              px[!j] := px[i]; 
              px[i] := xt;
              new xt = py[!j] 
              in
                py[!j] := py[i];
                py[i] := xt
              end (* new xt *) 
            end (* new xt *) 
          else skip ;
          new k = n div 2 
          in
            while (!k < !j) do 
              j := !j - !k; 
              k := !k div 2
            done ;
            j := !j + !k
          end (* new k *)
        done
      end (* new j *)
    end (* new n *) 
  end (* new i,m *)  
;;

(* 
let runtest (np:size) =
  new enp = int2float(np) 
  and npm = np div 2 - 1
  and #pxr = { np + 2 : float_shape } 
  and #pxi = #pxr 
  in
       update (fun t -> 0.0) pxr;
       update (fun t -> 0.0) pxi;
       new t = pi /. enp
       in 
         pxr[1] := (enp -. 1.0) *. 0.5;
         pxi[1] := 0.0;
         new n2 = np div 2 in
           pxr[n2+1] := -.0.5;
           pxi[n2+1] := 0.0
         end ; (* new n2 *)

         for (1 <= i < npm + 1) do 
           new j = np - i 
           in
             pxr[i+1] := -.0.5;
             pxr[j+1] := -.0.5;
             new z = t *. int2float(i) 
             and y = -.0.5 *. (cos(z)/.sin(z))
             in
                 pxi[i+1] := y;
                 pxi[j+1] := 0.0 -. y
             end (* new x,y *)
           end (* new j *)
         done ;

          fft pxr pxi np ; 

         new zr = 0.0 
         and zi = 0.0 
         and kr = 0 
         and ki = 0 
         in
           for (0 <= i < np) do 
             new a = fabs(pxr[i+1] -. int2float(i))
             in
               if (!zr <. a) 
               then 
                 zr := a; 
                 kr := i
               else 
                 skip
             end ; (* new a *)
             new a = fabs(pxi[i+1]) 
             in
               if (!zi <. a) 
               then 
                 zi := a; 
                 ki := i
               else
                 skip                 
             end (* new a *) 
           done
         end (* new zr,zi,kr,ki *) 
       end (* new t *)        
    end (* new enp,npm,pxr,pxi *)
;;

let fftest = 
   (runtest 16; 
   runtest 32;
   runtest 64;
   runtest 128;
   runtest 256;
   runtest 512;
   runtest 1024;
   runtest 2048;
   runtest 4096;
   runtest 8192;
   runtest 16384;
   runtest 32768;
   runtest 65536)
;; 

%run -c -q fftest
;;

*)
@head(2,"fourier.fsh")
fourier.fsh.
@select(tangler("fish/fourier.fsh",'data'))
(* 
%use "Matrix/fourier.fsh";; 
*)

%use "Preludes/complex_prelude.fsh";;
%use "BMF/scan.fsh";;

        (* nth root of unity *)

let root (n:size) = 
  let pi = 3.1415927 in 
    from_mod_arg 
            1.0 
        (2.0 *. pi /. (int2float n)) 
;;  


let fourier_pr (z:var b) (x: var a) = 
  let n = lendim #x 
  and omega = root n in 
  new twiddle = scan times_complex one_complex (copy {n:float_shape} omega) 
  in 
     z := copy {n:int_shape} zero_complex ;
     for i < n do 
        for j < n do
          z[i] := plus_complex z[i] (times_complex twiddle[i*j mod n] x[j])
        done
     done
  end
;;

let fourier = proc2fun fourier_pr identity ;;


@head(2,"lu_solver.fsh")
lu_solver.fsh.
@select(tangler("fish/lu_solver.fsh",'data'))
(*
%use "Matrix/lu_solver.fsh";;
*)

(* 

This program takes a non-singular square matrix a and a vector b of
the same length and solves the equation 

        a x = b

using an LU decomposition of the matrix. The actual code of the solver
(repeated below) is given by

let lu_solver_pr b x a = 
let n = rows_var a in
new p = diagvector n 
in 
  lu_decompose a p ;
  x := permute p b ; 
  solve_lower_pr a x ;
  solve_upper_pr a x 
end
;;


*)


let rows x =  lendim #x ;;
let cols x = lendim (preddim #x) ;;

(* 
best_row : var [float] -> int -> int 

best_row a k finds the first row number >= k of the matrix whose
kth entry has the largest absolute value. Could be generalised. 
*)

let best_row a k = 
new r = k in 
  for k+1 <= j< rows a do
    if fabs a[j,k] > (fabs a[r,k])
    then r:= j
    else skip
  done
return r
;;


(* 
swap : var [a] -> int -> int -> comm
exchanges to subarrays of an array
*)

let swap (a: var b) i j = 
new t = sub(a,i) in 
  sub(a,i) := sub(a,j) ;
  sub(a,j) := t 
end 
;;


(*
install_pivot : var [float] -> int -> comm

install_pivot a k finds best_row a k and swaps that row with the kth.
This corresponds to the "exchange" of Molinari. In addition, the
permutation is recorded in the vector p which should be initialised to
be the diagonal [0,1,2,3,4...] *)


let install_pivot (a:var b) p k = 
  new r = best_row a k in
    if not (r=k) 
    then swap a k r ;
         swap p k r
    else skip 
  end
;;


(*
decompose1 : var [float] -> int -> comm

performs one pivot
*)


let decompose1 (a:var b) k = 
let n = rows a in 
new 
  #et = float_shape 
in 
  for k+1 <= i < n do
    et := a[i,k] / a[k,k] ;
    a[i,k] := et ;
    for k+1 <= j < n do 
      a[i,j]:= a[i,j] - et * a[k,j]
    done
  done
end
;;


let lu_decompose (a:var b) p = 
let n = rows a in
  for k< n - 1 do 
    install_pivot a p k ;
    decompose1 a k 
  done
 ;;

let permute_pr (y:var d) (p:var c) (b:var d) = 
for k<lendim #p do
   y[k] := b[p[k]]
done 
;;

let permute_sh p_sh b_sh = b_sh ;;

let permute = proc2fun2 permute_pr permute_sh
;;

let solve_lower_pr (a:var [float]) (y:var [float]) =
let n = rows a in
for k<n do
  for j<k do 
    y[k] := y[k] - a[k,j] * y[j] 
  done
done
;;
 
let solve_upper_pr (a:var [float]) (y:var [float])  = 
let n = rows a in 
new #kr = int_shape in 
  for k<n do
    kr := n-k-1 ;
    for kr +1 <= j<n do
      y[kr] := y[kr] - a[kr,j] * y[j] 
    done ;
    y[kr] := y[kr] / a[kr,kr] 
  done
end
;;

let lu_solver_pr b x (a: var c) = 
let n = rows a in
new p = diagvector n
in 
  lu_decompose a p ;
  x := permute p b ; 
  solve_lower_pr a x ;
  solve_upper_pr a x 
end
;;

let lu_solver_sh bsh ash = bsh 
;;

let lu_solver a b = proc2fun (lu_solver_pr b) (lu_solver_sh #b) a
;;




@head(2,"mat_mult_iprod.fsh")
mat_mult_iprod.fsh.
@select(tangler("fish/mat_mult_iprod.fsh",'data'))
(* 
%use "Matrix/mat_mult_iprod.fsh" ;; 
*)

%use "BMF/map1.fsh" ;;
%use "Datum/float.fsh";;

let rows x =  lendim #x ;;
let cols x = lendim (preddim #x) ;;

let mat_mult_iprod_pr (z:var [a]) (x:var[a]) (y:var [a]) =
  for i < rows x do
    for j < cols y do 
        z[i,j] := inner_product_float sub(x,i) (map1 (fun u -> sub(u,j)) y)
    done
  done
;;

let mat_mult_iprod_sh x y  = 
  check (numdim x = 2)
  check (numdim y = 2)
  check (lendim (preddim x) = lendim y)
        (succdim (lendim x) 
        (succdim (lendim (preddim y))
        (zerodim float_shape)))
;;

let mat_mult_iprod = proc2fun2 mat_mult_iprod_pr mat_mult_iprod_sh 
;;


(* 

let mat1 = map (fun x -> int2float x) (fill {2,3:int_shape} with [1,2,3,4,5,6]);;

let mat2 = map (fun x -> int2float x) (fill {3,2:int_shape} with [1,2,3,4,5,6]);;

let mat3 = mat_mult_iprod mat1 mat2;;

*)
@head(2,"mat_mult_loop.fsh")
mat_mult_loop.fsh.
@select(tangler("fish/mat_mult_loop.fsh",'data'))
(*
%use "Matrix/mat_mult_loop.fsh";;
*)

(* some basic linear algebra.  You must specify values for the
algebraic primitives before using this module.

plus
zero
times
...

This file uses float as the default 
*)

%use "Datum/float.fsh" ;;


let rows x =  lendim #x ;;
let cols x = lendim (preddim #x) ;;

let mat_mult_loop_pr (z:var [a]) (x:var [a]) (y:var [a]) = 
  for 0<= i< rows x do
    for 0 <= j< cols y do
      z[i,j]:= 0.0
      for 0 <= k< cols x do 
        z[i,j] := plus z[i,j]
                     (times x[i,k] 
                            y[k,j]) 
      done
    done
  done
;;

let mat_mult_loop_sh x y = 
  let m = lendim x
  and n = lendim (preddim x)
  and p = lendim y 
  and q = lendim (preddim y) 
  in 
  check (n = p)
  succdim m (succdim q (zerodim #zero))
;;

let mat_mult_loop = proc2fun2 mat_mult_loop_pr mat_mult_loop_sh        
;;


@head(2,"mat_vec_mult_float.fsh")
mat_vec_mult_float.fsh.
@select(tangler("fish/mat_vec_mult_float.fsh",'data'))
(*
%use "Matrix/mat_vec_mult_float.fsh";;
*)

let mat_vec_mult_float_sh xsh ysh = 
        check (lendim (preddim xsh) = (lendim ysh))
                (succdim (lendim xsh) (preddim ysh)) ;;

let mat_vec_mult_float_pr (z:var [a]) (x:var [a]) (y:var [a]) =
        for i< lendim #x do
          z[i] := inner_product_float y (sub(x,i))
        done 
;;

let mat_vec_mult_float = 
          proc2fun2 
        mat_vec_mult_float_pr 
        mat_vec_mult_float_sh 
;;


(* test

let mat = fill {2,3:float_shape} with [1.0,2.0,3.0,4.0,5.0,6.0] ;;
let vec = fill {3:float_shape} with [1.0,2.0,3.0] in 
    mat_vec_mult_float mat vec
;;

*)

@head(2,"mergesort.fsh")
mergesort.fsh.
@select(tangler("fish/mergesort.fsh",'data'))
(*
%use "Quicksort/mergesort.fsh";;
*)

(* merge combines the sorted segments of the vector x (from lo to mid
        and mid to hi) into the corresponding part of y *)

let merge (ltor: exp a -> exp a -> bool) lo mid hi (y:var [a]) (x:var [a])  = 
  new i = lo
  and j = mid 
  and k = lo in 
  while i< mid && (j < hi) do
        (if ltor x[i]  x[j] 
        then y[k] := x[i] ;
             incr i ; 
        else y[k] := x[j] ;
             incr j ;
        ) ;
             incr k ;
  done ;

  if i = mid
  then for j <= jj < hi do 
         y[jj] := x[jj] 
       done ;
  else for i <= ii < mid do 
         y[mid + ii] := x[ii] 
       done ;
  end 
;;

(*
let v = 
  new #x = {8:int_shape}  
  and y = fill {8:int_shape} with [0,2,4,7,1,3,5,6] in 
    merge less_than_or_equal_int 0 4 8 x y 
  return x;;
*)


let mergesort_pr ltor (y:var [a]) (x:var [a]) = 

(* note rounding errors may give spurious results on large arrays *)

  new #z = #x in             // temporary storage. 

  let rec mstep b lo hi =
    new mid = (lo+hi) div 2 in 
      if mid > lo
      then 
        mstep (not b) lo (mid:int) ; 
        mstep (not b) (mid:int) hi ; 
        if b                          
        then merge ltor lo mid hi y z  // answer to go in y 
        else merge ltor lo mid hi z y  // answer to go in z 
      else skip 
    end 
  in

  let iterations = log (int2float (lendim #x)) /. (log 2.0) in 
  (if iterations fmod 2.0 >. 1.0  // if the number of iterations is even
  then y := x                 // then store the inputs in y (the result) 
  else z := x );              // else store the inputs in z                 
  mstep true 0 (lendim #x) 
  end 
;;

let mergesort ltor  = proc2fun (mergesort_pr ltor) identity ;;


(*
let arg = fill {8:float_shape} with [2.0,3.0,1.0,2.0,5.0,5.0,3.0,6.0];;
let result2 = mergesort less_than_or_equal_float arg ;;
 %run  result2;;
*)

@head(2,"quicksort.fsh")
quicksort.fsh.
@select(tangler("fish/quicksort.fsh",'data'))
(*
%use "Quicksort/quicksort.fsh" ;;
*)

(* Modified from Bob Tennent's code to be FISh 1.1 compatible.
 and made polymorphic by having a single comparison function cmp,
(strict less_than) instead of <. and >.

*)

let quicksort_pr (cmp: exp a -> exp a -> bool) (array: var [a]) =  
        let rec qs m n = 
          if m>=n then skip
          else 
          new sum = m + n
          and mid = sum div 2
          and pivot = array[mid] 
            and i = m
          and j = n
          in 
            whiletrue (cmp array[i]  pivot) ( incr i );  
            whiletrue (cmp pivot array[j]) ( decr j );
            whiletrue (i < j) (
              new aux = array[i] 
              in
                array[i] := array[j];
                array[j] := aux
              end;
              incr i; decr j;
              whiletrue (cmp array[i] pivot) ( incr i );  
              whiletrue (cmp pivot array[j]) ( decr j )
            );
            (if i=j then incr i; decr j else skip);
            qs m (!j) ; qs (!i) n 
          end
      in qs 0 (lendim #array -1) 
      ;;

      let quicksort cmp = ap2er (quicksort_pr cmp);;

(*
      let arg = fill {8:float_shape} with [2.0,3.0,1.0,2.0,5.0,5.0,3.0,6.0];;
      let result = quicksort less_than_float arg ;;
       %run  result;;
*)

let benchmark (k:size) = 
  new seed = 0 in 
  let next = seed := !seed * 25173 + 17431 in 
  new #v = {k * 10000:float_shape} in 
    for i< k * 10000 do
      next ;
      v[i] := int2float seed 
    done ;
    quicksort_pr less_than_float v
  end
  end 
;;

@head(2,"norms.fsh")
norms.fsh.
@select(tangler("fish/norms.fsh",'data'))
(* 
%use "Statistics/norms.fsh" ;;
*)

(*
l_1, l_2 and l_infinity norms on arrays.
*)

let l1_norm = fold f 0.0
  where f x y = x +. (fabs y)        (* change fabs for other types!! *)
;;

let l2_norm x = sqrt (fold f 0.0 x) 
  where f x y = x +. (y*.y) 
;;

let l_infinity_norm = 
  let f_pr x (y:var a) = if x >. y then y:= x else skip in 
  let f x y = ap2er (f_pr y) x in
    fold f 0.0 
;;


@head(2,"statistics.fsh")
statistics.fsh.
@select(tangler("fish/statistics.fsh",'data'))
(* 
%use "/homes/cbj/Languages/Fish/Datum/integer.fsh"  ;;
%use "/homes/cbj/Languages/Fish/Datum/float.fsh"  ;;
%use "Statistics/statistics.fsh" ;;
*)


let mean x = sum_float x / (int2float (number_of_entries #x)) ;;

let square_difference x y = new z = x -. y in z:= z *. z return z ;;

let variance x = 
  sum_float (zipop square_difference x (copy #x (mean x))) /. 
        (int2float (lendim #x - 1));;


(*
let meantest = mean (fill {4:float_shape} with [1.0,2.0,3.0,4.0]) ;;
let variancetest = variance (fill {4:float_shape} with [1.0,2.0,3.0,4.0]) ;;
*)



@head(2,"append.fsh")
append.fsh.
@select(tangler("fish/append.fsh",'data'))
(*
%use "Sundry/append.fsh" ;;
*)

(*
append : [a] -> [a] -> [a]

actually does joining of blocks 
*)


let append x y = 
  check (preddim #x #= (preddim #y)) (
  let m = lendim #x
  and n = lendim #y in  
  new #z = succdim (m+n) (preddim #x) 
  in 
  for i< m do
    sub(z,i) := sub(x,i)
  done ;
  for i<n do
    sub(z,m+i) := sub(y,i)
  done
  return z )
;;

@head(2,"converge.fsh")
converge.fsh.
@select(tangler("fish/converge.fsh",'data'))
(*
%use "Sundry/converge.fsh" ;;
*)

let conjunction x y = x && y 
;;
let all = reduce conjunction true
;;
let equal_int x y = x=y 
;;
let equal_vec_int x y = all (zipop equal_int x y)
;;


let converge eq proc (x:var a) =
  new different = true 
  and y = x
  in 
     while different do 
        proc y;
        if eq y x 
        then different := false
        else x:= y
     done
  end
;;

let converge_int = converge equal_int
;;


let converge_vec_int = converge equal_vec_int
;;

@head(2,"tautology.fsh")
tautology.fsh.
@select(tangler("fish/tautology.fsh",'data'))
(*
%use "Sundry/tautology.fsh" ;;
*)

(* The tautology problem.


(1) Write a program that takes as inputs a number k and a boolean
proposition p in k variables, and determines whether or not p is a
tautology. 


(2) The typical program requires that k be at least as big as the number
of variables in p to succeed. Ensure that the compiler detects such
violations statically. 

*)



(* book-keeping, exponentials  *)

let is_zero n = if n=0 then true else false ;;

let if0 n x y = if is_zero n then x else y ;;

let conjunction x y = x && y ;;

let double_second (m:size) (n:size) = 2 * n ;;

let power_of_2  = primrec double_second (1:size) ;;


let diagarray n = 
  new #x = {n:int_shape} in 
    for i<n do 
      x[i] := i 
    done 
  return x ;;

(* base_bool converts an integer into a vector of booleans (its binary
representation, least significant bits first. The first argument
provides an upper bound on the length of the binary representation. *)

let base_bool_sh n sh = {n:bool_shape} ;;

let base_bool_pr (n:size) (res: var b) (arg: var a) =  

 for i < n do
   res[i] := is_zero (arg mod 2) ;
   arg := arg div 2
 done
;;

let base_bool n = proc2fun (base_bool_pr n) (base_bool_sh n) ;;

(* taut_tests n generates all boolean vectors of length n.
taut n prop checks to see if prop : vec[bool] -> bool 
is true for all vectors of length n *)


let taut_tests (n:size) = map (base_bool n) (diagarray (power_of_2 n)) ;;
let taut n prop = reduce conjunction true (map prop (taut_tests n)) ;;

(* Now build some propositional constructors *)

let K (i:size) v = check (lendim #v > i) v[i] ;;

let conj p q v = (p v) && (q v) ;;
let disj p q v = (p v) || (q v) ;;
let neg p v = not (p v) ;;



(* examples 

let prop1 = disj (conj (K 0) (K 1)) (K 2) ;;


let test1 = taut 3 prop1 ;;
let test2 = taut 2 prop1 ;;

*)
