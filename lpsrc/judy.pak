@execfile("config"+os.sep+"target_cxx.py")
@execfile("flxbuild"+os.sep+"iscrutil.py")
@env = setup_test('test/judy/judy-')

@select(tangler('spkgs/judy.py'))
@tangle('unit_tests = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')

iscr_source = ['lpsrc/judy.pak']
weaver_directory = 'doc/judy/'
pkg_requires = ['flx_judy']

@head(1,"Judy Arrays binding")
@h = tangler("lib/judy.flx")
@select(h)

// NOTES: The Felix type 'address' is the correct type for Judy Word
// However it is also an unsigned integer type (int or long depending
// on platform)
//
// But Felix doesn't support automatic int/address conversions
// 
// So we will (later) use a typeset to fix this!
#import <flx.flxh>
include "std";

module Judy
{
  requires package "flx_judy";
  requires header "#include <Judy.h>";
  open C_hack;

  type word = "Word_t";
  fun _ctor_word: int -> word = "(Word_t)$1";
  fun _ctor_int: word -> int = "(int)$1";
  fun _ctor_ulong: word -> ulong = "(unsigned long int)$1";

  type JError_t = "JError_t*";
  gen _ctor_JError_t : 1 -> JError_t = "(JError_t*)malloc(sizeof(JError_t))";
  proc free: JError_t = "free($1);";

  type J1Array = "void**";
  gen _ctor_J1Array: 1 -> J1Array = "_mkj1()" requires body 
   """
     void **_mkj1(){
       void **m =(void**)malloc(sizeof(void*));
       *m=0;
       return m;
     }
   """;

  proc free: J1Array = "_j1free($1);" requires body
    """
      void _j1free(void **p) {
        JError_t je;
        Judy1FreeArray(p, &je); free(p);
      }
    """;

  proc Judy1Set: J1Array * word * JError_t * ptr[int] = 
    "*$4=Judy1Set($1,$2,$3);";

  proc Judy1UnSet: J1Array * word * JError_t * ptr[int] = 
    "*$4=Judy1UnSet($1,$2,$3);";

  proc Judy1Test: J1Array * word * JError_t * ptr[int] = 
    "*$4=Judy1Test(*$1,$2,$3);";

  proc Judy1Count: J1Array * word * word* JError_t * ptr[word] = 
    "*$5=Judy1Count(*$1,$2,$3,$4);";

  proc Judy1ByCount: J1Array * word * ptr[word] * JError_t * ptr[word] = 
    "*$5=Judy1ByCount(*$1,$2,$3,$4);";

  proc Judy1FreeArray: J1Array * JError_t * ptr[word] = 
    "*$3=Judy1Free($1,$2);";

  proc Judy1MemUsed: J1Array * ptr[word] = "*$2=Judy1MemUsed(*$1);";

  proc Judy1First: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1First(*$1,$2,$3);";

  proc Judy1Next: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1Next(*$1,$2,$3);";

  proc Judy1Last: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1Last(*$1,$2,$3);";

  proc Judy1Prev: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1Prev(*$1,$2,$3);";

  proc Judy1FirstEmpty: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1FirstEmpty(*$1,$2,$3);";

  proc Judy1NextEmpty: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1NextEmpty(*$1,$2,$3);";

  proc Judy1LastEmpty: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1LastEmpty(*$1,$2,$3);";

  proc Judy1PrevEmpty: J1Array * ptr[word] * JError_t * ptr[int] = 
    "*$4=Judy1PrevEmpty(*$1,$2,$3);";

///////////////////////////////////////

  type JLArray = "void**";
  gen _ctor_JLArray: 1 -> JLArray = "_mkjL()" requires body 
   """
     void **_mkjL(){
       void **m =(void**)malloc(sizeof(void*));
       *m=0;
       return m;
     }
   """;

  proc free: JLArray = "_jLfree($1);" requires body
    """
      void _jLfree(void **p) { JudyLFreeArray(p); free(p); }
    """;

  proc JudyLIns: JLArray * word * JError_t * ptr[ptr[word]] = 
    "*(Word_t**)$4=(Word_t*)JudyLIns($1,$2,$3);";

  proc JudyLDel: JLArray * word * JError_t * ptr[int] = 
    "*$4=JudyLDel($1,$2,$3);";

  proc JudyLGet: JLArray * word * JError_t * ptr[ptr[word]] = 
    "*$4=(Word_t*)JudyLGet(*$1,$2,$3);";

  proc JudyLCount: JLArray * word * word * JError_t * ptr[word] = 
    "*$5=JudyLCount(*$1,$2,$3,$4);";

  proc JudyLByCount: JLArray * word * ptr[word] * JError_t * ptr[ptr[word]] = 
    "*$5=JudyLCount(*$1,$2,$3,$4);";

  proc JudyLFreeArray: JLArray * JError_t * ptr[word] = 
    "*$3=JudyLFree($1,$2);";

  proc JudyLMemUsed: JLArray * ptr[word] = 
    "*$2=JudyLMemUsed(*$1);";

  proc JudyLFirst: JLArray * ptr[word] * JError_t * ptr[ptr[word]] = 
    "*(Word_t**)$4=(Word_t*)JudyLFirst(*$1,$2,$3);";

  proc JudyLNext: JLArray * ptr[word] * JError_t * ptr[ptr[word]] = 
    "*(Word_t**)$4=(Word_t*)JudyLNext(*$1,$2,$3);";

  proc JudyLLast: JLArray * ptr[word] * JError_t * ptr[ptr[word]] = 
    "*$4=JudyLLast(*$1,$2,$3);";

  proc JudyLPrev: JLArray * ptr[word] * JError_t * ptr[ptr[word]] = 
    "*$4=JudyLPrev(*$1,$2,$3);";

  proc JudyLFirstEmpty: JLArray * ptr[word] * JError_t * ptr[word] = 
    "*$4=JudyLFirstEmpty(*$1,$2,$3);";

  proc JudyLNextEmpty: JLArray * ptr[word] * JError_t * ptr[word] = 
    "*$4=JudyLNextEmpty(*$1,$2,$3);";

  proc JudyLLastEmpty: JLArray * ptr[word] * JError_t * ptr[word] = 
    "*$4=JudyLLastEmpty(*$1,$2,$3);";

  proc JudyLPrevEmpty: JLArray * ptr[word] * JError_t * ptr[word] = 
    "*$4=JudyLPrevEmpty(*$1,$2,$3);";

  type JHSArray = "void**";
  gen _ctor_JHSArray: 1 -> JHSArray = "_mkjHS()" requires body 
   """
     void **_mkjHS(){
       void **m =(void**)malloc(sizeof(void*));
       *m=0;
       return m;
     }
   """;

  proc free: JHSArray = "_jHSfree($1);" requires body
    """
      void _jHSfree(void **p) { JudyHSFreeArray(p); free(p); }
    """;

  proc JudyHSIns: JHSArray * address * word * JError_t * ptr[ptr[word]] = 
    "*$5=(Word_t*)JudyHSIns($1,$2,$3,$4);";

  proc JudyHSDel: JHSArray * address * word * JError_t * ptr[int] = 
    "*$5=JudyHSDel($1,$2,$3,$4);";

  proc JudyHSGet: JHSArray * address * word * JError_t * ptr[ptr[word]] = 
    "*$5=(Word_t*)JudyHSGet(*$1,$2,$3);";

}

@env.head(1, 'judy tests')
@select(env.test('.flx'))

#import <flx.flxh>
include "judy";
open Judy;
open C_hack;

gen _ctor_address : string -> address = "(void*)$1.data()";

val je = JError_t();
var ires : int;
var pires = addr ires;
var wres : word;
var pwres = addr wres;
{
  val ja = J1Array();
  Judy1Set(ja,word 1,je,pires);
  print "1 was unset="; println$ ires;

  Judy1Set(ja,word 1,je,pires);
  print "1 was unset="; println$ ires;

  Judy1Set(ja,word 9,je,pires);
  print "9 was unset="; println$ ires;
  Judy1Set(ja,word 7,je,pires);
  print "7 was unset="; println$ ires;
  Judy1Set(ja,word 23,je,pires);
  print "23 was unset="; println$ ires;
  Judy1Set(ja,word 7,je,pires);
  print "7 was unset="; println$ ires;

  var i : int;
  forall i in 0 upto 10 do
    Judy1Test(ja,word i,je,pires);
    print i; print " isset="; println$ ires;
  done;


  Judy1Count(ja,word 0,word 10,je,pwres);
  print "count="; println$ int wres;

  var curr: word = word 0;
  var pcurr= addr curr;
  Judy1First(ja,pcurr,je,pires);
  print "First="; println$ ulong curr;
  print "res="; println$ ires;
  Judy1Next(ja,pcurr,je,pires);
  print "Next="; println$ int curr;
  print "res="; println$ ires;
  Judy1Next(ja,pcurr,je,pires);
  print "Next="; println$ int curr;
  print "res="; println$ ires;
  Judy1Next(ja,pcurr,je,pires);
  print "Next="; println$ int curr;
  print "res="; println$ ires;


  println "Done J1";
};

{
  val ja = JLArray();
  var pv : ptr[word]; // pointer to space in the array to put value
  var ppv = addr pv;
  JudyLIns(ja,word 1,je,ppv);
  *pv = word 11;
  JudyLIns(ja,word 7,je,ppv);
  *pv = word 77;
  JudyLIns(ja,word 23,je,ppv);
  *pv = word 2323;

  JudyLGet(ja,word 1,je,ppv);
  print "1->"; println$ int$ *pv;

  JudyLGet(ja,word 23,je,ppv);
  print "23->"; println$ int$ *pv;

  JudyLGet(ja,word 7,je,ppv);
  print "7->"; println$ int$ *pv;

  JudyLCount(ja,word 0,word 10,je,pwres);
  print "Count="; println$ int wres;

  var i : int;
  forall i in 0 upto 10 do
    JudyLGet(ja,word i,je,ppv);
    print i; 
    if isNULL pv do
      println " --> NOT STORED";
    else
      print " --> ";
      println$ ulong$ *pv;
    done;
  done;

  var curr: word = word 0;
  var pcurr= C_hack::addr curr;
  JudyLFirst(ja,pcurr,je,ppv);
  print "First="; print$ int curr; print " -> "; println$ int$ *pv;

  JudyLNext(ja,pcurr,je,ppv);
  print "Next="; print$ int curr; print " -> "; println$ int$ *pv;


  println "Done JL";
};

{
  val ja = JHSArray();
  var pv : ptr[word]; // pointer to space in the array to put value
  var ppv = addr pv;

  s1 := "Hello";
  JudyHSIns(ja,address s1,word (len s1),je, ppv);
  *pv = word 101;

  s2 := "World";
  JudyHSIns(ja,address s2,word (len s2),je,ppv);
  *pv = word 22;

  s3 := "Silly";
  JudyHSIns(ja,address s3,word (len s3),je,ppv);
  *pv = word 303;

  JudyHSGet(ja,address s2, word (len s2),je, ppv);
  println$ "s2 -> " + str (int(*pv));
};

@select(env.expect())
1 was unset=1
1 was unset=0
9 was unset=1
7 was unset=1
23 was unset=1
7 was unset=0
0 isset=0
1 isset=1
2 isset=0
3 isset=0
4 isset=0
5 isset=0
6 isset=0
7 isset=1
8 isset=0
9 isset=1
10 isset=0
count=3
First=1
res=1
Next=7
res=1
Next=9
res=1
Next=23
res=1
Done J1
1->11
23->2323
7->77
Count=2
0 --> NOT STORED
1 --> 11
2 --> NOT STORED
3 --> NOT STORED
4 --> NOT STORED
5 --> NOT STORED
6 --> NOT STORED
7 --> 77
8 --> NOT STORED
9 --> NOT STORED
10 --> NOT STORED
First=1 -> 11
Next=7 -> 77
Done JL
s2 -> 22
@doc()

@select(env.test('.flx'))
// test Judy1
#import <flx.flxh>

include "judy";
open Judy;
open C_hack;		// ptr...

print "judyable\n";

var j1 = J1Array();  // new bit array, all zero
var je = JError_t(); // for error info

var res: int;
var pres = ptr res;
Judy1Set(j1, word(1977), je, pres);

Judy1Test(j1, word(1977), je, pres);
print res; endl;

Judy1Test(j1, word(1978), je, pres);
print res; endl;

Judy1Set(j1, word(1000000009), je, pres);

var first: word;
var last: word;
var n: word;

Judy1First(j1, ptr(first), je, pres);
Judy1Last(j1, ptr(last), je, pres);		// seems to give max uint
//print "first="; print(int first); endl;
//print "last="; print(ulong last); endl;

// count 1 bits between range, returning in w.
Judy1Count(j1, first, last, je, ptr(n));
print (int n); endl;

free je;
free j1;
@doc()

@select(env.expect())
judyable
1
0
2
@doc()

