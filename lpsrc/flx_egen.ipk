@h = tangler('src/flx_egen.mli')
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_label
open Flx_ctypes

val gen_expr:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  tbexpr_t ->
  bvs_t ->
  btypecode_t list ->
  range_srcref -> string

val gen_expr':
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  tbexpr_t ->
  bvs_t ->
  btypecode_t list ->
  range_srcref -> cexpr_t

val get_var_ref:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  int ->
  btypecode_t list ->
  string

@h = tangler('src/flx_egen.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_name
open Flx_tgen
open Flx_unify
open Flx_csubst
open Flx_exceptions
open Flx_display
open List
open Flx_generic
open Flx_label
open Flx_unravel
open Flx_ogen
open Flx_ctypes
open Flx_cexpr
open Flx_maps
open Flx_pgen

let string_of_string = Flx_string.c_quote_of_string

(* HACKERY: this assumes library dependent things:
  but we can't add literals in the library code :-(
*)
let csuffix_of_type s = match s with
  | "tiny" -> ""
  | "short" -> ""
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "ll"
  | "utiny" -> "u"
  | "ushort" -> "u"
  | "uint" -> "u"
  | "ulong" -> "lu"
  | "uvlong" -> "llu"
  | "int8" -> ""
  | "int16" -> ""
  | "int32" -> "l"
  | "int64" -> "ll"
  | "uint8" -> "u"
  | "uint16" -> "u"
  | "uint32" -> "lu"
  | "uint64" -> "llu"
  | "double" -> ""
  | "float" -> "f"
  | "ldouble" -> "l"
  | _ -> failwith ("[csuffix_of_type]: Unexpected Type " ^ s)

let cstring_of_literal e = match e with
  | `AST_int (s,i) -> (Big_int.string_of_big_int i)^csuffix_of_type s 
  | `AST_float (s,x) -> x ^ csuffix_of_type s
  | `AST_string s -> string_of_string s
  | `AST_cstring s -> string_of_string s
  | `AST_wstring s -> "L" ^ string_of_string s
  | `AST_ustring s -> "L" ^ string_of_string s

(* a native literal is one not needing a cast to get the type right *)
let is_native_literal e = match e with
  | `AST_int ("int",_) 
  | `AST_int ("long",_) 
  | `AST_int ("uint",_) 
  | `AST_int ("ulong",_) 
  | `AST_int ("vlong",_) 
  | `AST_int ("uvlong",_) 
  | `AST_float ("double",_) -> true
  | _ -> false

let get_var_frame syms bbdfns this index ts : string =
  match 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_var_frame(1)] Can't find index " ^ si index)
  with (id,parent,sr,entry) -> 
  match entry with
  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t) ->
    begin match parent with
    | None -> "0"
    | Some i ->
      if i <> this
      then "ptr" ^ cpp_instance_name syms bbdfns i ts
      else "this"
    end
  | `BBDCL_tmp (vs,t) ->
     failwith ("[get_var_frame] temporaries aren't framed: " ^ id)
     
  | _ -> failwith ("[get_var_frame] Expected name "^id^" to be variable or value")

let get_var_ref syms bbdfns this index ts : string =
  match 
    try Hashtbl.find bbdfns index 
    with _ -> failwith ("[get_var_ref] Can't find index " ^ si index)
  with (id,parent,sr,entry) ->
  (*
  print_endline ("get var ref for " ^ id ^ "<" ^ si index ^ ">["^catmap "," (string_of_btypecode syms.dfns) ts^"]");
  *)
  match entry with
  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t) ->
    begin match parent with
    | None -> (* print_endline "No parent ...?"; *)
      "PTF " ^ cpp_instance_name syms bbdfns index ts
    | Some i -> 
      (*
      print_endline ("Parent " ^ si i);
      *)
      (
        if i <> this 
        then "ptr" ^ cpp_instance_name syms bbdfns i ts ^ "->" 
        else ""
      ) ^
      cpp_instance_name syms bbdfns index ts
    end

  | `BBDCL_tmp (vs,t) ->
      cpp_instance_name syms bbdfns index ts

  | _ -> failwith ("[get_var_ref(3)] Expected name "^id^" to be variable, value or temporary")

let nth_type ts i = match ts with
  | `BTYP_tuple ts -> nth ts i
  | `BTYP_array (t,`BTYP_unitsum n) -> assert (i<n); t
  | _ -> assert false

let rec gen_expr' syms bbdfns this (e,t) vs ts sr : cexpr_t =

  (*
  print_endline ("Generating expression " ^ string_of_bound_expression_with_type syms.dfns (e,t));
  *)
  let ge' e = gen_expr' syms bbdfns this e vs ts sr in
  let ge e = gen_expr syms bbdfns this e vs ts sr in
  let ge'' sr e = gen_expr' syms bbdfns this e vs ts sr in
  if length ts <> length vs then 
  failwith 
  (
    "[gen_expr} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let tsub t = reduce_type (tsubst vs ts t) in
  let tn t = cpp_typename syms (tsub (lower t)) in
  let raw_typename t = cpp_typename syms (tsubst vs ts (lower t)) in
  let ge_arg ((x,t) as a) = 
    let t = reduce_type (tsubst vs ts (lower t)) in
    match t with
    | `BTYP_tuple [] -> ""
    | _ -> ge a
  in
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns this 
    with _ -> failwith ("[gen_expr] Can't find this = " ^ si this)
  in
  let our_display = get_display_list bbdfns this in
  let our_level = length our_display in
  let rt t = reduce_type (lstrip syms.dfns (tsub t)) in
  let t = rt t in
  match t with
  | `BTYP_tuple [] -> ce_atom ("UNIT_ERROR")
  | _ ->
  match e with
  | `BEXPR_parse ((_,t')as e,ii) -> 
    let pn = Hashtbl.find syms.parsers (this,t',ii) in
    let ln = Hashtbl.find syms.lexers (this,e) in
    let the_display = 
      "this"::
      map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
      our_display
    in

    let pdisplay = strd the_display in
    let ldisplay = strd (the_display @[ge e]) in
    let callstr = 
    "(Elk_" ^ si pn ^ pdisplay ^
    ".apply((new ElkLex_" ^ si ln^ldisplay^")->init()))"
    in
      (*
      print_endline ("Parse call : " ^ callstr);
      *)
      ce_atom callstr

  | `BEXPR_expr (s,_) -> ce_top s

  | `BEXPR_case_index e ->
    let _,t = e in
    let t = lstrip syms.dfns t in
    begin match t with
    | `BTYP_sum _
    | `BTYP_unitsum _ ->
      if is_unitsum t then ge' e
      else ce_dot (ge' e) "variant"
    | `BTYP_inst (i,ts) ->
      let ts = map tsub ts in
      let id,_,_,entry = Hashtbl.find bbdfns i in
      begin match entry with
      | `BBDCL_union (bvs,cts) ->
        let tsub' t = reduce_type (tsubst bvs ts t) in
        let cts = map (fun (_,t) -> tsub' t) cts in
        if all_voids cts then ge' e
        else ce_dot (ge' e) "variant"
      | _ -> failwith ("Woops expected union, got " ^ id)
      end 
    | _ -> failwith ("Woops expected union or sum, got " ^ sbt syms.dfns t)
    end

  | `BEXPR_get_n (n,(e',t as e)) -> 
    begin match rt t with
    | `BTYP_array (_,`BTYP_unitsum _) -> 
      ce_dot (ge' e) ("data["^si n^"]")
    | _ -> ce_dot (ge' e) ("mem_" ^ si n)
    end

  | `BEXPR_match_case (n,((e',t') as e)) -> 
    let t' = reduce_type (lstrip syms.dfns t') in
    if is_unitsum t' then
      ce_infix "==" (ge' e) (ce_atom (si (n-1)))
    else
      ce_infix "==" 
      (ce_dot (ge' e) "variant")
      (ce_atom (si (n-1)))

  | `BEXPR_case_arg (n,e) ->
    let cast = tn t ^ "*" in
    ce_prefix "*" (ce_cast cast (ce_dot (ge' e) "data"))
     
  | `BEXPR_deref ((`BEXPR_ref index),`BTYP_pointer t) -> 
    ge' (`BEXPR_name index,t)

  | `BEXPR_deref e -> 
    let cast = tn t ^ "*" in
    ce_prefix "*" (ce_cast cast (ce_dot (ge' e) "data"))

  | `BEXPR_literal v ->
    if is_native_literal v
    then ce_atom (cstring_of_literal v)
    else
    let t = tn t in
    ce_atom (t ^ "(" ^ cstring_of_literal v ^ ")")
    
  | `BEXPR_case (v,t') ->
    begin match unfold syms.dfns t' with
    | `BTYP_unitsum n ->
      if v<1 or v>n
      then 
        failwith 
        (
          "Invalid case index " ^ si v ^
          " of " ^ si n ^ " cases  in unitsum"
        )
     else ce_atom (si (v-1))

    | `BTYP_sum ls ->
       let s = 
         let n = length ls in
         if v<1 or v>n
         then 
           failwith 
           (
             "Invalid case index " ^ si v ^
             " of " ^ si n ^ " cases"
           )
         else let t' = nth ls (v-1) in
         if t' = `BTYP_tuple []
         then (* closure of const ctor is just the const value ???? *)
           if is_unitsum t then
             si (v-1)
           else
             "_uctor_(" ^ si (v-1) ^ ",0)"
         else 
           failwith 
           ( 
              "Can't handle closure of case " ^ 
              si v ^ 
              " of " ^
              string_of_btypecode syms.dfns t
           )
       in ce_atom s
       (* "(" ^ tn (lower t) ^ "*)_uctor_" *)

    | _ -> failwith "Case tag must have sum type"
    end 
   
  | `BEXPR_name (index,ts') -> 
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> 
        match Hashtbl.find syms.dfns index with
        {id=id; sr=sr} -> syserr sr
        ("[gen_expr(name)] Can't find "^ id ^ "<" ^ si index ^ ">")
    in
    let ts = map tsub ts' in
    begin match entry with
      | `BBDCL_var (_,t)
      | `BBDCL_val (_,t) 
      | `BBDCL_tmp (_,t) 
        ->
          ce_atom (get_var_ref syms bbdfns this index ts)

      | `BBDCL_const (_,_,ct,_) -> 
        let ts = map tn ts in
        csubst sr sr2 ct [] [] "Error" "Error" ts "expr" "Error" ["Error"]

      | `BBDCL_cstruct _ 
      | `BBDCL_struct _ 
      | `BBDCL_reglex _
      | `BBDCL_regmatch _
      | `BBDCL_function _
      | `BBDCL_procedure _ 
      | `BBDCL_fun _
      | `BBDCL_proc _ ->
         syserr sr
         (
           "[gen_expr: name] Open function '" ^ 
           id ^ "'<"^si index^
           "> in expression (closure required)"
         )
      | _ -> 
        syserr sr
        (
          "[gen_expr: name] Cannot use this kind of name '"^
          id^"' in expression"
        )
    end

  | `BEXPR_closure (index,ts') -> 
    let id,parent,sr,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    (*
    Should not be needed now .. 
    let ts = adjust_ts syms index ts' in
    *)
    let ts = map tsub ts' in
    begin match entry with
    | `BBDCL_function _ 
    | `BBDCL_procedure _ ->
      let the_display = 
        let d' = 
          map (fun (i,vslen) -> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")" ^ strd the_display ^")"
      )

    | `BBDCL_cstruct _ 
    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith ("[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression")
    end

  | `BEXPR_ref (index,ts') -> 
    let ts = map tsub ts' in
    let t = lower t in
    let ref_type = tn (lower t) in
    let var_ptr = "&" ^ get_var_ref syms bbdfns this index ts  in
    let frame_ptr = get_var_frame syms bbdfns this index ts in
    let reference = ref_type ^ 
      "(" ^ frame_ptr ^ ", " ^ var_ptr ^ ")" 
    in
    ce_atom reference

  (* Hackery -- we allow a constructor with no
     arguments to be applied to a unit anyhow
  *)
  | `BEXPR_apply 
     (
       (`BEXPR_case (v,t),t'),
       (a,t'') 
     ) ->
       (* t is the type of the sum, 
          t' is the function type of the constructor,
          t'' is the type of the argument
       *)
       let 
         arg_typename = tn (lower t'') 
       and
         union_typename = tn (lower t)
       in
       let aval = 
         "new (gc, "^arg_typename^"_ptr_map) " ^
         arg_typename ^ "(" ^ ge_arg (a,t'') ^ ")"
       in
       let uval = 
         if is_unitsum t then
           si (v-1) 
         else
         "_uctor_(" ^ si (v-1) ^ ", " ^ aval ^")" 
       in
       let s = "(" ^ union_typename ^ ")" ^ uval in
       ce_atom s

       (*
       failwith 
       (
         "Trapped application, case " ^ 
         si v ^
         " of " ^ string_of_btypecode syms.dfns t ^
         "\ntype " ^ string_of_btypecode syms.dfns t' ^
         "\nargument=" ^ 
         string_of_bound_expression syms.dfns (a,t'') ^
         "\ntype " ^ string_of_btypecode syms.dfns t''
       )
      *) 


  | `BEXPR_apply_prim (index,ts,(arg,argt as a)) ->
    let argt = tsub argt in
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    match entry with
    | `BBDCL_fun (vs,ps,retyp,ct,_,prec) -> 
      if length vs <> length ts then
      failwith 
      (
        "[get_expr:apply closure of fun] function " ^ 
        id ^ "<" ^ si index ^">" ^
        ", wrong number of args, expected vs = " ^ 
        si (length vs) ^ 
        ", got ts=" ^ 
        si (length ts)
      );
      let ts = map tsub ts in
      let retyp = reduce_type (lstrip syms.dfns (tsubst vs ts retyp)) in
      let retyp = tn retyp in
      gen_prim_call syms bbdfns tsub ge'' ct ts (arg,argt) retyp sr sr2 prec

    (* not sure whether these will be prims or directs or what .. *)
    | `BBDCL_cstruct (vs,_) ->
      ce_atom ("reinterpret<"^ id ^">(" ^ ge a ^ ")")
       
    (* not sure whether these will be prims or directs or what .. *)
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then
        (* argument must be an lvalue *)
       ce_atom ("reinterpret<"^ name ^">(" ^ ge a ^ ")")
      else if length cts = 0 then
        ce_atom (name ^ "()")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    (* but can't be a Felix function *)
    | _ -> 
      failwith 
      (
        "[gen_expr: apply prim] Expected '"^id^"' to be primitive function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply_direct (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_regmatch _
    | `BBDCL_reglex _
    | `BBDCL_function _ ->
      let ts = map tsub ts in
      let the_display = 
        let d' = 
          map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")"^ strd the_display ^")"^
      "\n      ->apply(" ^ ge_arg a ^ ")"
      )

    | `BBDCL_cstruct (vs,_) ->
      ce_atom ("reinterpret<"^ id ^">(" ^ ge a ^ ")")
       
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then 
        (* argument must be an lvalue *)
        ce_atom ("reinterpret<"^ name ^">(" ^ ge a ^ ")")
      else if length cts = 0 then
        ce_atom (name ^ "()")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    | `BBDCL_fun _ ->
      ge' (`BEXPR_apply_prim (index,ts,a),t)

    | `BBDCL_nonconst_ctor (vs,uidx,udt,cidx,ct) ->
      let ts = map tsub ts in
      let ct = reduce_type (tsubst vs ts ct) in
      let ctt = tn ct in
      let ptrmap = shape_of bbdfns tn ct in 
      ce_atom (
        "(_uctor_(" ^ si cidx ^ ", new(gc,"^ ptrmap^")"^
        ctt ^"("^ ge a ^")))"
      )
    
    | _ -> 
      failwith 
      (
        "[gen_expr: apply_direct] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply_stack (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_function (props,vs,ps,retyp,_) ->
      let ts = map tsub ts in
      let display = get_display_list bbdfns index in
      let name = cpp_instance_name syms bbdfns index ts in

      (* C FUNCTION CALL *)
      if mem `Pure props && not (mem `Heap_closure props) then
        let s = 
          assert (length display = 0);
          match ps with
          | [] -> ""
          | [_,(_,t)] -> 
            ge_arg a

          | _ ->
            begin match a with
            | `BEXPR_tuple xs,_ ->
              fold_left 
              (fun s ((x,t) as xt) ->
                let x = ge_arg xt in
                if String.length x = 0 then s else
                s ^ 
                (if String.length s > 0 then ", " else "") ^ (* append a comma if needed *)
                x
              )
              ""
              xs

            | _,tt ->
              let tt = reduce_type (lstrip syms.dfns (tsubst vs ts tt)) in
              (* NASTY, EVALUATES EXPR MANY TIMES .. *)
              let n = ref 0 in
              fold_left
              (fun s i -> 
                (*
                print_endline ( "ps = " ^ catmap "," (fun (id,(p,t)) -> id) ps);
                print_endline ("tt=" ^ sbt syms.dfns tt);
                *)
                let t = nth_type tt i in
                let a' = `BEXPR_get_n (i,a),t in
                let x = ge_arg a' in
                incr n;
                if String.length x = 0 then s else
                s ^ (if String.length s > 0 then ", " else "") ^ x
              ) 
              ""
              (nlist (length ps))
            end
        in 
        let s = 
          if String.length s > 0 then "FLX_FPAR_PASS " ^ s 
          else "FLX_FPAR_PASS_ONLY"
        in 
          ce_atom (name ^ "(" ^ s ^ ")")
      else
        let the_display = 
          let d' = 
            map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
            display
          in 
            if length d' > our_level
            then "this" :: tl d'
            else d'
        in
        let s = 
          name^ strd the_display 
          ^
          "\n      .apply(" ^ ge_arg a ^ ")"
        in ce_atom s

    | `BBDCL_cstruct (vs,_) ->
      ce_atom ("reinterpret<"^ id ^">(" ^ ge a ^ ")")
       
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then
        (* argument must be an lvalue *)
        ce_atom ("reinterpret<"^ name ^">(" ^ ge a ^ ")")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    | _ -> 
      failwith 
      (
        "[gen_expr: apply_direct] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply ((`BEXPR_closure (index,ts),_),a) ->
    assert false (* should have been factored out *)

  (* General application*)
  | `BEXPR_apply (f,a) ->
    ce_atom (
    (ge f) ^ "->clone()\n      ->apply(" ^ ge_arg a ^ ")"
    )

  | `BEXPR_tuple es ->
    (* just apply the tuple type ctor to the arguments *)
    begin match t with
    | `BTYP_array (t',`BTYP_unitsum n) ->
      let tuple = 
        let t'' = `BTYP_tuple (map (fun _ -> t') (nlist n)) in
        let ctyp = raw_typename t'' in
        ce_atom (
        ctyp ^ "(" ^
          fold_left
          (fun s e ->
            let x = ge_arg e in
            if String.length x = 0 then s else
            s ^ 
            (if String.length s > 0 then ", " else "") ^
            x
          )
          ""
          es
        ^
        ")"
        )
      in
        (* cast a tuple which is an array type to an array *)
        let atyp = tn (lower t) in
        ce_call 
          (ce_atom ("reinterpret<" ^ atyp ^">"))
          [tuple]

    | `BTYP_tuple _ ->
      let ctyp = tn (lower t) in
      ce_atom (
      ctyp ^ "(" ^
        fold_left
        (fun s e ->
          let x = ge_arg e in
          if String.length x = 0 then s else
          s ^ 
          (if String.length s > 0 then ", " else "") ^
          x
        )
        ""
        es
      ^
      ")"
      )
    | _ -> assert false
    end

and gen_expr syms bbdfns this e vs ts sr =
  let e = Flx_maps.reduce_tbexpr bbdfns e in
  let s = 
    try gen_expr' syms bbdfns this e vs ts sr  
    with Unknown_prec p -> clierr sr 
    ("[gen_expr] Unknown precedence name '"^p^"' in " ^ sbe syms.dfns e)
  in
  string_of_cexpr s


