@h = tangler('src/flx_egen.mli')
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_label
open Flx_ctypes

val gen_expr:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  tbexpr_t ->
  bvs_t ->
  btypecode_t list ->
  range_srcref -> string

val gen_expr':
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  tbexpr_t ->
  bvs_t ->
  btypecode_t list ->
  range_srcref -> cexpr_t

val get_var_ref:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  int ->
  int ->
  btypecode_t list ->
  string

@h = tangler('src/flx_egen.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_name
open Flx_tgen
open Flx_unify
open Flx_csubst
open Flx_exceptions
open Flx_display
open List
open Flx_generic
open Flx_label
open Flx_unravel
open Flx_ogen
open Flx_ctypes
open Flx_cexpr
open Flx_maps
open Flx_pgen
open Flx_beta

let string_of_string = Flx_string.c_quote_of_string

(* HACKERY: this assumes library dependent things:
  but we can't add literals in the library code :-(
*)
let csuffix_of_type s = match s with
  | "tiny" -> ""
  | "short" -> ""
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "ll"
  | "utiny" -> "u"
  | "ushort" -> "u"
  | "uint" -> "u"
  | "ulong" -> "ul"
  | "uvlong" -> "ull"
  | "int8" -> ""
  | "int16" -> ""
  | "int32" -> "l"
  | "int64" -> "ll"
  | "uint8" -> "u"
  | "uint16" -> "u"
  | "uint32" -> "ul"
  | "uint64" -> "ull"
  | "double" -> ""
  | "float" -> "f"
  | "ldouble" -> "l"
  | _ -> failwith ("[csuffix_of_type]: Unexpected Type " ^ s)

let cstring_of_literal e = match e with
  | `AST_int (s,i) -> (Big_int.string_of_big_int i)^csuffix_of_type s 
  | `AST_float (s,x) -> x ^ csuffix_of_type s
  | `AST_string s -> string_of_string s
  | `AST_cstring s -> string_of_string s
  | `AST_wstring s -> "L" ^ string_of_string s
  | `AST_ustring s -> "L" ^ string_of_string s

(* a native literal is one not needing a cast to get the type right *)
let is_native_literal e = match e with
  | `AST_int ("int",_) 
  | `AST_int ("long",_) 
  | `AST_int ("uint",_) 
  | `AST_int ("ulong",_) 
  | `AST_int ("vlong",_) 
  | `AST_int ("uvlong",_) 
  | `AST_float ("double",_) -> true
  | _ -> false

let get_var_frame syms bbdfns this index ts : string =
  match 
    try Hashtbl.find bbdfns index 
    with Not_found -> failwith ("[get_var_frame(1)] Can't find index " ^ si index)
  with (id,parent,sr,entry) -> 
  match entry with
  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t) ->
    begin match parent with
    | None -> "0"
    | Some i ->
      if i <> this
      then "ptr" ^ cpp_instance_name syms bbdfns i ts
      else "this"
    end
  | `BBDCL_tmp (vs,t) ->
     failwith ("[get_var_frame] temporaries aren't framed: " ^ id)
     
  | _ -> failwith ("[get_var_frame] Expected name "^id^" to be variable or value")

let get_var_ref syms bbdfns this index ts : string =
  match 
    try Hashtbl.find bbdfns index 
    with Not_found -> failwith ("[get_var_ref] Can't find index " ^ si index)
  with (id,parent,sr,entry) ->
  (*
  print_endline ("get var ref for " ^ id ^ "<" ^ si index ^ ">["^catmap "," (string_of_btypecode syms.dfns) ts^"]");
  *)
  match entry with
  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t) ->
    begin match parent with
    | None -> (* print_endline "No parent ...?"; *)
      "PTF " ^ cpp_instance_name syms bbdfns index ts
    | Some i -> 
      (*
      print_endline ("Parent " ^ si i);
      *)
      (
        if i <> this 
        then "ptr" ^ cpp_instance_name syms bbdfns i ts ^ "->" 
        else ""
      ) ^
      cpp_instance_name syms bbdfns index ts
    end

  | `BBDCL_tmp (vs,t) ->
      cpp_instance_name syms bbdfns index ts

  | _ -> failwith ("[get_var_ref(3)] Expected name "^id^" to be variable, value or temporary")

let nth_type ts i = match ts with
  | `BTYP_tuple ts -> nth ts i
  | `BTYP_array (t,`BTYP_unitsum n) -> assert (i<n); t
  | _ -> assert false

let rec gen_expr' syms bbdfns this (e,t) vs ts sr : cexpr_t =
  (*
  print_endline ("Generating expression " ^ string_of_bound_expression_with_type syms.dfns (e,t));
  *)
  let ge' e = gen_expr' syms bbdfns this e vs ts sr in
  let ge e = gen_expr syms bbdfns this e vs ts sr in
  let ge'' sr e = gen_expr' syms bbdfns this e vs ts sr in
  if length ts <> length vs then 
  failwith 
  (
    "[gen_expr} wrong number of args, expected vs = " ^ 
    si (length vs) ^ 
    ", got ts=" ^ 
    si (length ts)
  );
  let tsub t = reduce_type (beta_reduce syms [] (tsubst vs ts t)) in
  let tn t = cpp_typename syms (tsub (lower t)) in

  (* NOTE this function does not do a reduce_type *)
  let raw_typename t = cpp_typename syms (beta_reduce syms [] (tsubst vs ts t)) in

  let ge_arg ((x,t) as a) = 
    let t = tsub t in
    match t with
    | `BTYP_tuple [] -> ""
    | _ -> ge a
  in
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns this 
    with Not_found -> failwith ("[gen_expr] Can't find this = " ^ si this)
  in
  let our_display = get_display_list bbdfns this in
  let our_level = length our_display in
  let rt t = reduce_type (beta_reduce syms [] (lstrip syms.dfns (tsubst vs ts t))) in
  let t = rt t in
  match t with
  | `BTYP_tuple [] -> 
      clierr sr 
     ("[egen] In "^sbe syms.dfns (e,t)^":\nunit value required, should have been eliminated")

     (* ce_atom ("UNIT_ERROR") *)
  | _ ->
  match e with
  | `BEXPR_parse ((_,t')as e,ii) -> 
    let pn = 
      try Hashtbl.find syms.parsers (this,t',ii) 
      with Not_found -> failwith ("[gen_expr] parse can't find parser")
    in
    let ln = 
      try Hashtbl.find syms.lexers (this,e) 
      with Not_found -> failwith ("[gen_expr] parse can't find lexer")
    in
    let the_display = 
      "this"::
      map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
      our_display
    in

    (* HACK PROPERTIES *)
    let pdisplay = strd the_display [`Requires_ptf] in
    let ldisplay = strd (the_display @[ge e]) [`Requires_ptf] in
    let callstr = 
    "(Elk_" ^ si pn ^ pdisplay ^
    ".apply((new ElkLex_" ^ si ln^ldisplay^")->init()))"
    in
      (*
      print_endline ("Parse call : " ^ callstr);
      *)
      ce_atom callstr

  | `BEXPR_expr (s,_) -> ce_top s

  | `BEXPR_case_index e ->
    let _,t = e in
    let t = lstrip syms.dfns t in
    begin match t with
    | `BTYP_sum _
    | `BTYP_unitsum _ 
    | `BTYP_variant _ ->
      if is_unitsum t then ge' e
      else ce_dot (ge' e) "variant"
    | `BTYP_inst (i,ts) ->
      let ts = map tsub ts in
      let id,_,_,entry = 
        try Hashtbl.find bbdfns i 
        with Not_found -> failwith ("[gen_expr: case_index] Can't find index " ^ si i)
      in
      begin match entry with
      | `BBDCL_union (bvs,cts) ->
        let tsub' t = reduce_type (beta_reduce syms [] (tsubst bvs ts t)) in
        let cts = map (fun (_,_,t) -> tsub' t) cts in
        if all_voids cts then ge' e
        else ce_dot (ge' e) "variant"
      | _ -> failwith ("Woops expected union, got " ^ id)
      end 
    | _ -> failwith ("Woops expected union or sum, got " ^ sbt syms.dfns t)
    end

  | `BEXPR_range_check (e1,e2,e3) ->
     let f,sl,sc,el,ec = sr in
     let f = ce_atom ("\""^ f ^"\"") in
     let sl = ce_atom (si sl) in
     let sc = ce_atom (si sc) in
     let el = ce_atom (si el) in
     let ec = ce_atom (si ec) in
     let sref = ce_call (ce_atom "flx::rtl::flx_range_srcref_t") [f;sl;sc;el;ec] in
     let cf = ce_atom "__FILE__" in
     let cl = ce_atom "__LINE__" in
     let args : cexpr_t list =
       [ ge' e1 ; ge' e2; ge' e3; sref; cf; cl]
     in 
     ce_call (ce_atom "flx::rtl::range_check") args

  | `BEXPR_get_n (n,(e',t as e)) -> 
    begin match rt t with
    | `BTYP_array (_,`BTYP_unitsum _) -> 
      ce_dot (ge' e) ("data["^si n^"]")
    | `BTYP_record es ->
       let field_name,_ = nth es n in
       ce_dot (ge' e) field_name
    | _ -> ce_dot (ge' e) ("mem_" ^ si n)
    end

  | `BEXPR_get_named (n,(e',t as e)) -> 
    (*
    print_endline "Handling get_named expression";
    *)
    begin match rt t with
    | `BTYP_inst (i,ts) -> 
      begin match
        try Hashtbl.find syms.dfns i 
        with Not_found -> assert false
      with { id=class_name; symdef=symdef } -> 
      match symdef with
      | `SYMDEF_class -> 
        begin match 
          try Hashtbl.find syms.dfns n
          with Not_found -> failwith ("Can't find class "^class_name^"member " ^ si n);
        with { id = name } ->
          let cname = cpp_instance_name syms bbdfns n ts in
          ce_arrow (ge' e) cname
        end
      | _ -> clierr sr ("[gen_expr'] Expecting "^si i^" to be class, got " ^ string_of_bbdcl syms.dfns entry i)
      end
    | _ -> assert false
    end

  | `BEXPR_match_case (n,((e',t') as e)) -> 
    let t' = reduce_type (beta_reduce syms [] (lstrip syms.dfns t')) in
    if is_unitsum t' then
      ce_infix "==" (ge' e) (ce_atom (si n))
    else
      ce_infix "==" 
      (ce_dot (ge' e) "variant")
      (ce_atom (si n))

  | `BEXPR_case_arg (n,e) ->
    let cast = tn t ^ "*" in
    ce_prefix "*" (ce_cast cast (ce_dot (ge' e) "data"))
     
  | `BEXPR_deref ((`BEXPR_ref index),`BTYP_pointer t) -> 
    ge' (`BEXPR_name index,t)

  | `BEXPR_deref e -> 
    let cast = tn t ^ "*" in
    ce_prefix "*" (ce_cast cast (ce_dot (ge' e) "get_data()"))

  | `BEXPR_literal v ->
    if is_native_literal v
    then ce_atom (cstring_of_literal v)
    else
    let t = tn t in
    ce_atom (t ^ "(" ^ cstring_of_literal v ^ ")")
    
  | `BEXPR_case (v,t') ->
    begin match unfold syms.dfns t' with
    | `BTYP_unitsum n ->
      if v < 0 or v >= n
      then 
        failwith 
        (
          "Invalid case index " ^ si v ^
          " of " ^ si n ^ " cases  in unitsum"
        )
     else ce_atom (si v)

    | `BTYP_sum ls ->
       let s = 
         let n = length ls in
         if v < 0 or v >= n
         then 
           failwith 
           (
             "Invalid case index " ^ si v ^
             " of " ^ si n ^ " cases"
           )
         else let t' = nth ls v in
         if t' = `BTYP_tuple []
         then (* closure of const ctor is just the const value ???? *)
           if is_unitsum t then
             si v
           else
             "_uctor_(" ^ si v ^ ",0)"
         else 
           failwith 
           ( 
              "Can't handle closure of case " ^ 
              si v ^ 
              " of " ^
              string_of_btypecode syms.dfns t
           )
       in ce_atom s
       (* "(" ^ tn (lower t) ^ "*)_uctor_" *)

    | _ -> failwith "Case tag must have sum type"
    end 
   
  | `BEXPR_name (index,ts') -> 
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> 
        match 
          try Hashtbl.find syms.dfns index 
          with Not_found -> assert false
        with
        {id=id; sr=sr} -> syserr sr
        ("[gen_expr(name)] Can't find "^ id ^ "<" ^ si index ^ ">")
    in
    let ts = map tsub ts' in
    begin match entry with
      | `BBDCL_var (_,t)
      | `BBDCL_val (_,t) 
      | `BBDCL_tmp (_,t) 
        ->
          ce_atom (get_var_ref syms bbdfns this index ts)

      | `BBDCL_const (_,_,ct,_) -> 
        begin match ct with
        | `Str c
        | `StrTemplate c when c = "#memcount" ->
          let ts = map (lstrip syms.dfns) ts in
          begin match ts with 
          | [`BTYP_unitsum n]
          | [`BTYP_array (_,`BTYP_unitsum n)] -> ce_atom (si n)
          | [`BTYP_sum ls]
          | [`BTYP_tuple ls] -> let n = length ls in ce_atom (si n)
          | [`BTYP_inst (i,_)] ->
            let _,_,_,entry = Hashtbl.find bbdfns i in
            begin match entry with
              | `BBDCL_struct (_,ls) -> let n = length ls in ce_atom (si n)
              | `BBDCL_cstruct (_,ls) -> let n = length ls in ce_atom (si n)
              | `BBDCL_union (_,ls) -> let n = length ls in ce_atom (si n)
              | `BBDCL_class (_,ls) -> let n = length ls in ce_atom (si n)
              | _ -> 
                clierr sr (
                  "#memcount function requires type with members to count, got: " ^ 
                  sbt syms.dfns (hd ts)
                )
            end
          | _ -> 
            clierr sr (
              "#memcount function requires type with members to count, got : " ^
              sbt syms.dfns (hd ts)
            )
          end
        | `Str c -> ce_expr "expr" c
        | `StrTemplate c ->
          let ts = map tn ts in
          csubst sr sr2 c (ce_atom "Error") [] [] "Error" "Error" ts "expr" "Error" ["Error"] ["Error"]
        end

      | `BBDCL_cstruct _ 
      | `BBDCL_struct _ 
      | `BBDCL_reglex _
      | `BBDCL_regmatch _
      | `BBDCL_function _
      | `BBDCL_procedure _ 
      | `BBDCL_fun _
      | `BBDCL_proc _ ->
         syserr sr
         (
           "[gen_expr: name] Open function '" ^ 
           id ^ "'<"^si index^
           "> in expression (closure required)"
         )
      | _ -> 
        syserr sr
        (
          "[gen_expr: name] Cannot use this kind of name '"^
          id^"' in expression"
        )
    end

  | `BEXPR_closure (index,ts') -> 
    (*
    print_endline ("Generating closure of " ^ si index);
    *)
    let id,parent,sr,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    (*
    Should not be needed now .. 
    let ts = adjust_ts syms index ts' in
    *)
    let ts = map tsub ts' in
    begin match entry with
    | `BBDCL_function (props,_,_,_,_) 
    | `BBDCL_procedure (props,_,_,_) ->
      let the_display = 
        let d' = 
          map (fun (i,vslen) -> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")" ^ strd the_display props ^")"
      )

    | `BBDCL_callback _ -> 
      print_endline "Mapping closure of callback to C function pointer";
      ce_atom id

    | `BBDCL_cstruct _ 
    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith ("[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression")
    end

  | `BEXPR_apply_method_stack (obj,meth,ts',a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns meth
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si meth)
    in
    begin 
    (*
    print_endline ("apply method closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_function (props,_,_,_,_) ->
      (*
      print_endline ("Generating closure[apply method stack] of " ^ si meth);
      *)
      let ts = map tsub ts' in
      let the_display = 
        let d' = 
          map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns meth)
        in 
          let d' = tl d' in (* throw out class pointer *)
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let class_frame = ge obj in
      let the_display = class_frame :: the_display in
      let name = cpp_instance_name syms bbdfns meth ts in
      ce_atom (
      name ^ strd the_display props ^
      "\n      .apply(" ^ ge_arg a ^ ")"
      )
    | _ ->
      failwith 
      (
        "[gen_expr: apply_method_stack] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry meth
      )
   end

  | `BEXPR_apply_method_direct (obj,meth,ts',a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns meth
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si meth)
    in
    begin 
    (*
    print_endline ("apply method closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_function (props,_,_,_,_) ->
      (*
      print_endline ("Generating closure[apply method direct] of " ^ si meth);
      *)
      let ts = map tsub ts' in
      let the_display = 
        let d' = 
          map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns meth)
        in 
          let d' = tl d' in (* throw out class pointer *)
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let class_frame = ge obj in
      let the_display = class_frame :: the_display in
      let name = cpp_instance_name syms bbdfns meth ts in
      ce_atom (
      "(FLX_NEWP("^name^")"^ strd the_display props ^")"^
      "\n      ->apply(" ^ ge_arg a ^ ")"
      )

    | _ -> 
      failwith 
      (
        "[gen_expr: apply_method_direct] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry meth
      )
    end

  | `BEXPR_method_closure (e,index,ts') -> 
    (*
    print_endline ("Generating method closure of " ^ si index);
    *)
    let id,parent,sr,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(name)] Can't find index " ^ si index)
    in
    (*
    Should not be needed now .. 
    let ts = adjust_ts syms index ts' in
    *)
    let ts = map tsub ts' in
    begin match entry with
    | `BBDCL_function (props,_,_,_,_) 
    | `BBDCL_procedure (props,_,_,_) ->
      (*
      print_endline ("Method " ^ id ^ (
        if mem `Requires_ptf props then 
          " REQUIRES PTF" else " DOES NOT REQUIRE PTF"
        )
      );
      *)
      let the_display = 
        let d' = 
          map (fun (i,vslen) -> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
        let d' = tl d' in (* throw out class pointer *)

          (*
          print_endline ("Generated display is " ^ cat ", " d');
          print_endline ("Display length = " ^ si (length d') ^ " .. our level = " ^ si our_level);
          *)

          assert (length d' >= our_level);
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      (* A method closure requires the last entry in the display
         to be the class. If we're cross calling from one
         method to another, we should automatically get the 
         parent class environment, but I'm not sure .. 
      *)
      let class_frame = ge e in
      let the_display = class_frame :: the_display in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")" ^ strd the_display props ^")"
      )

    | `BBDCL_cstruct _ 
    | `BBDCL_struct _ 
    | `BBDCL_fun _
    | `BBDCL_proc _ ->
      failwith ("[gen_expr: closure] Can't wrap primitive proc, fun, or struct '"^id^"' yet")
    | _ -> failwith ("[gen_expr: closure] Cannot use this kind of name '"^id^"' in expression")
    end

  | `BEXPR_ref (index,ts') -> 
    let ts = map tsub ts' in
    let t = lower t in
    let ref_type = tn (lower t) in
    let frame_ptr, var_ptr =
      match t with
      | `BTYP_tuple [] -> "NULL","NULL"
      | _ ->
       get_var_frame syms bbdfns this index ts,
      "&" ^ get_var_ref syms bbdfns this index ts
    in
    let reference = ref_type ^ 
      "(" ^ frame_ptr ^ ", " ^ var_ptr ^ ")" 
    in
    ce_atom reference

  (* Hackery -- we allow a constructor with no
     arguments to be applied to a unit anyhow
  *)

  | `BEXPR_variant (s,((_,t') as e)) ->
    print_endline ("Variant " ^ s);
    print_endline ("Type " ^ sbt syms.dfns t);
    let 
      arg_typename = tn t' and
      union_typename = tn t 
    in
    let aval = 
      "new (*PTF gc, "^arg_typename^"_ptr_map) " ^
      arg_typename ^ "(" ^ ge_arg e ^ ")"
    in 
    let ls = match t with
      | `BTYP_variant ls -> ls
      | _ -> failwith "[egen] Woops variant doesn't have variant type"
    in 
    let vidx = match list_assoc_index ls s with
      | Some i -> i
      | None -> failwith "[egen] Woops, variant field not in type"
    in
    print_endline ("Index " ^ si vidx);
    let uval = "_uctor_("^si vidx^"," ^ aval ^")"  in
    ce_atom uval

  | `BEXPR_coerce ((srcx,srct) as srce,dstt) ->
    let srct = lstrip syms.dfns srct in
    let vts = 
      match dstt with 
      | `BTYP_variant ls -> ls
      | _ -> syserr sr "Coerce non-variant"
    in
    begin match srcx with
    | `BEXPR_variant (s,argt) ->
      print_endline "Coerce known variant!";
      ge' (`BEXPR_variant (s,argt),t)
    | _ ->
      let i = 
        begin try 
          Hashtbl.find syms.variant_map (srct,dstt)
        with Not_found -> 
          let i = !(syms.counter) in incr (syms.counter);
          Hashtbl.add syms.variant_map (srct,dstt) i;
          i
      end
      in
      ce_atom ("_uctor_(vmap_"^si i^","^ge srce^")")
    end
  
  | `BEXPR_apply 
     (
       (`BEXPR_case (v,t),t'),
       (a,t'') 
     ) ->
       (* t is the type of the sum, 
          t' is the function type of the constructor,
          t'' is the type of the argument
       *)
       let 
         arg_typename = tn (lower t'') 
       and
         union_typename = tn (lower t)
       in
       let aval = 
         "new (*PTF gc, "^arg_typename^"_ptr_map) " ^
         arg_typename ^ "(" ^ ge_arg (a,t'') ^ ")"
       in
       let uval = 
         if is_unitsum t then
           si v 
         else
         "_uctor_(" ^ si v ^ ", " ^ aval ^")" 
       in
       let s = "(" ^ union_typename ^ ")" ^ uval in
       ce_atom s

       (*
       failwith 
       (
         "Trapped application, case " ^ 
         si v ^
         " of " ^ string_of_btypecode syms.dfns t ^
         "\ntype " ^ string_of_btypecode syms.dfns t' ^
         "\nargument=" ^ 
         string_of_bound_expression syms.dfns (a,t'') ^
         "\ntype " ^ string_of_btypecode syms.dfns t''
       )
      *) 


  | `BEXPR_apply_prim (index,ts,(arg,argt as a)) ->
    (*
    print_endline ("Prim apply, arg=" ^ sbe syms.dfns a);
    *)
    let argt = tsub argt in
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    match entry with
    | `BBDCL_fun (props,vs,ps,retyp,ct,_,prec) -> 
      if length vs <> length ts then
      failwith 
      (
        "[get_expr:apply closure of fun] function " ^ 
        id ^ "<" ^ si index ^">" ^
        ", wrong number of args, expected vs = " ^ 
        si (length vs) ^ 
        ", got ts=" ^ 
        si (length ts)
      );
      begin match ct with
      | `Str s -> ce_expr prec s
      | `StrTemplate s ->
        let ts = map tsub ts in
        let retyp = reduce_type (beta_reduce syms [] (lstrip syms.dfns (tsubst vs ts retyp))) in
        let retyp = tn retyp in
        gen_prim_call syms bbdfns tsub ge'' s ts (arg,argt) retyp sr sr2 prec
      end

    | `BBDCL_callback (props,vs,ps_cf,ps_c,_,retyp,_,_) -> 
      assert (retyp <> `BTYP_void);
      if length vs <> length ts then
      clierr sr "[gen_prim_call] Wrong number of type arguments"
      ;
      let ts = map tsub ts in
      let s = id ^ "($a)" in
      let retyp = reduce_type (beta_reduce syms [] (lstrip syms.dfns (tsubst vs ts retyp))) in
      let retyp = tn retyp in
      gen_prim_call syms bbdfns tsub ge'' s ts (arg,argt) retyp sr sr2 "atom" 

    (* but can't be a Felix function *)
    | _ -> 
      failwith 
      (
        "[gen_expr: apply prim] Expected '"^id^"' to be primitive function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply_struct (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    let ts = map tsub ts in
    begin match entry with
    | `BBDCL_cstruct (vs,_) ->
      let name = tn (`BTYP_inst (index,ts)) in
      ce_atom ("reinterpret<"^ name ^">(" ^ ge a ^ ")")
       
    | `BBDCL_struct (vs,cts) ->
      let name = tn (`BTYP_inst (index,ts)) in
      if length cts > 1 then 
        (* argument must be an lvalue *)
        ce_atom ("reinterpret<"^ name ^">(" ^ ge a ^ ")")
      else if length cts = 0 then
        ce_atom (name ^ "()")
      else
        ce_atom (name ^ "(" ^ ge a ^ ")")

    | `BBDCL_nonconst_ctor (vs,uidx,udt,cidx,ct) ->
      (* due to some hackery .. the argument of a non-const
         ctor can STILL be a unit .. prolly cause the stupid
         compiler is checking for voids for these pests,
         but units for sums .. hmm .. inconsistent!
      *)
      let ts = map tsub ts in
      let ct = reduce_type (beta_reduce syms [] (tsubst vs ts ct)) in
      let ptrmap = shape_of bbdfns tn ct in 
      let _,t = a in
      let t = reduce_type (beta_reduce syms [] (tsubst vs ts t)) in
      begin match t with
      | `BTYP_tuple [] ->
        ce_atom ( "_uctor_(" ^ si cidx ^ ", NULL)")
      | _ ->
        let ctt = tn ct in
        ce_atom (
          "_uctor_(" ^ si cidx ^ ", new(*PTF gc,"^ ptrmap^")"^
          ctt ^"("^ ge a ^"))"
        )
      end
    | _ -> assert false
    end

  | `BEXPR_apply_direct (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_regmatch (props,_,_,_,_) 
    | `BBDCL_reglex (props,_,_,_,_,_)
    | `BBDCL_function (props,_,_,_,_) ->
      (*
      print_endline ("Generating closure[apply direct] of " ^ si index);
      *)
      let ts = map tsub ts in
      let the_display = 
        let d' = 
          map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
          (get_display_list bbdfns index)
        in 
          if length d' > our_level
          then "this" :: tl d'
          else d'
      in
      let name = cpp_instance_name syms bbdfns index ts in
      ce_atom (
      "(FLX_NEWP("^name^")"^ strd the_display props ^")"^
      "\n      ->apply(" ^ ge_arg a ^ ")"
      )

    | `BBDCL_fun _ -> assert false
    (*
      ge' (`BEXPR_apply_prim (index,ts,a),t)
    *)
   
    | _ -> 
      failwith 
      (
        "[gen_expr: apply_direct] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply_stack (index,ts,a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_expr(apply instance)] Can't find index " ^ si index)
    in
    begin 
    (*
    print_endline ("apply closure of "^ id );
    print_endline ("  .. argument is " ^ string_of_bound_expression syms.dfns a);
    *)
    match entry with
    | `BBDCL_function (props,vs,(ps,traint),retyp,_) ->
      let ts = map tsub ts in
      let display = get_display_list bbdfns index in
      let name = cpp_instance_name syms bbdfns index ts in

      (* C FUNCTION CALL *)
      if mem `Pure props && not (mem `Heap_closure props) then
        let s = 
          assert (length display = 0);
          match ps with
          | [] -> ""
          | [_,(_,t)] -> 
            ge_arg a

          | _ ->
            begin match a with
            | `BEXPR_tuple xs,_ ->
              (*
              print_endline ("Arg to C function is tuple " ^ sbe syms.dfns a);
              *)
              fold_left 
              (fun s ((x,t) as xt) ->
                let x = ge_arg xt in
                if String.length x = 0 then s else
                s ^ 
                (if String.length s > 0 then ", " else "") ^ (* append a comma if needed *)
                x
              )
              ""
              xs

            | _,tt ->
              let tt = reduce_type (beta_reduce syms [] (lstrip syms.dfns (tsubst vs ts tt))) in
              (* NASTY, EVALUATES EXPR MANY TIMES .. *)
              let n = ref 0 in
              fold_left
              (fun s i -> 
                (*
                print_endline ( "ps = " ^ catmap "," (fun (id,(p,t)) -> id) ps);
                print_endline ("tt=" ^ sbt syms.dfns tt);
                *)
                let t = nth_type tt i in
                let a' = `BEXPR_get_n (i,a),t in
                let x = ge_arg a' in
                incr n;
                if String.length x = 0 then s else
                s ^ (if String.length s > 0 then ", " else "") ^ x
              ) 
              ""
              (nlist (length ps))
            end
        in 
        let s = 
          if mem `Requires_ptf props then
            if String.length s > 0 then "FLX_FPAR_PASS " ^ s 
            else "FLX_FPAR_PASS_ONLY"
          else s
        in 
          ce_atom (name ^ "(" ^ s ^ ")")
      else
        let the_display = 
          let d' = 
            map (fun (i,vslen)-> "ptr"^ cpp_instance_name syms bbdfns i (list_prefix ts vslen))
            display
          in 
            if length d' > our_level
            then "this" :: tl d'
            else d'
        in
        let s = 
          name^ strd the_display props
          ^
          "\n      .apply(" ^ ge_arg a ^ ")"
        in ce_atom s

    | _ -> 
      failwith 
      (
        "[gen_expr: apply_stack] Expected '"^id^"' to be generic function instance, got:\n" ^
        string_of_bbdcl syms.dfns entry index 
      )
    end

  | `BEXPR_apply ((`BEXPR_closure (index,ts),_),a) ->
    assert false (* should have been factored out *)

  (* General application*)
  | `BEXPR_apply (f,a) ->
    ce_atom (
    (ge f) ^ "->clone()\n      ->apply(" ^ ge_arg a ^ ")"
    )

  | `BEXPR_record es ->
    let rcmp (s1,_) (s2,_) = compare s1 s2 in
    let es = sort rcmp es in
    let es = map snd es in
    let ctyp = tn (lower t) in
    ce_atom (
    ctyp ^ "(" ^
      fold_left
      (fun s e ->
        let x = ge_arg e in
        if String.length x = 0 then s else
        s ^ 
        (if String.length s > 0 then ", " else "") ^
        x
      )
      ""
      es
    ^
    ")"
    )

  | `BEXPR_tuple es ->
    (*
    print_endline ("Eval tuple " ^ sbe syms.dfns (e,t));
    *)
    (* just apply the tuple type ctor to the arguments *)
    begin match t with
    | `BTYP_array (t',`BTYP_unitsum n) ->
      let tuple = 
        let t'' = `BTYP_tuple (map (fun _ -> t') (nlist n)) in
        let ctyp = raw_typename t'' in
        ce_atom (
        ctyp ^ "(" ^
          fold_left
          (fun s e ->
            let x = ge_arg e in
            if String.length x = 0 then s else
            s ^ 
            (if String.length s > 0 then ", " else "") ^
            x
          )
          ""
          es
        ^
        ")"
        )
      in
        (* cast a tuple which is an array type to an array *)
        let atyp = tn (lower t) in
        ce_call 
          (ce_atom ("reinterpret<" ^ atyp ^">"))
          [tuple]

    | `BTYP_tuple _ ->
      let ctyp = tn (lower t) in
      ce_atom (
      ctyp ^ "(" ^
        fold_left
        (fun s e ->
          let x = ge_arg e in
          if String.length x = 0 then s else
          s ^ 
          (if String.length s > 0 then ", " else "") ^
          x
        )
        ""
        es
      ^
      ")"
      )
    | _ -> assert false
    end

and gen_expr syms bbdfns this e vs ts sr =
  let e = Flx_maps.reduce_tbexpr bbdfns e in
  let s = 
    try gen_expr' syms bbdfns this e vs ts sr  
    with Unknown_prec p -> clierr sr 
    ("[gen_expr] Unknown precedence name '"^p^"' in " ^ sbe syms.dfns e)
  in
  string_of_cexpr s


