@head(1,"Name Binding: types")
Name binding, pass 1.

@h = tangler("src/flx_tbind.mli")
@select(h)
open Flx_types
val bind_type:
  symbol_table_t ->
  env_t ->
  int list ->
  typecode_t ->
  btypecode_t

@h = tangler("src/flx_tbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open List
open Flx_overload
open Flx_lookup
open Flx_srcref

let get_data table index : symbol_data_t = 
  try Hashtbl.find table index
  with Not_found -> 
    failwith ("[Flx_tbind.get_data] No definition of <" ^ string_of_int index ^ ">")

 
let rec bind_type dfns env exclude t : btypecode_t =
  let bt t = bind_type dfns env exclude t in
  let dummy_sr = ("type binding",0,0,0,0) in
  let lu qn = lookup_qn_in_env dfns env dummy_sr qn in
  match t with
  | TYP_name qn ->
    let index = match lu qn with
      | NonFunctionEntry index -> index
      | FunctionEntry _ -> 
        failwith 
        (
          "[bind_types] Expected "^
          string_of_qualified_name qn^
          " to be a type, got function overload set"
        )
    in
    if List.mem index exclude 
    then failwith (
      "Recursive type alias " ^
      (
        match get_data dfns index with id,sr,_,_ -> 
          id ^ " defined at " ^
          short_string_of_src sr
      )
    )
    else begin match get_data dfns index with
    | _,_,_,SYMDEF_dcl (DCL_type_alias t) -> bind_type dfns env (index :: exclude) t
    | _,_,_,SYMDEF_dcl (DCL_abs _) -> BTYP_name index
    | _,_,_,SYMDEF_dcl (DCL_union _) -> BTYP_name index
    | _,_,_,SYMDEF_dcl (DCL_struct _) -> BTYP_name index
    | id,sr,_,_ -> 
      failwith 
      (
        "[bind_type] Type " ^ id ^ 
        " defined at " ^ short_string_of_src sr ^
        " must be abstact, union or struct"
      )
    end 
  | TYP_tuple ts -> BTYP_tuple (List.map bt ts)
  | TYP_function (d,c) -> BTYP_function (bt d, bt c)
  | TYP_pointer t -> BTYP_pointer (bt t)
  | TYP_void -> BTYP_void
  | TYP_none -> BTYP_none
  
 

