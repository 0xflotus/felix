@head(1,"Inlining")
To make this work, we need a theorem.
First,  the call rule is:

@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_call

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  unit
 
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child
open Flx_reparent
open Flx_spexes
open Flx_foldvars


module BidSet = IntSet

let intset_of_list ls = 
  fold_left (fun s i -> IntSet.add i s) IntSet.empty ls
  

let string_of_vs vs =
  "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^ "]"

(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let ident x = x 

(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h

let idt t = t 

let is_var bbdfns i = 
  match Hashtbl.find bbdfns i with
  | _,_,_,`BBDCL_var _ -> true 
  | _ -> false

let is_simple_expr syms e =
  print_endline ("Is " ^ sbe syms.dfns e ^ " simple?");
  match e with
  | `BEXPR_ref _,_ -> print_endline "YES"; true
  | _ -> print_endline "NO"; false

(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

  NOTE: this is a special case of the distributive law.

  f (if c then a else b) v => if c then f a v else f b v

*)

let call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument =
  (*
  print_endline "DOING CALL LIFTING";
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = 
      try mk_varmap vs ts 
      with Failure x -> 
        print_endline "[call_lifting] FAIL mk_varmap";
        raise (Failure x)
    in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap false
    in
    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in

    (* replace all function returns with tailed calls *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_call_lift_" ^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    iter
      (function 
      | `BEXE_fun_return (sr,e) ->
        (* NOTE REVERSED ORDER *)
        let call_instr = 
          (
          (*
          match e with
          | `BEXPR_closure (i,ts),_ -> 
            `BEXE_call_direct (sr,i,ts,argument)
          | `BEXPR_method_closure (obj,i,ts),_ -> 
            `BEXE_call_method_direct (sr,obj,i,ts,argument)
          | _ ->
          *)
            `BEXE_call (sr,e,argument)
          )
        in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | `BEXE_yield _ ->
        syserr sr "Attempt to inline generator containing a yield"
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    revariable,!body2 (* forward order *)

  | _ -> assert false

let inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a =
  (* TEMPORARY .. this should be allowed for unrolling but we do not do that yet *)
  assert (callee <> caller);
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    let id2,_,_,_ = Hashtbl.find bbdfns caller in
    (*
    print_endline 
    (
      "TAIL Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "] into " ^ id2 ^ "<" ^ si caller ^">"
    );
    *)
    let relabel = mk_label_map syms exes in
    let varmap = 
      try mk_varmap vs ts 
      with Failure x -> 
        print_endline "[inline_tail_apply] FAIL mk_varmap";
        raise (Failure x)
    in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap false
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in
    revariable,rev body

  | _ -> assert false

let inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a varindex =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    (*
    print_endline 
    (
      "Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"^
      " retvar="^ si varindex ^
      "\nvs = " ^ catmap "," (fun (s,i) -> s ^ "<" ^ si i ^ ">") vs
    );
    *)
    let relabel = mk_label_map syms exes in
    let varmap = 
      try mk_varmap vs ts 
      with Failure x -> 
        print_endline "[inline_function] FAIL mk_varmap";
        raise (Failure x)
    in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap false
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in

    (*
    print_endline "Replace returns with inits";
    *)
    (* replace all function returns with variable initialisations *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_inline_" ^ Flx_name.cid_of_flxid id ^ "_"^ si n in
    let t = ref None in
    let end_label_used = ref false in
    iter
      (function 
      | `BEXE_fun_return (sr,((_,t') as e)) ->
        t := Some t';
        if not (!body2 == []) then begin
          body2 := `BEXE_goto (sr,end_label) :: !body2;
          end_label_used := true
        end
        ;
        let call_instr = `BEXE_init (sr,varindex,e) in
        (*
        print_endline ("Replacing return with init: " ^ string_of_bexe syms.dfns 0 call_instr);
        *)
        body2 := call_instr :: !body2;

      | `BEXE_yield _ ->
        syserr sr "Attempt to inline generator with a yield"

      | x -> body2 := x::!body2
      )
      body
    ;
    (* Ugghhh *)
    if !end_label_used then
      body2 := !body2 @ [`BEXE_label (sr,end_label)]
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    revariable,!body2 (* forward order *)

  | _ -> assert false

let is_generator bbdfns i = 
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with 
  | `BBDCL_fun (props,_,_,_,_,_,_) 
  | `BBDCL_function (props,_,_,_,_) 
    when mem `Generator props
    -> true
  | _ -> false

(* note u sr e must return exes in reverse order, this
  function however returns exes in forward order 
*)
let expand_exe syms bbdfns u exe = 
  let xs = 
    (*
    print_endline ("EXPAND EXE " ^ string_of_bexe syms.dfns 0 exe);
    *)
    match exe with
    | `BEXE_axiom_check _ -> assert false
    | `BEXE_call_prim (sr,i,ts,e2) -> assert false
      (*
      let e,xs = u sr e2 in
      `BEXE_call_prim (sr,i,ts,e) :: xs
      *)

    | `BEXE_call_stack (sr,i,ts,e2) -> assert false

    | `BEXE_call_direct (sr,i,ts,e2) -> assert false
      (*
      let e,xs = u sr e2 in
      `BEXE_call_direct (sr,i,ts,e) :: xs
      *)

    | `BEXE_call_method_direct (sr,e1,i,ts,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call_method_direct (sr,e1,i,ts,e2) :: xs2 @ xs1

    | `BEXE_call_method_stack (sr,e1,i,ts,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call_method_stack (sr,e1,i,ts,e2) :: xs2 @ xs1

    | `BEXE_jump_direct (sr,i,ts,e2) -> assert false
      (*
      let e,xs = u sr e2 in
      `BEXE_jump_direct (sr,i,ts,e) :: xs
      *)
   
    | `BEXE_apply_ctor (sr,i1,i2,ts,i3,e2) ->
      let e,xs = u sr e2 in
      `BEXE_apply_ctor (sr,i1,i2,ts,i3,e) :: xs

    | `BEXE_apply_ctor_stack (sr,i1,i2,ts,i3,e2) ->
      let e,xs = u sr e2 in
      `BEXE_apply_ctor_stack (sr,i1,i2,ts,i3,e) :: xs
     
    | `BEXE_assign (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_assign (sr,e1,e2) :: xs2 @ xs1

    | `BEXE_assert (sr,e) ->
      let e,xs = u sr e in
      `BEXE_assert (sr,e) :: xs

    | `BEXE_assert2 (sr,sr2,e1,e2) ->
      let e1,xs1 = 
        match e1 with Some e -> let a,b = u sr e in Some a,b
        | None -> None,[]
      in
      let e2,xs2 = u sr e2 in
      `BEXE_assert2 (sr,sr2,e1,e2) :: xs2 @ xs1

    (* preserve call lift pattern ??*)
    | `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) :: xs2 @ xs1

    | `BEXE_call (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call (sr,e1,e2) :: xs2 @ xs1

    | `BEXE_jump (sr,e1,e2) -> assert false

    | `BEXE_loop (sr,i,e) -> assert false
      (*
      let e,xs = u sr e in
      `BEXE_loop (sr,i,e) :: xs
      *)
   
    | `BEXE_ifgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifgoto (sr,e,lab) :: xs

    | `BEXE_ifnotgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifnotgoto (sr,e,lab) :: xs
   
    (* preserve tail call pattern -- used by both
       tail-rec eliminator 
       and by call lifter (which converts returns to calls)
    *)
    | `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) :: xs
    
    | `BEXE_fun_return (sr,e) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,e) :: xs

    | `BEXE_yield (sr,e) ->
      let e,xs = u sr e in
      `BEXE_yield (sr,e) :: xs
   
    (* This case has to be handled specially, in case we already
       have a simplified form, and the unravelling introduces
       a gratuitous extra variable: for example
       
       x : = f a

       might expand to

       x' = f a
       x := x'
       
       which is rather pointless. There is, unfortunately,
       a duplicate of this check elsewhere ..
    *)
    
    | `BEXE_init (sr,i,(`BEXPR_apply((`BEXPR_closure (j,ts),t'),e),t))
      when is_generator bbdfns j ->
      let e,xs = u sr e in
      `BEXE_init (sr,i,(`BEXPR_apply((`BEXPR_closure (j,ts),t'),e),t)) :: xs

    | `BEXE_init (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_init (sr,i,e) :: xs
    
    | `BEXE_svc _
    | `BEXE_label _
    | `BEXE_goto _
    | `BEXE_code _
    | `BEXE_nonreturn_code _
    | `BEXE_proc_return _
    | `BEXE_comment _
    | `BEXE_nop _
    | `BEXE_halt _
    | `BEXE_begin
    | `BEXE_end
      -> [exe]
  in 
    let xs = rev xs in
    xs

let check_reductions syms exes = Flx_reduce.reduce_exes syms syms.reductions exes

let heavy_inline_call syms (uses,child_map,bbdfns) 
  caller caller_vs callee ts argument id sr (props, vs, (ps,traint), exes)
=
  (*
  print_endline ("INLINING CALL to " ^ id ^"<"^ si callee^">("^sbe syms.dfns argument^")");
  print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
  print_endline ("Callee is " ^ id ^ "<"^si callee ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts);
  print_endline ("Callee vs=" ^ string_of_vs vs);
  *)
  let caller_vs_len = length caller_vs in
  let callee_vs_len = length vs in
  (*
  print_endline ("In the callee and its children,");
  print_endline ("The callee vs are elided and replaced by the caller vs");
  print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
  print_endline ("This works by instantiating the callee vs with the calls ts");
  *)
  assert(length vs = length ts);
  
  (*
  print_endline ("Found procedure "^id^": Inline it!");
  *)
  let relabel = mk_label_map syms exes in
  let varmap = 
    try mk_varmap vs ts 
    with Failure x -> 
      print_endline "[heavy_inline_call] FAIL mk_varmap";
      raise (Failure x)
  in
  let revariable = reparent_children 
    syms (uses,child_map,bbdfns) 
    caller_vs callee_vs_len callee (Some caller) relabel varmap false
  in
  let xs = gen_body syms (uses,child_map,bbdfns) id 
    varmap ps relabel revariable exes 
    argument sr caller callee caller_vs callee_vs_len `Lazy props
  in 
    revariable,rev xs (* forward order *)

let make_specialisation syms (uses,child_map,bbdfns) 
  caller caller_vs callee ts id sr parent props vs exes rescan_flag
=
  (*
  print_endline ("Specialising call " ^ id ^ "<"^si callee ^ ">[" ^ catmap "," (sbt syms.dfns) ts ^"]");
  print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
  print_endline ("Callee vs=" ^ string_of_vs vs);
  *)
  let caller_vs_len = length caller_vs in
  let callee_vs_len = length vs in

  (*
  print_endline ("In the callee and its children,");
  print_endline ("The callee vs are elided and replaced by the caller vs");
  print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
  print_endline ("This works by instantiating the callee vs with the calls ts");
  *)
  assert(length vs = length ts);
  
  (*
  print_endline ("Found procedure "^id^": Inline it!");
  *)
  let relabel = mk_label_map syms exes in
  let varmap = 
    try mk_varmap vs ts 
    with Failure x -> 
      print_endline "[make_specialisation] FAIL mk_varmap";
      raise (Failure x)
  in
  let k,ts' =
    specialise_symbol
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee ts parent relabel varmap rescan_flag
   in
   (*
   print_endline ("Specialised to " ^ id ^ "<"^si k ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts');
   *)
   k,ts'
    
(* Dependency analyser. This should be generalised,
but for now we only use it in tail calls.
 
We wish to discover what *local* vals an expression e in
some routine i depends on.

These are (a) the symbols manifestly used in the expression,
and (b) any variable used by any function that is called.

We can calculate this, expensively as the union of the
use closures of each symbol in the expression intersected
with the candidate locals.
*)


(* note returns exes in reverse order *)
(* This routine analyses an expression to see if it has  the form

  f a

If so it is replaced by v and a statement v = f a, then
this initialisation is replaced by the body of f 
with a replacing the parameter,
where returns are replaced by initialisations of v
and a goto the end of the routine.

Then in the special case the last line of the body
resolves to the form

  v = e'

the expression is replaced by e'. This works by a quirk,
that this code must have come from a sole tail return
in the body. If there were more than one return,
prior returns would be a return to a label after it,
however the inliner doesn't generate the label at the
end for a sole tail return, so we can assume this
is the only return.

The result leaves an expression in a place where
a tail call might be recognized, avoiding a temporary
which prevents simplistic patterns representing data
and control flow. Although its a hack, it is important
to ensure trivial functions have no overhead.

Note this routine, in itself, does NOT rescan anything:
there is no recursion -- other than the recursive traversal
of the original expression, done by the 'aux' function.
*)

let inlining_complete bbdfns i =
  let _,_,_,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (props,_,_,_,_)
  | `BBDCL_procedure (props,_,_,_) ->
    mem `Inlining_complete props
  | `BBDCL_proc _
  | `BBDCL_fun _ 
    -> true

  | _ -> assert false


(*


See post in felix-language. The problem is knowing
when to inline a function: typeclass virtual function
default methods can only be inlined if there is an instance
of the typeclass AND the virtual is not overridden in the
instance.

Proposed algorithm. 

1. Check if the function is virtual.

2. If so, find its parent, which is the typeclass

3. strip the tail off the instantiating ts so it
   matches the length of the typeclass vs list
   (in case the function is polymorphic, the function's
    private type arguments will be the remaining ones)

3. Using a table of pairs:

	(typeclass, (instance, (vs,ts)))

discover if there is an instance. This is actually hard:
the check actually requires seeing if the given ts specialises
one of the ts in the above table for the given typeclass.
The instantiation's vs is required too, since the ts of the
typeclass have to be mapped to the instance view.

4. IF there is a match:

4a. try to find an instance  of the virtual function. 

4b. If none is found, then inline the virtual function
    default body

4c.  otherwise inline the instance.

5. otherwise (no instance) leave the call alone.

IF we know the code is fully monorphised then 5 becomes
instead an error.

Note that Felix currently DOES NOT detect this error.
If the function has a default, it will be used even
if there is no instance. This will result in either
an infinite recursion at run time OR lead to another
virtual that has no body, resulting in an error diagnostic.

But the infinite recursion is also possible even if there
is an instance .. so nothing is lost here.. :)

*)

let virtual_check syms (bbdfns:fully_bound_symbol_table_t) sr i ts =
  let id,parent,callee_sr,entry = Hashtbl.find bbdfns i in
  (*
  print_endline ("virtual check Examining call to " ^ id ^ "<" ^ si i ^ ">");
  *)
  match entry with
  | `BBDCL_fun (props,_,_,_,_,_,_) 
  | `BBDCL_function (props,_,_,_,_)
  | `BBDCL_proc (props,_,_,_,_)
  | `BBDCL_procedure (props,_,_,_) when mem `Virtual props ->
    (*
    print_endline ("Examining call to virtual " ^ id);
    *)
    let parent = match parent with | Some p -> p | None -> assert false in
    let tcvslen =
      try 
        let {id=pid; vs=vs; symdef=entry} = Hashtbl.find syms.dfns parent in
        match entry with
        | `SYMDEF_typeclass ->
          (*
          print_endline ("Found parent " ^ pid ^ "<" ^ si i ^ ">");
          *)
          List.length (fst vs)
        | _ -> 
          print_endline "Woops, parent isn't typeclass?"; 
          assert false
      with Not_found -> 
        print_endline ("Parent typeclass " ^ si parent ^ " not found!");
        assert false
    in
    let tslen = List.length ts in
    (*
    print_endline ("Vs len of parent = " ^ si tcvslen);
    print_endline ("ts len           = " ^ si tslen);
    *)
    if tcvslen > tslen then
      clierr sr "Not enough type arguments for typeclass"
    ;
    let fts = rev (list_prefix (rev ts) (tslen - tcvslen)) in
    let ts = list_prefix ts tcvslen in
    let instances = 
      try Hashtbl.find syms.instances_of_typeclass parent 
      with Not_found ->
        (*
        print_endline "No instances of typeclass?";
        *)
        (*
        assert false
        *)
        []
    in
    (*
    print_endline "Found some instances!";
    print_endline ("ts = " ^ catmap "," (sbt syms.dfns) ts);
    *)
    let matches = ref [] in
    iter (fun (j,(jvs,jcon,jts)) ->
      (*
      print_endline ("instance[" ^
        catmap "," (fun (s,i) -> s^ "<"^si i^">") jvs ^ "] " ^
        si j ^ "[" ^
        catmap "," (sbt syms.dfns) jts ^ "]"
      );
      *)
      (* check if the call specialises the instance. *)
      let ok = 
        Flx_typeclass.tcinst_chk syms true i ts sr 
          (jvs, jcon,jts, j)
      in
      begin match ok with
      | Some _ -> 
        (*
        print_endline "matches";
        *)
        matches := j :: !matches

      | None -> (* print_endline "Doesn't match"; *)  ()
      end
    )
    instances
    ;
    begin match !matches with 
    | [_] -> 
      let i',ts' = 
        Flx_typeclass.maybe_fixup_typeclass_instance syms bbdfns i ts 
      in
      if i = i' then begin
        (*
        print_endline (id ^ " -- Dispatch to default");
        *)
        true,i',ts' @ fts
      end else begin
        (*
        print_endline (id ^ " -- Dispatch to instance");
        *)
        true,i',ts' @ fts
      end
    | _ -> 
      (*
      print_endline (id ^ " -- Dispatch unknown");
      *)
      false,i,ts @ fts
    end

  | _ -> (* print_endline (id ^ " -- Not virtual") *) true,i,ts

let rec special_inline syms (uses,child_map,bbdfns) caller_vs caller excludes sr e =
  (*
  print_endline ("Special inline " ^ sbe syms.dfns e);
  *)
  let exes' = ref [] in
  let id x = x in
  let rec aux e = 
  (*
  print_endline (" ... Special inline subexpr: " ^ sbe syms.dfns e);
  *)
  match map_tbexpr id aux id e with
  | `BEXPR_closure (callee,_),_ as x ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      x

  | ((`BEXPR_apply_prim (callee,ts,a),t) as e)
  | ((`BEXPR_apply_stack (callee,ts,a),t) as e)
  | ((`BEXPR_apply_direct (callee,ts,a),t) as e) -> assert false

  | (((`BEXPR_apply(  (`BEXPR_closure (callee,ts),_) ,a)),t) as e)
    ->
      let can_inline,callee,ts = virtual_check syms bbdfns sr callee ts in
      if not (mem callee excludes) then begin
        heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
        let id,parent,sr,entry = Hashtbl.find bbdfns callee in
        begin match entry with


        (* THIS CODE IS PROBABLY IN THE WRONG PLACE! 

           The technique is ALSO probably insecure because
           it only works with direct applications .. but
           the overloading works with closures too.

           To make this actually work properly requires a change
           to the type system.

           In addition, it isn't clear the lifted call is optimised
           as it should be (it should be inlined of course).
           In particular, its argument may also include calls
           needing lifting.
        *)

        (* This code must ONLY be triggered by an inner (unlifted) application
           so the detector must not be recursively applied to RHS of initialisation
           x = f a
           where f is the generator, since that form is properly lifted ..
           otherwise we get a chain:
           x1 = f a
           x2 = x1
           x3 = x2 
           ...
        *)
        | `BBDCL_fun (props,_,_,_,_,_,_) 
        | `BBDCL_function (props,_,_,_,_) 
          when mem `Generator props ->
          (*
          print_endline ("Unravel generator " ^ id);
          *)

          (* create a new variable *)
          let urv = !(syms.counter) in incr (syms.counter);
          let urvid = "_genout_urv" ^ si urv in
          add_child child_map caller urv;
          add_use uses caller urv sr;
          let entry = `BBDCL_var (caller_vs,t) in
          Hashtbl.add bbdfns urv (urvid,Some caller,sr,entry);

          (* set variable to function appliction *)
          let cll = `BEXE_init (sr,urv,e) in
          exes' := cll :: !exes';


          (* replace application with the variable *)
          let ts = map (fun (_,i)-> `BTYP_var (i,`BTYP_type 0)) caller_vs in
          `BEXPR_name (urv,ts),t

        | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
          (*
          print_endline ("Consider inlining " ^ id);
          *)
          (*
          if is_child child_map caller callee then
            print_endline ("Callee "^si callee ^" is child of caller " ^ si caller ^ " EXCLUDE LEN= " ^ si (length excludes))
          ;
          *)
          if can_inline &&
            not (mem `NoInline props) &&
            (
              mem `Inline props ||
              length exes <= syms.compiler_options.max_inline_length
            ) &&
           (
              (* only inline a recursive call to a child *)
              not (Flx_call.is_recursive_call uses caller callee) ||
              is_child child_map caller callee
           )
          then 
              begin
                (*
                heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
                *)
                if not (inlining_complete bbdfns callee) then print_endline "Inlining isn't complete in callee ..??";

                if inlining_complete bbdfns callee then begin
                  (*
                  print_endline ("INLINE " ^ id ^ "<" ^ si callee ^ ">");
                  print_endline ("Special inline " ^ si caller ^" calls " ^ si callee);
                  *)
                  (* GENERAL CASE -- we need to add a variable *)
                  let urv = !(syms.counter) in incr (syms.counter);
                  (* inline the code, replacing returns with variable inits *)
                  let revariable,xs = 
                     inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a urv 
                  in 
                  (*
                  print_endline "Inline body = ";
                  iter (fun exe -> print_endline (string_of_bexe syms.dfns 4 exe)) xs;
                  *)

                  match rev xs with
                  (* SPECIAL CASE DETECTOR: if the inlined function
                    terminates with an initialisation of the new variable,
                    ignore the variable and use the value used to initialise
                    it instead. This is sure to be the result of the sole
                    trailing return. If there were another return, a
                    jump to the end of the function would be needed,
                    past this initialisation, which would require a label
                    at the end of the function

                    Note this is a bad form of 'apply lifting'.
                    We should be able to inline

                    f (g x)

                    by inlining g x, and replacing 'return e'
                    with 'v = f e' everywhere. instead we get
                    v = e in various places, then f v.

                    To do this right we need to see a double application.
                  *)
                  | [] -> assert false
                  | `BEXE_init (sr,j,e') :: tail ->
                    assert (j==urv);
                    (*
                    print_endline "DETECTED SPECIAL CASE";
                    print_endline "Outputing tail:";
                    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev tail);
                    print_endline ("Expr: " ^ sbe syms.dfns e');
                    *)
                    exes' := tail @ !exes';
                    e'
                  | rxs -> 
                    let urvid = "_urv" ^ si urv in
                    add_child child_map caller urv;
                    add_use uses caller urv sr;
                    let entry = `BBDCL_val (caller_vs,t) in
                    Hashtbl.add bbdfns urv (urvid,Some caller,sr,entry);

                    exes' := rxs @ !exes';
                    let ts = map (fun (_,i)-> `BTYP_var (i,`BTYP_type 0)) caller_vs in
                    `BEXPR_name (urv,ts),t
                end
                else e
              end
          else e
        | _ -> e
        end
      end else e
  
  | x -> x
  in 
   let e = aux e in (* we need left to right evaluation here ..*)
   e,!exes'

and heavy_inline_calls
  syms (uses,child_map,bbdfns)
  caller_vs caller excludes exes 
=
  (*
  print_endline ("HIC: Input excludes = " ^ catmap "," si excludes);
  *)
  let inline_check caller callee props exes =        
    not (mem `NoInline props) &&
    (
        mem `Inline props ||
        length exes <= syms.compiler_options.max_inline_length
    ) && 
    (
      (* only inline a recursive call to a child *)
      not (Flx_call.is_recursive_call uses caller callee) ||
      is_child child_map caller callee
    )
  in
  let specialise_check caller callee ts props exes = false
    (*
    (* for the moment, don't specialise recursive calls *)
    ts <> [] &&
    not (Flx_call.is_recursive_call uses caller callee)
    *)
  in
  let hic revariable callee exes =
    (*
    print_endline "Rescanning ..";
    *)
    let excludes = fold_left 
    (fun acc i -> 
      i :: (try [Hashtbl.find revariable i] with Not_found -> []) @ acc
    )
    []
    (callee::excludes) 
    in
    heavy_inline_calls syms (uses,child_map,bbdfns)
    caller_vs caller excludes exes
  in

  (* The function ee applies the special inlining routine
    to all subexpressions of an expression, bottom up
    (that is, inside out). 
  *)
  
  let sinl sr e = special_inline syms (uses,child_map,bbdfns) caller_vs caller (caller::excludes) sr e in 

  let ee exe = expand_exe syms bbdfns sinl exe in
  let exes' = ref [] in (* reverse order *)
  iter  (* each exe *)
  (fun exeIN -> 
    (*
    print_endline ("EXE[in] =" ^ string_of_bexe syms.dfns 0 exeIN);
    *)
    let xs = ee exeIN in
    (*
    iter (fun x -> print_endline ("EXE[out]=" ^ string_of_bexe syms.dfns 0 x)) xs;
    print_endline "--";
    *)
    (*
      This code RESCANS the result of the special inliner.
      The special inliner only handles function applications,
      this code should NOT handle them because iteration might
      lead to infinite recurse ..??

      This means the 'special cases' handled must be
      disjoint.

      Unfortunately, when inlining a function, we first
      inline into the function, then dump the result and
      rescan it. Consequently the recursion stop applied
      which leaves a direct non-tail self call will be
      rescanned here, and the function will be unfolded
      again .. in that process we also redo the special
      inlining .. infinite recursion. This is stopped
      by the flag which prevents inlining into a function
      more than once .. but that doesn't work if the
      function is cloned.
    *)
    iter (fun exe ->
    match exe with
    | `BEXE_call (sr,(`BEXPR_closure(callee,ts),clt),argument) 
    (*
    | `BEXE_call_direct (sr,callee,ts,argument) 
    *)
      when not (mem callee excludes)
      ->
      let can_inline,callee,ts = virtual_check syms bbdfns sr callee ts in
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,callee_sr,entry = Hashtbl.find bbdfns callee in
      (*
      print_endline ("CALL DIRECT " ^ id ^ "<"^ si callee^">");
      *)
      begin match entry with
      | `BBDCL_procedure (props,vs,(ps,traint),exes) ->
        if can_inline && inline_check caller callee props exes then
        begin
          (*
          print_endline "INLINE CANDIDATE DETECTED - CALL";
          *)
          let revariable,xs = 
            heavy_inline_call syms (uses,child_map,bbdfns) 
            caller caller_vs callee ts argument id sr (props,vs,(ps,traint),exes)
          in 
            let xs = hic revariable callee xs in
            exes' := rev xs @ !exes'
        end
        (*
        else if specialise_check caller callee ts props exes then
          let k,ts' = make_specialisation
             syms (uses,child_map,bbdfns) 
             caller caller_vs callee ts id sr parent props vs exes true
          in
            exes' := `BEXE_call_direct (sr,k,ts',argument) :: !exes'
        *)
        else
          exes' := exe :: !exes'

      | _ ->  exes' := exe :: !exes'
      end

    | `BEXE_call (sr,(`BEXPR_apply_stack (callee,ts,a),_),argument)
    | `BEXE_call (sr,(`BEXPR_apply_prim (callee,ts,a),_),argument)
    | `BEXE_call (sr,(`BEXPR_apply_direct (callee,ts,a),_),argument) 
      -> assert false

    | `BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument)
      when not (mem callee excludes)
      ->
      (*
      print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
      print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
      *)
      (*
      print_endline ("handling call lift: " ^ string_of_bexe syms.dfns 0 exe);
      print_endline ("Callee is " ^ si callee ^ " with ts = " ^ catmap "," (sbt syms.dfns) ts);
      *)
      let can_inline,callee,ts = virtual_check syms bbdfns sr callee ts in
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,callee_sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
        if can_inline && inline_check caller callee props exes then
          let revariable,xs = 
             call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument
          in 
            (* The recursion here is because the call is lifted,
            so there may be new calls that didn't previously
            exist, they need rescanning eg:
            
              call {if x then f else g endif} a 
              -->
              if x then call f a else call f a endif
            
            creates new calls to f and g when now need
            to be scanned (possibly for a further lift,
            possibly for call inlining)

            The hassle here is that we might unfold
            an unrelated recursive function multiple times
            as a side effect.
            *)
            let xs = hic revariable callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_init (sr,i,(`BEXPR_apply_stack (callee,ts,a),_)) 
    | `BEXE_init (sr,i,(`BEXPR_apply_prim (callee,ts,a),_)) 
    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_))  
      -> assert false

    | `BEXE_init (sr,i,(`BEXPR_apply ((`BEXPR_closure(callee,ts),_),a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling init: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      let can_inline,callee,ts = virtual_check syms bbdfns sr callee ts in
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,callee_sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
        if can_inline && inline_check caller callee props exes then
          begin
            let vid,vparent,vsr,ventry = Hashtbl.find bbdfns i in
            begin match ventry with
            | `BBDCL_tmp (vs,t) ->
              (*
              print_endline ("Downgrading temporary .." ^ si i);
              *)
              (* should this be a VAR or a VAL? *)
              Hashtbl.replace bbdfns i (vid,vparent,vsr,`BBDCL_var (vs,t))
            | _ -> ()
            end;
            let revariable,xs = 
               inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a i
            in 
              let xs = hic revariable callee xs in
              exes' := rev xs @ !exes'
          end
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_fun_return (sr,(`BEXPR_apply_direct (callee,ts,a),_)) 
    | `BEXE_fun_return (sr,(`BEXPR_apply_stack (callee,ts,a),_)) 
    | `BEXE_fun_return (sr,(`BEXPR_apply_prim (callee,ts,a),_)) 
     -> assert false

    | `BEXE_fun_return (sr,(`BEXPR_apply((`BEXPR_closure(callee,ts),_),a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling return: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      let can_inline,callee,ts = virtual_check syms bbdfns sr callee ts in
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,callee_sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
        if can_inline && inline_check caller callee props exes then
        begin
          if inlining_complete bbdfns callee then
            let revariable,xs = 
               (*
               print_endline ("Tail apply: " ^ string_of_bexe syms.dfns 0 exe);
               *)
               inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a
            in 
              let xs = hic revariable callee xs in
              exes' := rev xs @ !exes'
          else
            exes' := exe :: !exes'
        end else
          exes' := exe :: !exes'
      | _ -> 
        exes' := exe :: !exes'
      end
    | _ -> exes' := exe :: !exes' 
    )
    xs
  )
  exes
  ;
  rev !exes'

and remove_unused_children syms (uses,child_map,bbdfns) i = 
  let desc = descendants child_map i in
  if desc <> IntSet.empty then begin
    (* all the descendants of a routine, excluding self *)
    (*
    print_endline "CANDIDATE FOR CHILD REMOVAL";
    print_function syms.dfns bbdfns i;
    print_endline ("Descendants of " ^ si i ^ " =" ^ IntSet.fold (fun j s -> s ^ " " ^ si j) desc "");
    IntSet.iter (fun i-> print_function syms.dfns bbdfns i) desc;
    *)


    (* everything used by this routine directly or indirectly *)
    let used = Flx_call.use_closure uses i in

    (*
    print_endline ("Usage closure of " ^ si i ^ " =" ^ IntSet.fold (fun j s -> s ^ " " ^ si j) used "");
    *)
    (* any desendants not used by this routine *)
    let unused_descendants = IntSet.diff desc used in

    (* remove the item *)
    IntSet.iter
    (fun i -> 
      begin 
        try 
          (* any parent disowns the child *)
          match Hashtbl.find bbdfns i with
          | _,Some parent,_,_ -> remove_child child_map parent i
          | _ -> ()
        with Not_found -> ()
      end
      ;

      (* remove from symbol table, child map, and usage map *)
      Hashtbl.remove bbdfns i;
      Hashtbl.remove child_map i;
      Hashtbl.remove uses i;
      if syms.compiler_options.print_flag then
        print_endline ("REMOVED CHILD SYMBOL " ^ qualified_name_of_index syms.dfns i)
    )
    unused_descendants
  end

and heavily_inline_bbdcl syms (uses,child_map,bbdfns) excludes i =
  let specs = 
    try Some (Hashtbl.find bbdfns i) 
    with Not_found -> None 
  in
  match specs with None -> () | Some spec ->
  match spec with
  | id,parent,sr,`BBDCL_procedure (props,vs,(ps,traint),exes) ->
    (*
    print_endline ("HIB: consider procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
    *)
    if not (mem `Inlining_started props) then begin
      let props = `Inlining_started :: props in
      let data = id,parent,sr,`BBDCL_procedure (props,vs,(ps,traint),exes) in
      Hashtbl.replace bbdfns i data;

      (* inline into all children first *)
      let children = find_children child_map i in
      iter (fun i-> heavily_inline_bbdcl syms (uses, child_map, bbdfns) excludes i) children;

      let xcls = Flx_tailit.exes_get_xclosures syms exes in
      IntSet.iter (fun i-> heavily_inline_bbdcl syms (uses, child_map, bbdfns) excludes i) xcls;

      if syms.compiler_options.print_flag then
      print_endline ("HIB: Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      (*
      print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in 
      recal_exes_usage syms uses sr i ps exes;
      (*
      print_endline (id ^ " Before inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      let exes = Flx_tailit.tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *) 
      recal_exes_usage syms uses sr i ps exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in 
      recal_exes_usage syms uses sr i ps exes;
      let exes = check_reductions syms exes in
      let exes = Flx_cflow.chain_gotos syms exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_procedure (props,vs,(ps,traint),exes) in
      Hashtbl.replace bbdfns i data;
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      (*
      print_endline ("DONE Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      print_endline ("OPTIMISED PROCEDURE BODY: " ^ id ^ " :\n" ^ catmap "\n" (string_of_bexe syms.dfns 2) exes);
      *)
    end

  | id,parent,sr,`BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    if not (mem `Inlining_started props) then begin
      let props = `Inlining_started :: props in
      let data = id,parent,sr,`BBDCL_function (props,vs,(ps,traint),ret,exes) in
      Hashtbl.replace bbdfns i data;

      (* inline into all children first *)
      let children = find_children child_map i in
      iter (fun i-> heavily_inline_bbdcl syms (uses, child_map, bbdfns) excludes i) children;

      let xcls = Flx_tailit.exes_get_xclosures syms exes in
      IntSet.iter (fun i-> heavily_inline_bbdcl syms (uses, child_map, bbdfns) excludes i) xcls;

      if syms.compiler_options.print_flag then
      print_endline ("HIB:Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      (*
      print_endline (id ^ " Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in 
      recal_exes_usage syms uses sr i ps exes;
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      (*
      print_endline ("Tailing " ^ si i);
      *)
      recal_exes_usage syms uses sr i ps exes;
      let exes = Flx_tailit.tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id^ " After tailing(2):\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in
      recal_exes_usage syms uses sr i ps exes;
      let exes = check_reductions syms exes in
      let exes = Flx_cflow.chain_gotos syms exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_function (props,vs,(ps,traint),ret,exes) in
      Hashtbl.replace bbdfns i data;
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      (*
      print_endline ("DONE Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      print_endline ("OPTIMISED FUNCTION BODY: " ^ id ^ " :\n" ^ catmap "\n" (string_of_bexe syms.dfns 2) exes);
      *)
    end
  | _ -> ()

let heavy_inlining syms  
  (child_map,bbdfns)
=
  let used = ref (!(syms.roots)) in
  let (uses,usedby) = Flx_call.call_data syms bbdfns in

  while not (IntSet.is_empty !used) do
    let i = IntSet.choose !used in
    used := IntSet.remove i !used;
    heavily_inline_bbdcl syms (uses,child_map,bbdfns) [i] i
  done;

  Hashtbl.iter
    (fun i _ -> try heavily_inline_bbdcl syms (uses,child_map,bbdfns) [i] i with _ -> ())
  bbdfns


(* NOTES: this algorithm ONLY WORKS if inlining is attempted
in the corect order. Attempting to inline into children
before parents, when they're mutually recursive, spawns
clones infinitely, because we end up cloning a function
on the exclusion list, but not adding the clone to it.


NOTE!!!! THIS SHOULD BE FIXED NOW. WE NO LONGER
PERMIT INLINING RECURSIVE FUNCTIONS UNLESS THE CALL
IS TO A CHILD. A CALL TO SELF, PARENT OR SIBLING NEVER
DOES INLINING .. AND THERE ARE NO OTHER CASES.

INLINING KIDS IS MANDATORY FOR TAIL RECURSION OPTIMISATION.

So we end up recursing into the clone, and inlining
into it, which spawns more clones which are not
excluded, and haven't been inlined into yet.

This needs to be fixed so the algorithm is proven
to terminate and also be complete.

What we need (and is NOT implemented) is something like this:

Cloning nested functions is should not be needed in general.
If we proceed from leaves towards the root, we can eliminate
from each function any nested children, by simply inlining
them. So only variable children need cloning.

Two things stop this working: 

(a) non-inline functions and
(b) recursion.

The current algorithm has been hacked to only handle the
call graph from the roots. It used to consider the useage
closure, however that started to fail when I added 
'pre-assigned' slot numbers (AST_index). Doing that meant
the natural order of the set wasn't a topological sort
of the parent-child order.

Unfortunately, the remaining recursive descent doesn't
proceed into noinline functions. Although these shouldn't
be inlined into their caller, that doesn't mean functions
shouldn't be inlined into them. Iterating over the usage
closure ensured noinline functions would still be inlined
into.

Recursive functions are a bit different: they currently
allow inlining, with a recursion stopper preventing
infinite recursion.

Unfortunately with a double nesting like this:

  fun f() { fun g() { fun h() { f(); } h(); } g(); }

trying to inline g into f causes h to be cloned.
But trying to inline f into the clone of h retriggers
the descent, causing the clone to be recloned, and 
the recursion stopper doesn't prevent this, since it
isn't the same routine being inlined twice (just a clone
of it ..)

The thing is.. we HAVE to inline the original routine
AND the clone for completeness, since both may be
called independently, so even if we could clone the
recursion stoppers, it wouldn't work.

The only solution I can think of is to guarrantee that
you can only clone a routine that is inlined into
already (as fas as possible) so that no attempt will
be made to inline into the clone either.
--------------------------------------------------------------
Hum.... When I inline A -> B -> C -> A (all kid inlines) the 
inline of A into C is done first. This creates clones B' and C'.
When we rescan the code to be put into C, we would try to
inline B' into it, and C' into that .. but C' is a cloned sibling
of C, and not the same function. So we try to inline into C',
and inlining A is allowed there .. which causes an infinite
recursion.

*)
