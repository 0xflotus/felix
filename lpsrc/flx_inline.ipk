@head(1,"Inlining")
To make this work, we need a theorem.
First, the call rule is:
@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_call

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  unit

 
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child

module BidSet = IntSet

let intset_of_list ls = 
  fold_left (fun s i -> IntSet.add i s) IntSet.empty ls
  
(* this only updates the uses table not the usedby table,
  because inlining changes usage (obviously).
  we need it in particular for the is_recursive test,
  so that tail recursions which have been eliminated
  won't cause the test to return a false positive
*)

let string_of_intset s =
  "{ " ^
  IntSet.fold (fun i x -> x ^ si i ^ " ") s "" ^
  "}"

let recal_exes_usage syms uses sr i ps exes =
  (*
  print_endline ("Recal usage of this code:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
  *)
  (* delete old entry *)
  (try Hashtbl.remove uses i with Not_found -> ());
  iter (Flx_call.cal_param_usage syms uses sr i) ps;
  iter (Flx_call.cal_exe_usage syms uses i) exes

let is_tailed ps exes =
  try iter
  (function 
    | `BEXE_init(_,i,_) when mem i ps -> raise Not_found 
    | _ -> ()
  )
  exes;
  false
  with Not_found -> true
  
let string_of_vs vs =
  "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^ "]"

let useset uses i =
  let u = try Hashtbl.find uses i with Not_found -> [] in
  fold_left (fun s (i,_) -> IntSet.add i s) IntSet.empty u
  
(* find all the variables of a function i which
   are not used by children, this is the kids
   minus just the union of everything used by the 
   child functions.
*)
let locals child_map uses i =
  let kids = intset_of_list (find_children child_map i) in
  (*
  print_endline ("Kid of " ^ si i ^ " = " ^ string_of_intset kids);
  *) 
  (*
  let u = useset uses i in
  *)
  let u = Flx_call.child_use_closure kids uses i in
  let unused_kids = IntSet.diff kids u in
  (*
  print_endline ("Unused kids are " ^ si i ^ " = " ^ string_of_intset unused_kids);
  *)
  let used_kids = IntSet.diff kids unused_kids in
  (*
  print_endline ("Used kids are " ^ si i ^ " = " ^ string_of_intset used_kids);
  *)
  (*
  let desc = descendants child_map i in
  *)
  let desc =
    IntSet.fold
    (fun j s -> let u = descendants child_map j in IntSet.union u s)
    used_kids
    IntSet.empty
  in
  (*
  print_endline ("Descendants of " ^ si i ^ " = " ^ string_of_intset desc);
  *)
  let u =
    IntSet.fold 
    (fun j s -> 
      let u = useset uses j in
      (*
      print_endline ("Descendant " ^ si j ^ " of " ^ si i ^ " uses " ^ string_of_intset u);
      *)
      IntSet.union s u
    )
    desc
    IntSet.empty
  in
  (*
  print_endline ("Stuff used by some descendant = " ^ string_of_intset u);
  *)
  IntSet.diff kids u

(* remove all uses of j from i *)
let remove_uses uses i j =
  try
    let u = Hashtbl.find uses i in
    let u = filter (fun (k,sr) -> j <> k) u in
    Hashtbl.replace uses i u
  with Not_found -> ()

let add_use uses i j sr =
  let u = try Hashtbl.find uses i with Not_found -> [] in
  Hashtbl.replace uses i ((j,sr) :: u)
  
let mk_remap counter d =
  let m = Hashtbl.create 97 in
  IntSet.iter
  (fun i -> 
    let n = !counter in 
    incr counter; 
    Hashtbl.add m i n
  )
  d
  ;
  m

(* replace callee type variables with callers *)
let vsplice caller_vars callee_vs_len ts = 
  if not (callee_vs_len <= length ts)
  then failwith 
  (
    "Callee_vs_len = " ^ 
    si callee_vs_len ^ 
    ", len vs/ts= " ^ 
    si (length ts) ^
    ", length caller_vars = " ^
    si (length caller_vars)
  )
  ;
  let rec aux lst n =  (* elide first n elements *)
    if n = 0 then lst 
    else aux (tl lst) (n-1) 
  in
  caller_vars @ aux ts callee_vs_len 


(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let ident x = x 

let remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e = 
  let auxt t = varmap_subst varmap t in
  let fixup i ts = 
    let ts = map auxt ts in
    try 
      let j= Hashtbl.find revariable i in 
      j, vsplice caller_vars callee_vs_len ts
    with Not_found -> i,ts
  in
  let rec aux e = match map_tbexpr ident aux auxt e with
  | `BEXPR_name (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_name (i,ts), auxt t

  | `BEXPR_ref (i,ts) as x,t ->
    let i,ts = fixup i ts in
    `BEXPR_ref (i,ts), auxt t

  | `BEXPR_closure (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_closure (i,ts), auxt t

  | `BEXPR_apply_direct (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_direct (i,ts,aux e), auxt t

  | `BEXPR_apply_stack (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_stack (i,ts,aux e), auxt t

  | `BEXPR_apply_prim (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_prim (i,ts,aux e), auxt t

  | `BEXPR_parse (e,gs),t ->
    let revar i = try Hashtbl.find revariable i with Not_found -> i in
    let e = aux e in
    let gs = map revar gs in
    `BEXPR_parse (e,gs), auxt t

  | x -> x
  in
    let a = aux e in
    (*
    print_endline ("replace " ^ sbe syms.dfns e ^ "-->" ^ sbe syms.dfns a);
    *)
    a

let remap_exe syms bbdfns relabel varmap revariable caller_vars callee_vs_len exe =
  (*
  print_endline ("remap_exe " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let ge e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_prim (sr,i,ts, ge e2)

  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_direct (sr,i,ts, ge e2)

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_stack (sr,i,ts, ge e2)
    
  | x -> map_bexe revar ge ident relab relab x

let remap_exes syms bbdfns relabel varmap revariable caller_vars callee_vs_len exes =
  map (remap_exe syms bbdfns relabel varmap revariable caller_vars callee_vs_len) exes

let reparent1 (syms:sym_state_t) (uses,child_map,bbdfns )
  relabel varmap revariable 
  caller_vs callee_vs_len index parent
=
  let splice vs = (* replace callee type variables with callers *)
    vsplice caller_vs callee_vs_len vs 
  in
  let sop = function
    | None -> "NONE?" 
    | Some i -> si i
  in
  let caller_vars = map (fun (s,i) -> `BTYP_var i) caller_vs in

  let auxt t = varmap_subst varmap t in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let remap_ps ps = map (fun (id,(i,t)) -> id,(revar i,auxt t)) ps in

  let k = Hashtbl.find revariable index in
  let rexes xs = remap_exes syms bbdfns relabel varmap revariable caller_vars callee_vs_len xs in
  let rexpr e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in 
  let id,old_parent,sr,entry = Hashtbl.find bbdfns index in
  (*
  print_endline 
  (
    "COPYING " ^ id ^ " index " ^ si index ^ " with old parent " ^
    sop old_parent ^ " to index " ^ si k ^ " with new parent " ^
    sop parent
  );
  *)
  begin match parent with
  | Some p ->
    let old_kids = try Hashtbl.find child_map p with Not_found -> [] in
    (*
    print_endline ("ADDING " ^ si k ^ " as child of " ^ si p);
    *)
    Hashtbl.replace child_map p (k::old_kids)
  | None -> ()
  end
  ;
  match entry with
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = rexes exes in
    let ps = remap_ps ps in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_procedure (props,splice vs,ps,exes));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls
     
  | `BBDCL_function (props, vs, ps, ret, exes) ->
    let ps = remap_ps ps in
    let exes = rexes exes in
    let ret = auxt ret in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_function (props,splice vs,ps,ret,exes));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls
 
  | `BBDCL_var (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_var (splice vs,auxt t))

  | `BBDCL_val (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_val (splice vs,auxt t))

  | `BBDCL_tmp (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_tmp (splice vs,auxt t))

  | `BBDCL_reglex (props,vs,ps,i,t,(a,j,h,m)) ->
    let t = auxt t in
    let ps = remap_ps ps in
    let vs = splice vs in
    let i = revar i in
    let h2 = Hashtbl.create 13 in
    Hashtbl.iter (fun x e -> Hashtbl.add h2 x (rexpr e)) h;
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_reglex (props,vs,ps,i,t,(a,j,h2,m)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls


  | `BBDCL_regmatch (props,vs,ps,t,(a,j,h,m)) ->
    let t = auxt t in
    let ps = remap_ps ps in
    let vs = splice vs in
    let h2 = Hashtbl.create 13 in
    Hashtbl.iter (fun x e -> Hashtbl.add h2 x (rexpr e)) h;
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_regmatch (props,vs,ps,t,(a,j,h2,m)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls

  
  | `BBDCL_glr (props,vs,t,(prd,exes)) -> 
    let t = auxt t in
    let vs = splice vs in
    let exes = rexes exes in
    let remap_glr g = match g with 
      | `Nonterm js -> `Nonterm (map revar js)
      | x -> x (* terminal codes are invariant *)
    in
    let prd = map (fun (s,g) -> s,remap_glr g) prd in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_glr (props,vs,t,(prd,exes)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls

  | _ -> syserr sr ("[reparent1] Unexpected bbdcl " ^ string_of_bbdcl syms.dfns entry index)

(* make a copy all the descendants of i, changing any
  parent which is i to the given new parent
*)

let reparent_children syms (uses,child_map,bbdfns) 
  caller_vs callee_vs_len index parent relabel varmap 
=
  let pp p = match p with None -> "NONE" | Some i -> si i in
  (*
  print_endline 
  (
    "Renesting children of callee " ^ si index ^ 
    " to caller " ^ pp parent ^
     "\n  -- Caller vs len = " ^ si (length caller_vs) ^
     "\n  -- Callee vs len = " ^ si (callee_vs_len)
  );
  *)
  let closure = descendants child_map index in
  assert (not (IntSet.mem index closure));
  (*
  let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
  print_endline ("Closure is " ^ catmap " " si !cl);
  *)
  let revariable = mk_remap syms.counter closure in
  IntSet.iter
  (fun i -> 
    let old_parent = 
      match Hashtbl.find bbdfns i with id,oldp,_,_ -> oldp
    in
    let new_parent: bid_t option =
      match old_parent with
      | None -> assert false
      | Some p ->
        if p = index then parent
        else Some (Hashtbl.find revariable p)
    in
    reparent1 syms (uses,child_map,bbdfns) relabel varmap revariable 
    caller_vs callee_vs_len i new_parent
  )
  closure
  ;
  if syms.compiler_options.print_flag then begin
    Hashtbl.iter
    (fun i j ->
      print_endline ("//Reparent " ^ si j ^ " <-- " ^ si i)
    )
    revariable
  end
  ;
  revariable

 
(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h

let idt t = t 
let subarg syms bbdfns argmap exe =
  (*
  print_endline ("[subarg] Checking " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let rec rpl x = match map_tbexpr ident rpl idt x with
  (* No need to check ts or type here *)
  | (`BEXPR_name (i,_),_) as x -> 
    (try 
      let x' = Hashtbl.find argmap i in
      (*
      print_endline ("Replacing variable " ^ si i ^ " with " ^ sbe syms.dfns x');
      *)
      x'
      with Not_found -> x)
  | x -> x
  in
  reduce_bexe bbdfns (map_bexe idt rpl idt idt idt exe)

(* NOTE: result is in reversed order *)
let gen_body syms (uses,child_map,bbdfns) id 
  varmap ps relabel revariable exes argument 
  sr caller callee vs callee_vs_len inline_method props
=
  let argument = reduce_tbexpr bbdfns argument in
  let psis: int list = map (fun (_,(i,_)) -> i) ps in
  let inline_method = match inline_method with
  | `Lazy -> 
    if 
      Flx_call.is_recursive uses callee or 
      is_tailed psis exes
    then `Eager 
    else `Lazy
  | `Eager -> `Eager
  in
  
  (* HACKERY *)
  
  (*
  let inline_method = `Eager in
  *)
  
  (*
  print_endline ("Inlining " ^ si callee ^ " into " ^ si caller);
  *)
  (*
  begin match inline_method with
  | `Eager ->
    print_endline ("Eager INLINING " ^ id ^ "<"^si callee^">("^sbe syms.dfns argument^") into " ^ si caller ^ " .. INPUT:");
  | `Lazy ->
    print_endline ("Lazy INLINING " ^ id ^ "<"^si callee^">("^sbe syms.dfns argument^") into " ^ si caller ^ " .. INPUT:");
  end
  ;
  iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) exes;
  *)
  let paramtype  =
    let pt = 
      let pts = map (fun (_,(_,t)) -> t) ps in
      match pts with
      | [x] -> x
      | x -> `BTYP_tuple x
    in
      varmap_subst varmap pt
  in
 
  let caller_vars = map (fun (s,i) -> `BTYP_var i) vs in
  let ge e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let end_label_uses = ref 0 in
  let end_label = 
    let end_index = !(syms.counter) in 
    incr syms.counter; 
    "_end_" ^ (si end_index) 
  in 

 
  let remap: bexe_t -> bexe_t list =  fun exe ->
  match exe with
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_prim (sr,i,ts, ge e2)]
  
  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_direct (sr,i,ts, ge e2)]

  | `BEXE_jump_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_jump_direct (sr,i,ts, ge e2)]

  | `BEXE_call_stack (sr,i,ts,e2)  -> assert false
    
  | `BEXE_call (sr,e1,e2)  -> [reduce_bexe bbdfns (`BEXE_call (sr,ge e1, ge e2))]
  | `BEXE_jump (sr,e1,e2)  -> assert false

  | `BEXE_loop (sr,i,e) -> assert false

  | `BEXE_ifgoto (sr,e,lab) -> [`BEXE_ifgoto (sr,ge e, relab lab)]
  | `BEXE_ifnotgoto (sr,e,lab) -> [`BEXE_ifnotgoto (sr,ge e, relab lab)]
  | `BEXE_fun_return (sr,e) -> [`BEXE_fun_return (sr, ge e)]
  | `BEXE_assign (sr,e1,e2) -> [`BEXE_assign (sr, ge e1, ge e2)]
  | `BEXE_init (sr,i,e) -> [`BEXE_init (sr,revar i, ge e)]
  | `BEXE_read (sr,i)  -> [`BEXE_read (sr, revar i)]

  | `BEXE_code (sr,s)  as x -> [x]
  | `BEXE_nonreturn_code (sr,s)  as x -> [x]
  | `BEXE_goto (sr,lab) -> [`BEXE_goto (sr, relab lab)]
  | `BEXE_proc_return sr as x -> 
    incr end_label_uses;
    [`BEXE_goto (sr,end_label)]

  | `BEXE_comment (sr,s) as x -> [x]
  | `BEXE_nop (sr,s) as x -> [x]
  | `BEXE_halt (sr,s) as x -> [x]
  | `BEXE_label (sr,lab) -> [`BEXE_label (sr, relab lab)]
  | `BEXE_begin as x -> [x]
  | `BEXE_end as x -> [x]
  in
    let kind = match inline_method with 
      | `Lazy -> "Lazy " 
      | `Eager -> "Eager " 
    in
    let rec fgc props s = 
      match props with
      | [] -> String.concat ", " s
      | `Generated x :: t -> fgc t (x :: s)
      | _ :: t -> fgc t s
    in
    let source = 
      let x = fgc props [] in
      if x <> "" then " (Generated "^x^")" else "" 
    in
    (* add a comment for non-generated functions .. *)
    let b = 
      ref 
      (
        if source = "" then 
          [`BEXE_comment (sr,(kind ^ "inline call to " ^ id ^source))] 
        else []
      ) 
    in
    if inline_method = `Eager then begin
      (* create a variable for the parameter *)
      let parameter = !(syms.counter) in 
      incr syms.counter; 
      let param_id = "_p" ^ si parameter in
      (*
      print_endline ("Parameter assigned index " ^ si parameter);
      *)

      (* create variables for parameter components *)
      (* Whaaa??
      if length ps > 1 then 
      for i = 1 to length ps do incr syms.counter done;
       (* Initialise parameter to argument, but only if
         the argument is not unit
      *)
      *)
      if length ps > 0 then
      begin
        let x = 
          if length ps > 1
          then begin
            let entry = `BBDCL_var (vs,paramtype) in
            let kids = 
              try Hashtbl.find child_map caller
              with Not_found -> [] 
            in
            Hashtbl.replace child_map caller (parameter::kids);
            Hashtbl.add bbdfns parameter (param_id,Some caller,sr,entry);
            `BEXE_init (sr,parameter,argument)
          end
          else 
            let vid,(k,_) = hd ps in
            let index = revar k in
            `BEXE_init (sr,index,argument)
        in
        b := x :: !b;
       
        (* unpack argument *)
        if length ps > 1 then
        let ts = map (fun (_,i) -> `BTYP_var i) vs in
        let p = `BEXPR_name (parameter,ts),paramtype in  
        let n = ref 0 in
        iter 
        (fun (vid,(ix,prjt)) ->
          let prjt = varmap_subst varmap prjt in
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,p),prjt) in
          let index = revar ix in
          let x = `BEXE_init (sr,index,prj) in
          b := x :: !b;
          incr n
        )
        ps
      end
      ;
      iter
      (fun exe -> 
        iter 
        (fun x -> b := x :: !b) 
        (remap exe)
      )
      exes
    end else if inline_method = `Lazy then begin
      let argmap = Hashtbl.create 97 in
      begin match length ps with
      | 0 -> ()
      | 1 -> 
        let vid,(k,_) = hd ps in
        let index = revar k in
        Hashtbl.add argmap index argument
      | _ -> 
        let ts = map (fun (_,i) -> `BTYP_var i) vs in
        let n = ref 0 in
        iter 
        (fun (vid,(ix,prjt)) ->
          let prjt = varmap_subst varmap prjt in
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,argument),prjt) in
          let index = revar ix in
          Hashtbl.add argmap index prj;
          incr n
        )
        ps
      end
      ;
      (*
      print_endline "argmap = ";
      Hashtbl.iter
      (fun i e -> 
        try
        let id,_,_,_ = Hashtbl.find bbdfns i in
        print_endline (id ^ "<"^ si i ^ "> --> " ^ sbe syms.dfns e)
        with Not_found -> print_endline ("Can't find index .." ^ si i)
      )
      argmap
      ;
      print_endline "----::----";
      *)
      let sba = if length ps = 0 then
        fun x -> b := x :: !b 
      else
        fun x -> b := subarg syms bbdfns argmap x :: !b 
      in
      iter
      (fun exe -> iter sba (remap exe))
      exes
      ;
      (*
      print_endline "Lazy evaluation, output=";
      iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
      *)
      (* substitute in kids too *)
      if length ps > 0 then begin
        let closure = descendants child_map callee in
        (*
           let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
           print_endline ("Closure is " ^ catmap " " si !cl);
        *)
        let kids = 
          IntSet.fold 
          (fun i s -> IntSet.add (revar i) s) 
          closure 
          IntSet.empty 
        in
        IntSet.iter (fun i -> 
          let id,parent,sr,entry = Hashtbl.find bbdfns i in
          match entry with 
          | `BBDCL_function (props,vs,ps,ret,exes) ->
            let exes = map (subarg syms bbdfns argmap) exes in 
            Hashtbl.replace bbdfns i 
            (id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes))
          | `BBDCL_procedure (props,vs,ps,exes) ->
            let exes = map (subarg syms bbdfns argmap) exes in 
            Hashtbl.replace bbdfns i 
            (id,parent,sr,`BBDCL_procedure (props,vs,ps,exes))
          | _ -> ()
        )
        kids
      end
    end
    ;
    let trail_jump = match !b with
      | `BEXE_goto (_,lab)::_ when lab = end_label -> true
      | _ -> false
    in
    if trail_jump then 
      (b := tl !b; decr end_label_uses)
    ;
    if !end_label_uses > 0 then
      b := (`BEXE_label (sr,end_label)) :: !b
    ;
    (*
    print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. OUTPUT:");
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
    print_endline ("END OUTPUT for " ^ id);
    *)
    !b


(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

  NOTE: this is a special case of the distributive law.

  f (if c then a else b) v => if c then f a v else f b v

*)

let call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument =
  (*
  print_endline "DOING CALL LIFTING";
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in
    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in

    (* replace all function returns with tailed calls *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_call_lift_" ^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    iter
      (function 
      | `BEXE_fun_return (sr,e) ->
        (* NOTE REVERSED ORDER *)
        let call_instr = 
          (match e with
          | `BEXPR_closure (i,ts),_ -> 
            `BEXE_call_direct (sr,i,ts,argument)
          | _ ->
            `BEXE_call (sr,e,argument)
          )
        in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    !body2 (* forward order *)

  | _ -> assert false

let inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a =
  (* TEMPORARY .. this should be allowed for unrolling but we do not do that yet *)
  assert (callee <> caller);
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    let id2,_,_,_ = Hashtbl.find bbdfns caller in
    (*
    print_endline 
    (
      "TAIL Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "] into " ^ id2 ^ "<" ^ si caller ^">"
    );
    flush stdout;
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in
    rev body

  | _ -> assert false

let inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a varindex =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline 
    (
      "Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"^
      "var="^ si varindex
    );
    flush stdout;
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in

    (*
    print_endline "Replace returns with inits";
    *)
    (* replace all function returns with variable initialisations *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_inline_" ^ Flx_name.cid_of_flxid id ^ "_"^ si n in
    let t = ref None in
    let end_label_used = ref false in
    iter
      (function 
      | `BEXE_fun_return (sr,((_,t') as e)) ->
        t := Some t';
        if not (!body2 == []) then begin
          body2 := `BEXE_goto (sr,end_label) :: !body2;
          end_label_used := true
        end
        ;
        let call_instr = `BEXE_init (sr,varindex,e) in
        body2 := call_instr :: !body2;

      | x -> body2 := x::!body2
      )
      body
    ;
    (* Ugghhh *)
    if !end_label_used then
      body2 := !body2 @ [`BEXE_label (sr,end_label)]
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    !body2 (* forward order *)

  | _ -> assert false

(* this routine changes direct applications into a named
  value plus an initialisation of that value: the argument
  should have already been processed bottom up, ie. already
  be in canonical form
*)
let bunravel syms bbdfns ts e = 
  let counter = syms.counter in 
  let vars = ref [] in
  let rec urv e = 
    match map_tbexpr ident urv ident e with
    | (`BEXPR_apply_direct _,t) as x ->
      let n = !counter in incr counter;
      print_endline ("New variable " ^ si n);
      vars := (n,x) :: !vars ;
      `BEXPR_name (n,ts),t
    | (`BEXPR_apply ((`BEXPR_apply_direct _,t'),a),t as x) ->
      print_endline ("Indirect apply direct!! " ^ sbe syms.dfns x);
      x
    | (`BEXPR_apply (f,a),t as x) ->
      print_endline ("Indirect apply " ^ sbe syms.dfns x);
      x

    | x -> x
  in
    let x = urv e in
    x,!vars

(* note u sr e must return exes in reverse order, this
  function however returns exes in forward order 
*)
let expand_exe syms bbdfns u exe = 
  let xs = 
    match exe with
    | `BEXE_call_prim (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_prim (sr,i,ts,e) :: xs

    | `BEXE_call_stack (sr,i,ts,e2) -> assert false

    | `BEXE_call_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_direct (sr,i,ts,e) :: xs

    | `BEXE_jump_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_jump_direct (sr,i,ts,e) :: xs
   
    | `BEXE_assign (sr,e1,e2) ->
      let e1,xs = u sr e1 in
      let e2,xs = u sr e2 in
      `BEXE_assign (sr,e1,e2) :: xs

    (* preserve call lift pattern ??*)
    | `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) :: xs2 @ xs1


    | `BEXE_call (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      reduce_bexe bbdfns (`BEXE_call (sr,e1,e2)) :: xs2 @ xs1

    | `BEXE_jump (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      reduce_bexe bbdfns (`BEXE_jump (sr,e1,e2)) :: xs2 @ xs1

    | `BEXE_loop (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_loop (sr,i,e) :: xs
   
    | `BEXE_ifgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifgoto (sr,e,lab) :: xs

    | `BEXE_ifnotgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifnotgoto (sr,e,lab) :: xs
   
    (* preserve tail call pattern -- used by both
       tail-rec eliminator 
       and by call lifter (which converts returns to calls)
    *)
    | `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) :: xs
    
    | `BEXE_fun_return (sr,e) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,e) :: xs
   
    | `BEXE_init (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_init (sr,i,e) :: xs
    
    | `BEXE_read _
    | `BEXE_label _
    | `BEXE_goto _
    | `BEXE_code _
    | `BEXE_nonreturn_code _
    | `BEXE_proc_return _
    | `BEXE_comment _
    | `BEXE_nop _
    | `BEXE_halt _
    | `BEXE_begin
    | `BEXE_end
      -> [exe]
  in 
    let xs = rev xs in
    xs

(* output in reverse order *)
let xmap_bexe syms (child_map,bbdfns) caller vs exe : bexe_t list = 
  let ts = map (fun (_,i)-> `BTYP_var i) vs in
  let u sr e = 
    let x,xs = bunravel syms bbdfns ts e in
    iter 
    (fun (i,((x,t) as e)) -> 
      let id = "_urv_" ^ si i  in
      (*
      print_endline (id ^ "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      let entry = `BBDCL_val (vs,t) in
      Hashtbl.add bbdfns i (id,Some caller,sr,entry);
      let kids = 
        try Hashtbl.find child_map caller
        with Not_found -> [] 
      in
      Hashtbl.replace child_map caller (i::kids)
    )
    xs
    ;
    let inits = map (fun (i,e)->`BEXE_init (sr,i,e)) xs in
    x,inits
  in
  expand_exe syms bbdfns u exe 

let heavy_inline_call syms (uses,child_map,bbdfns) 
  caller caller_vs callee ts argument id sr (props, vs, ps, exes)
=
  (*
  print_endline ("INLINING CALL to " ^ id ^"<"^ si callee^">("^sbe syms.dfns argument^")");
  print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
  print_endline ("Callee is " ^ id ^ "<"^si callee ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts);
  print_endline ("Callee vs=" ^ string_of_vs vs);
  *)
  let caller_vs_len = length caller_vs in
  let callee_vs_len = length vs in
  (*
  print_endline ("In the callee and its children,");
  print_endline ("The callee vs are elided and replaced by the caller vs");
  print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
  print_endline ("This works by instantiating the callee vs with the calls ts");
  *)
  assert(length vs = length ts);
  
  (*
  print_endline ("Found procedure "^id^": Inline it!");
  *)
  let relabel = mk_label_map syms exes in
  let varmap = mk_varmap vs ts in
  let revariable = reparent_children 
    syms (uses,child_map,bbdfns) 
    caller_vs callee_vs_len callee (Some caller) relabel varmap
  in
  let xs = gen_body syms (uses,child_map,bbdfns) id 
    varmap ps relabel revariable exes 
    argument sr caller callee caller_vs callee_vs_len `Lazy props
  in 
    rev xs (* forward order *)
   
(* Dependency analyser. This should be generalised,
but for now we only use it in tail calls.
 
We wish to discover what *local* vals an expression e in
some routine i depends on.

These are (a) the symbols manifestly used in the expression,
and (b) any variable used by any function that is called.

We can calculate this, expensively as the union of the
use closures of each symbol in the expression intersected
with the candidate locals.
*)


(* note returns exes in reverse order *)
(* This routine analyses an expression to see if it has  the form

  f a

If so it is replaced by v and a statement v = f a, then
this initialisation is replaced by the body of f 
with a replacing the parameter,
where returns are replaced by initialisations of v
and a goto the end of the routine.

Then in the special case the last line of the body
resolves to the form

  v = e'

the expression is replaced by e'. This works by a quirk,
that this code must have come from a sole tail return
in the body. If there were more than one return,
prior returns would be a return to a label after it,
however the inliner doesn't generate the label at the
end for a sole tail return, so we can assume this
is the only return.

The result leaves an expression in a place where
a tail call might be recognized, avoiding a temporary
which prevents simplistic patterns representing data
and control flow. Although its a hack, it is important
to ensure trivial functions have no overhead.

Note this routine, in itself, does NOT rescan anything:
there is no recursion -- other than the recursive traversal
of the original expression, done by the 'aux' function.
*)

let inlining_complete bbdfns i =
  let _,_,_,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (props,_,_,_,_)
  | `BBDCL_procedure (props,_,_,_) ->
    mem `Inlining_complete props
  | _ -> assert false
 
let rec special_inline syms (uses,child_map,bbdfns) caller_vs caller excludes sr e =
  (*
  print_endline ("Special inline " ^ sbe syms.dfns e); flush stdout;
  *)
  let exes' = ref [] in
  let id x = x in
  let rec aux e = match map_tbexpr id aux id e with
  | ((`BEXPR_apply_direct (callee,ts,a),t) as e)
  | (((`BEXPR_apply(  (`BEXPR_closure (callee,ts),_) ,a)),t) as e)
    when 
      not (mem callee excludes) 
    ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          ) &&
         (
            (* only inline a recursive call to a child *)
            not (Flx_call.is_recursive_call uses caller callee) ||
            is_child child_map caller callee
         )
        then 
            begin
              (*
              heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
              *)
              if inlining_complete bbdfns callee then begin
                (*
                print_endline ("Special inline " ^ si caller ^" calls " ^ si callee);
                *)
                (* GENERAL CASE -- we need to add a variable *)
                let urv = !(syms.counter) in incr (syms.counter);
                (* inline the code, replacing returns with variable inits *)
                let xs = 
                   inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a urv 
                in 
                match rev xs with
                (* SPECIAL CASE DETECTOR: if the inlined function
                  terminates with an initialisation of the new variable,
                  ignore the variable and use the value used to initialise
                  it instead. This is sure to be the result of the sole
                  trailing return. If there were another return, a
                  jump to the end of the function would be needed,
                  past this initialisation, which would require a label
                  at the end of the function

                  Note this is a bad form of 'apply lifting'.
                  We should be able to inline

                  f (g x)

                  by inlining g x, and replacing 'return e'
                  with 'v = f e' everywhere. instead we get
                  v = e in various places, then f v.

                  To do this right we need to see a double application.
                *)
                | [] -> assert false
                | `BEXE_init (sr,j,e') :: tail ->
                  assert (j==urv);
                  (*
                  print_endline "DETECTED SPECIAL CASE";
                  print_endline "Outputing tail:";
                  iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev tail);
                  print_endline ("Expr: " ^ sbe syms.dfns e');
                  *)
                  exes' := tail @ !exes';
                  e'
                | rxs -> 
                  let urvid = "_urv" ^ si urv in
                  add_child child_map caller urv;
                  add_use uses caller urv sr;
                  let entry = `BBDCL_val (caller_vs,t) in
                  Hashtbl.add bbdfns urv (urvid,Some caller,sr,entry);

                  exes' := rxs @ !exes';
                  let ts = map (fun (_,i)-> `BTYP_var i) caller_vs in
                  `BEXPR_name (urv,ts),t
              end
              else e
            end
        else e
      | _ -> e
      end
  
  | x -> x
  in 
   let e = aux e in (* we need left to right evaluation here ..*)
   e,!exes'


and heavy_inline_calls
  syms (uses,child_map,bbdfns)
  caller_vs caller excludes exes 
=
  let hic callee exes =
    (*
    print_endline "Rescanning ..";
    *)
    heavy_inline_calls syms (uses,child_map,bbdfns)
    caller_vs caller (callee::excludes) exes
  in

  (* The function ee applies the special inlining routine
    to all subexpressions of an expression, bottom up
    (that is, inside out). 
  *)
  
  let sinl sr e = special_inline syms (uses,child_map,bbdfns) caller_vs caller (caller::excludes) sr e in 
  let ee exe = expand_exe syms bbdfns sinl exe in
  let exes' = ref [] in (* reverse order *)
  iter  (* each exe *)
  (fun exeIN -> 
    let xs = ee exeIN in
    (*
    print_endline ("EXE[in] =" ^ string_of_bexe syms.dfns 0 exeIN);
    iter (fun x -> print_endline ("EXE[out]=" ^ string_of_bexe syms.dfns 0 x)) xs;
    print_endline "--";
    *)

    (*
      This code RESCANS the result of the special inliner.
      The special inliner only handles function applications,
      this code should NOT handle them because iteration might
      lead to infinite recurse ..??

      This means the 'special cases' handled must be
      disjoint.

      Unfortunately, when inlining a function, we first
      inline into the function, then dump the result and
      rescan it. Consequently the recursion stop applied
      which leaves a direct non-tail self call will be
      rescanned here, and the function will be unfolded
      again .. in that process we also redo the special
      inlining .. infinite recursion. This is stopped
      by the flag which prevents inlining into a function
      more than once .. but that doesn't work if the
      function is cloned.
    *)
    iter (fun exe ->
    match exe with
    | `BEXE_call_direct (sr,callee,ts,argument) 
      when not (mem callee excludes)
      ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      (*
      print_endline ("CALL DIRECT " ^ id ^ "<"^ si callee^">");
      *)
      begin match entry with
      | `BBDCL_procedure (props,vs,ps,exes) ->
        if 
         mem `Inlining_complete props &&
         not (mem `NoInline props) &&
         (
              mem `Inline props ||
              length exes <= syms.compiler_options.max_inline_length
         ) &&
         (
            (* only inline a recursive call to a child *)
            not (Flx_call.is_recursive_call uses caller callee) ||
            is_child child_map caller callee
         )
        then begin
          (*
          print_endline "INLINE CANDIDATE DETECTED - CALL";
          *)
          let xs = 
            heavy_inline_call syms (uses,child_map,bbdfns) 
            caller caller_vs callee ts argument id sr (props,vs,ps,exes)
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        end
        else
          exes' := exe :: !exes'

      | _ ->  exes' := exe :: !exes'
      end

    | `BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument) -> assert false
    | `BEXE_call (sr,(`BEXPR_apply_stack (callee,ts,a),_),argument) -> assert false

    | `BEXE_call (sr,(`BEXPR_apply_direct (callee,ts,a),_),argument)
      when not (mem callee excludes)
      ->
      (*
      print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
      print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
      print_endline (string_of_bexe syms.dfns 0 exe);
      print_endline ("Callee is " ^ si callee ^ " with ts = " ^ catmap "," (sbt syms.dfns) ts);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          mem `Inlining_complete props &&
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          ) &&
          (
            (* only inline a recursive call to a child *)
            not (Flx_call.is_recursive_call uses caller callee) ||
            is_child child_map caller callee
          )
        then 
          let xs = 
             call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument
          in 
            (* The recursion here is because the call is lifted,
            so there may be new calls that didn't previously
            exist, they need rescanning eg:
            
              call {if x then f else g endif} a 
              -->
              if x then call f a else call f a endif
            
            creates new calls to f and g when now need
            to be scanned (possibly for a further lift,
            possibly for call inlining)

            The hassle here is that we might unfold
            an unrelated recursive function multiple times
            as a side effect.
            *)
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling init: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          mem `Inlining_complete props &&
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          ) && 
          (
            (* only inline a recursive call to a child *)
            not (Flx_call.is_recursive_call uses caller callee) ||
            is_child child_map caller callee
          )
        then 
          begin
            let vid,vparent,vsr,ventry = Hashtbl.find bbdfns i in
            begin match ventry with
            | `BBDCL_tmp (vs,t) ->
              (*
              print_endline ("Downgrading temporary .." ^ si i);
              *)
              (* should this be a VAR or a VAL? *)
              Hashtbl.replace bbdfns i (vid,vparent,vsr,`BBDCL_var (vs,t))
            | _ -> ()
            end;
            let xs = 
               inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a i
            in 
              let xs = hic callee xs in
              exes' := rev xs @ !exes'
          end
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_fun_return (sr,(`BEXPR_apply((`BEXPR_closure(callee,ts),_),a),_)) -> assert false
    | `BEXE_fun_return (sr,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling return: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
              mem `Inline props ||
              length exes <= syms.compiler_options.max_inline_length
          ) && 
          (
            (* only inline a recursive call to a child *)
            not (Flx_call.is_recursive_call uses caller callee) ||
            is_child child_map caller callee
          )
        then begin
          (*
          heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
          *)
          if inlining_complete bbdfns callee then
            let xs = 
               (*
               print_endline ("Tail apply: " ^ string_of_bexe syms.dfns 0 exe);
               *)
               inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a
            in 
              let xs = hic callee xs in
              exes' := rev xs @ !exes'
          else
            exes' := exe :: !exes'
        end else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end
    | _ -> exes' := exe :: !exes' 
    )
    xs
  )
  exes
  ;
  rev !exes'


and fold_vars syms (uses,child_map,bbdfns) i ps exes = 
  let pset = fold_left (fun s (_,(i,_))-> IntSet.add i s) IntSet.empty ps in
  let kids = find_children child_map i in
  let id,_,_,_ = Hashtbl.find bbdfns i in
  (*
  print_endline ("\nFOLDing " ^ id ^ "<" ^ si i ^">");
  print_endline ("Kids = " ^ catmap ", " si kids);
  *)
  let descend = descendants child_map i in
  (*
  print_endline ("Descendants are " ^ string_of_intset descend);
  *)
  let locls = locals child_map uses i in
  (*
  print_endline ("Locals of " ^ si i ^ " are " ^ string_of_intset locls);
  print_endline "INPUT Code is";
  iter (fun exe -> print_endline (string_of_bexe syms.dfns 0 exe)) exes;
  *)

  let elim_pass exes =
    let count = ref 0 in
    let rec find_tassign inexes outexes =
      match inexes with
      | [] -> rev outexes
      | ((
        `BEXE_init (_,j,y)
        | `BEXE_assign (_, (`BEXPR_name (j,_),_),y)
      ) as x) :: t  when IntSet.mem j locls ->

        let id,_,_,_ = Hashtbl.find bbdfns j in
        (*
        print_endline ("CONSIDERING VARIABLE " ^ id ^ "<" ^ si j ^ "> -> " ^ sbe syms.dfns y);
        *)
        (* does uses include initialisations or not ..?? *)

        (* check if the variable is used by any descendants *)
        let nlocal_uses =
          IntSet.fold
          (fun child u ->
             let luses = Flx_call.use_closure uses child in
             u || IntSet.mem j luses
          )
          descend
          false 
        in
        if nlocal_uses then begin
          (*
          print_endline "VARIABLE USED NONLOCALLY";
          *)
          find_tassign t (x::outexes)
        end else

        (* count all local uses of the variable: there are no others *)
        let usecnt = 
          let luses = try Hashtbl.find uses i with Not_found -> [] in
          fold_left (fun u (k,sr) -> if k = j then u+1 else u) 0 luses
         in
        (*
        print_endline ("Use count = " ^ si usecnt);
        *)
        let setcnt = ref (if IntSet.mem j pset then 2 else 1) in
        let sets exe = 
          match exe with
           | `BEXE_init (_,k,_) when j = k -> incr setcnt
           | _ -> ()
        in
        iter sets t; iter sets outexes;
        (*
        print_endline ("Set count = " ^ si !setcnt);
        *)
        let yuses = Flx_call.expr_uses syms descend uses pset y in
        let delete_var () =
          let id,_,_,_ = Hashtbl.find bbdfns j in
          if syms.compiler_options.print_flag then
            print_endline ("ELIMINATING VARIABLE " ^ id ^ "<" ^ si j ^ "> -> " ^ sbe syms.dfns y);

          (* remove the variable *)
          Hashtbl.remove bbdfns j;
          remove_child child_map i j;
          remove_uses uses i j;
          incr count
        in
        let isvar = 
          match Hashtbl.find bbdfns j with
          | _,_,_,(`BBDCL_var _ | `BBDCL_tmp _) -> true
          | _,_,_,`BBDCL_val _ -> false
          | _ -> assert false
        in

        (* Cannot do anything with variables or multiply assigned values
          so skip to next instruction -- this is a tail-recursive call
        *)
        if isvar or !setcnt > 1 then begin
          (*
          print_endline "IS VAR or SETCNT > 1";
          *)
          find_tassign t (x::outexes)

        (* otherwise it is a value and it is set at most once *)

        (* it is not used anywhere (except the init) *)
        end else if usecnt = 1 then begin
          if syms.compiler_options.print_flag then
          print_endline "WARNING: unused variable found ..";
          delete_var();
          find_tassign t outexes

        (* OK, it is used at least once *)
        end else
        (* count elision of the init as 1 *)
        let rplcnt = ref 1 in
        let subi,rplimit =
          match y with
          | `BEXPR_tuple ys,_ ->
            print_endline "Tuple init found";
            let rec subi j ys e =
              match map_tbexpr ident (subi j ys) ident e with
              | `BEXPR_get_n (k, (`BEXPR_name(i,_),_) ),_ 
                when j = i ->
                (*
                print_endline ("Replacing " ^ sbe syms.dfns e);
                *)
                incr rplcnt; nth ys k
              | x -> x
            in subi j ys, length ys + 1
          | _ ->
            let rec subi j y e = 
              match map_tbexpr ident (subi j y) ident e with
              | `BEXPR_name (i,_),_ when j = i -> incr rplcnt; y
              | x -> x
            in subi j y, 2 (* take init into account *)
        in
        let elimi exe = 
          map_bexe ident subi ident ident ident exe 
        in
        let subs = ref true in
        let elim exes = map 
          (fun exe ->
          (*
          print_endline ("In Exe = " ^ string_of_bexe syms.dfns 2 exe);
          *)
          if !subs then 
          match exe with

          (* terminate substitution, return unmodified instr *)
          | `BEXE_goto _ 
          | `BEXE_proc_return _
          | `BEXE_label _ 
             -> subs:= false; exe

          (* return unmodified instr *)
          | `BEXE_begin
          | `BEXE_end
          | `BEXE_nop _
          | `BEXE_code _
          | `BEXE_nonreturn_code _
          | `BEXE_comment _
          | `BEXE_halt _ 
             -> exe

          (* conditional, check if y depends on init (tail rec) *)
           
          | `BEXE_assign (_,(`BEXPR_name (k,_),_),_)
          | `BEXE_read (_,k)
          | `BEXE_init (_,k,_) ->
             subs := not (IntSet.mem k yuses); 
             elimi exe
           
          (* return modified instr *)
          | `BEXE_ifgoto _
          | `BEXE_ifnotgoto _
             -> elimi exe

          (* terminate substitution, return modified instr *)
          | `BEXE_assign _
          | `BEXE_fun_return _
          | `BEXE_jump _
          | `BEXE_jump_direct _
          | `BEXE_loop _
          | `BEXE_call_prim _
          | `BEXE_call _
          | `BEXE_call_direct _
          | `BEXE_call_stack _
             -> subs := false; elimi exe
          else exe
          ) 
          exes 
        in
        let t' = elim t in
        if !rplcnt > rplimit then
          begin
            if syms.compiler_options.print_flag then
            print_endline (
              "Warning: replacement count " ^ 
              si !rplcnt ^
              " exceeds replacement limit " ^ 
              si rplimit
            );
            find_tassign t (x::outexes)
          end
        else if !rplcnt <> usecnt then
          begin
            if syms.compiler_options.print_flag then
            print_endline (
              "Warning: replacement count " ^ 
              si !rplcnt ^
              " not equal to usage count " ^ 
              si usecnt
            );
            find_tassign t (x::outexes)
          end
        else
          begin
            delete_var();
            find_tassign t' outexes
          end

      | h::t -> find_tassign t (h::outexes)
    in 
    !count,find_tassign exes []
  in
  let master_count = ref 0 in
  let iters = ref 0 in
  let rec elim exes =
    let count,exes = elim_pass exes in
    incr iters;
    master_count := !master_count + count;
    if count > 0 then elim exes else exes
  in
  let exes = elim exes in
  
  (*
  if syms.compiler_options.print_flag then
  *)
  if !master_count > 0 then begin
    if syms.compiler_options.print_flag then
    print_endline ("Removed " ^ si !master_count ^" variables in " ^ si !iters ^ " passes");
    (*
    print_endline "OUTPUT Code is";
    iter (fun exe -> print_endline (string_of_bexe syms.dfns 0 exe)) exes;
    *)
  end
  ;
  exes

and remove_unused_children syms (uses,child_map,bbdfns) i =
  (* all the descendants of a routine, excluding self *)
  let desc = descendants child_map i in

  (* everything used by this routine directly or indirectly *)
  let used = Flx_call.use_closure uses i in

  (* any desendants not used by this routine *)
  let unused_descendants = IntSet.diff desc used in

  (* remove the item *)
  IntSet.iter
  (fun i -> 
    begin 
      try 
        (* any parent disowns the child *)
        match Hashtbl.find bbdfns i with
        | _,Some parent,_,_ -> remove_child child_map parent i
        | _ -> ()
      with Not_found -> ()
    end
    ;

    (* remove from symbol table, child map, and usage map *)
    Hashtbl.remove bbdfns i;
    Hashtbl.remove child_map i;
    Hashtbl.remove uses i;
    (*
    print_endline ("REMOVED SYMBOL " ^ qualified_name_of_index syms.dfns i)
    *)
  )
  unused_descendants

and heavily_inline_bbdcl syms (uses,child_map,bbdfns) excludes i =
  let specs = 
    try Some (Hashtbl.find bbdfns i) 
    with Not_found -> None 
  in
  match specs with None -> () | Some spec ->
  match spec with
  | id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) ->
    if not (mem `Inlining_started props) then begin
      let props = `Inlining_started :: props in
      let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
      Hashtbl.replace bbdfns i data;

      (* inline into all children first *)
      let children = find_children child_map i in
      iter (fun i-> heavily_inline_bbdcl syms (uses, child_map, bbdfns) excludes i) children;

      (*
      print_endline ("HIB: Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in 
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = Flx_tailit.tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in 
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = Flx_cflow.chain_gotos exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
      Hashtbl.replace bbdfns i data;
      (*
      print_endline ("DONE Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      print_endline ("OPTIMISED PROCEDURE BODY: " ^ id ^ " :\n" ^ catmap "\n" (string_of_bexe syms.dfns 2) exes);
      *)
    end

  | id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) ->
    if not (mem `Inlining_started props) then begin
      let props = `Inlining_started :: props in
      let data = id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) in
      Hashtbl.replace bbdfns i data;

      (* inline into all children first *)
      let children = find_children child_map i in
      iter (fun i-> heavily_inline_bbdcl syms (uses, child_map, bbdfns) excludes i) children;

      (*
      print_endline ("HIB:Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      print_endline (id ^ " Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in 
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      (*
      print_endline ("Tailing " ^ si i);
      *)
      let exes = Flx_tailit.tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      
      (*
      print_endline (id^ " After tailing(2):\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in
      recal_exes_usage syms uses sr i ps exes;
      remove_unused_children syms (uses,child_map,bbdfns) i;
      let exes = Flx_cflow.chain_gotos exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) in
      Hashtbl.replace bbdfns i data;
      (*
      print_endline ("DONE Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      print_endline ("OPTIMISED FUNCTION BODY: " ^ id ^ " :\n" ^ catmap "\n" (string_of_bexe syms.dfns 2) exes);
      *)
    end
  | _ -> ()

let heavy_inlining syms  
  (child_map,bbdfns)
  (root:bid_t) 
  (bifaces:biface_t list) 
=
  (* make set of used things, initially empty *)
  (*
  let used = ref (Flx_use.full_use_closure syms bbdfns) in
  *)
  let used = ref (!(syms.roots)) in
  let (uses,usedby) = Flx_call.call_data syms bbdfns in

  while not (IntSet.is_empty !used) do
    let i = IntSet.choose !used in
    used := IntSet.remove i !used;
    heavily_inline_bbdcl syms (uses,child_map,bbdfns) [i] i
  done;

(* NOTES: this algorithm ONLY WORKS if inlining is attempted
in the corect order. Attempting to inline into children
before parents, when they're mutually recursive, spawns
clones infinitely, because we end up cloning a function
on the exclusion list, but not adding the clone to it.


NOTE!!!! THIS SHOULD BE FIXED NOW. WE NO LONGER
PERMIT INLINING RECURSIVE FUNCTIONS UNLESS THE CALL
IS TO A CHILD. A CALL TO SELF, PARENT OR SIBLING NEVER
DOES INLINING .. AND THERE ARE NO OTHER CASES.

INLINING KIDS IS MANDATORY FOR TAIL RECURSION OPTIMISATION.

So we end up recursing into the clone, and inlining
into it, which spawns more clones which are not
excluded, and haven't been inlined into yet.

This needs to be fixed so the algorithm is proven
to terminate and also be complete.

What we need (and is NOT implemented) is something like this:

Cloning nested functions is should not be needed in general.
If we proceed from leaves towards the root, we can eliminate
from each function any nested children, by simply inlining
them. So only variable children need cloning.

Two things stop this working: 

(a) non-inline functions and
(b) recursion.

The current algorithm has been hacked to only handle the
call graph from the roots. It used to consider the useage
closure, however that started to fail when I added 
'pre-assigned' slot numbers (AST_index). Doing that meant
the natural order of the set wasn't a topological sort
of the parent-child order.

Unfortunately, the remaining recursive descent doesn't
proceed into noinline functions. Although these shouldn't
be inlined into their caller, that doesn't mean functions
shouldn't be inlined into them. Iterating over the usage
closure ensured noinline functions would still be inlined
into.

Recursive functions are a bit different: they currently
allow inlining, with a recursion stopper preventing
infinite recursion.

Unfortunately with a double nesting like this:

  fun f() { fun g() { fun h() { f(); } h(); } g(); }

trying to inline g into f causes h to be cloned.
But trying to inline f into the clone of h retriggers
the descent, causing the clone to be recloned, and 
the recursion stopper doesn't prevent this, since it
isn't the same routine being inlined twice (just a clone
of it ..)

The thing is.. we HAVE to inline the original routine
AND the clone for completeness, since both may be
called independently, so even if we could clone the
recursion stoppers, it wouldn't work.

The only solution I can think of is to guarrantee that
you can only clone a routine that is inlined into
already (as fas as possible) so that no attempt will
be made to inline into the clone either.
--------------------------------------------------------------
Hum.... When I inline A -> B -> C -> A (all kid inlines) the 
inline of A into C is done first. This creates clones B' and C'.
When we rescan the code to be put into C, we would try to
inline B' into it, and C' into that .. but C' is a cloned sibling
of C, and not the same function. So we try to inline into C',
and inlining A is allowed there .. which causes an infinite
recursion.

*)
