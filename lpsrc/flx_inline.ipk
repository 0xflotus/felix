@head(1,"Inlining")
To make this work, we need a theorem.
First, the call rule is:
@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_call

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  unit

val descendants:
  (bid_t, bid_t list) Hashtbl.t ->
  bid_t ->
  IntSet.t
  
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use

module BidSet = IntSet

let find_children childmap parent =
  try Hashtbl.find childmap parent with Not_found -> []

let add_child childmap parent child =
  let kids = find_children childmap parent in
  Hashtbl.replace childmap parent (child::kids)

let string_of_vs vs =
  "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^ "]"

(* closure of index with respect to children, EXCLUDES self *)
let rec descendants child_map index =
  let d = ref IntSet.empty in
  let children = find_children child_map index in
  iter
  (fun i -> 
    if not (IntSet.mem i !d) then
    begin
      d := IntSet.add i !d;
      d := IntSet.union !d (descendants child_map i)
    end
  )
  children
  ;
  !d

let mk_remap counter d =
  let m = Hashtbl.create 97 in
  IntSet.iter
  (fun i -> 
    let n = !counter in 
    incr counter; 
    Hashtbl.add m i n
  )
  d
  ;
  m

(* replace callee type variables with callers *)
let vsplice caller_vars callee_vs_len ts = 
  if not (callee_vs_len <= length ts)
  then failwith 
  (
    "Callee_vs_len = " ^ 
    si callee_vs_len ^ 
    ", len vs/ts= " ^ 
    si (length ts) ^
    ", length caller_vars = " ^
    si (length caller_vars)
  )
  ;
  let rec aux lst n =  (* elide first n elements *)
    if n = 0 then lst 
    else aux (tl lst) (n-1) 
  in
  caller_vars @ aux ts callee_vs_len 


(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let ident x = x 

let remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e = 
  let auxt t = varmap_subst varmap t in
  let fixup i ts = 
    let ts = map auxt ts in
    try 
      let j= Hashtbl.find revariable i in 
      j, vsplice caller_vars callee_vs_len ts
    with Not_found -> i,ts
  in
  let rec aux e = match map_tbexpr ident aux auxt e with
  | `BEXPR_name (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_name (i,ts), auxt t

  | `BEXPR_ref (i,ts) as x,t ->
    let i,ts = fixup i ts in
    `BEXPR_ref (i,ts), auxt t

  | `BEXPR_closure (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_closure (i,ts), auxt t

  | `BEXPR_apply_direct (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_direct (i,ts,aux e), auxt t

  | `BEXPR_apply_stack (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_stack (i,ts,aux e), auxt t

  | `BEXPR_apply_prim (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_prim (i,ts,aux e), auxt t

  | `BEXPR_parse (e,gs),t ->
    let revar i = try Hashtbl.find revariable i with Not_found -> i in
    let e = aux e in
    let gs = map revar gs in
    `BEXPR_parse (e,gs), auxt t

  | x -> x
  in
    let a = aux e in
    (*
    print_endline ("replace " ^ sbe syms.dfns e ^ "-->" ^ sbe syms.dfns a);
    *)
    a

let remap_exe syms bbdfns relabel varmap revariable caller_vars callee_vs_len exe =
  (*
  print_endline ("remap_exe " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let ge e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_prim (sr,i,ts, ge e2)

  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_direct (sr,i,ts, ge e2)

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_stack (sr,i,ts, ge e2)
    
  | x -> map_bexe revar ge ident relab relab x

let remap_exes syms bbdfns relabel varmap revariable caller_vars callee_vs_len exes =
  map (remap_exe syms bbdfns relabel varmap revariable caller_vars callee_vs_len) exes

let reparent1 (syms:sym_state_t) (uses,child_map,bbdfns )
  relabel varmap revariable 
  caller_vs callee_vs_len index parent
=
  let splice vs = (* replace callee type variables with callers *)
    vsplice caller_vs callee_vs_len vs 
  in
  let sop = function
    | None -> "NONE?" 
    | Some i -> si i
  in
  let caller_vars = map (fun (s,i) -> `BTYP_var i) caller_vs in

  let auxt t = varmap_subst varmap t in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let remap_ps ps = map (fun (id,(i,t)) -> id,(revar i,auxt t)) ps in

  let k = Hashtbl.find revariable index in
  let rexes xs = remap_exes syms bbdfns relabel varmap revariable caller_vars callee_vs_len xs in
  let rexpr e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in 
  let id,old_parent,sr,entry = Hashtbl.find bbdfns index in
  (*
  print_endline 
  (
    "COPYING " ^ id ^ " index " ^ si index ^ " with old parent " ^
    sop old_parent ^ " to index " ^ si k ^ " with new parent " ^
    sop parent
  );
  *)
  begin match parent with
  | Some p ->
    let old_kids = try Hashtbl.find child_map p with Not_found -> [] in
    Hashtbl.replace child_map p (k::old_kids)
  | None -> ()
  end
  ;
  match entry with
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = rexes exes in
    let ps = remap_ps ps in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_procedure (props,splice vs,ps,exes));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls
     
  | `BBDCL_function (props, vs, ps, ret, exes) ->
    let ps = remap_ps ps in
    let exes = rexes exes in
    let ret = auxt ret in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_function (props,splice vs,ps,ret,exes));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls
 
  | `BBDCL_var (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_var (splice vs,auxt t))

  | `BBDCL_val (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_val (splice vs,auxt t))

  | `BBDCL_reglex (vs,ps,i,t,(a,j,h,m)) ->
    let t = auxt t in
    let ps = remap_ps ps in
    let vs = splice vs in
    let i = revar i in
    let h2 = Hashtbl.create 13 in
    Hashtbl.iter (fun x e -> Hashtbl.add h2 x (rexpr e)) h;
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_reglex (vs,ps,i,t,(a,j,h2,m)))

  | `BBDCL_regmatch (vs,ps,t,(a,j,h,m)) ->
    let t = auxt t in
    let ps = remap_ps ps in
    let vs = splice vs in
    let h2 = Hashtbl.create 13 in
    Hashtbl.iter (fun x e -> Hashtbl.add h2 x (rexpr e)) h;
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_regmatch (vs,ps,t,(a,j,h2,m)))
  
  | `BBDCL_glr (vs,t,(prd,exes)) -> 
    let t = auxt t in
    let vs = splice vs in
    let exes = rexes exes in
    let remap_glr g = match g with 
      | `Nonterm js -> `Nonterm (map revar js)
      | x -> x (* terminal codes are invariant *)
    in
    let prd = map (fun (s,g) -> s,remap_glr g) prd in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_glr (vs,t,(prd,exes)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls

  | _ -> syserr sr ("[reparent1] Unexpected bbdcl " ^ string_of_bbdcl syms.dfns entry index)

(* make a copy all the descendants of i, changing any
  parent which is i to the given new parent
*)

let reparent_children syms (uses,child_map,bbdfns) 
  caller_vs callee_vs_len index parent relabel varmap 
=
  let pp p = match p with None -> "NONE" | Some i -> si i in
  (*
  print_endline 
  (
    "Renesting children of callee " ^ si index ^ 
    " to caller " ^ pp parent ^
     "\n  -- Caller vs len = " ^ si (length caller_vs) ^
     "\n  -- Callee vs len = " ^ si (callee_vs_len)
  );
  *)
  let closure = descendants child_map index in
  (*
  let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
  print_endline ("Closure is " ^ catmap " " si !cl);
  *)
  let revariable = mk_remap syms.counter closure in
  IntSet.iter
  (fun i -> 
    let old_parent = 
      match Hashtbl.find bbdfns i with id,oldp,_,_ -> oldp
    in
    let new_parent: bid_t option =
      match old_parent with
      | None -> assert false
      | Some p ->
        if p = index then parent
        else Some (Hashtbl.find revariable p)
    in
    reparent1 syms (uses,child_map,bbdfns) relabel varmap revariable 
    caller_vs callee_vs_len i new_parent
  )
  closure
  ;
  if syms.compiler_options.print_flag then begin
    Hashtbl.iter
    (fun i j ->
      print_endline ("//Reparent " ^ si j ^ " <-- " ^ si i)
    )
    revariable
  end
  ;
  revariable

 
(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h

let idt t = t 
let subarg syms bbdfns argmap exe =
  (*
  print_endline ("[subarg] Checking " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let rec rpl x = match map_tbexpr ident rpl idt x with
  (* No need to check ts or type here *)
  | (`BEXPR_name (i,_),_) as x -> 
    (try 
      let x' = Hashtbl.find argmap i in
      (*
      print_endline ("Replacing variable " ^ si i ^ " with " ^ sbe syms.dfns x');
      *)
      x'
      with Not_found -> x)
  | x -> x
  in
  reduce_bexe bbdfns (map_bexe idt rpl idt idt idt exe)

(* NOTE: result is in reversed order *)
let gen_body syms (uses,child_map,bbdfns) id 
  varmap ps relabel revariable exes argument 
  sr caller callee vs callee_vs_len inline_method
=
  let argument = reduce_tbexpr bbdfns argument in
  let inline_method = match inline_method with
  | `Lazy -> if Flx_call.is_recursive uses callee then `Eager else `Lazy
  | `Eager -> `Eager
  in
  (*
  begin match inline_method with
  | `Eager ->
    print_endline ("Eager INLINING " ^ id ^ "<"^si callee^">("^sbe syms.dfns argument^") into " ^ si caller ^ " .. INPUT:");
  | `Lazy ->
    print_endline ("Lazy INLINING " ^ id ^ "<"^si callee^">("^sbe syms.dfns argument^") into " ^ si caller ^ " .. INPUT:");
  end
  ;
  iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) exes;
  *)
  let paramtype  =
    let pt = 
      let pts = map (fun (_,(_,t)) -> t) ps in
      match pts with
      | [x] -> x
      | x -> `BTYP_tuple x
    in
      varmap_subst varmap pt
  in
 
  let caller_vars = map (fun (s,i) -> `BTYP_var i) vs in
  let ge e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let end_label_uses = ref 0 in
  let end_label = 
    let end_index = !(syms.counter) in 
    incr syms.counter; 
    "_end_" ^ (si end_index) 
  in 

 
  let remap: bexe_t -> bexe_t list =  fun exe ->
  match exe with
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_prim (sr,i,ts, ge e2)]
  
  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_direct (sr,i,ts, ge e2)]

  | `BEXE_jump_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_jump_direct (sr,i,ts, ge e2)]

  | `BEXE_call_stack (sr,i,ts,e2)  -> assert false
    
  | `BEXE_call (sr,e1,e2)  -> [reduce_bexe bbdfns (`BEXE_call (sr,ge e1, ge e2))]
  | `BEXE_jump (sr,e1,e2)  -> assert false

  | `BEXE_loop (sr,i,e) -> assert false

  | `BEXE_ifgoto (sr,e,lab) -> [`BEXE_ifgoto (sr,ge e, relab lab)]
  | `BEXE_ifnotgoto (sr,e,lab) -> [`BEXE_ifnotgoto (sr,ge e, relab lab)]
  | `BEXE_fun_return (sr,e) -> [`BEXE_fun_return (sr, ge e)]
  | `BEXE_assign (sr,e1,e2) -> [`BEXE_assign (sr, ge e1, ge e2)]
  | `BEXE_init (sr,i,e) -> [`BEXE_init (sr,revar i, ge e)]
  | `BEXE_read (sr,i)  -> [`BEXE_read (sr, revar i)]

  (*
  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_regmatch (sr, ge e,(a,sc,h',tr))]
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))]
  *)

  | `BEXE_code (sr,s)  as x -> [x]
  | `BEXE_nonreturn_code (sr,s)  as x -> [x]
  | `BEXE_goto (sr,lab) -> [`BEXE_goto (sr, relab lab)]
  | `BEXE_proc_return sr as x -> 
    incr end_label_uses;
    [`BEXE_goto (sr,end_label)]

  | `BEXE_comment (sr,s) as x -> [x]
  | `BEXE_nop (sr,s) as x -> [x]
  | `BEXE_halt (sr,s) as x -> [x]
  | `BEXE_label (sr,lab) -> [`BEXE_label (sr, relab lab)]
  in
    let kind = match inline_method with 
      | `Lazy -> "Lazy " 
      | `Eager -> "Eager " 
    in
    let b = ref [`BEXE_comment (sr,(kind ^ "inline call to " ^ id))] in
    if inline_method = `Eager then begin
      (* create a variable for the parameter *)
      let parameter = !(syms.counter) in 
      incr syms.counter; 
      let param_id = "_p" ^ si parameter in
      (*
      print_endline ("Parameter assigned index " ^ si parameter);
      *)

      (* create variables for parameter components *)
      (* Whaaa??
      if length ps > 1 then 
      for i = 1 to length ps do incr syms.counter done;
       (* Initialise parameter to argument, but only if
         the argument is not unit
      *)
      *)
      if length ps > 0 then
      begin
        let x = 
          if length ps > 1
          then begin
            let entry = `BBDCL_var (vs,paramtype) in
            let kids = 
              try Hashtbl.find child_map caller
              with Not_found -> [] 
            in
            Hashtbl.replace child_map caller (parameter::kids);
            Hashtbl.add bbdfns parameter (param_id,Some caller,sr,entry);
            `BEXE_init (sr,parameter,argument)
          end
          else 
            let vid,(k,_) = hd ps in
            let index = revar k in
            `BEXE_init (sr,index,argument)
        in
        b := x :: !b;
       
        (* unpack argument *)
        if length ps > 1 then
        let ts = map (fun (_,i) -> `BTYP_var i) vs in
        let p = `BEXPR_name (parameter,ts),paramtype in  
        let n = ref 0 in
        iter 
        (fun (vid,(ix,prjt)) ->
          let prjt = varmap_subst varmap prjt in
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,p),prjt) in
          let index = revar ix in
          let x = `BEXE_init (sr,index,prj) in
          b := x :: !b;
          incr n
        )
        ps
      end
      ;
      iter
      (fun exe -> 
        iter 
        (fun x -> b := x :: !b) 
        (remap exe)
      )
      exes
    end else if inline_method = `Lazy then begin
      let argmap = Hashtbl.create 97 in
      begin match length ps with
      | 0 -> ()
      | 1 -> 
        let vid,(k,_) = hd ps in
        let index = revar k in
        Hashtbl.add argmap index argument
      | _ -> 
        let ts = map (fun (_,i) -> `BTYP_var i) vs in
        let n = ref 0 in
        iter 
        (fun (vid,(ix,prjt)) ->
          let prjt = varmap_subst varmap prjt in
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,argument),prjt) in
          let index = revar ix in
          Hashtbl.add argmap index prj;
          incr n
        )
        ps
      end
      ;
      (*
      print_endline "argmap = ";
      Hashtbl.iter
      (fun i e -> 
        try
        let id,_,_,_ = Hashtbl.find bbdfns i in
        print_endline (id ^ "<"^ si i ^ "> --> " ^ sbe syms.dfns e)
        with Not_found -> print_endline ("Can't find index .." ^ si i)
      )
      argmap
      ;
      print_endline "----::----";
      *)
      let sba = if length ps = 0 then
        fun x -> b := x :: !b 
      else
        fun x -> b := subarg syms bbdfns argmap x :: !b 
      in
      iter
      (fun exe -> iter sba (remap exe))
      exes
      ;
      (*
      print_endline "Lazy evaluation, output=";
      iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
      *)
      (* substitute in kids too *)
      if length ps > 0 then begin
        let closure = descendants child_map callee in
        (*
           let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
           print_endline ("Closure is " ^ catmap " " si !cl);
        *)
        let kids = 
          IntSet.fold 
          (fun i s -> IntSet.add (revar i) s) 
          closure 
          IntSet.empty 
        in
        IntSet.iter (fun i -> 
          let id,parent,sr,entry = Hashtbl.find bbdfns i in
          match entry with 
          | `BBDCL_function (props,vs,ps,ret,exes) ->
            let exes = map (subarg syms bbdfns argmap) exes in 
            Hashtbl.replace bbdfns i 
            (id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes))
          | `BBDCL_procedure (props,vs,ps,exes) ->
            let exes = map (subarg syms bbdfns argmap) exes in 
            Hashtbl.replace bbdfns i 
            (id,parent,sr,`BBDCL_procedure (props,vs,ps,exes))
          | _ -> ()
        )
        kids
      end
    end
    ;
    let trail_jump = match !b with
      | `BEXE_goto (_,lab)::_ when lab = end_label -> true
      | _ -> false
    in
    if trail_jump then 
      (b := tl !b; decr end_label_uses)
    ;
    if !end_label_uses > 0 then
      b := (`BEXE_label (sr,end_label)) :: !b
    ;
    (*
    print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. OUTPUT:");
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
    print_endline ("END OUTPUT for " ^ id);
    *)
    !b


(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

  NOTE: this is a special case of the distributive law.

  f (if c then a else b) v => if c then f a v else f b v

*)

let call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument =
  (*
  print_endline "DOING CALL LIFTING";
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in
    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy
    in

    (* replace all function returns with tailed calls *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_call_lift_" ^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    iter
      (function 
      | `BEXE_fun_return (sr,e) ->
        (* NOTE REVERSED ORDER *)
        let call_instr = 
          (match e with
          | `BEXPR_closure (i,ts),_ -> 
            `BEXE_call_direct (sr,i,ts,argument)
          | _ ->
            `BEXE_call (sr,e,argument)
          )
        in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    !body2 (* forward order *)

  | _ -> assert false

let inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline 
    (
      "TAIL Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"
    );
    flush stdout;
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy
    in
    rev body

  | _ -> assert false

let inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a varindex =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline 
    (
      "Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"^
      "var="^ si varindex
    );
    flush stdout;
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy
    in

    (*
    print_endline "Replace returns with inits";
    *)
    (* replace all function returns with variable initialisations *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_inline_" ^ id ^ "_"^ si n in
    let t = ref None in
    let end_label_used = ref false in
    iter
      (function 
      | `BEXE_fun_return (sr,((_,t') as e)) ->
        t := Some t';
        if not (!body2 == []) then begin
          body2 := `BEXE_goto (sr,end_label) :: !body2;
          end_label_used := true
        end
        ;
        let call_instr = `BEXE_init (sr,varindex,e) in
        body2 := call_instr :: !body2;

      | x -> body2 := x::!body2
      )
      body
    ;
    (* Ugghhh *)
    if !end_label_used then
      body2 := !body2 @ [`BEXE_label (sr,end_label)]
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    !body2 (* forward order *)

  | _ -> assert false

(* this routine changes direct applications into a named
  value plus an initialisation of that value: the argument
  should have already been processed bottom up, ie. already
  be in canonical form
*)
let bunravel syms bbdfns ts e = 
  let counter = syms.counter in 
  let vars = ref [] in
  let rec urv e = 
    match map_tbexpr ident urv ident e with
    | (`BEXPR_apply_direct _,t) as x ->
      let n = !counter in incr counter;
      print_endline ("New variable " ^ si n);
      vars := (n,x) :: !vars ;
      `BEXPR_name (n,ts),t
    | (`BEXPR_apply ((`BEXPR_apply_direct _,t'),a),t as x) ->
      print_endline ("Indirect apply direct!! " ^ sbe syms.dfns x);
      x
    | (`BEXPR_apply (f,a),t as x) ->
      print_endline ("Indirect apply " ^ sbe syms.dfns x);
      x

    | x -> x
  in
    let x = urv e in
    x,!vars

(* note u sr e must return exes in reverse order, this
  function however returns exes in forward order 
*)
let expand_exe syms bbdfns u exe = 
  let xs = 
    match exe with
    | `BEXE_call_prim (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_prim (sr,i,ts,e) :: xs

    | `BEXE_call_stack (sr,i,ts,e2) -> assert false

    | `BEXE_call_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_direct (sr,i,ts,e) :: xs

    | `BEXE_jump_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_jump_direct (sr,i,ts,e) :: xs
   
    | `BEXE_assign (sr,e1,e2) ->
      let e1,xs = u sr e1 in
      let e2,xs = u sr e2 in
      `BEXE_assign (sr,e1,e2) :: xs

    (* preserve call lift pattern ??*)
    | `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) :: xs2 @ xs1


    | `BEXE_call (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      reduce_bexe bbdfns (`BEXE_call (sr,e1,e2)) :: xs2 @ xs1

    | `BEXE_jump (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      reduce_bexe bbdfns (`BEXE_jump (sr,e1,e2)) :: xs2 @ xs1

    | `BEXE_loop (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_loop (sr,i,e) :: xs
   
    | `BEXE_ifgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifgoto (sr,e,lab) :: xs

    | `BEXE_ifnotgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifnotgoto (sr,e,lab) :: xs
   
    (* preserve tail call pattern -- used by both
       tail-rec eliminator 
       and by call lifter (which converts returns to calls)
    *)
    | `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) :: xs
    
    | `BEXE_fun_return (sr,e) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,e) :: xs
   
    | `BEXE_init (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_init (sr,i,e) :: xs
    
    (*
    | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
      let e,xs = u sr e in
      `BEXE_regmatch (sr,e,(a,sc,h,tr)) :: xs
   
    | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
      let p1,xs1 = u sr p1 in
      let p2,xs2 = u sr p2 in
      `BEXE_reglex(sr,p1,p2,(a,sc,h,tr)) :: xs1 @ xs2
    *)

    | `BEXE_read _
    | `BEXE_label _
    | `BEXE_goto _
    | `BEXE_code _
    | `BEXE_nonreturn_code _
    | `BEXE_proc_return _
    | `BEXE_comment _
    | `BEXE_nop _
    | `BEXE_halt _
      -> [exe]
  in 
    let xs = rev xs in
    xs

(* output in reverse order *)
let xmap_bexe syms (child_map,bbdfns) caller vs exe : bexe_t list = 
  let ts = map (fun (_,i)-> `BTYP_var i) vs in
  let u sr e = 
    let x,xs = bunravel syms bbdfns ts e in
    iter 
    (fun (i,((x,t) as e)) -> 
      let id = "_urv_" ^ si i  in
      (*
      print_endline (id ^ "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      let entry = `BBDCL_val (vs,t) in
      Hashtbl.add bbdfns i (id,Some caller,sr,entry);
      let kids = 
        try Hashtbl.find child_map caller
        with Not_found -> [] 
      in
      Hashtbl.replace child_map caller (i::kids)
    )
    xs
    ;
    let inits = map (fun (i,e)->`BEXE_init (sr,i,e)) xs in
    x,inits
  in
  expand_exe syms bbdfns u exe 

let unravel syms (child_map,bbdfns) i vs exes =
  (*
  print_endline ( "BEFORE UNRAVEL: " ^ catmap "\n" (string_of_bexe syms.dfns 0) exes) ;
  *)
  let exes = concat ( map (xmap_bexe syms (child_map,bbdfns) i vs) exes) in
  (*
  print_endline ( "AFTER  UNRAVEL: " ^ catmap "\n" (string_of_bexe syms.dfns 0) exes) ;
  *)
  exes


let heavy_inline_call syms (uses,child_map,bbdfns) 
  caller caller_vs callee ts argument id sr (props, vs, ps, exes)
=
  (*
  print_endline ("INLINING CALL to " ^ id ^"<"^ si callee^">("^sbe syms.dfns argument^")");
  print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
  print_endline ("Callee is " ^ id ^ "<"^si callee ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts);
  print_endline ("Callee vs=" ^ string_of_vs vs);
  *)
  let caller_vs_len = length caller_vs in
  let callee_vs_len = length vs in
  (*
  print_endline ("In the callee and its children,");
  print_endline ("The callee vs are elided and replaced by the caller vs");
  print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
  print_endline ("This works by instantiating the callee vs with the calls ts");
  *)
  assert(length vs = length ts);
  
  (*
  print_endline ("Found procedure "^id^": Inline it!");
  *)
  let relabel = mk_label_map syms exes in
  let varmap = mk_varmap vs ts in
  let revariable = reparent_children 
    syms (uses,child_map,bbdfns) 
    caller_vs callee_vs_len callee (Some caller) relabel varmap
  in
  let xs = gen_body syms (uses,child_map,bbdfns) id 
    varmap ps relabel revariable exes 
    argument sr caller callee caller_vs callee_vs_len `Lazy
  in 
    rev xs (* forward order *)
   
let tailit syms (child_map,bbdfns) this sr ps vs exes : bexe_t list = 
  let ts' = map (fun (_,i) -> `BTYP_var i) vs in
  let parameter = !(syms.counter) in incr syms.counter;
  let param_used = ref false in
  let jump_done = ref false in
  let start_label = "start_" ^ si parameter in
  let paramtype  =
    match map (fun (_,(_,t)) -> t) ps with
    | [x] -> x
    | x -> `BTYP_tuple x
  in

  (* note reverse order *)
  (* Weirdly, this works for BOTH tail calls
    and tail applies
  *)
  let cal_tail_call e = 
    match length ps with
    | 0 -> 
      [
        `BEXE_goto (sr,start_label);
        `BEXE_comment (sr,"tail rec call (0)")
      ]
    | 1 ->
      let (_,(k,_)) = hd ps in
      [
        `BEXE_goto (sr,start_label);
        `BEXE_init (sr,k,e);
        `BEXE_comment (sr,"tail rec call (1)")
      ]
    | _ ->

      [
        `BEXE_goto (sr,start_label);
        `BEXE_comment (sr,"tail rec call (2)")
      ]
      @
      begin
        param_used := true;
        let p = `BEXPR_name (parameter,ts'),paramtype in  
        let n = ref 0 in
        map
        (fun (_,(ix,prjt)) ->
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,p),prjt) in
          incr n;
          `BEXE_init (sr,ix,prj)
        )
        ps
      end
      @
      [
        `BEXE_init (sr,parameter,e);
        `BEXE_comment (sr,"tail call")
      ]
  in
  let rec aux tail res = match tail with
  | `BEXE_call_direct (sr,i,ts,a) :: tail 
    when (i,ts)=(this,ts') && Flx_cflow.tailable exes [] tail
    ->
     (*
     print_endline ("--> Tail rec call " ^ si this);
     *)
     jump_done := true;
     let res = cal_tail_call a @ res
     in aux tail res

  | `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,a),_)) :: tail 
    when (i,ts)=(this,ts') 
    ->
     (*
     print_endline ("--> Tail rec apply " ^ si this);
     *)
     jump_done := true;
     let res = cal_tail_call a @ res
     in aux tail res

  | (`BEXE_call_direct (sr,i,ts,a)) as x :: tail  ->
    (*
    print_endline ("Untailed call " ^ si i ^ "["^catmap "," (sbt syms.dfns) ts^"]");
    print_endline ("This = " ^ si this);
    print_endline ("ts'=" ^"["^catmap "," (sbt syms.dfns) ts'^"]");
    print_endline "TAIL=";
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) tail;
    print_endline "-- end of tail --";
    *)
    aux tail (x::res)
    
  | [] -> rev res (* forward order *)
  | h :: t  -> aux t (h::res)
  in 
    let exes = aux exes [] in

    (* if parameter used, create a variable *)
    if !param_used then
    begin
      let entry = `BBDCL_var (vs,paramtype) in
      let kids = 
        try Hashtbl.find child_map this
        with Not_found -> [] 
      in
      Hashtbl.replace child_map this (parameter::kids);
      let id = "_trp_" ^ si  parameter in
      Hashtbl.add bbdfns parameter (id,Some this,sr,entry);
    end
    ;
    (* return with posssible label at start *)
    let exes = 
      if !jump_done
      then `BEXE_label (sr,start_label) :: exes
      else exes
    in
      (*
      print_endline ("Tailed exes = ");
      iter (fun exe -> print_endline (string_of_bexe syms.dfns 0 exe)) exes;
      *)
      exes
      
(* note returns exes in reverse order *)
let rec special_inline syms (uses,child_map,bbdfns) caller_vs caller excludes sr e =
  (*
  print_endline ("Special inline " ^ sbe syms.dfns e); flush stdout;
  *)
  let exes' = ref [] in
  let id x = x in
  let rec aux e = match map_tbexpr id aux id e with
  | ((`BEXPR_apply_direct (callee,ts,a),t) as e)
  | (((`BEXPR_apply(  (`BEXPR_closure (callee,ts),_) ,a)),t) as e)
    when 
      not (mem callee excludes) && 
      not (Flx_call.is_recursive uses callee)
    ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
            begin
              (* GENERAL CASE -- we need to add a variable *)
              let urv = !(syms.counter) in incr (syms.counter);
              (* inline the code, replacing returns with variable inits *)
              let xs = 
                 inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a urv 
              in 
              match rev xs with
              (* SPECIAL CASE DETECTOR: if the inlined function
                terminates with an initialisation of the new variable,
                ignore the variable and use the value used to initialise
                it instead. This is sure to be the result of the sole
                trailing return. If there were another return, a
                jump to the end of the function would be needed,
                past this initialisation, which would require a label
                at the end of the function

                Note this is a bad form of 'apply lifting'.
                We should be able to inline

                f (g x)

                by inlining g x, and replacing 'return e'
                with 'v = f e' everywhere. instead we get
                v = e in various places, then f v.

                To do this right we need to see a double application.
              *)
              | [] -> assert false
              | `BEXE_init (sr,j,e') :: tail ->
                assert (j==urv);
                (*
                print_endline "DETECTED SPECIAL CASE";
                print_endline "Outputing tail:";
                iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev tail);
                print_endline ("Expr: " ^ sbe syms.dfns e');
                *)
                exes' := tail @ !exes';
                e'
              | rxs -> 
                let urvid = "_urv" ^ si urv in
                add_child child_map caller urv;
                let entry = `BBDCL_val (caller_vs,t) in
                Hashtbl.add bbdfns urv (urvid,Some caller,sr,entry);

                exes' := rxs @ !exes';
                let ts = map (fun (_,i)-> `BTYP_var i) caller_vs in
                `BEXPR_name (urv,ts),t
            end
        else e
      | _ -> e
      end
  
  | x -> x
  in 
   let e = aux e in (* we need left to right evaluation here ..*)
   e,!exes'


and tail_bbdcl syms (child_map,bbdfns) i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) ->
    let exes = tailit syms (child_map,bbdfns) i sr ps vs exes in
    let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
    Hashtbl.replace bbdfns i data

  | _ -> ()


and heavy_inline_calls
  syms (uses,child_map,bbdfns)
  caller_vs caller excludes exes 
=
  let hic callee exes =
    (*
    print_endline "Rescanning ..";
    *)
    heavy_inline_calls syms (uses,child_map,bbdfns)
    caller_vs caller (callee::excludes) exes
  in
  let sinl sr e = special_inline syms (uses,child_map,bbdfns) caller_vs caller excludes sr e in 
  let ee exe = expand_exe syms bbdfns sinl exe in
  let exes' = ref [] in (* reverse order *)
  iter 
  (fun exeIN -> 
    let xs = ee exeIN in
    (*
    print_endline ("EXE[in] =" ^ string_of_bexe syms.dfns 0 exeIN);
    iter (fun x -> print_endline ("EXE[out]=" ^ string_of_bexe syms.dfns 0 x)) xs;
    print_endline "--";
    *)
    iter (fun exe ->
    match exe with
    | `BEXE_call_direct (sr,callee,ts,argument) 
      when not (mem callee excludes)
      ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      (*
      print_endline ("CALL DIRECT " ^ id ^ "<"^ si callee^">");
      *)
      begin match entry with
      | `BBDCL_procedure (props,vs,ps,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then begin
          (*
          print_endline "INLINE CANDIDATE DETECTED - CALL";
          *)
          let xs = 
            heavy_inline_call syms (uses,child_map,bbdfns) 
            caller caller_vs callee ts argument id sr (props,vs,ps,exes)
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        end
        else
          exes' := exe :: !exes'

      | _ ->  exes' := exe :: !exes'
      end

    | `BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument) -> assert false
    | `BEXE_call (sr,(`BEXPR_apply_stack (callee,ts,a),_),argument) -> assert false

    | `BEXE_call (sr,(`BEXPR_apply_direct (callee,ts,a),_),argument)
      when not (mem callee excludes)
      ->
      (*
      print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
      print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
      print_endline (string_of_bexe syms.dfns 0 exe);
      print_endline ("Callee is " ^ si callee ^ " with ts = " ^ catmap "," (sbt syms.dfns) ts);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument
          in 
            (* The recursion here is because the call is lifted,
            so there may be new calls that didn't previously
            exist, they need rescanning eg:
            
              call {if x then f else g endif} a 
              -->
              if x then call f a else call f a endif
            
            creates new calls to f and g when now need
            to be scanned (possibly for a further lift,
            possibly for call inlining)

            The hassle here is that we might unfold
            an unrelated recursive function multiple times
            as a side effect.
            *)
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling init: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a i
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_fun_return (sr,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling return: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end
    | _ -> exes' := exe :: !exes' 
    )
    xs
    (*
    | _ -> 
     (* exes' := exe :: !exes' *)
     exes' := rev (ee exe) @ !exes'
    *)
  )
  exes
  ;
  rev !exes'


and heavy_inline_applies
  syms (uses,child_map,bbdfns)
  caller_vs caller excludes exes 
=
  let hia callee exes = heavy_inline_applies 
    syms (uses,child_map,bbdfns)
    caller_vs caller (callee::excludes) exes 
  in
  let exes' = ref [] in (* reverse order *)
  iter 
  (fun exe ->
    match exe with
    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a i
          in 
            let xs = hia callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_fun_return (sr,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a
          in 
            exes' := rev (hia callee xs) @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end
    
    | _ -> exes' := exe :: !exes'
  )
  exes
  ;
  rev !exes'


and heavily_inline_bbdcl syms (uses,child_map,bbdfns) excludes i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) ->
    if not (mem `Inlining_complete props) then begin
      (*
      print_endline ("HIB: Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      *)
      (*
      print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = tailit syms (child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      
      (*
      let exes = unravel syms (child_map,bbdfns) i vs exes in
      print_endline (id ^ " After unravelling:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      let exes = heavy_inline_applies syms (uses,child_map,bbdfns) vs i excludes exes in
      print_endline (id ^ " After inlining applies:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = Flx_cflow.chain_gotos exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
      Hashtbl.replace bbdfns i data;
      (*
      print_endline ("DONE Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      *)
    end

  | id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) ->
    if not (mem `Inlining_complete props) then begin
      (*
      print_endline ("HIB:Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      *)
      (*
      print_endline (id ^ " Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = tailit syms (child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      
      (*
      let exes = unravel syms (child_map,bbdfns) i vs exes in
      (*
      print_endline (id ^ " After unravelling:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = heavy_inline_applies syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining applies:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      *)
      
      let exes = tailit syms (child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id^ " After tailing(2):\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = Flx_cflow.chain_gotos exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) in
      Hashtbl.replace bbdfns i data;
      (*
      print_endline ("DONE Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      *)
    end
  | _ -> ()

let heavy_inlining syms  
  (child_map,bbdfns)
  (root:bid_t) 
  (bifaces:biface_t list) 
=
  (* make set of used things, initially empty *)
  let used = ref IntSet.empty in

  let use i = Flx_use.uses syms used bbdfns i in

  (*
  (* add root items to set, then add items it uses *)
  IntSet.iter use !(syms.roots)
  ;
  *)

  used := !(syms.roots);
  
  let (uses,usedby) = Flx_call.call_data bbdfns in
  (*
  print_endline "Inlining heavy pass1";
  *)
  while not (IntSet.is_empty !used) do
    let i = IntSet.choose !used in
    used := IntSet.remove i !used;
    heavily_inline_bbdcl syms (uses,child_map,bbdfns) [i] i
  done;

(* NOTES: this algorithm ONLY WORKS if inlining is attempted
in the corect order. Attempting to inline into children
before parents, when they're mutually recursive, spawns
clones infinitely, because we end up cloning a function
on the exclusion list, but not adding the clone to it.

So we end up recursing into the clone, and inlining
into it, which spawns more clones which are not
excluded, and haven't been inlined into yet.

This needs to be fixed so the algorithm is proven
to terminate and also be complete.

What we need (and is NOT implemented) is something like this:

Cloning nested functions is should not be needed in general.
If we proceed from leaves towards the root, we can eliminate
from each function any nested children, by simply inlining
them. So only variable children need cloning.

Two things stop this working: 

(a) non-inline functions and
(b) recursion.

The current algorithm has been hacked to only handle the
call graph from the roots. It used to consider the useage
closure, however that started to fail when I added 
'pre-assigned' slot numbers (AST_index). Doing that meant
the natural order of the set wasn't a topological sort
of the parent-child order.

Unfortunately, the remaining recursive descent doesn't
proceed into noinline functions. Although these shouldn't
be inlined into their caller, that doesn't mean functions
shouldn't be inlined into them. Iterating over the usage
closure ensured noinline functions would still be inlined
into.

Recursive functions are a bit different: they currently
allow inlining, with a recursion stopper preventing
infinite recursion.

Unfortunately with a double nesting like this:

  fun f() { fun g() { fun h() { f(); } h(); } g(); }

trying to inline g into f causes h to be cloned.
But trying to inline f into the clone of h retriggers
the descent, causing the clone to be recloned, and 
the recursion stopper doesn't prevent this, since it
isn't the same routine being inlined twice (just a clone
of it ..)

The thing is.. we HAVE to inline the original routine
AND the clone for completeness, since both may be
called independently, so even if we could clone the
recursion stoppers, it wouldn't work.

The only solution I can think of is to guarrantee that
you can only clone a routine that is inlined into
already (as fas as possible) so that no attempt will
be made to inline into the clone either.

*)
