@head(1,"Inlining")
To make this work, we need a theorem.
First, the call rule is:
@begin_displayed_code()
A procedure may only call a child of an ancestor.
@end_displayed_code()
Note an ancestor is itself or a parent
of any ancestor: that is, a procedure
is an ancestor of itself. A parentless toplevel
procedure is considered a child of a dummy root
to make this simple formulation work.
@p()
It is clear we can inline any sibling
by copying its body, and duplicating
any children -- variables and nested
procedures included. This is because
any references to its parent will
go through from the caller, since
they have the same parent.
@p()
Clearly this result extends to any
child of any parent.

@h = tangler("src/flx_inline.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_call

val heavy_inlining:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  unit

val descendants:
  (bid_t, bid_t list) Hashtbl.t ->
  bid_t ->
  IntSet.t
  
@h = tangler("src/flx_inline.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use

module BidSet = IntSet

let intset_of_list ls = 
  fold_left (fun s i -> IntSet.add i s) IntSet.empty ls
  
(* this only updates the uses table not the usedby table,
  because inlining changes usage (obviously).
  we need it in particular for the is_recursive test,
  so that tail recursions which have been eliminated
  won't cause the test to return a false positive
*)

let string_of_intset s =
  "{ " ^
  IntSet.fold (fun i x -> x ^ si i ^ " ") s "" ^
  "}"

let recal_exes_usage uses i exes =
  (* delete old entry *)
  (try Hashtbl.remove uses i with Not_found -> ());
  iter (Flx_call.cal_exe_usage uses i) exes

let is_tailed ps exes =
  try iter
  (function 
    | `BEXE_init(_,i,_) when mem i ps -> raise Not_found 
    | _ -> ()
  )
  exes;
  false
  with Not_found -> true
  
let find_children childmap parent =
  try Hashtbl.find childmap parent with Not_found -> []

let is_child childmap parent child =
  mem child (find_children childmap parent)

let add_child childmap parent child =
  let kids = find_children childmap parent in
  Hashtbl.replace childmap parent (child::kids)

let remove_child childmap parent child =
  let kids = find_children childmap parent in
  let kids = filter (fun i -> i <> child) kids in
  Hashtbl.replace childmap parent kids

let string_of_vs vs =
  "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^ "]"

(* closure of index with respect to children, EXCLUDES self *)
let rec descendants child_map index =
  let d = ref IntSet.empty in
  let children = find_children child_map index in
  iter
  (fun i -> 
    if not (IntSet.mem i !d) then
    begin
      d := IntSet.add i !d;
      d := IntSet.union !d (descendants child_map i)
    end
  )
  children
  ;
  !d

let useset uses i =
  let u = try Hashtbl.find uses i with Not_found -> [] in
  fold_left (fun s (i,_) -> IntSet.add i s) IntSet.empty u
  
(* find all the variables of a function i which
   are not used by children, this is the kids
   minus just the union of everything used by the 
   child functions.
*)
let locals child_map uses i =
  let kids = intset_of_list (find_children child_map i) in
  let desc = descendants child_map i in
  let u =
    IntSet.fold 
    (fun i s -> 
      let u = useset uses i in
      IntSet.union s u
    )
    desc
    IntSet.empty
  in
  IntSet.diff kids u

(* remove all uses of j from i *)
let remove_uses uses i j =
  try
    let u = Hashtbl.find uses i in
    let u = filter (fun (k,sr) -> j <> k) u in
    Hashtbl.replace uses i u
  with Not_found -> ()

let add_use uses i j sr =
  let u = try Hashtbl.find uses i with Not_found -> [] in
  Hashtbl.replace uses i ((j,sr) :: u)
  
let mk_remap counter d =
  let m = Hashtbl.create 97 in
  IntSet.iter
  (fun i -> 
    let n = !counter in 
    incr counter; 
    Hashtbl.add m i n
  )
  d
  ;
  m

(* replace callee type variables with callers *)
let vsplice caller_vars callee_vs_len ts = 
  if not (callee_vs_len <= length ts)
  then failwith 
  (
    "Callee_vs_len = " ^ 
    si callee_vs_len ^ 
    ", len vs/ts= " ^ 
    si (length ts) ^
    ", length caller_vars = " ^
    si (length caller_vars)
  )
  ;
  let rec aux lst n =  (* elide first n elements *)
    if n = 0 then lst 
    else aux (tl lst) (n-1) 
  in
  caller_vars @ aux ts callee_vs_len 


(* varmap is the *typevariable* remapper, 
 revariable remaps indices
*)
let ident x = x 

let remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e = 
  let auxt t = varmap_subst varmap t in
  let fixup i ts = 
    let ts = map auxt ts in
    try 
      let j= Hashtbl.find revariable i in 
      j, vsplice caller_vars callee_vs_len ts
    with Not_found -> i,ts
  in
  let rec aux e = match map_tbexpr ident aux auxt e with
  | `BEXPR_name (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_name (i,ts), auxt t

  | `BEXPR_ref (i,ts) as x,t ->
    let i,ts = fixup i ts in
    `BEXPR_ref (i,ts), auxt t

  | `BEXPR_closure (i,ts),t ->
    let i,ts = fixup i ts in
    `BEXPR_closure (i,ts), auxt t

  | `BEXPR_apply_direct (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_direct (i,ts,aux e), auxt t

  | `BEXPR_apply_stack (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_stack (i,ts,aux e), auxt t

  | `BEXPR_apply_prim (i,ts,e),t ->
    let i,ts = fixup i ts in
    `BEXPR_apply_prim (i,ts,aux e), auxt t

  | `BEXPR_parse (e,gs),t ->
    let revar i = try Hashtbl.find revariable i with Not_found -> i in
    let e = aux e in
    let gs = map revar gs in
    `BEXPR_parse (e,gs), auxt t

  | x -> x
  in
    let a = aux e in
    (*
    print_endline ("replace " ^ sbe syms.dfns e ^ "-->" ^ sbe syms.dfns a);
    *)
    a

let remap_exe syms bbdfns relabel varmap revariable caller_vars callee_vs_len exe =
  (*
  print_endline ("remap_exe " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let ge e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_prim (sr,i,ts, ge e2)

  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_direct (sr,i,ts, ge e2)

  | `BEXE_call_stack (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    `BEXE_call_stack (sr,i,ts, ge e2)
    
  | x -> map_bexe revar ge ident relab relab x

let remap_exes syms bbdfns relabel varmap revariable caller_vars callee_vs_len exes =
  map (remap_exe syms bbdfns relabel varmap revariable caller_vars callee_vs_len) exes

let reparent1 (syms:sym_state_t) (uses,child_map,bbdfns )
  relabel varmap revariable 
  caller_vs callee_vs_len index parent
=
  let splice vs = (* replace callee type variables with callers *)
    vsplice caller_vs callee_vs_len vs 
  in
  let sop = function
    | None -> "NONE?" 
    | Some i -> si i
  in
  let caller_vars = map (fun (s,i) -> `BTYP_var i) caller_vs in

  let auxt t = varmap_subst varmap t in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let remap_ps ps = map (fun (id,(i,t)) -> id,(revar i,auxt t)) ps in

  let k = Hashtbl.find revariable index in
  let rexes xs = remap_exes syms bbdfns relabel varmap revariable caller_vars callee_vs_len xs in
  let rexpr e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in 
  let id,old_parent,sr,entry = Hashtbl.find bbdfns index in
  (*
  print_endline 
  (
    "COPYING " ^ id ^ " index " ^ si index ^ " with old parent " ^
    sop old_parent ^ " to index " ^ si k ^ " with new parent " ^
    sop parent
  );
  *)
  begin match parent with
  | Some p ->
    let old_kids = try Hashtbl.find child_map p with Not_found -> [] in
    Hashtbl.replace child_map p (k::old_kids)
  | None -> ()
  end
  ;
  match entry with
  | `BBDCL_procedure (props,vs,ps,exes) ->
    let exes = rexes exes in
    let ps = remap_ps ps in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_procedure (props,splice vs,ps,exes));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls
     
  | `BBDCL_function (props, vs, ps, ret, exes) ->
    let ps = remap_ps ps in
    let exes = rexes exes in
    let ret = auxt ret in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_function (props,splice vs,ps,ret,exes));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls
 
  | `BBDCL_var (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_var (splice vs,auxt t))

  | `BBDCL_val (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_val (splice vs,auxt t))

  | `BBDCL_tmp (vs,t) ->
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_tmp (splice vs,auxt t))

  | `BBDCL_reglex (vs,ps,i,t,(a,j,h,m)) ->
    let t = auxt t in
    let ps = remap_ps ps in
    let vs = splice vs in
    let i = revar i in
    let h2 = Hashtbl.create 13 in
    Hashtbl.iter (fun x e -> Hashtbl.add h2 x (rexpr e)) h;
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_reglex (vs,ps,i,t,(a,j,h2,m)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls


  | `BBDCL_regmatch (vs,ps,t,(a,j,h,m)) ->
    let t = auxt t in
    let ps = remap_ps ps in
    let vs = splice vs in
    let h2 = Hashtbl.create 13 in
    Hashtbl.iter (fun x e -> Hashtbl.add h2 x (rexpr e)) h;
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_regmatch (vs,ps,t,(a,j,h2,m)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls

  
  | `BBDCL_glr (vs,t,(prd,exes)) -> 
    let t = auxt t in
    let vs = splice vs in
    let exes = rexes exes in
    let remap_glr g = match g with 
      | `Nonterm js -> `Nonterm (map revar js)
      | x -> x (* terminal codes are invariant *)
    in
    let prd = map (fun (s,g) -> s,remap_glr g) prd in
    Hashtbl.add bbdfns k (id,parent,sr,`BBDCL_glr (vs,t,(prd,exes)));
    let calls = try Hashtbl.find uses index with Not_found -> [] in
    let calls = map (fun (j,sr) -> revar j,sr) calls in
    Hashtbl.add uses k calls

  | _ -> syserr sr ("[reparent1] Unexpected bbdcl " ^ string_of_bbdcl syms.dfns entry index)

(* make a copy all the descendants of i, changing any
  parent which is i to the given new parent
*)

let reparent_children syms (uses,child_map,bbdfns) 
  caller_vs callee_vs_len index parent relabel varmap 
=
  let pp p = match p with None -> "NONE" | Some i -> si i in
  (*
  print_endline 
  (
    "Renesting children of callee " ^ si index ^ 
    " to caller " ^ pp parent ^
     "\n  -- Caller vs len = " ^ si (length caller_vs) ^
     "\n  -- Callee vs len = " ^ si (callee_vs_len)
  );
  *)
  let closure = descendants child_map index in
  (*
  let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
  print_endline ("Closure is " ^ catmap " " si !cl);
  *)
  let revariable = mk_remap syms.counter closure in
  IntSet.iter
  (fun i -> 
    let old_parent = 
      match Hashtbl.find bbdfns i with id,oldp,_,_ -> oldp
    in
    let new_parent: bid_t option =
      match old_parent with
      | None -> assert false
      | Some p ->
        if p = index then parent
        else Some (Hashtbl.find revariable p)
    in
    reparent1 syms (uses,child_map,bbdfns) relabel varmap revariable 
    caller_vs callee_vs_len i new_parent
  )
  closure
  ;
  if syms.compiler_options.print_flag then begin
    Hashtbl.iter
    (fun i j ->
      print_endline ("//Reparent " ^ si j ^ " <-- " ^ si i)
    )
    revariable
  end
  ;
  revariable

 
(* Heavy inlining routine. This routine can inline
any procedure. The basic operation is emit the body
of the target procedure. We have to do the following to
make it all work.

(1) Each declared label is replaced by a fresh one,
and all jumps to these labels modified accordingly.

(2) Variables are replaced by fresh ones. This requires
making additions to the output bound tables. References
to the variables are modified. Note the parent is the
caller now.

(3) Paremeters are replaced like variables, initialised
by the arguments.

(4) Any type variables instantiated by the call must
also be instantiated in body expressions, as well as
the typing of any generated variables.

(5) If the procedure has any nested procedures, they
also must be replaced in toto by fresh ones, reparented
to the caller so that any calls to them will access
the fresh variables in the caller.

Note that the cache of children of the caller will
be wrong after the inlining (it may have acquired new
variables or procedure children).

Note that this inlining procedure is NOT recursive!
Its a flat one level inlining. This ensures recursive
calls don't cause an infinite unrolling, and hopefully
prevent gross bloat.
*)

let mk_label_map syms exes = 
  let h = Hashtbl.create 97 in
  let aux = function
  | `BEXE_label (sr,s) -> 
    let n = !(syms.counter) in
    incr syms.counter;
    let s' =  "_" ^ si n in
    Hashtbl.add h s s'
  | _ -> ()
  in
    iter aux exes;
    h

let idt t = t 
let subarg syms bbdfns argmap exe =
  (*
  print_endline ("[subarg] Checking " ^ string_of_bexe syms.dfns 0 exe);
  *)
  let rec rpl x = match map_tbexpr ident rpl idt x with
  (* No need to check ts or type here *)
  | (`BEXPR_name (i,_),_) as x -> 
    (try 
      let x' = Hashtbl.find argmap i in
      (*
      print_endline ("Replacing variable " ^ si i ^ " with " ^ sbe syms.dfns x');
      *)
      x'
      with Not_found -> x)
  | x -> x
  in
  reduce_bexe bbdfns (map_bexe idt rpl idt idt idt exe)

(* NOTE: result is in reversed order *)
let gen_body syms (uses,child_map,bbdfns) id 
  varmap ps relabel revariable exes argument 
  sr caller callee vs callee_vs_len inline_method props
=
  let argument = reduce_tbexpr bbdfns argument in
  let psis: int list = map (fun (_,(i,_)) -> i) ps in
  let inline_method = match inline_method with
  | `Lazy -> 
    if 
      Flx_call.is_recursive uses callee or 
      is_tailed psis exes
    then `Eager 
    else `Lazy
  | `Eager -> `Eager
  in
  (*
  begin match inline_method with
  | `Eager ->
    print_endline ("Eager INLINING " ^ id ^ "<"^si callee^">("^sbe syms.dfns argument^") into " ^ si caller ^ " .. INPUT:");
  | `Lazy ->
    print_endline ("Lazy INLINING " ^ id ^ "<"^si callee^">("^sbe syms.dfns argument^") into " ^ si caller ^ " .. INPUT:");
  end
  ;
  iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) exes;
  *)
  let paramtype  =
    let pt = 
      let pts = map (fun (_,(_,t)) -> t) ps in
      match pts with
      | [x] -> x
      | x -> `BTYP_tuple x
    in
      varmap_subst varmap pt
  in
 
  let caller_vars = map (fun (s,i) -> `BTYP_var i) vs in
  let ge e = remap_expr syms bbdfns varmap revariable caller_vars callee_vs_len e in
  let relab s = try Hashtbl.find relabel s with Not_found -> s in
  let revar i = try Hashtbl.find revariable i with Not_found -> i in
  let end_label_uses = ref 0 in
  let end_label = 
    let end_index = !(syms.counter) in 
    incr syms.counter; 
    "_end_" ^ (si end_index) 
  in 

 
  let remap: bexe_t -> bexe_t list =  fun exe ->
  match exe with
  | `BEXE_call_prim (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_prim (sr,i,ts, ge e2)]
  
  | `BEXE_call_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_call_direct (sr,i,ts, ge e2)]

  | `BEXE_jump_direct (sr,i,ts,e2)  -> 
    let fixup i ts = 
      let auxt t = varmap_subst varmap t in
      let ts = map auxt ts in
      try 
        let j= Hashtbl.find revariable i in 
        j, vsplice caller_vars callee_vs_len ts
      with Not_found -> i,ts
    in
    let i,ts = fixup i ts in
    [`BEXE_jump_direct (sr,i,ts, ge e2)]

  | `BEXE_call_stack (sr,i,ts,e2)  -> assert false
    
  | `BEXE_call (sr,e1,e2)  -> [reduce_bexe bbdfns (`BEXE_call (sr,ge e1, ge e2))]
  | `BEXE_jump (sr,e1,e2)  -> assert false

  | `BEXE_loop (sr,i,e) -> assert false

  | `BEXE_ifgoto (sr,e,lab) -> [`BEXE_ifgoto (sr,ge e, relab lab)]
  | `BEXE_ifnotgoto (sr,e,lab) -> [`BEXE_ifnotgoto (sr,ge e, relab lab)]
  | `BEXE_fun_return (sr,e) -> [`BEXE_fun_return (sr, ge e)]
  | `BEXE_assign (sr,e1,e2) -> [`BEXE_assign (sr, ge e1, ge e2)]
  | `BEXE_init (sr,i,e) -> [`BEXE_init (sr,revar i, ge e)]
  | `BEXE_read (sr,i)  -> [`BEXE_read (sr, revar i)]

  (*
  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_regmatch (sr, ge e,(a,sc,h',tr))]
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter 
    (fun k v -> Hashtbl.add h' k (ge v))
    h
    ;
    [`BEXE_reglex (sr, ge p1, ge p2,(a,sc,h',tr))]
  *)

  | `BEXE_code (sr,s)  as x -> [x]
  | `BEXE_nonreturn_code (sr,s)  as x -> [x]
  | `BEXE_goto (sr,lab) -> [`BEXE_goto (sr, relab lab)]
  | `BEXE_proc_return sr as x -> 
    incr end_label_uses;
    [`BEXE_goto (sr,end_label)]

  | `BEXE_comment (sr,s) as x -> [x]
  | `BEXE_nop (sr,s) as x -> [x]
  | `BEXE_halt (sr,s) as x -> [x]
  | `BEXE_label (sr,lab) -> [`BEXE_label (sr, relab lab)]
  | `BEXE_begin as x -> [x]
  | `BEXE_end as x -> [x]
  in
    let kind = match inline_method with 
      | `Lazy -> "Lazy " 
      | `Eager -> "Eager " 
    in
    let rec fgc props s = 
      match props with
      | [] -> String.concat ", " s
      | `Generated x :: t -> fgc t (x :: s)
      | _ :: t -> fgc t s
    in
    let source = 
      let x = fgc props [] in
      if x <> "" then " (Generated "^x^")" else "" 
    in
    (* add a comment for non-generated functions .. *)
    let b = 
      ref 
      (
        if source = "" then 
          [`BEXE_comment (sr,(kind ^ "inline call to " ^ id ^source))] 
        else []
      ) 
    in
    if inline_method = `Eager then begin
      (* create a variable for the parameter *)
      let parameter = !(syms.counter) in 
      incr syms.counter; 
      let param_id = "_p" ^ si parameter in
      (*
      print_endline ("Parameter assigned index " ^ si parameter);
      *)

      (* create variables for parameter components *)
      (* Whaaa??
      if length ps > 1 then 
      for i = 1 to length ps do incr syms.counter done;
       (* Initialise parameter to argument, but only if
         the argument is not unit
      *)
      *)
      if length ps > 0 then
      begin
        let x = 
          if length ps > 1
          then begin
            let entry = `BBDCL_var (vs,paramtype) in
            let kids = 
              try Hashtbl.find child_map caller
              with Not_found -> [] 
            in
            Hashtbl.replace child_map caller (parameter::kids);
            Hashtbl.add bbdfns parameter (param_id,Some caller,sr,entry);
            `BEXE_init (sr,parameter,argument)
          end
          else 
            let vid,(k,_) = hd ps in
            let index = revar k in
            `BEXE_init (sr,index,argument)
        in
        b := x :: !b;
       
        (* unpack argument *)
        if length ps > 1 then
        let ts = map (fun (_,i) -> `BTYP_var i) vs in
        let p = `BEXPR_name (parameter,ts),paramtype in  
        let n = ref 0 in
        iter 
        (fun (vid,(ix,prjt)) ->
          let prjt = varmap_subst varmap prjt in
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,p),prjt) in
          let index = revar ix in
          let x = `BEXE_init (sr,index,prj) in
          b := x :: !b;
          incr n
        )
        ps
      end
      ;
      iter
      (fun exe -> 
        iter 
        (fun x -> b := x :: !b) 
        (remap exe)
      )
      exes
    end else if inline_method = `Lazy then begin
      let argmap = Hashtbl.create 97 in
      begin match length ps with
      | 0 -> ()
      | 1 -> 
        let vid,(k,_) = hd ps in
        let index = revar k in
        Hashtbl.add argmap index argument
      | _ -> 
        let ts = map (fun (_,i) -> `BTYP_var i) vs in
        let n = ref 0 in
        iter 
        (fun (vid,(ix,prjt)) ->
          let prjt = varmap_subst varmap prjt in
          let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,argument),prjt) in
          let index = revar ix in
          Hashtbl.add argmap index prj;
          incr n
        )
        ps
      end
      ;
      (*
      print_endline "argmap = ";
      Hashtbl.iter
      (fun i e -> 
        try
        let id,_,_,_ = Hashtbl.find bbdfns i in
        print_endline (id ^ "<"^ si i ^ "> --> " ^ sbe syms.dfns e)
        with Not_found -> print_endline ("Can't find index .." ^ si i)
      )
      argmap
      ;
      print_endline "----::----";
      *)
      let sba = if length ps = 0 then
        fun x -> b := x :: !b 
      else
        fun x -> b := subarg syms bbdfns argmap x :: !b 
      in
      iter
      (fun exe -> iter sba (remap exe))
      exes
      ;
      (*
      print_endline "Lazy evaluation, output=";
      iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
      *)
      (* substitute in kids too *)
      if length ps > 0 then begin
        let closure = descendants child_map callee in
        (*
           let cl = ref [] in IntSet.iter (fun i -> cl := i :: !cl) closure;
           print_endline ("Closure is " ^ catmap " " si !cl);
        *)
        let kids = 
          IntSet.fold 
          (fun i s -> IntSet.add (revar i) s) 
          closure 
          IntSet.empty 
        in
        IntSet.iter (fun i -> 
          let id,parent,sr,entry = Hashtbl.find bbdfns i in
          match entry with 
          | `BBDCL_function (props,vs,ps,ret,exes) ->
            let exes = map (subarg syms bbdfns argmap) exes in 
            Hashtbl.replace bbdfns i 
            (id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes))
          | `BBDCL_procedure (props,vs,ps,exes) ->
            let exes = map (subarg syms bbdfns argmap) exes in 
            Hashtbl.replace bbdfns i 
            (id,parent,sr,`BBDCL_procedure (props,vs,ps,exes))
          | _ -> ()
        )
        kids
      end
    end
    ;
    let trail_jump = match !b with
      | `BEXE_goto (_,lab)::_ when lab = end_label -> true
      | _ -> false
    in
    if trail_jump then 
      (b := tl !b; decr end_label_uses)
    ;
    if !end_label_uses > 0 then
      b := (`BEXE_label (sr,end_label)) :: !b
    ;
    (*
    print_endline ("INLINING " ^ id ^ " into " ^ si caller ^ " .. OUTPUT:");
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev !b);
    print_endline ("END OUTPUT for " ^ id);
    *)
    !b


(* CALL LIFTING. What this does is transform a call:

  call (f a) arg

  by replacing it with the body of f,
  in which every 
  
  return x 
  
  is replaced by 
  
  call x arguemnt

  This converts  f from a function returning
  a procedure, to a procedure which executes that
  procedure.

  NOTE: this is a special case of the distributive law.

  f (if c then a else b) v => if c then f a v else f b v

*)

let call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument =
  (*
  print_endline "DOING CALL LIFTING";
  *)
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline ("Found procedure "^id^": Inline it!");
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in
    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in

    (* replace all function returns with tailed calls *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_call_lift_" ^ si n in
    body2 := `BEXE_label (sr,end_label) :: !body2;
    iter
      (function 
      | `BEXE_fun_return (sr,e) ->
        (* NOTE REVERSED ORDER *)
        let call_instr = 
          (match e with
          | `BEXPR_closure (i,ts),_ -> 
            `BEXE_call_direct (sr,i,ts,argument)
          | _ ->
            `BEXE_call (sr,e,argument)
          )
        in
        body2 := `BEXE_goto (sr,end_label) :: !body2;
        body2 := call_instr :: !body2;
      | x -> body2 := x::!body2
      )
      body
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    !body2 (* forward order *)

  | _ -> assert false

let inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline 
    (
      "TAIL Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"
    );
    flush stdout;
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in
    rev body

  | _ -> assert false

let inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a varindex =
  let id,parent,sr,entry = Hashtbl.find bbdfns callee in
  match entry with 
  | `BBDCL_function (props,vs,ps,ret,exes) ->
    (*
    print_endline 
    (
      "Inlining function "^id^
      "<"^si callee^">"^
      "[" ^ catmap "," (sbt syms.dfns) ts ^ "]"^
      "var="^ si varindex
    );
    flush stdout;
    *)
    let relabel = mk_label_map syms exes in
    let varmap = mk_varmap vs ts in
    let callee_vs_len = length vs in

    let revariable = reparent_children 
      syms (uses,child_map,bbdfns) 
      caller_vs callee_vs_len callee (Some caller) relabel varmap
    in

    (* use the inliner to handle the heavy work *)
    let body =
      gen_body syms (uses,child_map,bbdfns) id varmap ps relabel revariable 
      exes a sr caller callee caller_vs callee_vs_len `Lazy props
    in

    (*
    print_endline "Replace returns with inits";
    *)
    (* replace all function returns with variable initialisations *)
    let body2 = ref [] in
    let n = !(syms.counter) in incr (syms.counter);
    let end_label = "_end_inline_" ^ id ^ "_"^ si n in
    let t = ref None in
    let end_label_used = ref false in
    iter
      (function 
      | `BEXE_fun_return (sr,((_,t') as e)) ->
        t := Some t';
        if not (!body2 == []) then begin
          body2 := `BEXE_goto (sr,end_label) :: !body2;
          end_label_used := true
        end
        ;
        let call_instr = `BEXE_init (sr,varindex,e) in
        body2 := call_instr :: !body2;

      | x -> body2 := x::!body2
      )
      body
    ;
    (* Ugghhh *)
    if !end_label_used then
      body2 := !body2 @ [`BEXE_label (sr,end_label)]
    ;
    (*
    print_endline (
     catmap "\n" (string_of_bexe syms.dfns 0) !body2
    )
    ;
    *)
    !body2 (* forward order *)

  | _ -> assert false

(* this routine changes direct applications into a named
  value plus an initialisation of that value: the argument
  should have already been processed bottom up, ie. already
  be in canonical form
*)
let bunravel syms bbdfns ts e = 
  let counter = syms.counter in 
  let vars = ref [] in
  let rec urv e = 
    match map_tbexpr ident urv ident e with
    | (`BEXPR_apply_direct _,t) as x ->
      let n = !counter in incr counter;
      print_endline ("New variable " ^ si n);
      vars := (n,x) :: !vars ;
      `BEXPR_name (n,ts),t
    | (`BEXPR_apply ((`BEXPR_apply_direct _,t'),a),t as x) ->
      print_endline ("Indirect apply direct!! " ^ sbe syms.dfns x);
      x
    | (`BEXPR_apply (f,a),t as x) ->
      print_endline ("Indirect apply " ^ sbe syms.dfns x);
      x

    | x -> x
  in
    let x = urv e in
    x,!vars

(* note u sr e must return exes in reverse order, this
  function however returns exes in forward order 
*)
let expand_exe syms bbdfns u exe = 
  let xs = 
    match exe with
    | `BEXE_call_prim (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_prim (sr,i,ts,e) :: xs

    | `BEXE_call_stack (sr,i,ts,e2) -> assert false

    | `BEXE_call_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_call_direct (sr,i,ts,e) :: xs

    | `BEXE_jump_direct (sr,i,ts,e2) ->
      let e,xs = u sr e2 in
      `BEXE_jump_direct (sr,i,ts,e) :: xs
   
    | `BEXE_assign (sr,e1,e2) ->
      let e1,xs = u sr e1 in
      let e2,xs = u sr e2 in
      `BEXE_assign (sr,e1,e2) :: xs

    (* preserve call lift pattern ??*)
    | `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      `BEXE_call (sr,(`BEXPR_apply_direct(i,ts,e1),t),e2) :: xs2 @ xs1


    | `BEXE_call (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      reduce_bexe bbdfns (`BEXE_call (sr,e1,e2)) :: xs2 @ xs1

    | `BEXE_jump (sr,e1,e2) ->
      let e1,xs1 = u sr e1 in
      let e2,xs2 = u sr e2 in
      reduce_bexe bbdfns (`BEXE_jump (sr,e1,e2)) :: xs2 @ xs1

    | `BEXE_loop (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_loop (sr,i,e) :: xs
   
    | `BEXE_ifgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifgoto (sr,e,lab) :: xs

    | `BEXE_ifnotgoto (sr,e,lab) ->
      let e,xs = u sr e in
      `BEXE_ifnotgoto (sr,e,lab) :: xs
   
    (* preserve tail call pattern -- used by both
       tail-rec eliminator 
       and by call lifter (which converts returns to calls)
    *)
    | `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,e),t)) :: xs
    
    | `BEXE_fun_return (sr,e) ->
      let e,xs = u sr e in
      `BEXE_fun_return (sr,e) :: xs
   
    | `BEXE_init (sr,i,e) ->
      let e,xs = u sr e in
      `BEXE_init (sr,i,e) :: xs
    
    (*
    | `BEXE_regmatch (sr,e,(a,sc,h,tr)) ->
      let e,xs = u sr e in
      `BEXE_regmatch (sr,e,(a,sc,h,tr)) :: xs
   
    | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) ->
      let p1,xs1 = u sr p1 in
      let p2,xs2 = u sr p2 in
      `BEXE_reglex(sr,p1,p2,(a,sc,h,tr)) :: xs1 @ xs2
    *)

    | `BEXE_read _
    | `BEXE_label _
    | `BEXE_goto _
    | `BEXE_code _
    | `BEXE_nonreturn_code _
    | `BEXE_proc_return _
    | `BEXE_comment _
    | `BEXE_nop _
    | `BEXE_halt _
    | `BEXE_begin
    | `BEXE_end
      -> [exe]
  in 
    let xs = rev xs in
    xs

(* output in reverse order *)
let xmap_bexe syms (child_map,bbdfns) caller vs exe : bexe_t list = 
  let ts = map (fun (_,i)-> `BTYP_var i) vs in
  let u sr e = 
    let x,xs = bunravel syms bbdfns ts e in
    iter 
    (fun (i,((x,t) as e)) -> 
      let id = "_urv_" ^ si i  in
      (*
      print_endline (id ^ "[" ^ catmap "," (sbt syms.dfns) ts ^ "]");
      *)
      let entry = `BBDCL_val (vs,t) in
      Hashtbl.add bbdfns i (id,Some caller,sr,entry);
      let kids = 
        try Hashtbl.find child_map caller
        with Not_found -> [] 
      in
      Hashtbl.replace child_map caller (i::kids)
    )
    xs
    ;
    let inits = map (fun (i,e)->`BEXE_init (sr,i,e)) xs in
    x,inits
  in
  expand_exe syms bbdfns u exe 

let unravel syms (child_map,bbdfns) i vs exes =
  (*
  print_endline ( "BEFORE UNRAVEL: " ^ catmap "\n" (string_of_bexe syms.dfns 0) exes) ;
  *)
  let exes = concat ( map (xmap_bexe syms (child_map,bbdfns) i vs) exes) in
  (*
  print_endline ( "AFTER  UNRAVEL: " ^ catmap "\n" (string_of_bexe syms.dfns 0) exes) ;
  *)
  exes


let heavy_inline_call syms (uses,child_map,bbdfns) 
  caller caller_vs callee ts argument id sr (props, vs, ps, exes)
=
  (*
  print_endline ("INLINING CALL to " ^ id ^"<"^ si callee^">("^sbe syms.dfns argument^")");
  print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
  print_endline ("Callee is " ^ id ^ "<"^si callee ^ "> with ts = " ^ catmap "," (sbt syms.dfns) ts);
  print_endline ("Callee vs=" ^ string_of_vs vs);
  *)
  let caller_vs_len = length caller_vs in
  let callee_vs_len = length vs in
  (*
  print_endline ("In the callee and its children,");
  print_endline ("The callee vs are elided and replaced by the caller vs");
  print_endline ("ELIDE: first " ^ si callee_vs_len ^ ", PREPEND " ^ si caller_vs_len);
  print_endline ("This works by instantiating the callee vs with the calls ts");
  *)
  assert(length vs = length ts);
  
  (*
  print_endline ("Found procedure "^id^": Inline it!");
  *)
  let relabel = mk_label_map syms exes in
  let varmap = mk_varmap vs ts in
  let revariable = reparent_children 
    syms (uses,child_map,bbdfns) 
    caller_vs callee_vs_len callee (Some caller) relabel varmap
  in
  let xs = gen_body syms (uses,child_map,bbdfns) id 
    varmap ps relabel revariable exes 
    argument sr caller callee caller_vs callee_vs_len `Lazy props
  in 
    rev xs (* forward order *)
   
let expr_uses syms descend usage restrict e = 
  let u = ref IntSet.empty in
  let add u i = u := IntSet.add i !u in
  let rec fe e = iter_tbexpr (add u) fe ignore e in
  fe e;
  

  (*
  print_string ("Direct usage of expr " ^ sbe syms.dfns e ^ ": ");
  IntSet.iter (fun i -> print_string (si i^" ")) !u;
  print_endline "";
  

  print_string ("Restrict =  ");
  IntSet.iter (fun i -> print_string (si i^" ")) restrict;
  print_endline "";
  *)
 
  let u = IntSet.fold
    (fun i cls -> IntSet.union cls (
     let cl = Flx_call.child_use_closure descend usage i in
     (*
     print_string ("Closure of " ^ si i ^ " is: ");
     IntSet.iter (fun i -> print_string (si i ^ " ")) cl;
     print_endline "";
     *)
     cl
    ))
    !u
    !u
  in let u = IntSet.inter restrict u in
  (*
  print_string ("Restricted usage of expr " ^ sbe syms.dfns e ^ ": ");
  IntSet.iter (fun i -> print_string (si i^" ")) u;
  print_endline "";
  *)
  u

(* Dependency analyser. This should be generalised,
but for now we only use it in tail calls.
 
We wish to discover what *local* vals an expression e in
some routine i depends on.

These are (a) the symbols manifestly used in the expression,
and (b) any variable used by any function that is called.

We can calculate this, expensively as the union of the
use closures of each symbol in the expression intersected
with the candidate locals.
*)

let tailit syms (uses,child_map,bbdfns) this sr ps vs exes : bexe_t list = 
  let ts' = map (fun (_,i) -> `BTYP_var i) vs in
  let pset = fold_left (fun s (_,(i,_))-> IntSet.add i s) IntSet.empty ps in
  let parameters = ref [] in
  let descend = descendants child_map this in
  let jump_done = ref false in
  let lc = !(syms.counter) in incr (syms.counter);
  let start_label = "start_" ^ si lc in

  (* note reverse order *)
  (* Weirdly, this works for BOTH tail calls
    and tail applies
  *)
  let cal_tail_call e = 
    match length ps with
    | 0 -> 
      [
        `BEXE_goto (sr,start_label);
        `BEXE_comment (sr,"tail rec call (0)")
      ]
    | 1 ->
      let (_,(k,_)) = hd ps in
      [
        `BEXE_goto (sr,start_label);
        `BEXE_init (sr,k,e);
        `BEXE_comment (sr,"tail rec call (1)")
      ]
    | _ ->
      let tmps_used = ref false in
      begin match e with
      | `BEXPR_tuple ls,_ ->
        (*
        print_endline ("TUPLE ASSGN " ^ sbe syms.dfns e);
        *)
        (* Parallel Assignment algorithm.
           Given a set of assignments, xi = ei,
           we need a sequence of assignments of xi, ei, tj,
           where tj are fresh variables, xi on left, ei on
           right, and tj on either side, such that no RHS
           term depends on a prior LHS term.

           A pair x1 = e1, x2 = e2 which are mutually dependent
           can always by resolved as

           t1 = e1; x2 = e2; x1 = t1

           Here e1 doesn't depend on a prior term, vaccuously,
           e2 can't depend on t1 since it is fresh, and
           t1 can't depend on anything, since it just a fresh variable

           Let's start by taking the equations, and making
           two lists -- a head list and a tail list.
           Head assignments are done first, tails last,
           the head list is in reverse order.

           Any equations setting variables no one depends on
           can be moved into the head list, they can safely
           be done first.

           Any equations whose RHS depend on nothing are
           moved into the tail list, its safe to do them last.

           Any dependencies on variables set by equations
           moved into the tail list can now be removed
           from the remaining equations, since it is determined
           now that these variables will be changed after
           any of the remaining assignments are one.

           Repeat until the set of remaining equations is fixed.

           We can now pick (somehow!!) an equation, and break
           it into two using a fresh temporary. The temporary
           assignment goes on the head list, the variable
           assignment from the temporary on the tail list,
           and as above, any dependencies on the variable
           can now be removed from the remaining equations.

           Repeat everything until the set of remaining
           equations is empty, the result is the reverse
           of the heap list plus the tail list.

           This process is certain to terminate, since
           each outer step removes one equation,
           and it is certain to be correct (obvious).

           What is NOT clear is that the result is minimal.
           And it is NOT clear how to best 'choose' which
           equation to split.
           
        
        *)
        assert (length ls = length ps);
        let pinits = 
          map2
          (fun (name,(i,t)) e ->
            i,(name,t,e,expr_uses syms descend uses pset e)
          )
          ps ls
        in
        (* strip trivial assignments like x = x *)
        let pinits = 
          filter 
          (fun (i,(name,t,e,u)) -> 
            match e with 
            | `BEXPR_name (j,_),_ when i = j -> false 
            | _ -> true
          )
          pinits 
        in
        let fixdeps pinits =
          let vars = fold_left (fun s (i,_) -> IntSet.add i s) IntSet.empty pinits in
          map 
          (fun (i,(name,t,e,u)) -> 
            let u = IntSet.remove i (IntSet.inter u vars) in
            i,(name,t,e,u)
          )
          pinits
        in
        (*
        iter
        (fun (i,(name,t,e,u)) -> 
          print_endline ("ASG " ^ name ^ "<"^si i ^ "> = " ^ sbe syms.dfns e);
          print_string "  Depends: "; 
            IntSet.iter (fun i -> print_string (si i ^ ", ")) u;
          print_endline "";
        )
        pinits;
        *)
        (* this function measures if the expression assigning i
        depends on the old value of j
        *)
        let depend pinits i j =
           let u = match assoc i pinits with _,_,_,u -> u in
           IntSet.mem j u
        in
        (* return true if an assignment in inits depends on j *)
        let used j inits = 
          fold_left (fun r (i,_)-> r or depend inits i j) false inits
        in
        let rec aux ((head, middle, tail) as arg) = function
          | [] -> arg
          | (i,(name,ty,e,u)) as h :: ta ->
            if IntSet.cardinal u = 0 then
              aux (head,middle,h::tail) ta
            else if not (used i (middle @ ta)) then
              aux (h::head, middle, tail) ta
            else 
              aux (head,h::middle,tail) ta
        in 

        let printem (h,m,t) =
          print_endline "HEAD:";
          iter
          (fun (i,(name,t,e,u)) -> 
            print_endline ("ASG " ^ name ^ "<"^si i ^ "> = " ^ sbe syms.dfns e)
          )
          h;

          print_endline "MIDDLE:";
          iter
          (fun (i,(name,t,e,u)) -> 
            print_endline ("ASG " ^ name ^ "<"^si i ^ "> = " ^ sbe syms.dfns e)
          )
          m;

          print_endline "TAIL:";
          iter
          (fun (i,(name,t,e,u)) -> 
            print_endline ("ASG " ^ name ^ "<"^si i ^ "> = " ^ sbe syms.dfns e)
          )
          t
        in

        let rec aux2 (hh,mm,tt) =
          let h,m,t = aux ([],[],[]) (fixdeps mm) in
          (* printem (h,m,t); *)
          (* reached a fixpoint? *)
          if length h = 0 && length t = 0 then hh,m,tt (* m = mm *)
          else begin
            (*
            print_endline "Recursing on MIDDLE";
            *)
            aux2 (h @ hh, m, t @ tt) 
          end
        in
        let temps = ref [] in
        let rec aux3 (hh,mm,tt) =
          let h,m,t = aux2 (hh,mm,tt) in
          (*
          print_endline "SPLIT STEP result:";
          printem(h,m,t);
          *)
          match m with
          | [] -> rev h @ t 
          | [_] -> assert false
          | (i,(name,ty,e,u)) :: ta ->
            let k = !(syms.counter) in incr syms.counter;
            let name2 = "_tmp_" ^ name in
            parameters := (ty,k) :: !parameters;
            tmps_used := true;
            let h' = k,(name2,ty,e,IntSet.empty) in
            let e' = `BEXPR_name (k,ts'),ty in
            let t' = i,(name,ty,e',IntSet.empty) in
            aux3 (h' :: h, ta, t' :: t)
        in
        let m = aux3 ([],pinits,[]) in
        (*
        print_endline "FINAL SPLIT UP:";
        iter
        (fun (i,(name,t,e,u)) -> 
          print_endline ("ASG " ^ name ^ "<"^si i ^ "> = " ^ sbe syms.dfns e)
        )
        m;
        *)
        [
          `BEXE_goto (sr,start_label)
        ]
        @
        (if !tmps_used then [`BEXE_end] else [])
        @
        rev_map (fun (i,(name,ty,e,_)) -> `BEXE_init (sr,i,e)) m
        @
        (if !tmps_used then [`BEXE_begin] else [])
        @
        [
          `BEXE_comment (sr,"tail rec call (3)")
        ]

      | _ ->
        let t = snd e in
        let pix = 
          try assoc t !parameters 
          with Not_found ->
            let pix = !(syms.counter) in incr syms.counter;
            parameters := (t,pix) :: !parameters;
            pix
        in
        let p = `BEXPR_name (pix,ts'),t in  
        let n = ref 0 in
        let param_decode = 
          map
          (fun (_,(ix,prjt)) ->
            let prj = reduce_tbexpr bbdfns (`BEXPR_get_n (!n,p),prjt) in
            incr n;
            `BEXE_init (sr,ix,prj)
          )
          ps
        in
        [
          `BEXE_goto (sr,start_label);
        ]
        @
        param_decode
        @
        [
          `BEXE_init (sr,pix,e);
          `BEXE_comment (sr,"tail rec call (2)")
        ]
      end
  in
  let rec aux tail res = match tail with
  | `BEXE_call_direct (sr,i,ts,a) :: tail 
    when (i,ts)=(this,ts') && Flx_cflow.tailable exes [] tail
    ->
     (*
     print_endline ("--> Tail rec call " ^ si this);
     *)
     jump_done := true;
     let res = cal_tail_call a @ res
     in aux tail res

  | `BEXE_fun_return (sr,(`BEXPR_apply_direct(i,ts,a),_)) :: tail 
    when (i,ts)=(this,ts') 
    ->
     (*
     print_endline ("--> Tail rec apply " ^ si this);
     *)
     jump_done := true;
     let res = cal_tail_call a @ res
     in aux tail res

  | (`BEXE_call_direct (sr,i,ts,a)) as x :: tail  ->
    (*
    print_endline ("Untailed call " ^ si i ^ "["^catmap "," (sbt syms.dfns) ts^"]");
    print_endline ("This = " ^ si this);
    print_endline ("ts'=" ^"["^catmap "," (sbt syms.dfns) ts'^"]");
    print_endline "TAIL=";
    iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) tail;
    print_endline "-- end of tail --";
    *)
    aux tail (x::res)
    
  | [] -> rev res (* forward order *)
  | h :: t  -> aux t (h::res)
  in 
    let exes = aux exes [] in

    (* instantiate any parameter temporaries *)
    iter 
      (fun (paramtype, parameter) ->
        let entry = `BBDCL_tmp (vs,paramtype) in
        let kids = 
          try Hashtbl.find child_map this
          with Not_found -> [] 
        in
        Hashtbl.replace child_map this (parameter::kids);
        let id = "_trp_" ^ si  parameter in
        Hashtbl.add bbdfns parameter (id,Some this,sr,entry);
      )
    !parameters
    ;
    (* return with posssible label at start *)
    let exes = 
      if !jump_done
      then `BEXE_label (sr,start_label) :: exes
      else exes
    in
      (*
      print_endline ("Tailed exes = ");
      iter (fun exe -> print_endline (string_of_bexe syms.dfns 0 exe)) exes;
      *)
      exes
      
(* note returns exes in reverse order *)
let rec special_inline syms (uses,child_map,bbdfns) caller_vs caller excludes sr e =
  (*
  print_endline ("Special inline " ^ sbe syms.dfns e); flush stdout;
  *)
  let exes' = ref [] in
  let id x = x in
  let rec aux e = match map_tbexpr id aux id e with
  | ((`BEXPR_apply_direct (callee,ts,a),t) as e)
  | (((`BEXPR_apply(  (`BEXPR_closure (callee,ts),_) ,a)),t) as e)
    when 
      not (mem callee excludes) 
    ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      if  
        (Flx_call.is_recursive uses callee) &&
        not (is_child child_map caller callee)
      then e 
      else
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
            begin
              (* GENERAL CASE -- we need to add a variable *)
              let urv = !(syms.counter) in incr (syms.counter);
              (* inline the code, replacing returns with variable inits *)
              let xs = 
                 inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a urv 
              in 
              match rev xs with
              (* SPECIAL CASE DETECTOR: if the inlined function
                terminates with an initialisation of the new variable,
                ignore the variable and use the value used to initialise
                it instead. This is sure to be the result of the sole
                trailing return. If there were another return, a
                jump to the end of the function would be needed,
                past this initialisation, which would require a label
                at the end of the function

                Note this is a bad form of 'apply lifting'.
                We should be able to inline

                f (g x)

                by inlining g x, and replacing 'return e'
                with 'v = f e' everywhere. instead we get
                v = e in various places, then f v.

                To do this right we need to see a double application.
              *)
              | [] -> assert false
              | `BEXE_init (sr,j,e') :: tail ->
                assert (j==urv);
                (*
                print_endline "DETECTED SPECIAL CASE";
                print_endline "Outputing tail:";
                iter (fun x -> print_endline (string_of_bexe syms.dfns 0 x)) (rev tail);
                print_endline ("Expr: " ^ sbe syms.dfns e');
                *)
                exes' := tail @ !exes';
                e'
              | rxs -> 
                let urvid = "_urv" ^ si urv in
                add_child child_map caller urv;
                add_use uses caller urv sr;
                let entry = `BBDCL_val (caller_vs,t) in
                Hashtbl.add bbdfns urv (urvid,Some caller,sr,entry);

                exes' := rxs @ !exes';
                let ts = map (fun (_,i)-> `BTYP_var i) caller_vs in
                `BEXPR_name (urv,ts),t
            end
        else e
      | _ -> e
      end
  
  | x -> x
  in 
   let e = aux e in (* we need left to right evaluation here ..*)
   e,!exes'


(*
and tail_bbdcl syms (uses,child_map,bbdfns) i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) ->
    let exes = tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
    let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
    Hashtbl.replace bbdfns i data

  | _ -> ()
*)

and heavy_inline_calls
  syms (uses,child_map,bbdfns)
  caller_vs caller excludes exes 
=
  let hic callee exes =
    (*
    print_endline "Rescanning ..";
    *)
    heavy_inline_calls syms (uses,child_map,bbdfns)
    caller_vs caller (callee::excludes) exes
  in
  let sinl sr e = special_inline syms (uses,child_map,bbdfns) caller_vs caller excludes sr e in 
  let ee exe = expand_exe syms bbdfns sinl exe in
  let exes' = ref [] in (* reverse order *)
  iter 
  (fun exeIN -> 
    let xs = ee exeIN in
    (*
    print_endline ("EXE[in] =" ^ string_of_bexe syms.dfns 0 exeIN);
    iter (fun x -> print_endline ("EXE[out]=" ^ string_of_bexe syms.dfns 0 x)) xs;
    print_endline "--";
    *)
    iter (fun exe ->
    match exe with
    | `BEXE_call_direct (sr,callee,ts,argument) 
      when not (mem callee excludes)
      ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      (*
      print_endline ("CALL DIRECT " ^ id ^ "<"^ si callee^">");
      *)
      begin match entry with
      | `BBDCL_procedure (props,vs,ps,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then begin
          (*
          print_endline "INLINE CANDIDATE DETECTED - CALL";
          *)
          let xs = 
            heavy_inline_call syms (uses,child_map,bbdfns) 
            caller caller_vs callee ts argument id sr (props,vs,ps,exes)
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        end
        else
          exes' := exe :: !exes'

      | _ ->  exes' := exe :: !exes'
      end

    | `BEXE_call (sr,(`BEXPR_apply((`BEXPR_closure (callee,ts),_),a),_),argument) -> assert false
    | `BEXE_call (sr,(`BEXPR_apply_stack (callee,ts,a),_),argument) -> assert false

    | `BEXE_call (sr,(`BEXPR_apply_direct (callee,ts,a),_),argument)
      when not (mem callee excludes)
      ->
      (*
      print_endline "DETECTED CANDIDATE FOR CALL LIFTING ";
      print_endline ("In procedure " ^ si caller ^ " with vs=" ^ string_of_vs caller_vs);
      print_endline (string_of_bexe syms.dfns 0 exe);
      print_endline ("Callee is " ^ si callee ^ " with ts = " ^ catmap "," (sbt syms.dfns) ts);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             call_lifting syms (uses,child_map,bbdfns) caller caller_vs callee ts a argument
          in 
            (* The recursion here is because the call is lifted,
            so there may be new calls that didn't previously
            exist, they need rescanning eg:
            
              call {if x then f else g endif} a 
              -->
              if x then call f a else call f a endif
            
            creates new calls to f and g when now need
            to be scanned (possibly for a further lift,
            possibly for call inlining)

            The hassle here is that we might unfold
            an unrelated recursive function multiple times
            as a side effect.
            *)
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling init: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a i
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_fun_return (sr,(`BEXPR_apply((`BEXPR_closure(callee,ts),_),a),_)) -> assert false
    | `BEXE_fun_return (sr,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      (*
      print_endline ("Handling return: " ^ string_of_bexe syms.dfns 0 exe);
      *)
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a
          in 
            let xs = hic callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end
    | _ -> exes' := exe :: !exes' 
    )
    xs
    (*
    | _ -> 
     (* exes' := exe :: !exes' *)
     exes' := rev (ee exe) @ !exes'
    *)
  )
  exes
  ;
  rev !exes'


and heavy_inline_applies
  syms (uses,child_map,bbdfns)
  caller_vs caller excludes exes 
=
  let hia callee exes = heavy_inline_applies 
    syms (uses,child_map,bbdfns)
    caller_vs caller (callee::excludes) exes 
  in
  let exes' = ref [] in (* reverse order *)
  iter 
  (fun exe ->
    match exe with
    | `BEXE_init (sr,i,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
             inline_function syms (uses,child_map,bbdfns) caller caller_vs callee ts a i
          in 
            let xs = hia callee xs in
            exes' := rev xs @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end

    | `BEXE_fun_return (sr,(`BEXPR_apply_direct (callee,ts,a),_)) 
      when not (mem callee excludes)  ->
      heavily_inline_bbdcl syms (uses,child_map,bbdfns) (callee::excludes) callee;
      let id,parent,sr,entry = Hashtbl.find bbdfns callee in
      begin match entry with
      | `BBDCL_function (props,vs,ps,ret,exes) ->
        if 
          not (mem `NoInline props) &&
          (
            mem `Inline props ||
            length exes <= syms.compiler_options.max_inline_length
          )
        then 
          let xs = 
            inline_tail_apply syms (uses,child_map,bbdfns) caller caller_vs callee ts a
          in 
            exes' := rev (hia callee xs) @ !exes'
        else
          exes' := exe :: !exes'
      | _ -> exes' := exe :: !exes'
      end
    
    | _ -> exes' := exe :: !exes'
  )
  exes
  ;
  rev !exes'

and strip_useless syms (uses,child_map,bbdfns) i ps exes =
  let parms = fold_left (fun s (_,(i,_)) -> IntSet.add i s) IntSet.empty ps in
  let k = ref (intset_of_list (find_children child_map i)) in

  let rec aux exes =
    let u = Flx_call.use_closure uses i in
    let useless = IntSet.diff !k u in
    let useless = IntSet.diff useless parms in
    if not (IntSet.is_empty useless) then begin
      (*
      print_endline ("Useless: " ^ string_of_intset useless);
      *)
      (* Throw out useless stuff *)
      IntSet.iter
      (fun j -> 
        Hashtbl.remove bbdfns j;
        Hashtbl.remove child_map j;
        remove_child child_map i j;
        k := IntSet.remove j !k
      )
      useless;
      (* delete inits of useless stuff *)
      let exes = 
        filter 
        (function 
          | `BEXE_init (_,j,_) 
          | `BEXE_assign (_,(`BEXPR_name (j,_),_),_)
            when IntSet.mem j useless -> false 
          | _ -> true
        ) 
        exes 
      in
      recal_exes_usage uses i exes;
      aux exes
    end
    else exes
  in aux exes


and fold_vars syms (uses,child_map,bbdfns) i ps exes =
  let pset = fold_left (fun s (_,(i,_))-> IntSet.add i s) IntSet.empty ps in
  let descend = descendants child_map i in
  let locls = locals child_map uses i in
  let count = ref 0 in
  let rec find_tassign inexes outexes =
    match inexes with
    | [] -> rev outexes
    | ((
      `BEXE_init (_,j,y)
      | `BEXE_assign (_, (`BEXPR_name (j,_),_),y)
    ) as x) :: t  when IntSet.mem j locls ->

      (*
      let id,_,_,_ = Hashtbl.find bbdfns j in
      print_endline ("CONSIDERING VARIABLE " ^ id ^ "<" ^ si j ^ "> -> " ^ sbe syms.dfns y);
      *)
      let luses = try Hashtbl.find uses i with Not_found -> [] in
      let usecnt = ref 0 in
      iter (fun (k,sr) -> if k = j then incr usecnt) luses;
      (*
      print_endline ("Use count = " ^ si !usecnt);
      *)
      let setcnt = ref (if IntSet.mem j pset then 1 else 0) in
      let sets exe = 
        match exe with
         | `BEXE_init (_,k,_) when j = k -> incr setcnt
         | _ -> ()
      in
      iter sets t; iter sets outexes;
      (*
      print_endline ("Set count = " ^ si (!setcnt+1));
      *)
      let yuses = expr_uses syms descend uses pset y in
      let delete_var () =
        let id,_,_,_ = Hashtbl.find bbdfns j in
        print_endline ("ELIMINATING VARIABLE " ^ id ^ "<" ^ si j ^ "> -> " ^ sbe syms.dfns y);
        Hashtbl.remove bbdfns j;
        remove_child child_map i j;
        remove_uses uses i j;
        incr count
      in
      let isvar = 
        match Hashtbl.find bbdfns j with
        | _,_,_,`BBDCL_var _ -> true
        | _,_,_,(`BBDCL_val _ | `BBDCL_tmp _) -> false
        | _ -> assert false
      in
      begin match isvar,!usecnt,!setcnt with
        | _,0,_ -> 
          print_endline "WARNING: unused variable found";
          delete_var();
          find_tassign t outexes

        | false,1,0 -> 
          let rplcnt = ref 0 in
          let rec subi j y e = 
            match map_tbexpr ident (subi j y) ident e with
            | `BEXPR_name (i,_),_ when j = i -> incr rplcnt; y
            | x -> x
          in 
          let elimi j y exe = map_bexe ident (subi j y) ident ident ident exe in
          let subs = ref true in
          let elim j y exes = map 
           (fun exe -> 
             if !subs then match exe with

             (* terminate substitution, return unmodified instr *)
             | `BEXE_goto _ 
             | `BEXE_proc_return _
             | `BEXE_label _ 
               -> subs:= false; exe

             (* return unmodified instr *)
             | `BEXE_begin
             | `BEXE_end
             | `BEXE_nop _
             | `BEXE_code _
             | `BEXE_nonreturn_code _
             | `BEXE_comment _
             | `BEXE_halt _ 
               -> exe

             (* conditional, check if y depends on init (tail rec) *)
             
             | `BEXE_assign (_,(`BEXPR_name (k,_),_),_)
             | `BEXE_read (_,k)
             | `BEXE_init (_,k,_) ->
               subs := not (IntSet.mem k yuses); 
               elimi j y exe
             
             (* return modified instr *)
             | `BEXE_ifgoto _
             | `BEXE_ifnotgoto _
               -> elimi j y exe

             (* terminate substitution, return modified instr *)
             | `BEXE_assign _
             | `BEXE_fun_return _
             | `BEXE_jump _
             | `BEXE_jump_direct _
             | `BEXE_loop _
             | `BEXE_call_prim _
             | `BEXE_call _
             | `BEXE_call_direct _
             | `BEXE_call_stack _
               -> subs := false; elimi j y exe
             else exe
           ) 
           exes 
          in
          let t' = elim j y t in
          if !rplcnt = 1 then 
          begin
            delete_var();
            find_tassign t' outexes
          end
          else 
            find_tassign t (x::outexes)

        | _ -> find_tassign t (x::outexes)
      end

    | h::t -> find_tassign t (h::outexes)
  in 
  let exes = find_tassign exes [] in
  if !count > 0 then
    print_endline ("Elimination complete, removed " ^ si !count ^" variables")
  ;
  exes

and heavily_inline_bbdcl syms (uses,child_map,bbdfns) excludes i =
  match Hashtbl.find bbdfns i with
  | id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) ->
    if not (mem `Inlining_complete props) then begin
      (*
      print_endline ("HIB: Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      *)
      (*
      print_endline ("Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage uses i exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      
      (*
      let exes = unravel syms (child_map,bbdfns) i vs exes in
      print_endline (id ^ " After unravelling:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      let exes = heavy_inline_applies syms (uses,child_map,bbdfns) vs i excludes exes in
      print_endline (id ^ " After inlining applies:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage uses i exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in
      let exes = strip_useless syms (uses,child_map,bbdfns) i ps exes in
      let exes = Flx_cflow.chain_gotos exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_procedure (props,vs,ps,exes) in
      Hashtbl.replace bbdfns i data;
      (*
      print_endline ("DONE Examining procedure " ^ id ^ "<"^ si i ^ "> for inlinable calls");
      *)
    end

  | id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) ->
    if not (mem `Inlining_complete props) then begin
      (*
      print_endline ("HIB:Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      *)
      (*
      print_endline (id ^ " Input:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage uses i exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in
      let exes = heavy_inline_calls syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining calls:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id ^ " After tailing:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      
      (*
      let exes = unravel syms (child_map,bbdfns) i vs exes in
      (*
      print_endline (id ^ " After unravelling:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      let exes = heavy_inline_applies syms (uses,child_map,bbdfns) vs i excludes exes in
      (*
      print_endline (id ^ " After inlining applies:\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      *)
      
      let exes = tailit syms (uses,child_map,bbdfns) i sr ps vs exes in
      (*
      print_endline (id^ " After tailing(2):\n" ^ catmap "\n" (string_of_bexe syms.dfns 0) exes);
      *)
      recal_exes_usage uses i exes;
      let exes = fold_vars syms (uses,child_map,bbdfns) i ps exes in
      let exes = strip_useless syms (uses,child_map,bbdfns) i ps exes in
      let exes = Flx_cflow.chain_gotos exes in
      let props = `Inlining_complete :: props in
      let data = id,parent,sr,`BBDCL_function (props,vs,ps,ret,exes) in
      Hashtbl.replace bbdfns i data;
      (*
      print_endline ("DONE Examining function " ^ id ^"<" ^ si i ^ "> for inlinable calls");
      *)
    end
  | _ -> ()

let heavy_inlining syms  
  (child_map,bbdfns)
  (root:bid_t) 
  (bifaces:biface_t list) 
=
  (* make set of used things, initially empty *)
  let used = ref IntSet.empty in

  let use i = Flx_use.uses syms used bbdfns i in

  (*
  (* add root items to set, then add items it uses *)
  IntSet.iter use !(syms.roots)
  ;
  *)

  used := !(syms.roots);
  
  let (uses,usedby) = Flx_call.call_data bbdfns in
  (*
  print_endline "Inlining heavy pass1";
  *)
  while not (IntSet.is_empty !used) do
    let i = IntSet.choose !used in
    used := IntSet.remove i !used;
    heavily_inline_bbdcl syms (uses,child_map,bbdfns) [i] i
  done;

(* NOTES: this algorithm ONLY WORKS if inlining is attempted
in the corect order. Attempting to inline into children
before parents, when they're mutually recursive, spawns
clones infinitely, because we end up cloning a function
on the exclusion list, but not adding the clone to it.

So we end up recursing into the clone, and inlining
into it, which spawns more clones which are not
excluded, and haven't been inlined into yet.

This needs to be fixed so the algorithm is proven
to terminate and also be complete.

What we need (and is NOT implemented) is something like this:

Cloning nested functions is should not be needed in general.
If we proceed from leaves towards the root, we can eliminate
from each function any nested children, by simply inlining
them. So only variable children need cloning.

Two things stop this working: 

(a) non-inline functions and
(b) recursion.

The current algorithm has been hacked to only handle the
call graph from the roots. It used to consider the useage
closure, however that started to fail when I added 
'pre-assigned' slot numbers (AST_index). Doing that meant
the natural order of the set wasn't a topological sort
of the parent-child order.

Unfortunately, the remaining recursive descent doesn't
proceed into noinline functions. Although these shouldn't
be inlined into their caller, that doesn't mean functions
shouldn't be inlined into them. Iterating over the usage
closure ensured noinline functions would still be inlined
into.

Recursive functions are a bit different: they currently
allow inlining, with a recursion stopper preventing
infinite recursion.

Unfortunately with a double nesting like this:

  fun f() { fun g() { fun h() { f(); } h(); } g(); }

trying to inline g into f causes h to be cloned.
But trying to inline f into the clone of h retriggers
the descent, causing the clone to be recloned, and 
the recursion stopper doesn't prevent this, since it
isn't the same routine being inlined twice (just a clone
of it ..)

The thing is.. we HAVE to inline the original routine
AND the clone for completeness, since both may be
called independently, so even if we could clone the
recursion stoppers, it wouldn't work.

The only solution I can think of is to guarrantee that
you can only clone a routine that is inlined into
already (as fas as possible) so that no attempt will
be made to inline into the clone either.

*)
