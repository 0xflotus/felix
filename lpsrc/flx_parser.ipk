@execfile('config'+os.sep+'flx_data.py')

@head(1,'Parser')
@h = tangler('src/compiler/flxlib/flx_parse.dyp','data')

@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
%mltop {
open Flx_token
open Flx_mtypes2
}
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_mtypes1
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset
open Flx_exceptions
open Flx_util
open Ocs_types
open Sex_types
open Dyp
open Flx_pdoc

let dummysr = "Dummy",0,0,0,0


let silly_strtoken k = Flx_prelex.string_of_token k 
  (*
  match k with 
  | NAME (_,s) -> s
  | NONTERMINAL (_,s,p) -> s
  | _ -> Dyp_symbols.str_token k
  *)


let map = List.map
let map2 = List.map2
let hd = List.hd
let tl = List.tl
let fold_left = List.fold_left
let rev = List.rev 
let mem = List.mem
let length = List.length

let fresh_dssl = { 
  prios = [];
  rules = [];
  deps = [];
  privacy = Drules.empty;
}

exception Scheme_error of sval

let giveup () = raise Giveup; Sunspec
let sraise s  = raise (Scheme_error s); Sunspec

let flx_ocs_init env =
  Ocs_env.set_pf0 env giveup "giveup";
  Ocs_env.set_pf1 env sraise "raise"

let init_env () =  
  let env = Ocs_top.make_env () in
  flx_ocs_init env;

  let v1:Ocs_types.sval = Ocs_sym.get_symbol "_sr" in
  let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
  Ocs_env.bind_name env v1 g1;
  for n = 1 to 20 do
    let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
    let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
    Ocs_env.bind_name env v1 g1;
  done;
  env

let global_data = {
  pcounter = ref 1;
  env=init_env();
  pdebug=ref false;
}
let local_data = {
  dssls=Drules.empty; 
  loaded_dssls = [];
  scm = [];
}

let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

let buffer_add_ocs b r = Ocs_print.print_to_buffer b false r

let print_ocs r = 
  print_endline (Ocs_print.string_of_ocs r)

let scheme_lex sr (s:string):sval = 
  let sr = short_string_of_src sr in
  let inp = Ocs_port.string_input_port s in
  let lex = Ocs_lex.make_lexer inp sr in
  match Ocs_read.read_expr lex with
  | Ocs_types.Seof -> print_endline "END OF FILE?"; Snull
  | v ->  v

let scheme_compile env (s:sval):Ocs_types.code =
  Ocs_compile.compile env s

let scheme_eval (c:Ocs_types.code):sval =
  let th = Ocs_top.make_thread () in
  let term = ref None in
  Ocs_eval.eval th (fun (r:sval) -> term := Some r) c;
  match !term with
  | None -> failwith "Scheme term not returned!"
  | Some r -> r

let scheme_run sr env (s:string):sval = 
  let l :sval = scheme_lex sr s in
  let c :code = scheme_compile env l in
  let r :sval = scheme_eval c in
  r

let cal_priority priority_data p = 
  let cp p = 
    try find_priority priority_data p 
    with Not_found -> failwith ("Priority " ^ p ^ " not defined!")
  in
  match p with
  | `No_prio -> No_priority
  | `Eq_prio p -> Eq_priority (cp p)
  | `Less_prio p -> Less_priority (cp p)
  | `Lesseq_prio p -> Lesseq_priority (cp p)
  | `Greater_prio p -> Greater_priority (cp p)
  | `Greatereq_prio p -> Greatereq_priority (cp p)

let define_scheme sr dyp priority_data dssl_record dssl name prio rhs (scm:string) =
  let mapnt name = try Drules.find name dssl_record.privacy with Not_found -> name in
  let pr_age = !(dyp.global_data.pcounter) in 
  incr (dyp.global_data.pcounter);
  let name = mapnt name in
  let lhs = 
    try dyp.add_nt name "Obj_sexpr" 
    with Dyp.Constructor_mismatch _ -> failwith ("CONSTRUCTOR MISMATCH " ^ name)
  in
  let f o =
    match o with
      | STRING _ ->
        Dyp.Ter Dyp_symbols.t_NAME

      | NONTERMINAL (sr,s,p) -> 
          let nt = mapnt s in
          let nt = 
            try dyp.add_nt nt "Obj_sexpr"
            with Dyp.Constructor_mismatch _ -> failwith ("CONSTRUCTOR MISMATCH " ^ s)
            | Dyp.Bad_constructor _ -> failwith ("BAD CONSTRUCTOR FOR " ^ s)
          in
          let ntpri = cal_priority priority_data p in
          Dyp.Non_ter (nt,ntpri)

      | NAME (sr,s) -> assert false

      | s -> 
        let name = Dyp_symbols.str_token s in
        Dyp.Ter (Dyp_symbols.get_token_name s)
  in
  let cde = 
    try 
      let l = scheme_lex sr scm in
      let c = scheme_compile dyp.global_data.env l in
      c
    with
    | Ocs_error.Error err | Ocs_error.ErrorL (_,err) -> failwith ("Error " ^ err ^ " compiling " ^ scm) 
  in

  let priority = match prio with
  | `Default -> Dyp_priority_data.default_priority
  | `Priority p -> 
    try find_priority priority_data p
    with Not_found -> clierr sr ("Priority " ^ p ^ " not found")
  in
  let rule  = lhs,(List.map f rhs),priority in
  if !(dyp.global_data.pdebug) then
  print_endline ("Rule "^string_of_int pr_age ^" " ^ name ^ " := " ^
  catmap " " silly_strtoken rhs ^
  " =># "^scm);
  let action = fun _ avl ->
    match avl,scm with
    (* optimise special case *)
    | [`Obj_sexpr (_,sr,s)],"_1" -> `Obj_sexpr (pr_age,sr,s),[]
    | _ ->
    let age = ref pr_age in
    let b = Buffer.create 200 in
    if !(dyp.global_data.pdebug) then
    Buffer.add_string b ("Reducing Rule for " ^ name ^ ", scm="^scm^"\n");

    (* let env = Ocs_env.env_copy dyp.local_data.env in *)
    (* let env = dyp.local_data.env in *)
    let env = dyp.global_data.env in
    let srs = ref [] in
    let rec aux objs syms n = match objs, syms with
      | [],[] -> ()
      | [],_ | _,[] -> assert false
      | h1::t1,h2::t2 -> 
        let sr,s =
          match h1,h2 with
          | _,`Obj_sexpr (seq,sr,s) ->
            (* age := max !age seq; *)
            sr,s

          | k,`Obj_keyword sr -> slift sr, Sstring (Flx_prelex.string_of_token k)

          | (STRING (_,s1) | USER_KEYWORD (_,s1) | USER10 (_,s1,_)),
            (`Obj_NAME (sr,s2) | `Obj_USER_KEYWORD (sr,s2) | `Obj_USER10 (sr,s2,_))
            ->
            if s1 <> s2 then raise Giveup;
            slift sr,Sstring s1
             
          | k , _ -> 
          print_endline ("Woops, unhandled token=" ^ Flx_prelex.string_of_token k);
          dummysr, Sstring (Flx_prelex.string_of_token k)
        in
        if !(dyp.global_data.pdebug) then begin
          Buffer.add_string b ("Arg " ^ string_of_int n ^ " = "); 
          buffer_add_ocs b s; Buffer.add_string b "\n";
        end;
        let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
        Ocs_env.set_glob env v1 s;
        if (match sr with _,l,_,_,_ -> l) <> 0 then srs := sr :: !srs;
        aux t1 t2 (n+1)
    in
    aux rhs avl 1;
    if !(dyp.global_data.pdebug) then
    Buffer.add_string b "End of arguments\n";
    let sr = match !srs with
      | [] -> "dummy:"^name,0,0,0,0
      | sr::_ -> rsrange (hd (rev !srs)) sr
    in
    begin
      match sr with fn,fl,fc,ll,lc ->
      let ssr = Sstring fn :: Sint fl :: Sint fc :: Sint ll :: Sint lc :: [] in
      let ssr = Ocs_misc.make_slist Snull (rev ssr) in
      let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_sr") in
      (*
      let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = ssr } in
      *)
      Ocs_env.set_glob env v1 ssr
    end
    ;
    let r = 
      try scheme_eval cde 
      with Ocs_error.Error err | Ocs_error.ErrorL (_,err) -> 
        print_string (Buffer.contents b);
        print_string ("Error "^err^" evaluating " ^ scm);
        failwith "Error evaluating Scheme"
    in
    `Obj_sexpr (!age,sr,r),[]
  in
  rule,action

let extend_grammar dyp priority_data (dssl,(name,prio,prod,action,anote,sr)) =
  let m = dyp.local_data in
  let dssl_record = Drules.find dssl m.dssls in
  let rule = define_scheme sr dyp priority_data dssl_record dssl name prio prod action in
  rule

(* ------------------------------------------------------ *)

(* create rules for nt* nt+ and nt? *)
let fixup_suffix_scheme sr pcounter rhs =
  let rec aux inp out extras = match inp with
  | [] -> rev out,extras
  | NONTERMINAL (sr,s,p) :: STAR _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__rlist_"^x in
    let sl = s ^ "__list_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"(reverse _1)","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(cons _2 _1)","",rsr in
    let rule2 = sl,`Default,[],"'()","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: PLUS _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__nerlist_"^x in
    let sl = s ^ "__nelist_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"(reverse _1)","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(cons _2 _1)","",rsr in
    let rule2 = sl,`Default,[NONTERMINAL(sr,s,`No_prio)],"`(,_1)","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: QUEST _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = s ^ "__opt_"^x in
    let rule1 = sl,`Default,[NONTERMINAL(sr,s,p)],"`(,_1)","",rsr in
    let rule2 = sl,`Default,[],"()","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | other :: QUEST sr :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__opt_"^x in
    let rule1 = sl,`Default,[other],"()","",rsr in
    let rule2 = sl,`Default,[],"()","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | h :: t -> aux t (h::out) extras 
  in aux rhs [] []

let fixup_suffix_string sr pcounter rhs =
  let rec aux inp out extras = match inp with
  | [] -> rev out,extras
  | NONTERMINAL (sr,s,p) :: STAR _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__rlist_"^x in
    let sl = s ^ "__list_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"_1","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(strcat `(,_1 ,_2))","",rsr in
    let rule2 = sl,`Default,[],"\"\"","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: PLUS _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let slr = s ^ "__nerlist_"^x in
    let sl = s ^ "__nelist_"^x in
    let rule0 = slr,`Default,[NONTERMINAL(sr,sl,`No_prio)],"_1","",rsr in
    let rule1 = sl,`Default,[NONTERMINAL(sr,sl,`No_prio);NONTERMINAL(sr,s,p)],"(strcat `(,_1 ,_2))","",rsr in
    let rule2 = sl,`Default,[NONTERMINAL(sr,s,`No_prio)],"_1","",rsr in
    aux t (NONTERMINAL (sr,slr,`No_prio)::out) (rule0::rule1::rule2::extras)

  | NONTERMINAL (sr,s,p) :: QUEST _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = s ^ "__opt_"^x in
    let rule1 = sl,`Default,[NONTERMINAL(sr,s,p)],"_1","",rsr in
    let rule2 = sl,`Default,[],"\"\"","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | other :: QUEST sr :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__opt_"^x in
    let rule1 = sl,`Default,[other],"_1","",rsr in
    let rule2 = sl,`Default,[],"\"\"","",rsr in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rule1::rule2::extras)

  | h :: t -> aux t (h::out) extras 
  in aux rhs [] []

let fixup_suffix sr pcounter kind rhs =
  match kind with
  | `Sval -> fixup_suffix_scheme sr pcounter rhs
  | `String -> fixup_suffix_string sr pcounter rhs

let fixup_prio rhs =
  let rec aux inp out = match inp with
  | [] -> rev out
  | NAME (sr,s) :: LSQB _ :: LESS _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Less_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: LESSEQUAL _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Lesseq_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: GREATER _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Greater_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: GREATEREQUAL _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Greatereq_prio p)::out)
  | NAME (sr,s) :: LSQB _ :: EQUAL _ :: NAME (_,p) :: RSQB _ :: t ->
    aux t (NONTERMINAL (sr,s,`Eq_prio p)::out)
  | NAME (sr,s) ::t ->
    aux t (NONTERMINAL (sr,s,`No_prio)::out)
  | h :: t -> aux t (h::out)
  in aux rhs []
 
let dflt_action kind prod = 
  let rn = ref 1 in
  let action = 
    match kind with 
    | `Sval -> 
      "`(" ^ 
      fold_left (fun acc _ -> let n = !rn in incr rn;  
        (if acc = "" then "" else acc ^ " ") ^ ",_" ^ string_of_int n 
      ) "" prod 
      ^ ")" 

    | `String -> 
      "(strcat `(" ^ 
      fold_left (fun acc _ -> let n = !rn in incr rn;  
        (if acc = "" then "" else acc ^ " ") ^ ",_" ^ string_of_int n 
      ) "" prod 
      ^ "))"
  in
  (*
  print_endline ("DEFAULT ACTION for " ^ 
    catmap " " silly_strtoken prod ^
    " =># " ^ action)
  ;
  *)
  action

let user_expr prod fn : string = 
  (* this is a supreme hack .. but it is mandatory because Marshal
     cannot save an Ocs.sval because it can contain primitive
     functions
  *)
  let fn = Ocs_print.string_of_ocs fn in
  (*
  print_endline ("Rendered Ocs sval as " ^ fn);
  *)
  let rn = ref 1 in
  let arg =
    let rec aux acc inp = match inp with
    | [] -> acc
    | `Atom (NAME _) :: `Atom (LSQB _) :: 
      `Atom 
      (
        EQUAL _ | LESS _ |
        GREATER _ | LESSEQUAL _ | 
        GREATEREQUAL _
      ) :: `Atom (NAME _) :: `Atom (RSQB _) :: t

    | `Atom (NAME _) :: t ->
      let n = !rn in incr rn;
      aux 
      (
        (if acc = "" then "" else acc ^ " ")
        ^ "(Expression_term ,_" ^ string_of_int n ^ ")"
      ) t

    | `Atom (QUEST _ | PLUS _ | STAR _) :: _
    | `Group _ :: _ ->
      failwith "Production of user expression can't have meta symbols"

    | `Atom k :: t -> 
      (* this is really a don't care case .. *)
      let k = silly_strtoken k in
      let n = !rn in incr rn;
      aux 
      (
        (if acc = "" then "" else acc ^ " ")
        ^ "(Keyword_term " ^ Flx_string.c_quote_of_string k ^ ")"
      ) t
    in aux "" prod 
  in
  let action = "(Apply_term (Expression_term " ^ fn ^ ") (" ^ arg ^ "))" in
  let action = "`(ast_user_expr ,_sr \"dunno\" " ^ action ^ ")" in
  (*
  print_endline ("User expression, action=" ^ action);
  *)
  action
  

let cal_action kind prod action =
  match action with 
  | `None -> dflt_action kind prod
  | `Scheme scm -> scm


let unlift (f,l1,c1,l2,c2) = 
  if l1 = l2 then f,l1,c1,c2
  else f,l1,c1,c1

let rec flatten sr pcounter kind (rhs: symbol_t list) : token list * rule_t list =
  let rec aux inp out extras = match inp with
  | [] -> rev out,extras

  | `Group dyalts :: t -> 
    let sr = unlift sr in
    let x = string_of_int (!pcounter) in incr pcounter;
    let sl = "__grp_"^x in
    let rules : rule_t list = fixup_alternatives pcounter kind sl `Default dyalts in
    aux t (NONTERMINAL (sr,sl,`No_prio)::out) (rules@extras)

  | `Atom h :: t -> aux t (h::out) extras 
  in aux rhs [] []

and fixup_rule sr pcounter kind (rhs:symbol_t list) : token list * rule_t list =
  let rhs,extras = flatten sr pcounter kind rhs in
  let rhs, extras = 
    fixup_prio rhs, 
    map (fun (name,prio,prod,action,anote,sr) -> name,prio,fixup_prio prod, action,anote,sr) extras
  in
  let rhs,extras' = fixup_suffix sr pcounter kind rhs in
  rhs,extras@extras'

and fixup_alternatives pcounter kind name prio (dyalts:dyalt_t list) : rule_t list =
  let rules = 
    fold_left 
      (fun rules (rhs,sr,action,anote) ->
        let prod,extras = fixup_rule sr pcounter kind rhs in
        let action : string = cal_action kind prod action in
        ((name,prio,prod,action,anote,sr) :: extras) @ rules
      ) 
      [] dyalts
  in
  rev rules

let add_rule global_data local_data dssl rule =
  let m = local_data in
  let d: dssl_t = try Drules.find dssl m.dssls with Not_found -> fresh_dssl in
  match rule with
  | `Scheme_rule (privacy,name,prio,kind,dyalts) ->
     if !Flx_pdoc.document_grammar then record_rule dssl name dyalts;
     let rules = fixup_alternatives global_data.pcounter kind name prio dyalts in
     let rules = fold_left (fun acc rule -> uniq_add rule acc) d.rules rules in
     let privacy = 
       match privacy with
       | `Private -> 
          let n = !(global_data.pcounter) in incr (global_data.pcounter);
          let secret = "_"^name^"_"^string_of_int n in 
          Drules.add name secret d.privacy
       | `Public -> d.privacy
     in 
     let d: dssl_t = {d with rules = rules;  privacy = privacy} in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     global_data,m

  | `Requires ls ->
     let d: dssl_t = {d with deps = ls @ d.deps } in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     global_data,m

  | `Document (name,s) -> record_doc dssl name s; global_data,local_data
  | `Page (name,entries) -> record_group name entries; global_data, local_data
  | `Priorities p -> 
    let d = { d with prios = p::d.prios } in
    let m = {m with dssls=Drules.add dssl d m.dssls } in
    global_data, m


let ocs2flx sr r = 
  let sex = Ocs2sex.ocs2sex r in
  (*
  print_endline "OCS scheme term converted to s-expression:";
  Sex_print.sex_print sex;
  *)
  let fresh = ref 1 in
  let env = [] in
  let flx = Flx_sex2flx.xstatement_t sr fresh env sex in
  (*
  print_endline "s-expression converted to Felix statement!";
  print_endline (string_of_statement 0 flx);
  *)
  flx

let smerge ((oseq,osr,osex),ogd,old as oit) ((nseq,nsr,nsex),ngd,nld as nit) =
   if !(global_data.pdebug) then 
   begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ "\nnxt=" ^ Ocs_print.string_of_ocs nsex);
   end;

   if oseq > nseq then oit
   else if nseq > oseq then nit
   else begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ "\nnxt=" ^ Ocs_print.string_of_ocs nsex);
     Flx_exceptions.clierr2 osr nsr ("AMBIGUITY PARSING, same production!,seq = " ^ string_of_int nseq)
   end

let dyp_merge_Obj_sexpr ol = 
 match ol with
 | []
 | [_] -> assert false
 | h :: t -> 
   match fold_left smerge h t with
   ntt,gd,ld -> [ntt],gd,ld

let rec elim_common_prefix x y = 
  match x, y with
  | a :: ta, b :: tb -> 
    let eq = try a = b with _ -> false in
    if eq then elim_common_prefix ta tb
    else x,y

  | x,y -> x,y

let ssmerge ((xseq,x),xgd,xld as xit) ((yseq,y),ygd,yld as yit) =
   if xseq > yseq then xit
   else if yseq > xseq then yit
   else
   let xsr = src_of_stmt (hd x) and ysr = src_of_stmt (hd y) in
   print_endline "Ambiguity parsing statements:";
   let x = rev x and y = rev y in
   let x,y = elim_common_prefix x y in
   print_endline ("Statements 1 = " ^ catmap "\n----\n" (string_of_statement 1) x);
   print_endline ("Statement 2 = " ^ catmap "\n----\n" (string_of_statement 1) y);
   Flx_exceptions.clierr2 xsr ysr "AMBIGUITY PARSING TOP LEVEL!"


let dyp_merge_Obj_statement_star ol = 
 match ol with
 | [] 
 | [_] -> assert false
 | h::t -> 
   match fold_left ssmerge h t with
   | ntt,gd,ld -> [ntt],gd,ld

}

@head(2,'Tokens')
@select(h)

%global_data_type <global_data_t>
%local_data_type <local_data_t>

/* special */
%token <(Flx_ast.srcref * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE 
%token SLOSH
%token <(string)> COMMENT 
%token <(string)> COMMENT_NEWLINE
%token <(int)> WHITE 

/* literals */
%token <(Flx_ast.srcref * string)> NAME
%token <(Flx_ast.srcref * string * prio_t)> NONTERMINAL
%token <(Flx_ast.srcref * string * Flx_ast.bigint)> INTEGER
%token <(Flx_ast.srcref * string * string )> FLOAT
%token <(Flx_ast.srcref * string)> STRING
%token <(Flx_ast.srcref * string)> CSTRING
%token <(Flx_ast.srcref * string)> FSTRING
%token <(Flx_ast.srcref * string)> QSTRING
%token <(Flx_ast.srcref * string)> WSTRING
%token <(Flx_ast.srcref * string)> USTRING
%token <(Flx_ast.srcref * string)> USER_KEYWORD
%token <(string list)> HASH_INCLUDE_FILES
%token <(token list)> TOKEN_LIST
%token DUMMY

%token <local_data_t> LOAD_SYNTAX
%token <string> SAVE_SYNTAX

/* user defined symbols */
%token <(Flx_ast.srcref * string * string)> USER10
%token <(Flx_ast.srcref * (string * string) list * string)> USERLB
%token <(Flx_ast.srcref * string )> USERRB

@for k,v in flx_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)
  tangle("%constructor Obj_keyword %for " + k,inhibit_sref=1)

@for n,t in flx_keywords: 
  tangle("%token <(Flx_ast.srcref)> " + t,inhibit_sref=1)
  tangle("%constructor Obj_keyword %for " + t,inhibit_sref=1)

/* top level entry */
%constructor Obj_sexpr %for sterm 

/* predefined major non-terminals */
%constructor Obj_sexpr %for statement sexpr 

/* low level non terminals */
%constructor Obj_sexpr %for sname sliteral 

/* literals */
%constructor Obj_sexpr %for sinteger sfloat sstring scstring strue sfalse
%constructor Obj_sexpr %for strint strfloat strstring strtrue strfalse

/* patterns */
%constructor Obj_sexpr %for sintegral

/* tokens replacements for special symbols used in productions */
%constructor Obj_sexpr %for star plus quest suser10token sident
%constructor Obj_sexpr %for suserlbtoken suserrbtoken
%constructor Obj_sexpr %for lbrace rbrace lpar rpar lsqb rsqb 
%constructor Obj_sexpr %for ssemi comma colon vbar



/* nothing*/
%constructor Obj_sexpr %for sepsilon
%constructor Obj_sexpr %for strepsilon

%start <(Flx_ast.compilation_unit_t)> compilation_unit
%%

@head(2,'Compilation Unit')
@select(h)

compilation_unit:  
  | statements ENDMARKER { $1 }

statements:
 | statement_star 
   {
     List.rev (snd $1)
   }

statement_star:
 | statement_star statement
   @{ 
     let seq,sr,s = $2 in
     (match s with Snull -> $1 | _ ->
     let sseq,stmts = $1 in
     let s' = ocs2flx sr s in
     (max seq sseq, (s' :: stmts))),
     [Keep_grammar true; Local_data (dyp.last_local_data)]
   }

 | { 0,[] }

@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
dyprods:
   | dyprods dyprod { $2 :: $1 }
   | { [] }

opt_private:
  | PRIVATE { `Private }
  | { `Public }

opt_prio:
  | LSQB NAME RSQB { `Priority (snd $2) }
  | { `Default }

pri:
  | NAME { snd $1 }

prilist:
  | pri LESS prilist { $1 :: $3 }
  | pri { [$1] }

dyprod:
   | opt_private NAME opt_prio COLONEQUAL dyalts SEMI
     {
       `Scheme_rule ($1, snd $2, $3,`Sval,$5)
     }

   | opt_private NAME opt_prio COLON NAME EQUAL dyalts SEMI
     {
       if snd $5 <> "string" then raise Giveup;
       print_endline "STRING RULE";
       `Scheme_rule ($1, snd $2,$3,`String,$7)
     }


   | REQUIRES basic_name_comma_list SEMI
     {
        let dssls = map snd $2 in
       `Requires dssls
     }

   | NAME NAME STRING SEMI
     {
       if snd $1 <> "explain" then raise Giveup;
       `Document ((snd $2),(snd $3))
     }

   | NAME NAME EQUAL subpage_entries SEMI
     {
       if snd $1 <> "page" then raise Giveup;
       `Page ((snd $2),$4)
     }

   | NAME prilist SEMI
     {
       if snd $1 <> "priority" then raise Giveup;
       `Priorities $2
     }

subpage_entry:
  | NAME EQUAL LPAR subpage_entries RPAR { `Subpage ((snd $1),$4) } 
  | NAME { `Nt (snd $1) }

subpage_entries:
  | subpage_entry COMMA subpage_entries { $1 :: $3 }
  | subpage_entry { [$1] }

action:
   | STRING { `Scheme (snd $1) }
   | LPAR sexpr RPAR { `Expr $2 }

note:
   | NAME STRING 
     {
       if snd $1 <> "note" then raise Giveup;
       snd $2
     }
   | { "" }

dyalt:
   | rhs PARSE_ACTION action note
     { 
       let anote = $4 in
       let prod = $1 in
       let action = $3 in
       let action : action_t =
         match action with
         | `Scheme _ as x -> x
         | `None as x -> x
         | `Expr (_,_,e) ->
           `Scheme (user_expr prod e)
       in
       prod,slift $2,action,anote
     }
   | rhs { $1,dummysr,`None,"" }

dyaltlist:
   | { [] }
   | VBAR dyalt dyaltlist { $2 :: $3 }

dyalts:
   | dyalt dyaltlist { $1 :: $2 }
   | VBAR dyalt dyaltlist { $2 :: $3 }

rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

rhs_term :
  | rhs_atom { `Atom $1 }
  | LPAR dyalts RPAR { `Group $2 }

rhs_atom:
  | NAME { let sr,s = $1 in NAME (sr,s) } /* arbitrary nonterminal */
  | STRING { let sr,s = $1 in STRING (sr,s) } /* the string as an identifier */
  | IDENT { NAME ($1,"identifier") }
  | USER_KEYWORD { USER_KEYWORD $1 } /* user terminal */
  | USER10 { USER10 $1 } /* user terminal */
@for s,t in flx_keywords:
  if t != "IDENT":
    tangle("  | " +t+ " { " + t + " $1 }")
@for t,s in flx_syms:
  if t not in ["PARSE_ACTION","VBAR","LPAR","RPAR","SEMI"]:
    tangle("  | " +t+ " { " + t + " $1 }")

statement:
  | SCHEME STRING SEMI
    @{
      let sr = rstoken $1 $3 in
      let s = snd $2 in
      let failwith x = print_endline ("Evaluating " ^ s); failwith x in 
      (*
      let env = Ocs_env.env_copy dyp.local_data.env in
      *)
      let env = dyp.global_data.env in
      let r = 
        try scheme_run sr env s 
        with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
          print_endline ("Error "^err^" executing " ^s);
          failwith "Error executing SCHEME"
      in
      let local_data = { dyp.local_data with scm = (sr,s) :: dyp.local_data.scm } in
      (0,sr,Snull),[Local_data local_data]
    }

  | OPEN SYNTAX basic_name_comma_list SEMI
    @{
      (*
      print_endline "Parsed open of syntax extensions";
      print_endline "Opening syntax extensions";
      *)
      let sr = rstoken $1 $4 in
      let dssls = map snd $3 in
      let m = dyp.local_data in

      (* calculate the transitive closure of DSSL's required
         minus those already installed
      *)
      let installed = m.loaded_dssls in
      let visited = ref [] in
      let to_install = ref [] in
      let rec cal_install s =
        if mem s installed or mem s !visited then ()
        else begin
          visited := s :: !visited;
          let d = 
            try Drules.find s m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ s)
          in
          List.iter cal_install d.deps;
          to_install := s :: !to_install
        end
      in
      List.iter cal_install dssls
      ;
      let to_install = rev (!to_install) in
      (*
      print_endline ("Installing " ^ cat "," to_install);
      *)

      let rules,prios =
        fold_left (fun (acc_rules, acc_prios) dssl ->
        let rules,prios = 
          let d = 
            try Drules.find dssl m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ dssl)
          in d.rules,d.prios
        in 
        let rules = map (fun x -> dssl,x) rules in
        acc_rules @ rules, acc_prios @ prios
        )
        ([],[])
        to_install
      in

      let priority_data =
        fold_left (fun pd prios -> 
          let pd,plist = fold_left (fun (pd,plist) pri ->
            let pd,pr = insert_priority pd pri in 
            pd,(pr::plist)
          ) (pd,[]) prios
          in 
          match plist with 
          | [] 
          | [_] -> pd
          | _ ->  add_list_relations pd (rev plist)
        ) dyp.priority_data prios
      in

      let add_rules = List.map (extend_grammar dyp priority_data) rules in
      let local_data = { m with loaded_dssls = to_install @ m.loaded_dssls } in
      (0,sr,Snull),[Add_rules add_rules; Local_data local_data; Priority_data priority_data]
    }

  | SYNTAX NAME LBRACE dyprods RBRACE
    @{
      (* NOTE ORDER!! dyprods is reversed, but the fold reverses it again *)
      (*
      print_endline ("Parsed syntax extensions " ^ (snd $2));
      print_endline ("Defining syntax extensions " ^ (snd $2));
      *)
      let sr = rstoken $1 $5 in
      let dssl = snd $2 in
      let m = dyp.local_data in
      let m = 
        if Drules.mem dssl m.dssls then m 
        else {m with dssls=Drules.add dssl fresh_dssl m.dssls}
      in
      let global_data,local_data = 
        List.fold_left (fun (g,l) x -> add_rule g l dssl x) (dyp.global_data, m) $4
      in 
      (* This cal tries to avoid gratutions mods to global/local data
         by checking for physical equality. Note changes to any
         embedded mutable data structure propagate anyhow.
      *)
      let mods = 
        (if dyp.global_data != global_data then [Global_data global_data] else []) 
        @
        (if dyp.local_data != local_data then [Local_data local_data] else []) 
      in
      (0,sr,Snull),mods
    }

  | LOAD_SYNTAX 
    @{
      let local_data = $1 in
      let scm = rev local_data.scm in
      let env = dyp.global_data.env in
      List.iter (fun (sr,s) -> ignore (
        
          try scheme_run sr env s 
          with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
            print_endline ("Error "^err^" executing " ^s);
            failwith "Error executing SCHEME"
      )) 
      scm;
      (0,dummysr,Snull),[Local_data local_data]
    }

  | SAVE_SYNTAX
    {
      let this_version = !Flx_version.version_data in
      let filename = $1 in
      let x = try Some  (open_out_bin filename) with _ -> None in
      begin match x with
      | None -> ()
      | Some x ->
        print_endline ("// Save Syntax file " ^ filename);
        Marshal.to_channel x this_version [];
        Marshal.to_channel x dyp.local_data [];
        close_out x
      end;
      (0,dummysr,Snull)
    }
sexpr: | DUMMY { 0,dummysr,Snull }

/* identifiers which aren't keywords */
sname: NAME { 0,slift (fst $1),Sstring (snd $1) }

/* 
replacements for * + and ? to be used in productions,
since these symbols have special meansings as
list, non-empty list, and optional respectively
*/
star: STAR { 0,slift $1,Snull }
plus: PLUS { 0,slift $1,Snull }
quest: QUEST { 0,slift $1,Snull }
sident: IDENT { 0,slift $1,Snull }

lbrace: LBRACE { 0,slift $1,Snull }
rbrace: RBRACE { 0,slift $1,Snull }
lpar: LPAR { 0,slift $1,Snull }
rpar: RPAR { 0,slift $1,Snull }
lsqb: LSQB { 0,slift $1,Snull }
rsqb: RSQB { 0,slift $1,Snull }

ssemi: SEMI { 0,slift $1,Snull }
comma: COMMA { 0,slift $1,Snull }
colon: COLON { 0,slift $1,Snull }
vbar: VBAR { 0,slift $1,Snull }
strue: TRUE { 0,slift $1,Snull }
sfalse : FALSE { 0,slift $1,Snull }

strtrue: TRUE { 0,slift $1,Sstring "true" }
strfalse : FALSE { 0,slift $1,Sstring "false" }

/* 
a definite non-terminal for a sequence of no tokens,
since the production syntax cannot parse an empty
production at the moment 
*/
sepsilon: | {0,dummysr,Snull }
strepsilon: | {0,dummysr,Sstring "" }

sinteger:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      0,slift sr,Sbigint v
    }

strint:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let s = Big_int.string_of_big_int v in
      0,slift sr,Sstring s
    }

sfloat:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      let x = Sstring t::Sstring v::[] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

strfloat:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      0,slift sr,Sstring v
    }


sintegral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      0,slift sr,x
    }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in
      let v = Big_int.minus_big_int v in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      0,slift sr,x
    }

sstring:
  | STRING
    { 
      let sr,s = $1 in
      0,slift sr,Sstring s
    }

strstring:
  | STRING
    { 
      let sr,s = $1 in
      let s = Flx_string.c_quote_of_string s in
      0,slift sr,Sstring s
    }

scstring:
  | CSTRING
    { 
      let sr,s = $1 in
      0,slift sr,Sstring s
    }


sliteral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let v = Big_int.string_of_big_int v in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let aint = Ocs_sym.get_symbol "ast_int" in 
      let i = aint :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | FLOAT   
    { 
      let sr,t,v = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let afloat = Ocs_sym.get_symbol "ast_float" in 
      let i = afloat :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | STRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_string" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
   }

  | WSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_wstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | USTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_ustring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_cstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | QSTRING  
    { 
      let sr,s = $1 in
      let qstring = Ocs_sym.get_symbol "ast_interpolate" in 
      let x = qstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | FSTRING  
    { 
      let sr,s = $1 in
      let fstring = Ocs_sym.get_symbol "ast_vsprintf" in 
      let x = fstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

suser10token:
  | USER10 
    { 
      let sr,op,fn = $1 in
      0,slift sr,Sstring fn
    }

suserlbtoken:
  | USERLB
  {
    let sr, ass, sym = $1 in
    let ass = List.rev_map (fun (k,f) -> 
      let x = Sstring k :: Sstring f :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
      ) 
      ass 
    in
    let ass = Ocs_misc.make_slist Snull ass in
    let x = ass :: Sstring sym :: [] in
    let x = Ocs_misc.make_slist Snull (rev x) in
    0,slift sr,x
  }

suserrbtoken:
  | USERRB
  {
    0,slift (fst $1),Sstring (snd $1)
  }

basic_name: 
  | NAME { $1 }
@commalistof("basic_name")

epsilon: | {()}

%mlitop {
open Flx_token
open Flx_mtypes2
}

%mli { 
  exception Scheme_error of Ocs_types.sval 
  val global_data : global_data_t
}

@head(1,'Parser object')
@h = tangler('src/compiler/flxlib/flx_parse_ctrl.ml')
@select(h)

open Flx_ast
open Flx_token
open Flx_exceptions
open Flx_parse

let dyphack (ls : ( 'a * Dyp.priority) list) : 'a =
  match ls with
  | [x,_] -> x
  | _ -> failwith "Dypgen parser failed"

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
  expand_expr
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
      expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
  let hash_include_files, tokens = match tokens with
    | HASH_INCLUDE_FILES fs :: t -> fs,t
    | _ -> assert false
  in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError ("Failure \""^s^"\" Parsing File"))
        end
      | Flx_exceptions.ClientError _ 
      | Flx_exceptions.ClientError2 _ 
      | Flx_exceptions.ClientErrorn _ as x  ->
        begin
          toker#report_syntax_error;
          raise x
        end

      | Flx_exceptions.RDP_match_fail (sr1,sr2,s) as x  ->
        begin
          toker#report_syntax_error;
          clierr2 sr1 sr2 ("User Syntax Parse Error " ^ s)
        end

      | Dyp.Bad_constructor (nt,ctor1, ctor2) ->
          toker#report_syntax_error;
          let s = "Bad constructor '" ^ ctor1 ^ "' and '" ^ ctor2 ^ "' for nonterminal '" ^ nt ^"'" in
          print_endline s;
          failwith s

      | x -> 
        begin
          toker#report_syntax_error;
          print_endline (Printexc.to_string x);
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
      in hash_include_files, parse_tree
    end

let parse_string (data : string) (filename : string) expand_expr = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/compiler/flxlib/flx_parse_ctrl.mli')
@select(h)
open Flx_ast

val parse_file : 
  string -> (* filenames *)
  string ->
  string list ->
  (string -> expr_t -> expr_t) ->
  string list * compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  (string -> expr_t -> expr_t) ->
  compilation_unit_t

@head(1,'Parser test harness')
@h = tangler('src/compiler/drivers/flxp.ml')
@select(h)
open Flx_mtypes2
open Flx_types
open Flx_version
open Flx_flxopt
open Flx_getopt
open Flx_token
;;

let print_help () = print_options(); exit(0)
;;

let run() =
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  Flx_pdoc.document_grammar := compiler_options.document_grammar;
  Flx_parse.global_data.pdebug := compiler_options.print_flag;

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;

  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" in

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline ("Parsing " ^ input_file_name);
    print_endline "---------------------------------------";
  end
  ;

  let _,parse_tree = 
    Flx_parse_ctrl.parse_file 
    input_file_name
    (Filename.dirname input_file_name)
    compiler_options.include_dirs
    Flx_macro.expand_expression
  in
    print_endline (Flx_print.string_of_compilation_unit parse_tree);

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline "PARSE OK";
    print_endline "---------------------------------------";
  end
  ;

  flush stdout;

  if compiler_options.document_grammar then 
    Flx_pdoc.gen_doc();

in
  run()
;;


