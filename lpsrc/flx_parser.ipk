@head(1,'Parser')
@h = tangler('src/flx_parse.mly')
@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
%{
exception EndOfInput
open Flx_types
open Flx_srcref

let list_last lst = List.hd (List.rev lst)

let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) = 
  let sr = rslist tup in
  AST_apply 
  (
    sr, 
    (
      AST_name (lift sri,([fn],TYP_none)), 
      AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t = 
  let sr = src_of_expr arg in
  AST_apply 
  (
    sr, 
    (
      AST_name (lift sri, ([fn],TYP_none)),
      arg
    )
  )

(* model binary operator as procedure call *)
let assign (op:string) (sr:range_srcref) (sri:srcref) l r = 
  AST_call 
  (
    sr,
    AST_name (lift sri, ([op], TYP_none)),
    AST_tuple 
    (
      sr, 
      [ AST_ref (src_of_expr l,l); r]
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l = 
  AST_call 
  (
    sr,
    AST_name (lift sri, ([op], TYP_none)),
    AST_ref (src_of_expr l,l)
  )

let mkcurry sr name args return_type body =
  let mkfuntyp d c = TYP_function (d,c)
  and typeoflist lst = match lst with
    | [x] -> x
    | _ -> TYP_tuple lst
  in 
  let mkret arg ret = mkfuntyp (typeoflist (List.map snd arg)) ret in
  let arity = List.length args in
  let rettype args = List.fold_right mkret args return_type in

  let rec aux args =  
    let n = List.length args in
    let name n = 
      if n = arity
      then name (* top level *)
      else "_curry_" ^ string_of_int n
    in
    match args with 
    | [] -> assert false
    | h :: [] -> (* bottom level *)
      (match return_type with
      | TYP_void -> 
        AST_procedure (sr, TYP_void, name n, h, body) 
        (* Note that this 'TYP_void' is supposed to be
           the type of the message: unused at present!
        *)
      | _ -> 
        AST_function (sr, name n, h, return_type, body)
      )
    | h :: t ->
      let m = List.length args in
      let body = 
        [
          aux t;
          AST_return 
          (
            sr,
            AST_name 
            (
              sr,
              (
                [name (m-1)],
                typeoflist (List.map snd (List.hd t))
              )
            )
          )
        ] 
      in
        AST_function (sr, name m, h, rettype t, body)
   in aux args

%}

@head(2,'Tokens')
@select(h)
/* special */
%token<Flx_types.srcref * string> ERRORTOKEN

/* whitespace */
%token NEWLINE 
%token<string> COMMENT 
%token<string> COMMENT_NEWLINE
%token<int> WHITE 


/* constants */
%token ENDMARKER

/* literals */
%token<Flx_types.srcref * string> NAME
%token<Flx_types.srcref * string * Big_int.big_int> INTEGER
%token<Flx_types.srcref * string * string > FLOAT
%token<Flx_types.srcref * string> STRING
%token<Flx_types.srcref> INF
%token<Flx_types.srcref> NAN 
%token<Flx_types.srcref> ROOT

/* operators and punctuation */

/* assignment */
%token<Flx_types.srcref> EQUAL

/* math */
%token<Flx_types.srcref> PLUS MINUS STAR SLASH PERCENT STARSTAR 

/* comparison */

/* logic */
%token<Flx_types.srcref> AMPER VBAR PERCENT
%token<Flx_types.srcref> EXCLAMATION

/* brackets */
%token<Flx_types.srcref> LPAR RPAR 
%token<Flx_types.srcref> LSQB RSQB 
%token<Flx_types.srcref> LBRACE RBRACE  
%token<Flx_types.srcref> LSQANGLE RSQANGLE

/* terminal */
%token<Flx_types.srcref> COLON COMMA SEMI DOT BACKQUOTE

/* comparison */
%token<Flx_types.srcref> LESS GREATER EQEQUAL NOTEQUAL LESSEQUAL GREATEREQUAL 
%token<Flx_types.srcref> ANDLESS ANDGREATER ANDEQEQUAL ANDNOTEQUAL ANDLESSEQUAL ANDGREATEREQUAL 

/* bitwise */
%token<Flx_types.srcref> TILDE CIRCUMFLEX LEFTSHIFT RIGHTSHIFT DOUBLESTAR

/* read-modify-write */
%token<Flx_types.srcref> PLUSPLUS MINUSMINUS PLUSEQUAL MINUSEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL
%token<Flx_types.srcref> CARETEQUAL VBAREQUAL AMPEREQUAL TILDEEQUAL COLONEQUAL
%token<Flx_types.srcref> LEFTSHIFTEQUAL RIGHTSHIFTEQUAL LEFTARROW RIGHTARROW COLONGREATER LESSCOLON
%token<Flx_types.srcref> LEFTRIGHTARROW 

/* other */
%token<Flx_types.srcref> COLONCOLON
%token<Flx_types.srcref> DOTDOT SLOSH DOTDOTDOT

/* operator keywords */
%token<Flx_types.srcref> NOT OR AND LAMBDA LAZY
/* patterns */
%token<Flx_types.srcref> AS ANY REGEXP WHEN

/* statement keywords */
%token<Flx_types.srcref> IF THEN ELSE ENDIF ELIF OF VAR UNION CLASS CATEGORY EXCEPTIONS GOTO EXPORT

%token<Flx_types.srcref> MATCH WITH ENDMATCH CASE HEADER MODULE CODE
%token<Flx_types.srcref> SERVICE COMMAND HANDLER CALL PROCEDURE FUNCTION SLP READER FUNCTOR
%token<Flx_types.srcref> UNIT RETURN FORK VOID
%token<Flx_types.srcref> WHILE LOOP
%token<Flx_types.srcref> TODO INTERFACE
%token<Flx_types.srcref> TYPE FUN READ PROC CONST STRUCT RAISE ATTEMPT FINALLY EXCEPT VAL TYPEDEF


%type <Flx_types.compilation_unit_t> compilation_unit
%type <Flx_types.range_srcref * Flx_types.statement_t list> compound
%type <Flx_types.range_srcref * Flx_types.id_t> simple_name
%type <Flx_types.range_srcref * Flx_types.qualified_name_t> qualified_name
%type <Flx_types.range_srcref * Flx_types.suffixed_name_t> suffixed_name
%type <Flx_types.range_srcref * Flx_types.suffixed_mname_t> suffixed_mname
%type <Flx_types.statement_t> statement 
%type <Flx_types.expr_t> expr
%type <Flx_types.mexpr_t> mexpr
%type <Flx_types.mexpr_t> mapplication
%type <Flx_types.expr_t> rvalue

%type <Flx_types.pattern_t> pattern

%start compilation_unit
%%
/* empty: { [] } */

@head(2,'Compilation Unit')
@select(h)
compilation_unit:  
  | statement_aster ENDMARKER { $1 }

@aster("statement")
@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
statement:
  | binding_definition { $1 }
  | declarative { $1 }
  | executable { $1 }

@doc()
There are three rough categories of statements.

@select(h)
binding_definition:
  | abstract_type { $1 }
  | const_def { $1 }
  | binding_header { $1 }
  | export_statement { $1 }

@doc()
A binding definition is used to bind a entity to the implementation
language.
 
@select(h)
declarative:
  | type_alias { $1 }
  | function_definition { $1 }
  | procedure_definition { $1 }
  | module_definition { $1 }
  | union_decl { $1 }
  | struct_decl { $1 }
  | interface_decl { $1 }
  
executable:
  | var_def { $1 }
  | val_def { $1 }
  | call { $1 }
  | read { $1 }
  | return { $1 }
/*  | block { $1 } */
  | if_stmt { $1 }
  | while_stmt { $1 }
  | todo { $1 }
  | attempt_stmt { $1 }
  | raise_stmt { $1 }
  | match_stmt { $1 }
  | assignment { $1 } 
  | inline_cpp { $1 } 
  | goto_statement { $1 }
  | label_statement { $1 }

@head(3,'Abstract Type')
@select(h)
abstract_type:
  | TYPE NAME EQUAL STRING SEMI 
    { 
      AST_abs_decl (rstoken $1 $5, snd $2, snd $4) 
    }

@head(3,'Union Binding')
@select(h)
union_decl:
  | UNION NAME EQUAL type_sum_items SEMI 
    { 
      AST_union (rstoken $1 $5, snd $2, $4) 
    }
  | UNION NAME EQUAL VBAR type_sum_items SEMI 
    { 
      AST_union (rstoken $1 $6, snd $2, $5) 
    }
type_sum_items:
  | type_sum_items VBAR type_sum_item { $1 @ [$3] }
  | type_sum_item { [$1] }
type_sum_item:
  | NAME OF type_product { (snd $1,$3) }
  | NAME { (snd $1,TYP_void) }

@head(3,'Struct Binding')
@select(h)
struct_decl:
  | STRUCT NAME EQUAL LBRACE struct_component_aster RBRACE 
  { 
    AST_struct (rstoken $1 $6, snd $2, $5) 
  }
  | STRUCT NAME LBRACE struct_component_aster RBRACE 
  { 
    AST_struct (rstoken $1 $5, snd $2, $4) 
  }

@aster("struct_component")
struct_component:
  | NAME COLON type_expr SEMI { (snd $1,$3) }


@head(3,'Abstract Constant Binding')
@select(h)
const_def:
  | CONST NAME COLON type_expr EQUAL STRING SEMI 
  { 
    AST_const_decl (rstoken $1 $7, snd $2, $4, snd $6) 
  }


@head(3,'Binding Header Definition')
@select(h)
binding_header:
  | HEADER STRING SEMI { AST_header (rstoken $1 $3, snd $2) }

@head(3,'Inline C++ Code Definition')
@select(h)
inline_cpp:
  | CODE STRING SEMI { AST_code (rstoken $1 $3, snd $2) }

@head(3,'Type Alias')
@select(h)
type_alias:
  | TYPEDEF NAME EQUAL type_expr SEMI 
    { 
      AST_type_alias (rstoken $1 $5, snd $2, $4) 
    }

@head(3,'Export')
@select(h)
export_statement:
  | EXPORT suffixed_name AS STRING SEMI 
    { 
      AST_export (rstoken $1 $5, snd $2, snd $4) 
    }
 
@head(3,'Function and Procedure Definition')
@select(h)
pparam:
  | NAME { TYP_name [snd $1] }
  | AMPER NAME { TYP_pointer (TYP_name [snd $2]) }
pparams:
  | pparam STAR pparams { $1 :: $3 }
  | pparam { [$1] }

fun_arg:
  | LPAR parameter_comma_list RPAR { rstoken $1 $3,$2 }

fun_args:
  | fun_arg fun_args      { $1 :: $2 }
  | fun_arg               { [$1] }

function_definition:
  | FUNCTION NAME fun_args COLON type_expr compound 
    { 
      let sr = rsrange (lift $1) (fst $6)
      and name = snd $2 
      and return_type = $5
      and body = snd $6
      and args = List.map snd $3 (* elide srcref *)
      in mkcurry sr name args return_type body
    }

  | FUNCTION NAME COLON UNIT RIGHTARROW type_expr EQUAL STRING SEMI 
    { 
      AST_fun_decl (rstoken $1 $9, snd $2, [],  $6,  snd $8) 
    }
  | FUNCTION NAME COLON pparams RIGHTARROW type_expr EQUAL STRING SEMI 
    { 
      AST_fun_decl (rstoken $1 $9, snd $2,  $4,  $6,  snd $8) 
    }
  | FUNCTION NAME fun_args compound 
    {
      failwith ("Missing return type in declaration of function " ^ snd $2)
    }
  
procedure_definition:
  | PROCEDURE NAME compound 
    { 
      AST_procedure (rsrange (lift $1) (fst $3), TYP_void, snd $2, [], snd $3) 
    }
  | PROCEDURE NAME fun_args compound 
    { 
      let sr = rsrange (lift $1) (fst $4)
      and name = snd $2 
      and return_type = TYP_void
      and body = snd $4
      and args = List.map snd $3 (* elide srcref *)
      in mkcurry sr name args return_type body
    }
  | PROCEDURE NAME COLON UNIT EQUAL STRING SEMI 
    { 
      AST_proc_decl (rstoken $1 $7, snd $2, [],  snd $6) 
    }
  | PROCEDURE NAME COLON pparams EQUAL STRING SEMI 
    { 
      AST_proc_decl (rstoken $1 $7, snd $2,  $4,  snd $6) 
    }


@commalistof("parameter")
parameter:
  | NAME COLON type_expr { snd $1,$3 }
 
@doc()
Flx functions and procedures are first class citizens: the may both be passed
as arguments to procedures, and they may both be be returned from functions.
Only functions may be passed to functions.

@head(3,'Goto and Label')
The goto and label statements are ONLY for testing!
Note labels are declared like
@begin_displayed_code()
label:>
@end_displayed_code()
to avoid ambiguity with 'x:int'.
@select(h)
goto_statement:
  | GOTO NAME SEMI 
    { 
      AST_goto (rstoken $1 $3, snd $2) 
    }
label_statement:
  | NAME COLONGREATER 
    { 
      AST_label (rstoken (fst $1) $2, snd $1) 
    }

@head(3,'Read Statement')
@select(h)
read:         
  | READ NAME SEMI            
    { 
      AST_read (rstoken $1 $3, snd $2) 
    }
@doc()
The read statement is responsible for specifying the variable to contain
the next message, and exchanging control with the dispatcher on entry,
to wait for the message, and resuming control when the message is
placed in the variable by the dispatcher.

@head(3,'Module Definition')
@select(h)
@commalistof("mparameter")
mparameter:
  | NAME COLON mtype_expr { snd $1,$3 }

/*
mpparam:
  | NAME { MTYP_name [snd $1] }
  | AMPER NAME { MTYP_pointer (MTYP_name [snd $2]) }
mpparams:
  | mpparam STAR mpparams { $1 :: $3 }
  | mpparam { [$1] }
*/

mfun_arg:
  | LPAR mparameter_comma_list RPAR { rstoken $1 $3,$2 }

mfun_args:
  | mfun_arg mfun_args      { $1 :: $2 }
  | mfun_arg               { [$1] }


module_definition:
  | MODULE NAME compound 
    { 
      AST_module 
      (
        rsrange (lift $1) (fst $3), 
        snd $2, 
        snd $2, 
        snd $3
      ) 
    }

  | MODULE NAME COLON NAME compound 
    { 
      AST_module 
      (
        rsrange (lift $1) (fst $5), 
        snd $2, 
        snd $4, 
        snd $5
      ) 
    }

  | MODULE NAME COLON NAME EQUAL compound 
    { 
      AST_module 
      (
        rsrange (lift $1) (fst $6), 
        snd $2, 
        snd $4, 
        snd $6
      ) 
    }

  | MODULE NAME EQUAL compound 
    { 
      AST_module 
      (
        rsrange (lift $1) (fst $4), 
        snd $2, 
        snd $2, 
        snd $4
      ) 
    }

  | FUNCTOR NAME mfun_args COLON mtype_expr compound
    {
      let sr = rsrange (lift $1) (fst $6)
      and name = snd $2 
      and return_type = $5
      and body = snd $6
      and args = List.map snd $3 (* elide srcref *)
      in match args with
      | [x] ->
        AST_functor (sr, name, x, return_type, body)
      | _ -> failwith "Can't handle functor of more than one arg"
    }

  | MODULE NAME EQUAL mexpr SEMI
    {
      AST_module_binding 
      (
        rsrange (lift $1) (lift $5), 
        snd $2, 
        $4 
      )
    }

interface_entry:
  | TYPE NAME SEMI                  { IAST_type (snd $2); }
  | VAL NAME COLON type_expr SEMI  { IAST_val (snd $2, $4); }
  | VAR NAME COLON type_expr SEMI  { IAST_var (snd $2, $4); }
  | PROCEDURE NAME COLON type_expr SEMI  { IAST_procedure (snd $2, $4); }
  | FUNCTION NAME COLON type_expr SEMI  { IAST_function (snd $2, $4); }
  
interface_decl:
  | INTERFACE NAME LBRACE interface_entry_aster RBRACE
    {
      AST_interface
      (
        rstoken $1 $5,
        snd $2,
        $4
      )
    }

  | INTERFACE NAME EQUAL LBRACE interface_entry_aster RBRACE
    {
      AST_interface
      (
        rstoken $1 $6,
        snd $2,
        $5
      )
    }

@aster("interface_entry")

@head(3,'Module expression')
@select(h)
mexpr:
  | mtuple { $1 }
  
mtuple:
  | mapplication_comma_list 
    { 
      let lst = $1 in 
      MAST_tuple ( rsmlist lst, lst) 
    }

mapplication:
  | mapplication mfactor                  
    { 
      MAST_apply (rsmexpr $1 $2, ($1, $2)) 
    }
  | mfactor              { $1 }


mfactor:
  | mfactor DOT NAME     { MAST_dot (lift $2, ($1, snd $3)) }
  | matom                { $1 }

matom:
  | LPAR mexpr RPAR      { $2 }
  | suffixed_mname       { MAST_name (fst $1,snd $1) }

suffixed_mname:
  | qualified_name OF LPAR mtype_expr RPAR 
    { 
      fst $1,
      (snd $1, $4)
    }
  | qualified_name 
    { 
      fst $1, 
      (snd $1, MTYP_none) 
    }

@commalistof("mapplication")

@head(2,'Module Type Grammar')
@select(h)
/* MODULE TYPE GRAMMAR */
mtype_expr:
  | mtype_arrow { $1 }

/* arrow has the lowest precedence, and associates right */
mtype_arrow:
  | mtype_product RIGHTARROW mtype_arrow { MTYP_function ($1,$3) }
  | mtype_product { $1 }

/* star is left associative */
mtype_product:
  | mtype_pointer STAR mtype_product_list { MTYP_tuple ($1 :: $3) }
  | mtype_pointer{ $1 }
mtype_product_list:
  | mtype_pointer STAR mtype_product_list { $1 :: $3 }
  | mtype_pointer { [$1] }

mtype_pointer:
  | AMPER mtype_atom { MTYP_pointer $2 }
  | mtype_atom { $1 }
mtype_atom:
  | LPAR mtype_expr RPAR { $2 }
  | UNIT { MTYP_tuple [] }
  | LPAR RPAR { MTYP_tuple [] }
  | qualified_mtype_name { MTYP_name $1 }

relative_mtype_name:
  | relative_mtype_name COLONCOLON NAME { $1 @ [snd $3] }
  | NAME { [snd $1] }
qualified_mtype_name:
  | COLONCOLON relative_mtype_name { "" :: $2 }
  | relative_mtype_name { $1 }

@head(3,'Variable and Constant Declaration')
@select(h)
var_def:  
  | VAR NAME EQUAL expr SEMI  
    { 
      AST_var_decl (rstoken $1 $5, snd $2, None, Some $4) 
    }
  | VAR NAME COLON type_expr EQUAL expr SEMI  
    { 
      AST_var_decl (rstoken $1 $7, snd $2, Some $4, Some $6) 
    }
  | VAR NAME COLON type_expr SEMI  
    { 
      AST_var_decl (rstoken $1 $5, snd $2, Some $4, None) 
    }
val_def:  
  | VAL NAME EQUAL expr SEMI  
    { 
      AST_val_decl (rstoken $1 $5, snd $2, None, Some $4) 
    }
  | VAL NAME COLON type_expr EQUAL expr SEMI  
    { 
      AST_val_decl (rstoken $1 $7, snd $2, Some $4, Some $6) 
    }
  | VAL NAME COLON type_expr SEMI  
    { 
      AST_val_decl (rstoken $1 $5, snd $2, Some $4, None) 
    }
@doc()
Variables can be declared in both procedures and functions.

@head(3,'Function or Procedure Return')
@select(h)
return:       
  | RETURN expr SEMI          { AST_return (rstoken $1 $3, $2) }
@doc()
The return statement is only permitted as the last statement
in a function.

@head(3,'Procedure Call')
@select(h)
compound:     
  | LBRACE statement_aster RBRACE  { rstoken $1 $3, $2 }

/*
block:        
  | compound { AST_block (fst $1, snd $1) }
*/

@doc()
A procedure call looks like a function application,
followed by a semicolon:
@begin_displayed_code()
  p a;
  f1 a1 a2 a3; 
@end_displayed_code()
are valid procedure calls. Note in the second
example, f1 and f1 a1 are functions, whilst
the function call f1 a1 a2 must return a procedure
which accepts a3.
@p()
There is a special case: a single name followed
by a semi-colon is considered a call of the
designated procedure passing the unit argument,
so that the following are equivalent:
@begin_displayed_code()
  print_eol ();
  print_eol;
@end_displayed_code()
Note that there is no ambiguity with passing
procedures as arguments: the name always
represents a procedure closure in an expression
context, never a call.
@p()
Note again that this special case only
applies to names, not general expressions,
but the name doesn't have to be a procedure
constant: it could be a variable name.
@begin_displayed_code()
  val eol = print_eol;
  eol; // means eol()
  sin x; // error: function application
  (sin x); // still an error!
@end_displayed_code()

@select(h)
call:
  | application SEMI {
    match $1 with 
    | AST_apply (s,(proc, arg)) -> 
      AST_call (rsrange s (lift $2), proc, arg)

    | AST_name (s,name) as proc ->
      AST_call (rsrange s (lift $2), proc, AST_tuple (lift $2, []))

    | AST_lambda(sr,([],TYP_void,stmts)) ->
      AST_block (sr,stmts)

    | _ -> failwith 
    (
      "Procedure call requires application, got " ^
      Flx_print.string_of_expression $1
    )
  }

  | CALL application SEMI {
    match $2 with 
    | AST_apply (s,(proc, arg)) -> 
      AST_call (rsrange s (lift $3), proc, arg)
    | _ -> failwith "Procedure call requires application"
  }

assignop:
  | LEFTARROW       { $1,"set" }
  | EQUAL           { $1,"set" }
  | COLONEQUAL      { $1,"set" }
  | PLUSEQUAL       { $1,"pluseq" }
  | MINUSEQUAL      { $1,"minuseq" }
  | STAREQUAL       { $1,"muleq" }
  | SLASHEQUAL      { $1,"diveq" }
  | PERCENTEQUAL    { $1,"modeq" }
  | LEFTSHIFTEQUAL  { $1,"leftshifteq" }
  | RIGHTSHIFTEQUAL { $1,"rightshifteq" }
  | CARETEQUAL      { $1,"careteq" }
  | VBAREQUAL       { $1,"vbareq" }
  | AMPEREQUAL      { $1,"ampereq" }
  | TILDEEQUAL      { $1,"tildeeq" }
  | LEFTRIGHTARROW  { $1,"swap" }

incrop:
  | PLUSPLUS        { $1,"incr" }
  | MINUSMINUS      { $1, "decr" }

assignment: 
  | expr assignop expr SEMI 
    { 
      let src,sname = $2 in
      let sr = rsrange (src_of_expr $1) (lift $4) in
      assign sname sr src $1 $3 
    }
  | expr incrop SEMI 
    {
      let src,sname = $2 in
      let sr = rsrange (src_of_expr $1) (lift $3) in
      call1 ("post_" ^ sname) sr src $1
    }
  | incrop expr SEMI
    {
      let src,sname = $1 in
      let sr = rsrange (lift src) (lift $3) in
      call1 ("pre_" ^ sname) sr src $2
    }


@doc()
Note that a block is an anonymous procedure defintion together with
a call to that procedure with the unit argument.
@p()
The assignment statement 'v <- e;' is syntact sugar for 'set(&v,e);'.

@head(3,'Place Holder')
@select(h)
todo:         
  | TODO STRING SEMI        { AST_nop (rstoken $1 $3, snd $2) }
  | TODO SEMI               { AST_nop (rstoken $1 $2, "") }
  | SEMI                    { AST_nop (rstoken $1 $1,"") }

@doc()
The placed holder is used to denote an incomplete section of code.
A string may be included after the 'todo' keyword to serve as a reminder
of the programmers intentions.

@head(3,'Loop Statements')
@select(h)
while_stmt:   
  | WHILE LPAR expr RPAR statement      
    { 
      AST_while (rsrange (lift $1) (src_of_statement $5), $3,$5) 
    }
  | LOOP statement                      
    { 
      let dummy = lift $1 in
      AST_while (
        rsrange (lift $1) (src_of_statement $2),
        AST_literal (dummy,(AST_bool true)), 
        $2
      ) 
    }
@doc()
The while statement provides a loop terminated by a condition.
The condition is tested before executing the loop body.

@head(3,'If/Then/Elif/Else')
@select(h)
elif_clause:
  | ELIF LPAR expr RPAR statement 
    { 
      rsrange (lift $1) (src_of_statement $5), ($3, $5) 
    }

else_clause:
  | ELSE statement 
    { 
      rsrange (lift $1) (src_of_statement $2), $2 
    }

if_clause:
  | IF LPAR expr RPAR statement 
    { 
      rsrange (lift $1) (src_of_statement $5),($3, $5) 
    } 

elif_clauses:
  | elif_clause elif_clauses { $1 :: $2 }
  | elif_clause { [$1] }

ifelif_clause:
  | if_clause elif_clauses { $1 :: $2 }
  | if_clause { [$1]}

if_stmt: 
  | ifelif_clause else_clause 
    { 
      AST_if 
      (
        rsrange (fst (List.hd $1)) (fst $2), 
        $1, 
        $2
      )
    } 
  | ifelif_clause 
    {  
      AST_if 
      (
        fst (List.hd $1), 
        $1, 
        (generated,AST_nop (generated,""))
      ) 
    } 

@doc()
The if/then/elif/else constuction provides conditional execution
of at most one branch; if the else clause is included, then
exactly one branch is executed. The conditions are tested
in order of writing.

@head(3,'Attempt/Raise/Except/Finally')
@select(h)
raise_stmt:   
  | RAISE NAME SEMI      
    { 
      AST_raise 
      (
        rstoken $1 $3,
        snd $2, 
        AST_tuple (rstoken $1 $3,[])
      )
    }
  | RAISE NAME expr SEMI 
    { 
      AST_raise 
      (
        rstoken $1 $4,
        snd $2, 
        $3
      )
    }

attempt_stmt:
  | attempt_clause except_clause finally_clause 
    { 
      AST_attempt 
      (
        rsrange (fst $1) (fst $3), 
        $1, 
        $2, 
        $3
      ) 
    }
  | attempt_clause finally_clause 
    { 
      AST_attempt 
      (
        rsrange (fst $1) (fst $2), 
        $1, 
        (generated,[]), 
        $2
      ) 
    }
  | attempt_clause except_clause 
    { 
      AST_attempt 
      (
        rsrange (fst $1) (fst $2), 
        $1, 
        $2, 
        (generated,[])
      ) 
    }

attempt_clause: 
  ATTEMPT statement 
  { 
    rsrange (lift $1) (src_of_statement $2), 
    $2 
  }
except_clause:  
  EXCEPTIONS LBRACE exception_clause_aster RBRACE 
  { 
    rstoken $1 $4, 
    $3 
  }
finally_clause: 
  FINALLY compound 
  { 
    rsrange (lift $1) (fst $2), 
    snd $2 
  }

exception_clause:
  | NAME LPAR parameter_comma_list RPAR compound 
    { 
      AST_except_handler 
      (
        rsrange (lift (fst $1)) (fst $5), 
        snd $1, 
        $3, 
        snd $5
      ) 
    }
  | NAME compound 
    { 
      AST_except_handler 
      (
        rsrange (lift (fst $1)) (fst $2),
        snd $1, 
        [], 
        snd $2
      ) 
    }
@aster("exception_clause")

@doc()
The attempt/raise/exceptions/finally construction
provides a block with multiple terminating conditions
and an optional finally clause. While this construction
resembles exception handling, the target of a raise statement
must be in scope and is bound at compile time.
@p()
Note that a raise statement causes a branch to 
the innermost matching exception signature; that is,
branches may go to an entry point in a containing
attepmt block.
@p()
More than one exception handler may be specified with the same
name in an exception handling group, provided each instance
has an argument of a different type.
@p()
A raise statement without an argument after the exception
handler name implicitly passes a unit argument.

@head(3,'Pattern Matching')
@select(h)
match_stmt:
  | MATCH LPAR expr RPAR LBRACE matchings RBRACE 
  { 
    AST_match (rstoken $1 $7, $3, $6) 
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | CASE pattern COLON statement { $2, $4 }
  | vbar_pattern COLON statement { $1, $3 }

@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
/* patterns */
integral:
  | INTEGER { let sr,t,v = $1 in lift sr, t, v }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in 
      rstoken $1 sr, t, Big_int.minus_big_int v 
    }

floating:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      lift sr, Float_plus (t,v) 
    }
  | MINUS FLOAT 
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v) 
    }
  | INF { lift $1, Float_inf }
  | MINUS INF { lift $1, Float_minus_inf }

atomic_pattern:
  /* constants */
  | STRING { PAT_string (lift (fst $1), snd $1) }
  | integral 
    { 
      let sr,t,v = $1 in
      PAT_int (sr,t,v) 
    }
  | NAN { PAT_nan (lift $1) }
  
  /* ranges */
  | STRING DOTDOT STRING 
    { 
      PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral 
    { 
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)  
    }

| floating DOTDOT floating 
    { 
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      PAT_float_range 
      (
       rsrange sr1 sr2, 
       v1, v2
      ) 
    }

  /* other */
  | NAME { PAT_name (lift (fst $1), snd $1) }
  | ANY { PAT_any (lift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR simple_name_comma_list RPAR 
    { 
      let names = List.map snd $4 in
      PAT_regexp (rstoken $1 $5, snd $2, names) 
    }
@commalistof("simple_name")

atomic_pattern_list:
  | atomic_pattern COMMA atomic_pattern_list { $1 :: $3 }
  | atomic_pattern { [$1] }

tuple_pattern:
  | atomic_pattern_list 
    { 
      match $1 with 
      | [x] -> x 
      | _ -> PAT_tuple 
        (
          rsrange (src_of_pattern (List.hd $1)) (src_of_pattern (list_last $1)),
          $1
        )
    }

vbar_pattern:
  | VBAR qualified_name tuple_pattern 
    { 
      PAT_nonconst_ctor 
      (
        rsrange (lift $1) (src_of_pattern $3), 
        snd $2, 
        $3
      ) 
    }
  | VBAR qualified_name 
    { 
      PAT_const_ctor 
      (
        rsrange (lift $1) (fst $2), 
        snd $2 
      )
    }

variant_pattern:
  | vbar_pattern { $1 }
  | tuple_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME 
    { 
      PAT_as 
      (
        rsrange (src_of_pattern $1) (lift (fst $3)), 
        $1, 
        snd $3
      ) 
    }
  | variant_pattern { $1 }

pattern:
  | as_pattern WHEN expr 
    { 
      PAT_when 
      (
        rsrange (src_of_pattern $1) (src_of_expr $3),
        $1, 
        $3
      ) 
    }
  | as_pattern { $1 }

@head(2,'Type Grammar')
@select(h)
/* TYPE GRAMMAR */
type_expr:
  | type_arrow { $1 }

/* arrow has the lowest precedence, and associates right */
type_arrow:
  | type_product RIGHTARROW type_arrow { TYP_function ($1,$3) }
  | type_product { $1 }

/* star is left associative */
type_product:
  | type_pointer STAR type_product_list { TYP_tuple ($1 :: $3) }
  | type_pointer{ $1 }
type_product_list:
  | type_pointer STAR type_product_list { $1 :: $3 }
  | type_pointer { [$1] }

type_pointer:
  | AMPER type_atom { TYP_pointer $2 }
  | type_atom { $1 }
type_atom:
  | LPAR type_expr RPAR { $2 }
  | UNIT { TYP_tuple [] }
  | VOID { TYP_void }
  | LPAR RPAR { TYP_tuple [] }
  | qualified_type_name { TYP_name $1 }

relative_type_name:
  | relative_type_name COLONCOLON NAME { $1 @ [snd $3] }
  | NAME { [snd $1] }
qualified_type_name:
  | COLONCOLON relative_type_name { "" :: $2 }
  | relative_type_name { $1 }

@head(2,'Names')
The simplest form of a name is an identifier.
@p()
An instantiated name is a identifier possibly followed by
an a comma separated list of types enclosed in
[<>] brackets representing an instance of a module.
@p()
A qualified name is a :: separated list of instantiated names.
@p()
Finally, a suffixed name consists of a qualified name
possible followed by a : and a type expression, this
notation is used to disambiguate overloaded functions.
Note that the type expression is the domain type,
not the whole function type.

@select(h)
simple_name:
  | NAME { lift (fst $1), snd $1 }
  | VBAR NAME 
    { 
      rsrange (lift $1) (lift (fst $2)), 
      snd $2 
    }

relative_name:
  | simple_name COLONCOLON relative_name
    { 
      rsrange (fst $1) (fst $3),
      snd $1 :: snd $3
    }
  | simple_name { fst $1, [snd $1] }

qualified_name:
  | ROOT COLONCOLON relative_name
    { 
      rsrange (lift $1) (fst $3),
      [""] @ snd $3
    }
  | relative_name { $1 }

suffixed_name:
  | qualified_name OF LPAR type_expr RPAR 
    { 
      fst $1,
      (snd $1, $4)
    }
  | qualified_name 
    { 
      fst $1, 
      (snd $1, TYP_none) 
    }

@head(2,'Expressions')
@select(h)
expr: 
  | rvalue { $1 }

rvalue:
  | lambda { $1 }

lambda:
  | tuple { $1 }
  | FUNCTION LPAR parameter_comma_list RPAR COLON type_expr compound
    {
      AST_lambda 
      (
        rsrange (lift $1) (fst $7),
        ($3, $6, snd $7)
      )
    }
  | LAZY LPAR expr RPAR 
    {
      AST_lazy
      (
        rstoken $1 $4,
        $3
      )
    }
  | PROCEDURE LPAR parameter_comma_list RPAR compound
    {
      AST_lambda 
      (
        rsrange (lift $1) (fst $5),
        ($3, TYP_void, snd $5)
      )
    }

  | PROCEDURE compound
    {
      AST_lambda 
      (
        rsrange (lift $1) (fst $2),
        ([], TYP_void, snd $2)
      )
    }

tuple:
  | or_condition tuple_suffix           
    { 
      let lst = $1 :: $2 in
      AST_tuple ( rslist lst, lst) 
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

or_condition:
  | or_condition OR and_condition       { apl2 $2 "lor" [$1; $3] }
  | and_condition                       { $1 }

and_condition:
  | and_condition AND not_condition     { apl2 $2 "land" [$1; $3] }
  | not_condition                       { $1 }

not_condition:
  | NOT not_condition                   { apl $1 "lnot" $2 }
  | comparison                          { $1 }

chain_cmp_op:
  | ANDEQEQUAL                         { "eq",$1}
  | ANDNOTEQUAL                        { "ne",$1} 
  | ANDLESS                            { "lt",$1}
  | ANDGREATER                         { "gt",$1} 
  | ANDLESSEQUAL                       { "le",$1}
  | ANDGREATEREQUAL                    { "ge",$1}

cmp_item:
  | chain_cmp_op sum                   { $1,$2 }

cmp_item_list:
  | cmp_item cmp_item_list             { $1 :: $2 }
  | cmp_item                           { [$1] }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }

/* NOTE: this routine has a FAULT: the variables
  _t0 .. _tn, _r0 .. _rn in the generated lambda
  WILL hide similar variables in the expressions.
  Normally, this can't happen because these are not
  legal user names. We should use a unique index,
  but the parser is currently stateless.
*/
  
comparison:
  | sum cmp_op sum cmp_item_list
    {
      let dummy_sr = ("",0,0,0,0) in
      let unit_tuple = AST_tuple (dummy_sr,[]) in
      let bool_t = TYP_name ["";"bool"] in
      let sr = rsrange (src_of_expr $1) (src_of_expr (snd (list_last $4))) in
      let si i = string_of_int i in
      let nm s = AST_name (dummy_sr,([s],TYP_none)) in
      let rec p n lst = 
        match lst with
        | [] -> [] 
        | ((op,opsrc),ex) :: t ->
           AST_val_decl(lift opsrc,"_t"^si (n+1), None, Some ex)
           ::
           AST_val_decl
           (
             lift opsrc,
             "_r"^si (n+1),
             None,
             Some 
             (
               apl2 opsrc "land" 
               [
                 nm ("_r"^si n);
                 apl2 opsrc op 
                 [
                   nm ("_t"^si n);
                   nm ("_t"^si (n+1))
                 ]
               ]
             )
           )
           :: 
           p (n+1) t
      in 
      let stmts = 
        let n = List.length $4 in
        AST_val_decl (src_of_expr $3,"_t0",None,Some $3) ::
        AST_val_decl 
        (
          rsrange (src_of_expr $1) (src_of_expr $3),
          "_r0",
          None,
          Some (apl2 (snd $2) (fst $2) [$1; nm "_t0"])
        ) 
        ::
        p 0 $4
        @
        [AST_return (sr,AST_name(sr,(["_r"^si n],TYP_none)))]
      in
      AST_apply
      (
        sr,
        (
          AST_lambda (sr,([],bool_t, stmts)),
          unit_tuple
        )
      )
    }
  | sum cmp_op sum                      { apl2 (snd $2) (fst $2) [$1; $3] }
  | sum                                 { $1 }

/* addition is left associative */
sum:
  | sum PLUS term                       { apl2 $2 "add" [$1; $3] }
  | sum MINUS term                      { apl2 $2 "sub" [$1; $3] }
  | term                                { $1 }

/* multiply is left associative */
term:
  | term STAR power                     { apl2 $2 "mul" [$1; $3] }
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed                            { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | refr STARSTAR prefixed               { apl2 $2 "pow" [$1; $3] }
  | refr { $1 }

refr:
  | AMPER refr
    { 
      AST_ref 
      (
        rsrange (lift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | STAR refr
    { 
      AST_deref 
      (
        rsrange (lift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | application                         { $1 }

/* applications is left associative */
application:
  | application factor                  
    { 
      AST_apply (rsexpr $1 $2, ($1, $2)) 
    }
  | factor                              { $1 }

factor:
  | factor LSQB expr RSQB               { apl2 $2 "subscript" [$1; $3] }
  | factor LSQB expr COLON expr RSQB    { apl2 $2 "substring" [$1; $3; $5] }
  | factor LSQB COLON RSQB              { apl2 $2 "copystring" [$1] }
  | factor LSQB expr COLON RSQB         { apl2 $2 "copyfrom" [$1; $3] }
  | factor LSQB COLON expr RSQB         { apl2 $2 "copyto" [$1; $4] } 
  | factor DOT NAME                     { AST_dot (lift $2, ($1, snd $3)) }
  | factor DOT LPAR INTEGER RPAR
    { 
      match $4 with
      | (sr,t,v) ->
        let n = 
          try Big_int.int_of_big_int v 
          with _ -> 
            failwith 
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^ 
              short_string_of_src (lift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (lift $5) in
          AST_get_n (sr, (n,$1)) 
    }
  | atom { $1 }


atom:
  | compound            
    {
      let sr, stmts = $1 in
      AST_lambda 
      (
        sr,
        ([], TYP_void, stmts)
      )
    
    }
  | LPAR expr RPAR      { $2 }
  | LPAR RPAR           { AST_tuple (rstoken $1 $2,[]) }
  | suffixed_name       { AST_name (fst $1,snd $1) }
  | literal             { $1 }

literal:
  | INTEGER 
    { let sr,t,v = $1 in
      AST_literal (lift sr, AST_int (t,v)) 
    }
  | FLOAT   
    { 
      let sr,t,v = $1 in
      AST_literal (lift sr, AST_float (t,v)) 
    }
  | STRING  
    { 
      let sr,s = $1 in
      AST_literal (lift sr, AST_string s) 
    }


%%
(* trailer *)

@head(1,'Parser object')
@h = tangler('src/flx_parse_ctrl.ml')
@select(h)

open Flx_types
open Flx_exceptions
open Flx_parse

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try 
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError "Parsing File")
        end
      | _ -> 
        begin
          toker#report_syntax_error;
          raise (Flx_exceptions.ParseError "Parsing File")
        end
      in parse_tree
    end

let parse_string (data : string) (filename : string) = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename 
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/flx_parse_ctrl.mli')
@select(h)
val parse_file : 
  string -> 
  string ->
  string list ->
  Flx_types.compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  Flx_types.compilation_unit_t
  
@head(1,'Parser test harness')
@h = tangler('src/flxp.ml')
@select(h)
let filename = Sys.argv.(1) ^ ".flx";;
print_endline ("Parsing " ^ filename);;
let parse_tree = Flx_parse_ctrl.parse_file filename "" [];;
print_endline (Flx_print.string_of_compilation_unit parse_tree);;
print_endline "PARSE OK";;
flush stdout


