@head(1,'Parser')
@h = tangler('src/flx_parse.mly')
@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
%{
exception EndOfInput
open Flx_ast
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset

let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) = 
  let sr = rslist tup in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri,fn,[]), 
      `AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t = 
  let sr = src_of_expr arg in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri, fn,[]),
      arg
    )
  )

(* model binary operator as procedure call *)
let assign (op:string) (sr:range_srcref) (sri:srcref) l r = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op,[]),
    `AST_tuple 
    (
      sr, 
      [ `AST_ref (src_of_expr l,l); r]
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op,[]),
    `AST_ref (src_of_expr l,l)
  )

let mkcurry sr name vs args return_type body =
  let mkfuntyp d c = `TYP_function (d,c)
  and typeoflist lst = match lst with
    | [x] -> x
    | _ -> `TYP_tuple lst
  in 
  let mkret arg ret = mkfuntyp (typeoflist (List.map snd arg)) ret in
  let arity = List.length args in
  let rettype args = 
    match return_type with
    | `TYP_none -> `TYP_none
    | _ -> List.fold_right mkret args return_type 
  in

  let rec aux args vs =  
    let n = List.length args in
    let name n = 
      if n = arity
      then name (* top level *)
      else "_curry_" ^ string_of_int n
    in
    match args with 
    | [] -> assert false
    | h :: [] -> (* bottom level *)
        `AST_function (sr, name n, vs, h, return_type, body)
    | h :: t ->
      let m = List.length args in
      let body = 
        [
          aux t [];
          `AST_fun_return 
          (
            sr,
            `AST_suffix
            (
              sr,
              (
                `AST_name (sr,name (m-1),[]),
                typeoflist (List.map snd (List.hd t))
              )
            )
          )
        ] 
      in
        `AST_function (sr, name m, vs, h, rettype t, body)
   in aux args vs

(* handle curried type functions *)
let mktypefun sr name vs args return_type body =
  let argtyp t = match t with
    | [] -> failwith "Lambda abstraction requires nonunit parameter"
    | [x] -> x
    | x -> `TYP_type_tuple x
  in
  let body = 
    let p = ref (List.rev args) in
    let r = ref return_type in
    let b = ref body in
    while !p <> [] do
      let arg = List.hd !p in
      p := List.tl !p;
      b := `TYP_typefun (arg, !r, !b);
      r := `TYP_function(argtyp (List.map snd arg),!r)
    done;
    !b
  in
  `AST_type_alias
  (
    sr,
    name,
    vs,
    body
  )

%}

@head(2,'Tokens')
@select(h)
/* special */
%token<Flx_ast.srcref * string> ERRORTOKEN

/* whitespace */
%token NEWLINE 
%token<string> COMMENT 
%token<string> COMMENT_NEWLINE
%token<int> WHITE 


/* constants */
%token ENDMARKER

/* literals */
%token<Flx_ast.srcref * string> NAME
%token<Flx_ast.srcref * string * Big_int.big_int> INTEGER
%token<Flx_ast.srcref * string * string > FLOAT
%token<Flx_ast.srcref * string> STRING
%token<Flx_ast.srcref * string> WSTRING
%token<Flx_ast.srcref * string> USTRING
%token<Flx_ast.srcref> INF
%token<Flx_ast.srcref> NAN 

/* operators and punctuation */

/* assignment */
%token<Flx_ast.srcref> EQUAL

/* math */
%token<Flx_ast.srcref> PLUS MINUS STAR SLASH PERCENT STARSTAR 

/* comparison */

/* logic */
%token<Flx_ast.srcref> AMPER VBAR PERCENT
%token<Flx_ast.srcref> EXCLAMATION

/* brackets */
%token<Flx_ast.srcref> LPAR RPAR 
%token<Flx_ast.srcref> LSQB RSQB 
%token<Flx_ast.srcref> LBRACE RBRACE  
%token<Flx_ast.srcref> LSQANGLE RSQANGLE

/* terminal */
%token<Flx_ast.srcref> COLON COMMA SEMI DOT BACKQUOTE

/* comparison */
%token<Flx_ast.srcref> LESS GREATER EQEQUAL NOTEQUAL LESSEQUAL GREATEREQUAL 
%token<Flx_ast.srcref> ANDLESS ANDGREATER ANDEQEQUAL ANDNOTEQUAL ANDLESSEQUAL ANDGREATEREQUAL 

/* bitwise */
%token<Flx_ast.srcref> TILDE CIRCUMFLEX LEFTSHIFT RIGHTSHIFT DOUBLESTAR

/* read-modify-write */
%token<Flx_ast.srcref> PLUSPLUS MINUSMINUS PLUSEQUAL MINUSEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL
%token<Flx_ast.srcref> CARETEQUAL VBAREQUAL AMPEREQUAL TILDEEQUAL COLONEQUAL
%token<Flx_ast.srcref> LEFTSHIFTEQUAL RIGHTSHIFTEQUAL LEFTARROW RIGHTARROW COLONGREATER LESSCOLON
%token<Flx_ast.srcref> LEFTRIGHTARROW 

/* other */
%token<Flx_ast.srcref> COLONCOLON
%token<Flx_ast.srcref> DOTDOT SLOSH DOTDOTDOT

/* operator keywords */
%token<Flx_ast.srcref> NOT OR AND DOLLAR

/* patterns */
%token<Flx_ast.srcref> AS UNDERSCORE REGEXP WHEN ALL

/* statement keywords */
%token<Flx_ast.srcref> IF THEN ELSE ENDIF ELIF 
%token<Flx_ast.srcref> OF VAR UNION CLASS GOTO EXPORT

%token<Flx_ast.srcref> MATCH WITH ENDMATCH CASE REGMATCH REGLEX
%token<Flx_ast.srcref> HEADER BODY MODULE CODE LET IN
%token<Flx_ast.srcref> CALL PROCEDURE FUNCTION FUNCTOR JUMP LOOP
%token<Flx_ast.srcref> RETURN FORK 
%token<Flx_ast.srcref> TO OPEN EQRIGHTARROW USE INCLUDE
%token<Flx_ast.srcref> TODO INTERFACE DEFINE
%token<Flx_ast.srcref> TYPE READ CONST STRUCT 
%token<Flx_ast.srcref> VAL TYPEDEF
%token<Flx_ast.srcref> QUEST
%token<Flx_ast.srcref> MACRO IDENT NEW FORGET

%type <Flx_ast.compilation_unit_t> compilation_unit
%type <Flx_ast.range_srcref * Flx_ast.statement_t list> compound
%type <Flx_ast.statement_t> statement 
%type <Flx_ast.expr_t> expr
%type <Flx_ast.expr_t> rvalue

%type <Flx_ast.pattern_t> pattern

%start compilation_unit
%%
/* empty: { [] } */

@head(2,'Compilation Unit')
@select(h)
compilation_unit:  
  | statement_aster ENDMARKER { $1 }

@aster("statement")
@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
statement:
  | binding_definition { $1 }
  | declarative { $1 }
  | executable { $1 }
  | inclusion { $1 }

binding_definition:
  | abstract_type { $1 }
  | const_def { $1 }
  | binding_header { $1 }
  | export_statement { $1 }

declarative:
  | type_alias { $1 }
  | function_definition { $1 }
  | procedure_definition { $1 }
  | module_definition { $1 }
  | union_decl { $1 }
  | struct_decl { $1 }
  | interface_decl { $1 }
  | open_decl { $1 }
  | use_decl { $1 }
  | regdef { $1 }
  | macro_definition { $1 }

executable:
  | var_def { $1 }
  | val_def { $1 }
  | call { $1 }
  | read { $1 }
  | return { $1 }
  | ifgoto_stmt { $1 }
  | todo { $1 }
  | assignment { $1 } 
  | inline_cpp { $1 } 
  | goto_statement { $1 }
  | label_statement { $1 }

inclusion:
  | INCLUDE STRING SEMI
    { 
      let sr = rstoken $1 $3 in 
      `AST_include (sr, snd $2) 
    }
  
@head(2,"Regular definitions")
@select(h)

regdef:
  | REGEXP NAME EQUAL re1 SEMI      
    { 
      let name = snd $2 in 
      `AST_regdef (rstoken $1 $5,name,$4) 
    }
  
re1:
  | re1 VBAR re2             { REGEXP_alt ($1, $3) }
  | re2                      { $1 }

re2:
  | re2 re3                  { REGEXP_seq ($1, $2) }
  | re3                      { $1 }

re3:
  | re4 STAR                { REGEXP_aster $1 }
  | re4 PLUS                 { REGEXP_seq ($1,REGEXP_aster $1) }
  | re4 QUEST                { REGEXP_alt (REGEXP_epsilon, $1) }
  | re4                      { $1 }

re4:
  | STRING                  { let s = snd $1 in REGEXP_string s }
  | UNDERSCORE              { regexp_underscore }
  | DOT                     { regexp_dot }
  | LPAR re1 RPAR           { $2 }
  | LSQB charset RSQB       { regexp_of_charset $2 }
  | LSQB CIRCUMFLEX charset RSQB { regexp_of_charset (charset_inv $3) }
  | re_name                 { REGEXP_name $1 } 

re_name:
  | re_name COLONCOLON NAME 
    { 
      let e = ($1 :> expr_t) in
      let sr = rsrange (src_of_expr e) (slift (fst $3)) in
      `AST_lookup (sr, (e, snd $3,[]))
    }
  | NAME { `AST_name (slift (fst $1), snd $1,[]) }

charset0:
  | STRING MINUS STRING      { charset_of_range (snd $1) (snd $3) }
  | STRING                  { charset_of_string (snd $1) }
charset:
  | charset charset0        { charset_union $1 $2 }
  | charset0                { $1 }
 
@head(3,'Abstract Type')
@select(h)
tvarlist:
   | LSQB basic_name_comma_list RSQB { $2 }
   | { [] } 

abstract_type:
  | TYPE NAME tvarlist EQUAL STRING SEMI 
    { 
      `AST_abs_decl (rstoken $1 $6, snd $2, List.map snd $3, snd $5) 
    }

  | TYPE NAME tvarlist SEMI 
    { 
      `AST_type (rstoken $1 $4, snd $2, List.map snd $3) 
    }

@head(3,'Union Binding')
@select(h)
union_decl:
  | UNION NAME tvarlist EQUAL type_sum_items SEMI 
    { 
      `AST_union (rstoken $1 $6, snd $2, List.map snd $3, $5) 
    }
  | UNION NAME tvarlist EQUAL VBAR type_sum_items SEMI 
    { 
      `AST_union (rstoken $1 $7, snd $2, List.map snd $3, $6) 
    }
type_sum_items:
  | type_sum_items VBAR type_sum_item { $1 @ [$3] }
  | type_sum_item { [$1] }
type_sum_item:
  | NAME OF type_expr { (snd $1,typecode_of_expr $3) }
  | NAME 
    { 
      let sr = slift (fst $1) in
      snd $1, typecode_of_expr (`AST_void sr)
    }

@head(3,'Struct Binding')
@select(h)
struct_decl:
  | STRUCT NAME tvarlist EQUAL LBRACE struct_component_aster RBRACE 
  { 
    `AST_struct (rstoken $1 $7, snd $2, List.map snd $3, $6) 
  }
  | STRUCT NAME tvarlist LBRACE struct_component_aster RBRACE 
  { 
    `AST_struct (rstoken $1 $6, snd $2, List.map snd $3, $5) 
  }

@aster("struct_component")
struct_component:
  | NAME COLON type_expr SEMI { (snd $1,typecode_of_expr $3) }


@head(3,'Abstract Constant Binding')
@select(h)
const_def:
  | CONST NAME tvarlist COLON type_expr EQUAL STRING SEMI 
  { 
    `AST_const_decl 
    (
      rstoken $1 $8, 
      snd $2, 
      List.map snd $3,
      typecode_of_expr $5, 
      snd $7
    ) 
  }


@head(3,'Binding Header Definition')
@select(h)
binding_header:
  | HEADER STRING SEMI { `AST_header (rstoken $1 $3, snd $2) }
  | BODY STRING SEMI { `AST_body (rstoken $1 $3, snd $2) }

@head(3,'Inline C++ Code Definition')
@select(h)
inline_cpp:
  | CODE STRING SEMI { `AST_code (rstoken $1 $3, snd $2) }

@head(3,'Type Alias')
@select(h)
type_alias:
  | TYPEDEF NAME tvarlist EQUAL type_expr SEMI 
    { 
      let sr = rstoken $1 $6
      and name = snd $2 
      and return_type = `TYP_type
      and body = typecode_of_expr $5
      and vs = List.map snd $3 
      in
      `AST_type_alias (sr,name,vs,body)
    }

  | TYPEDEF FUNCTION NAME tvarlist fun_args COLON type_expr EQUAL type_expr SEMI
    {
      let sr = rstoken $1 $10
      and name = snd $3 
      and return_type = typecode_of_expr $7
      and body = typecode_of_expr $9
      and args = List.map snd $5 (* elide srcref *)
      and vs = List.map snd $4 
      in 
      mktypefun sr name vs args return_type body
    }


@head(3,'Export')
@select(h)
export_statement:
  | EXPORT suffixed_name AS STRING SEMI 
    { 
      `AST_export (rstoken $1 $5, $2, snd $4) 
    }
 
@head(3,'Open')
@select(h)
open_decl:
  | OPEN qualified_name SEMI
  {
    `AST_open (rstoken $1 $3,qualified_name_of_expr $2)
  }

use_decl:
  | USE qualified_name SEMI
    {
      let sr = rstoken $1 $3 in
      match $2 with
      | (`AST_lookup (_,(e,n,[])) as qn) -> `AST_use (sr,n,qualified_name_of_expr qn)
      | (`AST_name (_,n,_) as qn) -> `AST_use (sr,n,qualified_name_of_expr qn)
      | _ -> failwith "Use declaration requires qualified name"
    }
    
  | USE NAME EQUAL qualified_name SEMI
    {
      let sr = rstoken $1 $5 in
      `AST_use (sr, snd $2, qualified_name_of_expr $4)
    }
  
@head(3,'Macro Definition')
@select(h)
mac_arg:
  | NAME COLON FUNCTION    { snd $1, Expr }
  | NAME COLON PROCEDURE   { snd $1, Stmt }
  | NAME COLON IDENT       { snd $1, Ident}
  | NAME                   { snd $1, Expr }

mac_args:
  | mac_arg COMMA mac_args { $1 :: $3 }
  | mac_arg                { [$1] }

mac_arg_list:
  | LPAR mac_args RPAR     { $2 }
  | LPAR RPAR              { [] }

macro_definition:
  | MACRO IDENT NAME EQUAL NAME SEMI
    {
      let 
        sr = rstoken $1 $6 and
        lname = snd $3 and
        rname = snd $5
      in
        `AST_name_macro (sr,lname,rname)
    }

  | MACRO IDENT NAME EQUAL NEW SEMI
    {
      let 
        sr = rstoken $1 $6 and
        lname = snd $3
      in
        `AST_name_macro (sr,lname,"")
    }

  | MACRO VAR NAME EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $6 and
        name = snd $3 and
        e = $5
      in
        `AST_macro_var (sr,name,e)
    }

  | MACRO NAME EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $5 and
        name = snd $2 and
        e = $4
      in
        `AST_macro_assign (sr,name,e)
    }


  | MACRO VAL NAME EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $6 and
        name = snd $3 and
        e = $5
      in
        `AST_macro_val (sr,name,e)
    }


  | MACRO FUNCTION NAME mac_arg_list EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $7 and
        name = snd $3 and
        args = $4 and
        e = $6
      in
      `AST_expr_macro (sr,name,args,e)
    }

  | MACRO PROCEDURE NAME mac_arg_list compound 
    {
      let 
        sr = rsrange (slift $1) (fst $5) and 
        name = snd $3 and
        args = $4 and
        sts = snd $5
      in
      `AST_stmt_macro (sr,name,args,sts)
    }
    
  | MACRO FORGET macro_names SEMI
    {
      let sr = rstoken $1 $4 in
      `AST_macro_forget (sr,$3)
    }

  | MACRO GOTO NAME SEMI
    { 
      `AST_macro_goto (rstoken $1 $4, snd $3) 
    }

  | MACRO NAME COLONGREATER 
    { 
      `AST_macro_label (rstoken $1 $3, snd $2) 
    }

  | MACRO IF expr GOTO NAME SEMI
    { `AST_macro_ifgoto (rstoken $1 $6,$3,snd $5) }

 
macro_name_list:
  | macro_name_list NAME { snd $2 :: $1 }
  | NAME { [snd $1] }
macro_names:
  | macro_name_list { List.rev $1 }
  | { [] }
  
@head(3,'Function and Procedure Definition')
@select(h)
fun_arg:
  | LPAR parameter_comma_list RPAR { rstoken $1 $3,$2 }

fun_args:
  | fun_arg fun_args      { $1 :: $2 }
  | fun_arg               { [$1] }

opt_type_expr:
  | COLON type_expr { typecode_of_expr $2 }
  | { `TYP_none }

function_definition:
  | FUNCTION NAME tvarlist fun_args opt_type_expr EQUAL compound 
    { 
      let sr = rsrange (slift $1) (fst $7)
      and name = snd $2 
      and return_type = $5
      and body = snd $7
      and args = List.map snd $4 (* elide srcref *)
      and vs = List.map snd $3
      in mkcurry sr name vs args return_type body
    }

  | FUNCTION NAME tvarlist COLON type_expr EQUAL STRING SEMI 
    { 
      let name = snd $2 
      and vs = List.map snd $3
      and t = typecode_of_expr $5 
      and ct = snd $7 
      and sr = rstoken $1 $8
      in
      match t with
      | `TYP_function (arg, ret) ->
        let args = 
          match arg with
          | `TYP_tuple lst -> lst
          | x -> [x]
        in
        `AST_fun_decl (sr, name, vs, args,  ret,  ct) 
      | _ -> 
        failwith 
        (
          "Function '"^name^"' requires function type, got " ^
          string_of_typecode t ^ " in " ^
          short_string_of_src sr
        )
    }
  | FUNCTION NAME tvarlist COLON type_expr SEMI
    {
      `AST_function_decl 
      (
        rstoken $1 $6, 
        snd $2, 
        List.map snd $3, 
        typecode_of_expr $5
      ) 
    }

procedure_definition:
  | PROCEDURE NAME tvarlist compound 
    { 
      let 
        vs = List.map snd $3 and
        sr =rsrange (slift $1) (fst $4) and
        name = snd $2 and
        body = snd $4 and
        args = [] 
      in
      `AST_function (sr, name, vs, args, `AST_void sr,body) 
    }

  | PROCEDURE NAME tvarlist COLON type_expr SEMI
    {
      let sr = rstoken $1 $6 in
      `AST_function_decl 
      (
        sr,
        snd $2, 
        List.map snd $3,
        `TYP_function 
        (
          typecode_of_expr $5,
          `AST_void sr
        )
      )
    }

  | PROCEDURE NAME tvarlist fun_args compound 
    { 
      let sr = rsrange (slift $1) (fst $5) in
      let name = snd $2 
      and vs = List.map snd $3
      and return_type = `AST_void sr
      and body = snd $5
      and args = List.map snd $4 (* elide srcref *)
      in mkcurry sr name vs args return_type body
    }

  | PROCEDURE NAME tvarlist COLON type_expr EQUAL STRING SEMI 
    { 
      let sr = rstoken $1 $8 
      and vs = List.map snd $3
      and name = snd $2 
      and t = typecode_of_expr $5
      and ct = snd $7
      in
      let ts = 
        match t with
        | `TYP_tuple lst -> lst
        | x -> [x]
      in
      `AST_fun_decl (sr,name,vs, ts,`AST_void sr, ct) 
    }


@commalistof("parameter")
parameter:
  | NAME COLON type_expr { snd $1,typecode_of_expr $3 }
 
@doc()
Flx functions and procedures are first class citizens: the may both be passed
as arguments to procedures, and they may both be be returned from functions.
Only functions may be passed to functions.

@head(3,'Goto and Label')
The goto and label statements are ONLY for testing!
Note labels are declared like
@begin_displayed_code()
label:>
@end_displayed_code()
to avoid ambiguity with 'x:int'.
@select(h)
goto_statement:
  | GOTO NAME SEMI 
    { 
      `AST_goto (rstoken $1 $3, snd $2) 
    }
label_statement:
  | NAME COLONGREATER 
    { 
      `AST_label (rstoken (fst $1) $2, snd $1) 
    }

@head(3,'Read Statement')
@select(h)
read:         
  | READ NAME SEMI            
    { 
      `AST_read (rstoken $1 $3, snd $2) 
    }
@doc()
The read statement is responsible for specifying the variable to contain
the next message, and exchanging control with the dispatcher on entry,
to wait for the message, and resuming control when the message is
placed in the variable by the dispatcher.

@head(3,'Module Definition')
@select(h)
module_definition:
  | MODULE NAME tvarlist compound 
    { 
      `AST_untyped_module 
      (
        rsrange (slift $1) (fst $4), 
        snd $2, 
        List.map snd $3,
        snd $4
      ) 
    }

  | MODULE NAME tvarlist COLON type_expr EQUAL compound 
    { 
      `AST_typed_module 
      (
        rsrange (slift $1) (fst $7), 
        snd $2, 
        List.map snd $3,
        typecode_of_expr $5,
        snd $7
      ) 
    }

  | FUNCTOR NAME tvarlist fun_args compound
    {
      let sr = rsrange (slift $1) (fst $5)
      and name = snd $2 
      and vs = List.map snd $3
      and body = snd $5
      and args = List.map snd $4 (* elide srcref *)
      in `AST_untyped_functor (sr, name, vs, List.hd args, body)
    }

  | FUNCTOR NAME tvarlist fun_args COLON type_expr EQUAL compound
    {
      let sr = rsrange (slift $1) (fst $8)
      and name = snd $2 
      and vs = List.map snd $3
      and return_type = typecode_of_expr $6
      and body = snd $8
      and args = List.map snd $4 (* elide srcref *)
      in `AST_typed_functor (sr, name, vs, List.hd args, return_type, body)
    }

  | MODULE NAME tvarlist EQUAL expr SEMI
    {
      `AST_module_binding 
      (
        rstoken $1 $6, 
        snd $2, 
        List.map snd $3,
        $5 
      )
    }
 
interface_decl:
  | INTERFACE NAME tvarlist compound
    {
      `AST_interface
      (
        rsrange (slift $1) (fst $4),
        snd $2,
        List.map snd $3,
        snd $4
      )
    }

  | INTERFACE NAME tvarlist EQUAL compound 
    {
      `AST_interface
      (
        rsrange (slift $1) (fst $5),
        snd $2,
        List.map snd $3,
        snd $5
      )
    }

@head(3,'Variable and Constant Declaration')
@select(h)
var_def:  
  | VAR NAME tvarlist EQUAL expr SEMI  
    { 
      `AST_var_decl 
      (
        rstoken $1 $6, 
        snd $2, 
        List.map snd $3, None, Some $5
      ) 
    }
  | VAR NAME tvarlist COLON type_expr EQUAL expr SEMI  
    { 
      `AST_var_decl 
      (
        rstoken $1 $8, 
        snd $2, 
        List.map snd $3,
        Some (typecode_of_expr $5), 
        Some $7
      ) 
    }
  | VAR NAME tvarlist COLON type_expr SEMI  
    { 
      `AST_var_decl 
      (
        rstoken $1 $6, 
        snd $2, 
        List.map snd $3,
        Some (typecode_of_expr $5), 
        None
      ) 
    }

val_def:  
  | VAL NAME tvarlist EQUAL expr SEMI  
    { 
      `AST_val_decl 
      (
        rstoken $1 $6, 
        snd $2, 
        List.map snd $3,
        None, 
        Some $5
      ) 
    }

  | VAL NAME tvarlist COLON type_expr EQUAL expr SEMI  
    { 
      `AST_val_decl 
      (
        rstoken $1 $8, 
        snd $2, 
        List.map snd $3,
        Some (typecode_of_expr $5), 
        Some $7
      ) 
    }
  | VAL NAME tvarlist COLON type_expr SEMI  
    { 
      `AST_val_decl 
      (
        rstoken $1 $6, 
        snd $2, 
        List.map snd $3,
        Some (typecode_of_expr $5), 
        None
      ) 
    }
@doc()
Variables can be declared in both procedures and functions.

@head(3,'Function or Procedure Return')
@select(h)
return:       
  | RETURN expr SEMI          { `AST_fun_return (rstoken $1 $3, $2) }
  | RETURN SEMI               { `AST_proc_return (rstoken $1 $2) }
@doc()
The return statement is only permitted as the last statement
in a function.

@head(3,'Procedure Call')
@select(h)
compound:     
  | LBRACE statement_aster RBRACE  { rstoken $1 $3, $2 }

@doc()
A procedure call looks like a function application,
followed by a semicolon:
@begin_displayed_code()
  p a;
  f1 a1 a2 a3; 
@end_displayed_code()
are valid procedure calls. Note in the second
example, f1 and f1 a1 are functions, whilst
the function call f1 a1 a2 must return a procedure
which accepts a3.
@p()
There is a special case: a single name followed
by a semi-colon is considered a call of the
designated procedure passing the unit argument,
so that the following are equivalent:
@begin_displayed_code()
  print_eol ();
  print_eol;
@end_displayed_code()
Note that there is no ambiguity with passing
procedures as arguments: the name always
represents a procedure closure in an expression
context, never a call.
@p()
Note again that this special case only
applies to names, not general expressions,
but the name doesn't have to be a procedure
constant: it could be a variable name.
@begin_displayed_code()
  val eol = print_eol;
  eol; // means eol()
  sin x; // error: function application
  (sin x); // still an error!
@end_displayed_code()

@select(h)
call:
  | application SEMI 
    {
      let sr = 
        let sr1 = src_of_expr $1 in
        rsrange sr1 (slift $2) 
     in
      match $1 with 
      | `AST_apply (_,(proc, arg)) -> 
        `AST_call (sr, proc, arg)

      (*
      | `AST_lambda(_,([],`AST_void _,stmts)) ->
        `AST_block (sr,stmts)
      *)
      | proc -> 
       let u = `AST_tuple (slift $2, []) in
       `AST_call (sr, proc, u)
    }

  | CALL application SEMI 
    {
      let sr = rstoken $1 $3 in
      match $2 with 
      | `AST_apply (sr,(proc, arg)) -> 
        `AST_call (sr, proc, arg)
      
      (*
      | `AST_lambda(sr,([],`AST_void _,stmts)) ->
        `AST_block (sr,stmts)
      *)

      | proc -> 
        let u = `AST_tuple (slift $3, []) in
       `AST_call (rstoken $1 $3, proc, u)
    }

  | JUMP application SEMI 
    {
      let sr = rstoken $1 $3 in
      match $2 with 
      | `AST_apply (sr,(proc, arg)) -> 
        `AST_jump (sr, proc, arg)
      
      (*
      | `AST_lambda(sr,([],`AST_void _,stmts)) ->
        `AST_block (sr,stmts)
      *)

      | proc -> 
        let u = `AST_tuple (slift $3, []) in
       `AST_call (sr, proc, u)
    }

  | LOOP application SEMI {
    let sr = rstoken $1 $3 in
    let u = `AST_tuple (slift $3, []) in
    match $2 with 
    | `AST_apply (_,(`AST_name (_,name,[]), arg)) -> 
      `AST_loop (sr, name, arg)
    
    | `AST_name (s,name,[]) ->
      `AST_loop (sr, name, u)

    | _ -> failwith "Loop requires unqualified name"
  }

assignop:
  | LEFTARROW       { $1,"set" }
  | EQUAL           { $1,"set" }
  | COLONEQUAL      { $1,"set" }
  | PLUSEQUAL       { $1,"pluseq" }
  | MINUSEQUAL      { $1,"minuseq" }
  | STAREQUAL       { $1,"muleq" }
  | SLASHEQUAL      { $1,"diveq" }
  | PERCENTEQUAL    { $1,"modeq" }
  | LEFTSHIFTEQUAL  { $1,"leftshifteq" }
  | RIGHTSHIFTEQUAL { $1,"rightshifteq" }
  | CARETEQUAL      { $1,"careteq" }
  | VBAREQUAL       { $1,"vbareq" }
  | AMPEREQUAL      { $1,"ampereq" }
  | TILDEEQUAL      { $1,"tildeeq" }
  | LEFTRIGHTARROW  { $1,"swap" }

incrop:
  | PLUSPLUS        { $1,"incr" }
  | MINUSMINUS      { $1, "decr" }

assignment: 
  | expr assignop expr SEMI 
    { 
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $4) in
      assign sname sr srop $1 $3 
    }
  | expr incrop SEMI 
    {
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $3) in
      call1 ("post_" ^ sname) sr srop $1
    }
  | incrop expr SEMI
    {
      let srop,sname = $1 in
      let sr = rsrange (slift srop) (slift $3) in
      call1 ("pre_" ^ sname) sr srop $2
    }


@doc()
Note that a block is an anonymous procedure defintion together with
a call to that procedure with the unit argument.
@p()
The assignment statement 'v <- e;' is syntact sugar for 'set(&v,e);'.

@head(3,'Place Holder')
@select(h)
todo:         
  | TODO STRING SEMI        { `AST_nop (rstoken $1 $3, snd $2) }
  | TODO SEMI               { `AST_nop (rstoken $1 $2, "") }
  | SEMI                    { `AST_nop (rstoken $1 $1,"") }

@doc()
The placed holder is used to denote an incomplete section of code.
A string may be included after the 'todo' keyword to serve as a reminder
of the programmers intentions.


@#@head(3,'If/Then/Elif/Else')
@select(h)
ifgoto_stmt:
  | IF expr GOTO NAME SEMI
    { `AST_ifgoto (rstoken $1 $5,$2,snd $4) }

@head(3,'Regular expression matching')
@select(h)
regmatch_expr:
  | REGMATCH expr WITH regmatch_alternatives ENDMATCH
  {
    `AST_regmatch (rstoken $1 $5,($2,$4))
  }

  | REGLEX expr WITH regmatch_alternatives ENDMATCH
  {
    `AST_reglex (rstoken $1 $5,($2,$4))
  }

regmatch_alternatives:
  | regmatch_alternatives regmatch_alternative { $2 :: $1 }
  | regmatch_alternative { [$1] }

regmatch_alternative:
  | VBAR re1 EQRIGHTARROW expr { $2,$4 }


@head(3,'Pattern Matching')
@select(h)
match_expr:
  | MATCH expr WITH matchings ENDMATCH
  { 
    `AST_match (rstoken $1 $5, ($2, $4))
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | VBAR pattern EQRIGHTARROW expr { $2, $4 }

@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
pattern:
  | as_pattern WHEN expr 
    { 
      `PAT_when 
      (
        rsrange (src_of_pat $1) (src_of_expr $3),
        $1, 
        $3
      ) 
    }
  | as_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME 
    { 
      `PAT_as 
      (
        rsrange (src_of_pat $1) (slift (fst $3)), 
        $1, 
        snd $3
      ) 
    }
  | variant_pattern { $1 }

variant_pattern:
  | tuple_pattern { $1 }
tuple_pattern:
  | atomic_pattern_list 
    { 
      match $1 with 
      | [x] -> x 
      | _ -> `PAT_tuple 
        (
          rsrange (src_of_pat (List.hd $1)) (src_of_pat (list_last $1)),
          $1
        )
    }

atomic_pattern_list:
  | atomic_pattern COMMA atomic_pattern_list { $1 :: $3 }
  | atomic_pattern { [$1] }

atomic_pattern:
  /* constants */
  | STRING { `PAT_string (slift (fst $1), snd $1) }
  | integral 
    { 
      let sr,t,v = $1 in
      `PAT_int (sr,t,v) 
    }
  | NAN { `PAT_nan (slift $1) }
  
  /* ranges */
  | STRING DOTDOT STRING 
    { 
      `PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral 
    { 
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      `PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)  
    }

  | floating DOTDOT floating 
    { 
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      `PAT_float_range 
      (
       rsrange sr1 sr2, 
       v1, v2
      ) 
    }

  /* other */
  | ctor_pattern { $1 }
  | QUEST NAME { `PAT_name (rstoken $1 (fst $2), snd $2) }
  | QUEST { `PAT_any (slift $1) }
  | UNDERSCORE { `PAT_any (slift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR basic_name_comma_list RPAR 
    { 
      let names = List.map snd $4 in
      `PAT_regexp (rstoken $1 $5, snd $2, names) 
    }


ctor_pattern:
  | ctor_name atomic_pattern 
    { 
      `PAT_nonconst_ctor 
      (
        rsrange (src_of_expr $1) (src_of_pat $2), 
        qualified_name_of_expr $1, 
        $2
      ) 
    }
  | ctor_name 
    { 
      `PAT_const_ctor 
      (
        src_of_expr $1, 
        qualified_name_of_expr $1 
      )
    }

ctor_name:
  | NAME { `AST_name (slift (fst $1), snd $1,[]) }
  | CASE INTEGER { 
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }

integral:
  | INTEGER { let sr,t,v = $1 in slift sr, t, v }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in 
      rstoken $1 sr, t, Big_int.minus_big_int v 
    }

floating:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      slift sr, Float_plus (t,v) 
    }
  | MINUS FLOAT 
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v) 
    }
  | INF { slift $1, Float_inf }
  | MINUS INF { slift $1, Float_minus_inf }

basic_name: NAME { $1 }
@commalistof("basic_name")

@head(2,'Executable Expressions')
@select(h)
expr: 
  | LET pattern EQUAL expr IN expr 
    { 
      let sr = rsrange (slift $1) (src_of_expr $6) in
      `AST_letin (sr,($2,$4,$6)) 
    }
  | rvalue { $1 }
  
rvalue:
  | lambda { $1 }

lambda:
  | tuple { $1 }

  | FUNCTION LPAR parameter_comma_list RPAR COLON type_expr EQUAL compound
    {
      `AST_lambda 
      (
        rsrange (slift $1) (fst $8),
        ($3, typecode_of_expr $6, snd $8)
      )
    }

  | FUNCTION LPAR parameter_comma_list RPAR COLON type_expr EQUAL LBRACE expr RBRACE
    {
      let sr = rstoken $1 $10 in
      `AST_lambda 
      (
        sr,
        (
          $3, 
          typecode_of_expr $6, 
          [`AST_fun_return (sr,$9)]
        )
      )
    }

  | PROCEDURE LPAR parameter_comma_list RPAR compound
    {
      let sr = rsrange (slift $1) (fst $5) in
      `AST_lambda 
      (
        sr,
        ($3, `AST_void sr, snd $5)
      )
    }

  | PROCEDURE compound
    {
      let sr = rsrange (slift $1) (fst $2) in
      `AST_lambda 
      (
        sr,
        ([], `AST_void sr, snd $2)
      )
    }

tuple:
  | or_condition tuple_suffix           
    { 
      let lst = $1 :: $2 in
      `AST_tuple ( rslist lst, lst) 
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

or_condition:
  | or_condition OR and_condition       { apl2 $2 "lor" [$1; $3] }
  | and_condition                       { $1 }

and_condition:
  | and_condition AND not_condition     { apl2 $2 "land" [$1; $3] }
  | not_condition                       { $1 }

not_condition:
  | NOT not_condition                   { apl $1 "lnot" $2 }
  | comparison                          { $1 }

chain_cmp_op:
  | ANDEQEQUAL                         { "eq",$1}
  | ANDNOTEQUAL                        { "ne",$1} 
  | ANDLESS                            { "lt",$1}
  | ANDGREATER                         { "gt",$1} 
  | ANDLESSEQUAL                       { "le",$1}
  | ANDGREATEREQUAL                    { "ge",$1}

cmp_item:
  | chain_cmp_op sum                   { $1,$2 }

cmp_item_list:
  | cmp_item cmp_item_list             { $1 :: $2 }
  | cmp_item                           { [$1] }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }

/* NOTE: this routine has a FAULT: the variables
  _t0 .. _tn, _r0 .. _rn in the generated lambda
  WILL hide similar variables in the expressions.
  Normally, this can't happen because these are not
  legal user names. We should use a unique index,
  but the parser is currently stateless.

  THis routine should be moved to desugaring phase.
*/
  
comparison:
  | sum cmp_op sum cmp_item_list
    {
      let dummy_sr:range_srcref = ("",0,0,0,0) in
      let unit_tuple:expr_t = `AST_tuple (dummy_sr,[]) in
      let sr:range_srcref = rsrange (src_of_expr $1) (src_of_expr (snd (list_last $4))) in
      let si i = string_of_int i in
      let nm s = `AST_name (dummy_sr,s,[]) in
      let rec p n lst = 
        match lst with
        | [] -> [] 
        | ((op,opsrc),ex) :: t ->
           `AST_val_decl(slift opsrc,"_t"^si (n+1), [],None, Some ex)
           ::
           `AST_val_decl
           (
             slift opsrc,
             "_r"^si (n+1),
             [],
             None,
             Some 
             (
               apl2 opsrc "land" 
               [
                 nm ("_r"^si n);
                 apl2 opsrc op 
                 [
                   nm ("_t"^si n);
                   nm ("_t"^si (n+1))
                 ]
               ]
             )
           )
           :: 
           p (n+1) t
      in 
      let stmts = 
        let n = List.length $4 in
        `AST_val_decl (src_of_expr $3,"_t0",[],None,Some $3) ::
        `AST_val_decl 
        (
          rsrange (src_of_expr $1) (src_of_expr $3),
          "_r0",[],
          None,
          Some (apl2 (snd $2) (fst $2) [$1; nm "_t0"])
        ) 
        ::
        p 0 $4
        @
        [`AST_fun_return (sr,`AST_name(sr,"_r"^si n,[]))]
      in
      `AST_apply
      (
        sr,
        (
          `AST_lambda (sr,([],flx_bool, stmts)),
          unit_tuple
        )
      )
    }
  | sum cmp_op sum                      { apl2 (snd $2) (fst $2) [$1; $3] }
  | arrow                               { $1 }

/* arrow is right associative */
@commalistof('type_expr')
type_expr:
  | arrow { $1 }

arrow:
  | case_literal RIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_arrow (sr,($1,$3)) 
    }
  | case_literal { $1 }

case_literal:
  | CASE INTEGER 
    {
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    } 
  | CASE INTEGER OF sum
    {
      let _,_,v = $2 in 
      `AST_typed_case 
      (
        rsrange (slift $1) (src_of_expr $4),
        Big_int.int_of_big_int v, 
        typecode_of_expr $4
      )
    } 
  | sum { $1 }

/* sum formation is 'psuedo-associative' */
sum:
  | subtraction PLUS sum_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_sum (sr,$1 :: $3) 
    }
  | subtraction { $1 }

sum_list:
  | subtraction PLUS sum_list              { $1 :: $3 }
  | subtraction { [$1] }

subtraction:
  | subtraction MINUS product { apl2 $2 "sub" [$1; $3] }
  | product { $1 }

/* product formation is 'psuedo-associative' */
product:
  | term STAR product_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_product (sr,$1 :: $3) 
    }
  | term                                { $1 }
product_list:
  | term STAR product_list              { $1 :: $3 }
  | term                                { [$1] }


/* division is left associative: note higher precedence
   the product, so that

   a * b/c * d -> a * (b/c) * d
*/
term:
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed                            { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | refr STARSTAR prefixed               { apl2 $2 "pow" [$1; $3] }
  | refr { $1 }

refr:
  | AMPER refr
    { 
      `AST_ref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | STAR refr
    { 
      `AST_deref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | application                         { $1 }

/* applications is left associative */
application:
  | application coercion
    { 
      `AST_apply (rsexpr $1 $2, ($1, $2)) 
    }
  | coercion { $1 }

coercion:
  | coercion COLON factor          
    { 
      `AST_coercion (slift $2, ($1, typecode_of_expr $3)) 
    }
  | suffixed_name                  { ($1:>expr_t) }
  | factor                         { $1 }


factor:
  | qualified_name                     { ($1:>expr_t) }
  | factor DOT LSQB expr RSQB          { apl2 $3 "subscript" [$1; $4] }
  | factor DOT LSQB expr TO expr RSQB  { apl2 $3 "substring" [$1; $4; $6] }
  | factor DOT LSQB expr TO RSQB       { apl2 $3 "copyfrom" [$1; $4] }
  | factor DOT LSQB TO expr RSQB       { apl2 $3 "copyto" [$1; $5] } 
  | factor DOT NAME                    { `AST_dot (slift $2, ($1, snd $3)) }
  | factor DOT LPAR INTEGER RPAR
    { 
      match $4 with
      | (sr,t,v) ->
        let n = 
          try Big_int.int_of_big_int v 
          with _ -> 
            failwith 
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^ 
              short_string_of_src (slift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (slift $5) in
          `AST_get_n (sr, (n,$1)) 
    }
  | factor AS NAME
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_as (sr,($1,snd $3))
    }

qualified_name:
  | qualified_name COLONCOLON NAME LSQB type_expr_comma_list RSQB              
    { 
      let sr = rsrange (src_of_expr $1) (slift $6) in
      `AST_lookup (sr,($1, snd $3, List.map typecode_of_expr $5))
    }
  | qualified_name COLONCOLON NAME 
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_lookup (sr, ($1, snd $3,[]))
    }
  | dollar_atom { $1 }

elif:
  | ELIF expr THEN expr { $2,$4 }

elifs:
  | elifs elif { $2 :: $1 }
  | elif { [$1] }

else_part:
  | elifs ELSE expr 
    {
      List.fold_left (* actually a right fold cause list is reversed *)
      (fun result (cond,thn) ->
        let sr = rsrange (src_of_expr cond) (src_of_expr result) in
        `AST_cond 
        (
          sr,
          (
            cond,
            thn,
            result
          )
        )
      )
      $3 $1
    }
  | ELSE expr { $2 }

cond:
  | IF expr THEN expr else_part ENDIF
    { 
      `AST_cond (rstoken $1 $6,($2,$4,$5))
    }

dollar_atom:
  | DOLLAR atom 
    { 
      `AST_noexpand (rsrange (slift $1) (src_of_expr $2), $2)
    }
  | atom { $1}
  
atom:
  | LBRACE expr RBRACE     
    { 
      let sr = rstoken $1 $3 in
      `AST_lambda 
      (
        sr,
        (
          [],
          `TYP_none,
          [`AST_fun_return (sr,$2)]
        ) 
      )
    }
  | match_expr { $1 }
  | regmatch_expr { $1 }
  | compound            
    {
      let sr, stmts = $1 in
      `AST_lambda 
      (
        sr,
        ([], `TYP_none, stmts)
      )
    
    }
  | LPAR expr RPAR      { $2 }
  | LPAR RPAR           { `AST_tuple (rstoken $1 $2,[]) }
  | literal             { $1 }
  | simple_name         { ($1:>expr_t) }
  | cond                { $1 }

literal:
  | INTEGER 
    { let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_int (t,v)) 
    }
  | FLOAT   
    { 
      let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_float (t,v)) 
    }
  | STRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_string s) 
    }

simple_name:
  | NAME LSQB type_expr_comma_list RSQB  
    { 
      `AST_name 
      (
        rsrange (slift (fst $1)) (slift $4),
        snd $1,
        List.map typecode_of_expr $3 
      ) 
    }

  | NAME 
    { 
      `AST_name 
      (
        slift (fst $1), 
        snd $1,
        []
      ) 
    }

suffixed_name:
  | qualified_name OF LPAR type_expr RPAR 
    { 
      `AST_suffix
      (
        rsrange (src_of_expr $1) (slift $5),
        (qualified_name_of_expr $1, typecode_of_expr $4)
      )
    }



%%
(* trailer *)

@head(1,'Parser object')
@h = tangler('src/flx_parse_ctrl.ml')
@select(h)

open Flx_ast
open Flx_exceptions
open Flx_parse

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try 
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError "Parsing File")
        end
      | _ -> 
        begin
          toker#report_syntax_error;
          raise (Flx_exceptions.ParseError "Parsing File")
        end
      in parse_tree
    end

let parse_string (data : string) (filename : string) = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename 
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/flx_parse_ctrl.mli')
@select(h)
val parse_file : 
  string -> 
  string ->
  string list ->
  Flx_ast.compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  Flx_ast.compilation_unit_t
  
@head(1,'Parser test harness')
@h = tangler('src/flxp.ml')
@select(h)
let filename = Sys.argv.(1) ^ ".flx";;
print_endline ("Parsing " ^ filename);;
let parse_tree = Flx_parse_ctrl.parse_file filename "" [];;
print_endline (Flx_print.string_of_compilation_unit parse_tree);;
print_endline "PARSE OK";;
flush stdout


