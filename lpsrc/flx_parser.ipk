@head(1,'Parser')
@h = tangler('src/flx_parse.mly')
@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
%{
exception EndOfInput
open Flx_types
open Flx_typing
open Flx_srcref
open Flx_print

let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) = 
  let sr = rslist tup in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri,fn), 
      `AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t = 
  let sr = src_of_expr arg in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri, fn),
      arg
    )
  )

(* model binary operator as procedure call *)
let assign (op:string) (sr:range_srcref) (sri:srcref) l r = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op),
    `AST_tuple 
    (
      sr, 
      [ `AST_ref (src_of_expr l,l); r]
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op),
    `AST_ref (src_of_expr l,l)
  )

let mkcurry sr name args return_type body =
  let mkfuntyp d c = `TYP_function (d,c)
  and typeoflist lst = match lst with
    | [x] -> x
    | _ -> `TYP_tuple lst
  in 
  let mkret arg ret = mkfuntyp (typeoflist (List.map snd arg)) ret in
  let arity = List.length args in
  let rettype args = List.fold_right mkret args return_type in

  let rec aux args =  
    let n = List.length args in
    let name n = 
      if n = arity
      then name (* top level *)
      else "_curry_" ^ string_of_int n
    in
    match args with 
    | [] -> assert false
    | h :: [] -> (* bottom level *)
      (match return_type with
      | `AST_void _ -> 
        `AST_procedure (sr, name n, h, body) 
        (* Note that this '`TYP_void' is supposed to be
           the type of the message: unused at present!
        *)
      | _ -> 
        `AST_function (sr, name n, h, return_type, body)
      )
    | h :: t ->
      let m = List.length args in
      let body = 
        [
          aux t;
          `AST_return 
          (
            sr,
            `AST_suffix
            (
              sr,
              (
                `AST_name (sr,name (m-1)),
                typeoflist (List.map snd (List.hd t))
              )
            )
          )
        ] 
      in
        `AST_function (sr, name m, h, rettype t, body)
   in aux args

%}

@head(2,'Tokens')
@select(h)
/* special */
%token<Flx_types.srcref * string> ERRORTOKEN

/* whitespace */
%token NEWLINE 
%token<string> COMMENT 
%token<string> COMMENT_NEWLINE
%token<int> WHITE 


/* constants */
%token ENDMARKER

/* literals */
%token<Flx_types.srcref * string> NAME
%token<Flx_types.srcref * string * Big_int.big_int> INTEGER
%token<Flx_types.srcref * string * string > FLOAT
%token<Flx_types.srcref * string> STRING
%token<Flx_types.srcref> INF
%token<Flx_types.srcref> NAN 
%token<Flx_types.srcref> ROOT

/* operators and punctuation */

/* assignment */
%token<Flx_types.srcref> EQUAL

/* math */
%token<Flx_types.srcref> PLUS MINUS STAR SLASH PERCENT STARSTAR 

/* comparison */

/* logic */
%token<Flx_types.srcref> AMPER VBAR PERCENT
%token<Flx_types.srcref> EXCLAMATION

/* brackets */
%token<Flx_types.srcref> LPAR RPAR 
%token<Flx_types.srcref> LSQB RSQB 
%token<Flx_types.srcref> LBRACE RBRACE  
%token<Flx_types.srcref> LSQANGLE RSQANGLE

/* terminal */
%token<Flx_types.srcref> COLON COMMA SEMI DOT BACKQUOTE

/* comparison */
%token<Flx_types.srcref> LESS GREATER EQEQUAL NOTEQUAL LESSEQUAL GREATEREQUAL 
%token<Flx_types.srcref> ANDLESS ANDGREATER ANDEQEQUAL ANDNOTEQUAL ANDLESSEQUAL ANDGREATEREQUAL 

/* bitwise */
%token<Flx_types.srcref> TILDE CIRCUMFLEX LEFTSHIFT RIGHTSHIFT DOUBLESTAR

/* read-modify-write */
%token<Flx_types.srcref> PLUSPLUS MINUSMINUS PLUSEQUAL MINUSEQUAL STAREQUAL SLASHEQUAL PERCENTEQUAL
%token<Flx_types.srcref> CARETEQUAL VBAREQUAL AMPEREQUAL TILDEEQUAL COLONEQUAL
%token<Flx_types.srcref> LEFTSHIFTEQUAL RIGHTSHIFTEQUAL LEFTARROW RIGHTARROW COLONGREATER LESSCOLON
%token<Flx_types.srcref> LEFTRIGHTARROW 

/* other */
%token<Flx_types.srcref> COLONCOLON
%token<Flx_types.srcref> DOTDOT SLOSH DOTDOTDOT

/* operator keywords */
%token<Flx_types.srcref> NOT OR AND LAMBDA LAZY

/* patterns */
%token<Flx_types.srcref> AS ANY REGEXP WHEN ALL

/* type operator */
%token<Flx_types.srcref> TYPEOF

/* statement keywords */
%token<Flx_types.srcref> IF THEN ELSE ENDIF ELIF OF VAR UNION CLASS CATEGORY EXCEPTIONS GOTO EXPORT

%token<Flx_types.srcref> MATCH WITH ENDMATCH CASE HEADER BODY MODULE CODE
%token<Flx_types.srcref> SERVICE COMMAND HANDLER CALL PROCEDURE FUNCTION READER FUNCTOR
%token<Flx_types.srcref> UNIT RETURN FORK VOID
%token<Flx_types.srcref> WHILE LOOP TO OPEN EQRIGHTARROW
%token<Flx_types.srcref> TODO INTERFACE DEFINE OVERLOAD
%token<Flx_types.srcref> TYPE FUN READ PROC CONST STRUCT RAISE ATTEMPT FINALLY EXCEPT VAL TYPEDEF ENDATTEMPT
%token<Flx_types.srcref> QUEST


%type <Flx_types.compilation_unit_t> compilation_unit
%type <Flx_types.range_srcref * Flx_types.statement_t list> compound
%type <Flx_types.statement_t> statement 
%type <Flx_types.expr_t> expr
%type <Flx_types.expr_t> rvalue

%type <Flx_types.pattern_t> pattern

%start compilation_unit
%%
/* empty: { [] } */

@head(2,'Compilation Unit')
@select(h)
compilation_unit:  
  | statement_aster ENDMARKER { $1 }

@aster("statement")
@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
statement:
  | binding_definition { $1 }
  | declarative { $1 }
  | executable { $1 }

@doc()
There are three rough categories of statements.

@select(h)
binding_definition:
  | abstract_type { $1 }
  | const_def { $1 }
  | binding_header { $1 }
  | export_statement { $1 }

@doc()
A binding definition is used to bind a entity to the implementation
language.
 
@select(h)
declarative:
  | type_alias { $1 }
  | function_definition { $1 }
  | procedure_definition { $1 }
  | module_definition { $1 }
  | union_decl { $1 }
  | struct_decl { $1 }
  | interface_decl { $1 }
  | open_decl { $1 }

executable:
  | var_def { $1 }
  | val_def { $1 }
  | call { $1 }
  | read { $1 }
  | return { $1 }
  | ifgoto_stmt { $1 }
/*  | if_stmt { $1 } */
/*  | while_stmt { $1 } */
  | todo { $1 }
  | attempt_stmt { $1 }
  | raise_stmt { $1 }
  | assignment { $1 } 
  | inline_cpp { $1 } 
  | goto_statement { $1 }
  | label_statement { $1 }

@head(3,'Abstract Type')
@select(h)
abstract_type:
  | TYPE NAME EQUAL STRING SEMI 
    { 
      `AST_abs_decl (rstoken $1 $5, snd $2, snd $4) 
    }

  | TYPE NAME SEMI 
    { 
      `AST_type (rstoken $1 $3, snd $2) 
    }

@head(3,'Union Binding')
@select(h)
union_decl:
  | UNION NAME EQUAL type_sum_items SEMI 
    { 
      `AST_union (rstoken $1 $5, snd $2, $4) 
    }
  | UNION NAME EQUAL VBAR type_sum_items SEMI 
    { 
      `AST_union (rstoken $1 $6, snd $2, $5) 
    }
type_sum_items:
  | type_sum_items VBAR type_sum_item { $1 @ [$3] }
  | type_sum_item { [$1] }
type_sum_item:
  | NAME OF type_expr { (snd $1,typecode_of_expr $3) }
  | NAME 
    { 
      let sr = slift (fst $1) in
      snd $1, typecode_of_expr (`AST_void sr)
    }

@head(3,'Struct Binding')
@select(h)
struct_decl:
  | STRUCT NAME EQUAL LBRACE struct_component_aster RBRACE 
  { 
    `AST_struct (rstoken $1 $6, snd $2, $5) 
  }
  | STRUCT NAME LBRACE struct_component_aster RBRACE 
  { 
    `AST_struct (rstoken $1 $5, snd $2, $4) 
  }

@aster("struct_component")
struct_component:
  | NAME COLON type_expr SEMI { (snd $1,typecode_of_expr $3) }


@head(3,'Abstract Constant Binding')
@select(h)
const_def:
  | CONST NAME COLON type_expr EQUAL STRING SEMI 
  { 
    `AST_const_decl (rstoken $1 $7, snd $2, typecode_of_expr $4, snd $6) 
  }


@head(3,'Binding Header Definition')
@select(h)
binding_header:
  | HEADER STRING SEMI { `AST_header (rstoken $1 $3, snd $2) }
  | BODY STRING SEMI { `AST_body (rstoken $1 $3, snd $2) }

@head(3,'Inline C++ Code Definition')
@select(h)
inline_cpp:
  | CODE STRING SEMI { `AST_code (rstoken $1 $3, snd $2) }

@head(3,'Type Alias')
@select(h)
type_alias:
  | TYPEDEF NAME EQUAL type_expr SEMI 
    { 
      `AST_type_alias (rstoken $1 $5, snd $2, typecode_of_expr $4) 
    }

@head(3,'Export')
@select(h)
export_statement:
  | EXPORT suffixed_name AS STRING SEMI 
    { 
      `AST_export (rstoken $1 $5, $2, snd $4) 
    }
 
@head(3,'Open')
@select(h)
open_decl:
  | OPEN qualified_name SEMI
  {
    `AST_open (rstoken $1 $3,qualified_name_of_expr $2)
  }
  
@head(3,'Function and Procedure Definition')
@select(h)
fun_arg:
  | LPAR parameter_comma_list RPAR { rstoken $1 $3,$2 }

fun_args:
  | fun_arg fun_args      { $1 :: $2 }
  | fun_arg               { [$1] }

opt_type_expr:
  | COLON type_expr { typecode_of_expr $2 }
  | { `TYP_none }

function_definition:
  | FUNCTION NAME fun_args opt_type_expr EQUAL compound 
    { 
      let sr = rsrange (slift $1) (fst $6)
      and name = snd $2 
      and return_type = $4
      and body = snd $6
      and args = List.map snd $3 (* elide srcref *)
      in mkcurry sr name args return_type body
    }

  | FUNCTION NAME COLON type_expr EQUAL STRING SEMI 
    { 
      let name = snd $2 
      and t = typecode_of_expr $4 
      and ct = snd $6 
      and sr = rstoken $1 $7
      in
      match t with
      | `TYP_function (arg, ret) ->
        let args = 
          match arg with
          | `TYP_tuple lst -> lst
          | x -> [x]
        in
        `AST_fun_decl (sr, name, args,  ret,  ct) 
      | _ -> 
        failwith 
        (
          "Function '"^name^"' requires function type, got " ^
          string_of_typecode t ^ " in " ^
          short_string_of_src sr
        )
    }
  | FUNCTION NAME COLON type_expr SEMI
    {
      `AST_function_decl (rstoken $1 $5, snd $2,  typecode_of_expr $4) 
    }

procedure_definition:
  | PROCEDURE NAME compound 
    { 
      `AST_procedure (rsrange (slift $1) (fst $3), snd $2, [], snd $3) 
    }
  | PROCEDURE NAME COLON type_expr SEMI
    {
      `AST_procedure_decl 
      (
        rstoken $1 $5,
        snd $2, 
        typecode_of_expr $4
      );
    }
  | PROCEDURE NAME fun_args compound 
    { 
      let sr = rsrange (slift $1) (fst $4) in
      let name = snd $2 
      and return_type = `AST_void sr
      and body = snd $4
      and args = List.map snd $3 (* elide srcref *)
      in mkcurry sr name args return_type body
    }
  | PROCEDURE NAME COLON type_expr EQUAL STRING SEMI 
    { 
      let sr = rstoken $1 $7 
      and name = snd $2 
      and t = typecode_of_expr $4
      and ct = snd $6
      in
      let ts = 
        match t with
        | `TYP_tuple lst -> lst
        | x -> [x]
      in
      `AST_proc_decl (sr,name, ts,ct) 
    }


@commalistof("parameter")
parameter:
  | NAME COLON type_expr { snd $1,typecode_of_expr $3 }
 
@doc()
Flx functions and procedures are first class citizens: the may both be passed
as arguments to procedures, and they may both be be returned from functions.
Only functions may be passed to functions.

@head(3,'Goto and Label')
The goto and label statements are ONLY for testing!
Note labels are declared like
@begin_displayed_code()
label:>
@end_displayed_code()
to avoid ambiguity with 'x:int'.
@select(h)
goto_statement:
  | GOTO NAME SEMI 
    { 
      `AST_goto (rstoken $1 $3, snd $2) 
    }
label_statement:
  | NAME COLONGREATER 
    { 
      `AST_label (rstoken (fst $1) $2, snd $1) 
    }

@head(3,'Read Statement')
@select(h)
read:         
  | READ NAME SEMI            
    { 
      `AST_read (rstoken $1 $3, snd $2) 
    }
@doc()
The read statement is responsible for specifying the variable to contain
the next message, and exchanging control with the dispatcher on entry,
to wait for the message, and resuming control when the message is
placed in the variable by the dispatcher.

@head(3,'Module Definition')
@select(h)
module_definition:
  | MODULE NAME compound 
    { 
      `AST_untyped_module 
      (
        rsrange (slift $1) (fst $3), 
        snd $2, 
        snd $3
      ) 
    }

  | MODULE NAME COLON type_expr EQUAL compound 
    { 
      `AST_typed_module 
      (
        rsrange (slift $1) (fst $6), 
        snd $2, 
        typecode_of_expr $4,
        snd $6
      ) 
    }

  | FUNCTOR NAME fun_args compound
    {
      let sr = rsrange (slift $1) (fst $4)
      and name = snd $2 
      and body = snd $4
      and args = List.map snd $3 (* elide srcref *)
      in `AST_untyped_functor (sr, name, List.hd args, body)
    }

  | FUNCTOR NAME fun_args COLON type_expr EQUAL compound
    {
      let sr = rsrange (slift $1) (fst $7)
      and name = snd $2 
      and return_type = typecode_of_expr $5
      and body = snd $7
      and args = List.map snd $3 (* elide srcref *)
      in `AST_typed_functor (sr, name, List.hd args, return_type, body)
    }

  | MODULE NAME EQUAL expr SEMI
    {
      `AST_module_binding 
      (
        rstoken $1 $5, 
        snd $2, 
        $4 
      )
    }
 
interface_decl:
  | INTERFACE NAME compound
    {
      `AST_interface
      (
        rsrange (slift $1) (fst $3),
        snd $2,
        snd $3
      )
    }

  | INTERFACE NAME EQUAL compound 
    {
      `AST_interface
      (
        rsrange (slift $1) (fst $4),
        snd $2,
        snd $4
      )
    }

@head(3,'Variable and Constant Declaration')
@select(h)
var_def:  
  | VAR NAME EQUAL expr SEMI  
    { 
      `AST_var_decl (rstoken $1 $5, snd $2, None, Some $4) 
    }
  | VAR NAME COLON type_expr EQUAL expr SEMI  
    { 
      `AST_var_decl 
      (
        rstoken $1 $7, 
        snd $2, 
        Some (typecode_of_expr $4), 
        Some $6
      ) 
    }
  | VAR NAME COLON type_expr SEMI  
    { 
      `AST_var_decl 
      (
        rstoken $1 $5, 
        snd $2, 
        Some (typecode_of_expr $4), 
        None
      ) 
    }
val_def:  
  | VAL NAME EQUAL expr SEMI  
    { 
      `AST_val_decl 
      (
        rstoken $1 $5, 
        snd $2, 
        None, 
        Some $4
      ) 
    }
  | VAL NAME COLON type_expr EQUAL expr SEMI  
    { 
      `AST_val_decl 
      (
        rstoken $1 $7, 
        snd $2, 
        Some (typecode_of_expr $4), 
        Some $6
      ) 
    }
  | VAL NAME COLON type_expr SEMI  
    { 
      `AST_val_decl 
      (
        rstoken $1 $5, 
        snd $2, 
        Some (typecode_of_expr $4), 
        None
      ) 
    }
@doc()
Variables can be declared in both procedures and functions.

@head(3,'Function or Procedure Return')
@select(h)
return:       
  | RETURN expr SEMI          { `AST_return (rstoken $1 $3, $2) }
@doc()
The return statement is only permitted as the last statement
in a function.

@head(3,'Procedure Call')
@select(h)
compound:     
  | LBRACE statement_aster RBRACE  { rstoken $1 $3, $2 }

@doc()
A procedure call looks like a function application,
followed by a semicolon:
@begin_displayed_code()
  p a;
  f1 a1 a2 a3; 
@end_displayed_code()
are valid procedure calls. Note in the second
example, f1 and f1 a1 are functions, whilst
the function call f1 a1 a2 must return a procedure
which accepts a3.
@p()
There is a special case: a single name followed
by a semi-colon is considered a call of the
designated procedure passing the unit argument,
so that the following are equivalent:
@begin_displayed_code()
  print_eol ();
  print_eol;
@end_displayed_code()
Note that there is no ambiguity with passing
procedures as arguments: the name always
represents a procedure closure in an expression
context, never a call.
@p()
Note again that this special case only
applies to names, not general expressions,
but the name doesn't have to be a procedure
constant: it could be a variable name.
@begin_displayed_code()
  val eol = print_eol;
  eol; // means eol()
  sin x; // error: function application
  (sin x); // still an error!
@end_displayed_code()

@select(h)
call:
  | application SEMI {
    match $1 with 
    | `AST_apply (s,(proc, arg)) -> 
      `AST_call (rsrange s (slift $2), proc, arg)

    | `AST_name (s,name) as proc ->
      `AST_call (rsrange s (slift $2), proc, `AST_tuple (slift $2, []))

    | `AST_lambda(sr,([],`AST_void _,stmts)) ->
      `AST_block (sr,stmts)

    (* ARGGG! A match expression may have the type
       of a procedure, and we need to call it,
       we could check for 'match' here, but
       basically, we just have to give up and
       assume that an expression returns an 
       unit->void and call it, and let the type
       checker detect an error.

       This is a MESS because it is inconsistent ...
    *)
    | proc -> 
     let s = src_of_expr proc in
     `AST_call (rsrange s (slift $2), proc, `AST_tuple (slift $2, []))
    
    (* we used to do this:
    failwith 
    (
      "Procedure call requires application, got " ^
      Flx_print.string_of_expr $1
    )
    *)
  }

  | CALL application SEMI {
    match $2 with 
    | `AST_apply (s,(proc, arg)) -> 
      `AST_call (rsrange s (slift $3), proc, arg)
    | _ -> failwith "Procedure call requires application"
  }

assignop:
  | LEFTARROW       { $1,"set" }
  | EQUAL           { $1,"set" }
  | COLONEQUAL      { $1,"set" }
  | PLUSEQUAL       { $1,"pluseq" }
  | MINUSEQUAL      { $1,"minuseq" }
  | STAREQUAL       { $1,"muleq" }
  | SLASHEQUAL      { $1,"diveq" }
  | PERCENTEQUAL    { $1,"modeq" }
  | LEFTSHIFTEQUAL  { $1,"leftshifteq" }
  | RIGHTSHIFTEQUAL { $1,"rightshifteq" }
  | CARETEQUAL      { $1,"careteq" }
  | VBAREQUAL       { $1,"vbareq" }
  | AMPEREQUAL      { $1,"ampereq" }
  | TILDEEQUAL      { $1,"tildeeq" }
  | LEFTRIGHTARROW  { $1,"swap" }

incrop:
  | PLUSPLUS        { $1,"incr" }
  | MINUSMINUS      { $1, "decr" }

assignment: 
  | expr assignop expr SEMI 
    { 
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $4) in
      assign sname sr srop $1 $3 
    }
  | expr incrop SEMI 
    {
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $3) in
      call1 ("post_" ^ sname) sr srop $1
    }
  | incrop expr SEMI
    {
      let srop,sname = $1 in
      let sr = rsrange (slift srop) (slift $3) in
      call1 ("pre_" ^ sname) sr srop $2
    }


@doc()
Note that a block is an anonymous procedure defintion together with
a call to that procedure with the unit argument.
@p()
The assignment statement 'v <- e;' is syntact sugar for 'set(&v,e);'.

@head(3,'Place Holder')
@select(h)
todo:         
  | TODO STRING SEMI        { `AST_nop (rstoken $1 $3, snd $2) }
  | TODO SEMI               { `AST_nop (rstoken $1 $2, "") }
  | SEMI                    { `AST_nop (rstoken $1 $1,"") }

@doc()
The placed holder is used to denote an incomplete section of code.
A string may be included after the 'todo' keyword to serve as a reminder
of the programmers intentions.


@#@head(3,'If/Then/Elif/Else')
@select(h)
ifgoto_stmt:
  | IF expr GOTO NAME SEMI
    { `AST_ifgoto (rstoken $1 $5,$2,snd $4) }
/*
elif_clause:
  | ELIF expr THEN statement 
    { 
      rsrange (slift $1) (src_of_stmt $4), ($2, $4) 
    }

else_clause:
  | ELSE statement 
    { 
      rsrange (slift $1) (src_of_stmt $2), $2 
    }

if_clause:
  | IF expr THEN statement 
    { 
      rsrange (slift $1) (src_of_stmt $4),($2, $4) 
    } 

elif_clauses:
  | elif_clause elif_clauses { $1 :: $2 }
  | elif_clause { [$1] }

ifelif_clause:
  | if_clause elif_clauses { $1 :: $2 }
  | if_clause { [$1]}

if_stmt: 
  | ifelif_clause else_clause ENDIF
    { 
      `AST_if 
      (
        rsrange (fst (List.hd $1)) (fst $2), 
        $1, 
        $2
      )
    } 
  | ifelif_clause ENDIF
    {  
      `AST_if 
      (
        fst (List.hd $1), 
        $1, 
        (generated,`AST_nop (generated,""))
      ) 
    } 
*/

@doc()
The if/then/elif/else constuction provides conditional execution
of at most one branch; if the else clause is included, then
exactly one branch is executed. The conditions are tested
in order of writing.

@head(3,'Attempt/Raise/Except/Finally')
@select(h)
raise_stmt:   
  | RAISE NAME SEMI      
    { 
      `AST_raise 
      (
        rstoken $1 $3,
        snd $2, 
        `AST_tuple (rstoken $1 $3,[])
      )
    }
  | RAISE NAME expr SEMI 
    { 
      `AST_raise 
      (
        rstoken $1 $4,
        snd $2, 
        $3
      )
    }

attempt_stmt:
  | attempt_clause except_clause finally_clause ENDATTEMPT
    { 
      `AST_attempt 
      (
        rsrange (fst $1) (fst $3), 
        $1, 
        $2, 
        $3
      ) 
    }
  | attempt_clause finally_clause ENDATTEMPT
    { 
      `AST_attempt 
      (
        rsrange (fst $1) (fst $2), 
        $1, 
        (generated,[]), 
        $2
      ) 
    }
  | attempt_clause except_clause ENDATTEMPT
    { 
      `AST_attempt 
      (
        rsrange (fst $1) (fst $2), 
        $1, 
        $2, 
        (generated,[])
      ) 
    }

attempt_clause: 
  ATTEMPT statement 
  { 
    rsrange (slift $1) (src_of_stmt $2), 
    $2 
  }
except_clause:  
  EXCEPTIONS LBRACE exception_clause_aster RBRACE 
  { 
    rstoken $1 $4, 
    $3 
  }
finally_clause: 
  FINALLY compound 
  { 
    rsrange (slift $1) (fst $2), 
    snd $2 
  }

exception_clause:
  | NAME LPAR parameter_comma_list RPAR compound 
    { 
      `AST_except_handler 
      (
        rsrange (slift (fst $1)) (fst $5), 
        snd $1, 
        $3, 
        snd $5
      ) 
    }
  | NAME compound 
    { 
      `AST_except_handler 
      (
        rsrange (slift (fst $1)) (fst $2),
        snd $1, 
        [], 
        snd $2
      ) 
    }
@aster("exception_clause")

@doc()
The attempt/raise/exceptions/finally construction
provides a block with multiple terminating conditions
and an optional finally clause. While this construction
resembles exception handling, the target of a raise statement
must be in scope and is bound at compile time.
@p()
Note that a raise statement causes a branch to 
the innermost matching exception signature; that is,
branches may go to an entry point in a containing
attepmt block.
@p()
More than one exception handler may be specified with the same
name in an exception handling group, provided each instance
has an argument of a different type.
@p()
A raise statement without an argument after the exception
handler name implicitly passes a unit argument.

@head(3,'Pattern Matching')
@select(h)
match_expr:
  | MATCH expr WITH matchings ENDMATCH
  { 
    `AST_match (rstoken $1 $5, ($2, $4))
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | VBAR pattern EQRIGHTARROW expr { $2, $4 }

@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
pattern:
  | as_pattern WHEN expr 
    { 
      `PAT_when 
      (
        rsrange (src_of_pat $1) (src_of_expr $3),
        $1, 
        $3
      ) 
    }
  | as_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME 
    { 
      `PAT_as 
      (
        rsrange (src_of_pat $1) (slift (fst $3)), 
        $1, 
        snd $3
      ) 
    }
  | variant_pattern { $1 }

variant_pattern:
  | tuple_pattern { $1 }
tuple_pattern:
  | atomic_pattern_list 
    { 
      match $1 with 
      | [x] -> x 
      | _ -> `PAT_tuple 
        (
          rsrange (src_of_pat (List.hd $1)) (src_of_pat (list_last $1)),
          $1
        )
    }

atomic_pattern_list:
  | atomic_pattern COMMA atomic_pattern_list { $1 :: $3 }
  | atomic_pattern { [$1] }

atomic_pattern:
  /* constants */
  | STRING { `PAT_string (slift (fst $1), snd $1) }
  | integral 
    { 
      let sr,t,v = $1 in
      `PAT_int (sr,t,v) 
    }
  | NAN { `PAT_nan (slift $1) }
  
  /* ranges */
  | STRING DOTDOT STRING 
    { 
      `PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral 
    { 
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      `PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)  
    }

  | floating DOTDOT floating 
    { 
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      `PAT_float_range 
      (
       rsrange sr1 sr2, 
       v1, v2
      ) 
    }

  /* other */
  | ctor_pattern { $1 }
  | QUEST NAME { `PAT_name (rstoken $1 (fst $2), snd $2) }
  | QUEST { `PAT_any (slift $1) }
  | ANY { `PAT_any (slift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR basic_name_comma_list RPAR 
    { 
      let names = List.map snd $4 in
      `PAT_regexp (rstoken $1 $5, snd $2, names) 
    }


ctor_pattern:
  | ctor_name atomic_pattern 
    { 
      `PAT_nonconst_ctor 
      (
        rsrange (src_of_expr $1) (src_of_pat $2), 
        qualified_name_of_expr $1, 
        $2
      ) 
    }
  | ctor_name 
    { 
      `PAT_const_ctor 
      (
        src_of_expr $1, 
        qualified_name_of_expr $1 
      )
    }

ctor_name:
  | NAME { `AST_name (slift (fst $1), snd $1) }
  | CASE INTEGER { 
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }

integral:
  | INTEGER { let sr,t,v = $1 in slift sr, t, v }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in 
      rstoken $1 sr, t, Big_int.minus_big_int v 
    }

floating:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      slift sr, Float_plus (t,v) 
    }
  | MINUS FLOAT 
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v) 
    }
  | INF { slift $1, Float_inf }
  | MINUS INF { slift $1, Float_minus_inf }

basic_name: NAME { $1 }
@commalistof("basic_name")


@head(2,'Executable Expressions')
@select(h)
expr: 
  | rvalue { $1 }

rvalue:
  | lambda { $1 }

lambda:
  | tuple { $1 }
  | FUNCTION LPAR parameter_comma_list RPAR COLON type_expr EQUAL compound
    {
      `AST_lambda 
      (
        rsrange (slift $1) (fst $8),
        ($3, typecode_of_expr $6, snd $8)
      )
    }
  | LAZY LPAR expr RPAR 
    {
      `AST_lazy
      (
        rstoken $1 $4,
        $3
      )
    }
  | PROCEDURE LPAR parameter_comma_list RPAR compound
    {
      let sr = rsrange (slift $1) (fst $5) in
      `AST_lambda 
      (
        sr,
        ($3, `AST_void sr, snd $5)
      )
    }

  | PROCEDURE compound
    {
      let sr = rsrange (slift $1) (fst $2) in
      `AST_lambda 
      (
        sr,
        ([], `AST_void sr, snd $2)
      )
    }

tuple:
  | or_condition tuple_suffix           
    { 
      let lst = $1 :: $2 in
      `AST_tuple ( rslist lst, lst) 
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

or_condition:
  | or_condition OR and_condition       { apl2 $2 "lor" [$1; $3] }
  | and_condition                       { $1 }

and_condition:
  | and_condition AND not_condition     { apl2 $2 "land" [$1; $3] }
  | not_condition                       { $1 }

not_condition:
  | NOT not_condition                   { apl $1 "lnot" $2 }
  | comparison                          { $1 }

chain_cmp_op:
  | ANDEQEQUAL                         { "eq",$1}
  | ANDNOTEQUAL                        { "ne",$1} 
  | ANDLESS                            { "lt",$1}
  | ANDGREATER                         { "gt",$1} 
  | ANDLESSEQUAL                       { "le",$1}
  | ANDGREATEREQUAL                    { "ge",$1}

cmp_item:
  | chain_cmp_op sum                   { $1,$2 }

cmp_item_list:
  | cmp_item cmp_item_list             { $1 :: $2 }
  | cmp_item                           { [$1] }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }

/* NOTE: this routine has a FAULT: the variables
  _t0 .. _tn, _r0 .. _rn in the generated lambda
  WILL hide similar variables in the expressions.
  Normally, this can't happen because these are not
  legal user names. We should use a unique index,
  but the parser is currently stateless.
*/
  
comparison:
  | sum cmp_op sum cmp_item_list
    {
      let dummy_sr:range_srcref = ("",0,0,0,0) in
      let unit_tuple:expr_t = `AST_tuple (dummy_sr,[]) in
      let sr:range_srcref = rsrange (src_of_expr $1) (src_of_expr (snd (list_last $4))) in
      let si i = string_of_int i in
      let nm s = `AST_name (dummy_sr,s) in
      let rec p n lst = 
        match lst with
        | [] -> [] 
        | ((op,opsrc),ex) :: t ->
           `AST_val_decl(slift opsrc,"_t"^si (n+1), None, Some ex)
           ::
           `AST_val_decl
           (
             slift opsrc,
             "_r"^si (n+1),
             None,
             Some 
             (
               apl2 opsrc "land" 
               [
                 nm ("_r"^si n);
                 apl2 opsrc op 
                 [
                   nm ("_t"^si n);
                   nm ("_t"^si (n+1))
                 ]
               ]
             )
           )
           :: 
           p (n+1) t
      in 
      let stmts = 
        let n = List.length $4 in
        `AST_val_decl (src_of_expr $3,"_t0",None,Some $3) ::
        `AST_val_decl 
        (
          rsrange (src_of_expr $1) (src_of_expr $3),
          "_r0",
          None,
          Some (apl2 (snd $2) (fst $2) [$1; nm "_t0"])
        ) 
        ::
        p 0 $4
        @
        [`AST_return (sr,`AST_name(sr,"_r"^si n))]
      in
      `AST_apply
      (
        sr,
        (
          `AST_lambda (sr,([],flx_bool, stmts)),
          unit_tuple
        )
      )
    }
  | sum cmp_op sum                      { apl2 (snd $2) (fst $2) [$1; $3] }
  | arrow                               { $1 }

/* arrow is right associative */
type_expr:
  | arrow { $1 }

arrow:
  | case_literal RIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_arrow (sr,($1,$3)) 
    }
  | case_literal { $1 }

case_literal:
  | CASE INTEGER 
    {
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    } 
  | CASE INTEGER OF sum
    {
      let _,_,v = $2 in 
      `AST_typed_case 
      (
        rsrange (slift $1) (src_of_expr $4),
        Big_int.int_of_big_int v, 
        typecode_of_expr $4
      )
    } 
  | sum { $1 }

/* sum formation is 'psuedo-associative' */
sum:
  | subtraction PLUS sum_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_sum (sr,$1 :: $3) 
    }
  | subtraction { $1 }

sum_list:
  | subtraction PLUS sum_list              { $1 :: $3 }
  | subtraction { [$1] }

subtraction:
  | subtraction MINUS product { apl2 $2 "sub" [$1; $3] }
  | product { $1 }

/* product formation is 'psuedo-associative' */
product:
  | term STAR product_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_product (sr,$1 :: $3) 
    }
  | term                                { $1 }
product_list:
  | term STAR product_list              { $1 :: $3 }
  | term                                { [$1] }


/* division is left associative: note higher precedence
   the product, so that

   a * b/c * d -> a * (b/c) * d
*/
term:
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed                            { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | refr STARSTAR prefixed               { apl2 $2 "pow" [$1; $3] }
  | refr { $1 }

refr:
  | AMPER refr
    { 
      `AST_ref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | STAR refr
    { 
      `AST_deref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | application                         { $1 }

/* applications is left associative */
application:
  | application coercion
    { 
      `AST_apply (rsexpr $1 $2, ($1, $2)) 
    }
  | coercion { $1 }

coercion:
  | coercion COLON factor          
    { 
      `AST_coercion (slift $2, ($1, typecode_of_expr $3)) 
    }
  | suffixed_name                  { ($1:>expr_t) }
  | factor                         { $1 }


factor:
  | qualified_name                     { ($1:>expr_t) }
  | factor DOT LSQB expr RSQB          { apl2 $3 "subscript" [$1; $4] }
  | factor DOT LSQB expr TO expr RSQB  { apl2 $3 "substring" [$1; $4; $6] }
  | factor DOT LSQB expr TO RSQB       { apl2 $3 "copyfrom" [$1; $4] }
  | factor DOT LSQB TO expr RSQB       { apl2 $3 "copyto" [$1; $5] } 
  | factor DOT NAME                    { `AST_dot (slift $2, ($1, snd $3)) }
  | factor DOT LPAR INTEGER RPAR
    { 
      match $4 with
      | (sr,t,v) ->
        let n = 
          try Big_int.int_of_big_int v 
          with _ -> 
            failwith 
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^ 
              short_string_of_src (slift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (slift $5) in
          `AST_get_n (sr, (n,$1)) 
    }
  | factor AS NAME
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_as (sr,($1,snd $3))
    }

qualified_name:
  | qualified_name COLONCOLON NAME 
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_lookup (sr, ($1, snd $3))
    }
  | atom { $1 }

atom:
  | TYPEOF LPAR expr RPAR
    { 
      let sr = rstoken $1 $4 in
      `AST_typeof (sr,$3) 
    }
  | LBRACE expr RBRACE     { `AST_lazy (rstoken $1 $3,$2) }
  | match_expr { $1 }
  | compound            
    {
      let sr, stmts = $1 in
      `AST_lambda 
      (
        sr,
        ([], `TYP_none, stmts)
      )
    
    }
  | LPAR expr RPAR      { $2 }
  | LPAR RPAR           { `AST_tuple (rstoken $1 $2,[]) }
  | UNIT                { `AST_product (slift $1,[]) }
  | VOID                { `AST_void (slift $1) }
  | literal             { $1 }
  | simple_name         { ($1:>expr_t) }
  | IF expr THEN expr ELSE expr ENDIF 
    { 
      `AST_cond (rstoken $1 $7,($2,$4,$6))
    }

literal:
  | INTEGER 
    { let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_int (t,v)) 
    }
  | FLOAT   
    { 
      let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_float (t,v)) 
    }
  | STRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_string s) 
    }

simple_name:
  | NAME 
    { 
      `AST_name 
      (
        slift (fst $1), 
        snd $1
      ) 
    }
  | ROOT { `AST_root (slift $1) }

suffixed_name:
  | qualified_name OF LPAR type_expr RPAR 
    { 
      `AST_suffix
      (
        rsrange (src_of_expr $1) (slift $5),
        (qualified_name_of_expr $1, typecode_of_expr $4)
      )
    }



%%
(* trailer *)

@head(1,'Parser object')
@h = tangler('src/flx_parse_ctrl.ml')
@select(h)

open Flx_types
open Flx_exceptions
open Flx_parse

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try 
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError "Parsing File")
        end
      | _ -> 
        begin
          toker#report_syntax_error;
          raise (Flx_exceptions.ParseError "Parsing File")
        end
      in parse_tree
    end

let parse_string (data : string) (filename : string) = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename 
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/flx_parse_ctrl.mli')
@select(h)
val parse_file : 
  string -> 
  string ->
  string list ->
  Flx_types.compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  Flx_types.compilation_unit_t
  
@head(1,'Parser test harness')
@h = tangler('src/flxp.ml')
@select(h)
let filename = Sys.argv.(1) ^ ".flx";;
print_endline ("Parsing " ^ filename);;
let parse_tree = Flx_parse_ctrl.parse_file filename "" [];;
print_endline (Flx_print.string_of_compilation_unit parse_tree);;
print_endline "PARSE OK";;
flush stdout


