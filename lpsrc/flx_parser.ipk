@execfile('config'+os.sep+'flx_data.py')

@head(1,'Parser')
@h = tangler('src/flx_parse.dyp','data')

@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_mtypes1
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset
open Flx_exceptions
open Flx_util
open Ocs_types
open Sex_types
open Dyp

let silly_strtoken k = 
  match k with 
  | NAME (_,s) -> s
  | _ -> Dyp_symbols.str_token k


let map = List.map
let map2 = List.map2
let hd = List.hd
let tl = List.tl
let fold_left = List.fold_left
let rev = List.rev 
let mem = List.mem
let length = List.length

module Drules = Map.Make(struct
  type t = string
  let compare = compare
end)

type rule_t = string * token list * string * range_srcref

type dssl_t = {
  rules : rule_t list;
  deps : string list;
}

let fresh_dssl = { 
  rules = [];
  deps = [];
}

type local_data_t = {
  dssls : dssl_t Drules.t;
  loaded_dssls : string list;
}

let local_data = ref {
  dssls=Drules.empty; 
  loaded_dssls = [];
}

type global_data_t = {
  counter : int ref;
  env : Ocs_types.env;
  debug : bool ref;
}

exception Scheme_error of sval

let giveup () = raise Giveup; Sunspec
let sraise s  = raise (Scheme_error s); Sunspec

let flx_ocs_init env =
  Ocs_env.set_pf0 env giveup "giveup";
  Ocs_env.set_pf1 env sraise "raise"

let init_env () =  
  let env = Ocs_top.make_env () in
  flx_ocs_init env;

  let v1:Ocs_types.sval = Ocs_sym.get_symbol "_sr" in
  let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
  Ocs_env.bind_name env v1 g1;
  for n = 1 to 100 do
    let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
    let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = Sunbound } in
    Ocs_env.bind_name env v1 g1;
  done;
  env

let global_data = ref {
  counter = ref 1;
  env=init_env();
  debug=ref false;
}

(* This stuff is a hack to emit documentation
   for the reference manual
*)
let document_grammar = ref false
let grammar_doc = Hashtbl.create 97

let nt2tok = [
  "lpar","(";
  "rpar",")";
  "lsqb","[";
  "rsqb","]";
  "lbrace","{";
  "rbrace","}";
  "star","*";
  "plus","+";
  "quest","?";
  "strue","true";
  "sfalse","false";
  "colon",":";
  "ssemi",";";
  "vbar","|";
  "sname","<FONT STYLE=\"color:#00AA22\">NAME</FONT>";
  "sinteger","<FONT STYLE=\"color:#00AA22\">INTEGER</FONT>";
  "sstring","<FONT STYLE=\"color:#00AA22\">STRING</FONT>";
  "scstring","<FONT STYLE=\"color:#00AA22\">CSTRING</FONT>";
  "sepsilon","<FONT STYLE=\"color:#00AA22\">epsilon</FONT>";
]

let spelling = [
@for s,t in flx_keywords: tangle('"'+t+'","'+s+'";')
@for t,s in flx_syms: tangle('"'+t+'","'+s+'";')
]

let emit_rule dssl name dyalts =
  let done_space = ref false in
  let b = Buffer.create 1000 in
  let emit s = Buffer.add_string b s in
  let spc () = 
    if !done_space then () else
    done_space :=true; emit " "
  in
  let semit s = spc(); emit s; done_space := false in

  let emit_ter tok = semit tok in
  let emit_nt s = semit ("<A HREF=\""^s^".html\">" ^ s ^ "</A>") in
  let emit_enc s = emit ("<FONT STYLE=\"font-size:1.3em;color:#ff3300\">"^s^"</FONT>") in
  let rec emit_symbol sym = match sym with
    | `Group dyalts -> 
      spc(); emit_enc "("; done_space := false;
      let first = ref true in
      List.iter (fun x -> 
        if not (!first) then emit_enc "|"; 
        first := false;
        emit_dyalt x) 
      dyalts; 
      emit_enc ")"

    | `Atom a -> match a with
      | NAME (_,s) -> 
        begin try 
          let tok = List.assoc s nt2tok in 
          emit_ter tok
        with Not_found -> emit_nt s
        end
      | STRING (_,s) -> semit("\"" ^ s ^ "\"")
      | STAR _ -> emit_enc "*"
      | QUEST _ -> emit_enc "?"
      | PLUS _  -> emit_enc "+"
      | x -> 
        let s =  silly_strtoken x in
        let s = try List.assoc s spelling with Not_found -> s in
        semit s
      
  and emit_dyalt (rhs,sr,action) = List.iter emit_symbol rhs 
  in
  List.iter (fun x -> emit "  "; emit_enc "|"; done_space:=false; emit_dyalt x) dyalts;
  let s = Buffer.contents b in
  let old = try Hashtbl.find grammar_doc name with Not_found -> [] in
  Hashtbl.replace grammar_doc name ((dssl,s) :: old)

let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) = 
  let sr = rslist tup in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri,fn,[]), 
      `AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t = 
  let sr = src_of_expr arg in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri, fn,[]),
      arg
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l = 
  `AST_call 
  (
    sr, `AST_name (slift sri, op,[]), l
  )

(* model unary operator as procedure call *)
let call2 (op:string) (sr:range_srcref) (sri:srcref) l r = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op,[]),
    `AST_tuple(sr,[l;r])
  )

let mkcurry sr name vs (args:params_t list) return_type kind body =
  `AST_curry (sr,name,vs,args,return_type,kind,body)

let cal_funkind adjs fk =
  match fk with
  | sr,`CFunction -> sr,`CFunction
  | sr,`Generator -> sr,`Generator
  | sr,`Function -> match adjs with
  | [] -> sr,`Function
  | h :: t -> sr,snd h
  
let dfltvs = 
  [],
  {
    raw_type_constraint=`TYP_tuple [];
    raw_typeclass_reqs=[]
  } 

@expr_nts = [
  "expr",
  "dollar_apply",
  "tuple",
  "or_condition",
  "and_confition",
  "nor_condition",
  "comparison",
  "as_expr",
  "setunion",
  "setintersection",
  "arrow",
  "bor",
  "bxor",
  "band",
  "shift",
  "sum",
  "subtraction",
  "product",
  "term",
  "prefixed",
  "power",
  "superscript",
  "refr",
  "coercion",
  "factor",
  "hash_name",
  "the_name",
  "qualified_name",
  "atom",
  ]
@#

let buffer_add_ocs b r = Ocs_print.print_to_buffer b false r

let print_ocs r = 
  print_endline (Ocs_print.string_of_ocs r)

let scheme_lex sr (s:string):sval = 
  let sr = short_string_of_src sr in
  let inp = Ocs_port.string_input_port s in
  let lex = Ocs_lex.make_lexer inp sr in
  match Ocs_read.read_expr lex with
  | Ocs_types.Seof -> print_endline "END OF FILE?"; Snull
  | v ->  v

let scheme_compile env (s:sval):Ocs_types.code =
  Ocs_compile.compile env s

let scheme_eval (c:Ocs_types.code):sval =
  let th = Ocs_top.make_thread () in
  let term = ref None in
  Ocs_eval.eval th (fun (r:sval) -> term := Some r) c;
  match !term with
  | None -> failwith "Scheme term not returned!"
  | Some r -> r

let scheme_run sr env (s:string):sval = 
  let l :sval = scheme_lex sr s in
  let c :code = scheme_compile env l in
  let r :sval = scheme_eval c in
  r

let define_scheme sr dyp name rhs (scm:string) =
  let pr_age = !(dyp.global_data.counter) in 
  incr (dyp.global_data.counter)
  ;
  let lhs = 
    try dyp.add_nt name "Obj_sexpr" 
    with Dyp.Constructor_mismatch _ -> failwith ("CONSTRUCTOR MISMATCH " ^ name)
  in
  let f o =
    match o with
      | STRING _ ->
        Dyp.Ter Dyp_symbols.t_NAME

      | NAME (sr,s) -> 
          let nt = 
            try dyp.add_nt s "Obj_sexpr"
            with Dyp.Constructor_mismatch _ -> failwith ("CONSTRUCTOR MISMATCH " ^ s)
            | Dyp.Bad_constructor _ -> failwith ("BAD CONSTRUCTOR FOR " ^ s)
          in
          Dyp.Non_ter (nt,Dyp.No_priority)

      | s -> 
        let name = Dyp_symbols.str_token s in
        Dyp.Ter (Dyp_symbols.get_token_name s)
  in
  let cde = 
    try 
      let l = scheme_lex sr scm in
      let c = scheme_compile dyp.global_data.env l in
      c
    with
    | Ocs_error.Error err | Ocs_error.ErrorL (_,err) -> failwith ("Error " ^ err ^ " compiling " ^ scm) 
  in

  let rule  = lhs,(List.map f rhs),Dyp_priority_data.default_priority in
  if !(dyp.global_data.debug) then
  print_endline ("Rule "^string_of_int pr_age ^" " ^ name ^ " := " ^
  catmap " " silly_strtoken rhs ^
  " =># "^scm);
  let action = fun _ avl ->
    let age = ref pr_age in
    let b = Buffer.create 200 in
    if !(dyp.global_data.debug) then
    Buffer.add_string b ("Reducing Rule for " ^ name ^ ", scm="^scm^"\n");

    (* let env = Ocs_env.env_copy dyp.local_data.env in *)
    (* let env = dyp.local_data.env in *)
    let env = dyp.global_data.env in
    let srs = ref [] in
    let rec aux objs syms n = match objs, syms with
    | [],[] -> ()
    | [],_ | _,[] -> assert false
    | h1::t1,h2::t2 -> 
      match h1,h2 with
      | STRING (_,s1),`Obj_NAME (sr,s2) ->
        if s1 <> s2 then raise Giveup;
        if (match sr with _,l,_,_ -> l) <> 0 then
        srs := slift sr :: !srs;
        aux t1 t2 (n+1)

      | _,`Obj_sexpr (seq,sr,s) 
        ->
        (* age := max !age seq; *)
        if (match sr with _,l,_,_,_ -> l) <> 0 then
        srs := sr :: !srs;
        if !(dyp.global_data.debug) then begin
        Buffer.add_string b ("Arg " ^ string_of_int n ^ " = "); 
        buffer_add_ocs b s; Buffer.add_string b "\n";
        end;

        let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
        (*
        let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = s } in
        *)
        Ocs_env.set_glob env v1 s;
        aux t1 t2 (n+1)
      | USER_KEYWORD (_,s1) , `Obj_USER_KEYWORD (sr,s2) ->
        if s1 <> s2 then raise Giveup;
        if (match sr with _,l,_,_ -> l) <> 0 then
        srs := slift sr :: !srs;
        aux t1 t2 (n+1)
      | USER10 (_,s1,_) , `Obj_USER10 (sr,s2,_) ->
        if s1 <> s2 then raise Giveup;
        if (match sr with _,l,_,_ -> l) <> 0 then
        srs := slift sr :: !srs;
        aux t1 t2 (n+1)

@for k,n in flx_syms:
  tangle ("      | _,`Obj_"+k+" sr ")

@for n,k in flx_keywords:
  tangle ("      | _,`Obj_"+k+" sr ")
@#
        ->
        if (match sr with _,l,_,_ -> l) <> 0 then
        srs := slift sr :: !srs;
        aux t1 t2 (n+1)
         
      | _ -> aux t1 t2 (n+1)
    in
    aux rhs avl 1;
    if !(dyp.global_data.debug) then
    Buffer.add_string b "End of arguments\n";
    let sr = match !srs with
      | [] -> "dummy:"^name,0,0,0,0
      | sr::_ -> rsrange (hd (rev !srs)) sr
    in
    begin
      match sr with fn,fl,fc,ll,lc ->
      let ssr = Sstring fn :: Sint fl :: Sint fc :: Sint ll :: Sint lc :: [] in
      let ssr = Ocs_misc.make_slist Snull (rev ssr) in
      let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_sr") in
      (*
      let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = ssr } in
      *)
      Ocs_env.set_glob env v1 ssr
    end
    ;
    let r = 
      try scheme_eval cde 
      with Ocs_error.Error err | Ocs_error.ErrorL (_,err) -> 
        print_string (Buffer.contents b);
        print_string ("Error "^err^" evaluating " ^ scm);
        failwith "Error evaluating Scheme"
    in
    `Obj_sexpr (!age,sr,r)
  in
  rule,action

let extend_grammar dyp (dssl,(name,prod,action,sr)) =
  let rule = define_scheme sr dyp name prod action in
  dyp.add_rules <- rule :: dyp.add_rules

(* ------------------------------------------------------ *)

(* create rules for nt* nt+ and nt? *)
let fixup_suffix sr counter rhs =
  let rec aux inp out extras = match inp with
  | [] -> rev out,extras
  | NAME (sr,s) :: STAR _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!counter) in incr counter;
    let slr = s ^ "__rlist_"^x in
    let sl = s ^ "__list_"^x in
    let rule0 = slr,[NAME(sr,sl)],"(reverse _1)",rsr in
    let rule1 = sl,[NAME(sr,sl);NAME(sr,s)],"(cons _2 _1)",rsr in
    let rule2 = sl,[],"'()",rsr in
    aux t (NAME (sr,slr)::out) (rule0::rule1::rule2::extras)

  | NAME (sr,s) :: PLUS _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!counter) in incr counter;
    let slr = s ^ "__nerlist_"^x in
    let sl = s ^ "__nelist_"^x in
    let rule0 = slr,[NAME(sr,sl)],"(reverse _1)",rsr in
    let rule1 = sl,[NAME(sr,sl);NAME(sr,s)],"(cons _2 _1)",rsr in
    let rule2 = sl,[NAME(sr,s)],"`(,_1)",rsr in
    aux t (NAME (sr,slr)::out) (rule0::rule1::rule2::extras)

  | NAME (sr,s) :: QUEST _ :: t -> 
    let rsr = slift sr in
    let x = string_of_int (!counter) in incr counter;
    let sl = s ^ "__opt_"^x in
    let rule1 = sl,[NAME (sr,s)],"`(,_1)",rsr in
    let rule2 = sl,[],"()",rsr in
    aux t (NAME (sr,sl)::out) (rule1::rule2::extras)


  | h :: t -> aux t (h::out) extras 
  in aux rhs [] []
    
let dflt_action prod = 
  let rn = ref 1 in
  let action =
    fold_left (fun acc x -> match x with
    | NAME _ ->
      let n = !rn in incr rn;
      (if acc = "" then "" else acc ^ " ")
      ^ ",_" ^ string_of_int n 
    | _ -> incr rn; acc
    ) "" prod 
  in
  let action = "`(" ^ action ^ ")" in
  (*
  print_endline ("DEFAULT ACTION for " ^ 
    catmap " " silly_strtoken prod ^
    " =># " ^ action)
  ;
  *)
  action
  

let cal_action prod action =
  match action with 
  | `None -> dflt_action prod
  | `Scheme scm -> scm

let unlift (f,l1,c1,l2,c2) = 
  if l1 = l2 then f,l1,c1,c2
  else f,l1,c1,c1

type action_t = [`Scheme of string | `None]
type symbol_t = [`Atom of token | `Group of dyalt_t list]
and dyalt_t = symbol_t list * range_srcref * action_t

let rec flatten sr counter (rhs: symbol_t list) : token list * rule_t list =
  let rec aux inp out extras = match inp with
  | [] -> rev out,extras

  | `Group dyalts :: t -> 
    let sr = unlift sr in
    let x = string_of_int (!counter) in incr counter;
    let sl = "__grp_"^x in
    let rules : rule_t list = fixup_alternatives counter sl dyalts in
    aux t (NAME (sr,sl)::out) (rules@extras)

  | `Atom h :: t -> aux t (h::out) extras 
  in aux rhs [] []

and fixup_rule sr counter (rhs:symbol_t list) : token list * rule_t list =
  let rhs,extras = flatten sr counter rhs in
  let rhs,extras' = fixup_suffix sr counter rhs in
  rhs,extras@extras'

and fixup_alternatives counter name (dyalts:dyalt_t list) : rule_t list =
  let rules = 
    fold_left 
      (fun rules (rhs,sr,action) ->
        let prod,extras = fixup_rule sr counter rhs in
        let action : string = cal_action prod action in
        ((name,prod,action,sr) :: extras) @ rules
      ) 
      [] dyalts
  in
  rev rules

let add_rule dyp dssl rule =
  let m = dyp.local_data in
  let d: dssl_t = try Drules.find dssl m.dssls with Not_found -> fresh_dssl in
  match rule with
  | `Scheme_rule (name,dyalts) ->
     if !document_grammar then emit_rule dssl name dyalts;
     let rules = fixup_alternatives dyp.global_data.counter name dyalts in
     let rules = fold_left (fun acc rule -> uniq_add rule acc) d.rules rules in
     let d: dssl_t = {d with rules = rules } in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     dyp.local_data <- m

  | `Requires ls ->
     let d: dssl_t = {d with deps = ls @ d.deps } in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     dyp.local_data <- m

let ocs2flx sr r = 
  let sex = Ocs2sex.ocs2sex r in
  (*
  print_endline "OCS scheme term converted to s-expression:";
  Sex_print.sex_print sex;
  *)
  let fresh = ref 1 in
  let env = [] in
  let flx = Flx_sex2flx.xstatement_t sr fresh env sex in
  (*
  print_endline "s-expression converted to Felix statement!";
  print_endline (string_of_statement 0 flx);
  *)
  flx

let dummysr = "Dummy",0,0,0,0

let smerge ((oseq,osr,osex),ogd,old as oit) ((nseq,nsr,nsex),ngd,nld as nit) =
   (*
   print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
   print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ ", nxt=" ^ Ocs_print.string_of_ocs nsex);
   *)
   if oseq > nseq then oit
   else if nseq > oseq then nit
   else begin
     print_endline ("MERGING! prev=" ^ string_of_int oseq ^ ", nxt=" ^ string_of_int nseq);
     print_endline ("MERGING! prev=" ^ Ocs_print.string_of_ocs osex ^ ", nxt=" ^ Ocs_print.string_of_ocs nsex);
     Flx_exceptions.clierr2 osr nsr ("AMBIGUITY PARSING, same production!,seq = " ^ string_of_int nseq)
   end

let dyp_merge_Obj_sexpr ol = 
 match ol with
 | []
 | [_] -> assert false
 | h :: t -> 
   match fold_left smerge h t with
   ntt,gd,ld -> [ntt],gd,ld

let rec elim_common_prefix x y = 
  match x, y with
  | a :: ta, b :: tb -> 
    let eq = try a = b with _ -> false in
    if eq then elim_common_prefix ta tb
    else x,y

  | x,y -> x,y

let ssmerge ((xseq,x),xgd,xld as xit) ((yseq,y),ygd,yld as yit) =
   if xseq > yseq then xit
   else if yseq > xseq then yit
   else
   let xsr = src_of_stmt (hd x) and ysr = src_of_stmt (hd y) in
   print_endline "Ambiguity parsing statements:";
   let x = rev x and y = rev y in
   let x,y = elim_common_prefix x y in
   print_endline ("Statements 1 = " ^ catmap "\n----\n" (string_of_statement 1) x);
   print_endline ("Statement 2 = " ^ catmap "\n----\n" (string_of_statement 1) y);
   Flx_exceptions.clierr2 xsr ysr "AMBIGUITY PARSING TOP LEVEL!"


let dyp_merge_Obj_statement_star ol = 
 match ol with
 | [] 
 | [_] -> assert false
 | h::t -> 
   match fold_left ssmerge h t with
   | ntt,gd,ld -> [ntt],gd,ld

}

@head(2,'Tokens')
@select(h)
/* special */
%token <(Flx_ast.srcref * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE 
%token SLOSH
%token <(string)> COMMENT 
%token <(string)> COMMENT_NEWLINE
%token <(int)> WHITE 

/* literals */
%token <(Flx_ast.srcref * string)> NAME
%token <(Flx_ast.srcref * string * Flx_ast.bigint)> INTEGER
%token <(Flx_ast.srcref * string * string )> FLOAT
%token <(Flx_ast.srcref * string)> STRING
%token <(Flx_ast.srcref * string)> CSTRING
%token <(Flx_ast.srcref * string)> FSTRING
%token <(Flx_ast.srcref * string)> QSTRING
%token <(Flx_ast.srcref * string)> WSTRING
%token <(Flx_ast.srcref * string)> USTRING
%token <(Flx_ast.srcref * string)> USER_KEYWORD
%token <(string list)> HASH_INCLUDE_FILES
%token <(token list)> TOKEN_LIST
%token DUMMY

/* user defined symbols */
%token <(Flx_ast.srcref * string * string)> USER10
%token <(Flx_ast.srcref * (string * string) list * string)> USERLB
%token <(Flx_ast.srcref * string )> USERRB

@for k,v in flx_1_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for k,v in flx_2_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for k,v in flx_3_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for n,t in flx_keywords: 
  tangle("%token <(Flx_ast.srcref)> " + t,inhibit_sref=1)

/* top level entry */
%constructor Obj_sexpr %for sterm 

/* predefined major non-terminals */
%constructor Obj_sexpr %for statement sexpr 

/* low level non terminals */
%constructor Obj_sexpr %for sname sliteral 

/* literals */
%constructor Obj_sexpr %for sinteger sfloat sstring scstring strue sfalse

/* patterns */
%constructor Obj_sexpr %for sintegral

/* tokens replacements for special symbols used in productions */
%constructor Obj_sexpr %for star plus quest suser10token sident
%constructor Obj_sexpr %for suserlbtoken suserrbtoken
%constructor Obj_sexpr %for lbrace rbrace lpar rpar lsqb rsqb 
%constructor Obj_sexpr %for ssemi comma colon vbar

/* nothing*/
%constructor Obj_sexpr %for sepsilon

%start <(Flx_ast.compilation_unit_t)> compilation_unit
%start <(Flx_ast.expr_t)> expression
%%

@head(2,'Compilation Unit')
@select(h)
expression:  
  | old_expr ENDMARKER { $1 }

compilation_unit:  
  | statements ENDMARKER { $1 }

statements:
 | statement_star 
   {
     (*
     dyp.local_data <- dyp.last_local_data;
     dyp.keep_grammar <- true;
     *)
     List.rev (snd $1)
   }

statement_star:
 | statement_star statement
   { 
     dyp.local_data <- dyp.last_local_data;
     dyp.keep_grammar <- true;
     let seq,sr,s = $2 in
     match s with Snull -> $1 | _ ->
     let sseq,stmts = $1 in
     let s' = ocs2flx sr s in
     max seq sseq, (s' :: stmts)
   }

 | { 0,[] }

@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
dyprods:
   | dyprod dyprods { $1 :: $2 }
   | { [] }

dyprod:
   | NAME COLONEQUAL dyalts SEMI
     {
       `Scheme_rule (snd $1,$3)
     }
   | REQUIRES basic_name_comma_list SEMI
     {
        let dssls = map snd $2 in
       `Requires dssls
     }

dyalt:
   | rhs PARSE_ACTION STRING { $1,slift $2,`Scheme (snd $3) }
   | rhs { $1,dummysr,`None }

dyaltlist:
   | { [] }
   | VBAR dyalt dyaltlist { $2 :: $3 }

dyalts:
   | dyalt dyaltlist { $1 :: $2 }
   | VBAR dyalt dyaltlist { $2 :: $3 }

rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

rhs_term :
  | rhs_atom { `Atom $1 }
  | LPAR dyalts RPAR { `Group $2 }

rhs_atom:
  | NAME { let sr,s = $1 in NAME (sr,s) } /* arbitrary nonterminal */
  | STRING { let sr,s = $1 in STRING (sr,s) } /* the string as an identifier */
  | IDENT { NAME ($1,"identifier") }
  | USER_KEYWORD { USER_KEYWORD $1 } /* user terminal */
  | USER10 { USER10 $1 } /* user terminal */
@for s,t in flx_keywords:
  if t != "IDENT":
    tangle("  | " +t+ " { " + t + " $1 }")
@for t,s in flx_syms:
  if t not in ["PARSE_ACTION","VBAR","LPAR","RPAR"]:
    tangle("  | " +t+ " { " + t + " $1 }")

statement:
  | SCHEME STRING SEMI
    {
      let sr = rstoken $1 $3 in
      let s = snd $2 in
      let failwith x = print_endline ("Evaluating " ^ s); failwith x in 
      (*
      let env = Ocs_env.env_copy dyp.local_data.env in
      *)
      let env = dyp.global_data.env in
      let r = 
        try scheme_run sr env s 
        with Ocs_error.Error err | Ocs_error.ErrorL (_,err) ->
          print_endline ("Error "^err^" executing " ^s);
          failwith "Error executing SCHEME"
      in
      0,sr,Snull
    }

  | OPEN SYNTAX basic_name_comma_list SEMI
    {
      (*
      print_endline "Parsed open of syntax extensions";
      print_endline "Opening syntax extensions";
      *)
      let sr = rstoken $1 $4 in
      let dssls = map snd $3 in
      let m = dyp.local_data in

      (* calculate the transitive closure of DSSL's required
         minus those already installed
      *)
      let installed = m.loaded_dssls in
      let visited = ref [] in
      let to_install = ref [] in
      let rec cal_install s =
        if mem s installed or mem s !visited then ()
        else begin
          visited := s :: !visited;
          let d = 
            try Drules.find s m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ s)
          in
          List.iter cal_install d.deps;
          to_install := s :: !to_install
        end
      in
      List.iter cal_install dssls
      ;
      let to_install = rev (!to_install) in
      (*
      print_endline ("Installing " ^ cat "," to_install);
      *)

      let rules =
        fold_left (fun acc dssl ->
        let rules = 
          let d = 
            try Drules.find dssl m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ dssl)
          in d.rules
        in 
        let rules = map (fun x -> dssl,x) rules in
        acc @ rules
        )
        []
        to_install
      in
      List.iter (extend_grammar dyp) rules;
      dyp.local_data <- { m with loaded_dssls = to_install @ m.loaded_dssls };
      0,sr,Snull
    }

  | SYNTAX NAME LBRACE dyprods RBRACE
    {
      (*
      print_endline ("Parsed syntax extensions " ^ (snd $2));
      print_endline ("Defining syntax extensions " ^ (snd $2));
      *)
      let sr = rstoken $1 $5 in
      let dssl = snd $2 in
      List.iter (add_rule dyp dssl) (rev $4);
      0,sr,Snull
    }

expr:  
  | sexpr 
    {
      (*
      print_endline "GOT SEXPR";
      *)
      let _,sr,r = $1 in
      let sex = Ocs2sex.ocs2sex r in
      (*
      print_endline "OCS scheme sexpr converted to s-expression:";
      Sex_print.sex_print sex;
      *)
      let fresh = ref 1 in
      let env = [] in
      let flx = Flx_sex2flx.xexpr_t sr fresh env sex in
      (*
      print_endline "s-expression converted to Felix expression!";
      print_endline (string_of_expr flx);
      *)
      flx
    }


sexpr: | DUMMY { 0,dummysr,Snull }

/* identifiers which aren't keywords */
sname: NAME { 0,slift (fst $1),Sstring (snd $1) }

/* 
replacements for * + and ? to be used in productions,
since these symbols have special meansings as
list, non-empty list, and optional respectively
*/
star: STAR { 0,slift $1,Snull }
plus: PLUS { 0,slift $1,Snull }
quest: QUEST { 0,slift $1,Snull }
sident: IDENT { 0,slift $1,Snull }

lbrace: LBRACE { 0,slift $1,Snull }
rbrace: RBRACE { 0,slift $1,Snull }
lpar: LPAR { 0,slift $1,Snull }
rpar: RPAR { 0,slift $1,Snull }
lsqb: LSQB { 0,slift $1,Snull }
rsqb: RSQB { 0,slift $1,Snull }

ssemi: SEMI { 0,slift $1,Snull }
comma: COMMA { 0,slift $1,Snull }
colon: COLON { 0,slift $1,Snull }
vbar: VBAR { 0,slift $1,Snull }
strue: TRUE { 0,slift $1,Snull }
sfalse : FALSE { 0,slift $1,Snull }

/* 
a definite non-terminal for a sequence of no tokens,
since the production syntax cannot parse an empty
production at the moment 
*/
sepsilon: | {0,dummysr,Snull }

sinteger:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      0,slift sr,Sbigint v
    }

sfloat:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      let x = Sstring t::Sstring v::[] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

sintegral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      0,slift sr,x
    }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in
      let v = Big_int.minus_big_int v in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      0,slift sr,x
    }

sstring:
  | STRING
    { 
      let sr,s = $1 in
      0,slift sr,Sstring s
    }


scstring:
  | CSTRING
    { 
      let sr,s = $1 in
      0,slift sr,Sstring s
    }


sliteral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let v = Big_int.string_of_big_int v in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let aint = Ocs_sym.get_symbol "ast_int" in 
      let i = aint :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | FLOAT   
    { 
      let sr,t,v = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let afloat = Ocs_sym.get_symbol "ast_float" in 
      let i = afloat :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | STRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_string" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
   }

  | WSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_wstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | USTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_ustring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_cstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | QSTRING  
    { 
      let sr,s = $1 in
      let qstring = Ocs_sym.get_symbol "ast_interpolate" in 
      let x = qstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

  | FSTRING  
    { 
      let sr,s = $1 in
      let fstring = Ocs_sym.get_symbol "ast_vsprintf" in 
      let x = fstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      0,slift sr,x
    }

suser10token:
  | USER10 
    { 
      let sr,op,fn = $1 in
      0,slift sr,Sstring fn
    }

suserlbtoken:
  | USERLB
  {
    let sr, ass, sym = $1 in
    let ass = List.rev_map (fun (k,f) -> 
      let x = Sstring k :: Sstring f :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
      ) 
      ass 
    in
    let ass = Ocs_misc.make_slist Snull ass in
    let x = ass :: Sstring sym :: [] in
    let x = Ocs_misc.make_slist Snull (rev x) in
    0,slift sr,x
  }

suserrbtoken:
  | USERRB
  {
    0,slift (fst $1),Sstring (snd $1)
  }

/* ******************* OLD STUFF *************************** */

compound:     
  | LBRACE statements RBRACE  { rstoken $1 $3, $2 }

@head(3,'Pattern Matching')
@select(h)
match_expr:
  | MATCH expr WITH matchings ENDMATCH
  { 
    `AST_match (rstoken $1 $5, ($2, $4))
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | VBAR pattern EQRIGHTARROW expr { $2, $4 }
  | VBAR EQRIGHTARROW expr { let sr = rstoken $1 $2 in `PAT_none sr, $3 }

typecaseargs:
  | LSQB basic_name_comma_list RSQB { $2 }
  
typecase:
  | TYPECASE typecaseargs expr EQRIGHTARROW expr ENDCASE
    {
      let sr = rstoken $1 $6 in
      let t1 = $3 in
      let t2 = $5 in
      let ls = map snd $2 in
      `AST_case (sr,t1,ls,t2)
    }
    
@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
pattern:
  | as_pattern WHEN expr 
    { 
      `PAT_when 
      (
        rsrange (src_of_pat $1) (src_of_expr $3),
        $1, 
        $3
      ) 
    }
  | as_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME 
    { 
      `PAT_as 
      (
        rsrange (src_of_pat $1) (slift (fst $3)), 
        $1, 
        snd $3
      ) 
    }
  | variant_pattern { $1 }

variant_pattern:
  | tuple_pattern { $1 }
tuple_pattern:
  | coercive_pattern_list 
    { 
      match $1 with 
      | [x] -> x 
      | _ -> `PAT_tuple 
        (
          rsrange (src_of_pat (List.hd $1)) (src_of_pat (list_last $1)),
          $1
        )
    }

coercive_pattern_list:
  | coercive_pattern COMMA coercive_pattern_list { $1 :: $3 }
  | coercive_pattern { [$1] }

coercive_pattern:
  | atomic_pattern COLON arrow 
    { 
      let sr = rsrange (src_of_pat $1) (src_of_expr $3) in
      let t = typecode_of_expr $3 in
      `PAT_coercion (sr,$1,t) 
    }
  | atomic_pattern { $1 }

atomic_pattern:
  /* constants */
  | STRING { `PAT_string (slift (fst $1), snd $1) }
  | integral 
    { 
      let sr,t,v = $1 in
      `PAT_int (sr,t,v) 
    }
  | NAN { `PAT_nan (slift $1) }
  
  /* ranges */
  | STRING DOTDOT STRING 
    { 
      `PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral 
    { 
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      `PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)  
    }

  | floating DOTDOT floating 
    { 
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      `PAT_float_range 
      (
       rsrange sr1 sr2, 
       v1, v2
      ) 
    }

  /* other */
  | ctor_pattern { $1 }
  /*
  | QUEST NAME { `PAT_name (rstoken $1 (fst $2), snd $2) }
  */
  | QUEST NAME { let sr = rstoken $1 (fst $2)in `PAT_as (sr,`PAT_any sr, snd $2) }
  | QUEST { `PAT_any (slift $1) }
  | UNDERSCORE { `PAT_any (slift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR basic_name_comma_list RPAR 
    { 
      let names = List.map snd $4 in
      `PAT_regexp (rstoken $1 $5, snd $2, names) 
    }
  | STRUCT LBRACE pat_assigns RBRACE
    {
      `PAT_record (rstoken $1 $4, $3)
    }

pat_assign:
  | NAME EQUAL pattern SEMI { snd $1, $3 }
pat_assigns:
  | pat_assign pat_assigns  { $1 :: $2 }
  | pat_assign { [$1] }
  
ctor_pattern:
  | ctor_name atomic_pattern 
    { 
      `PAT_nonconst_ctor 
      (
        rsrange (src_of_expr $1) (src_of_pat $2), 
        qualified_name_of_expr $1, 
        $2
      ) 
    }
  | ctor_name 
    { 
      `PAT_const_ctor 
      (
        src_of_expr $1, 
        qualified_name_of_expr $1 
      )
    }

ctor_name:
  | qualified_name 
    { 
      $1
      (*
      match $1 with sr,name,ts ->
      `AST_name (sr,name,ts)
      *) 
    }
  
  | CASE INTEGER { 
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }

integral:
  | INTEGER { let sr,t,v = $1 in slift sr, t, v }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in 
      rstoken $1 sr, t, (Big_int.minus_big_int v)
    }

floating:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      slift sr, Float_plus (t,v) 
    }
  | MINUS FLOAT 
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v) 
    }
  | INF { slift $1, Float_inf }
  | MINUS INF { slift $1, Float_minus_inf }

basic_name: 
  | NAME { $1 }
@commalistof("basic_name")

@head(2,'Type match')
@select(h)
@commalistof('tpattern')

tuple_tpattern:
  | tpattern_comma_list { 
      match $1 with
      | _ :: _ :: _ -> `TPAT_type_tuple $1 
      | x :: [] -> x
      | [] -> assert false
    }
  
tpattern:
  | tpattern AS NAME { `TPAT_as ($1,snd $3) }
  | tpat0 { $1 }

tpat0:
  | tpat1 RIGHTARROW tpat0 { `TPAT_function ($1,$3) }
  | tpat1  { $1 }

tpat1:
  | sumpat 
    { 
      match $1 with 
      | [x] -> x 
      | ps -> `TPAT_sum ps 
    }

sumpat:
  | tpat2 PLUS sumpat { $1 :: $3 }
  | tpat2 { [$1] }

tpat2:
  | mulpat 
    { 
      match $1 with 
      | [x] -> x 
      | ps -> `TPAT_tuple ps 
    }

mulpat:
  | tpat3 STAR mulpat { $1 :: $3 }
  | tpat3 { [$1] }

tpat3:
  | NAME tpatlist { `TPAT_name (snd $1, $2) }
  | LPAR tuple_tpattern RPAR { $2 }
  | QUEST NAME { `TPAT_var (snd $2) }
  | QUEST { `TPAT_any }
  | UNDERSCORE { `TPAT_any }
  | INTEGER { let sr,t,v = $1 in `TPAT_unitsum (Big_int.int_of_big_int v) }

tpatlist:
   | LSQB tpattern_comma_list RSQB { $2 }
   | { [] }


type_match_expr:
  | TYPEMATCH expr WITH type_matchings ENDMATCH
  { 
    let t = typecode_of_expr $2 in
    `AST_type_match (rstoken $1 $5, (t, $4))
  }

type_matchings:
  | type_matching type_matchings { $1 :: $2 }
  | type_matching { [$1] }

type_matching:
  /*
  | VBAR tuple_tpattern EQRIGHTARROW expr { $2, typecode_of_expr $4 }
  */
  | VBAR expr EQRIGHTARROW expr { typecode_of_expr $2, typecode_of_expr $4 }

old_expr: 
  | LET pattern EQUAL old_expr IN old_expr 
    { 
      let sr = rsrange (slift $1) (src_of_expr $6) in
      `AST_letin (sr,($2,$4,$6)) 
    }
  | rvalue { $1 }
  
rvalue:
  | lambda { $1 }

lambda:
  | dollar_apply { $1 }

dollar_apply:
  | tuple UNLESS old_expr THEN dollar_apply
    {
      let sr = rsrange (src_of_expr $1) (src_of_expr $5) in
      let revcond = apl $2 "lnot" $3 in
      `AST_cond (sr,(revcond,$1,$5))
    }

  | tuple DOLLAR dollar_apply
    { 
      let sr = rsexpr $1 $3 in 
      `AST_apply (sr, ($1,$3)) 
    }

  | tuple { $1 }

tuple:
  | or_condition tuple_suffix           
    { 
      let lst = $1 :: $2 in
      `AST_tuple ( rslist lst, lst) 
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

/* oring formation is 'psuedo-associative' */
typeexpr: or_condition { $1 }
or_condition:
  | and_condition OR or_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_orlist (sr,$1 :: $3) 
    }
  | and_condition { $1 }

or_list:
  | and_condition OR or_list              { $1 :: $3 }
  | and_condition                         { [$1] }

/* oring formation is 'psuedo-associative' */
and_condition:
  | not_condition AND and_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_andlist (sr,$1 :: $3) 
    }
  | not_condition { $1 }

and_list:
  | not_condition AND and_list              { $1 :: $3 }
  | not_condition                         { [$1] }

notop:
  | NOT {$1,"lnot"}
not_condition:
  | notop not_condition                 { apl (fst $1) (snd $1) $2 }
  | comparison                          { $1 }

chain_cmp_op:
  | ANDEQEQUAL                         { "eq",$1}
  | ANDNOTEQUAL                        { "ne",$1} 
  | ANDLESS                            { "lt",$1}
  | ANDGREATER                         { "gt",$1} 
  | ANDLESSEQUAL                       { "le",$1}
  | ANDGREATEREQUAL                    { "ge",$1}

cmp_item:
  | chain_cmp_op sum                   { $1,$2 }

cmp_item_list:
  | cmp_item cmp_item_list             { $1 :: $2 }
  | cmp_item                           { [$1] }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }
  | ISIN                               { "_isin",$1 } 
    /* hack */

comparison:
  | sum cmp_op sum cmp_item_list
    {
      let dummy_sr:range_srcref = ("",0,0,0,0) in
      let unit_tuple:expr_t = `AST_tuple (dummy_sr,[]) in
      let sr:range_srcref = rsrange (src_of_expr $1) (src_of_expr (snd (list_last $4))) in
      let si i = string_of_int i in
      let nm s = `AST_name (dummy_sr,s,[]) in
      let rec p n lst = 
        match lst with
        | [] -> [] 
        | ((op,opsrc),ex) :: t ->
           `AST_val_decl(slift opsrc,"_t"^si (n+1), dfltvs,None, Some ex)
           ::
           `AST_val_decl
           (
             slift opsrc,
             "_r"^si (n+1),
             dfltvs,
             None,
             Some 
             (
               apl2 opsrc "land" 
               [
                 nm ("_r"^si n);
                 apl2 opsrc op 
                 [
                   nm ("_t"^si n);
                   nm ("_t"^si (n+1))
                 ]
               ]
             )
           )
           :: 
           p (n+1) t
      in 
      let stmts = 
        let n = List.length $4 in
        `AST_val_decl (src_of_expr $3,"_t0",dfltvs,None,Some $3) ::
        `AST_val_decl 
        (
          rsrange (src_of_expr $1) (src_of_expr $3),
          "_r0",dfltvs,
          None,
          Some (apl2 (snd $2) (fst $2) [$1; nm "_t0"])
        ) 
        ::
        p 0 $4
        @
        [`AST_fun_return (sr,`AST_name(sr,"_r"^si n,[]))]
      in
      `AST_apply
      (
        sr,
        (
          `AST_lambda (sr,(dfltvs,[[],None],flx_bool, stmts)),
          unit_tuple
        )
      )
    }
  | sum cmp_op sum                      { apl2 (snd $2) (fst $2) [$1; $3] }
  | as_expr                             { $1 }

as_expr:
  | as_expr AS NAME
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_as (sr,($1,snd $3))
    }
  | setunion { $1 }

setunion:
  | user10 VBARVBAR setunion_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_setunion (sr,$1 :: $3) 
    }
  | user10 { $1 }

setunion_list:
  | user10 VBARVBAR setunion_list { $1 :: $3 }
  | user10 { [$1] }

user10:
  | user10 USER10 setintersection 
    { 
      let sr,op,fn = $2 in
      apl2 sr fn [$1;$3]
    }
  | setintersection { $1 }

setintersection:
  | arrow AMPERAMPER setintersection_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_setintersection (sr,$1 :: $3) 
    }
  | arrow { $1 }

setintersection_list:
  | arrow AMPERAMPER setintersection_list { $1 :: $3 }
  | arrow { [$1] }


arrow:
  | case_literal RIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_arrow (sr,($1,$3)) 
    }
  | case_literal LONGRIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_longarrow (sr,($1,$3)) 
    }
  | case_literal { $1 }

case_literal:
  | CASE INTEGER 
    {
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    } 
  | CASE INTEGER OF sum
    {
      let _,_,v = $2 in 
      `AST_typed_case 
      (
        rsrange (slift $1) (src_of_expr $4),
        Big_int.int_of_big_int v, 
        typecode_of_expr $4
      )
    } 
  | CASE NAME OF sum
    {
      let sr =  rsrange (slift $1) (src_of_expr $4) in
      let s = snd $2 in
      let e = $4 in
      `AST_variant (sr,(s,e))
    } 

  | bor { $1 }

bor:
  | bor SLOSHVBAR bxor { apl2 $2 "bor" [$1;$3] }
  | bxor { $1 }

bxor:
  | bxor SLOSHCIRCUMFLEX band { apl2 $2 "bxor" [$1;$3] }
  | band { $1 }

band:
  | band SLOSHAMPER shift { apl2 $2 "band" [$1;$3] }
  | shift { $1 }

shift:
  | shift LEFTSHIFT sum { apl2 $2 "shl" [$1;$3] }
  | shift RIGHTSHIFT sum { apl2 $2 "shr" [$1;$3] }
  | sum { $1 }

/* sum formation is 'psuedo-associative' */
sum:
  | subtraction PLUS sum_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_sum (sr,$1 :: $3) 
    }
  | subtraction { $1 }

sum_list:
  | subtraction PLUS sum_list { $1 :: $3 }
  | subtraction { [$1] }

subtraction:
  | subtraction MINUS product { apl2 $2 "sub" [$1; $3] }
  | product { $1 }

/* product formation is 'psuedo-associative' */
product:
  | term STAR product_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_product (sr,$1 :: $3) 
    }
  | term                                { $1 }
product_list:
  | term STAR product_list              { $1 :: $3 }
  | term                                { [$1] }


/* division is left associative: note higher precedence
   the product, so that

   a * b/c * d -> a * (b/c) * d
*/
term:
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
  | LVAL power
    { 
      `AST_lvalue
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  /*
  | HASH power  { apl $1 "len" $2 }
  */
  | EXCLAMATION power  { apl $1 "excl" $2 }
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | TILDE power { apl $1 "compl" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | superscript STARSTAR prefixed      { apl2 $2 "pow" [$1; $3] }
  | superscript { $1 }

superscript:
  | superscript CIRCUMFLEX refr 
    { 
      let sr = rsrange (src_of_expr $1) (src_of_expr $3) in
      `AST_superscript (sr, ($1, $3))
    }

  | refr { $1 }
refr:
  | AMPER refr
    { 
      `AST_ref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | STAR refr { apl $1 "deref" $2 }
  | DEREF refr
    { 
      `AST_deref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | NEW refr 
    { 
      `AST_new
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }

  | application { $1 }

/* applications is left associative */
application:
  | application coercion
    { 
      `AST_apply (rsexpr $1 $2, ($1, $2)) 
    }
/*
  | MAP coercion coercion
    {
      `AST_map (rsrange (slift $1) (src_of_expr $3), $2, $3)
    }
*/
  | CASENO coercion { 
      let sr = rsrange (slift $1) (src_of_expr $2) in
      `AST_case_index (sr,$2) 
    }
    
  | coercion { $1 }


coercion:
  | coercion COLON factor          
    { 
      `AST_coercion (slift $2, ($1, typecode_of_expr $3)) 
    }
  | suffixed_name                  { ($1:>expr_t) }
  | factor                         { $1 }


factor:
  | hash_name                        { ($1:>expr_t) }
  | factor DOT LSQB old_expr RSQB          { apl2 $3 "subscript" [$1; $4] }
  | factor DOT LSQB old_expr TO old_expr RSQB  { apl2 $3 "substring" [$1; $4; $6] }
  | factor DOT LSQB old_expr TO RSQB       { apl2 $3 "copyfrom" [$1; $4] }
  | factor DOT LSQB TO old_expr RSQB       { apl2 $3 "copyto" [$1; $5] } 
  | factor DOT simple_name_parts       
    { 
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      `AST_dot (sr, ($1, `AST_name (sr,name,ts))) 
    }
  | factor DOTRIGHTARROW simple_name_parts       
    { 
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      let x = apl $2 "deref" $1 in
      `AST_dot (sr, (x, `AST_name (sr,name,ts))) 
    }
  | factor DOT LPAR INTEGER RPAR
    { 
      match $4 with
      | (sr,t,v) ->
        let n = 
          try Big_int.int_of_big_int v 
          with _ -> 
            failwith 
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^ 
              short_string_of_src (slift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (slift $5) in
          `AST_get_n (sr, (n,$1)) 
    }

hash_name:
  | HASH hash_name { `AST_lift ((slift $1), $2) }
  | the_name { $1 }

the_name:
  | NOEXPAND qualified_name
    { 
      let e = ($2:>expr_t) in
      let sr = src_of_expr e in
      let sr = rsrange (slift $1) sr in
      `AST_noexpand (sr,e) 
    }
  | THE qualified_name
  { 
    let sr = src_of_expr $2 in 
    let sr = rsrange (slift $1) sr in
    let qn = qualified_name_of_expr $2 in
    (`AST_the (sr,qn))
  }
  | qualified_name { $1 }
  | QUEST NAME { `AST_patvar (rstoken $1 (fst $2), snd $2) }
  | atom { $1 }

qualified_name:
  | qualified_name COLONCOLON simple_name_parts
    { 
      match $3 with sr,name,ts ->
      let sr = rsrange (src_of_expr $1) sr in
      `AST_lookup (sr,($1, name, ts))
    }

  | simple_name_parts  
    { 
      match $1 with sr,name,ts -> 
      (`AST_name (sr,name,ts):>expr_t) 
    }

elif:
  | ELIF old_expr THEN old_expr { $2,$4 }

elifs:
  | elifs elif { $2 :: $1 }
  | elif { [$1] }

else_part:
  | elifs ELSE old_expr 
    {
      List.fold_left (* actually a right fold cause list is reversed *)
      (fun result (cond,thn) ->
        let sr = rsrange (src_of_expr cond) (src_of_expr result) in
        `AST_cond 
        (
          sr,
          (
            cond,
            thn,
            result
          )
        )
      )
      $3 $1
    }
  | ELSE old_expr { $2 }

cond:
  | IF old_expr THEN old_expr else_part ENDIF
    { 
      `AST_cond (rstoken $1 $6,($2,$4,$5))
    }

expr_code_prefix:
  | CODE LSQB old_expr RSQB 
    {
     $1,
     typecode_of_expr $3
    }



atom:
  | UNDERSCORE { `AST_patany (slift $1) }
  | CALLBACK LSQB qualified_name RSQB
    { 
      let sr = rstoken $1 $4 in
      let qn = qualified_name_of_expr $3 in
      `AST_callback (sr,qn)
    }
  
  | DOTDOTDOT { `AST_ellipsis (slift $1) }

  | type_match_expr { $1 }
  | expr_code_prefix NAME
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | expr_code_prefix STRING
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | LSQBAR old_expr RSQBAR
    {
      let sr = rstoken $1 $3 in
      match $2 with
      | `AST_tuple (_,ls) -> `AST_arrayof (sr,ls)
      | x -> `AST_arrayof (sr,[x])
    }

  | LBRACE old_expr RBRACE     
    { 
      let sr = rstoken $1 $3 in
      `AST_lambda 
      (
        sr,
        (
          dfltvs,
          [[],None],
          `TYP_none,
          [`AST_fun_return (sr,$2)]
        ) 
      )
    }
  | match_expr { $1 }
  | typecase { $1 }
  | compound            
    {
      let sr, stmts = $1 in
      `AST_lambda 
      (
        sr,
        (dfltvs,[[],None], `TYP_none, stmts)
      )
    
    }
  | LPAR old_expr RPAR      { $2 }
  | LPAR RPAR           { `AST_tuple (rstoken $1 $2,[]) }
  | literal             { $1 }
  | cond                { $1 }
  | FSTRING             
    { 
      let sr,s = $1 in 
      let sr = slift sr in 
      `AST_vsprintf (sr,s) 
    }
  | QSTRING             
    { 
      let sr,s = $1 in 
      let sr = slift sr in 
      `AST_interpolate (sr,s) 
    }
    
  | USERLB old_expr USERRB  
    {
      let sr1,fnmap,lsym =$1 and sr2,rsym = $3 in
      let sr = rstoken sr1 sr2 in
      try
        let fn = List.assoc rsym fnmap in
        apl2 (fst $3) fn [$2]
      with Not_found ->
        Flx_exceptions.clierr sr "Mismatched brackets"
    }

literal:
  | integer_literal { $1 }
  | string_literal { $1 }
  | float_literal { $1 }
  | TRUE { `AST_typed_case (slift $1, 1, `TYP_unitsum 2) }
  | FALSE { `AST_typed_case (slift $1, 0, `TYP_unitsum 2) }

integer_literal:
  | INTEGER 
    { let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_int (t,v)) 
    }

float_literal:
  | FLOAT   
    { 
      let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_float (t,v)) 
    }

string_literal:    
  | STRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_string s) 
    }

  | WSTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_wstring s) 
    }

  | USTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_ustring s) 
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_cstring s) 
    }

simple_name_parts:
  | NAME LSQB old_expr RSQB  
    { 
      rsrange (slift (fst $1)) (slift $4),
      snd $1,
      match typecode_of_expr $3 with
      | `TYP_type_tuple ls -> ls
      | x -> [x]
    }

  | identifier { $1 }

identifier:
  | NAME 
    { 
      slift (fst $1), 
      snd $1,
      []
    }

suffixed_name:
  | qualified_name OF factor
    { 
      `AST_suffix
      (
        rsrange (src_of_expr $1) (src_of_expr $3),
        (qualified_name_of_expr $1, typecode_of_expr $3)
      )
    }

epsilon: | {()}

%mli { 
  exception Scheme_error of Ocs_types.sval 
  val document_grammar : bool ref
  val grammar_doc : (string,(string * string) list) Hashtbl.t
}

@head(1,'Parser object')
@h = tangler('src/flx_parse_ctrl.ml')
@select(h)

open Flx_ast
open Flx_exceptions
open Flx_parse

let dyphack (ls : ( 'a * Dyp.priority) list) : 'a =
  match ls with
  | [x,_] -> x
  | _ -> failwith "Dypgen parser failed"

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
  expand_expr
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
      expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
  let hash_include_files, tokens = match tokens with
    | HASH_INCLUDE_FILES fs :: t -> fs,t
    | _ -> assert false
  in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError ("Failure \""^s^"\" Parsing File"))
        end
      | Flx_exceptions.ClientError _ 
      | Flx_exceptions.ClientError2 _ 
      | Flx_exceptions.ClientErrorn _ as x  ->
        begin
          toker#report_syntax_error;
          raise x
        end

      | Flx_exceptions.RDP_match_fail (sr1,sr2,s) as x  ->
        begin
          toker#report_syntax_error;
          clierr2 sr1 sr2 ("User Syntax Parse Error " ^ s)
        end

      | Dyp.Bad_constructor (nt,ctor1, ctor2) ->
          toker#report_syntax_error;
          let s = "Bad constructor '" ^ ctor1 ^ "' and '" ^ ctor2 ^ "' for nonterminal '" ^ nt ^"'" in
          print_endline s;
          failwith s

      | x -> 
        begin
          toker#report_syntax_error;
          print_endline (Printexc.to_string x);
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
      in hash_include_files, parse_tree
    end

let parse_string (data : string) (filename : string) expand_expr = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/flx_parse_ctrl.mli')
@select(h)
open Flx_ast

val parse_file : 
  string -> (* filenames *)
  string ->
  string list ->
  (string -> expr_t -> expr_t) ->
  string list * compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  (string -> expr_t -> expr_t) ->
  compilation_unit_t

@head(1,'Parser test harness')
@h = tangler('src/flxp.ml')
@select(h)
open Flx_mtypes2
open Flx_types
open Flx_version
open Flx_flxopt
open Flx_getopt
;;

let print_help () = print_options(); exit(0)
;;

let run() =
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in
  Flx_parse.document_grammar := compiler_options.document_grammar;

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;

  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" in

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline ("Parsing " ^ input_file_name);
    print_endline "---------------------------------------";
  end
  ;

  let _,parse_tree = 
    Flx_parse_ctrl.parse_file 
    input_file_name
    (Filename.dirname input_file_name)
    compiler_options.include_dirs
    Flx_macro.expand_expression
  in
    print_endline (Flx_print.string_of_compilation_unit parse_tree);

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline "PARSE OK";
    print_endline "---------------------------------------";
  end
  ;

  flush stdout;

  if compiler_options.document_grammar then begin
    let _ = try Unix.mkdir "doc" 0o775 with _ -> () in
    let _ = try Unix.mkdir "doc/gramdoc" 0o775 with _ -> () in
    Hashtbl.iter
    (fun name dfn ->
      let f = open_out ("doc/gramdoc/" ^ name ^ ".html") in
      let w s = output_string f s in
      w "<html><head>\n";
      w "<meta content=\"text/html; charset=utf8\" http-equiv=\"Content-Type\">\n";
      w ("<title>" ^ name ^ "</title>\n");
      w "</head>\n";
      w "<body><pre><code>\n";
      w (" " ^ name ^ " := \n");
      List.iter (fun (dssl,s) -> 
        let ds = String.sub ("  " ^ dssl ^ String.make 20 ' ') 0 20 in
        w ("<FONT STYLE=\"color:#400040\">"^ ds ^"</FONT>"^ s ^ "\n")) 
        (List.rev dfn)
      ;
      w "\n";
      w "</code></pre></body></html>\n";
      close_out f
    )
    Flx_parse.grammar_doc;
    let grammar_list = Hashtbl.fold (fun k _ acc -> k::acc) Flx_parse.grammar_doc [] in
    let grammar_list = List.sort compare grammar_list in
    let f = open_out ("doc/gramdoc/index.html") in
    let w s = output_string f s in
    w "<html><head>\n";
    w "<meta content=\"text/html; charset=utf8\" http-equiv=\"Content-Type\">\n";
    w ("<title>Felix Grammar</title>\n");
    w "</head>\n";
    w "<body><pre><code>\n";
    List.iter
    (fun name ->
      w (" <A HREF=\"" ^ name ^ ".html\">"^name^"</A>\n");
    )
    grammar_list
    ;
    w "</code></pre></body></html>\n";
    close_out f
  end;

in
  run()
;;

