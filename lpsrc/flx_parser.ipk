@execfile('config'+os.sep+'flx_data.py')

@head(1,'Parser')
@h = tangler('src/flx_parse.dyp','data')

@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_mtypes1
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset
open Flx_exceptions
open Flx_util
open Ocs_types
open Sex_types
open Dyp

let map = List.map
let map2 = List.map2
let hd = List.hd
let tl = List.tl
let fold_left = List.fold_left
let rev = List.rev 
let mem = List.mem
let length = List.length

module Drules = Map.Make(struct
  type t = string
  let compare = compare
end)

type rule_t = string * token list * statement_t * range_srcref

type dssl_t = {
  rules : rule_t list;
  deps : string list;
}

let fresh_dssl = { 
  rules = [];
  deps = [];
}

type parse_info = {
  dssls : dssl_t Drules.t;
  env : Ocs_types.env;
  loaded_dssls : string list;
}

let local_data = ref {
  dssls=Drules.empty; 
  env=Ocs_top.make_env ();
  loaded_dssls = [];
}


let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) = 
  let sr = rslist tup in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri,fn,[]), 
      `AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t = 
  let sr = src_of_expr arg in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri, fn,[]),
      arg
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l = 
  `AST_call 
  (
    sr, `AST_name (slift sri, op,[]), l
  )

(* model unary operator as procedure call *)
let call2 (op:string) (sr:range_srcref) (sri:srcref) l r = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op,[]),
    `AST_tuple(sr,[l;r])
  )

let mkcurry sr name vs (args:params_t list) return_type kind body =
  `AST_curry (sr,name,vs,args,return_type,kind,body)

let cal_funkind adjs fk =
  match fk with
  | sr,`CFunction -> sr,`CFunction
  | sr,`Generator -> sr,`Generator
  | sr,`Function -> match adjs with
  | [] -> sr,`Function
  | h :: t -> sr,snd h
  
(* MOVED TO flx_typing 
(* handle curried type functions *)
let mktypefun sr name vs (args: (string * typecode_t) list list) return_type body =
  let argtyp t = match t with
    | [] -> failwith "Lambda abstraction requires nonunit parameter"
    | [x] -> x
    | x -> `TYP_type_tuple x
  in
  let body = 
    let p = ref (List.rev args) in
    let r = ref return_type in
    let b = ref body in
    while !p <> [] do
      let arg = List.hd !p in
      p := List.tl !p;
      b := `TYP_typefun (arg, !r, !b);
      r := `TYP_function(argtyp (List.map snd (arg)),!r)
    done;
    !b
  in
  `AST_type_alias
  (
    sr,
    name,
    vs,
    body
  )
*)

let dfltvs = 
  [],
  {
    raw_type_constraint=`TYP_tuple [];
    raw_typeclass_reqs=[]
  } 

@expr_nts = [
  "expr",
  "dollar_apply",
  "tuple",
  "or_condition",
  "and_confition",
  "nor_condition",
  "comparison",
  "as_expr",
  "setunion",
  "setintersection",
  "arrow",
  "bor",
  "bxor",
  "band",
  "shift",
  "sum",
  "subtraction",
  "product",
  "term",
  "prefixed",
  "power",
  "superscript",
  "refr",
  "coercion",
  "factor",
  "hash_name",
  "the_name",
  "qualified_name",
  "atom",
  ]
@#

let string_of_ocs r = 
  let outp = Buffer.create 200 in
  Ocs_print.print_to_buffer outp false r;
  Buffer.contents outp

let buffer_add_ocs b r = Ocs_print.print_to_buffer b false r

let print_ocs r = 
  print_endline (string_of_ocs r)

let scheme_eval env (s:sval):sval =
  let term = ref None in
  let get_port = function 
    | Ocs_types.Sport p -> p
    | _ -> failwith "expected port"
  in
  let th = Ocs_top.make_thread () in
  begin try
    let c = Ocs_compile.compile env s in
    (*
    print_endline "COMPILED";
    *)
    Ocs_eval.eval th (function 
(*
      | Ocs_types.Sunspec -> failwith "UNSPECIFIED" 
*)
      | r -> 
         (*
         print_endline "EVALUATED";
         Ocs_print.print outp false r;
         Ocs_port.puts outp "\n";
         Ocs_port.flush outp;
         *)
         term := Some r
    ) c
  with 
    | Ocs_error.Error err 
    | Ocs_error.ErrorL (_,err) 
      ->
        failwith ("Error " ^ err)
  end
  ;
  match !term with
  | None -> failwith "Scheme term not returned!"
  | Some r -> r

let scheme_compile_eval failwith env (s:string):sval = 
  try
  let inp = Ocs_port.string_input_port s in
  let lex = Ocs_lex.make_lexer inp "" in
  begin match Ocs_read.read_expr lex with
  | Ocs_types.Seof -> print_endline "END OF FILE?"; Snull
  | v -> scheme_eval env v
  end
  with
  | Failure e -> failwith ("ERROR EVALUATING SCHEME " ^ s ^", err=" ^ e)
  | x -> failwith ("ERROR EVALUATING SCHEME " ^ s ^ ", exn=" ^ Printexc.to_string x)


let define_scheme dyp name rhs (scm:string) =
  let lhs = 
    try dyp.add_nt name "Obj_sexpr" 
    with Dyp.Constructor_mismatch _ -> failwith ("CONSTRUCTOR MISMATCH " ^ name)
  in
  let f o =
    match o with
      | NAME (sr,s) -> 
          let nt = 
            try dyp.add_nt s "Obj_sexpr"
            with Dyp.Constructor_mismatch _ -> failwith ("CONSTRUCTOR MISMATCH " ^ s)
            | Dyp.Bad_constructor _ -> failwith ("BAD CONSTRUCTOR FOR " ^ s)
          in
          Dyp.Non_ter (nt,Dyp.No_priority)
      | s -> 
        let name = Dyp_symbols.str_token s in
        Dyp.Ter (Dyp_symbols.get_token_name s)
  in
  let rule  = lhs,(List.map f rhs),Dyp_priority_data.default_priority in
  (*
  print_endline ("A Rule for " ^ name ^ " defined, scm="^scm);
  *)
  let action = fun _ avl ->
    let b = Buffer.create 200 in
    Buffer.add_string b ("Reducing Rule for " ^ name ^ ", scm="^scm^"\n");
    let env = Ocs_env.env_copy dyp.local_data.env in
    let srs = ref [] in
    let rec aux objs syms n = match objs, syms with
    | [],[] -> ()
    | [],_ | _,[] -> assert false
    | h1::t1,h2::t2 -> 
      match h1,h2 with
      | _,`Obj_sexpr (sr,s) 
        ->
        srs := sr :: !srs;
        Buffer.add_string b ("Arg " ^ string_of_int n ^ " = "); 
        buffer_add_ocs b s; Buffer.add_string b "\n";

        let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
        let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = s } in
        Ocs_env.bind_name env v1 g1;
        aux t1 t2 (n+1)
      | USER_KEYWORD (sr,s1) , `Obj_USER_KEYWORD (_,s2) ->
        if s1 <> s2 then raise Giveup;
        srs := slift sr :: !srs;
        aux t1 t2 (n+1)
@for k,n in flx_syms:
  tangle ("      | _,`Obj_"+k+" sr ")

@for n,k in flx_keywords:
  tangle ("      | _,`Obj_"+k+" sr ")
@#
        ->
        srs := slift sr :: !srs;
        aux t1 t2 (n+1)
         
      | _ -> aux t1 t2 (n+1)
    in
    aux rhs avl 1;
    Buffer.add_string b "End of arguments\n";
    let sr = match !srs with
      | [] -> "dummy:"^name,0,0,0,0
      | sr::_ -> rsrange (hd (rev !srs)) sr
    in
    begin
      match sr with fn,fl,fc,ll,lc ->
      let ssr = Sstring fn :: Sint fl :: Sint fc :: Sint ll :: Sint lc :: [] in
      let ssr = Ocs_misc.make_slist Snull (rev ssr) in
      let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_sr") in
      let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = ssr } in
      Ocs_env.bind_name env v1 g1
    end
    ;
    let failwith x = print_string (Buffer.contents b); failwith x in
    let r = scheme_compile_eval failwith env scm in
    `Obj_sexpr (sr,r)
  in
  rule,action

let add_rule dyp dssl rule =
  let m = dyp.local_data in
  let d: dssl_t = try Drules.find dssl m.dssls with Not_found -> fresh_dssl in
  match rule with
  | `Scheme_rule rule ->
     let d: dssl_t = {d with rules = (uniq_add rule d.rules) } in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     dyp.local_data <- m

  | `Requires ls ->
     let d: dssl_t = {d with deps = ls @ d.deps } in
     let m = {m with dssls=Drules.add dssl d m.dssls } in
     dyp.local_data <- m


(* create rules for nt* nt+ and nt? *)
let fixup_rule rhs =
  let rec aux inp out extras = match inp with
  | [] -> rev out,extras
  | NAME (sr,s) :: STAR _ :: t -> 
    let sl = s ^ "__list" in
    let rule1 = sl,[NAME(sr,s);NAME(sr,sl)],"(cons _1 _2)" in
    let rule2 = sl,[],"'()" in
    aux t (NAME (sr,sl)::out) (rule1::rule2::extras)

  | NAME (sr,s) :: PLUS _ :: t -> 
    let sl = s ^ "__nelist" in
    let rule1 = sl,[NAME(sr,s);NAME(sr,sl)],"(cons _1 _2)" in
    let rule2 = sl,[NAME(sr,s)],"`(,_1)" in
    aux t (NAME (sr,sl)::out) (rule1::rule2::extras)

  | NAME (sr,s) :: QUEST _ :: t -> 
    let sl = s ^ "__opt" in
    let rule1 = sl,[NAME (sr,s)],"`(some ,_1)" in
    let rule2 = sl,[],"'none" in
    aux t (NAME (sr,sl)::out) (rule1::rule2::extras)


  | h :: t -> aux t (h::out) extras 
  in aux rhs [] []

let do_dyp_rule dyp (dssl,(name,rhs,stmt,sr)) =
   (*
   print_endline ("PROCESSING DEFINITION " ^ name ^ ":= " ^
   catmap " " (function 
   | NAME (_,s) -> "<"^s^">"
   | USER_KEYWORD (_,s) -> s
   | x -> Dyp_symbols.str_token x
   ) rhs ^ 
   "=>#\n" ^
   string_of_statement 0 stmt
   );
   *)
   match stmt with
   | `AST_scheme_string (sr,s) ->
        (*
        print_endline ("SCHEME, user action = " ^ s);
        *)
        let prod,extras = fixup_rule rhs in
        let rule = define_scheme dyp name prod s in
        dyp.add_rules <- rule :: dyp.add_rules;
        List.iter (fun (name,prod,s) ->
          let rule = define_scheme dyp name prod s in
          dyp.add_rules <- rule :: dyp.add_rules;
        )
        extras 

   | _ ->
     let s = 
        "Syntax extension: non-terminal " ^ name ^
        " requires action to be Scheme term!"
      in
      print_endline s;
      clierr sr s

let ocs2flx sr r = 
  let sex = Ocs2sex.ocs2sex r in
  (*
  print_endline "OCS scheme term converted to s-expression:";
  Sex_print.sex_print sex;
  *)
  let fresh = ref 1 in
  let env = [] in
  let flx = Flx_sex2flx.xstatement_t sr fresh env sex in
  (*
  print_endline "s-expression converted to Felix statement!";
  print_endline (string_of_statement 0 flx);
  *)
  flx

let dummysr = "Dummy",0,0,0,0

}

@head(2,'Tokens')
@select(h)
/* special */
%token <(Flx_ast.srcref * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE 
%token SLOSH
%token <(string)> COMMENT 
%token <(string)> COMMENT_NEWLINE
%token <(int)> WHITE 

/* literals */
%token <(Flx_ast.srcref * string)> NAME
%token <(Flx_ast.srcref * string * Flx_ast.bigint)> INTEGER
%token <(Flx_ast.srcref * string * string )> FLOAT
%token <(Flx_ast.srcref * string)> STRING
%token <(Flx_ast.srcref * string)> CSTRING
%token <(Flx_ast.srcref * string)> FSTRING
%token <(Flx_ast.srcref * string)> QSTRING
%token <(Flx_ast.srcref * string)> WSTRING
%token <(Flx_ast.srcref * string)> USTRING
%token <(Flx_ast.srcref * string)> USER_KEYWORD
%token <(string list)> HASH_INCLUDE_FILES
%token <(token list)> TOKEN_LIST
%token DUMMY

/* user defined symbols */
%token <(Flx_ast.srcref * string * string)> USER10
%token <(Flx_ast.srcref * (string * string) list * string)> USERLB
%token <(Flx_ast.srcref * string )> USERRB

@for k,v in flx_1_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for k,v in flx_2_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for k,v in flx_3_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for n,t in flx_keywords: 
  tangle("%token <(Flx_ast.srcref)> " + t,inhibit_sref=1)

/* top level entry */
%constructor Obj_sexpr %for sterm 

/* predefined major non-terminals */
%constructor Obj_sexpr %for statement sexpr satom 

/* low level non terminals */
%constructor Obj_sexpr %for sname sliteral 

/* literals */
%constructor Obj_sexpr %for sinteger sfloat sstring scstring strue sfalse

/* patterns */
%constructor Obj_sexpr %for sintegral

/* tokens replacements for special symbols used in productions */
%constructor Obj_sexpr %for star plus quest suser10token sident
%constructor Obj_sexpr %for suserlbtoken suserrbtoken
%constructor Obj_sexpr %for lbrace rbrace lpar rpar lsqb rsqb 
%constructor Obj_sexpr %for ssemi comma colon vbar

/* nothing*/
%constructor Obj_sexpr %for sepsilon

%start <(Flx_ast.compilation_unit_t)> compilation_unit
%start <(Flx_ast.expr_t)> expression
%%

@head(2,'Compilation Unit')
@select(h)
expression:  
  | old_expr ENDMARKER { $1 }

compilation_unit:  
  | statements ENDMARKER { $1 }

statements:
 | statement statements 
   { 
     let sr,s = $1 in 
     ocs2flx sr s :: $2
   }

 | { [] }

@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
dyalt:
   | rhs PARSE_ACTION STRING { $1,slift $2,snd $3 }
   | NAME { [NAME $1],dummysr,"_1" }

dyaltlist:
   | { [] }
   | VBAR dyalt dyaltlist { $2 :: $3 }

dyalts:
   | dyalt dyaltlist { $1 :: $2 }
   | VBAR dyalt dyaltlist { $2 :: $3 }

dyprod:
   | NAME COLONEQUAL dyalts SEMI
     {
       let name = snd $1 in
       map (fun (rhs,sr,scm) ->
         let stmt = `AST_scheme_string (sr,scm) in
         `Scheme_rule (name,rhs,stmt,sr)
       ) $3
     }
   | REQUIRES basic_name_comma_list SEMI
     {
        let dssls = map snd $2 in
       [`Requires dssls]
     }

dyprods:
   | dyprod dyprods { $1 @ $2 }
   | { [] }

rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

rhs_term :
  | NAME { let sr,s = $1 in NAME (sr,s) } /* arbitrary nonterminal */
  | IDENT { NAME ($1,"identifier") }
  | USER_KEYWORD { USER_KEYWORD $1 } /* user terminal */
  | USER10 { USER10 $1 } /* user terminal */
@for s,t in flx_keywords:
  if t != "IDENT":
    tangle("  | " +t+ " { " + t + " $1 }")
@for t,s in flx_syms:
  if t not in ["PARSE_ACTION","VBAR"]:
    tangle("  | " +t+ " { " + t + " $1 }")

statement:
  | SCHEME STRING SEMI
    {
      let sr = rstoken $1 $3 in
      let s = snd $2 in
      let failwith x = print_endline ("Evaluating " ^ s); failwith x in 
      let env = Ocs_env.env_copy dyp.local_data.env in
      let r = scheme_compile_eval failwith env s in
      dyp.local_data <- { dyp.local_data with env = env };
      sr,Snull
    }

  | OPEN SYNTAX basic_name_comma_list SEMI
    {
      (*
      print_endline "Parsed open of syntax extensions";
      print_endline "Opening syntax extensions";
      *)
      let sr = rstoken $1 $4 in
      let dssls = map snd $3 in
      let m = dyp.local_data in

      (* calculate the transitive closure of DSSL's required
         minus those already installed
      *)
      let installed = m.loaded_dssls in
      let to_install = ref [] in
      let rec cal_install s =
        if mem s installed or mem s !to_install then ()
        else begin
          to_install := s :: !to_install;
          let d = 
            try Drules.find s m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ s)
          in
          List.iter cal_install d.deps
        end
      in
      List.iter cal_install dssls
      ;

      let rules =
        fold_left (fun acc dssl ->
        let rules = 
          let d = 
            try Drules.find dssl m.dssls
            with Not_found -> failwith ("Can't open syntax " ^ dssl)
          in d.rules
        in 
        let rules = map (fun x -> dssl,x) rules in
        acc @ rules
        )
        []
        !to_install
      in
      List.iter (do_dyp_rule dyp) rules;
      dyp.local_data <- { m with loaded_dssls = !to_install @ m.loaded_dssls };
      sr,Snull
    }

  | SYNTAX NAME LBRACE dyprods RBRACE
    {
      (*
      print_endline ("Parsed syntax extensions " ^ (snd $2));
      print_endline ("Defining syntax extensions " ^ (snd $2));
      *)
      let sr = rstoken $1 $5 in
      let dssl = snd $2 in
      List.iter (add_rule dyp dssl) $4;
      sr,Snull
    }

expr:  
  | sexpr 
    {
      (*
      print_endline "GOT SEXPR";
      *)
      let sr,r = $1 in
      let sex = Ocs2sex.ocs2sex r in
      (*
      print_endline "OCS scheme sexpr converted to s-expression:";
      Sex_print.sex_print sex;
      *)
      let fresh = ref 1 in
      let env = [] in
      let flx = Flx_sex2flx.xexpr_t sr fresh env sex in
      (*
      print_endline "s-expression converted to Felix expression!";
      print_endline (string_of_expr flx);
      *)
      flx
    }


sexpr: | DUMMY { dummysr,Snull }

/* identifiers which aren't keywords */
sname: NAME { slift (fst $1),Sstring (snd $1) }

/* 
replacements for * + and ? to be used in productions,
since these symbols have special meansings as
list, non-empty list, and optional respectively
*/
star: STAR { slift $1,Snull }
plus: PLUS { slift $1,Snull }
quest: QUEST { slift $1,Snull }
sident: IDENT { slift $1,Snull }

lbrace: LBRACE { slift $1,Snull }
rbrace: RBRACE { slift $1,Snull }
lpar: LPAR { slift $1,Snull }
rpar: RPAR { slift $1,Snull }
lsqb: LSQB { slift $1,Snull }
rsqb: RSQB { slift $1,Snull }

ssemi: SEMI { slift $1,Snull }
comma: COMMA { slift $1,Snull }
colon: COLON { slift $1,Snull }
vbar: VBAR { slift $1,Snull }
strue: TRUE { slift $1,Snull }
sfalse : FALSE { slift $1,Snull }

/* 
a definite non-terminal for a sequence of no tokens,
since the production syntax cannot parse an empty
production at the moment 
*/
sepsilon: | {dummysr,Snull }

satom:
  | sliteral { $1 }

  | NAME 
    {
      let sr,x = $1 in
      let aname = Ocs_sym.get_symbol "ast_name" in 
      let empty = Ocs_misc.make_slist Snull [] in
      let x = aname :: Sstring x :: empty :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

sinteger:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      slift sr,Sbigint v
    }

sfloat:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      let x = Sstring t::Sstring v::[] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

sintegral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      slift sr,x
    }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in
      let v = Big_int.minus_big_int v in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      slift sr,x
    }

sstring:
  | STRING
    { 
      let sr,s = $1 in
      slift sr,Sstring s
    }


scstring:
  | CSTRING
    { 
      let sr,s = $1 in
      slift sr,Sstring s
    }


sliteral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let v = Big_int.string_of_big_int v in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let aint = Ocs_sym.get_symbol "ast_int" in 
      let i = aint :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

  | FLOAT   
    { 
      let sr,t,v = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let afloat = Ocs_sym.get_symbol "ast_float" in 
      let i = afloat :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

  | STRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_string" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
   }

  | WSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_wstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

  | USTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_ustring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_cstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

  | QSTRING  
    { 
      let sr,s = $1 in
      let qstring = Ocs_sym.get_symbol "ast_interpolate" in 
      let x = qstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

  | FSTRING  
    { 
      let sr,s = $1 in
      let fstring = Ocs_sym.get_symbol "ast_vsprintf" in 
      let x = fstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      slift sr,x
    }

suser10token:
  | USER10 
    { 
      let sr,op,fn = $1 in
      slift sr,Sstring fn
    }

suserlbtoken:
  | USERLB
  {
    let sr, ass, sym = $1 in
    let ass = List.rev_map (fun (k,f) -> 
      let x = Sstring k :: Sstring f :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
      ) 
      ass 
    in
    let ass = Ocs_misc.make_slist Snull ass in
    let x = ass :: Sstring sym :: [] in
    let x = Ocs_misc.make_slist Snull (rev x) in
    slift sr,x
  }

suserrbtoken:
  | USERRB
  {
    slift (fst $1),Sstring (snd $1)
  }

/* ******************* OLD STUFF *************************** */

compound:     
  | LBRACE statements RBRACE  { rstoken $1 $3, $2 }

@head(3,'Pattern Matching')
@select(h)
match_expr:
  | MATCH expr WITH matchings ENDMATCH
  { 
    `AST_match (rstoken $1 $5, ($2, $4))
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | VBAR pattern EQRIGHTARROW expr { $2, $4 }
  | VBAR EQRIGHTARROW expr { let sr = rstoken $1 $2 in `PAT_none sr, $3 }

typecaseargs:
  | LSQB basic_name_comma_list RSQB { $2 }
  
typecase:
  | TYPECASE typecaseargs expr EQRIGHTARROW expr ENDCASE
    {
      let sr = rstoken $1 $6 in
      let t1 = $3 in
      let t2 = $5 in
      let ls = map snd $2 in
      `AST_case (sr,t1,ls,t2)
    }
    
@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
pattern:
  | as_pattern WHEN expr 
    { 
      `PAT_when 
      (
        rsrange (src_of_pat $1) (src_of_expr $3),
        $1, 
        $3
      ) 
    }
  | as_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME 
    { 
      `PAT_as 
      (
        rsrange (src_of_pat $1) (slift (fst $3)), 
        $1, 
        snd $3
      ) 
    }
  | variant_pattern { $1 }

variant_pattern:
  | tuple_pattern { $1 }
tuple_pattern:
  | coercive_pattern_list 
    { 
      match $1 with 
      | [x] -> x 
      | _ -> `PAT_tuple 
        (
          rsrange (src_of_pat (List.hd $1)) (src_of_pat (list_last $1)),
          $1
        )
    }

coercive_pattern_list:
  | coercive_pattern COMMA coercive_pattern_list { $1 :: $3 }
  | coercive_pattern { [$1] }

coercive_pattern:
  | atomic_pattern COLON arrow 
    { 
      let sr = rsrange (src_of_pat $1) (src_of_expr $3) in
      let t = typecode_of_expr $3 in
      `PAT_coercion (sr,$1,t) 
    }
  | atomic_pattern { $1 }

atomic_pattern:
  /* constants */
  | STRING { `PAT_string (slift (fst $1), snd $1) }
  | integral 
    { 
      let sr,t,v = $1 in
      `PAT_int (sr,t,v) 
    }
  | NAN { `PAT_nan (slift $1) }
  
  /* ranges */
  | STRING DOTDOT STRING 
    { 
      `PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral 
    { 
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      `PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)  
    }

  | floating DOTDOT floating 
    { 
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      `PAT_float_range 
      (
       rsrange sr1 sr2, 
       v1, v2
      ) 
    }

  /* other */
  | ctor_pattern { $1 }
  /*
  | QUEST NAME { `PAT_name (rstoken $1 (fst $2), snd $2) }
  */
  | QUEST NAME { let sr = rstoken $1 (fst $2)in `PAT_as (sr,`PAT_any sr, snd $2) }
  | QUEST { `PAT_any (slift $1) }
  | UNDERSCORE { `PAT_any (slift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR basic_name_comma_list RPAR 
    { 
      let names = List.map snd $4 in
      `PAT_regexp (rstoken $1 $5, snd $2, names) 
    }
  | STRUCT LBRACE pat_assigns RBRACE
    {
      `PAT_record (rstoken $1 $4, $3)
    }

pat_assign:
  | NAME EQUAL pattern SEMI { snd $1, $3 }
pat_assigns:
  | pat_assign pat_assigns  { $1 :: $2 }
  | pat_assign { [$1] }
  
ctor_pattern:
  | ctor_name atomic_pattern 
    { 
      `PAT_nonconst_ctor 
      (
        rsrange (src_of_expr $1) (src_of_pat $2), 
        qualified_name_of_expr $1, 
        $2
      ) 
    }
  | ctor_name 
    { 
      `PAT_const_ctor 
      (
        src_of_expr $1, 
        qualified_name_of_expr $1 
      )
    }

ctor_name:
  | qualified_name 
    { 
      $1
      (*
      match $1 with sr,name,ts ->
      `AST_name (sr,name,ts)
      *) 
    }
  
  | CASE INTEGER { 
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }

integral:
  | INTEGER { let sr,t,v = $1 in slift sr, t, v }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in 
      rstoken $1 sr, t, (Big_int.minus_big_int v)
    }

floating:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      slift sr, Float_plus (t,v) 
    }
  | MINUS FLOAT 
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v) 
    }
  | INF { slift $1, Float_inf }
  | MINUS INF { slift $1, Float_minus_inf }

basic_name: 
  | NAME { $1 }
@commalistof("basic_name")

@head(2,'Type match')
@select(h)
@commalistof('tpattern')

tuple_tpattern:
  | tpattern_comma_list { 
      match $1 with
      | _ :: _ :: _ -> `TPAT_type_tuple $1 
      | x :: [] -> x
      | [] -> assert false
    }
  
tpattern:
  | tpattern AS NAME { `TPAT_as ($1,snd $3) }
  | tpat0 { $1 }

tpat0:
  | tpat1 RIGHTARROW tpat0 { `TPAT_function ($1,$3) }
  | tpat1  { $1 }

tpat1:
  | sumpat 
    { 
      match $1 with 
      | [x] -> x 
      | ps -> `TPAT_sum ps 
    }

sumpat:
  | tpat2 PLUS sumpat { $1 :: $3 }
  | tpat2 { [$1] }

tpat2:
  | mulpat 
    { 
      match $1 with 
      | [x] -> x 
      | ps -> `TPAT_tuple ps 
    }

mulpat:
  | tpat3 STAR mulpat { $1 :: $3 }
  | tpat3 { [$1] }

tpat3:
  | NAME tpatlist { `TPAT_name (snd $1, $2) }
  | LPAR tuple_tpattern RPAR { $2 }
  | QUEST NAME { `TPAT_var (snd $2) }
  | QUEST { `TPAT_any }
  | UNDERSCORE { `TPAT_any }
  | INTEGER { let sr,t,v = $1 in `TPAT_unitsum (Big_int.int_of_big_int v) }

tpatlist:
   | LSQB tpattern_comma_list RSQB { $2 }
   | { [] }


type_match_expr:
  | TYPEMATCH expr WITH type_matchings ENDMATCH
  { 
    let t = typecode_of_expr $2 in
    `AST_type_match (rstoken $1 $5, (t, $4))
  }

type_matchings:
  | type_matching type_matchings { $1 :: $2 }
  | type_matching { [$1] }

type_matching:
  /*
  | VBAR tuple_tpattern EQRIGHTARROW expr { $2, typecode_of_expr $4 }
  */
  | VBAR expr EQRIGHTARROW expr { typecode_of_expr $2, typecode_of_expr $4 }

old_expr: 
  | LET pattern EQUAL old_expr IN old_expr 
    { 
      let sr = rsrange (slift $1) (src_of_expr $6) in
      `AST_letin (sr,($2,$4,$6)) 
    }
  | rvalue { $1 }
  
rvalue:
  | lambda { $1 }

lambda:
  | dollar_apply { $1 }

dollar_apply:
  | tuple UNLESS old_expr THEN dollar_apply
    {
      let sr = rsrange (src_of_expr $1) (src_of_expr $5) in
      let revcond = apl $2 "lnot" $3 in
      `AST_cond (sr,(revcond,$1,$5))
    }

  | tuple DOLLAR dollar_apply
    { 
      let sr = rsexpr $1 $3 in 
      `AST_apply (sr, ($1,$3)) 
    }

  | tuple { $1 }

tuple:
  | or_condition tuple_suffix           
    { 
      let lst = $1 :: $2 in
      `AST_tuple ( rslist lst, lst) 
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

/* oring formation is 'psuedo-associative' */
typeexpr: or_condition { $1 }
or_condition:
  | and_condition OR or_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_orlist (sr,$1 :: $3) 
    }
  | and_condition { $1 }

or_list:
  | and_condition OR or_list              { $1 :: $3 }
  | and_condition                         { [$1] }

/* oring formation is 'psuedo-associative' */
and_condition:
  | not_condition AND and_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_andlist (sr,$1 :: $3) 
    }
  | not_condition { $1 }

and_list:
  | not_condition AND and_list              { $1 :: $3 }
  | not_condition                         { [$1] }

notop:
  | NOT {$1,"lnot"}
not_condition:
  | notop not_condition                 { apl (fst $1) (snd $1) $2 }
  | comparison                          { $1 }

chain_cmp_op:
  | ANDEQEQUAL                         { "eq",$1}
  | ANDNOTEQUAL                        { "ne",$1} 
  | ANDLESS                            { "lt",$1}
  | ANDGREATER                         { "gt",$1} 
  | ANDLESSEQUAL                       { "le",$1}
  | ANDGREATEREQUAL                    { "ge",$1}

cmp_item:
  | chain_cmp_op sum                   { $1,$2 }

cmp_item_list:
  | cmp_item cmp_item_list             { $1 :: $2 }
  | cmp_item                           { [$1] }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }
  | ISIN                               { "_isin",$1 } 
    /* hack */

comparison:
  | sum cmp_op sum cmp_item_list
    {
      let dummy_sr:range_srcref = ("",0,0,0,0) in
      let unit_tuple:expr_t = `AST_tuple (dummy_sr,[]) in
      let sr:range_srcref = rsrange (src_of_expr $1) (src_of_expr (snd (list_last $4))) in
      let si i = string_of_int i in
      let nm s = `AST_name (dummy_sr,s,[]) in
      let rec p n lst = 
        match lst with
        | [] -> [] 
        | ((op,opsrc),ex) :: t ->
           `AST_val_decl(slift opsrc,"_t"^si (n+1), dfltvs,None, Some ex)
           ::
           `AST_val_decl
           (
             slift opsrc,
             "_r"^si (n+1),
             dfltvs,
             None,
             Some 
             (
               apl2 opsrc "land" 
               [
                 nm ("_r"^si n);
                 apl2 opsrc op 
                 [
                   nm ("_t"^si n);
                   nm ("_t"^si (n+1))
                 ]
               ]
             )
           )
           :: 
           p (n+1) t
      in 
      let stmts = 
        let n = List.length $4 in
        `AST_val_decl (src_of_expr $3,"_t0",dfltvs,None,Some $3) ::
        `AST_val_decl 
        (
          rsrange (src_of_expr $1) (src_of_expr $3),
          "_r0",dfltvs,
          None,
          Some (apl2 (snd $2) (fst $2) [$1; nm "_t0"])
        ) 
        ::
        p 0 $4
        @
        [`AST_fun_return (sr,`AST_name(sr,"_r"^si n,[]))]
      in
      `AST_apply
      (
        sr,
        (
          `AST_lambda (sr,(dfltvs,[[],None],flx_bool, stmts)),
          unit_tuple
        )
      )
    }
  | sum cmp_op sum                      { apl2 (snd $2) (fst $2) [$1; $3] }
  | as_expr                             { $1 }

as_expr:
  | as_expr AS NAME
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_as (sr,($1,snd $3))
    }
  | setunion { $1 }

setunion:
  | user10 VBARVBAR setunion_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_setunion (sr,$1 :: $3) 
    }
  | user10 { $1 }

setunion_list:
  | user10 VBARVBAR setunion_list { $1 :: $3 }
  | user10 { [$1] }

user10:
  | user10 USER10 setintersection 
    { 
      let sr,op,fn = $2 in
      apl2 sr fn [$1;$3]
    }
  | setintersection { $1 }

setintersection:
  | arrow AMPERAMPER setintersection_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_setintersection (sr,$1 :: $3) 
    }
  | arrow { $1 }

setintersection_list:
  | arrow AMPERAMPER setintersection_list { $1 :: $3 }
  | arrow { [$1] }


arrow:
  | case_literal RIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_arrow (sr,($1,$3)) 
    }
  | case_literal LONGRIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_longarrow (sr,($1,$3)) 
    }
  | case_literal { $1 }

case_literal:
  | CASE INTEGER 
    {
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    } 
  | CASE INTEGER OF sum
    {
      let _,_,v = $2 in 
      `AST_typed_case 
      (
        rsrange (slift $1) (src_of_expr $4),
        Big_int.int_of_big_int v, 
        typecode_of_expr $4
      )
    } 
  | CASE NAME OF sum
    {
      let sr =  rsrange (slift $1) (src_of_expr $4) in
      let s = snd $2 in
      let e = $4 in
      `AST_variant (sr,(s,e))
    } 

  | bor { $1 }

bor:
  | bor SLOSHVBAR bxor { apl2 $2 "bor" [$1;$3] }
  | bxor { $1 }

bxor:
  | bxor SLOSHCIRCUMFLEX band { apl2 $2 "bxor" [$1;$3] }
  | band { $1 }

band:
  | band SLOSHAMPER shift { apl2 $2 "band" [$1;$3] }
  | shift { $1 }

shift:
  | shift LEFTSHIFT sum { apl2 $2 "shl" [$1;$3] }
  | shift RIGHTSHIFT sum { apl2 $2 "shr" [$1;$3] }
  | sum { $1 }

/* sum formation is 'psuedo-associative' */
sum:
  | subtraction PLUS sum_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_sum (sr,$1 :: $3) 
    }
  | subtraction { $1 }

sum_list:
  | subtraction PLUS sum_list { $1 :: $3 }
  | subtraction { [$1] }

subtraction:
  | subtraction MINUS product { apl2 $2 "sub" [$1; $3] }
  | product { $1 }

/* product formation is 'psuedo-associative' */
product:
  | term STAR product_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_product (sr,$1 :: $3) 
    }
  | term                                { $1 }
product_list:
  | term STAR product_list              { $1 :: $3 }
  | term                                { [$1] }


/* division is left associative: note higher precedence
   the product, so that

   a * b/c * d -> a * (b/c) * d
*/
term:
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
  | LVAL power
    { 
      `AST_lvalue
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  /*
  | HASH power  { apl $1 "len" $2 }
  */
  | EXCLAMATION power  { apl $1 "excl" $2 }
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | TILDE power { apl $1 "compl" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | superscript STARSTAR prefixed      { apl2 $2 "pow" [$1; $3] }
  | superscript { $1 }

superscript:
  | superscript CIRCUMFLEX refr 
    { 
      let sr = rsrange (src_of_expr $1) (src_of_expr $3) in
      `AST_superscript (sr, ($1, $3))
    }

  | refr { $1 }
refr:
  | AMPER refr
    { 
      `AST_ref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | STAR refr { apl $1 "deref" $2 }
  | DEREF refr
    { 
      `AST_deref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | NEW refr 
    { 
      `AST_new
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }

  | application { $1 }

/* applications is left associative */
application:
  | application coercion
    { 
      `AST_apply (rsexpr $1 $2, ($1, $2)) 
    }
/*
  | MAP coercion coercion
    {
      `AST_map (rsrange (slift $1) (src_of_expr $3), $2, $3)
    }
*/
  | CASENO coercion { 
      let sr = rsrange (slift $1) (src_of_expr $2) in
      `AST_case_index (sr,$2) 
    }
    
  | coercion { $1 }


coercion:
  | coercion COLON factor          
    { 
      `AST_coercion (slift $2, ($1, typecode_of_expr $3)) 
    }
  | suffixed_name                  { ($1:>expr_t) }
  | factor                         { $1 }


factor:
  | hash_name                        { ($1:>expr_t) }
  | factor DOT LSQB old_expr RSQB          { apl2 $3 "subscript" [$1; $4] }
  | factor DOT LSQB old_expr TO old_expr RSQB  { apl2 $3 "substring" [$1; $4; $6] }
  | factor DOT LSQB old_expr TO RSQB       { apl2 $3 "copyfrom" [$1; $4] }
  | factor DOT LSQB TO old_expr RSQB       { apl2 $3 "copyto" [$1; $5] } 
  | factor DOT simple_name_parts       
    { 
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      `AST_dot (sr, ($1, `AST_name (sr,name,ts))) 
    }
  | factor DOTRIGHTARROW simple_name_parts       
    { 
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      let x = apl $2 "deref" $1 in
      `AST_dot (sr, (x, `AST_name (sr,name,ts))) 
    }
  | factor DOT LPAR INTEGER RPAR
    { 
      match $4 with
      | (sr,t,v) ->
        let n = 
          try Big_int.int_of_big_int v 
          with _ -> 
            failwith 
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^ 
              short_string_of_src (slift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (slift $5) in
          `AST_get_n (sr, (n,$1)) 
    }

hash_name:
  | HASH hash_name { `AST_lift ((slift $1), $2) }
  | the_name { $1 }

the_name:
  | NOEXPAND qualified_name
    { 
      let e = ($2:>expr_t) in
      let sr = src_of_expr e in
      let sr = rsrange (slift $1) sr in
      `AST_noexpand (sr,e) 
    }
  | THE qualified_name
  { 
    let sr = src_of_expr $2 in 
    let sr = rsrange (slift $1) sr in
    let qn = qualified_name_of_expr $2 in
    (`AST_the (sr,qn))
  }
  | qualified_name { $1 }
  | QUEST NAME { `AST_patvar (rstoken $1 (fst $2), snd $2) }
  | atom { $1 }

qualified_name:
  | qualified_name COLONCOLON simple_name_parts
    { 
      match $3 with sr,name,ts ->
      let sr = rsrange (src_of_expr $1) sr in
      `AST_lookup (sr,($1, name, ts))
    }

  | simple_name_parts  
    { 
      match $1 with sr,name,ts -> 
      (`AST_name (sr,name,ts):>expr_t) 
    }

elif:
  | ELIF old_expr THEN old_expr { $2,$4 }

elifs:
  | elifs elif { $2 :: $1 }
  | elif { [$1] }

else_part:
  | elifs ELSE old_expr 
    {
      List.fold_left (* actually a right fold cause list is reversed *)
      (fun result (cond,thn) ->
        let sr = rsrange (src_of_expr cond) (src_of_expr result) in
        `AST_cond 
        (
          sr,
          (
            cond,
            thn,
            result
          )
        )
      )
      $3 $1
    }
  | ELSE old_expr { $2 }

cond:
  | IF old_expr THEN old_expr else_part ENDIF
    { 
      `AST_cond (rstoken $1 $6,($2,$4,$5))
    }

expr_code_prefix:
  | CODE LSQB old_expr RSQB 
    {
     $1,
     typecode_of_expr $3
    }



atom:
  | UNDERSCORE { `AST_patany (slift $1) }
  | CALLBACK LSQB qualified_name RSQB
    { 
      let sr = rstoken $1 $4 in
      let qn = qualified_name_of_expr $3 in
      `AST_callback (sr,qn)
    }
  
  | DOTDOTDOT { `AST_ellipsis (slift $1) }

  | type_match_expr { $1 }
  | expr_code_prefix NAME
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | expr_code_prefix STRING
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | LSQBAR old_expr RSQBAR
    {
      let sr = rstoken $1 $3 in
      match $2 with
      | `AST_tuple (_,ls) -> `AST_arrayof (sr,ls)
      | x -> `AST_arrayof (sr,[x])
    }

  | LBRACE old_expr RBRACE     
    { 
      let sr = rstoken $1 $3 in
      `AST_lambda 
      (
        sr,
        (
          dfltvs,
          [[],None],
          `TYP_none,
          [`AST_fun_return (sr,$2)]
        ) 
      )
    }
  | match_expr { $1 }
  | typecase { $1 }
  | compound            
    {
      let sr, stmts = $1 in
      `AST_lambda 
      (
        sr,
        (dfltvs,[[],None], `TYP_none, stmts)
      )
    
    }
  | LPAR old_expr RPAR      { $2 }
  | LPAR RPAR           { `AST_tuple (rstoken $1 $2,[]) }
  | literal             { $1 }
  | cond                { $1 }
  | FSTRING             
    { 
      let sr,s = $1 in 
      let sr = slift sr in 
      `AST_vsprintf (sr,s) 
    }
  | QSTRING             
    { 
      let sr,s = $1 in 
      let sr = slift sr in 
      `AST_interpolate (sr,s) 
    }
    
  | USERLB old_expr USERRB  
    {
      let sr1,fnmap,lsym =$1 and sr2,rsym = $3 in
      let sr = rstoken sr1 sr2 in
      try
        let fn = List.assoc rsym fnmap in
        apl2 (fst $3) fn [$2]
      with Not_found ->
        Flx_exceptions.clierr sr "Mismatched brackets"
    }

literal:
  | integer_literal { $1 }
  | string_literal { $1 }
  | float_literal { $1 }
  | TRUE { `AST_typed_case (slift $1, 1, `TYP_unitsum 2) }
  | FALSE { `AST_typed_case (slift $1, 1, `TYP_unitsum 2) }

integer_literal:
  | INTEGER 
    { let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_int (t,v)) 
    }

float_literal:
  | FLOAT   
    { 
      let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_float (t,v)) 
    }

string_literal:    
  | STRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_string s) 
    }

  | WSTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_wstring s) 
    }

  | USTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_ustring s) 
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_cstring s) 
    }

simple_name_parts:
  | NAME LSQB old_expr RSQB  
    { 
      rsrange (slift (fst $1)) (slift $4),
      snd $1,
      match typecode_of_expr $3 with
      | `TYP_type_tuple ls -> ls
      | x -> [x]
    }

  | identifier { $1 }

identifier:
  | NAME 
    { 
      slift (fst $1), 
      snd $1,
      []
    }

suffixed_name:
  | qualified_name OF factor
    { 
      `AST_suffix
      (
        rsrange (src_of_expr $1) (src_of_expr $3),
        (qualified_name_of_expr $1, typecode_of_expr $3)
      )
    }

epsilon: | {()}

@head(1,'Parser object')
@h = tangler('src/flx_parse_ctrl.ml')
@select(h)

open Flx_ast
open Flx_exceptions
open Flx_parse

let dyphack (ls : ( 'a * Dyp.priority) list) : 'a =
  match ls with
  | [x,_] -> x
  | _ -> failwith "Dypgen parser failed"

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
  expand_expr
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
      expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
  let hash_include_files, tokens = match tokens with
    | HASH_INCLUDE_FILES fs :: t -> fs,t
    | _ -> assert false
  in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError ("Failure \""^s^"\" Parsing File"))
        end
      | Flx_exceptions.ClientError _ 
      | Flx_exceptions.ClientError2 _ 
      | Flx_exceptions.ClientErrorn _ as x  ->
        begin
          toker#report_syntax_error;
          raise x
        end

      | Flx_exceptions.RDP_match_fail (sr1,sr2,s) as x  ->
        begin
          toker#report_syntax_error;
          clierr2 sr1 sr2 ("User Syntax Parse Error " ^ s)
        end

      | Dyp.Bad_constructor (nt,ctor1, ctor2) ->
          toker#report_syntax_error;
          let s = "Bad constructor '" ^ ctor1 ^ "' and '" ^ ctor2 ^ "' for nonterminal '" ^ nt ^"'" in
          print_endline s;
          failwith s

      | x -> 
        begin
          toker#report_syntax_error;
          print_endline (Printexc.to_string x);
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
      in hash_include_files, parse_tree
    end

let parse_string (data : string) (filename : string) expand_expr = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/flx_parse_ctrl.mli')
@select(h)
open Flx_ast

val parse_file : 
  string -> (* filenames *)
  string ->
  string list ->
  (string -> expr_t -> expr_t) ->
  string list * compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  (string -> expr_t -> expr_t) ->
  compilation_unit_t

@head(1,'Parser test harness')
@h = tangler('src/flxp.ml')
@select(h)
open Flx_mtypes2
open Flx_types
open Flx_version
open Flx_flxopt
open Flx_getopt
;;

let print_help () = print_options(); exit(0)
;;

let run() =
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;

  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" in

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline ("Parsing " ^ input_file_name);
    print_endline "---------------------------------------";
  end
  ;

  let _,parse_tree = 
    Flx_parse_ctrl.parse_file 
    input_file_name
    (Filename.dirname input_file_name)
    compiler_options.include_dirs
    Flx_macro.expand_expression
  in
    print_endline (Flx_print.string_of_compilation_unit parse_tree);

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline "PARSE OK";
    print_endline "---------------------------------------";
  end
  ;

  flush stdout;

in
  run()
;;

