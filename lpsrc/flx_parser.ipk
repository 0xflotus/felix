@execfile('config'+os.sep+'flx_data.py')

@head(1,'Parser')
@h = tangler('src/flx_parse.dyp','data')

@# define meta operators:
@#  aster: t*
@#  plus:  t+
@#  quest: t?
@# commalistof:  (t (,t)*)?
@def plus(s):
  for line in [
    s + "_plus:",
    "  | " + s + " " + s+ "_plus { $1 :: $2 }",
    "  | " + s + " {[$1]}",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_plus: " + s + "+\n")
  # end_bold()
@def aster(s):
  for line in [
    s + "_aster:",
    "  | " + s + " " + s+ "_aster { $1 :: $2 }",
    "  | { [] }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_aster: " + s + "*\n")
  # end_bold()
@def opt(s):
  for line in [
    s+"_opt:",
    "  | " + s + " { Some $1 }",
    "  | { None }"
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_opt: " + s + "?\n")
  # end_bold()

@def commalistof(s): # possibly empty comma separated list
  for line in [
    s+"_comma_list:",
    "  | " + s + " COMMA " + s+"_comma_list { $1 :: $3 }",
    "  | " + s + " { [$1] }",
    "  | { [] }",
  ]: tangle (line)
  # begin_bold()
  # weave("    " + s + "_comma_list: " + s + " (COMMA " + s+")*\n")
  # end_bold()

@head(2,'Header')
@select(h)
{

(* parser header *)
exception EndOfInput
open Flx_ast
open Flx_mtypes1
open Flx_typing
open Flx_typing2
open Flx_srcref
open Flx_print
open Flx_charset
open Flx_exceptions
open Flx_util
open Ocs_types
open Sex_types
open Dyp

let map = List.map
let map2 = List.map2
let hd = List.hd
let tl = List.tl
let fold_left = List.fold_left
let rev = List.rev 
let mem = List.mem
let length = List.length

module Drules = Map.Make(struct
  type t = string
  let compare = compare
end)
let global_data = ref Drules.empty


let list_last lst = List.hd (List.rev lst)
let generated = ("Generated by Parser",0,0,0,0)
let parse_error (s : string) = 
  raise (Flx_exceptions.ParseError "Error parsing input")

(* model infix operator as function call *)
let apl2 (sri:srcref) (fn : string) (tup:expr_t list) = 
  let sr = rslist tup in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri,fn,[]), 
      `AST_tuple (sr,tup)
    )
  )

(* model prefix operator as function call *)
let apl (sri:srcref) (fn : string) (arg:expr_t):expr_t = 
  let sr = src_of_expr arg in
  `AST_apply 
  (
    sr, 
    (
      `AST_name (slift sri, fn,[]),
      arg
    )
  )

(* model unary operator as procedure call *)
let call1 (op:string) (sr:range_srcref) (sri:srcref) l = 
  `AST_call 
  (
    sr, `AST_name (slift sri, op,[]), l
  )

(* model unary operator as procedure call *)
let call2 (op:string) (sr:range_srcref) (sri:srcref) l r = 
  `AST_call 
  (
    sr,
    `AST_name (slift sri, op,[]),
    `AST_tuple(sr,[l;r])
  )

let mkcurry sr name vs (args:params_t list) return_type kind body =
  `AST_curry (sr,name,vs,args,return_type,kind,body)

let cal_funkind adjs fk =
  match fk with
  | sr,`CFunction -> sr,`CFunction
  | sr,`Generator -> sr,`Generator
  | sr,`Function -> match adjs with
  | [] -> sr,`Function
  | h :: t -> sr,snd h
  
(* handle curried type functions *)
let mktypefun sr name vs (args: (string * typecode_t) list list) return_type body =
  let argtyp t = match t with
    | [] -> failwith "Lambda abstraction requires nonunit parameter"
    | [x] -> x
    | x -> `TYP_type_tuple x
  in
  let body = 
    let p = ref (List.rev args) in
    let r = ref return_type in
    let b = ref body in
    while !p <> [] do
      let arg = List.hd !p in
      p := List.tl !p;
      b := `TYP_typefun (arg, !r, !b);
      r := `TYP_function(argtyp (List.map snd (arg)),!r)
    done;
    !b
  in
  `AST_type_alias
  (
    sr,
    name,
    vs,
    body
  )

let dfltvs = 
  [],
  {
    raw_type_constraint=`TYP_tuple [];
    raw_typeclass_reqs=[]
  } 

@expr_nts = [
  "expr",
  "dollar_apply",
  "tuple",
  "or_condition",
  "and_confition",
  "nor_condition",
  "comparison",
  "as_expr",
  "setunion",
  "setintersection",
  "arrow",
  "bor",
  "bxor",
  "band",
  "shift",
  "sum",
  "subtraction",
  "product",
  "term",
  "prefixed",
  "power",
  "superscript",
  "refr",
  "coercion",
  "factor",
  "hash_name",
  "the_name",
  "qualified_name",
  "atom",
  ]
@#

let scheme_eval env (s:sval):sval =
  let term = ref None in
  let get_port = function 
    | Ocs_types.Sport p -> p
    | _ -> failwith "expected port"
  in
  let th = Ocs_top.make_thread () in
  let outp = get_port th.Ocs_types.th_stdout in
  begin try
    let c = Ocs_compile.compile env s in
    print_endline "COMPILED";
    Ocs_eval.eval th (function 
      | Ocs_types.Sunspec -> failwith "UNSPECIFIED" 
      | r -> 
         print_endline "EVALUATED";
         Ocs_print.print outp false r;
         Ocs_port.puts outp "\n";
         Ocs_port.flush outp;
         term := Some r
    ) c
  with 
    | Ocs_error.Error err 
    | Ocs_error.ErrorL (_,err) 
      ->
        failwith ("Error " ^ err)
  end
  ;
  match !term with
  | None -> failwith "Scheme term not returned!"
  | Some r -> r

let scheme_compile_eval env (s:string):sval = 
  let inp = Ocs_port.string_input_port s in
  let lex = Ocs_lex.make_lexer inp "" in
  match Ocs_read.read_expr lex with
  | Ocs_types.Seof -> print_endline "END OF FILE?"; Snull
  | v -> scheme_eval env v


let define_scheme dyp name rhs (scm:string) =
  let lhs = dyp.add_nt name "Obj_sexpr" in
  let f o =
    match o with
      | NAME (sr,s) -> 
          Dyp.Non_ter ((dyp.add_nt s "Obj_sexpr"),Dyp.No_priority)
      | s -> 
        let name = Dyp_symbols.str_token s in
        Dyp.Ter (Dyp_symbols.get_token_name s)
  in
  let rule  = lhs,(List.map f rhs),Dyp_priority_data.default_priority in
  print_endline ("A Rule for " ^ name ^ " defined, scm="^scm);
  let action = fun _ avl ->
    print_endline ("Reducing Rule for " ^ name ^ ", scm="^scm);
    let dummy = ("dummy",0,0,0,0) in
    let srr = ref dummy in
    let setsr sr = if dummy = !srr then srr := slift sr in
    let env = Ocs_top.make_env () in
    let rec aux objs syms n = match objs, syms with
    | [],[] -> ()
    | [],_ | _,[] -> assert false
    | h1::t1,h2::t2 -> 
      match h1,h2 with
      | _,`Obj_sexpr s 
        ->
        let v1:Ocs_types.sval = Ocs_sym.get_symbol ("_" ^ string_of_int n) in
        let g1:Ocs_types.vbind = Vglob { g_sym=v1; g_val = s } in
        Ocs_env.bind_name env v1 g1;
        aux t1 t2 (n+1)
      | _ -> aux t1 t2 (n+1)
    in
    aux rhs avl 1;
    let r = scheme_compile_eval env scm in
    `Obj_sexpr r
  in
  rule,action


let define_statement dyp name rhs (statement:statement_t) =
  let lhs,_ = dyp.find_nt name in
  let f o =
    match o with
      | NAME (sr,s) -> 
        begin try
          Dyp.Non_ter (fst (dyp.find_nt s),Dyp.No_priority)
        with
        | Not_found ->
          print_endline ("[define_statement] User Syntax: Cannot find non-terminal " ^ s);
          failwith ("[define_statement] User syntax: Missing nonterminal " ^ s)
        end
      | s -> 
        (*
        let name = Flx_prelex.name_of_token s in
        *)
        let name = Dyp_symbols.str_token s in
        (*
        print_endline ("Processing keyword " ^ name);
        *)
        Dyp.Ter (Dyp_symbols.get_token_name s)
  in
  let rule  = lhs,(List.map f rhs),Dyp_priority_data.default_priority in
  let truncs e = 
    let s = string_of_expr e in
    let n = String.length s in
    if n > 20 then String.sub s 0 20 else s
  in
  let action = fun _ avl ->
    let dummy = ("dummy",0,0,0,0) in
    let srr = ref dummy in
    let setsr sr = if dummy = !srr then srr := slift sr in
    let rec aux objs syms args = match objs, syms with
    | [],[] -> rev args
    | [],_ | _,[] -> assert false
    | h1::t1,h2::t2 -> 
      match h1,h2 with
      | USER_KEYWORD (_,s1),`Obj_USER_KEYWORD (sr,s2) ->
        setsr sr;
        if s1 <> s2 then (
          (*
          print_endline ("Keyword mismatch req=" ^ s1 ^ ", got=" ^ s2);
          *)
          raise Dyp.Giveup 
        )
        else
        aux t1 t2 (`Keyword_term s1::args)

      | USER10 (_,s1,_),`Obj_USER10 (sr,s2,_) ->
        setsr sr;
        if s1 <> s2 then (
          (*
          print_endline ("Keyword mismatch req=" ^ s1 ^ ", got=" ^ s2);
          *)
          raise Dyp.Giveup 
        )
        else
        aux t1 t2 (`Keyword_term s1::args)

      | NAME (_,"statements"),`Obj_statements sts -> 
        (*
        print_endline "Matched statements";
        List.iter
        (fun st -> print_endline (string_of_statement 0 st))
        sts
        ;
        *)
        aux t1 t2 (`Statements_term sts:: args)

      | NAME (_,"statement"),`Obj_statement st -> 
        (*
        print_endline "Matched statement";
        print_endline (string_of_statement 0 st);
        *)
        aux t1 t2 (`Statement_term st::args)

      | NAME (_,"expr"),`Obj_expr e -> 
        (*
        print_endline ("Matched expr " ^ string_of_expr e);
        *)
        aux t1 t2 (`Expression_term e::args)

      | NAME (_,"string_literal"),`Obj_string_literal e -> 
        (*
        print_endline ("Matched string_literal " ^ truncs e);
        *)
        aux t1 t2 (`Expression_term e::args)

      | NAME (_,"identifier"),`Obj_identifier (_,name,[]) -> 
        (*
        print_endline ("Matched ident " ^ name);
        *)
        aux t1 t2 (`Identifier_term name::args)
      
      | NAME (_,s),_ ->
        print_endline ("Syntax: Unknown symbol " ^ s);
        failwith ("Syntax: Unknown Symbol " ^ s)

@for s,t in flx_keywords:
  if t != "IDENT":
    tangle("      | " +t+ ' _,`Obj_'+t+' _ -> aux t1 t2 (`Keyword_term "'+t+'" :: args)')
@for t,s in flx_syms:
  tangle("      | " +t+ ' _,`Obj_'+t+' _ -> aux t1 t2 (`Keyword_term "'+t+'" :: args)')
@#
      | x,_ -> 
        print_endline ("Unknown symbol " ^ Dyp_symbols.str_token x);
        failwith ("Unknown symbol " ^ Dyp_symbols.str_token x);

    in
    let args = aux rhs avl [] in
    let sname = 
      let rec aux rhs out = match rhs with
      | [] -> String.concat " " (rev out)
      | USER_KEYWORD (_,s)::t -> aux t (s::out)
      | NAME (_,s)::t -> aux t (("<"^s^">")::out)
      | h::t -> aux t (Dyp_symbols.str_token h::out)
      in aux rhs []
    in
    let ast_term = `Apply_term (`Statement_term statement, args) in
    `Obj_statement (`AST_user_statement (!srr,"[usersyntax "^sname^"]",ast_term))
  in
  rule,action

let define_expr dyp name rhs (expr:expr_t) =
  let lhs,_ = dyp.find_nt name in
  (*
  print_endline ("DEFINE "^name^" = " ^ string_of_expr expr);
  *)
  let f o =
    match o with
      | NAME (sr,s) -> 
        begin try
          Dyp.Non_ter (fst (dyp.find_nt s),Dyp.No_priority)
        with
        | Not_found ->
          print_endline ("[define_expr] User Syntax: Cannot find non-terminal " ^ s);
          failwith ("[define_expr] User syntax: Missing nonterminal " ^ s)
        end
      | s -> 
        (*
        let name = Flx_prelex.name_of_token s in
        *)
        let name = Dyp_symbols.str_token s in
        (*
        print_endline ("Processing keyword " ^ name);
        *)
        Dyp.Ter (Dyp_symbols.get_token_name s)
  in
  let rule  = lhs,(List.map f rhs),Dyp_priority_data.default_priority in
  let truncs e = 
    let s = string_of_expr e in
    let n = String.length s in
    if n > 20 then String.sub s 0 20 else s
  in
  let action = fun _ avl ->
    (*
    print_endline ("REDUCING "^name^" = " ^ string_of_expr expr);
    *)
    let dummy = ("dummy",0,0,0,0) in
    let srr = ref dummy in
    let setsr sr = if dummy = !srr then srr := slift sr in
    let rec aux objs syms args = match objs, syms with
    | [],[] -> rev args
    | [],_ | _,[] -> assert false
    | h1::t1,h2::t2 -> 
      match h1,h2 with
      | USER_KEYWORD (_,s1),`Obj_USER_KEYWORD (sr,s2) ->
        setsr sr;
        if s1 <> s2 then (
          (*
          print_endline "keyword mismatch";
          *)
          raise Dyp.Giveup 
        )
        else
        aux t1 t2 (`Keyword_term s1::args)

      | USER10 (_,s1,_),`Obj_USER10 (sr,s2,_) ->
        setsr sr;
        if s1 <> s2 then (
          (*
          print_endline "keyword mismatch";
          *)
          raise Dyp.Giveup 
        )
        else
        aux t1 t2 (`Keyword_term s1::args)


      | NAME (_,"statements"),`Obj_statements sts -> 
        (*
        print_endline "Matched statements";
        List.iter
        (fun st -> print_endline (string_of_statement 0 st))
        sts
        ;
        *)
        aux t1 t2 (`Statements_term sts:: args)

      | NAME (_,"statement"),`Obj_statement st -> 
        (*
        print_endline "Matched statement";
        print_endline (string_of_statement 0 st);
        *)
        aux t1 t2 (`Statement_term st::args)

@for i in expr_nts: 
  tangle('      | NAME (_,"'+i+'"),obj')
@#
       -> 
         let e = match obj with
@for i in expr_nts: 
  tangle('        | `Obj_'+i+' e -> e')
@#
        | _ -> failwith "Expression nonterminal has wrong type"
        in
        (*
        print_endline ("Matched expr " ^ string_of_expr e);
        *)
        aux t1 t2 (`Expression_term e::args)

      | NAME (_,"string_literal"),`Obj_string_literal e -> 
        (*
        print_endline ("Matched string_literal " ^ truncs e);
        *)
        aux t1 t2 (`Expression_term e::args)

      | NAME (_,"identifier"),`Obj_identifier (_,name,[]) -> 
        (*
        print_endline ("Matched ident " ^ name);
        *)
        aux t1 t2 (`Identifier_term name::args)
      
      (* Unknown nonterminal returning expression *)
      | NAME (_,s),`Obj_expr e ->
        aux t1 t2 (`Expression_term e::args)

      | NAME (_,s),_ ->
        print_endline ("Syntax: Unknown symbol " ^ s);
        failwith ("Syntax: Unknown Symbol " ^ s)

@for s,t in flx_keywords:
  if t != "IDENT":
    tangle("      | " +t+ ' _,`Obj_'+t+' _ -> aux t1 t2 (`Keyword_term "'+t+'" :: args)')
@for t,s in flx_syms:
  tangle("      | " +t+ ' _,`Obj_'+t+' _ -> aux t1 t2 (`Keyword_term "'+t+'" :: args)')
@#
      | x,_ -> 
        print_endline ("Unknown symbol " ^ Dyp_symbols.str_token x);
        failwith ("Unknown symbol " ^ Dyp_symbols.str_token x);

    in
    let args = aux rhs avl [] in
    let ast_term = `Apply_term (`Expression_term expr, args) in
    let e = `AST_user_expr (!srr,"unknownusersyntax",ast_term) in
    match name with

@for i in expr_nts: 
  tangle('    | "'+i+'"-> `Obj_'+i+' e')
@# 
    | _ -> `Obj_expr e
  in
  rule,action

let add_rule dyp dssl rule =
  let m = dyp.global_data in
  let rules = try Drules.find dssl m with Not_found -> [] in
  let m = Drules.add dssl (rule :: rules) m in
  dyp.global_data <- m

let do_dyp_rule dyp (dssl,(name,rhs,stmt,sr)) =
     (*
     print_endline ("PROCESSING DEFINITION " ^ name ^ ":= " ^
     catmap " " (function 
     | NAME (_,s) -> "<"^s^">"
     | USER_KEYWORD (_,s) -> s
     | x -> Dyp_symbols.str_token x
     ) rhs ^ 
     "=>#\n" ^
     string_of_statement 0 stmt
     );
     *)
     (* WE should use a distinct syntax for adding new nonterms .. *)
     ignore(dyp.add_nt name ("Obj_" ^ name));
     begin match name with
     | "statement" ->
       let rule =(define_statement dyp name rhs stmt) in
       dyp.add_rules <- rule :: dyp.add_rules;

@for i in expr_nts: tangle('    | "' + i + '"')
      ->
        begin match stmt with
        | `AST_call (sr, proc, arg) -> 
          let expr = match arg with
          | `AST_tuple (_,[]) -> proc
          | _ -> `AST_apply (sr,(proc,arg))
          in
          let rule = define_expr dyp name rhs expr in
          dyp.add_rules <- rule :: dyp.add_rules;
        | _ ->
          let s = 
            "Syntax extension: expression non-terminal " ^ name ^
            " requires action to be expression!"
          in
          print_endline s;
          clierr sr s
        end

      | _ ->
        (*
        print_endline ("Syntax extension: unknown non-terminal " ^ name);
        print_endline ("Syntax extension: ASSUME EXPRESSION " ^ name);
        *)
        begin match stmt with
        | `AST_scheme_string (sr,s) ->
          let rule = define_scheme dyp name rhs s in
          dyp.add_rules <- rule :: dyp.add_rules

        | `AST_call (sr, proc, arg) -> 
          let expr = match arg with
          | `AST_tuple (_,[]) -> proc
          | _ -> `AST_apply (sr,(proc,arg))
          in
          let rule = define_expr dyp name rhs expr in
          dyp.add_rules <- rule :: dyp.add_rules;
        | _ ->
          let s = 
            "Syntax extension: expression non-terminal " ^ name ^
            " requires action to be expression!"
          in
          print_endline s;
          clierr sr s
        end


        (*
        failwith ("Syntax extension: unknown non-terminal " ^ name);
        *)
      end

let ocs2flx sr r = 
  let sex = Ocs2sex.ocs2sex r in
  print_endline "OCS scheme term converted to s-expression:";
  Sex_print.sex_print sex;
  let fresh = ref 1 in
  let env = [] in
  let flx = Flx_sex2flx.xstatement_t sr fresh env sex in
  print_endline "s-expression converted to Felix statement!";
  print_endline (string_of_statement 0 flx);
  flx


}

@head(2,'Tokens')
@select(h)
/* special */
%token <(Flx_ast.srcref * string)> ERRORTOKEN
%token ENDMARKER

/* whitespace and comments */
%token NEWLINE 
%token SLOSH
%token <(string)> COMMENT 
%token <(string)> COMMENT_NEWLINE
%token <(int)> WHITE 

/* literals */
%token <(Flx_ast.srcref * string)> NAME
%token <(Flx_ast.srcref * string * Flx_ast.bigint)> INTEGER
%token <(Flx_ast.srcref * string * string )> FLOAT
%token <(Flx_ast.srcref * string)> STRING
%token <(Flx_ast.srcref * string)> CSTRING
%token <(Flx_ast.srcref * string)> FSTRING
%token <(Flx_ast.srcref * string)> QSTRING
%token <(Flx_ast.srcref * string)> WSTRING
%token <(Flx_ast.srcref * string)> USTRING
%token <(Flx_ast.srcref * string)> USER_KEYWORD
%token <(string list)> HASH_INCLUDE_FILES
%token <(token list)> TOKEN_LIST
%token DUMMY

/* this has to be defined, but is never seen */
%token <(Flx_ast.srcref * string * (token list * Flx_ast.ast_term_t) list * (string, (token list * Flx_ast.ast_term_t) list) Hashtbl.t )> USER_STATEMENT_KEYWORD

/* the tokeniser replaces the above with this one */
%token <(Flx_ast.srcref * string * (unit -> Flx_ast.statement_t) )> USER_STATEMENT_DRIVER

/* user defined symbols */
%token <(Flx_ast.srcref * string * string)> USER10
%token <(Flx_ast.srcref * (string * string) list * string)> USERLB
%token <(Flx_ast.srcref * string )> USERRB

@for k,v in flx_1_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for k,v in flx_2_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for k,v in flx_3_char_syms:
  tangle("%token <(Flx_ast.srcref)> " + k,inhibit_sref=1)

@for n,t in flx_keywords+flx_parser_keywords:
  tangle("%token <(Flx_ast.srcref)> " + t,inhibit_sref=1)

%type <Ocs_types.sval> sname sliteral satom sexpr
%constructor Obj_sexpr %for sterm sexpr satom sname sliteral sinteger sfloating sintegral sstring

%start <(Flx_ast.compilation_unit_t)> compilation_unit
%start <(Flx_ast.statement_t list * token)> statementsx
%start <(Flx_ast.statement_t list)> statements
%start <(Flx_ast.statement_t)> statement
%start <(Flx_ast.expr_t)> expression
%start <(Flx_ast.expr_t * token)> exprx
%start <(Flx_ast.expr_t)> expr
%start <(unit)> semi

%%

@head(2,'Compilation Unit')
@select(h)
semi:
  | SEMI {()}

exprx:
  expr expr_terminator { $1,$2 }

expr_terminator:
  | SEMI { SEMI $1 }
  | USER_KEYWORD { USER_KEYWORD $1 }
  | VBAR { VBAR $1 }
  | ENDMARKER { ENDMARKER }

@for n,t in flx_expr_terminator_keywords:
  tangle("  | "  + t + " { " + t + " $1 }",inhibit_sref=1)

statementsx:
  | statements statements_terminator { $1, $2 }

statements_terminator:
  | VBAR { VBAR $1 }
  | DONE { DONE $1 }
  | USER_KEYWORD { USER_KEYWORD $1 }
  | ENDMARKER { ENDMARKER }
 
compilation_unit:  
  | statements ENDMARKER { $1 }

expression:  
  | expr ENDMARKER { $1 }

statements:
 | statement statements { $1 :: $2 }
 | { [] }

@doc()
A compilation unit is just a sequence of statements.
Executable statements (or parts thereof) form the initialisation
code of the compilation unit.

@head(2,'Statement')
@select(h)
statement:
  | binding_definition { (* print_endline "Reducing binding_definition"; *) $1 
    }
  | declarative { (* print_endline "Reducing declarative"; *) $1 }
  | executable { (* print_endline ("Reducing executable " ^ Flx_print.string_of_statement 0 $1); *) $1 }
  | inclusion { (* print_endline "Reducing inclusion"; *) $1 }
  | directive { (* print_endline ("Reducing directive " ^ Flx_print.string_of_statement 0 $1); *) $1 }
  | publish { (* print_endline "Reducing publish"; *) $1}
  | comment { (* print_endline "Reducing comment"; *) $1 }
  | null_statement { (* print_endline "Reducing null_statement"; *) $1 }
  | user_statement { (* print_endline "Reducing user_statement"; *) $1 }
  | cparse { (* print_endline "Reducing cparse "; *) $1 }
  | sstatement { $1 }
  | OPEN SYNTAX basic_name_comma_list SEMI
    {
      print_endline "Opening syntax extensions";
      let sr = rstoken $1 $4 in
      let dssls = map snd $3 in
      let m = dyp.global_data in
      let rules =
        fold_left (fun acc dssl ->
        let rules = 
          try Drules.find dssl m
          with Not_found -> failwith ("Can't open syntax " ^ dssl)
        in 
        let rules = map (fun x -> dssl,x) rules in
        acc @ rules
        )
        []
        dssls
      in
      List.iter (do_dyp_rule dyp) rules;
      `AST_nop (sr, cat "," dssls)
    }

  | SYNTAX NAME LBRACE dyprods RBRACE
    {
      let sr = rstoken $1 $5 in
      let dssl = snd $2 in
      List.iter (add_rule dyp dssl) $4;
      `AST_nop (sr, dssl)
    }

 dyprod:
   | NAME COLONEQUAL rhs PARSE_ACTION statement
     {
       let name = snd $1 in
       let rhs = $3 in
       let stmt:statement_t = $5 in
       let sr = rstoken (fst $1) $4 in
       name,rhs,stmt,sr
     }

   | NAME COLONEQUAL rhs PARSE_ACTION STRING SEMI
     {
       let name = snd $1 in
       let rhs = $3 in
       let sr = rstoken (fst $1) $6 in
       let stmt:statement_t = `AST_scheme_string (sr,snd $5) in
       let sr = rstoken (fst $1) $4 in
       name,rhs,stmt,sr
     }
  
 dyprods:
   | dyprod dyprods { $1 :: $2 }
   | { [] }

 rhs:
  | rhs_term { [$1] }
  | rhs_term rhs { $1 :: $2 }

 rhs_term :
  | NAME { let sr,s = $1 in NAME (sr,s) } /* arbitrary nonterminal */
  | IDENT { NAME ($1,"identifier") }
  | USER_KEYWORD { USER_KEYWORD $1 } /* user terminal */
  | USER10 { USER10 $1 } /* user terminal */
@for s,t in flx_keywords:
  if t != "IDENT":
    tangle("  | " +t+ " { " + t + " $1 }")
@for t,s in flx_syms:
  if t != "PARSE_ACTION":
    tangle("  | " +t+ " { " + t + " $1 }")

sstatement:
  | SCHEME LBRACE sterm RBRACE { let sr = rstoken $1 $4 in ocs2flx sr $3 }

sterm:
  | CALL sexpr SEMI { 
    let call = Ocs_sym.get_symbol "ast_call" in 
    let f,a =
      let a = $2 in
      match a with
      | Spair { car=car; cdr=cdr } -> 
        if Ocs_misc.test_eqv car (Ocs_sym.get_symbol "ast_apply")
        then begin
          match cdr with 
          | Spair { cdr=Snull; car=Spair { car = f; cdr = Spair { car = a; cdr=Snull } } } -> f,a
          | _ -> failwith "application wrong no of args"
        end
        else a, Snull
      | _ -> a,Snull
    in
    let x = call :: f :: a :: [] in
    let x = Ocs_misc.make_slist Snull (rev x) in
    x
    }

sexpr: | DUMMY { Snull }

sname: NAME { Sstring (snd $1) }

satom:
  | sliteral { $1 }

  | NAME 
    {
      let sr,x = $1 in
      let aname = Ocs_sym.get_symbol "ast_name" in 
      let empty = Ocs_misc.make_slist Snull [] in
      let x = aname :: Sstring x :: empty :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

sinteger:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      Sbigint v
    }

sintegral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      x
    }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in
      let v = Big_int.minus_big_int v in
      let i = Sstring t :: Sbigint v :: [] in
      let x = Ocs_misc.make_slist Snull (rev i) in
      x
    }

sstring:
  | STRING
    { 
      let sr,s = $1 in
      Sstring s
    }


sliteral:
  | INTEGER 
    { 
      let sr,t,v = $1 in
      let v = Big_int.string_of_big_int v in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let aint = Ocs_sym.get_symbol "ast_int" in 
      let i = aint :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

  | FLOAT   
    { 
      let sr,t,v = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let afloat = Ocs_sym.get_symbol "ast_float" in 
      let i = afloat :: Sstring t :: Sstring v :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

  | STRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_string" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
   }

  | WSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_wstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

  | USTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_ustring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      let alit = Ocs_sym.get_symbol "ast_literal" in 
      let astring = Ocs_sym.get_symbol "ast_cstring" in 
      let i = astring :: Sstring s :: [] in
      let i = Ocs_misc.make_slist Snull (rev i) in
      let x = alit :: i :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

  | QSTRING  
    { 
      let sr,s = $1 in
      let qstring = Ocs_sym.get_symbol "ast_interpolate" in 
      let x = qstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

  | FSTRING  
    { 
      let sr,s = $1 in
      let fstring = Ocs_sym.get_symbol "ast_vsprintf" in 
      let x = fstring :: Sstring s :: [] in
      let x = Ocs_misc.make_slist Snull (rev x) in
      x
    }

suser10token:
  | USER10 
    { 
      let sr,op,fn = $1 in
      Sstring fn
    }

comment:
  | COMMENT_KEYWORD STRING SEMI { `AST_nop (rstoken $1 $3, snd $2) }

binding_definition:
  | abstract_type { $1 }
  | const_def { $1 }
  | binding_header { $1 }
  | export_statement { $1 }

publish:
  /*
  | PUBLISH STRING binding_definition 
    { `AST_public (slift $1, snd $2, $3) }

  | PUBLISH STRING declarative 
    { `AST_public (slift $1, snd $2, $3) }
  */

  | PRIVATE declarative 
    { `AST_private (slift $1, $2) }

  | PRIVATE binding_definition
    { `AST_private (slift $1, $2) }

  | PRIVATE var_def 
    { `AST_private (slift $1, $2) }
  
  | PRIVATE val_def 
    { `AST_private (slift $1, $2) }


declarative:
  | function_definition { $1 }
  | object_definition { $1 }
  | procedure_definition { $1 }
  | module_definition { $1 }
  | union_decl { $1 }
  | struct_decl { $1 }
  | type_alias { $1 }

directive:
  | open_decl { $1 }
  | use_decl { $1 }
  | regdef { $1 }
  | glr_production { $1 }
  | macro_definition { $1 }

executable:
  | var_def { $1 }
  | val_def { $1 }
  | call { $1 }
  | svc { $1 }
  | return { $1 }
  | ifgoto_stmt { $1 }
/*  | whilst_stmt { $1 } */
  | todo { $1 }
  | assignment { $1 } 
  | inline_cpp { $1 } 
  | goto_statement { $1 }
  | label_statement { $1 }
  | assert_statement { $1 }

null_statement:
  | SEMI                    { `AST_nop (rstoken $1 $1,"") }

user_statement:
  | USER_STATEMENT_DRIVER
    { 
      let srt, kw, f = $1 in
      let sr = slift srt in
      (*
      print_endline ("USER STATEMENT KEYWORD " ^ kw);
      *)
      f ()
    }

inclusion:
  | INCLUDE STRING SEMI
    { 
      let sr = rstoken $1 $3 in 
      `AST_include (sr, snd $2) 
    }
 
@head(2,"C parse hack")
@select(h)
cparse:
  | CPARSE STRING SEMI
    {
      `AST_cparse (rstoken $1 $3, snd $2)
    }
    
@head(2,"Decl name")
@select(h)
declname: /* reverse order */
  | declname COLONCOLON NAME tvarlist  { (snd $3,$4) :: $1 }
  | NAME tvarlist { [snd $1,$2] }
  
@head(2,"Regular definitions")
@select(h)

regdef:
  | REGEXP NAME EQUAL re1 SEMI      
    { 
      let name = snd $2 in 
      `AST_regdef (rstoken $1 $5,name,$4) 
    }
  
re0:
  | re1 AS NAME              { `REGEXP_group (snd $3, $1) }
  | re1                      { $1 }

re1:
  | re1 VBAR re2             { `REGEXP_alt ($1, $3) }
  | re2                      { $1 }

re2:
  | re2 re3                  { `REGEXP_seq ($1, $2) }
  | re3                      { $1 }

re3:
  | re4 STAR                { `REGEXP_aster $1 }
  | re4 PLUS                 { `REGEXP_seq ($1,`REGEXP_aster $1) }
  | re4 QUEST                { `REGEXP_alt (`REGEXP_epsilon, $1) }
  | re4                      { $1 }

re4:
  | STRING                  { let s = snd $1 in `REGEXP_string s }
  | UNDERSCORE              { regexp_underscore }
  | DOT                     { regexp_dot }
  | LPAR re0 RPAR           { $2 }
  | LSQB charset RSQB       { regexp_of_charset $2 }
  | LSQB CIRCUMFLEX charset RSQB { regexp_of_charset (charset_inv $3) }
  | re_name                 { `REGEXP_name $1 } 

re_name:
  | re_name COLONCOLON NAME 
    { 
      let e = ($1 :> expr_t) in
      let sr = rsrange (src_of_expr e) (slift (fst $3)) in
      `AST_lookup (sr, (e, snd $3,[]))
    }
  | NAME { `AST_name (slift (fst $1), snd $1,[]) }

charset0:
  | INTEGER MINUS INTEGER   
    { 
      let 
        a = match $1 with _,_,x -> Big_int.int_of_big_int x and
        b = match $3 with _,_,x -> Big_int.int_of_big_int x
      in
      charset_of_int_range a b
    }
  | STRING MINUS STRING     { charset_of_range (snd $1) (snd $3) }
  | STRING                  { charset_of_string (snd $1) }
  | INTEGER                 
    { 
      let a = match $1 with _,_,x -> Big_int.int_of_big_int x in
      charset_of_int_range a a 
    } 
charset:
  | charset charset0        { charset_union $1 $2 }
  | charset0                { $1 }
 
@head(3,'Abstract Type')
@select(h)
eqorin:
  | EQUAL typeexpr { `Eq (typecode_of_expr $2) }
  | IN typeexpr { `In (typecode_of_expr $2) }
  | { `None }

tvar:
  | NAME eqorin { snd $1 , `TYP_type, $2}
  | NAME COLON typeexpr eqorin { snd $1 , typecode_of_expr $3, $4 }

@commalistof("tvar")
@commalistof("qualified_name")

opt_type_constraint:
  | WITH qualified_name_comma_list WHERE expr 
    { {
      raw_type_constraint=typecode_of_expr $4;
      raw_typeclass_reqs=map qualified_name_of_expr $2
    } }
  | WHERE expr WITH qualified_name_comma_list
    { {
      raw_type_constraint=typecode_of_expr $2;
      raw_typeclass_reqs=map qualified_name_of_expr $4
    } }

  | WITH qualified_name_comma_list
    { {
      raw_type_constraint=`TYP_tuple [];
      raw_typeclass_reqs=map qualified_name_of_expr $2
    } }

  | WHERE expr
    { {
      raw_type_constraint=typecode_of_expr $2;
      raw_typeclass_reqs=[]
    } }

  | { {
      raw_type_constraint=`TYP_tuple [];
      raw_typeclass_reqs=[]
    } }

tvarlist:
   | LSQB tvar_comma_list opt_type_constraint RSQB
     {
       let sr = slift $1 in
       let vs,cs = fold_left
         (fun (vs,ct) (v,t,c) -> 
           let ct = match c with
           | `None -> ct
           | `Eq et -> `TYP_type_match (`AST_name (sr,v,[]),[et,`TYP_tuple []]) :: ct
           | `In elt -> `TYP_isin (`AST_name (sr,v,[]),elt) :: ct
           in
           (v,t)::vs, ct
         )
         ([], [])
         $2
       in
       let {raw_typeclass_reqs=rtr; raw_type_constraint=rtc} = $3 in
       let ct = 
         {
           raw_typeclass_reqs=rtr; 
           raw_type_constraint=`TYP_intersect (rtc::cs) 
         } 
       in
       rev vs, ct
     }
   | { dfltvs }

type_qual:
  | INCOMPLETE { [$1,`Incomplete] }
  | POD { [$1, `Pod] } /* POD types don't require destructors */
  | GC_POINTER { [$1, `GC_pointer] }
  | GC_TYPE expr 
    { 
      let t = $2 in
      let t = typecode_of_expr t in
      [$1, `Raw_needs_shape t ]
    }

type_quals:
  | type_qual type_quals { $1 @ $2 }
  | { [] }
  
abstract_type:
  | type_quals CTYPES basic_name_comma_list requires_clause SEMI
    {
      let sr = rstoken $2 $5 in
      let qs = List.map snd $1 in
      `AST_ctypes (sr,$3,qs,$4)
    }

  | type_quals TYPE declname EQUAL code_spec requires_clause SEMI 
    { 
      let name,vs = hd $3 in
      let qs = List.map snd $1 in
      let sr = rstoken $2 $7 in
      let stmt = `AST_abs_decl (sr, name, vs, qs, $5, $6) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

  | type_quals TYPE declname EQUAL NEW typeexpr SEMI 
    { 
      let name,vs = hd $3 in
      let sr = rstoken $2 $7 in
      let t = typecode_of_expr $6 in
      let stmt = `AST_newtype (sr, name, vs, t) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

  | CALLBACK PROCEDURE NAME COLON expr requires_clause SEMI 
    {
      let sr = rstoken $1 $7 in
      let name = snd $3 in
      let t = typecode_of_expr $5 in
      let rqs = $6 in
      let args = 
        match t with
        | `TYP_tuple lst -> lst
        | x -> [x]
      in
      `AST_callback_decl (sr,name,args,`AST_void sr,rqs)
    }

  | CALLBACK FUNCTION NAME COLON expr requires_clause SEMI 
    {
      let sr = rstoken $1 $7 in
      let name = snd $3 in
      let t = typecode_of_expr $5 in
      let rqs = $6 in
      match t with
      | `TYP_function (arg, ret) ->
        let args = 
          match arg with
          | `TYP_tuple lst -> lst
          | x -> [x]
        in
        `AST_callback_decl (sr,name,args,ret,rqs)
      | _ -> 
        failwith 
        (
          "Function '"^name^"' requires function type, got " ^
          string_of_typecode t ^ " in " ^
          short_string_of_src sr
        )
    }


@head(3,'Union Binding')
@select(h)
union_decl:
  | ENUM NAME LBRACE enum_items RBRACE SEMI 
    { 
      `AST_union (rstoken $1 $6, snd $2, dfltvs, $4) 
    }

  | UNION declname EQUAL type_sum_items SEMI 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_union (sr, name,vs, $4) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }
  | UNION declname EQUAL VBAR type_sum_items SEMI 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let stmt = `AST_union (sr, name,vs, $5) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | UNION declname LBRACE type_sum_items2 RBRACE 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_union (sr, name,vs, $4) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

opt_value:
  | EQUAL INTEGER { 
      let sr,t,v = $2 in 
      let n = Big_int.int_of_big_int v in
      Some n 
    }
  | { None }

enum_items:
  | enum_items COMMA enum_item { $1 @ [$3] }
  | enum_item { [$1] }
enum_item:
  | NAME opt_value
    { 
      let sr = slift (fst $1) in
      snd $1, $2, dfltvs, typecode_of_expr (`AST_void sr)
    }

type_sum_items:
  | type_sum_items VBAR type_sum_item { $1 @ [$3] }
  | type_sum_item { [$1] }
type_sum_item:
  | NAME tvarlist OF expr { (snd $1,None,$2,typecode_of_expr $4) }
  | NAME tvarlist
    { 
      let sr = slift (fst $1) in
      snd $1, None, $2, typecode_of_expr (`AST_void sr)
    }
type_sum_items2:
  | type_sum_items2 type_sum_item SEMI { $1 @ [$2] }
  | type_sum_item SEMI { [$1] }

@head(3,'Struct Binding')
@select(h)
opt_equal:
  | EQUAL {()}
  | {()}

struct_decl:
  | STRUCT declname opt_equal LBRACE struct_component_aster RBRACE 
  { 
    let name,vs = hd $2 in
    let sr = rstoken $1 $6 in
    let stmt = `AST_struct (sr,name,vs,$5) in
    fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
  }

  | CSTRUCT declname opt_equal LBRACE struct_component_aster RBRACE 
  { 
    let name,vs = hd $2 in
    let sr = rstoken $1 $6 in
    let stmt = `AST_cstruct (sr,name,vs, $5) in
    fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
  }

  | CCLASS declname opt_equal LBRACE class_component_aster RBRACE 
  { 
    let name,vs = hd $2 in
    let sr = rstoken $1 $6 in
    let stmt = `AST_cclass (sr, name,vs, $5) in
    fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
  }

  | CLASS declname opt_equal compound
  { 
    let name,vs = hd $2 in
    let sr = rsrange (slift $1) (fst $4) in
    let stmt = `AST_class (sr, name,vs, snd $4) in
    fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
  }

  | TYPECLASS declname opt_equal compound
  {
    let name,vs = hd $2 in
    let sr = rsrange (slift $1) (fst $4) in 
    let stmt = `AST_typeclass (sr, name, vs, snd $4)  in
    fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
  }

  | INSTANCE tvarlist qualified_name opt_equal compound
  {
    let sr = rsrange (slift $1) (fst $5) in 
    let vs = $2 in
    match $3 with
    | (`AST_name _ | `AST_lookup _) as qn ->
      `AST_instance (sr, vs, qn, snd $5) 
    | _ -> Flx_exceptions.clierr sr "Qualified name required"
  }

@aster("struct_component")
struct_component:
  | NAME COLON expr SEMI { (snd $1,typecode_of_expr $3) }


opt_name:
  | NAME { snd $1 }
  | {""}

@aster("class_component")
class_component:
  | VAR NAME COLON expr SEMI { `MemberVar (snd $2,typecode_of_expr $4,None) }
  | VAL NAME COLON expr SEMI { `MemberVal (snd $2,typecode_of_expr $4,None) }
  | CTOR opt_name COLON expr opt_cstring SEMI 
    { `MemberCtor ($2,None,typecode_of_expr $4,$5) }
  | FUNCTION NAME tvarlist COLON expr opt_cstring SEMI 
    { `MemberFun (snd $2,None,$3,typecode_of_expr $5,$6) }
  | PROCEDURE NAME tvarlist COLON expr opt_cstring SEMI 
    { `MemberProc (snd $2,None,$3,typecode_of_expr $5,$6) }

@aster("typeclass_component")
typeclass_component:
  | FUNCTION NAME COLON expr SEMI 
    { `TypeClassMemberFun (rstoken $1 $5, snd $2,typecode_of_expr $4) }
  | PROCEDURE NAME COLON expr SEMI 
    { `TypeClassMemberProc (rstoken $1 $5, snd $2,typecode_of_expr $4) }


@head(3,'Abstract Constant Binding')
@select(h)
const_def:
  | adjectives CONST declname COLON expr EQUAL code_spec requires_clause SEMI 
    { 
      let adjectives = map snd $1 in
      let name,vs = hd $3 in
      let reqs = $8 in
      let reqs = 
        if mem `Virtual adjectives then
          `RREQ_and (`RREQ_atom (`Property_req "virtual"),reqs)
        else reqs
      in
      let sr = rstoken $2 $9 in
      let stmt = `AST_const_decl 
      (
        sr, name,vs,
        typecode_of_expr $5, 
        $7, reqs
      ) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)

    }

  | adjectives CONST declname COLON expr requires_clause SEMI 
    { 
      let adjectives = map snd $1 in
      let name,vs = hd $3 in
      let reqs = $6 in
      let reqs = 
        if mem `Virtual adjectives then
          `RREQ_and (`RREQ_atom (`Property_req "virtual"),reqs)
        else reqs
      in
      let sr = rstoken $2 $7 in
      let stmt = `AST_const_decl 
      (
        sr, name, vs,
        typecode_of_expr $5, 
        `Str name, reqs
      ) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }


@head(3,'Binding Header Definition')
@select(h)
code_spec:
  | STRING { `StrTemplate (snd $1) }
  | CSTRING { `Str (snd $1) }
  | IDENT { `Identity }

requirement:
  | qualified_name
    {
      `Named_req (qualified_name_of_expr $1)
    }

  | BODY code_spec { `Body_req $2 }
  | HEADER code_spec { `Header_req $2 }
  | PROPERTY STRING { `Property_req (snd $2) }
  | PACKAGE code_spec { `Package_req $2 }

requirement_atom:
  | requirement { `RREQ_atom $1 }
  | LPAR requirements RPAR { $2 }

requirement_and:
  | requirement_and AND requirement_atom { `RREQ_and ($1,$3) }
  | requirement_atom { $1 }

requirement_or:
  | requirement_or OR requirement_and { `RREQ_or ($1,$3) }
  | requirement_and { $1 }
  
requirements:
  | requirements COMMA requirement_or { `RREQ_and ($1,$3) }
  | requirement_or { $1 }

requires_clause:
  | REQUIRES requirements { $2 }
  | { `RREQ_true }

binding_header:
  | HEADER code_spec requires_clause SEMI 
  { 
      let sr = rstoken $1 $4 in
      `AST_insert (sr, "_root", dfltvs, $2, `Header ,$3) 
  }
  
  | BODY code_spec requires_clause SEMI 
  { 
     let sr = rstoken $1 $4 in
    `AST_insert (sr, "_root", dfltvs, $2, `Body, $3) 
  }

  | HEADER EQUAL code_spec requires_clause SEMI 
  { 
      let sr = rstoken $1 $5 in
      `AST_insert (sr, "_root", dfltvs, $3, `Header, $4) 
  }
  
  | BODY EQUAL code_spec requires_clause SEMI 
  { 
     let sr = rstoken $1 $5 in
    `AST_insert (sr, "_root", dfltvs, $3, `Body, $4) 
  }

  | HEADER declname EQUAL code_spec requires_clause SEMI 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let stmt = `AST_insert (sr,name,vs, $4, `Header, $5) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }
  
  | BODY declname EQUAL code_spec requires_clause SEMI 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let stmt = `AST_insert (sr,name,vs, $4, `Body, $5) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | REQUIRES requirements SEMI 
  { 
    let sr = rstoken $1 $3 in
    `AST_insert (sr, "_root", dfltvs, `Str "", `Body, $2)
  }

  | NAME REQUIRES requirements SEMI 
  { 
    let sr = rstoken (fst $1) $4 in
    `AST_insert (sr, snd $1, dfltvs, `Str "", `Body, $3)
  }

@head(3,'Inline C++ Code Definition')
@select(h)
inline_cpp:
  | CODE code_spec SEMI { `AST_code (rstoken $1 $3, $2) }
  | NORETURN CODE code_spec SEMI { `AST_noreturn_code (rstoken $1 $4, $3) }

@head(3,'Type Alias')
@select(h)
type_alias:
  | TYPEDEF declname EQUAL expr SEMI 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let return_type = `TYP_type in
      let body = typecode_of_expr $4 in
      let stmt = `AST_type_alias (sr,name,vs,body) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | TYPEDEF FUNCTION declname typefun_args COLON expr EQRIGHTARROW expr SEMI
    {
      let name,vs = hd $3 in
      let sr = rstoken $1 $9 in
      let return_type = typecode_of_expr $6 in
      let body = typecode_of_expr $8 in
      let args = List.map snd $4 (* elide srcref *) in
      let stmt =  mktypefun sr name vs args return_type body in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }
 
 | TYPEDEF FUNCTION declname COLON expr EQUAL type_matchings SEMI
    { 
      let name,vs = hd $3 in
      let sr = rstoken $1 $8 in
      let t = typecode_of_expr $5 in
      match t with
      | `TYP_function (argt, return_type) ->
        let args = [["_a",argt]] in 
        let match_expr = `AST_type_match (sr,(`AST_name (sr,"_a",[]),$7)) in
        let body = typecode_of_expr match_expr in
        let stmt = mktypefun sr name vs args return_type body in
        fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)

      | _ -> 
        failwith 
        (
          "Function '"^name^"' requires function type, got " ^
          string_of_typecode t ^ " in " ^
          short_string_of_src sr
        )
    }


  | RENAME declname EQUAL qualified_name SEMI 
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let qn = qualified_name_of_expr $4 in
      let stmt = `AST_inherit (sr,name,vs,qn) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }
  
  | RENAME FUNCTION declname EQUAL qualified_name SEMI 
    { 
      let name,vs = hd $3 in
      let sr = rstoken $1 $6 in
      let qn = qualified_name_of_expr $5 in
      let stmt = `AST_inherit_fun (sr,name,vs,qn) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

  | INHERIT qualified_name SEMI 
    { 
      let sr = rstoken $1 $3
      and qn = qualified_name_of_expr $2
      in
      `AST_inject_module (sr,qn)
    }

@head(3,'Export')
@select(h)
export_statement:
  | EXPORT FUNCTION suffixed_name AS STRING SEMI 
    { 
      `AST_export_fun (rstoken $1 $6, $3, snd $5) 
    }

  | EXPORT PROCEDURE suffixed_name AS STRING SEMI 
    { 
      `AST_export_fun (rstoken $1 $6, $3, snd $5) 
    }

  | EXPORT TYPE LPAR expr RPAR AS STRING SEMI 
    { 
      `AST_export_type (rstoken $1 $8, typecode_of_expr $4, snd $7) 
    }

@head(3,'Open')
@select(h)
open_decl:
  | OPEN tvarlist qualified_name SEMI
  {
    let vs : vs_list_t = $2 in
    `AST_open (rstoken $1 $4,vs,qualified_name_of_expr $3)
  }

use_decl:
  | USE qualified_name SEMI
    {
      let sr = rstoken $1 $3 in
      match $2 with
      | (`AST_lookup (_,(e,n,[])) as qn) -> `AST_use (sr,n,qualified_name_of_expr qn)
      | (`AST_name (_,n,_) as qn) -> `AST_use (sr,n,qualified_name_of_expr qn)
      | _ -> Flx_exceptions.clierr sr "Use declaration requires qualified name"
    }
    
  | USE NAME EQUAL qualified_name SEMI
    {
      let sr = rstoken $1 $5 in
      `AST_use (sr, snd $2, qualified_name_of_expr $4)
    }

@head(3,'Macro Definition')
@select(h)
mac_arg:
  | NAME COLON FUNCTION    { snd $1, Expr }
  | NAME COLON PROCEDURE   { snd $1, Stmt }
  | NAME COLON NAME 
    { 
      let sr = rstoken (fst $1) (fst $3) in
      snd $1, 
      match $3 with 
      | (_,"ident") -> Ident 
      | _ -> clierr sr "Unknown macro type"
    }
  | NAME                   { snd $1, Expr }

mac_args:
  | mac_arg COMMA mac_args { $1 :: $3 }
  | mac_arg                { [$1] }

mac_arg_list:
  | LPAR mac_args RPAR     { $2 }
  | LPAR RPAR              { [] }

eqop: 
  | EQUAL {}
  | EQRIGHTARROW {}

macro_definition:
  | MACRO NAME IS expr SEMI
    {
      let 
        sr = rstoken $1 $5 and
        lname = snd $2 and
        rname = $4
      in
        match rname with
        | `AST_tuple (_,ls) -> 
          let ls =
            map 
            (fun x -> match x with 
              | `AST_name (_,x,[]) -> x
              | _ -> clierr sr "RHS must be name or name list"
            ) 
            ls
          in
          `AST_macro_names (sr,lname,ls)

        | `AST_name (_,x,[]) -> `AST_macro_name (sr,lname,x)

        | _ -> clierr sr "RHS must be name or name list"
    }

  | MACRO FOR NAME IN expr DO statements DONE SEMI
    { 
      let 
        sr = rstoken $1 $9 and
        lname = snd $3 and
        rname = $5 and
        sts = $7 
      in
        let ls = match rname with
        | `AST_name (_,rname,[]) -> [rname]
        | `AST_tuple (_,ls) ->
          map 
          (fun x -> match x with 
          | `AST_name (_,x,[]) -> x
          | _ -> clierr sr "RHS must be name or name list"
          ) 
          ls
        | _ -> clierr sr "RHS must be name list"
        in
         `AST_macro_ifor (sr, lname,ls,sts) 
  }


  /*
  | MACRO NAME COLON LIST IDENT EQUAL rev_name_list SEMI
    {
      let 
        sr = rstoken $1 $8 and
        lname = snd $2 and
        rnames = rev $7
      in
        `AST_macro_names (sr,lname,rnames)
    }
  */
  | MACRO NAME IS NEW SEMI
    {
      let 
        sr = rstoken $1 $5 and
        lname = snd $2
      in
        `AST_macro_name (sr,lname,"")
    }

  | MACRO VAR macro_names EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $6 and
        names = $3 and
        e = $5
      in
        `AST_macro_var (sr,names,e)
    }


  | MACRO macro_names EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $5 and
        names = $2 and
        e = $4
      in
        `AST_macro_assign (sr,names,e)
    }


  | MACRO VAL macro_names EQUAL expr SEMI
    {
      let 
        sr = rstoken $1 $6 and
        names = $3 and
        e = $5
      in
        `AST_macro_val (sr,names,e)
    }

  | MACRO VAL NAME IS tuple SEMI
    {
      let 
        sr = rstoken $1 $6 and
        name = snd $3 and
        es = 
          (* hacky .. (x,y) and x,y both tuples, no way
            to get a real tuple value ..
          *)
          match $5 with 
          | `AST_tuple (_,es) -> es 
          | x -> [x]
      in
        `AST_macro_vals (sr,name,es)
    }


  | MACRO FUNCTION NAME mac_arg_list eqop expr SEMI
    {
      let 
        sr = rstoken $1 $7 and
        name = snd $3 and
        args = $4 and
        e = $6
      in
      `AST_expr_macro (sr,name,args,e)
    }

  | MACRO PROCEDURE NAME mac_arg_list compound 
    {
      let 
        sr = rsrange (slift $1) (fst $5) and 
        name = snd $3 and
        args = $4 and
        sts = snd $5
      in
      `AST_stmt_macro (sr,name,args,sts)
    }

  | MACRO compound SEMI
    {
      let sr = rstoken $1 $3 in
      let sts = snd $2 in 
      `AST_macro_block (sr,sts)
    }
    
  | MACRO FORGET macro_names SEMI
    {
      let sr = rstoken $1 $4 in
      `AST_macro_forget (sr,$3)
    }

  | MACRO GOTO NAME SEMI
    { 
      `AST_macro_goto (rstoken $1 $4, snd $3) 
    }

  | MACRO NAME COLONGREATER 
    { 
      `AST_macro_label (rstoken $1 $3, snd $2) 
    }

  | MACRO IF expr GOTO NAME SEMI
    { `AST_macro_ifgoto (rstoken $1 $6,$3,snd $5) }

  | MACRO FOR VAL macro_names IN expr DO statements DONE SEMI
  { 
    `AST_macro_vfor (rstoken $1 $10, $4,$6,$8) 
  }
  
 
macro_name_list:
  | macro_name_list COMMA NAME { snd $3 :: $1 }
  | NAME { [snd $1] }
macro_names:
  | macro_name_list { List.rev $1 }
  | { [] }

/*
rev_name_list:
  | NAME COMMA rev_name_list { snd $1 :: $3 }
  | NAME { [snd $1] }
*/

@head(3,'Function and Procedure Definition')
@select(h)
typefun_arg:
  | LPAR typeparameter_comma_list RPAR { rstoken $1 $3,$2 }
  | NAME { slift (fst $1),[snd $1,`TYP_none] }
typefun_args:
  | typefun_arg typefun_args      { $1 :: $2 }
  | typefun_arg               { [$1] }


fun_arg:
  | LPAR parameter_comma_list WHEN expr RPAR { rstoken $1 $3,($2,Some $4) }
  | LPAR parameter_comma_list RPAR { rstoken $1 $3,($2,None) }
  | NAME { slift (fst $1),([`PVal,snd $1,`TYP_none],None) }

fun_args:
  | fun_arg fun_args      { $1 :: $2 }
  | fun_arg               { [$1] }
opt_fun_args:
  | fun_args { $1 }
  | { [] }

opt_type_expr:
  | COLON expr EXPECT expr { typecode_of_expr $2, Some $4 }
  | COLON expr { typecode_of_expr $2, None }
  | EXPECT expr { `TYP_none, Some $2 }
  | { `TYP_none, None }

opt_cstring:
  | EQUAL code_spec { Some $2 }
  | { None }

adjective:
  | INLINE { $1,`InlineFunction }
  | NOINLINE { $1,`NoInlineFunction }
  | VIRTUAL { $1,`Virtual }

adjectives:
  | adjective adjectives { $1 :: $2 }
  | { [] }

opt_prec:
  | IS NAME { snd $2 }
  | { "" }

opt_traint_eq:
  | EXPECT expr EQUAL { Some $2 }
  | { None }

reduce_args:
  | LPAR typeparameter_comma_list RPAR { $2 }

fun_kind:
  | CFUNCTION { $1,`CFunction }
  | FUNCTION { $1,`Function }
  | GENERATOR { $1,`Generator }

function_definition:
  | REDUCE declname reduce_args COLON expr EQRIGHTARROW expr SEMI
    {
      let name,vs = hd $2 in
      let sr = rstoken $1 $8 in
      let args = $3 in
      let rsrc = $5 in
      let rdst = $7 in
      let stmt = `AST_reduce (sr,name,vs,args,rsrc,rdst) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | AXIOM declname fun_arg COLON expr SEMI
    {
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let args = snd $3 in
      let rsrc = $5 in
      let stmt = `AST_axiom (sr,name,vs,args,`Predicate rsrc) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | AXIOM declname fun_arg COLON expr EQUAL expr SEMI
    {
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let args = snd $3 in
      let l= $5 in
      let r= $7 in
      let stmt = `AST_axiom (sr,name,vs,args,`Equation (l,r)) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | LEMMA declname fun_arg COLON expr SEMI
    {
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let args = snd $3 in
      let rsrc = $5 in
      let stmt = `AST_lemma (sr,name,vs,args,`Predicate rsrc) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | LEMMA declname fun_arg COLON expr EQUAL expr SEMI
    {
      let name,vs = hd $2 in
      let sr = rstoken $1 $6 in
      let args = snd $3 in
      let l= $5 in
      let r= $7 in
      let stmt = `AST_lemma (sr,name,vs,args,`Equation (l,r)) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | adjectives fun_kind declname fun_args opt_type_expr EQRIGHTARROW expr SEMI
    { 
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let sr = rstoken sr1 $8 in
      let return_type = $5 in
      let body = [`AST_fun_return (sr,$7)] in
      let args = List.map snd $4 in
      let stmt = mkcurry sr name vs args return_type kind body in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

  | adjectives fun_kind declname fun_args opt_type_expr EQUAL compound 
    { 
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let sr = rsrange (slift sr1) (fst $7) in
      let return_type = $5 in
      let body = snd $7 in
      let args = List.map snd $4 in
      let stmt = mkcurry sr name vs args return_type kind body in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }
  
  | adjectives fun_kind declname opt_type_expr opt_cstring opt_prec requires_clause SEMI 
    { 
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let adjectives = map snd $1 in 
      let t,traint = $4
      and sr = rstoken sr1 $8
      and prec = $6
      and reqs = $7
      in
      let ct =  
        match $5 with 
        | Some x -> x 
        | None -> 
          if mem `Virtual adjectives then `Virtual else
          `StrTemplate (name ^ "($a)")
      in
      match t with
      | `TYP_cfunction (arg, ret) 
      | `TYP_function (arg, ret) ->
        let args = 
          match arg with
          | `TYP_tuple lst -> lst
          | x -> [x]
        in
        let reqs = match kind with 
          | `Generator -> 
            `RREQ_and (`RREQ_atom (`Property_req "generator"),reqs)
          | _ -> reqs
        in
        let reqs = 
          if mem `Virtual adjectives then
            `RREQ_and (`RREQ_atom (`Property_req "virtual"),reqs)
          else reqs
        in
        let stmt = 
          if List.length args > 0 && list_last args = `TYP_ellipsis 
          then
            (*
            let vs = vs @ ["_varargs",`TPAT_any] in
            *)
            let vs = let vs,t = vs in vs @ ["_varargs",`AST_patany sr],t in
            let args = List.rev (`AST_name (sr,"_varargs",[]) :: List.tl (List.rev args)) in
            `AST_fun_decl (sr, name, vs, args,  ret,  ct, reqs,prec) 
          else
            `AST_fun_decl (sr, name, vs, args,  ret,  ct, reqs,prec) 
          in
          fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)

      | _ -> 
        failwith 
        (
          "Function '"^name^"' requires function type, got " ^
          string_of_typecode t ^ " in " ^
          short_string_of_src sr
        )
    }

  | adjectives fun_kind declname opt_type_expr EQRIGHTARROW expr SEMI
    {
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let sr = rstoken sr1 $7 in
      let return_type = $4
      and body = [`AST_fun_return (sr,$6)]
      and args = []
      in 
      let stmt = mkcurry sr name vs args return_type kind body in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

  | adjectives fun_kind declname opt_type_expr EQUAL matchings SEMI
    { 
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let sr = rstoken sr1 $7 in
      let t,traint = $4 in
      let body = $6 in
      match t with
      | `TYP_function (argt, return_type) ->
        let args = [[`PVal,"_a",argt],None] in 
        let match_expr = `AST_match (sr,(`AST_name (sr,"_a",[]),body)) in
        let body = [`AST_fun_return (sr,match_expr)] in
        let stmt = mkcurry sr name vs args (return_type,traint) kind body in
        fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
      | _ -> 
        failwith 
        (
          "Function '"^name^"' requires function type, got " ^
          string_of_typecode t ^ " in " ^
          short_string_of_src sr
        )
    }

ctor_init:
  | NAME LPAR expr RPAR { $1,$3 }
  
ctor_init_list:
  | ctor_init COMMA ctor_init_list { $1 :: $3 }
  | ctor_init { [$1] }
  
ctor_inits:
  | COLON ctor_init_list { $2 }
  | {[]}

proc_kind:
  | PROCEDURE { $1,`Function }
  | CPROCEDURE { $1,`CFunction }

procedure_definition:
  | CTOR tvarlist opt_fun_args opt_traint_eq ctor_inits compound 
    { 
      let sr = rsrange (slift $1) (fst $6) in
      let name = "__constructor__"
      and vs = $2
      and return_type = `AST_void sr
      and traint = $4 
      and body = snd $6
      and inits = $5
      and args = List.map snd $3 (* elide srcref *)
      in 
      let body = map (fun (n,e) -> `AST_init (slift (fst n), snd n, e)) inits @ body in
      mkcurry sr name vs args (return_type,traint) `Ctor body
    }

  | adjectives proc_kind declname opt_fun_args opt_traint_eq compound 
    { 
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let sr = rsrange (slift sr1) (fst $6) in
      let return_type = `AST_void sr
      and traint = $5
      and body = snd $6
      and args = List.map snd $4 (* elide srcref *)
      in
      let stmt = mkcurry sr name vs args (return_type,traint) kind body in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

  | adjectives proc_kind declname COLON expr opt_cstring requires_clause SEMI 
    { 
      let name,vs = hd $3 in
      let sr1,kind = cal_funkind $1 $2 in
      let sr = rstoken sr1 $8 
      and t = typecode_of_expr $5
      and adjectives = map snd $1
      in 
      let ct =  
        match $6 with 
        | Some x -> 
          if mem `Virtual adjectives then 
            Flx_exceptions.clierr sr "Virtual procedure can't have body"
          else x 
        | None -> 
          if mem `Virtual adjectives then `Virtual else
          `StrTemplate (name ^ "($a);")
      in
      let args = 
        match t with
        | `TYP_tuple lst -> lst
        | x -> [x]
      in
      let stmt = 
        if List.length args > 0 && list_last args = `TYP_ellipsis 
        then
          (*
          let vs = match vs with vs,t -> vs @ ["_varargs",`TPAT_any],t in
          *)
          let vs = match vs with vs,t -> vs @ ["_varargs",`AST_patany sr],t in
          let args = List.rev (`AST_name (sr,"_varargs",[]) :: List.tl (List.rev args)) in
          `AST_fun_decl (sr, name, vs, args,  `AST_void sr,  ct,$7,"") 
        else
          `AST_fun_decl (sr,name,vs, args,`AST_void sr, ct, $7,"") 
      in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }

@head(3,'Object')
@select(h)
object_definition:
  | OBJECT declname fun_args compound 
    { 
      let name,vs = hd $2 in
      let sr = rsrange (slift $1) (fst $4) in
      let return_type = `TYP_none in
      let body = snd $4 in
      let args = List.map snd $3 (* elide srcref *) in
      let stmt = mkcurry sr name vs args (return_type,None) `Object body in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }


@commalistof("typeparameter")
typeparameter:
  | NAME COLON arrow { snd $1,typecode_of_expr $3 }
  | NAME { snd $1,`TYP_none }
 
@commalistof("parameter")
param_qual:
  | VAL { `PVal }
  | VAR { `PVar }
  | REF { `PRef }
  | FUNCTION { `PFun }
  | { `PVal }

parameter:
  | param_qual NAME COLON arrow { $1, snd $2,typecode_of_expr $4 }
  | param_qual NAME { $1, snd $2,`TYP_none }
 
@doc()
Flx functions and procedures are first class citizens: the may both be passed
as arguments to procedures, and they may both be be returned from functions.
Only functions may be passed to functions.

@head(3,'Assert')
@select(h)
assert_statement:
  | ASSERT expr SEMI
    {
      `AST_assert(rstoken $1 $3, $2)
    }

@head(3,'Goto and Label')
The goto and label statements are ONLY for testing!
Note labels are declared like
@begin_displayed_code()
label:>
@end_displayed_code()
to avoid ambiguity with 'x:int'.
@select(h)
goto_statement:
  | GOTO NAME SEMI 
    { 
      `AST_goto (rstoken $1 $3, snd $2) 
    }
label_statement:
  | NAME COLONGREATER 
    { 
      `AST_label (rstoken (fst $1) $2, snd $1) 
    }

@head(3,'Read Statement')
@select(h)
svc:         
  | SVC NAME SEMI            
    { 
      `AST_svc (rstoken $1 $3, snd $2) 
    }
@doc()
The svc statement is used for supervisor calls.

@head(3,'Module Definition')
@select(h)
open_opt:
  | OPEN { `Open }
  | { `None }
  
module_definition:
  | open_opt MODULE declname opt_equal compound 
    { 
      let name,vs = hd $3 in
      let sr = rsrange (slift $2) (fst $5) in
      let qn = `AST_name (sr,name,[]) in
      let stmt = 
        let dcl =
          `AST_untyped_module ( sr, name, vs, snd $5) 
        in match $1 with
        | `None -> dcl
        | `Open -> `AST_seq (sr,[dcl; `AST_open (sr,dfltvs,qn)])
      in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)

    }

  | open_opt NAMESPACE declname opt_equal compound 
    { 
      let name,vs = hd $3 in
      let sr = rsrange (slift $2) (fst $5) in
      let qn = `AST_name (sr,name,[]) in
      let stmt = 
        let dcl = `AST_namespace ( sr, name, vs, snd $5) in
        match $1 with
        | `None -> dcl
        | `Open -> `AST_seq (sr,[dcl; `AST_open (sr,dfltvs,qn)])
      in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $3)
    }


@head(3,'Variable and Constant Declaration')
@select(h)
name_suffix:
  | COMMA NAME name_suffix { snd $2 :: $3 }
  | COMMA NAME { [snd $2] }
  
var_def:  
  | VAR NAME name_suffix EQUAL expr SEMI  
    { 
      let sr = rstoken $1 $6 in
      let names = snd $2 :: $3 in
      let n = length names in
      let expr = $5 in
      match expr with
      | `AST_tuple (_,ls) ->
        if length ls <> n then
          Flx_exceptions.clierr sr ("Wrong number of initialisers, expected " ^ string_of_int n)
        else 
        `AST_seq 
        (
          sr, 
          map2 
          (fun name v -> 
            `AST_var_decl ( sr, name, dfltvs, None, Some v) 
          ) 
          names ls
        )

      | x ->
        let lexpr: tlvalue_t list = map (fun name -> `Var (sr,name),None) names in
        `AST_assign (sr,"_set",(`List lexpr, None), expr)
    }

  | VAR declname EQUAL expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_var_decl ( sr,name,vs, None, Some $4) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | VAR declname COLON expr LEFTARROW expr SEMI  
   {
      let name,vs = hd $2 in
      let sr = rstoken $1 $7 in
      let call =
        let lsym = `AST_name (slift $1,name,[]) in
        match $6 with
        | `AST_apply (sr2,(f,a)) ->
          begin match a with
          | `AST_tuple (sr3,ls) ->
            `AST_call (sr,f,`AST_tuple (sr3,lsym::ls))
          | _ ->
            `AST_call (sr,f,`AST_tuple (sr2,[lsym;a]))
          end
        | _ as f -> 
          `AST_call (sr,f,lsym)
      in
      let vardef = `AST_var_decl (sr,name,vs, Some (typecode_of_expr $4), None) in 
      let stmt = `AST_seq (sr,[vardef;call]) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)

    }

  | VAR AMPER NAME tvarlist COLON expr LEFTARROW expr SEMI  
   {
      let sr = rstoken $1 $9 in
      let call =
        let srn = slift (fst $3) in
        let lsym = `AST_ref 
          (rsrange (slift $2) srn,
            `AST_name (srn,snd $3,[])
          ) 
        in
        match $8 with
        | `AST_apply (sr2,(f,a)) ->
          begin match a with
          | `AST_tuple (sr3,ls) ->
            `AST_call (sr,f,`AST_tuple (sr3,lsym::ls))
          | _ ->
            `AST_call (sr,f,`AST_tuple (sr2,[lsym;a]))
          end
        | _ as f -> 
          `AST_call (sr,f,lsym)
      in
      let vardef =
        `AST_var_decl 
        (
          rstoken $1 $7, 
          snd $3, 
          $4,
          Some (typecode_of_expr $6), 
          None
        ) 
      in 
        `AST_seq (sr,[vardef;call])
    }

  | VAR declname COLON expr EQUAL expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $7 in
      let stmt = `AST_var_decl ( sr,name,vs, Some (typecode_of_expr $4), Some $6) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | VAR declname COLON expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_var_decl ( sr,name,vs, Some (typecode_of_expr $4), None) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

val_def:  
  | VAL NAME name_suffix EQUAL expr SEMI  
    { 
      let sr = rstoken $1 $6 in
      let names = snd $2 :: $3 in
      let n = length names in
      let expr = $5 in
      match expr with
      | `AST_tuple (_,ls) ->
        if length ls <> n then
          Flx_exceptions.clierr sr ("Wrong number of initialisers, expected " ^ string_of_int n)
        else 
        `AST_seq 
        (
          sr, 
          map2 
          (fun name v -> 
            `AST_val_decl ( sr, name, dfltvs, None, Some v) 
          ) 
          names ls
        )

      | x ->
        let lexpr: tlvalue_t list = map (fun name -> `Val (sr,name),None) names in
        `AST_assign (sr,"_set",(`List lexpr, None), expr)
    }

  | VAL declname EQUAL expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_val_decl ( sr,name,vs, None, Some $4) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | VAL declname COLON expr EQUAL expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $7 in
      let stmt = `AST_val_decl ( sr,name,vs, Some (typecode_of_expr $4), Some $6) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | VAL declname COLON expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_val_decl ( sr,name,vs, Some (typecode_of_expr $4), None) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | REF declname LEFTARROW expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $5 in
      let stmt = `AST_ref_decl ( sr,name,vs, None, Some $4) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

  | REF declname COLON expr LEFTARROW expr SEMI  
    { 
      let name,vs = hd $2 in
      let sr = rstoken $1 $7 in
      let stmt = `AST_ref_decl ( sr,name,vs, Some (typecode_of_expr $4), Some $6) in
      fold_left (fun stmt (name,vs) -> `AST_namespace (sr,name,vs,[stmt])) stmt (tl $2)
    }

@doc()
Variables can be declared in both procedures and functions.

@head(3,'Function or Procedure Return')
@select(h)
return:       
  | YIELD expr SEMI          { `AST_yield (rstoken $1 $3, $2) }
  | RETURN expr SEMI          { `AST_fun_return (rstoken $1 $3, $2) }
  | RETURN SEMI               { `AST_proc_return (rstoken $1 $2) }
  | HALT STRING SEMI          { `AST_halt (rstoken $1 $3, snd $2) }

@doc()
The return statement is only permitted as the last statement
in a function.

@head(3,'Procedure Call')
@select(h)
compound:     
  | LBRACE statements RBRACE  { rstoken $1 $3, $2 }

@doc()
A procedure call looks like a function application,
followed by a semicolon:
@begin_displayed_code()
  p a;
  f1 a1 a2 a3; 
@end_displayed_code()
are valid procedure calls. Note in the second
example, f1 and f1 a1 are functions, whilst
the function call f1 a1 a2 must return a procedure
which accepts a3.
@p()
There is a special case: a single name followed
by a semi-colon is considered a call of the
designated procedure passing the unit argument,
so that the following are equivalent:
@begin_displayed_code()
  print_eol ();
  print_eol;
@end_displayed_code()
Note that there is no ambiguity with passing
procedures as arguments: the name always
represents a procedure closure in an expression
context, never a call.
@p()
Note again that this special case only
applies to names, not general expressions,
but the name doesn't have to be a procedure
constant: it could be a variable name.
@begin_displayed_code()
  val eol = print_eol;
  eol; // means eol()
  sin x; // error: function application
  (sin x); // still an error!
@end_displayed_code()

@select(h)
call:
  | expr SEMI 
    {
      let sr = 
        let sr1 = src_of_expr $1 in
        rsrange sr1 (slift $2) 
     in
      match $1 with 
      | `AST_apply (_,(proc, arg)) -> 
        `AST_call (sr, proc, arg)

      | proc -> 
       let u = `AST_tuple (slift $2, []) in
       `AST_call (sr, proc, u)
    }

  | CALL expr SEMI 
    {
      let sr = rstoken $1 $3 in
      match $2 with 
      | `AST_apply (sr,(proc, arg)) -> 
        `AST_call (sr, proc, arg)
      
      | proc -> 
        let u = `AST_tuple (slift $3, []) in
       `AST_call (rstoken $1 $3, proc, u)
    }

  | JUMP expr SEMI 
    {
      let sr = rstoken $1 $3 in
      match $2 with 
      | `AST_apply (sr,(proc, arg)) -> 
        `AST_jump (sr, proc, arg)
      
      | proc -> 
        let u = `AST_tuple (slift $3, []) in
       `AST_call (sr, proc, u)
    }

  | LOOP expr SEMI {
    let sr = rstoken $1 $3 in
    let u = `AST_tuple (slift $3, []) in
    match $2 with 
    | `AST_apply (_,(`AST_name (_,name,[]), arg)) -> 
      `AST_loop (sr, name, arg)
    
    | `AST_name (s,name,[]) ->
      `AST_loop (sr, name, u)

    | _ -> failwith "Loop requires unqualified name"
  }


assignop:
  | EQUAL           { $1,"_set" }
  | COLONEQUAL      { $1,"_init" }

rmwop:
  | PLUSEQUAL       { $1,"pluseq" }
  | MINUSEQUAL      { $1,"minuseq" }
  | STAREQUAL       { $1,"muleq" }
  | SLASHEQUAL      { $1,"diveq" }
  | PERCENTEQUAL    { $1,"modeq" }
  | LEFTSHIFTEQUAL  { $1,"leftshifteq" }
  | RIGHTSHIFTEQUAL { $1,"rightshifteq" }
  | CARETEQUAL      { $1,"bxoreq" }
  | VBAREQUAL       { $1,"boreq" }
  | AMPEREQUAL      { $1,"bandeq" }
  | TILDEEQUAL      { $1,"tildeeq" }

swapop:
  | LEFTRIGHTARROW  { $1,"_swap" }

incrop:
  | PLUSPLUS        { $1,"incr" }
  | MINUSMINUS      { $1, "decr" }

lelement:
  | VAL NAME { `Val  (rstoken $1 (fst $2), snd $2) }
  | VAR NAME { `Var  (rstoken $1 (fst $2), snd $2) }
  | NAME     { `Name (slift (fst $1), snd $1) }
  | UNDERSCORE { `Skip (rstoken $1 $1) }
  | LPAR lexprs RPAR { `List $2 }

tlelement:
  | lelement COLON factor { $1,Some (typecode_of_expr $3) } 
  | lelement { $1,None }

lexprs:
  | tlelement COMMA lexprs { $1 :: $3 }
  | tlelement { [$1] }

lexpr: 
  | lexprs 
    { 
      match $1 with 
      | [lv,t] -> lv,t 
      | _ -> `List $1, None 
    }

assignment: 
  | VAR NAME LEFTARROW NEW expr SEMI 
    {
      let sr = rstoken $1 $6 in
      let name = snd $2 in
      let f,a= match $5 with
      | `AST_apply(_,(f,a)) -> f,a
      | f -> f,`AST_tuple (sr,[])
      in
      `AST_apply_ctor (sr,name,f,a)
    }

  | expr LEFTARROW expr SEMI
    {
      let sr = rsrange (src_of_expr $1) (slift $4) in
      let lsym = $1 in
      match $3 with
      | `AST_apply (sr2,(f,a)) ->
        begin match a with
        | `AST_tuple (sr3,ls) ->
          `AST_call (sr,f,`AST_tuple (sr3,lsym::ls))
        | _ ->
          `AST_call (sr,f,`AST_tuple (sr2,[lsym;a]))
        end
      | _ as f -> 
        `AST_call (sr,f,lsym)
    }

  | expr swapop expr SEMI 
    { 
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $4) in
      call2 sname sr srop $1 $3
    }

  | DEF lexpr EQUAL expr SEMI 
    { 
      let sr = rstoken $1 $5 in
      `AST_assign (sr,"_set",$2, $4)
    }


  | expr assignop expr SEMI 
    { 
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $4) in
      `AST_assign (sr,sname,(`Expr (sr,$1),None), $3)
    }

  | expr rmwop expr SEMI 
    { 
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $4) in
      `AST_assign (sr,sname,(`Expr (sr,$1),None), $3)
    }

  | expr incrop SEMI 
    {
      let srop,sname = $2 in
      let sr = rsrange (src_of_expr $1) (slift $3) in
      call1 ("post_" ^ sname) sr srop $1
    }
  | incrop expr SEMI
    {
      let srop,sname = $1 in
      let sr = rsrange (slift srop) (slift $3) in
      call1 ("pre_" ^ sname) sr srop $2
    }


@doc()
Note that a block is an anonymous procedure defintion together with
a call to that procedure with the unit argument.

@head(3,'Place Holder')
@select(h)
todo:         
  | TODO STRING SEMI        { `AST_nop (rstoken $1 $3, snd $2) }
  | TODO SEMI               { `AST_nop (rstoken $1 $2, "") }

@doc()
The placed holder is used to denote an incomplete section of code.
A string may be included after the 'todo' keyword to serve as a reminder
of the programmers intentions.


@head(3,'Conditional Statements')
@select(h)
elif_clause:
  | ELIF expr DO statements 
    { 
      let sr = rstoken $1 $3 in
      let sr = fold_left (fun l r -> rsrange l (src_of_stmt r)) sr $4 in
      sr,$2,$4 
    }
  | ELIF expr RETURN SEMI
    {
      let sr = rstoken $1 $4 in
      sr,$2,[`AST_proc_return sr]
    }

  | ELIF expr GOTO NAME SEMI
    {
      let sr = rstoken $1 $5 in
      sr,$2,[`AST_goto (sr,snd $4)]
    }

elif_clauses:
  | elif_clauses elif_clause { $2 :: $1 }
  | elif_clause { [$1] }

else_clause:
  | elif_clauses ELSE statements
    {
      let sr = fold_left (fun l r -> rsrange l (src_of_stmt r)) (slift $2) $3 in
      fold_left (* actually a right fold cause list is reversed *)
      (fun els (sr,cond,thn) ->
        let sr = rsrange sr (fst els) in
        sr,[`AST_ifdo ( sr, cond, thn, snd els )]
      )
      (sr,$3) $1
    }
  | ELSE statements 
    {   
      let sr = fold_left (fun l r -> rsrange l (src_of_stmt r)) (slift $1) $2 in
      sr,$2 
    }
  | elif_clauses 
    {
      match $1 with [] -> assert false
      | (sr,_,_) :: _ ->
      fold_left (* actually a right fold cause list is reversed *)
      (fun els (sr,cond,thn) ->
        let sr = rsrange sr (fst els) in
        sr,[`AST_ifdo ( sr, cond, thn, snd els )]
      )
      (sr,[]) $1
    }

ifgoto_stmt:
  | IF expr GOTO NAME SEMI
    { `AST_ifgoto (rstoken $1 $5,$2,snd $4) }

  | IF expr RETURN SEMI
    { `AST_ifreturn (rstoken $1 $4,$2) }
  
  | IF expr CALL expr SEMI 
    {
      let isr = rstoken $1 $5 in
      match $4 with 
      | `AST_apply (sr,(proc, arg)) -> 
        `AST_ifdo (isr, $2,[`AST_call (sr, proc, arg)],[])
      
      | proc -> 
        let u = `AST_tuple (slift $5, []) in
       `AST_ifdo (isr, $2, [`AST_call (rstoken $3 $5, proc, u)],[])
    }


  | IF expr DO statements else_clause DONE SEMI
    { `AST_ifdo (rstoken $1 $6,$2,$4,snd $5) }

  | IF expr DO statements DONE SEMI
    { `AST_ifdo (rstoken $1 $5,$2,$4,[]) }

/*
whilst_stmt:
   | WHILST expr DO statements DONE SEMI
     { `AST_whilst (rstoken $1 $6, $2, $4) }

   | UNTIL expr DO statements DONE SEMI
     { `AST_until (rstoken $1 $6, $2, $4) }
*/

@head(3,'Regular expression matching')
@select(h)
regmatch_expr:
  | REGMATCH expr WITH regmatch_alternatives ENDMATCH
  {
    let sr = rstoken $1 $5 in
    `AST_string_regmatch (sr,($2,$4))

    (*
    let pa = `PAT_as (sr,`PAT_any sr,"_a") in
    let pb = `PAT_as (sr,`PAT_any sr,"_b") in
    let p = `PAT_tuple (sr,[pa;pb]) in
    let a = `AST_name (sr,"_a",[]) in
    let b = `AST_name (sr,"_b",[]) in
    let lexmod = `AST_name(sr,"Lexer",[]) in
    let sb = `AST_lookup(sr,(lexmod,"bounds",[])) in
    let se = `AST_apply(sr,(sb,$2)) in
    `AST_letin (sr,(p,se,
      `AST_regmatch (sr,(a,b,$4)))
    )
    *)
  }

  | REGLEX expr TO expr WITH regmatch_alternatives ENDMATCH
  {
    `AST_reglex (rstoken $1 $7,($2,$4,$6))
  }

regmatch_alternatives:
  | regmatch_alternatives regmatch_alternative { $2 :: $1 }
  | regmatch_alternative { [$1] }

regmatch_alternative:
  | VBAR re1 EQRIGHTARROW expr { $2,$4 }


@head(3,'Pattern Matching')
@select(h)
match_expr:
  | MATCH expr WITH matchings ENDMATCH
  { 
    `AST_match (rstoken $1 $5, ($2, $4))
  }
matchings:
  | matching matchings { $1 :: $2 }
  | matching { [$1] }
matching:
  | VBAR pattern EQRIGHTARROW expr { $2, $4 }
  | VBAR EQRIGHTARROW expr { let sr = rstoken $1 $2 in `PAT_none sr, $3 }

typecaseargs:
  | LSQB basic_name_comma_list RSQB { $2 }
  
typecase:
  | TYPECASE typecaseargs expr EQRIGHTARROW expr ENDCASE
    {
      let sr = rstoken $1 $6 in
      let t1 = $3 in
      let t2 = $5 in
      let ls = map snd $2 in
      `AST_case (sr,t1,ls,t2)
    }
    
@doc()
The pattern matching statment analyses the shape and contents of
a value and selects the first matching case from the matching body.

@head(4,'Patterns')
@select(h)
pattern:
  | as_pattern WHEN expr 
    { 
      `PAT_when 
      (
        rsrange (src_of_pat $1) (src_of_expr $3),
        $1, 
        $3
      ) 
    }
  | as_pattern { $1 }

as_pattern:
  | variant_pattern AS NAME 
    { 
      `PAT_as 
      (
        rsrange (src_of_pat $1) (slift (fst $3)), 
        $1, 
        snd $3
      ) 
    }
  | variant_pattern { $1 }

variant_pattern:
  | tuple_pattern { $1 }
tuple_pattern:
  | coercive_pattern_list 
    { 
      match $1 with 
      | [x] -> x 
      | _ -> `PAT_tuple 
        (
          rsrange (src_of_pat (List.hd $1)) (src_of_pat (list_last $1)),
          $1
        )
    }

coercive_pattern_list:
  | coercive_pattern COMMA coercive_pattern_list { $1 :: $3 }
  | coercive_pattern { [$1] }

coercive_pattern:
  | atomic_pattern COLON arrow 
    { 
      let sr = rsrange (src_of_pat $1) (src_of_expr $3) in
      let t = typecode_of_expr $3 in
      `PAT_coercion (sr,$1,t) 
    }
  | atomic_pattern { $1 }

atomic_pattern:
  /* constants */
  | STRING { `PAT_string (slift (fst $1), snd $1) }
  | integral 
    { 
      let sr,t,v = $1 in
      `PAT_int (sr,t,v) 
    }
  | NAN { `PAT_nan (slift $1) }
  
  /* ranges */
  | STRING DOTDOT STRING 
    { 
      `PAT_string_range (rstoken (fst $1) (fst $3), snd $1, snd $3)
    }
  | integral DOTDOT integral 
    { 
      let sr1,t1,v1 = $1
      and sr2,t2,v2 = $3
      in
      `PAT_int_range (rsrange sr1 sr2, t1,v1,t2,v2)  
    }

  | floating DOTDOT floating 
    { 
      let sr1,v1 = $1
      and sr2,v2 = $3
      in
      `PAT_float_range 
      (
       rsrange sr1 sr2, 
       v1, v2
      ) 
    }

  /* other */
  | ctor_pattern { $1 }
  /*
  | QUEST NAME { `PAT_name (rstoken $1 (fst $2), snd $2) }
  */
  | QUEST NAME { let sr = rstoken $1 (fst $2)in `PAT_as (sr,`PAT_any sr, snd $2) }
  | QUEST { `PAT_any (slift $1) }
  | UNDERSCORE { `PAT_any (slift $1) }
  | LPAR pattern RPAR { $2 }
  | REGEXP STRING LPAR basic_name_comma_list RPAR 
    { 
      let names = List.map snd $4 in
      `PAT_regexp (rstoken $1 $5, snd $2, names) 
    }
  | STRUCT LBRACE pat_assigns RBRACE
    {
      `PAT_record (rstoken $1 $4, $3)
    }

pat_assign:
  | NAME EQUAL pattern SEMI { snd $1, $3 }
pat_assigns:
  | pat_assign pat_assigns  { $1 :: $2 }
  | pat_assign { [$1] }
  
ctor_pattern:
  | ctor_name atomic_pattern 
    { 
      `PAT_nonconst_ctor 
      (
        rsrange (src_of_expr $1) (src_of_pat $2), 
        qualified_name_of_expr $1, 
        $2
      ) 
    }
  | ctor_name 
    { 
      `PAT_const_ctor 
      (
        src_of_expr $1, 
        qualified_name_of_expr $1 
      )
    }

ctor_name:
  | qualified_name 
    { 
      $1
      (*
      match $1 with sr,name,ts ->
      `AST_name (sr,name,ts)
      *) 
    }
  
  | CASE INTEGER { 
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    }

integral:
  | INTEGER { let sr,t,v = $1 in slift sr, t, v }
  | MINUS INTEGER 
    { 
      let sr,t,v = $2 in 
      rstoken $1 sr, t, (Big_int.minus_big_int v)
    }

floating:
  | FLOAT 
    { 
      let sr,t,v = $1 in
      slift sr, Float_plus (t,v) 
    }
  | MINUS FLOAT 
    {
      let sr,t,v = $2 in
      rstoken $1 sr, Float_minus (t,v) 
    }
  | INF { slift $1, Float_inf }
  | MINUS INF { slift $1, Float_minus_inf }

basic_name: 
  | NAME { $1 }
@commalistof("basic_name")

@head(2,'Type match')
@select(h)
@commalistof('tpattern')

tuple_tpattern:
  | tpattern_comma_list { 
      match $1 with
      | _ :: _ :: _ -> `TPAT_type_tuple $1 
      | x :: [] -> x
      | [] -> assert false
    }
  
tpattern:
  | tpattern AS NAME { `TPAT_as ($1,snd $3) }
  | tpat0 { $1 }

tpat0:
  | tpat1 RIGHTARROW tpat0 { `TPAT_function ($1,$3) }
  | tpat1  { $1 }

tpat1:
  | sumpat 
    { 
      match $1 with 
      | [x] -> x 
      | ps -> `TPAT_sum ps 
    }

sumpat:
  | tpat2 PLUS sumpat { $1 :: $3 }
  | tpat2 { [$1] }

tpat2:
  | mulpat 
    { 
      match $1 with 
      | [x] -> x 
      | ps -> `TPAT_tuple ps 
    }

mulpat:
  | tpat3 STAR mulpat { $1 :: $3 }
  | tpat3 { [$1] }

tpat3:
  | NAME tpatlist { `TPAT_name (snd $1, $2) }
  | LPAR tuple_tpattern RPAR { $2 }
  | QUEST NAME { `TPAT_var (snd $2) }
  | QUEST { `TPAT_any }
  | UNDERSCORE { `TPAT_any }
  | INTEGER { let sr,t,v = $1 in `TPAT_unitsum (Big_int.int_of_big_int v) }

tpatlist:
   | LSQB tpattern_comma_list RSQB { $2 }
   | { [] }


type_match_expr:
  | TYPEMATCH expr WITH type_matchings ENDMATCH
  { 
    let t = typecode_of_expr $2 in
    `AST_type_match (rstoken $1 $5, (t, $4))
  }

type_matchings:
  | type_matching type_matchings { $1 :: $2 }
  | type_matching { [$1] }

type_matching:
  /*
  | VBAR tuple_tpattern EQRIGHTARROW expr { $2, typecode_of_expr $4 }
  */
  | VBAR expr EQRIGHTARROW expr { typecode_of_expr $2, typecode_of_expr $4 }

@head(2,'Grammar Expressions')
@select(h)
glr_term:
  | qualified_name { `GLR_name (qualified_name_of_expr $1) }
  /* | LSQB glr_alts RSQB { `GLR_opt $1 }  */
  | LBRACE glr_alternatives RBRACE { `GLR_ast $2 } 
  | LPAR glr_alternatives RPAR { $2 }
  | glr_term QUEST { `GLR_opt $1 } 
  | glr_term STAR { `GLR_ast $1 } 
  | glr_term PLUS  { `GLR_plus $1 }

glr_alternatives:
  | glr_sequence VBAR glr_alts { `GLR_alt ( $1::$3) }
  | glr_sequence { $1 }

glr_alts:
  | glr_sequence VBAR glr_alts { $1 :: $3 }
  | glr_sequence { [$1] }
  
glr_sequence:
  | glr_term glr_seqs { `GLR_seq ($1::$2) }
  | glr_term { $1 }

glr_seqs:
  | glr_term glr_seqs { $1 :: $2 }
  | glr_term { [$1] }

glr_entry:
  | NAME COLON glr_term { Some (snd $1), $3 }
  | glr_term { None, $1 }
  
glr_entries:
  | glr_entry glr_entries { $1 :: $2 }
  | glr_entry { [$1] }

glr_matching:
  | VBAR glr_entries EQRIGHTARROW expr { rstoken $1 $3, $2 , $4 }
  | VBAR EQRIGHTARROW expr { rstoken $1 $2, [] , $3 }

glr_matchings:
  | glr_matching glr_matchings { $1 :: $2 }
  | glr_matching { [$1] }

glr_production:
  | NONTERM NAME COLON expr EQUAL glr_matchings SEMI
  {
    let sr = rstoken $1 $7 in
    let t = typecode_of_expr $4 in
    `AST_glr (sr,snd $2, t, $6)
  }

glr_parse:
  | PARSE expr WITH glr_matchings ENDMATCH 
  {
    let sr = rstoken $1 $5 in
    `AST_parse (sr,$2,$4)
  }
  
@head(2,'Executable Expressions')
@select(h)
expr: 
  | LET pattern EQUAL expr IN expr 
    { 
      let sr = rsrange (slift $1) (src_of_expr $6) in
      `AST_letin (sr,($2,$4,$6)) 
    }
  | rvalue { $1 }
  
rvalue:
  | lambda { $1 }

/* cannot use fun_args, since ambiguity on the third case (NAME) */
lambda_fun_arg:
  | LPAR parameter_comma_list WHEN expr RPAR { rstoken $1 $3,($2,Some $4) }
  | LPAR parameter_comma_list RPAR { rstoken $1 $3,($2,None) }

lambda_fun_args:
  | lambda_fun_arg lambda_fun_args      { $1 :: $2 }
  | lambda_fun_arg               { [$1] }

lambda:
  | dollar_apply { $1 }

  | adjectives FUNCTION tvarlist lambda_fun_args opt_type_expr EQUAL compound
    {
      let sr = rsrange (slift $2) (fst $7) in
      let vs = $3 in
      let args = List.map snd $4 in
      let ret,traint = $5 in
      let body = snd $7 in
      `AST_lambda ( sr,(vs,args, ret, body))
    }

  | adjectives FUNCTION tvarlist lambda_fun_args opt_type_expr EQRIGHTARROW expr
    {
      let sr = rsrange (slift $2) (src_of_expr $7) in
      let vs = $3 in
      let args = List.map snd $4 in
      let body = [`AST_fun_return (sr,$7)] in
      let ret,traint = $5 in
      `AST_lambda (sr, (vs,args, ret, body))
    }

  | adjectives PROCEDURE tvarlist lambda_fun_args compound
    {
      let sr = rsrange (slift $2) (fst $5) in
      let vs = $3 in
      let args = List.map snd $4 in
      `AST_lambda ( sr, (vs,args, `AST_void sr, snd $5))
    }

  | adjectives PROCEDURE tvarlist compound
    {
      let sr = rsrange (slift $2) (fst $4) in
      let vs = $3 in
      `AST_lambda ( sr, (vs,[[],None], `AST_void sr, snd $4))
    }

dollar_apply:
  | tuple UNLESS expr THEN dollar_apply
    {
      let sr = rsrange (src_of_expr $1) (src_of_expr $5) in
      let revcond = apl $2 "lnot" $3 in
      `AST_cond (sr,(revcond,$1,$5))
    }

  | tuple DOLLAR dollar_apply
    { 
      let sr = rsexpr $1 $3 in 
      `AST_apply (sr, ($1,$3)) 
    }

  | tuple { $1 }

tuple:
  | or_condition tuple_suffix           
    { 
      let lst = $1 :: $2 in
      `AST_tuple ( rslist lst, lst) 
    }
  | or_condition                        { $1 }

tuple_suffix:
  | COMMA or_condition tuple_suffix     { $2 :: $3 }
  | COMMA or_condition                  { [$2] }

/* oring formation is 'psuedo-associative' */
typeexpr: or_condition { $1 }
or_condition:
  | and_condition OR or_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_orlist (sr,$1 :: $3) 
    }
  | and_condition { $1 }

or_list:
  | and_condition OR or_list              { $1 :: $3 }
  | and_condition                         { [$1] }

/* oring formation is 'psuedo-associative' */
and_condition:
  | not_condition AND and_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_andlist (sr,$1 :: $3) 
    }
  | not_condition { $1 }

and_list:
  | not_condition AND and_list              { $1 :: $3 }
  | not_condition                         { [$1] }

notop:
  | NOT {$1,"lnot"}
not_condition:
  | notop not_condition                 { apl (fst $1) (snd $1) $2 }
  | comparison                          { $1 }

chain_cmp_op:
  | ANDEQEQUAL                         { "eq",$1}
  | ANDNOTEQUAL                        { "ne",$1} 
  | ANDLESS                            { "lt",$1}
  | ANDGREATER                         { "gt",$1} 
  | ANDLESSEQUAL                       { "le",$1}
  | ANDGREATEREQUAL                    { "ge",$1}

cmp_item:
  | chain_cmp_op sum                   { $1,$2 }

cmp_item_list:
  | cmp_item cmp_item_list             { $1 :: $2 }
  | cmp_item                           { [$1] }

cmp_op:
  | EQEQUAL                            { "eq",$1 }
  | NOTEQUAL                           { "ne",$1 }
  | LESS                               { "lt",$1 }
  | GREATER                            { "gt",$1 }
  | LESSEQUAL                          { "le",$1 }
  | GREATEREQUAL                       { "ge",$1 }
  | ISIN                               { "_isin",$1 } 
    /* hack */

comparison:
  | sum cmp_op sum cmp_item_list
    {
      let dummy_sr:range_srcref = ("",0,0,0,0) in
      let unit_tuple:expr_t = `AST_tuple (dummy_sr,[]) in
      let sr:range_srcref = rsrange (src_of_expr $1) (src_of_expr (snd (list_last $4))) in
      let si i = string_of_int i in
      let nm s = `AST_name (dummy_sr,s,[]) in
      let rec p n lst = 
        match lst with
        | [] -> [] 
        | ((op,opsrc),ex) :: t ->
           `AST_val_decl(slift opsrc,"_t"^si (n+1), dfltvs,None, Some ex)
           ::
           `AST_val_decl
           (
             slift opsrc,
             "_r"^si (n+1),
             dfltvs,
             None,
             Some 
             (
               apl2 opsrc "land" 
               [
                 nm ("_r"^si n);
                 apl2 opsrc op 
                 [
                   nm ("_t"^si n);
                   nm ("_t"^si (n+1))
                 ]
               ]
             )
           )
           :: 
           p (n+1) t
      in 
      let stmts = 
        let n = List.length $4 in
        `AST_val_decl (src_of_expr $3,"_t0",dfltvs,None,Some $3) ::
        `AST_val_decl 
        (
          rsrange (src_of_expr $1) (src_of_expr $3),
          "_r0",dfltvs,
          None,
          Some (apl2 (snd $2) (fst $2) [$1; nm "_t0"])
        ) 
        ::
        p 0 $4
        @
        [`AST_fun_return (sr,`AST_name(sr,"_r"^si n,[]))]
      in
      `AST_apply
      (
        sr,
        (
          `AST_lambda (sr,(dfltvs,[[],None],flx_bool, stmts)),
          unit_tuple
        )
      )
    }
  | sum cmp_op sum                      { apl2 (snd $2) (fst $2) [$1; $3] }
  | as_expr                             { $1 }

as_expr:
  | as_expr AS NAME
    { 
      let sr = rsrange (src_of_expr $1) (slift (fst $3)) in
      `AST_as (sr,($1,snd $3))
    }
  | setunion { $1 }

setunion:
  | user10 VBARVBAR setunion_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_setunion (sr,$1 :: $3) 
    }
  | user10 { $1 }

setunion_list:
  | user10 VBARVBAR setunion_list { $1 :: $3 }
  | user10 { [$1] }

user10:
  | user10 USER10 setintersection 
    { 
      let sr,op,fn = $2 in
      apl2 sr fn [$1;$3]
    }
  | setintersection { $1 }

setintersection:
  | arrow AMPERAMPER setintersection_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_setintersection (sr,$1 :: $3) 
    }
  | arrow { $1 }

setintersection_list:
  | arrow AMPERAMPER setintersection_list { $1 :: $3 }
  | arrow { [$1] }


arrow:
  | case_literal RIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_arrow (sr,($1,$3)) 
    }
  | case_literal LONGRIGHTARROW arrow                
    { 
      let sr = rsexpr $1 $3 in
      `AST_longarrow (sr,($1,$3)) 
    }
  | case_literal { $1 }

case_literal:
  | CASE INTEGER 
    {
      let sr,t,v = $2 in 
      `AST_case_tag (rstoken $1 sr, Big_int.int_of_big_int v)
    } 
  | CASE INTEGER OF sum
    {
      let _,_,v = $2 in 
      `AST_typed_case 
      (
        rsrange (slift $1) (src_of_expr $4),
        Big_int.int_of_big_int v, 
        typecode_of_expr $4
      )
    } 
  | CASE NAME OF sum
    {
      let sr =  rsrange (slift $1) (src_of_expr $4) in
      let s = snd $2 in
      let e = $4 in
      `AST_variant (sr,(s,e))
    } 

  | bor { $1 }

bor:
  | bor SLOSHVBAR bxor { apl2 $2 "bor" [$1;$3] }
  | bxor { $1 }

bxor:
  | bxor SLOSHCIRCUMFLEX band { apl2 $2 "bxor" [$1;$3] }
  | band { $1 }

band:
  | band SLOSHAMPER shift { apl2 $2 "band" [$1;$3] }
  | shift { $1 }

shift:
  | shift LEFTSHIFT sum { apl2 $2 "shl" [$1;$3] }
  | shift RIGHTSHIFT sum { apl2 $2 "shr" [$1;$3] }
  | sum { $1 }

/* sum formation is 'psuedo-associative' */
sum:
  | subtraction PLUS sum_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_sum (sr,$1 :: $3) 
    }
  | subtraction { $1 }

sum_list:
  | subtraction PLUS sum_list { $1 :: $3 }
  | subtraction { [$1] }

subtraction:
  | subtraction MINUS product { apl2 $2 "sub" [$1; $3] }
  | product { $1 }

/* product formation is 'psuedo-associative' */
product:
  | term STAR product_list              
    { 
      let sr = rsrange 
        (src_of_expr $1) 
        (src_of_expr (list_last $3)) 
      in
      `AST_product (sr,$1 :: $3) 
    }
  | term                                { $1 }
product_list:
  | term STAR product_list              { $1 :: $3 }
  | term                                { [$1] }


/* division is left associative: note higher precedence
   the product, so that

   a * b/c * d -> a * (b/c) * d
*/
term:
  | term SLASH power                    { apl2 $2 "div" [$1; $3] }
  | term PERCENT power                  { apl2 $2 "mod" [$1; $3] }
  | prefixed { $1 }

/* note weird recursion here: we need to support
  -x ** -x = -(x**(-x))
*/
prefixed:
  | LVAL power
    { 
      `AST_lvalue
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  /*
  | HASH power  { apl $1 "len" $2 }
  */
  | EXCLAMATION power  { apl $1 "excl" $2 }
  | PLUS power  { apl $1 "pos" $2 }
  | MINUS power { apl $1 "neg" $2 }
  | TILDE power { apl $1 "compl" $2 }
  | power       { $1 }

/* exponentiation is right associative */
power:
  | superscript STARSTAR prefixed      { apl2 $2 "pow" [$1; $3] }
  | superscript { $1 }

superscript:
  | superscript CIRCUMFLEX refr 
    { 
      let sr = rsrange (src_of_expr $1) (src_of_expr $3) in
      `AST_superscript (sr, ($1, $3))
    }

  | refr { $1 }
refr:
  | UNION LBRACE type_sum_items2 RBRACE 
    { 
      let sr = rstoken $1 $4 in
      let ls = map (fun (s,_,vs,t)->s,t) $3 in
      `AST_variant_type (sr,ls)
    }

  | STRUCT compound { 
     let sr = rsrange (slift $1) (fst $2) in
     let es = snd $2 in
     let flag = ref `Unk in
     (* this crud distinguishes "a=e;" from "a:t;"  *)
     let f (stmt:statement_t) = match stmt with
       | `AST_assign (_,sname,(`Name (_,lhs),None), rhs)
       | `AST_assign (_,sname,(`Expr (_,`AST_name (_,lhs,[])),None), rhs) 
         when sname = "_set" -> 
         if !flag = `Unk then flag := `Ex
         else if !flag = `Ty then
          Flx_exceptions.clierr sr 
          "anonymous struct type components require coercions!"
         ;
         lhs,rhs
       | `AST_call (_,`AST_coercion(_,(`AST_name(_,lhs,[]),rhs)),`AST_tuple (_,[])) ->
         if !flag = `Unk then flag := `Ty
         else if !flag = `Ex then
          Flx_exceptions.clierr sr 
          "anonymous struct components require assignments!"
         ;
         lhs,`AST_expr (sr,"dummy",rhs)

       | _ -> Flx_exceptions.clierr sr 
         "anonymous struct components require assignments!"
     in

     let es: (string * expr_t) list = map f es in
     if !flag = `Unk then 
       if length es = 0 then `AST_tuple (sr,[])
       else
         Flx_exceptions.clierr sr 
         "anonymous struct: unrecognizable components!"
     else if !flag = `Ex then 
       (`AST_record (sr,es):> expr_t)
     else if !flag = `Ty then 
       let es : (string * typecode_t) list  = map (fun (lhs,x) ->
         match x with 
         | `AST_expr (_,_,rhs) -> lhs, rhs
         | _ -> assert false
         ) es
       in 
       (`AST_record_type (sr,es) :> expr_t)
     else assert false
   }
  
  | AMPER refr
    { 
      `AST_ref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | STAR refr { apl $1 "deref" $2 }
  | DEREF refr
    { 
      `AST_deref 
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }
  | NEW refr 
    { 
      `AST_new
      (
        rsrange (slift $1) (src_of_expr $2), 
        $2
      ) 
    }

  | application { $1 }

/* applications is left associative */
application:
  | application coercion
    { 
      `AST_apply (rsexpr $1 $2, ($1, $2)) 
    }
/*
  | MAP coercion coercion
    {
      `AST_map (rsrange (slift $1) (src_of_expr $3), $2, $3)
    }
*/
  | CASENO coercion { 
      let sr = rsrange (slift $1) (src_of_expr $2) in
      `AST_case_index (sr,$2) 
    }
    
  | MACRO CTOR NAME coercion 
    {
      let sr = rsrange (slift $1) (src_of_expr $4) in
      `AST_macro_ctor (sr,(snd $3,$4))
    }
    
  | coercion { $1 }


coercion:
  | coercion COLON factor          
    { 
      `AST_coercion (slift $2, ($1, typecode_of_expr $3)) 
    }
  | suffixed_name                  { ($1:>expr_t) }
  | factor                         { $1 }


factor:
  | hash_name                        { ($1:>expr_t) }
  | factor DOT LSQB expr RSQB          { apl2 $3 "subscript" [$1; $4] }
  | factor DOT LSQB expr TO expr RSQB  { apl2 $3 "substring" [$1; $4; $6] }
  | factor DOT LSQB expr TO RSQB       { apl2 $3 "copyfrom" [$1; $4] }
  | factor DOT LSQB TO expr RSQB       { apl2 $3 "copyto" [$1; $5] } 
  | factor DOT simple_name_parts       
    { 
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      `AST_dot (sr, ($1, `AST_name (sr,name,ts))) 
    }
  | factor DOTRIGHTARROW simple_name_parts       
    { 
      let rsr,name,ts = $3 in
      let sr = rsrange (src_of_expr $1) rsr in
      let x = apl $2 "deref" $1 in
      `AST_dot (sr, (x, `AST_name (sr,name,ts))) 
    }
  | factor DOT LPAR INTEGER RPAR
    { 
      match $4 with
      | (sr,t,v) ->
        let n = 
          try Big_int.int_of_big_int v 
          with _ -> 
            failwith 
            (
              "[parser] Tuple index " ^
              Big_int.string_of_big_int v ^
              " too big in " ^ 
              short_string_of_src (slift sr)
             )
        in
          let sr = rsrange (src_of_expr $1) (slift $5) in
          `AST_get_n (sr, (n,$1)) 
    }

hash_name:
  | HASH hash_name { `AST_lift ((slift $1), $2) }
  | the_name { $1 }

the_name:
  | NOEXPAND qualified_name
    { 
      let e = ($2:>expr_t) in
      let sr = src_of_expr e in
      let sr = rsrange (slift $1) sr in
      `AST_noexpand (sr,e) 
    }
  | THE qualified_name
  { 
    let sr = src_of_expr $2 in 
    let sr = rsrange (slift $1) sr in
    let qn = qualified_name_of_expr $2 in
    (`AST_the (sr,qn))
  }
  | qualified_name { $1 }
  | QUEST NAME { `AST_patvar (rstoken $1 (fst $2), snd $2) }
  | atom { $1 }

qualified_name:
  | qualified_name COLONCOLON simple_name_parts
    { 
      match $3 with sr,name,ts ->
      let sr = rsrange (src_of_expr $1) sr in
      `AST_lookup (sr,($1, name, ts))
    }

  | simple_name_parts  
    { 
      match $1 with sr,name,ts -> 
      (`AST_name (sr,name,ts):>expr_t) 
    }

elif:
  | ELIF expr THEN expr { $2,$4 }

elifs:
  | elifs elif { $2 :: $1 }
  | elif { [$1] }

else_part:
  | elifs ELSE expr 
    {
      List.fold_left (* actually a right fold cause list is reversed *)
      (fun result (cond,thn) ->
        let sr = rsrange (src_of_expr cond) (src_of_expr result) in
        `AST_cond 
        (
          sr,
          (
            cond,
            thn,
            result
          )
        )
      )
      $3 $1
    }
  | ELSE expr { $2 }

cond:
  | IF expr THEN expr else_part ENDIF
    { 
      `AST_cond (rstoken $1 $6,($2,$4,$5))
    }

expr_code_prefix:
  | CODE LSQB expr RSQB 
    {
     $1,
     typecode_of_expr $3
    }



atom:
  | UNDERSCORE { `AST_patany (slift $1) }
  | CALLBACK LSQB qualified_name RSQB
    { 
      let sr = rstoken $1 $4 in
      let qn = qualified_name_of_expr $3 in
      `AST_callback (sr,qn)
    }
  
  | DOTDOTDOT { `AST_ellipsis (slift $1) }

  | type_match_expr { $1 }
  | expr_code_prefix NAME
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | expr_code_prefix STRING
    {
      let sr = rstoken (fst $1) (fst $2) in
      let s = snd $2 in
      let t = snd $1 in
      `AST_expr (sr,s,t)
    }

  | LSQBAR expr RSQBAR
    {
      let sr = rstoken $1 $3 in
      match $2 with
      | `AST_tuple (_,ls) -> `AST_arrayof (sr,ls)
      | x -> `AST_arrayof (sr,[x])
    }

  | LBRACE expr RBRACE     
    { 
      let sr = rstoken $1 $3 in
      `AST_lambda 
      (
        sr,
        (
          dfltvs,
          [[],None],
          `TYP_none,
          [`AST_fun_return (sr,$2)]
        ) 
      )
    }
  | glr_parse { $1 }
  | match_expr { $1 }
  | regmatch_expr { $1 }
  | typecase { $1 }
  | compound            
    {
      let sr, stmts = $1 in
      `AST_lambda 
      (
        sr,
        (dfltvs,[[],None], `TYP_none, stmts)
      )
    
    }
  | LPAR expr RPAR      { $2 }
  | LPAR RPAR           { `AST_tuple (rstoken $1 $2,[]) }
  | literal             { $1 }
  | cond                { $1 }
  | FSTRING             
    { 
      let sr,s = $1 in 
      let sr = slift sr in 
      `AST_vsprintf (sr,s) 
    }
  | QSTRING             
    { 
      let sr,s = $1 in 
      let sr = slift sr in 
      `AST_interpolate (sr,s) 
    }
    
  | USERLB expr USERRB  
    {
      let sr1,fnmap,lsym =$1 and sr2,rsym = $3 in
      let sr = rstoken sr1 sr2 in
      try
        let fn = List.assoc rsym fnmap in
        apl2 (fst $3) fn [$2]
      with Not_found ->
        Flx_exceptions.clierr sr "Mismatched brackets"
    }

literal:
  | integer_literal { $1 }
  | string_literal { $1 }
  | float_literal { $1 }

integer_literal:
  | INTEGER 
    { let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_int (t,v)) 
    }

float_literal:
  | FLOAT   
    { 
      let sr,t,v = $1 in
      `AST_literal (slift sr, `AST_float (t,v)) 
    }

string_literal:    
  | STRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_string s) 
    }

  | WSTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_wstring s) 
    }

  | USTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_ustring s) 
    }

  | CSTRING  
    { 
      let sr,s = $1 in
      `AST_literal (slift sr, `AST_cstring s) 
    }

simple_name_parts:
  | NAME LSQB expr RSQB  
    { 
      rsrange (slift (fst $1)) (slift $4),
      snd $1,
      match typecode_of_expr $3 with
      | `TYP_type_tuple ls -> ls
      | x -> [x]
    }

  | identifier { $1 }

identifier:
  | NAME 
    { 
      slift (fst $1), 
      snd $1,
      []
    }

suffixed_name:
  | qualified_name OF factor
    { 
      `AST_suffix
      (
        rsrange (src_of_expr $1) (src_of_expr $3),
        (qualified_name_of_expr $1, typecode_of_expr $3)
      )
    }

epsilon: | {()}

@head(1,'Parser object')
@h = tangler('src/flx_parse_ctrl.ml')
@select(h)

open Flx_ast
open Flx_exceptions
open Flx_parse

let dyphack (ls : ( 'a * Dyp.priority) list) : 'a =
  match ls with
  | [x,_] -> x
  | _ -> failwith "Dypgen parser failed"

let parse_file 
  (filename : string) 
  (basedir :string) 
  (include_dirs : string list) 
  expand_expr
= 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_filename 
      filename 
      basedir
      include_dirs 
      expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
  let hash_include_files, tokens = match tokens with
    | HASH_INCLUDE_FILES fs :: t -> fs,t
    | _ -> assert false
  in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      let parse_tree = 
      try dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with 
      | Failure s ->
        begin
          toker#report_syntax_error;
          print_endline s;
          raise (Flx_exceptions.ParseError ("Failure \""^s^"\" Parsing File"))
        end
      | Flx_exceptions.ClientError _ 
      | Flx_exceptions.ClientError2 _ 
      | Flx_exceptions.ClientErrorn _ as x  ->
        begin
          toker#report_syntax_error;
          raise x
        end

      | Flx_exceptions.RDP_match_fail (sr1,sr2,s) as x  ->
        begin
          toker#report_syntax_error;
          clierr2 sr1 sr2 ("User Syntax Parse Error " ^ s)
        end

      | x -> 
        begin
          toker#report_syntax_error;
          print_endline (Printexc.to_string x);
          raise (Flx_exceptions.ParseError "Unknown exception Parsing File")
        end
      in hash_include_files, parse_tree
    end

let parse_string (data : string) (filename : string) expand_expr = 
  let pre_tokens  = 
    Flx_pretok.pre_tokens_of_string data filename expand_expr
  in
  let tokens  = Flx_lex1.translate pre_tokens in
    begin
      let toker = (new Flx_tok.tokeniser tokens) in
      try 
        dyphack (
        Flx_parse.compilation_unit
        (toker#token_src) 
        (Lexing.from_string "dummy" )
        )
      with _ -> begin
        toker#report_syntax_error;
        raise (Flx_exceptions.ParseError "Parsing String")
      end
    end


@h = tangler('src/flx_parse_ctrl.mli')
@select(h)
open Flx_ast

val parse_file : 
  string -> (* filenames *)
  string ->
  string list ->
  (string -> expr_t -> expr_t) ->
  string list * compilation_unit_t

val parse_string : 
  string -> 
  string -> 
  (string -> expr_t -> expr_t) ->
  compilation_unit_t

@head(1,'Parser test harness')
@h = tangler('src/flxp.ml')
@select(h)
open Flx_mtypes2
open Flx_types
open Flx_version
open Flx_flxopt
open Flx_getopt
;;

let print_help () = print_options(); exit(0)
;;

let run() =
  let raw_options = parse_options Sys.argv in
  let compiler_options = get_felix_options raw_options in

  if check_keys raw_options ["h"; "help"]
  then print_help ()
  ;
  if check_key raw_options "version" 
  then (print_endline ("Felix Version " ^ !version_data.version_string))
  ;

  if compiler_options.print_flag then begin
    print_string "//Include directories = ";
    List.iter (fun d -> print_string (d ^ " "))
    compiler_options.include_dirs;
    print_endline ""
  end
  ;

  let filename = 
    match get_key_value raw_options "" with
    | Some s -> s
    | None -> exit 0
  in
  let filebase = filename in
  let input_file_name = filebase ^ ".flx" in

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline ("Parsing " ^ input_file_name);
    print_endline "---------------------------------------";
  end
  ;

  let _,parse_tree = 
    Flx_parse_ctrl.parse_file 
    input_file_name
    (Filename.dirname input_file_name)
    compiler_options.include_dirs
    Flx_macro.expand_expression
  in
    print_endline (Flx_print.string_of_compilation_unit parse_tree);

  if compiler_options.print_flag then begin
    print_endline "---------------------------------------";
    print_endline "PARSE OK";
    print_endline "---------------------------------------";
  end
  ;

  flush stdout;

in
  run()
;;

