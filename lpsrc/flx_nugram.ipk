@select(tangler("lib/nugram.flxh"))

SCHEME """
(define fold_left
  (lambda (f acc lst) 
    (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst)))))
""";

SCHEME """
(define dfltaux '( (ast_tuple ()) ()))
""";

SCHEME """
(define dfltvs 
  `(
    ()           ;; vs list: name,type,constraint triple 
    ,dfltaux
  ) 
)
""";

SCHEME """
(define mkn1 (lambda (stmt nvs) 
  `(ast_namespace ,(car nvs) ,(cadr nvs) (,stmt))))
""";

SCHEME """
(define mkns (lambda (stmt nvsl) (
  fold_left mkn1 stmt nvsl
  )))
""";

SCHEME """
(define splitapply (lambda (x)
  (if (pair? x) 
    (if (eq? (car x) 'ast_apply) 
      (if (pair? (cddr x)) 
        (begin 
;;           (display "f=")(display (caaddr x))
;;           (display " arg=")(display (cadaddr x))
;;           (display " pair=")(display (caddr x))
           (caddr x))
        (list x ()))
      (list x ()))
    (list ()))
))
""";

SCHEME """
(define mkl (lambda (x)
  (begin 
  ;;(display "mkl x=")(display x)
  (if (pair? x) 
    (if (eq? (car x) 'ast_tuple) 
      (if (pair? (cdr x)) (cadr x) (list x))
      (list x))
    (list x)))
))
""";

SCHEME """
(define mkl2 (lambda (x)
  (begin 
  ;;(display "mkl2 x=")(display x)
  (if (pair? x) 
    (if (eq? (car x) 'ast_product) 
      (if (pair? (cdr x)) (cadr x) (list x))
      (list x))
    (list x)))
))
""";

SCHEME """
(define cal_funkind (lambda (adjs fk)
  (if (eq? fk 'CFunction)'CFunction
  (if (eq? fk 'Generator)'Generator
  ;; fk is Function
  (if (pair? adjs)(car adjs)'Function
)))))
""";

SCHEME """
(define myassoc (lambda (elt alst)
  (let ((r (assoc elt alst)))
  (if r (cadr r) `(MISMATCHED_BRACKET ,elt ,alst)))))
""";

SCHEME """
(define tvfixup_folder (lambda (vsct vtc)
  (begin ;;(display "tvfixup_folder vsct=")(display vsct)(display ", vtc=")(display vtc)(display "\\n")
  (let* 
    (
      (vs (car vsct))
      (ct (cadr vsct))
      (v (car vtc))
      (t (cadr vtc))
      (c (caddr vtc))
      (ct2 
        (cond 
          ((eq? 'NoConstraint c) ct )
          ((eq? 'Eq (car c)) ;; type constraint
            `(ast_intersect
              ((ast_type_match ((ast_name ,v ()) ((,(cadr c) ())))) 
              ,ct)
            )
          )
          ((eq? 'In (car c)) ;; type constraint
            `(ast_intersect
              ((ast_isin ((ast_name ,v ()) ,(cadr c))) 
              ,ct)
            )
          )
        (else (display "ERROR!!!"))
        )
      )
    )
    (begin 
    ;;  (display "vs=")(display vs)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\nv=")(display v)
    ;;  (display "\\nt=")(display t)
    ;;  (display "\\nc=")(display c)
    ;;  (display "\\nct2=")(display ct2)
    ;;  (display "\\n")
    (list (cons `(,v ,t) vs) ct2))
))))
""";

//
// rti = rtc:type constraint, rtr:typeclass requirement list
//

SCHEME """
(define tvfixup (lambda (tv ct)
  (begin ;;(display "tvfixup tv=")(display tv)(display ", ct=")(display ct)(display "\\n")
  (let* 
    (
      (vscs (fold_left tvfixup_folder '(() (ast_tuple ())) tv))
      (vs (car vscs))
      (cs (cadr vscs))
      (rtc (car ct))
      (rtr (cadr ct))
      (ct `((ast_intersect (,rtc ,cs)) ,rtr))
    )
    (begin 
    ;;  (display "vs=")(display vs)
    ;;  (display "\\ncs=")(display cs)
    ;;  (display "\\nrtc=")(display rtc)
    ;;  (display "\\nrtr=")(display rtr)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\n")
    (list (reverse vs) ct))
  )
)))
""";

//------------------------------------------
syntax expressions {
  satom := sliteral;
  satom := _ =># "'ast_patany";
  satom := ... =># "'ast_ellipsis";
  satom := sfalse =># "'(ast_typed_case  0 2)";
  satom := strue =># "'(ast_typed_case  1 2)";
  
  satom := callback lsqb sexpr rsqb =># "`(ast_callback ,_3)";
  satom := [| sexpr |] =># "`(ast_arrayof ,(mkl _2))";
  satom := lbrace sexpr rbrace =># """
    `(ast_lambda (,dfltvs ((() none)) typ_none ((ast_fun_return ,_sr ,_2))))
  """;

  satom := match sexpr with smatching+ endmatch =># 
    "`(ast_match (,_2 ,_4))";

    smatching  := vbar spattern => sexpr =># "`(,_2 ,_4)";
    smatching  := vbar => sexpr =># "`(pat_none ,_4)";

  satom := typematch sexpr with stype_matching+ endmatch =># 
    "`(ast_type_match (,_2 ,_4))";

    stype_matching  := vbar sexpr => sexpr =># "`(,_2 ,_4)";

    satomic_pattern := strue =># "'(pat_const_ctor (ast_case_tag 1))";
    satomic_pattern := sfalse =># "'(pat_const_ctor (ast_case_tag 0))";
    satomic_pattern := sstring =># "`(pat_string ,_1)";
    satomic_pattern := quest sname =># "`(pat_as pat_any ,_2)";
    satomic_pattern := _ =># "'pat_any";
    satomic_pattern := lpar spattern rpar =># "_2";
    satomic_pattern := struct lbrace spat_assigns rbrace =># "`(pat_record ,_3)";
      spat_assign := sname = spattern ; =># "`(,_1 ,_3)";
      spat_assigns := spat_assign =># "`(,_1)";
      spat_assigns := spat_assign spat_assigns =># "(cons _1 _2)";

    satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
    satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";
      sctor_name := squalified_name =># "_1";
      sctor_name := case sinteger =># "`(ast_case_tag ,_2)";

    satomic_pattern := sstring .. sstring =># "`(pat_string_range ,_1 ,_3)";
    satomic_pattern := sintegral =># "`(pat_int ,(car _1) ,(cadr _1))";
    satomic_pattern := sintegral .. sintegral=># 
      "`(pat_int_range ,(car _1) ,(cadr _1) ,(car _3) ,(cadr _3))";

    satomic_pattern := NaN =># "'pat_nan";
    satomic_pattern := sfloating .. sfloating =># 
      "`(pat_float_range ,_1 ,_3)";

      sfloating:= sfloat =># "`(Float_plus ,(car _1) ,(cadr _1))";
      sfloating:= - sfloat =># "`(Float_minus ,(car _2) ,(cadr _2))";
      sfloating:= inf =># "'Float_inf";
      sfloating:= - inf =># "'Float_minus_inf";

    scoercive_pattern := satomic_pattern =># "_1";
    scoercive_pattern := satomic_pattern : sarrow =># "`(pat_coercion ,_1 ,_2)";

    stuple_pattern := scoercive_pattern =># "_1";
    stuple_pattern := scoercive_pattern stuple_pattern_suffix =># 
      "`(pat_tuple ,(cons _1 _2))";

      stuple_pattern_suffix := , scoercive_pattern =># "`(,_2)";
      stuple_pattern_suffix := , scoercive_pattern stuple_pattern_suffix =># 
        "(cons _2 _3)";

    sas_pattern := stuple_pattern =># "_1";
    sas_pattern := stuple_pattern as sname =># "`(pat_as ,_1 ,_3)";

    spattern := sas_pattern =># "_1";
    spattern := sas_pattern when sexpr =># "`(pat_when ,_1 ,_3)";

  satom := scompound =># "`(ast_lambda (,dfltvs ((() none)) none ,_1))";

  satom := lpar sexpr rpar =># "_2";
  satom := lpar rpar =># "'()";

  satom := if sexpr then sexpr selse_part endif =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

    selif := elif sexpr then sexpr =># "`(,_2 ,_4)";

    selifs := selif =># "`(,_1)";
    selifs := selifs selif =># "(cons _2 _1)";

    selse_part:= else sexpr =># "_2";
    selse_part:= selifs else sexpr =># 
      """
        (let ((f (lambda (result condthn) 
          (let ((cond (car condthn)) (thn (cadr condthn))) 
            `(ast_cond (,cond ,thn ,result))))))
        (fold_left f _3 _1))
      """;

  satom := suserlbtoken sexpr suserrbtoken =>#
    "`(ast_apply ,_sr ((ast_name ,(myassoc _3 (car _1)) ()) ,_2))";

  ssimple_name_parts := sname           =># "`(,_1 ())";
  ssimple_name_parts := sname lsqb sexpr rsqb =># "`(,_1 ,(mkl _3))";

  squalified_name := squalified_name :: ssimple_name_parts =># 
    "`(ast_lookup (,_1 ,(car _3) ,(cadr _3)))";
  squalified_name := ssimple_name_parts =># 
    "`(ast_name ,(car _1) ,(cadr _1))";

  ssuffixed_name := squalified_name of sfactor =># 
    "`(ast_suffix (,_1 ,_3))";

  sthe_name := satom;
  sthe_name := 
    | the squalified_name =># "`(ast_the ,_2)"
    | noexpand squalified_name =># "`(ast_noexpand ,_2)"
    | quest sname =># "`(ast_patvar ,_2)"
    | squalified_name =># "_1"
  ;

  shash_name := sthe_name =># "_1";
  shash_name := # shash_name =># "`(ast_lift ,_2)";

  sfactor := shash_name =># "_1";
  sfactor := sfactor . lsqb sexpr rsqb =># "`(ast_apply ,_sr (subscript (,_1 ,_4)))";
  sfactor := sfactor . lsqb sexpr to sexpr rsqb =># "`(ast_apply ,_sr (substring (,_1 ,_4 ,_6)))";
  sfactor := sfactor . lsqb sexpr to rsqb =># "`(ast_apply ,_sr (copyfrom (,_1 ,_4)))";
  sfactor := sfactor . lsqb to sexpr rsqb =># "`(ast_apply ,_sr (copyto (,_1 ,_5)))";
  sfactor := sfactor . ssimple_name_parts =># 
    "`(ast_dot (,_1 (ast_name ,(car _3) ,(cadr _3))))";

  sfactor := sfactor .-> ssimple_name_parts =># 
    "`(ast_dot ((ast_apply ,_sr (deref ,_1)) (ast_name (,(car _3) ,(cadr _3)))))";

  sfactor := sfactor . lpar sinteger rpar =># "`(ast_get_n (,_4 ,_1))";

  scoercion := sfactor =># "_1";
  scoercion := scoercion : sfactor =># "`(ast_coercion (,_1 ,_3))";
  scoercion := ssuffixed_name =># "_1";

  sapplication := scoercion =># "_1";
  sapplication := sapplication scoercion =># "`(ast_apply ,_sr (,_1 ,_2))";
  sapplication := caseno scoercion =># "`(ast_case_index ,_2)";

  srefr := sapplication =># "_1";
  // todo anonymous union
  // todo anonymous struct
  srefr := & srefr =># "`(ast_ref ,_2)";
  srefr := star srefr =># "`(ast_apply ,_sr (deref ,_2))";
  srefr := _deref srefr =># "`(ast_deref ,_2)";
  srefr := new srefr =># "`(ast_new ,_2)";
  srefr := struct lbrace sstruct_mem_decl* rbrace =># "`(ast_record_type ,_3)";
    sstruct_mem_decl := sname : sexpr ; =># "`(,_1 ,_3)";
  srefr := struct lbrace sstruct_assign* rbrace =># "`(ast_record ,_3)";
    sstruct_assign := sname = sexpr ; =># "`(,_1 ,_3)";

  srefr := union lbrace stype_sum_item0* rbrace =># "`(ast_variant_type ,_3)";
    stype_sum_item := sname sopt_value stvarlist of sexpr =># "`(,_1 ,_2 ,_3 ,_5)";
    stype_sum_item := sname sopt_value stvarlist =># "`(,_1 ,_2 ,_3 ast_void)";

    stype_sum_item0 := sname of sexpr =># "`(,_1 none ,_3)";
    stype_sum_item0 := sname =># "`(,_1 none ast_void)";

    stype_sum_item1 := stype_sum_item ; =># "_1";

    stype_sum_item2 := vbar stype_sum_item =># "_2";
    stype_sum_items2 := stype_sum_item stype_sum_item2* =># "(cons _1 _2)";
    stype_sum_items2 := stype_sum_item2* =># "_1";

  ssuperscript := srefr =># "_1"; 
  ssuperscript := ssuperscript ^ srefr =># "`(ast_superscript (,_1 ,_3))"; 

  spower := ssuperscript  =># "_1"; 
  spower := ssuperscript ** sprefixed =># "`(ast_apply ,_sr (pow (,_1 ,_3)))"; 

  sprefixed := spower =># "_1";
  sprefixed := lval spower =># "`(ast_lvalue ,_2)";
  sprefixed := ! spower =># "`(ast_apply ,_sr (excl ,_2))";
  sprefixed := plus spower =># "`(ast_apply ,_sr (pos ,_2))";
  sprefixed := - spower =># "`(ast_apply ,_sr (neg ,_2))";
  sprefixed := ~ spower =># "`(ast_apply ,_sr (compl ,_2))";

  s_term := sprefixed =># "_1";
  s_term := s_term / spower =># "`(ast_apply ,_sr (div (,_1 ,_3)))";
  s_term := s_term % spower =># "`(ast_apply ,_sr (mod (,_1 ,_3)))";

  sproduct :=  s_term =># "_1";
  sproduct := s_term star sproduct_list =># "`(ast_product ,(cons _1 _3))";
    sproduct_list := s_term star sproduct_list =># "(cons _1 _3)";
    sproduct_list := s_term =># "`(,_1)";
  
  ssubtraction := sproduct =># "_1";
  ssubtraction := ssubtraction - sproduct =># "`(ast_apply ,_sr (sub (,_1 ,_3)))";

  ssum :=  ssubtraction =># "_1";
  ssum := ssubtraction plus ssum_list =># "`(ast_sum ,(cons _1 _3))";
    ssum_list := ssubtraction plus ssum_list =># "(cons _1 _3)";
    ssum_list := ssubtraction =># "`(,_1)";

  sshift := ssum =># "_1";
  sshift := sshift << ssum =># "`(ast_apply ,_sr (shl (,_1 ,_3)))";
  sshift := sshift >> ssum =># "`(ast_apply ,_sr (shr (,_1 ,_3)))";

  sband :=  sshift =># "_1";
  sband := sband \& sshift =># "`(ast_apply ,_sr (band (,_1 ,_3)))";

  sbxor := sband =># "_1";
  sbxor := sbxor \^ sband =># "`(ast_apply ,_sr (bxor (,_1 ,_3)))";

  sbor := sbxor =># "_1";
  sbor := sbor \| sbxor =># "`(ast_apply ,_sr (bor (,_1 ,_3)))";

  scase_literal := sbor =># "_1";
  scase_literal := case sinteger =># "`(ast_case_tag ,_2))";
  scase_literal := case sinteger of ssum =># "`(ast_typed_case ,_2 ,_4)";
  scase_literal := case sname of ssum =># "`(ast_variant (,_2 ,_4))";
  
  sarrow := scase_literal =># "_1";
  sarrow := scase_literal -> sarrow =># "`(ast_arrow (,_1 ,_3))";
  sarrow := scase_literal --> sarrow =># "`(ast_longarrow (,_1 ,_3))";

  ssetintersection:= sarrow =># "_1";
  ssetintersection := sarrow && ssetintersection_list =># "`(ast_setintersection ,(cons _1 _3))";
    ssetintersection_list := sarrow =># "`(,_1)";
    ssetintersection_list := sarrow && ssetintersection_list =># "(cons _1 _3)";

  suser10 := ssetintersection =># "_1";
  suser10 := suser10 suser10token ssetintersection =># 
    "`(ast_apply ,_sr ( (ast_name ,_2 ()) (,_1 ,_3)))";

  ssetunion := suser10 =># "_1";
  ssetunion := suser10 || ssetunion_list =># "`(ast_setunion ,(cons _1 _3))";
    ssetunion_list := suser10 =># "`(,_1)";
    ssetunion_list := suser10 || ssetunion_list =># "(cons _1 _3)";

  sas_expr := ssetunion =># "_1";
  sas_expr := sas_expr as sname =># "`(ast_as (,_1 ,_3))";

  // NOTE: this version doesn't support chains like a < b < c.. too bad
  scomparison:= sas_expr =># "_1";
  scomparison:= sas_expr < sas_expr =># "`(ast_apply ,_sr (lt (,_1 ,_3)))";
  scomparison:= sas_expr <= sas_expr =># "`(ast_apply ,_sr (le (,_1 ,_3)))";
  scomparison:= sas_expr == sas_expr =># "`(ast_apply ,_sr (eq (,_1 ,_3)))";
  scomparison:= sas_expr != sas_expr =># "`(ast_apply ,_sr (ne (,_1 ,_3)))";
  scomparison:= sas_expr >= sas_expr =># "`(ast_apply ,_sr (ge (,_1 ,_3)))";
  scomparison:= sas_expr > sas_expr =># "`(ast_apply ,_sr (gt (,_1 ,_3)))";

  snot_condition := scomparison  =># "_1";
  snot_condition := not snot_condition  =># "`(ast_apply ,_sr (lnot ,_2))";

  sand_condition := snot_condition =># "_1";
  sand_condition := snot_condition and sand_list =># "`(ast_andlist ,(cons _1 _3))";
    sand_list := snot_condition and sand_list =># "(cons _1 _3)";
    sand_list := snot_condition =># "`(,_1)";

  sor_condition := sand_condition =># "_1";
  sor_condition := sand_condition or sor_list =># "`(ast_orlist ,(cons _1 _3))";
    sor_list := sand_condition or sor_list =># "(cons _1 _3)";
    sor_list := sand_condition =># "`(,_1)";

  stypeexpr:= sor_condition =># "_1";

  stuple := sor_condition  =># "_1";
  stuple := sor_condition stuple_suffix =># "`(ast_tuple ,(cons _1 _2))";
    stuple_suffix:= , sor_condition stuple_suffix =># "(cons _2 _3)";
    stuple_suffix:= , sor_condition  =># "`(,_2)";
  
  sdollar_apply := stuple =># "_1";
  sdollar_apply := stuple unless sexpr then sdollar_apply =>#
    "`(ast_cond ((ast_apply ,_sr (lnot ,_3)) ,_1 ,_5))";
  sdollar_apply := stuple $ sdollar_apply =># "`(ast_apply ,_sr (,_1 ,_3))";

  slambda := sdollar_apply =># "_1";
  slambda := sadjectives fun stvarlist slambda_fun_args sopt_type_expr = scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ,_7))
    """;

  slambda := sadjectives fun stvarlist slambda_fun_args sopt_type_expr => sexpr =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ((ast_fun_return ,_sr ,_7))))
    """;

  slambda := sadjectives proc stvarlist slambda_fun_args scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ast_void ,_5))
    """;

  slambda := sadjectives proc stvarlist scompound =>#
    """
    `(ast_lambda (,_3 ((() none)) ast_void ,_4))
    """;

    sadjective := inline =># "'InlineFunction";
    sadjective := noinline =># "'NoInlineFunction";
    sadjective := virtual =># "'Virtual";
    sadjectives := sadjective* =># "_1";

    slambda_fun_arg := lpar sparameter_comma_list when sexpr rpar =># "`(,_2 (some ,_4))";
    slambda_fun_arg := lpar sparameter_comma_list rpar =># "`(,_2 none)";
    slambda_fun_args := slambda_fun_arg+ =># "_1";

    sopt_type_expr := : sexpr expect sexpr =># "`(,_2 (some ,_4))";
    sopt_type_expr := : sexpr =># "`(,_2 none)";
    sopt_type_expr := expect sexpr =># "`(typ_none (some ,_2))";
    sopt_type_expr := sepsilon =># "'(typ_none none)";

    sparameter := sparam_qual sname : sarrow =># "`(,_1 ,_2 ,_4)";
    sparameter := sparam_qual sname =># "`(,_1 ,_2 typ_none)";
    sparameter_comma_list := sepsilon =># "()";
    sparameter_comma_list := sparameter , sparameter_comma_list =># "(cons _1 _3)";
    sparameter_comma_list := sparameter =># "`(,_1)";


    sparam_qual := val =># "'PVal";
    sparam_qual := var =># "'PVar";
    sparam_qual := ref =># "'PRef";
    sparam_qual := fun =># "'PFun";
    sparam_qual := sepsilon =># "'PVal";

  srvalue := slambda  =># "_1";

  sexpr := srvalue =># "_1";
  sexpr := let spattern = sexpr in sexpr =># "`(ast_letin (,_2 ,_4 ,_6))"; 
}

//------------------------------------------
syntax regexps {
  requires expressions;
  satom := sregmatch_expr =># "_1";
  sdirective := sregdef =># "_1";

  sregmatch_expr := reglex sexpr to sexpr with sregmatch_alternatives endmatch =>#
    "`(ast_reglex (,_2 ,_4 ,_6))";
  sregmatch_expr := regmatch sexpr with sregmatch_alternatives endmatch =>#
    "`(ast_string_regmatch (,_2 ,_4))";
  
  sregmatch_alternatives := sregmatch_alternative + =># "(reverse _1)";
  sregmatch_alternative := vbar sre1 => sexpr =># "`(,_2 ,_4)";

  sregdef := regexp sname = sre1 ; =># "`(ast_regdef ,_sr ,_2 ,_4)";
  sre0 := sre1 as sname =># "`(regexp_group ,_3 ,_1)";
  sre0 := sre1 =># "_1";

  sre1 := sre1 vbar sre2 =># "`(regexp_alt ,_1 ,_3)";
  sre1 := sre2 =># "_1";

  sre2 := sre2 sre3 =># "`(regexp_seq ,_1 ,_2)";
  sre2 := sre3 =># "_1";

  sre3 := sre4 star =># "`(regexp_aster ,_1)";
  sre3 := sre4 plus =># "`(regexp_seq ,_1 (regexp_aster ,_1))";
  sre3 := sre4 quest =># "`(regexp_alt regexp_epsilon ,_1)";
  sre3 := sre4 =># "_1";

  sre4 := sstring =># "`(regexp_string ,_1)";
  sre4 := _ =># "'regexp_underscore";
  sre4 := . =># "'regexp_dot";
  sre4 := lpar sre0 rpar =># "_2";
  sre4 := lsqb scharset rsqb =># "`(regexp_of_charset ,_2)";
  sre4 := lsqb ^ scharset rsqb =># "`(regexp_of_charset (charset_inv ,_3))";
  sre4 := sre_name =># "`(regexp_name ,_1)";

  sre_name := sre_name :: sname =># "`(ast_lookup (,_1 ,_3 ()))";
  sre_name := sname =># "`(ast_name ,_1 ())";

  scharset0:= sinteger - sinteger =># "`(charset_of_int_range ,_1 ,_3)";
  scharset0:= sstring - sstring =># "`(charset_of_range ,_1 ,_3)";
  scharset0:= sstring =># "`(charset_of_string ,_1)";
  scharset0:= sinteger =># "`(charset_of_int_range ,_1 ,_1)";
 
  scharset:= scharset scharset0 =># "`(charset_union ,_1 ,_2)";
  scharset:= scharset0 =># "_1";

}

//------------------------------------------
syntax parsing {
  requires expressions, statements;
  satom := sglr_parse =># "_1";
  sdirective := sglr_production =># "_1";

  sglr_term := squalified_name =># "`(GLR_name ,_1)";
  sglr_term := lbrace sglr_alternatives rbrace =># "`(GLR_ast ,_2)";
  sglr_term := lpar sglr_alternatives rpar =># "_2";
  sglr_term := sglr_term quest =># "`(GLR_opt ,_1)";
  sglr_term := sglr_term star =># "`(GLR_ast ,_1)";
  sglr_term := sglr_term plus =># "`(GLR_plus ,_1)";

  sglr_alternatives := sglr_sequence vbar sglr_alts =># "`(GLR_alt ,(cons _1 _3))";
  sglr_alternatives := sglr_sequence =># "_1";

  sglr_alts := sglr_sequence vbar sglr_alts =># "(cons _1 _3)";
  sglr_alts := sglr_sequence =># "`(,_1)";

  sglr_sequence:= sglr_term sglr_seqs =># "`(GLR_seq ,(cons _1 _2))";
  sglr_sequence:= sglr_term =># "_1";

  sglr_seqs := sglr_term sglr_seqs =># "(cons _1 _2)";
  sglr_seqs := sglr_term =># "`(,_1)";

  sglr_entry:= sname colon sglr_term =># "`((some ,_1) ,_3)";
  sglr_entry:= sglr_term =># "`(none ,_1)";

  sglr_entries:= sglr_entry sglr_entries =># "(cons _1 _2)";
  sglr_entries:= sglr_entry =># "`(,_1)";

  sglr_matching:= vbar sglr_entries => sexpr =># "`(,_2 ,_4)";
  sglr_matching:= vbar => sexpr =># "`(() ,_3)";

  sglr_matchings:= sglr_matching sglr_matchings =># "(cons _1 _2)";
  sglr_matchings:= sglr_matching =># "`(,_1)";

  sglr_production:= nonterm sname colon sexpr = sglr_matchings ssemi =>#
  "`(ast_glr ,_sr ,_2 ,_4 ,_6)";

  sglr_parse:= parse sexpr with sglr_matchings endmatch =>#
  "`(ast_parse ,_sr ,_2 ,_4)";
}

syntax typing {
  satom := typecase_expr =># "_1";
}

//------------------------------------------
syntax statements {
  requires expressions;
  statement:= sdeclarative =># "_1"; 
  statement:= sinclusion =># "_1"; 
  statement:= sdirective =># "_1"; 
  statement:= spublish =># "_1"; 
  statement:= scomment =># "_1"; 
  statement:= snull_statement =># "_1"; 
  //statement:= suser_statement =># "_1"; 
  statement:= scparse =># "_1"; 

  scomment := comment sstring ; =># "`(ast_nop ,_sr ,_2)";
 
 
  spublish := private sdeclarative =># "`(ast_private ,_2)";
  spublish := private sbinding_definition =># "`(ast_private ,_2)";
  spublish := private svar_def =># "`(ast_private ,_2)";
  spublish := private sval_def =># "`(ast_private ,_2)";

#keyword publish  
  spublish := publish sstring statement =># "_3";

  sdeclarative := sfunction_definition =># "_1";
  sdeclarative := sobject_definition =># "_1";
  sdeclarative := sprocedure_definition =># "_1";
  sdeclarative := smodule_definition =># "_1";
  sdeclarative := sunion_decl =># "_1";
  sdeclarative := sstruct_decl =># "_1";
  sdeclarative := stype_alias =># "_1";

  sdirective := sopen_decl =># "_1";
  sdirective := suse_decl =># "_1";

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  snull_statement := ; =># """`(ast_nop ,_sr "")""";

  sinclusion := include sstring ; =># "`(ast_include ,_sr ,_2)";
  scparse := cparse sstring ; =># "`(ast_cparse ,_sr ,_2)";

  // note: list is reversed, eg X::Y::name goes to list name, Y, Z
  sdeclname := sdeclname :: sname stvarlist =># "(cons `(,_3 ,_4) _1)";
  sdeclname := sname stvarlist =># "`((,_1 ,_2))";

  sabstract_type := stype_quals type sdeclname = new sexpr ; =>#
    """
    (mkns 
    `(ast_newtype ,_sr ,(caar _3) ,(cadar _3) ,_6)
    (cdr _3))
    """; 

  sabstract_type := callback proc sname : sexpr srequires_clause ; =>#
    """
    `(ast_callback_decl ,_sr ,_3 ,(mkl2 _5) ast_void ,_6)
    """; 


  sabstract_type := callback fun sname : sexpr srequires_clause ; =>#
    """
    (if (eq? 'ast_arrow (car _5))
      (let* 
        (
          (ft (cadr _5))
          (dom (car ft))
          (cod (cadr ft))
          (args (mkl2 dom))
        )
      `(ast_callback_decl  ,_sr,_3 ,args ,cod ,_6)
      )
      'ERROR
    )
    """; 

  sbasic_name_comma_list:= sname scomma_name* =># "(cons _1 _2)";
  scomma_name:= , sname =># "_2";

  squalified_name_comma_list:= squalified_name scomma_qualified_name* =>#
    "(cons _1 _2)";
  scomma_qualified_name := , squalified_name =># "_2";

  stype_constraint := with squalified_name_comma_list where sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := where sexpr with squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := where sexpr =># "`(,_2 ())";
  stype_constraint := with squalified_name_comma_list =># "`((ast_tuple()) ,_2)";
  stype_constraint := sepsilon =># "'((ast_tuple())())";

  seqorin:= = stypeexpr =># "`(Eq ,_2)";
  seqorin:= in stypeexpr =># "`(In ,_2)";
  seqorin:= sepsilon =># "'NoConstraint"; 

  stvar := sname seqorin =># """`(,_1 (ast_name "TYPE" ()) ,_2)""";
  stvar := sname : stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := , stvar =># "_2";

  stvarlist:= sepsilon =># "dfltvs";
  stvarlist:= lsqb stvar_comma_list stype_constraint rsqb =>#
    "(tvfixup _2 _3)";

  stypeparameter:= sname : sarrow =># "`(,_1 ,_3)";
  stypeparameter:= sname =># "`(,_1 typ_none)";
  stypeparameter_comma_list := sepsilon =># "()";
  stypeparameter_comma_list := stypeparameter , stypeparameter_comma_list =># "(cons _1 _3)";
  stypeparameter_comma_list := stypeparameter =># "`(,_1)";

  stypefun_arg := sname =># "`((,_1 typ_none))";
  stypefun_arg := lpar stypeparameter_comma_list rpar =># "_2";
  stypefun_args := stypefun_arg+  =># "_1";

  stodo := todo sstring ; =># "`(ast_nop ,_sr ,_2)";
  stodo := todo ; =># """`(ast_nop ,_sr "todo")""";

  scompound := lbrace statement* rbrace =># "_2";

  sname_suffix:= comma sname sname_suffix =># "(cons _2 _3)";
  sname_suffix:= comma sname =># "`(,_2)";

  sval_def := val sname sname_suffix = sexpr ; =># 
  """
  (let 
    (
      (names (cons _2 _3))
      (vals (mkl _5))
    )
    (begin 
    ;;(display "names=")(display names)
    ;;(display "init=")(display vals)
    ;;(display "\\n")
    (if (eq? (length names)(length vals))
      (let  
        (
          (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
        )
        `(ast_seq ,(map f names vals))
      )
      (let* 
        (
          (f (lambda (n)`((Val ,n) none)))
          (lexpr (map f names))
        )
        `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
      )
  )))
  """;
 
  sval_def := val sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """; 

  sval_def := val sdeclname : sexpr = sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """; 

  sval_def := val sdeclname : sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) none)
    (cdr _2))
     """; 

  sval_def := ref sdeclname <- sexpr ; =>#
    """
    (mkns 
    `(ast_ref_decl ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """; 

  sval_def := ref sdeclname : sexpr <- sexpr ; =>#
    """
    (mkns 
    `(ast_ref_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """; 

  svar_def := var sname sname_suffix = sexpr ; =># 
  """
  (let 
    (
      (names (cons _2 _3))
      (vals (mkl _5))
    )
    (begin 
    ;;(display "names=")(display names)
    ;;(display "init=")(display vals)
    ;;(display "\\n")
    (if (eq? (length names)(length vals))
      (let  
        (
          (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
        )
        `(ast_seq ,(map f names vals))
      )
      (let* 
        (
          (f (lambda (n)`((Var ,n) none)))
          (lexpr (map f names))
        )
        `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
      )
  )))
  """;
  
  svar_def := var sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """; 

  svar_def := var sdeclname : sexpr = sexpr ; =>#
    """
    (mkns 
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """; 

  svar_def := var sdeclname : sexpr ; =>#
    """
    (mkns 
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) none)
    (cdr _2))
     """; 

  svar_def := var & sname stvarlist : sexpr <- sexpr ; =># 
     """
   (let* (
     (fl (splitapply _8))
     (f (car fl))
     (a (cadr fl))
     (nua (cons `(ast_ref (ast_name ,_3 ())) (mkl a)))
     (call `(ast_call ,_sr ,f ,nua))
     (vardef `(ast_var_decl ,_sr ,_3 ,_4 (some ,_6) none))
     (seq `(ast_seq (,vardef ,call))))
     (begin 
     ;;(display "f=")(display f)
     ;;(display "\\n_3=")(display _3)
     ;;(display "\\na=")(display a)
     ;;(display "\\nnua=")(display nua)
     ;;(display "\\ncall=")(display call)
     ;;(display "\\nvardef=")(display vardef)
     ;;(display "\\nseq=")(display seq)
     ;;(display "\\n")
     seq))
     """; 
 

  svar_def := var sdeclname : sexpr <- sexpr ; =># 
   """
   (let* 
     (
       (fl (splitapply _6))
       (f (car fl))
       (a (cadr fl))
       (name (caar _2))
       (vs (cadar _2))
       (namespace (cdr _2))
       (typ _4)
       (nua (cons `(ast_name ,name ()) (mkl a)))
       (call `(ast_call ,_sr ,f ,nua))
       (vardef `(ast_var_decl ,_sr ,name ,vs (some ,typ) none))
       (seq `(ast_seq (,vardef ,call)))
     )
     (begin 
     ;;(display "f=")(display f)
     ;;(display "\\na=")(display a)
     ;;(display "\\nname=")(display name)
     ;;(display "\\nvs=")(display vs)
     ;;(display "\\ntyp=")(display typ)
     ;;(display "\\nnua=")(display nua)
     ;;(display "\\ncall=")(display call)
     ;;(display "\\nvardef=")(display vardef)
     ;;(display "\\nseq=")(display seq)
     ;;(display "\\nnamespace=")(display namespace)
     ;;(display "\\n")
     (mkns seq namespace)
     ))
     """; 

  sfun_arg :=  ( sparameter_comma_list when sexpr ) =># "`(,_2 (some ,_4))";
  sfun_arg :=  ( sparameter_comma_list ) =># "`(,_2 none)";
  sfun_arg :=  sname =># "`(((PVal ,_1 typ_none)) none)";

  sfun_kind := cfun =># "'CFunction";
  sfun_kind := gen =># "'Generator";
  sfun_kind := fun =># "'Function";

  sfunction_definition := sadjectives sfun_kind sdeclname 
    sfun_arg* sopt_type_expr => sexpr ; =>#
  """
    (let ((body `((ast_fun_return ,_sr ,_7))))
    (mkns 
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,body)
    (cdr _3)))
  """;


  sfunction_definition := sadjectives sfun_kind sdeclname 
    sfun_arg* sopt_type_expr = scompound =>#
  """
    (mkns 
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,_7)
    (cdr _3))
  """;

  sopt_cstring := = scode_spec =># "`(some ,_2)";
  sopt_cstring := sepsilon =># "'none";

  sopt_prec := is sname =># "_2";
  sopt_prec := sepsilon =># '(quote "")';


  sfunction_definition := sadjectives sfun_kind sdeclname 
    sopt_type_expr = smatching+ ; =>#
  """
   (let 
     (
      (t (car _4))
      (traint (cadr _4))
     )
    (begin ;;(display "ftype=")(display t)(display "\\n")
    (if (eq? 'ast_arrow (car t))
      (let 
        (
          (argt (caadr t))
          (ret (cadadr t))
          (body `((ast_fun_return ,_sr (ast_match (_a ,_6)))))
        )
        (mkns 
        `(ast_curry ,_sr ,(caar _3) ,(cadar _3) 
          ( 
            (((PVal _a ,argt)) none)
          )
          (,ret ,traint) 
          ,(cal_funkind _1 _2) ,body)
        (cdr _3))
      )
      'ERROR
     )
     )
   )
  """;

  sproc_kind := proc =># "'Function";
  sproc_kind := cproc =># "'CFunction";

  sopt_traint_eq:= expect sexpr = =># "`(some ,_2)";
  sopt_traint_eq:= sepsilon =># "'none";

  sctor_init := sname lpar sexpr rpar =># "`(,_1 ,_3)";
  sctor_init_list := sctor_init , sctor_init_list =># "(cons _1 _3)";
  sctor_init_list :=  sctor_init =># "`(,_1)";
  sctor_inits := : sctor_init_list =># "_2";
  sctor_inits := sepsilon =># "()";

  sprocedure_definition := ctor stvarlist sfun_arg* sopt_traint_eq 
    sctor_inits scompound =>#
  """
  (let* 
    (
      (name "__constructor__")
      (vs _2)
      (ret 'ast_void)
      (traint _4)
      (body _6)
      (inits _5)
      (args _3)
      (f (lambda (ne)`(ast_init ,_sr ,(car ne) ,(cadr ne))))
      (body (append (map f inits) body))
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Ctor ,body))
  """;

  sprocedure_definition := sadjectives sproc_kind sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns 
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) ,(cal_funkind _1 _2) ,_6)
    (cdr _3))
  """;

  sobject_definition := obj sdeclname sfun_arg+ scompound =>#
  """
    (mkns 
    `(ast_curry ,_sr ,(caar _2) ,(cadar _2) ,_3 (typ_none none) Object ,_4)
    (cdr _2))
  """;

}

//------------------------------------------
syntax macros {
  requires expressions, statements;

  sdirective := smacro_definition =># "_1";
  smacro_definition := macro sname is sbasic_name_comma_list ; =># 
    "`(ast_macro_names ,_2 ,_4)";

  // this MUST be next, overrides case with only one name
  smacro_definition := macro sname is sname ; =># "`(ast_macro_name ,_2 ,_4)";
  smacro_definition := macro for sname in sbasic_name_comma_list do statement* done ; =># 
    "`(ast_macro_ifor ,_3 ,_5 ,_7)";
  smacro_definition := macro for sname in lpar sbasic_name_comma_list rpar do statement* done ; =># 
    "`(ast_macro_ifor ,_3 ,_6 ,_9)";

  smacro_definition := macro sname is new; =># """`(ast_macro_name ,_2 "")""";
  smacro_definition := macro var sbasic_name_comma_list = sexpr ; =># 
    "`(ast_macro_var ,_3 ,_5)";
  smacro_definition := macro val sbasic_name_comma_list = sexpr ; =># 
    "`(ast_macro_val ,_3 ,_5)";
  smacro_definition := macro sbasic_name_comma_list = sexpr ; =># 
    "`(ast_macro_assign ,_2 ,_4)";
  smacro_definition := macro val sname is sexpr ; =># 
    "`(ast_macro_vals ,_3 ,(mkl _5))";
  smacro_definition := macro fun sname smac_arg_list = sexpr ; =># 
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro fun sname smac_arg_list => sexpr ; =># 
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro proc sname smac_arg_list scompound =># 
    "`(ast_stmt_macro ,_3 ,_4 ,_5)";
  smacro_definition := macro scompound ; =># "`(ast_macro_block ,_2)";
  smacro_definition := macro forget sbasic_name_comma_list ; =># 
    "`(ast_macro_forget ,_3)";
  smacro_definition := macro forget; =># 
    "`(ast_macro_forget ())";
  smacro_definition := macro goto sname ; =># "`(ast_macro_goto ,_3)";
  smacro_definition := macro sname :> =># "`(ast_macro_label ,_2)";
  smacro_definition := macro if sexpr goto sname ; =># 
    "`(ast_macro_ifgoto ,_3 ,_5)";
  smacro_definition := macro for val sbasic_name_comma_list in sexpr do statement* done ; =># 
    "`(ast_macro_vfor ,_4 ,_6 ,_8)";

    smac_arg:= sname : fun =># "`(,_1 Expr)"; 
    smac_arg:= sname : proc =># "`(,_1 Stmt)"; 
    smac_arg:= sname : sident =># "`(,_1 Stmt)"; 
    smac_arg:= sname =># "`(,_1 Expr)"; 
    smac_args := smac_arg , smac_args =># "(cons _1 _3)";
    smac_args := smac_arg =># "`(,_1)";
    smac_arg_list := ( smac_args ) =># "_2";
    smac_arg_list := () =># "()";

  sapplication := macro ctor sname scoercion =># "`ast_macro_ctor (,_3 ,_4))";
}

//------------------------------------------
syntax cbind {
  requires expressions, statements;

  statement:= sbinding_definition =># "_1";
  sbinding_definition :=  sabstract_type =># "_1";
  sbinding_definition :=  sconst_def =># "_1";
  sbinding_definition :=  sbinding_header =># "_1";
  sbinding_definition :=  sexport_statement =># "_1";
   sexport_statement := export fun ssuffixed_name as sstring ; =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
  sexport_statement := export proc ssuffixed_name as sstring ; =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
  sexport_statement := export type (sexpr) as sstring ; =>#
    "`(ast_export_type ,_sr ,_4 ,_7)";


  sstruct_decl := cstruct sdeclname sopt_equal lbrace sstruct_mem_decl * rbrace =>#
    """
    (mkns 
    `(ast_cstruct ,_sr ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """; 

  // note: also needed by typeclasses atm for virtual funs
  sfunction_definition := sadjectives sfun_kind sdeclname 
    sopt_type_expr sopt_cstring sopt_prec srequires_clause ; =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t (car _4))
      (traint (cadr _4))
      (prec _6)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
        _7)
      )
      (ct 
        (if (eq? 'none _5)
          (if (memv 'Virtual _1)
            'Virtual 
             `(StrTemplate ,(string-append (caar _3) "($a)"))
           )
           (cadr _5))
      )
    )
    (let (
      (reqs 
        (if (eq? 'Generator kind)
          `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
          reqs))
    )
    (if (eq? 'ast_arrow (car t))
      (let (
        (argt (caadr t))
        (ret (cadadr t)))
      (mkns 
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
      (cdr _3)))
      ('ERROR))))
  """;

  sabstract_type:= stype_quals type sdeclname = scode_spec srequires_clause ; =>#
    """
    (mkns 
    `(ast_abs_decl ,_sr ,(caar _3) ,(cadar _3) ,_1 ,_5 ,_6)
    (cdr _3))
    """; 

  stype_qual := incomplete =># "'Incomplete";
  stype_qual := pod =># "'Pod";
  stype_qual := _gc_pointer =># "'GC_pointer";
  stype_qual := _gc_type sexpr =># "`(Raw_needs_shape ,_2)";
  stype_quals:= stype_qual stype_quals =># "(cons _1 _2)";
  stype_quals:= sepsilon =># "()";

  sabstract_type:= stype_quals ctypes sbasic_name_comma_list srequires_clause ; =>#
    "`(ast_ctypes ,_sr ,_3 ,_1 ,_4)";

  sexecutable := sinline_cpp =># "_1";
  sinline_cpp:= code scode_spec ; =># "`(ast_code ,_sr ,_2)";
  sinline_cpp:= noreturn code scode_spec ; =># "`(ast_noreturn_code ,_sr ,_3)";

  sclass_component:= var sname : sexpr ; =># "`(MemberVar ,_2 ,_4 none)";
  sclass_component:= val sname : sexpr ; =># "`(MemberVal ,_2 ,_4 none)";
  sclass_component:= ctor sopt_name : sexpr sopt_cstring ; =># 
    "`(MemberCtor ,_2 none ,_4 ,_5)";
  sclass_component:= fun sname stvarlist  : sexpr sopt_cstring ; =># 
    "`(MemberFun ,_2 none ,_3 ,_5 ,_6)";
  sclass_component:= proc sname stvarlist  : sexpr sopt_cstring ; =># 
    "`(MemberProc ,_2 none ,_3 ,_5 ,_6)";

  sstruct_decl := cclass sdeclname sopt_equal lbrace sclass_component * rbrace =>#
    """
    (mkns 
    `(ast_cclass ,_sr ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """; 

  sexpr_code_prefix := code lsqb sexpr rsqb =># "_3";
  satom := sexpr_code_prefix sstring =># "`(ast_expr ,_2 ,_1)";
  satom := sexpr_code_prefix sname =># "`(ast_expr ,_2 ,_1)";

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives const sdeclname : sexpr = scode_spec srequires_clause ; =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and (rreq_atom (Property_req "virtual")) ,_8)
      _8)))
    (mkns 
    `(ast_const_decl ,_sr ,(caar _3) ,(cadar _3) ,_5 ,_7 ,reqs)
    (cdr _3)))
  """;

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives const sdeclname : sexpr srequires_clause ; =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and (rreq_atom (Property_req "virtual")) ,_6)
      _6)))
    (mkns 
    `(ast_const_decl ,_sr ,(caar _3) ,(cadar _3) ,_5 (Str ,(caar _3)) ,reqs)
    (cdr _3)))
  """;

  // note: also needed by typeclasses atm for virtual procs
  sprocedure_definition := sadjectives sproc_kind sdeclname : sexpr 
    sopt_cstring srequires_clause ; =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t _5)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
        _7)
      )
      (ct 
        (if (eq? 'none _6)
          (if (memv 'Virtual _1)
            'Virtual 
             `(StrTemplate ,(string-append (caar _3) "($a);"))
           )
           (cadr _6))
      )
    )
    (let (
      (reqs 
        (if (eq? 'Generator kind)
          `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
          reqs))
    )
    (let (
      (argt t)
      (ret 'ast_void))
      (mkns 
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs "")
      (cdr _3)))))
  """;

 
}

//------------------------------------------
syntax executable {  
  statement:= sexecutable =># "_1"; 
  sexecutable := scall =># "_1";
  sexecutable := ssvc =># "_1";
  sexecutable := sreturn =># "_1";
  sexecutable := sifgoto =># "_1";
  sexecutable := stodo =># "_1";
  sexecutable := sassignment =># "_1";
  sexecutable := sgoto_statement=># "_1";
  sexecutable := slabel_statement =># "_1";

  slabel_statement := sname :> =># "`(ast_label ,_sr ,_1)";
  sgoto_statement := goto sname ; =># "`(ast_goto ,_sr ,_2)";
  ssvc := _svc sname ; =># "`(ast_svc ,_sr ,_2)";

  // deprecate: class object construction, use a generator
  sassignment := var sname <- new sexpr ; =># 
    "(append `(ast_apply_ctor ,_sr ,_2) (splitapply _5))";

  // a0 <- f (a1, a2, ..)  means f (a0, a1, a2 ..)
  sassignment := sexpr <- sexpr ; =># 
   """
   (let* (
     (fl (splitapply _3))
     (f (car fl))
     (a (cadr fl)))
     (begin 
     ;; (display "f=")(display f)
     ;; (display "\\n_1=")(display _1)
     ;; (display "\\na=")(display a)
     ;; (display "\\nnew a=")(display (cons _1 (mkl a)))
     ;; (display "\\n")
     `(ast_call ,_sr ,f ,(cons _1 (mkl a)))))
   """;

  sassignop:= = =># "'_set";
  sassignop:= := =># "'_init";

  srmwop:= += =># "'pluseq";
  srmwop:= -= =># "'minuseq";
  srmwop:= *= =># "'muleq";
  srmwop:= /= =># "'diveq";
  srmwop:= %= =># "'modeq";
  srmwop:= <<= =># "'leftshifteq";
  srmwop:= >>= =># "'rightshifteq";
  srmwop:= ^= =># "'bxoreq";
  srmwop:= |= =># "'boreq";
  srmwop:= &= =># "'bandeq";
  srmwop:= ~= =># "'tildeeq";

  sswapop := <-> =># "'_swap";

  spreincrop:= ++ =># "'pre_incr";
  spreincrop:= -- =># "'pre_decr";
  spostincrop:= ++ =># "'post_incr";
  spostincrop:= -- =># "'post_decr";

  slelement := val sname =># "`(Val ,_2)";
  slelement := var sname =># "`(Var ,_2)";
  slelement := sname =># "`(Name ,_1)";
  slelement := _ =># "'Skip";
  slelement := lpar slexprs rpar =># "`(List ,_2)";

  stlelement := slelement : sfactor =># "`(,_1 (some ,_3))";
  stlelement := slelement =># "`(,_1 none)";

  slexprs := stlelement , slexprs =># "(cons _1 _3)";
  slexprs := stlelement =># "`(,_1)";

  slexpr := slexprs =># 
    """
    (if (null? (cdr _1)) (car _1) `((List ,_1) none))
    """;

  sassignment := def slexpr = sexpr ; =># "`(ast_assign ,_sr _set ,_2 ,_4)";

  sassignment := sexpr sswapop sexpr ; =># 
    "`(ast_call ,_sr ,_2 (,_1 ,_3))";

  sassignment := sexpr sassignop sexpr ; =># 
    "`(ast_assign ,_sr ,_2 ((Expr ,_1) none) ,_3)";

  sassignment := sexpr srmwop sexpr ; =># 
    "`(ast_assign ,_sr ,_2 ((Expr ,_1) none) ,_3)";

  sassignment := sexpr spostincrop ; =># "`(ast_call ,_sr ,_2 ,_1)";
  sassignment := spreincrop sexpr ; =># "`(ast_call ,_sr ,_1 ,_2)";

  sreturn := yield sexpr ; =># "`(ast_yield ,_sr ,_2)";
  sreturn := return sexpr ; =># "`(ast_fun_return ,_sr ,_2)";
  sreturn := return ; =># "`(ast_proc_return ,_sr)";
  sreturn := halt sstring ; =># "`(ast_halt ,_sr ,_2)";

  scall := call sexpr ; =># """(cons 'ast_call (cons _sr (splitapply _2)))""";
  scall := jump sexpr ; =># """(cons 'ast_jump (cons _sr (splitapply _2)))""";
  //scall := loop sname sexpr ; =># "`(ast_loop ,_sr ,_2 ,_3)";
  //scall := loop sname ; =># "`(ast_loop ,_sr ,_2 (ast_tuple ()))";
  scall := loop sname sexpr ; =># "`(ast_jump ,_sr (ast_name ,_2 ()) ,_3)";
  scall := loop sname ; =># "`(ast_jump ,_sr (ast_name ,_2 ()) (ast_tuple ()))";

  scall := sexpr ; =># "(cons 'ast_call (cons _sr (splitapply _1)))";

  sifgoto := if sexpr goto sname ; =># "`(ast_ifgoto ,_sr ,_2 ,_4)";
  sifgoto := if sexpr return ; =># "`(ast_ifreturn ,_sr ,_2)";
  sifgoto := if sexpr call sexpr ; =># 
    "`(ast_ifdo ,_sr ,_2 (,(cons 'ast_call (cons _sr (splitapply _4))))())";
  sifgoto := if sexpr do statement* selse_clause done ; =># 
    "`(ast_ifdo ,_sr ,_2 ,_4 ,_5)";
  sifgoto := if sexpr do statement* done ; =># 
    "`(ast_ifdo ,_sr ,_2 ,_4 ())";

  selif_clause := elif sexpr do statement* =># "`(,_2 ,_4)";
  selif_clause := elif sexpr return ; =># "`(,_2 ((ast_proc_return ,_sr)))";
  selif_clause := elif sexpr goto sname ; =># "`(,_2 (ast_goto ,_sr ,_4))";
  selif_clauses := selif_clauses selif_clause =># "(cons _2 _1)";
  selif_clauses := selif_clause =># "`(,_1)";
  selse_clause := selif_clauses else statement* =>#
    """      
        (let ((f (lambda (result condthn) 
          (let ((cond (car condthn)) (thn (cadr condthn))) 
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f _3 _1))
    """;

  selse_clause := else statement* =># "_2";
  selse_clause := selif_clauses =>#
    """      
        (let ((f (lambda (result condthn) 
          (let ((cond (car condthn)) (thn (cadr condthn))) 
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f () _1))
    """;

#keyword whilst
  sifgoto := whilst sexpr do statement* done; =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" ) 
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" ) 
      ( ast_ifgoto ,_sr (ast_apply ,_sr (lnot ,_2)) "lab2" ) )
      _4  
      `(( ast_goto ,_sr "lab1" ) 
      ( ast_label ,_sr "lab2" ))
      )
    ) 
  """;

#keyword until
  sifgoto := until sexpr do statement* done; =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" ) 
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" ) 
      ( ast_ifgoto ,_sr ,_2 "lab2" ) )
      _4  
      `(( ast_goto ,_sr "lab1" ) 
      ( ast_label ,_sr "lab2" ))
      )
    ) 
  """;


#keyword forall
  statement := forall sname in sexpr do statement* done ; =>#
    "`(ast_macro_vfor (,_4) ,_6 ,_8)";
  ;

#keyword upto
  statement := forall sname in sexpr upto sexpr do statement* done ; =>#
  """
    `(ast_macro_block ,( append `(
      (ast_assign ,_sr _set ((Expr (ast_name ,_2 ())) none) ,_4)
      ( ast_macro_name "lab1" "" ) 
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" ) 
      ( ast_ifgoto ,_sr (ast_apply ,_sr (lnot (ast_apply ,_sr (le ((ast_name ,_2 ()),_6))))) "lab2" ))
      _8  
      `((ast_call ,_sr pre_incr (ast_name ,_2()))
      ( ast_goto ,_sr "lab1" ) 
      ( ast_label ,_sr "lab2" ))
     ))
  """;

#keyword downto
  statement := forall sname in sexpr downto sexpr do statement* done ; =>#
  """
    `(ast_macro_block ,( append `(
      (ast_assign ,_sr _set ((Expr (ast_name ,_2 ())) none) ,_4)
      ( ast_macro_name "lab1" "" ) 
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" ) 
      ( ast_ifgoto ,_sr (ast_apply ,_sr (lnot (ast_apply ,_sr (ge ((ast_name ,_2 ()) ,_6))))) "lab2" ))
      _8 
      `((ast_call ,_sr pre_decr (ast_name ,_2 ()))
      ( ast_goto ,_sr "lab1" ) 
      ( ast_label ,_sr "lab2" ))
     ))
  """;



}

//------------------------------------------
syntax requirements {
  srequires_clause := requires srequirements =># "_2";
  srequires_clause := sepsilon =># "'rreq_true";

  srequirement:= squalified_name =># "`(Named_req ,_1)";
  srequirement :=  property sstring =># "`(Property_req ,_2)";
  srequirement :=  package scode_spec =># "`(Package_req ,_2)";

  srequirement_atom:= srequirement =># "`(rreq_atom ,_1)";
  srequirement_atom:= lpar srequirements rpar =># "_2";

  srequirement_and:= srequirement_and and srequirement_atom =>#
    "`(rreq_and ,_1 ,_3)";
  srequirement_and:= srequirement_atom =># "_1";

  srequirement_or:= srequirement_or or srequirement_and =>#
    "`(rreq_or ,_1 ,_3)";
  srequirement_or:= srequirement_and =># "_1";

  srequirements:= srequirements , srequirement_or =>#
    "`(rreq_and ,_1 ,_3)";
  srequirements:= srequirement_or =># "_1";


  sbinding_header := requires srequirements ; =># 
    """`(ast_insert ,_sr "_root" ,dfltvs (Str "") body ,_2)""";

  sbinding_header := sname requires srequirements ; =># 
    """`(ast_insert ,_sr ,_1 ,dfltvs (Str "") body ,_3)""";

  srequirement := body scode_spec =># "`(Body_req ,_2)";
  srequirement := header scode_spec =># "`(Header_req ,_2)";

  scode_spec := sstring =># "`(StrTemplate ,_1)";
  scode_spec := scstring =># "`(Str ,_1)";
  scode_spec := sident =># "'Identity";

  sbinding_header:= header scode_spec srequires_clause ; =># 
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 header ,_3))"""; 
  sbinding_header:= body scode_spec srequires_clause ; =># 
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 body ,_3))"""; 
  sbinding_header:= header = scode_spec srequires_clause ; =># 
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 header ,_4))"""; 
  sbinding_header:= body = scode_spec srequires_clause ; =># 
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 body ,_4))"""; 
  sbinding_header:= header sdeclname = scode_spec srequires_clause ; =># 
    """
    (mkns 
    `(ast_insert ,_sr ,(caar _2) ,(cadar _2) ,_4 header ,_5)
    (cdr _2))
     """; 

  sbinding_header:= body sdeclname = scode_spec srequires_clause ; =># 
    """
    (mkns 
    `(ast_insert ,_sr ,(caar _2) ,(cadar _2) ,_4 body ,_5)
    (cdr _2))
     """; 

}

syntax type_declarations {
  stype_alias := typedef sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_type_alias ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
    """; 

  stype_alias := typedef fun sdeclname stypefun_args : sexpr => sexpr ; =>#
    """
    (mkns 
    `(mktypefun ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_6 ,_8)
    (cdr _3))
    """; 

  stype_alias := typedef fun sdeclname : sexpr = stype_matching+ ; =>#
    """
    (if (eq? 'ast_arrow (car _5))
      (let (
        (argt (caadr _5))
        (ret (cadadr _5))
        (body `(ast_type_match (_a ,_7))))
        (let ((args `(((_a ,argt)))))
      (mkns 
      `(mktypefun ,_sr ,(caar _3) ,(cadar _3) ,args ,ret ,body)
      (cdr _3))))
      ('ERROR)
    )
    """; 

  sstruct_decl := struct sdeclname sopt_equal lbrace sstruct_mem_decl * rbrace =>#
    """
    (mkns 
    `(ast_struct ,_sr ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """; 

  sopt_name := sname =># "_1";
  sopt_name := sepsilon =># '""';

  sstruct_decl := class sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_class ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  sstruct_decl := typeclass sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_typeclass ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  sstruct_decl := instance stvarlist squalified_name sopt_equal scompound =>#
    """
    `(ast_instance ,_sr ,_2 ,_3 ,_5)
     """; 

  sunion_decl := union sdeclname = stype_sum_items2 ; =>#
    """
    (mkns 
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  sunion_decl := union sdeclname lbrace stype_sum_item1* rbrace =>#
    """
    (mkns 
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  sunion_decl := enum sdeclname lbrace senum_items rbrace =>#
    """
    (mkns 
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  sopt_value := = sinteger =># "`(some ,_2)";
  sopt_value := sepsilon =># "'none";
  senum_item := sname sopt_value =># "`(,_1 ,_2 ,dfltvs ast_void)";
  senum_items := senum_item , senum_items =># "(cons _1 _3)";
  senum_items := senum_item =># "`(,_1)";
  senum_items := sepsilon =># "()";

}

//------------------------------------------
syntax assertions {
  sexecutable := sassert_statement =># "_1";
  sassert_statement:= assert sexpr ; =># "`(ast_assert ,_sr ,_2)";

  sfunction_definition := axiom sdeclname sfun_arg : sexpr; =>#
  """
    (mkns 
    `(ast_axiom ,_sr ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
    (cdr _2))
  """;

  sfunction_definition := axiom sdeclname sfun_arg : sexpr = sexpr ; =>#
  """
    (mkns 
    `(ast_axiom ,_sr ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
    (cdr _2))
  """;

  sfunction_definition := lemma sdeclname sfun_arg : sexpr; =>#
  """
    (mkns 
    `(ast_lemma ,_sr ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
    (cdr _2))
  """;

  sfunction_definition := lemma sdeclname sfun_arg : sexpr = sexpr ; =>#
  """
    (mkns 
    `(ast_lemma ,_sr ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
    (cdr _2))
  """;

  sreduce_args := ( stypeparameter_comma_list ) =># "_2";

  sfunction_definition := reduce sdeclname sreduce_args : sexpr => sexpr ; =>#
  """
    (mkns 
    `(ast_reduce ,_sr ,(caar _2) ,(cadar _2) ,_3 ,_5 ,_7)
    (cdr _2))
  """;


}

syntax namespaces {  
  stype_alias := rename sdeclname = squalified_name ; =>#
    """
    (mkns 
    `(ast_inherit ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
    """; 

  stype_alias := rename fun sdeclname = squalified_name ; =>#
    """
    (mkns 
    `(ast_inherit_fun ,_sr ,(caar _3) ,(cadar _3) ,_5)
    (cdr _3))
    """; 

  stype_alias := inherit squalified_name ; =># "`(ast_inject_module ,_sr ,_2)";
 
  sopen_decl := open stvarlist squalified_name ; =>#
    "`(ast_open ,_sr ,_2 ,_3)";

  suse_decl:= use squalified_name ; =>#
    """
    (let ((name
      (if (eq? (car _2) 'ast_lookup) (cadadr _2)
        (if (eq? (car _2) 'ast_name) (cadr _2)
        ("ERROR")))))
    `(ast_use ,_sr ,name ,_2))
    """;
  suse_decl := use sname = squalified_name ; =># "`(ast_use ,_sr ,_2 ,_4)";

  smodule_definition := module sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_untyped_module ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  smodule_definition := open module sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_seq (
      (ast_untyped_module ,_sr ,(caar _3) ,(cadar _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,(caar _3)()))))
    (cdr _3))
     """; 

  smodule_definition := namespace sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_namespace ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """; 

  smodule_definition := open namespace sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_seq (
      (ast_namespace ,(caar _3) ,(cadar _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,(caar _3)()))))
    (cdr _3))
     """; 

    sopt_equal := = =># "()";
    sopt_equal := sepsilon =># "()";

}

//------------------------------------------

syntax csyntax {
  base_type := 
    | "char" =># '`(ast_name "char" ())'
    | "tiny" =># '`(ast_name "tiny" ())'
    | "short" =># '`(ast_name "short" ())'
    | "int" =># '`(ast_name "int" ())'
    | "long" =># '`(ast_name "long" ())'
    | "vlong" =># '`(ast_name "vlong" ())'
    | "utiny" =># '`(ast_name "utiny" ())'
    | "uchar" =># '`(ast_name "utiny" ())'
    | "ushort" =># '`(ast_name "ushort" ())'
    | "uint" =># '`(ast_name "uint" ())'
    | "ulong" =># '`(ast_name "ulong" ())'
    | "uvlong" =># '`(ast_name "uvlong" ())'
    | "float" =># '`(ast_name "float" ())'
    | "double" =># '`(ast_name "double" ())'
    | "ldouble" =># '`(ast_name "ldouble" ())'

    | struct sname =># "`(ast_name ,_2 ())"
    | union sname =># "`(ast_name ,_2 ())"
    | class sname =># "`(ast_name ,_2 ())"
    | enum sname =># "`(ast_name ,_2 ())"
  ;

  pointer_type:= 
    | base_type
    | "void" star =># '`(ast_name "address" ())'
    | pointer_type star =># "`(ast_ref ,_1)"
  ;

  c_type := 
    | pointer_type
    | c_type lpar star rpar lpar c_type_list rpar =>#
      "`(ast_longarrow (,_6 ,_1))"           // cfunction
  ;

  c_type_suffix := comma c_type =># "_2";
  c_type_list := 
    | c_type c_type_suffix+ =># "`(ast_tuple ,(cons _1 _2))"
    | c_type =># "_1"
    | sepsilon =># "`(ast_tuple ())"
  ;

  declarator := 
    | pointer_type sname =># "`(PVar ,_2 ,_1)"
    | pointer_type const sname =># "`(PVal ,_3 ,_1)"
    | c_type lpar sname rpar lpar c_type_list rpar =>#
      "`(PVar ,_3 (ast_longarrow (,_6 ,_1)))"

    | c_type lpar star sname rpar lpar c_type_list rpar =>#
      "`(PVar ,_4 (ast_longarrow (,_7 ,_1)))"

    | c_type sname lpar c_type_list rpar =>#
      "`(PVar ,_2 (ast_longarrow (,_4 ,_1)))"
  ;

  sparameter := declarator;

  svar_def := declarator = sexpr ; =>#
    """
    (let*
      (
        (kind (car _1))
        (name (cadr _1))
        (type (caddr _1))
        (dcl (if (eq? kind 'PVal) 'ast_val_decl 'ast_var_decl))
      )
    `(,dcl ,_sr ,name ,dfltvs (some ,type) (some ,_3)))
    """; 


  sprocedure_definition := sadjectives "void" sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns 
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) Function ,_6)
    (cdr _3))
  """;

  sfunction_definition := sadjectives pointer_type sdeclname 
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns 
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (,_2 ,_5) Function ,_6)
    (cdr _3))
  """;


}

//------------------------------------------
syntax felix {
  requires 
    statements, 
      type_declarations,
      executable, 
      assertions,
      namespaces,
    requirements,
    expressions, 
    cbind, 
    regexps, 
    parsing,
    macros
  ;
}

