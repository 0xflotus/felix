@select(tangler("lib/nugram.flxh"))

SCHEME """
(define fold_left
  (lambda (f acc lst) 
    (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst)))))
""";

SCHEME """
(define dfltvs '(() (()())))
""";

SCHEME """
(define mkn1 (lambda (stmt nvs) 
  `(ast_namespace (,(car nvs) ,(cadr nsv) (,stmt)))))
""";

SCHEME """
(define mkns (lambda (stmt nsvl) (
  fold_left mkn1 stmt nsvl
  )))
""";

SCHEME """
(define splitapply (lambda (x)
  (if (pair? x) 
    (if (eq? (car x) 'ast_apply) 
      (if (pair? (cdr x)) 
        (begin 
;;           (display "f=")(display (caadr x))
;;           (display " arg=")(display (cadadr x))
;;           (display " pair=")(display (cadr x))
           (cadr x))
        (list x ()))
      (list x ()))
    (list ()))
))
""";

SCHEME """
(define mkl (lambda (x)
  (begin 
;;  (display "mkl x=")(display x)
  (if (pair? x) 
    (if (eq? (car x) 'ast_tuple) 
      (if (pair? (cdr x)) (cadr x) (list x))
      (list x))
    (list x)))
))
""";

SCHEME """
(define cal_funkind (lambda (adjs fk)
  (if (eq? fk 'CFunction)'CFunction
  (if (eq? fk 'Generator)'Generator
  ;; fk is Function
  (if (pair? adjs)(car adjs)'Function
)))))
""";

syntax expressions {
  satom := _ =># "'ast_patany";
  satom := ... =># "'ast_ellipsis";
  
  sexpr_code_prefix := code [ sexpr ] =># "_3";
  satom := sexpr_code_prefix sstring =># "`(ast_expr ,_2 ,_1)";
  satom := sexpr_code_prefix sname =># "`(ast_expr ,_2 ,_1)";

  satom := callback [ sexpr ] =># "`(ast_callback ,_3)";
  satom := [| sexpr |] =># "`(ast_arrayof ,(mkl _2))";
  satom := { sexpr } =># """
    `(ast_lambda (,dfltvs ((() none)) typ_none ((ast_fun_return ,_2))))
  """;

  satom := match sexpr with smatching+ endmatch =># 
    "`(ast_match (,_2 ,_4))";

    smatching  := | spattern => sexpr =># "`(,_2 ,_4)";
    smatching  := | => sexpr =># "`(pat_none ,_4)";

  satom := typematch sexpr with stype_matching+ endmatch =># 
    "`(ast_type_match (,_2 ,_4))";

    stype_matching  := | sexpr => sexpr =># "`(,_2 ,_4)";

    satomic_pattern := sstring =># "`(pat_string ,_1)";
    satomic_pattern := quest sname =># "`(pat_as pat_any ,_2)";
    satomic_pattern := _ =># "'pat_any";
    satomic_pattern := ( spattern ) =># "_2";
    satomic_pattern := struct { spat_assigns } =># "`(pat_record ,_3)";
      spat_assign := sname = spattern ; =># "`(,_1 ,_3)";
      spat_assigns := spat_assign =># "`(,_1)";
      spat_assigns := spat_assign spat_assigns =># "(cons _1 _2)";

    satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
    satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";
      sctor_name := squalified_name =># "_1";
      sctor_name := case sinteger =># "`(ast_case_tag ,_2)";

    satomic_pattern := sstring .. sstring =># "`(pat_string_range ,_1 ,_3)";
    satomic_pattern := sintegral =># "`(pat_int ,(car _1) ,(cadr _1))";
    satomic_pattern := sintegral .. sintegral=># 
      "`(pat_int_range ,(car _1) ,(cadr _1) ,(car _3) ,(cadr _3))";

    satomic_pattern := NaN =># "'pat_nan";
    satomic_pattern := sfloating .. sfloating =># 
      "`(pat_int ,(car _1) ,(cadr _1))";

      sfloating:= sfloat =># "`(float_plus ,(car _1) ,(cadr _1))";
      sfloating:= - sfloat =># "`(float_minus ,(car _2) ,(cadr _2))";
      sfloating:= inf =># "'float_inf";
      sfloating:= - inf =># "'float_minus_inf";

    scoercive_pattern := satomic_pattern =># "_1";
    scoercive_pattern := satomic_pattern : sarrow =># "`(pat_coercion ,_1 ,_2)";

    stuple_pattern := scoercive_pattern =># "_1";
    stuple_pattern := scoercive_pattern stuple_pattern_suffix =># 
      "`(pat_tuple ,(cons _1 _2))";

      stuple_pattern_suffix := , scoercive_pattern =># "`(,_2)";
      stuple_pattern_suffix := , scoercive_pattern stuple_pattern_suffix =># 
        "(cons _2 _3)";

    sas_pattern := stuple_pattern =># "_1";
    sas_pattern := stuple_pattern as sname =># "`(pat_as ,_1 ,_3)";

    spattern := sas_pattern =># "_1";
    spattern := sas_pattern when sexpr =># "`(pat_when ,_1 ,_3)";

  satom := scompound =># "`(ast_lambda (,dfltvs ((() none)) none ,_1))";

  satom := ( sexpr ) =># "_2";
  satom := ( ) =># "'()";

  satom := if sexpr then sexpr selse_part endif =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

    selif := elif sexpr then sexpr =># "`(,_2 ,_4)";

    selifs := selif =># "`(,_1)";
    selifs := selifs selif =># "(cons _2 _1)";

    selse_part:= else sexpr =># "_2";
    selse_part:= selifs else sexpr =># 
      """
        (let ((f (lambda (result condthn) 
          (let ((cond (car condthn)) (thn (cadr condthn))) 
            `(ast_cond (,cond ,thn ,result))))))
        (fold_left f _3 _1))
      """;
/*    
    selse_part:= selifs else sexpr =># """
     (letrec 
       ((fold_left 
         (lambda (f acc lst) 
           (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst))))))
       (let ((f (lambda (result condthn) 
         (let ((cond (car condthn)) (thn (cadr condthn))) 
           `(ast_cond (,cond ,thn ,result))))))
         (fold_left f _3 _1)))
    """;
*/

  ssimple_name_parts := sname           =># "`(,_1 ())";
  ssimple_name_parts := sname [ sexpr ] =># "`(,_1 ,(mkl _3))";

  squalified_name := squalified_name :: ssimple_name_parts =># 
    "`(ast_lookup (,_1 ,(car _3) ,(cadr _3)))";
  squalified_name := ssimple_name_parts =># 
    "`(ast_name ,(car _1) ,(cadr _1))";

  ssuffixed_name := squalified_name of sfactor =># 
    "`(ast_suffix (,_1 ,_3))";

  sthe_name := satom =># "_1";
  sthe_name := the squalified_name =># "`(ast_the ,_2)";
  sthe_name := noexpand squalified_name =># "`(ast_noexpand ,_2)";
  sthe_name := quest sname =># "`(ast_patvar ,_2)";
  sthe_name := squalified_name =># "_1";

  shash_name := sthe_name =># "_1";
  shash_name := # shash_name =># "`(ast_lift ,_2)";

  sfactor := shash_name =># "_1";
  sfactor := sfactor .[ sexpr ] =># "`(ast_apply (subscript (,_1 ,_4)))";
  sfactor := sfactor .[ sexpr to sexpr ] =># "`(ast_apply (substring (,_1 ,_4 ,_6)))";
  sfactor := sfactor .[ sexpr to ] =># "`(ast_apply (copyfrom (,_1 ,_4)))";
  sfactor := sfactor .[ to sexpr ] =># "`(ast_apply (copyto (,_1 ,_5)))";
  sfactor := sfactor . ssimple_name_parts =># 
    "`(ast_dot (,_1 (ast_name ,(car _3) ,(cadr _3))))";

  sfactor := sfactor .-> ssimple_name_parts =># 
    "`(ast_dot ((ast_apply (deref ,_1)) (ast_name (,(car _3) ,(cadr _3)))))";

  sfactor := sfactor . ( sinteger ) =># "`(ast_get_n (,_4 ,_1))";

  scoercion := sfactor =># "_1";
  scoercion := scoercion : sfactor =># "`(ast_coercion (,_1 ,_3))";
  scoercion := ssuffixed_name =># "_1";

  sapplication := scoercion =># "_1";
  sapplication := sapplication scoercion =># "`(ast_apply (,_1 ,_2))";
  sapplication := caseno scoercion =># "`(ast_case_index ,_2)";
  sapplication := macro ctor sname scoercion =># "`ast_macro_ctor (,_3 ,_4))";

  srefr := sapplication =># "_1";
  // todo anonymous union
  // todo anonymous struct
  srefr := & srefr =># "`(ast_ref ,_2)";
  srefr := star srefr =># "`(ast_apply (deref ,_2))";
  srefr := _deref srefr =># "`(ast_deref ,_2)";
  srefr := new srefr =># "`(ast_new ,_2)";
  srefr := struct { sstruct_decl* } =># "`(ast_record_type ,_3)";
    sstruct_decl := sname : sexpr ; =># "`(,_1 ,_3)";
  srefr := struct { sstruct_assign* } =># "`(ast_record ,_3)";
    sstruct_assign := sname = sexpr ; =># "`(,_1 ,_3)";

  srefr := union { stype_sum_items2 } =># "`(ast_variant_type ,_3)";
    stype_sum_item2 := sname of sexpr =># "`(,_1 ,_3)";
    stype_sum_item2 := sname =># "`(,_1 ast_void)";
    stype_sum_item2_suffix := | stype_sum_item2 =># "_2";
    stype_sum_items2 := stype_sum_item2 stype_sum_item2_suffix* =># "(cons _1 _2)";
    stype_sum_items2 := stype_sum_item2_suffix* =># "_1";

  ssuperscript := srefr =># "_1"; 
  ssuperscript := ssuperscript ^ srefr =># "`(ast_superscript (,_1 ,_3))"; 

  spower := ssuperscript  =># "_1"; 
  spower := ssuperscript ** sprefixed =># "`(ast_apply (pow (,_1 ,_3)))"; 

  sprefixed := spower =># "_1";
  sprefixed := lval spower =># "`(ast_lvalue ,_2)";
  sprefixed := ! spower =># "`(ast_apply (excl ,_2))";
  sprefixed := plus spower =># "`(ast_apply (pos ,_2))";
  sprefixed := - spower =># "`(ast_apply (neg ,_2))";
  sprefixed := ~ spower =># "`(ast_apply (compl ,_2))";

  s_term := sprefixed =># "_1";
  s_term := s_term / spower =># "`(ast_apply (div (,_1 ,_3)))";
  s_term := s_term % spower =># "`(ast_apply (mod (,_1 ,_3)))";

  sproduct :=  s_term =># "_1";
  sproduct := s_term star sproduct_list =># "`(ast_product ,(cons _1 _3))";
    sproduct_list := s_term star sproduct_list =># "(cons _1 _3)";
    sproduct_list := s_term =># "`(,_1)";
  
  ssubtraction := sproduct =># "_1";
  ssubtraction := ssubtraction - sproduct =># "`(ast_apply (sub (,_1 ,_3)))";

  ssum :=  ssubtraction =># "_1";
  ssum := ssubtraction plus ssum_list =># "`(ast_sum ,(cons _1 _3))";
    ssum_list := ssubtraction plus ssum_list =># "(cons _1 _3)";
    ssum_list := ssubtraction =># "`(,_1)";

  sshift := ssum =># "_1";
  sshift := sshift << ssum =># "`(ast_apply (shl (,_1 ,_3)))";
  sshift := sshift >> ssum =># "`(ast_apply (shr (,_1 ,_3)))";

  sband :=  sshift =># "_1";
  sband := sband \& sshift =># "`(ast_apply (band (,_1 ,_3)))";

  sbxor := sband =># "_1";
  sbxor := sbxor \^ sband =># "`(ast_apply (bxor (,_1 ,_3)))";

  sbor := sbxor =># "_1";
  sbor := sbor \| sbxor =># "`(ast_apply (bor (,_1 ,_3)))";

  scase_literal := sbor =># "_1";
  scase_literal := case sinteger =># "`(ast_case_tag ,_2))";
  scase_literal := case sinteger of ssum =># "`(ast_typed_case ,_2 ,_4)";
  scase_literal := case sname of ssum =># "`(ast_variant (,_2 ,_4))";
  
  sarrow := scase_literal =># "_1";
  sarrow := scase_literal -> sarrow =># "`(ast_arrow (,_1 ,_3))";
  sarrow := scase_literal --> sarrow =># "`(ast_longarrow (,_1 ,_3))";

  ssetintersection:= sarrow =># "_1";
  ssetintersection := sarrow && ssetintersection_list =># "`(ast_setintersection ,(cons _1 _3))";
    ssetintersection_list := sarrow =># "`(,_1)";
    ssetintersection_list := sarrow && ssetintersection_list =># "(cons _1 _3)";

  suser10 := ssetintersection =># "_1";
  suser10 := suser10 suser10token ssetintersection =># 
    "`(,_2 (,_1 ,_3)))";

  ssetunion := suser10 =># "_1";
  ssetunion := suser10 || ssetunion_list =># "`(ast_setunion ,(cons _1 _3))";
    ssetunion_list := suser10 =># "`(,_1)";
    ssetunion_list := suser10 || ssetunion_list =># "(cons _1 _3)";

  sas_expr := ssetunion =># "_1";
  sas_expr := sas_expr as sname =># "`(ast_as (,_1 ,_3))";

  // NOTE: this version doesn't support chains like a < b < c.. too bad
  scomparison:= sas_expr =># "_1";
  scomparison:= sas_expr < sas_expr =># "`(ast_apply (lt (,_1 ,_3)))";
  scomparison:= sas_expr <= sas_expr =># "`(ast_apply (le (,_1 ,_3)))";
  scomparison:= sas_expr == sas_expr =># "`(ast_apply (eq (,_1 ,_3)))";
  scomparison:= sas_expr != sas_expr =># "`(ast_apply (ne (,_1 ,_3)))";
  scomparison:= sas_expr >= sas_expr =># "`(ast_apply (ge (,_1 ,_3)))";
  scomparison:= sas_expr > sas_expr =># "`(ast_apply (gt (,_1 ,_3)))";

  snot_condition := scomparison  =># "_1";
  snot_condition := not snot_condition  =># "`(ast_apply (lnot ,_2))";

  sand_condition := snot_condition =># "_1";
  sand_condition := snot_condition and sand_list =># "`(ast_andlist ,(cons _1 _3))";
    sand_list := snot_condition and sand_list =># "(cons _1 _3)";
    sand_list := snot_condition =># "`(,_1)";

  sor_condition := sand_condition =># "_1";
  sor_condition := sand_condition or sor_list =># "`(ast_orlist ,(cons _1 _3))";
    sor_list := sand_condition or sor_list =># "(cons _1 _3)";
    sor_list := sand_condition =># "`(,_1)";

  stypeexpr:= sor_condition =># "_1";

  stuple := sor_condition  =># "_1";
  stuple := sor_condition stuple_suffix =># "`(ast_tuple ,(cons _1 _2))";
    stuple_suffix:= , sor_condition stuple_suffix =># "(cons _2 _3)";
    stuple_suffix:= , sor_condition  =># "`(,_2)";
  
  sdollar_apply := stuple =># "_1";
  sdollar_apply := stuple unless sexpr then sdollar_apply =>#
    "`(ast_cond ((ast_apply (lnot ,_3)) ,_1 ,_5))";
  sdollar_apply := stuple $ sdollar_apply =># "`(ast_apply (,_1 ,_3))";

  slambda := sdollar_apply =># "_1";
  slambda := sadjectives fun stvarlist slambda_fun_args sopt_type_expr = scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ,_7))
    """;

  slambda := sadjectives fun stvarlist slambda_fun_args sopt_type_expr => sexpr =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ((ast_fun_return ,_7))))
    """;

  slambda := sadjectives proc stvarlist slambda_fun_args scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ast_void ,_5))
    """;

  slambda := sadjectives proc stvarlist scompound =>#
    """
    `(ast_lambda (,_3 ((() none)) ast_void ,_4))
    """;


    sadjective := inline =># "'InlineFunction";
    sadjective := noinline =># "'NoInlineFunction";
    sadjective := virtual =># "'Virtual";
    sadjectives := sadjective* =># "_1";

    slambda_fun_arg := ( sparameter_comma_list when sexpr ) =># "`(,_2 (some ,_4))";
    slambda_fun_arg := ( sparameter_comma_list ) =># "`(,_2 none)";
    slambda_fun_args := slambda_fun_arg* =># "_1";

    sopt_type_expr := : sexpr expect sexpr =># "`(,_2 (some ,_4))";
    sopt_type_expr := : sexpr =># "`(,_2 none)";
    sopt_type_expr := expect sexpr =># "`(typ_none (some ,_2))";
    sopt_type_expr := sepsilon =># "'(typ_none none)";

    sparameter := sparam_qual sname : sarrow =># "`(,_1 ,_2 ,_4)";
    sparameter := sparam_qual sname =># "`(,_1 ,_2 typ_none)";
    sparameter_comma_list := sepsilon =># "()";
    sparameter_comma_list := sparameter , sparameter_comma_list =># "(cons _1 _3)";
    sparameter_comma_list := sparameter =># "`(,_1)";


    sparam_qual := val =># "'PVal";
    sparam_qual := var =># "'PVar";
    sparam_qual := ref =># "'PRef";
    sparam_qual := fun =># "'PFun";
    sparam_qual := sepsilon =># "'PVal";

  srvalue := slambda  =># "_1";

  sexpr := srvalue =># "_1";
  sexpr := let spattern = sexpr in sexpr =># "`(ast_letin (,_2 ,_4 ,_6))"; 
}

syntax regexps {
  satom := sregmatch_expr =># "_1";
  sregmatch_expr := reglex sexpr to sexpr with sregmatch_alternatives endmatch =>#
    "`(ast_reglex (,_2 ,_4 ,_6))";
  sregmatch_expr := regmatch sexpr with sregmatch_alternatives endmatch =>#
    "`(ast_string_regmatch (,_2 ,_4))";
  
  sregmatch_alternatives := sregmatch_alternative + =># "(reverse _1)";
  sregmatch_alternative := | sre1 => sexpr =># "`(,_2 ,_4)";

  sregdef := regexp sname = sre1 ; =># "`(ast_regdef ,_2 ,_4)";
  sre0 := sre1 as sname =># "`(regexp_group ,_3 ,_1)";
  sre0 := sre1 =># "_1";

  sre1 := sre1 | sre2 =># "`(regexp_alt ,_1 ,_3)";
  sre1 := sre2 =># "_1";

  sre2 := sre2 sre3 =># "`(regexp_seq ,_1 ,_2)";
  sre2 := sre3 =># "_1";

  sre3 := sre4 star =># "`(regexp_aster ,_1)";
  sre3 := sre4 plus =># "`(regexp_seq ,_1 (regexp_aster ,_1))";
  sre3 := sre4 quest =># "`(regexp_alt regexp_epsilon ,_1)";
  sre3 := sre4 =># "_1";

  sre4 := sstring =># "`(regexp_string ,_1)";
  sre4 := _ =># "'regexp_underscore";
  sre4 := . =># "'regexp_dot";
  sre4 := ( sre0 ) =># "_2";
  sre4 := [ scharset ] =># "`(regexp_of_charset ,_2)";
  sre4 := [ ^ scharset ] =># "`(regexp_of_charset (charset_inv ,_3))";
  sre4 := sre_name =># "`(regexp_name ,_1)";

  sre_name := sre_name :: sname =># "`(ast_lookup (,_1 ,_3 ()))";
  sre_name := sname =># "`(ast_name ,_1 ())";

  scharset0:= sinteger - sinteger =># "`(charset_of_int_range ,_1 ,_3)";
  scharset0:= sstring - sstring =># "`(charset_of_range ,_1 ,_3)";
  scharset0:= sstring =># "`(charset_of_string ,_1)";
  scharset0:= sinteger =># "`(charset_of_int_range ,_1 ,_1)";
 
  scharset:= scharset scharset0 =># "`(charset_union ,_1 ,_2)";
  scharset:= scharset0 =># "_1";

}

syntax parsing {
  satom := glrparse =># "_1";
}

syntax typing {
  satom := typecase_expr =># "_1";
}

syntax statements {
  sstatement:= sbinding_definition =># "_1";
  sstatement:= sdeclarative =># "_1"; 
  sstatement:= sexecutable =># "_1"; 
  sstatement:= sinclusion =># "_1"; 
  sstatement:= sdirective =># "_1"; 
  sstatement:= spublish =># "_1"; 
  sstatement:= scomment =># "_1"; 
  sstatement:= snull_statement =># "_1"; 
  //sstatement:= suser_statement =># "_1"; 
  sstatement:= scparse =># "_1"; 

  scomment := comment sstring ; =># "`(ast_nop ,_2)";
 
  sbinding_definition :=  sabstract_type =># "_1";
  sbinding_definition :=  sconst_def =># "_1";
  sbinding_definition :=  sbinding_header =># "_1";
  sbinding_definition :=  sexport_statement =># "_1";
  
  spublish := private sdeclarative =># "`(ast_private ,_2)";
  spublish := private sbinding_definition =># "`(ast_private ,_2)";
  spublish := private svar_def =># "`(ast_private ,_2)";
  spublish := private sval_def =># "`(ast_private ,_2)";

  sdeclarative := sfunction_definition =># "_1";
  sdeclarative := sobject_definition =># "_1";
  sdeclarative := sprocedure_definition =># "_1";
  sdeclarative := smodule_definition =># "_1";
  sdeclarative := sunion_decl =># "_1";
  sdeclarative := sstruct_decl =># "_1";
  sdeclarative := stype_alias =># "_1";

  sdirective := sopen_decl =># "_1";
  sdirective := suse_decl =># "_1";
  sdirective := sregdef =># "_1";
  sdirective := sglr_production =># "_1";
  sdirective := smacro_definition =># "_1";

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  sexecutable := scall =># "_1";
  sexecutable := ssvc =># "_1";
  sexecutable := sreturn =># "_1";
  sexecutable := sifgoto =># "_1";
  sexecutable := stodo =># "_1";
  sexecutable := sassignment =># "_1";
  sexecutable := sinline_cpp =># "_1";
  sexecutable := sgoto_statement=># "_1";
  sexecutable := slabel_statement =># "_1";
  sexecutable := sassert_statement =># "_1";

  snull_statement := ; =># """'(ast_nop "")""";

  sinclusion := include sstring ; =># "`(ast_include ,_2)";
  scparse := cparse sstring ; =># "`(ast_cparse ,_2)";

  sdeclname := sdeclname :: sname stvarlist =># "(cons _1 `(,_3 ,_4))";
  sdeclname := sname stvarlist =># "`((,_1 ,_2))";

  stype_qual := incomplete =># "'incomplete";
  stype_qual := pod =># "'pod";
  stype_qual := _gc_pointer =># "'gc_pointer";
  stype_qual := _gc_type sexpr =># "`(gc_type ,_2)";
  stype_quals:= stype_qual stype_quals =># "(cons _1 _2)";
  stype_quals:= sepsilon =># "()";

  sabstract_type:= stype_quals ctypes sbasic_name_comma_list srequires_clause ; =>#
    "`(ast_ctypes ,_3 ,_1 ,_4)";

  sabstract_type:= stype_quals type sdeclname = scode_spec srequires_clause ; =>#
    """
    (mkns 
    `(ast_abs_decl ,(caar _3) ,(cadar _3) ,_1 ,_5 ,_6)
    (cdr _3))
    """; 

  sabstract_type := stype_quals type sdeclname = new sexpr ; =>#
    """
    (mkns 
    `(ast_newtype ,(caar _3) ,(cadar _3) ,_6)
    (cdr _3))
    """; 

  sabstract_type := callback proc sname : sexpr srequires_clause ; =>#
    """
    (mkns 
    `(ast_callback_decl ,_3 ,(mkl _5) 'ast_void ,_6)
    (cdr _3))
    """; 


  sabstract_type := callback fun sname : sexpr srequires_clause ; =>#
    """
    (if (eq? ('ast_arrow (car _5)))
      (mkns 
      `(ast_callback_decl ,_3 ,(mkl (cadr _5)) ,(caddr _5) ,_6)
      (cdr _3))
      'ERROR
    )
    """; 

  sbasic_name_comma_list:= sname scomma_name* =># "(cons _1 _2)";
  scomma_name:= , sname =># "_2";

  srequires_clause := requires srequirements =># "_2";
  srequires_clause := sepsilon =># "'()";

  scode_spec := sstring =># "`(strtemplate ,_1)";
  scode_spec := scstring =># "`(str ,_1)";
  scode_spec := sident =># "'identity";

  srequirement:= squalified_name =># "`(named_req ,_1)";
  srequirement := body scode_spec =># "`(body_req ,_2)";
  srequirement := header scode_spec =># "`(header_req ,_2)";
  srequirement :=  property sstring =># "`(property_req ,_2)";
  srequirement :=  package scode_spec =># "`(package_req ,_2)";

  srequirement_atom:= srequirement =># "`(rreq_atom ,_1)";
  srequirement_atom:= ( srequirements ) =># "_2";

  srequirement_and:= srequirement_and and srequirement_atom =>#
    "`(rreq_and ,_1 ,_3)";
  srequirement_and:= srequirement_atom =># "_1";

  srequirement_or:= srequirement_or or srequirement_and =>#
    "`(rreq_or ,_1 ,_3)";
  srequirement_or:= srequirement_and =># "_1";

  srequirements:= srequirements , srequirement_or =>#
    "`(rreq_and ,_1 ,_3)";
  srequirements:= srequirement_or =># "_1";

  sbinding_header:= header scode_spec srequires_clause ; =># 
    """`(ast_insert "_root" ,dfltvs ,_2 header ,_3))"""; 
  sbinding_header:= body scode_spec srequires_clause ; =># 
    """`(ast_insert "_root" ,dfltvs ,_2 body ,_3))"""; 
  sbinding_header:= header = scode_spec srequires_clause ; =># 
    """`(ast_insert "_root" ,dfltvs ,_3 header ,_4))"""; 
  sbinding_header:= body = scode_spec srequires_clause ; =># 
    """`(ast_insert "_root" ,dfltvs ,_3 body ,_4))"""; 
  sbinding_header:= header sdeclname = scode_spec srequires_clause ; =># 
    """
    (mkns 
    `(ast_insert ,(caar _2) ,(cadar _2) ,_4 header ,_5)
    (cdr _2))
     """; 

  sbinding_header:= body sdeclname = scode_spec srequires_clause ; =># 
    """
    (mkns 
    `(ast_insert ,(caar _2) ,(cadar _2) ,_4 body ,_5)
    (cdr _2))
     """; 
 
  sbinding_header := requires srequirements ; =># 
    """`(ast_insert "_root" ,dfltvs (str "") body ,_2)""";

  sbinding_header := sname requires srequirements ; =># 
    """`(ast_insert ,_1 ,dfltvs (str "") body ,_3)""";

  squalified_name_comma_list:= squalified_name scomma_qualified_name* =>#
    "(cons _1 _2)";
  scomma_qualified_name := , squalified_name =># "_2";

  stype_constraint := with squalified_name_comma_list where sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := where sexpr with squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := where sexpr =># "`(,_2 ())";
  stype_constraint := with squalified_name_comma_list =># "`(() ,_2)";

  sopt_type_constraint := stype_constraint? =># "_1";

  seqorin:= = stypeexpr =># "`(eq ,_2)";
  seqorin:= in stypeexpr =># "`(in ,_2)";
  seqorin:= sepsilon =># "'none"; // ambiguous with Some/None?

  stvar := sname seqorin =># "`(,_1 (ast_name typ_type ()) ,_2)";
  stvar := sname : stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := , stvar =># "_2";

  stvarlist:= sepsilon =># "dfltvs";
  stvarlist:= [ stvar_comma_list sopt_type_constraint ] =>#
    "`(,_2 ,_3)";

  sassert_statement:= assert sexpr ; =># "`(ast_assert ,_2)";
  slabel_statement := sname :> =># "`(ast_label ,_1)";
  sgoto_statement := goto sname ; =># "`(ast_goto ,_2)";
  ssvc := _svc sname ; =># "`(ast_svc ,_2)";

  sinline_cpp:= code scode_spec ; =># "`(ast_code ,_2)";
  sinline_cpp:= noreturn code scode_spec ; =># "`(ast_noreturn_code ,_3)";

  stypeparameter:= sname : sarrow =># "`(,_1 ,_3)";
  stypeparameter:= sname =># "`(,_1 typ_none)";
  stypeparameter_comma_list := sepsilon =># "()";
  stypeparameter_comma_list := stypeparameter , stypeparameter_comma_list =># "(cons _1 _3)";
  stypeparameter_comma_list := stypeparameter =># "`(,_1)";

  stypefun_arg := sname =># "`((,_1 typ_none))";
  stypefun_arg := ( stypeparameter_comma_list ) =># "`(,_2)";
  stypefun_args := stypefun_arg+  =># "_1";

  stype_alias := typedef sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_type_alias (,(caar _2) ,(cadar _2) ,_4))
    (cdr _2))
    """; 

  stype_alias := typedef fun sdeclname stypefun_args : sexpr => sexpr ; =>#
    """
    (mkns 
    `(mktypefun (,(caar _3) ,(cadar _3) ,_4 ,_6 ,_8))
    (cdr _3))
    """; 

  stype_alias := typedef fun sdeclname : sexpr => stype_matching+ ; =>#
    """
    (if (eq? ('ast_arrow (car _5)))
      (let (
        (argt (cadr _5))
        (ret (caddr _5))
        (body `(ast_type_match (_a ,_7))))
        (let ((args `((_a ,argt))))
      (mkns 
      `(mktypefun (,(caar _3) ,(cadar _3) ,args ,ret ,body))
      (cdr _3))))
      ('ERROR)
    )
    """; 

  stype_alias := rename sdeclname = squalified_name ; =>#
    """
    (mkns 
    `(ast_inherit (,(caar _2) ,(cadar _2) ,_4))
    (cdr _2))
    """; 

  stype_alias := rename fun sdeclname = squalified_name ; =>#
    """
    (mkns 
    `(ast_inherit (,(caar _3) ,(cadar _3) ,_5))
    (cdr _3))
    """; 

  stype_alias := inherit squalified_name ; =># "`(ast_inject_module ,_2)";
 
  sexport_statement := export fun ssuffixed_name as sstring ; =>#
    "`(ast_export_fun (,_3 ,_5))";
  sexport_statement := export proc ssuffixed_name as sstring ; =>#
    "`(ast_export_fun (,_3 ,_5))";
  sexport_statement := export type (sexpr) as sstring ; =>#
    "`(ast_export_type (,_4 ,_7))";

  sopen_decl := open stvarlist squalified_name ; =>#
    "`(ast_open ,_2 ,_3)";

  suse_decl:= use squalified_name ; =>#
    """
    (let (name
      (if (eq? (car _2) 'ast_lookup) (caddr _2)
        (if (eq? (car _2) 'ast_name) (cadr _2)
        ("ERROR"))))
    `(ast_use ,_name ,_2))
    """;
  suse_decl := use sname = squalified_name ; =># "`(ast_use ,_2 ,_4)";

  // deprecate: class object construction, use a generator
  sassignment := var sname <- new sexpr ; =># 
    "`(ast_apply_ctor ,_2 ,(splitapply ,_5))";

  // a0 <- f (a1, a2, ..)  means f (a0, a1, a2 ..)
  sassignment := sexpr <- sexpr ; =># 
   """
   (let ((fl (splitapply ,_3)))
     (let ((f (car fl))(a (cadr fl)))
       `(ast_call ,f ,(cons _1 a))))
   """;

  sassignop:= = =># "'_set";
  sassignop:= := =># "'_init";

  srmwop:= += =># "'pluseq";
  srmwop:= -= =># "'minuseq";
  srmwop:= *= =># "'muleq";
  srmwop:= /= =># "'diveq";
  srmwop:= %= =># "'modeq";
  srmwop:= <<= =># "'leftshifteq";
  srmwop:= >>= =># "'rightshifteq";
  srmwop:= ^= =># "'bxoreq";
  srmwop:= |= =># "'boreq";
  srmwop:= &= =># "'bandeq";
  srmwop:= ~= =># "'tildeeq";

  sswapop := <-> =># "'_swap";

  spreincrop:= ++ =># "'pre_incr";
  spreincrop:= -- =># "'pre_decr";
  spostincrop:= ++ =># "'post_incr";
  spostincrop:= -- =># "'post_decr";

  slelement := val sname =># "`(Val ,_2)";
  slelement := var sname =># "`(Var ,_2)";
  slelement := sname =># "`(Name ,_1)";
  slelement := _ =># "'Skip";
  slelement := ( slexprs ) =># "`(List ,_2)";

  stlelement := slelement : sfactor =># "`(,_1 (some ,_3))";
  stlelement := slelement =># "`(,_1 none)";

  slexprs := stlelement , slexprs =># "(cons _1 _3)";
  slexprs := stlelement =># "`(,_1)";

  slexpr := slexprs =># 
    """
    (if (null? (cdr _1)) (car _1) `((List ,_1) none))
    """;

  sassignment := def slexpr = sexpr ; =># "`(ast_assign _set ,_2 ,_4)";

  sassignment := sexpr sswapop sexpr ; =># 
    "`(ast_call ,_2 (,_1 ,_3))";

  sassignment := sexpr sassignop sexpr ; =># 
    "`(ast_assign ,_2 ((Expr ,_1) none) ,_3)";

  sassignment := sexpr srmwop sexpr ; =># 
    "`(ast_assign ,_2 ((Expr ,_1) none) ,_3)";

  sassignment := sexpr spostincrop ; =># "`(ast_call ,_2 ,_1)";
  sassignment := spreincrop sexpr ; =># "`(ast_call ,_1 ,_2)";

  stodo := todo sstring ; =># "`(ast_nop ,_2)";
  stodo := todo ; =># """`(ast_nop "todo")""";

  sifgoto := if sexpr goto sname ; =># "`(ast_ifgoto ,_2 ,_4)";
  sifgoto := if sexpr return ; =># "`(ast_ifreturn ,_2)";
  sifgoto := if sexpr call sexpr ; =># 
    "`(ast_ifdo ,_2 (,(cons 'ast_call (splitapply _4)))())";
  sifgoto := if sexpr do sstatements selse_clause done ; =># 
    "`(ast_ifdo ,_2 ,_4 ,_5)";
  sifgoto := if sexpr do sstatements done ; =># 
    "`(ast_ifdo ,_2 ,_4 ())";

  selif_clause := elif sexpr do sstatements =># "`(,_2 ,_4)";
  selif_clause := elif sexpr return ; =># "`(,_2 (ast_proc_return))";
  selif_clause := elif sexpr goto sname ; =># "`(,_2 (ast_goto ,_4))";
  selif_clauses := selif_clauses selif_clause =># "(cons _2 _1)";
  selif_clauses := selif_clause =># "`(,_1)";
  selse_clause := selif_clauses else sstatements =>#
    """      
        (let ((f (lambda (result condthn) 
          (let ((cond (car condthn)) (thn (cadr condthn))) 
            `((ast_ifdo ,cond ,thn ,result))))))
        (fold_left f _3 _1))
    """;

  selse_clause := else sstatements =># "_2";
  selse_clause := selif_clauses =>#
    """      
        (let ((f (lambda (result condthn) 
          (let ((cond (car condthn)) (thn (cadr condthn))) 
            `((ast_ifdo ,cond ,thn ,result))))))
        (fold_left f () _1))
    """;

#keyword whilst
  sifgoto := whilst sexpr do sstatements done; =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" ) 
      ( ast_macro_name "lab2" "" )
      ( ast_label "lab1" ) 
      ( ast_ifgoto (ast_apply (lnot ,_2)) "lab2" ) )
      _4  
      '(( ast_goto "lab1" ) 
      ( ast_label "lab2" ))
      )
    ) 
  """;

  sreturn := yield sexpr ; =># "`(ast_yield ,_2)";
  sreturn := return sexpr ; =># "`(ast_fun_return ,_2)";
  sreturn := return ; =># "'ast_proc_return";
  sreturn := halt sstring ; =># "`(ast_halt ,_2)";

  sstatements := sstatement* =># "_1";
  scompound := { sstatements } =># "_2";
  scall := call sexpr ; =># """(cons 'ast_call (splitapply _2))""";
  scall := sexpr ; =># "(cons 'ast_call (splitapply _1))";

  sval_def := val sname sname_suffix = sexpr ; =># "TODOIT";
    sname_suffix := , sname sname_suffix =># "(cons _2 _3)";
    sname_suffix := , sname =># "`((,_2))";

  sval_def := val sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """; 

  sval_def := val sdeclname : sexpr = sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """; 

  sval_def := val sdeclname : sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,(caar _2) ,(cadar _2) (some ,_4) none)
    (cdr _2))
     """; 

  sval_def := ref sdeclname <- sexpr ; =>#
    """
    (mkns 
    `(ast_ref_decl ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """; 

  sval_def := ref sdeclname : sexpr <- sexpr ; =>#
    """
    (mkns 
    `(ast_ref_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """; 

  svar_def := var sname sname_suffix = sexpr ; =># "TODOIT";

  svar_def := var sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_var_decl ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """; 

  svar_def := var sdeclname : sexpr = sexpr ; =>#
    """
    (mkns 
    `(ast_val_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """; 

  svar_def := var sdeclname : sexpr ; =>#
    """
    (mkns 
    `(ast_var_decl ,(caar _2) ,(cadar _2) (some ,_4) none)
    (cdr _2))
     """; 

  svar_def := var & sname stvarlist : sexpr <- sexpr ; =># "TODOIT";
  svar_def := var sdeclname : sexpr <- sexpr ; =># "TODOIT";


  smacro_definition := macro sname is sname ; =># "`(ast_macro_name ,_2 ,_4)";
  smacro_definition := macro sname is sbasic_name_comma_list ; =># 
    "`(ast_macro_names ,_2 ,_4)";
  smacro_definition := macro for sname in sbasic_name_comma_list do sstatements done ; =># 
    "`(ast_macro_ifor ,_3 ,_5 ,_7)";
  smacro_definition := macro sname is new; =># """`(ast_macro_name ,_2 "")""";
  smacro_definition := macro var sbasic_name_comma_list = sexpr ; =># 
    "`(ast_macro_var ,_3 ,_5)";
  smacro_definition := macro val sbasic_name_comma_list = sexpr ; =># 
    "`(ast_macro_val ,_3 ,_5)";
  smacro_definition := macro sbasic_name_comma_list = sexpr ; =># 
    "`(ast_macro_assign ,_2 ,_4)";
  smacro_definition := macro val sname is sexpr ; =># 
    "`(ast_macro_vals ,_3 ,(mkl _5))";
  smacro_definition := macro fun sname smac_arg_list = sexpr ; =># 
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro fun sname smac_arg_list => sexpr ; =># 
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro proc sname smac_arg_list scompound =># 
    "`(ast_stmt_macro ,_3 ,_4 ,_5)";
  smacro_definition := macro scompound ; =># "`(ast_macro_block ,_2)";
  smacro_definition := macro forget sbasic_name_comma_list ; =># 
    "`(ast_macro_forget ,_3)";
  smacro_definition := macro forget; =># 
    "`(ast_macro_forget ())";
  smacro_definition := macro goto sname ; =># "`(ast_macro_goto ,_3)";
  smacro_definition := macro sname :> =># "`(ast_macro_label ,_3)";
  smacro_definition := macro if sexpr goto sname ; =># 
    "`(ast_macro_ifgoto ,_3 ,_5)";
  smacro_definition := macro for val sbasic_name_comma_list in sexpr do sstatements done ; =># 
    "`(ast_macro_vfor ,_4 ,_6 ,_8)";

    smac_arg:= sname : fun =># "`(,_1 Expr)"; 
    smac_arg:= sname : proc =># "`(,_1 Stmt)"; 
    smac_arg:= sname : sident =># "`(,_1 Stmt)"; 
    smac_arg:= sname =># "`(,_1 Expr)"; 
    smac_args := smac_arg , smac_args =># "(cons _1 _3)";
    smac_args := smac_arg =># "`(,_1)";
    smac_arg_list := ( smac_args ) =># "_2";
    smac_arg_list := () =># "()";

  sglr_production := parse sexpr ; =># "TODOIT";
  sregdef := regexp sexpr ; =># "TODOIT";
  sstruct_decl := struct sexpr ; =># "TODOIT";
  sunion_decl := union sexpr ; =># "TODOIT";
  smodule_definition := module sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_untyped_module ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """; 

  smodule_definition := open module sdeclname sopt_equal scompound =>#
    """
    (mkns 
    `(ast_seq (
      (ast_untyped_module ,(caar _3) ,(cadar _3) ,_6)
      (ast_open (,dfltvs (ast_name ,(caar _3)())))))
    (cdr _2))
     """; 

    sopt_equal := = =># "()";
    sopt_equal := sepsilon =># "()";

  sreduce_args := ( stypeparameter_comma_list ) =># "_2";

  sfunction_definition := reduce sdeclname sreduce_args : sexpr => sexpr ; =>#
  """
    (mkns 
    `(ast_reduce ,(caar _2) ,(cadar _2) ,_3 ,_5 ,_7)
    (cdr _2))
  """;

  sfun_arg :=  ( sparameter_comma_list when sexpr ) =># "`(,_2 ,_4)";
  sfun_arg :=  ( sparameter_comma_list ) =># "`(,_2 none)";
  sfun_arg :=  sname =># "`(((,_1 typ_none)) none)";

  sfunction_definition := axiom sdeclname sfun_arg : sexpr; =>#
  """
    (mkns 
    `(ast_axiom ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
    (cdr _2))
  """;

  sfunction_definition := axiom sdeclname sfun_arg : sexpr = sexpr ; =>#
  """
    (mkns 
    `(ast_axiom ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
    (cdr _2))
  """;

  sfunction_definition := lemma sdeclname sfun_arg : sexpr; =>#
  """
    (mkns 
    `(ast_lemma ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
    (cdr _2))
  """;

  sfunction_definition := axiom sdeclname sfun_arg : sexpr = sexpr ; =>#
  """
    (mkns 
    `(ast_lemma ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
    (cdr _2))
  """;

  sfun_kind := cfun =># "'CFunction";
  sfun_kind := gen =># "'Generator";
  sfun_kind := fun =># "'Function";

  sfunction_definition := sadjectives sfun_kind sdeclname 
    sfun_arg* sopt_type_expr => sexpr ; =>#
  """
    (let ((body `((ast_fun_return ,_7))))
    (mkns 
    `(ast_curry ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,body)
    (cdr _3)))
  """;


  sfunction_definition := sadjectives sfun_kind sdeclname 
    sfun_arg* sopt_type_expr = scompound ; =>#
  """
    (mkns 
    `(ast_curry ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,_7)
    (cdr _3))
  """;

  sopt_cstring := = scode_spec =># "`(some ,_2)";
  sopt_cstring := sepsilon =># "'none";

  sopt_prec := is sname =># "_2";
  sopt_prec := sepsilon =># '(quote "")';

  sfunction_definition := sadjectives sfun_kind sdeclname 
    sopt_type_expr sopt_cstring sopt_prec srequires_clause ; =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t (car _4))
      (traint (cadr _4))
      (prec _6)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and ((rreq_atom (Property_req "virtual")) ,_7))
        _7)
      )
      (ct 
        (if (eq? 'none _5)
          (if (memv 'Virtual _1)
            'Virtual 
             `(StrTemplate ,(string-append (caar _3) "($a)"))
           )
           (cadr _5))
      )
    )
    (let (
      (reqs 
        (if (eq? 'Generator kind)
          `(rreq_and ((rreq_atom (Property_req "generator")) ,reqs))
          reqs))
    )
    (if (eq? 'ast_arrow (car t))
      (let (
        (argt (caadr t))
        (ret (cadadr t)))
      (mkns 
      `(ast_fun_decl ,name ,vs ,(mkl argt) ,ret ,ct ,reqs ,prec)
      (cdr _3)))
      ('ERROR))))
  """;


  sfunction_definition := sadjectives sfun_kind sdeclname 
    sopt_type_expr = smatching+ ; =>#
  """
    (if (eq? 'ast_arrow (caar _4))
      (let (
        (argt (caadr _4))
        (ret (cadadr _4))
        (traint (cadr _3))
        (body `((ast_fun_return (ast_match _a ,_6)))))
    (mkns 
    `(ast_curry ,(caar _3) ,(cadar _3) 
      (((PVal _a ,argt) none))
      (,ret ,traint) 
      ,(cal_funkind _1 _2) ,body)
    (cdr _3)))
    ('ERROR))
  """;

  sproc_kind := proc =># "'Function";
  sproc_kind := cproc =># "'CFunction";

  sopt_traint_eq:= expect sexpr = =># "`(some ,_2)";
  sopt_traint_eq:= sepsilon =># "'none";

  sctor_init := sname ( sexpr ) =># "`(,_1 ,_3)";
  sctor_init_list := sctor_init , sctor_init_list =># "(cons _1 _3)";
  sctor_init_list :=  sctor_init =># "`(,_1)";
  sctor_inits := : sctor_init_list =># "_2";
  sctor_inits := sepsilon =># "()";

  sprocedure_definition := ctor stvarlist sfun_arg* sopt_traint_eq 
    sctor_inits scompound =>#
  """
  (let (
    (name '"__constructor__")
    (vs ,_2)
    (ret 'ast_void)
    (traint ,_4)
    (body ,_6)
    (inits ,_5)
    (args ,_3))
  (let ((f (lambda (ne)`(ast_init ,(car ne),(cadr ne)))))
  (let ((body (map f (append inits body))))
  `(ast_curry ,name ,vs ,args (,ret ,traint) 'Ctor ,body))))
  """;

  sprocedure_definition := sadjectives sproc_kind sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns 
    `(ast_curry ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) ,(cal_funkind _1 _2) ,_6)
    (cdr _3))
  """;

  sprocedure_definition := sadjectives sproc_kind sdeclname : sexpr 
    sopt_cstring srequires_clause ; =>#
  """
  ('ERROR)
  """;

  sobject_definition := obj sdeclname sfun_arg+ scompound =>#
  """
    (mkns 
    `(ast_curry ,(caar _2) ,(cadar _2) ,_3 (typ_none none) 'Object ,_4)
    (cdr _2))
  """;

  sconst_def := sadjectives const sdeclname : sexpr = scode_spec srequires_clause ; =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and ((rreq_atom (Property_req "virtual")) ,_8))
      _8)))
    (mkns 
    `(ast_const_decl ,(caar _3) ,(cadar _3) ,_5 ,_7 ,reqs)
    (cdr _3)))
  """;

  sconst_def := sadjectives const sdeclname : sexpr srequires_clause ; =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and ((rreq_atom (Property_req "virtual")) ,_6))
      _6)))
    (mkns 
    `(ast_const_decl ,(caar _3) ,(cadar _3) ,_5 (Str ,(caar _3)) ,reqs)
    (cdr _3)))
  """;

}


