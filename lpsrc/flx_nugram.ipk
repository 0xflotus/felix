@import config.flx_data as flx_data

@select(tangler("lib/nugram.flxh"))

SCHEME """
(define fold_left
  (lambda (f acc lst)
    (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst)))))
""";

SCHEME """
(define dfltaux '( (ast_tuple ("dummy" 0 0 0 0) ()) ()))
""";

SCHEME """
(define dfltvs
  `(
    ()           ;; vs list: name,type,constraint triple
    ,dfltaux
  )
)
""";

SCHEME """
  (define dfltargs '((() none)))
""";

SCHEME """
  (define (lazy stmts) `(ast_lambda (,dfltvs ,dfltargs typ_none ,stmts)))
""";

SCHEME """
  (define (lazy_proc stmts) `(ast_lambda (,dfltvs ,dfltargs ast_void ,stmts)))
""";

SCHEME """
  (define (block stmts)`(ast_call ,_sr ,(lazy_proc stmts) ())))
""";

SCHEME """
  (define call (lambda (f a) `(ast_call ,_sr (ast_name ,_sr ,f ()) ,a)))
""";

SCHEME """
(define (mkn1 stmt nvs)
  `(ast_namespace ,(car nvs) ,(cadr nvs) (,stmt)))
""";

SCHEME """
(define (mkns stmt nvsl) (
  fold_left mkn1 stmt nvsl
  ))
""";

SCHEME """
(define (splitapply x)
  (if (pair? x)
    (if (eq? (car x) 'ast_apply)
      (if (pair? (cddr x))
        (begin
;;           (display "f=")(display (caaddr x))
;;           (display " arg=")(display (cadaddr x))
;;           (display " pair=")(display (caddr x))
           (caddr x))
        (list x ()))
      (list x ()))
    (list ()))
)
""";

SCHEME """
(define (mkl x)
  (begin
  ;;(display "mkl x=")(display x)
  (if (pair? x)
    (if (eq? (car x) 'ast_tuple)
      (if (pair? (cddr x)) (caddr x) (list x))
      (list x))
    (list x)))
)
""";

SCHEME """
(define (mkl2 x)
  (begin
  ;;(display "mkl2 x=")(display x)
  (if (pair? x)
    (if (eq? (car x) 'ast_product)
      (if (pair? (cddr x)) (caddr x) (list x))
      (list x))
    (list x)))
)
""";

SCHEME """
(define (cal_funkind adjs fk)
  (if (eq? fk 'CFunction)'CFunction
  (if (eq? fk 'Generator)'Generator
  ;; fk is Function
  (if (pair? adjs)(car adjs)'Function
))))
""";

SCHEME """
(define (myassoc elt alst)
  (let ((r (assoc elt alst)))
  (if r (cadr r) `(MISMATCHED_BRACKET ,elt ,alst))))
""";

SCHEME """
(define (tvfixup_folder vsct vtc)
  (begin ;;(display "tvfixup_folder vsct=")(display vsct)(display ", vtc=")(display vtc)(display "\\n")
  (let*
    (
      (vs (car vsct))
      (ct (cadr vsct))
      (v (car vtc))
      (t (cadr vtc))
      (c (caddr vtc))
      (ct2
        (cond
          ((eq? 'NoConstraint c) ct )
          ((eq? 'Eq (car c)) ;; type constraint
            `(ast_intersect
              ((ast_type_match ((ast_name ,_sr ,v ()) ((,(cadr c) ()))))
              ,ct)
            )
          )
          ((eq? 'In (car c)) ;; type constraint
            `(ast_intersect
              ((ast_isin ((ast_name ,_sr ,v ()) ,(cadr c)))
              ,ct)
            )
          )
        (else (display "ERROR!!!"))
        )
      )
    )
    (begin
    ;;  (display "vs=")(display vs)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\nv=")(display v)
    ;;  (display "\\nt=")(display t)
    ;;  (display "\\nc=")(display c)
    ;;  (display "\\nct2=")(display ct2)
    ;;  (display "\\n")
    (list (cons `(,v ,t) vs) ct2))
))))
""";

//
// rti = rtc:type constraint, rtr:typeclass requirement list
//

SCHEME """
(define (tvfixup tv ct)
  (begin ;;(display "tvfixup tv=")(display tv)(display ", ct=")(display ct)(display "\\n")
  (let*
    (
      (vscs (fold_left tvfixup_folder `(() (ast_tuple ,_sr ())) tv))
      (vs (car vscs))
      (cs (cadr vscs))
      (rtc (car ct))
      (rtr (cadr ct))
      (ct `((ast_intersect (,rtc ,cs)) ,rtr))
    )
    (begin
    ;;  (display "vs=")(display vs)
    ;;  (display "\\ncs=")(display cs)
    ;;  (display "\\nrtc=")(display rtc)
    ;;  (display "\\nrtr=")(display rtr)
    ;;  (display "\\nct=")(display ct)
    ;;  (display "\\n")
    (list (reverse vs) ct))
  )
))
""";

SCHEME """
  (define (maybe k)(if (null? k)'none `(some ,(car k))))
""";

SCHEME """
  (define (strap a b)
  (if(null? b)a(if(equal? b "")a(if(equal? a "")b(string-append a " " b)))))
""";

SCHEME """
  (define (strcat ls)(fold_left strap "" ls))
""";

// chain 'and (x) yields just x,
// chain 'and (x y) yields ('and _sr (x y))
SCHEME """
  (define (chain op hd tl)
    (
      if (equal? tl ())
      hd
      `(,op ,_sr ,(cons hd (map cadr tl)))
    )
  )
""";

//------------------------------------------
syntax expressions {
  sexpr := let spattern = sexpr in sexpr =># "`(ast_letin (,_2 ,_4 ,_6))";
  sexpr := slambda =># "_1";

  stypeexpr:= sor_condition =># "_1";
  slambda := sdollar_apply =># "_1";

  page tuples = sdollar_apply, stuple;

  sdollar_apply := stuple unless sexpr then sdollar_apply =>#
    "`(ast_cond ((ast_apply ,_sr (lnot ,_3)) ,_1 ,_5))";
  sdollar_apply := stuple $ sdollar_apply =># "`(ast_apply ,_sr (,_1 ,_3))";
  sdollar_apply := stuple =># "_1";

  stuple := sor_condition ( , sor_condition)* =># "(chain 'ast_tuple _1 _2)";

  page logic =
    sor_condition,
    sand_condition,
    snot_condition,
    scomparison,
    sas_expr,
    ssetunion,
    suser10,
    ssetintersection,
    sarrow,
    scase_literal
  ;

  sor_condition := sand_condition ( or sand_condition)* =># "(chain 'ast_orlist _1 _2)" note "lor";
  sand_condition := snot_condition ( and snot_condition)* =># "(chain 'ast_andlist _1 _2)" note "land";
  snot_condition := not snot_condition  =># "`(ast_apply ,_sr (lnot ,_2))" note "lnot";
  snot_condition := scomparison  =># "_1";

  // NOTE: this version doesn't support chains like a < b < c.. too bad
  scomparison:= sas_expr < sas_expr =># "`(ast_apply ,_sr (lt (,_1 ,_3)))" note "lt";
  scomparison:= sas_expr <= sas_expr =># "`(ast_apply ,_sr (le (,_1 ,_3)))" note "le";
  scomparison:= sas_expr == sas_expr =># "`(ast_apply ,_sr (eq (,_1 ,_3)))" note "eq";
  scomparison:= sas_expr != sas_expr =># "`(ast_apply ,_sr (ne (,_1 ,_3)))" note "ne";
  scomparison:= sas_expr >= sas_expr =># "`(ast_apply ,_sr (ge (,_1 ,_3)))" note "ge";
  scomparison:= sas_expr > sas_expr =># "`(ast_apply ,_sr (gt (,_1 ,_3)))" note "gt";
  scomparison:= sas_expr =># "_1";

  sas_expr := sas_expr as sname =># "`(ast_as (,_1 ,_3))";
  sas_expr := ssetunion =># "_1";

  ssetunion := suser10 ( || suser10)* =># "(chain 'ast_setunion _1 _2)" note "setunion";

  suser10 := suser10 suser10token ssetintersection =>#
    "`(ast_apply ,_sr ( (ast_name ,_sr ,_2 ()) (,_1 ,_3)))";
  suser10 := ssetintersection =># "_1";

  ssetintersection := sarrow (&& sarrow)* =># "(chain 'ast_setintersection _1 _2)" note "setintersection";

  sarrow := scase_literal -> sarrow =># "`(ast_arrow (,_1 ,_3))";
  sarrow := scase_literal --> sarrow =># "`(ast_longarrow (,_1 ,_3))";
  sarrow := scase_literal =># "_1";

  scase_literal := case sinteger =># "`(ast_case_tag ,_2))";
  scase_literal := case sinteger of ssum =># "`(ast_typed_case ,_2 ,_4)";
  scase_literal := case sname of ssum =># "`(ast_variant (,_2 ,_4))";
  scase_literal := sbor =># "_1";

  explain scase_literal """<p>Next: bitwise</p>""";

  page bitwise = sbor, sbxor, sband, sshift;
  sbor := sbor \| sbxor =># "`(ast_apply ,_sr (bor (,_1 ,_3)))" note "bxor";
  sbor := sbxor =># "_1";

  sbxor := sbxor \^ sband =># "`(ast_apply ,_sr (bxor (,_1 ,_3)))" note "bor";
  sbxor := sband =># "_1";

  sband := sband \& sshift =># "`(ast_apply ,_sr (band (,_1 ,_3)))" note "band";
  sband :=  sshift =># "_1";

  sshift := sshift << ssum =># "`(ast_apply ,_sr (shl (,_1 ,_3)))" note "shl";
  sshift := sshift >> ssum =># "`(ast_apply ,_sr (shr (,_1 ,_3)))" note "shr";
  sshift := ssum =># "_1";

  explain sshift """<p>Next: arithmetic</p>""";

  page arithmetic =
    ssum,
    ssubtraction,
    sproduct,
    s_term,
    sprefixed
  ;

  ssum := ssubtraction (plus ssubtraction)* =># "(chain 'ast_sum _1 _2)" note "add";
  ssubtraction := ssubtraction - sproduct =># "`(ast_apply ,_sr (sub (,_1 ,_3)))" note "sub";
  ssubtraction := sproduct =># "_1";

  sproduct := s_term (star s_term)* =># "(chain 'ast_product _1 _2)" note "mul";

  s_term := s_term / spower =># "`(ast_apply ,_sr (div (,_1 ,_3)))" note "div";
  s_term := s_term % spower =># "`(ast_apply ,_sr (mod (,_1 ,_3)))" note "mod";
  s_term := sprefixed =># "_1";

  sprefixed := lval spower =># "`(ast_lvalue ,_2)";
  sprefixed := ! spower =># "`(ast_apply ,_sr (excl ,_2))" note "excl";
  sprefixed := plus spower =># "`(ast_apply ,_sr (pos ,_2))" note "pos";
  sprefixed := - spower =># "`(ast_apply ,_sr (neg ,_2))" note "neg";
  sprefixed := ~ spower =># "`(ast_apply ,_sr (bnot ,_2))" note "bnot";
  sprefixed := spower =># "_1";


  explain sprefixed """<p>Next: exponentials</p>""";

  page exponentials = spower, ssuperscript, srefr;

  spower := ssuperscript ** sprefixed =># "`(ast_apply ,_sr (pow (,_1 ,_3)))" note "pow";
  spower := ssuperscript  =># "_1";

  ssuperscript := ssuperscript ^ srefr =># "`(ast_superscript (,_1 ,_3))";
  ssuperscript := srefr =># "_1";

  srefr := & srefr =># "`(ast_ref ,_2)";
  srefr := star srefr =># "`(ast_apply ,_sr (deref ,_2))" note "deref";
  srefr := _deref srefr =># "`(ast_deref ,_2)";
  srefr := new srefr =># "`(ast_new ,_2)";
  srefr := anon_value =># "_1";
  srefr := sapplication =># "_1";

  explain srefr """<p>Next: applications</p>""";

  page structured_values =
    anon_value,
    sstruct_mem_decl,
    sstruct_assign,
    stype_sum_item,
    stype_sum_item0,
    stype_sum_item1,
    stype_sum_item2,
    stype_sum_items2
  ;

  anon_value := struct lbrace sstruct_mem_decl* rbrace =># "`(ast_record_type ,_3)";
    sstruct_mem_decl := sname : stypeexpr ssemi =># "`(,_1 ,_3)";
  anon_value := struct lbrace sstruct_assign* rbrace =># "`(ast_record ,_3)";
    sstruct_assign := sname = sexpr ssemi =># "`(,_1 ,_3)";

  satom := lpar rassign (, rassign )* rpar =>#
    "`(ast_record ,(cons _2 (map cadr _3)))"
  ;
    rassign := sname = sor_condition =># "`(,_1 ,_3)";

  anon_value := union lbrace stype_sum_item0* rbrace =># "`(ast_variant_type ,_3)";
    stype_sum_item := sname sopt_value stvarlist of sexpr =># "`(,_1 ,_2 ,_3 ,_5)";
    stype_sum_item := sname sopt_value stvarlist =># "`(,_1 ,_2 ,_3 ast_void)";

    stype_sum_item0 := sname of sexpr =># "`(,_1 none ,_3)";
    stype_sum_item0 := sname =># "`(,_1 none ast_void)";

    stype_sum_item1 := stype_sum_item ssemi =># "_1";

    stype_sum_item2 := vbar stype_sum_item =># "_2";
    stype_sum_items2 := stype_sum_item stype_sum_item2* =># "(cons _1 _2)";
    stype_sum_items2 := stype_sum_item2* =># "_1";

  page basic_expr = sapplication, scoercion, sfactor;

  sapplication := scoercion =># "_1";
  sapplication := sapplication scoercion =># "`(ast_apply ,_sr (,_1 ,_2))" note "apply";
  sapplication := caseno scoercion =># "`(ast_case_index ,_2)";
  sapplication := "likely" scoercion =># "`(ast_likely ,_2)";
  sapplication := "unlikely" scoercion =># "`(ast_unlikely ,_2)";

  explain sapplication """
  <p>The system automatically handles application of values of function type.
  However the user can provide overloaded applicators for a value of
  type <code>d</code> to a value of type <code>c</code> by defining
  a function named <code>apply</code> of type <code>d -> c</code>.</p>
  <p>In addition, a constructor for a named type <code>t</code> can be
  defined by a function with the name <code>_ctor_t</code>.
  This function will be invisible if the type already has a constructor
  defined by the system, for example a <code>struct</code>. In fact there
  is no requirement that the function return the specified type: this
  feature is purely syntactic sugar which is used when a function is
  expected and a named type is found. Algebraic types can be used
  via a typedef name.</p>
  """;

  scoercion := sfactor =># "_1";
  scoercion := scoercion : sfactor =># "`(ast_coercion (,_1 ,_3))";
  scoercion := ssuffixed_name =># "_1";

  sfactor := shash_name =># "_1";
  sfactor := sfactor . lsqb sexpr rsqb =># "`(ast_apply ,_sr (subscript (,_1 ,_4)))";
  sfactor := sfactor . lsqb sexpr to sexpr rsqb =># "`(ast_apply ,_sr (substring (,_1 ,_4 ,_6)))";
  sfactor := sfactor . lsqb sexpr to rsqb =># "`(ast_apply ,_sr (copyfrom (,_1 ,_4)))";
  sfactor := sfactor . lsqb to sexpr rsqb =># "`(ast_apply ,_sr (copyto (,_1 ,_5)))";
  sfactor := sfactor . shash_name =>#
    "`(ast_dot ,_sr (,_1 ,_3))))";

  /*
  sfactor := sfactor .-> ssimple_name_parts =>#
    "`(ast_dot ,_sr ((ast_apply ,_sr (deref ,_1)) (ast_name ,_sr ,(car _3) ,(cadr _3))))";
  */

  sfactor := sfactor . lpar sinteger rpar =># "`(ast_get_n (,_4 ,_1))";

  page names =
    shash_name,
    sthe_name,
    ssuffixed_name,
    squalified_name,
    ssimple_name_parts,
    squalified_name_comma_list,
    sbasic_name_comma_list
  ;

  // these are weirdos
  sbasic_name_comma_list:= sname (, sname)* =># "(cons _1 (map cadr _2))";

  squalified_name_comma_list:= squalified_name (, squalified_name)* =>#
    "(cons _1 (map cadr _2))";


  shash_name := # shash_name =># "`(ast_lift ,_2)";
  shash_name := sthe_name =># "_1";

  sthe_name :=
    | the squalified_name =># "`(ast_the ,_2)"
    | noexpand squalified_name =># "`(ast_noexpand ,_2)"
    | quest sname =># "`(ast_patvar ,_2)"
    | squalified_name =># "_1"
  ;
  sthe_name := satom =># "_1";

  squalified_name := squalified_name :: ssimple_name_parts =>#
    "`(ast_lookup (,_1 ,(car _3) ,(cadr _3)))";
  squalified_name := ssimple_name_parts =>#
    "`(ast_name ,_sr ,(car _1) ,(cadr _1))";

  ssuffixed_name := squalified_name of sfactor =>#
    "`(ast_suffix (,_1 ,_3))";

  ssimple_name_parts := sname           =># "`(,_1 ())";
  ssimple_name_parts := sname lsqb sexpr rsqb =># "`(,_1 ,(mkl _3))";

  satom := sliteral =># "_1";
  satom := _ =># "'ast_patany";
  satom := ... =># "'ast_ellipsis";
  satom := sfalse =># "'(ast_typed_case  0 2)";
  satom := strue =># "'(ast_typed_case  1 2)";

  satom := callback lsqb sexpr rsqb =># "`(ast_callback ,_3)";
  satom := [| sexpr |] =># "`(ast_arrayof ,(mkl _2))";
  satom := lbrace sexpr rbrace =># """
    (lazy `((ast_fun_return ,_sr ,_2)))
  """;

  satom := scompound =># "(lazy _1)";

  satom := lpar sexpr rpar =># "_2";
  satom := lpar rpar =># "'()";
  satom := sconditional =># "_1";

  page conditional = sconditional, selif, selifs, selse_part;

  sconditional := if sexpr then sexpr selse_part endif =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

  selif := elif sexpr then sexpr =># "`(,_2 ,_4)";

  selifs := selif =># "`(,_1)";
  selifs := selifs selif =># "(cons _2 _1)";

  selse_part:= else sexpr =># "_2";
  selse_part:= selifs else sexpr =>#
      """
        (let ((f (lambda (result condthn)
          (let ((cond (car condthn)) (thn (cadr condthn)))
            `(ast_cond (,cond ,thn ,result))))))
        (fold_left f _3 _1))
      """;

  satom := suserlbtoken sexpr suserrbtoken =>#
    "`(ast_apply ,_sr ((ast_name ,_sr ,(myassoc _3 (car _1)) ()) ,_2))";

  page atomic = satom, sexpr_code_prefix;

}

//------------------------------------------
syntax patterns {
  satom := pattern_match =># "_1";


  page pattern_matching =
    pattern_match,
    smatching,
    spattern,
    spat_assign,
    sctor_name,
    stuple_pattern,
    scoercive_pattern,
    sas_pattern,
    satomic_pattern,
    sfloating
  ;

  pattern_match := match sexpr with smatching+ endmatch =>#
    "`(ast_match (,_2 ,_4))";

    smatching  := vbar spattern => sexpr =># "`(,_2 ,_4)";
    smatching  := vbar => sexpr =># "`(pat_none ,_4)";

    spattern := sas_pattern when sexpr =># "`(pat_when ,_1 ,_3)";
    spattern := sas_pattern =># "_1";

    sas_pattern := stuple_pattern as sname =># "`(pat_as ,_1 ,_3)";
    sas_pattern := stuple_pattern =># "_1";

    stuple_pattern := scoercive_pattern (, scoercive_pattern )* =># "(chain 'pat_tuple _1 _2)";

    scoercive_pattern := satomic_pattern : sarrow =># "`(pat_coercion ,_1 ,_3)";
    scoercive_pattern := satomic_pattern =># "_1";

    satomic_pattern := strue =># "'(pat_const_ctor (ast_case_tag 1))";
    satomic_pattern := sfalse =># "'(pat_const_ctor (ast_case_tag 0))";
    satomic_pattern := sstring =># "`(pat_string ,_1)";
    satomic_pattern := quest sname =># "`(pat_as pat_any ,_2)";
    satomic_pattern := _ =># "'pat_any";
    satomic_pattern := lpar spattern rpar =># "_2";
    satomic_pattern := struct lbrace spat_assign+ rbrace =># "`(pat_record ,_3)";
      spat_assign := sname = spattern ssemi =># "`(,_1 ,_3)";

    satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
    satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";
      sctor_name := squalified_name =># "_1";
      sctor_name := case sinteger =># "`(ast_case_tag ,_2)";

    satomic_pattern := sstring .. sstring =># "`(pat_string_range ,_1 ,_3)";
    satomic_pattern := sintegral =># "`(pat_int ,(car _1) ,(cadr _1))";
    satomic_pattern := sintegral .. sintegral=>#
      "`(pat_int_range ,(car _1) ,(cadr _1) ,(car _3) ,(cadr _3))";

    satomic_pattern := NaN =># "'pat_nan";
    satomic_pattern := sfloating .. sfloating =>#
      "`(pat_float_range ,_1 ,_3)";

      sfloating:= sfloat =># "`(Float_plus ,(car _1) ,(cadr _1))";
      sfloating:= - sfloat =># "`(Float_minus ,(car _2) ,(cadr _2))";
      sfloating:= inf =># "'Float_inf";
      sfloating:= - inf =># "'Float_minus_inf";


}

//------------------------------------------
syntax functions {
  requires expressions;
  sdeclarative := sfunction_definition =># "_1";
  sdeclarative := sobject_definition =># "_1";
  sdeclarative := sprocedure_definition =># "_1";
  sdeclarative := sctor_definition =># "_1";

  page functions = sfunction_definition, sfun_kind, sfun_arg, fun_return_type;
  page procedures =
    sprocedure_definition,
    sproc_kind,
    sopt_traint,
    sopt_traint_eq,
    class_constructor=
     (
       sctor_definition, sctor_init, sctor_inits
     )
  ;

  page adjectives = sadjective, sadjectives;
  page parameters = sparameter, sparameter_comma_list, sparam_qual;
  page lambda = slambda, slambda_fun_arg, slambda_fun_args;

  slambda := sadjectives fun stvarlist slambda_fun_args fun_return_type = scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ,_7))
    """;

  slambda := sadjectives fun stvarlist slambda_fun_args fun_return_type => sexpr =>#
    """
    `(ast_lambda (,_3 ,_4 ,(car _5) ((ast_fun_return ,_sr ,_7))))
    """;

  slambda := sadjectives proc stvarlist slambda_fun_args scompound =>#
    """
    `(ast_lambda (,_3 ,_4 ast_void ,_5))
    """;

  slambda := sadjectives proc stvarlist scompound =>#
    """
    `(ast_lambda (,_3 ((() none)) ast_void ,_4))
    """;

    sadjective := inline =># "'InlineFunction";
    sadjective := noinline =># "'NoInlineFunction";
    sadjective := virtual =># "'Virtual";
    sadjectives := sadjective* =># "_1";

    slambda_fun_arg := lpar sparameter_comma_list when sexpr rpar =># "`(,_2 (some ,_4))";
    slambda_fun_arg := lpar sparameter_comma_list rpar =># "`(,_2 none)";
    slambda_fun_args := slambda_fun_arg+ =># "_1";

    fun_return_type := : stypeexpr expect sexpr =># "`(,_2 (some ,_4))";
    fun_return_type := : stypeexpr =># "`(,_2 none)";
    fun_return_type := expect sexpr =># "`(typ_none (some ,_2))";
    fun_return_type := sepsilon =># "'(typ_none none)";

  explain fun_return_type """
  <p>A function return specification consists of an optional type
  and an optional expected postcondition. The special identifier
  <code>result</code> can be used in the postcondition to denote
  the returned value. If the postcondition is omitted it is
  quivalent to <code>true</code>, otherwise the postcondition
  is check after every application.</p>
  <p>If the return type is not specified, the compiler will
  try to calculate it from the function definition. Occasionally
  this will fail for recursive functions due to the interaction
  with overloading and recursive types. Reusable library functions
  should always provide an explicit return type annotation.</p>
  """;

    sparameter := sparam_qual sname : sarrow = sor_condition =># "`(,_1 ,_2 ,_4 (some ,_6))";
    sparameter := sparam_qual sname : sarrow =># "`(,_1 ,_2 ,_4 none)";
    sparameter := sparam_qual sname =># "`(,_1 ,_2 typ_none none)";

    explain sparameter """
    <p>If the type is elided, a fresh type variable is used.</p>
    """;

    sparameter_comma_list := sepsilon =># "()";
    sparameter_comma_list := sparameter (, sparameter)* =># "(cons _1 (map cadr _2))";


    sparam_qual := val =># "'PVal";
    sparam_qual := var =># "'PVar";
    sparam_qual := ref =># "'PRef";
    sparam_qual := fun =># "'PFun";
    sparam_qual := sepsilon =># "'PVal";

    explain sparam_qual """
    <p>Parameter qualifiers have the following meaning:
    <dl>
    <dt>val</dt><dd>The default: Pass by name or value, may be inlined (lazy evaluation), and maybe not.</dd>
    <dt>var</dt><dd>Pass by value, assign to local variable (eager evaluation, copying).</dd>
    <dt>ref</dt><dd>Enforced Lazy evaluation.
      Pass a pointer to the specified type by value.
      Automatically dereferenced in function body.
      Caller will usually explicitly take address, eg <code>&amp;x</code>.
      </dd>
    <dt>fun</dt><dd>Enforced Lazy evaluation.
      Pass a closure of a function of unit argument returning the specified value.
      Automatically called in function body.
      Caller will usually explicitly wrap, eg <code>{ 42 }</code>.
      </dd>
    </dl>
    </P>
    """;

  sfun_arg :=  lpar sparameter_comma_list when sexpr rpar =># "`(,_2 (some ,_4))";
  sfun_arg :=  lpar sparameter_comma_list rpar =># "`(,_2 none)";
  sfun_arg :=  sname =># "`(((PVal ,_1 typ_none none)) none)";

  sfun_kind := cfun =># "'CFunction";
  sfun_kind := gen =># "'Generator";
  sfun_kind := fun =># "'Function";

  explain sfun_kind """
  <p>The function kinds have the following semantics:
  <dl>
  <dt>fun</dt><dd>An ordinary Felix function. Must not have side-effects.
    The representation is indeterminate, and may be a C++ class with an
    <code>apply()</code> method, an ordinary C function, or nothing if all applications
    are inlined away.
  </dd>
  <dt>cfun</dt><dd>Enforces creation of a C style function.</dd>
  <dt>gen</dt><dd>Create a generator. A generator is a
    function with side-effects, which includes any kind of
    object creation (such as a C++ string), or function which
    impacts external state such as <code>malloc()</code>
    or <code>random()</code>.
    <p>Generator applications are
    always lifted out of expressions and the result of the
    application assigned to a temporary variable, which
    replaces the application in the original expression.
    This ensures a generator application is evaluated exactly
    one if the enclosing expression is evaluated. This feature
    is similar to C sequence points.
  </dd>
  </dl>
  </p>
  """;

  sfunction_definition := sadjectives sfun_kind sdeclname
    sfun_arg* fun_return_type => sexpr ssemi =>#
  """
    (let ((body `((ast_fun_return ,_sr ,_7))))
    (mkns
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,body)
    (cdr _3)))
  """;


  sfunction_definition := sadjectives sfun_kind sdeclname
    sfun_arg* fun_return_type = scompound =>#
  """
    (mkns
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_5 ,(cal_funkind _1 _2) ,_7)
    (cdr _3))
  """;

  sopt_cstring := = scode_spec =># "`(some ,_2)";
  sopt_cstring := sepsilon =># "'none";

  sfunction_definition := sadjectives sfun_kind sdeclname
    fun_return_type = smatching+ ssemi =>#
  """
   (let
     (
      (t (car _4))
      (traint (cadr _4))
     )
    (begin ;;(display "ftype=")(display t)(display "\\n")
    (if (eq? 'ast_arrow (car t))
      (let
        (
          (argt (caadr t))
          (ret (cadadr t))
          (body `((ast_fun_return ,_sr (ast_match (_a ,_6)))))
        )
        (mkns
        `(ast_curry ,_sr ,(caar _3) ,(cadar _3)
          (
            (((PVal _a ,argt none)) none)
          )
          (,ret ,traint)
          ,(cal_funkind _1 _2) ,body)
        (cdr _3))
      )
      'ERROR
     )
     )
   )
  """;

  sproc_kind := proc =># "'Function";
  sproc_kind := cproc =># "'CFunction";

  sopt_traint_eq:= expect sexpr = =># "`(some ,_2)";
  sopt_traint_eq:= sepsilon =># "'none";

  sopt_traint:= expect sexpr =># "`(some ,_2)";
  sopt_traint:= sepsilon =># "'none";


  sctor_init := sname lpar sexpr rpar =># "`(,_1 ,_3)";
  sctor_inits := : sctor_init (, sctor_init)* =># "(cons _2 _3)";
  sctor_inits := sepsilon =># "()";

  // only used by classes
  sctor_definition := ctor stvarlist sfun_arg* sopt_traint_eq
    sctor_inits scompound =>#
  """
  (let*
    (
      (name "__constructor__")
      (vs _2)
      (ret 'ast_void)
      (traint _4)
      (body _6)
      (inits _5)
      (args _3)
      (f (lambda (ne)`(ast_init ,_sr ,(car ne) ,(cadr ne))))
      (body (append (map f inits) body))
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Ctor ,body))
  """;

  sctor_definition := ctor stvarlist sname sfun_arg+ sopt_traint_eq
    scompound =>#
  """
  (let*
    (
      (name (string-append "_ctor_" _3))
      (vs _2)
      (ret `(ast_name ,_sr ,_3 ()))
      (traint _5)
      (body _6)
      (args _4)
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Function ,body))
  """;

  sctor_definition := ctor stvarlist sname sfun_arg+
    sopt_traint => sexpr ssemi =>#
  """
  (let*
    (
      (name (string-append "_ctor_" _3))
      (vs _2)
      (ret `(ast_name ,_sr ,_3 ()))
      (traint _5)
      (body `((ast_fun_return ,_sr ,_7)))
      (args _4)
    )
    `(ast_curry ,_sr ,name ,vs ,args (,ret ,traint) Function ,body))
  """;

  sprocedure_definition := sadjectives sproc_kind sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) ,(cal_funkind _1 _2) ,_6)
    (cdr _3))
  """;

  sobject_definition := obj sdeclname sfun_arg+ scompound =>#
  """
    (mkns
    `(ast_curry ,_sr ,(caar _2) ,(cadar _2) ,_3 (typ_none none) Object ,_4)
    (cdr _2))
  """;

}


//------------------------------------------
syntax regexps {
  requires expressions;
  satom := sregmatch_expr =># "_1";
  sdirective := sregdef =># "_1";

  page regular_expressions =
    sregmatch_expr,
    sregmatch_alternatives,
    sregmatch_alternative,
    sregdef,
    sre0, sre1, sre2, sre3, sre4, sre_name,
    scharset, scharset0
  ;

  sregmatch_expr := reglex sexpr to sexpr with sregmatch_alternatives endmatch =>#
    "`(ast_reglex (,_2 ,_4 ,_6))";
  sregmatch_expr := regmatch sexpr with sregmatch_alternatives endmatch =>#
    "`(ast_string_regmatch (,_2 ,_4))";

  sregmatch_alternatives := sregmatch_alternative + =># "(reverse _1)";
  sregmatch_alternative := vbar sre1 => sexpr =># "`(,_2 ,_4)";

  sregdef := regexp sname = sre1 ssemi =># "`(ast_regdef ,_sr ,_2 ,_4)";

  sre0 := sre1 as sname =># "`(regexp_group ,_3 ,_1)";
  sre0 := sre1 =># "_1";

  sre1 := sre1 vbar sre2 =># "`(regexp_alt ,_1 ,_3)";
  sre1 := sre2 =># "_1";

  sre2 := sre2 sre3 =># "`(regexp_seq ,_1 ,_2)";
  sre2 := sre3 =># "_1";

  sre3 := sre4 star =># "`(regexp_aster ,_1)";
  sre3 := sre4 plus =># "`(regexp_seq ,_1 (regexp_aster ,_1))";
  sre3 := sre4 quest =># "`(regexp_alt regexp_epsilon ,_1)";
  sre3 := sre4 =># "_1";

  sre4 := sstring =># "`(regexp_string ,_1)";
  sre4 := _ =># "'regexp_underscore";
  sre4 := . =># "'regexp_dot";
  sre4 := lpar sre0 rpar =># "_2";
  sre4 := lsqb scharset rsqb =># "`(regexp_of_charset ,_2)";
  sre4 := lsqb ^ scharset rsqb =># "`(regexp_of_charset (charset_inv ,_3))";
  sre4 := sre_name =># "`(regexp_name ,_1)";

  sre_name := sre_name :: sname =># "`(ast_lookup (,_1 ,_3 ()))";
  sre_name := sname =># "`(ast_name ,_sr ,_1 ())";

  scharset0:= sinteger - sinteger =># "`(charset_of_int_range ,_1 ,_3)";
  scharset0:= sstring - sstring =># "`(charset_of_range ,_1 ,_3)";
  scharset0:= sstring =># "`(charset_of_string ,_1)";
  scharset0:= sinteger =># "`(charset_of_int_range ,_1 ,_1)";

  scharset:= scharset scharset0 =># "`(charset_union ,_1 ,_2)";
  scharset:= scharset0 =># "_1";

}

//------------------------------------------
syntax parsing {
  requires expressions, statements;
  satom := sglr_parse =># "_1";
  sdirective := sglr_production =># "_1";

  page glr_parsing =
    sglr_parse,
    sglr_production,
    sglr_matching,
    sglr_entry,
    sglr_seq,
    sglr_alts,
    sglr_term
  ;

  sglr_term := squalified_name =># "`(GLR_name ,_1)";
  sglr_term := sglr_term quest =># "`(GLR_opt ,_1)";
  sglr_term := sglr_term star =># "`(GLR_ast ,_1)";
  sglr_term := sglr_term plus =># "`(GLR_plus ,_1)";

  sglr_term := lbrace sglr_alts rbrace =># "`(GLR_ast ,_2)";
  sglr_term := lpar sglr_alts rpar =># "_2";

  sglr_seq:= sglr_term sglr_term+ =># "`(GLR_seq ,(cons _1 _2))";
  sglr_seq:= sglr_term =># "_1";

  sglr_alts := sglr_seq (vbar sglr_seq)+ =># "`(GLR_alt ,(cons _1 (map cadr _2)))";
  sglr_alts := sglr_seq =># "_1";

  sglr_entry:= sname colon sglr_term =># "`((some ,_1) ,_3)";
  sglr_entry:= sglr_term =># "`(none ,_1)";

  sglr_matching:= vbar sglr_entry* => sexpr =># "`(,_2 ,_4)";

  sglr_production:= nonterm sname colon sexpr = sglr_matching+ ssemi =>#
  "`(ast_glr ,_sr ,_2 ,_4 ,_6)";

explain sglr_production """<p>A nonterm directive defines
nonterminal as a sequence of symbols and a user
action.<p>""";

  sglr_parse:= parse sexpr with sglr_matching+ endmatch =>#
  "`(ast_parse ,_sr ,_2 ,_4)";

explain sglr_parse """<p>A GLR parsing expression accepts
a token source generator as its first argument. This must
be a generator returning a value of union type when applied
to the unit argument.</p>
""";

}


//------------------------------------------
syntax statements {
  requires expressions;
  statement:= sdeclarative =># "_1";
  statement:= sinclusion =># "_1";
  statement:= sdirective =># "_1";
  statement:= spublish =># "_1";
  statement:= scomment =># "_1";
  statement:= snull_statement =># "_1";
  statement:= scparse =># "_1";

  scomment := comment sstring ssemi =># "`(ast_comment ,_sr ,_2)";


  spublish := private sdeclarative =># "`(ast_private ,_2)";
  spublish := private sbinding_definition =># "`(ast_private ,_2)";
  spublish := private svar_def =># "`(ast_private ,_2)";
  spublish := private sval_def =># "`(ast_private ,_2)";

  spublish := "publish" sstring statement =># "_3";

  sdeclarative := smodule_definition =># "_1";
  sdeclarative := sunion_decl =># "_1";
  sdeclarative := sstruct_decl =># "_1";
  sdeclarative := stype_alias =># "_1";

  sdirective := sopen_decl =># "_1";

  snull_statement := ssemi =># """`(ast_nop ,_sr "")""";

  sinclusion := include sstring ssemi =># "`(ast_include ,_sr ,_2)";
  scparse := cparse sstring ssemi =># "`(ast_cparse ,_sr ,_2)";

  // note: list is reversed, eg X::Y::name goes to list name, Y, Z
  sdeclname := sdeclname :: sname stvarlist =># "(cons `(,_3 ,_4) _1)";
  sdeclname := sname stvarlist =># "`((,_1 ,_2))";

  sabstract_type := stype_qual* type sdeclname = new sexpr ssemi =>#
    """
    (mkns
    `(ast_newtype ,_sr ,(caar _3) ,(cadar _3) ,_6)
    (cdr _3))
    """;

  page type_variables =
    stvarlist,
    stvar_comma_list,
    stvar,
    scomma_tvar,
    seqorin,
    stype_constraint
  ;


  stype_constraint := with squalified_name_comma_list where sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := where sexpr with squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := where sexpr =># "`(,_2 ())";
  stype_constraint := with squalified_name_comma_list =># "`((ast_tuple,_sr()) ,_2)";
  stype_constraint := sepsilon =># "`((ast_tuple,_sr())())";

  explain stype_constraint
  """<p>A <code>with</code> clause is a side constraint
  on the set of type variables, it specifies a list
  of typeclass specialisations, requiring suitable instances
  exist, but also allowing functions of the typeclass to
  be applied to the specified types in the body of the
  definition.</p>
  <p>A <code>where</code> constraint is an arbitrary
  predicate on type variables, which must resolve to true for
  any use of the symbol being defined. It is typically an
  equation, but may also be a type match. In the case of
  a function or procedure, failed predicative constraints
  exclude the function from any overload set.</p>
  """;

  seqorin:= = stypeexpr =># "`(Eq ,_2)";
  seqorin:= in stypeexpr =># "`(In ,_2)";
  seqorin:= sepsilon =># "'NoConstraint";

  explain seqorin
  """<p>An <code>=</code> assignment suffix on a type variable is used
  to add a dependent type variable to the list of type variables.
  </p>
  <p>An <code>in</code> suffix specifies that a type variable
  is a member of a typeset. in the case of a function
  or procedure, failure of this constraint excludes the function
  from any overload set.</p>
  """;

  stvar := sname seqorin =># """`(,_1 (ast_name ,_sr "TYPE" ()) ,_2)""";
  stvar := sname : stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := , stvar =># "_2";

  stvarlist:= sepsilon =># "dfltvs";
  stvarlist:= lsqb stvar_comma_list stype_constraint rsqb =>#
    "(tvfixup _2 _3)";

  stypeparameter:= sname : sarrow =># "`(,_1 ,_3)";
  stypeparameter:= sname =># "`(,_1 typ_none)";
  stypeparameter_comma_list := sepsilon =># "()";
  stypeparameter_comma_list := stypeparameter , stypeparameter_comma_list =># "(cons _1 _3)";
  stypeparameter_comma_list := stypeparameter =># "`(,_1)";

  stypefun_arg := sname =># "`((,_1 typ_none))";
  stypefun_arg := lpar stypeparameter_comma_list rpar =># "_2";
  stypefun_args := stypefun_arg+  =># "_1";

  stodo := todo sstring ssemi =># "`(ast_nop ,_sr ,_2)";
  stodo := todo ssemi =># """`(ast_nop ,_sr "todo")""";

  scompound := lbrace statement* rbrace =># "_2";

  sname_suffix:= comma sname sname_suffix =># "(cons _2 _3)";
  sname_suffix:= comma sname =># "`(,_2)";

}

//------------------------------------------
syntax variables {
  // assignments have lower priority than variable
  // definitions to support 'int x = 1;' being
  // a variable definition not an assignment,
  // so we have to requires them first: they're
  // currently defined in executable.. this is fragile ..
  requires statements, executable;

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  sval_def := val sname sname_suffix = sexpr ssemi =>#
  """
  (let
    (
      (names (cons _2 _3))
      (vals (mkl _5))
    )
    (begin
    ;;(display "names=")(display names)
    ;;(display "init=")(display vals)
    ;;(display "\\n")
    (if (eq? (length names)(length vals))
      (let
        (
          (f (lambda (n v)`(ast_val_decl ,_sr ,n ,dfltvs none (some ,v))))
        )
        `(ast_seq ,_sr ,(map f names vals))
      )
      (let*
        (
          (f (lambda (n)`((Val ,_sr ,n) none)))
          (lexpr (map f names))
        )
        `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
      )
  )))
  """;

  sval_def := val sdeclname = sexpr ssemi =>#
    """
    (mkns
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """;

  sval_def := val sdeclname : stypeexpr = sexpr ssemi =>#
    """
    (mkns
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """;

explain sval_def """<p>Value definition requires an initialiser.</p>""";

  sval_def := val sdeclname : stypeexpr ssemi =>#
    """
    (mkns
    `(ast_val_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) none)
    (cdr _2))
     """;

explain sval_def """<p>Value declaration, only allowed in classes.</p>""";

  sval_def := ref sdeclname <- sexpr ssemi =>#
    """
    (mkns
    `(ast_ref_decl ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """;

  sval_def := ref sdeclname : stypeexpr <- sexpr ssemi =>#
    """
    (mkns
    `(ast_ref_decl ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """;

  svar_def := var sname sname_suffix = sexpr ssemi =>#
  """
  (let
    (
      (names (cons _2 _3))
      (vals (mkl _5))
    )
    (begin
    ;;(display "names=")(display names)
    ;;(display "init=")(display vals)
    ;;(display "\\n")
    (if (eq? (length names)(length vals))
      (let
        (
          (f (lambda (n v)`(ast_var_decl ,_sr ,n ,dfltvs none (some ,v))))
        )
        `(ast_seq ,_sr ,(map f names vals))
      )
      (let*
        (
          (f (lambda (n)`((Var ,_sr ,n) none)))
          (lexpr (map f names))
        )
        `(ast_assign ,_sr _set ((List ,lexpr) none) ,_5)
      )
  )))
  """;

  svar_def := var sdeclname = sexpr ssemi =>#
    """
    (mkns
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) none (some ,_4))
    (cdr _2))
     """;

  svar_def := var sdeclname : stypeexpr = sexpr ssemi =>#
    """
    (mkns
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) (some ,_6))
    (cdr _2))
     """;

  svar_def := var sdeclname : stypeexpr ssemi =>#
    """
    (mkns
    `(ast_var_decl ,_sr ,(caar _2) ,(cadar _2) (some ,_4) none)
    (cdr _2))
     """;

  svar_def := var & sname stvarlist : stypeexpr <- sexpr ssemi =>#
     """
   (let* (
     (fl (splitapply _8))
     (f (car fl))
     (a (cadr fl))
     (nua (cons `(ast_ref (ast_name ,_sr ,_3 ())) (mkl a)))
     (call `(ast_call ,_sr ,f ,nua))
     (vardef `(ast_var_decl ,_sr ,_3 ,_4 (some ,_6) none))
     (seq `(ast_seq ,_sr (,vardef ,call))))
     (begin
     ;;(display "f=")(display f)
     ;;(display "\\n_3=")(display _3)
     ;;(display "\\na=")(display a)
     ;;(display "\\nnua=")(display nua)
     ;;(display "\\ncall=")(display call)
     ;;(display "\\nvardef=")(display vardef)
     ;;(display "\\nseq=")(display seq)
     ;;(display "\\n")
     seq))
     """;


  svar_def := var sdeclname : stypeexpr <- sexpr ssemi =>#
   """
   (let*
     (
       (fl (splitapply _6))
       (f (car fl))
       (a (cadr fl))
       (name (caar _2))
       (vs (cadar _2))
       (namespace (cdr _2))
       (typ _4)
       (nua (cons `(ast_name ,_sr ,name ()) (mkl a)))
       (call `(ast_call ,_sr ,f ,nua))
       (vardef `(ast_var_decl ,_sr ,name ,vs (some ,typ) none))
       (seq `(ast_seq ,_sr (,vardef ,call)))
     )
     (begin
     ;;(display "f=")(display f)
     ;;(display "\\na=")(display a)
     ;;(display "\\nname=")(display name)
     ;;(display "\\nvs=")(display vs)
     ;;(display "\\ntyp=")(display typ)
     ;;(display "\\nnua=")(display nua)
     ;;(display "\\ncall=")(display call)
     ;;(display "\\nvardef=")(display vardef)
     ;;(display "\\nseq=")(display seq)
     ;;(display "\\nnamespace=")(display namespace)
     ;;(display "\\n")
     (mkns seq namespace)
     ))
     """;
}

//------------------------------------------
syntax macros {
  requires expressions, statements;

  sdirective := smacro_definition =># "_1";
  smacro_definition := macro sname is sbasic_name_comma_list ssemi =>#
    "`(ast_macro_names ,_2 ,_4)";

  // this MUST be next, overrides case with only one name
  smacro_definition := macro sname is sname ssemi =># "`(ast_macro_name ,_2 ,_4)";
  smacro_definition := macro for sname in sbasic_name_comma_list do statement* done ssemi =>#
    "`(ast_macro_ifor ,_3 ,_5 ,_7)";
  smacro_definition := macro for sname in lpar sbasic_name_comma_list rpar do statement* done ssemi =>#
    "`(ast_macro_ifor ,_3 ,_6 ,_9)";

  smacro_definition := macro sname is new ssemi =># """`(ast_macro_name ,_2 "")""";
  smacro_definition := macro var sbasic_name_comma_list = sexpr ssemi =>#
    "`(ast_macro_var ,_3 ,_5)";
  smacro_definition := macro val sbasic_name_comma_list = sexpr ssemi =>#
    "`(ast_macro_val ,_3 ,_5)";
  smacro_definition := macro sbasic_name_comma_list = sexpr ssemi =>#
    "`(ast_macro_assign ,_2 ,_4)";
  smacro_definition := macro val sname is sexpr ssemi =>#
    "`(ast_macro_vals ,_3 ,(mkl _5))";
  smacro_definition := macro fun sname smac_arg_list = sexpr ssemi =>#
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro fun sname smac_arg_list => sexpr ssemi =>#
    "`(ast_expr_macro ,_3 ,_4 ,_6)";
  smacro_definition := macro proc sname smac_arg_list scompound =>#
    "`(ast_stmt_macro ,_3 ,_4 ,_5)";
  smacro_definition := macro scompound ssemi =># "`(ast_macro_block ,_2)";
  smacro_definition := macro forget sbasic_name_comma_list ssemi =>#
    "`(ast_macro_forget ,_3)";
  smacro_definition := macro forget ssemi =>#
    "`(ast_macro_forget ())";
  smacro_definition := macro goto sname ssemi =># "`(ast_macro_goto ,_3)";
  smacro_definition := macro sname :> =># "`(ast_macro_label ,_2)";
  smacro_definition := macro if sexpr goto sname ssemi =>#
    "`(ast_macro_ifgoto ,_3 ,_5)";
  smacro_definition := macro for val sbasic_name_comma_list in sexpr do statement* done ssemi =>#
    "`(ast_macro_vfor ,_4 ,_6 ,_8)";

  page macro_terms = smac_arg, smac_args, smac_arg_list;

    smac_arg:= sname : fun =># "`(,_1 Expr)";
    smac_arg:= sname : proc =># "`(,_1 Stmt)";
    smac_arg:= sname : sident =># "`(,_1 Stmt)";
    smac_arg:= sname =># "`(,_1 Expr)";
    smac_args := smac_arg , smac_args =># "(cons _1 _3)";
    smac_args := smac_arg =># "`(,_1)";
    smac_arg_list := lpar smac_args rpar =># "_2";
    smac_arg_list := lpar rpar =># "()";

  sapplication := macro ctor sname scoercion =># "`ast_macro_ctor (,_3 ,_4))";
}

//------------------------------------------
syntax cbind {
  requires expressions, statements;

  statement:= sbinding_definition =># "_1";
  sbinding_definition :=  sabstract_type =># "_1";
  sbinding_definition :=  sconst_def =># "_1";
  sbinding_definition :=  sbinding_header =># "_1";
  sbinding_definition :=  sexport_statement =># "_1";
   sexport_statement := export fun ssuffixed_name as sstring ssemi =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
  sexport_statement := export proc ssuffixed_name as sstring ssemi =>#
    "`(ast_export_fun ,_sr ,_3 ,_5)";
  sexport_statement := export type lpar sexpr rpar as sstring ssemi =>#
    "`(ast_export_type ,_sr ,_4 ,_7)";


  sstruct_decl := cstruct sdeclname = ? lbrace sstruct_mem_decl * rbrace =>#
    """
    (mkns
    `(ast_cstruct ,_sr ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """;

  sopt_prec := is sname =># "_2";
  sopt_prec := sepsilon =># '(quote "")';

  explain sopt_prec """
    <p>This attribute is used to specify the precedence of a C expression
    so that the code generator can place parenthesis around it if it
    is embedded in a context with higher precedence.</p>
    <p>Felix automatically calculates the predence for tightly
    packed encodings of all C operators; for example there is no
    need to specify the precedence of <code>"$1+$2"</code>.</p>
    <p>Otherwise, if the precedence is omitted, the expression is
    assumed to be low, and parenthesis is always added.<p>
    <p> The precedence must be one of the following identifiers:
    <ol>
@for i in flx_data.cprecedence: tangle ('<li>'+i+'</li>')
    </ol></p>
  """;

  // note: also needed by typeclasses atm for virtual funs
  sfunction_definition := sadjectives sfun_kind sdeclname
    fun_return_type sopt_cstring sopt_prec srequires_clause ssemi =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t (car _4))
      (traint (cadr _4))
      (prec _6)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
        _7)
      )
      (ct
        (if (eq? 'none _5)
          (if (memv 'Virtual _1)
            'Virtual
             `(StrTemplate ,(string-append (caar _3) "($a)"))
           )
           (cadr _5))
      )
    )
    (let (
      (reqs
        (if (eq? 'Generator kind)
          `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
          reqs))
    )
    (if (eq? 'ast_arrow (car t))
      (let (
        (argt (caadr t))
        (ret (cadadr t)))
      (mkns
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
      (cdr _3)))
      ('ERROR))))
  """;

  sfunction_definition :=
    ctor stvarlist sname : stypeexpr
    sopt_cstring sopt_prec srequires_clause ssemi =>#
  """
  (let*
    (
      (name (string-append "_ctor_" _3))
      (vs _2)
      (ret `(ast_name ,_sr ,_3 ()))
      (argt _5)
      (ct
        (if (eq? 'none _6)
          `(StrTemplate ,(string-append _3 "($a)"))
          (cadr _6)
        )
      )
      (prec _7)
      (reqs _8)
    )
    `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs ,prec)
  )
  """;

  page abstract_types = sabstract_type, stype_qual;

  sabstract_type:= stype_qual* type sdeclname = scode_spec srequires_clause ssemi =>#
    """
    (mkns
    `(ast_abs_decl ,_sr ,(caar _3) ,(cadar _3) ,_1 ,_5 ,_6)
    (cdr _3))
    """;

  sabstract_type := callback proc sname : stypeexpr srequires_clause ssemi =>#
    """
    `(ast_callback_decl ,_sr ,_3 ,(mkl2 _5) ast_void ,_6)
    """;


  sabstract_type := callback fun sname : stypeexpr srequires_clause ssemi =>#
    """
    (if (eq? 'ast_arrow (car _5))
      (let*
        (
          (ft (cadr _5))
          (dom (car ft))
          (cod (cadr ft))
          (args (mkl2 dom))
        )
      `(ast_callback_decl  ,_sr,_3 ,args ,cod ,_6)
      )
      'ERROR
    )
    """;


  stype_qual := incomplete =># "'Incomplete";
  stype_qual := pod =># "'Pod";
  stype_qual := _gc_pointer =># "'GC_pointer";
  stype_qual := _gc_type stypeexpr =># "`(Raw_needs_shape ,_2)";

  sabstract_type:= stype_qual* ctypes sbasic_name_comma_list srequires_clause ssemi =>#
    "`(ast_ctypes ,_sr ,_3 ,_1 ,_4)";

  sexecutable := sinline_cpp =># "_1";
  sinline_cpp:= code scode_spec ssemi =># "`(ast_code ,_sr ,_2)";
  sinline_cpp:= noreturn code scode_spec ssemi =># "`(ast_noreturn_code ,_sr ,_3)";

  sclass_component:= var sname : stypeexpr ssemi =># "`(MemberVar ,_2 ,_4 none)";
  sclass_component:= val sname : stypeexpr ssemi =># "`(MemberVal ,_2 ,_4 none)";
  sclass_component:= ctor sopt_name : stypeexpr sopt_cstring ssemi =>#
    "`(MemberCtor ,_2 none ,_4 ,_5)";
  sclass_component:= fun sname stvarlist  : stypeexpr sopt_cstring ssemi =>#
    "`(MemberFun ,_2 none ,_3 ,_5 ,_6)";
  sclass_component:= proc sname stvarlist  : stypeexpr sopt_cstring ssemi =>#
    "`(MemberProc ,_2 none ,_3 ,_5 ,_6)";

  sstruct_decl := cclass sdeclname = ? lbrace sclass_component * rbrace =>#
    """
    (mkns
    `(ast_cclass ,_sr ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """;

  sexpr_code_prefix := code lsqb stypeexpr rsqb =># "_3";
  satom := sexpr_code_prefix sstring =># "`(ast_expr ,_2 ,_1)";
  satom := sexpr_code_prefix sname =># "`(ast_expr ,_2 ,_1)";

  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives const sdeclname : stypeexpr = scode_spec srequires_clause ssemi =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and (rreq_atom (Property_req "virtual")) ,_8)
      _8)))
    (mkns
    `(ast_const_decl ,_sr ,(caar _3) ,(cadar _3) ,_5 ,_7 ,reqs)
    (cdr _3)))
  """;

explain sconst_def """<p>A const definition defines a typed
expression in terms of C code. Note that whilst the C code
is usually a constant value, any expression can be used.<p>""";


  // note: also needed by typeclasses atm for virtual consts
  sconst_def := sadjectives const sdeclname : stypeexpr srequires_clause ssemi =>#
  """
    (let ((reqs (if (memv 'Virtual _1)
      `(rreq_and (rreq_atom (Property_req "virtual")) ,_6)
      _6)))
    (mkns
    `(ast_const_decl ,_sr ,(caar _3) ,(cadar _3) ,_5 (Str ,(caar _3)) ,reqs)
    (cdr _3)))
  """;

explain sconst_def """<p>A short form const definition maps
a Felix name onto the same C name.<p>""";

  // note: also needed by typeclasses atm for virtual procs
  sprocedure_definition := sadjectives sproc_kind sdeclname : stypeexpr
    sopt_cstring srequires_clause ssemi =>#
  """
    (let (
      (name (caar _3))
      (vs (cadar _3))
      (kind (cal_funkind _1 _2))
      (t _5)
      (reqs (if (memv 'Virtual _1)
        `(rreq_and (rreq_atom (Property_req "virtual")) ,_7)
        _7)
      )
      (ct
        (if (eq? 'none _6)
          (if (memv 'Virtual _1)
            'Virtual
             `(StrTemplate ,(string-append (caar _3) "($a);"))
           )
           (cadr _6))
      )
    )
    (let (
      (reqs
        (if (eq? 'Generator kind)
          `(rreq_and (rreq_atom (Property_req "generator")) ,reqs)
          reqs))
    )
    (let (
      (argt t)
      (ret 'ast_void))
      (mkns
      `(ast_fun_decl ,_sr ,name ,vs ,(mkl2 argt) ,ret ,ct ,reqs "")
      (cdr _3)))))
  """;


}

//------------------------------------------
syntax executable {
  requires statements;
  statement:= sexecutable =># "_1";
  sexecutable := scall =># "_1";
  sexecutable := ssvc =># "_1";
  sexecutable := sreturn =># "_1";
  sexecutable := sifgoto =># "_1";
  sexecutable := stodo =># "_1";
  sexecutable := sassignment =># "_1";
  sexecutable := sgoto_statement=># "_1";
  sexecutable := slabel_statement =># "_1";

  page system_call = ssvc;
  ssvc := _svc sname ssemi =># "`(ast_svc ,_sr ,_2)";

  page assignments =
    sassignment, sassignexpr, sassignop,
    srmwop, sswapop,
    spreincrop, spostincrop,
    slelement,
    stlelement,
    slexprs, slexpr
  ;


  sassignment := sassignexpr ssemi =># "_1";

  // deprecate: class object construction, use a generator
  sassignexpr := var sname <- new sexpr =>#
    "(append `(ast_apply_ctor ,_sr ,_2) (splitapply _5))";

  // a0 <- f (a1, a2, ..)  means f (a0, a1, a2 ..)
  sassignexpr := sexpr <- sexpr =>#
   """
   (let* (
     (fl (splitapply _3))
     (f (car fl))
     (a (cadr fl)))
     (begin
     ;; (display "f=")(display f)
     ;; (display "\\n_1=")(display _1)
     ;; (display "\\na=")(display a)
     ;; (display "\\nnew a=")(display (cons _1 (mkl a)))
     ;; (display "\\n")
     `(ast_call ,_sr ,f ,(cons _1 (mkl a)))))
   """;

  sassignop:= = =># "'_set";
  sassignop:= := =># "'_init";

  srmwop:= += =># "'pluseq";
  srmwop:= -= =># "'minuseq";
  srmwop:= *= =># "'muleq";
  srmwop:= /= =># "'diveq";
  srmwop:= %= =># "'modeq";
  srmwop:= <<= =># "'leftshifteq";
  srmwop:= >>= =># "'rightshifteq";
  srmwop:= ^= =># "'bxoreq";
  srmwop:= |= =># "'boreq";
  srmwop:= &= =># "'bandeq";
  srmwop:= ~= =># "'tildeeq";

  sswapop := <-> =># "'_swap";

  spreincrop:= ++ =># "'pre_incr";
  spreincrop:= -- =># "'pre_decr";
  spostincrop:= ++ =># "'post_incr";
  spostincrop:= -- =># "'post_decr";

  slelement := val sname =># "`(Val ,_sr ,_2)";
  slelement := var sname =># "`(Var ,_sr ,_2)";
  slelement := sname =># "`(Name ,_sr ,_1)";
  slelement := _ =># "`(Skip ,_sr)";
  slelement := lpar slexprs rpar =># "`(List ,_2)";

  stlelement := slelement : sfactor =># "`(,_1 (some ,_3))";
  stlelement := slelement =># "`(,_1 none)";

  slexprs := stlelement , slexprs =># "(cons _1 _3)";
  slexprs := stlelement =># "`(,_1)";

  slexpr := slexprs =>#
    """
    (if (null? (cdr _1)) (car _1) `((List ,_1) none))
    """;

  sassignexpr := def slexpr = sexpr =># "`(ast_assign ,_sr _set ,_2 ,_4)";

  sassignexpr := sexpr sswapop sexpr =>#
    "`(ast_call ,_sr ,_2 (,_1 ,_3))";

  sassignexpr := sexpr sassignop sexpr =>#
    "`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)";

  sassignexpr := sexpr srmwop sexpr =>#
    "`(ast_assign ,_sr ,_2 ((Expr ,_sr ,_1) none) ,_3)";

  sassignexpr := sexpr spostincrop =># "`(ast_call ,_sr ,_2 ,_1)";
  sassignexpr := spreincrop sexpr =># "`(ast_call ,_sr ,_1 ,_2)";

  page subroutines =
    sreturn, scall
  ;

  sreturn := yield sexpr ssemi =># "`(ast_yield ,_sr ,_2)";
  sreturn := return sexpr ssemi =># "`(ast_fun_return ,_sr ,_2)";
  sreturn := return ssemi =># "`(ast_proc_return ,_sr)";
  sreturn := halt sstring ssemi =># "`(ast_halt ,_sr ,_2)";
  sreturn := "trace" sname sstring ssemi =># "`(ast_trace ,_sr ,_2 ,_3)";

  scall := call sexpr ssemi =># """(cons 'ast_call (cons _sr (splitapply _2)))""";
  scall := jump sexpr ssemi =># """(cons 'ast_jump (cons _sr (splitapply _2)))""";
  //scall := loop sname sexpr ssemi =># "`(ast_loop ,_sr ,_2 ,_3)";
  //scall := loop sname ssemi =># "`(ast_loop ,_sr ,_2 (ast_tuple,_sr ()))";
  scall := loop sname sexpr ssemi =># "`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) ,_3)";
  scall := loop sname ssemi =># "`(ast_jump ,_sr (ast_name ,_sr ,_2 ()) (ast_tuple,_sr ()))";

  scall := sexpr ssemi =># "(cons 'ast_call (cons _sr (splitapply _1)))";

  page gotos =
    slabel_statement, sgoto_statement,
    sifgoto, selif_clause, selif_clauses, selse_clause
  ;

  slabel_statement := sname :> =># "`(ast_label ,_sr ,_1)";
  sgoto_statement := goto sname ssemi =># "`(ast_goto ,_sr ,_2)";


  sifgoto := if sexpr goto sname ssemi =># "`(ast_ifgoto ,_sr ,_2 ,_4)";
  sifgoto := if sexpr return ssemi =># "`(ast_ifreturn ,_sr ,_2)";
  sifgoto := if sexpr call sexpr ssemi =>#
    "`(ast_ifdo ,_sr ,_2 (,(cons 'ast_call (cons _sr (splitapply _4))))())";
  sifgoto := if sexpr do statement* selse_clause done ssemi =>#
    "`(ast_ifdo ,_sr ,_2 ,_4 ,_5)";
  sifgoto := if sexpr do statement* done ssemi =>#
    "`(ast_ifdo ,_sr ,_2 ,_4 ())";

  selif_clause := elif sexpr do statement* =># "`(,_2 ,_4)";
  selif_clause := elif sexpr return ssemi =># "`(,_2 ((ast_proc_return ,_sr)))";
  selif_clause := elif sexpr goto sname ssemi =># "`(,_2 (ast_goto ,_sr ,_4))";
  selif_clauses := selif_clauses selif_clause =># "(cons _2 _1)";
  selif_clauses := selif_clause =># "`(,_1)";
  selse_clause := selif_clauses else statement* =>#
    """
        (let ((f (lambda (result condthn)
          (let ((cond (car condthn)) (thn (cadr condthn)))
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f _3 _1))
    """;

  selse_clause := else statement* =># "_2";
  selse_clause := selif_clauses =>#
    """
        (let ((f (lambda (result condthn)
          (let ((cond (car condthn)) (thn (cadr condthn)))
            `((ast_ifdo ,_sr ,cond ,thn ,result))))))
        (fold_left f () _1))
    """;

  sifgoto := "whilst" sexpr do statement* done ssemi =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" )
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" )
      ( ast_unlikely_ifnotgoto ,_sr ,_2 "lab2" ))
      _4
      `(( ast_goto ,_sr "lab1" )
      ( ast_label ,_sr "lab2" ))
      )
    )
  """;

  sifgoto := "until" sexpr do statement* done ssemi =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" )
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" )
      ( ast_unlikely_ifgoto ,_sr ,_2 "lab2" ))
      _4
      `(( ast_goto ,_sr "lab1" )
      ( ast_label ,_sr "lab2" ))
      )
    )
  """;


  sifgoto := "forall" sname in sexpr do statement* done ssemi =>#
    "`(ast_macro_vfor (,_2) ,_4 ,_6)";
  ;

  sifgoto := "forall" sname in sexpr "upto" sexpr do statement* done ssemi =>#
  """
    `(ast_macro_block ,( append `(
      (ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_2 ())) none) ,_4)
      ( ast_macro_name "lab1" "" )
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" )
      ( ast_unlikely_ifnotgoto ,_sr
        (ast_apply ,_sr (le ((ast_name ,_sr ,_2 ()),_6)))
        "lab2"
      ))
      _8
      `((ast_call ,_sr pre_incr (ast_name ,_sr ,_2()))
      ( ast_goto ,_sr "lab1" )
      ( ast_label ,_sr "lab2" ))
     ))
  """;

  sifgoto := "forall" sname in sexpr "downto" sexpr do statement* done ssemi =>#
  """
    `(ast_macro_block ,( append `(
      (ast_assign ,_sr _set ((Expr ,_sr (ast_name ,_sr ,_2 ())) none) ,_4)
      ( ast_macro_name "lab1" "" )
      ( ast_macro_name "lab2" "" )
      ( ast_label ,_sr "lab1" )
      ( ast_unlikely_ifnotgoto ,_sr
        (ast_apply ,_sr (ge ((ast_name ,_sr ,_2 ()) ,_6)))
        "lab2"
      ))
      _8
      `((ast_call ,_sr pre_decr (ast_name ,_sr ,_2 ()))
      ( ast_goto ,_sr "lab1" )
      ( ast_label ,_sr "lab2" ))
     ))
  """;
}

//------------------------------------------
syntax requirements {
  srequires_clause := requires srequirements =># "_2";

  page requirement_terms =
    sbinding_header,
    srequires_clause,
    srequirement,
    srequirement_atom,
    srequirement_and,
    srequirement_or,
    srequirements
  ;

  srequires_clause := sepsilon =># "'rreq_true";

  explain srequires_clause """
  <p>A requires clause is used to establish a dependency between
  a named C binding, particularly abstract types, and resources
  such as C code needed to define the subject of the binding, particularly
  C header files, so that the specified resource is loaded
  if, and only if, one of the dependent C bindings is used.</p>

  <p>This not only makes it possible to minimise the header files
  read by the C++ compiler processing the output of Felix, but also
  to provide Felix libraries binding to C libraries which are not
  installed without breaking the compilation process, provided
  the library is not actually used.</p>

  <p>The requirement mechanism is also responsible for triggering
  the emission of a run or link time resource requirements list which in
  turn is used to search for and link external C libraries, without
  user command line intervention.</p>

  <p>Requirements may be polymorphic, in which case an instance for
  each combination of type variable instances is emitted.</p>

  <p>Requirements can be named, and may depend on other requirements.
  Those dependencies may be recursive. Felix emits C code resources
  in order of writing, independently of the dependencies.</p>

  <p>A resource which is C text to be emitted in the header or body
  file generated by Felix is known as a <em>floating insertion</em>.
  </p>

  <p>The name of a requirement is sometimes called a <em>tag name</em>,
  however unlike C struct tags, tag names live in the same unified
  namespace as other declarations.</p>
  """;

  srequirement:= squalified_name =># "`(Named_req ,_1)";
  srequirement :=  property sstring =># "`(Property_req ,_2)";
  srequirement :=  package scode_spec =># "`(Package_req ,_2)";

  srequirement_atom:= srequirement =># "`(rreq_atom ,_1)";
  srequirement_atom:= lpar srequirements rpar =># "_2";

  srequirement_and:= srequirement_and and srequirement_atom =>#
    "`(rreq_and ,_1 ,_3)";
  srequirement_and:= srequirement_atom =># "_1";

  srequirement_or:= srequirement_or or srequirement_and =>#
    "`(rreq_or ,_1 ,_3)";
  srequirement_or:= srequirement_and =># "_1";

  srequirements:= srequirements , srequirement_or =>#
    "`(rreq_and ,_1 ,_3)";
  srequirements:= srequirement_or =># "_1";


  srequirement := body scode_spec =># "`(Body_req ,_2)";
  srequirement := header scode_spec =># "`(Header_req ,_2)";

  scode_spec := sstring =># "`(StrTemplate ,_1)";
  scode_spec := scstring =># "`(Str ,_1)";
  scode_spec := sident =># "'Identity";

  sbinding_header := requires srequirements ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs (Str "") body ,_2)""";

  sbinding_header := sname requires srequirements ssemi =>#
    """`(ast_insert ,_sr ,_1 ,dfltvs (Str "") body ,_3)""";

  sbinding_header:= header scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 header ,_3))""";
  sbinding_header:= body scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_2 body ,_3))""";
  sbinding_header:= header = scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 header ,_4))""";
  sbinding_header:= body = scode_spec srequires_clause ssemi =>#
    """`(ast_insert ,_sr "_root" ,dfltvs ,_3 body ,_4))""";
  sbinding_header:= header sdeclname = scode_spec srequires_clause ssemi =>#
    """
    (mkns
    `(ast_insert ,_sr ,(caar _2) ,(cadar _2) ,_4 header ,_5)
    (cdr _2))
     """;

  sbinding_header:= body sdeclname = scode_spec srequires_clause ssemi =>#
    """
    (mkns
    `(ast_insert ,_sr ,(caar _2) ,(cadar _2) ,_4 body ,_5)
    (cdr _2))
     """;

}

syntax type_decls {
  requires statements;

  satom := stypematch =># "_1";

  page type_decls =
    stype_alias,
    stypematch,
    stype_matching,
    stypefun_arg,
    stypefun_args,
    stypeparameter,
    stypeparameter_comma_list
  ;

  stype_alias := typedef sdeclname = sexpr ssemi =>#
    """
    (mkns
    `(ast_type_alias ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
    """;

  stype_alias := typedef fun sdeclname stypefun_args : stypeexpr => sexpr ssemi =>#
    """
    (mkns
    `(mktypefun ,_sr ,(caar _3) ,(cadar _3) ,_4 ,_6 ,_8)
    (cdr _3))
    """;

  stype_alias := typedef fun sdeclname : stypeexpr = stype_matching+ ssemi =>#
    """
    (if (eq? 'ast_arrow (car _5))
      (let (
        (argt (caadr _5))
        (ret (cadadr _5))
        (body `(ast_type_match (_a ,_7))))
        (let ((args `(((_a ,argt)))))
      (mkns
      `(mktypefun ,_sr ,(caar _3) ,(cadar _3) ,args ,ret ,body)
      (cdr _3))))
      ('ERROR)
    )
    """;

  stype_matching  := vbar sexpr => sexpr =># "`(,_2 ,_4)";

  stypematch := typematch sexpr with stype_matching+ endmatch =>#
    "`(ast_type_match (,_2 ,_4))";

  sstruct_decl := struct sdeclname = ? lbrace sstruct_mem_decl * rbrace =>#
    """
    (mkns
    `(ast_struct ,_sr ,(caar _2) ,(cadar _2) ,_5)
    (cdr _2))
     """;

  sopt_name := sname =># "_1";
  sopt_name := sepsilon =># '""';

  sstruct_decl := class sdeclname = ? scompound =>#
    """
    (mkns
    `(ast_class ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  sstruct_decl := typeclass sdeclname = ? scompound =>#
    """
    (mkns
    `(ast_typeclass ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  sstruct_decl := instance stvarlist squalified_name = ? scompound =>#
    """
    `(ast_instance ,_sr ,_2 ,_3 ,_5)
     """;

  sunion_decl := union sdeclname = stype_sum_items2 ssemi =>#
    """
    (mkns
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  sunion_decl := union sdeclname lbrace stype_sum_item1* rbrace =>#
    """
    (mkns
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  sunion_decl := senum_decl =># "_1";

  senum_decl := enum sdeclname lbrace senum_items rbrace =>#
    """
    (mkns
    `(ast_union ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  page enumeration = senum_decl, sopt_value, senum_item, senum_items;

  sopt_value := = sinteger =># "`(some ,_2)";
  sopt_value := sepsilon =># "'none";
  senum_item := sname sopt_value =># "`(,_1 ,_2 ,dfltvs ast_void)";
  senum_items := senum_item , senum_items =># "(cons _1 _3)";
  senum_items := senum_item =># "`(,_1)";
  senum_items := sepsilon =># "()";

}

//------------------------------------------
syntax assertions {
  requires statements;
  sexecutable := sassert_statement =># "_1";

  page assertions =
    sassert_statement,
    sassertion,
    sreduce_args
  ;

  sassert_statement:= assert sexpr ssemi =># "`(ast_assert ,_sr ,_2)";

  sdeclarative := sassertion =># "_1";

  sassertion := axiom sdeclname sfun_arg : sexpr ssemi =>#
  """
    (mkns
    `(ast_axiom ,_sr ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
    (cdr _2))
  """;

  explain sassertion """<p>An axiom using a general predicate
  to specify semantics.</p>
  """;

  sassertion := axiom sdeclname sfun_arg : sexpr = sexpr ssemi =>#
  """
    (mkns
    `(ast_axiom ,_sr ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
    (cdr _2))
  """;

  explain sassertion """<p>An axiom using equality to specify semantics.</p>""";


  sassertion := lemma sdeclname sfun_arg : sexpr ssemi =>#
  """
    (mkns
    `(ast_lemma ,_sr ,(caar _2) ,(cadar _2) ,_3 (Predicate ,_5))
    (cdr _2))
  """;

  sassertion := lemma sdeclname sfun_arg : sexpr = sexpr ssemi =>#
  """
    (mkns
    `(ast_lemma ,_sr ,(caar _2) ,(cadar _2) ,_3 (Equation (,_5 ,_7)))
    (cdr _2))
  """;

  explain sassertion """<p>A lemma is a proposition which can be
  derived from axioms by an automatic theorem prover.</p>
  """;


  sreduce_args := lpar stypeparameter_comma_list rpar =># "_2";

  sassertion := reduce sdeclname sreduce_args : sexpr => sexpr ssemi =>#
  """
    (mkns
    `(ast_reduce ,_sr ,(caar _2) ,(cadar _2) ,_3 ,_5 ,_7)
    (cdr _2))
  """;

  explain sassertion """<p>A reduction is an axiom or lemma
  specified as a rewriting rule. Rewriting rules are applied
  exhaustively to eliminate left hand side terms globally.</p>
  """;
}

syntax namespaces {
  requires statements;
  sopen_decl := rename sdeclname = squalified_name ssemi =>#
    """
    (mkns
    `(ast_inherit ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
    """;

  sopen_decl := rename fun sdeclname = squalified_name ssemi =>#
    """
    (mkns
    `(ast_inherit_fun ,_sr ,(caar _3) ,(cadar _3) ,_5)
    (cdr _3))
    """;

  sopen_decl := inherit squalified_name ssemi =># "`(ast_inject_module ,_sr ,_2)";

  sopen_decl := open stvarlist squalified_name ssemi =>#
    "`(ast_open ,_sr ,_2 ,_3)";

  sopen_decl := use squalified_name ssemi =>#
    """
    (let ((name
      (if (eq? (car _2) 'ast_lookup) (cadadr _2)
        (if (eq? (car _2) 'ast_name) (cadr _2)
        ("ERROR")))))
    `(ast_use ,_sr ,name ,_2))
    """;
  sopen_decl := use sname = squalified_name ssemi =># "`(ast_use ,_sr ,_2 ,_4)";

  smodule_definition := module sdeclname = ? scompound =>#
    """
    (mkns
    `(ast_untyped_module ,_sr ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  smodule_definition := open module sdeclname = ? scompound =>#
    """
    (mkns
    `(ast_seq ,_sr (
      (ast_untyped_module ,_sr ,(caar _3) ,(cadar _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(caar _3)()))))
    (cdr _3))
     """;

  smodule_definition := namespace sdeclname = ? scompound =>#
    """
    (mkns
    `(ast_namespace ,(caar _2) ,(cadar _2) ,_4)
    (cdr _2))
     """;

  smodule_definition := open namespace sdeclname = ? scompound =>#
    """
    (mkns
    `(ast_seq ,_sr (
      (ast_namespace ,(caar _3) ,(cadar _3) ,_5)
      (ast_open ,_sr ,dfltvs (ast_name ,_sr ,(caar _3)()))))
    (cdr _3))
     """;

}

//------------------------------------------

syntax csyntax {
  requires statements;

  base_type :=
    | "char" =># '`(ast_name ,_sr "char" ())' note "C character"
    | "tiny" =># '`(ast_name ,_sr "tiny" ())'
    | "short" =># '`(ast_name ,_sr "short" ())'
    | "int" =># '`(ast_name ,_sr "int" ())'
    | "long" =># '`(ast_name ,_sr "long" ())'
    | "vlong" =># '`(ast_name ,_sr "vlong" ())'
    | "utiny" =># '`(ast_name ,_sr "utiny" ())'
    | "uchar" =># '`(ast_name ,_sr "utiny" ())'
    | "ushort" =># '`(ast_name ,_sr "ushort" ())'
    | "uint" =># '`(ast_name ,_sr "uint" ())'
    | "ulong" =># '`(ast_name ,_sr "ulong" ())'
    | "uvlong" =># '`(ast_name ,_sr "uvlong" ())'
    | "float" =># '`(ast_name ,_sr "float" ())'
    | "double" =># '`(ast_name ,_sr "double" ())'
    | "ldouble" =># '`(ast_name ,_sr "ldouble" ())'

    | struct sname =># "`(ast_name ,_sr ,_2 ())"
    | union sname =># "`(ast_name ,_sr ,_2 ())"
    | class sname =># "`(ast_name ,_sr ,_2 ())"
    | enum sname =># "`(ast_name ,_sr ,_2 ())"
  ;

explain base_type """
<p>Support for basic C types.</p>
""";


explain base_type """
<p>Although matching only
Felix names for these types, you can actually use
the C type name, for example <code>long long</code>
with be translated by the lexer to <code>ulong</code>.</p>
""";


  pointer_type:=
    | base_type =># "_1"
    | "void" star =># '`(ast_name ,_sr "address" ())'
    | pointer_type star =># "`(ast_ref ,_1)"
  ;

explain pointer_type """
<p>Note that pointers to const are not supported.</p>
""";


  c_type :=
    | pointer_type =># "_1"
    | c_type lpar star rpar lpar c_type_list rpar =>#
      "`(ast_longarrow (,_6 ,_1))"           // cfunction
  ;

explain c_type """
<p>Note that function pointer types are C function
pointers <code>A--&gt;B</code>.</p>
""";


  c_type_suffix := comma c_type =># "_2";
  c_type_list :=
    | c_type c_type_suffix+ =># "`(ast_tuple,_sr ,(cons _1 _2))"
    | c_type =># "_1"
    | sepsilon =># "`(ast_tuple,_sr ())"
  ;

  page c_types =
    base_type,
    pointer_type,
    c_type,
    c_type_suffix,
    c_type_list
  ;

  declarator :=
    | pointer_type sname =># "`(PVar ,_2 ,_1)"
    | pointer_type const sname =># "`(PVal ,_3 ,_1)"
    | c_type lpar sname rpar lpar c_type_list rpar =>#
      "`(PVar ,_3 (ast_longarrow (,_6 ,_1)))"

    | c_type lpar star sname rpar lpar c_type_list rpar =>#
      "`(PVar ,_4 (ast_longarrow (,_7 ,_1)))"

    | c_type sname lpar c_type_list rpar =>#
      "`(PVar ,_2 (ast_longarrow (,_4 ,_1)))"
  ;

explain declarator """
<p>Top level const is supported by passing by <code>val</code>,
otherwise we pass by <code>var</code></p>
""";

explain declarator """
<p>Note that function pointer types are C function
pointers <code>A--&gt;B</code>.</p>
""";


  // function parameter
  sparameter := declarator =># "(append _1 `(none))";
  sparameter := declarator = sor_condition =># "(append _1 `((some ,_3)))";

explain sparameter """
<p> C style function paramaters like <code>int x</code> mean
the same as <code>x:int</code></p>
""";

  // initialised variable
  svar_def := declarator = sexpr ssemi =>#
    """
    (let*
      (
        (kind (car _1))
        (name (cadr _1))
        (type (caddr _1))
        (dcl (if (eq? kind 'PVal) 'ast_val_decl 'ast_var_decl))
      )
    `(,dcl ,_sr ,name ,dfltvs (some ,type) (some ,_3)))
    """;

  // uninitialised variable (RISKY)
  svar_def := declarator ssemi =>#
    """
    (let*
      (
        (kind (car _1))
        (name (cadr _1))
        (type (caddr _1))
        (dcl (if (eq? kind 'PVal) 'ast_val_decl 'ast_var_decl))
      )
    `(,dcl ,_sr ,name ,dfltvs (some ,type) none))
    """;


  // function
  sprocedure_definition := sadjectives "void" sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (ast_void ,_5) Function ,_6)
    (cdr _3))
  """;

  // function
  sfunction_definition := sadjectives pointer_type sdeclname
    sfun_arg* sopt_traint_eq scompound =>#
  """
    (mkns
    `(ast_curry ,_sr ,(caar _3) ,(cadar _3) ,_4 (,_2 ,_5) Function ,_6)
    (cdr _3))
  """;

  // union
  stype_sum_item1 := declarator ssemi =># """
    `(,(car _1) none ,dfltvs ,(cadr _1))
  """;

  // struct, cstruct
  sstruct_mem_decl := declarator ssemi =># """
    ;;(begin (display "\\ndeclarator=")(display _1)
    ;;(display "\\nvariable=")(display (cadr _1))
    ;;(display "\\ntype=")(display (caddr _1))
    `(,(cadr _1) ,(caddr _1))
    ;;)
  """;

  // typedef
  stype_alias := typedef declarator ssemi =>#
    """
    `(ast_type_alias ,_sr ,(car _2) ,dfltvs ,(cadr _2))
    """;

  sifgoto := "break" ssemi =># '`(ast_goto ,_sr "break_label")';
  sifgoto := "continue" ssemi =># '`(ast_goto ,_sr "continue_label")';
  sifgoto := "redo" ssemi =># '`(ast_goto ,_sr "redo_label")';

  sifgoto := for lpar statement sexpr ssemi sassignexpr rpar statement =>#
  """
    (let*
      (
        (init _3)
        (cond _4)
        (iter _6)
        (body _8)
      )
    (block ( append `(
      ,init
      (ast_label ,_sr "redo_label" )
      (ast_unlikely_ifnotgoto ,_sr ,cond "break_label")
      ,body
      (ast_label ,_sr "continue_label" )
      ,iter
      (ast_goto ,_sr "redo_label")
      ( ast_label ,_sr "break_label" ))
    )))
  """;

  // note: we use sdollar_apply not sexpr here,
  // otherwise while (fun ()=>x) { } is interpreted
  // as a C while loop, instead of the while HOF in the library

  sifgoto := "while" lpar sdollar_apply rpar statement =>#
  """
    ( block ( append `(
      ( ast_label ,_sr "continue_label" )
      ( ast_unlikely_ifnotgoto ,_sr ,_3 "break_label" )
      ,_5
      ( ast_goto ,_sr "continue_label" )
      ( ast_label ,_sr "break_label" )
    )))
  """;

  sifgoto := do scompound "until" sdollar_apply ssemi =>#
  """
    ( block ( append `(
      ( ast_label ,_sr "continue_label" )
      ,( block _2)
      ( ast_likely_ifnotgoto ,_sr ,_4 "continue_label" )
      ( ast_label ,_sr "break_label" )
    )))
  """;

  sifgoto := if lpar sdollar_apply rpar statement else statement =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" )
      ( ast_macro_name "lab2" "" )
      ( ast_ifnotgoto ,_sr ,_3 "lab1" )
      ,_5
      (ast_goto ,_sr "lab2")
      ( ast_label ,_sr "lab1" )
      ,_7
      ( ast_label ,_sr "lab2" )
    )))
  """;

  // this must be given first ..
  sifgoto := if lpar sdollar_apply rpar statement =>#
  """
    `( ast_macro_block ,( append `(
      ( ast_macro_name "lab1" "" )
      ( ast_ifnotgoto ,_sr ,_3 "lab1" )
      ,_5
      ( ast_label ,_sr "lab1" )
    )))
  """;

}

//------------------------------------------
syntax felix {
  requires
    statements,
      type_decls,
      variables,
      executable,
      assertions,
      namespaces,
    requirements,
    expressions,
    functions,
    patterns,
    cbind,
    regexps,
    parsing,
    macros,
    csyntax
  ;
}

