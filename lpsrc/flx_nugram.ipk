@select(tangler("lib/nugram.flxh"))

SCHEME """
(define fold_left
  (lambda (f acc lst) 
    (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst)))))
""";

SCHEME """
(define dfltvs '(() (()())))
""";

SCHEME """
(define mkn1 (lambda (stmt nvs) 
  `(ast_namespace (,(car nvs) ,(cadr nsv) (,stmt)))))
""";

SCHEME """
(define mkns (lambda (stmt nsvl) (
  fold_left mkn1 stmt nsvl
  )))
""";

syntax expressions {
  satom := _ =># "'ast_patany";
  satom := ... =># "'ast_ellipsis";
  
  sexpr_code_prefix := code [ sexpr ] =># "_3";
  satom := sexpr_code_prefix sexpr =># "`(ast_expr ,_1 ,_2)";

  satom := callback [ sexpr ] =># "`(ast_callback ,_3)";
  satom := [| sexpr |] =># "`(ast_arrayof ,_2)";
  satom := { sexpr } =># """
    `(ast_lambda ,dfltvs (() None) None (ast_fun_return ,_2))
  """;

  satom := match sexpr with smatching+ endmatch =># 
    "`(ast_match (,_2 ,_4))";

    /*
    smatchings := smatching =># "`(,_1)";
    smatchings := smatching smatchings =># "(cons _1 _2)";
    smatchings := smatching + =># "_1";
    */

    smatching  := | spattern => sexpr =># "`(,_2 ,_4)";
    smatching  := | => sexpr =># "`(pat_none ,_4)";

    satomic_pattern := sstring =># "`(pat_string ,_1)";
    satomic_pattern := quest sname =># "`(pat_as pat_any ,_2)";
    satomic_pattern := _ =># "'pat_any";
    satomic_pattern := ( spattern ) =># "_2";
    satomic_pattern := struct { spat_assigns } =># "`(pat_record ,_3)";
      spat_assign := sname = spattern ; =># "`(,_1 ,_3)";
      spat_assigns := spat_assign =># "`(,_1)";
      spat_assigns := spat_assign spat_assigns =># "(cons _1 _2)";

    satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
    satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";
      sctor_name := squalified_name =># "_1";
      sctor_name := case sinteger =># "`(ast_case_tag ,(cadr _2))";

    satomic_pattern := sstring .. sstring =># "`(pat_string_range ,_1 ,_3)";
    satomic_pattern := sintegral =># "`(pat_int ,(car _1) ,(cadr _1))";
    satomic_pattern := sintegral .. sintegral=># 
      "`(pat_int_range ,(car _1) ,(cadr _1) ,(car _3) ,(cadr _3))";

    satomic_pattern := NaN =># "'pat_nan";
    satomic_pattern := sfloating .. sfloating =># 
      "`(pat_int ,(car _1) ,(cadr _1))";

      sfloating:= sfloat =># "`(float_plus ,(car _1) ,(cadr _1))";
      sfloating:= - sfloat =># "`(float_minus ,(car _2) ,(cadr _2))";
      sfloating:= inf =># "'float_inf";
      sfloating:= - inf =># "'float_minus_inf";

    scoercive_pattern := satomic_pattern =># "_1";
    scoercive_pattern := satomic_pattern : sarrow =># "`(pat_coercion ,_1 ,_2)";

    stuple_pattern := scoercive_pattern =># "_1";
    stuple_pattern := scoercive_pattern stuple_pattern_suffix =># 
      "`(pat_tuple ,(cons _1 _2))";

      stuple_pattern_suffix := , scoercive_pattern =># "`(,_2)";
      stuple_pattern_suffix := , scoercive_pattern stuple_pattern_suffix =># 
        "(cons _1 _2)";

    sas_pattern := stuple_pattern =># "_1";
    sas_pattern := stuple_pattern as sname =># "`(pat_as ,_1 ,_3)";

    spattern := sas_pattern =># "_1";
    spattern := sas_pattern when sexpr =># "`(pat_when ,_1 ,_3)";

//  satom := compound =># "`(ast_lambda dfltvs (() None) None ,_2)";

  satom := ( sexpr ) =># "_2";
  satom := ( ) =># "'()";

  satom := if sexpr then sexpr selse_part endif =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

    selif := elif sexpr then sexpr =># "`(,_2 ,_4)";

    selifs := selif =># "`(,_1)";
    selifs := selifs selif =># "(cons _2 _1)";

    selse_part:= else sexpr =># "_2";
    selse_part:= selifs else sexpr =># """
       (let ((f (lambda (result condthn) 
         (let ((cond (car condthn)) (thn (cadr condthn))) 
           `(ast_cond (,cond ,thn ,result))))))
         (fold_left f _3 _1))
    """;
/*    
    selse_part:= selifs else sexpr =># """
     (letrec 
       ((fold_left 
         (lambda (f acc lst) 
           (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst))))))
       (let ((f (lambda (result condthn) 
         (let ((cond (car condthn)) (thn (cadr condthn))) 
           `(ast_cond (,cond ,thn ,result))))))
         (fold_left f _3 _1)))
    """;
*/

  ssimple_name_parts := sname [ sexpr ] =># "`(,_1 ,_3)";
  ssimple_name_parts := sname           =># "`(,_1 ())";

  squalified_name := squalified_name :: ssimple_name_parts =># 
    "`(ast_lookup (,_1 ,(car _2) ,(cadr _2))";
  squalified_name := ssimple_name_parts =># 
    "`(ast_name ,(car _1) ,(cadr _1))";

  ssuffixed_name := squalified_name of sfactor =># 
    "`(ast_suffix (,_1 ,_3))";

  sthe_name := satom =># "_1";
  sthe_name := the squalified_name =># "`(ast_the ,_2)";
  sthe_name := noexpand squalified_name =># "`(ast_noexpand ,_2)";
  sthe_name := quest sname =># "`(ast_patvar ,_2)";
  sthe_name := squalified_name =># "_1";

  shash_name := sthe_name =># "_1";
  shash_name := # shash_name =># "`(ast_lift ,_2)";

  sfactor := shash_name =># "_1";
  sfactor := sfactor .[ sexpr ] =># "`(ast_apply (subscript (,_1 ,_4)))";
  sfactor := sfactor .[ sexpr to sexpr ] =># "`(ast_apply (substring (,_1 ,_4 ,_6)))";
  sfactor := sfactor .[ sexpr to ] =># "`(ast_apply (copyfrom (,_1 ,_4)))";
  sfactor := sfactor .[ to sexpr ] =># "`(ast_apply (copyto (,_1 ,_5)))";
  sfactor := sfactor . ssimple_name_parts =># 
    "`(ast_dot (,_1 (ast_name ((car ,_3) (cadr ,_3)))))";

  sfactor := sfactor .-> ssimple_name_parts =># 
    "`(ast_dot ((ast_apply (deref ,_1)) (ast_name ((car ,_3) (cadr ,_3)))))";


  scoercion := sfactor =># "_1";
  scoercion := scoercion : sfactor =># "`(ast_coercion (,_1 ,_3))";

  sapplication := scoercion =># "_1";
  sapplication := sapplication scoercion =># "`(ast_apply (,_1 ,_2))";
  sapplication := caseno scoercion =># "`(ast_case_index ,_2)";
  sapplication := macro ctor sname scoercion =># "`ast_macro_ctor (,_3 ,_4))";

  srefr := sapplication =># "_1";
  // todo anonymous union
  // todo anonymous struct
  srefr := & srefr =># "`(ast_ref ,_2)";
  srefr := star srefr =># "`(ast_apply (deref ,_2))";
  srefr := _deref srefr =># "`(ast_deref ,_2)";
  srefr := new srefr =># "`(ast_new ,_2)";

  ssuperscript := srefr =># "_1"; 
  ssuperscript := ssuperscript ^ srefr =># "`(ast_superscript (,_1 ,_3))"; 

  spower := ssuperscript  =># "_1"; 
  spower := ssuperscript ** sprefixed =># "`(ast_apply (pow (,_1 ,_3)))"; 

  sprefixed := spower =># "_1";
  sprefixed := lval spower =># "`(ast_lvalue ,_1)";
  sprefixed := ! spower =># "`(ast_apply (excl ,_2))";
  sprefixed := plus spower =># "`(ast_apply (pos ,_2))";
  sprefixed := - spower =># "`(ast_apply (neg ,_2))";
  sprefixed := ~ spower =># "`(ast_apply (compl ,_2))";

  s_term := sprefixed =># "_1";
  s_term := s_term / spower =># "`(ast_apply (div (,_1 ,_3)))";
  s_term := s_term % spower =># "`(ast_apply (mod (,_1 ,_3)))";

  sproduct :=  s_term =># "_1";
  sproduct := s_term star sproduct_list =># "`(ast_product ,(cons _1 _3))";
    sproduct_list := s_term star sproduct_list =># "(cons _1 _3)";
    sproduct_list := s_term =># "`(,_1)";
  
  ssubtraction := sproduct =># "_1";
  ssubtraction := ssubtraction - sproduct =># "`(ast_apply (sub (,_1 ,_3)))";

  ssum :=  ssubtraction =># "_1";
  ssum := ssubtraction plus ssum_list =># "`(ast_sum ,(cons _1 _3))";
    ssum_list := ssubtraction plus ssum_list =># "(cons _1 _3)";
    ssum_list := ssubtraction =># "`(,_1)";

  sshift := ssum =># "_1";
  sshift := sshift << ssum =># "`(ast_apply (shl (,_1 ,_3)))";
  sshift := sshift >> ssum =># "`(ast_apply (shr (,_1 ,_3)))";

  sband :=  sshift =># "_1";
  sband := sband \& sshift =># "`(ast_apply (band (,_1 ,_3)))";

  sbxor := sband =># "_1";
  sbxor := sbxor \^ sband =># "`(ast_apply (bxor (,_1 ,_3)))";

  sbor := sbxor =># "_1";
  sbor := sbor \| sbxor =># "`(ast_apply (bor (,_1 ,_3)))";

  scase_literal := sbor =># "_1";
  scase_literal := case sinteger =># "`(ast_case_tag ,_2))";
  scase_literal := case sinteger of ssum =># "`(ast_typed_case (,_2 ,_4))";
  scase_literal := case sname of ssum =># "`(ast_variant (,_2 ,_4))";
  
  sarrow := scase_literal =># "_1";
  sarrow := scase_literal -> sarrow =># "`(ast_arrow (,_1 ,_3))";
  sarrow := scase_literal --> sarrow =># "`(ast_longarrow (,_1 ,_3))";

  ssetintersection:= sarrow =># "_1";
  ssetintersection := sarrow && ssetintersection_list =># "(cons _1 _3)";
    ssetintersection_list := sarrow =># "_1";
    ssetintersection_list := sarrow && ssetintersection_list =># "(cons _1 _3)";

  suser10 := ssetintersection =># "_1";
  suser10 := suser10 suser10token ssetintersection =># 
    "`(,_2 (,_1 ,_3)))";

  ssetunion := suser10 =># "_1";
  ssetunion := suser10 || ssetunion_list =># "(cons _1 _3)";
    ssetunion_list := suser10 =># "_1";
    ssetunion_list := suser10 || ssetunion_list =># "(cons _1 _3)";

  sas_expr := ssetunion =># "_1";
  sas_expr := sas_expr as sname =># "`(ast_as (,_1 ,_3))";

  // NOTE: this version doesn't support chains like a < b < c.. too bad
  scomparison:= sas_expr =># "_1";
  scomparison:= sas_expr < sas_expr =># "`(ast_apply (lt (,_1 ,_3)))";
  scomparison:= sas_expr <= sas_expr =># "`(ast_apply (le (,_1 ,_3)))";
  scomparison:= sas_expr == sas_expr =># "`(ast_apply (eq (,_1 ,_3)))";
  scomparison:= sas_expr != sas_expr =># "`(ast_apply (ne (,_1 ,_3)))";
  scomparison:= sas_expr >= sas_expr =># "`(ast_apply (ge (,_1 ,_3)))";
  scomparison:= sas_expr > sas_expr =># "`(ast_apply (gt (,_1 ,_3)))";

  snot_condition := scomparison  =># "_1";
  snot_condition := not snot_condition  =># "`(ast_apply (lnot ,_2))";

  sand_condition := snot_condition =># "_1";
  sand_condition := snot_condition and sand_list =># "`(ast_andlist ,(cons _1 _3))";
    sand_list := snot_condition and sand_list =># "(cons _1 _3)";
    sand_list := snot_condition =># "`(,_1)";

  sor_condition := sand_condition =># "_1";
  sor_condition := sand_condition or sor_list =># "`(ast_orlist ,(cons _1 _3))";
    sor_list := sand_condition or sor_list =># "(cons _1 _3)";
    sor_list := sand_condition =># "`(,_1)";

  stypeexpr:= sor_condition =># "_1";

  stuple := sor_condition  =># "_1";
  stuple := sor_condition stuple_suffix =># "`(ast_tuple ,(cons _1 _2))";
    stuple_suffix:= , sor_condition stuple_suffix =># "(cons _2 _3)";
    stuple_suffix:= , sor_condition  =># "`(,_2)";
  
  sdollar_apply := stuple =># "_1";
  sdollar_apply := stuple unless sexpr then sdollar_apply =>#
    "`(ast_cond ((ast_apply (lnot ,_3)) ,_1 ,_5))";
  sdollar_apply := stuple $ sdollar_apply =># "`(ast_apply (,_1 ,_3))";

  slambda := sdollar_apply =># "_1";
  // lambda forms here

  srvalue := slambda  =># "_1";

  sexpr := srvalue =># "_1";
  sexpr := let sexpr = sexpr in sexpr =># "`(ast_letin (,_2 ,_4 ,_6))"; 
}

syntax regexps {
  satom := regmatch_expr =># "_1";
}

syntax parsing {
  satom := glrparse =># "_1";
}

syntax typing {
  satom := typecase_expr =># "_1";
}

syntax statements {
  sstatement:= sbinding_definition =># "_1";
  sstatement:= sdeclarative =># "_1"; 
  sstatement:= sexecutable =># "_1"; 
  sstatement:= sinclusion =># "_1"; 
  sstatement:= sdirective =># "_1"; 
  sstatement:= spublish =># "_1"; 
  sstatement:= scomment =># "_1"; 
  sstatement:= snull_statement =># "_1"; 
  //sstatement:= suser_statement =># "_1"; 
  sstatement:= scparse =># "_1"; 

  scomment := comment sstring ; =># "`(ast_nop ,_2)";
 
  sbinding_definition :=  sabstract_type =># "_1";
  sbinding_definition :=  sconst_def =># "_1";
  sbinding_definition :=  sbinding_header =># "_1";
  sbinding_definition :=  sexport_statement =># "_1";
  
  spublish := private sdeclarative =># "`(ast_private ,_2)";
  spublish := private sbinding_definition =># "`(ast_private ,_2)";
  spublish := private svar_def =># "`(ast_private ,_2)";
  spublish := private sval_def =># "`(ast_private ,_2)";

  sdeclarative := sfunction_definition =># "_1";
  sdeclarative := sobject_definition =># "_1";
  sdeclarative := sprocedure_definition =># "_1";
  sdeclarative := smodule_definition =># "_1";
  sdeclarative := sunion_decl =># "_1";
  sdeclarative := sstruct_decl =># "_1";
  sdeclarative := stype_alias =># "_1";

  sdirective := sopen_decl =># "_1";
  sdirective := suse_decl =># "_1";
  sdirective := sregdef =># "_1";
  sdirective := sglr_production =># "_1";
  sdirective := smacro_definition =># "_1";

  sexecutable := svar_def =># "_1";
  sexecutable := sval_def =># "_1";
  sexecutable := scall =># "_1";
  sexecutable := ssvc =># "_1";
  sexecutable := sreturn =># "_1";
  sexecutable := sifgoto =># "_1";
  sexecutable := stodo =># "_1";
  sexecutable := sassignment =># "_1";
  sexecutable := sinline_cpp =># "_1";
  sexecutable := sgoto_statement=># "_1";
  sexecutable := slabel_statement =># "_1";
  sexecutable := sassert_statement =># "_1";

  snull_statement := ; =># '''('ast_nop "")''';

  sinclusion := include sstring ; =># "`(ast_include ,_2)";
  scparse := cparse sstring ; =># "`(ast_cparse ,_2)";

  sdeclname := sdeclname :: sname stvarlist =># "(cons _1 `(,_3 ,_4))";
  sdeclname := sname stvarlist =># "`(,_1 ,_2)";

  stype_qual := incomplete =># "'incomplete";
  stype_qual := pod =># "'pod";
  stype_qual := _gc_pointer =># "'gc_pointer";
  stype_qual := _gc_type sexpr =># "`(gc_type ,_2)";
  stype_quals:= stype_qual stype_quals =># "(cons _1 _2)";
  stype_quals:= sepsilon =># "()";

  sabstract_type:= stype_quals ctypes sbasic_name_comma_list srequires_clause ; =>#
    "`(ast_ctypes ,_3 ,_1 ,_4)";

  sbasic_name_comma_list:= sname scomma_name* =># "(cons _1 _2)";
  scomma_name:= , sname =># "_2";

  srequires_clause := requires srequirements =># "_2";
  srequires_clause := sepsilon =># "'()";

  scode_spec := sstring =># "`(strtemplate ,_1)";
  scode_spec := scstring =># "`(str ,_1)";
  scode_spec := sident =># "'identity";

  srequirement:= squalified_name =># "`(named_req ,_1)";
  srequirement := body scode_spec =># "`(body_req ,_2)";
  srequirement := header scode_spec =># "`(header_req ,_2)";
  srequirement :=  property sstring =># "`(property_req ,_2)";
  srequirement :=  package scode_spec =># "`(package_req ,_2)";

  srequirement_atom:= srequirement =># "`(rreq_atom ,_1)";
  srequirement_atom:= ( srequirements ) =># "_2";

  srequirement_and:= srequirement_and and srequirement_atom =>#
    "`(rreq_and ,_1 ,_3)";
  srequirement_and:= srequirement_atom =># "_1";

  srequirement_or:= srequirement_or or srequirement_and =>#
    "`(rreq_or ,_1 ,_3)";
  srequirement_or:= srequirement_and =># "_1";

  srequirements:= srequirements , srequirement_or =>#
    "`(rreq_and ,_1 ,_3)";
  srequirements:= srequirement_or =># "_1";

  sbinding_header:= header scode_spec srequires_clause ; =># 
    """`(ast_insert ("_root" ,dfltvs ,_2 header ,_3))"""; 
  sbinding_header:= body scode_spec srequires_clause ; =># 
    "`(ast_insert ("_root" ,dfltvs ,_2 body ,_3))"; 
  sbinding_header:= header = scode_spec srequires_clause ; =># 
    """`(ast_insert ("_root" ,dfltvs ,_3 header ,_4))"""; 
  sbinding_header:= body = scode_spec srequires_clause ; =># 
    """`(ast_insert ("_root" ,dfltvs ,_3 body ,_4))"""; 
  sbinding_header:= header sdeclname = scode_spec srequires_clause ; =># 
    """
    (mkns 
    `(ast_insert (,(caar _2) ,(cdar _2) ,_4 header ,_5))
    (cdr _2))
     """; 

  sbinding_header:= body sdeclname = scode_spec srequires_clause ; =># 
    """
    (mkns 
    `(ast_insert (,(caar _2) ,(cdar _2) ,_4 body ,_5))
    (cdr _2))
     """; 
 
  sbinding_header := requires srequirements ; =># 
    """`(ast_insert ("_root" ,dfltvs (str "") body ,_2))""";

  sbinding_header := sname requires srequirements ; =># 
    """`(ast_insert (,_1 ,dfltvs (str "") body ,_3))""";

  squalified_name_comma_list:= squalified_name scomma_qualified_name* =>#
    "(cons _1 _2)";
  scomma_qualified_name := , squalified_name =># "_2";

  stype_constraint := with squalified_name_comma_list where sexpr =>#
    "`(,_4 ,_2)";
  stype_constraint := where sexpr with squalified_name_comma_list =>#
    "`(,_2 ,_4)";
  stype_constraint := where sexpr =># "`(,_2 ())";
  stype_constraint := with squalified_name_comma_list =># "`(() ,_2)";

  sopt_type_constraint := stype_constraint? =># "_1";

  seqorin:= = stypeexpr =># "`(eq ,_2)";
  seqorin:= in stypeexpr =># "`(in ,_2)";
  seqorin:= sepsilon =># "'none"; // ambiguous with Some/None?

  stvar := sname seqorin =># "`(,_1 "typ_type" ,_2)";
  stvar := sname : stypeexpr seqorin =># "`(,_1 ,_3 ,_4)";

  stvar_comma_list := stvar scomma_tvar* =># "(cons _1 _2)";
  stvar_comma_list := sepsilon =># "'()";
  scomma_tvar := , stvar =># "_2";

  // TODO -- COMPLETE THIS MESSY ONE!
  stvarlist:= [ stvar_comma_list sopt_type_constraint ] =>#
    "'()";

  sassert_statement:= assert sexpr ; =># "`(ast_assert ,_2)";
  slabel_statement := sname :> =># "`(ast_label ,_1)";
  sgoto_statement := goto sname ; =># "`(ast_goto ,_2)";
  ssvc := _svc sname ; =># "`(ast_svc ,_2)";

  sinline_cpp:= code scode_spec ; =># "`(ast_code ,_2)";
  sinline_cpp:= noreturn code scode_spec ; =># "`(ast_noreturn_code ,_3)";

  stype_alias := typedef sdeclname = sexpr ; =>#
    """
    (mkns 
    `(ast_type_alias (,(caar _2) ,(cdar _2) ,_4))
    (cdr _2))
    """; 
  // TODO -- typedef function forms
  stype_alias := rename sdeclname = squalified_name ; =>#
    """
    (mkns 
    `(ast_inherit (,(caar _2) ,(cdar _2) ,_4))
    (cdr _2))
    """; 

  stype_alias := rename fun sdeclname = squalified_name ; =>#
    """
    (mkns 
    `(ast_inherit (,(caar _3) ,(cdar _3) ,_5))
    (cdr _3))
    """; 

  stype_alias := inherit squalified_name ; =># "`(ast_inject_module ,_2)";
 
  sexport_statement := export fun ssuffixed_name as sstring ; =>#
    "`(ast_export_fun (,_3 ,_5))";
  sexport_statement := export proc ssuffixed_name as sstring ; =>#
    "`(ast_export_fun (,_3 ,_5))";
  sexport_statement := export type (sexpr) as sstring ; =>#
    "`(ast_export_type (,_4 ,_7))";

  sopen_decl := open stvarlist squalified_name ; =>#
    "`(ast_open (,_2 ,_3))";

  suse_decl:= use squalified_name ; =>#
    """
    (let ((name))
      (if (eq? (car _2) "ast_lookup") (caddr _2)
        (if (eq? (car _2 "ast_name") (cadr _2)
        ("ERROR"))))
    `(ast_use (,_name ,_2))
    """;
  suse_decl := use sname = squalified_name ; =># "`(ast_use ,_2 ,_4)";

  sassignment := sexpr = sexpr =># """`(ast_assign "_set" ,_1 ,_3)""";
  // TODO more assigments

  stodo := todo sstring ; =># "`(ast_nop ,_2)";
  stodo := todo ; =># """`(ast_nop "todo")""";

  sifgoto := if sexpr goto sname ; =># "`(ast_ifgoto ,_2 ,_4)";
  sifgoto := if sexpr return ; =># "`(ast_ifreturn ,_2)";
  // TODO more ifgotos

  sreturn := yield sexpr ; =># "`(ast_yield ,_2)";
  sreturn := return sexpr ; =># "`(ast_fun_return ,_2)";
  sreturn := return ; =># "'ast_proc_return";
  sreturn := halt sstring ; =># "`(ast_halt ,_2)";

  sstatements := sstatement* =># "_1";
  scompound := { sstatements } =># "_2";
  scall := sexpr ; =># "TODOIT";
  sval_def := val sexpr ; =># "TODOIT";
  svar_def := var sexpr ; =># "TODOIT";
  smacro_definition := macro sexpr ; =># "TODOIT";
  sglr_production := parse sexpr ; =># "TODOIT";
  sregdef := regexp sexpr ; =># "TODOIT";
  sstruct_decl := struct sexpr ; =># "TODOIT";
  sunion_decl := union sexpr ; =># "TODOIT";
  smodule_definition := module sexpr ; =># "TODOIT";
  sprocedure_definition := module sexpr ; =># "TODOIT";
  sfunction_definition := module sexpr ; =># "TODOIT";
  sobject_definition := module sexpr ; =># "TODOIT";
  sconst_def := module sexpr ; =># "TODOIT";
}


