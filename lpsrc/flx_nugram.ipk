@select(tangler("lib/nugram.flxh"))
syntax schemer {
  satom := _ =># "'ast_patany";
  satom := ... =># "'ast_ellipsis";
  
  expr_code_prefix := code [ sexpr ] =># "_3";
  satom := expr_code_prefix sexpr =># "`(ast_expr ,_1 ,_2)";

  satom := callback [ sexpr ] =># "`(ast_callback ,_3)";
  satom := [| sexpr |] =># "`(ast_arrayof ,_2)";
  satom := { sexpr } =># """
    `(ast_lambda dfltvs (() None) None (ast_fun_return ,_2))
  """;

  satom := match sexpr with smatchings endmatch =># 
    "`(ast_match (,_2 ,_4))";

    smatchings := smatching =># "`(,_1)";
    smatchings := smatching smatchings =># "(cons _1 _2)";
    smatching  := | spattern => sexpr =># "`(,_2 ,_4)";
    smatching  := | => sexpr =># "`(pat_none ,_4)";

    satomic_pattern := sstring =># "`(pat_string ,_1)";
    satomic_pattern := ? sname =># "`(pat_as pat_any ,_2)";
    satomic_pattern := _ =># "'pat_any";
    satomic_pattern := ( spattern ) =># "_2";
    satomic_pattern := struct { spat_assigns } =># "`(pat_record ,_3)";
      spat_assign := sname = spattern ; =># "`(,_1 ,_3)";
      spat_assigns := spat_assign =># "`(,_1)";
      spat_assigns := spat_assign spat_assigns =># "(cons _1 _2)";

    satomic_pattern := sctor_name satomic_pattern =># "`(pat_nonconst_ctor ,_1 ,_2)";
    satomic_pattern := sctor_name =># "`(pat_const_ctor ,_1)";
      sctor_name := squalified_name =># "_1";
      sctor_name := case sinteger =># "`(ast_case_tag ,(cadr _2))";

    satomic_pattern := sstring .. sstring =># "`(pat_string_range ,_1 ,_3)";
    satomic_pattern := sintegral =># "`(pat_int ,(car _1) ,(cadr _1))";
    satomic_pattern := sintegral .. sintegral=># 
      "`(pat_int_range ,(car _1) ,(cadr _1) ,(car _3) ,(cadr _3))";

    satomic_pattern := nan =># "'pat_nan";
    satomic_pattern := sfloating .. sfloating =># 
      "`(pat_int ,(car _1) ,(cadr _1))";

      sfloating:= sfloat =># "`(float_plus ,(car _1) ,(cadr _1))";
      sfloating:= - sfloat =># "`(float_minus ,(car _2) ,(cadr _2))";
      sfloating:= inf =># "'float_inf";
      sfloating:= - inf =># "'float_minus_inf";

    scoercive_pattern := satomic_pattern =># "_1";
    scoercive_pattern := satomic_pattern : sarrow =># "`(pat_coercion ,_1 ,_2)";

    stuple_pattern := scoercive_pattern =># "_1";
    stuple_pattern := scoercive_pattern stuple_pattern_suffix =># 
      "`(pat_tuple ,(cons _1 _2))";

      stuple_pattern_suffix := , scoercive_pattern =># "`(,_2)";
      stuple_pattern_suffix := , scoercive_pattern stuple_pattern_suffix =># 
        "(cons _1 _2)";

    sas_pattern := stuple_pattern =># "_1";
    sas_pattern := stuple_pattern as sname =># "`(pat_as ,_1 ,_3)";

    spattern := sas_pattern =># "_1";
    spattern := sas_pattern when sexpr =># "`(pat_when ,_1 ,_3)";

//  satom := compound =># "`(ast_lambda dfltvs (() None) None ,_2)";

  satom := ( sexpr ) =># "_2";
  satom := ( ) =># "'()";

  satom := if sexpr then sexpr selse_part endif =>#
    "`(ast_cond (,_2 ,_4 ,_5))";

    selif := elif sexpr then sexpr =># "`(,_2 ,_4)";

    selifs := selif =># "`(,_1)";
    selifs := selifs selif =># "(cons _2 _1)";

    selse_part:= else sexpr =># "_2";
    selse_part:= selifs else sexpr =># """
     (letrec 
       ((fold_left 
         (lambda (f acc lst) 
           (if (null? lst) acc (fold_left f (f acc (car lst)) (cdr lst))))))
       (let ((f (lambda (result condthn) 
         (let ((cond (car condthn)) (thn (cadr condthn))) 
           `(ast_cond (,cond ,thn ,result))))))
         (fold_left f _3 _1)))
    """;

  ssimple_name_parts := sname [ sexpr ] =># "`(,_1 ,_3)";
  ssimple_name_parts := sname           =># "`(,_1 ())";

  squalified_name := squalified_name :: ssimple_name_parts =># 
    "`(ast_lookup (,_1 ,(car _2) ,(cadr _2))";
  squalified_name := ssimple_name_parts =># 
    "`(ast_name ,(car _1) ,(cadr _1))";

  ssuffixed_name := squalified_name of sfactor =># 
    "`(ast_suffix (,_1 ,_3))";

  sthe_name := satom =># "_1";
  sthe_name := the squalified_name =># "`(ast_the ,_2)";
  sthe_name := noexpand squalified_name =># "`(ast_noexpand ,_2)";
  sthe_name := ? sname =># "`(ast_patvar ,_2)";
  sthe_name := squalified_name =># "_1";

  shash_name := sthe_name =># "_1";
  shash_name := # shash_name =># "`(ast_lift ,_2)";

  sfactor := shash_name =># "_1";
  sfactor := sfactor .[ sexpr ] =># "`(ast_apply (subscript (,_1 ,_4)))";
  sfactor := sfactor .[ sexpr to expr ] =># "`(ast_apply (substring (,_1 ,_4 ,_6)))";
  sfactor := sfactor .[ sexpr to ] =># "`(ast_apply (copyfrom (,_1 ,_4)))";
  sfactor := sfactor .[ to sexpr ] =># "`(ast_apply (copyto (,_1 ,_5)))";
  sfactor := sfactor . simple_name_parts =># 
    "`(ast_dot (,_1 (ast_name ((car ,_3) (cadr ,_3)))))";

  sfactor := sfactor .-> simple_name_parts =># 
    "`(ast_dot ((ast_apply (deref ,_1)) (ast_name ((car ,_3) (cadr ,_3)))))";


  scoercion := sfactor =># "_1";
  scoercion := scoercion : sfactor =># "`(ast_coercion (,_1 ,_3))";

  sapplication := scoercion =># "_1";
  sapplication := sapplication scoercion =># "`(ast_apply (,_1 ,_2))";
  sapplication := caseno scoercion =># "`(ast_case_index ,_2)";
  sapplication := macro ctor sname scoercion =># "`ast_macro_ctor (,_3 ,_4))";

  srefr := sapplication =># "_1";
  // todo anonymous union
  // todo anonymous struct
  srefr := & srefr =># "`(ast_ref ,_2)";
  srefr := * srefr =># "`(ast_apply (deref ,_2))";
  srefr := deref srefr =># "`(ast_deref ,_2)";
  srefr := new srefr =># "`(ast_new ,_2)";

  ssuperscript := srefr =># "_1"; 
  ssuperscript := ssuperscript ^ srefr =># "`(ast_superscript (,_1 ,_3))"; 

  spower := ssuperscript  =># "_1"; 
  spower := ssuperscript ** sprefixed =># "`(ast_apply (pow (,_1 ,_3)))"; 

  sprefixed := spower =># "_1";
  sprefixed := lval spower =># "`(ast_lvalue ,_1)";
  sprefixed := ! spower =># "`(ast_apply (excl ,_2))";
  sprefixed := + spower =># "`(ast_apply (pos ,_2))";
  sprefixed := - spower =># "`(ast_apply (neg ,_2))";
  sprefixed := ~ spower =># "`(ast_apply (compl ,_2))";

  s_term := sprefixed =># "_1";
  s_term := s_term / spower =># "`(ast_apply (div (,_1 ,_3)))";
  s_term := s_term % spower =># "`(ast_apply (mod (,_1 ,_3)))";

  sproduct :=  s_term =># "_1";
  sproduct := s_term * sproduct_list =># "`(ast_product ,(cons _1 _3))";
    sproduct_list := s_term * sproduct_list =># "(cons _1 _3)";
    sproduct_list := s_term =># "`(,_1)";
  
  ssubtraction := sproduct =># "_1";
  ssubtraction := ssubtraction - sproduct =># "`(ast_apply (sub (,_1 ,_3)))";

  ssum :=  ssubtraction =># "_1";
  ssum := ssubtraction + ssum_list =># "`(ast_sum ,(cons _1 _3))";
    ssum_list := ssubtraction + ssum_list =># "(cons _1 _3)";
    ssum_list := ssubtraction =># "`(,_1)";

  sshift := ssum =># "_1";
  sshift := sshift << ssum =># "`(ast_apply (shl (,_1 ,_3)))";
  sshift := sshift >> ssum =># "`(ast_apply (shr (,_1 ,_3)))";

  sband :=  sshift =># "_1";
  sband := sband \& sshift =># "`(ast_apply (band (,_1 ,_3)))";

  sbxor := sband =># "_1";
  sbxor := sbxor \^ sband =># "`(ast_apply (bxor (,_1 ,_3)))";

  sbor := sbxor =># "_1";
  sbor := sbor \| sbxor =># "`(ast_apply (bor (,_1 ,_3)))";

  scase_literal := sbor =># "_1";
  scase_literal := case sinteger =># "`(ast_case_tag ,_2))";
  scase_literal := case sinteger of ssum =># "`(ast_typed_case (,_2 ,_4))";
  scase_literal := case sname of ssum =># "`(ast_variant (,_2 ,_4))";
  
  sarrow := scase_literal =># "_1";
  sarrow := scase_literal -> sarrow =># "`(ast_arrow (,_1 ,_3))";
  sarrow := scase_literal --> sarrow =># "`(ast_longarrow (,_1 ,_3))";

  sintersection:= sarrow =># "_1";
  suser10 := sintersection =># "_1";
  ssetunion := suser10 =># "_1";
  sas_expr := ssetunion =># "_1";

  // NOTE: this version doesn't support chains like a < b < c.. too bad
  scomparison:= sas_expr =># "_1";
  scomparison:= sas_expr < sas_expr =># "`(ast_apply (lt (,_1 ,_3)))";
  scomparison:= sas_expr <= sas_expr =># "`(ast_apply (le (,_1 ,_3)))";
  scomparison:= sas_expr == sas_expr =># "`(ast_apply (eq (,_1 ,_3)))";
  scomparison:= sas_expr != sas_expr =># "`(ast_apply (ne (,_1 ,_3)))";
  scomparison:= sas_expr >= sas_expr =># "`(ast_apply (ge (,_1 ,_3)))";
  scomparison:= sas_expr > sas_expr =># "`(ast_apply (gt (,_1 ,_3)))";

  snot_condition := scomparison  =># "_1";
  snot_condition := not snot_condition  =># "`(ast_apply (lnot ,_2))";

  sand_condition := snot_condition =># "_1";
  sand_condition := snot_condition and sand_list =># "`(ast_andlist ,(cons _1 _3))";
    sand_list := snot_condition and sand_list =># "(cons _1 _3)";
    sand_list := snot_condition =># "`(,_1)";

  sor_condition := sand_condition =># "_1";
  sor_condition := sand_condition or sor_list =># "`(ast_orlist ,(cons _1 _3))";
    sor_list := and_condition or sor_list =># "(cons _1 _3)";
    sor_list := and_condition =># "`(,_1)";

  stuple := sor_condition  =># "_1";
  stuple := sor_condition stuple_suffix =># "`(ast_tuple ,(cons _1 _2))";
    stuple_suffix:= , sor_condition stuple_suffix =># "(cons _2 _3)";
    stuple_suffix:= , sor_condition  =># "`(,_2)";
  
  sdollar_apply := stuple =># "_1";
  sdollar_apply := stuple unless sexpr then sdollar_apply =>#
    "`(ast_cond ((ast_apply (lnot ,_3)) ,_1 ,_5))";
  sdollar_apply := stuple $ sdollar_apply =># "`(ast_apply (,_1 ,_3))";

  slambda := sdollar_apply =># "_1";
  // lambda forms here

  srvalue := slambda  =># "_1";

  sexpr := srvalue =># "_1";
  sexpr := let sexpr = expr in expr =># "`(ast_letin (,_2 ,_4 ,_6))"; 
}

syntax regexps {
  satom := regmatch_expr =># "_1";
}

syntax parsing {
  satom := glrparse =># "_1";
}

syntax typing {
  satom := typecase_expr =># "_1";
}

open syntax schemer;
