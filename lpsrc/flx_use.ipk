@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_use.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2

val find_roots:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list -> unit

val uses_type:
  sym_state_t ->
  IntSet.t ref ->
  fully_bound_symbol_table_t ->
  btypecode_t -> 
  unit

val uses:
  sym_state_t ->
  IntSet.t ref ->
  fully_bound_symbol_table_t ->
  int ->
  unit

val full_use_closure:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  IntSet.t

val copy_used:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  fully_bound_symbol_table_t

@h = tangler("src/flx_use.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions


(* These routines find the absolute use closure of a symbol,
in particular they include variables which are initialised
but never used: these routine are intended to be used
to extract all the bound symbol table entries required
to process a set of roots.

Contrast with the 'Flx_call' usage routines, which
find some symbols which are useful, this excludes
types, and it excludes LHS vals and perhaps vars,
which are not used in some expression.

It seems a pity these routines are almost identical
(and the lot gets repeated yet again in the instantiator,
and weakly in the 'useless call eliminator', we hope
to find a better code reuse solution.. for now,
remember to update all three sets of routines when
changing the data structures.

*)

let nop x = ()

let rec uses_type syms used bbdfns (t:btypecode_t) = 
  let ut t = uses_type syms used bbdfns t in
  match t with
  | `BTYP_inst (i,ts)
    -> 
      uses syms used bbdfns i;
      iter ut ts

  | `BTYP_type 
    -> 
      failwith "[uses_type] Unexpected metatype"

  | _ -> iter_btype ut t

and uses_exes syms used bbdfns exes =
  iter (uses_exe syms used bbdfns) exes

and uses_exe syms used bbdfns (exe:bexe_t) =
  (*
  print_endline ("EXE=" ^ string_of_bexe syms.dfns 0 exe);
  *)
  let ue e = uses_tbexpr syms used bbdfns e in
  let ui i = uses syms used bbdfns i in
  let ut t = uses_type syms used bbdfns t in
  iter_bexe ui ue ut nop nop exe


and uses_tbexpr syms used bbdfns (e,t) =
  let ue e = uses_tbexpr syms used bbdfns e in
  let ut t = uses_type syms used bbdfns t in
  let ui i = uses syms used bbdfns i in

  ut t;

  match e with
  | `BEXPR_parse (e,ii)          -> ue e; iter ui ii
  | `BEXPR_deref e
  | `BEXPR_get_n (_,e)
  | `BEXPR_match_case (_,e)
  | `BEXPR_case_index e
  | `BEXPR_case_arg (_,e)        -> ue e
  | `BEXPR_apply (e1,e2)         -> ue e1; ue e2
  | `BEXPR_apply_prim (i,ts,e2)-> ui i; iter ut ts; ue e2
  | `BEXPR_apply_stack (i,ts,e2)-> ui i; iter ut ts; ue e2
  | `BEXPR_apply_direct (i,ts,e2)-> ui i; iter ut ts; ue e2
  | `BEXPR_tuple es              -> iter ue es 
  | `BEXPR_case (_,t)            -> ut t
  | `BEXPR_ref (i,ts)
  | `BEXPR_name (i,ts)
  | `BEXPR_closure (i,ts)        -> ui i; iter ut ts
  | `BEXPR_literal _ -> ()
  | `BEXPR_expr (_,t) -> ut t

and uses_production syms used bbdfns p =
  let uses_symbol (_,nt) = match nt with
  | `Nonterm ii -> iter (uses syms used bbdfns) ii
  | `Term i -> () (* HACK! This is a union constructor name  we need to 'use' the union type!! *)
  in
  iter uses_symbol p

and uses syms used bbdfns i =
  let ui i = uses syms used bbdfns i in
  let ut t = uses_type syms used bbdfns t in
  let ur (i,ts) = ui i; iter ut ts in
  let ux x = uses_exes syms used bbdfns x in
  let ue e = uses_tbexpr syms used bbdfns e in
  if not (IntSet.mem i !used) then
  begin
    match
      try Some (Hashtbl.find bbdfns i)
      with Not_found -> None
    with
    | Some (id,_,_,bbdcl) ->
      used := IntSet.add i !used;
      begin match bbdcl with
      | `BBDCL_function (props,_,ps,ret,exes) ->
        iter ut (map (fun x -> snd (snd x)) ps);
        ut ret;
        ux exes
                                                                                
      | `BBDCL_procedure (props,_,ps, exes) ->
        iter ut (map (fun x -> snd (snd x)) ps);
        ux exes

      | `BBDCL_glr (_,_,t,(p,e)) ->
        ut t; ux e;
        uses_production syms used bbdfns p

      | `BBDCL_regmatch (_,_,ps,t,(_,_,h,_)) ->
        ut t; Hashtbl.iter (fun _ e -> ue e) h;
        iter (fun (_,(i,_)) -> ui i) ps

      | `BBDCL_reglex (_,_,ps,i,t,(_,_,h,_)) ->
        ut t; Hashtbl.iter (fun _ e -> ue e) h;
        iter (fun (_,(i,_)) -> ui i) ps;
        ui i
        
      | `BBDCL_union (_,ps)
      | `BBDCL_struct (_,ps)
      | `BBDCL_cstruct (_,ps)
        ->
        iter ut (map snd ps)
                                                                                
      | `BBDCL_val (_,t)
      | `BBDCL_var (_,t) 
      | `BBDCL_tmp (_,t) -> ut t

      | `BBDCL_const (_,t,_,reqs) -> ut t; iter ur reqs
      | `BBDCL_fun (_,ps, ret, _,reqs,_) -> iter ut ps; ut ret; iter ur reqs
      | `BBDCL_proc (_,ps, _, reqs)  -> iter ut ps; iter ur reqs

      | `BBDCL_abs (_,_,_,reqs) -> iter ur reqs
      | `BBDCL_header (_,s,reqs)  
      | `BBDCL_body (_,s,reqs) -> iter ur reqs
      | `BBDCL_nonconst_ctor (_,_,unt,_,ct) ->
        ut unt; ut ct

      end
    | None -> failwith ("[Flx_use.uses] Cannot find " ^ si i)
  end

let find_roots syms bbdfns
  (root:bid_t) 
  (bifaces:biface_t list) 
=

  (* make a list of the root and all exported functions,
  add exported types and components thereof into the used
  set now too
  *)
  let roots = ref (IntSet.singleton root) in
  iter
  (function
     | `BIFACE_export_fun (_,x,_) -> roots := IntSet.add x !roots
     | `BIFACE_export_type (_,t,_) -> 
        uses_type syms roots bbdfns t
  )
  bifaces
  ;
  syms.roots := !roots

let full_use_closure syms bbdfns =
  let u = ref IntSet.empty in
  let v : IntSet.t  = !(syms.roots) in
  let v = ref v in

  let add j = 
    if not (IntSet.mem j !u) then 
    begin
       (*
       print_endline ("Scanning " ^ si j);
       *)
       u:= IntSet.add j !u;
       uses syms v bbdfns j
    end
  in
  while not (IntSet.is_empty !v) do 
    let j = IntSet.choose !v in
    v := IntSet.remove j !v;
    add j
  done;
  !u
       
let copy_used syms bbdfns =
  let h = Hashtbl.create 97 in
  let u = full_use_closure syms bbdfns in
  IntSet.iter
  begin fun i ->
    (* print_endline ("Copying " ^ si i); *)
    Hashtbl.add h i (Hashtbl.find bbdfns i)
  end
  u;
  h

