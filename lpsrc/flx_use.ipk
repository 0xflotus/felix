@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_use.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1

val uses_type:
  sym_state_t ->
  IntSet.t ref ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  btypecode_t -> 
  unit

val uses:
  sym_state_t ->
  IntSet.t ref ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  int ->
  unit

@h = tangler("src/flx_use.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions

let nop x = ()

let rec uses_type syms used (child_map,bbdfns) (t:btypecode_t) = 
  let ut t = uses_type syms used (child_map,bbdfns) t in
  match t with
  | `BTYP_name i 
    -> uses syms used (child_map,bbdfns) i

  | `BTYP_inst (i,ts)
    -> 
      uses syms used (child_map,bbdfns) i;
      iter ut ts

  | `BTYP_type 
    -> 
      failwith "[uses_type] Unexpected metatype"

  | _ -> iter_btype ut t

and uses_exes syms used (child_map,bbdfns) exes =
  iter (uses_exe syms used (child_map,bbdfns)) exes

and uses_exe syms used (child_map,bbdfns) (exe:bexe_t) =
  let ue e = uses_tbexpr syms used (child_map,bbdfns) e in
  let ui i = uses syms used (child_map,bbdfns) i in
  match exe with
  | `BEXE_init (_,i,e) -> 
    (* uses syms used (child_map,bbdfns) i; *) ue e

  | _ -> iter_bexe ui ue nop nop nop exe


and uses_tbexpr syms used (child_map,bbdfns) (e,t) =
  let ue e = uses_tbexpr syms used (child_map,bbdfns) e in
  let ut t = uses_type syms used (child_map,bbdfns) t in
  let ui i = uses syms used (child_map,bbdfns) i in

  ut t;

  match e with
  | `BEXPR_deref e
  | `BEXPR_get_n (_,e)
  | `BEXPR_match_case (_,e)
  | `BEXPR_case_arg (_,e)        -> ue e
  | `BEXPR_apply (e1,e2)         -> ue e1; ue e2
  | `BEXPR_apply_prim (i,ts,e2)-> ui i; iter ut ts; ue e2
  | `BEXPR_apply_stack (i,ts,e2)-> ui i; iter ut ts; ue e2
  | `BEXPR_apply_direct (i,ts,e2)-> ui i; iter ut ts; ue e2
  | `BEXPR_tuple es              -> iter ue es 
  | `BEXPR_coercion (e,t)        -> ue e; ut t
  | `BEXPR_case (_,t)            -> ut t
  | `BEXPR_ref (i,ts)
  | `BEXPR_name (i,ts)
  | `BEXPR_closure (i,ts)        -> ui i; iter ut ts
  | `BEXPR_literal _ -> ()
  | `BEXPR_expr (_,t) -> ut t

and uses syms used (child_map,bbdfns) i =
  let ur i = uses syms used (child_map,bbdfns) i in
  let ut t = uses_type syms used (child_map,bbdfns) t in
  let ux x = uses_exes syms used (child_map,bbdfns) x in
  if not (IntSet.mem i !used) then
  begin
    match
      try Some (Hashtbl.find bbdfns i)
      with Not_found -> None
    with
    | Some (id,_,_,bbdcl) ->
      used := IntSet.add i !used;
      begin match bbdcl with
      | `BBDCL_function (props,_,ps,ret,exes) ->
        iter ut (map (fun x -> snd (snd x)) ps);
        ut ret;
        ux exes
                                                                                
      | `BBDCL_procedure (props,_,ps, exes) ->
        iter ut (map (fun x -> snd (snd x)) ps);
        ux exes
                                                                                
      | `BBDCL_union (_,ps)
      | `BBDCL_struct (_,ps)
      | `BBDCL_cstruct (_,ps)
        ->
        iter ut (map snd ps)
                                                                                
      | `BBDCL_val (_,t)
      | `BBDCL_var (_,t) -> ut t

      | `BBDCL_const (_,t,_,reqs) -> ut t; iter ur reqs
      | `BBDCL_fun (_,ps, ret, _,reqs) -> iter ut ps; ut ret; iter ur reqs
      | `BBDCL_proc (_,ps, _, reqs)  -> iter ut ps; iter ur reqs

      | `BBDCL_abs (vs,_,_,reqs) -> iter ur reqs
      | `BBDCL_header (_,reqs)  
      | `BBDCL_body (_,reqs) -> iter ur reqs
      end
    | None -> ()
  end

