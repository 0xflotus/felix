@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_use.mli")
@select(h)
open Flx_types
val elide_unused:
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  fully_bound_symbol_table_t

@h = tangler("src/flx_use.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_mbind
open Flx_srcref

module BidSet = PosSet

(* Elide calls to useless procedures. Note we can't simply
elide the procedures, since they might be addressed/passed
as an argument, or be a root [main or exported]. 

Instead we rely on 'elide_useless' to elide procedures 
which are unused, by first eliding the call.
*)

exception Useful
let rec isuseless bbdfns exes = 
  try
    List.iter
    (fun x -> match x with
      | `BEXE_call ((`BEXPR_closure i,_),_) 
      | `BEXE_call ((`BEXPR_name i,_),_) 
      | `BEXE_call ((`BEXPR_ginst (i,_),_),_) 
        ->
        begin try 
          match Hashtbl.find bbdfns i with 
          | _,_,`BBDCL_procedure (_,exes,_) -> 
            if not (isuseless bbdfns exes) 
            then raise Useful
            else ()
          | _,_,`BBDCL_proc _
          | _,_,`BBDCL_val _
          | _,_,`BBDCL_var _
            -> raise Useful
          | _ -> failwith "[isuseless] Expected procedure type"
        with 
          Not_found -> ()
        end
      | `BEXE_call _ (* assume useful if not call to name useful proc *)
      | `BEXE_read _ (* useful even if local, due to side effect *)
      | `BEXE_code _ 
      | `BEXE_goto _ (* assume a non-local goto here *)
        -> raise Useful 
      (* NOTE: 
        BEXE_init always inits a local variable which isn't useful by itself 
      *)
      | _ -> () 
    )
    exes
    ;
    true
  with Useful -> false

let useless_call_elim bbdfns exes =
  let exes' = ref [] in
  List.iter
  (fun x -> match x with
  | `BEXE_call ((`BEXPR_closure i,_),_)
  | `BEXE_call ((`BEXPR_name i,_),_)
    -> (* only keep calls to useful procedures *) 
      begin match Hashtbl.find bbdfns i with
      | id,parent,`BBDCL_procedure (ps,exes,nm) ->
        if not (isuseless bbdfns exes) then exes' := x :: !exes'
      | _ -> exes' := x :: !exes'
      end

  | `BEXE_nop _ 
  | `BEXE_comment _  (* we shouldn't really elide comments .. *)
    -> ()
  | `BEXE_label s -> (* but it makes this test easier *)
    while            (* eliminate jumps to next instruction *)
      match !exes' with
      | (`BEXE_goto s') :: _
      | (`BEXE_ifgoto (_,s')) :: _
      | (`BEXE_ifnotgoto (_,s')) :: _
        -> s = s'
      | _ -> false
    do 
      exes' := List.tl !exes'
    done
    ;
    exes' := x :: !exes'

  | x -> exes' := x :: !exes'
  )
  exes
  ;
  List.rev !exes'

let rec uses_type used bbdfns t = 
  let ut t = uses_type used bbdfns t in
  match t with
  | `BTYP_name i -> uses used bbdfns i

  | `BTYP_inst (_,ts)
  | `BTYP_tuple ts
  | `BTYP_sum ts
  | `BTYP_type_tuple ts
    -> List.iter ut ts

  | `BTYP_function (t1, t2)
  | `BTYP_apply (t1, t2)
  | `BTYP_binding (t1, t2)
    -> ut t1; ut t2
    
  | `BTYP_pointer t -> ut t
  | `BTYP_typefun (ts, t1, t2) 
    ->
      List.iter ut (List.map snd ts);
      ut t1; ut t2
  | _ -> ()

and uses_exes used bbdfns exes =
  List.iter (uses_exe used bbdfns) exes

and uses_exe used bbdfns (exe:bexe_t) =
  let ue e = uses_tbexpr used bbdfns e in
  match exe with
  | `BEXE_call (e1,e2) -> ue e1; ue e2
    
  | `BEXE_ifgoto (e,_)
  | `BEXE_ifnotgoto (e,_)
  | `BEXE_return e 
    -> ue e

  | `BEXE_init (i,e) -> uses used bbdfns i; ue e
  | `BEXE_read i -> uses used bbdfns i
  | _ -> ()

and uses_tbexpr used bbdfns (e,t) =
  let ue e = uses_tbexpr used bbdfns e in
  let ut t = uses_type used bbdfns t in
  let ui i = uses used bbdfns i in

  ut t;

  match e with
  | `BEXPR_deref e
  | `BEXPR_get_n (_,e)
  | `BEXPR_match_case (_,e)
  | `BEXPR_case_arg (_,e)
    -> ue e
    
  | `BEXPR_name i
  | `BEXPR_closure i
    -> ui i
    
  | `BEXPR_apply (e1,e2) -> ue e1; ue e2
  | `BEXPR_tuple es -> List.iter ue es 
  | `BEXPR_dot (e,i)
     -> ui i; ue e
     
  | `BEXPR_coercion (e,t)
     -> ue e; ut t
     
  | `BEXPR_case (_,t)
    -> ut t

  | `BEXPR_ginst (i,ts) 
    -> ui i; List.iter ut ts

  | _ -> ()

and uses used bbdfns i =
  let ut t = uses_type used bbdfns t in
  let ux x = uses_exes used bbdfns x in
  if not (BidSet.mem i !used) then
  begin 
    match 
      try Some (Hashtbl.find bbdfns i)
      with Not_found -> None
    with 
    | Some (_,_,bbdcl) ->
      used := BidSet.add i !used;
      begin match bbdcl with
      | `BBDCL_function (ps,ret,exes, _) -> 
        List.iter ut (List.map snd ps);
        ut ret;
        ux exes
      
      | `BBDCL_procedure (ps, exes, _) ->
        List.iter ut (List.map snd ps);
        ux exes

      | `BBDCL_union ps 
      | `BBDCL_struct ps 
        ->
        List.iter ut (List.map snd ps)

      | `BBDCL_val t
      | `BBDCL_var t
      | `BBDCL_const (t,_)
        -> ut t
      
      | `BBDCL_fun (_,ps, ret, _) -> List.iter ut ps; ut ret 
      | `BBDCL_proc (_,ps, _)  -> List.iter ut ps
      
      | _ -> ()
      end
    | None -> ()
  end

let copy_bbdcl bbdfns bbdfns2 i =
  let data = 
    match Hashtbl.find bbdfns i with
    | id,parent,`BBDCL_procedure (p,exes,names) ->
      let exes = useless_call_elim bbdfns exes in
      id,parent,`BBDCL_procedure (p,exes,names)
    | x -> x
  in
    Hashtbl.add bbdfns2 i data

let elide_unused (bbdfns:fully_bound_symbol_table_t) (root:bid_t) (bifaces:biface_t list) =
  (* make a list of the root and all exported things *)
  let roots : bid_t list = root :: 
  (
    List.map  (function `BIFACE_export (x,_) -> x) bifaces
  ) 
  in

  (* make set of used things, initially empty *)
  let used = ref BidSet.empty in

  let uses i = uses used bbdfns i in

  (* add root item to set, then add items it uses *)
  List.iter uses roots
  ;
  (* copy used things *)
  let bbdfns2 = Hashtbl.create 97 in
  BidSet.iter (copy_bbdcl bbdfns bbdfns2) !used
  ;
  (* copy all header and body specs, they're always considered used *)
  Hashtbl.iter 
  (fun i b -> match b with
    | _,_,`BBDCL_header _
    | _,_,`BBDCL_body _ -> Hashtbl.add bbdfns2 i b
    | _ -> ()
  )
  bbdfns
  ;
  bbdfns2

