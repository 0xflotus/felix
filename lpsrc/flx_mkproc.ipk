@head(1,"mkproc")
@h = tangler("src/compiler/flxlib/flx_mkproc.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2

val mkproc_gen:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  int
 
@h = tangler("src/compiler/flxlib/flx_mkproc.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child
open Flx_reparent
open Flx_spexes
open Flx_args

let hfind msg h k = 
  try Hashtbl.find h k
  with Not_found ->
    print_endline ("flx_inline Hashtbl.find failed " ^ msg);
    raise Not_found

module BidSet = IntSet

let ident x = x

let intset_of_list ls = 
  fold_left (fun s i -> IntSet.add i s) IntSet.empty ls

(* THIS CODE JUST COUNTS APPLICATIONS *)
let find_mkproc_expr mkproc_map e =
  let aux e = match e with
  | `BEXPR_apply 
    (
      (`BEXPR_closure (f,ts),_),
      a
    )
    ,ret 
    when Hashtbl.mem mkproc_map f ->
    let p,n = Hashtbl.find mkproc_map f in
    Hashtbl.replace mkproc_map f (p,n+1)

  | x -> ()
  in 
  iter_tbexpr ignore aux ignore e

let find_mkproc_exe mkproc_map exe =
  iter_bexe ignore (find_mkproc_expr mkproc_map) ignore ignore ignore exe

let find_mkproc_exes mkproc_map exes =
  iter (find_mkproc_exe mkproc_map) exes

(* THIS CODE REPLACES APPLICATIONS WITH CALLS *)
let mkproc_expr syms bbdfns sr this mkproc_map vs e =
  let exes = ref [] in
  let rec aux e = match map_tbexpr ident aux ident e with
  | `BEXPR_apply 
    (
      (`BEXPR_closure (f,ts),_),
      a
    )
    ,ret 
    when Hashtbl.mem mkproc_map f ->

    let e = 
      (* count replacements *)
      let p,n = Hashtbl.find mkproc_map f in
      Hashtbl.replace mkproc_map f (p,n+1);

      (* create a new variable *)
      let k = !(syms.counter) in incr (syms.counter);
      let vid = "_mkp_" ^ si k in
      let vardecl = `BBDCL_var (vs,ret) in
      Hashtbl.add bbdfns k (vid,Some this,sr,vardecl);

      (* append a pointer to this variable to the argument *)
      let ptr = `BEXPR_ref (k,ts),`BTYP_pointer ret in
      let (_,at') as a' = append_args syms bbdfns this a [ptr] in

      (* create a call instruction to the mapped procedure *)
      let call : bexe_t = 
        `BEXE_call (sr,
          (`BEXPR_closure (p,ts),`BTYP_function (at',`BTYP_void)),
          a'
        )
      in

      (* record the procedure call *)
      exes := call :: !exes;

      (* replace the original expression with the variable *)
      `BEXPR_name (k,ts),ret
    in e
  | x -> x
  in 
  let e = aux e in
  e,rev !exes

let mkproc_exe syms bbdfns sr this mkproc_map vs exe =
  print_endline ("Unravelling exe=" ^ string_of_bexe syms.dfns bbdfns 0 exe);
  let exes = ref [] in
  let tocall e =
    let e,xs = mkproc_expr syms bbdfns sr this mkproc_map vs e in
    exes := xs @ !exes;
    e
  in
  let exe = map_bexe ident tocall ident ident ident exe in
  let exes = !exes @ [exe] in
  print_endline ("Unravelled exes =");
  iter (fun exe -> print_endline (string_of_bexe syms.dfns bbdfns 2 exe)) exes;
  exes

let mkproc_exes syms bbdfns sr this mkproc_map vs exes = 
  List.concat (map (mkproc_exe syms bbdfns sr this mkproc_map vs) exes)

let mkproc_gen syms (child_map,bbdfns) =

  let nuprocs = ref 0 in
  let mkproc_map = Hashtbl.create 97 in

  (* make the funproc map *)
  Hashtbl.iter
  (fun i (id,parent,sr,bbdcl) -> match bbdcl with
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    let k = !(syms.counter) in incr (syms.counter);
    Hashtbl.add mkproc_map i (k,0);
    if syms.compiler_options.print_flag then
    print_endline ("Detected function to make into a proc? " ^ id ^ "<" ^ si i ^"> synth= " ^ si k)

  | _ -> ()
  )
  bbdfns
  ;

  (* count direct applications of these functions *)
  Hashtbl.iter
  (fun i (id,parent,sr,bbdcl) -> match bbdcl with
  | `BBDCL_procedure (props,vs,(ps,traint),exes) ->
    find_mkproc_exes mkproc_map exes

  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    find_mkproc_exes mkproc_map exes
  | _ -> ()
  )
  bbdfns
  ;

  (*
  if syms.compiler_options.print_flag then
  *)
  Hashtbl.iter
  (fun i (k,n) ->
     print_endline ("MAYBE MAKE PROC: Orig " ^ si i ^ " synth " ^ si k ^ " count=" ^ si n);
  )
  mkproc_map
  ;

  (* make a list of the ones actually applied directly *)
  let to_mkproc = ref [] in
  Hashtbl.iter 
  (fun i (_,n) -> 
    if n > 0 then to_mkproc := i :: !to_mkproc
  ) 
  mkproc_map
  ;

  (* remove any function which is an ancestor of any other:
     keep the children (arbitrary choice)
  *)
  let isnot_asc adult = 
    fold_left 
    (fun acc child -> acc && not (Flx_child.is_ancestor bbdfns child adult))
    true !to_mkproc
  in

  let to_mkproc = filter isnot_asc (!to_mkproc) in

  let nu_mkproc_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i j -> 
    if mem i to_mkproc 
    then begin 
      Hashtbl.add nu_mkproc_map i j
      (*
      ; 
      print_endline ("Keeping " ^ si i)
      *)
    end else begin
      (*
      print_endline ("Discarding (ancestor) " ^ si i)
      *)
    end
  )
  mkproc_map;

  let mkproc_map = nu_mkproc_map in

  (*
  if syms.compiler_options.print_flag then
  *)
  Hashtbl.iter
  (fun i (k,n) ->
     print_endline ("ACTUALLY UNCURRY: Orig " ^ si i ^ " synth " ^ si k ^ " count=" ^ si n);
  )
  mkproc_map
  ;


  (* replace applications *)
  (* DISABLE MODIFICATIONS DURING INITIAL DEPLOYMENT *)
  Hashtbl.iter
  (fun i (id, parent, sr, bbdcl) -> match bbdcl with
  | `BBDCL_procedure (props,vs,(ps,traint),exes) ->
    let exes = mkproc_exes syms bbdfns sr i mkproc_map vs exes in
    ()
    (*
    Hashtbl.replace bbdfns i
      (id,parent,sr,`BBDCL_procedure (props,vs,(ps,traint),exes))
    *)

  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    let exes = mkproc_exes syms bbdfns sr i mkproc_map vs exes in
    ()
    (*
    Hashtbl.replace bbdfns i 
      (id,parent,sr,`BBDCL_function (props,vs,(ps,traint),ret,exes))
    *)

  | _ -> ()
  )
  bbdfns
  ;
  !nuprocs

