@h=tangler('demux/demux_iocp_demuxer.hpp')
@select(h)
#ifndef __FLX_DEMUX_IOCP_DEMUXER_H__
#define __FLX_DEMUX_IOCP_DEMUXER_H__

#include <flx_demux_config.hpp>
//#include <Windows.h>
// be specific - flx_rtl_config.h now jigs it so that windows.h  does not
// include winsock version 1 headers by default. this was making the order
// of inclusion of windows.h and winsock2.h significant with cl.exe.
#include <WinSock2.h>

#include "demux_demuxer.hpp"
#include "pthread_sleep_queue.hpp"


namespace flx { namespace demux {

// not here? returns INVALID_SOCKET on failure.
// if *io_port == 0, then a port is chosen and returned in *io_port
SOCKET DEMUX_EXTERN create_listener_socket(int* io_port, int backlog);
// these two probably not used. move to wsockety.h
SOCKET DEMUX_EXTERN nice_accept(SOCKET listener);
SOCKET DEMUX_EXTERN nice_connect(const char* addr, int port);
int DEMUX_EXTERN set_tcp_nodelay(int s, int disable_nagle);

// ********************************************************
/// make sure you instantion ONE (1) of these before using winsock
// ********************************************************
class DEMUX_EXTERN winsock_initer
{
public:
  winsock_initer();
  ~winsock_initer();
};

// ********************************************************
/// iocp_wakeup base class for users of iocp_demuxer
/// becoming an overlapped call control block
// ********************************************************
class DEMUX_EXTERN iocp_wakeup {
protected:            // folks need to use these in win 32 calls
  OVERLAPPED  ol;
  // store wakeup error here?
  // I didn't want this to be felixy, useful though.
  void clear_overlapped();  // zero the OVERLAPPED structure
public:
  // 2 possibilities for piggybacking data. who could ask for more?
  // udat = per iocp association, olp = per overlapped function call.
  // why don't I need this in the posix version?
  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err) = 0;

  // start overlapped async operation. returns true if it finished
  // immediately. in this case there will be no iocp_op_finished wakeup.
  // assumes all args ready for call.
  virtual bool start_overlapped() = 0;

  // retrieves this pointer from OVERLAPPED pointer
  static iocp_wakeup* from_overlapped(LPOVERLAPPED olp);
};

// ********************************************************
// ********************************************************
class DEMUX_EXTERN iocp_demuxer : public demuxer {
  HANDLE    iocp;     // the io completion queue

  void get_evts(bool poll);
public:
  iocp_demuxer();
  virtual ~iocp_demuxer();

  // udat is the per IOCP object user cookie & the overlapped pointer
  // is the per overlapped operation cookie (sort of), so in the case
  // of acceptex, udat is set when the listener is associated with the
  // iocp and is passed to the subsequent acceptex iocp wakeups.
  // probably won't be used very often
  // the OVERLAPPED retrieved from the iocp is assumed to be part of
  // an iocp_wakeup - beware! returns 0 on success, -1 on failure.
  int associate_with_iocp(HANDLE obj, ULONG_PTR udat);

};

}} // namespace demux, flx
#endif


@h=tangler('demux/demux_iocp_demuxer.cpp')
@select(h)
#include "demux_iocp_demuxer.hpp"
#include "demux_quitter.hpp" // for clean threaded iocp takedown

#include <stdio.h>      // for printf debugging
#include <stddef.h>     // offsetof
#include <assert.h>
// shoving the win_queue in here for now

namespace flx { namespace demux {

// this could really do with auto objs. steal the strat stuff?

// add windows error processing macros. It's a bore otherwise.

// WaitForSingleObject on an kill event in the thread for thread cancel
// kill_event = CreateEvent(NULL, TRUE, FALSE, NULL); (what's that)
// SetEvent(kill_event) to invoke (?): SetEvent sets the event to the 
// signalled state. Return value is success flag. GetLastError.

// do auto SOCKET wrapper, check closesocket return code.

// a completion port is a queue into which the os puts notifications of
// completed overlapped io requests. once the operation completes, a
// notification is sent to a worker thread that can process the result.
// a socket may be associated with a completion port at any point after
// creation.


// I don't see how to nicely stop a thread, I may have to have my own protocol
// to ask it to exit.

// PostQueuedCompletionStatus can be used by threads to wake up a worker
// thread. Could be handy replacement for timeout. "useful for notifying
// worker threads of external events"

// working through this: http://msdn.microsoft.com/msdnmag/issues/1000/Winsock/
// example of worker thread here
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/fileio/fs/i_o_completion_ports.asp
// nono, use this onec
// http://msdn.microsoft.com/library/default.asp?url=/library/en-us/msmq/msmq_using_reading_msg_98j7.asp
// oh, wait they're the same
// FormatMessge

winsock_initer::winsock_initer()
{
  WSADATA wsaData;

  // strange, rt_faio_01 static doesn't work under vs without this.
  // hum.
  // fprintf(stderr, "WINSOCK INIT!!!\n");
  // apparently 2.2's the way to go
  int res= WSAStartup(MAKEWORD(2, 2), &wsaData);
  if(res!= 0)
  {
    //JS: WSAGetLastError CANNOT be called, since WSAStartup failed
    fprintf(stderr,"couldn't find usable winsock dll: %i\n", res);
    throw res;
  }
}

winsock_initer::~winsock_initer()
{
  if(WSACleanup() != 0)
  {
    fprintf(stderr,"WSACleanup failed %i\n", WSAGetLastError());
  }
}

// iocp_wakeup base class for users of iocp_demuxer
//static
iocp_wakeup*
iocp_wakeup::from_overlapped(LPOVERLAPPED olp)
{
  // calculate the address of this from overlapped member
  // suffer an obligatory offsestof warning from broken gccs.
  return (iocp_wakeup*)((char*)olp-offsetof(iocp_wakeup, ol));
}

void
iocp_wakeup::clear_overlapped()
{
  ZeroMemory(&ol, sizeof(ol));  // much better than memset, right?
}


iocp_demuxer::iocp_demuxer()
  : iocp(NULL)
{
  // Create the completion port
  // not sure what first 3 args do, but by specifying INVALID_HANDLE_VALUE
  // for the first I think I can ignore the rest (apart from the last, numthreads)
  // I still have to create the threads, but only NumberOfConcurrentThreads
  // will wake up from GetQueuedCompletionStatus at a time. This looks to be
  // slightly elastic...
// NT 3.51 doesn't let you pass null filehandle, you've got to have a dummy
// socket. keep that in mind. see InitializeIOCP in IOCPServer.cpp example
// taken from codeproject. GetSystemInfo to find out num CPUs
  //fprintf(stderr,"CreateIoCompletionPort with ONE WORKER THREAD\n");
  iocp = CreateIoCompletionPort(
    INVALID_HANDLE_VALUE,
    NULL,
    (ULONG_PTR)0,
    1       // 1 thread (zero means one for each CPU)
  );

  if(NULL == iocp)
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed to create completion port: %li\n", err);
    throw -1;
  }
}

iocp_demuxer::~iocp_demuxer()
{
  //fprintf(stderr, "~iocp (%p) NOW WITH ASYNC QUITTER!\n", iocp);
  try
  {
    demux_quitter q;
    q.quit(this);
  }
  catch(...)
  {
    fprintf(stderr, "~iocp_demuxer async quit threw exception!\n");
    // now what do we do?
  }


  if(NULL != iocp && !CloseHandle(iocp))
  {
    DWORD err = GetLastError();
    fprintf(stderr,"failed cleanup iocp: %li\n", err);
  }
}

int
iocp_demuxer::associate_with_iocp(HANDLE obj, ULONG_PTR udat)
{
  // fprintf(stderr, "associating with iocp=%p: %p, udat: %lx\n",
  //  iocp, obj, udat);

  // Any overlapped operations performed on the object will use the
  // completion port for notification. The 3rd param can be used to pass
  // per object context information. we'll just pass that back.
  if(CreateIoCompletionPort(obj, iocp, udat, 0) == NULL) {
    // adding the same obj twice without an intervening get completion
    // status wakup gets an error 87, ERROR_INVALID_PARAMETER
    fprintf(stderr,"CreateIoCompletionPort failed to register object: %li\n",
      GetLastError());
    return -1;
  }

  return 0;
}

void
iocp_demuxer::get_evts(bool poll) {
  // with multiple threads, this will actually wake up the last to
  // block (lifo)

  // get context, call worker_thread 
  // need to be able to tell which thing completed, can have extra data
  // following some kind of struct
  // get this pointer

  // I guess to avoid swapping of thread context. By calling this on a given
  // completion port this thread is associated with it until exit or respec
  DWORD     nbytes;   // number of bytes in io transaction
  ULONG_PTR     udat;   // user data - not using this atm
  LPOVERLAPPED  olp;    // we get iocp_wakeup from this.

// If a socket handle associated with a completion port is closed,
// GetQueuedCompletionStatus returns ERROR_SUCCESS, with *lpOverlapped
// non-NULL and lpNumberOfBytes equal zero.
  
  int err = NO_ERROR;

  // No timeout. What does false mean? Eh. Could need a timeout to bring
  // the thread down.
  if(!GetQueuedCompletionStatus(iocp, &nbytes, &udat, &olp, 
    (poll) ? 0: INFINITE))
  {
    // That's strange - I sometimes get my ConnectEx errors popping
    // out here (ERROR_SEM_TIMEOUT=121, ERROR_CONNECTION_REFUSED=1225)
    // it looks like my args (overlapped, etc) are still filled out, so
    // I can still awake the sleeper
    err = GetLastError();   // doco says this & not WSALastError.

    // let's see: yep - there's my overlapped
    // fprintf(stderr,"!iocp::wait: nbytes=%li, udat=%lx, io=%p, err=%i\n",
    //  nbytes, udat, olp, err);

    if(WAIT_TIMEOUT == err)
    {
      // we get this a lot now that we can poll the iocp, so no output
      // interestingly, nbytes = 1. what could that mean?
      return;         // no wakeup
    }
    else if(ERROR_OPERATION_ABORTED == err)
    {
      // that's real bad manners. Or I could just ignore it. Anyway,
      // any overlapped received is stale.
      fprintf(stderr, "WHOA!!! - disassociate before killing handle\n");
      return;         // no wakeup
    }
    else
    {
      fprintf(stderr,"GetQueuedCompletionStatus returned false: %i\n",
        err);
      // return here? relying on olp being NULL, to stop us dereffing
    }

    // I'm going to assume that there's a good wakeup, and fall through
    // We need to wakeup on some errors (like ERROR_CONNECTION_REFUSED)
    // FALL THROUGH
  }

// An IOCP is a very general event mechanism. It tells you not only about
// the completion of reads & writes, but also of pretty much any asynchronous
// event's completion. It doesn't quite fit in with my select style interfaces.
// I've got general overlapped things completing here. I don't want them to
// know about demuxers & so forth so I'll have to know about them.

  //fprintf(stderr,"HOLEY! Woke up!\n");
  //fprintf(stderr,"nbytes=%li, udat=%lx, olp=%p, err=%i\n",
  //  nbytes, udat, olp, err);

  // with polling it's normal not to get an overlapped pointer, because
  // we may simply have timed out
  assert( olp );

  // tell someone that some overlapped op finished
  iocp_wakeup*  wakeup = iocp_wakeup::from_overlapped(olp);

  // passing olp may be redundant, seeing as it's contained in iocp_wakeup
  wakeup->iocp_op_finished(nbytes, udat, olp, err);
}



// simple utility fn, shouldn't be here. creates listener on any interface.
// this could benifit from a SOCKET class. in failure returns INVALID_SOCKET
// CURRENTLY EATS ERROR, SO DON'T BOTHER CHECKING
SOCKET
create_listener_socket(int* io_port, int backlog)
{
  fprintf(stderr,"creating_listener_socket\n");
  SOCKET        listener;

  // could use WSASocket, but these seem to be turning out overlapped anyway
  // at least after tangling with overlapped functions.
  // socket returns INVALID_SOCKET on failure.
  listener = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);

  if (INVALID_SOCKET == listener)
  {
    fprintf(stderr,"listener create failed: %i\n", WSAGetLastError());
    return INVALID_SOCKET;
  }

  SOCKADDR_IN   addr;

  // msdn code examples don't zero the sockaddr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(*io_port);

  // bind our name to the socket
  int         res;
  res = bind(listener, (LPSOCKADDR)&addr, sizeof(addr));

  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"bind() failed %i\n", WSAGetLastError());
    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }
    return INVALID_SOCKET;
  }

  // if user wanted port chosen tell them what it turned out to be
  if(0 == *io_port)
  {
    int namelen = sizeof(addr);
    if (getsockname(listener, (struct sockaddr *)&addr, &namelen) 
      == SOCKET_ERROR)
    {
      fprintf(stderr, "getsockname failed (%i)\n", WSAGetLastError());

      if(closesocket(listener) == SOCKET_ERROR)
      {
        fprintf(stderr,"closesocket failed on listener: %i\n",
          WSAGetLastError());
      }
      return INVALID_SOCKET;
    }

    *io_port = ntohs(addr.sin_port);
  }

  // Set the socket to listen
  res = listen(listener, backlog);
  if (SOCKET_ERROR == res)
  {
    fprintf(stderr,"listen() failed %i\n", WSAGetLastError());

    if(closesocket(listener) == SOCKET_ERROR)
    {
      fprintf(stderr,"closesocket failed on listener: %i\n",
        WSAGetLastError());
    }

    return INVALID_SOCKET;
  }

  return listener;
}

// currently the following aren't used. Look forward to warnings
// about them.

// the posix version of this made the socket nonblocking.
// I don't seem to have to do that when using iocp. if you
// want to create a nonblocking socket (or overlapped) pass
// WSA_FLAG_OVERLAPPED to WSASocket. I've never had to
// actually do this. How do you make accept do this? (supposing
// you wanted to) WSAAccept doesn't have a flag for it (however
// it does let you do conditional accepting). 
// There doesn't seem to be a sockopt
// returns INVALID_SOCKET on failure. eats the err.
SOCKET
nice_accept(SOCKET listener)
{
  struct sockaddr_in  remoteaddr;
  int         addrlen = sizeof(remoteaddr);
  SOCKET        s;
  
  // accept returns INVALID_SOCKET when it fails
  s = accept(listener, (struct sockaddr*)&remoteaddr, &addrlen);

  if(INVALID_SOCKET == s)
  {
    fprintf(stderr,"nice_accept failed (%i)\n", WSAGetLastError());
  }

  // the posix version makes the socket nonblocking here
  // we're not bothering

  return s;
}

// returns SOCKET_ERROR on failure, with err in WSAGetLastError()
static int
connect_sock(SOCKET s, const char* addr, int port)
{
  struct sockaddr_in  sock_addr;

  memset(&sock_addr, 0, sizeof(sock_addr));
  sock_addr.sin_family = AF_INET;
  sock_addr.sin_addr.s_addr = inet_addr(addr);
  sock_addr.sin_port = htons(port);
  
  return connect(s, (struct sockaddr *)&sock_addr, sizeof(sock_addr));
}

// returns INVALID_SOCKET on failure, eats last error with WSAGetLastError
// unlike the posix version, this does not make the socket nonblocking.
SOCKET
nice_connect(const char* addr, int port)
{
  SOCKET      s;

  if((s = socket(AF_INET, SOCK_STREAM, 0)) != INVALID_SOCKET
    && connect_sock(s, addr, port) != SOCKET_ERROR)
  {
    return s;   /* success! */
  }

  /* something happened (not as good as catch 22) */
  fprintf(stderr,"nice_connect failed (%i)\n", WSAGetLastError());

  if(INVALID_SOCKET != s && closesocket(s) == SOCKET_ERROR)
    fprintf(stderr,"nice close failed (%i)\n", WSAGetLastError());

  return INVALID_SOCKET;
}

// returns -1 on error with errno in WSAGetLastError. 0 otherwise.
// kind of crap.
int
set_tcp_nodelay(int s, int disable)
{
  BOOL  disable_nagle = (disable) ? true : false;

  int res = setsockopt(s, IPPROTO_TCP, TCP_NODELAY,
      (const char*)&disable_nagle, sizeof(disable_nagle));

  return (res == SOCKET_ERROR) ? -1 : 0;
}

}}


@h=tangler('demux/demux_overlapped.cpp')
@select(h)
#include "demux_overlapped.hpp"
#include <stdio.h>      // fprintf
#include <assert.h>

// cygwin's copy of mswsock.h leaves something to be desired...
#ifndef WSAID_CONNECTEX
typedef 
BOOL
(PASCAL FAR * LPFN_CONNECTEX) (
    IN SOCKET s,
    IN const struct sockaddr FAR *name,
    IN int namelen,
    IN PVOID lpSendBuffer OPTIONAL,
    IN DWORD dwSendDataLength,
    OUT LPDWORD lpdwBytesSent,
    IN LPOVERLAPPED lpOverlapped 
    );

#define WSAID_CONNECTEX \           
    {0x25a207b9,0xddf3,0x4660,{0x8e,0xe9,0x76,0xe5,0x8c,0x74,0x06,0x3e}}
#endif

namespace flx { namespace demux {

// windows includes files here? vs will be fussy.

// AcceptEx

// return async finished flag (error flags - can be transmitted via class)
// AcceptEx is the way to get accept connections via the IOCP
bool
acceptex_control_block::start_overlapped()
{
  clear_overlapped();

// I've seen two examples get the pointer to AcceptEx, just in case it
// isn't implemented...
  // fprintf(stderr,"AcceptExing: listen backlog => can succeed immediately\n");

  // this is only set when acceptex receives data and returns immediately.
  // can't hurt to set it.
  DWORD nbytes = 0;
  BOOL  success;

  // note that in order to get the wakeup packet, the listener must
  // already be associated with the iocp. for future async io, the acceptor
  // must be associated too.
  success = AcceptEx(listener, acceptor,
    accept_buf,       // required - near/far address
    0,            // receive data size - don't yet want this
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    ACCEPTEX_ADDR_SIZE,   // must be nonzero
    &nbytes,        // only set if fn completes. should be 0
    &ol);         // oblig. gets us back to the this ptr

  // if there is a backlog of connections, AcceptEx can return immediately
  if(success)
  {
    // must clear the wait
    fprintf(stderr,"WHOA! AcceptEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "This could be bad, as wait should call op_finish\n");
    fprintf(stderr, "We also lose the udat cookie (set to NULL)\n");
    // handle the successful wakeup
    // complete_async_op(demux, drv, nbytes, NO_ERROR); 
    // I hope they don't want the udat pointer, because I
    // just made it up (0=NULL). Not using it anyway.
    iocp_op_finished(nbytes, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();
    // can also return WSACONNRESET, which isn't so bad
    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"AcceptEx returned ERROR_IO_PENDING - that's normal\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      fprintf(stderr,"AcceptEx failed: %i\n", err);
      fprintf(stderr,"returning true should wake thread to detect failure.\n");
      return true;    // have self woken
    }
  }
  return false;       // async not finished

}

// ConnectEx
#if 0
// apparently we're supposed to do this now to make the acceptee inherit
// the listener's state. it is currently in the default state
//err = setsockopt( sAcceptSocket, 
//  SOL_SOCKET, 
//  SO_UPDATE_ACCEPT_CONTEXT, 
//  (char *)&sListenSocket, 
//  sizeof(sListenSocket) );
#endif

// what a pain in the arse (zzz)
// This doesn't exist in win2000, so it'll need to be synchronous there.
static int
GetConnectExAddr(SOCKET s, LPFN_CONNECTEX* conn_fn)
{
  *conn_fn = NULL;
  GUID      GuidConnectEx = WSAID_CONNECTEX;   
  DWORD     dwBytes;
  int       err;

  err = WSAIoctl(s,   // why do I need this?
    SIO_GET_EXTENSION_FUNCTION_POINTER,
    &GuidConnectEx,
    sizeof(GuidConnectEx),
    conn_fn,
    sizeof(*conn_fn),
    &dwBytes,
    NULL, NULL);    // no overlapped, no completion fun ptr
//  fprintf(stderr,"Get addr dwbytes: %li\n", dwBytes);
  return err;
}

// this is the weirdest. To use ConnectEx, the socket must be already bound.
// By trial and error, I found that it had to be bound to INADDR_ANY: 0.
// So strange. Apparently I don't have to do it again if I want to reuse.
static int
bind_socket(SOCKET s)
{
  SOCKADDR_IN   addr;

  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = htonl(INADDR_ANY);
  addr.sin_port = htons(0);

  return bind(s, (LPSOCKADDR)&addr, sizeof(addr));
}

bool
connectex_control_block::start_overlapped()
{
  clear_overlapped();

  // why not get this directly from the ConnectEx?
  socket_err = ERROR_IO_PENDING;


  DWORD bytes_sent = 0;   // we're not sending data on connect (yet)
  BOOL  success;

  LPFN_CONNECTEX  pfConnectEx;

  // unfortunate, will fix up later.
  // fprintf(stderr,"Getting ConnectEx address\n");

  // Turns out that ConnectEx isn't defined anywhere; I have to load its
  // addr via WSAIoctl
  // this is a bad way. make the driver cache it. why on earth is this
  // call per-socket? does it really need to be that way?
  if(GetConnectExAddr(s, &pfConnectEx) == SOCKET_ERROR)
  {
    fprintf(stderr,"GetConnectExAddr failed: %i\n", WSAGetLastError());
    return true;
  }

  // fprintf(stderr,"about to connectex to %s:%i, %i\n", addy, p, s);

  // this is so strange - I have to bind the socket to the localhost.
  // if I don't, ConnectEx returns EINVAL. in any case, I won't need
  // to do this again if I reuse this socket.
  if(bind_socket(s) == SOCKET_ERROR)
    fprintf(stderr,"ConnectEx bind failed: %i\n", WSAGetLastError());

  // I hope ConnectEx doesn't want this to hang around, because it's
  // going to drop off the stack after this.
  SOCKADDR_IN   addr;

  // some examples don't zero the addr. That makes me nervous.
  ZeroMemory(&addr, sizeof(addr));
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = inet_addr(addy);
  addr.sin_port = htons(p);

  // in order to receive the wakeup packet, s must already be associated
  // with the iocp. this is best done at socket creation time. for these
  // sockets it's probably best to also bind them at the same time.
  // that requires "purposed" sockets (CreateConnectSocket?).
  // p.s. the default (waio_base) wakeup is doing fine for now.

  success = (*pfConnectEx)(s, // socket
    (LPSOCKADDR)&addr,    // connect address
    sizeof(addr),     // size thereof
    NULL,         // not sending any data yet, but we could
    0,            // ditto
    NULL,         // should be zero until this changes
    &ol);         // oblig. gets us back to the this ptr

// there's a caveat about the type of socket s becomes after ConnectEx.
// It's in some kind of default state and cannot be used with shutdown
// change it with setsockopt (?)
  if(success)
  {
    fprintf(stderr,"WHOA! ConnectEx RETURNED SUCCESS IMMEDIATELY!\n");
    fprintf(stderr, "BAD: calls op_finish and loses udat cookie\n");
    // handle the successful wakeup. (udat=0, olp=&ol)
    iocp_op_finished(bytes_sent, 0, &ol, NO_ERROR); 
    return false;   // means no completion packet coming (correct?)
  }
  else
  {
    int err = WSAGetLastError();

    if(ERROR_IO_PENDING == err)
    {
      // fprintf(stderr,"ConnectEx pending...\n");
      // This is the normal situation, fall through, leaving thread
      // to sleep on wakeup call.
    }
    else
    {
      // maybe store the error here. that could work for all
      // windows wakeups
      fprintf(stderr,"ConnectEx failed: %i\n", err);
      return true;    // have self woken
    }
  }
  return false;       // not finished
}

// TransmitFile

bool
transmitfile_control_block::start_overlapped()
{
  clear_overlapped();

  // 0 bytes => transmit entire file
  // the second zero means use the default chunk size
  // the NULL is for mem buffers to bookend the file with. nothing yet.
  // the final zero is for various flags, including a way of doing
  // DisconnectEx style socket reuse (more widely compatible?)

  // in order to receive the wakeup, s must already be associated with the
  // iocp. this is best done at socket creation time.
  if(TransmitFile(s, file, 0, 0, &ol, NULL, flags))
  {
    fprintf(stderr,"Transmit file succeeded immediately! waking...\n");
    return true;
  }
  else
  {
    DWORD err = WSAGetLastError();

    // will need to actually signal something
    // fprintf(stderr,"signal TransmitFile failure!\n");
    if(ERROR_IO_PENDING != err && WSA_IO_PENDING != err)
      fprintf(stderr,"genuine error from TransmitFile: %li\n", err);
  }
  return false;
}


// SOCKET io using WSASend and WSARecv

// windows style control blocks
wsasocketio_control_block::wsasocketio_control_block(SOCKET src, sel_param* pb,
  bool inread)
  : s(src), ppb(pb), reading(inread)
{
}

bool
wsasocketio_control_block::start_overlapped()
{
  clear_overlapped();

  error = 0;

  // num bytes received IF recv completes immediately.
  DWORD imm_bytes;
  int   recv_res;

  // set up the single wbuf, bearing in mind we may be part way.
  wbufs[0].len = ppb->buffer_size - ppb->bytes_written;
  wbufs[0].buf = ppb->buffer + ppb->bytes_written;

// fprintf(stderr, "sockio: %p->finished = %i, reading = %i\n",
//  ppb, ppb->finished(), reading);

  // Ideally, we would like to be able to use MSG_WAITALL, which would
  // let us only get a completion packet when either all the data was
  // available or the connection had been closed or shutdown.
  // Unfortunately this is not possible for non-blocking sockets, so
  // we have to take whatever we get and then call WSARecv again.

  //#define MSG_WAITALL 0   // not defined in cygwin - apparently this
  //DWORD flags = MSG_WAITALL;

  // ah, unfortunately MSG_WAITALL is not supported for non blocking sockets
  // we'll just have to do it ourselves
  DWORD flags = MSG_PARTIAL;

  // completion routines! (unused)
  if(reading)
    recv_res = WSARecv(s, wbufs, NUM_WBUFS, &imm_bytes, &flags, &ol, NULL);
  else
    recv_res = WSASend(s, wbufs, NUM_WBUFS, &imm_bytes, flags, &ol, NULL);

  // don't know if I need to check non winsock errs

  switch(recv_res)
  {
    case 0:
    {
      // flags are updated to indicate what? if there was a callback, it
      // would be scheduled to be called when this thread is in the
      // waitable state, whatever that means.
      //fprintf(stderr,
      //  "WSA%s completed immediately!!! nbytes: %li, flags: %lx\n",
      //    (reading) ? "Recv" : "Send", imm_bytes, flags);

      // looks like we get the completion packet even if we do finish
      // immediately so let the iocp wake us. note that this method
      // of manually calling iocp_op_finished is not so great as we
      // don't know the (as yet unused) udat cookie and so set it to 0.
      // fprintf(stderr, "calling finished manually (ppb=%p)\n", ppb);
      // iocp_op_finished(imm_bytes, 0, &ol, NO_ERROR); 

      // false because iocp_op_finished will wake us. I guess false from
      // these guys means that a completion packet is in the mail and
      // true means that it isn't (in the mail).
      return false;
    }
    break;
    case SOCKET_ERROR:
    {
      DWORD err = WSAGetLastError();

      // normal mode - wait for completion
      // fyi, xp pro seems to mostly give us ERROR_IO_PENDING
      if(ERROR_IO_PENDING == err || WSA_IO_PENDING == err)
      {
        // fprintf(stderr,"WSA%s pending completion (%li)\n",
        //  (reading) ? "Recv" : "Send", err);
        return false;     
      }

      fprintf(stderr,"WSARecv/Send returned SOCKET_ERR: %li\n", err);
      return true;    // assume it's bad and we won't get a wakeup
    }
    break;
    default:
    {
      fprintf(stderr,"WSARecv/Send returned other error: %i, GetLastError: %li\n",
        recv_res, GetLastError());
      return true;        // wake up
    }
    break;
  }

  return false;
}

// NB: called by iocp::wait, so be aware of which thread is doing what, lest
// you be surprised by this being called asynchronously.
void
wsasocketio_control_block::iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
  LPOVERLAPPED olp, int err)
{
  error = err;        // copy back for others to look at.
                // perhaps move back to iocpwakeup
// fprintf(stderr, "wsasocketio::finished: ppb=%p, nbytes=%li, err=%i, read=%i\n",
//  ppb, nbytes, err, reading);

  if(err)
  {
    fprintf(stderr, "wsasocketio, got error: %i\n", err);
  }

  // fprintf(stderr,"wsa_socketio wakeup, nb: %li, err: %i\n", nbytes, err );
assert( !ppb->finished() );
  // keep track of bytes received.
  ppb->bytes_written += nbytes;

  if(0 == nbytes)
  {
    fprintf(stderr, "wsaiosocket got zero bytes: err=%i, read=%i\n",
      err, reading);
  }

  // if we're not finished, we have to reinstall our request
  // zero bytes indicates shutdown/closure, right?
  // might be using this for WSASend. Instead of broken pipes on win32, 
  // instead we get WSAECONNRESET (pretty sure) on write. On read?
// not sure about this - I don't think we have to check nbytes == 0
  if(0 == nbytes || ppb->finished())
  {
    return;
  }
  else
  {
    // go back around again
    fprintf(stderr,"didn\'t get everything (%li of %li bytes)\n",
      ppb->bytes_written, ppb->buffer_size);
    if(start_overlapped())
    {
      fprintf(stderr, "UM, socket restart finished immediately\n");
      fprintf(stderr, "causes new wakeup? or should I loop around?\n");
    }
  }
}


// file/pipe io using ReadFile and WriteFile

winfileio_control_block::winfileio_control_block(HANDLE f, void* buf, int len,
  bool inread)
  : reading(inread), file(f)
{
  // pb is not so useful here. we only want to
  // know num bytes written/processed.
  pb.buffer = (char*)buf;
  pb.buffer_size = len;
  pb.bytes_written = 0;
}

// if file is opened with FILE_FLAG_OVERLAPPED, we can do "immutable file ptr"
// ops & set the desired offset within the overlapped. can also stick an
// event to signal in there.
bool
winfileio_control_block::start_overlapped()
{
  // fprintf(stderr,"winfileio_cb::start_overlapped: reading=%i\n", reading);
  clear_overlapped();

  // DWORD  imm_bytes;
  BOOL  success;

  // don't need bytes read, written when we have an OVERLAPPED
  if(reading)
    // success = ReadFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = ReadFile(file, pb.buffer, pb.buffer_size, NULL, &ol);
  else
    //success = WriteFile(file, pb.buffer, pb.buffer_size, &imm_bytes, &ol);
    success = WriteFile(file, pb.buffer, pb.buffer_size, NULL, &ol);

  // fprintf(stderr,"immbytes = %li\n", imm_bytes);

  if(!success)
  {
    int err = GetLastError();

    // I'm getting this for unfinished
    if(ERROR_IO_PENDING == err)
    {
       return false;  // sleep on
    }
    else
    {
       fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
         err);
       return true;      // ask for wakeup
    }

    // fprintf(stderr,"%sFile failed! (%li)\n", (reading) ? "Read" : "Write",
    //  GetLastError());
    // fprintf(stderr,"do I still get completion packet???\n");
    // assume not
  }

  return false;       // sleep on
}

}}

@h=tangler('demux/demux_overlapped.hpp')
@select(h)
#ifndef __FLX_DEMUX_OVERLAPPED_H__
#define __FLX_DEMUX_OVERLAPPED_H__
#include "flx_demux_config.hpp"

// visual studio is quite sensitve about how you do these includes.
#include <WinSock2.h>              // Winsock2 (WSABufs, etc) must come before Windows.h
#include "demux_iocp_demuxer.hpp"  // this header file include Windows.h
#include <MSWSock.h>  // AcceptEx, TF_REUSE_SOCKET, etc

namespace flx { namespace demux {

// rename these to control block something or other
// get rid of default constructors - faio can worry about that.

// WARNING: in some "immediate completion" cases I have to call
// the finished function myself - in these cases I set the udat to 0, making
// it not very reliable. Either make sure the user understands immediate
// finish (and does it themselves) or keep a copy of udat.

// listener socket must be already associated with an IOCP
// in doing an AcceptEx, it might succeed immediately - do you still
// get the IOCP wakeup?
class DEMUX_EXTERN acceptex_control_block : public iocp_wakeup {
  enum { ACCEPTEX_ADDR_SIZE = sizeof(SOCKADDR_IN) + 16 };

public:
  SOCKET  listener, acceptor;
  // there are two of these!
  char  accept_buf[2*ACCEPTEX_ADDR_SIZE];

  virtual bool start_overlapped();

  acceptex_control_block() 
    : listener(INVALID_SOCKET), acceptor(INVALID_SOCKET) {}
};

class DEMUX_EXTERN connectex_control_block : public iocp_wakeup
{
public:
  // move further back?
  int socket_err;         // outgoing

  // can have buffer to be sent on connection
  SOCKET    s;          // previously unbound socket
  const char* addy;       // ipv4 address
  int     p;          // port number

  // socket_err undefined
  connectex_control_block() : s(INVALID_SOCKET), addy(0), p(0) {}

  // see posix version of this, try to keep them in sync. give socket_err
  // initial definition that works with this?
  bool finished() { return ERROR_IO_PENDING != socket_err; }

  virtual bool start_overlapped();
};

// TransmitFile here (requires file handle)
class DEMUX_EXTERN transmitfile_control_block : public iocp_wakeup {
  SOCKET  s;
  HANDLE  file;
  DWORD flags;                // for possible socket reuse.
public:

  transmitfile_control_block(SOCKET dst)      // for reuse of socket
    : s(dst), file(NULL), flags(TF_DISCONNECT | TF_REUSE_SOCKET) {}

  transmitfile_control_block(SOCKET dst, HANDLE src)  // actual transmitfile
    : s(dst), file(src), flags(0) {}

  virtual bool start_overlapped();
};


// handles both WSASend & WSARecv
class DEMUX_EXTERN wsasocketio_control_block : public iocp_wakeup {
protected:
  enum { NUM_WBUFS = 1 }; // just one for now, but can do scattered send/recvs
  WSABUF    wbufs[NUM_WBUFS];
public:
  SOCKET    s;
  sel_param*  ppb;      // on input what you want, on output what you got
  int     error;
  bool    reading;  // else use WSASend

  // watch the memory interfaces here, going back and forth between threads.
  wsasocketio_control_block(SOCKET src, sel_param* pb, bool read);

  virtual bool start_overlapped();

  virtual void iocp_op_finished( DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);
};

// winfileio_control_block, much like wsasocketio_control_block
class DEMUX_EXTERN winfileio_control_block : public iocp_wakeup {
  bool    reading;
public:
  sel_param pb;
  HANDLE    file; // I like to modify this from the outside

  // offset?
  winfileio_control_block(HANDLE f, void* buf, int len, bool read);

  virtual bool start_overlapped();

  // NB: no iocp_op_finished callback. defined by users of the class.
};

}}

#endif

@h=tangler('demux/demux_wself_piper.hpp')
@select(h)
#ifndef __FLX_DEMUX_WSELF_PIPER_H__
#define __FLX_DEMUX_WSELF_PIPER_H__

#include <flx_demux_config.hpp>
#include "demux_overlapped.hpp"  // I use readfile control block
#include "demux_wself_piper.hpp"

namespace flx { namespace demux {

class DEMUX_EXTERN auto_handle {
public:
  HANDLE h;
  
  auto_handle();
  ~auto_handle();
};

// win32 self pipe trick (what a pain!)
class DEMUX_EXTERN wpipe_pair {
  enum { READ_END, WRITE_END };
  // HANDLE pipe[2];  // 0 = read end, 1 = write end
  auto_handle pipe[2];
public:
  wpipe_pair();

  void write_byte();
  HANDLE get_read_end() { return pipe[READ_END].h; }
};

// use a winfileio_control_block to install a nonblocking ReadFile on the
// read end of the pipe pair. when we get a byte we can execute whatever
// the user wanted which for win32 which seems to be naturally responsive
// to new sockets/handles. demux quit will probably be the only operation
// needed.
class DEMUX_EXTERN wself_piper_wakeup : public winfileio_control_block
{
  char the_byte;

public:
  // possibly null, if not, called on iocp_op_finished
  demux_callback* cb; 

  // the demuxer. doesn't actually get passed by iocp_op_finished
  iocp_demuxer* d;  


  wself_piper_wakeup();

  // detect when single byte read has finished and exec callback,
  // re-arming.
  virtual void iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err);

  void arm();
};

// at the very least, the read end must be nonblocking and associated
// with the iocp.
class DEMUX_EXTERN wself_piper {
  wpipe_pair pp;
  wself_piper_wakeup spw;
public:
  void install(demuxer* demux, demux_callback* cb = 0);
  void wake(); // wakes demuxer which calls callback
};

} } // demux, flx

#endif

@h=tangler('demux/demux_wself_piper.cpp')
@select(h)

#include "demux_wself_piper.hpp"
#include <stdio.h>

namespace flx { namespace demux {

auto_handle::auto_handle()
{
  h = INVALID_HANDLE_VALUE;
}

auto_handle::~auto_handle()
{
  if(INVALID_HANDLE_VALUE == h) return; // done

  if(!CloseHandle(h))
    fprintf(stderr, "auto CloseHandle failed: %i\n", GetLastError());
}

wpipe_pair::wpipe_pair()
{
  // fprintf(stderr, "wpipe CTOR\n");
  // made bufsize 1 as we only ever read and write 1 byte at a time

  // looks like I can't use anonymous pipes with iocp. will have to
  // use a specially setup named pipe - one that allows repetitions...
  // this doesn't sound good.
  // This will be a problem if we have multiple event waiting threads.
  // If I don't get the flags right it will also be a problem if we
  // have multiple instances/apps running. I don't wan't this resource
  // to be globally visible. Flags?
  const char* pname = "\\\\.\\pipe\\flx_iocp_quitter";

  // don't actually need duplex, nor those buffers. 1 byte at a time suffices
  // I probably don't need both ends to be marked as nonblocking either, should
  // only need the read end nonblocking.

  // create pipe
  pipe[READ_END].h = CreateNamedPipe(pname,
   PIPE_ACCESS_DUPLEX | FILE_FLAG_OVERLAPPED,
   PIPE_TYPE_BYTE, 1, 256, 256, 0, NULL);

  if(INVALID_HANDLE_VALUE == pipe[READ_END].h)
  {
    fprintf(stderr, "couldn't create named pipe: %i\n", GetLastError());
    throw -1;
  }

  // this is the part that I don't like - this pipe's name isn't unique
  // and so theoretically another iocp quitter could join here. a race!

  // connect to it. note that overlapped isn't needed for write end as
  // we want to block.
  pipe[WRITE_END].h = CreateFile(pname, FILE_READ_DATA | FILE_WRITE_DATA,
    FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING,
    FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, NULL);

  if(INVALID_HANDLE_VALUE == pipe[WRITE_END].h)
  {
    fprintf(stderr, "failed to open named pipe: %i\n", GetLastError());
    throw -1;
  }

  // anonymous pipes can't be made nonblocking/iocpable on windows!
  // What a shame!
/*
  if(!CreatePipe(&pipe[READ_END], &pipe[WRITE_END], NULL, 1))
  {
    fprintf(stderr, "wpipe_pair CreatePipe failed: %i\n", GetLastError());
    throw -1;
  }
*/ 
}

void
wpipe_pair::write_byte()
{
  // I think I want a blocking write here.
  char  b = 1;
  DWORD bytes_written;
  // last arg is overlapped pointer, unused, we want to block.
  if(!WriteFile(pipe[WRITE_END].h, &b, 1, &bytes_written, NULL))
    fprintf(stderr, "wpipe_pair failed to write byte: %i\n",
      GetLastError());
}

void
wself_piper::install(demuxer* d, demux_callback* cb)
{
  fprintf(stderr, "wself_piper::install(%p, %p)\n", d, cb);
  iocp_demuxer* demux = static_cast<iocp_demuxer*>(d);

  // make read end non blocking and associate with iocp
  HANDLE read_end = pp.get_read_end();

#if 0
  // make the anonymous pipe non blocking. this function is for named pipes,
  // but I've heard talk that it works for anon pipes too. Nope, doesn't work.
  DWORD pipe_mode = PIPE_NOWAIT;
  if(!SetNamedPipeHandleState(read_end, &pipe_mode, NULL, NULL))
  {
    fprintf(stderr, "SetNamedPipeHandleState failed: %i\n", GetLastError());
    return; // not much to be done here.
  }
#endif

  if(0 != demux->associate_with_iocp(read_end, NULL))
  {
    fprintf(stderr, "failed to install self pipe in IOCP!!!\n");
    return; // error code?
  }

  // copy into the self pipe wakeup, for its later use.
  spw.d = demux;
  spw.cb = cb;
  spw.file = read_end;

  fprintf(stderr, "initial self pipe arm\n");
  spw.arm();
}

// wakes demuxer
void
wself_piper::wake() 
{
  fprintf(stderr, "wself_piper::wake - write a byte\n");
  pp.write_byte();
}

wself_piper_wakeup::wself_piper_wakeup()
  // configure the control block for ReadFile on the read end pipe
  // will set pipe handle later, read = true
  : winfileio_control_block(INVALID_HANDLE_VALUE, NULL, 0, true),
    cb(0), d(0)
{
  // I'll probably need to reset the byte address
  fprintf(stderr, "SET UP THE PIPE HANDLE!\n");
}

// at this point the byte has already been read. we want to re-arm for future
// wakeups.
void
wself_piper_wakeup::iocp_op_finished(DWORD nbytes, ULONG_PTR udat,
    LPOVERLAPPED olp, int err)
{
  fprintf(stderr, "wself_piper_wakeup::iocp_op_finished\n");
  fprintf(stderr, "nbytes=%i, err=%i\n", nbytes, err);
  fprintf(stderr, "about to callback %p(%p)\n", cb, d);

  if(cb) cb->callback(d);

  arm();  // re-arm
}

void
wself_piper_wakeup::arm()
{
  // exec another nonblocking ReadFile on read end of pipe
  fprintf(stderr, "wself_piper_wakeup::arm\n");
  pb.buffer = &the_byte;
  pb.buffer_size = 1;
  pb.bytes_written = 0;
  if(start_overlapped())
    fprintf(stderr, "WARNING: wslef_pipe install completed immediately\n");
}

} }




