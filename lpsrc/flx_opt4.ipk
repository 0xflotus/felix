@head(1,"Make stack calls")
Name binding pass 2.

@h = tangler("src/flx_stack_calls.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1

val make_stack_calls:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  fully_bound_symbol_table_t

@h = tangler("src/flx_stack_calls.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions

(* first approximation: we can stack functions that have no
  function or procedure children AND no variables: later
  we will check the return type, for now just check
  the code generator works
*)

exception Found

(* A function is stackable provided it doesn't return
  a pointer to itself. There are only two ways this
  can happen: the function returns the address of
  a variable, or, it returns the closure of a child.

  We will check the return type for pointer or
  function types. If its a function, there
  has to be at least one child to grab our this
  pointer in its display. If its a pointer,
  there has to be either a variable, or any
  non-stackable child function, or any child
  procedure -- note that the pointer might address
  a variable in a child function or procedure,
  however it can't 'get out' of a function except
  by it being returned.
  
  Proposition: type variables cannot carry either
  pointers to a variable or a child function closure.

  Reason: type variables are all universally quantified
  and unconstrained. We would have v1 = &v2 for the pointer
  case, contrary to the current lack of constraints.
  Smly for functions. So we'll just ignore type variables.
*)

let has_var bbdfns children =
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_var _  -> raise Found
      | _ -> ()
    )
    children
    ;
    true
  with Found -> false

let has_fun bbdfns children =
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_procedure _ 
      | `BBDCL_function _ -> raise Found
      | _ -> ()
    )
    children
    ;
    true
  with Found -> false


(* NOTE: this won't work for abstracted types like unions
   or structs .. 
*)
let has_ptr_fn bbdfns children e = 
  let rec aux exclude e = match e with
    | `BTYP_function _ -> 
      (* if has_fun bbdfns children then *)
      raise Not_found

    | `BTYP_pointer _ -> 
      (* encode the more lenient condition here!! *)
      raise Not_found 

    | `BTYP_inst (i,ts) ->
      if not (mem i exclude) then
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      begin match entry with
      | `BBDCL_abs _ -> ()
      | `BBDCL_union (vs,cs)
      | `BBDCL_struct (vs,cs)
      | `BBDCL_cstruct (vs,cs) -> 
        let varmap = mk_varmap vs ts in
        iter 
        (fun (_,t) -> aux (i::exclude) (varmap_subst varmap t)) 
        cs
      | _ -> assert false
      end
    | x -> iter_btype (aux exclude) x

  in try aux [] e; false with Not_found -> true
    
let can_stack_func (child_map,bbdfns) i =
  let children = try Hashtbl.find child_map i with Not_found -> [] in
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (_,_,_,ret,_) -> not (has_ptr_fn bbdfns children ret)
  | `BBDCL_fun _
  | `BBDCL_struct _
  | `BBDCL_cstruct _ -> false (* hack *)
  | _ -> failwith ("Unexpected non-function " ^ id)

let ident x = x 
let tident t = t 

let rec enstack_applies syms (child_map, bbdfns) x = 
  let ea e = enstack_applies syms (child_map, bbdfns) e in
  match map_tbexpr ident ea tident x with
  | `BEXPR_apply_direct (i,ts,b),t  ->
    if can_stack_func (child_map, bbdfns) i
    then `BEXPR_apply_stack (i,ts,b),t
    else x
  
  | x -> x

let enstack_calls syms (child_map,bbdfns) exes =
  let ea e = enstack_applies syms (child_map, bbdfns) e in
  let exes' = ref [] in
  iter
  (fun x -> match x with
  | `BEXE_init (sr,i,b) -> 
    exes' := `BEXE_init (sr,i,ea b) :: !exes'

  | `BEXE_assign (sr,a,b) -> 
    exes' := `BEXE_assign (sr,ea a,ea b) :: !exes'

  | `BEXE_call_direct (sr,i,ts, b') ->
    exes' := `BEXE_call_direct (sr,i,ts,ea b') :: !exes'

  | `BEXE_call (sr,a,b) -> exes' := `BEXE_call (sr,ea a,ea b) :: !exes'
  | `BEXE_jump (sr,a,b) -> exes' := `BEXE_jump (sr,ea a,ea b) :: !exes'
  | `BEXE_fun_return (sr,a) -> exes' := `BEXE_fun_return (sr,ea a) :: !exes'
  | `BEXE_ifgoto (sr,e,l) -> exes' := `BEXE_ifgoto (sr,ea e, l) :: !exes'
  | `BEXE_ifnotgoto (sr,e,l) -> exes' := `BEXE_ifnotgoto (sr,ea e, l) :: !exes'
  | `BEXE_loop (sr,i,e) -> exes' := `BEXE_loop (sr,i,ea e) :: !exes'

  | `BEXE_nop _ -> () (* elide NOP *)
  | `BEXE_comment _  as x -> exes' := x :: !exes' (* but not comments *)

  | `BEXE_label (sr,s) -> 
    exes' := x :: !exes'

  | `BEXE_regmatch (sr,e,(a,n,h,tr)) ->
     let h' = Hashtbl.create 97 in
     Hashtbl.iter
     (fun i e -> Hashtbl.add h' i (ea e))
     h
     ;
    exes' := `BEXE_regmatch (sr,ea e,(a,n,h',tr)) :: !exes'


  | `BEXE_reglex (sr,p1,p2,(a,n,h,tr)) ->
     let h' = Hashtbl.create 97 in
     Hashtbl.iter
     (fun i e -> Hashtbl.add h' i (ea e))
     h
     ;
    exes' := `BEXE_reglex (sr,ea p1, ea p2,(a,n,h',tr)) :: !exes'

  | x -> exes' := x :: !exes'
  )
  exes
  ;
  rev !exes'

let copy_bbdcl syms (child_map,bbdfns) bbdfns2 i bbdfn =
  let data =
    match bbdfn with
    | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
      let exes = enstack_calls syms (child_map,bbdfns) exes in
      id,parent,sr,`BBDCL_procedure (props,vs,p,exes)

    | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
      let exes = enstack_calls syms (child_map,bbdfns) exes in
      id,parent,sr,`BBDCL_function (props,vs,p,ret,exes)
    | x -> x
  in
    Hashtbl.add bbdfns2 i data

let make_stack_calls syms (child_map, bbdfns) =
  let bbdfns2 = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i bbdfn ->
    copy_bbdcl syms (child_map,bbdfns) bbdfns2 i bbdfn
  )
  bbdfns
  ;
  bbdfns2

