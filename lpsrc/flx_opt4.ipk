@head(1,"Make stack calls")
Name binding pass 2.

@h = tangler("src/flx_stack_calls.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2

val make_stack_calls:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  fully_bound_symbol_table_t

@h = tangler("src/flx_stack_calls.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions

(* first approximation: we can stack functions that have no
  function or procedure children AND no variables: later
  we will check the return type, for now just check
  the code generator works
*)

exception Found

(* A function is stackable provided it doesn't return
  a pointer to itself. There are only two ways this
  can happen: the function returns the address of
  a variable, or, it returns the closure of a child.

  We will check the return type for pointer or
  function types. If its a function, there
  has to be at least one child to grab our this
  pointer in its display. If its a pointer,
  there has to be either a variable, or any
  non-stackable child function, or any child
  procedure -- note that the pointer might address
  a variable in a child function or procedure,
  however it can't 'get out' of a function except
  by it being returned.
  
  Proposition: type variables cannot carry either
  pointers to a variable or a child function closure.

  Reason: type variables are all universally quantified
  and unconstrained. We would have v1 = &v2 for the pointer
  case, contrary to the current lack of constraints.
  Smly for functions. So we'll just ignore type variables.
*)

let has_var bbdfns children =
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_var _  -> raise Found
      | _ -> ()
    )
    children
    ;
    true
  with Found -> false

let has_fun bbdfns children =
  try
    iter
    (fun i ->
      let id,parent,sr,entry = Hashtbl.find bbdfns i in
      match entry with 
      | `BBDCL_procedure _ 
      | `BBDCL_function _ -> raise Found
      | _ -> ()
    )
    children
    ;
    true
  with Found -> false


(* NOTE: this won't work for abstracted types like unions
   or structs .. 
*)
exception Unsafe

let has_ptr_fn cache syms bbdfns children e = 
  let rec aux e = 
    try match Hashtbl.find cache e with
    | `Recurse -> ()
    | `Unsafe -> raise Unsafe
    | `Safe -> ()
    with Not_found ->
      Hashtbl.add cache e `Recurse;
      match e with
      | `BTYP_function _ -> 
        (* if has_fun bbdfns children then *)
        Hashtbl.replace cache e `Unsafe;
        raise Unsafe

      | `BTYP_pointer _ -> 
        (* encode the more lenient condition here!! *)
        Hashtbl.replace cache e `Unsafe;
        raise Unsafe

      | `BTYP_inst (i,ts) ->
        let id,parent,sr,entry = Hashtbl.find bbdfns i in
        begin match entry with
        | `BBDCL_abs _ -> ()
        | `BBDCL_union (vs,cs)
        | `BBDCL_struct (vs,cs)
        | `BBDCL_cstruct (vs,cs) -> 
          let varmap = mk_varmap vs ts in
          begin try
            iter 
            (fun (_,t) -> 
              let t = varmap_subst varmap t in
              aux t
            ) 
            cs;
            Hashtbl.replace cache e `Safe
          with Unsafe ->
            Hashtbl.replace cache e `Unsafe;
            raise Unsafe
          end

        | _ -> assert false
        end
      | x -> 
        try 
          iter_btype aux x;
          Hashtbl.replace cache e `Safe
        with Unsafe ->
          Hashtbl.replace cache e `Unsafe;
          raise Unsafe

  in try aux e; false with Unsafe -> true
    
let can_stack_func cache syms (child_map,bbdfns) i =
  let children = try Hashtbl.find child_map i with Not_found -> [] in
  let id,parent,sr,entry = Hashtbl.find bbdfns i in
  match entry with
  | `BBDCL_function (_,_,_,ret,_) -> not (has_ptr_fn cache syms bbdfns children ret)
  | `BBDCL_nonconst_ctor _
  | `BBDCL_fun _
  | `BBDCL_struct _
  | `BBDCL_cstruct _ 
  | `BBDCL_regmatch _
  | `BBDCL_reglex _
    -> false (* hack *)
  | _ -> failwith ("Unexpected non-function " ^ id)

let ident x = x 
let tident t = t 

let rec enstack_applies cache syms (child_map, bbdfns) x = 
  let ea e = enstack_applies cache syms (child_map, bbdfns) e in
  match map_tbexpr ident ea tident x with
  | `BEXPR_apply ((`BEXPR_closure(i,ts),_),b),t 
  | `BEXPR_apply_direct (i,ts,b),t  ->
    if can_stack_func cache syms (child_map, bbdfns) i
    then `BEXPR_apply_stack (i,ts,b),t
    else x
  
  | x -> x

let enstack_calls cache syms (child_map,bbdfns) exes =
  let ea e = enstack_applies cache syms (child_map, bbdfns) e in
  let id x = x in
  map (map_bexe id ea id id id) exes

let copy_bbdcl cache syms (child_map,bbdfns) bbdfns2 i bbdfn =
  let ea e = enstack_applies cache syms (child_map, bbdfns) e in
  let data =
    match bbdfn with
    | id,parent,sr,`BBDCL_procedure (props,vs,p,exes) ->
      let exes = enstack_calls cache syms (child_map,bbdfns) exes in
      let exes = Flx_cflow.final_tailcall_opt exes in
      id,parent,sr,`BBDCL_procedure (props,vs,p,exes)

    | id,parent,sr,`BBDCL_function (props,vs,p,ret,exes) ->
      let exes = enstack_calls cache syms (child_map,bbdfns) exes in
      id,parent,sr,`BBDCL_function (props,vs,p,ret,exes)

    | id,parent,sr,`BBDCL_glr (props,vs,t,(p,exes)) ->
      let exes = enstack_calls cache syms (child_map,bbdfns) exes in
      id,parent,sr,`BBDCL_glr (props,vs,t,(p,exes))

    | id,parent,sr,`BBDCL_regmatch (_,vs,p,t,(a,i,h,m)) ->
      Hashtbl.iter
      (fun k e -> Hashtbl.replace h k (ea e))
      h;
      bbdfn (* mutated *)

    | id,parent,sr,`BBDCL_reglex (_,vs,p,j,t,(a,i,h,m)) ->
      Hashtbl.iter
      (fun k e -> Hashtbl.replace h k (ea e))
      h;
      bbdfn (* mutated *)

    | x -> x
  in
    Hashtbl.add bbdfns2 i data

let make_stack_calls syms (child_map, bbdfns) =
  let bbdfns2 = Hashtbl.create 97 in
  let cache = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i bbdfn ->
    copy_bbdcl cache syms (child_map,bbdfns) bbdfns2 i bbdfn
  )
  bbdfns
  ;
  bbdfns2

