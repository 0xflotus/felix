@head(1,'Utilities')
Generic (non Felix dependent) utilities.
@h = tangler('src/flx_util.mli')
@select(h)
val spaces : int -> string
val catmap : string -> ('a -> string) -> 'a list -> string
val (+>) : 'a -> ('a ->'b) -> 'b
val transpose: 'a list list -> 'a list list
val list_last: 'a list -> 'a 

@h = tangler('src/flx_util.ml')
@select(h)
let spaces level = String.make (level*2) ' '
let catmap sep fn ls = String.concat sep (List.map fn ls)
let (+>) x f = f x (* reverse application *)
let transpose x =
  let dtor ls =
    List.split (List.map (fun x -> List.hd x, List.tl x) ls)
  in let rec cons ls (h,t) = match List.hd t with
    | [] -> h :: ls
    | _ -> cons (h :: ls) (dtor t)
  in List.tl (List.rev (cons [] ([],x)))

let list_last l = List.hd (List.rev l)

@head(1,'Types')
@h = tangler('src/flx_types.mli')
These files declare the main data structures used by the compiler,
and provide routines to dump them to a string for debugging purposes.
@head(2,'Source Reference')
Provides a reference to the original source.
@select(h)
open Big_int
type srcref = 
  string * (* filename *)
  int * (* line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int   (* ending column, 1 origin *)

type range_srcref =
  string * (* filename *)
  int * (* starting line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int * (* ending line number, 1 origin *)
  int   (* ending column, 1 origin *)

@head(2,'Abstract Syntax Tree')
AST types are nodes of the Abstract Syntax Tree generated by the
parser. 

@head(3,'Names')
A simple name is an identifier, a qualified name is a dot (.) separated list
of instantiated names, and a instantiated name is a simple name optionally
followed by a square bracket enclosed list of type expressions.
@select(h)
type c_t = string     (* C++ code as a string *)
type id_t = string
and qualified_name_t = id_t list      (* module nesting *)
and suffixed_name_t = qualified_name_t * typecode_t  (* overload disambiguation *)

@head(3,'Type sublanguage')
Terms of the type sublanguage. The encoding 'TYP_none' is 
a hack which allows the suffixed name representation
to work for unsuffixed names. 
@p()
The encoding 'TYP_void'
is the categorical initial: the type of an empty
union, and the type ordinary procedure types return.
There are no values of this type. 
@select(h)
and typecode_t = 
  | TYP_name of qualified_name_t               (* named type *)
  | TYP_tuple of typecode_t list               (* product type *)
  | TYP_function of typecode_t * typecode_t    (* function type *)
  | TYP_pointer  of typecode_t                 (* pointer type *)
  | TYP_void                                   (* void type *)
  | TYP_none                                   (* special hack for 'no type' *)

@head(3,'Literals')
Literals recognized by the lexer.
@select(h)
and literal_t =
  | AST_int of string * big_int
  | AST_float of float
  | AST_string of string
  | AST_bool of bool

@head(3,'Expressions')
Expressions; that is, the functional calculator subsystem.
A name in general form like
@begin_displayed_code()
  X::Y[<int,float>]::Z::f : int * int * Z::Y[<int>]::long
@end_displayed_code()
is encoded as a pair called a suffixed name. The first part
of the suffixed name is the qualified name, and the last part
is an argument type signature, used to disambiguate naming of functions.
Note that this signature does NOT include the return type (since overloading
is only permited on the argument type).
@p()
The qualified name part consists of a list of names, first mentioned at the 
top of the list, each of which is a pair, the first part being an identifier,
and the second a list of type expressions. The pair represents an
instantiated module name; that is, a module name with bindings for 
its type variables.

@select(h)
and expr_t =
  | AST_deref of range_srcref * expr_t
  | AST_name of range_srcref * suffixed_name_t
  | AST_ref of range_srcref * expr_t
  | AST_literal of range_srcref * literal_t
  | AST_apply of range_srcref * (expr_t * expr_t)
  | AST_method_apply of range_srcref * (id_t * expr_t)
  | AST_tuple of range_srcref * expr_t list
  | AST_dot of range_srcref * (expr_t * id_t)
  | AST_lambda of range_srcref * (parameter_t list * typecode_t * statement_t list)
  | AST_match_ctor of range_srcref * (qualified_name_t * expr_t)
  | AST_ctor_arg of range_srcref * (qualified_name_t * expr_t)
  | AST_get_n of range_srcref * (int * expr_t) (* get n'th component of a tuple *)
  
@head(3,'Pattern')
Patterns; used for matching variants in match statements.
@select(h)
and pattern_t =
  (* constants *)
  | PAT_int of range_srcref * big_int
  | PAT_string of range_srcref * string

  (* ranges *)
  | PAT_int_range of range_srcref * big_int * big_int
  | PAT_string_range of range_srcref * string * string
  | PAT_float_range of range_srcref * float * float

  (* other *)
  | PAT_name of range_srcref * id_t 
  | PAT_tuple of range_srcref * pattern_t list
  | PAT_any of range_srcref 
  | PAT_regexp of range_srcref * string * id_t list 
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | PAT_const_ctor of range_srcref * qualified_name_t
  | PAT_nonconst_ctor of range_srcref * qualified_name_t * pattern_t
  | PAT_as of range_srcref * pattern_t * id_t
  | PAT_when of range_srcref * pattern_t * expr_t
 
@head(3,'Pattern extractor')
This type is used to extract components of a value,
corresponding to a match.
@select(h)
and extract_t = 
  | Proj_n of range_srcref * int             (* tuple projections 1 .. n *)
  | Udtor of range_srcref * qualified_name_t (* argument of union component s *)

@head(3,'Statements')
Statements; that is, the procedural sequence control system.
@select(h)
and parameter_t = id_t * typecode_t
and statement_t =
  | AST_label of range_srcref * id_t (* for testing the code generator! *)
  | AST_goto of range_srcref * id_t (* for testing the code generator! *)
  
  | AST_comment of string (* for documenting generated code *)
  (* definitions *)
  | AST_function of range_srcref * id_t * parameter_t list * typecode_t * statement_t list
  | AST_procedure of range_srcref * typecode_t * id_t * parameter_t list * statement_t list

  | AST_val_decl of range_srcref * id_t * typecode_t option * expr_t option
  | AST_var_decl of range_srcref * id_t * typecode_t option * expr_t option

  | AST_type_alias of range_srcref * id_t * typecode_t
  | AST_except_handler of range_srcref * id_t * parameter_t list * statement_t list
  
  (* control structures *)
  | AST_call of range_srcref * expr_t * expr_t 
  | AST_read of range_srcref * id_t
  | AST_return of range_srcref * expr_t
  | AST_block of range_srcref * statement_t list
  | AST_nop of range_srcref * string
  | AST_if of 
    range_srcref * 
    (range_srcref * (expr_t * statement_t)) list * 
    (range_srcref * statement_t)
  | AST_while of range_srcref * expr_t * statement_t
  | AST_attempt of 
    range_srcref *
    (range_srcref * statement_t) *         (* the attempt *)
    (range_srcref * statement_t list) *    (* the handlers *)
    (range_srcref * statement_t list)      (* the finally block *)

  | AST_raise of range_srcref * id_t * expr_t
  | AST_match of range_srcref * expr_t * (pattern_t * statement_t) list

  (* binding structures [prolog] *)
  | AST_abs_decl of range_srcref * id_t * c_t
  | AST_const_decl of range_srcref * id_t * typecode_t * c_t
  | AST_fun_decl of range_srcref * id_t * typecode_t list * typecode_t * c_t 
  | AST_proc_decl of range_srcref * id_t * typecode_t list * c_t 
  | AST_header of range_srcref * string
  | AST_code of range_srcref * string
  | AST_union of range_srcref * id_t * (id_t * typecode_t) list
  | AST_struct of range_srcref * id_t * (id_t * typecode_t) list
  | AST_module of range_srcref * id_t * statement_t list  
  | AST_export of range_srcref * suffixed_name_t * string

and exe_t =
  | EXE_code of string (* for inline C++ code *)
  | EXE_comment of string (* for documenting generated code *)
  | EXE_label of string (* for internal use only *)
  | EXE_goto of string  (* for internal use only *)
  | EXE_ifgoto of expr_t * string  (* for internal use only *)
  | EXE_ifnotgoto of expr_t * string  (* for internal use only *)
  | EXE_call of expr_t * expr_t 
  | EXE_read of id_t
  | EXE_return of expr_t
  | EXE_nop of string
  | EXE_init of id_t * expr_t 

and dcl_t = 
  | DCL_header of string
  | DCL_function of   parameter_t list * typecode_t * asm_t list
  | DCL_procedure of  typecode_t * parameter_t list * asm_t list
  
  | DCL_match_check of pattern_t * string
  | DCL_match_handler of  typecode_t * pattern_t * string * asm_t list
  
  | DCL_val of        typecode_t
  | DCL_val_typeof of expr_t
  | DCL_var of        typecode_t
  | DCL_var_typeof of expr_t
  | DCL_type_alias of typecode_t

  (* binding structures [prolog] *)
  | DCL_abs of        c_t
  | DCL_const of      typecode_t * c_t
  | DCL_fun of        typecode_t list * typecode_t * c_t 
  | DCL_proc of       typecode_t list * c_t 
  | DCL_union of      (id_t * typecode_t) list
  | DCL_struct of     (id_t * typecode_t) list
  | DCL_module of     asm_t list  

and asm_t = 
  | Exe of range_srcref * exe_t 
  | Dcl of range_srcref * id_t * dcl_t 
  | Iface of range_srcref * iface_t

and bid_t = int

and iface_t =
  | IFACE_export of suffixed_name_t * string

and biface_t =
  | BIFACE_export of bid_t * string

and bexe_t =
  | BEXE_label of string
  | BEXE_comment of string (* for documenting generated code *)
  | BEXE_goto of string  (* for internal use only *)
  | BEXE_ifgoto of tbexpr_t * string  (* for internal use only *)
  | BEXE_ifnotgoto of tbexpr_t * string  (* for internal use only *)
  | BEXE_call of tbexpr_t * tbexpr_t 
  | BEXE_read of bid_t
  | BEXE_return of tbexpr_t
  | BEXE_nop of string
  | BEXE_code of string
  | BEXE_init of bid_t * tbexpr_t 

and bexpr_t =
  | BEXPR_deref of tbexpr_t
  | BEXPR_name of bid_t
  | BEXPR_ref of bid_t
  | BEXPR_literal of literal_t 
  | BEXPR_apply of tbexpr_t * tbexpr_t 
  | BEXPR_tuple of tbexpr_t list
  | BEXPR_dot of tbexpr_t * bid_t
  | BEXPR_get_n of int * tbexpr_t
  | BEXPR_closure of bid_t

and tbexpr_t = bexpr_t * btypecode_t

and btypecode_t = 
  | BTYP_name of bid_t                            (* named type *)
  | BTYP_tuple of btypecode_t list                (* product type *)
  | BTYP_function of btypecode_t * btypecode_t    (* function type *)
  | BTYP_pointer  of btypecode_t                  (* pointer type *)
  | BTYP_void                                     (* void type *)
  | BTYP_none                                     (* special hack for 'no type' *)

and bparameter_t = string * btypecode_t
and bdcl_t = 
  | BDCL_header of     string
  | BDCL_function of   bparameter_t list * btypecode_t * int list * exe_t list * name_map_t
  | BDCL_procedure of  bparameter_t list * int list * exe_t list * name_map_t 
  
  | BDCL_match_check of pattern_t * int * int list
  | BDCL_match_handler of btypecode_t * pattern_t * int * int list * exe_t list * name_map_t

  | BDCL_val of        btypecode_t
  | BDCL_var of        btypecode_t

  | BDCL_val_typeof of expr_t
  | BDCL_var_typeof of expr_t 

  (* binding structures [prolog] *)
  | BDCL_abs of        c_t
  | BDCL_const of      btypecode_t * c_t
  | BDCL_fun of        btypecode_t list * btypecode_t * c_t 
  | BDCL_proc of       btypecode_t list * c_t 
  | BDCL_union of      (id_t * btypecode_t) list
  | BDCL_struct of     (id_t * btypecode_t) list
  | BDCL_module of     name_map_t

and bbdcl_t = 
  | BBDCL_header of     string
  | BBDCL_function of   bparameter_t list * btypecode_t * int list * bexe_t list * name_map_t
  | BBDCL_procedure of  bparameter_t list * int list * bexe_t list * name_map_t

  | BBDCL_val of        btypecode_t
  | BBDCL_var of        btypecode_t

  (* binding structures [prolog] *)
  | BBDCL_abs of        c_t
  | BBDCL_const of      btypecode_t * c_t
  | BBDCL_fun of        btypecode_t list * btypecode_t * c_t 
  | BBDCL_proc of       btypecode_t list * c_t 
  | BBDCL_union of      (id_t * btypecode_t) list
  | BBDCL_struct of     (id_t * btypecode_t) list

  | BBDCL_module of     name_map_t

and entry_set_t =
  | FunctionEntry of int list
  | NonFunctionEntry of int
  
and name_map_t = (string, entry_set_t) Hashtbl.t


type env_t = name_map_t list
type symbol_definition_t =
  | SYMDEF_module of name_map_t
  | SYMDEF_parameter of typecode_t
  | SYMDEF_function of parameter_t list * typecode_t * int list * exe_t list * name_map_t
  | SYMDEF_match_check of pattern_t * int * int list
  | SYMDEF_match_handler of typecode_t * pattern_t * int * int list * exe_t list * name_map_t
  | SYMDEF_procedure of typecode_t * 
     parameter_t list * int list * exe_t list * name_map_t
  | SYMDEF_dcl of dcl_t

type symbol_data_t = string * range_srcref * int option * symbol_definition_t 
type symbol_table_t = (int, symbol_data_t) Hashtbl.t

type symbol_data2_t = string * int option * bdcl_t 
type bound_symbol_table_t = (int, symbol_data2_t) Hashtbl.t

type symbol_data3_t = string * int option * bbdcl_t 
type fully_bound_symbol_table_t = (int, symbol_data3_t) Hashtbl.t

type type_registry_t = (btypecode_t,int) Hashtbl.t

@doc()
The whole of a compilation unit, this is the data structure
returned by parsing a whole file.
@select(h)
type compilation_unit_t = statement_t list

@head(1,'Routines to extract source reference from terms')
Source reference manipulators.
@h = tangler('src/flx_srcref.mli')
@select(h)
open Flx_types
val rstoken: srcref -> srcref -> range_srcref
val rsrange: range_srcref -> range_srcref -> range_srcref
val lift: srcref -> range_srcref

val rsexpr: expr_t -> expr_t -> range_srcref
val rslist: expr_t list -> range_srcref

val src_of_expr : expr_t -> range_srcref
val src_of_statement: statement_t -> range_srcref
val src_of_pattern: pattern_t -> range_srcref
val short_string_of_src: range_srcref -> string

(* the following routine takes a 
  source reference 'sr' 
  and a string 's'
  and produces an untyped AST_name:

    AST_name (sr,([s],TYP_none))

  It doesn't really belong here, but it was a convenient
  place to put it :-)
*)
val name_of_string: range_srcref -> string -> expr_t

@h = tangler('src/flx_srcref.ml')
@doc()
Generic source reference manipulation.
Note the special hack of forgetting the second
filename when creating a range: the alternative
would be to record a complete list of lines.
@select(h)
(* get source range from source references of first
   and last tokens 
*)
let rstoken (f1,l1,s1,e1) (f2,l2,s2,e2) = (f1,l1,s1,l2,e2)

(* get range from first and last ranges *)
let rsrange (f1,sl1,sc1,el1,ec1) (f2,sl2,sc2,el2,ec2) =
  (f1,sl1,sc1,el2,ec2)

(* lift token source to range *)
let lift (f,l,s,e) = (f,l,s,l,e)

(* axiom: rstoken a b = rsrange (lift a) (lift b) *)

@doc()
Type specific operations.
@select(h)
open Flx_util
open Flx_types
let src_of_expr e = match e with
  | AST_deref (s,_) 
  | AST_name  (s,_) 
  | AST_ref  (s,_) 
  | AST_literal  (s,_) 
  | AST_apply  (s,_) 
  | AST_method_apply  (s,_) 
  | AST_tuple  (s,_) 
  | AST_dot  (s,_) 
  | AST_lambda  (s,_) 
  | AST_match_ctor  (s,_) 
  | AST_ctor_arg  (s,_) 
  | AST_get_n  (s,_) 
    -> s 
(* get range from first and last expressions *)
let rsexpr a b = rsrange (src_of_expr a) (src_of_expr b)

(* get source range of non-empty list of expressions *)
let rslist lst = 
  rsexpr (List.hd lst) (list_last lst)

let src_of_statement s = match s with
  | AST_label (s,_)
  | AST_goto (s,_)
  
  | AST_function (s, _, _ , _, _)
  | AST_procedure (s, _, _, _ , _)

  | AST_val_decl (s, _, _, _) 
  | AST_var_decl (s, _, _, _) 

  | AST_type_alias (s, _, _) 
  | AST_except_handler (s, _, _, _ ) 
  
  | AST_call (s, _, _ ) 
  | AST_read (s, _) 
  | AST_return (s, _) 
  | AST_block (s, _ ) 
  | AST_nop (s, _) 
  | AST_if (s, _ , _) 
  | AST_while (s, _, _) 
  | AST_attempt (s,_,_,_)

  | AST_raise (s, _, _) 
  | AST_match (s, _, _) 

  | AST_abs_decl (s, _, _) 
  | AST_const_decl (s, _, _, _) 
  | AST_fun_decl (s, _, _ , _, _ ) 
  | AST_proc_decl (s, _, _ , _ ) 
  | AST_header (s,_) 
  | AST_code (s, _) 
  | AST_union (s, _, _ ) 
  | AST_struct (s, _, _)
  | AST_module (s, _, _ )
  | AST_export (s, _,_)
    -> s

  | AST_comment _ -> ("Generated",0,0,0,0)

let src_of_pattern p = match p with
  (* constants *)
  | PAT_int (s, _)
  | PAT_string (s, _)

  (* ranges *)
  | PAT_int_range (s, _, _)
  | PAT_string_range (s, _, _)
  | PAT_float_range (s, _,_)

  (* other *)
  | PAT_name (s, _)
  | PAT_tuple (s, _)
  | PAT_any s
  | PAT_regexp (s, _, _ )
  | PAT_const_ctor (s, _)
  | PAT_nonconst_ctor (s, _, _)
  | PAT_as (s, _, _)
  | PAT_when (s, _, _)
    -> s

let short_string_of_src (f,l1,c1,l2,c2) =
  if l1 = l2 
  then
    f ^ ": line " ^ string_of_int l1 ^ 
    ", cols " ^ string_of_int c1 ^ " to " ^ string_of_int c2
  else
    f ^ ": line " ^ string_of_int l1 ^ 
    " col " ^ string_of_int c1 ^ " to " ^ 
    " line " ^ string_of_int l2 ^ " col " ^ string_of_int c2

let name_of_string sr s = 
  AST_name (sr,([s],TYP_none))

@head(1,'Print module')
Routines to print various terms.
@h = tangler('src/flx_print.mli')
@select(h)
open Flx_types
val string_of_typecode : typecode_t -> string
val string_of_btypecode : symbol_table_t -> btypecode_t -> string
val special_string_of_typecode : typecode_t -> string
val string_of_expression : expr_t -> string
val string_of_bound_expression : 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val string_of_pattern : pattern_t -> string
val string_of_literal : literal_t -> string
val string_of_parameters : parameter_t list -> string
val string_of_arguments : expr_t list -> string
val string_of_statement : int -> statement_t -> string
val string_of_compilation_unit : compilation_unit_t -> string
val string_of_desugared : asm_t list -> string
val string_of_suffixed_name : suffixed_name_t -> string
val string_of_qualified_name : qualified_name_t -> string
val string_of_dcl : int -> id_t -> dcl_t -> string
val string_of_bdcl : symbol_table_t -> int -> int -> bdcl_t -> string
val string_of_bexe : symbol_table_t -> int -> bexe_t -> string
val string_of_exe : int -> exe_t -> string
val qualified_name_of_index : symbol_table_t -> int -> string
val string_of_bbdcl : 
  symbol_table_t -> 
  bbdcl_t -> 
  int -> 
  string

@h = tangler('src/flx_print.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_srcref
open Big_int

let string_of_string = Flx_string.c_quote_of_string

let rec string_of_qualified_name name =
  String.concat "::"  name

and string_of_suffixed_name (name,typ) =
  string_of_qualified_name name
  ^
  match typ with
  | TYP_none -> ""
  | _ -> " of (" ^ string_of_typecode typ ^ ")"

and suffix_of_type s = match s with
  | "tiny" -> "t"
  | "short" -> "s"
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "v"
  | "utiny" -> "tu"
  | "ushort" -> "su"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "vu"
  | "int8" -> "i8"
  | "int16" -> "i16"
  | "int32" -> "i32"
  | "int64" -> "i64"
  | "uint8" -> "u8"
  | "uint16" -> "u16"
  | "uint32" -> "u32"
  | "uint64" -> "u64"
  | _ -> failwith ("[suffix_of_type] Unexpected Integer Type " ^ s)

 
and string_of_literal e = match e with
  | AST_bool i -> (match i with | true -> "true" | false -> "false")
  | AST_int (s,i) -> (string_of_big_int i)^suffix_of_type s 
  | AST_float x -> string_of_float x
  | AST_string s -> string_of_string s

and string_of_expression e = 
  let se e = string_of_expression e in
  match e with
  | AST_get_n (_,(n,e)) -> "get (" ^ string_of_int n ^ ", " ^se e^")"
  | AST_deref (_,e) -> "*(" ^ se e ^ ")"
  | AST_name (_,name) -> string_of_suffixed_name name
  | AST_ref (_,e) -> "&" ^ "(" ^ se e ^ ")"
  | AST_literal (_,e) -> string_of_literal e
  | AST_apply  (_,(fn, arg)) -> "(" ^ 
    string_of_expression fn ^ " " ^ 
    string_of_expression arg ^ 
    ")"

  | AST_method_apply  (_,(fn, arg)) -> "(" ^ 
    fn ^ " " ^ 
    string_of_expression arg ^ 
    ")"

  | AST_tuple (_,t) -> "(" ^ catmap ", " string_of_expression t ^ ")"
  | AST_dot (_,(e,n)) ->  "get_" ^ n ^ "(" ^ string_of_expression e ^ ")"

  | AST_lambda (_,(params,ret, sts)) -> 
    "(lambda(" ^ string_of_parameters params ^ "): " ^ 
    string_of_typecode ret ^
    string_of_compound 0 sts
  | AST_ctor_arg (_,(cn,e)) ->
    "ctor_arg " ^ string_of_qualified_name cn ^ "(" ^
    string_of_expression e ^ ")"
  | AST_match_ctor (_,(cn,e)) ->
    "match_ctor " ^ string_of_qualified_name cn ^ "(" ^
    string_of_expression e ^ ")"

and string_of_typecode tc = match tc with
  | TYP_name name -> string_of_qualified_name name
  | TYP_tuple ls -> 
    begin match ls with 
    | [] -> "unit" 
    | _ -> "(" ^ (String.concat " * " (List.map string_of_typecode ls)) ^")"
    end

  | TYP_function (args, result) ->  
    "(" ^ (string_of_typecode args) ^ " -> " ^ (string_of_typecode result) ^ ")"
  | TYP_pointer t -> "&(" ^ (string_of_typecode t) ^ ")"
  | TYP_void -> "void"
  | TYP_none -> "<none>"

and qualified_name_of_index dfns index = 
  match Hashtbl.find dfns index with 
  | (id,sr,None,_) -> (* id ^ "<" ^ string_of_int index ^ ">" *) ""
  | (id,sr,Some index',_) -> 
    qualified_name_of_index dfns index' ^ "::" ^
    id ^ "<" ^ string_of_int index ^ ">"

and string_of_btypecode dfns tc = 
  let sbt t = string_of_btypecode dfns t in
  match tc with
  | BTYP_name n -> qualified_name_of_index dfns n
  | BTYP_tuple ls -> 
    begin match ls with 
    | [] -> "unit" 
    | [x] -> failwith ("UNEXPECTED TUPLE OF ONE ARGUMENT " ^ sbt x)
    | _ -> "(" ^ (String.concat " * " (List.map sbt ls)) ^")"
    end

  | BTYP_function (args, result) ->  
    "(" ^ (sbt args) ^ " -> " ^ (sbt result) ^ ")"

  | BTYP_pointer t -> "&(" ^ (sbt t) ^ ")"
  | BTYP_void -> "void"
  | BTYP_none -> "<none>"

and string_of_parameters ps = 
  String.concat 
    ", " 
    (List.map (fun (x,y)-> x ^ ": "^(string_of_typecode y)) ps)

and string_of_bparameters dfns ps = 
  String.concat 
    ", " 
    (List.map (fun (x,y)-> x ^ ": "^(string_of_btypecode dfns y)) ps)

and string_of_arguments ass = 
  catmap ", " string_of_expression ass

 
and string_of_component level (name, typ) = 
   (spaces level) ^ name ^ ": " ^ (string_of_typecode typ)

and string_of_pattern p = match p with
  | PAT_int (_,i) -> string_of_big_int i
  | PAT_int_range (_,i1,i2) -> 
    string_of_big_int i1 ^ " .. " ^ string_of_big_int i2
  | PAT_string (_,s) -> string_of_string s
  | PAT_string_range (_,s1, s2) -> 
    string_of_string s1 ^ " .. " ^ string_of_string s2
  | PAT_float_range (_,x1, x2) -> 
    string_of_float x1 ^ " .. " ^ string_of_float x2
  | PAT_name (_,s) -> s
  | PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_pattern ps ^ ")"
  | PAT_any _ -> "any"
  | PAT_regexp (_,r,b) -> 
    "regexp " ^ string_of_string r ^
    "(" ^ String.concat ", " b ^ ")"
  | PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_pattern p
  | PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | PAT_when (_,p,e) -> "(" ^ string_of_pattern p ^ " when " ^ string_of_expression e ^ ")"
 
and string_of_compound level ss = 
  (spaces level) ^ "{\n" ^
  catmap "\n" (string_of_statement (level+1)) ss ^ "\n" ^
  (spaces level) ^ "}"

and short_string_of_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_compound level ss

and string_of_asm_compound level ss = 
  (spaces level) ^ "{\n" ^
  catmap "\n" (string_of_asm (level+1)) ss ^ "\n" ^
  (spaces level) ^ "}"

and short_string_of_asm_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_asm_compound level ss

and special_string_of_typecode ty =  (* used for constructors *)
  match ty with
  | TYP_tuple [] -> ""
  | _ -> " of " ^ string_of_typecode ty

and special_string_of_btypecode dfns ty =  (* used for constructors *)
  match ty with
  | BTYP_tuple [] -> ""
  | _ -> " of " ^ string_of_btypecode dfns ty


and string_of_statement level s = 
  match s with 
  | AST_export (_,flx_name,cpp_name) -> 
    spaces level ^ "export " ^ 
    string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | AST_label (_,s) -> s ^ ":"
  | AST_goto (_,s) -> (spaces level) ^ "goto " ^ s ^ ";"

  | AST_comment s -> (spaces level) ^ "// " ^ s

  | AST_type_alias (_,t1,t2) ->
    spaces level ^ "type " ^ t1 ^ " = " ^ string_of_typecode t2 ^ ";"

  | AST_module (_,name, sts)  -> 
    (spaces level) ^ "module " ^ name ^
    "\n" ^ 
    string_of_compound level sts

  | AST_struct (_,name, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    (spaces level) ^ "struct " ^ name ^ " = " ^
    (spaces level) ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    (spaces level) ^ "}"

  | AST_union (_,name, cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^ name ^ special_string_of_typecode ty
    in
    (spaces level) ^ "union " ^ name ^ " = " ^
    (spaces level) ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    (spaces level) ^ "}"

  | AST_match (_,e, ps) ->
    (spaces level) ^ "match " ^ string_of_expression e ^ "\n" ^
    (spaces level) ^ "{\n" ^
    catmap "\n"
    (fun (p,s)->
      (spaces (level+1)) ^ "case " ^
      string_of_pattern p ^
      ":\n" ^
      string_of_statement (level+2) s
    )
    ps
    ^
    "\n" ^ (spaces level) ^ "} /* end match */"

  | AST_abs_decl (_,t,code) -> (spaces level) ^ 
   "type " ^ t ^ " = " ^ string_of_string code ^ ";"

  | AST_fun_decl (_,name,args, result, code) ->
    (spaces level) ^ 
     "fun " ^ name ^ ": " ^ 
     (string_of_typecode (TYP_tuple args)) ^ " -> " ^
     (string_of_typecode result) ^ 
     " = " ^ string_of_string code ^ ";"

  | AST_proc_decl (_,name,args, code) ->
    (spaces level) ^ 
    "proc " ^ name ^ ": " ^ 
     (string_of_typecode (TYP_tuple args)) ^
     " = " ^ string_of_string code ^ ";"

  | AST_const_decl (_,name,typ, code) ->
    (spaces level) ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ ";" 

  | AST_header (_,s) -> let triple_quote = "\"\"\"" in
    "header \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote

  | AST_code (_,s) -> let triple_quote = "\"\"\"" in
    "code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote

  | AST_function (_,name, ps, res, ss) -> 
    (spaces level) ^ 
    "function " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_compound level ss

  | AST_procedure (_,msgt, name, ps, ss) -> 
    (spaces level) ^ 
    "procedure ("^string_of_typecode msgt^") " ^ name ^ 
    "("^ (string_of_parameters ps)^")" ^
    short_string_of_compound level ss

  | AST_block (_,ss) -> string_of_compound level ss

  | AST_val_decl (_,name, ty, value) ->
    (spaces level) ^ 
    "val " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (string_of_expression e) 
      | None -> ""
    )
    ^ ";"

  | AST_var_decl (_,name, ty, value) ->
    (spaces level) ^ 
    "var " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (string_of_expression e) 
      | None -> ""
    )
    ^ ";"


  | AST_call (_,pr, args) ->
    (spaces level)
    ^ "call " ^ string_of_expression pr ^ " " ^ string_of_expression args ^ ";"

  | AST_nop (_,s) -> (spaces level) ^ "{/*"^s^"*/;}"

  | AST_if (_,clist, (_,s2)) ->
    begin catmap ((spaces level) ^ "else ")
      begin fun (sr, (e, s)) ->
        (spaces level) ^ "if " ^
        (string_of_expression e) ^ " then\n" ^
        (string_of_statement (level+1) s) ^ "\n"
      end
      clist
    end
    ^ 
    begin match s2 with 
      | AST_nop (_,"") -> ""
      | _ ->
        (spaces level) ^ "else\n" ^
        (string_of_statement (level+1) s2)
    end
  
  | AST_while (_,e,s) ->
    (spaces level) ^ "while(" ^ (string_of_expression e) ^ ")\n" ^
    (string_of_statement (level+1) s)

  | AST_except_handler (_,label,params,code) ->
    (spaces level) ^ "except " ^ label ^ " " ^ 
    "("^ (string_of_parameters params)^")"^
    short_string_of_compound level code

  | AST_attempt (_,(_,main), (_,handlers), (fsr,finally)) ->
    (spaces level) ^ "attempt\n" ^
    string_of_statement (level+1) main ^ "\n" ^
    (spaces level) ^ "exceptions\n" ^
    (spaces level) ^ "{\n" ^
    catmap "\n" (string_of_statement (level+1)) handlers ^ "\n" ^
    (
      match finally with 
      | [] -> "" 
      | _ -> 
        (spaces level) ^ "finally\n" ^ 
        string_of_statement (level+1) 
          (AST_block (fsr,finally))
    ) ^ "\n" ^
    (spaces level) ^ "}"
    

  | AST_raise (_,label,e) -> 
    (spaces level) ^ "raise " ^ label ^
    begin match e with
    | AST_tuple (_,[]) -> ""
    | expr -> " " ^ string_of_expression expr
    end ^ 
    ";"

  | AST_return (_,e) -> 
    (spaces level) ^ "return " ^ (string_of_expression e) ^ ";"
    
  | AST_read (_,name) ->
    (spaces level) ^ "read " ^ name ^ ";"

and string_of_compilation_unit stats =
  catmap "\n" (string_of_statement 0) stats

and string_of_desugared stats =
  catmap "\n" (string_of_asm 0) stats
  
and string_of_iface level s =
  let spc = spaces level in
  match s with
  | IFACE_export (flx_name,cpp_name) -> 
    spc ^ "export " ^ string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

and string_of_exe level s = 
  let spc = spaces level in
  match s with
  | EXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | EXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ string_of_expression e ^ ")goto " ^ s ^ ";"

  | EXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ string_of_expression e ^ "))goto " ^ s ^ ";"

  | EXE_label s -> s ^ ":"

  | EXE_comment s -> spc ^ 
    "// " ^ s 

  | EXE_call (p,a) -> spc ^ 
    "call " ^ 
    string_of_expression p ^ " " ^ 
    string_of_expression a ^ ";"

  | EXE_read v -> spc ^ 
    "read " ^ v

  | EXE_return x -> spc ^ 
    "return " ^ string_of_expression x ^ ";"

  | EXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | EXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | EXE_init (l,r) -> spc ^ 
    l ^ " := " ^ string_of_expression r ^ ";"

and string_of_bound_expression dfns e = 
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match fst e with
  | BEXPR_get_n (n,e') -> "(" ^ se e' ^ ").mem_" ^ string_of_int n
  | BEXPR_deref e -> "*("^ se e ^ ")"
  | BEXPR_name i -> sid i 
  | BEXPR_closure i -> "closure(" ^ sid i ^ ")"
  | BEXPR_ref i -> "&" ^ sid i
  | BEXPR_literal e -> string_of_literal e
  | BEXPR_apply  (fn, arg) -> "(" ^ 
    se fn ^ " " ^ 
    se arg ^ 
    ")"

  | BEXPR_tuple t -> "(" ^ catmap ", " se t ^ ")"
  | BEXPR_dot (e,n) ->  "get_<" ^ string_of_int n ^ ">(" ^ se e ^ ")"

and string_of_biface dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | BIFACE_export (index,cpp_name) ->
    spc ^ "export " ^ qualified_name_of_index dfns index ^ 
    " as \"" ^ cpp_name ^ "\";"

and string_of_bexe dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | BEXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | BEXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | BEXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | BEXE_label s -> s ^ ":"

  | BEXE_comment s -> spc ^ 
    "// " ^ s 

  | BEXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | BEXE_read v -> spc ^ 
    "read " ^ sid v 

  | BEXE_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | BEXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | BEXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | BEXE_init (l,r) -> spc ^ 
    sid l ^ " := " ^ se r ^ ";"

and string_of_dcl level name s = match s with
  | DCL_header s -> "header " ^ string_of_string s
  | DCL_type_alias (t2) ->
    spaces level ^ "type " ^ name ^ " = " ^ string_of_typecode t2 ^ ";"

  | DCL_module (sts)  -> 
    (spaces level) ^ "module " ^ name ^
    "\n" ^ 
    string_of_asm_compound level sts

  | DCL_struct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    (spaces level) ^ "struct " ^ name ^ " = " ^
    (spaces level) ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    (spaces level) ^ "}"

  | DCL_union (cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^name ^ special_string_of_typecode ty
    in
    (spaces level) ^ "union " ^ name ^ " = " ^
    (spaces level) ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    (spaces level) ^ "}"

  | DCL_abs (code) -> (spaces level) ^ 
   "type " ^ name ^ " = " ^ string_of_string code ^ ";"

  | DCL_fun (args, result, code) ->
    (spaces level) ^ 
     "fun " ^ name ^ ": " ^ 
     (string_of_typecode (TYP_tuple args)) ^ " -> " ^
     (string_of_typecode result) ^ 
     " = " ^ string_of_string code ^ ";"

  | DCL_proc (args, code) ->
    (spaces level) ^ 
    "proc " ^ name ^ ": " ^ 
     (string_of_typecode (TYP_tuple args)) ^
     " = " ^ string_of_string code ^ ";"

  | DCL_const (typ, code) ->
    (spaces level) ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ ";" 

  | DCL_function (ps, res, ss) -> 
    (spaces level) ^ 
    "function " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_asm_compound level ss

  | DCL_procedure (msgt, ps, ss) -> 
    (spaces level) ^ 
    "procedure ("^string_of_typecode msgt^") " ^ name ^ 
    "("^ (string_of_parameters ps)^")" ^
    short_string_of_asm_compound level ss

  | DCL_match_check (pat,s) ->
    (spaces level) ^ 
    "function " ^ name ^ "() { " ^ 
    s ^ " matches " ^ string_of_pattern pat ^
    " }"

  | DCL_match_handler (_,pat,e, ss) ->
    (spaces level) ^ 
    "procedure " ^ name ^ 
    "() //pattern: " ^ string_of_pattern pat ^ "\n" ^
    string_of_asm_compound level ss


  | DCL_val (ty) ->
    (spaces level) ^ 
    "val " ^ name ^ ": " ^ string_of_typecode ty ^ ";"

  | DCL_var (ty) ->
    (spaces level) ^ 
    "var " ^ name ^ ": " ^ string_of_typecode ty ^ ";"

  | DCL_val_typeof (e) ->
    (spaces level) ^ 
    "val " ^ name ^ ": typeof(" ^ string_of_expression e ^ ");"

  | DCL_var_typeof (e) ->
    (spaces level) ^ 
    "var " ^ name ^ ": typeof(" ^ string_of_expression e ^ ");"

and string_of_asm level s =
  match s with
  | Dcl (sr,name,d) -> string_of_dcl level name d
  | Exe (sr,s) -> string_of_exe level s
  | Iface (sr,s) -> string_of_iface level s

and string_of_bdcl dfns level index s = 
  let name = qualified_name_of_index dfns index in
  let string_of_btypecode t = string_of_btypecode dfns t in
  match s with
  | BDCL_module name_map -> 
    spaces level ^
    "module " ^ name ^ ";\n"

  | BDCL_match_check (pat,index,display) ->
    (spaces level) ^ 
    "_match_var_"^string_of_int index ^ " matches " ^ string_of_pattern pat

  | BDCL_match_handler (msgt, pat,idx, display,exes,_) ->
    (spaces level) ^ 
    "match_proc (" ^ string_of_pattern pat ^ ")" 

  | BDCL_header s -> "header " ^ string_of_string s

  | BDCL_struct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_btypecode ty ^ ";"
    in
    (spaces level) ^ "struct " ^ name ^ " = " ^
    (spaces level) ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    (spaces level) ^ "}"

  | BDCL_union (cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^ name ^ special_string_of_btypecode dfns ty
    in
    (spaces level) ^ "union " ^ name ^ " = " ^
    (spaces level) ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    (spaces level) ^ "}"

  | BDCL_abs (code) -> (spaces level) ^ 
   "type " ^ name ^ " = " ^ string_of_string code ^ ";"

  | BDCL_fun (args, result, code) ->
    (spaces level) ^ 
     "fun " ^ name ^ ": " ^ 
     (string_of_btypecode (BTYP_tuple args)) ^ " -> " ^
     (string_of_btypecode result) ^ 
     " = " ^ string_of_string code ^ ";"

  | BDCL_proc (args, code) ->
    (spaces level) ^ 
    "proc " ^ name ^ ": " ^ 
     (string_of_btypecode (BTYP_tuple args)) ^
     " = " ^ string_of_string code ^ ";"

  | BDCL_const (typ, code) ->
    (spaces level) ^ 
     "const " ^ name ^ 
     ": " ^ string_of_btypecode typ ^ 
     " = "^string_of_string code^ ";" 

  | BDCL_function (ps, res,display,exes,_) -> 
    (spaces level) ^ 
    "function " ^ name ^ 
    "("^ (string_of_bparameters dfns ps)^"): "^(string_of_btypecode res)^"\n" 

  | BDCL_procedure (ps,display,exes,_) -> 
    (spaces level) ^ 
    "procedure " ^ name ^ 
    "("^ (string_of_bparameters dfns ps)^")"

  | BDCL_val (ty) ->
    (spaces level) ^ 
    "val " ^ name ^ ": " ^ string_of_btypecode ty ^ ";"

  | BDCL_var (ty) ->
    (spaces level) ^ 
    "var " ^ name ^ ": " ^ string_of_btypecode ty ^ ";"

  | BDCL_val_typeof (e) ->
    (spaces level) ^ 
    "val " ^ name ^ ": typeof(" ^ string_of_expression e ^ ");"

  | BDCL_var_typeof (e) ->
    (spaces level) ^ 
    "var " ^ name ^ ": typeof(" ^ string_of_expression e ^ ");"

and string_of_bbdcl dfns bbdcl index = 
  let name = qualified_name_of_index dfns index in
  let sobt t = string_of_btypecode dfns t in
  match bbdcl with
  | BBDCL_module name_map -> "module " ^ name ^ ";"
  | BBDCL_header s -> "header " ^ string_of_string s
  | BBDCL_function (ps,res,display,es,name_map) ->
    "function " ^ name ^ 
    "("^ (string_of_bparameters dfns ps)^"): "^(sobt res)
    
  | BBDCL_procedure (ps,display,es,name_map) ->
    "procedure " ^ name ^ 
    "("^ (string_of_bparameters dfns ps)^")" ^
    "{\n" ^
    String.concat "\n" (List.map (string_of_bexe dfns 1) es) ^
    "}"

  | BBDCL_val ty ->
    "val " ^ name ^ ": " ^ sobt ty ^ ";"

  | BBDCL_var ty ->
    "var " ^ name ^ ": " ^ sobt ty ^ ";"

  (* binding structures [prolog] *)
  | BBDCL_abs code ->
   "type " ^ name ^ " = " ^ string_of_string code ^ ";"

  | BBDCL_const (ty,code) ->
     "const " ^ name ^ 
     ": " ^ sobt ty ^ 
     " = "^string_of_string code^ ";" 

  | BBDCL_fun (ps,rt,code) ->
     "fun " ^ name ^ ": " ^ 
     (sobt (BTYP_tuple ps)) ^ " -> " ^
     (sobt rt) ^ 
     " = " ^ string_of_string code ^ ";"

  | BBDCL_proc (ps,code) ->
    "proc " ^ name ^ ": " ^ 
     (sobt (BTYP_tuple ps)) ^
     " = " ^ string_of_string code ^ ";"

  | BBDCL_union cs ->
    let string_of_union_component (name,ty) =
      "  " ^ "|" ^name ^ special_string_of_btypecode dfns ty
    in
    "union " ^ name ^ " = " ^
    "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    "}"

  | BBDCL_struct cs ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "struct " ^ name ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"


@h = tangler('src/flx_mtypes.ml')
@select(h)
module VarMap = Map.Make(struct type t = string let compare = compare end);;
type varmap_t = string VarMap.t

module TypecodeSet = Set.Make(
  struct type t = Flx_types.typecode_t let compare = compare end
)
type typecodeset_t = TypecodeSet.t

let typecodeset_of_list x = 
  let rec tsol x = match x with
  | h :: t -> TypecodeSet.add h (tsol t)
  | [] -> TypecodeSet.empty
  in tsol x

let typecodeset_map f x = typecodeset_of_list (List.map f (TypecodeSet.elements x))

@h = tangler('src/flx_mtypes.mli')
@select(h)
module VarMap :
  sig
    type key = string
    and 'a t
    val empty : 'a t
    val add : key:key -> data:'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val mem : key -> 'a t -> bool
    val iter : f:(key:key -> data:'a -> unit) -> 'a t -> unit
    val map : f:('a -> 'b) -> 'a t -> 'b t
    val mapi : f:(key -> 'a -> 'b) -> 'a t -> 'b t
    val fold : f:(key:key -> data:'a -> 'b -> 'b) -> 'a t -> init:'b -> 'b
  end
type varmap_t = string VarMap.t
module TypecodeSet :
  sig
    type elt = Flx_types.typecode_t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : f:(elt -> unit) -> t -> unit
    val fold : f:(elt -> 'a -> 'a) -> t -> init:'a -> 'a
    val for_all : f:(elt -> bool) -> t -> bool
    val exists : f:(elt -> bool) -> t -> bool
    val filter : f:(elt -> bool) -> t -> t
    val partition : f:(elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end
type typecodeset_t = TypecodeSet.t
val typecodeset_of_list : TypecodeSet.elt list -> TypecodeSet.t
val typecodeset_map :
  (TypecodeSet.elt -> TypecodeSet.elt) -> TypecodeSet.t -> TypecodeSet.t

@head(1,'Compile time exceptions')
@python('//')
exceptions = """
exception SyntaxError of string
exception ParseError of string
exception LexError of string
exception Bad_letter_in_identifier of int 
exception TokenError of string
"""
//
@h = tangler('src/flx_exceptions.ml')
@select(h)
@tangle(exceptions)
@h = tangler('src/flx_exceptions.mli')
@select(h)
@tangle(exceptions)

@h = tangler('src/flx_typing.ml')
@select(h)
open Flx_types

(* unbound type *)
let type_of_argtypes ls = match ls with
 | [x] -> x
 | _ -> TYP_tuple ls

let funparamtype x = snd x

module FuntypeSet = Set.Make(
  struct type t=typecode_t let compare = compare end
)

(* bound type! *)
let typeoflist typlist = match typlist with
  | [] -> BTYP_tuple []
  | [t] -> t
  | _ -> BTYP_tuple typlist


@h = tangler('src/flx_typing.mli')
@select(h)
val type_of_argtypes : 
  Flx_types.typecode_t list -> 
  Flx_types.typecode_t
  
val funparamtype : 'a * 'b -> 'b

val typeoflist:
  Flx_types.btypecode_t list ->
  Flx_types.btypecode_t

module FuntypeSet :
  sig
    type elt = Flx_types.typecode_t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : f:(elt -> unit) -> t -> unit
    val fold : f:(elt -> 'a -> 'a) -> t -> init:'a -> 'a
    val for_all : f:(elt -> bool) -> t -> bool
    val exists : f:(elt -> bool) -> t -> bool
    val filter : f:(elt -> bool) -> t -> t
    val partition : f:(elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end

