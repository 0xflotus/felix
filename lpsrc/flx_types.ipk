@head(1,'Utilities')
Generic (non Felix dependent) utilities.
@h = tangler('src/compiler/flxlib/flx_util.mli')
@select(h)
(** Generic utilities *)

(** n spaces 
*)
val spaces : int -> string

(** String.concat sep (map fun lst) 
*)
val catmap : string -> ('a -> string) -> 'a list -> string

(** reverse application *)
val (+>) : 'a -> ('a ->'b) -> 'b

(** hmmm *)
val transpose: 'a list list -> 'a list list

(** last element of list 
*)
val list_last: 'a list -> 'a 

(** position in list of value *)
val list_index: 'a list -> 'a -> int option
val list_assoc_index: ('a * 'b) list -> 'a -> int option

(** forward order map *)
val list_omap: ('a -> 'b) -> 'a list -> 'b list

(** convert exception to option *)
val catch_all : ('a -> 'b) -> 'a -> 'b option

(** test if option not None *)
val is_some: 'a option -> bool

(** list of n integers 0  to n-1 *)
val nlist: int -> int list

(** first n elements of a list *)
val list_prefix: 'a list -> int -> 'a list

(* remaining elements of a list after first n removed,
   the second list must be long enough or an exception is thrown
*)
val list_tail: 'a list -> int -> 'a list

(* the first list with the tail of the second list
   appended. If the second list isn't long enough return
   just the first list (routine cannot fail)
*)
val splice_tail: 'a list -> 'a list -> 'a list

(** synonym for string_of_int *)
val si: int -> string

(** synonym for String.concat *)
val cat: string -> string list -> string

(** synonym for Buffer.add_string *)
val bcat: Buffer.t -> string -> unit

(** make a hashtable from an assoc list *)
val hashtable_of_list:
  ('a * 'b) list ->
  ('a,'b) Hashtbl.t

(** fixpoint combinator *)
val fix:
 (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b

(** add element to unique list *)
val uniq_add: 'a -> 'a list -> 'a list

(** add elements to unique list *)
val uniq_cat: 'a list -> 'a list -> 'a list

(** make a list of unique elements *)
val uniq_list: 'a list -> 'a list

@h = tangler('src/compiler/flxlib/flx_util.ml')
@select(h)
open List
let spaces level = String.make (level*2) ' '
let catmap sep fn ls = String.concat sep (map fn ls)
let (+>) x f = f x (* reverse application *)
let transpose x =
  let dtor ls =
    split (map (fun x -> hd x, tl x) ls)
  in let rec cons ls (h,t) = match hd t with
    | [] -> h :: ls
    | _ -> cons (h :: ls) (dtor t)
  in tl (rev (cons [] ([],x)))

let list_last l = hd (rev l)

let list_prefix lst n =
  let rec aux ol nl n = 
    if n>0 then aux (tl ol) (hd ol :: nl) (n-1)
    else rev nl
  in aux lst [] n

let list_tail lst n = 
  let rec aux ol il n =
    if n > 0 then aux (hd il::ol) (tl il) (n-1)
    else rev ol
  in aux [] lst n

let splice_tail hlst tlst =
  let n = length hlst in
  if n >= length tlst then hlst else
  hlst @ list_tail tlst n

let rec list_index l x = 
 let rec aux l i =
   match l with
   | [] -> None
   | h::t -> 
    if x = h then Some i
    else aux t (i+1)
  in aux l 0

let rec list_assoc_index l x = 
 let rec aux l i =
   match l with
   | [] -> None
   | (h,_)::t -> 
    if x = h then Some i
    else aux t (i+1)
  in aux l 0

let list_omap f ls =
  rev (rev_map f ls)

let catch_all f x = 
  try Some (f x) with _ -> None

let is_some = function | Some _ -> true | None -> false

let nlist n = 
  let lst = ref [] in
  for i = 1 to n do lst := (n-i) :: !lst done;
  !lst

let si = string_of_int
let cat = String.concat
let bcat = Buffer.add_string

let hashtable_of_list lst = 
  let t = Hashtbl.create (length lst) in
  iter
  (fun (k,v) -> Hashtbl.add t k v)
  lst
  ;
  t

let rec fix f x = f (fix f) x

let uniq_add elt lst =
  if mem elt lst then lst else (elt::lst)

let uniq_cat u nu  =
  fold_left 
  (fun l i -> if mem i l then l else i :: l) 
  u
  nu

let uniq_list lst = uniq_cat [] lst

@h = tangler('src/compiler/flxlib/flx_dlst.mli')
@select(h)
type direction = Fwd | Rev
val dir_rev : direction -> direction
type 'a dlst = { dir : direction; lst : 'a list; }
val dfwd : 'a dlst -> 'a list
val drev : 'a dlst -> 'a list
val dlst_fwd : 'a list -> 'a dlst
val dlst_rev : 'a list -> 'a dlst
val dlst_lst : 'a dlst -> 'a list
val dlst_dir : 'a dlst -> direction
val dlst_map : ('a -> 'b) -> 'a dlst -> 'b dlst
val append : 'a dlst -> 'a -> 'a dlst
val prepend : 'a dlst -> 'a -> 'a dlst
val cons : 'a list -> 'a -> 'a list
val concat : 'a dlst -> 'a dlst -> 'a dlst

@h = tangler('src/compiler/flxlib/flx_dlst.ml')
@select(h)
open List
type direction = Fwd | Rev
let dir_rev = function | Fwd -> Rev | Rev->Fwd

type 'a dlst = { dir:direction; lst: 'a list }

let dfwd = function
  | {dir=Fwd; lst=l} -> l
  | {dir=Rev; lst=l} -> rev l

let drev = function
  | {dir=Fwd; lst=l} -> l
  | {dir=Rev; lst=l} -> rev l

let dlst_fwd = function l -> {dir=Fwd; lst=l}
let dlst_rev = function l -> {dir=Rev; lst=l}

let dlst_lst = function {lst=l} -> l
let dlst_dir = function {dir=d} -> d

let dlst_map f {dir=d; lst=l} = {dir=dir_rev d; lst=rev_map f l}

let append = function 
  | {dir=Fwd; lst=l} -> (fun e -> {dir=Rev; lst=e::rev l})
  | {dir=Rev; lst=l} as d -> (fun e -> {d with lst=e::l})

let prepend = function 
  | {dir=Rev; lst=l} -> (function e -> {dir=Fwd; lst=e::rev l})
  | {dir=Fwd; lst=l} as d -> (function e -> {d with lst=e::l})

let cons = function lst -> (function elt -> elt :: lst)

let concat a b = match (a,b) with
  | {dir=Rev; lst=l1}, {dir=Fwd; lst=l2} -> 
    {dir=Rev; lst=fold_left cons l1 l2}

  | {dir=Fwd; lst=l1}, {dir=Fwd; lst=l2} -> 
    {dir=Rev; lst=fold_left cons (rev l1) (rev l2)}

  | {dir=Rev; lst=l1}, {dir=Rev; lst=l2} -> 
    {dir=Rev; lst=fold_left cons l1 (rev l2)}

  | {dir=Fwd; lst=l1}, {dir=Rev; lst=l2} -> 
    {dir=Rev; lst=fold_left cons (rev l1) l2}
  
@head(1,'AST')
@h = tangler('src/compiler/flxlib/flx_ast.mli')
@head(2,'Source Reference')
Provides a reference to the original source.
@select(h)
(** Types used in the Felix compiler *)
open Big_int

(** type of a position in the {e original} sources *)
type srcref = 
  string (* filename *) *
  int (* line number, 1 origin *) *
  int (* starting column, 1 origin *) *
  int (* ending column, 1 origin *)

(** type of a span between two positions in one file*)
type range_srcref =
  string * (* filename *)
  int * (* starting line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int * (* ending line number, 1 origin *)
  int   (* ending column, 1 origin *)

type bigint = big_int

@head(2,'Abstract Syntax Tree')
AST types are nodes of the Abstract Syntax Tree generated by the
parser. 

@head(3,'Names')
A simple name is an identifier, a qualified name is a dot (.) separated list
of instantiated names, and a instantiated name is a simple name optionally
followed by a square bracket enclosed list of type expressions.
@select(h)
type id_t = string
type bid_t = int
type index_map_t = (int,int) Hashtbl.t
type  c_t = [
  | `StrTemplate of string
  | `Str of string
  | `Virtual
  | `Identity
]

type base_type_qual_t = [
  | `Incomplete
  | `Pod
  | `GC_pointer (* this means the type is a pointer the GC must follow *)
]

(** type of a qualified name *)
type qualified_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list 
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_callback of range_srcref * qualified_name_t
  ]

(** type of a suffixed name *)
and suffixed_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list  
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_callback of range_srcref * qualified_name_t
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)  
  ]

(** type of a regular expression *)
and regexp_t =
  [
  | `REGEXP_seq of regexp_t * regexp_t (** concatenation *)
  | `REGEXP_alt of regexp_t * regexp_t (** alternation *)
  | `REGEXP_aster of regexp_t (** Kleene closure *)
  | `REGEXP_name of qualified_name_t (** lookup regular definition *)
  | `REGEXP_string of string  (** concatenation of chars of string *)
  | `REGEXP_epsilon (** epsilon: null string *)
  | `REGEXP_sentinel (** end marker *)
  | `REGEXP_code of expr_t (** associated code *)
  | `REGEXP_group of string * regexp_t (** named group *)
  ]

@head(3,'Type sublanguage')
The encoding '`TYP_void'
is the categorical initial: the type of an empty
union, and the type ordinary procedure types return.
There are no values of this type. 
@select(h)
(** type of a type *)
and typecode_t = 
  [
  | `AST_void of range_srcref                   (** void type *)
  | `AST_name of range_srcref * string * typecode_t list 
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_callback of range_srcref * qualified_name_t
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)  
  | `AST_patvar of range_srcref * string
  | `AST_patany of range_srcref
  | `TYP_tuple of typecode_t list               (** product type *)
  | `TYP_unitsum of int                         (** sum of units  *)
  | `TYP_sum of typecode_t list                 (** numbered sum type *)
  | `TYP_intersect of typecode_t list           (** intersection type *)
  | `TYP_record of (string * typecode_t) list   (** anon product *)
  | `TYP_variant of (string * typecode_t) list  (** anon sum *)
  | `TYP_function of typecode_t * typecode_t    (** function type *)
  | `TYP_cfunction of typecode_t * typecode_t   (** C function type *)
  | `TYP_pointer of typecode_t                  (** pointer type *)
  | `TYP_array of typecode_t * typecode_t       (** array type base ^ index *)
  | `TYP_as of typecode_t * string              (** fixpoint *)
  | `TYP_typeof of expr_t                       (** typeof *)
  | `TYP_var of int                             (** unknown type *)
  | `TYP_none                                   (** unspecified *)
  | `TYP_ellipsis                               (** ... for varargs *)
  | `TYP_lvalue of typecode_t                   (** ... lvalue annotation *)
  | `TYP_isin of typecode_t * typecode_t        (** typeset membership *)

  (* sets of types *)
  | `TYP_typeset of typecode_t list             (** discrete set of types *)
  | `TYP_setunion of typecode_t list            (** union of typesets *)
  | `TYP_setintersection of typecode_t list     (** intersection of typesets *)

  (* dualizer *)
  | `TYP_dual of typecode_t                     (** dual *)

  (* destructors *)
  | `TYP_dom of typecode_t                      (** function domain extractor *)
  | `TYP_cod of typecode_t                      (** function codomain extractor *)
  | `TYP_proj of int * typecode_t               (** tuple projection *)
  | `TYP_case_arg of int * typecode_t           (** argument of n'th variant *)

  | `TYP_apply of typecode_t * typecode_t       (** type function application *)
  | `TYP_typefun of simple_parameter_t list * typecode_t * typecode_t
                                                (** type lambda *)
  | `TYP_type                                   (** meta type of a type *)
  | `TYP_type_tuple of typecode_t list          (** meta type product *)

  | `TYP_type_match of typecode_t * (typecode_t * typecode_t) list

  | `TYP_glr_attr_type of qualified_name_t

  (* Barry Jay pattern calculus case *)
  | `TYP_case of typecode_t * string list * typecode_t

  | `TYP_lift of typecode_t                      (** lift type to metatype *)
  ]

and tpattern_t =
  [
  |  `TPAT_function of tpattern_t * tpattern_t
  |  `TPAT_sum of tpattern_t list
  |  `TPAT_tuple of tpattern_t list
  |  `TPAT_pointer of tpattern_t
  |  `TPAT_void
  |  `TPAT_var of string
  |  `TPAT_name of string * tpattern_t list
  |  `TPAT_as of tpattern_t * string
  |  `TPAT_any
  |  `TPAT_unitsum of int
  |  `TPAT_type_tuple of tpattern_t list
  ]

and raw_typeclass_insts_t = qualified_name_t list
and vs_aux_t = { 
  raw_type_constraint:typecode_t; 
  raw_typeclass_reqs: raw_typeclass_insts_t 
}

and plain_vs_list_t = (id_t * typecode_t) list
and plain_ivs_list_t = (id_t * int * typecode_t) list 
and vs_list_t = plain_vs_list_t *  vs_aux_t
and ivs_list_t = plain_ivs_list_t * vs_aux_t

@head(3,'Literals')
Literals recognized by the lexer.
@select(h)
and literal_t =
  [
  | `AST_int of string * bigint
  | `AST_string of string
  | `AST_cstring of string
  | `AST_wstring of string
  | `AST_ustring of string
  | `AST_float of string * string
  ]

@head(3,'Expressions')
Raw expression terms.

@select(h)
and axiom_kind_t = [`Axiom | `Lemma ]
and axiom_method_t = [`Predicate of expr_t | `Equation of expr_t * expr_t]
and expr_t =
  [
  | `AST_interpolate of range_srcref * string
  | `AST_vsprintf of range_srcref * string
  | `AST_map of range_srcref * expr_t * expr_t
  | `AST_noexpand of range_srcref * expr_t
  | `AST_name of range_srcref * string * typecode_t list 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_apply of range_srcref * (expr_t * expr_t)
  | `AST_tuple of range_srcref * expr_t list
  | `AST_record of range_srcref * (string * expr_t) list
  | `AST_record_type of range_srcref * (string * typecode_t) list
  | `AST_variant of range_srcref * (string * expr_t) 
  | `AST_variant_type of range_srcref * (string * typecode_t) list
  | `AST_arrayof of range_srcref * expr_t list
  | `AST_coercion of range_srcref * (expr_t * typecode_t)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t) 

  | `AST_patvar of range_srcref * string
  | `AST_patany of range_srcref

  | `AST_void of range_srcref
  | `AST_ellipsis of range_srcref
  | `AST_product of range_srcref * expr_t list
  | `AST_sum of range_srcref * expr_t list
  | `AST_intersect of range_srcref * expr_t list
  | `AST_isin of range_srcref * (expr_t * expr_t)
  | `AST_setintersection of range_srcref * expr_t list
  | `AST_setunion of range_srcref * expr_t list
  | `AST_orlist of range_srcref * expr_t list
  | `AST_andlist of range_srcref * expr_t list
  | `AST_arrow of range_srcref * (expr_t * expr_t)
  | `AST_longarrow of range_srcref * (expr_t * expr_t)
  | `AST_superscript of range_srcref * (expr_t * expr_t)

  | `AST_literal of range_srcref * literal_t
  | `AST_deref of range_srcref * expr_t
  | `AST_ref of range_srcref * expr_t
  | `AST_new of range_srcref * expr_t
  | `AST_lvalue of range_srcref * expr_t
  | `AST_callback of range_srcref * qualified_name_t
  | `AST_method_apply of range_srcref * (id_t * expr_t * typecode_t list)
  (*
  | `AST_dot of range_srcref * (expr_t * id_t * typecode_t list)
  *)
  | `AST_dot of range_srcref * (expr_t * expr_t)
  | `AST_lambda of range_srcref * (vs_list_t * params_t list * typecode_t * statement_t list)

  (* this boolean expression checks its argument is 
     the nominated union variant .. not a very good name for it
  *)
  | `AST_match_ctor of range_srcref * (qualified_name_t * expr_t)
  
  (* this boolean expression checks its argument is the nominate
     sum variant
  *)
  | `AST_match_case of range_srcref * (int * expr_t)
  
  (* this extracts the argument of a named union variant -- unsafe *)
  | `AST_ctor_arg of range_srcref * (qualified_name_t * expr_t)
  
  (* this extracts the argument of a number sum variant -- unsafe *)
  | `AST_case_arg of range_srcref * (int * expr_t)

  (* this just returns an integer equal to union or sum index *)
  | `AST_case_index of range_srcref * expr_t (* the zero origin variant index *)

  | `AST_letin of range_srcref * (pattern_t * expr_t * expr_t)

  | `AST_get_n of range_srcref * (int * expr_t) (* get n'th component of a tuple *)
  | `AST_get_named_variable of range_srcref * (string * expr_t) (* get named component of a class or record *)
  | `AST_get_named_method of range_srcref * (string * int * typecode_t list * expr_t ) (* get named component of a class *)
  | `AST_as of range_srcref * (expr_t * string)
  | `AST_match of range_srcref * (expr_t * (pattern_t * expr_t) list)
  | `AST_parse of range_srcref * expr_t * (range_srcref * production_t * expr_t) list
  | `AST_sparse of range_srcref * expr_t * string * int list

  | `AST_regmatch of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  | `AST_string_regmatch of range_srcref * (expr_t * (regexp_t * expr_t) list)
  | `AST_reglex of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  | `AST_typeof of range_srcref * expr_t
  | `AST_lift of range_srcref * expr_t
  | `AST_cond of range_srcref * (expr_t * expr_t * expr_t)

  | `AST_expr of range_srcref * string * typecode_t

  | `AST_type_match of range_srcref * (typecode_t * (typecode_t * typecode_t) list)

  | `AST_macro_ctor of range_srcref * (string * expr_t)
  | `AST_macro_statements of range_srcref * statement_t list

  | `AST_case of range_srcref * expr_t * string list * expr_t
  | `AST_user_expr of range_srcref * string * ast_term_t
  ]

@head(3,'Pattern')
Patterns; used for matching variants in match statements.
@select(h)
and float_pat = 
  | Float_plus of string * string (** type, value *)
  | Float_minus of string * string
  | Float_inf  (** infinity *)
  | Float_minus_inf (** negative infinity *)

and pattern_t =
  [
  | `PAT_nan of range_srcref
  | `PAT_none of range_srcref

  (* constants *)
  | `PAT_int of range_srcref * string * bigint
  | `PAT_string of range_srcref * string

  (* ranges *)
  | `PAT_int_range of range_srcref * string * bigint * string * bigint
  | `PAT_string_range of range_srcref * string * string
  | `PAT_float_range of range_srcref * float_pat * float_pat 

  (* other *)
  | `PAT_coercion of range_srcref * pattern_t * typecode_t
  
  | `PAT_name of range_srcref * id_t 
  | `PAT_tuple of range_srcref * pattern_t list
  | `PAT_any of range_srcref 
  | `PAT_regexp of range_srcref * string * id_t list 
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | `PAT_const_ctor of range_srcref * qualified_name_t
  | `PAT_nonconst_ctor of range_srcref * qualified_name_t * pattern_t
  | `PAT_as of range_srcref * pattern_t * id_t
  | `PAT_when of range_srcref * pattern_t * expr_t
  | `PAT_record of range_srcref * (id_t * pattern_t) list
  ]

@head(3,'Statements')
Statements; that is, the procedural sequence control system.
@select(h)
and param_kind_t = [`PVal | `PVar | `PFun | `PRef ]
and simple_parameter_t = id_t * typecode_t
and parameter_t = param_kind_t * id_t * typecode_t * expr_t option
and macro_parameter_type_t = 
  | Ident 
  | Expr 
  | Stmt
and macro_parameter_t = id_t * macro_parameter_type_t
and lvalue_t = [ 
  | `Val of range_srcref * string
  | `Var of range_srcref * string
  | `Name of range_srcref * string
  | `Skip of range_srcref 
  | `List of tlvalue_t list
  | `Expr of range_srcref * expr_t
]
and tlvalue_t = lvalue_t * typecode_t option

and funkind_t = [
  | `Object 
  | `Function 
  | `CFunction 
  | `InlineFunction 
  | `NoInlineFunction
  | `Virtual
  | `Ctor
  | `Generator
]

and property_t = [
  | `Recursive 
  | `Inline 
  | `NoInline 
  | `Inlining_started
  | `Inlining_complete
  | `Generated of string
  | `Heap_closure        (* a heaped closure is formed *)
  | `Explicit_closure    (* explicit closure expression *)
  | `Stackable           (* closure can be created on stack *)
  | `Stack_closure       (* a stacked closure is formed *)
  | `Unstackable         (* closure cannot be created on stack *)
  | `Pure                (* closure not required by self *)
  | `Uses_global_var     (* a global variable is explicitly used *)
  | `Ctor                (* Class constructor procedure *)
  | `Generator           (* Generator: fun with internal state *)
  | `Yields              (* Yielding generator *)
  | `Cfun                (* C function *)

  (* one of the below must be set before code generation *)
  | `Requires_ptf        (* a pointer to thread frame is needed *)
  | `Not_requires_ptf    (* no pointer to thread frame is needed *)

  | `Uses_gc             (* requires gc locally *)
  | `Virtual             (* interface in a typeclass *)
]

and type_qual_t = [
  | base_type_qual_t
  | `Raw_needs_shape of typecode_t
]

and requirement_t = [
  | `Body_req of c_t
  | `Header_req of c_t
  | `Named_req of qualified_name_t
  | `Property_req of string
  | `Package_req of c_t
]

and ikind_t = [
  | `Header
  | `Body
  | `Package
] 

and raw_req_expr_t =
[
  | `RREQ_atom of requirement_t 
  | `RREQ_or of raw_req_expr_t * raw_req_expr_t
  | `RREQ_and of raw_req_expr_t * raw_req_expr_t
  | `RREQ_true
  | `RREQ_false
]

and named_req_expr_t = 
[
  | `NREQ_atom of qualified_name_t
  | `NREQ_or of named_req_expr_t * named_req_expr_t
  | `NREQ_and of named_req_expr_t * named_req_expr_t
  | `NREQ_true
  | `NREQ_false
]

and prec_t = string
and glr_term_t = 
[
  | `GLR_name of qualified_name_t
  | `GLR_opt of glr_term_t
  | `GLR_ast of glr_term_t
  | `GLR_plus of glr_term_t
  | `GLR_alt of glr_term_t list
  | `GLR_seq of glr_term_t list
]

and glr_entry_t = string option * glr_term_t
and production_t = glr_entry_t list

and reduced_glr_entry_t = string option * qualified_name_t
and reduced_production_t = reduced_glr_entry_t list
and params_t = parameter_t list * expr_t option (* second arg is a constraint *)
and class_member_t = [
  | `MemberVal of id_t * typecode_t * c_t option
  | `MemberVar of id_t * typecode_t * c_t option
  | `MemberFun of id_t * int option * vs_list_t * typecode_t * c_t option
  | `MemberProc of id_t * int option * vs_list_t * typecode_t * c_t option
  | `MemberCtor of id_t * int option * typecode_t * c_t option
]

and ast_term_t = 
  [
  | `Expression_term of expr_t
  | `Statement_term of statement_t
  | `Statements_term of statement_t list
  | `Identifier_term of string
  | `Keyword_term of string
  | `Apply_term of ast_term_t * ast_term_t list
  ]

and statement_t =
  [ 
  | `AST_cparse of range_srcref * string
  | `AST_include of range_srcref * string 
  | `AST_open of range_srcref * vs_list_t * qualified_name_t
  | `AST_inject_module of range_srcref * qualified_name_t
  | `AST_use of range_srcref * id_t * qualified_name_t
  | `AST_comment of range_srcref * string (* for documenting generated code *)
  (*
  | `AST_public of range_srcref * string * statement_t
  *)
  | `AST_private of range_srcref * statement_t

  (* definitions *)
  | `AST_reduce of range_srcref * id_t * vs_list_t * simple_parameter_t list * expr_t * expr_t 
  | `AST_axiom of range_srcref * id_t * vs_list_t * params_t * axiom_method_t
  | `AST_lemma of range_srcref * id_t * vs_list_t * params_t * axiom_method_t
  | `AST_function of range_srcref * id_t * vs_list_t * params_t * (typecode_t * expr_t option) * property_t list * statement_t list
  | `AST_curry of range_srcref * id_t * vs_list_t * params_t list * (typecode_t * expr_t option) * funkind_t * statement_t list
  | `AST_object of range_srcref * id_t * vs_list_t * params_t * statement_t list
  | `AST_regdef of range_srcref * string * regexp_t
  | `AST_glr of range_srcref * string * typecode_t * (range_srcref * production_t * expr_t) list
  
  (* macros *)
  | `AST_macro_name of range_srcref * id_t * id_t 
  | `AST_macro_names of range_srcref * id_t * id_t list
  | `AST_expr_macro of range_srcref * id_t * macro_parameter_t list * expr_t
  | `AST_stmt_macro of range_srcref * id_t * macro_parameter_t list * statement_t list
  | `AST_macro_block of range_srcref * statement_t list
  | `AST_macro_val  of range_srcref * id_t list * expr_t
  | `AST_macro_vals  of range_srcref * id_t * expr_t list
  | `AST_macro_var  of range_srcref * id_t list * expr_t
  | `AST_macro_assign of range_srcref * id_t list * expr_t
  | `AST_macro_forget of range_srcref * id_t list
  | `AST_macro_label of range_srcref * id_t
  | `AST_macro_goto of range_srcref * id_t
  | `AST_macro_ifgoto of range_srcref * expr_t * id_t
  | `AST_macro_proc_return of range_srcref

  (* type macros *)
  | `AST_macro_ifor of range_srcref * id_t * id_t list * statement_t list
  | `AST_macro_vfor of range_srcref * id_t list * expr_t * statement_t list

  (* composition of statements: note NOT A BLOCK *)
  | `AST_seq of range_srcref * statement_t list

  (* types *)
  | `AST_union of range_srcref * id_t * vs_list_t * (id_t * int option * vs_list_t * typecode_t) list
  | `AST_struct of range_srcref * id_t * vs_list_t * (id_t * typecode_t) list
  | `AST_cstruct of range_srcref * id_t * vs_list_t * (id_t * typecode_t) list
  | `AST_cclass of range_srcref * id_t * vs_list_t * class_member_t list
  | `AST_class of range_srcref * id_t * vs_list_t * statement_t list
  | `AST_type_alias of range_srcref * id_t * vs_list_t * typecode_t
  | `AST_inherit of range_srcref * id_t * vs_list_t * qualified_name_t
  | `AST_inherit_fun of range_srcref * id_t * vs_list_t * qualified_name_t
  
  (* variables *)
  | `AST_val_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
  | `AST_lazy_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
  | `AST_var_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
  | `AST_ref_decl of range_srcref * id_t * vs_list_t * typecode_t option * expr_t option
 
  (* module system *)
  | `AST_untyped_module of range_srcref * id_t * vs_list_t * statement_t list  
  | `AST_namespace of range_srcref * id_t * vs_list_t * statement_t list  
  | `AST_typeclass of range_srcref * id_t * vs_list_t * statement_t list
  | `AST_instance of range_srcref * vs_list_t * qualified_name_t * statement_t list
 
  (* control structures: primitives *)
  | `AST_label of range_srcref * id_t
  (*
  | `AST_whilst of range_srcref * expr_t * statement_t list
  | `AST_until of range_srcref * expr_t * statement_t list
  *)
  | `AST_goto of range_srcref * id_t 
  | `AST_ifgoto of range_srcref * expr_t *id_t
  | `AST_ifreturn of range_srcref * expr_t
  | `AST_ifdo of range_srcref * expr_t * statement_t list * statement_t list
  | `AST_ifnotgoto of range_srcref * expr_t * id_t
  | `AST_call of range_srcref * expr_t * expr_t 
  | `AST_assign of range_srcref * string * tlvalue_t * expr_t 
  | `AST_cassign of range_srcref * expr_t * expr_t 
  | `AST_jump of range_srcref * expr_t * expr_t 
  | `AST_loop of range_srcref * id_t * expr_t 
  | `AST_svc of range_srcref * id_t
  | `AST_fun_return of range_srcref * expr_t
  | `AST_yield of range_srcref * expr_t
  | `AST_proc_return of range_srcref 
  | `AST_halt of range_srcref  * string
  | `AST_trace of range_srcref  * id_t * string
  | `AST_nop of range_srcref * string
  | `AST_assert of range_srcref * expr_t
  | `AST_apply_ctor of range_srcref * id_t * expr_t * expr_t
  | `AST_init of range_srcref * id_t * expr_t

  | `AST_newtype of range_srcref * id_t * vs_list_t * typecode_t

  (* binding structures [prolog] *)
  | `AST_abs_decl of range_srcref * id_t * vs_list_t * type_qual_t list * c_t * raw_req_expr_t
  | `AST_ctypes of range_srcref * (srcref * id_t) list * type_qual_t list  * raw_req_expr_t 
  | `AST_const_decl of range_srcref * id_t * vs_list_t * typecode_t * c_t * raw_req_expr_t
  | `AST_fun_decl of range_srcref * id_t * vs_list_t * typecode_t list * typecode_t * c_t * raw_req_expr_t * prec_t
  | `AST_callback_decl of range_srcref * id_t * typecode_t list * typecode_t * raw_req_expr_t
  (* embedding *)
  | `AST_insert of range_srcref * id_t * vs_list_t * c_t * ikind_t  * raw_req_expr_t
  | `AST_code of range_srcref * c_t
  | `AST_noreturn_code of range_srcref * c_t

  | `AST_export_fun of range_srcref * suffixed_name_t * string
  | `AST_export_type of range_srcref * typecode_t * string

  | `AST_user_statement of range_srcref * string * ast_term_t
  | `AST_scheme_string of range_srcref * string 
  ]


and exe_t =
  [
  | `EXE_code of c_t (* for inline C++ code *)
  | `EXE_noreturn_code of c_t (* for inline C++ code *)
  | `EXE_comment of string (* for documenting generated code *)
  | `EXE_label of string (* for internal use only *)
  | `EXE_goto of string  (* for internal use only *)
  | `EXE_ifgoto of expr_t * string  (* for internal use only *)
  | `EXE_ifnotgoto of expr_t * string  (* for internal use only *)
  | `EXE_call of expr_t * expr_t 
  | `EXE_jump of expr_t * expr_t 
  | `EXE_loop of id_t * expr_t 
  | `EXE_svc of id_t
  | `EXE_fun_return of expr_t
  | `EXE_yield of expr_t
  | `EXE_proc_return
  | `EXE_halt of string
  | `EXE_trace of id_t * string
  | `EXE_nop of string
  | `EXE_init of id_t * expr_t 
  | `EXE_iinit of (id_t * int) * expr_t 
  | `EXE_assign of expr_t * expr_t 
  | `EXE_assert of expr_t
  | `EXE_apply_ctor of id_t * expr_t * expr_t
  ]

type sexe_t = range_srcref * exe_t

@doc()
The whole of a compilation unit, this is the data structure
returned by parsing a whole file.
@select(h)
type compilation_unit_t = statement_t list


@head(1,'Types')
@h = tangler('src/compiler/flxlib/flx_types.mli')
These files declare the main data structures used by the compiler,
and provide routines to dump them to a string for debugging purposes.

@head(2,'Generic partial ordering comparison result')
@select(h)
open Flx_mtypes1

type partial_order_result_t = 
[
  | `Less 
  | `Equal 
  | `Greater 
  | `Incomparable
]


open Flx_ast

@head(3,'Pattern extractor')
This type is used to extract components of a value,
corresponding to a match.
@select(h)
type dir_t =
  | DIR_open of ivs_list_t * qualified_name_t
  | DIR_inject_module of qualified_name_t
  | DIR_use of id_t * qualified_name_t

type dcl_t = 
  [

  (* data structures *)
  | `DCL_axiom of       params_t * axiom_method_t
  | `DCL_lemma of       params_t * axiom_method_t
  | `DCL_reduce of       simple_parameter_t list * expr_t * expr_t
  | `DCL_function of     params_t * typecode_t * property_t list * asm_t list
  | `DCL_union of        (id_t * int option * vs_list_t * typecode_t) list
  | `DCL_struct of       (id_t * typecode_t) list
  | `DCL_cstruct of      (id_t * typecode_t) list
  | `DCL_cclass of       class_member_t list
  | `DCL_typeclass of    asm_t list
  | `DCL_match_check of pattern_t * (string * int)
  | `DCL_match_handler of pattern_t * (string * int) * asm_t list
  | `DCL_glr of          typecode_t * (reduced_production_t * expr_t)
 
  (* variables *)
  | `DCL_val of          typecode_t
  | `DCL_var of          typecode_t
  | `DCL_lazy of          typecode_t * expr_t
  | `DCL_ref of          typecode_t
  | `DCL_type_alias of   typecode_t
  | `DCL_inherit of   qualified_name_t
  | `DCL_inherit_fun of   qualified_name_t

  (* module system *)
  | `DCL_module of       asm_t list  
  | `DCL_class of        asm_t list  
  | `DCL_instance of     qualified_name_t * asm_t list  

  (* binding structures [prolog] *)
  | `DCL_newtype of     typecode_t
  | `DCL_abs of         type_qual_t list * c_t * named_req_expr_t
  | `DCL_const of       property_t list * typecode_t * c_t * named_req_expr_t
  | `DCL_fun of         property_t list * typecode_t list * typecode_t * c_t * named_req_expr_t * prec_t
  | `DCL_callback of    property_t list * typecode_t list * typecode_t * named_req_expr_t 
  | `DCL_insert of      c_t * ikind_t * named_req_expr_t
  | `DCL_regdef of      regexp_t
  | `DCL_regmatch of    (regexp_t * expr_t) list
  | `DCL_reglex of      (regexp_t * expr_t) list
  ]

and access_t = [`Private | `Public ]

and asm_t = 
  [ 
  | `Exe of range_srcref * exe_t 
  | `Dcl of range_srcref * id_t * int option * access_t * vs_list_t * dcl_t 
  | `Iface of range_srcref * iface_t
  | `Dir of dir_t
  ]
 
and iface_t =
  [
  | `IFACE_export_fun of suffixed_name_t * string
  | `IFACE_export_type of typecode_t * string
  ]

(** value typing *)
type 't b0typecode_t' = 
  [
  | `BTYP_inst of bid_t * 't list 
  | `BTYP_tuple of 't list         
  | `BTYP_record of (string * 't) list         
  | `BTYP_variant of (string * 't) list         
  | `BTYP_unitsum of int
  | `BTYP_sum of 't list 
  | `BTYP_function of 't * 't
  | `BTYP_cfunction of 't * 't
  | `BTYP_pointer  of 't 
  | `BTYP_lvalue  of 't 
  | `BTYP_array of 't * 't 
  | `BTYP_void                       
  | `BTYP_fix of int      
  | `BTYP_intersect of 't list (** intersection type *)
  ]

type 't btpattern_t' = {
  pattern: 't;
  pattern_vars: IntSet.t; (* pattern type variables, including 'any' vars *)
  assignments : (int * 't) list (* assignments for 'as' vars *)
}


(** meta typing *)
type 't b1typecode_t' =
  [
  | `BTYP_var of int * 't
  | `BTYP_apply of 't * 't 
  | `BTYP_typefun of (int * 't) list * 't * 't
  | `BTYP_type of int
  | `BTYP_type_tuple of 't list
  | `BTYP_type_match of 't * ('t btpattern_t' * 't) list

  (* type sets *)
  | `BTYP_typeset of 't list (** open union *)
  | `BTYP_typesetunion of 't list (** open union *)
  | `BTYP_typesetintersection of 't list (** open union *)

  (* Barry Jay pattern calculus *)
  | `BTYP_case of 't * IntSet.t * 't

  | `BTYP_lift of 't (* lift type to metatype *)
  ]

(** general typing *)
type 't btypecode_t' =
  [
  | 't b0typecode_t'
  | 't b1typecode_t'
  ]

type b0typecode_t = 't b0typecode_t' as 't
type btypecode_t = 't btypecode_t' as 't
type btpattern_t = btypecode_t btpattern_t'

type entry_kind_t = { 
  base_sym:int;                 (* the function *)
  spec_vs:(string * int) list;  (* the type variables of the specialisation *)
  sub_ts:btypecode_t list      (* types to replace the old type variables 
                               expressed in terms of the new ones 
                            *)
}    

and entry_set_t =
  [
  | `FunctionEntry of entry_kind_t list
  | `NonFunctionEntry of entry_kind_t
  ]
  
and module_rep_t = 
  | Simple_module of bid_t * typecode_t list * name_map_t * dir_t list

and name_map_t = (string, entry_set_t) Hashtbl.t


type biface_t =
  [
  | `BIFACE_export_fun of range_srcref * bid_t * string
  | `BIFACE_export_type of range_srcref * btypecode_t * string
  ]

type regular_args_t =
    int list * (* alphabet *)
    int *      (* state count *)
    (int, tbexpr_t) Hashtbl.t * (* state->expression map *)
    (int * int, int) Hashtbl.t (* transition matrix *)

and bexe_t =
  [
  | `BEXE_label of range_srcref * string
  | `BEXE_comment of range_srcref * string (* for documenting generated code *)
  | `BEXE_halt of range_srcref * string  (* for internal use only *)
  | `BEXE_trace of range_srcref * string * string  (* for internal use only *)
  | `BEXE_goto of range_srcref * string  (* for internal use only *)
  | `BEXE_ifgoto of range_srcref * tbexpr_t * string  (* for internal use only *)
  | `BEXE_ifnotgoto of range_srcref * tbexpr_t * string  (* for internal use only *)
  | `BEXE_call of range_srcref * tbexpr_t * tbexpr_t 
  | `BEXE_call_direct of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_call_method_direct of range_srcref * tbexpr_t * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_call_method_stack of range_srcref * tbexpr_t * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_call_stack of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_call_prim of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_jump of range_srcref * tbexpr_t * tbexpr_t 
  | `BEXE_jump_direct of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_loop of range_srcref * int * tbexpr_t 
  | `BEXE_svc of range_srcref * bid_t
  | `BEXE_fun_return of range_srcref * tbexpr_t
  | `BEXE_yield of range_srcref * tbexpr_t
  | `BEXE_proc_return of range_srcref   
  | `BEXE_nop of range_srcref * string
  | `BEXE_code of range_srcref * c_t
  | `BEXE_nonreturn_code of range_srcref * c_t
  | `BEXE_assign of range_srcref * tbexpr_t * tbexpr_t 
  | `BEXE_init of range_srcref * bid_t * tbexpr_t 
  | `BEXE_begin
  | `BEXE_end
  | `BEXE_assert of range_srcref * tbexpr_t
  | `BEXE_assert2 of range_srcref * range_srcref * tbexpr_t option * tbexpr_t
  | `BEXE_axiom_check of range_srcref * tbexpr_t

  | `BEXE_apply_ctor of range_srcref * bid_t * bid_t * btypecode_t list * bid_t * tbexpr_t
  | `BEXE_apply_ctor_stack of range_srcref * bid_t * bid_t * btypecode_t list * bid_t * tbexpr_t
    (* For classes! Note this case works as so: 
     * arg0 denotes a variable to store the closure pointer in
     * arg1 and 2 denote the closure to be created, 
     * arg3 and 4 s a procedure call executed in the 
       context of the closure to initialise the frame. 
     * The expression just returns the initialised closure. 
     * This is rougly equivalent to (in Ocaml notation):
     
      let frame = closure (arg1,arg2) in
      closure(arg3,arg2).call(arg4).run();
      closure

      except that the second closure create takes
      the first as its parent. This combinator is
      needed to intervene in the construction of
      the display (list of environment pointers)
      to ensure that the first closure is passed
      as a display variable to the second, so that
      the class constructor can refer to the class object
      as its parent, that is, so references to member variables
      resolve correctly to the instance object.

      NOTE: the stack version applies to the constructor procedure
      NOT the class, which is always heaped
    *)
   ]

and bexpr_t =
  [
  | `BEXPR_parse of tbexpr_t * int list
  | `BEXPR_deref of tbexpr_t
  | `BEXPR_name of bid_t * btypecode_t list
  | `BEXPR_ref of bid_t * btypecode_t list
  | `BEXPR_new of tbexpr_t 
  | `BEXPR_literal of literal_t 
  | `BEXPR_apply of tbexpr_t * tbexpr_t 
  | `BEXPR_apply_prim of bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_direct of bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_stack of bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_method_direct of tbexpr_t * bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_method_stack of tbexpr_t * bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_struct of bid_t * btypecode_t list * tbexpr_t 
   
  | `BEXPR_tuple of tbexpr_t list
  | `BEXPR_record of (string * tbexpr_t) list
  | `BEXPR_variant of string * tbexpr_t
  | `BEXPR_get_n of int * tbexpr_t (* tuple projection *)
  | `BEXPR_get_named of int * tbexpr_t (* struct/class projection *)
  | `BEXPR_closure of bid_t * btypecode_t list
  | `BEXPR_method_closure of tbexpr_t * bid_t * btypecode_t list
  | `BEXPR_case of int * btypecode_t
  | `BEXPR_match_case of int * tbexpr_t
  | `BEXPR_case_arg of int * tbexpr_t
  | `BEXPR_case_index of tbexpr_t
  | `BEXPR_expr of string * btypecode_t
  | `BEXPR_range_check of tbexpr_t * tbexpr_t * tbexpr_t
  | `BEXPR_coerce of tbexpr_t * btypecode_t
  ]

and tbexpr_t = bexpr_t * btypecode_t

and glr_symbol_t = [`Term of int | `Nonterm of int list]
and bglr_entry_t = string option * glr_symbol_t 
and bproduction_t = bglr_entry_t list

and bparameter_t = {pkind:param_kind_t; pid:string; pindex:int; ptyp:btypecode_t}
and breqs_t = (bid_t * btypecode_t list) list
and bvs_t = (string * int) list
and bparams_t = bparameter_t list * tbexpr_t option
and bclass_member_t = [
  | `BMemberVal of id_t * btypecode_t
  | `BMemberVar of id_t * btypecode_t
  | `BMemberFun of id_t * bvs_t * btypecode_t
  | `BMemberProc of id_t * bvs_t * btypecode_t
  | `BMemberCtor of id_t * btypecode_t
]

and btype_qual_t = [
  | base_type_qual_t
  | `Bound_needs_shape of btypecode_t
]

and bbdcl_t = 
  [
  | `BBDCL_function of   property_t list * bvs_t * bparams_t * btypecode_t * bexe_t list
  | `BBDCL_procedure of  property_t list * bvs_t * bparams_t * bexe_t list
  | `BBDCL_val of        bvs_t * btypecode_t
  | `BBDCL_var of        bvs_t * btypecode_t
  | `BBDCL_ref of        bvs_t * btypecode_t
  | `BBDCL_tmp of        bvs_t * btypecode_t
  | `BBDCL_glr of        property_t list * bvs_t * btypecode_t * (bproduction_t * bexe_t list)
  | `BBDCL_regmatch of   property_t list * bvs_t * bparams_t * btypecode_t * regular_args_t
  | `BBDCL_reglex of     property_t list * bvs_t * bparams_t * int * btypecode_t * regular_args_t

  (* binding structures [prolog] *)
  | `BBDCL_newtype of    bvs_t * btypecode_t
  | `BBDCL_abs of        bvs_t * btype_qual_t list * c_t * breqs_t
  | `BBDCL_const of      property_t list * bvs_t * btypecode_t * c_t * breqs_t
  | `BBDCL_fun of        property_t list * bvs_t * btypecode_t list * btypecode_t * c_t  * breqs_t * prec_t
  | `BBDCL_callback of   property_t list * bvs_t * btypecode_t list * btypecode_t list * int * btypecode_t * breqs_t * prec_t
  | `BBDCL_proc of       property_t list * bvs_t * btypecode_t list * c_t  * breqs_t
  | `BBDCL_insert of     bvs_t * c_t * ikind_t * breqs_t
  
  | `BBDCL_union of      bvs_t * (id_t * int * btypecode_t) list
  | `BBDCL_struct of     bvs_t * (id_t * btypecode_t) list
  | `BBDCL_cstruct of     bvs_t * (id_t * btypecode_t) list
  | `BBDCL_cclass of     bvs_t * bclass_member_t list
  | `BBDCL_class of      property_t list * bvs_t
  | `BBDCL_typeclass of  property_t list * bvs_t
  | `BBDCL_instance of   property_t list * 
                         bvs_t * 
                         btypecode_t (* constraint *) * 
                         bid_t * 
                         btypecode_t list
  | `BBDCL_nonconst_ctor of bvs_t * int * btypecode_t * int * btypecode_t *
                         bvs_t * btypecode_t (* existentials and constraint for GADTs *)
  ]

and baxiom_method_t = [`BPredicate of tbexpr_t | `BEquation of tbexpr_t * tbexpr_t]
and reduction_t = id_t * bvs_t * bparameter_t list * tbexpr_t * tbexpr_t
and axiom_t = id_t * range_srcref * int option * axiom_kind_t * bvs_t * bparams_t * baxiom_method_t

and typevarmap_t = (int,btypecode_t) Hashtbl.t

type env_t = (bid_t * id_t * name_map_t * name_map_t list) list 

type symbol_definition_t =
  [
  | `SYMDEF_newtype of typecode_t
  | `SYMDEF_abs of type_qual_t list * c_t * named_req_expr_t
  | `SYMDEF_regdef of regexp_t
  | `SYMDEF_regmatch of params_t * (regexp_t * expr_t) list
  | `SYMDEF_reglex of params_t * int * (regexp_t * expr_t) list
  | `SYMDEF_glr of typecode_t * (reduced_production_t * sexe_t list) 

  | `SYMDEF_parameter of  param_kind_t * typecode_t
  | `SYMDEF_typevar of typecode_t (* usually type TYPE *)

  | `SYMDEF_axiom of params_t * axiom_method_t
  | `SYMDEF_lemma of params_t * axiom_method_t
  | `SYMDEF_reduce of parameter_t list * expr_t * expr_t
  | `SYMDEF_function of params_t * typecode_t * property_t list * sexe_t list

  | `SYMDEF_match_check of  pattern_t * (string *int)
  | `SYMDEF_module
  | `SYMDEF_class

  | `SYMDEF_const_ctor of int * typecode_t * int * ivs_list_t
  | `SYMDEF_nonconst_ctor of int * typecode_t * int * ivs_list_t * typecode_t

  | `SYMDEF_const of property_t list * typecode_t * c_t * named_req_expr_t
  | `SYMDEF_var of  typecode_t
  | `SYMDEF_val of  typecode_t
  | `SYMDEF_ref of  typecode_t
  | `SYMDEF_lazy of  typecode_t * expr_t
  | `SYMDEF_fun of property_t list * typecode_t list * typecode_t * c_t  * named_req_expr_t * prec_t
  | `SYMDEF_callback of property_t list * typecode_t list * typecode_t * named_req_expr_t
  | `SYMDEF_insert of c_t  * ikind_t * named_req_expr_t
  | `SYMDEF_union of  (id_t * int *  vs_list_t * typecode_t) list
  | `SYMDEF_struct of  (id_t * typecode_t) list
  | `SYMDEF_cstruct of  (id_t * typecode_t) list
  | `SYMDEF_cclass of  class_member_t list
  | `SYMDEF_typeclass
  | `SYMDEF_type_alias of   typecode_t
  | `SYMDEF_inherit of   qualified_name_t
  | `SYMDEF_inherit_fun of   qualified_name_t
  | `SYMDEF_instance of qualified_name_t
  ]

type symbol_data_t = {
  id:string;
  sr:range_srcref;
  parent:int option;
  vs:ivs_list_t;
  pubmap:name_map_t;
  privmap:name_map_t;
  dirs:dir_t list;
  symdef:symbol_definition_t;
}

type symbol_table_t = (int, symbol_data_t) Hashtbl.t

type symbol_data3_t = string * int option * range_srcref * bbdcl_t 
type fully_bound_symbol_table_t = (int, symbol_data3_t) Hashtbl.t

type type_registry_t = (btypecode_t,int) Hashtbl.t

@head(1,'Mappings')
@h = tangler('src/compiler/flxlib/flx_maps.mli')
@select(h)
open Flx_ast
open Flx_types

val map_type:
  (typecode_t -> typecode_t) -> typecode_t -> typecode_t

val map_b0type:
  (b0typecode_t -> b0typecode_t) -> b0typecode_t -> b0typecode_t

val map_btype:
  (btypecode_t -> btypecode_t) -> btypecode_t -> btypecode_t

val iter_b0type:
  (b0typecode_t -> unit) -> b0typecode_t -> unit

val iter_btype:
  (btypecode_t -> unit) -> btypecode_t -> unit
  
val flat_iter_tbexpr:
  (bid_t -> unit) ->
  (tbexpr_t -> unit) -> 
  (btypecode_t -> unit) ->
  tbexpr_t -> unit

val iter_tbexpr:
  (bid_t -> unit) ->
  (tbexpr_t -> unit) -> 
  (btypecode_t -> unit) ->
  tbexpr_t -> unit

val map_expr: 
  (expr_t -> expr_t) -> 
  expr_t -> 
  expr_t

val map_tbexpr:
  (bid_t -> bid_t) ->
  (tbexpr_t -> tbexpr_t) -> 
  (btypecode_t -> btypecode_t) ->
  tbexpr_t -> tbexpr_t

val iter_bexe:
  (bid_t -> unit) ->
  (tbexpr_t -> unit) ->
  (btypecode_t -> unit) ->
  (string -> unit) ->
  (string -> unit) ->
  bexe_t -> unit

val map_bexe:
  (bid_t -> bid_t) ->
  (tbexpr_t -> tbexpr_t) ->
  (btypecode_t -> btypecode_t) ->
  (string -> string) ->
  (string -> string) ->
  bexe_t -> bexe_t

val reduce_tbexpr:
  fully_bound_symbol_table_t ->
  tbexpr_t -> tbexpr_t

val reduce_bexe:
  fully_bound_symbol_table_t ->
  bexe_t -> bexe_t

val reduce_type:
  btypecode_t ->
  btypecode_t

val scan_expr: expr_t -> range_srcref list

@h = tangler('src/compiler/flxlib/flx_maps.ml')
@select(h)
open Flx_ast
open Flx_types
open List
open Flx_typing

let rec list_of_n_things thing lst n =
  if n = 0 then lst 
  else list_of_n_things thing (thing::lst) (n-1)
  
let map_type f (t:typecode_t):typecode_t = match t with
  | `AST_name (sr,name,ts) -> `AST_name (sr,name, map f ts)
  | `AST_lookup (sr,(e,name,ts)) -> `AST_lookup (sr,(e,name,map f ts))
  | `AST_suffix (sr,(qn,t)) -> `AST_suffix (sr,(qn, f t))

  | `AST_typed_case (sr,i,t) -> `AST_typed_case (sr,i, f t)
  | `TYP_tuple ts -> `TYP_tuple (map f ts)
  | `TYP_record ts -> `TYP_record (map (fun (s,t) -> s,f t) ts)
  | `TYP_variant ts -> `TYP_variant (map (fun (s,t) -> s,f t) ts)
  | `TYP_isin (a,b) -> `TYP_isin (f a, f b)

  (* we have to do this, so that a large unitsume
     can be specified without overflowing the compiler
     storage
  *)
  | `TYP_unitsum k -> 
    if k>0 then
      let mapped_unit = f (`TYP_tuple []) in
      match mapped_unit with
      | `TYP_tuple [] ->
        `TYP_unitsum k
      | _ -> `TYP_tuple ( list_of_n_things mapped_unit [] k)
    else `TYP_unitsum k

  (* here we don't need to go to a unitsum, since
     we have already used up storage
  *)
  | `TYP_sum ts -> `TYP_sum (map f ts)
  | `TYP_intersect ts -> `TYP_intersect (map f ts)
  | `TYP_function (a,b) -> `TYP_function (f a, f b)
  | `TYP_cfunction (a,b) -> `TYP_cfunction (f a, f b)
  | `TYP_pointer t -> `TYP_pointer (f t)
  | `TYP_lvalue t -> `TYP_lvalue (f t)
  | `TYP_array (t1, t2) -> `TYP_array (f t1, f t2)
  | `TYP_as (t,s) -> `TYP_as (f t,s)

  (* type sets *)
  | `TYP_typeset ts -> `TYP_typeset (map f ts)
  | `TYP_setintersection ts -> `TYP_setintersection (map f ts)
  | `TYP_setunion ts -> `TYP_setunion (map f ts)

  (* destructors *)
  | `TYP_dom t -> `TYP_dom (f t)
  | `TYP_dual t -> `TYP_dual (f t)
  | `TYP_cod t -> `TYP_cod (f t)
  | `TYP_proj (i,t) -> `TYP_proj (i, f t)
  | `TYP_case_arg (i,t) -> `TYP_case_arg (i, f t) 
  | `TYP_case (t1,ls,t2) -> `TYP_case (f t1, ls, f t2)

  (*
  | `TYP_type_match (t,ps) -> 
    let ps = map (fun (p,t) -> p, f t) ps in
    `TYP_type_match (f t, ps)
  *)
  | `TYP_type_match (t,ps) -> 
    let ps = map (fun (p,t) -> f p, f t) ps in
    `TYP_type_match (f t, ps)

  (* meta constructors *)
  | `TYP_apply (a,b) -> `TYP_apply (f a, f b)
  | `TYP_typefun (ps, a, b) -> `TYP_typefun (ps, f a, f b)
  | `TYP_type_tuple ts -> `TYP_type_tuple (map f ts)
  | `TYP_lift t -> `TYP_lift (f t)


  (* invariant ..?? *)
  | `TYP_typeof _
  | `AST_callback _
  | `AST_case_tag _
  | `AST_index _
  | `AST_the _
  | `TYP_glr_attr_type _
  | `TYP_var _
  | `AST_patvar _
  | `AST_patany _

  (* absolute constants *)
  | `AST_void _
  | `TYP_ellipsis
  | `TYP_type
  | `TYP_none 

    -> t


let map_expr f (e:expr_t):expr_t = match e with
  | `AST_patvar _
  | `AST_patany _ 
  | `AST_vsprintf _ -> e
  | `AST_interpolate _ -> e
  | `AST_map (sr,a,b) -> `AST_map (sr,f a, f b)
  | `AST_noexpand (sr,x) -> e (* DO NOT EXPAND .. HMM .. *)
  | `AST_name _ -> e
  | `AST_callback _ -> e
  | `AST_the _ -> e
  | `AST_index _ -> e
  | `AST_case_tag _ -> e
  | `AST_typed_case _ -> e
  | `AST_lookup (sr,(x,s,ts)) -> `AST_lookup (sr,(f x, s, ts))
  | `AST_apply (sr,(a,b)) -> `AST_apply (sr,(f a, f b))
  | `AST_tuple (sr,es) -> `AST_tuple (sr, map f es)
  | `AST_record (sr,es) -> `AST_record (sr, map (fun (s,e) -> s,f e) es)
  | `AST_variant (sr,(s,e)) -> `AST_variant (sr, (s,f e))
  | `AST_arrayof (sr, es) -> `AST_arrayof (sr, map f es)
  | `AST_coercion (sr, (x,t)) -> `AST_coercion (sr,(f x, t))
  | `AST_suffix _ -> e

  | `AST_record_type (sr,ts) -> e 
  | `AST_variant_type (sr,ts) -> e 
  | `AST_void sr -> e
  | `AST_ellipsis sr -> e
  | `AST_product (sr,es) -> `AST_product (sr, map f es)
  | `AST_sum (sr,es) -> `AST_sum (sr, map f es)
  | `AST_setunion (sr,es) -> `AST_setunion (sr, map f es)
  | `AST_setintersection (sr,es) -> `AST_setintersection (sr, map f es)
  | `AST_intersect (sr,es) -> `AST_intersect (sr, map f es)
  | `AST_isin (sr,(a,b)) -> `AST_isin (sr, (f a, f b))
  | `AST_orlist (sr,es) -> `AST_orlist (sr, map f es)
  | `AST_andlist (sr,es) -> `AST_andlist (sr, map f es)
  | `AST_arrow (sr,(a,b)) -> `AST_arrow (sr,(f a, f b))
  | `AST_longarrow (sr,(a,b)) -> `AST_longarrow (sr,(f a, f b))
  | `AST_superscript (sr,(a,b)) -> `AST_superscript (sr,(f a, f b))

  | `AST_literal _ -> e
  | `AST_deref (sr,x) -> `AST_deref (sr,f x)
  | `AST_ref (sr,x) -> `AST_ref (sr, f x)
  | `AST_new (sr,x) -> `AST_new (sr, f x)
  | `AST_lvalue (sr,x) -> `AST_lvalue (sr, f x)
  | `AST_lift (sr,x) -> `AST_lift (sr, f x)
  | `AST_method_apply (sr,(id,x,ts)) -> `AST_method_apply (sr,(id,f x,ts))
  (*
  | `AST_dot (sr,(x,id,ts)) -> `AST_dot (sr,(f x,id,ts))
  *)
  | `AST_dot (sr,(x,x2)) -> `AST_dot (sr,(f x,f x2))

  (* GIVE UP ON LAMBDAS FOR THE MOMENT .. NEEDS STATEMENT MAPPING TOO *)
  (* | `AST_lambda of range_srcref * (vs_list_t * params_t list * typecode_t * statement_t list) *)
  | `AST_lambda _ -> e

  | `AST_match_ctor (sr,(qn,x)) -> `AST_match_ctor (sr,(qn,f x))
  | `AST_match_case (sr,(j,x)) -> `AST_match_case (sr,(j, f x))

  | `AST_ctor_arg (sr,(qn,x)) -> `AST_ctor_arg (sr,(qn,f x))
  | `AST_case_arg (sr,(j,x)) -> `AST_case_arg (sr,(j, f x))
  | `AST_case_index (sr,x) -> `AST_case_index (sr,f x)

  | `AST_letin (sr,(pat,a,b)) -> `AST_letin (sr,(pat,f a, f b))

  | `AST_get_n (sr,(j,x)) -> `AST_get_n (sr,(j,f x))
  | `AST_get_named_variable (sr,(j,x)) -> `AST_get_named_variable (sr,(j,f x))
  | `AST_get_named_method (sr,(j,k,ts,x)) -> `AST_get_named_method (sr,(j,k,ts,f x))
  | `AST_as (sr,(x,s)) -> `AST_as (sr,(f x, s))
  | `AST_match (sr,(a,pes)) ->
    `AST_match (sr, (f a, map (fun (pat,x) -> pat, f x) pes))
  
  (* GIVE UP ON NASTY STUFF FOR THE MOMENT *)
  (*
  | `AST_parse of range_srcref * expr_t * (range_srcref * production_t * expr_t) list
  | `AST_sparse of range_srcref * expr_t * string * int list
  | `AST_regmatch of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  | `AST_reglex of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  *)
  | `AST_parse _
  | `AST_sparse _
  | `AST_regmatch _
  | `AST_string_regmatch _
  | `AST_reglex _ -> e

  | `AST_typeof (sr,x) -> `AST_typeof (sr,f x)
  | `AST_cond (sr,(a,b,c)) -> `AST_cond (sr, (f a, f b, f c))

  | `AST_expr _ -> e
  | `AST_type_match _ -> e
  | `AST_macro_ctor _ -> e
  | `AST_macro_statements _ -> e
  | `AST_case (sr,e1,ls,e2) -> `AST_case (sr,f e1, ls, f e2)
  | `AST_user_expr (sr,term,ts) -> e (* ouch! *)


let iter_expr f (e:expr_t) = 
  f e;
  match e with
  | `AST_patvar _
  | `AST_patany _ 
  | `AST_vsprintf _ 
  | `AST_interpolate _ 
  | `AST_name _ 
  | `AST_callback _ 
  | `AST_the _ 
  | `AST_index _ 
  | `AST_case_tag _ 
  | `AST_typed_case _ 
  | `AST_record_type _
  | `AST_variant_type _
  | `AST_void _
  | `AST_ellipsis _
  | `AST_noexpand _
  | `AST_suffix _ 
  | `AST_literal _ 
  | `AST_lambda _ 
  | `AST_parse _
  | `AST_sparse _
  | `AST_regmatch _
  | `AST_string_regmatch _
  | `AST_reglex _ 
  | `AST_expr _ 
  | `AST_type_match _ 
  | `AST_macro_ctor _ 
  | `AST_macro_statements _ 
    -> ()

  | `AST_variant (_,(_,x))
  | `AST_typeof (_,x)
  | `AST_as (_,(x,_))
  | `AST_get_named_method (_,(_,_,_,x))
  | `AST_get_n (_,(_,x)) 
  | `AST_get_named_variable (_,(_,x))
  | `AST_ctor_arg (_,(_,x))
  | `AST_case_arg (_,(_,x)) 
  | `AST_case_index (_,x)
  | `AST_match_ctor (_,(_,x))
  | `AST_match_case (_,(_,x))
  | `AST_method_apply (_,(_,x,_))
  | `AST_deref (_,x) 
  | `AST_ref (_,x) 
  | `AST_new (_,x)
  | `AST_lvalue (_,x)
  | `AST_lookup (_,(x,_,_))
  | `AST_coercion (_, (x,_)) 
  | `AST_lift (_,x)
    -> f x

  | `AST_case (_,a,_,b) 
  | `AST_letin (_,(_,a,b))
  | `AST_dot (_,(a,b)) 
  | `AST_longarrow (_,(a,b)) 
  | `AST_superscript (_,(a,b))
  | `AST_arrow (_,(a,b)) 
  | `AST_map (_,a,b) 
  | `AST_apply (_,(a,b)) 
  | `AST_isin (_,(a,b))
    -> f a; f b

  | `AST_tuple (_,es) 
  | `AST_product (_,es)
  | `AST_sum (_,es)
  | `AST_setunion (_,es)
  | `AST_intersect (_,es)
  | `AST_setintersection (_,es)
  | `AST_orlist (_,es)
  | `AST_andlist (_,es)
  | `AST_arrayof (_, es) ->  
    iter f es

  | `AST_record (sr,es) -> iter (fun (s,e) -> f e) es

  | `AST_match (sr,(a,pes)) ->
    f a; iter (fun (pat,x) -> f x) pes
  
  | `AST_cond (sr,(a,b,c)) -> f a; f b; f c
  | `AST_user_expr (sr,term,ts) -> ()

let scan_expr e = 
  let ls = ref [] in 
  let add x = ls := Flx_srcref.src_of_expr x :: !ls in
  iter_expr add e;
  Flx_util.uniq_list !ls

let all_units' ts = 
  try 
    iter (function 
      | `BTYP_tuple [] -> () 
      | _ -> raise Not_found
    ) 
    ts; 
    true 
  with Not_found -> false

let map_b0type f = function
  | `BTYP_inst (i,ts) -> `BTYP_inst (i, map f ts)
  | `BTYP_tuple ts -> `BTYP_tuple (map f ts)
  | `BTYP_record ts -> `BTYP_record (map (fun (s,t) -> s,f t) ts)
  | `BTYP_variant ts -> `BTYP_variant (map (fun (s,t) -> s,f t) ts)

  | `BTYP_unitsum k -> 
    if k>0 then
      let mapped_unit = f (`BTYP_tuple []) in
      match mapped_unit with
      | `BTYP_tuple [] ->
        `BTYP_unitsum k
      | _ -> `BTYP_tuple ( list_of_n_things mapped_unit [] k)
    else `BTYP_unitsum k
  
  | `BTYP_intersect ts -> `BTYP_intersect (map f ts)

  | `BTYP_sum ts -> 
    let ts = map f ts in
    if all_units' ts then
      `BTYP_unitsum (length ts)
    else
      `BTYP_sum ts

  | `BTYP_function (a,b) -> `BTYP_function (f a, f b)
  | `BTYP_cfunction (a,b) -> `BTYP_cfunction (f a, f b)
  | `BTYP_pointer t->  `BTYP_pointer (f t)
  | `BTYP_lvalue t->  `BTYP_lvalue (f t)
  | `BTYP_array (t1,t2)->  `BTYP_array (f t1, f t2)
  | x -> x

let map_btype f = function
  | `BTYP_apply (a,b) -> `BTYP_apply (f a, f b)
  | `BTYP_typefun (its, a, b) ->
     `BTYP_typefun (map (fun (i,t) -> i, f t) its, f a , f b)
  | `BTYP_type_tuple ts -> `BTYP_type_tuple (map f ts)
  | `BTYP_type_match (t,ps) ->
    (* this may be wrong .. hard to know .. *)
    let g (tp,t) = {tp with pattern=f tp.pattern},f t in
    `BTYP_type_match (f t, map g ps)

  | `BTYP_typeset ts -> 
    let g acc elt = 
      (* SHOULD USE UNIFICATIION! *)
      let elt = f elt in 
      if mem elt acc then acc else elt::acc
    in
    let ts = rev(fold_left g [] ts) in
    if length ts = 1 then hd ts else
    `BTYP_typeset ts

  | `BTYP_typesetunion ls -> `BTYP_typesetunion (map f ls)
  | `BTYP_typesetintersection ls -> `BTYP_typesetintersection (map f ls)

  | `BTYP_type i -> `BTYP_type i
  | x -> map_b0type f x

let iter_b0type f = function
  | `BTYP_inst (i,ts) -> iter f ts
  | `BTYP_tuple ts -> iter f ts
  | `BTYP_record ts -> iter (fun (s,t) -> f t) ts
  | `BTYP_variant ts -> iter (fun (s,t) -> f t) ts
  | `BTYP_unitsum k -> 
    let unitrep = `BTYP_tuple [] in
    for i = 1 to k do f unitrep done

  | `BTYP_sum ts -> iter f ts
  | `BTYP_function (a,b) -> f a; f b
  | `BTYP_cfunction (a,b) -> f a; f b
  | `BTYP_pointer t->  f t
  | `BTYP_lvalue t->  f t
  | `BTYP_array (t1,t2)->  f t1; f t2
  | x -> ()

let iter_btype f = function
  | `BTYP_apply (a,b) -> f a; f b
  | `BTYP_typefun (its, a, b) ->
     iter (fun (i,t) -> f t) its; f a; f b
  | `BTYP_type_match (t,ps) ->
    let g (tp,t) = f tp.pattern; f t in
    f t; 
    iter g ps
 
  | `BTYP_type_tuple ts -> iter f ts
  | `BTYP_typeset ts -> iter f ts
  | `BTYP_typesetunion ts -> iter f ts
  | `BTYP_typesetintersection ts -> iter f ts

  | x -> iter_b0type f x

(* type invariant mapping *)

(* this routine applies arguments HOFs to SUB components only, not
   to the actual argument. It isn't recursive, so the argument HOF
   can be.
*)
let flat_iter_tbexpr fi fe ft ((x,t) as e) = 
  match x with 
  | `BEXPR_parse (e,iis) -> fe e; iter fi iis
  | `BEXPR_deref e -> fe e
  | `BEXPR_ref (i,ts) -> fi i; iter ft ts
  | `BEXPR_new e -> fe e

  | `BEXPR_apply (e1,e2) -> fe e1; fe e2

  | `BEXPR_apply_prim (i,ts,e2) -> fi i; iter ft ts; fe e2
  | `BEXPR_apply_direct (i,ts,e2) -> fi i; iter ft ts; fe e2
  | `BEXPR_apply_method_direct (e1,i,ts,e2) -> fe e1; fi i; iter ft ts; fe e2
  | `BEXPR_apply_struct (i,ts,e2) -> fi i; iter ft ts; fe e2
  | `BEXPR_apply_stack (i,ts,e2) -> fi i; iter ft ts; fe e2
  | `BEXPR_apply_method_stack (e1,i,ts,e2) -> fe e1; fi i; iter ft ts; fe e2
  | `BEXPR_tuple  es -> iter fe es
  | `BEXPR_record es -> iter (fun (s,e) -> fe e) es
  | `BEXPR_variant (s,e) -> fe e

  | `BEXPR_get_n (i,e) -> fe e
  | `BEXPR_get_named (i,e) -> fi i; fe e

  | `BEXPR_closure (i,ts) -> fi i; iter ft ts
  | `BEXPR_method_closure (e,i,ts) -> fe e; fi i; iter ft ts
  | `BEXPR_name (i,ts) -> fi i; iter ft ts
  | `BEXPR_case (i,t') -> ft t'
  | `BEXPR_match_case (i,e) -> fe e
  | `BEXPR_case_arg (i,e) -> fe e
  | `BEXPR_case_index e -> fe e

  | `BEXPR_literal x -> ft t
  | `BEXPR_expr (s,t1) -> ft t1
  | `BEXPR_range_check (e1,e2,e3) -> fe e1; fe e2; fe e3
  | `BEXPR_coerce (e,t) -> fe e; ft t

(* this is a self-recursing version of the above routine: the argument
   to this routine must NOT recursively apply itself!
*)
let rec iter_tbexpr fi fe ft ((x,t) as e) = 
  fe e; ft t;
  let fe e = iter_tbexpr fi fe ft e in
  flat_iter_tbexpr fi fe ft e


let map_tbexpr fi fe ft e = match e with 
  | `BEXPR_parse (e,iis),t -> `BEXPR_parse (fe e,map fi iis), ft t
  | `BEXPR_deref e,t -> `BEXPR_deref (fe e),ft t
  | `BEXPR_ref (i,ts),t -> `BEXPR_ref (fi i, map ft ts), ft t
  | `BEXPR_new e,t -> `BEXPR_new (fe e), ft t

  | `BEXPR_apply (e1,e2),t -> `BEXPR_apply (fe e1, fe e2), ft t

  | `BEXPR_apply_prim (i,ts,e2),t -> `BEXPR_apply_prim (fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_direct (i,ts,e2),t -> `BEXPR_apply_direct (fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_method_direct (e1,i,ts,e2),t -> `BEXPR_apply_method_direct (fe e1,fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_struct (i,ts,e2),t -> `BEXPR_apply_struct (fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_stack (i,ts,e2),t -> `BEXPR_apply_stack (fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_method_stack (e1,i,ts,e2),t -> `BEXPR_apply_method_stack (fe e1,fi i, map ft ts, fe e2),ft t

  | `BEXPR_tuple  es,t -> `BEXPR_tuple (map fe es),ft t
  | `BEXPR_record es,t -> `BEXPR_record (map (fun (s,e) -> s, fe e) es),ft t
  | `BEXPR_variant (s,e),t -> `BEXPR_variant (s, fe e),ft t

  | `BEXPR_get_n (i,e),t -> `BEXPR_get_n (i, fe e),ft t
  | `BEXPR_get_named (i,e),t -> `BEXPR_get_named (fi i, fe e),ft t

  | `BEXPR_closure (i,ts),t -> `BEXPR_closure (fi i, map ft ts),ft t
  | `BEXPR_method_closure (e,i,ts),t -> `BEXPR_method_closure (fe e, fi i, map ft ts),ft t
  | `BEXPR_name (i,ts),t -> `BEXPR_name (fi i, map ft ts), ft t
  | `BEXPR_case (i,t'),t -> `BEXPR_case (i, ft t'),ft t
  | `BEXPR_match_case (i,e),t -> `BEXPR_match_case (i, fe e),ft t
  | `BEXPR_case_arg (i,e),t -> `BEXPR_case_arg (i, fe e),ft t
  | `BEXPR_case_index e,t -> `BEXPR_case_index (fe e),ft t

  | `BEXPR_literal x,t -> `BEXPR_literal x, ft t
  | `BEXPR_expr (s,t1),t2 -> `BEXPR_expr (s, ft t1), ft t2
  | `BEXPR_range_check (e1,e2,e3),t -> `BEXPR_range_check (fe e1,fe e2, fe e3), ft t
  | `BEXPR_coerce (e,t'),t -> `BEXPR_coerce (fe e, ft t'), ft t

let iter_bexe fi fe ft fl fldef exe =
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  
  | `BEXE_call_stack (sr,i,ts,e2)  
  | `BEXE_call_direct (sr,i,ts,e2)  
  | `BEXE_jump_direct (sr,i,ts,e2)  
    -> fi i; iter ft ts; fe e2

  | `BEXE_call_method_direct (sr,e1,i,ts,e2)  
    -> fe e1; fi i; iter ft ts; fe e2

  | `BEXE_call_method_stack (sr,e1,i,ts,e2)  
    -> fe e1; fi i; iter ft ts; fe e2

  | `BEXE_assign (sr,e1,e2) 
  | `BEXE_call (sr,e1,e2)
  | `BEXE_jump (sr,e1,e2) 
    -> fe e1; fe e2

  | `BEXE_apply_ctor (sr,i0, i1,ts,i2,e2) 
    -> fi i0; fi i1; iter ft ts; fi i2; fe e2

  | `BEXE_apply_ctor_stack (sr,i0, i1,ts,i2,e2) 
    -> fi i0; fi i1; iter ft ts; fi i2; fe e2
  
  | `BEXE_loop (sr,i,e) 
    -> fi i; fe e
    
  | `BEXE_ifgoto (sr,e,lab) 
  | `BEXE_ifnotgoto (sr,e,lab) 
    -> fe e; fl lab

  | `BEXE_label (sr,lab) 
    -> fldef lab
    
  | `BEXE_goto (sr,lab) 
    -> fl lab

  | `BEXE_fun_return (sr,e) 
    -> fe e

  | `BEXE_yield (sr,e) 
    -> fe e

  | `BEXE_axiom_check (_,e)
    -> fe e
    
  | `BEXE_assert2 (_,_,e1,e2)
    -> (match e1 with Some e -> fe e | None->()); fe e2

  | `BEXE_assert (_,e)
    -> fe e

  | `BEXE_init (sr,i,e) 
    -> fi i; fe e
    
  | `BEXE_svc (sr,i)  
    -> fi i
    
  | `BEXE_halt _
  | `BEXE_trace _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_proc_return _
  | `BEXE_comment _
  | `BEXE_nop _
  | `BEXE_begin
  | `BEXE_end
    -> ()


let map_bexe fi fe ft fl fldef (exe:bexe_t):bexe_t =
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  ->
    `BEXE_call_prim (sr,fi i,map ft ts, fe e2)

  | `BEXE_call_stack (sr,i,ts,e2) ->
    `BEXE_call_stack (sr,fi i, map ft ts, fe e2)  

  | `BEXE_call_direct (sr,i,ts,e2) ->
    `BEXE_call_direct (sr,fi i,map ft ts,fe e2)  

  | `BEXE_call_method_direct (sr,e1,i,ts,e2) ->
    `BEXE_call_method_direct (sr,fe e1,fi i,map ft ts,fe e2)  

  | `BEXE_call_method_stack (sr,e1,i,ts,e2) ->
    `BEXE_call_method_stack (sr,fe e1,fi i,map ft ts,fe e2)  

  | `BEXE_jump_direct (sr,i,ts,e2) ->
    `BEXE_jump_direct (sr,fi i,map ft ts,fe e2)  

  | `BEXE_assign (sr,e1,e2) ->
    `BEXE_assign (sr,fe e1,fe e2) 
   
  | `BEXE_call (sr,e1,e2) -> 
    `BEXE_call (sr,fe e1, fe e2)

  | `BEXE_apply_ctor (sr,i1,i2,ts,i3,e2) ->
    `BEXE_apply_ctor (sr,fi i1,fi i2, map ft ts, fi i3,fe e2)

  | `BEXE_apply_ctor_stack (sr,i1,i2,ts,i3,e2) ->
    `BEXE_apply_ctor_stack (sr,fi i1,fi i2, map ft ts, fi i3,fe e2)

  | `BEXE_jump (sr,e1,e2) ->
    `BEXE_jump (sr,fe e1, fe e2) 

  | `BEXE_loop (sr,i,e) ->
    `BEXE_loop (sr,fi i,fe e) 
    
  | `BEXE_ifgoto (sr,e,lab)  ->
    `BEXE_ifgoto (sr,fe e,fl lab)

  | `BEXE_ifnotgoto (sr,e,lab) ->
    `BEXE_ifnotgoto (sr,fe e,fl lab) 

  | `BEXE_label (sr,lab) ->
    `BEXE_label (sr,fldef lab) 
    
  | `BEXE_goto (sr,lab) ->
    `BEXE_goto (sr,fl lab)

  | `BEXE_fun_return (sr,e) ->
    `BEXE_fun_return (sr,fe e) 

  | `BEXE_yield (sr,e) ->
    `BEXE_yield (sr,fe e) 

  | `BEXE_assert (sr,e) ->
    `BEXE_assert (sr, fe e)

  | `BEXE_assert2 (sr,sr2,e1, e2) ->
     let e1 = match e1 with Some e1 -> Some (fe e1) | None -> None in
    `BEXE_assert2 (sr, sr2,e1, fe e2)

  | `BEXE_axiom_check (sr,e) ->
    `BEXE_axiom_check (sr, fe e)

  | `BEXE_init (sr,i,e) ->
    `BEXE_init (sr,fi i,fe e) 
    
  | `BEXE_svc (sr,i) ->
    `BEXE_svc (sr,fi i)  
    
  | `BEXE_halt _
  | `BEXE_trace _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_proc_return _
  | `BEXE_comment _
  | `BEXE_nop _
  | `BEXE_begin
  | `BEXE_end
    -> exe

let ident x = x
let reduce_tbexpr bbdfns e =
  let rec aux e =
    match map_tbexpr ident aux ident e with
    | `BEXPR_apply((`BEXPR_closure (i,ts),_),a),t ->
      `BEXPR_apply_direct (i,ts,a),t

    | `BEXPR_apply((`BEXPR_method_closure (obj,i,ts),_),a),t ->
      `BEXPR_apply_method_direct (obj,i,ts,a),t
    
    | `BEXPR_get_n (n,((`BEXPR_tuple ls),_)),_ ->
      List.nth ls n

    | `BEXPR_deref (`BEXPR_ref (i,ts),_),t -> 
      `BEXPR_name (i,ts),t

    | x -> x
  in aux e
    
let reduce_bexe bbdfns exe =
  match map_bexe ident (reduce_tbexpr bbdfns) ident ident ident exe with
  | `BEXE_call (sr,(`BEXPR_closure (i,ts),_),a) ->
    `BEXE_call_direct (sr,i,ts,a)

  | `BEXE_call (sr,(`BEXPR_method_closure (obj,meth,ts),_),a) ->
    `BEXE_call_method_direct (sr,obj,meth,ts,a)

  | x -> x

let rec reduce_type t =
  match map_btype reduce_type t with
  | `BTYP_record ts -> 
    begin match ts with
    | [] -> `BTYP_tuple []
    | _ -> 
     let rcmp (s1,_) (s2,_) = compare s1 s2 in
     let ts = sort compare ts in
     let ss,ts = split ts in
     let ts = combine ss (map reduce_type ts) in
     `BTYP_record ts
    end
  | `BTYP_variant ts -> 
    begin match ts with
    | [] -> `BTYP_void
    | _ -> 
     let rcmp (s1,_) (s2,_) = compare s1 s2 in
     let ts = sort compare ts in
     let ss,ts = split ts in
     let ts = combine ss (map reduce_type ts) in
     `BTYP_variant ts
    end
  | `BTYP_tuple ts -> typeoflist ts
  | `BTYP_array (t',`BTYP_unitsum 0) -> `BTYP_tuple []
  | `BTYP_array (t',`BTYP_unitsum 1) -> t' 
  | t -> t

@head(1,'Routines to extract source reference from terms')
Source reference manipulators.
@h = tangler('src/compiler/flxlib/flx_srcref.mli')
@select(h)
open Flx_ast
open Flx_types

val rstoken: srcref -> srcref -> range_srcref
val rsrange: range_srcref -> range_srcref -> range_srcref
val slift: srcref -> range_srcref

val rsexpr: expr_t -> expr_t -> range_srcref
val rslist: expr_t list -> range_srcref

val src_of_bexe: bexe_t -> range_srcref
val src_of_expr: expr_t -> range_srcref
val src_of_stmt : statement_t -> range_srcref
val src_of_pat : pattern_t -> range_srcref
val src_of_qualified_name : qualified_name_t -> range_srcref
val src_of_suffixed_name: suffixed_name_t -> range_srcref

val short_string_of_src: range_srcref -> string
val long_string_of_src: range_srcref -> string

val dummy_sr: range_srcref
@h = tangler('src/compiler/flxlib/flx_srcref.ml')

@doc()
Generic source reference manipulation.
Note the special hack of forgetting the second
filename when creating a range: the alternative
would be to record a complete list of lines.
@select(h)

let dummy_sr = ("generated",0,0,0,0)

(** axiom: rstoken a b = rsrange (lift a) (lift b) *)

(** get source range from source references of first
   and last tokens 
*)
let rstoken (f1,l1,s1,e1) (f2,l2,s2,e2) = (f1,l1,s1,l2,e2)

(** get range from first and last ranges *)
let rsrange (f1,sl1,sc1,el1,ec1) (f2,sl2,sc2,el2,ec2) =
  (f1,sl1,sc1,el2,ec2)

(** lift token source to range for token without attribute*)
let slift (f,l,s,e) = (f,l,s,l,e)

(** lift token source to range for tokens with attribute*)
let sliftfst x = slift (fst x)


@doc()
Type specific operations.
@select(h)
open Flx_util
open Flx_ast
open Flx_types
let src_of_bexe = function
  | `BEXE_goto (sr,_)
  | `BEXE_assert (sr,_)
  | `BEXE_assert2 (sr,_,_,_)
  | `BEXE_axiom_check (sr,_)
  | `BEXE_halt (sr,_)
  | `BEXE_trace (sr,_,_)
  | `BEXE_ifgoto (sr,_,_)
  | `BEXE_ifnotgoto (sr,_,_)
  | `BEXE_label (sr,_)
  | `BEXE_comment (sr,_)
  | `BEXE_call (sr,_,_)
  | `BEXE_call_direct (sr,_,_,_)
  | `BEXE_call_method_direct (sr,_,_,_,_)
  | `BEXE_call_method_stack (sr,_,_,_,_)
  | `BEXE_jump_direct (sr,_,_,_)
  | `BEXE_call_stack (sr,_,_,_)
  | `BEXE_call_prim (sr,_,_,_)
  | `BEXE_jump (sr,_,_)
  | `BEXE_loop (sr,_,_)
  | `BEXE_svc (sr,_)
  | `BEXE_fun_return (sr,_)
  | `BEXE_yield (sr,_)
  | `BEXE_proc_return sr
  | `BEXE_nop (sr,_)
  | `BEXE_code (sr,_)
  | `BEXE_nonreturn_code (sr,_)
  | `BEXE_assign (sr,_,_)
  | `BEXE_init (sr,_,_)
  | `BEXE_apply_ctor (sr,_,_,_,_,_)
  | `BEXE_apply_ctor_stack (sr,_,_,_,_,_)
    -> sr

  | `BEXE_begin
  | `BEXE_end -> dummy_sr

let src_of_qualified_name (e : qualified_name_t) = match e with
  | `AST_void s 
  | `AST_name  (s,_,_) 
  | `AST_case_tag (s,_)
  | `AST_typed_case (s,_,_)
  | `AST_lookup (s,_)
  | `AST_the (s,_) 
  | `AST_index (s,_,_)
  | `AST_callback (s,_)
    -> s

let src_of_suffixed_name (e : suffixed_name_t) = match e with
  | #qualified_name_t as x -> src_of_qualified_name x
  | `AST_suffix (s,_) 
    -> s

let src_of_expr (e : expr_t) = match e with
  | #suffixed_name_t as x -> src_of_suffixed_name x
  | `AST_interpolate (s,_)
  | `AST_vsprintf (s,_)
  | `AST_ellipsis (s)
  | `AST_noexpand (s,_)
  | `AST_product (s,_)
  | `AST_sum (s,_)
  | `AST_setunion (s,_)
  | `AST_intersect (s,_)
  | `AST_isin (s,_)
  | `AST_setintersection (s,_)
  | `AST_orlist (s,_)
  | `AST_andlist (s,_)
  | `AST_arrow (s,_)
  | `AST_longarrow (s,_)
  | `AST_superscript (s,_)
  | `AST_patvar (s,_)
  | `AST_patany s

  | `AST_map (s,_,_) 
  | `AST_apply  (s,_) 
  | `AST_deref (s,_) 
  | `AST_new (s,_) 
  | `AST_ref  (s,_) 
  | `AST_lvalue (s,_) 
  | `AST_lift (s,_) 
  | `AST_literal  (s,_) 
  | `AST_method_apply  (s,_) 
  | `AST_tuple  (s,_) 
  | `AST_record (s,_) 
  | `AST_variant (s,_) 
  | `AST_record_type (s,_) 
  | `AST_variant_type (s,_) 
  | `AST_arrayof (s,_) 
  | `AST_dot  (s,_) 
  | `AST_lambda  (s,_) 
  | `AST_match_ctor  (s,_) 
  | `AST_match_case (s,_)
  | `AST_ctor_arg  (s,_) 
  | `AST_case_arg  (s,_) 
  | `AST_case_index (s,_) 
  | `AST_get_n  (s,_) 
  | `AST_get_named_variable  (s,_) 
  | `AST_get_named_method (s,_) 
  | `AST_coercion (s,_)
  | `AST_as (s,_)
  | `AST_match (s, _) 
  | `AST_parse (s, _,_) 
  | `AST_sparse (s,_,_,_) 
  | `AST_type_match (s, _) 
  | `AST_regmatch (s, _) 
  | `AST_string_regmatch (s, _) 
  | `AST_reglex (s, _) 
  | `AST_cond (s,_)
  | `AST_expr (s,_,_)
  | `AST_letin (s,_)
  | `AST_typeof (s,_)
  | `AST_macro_ctor (s,_)
  | `AST_macro_statements (s,_)
  | `AST_case (s,_,_,_) 
  | `AST_user_expr (s,_,_)
    -> s

let src_of_stmt e = match e with
  (*
  | `AST_public (s,_,_)
  *)
  | `AST_private (s,_)
  | `AST_label (s,_)
  | `AST_goto (s,_)
  | `AST_assert (s,_)
  | `AST_apply_ctor (s,_,_,_)
  | `AST_init (s,_,_)
  | `AST_function (s,_, _, _ , _, _, _)
  | `AST_reduce (s,_, _, _ , _, _)
  | `AST_axiom (s,_, _, _ , _)
  | `AST_lemma (s,_, _, _ , _)
  | `AST_curry (s,_, _, _ , _, _,_)
  | `AST_object (s,_, _, _ , _)
  | `AST_macro_name (s, _,_)
  | `AST_macro_names (s, _,_)
  | `AST_expr_macro (s,_, _,_)
  | `AST_stmt_macro (s,_, _,_)
  | `AST_macro_block (s,_)
  | `AST_macro_val (s,_,_)
  | `AST_macro_vals (s,_,_)
  | `AST_macro_var (s, _,_)
  | `AST_macro_assign (s,_,_)
  | `AST_macro_forget (s,_)
  | `AST_macro_label (s,_)
  | `AST_macro_goto (s,_)
  | `AST_macro_ifgoto (s,_,_)
  | `AST_macro_proc_return s
  | `AST_macro_ifor (s,_,_,_)
  | `AST_macro_vfor (s,_,_,_)

  | `AST_val_decl (s,_,_,_,_) 
  | `AST_lazy_decl (s,_,_,_,_) 
  | `AST_var_decl (s,_,_,_,_) 
  | `AST_ref_decl (s,_,_,_,_) 
 

  | `AST_type_alias (s,_,_,_) 
  | `AST_inherit (s,_,_,_) 
  | `AST_inherit_fun (s,_,_,_) 
  | `AST_nop (s, _) 

  | `AST_assign (s, _, _,_ ) 
  | `AST_cassign (s, _,_ ) 
  | `AST_call (s, _, _ ) 
  | `AST_jump (s, _, _ ) 
  | `AST_loop (s, _, _ ) 
  | `AST_svc (s, _) 
  | `AST_fun_return (s, _) 
  | `AST_yield (s, _) 
  | `AST_proc_return s 
  | `AST_halt (s,_)
  | `AST_trace (s,_,_)
  | `AST_ifgoto (s,_,_)
  | `AST_ifreturn (s,_)
  | `AST_ifdo (s,_,_,_)
  (*
  | `AST_whilst (s,_,_)
  | `AST_until (s,_,_)
  *)
  | `AST_ifnotgoto (s,_,_)
  | `AST_abs_decl (s,_,_, _,_,_) 
  | `AST_newtype (s,_,_,_) 
  | `AST_ctypes (s,_,_,_) 
  | `AST_const_decl (s,_,_,_,_,_) 
  | `AST_fun_decl (s,_,_,_,_,_,_,_ ) 
  | `AST_callback_decl (s,_,_,_,_) 
  | `AST_insert (s,_,_,_,_,_) 
  | `AST_code (s, _) 
  | `AST_noreturn_code (s, _) 
  | `AST_union (s, _,_, _ ) 
  | `AST_struct (s,_, _, _)
  | `AST_cstruct (s,_, _, _)
  | `AST_cclass (s,_, _, _)
  | `AST_class (s,_, _, _)
  | `AST_typeclass (s,_, _, _)
  | `AST_instance (s,_, _,_)
  | `AST_untyped_module (s,_,_,_)
  | `AST_namespace (s,_,_,_)
  | `AST_export_fun (s, _,_)
  | `AST_export_type (s, _,_)
  | `AST_type (s,_,_)
  | `AST_open (s,_,_)
  | `AST_inject_module (s,_)
  | `AST_include (s,_)
  | `AST_cparse (s,_)
  | `AST_use (s,_,_)
  | `AST_regdef (s,_,_)
  | `AST_glr (s,_,_,_)
  | `AST_seq (s,_)
  | `AST_user_statement (s,_,_)
  | `AST_scheme_string (s,_)
    -> s
  | `AST_comment (s,_) -> s


let src_of_pat e = match e with
  | `PAT_coercion (s,_,_)
  | `PAT_nan s
  | `PAT_none s
  | `PAT_int (s,_,_)
  | `PAT_string (s, _)
  | `PAT_int_range (s,_,_,_,_)
  | `PAT_string_range (s, _, _)
  | `PAT_float_range (s, _,_)
  | `PAT_name (s, _)
  | `PAT_tuple (s, _)
  | `PAT_any s
  | `PAT_regexp (s, _, _ )
  | `PAT_const_ctor (s, _)
  | `PAT_nonconst_ctor (s, _, _)
  | `PAT_as (s, _, _)
  | `PAT_when (s, _, _)
  | `PAT_record (s, _)
    -> s

(* get range from first and last expressions *)
let rsexpr a b = rsrange (src_of_expr a) (src_of_expr b)

(* get source range of non-empty list of expressions *)
let rslist lst = 
  rsexpr (List.hd lst) (list_last lst)


let short_string_of_src (f,l1,c1,l2,c2) =
  if l1 = l2 
  then
    f ^ ": line " ^ si l1 ^ 
    ", cols " ^ si c1 ^ " to " ^ si c2
  else
    f ^ ": line " ^ si l1 ^ 
    " col " ^ si c1 ^ " to " ^ 
    " line " ^ si l2 ^ " col " ^ si c2

let get_lines f context l1' l2' c1 c2 = (* first line is line 1 *)
  let l1 = max 1 (l1'-context) in
  let l2 = l2' + context in
  let n = String.length (si l2) in
  let fmt i = 
    let s ="    " ^ si i in
    let m = String.length s in
    String.sub s (m-n) n
  in
  try
    let buf = Buffer.create ((l2-l1+4) * 80) in
    let spc () = Buffer.add_char buf ' ' in
    let star() = Buffer.add_char buf '*' in
    let nl() = Buffer.add_char buf '\n' in
    let f = open_in f in
    for i = 1 to l1-1 do ignore(input_line f) done;
    let too_long = l2'-l1' > 20 in
    begin
      try
        for i = l1 to l2 do 
          let s = input_line f in
          if too_long && i = l1'+3 then
            Buffer.add_string buf ("...\n")
          else if too_long && i > l1'+3 && i< l2'-3 then () else
          begin
            Buffer.add_string buf (fmt i ^": ");
            Buffer.add_string buf s;
            nl();
            if i = l1' && l1' = l2' then
            begin
              for i = 1 to n + 2 do spc() done;
              for i = 1 to c1 - 1 do spc() done;
              for i = c1 to c2 do star() done;
              nl()
            end
          end
        done
      with _ -> Buffer.add_string buf "<eof>\n"
    end
    ;
    close_in f;
    Buffer.contents buf
  with _ -> 
    "*** Can't read file " ^ f ^ 
    " lines " ^ fmt l1 ^ " thru " ^ fmt l2 ^ "\n"

let long_string_of_src (f,l1,c1,l2,c2) =
  short_string_of_src (f,l1,c1,l2,c2) ^
  "\n" ^
  get_lines f 1 l1 l2 c1 c2

@head(1,'Print module')
Routines to print various terms.
@h = tangler('src/compiler/flxlib/flx_print.mli')
@select(h)
open Flx_ast
open Flx_types
val string_of_typecode : typecode_t -> string
val string_of_btypecode : symbol_table_t -> btypecode_t -> string
val sbt: symbol_table_t -> btypecode_t -> string
val special_string_of_typecode : typecode_t -> string
val string_of_expr : expr_t -> string
val string_of_bound_expression : 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  tbexpr_t -> 
  string
val string_of_bound_expression_with_type : 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  tbexpr_t -> 
  string
val sbe: 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  tbexpr_t -> 
  string
val tsbe: 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  tbexpr_t -> 
  string

val string_of_properties : property_t list -> string

val string_of_pattern : pattern_t -> string
val string_of_tpattern : tpattern_t -> string
val string_of_literal : literal_t -> string
val string_of_parameters : params_t -> string
val string_of_arguments : expr_t list -> string
val string_of_statement : int -> statement_t -> string
val string_of_compilation_unit : compilation_unit_t -> string
val string_of_desugared : asm_t list -> string
val string_of_suffixed_name : suffixed_name_t -> string
val string_of_qualified_name : qualified_name_t -> string
val string_of_dcl : int -> id_t -> int option -> vs_list_t -> dcl_t -> string
val string_of_bexe : symbol_table_t -> fully_bound_symbol_table_t -> int -> bexe_t -> string
val sbx: symbol_table_t -> fully_bound_symbol_table_t -> bexe_t -> string
val string_of_exe : int -> exe_t -> string
val qualified_name_of_index : symbol_table_t -> int -> string
val qualified_name_of_bindex : 
  symbol_table_t -> 
  fully_bound_symbol_table_t -> 
  int -> string
val string_of_bbdcl : 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  bbdcl_t -> 
  int -> 
  string

val string_of_symdef : 
  symbol_definition_t -> string -> ivs_list_t ->
  string

val string_of_entry_kind:
  entry_kind_t -> string

val full_string_of_entry_kind:
  symbol_table_t -> entry_kind_t -> string

val string_of_entry_set:
  entry_set_t -> string

val full_string_of_entry_set:
  symbol_table_t -> entry_set_t -> string

val print_name_table: 
  symbol_table_t -> name_map_t -> unit

val string_of_myentry:
  symbol_table_t -> entry_kind_t -> string

val string_of_varlist:
  symbol_table_t ->
  (int * btypecode_t) list ->
  string

val string_of_bigint: bigint -> string

val print_env: env_t -> unit
val print_env_short: env_t -> unit

val print_functions: 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  unit

val print_symbols: 
  symbol_table_t -> 
  fully_bound_symbol_table_t ->
  unit

val print_function_body:
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  string -> int -> bvs_t -> bparams_t -> bexe_t list -> int option ->
  unit

val print_function:
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  int ->
  unit

val print_vs: vs_list_t -> string
val print_ivs: ivs_list_t -> string
val print_ivs_with_index: ivs_list_t -> string

val string_of_ast_term: int -> ast_term_t -> string
val string_of_string: string -> string
val string_of_bquals: symbol_table_t -> btype_qual_t list -> string
val print_bvs: bvs_t -> string
val string_of_code_spec: c_t -> string
val string_of_raw_reqs: raw_req_expr_t -> string
val string_of_ikind: ikind_t -> string

val string_of_quals: type_qual_t list -> string

@h = tangler('src/compiler/flxlib/flx_print.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_srcref
open Big_int
open Flx_typing
open List

let rec string_of_string s = Flx_string.c_quote_of_string s

let string_of_char c =
  if c = -1 then "<<EOF>>" else
  if c < 32 || c > 126
  then "\\x" ^ Flx_string.hex2 c
  else String.make 1 (Char.chr c)


let suffix_of_type s = match s with
  | "tiny" -> "t"
  | "short" -> "s"
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "v"
  | "utiny" -> "tu"
  | "ushort" -> "su"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "vu"
  | "int8" -> "i8"
  | "int16" -> "i16"
  | "int32" -> "i32"
  | "int64" -> "i64"
  | "uint8" -> "u8"
  | "uint16" -> "u16"
  | "uint32" -> "u32"
  | "uint64" -> "u64"
  | "float" -> "f"
  | "double" -> ""
  | "ldouble" -> "l"
  | _ -> failwith ("[suffix_of_type] Unexpected Type " ^ s)

let string_of_bigint x = string_of_big_int x
 
let string_of_literal e = match e with
  | `AST_int (s,i) -> (string_of_bigint i)^suffix_of_type s 
  | `AST_float (t,v) -> v ^ suffix_of_type t
  | `AST_string s -> string_of_string s
  | `AST_cstring s -> "c"^string_of_string s
  | `AST_wstring s -> "w"^string_of_string s
  | `AST_ustring s -> "u"^string_of_string s
  
let rec string_of_qualified_name (n:qualified_name_t) =
  let se e = string_of_expr e in
  match n with
  | `AST_the (sr,q) -> "the " ^ string_of_qualified_name q
  | `AST_index (sr,name,idx) -> name ^ "<" ^ si idx ^ ">" 
  | `AST_void _ -> "void"
  | `AST_name (_,name,ts) -> name ^ 
    (
      if List.length ts = 0 then "" 
      else "[" ^ catmap ", " string_of_typecode ts ^ "]"
    )
  | `AST_case_tag (_,v) -> "case " ^ si v
  | `AST_typed_case (_,v,t) -> 
    "(case " ^ si v ^ 
    " of " ^ string_of_typecode t ^ ")"

  | `AST_lookup (_,(e,name, ts)) -> "("^se e ^")::" ^ name ^
    (if length ts = 0 then "" else
    "[" ^ catmap ", " string_of_typecode ts ^ "]"
    )
  | `AST_callback (_,name) -> "callback " ^string_of_qualified_name name

and string_of_suffixed_name (n:suffixed_name_t) =
  match n with
  | #qualified_name_t as n -> string_of_qualified_name n
  | `AST_suffix (_,(name,suf)) ->
    string_of_qualified_name name ^ " of (" ^ string_of_typecode suf ^ ")"

and string_of_re re =
  match re with
  | `REGEXP_seq (r1,r2) -> string_of_re r1 ^ " " ^ string_of_re r2
  | `REGEXP_alt (r1,r2) -> string_of_re r1 ^ " | " ^ string_of_re r2
  | `REGEXP_aster r -> "(" ^ string_of_re r ^ ")*"
  | `REGEXP_name s -> string_of_qualified_name s
  | `REGEXP_string s ->
    let ss=Buffer.create (String.length s) in
    Buffer.add_char ss '"';
    for i = 0 to String.length s - 1 do
      Buffer.add_string ss (string_of_char (Char.code s.[i]))
    done;
    Buffer.add_char ss '"';
    Buffer.contents ss


  | `REGEXP_epsilon -> "epsilon"
  | `REGEXP_sentinel -> "sentinel"
  | `REGEXP_code e -> "<CODE " ^ string_of_expr e ^ ">"
  | `REGEXP_group (n,r) -> "(" ^ string_of_re r ^ " as " ^ n ^ ")"

and string_of_expr (e:expr_t) = 
  let st t = string_of_typecode t in
  let se e = string_of_expr e in
  let sme e = string_of_expr e in
  let sqn e = string_of_qualified_name e in
  match e with
  | #suffixed_name_t as n -> string_of_suffixed_name n
  | `AST_patvar (sr,s) -> "?"^s
  | `AST_patany sr -> "ANY"
  | `AST_vsprintf (sr,s) -> "f"^string_of_string s
  | `AST_interpolate (sr,s) -> "q"^string_of_string s
  | `AST_ellipsis _ -> "..."
  (*
  | `AST_noexpand (sr,e) -> "noexpand(" ^ string_of_expr e ^ ")"
  *)
  (* because 'noexpand' is too ugly .. *)
  | `AST_noexpand (sr,e) -> string_of_expr e

  | `AST_letin (sr,(pat,e1, e2)) ->
    "let " ^ string_of_letpat pat ^ " = " ^ se e1 ^ " in " ^ se e2
  | `AST_coercion (_,(e,t)) -> 
    "(" ^ sme e ^ ":" ^ 
    string_of_typecode t ^ ")"

  | `AST_expr (_,s,t) -> 
    "code ["^string_of_typecode t^"]" ^
    "'" ^ s ^ "'"
    
  | `AST_cond (_,(e,b1,b2)) -> 
    "if " ^ se e ^ 
    " then " ^ se b1 ^ 
    " else " ^ se b2 ^ 
    " endif"

  | `AST_typeof (_,e) -> "typeof("^se e^")"
  | `AST_as (_,(e1, name)) -> "(" ^ se e1 ^ ") as " ^ name  
  | `AST_get_n (_,(n,e)) -> "get (" ^ si n ^ ", " ^se e^")"
  | `AST_get_named_variable (_,(n,e)) -> "get (" ^ n ^ ", " ^se e^")"
  | `AST_get_named_method (_,(n,mix,ts,e)) -> 
    "get (" ^ n ^ "<" ^ si mix ^">"^"["^catmap "," string_of_typecode ts^"], " ^
    se e ^")"
  | `AST_map (_,f,e) -> "map (" ^ se f ^ ") (" ^ se e ^ ")"
  | `AST_deref (_,e) -> "*(" ^ se e ^ ")"
  | `AST_lvalue (_,e) -> "lvalue" ^ "(" ^ se e ^ ")"
  | `AST_lift (_,t) -> "lift " ^ "(" ^ se t ^ ")"
  | `AST_ref (_,e) -> "&" ^ "(" ^ se e ^ ")"
  | `AST_new (_,e) -> "new " ^ "(" ^ se e ^ ")"
  | `AST_literal (_,e) -> string_of_literal e
  | `AST_apply  (_,(fn, arg)) -> "(" ^ 
    sme fn ^ " " ^ 
    sme arg ^ 
    ")"

  | `AST_product (_,ts) ->
     cat "*" (map se ts)

  | `AST_sum (_,ts) ->
     cat "+" (map se ts)

  | `AST_setunion (_,ts) ->
     cat "||" (map se ts)

  | `AST_setintersection (_,ts) ->
     cat "&&" (map se ts)

  | `AST_intersect (_,ts) ->
     cat "&" (map se ts)

  | `AST_isin (_,(a,b)) ->
     sme a ^ " isin " ^ sme b

  | `AST_orlist (_,ts) ->
     cat " or " (map se ts)

  | `AST_andlist (_,ts) ->
     cat " and " (map se ts)

  | `AST_arrow (_,(a,b)) ->
    "(" ^ se a ^ " -> " ^ se b ^ ")"

  | `AST_longarrow (_,(a,b)) ->
    "(" ^ se a ^ " --> " ^ se b ^ ")"

  | `AST_superscript (_,(a,b)) ->
    "(" ^ se a ^ " ^ " ^ se b ^ ")"
    
  | `AST_method_apply  (_,(fn, arg,ts)) -> "(" ^ fn ^ 
    (match ts with 
    | [] -> "" 
    | _ -> "[" ^catmap "," string_of_typecode ts^ "]"
    ) ^ 
    " " ^ 
    se arg ^ 
    ")"

  | `AST_tuple (_,t) -> "(" ^ catmap ", " sme t ^ ")"

  | `AST_record (_,ts) -> "struct {" ^ 
      catmap "; " (fun (s,e) -> s ^ "="^ sme e ^";") ts ^ 
    "}"

  | `AST_record_type (_,ts) -> "struct {" ^ 
      catmap "; " (fun (s,t) -> s ^ ":"^ string_of_typecode t ^";") ts ^ 
    "}"

  | `AST_variant (_,(s,e)) -> "case " ^ s ^ " of (" ^ se e ^ ")"

  | `AST_variant_type (_,ts) -> "union {" ^ 
      catmap "; " (fun (s,t) -> s ^ " of "^ string_of_typecode t ^";") ts ^ 
    "}"

  | `AST_arrayof (_,t) -> "[|" ^ catmap ", " sme t ^ "|]"
  (*
  | `AST_dot (_,(e,n,ts)) ->  
    "get_" ^ n ^ 
    (match ts with | [] -> "" | _ -> "[" ^ catmap "," string_of_typecode ts^ "]")^
    "(" ^ se e ^ ")"
  *)

  | `AST_dot (_,(e1,e2)) ->  
    "(" ^ se e1 ^ "." ^ se e2 ^  ")"

  | `AST_lambda (_,(vs,paramss,ret, sts)) -> 
    "(fun " ^ print_vs vs ^
    catmap " "  
    (fun ps -> "(" ^ string_of_parameters ps ^ ")") paramss
    ^ 
    (match ret with
    | `TYP_none -> ""
    | _ -> ": " ^string_of_typecode ret) ^ 
    " = " ^
    string_of_compound 0 sts ^ ")"

  | `AST_ctor_arg (_,(cn,e)) ->
    "ctor_arg " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_case_arg (_,(n,e)) ->
    "case_arg " ^ si n ^ "(" ^
    se e ^ ")"

  | `AST_case_index (_,e) ->
    "caseno (" ^ se e ^ ")"

  | `AST_match_ctor (_,(cn,e)) ->
    "match_ctor " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_match_case (_,(v,e)) ->
    "match_case " ^ si v ^ "(" ^
    se e ^ ")"

  | `AST_sparse (_,e, nt,iis) ->
    "parse " ^ se e ^ " with " ^ nt ^ " endmatch"
    
  | `AST_parse (_,e, ms) ->
    "parse " ^ se e ^ " with\n" ^
    catmap ""
    (fun (_,p,e')->
      " | " ^
      string_of_production p ^
      " => " ^
      string_of_expr e' ^
      "\n"
    )
    ms
    ^ "endmatch"

  | `AST_match (_,(e, ps)) ->
    "match " ^ se e ^ " with\n" ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_pattern p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

(*
  | `AST_type_match (_,(e, ps)) ->
    "typematch " ^ string_of_typecode e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_tpattern p ^
      " => " ^
      string_of_typecode e'
    )
    ps
    ^
    " endmatch"
*)

  | `AST_type_match (_,(e, ps)) ->
    "typematch " ^ string_of_typecode e ^ " with " ^
    catmap ""
    (fun (p,e')->
      "\n  | " ^
      string_of_typecode p ^
      " => " ^
      string_of_typecode e'
    )
    ps
    ^
    "\n endmatch"

  | `AST_macro_ctor (_,(s,e)) ->
    "macro ctor " ^ s ^ string_of_expr e

  | `AST_macro_statements (_,ss) ->
    "macro statements begin\n" ^ 
    catmap "\n" (string_of_statement 1) ss ^ "\nend"

  | `AST_regmatch (_,(p1,p2, ps)) ->
    "regmatch " ^ se p1 ^ " to " ^ se p2 ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_string_regmatch (_,(s, ps)) ->
    "regmatch " ^ se s ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_reglex (_,(p1, p2, ps)) ->
    "reglex " ^ se p1 ^ " to " ^ se p2 ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_case (_,e1,ls,e2) ->
    "typecase [" ^
    String.concat "," ls ^
    "] " ^ se e1 ^ " => " ^ se e2 ^
    "endcase"

  | `AST_user_expr (_,name,term) ->
    let body = string_of_ast_term 0 term in
    "User expr " ^ name ^ "(" ^ body ^ ")"
 
(* precedences for type operators ..
   0 -- atomic
   0.5 -- indexing t[i]
   1 -- pointer
   2 -- application
   3 -- ^
   4 -- *
   5 -- +
   6 -- isin 
   7 .. and
   8 .. or
   9 -- ->
   10 -- =>
   11    as, all
*)


and st prec tc : string = 
  let iprec,txt =
    match tc with
    | #suffixed_name_t as t -> 0,string_of_suffixed_name t
    | `AST_patvar (sr,s) -> 0,"?"^s
    | `AST_patany sr -> 0,"ANY"
    | `TYP_none -> 0,"<none>"
    | `TYP_ellipsis-> 0,"..."

    | `TYP_type_match (e,ps) -> 0,
      "typematch " ^ string_of_typecode e ^ " with " ^
      catmap ""
      (fun (p,t) ->
      "\n  | " ^ string_of_typecode p ^ " => " ^ string_of_typecode t 
      )
      ps
      ^
      "\nendmatch"

    | `TYP_var i -> 0,"<var " ^ si i ^ ">"
    | `TYP_unitsum k ->
      0,
      begin match k with 
      | 0 -> "void"
      | 1 -> "unit"
      | 2 -> "bool"
      | _ -> si k
      end

    | `TYP_tuple ls ->
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 4, cat " * " (map (st 4) ls)
      end

    | `TYP_record ls ->
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 0, "struct {" ^ catmap "" (fun (s,t)->s^":"^st 0 t ^"; ") ls ^ "}"
      end

    | `TYP_variant ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | _ -> 0, "union {" ^ catmap "" (fun (s,t)->s^" of "^st 0 t ^"; ") ls ^ "}"
      end

    | `TYP_sum ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | [`TYP_tuple[];`TYP_tuple[]] -> 0,"bool" 
      | _ -> 5,cat " + " (map (st 5) ls)
      end

    | `TYP_typeset ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | _ -> 0,"{" ^ cat ", " (map (st 0) ls) ^  "}"
      end

    | `TYP_intersect ls ->
      let ls = filter (fun t -> t <> `TYP_tuple []) ls in
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 9,cat " & " (map (st 9) ls)
      end

    | `TYP_setintersection ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | _ -> 9,cat " && " (map (st 9) ls)
      end

    | `TYP_setunion ls ->
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 9,cat " || " (map (st 9) ls)
      end

    | `TYP_function (args, result) ->  
      9,st 9 args ^ " -> " ^ st 9 result

    | `TYP_cfunction (args, result) ->  
      9,st 9 args ^ " --> " ^ st 9 result

    | `TYP_array (vt,it) -> 3, st 1 vt ^ "^" ^ st 3 it
    
    | `TYP_pointer t -> 1,"&" ^ st 1 t
    | `TYP_lvalue t -> 0,"lvalue[" ^ st 1 t ^"]"
    
    | `TYP_typeof e -> 0,"typeof(" ^ string_of_expr e ^ ")"
    | `TYP_lift t -> 0,"lift(" ^ st 0 t ^ ")"
    | `TYP_as (t,s) -> 11,st 11 t ^ " as " ^ s

    | `TYP_proj (i,t) -> 2,"proj_"^si i^" "^ st 2 t
    | `TYP_dual t -> 2,"~"^ st 2 t
    | `TYP_dom t -> 2,"dom "^ st 2 t
    | `TYP_cod t -> 2,"cod "^st 2 t
    | `TYP_case_arg (i,t) -> 2,"case_arg_"^si i^" "^st 2 t
    | `TYP_case (t1,ls,t2) -> 0,
      "typecase [" ^
      String.concat "," ls ^
      "] " ^ st 0 t1 ^ " => " ^ st 0 t2 ^ " endcase"

    | `TYP_isin (t1,t2) -> 6,st 2 t1 ^ " isin " ^ st 6 t2

    | `TYP_apply (t1,t2) -> 2,st 2 t1 ^ " " ^ st 2 t2
    | `TYP_type -> 0,"TYPE"
    | `TYP_type_tuple ls ->
      4, cat ", " (map (st 4) ls)

    | `TYP_glr_attr_type qn -> 
       0,"glr_attr_type(" ^string_of_qualified_name qn^ ")"
       
    | `TYP_typefun (args,ret,body) -> 
       10,
       (
         "fun(" ^ cat ", " 
         (
           map 
           (fun (n,t)-> n ^ ": " ^ st 10 t) 
           args
         ) ^
         "): " ^ st 0 ret ^ "=" ^ st 10 body
       )
  in
    if iprec >= prec 
    then "(" ^ txt ^ ")" 
    else txt

and string_of_typecode tc = st 99 tc

and qualified_name_of_index_with_vs dfns index = 
  match Hashtbl.find dfns index with 
  | { id=id; vs=vs; parent=parent} ->
    match parent with
    | Some index' ->
      qualified_name_of_index_with_vs dfns index' ^ 
      id ^ 
      print_ivs vs ^ 
      "::"
    | None -> ""
      (* If this entity has no parent, its the root module,
        and we don't bother to print its name as a prefix
      *)

and qualified_name_of_index' dfns index = 
  match Hashtbl.find dfns index with 
  | { id=id; parent=parent } ->
    begin match parent with
    | Some index' -> qualified_name_of_index_with_vs dfns index' 
    | None -> ""
    end ^
    id

and qualified_name_of_index dfns index = 
  try qualified_name_of_index' dfns index ^ "<"^si index ^">"
  with Not_found -> "index_"^ si index

and get_name_parent dfns bbdfns index =
  try 
    match Hashtbl.find dfns index with 
    { id=id; vs=vs; parent=parent} -> id, parent
  with Not_found ->
  try
    match Hashtbl.find bbdfns index with 
    id,parent,_,_ -> id,parent
  with Not_found -> "index_" ^ string_of_int index,None


and qualified_name_of_bindex dfns bbdfns index = 
  let name,parent = get_name_parent dfns bbdfns index in
  match parent with
  | Some index' ->
    qualified_name_of_bindex dfns bbdfns index' ^ "::" ^ name
  | None -> name

and bound_name_of_bindex dfns bbdfns index =
  let name,parent = get_name_parent dfns bbdfns index in
  name ^ "<" ^ si index ^ ">"

(* fixppoint labeller .. very sloppy, ignores precedence .. *)
and get_label i =
  if i = 0 then "" 
  else 
    let ch = Char.chr (i mod 26 + Char.code('a')-1) in
    get_label (i/26) ^ String.make 1 ch
  
and print_fixpoints depth fixlist =
  match fixlist with
  | (d,lab) :: t when d = depth -> 
    let txt,lst = print_fixpoints depth t in
    " as " ^ lab ^ " " ^ txt, lst
  | _ -> "", fixlist
  
and sb dfns depth fixlist counter prec tc = 
  let sbt prec t = sb dfns (depth+1) fixlist counter prec t in
  let iprec, term = 
    match tc with
    | `BTYP_type_match (t,ps) ->
      0,
      (
        "typematch " ^
        sbt 99 t ^
        " with" ^
        catmap ""
        (fun ({pattern=p},t) ->
          "\n  | " ^ sbt 99 p ^ " => " ^ sbt 99 t 
        )
        ps 
        ^
        "\nendmatch"
      )

    | `BTYP_fix i ->
       0,
       (
         try assoc (depth+i) !fixlist
         with Not_found ->
           incr counter; (* 'a is 1 anyhow .. *)
           let lab = "fix" ^ si i ^ "_"^get_label !counter in
           fixlist := (depth+i,lab) :: !fixlist;
           lab 
       )

    | `BTYP_var (i,mt) -> 0,"<T" ^ si i ^ 
      (match mt with `BTYP_type i ->"" | _ -> ":"^sbt 0 mt)^
      ">"

    | `BTYP_inst (i,ts) -> 
      0,qualified_name_of_index dfns i ^ 
      (if List.length ts = 0 then "" else
      "[" ^cat ", " (map (sbt 9) ts) ^ "]"
      )

    | `BTYP_tuple ls -> 
      begin match ls with 
      | [] -> 0,"unit" 
      | [x] -> failwith ("UNEXPECTED TUPLE OF ONE ARGUMENT " ^ sbt 9 x)
      | _ -> 4,cat " * " (map (sbt 4) ls)
      end

    | `BTYP_record ls -> 
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 0,"struct {"^catmap "" (fun (s,t)->s^":"^sbt 0 t^";") ls ^"}"
      end

    | `BTYP_variant ls -> 
      begin match ls with 
      | [] -> 0,"void" 
      | _ -> 0,"union {"^catmap "" (fun (s,t)->s^" of "^sbt 0 t^";") ls ^"}"
      end

    | `BTYP_unitsum k -> 
      begin match k with
      | 0 -> 0,"/*unitsum*/void"
      | 2 -> 0,"bool"
      | _ -> 0,si k
      end

    | `BTYP_sum ls -> 
      begin match ls with 
      | [] -> 9,"UNEXPECTED EMPTY SUM = void" 
      | [`BTYP_tuple[]; `BTYP_tuple[]] -> 0,"unexpected bool"
      | [x] -> (* failwith *) (9,"UNEXPECTED SUM OF ONE ARGUMENT " ^ sbt 9 x)
      | _ -> 
        if (all_units ls)
        then
          0,si (length ls)
        else
          5,cat " + " (map (sbt 5) ls)
      end

    | `BTYP_typeset ls -> 
      begin match ls with 
      | [] -> 9,"UNEXPECTED EMPTY TYPESET = void" 
      | _ -> 
          0,"{" ^ cat "," (map (sbt 0) ls) ^ "}"
      end

    | `BTYP_intersect ls -> 
      begin match ls with 
      | [] -> 9,"/*intersect*/void" 
      | _ -> 
          4,cat " and " (map (sbt 5) ls)
      end

    | `BTYP_typesetintersection ls -> 
      begin match ls with 
      | [] -> 9,"/*typesetintersect*/void" 
      | _ -> 
          4,cat " && " (map (sbt 5) ls)
      end

    | `BTYP_typesetunion ls -> 
      begin match ls with 
      | [] -> 9,"/*typesetunion*/unit" 
      | _ -> 
          4,cat " || " (map (sbt 5) ls)
      end

    | `BTYP_function (args, result) ->  
      6,(sbt 6 args) ^ " -> " ^ (sbt 6 result)

    | `BTYP_cfunction (args, result) ->  
      6,(sbt 6 args) ^ " --> " ^ (sbt 6 result)

    | `BTYP_array (t1,t2) -> 
      begin match t2 with 
      | `BTYP_unitsum k -> 3, sbt 3 t1 ^"^"^si k
      | _ -> 3, sbt 3 t1 ^"^"^sbt 3 t2
      end

    | `BTYP_lvalue t -> 0,"lvalue[" ^ sbt 0 t ^"]"
    | `BTYP_lift t -> 0,"lift[" ^ sbt 0 t ^"]"
    | `BTYP_pointer t -> 1,"&" ^ sbt 1 t
    | `BTYP_void -> 0,"void"
    
    | `BTYP_apply (t1,t2) -> 2,sbt 2 t1 ^ " " ^ sbt 2 t2
    | `BTYP_type i -> 0,"TYPE " ^ si i
    | `BTYP_type_tuple ls ->
      begin match ls with
      | [] -> 0,"UNEXPECTED TYPE TUPLE NO ARGS"
      | _ -> 4, cat ", " (map (sbt 4) ls)
      end


    | `BTYP_typefun (args,ret,body) -> 
       8,
       (
         "fun (" ^ cat ", " 
         (
           map 
           (fun (i,t)-> "T"^si i ^ ": " ^ sbt 8 t) 
           args
         ) ^
         "): " ^ sbt 0 ret ^ "=" ^ sbt 8 body
       )
     | `BTYP_case (pat,vars,res) ->
       8,
       sbt 8 pat ^
       "-->" ^
       Flx_mtypes1.string_of_intset vars ^
       " " ^
       sbt 8 res
  in
    let txt,lst = print_fixpoints depth !fixlist in
    fixlist := lst;
    if txt = "" then
      if iprec >= prec then "(" ^ term ^ ")"
      else term
    else
    "(" ^ term ^ txt ^ ")"

and string_of_btypecode (dfns:symbol_table_t) tc = 
  let fixlist = ref [] in
  let term = sb dfns 0 fixlist (ref 0) 99 tc in
  let bad = ref "" in
  while List.length !fixlist > 0 do
    match !fixlist with
    | (d,v)::t ->
      bad := !bad ^ " [Free Fixpoint " ^ si d ^ " " ^ v ^"]";
      fixlist := t
    | [] -> assert false
  done;
  term ^ !bad

and sbt a b = string_of_btypecode a b

and string_of_basic_parameters (ps: simple_parameter_t list) =
  cat 
    ", " 
    (map (fun (x,y)-> x ^ ": "^(string_of_typecode y)) ps)

and string_of_param_kind = function 
  | `PVal -> "val"
  | `PVar -> "var"
  | `PRef -> "ref"
  | `PFun -> "fun"

and string_of_parameters (ps:params_t) = 
  let ps, traint = ps in
  cat 
    ", " 
    (map 
      (fun (k,x,y,d)-> 
        string_of_param_kind k^ " " ^ 
        x ^ ": "^(string_of_typecode y) ^
        (match d with None -> "" | Some e -> "="^ string_of_expr e)
      ) 
      ps
     )
  ^
  (match traint with
  | Some x -> " where " ^ string_of_expr x
  | None -> ""
  )

(*
and string_of_iparameters dfns ps = 
  let ps,traint = ps in
  cat 
    ", " 
    (map (fun (x,(i,y))-> x ^ "["^si i^"]: "^(string_of_typecode y)) ps)
  ^
  (match traint with
  | Some x ->  " where " ^ sbe dfns bbdfns x
  | None -> ""
  )
*)

and string_of_basic_bparameters dfns ps : string = 
  catmap ","
  (fun {pid=x; pkind=kind; pindex=i; ptyp=y}-> 
    string_of_param_kind kind ^ " " ^ x ^ "<"^si i^">: "^(string_of_btypecode dfns y)
  ) 
  ps

and string_of_bparameters dfns bbdfns ps : string = 
  let ps, traint = ps in
  string_of_basic_bparameters dfns ps
  ^
  (match traint with
  | Some x -> " where " ^ sbe dfns bbdfns x
  | None -> ""
  )

and string_of_arguments ass = 
  catmap ", " string_of_expr ass

 
and string_of_component level (name, typ) = 
   spaces level ^ name ^ ": " ^ (string_of_typecode typ)

and string_of_float_pat = function
  | Float_plus (t,v) -> v ^ t
  | Float_minus (t,v) -> "-" ^ v ^ t
  | Float_inf -> "inf"
  | Float_minus_inf -> "-inf"

and string_of_tpattern p =
  let sp p = string_of_tpattern p in
  match p with
  | `TPAT_function (p1,p2) -> sp p1 ^ " -> " ^ sp p2
  | `TPAT_sum ps -> catmap " + " sp ps
  | `TPAT_tuple ps -> catmap " * " sp ps
  | `TPAT_pointer p -> "&" ^ sp p
  | `TPAT_void -> "0"
  | `TPAT_var s -> "?" ^ s
  | `TPAT_name (s,ps) -> 
    s ^ 
    (
      match ps with
      | [] -> ""
      | ps -> "[" ^ catmap "," sp ps ^ "]"
    )
  
  | `TPAT_as (p,s) -> sp p ^ " as " ^ s
  | `TPAT_any -> "_"
  | `TPAT_unitsum j -> si j
  | `TPAT_type_tuple ps -> catmap ", " sp ps

and string_of_pattern p = 
  let se e = string_of_expr e in
  match p with
  | `PAT_coercion (_,p,t) -> "(" ^ string_of_pattern p ^ ":" ^ string_of_typecode t ^ ")"
  | `PAT_none _ -> "<none>"
  | `PAT_nan _ -> "NaN"
  | `PAT_int (_,t,i) -> string_of_bigint i ^ suffix_of_type t
  | `PAT_int_range (_,t1,i1,t2,i2) -> 
    string_of_bigint i1 ^ suffix_of_type t1 ^
    " .. " ^ 
    string_of_bigint i2 ^ suffix_of_type t2
    
  | `PAT_string (_,s) -> string_of_string s
  | `PAT_string_range (_,s1, s2) -> 
    string_of_string s1 ^ " .. " ^ string_of_string s2
  | `PAT_float_range (_,x1, x2) -> 
    string_of_float_pat x1 ^ " .. " ^ string_of_float_pat x2
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_pattern ps ^ ")"
  | `PAT_any _ -> "any"
  | `PAT_regexp (_,r,b) -> 
    "regexp " ^ string_of_string r ^
    "(" ^ cat ", " b ^ ")"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_pattern p
  | `PAT_as (_,p,n) -> 
    begin match p with
    | `PAT_any _ -> n
    | _ ->
      "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
    end
  | `PAT_when (_,p,e) -> "(" ^ string_of_pattern p ^ " when " ^ se e ^ ")"
  | `PAT_record (_,ps) -> 
     "struct { " ^ catmap "; " (fun (s,p) -> s ^ "="^string_of_pattern p) ps ^"; }"
 
and string_of_letpat p = 
  match p with
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_letpat ps ^ ")"
  | `PAT_any _ -> "_"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_letpat p
  | `PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | `PAT_record (_,ps) -> 
     "struct { " ^ catmap "; " (fun (s,p) -> s ^ "="^string_of_pattern p) ps ^"; }"
     
  | _ -> failwith "unexpected pattern kind in let/in pattern" 
 
and string_of_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_statement (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_compound level ss

and string_of_asm_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_asm (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_asm_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_asm_compound level ss

and special_string_of_typecode ty =  (* used for constructors *)
  match ty with
  | `TYP_tuple [] -> ""
  | _ -> " of " ^ string_of_typecode ty

and special_string_of_btypecode dfns ty =  (* used for constructors *)
  match ty with
  | `BTYP_tuple [] -> ""
  | _ -> " of " ^ string_of_btypecode dfns ty

and string_of_macro_parameter_type = function
  | Expr -> "fun"
  | Ident -> "ident"
  | Stmt -> "proc"
 
and print_ixs = function
  | [] -> ""
  | ixs -> "[" ^ cat ", " ixs ^ "]"

(*
and string_of_maybe_tpattern = function
  | `TPAT_any -> ""
  | t -> ": " ^ string_of_tpattern t
*)

and string_of_maybe_tpattern = function
  | `AST_patany _ -> ""
  | t -> ": " ^ string_of_typecode t

and print_tconstraint = function
  | `TYP_tuple [] -> ""
  | `TYP_intersect [`TYP_tuple []] -> ""
  | t -> let x = string_of_typecode t in
    if x <> "unit" then " where " ^ x else ""

and print_tclass_req qn = string_of_qualified_name qn
  
and print_tclass_reqs = function
  | [] -> ""
  | t -> " with " ^ catmap "," print_tclass_req t

and print_tcon {raw_type_constraint=tcon; raw_typeclass_reqs=rtcr} =
  print_tconstraint tcon ^ print_tclass_reqs rtcr 

and print_ivs (vs,({raw_type_constraint=tcon; raw_typeclass_reqs=rtcr} as con)) =
  match vs,tcon,rtcr with
  | [],`TYP_tuple [],[] -> ""
  | _ -> 
    "[" ^ cat ", " (map (fun (name,ix,tpat) -> name ^ string_of_maybe_tpattern tpat) vs) ^ 
    print_tcon con ^
    "]"

and print_ivs_with_index (vs,({raw_type_constraint=tcon; raw_typeclass_reqs=rtcr} as con)) =
  match vs,tcon,rtcr with
  | [],`TYP_tuple [],[] -> ""
  | _ -> 
    "[" ^ cat ", " (map (fun (name,ix,tpat) -> name ^ "<"^si ix^">"^string_of_maybe_tpattern tpat) vs) ^ 
    print_tcon con ^
    "]"

and print_vs (vs,({raw_type_constraint=tcon; raw_typeclass_reqs=rtcr} as con)) =
  match vs,tcon,rtcr with
  | [],`TYP_tuple [],[] -> ""
  | _ -> 
    "[" ^ 
    cat ", " 
    (map (fun (name,tpat) -> name ^ string_of_maybe_tpattern tpat) vs) ^ 
    print_tcon con ^
    "]"

and print_bvs = function
  | [] -> ""
  | vs -> 
    "[" ^ 
    cat ", " 
    (
      map 
      (fun (s,i)-> s^"<"^si i^">" ) 
      vs
    ) ^
    "]"

and print_bvs_cons dfns vs cons = match vs,cons with
 | [],`BTYP_tuple [] -> ""
 | vs,cons ->
   "[" ^ catmap "," (fun (s,i)->s^"<"^si i^">") vs ^
   (if cons = `BTYP_tuple[] then "" 
   else " where " ^ sbt dfns cons) ^
   "]"

and print_inst dfns = function
  | [] -> ""
  | ts -> 
    "[" ^ 
    cat ", " 
    (
      map (string_of_btypecode dfns) ts 
    ) ^
    "]"

and sl x = string_of_lvalue x 
and string_of_lvalue (x,t) = 
  begin match x with
  | `Val (sr,x) -> "val " ^ x
  | `Var (sr,x) -> "var " ^ x
  | `Name (sr,x) -> x
  | `Skip (sr) -> "_"
  | `List ls -> "(" ^ catmap ", " sl ls ^ ")"
  | `Expr (sr,e) -> string_of_expr e
  end ^
  begin match t with
  | Some t -> ":" ^ string_of_typecode t
  | None -> ""
  end

and string_of_property = function
| `Recursive -> "recursive"
| `Inline -> "inline"
| `Generated s -> "generated " ^ s
| `NoInline -> "noinline"
| `Inlining_started -> "inlining_started"
| `Inlining_complete -> "inlining_complete"
| `Explicit_closure -> "explicit_closure_expression"
| `Stackable -> "stackable"
| `Unstackable -> "unstackable"
| `Heap_closure -> "heap_closure"
| `Stack_closure -> "stack_closure"
| `Pure -> "pure"
| `Uses_global_var-> "uses_global_var"
| `Requires_ptf -> "requires_thread_frame"
| `Not_requires_ptf -> "does_not_require_thread_frame"
| `Uses_gc -> "uses_gc"
| `Ctor -> "ctor"
| `Generator -> "generator"
| `Yields -> "yields"
| `Virtual -> "virtual"
| `Cfun -> "cfun"

and string_of_properties ps =
  match ps with 
  | [] -> ""
  | ps -> catmap " " string_of_property ps
  
and string_of_code_spec = function
  | `StrTemplate s -> "\"" ^ s ^  "\""
  | `Str s -> "c\"" ^ s ^  "\""
  | `Virtual -> "virtual"
  | `Identity -> "identity"

and string_of_long_code_spec c = 
  let triple_quote = "\"\"\"" in
  match c with
  | `StrTemplate s -> triple_quote ^ s ^ triple_quote
  | `Str s -> "c" ^ triple_quote ^ s ^ triple_quote
  | `Virtual -> "virtual"
  | `Identity -> "identity"

and string_of_raw_req = function 
  | `Named_req s -> string_of_qualified_name s
  | `Body_req c -> "body " ^ string_of_code_spec c
  | `Header_req c -> "header " ^ string_of_code_spec c
  | `Property_req s -> "property \"" ^ s ^ "\""
  | `Package_req c -> "package " ^ string_of_code_spec c

(* fairly lame excess brackets here *)
and string_of_raw_req_expr = function
  | `RREQ_atom r -> string_of_raw_req r
  | `RREQ_and (a,b) -> "(" ^ string_of_raw_req_expr a ^ ") and (" ^ string_of_raw_req_expr b ^")"
  | `RREQ_or (a,b) -> "(" ^ string_of_raw_req_expr a ^ ") or (" ^ string_of_raw_req_expr b ^")"
  | `RREQ_true -> "(true)"
  | `RREQ_false -> "(false)"

(* fairly lame excess brackets here *)
and string_of_named_req_expr = function
  | `NREQ_atom r -> string_of_qualified_name r
  | `NREQ_and (a,b) -> "(" ^ string_of_named_req_expr a ^ ") and (" ^ string_of_named_req_expr b ^")"
  | `NREQ_or (a,b) -> "(" ^ string_of_named_req_expr a ^ ") or (" ^ string_of_named_req_expr b ^")"
  | `NREQ_true -> "(true)"
  | `NREQ_false -> "(false)"

and string_of_raw_reqs x = match x with
  | `RREQ_true -> "" (* required nothing *)
  | x -> " requires " ^ string_of_raw_req_expr x

and string_of_named_reqs x = match x with
  | `NREQ_true -> "" (* requires nothing *)
  | x -> " requires " ^ string_of_named_req_expr x

and string_of_base_qual = function 
| `Incomplete -> "incomplete"
| `Pod -> "pod"
| `GC_pointer -> "GC_pointer"

and string_of_qual = function 
| #base_type_qual_t as x -> string_of_base_qual x
| `Raw_needs_shape t -> "needs_shape(" ^ string_of_typecode t ^ ")"

and string_of_bqual dfns = function 
| #base_type_qual_t as x -> string_of_base_qual x
| `Bound_needs_shape t -> "needs_shape(" ^ string_of_btypecode dfns t ^ ")"

and string_of_quals qs = catmap " " string_of_qual qs
and string_of_bquals dfns qs = catmap " " (string_of_bqual dfns) qs

and string_of_ast_term level (term:ast_term_t) = 
  let sast level x = string_of_ast_term level x in
  match term with
  | `Statement_term s -> string_of_statement (level+1) s
  | `Statements_term ss -> catmap "\n" (string_of_statement (level+1)) ss
  | `Expression_term e -> string_of_expr e
  | `Identifier_term s -> s
  | `Keyword_term s -> s
  | `Apply_term (t,ts) -> "apply("^ sast 0 t ^ ",(" ^ catmap ", " (sast 0) ts ^ "))"

and dfltvs = [], {raw_type_constraint=`TYP_tuple []; raw_typeclass_reqs=[]}
and dfltivs = [], {raw_type_constraint=`TYP_tuple []; raw_typeclass_reqs=[]}
and string_of_class_component level mem =
  let kind, name, mix,vs,ty,cc = match mem with
  | `MemberVar (name,typ,cc) -> "var",name,None,dfltvs,typ,cc
  | `MemberVal (name,typ,cc) -> "val",name,None,dfltvs,typ,cc
  | `MemberFun (name,mix,vs,typ,cc) -> "fun",name,mix,vs,typ,cc
  | `MemberProc (name,mix,vs,typ,cc) -> "proc",name,mix,vs,typ,cc
  | `MemberCtor (name,mix,typ,cc) -> "ctor",name,mix,dfltvs,typ,cc
  in
    (spaces (level+1)) ^ 
    kind ^ " " ^ name ^ print_vs vs ^ ": " ^ string_of_typecode ty ^ 
    (match cc with None -> "" | Some cc -> string_of_code_spec cc) ^
    ";"

and string_of_ikind = function
  | `Header -> "header "
  | `Body -> "body "
  | `Package -> "package "

and string_of_axiom_method a = match a with
  | `Predicate e -> string_of_expr e
  | `Equation (l,r) -> string_of_expr l ^ " = " ^ string_of_expr r

and string_of_baxiom_method dfns bbdfns a = match a with
  | `BPredicate e -> string_of_expr e
  | `BEquation (l,r) -> sbe dfns bbdfns l ^ " = " ^ sbe dfns bbdfns r

and string_of_statement level s = 
  let se e = string_of_expr e in
  let sqn n = string_of_qualified_name n in
  match s with 
  | `AST_seq (_,sts) -> catmap "" (string_of_statement level) sts
  (*
  | `AST_public (_,s,st) ->
    "\n" ^
    spaces level ^ "public '" ^ s ^ "'\n" ^
    string_of_statement (level+1) st
  *)

  | `AST_private (_,st) ->
    spaces level ^ "private " ^
    string_of_statement 0 st

  | `AST_export_fun (_,flx_name,cpp_name) -> 
    spaces level ^ 
    "export fun " ^ 
    string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `AST_export_type (_,flx_type,cpp_name) -> 
    spaces level ^ 
    "export type (" ^ 
    string_of_typecode flx_type ^ 
    ") as \"" ^ cpp_name ^ "\";"

  | `AST_label (_,s) -> s ^ ":"
  | `AST_goto (_,s) -> spaces level ^ "goto " ^ s ^ ";"

  | `AST_assert (_,e) -> spaces level ^ "assert " ^ se e ^ ";"

  | `AST_apply_ctor (_,i1,f,a) ->
    spaces level ^ i1 ^ " <- new " ^ se f ^ "(" ^ se a ^ ");"

  | `AST_init (_,v,e) ->
    spaces level ^ v ^ " := " ^ se e ^ ";"

  | `AST_comment (_,s) -> spaces level ^ "// " ^ s

  | `AST_open (_,vs,n) -> 
    spaces level ^ "open" ^ print_vs vs ^ " " ^ sqn n ^ ";"

  | `AST_inject_module (_,n) -> 
    spaces level ^ "include " ^ sqn n ^ ";"

  | `AST_include (_,s) -> 
    spaces level ^ "include " ^ s ^ ";"

  | `AST_cparse (_,s) ->
    spaces level ^ "cparse \"\"\"\n" ^ s ^ "\n\"\"\";"

  
  | `AST_use (_,n,qn) -> 
    spaces level ^ "use " ^ n ^ " = " ^ sqn qn ^ ";"

  | `AST_regdef (_,n,r) -> 
    spaces level ^ "regdef " ^ n ^ " = " ^string_of_re r^";"

  | `AST_glr (_,n,t,ps) -> 
    spaces level ^ "nonterm " ^ n ^ " : " ^string_of_typecode t ^
    catmap ""
    (fun (_,p,e')->
      spaces (level + 1) ^ " | " ^
      string_of_production p ^
      " => " ^
      string_of_expr e' ^
      "\n"
    )
    ps
    ^
    spaces level ^ ";"
  

  | `AST_type_alias (_,t1,vs,t2) ->
    spaces level ^ "typedef " ^ t1 ^ print_vs vs ^
    " = " ^ 
    string_of_typecode t2 ^ ";"

  | `AST_inherit (_,name,vs,qn) ->
    spaces level ^ "inherit " ^ name ^ print_vs vs ^
    " = " ^ 
    string_of_qualified_name qn ^ ";"

  | `AST_inherit_fun (_,name,vs,qn) ->
    spaces level ^ "inherit fun " ^ name ^ print_vs vs ^
    " = " ^ 
    string_of_qualified_name qn ^ ";"

  | `AST_untyped_module (_,name, vs,sts)  -> 
    spaces level ^ "module " ^ name ^ print_vs vs ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts
  
  | `AST_namespace (_,name, vs,sts)  -> 
    spaces level ^ "namespace " ^ name ^ print_vs vs ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts


  | `AST_struct (_,name, vs, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_cstruct (_,name, vs, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "cstruct " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_cclass (_,name, vs, cs) -> 
    spaces level ^ "cclass " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" (string_of_class_component level) cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_typeclass (_,name, vs, sts) -> 
    spaces level ^ "typeclass " ^ name ^ print_vs vs ^ " = " ^
    string_of_compound level sts
  
  | `AST_instance (_,vs,name, sts) -> 
    spaces level ^ "instance " ^ print_vs vs ^ " " ^
    string_of_qualified_name name ^ " = " ^
    string_of_compound level sts


  | `AST_class (_,name, vs, sts) -> 
    spaces level ^ "class " ^ name ^ print_vs vs ^ " = " ^
    string_of_compound level sts

  | `AST_union (_,name, vs,cs) -> 
    let string_of_union_component (name,cval, vs,ty) =
      (spaces (level+1)) ^ "|" ^ name ^ 
      (match cval with None -> "" | Some i -> "="^ si i) ^
      special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_ctypes (_,names, quals, reqs) -> spaces level ^ 
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "ctypes " ^ catmap "," snd names ^ 
    string_of_raw_reqs reqs ^
    ";"

  | `AST_abs_decl (_,t,vs, quals, ct, reqs) -> spaces level ^ 
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ t ^ print_vs vs ^
    " = " ^ string_of_code_spec ct ^ 
    string_of_raw_reqs reqs ^
    ";"

  | `AST_newtype (_,t,vs, nt) -> spaces level ^ 
    "type " ^ t ^ print_vs vs ^
    " = new " ^ string_of_typecode nt ^
    ";"

  | `AST_callback_decl (_,name,args,result, reqs) -> spaces level ^ 
    "callback " ^ name ^ ": " ^ 
    (string_of_typecode (`TYP_tuple args)) ^ " -> " ^
    (string_of_typecode result) ^ 
    string_of_raw_reqs reqs ^
    ";"

  | `AST_fun_decl (_,name,vs,args, result, code, reqs,prec) ->
    spaces level ^ 
    "fun " ^ name ^ print_vs vs ^
    ": " ^ 
    (string_of_typecode (`TYP_tuple args)) ^ " -> " ^
    (string_of_typecode result) ^ 
    " = " ^ string_of_code_spec code ^ 
    (if prec = "" then "" else ":"^prec^" ")^
    string_of_raw_reqs reqs ^
    ";"

  | `AST_const_decl (_,name,vs,typ, code, reqs) ->
    spaces level ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_code_spec code^ 
     string_of_raw_reqs reqs ^
     ";" 

  | `AST_insert (_,n,vs,s, ikind, reqs) -> 
    spaces level ^ string_of_ikind ikind ^
    n^print_vs vs^ 
    "\n" ^ string_of_code_spec s ^ " " ^
     string_of_raw_reqs reqs ^
    ";\n"

  | `AST_code (_,s) -> 
    "code \n" ^ string_of_long_code_spec s ^ ";\n"

  | `AST_noreturn_code (_,s) -> 
    "noreturn_code \n" ^ string_of_long_code_spec s ^ ";\n"

  | `AST_reduce (_,name, vs, ps, rsrc, rdst) -> 
    spaces level ^ 
    "reduce " ^ name ^ print_vs vs ^ 
    "("^string_of_basic_parameters ps^"): "^
    string_of_expr rsrc ^ " => " ^ string_of_expr rdst ^
    ";\n"

  | `AST_axiom (_,name, vs, ps, a) -> 
    spaces level ^ 
    "axiom " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^"): "^
    string_of_axiom_method a ^ 
    ";\n"

  | `AST_lemma (_,name, vs, ps, a) -> 
    spaces level ^ 
    "lemma " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^"): "^
    string_of_axiom_method a ^ 
    ";\n"

  | `AST_function (_,name, vs, ps, (res,post), props, ss) -> 
    spaces level ^ 
    string_of_properties props ^
    "fun " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^"): "^string_of_typecode res^
    (match post with
    | None -> ""
    | Some x -> " when " ^ string_of_expr x
    )^
    begin match ss with
    | [`AST_fun_return (_,e)] -> " => " ^ se e ^ ";\n"
    | _ -> "\n" ^ string_of_compound level ss
    end

  | `AST_curry (_,name, vs, pss, (res,traint) , kind, ss) -> 
    spaces level ^ 
    (match kind with 
    | `Function -> "fun " 
    | `CFunction -> "cfun " 
    | `Object -> "obj " 
    | `InlineFunction -> "inline fun "
    | `NoInlineFunction -> "noinline fun "
    | `Virtual -> "virtual fun "
    | `Ctor -> "ctor "
    | `Generator -> "generator "
    )
    ^ 
    name ^ print_vs vs ^ 
    catmap " " 
    (fun ps ->
      "("^string_of_parameters ps^")"
    )
    pss
    ^ 
    ": "^string_of_typecode res^
    (match traint with
    | None -> ""
    | Some x -> " when " ^ string_of_expr x
    )^
    begin match ss with
    | [`AST_fun_return (_,e)] -> " => " ^ se e ^ ";\n"
    | _ -> "\n" ^ string_of_compound level ss
    end


  | `AST_object (_,name, vs, ps, ss) -> 
    spaces level ^ 
    "object " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^")\n" ^
    string_of_compound level ss

  | `AST_macro_val (_,names, e) ->
    spaces level ^ 
    "macro val " ^ String.concat ", " names ^ " = " ^
    se e ^
    ";"

  | `AST_macro_vals (_,name, es) ->
    spaces level ^ 
    "macro val " ^ name ^ " = " ^
    catmap ", " se es ^
    ";"

  | `AST_macro_var (_,names, e) ->
    spaces level ^ 
    "macro var " ^ String.concat ", " names ^ " = " ^
    se e ^
    ";"

  | `AST_macro_assign (_,names, e) ->
    spaces level ^ 
    "macro " ^ String.concat ", " names ^ " = " ^
    se e ^
    ";\n"

  | `AST_macro_name (_,lname, rname) ->
    spaces level ^ 
    "macro ident " ^ lname ^ " = " ^
    (match rname with | "" -> "new" | _ -> rname) ^
    ";"

  | `AST_macro_names (_,lname, rnames) ->
    spaces level ^ 
    "macro ident " ^ lname ^ " = " ^
    cat ", " rnames ^
    ";"
    

  | `AST_expr_macro (_,name, ps, e) -> 
    let sps = 
      map 
      (fun (p,t) -> p ^ ":" ^ string_of_macro_parameter_type t) 
      ps 
    in
    spaces level ^ 
    "macro fun " ^ name ^ 
    "("^ cat ", " sps ^") = " ^
    se e ^
    ";"

  | `AST_stmt_macro (_,name, ps, ss) -> 
    let sps = 
      map 
      (fun (p,t) -> p ^ ":" ^ string_of_macro_parameter_type t) 
      ps 
    in
    spaces level ^ 
    "macro proc " ^ name ^ 
    "("^ cat ", " sps ^") " ^
    short_string_of_compound level ss

  | `AST_macro_block (_,ss) -> 
    spaces level ^ 
    "macro " ^
    short_string_of_compound level ss ^
    "}"

  | `AST_macro_forget (_,names) ->
    spaces level ^ 
    "macro forget" ^
    (
      match names with
      | [] -> ""
      | _ -> " "
    ) ^
    cat ", " names ^ 
    ";"

  | `AST_macro_label (_,id) ->
    "macro " ^ id ^ ":>\n"

  | `AST_macro_goto (_,id) ->
    "macro goto " ^ id ^ ";\n"

  | `AST_macro_ifgoto (_,e,id) ->
    "macro if "^se e^" goto " ^ id ^ ";\n"

  | `AST_macro_proc_return (_) ->
    "macro return;\n"

  | `AST_val_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "val " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_ref_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "ref " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"


  | `AST_lazy_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "fun " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_var_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "var " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_macro_ifor (_,v,ids,sts) ->
    spaces level
    ^ "macro for ident " ^ v ^ " in " ^ cat "," ids ^ " do\n" ^ 
    catmap "\n" (string_of_statement (level +2)) sts ^
    spaces level ^ "done;"

  | `AST_macro_vfor (_,v,e,sts) ->
    let se e = string_of_expr e in
    spaces level
    ^ "macro for val " ^ String.concat ", " v ^ " in " ^ se e ^ " do\n" ^ 
    catmap "\n" (string_of_statement (level +2)) sts ^
    spaces level ^ "done;"

  | `AST_call (_,pr, args) ->
    spaces level
    ^ "call " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_assign (_,name,l,r) ->
    spaces level
    ^ "call " ^ name ^ "(" ^ sl l ^ "," ^se r^");"

  | `AST_cassign (_,l,r) ->
    spaces level ^
    se l ^ " = " ^ se r ^ ";"

  | `AST_jump (_,pr, args) ->
    spaces level
    ^ "jump " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_loop (_,pr, args) ->
    spaces level
    ^ "call " ^ pr ^ " " ^ se args ^ ";"

  | `AST_nop (_,s) -> spaces level ^ "{/*"^s^"*/;}"

  | `AST_ifgoto (_,e,lab) ->
    spaces level ^
    "if("^string_of_expr e^")goto " ^ lab ^ ";"

  (*
  | `AST_whilst (_,e,sts) ->
    spaces level ^
    "whilst "^string_of_expr e^" do\n" ^ 
    catmap "\n" (string_of_statement (level+1)) sts ^
    spaces level ^ "done;"

  | `AST_until (_,e,sts) ->
    spaces level ^
    "until "^string_of_expr e^" do\n" ^ 
    catmap "\n" (string_of_statement (level+1)) sts ^
    spaces level ^ "done;"
   *)

  | `AST_ifreturn (_,e) ->
    spaces level ^
    "if("^string_of_expr e^")return;" 

  | `AST_ifdo (_,e,ss1,ss2) ->
    spaces level ^
    "if("^string_of_expr e^")do\n" ^
    catmap "\n" (string_of_statement (level+1)) ss1 ^
    spaces level ^ "else\n" ^
    catmap "\n" (string_of_statement (level+1)) ss2 ^
    spaces level ^ "done;"
    
  | `AST_ifnotgoto (_,e,lab) ->
    spaces level ^
    "if not("^string_of_expr e^")goto " ^ lab

  | `AST_fun_return (_,e) -> 
    spaces level ^ "return " ^ (se e) ^ ";"

  | `AST_yield (_,e) -> 
    spaces level ^ "yield " ^ (se e) ^ ";"

  | `AST_proc_return _ -> 
    spaces level ^ "return;"

  | `AST_halt (_,s) -> 
    spaces level ^ "halt "^string_of_string s^";"

  | `AST_trace (_,v,s) -> 
    spaces level ^ "trace "^v^ ", msg="^string_of_string s^";"
  
  | `AST_svc (_,name) ->
    spaces level ^ "read " ^ name ^ ";"
  
  | `AST_user_statement (_,name,term) ->
    let body = string_of_ast_term level term in
    spaces level ^ "User statement " ^ name ^ "\n" ^ body

  | `AST_scheme_string (_,s) ->
    spaces level ^ "Scheme string " ^ s ^ ";\n"
  
and string_of_compilation_unit stats =
  catmap "\n" (string_of_statement 0) stats

and string_of_desugared stats =
  catmap "\n" (string_of_asm 0) stats
  
and string_of_iface level s =
  let spc = spaces level in
  match s with
  | `IFACE_export_fun (flx_name,cpp_name) -> 
    spc ^ "export fun " ^ string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `IFACE_export_type (flx_type,cpp_name) -> 
    spc ^ "export type (" ^ string_of_typecode flx_type ^ 
    ") as \"" ^ cpp_name ^ "\";"

and string_of_symdef (entry:symbol_definition_t) name (vs:ivs_list_t) = 
  let se e = string_of_expr e in
  let st t = string_of_typecode t in
  match entry with
  | `SYMDEF_instance qn ->
    "instance " ^ print_ivs vs ^ " " ^ 
    string_of_qualified_name qn ^ ";\n"

  | `SYMDEF_regdef re ->
    "regexp " ^ name ^ " = " ^ string_of_re re ^ ";\n"

  | `SYMDEF_regmatch (ps,cls) ->
    "regmatch " ^ name ^ " with " ^ 
    catmap "" (fun (re,e) -> "| " ^ string_of_re re ^ " => " ^se e) cls ^
    "endmatch;\n"

  | `SYMDEF_reglex (ps,i,cls) ->
    "regmatch " ^ name ^ " with " ^ 
    catmap "" (fun (re,e) -> "| " ^ string_of_re re ^ " => " ^se e) cls ^
    "endmatch;\n"


  | `SYMDEF_glr(t,(p,sexes)) ->
    "nonterm " ^ name ^ " : " ^st t ^ " = | " ^
    string_of_reduced_production p ^
    " => " ^ " <exes> " ^
    ";"

  | `SYMDEF_const_ctor (uidx,ut,idx,vs') -> 
     st ut ^ "  const_ctor: " ^
     name ^ print_ivs vs ^ 
     ";"

  | `SYMDEF_nonconst_ctor (uidx,ut,idx,vs',argt) -> 
     st ut ^ "  nonconst_ctor: " ^
     name ^ print_ivs vs ^ 
     " of " ^ st argt ^
     ";"

  | `SYMDEF_type_alias t -> 
    "typedef " ^ name ^ print_ivs vs ^" = " ^ st t ^ ";"

  | `SYMDEF_inherit qn -> 
    "inherit " ^ name ^ print_ivs vs ^" = " ^ string_of_qualified_name qn ^ ";"

  | `SYMDEF_inherit_fun qn -> 
    "inherit fun " ^ name ^ print_ivs vs ^" = " ^ string_of_qualified_name qn ^ ";"

  | `SYMDEF_abs (quals,code, reqs) ->
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ name ^ print_ivs vs ^
    " = " ^ string_of_code_spec code ^ 
    string_of_named_reqs reqs ^
    ";"

  | `SYMDEF_newtype (nt) ->
    "type " ^ name ^ print_ivs vs ^
    " = new " ^ st nt ^
    ";"

  | `SYMDEF_var (t) -> 
    "var " ^ name ^ print_ivs vs ^":"^ st t ^ ";"

  | `SYMDEF_val (t) -> 
    "val " ^ name ^ print_ivs vs ^":"^ st t ^ ";"

  | `SYMDEF_ref (t) -> 
    "ref " ^ name ^ print_ivs vs ^":"^ st t ^ ";"

  | `SYMDEF_lazy (t,e) -> 
    "fun " ^ name ^ print_ivs vs ^
    ": "^ st t ^ 
    "= " ^ se e ^
    ";"

  | `SYMDEF_parameter (k,t) -> 
    "parameter " ^ string_of_param_kind k ^ " " ^
    name ^ print_ivs vs ^":"^ st t ^ ";"

  | `SYMDEF_typevar (t) -> 
    "typevar " ^ name ^ print_ivs vs ^":"^ st t ^ ";"

  | `SYMDEF_const (props,t,ct, reqs) -> 
    string_of_properties props ^
    "const " ^ name ^ print_ivs vs ^":"^ 
    st t ^ " = " ^string_of_code_spec ct^
    string_of_named_reqs reqs ^
    ";"
    
  | `SYMDEF_union (cts) -> 
    "union " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_struct (cts) -> 
    "struct " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_cstruct (cts) -> 
    "cstruct " ^ name ^ print_ivs vs ^ ";"
    
  | `SYMDEF_cclass (cts) -> 
    "cclass " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_typeclass -> 
    "typeclass " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_fun (props, pts,res,cts, reqs,prec) -> 
    string_of_properties props ^
    "fun " ^ name ^ print_ivs vs ^
    ": " ^ st 
    (
      `TYP_function 
      (
        (
          match pts with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    (if prec = "" then "" else ":"^prec^" ")^
    string_of_named_reqs reqs ^
    ";"

  | `SYMDEF_callback (props, pts,res,reqs) -> 
    string_of_properties props ^
    "callback fun " ^ name ^ print_ivs vs ^
    ": " ^ st 
    (
      `TYP_cfunction 
      (
        (
          match pts with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    string_of_named_reqs reqs ^
    ";"

  | `SYMDEF_insert (s,ikind, reqs) -> 
    (match ikind with 
    | `Header -> "header " 
    | `Body -> "body "
    | `Package -> "package "
    ) ^
    name ^ print_ivs vs ^
    " "^ string_of_code_spec s ^ 
     string_of_named_reqs reqs ^
    ";\n"
    
  | `SYMDEF_reduce (ps,e1,e2) ->
    "reduce " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_axiom (ps,e1) ->
    "axiom " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_lemma (ps,e1) ->
    "lemma " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_function (ps,res,props, es) -> 
    let ps,traint = ps in
    string_of_properties props ^
    "fun " ^ name ^ print_ivs vs ^
    ": " ^ st 
    (
      `TYP_function 
      (
        (
          match map (fun (x,y,z,d) -> z) ps with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    ";"
    
  | `SYMDEF_match_check (pat,(mvname,i))-> 
    "match_check " ^ name ^ " for " ^ string_of_pattern pat ^ ";"
  
  | `SYMDEF_module -> 
    "module " ^ name ^ ";"

  | `SYMDEF_class -> 
    "class " ^ name ^ ";"
    
and string_of_exe level s = 
  let spc = spaces level
  and se e = string_of_expr e 
  in
  match s with

  | `EXE_goto s -> spc ^ "goto " ^ s ^ ";"
  | `EXE_assert e -> spc ^ "assert " ^ se e ^ ";"
  | `EXE_apply_ctor (i1,f,e) ->
    spc ^ i1 ^ " <- new " ^ se f ^
    "(" ^ se e ^ ");"


  | `EXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `EXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `EXE_label s -> s ^ ":"

  | `EXE_comment s -> spc ^ 
    "// " ^ s 

  | `EXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_jump (p,a) -> spc ^ 
    "jump " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_loop (p,a) -> spc ^ 
    "loop " ^ 
    p ^ " " ^ 
    se a ^ ";"

  | `EXE_svc v -> spc ^ 
    "_svc " ^ v

  | `EXE_fun_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | `EXE_yield x -> spc ^ 
    "yield " ^ se x ^ ";"

  | `EXE_proc_return -> spc ^ 
    "return;"

  | `EXE_halt s -> spc ^ 
    "halt "^string_of_string s^";"

  | `EXE_trace (v,s) -> spc ^ 
    "trace "^v^"="^string_of_string s^";"


  | `EXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | `EXE_code s -> spc ^ 
    "code " ^ string_of_code_spec s 

  | `EXE_noreturn_code s -> spc ^ 
    "noreturn_code " ^ string_of_code_spec s 

  | `EXE_init (l,r) -> spc ^ 
    l ^ " := " ^ se r ^ ";"

  | `EXE_iinit ((l,i),r) -> spc ^ 
    l ^ "<"^si i^"> := " ^ se r ^ ";"

  | `EXE_assign (l,r) -> spc ^ 
    se l ^ " = " ^ se r ^ ";"

and sbe dfns bbdfns e = string_of_bound_expression dfns bbdfns e 
and tsbe dfns bbdfns e = string_of_bound_expression_with_type dfns bbdfns e 

and string_of_bound_expression_with_type dfns bbdfns ((e',t) as e) = 
  string_of_bound_expression' dfns bbdfns (tsbe dfns bbdfns) e ^ ":" ^
  sbt dfns t

and string_of_bound_expression dfns bbdfns e = 
  string_of_bound_expression' dfns bbdfns (sbe dfns bbdfns) e

and string_of_bound_expression' dfns bbdfns se e = 
  (*
  let sid n = qualified_name_of_bindex dfns bbdfns n in
  let sid n = fst (get_name_parent dfns bbdfns n) in
  *)
  let sid n = bound_name_of_bindex dfns bbdfns n in
  match fst e with
   
  | `BEXPR_parse (e,ii) -> "parse " ^ se e ^ " with <nt> endmatch"

  | `BEXPR_get_n (n,e') -> "(" ^ se e' ^ ").mem_" ^ si n
  | `BEXPR_get_named (i,e') -> "(" ^ se e' ^ ")." ^ sid i

  | `BEXPR_deref e -> "*("^ se e ^ ")"
  | `BEXPR_name (i,ts) -> sid i ^ print_inst dfns ts
  | `BEXPR_closure (i,ts) -> sid i ^ print_inst dfns ts
  | `BEXPR_method_closure (e,i,ts) -> se e ^ "." ^ sid i ^ print_inst dfns ts
  | `BEXPR_ref (i,ts) -> "&" ^ sid i ^ print_inst dfns ts
  | `BEXPR_new e -> "new " ^ se e 

  | `BEXPR_literal e -> string_of_literal e
  | `BEXPR_apply  (fn, arg) -> "(" ^ 
    se fn ^ " " ^ 
    se arg ^ 
    ")"

  | `BEXPR_apply_prim (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_apply_direct  (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"
  
  | `BEXPR_apply_method_direct (obj,i,ts, arg) -> "(" ^ 
    se obj ^ " -> " ^ sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"


  | `BEXPR_apply_struct (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_apply_stack (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_apply_method_stack (obj,i,ts, arg) -> "(" ^ 
    se obj ^ " -> " ^ sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_tuple t -> "(" ^ catmap ", " se t ^ ")"

  | `BEXPR_record ts -> "struct { " ^ 
      catmap "" (fun (s,e)-> s^":"^ se e ^"; ") ts ^ "}"

  | `BEXPR_variant (s,e) -> "case " ^ s ^ " of (" ^ se e ^ ")"

  | `BEXPR_case (v,t) -> 
    "case " ^ si v ^ " of " ^ string_of_btypecode dfns t

  | `BEXPR_match_case (v,e) -> 
    "(match case " ^ si v ^ ")(" ^ se e ^ ")"

  | `BEXPR_case_arg (v,e) ->
    "(arg of case " ^ si v ^ " of " ^ se e ^ ")"

  | `BEXPR_case_index e ->
    "caseno (" ^ se e ^ ")"

  | `BEXPR_expr (s,t) ->
    "code ["^string_of_btypecode dfns t^"]" ^ "'" ^ s ^ "'"

  | `BEXPR_range_check (e1,e2,e3) ->
    "range_check(" ^ se e1 ^"," ^ se e2 ^"," ^se e3 ^ ")"

  | `BEXPR_coerce (e,t) -> se e ^ " : " ^ string_of_btypecode dfns t

and string_of_biface dfns bbdfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns bbdfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BIFACE_export_fun (_,index,cpp_name) ->
    spc ^ "export fun " ^ qualified_name_of_index dfns index ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `BIFACE_export_type (_,btyp,cpp_name) ->
    spc ^ "export type (" ^ string_of_btypecode dfns btyp ^ 
    ") as \"" ^ cpp_name ^ "\";"

and sbx dfns bbdfns s =  string_of_bexe dfns bbdfns 0 s 

and string_of_bexe dfns bbdfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns bbdfns e in
  let sid n = bound_name_of_bindex dfns bbdfns n in
  match s with
  | `BEXE_goto (_,s) -> spc ^ "goto " ^ s ^ ";"

  | `BEXE_assert (_,e) -> spc ^ "assert " ^ se e ^ ";"
  | `BEXE_assert2 (_,_,e1,e2) -> spc ^ "assert2 " ^ 
    (match e1 with Some e1 -> se e1 ^ " implies " | None -> "") ^ 
    se e2^";"

  | `BEXE_axiom_check (_,e) -> spc ^ "axiom_check " ^ se e ^ ";"

  | `BEXE_halt (_,s) -> spc ^ "halt " ^ s ^ ";"
  | `BEXE_trace(_,v,s) -> spc ^ "trace " ^ s ^ ";"

  | `BEXE_ifgoto (_,e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `BEXE_ifnotgoto (_,e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `BEXE_label (_,s) -> s ^ ":"

  | `BEXE_comment (_,s) -> spc ^ 
    "// " ^ s 

  | `BEXE_call (_,p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_call_direct (_,i,ts,a) -> spc ^ 
    "directcall " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_call_method_direct (_,obj,i,ts,a) -> spc ^ 
    "direct_method_call " ^ 
    se obj ^ "->" ^ sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_call_method_stack (_,obj,i,ts,a) -> spc ^ 
    "stack_method_call " ^ 
    se obj ^ "->" ^ sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_jump_direct (_,i,ts,a) -> spc ^ 
    "direct tail call " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_call_stack (_,i,ts,a) -> spc ^ 
    "stackcall " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_call_prim (_,i,ts,a) -> spc ^ 
    "primcall " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_jump (_,p,a) -> spc ^ 
    "tail call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_loop (_,p,a) -> spc ^ 
    "loop<" ^ 
    si p ^ "> " ^ 
    se a ^ ";"

  | `BEXE_svc (_,v) -> spc ^ 
    "_svc " ^ sid v 

  | `BEXE_fun_return (_,x) -> spc ^ 
    "return " ^ se x ^ ";"

  | `BEXE_yield (_,x) -> spc ^ 
    "yield " ^ se x ^ ";"

  | `BEXE_proc_return _ -> spc ^ 
    "return;"

  | `BEXE_nop (_,s) -> spc ^ 
    "/*" ^ s ^ "*/"

  | `BEXE_code (_,s) -> spc ^ 
    "code " ^ string_of_code_spec s 

  | `BEXE_nonreturn_code (_,s) -> spc ^ 
    "non_return_code " ^ string_of_code_spec s 

  | `BEXE_assign (_,l,r) -> spc ^ 
    se l ^ " = " ^ se r ^ ";"

  | `BEXE_init (_,l,r) -> spc ^ 
    sid l ^ " := " ^ se r ^ ";"

  | `BEXE_begin -> "{//begin"

  | `BEXE_end -> "}//end"

  | `BEXE_apply_ctor (sr,i0,i1,ts, i2, arg) -> spc ^ 
    sid i0 ^ " = new " ^ sid i1 ^ print_inst dfns ts ^ " " ^ 
    sid i2 ^ " (" ^ se arg ^ ");"

  | `BEXE_apply_ctor_stack (sr,i0,i1,ts, i2, arg) -> spc ^ 
    sid i0 ^ " = new " ^ sid i1 ^ print_inst dfns ts ^ " " ^ 
    sid i2 ^ " (" ^ se arg ^ ");/*stacked*/"


and string_of_dcl level name seq vs (s:dcl_t) = 
  let se e = string_of_expr e in
  let st t = string_of_typecode t in
  let sl = spaces level in
  let seq = match seq with Some i -> "<" ^ si i ^ ">" | None -> "" in
  match s with
  | `DCL_regdef re -> 
    sl ^ "regexp " ^ name^seq ^ " = " ^ string_of_re re ^ ";\n"

  | `DCL_regmatch cls -> 
    sl ^ "regmatch " ^ name^seq ^ " with " ^ 
    catmap "" (fun (re,e) -> "| " ^ string_of_re re ^ " => " ^string_of_expr e) cls ^
    "endmatch;\n"

  | `DCL_reglex cls -> 
    sl ^ "reglex " ^ name^seq ^ " with " ^ 
    catmap "" (fun (re,e) -> "| " ^ string_of_re re ^ " => " ^string_of_expr e) cls ^
    "endmatch;\n"


  | `DCL_type_alias (t2) ->
    sl ^ "typedef " ^ name^seq ^ print_vs vs ^
    " = " ^ st t2 ^ ";"

  | `DCL_inherit qn ->
    sl ^ "inherit " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_qualified_name qn ^ ";"

  | `DCL_inherit_fun qn ->
    sl ^ "inherit fun " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_qualified_name qn ^ ";"

  | `DCL_module (asms) -> 
    sl ^ "module " ^ name^seq ^ print_vs vs ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms 

  | `DCL_class (asms) -> 
    sl ^ "class " ^ name^seq ^ print_vs vs ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms 

  | `DCL_instance (name,asms) -> 
    sl ^ "instance " ^ print_vs vs ^ " " ^ 
    string_of_qualified_name name ^seq ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms 

  | `DCL_struct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name^ ": " ^ st ty ^ ";"
    in
    sl ^ "struct " ^ name^seq ^ print_vs vs ^ " = " ^
    sl ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    sl ^ "}"

  | `DCL_cstruct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name^ ": " ^ st ty ^ ";"
    in
    sl ^ "cstruct " ^ name^seq ^ print_vs vs ^ " = " ^
    sl ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    sl ^ "}"

  | `DCL_cclass (cs) -> 
    sl ^ "cclass " ^ name^seq ^ print_vs vs ^ " = " ^
    sl ^ "{\n" ^
    catmap "\n" (string_of_class_component level) cs ^ "\n" ^
    sl ^ "}"

  | `DCL_typeclass (asms) -> 
    sl ^ "type class " ^ name^seq ^ print_vs vs ^ " =\n" ^
    string_of_asm_compound level asms 

  | `DCL_union (cs) -> 
    let string_of_union_component (name,v,vs,ty) =
      (spaces (level+1)) ^ 
      "|" ^name^ 
      (match v with | None -> "" | Some i -> "="^si i) ^ 
      special_string_of_typecode ty
    in
    sl ^ "union " ^ name^seq ^ print_vs vs ^
    " = " ^
    sl ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    sl ^ "}"

  | `DCL_newtype (nt)-> sl ^ 
    "type " ^ name^seq ^ print_vs vs ^ 
    " = new " ^ st nt ^ ";"

  | `DCL_abs (quals, code, reqs) -> sl ^ 
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_code_spec code ^ 
    string_of_named_reqs reqs ^
    ";"

  | `DCL_fun (props, args, result, code, reqs,prec) ->
    let argtype:typecode_t = type_of_argtypes args in
    let t:typecode_t = `TYP_function (argtype,result) in
    sl ^ 
    string_of_properties props ^
    "fun " ^ name^seq ^ print_vs vs ^
    ": " ^ st t ^
    " = " ^ string_of_code_spec code ^ 
    (if prec = "" then "" else ":"^prec^" ")^
    string_of_named_reqs reqs ^
    ";"

  | `DCL_callback (props, args, result, reqs) ->
    let argtype:typecode_t = type_of_argtypes args in
    let t:typecode_t = `TYP_cfunction (argtype,result) in
    sl ^ 
    string_of_properties props ^
    "callback fun " ^ name^seq ^ print_vs vs ^
    ": " ^ st t ^
    string_of_named_reqs reqs ^
    ";"

  | `DCL_insert (s,ikind, reqs) -> 
    sl ^ 
    (match ikind with 
    | `Header -> "header " 
    | `Body -> "body "
    | `Package -> "package "
    ) ^ 
    name^seq ^  print_vs vs ^
    " = "^ string_of_code_spec s ^
    string_of_named_reqs reqs ^ ";"
    
  | `DCL_const (props,typ, code, reqs) ->
    sl ^ 
    string_of_properties props ^
    "const " ^ name^seq ^print_vs vs ^  
    ": " ^ st typ ^ 
    " = "^string_of_code_spec code^ 
    string_of_named_reqs reqs ^
    ";" 

  | `DCL_reduce (ps, e1,e2) -> 
    sl ^ 
    "reduce " ^ name^seq ^ print_vs vs ^
    "("^ string_of_basic_parameters ps ^"): " ^
    string_of_expr e1 ^ " => " ^ string_of_expr e2 ^ ";"

  | `DCL_axiom (ps, e1) -> 
    sl ^ 
    "axiom " ^ name^seq ^ print_vs vs ^
    "("^ string_of_parameters ps ^"): " ^
    string_of_axiom_method e1 ^ ";"

  | `DCL_lemma (ps, e1) -> 
    sl ^ 
    "lemma " ^ name^seq ^ print_vs vs ^
    "("^ string_of_parameters ps ^"): " ^
    string_of_axiom_method e1 ^ ";"

  | `DCL_function (ps, res, props, ss) -> 
    sl ^ 
    string_of_properties props ^
    "fun " ^ name^seq ^ print_vs vs ^
    "("^ (string_of_parameters ps)^"): "^(st res)^"\n" ^
    string_of_asm_compound level ss


  | `DCL_match_check (pat,(s,i)) ->
    sl ^ 
    "function " ^ name^seq ^ "() { " ^ 
    s ^ "<"^si i^"> matches " ^ string_of_pattern pat ^
    " }"

  | `DCL_match_handler (pat,(varname, i), sts) ->
    sl ^ 
    "match_handler " ^ name^seq ^ 
    "(" ^ string_of_pattern pat ^ ")" ^
    string_of_asm_compound level sts

  | `DCL_glr (t,(p,e')) ->
    sl ^ "nonterm " ^ name^seq ^ " : " ^st t ^
    spaces (level + 1) ^ " | " ^
    string_of_reduced_production p ^
    " => " ^
    string_of_expr e' ^
    ";"
  
  | `DCL_val (ty) ->
    sl ^ 
    "val " ^ name^seq ^ print_vs vs ^ ": " ^ st ty ^ ";"

  | `DCL_ref (ty) ->
    sl ^ 
    "ref " ^ name^seq ^ print_vs vs ^ ": " ^ st ty ^ ";"

  | `DCL_var (ty) ->
    sl ^ 
    "var " ^ name^seq ^ print_vs vs ^ ": " ^ st ty ^ ";"
  
  | `DCL_lazy (ty,e) ->
    sl ^ 
    "fun " ^ name^seq ^ print_vs vs ^ 
    ": " ^ st ty ^ 
    "= " ^ se e ^
    ";"

and string_of_access = function
  | `Private -> "private "
  | `Public -> "public"

and string_of_asm level s =
  match s with
  | `Dcl (sr,name,seq,access,vs, d) -> 
    (match access with
    | `Private -> "private "
    | `Public -> ""
    ) ^
    string_of_dcl level name seq vs d
  | `Exe (sr,s) -> string_of_exe level s
  | `Iface (sr,s) -> string_of_iface level s
  | `Dir s -> string_of_dir level s

and string_of_dir level s =
  let sqn n = string_of_qualified_name n in
  match s with
  | DIR_open (vs,qn) ->
    spaces level ^ "open" ^ print_ivs vs ^ sqn qn ^ ";"

  | DIR_use (n,qn) ->
    spaces level ^ "use " ^ n ^ " = " ^ sqn qn ^ ";"

  | DIR_inject_module (qn) ->
    spaces level ^ "include " ^ sqn qn ^ ";"

and string_of_breq dfns (i,ts) = "rq<"^si i^">" ^ print_inst dfns ts
and string_of_breqs dfns reqs = catmap ", " (string_of_breq dfns) reqs
and string_of_production p = catmap " " string_of_glr_entry p
and string_of_reduced_production p = catmap " " string_of_reduced_glr_entry p
and string_of_bproduction dfns p = catmap " " (string_of_bglr_entry dfns) p

and string_of_glr_term t = match t with
  | `GLR_name qn -> string_of_qualified_name qn
  | `GLR_opt t  -> "[" ^ string_of_glr_term t ^ "]"
  | `GLR_ast t -> "{" ^ string_of_glr_term t ^ "}"
  | `GLR_plus t -> "(" ^ string_of_glr_term t ^ ")+"
  | `GLR_alt ts -> catmap " | " string_of_glr_term ts
  | `GLR_seq ts -> catmap " " string_of_glr_term ts
  
and string_of_glr_entry (name,t) = 
  (match name with 
  | Some n -> n ^ ":"
  | None -> ""
  )^
  string_of_glr_term t

and string_of_reduced_glr_entry (name,t) = 
  (match name with 
  | Some n -> n ^ ":"
  | None -> ""
  )^
  string_of_qualified_name t

and string_of_bglr_entry dfns (name,symbol) = 
  (match name with 
  | Some n -> n ^ ":"
  | None -> ""
  )^
  (match symbol with
  | `Nonterm (i::_) 
  | `Term i -> qualified_name_of_index dfns i
  | `Nonterm [] -> "<Undefined nonterminal>"
  )

and string_of_bbdcl dfns bbdfns (bbdcl:bbdcl_t) index : string = 
  let name = qualified_name_of_index dfns index in
  let sobt t = string_of_btypecode dfns t in
  let se e = string_of_bound_expression dfns bbdfns e in
  let un = `BTYP_tuple [] in 
  match bbdcl with
  | `BBDCL_function (props,vs,ps,res,es) ->
    string_of_properties props ^
    "fun " ^ name ^ print_bvs vs ^
    "("^ (string_of_bparameters dfns bbdfns ps)^"): "^(sobt res) ^
    "{\n" ^
    cat "\n" (map (string_of_bexe dfns bbdfns 1) es) ^
    "}"

  
  | `BBDCL_procedure (props,vs,ps,es) ->
    string_of_properties props ^
    "proc " ^ name ^ print_bvs vs ^
    "("^ (string_of_bparameters dfns bbdfns ps)^")" ^
    "{\n" ^
    cat "\n" (map (string_of_bexe dfns bbdfns 1) es) ^
    "}"

  | `BBDCL_val (vs,ty) ->
    "val " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  | `BBDCL_var (vs,ty) ->
    "var " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  | `BBDCL_ref (vs,ty) ->
    "ref " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  | `BBDCL_tmp (vs,ty) ->
    "tmp " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  (* binding structures [prolog] *)
  | `BBDCL_newtype (vs,t) ->
    "type " ^ name ^  print_bvs vs ^
    " = new " ^ sobt t ^ ";"

  | `BBDCL_abs (vs,quals,code,reqs) ->
    (match quals with [] ->"" | _ -> string_of_bquals dfns quals ^ " ") ^
    "type " ^ name ^  print_bvs vs ^
    " = " ^ string_of_code_spec code ^ ";"

  | `BBDCL_const (props, vs,ty,code,reqs) ->
    string_of_properties props ^
     "const " ^ name ^ print_bvs vs ^    
     ": " ^ sobt ty ^ 
     " = "^string_of_code_spec code^ 
     string_of_breqs dfns reqs ^
     ";" 

  | `BBDCL_fun (props,vs,ps,rt,code,reqs,prec) ->
    string_of_properties props ^
    "fun " ^ name ^ print_bvs vs ^
    ": " ^ 
    (sobt (typeoflist ps)) ^ " -> " ^
    (sobt rt) ^ 
    " = " ^ string_of_code_spec code ^ 
    (if prec = "" then "" else ":"^prec^" ")^
     string_of_breqs dfns reqs ^
    ";"

  | `BBDCL_callback (props,vs,ps_cf,ps_c,k,rt,reqs,prec) ->
    string_of_properties props ^
    "callback fun " ^ name ^ print_bvs vs ^
    ": " ^ 
    (sobt (typeoflist ps_cf)) ^ " -> " ^
    (sobt rt) ^ 
    " : " ^ 
    (if prec = "" then "" else ":"^prec^" ")^
     string_of_breqs dfns reqs ^
    ";"

  | `BBDCL_proc (props,vs, ps,code,reqs) ->
    string_of_properties props ^
    "proc " ^ name ^ print_bvs vs ^
    ": " ^ 
     (sobt (typeoflist ps)) ^
     " = " ^ string_of_code_spec code ^ 
     string_of_breqs dfns reqs ^
     ";"

  | `BBDCL_insert (vs,s,ikind,reqs) -> 
     (match ikind with 
     | `Header -> "header " 
     | `Body -> "body "
     | `Package -> "package "
     ) ^
    name^  print_bvs vs ^
    " "^ string_of_code_spec s ^
    string_of_breqs dfns reqs

  | `BBDCL_union (vs,cs) ->
    let string_of_union_component (name,v,ty) =
      "  " ^ "|" ^name ^ 
     "="^si v^
      special_string_of_btypecode dfns ty
    in
    "union " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    "}"

  | `BBDCL_struct (vs,cs) ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "struct " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"

  | `BBDCL_cstruct (vs,cs) ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "cstruct " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"

  | `BBDCL_cclass (vs,cs) ->
    let string_of_class_component mem  = 
      let kind, name,bvs,ty =
        match mem with
        | `BMemberVal (name,ty) -> "val",name,[],ty
        | `BMemberVar (name,ty) -> "var",name,[],ty
        | `BMemberFun (name,bvs,ty) -> "fun",name,bvs,ty
        | `BMemberProc (name,bvs,ty) -> "proc",name,bvs,ty
        | `BMemberCtor (name,ty) -> "ctor",name,[],ty
      in
      kind ^ "  " ^ name ^ print_bvs bvs ^ ": " ^ sobt ty ^ ";"
    in
    "cclass " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_class_component cs ^ "\n" ^
    "}"

  | `BBDCL_class (props,vs) ->
    string_of_properties props ^
    "class " ^ name ^ print_bvs vs ^ ";"

  | `BBDCL_typeclass (props,vs) ->
    string_of_properties props ^
    "typeclass " ^ name ^ print_bvs vs ^ ";"

  | `BBDCL_instance (props,vs,cons,bid,ts) ->
    string_of_properties props ^
    "instance "^print_bvs_cons dfns vs cons^
    " of <" ^ si bid ^">["^ catmap "," (sbt dfns) ts ^ "];"

  | `BBDCL_glr (props,vs,t,(p,bexes)) ->
    "  " ^ "nonterm " ^ name ^ print_bvs vs ^ " : " ^sobt t ^
    "   | " ^
    string_of_bproduction dfns p ^
    " => " ^
    cat "\n" (map (string_of_bexe dfns bbdfns 1) bexes) ^
    ";"
  
  | `BBDCL_regmatch (props,vs,ps,t,regargs) -> "regmatch.."
  | `BBDCL_reglex (props,vs,ps,i,t,regargs) -> "reglex.."

  | `BBDCL_nonconst_ctor (vs,uidx,ut,ctor_idx, ctor_argt, evs, etraint) ->
    "  uctor<" ^ name ^ ">"^ print_bvs vs ^
    " : " ^ sobt ut ^ 
    " of " ^ sobt ctor_argt ^
    ";"
    
    
let string_of_dfn dfns i =
  match Hashtbl.find dfns i with
  | { id=id; sr=sr; vs=vs; symdef=entry } ->
  string_of_symdef entry id vs
  ^ " defined at " ^ short_string_of_src sr

let full_string_of_entry_kind dfns {base_sym=i} =
  string_of_dfn dfns i

let string_of_entry_kind {base_sym=i} = si i

let string_of_entry_set = function
  | `NonFunctionEntry x -> string_of_entry_kind x
  | `FunctionEntry ls -> 
    "{" ^
      catmap "," string_of_entry_kind ls ^
    "}"

let full_string_of_entry_set dfns = function
  | `NonFunctionEntry x -> full_string_of_entry_kind dfns x
  | `FunctionEntry ls -> if length ls = 0 then "{}" else
    "{\n" ^
      catmap "\n" (full_string_of_entry_kind dfns) ls ^
    "\n}"

let string_of_myentry dfns {base_sym=i; spec_vs=vs; sub_ts=ts} =
 si i ^ 
 " vs=" ^ catmap "," (fun (s,_)->s) vs ^
 " ts=" ^ catmap "," (sbt dfns) ts

let print_name_table dfns table =
  Hashtbl.iter
  (fun s v -> 
    print_endline (s ^ " --> " ^
      match v with
      | `NonFunctionEntry i -> string_of_myentry dfns i
      | `FunctionEntry ii -> "{"^ catmap "," (string_of_myentry dfns) ii ^ "}"
    );
  )
  table


let string_of_varlist dfns varlist =
  catmap ", " (fun (i,t)-> si i ^ "->" ^ sbt dfns t) varlist

let print_env e = 
  let print_entry k v = 
    print_endline 
    (
      "  " ^ k ^ " " ^
      (
        match v with 
        | (`NonFunctionEntry (i)) -> string_of_entry_kind i
        | _ -> ""
      )
    )
  in 
  let print_table htab = 
    print_endline "--"; Hashtbl.iter print_entry htab

  in 
  let print_level (index,id,htab,htabs) = 
    print_string (id^"<"^si index^">");
    print_table htab;
    print_endline "OPENS:";
    List.iter print_table htabs;
    print_endline "ENDOFOPENS"
  in 

  List.iter print_level e

let print_env_short e = 
  let print_level (index,id,htab,htabs) = 
    print_endline (id^"<"^si index^">")
  in 
  List.iter print_level e

let print_function_body dfns bbdfns id i (bvs:bvs_t) ps exes parent =
  print_endline "";
  print_endline ("BODY OF " ^ id ^ "<" ^ si i ^ "> [" ^
  catmap "," (fun (s,i) -> s ^ "<" ^ si i ^ ">") bvs ^
  "] parent " ^ 
    (match parent with None -> "NONE" | Some k -> si k)
    ^
    "(" ^ string_of_bparameters dfns bbdfns ps ^ ")"
  );
  iter 
  (fun exe -> print_endline (string_of_bexe dfns bbdfns 1 exe)) 
  exes

let print_function dfns bbdfns i =
  match Hashtbl.find bbdfns i with (id,parent,_,entry) -> 
  match entry with
  | `BBDCL_function (_,bvs,ps,_,exes) 
  | `BBDCL_procedure (_,bvs,ps,exes) ->
    print_function_body dfns bbdfns id i bvs ps exes parent
  | _ -> ()

let print_functions dfns (bbdfns:fully_bound_symbol_table_t) =
  Hashtbl.iter
  (fun i (id,parent,_,entry) -> match entry with
  | `BBDCL_function (_,bvs,ps,_,exes) 
  | `BBDCL_procedure (_,bvs,ps,exes) ->
    print_function_body dfns bbdfns id i bvs ps exes parent

  | _ -> ()
  )
  bbdfns

let print_symbols dfns (bbdfns:fully_bound_symbol_table_t) =
  Hashtbl.iter
  (fun i (id,parent,_,entry) -> match entry with
  | `BBDCL_function (_,bvs,ps,_,exes) 
  | `BBDCL_procedure (_,bvs,ps,exes) ->
    print_function_body dfns bbdfns id i bvs ps exes parent
  | `BBDCL_var (bvs,t) ->
    print_endline ("VARIABLE " ^ id ^ "<" ^ si i ^ "> [" ^
      catmap "," (fun (s,i) -> s ^ "<" ^ si i ^ ">") bvs ^
      "] parent " ^ 
      (match parent with None -> "NONE" | Some k -> si k) ^
      " type " ^ sbt dfns t
    )
  | `BBDCL_val (bvs,t) ->
    print_endline ("VALUE " ^ id ^ "<" ^ si i ^ "> [" ^
      catmap "," (fun (s,i) -> s ^ "<" ^ si i ^ ">") bvs ^
      "] parent " ^ 
      (match parent with None -> "NONE" | Some k -> si k) ^
      " type " ^ sbt dfns t
    )
  | _ -> ()
  )
  bbdfns


@h = tangler('src/compiler/flxlib/flx_mtypes1.ml')
@select(h)
module IntHashtbl = Hashtbl.Make(
  struct
    type t = int
    let equal = fun x y -> x = y
    let hash = fun x -> x
  end
)
;;

module StringMap = Map.Make(
  struct 
    type t = string 
    let compare = compare 
  end
)
;;

type string_string_map_t = string StringMap.t

module StringSet = Set.Make (
  struct 
    type t = string 
    let compare=compare 
  end
);;

module IntSet = Set.Make (
  struct 
    type t = int 
    let compare=compare 
  end
);;

(* set of IntSet's *)
module IntSetSet = Set.Make (
  struct 
    type t = IntSet.t 
    let compare=compare 
  end
);;

let stringset_map f s =
  let d = ref StringSet.empty in
  StringSet.iter
  (fun x -> d := StringSet.add (f x) !d)
  s
  ;
  !d

let list_of_intset ii =
  IntSet.fold (fun i lst -> i :: lst) ii []

let string_of_intset ii = 
  "{"^
  String.concat ","
  (
    List.map string_of_int
    (
      list_of_intset ii
    )
  )
  ^"}"

let intset_of_list ii =
  List.fold_left (fun ii i -> IntSet.add i ii) IntSet.empty ii
  
@h = tangler('src/compiler/flxlib/flx_mtypes1.mli')
@select(h)
module IntHashtbl : Hashtbl.S with type key = int
module StringMap : Map.S with type key = string

type string_string_map_t = string StringMap.t
module StringSet : Set.S with type elt = string

val stringset_map: (string -> string) -> StringSet.t -> StringSet.t

module IntSet : Set.S with type elt = int
module IntSetSet : Set.S with type elt = IntSet.t

val string_of_intset : IntSet.t -> string
val intset_of_list : int list -> IntSet.t

@h = tangler('src/compiler/flxlib/flx_mtypes2.ml')
@select(h)
open Flx_mtypes1
open Flx_types
open List

(* generic entity instances: functions, variables *)
type instance_registry_t = (int * btypecode_t list, int) Hashtbl.t

type felix_compiler_options_t = 
{
  print_flag: bool;
  debug : bool;
  optimise : bool;
  trace : bool;
  include_dirs : string list;
  files : string list;
  raw_options: (string * string) list;
  reverse_return_parity: bool;
  max_inline_length : int;
  compile_only : bool;
  force_recompile : bool;
  with_comments : bool;
  document_grammar: bool;
  document_typeclass: bool;
  mangle_names : bool;
  elkhound : string;
  generate_axiom_checks : bool;
  auto_imports : string list;
}


type sym_state_t = 
{
  dfns : symbol_table_t;
  counter : int ref;
  varmap : typevarmap_t;
  ticache : (int, btypecode_t) Hashtbl.t;
  glr_cache : (int, btypecode_t) Hashtbl.t;
  env_cache : (int, env_t) Hashtbl.t;
  registry : type_registry_t;
  compiler_options : felix_compiler_options_t;
  instances : instance_registry_t;
  include_files : string list ref;
  roots : IntSet.t ref;
  wrappers : (int, int) Hashtbl.t;
  lexers : (int * tbexpr_t, int) Hashtbl.t;
  parsers : (int * btypecode_t * int list, int) Hashtbl.t;
  quick_names : (string, (int * btypecode_t list)) Hashtbl.t;
  mutable bifaces : biface_t list;
  mutable reductions : reduction_t list;
  mutable axioms: axiom_t list;
  variant_map: (btypecode_t * btypecode_t,int) Hashtbl.t;
  typeclass_to_instance: (int, (bvs_t * btypecode_t * btypecode_t list * int) list) Hashtbl.t;
  instances_of_typeclass: (int, (int * (bvs_t * btypecode_t * btypecode_t list)) list) Hashtbl.t;
  transient_specialisation_cache: (int * btypecode_t list, int * btypecode_t list) Hashtbl.t;
}

module VarMap = StringMap
type varmap_t = string_string_map_t

module TypecodeSet = Set.Make(
  struct type t = Flx_ast.typecode_t let compare = compare end
)
type typecodeset_t = TypecodeSet.t

let typecodeset_of_list x = 
  let rec tsol x = match x with
  | h :: t -> TypecodeSet.add h (tsol t)
  | [] -> TypecodeSet.empty
  in tsol x

let typecodeset_map f x = typecodeset_of_list (map f (TypecodeSet.elements x))

(* for regular expressions *)

(* PosSet -- set of positions in regular expression, used for followpos *)
module PosSet = IntSet
module PosSetSet = IntSetSet
module CharSet = IntSet

module Drules = Map.Make(struct
  type t = string
  let compare = compare
end)

@h = tangler('src/compiler/flxlib/flx_mtypes2.mli')
@select(h)
open Flx_types
open Flx_mtypes1

module VarMap : Map.S with type key = string

type varmap_t = string VarMap.t

module TypecodeSet : Set.S with type elt = Flx_ast.typecode_t

type typecodeset_t = TypecodeSet.t
val typecodeset_of_list : TypecodeSet.elt list -> TypecodeSet.t
val typecodeset_map :
  (TypecodeSet.elt -> TypecodeSet.elt) -> TypecodeSet.t -> TypecodeSet.t

module PosSet : Set.S with type elt = int
module PosSetSet : Set.S with type elt = PosSet.t
module CharSet : Set.S with type elt = int

(* generic entity instances: functions, variables *)
type instance_registry_t = (int * btypecode_t list, int) Hashtbl.t

type felix_compiler_options_t = 
{
  print_flag: bool;
  debug : bool;
  optimise : bool;
  trace : bool;
  include_dirs : string list;
  files : string list;
  raw_options: (string * string) list;
  reverse_return_parity: bool;
  max_inline_length : int;
  compile_only : bool;
  force_recompile : bool;
  with_comments : bool;
  document_grammar: bool;
  document_typeclass: bool;
  mangle_names : bool;
  elkhound : string;
  generate_axiom_checks : bool;
  auto_imports : string list;
}


type sym_state_t = 
{
  dfns : symbol_table_t;
  counter : int ref;
  varmap : typevarmap_t;
  ticache : (int, btypecode_t) Hashtbl.t;
  glr_cache : (int, btypecode_t) Hashtbl.t;
  env_cache : (int, env_t) Hashtbl.t;
  registry : type_registry_t;
  compiler_options : felix_compiler_options_t;
  instances : instance_registry_t;
  include_files : string list ref;
  roots : IntSet.t ref;
  wrappers : (int, int) Hashtbl.t;
  lexers : (int * tbexpr_t, int) Hashtbl.t;
  parsers : (int * btypecode_t * int list, int) Hashtbl.t;
  quick_names : (string, (int * btypecode_t list)) Hashtbl.t;
  mutable bifaces : biface_t list;
  mutable reductions : reduction_t list;
  mutable axioms : axiom_t list;
  variant_map: (btypecode_t * btypecode_t,int) Hashtbl.t;
  typeclass_to_instance: (int, (bvs_t * btypecode_t * btypecode_t list * int) list) Hashtbl.t;
  instances_of_typeclass: (int, (int * (bvs_t * btypecode_t * btypecode_t list)) list) Hashtbl.t;
  transient_specialisation_cache: (int * btypecode_t list, int * btypecode_t list) Hashtbl.t;
}


module Drules : Map.S with type key = string

@head(1,'Compile time exceptions')
@python('//')
exceptions = """
open Flx_ast
open Flx_types
exception RDP_match_fail of range_srcref * range_srcref * string
exception RDP_alternatives_exhausted of range_srcref * string
exception SyntaxError of string
exception ParseError of string
exception LexError of string
exception TokenError of string
exception ClientErrorn of range_srcref list * string
exception ClientError of range_srcref * string
exception ClientError2 of range_srcref * range_srcref * string
exception SystemError of range_srcref * string
exception Exit of int
exception Bad_recursion
exception Expr_recursion of expr_t
exception Free_fixpoint of btypecode_t 
exception Unresolved_return of range_srcref * string
"""
//
@h = tangler('src/compiler/flxlib/flx_exceptions.ml')
@select(h)
@tangle(exceptions)
let clierrn srs s = raise (ClientErrorn (srs,s))
let clierr2 sr sr2 s = raise (ClientError2 (sr,sr2,s))
let clierr sr s = raise (ClientError (sr,s))
let syserr sr s = raise (SystemError (sr,s))
let catch s f = try f() with _ -> failwith s
let rdp_match_fail sr1 sr2 s = raise (RDP_match_fail (sr1,sr2,s))
let rdp_alternatives_exhausted sr s = raise (RDP_alternatives_exhausted (sr,s))

@h = tangler('src/compiler/flxlib/flx_exceptions.mli')
@select(h)
@tangle(exceptions)
val clierrn: range_srcref list -> string -> 'a
val clierr: range_srcref -> string -> 'a
val clierr2: range_srcref -> range_srcref -> string -> 'a
val syserr: range_srcref -> string -> 'a
val catch: string -> (unit -> 'a) -> 'a
val rdp_match_fail: range_srcref -> range_srcref -> string -> 'a
val rdp_alternatives_exhausted: range_srcref -> string -> 'a

@h = tangler('src/compiler/flxlib/flx_typing.mli')
@select(h)
open Flx_ast
open Flx_types
exception UnificationError of btypecode_t * btypecode_t
val flx_bool : typecode_t
val flx_bbool : btypecode_t

val is_unitsum: btypecode_t -> bool
val int_of_unitsum : btypecode_t -> int
val all_units0 : b0typecode_t list -> bool
val all_units : btypecode_t list -> bool
val all_voids : btypecode_t list -> bool

val cmp_literal: literal_t -> literal_t -> bool
val cmp_tbexpr: tbexpr_t -> tbexpr_t -> bool

val type_of_argtypes : 
  typecode_t list -> 
  typecode_t
  
val funparamtype : 'a * 'b * 't * 'd -> 't

val typeoflist:
  btypecode_t list ->
  btypecode_t

val typeofbps_traint: bparams_t -> btypecode_t list
val typeofbps: bparameter_t list-> btypecode_t list

val lift:
  btypecode_t -> btypecode_t
                                                                         
val lower:
  btypecode_t -> btypecode_t

module FuntypeSet : Set.S with type elt = typecode_t

module FunInstSet : Set.S with type elt = bid_t * btypecode_t list

val sye: entry_kind_t -> int

val mktypefun:
  range_srcref ->
  string ->
  vs_list_t ->
  (string * typecode_t) list list ->
  typecode_t ->
  typecode_t ->
  statement_t

@h = tangler('src/compiler/flxlib/flx_typing.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_srcref
open List

(* MOVED FROM PARSER so flx_sex2flx can do the nasty work
   -- too lazy to implement this in Scheme at the moment --
*)

(* handle curried type functions *)
let mktypefun sr (name:string) (vs:vs_list_t) (args: (string * typecode_t) list list) (return_type:typecode_t) (body:typecode_t) : statement_t =
  let argtyp t = match t with
    | [] -> failwith "Lambda abstraction requires nonunit parameter"
    | [x] -> x
    | x -> `TYP_type_tuple x
  in
  let body = 
    let p = ref (List.rev args) in
    let r = ref return_type in
    let b = ref body in
    while !p <> [] do
      let arg = List.hd !p in
      p := List.tl !p;
      b := `TYP_typefun (arg, !r, !b);
      r := `TYP_function(argtyp (List.map snd (arg)),!r)
    done;
    !b
  in
  `AST_type_alias
  (
    sr,
    name,
    vs,
    body
  )


let sye {base_sym=i} = i

let all_voids ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_void))
    true ls

let all_units0 ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

let all_units ls = all_units0 ls

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_unitsum _ -> true
  | `BTYP_sum ls ->  all_units ls
  | _ -> false


let int_of_unitsum t = match t with
  | `BTYP_void -> 0
  | `BTYP_tuple [] -> 1
  | `BTYP_unitsum k -> k
  | `BTYP_sum [] ->  0
  | `BTYP_sum ls ->  
    if all_units ls then length ls
    else raise Not_found

  | _ -> raise Not_found 

exception UnificationError of btypecode_t * btypecode_t

(* unbound type *)
let type_of_argtypes ls = match ls with
 | [x] -> x
 | _ -> `TYP_tuple ls

let funparamtype (_,_,t,_) = t

module FuntypeSet = Set.Make(
  struct type t=typecode_t let compare = compare end
)

module FunInstSet = Set.Make(
  struct 
    type t= bid_t * btypecode_t list
    let compare = compare 
  end
)


let typeofbps bps =
  map 
  (fun {ptyp=t; pkind=k} -> 
    match k with 
    | `PRef -> `BTYP_pointer t 
    | `PFun -> `BTYP_function (`BTYP_tuple [],t)
    | _ ->t
  ) 
  bps

let typeofbps_traint (bps,_) = typeofbps bps

(* bound type! *)
let typeoflist typlist = match typlist with
  | [] -> `BTYP_tuple []
  | [t] -> t
  | h :: t -> 
    try 
      iter 
      (fun t -> if t <> h then raise Not_found)
      t; 
      `BTYP_array (h,`BTYP_unitsum (length typlist))
    with Not_found ->
      `BTYP_tuple typlist

let lift t = t
let lower t = t (* CHANGE THIS WHEN ABSTRACT TYPES IMPLEMENTED *)

let flx_bool = `TYP_unitsum 2
let flx_bbool = `BTYP_unitsum 2

(* Note floats are equal iff they're textually identical,
   we don't make any assumptions about the target machine FP model.
   OTOH, int comparisons are infinite precision, for the same
   int kind, even if the underlying machine model is not
*)

let cmp_literal (l:literal_t) (l':literal_t) = match l, l' with
  | `AST_int (a,b), `AST_int (a',b') -> a = a' && Big_int.eq_big_int b b'
  | `AST_float (a,b), `AST_float (a',b') -> a = a' && b = b'
  | `AST_string s, `AST_string s' -> s = s'
  | `AST_cstring s, `AST_cstring s' -> s = s'
  | `AST_wstring s, `AST_wstring s' -> s = s'
  | `AST_ustring s, `AST_ustring s' -> s = s'
  | _ -> false

(* Note that we don't bother comparing the type subterm:
  this had better be equal for equal expressions: the value
  is merely the cached result of a synthetic context
  independent type calculation
*)

let rec cmp_tbexpr (a,_) (b,_) = 
  let ecmp = cmp_tbexpr in match a,b with
  | `BEXPR_parse (e,ii), `BEXPR_parse (e',ii') ->
    ecmp e e' && ii = ii'

  | `BEXPR_coerce (e,t),`BEXPR_coerce (e',t') ->
    (* not really right .. *)
    ecmp e e'

  | `BEXPR_record ts,`BEXPR_record ts' ->
    length ts = length ts' &&
    let rcmp (s,t) (s',t') = compare s s' in
    let ts = sort rcmp ts in
    let ts' = sort rcmp ts' in
    map fst ts = map fst ts' &&
    fold_left2 (fun r a b -> r && a = b) true (map snd ts) (map snd ts')
 
  | `BEXPR_variant (s,e),`BEXPR_variant (s',e') ->
    s = s' && ecmp e e'

  | `BEXPR_deref e,`BEXPR_deref e' -> ecmp e e'

  | `BEXPR_name (i,ts),`BEXPR_name (i',ts')
  | `BEXPR_ref (i,ts),`BEXPR_ref (i',ts') 
  | `BEXPR_closure (i,ts),`BEXPR_closure (i',ts') ->
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts'

  (* Note any two distinct new expressions are distinct ... 
    not sure what is really needed here
  *)
  | `BEXPR_new e1,`BEXPR_new e2 -> false
 
  | `BEXPR_method_closure (e,i,ts),`BEXPR_method_closure (e',i',ts') ->
     ecmp e e' &&
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts'

  | `BEXPR_literal a,`BEXPR_literal a' -> cmp_literal a a'

  | `BEXPR_apply (a,b),`BEXPR_apply (a',b') ->  ecmp a a' && ecmp b b'

  | `BEXPR_apply_prim (i,ts,b),`BEXPR_apply_prim (i',ts',b') 
  | `BEXPR_apply_direct (i,ts,b),`BEXPR_apply_direct (i',ts',b')
  | `BEXPR_apply_struct (i,ts,b),`BEXPR_apply_struct (i',ts',b')
  | `BEXPR_apply_stack (i,ts,b),`BEXPR_apply_stack (i',ts',b') ->  
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts' &&
     ecmp b b'

  | `BEXPR_apply_method_direct (e,i,ts,b),`BEXPR_apply_method_direct (e',i',ts',b') ->  
     ecmp e e' &&
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts' &&
     ecmp b b'

  | `BEXPR_apply_method_stack (e,i,ts,b),`BEXPR_apply_method_stack (e',i',ts',b') ->  
     ecmp e e' &&
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts' &&
     ecmp b b'

  | `BEXPR_tuple ls,`BEXPR_tuple ls' ->
     fold_left2 (fun r a b -> r && ecmp a b) true ls ls'

  | `BEXPR_case_arg (i,e),`BEXPR_case_arg (i',e')

  | `BEXPR_match_case (i,e),`BEXPR_match_case (i',e')
  | `BEXPR_get_n (i,e),`BEXPR_get_n (i',e') ->
    i = i' && ecmp e e'

  (* this is probably wrong: says x.y = x'.y' iff x = x && y = y',
  however, x.y should unify with a simple value .. oh well..
  hmm .. this should REALLY be a pointer to member, that is,
  an actual projection function
  *)
  | `BEXPR_get_named (i,e),`BEXPR_get_named (i',e') ->
    i = i' && ecmp e e'

  | `BEXPR_case_index e,`BEXPR_case_index e' -> ecmp e e'

  | `BEXPR_case (i,t),`BEXPR_case (i',t') -> i = i' && t = t'
  | `BEXPR_expr (s,t),`BEXPR_expr (s',t') -> s = s' && t = t'
  | `BEXPR_range_check (e1,e2,e3), `BEXPR_range_check (e1',e2',e3') ->
    ecmp e1 e1' && ecmp e2 e2' && ecmp e3 e3'
    
  | _ -> false

 
@h = tangler('src/compiler/flxlib/flx_typing2.mli')
@select(h)
open Flx_ast
val typecode_of_expr:
  expr_t -> typecode_t

val typeof_list:
  typecode_t list -> typecode_t

val paramtype: 
  (param_kind_t * string * typecode_t * expr_t option) list -> typecode_t

val qualified_name_of_expr:
  expr_t -> qualified_name_t

@h = tangler('src/compiler/flxlib/flx_typing2.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_print
open Flx_srcref
open Flx_exceptions
open List

let qualified_name_of_expr e =
  match e with
  | #qualified_name_t as x -> x
  | _ -> 
    failwith
    (
      "Qualified name expected in\n" ^
      short_string_of_src (src_of_expr e) ^
      "\nGot " ^ Flx_print.string_of_expr e
    )


let typeof_list = function 
  | [x] -> x 
  | x -> `TYP_tuple x

let paramtype params = 
  let typlist params = 
    map 
    (fun (k,_,t,_) ->
      match k with 
      | `PRef -> `TYP_pointer t 
      | `PFun -> `TYP_function (`TYP_tuple [],t)
      | _ -> t
    ) 
    params 
  in
  typeof_list (typlist params)

let all_tunits ts = 
  try 
    iter 
    (fun t -> 
      if t <> `TYP_tuple [] 
      then raise Not_found
    ) 
    ts; 
    true
  with Not_found -> false

let rec typecode_of_expr (e:expr_t) :typecode_t = 
  let te e = typecode_of_expr e in
  match e with 
  | `AST_case (sr,e1,ls,e2) -> `TYP_case (te e1, ls, te e2)
  | `AST_name (_,"TYPE",[]) -> `TYP_type
  | `AST_name (sr,"_",[]) -> `AST_patany sr
  | `AST_ellipsis _ -> `TYP_ellipsis
  | #suffixed_name_t as x -> (x:>typecode_t)
  | `AST_tuple (sr,ls) ->
    begin match ls with
    | [] -> `TYP_tuple [] (* HACK!! *) 
    | [x] -> failwith "Unexpected one element tuple converting to type tuple"
    | _ -> `TYP_type_tuple (map te ls)
    end
  | `AST_record_type (sr,es) -> `TYP_record es
  | `AST_variant_type (sr,es) -> `TYP_variant es

  | `AST_product (_,ts) -> `TYP_tuple (map te ts)
  | `AST_intersect (_,ts) -> `TYP_intersect (map te ts)
  | `AST_isin (_,(a,b)) -> `TYP_isin (te a, te b)
  | `AST_setintersection (_,ts) -> `TYP_setintersection (map te ts)
  | `AST_setunion (_,ts) -> `TYP_setunion (map te ts)
  | `AST_arrow (_,(a,b)) -> `TYP_function (te a, te b)
  | `AST_longarrow (_,(a,b)) -> `TYP_cfunction (te a, te b)
  | `AST_superscript (_,(a,b)) -> `TYP_array (te a, te b)
  | `AST_lvalue (sr,e) -> `TYP_lvalue (te e)
  | `AST_ref (sr,e) -> `TYP_pointer (te e)
  | `AST_sum (_,ts) -> 
    let ts = map te ts in
    if all_tunits ts then
      `TYP_unitsum (length ts)
    else
      `TYP_sum ts

  | `AST_lift (sr,e) -> `TYP_lift (te e)

  | `AST_orlist (sr,ts) -> 
    begin match ts with
    | [] -> assert false
    | [x] -> assert false
    | h :: t ->
      let llor = `AST_name (sr,"lor",[]) in
      fold_left (fun sum t -> `TYP_apply (llor,`TYP_type_tuple[sum; te t])) (te h) t
    end

  | `AST_andlist (sr,ts) ->
    begin match ts with
    | [] -> assert false
    | [x] -> assert false
    | h :: t ->
      let lland = `AST_name (sr,"land",[]) in
      fold_left (fun sum t -> `TYP_apply (lland,`TYP_type_tuple [sum; te t])) (te h) t
    end

  | `AST_typeof (_,e) -> `TYP_typeof e
  | `AST_as (sr,(t,x)) -> `TYP_as (te t,x)

  | `AST_literal (sr,`AST_int (enc,v)) ->
    if enc <> "int" 
    then 
      clierr sr
      (
        "Only plain integer can be used as a type, code= '" ^ 
        enc ^
        "'"
      )
    else 
    let v = ref 
      begin try Big_int.int_of_big_int v
      with _ -> clierr sr "Integer used as type out of range"
      end
    in
      if !v <0 then clierr sr "Negative int not allowed as type"
      else if !v = 0 then ((`AST_void sr) :> typecode_t)
      else if !v = 1 then `TYP_tuple[]
      else `TYP_unitsum !v

  (* NOTE SPECIAL NAME HANDLING HACKS!! *)
  | `AST_apply(sr,(e1,e2)) ->
    begin match e1 with
    | `AST_name (_,name,[]) ->
      let name' = name ^ "          " (* 10 chars *) in
      if name = "typeof" then `TYP_typeof e2 
      else let arg = typecode_of_expr e2 in
      if name = "_isin" then
      begin
        match arg with
        | `TYP_type_tuple [memt; sett] ->
           `TYP_isin (memt, sett)
        | _ -> 
          (* this can be fixed by taking projections but I can't be bothered atm *)
          failwith 
           "Implementation limitation, 'isin' operator requires two explicit arguments"
      end
      else if name = "typesetof" then
      begin
        match arg with 
        | `TYP_type_tuple ls -> `TYP_typeset ls
        | x -> `TYP_typeset [x]
      end
      else if name = "compl" then `TYP_dual arg
      else if String.sub name' 0 5 = "proj_" 
      then 
        begin 
          let acc = ref 0 in
          for i = 5 to String.length name - 1 do
          if name.[i] <= '9' && name.[i] >='0'
          then acc := 10 * !acc + Char.code (name.[i]) - Char.code '0'
          else
            clierr sr 
            (
              "Digits expected in name '" ^ name ^ "' in\n" ^
              short_string_of_src sr
            )
          done;
          `TYP_proj (!acc, arg)
         end

      else if String.sub name' 0 9 = "case_arg_" 
      then 
        begin 
          let acc = ref 0 in
          for i = 9 to String.length name - 1 do
          if name.[i] <= '9' && name.[i] >='0'
          then acc := 10 * !acc + Char.code (name.[i]) - Char.code '0'
          else
            clierr sr
            (
              "Digits expected in name '" ^ name ^ "' in\n" ^
              short_string_of_src sr
            )
          done;
          `TYP_case_arg (!acc, arg)
         end
      else 
        `TYP_apply (typecode_of_expr e1,arg)

    | _ ->
      `TYP_apply (typecode_of_expr e1,typecode_of_expr e2)
    end

  | `AST_lambda (sr,(vs,paramss,ret,body)) ->
     begin match paramss with
     | [params,traint] ->
       (* constraint is ignored for now!! *)
       begin match body with
       | [`AST_fun_return (_,e)] -> 
         begin 
           try
             let t = typecode_of_expr e in
             match paramss,ret with
             (* special case, allows {t} to mean 1 -> t *)
             | [[],None],`TYP_none -> 
              `TYP_function (`TYP_tuple [],t)
             | _ ->
             let params = map (fun (x,y,z,d)-> y,z) params in
             `TYP_typefun 
             ( 
               params,
               ret,
               t
             )
           with _ -> 
             clierr sr 
             "Type lambda must return type expression"
         end

       | _ -> 
         clierr sr
         "Type lambda must just be 'return type_expr'"
       end
     | _ -> 
       clierr sr
       "Type lambda only allowed one argument (arity=1)"
     end

  | `AST_type_match (sr,(e,ps)) ->
    `TYP_type_match (e,ps)

  | `AST_noexpand (sr,e) -> te e

  | `AST_patvar _ as e -> e
  | `AST_patany _ as e -> e
  | #expr_t -> 
    let sr = src_of_expr e in
    clierr sr ("Type expression expected, got " ^ string_of_expr e)
    
@head(1,'Charset')
@select(tangler('src/compiler/flxlib/flx_charset.mli'))
open Flx_ast
type charset_t
val charset_of_string: string -> charset_t
val charset_of_int_range: int -> int -> charset_t
val charset_of_range: string -> string -> charset_t
val charset_union: charset_t -> charset_t -> charset_t
val charset_inv: charset_t -> charset_t
val regexp_of_charset: charset_t -> regexp_t
val regexp_underscore: regexp_t
val eol: int
val regexp_dot: regexp_t

@select(tangler('src/compiler/flxlib/flx_charset.ml'))
open Flx_ast
type charset_t = bool array

let charset_of_string s = 
  let x = Array.make 256 false in
  for i  = 0 to String.length s - 1 do
    x.(Char.code s.[i]) <- true
  done;
  x


let charset_of_int_range x1 x2 =
  let x = Array.make 256 false in
  for i = x1 to x2 do
    x.(i) <- true 
  done
  ;
  x

let charset_of_range s1 s2 =
  if String.length s1 <> 1 
  then
    failwith "Charset range(first) requires string length 1"
  ;
  if String.length s2 <> 1 
  then
    failwith "Charset range(last) requires string length 1"
  ;
  let x1 = Char.code (s1.[0])
  and x2 = Char.code (s2.[0])
  in 
    charset_of_int_range x1 x2

let charset_union x1 x2 = 
  let x = Array.make 256 false in
  for i = 0 to 255 do
    x.(i) <- x1.(i) || x2.(i)
  done;
  x

let charset_inv y =
  let x = Array.make 256 false in
  for i = 0 to 255 do
    x.(i) <- not y.(i)
  done;
  x

let regexp_of_charset y =
  let res = ref `REGEXP_epsilon in
  for i = 0 to 255 do
    if y.(i) then res := 
      let r = `REGEXP_string (String.make 1 (Char.chr i)) in
      if !res = `REGEXP_epsilon 
      then r 
      else `REGEXP_alt ( !res, r)
  done
  ;
  !res

let regexp_underscore = 
  regexp_of_charset (charset_of_int_range 0 255)

let eol = Char.code '\n'

let regexp_dot = 
  regexp_of_charset 
  (
    charset_union 
      (charset_of_int_range 0 (eol - 1))
      (charset_of_int_range (eol + 1) 255)
  )


