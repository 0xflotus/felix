@head(1,'Utilities')
Generic (non Felix dependent) utilities.
@h = tangler('src/flx_util.mli')
@select(h)
(** Generic utilities *)

(** n spaces 
*)
val spaces : int -> string

(** String.concat sep (map fun lst) 
*)
val catmap : string -> ('a -> string) -> 'a list -> string

(** reverse application *)
val (+>) : 'a -> ('a ->'b) -> 'b

(** hmmm *)
val transpose: 'a list list -> 'a list list

(** last element of list 
*)
val list_last: 'a list -> 'a 

(** position in list of value *)
val list_index: 'a list -> 'a -> int option

(** forward order map *)
val list_omap: ('a -> 'b) -> 'a list -> 'b list

(** convert exception to option *)
val catch_all : ('a -> 'b) -> 'a -> 'b option

(** test if option not None *)
val is_some: 'a option -> bool

(** list of n integers 0  to n-1 *)
val nlist: int -> int list

(** first n elements of a list *)
val list_prefix: 'a list -> int -> 'a list

(** synonym for string_of_int *)
val si: int -> string

(** synonym for String.concat *)
val cat: string -> string list -> string

(** synonym for Buffer.add_string *)
val bcat: Buffer.t -> string -> unit

(** make a hashtable from an assoc list *)
val hashtable_of_list:
  ('a * 'b) list ->
  ('a,'b) Hashtbl.t

(** fixpoint combinator *)
val fix:
 (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b

(** add elements to unique list *)
val uniq_cat: 'a list -> 'a list -> 'a list

(** make a list of unique elements *)
val uniq_list: 'a list -> 'a list

@h = tangler('src/flx_util.ml')
@select(h)
open List
let spaces level = String.make (level*2) ' '
let catmap sep fn ls = String.concat sep (map fn ls)
let (+>) x f = f x (* reverse application *)
let transpose x =
  let dtor ls =
    split (map (fun x -> hd x, tl x) ls)
  in let rec cons ls (h,t) = match hd t with
    | [] -> h :: ls
    | _ -> cons (h :: ls) (dtor t)
  in tl (rev (cons [] ([],x)))

let list_last l = hd (rev l)

let list_prefix lst n =
  let rec aux ol nl n = 
    if n>0 then aux (tl ol) (hd ol :: nl) (n-1)
    else rev nl
  in aux lst [] n

let rec list_index l x = 
 let rec aux l i =
   match l with
   | [] -> None
   | h::t -> 
    if x = h then Some i
    else aux t (i+1)
  in aux l 0

let list_omap f ls =
  rev (rev_map f ls)

let catch_all f x = 
  try Some (f x) with _ -> None

let is_some = function | Some _ -> true | None -> false

let nlist n = 
  let lst = ref [] in
  for i = 1 to n do lst := (n-i) :: !lst done;
  !lst

let si = string_of_int
let cat = String.concat
let bcat = Buffer.add_string

let hashtable_of_list lst = 
  let t = Hashtbl.create (length lst) in
  iter
  (fun (k,v) -> Hashtbl.add t k v)
  lst
  ;
  t

let rec fix f x = f (fix f) x

let uniq_cat u nu  =
  fold_left 
  (fun l i -> if mem i l then l else i :: l) 
  u
  nu

let uniq_list lst = uniq_cat [] lst

@h = tangler('src/flx_dlst.mli')
@select(h)
type direction = Fwd | Rev
val dir_rev : direction -> direction
type 'a dlst = { dir : direction; lst : 'a list; }
val dfwd : 'a dlst -> 'a list
val drev : 'a dlst -> 'a list
val dlst_fwd : 'a list -> 'a dlst
val dlst_rev : 'a list -> 'a dlst
val dlst_lst : 'a dlst -> 'a list
val dlst_dir : 'a dlst -> direction
val dlst_map : ('a -> 'b) -> 'a dlst -> 'b dlst
val append : 'a dlst -> 'a -> 'a dlst
val prepend : 'a dlst -> 'a -> 'a dlst
val cons : 'a list -> 'a -> 'a list
val concat : 'a dlst -> 'a dlst -> 'a dlst

@h = tangler('src/flx_dlst.ml')
@select(h)
open List
type direction = Fwd | Rev
let dir_rev = function | Fwd -> Rev | Rev->Fwd

type 'a dlst = { dir:direction; lst: 'a list }

let dfwd = function
  | {dir=Fwd; lst=l} -> l
  | {dir=Rev; lst=l} -> rev l

let drev = function
  | {dir=Fwd; lst=l} -> l
  | {dir=Rev; lst=l} -> rev l

let dlst_fwd = function l -> {dir=Fwd; lst=l}
let dlst_rev = function l -> {dir=Rev; lst=l}

let dlst_lst = function {lst=l} -> l
let dlst_dir = function {dir=d} -> d

let dlst_map f {dir=d; lst=l} = {dir=dir_rev d; lst=rev_map f l}

let append = function 
  | {dir=Fwd; lst=l} -> (fun e -> {dir=Rev; lst=e::rev l})
  | {dir=Rev; lst=l} as d -> (fun e -> {d with lst=e::l})

let prepend = function 
  | {dir=Rev; lst=l} -> (function e -> {dir=Fwd; lst=e::rev l})
  | {dir=Fwd; lst=l} as d -> (function e -> {d with lst=e::l})

let cons = function lst -> (function elt -> elt :: lst)

let concat a b = match (a,b) with
  | {dir=Rev; lst=l1}, {dir=Fwd; lst=l2} -> 
    {dir=Rev; lst=fold_left cons l1 l2}

  | {dir=Fwd; lst=l1}, {dir=Fwd; lst=l2} -> 
    {dir=Rev; lst=fold_left cons (rev l1) (rev l2)}

  | {dir=Rev; lst=l1}, {dir=Rev; lst=l2} -> 
    {dir=Rev; lst=fold_left cons l1 (rev l2)}

  | {dir=Fwd; lst=l1}, {dir=Rev; lst=l2} -> 
    {dir=Rev; lst=fold_left cons (rev l1) l2}
  
@head(1,'AST')
@h = tangler('src/flx_ast.mli')
@head(2,'Source Reference')
Provides a reference to the original source.
@select(h)
(** Types used in the Felix compiler *)
open Big_int

(** type of a position in the {e original} sources *)
type srcref = 
  string (* filename *) *
  int (* line number, 1 origin *) *
  int (* starting column, 1 origin *) *
  int (* ending column, 1 origin *)

(** type of a span between two positions in one file*)
type range_srcref =
  string * (* filename *)
  int * (* starting line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int * (* ending line number, 1 origin *)
  int   (* ending column, 1 origin *)

type bigint = big_int

@head(2,'Abstract Syntax Tree')
AST types are nodes of the Abstract Syntax Tree generated by the
parser. 

@head(3,'Names')
A simple name is an identifier, a qualified name is a dot (.) separated list
of instantiated names, and a instantiated name is a simple name optionally
followed by a square bracket enclosed list of type expressions.
@select(h)
type c_t = string     (* C++ code as a string *)
type id_t = string
type vs_list_t = (id_t * int) list
type bid_t = int
type index_map_t = (int,int) Hashtbl.t

(** type of a qualified name *)
type qualified_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list 
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  ]

(** type of a suffixed name *)
and suffixed_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list  
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)  
  ]

(** type of a regular expression *)
and regexp_t =
  | REGEXP_seq of regexp_t * regexp_t (** concatenation *)
  | REGEXP_alt of regexp_t * regexp_t (** alternation *)
  | REGEXP_aster of regexp_t (** Kleene closure *)
  | REGEXP_name of qualified_name_t (** lookup regular definition *)
  | REGEXP_string of string  (** concatenation of chars of string *)
  | REGEXP_epsilon (** epsilon: null string *)
  | REGEXP_sentinel (** end marker *)
  | REGEXP_code of expr_t (** associated code *)

@head(3,'Type sublanguage')
The encoding '`TYP_void'
is the categorical initial: the type of an empty
union, and the type ordinary procedure types return.
There are no values of this type. 
@select(h)
(** type of a type *)
and typecode_t = 
  [
  | `AST_void of range_srcref                   (** void type *)
  | `AST_name of range_srcref * string * typecode_t list 
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `TYP_tuple of typecode_t list               (** product type *)
  | `TYP_unitsum of int                         (** sum of units  *)
  | `TYP_sum of typecode_t list                 (** numbered sum type *)
  | `TYP_function of typecode_t * typecode_t    (** function type *)
  | `TYP_pointer of typecode_t                  (** pointer type *)
  | `TYP_array of typecode_t * typecode_t       (** array type base ^ index *)
  | `TYP_as of typecode_t * string              (** fixpoint *)
  | `TYP_typeof of expr_t                       (** typeof *)
  | `TYP_var of int                             (** unknown type *)
  | `TYP_none                                   (** unspecified *)
  | `TYP_ellipsis                               (** ... for varargs *)
  | `TYP_lvalue of typecode_t                   (** ... lvalue annotation *)

  (* dualizer *)
  | `TYP_dual of typecode_t                     (** dual *)

  (* destructors *)
  | `TYP_dom of typecode_t                      (** function domain extractor *)
  | `TYP_cod of typecode_t                      (** function codomain extractor *)
  | `TYP_proj of int * typecode_t               (** tuple projection *)
  | `TYP_case_arg of int * typecode_t           (** argument of n'th variant *)

  | `TYP_apply of typecode_t * typecode_t       (** type function application *)
  | `TYP_typefun of parameter_t list * typecode_t * typecode_t
                                                (** type lambda *)
  | `TYP_type                                   (** meta type of a type *)
  | `TYP_type_tuple of typecode_t list          (** meta type product *)

  | `TYP_type_match of typecode_t * (tpattern_t * typecode_t) list

  | `TYP_glr_attr_type of qualified_name_t
  ]

and tpattern_t =
  [
  |  `TPAT_function of tpattern_t * tpattern_t
  |  `TPAT_sum of tpattern_t list
  |  `TPAT_tuple of tpattern_t list
  |  `TPAT_pointer of tpattern_t
  |  `TPAT_void
  |  `TPAT_var of string
  |  `TPAT_name of string * tpattern_t list
  |  `TPAT_as of tpattern_t * string
  |  `TPAT_any
  ]

@head(3,'Literals')
Literals recognized by the lexer.
@select(h)
and literal_t =
  [
  | `AST_int of string * bigint
  | `AST_string of string
  | `AST_cstring of string
  | `AST_wstring of string
  | `AST_ustring of string
  | `AST_float of string * string
  ]

@head(3,'Expressions')
Raw expression terms.

@select(h)
and expr_t =
  [
  | `AST_map of range_srcref * expr_t * expr_t
  | `AST_noexpand of range_srcref * expr_t
  | `AST_name of range_srcref * string * typecode_t list 
  | `AST_the of range_srcref * qualified_name_t
  | `AST_index of range_srcref * string * int
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list) 
  | `AST_apply of range_srcref * (expr_t * expr_t)
  | `AST_tuple of range_srcref * expr_t list
  | `AST_arrayof of range_srcref * expr_t list
  | `AST_coercion of range_srcref * (expr_t * typecode_t)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t) 

  | `AST_void of range_srcref
  | `AST_ellipsis of range_srcref
  | `AST_product of range_srcref * expr_t list
  | `AST_sum of range_srcref * expr_t list
  | `AST_arrow of range_srcref * (expr_t * expr_t)
  | `AST_superscript of range_srcref * (expr_t * expr_t)

  | `AST_literal of range_srcref * literal_t
  | `AST_deref of range_srcref * expr_t
  | `AST_ref of range_srcref * expr_t
  | `AST_lvalue of range_srcref * expr_t
  | `AST_method_apply of range_srcref * (id_t * expr_t)
  | `AST_dot of range_srcref * (expr_t * id_t)
  | `AST_lambda of range_srcref * (parameter_t list list * typecode_t * statement_t list)

  | `AST_match_ctor of range_srcref * (qualified_name_t * expr_t)
  | `AST_match_case of range_srcref * (int * expr_t)
  | `AST_ctor_arg of range_srcref * (qualified_name_t * expr_t)
  | `AST_case_arg of range_srcref * (int * expr_t)
  | `AST_case_index of range_srcref * expr_t (* the zero origin variant index *)

  | `AST_letin of range_srcref * (pattern_t * expr_t * expr_t)

  | `AST_get_n of range_srcref * (int * expr_t) (* get n'th component of a tuple *)
  | `AST_as of range_srcref * (expr_t * string)
  | `AST_match of range_srcref * (expr_t * (pattern_t * expr_t) list)
  | `AST_parse of range_srcref * expr_t * (range_srcref * production_t * expr_t) list
  | `AST_sparse of range_srcref * expr_t * string * int list

  | `AST_regmatch of range_srcref * (expr_t * (regexp_t * expr_t) list)
  | `AST_reglex of range_srcref * (expr_t * expr_t * (regexp_t * expr_t) list)
  | `AST_typeof of range_srcref * expr_t
  | `AST_cond of range_srcref * (expr_t * expr_t * expr_t)

  | `AST_expr of range_srcref * string * typecode_t

  | `AST_type_match of range_srcref * (typecode_t * (tpattern_t * typecode_t) list)
   
  ]

@head(3,'Pattern')
Patterns; used for matching variants in match statements.
@select(h)
and float_pat = 
  | Float_plus of string * string (** type, value *)
  | Float_minus of string * string
  | Float_inf  (** infinity *)
  | Float_minus_inf (** negative infinity *)

and pattern_t =
  [
  | `PAT_nan of range_srcref
  | `PAT_none of range_srcref

  (* constants *)
  | `PAT_int of range_srcref * string * bigint
  | `PAT_string of range_srcref * string

  (* ranges *)
  | `PAT_int_range of range_srcref * string * bigint * string * bigint
  | `PAT_string_range of range_srcref * string * string
  | `PAT_float_range of range_srcref * float_pat * float_pat 

  (* other *)
  | `PAT_coercion of range_srcref * pattern_t * typecode_t
  
  | `PAT_name of range_srcref * id_t 
  | `PAT_tuple of range_srcref * pattern_t list
  | `PAT_any of range_srcref 
  | `PAT_regexp of range_srcref * string * id_t list 
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | `PAT_const_ctor of range_srcref * qualified_name_t
  | `PAT_nonconst_ctor of range_srcref * qualified_name_t * pattern_t
  | `PAT_as of range_srcref * pattern_t * id_t
  | `PAT_when of range_srcref * pattern_t * expr_t
  ]

@head(3,'Statements')
Statements; that is, the procedural sequence control system.
@select(h)
and parameter_t = id_t * typecode_t
and macro_parameter_type_t = 
  | Ident 
  | Expr 
  | Stmt
and macro_parameter_t = id_t * macro_parameter_type_t
and lvalue_t = [ 
  | `Val of range_srcref * string
  | `Var of range_srcref * string
  | `Name of range_srcref * string
  | `Skip of range_srcref 
  | `List of tlvalue_t list
  | `Expr of range_srcref * expr_t
]
and tlvalue_t = lvalue_t * typecode_t option

and funkind_t = [
  | `Object 
  | `Function 
  | `InlineFunction 
  | `NoInlineFunction
]

and property_t = [
  | `Recursive 
  | `Inline 
  | `NoInline 
  | `Inlining_complete
]

and type_qual_t = [
  | `Incomplete
  | `Pod
]

and requirement_t = [
  | `Named_req of qualified_name_t 
  | `Body_req of string
  | `Header_req of string
]

and requirements_t = requirement_t list
and named_reqs_t = qualified_name_t list
and prec_t = string
and glr_term_t = 
[
  | `GLR_name of qualified_name_t
  | `GLR_opt of glr_term_t
  | `GLR_ast of glr_term_t
  | `GLR_plus of glr_term_t
  | `GLR_alt of glr_term_t list
  | `GLR_seq of glr_term_t list
]

and glr_entry_t = string option * glr_term_t
and production_t = glr_entry_t list

and reduced_glr_entry_t = string option * qualified_name_t
and reduced_production_t = reduced_glr_entry_t list

and statement_t =
  [ 
  | `AST_include of range_srcref * string 
  | `AST_open of range_srcref * qualified_name_t
  | `AST_inject_module of range_srcref * qualified_name_t
  | `AST_use of range_srcref * id_t * qualified_name_t
  | `AST_comment of string (* for documenting generated code *)
  | `AST_public of range_srcref * string * statement_t
  | `AST_private of range_srcref * statement_t

  (* definitions *)
  | `AST_function of range_srcref * id_t * id_t list * parameter_t list * typecode_t * property_t list * statement_t list
  | `AST_curry of range_srcref * id_t * id_t list * parameter_t list list * typecode_t * funkind_t * statement_t list
  | `AST_object of range_srcref * id_t * id_t list * parameter_t list * statement_t list
  | `AST_regdef of range_srcref * string * regexp_t
  | `AST_glr of range_srcref * string * typecode_t * (range_srcref * production_t * expr_t) list
  

  (* macros *)
  | `AST_name_macro of range_srcref * id_t * id_t 
  | `AST_expr_macro of range_srcref * id_t * macro_parameter_t list * expr_t
  | `AST_stmt_macro of range_srcref * id_t * macro_parameter_t list * statement_t list
  | `AST_macro_val  of range_srcref * id_t * expr_t
  | `AST_macro_var  of range_srcref * id_t * expr_t
  | `AST_macro_assign of range_srcref * id_t * expr_t
  | `AST_macro_forget of range_srcref * id_t list
  | `AST_macro_label of range_srcref * id_t
  | `AST_macro_goto of range_srcref * id_t
  | `AST_macro_ifgoto of range_srcref * expr_t * id_t
  | `AST_macro_proc_return of range_srcref

  (* types *)
  | `AST_union of range_srcref * id_t * id_t list * (id_t * typecode_t) list
  | `AST_struct of range_srcref * id_t * id_t list * (id_t * typecode_t) list
  | `AST_cstruct of range_srcref * id_t * id_t list * (id_t * typecode_t) list
  | `AST_type_alias of range_srcref * id_t * id_t list * typecode_t
  | `AST_inherit of range_srcref * id_t * id_t list * qualified_name_t
  | `AST_inherit_fun of range_srcref * id_t * id_t list * qualified_name_t

  (* variables *)
  | `AST_val_decl of range_srcref * id_t * id_t list * typecode_t option * expr_t option
  | `AST_var_decl of range_srcref * id_t * id_t list * typecode_t option * expr_t option
 
  (* module system *)
  | `AST_untyped_module of range_srcref * id_t * id_t list * statement_t list  
 
  (* control structures: primitives *)
  | `AST_label of range_srcref * id_t
  | `AST_whilst of range_srcref * expr_t * statement_t list
  | `AST_until of range_srcref * expr_t * statement_t list
  | `AST_goto of range_srcref * id_t 
  | `AST_ifgoto of range_srcref * expr_t *id_t
  | `AST_ifreturn of range_srcref * expr_t
  | `AST_ifdo of range_srcref * expr_t * statement_t list * statement_t list
  | `AST_ifnotgoto of range_srcref * expr_t * id_t
  | `AST_call of range_srcref * expr_t * expr_t 
  | `AST_assign of range_srcref * string * tlvalue_t * expr_t 
  | `AST_cassign of range_srcref * expr_t * expr_t 
  | `AST_jump of range_srcref * expr_t * expr_t 
  | `AST_loop of range_srcref * id_t * expr_t 
  | `AST_read of range_srcref * id_t
  | `AST_fun_return of range_srcref * expr_t
  | `AST_proc_return of range_srcref 
  | `AST_nop of range_srcref * string

  (* binding structures [prolog] *)
  | `AST_abs_decl of range_srcref * id_t * id_t list * type_qual_t list * c_t * requirements_t
  | `AST_ctypes of range_srcref * (srcref * id_t) list * type_qual_t list  * requirements_t 
  | `AST_const_decl of range_srcref * id_t * id_t list * typecode_t * c_t * requirements_t
  | `AST_fun_decl of range_srcref * id_t * id_t list * typecode_t list * typecode_t * c_t  * requirements_t * prec_t

  (* embedding *)
  | `AST_header of range_srcref * id_t * id_t list * c_t * requirements_t
  | `AST_body of range_srcref * id_t * id_t list * c_t * requirements_t
  | `AST_code of range_srcref * string
  | `AST_noreturn_code of range_srcref * string

  | `AST_export_fun of range_srcref * suffixed_name_t * string
  | `AST_export_type of range_srcref * typecode_t * string

  ]


and exe_t =
  [
  | `EXE_code of string (* for inline C++ code *)
  | `EXE_noreturn_code of string (* for inline C++ code *)
  | `EXE_comment of string (* for documenting generated code *)
  | `EXE_label of string (* for internal use only *)
  | `EXE_goto of string  (* for internal use only *)
  | `EXE_ifgoto of expr_t * string  (* for internal use only *)
  | `EXE_ifnotgoto of expr_t * string  (* for internal use only *)
  | `EXE_call of expr_t * expr_t 
  | `EXE_jump of expr_t * expr_t 
  | `EXE_loop of id_t * expr_t 
  | `EXE_read of id_t
  | `EXE_fun_return of expr_t
  | `EXE_proc_return
  | `EXE_nop of string
  | `EXE_init of id_t * expr_t 
  | `EXE_iinit of (id_t * int) * expr_t 
  | `EXE_assign of expr_t * expr_t 
  | `EXE_regmatch of (expr_t * (regexp_t * expr_t) list)
  | `EXE_reglex of (expr_t * expr_t * (regexp_t * expr_t) list)
  ]

type sexe_t = range_srcref * exe_t

@doc()
The whole of a compilation unit, this is the data structure
returned by parsing a whole file.
@select(h)
type compilation_unit_t = statement_t list


@head(1,'Types')
@h = tangler('src/flx_types.mli')
These files declare the main data structures used by the compiler,
and provide routines to dump them to a string for debugging purposes.

@head(2,'Generic partial ordering comparison result')
@select(h)
open Flx_mtypes1

type partial_order_result_t = 
[
  | `Less 
  | `Equal 
  | `Greater 
  | `Incomparable
]


@head(2,'Version identification kit')
@select(h)
open Flx_ast
type version_data_t =
{
  version_string : string;
  build_time_float : float;
  build_time : string;
  buildno : int;
}

@head(3,'Pattern extractor')
This type is used to extract components of a value,
corresponding to a match.
@select(h)
type dir_t =
  | DIR_open of qualified_name_t
  | DIR_inject_module of qualified_name_t
  | DIR_use of id_t * qualified_name_t

type dcl_t = 
  [

  (* data structures *)
  | `DCL_function of     parameter_t list * typecode_t * property_t list * asm_t list
  | `DCL_union of        (id_t * typecode_t) list
  | `DCL_struct of       (id_t * typecode_t) list
  | `DCL_cstruct of      (id_t * typecode_t) list
  | `DCL_match_check of pattern_t * (string * int)
  | `DCL_match_handler of pattern_t * (string * int) * asm_t list
  | `DCL_glr of          typecode_t * (reduced_production_t * expr_t)
 
  (* variables *)
  | `DCL_val of          typecode_t
  | `DCL_var of          typecode_t
  | `DCL_type_alias of   typecode_t
  | `DCL_inherit of   qualified_name_t
  | `DCL_inherit_fun of   qualified_name_t

  (* module system *)
  | `DCL_module of       asm_t list  

  (* binding structures [prolog] *)
  | `DCL_abs of          type_qual_t list * c_t * named_reqs_t
  | `DCL_const of        typecode_t * c_t * named_reqs_t
  | `DCL_fun of          typecode_t list * typecode_t * c_t * named_reqs_t * prec_t
  | `DCL_header of       c_t * named_reqs_t
  | `DCL_body of         c_t * named_reqs_t
  | `DCL_regdef of      regexp_t
  ]

and access_t = [`Private | `Public ]

and asm_t = 
  
  | Exe of range_srcref * exe_t 
  | Dcl of range_srcref * id_t * int option * access_t * id_t list * dcl_t 
  | Iface of range_srcref * iface_t
  | Dir of range_srcref * dir_t
 
and entry_kind_t = int

and entry_set_t =
  | FunctionEntry of entry_kind_t list
  | NonFunctionEntry of entry_kind_t
  
and module_rep_t = 
  | Simple_module of bid_t * typecode_t list * name_map_t * dir_t list

and name_map_t = (string, entry_set_t) Hashtbl.t

and iface_t =
  [
  | `IFACE_export_fun of suffixed_name_t * string
  | `IFACE_export_type of typecode_t * string
  ]

(** value typing *)
type 't b0typecode_t' = 
  [
  | `BTYP_inst of bid_t * 't list 
  | `BTYP_tuple of 't list         
  | `BTYP_unitsum of int
  | `BTYP_sum of 't list 
  | `BTYP_function of 't * 't
  | `BTYP_pointer  of 't 
  | `BTYP_lvalue  of 't 
  | `BTYP_array of 't * 't 
  | `BTYP_void                       
  | `BTYP_fix of int      
  | `BTYP_var of int     
  ]

(** meta typing *)
type 't b1typecode_t' =
  [
  | `BTYP_apply of 't * 't 
  | `BTYP_typefun of (int * 't) list * 't * 't
  | `BTYP_type
  | `BTYP_type_tuple of 't list
  | `BTYP_type_match of 't * ('t * 't) list
  ]

(** general typing *)
type 't btypecode_t' =
  [
  | 't b0typecode_t'
  | 't b1typecode_t'
  ]

type b0typecode_t = 't b0typecode_t' as 't
type btypecode_t = 't btypecode_t' as 't

type biface_t =
  [
  | `BIFACE_export_fun of range_srcref * bid_t * string
  | `BIFACE_export_type of range_srcref * btypecode_t * string
  ]

type regular_args_t =
    int list * (* alphabet *)
    int *      (* state count *)
    (int, tbexpr_t) Hashtbl.t * (* state->expression map *)
    (int * int, int) Hashtbl.t (* transition matrix *)

and bexe_t =
  [
  | `BEXE_label of range_srcref * string
  | `BEXE_comment of range_srcref * string (* for documenting generated code *)
  | `BEXE_halt of range_srcref * string  (* for internal use only *)
  | `BEXE_goto of range_srcref * string  (* for internal use only *)
  | `BEXE_ifgoto of range_srcref * tbexpr_t * string  (* for internal use only *)
  | `BEXE_ifnotgoto of range_srcref * tbexpr_t * string  (* for internal use only *)
  | `BEXE_call of range_srcref * tbexpr_t * tbexpr_t 
  | `BEXE_call_direct of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_call_stack of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_call_prim of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_jump of range_srcref * tbexpr_t * tbexpr_t 
  | `BEXE_jump_direct of range_srcref * bid_t * btypecode_t list * tbexpr_t 
  | `BEXE_loop of range_srcref * int * tbexpr_t 
  | `BEXE_read of range_srcref * bid_t
  | `BEXE_fun_return of range_srcref * tbexpr_t
  | `BEXE_proc_return of range_srcref   
  | `BEXE_nop of range_srcref * string
  | `BEXE_code of range_srcref * string
  | `BEXE_nonreturn_code of range_srcref * string
  | `BEXE_assign of range_srcref * tbexpr_t * tbexpr_t 
  | `BEXE_init of range_srcref * bid_t * tbexpr_t 
  | `BEXE_regmatch of range_srcref * tbexpr_t * regular_args_t
  | `BEXE_reglex of range_srcref * tbexpr_t * tbexpr_t * regular_args_t
  ]

and bexpr_t =
  [
  | `BEXPR_parse of tbexpr_t * int list
  | `BEXPR_deref of tbexpr_t
  | `BEXPR_name of bid_t * btypecode_t list
  | `BEXPR_ref of bid_t * btypecode_t list
  | `BEXPR_literal of literal_t 
  | `BEXPR_apply of tbexpr_t * tbexpr_t 
  | `BEXPR_apply_prim of bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_direct of bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_apply_stack of bid_t * btypecode_t list * tbexpr_t 
  | `BEXPR_tuple of tbexpr_t list
  | `BEXPR_get_n of int * tbexpr_t
  | `BEXPR_closure of bid_t * btypecode_t list
  | `BEXPR_case of int * btypecode_t
  | `BEXPR_match_case of int * tbexpr_t
  | `BEXPR_case_arg of int * tbexpr_t
  | `BEXPR_case_index of tbexpr_t
  | `BEXPR_expr of string * btypecode_t
  ]

and tbexpr_t = bexpr_t * btypecode_t

and glr_symbol_t = [`Term of int | `Nonterm of int list]
and bglr_entry_t = string option * glr_symbol_t 
and bproduction_t = bglr_entry_t list

and bparameter_t = string * (int * btypecode_t)
and breqs_t = (bid_t * btypecode_t list) list
and bvs_t = (string * int) list

and bbdcl_t = 
  [
  | `BBDCL_function of   property_t list * bvs_t * bparameter_t list * btypecode_t * bexe_t list
  | `BBDCL_procedure of  property_t list * bvs_t * bparameter_t list * bexe_t list
  | `BBDCL_val of        bvs_t * btypecode_t
  | `BBDCL_var of        bvs_t * btypecode_t
  | `BBDCL_glr of        bvs_t * btypecode_t * (bproduction_t * bexe_t list)

  (* binding structures [prolog] *)
  | `BBDCL_abs of        bvs_t * type_qual_t list * c_t * breqs_t
  | `BBDCL_const of      bvs_t * btypecode_t * c_t * breqs_t
  | `BBDCL_fun of        bvs_t * btypecode_t list * btypecode_t * c_t  * breqs_t * prec_t
  | `BBDCL_proc of       bvs_t * btypecode_t list * c_t  * breqs_t
  | `BBDCL_header of     bvs_t * c_t  * breqs_t
  | `BBDCL_body of       bvs_t * c_t  * breqs_t
  
  | `BBDCL_union of      bvs_t * (id_t * btypecode_t) list
  | `BBDCL_struct of     bvs_t * (id_t * btypecode_t) list
  | `BBDCL_cstruct of     bvs_t * (id_t * btypecode_t) list
  | `BBDCL_nonconst_ctor of bvs_t * int * btypecode_t * int * btypecode_t
  ]

and typevarmap_t = (int,btypecode_t) Hashtbl.t

type env_t = (bid_t * id_t * name_map_t * name_map_t list) list 

type symbol_definition_t =
  [
  | `SYMDEF_abs of type_qual_t list * c_t * named_reqs_t
  | `SYMDEF_regdef of regexp_t
  | `SYMDEF_glr of typecode_t * (reduced_production_t * sexe_t list) 

  | `SYMDEF_parameter of  typecode_t
  | `SYMDEF_typevar of typecode_t (* usually type TYPE *)

  | `SYMDEF_function of parameter_t list * typecode_t * property_t list * sexe_t list

  | `SYMDEF_match_check of  pattern_t * (string *int)
  | `SYMDEF_module

  | `SYMDEF_const_ctor of int * typecode_t * int
  | `SYMDEF_nonconst_ctor of int * typecode_t * int * typecode_t

  | `SYMDEF_const of typecode_t * c_t * named_reqs_t
  | `SYMDEF_var of  typecode_t
  | `SYMDEF_val of  typecode_t
  | `SYMDEF_fun of typecode_t list * typecode_t * c_t  * named_reqs_t * prec_t
  | `SYMDEF_header of c_t  * named_reqs_t
  | `SYMDEF_body of c_t  * named_reqs_t
  | `SYMDEF_union of  (id_t * typecode_t) list
  | `SYMDEF_struct of  (id_t * typecode_t) list
  | `SYMDEF_cstruct of  (id_t * typecode_t) list
  | `SYMDEF_type_alias of   typecode_t
  | `SYMDEF_inherit of   qualified_name_t
  | `SYMDEF_inherit_fun of   qualified_name_t
  ]

type symbol_data_t = {
  id:string;
  sr:range_srcref;
  parent:int option;
  vs:vs_list_t;
  pubmap:name_map_t;
  privmap:name_map_t;
  dirs:dir_t list;
  symdef:symbol_definition_t;
}

type symbol_table_t = (int, symbol_data_t) Hashtbl.t

type symbol_data3_t = string * int option * range_srcref * bbdcl_t 
type fully_bound_symbol_table_t = (int, symbol_data3_t) Hashtbl.t

type type_registry_t = (btypecode_t,int) Hashtbl.t

@head(1,'Mappings')
@h = tangler('src/flx_maps.mli')
@select(h)
open Flx_ast
open Flx_types

val map_type:
  (typecode_t -> typecode_t) -> typecode_t -> typecode_t

val map_b0type:
  (b0typecode_t -> b0typecode_t) -> b0typecode_t -> b0typecode_t

val map_btype:
  (btypecode_t -> btypecode_t) -> btypecode_t -> btypecode_t

val iter_b0type:
  (b0typecode_t -> unit) -> b0typecode_t -> unit

val iter_btype:
  (btypecode_t -> unit) -> btypecode_t -> unit
  
val map_tbexpr:
  (bid_t -> bid_t) ->
  (tbexpr_t -> tbexpr_t) -> 
  (btypecode_t -> btypecode_t) ->
  tbexpr_t -> tbexpr_t

val iter_bexe:
  (bid_t -> unit) ->
  (tbexpr_t -> unit) ->
  (btypecode_t -> unit) ->
  (string -> unit) ->
  (string -> unit) ->
  bexe_t -> unit

val map_bexe:
  (bid_t -> bid_t) ->
  (tbexpr_t -> tbexpr_t) ->
  (btypecode_t -> btypecode_t) ->
  (string -> string) ->
  (string -> string) ->
  bexe_t -> bexe_t

val reduce_tbexpr:
  fully_bound_symbol_table_t ->
  tbexpr_t -> tbexpr_t

val reduce_bexe:
  fully_bound_symbol_table_t ->
  bexe_t -> bexe_t

val reduce_type:
  btypecode_t ->
  btypecode_t

@h = tangler('src/flx_maps.ml')
@select(h)
open Flx_ast
open Flx_types
open List
open Flx_typing

let rec list_of_n_things thing lst n =
  if n = 0 then lst 
  else list_of_n_things thing (thing::lst) (n-1)
  
let map_type f = function
  | `AST_name (sr,name,ts) -> `AST_name (sr,name, map f ts)
  | `AST_lookup (sr,(e,name,ts)) -> `AST_lookup (sr,(e,name,map f ts))
  | `AST_typed_case (sr,i,t) -> `AST_typed_case (sr,i, f t)
  | `TYP_tuple ts -> `TYP_tuple (map f ts)

  (* we have to do this, so that a large unitsume
     can be specified without overflowing the compiler
     storage
  *)
  | `TYP_unitsum k -> 
    if k>0 then
      let mapped_unit = f (`TYP_tuple []) in
      match mapped_unit with
      | `TYP_tuple [] ->
        `TYP_unitsum k
      | _ -> `TYP_tuple ( list_of_n_things mapped_unit [] k)
    else `TYP_unitsum k

  (* here we don't need to go to a unitsum, since
     we have already used up storage
  *)
  | `TYP_sum ts -> `TYP_sum (map f ts)
  | `TYP_function (a,b) -> `TYP_function (f a, f b)
  | `TYP_pointer t -> `TYP_pointer (f t)
  | `TYP_lvalue t -> `TYP_lvalue (f t)
  | `TYP_array (t1, t2) -> `TYP_array (f t1, f t2)
  | `TYP_as (t,s) -> `TYP_as (f t,s)

  (* destructors *)
  | `TYP_dom t -> `TYP_dom (f t)
  | `TYP_dual t -> `TYP_dual (f t)
  | `TYP_cod t -> `TYP_cod (f t)
  | `TYP_proj (i,t) -> `TYP_proj (i, f t)
  | `TYP_case_arg (i,t) -> `TYP_case_arg (i, f t) 
  | `TYP_type_match (t,ps) -> 
    let ps = map (fun (p,t) -> p, f t) ps in
    `TYP_type_match (f t, ps)
  
  (* meta constructors *)
  | `TYP_apply (a,b) -> `TYP_apply (f a, f b)
  | `TYP_typefun (ps, a, b) -> `TYP_typefun (ps, f a, f b)
  | `TYP_type_tuple ts -> `TYP_type_tuple (map f ts)
  | x -> x

let all_units' ts = 
  try 
    iter (function 
      | `BTYP_tuple [] -> () 
      | _ -> raise Not_found
    ) 
    ts; 
    true 
  with Not_found -> false

let map_b0type f = function
  | `BTYP_inst (i,ts) -> `BTYP_inst (i, map f ts)
  | `BTYP_tuple ts -> `BTYP_tuple (map f ts)

  | `BTYP_unitsum k -> 
    if k>0 then
      let mapped_unit = f (`BTYP_tuple []) in
      match mapped_unit with
      | `BTYP_tuple [] ->
        `BTYP_unitsum k
      | _ -> `BTYP_tuple ( list_of_n_things mapped_unit [] k)
    else `BTYP_unitsum k
  
  | `BTYP_sum ts -> 
    let ts = map f ts in
    if all_units' ts then
      `BTYP_unitsum (length ts)
    else
      `BTYP_sum ts

  | `BTYP_function (a,b) -> `BTYP_function (f a, f b)
  | `BTYP_pointer t->  `BTYP_pointer (f t)
  | `BTYP_lvalue t->  `BTYP_lvalue (f t)
  | `BTYP_array (t1,t2)->  `BTYP_array (f t1, f t2)
  | x -> x

let map_btype f = function
  | `BTYP_apply (a,b) -> `BTYP_apply (f a, f b)
  | `BTYP_typefun (its, a, b) ->
     `BTYP_typefun (map (fun (i,t) -> i, f t) its, f a , f b)
  | `BTYP_type_tuple ts -> `BTYP_type_tuple (map f ts)
  | `BTYP_type_match (t,ps) ->
    let g (a,b) = f a, f b in
    `BTYP_type_match (f t, map g ps)
    
  | `BTYP_type -> `BTYP_type 
  | x -> map_b0type f x

let iter_b0type f = function
  | `BTYP_inst (i,ts) -> iter f ts
  | `BTYP_tuple ts -> iter f ts
  | `BTYP_unitsum k -> 
    let unitrep = `BTYP_tuple [] in
    for i = 1 to k do f unitrep done

  | `BTYP_sum ts -> iter f ts
  | `BTYP_function (a,b) -> f a; f b
  | `BTYP_pointer t->  f t
  | `BTYP_lvalue t->  f t
  | `BTYP_array (t1,t2)->  f t1; f t2
  | x -> ()

let iter_btype f = function
  | `BTYP_apply (a,b) -> f a; f b
  | `BTYP_typefun (its, a, b) ->
     iter (fun (i,t) -> f t) its; f a; f b
  | `BTYP_type_match (t,ps) ->
    let g (a,b) = f a; f b in
    f t; 
    iter g ps
 
  | `BTYP_type_tuple ts -> iter f ts
  | x -> iter_b0type f x

(* type invariant mapping *)

let map_tbexpr fi fe ft e = match e with 
  | `BEXPR_parse (e,iis),t -> `BEXPR_parse (fe e,map fi iis), ft t
  | `BEXPR_deref e,t -> `BEXPR_deref (fe e),ft t
  | `BEXPR_ref (i,ts),t -> `BEXPR_ref (i, map ft ts), ft t

  | `BEXPR_apply (e1,e2),t -> `BEXPR_apply (fe e1, fe e2), ft t

  | `BEXPR_apply_prim (i,ts,e2),t -> `BEXPR_apply_prim (fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_direct (i,ts,e2),t -> `BEXPR_apply_direct (fi i, map ft ts, fe e2),ft t
  | `BEXPR_apply_stack (i,ts,e2),t -> `BEXPR_apply_stack (fi i, map ft ts, fe e2),ft t
  | `BEXPR_tuple  es,t -> `BEXPR_tuple (map fe es),ft t

  | `BEXPR_get_n (i,e),t -> `BEXPR_get_n (i, fe e),ft t

  | `BEXPR_closure (i,ts),t -> `BEXPR_closure (fi i, map ft ts),ft t
  | `BEXPR_name (i,ts),t -> `BEXPR_name (fi i, map ft ts), ft t
  | `BEXPR_case (i,t'),t -> `BEXPR_case (i, ft t'),ft t
  | `BEXPR_match_case (i,e),t -> `BEXPR_match_case (i, fe e),ft t
  | `BEXPR_case_arg (i,e),t -> `BEXPR_case_arg (i, fe e),ft t
  | `BEXPR_case_index e,t -> `BEXPR_case_index (fe e),ft t

  | `BEXPR_literal x,t -> `BEXPR_literal x, ft t
  | `BEXPR_expr (s,t1),t2 -> `BEXPR_expr (s, ft t1), ft t2


let iter_bexe fi fe ft fl fldef exe =
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  
  | `BEXE_call_stack (sr,i,ts,e2)  
  | `BEXE_call_direct (sr,i,ts,e2)  
  | `BEXE_jump_direct (sr,i,ts,e2)  
    -> fi i; iter ft ts; fe e2

  | `BEXE_assign (sr,e1,e2) 
  | `BEXE_call (sr,e1,e2)
  | `BEXE_jump (sr,e1,e2) 
    -> fe e1; fe e2

  | `BEXE_loop (sr,i,e) 
    -> fi i; fe e
    
  | `BEXE_ifgoto (sr,e,lab) 
  | `BEXE_ifnotgoto (sr,e,lab) 
    -> fe e; fl lab

  | `BEXE_label (sr,lab) 
    -> fldef lab
    
  | `BEXE_goto (sr,lab) 
    -> fl lab

  | `BEXE_fun_return (sr,e) 
    -> fe e

  | `BEXE_init (sr,i,e) 
    -> fi i; fe e
    
  | `BEXE_read (sr,i)  
    -> fi i
    
  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) 
    -> 
    fe e; 
    Hashtbl.iter
    (fun k v -> fe v)
    h
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) 
    ->
    fe p1; fe p2;
    Hashtbl.iter
    (fun k v -> fe v)
    h
    
  | `BEXE_halt _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_proc_return _
  | `BEXE_comment _
  | `BEXE_nop _
    -> ()


let map_bexe fi fe ft fl fldef (exe:bexe_t):bexe_t =
  match exe with 
  | `BEXE_call_prim (sr,i,ts,e2)  ->
    `BEXE_call_prim (sr,fi i,map ft ts, fe e2)

  | `BEXE_call_stack (sr,i,ts,e2) ->
    `BEXE_call_stack (sr,fi i, map ft ts, fe e2)  

  | `BEXE_call_direct (sr,i,ts,e2) ->
    `BEXE_call_direct (sr,fi i,map ft ts,fe e2)  

  | `BEXE_jump_direct (sr,i,ts,e2) ->
    `BEXE_jump_direct (sr,fi i,map ft ts,fe e2)  

  | `BEXE_assign (sr,e1,e2) ->
    `BEXE_assign (sr,fe e1,fe e2) 
   
  | `BEXE_call (sr,e1,e2) -> 
    `BEXE_call (sr,fe e1, fe e2)

  | `BEXE_jump (sr,e1,e2) ->
    `BEXE_jump (sr,fe e1, fe e2) 

  | `BEXE_loop (sr,i,e) ->
    `BEXE_loop (sr,fi i,fe e) 
    
  | `BEXE_ifgoto (sr,e,lab)  ->
    `BEXE_ifgoto (sr,fe e,fl lab)

  | `BEXE_ifnotgoto (sr,e,lab) ->
    `BEXE_ifnotgoto (sr,fe e,fl lab) 

  | `BEXE_label (sr,lab) ->
    `BEXE_label (sr,fldef lab) 
    
  | `BEXE_goto (sr,lab) ->
    `BEXE_goto (sr,fl lab)

  | `BEXE_fun_return (sr,e) ->
    `BEXE_fun_return (sr,fe e) 

  | `BEXE_init (sr,i,e) ->
    `BEXE_init (sr,fi i,fe e) 
    
  | `BEXE_read (sr,i) ->
    `BEXE_read (sr,fi i)  
    
  | `BEXE_regmatch (sr,e,(a,sc,h,tr)) 
    -> 
    let h' = Hashtbl.create 97 in
    Hashtbl.iter
    (fun k v -> Hashtbl.add h' k (fe v))
    h
    ;
    `BEXE_regmatch (sr,fe e,(a,sc,h',tr)) 
    
  | `BEXE_reglex (sr,p1,p2,(a,sc,h,tr)) 
    ->
    let h' = Hashtbl.create 97 in
    Hashtbl.iter
    (fun k v -> Hashtbl.add h' k (fe v))
    h
    ;
    `BEXE_reglex (sr,fe p1,fe p2,(a,sc,h',tr)) 
  
  | `BEXE_halt _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_proc_return _
  | `BEXE_comment _
  | `BEXE_nop _
    -> exe

let ident x = x
let reduce_tbexpr bbdfns e =
  let rec aux e =
    match map_tbexpr ident aux ident e with
    | `BEXPR_apply((`BEXPR_closure (i,ts),_),a),t ->
      `BEXPR_apply_direct (i,ts,a),t
    
    | `BEXPR_get_n (n,((`BEXPR_tuple ls),_)),_ ->
      List.nth ls n

    | `BEXPR_deref (`BEXPR_ref (i,ts),_),t -> 
      `BEXPR_name (i,ts),t

    | x -> x
  in aux e
    
let reduce_bexe bbdfns exe =
  match map_bexe ident (reduce_tbexpr bbdfns) ident ident ident exe with
  | `BEXE_call (sr,(`BEXPR_closure (i,ts),_),a) ->
    `BEXE_call_direct (sr,i,ts,a)
  | x -> x

let rec reduce_type t =
  match map_btype reduce_type t with
  | `BTYP_tuple ts -> typeoflist ts
  | t -> t

@head(1,'Routines to extract source reference from terms')
Source reference manipulators.
@h = tangler('src/flx_srcref.mli')
@select(h)
open Flx_ast
val rstoken: srcref -> srcref -> range_srcref
val rsrange: range_srcref -> range_srcref -> range_srcref
val slift: srcref -> range_srcref

val rsexpr: expr_t -> expr_t -> range_srcref
val rslist: expr_t list -> range_srcref

val src_of_expr: expr_t -> range_srcref
val src_of_stmt : statement_t -> range_srcref
val src_of_pat : pattern_t -> range_srcref
val src_of_qualified_name : qualified_name_t -> range_srcref
val src_of_suffixed_name: suffixed_name_t -> range_srcref

val short_string_of_src: range_srcref -> string
val long_string_of_src: range_srcref -> string

@h = tangler('src/flx_srcref.ml')
@doc()
Generic source reference manipulation.
Note the special hack of forgetting the second
filename when creating a range: the alternative
would be to record a complete list of lines.
@select(h)
(** axiom: rstoken a b = rsrange (lift a) (lift b) *)

(** get source range from source references of first
   and last tokens 
*)
let rstoken (f1,l1,s1,e1) (f2,l2,s2,e2) = (f1,l1,s1,l2,e2)

(** get range from first and last ranges *)
let rsrange (f1,sl1,sc1,el1,ec1) (f2,sl2,sc2,el2,ec2) =
  (f1,sl1,sc1,el2,ec2)

(** lift token source to range for token without attribute*)
let slift (f,l,s,e) = (f,l,s,l,e)

(** lift token source to range for tokens with attribute*)
let sliftfst x = slift (fst x)


@doc()
Type specific operations.
@select(h)
open Flx_util
open Flx_ast
open Flx_types
let src_of_qualified_name (e : qualified_name_t) = match e with
  | `AST_void s 
  | `AST_name  (s,_,_) 
  | `AST_case_tag (s,_)
  | `AST_typed_case (s,_,_)
  | `AST_lookup (s,_)
  | `AST_the (s,_) 
  | `AST_index (s,_,_)
    -> s

let src_of_suffixed_name (e : suffixed_name_t) = match e with
  | #qualified_name_t as x -> src_of_qualified_name x
  | `AST_suffix (s,_) 
    -> s

let src_of_expr (e : expr_t) = match e with
  | #suffixed_name_t as x -> src_of_suffixed_name x
  | `AST_ellipsis (s)
  | `AST_noexpand (s,_)
  | `AST_product (s,_)
  | `AST_sum (s,_)
  | `AST_arrow (s,_)
  | `AST_superscript (s,_)

  | `AST_map (s,_,_) 
  | `AST_apply  (s,_) 
  | `AST_deref (s,_) 
  | `AST_ref  (s,_) 
  | `AST_lvalue (s,_) 
  | `AST_literal  (s,_) 
  | `AST_method_apply  (s,_) 
  | `AST_tuple  (s,_) 
  | `AST_arrayof (s,_) 
  | `AST_dot  (s,_) 
  | `AST_lambda  (s,_) 
  | `AST_match_ctor  (s,_) 
  | `AST_match_case (s,_)
  | `AST_ctor_arg  (s,_) 
  | `AST_case_arg  (s,_) 
  | `AST_case_index (s,_) 
  | `AST_get_n  (s,_) 
  | `AST_coercion (s,_)
  | `AST_as (s,_)
  | `AST_match (s, _) 
  | `AST_parse (s, _,_) 
  | `AST_sparse (s,_,_,_) 
  | `AST_type_match (s, _) 
  | `AST_regmatch (s, _) 
  | `AST_reglex (s, _) 
  | `AST_cond (s,_)
  | `AST_expr (s,_,_)
  | `AST_letin (s,_)
  | `AST_typeof (s,_)
  
    -> s

let src_of_stmt e = match e with
  | `AST_public (s,_,_)
  | `AST_private (s,_)
  | `AST_label (s,_)
  | `AST_goto (s,_)
  | `AST_function (s,_, _, _ , _, _, _)
  | `AST_curry (s,_, _, _ , _, _,_)
  | `AST_object (s,_, _, _ , _)
  | `AST_name_macro (s, _,_)
  | `AST_expr_macro (s,_, _,_)
  | `AST_stmt_macro (s,_, _,_)
  | `AST_macro_val (s,_,_)
  | `AST_macro_var (s, _,_)
  | `AST_macro_assign (s,_,_)
  | `AST_macro_forget (s,_)
  | `AST_macro_label (s,_)
  | `AST_macro_goto (s,_)
  | `AST_macro_ifgoto (s,_,_)
  | `AST_macro_proc_return s

  | `AST_val_decl (s,_,_,_,_) 
  | `AST_var_decl (s,_,_,_,_) 
 

  | `AST_type_alias (s,_,_,_) 
  | `AST_inherit (s,_,_,_) 
  | `AST_inherit_fun (s,_,_,_) 
  | `AST_nop (s, _) 

  | `AST_assign (s, _, _,_ ) 
  | `AST_cassign (s, _,_ ) 
  | `AST_call (s, _, _ ) 
  | `AST_jump (s, _, _ ) 
  | `AST_loop (s, _, _ ) 
  | `AST_read (s, _) 
  | `AST_fun_return (s, _) 
  | `AST_proc_return s 
  | `AST_ifgoto (s,_,_)
  | `AST_ifreturn (s,_)
  | `AST_ifdo (s,_,_,_)
  | `AST_whilst (s,_,_)
  | `AST_until (s,_,_)
  | `AST_ifnotgoto (s,_,_)
  | `AST_abs_decl (s,_,_, _,_,_) 
  | `AST_ctypes (s,_,_,_) 
  | `AST_const_decl (s,_,_,_,_,_) 
  | `AST_fun_decl (s,_,_,_,_,_,_,_ ) 
  | `AST_header (s,_,_,_,_) 
  | `AST_body (s,_,_,_,_) 
  | `AST_code (s, _) 
  | `AST_noreturn_code (s, _) 
  | `AST_union (s, _,_, _ ) 
  | `AST_struct (s,_, _, _)
  | `AST_cstruct (s,_, _, _)
  | `AST_untyped_module (s,_,_,_)
  | `AST_export_fun (s, _,_)
  | `AST_export_type (s, _,_)
  | `AST_type (s,_,_)
  | `AST_open (s,_)
  | `AST_inject_module (s,_)
  | `AST_include (s,_)
  | `AST_use (s,_,_)
  | `AST_regdef (s,_,_)
  | `AST_glr (s,_,_,_)
    -> s
  | `AST_comment _ 
    -> ("Generated",0,0,0,0)

let src_of_pat e = match e with
  | `PAT_coercion (s,_,_)
  | `PAT_nan s
  | `PAT_none s
  | `PAT_int (s,_,_)
  | `PAT_string (s, _)
  | `PAT_int_range (s,_,_,_,_)
  | `PAT_string_range (s, _, _)
  | `PAT_float_range (s, _,_)
  | `PAT_name (s, _)
  | `PAT_tuple (s, _)
  | `PAT_any s
  | `PAT_regexp (s, _, _ )
  | `PAT_const_ctor (s, _)
  | `PAT_nonconst_ctor (s, _, _)
  | `PAT_as (s, _, _)
  | `PAT_when (s, _, _)
    -> s

(* get range from first and last expressions *)
let rsexpr a b = rsrange (src_of_expr a) (src_of_expr b)

(* get source range of non-empty list of expressions *)
let rslist lst = 
  rsexpr (List.hd lst) (list_last lst)


let short_string_of_src (f,l1,c1,l2,c2) =
  if l1 = l2 
  then
    f ^ ": line " ^ si l1 ^ 
    ", cols " ^ si c1 ^ " to " ^ si c2
  else
    f ^ ": line " ^ si l1 ^ 
    " col " ^ si c1 ^ " to " ^ 
    " line " ^ si l2 ^ " col " ^ si c2

let get_lines f context l1' l2' c1 c2 = (* first line is line 1 *)
  let l1 = max 1 (l1'-context) in
  let l2 = l2' + context in
  let n = String.length (si l2) in
  let fmt i = 
    let s ="    " ^ si i in
    let m = String.length s in
    String.sub s (m-n) n
  in
  try
    let buf = Buffer.create ((l2-l1+4) * 80) in
    let spc () = Buffer.add_char buf ' ' in
    let star() = Buffer.add_char buf '*' in
    let nl() = Buffer.add_char buf '\n' in
    let f = open_in f in
    for i = 1 to l1-1 do ignore(input_line f) done;
    begin
      try
        for i = l1 to l2 do 
          Buffer.add_string buf (fmt i ^": ");
          begin
            try
              Buffer.add_string buf (input_line f)
            with _ -> 
              Buffer.add_string buf "<eof>\n"; 
              raise Not_found
          end
          ;
          nl();
          if i = l1' && l1' = l2' then
          begin
            for i = 1 to n + 2 do spc() done;
            for i = 1 to c1 - 1 do spc() done;
            for i = c1 to c2 do star() done;
            nl()
          end
        done
      with Not_found -> ()
    end
    ;
    close_in f;
    Buffer.contents buf
  with _ -> 
    "*** Can't read file " ^ f ^ 
    " lines " ^ fmt l1 ^ " thru " ^ fmt l2 ^ "\n"

let long_string_of_src (f,l1,c1,l2,c2) =
  short_string_of_src (f,l1,c1,l2,c2) ^
  "\n" ^
  get_lines f 1 l1 l2 c1 c2

@head(1,'Print module')
Routines to print various terms.
@h = tangler('src/flx_print.mli')
@select(h)
open Flx_ast
open Flx_types
val string_of_typecode : typecode_t -> string
val string_of_btypecode : symbol_table_t -> btypecode_t -> string
val sbt: symbol_table_t -> btypecode_t -> string
val special_string_of_typecode : typecode_t -> string
val string_of_expr : expr_t -> string
val string_of_bound_expression : 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val string_of_bound_expression_with_type : 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val sbe: 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val tsbe: 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val string_of_pattern : pattern_t -> string
val string_of_literal : literal_t -> string
val string_of_parameters : parameter_t list -> string
val string_of_arguments : expr_t list -> string
val string_of_statement : int -> statement_t -> string
val string_of_compilation_unit : compilation_unit_t -> string
val string_of_desugared : asm_t list -> string
val string_of_suffixed_name : suffixed_name_t -> string
val string_of_qualified_name : qualified_name_t -> string
val string_of_dcl : int -> id_t -> int option -> id_t list -> dcl_t -> string
val string_of_bexe : symbol_table_t -> int -> bexe_t -> string
val string_of_exe : int -> exe_t -> string
val qualified_name_of_index : symbol_table_t -> int -> string
val string_of_bbdcl : 
  symbol_table_t -> 
  bbdcl_t -> 
  int -> 
  string

val string_of_symdef : 
  symbol_definition_t -> string -> vs_list_t ->
  string

val string_of_entry_kind:
  entry_kind_t -> string

val full_string_of_entry_kind:
  symbol_table_t -> entry_kind_t -> string

val string_of_entry_set:
  entry_set_t -> string

val full_string_of_entry_set:
  symbol_table_t -> entry_set_t -> string

val string_of_varlist:
  symbol_table_t ->
  (int * btypecode_t) list ->
  string

val string_of_bigint: bigint -> string

val print_env: env_t -> unit
val print_env_short: env_t -> unit

@h = tangler('src/flx_print.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_srcref
open Big_int
open Flx_typing
open List

let rec string_of_string s = Flx_string.c_quote_of_string s

let string_of_char c =
  if c = -1 then "<<EOF>>" else
  if c < 32 || c > 126
  then "\\x" ^ Flx_string.hex2 c
  else String.make 1 (Char.chr c)


let suffix_of_type s = match s with
  | "tiny" -> "t"
  | "short" -> "s"
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "v"
  | "utiny" -> "tu"
  | "ushort" -> "su"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "vu"
  | "int8" -> "i8"
  | "int16" -> "i16"
  | "int32" -> "i32"
  | "int64" -> "i64"
  | "uint8" -> "u8"
  | "uint16" -> "u16"
  | "uint32" -> "u32"
  | "uint64" -> "u64"
  | "float" -> "f"
  | "double" -> ""
  | "ldouble" -> "l"
  | _ -> failwith ("[suffix_of_type] Unexpected Type " ^ s)

let string_of_bigint x = string_of_big_int x
 
let string_of_literal e = match e with
  | `AST_int (s,i) -> (string_of_bigint i)^suffix_of_type s 
  | `AST_float (t,v) -> v ^ suffix_of_type t
  | `AST_string s -> string_of_string s
  | `AST_cstring s -> "c"^string_of_string s
  | `AST_wstring s -> "w"^string_of_string s
  | `AST_ustring s -> "u"^string_of_string s
  
let rec string_of_qualified_name (n:qualified_name_t) =
  let se e = string_of_expr e in
  match n with
  | `AST_the (sr,q) -> "the " ^ string_of_qualified_name q
  | `AST_index (sr,name,idx) -> name ^ "<" ^ si idx ^ ">" 
  | `AST_void _ -> "void"
  | `AST_name (_,name,ts) -> name ^ 
    (
      if List.length ts = 0 then "" 
      else "[" ^ catmap ", " string_of_typecode ts ^ "]"
    )
  | `AST_case_tag (_,v) -> "case " ^ si v
  | `AST_typed_case (_,v,t) -> 
    "(case " ^ si v ^ 
    " of " ^ string_of_typecode t ^ ")"

  | `AST_lookup (_,(e,name, ts)) -> "("^se e ^")::" ^ name ^
    (if length ts = 0 then "" else
    "[" ^ catmap ", " string_of_typecode ts ^ "]"
    )

and string_of_suffixed_name (n:suffixed_name_t) =
  match n with
  | #qualified_name_t as n -> string_of_qualified_name n
  | `AST_suffix (_,(name,suf)) ->
    string_of_qualified_name name ^ " of (" ^ string_of_typecode suf ^ ")"

and string_of_re re =
  match re with
  | REGEXP_seq (r1,r2) -> string_of_re r1 ^ " " ^ string_of_re r2
  | REGEXP_alt (r1,r2) -> string_of_re r1 ^ " | " ^ string_of_re r2
  | REGEXP_aster r -> "(" ^ string_of_re r ^ ")*"
  | REGEXP_name s -> string_of_qualified_name s
  | REGEXP_string s ->
    let ss=Buffer.create (String.length s) in
    Buffer.add_char ss '"';
    for i = 0 to String.length s - 1 do
      Buffer.add_string ss (string_of_char (Char.code s.[i]))
    done;
    Buffer.add_char ss '"';
    Buffer.contents ss


  | REGEXP_epsilon -> "epsilon"
  | REGEXP_sentinel -> "sentinel"
  | REGEXP_code e -> "<CODE " ^ string_of_expr e ^ ">"

and string_of_expr (e:expr_t) = 
  let se e = string_of_expr e 
  and sme e = string_of_expr e 
  and sqn e = string_of_qualified_name e
  in
  match e with
  | #suffixed_name_t as n -> string_of_suffixed_name n
  | `AST_ellipsis _ -> "..."
  | `AST_noexpand (sr,e) -> "$(" ^ string_of_expr e ^ ")"

  | `AST_letin (sr,(pat,e1, e2)) ->
    "let " ^ string_of_letpat pat ^ " = " ^ se e1 ^ " in " ^ se e2
  | `AST_coercion (_,(e,t)) -> 
    "(" ^ sme e ^ ":" ^ 
    string_of_typecode t ^ ")"

  | `AST_expr (_,s,t) -> 
    "code ["^string_of_typecode t^"]" ^
    "'" ^ s ^ "'"
    
  | `AST_cond (_,(e,b1,b2)) -> 
    "if " ^ se e ^ 
    " then " ^ se b1 ^ 
    " else " ^ se b2 ^ 
    " endif"

  | `AST_typeof (_,e) -> "typeof("^se e^")"
  | `AST_as (_,(e1, name)) -> "(" ^ se e1 ^ ") as " ^ name  
  | `AST_get_n (_,(n,e)) -> "get (" ^ si n ^ ", " ^se e^")"
  | `AST_map (_,f,e) -> "map (" ^ se f ^ ") (" ^ se e ^ ")"
  | `AST_deref (_,e) -> "*(" ^ se e ^ ")"
  | `AST_lvalue (_,e) -> "lvalue" ^ "(" ^ se e ^ ")"
  | `AST_ref (_,e) -> "&" ^ "(" ^ se e ^ ")"
  | `AST_literal (_,e) -> string_of_literal e
  | `AST_apply  (_,(fn, arg)) -> "(" ^ 
    sme fn ^ " " ^ 
    sme arg ^ 
    ")"

  | `AST_product (_,ts) ->
     cat "*" (map se ts)
  | `AST_sum (_,ts) ->
     cat "+" (map se ts)
  | `AST_arrow (_,(a,b)) ->
    "(" ^ se a ^ " -> " ^ se b ^ ")"

  | `AST_superscript (_,(a,b)) ->
    "(" ^ se a ^ " ^ " ^ se b ^ ")"
    
  | `AST_method_apply  (_,(fn, arg)) -> "(" ^ 
    fn ^ " " ^ 
    se arg ^ 
    ")"

  | `AST_tuple (_,t) -> "(" ^ catmap ", " sme t ^ ")"
  | `AST_arrayof (_,t) -> "[|" ^ catmap ", " sme t ^ "|]"
  | `AST_dot (_,(e,n)) ->  "get_" ^ n ^ "(" ^ se e ^ ")"

  | `AST_lambda (_,(paramss,ret, sts)) -> 
    "(fun " ^
    catmap " "  
    (fun ps -> "(" ^ string_of_parameters ps ^ ")") paramss
    ^ 
    (match ret with
    | `TYP_none -> ""
    | _ -> ": " ^string_of_typecode ret) ^ 
    " = " ^
    string_of_compound 0 sts ^ ")"

  | `AST_ctor_arg (_,(cn,e)) ->
    "ctor_arg " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_case_arg (_,(n,e)) ->
    "case_arg " ^ si n ^ "(" ^
    se e ^ ")"

  | `AST_case_index (_,e) ->
    "caseno (" ^ se e ^ ")"

  | `AST_match_ctor (_,(cn,e)) ->
    "match_ctor " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_match_case (_,(v,e)) ->
    "match_case " ^ si v ^ "(" ^
    se e ^ ")"

  | `AST_sparse (_,e, nt,iis) ->
    "parse " ^ se e ^ " with " ^ nt ^ " endmatch"
    
  | `AST_parse (_,e, ms) ->
    "parse " ^ se e ^ " with\n" ^
    catmap ""
    (fun (_,p,e')->
      " | " ^
      string_of_production p ^
      " => " ^
      string_of_expr e' ^
      "\n"
    )
    ms
    ^ "endmatch"

  | `AST_match (_,(e, ps)) ->
    "match " ^ se e ^ " with\n" ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_pattern p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_type_match (_,(e, ps)) ->
    "typematch " ^ string_of_typecode e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_tpattern p ^
      " => " ^
      string_of_typecode e'
    )
    ps
    ^
    " endmatch"

  | `AST_regmatch (_,(e, ps)) ->
    "regmatch " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_reglex (_,(p1, p2, ps)) ->
    "reglex " ^ se p1 ^ " to " ^ se p2 ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

(* precedences for type operators ..
   0 -- atomic
   0.5 -- indexing t[i]
   1 -- pointer
   2 -- application
   3 -- ^
   4 -- *
   5 -- +
   6 -- ->
   7 -- =>
   8    as, all
*)


and st prec tc : string = 
  let iprec,txt =
    match tc with
    | #qualified_name_t as t -> 0,string_of_qualified_name t
    | `TYP_none -> 0,"<none>"
    | `TYP_ellipsis-> 0,"..."
    | `TYP_type_match (e,ps) -> 0,
      "typematch " ^ string_of_typecode e ^ " with " ^
      catmap ""
      (fun (p,t) ->
      "| " ^ string_of_tpattern p ^ " => " ^ string_of_typecode t 
      )
      ps
      ^
      " endmatch"
      
    | `TYP_var i -> 0,"<var " ^ si i ^ ">"
    | `TYP_unitsum k ->
      0,
      begin match k with 
      | 0 -> "void"
      | 1 -> "unit"
      | 2 -> "bool"
      | _ -> si k
      end

    | `TYP_tuple ls ->
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 4, cat " * " (map (st 4) ls)
      end

    | `TYP_sum ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | [`TYP_tuple[];`TYP_tuple[]] -> 0,"bool" 
      | _ -> 5,cat " * " (map (st 5) ls)
      end

    | `TYP_function (args, result) ->  
      6,st 6 args ^ " -> " ^ st 6 result

    | `TYP_array (vt,it) -> 3, st 1 vt ^ "^" ^ st 3 it
    
    | `TYP_pointer t -> 1,"&" ^ st 1 t
    | `TYP_lvalue t -> 0,"lvalue[" ^ st 1 t ^"]"
    
    | `TYP_typeof e -> 0,"typeof(" ^ string_of_expr e ^ ")"
    | `TYP_as (t,s) -> 8,st 8 t ^ " as " ^ s

    | `TYP_proj (i,t) -> 2,"proj_"^si i^" "^ st 2 t
    | `TYP_dual t -> 2,"~"^ st 2 t
    | `TYP_dom t -> 2,"dom "^ st 2 t
    | `TYP_cod t -> 2,"cod "^st 2 t
    | `TYP_case_arg (i,t) -> 2,"case_arg_"^si i^" "^st 2 t

    | `TYP_apply (t1,t2) -> 2,st 2 t1 ^ " " ^ st 2 t2
    | `TYP_type -> 0,"TYPE"
    | `TYP_type_tuple ls ->
      4, cat ", " (map (st 4) ls)

    | `TYP_glr_attr_type qn -> 
       0,"glr_attr_type(" ^string_of_qualified_name qn^ ")"
       
    | `TYP_typefun (args,ret,body) -> 
       8,
       (
         "fun(" ^ cat ", " 
         (
           map 
           (fun (n,t)-> n ^ ": " ^ st 8 t) 
           args
         ) ^
         "): " ^ st 0 ret ^ "=" ^ st 8 body
       )
  in
    if iprec >= prec 
    then "(" ^ txt ^ ")" 
    else txt

and string_of_typecode tc = st 99 tc

and qualified_name_of_index_with_vs dfns index = 
  match Hashtbl.find dfns index with 
  | { id=id; vs=vs; parent=parent} ->
    match parent with
    | Some index' ->
      qualified_name_of_index_with_vs dfns index' ^ 
      id ^ 
      print_ivs vs ^ 
      "::"
    | None -> ""
      (* If this entity has no parent, its the root module,
        and we don't bother to print its name as a prefix
      *)

and qualified_name_of_index' dfns index = 
  match Hashtbl.find dfns index with 
  | { id=id; parent=parent } ->
    begin match parent with
    | Some index' -> qualified_name_of_index_with_vs dfns index' 
    | None -> ""
    end ^
    id

and qualified_name_of_index dfns index = 
  try qualified_name_of_index' dfns index
  with Not_found -> "index_"^ si index

(* fixppoint labeller .. very sloppy, ignores precedence .. *)
and get_label i =
  if i = 0 then "" 
  else 
    let ch = Char.chr (i mod 26 + Char.code('a')-1) in
    get_label (i/26) ^ String.make 1 ch
  
and print_fixpoints depth fixlist =
  match fixlist with
  | (d,lab) :: t when d = depth -> 
    let txt,lst = print_fixpoints depth t in
    " as " ^ lab ^ " " ^ txt, lst
  | _ -> "", fixlist
  
and sb dfns depth fixlist counter prec tc = 
  let sbt prec t = sb dfns (depth+1) fixlist counter prec t in
  let iprec, term = 
    match tc with
    | `BTYP_type_match (t,ps) ->
      0,
      (
        "typematch " ^
        sbt 99 t ^
        " with" ^
        catmap ""
        (fun (p,t) ->
          " | " ^ sbt 99 p ^ " => " ^ sbt 99 t 
        )
        ps 
        ^
        " endmatch"
      )

    | `BTYP_fix i ->
       0,
       (
         try assoc (depth+i) !fixlist
         with Not_found ->
           incr counter; (* 'a is 1 anyhow .. *)
           let lab = "fix" ^ si i ^ "_"^get_label !counter in
           fixlist := (depth+i,lab) :: !fixlist;
           lab 
       )

    | `BTYP_var i -> 0,"<T" ^ si i ^ ">"
    | `BTYP_inst (i,ts) -> 
      0,qualified_name_of_index dfns i ^ 
      (if List.length ts = 0 then "" else
      "[" ^cat ", " (map (sbt 9) ts) ^ "]"
      )

    | `BTYP_tuple ls -> 
      begin match ls with 
      | [] -> 0,"unit" 
      | [x] -> failwith ("UNEXPECTED TUPLE OF ONE ARGUMENT " ^ sbt 9 x)
      | _ -> 4,cat " * " (map (sbt 4) ls)
      end

    | `BTYP_unitsum k -> 
      begin match k with
      | 0 -> 0,"void"
      | 2 -> 0,"bool"
      | _ -> 0,si k
      end

    | `BTYP_sum ls -> 
      begin match ls with 
      | [] -> 9,"UNEXPECTED EMPTY SUM = void" 
      | [`BTYP_tuple[]; `BTYP_tuple[]] -> 0,"unexpected bool"
      | [x] -> (* failwith *) (9,"UNEXPECTED SUM OF ONE ARGUMENT " ^ sbt 9 x)
      | _ -> 
        if (all_units ls)
        then
          0,si (length ls)
        else
          5,cat " + " (map (sbt 5) ls)
      end

    | `BTYP_function (args, result) ->  
      6,(sbt 6 args) ^ " -> " ^ (sbt 6 result)

    | `BTYP_array (t1,t2) -> 
      begin match t2 with 
      | `BTYP_unitsum k -> 3, sbt 3 t1 ^"^"^si k
      | _ -> 3, sbt 3 t1 ^"^"^sbt 3 t2
      end

    | `BTYP_lvalue t -> 0,"lvalue[" ^ sbt 0 t ^"]"
    | `BTYP_pointer t -> 1,"&" ^ sbt 1 t
    | `BTYP_void -> 0,"void"
    
    | `BTYP_apply (t1,t2) -> 2,sbt 2 t1 ^ " " ^ sbt 2 t2
    | `BTYP_type -> 0,"TYPE"
    | `BTYP_type_tuple ls ->
      4, cat ", " (map (sbt 4) ls)

    | `BTYP_typefun (args,ret,body) -> 
       8,
       (
         "fun (" ^ cat ", " 
         (
           map 
           (fun (i,t)-> "T"^si i ^ ": " ^ sbt 8 t) 
           args
         ) ^
         "): " ^ sbt 0 ret ^ "=" ^ sbt 8 body
       )
  in
    let txt,lst = print_fixpoints depth !fixlist in
    fixlist := lst;
    if txt = "" then
      if iprec >= prec then "(" ^ term ^ ")"
      else term
    else
    "(" ^ term ^ txt ^ ")"

and string_of_btypecode (dfns:symbol_table_t) tc = 
  let fixlist = ref [] in
  let term = sb dfns 0 fixlist (ref 0) 99 tc in
  let bad = ref "" in
  while List.length !fixlist > 0 do
    match !fixlist with
    | (d,v)::t ->
      bad := !bad ^ " [Free Fixpoint " ^ si d ^ " " ^ v ^"]";
      fixlist := t
    | [] -> assert false
  done;
  term ^ !bad

and sbt a b = string_of_btypecode a b

and string_of_parameters ps = 
  cat 
    ", " 
    (map (fun (x,y)-> x ^ ": "^(string_of_typecode y)) ps)

and string_of_iparameters ps = 
  cat 
    ", " 
    (map (fun (x,(i,y))-> x ^ "["^si i^"]: "^(string_of_typecode y)) ps)

and string_of_bparameters dfns ps = 
  cat 
    ", " 
    (map (fun (x,(i,y))-> x ^ "["^si i^"]: "^(string_of_btypecode dfns y)) ps)

and string_of_arguments ass = 
  catmap ", " string_of_expr ass

 
and string_of_component level (name, typ) = 
   spaces level ^ name ^ ": " ^ (string_of_typecode typ)

and string_of_float_pat = function
  | Float_plus (t,v) -> v ^ t
  | Float_minus (t,v) -> "-" ^ v ^ t
  | Float_inf -> "inf"
  | Float_minus_inf -> "-inf"

and string_of_tpattern p =
  let sp p = string_of_tpattern p in
  match p with
  | `TPAT_function (p1,p2) -> sp p1 ^ " -> " ^ sp p2
  | `TPAT_sum ps -> catmap " + " sp ps
  | `TPAT_tuple ps -> catmap " * " sp ps
  | `TPAT_pointer p -> "&" ^ sp p
  | `TPAT_void -> "0"
  | `TPAT_var s -> "?" ^ s
  | `TPAT_name (s,ps) -> 
    s ^ 
    (
      match ps with
      | [] -> ""
      | ps -> "[" ^ catmap "," sp ps ^ "]"
    )
  
  |  `TPAT_as (p,s) -> sp p ^ " as " ^ s
  |  `TPAT_any -> "_"


and string_of_pattern p = 
  let se e = string_of_expr e in
  match p with
  | `PAT_coercion (_,p,t) -> "(" ^ string_of_pattern p ^ ":" ^ string_of_typecode t ^ ")"
  | `PAT_none _ -> "<none>"
  | `PAT_nan _ -> "NaN"
  | `PAT_int (_,t,i) -> string_of_bigint i ^ suffix_of_type t
  | `PAT_int_range (_,t1,i1,t2,i2) -> 
    string_of_bigint i1 ^ suffix_of_type t1 ^
    " .. " ^ 
    string_of_bigint i2 ^ suffix_of_type t2
    
  | `PAT_string (_,s) -> string_of_string s
  | `PAT_string_range (_,s1, s2) -> 
    string_of_string s1 ^ " .. " ^ string_of_string s2
  | `PAT_float_range (_,x1, x2) -> 
    string_of_float_pat x1 ^ " .. " ^ string_of_float_pat x2
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_pattern ps ^ ")"
  | `PAT_any _ -> "any"
  | `PAT_regexp (_,r,b) -> 
    "regexp " ^ string_of_string r ^
    "(" ^ cat ", " b ^ ")"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_pattern p
  | `PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | `PAT_when (_,p,e) -> "(" ^ string_of_pattern p ^ " when " ^ se e ^ ")"

and string_of_letpat p = 
  match p with
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_letpat ps ^ ")"
  | `PAT_any _ -> "_"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_letpat p
  | `PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | _ -> failwith "unexpected pattern kind in let/in pattern" 
 
and string_of_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_statement (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_compound level ss

and string_of_asm_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_asm (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_asm_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_asm_compound level ss

and special_string_of_typecode ty =  (* used for constructors *)
  match ty with
  | `TYP_tuple [] -> ""
  | _ -> " of " ^ string_of_typecode ty

and special_string_of_btypecode dfns ty =  (* used for constructors *)
  match ty with
  | `BTYP_tuple [] -> ""
  | _ -> " of " ^ string_of_btypecode dfns ty

and string_of_macro_parameter_type = function
  | Expr -> "fun"
  | Ident -> "ident"
  | Stmt -> "proc"
 
and print_vs = function
  | [] -> ""
  | vs -> "[" ^ cat ", " vs ^ "]"

and print_ivs = function
  | [] -> ""
  | vs -> "[" ^ cat ", " (map fst vs) ^ "]"

and print_bvs = function
  | [] -> ""
  | vs -> 
    "[" ^ 
    cat ", " 
    (
      map 
      (fun (s,i)-> s^"<"^si i^">" ) 
      vs
    ) ^
    "]"

and print_inst dfns = function
  | [] -> ""
  | ts -> 
    "[" ^ 
    cat ", " 
    (
      map (string_of_btypecode dfns) ts 
    ) ^
    "]"

and sl x = string_of_lvalue x 
and string_of_lvalue (x,t) = 
  begin match x with
  | `Val (sr,x) -> "val " ^ x
  | `Var (sr,x) -> "var " ^ x
  | `Name (sr,x) -> x
  | `Skip (sr) -> "_"
  | `List ls -> "(" ^ catmap ", " sl ls ^ ")"
  | `Expr (sr,e) -> string_of_expr e
  end ^
  begin match t with
  | Some t -> ":" ^ string_of_typecode t
  | None -> ""
  end

and string_of_property = function
| `Recursive -> "recursive"
| `Inline -> "inline"
| `NoInline -> "noinline"
| `Inlining_complete -> "inlining_complete"

and string_of_properties ps =
  match ps with 
  | [] -> ""
  | ps -> catmap " " string_of_property ps
  
and string_of_reqs = function 
  | [] -> ""
  | x -> 
    " requires " ^ catmap ", " 
    (function 
      | `Named_req s -> string_of_qualified_name s
      | `Body_req s -> "body \"" ^ s ^ "\""
      | `Header_req s -> "header \"" ^ s ^ "\""
    )
    x

and string_of_named_reqs = function | [] -> ""
 | x -> " requires " ^ catmap ", " string_of_qualified_name x

and string_of_qual = function 
| `Incomplete -> "incomplete"
| `Pod -> "pod"

and string_of_quals qs = catmap " " string_of_qual qs

and string_of_statement level s = 
  let se e = string_of_expr e in
  let sqn n = string_of_qualified_name n in
  match s with 
  | `AST_public (_,s,st) ->
    "\n" ^
    spaces level ^ "public '" ^ s ^ "'\n" ^
    string_of_statement (level+1) st

  | `AST_private (_,st) ->
    spaces level ^ "private " ^
    string_of_statement 0 st

  | `AST_export_fun (_,flx_name,cpp_name) -> 
    spaces level ^ 
    "export fun " ^ 
    string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `AST_export_type (_,flx_type,cpp_name) -> 
    spaces level ^ 
    "export type (" ^ 
    string_of_typecode flx_type ^ 
    ") as \"" ^ cpp_name ^ "\";"

  | `AST_label (_,s) -> s ^ ":"
  | `AST_goto (_,s) -> spaces level ^ "goto " ^ s ^ ";"

  | `AST_comment s -> spaces level ^ "// " ^ s

  | `AST_open (_,n) -> 
    spaces level ^ "open " ^ sqn n ^ ";"

  | `AST_inject_module (_,n) -> 
    spaces level ^ "include " ^ sqn n ^ ";"

  | `AST_include (_,s) -> 
    spaces level ^ "include " ^ s ^ ";"
  
  | `AST_use (_,n,qn) -> 
    spaces level ^ "use " ^ n ^ " = " ^ sqn qn ^ ";"

  | `AST_regdef (_,n,r) -> 
    spaces level ^ "regdef " ^ n ^ " = " ^string_of_re r^";"

  | `AST_glr (_,n,t,ps) -> 
    spaces level ^ "nonterm " ^ n ^ " : " ^string_of_typecode t ^
    catmap ""
    (fun (_,p,e')->
      spaces (level + 1) ^ " | " ^
      string_of_production p ^
      " => " ^
      string_of_expr e' ^
      "\n"
    )
    ps
    ^
    spaces level ^ ";"
  

  | `AST_type_alias (_,t1,vs,t2) ->
    spaces level ^ "type " ^ t1 ^ print_vs vs ^
    " = " ^ 
    string_of_typecode t2 ^ ";"

  | `AST_inherit (_,name,vs,qn) ->
    spaces level ^ "inherit " ^ name ^ print_vs vs ^
    " = " ^ 
    string_of_qualified_name qn ^ ";"

  | `AST_inherit_fun (_,name,vs,qn) ->
    spaces level ^ "inherit fun " ^ name ^ print_vs vs ^
    " = " ^ 
    string_of_qualified_name qn ^ ";"

  | `AST_untyped_module (_,name, vs,sts)  -> 
    spaces level ^ "module " ^ name ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts

  | `AST_struct (_,name, vs, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_cstruct (_,name, vs, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "cstruct " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_union (_,name, vs,cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^ name ^ special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_ctypes (_,names, quals, reqs) -> spaces level ^ 
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "ctypes " ^ catmap "," snd names ^ 
    string_of_reqs reqs ^
    ";"

  | `AST_abs_decl (_,t,vs, quals, ct, reqs) -> spaces level ^ 
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ t ^ print_vs vs ^
    " = " ^ string_of_string ct ^ 
    string_of_reqs reqs ^
    ";"

  | `AST_fun_decl (_,name,vs,args, result, code, reqs,prec) ->
    spaces level ^ 
    "fun " ^ name ^ print_vs vs ^
    ": " ^ 
    (string_of_typecode (`TYP_tuple args)) ^ " -> " ^
    (string_of_typecode result) ^ 
    " = " ^ string_of_string code ^ 
    (if prec = "" then "" else ":"^prec^" ")^
    string_of_reqs reqs ^
    ";"

  | `AST_const_decl (_,name,vs,typ, code, reqs) ->
    spaces level ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ 
     string_of_reqs reqs ^
     ";" 

  | `AST_header (_,n,vs,s, reqs) -> let triple_quote = "\"\"\"" in
    spaces level ^
    "header "^n^print_vs vs^ 
    "\n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
     string_of_reqs reqs ^
    ";\n"

  | `AST_body (_,n,vs,s, reqs) -> let triple_quote = "\"\"\"" in
    spaces level ^
    "body "^n^print_vs vs^ 
    "\n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
     string_of_reqs reqs ^
    ";\n"

  | `AST_code (_,s) -> let triple_quote = "\"\"\"" in
    "code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
    ";\n"

  | `AST_noreturn_code (_,s) -> let triple_quote = "\"\"\"" in
    "noreturn_code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
    ";\n"

  | `AST_function (_,name, vs, ps, res, props, ss) -> 
    spaces level ^ 
    string_of_properties props ^
    "fun " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^"): "^string_of_typecode res^"\n" ^
    string_of_compound level ss

  | `AST_curry (_,name, vs, pss, res, kind, ss) -> 
    spaces level ^ 
    (match kind with 
    | `Function -> "fun " 
    | `Object -> "obj " 
    | `InlineFunction -> "inline fun "
    | `NoInlineFunction -> "noinline fun "
    )
    ^ 
    name ^ print_vs vs ^ 
    catmap " " 
    (fun ps ->
      "("^string_of_parameters ps^")"
    )
    pss
    ^ 
    ": "^string_of_typecode res^"\n" ^
    string_of_compound level ss

  | `AST_object (_,name, vs, ps, ss) -> 
    spaces level ^ 
    "object " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^")\n" ^
    string_of_compound level ss

  | `AST_macro_val (_,name, e) ->
    spaces level ^ 
    "macro val " ^ name ^ " = " ^
    se e ^
    ";"

  | `AST_macro_var (_,name, e) ->
    spaces level ^ 
    "macro var " ^ name ^ " = " ^
    se e ^
    ";"

  | `AST_macro_assign (_,name, e) ->
    spaces level ^ 
    "macro " ^ name ^ " = " ^
    se e ^
    ";\n"

  | `AST_name_macro (_,lname, rname) ->
    spaces level ^ 
    "macro ident " ^ lname ^ " = " ^
    (match rname with | "" -> "new" | _ -> rname) ^
    ";"
    

  | `AST_expr_macro (_,name, ps, e) -> 
    let sps = 
      map 
      (fun (p,t) -> p ^ ":" ^ string_of_macro_parameter_type t) 
      ps 
    in
    spaces level ^ 
    "macro fun " ^ name ^ 
    "("^ cat ", " sps ^") = " ^
    se e ^
    ";"

  | `AST_stmt_macro (_,name, ps, ss) -> 
    let sps = 
      map 
      (fun (p,t) -> p ^ ":" ^ string_of_macro_parameter_type t) 
      ps 
    in
    spaces level ^ 
    "macro proc " ^ name ^ 
    "("^ cat ", " sps ^") " ^
    short_string_of_compound level ss

  | `AST_macro_forget (_,names) ->
    spaces level ^ 
    "macro forget" ^
    (
      match names with
      | [] -> ""
      | _ -> " "
    ) ^
    cat ", " names ^ 
    ";"

  | `AST_macro_label (_,id) ->
    "macro " ^ id ^ ":>\n"

  | `AST_macro_goto (_,id) ->
    "macro goto " ^ id ^ ";\n"

  | `AST_macro_ifgoto (_,e,id) ->
    "macro if "^se e^" goto " ^ id ^ ";\n"

  | `AST_macro_proc_return (_) ->
    "macro return;\n"

  | `AST_val_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "val " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_var_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "var " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_call (_,pr, args) ->
    spaces level
    ^ "call " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_assign (_,name,l,r) ->
    spaces level
    ^ "call " ^ name ^ "(" ^ sl l ^ "," ^se r^");"

  | `AST_cassign (_,l,r) ->
    spaces level ^
    se l ^ " = " ^ se r ^ ";"

  | `AST_jump (_,pr, args) ->
    spaces level
    ^ "jump " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_loop (_,pr, args) ->
    spaces level
    ^ "call " ^ pr ^ " " ^ se args ^ ";"

  | `AST_nop (_,s) -> spaces level ^ "{/*"^s^"*/;}"

  | `AST_ifgoto (_,e,lab) ->
    spaces level ^
    "if("^string_of_expr e^")goto " ^ lab ^ ";"

  | `AST_whilst (_,e,sts) ->
    spaces level ^
    "whilst "^string_of_expr e^" do\n" ^ 
    catmap "\n" (string_of_statement (level+1)) sts ^
    spaces level ^ "done;"

  | `AST_until (_,e,sts) ->
    spaces level ^
    "until "^string_of_expr e^" do\n" ^ 
    catmap "\n" (string_of_statement (level+1)) sts ^
    spaces level ^ "done;"
 
  | `AST_ifreturn (_,e) ->
    spaces level ^
    "if("^string_of_expr e^")return;" 

  | `AST_ifdo (_,e,ss1,ss2) ->
    spaces level ^
    "if("^string_of_expr e^")do\n" ^
    catmap "\n" (string_of_statement (level+1)) ss1 ^
    spaces level ^ "else\n" ^
    catmap "\n" (string_of_statement (level+1)) ss2 ^
    spaces level ^ "done;"
    
  | `AST_ifnotgoto (_,e,lab) ->
    spaces level ^
    "if not("^string_of_expr e^")goto " ^ lab

  | `AST_fun_return (_,e) -> 
    spaces level ^ "return " ^ (se e) ^ ";"

  | `AST_proc_return _ -> 
    spaces level ^ "return;"
    
  | `AST_read (_,name) ->
    spaces level ^ "read " ^ name ^ ";"

and string_of_compilation_unit stats =
  catmap "\n" (string_of_statement 0) stats

and string_of_desugared stats =
  catmap "\n" (string_of_asm 0) stats
  
and string_of_iface level s =
  let spc = spaces level in
  match s with
  | `IFACE_export_fun (flx_name,cpp_name) -> 
    spc ^ "export fun " ^ string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `IFACE_export_type (flx_type,cpp_name) -> 
    spc ^ "export type (" ^ string_of_typecode flx_type ^ 
    ") as \"" ^ cpp_name ^ "\";"

and string_of_symdef (entry:symbol_definition_t) name (vs:vs_list_t) 
= match entry with
  | `SYMDEF_regdef re ->
    "regexp " ^ name ^ " = " ^ string_of_re re ^ ";\n"

  | `SYMDEF_glr(t,(p,sexes)) ->
    "nonterm " ^ name ^ " : " ^string_of_typecode t ^ " = | " ^
    string_of_reduced_production p ^
    " => " ^ " <exes> " ^
    ";"

  | `SYMDEF_const_ctor (uidx,ut,idx) -> 
     string_of_typecode ut ^ "  " ^
     name ^ print_ivs vs ^ 
     ";"

  | `SYMDEF_nonconst_ctor (uidx,ut,idx,argt) -> 
     string_of_typecode ut ^ "  " ^
     name ^ print_ivs vs ^ 
     " of " ^ string_of_typecode argt ^
     ";"

  | `SYMDEF_type_alias t -> 
    "typedef " ^ name ^ print_ivs vs ^" = " ^ string_of_typecode t ^ ";"

  | `SYMDEF_inherit qn -> 
    "inherit " ^ name ^ print_ivs vs ^" = " ^ string_of_qualified_name qn ^ ";"

  | `SYMDEF_inherit_fun qn -> 
    "inherit fun " ^ name ^ print_ivs vs ^" = " ^ string_of_qualified_name qn ^ ";"

  | `SYMDEF_abs (quals,code, reqs) ->
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ name ^ print_ivs vs ^
    " = " ^ string_of_string code ^ 
    string_of_named_reqs reqs ^
    ";"

  | `SYMDEF_var (t) -> 
    "var " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_val (t) -> 
    "val " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_parameter (t) -> 
    "parameter " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_typevar (t) -> 
    "typevar " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_const (t,ct, reqs) -> 
    "const " ^ name ^ print_ivs vs ^":"^ 
    string_of_typecode t ^ " = '" ^ct^"'"^
    string_of_named_reqs reqs ^
    ";"
    
  | `SYMDEF_union (cts) -> 
    "union " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_struct (cts) -> 
    "struct " ^ name ^ print_ivs vs ^ ";"
  | `SYMDEF_cstruct (cts) -> 
    "cstruct " ^ name ^ print_ivs vs ^ ";"
    
  | `SYMDEF_fun (pts,res,cts, reqs,prec) -> 
    "fun " ^ name ^ print_ivs vs ^
    ": " ^ string_of_typecode 
    (
      `TYP_function 
      (
        (
          match pts with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    (if prec = "" then "" else ":"^prec^" ")^
    string_of_named_reqs reqs ^
    ";"

  | `SYMDEF_header (s,reqs) -> 
    "header " ^ name ^ print_ivs vs ^
    " "^ string_of_string s ^ 
     string_of_named_reqs reqs ^
    ";\n"
    
  | `SYMDEF_body (s,reqs) -> 
    "body " ^ name ^ print_ivs vs ^
    " "^ string_of_string s ^ 
     string_of_named_reqs reqs ^
    ";\n"

 
  | `SYMDEF_function (ps,res,props, es) -> 
    string_of_properties props ^
    "fun " ^ name ^ print_ivs vs ^
    ": " ^ string_of_typecode 
    (
      `TYP_function 
      (
        (
          match map snd ps with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    ";"
    
  | `SYMDEF_match_check (pat,(mvname,i))-> 
    "match_check " ^ name ^ " for " ^ string_of_pattern pat ^ ";"
  
  | `SYMDEF_module -> 
    "module " ^ name ^ ";"
    
and string_of_exe level s = 
  let spc = spaces level
  and se e = string_of_expr e 
  in
  match s with
  | `EXE_regmatch (e,cls) ->
    spc ^
    "regmatch " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    cls 
    ^
    " endmatch;"

  | `EXE_reglex (p1,p2,cls) ->
    spc ^
    "reglex " ^ se p1 ^ " to " ^ se p2 ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    cls 
    ^
    " endmatch;"


  | `EXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | `EXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `EXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `EXE_label s -> s ^ ":"

  | `EXE_comment s -> spc ^ 
    "// " ^ s 

  | `EXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_jump (p,a) -> spc ^ 
    "jump " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_loop (p,a) -> spc ^ 
    "loop " ^ 
    p ^ " " ^ 
    se a ^ ";"

  | `EXE_read v -> spc ^ 
    "read " ^ v

  | `EXE_fun_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | `EXE_proc_return -> spc ^ 
    "return;"

  | `EXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | `EXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | `EXE_noreturn_code s -> spc ^ 
    "noreturn_code " ^ string_of_string s 

  | `EXE_init (l,r) -> spc ^ 
    l ^ " := " ^ se r ^ ";"

  | `EXE_iinit ((l,i),r) -> spc ^ 
    l ^ "<"^si i^"> := " ^ se r ^ ";"

  | `EXE_assign (l,r) -> spc ^ 
    se l ^ " = " ^ se r ^ ";"

and sbe dfns e = string_of_bound_expression dfns e 
and tsbe dfns e = string_of_bound_expression_with_type dfns e 

and string_of_bound_expression_with_type dfns ((e',t) as e) = 
  string_of_bound_expression dfns e ^ ":" ^
  sbt dfns t

and string_of_bound_expression dfns e = 
  let se e = sbe dfns e in
  let sid n = qualified_name_of_index dfns n in
  match fst e with
   
  | `BEXPR_parse (e,ii) -> "parse " ^ se e ^ " with <nt> endmatch"

  | `BEXPR_get_n (n,e') -> "(" ^ se e' ^ ").mem_" ^ si n

  | `BEXPR_deref e -> "*("^ se e ^ ")"
  | `BEXPR_name (i,ts) -> sid i ^ print_inst dfns ts
  | `BEXPR_closure (i,ts) -> sid i ^ print_inst dfns ts
  | `BEXPR_ref (i,ts) -> "&" ^ sid i ^ print_inst dfns ts

  | `BEXPR_literal e -> string_of_literal e
  | `BEXPR_apply  (fn, arg) -> "(" ^ 
    se fn ^ " " ^ 
    se arg ^ 
    ")"

  | `BEXPR_apply_prim (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_apply_direct  (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_apply_stack (i,ts, arg) -> "(" ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se arg ^ 
    ")"

  | `BEXPR_tuple t -> "(" ^ catmap ", " se t ^ ")"

  | `BEXPR_case (v,t) -> 
    "case " ^ si v ^ " of " ^ string_of_btypecode dfns t

  | `BEXPR_match_case (v,e) -> 
    "(match case " ^ si v ^ ")(" ^ se e ^ ")"

  | `BEXPR_case_arg (v,e) ->
    "(arg of case " ^ si v ^ " of " ^ se e ^ ")"

  | `BEXPR_case_index e ->
    "caseno (" ^ se e ^ ")"

  | `BEXPR_expr (s,t) ->
    "code ["^string_of_btypecode dfns t^"]" ^ "'" ^ s ^ "'"

and string_of_biface dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BIFACE_export_fun (_,index,cpp_name) ->
    spc ^ "export fun " ^ qualified_name_of_index dfns index ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `BIFACE_export_type (_,btyp,cpp_name) ->
    spc ^ "export type (" ^ string_of_btypecode dfns btyp ^ 
    ") as \"" ^ cpp_name ^ "\";"

and string_of_bexe dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BEXE_regmatch (_,e,(alphabet, nstates, termcodes,matrix)) -> 
    spc ^ "regmatch " ^ se e ^ " with " ^
    "<TRANSITION MATRIX of "^si nstates^" states> " ^
    "endmatch;"

  | `BEXE_reglex (_,p1,p2,(alphabet, nstates, termcodes,matrix)) -> 
    spc ^ "reglex " ^ se p1 ^ " to " ^ se p2 ^ " with " ^
    "<TRANSITION MATRIX of "^si nstates^" states> " ^
    "endmatch;"

  | `BEXE_goto (_,s) -> spc ^ "goto " ^ s ^ ";"

  | `BEXE_halt (_,s) -> spc ^ "halt " ^ s ^ ";"

  | `BEXE_ifgoto (_,e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `BEXE_ifnotgoto (_,e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `BEXE_label (_,s) -> s ^ ":"

  | `BEXE_comment (_,s) -> spc ^ 
    "// " ^ s 

  | `BEXE_call (_,p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_call_direct (_,i,ts,a) -> spc ^ 
    "directcall " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_jump_direct (_,i,ts,a) -> spc ^ 
    "direct tail call " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_call_stack (_,i,ts,a) -> spc ^ 
    "stackcall " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_call_prim (_,i,ts,a) -> spc ^ 
    "primcall " ^ 
    sid i ^ print_inst dfns ts ^ " " ^
    se a ^ ";"

  | `BEXE_jump (_,p,a) -> spc ^ 
    "tail call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_loop (_,p,a) -> spc ^ 
    "loop<" ^ 
    si p ^ "> " ^ 
    se a ^ ";"

  | `BEXE_read (_,v) -> spc ^ 
    "read " ^ sid v 

  | `BEXE_fun_return (_,x) -> spc ^ 
    "return " ^ se x ^ ";"

  | `BEXE_proc_return _ -> spc ^ 
    "return;"

  | `BEXE_nop (_,s) -> spc ^ 
    "/*" ^ s ^ "*/"

  | `BEXE_code (_,s) -> spc ^ 
    "code " ^ string_of_string s 

  | `BEXE_nonreturn_code (_,s) -> spc ^ 
    "non_return_code " ^ string_of_string s 

  | `BEXE_assign (_,l,r) -> spc ^ 
    se l ^ " = " ^ se r ^ ";"

  | `BEXE_init (_,l,r) -> spc ^ 
    sid l ^ " := " ^ se r ^ ";"

and string_of_dcl level name seq vs (s:dcl_t) = 
  let se e = string_of_expr e in
  let seq = match seq with Some i -> "<" ^ si i ^ ">" | None -> "" in
  match s with
  | `DCL_regdef re -> 
    spaces level ^ "regexp " ^ name^seq ^ " = " ^ string_of_re re ^ ";\n"


  | `DCL_type_alias (t2) ->
    spaces level ^ "typedef " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_typecode t2 ^ ";"

  | `DCL_inherit qn ->
    spaces level ^ "inherit " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_qualified_name qn ^ ";"

  | `DCL_inherit_fun qn ->
    spaces level ^ "inherit fun " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_qualified_name qn ^ ";"

  | `DCL_module (asms) -> 
    spaces level ^ "module " ^ name^seq ^ print_vs vs ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms 

  | `DCL_struct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name^seq ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_cstruct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "cstruct " ^ name^seq ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_union (cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^name^ special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name^seq ^ print_vs vs ^
    " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_abs (quals, code, reqs) -> spaces level ^ 
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ name^seq ^ print_vs vs ^
    " = " ^ string_of_string code ^ 
    string_of_named_reqs reqs ^
    ";"

  | `DCL_fun (args, result, code, reqs,prec) ->
    let argtype:typecode_t = type_of_argtypes args in
    let t:typecode_t = `TYP_function (argtype,result) in
    spaces level ^ 
    "fun " ^ name^seq ^ print_vs vs ^
    ": " ^ string_of_typecode t ^
    " = " ^ string_of_string code ^ 
    (if prec = "" then "" else ":"^prec^" ")^
    string_of_named_reqs reqs ^
    ";"

  | `DCL_header (s,reqs) -> 
    spaces level ^ "header " ^ name^seq ^  print_vs vs ^
    " = "^ string_of_string s ^
    string_of_named_reqs reqs ^ ";"
    
  | `DCL_body (s,reqs) -> 
    spaces level ^ "body " ^ name^seq ^ print_vs vs ^
    " = "^ string_of_string s ^
     string_of_named_reqs reqs ^ ";"

  | `DCL_const (typ, code, reqs) ->
    spaces level ^ 
     "const " ^ name^seq ^print_vs vs ^  
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ 
    string_of_named_reqs reqs ^
     ";" 

  | `DCL_function (ps, res, props, ss) -> 
    spaces level ^ 
    string_of_properties props ^
    "fun " ^ name^seq ^ print_vs vs ^
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_asm_compound level ss


  | `DCL_match_check (pat,(s,i)) ->
    spaces level ^ 
    "function " ^ name^seq ^ "() { " ^ 
    s ^ "<"^si i^"> matches " ^ string_of_pattern pat ^
    " }"

  | `DCL_match_handler (pat,(varname, i), sts) ->
    spaces level ^ 
    "match_handler " ^ name^seq ^ 
    "(" ^ string_of_pattern pat ^ ")" ^
    string_of_asm_compound level sts

  | `DCL_glr (t,(p,e')) ->
    spaces level ^ "nonterm " ^ name^seq ^ " : " ^string_of_typecode t ^
    spaces (level + 1) ^ " | " ^
    string_of_reduced_production p ^
    " => " ^
    string_of_expr e' ^
    ";"
  
  | `DCL_val (ty) ->
    spaces level ^ 
    "val " ^ name^seq ^ print_vs vs ^ ": " ^ string_of_typecode ty ^ ";"

  | `DCL_var (ty) ->
    spaces level ^ 
    "var " ^ name^seq ^ print_vs vs ^ ": " ^ string_of_typecode ty ^ ";"

and string_of_asm level s =
  match s with
  | Dcl (sr,name,seq,access,vs, d) -> 
    (match access with
    | `Private -> "private "
    | `Public -> ""
    ) ^
    string_of_dcl level name seq vs d
  | Exe (sr,s) -> string_of_exe level s
  | Iface (sr,s) -> string_of_iface level s
  | Dir (sr,s) -> string_of_dir level s

and string_of_dir level s =
  let sqn n = string_of_qualified_name n in
  match s with
  | DIR_open qn ->
    spaces level ^ "open " ^ sqn qn ^ ";"

  | DIR_use (n,qn) ->
    spaces level ^ "use " ^ n ^ " = " ^ sqn qn ^ ";"

  | DIR_inject_module qn ->
    spaces level ^ "include " ^ sqn qn ^ ";"

and string_of_breq dfns (i,ts) = "rq<"^si i^">" ^ print_inst dfns ts
and string_of_breqs dfns reqs = catmap ", " (string_of_breq dfns) reqs
and string_of_production p = catmap " " string_of_glr_entry p
and string_of_reduced_production p = catmap " " string_of_reduced_glr_entry p
and string_of_bproduction dfns p = catmap " " (string_of_bglr_entry dfns) p

and string_of_glr_term t = match t with
  | `GLR_name qn -> string_of_qualified_name qn
  | `GLR_opt t  -> "[" ^ string_of_glr_term t ^ "]"
  | `GLR_ast t -> "{" ^ string_of_glr_term t ^ "}"
  | `GLR_plus t -> "(" ^ string_of_glr_term t ^ ")+"
  | `GLR_alt ts -> catmap " | " string_of_glr_term ts
  | `GLR_seq ts -> catmap " " string_of_glr_term ts
  
and string_of_glr_entry (name,t) = 
  (match name with 
  | Some n -> n ^ ":"
  | None -> ""
  )^
  string_of_glr_term t

and string_of_reduced_glr_entry (name,t) = 
  (match name with 
  | Some n -> n ^ ":"
  | None -> ""
  )^
  string_of_qualified_name t

and string_of_bglr_entry dfns (name,symbol) = 
  (match name with 
  | Some n -> n ^ ":"
  | None -> ""
  )^
  (match symbol with
  | `Nonterm (i::_) 
  | `Term i -> qualified_name_of_index dfns i
  | `Nonterm [] -> "<Undefined nonterminal>"
  )

and string_of_bbdcl dfns bbdcl index = 
  let name = qualified_name_of_index dfns index in
  let sobt t = string_of_btypecode dfns t in
  let se e = string_of_bound_expression dfns e in
  match bbdcl with
  | `BBDCL_function (props,vs,ps,res,es) ->
    string_of_properties props ^
    "fun " ^ name ^ print_bvs vs ^
    "("^ (string_of_bparameters dfns ps)^"): "^(sobt res) ^
    "{\n" ^
    cat "\n" (map (string_of_bexe dfns 1) es) ^
    "}"

  
  | `BBDCL_procedure (props,vs,ps,es) ->
    string_of_properties props ^
    "proc " ^ name ^ print_bvs vs ^
    "("^ (string_of_bparameters dfns ps)^")" ^
    "{\n" ^
    cat "\n" (map (string_of_bexe dfns 1) es) ^
    "}"

  | `BBDCL_val (vs,ty) ->
    "val " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  | `BBDCL_var (vs,ty) ->
    "var " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  (* binding structures [prolog] *)
  | `BBDCL_abs (vs,quals,code,reqs) ->
    (match quals with [] ->"" | _ -> string_of_quals quals ^ " ") ^
    "type " ^ name ^  print_bvs vs ^
    " = " ^ string_of_string code ^ ";"

  | `BBDCL_const (vs,ty,code,reqs) ->
     "const " ^ name ^ print_bvs vs ^    
     ": " ^ sobt ty ^ 
     " = "^string_of_string code^ 
     string_of_breqs dfns reqs ^
     ";" 

  | `BBDCL_fun (vs,ps,rt,code,reqs,prec) ->
    "fun " ^ name ^ print_bvs vs ^
    ": " ^ 
    (sobt (typeoflist ps)) ^ " -> " ^
    (sobt rt) ^ 
    " = " ^ string_of_string code ^ 
    (if prec = "" then "" else ":"^prec^" ")^
     string_of_breqs dfns reqs ^
    ";"

  | `BBDCL_proc (vs, ps,code,reqs) ->
    "proc " ^ name ^ print_bvs vs ^
    ": " ^ 
     (sobt (typeoflist ps)) ^
     " = " ^ string_of_string code ^ 
     string_of_breqs dfns reqs ^
     ";"

  | `BBDCL_header (vs,s,reqs) -> 
    "header " ^ name^  print_bvs vs ^
    " "^ string_of_string s ^
    string_of_breqs dfns reqs

  | `BBDCL_body (vs,s,reqs) -> 
    "body " ^ name^ 
    " "^ string_of_string s ^
    string_of_breqs dfns reqs


  | `BBDCL_union (vs,cs) ->
    let string_of_union_component (name,ty) =
      "  " ^ "|" ^name ^ special_string_of_btypecode dfns ty
    in
    "union " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    "}"

  | `BBDCL_struct (vs,cs) ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "struct " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"

  | `BBDCL_cstruct (vs,cs) ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "cstruct " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"

  | `BBDCL_glr (vs,t,(p,bexes)) ->
    "  " ^ "nonterm " ^ name ^ print_bvs vs ^ " : " ^sobt t ^
    "   | " ^
    string_of_bproduction dfns p ^
    " => " ^
    cat "\n" (map (string_of_bexe dfns 1) bexes) ^
    ";"
  
  | `BBDCL_nonconst_ctor (vs,uidx,ut,ctor_idx, ctor_argt) ->
    "  uctor<" ^ name ^ ">"^ print_bvs vs ^
    " : " ^ sobt ut ^ 
    " of " ^ sobt ctor_argt ^
    ";"
    
    
let string_of_dfn dfns i =
  match Hashtbl.find dfns i with
  | { id=id; sr=sr; vs=vs; symdef=entry } ->
  string_of_symdef entry id vs
  ^ " defined at " ^ short_string_of_src sr

let full_string_of_entry_kind dfns i =
  string_of_dfn dfns i

let string_of_entry_kind i = si i

let string_of_entry_set = function
  | NonFunctionEntry x -> string_of_entry_kind x
  | FunctionEntry ls -> 
    "{" ^
      catmap "," string_of_entry_kind ls ^
    "}"

let full_string_of_entry_set dfns = function
  | NonFunctionEntry x -> full_string_of_entry_kind dfns x
  | FunctionEntry ls -> if length ls = 0 then "{}" else
    "{\n" ^
      catmap "\n" (full_string_of_entry_kind dfns) ls ^
    "\n}"

let string_of_varlist dfns varlist =
  catmap ", " (fun (i,t)-> si i ^ "->" ^ sbt dfns t) varlist

let print_env e = 
  let print_entry k v = 
    print_endline 
    (
      "  " ^ k ^ " " ^
      (
        match v with 
        | (NonFunctionEntry (i)) -> string_of_int i
        | _ -> ""
      )
    )
  in 
  let print_table htab = 
    print_endline "--"; Hashtbl.iter print_entry htab

  in 
  let print_level (index,id,htab,htabs) = 
    print_string (id^"<"^si index^">");
    print_table htab;
    print_endline "OPENS:";
    List.iter print_table htabs;
    print_endline "ENDOFOPENS"
  in 

  List.iter print_level e

let print_env_short e = 
  let print_level (index,id,htab,htabs) = 
    print_endline (id^"<"^si index^">")
  in 
  List.iter print_level e

@h = tangler('src/flx_mtypes1.ml')
@select(h)
module IntHashtbl = Hashtbl.Make(
  struct
    type t = int
    let equal = fun x y -> x = y
    let hash = fun x -> x
  end
)
;;

module StringMap = Map.Make(
  struct 
    type t = string 
    let compare = compare 
  end
)
;;

type string_string_map_t = string StringMap.t

module StringSet = Set.Make (
  struct 
    type t = string 
    let compare=compare 
  end
);;

module IntSet = Set.Make (
  struct 
    type t = int 
    let compare=compare 
  end
);;

(* set of IntSet's *)
module IntSetSet = Set.Make (
  struct 
    type t = IntSet.t 
    let compare=compare 
  end
);;

let stringset_map f s =
  let d = ref StringSet.empty in
  StringSet.iter
  (fun x -> d := StringSet.add (f x) !d)
  s
  ;
  !d

@h = tangler('src/flx_mtypes1.mli')
@select(h)
module IntHashtbl : Hashtbl.S with type key = int
module StringMap : Map.S with type key = string

type string_string_map_t = string StringMap.t
module StringSet : Set.S with type elt = string

val stringset_map: (string -> string) -> StringSet.t -> StringSet.t

module IntSet : Set.S with type elt = int
module IntSetSet : Set.S with type elt = IntSet.t

@h = tangler('src/flx_mtypes2.ml')
@select(h)
open Flx_mtypes1
open Flx_types
open List

(* generic entity instances: functions, variables *)
type instance_registry_t = (int * btypecode_t list, int) Hashtbl.t

type felix_compiler_options_t = 
{
  print_flag: bool;
  debug : bool;
  optimise : bool;
  trace : bool;
  include_dirs : string list;
  files : string list;
  raw_options: (string * string) list;
  reverse_return_parity: bool;
  heavy_inlining : bool;
  max_inline_length : int;
  compile_only : bool;
  force_recompile : bool;
}


type sym_state_t = 
{
  dfns : symbol_table_t;
  counter : int ref;
  varmap : typevarmap_t;
  ticache : (int, btypecode_t) Hashtbl.t;
  glr_cache : (int, btypecode_t) Hashtbl.t;
  env_cache : (int, env_t) Hashtbl.t;
  registry : type_registry_t;
  compiler_options : felix_compiler_options_t;
  instances : instance_registry_t;
  include_files : string list ref;
  roots : IntSet.t ref;
  wrappers : (int, int) Hashtbl.t;
  lexers : (int * tbexpr_t, int) Hashtbl.t;
  parsers : (int * btypecode_t * int list, int) Hashtbl.t;
}

module VarMap = StringMap
type varmap_t = string_string_map_t

module TypecodeSet = Set.Make(
  struct type t = Flx_ast.typecode_t let compare = compare end
)
type typecodeset_t = TypecodeSet.t

let typecodeset_of_list x = 
  let rec tsol x = match x with
  | h :: t -> TypecodeSet.add h (tsol t)
  | [] -> TypecodeSet.empty
  in tsol x

let typecodeset_map f x = typecodeset_of_list (map f (TypecodeSet.elements x))

(* for regular expressions *)

(* PosSet -- set of positions in regular expression, used for followpos *)
module PosSet = IntSet
module PosSetSet = IntSetSet
module CharSet = IntSet

@h = tangler('src/flx_mtypes2.mli')
@select(h)
open Flx_types
open Flx_mtypes1

module VarMap : Map.S with type key = string

type varmap_t = string VarMap.t

module TypecodeSet : Set.S with type elt = Flx_ast.typecode_t

type typecodeset_t = TypecodeSet.t
val typecodeset_of_list : TypecodeSet.elt list -> TypecodeSet.t
val typecodeset_map :
  (TypecodeSet.elt -> TypecodeSet.elt) -> TypecodeSet.t -> TypecodeSet.t

module PosSet : Set.S with type elt = int
module PosSetSet : Set.S with type elt = PosSet.t
module CharSet : Set.S with type elt = int

(* generic entity instances: functions, variables *)
type instance_registry_t = (int * btypecode_t list, int) Hashtbl.t

type felix_compiler_options_t = 
{
  print_flag: bool;
  debug : bool;
  optimise : bool;
  trace : bool;
  include_dirs : string list;
  files : string list;
  raw_options: (string * string) list;
  reverse_return_parity: bool;
  heavy_inlining : bool;
  max_inline_length : int;
  compile_only : bool;
  force_recompile : bool;
}


type sym_state_t = 
{
  dfns : symbol_table_t;
  counter : int ref;
  varmap : typevarmap_t;
  ticache : (int, btypecode_t) Hashtbl.t;
  glr_cache : (int, btypecode_t) Hashtbl.t;
  env_cache : (int, env_t) Hashtbl.t;
  registry : type_registry_t;
  compiler_options : felix_compiler_options_t;
  instances : instance_registry_t;
  include_files : string list ref;
  roots : IntSet.t ref;
  wrappers : (int, int) Hashtbl.t;
  lexers : (int * tbexpr_t, int) Hashtbl.t;
  parsers : (int * btypecode_t * int list, int) Hashtbl.t;
}


@head(1,'Compile time exceptions')
@python('//')
exceptions = """
open Flx_ast
open Flx_types
exception SyntaxError of string
exception ParseError of string
exception LexError of string
exception TokenError of string
exception ClientErrorn of range_srcref list * string
exception ClientError of range_srcref * string
exception ClientError2 of range_srcref * range_srcref * string
exception SystemError of range_srcref * string
exception Exit of int
exception Bad_recursion
exception Expr_recursion of expr_t
exception Free_fixpoint of btypecode_t 
exception Unresolved_return of range_srcref * string
"""
//
@h = tangler('src/flx_exceptions.ml')
@select(h)
@tangle(exceptions)
let clierrn srs s = raise (ClientErrorn (srs,s))
let clierr2 sr sr2 s = raise (ClientError2 (sr,sr2,s))
let clierr sr s = raise (ClientError (sr,s))
let syserr sr s = raise (SystemError (sr,s))
let catch s f = try f() with _ -> failwith s

@h = tangler('src/flx_exceptions.mli')
@select(h)
@tangle(exceptions)
val clierrn: range_srcref list -> string -> 'a
val clierr: range_srcref -> string -> 'a
val clierr2: range_srcref -> range_srcref -> string -> 'a
val syserr: range_srcref -> string -> 'a
val catch: string -> (unit -> 'a) -> 'a

@h = tangler('src/flx_typing.mli')
@select(h)
open Flx_ast
open Flx_types
exception UnificationError of btypecode_t * btypecode_t
val flx_bool : typecode_t
val flx_bbool : btypecode_t
val dummy_sr: range_srcref

val is_unitsum: btypecode_t -> bool
val int_of_unitsum : btypecode_t -> int
val all_units0 : b0typecode_t list -> bool
val all_units : btypecode_t list -> bool
val all_voids : btypecode_t list -> bool

val cmp_literal: literal_t -> literal_t -> bool
val cmp_tbexpr: tbexpr_t -> tbexpr_t -> bool

val type_of_argtypes : 
  typecode_t list -> 
  typecode_t
  
val funparamtype : 'a * 'b -> 'b

val typeoflist:
  btypecode_t list ->
  btypecode_t

val lift:
  btypecode_t -> btypecode_t
                                                                         
val lower:
  btypecode_t -> btypecode_t

val qualified_name_of_expr:
  expr_t -> qualified_name_t

module FuntypeSet : Set.S with type elt = typecode_t

module FunInstSet : Set.S with type elt = bid_t * btypecode_t list

@h = tangler('src/flx_typing.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_srcref
open List
open Flx_maps

let all_voids ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_void))
    true ls

let all_units0 ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

let all_units ls = all_units0 ls

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_unitsum _ -> true
  | `BTYP_sum ls ->  all_units ls
  | _ -> false


let int_of_unitsum t = match t with
  | `BTYP_unitsum k -> k
  | `BTYP_sum ls ->  
    if all_units ls then length ls
    else raise Not_found

  | _ -> raise Not_found 



exception UnificationError of btypecode_t * btypecode_t

(* unbound type *)
let type_of_argtypes ls = match ls with
 | [x] -> x
 | _ -> `TYP_tuple ls

let funparamtype x = snd x

module FuntypeSet = Set.Make(
  struct type t=typecode_t let compare = compare end
)

module FunInstSet = Set.Make(
  struct 
    type t= bid_t * btypecode_t list
    let compare = compare 
  end
)

(* bound type! *)
let typeoflist typlist = match typlist with
  | [] -> `BTYP_tuple []
  | [t] -> t
  | h :: t -> 
    try 
      iter 
      (fun t -> if t <> h then raise Not_found)
      t; 
      `BTYP_array (h,`BTYP_unitsum (length typlist))
    with Not_found ->
      `BTYP_tuple typlist

let lift t = t
let lower t = t (* CHANGE THIS WHEN ABSTRACT TYPES IMPLEMENTED *)

let dummy_sr = ("generated",0,0,0,0)
let flx_bool = `TYP_unitsum 2
let flx_bbool = `BTYP_unitsum 2

let qualified_name_of_expr e =
  match e with
  | #qualified_name_t as x -> x
  | _ -> 
    failwith
    (
      "Qualified name expected in\n" ^
      short_string_of_src (src_of_expr e)
    )

(* Note floats are equal iff they're textually identical,
   we don't make any assumptions about the target machine FP model.
   OTOH, int comparisons are infinite precision, for the same
   int kind, even if the underlying machine model is not
*)

let cmp_literal (l:literal_t) (l':literal_t) = match l, l' with
  | `AST_int (a,b), `AST_int (a',b') -> a = a' && Big_int.eq_big_int b b'
  | `AST_float (a,b), `AST_float (a',b') -> a = a' && b = b'
  | `AST_string s, `AST_string s' -> s = s'
  | `AST_cstring s, `AST_cstring s' -> s = s'
  | `AST_wstring s, `AST_wstring s' -> s = s'
  | `AST_ustring s, `AST_ustring s' -> s = s'
  | _ -> false

(* Note that we don't bother comparing the type subterm:
  this had better be equal for equal expressions: the value
  is merely the cached result of a synthetic context
  independent type calculation
*)

let rec cmp_tbexpr (a,_) (b,_) = 
  let ecmp = cmp_tbexpr in match a,b with
  | `BEXPR_parse (e,ii), `BEXPR_parse (e',ii') ->
    ecmp e e' && ii = ii'

  | `BEXPR_deref e,`BEXPR_deref e' -> ecmp e e'

  | `BEXPR_name (i,ts),`BEXPR_name (i',ts')
  | `BEXPR_ref (i,ts),`BEXPR_ref (i',ts') 
  | `BEXPR_closure (i,ts),`BEXPR_closure (i',ts') ->
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts'

  | `BEXPR_literal a,`BEXPR_literal a' -> cmp_literal a a'

  | `BEXPR_apply (a,b),`BEXPR_apply (a',b') ->  ecmp a a' && ecmp b b'

  | `BEXPR_apply_prim (i,ts,b),`BEXPR_apply_prim (i',ts',b') 
  | `BEXPR_apply_direct (i,ts,b),`BEXPR_apply_direct (i',ts',b')
  | `BEXPR_apply_stack (i,ts,b),`BEXPR_apply_stack (i',ts',b') ->  
     i = i' && 
     fold_left2 (fun r a b -> r && a = b) true ts ts' &&
     ecmp b b'

  | `BEXPR_tuple ls,`BEXPR_tuple ls' ->
     fold_left2 (fun r a b -> r && ecmp a b) true ls ls'

  | `BEXPR_case_arg (i,e),`BEXPR_case_arg (i',e')

  | `BEXPR_match_case (i,e),`BEXPR_match_case (i',e')
  | `BEXPR_get_n (i,e),`BEXPR_get_n (i',e') ->
    i = i' && ecmp e e'

  | `BEXPR_case_index e,`BEXPR_case_index e' -> ecmp e e'

  | `BEXPR_case (i,t),`BEXPR_case (i',t') -> i = i' && t = t'
  | `BEXPR_expr (s,t),`BEXPR_expr (s',t') -> s = s' && t = t'
  | _ -> false

 
@h = tangler('src/flx_typing2.mli')
@select(h)
open Flx_ast
val typecode_of_expr:
  expr_t -> typecode_t

val typeof_list:
  typecode_t list -> typecode_t

val paramtype: 
  (string * typecode_t) list -> typecode_t


@h = tangler('src/flx_typing2.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_print
open Flx_srcref
open Flx_exceptions
open List

let typeof_list = function 
  | [x] -> x 
  | x -> `TYP_tuple x

let paramtype params = 
  let typlist params = map snd params in
  typeof_list (typlist params)

let all_tunits ts = 
  try 
    iter 
    (fun t -> 
      if t <> `TYP_tuple [] 
      then raise Not_found
    ) 
    ts; 
    true
  with Not_found -> false

let rec typecode_of_expr (e:expr_t) :typecode_t = 
  let te e = typecode_of_expr e in
  match e with 
  | `AST_name (_,"TYPE",[]) -> `TYP_type
  | `AST_ellipsis _ -> `TYP_ellipsis
  | #qualified_name_t as x -> (x:>typecode_t)
  | `AST_tuple (sr,ls) ->
    `TYP_type_tuple (map te ls)

  | `AST_product (_,ts) -> `TYP_tuple (map te ts)
  | `AST_arrow (_,(a,b)) -> `TYP_function (te a, te b)
  | `AST_superscript (_,(a,b)) -> `TYP_array (te a, te b)
  | `AST_lvalue (sr,e) -> `TYP_lvalue (te e)
  | `AST_ref (sr,e) -> `TYP_pointer (te e)
  | `AST_sum (_,ts) -> 
    let ts = map te ts in
    if all_tunits ts then
      `TYP_unitsum (length ts)
    else
      `TYP_sum ts

  | `AST_typeof (_,e) -> `TYP_typeof e
  | `AST_as (sr,(t,x)) -> `TYP_as (te t,x)

  | `AST_literal (sr,`AST_int (enc,v)) ->
    if enc <> "int" 
    then 
      clierr sr
      (
        "Only plain integer can be used as a type, code= '" ^ 
        enc ^
        "'"
      )
    else 
    let v = ref 
      begin try Big_int.int_of_big_int v
      with _ -> clierr sr "Integer used as type out of range"
      end
    in
      if !v <0 then clierr sr "Negative int not allowed as type"
      else if !v = 0 then ((`AST_void sr) :> typecode_t)
      else if !v = 1 then `TYP_tuple[]
      else `TYP_unitsum !v

  | `AST_apply(sr,(e1,e2)) ->
    begin match e1 with
    | `AST_name (_,name,[]) ->
      let name' = name ^ "          " (* 10 chars *) in
      if name = "typeof" then `TYP_typeof e2 
      else let arg = typecode_of_expr e2 in
      if name = "compl" then `TYP_dual arg
      else if String.sub name' 0 5 = "proj_" 
      then 
        begin 
          let acc = ref 0 in
          for i = 5 to String.length name - 1 do
          if name.[i] <= '9' && name.[i] >='0'
          then acc := 10 * !acc + Char.code (name.[i]) - Char.code '0'
          else
            clierr sr 
            (
              "Digits expected in name '" ^ name ^ "' in\n" ^
              short_string_of_src sr
            )
          done;
          `TYP_proj (!acc, arg)
         end

      else if String.sub name' 0 9 = "case_arg_" 
      then 
        begin 
          let acc = ref 0 in
          for i = 9 to String.length name - 1 do
          if name.[i] <= '9' && name.[i] >='0'
          then acc := 10 * !acc + Char.code (name.[i]) - Char.code '0'
          else
            clierr sr
            (
              "Digits expected in name '" ^ name ^ "' in\n" ^
              short_string_of_src sr
            )
          done;
          `TYP_case_arg (!acc, arg)
         end
      else 
        `TYP_apply (typecode_of_expr e1,arg)

    | _ ->
      `TYP_apply (typecode_of_expr e1,typecode_of_expr e2)
    end

  | `AST_lambda (sr,(paramss,ret,body)) ->
     begin match paramss with
     | [params] ->
       begin match body with
       | [`AST_fun_return (_,e)] -> 
         begin 
           try
             let t = typecode_of_expr e in
            `TYP_typefun 
            ( 
              params,
              ret,
              t
            )
           with _ -> 
             clierr sr 
             "Type lambda must return type expression"
         end

       | _ -> 
         clierr sr
         "Type lambda must just be 'return type_expr'"
       end
     | _ -> 
       clierr sr
       "Type lambda only allowed one argument (arity=1)"
     end

  | `AST_type_match (sr,(e,ps)) ->
    `TYP_type_match (e,ps)

  | #expr_t -> 
    let sr = src_of_expr e in
    clierr sr "Type expression expected"
    
@head(1,'Charset')
@select(tangler('src/flx_charset.mli'))
open Flx_ast
type charset_t
val charset_of_string: string -> charset_t
val charset_of_int_range: int -> int -> charset_t
val charset_of_range: string -> string -> charset_t
val charset_union: charset_t -> charset_t -> charset_t
val charset_inv: charset_t -> charset_t
val regexp_of_charset: charset_t -> regexp_t
val regexp_underscore: regexp_t
val eol: int
val regexp_dot: regexp_t

@select(tangler('src/flx_charset.ml'))
open Flx_ast
type charset_t = bool array

let charset_of_string s = 
  let x = Array.make 256 false in
  for i  = 0 to String.length s - 1 do
    x.(Char.code s.[i]) <- true
  done;
  x


let charset_of_int_range x1 x2 =
  let x = Array.make 256 false in
  for i = x1 to x2 do
    x.(i) <- true 
  done
  ;
  x

let charset_of_range s1 s2 =
  if String.length s1 <> 1 
  then
    failwith "Charset range(first) requires string length 1"
  ;
  if String.length s2 <> 1 
  then
    failwith "Charset range(last) requires string length 1"
  ;
  let x1 = Char.code (s1.[0])
  and x2 = Char.code (s2.[0])
  in 
    charset_of_int_range x1 x2

let charset_union x1 x2 = 
  let x = Array.make 256 false in
  for i = 0 to 255 do
    x.(i) <- x1.(i) || x2.(i)
  done;
  x

let charset_inv y =
  let x = Array.make 256 false in
  for i = 0 to 255 do
    x.(i) <- not y.(i)
  done;
  x

let regexp_of_charset y =
  let res = ref REGEXP_epsilon in
  for i = 0 to 255 do
    if y.(i) then res := 
      let r = REGEXP_string (String.make 1 (Char.chr i)) in
      if !res = REGEXP_epsilon 
      then r 
      else REGEXP_alt ( !res, r)
  done
  ;
  !res

let regexp_underscore = 
  regexp_of_charset (charset_of_int_range 0 255)

let eol = Char.code '\n'

let regexp_dot = 
  regexp_of_charset 
  (
    charset_union 
      (charset_of_int_range 0 (eol - 1))
      (charset_of_int_range (eol + 1) 255)
  )


