@head(1,'Utilities')
Generic (non Felix dependent) utilities.
@h = tangler('src/flx_util.mli')
@select(h)
(** Generic utilities *)

(** n spaces *)
val spaces : int -> string

(** String.concat sep (List.map fun lst) *)
val catmap : string -> ('a -> string) -> 'a list -> string

(** reverse application *)
val (+>) : 'a -> ('a ->'b) -> 'b

(** hmmm *)
val transpose: 'a list list -> 'a list list

(** last element of list *)
val list_last: 'a list -> 'a 

(** position in list of value *)
val list_index: 'a list -> 'a -> int option

(** forward order map *)
val list_omap: ('a -> 'b) -> 'a list -> 'b list

(** convert exception to option *)
val catch_all : ('a -> 'b) -> 'a -> 'b option

(** test if option not None *)
val is_some: 'a option -> bool

(** list of n integers 0  to n-1 *)
val nlist: int -> int list

(** first n elements of a list *)
val list_prefix: 'a list -> int -> 'a list

(** synonym for string_of_int *)
val si: int -> string

(** synonym for String.concat *)
val cat: string -> string list -> string

(** synonym for Buffer.add_string *)
val bcat: Buffer.t -> string -> unit

(** make a hashtable from an assoc list *)
val hashtable_of_list:
  ('a * 'b) list ->
  ('a,'b) Hashtbl.t

(** fixpoint combinator *)
val fix:
 (('a -> 'b) -> 'a -> 'b) -> 'a -> 'b

@h = tangler('src/flx_util.ml')
@select(h)
let spaces level = String.make (level*2) ' '
let catmap sep fn ls = String.concat sep (List.map fn ls)
let (+>) x f = f x (* reverse application *)
let transpose x =
  let dtor ls =
    List.split (List.map (fun x -> List.hd x, List.tl x) ls)
  in let rec cons ls (h,t) = match List.hd t with
    | [] -> h :: ls
    | _ -> cons (h :: ls) (dtor t)
  in List.tl (List.rev (cons [] ([],x)))

let list_last l = List.hd (List.rev l)

let list_prefix lst n =
  let rec aux ol nl n = 
    if n>0 then aux (List.tl ol) (List.hd ol :: nl) (n-1)
    else List.rev nl
  in aux lst [] n

let rec list_index l x = 
 let rec aux l i =
   match l with
   | [] -> None
   | h::t -> 
    if x = h then Some i
    else aux t (i+1)
  in aux l 0

let list_omap f ls =
  List.rev (List.rev_map f ls)

let catch_all f x = 
  try Some (f x) with _ -> None

let is_some = function | Some _ -> true | None -> false

let nlist n = 
  let lst = ref [] in
  for i = 1 to n do lst := (n-i) :: !lst done;
  !lst

let si = string_of_int
let cat = String.concat
let bcat = Buffer.add_string

let hashtable_of_list lst = 
  let t = Hashtbl.create (List.length lst) in
  List.iter
  (fun (k,v) -> Hashtbl.add t k v)
  lst
  ;
  t

let rec fix f x = f (fix f) x

@head(1,'AST')
@h = tangler('src/flx_ast.mli')
@head(2,'Source Reference')
Provides a reference to the original source.
@select(h)
(** Types used in the Felix compiler *)
open Big_int

(** type of a position in the {e original} sources *)
type srcref = 
  string (* filename *) *
  int (* line number, 1 origin *) *
  int (* starting column, 1 origin *) *
  int (* ending column, 1 origin *)

(** type of a span between two positions in one file*)
type range_srcref =
  string * (* filename *)
  int * (* starting line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int * (* ending line number, 1 origin *)
  int   (* ending column, 1 origin *)

@head(2,'Abstract Syntax Tree')
AST types are nodes of the Abstract Syntax Tree generated by the
parser. 

@head(3,'Names')
A simple name is an identifier, a qualified name is a dot (.) separated list
of instantiated names, and a instantiated name is a simple name optionally
followed by a square bracket enclosed list of type expressions.
@select(h)
type c_t = string     (* C++ code as a string *)
type id_t = string
type vs_list_t = (id_t * int) list
type bid_t = int
type index_map_t = (int,int) Hashtbl.t


(** type of a qualified name *)
type qualified_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  ]

(** type of a suffixed name *)
and suffixed_name_t =
  [
  | `AST_void of range_srcref
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)
  ]

(** type of a regular expression *)
and regexp_t =
  | REGEXP_seq of regexp_t * regexp_t (** concatenation *)
  | REGEXP_alt of regexp_t * regexp_t (** alternation *)
  | REGEXP_aster of regexp_t (** Kleene closure *)
  | REGEXP_name of qualified_name_t (** lookup regular definition *)
  | REGEXP_string of string  (** concatenation of chars of string *)
  | REGEXP_epsilon (** epsilon: null string *)
  | REGEXP_sentinel (** end marker *)
  | REGEXP_code of expr_t (** associated code *)

@head(3,'Type sublanguage')
The encoding '`TYP_void'
is the categorical initial: the type of an empty
union, and the type ordinary procedure types return.
There are no values of this type. 
@select(h)
(** type of a type *)
and typecode_t = 
  [
  | `AST_void of range_srcref                   (** void type *)
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `TYP_tuple of typecode_t list               (** product type *)
  | `TYP_sum of typecode_t list                 (** numbered sum type *)
  | `TYP_function of typecode_t * typecode_t    (** function type *)
  | `TYP_pointer  of typecode_t                 (** pointer type *)
  | `TYP_as of typecode_t * string              (** fixpoint *)
  | `TYP_typeof of expr_t                       (** typeof *)
  | `TYP_var of int                             (** unknown type *)
  | `TYP_none                                   (** unspecified *)

  (* destructors *)
  | `TYP_dom of typecode_t                      (** function domain extractor *)
  | `TYP_cod of typecode_t                      (** function codomain extractor *)
  | `TYP_proj of int * typecode_t               (** tuple projection *)
  | `TYP_case_arg of int * typecode_t           (** argument of n'th variant *)

  | `TYP_apply of typecode_t * typecode_t       (** type function application *)
  | `TYP_typefun of parameter_t list * typecode_t * typecode_t
                                                (** type lambda *)
  | `TYP_type                                   (** meta type of a type *)
  | `TYP_type_tuple of typecode_t list          (** meta type product *)
  ]

@head(3,'Literals')
Literals recognized by the lexer.
@select(h)
and literal_t =
  [
  | `AST_int of string * big_int
  | `AST_string of string
  | `AST_wstring of string
  | `AST_ustring of string
  | `AST_float of string * string
  ]

@head(3,'Expressions')
Raw expression terms.

@select(h)
and expr_t =
  [
  | `AST_noexpand of range_srcref * expr_t
  | `AST_name of range_srcref * string * typecode_t list
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string * typecode_t list)
  | `AST_apply of range_srcref * (expr_t * expr_t)
  | `AST_tuple of range_srcref * expr_t list
  | `AST_coercion of range_srcref * (expr_t * typecode_t)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)

  | `AST_void of range_srcref
  | `AST_product of range_srcref * expr_t list
  | `AST_sum of range_srcref * expr_t list
  | `AST_arrow of range_srcref * (expr_t * expr_t)

  | `AST_literal of range_srcref * literal_t
  | `AST_deref of range_srcref * expr_t
  | `AST_ref of range_srcref * expr_t
  | `AST_method_apply of range_srcref * (id_t * expr_t)
  | `AST_dot of range_srcref * (expr_t * id_t)
  | `AST_lambda of range_srcref * (parameter_t list * typecode_t * statement_t list)
  | `AST_match_ctor of range_srcref * (qualified_name_t * expr_t)
  | `AST_match_case of range_srcref * (int * expr_t)
  | `AST_ctor_arg of range_srcref * (qualified_name_t * expr_t)
  | `AST_case_arg of range_srcref * (int * expr_t)
  | `AST_letin of range_srcref * (pattern_t * expr_t * expr_t)

  | `AST_get_n of range_srcref * (int * expr_t) (* get n'th component of a tuple *)
  | `AST_as of range_srcref * (expr_t * string)
  | `AST_match of range_srcref * (expr_t * (pattern_t * expr_t) list)
  | `AST_regmatch of range_srcref * (expr_t * (regexp_t * expr_t) list)
  | `AST_reglex of range_srcref * (expr_t * (regexp_t * expr_t) list)
  | `AST_typeof of range_srcref * expr_t
  | `AST_cond of range_srcref * (expr_t * expr_t * expr_t)


  (* hacks .. *)
  | `AST_bound_module of range_srcref * (bid_t * bid_t * index_map_t)
  ]

@head(3,'Pattern')
Patterns; used for matching variants in match statements.
@select(h)
and float_pat = 
  | Float_plus of string * string (** type, value *)
  | Float_minus of string * string
  | Float_inf  (** infinity *)
  | Float_minus_inf (** negative infinity *)

and pattern_t =
  [
  | `PAT_nan of range_srcref

  (* constants *)
  | `PAT_int of range_srcref * string * big_int
  | `PAT_string of range_srcref * string

  (* ranges *)
  | `PAT_int_range of range_srcref * string * big_int * string * big_int
  | `PAT_string_range of range_srcref * string * string
  | `PAT_float_range of range_srcref * float_pat * float_pat 

  (* other *)
  | `PAT_name of range_srcref * id_t 
  | `PAT_tuple of range_srcref * pattern_t list
  | `PAT_any of range_srcref 
  | `PAT_regexp of range_srcref * string * id_t list 
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | `PAT_const_ctor of range_srcref * qualified_name_t
  | `PAT_nonconst_ctor of range_srcref * qualified_name_t * pattern_t
  | `PAT_as of range_srcref * pattern_t * id_t
  | `PAT_when of range_srcref * pattern_t * expr_t
  ]

@head(3,'Statements')
Statements; that is, the procedural sequence control system.
@select(h)
and parameter_t = id_t * typecode_t
and macro_parameter_type_t = 
  | Ident 
  | Expr 
  | Stmt
and macro_parameter_t = id_t * macro_parameter_type_t

and statement_t =
  [ 
  | `AST_include of range_srcref * string 
  | `AST_open of range_srcref * qualified_name_t
  | `AST_use of range_srcref * id_t * qualified_name_t
  | `AST_comment of string (* for documenting generated code *)

  (* definitions *)
  | `AST_function of range_srcref * id_t * id_t list * parameter_t list * typecode_t * statement_t list
  | `AST_regdef of range_srcref * string * regexp_t

  (* macros *)
  | `AST_name_macro of range_srcref * id_t * id_t 
  | `AST_expr_macro of range_srcref * id_t * macro_parameter_t list * expr_t
  | `AST_stmt_macro of range_srcref * id_t * macro_parameter_t list * statement_t list
  | `AST_macro_val  of range_srcref * id_t * expr_t
  | `AST_macro_var  of range_srcref * id_t * expr_t
  | `AST_macro_assign of range_srcref * id_t * expr_t
  | `AST_macro_forget of range_srcref * id_t list
  | `AST_macro_label of range_srcref * id_t
  | `AST_macro_goto of range_srcref * id_t
  | `AST_macro_ifgoto of range_srcref * expr_t * id_t
  | `AST_macro_proc_return of range_srcref

  (* types *)
  | `AST_union of range_srcref * id_t * id_t list * (id_t * typecode_t) list
  | `AST_struct of range_srcref * id_t * id_t list * (id_t * typecode_t) list
  | `AST_type_alias of range_srcref * id_t * id_t list * typecode_t

  (* variables *)
  | `AST_val_decl of range_srcref * id_t * id_t list * typecode_t option * expr_t option
  | `AST_var_decl of range_srcref * id_t * id_t list * typecode_t option * expr_t option
 
  (* module system *)
  | `AST_untyped_module of range_srcref * id_t * id_t list * statement_t list  
  | `AST_typed_module of range_srcref * id_t * id_t list * typecode_t * statement_t list  
  | `AST_module_binding of range_srcref * id_t * id_t list * expr_t
  | `AST_typed_functor of range_srcref * id_t * id_t list * parameter_t list * typecode_t * statement_t list
  | `AST_untyped_functor of range_srcref * id_t * id_t list * parameter_t list * statement_t list
  | `AST_interface of range_srcref * id_t * id_t list * statement_t list
  | `AST_type of range_srcref * id_t * id_t list 
  | `AST_function_decl of range_srcref * id_t * id_t list * typecode_t
 
  (* control structures: primitives *)
  | `AST_label of range_srcref * id_t
  | `AST_goto of range_srcref * id_t 
  | `AST_ifgoto of range_srcref * expr_t *id_t
  | `AST_ifnotgoto of range_srcref * expr_t * id_t
  | `AST_call of range_srcref * expr_t * expr_t 
  | `AST_jump of range_srcref * expr_t * expr_t 
  | `AST_loop of range_srcref * id_t * expr_t 
  | `AST_read of range_srcref * id_t
  | `AST_fun_return of range_srcref * expr_t
  | `AST_proc_return of range_srcref 
  | `AST_nop of range_srcref * string

  (* binding structures [prolog] *)
  | `AST_abs_decl of range_srcref * id_t * id_t list * c_t
  | `AST_const_decl of range_srcref * id_t * id_t list * typecode_t * c_t
  | `AST_fun_decl of range_srcref * id_t * id_t list * typecode_t list * typecode_t * c_t 
  | `AST_proc_decl of range_srcref * id_t * id_t list *  typecode_t list * c_t 

  (* embedding *)
  | `AST_header of range_srcref * string
  | `AST_body of range_srcref * string
  | `AST_code of range_srcref * string
  | `AST_noreturn_code of range_srcref * string

  | `AST_export of range_srcref * suffixed_name_t * string

  ]


and exe_t =
  [
  | `EXE_code of string (* for inline C++ code *)
  | `EXE_noreturn_code of string (* for inline C++ code *)
  | `EXE_comment of string (* for documenting generated code *)
  | `EXE_label of string (* for internal use only *)
  | `EXE_goto of string  (* for internal use only *)
  | `EXE_ifgoto of expr_t * string  (* for internal use only *)
  | `EXE_ifnotgoto of expr_t * string  (* for internal use only *)
  | `EXE_call of expr_t * expr_t 
  | `EXE_jump of expr_t * expr_t 
  | `EXE_loop of id_t * expr_t 
  | `EXE_read of id_t
  | `EXE_fun_return of expr_t
  | `EXE_proc_return
  | `EXE_nop of string
  | `EXE_init of id_t * expr_t 
  | `EXE_regmatch of (expr_t * (regexp_t * expr_t) list)
  | `EXE_reglex of (expr_t * (regexp_t * expr_t) list)
  ]

@doc()
The whole of a compilation unit, this is the data structure
returned by parsing a whole file.
@select(h)
type compilation_unit_t = statement_t list


@head(1,'Types')
@h = tangler('src/flx_types.mli')
These files declare the main data structures used by the compiler,
and provide routines to dump them to a string for debugging purposes.

@head(2,'Version identification kit')
@select(h)
open Flx_ast
type version_data_t =
{
  version_string : string;
  build_time_float : float;
  build_time : string;
  buildno : int;
}

@head(3,'Pattern extractor')
This type is used to extract components of a value,
corresponding to a match.
@select(h)
type dir_t =
  | DIR_open of qualified_name_t
  | DIR_use of id_t * qualified_name_t

type dcl_t = 
  [
  | `DCL_header of string
  | `DCL_body of string

  (* data structures *)
  | `DCL_function of     parameter_t list * typecode_t * asm_t list
  | `DCL_union of        (id_t * typecode_t) list
  | `DCL_struct of       (id_t * typecode_t) list
  | `DCL_match_check of pattern_t * string
  | `DCL_match_handler of pattern_t * string * asm_t list
 
  (* variables *)
  | `DCL_val of          typecode_t
  | `DCL_var of          typecode_t
  | `DCL_type_alias of   typecode_t

  (* module system *)
  | `DCL_module of       asm_t list  
  | `DCL_typed_functor of      parameter_t list * typecode_t * asm_t list
  | `DCL_untyped_functor of    parameter_t list * asm_t list
  | `DCL_module_binding of expr_t
  | `DCL_interface of    asm_t list

  (* interface elements *)
  | `DCL_if_fun of       typecode_t
  | `DCL_type
  
  (* binding structures [prolog] *)
  | `DCL_abs of          c_t
  | `DCL_const of        typecode_t * c_t
  | `DCL_fun of          typecode_t list * typecode_t * c_t 
  | `DCL_regdef of      regexp_t
  ]

and asm_t = 
  
  | Exe of range_srcref * exe_t 
  | Dcl of range_srcref * id_t * id_t list * dcl_t 
  | Iface of range_srcref * iface_t
  | Dir of range_srcref * dir_t
 
and entry_kind_t = 
  | Simple of int
  | Bound of int * int

and entry_set_t =
  | FunctionEntry of entry_kind_t list
  | NonFunctionEntry of entry_kind_t
  
and module_rep_t = 
  | Simple_module of bid_t * name_map_t * dir_t list
  | Bound_module of bid_t * bid_t * index_map_t
  | Functor_set of bid_t list
  | Module_product of module_rep_t list

and name_map_t = (string, entry_set_t) Hashtbl.t

and iface_t =
  [
  | `IFACE_export of suffixed_name_t * string
  ]

and biface_t =
  [
  | `BIFACE_export of bid_t * string
  ]

(** value typing *)
type 't b0typecode_t' = 
  [
  | `BTYP_name of bid_t         
  | `BTYP_inst of bid_t * 't list 
  | `BTYP_tuple of 't list         
  | `BTYP_sum of 't list            
  | `BTYP_function of 't * 't
  | `BTYP_pointer  of 't 
  | `BTYP_void                       
  | `BTYP_binding of 't * 't 
  | `BTYP_fix of int      
  | `BTYP_var of int     
  ]

(** meta typing *)
type 't b1typecode_t' =
  [
  | `BTYP_apply of 't * 't 
  | `BTYP_typefun of (int * 't) list * 't * 't
  | `BTYP_type
  | `BTYP_type_tuple of 't list
  ]

(** general typing *)
type 't btypecode_t' =
  [
  | 't b0typecode_t'
  | 't b1typecode_t'
  ]

type b0typecode_t = 't b0typecode_t' as 't
type btypecode_t = 't btypecode_t' as 't

type regular_args_t =
    tbexpr_t * (* argument *)
    int list * (* alphabet *)
    int *      (* state count *)
    (int, tbexpr_t) Hashtbl.t * (* state->expression map *)
    (int * int, int) Hashtbl.t (* transition matrix *)

and bexe_t =
  [
  | `BEXE_label of string
  | `BEXE_comment of string (* for documenting generated code *)
  | `BEXE_goto of string  (* for internal use only *)
  | `BEXE_ifgoto of tbexpr_t * string  (* for internal use only *)
  | `BEXE_ifnotgoto of tbexpr_t * string  (* for internal use only *)
  | `BEXE_call of tbexpr_t * tbexpr_t 
  | `BEXE_jump of tbexpr_t * tbexpr_t 
  | `BEXE_loop of int * tbexpr_t 
  | `BEXE_read of bid_t
  | `BEXE_fun_return of tbexpr_t
  | `BEXE_proc_return 
  | `BEXE_nop of string
  | `BEXE_code of string
  | `BEXE_init of bid_t * tbexpr_t 
  | `BEXE_regmatch of regular_args_t
  | `BEXE_reglex of regular_args_t
  ]

and bexpr_t =
  [
  | `BEXPR_deref of tbexpr_t
  | `BEXPR_name of bid_t * btypecode_t list
  | `BEXPR_ref of bid_t * btypecode_t list
  | `BEXPR_literal of literal_t 
  | `BEXPR_apply of tbexpr_t * tbexpr_t 
  | `BEXPR_tuple of tbexpr_t list
  | `BEXPR_dot of tbexpr_t * bid_t
  | `BEXPR_get_n of int * tbexpr_t
  | `BEXPR_closure of bid_t * btypecode_t list
  | `BEXPR_coercion of tbexpr_t * btypecode_t
  | `BEXPR_case of int * btypecode_t
  | `BEXPR_match_case of int * tbexpr_t
  | `BEXPR_case_arg of int * tbexpr_t
  ]

and tbexpr_t = bexpr_t * btypecode_t

and bparameter_t = string * (int * btypecode_t)
and bbdcl_t = 
  [
  | `BBDCL_header of     string
  | `BBDCL_body of       string
  | `BBDCL_function of   (string * int) list * bparameter_t list * btypecode_t * bexe_t list * name_map_t
  | `BBDCL_procedure of  (string * int) list * bparameter_t list * bexe_t list * name_map_t
  | `BBDCL_val of        (string * int) list * btypecode_t
  | `BBDCL_var of        (string * int) list * btypecode_t

  (* binding structures [prolog] *)
  | `BBDCL_abs of        (string * int) list * c_t
  | `BBDCL_const of      (string * int) list * btypecode_t * c_t
  | `BBDCL_fun of        (string * int) list * btypecode_t list * btypecode_t * c_t 
  | `BBDCL_proc of       (string * int) list * btypecode_t list * c_t 
  | `BBDCL_union of      (string * int) list * (id_t * btypecode_t) list
  | `BBDCL_struct of     (string * int) list * (id_t * btypecode_t) list
  ]

(* functor instances *)
and instantiation_registry_t = 
  (
    int *                         (* functor index *)
    module_rep_t,                 (* argument list *) 
    int                           (* instantiated functor = module index *)
  ) Hashtbl.t
and typevarmap_t = (int,btypecode_t) Hashtbl.t
and functor_arg_binding_t = 
  (
    id_t *                        (* argument name *)
    (
      bid_t *                     (* interface *)
      bid_t *                     (* implementation module  *)
      index_map_t                 (* interface->module binding map *)
    )
  ) list

type env_t = (name_map_t * name_map_t list) list 

type symbol_definition_t =
  [
  | `SYMDEF_abs of c_t
  | `SYMDEF_regdef of regexp_t
  | `SYMDEF_header of string
  | `SYMDEF_body of string

  | `SYMDEF_parameter of  typecode_t
  | `SYMDEF_typevar of typecode_t (* usually type TYPE *)

  | `SYMDEF_function of parameter_t list * typecode_t * exe_t list

  | `SYMDEF_match_check of  pattern_t * int 
  | `SYMDEF_interface 
  | `SYMDEF_typed_functor of parameter_t list * typecode_t * exe_t list
  | `SYMDEF_untyped_functor of parameter_t list * exe_t list 
  | `SYMDEF_module
  | `SYMDEF_if_type
  | `SYMDEF_if_fun of typecode_t
  
  | `SYMDEF_module_binding of expr_t
  | `SYMDEF_const of typecode_t * c_t
  | `SYMDEF_var of  typecode_t
  | `SYMDEF_val of  typecode_t
  | `SYMDEF_fun of typecode_t list * typecode_t * c_t 
  | `SYMDEF_union of  (id_t * typecode_t) list
  | `SYMDEF_struct of  (id_t * typecode_t) list
  | `SYMDEF_type_alias of   typecode_t
  ]

type symbol_data_t = string * range_srcref * int option * vs_list_t * name_map_t * dir_t list * symbol_definition_t 
type symbol_table_t = (int, symbol_data_t) Hashtbl.t

type symbol_data3_t = string * int option * bbdcl_t 
type fully_bound_symbol_table_t = (int, symbol_data3_t) Hashtbl.t

type type_registry_t = (btypecode_t,int) Hashtbl.t

(* generic entity instances: functions, variables *)
type instance_registry_t = (int * btypecode_t list, int) Hashtbl.t

type felix_compiler_options_t = 
{
  print_flag: bool;
  debug : bool;
  optimise : bool;
  trace : bool;
  include_dirs : string list;
  files : string list;
  raw_options: (string * string) list;
  reverse_return_parity: bool;
}

type sym_state_t = 
{
  dfns : symbol_table_t;
  freg : instantiation_registry_t;
  counter : int ref;
  varmap : typevarmap_t;
  ticache : (int * btypecode_t list, btypecode_t) Hashtbl.t;
  env_cache : (int, env_t) Hashtbl.t;
  registry : type_registry_t;
  compiler_options : felix_compiler_options_t;
  instances : instance_registry_t
}

@head(1,'Mappings')
@h = tangler('src/flx_maps.mli')
@select(h)
open Flx_ast
open Flx_types

val map_type:
  (typecode_t -> typecode_t) -> typecode_t -> typecode_t

val map_b0type:
  (b0typecode_t -> b0typecode_t) -> b0typecode_t -> b0typecode_t

val map_btype:
  (btypecode_t -> btypecode_t) -> btypecode_t -> btypecode_t

val iter_b0type:
  (b0typecode_t -> unit) -> b0typecode_t -> unit

val iter_btype:
  (btypecode_t -> unit) -> btypecode_t -> unit
  
@h = tangler('src/flx_maps.ml')
@select(h)
open Flx_ast
open Flx_types
open List

let map_type f = function
  | `AST_typed_case (sr,i,t) -> `AST_typed_case (sr,i, f t)
  | `TYP_tuple ts -> `TYP_tuple (map f ts)
  | `TYP_sum ts -> `TYP_sum (map f ts)
  | `TYP_function (a,b) -> `TYP_function (f a, f b)
  | `TYP_pointer t -> `TYP_pointer (f t)
  | `TYP_as (t,s) -> `TYP_as (f t,s)

  (* destructors *)
  | `TYP_dom t -> `TYP_dom (f t)
  | `TYP_cod t -> `TYP_cod (f t)
  | `TYP_proj (i,t) -> `TYP_proj (i, f t)
  | `TYP_case_arg (i,t) -> `TYP_case_arg (i, f t) 
  
  (* meta constructors *)
  | `TYP_apply (a,b) -> `TYP_apply (f a, f b)
  | `TYP_typefun (ps, a, b) -> `TYP_typefun (ps, f a, f b)
  | `TYP_type_tuple ts -> `TYP_type_tuple (map f ts)
  | x -> x

let map_b0type f = function
  | `BTYP_inst (i,ts) -> `BTYP_inst (i, map f ts)
  | `BTYP_tuple ts -> `BTYP_tuple (map f ts)
  | `BTYP_sum ts -> `BTYP_sum (map f ts)
  | `BTYP_function (a,b) -> `BTYP_function (f a, f b)
  | `BTYP_pointer t->  `BTYP_pointer (f t)
  | `BTYP_binding (a,b) -> `BTYP_binding (f a, f b)
  | x -> x

let map_btype f = function
  | `BTYP_apply (a,b) -> `BTYP_apply (f a, f b)
  | `BTYP_typefun (its, a, b) ->
     `BTYP_typefun (map (fun (i,t) -> i, f t) its, f a , f b)
  | `BTYP_type_tuple ts -> `BTYP_type_tuple (map f ts)
  | x -> map_b0type f x

let iter_b0type f = function
  | `BTYP_inst (i,ts) -> iter f ts
  | `BTYP_tuple ts -> iter f ts
  | `BTYP_sum ts -> iter f ts
  | `BTYP_function (a,b) -> f a; f b
  | `BTYP_pointer t->  f t
  | `BTYP_binding (a,b) -> f a; f b
  | x -> ()

let iter_btype f = function
  | `BTYP_apply (a,b) -> f a; f b
  | `BTYP_typefun (its, a, b) ->
     iter (fun (i,t) -> f t) its; f a; f b

  | `BTYP_type_tuple ts -> iter f ts
  | x -> iter_b0type f x

@head(1,'Routines to extract source reference from terms')
Source reference manipulators.
@h = tangler('src/flx_srcref.mli')
@select(h)
open Flx_ast
val rstoken: srcref -> srcref -> range_srcref
val rsrange: range_srcref -> range_srcref -> range_srcref
val slift: srcref -> range_srcref

val rsexpr: expr_t -> expr_t -> range_srcref
val rslist: expr_t list -> range_srcref

val src_of_expr: expr_t -> range_srcref
val src_of_stmt : statement_t -> range_srcref
val src_of_pat : pattern_t -> range_srcref
val src_of_qualified_name : qualified_name_t -> range_srcref
val src_of_suffixed_name: suffixed_name_t -> range_srcref

val short_string_of_src: range_srcref -> string
val long_string_of_src: range_srcref -> string

@h = tangler('src/flx_srcref.ml')
@doc()
Generic source reference manipulation.
Note the special hack of forgetting the second
filename when creating a range: the alternative
would be to record a complete list of lines.
@select(h)
(* get source range from source references of first
   and last tokens 
*)
let rstoken (f1,l1,s1,e1) (f2,l2,s2,e2) = (f1,l1,s1,l2,e2)

(* get range from first and last ranges *)
let rsrange (f1,sl1,sc1,el1,ec1) (f2,sl2,sc2,el2,ec2) =
  (f1,sl1,sc1,el2,ec2)

(* lift token source to range *)
let slift (f,l,s,e) = (f,l,s,l,e)

(* axiom: rstoken a b = rsrange (lift a) (lift b) *)

@doc()
Type specific operations.
@select(h)
open Flx_util
open Flx_ast
open Flx_types
let src_of_qualified_name (e : qualified_name_t) = match e with
  | `AST_void s 
  | `AST_name  (s,_,_) 
  | `AST_case_tag (s,_)
  | `AST_typed_case (s,_,_)
  | `AST_lookup (s,_)
    -> s

let src_of_suffixed_name (e : suffixed_name_t) = match e with
  | #qualified_name_t as x -> src_of_qualified_name x
  | `AST_suffix (s,_) 
    -> s

let src_of_expr (e : expr_t) = match e with
  | #suffixed_name_t as x -> src_of_suffixed_name x
  | `AST_noexpand (s,_)
  | `AST_product (s,_)
  | `AST_sum (s,_)
  | `AST_arrow (s,_)

  | `AST_apply  (s,_) 
  | `AST_deref (s,_) 
  | `AST_ref  (s,_) 
  | `AST_literal  (s,_) 
  | `AST_method_apply  (s,_) 
  | `AST_tuple  (s,_) 
  | `AST_dot  (s,_) 
  | `AST_lambda  (s,_) 
  | `AST_match_ctor  (s,_) 
  | `AST_match_case (s,_)
  | `AST_ctor_arg  (s,_) 
  | `AST_case_arg  (s,_) 
  | `AST_get_n  (s,_) 
  | `AST_coercion (s,_)
  | `AST_as (s,_)
  | `AST_match (s, _) 
  | `AST_regmatch (s, _) 
  | `AST_reglex (s, _) 
  | `AST_typeof (s, _) 
  | `AST_cond (s,_)
  | `AST_letin (s,_)

  | `AST_bound_module (s,_)
    -> s

let src_of_stmt e = match e with
  | `AST_interface (s,_,_,_)
  | `AST_module_binding (s,_,_,_)
  | `AST_typed_functor (s,_,_,_,_,_)
  | `AST_untyped_functor (s,_,_,_,_)
  | `AST_label (s,_)
  | `AST_goto (s,_)
  | `AST_function (s,_, _, _ , _, _)
  | `AST_name_macro (s, _,_)
  | `AST_expr_macro (s,_, _,_)
  | `AST_stmt_macro (s,_, _,_)
  | `AST_macro_val (s,_,_)
  | `AST_macro_var (s, _,_)
  | `AST_macro_assign (s,_,_)
  | `AST_macro_forget (s,_)
  | `AST_macro_label (s,_)
  | `AST_macro_goto (s,_)
  | `AST_macro_ifgoto (s,_,_)
  | `AST_macro_proc_return s

  | `AST_val_decl (s,_,_,_,_) 
  | `AST_var_decl (s,_,_,_,_) 
 

  | `AST_type_alias (s,_,_,_) 
  | `AST_nop (s, _) 

  | `AST_call (s, _, _ ) 
  | `AST_jump (s, _, _ ) 
  | `AST_loop (s, _, _ ) 
  | `AST_read (s, _) 
  | `AST_fun_return (s, _) 
  | `AST_proc_return s 
  | `AST_ifgoto (s,_,_)
  | `AST_ifnotgoto (s,_,_)
  | `AST_abs_decl (s,_,_, _) 
  | `AST_const_decl (s,_,_,_,_) 
  | `AST_fun_decl (s,_,_,_,_,_ ) 
  | `AST_proc_decl (s,_,_,_,_ ) 
  | `AST_header (s,_) 
  | `AST_body (s,_) 
  | `AST_code (s, _) 
  | `AST_noreturn_code (s, _) 
  | `AST_union (s, _,_, _ ) 
  | `AST_struct (s,_, _, _)
  | `AST_typed_module (s,_, _,_,_)
  | `AST_untyped_module (s,_,_,_)
  | `AST_export (s, _,_)
  | `AST_function_decl (s,_,_,_)
  | `AST_type (s,_,_)
  | `AST_open (s,_)
  | `AST_include (s,_)
  | `AST_use (s,_,_)
  | `AST_regdef (s,_,_)
    -> s
  | `AST_comment _ 
    -> ("Generated",0,0,0,0)

let src_of_pat e = match e with
  | `PAT_nan s
  | `PAT_int (s,_,_)
  | `PAT_string (s, _)
  | `PAT_int_range (s,_,_,_,_)
  | `PAT_string_range (s, _, _)
  | `PAT_float_range (s, _,_)
  | `PAT_name (s, _)
  | `PAT_tuple (s, _)
  | `PAT_any s
  | `PAT_regexp (s, _, _ )
  | `PAT_const_ctor (s, _)
  | `PAT_nonconst_ctor (s, _, _)
  | `PAT_as (s, _, _)
  | `PAT_when (s, _, _)
    -> s

(* get range from first and last expressions *)
let rsexpr a b = rsrange (src_of_expr a) (src_of_expr b)

(* get source range of non-empty list of expressions *)
let rslist lst = 
  rsexpr (List.hd lst) (list_last lst)


let short_string_of_src (f,l1,c1,l2,c2) =
  if l1 = l2 
  then
    f ^ ": line " ^ si l1 ^ 
    ", cols " ^ si c1 ^ " to " ^ si c2
  else
    f ^ ": line " ^ si l1 ^ 
    " col " ^ si c1 ^ " to " ^ 
    " line " ^ si l2 ^ " col " ^ si c2

let get_lines f context l1' l2' c1 c2 = (* first line is line 1 *)
  let l1 = max 1 (l1'-context) in
  let l2 = l2' + context in
  let n = String.length (si l2) in
  let fmt i = 
    let s ="    " ^ si i in
    let m = String.length s in
    String.sub s (m-n) n
  in
  try
    let buf = Buffer.create ((l2-l1+4) * 80) in
    let spc () = Buffer.add_char buf ' ' in
    let star() = Buffer.add_char buf '*' in
    let nl() = Buffer.add_char buf '\n' in
    let f = open_in f in
    for i = 1 to l1-1 do ignore(input_line f) done;
    begin
      try
        for i = l1 to l2 do 
          Buffer.add_string buf (fmt i ^": ");
          begin
            try
              Buffer.add_string buf (input_line f)
            with _ -> 
              Buffer.add_string buf "<eof>\n"; 
              raise Not_found
          end
          ;
          nl();
          if i = l1' && l1' = l2' then
          begin
            for i = 1 to n + 2 do spc() done;
            for i = 1 to c1 - 1 do spc() done;
            for i = c1 to c2 do star() done;
            nl()
          end
        done
      with Not_found -> ()
    end
    ;
    close_in f;
    Buffer.contents buf
  with _ -> 
    "*** Can't read file " ^ f ^ 
    " lines " ^ fmt l1 ^ " thru " ^ fmt l2 ^ "\n"

let long_string_of_src (f,l1,c1,l2,c2) =
  short_string_of_src (f,l1,c1,l2,c2) ^
  "\n" ^
  get_lines f 1 l1 l2 c1 c2

@head(1,'Print module')
Routines to print various terms.
@h = tangler('src/flx_print.mli')
@select(h)
open Flx_ast
open Flx_types
val string_of_typecode : typecode_t -> string
val string_of_btypecode : symbol_table_t -> btypecode_t -> string
val special_string_of_typecode : typecode_t -> string
val string_of_expr : expr_t -> string
val string_of_bound_expression : 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val string_of_pattern : pattern_t -> string
val string_of_literal : literal_t -> string
val string_of_parameters : parameter_t list -> string
val string_of_arguments : expr_t list -> string
val string_of_statement : int -> statement_t -> string
val string_of_compilation_unit : compilation_unit_t -> string
val string_of_desugared : asm_t list -> string
val string_of_suffixed_name : suffixed_name_t -> string
val string_of_qualified_name : qualified_name_t -> string
val string_of_dcl : int -> id_t -> id_t list -> dcl_t -> string
val string_of_bexe : symbol_table_t -> int -> bexe_t -> string
val string_of_exe : int -> exe_t -> string
val qualified_name_of_index : symbol_table_t -> int -> string
val string_of_bbdcl : 
  symbol_table_t -> 
  bbdcl_t -> 
  int -> 
  string

val string_of_symdef : 
  symbol_definition_t -> string -> vs_list_t ->
  string

val string_of_entry_kind:
  entry_kind_t -> string

val string_of_entry_set:
  entry_set_t -> string

@h = tangler('src/flx_print.ml')
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_srcref
open Big_int
open Flx_typing
open List

let rec string_of_string s = Flx_string.c_quote_of_string s

let string_of_char c =
  if c = -1 then "<<EOF>>" else
  if c < 32 || c > 126
  then "\\x" ^ Flx_string.hex2 c
  else String.make 1 (Char.chr c)


let suffix_of_type s = match s with
  | "tiny" -> "t"
  | "short" -> "s"
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "v"
  | "utiny" -> "tu"
  | "ushort" -> "su"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "vu"
  | "int8" -> "i8"
  | "int16" -> "i16"
  | "int32" -> "i32"
  | "int64" -> "i64"
  | "uint8" -> "u8"
  | "uint16" -> "u16"
  | "uint32" -> "u32"
  | "uint64" -> "u64"
  | "float" -> "f"
  | "double" -> ""
  | "ldouble" -> "l"
  | _ -> failwith ("[suffix_of_type] Unexpected Type " ^ s)

 
let string_of_literal e = match e with
  | `AST_int (s,i) -> (string_of_big_int i)^suffix_of_type s 
  | `AST_float (t,v) -> v ^ suffix_of_type t
  | `AST_string s -> string_of_string s
  | `AST_wstring s -> string_of_string s
  | `AST_ustring s -> string_of_string s
  
let rec string_of_qualified_name (n:qualified_name_t) =
  let se e = string_of_expr e in
  match n with
  | `AST_void _ -> "void"
  | `AST_name (_,name,ts) -> name ^ 
    (
      if List.length ts = 0 then "" 
      else "[" ^ catmap ", " string_of_typecode ts ^ "]"
    )
  | `AST_case_tag (_,v) -> "case " ^ si v
  | `AST_typed_case (_,v,t) -> 
    "(case " ^ si v ^ 
    " of " ^ string_of_typecode t ^ ")"

  | `AST_lookup (_,(e,name, ts)) -> "("^se e ^")::" ^ name ^
    (if length ts = 0 then "" else
    "[" ^ catmap ", " string_of_typecode ts ^ "]"
    )

and string_of_suffixed_name (n:suffixed_name_t) =
  match n with
  | #qualified_name_t as n -> string_of_qualified_name n
  | `AST_suffix (_,(name,suf)) ->
    string_of_qualified_name name ^ " of (" ^ string_of_typecode suf ^ ")"

and string_of_re re =
  match re with
  | REGEXP_seq (r1,r2) -> string_of_re r1 ^ " " ^ string_of_re r2
  | REGEXP_alt (r1,r2) -> string_of_re r1 ^ " | " ^ string_of_re r2
  | REGEXP_aster r -> "(" ^ string_of_re r ^ ")*"
  | REGEXP_name s -> string_of_qualified_name s
  | REGEXP_string s ->
    let ss=Buffer.create (String.length s) in
    Buffer.add_char ss '"';
    for i = 0 to String.length s - 1 do
      Buffer.add_string ss (string_of_char (Char.code s.[i]))
    done;
    Buffer.add_char ss '"';
    Buffer.contents ss


  | REGEXP_epsilon -> "epsilon"
  | REGEXP_sentinel -> "sentinel"
  | REGEXP_code e -> "<CODE " ^ string_of_expr e ^ ">"

and string_of_expr (e:expr_t) = 
  let se e = string_of_expr e 
  and sme e = string_of_expr e 
  and sqn e = string_of_qualified_name e
  in
  match e with
  | #suffixed_name_t as n -> string_of_suffixed_name n
  | `AST_noexpand (sr,e) -> "$(" ^ string_of_expr e ^ ")"

  | `AST_letin (sr,(pat,e1, e2)) ->
    "let " ^ string_of_letpat pat ^ " = " ^ se e1 ^ " in " ^ se e2
  | `AST_bound_module (sr,(iface,impl,binding)) -> "(module_binding)"
  | `AST_coercion (_,(e,t)) -> 
    "(" ^ sme e ^ ":" ^ 
    string_of_typecode t ^ ")"

  | `AST_cond (_,(e,b1,b2)) -> 
    "if " ^ se e ^ 
    " then " ^ se b1 ^ 
    " else " ^ se b2 ^ 
    " endif"

  | `AST_typeof (_,e) -> "typeof("^se e^")"
  | `AST_as (_,(e1, name)) -> "(" ^ se e1 ^ ") as " ^ name  
  | `AST_get_n (_,(n,e)) -> "get (" ^ si n ^ ", " ^se e^")"
  | `AST_deref (_,e) -> "*(" ^ se e ^ ")"
  | `AST_ref (_,e) -> "&" ^ "(" ^ se e ^ ")"
  | `AST_literal (_,e) -> string_of_literal e
  | `AST_apply  (_,(fn, arg)) -> "(" ^ 
    sme fn ^ " " ^ 
    sme arg ^ 
    ")"

  | `AST_product (_,ts) ->
     cat "*" (List.map se ts)
  | `AST_sum (_,ts) ->
     cat "+" (List.map se ts)
  | `AST_arrow (_,(a,b)) ->
    "(" ^ se a ^ " -> " ^ se b ^ ")"
    
  | `AST_method_apply  (_,(fn, arg)) -> "(" ^ 
    fn ^ " " ^ 
    se arg ^ 
    ")"

  | `AST_tuple (_,t) -> "(" ^ catmap ", " sme t ^ ")"
  | `AST_dot (_,(e,n)) ->  "get_" ^ n ^ "(" ^ se e ^ ")"

  | `AST_lambda (_,(params,ret, sts)) -> 
    "(fun(" ^ string_of_parameters params ^ ") " ^ 
    (match ret with
    | `TYP_none -> ""
    | _ -> ": " ^string_of_typecode ret) ^ 
    " = " ^
    string_of_compound 0 sts ^ ")"

  | `AST_ctor_arg (_,(cn,e)) ->
    "ctor_arg " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_case_arg (_,(n,e)) ->
    "case_arg " ^ si n ^ "(" ^
    se e ^ ")"

  | `AST_match_ctor (_,(cn,e)) ->
    "match_ctor " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_match_case (_,(v,e)) ->
    "match_case " ^ si v ^ "(" ^
    se e ^ ")"

  | `AST_match (_,(e, ps)) ->
    "match " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_pattern p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_regmatch (_,(e, ps)) ->
    "regmatch " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

  | `AST_reglex (_,(e, ps)) ->
    "reglex " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

(* precedences for type operators ..
   0 -- atomic
   0.5 -- indexing t[i]
   1 -- pointer
   2 -- application
   3 -- *
   4 -- +
   5 -- ->
   6 -- =>
   7    as, all
*)


and st prec tc : string = 
  let iprec,txt =
    match tc with
    | #qualified_name_t as t -> 0,string_of_qualified_name t
    | `TYP_none -> 0,"<none>"
    | `TYP_var i -> 0,"<var " ^ si i ^ ">"
    | `TYP_tuple ls ->
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 3, cat " * " (List.map (st 3) ls)
      end

    | `TYP_sum ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | _ -> 4,cat " * " (List.map (st 4) ls)
      end

    | `TYP_function (args, result) ->  
      5,st 5 args ^ " -> " ^ st 5 result

    | `TYP_pointer t -> 1,"&" ^ st 1 t
    
    | `TYP_typeof e -> 0,"typeof(" ^ string_of_expr e ^ ")"
    | `TYP_as (t,s) -> 7,st 7 t ^ " as " ^ s

    | `TYP_proj (i,t) -> 2,"proj_"^si i^" "^ st 2 t
    | `TYP_dom t -> 2,"dom "^ st 2 t
    | `TYP_cod t -> 2,"cod "^st 2 t
    | `TYP_case_arg (i,t) -> 2,"case_arg_"^si i^" "^st 2 t

    | `TYP_apply (t1,t2) -> 2,st 2 t1 ^ " " ^ st 2 t2
    | `TYP_type -> 0,"TYPE"
    | `TYP_type_tuple ls ->
      3, cat ", " (List.map (st 3) ls)
    | `TYP_typefun (args,ret,body) -> 
       7,
       (
         "fun(" ^ cat ", " 
         (
           List.map 
           (fun (n,t)-> n ^ ": " ^ st 7 t) 
           args
         ) ^
         "): " ^ st 0 ret ^ "=" ^ st 7 body
       )
  in
    if iprec >= prec 
    then "(" ^ txt ^ ")" 
    else txt

and string_of_typecode tc = st 99 tc

and qualified_name_of_index dfns index = 
  match Hashtbl.find dfns index with 
  (* don't print top level module name at present *)
  | (id,sr,None,vs,_,_,_) -> (* id ^ "<" ^ si index ^ ">" *) ""
  | (id,sr,Some index',vs,_,_,_) -> 
    let prefix = qualified_name_of_index dfns index' in
    (if prefix <> "" then prefix ^ "::" else "")
      ^ id (* ^ "<" ^ si index ^ ">" *)

(* fixppoint labeller .. very sloppy, ignores precedence .. *)
and get_label i =
  if i = 0 then "" 
  else 
    let ch = Char.chr (i mod 26 + Char.code('a')-1) in
    get_label (i/26) ^ String.make 1 ch
  
and print_fixpoints depth fixlist =
  match fixlist with
  | (d,lab) :: t when d = depth -> 
    let txt,lst = print_fixpoints depth t in
    " as " ^ lab ^ " " ^ txt, lst
  | _ -> "", fixlist
  
and sb dfns depth fixlist counter prec tc = 
  let sbt prec t = sb dfns (depth+1) fixlist counter prec t in
    let iprec, term = 
      match tc with
      | `BTYP_fix i ->
         incr counter; (* 'a is 1 anyhow .. *)
         let lab = "fix_" ^ get_label !counter in
         fixlist := (depth+i,lab) :: !fixlist;
         0,lab 

      | `BTYP_binding (a,b) -> 
        6,
        sbt 6 a ^
        " => " ^
        sbt 6 b

      | `BTYP_var i -> 0,"<T" ^ si i ^ ">"
      | `BTYP_inst (i,ts) -> 
        0,qualified_name_of_index dfns i ^ 
        (if List.length ts = 0 then "" else
        "[" ^cat ", " (List.map (string_of_btypecode dfns) ts) ^ "]"
        )

      | `BTYP_name n -> 
        let name = 
          try qualified_name_of_index dfns n
          with Not_found -> "<N" ^ si n^ ">"
        in
        0,name

      | `BTYP_tuple ls -> 
        begin match ls with 
        | [] -> 0,"unit" 
        | [x] -> failwith ("UNEXPECTED TUPLE OF ONE ARGUMENT " ^ sbt 9 x)
        | _ -> 3,cat " * " (List.map (sbt 3) ls)
        end

      | `BTYP_sum ls -> 
        begin match ls with 
        | [] -> 9,"UNEXPECTED EMPTY SUM = void" 
        | [x] -> (* failwith *) (9,"UNEXPECTED SUM OF ONE ARGUMENT " ^ sbt 9 x)
        | _ -> 4,cat " + " (List.map (sbt 4) ls)
        end

      | `BTYP_function (args, result) ->  
        5,(sbt 5 args) ^ " -> " ^ (sbt 5 result)

      | `BTYP_pointer t -> 1,"&" ^ sbt 1 t
      | `BTYP_void -> 0,"void"
      
      | `BTYP_apply (t1,t2) -> 2,sbt 2 t1 ^ " " ^ sbt 2 t2
      | `BTYP_type -> 0,"TYPE"
      | `BTYP_type_tuple ls ->
        3, cat ", " (List.map (sbt 3) ls)

      | `BTYP_typefun (args,ret,body) -> 
         7,
         (
           "fun (" ^ cat ", " 
           (
             List.map 
             (fun (i,t)-> si i ^ ": " ^ sbt 7 t) 
             args
           ) ^
           "): " ^ sbt 0 ret ^ "=" ^ sbt 7 body
         )
    in
      let txt,lst = print_fixpoints depth !fixlist in
      fixlist := lst;
      if iprec >= prec then "(" ^ term ^ txt ^ ")"
      else term ^ txt

and string_of_btypecode (dfns:symbol_table_t) tc = 
  let fixlist = ref [] in
  let term = sb dfns 0 fixlist (ref 0) 99 tc in
  let bad = ref "" in
  while List.length !fixlist > 0 do
    match !fixlist with
    | (d,v)::t ->
      bad := !bad ^ " [Free Fixpoint " ^ si d ^ " " ^ v ^"]";
      fixlist := t
    | [] -> assert false
  done;
  term ^ !bad
  
and string_of_parameters ps = 
  cat 
    ", " 
    (List.map (fun (x,y)-> x ^ ": "^(string_of_typecode y)) ps)

and string_of_iparameters ps = 
  cat 
    ", " 
    (List.map (fun (x,(i,y))-> x ^ "["^si i^"]: "^(string_of_typecode y)) ps)

and string_of_bparameters dfns ps = 
  cat 
    ", " 
    (List.map (fun (x,(i,y))-> x ^ "["^si i^"]: "^(string_of_btypecode dfns y)) ps)

and string_of_arguments ass = 
  catmap ", " string_of_expr ass

 
and string_of_component level (name, typ) = 
   spaces level ^ name ^ ": " ^ (string_of_typecode typ)

and string_of_float_pat = function
  | Float_plus (t,v) -> v ^ t
  | Float_minus (t,v) -> "-" ^ v ^ t
  | Float_inf -> "inf"
  | Float_minus_inf -> "-inf"

and string_of_pattern p = 
  let se e = string_of_expr e in
  match p with
  | `PAT_nan _ -> "NaN"
  | `PAT_int (_,t,i) -> string_of_big_int i ^ suffix_of_type t
  | `PAT_int_range (_,t1,i1,t2,i2) -> 
    string_of_big_int i1 ^ suffix_of_type t1 ^
    " .. " ^ 
    string_of_big_int i2 ^ suffix_of_type t2
    
  | `PAT_string (_,s) -> string_of_string s
  | `PAT_string_range (_,s1, s2) -> 
    string_of_string s1 ^ " .. " ^ string_of_string s2
  | `PAT_float_range (_,x1, x2) -> 
    string_of_float_pat x1 ^ " .. " ^ string_of_float_pat x2
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_pattern ps ^ ")"
  | `PAT_any _ -> "any"
  | `PAT_regexp (_,r,b) -> 
    "regexp " ^ string_of_string r ^
    "(" ^ cat ", " b ^ ")"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_pattern p
  | `PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | `PAT_when (_,p,e) -> "(" ^ string_of_pattern p ^ " when " ^ se e ^ ")"

and string_of_letpat p = 
  match p with
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_letpat ps ^ ")"
  | `PAT_any _ -> "_"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_letpat p
  | `PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | _ -> failwith "unexpected pattern kind in let/in pattern" 
 
and string_of_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_statement (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_compound level ss

and string_of_asm_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_asm (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_asm_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_asm_compound level ss

and special_string_of_typecode ty =  (* used for constructors *)
  match ty with
  | `TYP_tuple [] -> ""
  | _ -> " of " ^ string_of_typecode ty

and special_string_of_btypecode dfns ty =  (* used for constructors *)
  match ty with
  | `BTYP_tuple [] -> ""
  | _ -> " of " ^ string_of_btypecode dfns ty

and string_of_macro_parameter_type = function
  | Expr -> "fun"
  | Ident -> "ident"
  | Stmt -> "proc"
 
and print_vs = function
  | [] -> ""
  | vs -> " [" ^ cat ", " vs ^ "]"

and print_ivs = function
  | [] -> ""
  | vs -> " [" ^ cat ", " (map fst vs) ^ "]"

and print_bvs = function
  | [] -> ""
  | vs -> 
    " [" ^ 
    cat ", " 
    (
      List.map 
      (fun (s,i)-> s^"<"^si i^">" ) 
      vs
    ) ^
    "]"

and print_inst dfns = function
  | [] -> ""
  | ts -> 
    " [" ^ 
    cat ", " 
    (
      List.map (string_of_btypecode dfns) ts 
    ) ^
    "]"

and string_of_statement level s = 
  let se e = string_of_expr e in
  let sqn n = string_of_qualified_name n in
  match s with 
  | `AST_interface (_,name, vs, entries) ->
    spaces level ^
    "interface " ^ name ^ "{\n" ^
    (
      catmap "\n"
      (string_of_statement (level+1))
      entries
    ) ^ "\n" ^
    spaces level ^ "}\n"
    
  | `AST_module_binding (_,name,vs,e) ->
    spaces level ^
    "module " ^ name ^ print_vs vs ^ 
    " = " ^
    se e ^ ";\n";

  | `AST_typed_functor (_,name,vs,ps,res,ss) ->
    spaces level ^ 
    "functor " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_compound level ss

  | `AST_untyped_functor (_,name,vs,ps,ss) ->
    spaces level ^ 
    "functor " ^ name ^ 
    "("^ (string_of_parameters ps)^")\n" ^
    string_of_compound level ss


  | `AST_export (_,flx_name,cpp_name) -> 
    spaces level ^ 
    "export " ^ 
    string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `AST_label (_,s) -> s ^ ":"
  | `AST_goto (_,s) -> spaces level ^ "goto " ^ s ^ ";"

  | `AST_comment s -> spaces level ^ "// " ^ s

  | `AST_open (_,n) -> 
    spaces level ^ "open " ^ sqn n ^ ";"

  | `AST_include (_,s) -> 
    spaces level ^ "include " ^ s ^ ";"
  
  | `AST_use (_,n,qn) -> 
    spaces level ^ "use " ^ n ^ " = " ^ sqn qn ^ ";"
  
  | `AST_regdef (_,n,r) -> 
    spaces level ^ "regdef " ^ n ^ " = " ^string_of_re r^";"
  

  | `AST_type_alias (_,t1,vs,t2) ->
    spaces level ^ "type " ^ t1 ^ print_vs vs ^
    " = " ^ 
    string_of_typecode t2 ^ ";"

  | `AST_type (_,t,vs) ->
    spaces level ^ "type " ^ t ^ ";"

  | `AST_untyped_module (_,name, vs,sts)  -> 
    spaces level ^ "module " ^ name ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts

  | `AST_typed_module (_,name, vs,typ, sts)  -> 
    spaces level ^ "module " ^ name ^ ":" ^ 
    string_of_typecode typ ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts

  | `AST_struct (_,name, vs, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_union (_,name, vs,cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^ name ^ special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_abs_decl (_,t,vs, code) -> spaces level ^ 
   "type " ^ t ^ print_vs vs ^
   " = " ^ string_of_string code ^ ";"

  | `AST_fun_decl (_,name,vs,args, result, code) ->
    spaces level ^ 
    "fun " ^ name ^ print_vs vs ^
    ": " ^ 
    (string_of_typecode (`TYP_tuple args)) ^ " -> " ^
    (string_of_typecode result) ^ 
    " = " ^ string_of_string code ^ ";"

  | `AST_proc_decl (_,name,vs,args, code) ->
    spaces level ^ 
    "proc " ^ name ^ print_vs vs ^
    ": " ^ 
    (string_of_typecode (`TYP_tuple args)) ^
    " = " ^ string_of_string code ^ ";"

  | `AST_const_decl (_,name,vs,typ, code) ->
    spaces level ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ 
     ";" 

  | `AST_header (_,s) -> let triple_quote = "\"\"\"" in
    "header \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
    ";\n"

  | `AST_body (_,s) -> let triple_quote = "\"\"\"" in
    "body \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
    ";\n"

  | `AST_code (_,s) -> let triple_quote = "\"\"\"" in
    "code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
    ";\n"

  | `AST_noreturn_code (_,s) -> let triple_quote = "\"\"\"" in
    "noreturn_code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote ^
    ";\n"

  | `AST_function (_,name, vs, ps, res, ss) -> 
    spaces level ^ 
    "function " ^ name ^ print_vs vs ^ 
    "("^string_of_parameters ps^"): "^string_of_typecode res^"\n" ^
    string_of_compound level ss

  | `AST_macro_val (_,name, e) ->
    spaces level ^ 
    "macro val " ^ name ^ " = " ^
    se e ^
    ";"

  | `AST_macro_var (_,name, e) ->
    spaces level ^ 
    "macro var " ^ name ^ " = " ^
    se e ^
    ";"

  | `AST_macro_assign (_,name, e) ->
    spaces level ^ 
    "macro " ^ name ^ " = " ^
    se e ^
    ";\n"

  | `AST_name_macro (_,lname, rname) ->
    spaces level ^ 
    "macro ident " ^ lname ^ " = " ^
    (match rname with | "" -> "new" | _ -> rname) ^
    ";"
    

  | `AST_expr_macro (_,name, ps, e) -> 
    let sps = 
      List.map 
      (fun (p,t) -> p ^ ":" ^ string_of_macro_parameter_type t) 
      ps 
    in
    spaces level ^ 
    "macro fun " ^ name ^ 
    "("^ cat ", " sps ^") = " ^
    se e ^
    ";"

  | `AST_stmt_macro (_,name, ps, ss) -> 
    let sps = 
      List.map 
      (fun (p,t) -> p ^ ":" ^ string_of_macro_parameter_type t) 
      ps 
    in
    spaces level ^ 
    "macro proc " ^ name ^ 
    "("^ cat ", " sps ^") " ^
    short_string_of_compound level ss

  | `AST_macro_forget (_,names) ->
    spaces level ^ 
    "macro forget" ^
    (
      match names with
      | [] -> ""
      | _ -> " "
    ) ^
    cat ", " names ^ 
    ";"

  | `AST_macro_label (_,id) ->
    "macro " ^ id ^ ":>\n"

  | `AST_macro_goto (_,id) ->
    "macro goto " ^ id ^ ";\n"

  | `AST_macro_ifgoto (_,e,id) ->
    "macro if "^se e^" goto " ^ id ^ ";\n"

  | `AST_macro_proc_return (_) ->
    "macro return;\n"

  | `AST_function_decl (_,name,vs,t) ->
    spaces level ^
    "function " ^ name ^ ": " ^ string_of_typecode t ^ ";\n"

  | `AST_val_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "val " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_var_decl (_,name, vs,ty, value) ->
    spaces level ^ 
    "var " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"


  | `AST_call (_,pr, args) ->
    spaces level
    ^ "call " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_jump (_,pr, args) ->
    spaces level
    ^ "call " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_loop (_,pr, args) ->
    spaces level
    ^ "call " ^ pr ^ " " ^ se args ^ ";"

  | `AST_nop (_,s) -> spaces level ^ "{/*"^s^"*/;}"

  | `AST_ifgoto (_,e,lab) ->
    spaces level ^
    "if("^string_of_expr e^")goto " ^ lab
    
  | `AST_ifnotgoto (_,e,lab) ->
    spaces level ^
    "if not("^string_of_expr e^")goto " ^ lab

  | `AST_fun_return (_,e) -> 
    spaces level ^ "return " ^ (se e) ^ ";"

  | `AST_proc_return _ -> 
    spaces level ^ "return;"
    
  | `AST_read (_,name) ->
    spaces level ^ "read " ^ name ^ ";"

and string_of_compilation_unit stats =
  catmap "\n" (string_of_statement 0) stats

and string_of_desugared stats =
  catmap "\n" (string_of_asm 0) stats
  
and string_of_iface level s =
  let spc = spaces level in
  match s with
  | `IFACE_export (flx_name,cpp_name) -> 
    spc ^ "export " ^ string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

and string_of_symdef (entry:symbol_definition_t) name (vs:vs_list_t) 
= match entry with
  | `SYMDEF_header s -> 
    "header " ^ string_of_string s ^ ";\n"
    
  | `SYMDEF_body s -> 
    "body " ^ string_of_string s ^ ";\n"

  | `SYMDEF_regdef re ->
    "regexp " ^ name ^ " = " ^ string_of_re re ^ ";\n"

  | `SYMDEF_type_alias t -> 
    "typedef " ^ name ^ print_ivs vs ^" = " ^ string_of_typecode t ^ ";"
  
  | `SYMDEF_abs (code) ->
    "type " ^ name ^ print_ivs vs ^
    " = " ^ string_of_string code ^ ";"

  | `SYMDEF_var (t) -> 
    "var " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_val (t) -> 
    "val " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_parameter (t) -> 
    "parameter " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_typevar (t) -> 
    "typevar " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ ";"

  | `SYMDEF_const (t,ct) -> 
    "const " ^ name ^ print_ivs vs ^":"^ string_of_typecode t ^ " = '" ^ct^"';"
    
  | `SYMDEF_union (cts) -> 
    "union " ^ name ^ print_ivs vs ^ ";"

  | `SYMDEF_struct (cts) -> 
    "struct " ^ name ^ print_ivs vs ^ ";"
    
  | `SYMDEF_fun (pts,res,cts) -> 
    "fun " ^ name ^ print_ivs vs ^
    ": " ^ string_of_typecode 
    (
      `TYP_function 
      (
        (
          match pts with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    ";"
 
  | `SYMDEF_function (ps,res,es) -> 
    "function " ^ name ^ print_ivs vs ^
    ": " ^ string_of_typecode 
    (
      `TYP_function 
      (
        (
          match List.map snd ps with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    ";"
    
  | `SYMDEF_match_check (pat,i)-> 
    "match_check " ^ name ^ " for " ^ string_of_pattern pat ^ ";"
  
  | `SYMDEF_interface ->
    "interface " ^ name ^ ";"

  | `SYMDEF_typed_functor (ps,ret,es) ->
    "functor " ^ name ^ ";"

  | `SYMDEF_untyped_functor (ps,es) ->
    "functor " ^ name ^ ";"

  | `SYMDEF_module -> 
    "module " ^ name ^ ";"
    
  | `SYMDEF_if_type -> 
    "abstract_type " ^ name ^ ";"
    
  | `SYMDEF_if_fun (t) ->
    "abstract_function  " ^ name ^ string_of_typecode t ^ ";"

  | `SYMDEF_module_binding e ->
    "module_binding " ^ string_of_expr e ^ ";"

and string_of_exe level s = 
  let spc = spaces level
  and se e = string_of_expr e 
  in
  match s with
  | `EXE_regmatch (e,cls) ->
    spc ^
    "regmatch " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    cls 
    ^
    " endmatch;"

  | `EXE_reglex (e,cls) ->
    spc ^
    "reglex " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_re p ^
      " => " ^
      string_of_expr e'
    )
    cls 
    ^
    " endmatch;"


  | `EXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | `EXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `EXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `EXE_label s -> s ^ ":"

  | `EXE_comment s -> spc ^ 
    "// " ^ s 

  | `EXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_jump (p,a) -> spc ^ 
    "jump " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_loop (p,a) -> spc ^ 
    "loop " ^ 
    p ^ " " ^ 
    se a ^ ";"

  | `EXE_read v -> spc ^ 
    "read " ^ v

  | `EXE_fun_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | `EXE_proc_return -> spc ^ 
    "return;"

  | `EXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | `EXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | `EXE_noreturn_code s -> spc ^ 
    "noreturn_code " ^ string_of_string s 

  | `EXE_init (l,r) -> spc ^ 
    l ^ " := " ^ se r ^ ";"

and string_of_bound_expression dfns e = 
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match fst e with
   
  | `BEXPR_coercion (m,t) -> 
    "(" ^ 
    se m ^ 
    ": " ^
    string_of_btypecode dfns t ^ 
    ")"
  | `BEXPR_get_n (n,e') -> "(" ^ se e' ^ ").mem_" ^ si n

  | `BEXPR_deref e -> "*("^ se e ^ ")"
  | `BEXPR_name (i,ts) -> sid i ^ print_inst dfns ts
  | `BEXPR_closure (i,ts) -> "cls " ^ sid i ^ print_inst dfns ts
  | `BEXPR_ref (i,ts) -> "&" ^ sid i ^ print_inst dfns ts

  | `BEXPR_literal e -> string_of_literal e
  | `BEXPR_apply  (fn, arg) -> "(" ^ 
    se fn ^ " " ^ 
    se arg ^ 
    ")"

  | `BEXPR_tuple t -> "(" ^ catmap ", " se t ^ ")"
  | `BEXPR_dot (e,n) ->  "get_<" ^ si n ^ ">(" ^ se e ^ ")"
  | `BEXPR_case (v,t) -> 
    "case " ^ si v ^ " of " ^ string_of_btypecode dfns t

  | `BEXPR_match_case (v,e) -> 
    "(match case " ^ si v ^ ")(" ^ se e ^ ")"
  | `BEXPR_case_arg (v,e) ->
    "(arg of case " ^ si v ^ " of " ^ se e ^ ")"

and string_of_biface dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BIFACE_export (index,cpp_name) ->
    spc ^ "export " ^ qualified_name_of_index dfns index ^ 
    " as \"" ^ cpp_name ^ "\";"

and string_of_bexe dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BEXE_regmatch (e,alphabet, nstates, termcodes,matrix) -> 
    spc ^ "regmatch " ^ se e ^ " with " ^
    "<TRANSITION MATRIX of "^si nstates^" states> " ^
    "endmatch;"

  | `BEXE_reglex (e,alphabet, nstates, termcodes,matrix) -> 
    spc ^ "reglex " ^ se e ^ " with " ^
    "<TRANSITION MATRIX of "^si nstates^" states> " ^
    "endmatch;"

  | `BEXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | `BEXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `BEXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `BEXE_label s -> s ^ ":"

  | `BEXE_comment s -> spc ^ 
    "// " ^ s 

  | `BEXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_jump (p,a) -> spc ^ 
    "tail call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_loop (p,a) -> spc ^ 
    "loop<" ^ 
    si p ^ "> " ^ 
    se a ^ ";"

  | `BEXE_read v -> spc ^ 
    "read " ^ sid v 

  | `BEXE_fun_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | `BEXE_proc_return -> spc ^ 
    "return;"

  | `BEXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | `BEXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | `BEXE_init (l,r) -> spc ^ 
    sid l ^ " := " ^ se r ^ ";"

and string_of_dcl level name vs (s:dcl_t) = 
  let se e = string_of_expr e in
  match s with
  | `DCL_regdef re -> 
    spaces level ^ "regexp " ^ name ^ " = " ^ string_of_re re ^ ";\n"

  | `DCL_type -> spaces level ^ "type " ^ name ^ print_vs vs ^ ";\n"

  | `DCL_if_fun (t) ->
    spaces level ^ "function " ^ name ^ print_vs vs ^ ": " ^ string_of_typecode t
  
  | `DCL_module_binding expr -> 
    spaces level ^
    "module " ^ name ^ " = "^se expr^" ;\n"

  | `DCL_header s -> "header " ^ string_of_string s
  | `DCL_body s -> "body " ^ string_of_string s

  | `DCL_type_alias (t2) ->
    spaces level ^ "typedef " ^ name ^ print_vs vs ^
    " = " ^ string_of_typecode t2 ^ ";"

  | `DCL_module (asms) -> 
    spaces level ^ "module " ^ name ^ print_vs vs ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms 

  | `DCL_interface (asms) ->
    spaces level ^ "interface " ^ name ^ print_vs vs ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms


  | `DCL_struct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name ^ print_vs vs ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_union (cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^name ^ special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name ^ print_vs vs ^
    " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_abs (code) -> spaces level ^ 
    "type " ^ name ^ print_vs vs ^
    " = " ^ string_of_string code ^ ";"

  | `DCL_fun (args, result, code) ->
    let argtype:typecode_t = type_of_argtypes args in
    let t:typecode_t = `TYP_function (argtype,result) in
    spaces level ^ 
    "fun " ^ name ^ print_vs vs ^
    ": " ^ string_of_typecode t ^
    " = " ^ string_of_string code ^ ";"

  | `DCL_const (typ, code) ->
    spaces level ^ 
     "const " ^ name ^print_vs vs ^  
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ ";" 

  | `DCL_function (ps, res, ss) -> 
    spaces level ^ 
    "function " ^ name ^ print_vs vs ^
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_asm_compound level ss

  | `DCL_typed_functor (ps, res, ss) ->
    spaces level ^ 
    "functor " ^ name ^print_vs vs ^  
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_asm_compound level ss

  | `DCL_untyped_functor (ps, ss) ->
    spaces level ^ 
    "functor " ^ name ^ print_vs vs ^
    "("^ (string_of_parameters ps)^")\n" ^
    string_of_asm_compound level ss


  | `DCL_match_check (pat,s) ->
    spaces level ^ 
    "function " ^ name ^ "() { " ^ 
    s ^ " matches " ^ string_of_pattern pat ^
    " }"

  | `DCL_match_handler (pat,varname, sts) ->
    spaces level ^ 
    "match_handler " ^ name ^ 
    "(" ^ string_of_pattern pat ^ ")" ^
    string_of_asm_compound level sts

  | `DCL_val (ty) ->
    spaces level ^ 
    "val " ^ name ^ print_vs vs ^ ": " ^ string_of_typecode ty ^ ";"

  | `DCL_var (ty) ->
    spaces level ^ 
    "var " ^ name ^ print_vs vs ^ ": " ^ string_of_typecode ty ^ ";"

and string_of_asm level s =
  match s with
  | Dcl (sr,name,vs, d) -> string_of_dcl level name vs d
  | Exe (sr,s) -> string_of_exe level s
  | Iface (sr,s) -> string_of_iface level s
  | Dir (sr,s) -> string_of_dir level s

and string_of_dir level s =
  let sqn n = string_of_qualified_name n in
  match s with
  | DIR_open qn ->
    spaces level ^ "open " ^ sqn qn ^ ";"

  | DIR_use (n,qn) ->
    spaces level ^ "use " ^ n ^ " = " ^ sqn qn ^ ";"

and string_of_bbdcl dfns bbdcl index = 
  let name = qualified_name_of_index dfns index in
  let sobt t = string_of_btypecode dfns t in
  let se e = string_of_bound_expression dfns e in
  match bbdcl with
  | `BBDCL_header s -> "header " ^ string_of_string s
  | `BBDCL_body s -> "body " ^ string_of_string s

  | `BBDCL_function (vs,ps,res,es,name_map) ->
    "function " ^ name ^ print_bvs vs ^
    "("^ (string_of_bparameters dfns ps)^"): "^(sobt res) ^
    "{\n" ^
    cat "\n" (List.map (string_of_bexe dfns 1) es) ^
    "}"

  
  | `BBDCL_procedure (vs,ps,es,name_map) ->
    "procedure " ^ name ^ print_bvs vs ^
    "("^ (string_of_bparameters dfns ps)^")" ^
    "{\n" ^
    cat "\n" (List.map (string_of_bexe dfns 1) es) ^
    "}"

  | `BBDCL_val (vs,ty) ->
    "val " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  | `BBDCL_var (vs,ty) ->
    "var " ^ name ^ print_bvs vs ^ ": " ^ sobt ty ^ ";"

  (* binding structures [prolog] *)
  | `BBDCL_abs (vs,code) ->
   "type " ^ name ^  print_bvs vs ^
   " = " ^ string_of_string code ^ ";"

  | `BBDCL_const (vs,ty,code) ->
     "const " ^ name ^ print_bvs vs ^    
     ": " ^ sobt ty ^ 
     " = "^string_of_string code^ ";" 

  | `BBDCL_fun (vs,ps,rt,code) ->
    "fun " ^ name ^ print_bvs vs ^
    ": " ^ 
    (sobt (typeoflist ps)) ^ " -> " ^
    (sobt rt) ^ 
    " = " ^ string_of_string code ^ ";"

  | `BBDCL_proc (vs, ps,code) ->
    "proc " ^ name ^ print_bvs vs ^
    ": " ^ 
     (sobt (typeoflist ps)) ^
     " = " ^ string_of_string code ^ ";"

  | `BBDCL_union (vs,cs) ->
    let string_of_union_component (name,ty) =
      "  " ^ "|" ^name ^ special_string_of_btypecode dfns ty
    in
    "union " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    "}"

  | `BBDCL_struct (vs,cs) ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "struct " ^ name ^ print_bvs vs ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"

let string_of_entry_kind = function 
  | Simple i -> si i
  | Bound (i,j) -> "("^si i^","^si j^")"

let string_of_entry_set = function
  | NonFunctionEntry x -> string_of_entry_kind x
  | FunctionEntry ls -> 
    "{" ^
      catmap "," string_of_entry_kind ls ^
    "}"

@h = tangler('src/flx_mtypes.ml')
@select(h)
module VarMap = Map.Make(struct type t = string let compare = compare end);;
type varmap_t = string VarMap.t

module TypecodeSet = Set.Make(
  struct type t = Flx_ast.typecode_t let compare = compare end
)
type typecodeset_t = TypecodeSet.t

let typecodeset_of_list x = 
  let rec tsol x = match x with
  | h :: t -> TypecodeSet.add h (tsol t)
  | [] -> TypecodeSet.empty
  in tsol x

let typecodeset_map f x = typecodeset_of_list (List.map f (TypecodeSet.elements x))

(* for regular expressions *)

(* PosSet -- set of positions in regular expression, used for followpos *)
module PosSet = Set.Make (struct type t = int let compare=compare end);;

(* set of PosSet's *)
module PosSetSet = Set.Make (struct type t = PosSet.t let compare=compare end);;

(* character set [char type is 'int'] *)
module CharSet = Set.Make (struct type t = int let compare=compare end);;


@h = tangler('src/flx_mtypes.mli')
@select(h)
module VarMap :
  sig
    type key = string
    and 'a t
    val empty : 'a t
    val add : key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val mem : key -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  end
type varmap_t = string VarMap.t
module TypecodeSet :
  sig
    type elt = Flx_ast.typecode_t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end
type typecodeset_t = TypecodeSet.t
val typecodeset_of_list : TypecodeSet.elt list -> TypecodeSet.t
val typecodeset_map :
  (TypecodeSet.elt -> TypecodeSet.elt) -> TypecodeSet.t -> TypecodeSet.t

module PosSet :
  sig
    type elt = int
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end
module PosSetSet :
  sig
    type elt = PosSet.t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end
module CharSet :
  sig
    type elt = int
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end

@head(1,'Compile time exceptions')
@python('//')
exceptions = """
exception SyntaxError of string
exception ParseError of string
exception LexError of string
exception TokenError of string
exception ClientError of range_srcref * string
exception ClientError2 of range_srcref * range_srcref * string
exception SystemError of range_srcref * string
exception Exit of int
"""
//
@h = tangler('src/flx_exceptions.ml')
@select(h)
open Flx_ast
@tangle(exceptions)
let clierr2 sr sr2 s = raise (ClientError2 (sr,sr2,s))
let clierr sr s = raise (ClientError (sr,s))
let syserr sr s = raise (SystemError (sr,s))
let catch s f = try f() with _ -> failwith s

@h = tangler('src/flx_exceptions.mli')
@select(h)
open Flx_ast
@tangle(exceptions)
val clierr: range_srcref -> string -> 'a
val clierr2: range_srcref -> range_srcref -> string -> 'a
val syserr: range_srcref -> string -> 'a
val catch: string -> (unit -> 'a) -> 'a

@h = tangler('src/flx_typing.mli')
@select(h)
open Flx_ast
open Flx_types
exception UnificationError of btypecode_t * btypecode_t
val flx_bool : typecode_t
val flx_bbool : btypecode_t
val dummy_sr: range_srcref

val type_of_argtypes : 
  typecode_t list -> 
  typecode_t
  
val funparamtype : 'a * 'b -> 'b

val typeoflist:
  btypecode_t list ->
  btypecode_t

val lift:
  btypecode_t -> btypecode_t

val lower:
  btypecode_t -> btypecode_t

val unify:
  symbol_table_t ->
  btypecode_t -> 
  btypecode_t ->
  btypecode_t 

val qualified_name_of_expr:
  expr_t -> qualified_name_t

module FuntypeSet :
  sig
    type elt = typecode_t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end

module FunInstSet :
  sig
    type elt = bid_t * btypecode_t list
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end

@h = tangler('src/flx_typing.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_srcref

exception UnificationError of btypecode_t * btypecode_t

(* unbound type *)
let type_of_argtypes ls = match ls with
 | [x] -> x
 | _ -> `TYP_tuple ls

let funparamtype x = snd x

module FuntypeSet = Set.Make(
  struct type t=typecode_t let compare = compare end
)

module FunInstSet = Set.Make(
  struct 
    type t= bid_t * btypecode_t list
    let compare = compare 
  end
)

(* bound type! *)
let typeoflist typlist = match typlist with
  | [t] -> t
  | _ -> `BTYP_tuple typlist

let rec lower t = match t with
  | `BTYP_binding (i,t) -> t
  | `BTYP_pointer t -> `BTYP_pointer (lower t)
  | `BTYP_tuple ts -> `BTYP_tuple (List.map lower ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map lower ts)
  | `BTYP_void -> `BTYP_void
  | `BTYP_function (a,b) -> `BTYP_function (lower a, lower b)
  | `BTYP_name i -> `BTYP_name i
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> `BTYP_var i
  | `BTYP_inst (i,ts) -> `BTYP_inst (i, List.map lower ts)
  | _ -> failwith "Unexpected metatype"


let rec lift t = match t with
  | `BTYP_binding (i,t) -> i
  | `BTYP_pointer t -> `BTYP_pointer (lift t)
  | `BTYP_tuple ts -> `BTYP_tuple (List.map lift ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map lift ts)
  | `BTYP_void -> `BTYP_void
  | `BTYP_function (a,b) -> `BTYP_function (lift a, lift b)
  | `BTYP_name i -> `BTYP_name i
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> `BTYP_var i
  | `BTYP_inst (i,ts) -> `BTYP_inst (i, List.map lift ts)
  | _ -> failwith "Unexpected metatype"

let rec unify dfns it mt = 
  let u it mt = unify dfns it mt in
  match it,mt with
  | (`BTYP_fix i, `BTYP_fix j) when i = j -> `BTYP_fix i
  | `BTYP_function (a,b), `BTYP_function(c,d) ->
    `BTYP_function (u a c, u b d)

  | `BTYP_pointer a, `BTYP_pointer b ->
    `BTYP_pointer (u a b)

  | `BTYP_tuple a, `BTYP_tuple b ->
    `BTYP_tuple (List.map2 u a b)

  | `BTYP_sum a, `BTYP_sum b ->
    `BTYP_sum (List.map2 u a b)

  | `BTYP_void, `BTYP_void -> `BTYP_void
  | (`BTYP_var i, `BTYP_var j) when i = j -> `BTYP_var i
  | (`BTYP_inst (i1,ts1), `BTYP_inst (i2,ts2)) when i1 = i2 -> 
    `BTYP_inst (i1,List.map2 u ts1 ts2)
    
  | i,m -> `BTYP_binding (i,m)

let dummy_sr = ("generated",0,0,0,0)
let flx_bool = `TYP_sum [`TYP_tuple[]; `TYP_tuple []]
let flx_bbool = `BTYP_sum [`BTYP_tuple[]; `BTYP_tuple []]

let qualified_name_of_expr e =
  match e with
  | #qualified_name_t as x -> x
  | _ -> 
    failwith
    (
      "Qualified name expected in\n" ^
      short_string_of_src (src_of_expr e)
    )

 
@h = tangler('src/flx_typing2.mli')
@select(h)
open Flx_ast
val typecode_of_expr:
  expr_t -> typecode_t

@h = tangler('src/flx_typing2.ml')
@select(h)
open Flx_ast
open Flx_types
open Flx_print
open Flx_srcref

let rec typecode_of_expr (e:expr_t) :typecode_t = 
  let te e = typecode_of_expr e in
  match e with 
  | `AST_name (_,"TYPE",[]) -> `TYP_type
  | #qualified_name_t as x -> (x:>typecode_t)
  | `AST_tuple (sr,ls) ->
    `TYP_type_tuple (List.map te ls)

  | `AST_product (_,ts) -> `TYP_tuple (List.map te ts)
  | `AST_arrow (_,(a,b)) -> `TYP_function (te a, te b)
  | `AST_ref (sr,e) -> `TYP_pointer (te e)
  | `AST_sum (_,ts) -> 
    `TYP_sum (List.map te ts)

  | `AST_typeof (_,e) -> `TYP_typeof e
  | `AST_as (sr,(t,x)) -> `TYP_as (te t,x)

  | `AST_literal (sr,`AST_int (enc,v)) ->
    if enc <> "int" 
    then 
      failwith 
      (
        "Only plain integer can be used as a type, code= '" ^ 
        enc ^
        "'"
      )
    else 
    let v = ref 
      begin try Big_int.int_of_big_int v 
      with _ -> failwith ("Integer used as type out of range")
      end
    in
      if !v <0 then failwith "Negative int not allowed as type"
      else if !v >=2000 then failwith "Int used as type must be <2000"
      else if !v = 0 then ((`AST_void sr) :> typecode_t)
      else if !v = 1 then `TYP_tuple[]
      else begin 
        let u = `TYP_tuple [] in
        let t = ref [u] in
        while !v > 1 do
          t := u :: !t;
          decr v
        done;
        `TYP_sum !t
      end

  | `AST_apply(sr,(e1,e2)) ->
    begin match e1 with
    | `AST_name (_,name,[]) ->
      let name' = name ^ "          " (* 10 chars *) in
      if name = "typeof" then `TYP_typeof e2 
      else let arg = typecode_of_expr e2 in
      if name = "dom" then `TYP_dom arg
      else if name = "cod" then `TYP_cod arg
      else if String.sub name' 0 5 = "proj_" 
      then 
        begin 
          let acc = ref 0 in
          for i = 5 to String.length name - 1 do
          if name.[i] <= '9' && name.[i] >='0'
          then acc := 10 * !acc + Char.code (name.[i]) - Char.code '0'
          else
            failwith 
            (
              "Digits expected in name '" ^ name ^ "' in\n" ^
              short_string_of_src sr
            )
          done;
          `TYP_proj (!acc, arg)
         end

      else if String.sub name' 0 9 = "case_arg_" 
      then 
        begin 
          let acc = ref 0 in
          for i = 9 to String.length name - 1 do
          if name.[i] <= '9' && name.[i] >='0'
          then acc := 10 * !acc + Char.code (name.[i]) - Char.code '0'
          else
            failwith 
            (
              "Digits expected in name '" ^ name ^ "' in\n" ^
              short_string_of_src sr
            )
          done;
          `TYP_case_arg (!acc, arg)
         end
      else 
        `TYP_apply (typecode_of_expr e1,arg)

    | _ ->
      `TYP_apply (typecode_of_expr e1,typecode_of_expr e2)
    end

  | `AST_lambda (sr,(params,ret,body)) ->
     begin match body with
     | [`AST_fun_return (_,e)] -> 
       `TYP_typefun 
       ( 
         params,
         ret,
         typecode_of_expr e
       )

     | _ -> 
       failwith 
       (
         "Type lambda must just be 'return type_expr' in\n" ^
         short_string_of_src sr
       )
     end

  | #expr_t -> 
    failwith 
    (
      "Type expression expected in\n" ^
      short_string_of_src (src_of_expr e)
    )
    
@head(1,'Charset')
@select(tangler('src/flx_charset.mli'))
open Flx_ast
type charset_t
val charset_of_string: string -> charset_t
val charset_of_int_range: int -> int -> charset_t
val charset_of_range: string -> string -> charset_t
val charset_union: charset_t -> charset_t -> charset_t
val charset_inv: charset_t -> charset_t
val regexp_of_charset: charset_t -> regexp_t
val regexp_underscore: regexp_t
val eol: int
val regexp_dot: regexp_t

@select(tangler('src/flx_charset.ml'))
open Flx_ast
type charset_t = bool array

let charset_of_string s = 
  let x = Array.make 256 false in
  for i  = 0 to String.length s - 1 do
    x.(Char.code s.[i]) <- true
  done;
  x


let charset_of_int_range x1 x2 =
  let x = Array.make 256 false in
  for i = x1 to x2 do
    x.(i) <- true 
  done
  ;
  x

let charset_of_range s1 s2 =
  if String.length s1 <> 1 
  then
    failwith "Charset range(first) requires string length 1"
  ;
  if String.length s2 <> 1 
  then
    failwith "Charset range(last) requires string length 1"
  ;
  let x1 = Char.code (s1.[0])
  and x2 = Char.code (s2.[0])
  in 
    charset_of_int_range x1 x2

let charset_union x1 x2 = 
  let x = Array.make 256 false in
  for i = 0 to 255 do
    x.(i) <- x1.(i) || x2.(i)
  done;
  x

let charset_inv y =
  let x = Array.make 256 false in
  for i = 0 to 255 do
    x.(i) <- not y.(i)
  done;
  x

let regexp_of_charset y =
  let res = ref REGEXP_epsilon in
  for i = 0 to 255 do
    if y.(i) then res := 
      let r = REGEXP_string (String.make 1 (Char.chr i)) in
      if !res = REGEXP_epsilon 
      then r 
      else REGEXP_alt ( !res, r)
  done
  ;
  !res

let regexp_underscore = 
  regexp_of_charset (charset_of_int_range 0 255)

let eol = Char.code '\n'

let regexp_dot = 
  regexp_of_charset 
  (
    charset_union 
      (charset_of_int_range 0 (eol - 1))
      (charset_of_int_range (eol + 1) 255)
  )


