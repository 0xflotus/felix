@head(1,'Utilities')
Generic (non Felix dependent) utilities.
@h = tangler('src/flx_util.mli')
@select(h)
val spaces : int -> string
val catmap : string -> ('a -> string) -> 'a list -> string
val (+>) : 'a -> ('a ->'b) -> 'b
val transpose: 'a list list -> 'a list list
val list_last: 'a list -> 'a 

@h = tangler('src/flx_util.ml')
@select(h)
let spaces level = String.make (level*2) ' '
let catmap sep fn ls = String.concat sep (List.map fn ls)
let (+>) x f = f x (* reverse application *)
let transpose x =
  let dtor ls =
    List.split (List.map (fun x -> List.hd x, List.tl x) ls)
  in let rec cons ls (h,t) = match List.hd t with
    | [] -> h :: ls
    | _ -> cons (h :: ls) (dtor t)
  in List.tl (List.rev (cons [] ([],x)))

let list_last l = List.hd (List.rev l)

@head(1,'Types')
@h = tangler('src/flx_types.mli')
These files declare the main data structures used by the compiler,
and provide routines to dump them to a string for debugging purposes.
@head(2,'Source Reference')
Provides a reference to the original source.
@select(h)
open Big_int
type srcref = 
  string * (* filename *)
  int * (* line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int   (* ending column, 1 origin *)

type range_srcref =
  string * (* filename *)
  int * (* starting line number, 1 origin *)
  int * (* starting column, 1 origin *)
  int * (* ending line number, 1 origin *)
  int   (* ending column, 1 origin *)

@head(2,'Abstract Syntax Tree')
AST types are nodes of the Abstract Syntax Tree generated by the
parser. 

@head(3,'Names')
A simple name is an identifier, a qualified name is a dot (.) separated list
of instantiated names, and a instantiated name is a simple name optionally
followed by a square bracket enclosed list of type expressions.
@select(h)
type c_t = string     (* C++ code as a string *)
type id_t = string

and qualified_name_t =
  [
  | `AST_void of range_srcref
  | `AST_root of range_srcref
  | `AST_name of range_srcref * string
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string)
  ]

and suffixed_name_t =
  [
  | `AST_void of range_srcref
  | `AST_root of range_srcref
  | `AST_name of range_srcref * string
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)
  ]

@head(3,'Type sublanguage')
Terms of the type sublanguage. The encoding '`TYP_none' is 
a hack which allows the suffixed name representation
to work for unsuffixed names. 
@p()
The encoding '`TYP_void'
is the categorical initial: the type of an empty
union, and the type ordinary procedure types return.
There are no values of this type. 
@select(h)
and typecode_t = 
  [
  | `AST_void of range_srcref                   (* void type *)
  | `AST_root of range_srcref                   (* top level module *)
  | `AST_name of range_srcref * string
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string)
  | `TYP_tuple of typecode_t list               (* product type *)
  | `TYP_sum of typecode_t list                 (* numbered sum type *)
  | `TYP_function of typecode_t * typecode_t    (* function type *)
  | `TYP_pointer  of typecode_t                 (* pointer type *)
  | `TYP_as of typecode_t * string              (* fix *)
  | `TYP_typeof of expr_t                       (* typeof *)
  | `TYP_var of int                             (* unknown type *)
  | `TYP_none

  (* destructors *)
  | `TYP_dom of typecode_t                      (* domain *)
  | `TYP_cod of typecode_t                      (* codomain *)
  | `TYP_proj of int * typecode_t               (* tuple projection *)
  | `TYP_case_arg of int * typecode_t           (* argument of n'th variant *)
  ]

@head(3,'Literals')
Literals recognized by the lexer.
@select(h)
and literal_t =
  [
  | `AST_int of string * big_int
  | `AST_string of string
  | `AST_float of string * string
  ]

@head(3,'Expressions')
Raw expression terms.

@select(h)
and expr_t =
  [
  | `AST_root of range_srcref
  | `AST_name of range_srcref * string
  | `AST_case_tag of range_srcref * int
  | `AST_typed_case of range_srcref * int * typecode_t
  | `AST_lookup of range_srcref * (expr_t * string)
  | `AST_index of range_srcref * bid_t
  | `AST_bound_module of range_srcref * (bid_t * bid_t * index_map_t)
  | `AST_apply of range_srcref * (expr_t * expr_t)
  | `AST_tuple of range_srcref * expr_t list
  | `AST_coercion of range_srcref * (expr_t * typecode_t)
  | `AST_suffix of range_srcref * (qualified_name_t * typecode_t)

  | `AST_void of range_srcref
  | `AST_product of range_srcref * expr_t list
  | `AST_sum of range_srcref * expr_t list
  | `AST_arrow of range_srcref * (expr_t * expr_t)

  | `AST_literal of range_srcref * literal_t
  | `AST_deref of range_srcref * expr_t
  | `AST_ref of range_srcref * expr_t
  | `AST_method_apply of range_srcref * (id_t * expr_t)
  | `AST_dot of range_srcref * (expr_t * id_t)
  | `AST_lambda of range_srcref * (parameter_t list * typecode_t * statement_t list)
  | `AST_match_ctor of range_srcref * (qualified_name_t * expr_t)
  | `AST_match_case of range_srcref * (int * expr_t)
  | `AST_ctor_arg of range_srcref * (qualified_name_t * expr_t)
  | `AST_case_arg of range_srcref * (int * expr_t)

  | `AST_get_n of range_srcref * (int * expr_t) (* get n'th component of a tuple *)
  | `AST_lazy of range_srcref * expr_t
  | `AST_as of range_srcref * (expr_t * string)
  | `AST_match of range_srcref * (expr_t * (pattern_t * expr_t) list)
  | `AST_typeof of range_srcref * expr_t
  | `AST_cond of range_srcref * (expr_t * expr_t * expr_t)
  ]

@head(3,'Pattern')
Patterns; used for matching variants in match statements.
@select(h)
and float_pat = 
  | Float_plus of string * string (* type, value *)
  | Float_minus of string * string
  | Float_inf 
  | Float_minus_inf

and pattern_t =
  [
  | `PAT_nan of range_srcref

  (* constants *)
  | `PAT_int of range_srcref * string * big_int
  | `PAT_string of range_srcref * string

  (* ranges *)
  | `PAT_int_range of range_srcref * string * big_int * string * big_int
  | `PAT_string_range of range_srcref * string * string
  | `PAT_float_range of range_srcref * float_pat * float_pat 

  (* other *)
  | `PAT_name of range_srcref * id_t 
  | `PAT_tuple of range_srcref * pattern_t list
  | `PAT_any of range_srcref 
  | `PAT_regexp of range_srcref * string * id_t list 
    (* second list is group bindings 1 .. n-1: EXCLUDES 0 cause we can use 'as' for that ?? *)
  | `PAT_const_ctor of range_srcref * qualified_name_t
  | `PAT_nonconst_ctor of range_srcref * qualified_name_t * pattern_t
  | `PAT_as of range_srcref * pattern_t * id_t
  | `PAT_when of range_srcref * pattern_t * expr_t
  ]

@head(3,'Pattern extractor')
This type is used to extract components of a value,
corresponding to a match.
@select(h)
and extract_t = 
  | Proj_n of range_srcref * int             (* tuple projections 1 .. n *)
  | Udtor of range_srcref * qualified_name_t (* argument of union component s *)

@head(3,'Statements')
Statements; that is, the procedural sequence control system.
@select(h)
and parameter_t = id_t * typecode_t
and statement_t =
  [ 
  | `AST_open of range_srcref * qualified_name_t
  | `AST_comment of string (* for documenting generated code *)

  (* definitions *)
  | `AST_function of range_srcref * id_t * parameter_t list * typecode_t * statement_t list
  | `AST_procedure of range_srcref * id_t * parameter_t list * statement_t list

  (* types *)
  | `AST_union of range_srcref * id_t * (id_t * typecode_t) list
  | `AST_struct of range_srcref * id_t * (id_t * typecode_t) list
  | `AST_type_alias of range_srcref * id_t * typecode_t

  (* variables *)
  | `AST_val_decl of range_srcref * id_t * typecode_t option * expr_t option
  | `AST_var_decl of range_srcref * id_t * typecode_t option * expr_t option
 
  (* module system *)
  | `AST_untyped_module of range_srcref * id_t * statement_t list  
  | `AST_typed_module of range_srcref * id_t * typecode_t * statement_t list  
  | `AST_module_binding of range_srcref * id_t * expr_t
  | `AST_typed_functor of range_srcref * id_t * parameter_t list * typecode_t * statement_t list
  | `AST_untyped_functor of range_srcref * id_t * parameter_t list * statement_t list
  | `AST_interface of range_srcref * id_t * statement_t list
  | `AST_type of range_srcref * id_t
  | `AST_function_decl of range_srcref * id_t * typecode_t
  | `AST_procedure_decl of range_srcref * id_t * typecode_t

 
  (* control structures: primitives *)
  | `AST_label of range_srcref * id_t
  | `AST_goto of range_srcref * id_t 
  | `AST_ifgoto of range_srcref * expr_t *id_t
  | `AST_ifnotgoto of range_srcref * expr_t * id_t
  | `AST_call of range_srcref * expr_t * expr_t 
  | `AST_read of range_srcref * id_t
  | `AST_return of range_srcref * expr_t
  | `AST_nop of range_srcref * string

  | `AST_block of range_srcref * statement_t list
  (*
  | `AST_if of 
    range_srcref * 
    (range_srcref * (expr_t * statement_t)) list * 
    (range_srcref * statement_t)
  *)

  (* exceptions *)
  | `AST_attempt of 
    range_srcref *
    (range_srcref * statement_t) *         (* the attempt *)
    (range_srcref * statement_t list) *    (* the handlers *)
    (range_srcref * statement_t list)      (* the finally block *)
  | `AST_except_handler of range_srcref * id_t * parameter_t list * statement_t list
  | `AST_raise of range_srcref * id_t * expr_t

  (* binding structures [prolog] *)
  | `AST_abs_decl of range_srcref * id_t * c_t
  | `AST_const_decl of range_srcref * id_t * typecode_t * c_t
  | `AST_fun_decl of range_srcref * id_t * typecode_t list * typecode_t * c_t 
  | `AST_proc_decl of range_srcref * id_t * typecode_t list * c_t 
  | `AST_header of range_srcref * string
  | `AST_body of range_srcref * string
  | `AST_code of range_srcref * string
  | `AST_noreturn_code of range_srcref * string

  | `AST_export of range_srcref * suffixed_name_t * string
  ]


and exe_t =
  [
  | `EXE_code of string (* for inline C++ code *)
  | `EXE_noreturn_code of string (* for inline C++ code *)
  | `EXE_comment of string (* for documenting generated code *)
  | `EXE_label of string (* for internal use only *)
  | `EXE_goto of string  (* for internal use only *)
  | `EXE_ifgoto of expr_t * string  (* for internal use only *)
  | `EXE_ifnotgoto of expr_t * string  (* for internal use only *)
  | `EXE_call of expr_t * expr_t 
  | `EXE_read of id_t
  | `EXE_return of expr_t
  | `EXE_nop of string
  | `EXE_init of id_t * expr_t 
  ]

and dir_t =
  | DIR_open of qualified_name_t

and dcl_t = 
  [
  | `DCL_header of string
  | `DCL_body of string

  (* data structures *)
  | `DCL_function of    parameter_t list * typecode_t * asm_t list
  | `DCL_lazy of        expr_t
  | `DCL_procedure of   parameter_t list * asm_t list
  | `DCL_union of       (id_t * typecode_t) list
  | `DCL_struct of      (id_t * typecode_t) list
  | `DCL_match_check of pattern_t * string
  | `DCL_match_handler of pattern_t * string * asm_t list
  
  (* variables *)
  | `DCL_val of         typecode_t
  | `DCL_var of         typecode_t
  | `DCL_type_alias of  typecode_t

  (* module system *)
  | `DCL_module of      asm_t list  
  | `DCL_typed_functor of     parameter_t list * typecode_t * asm_t list
  | `DCL_untyped_functor of   parameter_t list * asm_t list
  | `DCL_module_binding of expr_t
  | `DCL_interface of   asm_t list

  (* interface elements *)
  | `DCL_if_proc of     typecode_t
  | `DCL_if_fun of      typecode_t
  | `DCL_type
  
  (* binding structures [prolog] *)
  | `DCL_abs of         c_t
  | `DCL_const of       typecode_t * c_t
  | `DCL_fun of         typecode_t list * typecode_t * c_t 
  | `DCL_proc of        typecode_t list * c_t 
  ]

and asm_t = 
  
  | Exe of range_srcref * exe_t 
  | Dcl of range_srcref * id_t * dcl_t 
  | Iface of range_srcref * iface_t
  | Dir of range_srcref * dir_t
 

and bid_t = int

and iface_t =
  [
  | `IFACE_export of suffixed_name_t * string
  ]

and biface_t =
  [
  | `BIFACE_export of bid_t * string
  ]

and bexe_t =
  [
  | `BEXE_label of string
  | `BEXE_comment of string (* for documenting generated code *)
  | `BEXE_goto of string  (* for internal use only *)
  | `BEXE_ifgoto of tbexpr_t * string  (* for internal use only *)
  | `BEXE_ifnotgoto of tbexpr_t * string  (* for internal use only *)
  | `BEXE_call of tbexpr_t * tbexpr_t 
  | `BEXE_read of bid_t
  | `BEXE_return of tbexpr_t
  | `BEXE_nop of string
  | `BEXE_code of string
  | `BEXE_init of bid_t * tbexpr_t 
  ]

and bexpr_t =
  [
  | `BEXPR_deref of tbexpr_t
  | `BEXPR_name of bid_t
  | `BEXPR_ref of bid_t
  | `BEXPR_literal of literal_t 
  | `BEXPR_apply of tbexpr_t * tbexpr_t 
  | `BEXPR_tuple of tbexpr_t list
  | `BEXPR_dot of tbexpr_t * bid_t
  | `BEXPR_get_n of int * tbexpr_t
  | `BEXPR_closure of bid_t
  | `BEXPR_coercion of tbexpr_t * btypecode_t
  | `BEXPR_functions of string * entry_kind_t list (* HACK! *)
  | `BEXPR_case of int * btypecode_t
  | `BEXPR_match_case of int * tbexpr_t
  | `BEXPR_case_arg of int * tbexpr_t
  ]

and tbexpr_t = bexpr_t * btypecode_t

and btypecode_t = 
  [
  | `BTYP_name of bid_t                            (* named type *)
  | `BTYP_tuple of btypecode_t list                (* product type *)
  | `BTYP_sum of btypecode_t list                  (* product type *)
  | `BTYP_function of btypecode_t * btypecode_t    (* function type *)
  | `BTYP_pointer  of btypecode_t                  (* pointer type *)
  | `BTYP_void                                     (* void type *)
  | `BTYP_none                                     (* special hack for 'no type' *)
  | `BTYP_binding of btypecode_t * btypecode_t     (* interface, module *)
  | `BTYP_fix of int                               (* recurse to depth n *)
  | `BTYP_var of int         (* unknown variable or function return type *)
  ]

and bparameter_t = string * btypecode_t
and bbdcl_t = 
  [
  | `BBDCL_header of     string
  | `BBDCL_body of     string
  | `BBDCL_function of   bparameter_t list * btypecode_t * bexe_t list * name_map_t
  (* 
  | `BBDCL_functor  of   bparameter_t list * btypecode_t * name_map_t
  *)
  | `BBDCL_procedure of  bparameter_t list * bexe_t list * name_map_t
  (*
  | `BBDCL_if_fun of     btypecode_t 
  | `BBDCL_if_proc of    btypecode_t
  *) 
  | `BBDCL_val of        btypecode_t
  | `BBDCL_var of        btypecode_t

  (* binding structures [prolog] *)
  | `BBDCL_abs of        c_t
  | `BBDCL_const of      btypecode_t * c_t
  | `BBDCL_fun of        btypecode_t list * btypecode_t * c_t 
  | `BBDCL_proc of       btypecode_t list * c_t 
  | `BBDCL_union of      (id_t * btypecode_t) list
  | `BBDCL_struct of     (id_t * btypecode_t) list
  ]

and entry_kind_t = 
  | Simple of int
  | Bound of int * int

and entry_set_t =
  | FunctionEntry of entry_kind_t list
  | NonFunctionEntry of entry_kind_t
  
and module_rep_t = 
  | Simple_module of bid_t * name_map_t * dir_t list
  | Bound_module of bid_t * bid_t * index_map_t
  | Functor_set of bid_t list
  | Module_product of module_rep_t list

and name_map_t = (string, entry_set_t) Hashtbl.t
and index_map_t = (int,int) Hashtbl.t
and instantiation_registry_t = 
  (
    int *                         (* functor index *)
    module_rep_t,                 (* argument list *) 
    int                           (* instantiated functor = module index *)
  ) Hashtbl.t
and typevarmap_t = (int,btypecode_t) Hashtbl.t
and functor_arg_binding_t = 
  (
    id_t *                        (* argument name *)
    (
      bid_t *                     (* interface *)
      bid_t *                     (* implementation module  *)
      index_map_t                 (* interface->module binding map *)
    )
  ) list

type env_t = (name_map_t * name_map_t list) list 
type symbol_definition_t =
  [
  | `SYMDEF_parameter of typecode_t
  | `SYMDEF_function of 
    parameter_t list * 
    typecode_t * 
    exe_t list * 
    name_map_t * 
    dir_t list

  | `SYMDEF_lazy of expr_t 
  | `SYMDEF_match_check of pattern_t * int 
  | `SYMDEF_match_handler of 
    pattern_t * 
    int *
    exe_t list * 
    name_map_t * 
    dir_t list

  | `SYMDEF_interface of name_map_t * dir_t list
  | `SYMDEF_typed_functor of 
    parameter_t list * 
    typecode_t * 
    exe_t list * 
    name_map_t * 
    dir_t list

  | `SYMDEF_untyped_functor of 
    parameter_t list * 
    exe_t list * 
    name_map_t * 
    dir_t list

  | `SYMDEF_module of name_map_t * dir_t list
  | `SYMDEF_if_type
  | `SYMDEF_if_proc of typecode_t 
  | `SYMDEF_if_fun of typecode_t
  | `SYMDEF_procedure of  
     parameter_t list * 
     exe_t list * 
     name_map_t * 
     dir_t list
  
  | `SYMDEF_module_binding of expr_t
  | `SYMDEF_dcl of dcl_t
  | `SYMDEF_var of typecode_t
  | `SYMDEF_val of typecode_t
  ]

type symbol_data_t = string * range_srcref * int option * symbol_definition_t 
type symbol_table_t = (int, symbol_data_t) Hashtbl.t

type symbol_data3_t = string * int option * bbdcl_t 
type fully_bound_symbol_table_t = (int, symbol_data3_t) Hashtbl.t

type type_registry_t = (btypecode_t,int) Hashtbl.t

type sym_state_t = 
{
  dfns : symbol_table_t;
  freg : instantiation_registry_t;
  counter : int ref;
  varmap : typevarmap_t;
  ticache : (int, btypecode_t) Hashtbl.t;
  env_cache : (int, env_t) Hashtbl.t
}

@doc()
The whole of a compilation unit, this is the data structure
returned by parsing a whole file.
@select(h)
type compilation_unit_t = statement_t list

@head(1,'Routines to extract source reference from terms')
Source reference manipulators.
@h = tangler('src/flx_srcref.mli')
@select(h)
open Flx_types
val rstoken: srcref -> srcref -> range_srcref
val rsrange: range_srcref -> range_srcref -> range_srcref
val slift: srcref -> range_srcref

val rsexpr: expr_t -> expr_t -> range_srcref
val rslist: expr_t list -> range_srcref

val src_of_expr: expr_t -> range_srcref
val src_of_stmt : statement_t -> range_srcref
val src_of_pat : pattern_t -> range_srcref
val src_of_qualified_name : qualified_name_t -> range_srcref
val src_of_suffixed_name: suffixed_name_t -> range_srcref

val short_string_of_src: range_srcref -> string

@h = tangler('src/flx_srcref.ml')
@doc()
Generic source reference manipulation.
Note the special hack of forgetting the second
filename when creating a range: the alternative
would be to record a complete list of lines.
@select(h)
(* get source range from source references of first
   and last tokens 
*)
let rstoken (f1,l1,s1,e1) (f2,l2,s2,e2) = (f1,l1,s1,l2,e2)

(* get range from first and last ranges *)
let rsrange (f1,sl1,sc1,el1,ec1) (f2,sl2,sc2,el2,ec2) =
  (f1,sl1,sc1,el2,ec2)

(* lift token source to range *)
let slift (f,l,s,e) = (f,l,s,l,e)

(* axiom: rstoken a b = rsrange (lift a) (lift b) *)

@doc()
Type specific operations.
@select(h)
open Flx_util
open Flx_types
let src_of_qualified_name (e : qualified_name_t) = match e with
  | `AST_void s 
  | `AST_root s 
  | `AST_name  (s,_) 
  | `AST_case_tag (s,_)
  | `AST_typed_case (s,_,_)
  | `AST_lookup (s,_)
    -> s

let src_of_suffixed_name (e : suffixed_name_t) = match e with
  | #qualified_name_t as x -> src_of_qualified_name x
  | `AST_suffix (s,_) 
    -> s

let src_of_expr (e : expr_t) = match e with
  | #suffixed_name_t as x -> src_of_suffixed_name x

  | `AST_product (s,_)
  | `AST_sum (s,_)
  | `AST_arrow (s,_)

  | `AST_index (s,_)
  | `AST_apply  (s,_) 
  | `AST_bound_module (s,_)
  | `AST_deref (s,_) 
  | `AST_ref  (s,_) 
  | `AST_literal  (s,_) 
  | `AST_method_apply  (s,_) 
  | `AST_tuple  (s,_) 
  | `AST_dot  (s,_) 
  | `AST_lambda  (s,_) 
  | `AST_match_ctor  (s,_) 
  | `AST_match_case (s,_)
  | `AST_ctor_arg  (s,_) 
  | `AST_case_arg  (s,_) 
  | `AST_get_n  (s,_) 
  | `AST_lazy (s,_)
  | `AST_coercion (s,_)
  | `AST_as (s,_)
  | `AST_match (s, _) 
  | `AST_typeof (s, _) 
  | `AST_cond (s,_)
    -> s

let src_of_stmt e = match e with
  | `AST_interface (s,_,_)
  | `AST_module_binding (s,_,_)
  | `AST_typed_functor (s,_,_,_,_)
  | `AST_untyped_functor (s,_,_,_)
  | `AST_label (s,_)
  | `AST_goto (s,_)
  
  | `AST_function (s, _, _ , _, _)
  | `AST_procedure (s, _, _ , _)

  | `AST_val_decl (s, _, _, _) 
  | `AST_var_decl (s, _, _, _) 

  | `AST_type_alias (s, _, _) 
  | `AST_except_handler (s, _, _, _ ) 
  
  | `AST_call (s, _, _ ) 
  | `AST_read (s, _) 
  | `AST_return (s, _) 
  | `AST_block (s, _ ) 
  | `AST_nop (s, _) 
  (*
  | `AST_if (s, _ , _) 
  *)
  | `AST_ifgoto (s,_,_)
  | `AST_ifnotgoto (s,_,_)
  | `AST_attempt (s,_,_,_)
  | `AST_raise (s, _, _) 
  | `AST_abs_decl (s, _, _) 
  | `AST_const_decl (s, _, _, _) 
  | `AST_fun_decl (s, _, _ , _, _ ) 
  | `AST_proc_decl (s,_, _ , _ ) 
  | `AST_header (s,_) 
  | `AST_body (s,_) 
  | `AST_code (s, _) 
  | `AST_noreturn_code (s, _) 
  | `AST_union (s, _, _ ) 
  | `AST_struct (s, _, _)
  | `AST_typed_module (s, _,_,_)
  | `AST_untyped_module (s,_,_)
  | `AST_export (s, _,_)
  | `AST_procedure_decl (s,_,_)
  | `AST_function_decl (s,_,_)
  | `AST_type (s,_)
  | `AST_open (s,_)
    -> s
  | `AST_comment _ 
    -> ("Generated",0,0,0,0)

let src_of_pat e = match e with
  | `PAT_nan s
  | `PAT_int (s,_,_)
  | `PAT_string (s, _)
  | `PAT_int_range (s,_,_,_,_)
  | `PAT_string_range (s, _, _)
  | `PAT_float_range (s, _,_)
  | `PAT_name (s, _)
  | `PAT_tuple (s, _)
  | `PAT_any s
  | `PAT_regexp (s, _, _ )
  | `PAT_const_ctor (s, _)
  | `PAT_nonconst_ctor (s, _, _)
  | `PAT_as (s, _, _)
  | `PAT_when (s, _, _)
    -> s

(* get range from first and last expressions *)
let rsexpr a b = rsrange (src_of_expr a) (src_of_expr b)

(* get source range of non-empty list of expressions *)
let rslist lst = 
  rsexpr (List.hd lst) (list_last lst)


let short_string_of_src (f,l1,c1,l2,c2) =
  if l1 = l2 
  then
    f ^ ": line " ^ string_of_int l1 ^ 
    ", cols " ^ string_of_int c1 ^ " to " ^ string_of_int c2
  else
    f ^ ": line " ^ string_of_int l1 ^ 
    " col " ^ string_of_int c1 ^ " to " ^ 
    " line " ^ string_of_int l2 ^ " col " ^ string_of_int c2

@head(1,'Print module')
Routines to print various terms.
@h = tangler('src/flx_print.mli')
@select(h)
open Flx_types
val string_of_typecode : typecode_t -> string
val string_of_btypecode : symbol_table_t -> btypecode_t -> string
val special_string_of_typecode : typecode_t -> string
val string_of_expr : expr_t -> string
val string_of_bound_expression : 
  symbol_table_t -> 
  tbexpr_t -> 
  string
val string_of_pattern : pattern_t -> string
val string_of_literal : literal_t -> string
val string_of_parameters : parameter_t list -> string
val string_of_arguments : expr_t list -> string
val string_of_statement : int -> statement_t -> string
val string_of_compilation_unit : compilation_unit_t -> string
val string_of_desugared : asm_t list -> string
val string_of_suffixed_name : suffixed_name_t -> string
val string_of_qualified_name : qualified_name_t -> string
val string_of_dcl : int -> id_t -> dcl_t -> string
val string_of_bexe : symbol_table_t -> int -> bexe_t -> string
val string_of_exe : int -> exe_t -> string
val qualified_name_of_index : symbol_table_t -> int -> string
val string_of_bbdcl : 
  symbol_table_t -> 
  bbdcl_t -> 
  int -> 
  string

val string_of_symdef : 
  symbol_definition_t -> string ->
  string

@h = tangler('src/flx_print.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_srcref
open Big_int
open Flx_typing

let rec string_of_string s = Flx_string.c_quote_of_string s

and suffix_of_type s = match s with
  | "tiny" -> "t"
  | "short" -> "s"
  | "int" -> ""
  | "long" -> "l"
  | "vlong" -> "v"
  | "utiny" -> "tu"
  | "ushort" -> "su"
  | "uint" -> ""
  | "ulong" -> "lu"
  | "uvlong" -> "vu"
  | "int8" -> "i8"
  | "int16" -> "i16"
  | "int32" -> "i32"
  | "int64" -> "i64"
  | "uint8" -> "u8"
  | "uint16" -> "u16"
  | "uint32" -> "u32"
  | "uint64" -> "u64"
  | "float" -> "f"
  | "double" -> ""
  | "ldouble" -> "l"
  | _ -> failwith ("[suffix_of_type] Unexpected Type " ^ s)

 
and string_of_literal e = match e with
  | `AST_int (s,i) -> (string_of_big_int i)^suffix_of_type s 
  | `AST_float (t,v) -> v ^ suffix_of_type t
  | `AST_string s -> string_of_string s
  
and string_of_qualified_name (n:qualified_name_t) =
  let se e = string_of_expr e in
  match n with
  | `AST_void _ -> "void"
  | `AST_root _ -> "root"
  | `AST_name (_,name) -> name 
  | `AST_case_tag (_,v) -> "case " ^ string_of_int v
  | `AST_typed_case (_,v,t) -> 
    "(case " ^ string_of_int v ^ 
    " of " ^ string_of_typecode t ^ ")"

  | `AST_lookup (_,(e,name)) -> "("^se e ^")::" ^ name 

and string_of_suffixed_name (n:suffixed_name_t) =
  match n with
  | #qualified_name_t as n -> string_of_qualified_name n
  | `AST_suffix (_,(name,suf)) ->
    string_of_qualified_name name ^ " of (" ^ string_of_typecode suf ^ ")"

and string_of_expr (e:expr_t) = 
  let se e = string_of_expr e 
  and sme e = string_of_expr e 
  and sqn e = string_of_qualified_name e
  in
  match e with
  | #suffixed_name_t as n -> string_of_suffixed_name n

  | `AST_index (sr,i) -> "(index " ^ string_of_int i ^ ")"
  | `AST_bound_module (sr,(iface,impl,binding)) -> "(module_binding)"
  | `AST_coercion (_,(e,t)) -> 
    "(" ^ sme e ^ ":" ^ 
    string_of_typecode t ^ ")"

  | `AST_cond (_,(e,b1,b2)) -> 
    "if " ^ se e ^ 
    " then " ^ se b1 ^ 
    " else " ^ se b2 ^ 
    " endif"

  | `AST_typeof (_,e) -> "typeof("^se e^")"
  | `AST_lazy (_,e) -> "lazy(" ^ se e ^ ")"
  | `AST_as (_,(e1, name)) -> "(" ^ se e1 ^ ") as " ^ name  
  | `AST_get_n (_,(n,e)) -> "get (" ^ string_of_int n ^ ", " ^se e^")"
  | `AST_deref (_,e) -> "*(" ^ se e ^ ")"
  | `AST_ref (_,e) -> "&" ^ "(" ^ se e ^ ")"
  | `AST_literal (_,e) -> string_of_literal e
  | `AST_apply  (_,(fn, arg)) -> "(" ^ 
    sme fn ^ " " ^ 
    sme arg ^ 
    ")"

  | `AST_product (_,ts) ->
     String.concat "*" (List.map se ts)
  | `AST_sum (_,ts) ->
     String.concat "+" (List.map se ts)
  | `AST_arrow (_,(a,b)) ->
    "(" ^ se a ^ " -> " ^ se b ^ ")"
    
  | `AST_method_apply  (_,(fn, arg)) -> "(" ^ 
    fn ^ " " ^ 
    se arg ^ 
    ")"

  | `AST_tuple (_,t) -> "(" ^ catmap ", " sme t ^ ")"
  | `AST_dot (_,(e,n)) ->  "get_" ^ n ^ "(" ^ se e ^ ")"

  | `AST_lambda (_,(params,ret, sts)) -> 
    "(lambda(" ^ string_of_parameters params ^ "): " ^ 
    string_of_typecode ret ^
    string_of_compound 0 sts

  | `AST_ctor_arg (_,(cn,e)) ->
    "ctor_arg " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_case_arg (_,(n,e)) ->
    "case_arg " ^ string_of_int n ^ "(" ^
    se e ^ ")"

  | `AST_match_ctor (_,(cn,e)) ->
    "match_ctor " ^ sqn cn ^ "(" ^
    se e ^ ")"

  | `AST_match_case (_,(v,e)) ->
    "match_case " ^ string_of_int v ^ "(" ^
    se e ^ ")"

  | `AST_match (_,(e, ps)) ->
    "match " ^ se e ^ " with " ^
    catmap "\n"
    (fun (p,e')->
      " | " ^
      string_of_pattern p ^
      " => " ^
      string_of_expr e'
    )
    ps
    ^
    " endmatch"

(* precedences for type operators ..
   0 -- atomic
   1 -- pointer
   2 -- application
   3 -- *
   4 -- +
   5 -- ->
   6 -- =>
   7    as, all
*)


and st prec tc = 
  let iprec,txt =
    match tc with
    | #qualified_name_t as t -> 0,string_of_qualified_name t
    | `TYP_none -> (* print_endline ("NONE DETECTED"); *)
       0,"Unknown"
    | `TYP_var i -> 0,"<var " ^ string_of_int i ^ ">"
    | `TYP_tuple ls ->
      begin match ls with 
      | [] -> 0,"unit" 
      | _ -> 3, String.concat " * " (List.map (st 3) ls)
      end

    | `TYP_sum ls ->
      begin match ls with 
      | [] -> 0,"void" 
      | _ -> 4,String.concat " * " (List.map (st 4) ls)
      end

    | `TYP_function (args, result) ->  
      5,st 5 args ^ " -> " ^ st 5 result

    | `TYP_pointer t -> 1,"&" ^ st 1 t
    
    | `TYP_typeof e -> 0,"typeof(" ^ string_of_expr e ^ ")"
    | `TYP_as (t,s) -> 7,st 7 t ^ " as " ^ s

    | `TYP_proj (i,t) -> 0,"proj_"^string_of_int i^"("^string_of_typecode t^")"
    | `TYP_dom t -> 0,"dom("^string_of_typecode t^")"
    | `TYP_cod t -> 0,"cod("^string_of_typecode t^")"
    | `TYP_case_arg (i,t) -> 0,"case_arg_"^string_of_int i^"("^string_of_typecode t^")"
  in
    if iprec >= prec 
    then "(" ^ txt ^ ")" 
    else txt

and string_of_typecode tc = st 99 tc

and qualified_name_of_index dfns index = 
  match Hashtbl.find dfns index with 
  | (id,sr,None,_) -> (* id ^ "<" ^ string_of_int index ^ ">" *) ""
  | (id,sr,Some index',_) -> 
    qualified_name_of_index dfns index' ^ "::" ^
    id 
    (* ^ "<" ^ string_of_int index ^ ">" *)

(* fixppoint labeller .. very sloppy, ignores precedence .. *)
and get_label i =
  if i = 0 then "" 
  else 
    let ch = Char.chr (i mod 26 + Char.code('a')-1) in
    get_label (i/26) ^ String.make 1 ch
  
and print_fixpoints depth fixlist =
  match fixlist with
  | (d,lab) :: t when d = depth -> 
    let txt,lst = print_fixpoints depth t in
    " as " ^ lab ^ " " ^ txt, lst
  | _ -> "", fixlist
  
and sb dfns depth fixlist counter prec tc = 
  let sbt prec t = sb dfns (depth+1) fixlist counter prec t in
    let iprec, term = 
      match tc with
      | `BTYP_fix i ->
         incr counter; (* 'a is 1 anyhow .. *)
         let lab = "fix_" ^ get_label !counter in
         fixlist := (depth+i,lab) :: !fixlist;
         0,lab 

      | `BTYP_binding (a,b) -> 
        6,
        sbt 6 a ^
        " => " ^
        sbt 6 b

      | `BTYP_var i -> 0,"<type_variable " ^ string_of_int i ^ ">"

      | `BTYP_name n -> 0,qualified_name_of_index dfns n

      | `BTYP_tuple ls -> 
        begin match ls with 
        | [] -> 0,"unit" 
        | [x] -> failwith ("UNEXPECTED TUPLE OF ONE ARGUMENT " ^ sbt 9 x)
        | _ -> 3,String.concat " * " (List.map (sbt 3) ls)
        end

      | `BTYP_sum ls -> 
        begin match ls with 
        | [] -> 9,"UNEXPECTED EMPTY SUM = void" 
        | [x] -> (* failwith *) (9,"UNEXPECTED SUM OF ONE ARGUMENT " ^ sbt 9 x)
        | _ -> 4,String.concat " + " (List.map (sbt 4) ls)
        end

      | `BTYP_function (args, result) ->  
        5,(sbt 5 args) ^ " -> " ^ (sbt 5 result)

      | `BTYP_pointer t -> 1,"&" ^ sbt 1 t
      | `BTYP_void -> 0,"void"
      | `BTYP_none -> 0,"<none>"
    in
      let txt,lst = print_fixpoints depth !fixlist in
      fixlist := lst;
      if txt <> "" then "(" ^ term ^ txt ^ ")"
      else if iprec >= prec then "(" ^ term ^ ")"
      else term

and string_of_btypecode dfns tc = 
  let fixlist = ref [] in
  let term = sb dfns 0 fixlist (ref 0) 99 tc in
  let bad = ref "" in
  while List.length !fixlist > 0 do
    match !fixlist with
    | (d,v)::t ->
      bad := !bad ^ " [Free Fixpoint " ^ string_of_int d ^ " " ^ v ^"]";
      fixlist := t
    | [] -> assert false
  done;
  term ^ !bad
  
and string_of_parameters ps = 
  String.concat 
    ", " 
    (List.map (fun (x,y)-> x ^ ": "^(string_of_typecode y)) ps)

and string_of_bparameters dfns ps = 
  String.concat 
    ", " 
    (List.map (fun (x,y)-> x ^ ": "^(string_of_btypecode dfns y)) ps)

and string_of_arguments ass = 
  catmap ", " string_of_expr ass

 
and string_of_component level (name, typ) = 
   spaces level ^ name ^ ": " ^ (string_of_typecode typ)

and string_of_float_pat = function
  | Float_plus (t,v) -> v ^ t
  | Float_minus (t,v) -> "-" ^ v ^ t
  | Float_inf -> "inf"
  | Float_minus_inf -> "-inf"

and string_of_pattern p = 
  let se e = string_of_expr e in
  match p with
  | `PAT_nan _ -> "NaN"
  | `PAT_int (_,t,i) -> string_of_big_int i ^ suffix_of_type t
  | `PAT_int_range (_,t1,i1,t2,i2) -> 
    string_of_big_int i1 ^ suffix_of_type t1 ^
    " .. " ^ 
    string_of_big_int i2 ^ suffix_of_type t2
    
  | `PAT_string (_,s) -> string_of_string s
  | `PAT_string_range (_,s1, s2) -> 
    string_of_string s1 ^ " .. " ^ string_of_string s2
  | `PAT_float_range (_,x1, x2) -> 
    string_of_float_pat x1 ^ " .. " ^ string_of_float_pat x2
  | `PAT_name (_,s) -> s
  | `PAT_tuple (_,ps) -> "(" ^ catmap ", "  string_of_pattern ps ^ ")"
  | `PAT_any _ -> "any"
  | `PAT_regexp (_,r,b) -> 
    "regexp " ^ string_of_string r ^
    "(" ^ String.concat ", " b ^ ")"
  | `PAT_const_ctor (_,s) -> "|" ^ string_of_qualified_name s 
  | `PAT_nonconst_ctor (_,s,p)-> "|" ^ string_of_qualified_name s ^ " " ^ string_of_pattern p
  | `PAT_as (_,p,n) -> "(" ^ string_of_pattern p ^ " as " ^ n ^ ")"
  | `PAT_when (_,p,e) -> "(" ^ string_of_pattern p ^ " when " ^ se e ^ ")"
 
and string_of_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_statement (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_compound level ss

and string_of_asm_compound level ss = 
  spaces level ^ "{\n" ^
  catmap "\n" (string_of_asm (level+1)) ss ^ "\n" ^
  spaces level ^ "}"

and short_string_of_asm_compound level ss =
  match ss with 
  | [] -> "{}"
  | _ -> "\n"^ string_of_asm_compound level ss

and special_string_of_typecode ty =  (* used for constructors *)
  match ty with
  | `TYP_tuple [] -> ""
  | _ -> " of " ^ string_of_typecode ty

and special_string_of_btypecode dfns ty =  (* used for constructors *)
  match ty with
  | `BTYP_tuple [] -> ""
  | _ -> " of " ^ string_of_btypecode dfns ty

and string_of_statement level s = 
  let se e = string_of_expr e in
  match s with 
  | `AST_interface (_,name, entries) ->
    spaces level ^
    "interface " ^ name ^ "{\n" ^
    (
      catmap "\n"
      (string_of_statement (level+1))
      entries
    ) ^ "\n" ^
    spaces level ^ "}\n"
    
  | `AST_module_binding (_,name,e) ->
    spaces level ^
    "module " ^ name ^ " = " ^
    se e ^ ";\n";

  | `AST_typed_functor (_,name,ps,res,ss) ->
    spaces level ^ 
    "functor " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_compound level ss

  | `AST_untyped_functor (_,name,ps,ss) ->
    spaces level ^ 
    "functor " ^ name ^ 
    "("^ (string_of_parameters ps)^")\n" ^
    string_of_compound level ss


  | `AST_export (_,flx_name,cpp_name) -> 
    spaces level ^ "export " ^ 
    string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

  | `AST_label (_,s) -> s ^ ":"
  | `AST_goto (_,s) -> spaces level ^ "goto " ^ s ^ ";"

  | `AST_comment s -> spaces level ^ "// " ^ s
  | `AST_open (_,n) -> 
    spaces level ^ "open " ^ string_of_qualified_name n ^ ";"
  

  | `AST_type_alias (_,t1,t2) ->
    spaces level ^ "type " ^ t1 ^ " = " ^ string_of_typecode t2 ^ ";"

  | `AST_type (_,t) ->
    spaces level ^ "type " ^ t ^ ";"

  | `AST_untyped_module (_,name, sts)  -> 
    spaces level ^ "module " ^ name ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts

  | `AST_typed_module (_,name, typ, sts)  -> 
    spaces level ^ "module " ^ name ^ ":" ^ 
    string_of_typecode typ ^ 
    " = " ^
    "\n" ^ 
    string_of_compound level sts

  | `AST_struct (_,name, cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_union (_,name, cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^ name ^ special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name ^ " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `AST_abs_decl (_,t,code) -> spaces level ^ 
   "type " ^ t ^ " = " ^ string_of_string code ^ ";"

  | `AST_fun_decl (_,name,args, result, code) ->
    spaces level ^ 
     "fun " ^ name ^ ": " ^ 
     (string_of_typecode (`TYP_tuple args)) ^ " -> " ^
     (string_of_typecode result) ^ 
     " = " ^ string_of_string code ^ ";"

  | `AST_proc_decl (_,name,args, code) ->
    spaces level ^ 
    "proc " ^ name ^ ": " ^ 
     (string_of_typecode (`TYP_tuple args)) ^
     " = " ^ string_of_string code ^ ";"

  | `AST_const_decl (_,name,typ, code) ->
    spaces level ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ ";" 

  | `AST_header (_,s) -> let triple_quote = "\"\"\"" in
    "header \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote

  | `AST_body (_,s) -> let triple_quote = "\"\"\"" in
    "body \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote

  | `AST_code (_,s) -> let triple_quote = "\"\"\"" in
    "code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote

  | `AST_noreturn_code (_,s) -> let triple_quote = "\"\"\"" in
    "noreturn_code \n" ^ triple_quote ^ "\n" ^ s ^ triple_quote

  | `AST_function (_,name, ps, res, ss) -> 
    spaces level ^ 
    "function " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_compound level ss

  | `AST_procedure (_,name, ps, ss) -> 
    spaces level ^ 
    "procedure " ^ name ^ 
    "("^ (string_of_parameters ps)^")" ^
    short_string_of_compound level ss

  | `AST_procedure_decl (_, name,t) ->
    spaces level ^
    "procedure " ^ name ^ ": " ^ string_of_typecode t ^ ";\n"

  | `AST_function_decl (_,name,t) ->
    spaces level ^
    "function " ^ name ^ ": " ^ string_of_typecode t ^ ";\n"

  | `AST_block (_,ss) -> string_of_compound level ss

  | `AST_val_decl (_,name, ty, value) ->
    spaces level ^ 
    "val " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"

  | `AST_var_decl (_,name, ty, value) ->
    spaces level ^ 
    "var " ^ name ^ 
    (
      match ty with 
      | Some t -> ": " ^ string_of_typecode t
      | None -> ""
    )
    ^ 
    (
      match value with 
      | Some e -> " = " ^ (se e) 
      | None -> ""
    )
    ^ ";"


  | `AST_call (_,pr, args) ->
    spaces level
    ^ "call " ^ se pr ^ " " ^ se args ^ ";"

  | `AST_nop (_,s) -> spaces level ^ "{/*"^s^"*/;}"

  | `AST_ifgoto (_,e,lab) ->
    spaces level ^
    "if("^string_of_expr e^")goto " ^ lab
    
  | `AST_ifnotgoto (_,e,lab) ->
    spaces level ^
    "if not("^string_of_expr e^")goto " ^ lab
  (*
  | `AST_if (_,clist, (_,s2)) ->
    begin catmap (spaces level ^ "else ")
      begin fun (sr, (e, s)) ->
        spaces level ^ "if " ^
        (se e) ^ " then\n" ^
        (string_of_statement (level+1) s) ^ "\n"
      end
      clist
    end
    ^ 
    begin match s2 with 
      | `AST_nop (_,"") -> ""
      | _ ->
        spaces level ^ "else\n" ^
        (string_of_statement (level+1) s2)
    end
  *)

  | `AST_except_handler (_,label,params,code) ->
    spaces level ^ "except " ^ label ^ " " ^ 
    "("^ (string_of_parameters params)^")"^
    short_string_of_compound level code

  | `AST_attempt (_,(_,main), (_,handlers), (fsr,finally)) ->
    spaces level ^ "attempt\n" ^
    string_of_statement (level+1) main ^ "\n" ^
    spaces level ^ "exceptions\n" ^
    spaces level ^ "{\n" ^
    catmap "\n" (string_of_statement (level+1)) handlers ^ "\n" ^
    (
      match finally with 
      | [] -> "" 
      | _ -> 
        spaces level ^ "finally\n" ^ 
        string_of_statement (level+1) 
          (`AST_block (fsr,finally))
    ) ^ "\n" ^
    spaces level ^ "}"
    

  | `AST_raise (_,label,e) -> 
    spaces level ^ "raise " ^ label ^
    begin match e with
    | `AST_tuple (_,[]) -> ""
    | expr -> " " ^ se expr
    end ^ 
    ";"

  | `AST_return (_,e) -> 
    spaces level ^ "return " ^ (se e) ^ ";"
    
  | `AST_read (_,name) ->
    spaces level ^ "read " ^ name ^ ";"

and string_of_compilation_unit stats =
  catmap "\n" (string_of_statement 0) stats

and string_of_desugared stats =
  catmap "\n" (string_of_asm 0) stats
  
and string_of_iface level s =
  let spc = spaces level in
  match s with
  | `IFACE_export (flx_name,cpp_name) -> 
    spc ^ "export " ^ string_of_suffixed_name flx_name ^ 
    " as \"" ^ cpp_name ^ "\";"

and string_of_symdef entry name = match entry with
  | `SYMDEF_var t -> 
    "variable " ^ string_of_typecode t ^ ";"
    
  | `SYMDEF_val t -> 
    "value " ^ string_of_typecode t ^ ";"
    
  | `SYMDEF_parameter t -> 
    "parameter " ^ string_of_typecode t ^ ";"
    
  | `SYMDEF_function (ps,res,es,nm,dir) -> 
    "function " ^ name ^ ": " ^ string_of_typecode 
    (
      `TYP_function 
      (
        (
          match List.map snd ps with
          | [x] -> x
          | x -> `TYP_tuple x
        )
        ,
        res
      )
    ) ^
    ";"
    
  | `SYMDEF_lazy (e) -> 
    "lazy " ^ name ^ ";"
    
  | `SYMDEF_match_check (pat,i)-> 
    "match_check " ^ name ^ " for " ^ string_of_pattern pat ^ ";"
  
  | `SYMDEF_match_handler (pat,i,es,_,dir) ->
    "match_handler " ^ name ^ " for " ^ string_of_pattern pat ^ ";"

  | `SYMDEF_interface (nm,dir) ->
    "interface " ^ name ^ ";"

  | `SYMDEF_typed_functor (ps,ret,es,nm,dir) ->
    "functor " ^ name ^ ";"

  | `SYMDEF_untyped_functor (ps,es,nm,dir) ->
    "functor " ^ name ^ ";"

  | `SYMDEF_module (table,dir) -> 
    "module " ^ name ^ ";"
    
  | `SYMDEF_if_type -> 
    "abstract_type " ^ name ^ ";"
    
  | `SYMDEF_if_proc t -> 
    "abstract_proc " ^ name ^ ": " ^ string_of_typecode t ^ ";"

  | `SYMDEF_if_fun t ->
    "abstract_function  " ^ name ^ string_of_typecode t ^ ";"

  | `SYMDEF_procedure (ps,es,nm,dir) ->
    "procedure " ^ name ^ ";"  
  
  | `SYMDEF_module_binding e ->
    "module_binding " ^ string_of_expr e ^ ";"

  | `SYMDEF_dcl d ->
    "declaration " ^ string_of_dcl 0 name d

and string_of_exe level s = 
  let spc = spaces level
  and se e = string_of_expr e 
  in
  match s with
  | `EXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | `EXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `EXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `EXE_label s -> s ^ ":"

  | `EXE_comment s -> spc ^ 
    "// " ^ s 

  | `EXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `EXE_read v -> spc ^ 
    "read " ^ v

  | `EXE_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | `EXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | `EXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | `EXE_noreturn_code s -> spc ^ 
    "noreturn_code " ^ string_of_string s 

  | `EXE_init (l,r) -> spc ^ 
    l ^ " := " ^ se r ^ ";"

and string_of_bound_expression dfns e = 
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match fst e with
  | `BEXPR_functions (name,fs) -> name ^ "<functions>"
  | `BEXPR_coercion (m,t) -> 
    "(" ^ 
    se m ^ 
    ": " ^
    string_of_btypecode dfns t ^ 
    ")"
  | `BEXPR_get_n (n,e') -> "(" ^ se e' ^ ").mem_" ^ string_of_int n

  | `BEXPR_deref e -> "*("^ se e ^ ")"
  | `BEXPR_name i -> sid i 
  | `BEXPR_closure i -> "closure(" ^ sid i ^ ")"
  | `BEXPR_ref i -> "&" ^ sid i
  | `BEXPR_literal e -> string_of_literal e
  | `BEXPR_apply  (fn, arg) -> "(" ^ 
    se fn ^ " " ^ 
    se arg ^ 
    ")"

  | `BEXPR_tuple t -> "(" ^ catmap ", " se t ^ ")"
  | `BEXPR_dot (e,n) ->  "get_<" ^ string_of_int n ^ ">(" ^ se e ^ ")"
  | `BEXPR_case (v,t) -> 
    "case " ^ string_of_int v ^ " of " ^ string_of_btypecode dfns t

  | `BEXPR_match_case (v,e) -> 
    "(match case " ^ string_of_int v ^ ")(" ^ se e ^ ")"
  | `BEXPR_case_arg (v,e) ->
    "(arg of case " ^ string_of_int v ^ " of " ^ se e ^ ")"

and string_of_biface dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BIFACE_export (index,cpp_name) ->
    spc ^ "export " ^ qualified_name_of_index dfns index ^ 
    " as \"" ^ cpp_name ^ "\";"

and string_of_bexe dfns level s = 
  let spc = spaces level in
  let se e = string_of_bound_expression dfns e in
  let sid n = qualified_name_of_index dfns n in
  match s with
  | `BEXE_goto s -> spc ^ "goto " ^ s ^ ";"

  | `BEXE_ifgoto (e,s) -> spc ^ 
     "if(" ^ se e ^ ")goto " ^ s ^ ";"

  | `BEXE_ifnotgoto (e,s) -> spc ^ 
     "if(not(" ^ se e ^ "))goto " ^ s ^ ";"

  | `BEXE_label s -> s ^ ":"

  | `BEXE_comment s -> spc ^ 
    "// " ^ s 

  | `BEXE_call (p,a) -> spc ^ 
    "call " ^ 
    se p ^ " " ^ 
    se a ^ ";"

  | `BEXE_read v -> spc ^ 
    "read " ^ sid v 

  | `BEXE_return x -> spc ^ 
    "return " ^ se x ^ ";"

  | `BEXE_nop s -> spc ^ 
    "/*" ^ s ^ "*/"

  | `BEXE_code s -> spc ^ 
    "code " ^ string_of_string s 

  | `BEXE_init (l,r) -> spc ^ 
    sid l ^ " := " ^ se r ^ ";"

and string_of_dcl level name s = 
  let se e = string_of_expr e in
  match s with
  | `DCL_type -> spaces level ^ "type " ^ name ^ ";\n"

  | `DCL_if_proc (t) ->
    spaces level ^ "procedure " ^ name ^ ": " ^ string_of_typecode t

  | `DCL_if_fun t ->
    spaces level ^ "function " ^ name ^ ": " ^ string_of_typecode t
  
  | `DCL_module_binding expr -> 
    spaces level ^
    "module " ^ name ^ " = "^se expr^" ;\n"

  | `DCL_lazy e -> "val "^name^"= lazy(" ^ se e ^ ");\n"

  | `DCL_header s -> "header " ^ string_of_string s
  | `DCL_body s -> "body " ^ string_of_string s

  | `DCL_type_alias (t2) ->
    spaces level ^ "type " ^ name ^ " = " ^ string_of_typecode t2 ^ ";"

  | `DCL_module asms -> 
    spaces level ^ "module " ^ name ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms 

  | `DCL_interface asms ->
    spaces level ^ "interface " ^ name ^ " = " ^
    "\n" ^ 
    string_of_asm_compound level asms


  | `DCL_struct (cs) -> 
    let string_of_struct_component (name,ty) =
      (spaces (level+1)) ^ name ^ ": " ^ string_of_typecode ty ^ ";"
    in
    spaces level ^ "struct " ^ name ^ " = " ^
    spaces level ^ "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_union (cs) -> 
    let string_of_union_component (name,ty) =
      (spaces (level+1)) ^ "|" ^name ^ special_string_of_typecode ty
    in
    spaces level ^ "union " ^ name ^ " = " ^
    spaces level ^ "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    spaces level ^ "}"

  | `DCL_abs (code) -> spaces level ^ 
   "type " ^ name ^ " = " ^ string_of_string code ^ ";"

  | `DCL_fun (args, result, code) ->
    let argtype:typecode_t = type_of_argtypes args in
    let t:typecode_t = `TYP_function (argtype,result) in
    spaces level ^ 
    "fun " ^ name ^ ": " ^ string_of_typecode t ^
    " = " ^ string_of_string code ^ ";"

  | `DCL_proc (args, code) ->
    spaces level ^ 
    "proc " ^ name ^ ": " ^ 
     (string_of_typecode (type_of_argtypes args)) ^
     " = " ^ string_of_string code ^ ";"

  | `DCL_const (typ, code) ->
    spaces level ^ 
     "const " ^ name ^ 
     ": " ^ string_of_typecode typ ^ 
     " = "^string_of_string code^ ";" 

  | `DCL_function (ps, res, ss) -> 
    spaces level ^ 
    "function " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_asm_compound level ss

  | `DCL_typed_functor (ps, res, ss) ->
    spaces level ^ 
    "function " ^ name ^ 
    "("^ (string_of_parameters ps)^"): "^(string_of_typecode res)^"\n" ^
    string_of_asm_compound level ss

  | `DCL_untyped_functor (ps, ss) ->
    spaces level ^ 
    "function " ^ name ^ 
    "("^ (string_of_parameters ps)^")\n" ^
    string_of_asm_compound level ss


  | `DCL_procedure (ps, ss) -> 
    spaces level ^ 
    "procedure " ^ name ^ 
    "("^ (string_of_parameters ps)^")" ^
    short_string_of_asm_compound level ss

  | `DCL_match_check (pat,s) ->
    spaces level ^ 
    "function " ^ name ^ "() { " ^ 
    s ^ " matches " ^ string_of_pattern pat ^
    " }"

  | `DCL_match_handler (pat,varname, sts) ->
    spaces level ^ 
    "match_handler " ^ name ^ 
    "(" ^ string_of_pattern pat ^ ")" ^
    string_of_asm_compound level sts

  | `DCL_val (ty) ->
    spaces level ^ 
    "val " ^ name ^ ": " ^ string_of_typecode ty ^ ";"

  | `DCL_var (ty) ->
    spaces level ^ 
    "var " ^ name ^ ": " ^ string_of_typecode ty ^ ";"

and string_of_asm level s =
  match s with
  | Dcl (sr,name,d) -> string_of_dcl level name d
  | Exe (sr,s) -> string_of_exe level s
  | Iface (sr,s) -> string_of_iface level s
  | Dir (sr,s) -> string_of_dir level s

and string_of_dir level s =
  match s with
  | DIR_open qn ->
    spaces level ^ "open " ^ string_of_qualified_name qn ^ ";"

and string_of_bbdcl dfns bbdcl index = 
  let name = qualified_name_of_index dfns index in
  let sobt t = string_of_btypecode dfns t in
  let se e = string_of_bound_expression dfns e in
  match bbdcl with
  | `BBDCL_header s -> "header " ^ string_of_string s
  | `BBDCL_body s -> "body " ^ string_of_string s

  | `BBDCL_function (ps,res,es,name_map) ->
    "function " ^ name ^ 
    "("^ (string_of_bparameters dfns ps)^"): "^(sobt res) ^
    "{\n" ^
    String.concat "\n" (List.map (string_of_bexe dfns 1) es) ^
    "}"

  
  | `BBDCL_procedure (ps,es,name_map) ->
    "procedure " ^ name ^ 
    "("^ (string_of_bparameters dfns ps)^")" ^
    "{\n" ^
    String.concat "\n" (List.map (string_of_bexe dfns 1) es) ^
    "}"

  | `BBDCL_val ty ->
    "val " ^ name ^ ": " ^ sobt ty ^ ";"

  | `BBDCL_var ty ->
    "var " ^ name ^ ": " ^ sobt ty ^ ";"

  (* binding structures [prolog] *)
  | `BBDCL_abs code ->
   "type " ^ name ^ " = " ^ string_of_string code ^ ";"

  | `BBDCL_const (ty,code) ->
     "const " ^ name ^ 
     ": " ^ sobt ty ^ 
     " = "^string_of_string code^ ";" 

  | `BBDCL_fun (ps,rt,code) ->
     "fun " ^ name ^ ": " ^ 
     (sobt (typeoflist ps)) ^ " -> " ^
     (sobt rt) ^ 
     " = " ^ string_of_string code ^ ";"

  | `BBDCL_proc (ps,code) ->
    "proc " ^ name ^ ": " ^ 
     (sobt (typeoflist ps)) ^
     " = " ^ string_of_string code ^ ";"

  | `BBDCL_union cs ->
    let string_of_union_component (name,ty) =
      "  " ^ "|" ^name ^ special_string_of_btypecode dfns ty
    in
    "union " ^ name ^ " = " ^
    "{\n" ^
    catmap ";\n" string_of_union_component cs ^ "\n" ^
    "}"

  | `BBDCL_struct cs ->
    let string_of_struct_component (name,ty) =
      "  " ^ name ^ ": " ^ sobt ty ^ ";"
    in
    "struct " ^ name ^ " = " ^
    "{\n" ^
    catmap "\n" string_of_struct_component cs ^ "\n" ^
    "}"

@h = tangler('src/flx_mtypes.ml')
@select(h)
module VarMap = Map.Make(struct type t = string let compare = compare end);;
type varmap_t = string VarMap.t

module TypecodeSet = Set.Make(
  struct type t = Flx_types.typecode_t let compare = compare end
)
type typecodeset_t = TypecodeSet.t

let typecodeset_of_list x = 
  let rec tsol x = match x with
  | h :: t -> TypecodeSet.add h (tsol t)
  | [] -> TypecodeSet.empty
  in tsol x

let typecodeset_map f x = typecodeset_of_list (List.map f (TypecodeSet.elements x))

@h = tangler('src/flx_mtypes.mli')
@select(h)
module VarMap :
  sig
    type key = string
    and 'a t
    val empty : 'a t
    val add : key -> 'a -> 'a t -> 'a t
    val find : key -> 'a t -> 'a
    val remove : key -> 'a t -> 'a t
    val mem : key -> 'a t -> bool
    val iter : (key -> 'a -> unit) -> 'a t -> unit
    val map : ('a -> 'b) -> 'a t -> 'b t
    val mapi : (key -> 'a -> 'b) -> 'a t -> 'b t
    val fold : (key -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
  end
type varmap_t = string VarMap.t
module TypecodeSet :
  sig
    type elt = Flx_types.typecode_t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end
type typecodeset_t = TypecodeSet.t
val typecodeset_of_list : TypecodeSet.elt list -> TypecodeSet.t
val typecodeset_map :
  (TypecodeSet.elt -> TypecodeSet.elt) -> TypecodeSet.t -> TypecodeSet.t

@head(1,'Compile time exceptions')
@python('//')
exceptions = """
exception SyntaxError of string
exception ParseError of string
exception LexError of string
exception TokenError of string
"""
//
@h = tangler('src/flx_exceptions.ml')
@select(h)
open Flx_types
@tangle(exceptions)
@h = tangler('src/flx_exceptions.mli')
@select(h)
open Flx_types
@tangle(exceptions)

@h = tangler('src/flx_typing.ml')
@select(h)
open Flx_types
open Flx_srcref

exception UnificationError of btypecode_t * btypecode_t

(* unbound type *)
let type_of_argtypes ls = match ls with
 | [x] -> x
 | _ -> `TYP_tuple ls

let funparamtype x = snd x

module FuntypeSet = Set.Make(
  struct type t=typecode_t let compare = compare end
)

(* bound type! *)
let typeoflist typlist = match typlist with
  | [t] -> t
  | _ -> `BTYP_tuple typlist

let rec lower t = match t with
  | `BTYP_binding (i,t) -> t
  | `BTYP_pointer t -> `BTYP_pointer (lower t)
  | `BTYP_tuple ts -> `BTYP_tuple (List.map lower ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map lower ts)
  | `BTYP_none -> `BTYP_none
  | `BTYP_void -> `BTYP_void
  | `BTYP_function (a,b) -> `BTYP_function (lower a, lower b)
  | `BTYP_name i -> `BTYP_name i
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> `BTYP_var i


let rec lift t = match t with
  | `BTYP_binding (i,t) -> i
  | `BTYP_pointer t -> `BTYP_pointer (lift t)
  | `BTYP_tuple ts -> `BTYP_tuple (List.map lift ts)
  | `BTYP_sum ts -> `BTYP_sum (List.map lift ts)
  | `BTYP_none -> `BTYP_none
  | `BTYP_void -> `BTYP_void
  | `BTYP_function (a,b) -> `BTYP_function (lift a, lift b)
  | `BTYP_name i -> `BTYP_name i
  | `BTYP_fix i -> `BTYP_fix i
  | `BTYP_var i -> `BTYP_var i

let rec unify dfns it mt = 
  let u it mt = unify dfns it mt in
  match it,mt with
  | (`BTYP_fix i, `BTYP_fix j) when i = j -> `BTYP_fix i
  | `BTYP_function (a,b), `BTYP_function(c,d) ->
    `BTYP_function (u a c, u b d)

  | `BTYP_pointer a, `BTYP_pointer b ->
    `BTYP_pointer (u a b)

  | `BTYP_tuple a, `BTYP_tuple b ->
    `BTYP_tuple (List.map2 u a b)

  | `BTYP_sum a, `BTYP_sum b ->
    `BTYP_sum (List.map2 u a b)

  | `BTYP_void, `BTYP_void -> `BTYP_void
  | `BTYP_none, `BTYP_none -> `BTYP_none
  | (`BTYP_var i, `BTYP_var j) when i = j -> `BTYP_var i
  | i,m -> `BTYP_binding (i,m)

let dummy_sr = ("generated",0,0,0,0)
let flx_bool = 
 `TYP_sum [`TYP_tuple[]; `TYP_tuple []]

let rec typecode_of_expr (e:expr_t) :typecode_t = 
  let te e = typecode_of_expr e in
  match e with 
  | #qualified_name_t as x -> (x:>typecode_t)
  | `AST_product (_,ts) -> `TYP_tuple (List.map te ts)
  | `AST_arrow (_,(a,b)) -> `TYP_function (te a, te b)
  | `AST_ref (sr,e) -> `TYP_pointer (te e)
  | `AST_sum (_,ts) -> 
    `TYP_sum (List.map te ts)

  | `AST_typeof (_,e) -> `TYP_typeof e
  | `AST_as (sr,(t,x)) -> `TYP_as (te t,x)

  | `AST_literal (sr,`AST_int (enc,v)) ->
    if enc <> "int" 
    then 
      failwith 
      (
        "Only plain integer can be used as a type, code= '" ^ 
        enc ^
        "'"
      )
    else 
    let v = ref 
      begin try Big_int.int_of_big_int v 
      with _ -> failwith ("Integer used as type out of range")
      end
    in
      if !v <0 then failwith "Negative int not allowed as type"
      else if !v >=2000 then failwith "Int used as type must be <2000"
      else if !v = 0 then ((`AST_void sr) :> typecode_t)
      else if !v = 1 then `TYP_tuple[]
      else begin 
        let u = `TYP_tuple [] in
        let t = ref [u] in
        while !v > 1 do
          t := u :: !t;
          decr v
        done;
        `TYP_sum !t
      end

  | #expr_t -> 
    failwith 
    (
      "Type expression expected in\n" ^
      short_string_of_src (src_of_expr e)
    )
    
let qualified_name_of_expr e =
  match e with
  | #qualified_name_t as x -> x
  | _ -> 
    failwith
    (
      "Qualified name expected in\n" ^
      short_string_of_src (src_of_expr e)
    )

 
@h = tangler('src/flx_typing.mli')
@select(h)
open Flx_types
exception UnificationError of btypecode_t * btypecode_t
val flx_bool : typecode_t
val dummy_sr: range_srcref

val type_of_argtypes : 
  typecode_t list -> 
  typecode_t
  
val funparamtype : 'a * 'b -> 'b

val typeoflist:
  btypecode_t list ->
  btypecode_t

val lift:
  btypecode_t -> btypecode_t

val lower:
  btypecode_t -> btypecode_t

val unify:
  symbol_table_t ->
  btypecode_t -> 
  btypecode_t ->
  btypecode_t 

val typecode_of_expr:
  expr_t -> typecode_t

val qualified_name_of_expr:
  expr_t -> qualified_name_t

module FuntypeSet :
  sig
    type elt = Flx_types.typecode_t
    and t
    val empty : t
    val is_empty : t -> bool
    val mem : elt -> t -> bool
    val add : elt -> t -> t
    val singleton : elt -> t
    val remove : elt -> t -> t
    val union : t -> t -> t
    val inter : t -> t -> t
    val diff : t -> t -> t
    val compare : t -> t -> int
    val equal : t -> t -> bool
    val subset : t -> t -> bool
    val iter : (elt -> unit) -> t -> unit
    val fold : (elt -> 'a -> 'a) -> t -> 'a -> 'a
    val for_all : (elt -> bool) -> t -> bool
    val exists : (elt -> bool) -> t -> bool
    val filter : (elt -> bool) -> t -> t
    val partition : (elt -> bool) -> t -> t * t
    val cardinal : t -> int
    val elements : t -> elt list
    val min_elt : t -> elt
    val max_elt : t -> elt
    val choose : t -> elt
  end

