@head(1,"Developer utility scripts")
@execfile('config/flx_data.py')
These script are NOT required to build Felix: they're utilies
related to munging the original code into interscript format,
and doing miscellaneous things during development.

@head(2,'Attempt to produce Texinfo document')
Hack up the tutorial: phase 1 of conversion to texinfo format.
@h = tangler('script/mktitut.sed','python')
@select(h)
s/@set_title('\(.*\)')/\\input texinfo\n@settitle \1/
s/@head(1,'\(.*\)')/@node \1\n@chapter \1/
s/@head(1,"\(.*\)")/@node \1\n@chapter \1/
s/@head(2,'\(.*\)')/@node \1\n@section \1/
s/@head(2,"\(.*\)")/@node \1\n@section \1/
s/@head(3,'\(.*\)')/@node \1\n@subsection \1/
s/@head(3,"\(.*\)")/@node \1\n@subsection \1/
s/@p()//
s/@select.*/@verbatim/
s/@doc()/@end verbatim/
s/@begin_displayed_code()/@verbatim/
s/@end_displayed_code()/@end verbatim/
s/@tdir =.*//
s/@execfile.*//
s/@h=//
s/@begin_table("\(.*\)","\(.*\)","\(.*\)")/@multitable @columnfractions .33 .33 .33\n@headitem \1 @tab \2 @tab \3/
s/@begin_table("\(.*\)","\(.*\)")/@multitable @columnfractions .5 .5\n@headitem \1 @tab \2/
s/@end_table()/@end multitable/
s/@table_row("\(.*\)","\(.*\)","\(.*\)")/@item \1 @tab \2 @tab \3/
s/@table_row("\(.*\)","\(.*\)")/@item \1 @tab \2/
s/\\uXXXX/@verb{ \\uXXXX }/
s/\\UXXXXXXXX/@verb{ \\UXXXXXXXX }/
s/\\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f/@verb{ \\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f }/
s/'else {}'\./@verb{.else {}.}/
s/"{" /@verb{ { }/
s/"}" /@verb{ } }/
@doc()
Now phase 2, a python script. There are some caveats
on what it can handle: it generates just one menu.
@h = tangler('script/mktitut.py','python')
@select(h)
# modify an texinfo file to add a menu of all the nodes
# read from stdin, write to stout
import sys

crap1 = """
@@copying
This manual is for Felix version 1.1.0. 
Copyright @copyright{} 2005 John Skaller
@@quotation
All rights relinquished, you can do whatever you
like with this manual.
@@end quotation
@@end copying

@@titlepage
@@title Felix Overview
@@subtitle A quick guide to the basic ideas
@@author John Skaller
@@page
@@vskip 0pt plus 1filll
@@insertcopying
@@end titlepage
@@contents

@@ifnottex
"""

crap2 = """
@@top Overview

@@insertcopying
@@end ifnottex
"""

cache = []
menu = []

def nav(node):
  for i in xrange(0,n):
    if node == menu[i]:
      if i == 0: prev = "Top"
      else: prev = menu[i-1]
      if i == n-1: next = "Top"
      else: next = menu[i+1]
      return next,prev

flag = 0
for line in sys.stdin:
  if flag == 0:
    if '@node ' == line[:6]:
      node = line[6:-1]
      flag = 1
      cache.append(line)
    else:
      cache.append(line)
  else:
    if '@chapter' == line[:8]:
      #print "chapter"
      menu.append(node)
    elif '@section' == line[:8]:
      #print "section"
      menu.append(node)
    elif '@subsection' == line[:11]:
      #print "subsection"
      menu.append(node)
    else:
      print "ERROR, need chapter section or subsection here"
      print "got ",line,
      raise "error" 
    cache.append('@section\n')
    flag = 0
  
  
n = len(menu)

for line in cache:
  if '@settitle' == line[:9]:
    print '@setfilename ' + sys.argv[1] # the filename
    print line,
    print crap1
    print "@node Top, "+menu[0]+", "+menu[n-1]+",(dir)"
    print crap2
    print '@menu'
    for item in menu:
      print "* " + item+":: "+item
    print '@end menu'
  elif '@node ' == line[:6]:
    node = line[6:-1]
    next,prev = nav(node)
    print '@node '+node+', '+next+', '+prev+', Top'
  else:
    print line,
print

@doc()
This is input to equiv-build, which makes
a dummy ocaml-3.08.3 package to satisfy
the debian package dependencies.
@h = tangler('misc/ocaml-nox-3.08.3-equiv','data')
@select(h)
Source: ocaml-nox-3.08.3
Section: devel
Priority: optional
Maintainer: John Skaller <skaller@users.sourceforge.net>
Standards-Version: 3.6.1

Package: ocaml-nox-3.08.3
Architecture: any
Description: hack to tell system 0caml3.08.3 is installed

@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mkjudy.py','python')
@select(h)
#
# Judy .. it's a bit of a mess .. macro threaded for
# code sharing
# 
import string
import os
import sys

prefix = '/home/skaller/judy/Judy-1.0.4/src'

files = [
  'Judy.h',

  'JudyCommon/JudyMalloc.c',
  'JudyCommon/JudyPrivate1L.h',
  'JudyCommon/JudyPrivateBranch.h',
  'JudyCommon/JudyPrivate.h',

  'Judy1/Judy1ByCount.c',
  'Judy1/Judy1Cascade.c',
  'Judy1/Judy1Count.c',
  'Judy1/Judy1CreateBranch.c',
  'Judy1/Judy1Decascade.c',
  'Judy1/Judy1First.c',
  'Judy1/Judy1FreeArray.c',
  'Judy1/Judy1.h',
  'Judy1/Judy1InsertBranch.c',
  'Judy1/Judy1MallocIF.c',
  'Judy1/Judy1MemActive.c',
  'Judy1/Judy1MemUsed.c',
  'Judy1/Judy1Next.c',
  'Judy1/Judy1NextEmpty.c',
  'Judy1/Judy1Prev.c',
  'Judy1/Judy1PrevEmpty.c',
  'Judy1/Judy1SetArray.c',
  'Judy1/Judy1Set.c',
  'Judy1/Judy1Tables.c',
  'Judy1/Judy1Tables32.c',
  'Judy1/Judy1Tables64.c',
  'Judy1/Judy1TablesGen.c',
  'Judy1/j__udy1Test.c',
  'Judy1/Judy1Test.c',
  'Judy1/Judy1Unset.c',

  'JudyL/JudyLByCount.c',
  'JudyL/JudyLCascade.c',
  'JudyL/JudyLCount.c',
  'JudyL/JudyLCreateBranch.c',
  'JudyL/JudyLDecascade.c',
  'JudyL/JudyLDel.c',
  'JudyL/JudyLFirst.c',
  'JudyL/JudyLFreeArray.c',
  'JudyL/j__udyLGet.c',
  'JudyL/JudyLGet.c',
  'JudyL/JudyL.h',
  'JudyL/JudyLInsArray.c',
  'JudyL/JudyLIns.c',
  'JudyL/JudyLInsertBranch.c',
  'JudyL/JudyLMallocIF.c',
  'JudyL/JudyLMemActive.c',
  'JudyL/JudyLMemUsed.c',
  'JudyL/JudyLNext.c',
  'JudyL/JudyLNextEmpty.c',
  'JudyL/JudyLPrev.c',
  'JudyL/JudyLPrevEmpty.c',
  'JudyL/JudyLTables.c',
  'JudyL/JudyLTables32.c',
  'JudyL/JudyLTables64.c',
  'JudyL/JudyLTablesGen.c',

  'JudyHS/JudyHS.c',
  'JudyHS/JudyHS.h',

  'JudySL/JudySL.c',
  ]

externs = [
# JUDY1 FUNCTIONS
  'Judy1Test',
  'Judy1Set',
  'Judy1SetArray',
  'Judy1Unset',
  'Judy1Count',
  'Judy1ByCount',
  'Judy1FreeArray',
  'Judy1MemUsed',
  'Judy1MemActive',
  'Judy1First',
  'Judy1Next',
  'Judy1Last',
  'Judy1Prev',
  'Judy1FirstEmpty',
  'Judy1NextEmpty',
  'Judy1LastEmpty',
  'Judy1PrevEmpty',
  'JudyLGet',
  'JudyLIns',
  'JudyLInsArray',
# JUDYL FUNCTIONS
  'JudyLDel',
  'JudyLCount',
  'JudyLByCount',
  'JudyLFreeArray',
  'JudyLMemUsed',
  'JudyLMemActive',
  'JudyLFirst',
  'JudyLNext',
  'JudyLLast',
  'JudyLPrev',
  'JudyLFirstEmpty',
  'JudyLNextEmpty',
  'JudyLLastEmpty',
  'JudyLPrevEmpty',
# JUDYSL FUNCTIONS
  'JudySLGet',
  'JudySLIns',
  'JudySLDel',
  'JudySLFreeArray',
  'JudySLFirst',
  'JudySLNext',
  'JudySLLast',
  'JudySLPrev',
# JUDYHSL FUNCTIONS:
  'JudyHSGet',
  'JudyHSIns',
  'JudyHSDel',
  'JudyHSFreeArray',
# JUDY memory interface to malloc
  'Judy1MallocSizes',
  'JudyLMallocSizes',
  'JudyMalloc',
  'JudyMallocVirtual',
  'JudyFree',
  'JudyFreeVirtual',
]

cph = '// Copyright (C) 2000 - 2002 Hewlett-Packard Company'
cpt = '// _________________'
cphn = len(cph)
cptn = len(cpt)

print "@execfile('config'+os.sep+'config.py')"
print "@head(1,'Judy')"
g = open("tmp.tmp","w")
for fn in files:
  copy = 1
  print "@h=tangler('judy/"+fn+"')"
  print "@select(h)"
  print "#ifndef JUDY_EXTERN"
  print "#if defined(_WIN32) && !defined(FLX_STATIC_LINK)"
  print "#ifdef BUILD_JUDY"
  print "#define JUDY_EXTERN __declspec(dllexport)"
  print "#else"
  print "#define JUDY_EXTERN __declspec(dllimport)"
  print "#endif"
  print "#else"
  print "#define JUDY_EXTERN"
  print "#endif"
  print "#endif"
  print
  print "#ifdef _WIN32"
  print "#define JU_WIN"
  print "#endif"
  print
  print
  f = open(prefix+'/'+fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    if line[:cphn]==cph:
      copy = 0
    if copy: 
      if line[:8]=="FUNCTION":
        s1 = string.split(line,"(")
        s2 = string.split(s1[0])
        if s2[1] in ["Word_t", "int", "PPvoid_t", "Pvoid_t"]:
          if s2[2][:4]=="Judy":
            t2 = [s2[0],s2[1],"JUDY_EXTERN"]+s2[2:]
            t2 = string.join(t2," ")
            t1 = [t2]+s1[1:]
            t1 = string.join(t1,"(")
            g.write(t1)
            line = t1+"\n"
      else:
        s1 = string.split(line,"(")
        s2 = string.split(s1[0])
        if len(s2)>=3 and s2[0]=='extern':
          if s2[2] in externs:
            t2 = [s2[0],s2[1],"JUDY_EXTERN"]+s2[2:]
            t2 = string.join(t2," ")
            t1 = [t2]+s1[1:]
            t1 = string.join(t1,"(")
            g.write(t1)
            line = t1+"\n"
      print line,
    if line[:cptn] == cpt:
      copy = 1
  print 
g.close()

print "@head(1,'Judy wrappers')"
compile = []

judycommon = [
  'JudyMalloc'
  ]

for i in judycommon:
  compile.append("judy/JudyCommon/"+i)

judy1 = [
  'Judy1ByCount',
  'Judy1Cascade',
  'Judy1Count',
  'Judy1CreateBranch',
  'Judy1Decascade',
  'Judy1First',
  'Judy1FreeArray',
  'Judy1InsertBranch',
  'Judy1MallocIF',
  'Judy1MemActive',
  'Judy1MemUsed',
  'Judy1SetArray',
  'Judy1Set',
  'Judy1Tables',
  'Judy1Unset',
  ]

for file in judy1:
  fn = 'judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print '#include "'+file+'.c"'
  print

judy1next = [
  'Judy1Next',
  'Judy1NextEmpty',
]

for file in judy1next:
  fn = 'judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print "#define JUDYNEXT"
  print '#include "'+file+'.c"'
  print


judy1prev = [
  'Judy1Prev',
  'Judy1PrevEmpty',
]

for file in judy1prev:
  fn = 'judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print "#define JUDYPREV"
  print '#include "'+file+'.c"'
  print

judy1get= [
  'Judy1Test',
  ]

for file in judy1get:
  fn='judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print '#include "'+file+'.c"'
  print

judy1geti = [
  'j__udy1Test',
  ]

for file in judy1geti:
  fn='judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print "#define JUDYGETINLINE"
  print '#include "'+file+'.c"'
  print


judyl = [
  'JudyLByCount',
  'JudyLCascade',
  'JudyLCount',
  'JudyLCreateBranch',
  'JudyLDecascade',
  'JudyLDel',
  'JudyLFirst',
  'JudyLFreeArray',
  'JudyLInsArray',
  'JudyLIns',
  'JudyLInsertBranch',
  'JudyLMemActive',
  'JudyLMemUsed',
  'JudyLMallocIF',
  'JudyLTables',
  ]

for file in judyl:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print '#include "'+file+'.c"'
  print


judylnext = [
  'JudyLNext',
  'JudyLNextEmpty',
  ]

for file in judylnext:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print "#define JUDYNEXT"
  print '#include "'+file+'.c"'
  print


judylprev = [
  'JudyLPrev',
  'JudyLPrevEmpty',
  ]

for file in judylprev:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print "#define JUDYPREV"
  print '#include "'+file+'.c"'
  print

judylget= [
  'JudyLGet',
  ]

for file in judylget:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print '#include "'+file+'.c"'
  print

judylgeti = [
  'j__udyLGet',
  ]

for file in judylgeti:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print "#define JUDYGETINLINE"
  print '#include "'+file+'.c"'
  print

judyHS = [
  'JudyHS'
  ]

for i in judyHS:
  compile.append("judy/JudyHS/"+i)

@# ------- source package -------------------------------

print "@head(1,'Judy source package')"
print "@select(tangler('spkgs/flx_judy.py'))"
print "rtl_interfaces = ['judy/Judy.h']"
print "cc_ccs = ["
for i in compile:
  print "  '"+i+"',"
print "  ]"

# this line is a HACK
print "include_path=['judy/Judy1', 'judy/JudyL', 'judy/JudyCommon', 'judy']"
print "if SIZEOF_VOIDP == 8:"
print "  macros=['JU_64BIT']"
print "else:"
print "  macros=['JU_32BIT']"

print "provides_lib = 'libflx_judy'"
print "iscr_source = ['lpsrc/flx_judy.pak']"
print "weaver_directory = 'doc/judy'"
print "build_macro = 'JUDY'"
print

@# ------- run time library  -------------------------------

print "@head(1,'Judy run time library')"
print "@select(tangler('config/flx_judy.fpc'))"
print '@if HAVE_MSVC:'
print '   tangle("provides_dlib: /DEFAULTLIB:libflx_judy_dynamic")'
print '   tangle("provides_slib: /DEFAULTLIB:libflx_judy_static")'
print ' else:'
print '   tangle("provides_dlib: -lflx_judy_dynamic")'
print '   tangle("provides_slib: -lflx_judy_static")'
print

@h = tangler('script/mkdemux.py','python')
@select(h)

import string
import os
import sys

prefix = '/Users/gchilds/UnNeko/walker/demux/'

tre_files = [
  'demuxer.h',
  'epoll_demuxer.h',
  'evtport_demuxer.h',
  'iocp_demuxer.h',
  'kqueue_demuxer.h',
  'pfileio.h',
  'posix_demuxer.h',
  'select_demuxer.h',
  'ts_select_demuxer.h',
  'timer_queue.h',
  'posix_timer_queue.h',
  'posix_timer_queue.cpp',
  'win_timer_queue.h',
  'win_timer_queue.cpp',
  'demuxer.cpp',
  'epoll_demuxer.cpp',
  'evtport_demuxer.cpp',
  'iocp_demuxer.cpp',
  'overlapped.cpp',
  'overlapped.h',
  'kqueue_demuxer.cpp',
  'pfileio.cpp',
  'posix_demuxer.cpp',
  'select_demuxer.cpp',
  'ts_select_demuxer.cpp',
  'sockety.h',
  'self_piper.h',
  'self_piper.cpp',
  ]

mods = {}
tgts = [] 

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'demux/demux_'+base
  if target[-1:]=='cpp':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'demux')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line,2)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "demux_'+fl[4:]+'"'
        else:
          print '#include "demux_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 

@h = tangler('script/mktre.py','python')
@select(h)

import string
import os
import sys

prefix = '/work/tre-0.7.2/lib/'

tre_files = [
  'gettext.h',
  'regcomp.c',
  'regerror.c',
  'regexec.c',
  'regex.h',
  'tre-ast.c',
  'tre-ast.h',
  'tre-compile.c',
  'tre-compile.h',
  'tre-config.h',
  'tre-filter.c',
  'tre-filter.h',
  'tre-internal.h',
  'tre-match-approx.c',
  'tre-match-backtrack.c',
  'tre-match-parallel.c',
  'tre-match-utils.h',
  'tre-mem.c',
  'tre-mem.h',
  'tre-parse.c',
  'tre-parse.h',
  'tre-stack.c',
  'tre-stack.h',
  'xmalloc.h',
  'xmalloc.c',
  ]

mods = {}
tgts = [] 

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'tre/tre_'+base
  if target[-1:]=='c':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'tre')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "tre_'+fl[4:]+'"'
        else:
          print '#include "tre_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 

@h = tangler('script/mksm.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/smbase/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
  'point.cc',
  'pprint.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

mods = {}
tgts = [] 

for fn in sm_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/sm_'+base
  if target[-2:]=='cc': 
    target = target[:-2]+'cpp'
  elif target[-1:]=='c':
    target = target[:-1]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'smbase')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkast.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/ast/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
#  'mypopen.h',
#  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
#  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
#  'mypopen.c',
#  'mysig.cc',
  'point.cc',
  'pprint.cc',
#  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]


ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]
mods = {}
tgts = [] 

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""


for fn in ast_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/ast_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

print "@head(1,'ast')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkelk.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/elkhound/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
#  'mypopen.h',
#  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
#  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
#  'mypopen.c',
#  'mysig.cc',
  'point.cc',
  'pprint.cc',
#  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]

elk_files = [
  'gramlex.lex',
  'grampar.y',
  'asockind.h',
  'emitcode.h',
  'flatutil.h',
  'genml.h',
  'glrconfig.h',
  'glr.h',
  'gramanl.h',
  'gramast.ast.gen.h',
  'grammar.h',
  'grampar.codes.h',
  'grampar.h',
  'grampar.tab.h',
  'lexerint.h',
  'mlsstr.h',
  'ownerspec.h',
  'parsetables.h',
  'ptreeact.h',
  'ptreenode.h',
  'rcptr.h',
  'useract.h',
  'util.h',
  'asockind.cc',
  'emitcode.cc',
  'genml.cc',
  'glr.cc',
  'gramanl.cc',
  'gramast.ast.gen.cc',
  'gramlex.yy.cc',
  'grampar.cc',
  'grampar.tab.cc',
  'grammar.cc',
  'mlsstr.cc',
  'parsetables.cc',
  'ptreeact.cc',
  'ptreenode.cc',
  'useract.cc',
  'gramexpl.cc'
]
mods = {}
tgts = [] 


for fn in elk_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/elk_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'elkhound')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      elif fl in elk_files:
        print '#include "elk_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkdypgen.py','python')
@select(h)

import string
import os

prefix = '/home/skaller/dypgen/dypgen'

dyplib = """
@@h = tangler('spkgs/dyplib.py')
@@select(h)
caml_interfaces = [
#  'dypgen/dyplib/sig',
  'dypgen/dyplib/dyp',
]

caml_implementations = [
  'dypgen/dyplib/priority_by_relation',
  'dypgen/dyplib/automaton',
  'dypgen/dyplib/gs',
#  'dypgen/dyplib/parser',
  'dypgen/dyplib/dyp',
]

#caml_pack = [
#  ("Dyp",'dypgen/dyplib/dyp',[ 
#    'dypgen/dyplib/sig',
#    'dypgen/dyplib/gs', 
#    'dypgen/dyplib/priority_by_relation',
#    'dypgen/dyplib/automaton',
#    'dypgen/dyplib/parser'
#  ])
#]

caml_include_paths=['dypgen/dyplib']
caml_provide_lib = 'dypgen/dyplib/dyplib'
iscr_source = ["lpsrc/dyp.pak"]
weaver_directory = 'doc/dypgen/'

"""

pgen = """
@@h = tangler('spkgs/pgen.py')
@@select(h)
caml_include_paths=['src','dypgen/dyplib','dypgen/generators/pgen']
caml_lexes = ['dypgen/generators/pgen/pgen_lexer']
caml_implementations=[
  'dypgen/generators/pgen/pgen_parser_param',
  'dypgen/generators/pgen/pgen_lexer'
]
caml_provide_lib = 'dypgen/generators/pgen/pgen'
caml_require_libs = ['flx_version','dyplib','pgen']
caml_exes = ['dypgen/generators/pgen/pgen']
iscr_source = ["lpsrc/dyp.pak"]
weaver_directory = 'doc/dypgen/'
pkg_requires = ['flx_version','dyplib']
"""

dypgen = """
@@h = tangler('spkgs/dypgen.py')
@@select(h)
caml_lexes = [
  'dypgen/generators/dypgen/dypgen_lexer', 
  'dypgen/generators/dypgen/insert_linenum'
]

caml_pgenparses = ['dypgen/generators/dypgen/dypgen_parser']
caml_interfaces =[
  'dypgen/generators/dypgen/parse_tree',
  'dypgen/generators/dypgen/dypgen_parser',
]
caml_implementations=[
  'dypgen/generators/dypgen/argument',
  'dypgen/generators/dypgen/dypgen_parser',
  'dypgen/generators/dypgen/dypgen_lexer',
  'dypgen/generators/dypgen/insert_linenum',
]
caml_include_paths=['src','dypgen/dyplib','dypgen/generators/dypgen']
caml_provide_lib = 'dypgen/generators/dypgen/dypgen'
caml_require_libs = ['flx_version','dyplib','dypgen']
caml_exes = ['dypgen/generators/dypgen/dypgen']
iscr_source = ["lpsrc/dyp.pak"]
pkg_requires = ['flx_version','dyplib','pgen']
weaver_directory = 'doc/dypgen/'
"""

files = [
  'dyplib/dyp.mli', 
#  'dyplib/sig.mli',
  'dyplib/automaton.ml',
#  'dyplib/parser.ml',
  'dyplib/dyp.ml',
  'dyplib/priority_by_relation.ml',
  'dyplib/gs.ml',
  'generators/pgen/pgen_lexer.mll',
  'generators/pgen/pgen.ml',  
  'generators/pgen/pgen_parser_param.ml',
  'generators/dypgen/dypgen_parser.dyp',
  'generators/dypgen/parse_tree.mli',
  'generators/dypgen/argument.ml',
  'generators/dypgen/dypgen.ml',
  'generators/dypgen/dypgen_lexer.mll',
  'generators/dypgen/insert_linenum.mll'
]

mods = {}
tgts = [] 

print "@head(1,'Dypgen')"
print dyplib
print pgen
print dypgen

for fn in files:
  print "@h=tangler('dypgen/"+fn+"')"
  print "@select(h)"
  f = open(prefix+'/'+fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
  print
 
@h = tangler('script/mkocs.py','python')
@select(h)

import string
import os

prefix = '/home/skaller/scheme/ocs-1.0.2/src/'

files = [
  'ocs_char.ml',
  'ocs_char.mli',
  'ocs_compile.ml',
  'ocs_compile.mli',
  'ocs_complex.ml',
  'ocs_complex.mli',
  'ocs_contin.ml',
  'ocs_contin.mli',
  'ocs_env.ml',
  'ocs_env.mli',
  'ocs_error.ml',
  'ocs_error.mli',
  'ocs_eval.ml',
  'ocs_eval.mli',
  'ocs_io.ml',
  'ocs_io.mli',
  'ocs_lex.ml',
  'ocs_lex.mli',
  'ocs_list.ml',
  'ocs_list.mli',
  'ocs_macro.ml',
  'ocs_macro.mli',
  'ocs_main.ml',
  'ocs_misc.ml',
  'ocs_misc.mli',
  'ocs_numaux.ml',
  'ocs_numaux.mli',
  'ocs_num.ml',
  'ocs_num.mli',
  'ocs_numstr.ml',
  'ocs_numstr.mli',
  'ocs_port.ml',
  'ocs_port.mli',
  'ocs_prim.ml',
  'ocs_prim.mli',
  'ocs_print.ml',
  'ocs_print.mli',
  'ocs_read.ml',
  'ocs_read.mli',
  'ocs_string.ml',
  'ocs_string.mli',
  'ocs_sym.ml',
  'ocs_sym.mli',
  'ocs_top.ml',
  'ocs_top.mli',
  'ocs_types.mli',
  'ocs_vartable.ml',
  'ocs_vartable.mli',
  'ocs_vector.ml',
  'ocs_vector.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'ocs/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'OCS')"
print """
@@h = tangler('spkgs/ocs.py')
@@select(h)
OCS_MODULES = [
  'ocs/ocs_vartable', 
  'ocs/ocs_error', 
  'ocs/ocs_port', 
  'ocs/ocs_types', 
  'ocs/ocs_sym', 
  'ocs/ocs_env',
  'ocs/ocs_char', 
  'ocs/ocs_numaux', 
  'ocs/ocs_complex', 
  'ocs/ocs_num', 
  'ocs/ocs_numstr', 
  'ocs/ocs_lex',
  'ocs/ocs_misc',
  'ocs/ocs_read', 
  'ocs/ocs_eval', 
  'ocs/ocs_list', 
  'ocs/ocs_compile', 
  'ocs/ocs_macro', 
  'ocs/ocs_prim', 
  'ocs/ocs_string',
  'ocs/ocs_vector', 
  'ocs/ocs_print', 
  'ocs/ocs_io', 
  'ocs/ocs_contin', 
  'ocs/ocs_top', 
]

caml_raw_interfaces = ['ocs/ocs_types']
caml_interfaces = OCS_MODULES
caml_implementations= OCS_MODULES
caml_include_paths = ['src','ocs']
caml_provide_lib = 'ocs/ocslib'
caml_require_libs = ['nums','unix','flx_version','ocslib']
caml_exes = ['ocs/ocs_main']
iscr_src= ['lpsrc/ocs.pak']
weaver_directory='doc/ocs'
pkg_requires = ['flx_version']
"""

for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/lua-5.0.2/src/'

files = [
  'lapi.c',
  'lapi.h',
  'lcode.c',
  'lcode.h',
  'ldebug.c',
  'ldebug.h',
  'ldo.c',
  'ldo.h',
  'ldump.c',
  'lfunc.c',
  'lfunc.h',
  'lgc.c',
  'lgc.h',
  'llex.c',
  'llex.h',
  'llimits.h',
  'lmem.c',
  'lmem.h',
  'lobject.c',
  'lobject.h',
  'lopcodes.c',
  'lopcodes.h',
  'lparser.c',
  'lparser.h',
  'lstate.c',
  'lstate.h',
  'lstring.c',
  'lstring.h',
  'ltable.c',
  'ltable.h',
  'ltests.c',
  'ltm.c',
  'ltm.h',
  'lundump.c',
  'lundump.h',
  'lvm.c',
  'lvm.h',
  'lzio.c',
  'lzio.h',
  'lib/lauxlib.c',
  'lib/lbaselib.c',
  'lib/ldblib.c',
  'lib/liolib.c',
  'lib/lmathlib.c',
  'lib/loadlib.c',
  'lib/lstrlib.c',
  'lib/ltablib.c',
  'luac/luac.c',
  'lua/lua.c',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[-1]=='c' :
    target = 'lua/'+base+'pp'
  else:
    target = 'lua/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'Lua')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua_scripts.py','python')
@select(h)

import string
import os
import glob

prefix = '/usr/local/src/lua-5.0.2/test/'
files = glob.glob(prefix+'*.lua')
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'misc/lua/'+base
  tgts.append((fn,target))

print "@head(1,'Lua test scripts')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,
      
@h = tangler('script/mk_fish','python')
@select(h)
import glob
glob = glob.glob

for i in glob("*.mli")+glob("*.mll")+glob("*.mly")+glob("*.ml"):
  if i not in ["parse_fish.ml","lex_fish.ml"]:
    print '@head(2,"'+i+'")'
    print i+"."
    print '@select(tangler("src/'+i+'"))'
    f = open(i)
    for j in f: print j,
    f.close()
    print


