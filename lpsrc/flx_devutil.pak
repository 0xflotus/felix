@head(1,"Developer utility scripts")
@execfile('config/flx_data.py')
$Log$
Revision 1.1  2006/02/14 09:02:00  skaller
Splitup flx_maker.ipk to get rid of some build utilities.

These script are NOT required to build Felix: they're utilies
related to munging the original code into interscript format,
and doing miscellaneous things during development.

@head(2,'Attempt to produce Texinfo document')
Hack up the tutorial: phase 1 of conversion to texinfo format.
@h = tangler('script/mktitut.sed','python')
@select(h)
s/@set_title('\(.*\)')/\\input texinfo\n@settitle \1/
s/@head(1,'\(.*\)')/@node \1\n@chapter \1/
s/@head(1,"\(.*\)")/@node \1\n@chapter \1/
s/@head(2,'\(.*\)')/@node \1\n@section \1/
s/@head(2,"\(.*\)")/@node \1\n@section \1/
s/@head(3,'\(.*\)')/@node \1\n@subsection \1/
s/@head(3,"\(.*\)")/@node \1\n@subsection \1/
s/@p()//
s/@select.*/@verbatim/
s/@doc()/@end verbatim/
s/@begin_displayed_code()/@verbatim/
s/@end_displayed_code()/@end verbatim/
s/@tdir =.*//
s/@execfile.*//
s/@h=//
s/@begin_table("\(.*\)","\(.*\)","\(.*\)")/@multitable @columnfractions .33 .33 .33\n@headitem \1 @tab \2 @tab \3/
s/@begin_table("\(.*\)","\(.*\)")/@multitable @columnfractions .5 .5\n@headitem \1 @tab \2/
s/@end_table()/@end multitable/
s/@table_row("\(.*\)","\(.*\)","\(.*\)")/@item \1 @tab \2 @tab \3/
s/@table_row("\(.*\)","\(.*\)")/@item \1 @tab \2/
s/\\uXXXX/@verb{ \\uXXXX }/
s/\\UXXXXXXXX/@verb{ \\UXXXXXXXX }/
s/\\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f/@verb{ \\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f }/
s/'else {}'\./@verb{.else {}.}/
s/"{" /@verb{ { }/
s/"}" /@verb{ } }/
@doc()
Now phase 2, a python script. There are some caveats
on what it can handle: it generates just one menu.
@h = tangler('script/mktitut.py','python')
@select(h)
# modify an texinfo file to add a menu of all the nodes
# read from stdin, write to stout
import sys

crap1 = """
@@copying
This manual is for Felix version 1.1.0. 
Copyright @copyright{} 2005 John Skaller
@@quotation
All rights relinquished, you can do whatever you
like with this manual.
@@end quotation
@@end copying

@@titlepage
@@title Felix Overview
@@subtitle A quick guide to the basic ideas
@@author John Skaller
@@page
@@vskip 0pt plus 1filll
@@insertcopying
@@end titlepage
@@contents

@@ifnottex
"""

crap2 = """
@@top Overview

@@insertcopying
@@end ifnottex
"""

cache = []
menu = []

def nav(node):
  for i in xrange(0,n):
    if node == menu[i]:
      if i == 0: prev = "Top"
      else: prev = menu[i-1]
      if i == n-1: next = "Top"
      else: next = menu[i+1]
      return next,prev

flag = 0
for line in sys.stdin:
  if flag == 0:
    if '@node ' == line[:6]:
      node = line[6:-1]
      flag = 1
      cache.append(line)
    else:
      cache.append(line)
  else:
    if '@chapter' == line[:8]:
      #print "chapter"
      menu.append(node)
    elif '@section' == line[:8]:
      #print "section"
      menu.append(node)
    elif '@subsection' == line[:11]:
      #print "subsection"
      menu.append(node)
    else:
      print "ERROR, need chapter section or subsection here"
      print "got ",line,
      raise "error" 
    cache.append('@section\n')
    flag = 0
  
  
n = len(menu)

for line in cache:
  if '@settitle' == line[:9]:
    print '@setfilename ' + sys.argv[1] # the filename
    print line,
    print crap1
    print "@node Top, "+menu[0]+", "+menu[n-1]+",(dir)"
    print crap2
    print '@menu'
    for item in menu:
      print "* " + item+":: "+item
    print '@end menu'
  elif '@node ' == line[:6]:
    node = line[6:-1]
    next,prev = nav(node)
    print '@node '+node+', '+next+', '+prev+', Top'
  else:
    print line,
print

@doc()
This is input to equiv-build, which makes
a dummy ocaml-3.08.3 package to satisfy
the debian package dependencies.
@h = tangler('misc/ocaml-nox-3.08.3-equiv','data')
@select(h)
Source: ocaml-nox-3.08.3
Section: devel
Priority: optional
Maintainer: John Skaller <skaller@users.sourceforge.net>
Standards-Version: 3.6.1

Package: ocaml-nox-3.08.3
Architecture: any
Description: hack to tell system 0caml3.08.3 is installed

@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mkdemux.py','python')
@select(h)

import string
import os
import sys

prefix = '/home/skaller/faio/demux/'

tre_files = [
  'demuxer.h',
  'epoll_demuxer.h',
  'evtport_demuxer.h',
  'iocp_demuxer.h',
  'kqueue_demuxer.h',
  'mutexlite.h',
  'pfileio.h',
  'posix_demuxer.h',
  'posix_queue.h',
  'select_demuxer.h',
  'sleep_queue.h',
  'sleep_task.h',
  'sockety.h',
  'work_fifo.h',
  'demuxer.cpp',
  'epoll_demuxer.cpp',
  'evtport_demuxer.cpp',
  'iocp_demuxer.cpp',
  'kqueue_demuxer.cpp',
  'mutexlite.cpp',
  'pfileio.cpp',
  'posix_demuxer.cpp',
  'posix_queue.cpp',
  'select_demuxer.cpp',
  'sleep_task.cpp',
  'unused.cpp',
  'work_fifo.cpp',
  'sockety.c',
  ]

mods = {}
tgts = [] 

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'demux/demux_'+base
  if target[-1:]=='cpp':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'demux')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line,2)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "demux_'+fl[4:]+'"'
        else:
          print '#include "demux_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 

@h = tangler('script/mktre.py','python')
@select(h)

import string
import os
import sys

prefix = '/work/tre-0.7.2/lib/'

tre_files = [
  'gettext.h',
  'regcomp.c',
  'regerror.c',
  'regexec.c',
  'regex.h',
  'tre-ast.c',
  'tre-ast.h',
  'tre-compile.c',
  'tre-compile.h',
  'tre-config.h',
  'tre-filter.c',
  'tre-filter.h',
  'tre-internal.h',
  'tre-match-approx.c',
  'tre-match-backtrack.c',
  'tre-match-parallel.c',
  'tre-match-utils.h',
  'tre-mem.c',
  'tre-mem.h',
  'tre-parse.c',
  'tre-parse.h',
  'tre-stack.c',
  'tre-stack.h',
  'xmalloc.h',
  'xmalloc.c',
  ]

mods = {}
tgts = [] 

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'tre/tre_'+base
  if target[-1:]=='c':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'tre')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "tre_'+fl[4:]+'"'
        else:
          print '#include "tre_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 

@h = tangler('script/mksm.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/smbase/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
  'point.cc',
  'pprint.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

mods = {}
tgts = [] 

for fn in sm_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/sm_'+base
  if target[-2:]=='cc': 
    target = target[:-2]+'cpp'
  elif target[-1:]=='c':
    target = target[:-1]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'smbase')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkast.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/ast/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
#  'mypopen.h',
#  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
#  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
#  'mypopen.c',
#  'mysig.cc',
  'point.cc',
  'pprint.cc',
#  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]


ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]
mods = {}
tgts = [] 

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""


for fn in ast_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/ast_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

print "@head(1,'ast')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkelk.py','python')
@select(h)

import string
import os
import sys

prefix = '/usr/local/src/elsa-2004.11.13/elkhound/'

sm_files = [
  'array.h',
  'arraymap.h',
  'arrayqueue.h',
  'astlist.h',
  'autofile.h',
  'bflatten.h',
  'bit2d.h',
  'bitarray.h',
  'boxprint.h',
  'breaker.h',
  'ckheap.h',
  'crc.h',
  'datablok.h',
  'exc.h',
  'flatten.h',
  'gprintf.h',
  'growbuf.h',
  'hashline.h',
  'hashtbl.h',
  'macros.h',
  'missing.h',
#  'mypopen.h',
#  'mysig.h',
  'nonport.h',
  'objlist.h',
  'objpool.h',
  'objstack.h',
  'ohashtbl.h',
  'okhasharr.h',
  'okhashtbl.h',
  'oobjmap.h',
  'owner.h',
  'point.h',
  'pprint.h',
  'ptrmap.h',
  'sm_flexlexer.h',
#  'smregexp.h',
  'sobjlist.h',
  'sobjset.h',
  'sobjstack.h',
  'srcloc.h',
  'strdict.h',
  'str.h',
  'strhash.h',
  'stringset.h',
  'strobjdict.h',
  'strsobjdict.h',
  'strtokp.h',
  'strutil.h',
  'svdict.h',
  'syserr.h',
  'taillist.h',
  'test.h',
  'thashtbl.h',
  'trace.h',
  'trdelete.h',
  'typ.h',
  'vdtllist.h',
  'voidlist.h',
  'vptrmap.h',
  'warn.h',
  'xassert.h',
  'xobjlist.h',
  'autofile.cc',
  'bflatten.cc',
  'bit2d.cc',
  'bitarray.cc',
  'boxprint.cc',
  'flatten.cc',
  'gprintf.c',
  'growbuf.cc',
  'hashline.cc',
  'hashtbl.cc',
#  'mypopen.c',
#  'mysig.cc',
  'point.cc',
  'pprint.cc',
#  'smregexp.cc',
  'srcloc.cc',
  'strdict.cc',
  'strhash.cc',
  'stringset.cc',
  'strutil.cc',
  'svdict.cc',
  'trace.cc',
  'trdelete.cc',
  'tsobjlist.cc',
  'vdtllist.cc',
  'voidlist.cc',
  'vptrmap.cc',
  'breaker.cpp',
  'crc.cpp',
  'datablok.cpp',
  'exc.cpp',
  'missing.cpp',
  'nonport.cpp',
  'str.cpp',
  'strtokp.cpp',
  'syserr.cpp',
  'warn.cpp',
  'malloc_stub.c',
]

ast_files = [
  'agramlex.lex',
  'agrampar.y',
  'agrampar.codes.h',
  'agrampar.h',
  'agrampar.tab.h',
  'ast.ast.h',
  'ast.hand.h',
  'asthelp.h',
  'ccsstr.h',
  'embedded.h',
  'fakelist.h',
  'gramlex.h',
  'locstr.h',
  'reporterr.h',
  'strtable.h',
  'agramlex.yy.cc',
  'agrampar.cc',
  'agrampar.tab.cc',
  'ast.ast.cc',
  'astgen.cc',
  'ast.hand.cc',
  'asthelp.cc',
  'ccsstr.cc',
  'embedded.cc',
  'gramlex.cc',
  'locstr.cc',
  'reporterr.cc',
  'strtable.cc',
  'towner.cc',
]

elk_files = [
  'gramlex.lex',
  'grampar.y',
  'asockind.h',
  'emitcode.h',
  'flatutil.h',
  'genml.h',
  'glrconfig.h',
  'glr.h',
  'gramanl.h',
  'gramast.ast.gen.h',
  'grammar.h',
  'grampar.codes.h',
  'grampar.h',
  'grampar.tab.h',
  'lexerint.h',
  'mlsstr.h',
  'ownerspec.h',
  'parsetables.h',
  'ptreeact.h',
  'ptreenode.h',
  'rcptr.h',
  'useract.h',
  'util.h',
  'asockind.cc',
  'emitcode.cc',
  'genml.cc',
  'glr.cc',
  'gramanl.cc',
  'gramast.ast.gen.cc',
  'gramlex.yy.cc',
  'grampar.cc',
  'grampar.tab.cc',
  'grammar.cc',
  'mlsstr.cc',
  'parsetables.cc',
  'ptreeact.cc',
  'ptreenode.cc',
  'useract.cc',
  'gramexpl.cc'
]
mods = {}
tgts = [] 


for fn in elk_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'elk/elk_'+base
  if target[-2:]=='cc': target = target[:-2]+'cpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'elkhound')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in sm_files:
        print '#include "sm_'+fl+'"'
      elif fl in ast_files:
        print '#include "ast_'+fl+'"'
      elif fl in elk_files:
        print '#include "elk_'+fl+'"'
      else:
        print "FILE:",fl," -- not known"
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,
 
@h = tangler('script/mkocs.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/ocs-1.0/src/'

files = [
  'ocs_char.ml',
  'ocs_char.mli',
  'ocs_compile.ml',
  'ocs_compile.mli',
  'ocs_complex.ml',
  'ocs_complex.mli',
  'ocs_contin.ml',
  'ocs_contin.mli',
  'ocs_env.ml',
  'ocs_env.mli',
  'ocs_error.ml',
  'ocs_eval.ml',
  'ocs_eval.mli',
  'ocs_io.ml',
  'ocs_io.mli',
  'ocs_lex.ml',
  'ocs_lex.mli',
  'ocs_list.ml',
  'ocs_list.mli',
  'ocs_macro.ml',
  'ocs_macro.mli',
  'ocs_main.ml',
  'ocs_misc.ml',
  'ocs_misc.mli',
  'ocs_numaux.ml',
  'ocs_numaux.mli',
  'ocs_num.ml',
  'ocs_num.mli',
  'ocs_numstr.ml',
  'ocs_numstr.mli',
  'ocs_port.ml',
  'ocs_port.mli',
  'ocs_prim.ml',
  'ocs_prim.mli',
  'ocs_print.ml',
  'ocs_print.mli',
  'ocs_read.ml',
  'ocs_read.mli',
  'ocs_string.ml',
  'ocs_string.mli',
  'ocs_sym.ml',
  'ocs_sym.mli',
  'ocs_top.ml',
  'ocs_top.mli',
  'ocs_types.mli',
  'ocs_vartable.ml',
  'ocs_vartable.mli',
  'ocs_vector.ml',
  'ocs_vector.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'OCS')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/lua-5.0.2/src/'

files = [
  'lapi.c',
  'lapi.h',
  'lcode.c',
  'lcode.h',
  'ldebug.c',
  'ldebug.h',
  'ldo.c',
  'ldo.h',
  'ldump.c',
  'lfunc.c',
  'lfunc.h',
  'lgc.c',
  'lgc.h',
  'llex.c',
  'llex.h',
  'llimits.h',
  'lmem.c',
  'lmem.h',
  'lobject.c',
  'lobject.h',
  'lopcodes.c',
  'lopcodes.h',
  'lparser.c',
  'lparser.h',
  'lstate.c',
  'lstate.h',
  'lstring.c',
  'lstring.h',
  'ltable.c',
  'ltable.h',
  'ltests.c',
  'ltm.c',
  'ltm.h',
  'lundump.c',
  'lundump.h',
  'lvm.c',
  'lvm.h',
  'lzio.c',
  'lzio.h',
  'lib/lauxlib.c',
  'lib/lbaselib.c',
  'lib/ldblib.c',
  'lib/liolib.c',
  'lib/lmathlib.c',
  'lib/loadlib.c',
  'lib/lstrlib.c',
  'lib/ltablib.c',
  'luac/luac.c',
  'lua/lua.c',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[-1]=='c' :
    target = 'lua/'+base+'pp'
  else:
    target = 'lua/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'Lua')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mklua_scripts.py','python')
@select(h)

import string
import os
import glob

prefix = '/usr/local/src/lua-5.0.2/test/'
files = glob.glob(prefix+'*.lua')
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'misc/lua/'+base
  tgts.append((fn,target))

print "@head(1,'Lua test scripts')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
 
@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = [] 

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,
      
@h = tangler('script/mk_fish','python')
@select(h)
import glob
glob = glob.glob

for i in glob("*.mli")+glob("*.mll")+glob("*.mly")+glob("*.ml"):
  if i not in ["parse_fish.ml","lex_fish.ml"]:
    print '@head(2,"'+i+'")'
    print i+"."
    print '@select(tangler("src/'+i+'"))'
    f = open(i)
    for j in f: print j,
    f.close()
    print


