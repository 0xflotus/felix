@head(1,"Developer utility scripts")
These script are NOT required to build Felix: they're utilies
related to munging the original code into interscript format,
and doing miscellaneous things during development.

@head(2,'Attempt to produce Texinfo document')
Hack up the tutorial: phase 1 of conversion to texinfo format.
@h = tangler('script/mktitut.sed','python')
@select(h)
s/@set_title('\(.*\)')/\\input texinfo\n@settitle \1/
s/@head(1,'\(.*\)')/@node \1\n@chapter \1/
s/@head(1,"\(.*\)")/@node \1\n@chapter \1/
s/@head(2,'\(.*\)')/@node \1\n@section \1/
s/@head(2,"\(.*\)")/@node \1\n@section \1/
s/@head(3,'\(.*\)')/@node \1\n@subsection \1/
s/@head(3,"\(.*\)")/@node \1\n@subsection \1/
s/@p()//
s/@select.*/@verbatim/
s/@doc()/@end verbatim/
s/@begin_displayed_code()/@verbatim/
s/@end_displayed_code()/@end verbatim/
s/@tdir =.*//
s/@execfile.*//
s/@h=//
s/@begin_table("\(.*\)","\(.*\)","\(.*\)")/@multitable @columnfractions .33 .33 .33\n@headitem \1 @tab \2 @tab \3/
s/@begin_table("\(.*\)","\(.*\)")/@multitable @columnfractions .5 .5\n@headitem \1 @tab \2/
s/@end_table()/@end multitable/
s/@table_row("\(.*\)","\(.*\)","\(.*\)")/@item \1 @tab \2 @tab \3/
s/@table_row("\(.*\)","\(.*\)")/@item \1 @tab \2/
s/\\uXXXX/@verb{ \\uXXXX }/
s/\\UXXXXXXXX/@verb{ \\UXXXXXXXX }/
s/\\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f/@verb{ \\\\, \\', \\", \\r, \\n, \\t, \\b, \\v, \\f }/
s/'else {}'\./@verb{.else {}.}/
s/"{" /@verb{ { }/
s/"}" /@verb{ } }/
@doc()
Now phase 2, a python script. There are some caveats
on what it can handle: it generates just one menu.
@h = tangler('script/mktitut.py','python')
@select(h)
# modify an texinfo file to add a menu of all the nodes
# read from stdin, write to stout
import sys

crap1 = """
@@copying
This manual is for Felix version 1.1.0.
Copyright @copyright{} 2005 John Skaller
@@quotation
All rights relinquished, you can do whatever you
like with this manual.
@@end quotation
@@end copying

@@titlepage
@@title Felix Overview
@@subtitle A quick guide to the basic ideas
@@author John Skaller
@@page
@@vskip 0pt plus 1filll
@@insertcopying
@@end titlepage
@@contents

@@ifnottex
"""

crap2 = """
@@top Overview

@@insertcopying
@@end ifnottex
"""

cache = []
menu = []

def nav(node):
  for i in xrange(0,n):
    if node == menu[i]:
      if i == 0: prev = "Top"
      else: prev = menu[i-1]
      if i == n-1: next = "Top"
      else: next = menu[i+1]
      return next,prev

flag = 0
for line in sys.stdin:
  if flag == 0:
    if '@node ' == line[:6]:
      node = line[6:-1]
      flag = 1
      cache.append(line)
    else:
      cache.append(line)
  else:
    if '@chapter' == line[:8]:
      #print "chapter"
      menu.append(node)
    elif '@section' == line[:8]:
      #print "section"
      menu.append(node)
    elif '@subsection' == line[:11]:
      #print "subsection"
      menu.append(node)
    else:
      print "ERROR, need chapter section or subsection here"
      print "got ",line,
      raise "error"
    cache.append('@section\n')
    flag = 0


n = len(menu)

for line in cache:
  if '@settitle' == line[:9]:
    print '@setfilename ' + sys.argv[1] # the filename
    print line,
    print crap1
    print "@node Top, "+menu[0]+", "+menu[n-1]+",(dir)"
    print crap2
    print '@menu'
    for item in menu:
      print "* " + item+":: "+item
    print '@end menu'
  elif '@node ' == line[:6]:
    node = line[6:-1]
    next,prev = nav(node)
    print '@node '+node+', '+next+', '+prev+', Top'
  else:
    print line,
print

@doc()
This is input to equiv-build, which makes
a dummy ocaml-3.08.3 package to satisfy
the debian package dependencies.
@h = tangler('misc/ocaml-nox-3.08.3-equiv','data')
@select(h)
Source: ocaml-nox-3.08.3
Section: devel
Priority: optional
Maintainer: John Skaller <skaller@users.sourceforge.net>
Standards-Version: 3.6.1

Package: ocaml-nox-3.08.3
Architecture: any
Description: hack to tell system 0caml3.08.3 is installed

@h = tangler('script/detab.py','python')
@select(h)
import string
import sys

f = open(sys.argv[1])
data = f.readlines()
f.close()
f = open(sys.argv[1],"w")
for line in data:
  line = string.expandtabs(line)
  f.write(line)
f.close()

@h = tangler('script/mkshoot.py','python')
@select(h)
import os
import sys
import glob
import string
root = "/home/skaller/shoot/shootout-scm-2007-05-14/shootout/bench"

dirs = glob.glob(root+"/*")
rejects = [
  "report.txt","LICENSE","Makefile","Makefile.mb","done.txt","Include","CVS",
  "tcprequest"]

def basename (f): return string.split(f,"/")[-1]

k = []
for f in dirs:
  base = basename (f)
  if base not in rejects:
    k.append(base)

k.sort()
#for d in k: print d

exts = [("gcc","c","c"),("ocaml","ml","ocaml"),("felix","flx","felix"),("gnat","ada","ada")]

print r"""
@def showgraph(machine,test,title):
  get_weaver()._write(
    '''<P></P><TABLE BORDER=2 ALIGN=center>
   <CAPTION>'''+title+'''</CAPTION>
   <TR><TD>
   <IMG ALT="'''+title+'''" SRC="machine/'''+machine+'''/images/'''+test+'''.jpg">
   </TD></TR></TABLE><P></P>
   ''')

@def showdata(fn):
  begin_displayed_code()
  try:
    f = open(fn)
    data = f.read()
    f.close()
    lines = string.split(data,'\n')
    for line in lines: weave(line+'\n')
  except:
    weave(fn+" not available\n")
  end_displayed_code()


@import glob
@raw_machs = glob.glob("speed/machine/*")
@machs = []
@for i in raw_machs: machs.append(i[14:])

"""

for d in k:
  #print "Bench = "+d
  print "@head(1,'["+d+"]')"
  print "@for i in machs:"
  print "  showgraph(i,'ack','"+d+" on '+i)"
  print "  showdata('speed/machine/'+i+'/rankings/"+d+".txt')"
  print
  print "@select(tangler('speed/specs/"+d+".py'))"
  print "descr='"+d+"'"
  print "min=5"
  print "max=10"
  print

  for tag,ext,dir in exts:
    #print "  Tag = " + tag+ ", ext = " + ext
    fls = glob.glob(root+"/"+d+"/*."+tag)
    for fn in fls:
      base = basename(fn)
      #print "    file = " + base
      bn = string.split(base,".")
      if len (bn) == 2:
        print "@select(tangler('speed/src/"+dir+"/"+bn[0]+"."+ext+"'))"
        fi = open(fn)
        lines = fi.read()
        print lines
        fi.close()





@h = tangler('script/mkjudy.py','python')
@select(h)
#
# Judy .. it's a bit of a mess .. macro threaded for
# code sharing
#
import string
import os
import sys

prefix = '/home/skaller/judy/Judy-1.0.4/src'

files = [
  'Judy.h',

  'JudyCommon/JudyMalloc.c',
  'JudyCommon/JudyPrivate1L.h',
  'JudyCommon/JudyPrivateBranch.h',
  'JudyCommon/JudyPrivate.h',

  'Judy1/Judy1ByCount.c',
  'Judy1/Judy1Cascade.c',
  'Judy1/Judy1Count.c',
  'Judy1/Judy1CreateBranch.c',
  'Judy1/Judy1Decascade.c',
  'Judy1/Judy1First.c',
  'Judy1/Judy1FreeArray.c',
  'Judy1/Judy1.h',
  'Judy1/Judy1InsertBranch.c',
  'Judy1/Judy1MallocIF.c',
  'Judy1/Judy1MemActive.c',
  'Judy1/Judy1MemUsed.c',
  'Judy1/Judy1Next.c',
  'Judy1/Judy1NextEmpty.c',
  'Judy1/Judy1Prev.c',
  'Judy1/Judy1PrevEmpty.c',
  'Judy1/Judy1SetArray.c',
  'Judy1/Judy1Set.c',
  'Judy1/Judy1Tables.c',
  'Judy1/Judy1Tables32.c',
  'Judy1/Judy1Tables64.c',
  'Judy1/Judy1TablesGen.c',
  'Judy1/j__udy1Test.c',
  'Judy1/Judy1Test.c',
  'Judy1/Judy1Unset.c',

  'JudyL/JudyLByCount.c',
  'JudyL/JudyLCascade.c',
  'JudyL/JudyLCount.c',
  'JudyL/JudyLCreateBranch.c',
  'JudyL/JudyLDecascade.c',
  'JudyL/JudyLDel.c',
  'JudyL/JudyLFirst.c',
  'JudyL/JudyLFreeArray.c',
  'JudyL/j__udyLGet.c',
  'JudyL/JudyLGet.c',
  'JudyL/JudyL.h',
  'JudyL/JudyLInsArray.c',
  'JudyL/JudyLIns.c',
  'JudyL/JudyLInsertBranch.c',
  'JudyL/JudyLMallocIF.c',
  'JudyL/JudyLMemActive.c',
  'JudyL/JudyLMemUsed.c',
  'JudyL/JudyLNext.c',
  'JudyL/JudyLNextEmpty.c',
  'JudyL/JudyLPrev.c',
  'JudyL/JudyLPrevEmpty.c',
  'JudyL/JudyLTables.c',
  'JudyL/JudyLTables32.c',
  'JudyL/JudyLTables64.c',
  'JudyL/JudyLTablesGen.c',

  'JudyHS/JudyHS.c',
  'JudyHS/JudyHS.h',

  'JudySL/JudySL.c',
  ]

externs = [
# JUDY1 FUNCTIONS
  'Judy1Test',
  'Judy1Set',
  'Judy1SetArray',
  'Judy1Unset',
  'Judy1Count',
  'Judy1ByCount',
  'Judy1FreeArray',
  'Judy1MemUsed',
  'Judy1MemActive',
  'Judy1First',
  'Judy1Next',
  'Judy1Last',
  'Judy1Prev',
  'Judy1FirstEmpty',
  'Judy1NextEmpty',
  'Judy1LastEmpty',
  'Judy1PrevEmpty',
  'JudyLGet',
  'JudyLIns',
  'JudyLInsArray',
# JUDYL FUNCTIONS
  'JudyLDel',
  'JudyLCount',
  'JudyLByCount',
  'JudyLFreeArray',
  'JudyLMemUsed',
  'JudyLMemActive',
  'JudyLFirst',
  'JudyLNext',
  'JudyLLast',
  'JudyLPrev',
  'JudyLFirstEmpty',
  'JudyLNextEmpty',
  'JudyLLastEmpty',
  'JudyLPrevEmpty',
# JUDYSL FUNCTIONS
  'JudySLGet',
  'JudySLIns',
  'JudySLDel',
  'JudySLFreeArray',
  'JudySLFirst',
  'JudySLNext',
  'JudySLLast',
  'JudySLPrev',
# JUDYHSL FUNCTIONS:
  'JudyHSGet',
  'JudyHSIns',
  'JudyHSDel',
  'JudyHSFreeArray',
# JUDY memory interface to malloc
  'Judy1MallocSizes',
  'JudyLMallocSizes',
  'JudyMalloc',
  'JudyMallocVirtual',
  'JudyFree',
  'JudyFreeVirtual',
]

cph = '// Copyright (C) 2000 - 2002 Hewlett-Packard Company'
cpt = '// _________________'
cphn = len(cph)
cptn = len(cpt)

print "@import config"
print "@head(1,'Judy')"
g = open("tmp.tmp","w")
for fn in files:
  copy = 1
  print "@h=tangler('judy/"+fn+"')"
  print "@select(h)"
  print "#ifndef JUDY_EXTERN"
  print "#if defined(_WIN32) && !defined(FLX_STATIC_LINK)"
  print "#ifdef BUILD_JUDY"
  print "#define JUDY_EXTERN __declspec(dllexport)"
  print "#else"
  print "#define JUDY_EXTERN __declspec(dllimport)"
  print "#endif"
  print "#else"
  print "#define JUDY_EXTERN"
  print "#endif"
  print "#endif"
  print
  print "/* here JU_WIN <=> MSVC CL build */"
  print "#ifdef _MSC_VER"
  print "#define JU_WIN"
  print "#endif"
  print
  print
  f = open(prefix+'/'+fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    if line[:cphn]==cph:
      copy = 0
    if copy:
      if line[:8]=="FUNCTION":
        s1 = string.split(line,"(")
        s2 = string.split(s1[0])
        if s2[1] in ["Word_t", "int", "PPvoid_t", "Pvoid_t"]:
          if s2[2][:4]=="Judy":
            t2 = [s2[0],s2[1],"JUDY_EXTERN"]+s2[2:]
            t2 = string.join(t2," ")
            t1 = [t2]+s1[1:]
            t1 = string.join(t1,"(")
            g.write(t1)
            line = t1+"\n"
      else:
        s1 = string.split(line,"(")
        s2 = string.split(s1[0])
        if len(s2)>=3 and s2[0]=='extern':
          if s2[2] in externs:
            t2 = [s2[0],s2[1],"JUDY_EXTERN"]+s2[2:]
            t2 = string.join(t2," ")
            t1 = [t2]+s1[1:]
            t1 = string.join(t1,"(")
            g.write(t1)
            line = t1+"\n"
      print line,
    if line[:cptn] == cpt:
      copy = 1
  print
g.close()

print "@head(1,'Judy wrappers')"
compile = []

judycommon = [
  'JudyMalloc'
  ]

for i in judycommon:
  compile.append("judy/JudyCommon/"+i)

judy1 = [
  'Judy1ByCount',
  'Judy1Cascade',
  'Judy1Count',
  'Judy1CreateBranch',
  'Judy1Decascade',
  'Judy1First',
  'Judy1FreeArray',
  'Judy1InsertBranch',
  'Judy1MallocIF',
  'Judy1MemActive',
  'Judy1MemUsed',
  'Judy1SetArray',
  'Judy1Set',
  'Judy1Tables',
  'Judy1Unset',
  ]

for file in judy1:
  fn = 'judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print '#include "'+file+'.c"'
  print

judy1next = [
  'Judy1Next',
  'Judy1NextEmpty',
]

for file in judy1next:
  fn = 'judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print "#define JUDYNEXT"
  print '#include "'+file+'.c"'
  print


judy1prev = [
  'Judy1Prev',
  'Judy1PrevEmpty',
]

for file in judy1prev:
  fn = 'judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print "#define JUDYPREV"
  print '#include "'+file+'.c"'
  print

judy1get= [
  'Judy1Test',
  ]

for file in judy1get:
  fn='judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print '#include "'+file+'.c"'
  print

judy1geti = [
  'j__udy1Test',
  ]

for file in judy1geti:
  fn='judy/Judy1/JUDY1_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDY1"
  print "#define JUDYGETINLINE"
  print '#include "'+file+'.c"'
  print


judyl = [
  'JudyLByCount',
  'JudyLCascade',
  'JudyLCount',
  'JudyLCreateBranch',
  'JudyLDecascade',
  'JudyLDel',
  'JudyLFirst',
  'JudyLFreeArray',
  'JudyLInsArray',
  'JudyLIns',
  'JudyLInsertBranch',
  'JudyLMemActive',
  'JudyLMemUsed',
  'JudyLMallocIF',
  'JudyLTables',
  ]

for file in judyl:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print '#include "'+file+'.c"'
  print


judylnext = [
  'JudyLNext',
  'JudyLNextEmpty',
  ]

for file in judylnext:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print "#define JUDYNEXT"
  print '#include "'+file+'.c"'
  print


judylprev = [
  'JudyLPrev',
  'JudyLPrevEmpty',
  ]

for file in judylprev:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print "#define JUDYPREV"
  print '#include "'+file+'.c"'
  print

judylget= [
  'JudyLGet',
  ]

for file in judylget:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print '#include "'+file+'.c"'
  print

judylgeti = [
  'j__udyLGet',
  ]

for file in judylgeti:
  fn='judy/JudyL/JUDYL_'+file
  compile.append(fn)
  print "@select(tangler('"+fn+".c'))"
  print "#define JUDYL"
  print "#define JUDYGETINLINE"
  print '#include "'+file+'.c"'
  print

judyHS = [
  'JudyHS'
  ]

for i in judyHS:
  compile.append("judy/JudyHS/"+i)

@# ------- source package -------------------------------

print "@head(1,'Judy source package')"
print "@select(tangler('spkgs/flx_judy.py'))"
print "rtl_interfaces = ['judy/Judy.h']"
print "cc_ccs = ["
for i in compile:
  print "  '"+i+"',"
print "  ]"

# this line is a HACK
print "include_path=['judy/Judy1', 'judy/JudyL', 'judy/JudyCommon', 'judy']"
print "if SIZEOF_VOIDP == 8:"
print "  macros=['JU_64BIT']"
print "else:"
print "  macros=['JU_32BIT']"

print "provides_lib = 'libflx_judy'"
print "iscr_source = ['lpsrc/flx_judy.pak']"
print "weaver_directory = 'doc/judy'"
print "build_macro = 'JUDY'"
print

@# ------- run time library  -------------------------------

print "@head(1,'Judy run time library')"
print "@select(tangler('config/flx_judy.fpc'))"
print '@if HAVE_MSVC:'
print '   tangle("provides_dlib: /DEFAULTLIB:flx_judy_dynamic")'
print '   tangle("provides_slib: /DEFAULTLIB:flx_judy_static")'
print ' else:'
print '   tangle("provides_dlib: -lflx_judy_dynamic")'
print '   tangle("provides_slib: -lflx_judy_static")'
print

@h = tangler('script/mkdemux.py','python')
@select(h)

import string
import os
import sys

prefix = '/Users/gchilds/UnNeko/walker/demux/'

tre_files = [
  'demuxer.h',
  'epoll_demuxer.h',
  'evtport_demuxer.h',
  'iocp_demuxer.h',
  'kqueue_demuxer.h',
  'pfileio.h',
  'posix_demuxer.h',
  'select_demuxer.h',
  'ts_select_demuxer.h',
  'timer_queue.h',
  'posix_timer_queue.h',
  'posix_timer_queue.cpp',
  'win_timer_queue.h',
  'win_timer_queue.cpp',
  'demuxer.cpp',
  'epoll_demuxer.cpp',
  'evtport_demuxer.cpp',
  'iocp_demuxer.cpp',
  'overlapped.cpp',
  'overlapped.h',
  'kqueue_demuxer.cpp',
  'pfileio.cpp',
  'posix_demuxer.cpp',
  'select_demuxer.cpp',
  'ts_select_demuxer.cpp',
  'sockety.h',
  'self_piper.h',
  'self_piper.cpp',
  ]

mods = {}
tgts = []

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'demux/demux_'+base
  if target[-1:]=='cpp':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'demux')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line,2)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "demux_'+fl[4:]+'"'
        else:
          print '#include "demux_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,


@h = tangler('script/mktre.py','python')
@select(h)

import string
import os
import sys

prefix = '/work/tre-0.7.2/lib/'

tre_files = [
  'gettext.h',
  'regcomp.c',
  'regerror.c',
  'regexec.c',
  'regex.h',
  'tre-ast.c',
  'tre-ast.h',
  'tre-compile.c',
  'tre-compile.h',
  'tre-config.h',
  'tre-filter.c',
  'tre-filter.h',
  'tre-internal.h',
  'tre-match-approx.c',
  'tre-match-backtrack.c',
  'tre-match-parallel.c',
  'tre-match-utils.h',
  'tre-mem.c',
  'tre-mem.h',
  'tre-parse.c',
  'tre-parse.h',
  'tre-stack.c',
  'tre-stack.h',
  'xmalloc.h',
  'xmalloc.c',
  ]

mods = {}
tgts = []

for fn in tre_files:
  parts = string.split(fn,'/')
  base = parts[-1]
  if base[0:4]=='tre-':
    target = 'tre/tre_'+base[4:]
  else:
    target = 'tre/tre_'+base
  if target[-1:]=='c':
    target = target[:-1]+'cpp'
  elif target[-1:]=='h':
    target = target[:-1]+'hpp'
  tgts.append((prefix+fn,target))

def index(line,ch):
  n = len (line)
  for i in range(0,n):
    if line[i]==ch: return i
  return -1

def incl(line):
  hp = index(line,'#')
  if hp == -1: return ""
  line = line[hp:]
  if line[:10]=='#include "':
    line=line[10:]
    qp = index(line,'"')
    if qp == -1: return ""
    return line[:qp]
  else:
    return ""

print "@head(1,'tre')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    fl = incl(line)
    if fl:
      if fl in tre_files:
        dot = index(fl,".")
        if dot > 0:
          fl = fl[:dot]
          fl = fl+'.hpp'
        if fl[0:4]=="tre-":
          print '#include "tre_'+fl[4:]+'"'
        else:
          print '#include "tre_'+fl+'"'
      else:
        print "UNKNOWN FILE:",fl
        sys.exit(1)
    else:
      if line[:5] != '#line':
        print line,


@h = tangler('script/mkdypgen.py','python')
@select(h)

import string
import os

prefix = '/home/skaller/dypgen/dypgen'

dyplib = """
@@h = tangler('spkgs/dyplib.py')
@@select(h)
caml_interfaces = [
#  'src/compiler/dyp/dyplib/sig',
  'src/compiler/dyp/dyplib/dyp',
]

caml_implementations = [
  'src/compiler/dyp/dyplib/priority_by_relation',
  'src/compiler/dyp/dyplib/automaton',
  'src/compiler/dyp/dyplib/gs',
#  'src/compiler/dyp/dyplib/parser',
  'src/compiler/dyp/dyplib/dyp',
]

#caml_pack = [
#  ("Dyp",'src/compiler/dyp/dyplib/dyp',[
#    'src/compiler/dyp/dyplib/sig',
#    'src/compiler/dyp/dyplib/gs',
#    'src/compiler/dyp/dyplib/priority_by_relation',
#    'src/compiler/dyp/dyplib/automaton',
#    'src/compiler/dyp/dyplib/parser'
#  ])
#]

caml_include_paths = ['dypgen/dyplib']
caml_provide_lib = 'src/compiler/dyp/dyplib/dyplib'
iscr_source = ["lpsrc/dyp.pak"]
weaver_directory = 'doc/dypgen/'

"""

pgen = """
@@h = tangler('spkgs/pgen.py')
@@select(h)
caml_include_paths=['src','dypgen/dyplib','dypgen/generators/pgen']
caml_lexes = ['dypgen/generators/pgen/pgen_lexer']
caml_implementations=[
  'src/compiler/dyp/generators/pgen/pgen_parser_param',
  'src/compiler/dyp/generators/pgen/pgen_lexer'
]
caml_provide_lib = 'src/compiler/dyp/generators/pgen/pgen'
caml_require_libs = ['flx_version','dyplib','pgen']
caml_exes = ['dypgen/generators/pgen/pgen']
iscr_source = ["lpsrc/dyp.pak"]
weaver_directory = 'doc/dypgen/'
pkg_requires = ['flx_version','dyplib']
"""

dypgen = """
@@h = tangler('spkgs/dypgen.py')
@@select(h)
caml_lexes = [
  'src/compiler/dyp/generators/dypgen/dypgen_lexer',
  'src/compiler/dyp/generators/dypgen/insert_linenum'
]

caml_pgenparses = ['src/compiler/dyp/generators/dypgen/dypgen_parser']
caml_interfaces =[
  'src/compiler/dyp/generators/dypgen/parse_tree',
  'src/compiler/dyp/generators/dypgen/dypgen_parser',
]
caml_implementations=[
  'src/compiler/dyp/generators/dypgen/argument',
  'src/compiler/dyp/generators/dypgen/dypgen_parser',
  'src/compiler/dyp/generators/dypgen/dypgen_lexer',
  'src/compiler/dyp/generators/dypgen/insert_linenum',
]
caml_include_paths=['src','dypgen/dyplib','dypgen/generators/dypgen']
caml_provide_lib = 'src/compiler/dyp/generators/dypgen/dypgen'
caml_require_libs = ['flx_version','dyplib','dypgen']
caml_exes = ['dypgen/generators/dypgen/dypgen']
iscr_source = ["lpsrc/dyp.pak"]
pkg_requires = ['flx_version','dyplib','pgen']
weaver_directory = 'doc/dypgen/'
"""

files = [
  'dyplib/dyp.mli',
#  'dyplib/sig.mli',
  'dyplib/automaton.ml',
#  'dyplib/parser.ml',
  'dyplib/dyp.ml',
  'dyplib/priority_by_relation.ml',
  'dyplib/gs.ml',
  'generators/pgen/pgen_lexer.mll',
  'generators/pgen/pgen.ml',
  'generators/pgen/pgen_parser_param.ml',
  'generators/dypgen/dypgen_parser.dyp',
  'generators/dypgen/parse_tree.mli',
  'generators/dypgen/argument.ml',
  'generators/dypgen/dypgen.ml',
  'generators/dypgen/dypgen_lexer.mll',
  'generators/dypgen/insert_linenum.mll'
]

mods = {}
tgts = []

print "@head(1,'Dypgen')"
print dyplib
print pgen
print dypgen

for fn in files:
  print "@h=tangler('dypgen/"+fn+"')"
  print "@select(h)"
  f = open(prefix+'/'+fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,
  print

@h = tangler('script/mkocs.py','python')
@select(h)

import string
import os

prefix = '/home/skaller/scheme/ocs-1.0.2/src/'

files = [
  'ocs_char.ml',
  'ocs_char.mli',
  'ocs_compile.ml',
  'ocs_compile.mli',
  'ocs_complex.ml',
  'ocs_complex.mli',
  'ocs_contin.ml',
  'ocs_contin.mli',
  'ocs_env.ml',
  'ocs_env.mli',
  'ocs_error.ml',
  'ocs_error.mli',
  'ocs_eval.ml',
  'ocs_eval.mli',
  'ocs_io.ml',
  'ocs_io.mli',
  'ocs_lex.ml',
  'ocs_lex.mli',
  'ocs_list.ml',
  'ocs_list.mli',
  'ocs_macro.ml',
  'ocs_macro.mli',
  'ocs_main.ml',
  'ocs_misc.ml',
  'ocs_misc.mli',
  'ocs_numaux.ml',
  'ocs_numaux.mli',
  'ocs_num.ml',
  'ocs_num.mli',
  'ocs_numstr.ml',
  'ocs_numstr.mli',
  'ocs_port.ml',
  'ocs_port.mli',
  'ocs_prim.ml',
  'ocs_prim.mli',
  'ocs_print.ml',
  'ocs_print.mli',
  'ocs_read.ml',
  'ocs_read.mli',
  'ocs_string.ml',
  'ocs_string.mli',
  'ocs_sym.ml',
  'ocs_sym.mli',
  'ocs_top.ml',
  'ocs_top.mli',
  'ocs_types.mli',
  'ocs_vartable.ml',
  'ocs_vartable.mli',
  'ocs_vector.ml',
  'ocs_vector.mli',
]

mods = {}
tgts = []

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'ocs/'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')

print "@head(1,'OCS')"
print """
@@h = tangler('spkgs/ocs.py')
@@select(h)
OCS_MODULES = [
  'ocs/ocs_vartable',
  'ocs/ocs_error',
  'ocs/ocs_port',
  'ocs/ocs_types',
  'ocs/ocs_sym',
  'ocs/ocs_env',
  'ocs/ocs_char',
  'ocs/ocs_numaux',
  'ocs/ocs_complex',
  'ocs/ocs_num',
  'ocs/ocs_numstr',
  'ocs/ocs_lex',
  'ocs/ocs_misc',
  'ocs/ocs_read',
  'ocs/ocs_eval',
  'ocs/ocs_list',
  'ocs/ocs_compile',
  'ocs/ocs_macro',
  'ocs/ocs_prim',
  'ocs/ocs_string',
  'ocs/ocs_vector',
  'ocs/ocs_print',
  'ocs/ocs_io',
  'ocs/ocs_contin',
  'ocs/ocs_top',
]

caml_raw_interfaces = ['ocs/ocs_types']
caml_interfaces = OCS_MODULES
caml_implementations= OCS_MODULES
caml_include_paths = ['src','ocs']
caml_provide_lib = 'src/compiler/ocs/ocslib'
caml_require_libs = ['nums','unix','flx_version','ocslib']
caml_exes = ['ocs/ocs_main']
iscr_src= ['lpsrc/ocs.pak']
weaver_directory='doc/ocs'
pkg_requires = ['flx_version']
"""

for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    print line,

@h = tangler('script/mkcil.py','python')
@select(h)

import string
import os

prefix = '/usr/local/src/cil/'
files = [
  'src/check.ml',
  'src/check.mli',
  'src/cil.ml',
  'src/cil.mli',
  'src/cilutil.ml',
  'src/clist.ml',
  'src/clist.mli',
  'src/escape.ml',
  'src/escape.mli',
  'src/formatcil.ml',
  'src/formatcil.mli',
  'src/formatlex.mll',
  'src/formatparse.mly',
  'src/libmaincil.ml',
  'src/maincil.ml',
  'src/mergecil.ml',
  'src/mergecil.mli',
  'src/rmtmps.ml',
  'src/rmtmps.mli',
  'src/testcil.ml',
  'src/frontc/cabs2cil.ml',
  'src/frontc/cabs2cil.mli',
  'src/frontc/cabs.ml',
  'src/frontc/cabsvisit.ml',
  'src/frontc/cabsvisit.mli',
  'src/frontc/clexer.mli',
  'src/frontc/clexer.mll',
  'src/frontc/cparser.mly',
  'src/frontc/cprint.ml',
  'src/frontc/frontc.ml',
  'src/frontc/frontc.mli',
  'src/frontc/lexerhack.ml',
  'src/frontc/patch.ml',
  'src/frontc/patch.mli',
  'ocamlutil/errormsg.ml',
  'ocamlutil/errormsg.mli',
  'ocamlutil/inthash.ml',
  'ocamlutil/pretty.ml',
  'ocamlutil/pretty.mli',
  'ocamlutil/stats.ml',
  'ocamlutil/stats.mli',
  'ocamlutil/trace.ml',
  'ocamlutil/trace.mli',
  'ocamlutil/util.ml',
  'ocamlutil/util.mli',
]

mods = {}
tgts = []

for fn in files:
  parts = string.split(fn,'/')
  base = parts[-1]
  target = 'src/flx_cil_'+base
  tgts.append((prefix+fn,target))
  i = string.index(base,'.')
  m = base[:i]
  mods[string.capitalize(m)]='Flx_cil_' + m

ms = mods.keys()
for k in ms:
  print mods[k]

print "@head(1,'CIL')"
for fn,tgt in tgts:
  print "@h=tangler('"+tgt+"')"
  print "@select(h)"
  f = open(fn)
  data = f.readlines()
  f.close()
  for line in data:
    line = string.expandtabs(line)
    for s in ms:
      r = mods[s]
      line = string.replace(line,s,r)
    print line,

@h = tangler('script/mk_fish','python')
@select(h)
import glob
glob = glob.glob

for i in glob("*.mli")+glob("*.mll")+glob("*.mly")+glob("*.ml"):
  if i not in ["parse_fish.ml","lex_fish.ml"]:
    print '@head(2,"'+i+'")'
    print i+"."
    print '@select(tangler("src/'+i+'"))'
    f = open(i)
    for j in f: print j,
    f.close()
    print


