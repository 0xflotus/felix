@head(1,'Cil package')
@select(tangler('licences/cil_licence.txt','data'))
Copyright (c) 2001-2002,
 George C. Necula    <necula@cs.berkeley.edu>
 Scott McPeak        <smcpeak@cs.berkeley.edu>
 Wes Weimer          <weimer@cs.berkeley.edu>
 Ben Liblit          <liblit@cs.berkeley.edu>
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are met:

1. Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

2. Redistributions in binary form must reproduce the above copyright notice,
this list of conditions and the following disclaimer in the documentation
and/or other materials provided with the distribution.

3. The names of the contributors may not be used to endorse or promote
products derived from this software without specific prior written
permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
POSSIBILITY OF SUCH DAMAGE.

(See http://www.opensource.org/licenses/bsd-license.php)

@h = tangler('src/compiler/cil/flx_cil_cilversion.mli')
@select(h)
val cilVersionMajor:int
val cilVersionMinor:int
val cilVersionRev:int
val cilVersion:string


@h = tangler('src/compiler/cil/flx_cil_cilversion.ml')
@select(h)
let cilVersionMajor = 1
let cilVersionMinor = 2
let cilVersionRev   = 5
let cilVersion      = "1.2.5"

@h = tangler('src/compiler/cil/flx_cil_machdep_type.mli')
@select(h)
@ctypes = [
  'bool',
  'cbool',
  'int',
  'short',
  'long',
  'longlong',
  'enum',
  'wchar',
  'size',

  'float',
  'double',
  'longdouble',

  'complex',
  'doublecomplex',
  'longdoublecomplex',

  'imaginary',
  'doubleimaginary',
  'longdoubleimaginary',
  ]

@def dcl(a):
  tangle("  sizeof_" + a.lower() + " : int;")
  tangle("  alignof_" + a.lower() + " : int;")


type mach = {
  version_major: int;     (* Major version number *)
  version_minor: int;     (* Minor version number *)
  version: string;        (* version number *)
  underscore_name: bool;  (* If assembly names have leading underscore *)

@for x in ctypes: dcl(x)

  sizeof_ptr: int;        (* Size of pointers *)
  sizeof_void: int;       (* Size of "void" *)
  sizeof_fun: int;        (* Size of function *)

  alignof_str: int;       (* Alignment of strings *)
  alignof_fun: int;       (* Alignment of function *)
  char_is_unsigned: bool; (* Whether "char" is unsigned *)
  const_string_literals: bool; (* Whether string literals have const chars *)
  little_endian: bool; (* whether the machine is little endian *)
}

@h = tangler('src/compiler/cil/flx_cil_machdep.mli')
@select(h)
open Flx_cil_machdep_type
val gcc:mach
val msvc:mach
val hasMSVC:bool
val gccHas__builtin_va_list:bool
val __thread_is_keyword:bool

@h = tangler('src/compiler/cil/flx_cil_machdep.ml')
@select(h)
open Flx_cil_machdep_type

let gcc:mach = {
  version_major    = 3;
  version_minor    = 2;
  version          = "3.2.2 20030222 (Red Hat Linux 3.2.2-5)";
  underscore_name  = true;

@tangle("  alignof_str = 1;")
@tangle("  alignof_fun = 1;")
@tangle("  sizeof_void      = 1;")
@tangle("  sizeof_fun       = 1;")
@tangle("  sizeof_ptr       = "+str(SIZEOF_VOIDP)+";")

@def pr(a):
  d= globals()
  v = d.get("SIZEOF_"+a.upper(),0)
  tangle("  sizeof_" + a.lower() + " = " + str(v) + ";")
  v = d.get("ALIGNOF_"+a.upper(),0)
  tangle("  alignof_" + a.lower() + " = " + str(v) + ";")

@for x in ctypes: pr(x)

@if CHAR_IS_UNSIGNED:
   tangle("  char_is_unsigned = true;")
 else:
   tangle("  char_is_unsigned = false;")
@tangle("  const_string_literals = true;")
@if LITTLE_ENDIAN:
   tangle("  little_endian = true;")
 else:
   tangle("  little_endian = false;")
}
@if HAVE_MSVC:
   tangle("let hasMSVC = true")
 else:
   tangle("let hasMSVC = false")

let msvc = gcc (* hackery .. *)
let gccHas__builtin_va_list = true
let __thread_is_keyword = true


@h=tangler('src/compiler/cil/flx_cil_check.ml')
@select(h)

(* A consistency checker for CIL *)
open Flx_cil_cil
module E = Flx_cil_errormsg
module H = Hashtbl
open Flx_cil_pretty


(* A few parameters to customize the checking *)
type checkFlags =
    NoFlx_cil_checkGlobalIds   (* Do not check that the global ids have the proper
                        * hash value *)

let checkGlobalIds = ref true

  (* Attributes must be sorted *)
type ctxAttr =
    CALocal                             (* Attribute of a local variable *)
  | CAGlobal                            (* Attribute of a global variable *)
  | CAType                              (* Attribute of a type *)

let valid = ref true

let warn fmt =
  valid := false;
  Flx_cil_cil.warn fmt

let warnContext fmt =
  valid := false;
  Flx_cil_cil.warnContext fmt

let checkAttributes (attrs: attribute list) : unit =
  let rec loop lastname = function
      [] -> ()
    | (Attr(an, _) as a) :: resta ->
        if an < lastname then
          ignore (warn "Attributes not sorted");
        loop an resta
  in
  loop "" attrs


  (* Keep track of defined types *)
let typeDefs : (string, typ) H.t = H.create 117


  (* Keep track of all variables names, enum tags and type names *)
let varNamesEnv : (string, unit) H.t = H.create 117

  (* We also keep a map of variables indexed by id, to ensure that only one
   * varinfo has a given id *)
let varIdsEnv: (int, varinfo) H.t = H.create 117

  (* And keep track of all varinfo's to check the uniqueness of the
   * identifiers *)
let allVarIds: (int, varinfo) H.t = H.create 117

 (* Also keep a list of environments. We place an empty string in the list to
  * mark the start of a local environment (i.e. a function) *)
let varNamesList : (string * int) list ref = ref []
let defineName s =
  if s = "" then
    E.s (bug "Empty name\n");
  if H.mem varNamesEnv s then
    ignore (warn "Multiple definitions for %s\n" s);
  H.add varNamesEnv s ()

let defineVariable vi =
  defineName vi.vname;
  varNamesList := (vi.vname, vi.vid) :: !varNamesList;
  (* Flx_cil_check the id *)
  if H.mem allVarIds vi.vid then
    ignore (warn "Id %d is already defined (%s)\n" vi.vid vi.vname);
  H.add allVarIds vi.vid vi;
  (* And register it in the current scope also *)
  H.add varIdsEnv vi.vid vi

(* Flx_cil_check that a varinfo has already been registered *)
let checkVariable vi =
  try
    (* Flx_cil_check in the current scope only *)
    if vi != H.find varIdsEnv vi.vid then
      ignore (warnContext "varinfos for %s not shared\n" vi.vname);
  with Not_found ->
    ignore (warn "Unknown id (%d) for %s\n" vi.vid vi.vname)


let startEnv () =
  varNamesList := ("", -1) :: !varNamesList

let endEnv () =
  let rec loop = function
      [] -> E.s (bug "Cannot find start of env")
    | ("", _) :: rest -> varNamesList := rest
    | (s, id) :: rest -> begin
        H.remove varNamesEnv s;
        H.remove varIdsEnv id;
        loop rest
    end
  in
  loop !varNamesList



(* The current function being checked *)
let currentReturnType : typ ref = ref voidType

(* A map of labels in the current function *)
let labels: (string, unit) H.t = H.create 17

(* A list of statements seen in the current function *)
let statements: stmt list ref = ref []

(* A list of the targets of Gotos *)
let gotoTargets: (string * stmt) list ref = ref []

(*** TYPES ***)
(* Cetain types can only occur in some contexts, so keep a list of context *)
type ctxType =
    CTStruct                            (* In a composite type *)
  | CTUnion
  | CTFArg                              (* In a function argument type *)
  | CTFRes                              (* In a function result type *)
  | CTArray                             (* In an array type *)
  | CTPtr                               (* In a pointer type *)
  | CTExp                               (* In an expression, as the type of
                                         * the result of binary operators, or
                                         * in a cast *)
  | CTSizeof                            (* In a sizeof *)
  | CTDecl                              (* In a typedef, or a declaration *)

let d_context () = function
    CTStruct -> text "CTStruct"
  | CTUnion -> text "CTUnion"
  | CTFArg -> text "CTFArg"
  | CTFRes -> text "CTFRes"
  | CTArray -> text "CTArray"
  | CTPtr -> text "CTPtr"
  | CTExp -> text "CTExp"
  | CTSizeof -> text "CTSizeof"
  | CTDecl -> text "CTDecl"


(* Keep track of all tags that we use. For each tag remember also the info
 * structure and a flag whether it was actually defined or just used. A
 * forward declaration acts as a definition. *)
type defuse =
    Defined (* We actually have seen a definition of this tag *)
  | Forward (* We have seen a forward declaration for it. This is done using
             * a GType with an empty type name *)
  | Used    (* Only uses *)
let compUsed : (int, compinfo * defuse ref) H.t = H.create 117
let enumUsed : (string, enuminfo * defuse ref) H.t = H.create 117
let typUsed  : (string, typeinfo * defuse ref) H.t = H.create 117

(* For composite types we also check that the names are unique *)
let compNames : (string, unit) H.t = H.create 17


  (* Flx_cil_check a type *)
let rec checkType (t: typ) (ctx: ctxType) =
  (* Flx_cil_check that it appears in the right context *)
  let rec checkContext = function
      TVoid _ -> ctx = CTPtr || ctx = CTFRes || ctx = CTDecl
    | TNamed (ti, a) -> checkContext ti.ttype
    | TArray _ ->
        (ctx = CTStruct || ctx = CTUnion
         || ctx = CTSizeof || ctx = CTDecl || ctx = CTArray || ctx = CTPtr)
    | TComp _ -> ctx <> CTExp
    | _ -> true
  in
  if not (checkContext t) then
    ignore (warn "Type (%a) used in wrong context. Expected context: %a"
              d_plaintype t d_context ctx);
  match t with
    (TVoid a | TBuiltin_va_list a) -> checkAttributes a
  | TInt (ik, a) -> checkAttributes a
  | TFloat (_, a) -> checkAttributes a
  | TPtr (t, a) -> checkAttributes a;  checkType t CTPtr

  | TNamed (ti, a) ->
      checkAttributes a;
      if ti.tname = "" then
        ignore (warnContext "Using a typeinfo for an empty-named type\n");
      checkTypeInfo Used ti

  | TComp (comp, a) ->
      checkAttributes a;
      (* Mark it as a forward. We'll check it later. If we try to check it
       * now we might encounter undefined types *)
      checkCompInfo Used comp


  | TEnum (enum, a) -> begin
      checkAttributes a;
      checkEnumInfo Used enum
  end

  | TArray(bt, len, a) ->
      checkAttributes a;
      checkType bt CTArray;
      (match len with
        None -> ()
      | Some l -> begin
          let t = checkExp true l in
          match t with
            TInt((IInt|IUInt), _) -> ()
          | _ -> E.s (bug "Type of array length is not integer")
      end)

  | TFun (rt, targs, isva, a) ->
      checkAttributes a;
      checkType rt CTFRes;
      List.iter
        (fun (an, at, aa) ->
          checkType at CTFArg;
          checkAttributes aa) (argsToList targs)

(* Flx_cil_check that a type is a promoted integral type *)
and checkIntegralType (t: typ) =
  checkType t CTExp;
  match unrollType t with
    TInt _ -> ()
  | _ -> ignore (warn "Non-integral type")

(* Flx_cil_check that a type is a promoted arithmetic type *)
and checkArithmeticType (t: typ) =
  checkType t CTExp;
  match unrollType t with
    TInt _ | TFloat _ -> ()
  | _ -> ignore (warn "Non-arithmetic type")

(* Flx_cil_check that a type is a promoted boolean type *)
and checkBooleanType (t: typ) =
  checkType t CTExp;
  match unrollType t with
    TInt _ | TFloat _ | TPtr _ -> ()
  | _ -> ignore (warn "Non-boolean type")


(* Flx_cil_check that a type is a pointer type *)
and checkPointerType (t: typ) =
  checkType t CTExp;
  match unrollType t with
    TPtr _ -> ()
  | _ -> ignore (warn "Non-pointer type")


and typeMatch (t1: typ) (t2: typ) =
  if typeSig t1 <> typeSig t2 then
    match unrollType t1, unrollType t2 with
    (* Allow free interchange of TInt and TEnum *)
      TInt (IInt, _), TEnum _ -> ()
    | TEnum _, TInt (IInt, _) -> ()

    | _, _ -> ignore (warn "Type mismatch:@!    %a@!and %a@!"
                        d_type t1 d_type t2)

and checkCompInfo (isadef: defuse) comp =
  let fullname = compFullName comp in
  try
    let oldci, olddef = H.find compUsed comp.ckey in
    (* Flx_cil_check that it is the same *)
    if oldci != comp then
      ignore (warnContext "compinfo for %s not shared\n" fullname);
    (match !olddef, isadef with
    | Defined, Defined ->
        ignore (warnContext "Multiple definition of %s\n" fullname)
    | _, Defined -> olddef := Defined
    | Defined, _ -> ()
    | _, Forward -> olddef := Forward
    | _, _ -> ())
  with Not_found -> begin (* This is the first time we see it *)
    (* Flx_cil_check that the name is not empty *)
    if comp.cname = "" then
      E.s (bug "Compinfo with empty name");
    (* Flx_cil_check that the name is unique *)
    if H.mem compNames fullname then
      ignore (warn "Duplicate name %s" fullname);
    (* Add it to the map before we go on *)
    H.add compUsed comp.ckey (comp, ref isadef);
    H.add compNames fullname ();
    (* Do not check the compinfo unless this is a definition. Otherwise you
     * might run into undefined types. *)
    if isadef = Defined then begin
      checkAttributes comp.cattr;
      let fctx = if comp.cstruct then CTStruct else CTUnion in
      let rec checkField f =
        if not
            (f.fcomp == comp &&  (* Each field must share the self cell of
             * the host *)
             f.fname <> "") then
          ignore (warn "Self pointer not set in field %s of %s"
                    f.fname fullname);
        checkType f.ftype fctx;
        (* Flx_cil_check the bitfields *)
        (match unrollType f.ftype, f.fbitfield with
        | TInt (ik, a), Some w ->
            checkAttributes a;
            if w < 0 || w >= bitsSizeOf (TInt(ik, a)) then
              ignore (warn "Wrong width (%d) in bitfield" w)
        | _, Some w ->
            ignore (E.error "Bitfield on a non integer type\n")
        | _ -> ());
        checkAttributes f.fattr
      in
      List.iter checkField comp.cfields
    end
  end


and checkEnumInfo (isadef: defuse) enum =
  if enum.ename = "" then
    E.s (bug "Enuminfo with empty name");
  try
    let oldei, olddef = H.find enumUsed enum.ename in
    (* Flx_cil_check that it is the same *)
    if oldei != enum then
      ignore (warnContext "enuminfo for %s not shared\n" enum.ename);
    (match !olddef, isadef with
      Defined, Defined ->
        ignore (warnContext "Multiple definition of enum %s\n" enum.ename)
    | _, Defined -> olddef := Defined
    | Defined, _ -> ()
    | _, Forward -> olddef := Forward
    | _, _ -> ())
  with Not_found -> begin (* This is the first time we see it *)
    (* Add it to the map before we go on *)
    H.add enumUsed enum.ename (enum, ref isadef);
    checkAttributes enum.eattr;
    List.iter (fun (tn, _, _) -> defineName tn) enum.eitems;
  end

and checkTypeInfo (isadef: defuse) ti =
  try
    let oldti, olddef = H.find typUsed ti.tname in
    (* Flx_cil_check that it is the same *)
    if oldti != ti then
      ignore (warnContext "typeinfo for %s not shared\n" ti.tname);
    (match !olddef, isadef with
      Defined, Defined ->
        ignore (warnContext "Multiple definition of type %s\n" ti.tname)
    | Defined, Used -> ()
    | Used, Defined ->
        ignore (warnContext "Use of type %s before its definition\n" ti.tname)
    | _, _ ->
        ignore (warnContext "Bug in checkTypeInfo for %s\n" ti.tname))
  with Not_found -> begin (* This is the first time we see it *)
    if ti.tname = "" then
      ignore (warnContext "typeinfo with empty name");
    checkType ti.ttype CTDecl;
    (* Add it to the map before we go on *)
    H.add typUsed ti.tname (ti, ref isadef);
  end

(* Flx_cil_check an lvalue. If isconst then the lvalue appears in a context where
 * only a compile-time constant can appear. Return the type of the lvalue.
 * See the typing rule from cil.mli *)
and checkLval (isconst: bool) (lv: lval) : typ =
  match lv with
    Var vi, off ->
      checkVariable vi;
      checkOffset vi.vtype off

  | Mem addr, off -> begin
      if isconst then
        ignore (warn "Memory operation in constant");
      let ta = checkExp false addr in
      match unrollType ta with
        TPtr (t, _) -> checkOffset t off
      | _ -> E.s (bug "Mem on a non-pointer")
  end

(* Flx_cil_check an offset. The basetype is the type of the object referenced by the
 * base. Return the type of the lvalue constructed from a base value of right
 * type and the offset. See the typing rules from cil.mli *)
and checkOffset basetyp : offset -> typ = function
    NoOffset -> basetyp
  | Index (ei, o) ->
      checkExpType false ei intType;
      begin
        match unrollType basetyp with
          TArray (t, _, _) -> checkOffset t o
        | t -> E.s (bug "typeOffset: Index on a non-array: %a" d_plaintype t)
      end

  | Field (fi, o) ->
      (* Now check that the host is shared propertly *)
      checkCompInfo Used fi.fcomp;
      (* Flx_cil_check that this exact field is part of the host *)
      if not (List.exists (fun f -> f == fi) fi.fcomp.cfields) then
        ignore (warn "Field %s not part of %s"
                  fi.fname (compFullName fi.fcomp));
      checkOffset fi.ftype o

and checkExpType (isconst: bool) (e: exp) (t: typ) =
  let t' = checkExp isconst e in (* compute the type *)
  if isconst then begin (* For initializers allow a string to initialize an
                         * array of characters  *)
    if typeSig t' <> typeSig t then
      match e, t with
      | _ -> typeMatch t' t
  end else
    typeMatch t' t

(* Flx_cil_check an expression. isconst specifies if the expression occurs in a
 * context where only a compile-time constant can occur. Return the computed
 * type of the expression *)
and checkExp (isconst: bool) (e: exp) : typ =
  E.withContext
    (fun _ -> dprintf "check%s: %a"
        (if isconst then "Const" else "Exp") d_exp e)
    (fun _ ->
      match e with
      | Const(CInt64 (_, ik, _)) -> TInt(ik, [])
      | Const(CChr _) -> charType
      | Const(CStr s) -> charPtrType
      | Const(CWStr s) -> TPtr(!wcharType,[])
      | Const(CReal (_, fk, _)) -> TFloat(fk, [])
      | Lval(lv) ->
          if isconst then
            ignore (warn "Lval in constant");
          checkLval isconst lv

      | SizeOf(t) -> begin
          (* Sizeof cannot be applied to certain types *)
          checkType t CTSizeof;
          (match unrollType t with
            (TFun _ | TVoid _) ->
              ignore (warn "Invalid operand for sizeof")
          | _ ->());
          uintType
      end
      | SizeOfE(e) ->
          (* The expression in a sizeof can be anything *)
          let te = checkExp false e in
          checkExp isconst (SizeOf(te))

      | SizeOfStr s -> uintType

      | AlignOf(t) -> begin
          (* Sizeof cannot be applied to certain types *)
          checkType t CTSizeof;
          (match unrollType t with
            (TFun _ | TVoid _) ->
              ignore (warn "Invalid operand for sizeof")
          | _ ->());
          uintType
      end
      | AlignOfE(e) ->
          (* The expression in an AlignOfE can be anything *)
          let te = checkExp false e in
          checkExp isconst (AlignOf(te))

      | UnOp (Neg, e, tres) ->
          checkArithmeticType tres; checkExpType isconst e tres; tres

      | UnOp (BNot, e, tres) ->
          checkIntegralType tres; checkExpType isconst e tres; tres

      | UnOp (LNot, e, tres) ->
          let te = checkExp isconst e in
          checkBooleanType te;
          checkIntegralType tres; (* Must check that t is well-formed *)
          typeMatch tres intType;
          tres

      | BinOp (bop, e1, e2, tres) -> begin
          let t1 = checkExp isconst e1 in
          let t2 = checkExp isconst e2 in
          match bop with
            (Mult | Div) ->
              typeMatch t1 t2; checkArithmeticType tres;
              typeMatch t1 tres; tres
          | (Eq|Ne|Lt|Le|Ge|Gt) ->
              typeMatch t1 t2; checkArithmeticType t1;
              typeMatch tres intType; tres
          | Mod|BAnd|BOr|BXor ->
              typeMatch t1 t2; checkIntegralType tres;
              typeMatch t1 tres; tres
          | LAnd | LOr ->
              typeMatch t1 t2; checkBooleanType tres;
              typeMatch t1 tres; tres
          | Shiftlt | Shiftrt ->
              typeMatch t1 tres; checkIntegralType t1;
              checkIntegralType t2; tres
          | (PlusA | MinusA) ->
                typeMatch t1 t2; typeMatch t1 tres;
                checkArithmeticType tres; tres
          | (PlusPI | MinusPI | IndexPI) ->
              checkPointerType tres;
              typeMatch t1 tres;
              checkIntegralType t2;
              tres
          | MinusPP  ->
              checkPointerType t1; checkPointerType t2;
              typeMatch t1 t2;
              typeMatch tres intType;
              tres
      end
      | AddrOf (lv) -> begin
          let tlv = checkLval isconst lv in
          (* Only certain types can be in AddrOf *)
          match unrollType tlv with
          | TVoid _ ->
              E.s (bug "AddrOf on improper type");

          | (TInt _ | TFloat _ | TPtr _ | TComp _ | TFun _ | TArray _ ) ->
              TPtr(tlv, [])

          | TEnum _ -> intPtrType
          | _ -> E.s (bug "AddrOf on unknown type")
      end

      | StartOf lv -> begin
          let tlv = checkLval isconst lv in
          match unrollType tlv with
            TArray (t,_, _) -> TPtr(t, [])
          | _ -> E.s (bug "StartOf on a non-array")
      end

      | CastE (tres, e) -> begin
          let et = checkExp isconst e in
          checkType tres CTExp;
          (* Not all types can be cast *)
          match unrollType et with
            TArray _ -> E.s (bug "Cast of an array type")
          | TFun _ -> E.s (bug "Cast of a function type")
          | TComp _ -> E.s (bug "Cast of a composite type")
          | TVoid _ -> E.s (bug "Cast of a void type")
          | _ -> tres
      end)
    () (* The argument of withContext *)

and checkInit  (i: init) : typ =
  E.withContext
    (fun _ -> dprintf "checkInit: %a" d_init i)
    (fun _ ->
      match i with
        SingleInit e -> checkExp true e
(*
      | ArrayInit (bt, len, initl) -> begin
          checkType bt CTSizeof;
          if List.length initl > len then
            ignore (warn "Too many initializers in array");
          List.iter (fun i -> checkInitType i bt) initl;
          TArray(bt, Some (integer len), [])
      end
*)
      | CompoundInit (ct, initl) -> begin
          checkType ct CTSizeof;
          (match unrollType ct with
            TArray(bt, Some (Const(CInt64(len, _, _))), _) ->
              let rec loopIndex i = function
                  [] ->
                    if i <> len then
                      ignore (warn "Wrong number of initializers in array")

                | (Index(Const(CInt64(i', _, _)), NoOffset), ei) :: rest ->
                    if i' <> i then
                      ignore (warn "Initializer for index %s when %s was expected\n"
                                (Int64.format "%d" i') (Int64.format "%d" i));
                    checkInitType ei bt;
                    loopIndex (Int64.succ i) rest
                | _ :: rest ->
                    ignore (warn "Malformed initializer for array element")
              in
              loopIndex Int64.zero initl
          | TArray(_, _, _) ->
              ignore (warn "Malformed initializer for array")
          | TComp (comp, _) ->
              if comp.cstruct then
                let rec loopFields
                    (nextflds: fieldinfo list)
                    (initl: (offset * init) list) : unit =
                  match nextflds, initl with
                    [], [] -> ()   (* We are done *)
                  | f :: restf, (Field(f', NoOffset), i) :: resti ->
                      if f.fname <> f'.fname then
                        ignore (warn "Expected initializer for field %s and found one for %s\n" f.fname f'.fname);
                      checkInitType i f.ftype;
                      loopFields restf resti
                  | [], _ :: _ ->
                      ignore (warn "Too many initializers for struct")
                  | _ :: _, [] ->
                      ignore (warn "Too few initializers for struct")
                  | _, _ ->
                      ignore (warn "Malformed initializer for struct")
                in
                loopFields
                  (List.filter (fun f -> f.fname <> missingFieldName)
                     comp.cfields)
                  initl

              else (* UNION *)
                if comp.cfields == [] then begin
                  if initl != [] then
                    ignore (warn "Initializer for empty union not empty");
                end else begin
                  match initl with
                    [(Field(f, NoOffset), ei)] ->
                      if f.fcomp != comp then
                        ignore (bug "Wrong designator for union initializer");
                      if !msvcMode && f != List.hd comp.cfields then
                        ignore (warn "On MSVC you can only initialize the first field of a union");
                      checkInitType ei f.ftype

                  | _ ->
                      ignore (warn "Malformed initializer for union")
                end
          | _ ->
              E.s (warn "Type of Compound is not array or struct or union"));
          ct
      end)
    () (* The arguments of withContext *)


and checkInitType (i: init) (t: typ) : unit =
  let it = checkInit i in
  typeMatch it t

and checkStmt (s: stmt) =
  E.withContext
    (fun _ ->
      (* Print context only for certain small statements *)
      match s.skind with
        Loop _ | If _ | Switch _  -> nil
      | _ -> dprintf "checkStmt: %a" d_stmt s)
    (fun _ ->
      (* Flx_cil_check the labels *)
      let checkLabel = function
          Label (ln, l, _) ->
            if H.mem labels ln then
              ignore (warn "Multiply defined label %s" ln);
            H.add labels ln ()
        | Case (e, _) -> checkExpType true e intType
        | _ -> () (* Not yet implemented *)
      in
      List.iter checkLabel s.labels;
      (* See if we have seen this statement before *)
      if List.memq s !statements then
        ignore (warn "Statement is shared");
      (* Remember that we have seen this one *)
      statements := s :: !statements;
      match s.skind with
        Break _ | Continue _ -> ()
      | Goto (gref, l) ->
          currentLoc := l;
          (* Find a label *)
          let lab =
            match List.filter (function Label _ -> true | _ -> false)
                  !gref.labels with
              Label (lab, _, _) :: _ -> lab
            | _ ->
                ignore (warn "Goto to block without a label\n");
                "<missing label>"
          in
          (* Remember it as a target *)
          gotoTargets := (lab, !gref) :: !gotoTargets


      | Return (re,l) -> begin
          currentLoc := l;
          match re, !currentReturnType with
            None, TVoid _  -> ()
          | _, TVoid _ -> ignore (warn "Invalid return value")
          | None, _ -> ignore (warn "Invalid return value")
          | Some re', rt' -> checkExpType false re' rt'
        end
      | Loop (b, l, _, _) -> checkBlock b
      | Block b -> checkBlock b
      | If (e, bt, bf, l) ->
          currentLoc := l;
          let te = checkExp false e in
          checkBooleanType te;
          checkBlock bt;
          checkBlock bf
      | Switch (e, b, cases, l) ->
          currentLoc := l;
          checkExpType false e intType;
          (* Remember the statements so far *)
          let prevStatements = !statements in
          checkBlock b;
          (* Now make sure that all the cases do occur in that block *)
          List.iter
            (fun c ->
              if not (List.exists (function Case _ -> true | _ -> false)
                        c.labels) then
                ignore (warn "Case in switch statment without a \"case\"\n");
              (* Make sure it is in there *)
              let rec findCase = function
                | l when l == prevStatements -> (* Not found *)
                    ignore (warnContext
                              "Cannot find target of switch statement")
                | [] -> E.s (E.bug "Flx_cil_check: findCase")
                | c' :: rest when c == c' -> () (* Found *)
                | _ :: rest -> findCase rest
              in
              findCase !statements)
            cases;
      | TryFinally (b, h, l) ->
          currentLoc := l;
          checkBlock b;
          checkBlock h

      | TryExcept (b, (il, e), h, l) ->
          currentLoc := l;
          checkBlock b;
          List.iter checkInstr il;
          checkExpType false e intType;
          checkBlock h

      | Instr il -> List.iter checkInstr il)
    () (* argument of withContext *)

and checkBlock (b: block) : unit =
  List.iter checkStmt b.bstmts


and checkInstr (i: instr) =
  match i with
  | Set (dest, e, l) ->
      currentLoc := l;
      let t = checkLval false dest in
      (* Not all types can be assigned to *)
      (match unrollType t with
        TFun _ -> ignore (warn "Assignment to a function type")
      | TArray _ -> ignore (warn "Assignment to an array type")
      | TVoid _ -> ignore (warn "Assignment to a void type")
      | _ -> ());
      checkExpType false e t

  | Call(dest, what, args, l) ->
      currentLoc := l;
      let (rt, formals, isva) =
        match checkExp false what with
          TFun(rt, formals, isva, _) -> rt, formals, isva
        | _ -> E.s (bug "Call to a non-function")
      in
          (* Now check the return value*)
      (match dest, unrollType rt with
        None, TVoid _ -> ()
      | Some _, TVoid _ -> ignore (warn "void value is assigned")
      | None, _ -> () (* "Call of function is not assigned" *)
      | Some destlv, rt' ->
          let desttyp = checkLval false destlv in
          if typeSig desttyp <> typeSig rt then begin
            (* Not all types can be assigned to *)
            (match unrollType desttyp with
              TFun _ -> ignore (warn "Assignment to a function type")
            | TArray _ -> ignore (warn "Assignment to an array type")
            | TVoid _ -> ignore (warn "Assignment to a void type")
            | _ -> ());
            (* Not all types can be cast *)
            (match rt' with
              TArray _ -> ignore (warn "Cast of an array type")
            | TFun _ -> ignore (warn "Cast of a function type")
            | TComp _ -> ignore (warn "Cast of a composite type")
            | TVoid _ -> ignore (warn "Cast of a void type")

            | _ -> ())
          end);
          (* Now check the arguments *)
      let rec loopArgs formals args =
        match formals, args with
          [], _ when (isva || args = []) -> ()
        | (fn,ft,_) :: formals, a :: args ->
            checkExpType false a ft;
            loopArgs formals args
        | _, _ -> ignore (warn "Not enough arguments")
      in
      if formals = None then
        ignore (warn "Call to function without prototype\n")
      else
        loopArgs (argsToList formals) args

  | Asm _ -> ()  (* Not yet implemented *)

let rec checkGlobal = function
    GAsm _ -> ()
  | GPragma _ -> ()
  | GText _ -> ()
  | GType (ti, l) ->
      currentLoc := l;
      E.withContext (fun _ -> dprintf "GType(%s)" ti.tname)
        (fun _ ->
          checkTypeInfo Defined ti;
          if ti.tname <> "" then defineName ti.tname)
        ()

  | GCompTag (comp, l) ->
      currentLoc := l;
      checkCompInfo Defined comp;

  | GCompTagDecl (comp, l) ->
      currentLoc := l;
      checkCompInfo Forward comp;

  | GEnumTag (enum, l) ->
      currentLoc := l;
      checkEnumInfo Defined enum

  | GEnumTagDecl (enum, l) ->
      currentLoc := l;
      checkEnumInfo Forward enum

  | GVarDecl (vi, l) ->
      currentLoc := l;
      (* We might have seen it already *)
      E.withContext (fun _ -> dprintf "GVarDecl(%s)" vi.vname)
        (fun _ ->
          (* If we have seen this vid already then it must be for the exact
           * same varinfo *)
          if H.mem varIdsEnv vi.vid then
            checkVariable vi
          else begin
            defineVariable vi;
            checkAttributes vi.vattr;
            checkType vi.vtype CTDecl;
            if not (vi.vglob &&
                    vi.vstorage <> Register) then
              E.s (bug "Invalid declaration of %s" vi.vname)
          end)
        ()

  | GVar (vi, init, l) ->
      currentLoc := l;
      (* Maybe this is the first occurrence *)
      E.withContext (fun _ -> dprintf "GVar(%s)" vi.vname)
        (fun _ ->
          checkGlobal (GVarDecl (vi, l));
          (* Flx_cil_check the initializer *)
          begin match init.init with
            None -> ()
          | Some i -> ignore (checkInitType i vi.vtype)
          end;
          (* Cannot be a function *)
          if isFunctionType vi.vtype then
            E.s (bug "GVar for a function (%s)\n" vi.vname);
          )
        ()


  | GFun (fd, l) -> begin
      currentLoc := l;
      (* Flx_cil_check if this is the first occurrence *)
      let vi = fd.svar in
      let fname = vi.vname in
      E.withContext (fun _ -> dprintf "GFun(%s)" fname)
        (fun _ ->
          checkGlobal (GVarDecl (vi, l));
          (* Flx_cil_check that the argument types in the type are identical to the
           * formals *)
          let rec loopArgs targs formals =
            match targs, formals with
              [], [] -> ()
            | (fn, ft, fa) :: targs, fo :: formals ->
                if fn <> fo.vname || ft != fo.vtype || fa != fo.vattr then
                  ignore (warnContext
                            "Formal %s not shared (type + locals) in %s"
                            fo.vname fname);
                loopArgs targs formals

            | _ ->
                E.s (bug "Type has different number of formals for %s"
                       fname)
          in
          begin match vi.vtype with
            TFun (rt, args, isva, a) -> begin
              currentReturnType := rt;
              loopArgs (argsToList args) fd.sformals
            end
          | _ -> E.s (bug "Function %s does not have a function type"
                        fname)
          end;
          ignore (fd.smaxid >= 0 || E.s (bug "smaxid < 0 for %s" fname));
          (* Now start a new environment, in a finally clause *)
          begin try
            startEnv ();
            (* Do the locals *)
            let doLocal tctx v =
              if v.vglob then
                ignore (warnContext
                          "Local %s has the vglob flag set" v.vname);
              if v.vstorage <> NoStorage && v.vstorage <> Register then
                ignore (warnContext
                          "Local %s has storage %a\n" v.vname
                          d_storage v.vstorage);
              checkType v.vtype tctx;
              checkAttributes v.vattr;
              defineVariable v
            in
            List.iter (doLocal CTFArg) fd.sformals;
            List.iter (doLocal CTDecl) fd.slocals;
            statements := [];
            gotoTargets := [];
            checkBlock fd.sbody;
            H.clear labels;
            (* Now verify that we have scanned all targets *)
            List.iter
              (fun (lab, t) -> if not (List.memq t !statements) then
                ignore (warnContext
                          "Target of \"goto %s\" statement does not appear in function body" lab))
              !gotoTargets;
            statements := [];
            gotoTargets := [];
            (* Done *)
            endEnv ()
          with e ->
            endEnv ();
            raise e
          end;
          ())
        () (* final argument of withContext *)
  end


let checkFile flags fl =
  if !E.verboseFlag then ignore (E.log "Flx_cil_checking file %s\n" fl.fileName);
  valid := true;
  List.iter
    (function
        NoFlx_cil_checkGlobalIds -> checkGlobalIds := false)
    flags;
  iterGlobals fl (fun g -> try checkGlobal g with _ -> ());
  (* Flx_cil_check that for all struct/union tags there is a definition *)
  H.iter
    (fun k (comp, isadef) ->
      if !isadef = Used then
        begin
          valid := false;
          ignore (E.warn "Compinfo %s is referenced but not defined"
                    (compFullName comp))
        end)
    compUsed;
  (* Flx_cil_check that for all enum tags there is a definition *)
  H.iter
    (fun k (enum, isadef) ->
      if !isadef = Used then
        begin
          valid := false;
          ignore (E.warn "Enuminfo %s is referenced but not defined"
                    enum.ename)
        end)
    enumUsed;
  (* Clean the hashes to let the GC do its job *)
  H.clear typeDefs;
  H.clear varNamesEnv;
  H.clear varIdsEnv;
  H.clear allVarIds;
  H.clear compNames;
  H.clear compUsed;
  H.clear enumUsed;
  H.clear typUsed;
  varNamesList := [];
  if !E.verboseFlag then
    ignore (E.log "Finished checking file %s\n" fl.fileName);
  !valid

@h=tangler('src/compiler/cil/flx_cil_check.mli')
@select(h)

    (* Flx_cil_checks the well-formedness of the file. Prints warnings and
     * returns false if errors are found *)

type checkFlags =
    NoFlx_cil_checkGlobalIds   (* Do not check that the global ids have the proper
                        * hash value *)

val checkFile: checkFlags list -> Flx_cil_cil.file -> bool
@h=tangler('src/compiler/cil/flx_cil_cil.ml')
@select(h)

open Flx_cil_escape
open Flx_cil_pretty
open Flx_cil_trace      (* sm: 'trace' function *)
open Flx_cil_machdep_type
module E = Flx_cil_errormsg
module H = Hashtbl

(*
 * CIL: An intermediate language for analyzing C progams.
 *
 * Version Tue Dec 12 15:21:52 PST 2000
 * Scott McPeak, George Necula, Wes Weimer
 *
 *)


module M = Flx_cil_machdep

(* The module Flx_cil_cilversion is generated automatically by Makefile from
 * information in configure.in *)
let cilVersion         = Flx_cil_cilversion.cilVersion
let cilVersionMajor    = Flx_cil_cilversion.cilVersionMajor
let cilVersionMinor    = Flx_cil_cilversion.cilVersionMinor
let cilVersionRevision = Flx_cil_cilversion.cilVersionRev

(* A few globals that control the interpretation of C source *)
let msvcMode = ref false              (* Whether the pretty printer should
                                       * print output for the MS VC
                                       * compiler. Default is GCC *)

let useLogicalOperators = ref false

(* Flx_cil_cil.initFlx_cil_cil will set this to the current machine description *)
let theMachine : Flx_cil_machdep_type.mach ref = ref M.gcc

let little_endian = ref true
let char_is_unsigned = ref false

type lineDirectiveStyle =
  | LineComment
  | LinePreprocessorInput
  | LinePreprocessorOutput

let lineDirectiveStyle = ref (Some LinePreprocessorInput)

let print_CIL_Input = ref false

let printCilAsIs = ref false

(* sm: return the string 's' if we're printing output for gcc, suppres
 * it if we're printing for CIL to parse back in.  the purpose is to
 * hide things from gcc that it complains about, but still be able
 * to do lossless transformations when CIL is the consumer *)
let forgcc (s: string) : string =
  if (!print_CIL_Input) then "" else s


let debugConstFold = false

(** The Abstract Syntax of CIL *)


(** The top-level representation of a CIL source file. Its main contents is
    the list of global declarations and definitions. *)
type file =
    { mutable fileName: string;   (** The complete file name *)
      mutable globals: global list; (** List of globals as they will appear
                                        in the printed file *)
      mutable globinit: fundec option;
      (** An optional global initializer function. This is a function where
       * you can put stuff that must be executed before the program is
       * started. This function, is conceptually at the end of the file,
       * although it is not part of the globals list. Use {!Flx_cil_cil.getGlobInit}
       * to create/get one. *)
      mutable globinitcalled: bool;
      (** Whether the global initialization function is called in main. This
          should always be false if there is no global initializer. When
          you create a global initialization CIL will try to insert code in
          main to call it. *)
    }


(** The main type for representing global declarations and definitions. A list
    of these form a CIL file. The order of globals in the file is generally
    important. *)
and global =
  | GType of typeinfo * location
    (** A typedef. All uses of type names (through the [TNamed] constructor)
        must be preceeded in the file by a definition of the name. The string
        is the defined name and always not-empty. *)

  | GCompTag of compinfo * location
    (** Defines a struct/union tag with some fields. There must be one of
        these for each struct/union tag that you use (through the [TComp]
        constructor) since this is the only context in which the fields are
        printed. Consequently nested structure tag definitions must be
        broken into individual definitions with the innermost structure
        defined first. *)

  | GCompTagDecl of compinfo * location
    (** Declares a struct/union tag. Use as a forward declaration. This is
      * printed without the fields.  *)

  | GEnumTag of enuminfo * location
   (** Declares an enumeration tag with some fields. There must be one of
      these for each enumeration tag that you use (through the [TEnum]
      constructor) since this is the only context in which the items are
      printed. *)

  | GEnumTagDecl of enuminfo * location
    (** Declares an enumeration tag. Use as a forward declaration. This is
      * printed without the items.  *)

  | GVarDecl of varinfo * location
   (** A variable declaration (not a definition). If the variable has a
       function type then this is a prototype. There can be several
       declarations and at most one definition for a given variable. If both
       forms appear then they must share the same varinfo structure. A
       prototype shares the varinfo with the fundec of the definition. Either
       has storage Extern or there must be a definition in this file *)

  | GVar  of varinfo * initinfo * location
     (** A variable definition. Can have an initializer. The initializer is
      * updateable so that you can change it without requiring to recreate
      * the list of globals. There can be at most one definition for a
      * variable in an entire program. Cannot have storage Extern or function
      * type. *)


  | GFun of fundec * location
     (** A function definition. *)

  | GAsm of string * location           (** Global asm statement. These ones
                                            can contain only a template *)
  | GPragma of attribute * location     (** Pragmas at top level. Use the same
                                            syntax as attributes *)
  | GText of string                     (** Some text (printed verbatim) at
                                            top level. E.g., this way you can
                                            put comments in the output.  *)


(** The various types available. Every type is associated with a list of
 * attributes, which are always kept in sorted order. Use {!Flx_cil_cil.addAttribute}
 * and {!Flx_cil_cil.addAttributes} to construct list of attributes. If you want to
 * inspect a type, you should use {!Flx_cil_cil.unrollType} to see through the uses
 * of named types. *)
and typ =
    TVoid of attributes   (** Void type *)
  | TInt of ikind * attributes (** An integer type. The kind specifies
                                       the sign and width. *)
  | TFloat of fkind * attributes (** A floating-point type. The kind
                                         specifies the precision. *)

  | TPtr of typ * attributes
           (** Pointer type. *)

  | TArray of typ * exp option * attributes
           (** Array type. It indicates the base type and the array length. *)

  | TFun of typ * (string * typ * attributes) list option * bool * attributes
          (** Function type. Indicates the type of the result, the name, type
           * and name attributes of the formal arguments ([None] if no
           * arguments were specified, as in a function whose definition or
           * prototype we have not seen; [Some \[\]] means void). Use
           * {!Flx_cil_cil.argsToList} to obtain a list of arguments. The boolean
           * indicates if it is a variable-argument function. If this is the
           * type of a varinfo for which we have a function declaration then
           * the information for the formals must match that in the
           * function's sformals. *)

  | TNamed of typeinfo * attributes
          (* The use of a named type. All uses of the same type name must
           * share the typeinfo. Each such type name must be preceeded
           * in the file by a [GType] global. This is printed as just the
           * type name. The actual referred type is not printed here and is
           * carried only to simplify processing. To see through a sequence
           * of named type references, use {!Flx_cil_cil.unrollType}. The attributes
           * are in addition to those given when the type name was defined. *)

  | TComp of compinfo * attributes
          (** A reference to a struct or a union type. All references to the
             same struct or union must share the same compinfo among them and
             with a [GCompTag] global that preceeds all uses (except maybe
             those that are pointers to the composite type). The attributes
             given are those pertaining to this use of the type and are in
             addition to the attributes that were given at the definition of
             the type and which are stored in the compinfo.  *)

  | TEnum of enuminfo * attributes
           (** A reference to an enumeration type. All such references must
               share the enuminfo among them and with a [GEnumTag] global that
               preceeds all uses. The attributes refer to this use of the
               enumeration and are in addition to the attributes of the
               enumeration itself, which are stored inside the enuminfo  *)



  | TBuiltin_va_list of attributes
            (** This is the same as the gcc's type with the same name *)

(** Various kinds of integers *)
and ikind =
  | IBool       (** [_Bool] *)
  | IChar       (** [char] *)
  | ISChar      (** [signed char] *)
  | IUChar      (** [unsigned char] *)
  | IInt        (** [int] *)
  | IUInt       (** [unsigned int] *)
  | IShort      (** [short] *)
  | IUShort     (** [unsigned short] *)
  | ILong       (** [long] *)
  | IULong      (** [unsigned long] *)
  | ILongLong   (** [long long] (or [_int64] on Microsoft Visual C) *)
  | IULongLong  (** [unsigned long long] (or [unsigned _int64] on Microsoft
                    Visual C) *)

(** Various kinds of floating-point numbers*)
and fkind =
    FFloat      (** [float] *)
  | FDouble     (** [double] *)
  | FLongDouble (** [long double] *)

  | CFloat      (** [_Complex] *)
  | CDouble     (** [double _Complex] *)
  | CLongDouble (** [long double _Complex] *)

  | IFloat      (** [_Imaginary] *)
  | IDouble     (** [double _Imaginary] *)
  | ILongDouble (** [long double _Imaginary] *)

(** An attribute has a name and some optional parameters *)
and attribute = Attr of string * attrparam list

(** Attributes are lists sorted by the attribute name *)
and attributes = attribute list

(** The type of parameters in attributes *)
and attrparam =
  | AInt of int                          (** An integer constant *)
  | AStr of string                       (** A string constant *)
  | ACons of string * attrparam list       (** Constructed attributes. These
                                             are printed [foo(a1,a2,...,an)].
                                             The list of parameters can be
                                             empty and in that case the
                                             parentheses are not printed. *)
  | ASizeOf of typ                       (** A way to talk about types *)
  | ASizeOfE of attrparam
  | AAlignOf of typ
  | AAlignOfE of attrparam
  | AUnOp of unop * attrparam
  | ABinOp of binop * attrparam * attrparam
  | ADot of attrparam * string           (** a.foo **)


(** Information about a composite type (a struct or a union). Use
    {!Flx_cil_cil.mkCompInfo}
    to create non-recursive or (potentially) recursive versions of this. Make
    sure you have a [GCompTag] for each one of these.  *)
and compinfo = {
    mutable cstruct: bool;              (** True if struct, False if union *)
    mutable cname: string;              (** The name. Always non-empty. Use
                                         * {!Flx_cil_cil.compFullName} to get the
                                         * full name of a comp (along with
                                         * the struct or union) *)
    mutable ckey: int;                  (** A unique integer constructed from
                                         * the name. Use {!Hashtbl.hash} on
                                         * the string returned by
                                         * {!Flx_cil_cil.compFullName}. All compinfo
                                         * for a given key are shared. *)
    mutable cfields: fieldinfo list;    (** Information about the fields *)
    mutable cattr:   attributes;        (** The attributes that are defined at
                                            the same time as the composite
                                            type *)
    mutable cdefined: bool;             (** Whether this is a defined
                                         * compinfo. *)
    mutable creferenced: bool;          (** True if used. Initially set to
                                         * false *)
  }

(** Information about a struct/union field *)
and fieldinfo = {
    mutable fcomp: compinfo;            (** The compinfo of the host. Note
                                            that this must be shared with the
                                            host since there can be only one
                                            compinfo for a given id *)
    mutable fname: string;              (** The name of the field. Might be
                                         * the value of
                                         * {!Flx_cil_cil.missingFieldName} in which
                                         * case it must be a bitfield and is
                                         * not printed and it does not
                                         * participate in initialization *)
    mutable ftype: typ;                 (** The type *)
    mutable fbitfield: int option;      (** If a bitfield then ftype should be
                                            an integer type *)
    mutable fattr: attributes;          (** The attributes for this field
                                          * (not for its type) *)
    mutable floc: location;             (** The location where this field
                                          * is defined *)
    mutable fstorage: storage;          (** Must be NoStorage or Static,
                                          * indicates nonstatic or static member *)
}



(** Information about an enumeration. This is shared by all references to an
    enumeration. Make sure you have a [GEnumTag] for each of of these.   *)
and enuminfo = {
    mutable ename: string;              (** The name. Always non-empty *)
    mutable eitems: (string * exp * location) list; (** Items with names
                                                      and values. This list
                                                      should be
                                                      non-empty. The item
                                                      values must be
                                                      compile-time
                                                      constants. *)
    mutable eattr: attributes;         (** Attributes *)
    mutable ereferenced: bool;         (** True if used. Initially set to false*)
}

(** Information about a defined type *)
and typeinfo = {
    mutable tname: string;
    (** The name. Can be empty only in a [GType] when introducing a composite
     * or enumeration tag. If empty cannot be refered to from the file *)
    mutable ttype: typ;
    (** The actual type. *)
    mutable treferenced: bool;
    (** True if used. Initially set to false*)
}


(** Information about a variable. These structures are shared by all
 * references to the variable. So, you can change the name easily, for
 * example. Use one of the {!Flx_cil_cil.makeLocalVar}, {!Flx_cil_cil.makeTempVar} or
 * {!Flx_cil_cil.makeGlobalVar} to create instances of this data structure. *)
and varinfo = {
    mutable vname: string;              (** The name of the variable. Cannot
                                          * be empty. *)
    mutable vtype: typ;                 (** The declared type of the
                                          * variable. *)
    mutable vattr: attributes;          (** A list of attributes associated
                                          * with the variable. *)
    mutable vstorage: storage;          (** The storage-class *)
    (* The other fields are not used in varinfo when they appear in the formal
     * argument list in a [TFun] type *)


    mutable vglob: bool;                (** True if this is a global variable*)

    (** Whether this varinfo is for an inline function. *)
    mutable vinline: bool;

    mutable vdecl: location;            (** Location of variable declaration *)

    mutable vid: int;  (** A unique integer identifier.  *)
    mutable vaddrof: bool;              (** True if the address of this
                                            variable is taken. CIL will set
                                         * these flags when it parses C, but
                                         * you should make sure to set the
                                         * flag whenever your transformation
                                         * create [AddrOf] expression. *)

    mutable vreferenced: bool;          (** True if this variable is ever
                                            referenced. This is computed by
                                            [removeUnusedVars]. It is safe to
                                            just initialize this to False *)
}

(** Storage-class information *)
and storage =
    | NoStorage                          (** The default storage. Nothing is
                                         * printed  *)
    | Static
    | Register
    | Extern


(** Expressions (Side-effect free)*)
and exp =
  | Const      of constant              (** Constant *)
  | Lval       of lval                  (** Lvalue *)
  | SizeOf     of typ                   (** sizeof(<type>). Has [unsigned
                                         * int] type (ISO 6.5.3.4). This is
                                         * not turned into a constant because
                                         * some transformations might want to
                                         * change types *)

  | SizeOfE    of exp                   (** sizeof(<expression>) *)
  | SizeOfStr  of string
    (** sizeof(string_literal). We separate this case out because this is the
      * only instance in which a string literal should not be treated as
      * having type pointer to character. *)

  | AlignOf    of typ                   (** Has [unsigned int] type *)
  | AlignOfE   of exp


  | UnOp       of unop * exp * typ      (** Unary operation. Includes
                                            the type of the result *)

  | BinOp      of binop * exp * exp * typ
                                        (** Binary operation. Includes the
                                            type of the result. The arithemtic
                                            conversions are made  explicit
                                            for the arguments *)
  | CastE      of typ * exp            (** Use {!Flx_cil_cil.mkCast} to make casts *)

  | AddrOf     of lval                 (** Always use {!Flx_cil_cil.mkAddrOf} to
                                        * construct one of these. Apply to an
                                        * lvalue of type [T] yields an
                                        * expression of type [TPtr(T)] *)

  | StartOf    of lval   (** There is no C correspondent for this. C has
                          * implicit coercions from an array to the address
                          * of the first element. [StartOf] is used in CIL to
                          * simplify type checking and is just an explicit
                          * form of the above mentioned implicit conversion.
                          * It is not printed. Given an lval of type
                          * [TArray(T)] produces an expression of type
                          * [TPtr(T)]. *)


(** Literal constants *)
and constant =
  | CInt64 of int64 * ikind * string option
                 (** Integer constant. Give the ikind (see ISO9899 6.1.3.2)
                  * and the textual representation, if available. Use
                  * {!Flx_cil_cil.integer} or {!Flx_cil_cil.kinteger} to create these. Watch
                  * out for integers that cannot be represented on 64 bits.
                  * OCAML does not give Overflow exceptions. *)
  | CStr of string (** String constant (of pointer type) *)
  | CWStr of int64 list (** Wide string constant (of type "wchar_t *") *)
  | CChr of char   (** Character constant *)
  | CReal of float * fkind * string option (** Floating point constant. Give
                                               the fkind (see ISO 6.4.4.2) and
                                               also the textual representation,
                                               if available *)

(** Unary operators *)
and unop =
    Neg                                 (** Unary minus *)
  | BNot                                (** Bitwise complement (~) *)
  | LNot                                (** Logical Not (!) *)

(** Binary operations *)
and binop =
    PlusA                               (** arithmetic + *)
  | PlusPI                              (** pointer + integer *)
  | IndexPI                             (** pointer + integer but only when
                                         * it arises from an expression
                                         * [e\[i\]] when [e] is a pointer and
                                         * not an array. This is semantically
                                         * the same as PlusPI but CCured uses
                                         * this as a hint that the integer is
                                         * probably positive. *)
  | MinusA                              (** arithmetic - *)
  | MinusPI                             (** pointer - integer *)
  | MinusPP                             (** pointer - pointer *)
  | Mult                                (** * *)
  | Div                                 (** / *)
  | Mod                                 (** % *)
  | Shiftlt                             (** shift left *)
  | Shiftrt                             (** shift right *)

  | Lt                                  (** <  (arithmetic comparison) *)
  | Gt                                  (** >  (arithmetic comparison) *)
  | Le                                  (** <= (arithmetic comparison) *)
  | Ge                                  (** >  (arithmetic comparison) *)
  | Eq                                  (** == (arithmetic comparison) *)
  | Ne                                  (** != (arithmetic comparison) *)
  | BAnd                                (** bitwise and *)
  | BXor                                (** exclusive-or *)
  | BOr                                 (** inclusive-or *)

  | LAnd                                (** logical and *)
  | LOr                                 (** logical or *)




(** An lvalue denotes the contents of a range of memory addresses. This range
 * is denoted as a host object along with an offset within the object. The
 * host object can be of two kinds: a local or global variable, or an object
 * whose address is in a pointer expression. We distinguish the two cases so
 * that we can tell quickly whether we are accessing some component of a
 * variable directly or we are accessing a memory location through a pointer.*)
and lval =
    lhost * offset

(** The host part of an {!Flx_cil_cil.lval}. *)
and lhost =
  | Var        of varinfo
    (** The host is a variable. *)

  | Mem        of exp
    (** The host is an object of type [T] when the expression has pointer
     * [TPtr(T)]. *)


(** The offset part of an {!Flx_cil_cil.lval}. Each offset can be applied to certain
  * kinds of lvalues and its effect is that it advances the starting address
  * of the lvalue and changes the denoted type, essentially focussing to some
  * smaller lvalue that is contained in the original one. *)
and offset =
  | NoOffset          (** No offset. Can be applied to any lvalue and does
                        * not change either the starting address or the type.
                        * This is used when the lval consists of just a host
                        * or as a terminator in a list of other kinds of
                        * offsets. *)

  | Field      of fieldinfo * offset
                      (** A field offset. Can be applied only to an lvalue
                       * that denotes a structure or a union that contains
                       * the mentioned field. This advances the offset to the
                       * beginning of the mentioned field and changes the
                       * type to the type of the mentioned field. *)

  | Index    of exp * offset
                     (** An array index offset. Can be applied only to an
                       * lvalue that denotes an array. This advances the
                       * starting address of the lval to the beginning of the
                       * mentioned array element and changes the denoted type
                       * to be the type of the array element *)



(* The following equivalences hold *)
(* Mem(AddrOf(Mem a, aoff)), off   = Mem a, aoff + off                *)
(* Mem(AddrOf(Var v, aoff)), off   = Var v, aoff + off                *)
(* AddrOf (Mem a, NoOffset)        = a                                *)

(** Initializers for global variables.  You can create an initializer with
 * {!Flx_cil_cil.makeZeroInit}. *)
and init =
  | SingleInit   of exp   (** A single initializer *)
  | CompoundInit   of typ * (offset * init) list
            (** Used only for initializers of structures, unions and arrays.
             * The offsets are all of the form [Field(f, NoOffset)] or
             * [Index(i, NoOffset)] and specify the field or the index being
             * initialized. For structures all fields
             * must have an initializer (except the unnamed bitfields), in
             * the proper order. This is necessary since the offsets are not
             * printed. For arrays the list must contain a prefix of the
             * initializers; the rest are 0-initialized.
             * For unions there must be exactly one initializer. If
             * the initializer is not for the first field then a field
             * designator is printed, so you better be on GCC since MSVC does
             * not understand this. You can scan an initializer list with
             * {!Flx_cil_cil.foldLeftCompound}. *)

(** We want to be able to update an initializer in a global variable, so we
 * define it as a mutable field *)
and initinfo = {
    mutable init : init option;
  }


(** Function definitions. *)
and fundec =
    { mutable svar:     varinfo;
         (** Holds the name and type as a variable, so we can refer to it
          * easily from the program. All references to this function either
          * in a function call or in a prototype must point to the same
          * varinfo. *)
      mutable sformals: varinfo list;
        (** Formals. These must be shared with the formals that appear in the
         * type of the function. Use {!Flx_cil_cil.setFormals} or
         * {!Flx_cil_cil.setFunctionType} to set these
         * formals and ensure that they are reflected in the function type.
         * Do not make copies of these because the body refers to them. *)
      mutable slocals: varinfo list;
        (** Locals. Does not include the sformals. Do not make copies of
         * these because the body refers to them. *)
      mutable smaxid: int;           (** Max local id. Starts at 0. *)
      mutable sbody: block;          (** The function body. *)
      mutable smaxstmtid: int option;  (** max id of a (reachable) statement
                                        * in this function, if we have
                                        * computed it. range = 0 ...
                                        * (smaxstmtid-1) *)
    }


(** A block is a sequence of statements with the control falling through from
    one element to the next *)
and block =
   { mutable battrs: attributes;      (** Attributes for the block *)
     mutable bstmts: stmt list;       (** The statements comprising the block*)
   }


(** Statements.
    The statement is the structural unit in the control flow graph. Use mkStmt
    to make a statement and then fill in the fields. *)
and stmt = {
    mutable labels: label list;        (** Whether the statement starts with
                                           some labels, case statements or
                                           default statement *)
    mutable skind: stmtkind;           (** The kind of statement *)

    (* Now some additional control flow information. Initially this is not
     * filled in. *)
    mutable sid: int;                  (** A number (>= 0) that is unique
                                           in a function. *)
    mutable succs: stmt list;          (** The successor statements. They can
                                           always be computed from the skind
                                           and the context in which this
                                           statement appears *)
    mutable preds: stmt list;          (** The inverse of the succs function*)
  }

(** Labels *)
and label =
    Label of string * location * bool
          (** A real label. If the bool is "true", the label is from the
           * input source program. If the bool is "false", the label was
           * created by CIL or some other transformation *)
  | Case of exp * location              (** A case statement *)
  | Default of location                 (** A default statement *)



(* The various kinds of statements *)
and stmtkind =
  | Instr  of instr list               (** A group of instructions that do not
                                           contain control flow. Control
                                           implicitly falls through. *)
  | Return of exp option * location     (** The return statement. This is a
                                            leaf in the CFG. *)

  | Goto of stmt ref * location         (** A goto statement. Appears from
                                            actual goto's in the code. *)
  | Break of location                   (** A break to the end of the nearest
                                             enclosing Loop or Switch *)
  | Continue of location                (** A continue to the start of the
                                            nearest enclosing [Loop] *)
  | If of exp * block * block * location (** A conditional.
                                             Two successors, the "then" and
                                             the "else" branches. Both
                                             branches  fall-through to the
                                             successor of the If statement *)
  | Switch of exp * block * (stmt list) * location
                                       (** A switch statement. The block
                                           contains within all of the cases.
                                           We also have direct pointers to the
                                           statements that implement the
                                           cases. Which cases they implement
                                           you can get from the labels of the
                                           statement *)

  | Loop of block * location * (stmt option) * (stmt option)
                                        (** A [while(1)] loop *)

  | Block of block                      (** Just a block of statements. Use it
                                            as a way to keep some attributes
                                            local *)
    (** On MSVC we support structured exception handling. This is what you
     * might expect. Control can get into the finally block either from the
     * end of the body block, or if an exception is thrown. The location
     * corresponds to the try keyword. *)
  | TryFinally of block * block * location

    (** On MSVC we support structured exception handling. The try/except
     * statement is a bit tricky:
         __try { blk }
         __except (e) {
            handler
         }

         The argument to __except  must be an expression. However, we keep a
         list of instructions AND an expression in case you need to make
         function calls. We'll print those as a comma expression. The control
         can get to the __except expression only if an exception is thrown.
         After that, depending on the value of the expression the control
         goes to the handler, propagates the exception, or retries the
         exception !!! The location corresponds to the try keyword.
     *)
  | TryExcept of block * (instr list * exp) * block * location


(** Instructions. They may cause effects directly but may not have control
    flow.*)
and instr =
    Set        of lval * exp * location  (** An assignment. A cast is present
                                             if the exp has different type
                                             from lval *)
  | Call       of lval option * exp * exp list * location
                         (** optional: result is an lval. A cast might be
                             necessary if the declared result type of the
                             function is not the same as that of the
                             destination. If the function is declared then
                             casts are inserted for those arguments that
                             correspond to declared formals. (The actual
                             number of arguments might be smaller or larger
                             than the declared number of arguments. C allows
                             this.) If the type of the result variable is not
                             the same as the declared type of the function
                             result then an implicit cast exists. *)

                         (* See the GCC specification for the meaning of ASM.
                          * If the source is MS VC then only the templates
                          * are used *)
                         (* sm: I've added a notes.txt file which contains more
                          * information on interpreting Asm instructions *)
  | Asm        of attributes * (* Really only const and volatile can appear
                               * here *)
                  string list *         (* templates (CR-separated) *)
                  (string * lval) list * (* outputs must be lvals with
                                          * constraints. I would like these
                                          * to be actually variables, but I
                                          * run into some trouble with ASMs
                                          * in the Linux sources  *)
                  (string * exp) list * (* inputs with constraints *)
                  string list *         (* register clobbers *)
                  location
        (** An inline assembly instruction. The arguments are (1) a list of
            attributes (only const and volatile can appear here and only for
            GCC), (2) templates (CR-separated), (3) a list of
            outputs, each of which is an lvalue with a constraint, (4) a list
            of input expressions along with constraints, (5) clobbered
            registers, and (5) location information *)



(** Describes a location in a source file *)
and location = {
    line: int;             (** The line number. -1 means "do not know" *)
    file: string;          (** The name of the source file*)
    byte: int;             (** The byte position in the source file *)
}



(** To be able to add/remove features easily, each feature should be package
   * as an interface with the following interface. These features should be *)
type featureDescr = {
    fd_enabled: bool ref;
    (** The enable flag. Set to default value  *)

    fd_name: string;
    (** This is used to construct an option "--doxxx" and "--dontxxx" that
     * enable and disable the feature  *)

    fd_description: string;
    (* A longer name that can be used to document the new options  *)

    fd_extraopt: (string * Arg.spec * string) list;
    (** Additional command line options *)

    fd_doit: (file -> unit);
    (** This performs the transformation *)

    fd_post_check: bool;
    (* Whether to perform a CIL consistency checking after this stage, if
     * checking is enabled (--check is passed to cilly) *)
}

let locUnknown = { line = -1; file = ""; byte = -1; }
(* A reference to the current location *)
let currentLoc : location ref = ref locUnknown

let compareLoc (a: location) (b: location) : int =
  let namecmp = compare a.file b.file in
  if namecmp != 0
  then namecmp
  else
    let linecmp = a.line - b.line in
    if linecmp != 0
    then linecmp
    else a.byte - b.byte

let argsToList : (string * typ * attributes) list option
                  -> (string * typ * attributes) list
    = function
    None -> []
  | Some al -> al



(** Different visiting actions. 'a will be instantiated with [exp], [instr],
    etc. *)
type 'a visitAction =
    SkipChildren                        (** Do not visit the children. Return
                                            the node as it is. *)
  | DoChildren                          (** Continue with the children of this
                                            node. Rebuild the node on return
                                            if any of the children changes
                                            (use == test) *)
  | ChangeTo of 'a                      (** Replace the expression with the
                                            given one *)
  | ChangeDoChildrenPost of 'a * ('a -> 'a) (** First consider that the entire
                                           exp is replaced by the first
                                           parameter. Then continue with
                                           the children. On return rebuild
                                           the node if any of the children
                                           has changed and then apply the
                                           function on the node *)



(* sm/gn: cil visitor interface for traversing Flx_cil_cil trees. *)
(* Use visitCilStmt and/or visitCilFile to use this. *)
(* Some of the nodes are changed in place if the children are changed. Use
 * one of Change... actions if you want to copy the node *)

(** A visitor interface for traversing CIL trees. Create instantiations of
 * this type by specializing the class {!Flx_cil_cil.nopCilVisitor}. *)
class type cilVisitor = object

  method vvdec: varinfo -> varinfo visitAction
    (** Invoked for each variable declaration. The subtrees to be traversed
     * are those corresponding to the type and attributes of the variable.
     * Note that variable declarations are all the [GVar], [GVarDecl], [GFun],
     * all the [varinfo] in formals of function types, and the formals and
     * locals for function definitions. This means that the list of formals
     * in a function definition will be traversed twice, once as part of the
     * function type and second as part of the formals in a function
     * definition. *)

  method vvrbl: varinfo -> varinfo visitAction
    (** Invoked on each variable use. Here only the [SkipChildren] and
     * [ChangeTo] actions make sense since there are no subtrees. Note that
     * the type and attributes of the variable are not traversed for a
     * variable use *)

  method vexpr: exp -> exp visitAction
    (** Invoked on each expression occurence. The subtrees are the
     * subexpressions, the types (for a [Cast] or [SizeOf] expression) or the
     * variable use. *)

  method vlval: lval -> lval visitAction
    (** Invoked on each lvalue occurence *)

  method voffs: offset -> offset visitAction
    (** Invoked on each offset occurrence that is *not* as part
      * of an initializer list specification, i.e. in an lval or
      * recursively inside an offset. *)

  method vinitoffs: offset -> offset visitAction
    (** Invoked on each offset appearing in the list of a
      * CompoundInit initializer.  *)

  method vinst: instr -> instr list visitAction
    (** Invoked on each instruction occurrence. The [ChangeTo] action can
     * replace this instruction with a list of instructions *)

  method vstmt: stmt -> stmt visitAction
    (** Control-flow statement. *)

  method vblock: block -> block visitAction     (** Block. Replaced in
                                                    place. *)
  method vfunc: fundec -> fundec visitAction    (** Function definition.
                                                    Replaced in place. *)
  method vglob: global -> global list visitAction (** Global (vars, types,
                                                      etc.)  *)
  method vinit: init -> init visitAction        (** Initializers for globals *)
  method vtype: typ -> typ visitAction          (** Use of some type. Note
                                                 * that for structure/union
                                                 * and enumeration types the
                                                 * definition of the
                                                 * composite type is not
                                                 * visited. Use [vglob] to
                                                 * visit it.  *)
  method vattr: attribute -> attribute list visitAction
    (** Attribute. Each attribute can be replaced by a list *)

    (** Add here instructions while visiting to queue them to
     * preceede the current statement or instruction being processed *)
  method queueInstr: instr list -> unit

    (** Gets the queue of instructions and resets the queue *)
  method unqueueInstr: unit -> instr list

end

(* the default visitor does nothing at each node, but does *)
(* not stop; hence they return true *)
class nopCilVisitor : cilVisitor = object
  method vvrbl (v:varinfo) = DoChildren (* variable *)
  method vvdec (v:varinfo) = DoChildren (* variable
                                                               * declaration *)
  method vexpr (e:exp) = DoChildren   (* expression *)
  method vlval (l:lval) = DoChildren  (* lval (base is 1st
                                                         * field)  *)
  method voffs (o:offset) = DoChildren      (* lval or recursive offset *)
  method vinitoffs (o:offset) = DoChildren  (* initializer offset *)
  method vinst (i:instr) = DoChildren       (* imperative instruction *)
  method vstmt (s:stmt) = DoChildren        (* constrol-flow statement *)
  method vblock (b: block) = DoChildren
  method vfunc (f:fundec) = DoChildren      (* function definition *)
  method vglob (g:global) = DoChildren      (* global (vars, types, etc.) *)
  method vinit (i:init) = DoChildren        (* global initializers *)
  method vtype (t:typ) = DoChildren         (* use of some type *)
  method vattr (a: attribute) = DoChildren

  val mutable instrQueue = []

  method queueInstr (il: instr list) =
    List.iter (fun i -> instrQueue <- i :: instrQueue) il

  method unqueueInstr () =
    let res = List.rev instrQueue in
    instrQueue <- [];
    res

end

let assertEmptyQueue vis =
  if vis#unqueueInstr () <> [] then
    (* Either a visitor inserted an instruction somewhere that it shouldn't
       have (i.e. at the top level rather than inside of a statement), or
       there's a bug in the visitor engine. *)
    E.s (E.bug "Visitor's instruction queue is not empty\n. You should only use queueInstr inside a function body!");
  ()


let lu = locUnknown

(* sm: utility *)
let startsWith (prefix: string) (s: string) : bool =
(
  let prefixLen = (String.length prefix) in
  (String.length s) >= prefixLen &&
  (String.sub s 0 prefixLen) = prefix
)


let get_instrLoc (inst : instr) =
  match inst with
      Set(_, _, loc) -> loc
    | Call(_, _, _, loc) -> loc
    | Asm(_, _, _, _, _, loc) -> loc
let get_globalLoc (g : global) =
  match g with
  | GFun(_,l) -> (l)
  | GType(_,l) -> (l)
  | GEnumTag(_,l) -> (l)
  | GEnumTagDecl(_,l) -> (l)
  | GCompTag(_,l) -> (l)
  | GCompTagDecl(_,l) -> (l)
  | GVarDecl(_,l) -> (l)
  | GVar(_,_,l) -> (l)
  | GAsm(_,l) -> (l)
  | GPragma(_,l) -> (l)
  | GText(_) -> locUnknown

let rec get_stmtLoc (statement : stmtkind) =
  match statement with
      Instr([]) -> lu
    | Instr(hd::tl) -> get_instrLoc(hd)
    | Return(_, loc) -> loc
    | Goto(_, loc) -> loc
    | Break(loc) -> loc
    | Continue(loc) -> loc
    | If(_, _, _, loc) -> loc
    | Switch (_, _, _, loc) -> loc
    | Loop (_, loc, _, _) -> loc
    | Block b -> if b.bstmts = [] then lu
                 else get_stmtLoc ((List.hd b.bstmts).skind)
    | TryFinally (_, _, l) -> l
    | TryExcept (_, _, _, l) -> l


(* The next variable identifier to use. Counts up *)
let nextGlobalVID = ref 1

(* The next compindo identifier to use. Counts up. *)
let nextCompinfoKey = ref 1

(* Some error reporting functions *)
let d_loc (_: unit) (loc: location) : doc =
  text loc.file ++ chr ':' ++ num loc.line

let d_thisloc (_: unit) : doc = d_loc () !currentLoc

let error (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    E.hadErrors := true;
    ignore (eprintf "@!%t: Error: %a@!"
              d_thisloc insert d);
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let unimp (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    E.hadErrors := true;
    ignore (eprintf "@!%t: Unimplemented: %a@!"
              d_thisloc insert d);
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let bug (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    E.hadErrors := true;
    ignore (eprintf "@!%t: Bug: %a@!"
              d_thisloc insert d);
    E.showContext ();
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let errorLoc (loc: location) (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    E.hadErrors := true;
    ignore (eprintf "@!%a: Error: %a@!"
              d_loc loc insert d);
    E.showContext ();
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let warn (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    ignore (eprintf "@!%t: Warning: %a@!"
              d_thisloc insert d);
    nil
  in
  Flx_cil_pretty.gprintf f fmt


let warnOpt (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    if !E.warnFlag then
      ignore (eprintf "@!%t: Warning: %a@!"
                d_thisloc insert d);
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let warnContext (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    ignore (eprintf "@!%t: Warning: %a@!"
              d_thisloc insert d);
    E.showContext ();
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let warnContextOpt (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    if !E.warnFlag then
      ignore (eprintf "@!%t: Warning: %a@!"
                d_thisloc insert d);
    E.showContext ();
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let warnLoc (loc: location) (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    ignore (eprintf "@!%a: Warning: %a@!"
              d_loc loc insert d);
    E.showContext ();
    nil
  in
  Flx_cil_pretty.gprintf f fmt



(* Represents an integer as for a given kind. Some truncation might be
 * necessary *)
let truncateInteger64 (k: ikind) (i: int64) =
  let nrBits, signed =
    match k with
    | IBool -> 8, true
    | IChar|ISChar -> 8, true
    | IUChar -> 8, false
    | IShort -> 16, true
    | IUShort -> 16, false
    | IInt | ILong -> 32, true
    | IUInt | IULong -> 32, false
    | ILongLong -> 64, true
    | IULongLong -> 64, false
  in
  if nrBits = 64 then
    i
  else begin
    let i1 = Int64.shift_left i (64 - nrBits) in
    let i2 =
      if signed then Int64.shift_right i1 (64 - nrBits)
      else Int64.shift_right_logical i1 (64 - nrBits)
    in
    i2
  end

(* Construct an integer constant with possible truncation *)
let kinteger64 (k: ikind) (i: int64) : exp =
  let i' = truncateInteger64 k i in
  if i' <> i then
    ignore (warnOpt "Truncating integer %s to %s\n"
              (Int64.format "0x%x" i) (Int64.format "0x%x" i'));
  Const (CInt64(i', k,  None))

(* Construct an integer of a given kind. *)
let kinteger (k: ikind) (i: int) = kinteger64 k (Int64.of_int i)

(* Construct an integer. Use only for values that fit on 31 bits *)
let integer (i: int) = Const (CInt64(Int64.of_int i, IInt, None))

let zero      = integer 0
let one       = integer 1
let mone      = integer (-1)

let rec isInteger = function
  | Const(CInt64 (n,_,_)) -> Some n
  | Const(CChr c) -> Some (Int64.of_int (Char.code c))
  | CastE(_, e) -> isInteger e
  | _ -> None



let rec isZero (e: exp) : bool = isInteger e = Some Int64.zero

let voidType = TVoid([])
let intType = TInt(IInt,[])
let uintType = TInt(IUInt,[])
let longType = TInt(ILong,[])
let ulongType = TInt(IULong,[])
let charType = TInt(IChar, [])
let boolType = TInt(IBool, [])

let charPtrType = TPtr(charType,[])
let charConstPtrType = TPtr(TInt(IChar, [Attr("const", [])]),[])
let stringLiteralType = ref charPtrType

let voidPtrType = TPtr(voidType, [])
let intPtrType = TPtr(intType, [])
let uintPtrType = TPtr(uintType, [])

let doubleType = TFloat(FDouble, [])

let parseInt (str: string) : exp =
  let hasSuffix str =
    let l = String.length str in
    fun s ->
      let ls = String.length s in
      l >= ls && s = String.uppercase (String.sub str (l - ls) ls)
  in
  let l = String.length str in
  (* See if it is octal or hex *)
  let octalhex = (l >= 1 && String.get str 0 = '0') in
  (* The length of the suffix and a list of possible kinds. See ISO
  * 6.4.4.1 *)
  let hasSuffix = hasSuffix str in
  let suffixlen, kinds =
    if hasSuffix "ULL" || hasSuffix "LLU" then
      3, [IULongLong]
    else if hasSuffix "LL" then
      2, if octalhex then [ILongLong; IULongLong] else [ILongLong]
    else if hasSuffix "UL" || hasSuffix "LU" then
      2, [IULong; IULongLong]
    else if hasSuffix "L" then
      1, if octalhex then [ILong; IULong; ILongLong; IULongLong]
      else [ILong; ILongLong]
    else if hasSuffix "U" then
      1, [IUInt; IULong; IULongLong]
    else
      0, if octalhex || true (* !!! This is against the ISO but it
        * is what GCC and MSVC do !!! *)
      then [IInt; IUInt; ILong; IULong; ILongLong; IULongLong]
      else [IInt; ILong; IUInt; ILongLong]
  in
  (* Convert to integer. To prevent overflow we do the arithmetic
  * on Int64 and we take care of overflow. We work only with
  * positive integers since the lexer takes care of the sign *)
  let rec toInt (base: int64) (acc: int64) (idx: int) : int64 =
    let doAcc (what: int) =
      let acc' =
        Int64.add (Int64.mul base acc)  (Int64.of_int what) in
      if acc < Int64.zero || (* We clearly overflow since base >= 2
      * *)
      (acc' > Int64.zero && acc' < acc) then
        E.s (unimp "Cannot represent on 64 bits the integer %s\n"
               str)
      else
        toInt base acc' (idx + 1)
    in
    if idx >= l - suffixlen then begin
      acc
    end else
      let ch = String.get str idx in
      if ch >= '0' && ch <= '9' then
        doAcc (Char.code ch - Char.code '0')
      else if  ch >= 'a' && ch <= 'f'  then
        doAcc (10 + Char.code ch - Char.code 'a')
      else if  ch >= 'A' && ch <= 'F'  then
        doAcc (10 + Char.code ch - Char.code 'A')
      else
        E.s (bug "Invalid integer constant: %s" str)
  in
  try
    let i =
      if octalhex then
        if l >= 2 &&
          (let c = String.get str 1 in c = 'x' || c = 'X') then
          toInt (Int64.of_int 16) Int64.zero 2
        else
          toInt (Int64.of_int 8) Int64.zero 1
      else
        toInt (Int64.of_int 10) Int64.zero 0
    in
    (* Construct an integer of the first kinds that fits. i must be
    * POSITIVE  *)
    let res =
      let rec loop = function
        | ((IInt | ILong) as k) :: _
                  when i < Int64.shift_left (Int64.of_int 1) 31 ->
                    kinteger64 k i
        | ((IUInt | IULong) as k) :: _
                  when i < Int64.shift_left (Int64.of_int 1) 32
          ->  kinteger64 k i
        | (ILongLong as k) :: _
                 when i <= Int64.sub (Int64.shift_left
                                              (Int64.of_int 1) 63)
                                          (Int64.of_int 1)
          ->
            kinteger64 k i
        | (IULongLong as k) :: _ -> kinteger64 k i
        | _ :: rest -> loop rest
        | [] -> E.s (E.unimp "Cannot represent the integer %s\n"
                       (Int64.to_string i))
      in
      loop kinds
    in
    res
  with e -> begin
    ignore (E.log "int_of_string %s (%s)\n" str
              (Printexc.to_string e));
    zero
  end


(* An integer type that fits pointers. Initialized by initCIL *)
let upointType = ref voidType

(* An integer type that fits wchar_t. Initialized by initCIL *)
let wcharKind = ref IChar
let wcharType = ref voidType


(* An integer type that is the type of sizeof. Initialized by initCIL *)
let typeOfSizeOf = ref voidType
let kindOfSizeOf = ref IUInt

(** Returns true if and only if the given integer type is signed. *)
let isSigned = function
  | IBool
  | IUChar
  | IUShort
  | IUInt
  | IULong
  | IULongLong ->
      false
  | ISChar
  | IShort
  | IInt
  | ILong
  | ILongLong ->
      true
  | IChar ->
      not !theMachine.Flx_cil_machdep_type.char_is_unsigned

let mkStmt (sk: stmtkind) : stmt =
  { skind = sk;
    labels = [];
    sid = -1; succs = []; preds = [] }

let mkBlock (slst: stmt list) : block =
  { battrs = []; bstmts = slst; }

let mkEmptyStmt () = mkStmt (Instr [])
let mkStmtOneInstr (i: instr) = mkStmt (Instr [i])

let dummyInstr = (Asm([], ["dummy statement!!"], [], [], [], lu))
let dummyStmt =  mkStmt (Instr [dummyInstr])

let compactStmts (b: stmt list) : stmt list =
      (* Try to compress statements. Scan the list of statements and remember
       * the last instrunction statement encountered, along with a Flx_cil_clist of
       * instructions in it. *)
  let rec compress (lastinstrstmt: stmt) (* Might be dummStmt *)
                   (lastinstrs: instr Flx_cil_clist.clist)
                   (body: stmt list) =
    let finishLast (tail: stmt list) : stmt list =
      if lastinstrstmt == dummyStmt then tail
      else begin
        lastinstrstmt.skind <- Instr (Flx_cil_clist.toList lastinstrs);
        lastinstrstmt :: tail
      end
    in
    match body with
      [] -> finishLast []
    | ({skind=Instr il} as s) :: rest ->
        let ils = Flx_cil_clist.fromList il in
        if lastinstrstmt != dummyStmt && s.labels == [] then
          compress lastinstrstmt (Flx_cil_clist.append lastinstrs ils) rest
        else
          finishLast (compress s ils rest)

    | s :: rest ->
        let res = s :: compress dummyStmt Flx_cil_clist.empty rest in
        finishLast res
  in
  compress dummyStmt Flx_cil_clist.empty b


(** Construct sorted lists of attributes ***)
let rec addAttribute (Attr(an, _) as a: attribute) (al: attributes) =
  let rec insertSorted = function
      [] -> [a]
    | ((Attr(an0, _) as a0) :: rest) as l ->
        if an < an0 then a :: l
        else if an > an0 then a0 :: insertSorted rest
        else if a = a0 then l (* Do not add if already in there *)
        else a0 :: insertSorted rest (* Make sure we see all attributes with
                                      * this name *)
  in
  insertSorted al

(** The second attribute list is sorted *)
and addAttributes al0 (al: attributes) : attributes =
    if al0 == [] then al else
    List.fold_left (fun acc a -> addAttribute a acc) al al0

and dropAttribute (an: string) (al: attributes) =
  List.filter (fun (Attr(an', _)) -> an <> an') al

and dropAttributes (anl: string list) (al: attributes) =
  List.fold_left (fun acc an -> dropAttribute an acc) al anl

and filterAttributes (s: string) (al: attribute list) : attribute list =
  List.filter (fun (Attr(an, _)) -> an = s) al

(* sm: *)
let hasAttribute s al =
  (filterAttributes s al <> [])


type attributeClass =
    AttrName of bool
        (* Attribute of a name. If argument is true and we are on MSVC then
         * the attribute is printed using __declspec as part of the storage
         * specifier  *)
  | AttrFunType of bool
        (* Attribute of a function type. If argument is true and we are on
         * MSVC then the attribute is printed just before the function name *)

  | AttrType  (* Attribute of a type *)

(* This table contains the mapping of predefined attributes to classes.
 * Extend this table with more attributes as you need. This table is used to
 * determine how to associate attributes with names or type during cabs2cil
 * conversion *)
let attributeHash: (string, attributeClass) H.t =
  let table = H.create 13 in
  List.iter (fun a -> H.add table a (AttrName false))
    [ "section"; "constructor"; "destructor"; "unused"; "weak";
      "no_instrument_function"; "alias"; "no_check_memory_usage";
      "exception"; "model"; (* "restrict"; *)
      "aconst"; "__asm__" (* Gcc uses this to specifiy the name to be used in
                           * assembly for a global  *)];

  (* Now come the MSVC declspec attributes *)
  List.iter (fun a -> H.add table a (AttrName true))
    [ "thread"; "naked"; "dllimport"; "dllexport"; "noreturn";
      "selectany"; "allocate"; "nothrow"; "novtable"; "property";
      "uuid"; "align" ];

  List.iter (fun a -> H.add table a (AttrFunType false))
    [ "format"; "regparm"; "longcall" ];
  List.iter (fun a -> H.add table a (AttrFunType true))
    [ "stdcall";"cdecl"; "fastcall" ];
  List.iter (fun a -> H.add table a AttrType)
    [ "const"; "volatile"; "restrict"; "mode" ];
  table


(* Partition the attributes into classes *)
let partitionAttributes
    ~(default:attributeClass)
    (attrs:  attribute list) :
    attribute list * attribute list * attribute list =
  let rec loop (n,f,t) = function
      [] -> n, f, t
    | (Attr(an, _) as a) :: rest ->
        match (try H.find attributeHash an with Not_found -> default) with
          AttrName _ -> loop (addAttribute a n, f, t) rest
        | AttrFunType _ -> loop (n, addAttribute a f, t) rest
        | AttrType -> loop (n, f, addAttribute a t) rest
  in
  loop ([], [], []) attrs


(* Get the full name of a comp *)
let compFullName comp =
  (if comp.cstruct then "struct " else "union ") ^ comp.cname


let missingFieldName = "___missing_field_name"

(** Creates a a (potentially recursive) composite type. Make sure you add a
  * GTag for it to the file! **)
let mkCompInfo
      (isstruct: bool)
      (n: string)
      (* fspec is a function that when given a forward
       * representation of the structure type constructs the type of
       * the fields. The function can ignore this argument if not
       * constructing a recursive type.  *)
       (mkfspec: compinfo -> (string * typ * int option * attribute list *
                             location * storage) list)
       (a: attribute list) : compinfo =

  (* make an new name for anonymous structs *)
   if n = "" then
     E.s (E.bug "mkCompInfo: missing structure name\n");
   (* Make a new self cell and a forward reference *)
   let comp =
     { cstruct = isstruct; cname = ""; ckey = 0; cfields = [];
       cattr = a; creferenced = false;
       (* Make this compinfo undefined by default *)
       cdefined = false; }
   in
   comp.cname <- n;
   comp.ckey <- !nextCompinfoKey;
   incr nextCompinfoKey;
   let self = ref voidType in
   let flds =
       List.map (fun (fn, ft, fb, fa, fl, fs) ->
          { fcomp = comp;
            ftype = ft;
            fname = fn;
            fbitfield = fb;
            fattr = fa;
            floc = fl;
            fstorage = fs}) (mkfspec comp) in
   comp.cfields <- flds;
   if flds <> [] then comp.cdefined <- true;
   comp

(** Make a copy of a compinfo, changing the name and the key *)
let copyCompInfo (ci: compinfo) (n: string) : compinfo =
  let ci' = {ci with cname = n;
                     ckey = !nextCompinfoKey; } in
  incr nextCompinfoKey;
  (* Copy the fields and set the new pointers to parents *)
  ci'.cfields <- List.map (fun f -> {f with fcomp = ci'}) ci'.cfields;
  ci'

(**** Flx_cil_utility functions ******)
let rec unrollType = function   (* Might drop some attributes !! *)
    TNamed (r, _) -> unrollType r.ttype
  | x -> x

let rec unrollTypeDeep = function   (* Might drop some attributes !! *)
    TNamed (r, _) -> unrollTypeDeep r.ttype
  | TPtr(t, a) -> TPtr(unrollTypeDeep t, a)
  | TArray(t, l, a) -> TArray(unrollTypeDeep t, l, a)
  | TFun(rt, args, isva, a) ->
      TFun (unrollTypeDeep rt,
            (match args with
              None -> None
            | Some argl ->
                Some (List.map (fun (an,at,aa) -> (an, unrollTypeDeep at, aa)) argl)),
            isva, a)
  | x -> x

let isVoidType t =
  match unrollType t with
    TVoid _ -> true
  | _ -> false
let isVoidPtrType t =
  match unrollType t with
    TPtr(tau,_) when isVoidType tau -> true
  | _ -> false

let var vi : lval = (Var vi, NoOffset)
(* let assign vi e = Instrs(Set (var vi, e), lu) *)

let mkString s = Const(CStr s)


let mkWhile ~(guard:exp) ~(body: stmt list) : stmt list =
  (* Do it like this so that the pretty printer recognizes it *)
  [ mkStmt (Loop (mkBlock (mkStmt (If(guard,
                                      mkBlock [ mkEmptyStmt () ],
                                      mkBlock [ mkStmt (Break lu)], lu)) ::
                           body), lu, None, None)) ]



let mkFor ~(start: stmt list) ~(guard: exp) ~(next: stmt list)
          ~(body: stmt list) : stmt list =
  (start @
     (mkWhile guard (body @ next)))


let mkForIncr ~(iter : varinfo) ~(first: exp) ~stopat:(past: exp) ~(incr: exp)
    ~(body: stmt list) : stmt list =
      (* See what kind of operator we need *)
  let compop, nextop =
    match unrollType iter.vtype with
      TPtr _ -> Lt, PlusPI
    | _ -> Lt, PlusA
  in
  mkFor
    [ mkStmt (Instr [(Set (var iter, first, lu))]) ]
    (BinOp(compop, Lval(var iter), past, intType))
    [ mkStmt (Instr [(Set (var iter,
                           (BinOp(nextop, Lval(var iter), incr, iter.vtype)),
                           lu))])]
    body




(* the name of the C function we call to get ccgr ASTs
external parse : string -> file = "cil_main"
*)
(*
  Flx_cil_pretty Printing
 *)

let d_ikind () = function
  | IBool -> text "_Bool"
  | IChar -> text "char"
  | ISChar -> text "signed char"
  | IUChar -> text "unsigned char"
  | IInt -> text "int"
  | IUInt -> text "unsigned int"
  | IShort -> text "short"
  | IUShort -> text "unsigned short"
  | ILong -> text "long"
  | IULong -> text "unsigned long"
  | ILongLong ->
      if !msvcMode then text "__int64" else text "long long"
  | IULongLong ->
      if !msvcMode then text "unsigned __int64"
      else text "unsigned long long"

let d_fkind () = function
    FFloat -> text "float"
  | FDouble -> text "double"
  | FLongDouble -> text "long double"

  | CFloat -> text "_Complex"
  | CDouble -> text "double _Complex"
  | CLongDouble -> text "long double _Complex"

  | IFloat -> text "_Imaginary"
  | IDouble -> text "double _Imaginary"
  | ILongDouble -> text "long double _Imaginary"

let d_storage () = function
    NoStorage -> nil
  | Static -> text "static "
  | Extern -> text "extern "
  | Register -> text "register "

(* sm: need this value below *)
let mostNeg32BitInt : int64 = (Int64.of_string "-0x80000000")
let mostNeg64BitInt : int64 = (Int64.of_string "-0x8000000000000000")

(* constant *)
let d_const () c =
  let suffix ik =
    match ik with
      IUInt -> "U"
    | ILong -> "L"
    | IULong -> "UL"
    | ILongLong -> if !msvcMode then "L" else "LL"
    | IULongLong -> if !msvcMode then "UL" else "ULL"
    | _ -> ""
  in
  match c with
    CInt64(_, _, Some s) -> text s (* Always print the text if there is one *)
  | CInt64(i, ik, None) ->
      (* Watch out here for negative integers that we should be printing as
       * large positive ones *)
      if i < Int64.zero
          && (match ik with
            IUInt | IULong | IULongLong | IUChar | IUShort -> true | _ -> false) then
        let high = Int64.shift_right i 32 in
        if ik <> IULongLong && ik <> ILongLong && high = Int64.of_int (-1) then
          (* Print only the low order 32 bits *)
          text ("0x" ^
                Int64.format "%x" (Int64.logand i (Int64.shift_right_logical high 32))
                ^ suffix ik)
        else
          text ("0x" ^ Int64.format "%x" i ^ suffix ik)
      else (
        if (i = mostNeg32BitInt) then
          (* sm: quirk here: if you print -2147483648 then this is two tokens *)
          (* in C, and the second one is too large to represent in a signed *)
          (* int.. so we do what's done in limits.h, and print (-2147483467-1); *)
          (* in gcc this avoids a warning, but it might avoid a real problem *)
          (* on another compiler or a 64-bit architecture *)
          text "(-0x7FFFFFFF-1)"
        else if (i = mostNeg64BitInt) then
          (* The same is true of the largest 64-bit negative. *)
          text "(-0x7FFFFFFFFFFFFFFF-1)"
        else
          text (Int64.to_string i ^ suffix ik)
      )

  | CStr(s) -> text ("\"" ^ escape_string s ^ "\"")
  | CWStr(s) ->
      (* text ("L\"" ^ escape_string s ^ "\"")  *)
      (List.fold_left (fun acc elt ->
        acc ++
        if (elt >= Int64.zero &&
            elt <= (Int64.of_int 255)) then
          text (escape_char (Char.chr (Int64.to_int elt)))
        else
          ( text (Printf.sprintf "\\x%LX\"" elt) ++ break ++
            (text "\""))
      ) (text "L\"") s ) ++ text "\""
      (* we cannot print L"\xabcd" "feedme" as L"\xabcdfeedme" --
       * the former has 7 wide characters and the later has 3. *)

  | CChr(c) -> text ("'" ^ escape_char c ^ "'")
  | CReal(_, _, Some s) -> text s
  | CReal(f, _, None) -> text (string_of_float f)

(* Parentheses level. An expression "a op b" is printed parenthesized if its
 * parentheses level is >= that that of its context. Identifiers have the
 * lowest level and weakly binding operators (e.g. |) have the largest level.
 * The correctness criterion is that a smaller level MUST correspond to a
 * stronger precedence!
 *)
let derefStarLevel = 20
let indexLevel = 20
let arrowLevel = 20
let addrOfLevel = 30
let additiveLevel = 60
let comparativeLevel = 70
let bitwiseLevel = 75
let getParenthLevel = function
  | BinOp((LAnd | LOr), _,_,_) -> 80
                                        (* Bit operations. *)
  | BinOp((BOr|BXor|BAnd),_,_,_) -> bitwiseLevel (* 75 *)

                                        (* Comparisons *)
  | BinOp((Eq|Ne|Gt|Lt|Ge|Le),_,_,_) ->
      comparativeLevel (* 70 *)
                                        (* Additive. Shifts can have higher
                                         * level than + or - but I want
                                         * parentheses around them *)
  | BinOp((MinusA|MinusPP|MinusPI|PlusA|
           PlusPI|IndexPI|Shiftlt|Shiftrt),_,_,_)
    -> additiveLevel (* 60 *)

                                        (* Multiplicative *)
  | BinOp((Div|Mod|Mult),_,_,_) -> 40

                                        (* Unary *)
  | CastE(_,_) -> 30
  | AddrOf(_) -> 30
  | StartOf(_) -> 30
  | UnOp((Neg|BNot|LNot),_,_) -> 30

                                        (* Lvals *)
  | Lval(Mem _ , _) -> 20
  | Lval(Var _, (Field _|Index _)) -> 20
  | SizeOf _ | SizeOfE _ | SizeOfStr _ -> 20
  | AlignOf _ | AlignOfE _ -> 20

  | Lval(Var _, NoOffset) -> 0        (* Plain variables *)
  | Const _ -> 0                        (* Constants *)



(* Separate out the storage-modifier name attributes *)
let separateStorageModifiers (al: attribute list) =
  let isstoragemod (Attr(an, _): attribute) : bool =
    try
      match H.find attributeHash an with
        AttrName issm -> issm
      | _ -> E.s (E.bug "separateStorageModifier: %s is not a name attribute" an)
    with Not_found -> false
  in
    let stom, rest = List.partition isstoragemod al in
    if not !msvcMode then
      stom, rest
    else
      (* Put back the declspec. Put it without the leading __ since these will
       * be added later *)
      let stom' =
        List.map (fun (Attr(an, args)) ->
          Attr("declspec", [ACons(an, args)])) stom in
      stom', rest


let rec typeAttrs = function
    TVoid a -> a
  | TInt (_, a) -> a
  | TFloat (_, a) -> a
  | TNamed (t, a) -> addAttributes a (typeAttrs t.ttype)
  | TPtr (_, a) -> a
  | TArray (_, _, a) -> a
  | TComp (comp, a) -> addAttributes comp.cattr a
  | TEnum (enum, a) -> addAttributes enum.eattr a
  | TFun (_, _, _, a) -> a
  | TBuiltin_va_list a -> a


let setTypeAttrs t a =
  match t with
    TVoid _ -> TVoid a
  | TInt (i, _) -> TInt (i, a)
  | TFloat (f, _) -> TFloat (f, a)
  | TNamed (t, _) -> TNamed(t, a)
  | TPtr (t', _) -> TPtr(t', a)
  | TArray (t', l, _) -> TArray(t', l, a)
  | TComp (comp, _) -> TComp (comp, a)
  | TEnum (enum, _) -> TEnum (enum, a)
  | TFun (r, args, v, _) -> TFun(r,args,v,a)
  | TBuiltin_va_list _ -> TBuiltin_va_list a


let typeAddAttributes a0 t =
begin
  match a0 with
  | [] ->
      (* no attributes, keep same type *)
      t
  | _ ->
      (* anything else: add a0 to existing attributes *)
      let add (a: attributes) = addAttributes a0 a in
      match t with
        TVoid a -> TVoid (add a)
      | TInt (ik, a) -> TInt (ik, add a)
      | TFloat (fk, a) -> TFloat (fk, add a)
      | TEnum (enum, a) -> TEnum (enum, add a)
      | TPtr (t, a) -> TPtr (t, add a)
      | TArray (t, l, a) -> TArray (t, l, add a)
      | TFun (t, args, isva, a) -> TFun(t, args, isva, add a)
      | TComp (comp, a) -> TComp (comp, add a)
      | TNamed (t, a) -> TNamed (t, add a)
      | TBuiltin_va_list a -> TBuiltin_va_list (add a)
end

let typeRemoveAttributes (anl: string list) t =
  let drop (al: attributes) = dropAttributes anl al in
  match t with
    TVoid a -> TVoid (drop a)
  | TInt (ik, a) -> TInt (ik, drop a)
  | TFloat (fk, a) -> TFloat (fk, drop a)
  | TEnum (enum, a) -> TEnum (enum, drop a)
  | TPtr (t, a) -> TPtr (t, drop a)
  | TArray (t, l, a) -> TArray (t, l, drop a)
  | TFun (t, args, isva, a) -> TFun(t, args, isva, drop a)
  | TComp (comp, a) -> TComp (comp, drop a)
  | TNamed (t, a) -> TNamed (t, drop a)
  | TBuiltin_va_list a -> TBuiltin_va_list (drop a)


     (* Type signatures. Two types are identical iff they have identical
      * signatures *)
type typsig =
    TSArray of typsig * exp option * attribute list
  | TSPtr of typsig * attribute list
  | TSComp of bool * string * attribute list
  | TSFun of typsig * typsig list * bool * attribute list
  | TSEnum of string * attribute list
  | TSBase of typ

(* Compute a type signature *)
let rec typeSigWithAttrs doattr t =
  let typeSig = typeSigWithAttrs doattr in
  match t with
  | TInt (ik, al) -> TSBase (TInt (ik, doattr al))
  | TFloat (fk, al) -> TSBase (TFloat (fk, doattr al))
  | TVoid al -> TSBase (TVoid (doattr al))
  | TEnum (enum, a) -> TSEnum (enum.ename, doattr a)
  | TPtr (t, a) -> TSPtr (typeSig t, doattr a)
  | TArray (t,l,a) -> TSArray(typeSig t, l, doattr a)
  | TComp (comp, a) ->
      TSComp (comp.cstruct, comp.cname, doattr (addAttributes comp.cattr a))
  | TFun(rt,args,isva,a) ->
      TSFun(typeSig rt,
            List.map (fun (_, atype, _) -> (typeSig atype)) (argsToList args),
            isva, doattr a)
  | TNamed(t, a) -> typeSigAddAttrs (doattr a) (typeSig t.ttype)
  | TBuiltin_va_list al -> TSBase (TBuiltin_va_list (doattr al))
and typeSigAddAttrs a0 t =
  if a0 == [] then t else
  match t with
    TSBase t -> TSBase (typeAddAttributes a0 t)
  | TSPtr (ts, a) -> TSPtr (ts, addAttributes a0 a)
  | TSArray (ts, l, a) -> TSArray(ts, l, addAttributes a0 a)
  | TSComp (iss, n, a) -> TSComp (iss, n, addAttributes a0 a)
  | TSEnum (n, a) -> TSEnum (n, addAttributes a0 a)
  | TSFun(ts, tsargs, isva, a) -> TSFun(ts, tsargs, isva, addAttributes a0 a)


let typeSig t = typeSigWithAttrs (fun al -> al) t

(* Remove the attribute from the top-level of the type signature *)
let setTypeSigAttrs (a: attribute list) = function
    TSBase t -> TSBase (setTypeAttrs t a)
  | TSPtr (ts, _) -> TSPtr (ts, a)
  | TSArray (ts, l, _) -> TSArray(ts, l, a)
  | TSComp (iss, n, _) -> TSComp (iss, n, a)
  | TSEnum (n, _) -> TSEnum (n, a)
  | TSFun (ts, tsargs, isva, _) -> TSFun (ts, tsargs, isva, a)


let typeSigAttrs = function
    TSBase t -> typeAttrs t
  | TSPtr (ts, a) -> a
  | TSArray (ts, l, a) -> a
  | TSComp (iss, n, a) -> a
  | TSEnum (n, a) -> a
  | TSFun (ts, tsargs, isva, a) -> a


(**** Compute the type of an expression ****)
let rec typeOf (e: exp) : typ =
  match e with
  | Const(CInt64 (_, ik, _)) -> TInt(ik, [])

    (* Character constants have type int.  ISO/IEC 9899:1999 (E),
     * section 6.4.4.4 [Character constants], paragraph 10, if you
     * don't believe me. *)
  | Const(CChr _) -> intType

    (* The type of a string is a pointer to characters ! The only case when
     * you would want it to be an array is as an argument to sizeof, but we
     * have SizeOfStr for that *)
  | Const(CStr s) -> !stringLiteralType

  | Const(CWStr s) -> TPtr(!wcharType,[])

  | Const(CReal (_, fk, _)) -> TFloat(fk, [])
  | Lval(lv) -> typeOfLval lv
  | SizeOf _ | SizeOfE _ | SizeOfStr _ -> !typeOfSizeOf
  | AlignOf _ | AlignOfE _ -> !typeOfSizeOf
  | UnOp (_, _, t) -> t
  | BinOp (_, _, _, t) -> t
  | CastE (t, _) -> t
  | AddrOf (lv) -> TPtr(typeOfLval lv, [])
  | StartOf (lv) -> begin
      match unrollType (typeOfLval lv) with
        TArray (t,_, _) -> TPtr(t, [])
     | _ -> E.s (E.bug "typeOf: StartOf on a non-array")
  end

and typeOfInit (i: init) : typ =
  match i with
    SingleInit e -> typeOf e
  | CompoundInit (t, _) -> t

and typeOfLval = function
    Var vi, off -> typeOffset vi.vtype off
  | Mem addr, off -> begin
      match unrollType (typeOf addr) with
        TPtr (t, _) -> typeOffset t off
      | _ -> E.s (bug "typeOfLval: Mem on a non-pointer")
  end

and typeOffset basetyp = function
    NoOffset -> basetyp
  | Index (_, o) -> begin
      match unrollType basetyp with
        TArray (t, _, _) -> typeOffset t o
      | t -> E.s (E.bug "typeOffset: Index on a non-array")
  end
  | Field (fi, o) -> typeOffset fi.ftype o


and d_binop () b =
  match b with
    PlusA | PlusPI | IndexPI -> text "+"
  | MinusA | MinusPP | MinusPI -> text "-"
  | Mult -> text "*"
  | Div -> text "/"
  | Mod -> text "%"
  | Shiftlt -> text "<<"
  | Shiftrt -> text ">>"
  | Lt -> text "<"
  | Gt -> text ">"
  | Le -> text "<="
  | Ge -> text ">="
  | Eq -> text "=="
  | Ne -> text "!="
  | BAnd -> text "&"
  | BXor -> text "^"
  | BOr -> text "|"
  | LAnd -> text "&&"
  | LOr -> text "||"

let invalidStmt = mkStmt (Instr [])

(** Construct a hash with the builtins *)
let gccBuiltins : (string, typ * typ list * bool) H.t =
  let h = H.create 17 in
  (* See if we have builtin_va_list *)
  let hasbva = M.gccHas__builtin_va_list in
  (* When we parse builtin_next_arg we drop the second argument *)
  H.add h "__builtin_next_arg"
    ((if hasbva then TBuiltin_va_list [] else voidPtrType), [], false);
  H.add h "__builtin_constant_p" (intType, [ intType ], false);
  H.add h "__builtin_fabs" (doubleType, [ doubleType ], false);
  let longDouble = TFloat (FLongDouble, []) in
  H.add h "__builtin_fabsl" (longDouble, [ longDouble ], false);
  if hasbva then begin
    H.add h "__builtin_va_end" (voidType, [ TBuiltin_va_list [] ], false);
    H.add h "__builtin_varargs_start"
      (voidType, [ TBuiltin_va_list [] ], false);
    H.add h "__builtin_va_start" (voidType, [ TBuiltin_va_list [] ], false);
    (* When we parse builtin_stdarg_start, we drop the second argument *)
    H.add h "__builtin_stdarg_start" (voidType, [ TBuiltin_va_list []; ],
                                      false);
    (* When we parse builtin_va_arg we change its interface *)
    H.add h "__builtin_va_arg" (voidType, [ TBuiltin_va_list [];
                                            uintType; (* Sizeof the type *)
                                            voidPtrType; (* Ptr to res *) ],
                               false);
    H.add h "__builtin_va_copy" (voidType, [ TBuiltin_va_list [];
                                             TBuiltin_va_list [] ],
                                false);
  end;
  h

(** Construct a hash with the builtins *)
let msvcBuiltins : (string, typ * typ list * bool) H.t =
  (* These are empty for now but can be added to depending on the application*)
  let h = H.create 17 in
  (** Take a number of wide string literals *)
  H.add h "__annotation" (voidType, [ ], true);
  h


(** A printer interface for CIL trees. Create instantiations of
 * this type by specializing the class {!Flx_cil_cil.defaultCilPrinter}. *)
class type cilPrinter = object
  method pVDecl: unit -> varinfo -> doc
    (** Invoked for each variable declaration. Note that variable
     * declarations are all the [GVar], [GVarDecl], [GFun], all the [varinfo]
     * in formals of function types, and the formals and locals for function
     * definitions. *)

  method pVar: varinfo -> doc
    (** Invoked on each variable use. *)

  method pLval: unit -> lval -> doc
    (** Invoked on each lvalue occurence *)

  method pOffset: doc -> offset -> doc
    (** Invoked on each offset occurence. The second argument is the base. *)

  method pInstr: unit -> instr -> doc
    (** Invoked on each instruction occurrence. *)

  method pStmt: unit -> stmt -> doc
    (** Control-flow statement. This is used by
     * {!Flx_cil_cil.printGlobal} and by {!Flx_cil_cil.dumpGlobal}. *)

  method dStmt: out_channel -> int -> stmt -> unit
    (** Dump a control-flow statement to a file with a given indentation. This is used by
     * {!Flx_cil_cil.dumpGlobal}. *)

  method dBlock: out_channel -> int -> block -> unit
    (** Dump a control-flow block to a file with a given indentation. This is
     * used by {!Flx_cil_cil.dumpGlobal}. *)

  method pBlock: unit -> block -> Flx_cil_pretty.doc
    (** Print a block. *)

  method pGlobal: unit -> global -> doc
    (** Global (vars, types, etc.). This can be slow and is used only by
     * {!Flx_cil_cil.printGlobal} but by {!Flx_cil_cil.dumpGlobal} for everything else except
     * [GVar] and [GFun]. *)

  method dGlobal: out_channel -> global -> unit
    (** Dump a global to a file. This is used by {!Flx_cil_cil.dumpGlobal}. *)

  method pFieldDecl: unit -> fieldinfo -> doc
    (** A field declaration *)

  method pType: doc option -> unit -> typ -> doc
  (* Use of some type in some declaration. The first argument is used to print
   * the declared element, or is None if we are just printing a type with no
   * name being decalred. Note that for structure/union and enumeration types
   * the definition of the composite type is not visited. Use [vglob] to
   * visit it.  *)

  method pAttr: attribute -> doc * bool
    (** Attribute. Also return an indication whether this attribute must be
      * printed inside the __attribute__ list or not. *)

  method pAttrParam: unit -> attrparam -> doc
    (** Attribute paramter *)

  method pAttrs: unit -> attributes -> doc
    (** Attribute lists *)

  method pLabel: unit -> label -> doc
    (** Label *)

  method pLineDirective: ?forcefile:bool -> location -> Flx_cil_pretty.doc
    (** Print a line-number. This is assumed to come always on an empty line.
     * If the forcefile argument is present and is true then the file name
     * will be printed always. Otherwise the file name is printed only if it
     * is different from the last time time this function is called. The last
     * file name is stored in a private field inside the cilPrinter object. *)

  method pStmtKind : stmt -> unit -> stmtkind -> Flx_cil_pretty.doc
    (** Print a statement kind. The code to be printed is given in the
     * {!Flx_cil_cil.stmtkind} argument.  The initial {!Flx_cil_cil.stmt} argument
     * records the statement which follows the one being printed;
     * {!Flx_cil_cil.defaultCilPrinterClass} uses this information to prettify
     * statement printing in certain special cases. *)

  method pExp: unit -> exp -> doc
    (** Print expressions *)

  method pInit: unit -> init -> doc
    (** Print initializers. This can be slow and is used by
     * {!Flx_cil_cil.printGlobal} but not by {!Flx_cil_cil.dumpGlobal}. *)

  method dInit: out_channel -> int -> init -> unit
    (** Dump a global to a file with a given indentation. This is used by
     * {!Flx_cil_cil.dumpGlobal}. *)
end


class defaultCilPrinterClass : cilPrinter = object (self)
  val mutable currentFormals : varinfo list = []
  method private getLastNamedArgument (s: string) : exp =
    match List.rev currentFormals with
      f :: _ -> Lval (var f)
    | [] ->
        E.s (warn "Cannot find the last named argument when priting call to %s\n" s);
        zero

  (*** VARIABLES ***)
  (* variable use *)
  method pVar (v:varinfo) = text v.vname

  (* variable declaration *)
  method pVDecl () (v:varinfo) =
    let stom, rest = separateStorageModifiers v.vattr in
    (* First the storage modifiers *)
    text (if v.vinline then "__inline " else "")
      ++ d_storage () v.vstorage
      ++ (self#pAttrs () stom)
      ++ (self#pType (Some (text v.vname)) () v.vtype)
      ++ text " "
      ++ self#pAttrs () rest

  (*** L-VALUES ***)
  method pLval () (lv:lval) =  (* lval (base is 1st field)  *)
    match lv with
      Var vi, o -> self#pOffset (self#pVar vi) o
    | Mem e, Field(fi, o) ->
        self#pOffset
          ((self#pExpPrec arrowLevel () e) ++ text ("->" ^ fi.fname)) o
    | Mem e, o ->
        self#pOffset
          (text "(*" ++ self#pExpPrec derefStarLevel () e ++ text ")") o

  (** Offsets **)
  method pOffset (base: doc) = function
    | NoOffset -> base
    | Field (fi, o) ->
        self#pOffset (base ++ text "." ++ text fi.fname) o
    | Index (e, o) ->
        self#pOffset (base ++ text "[" ++ self#pExp () e ++ text "]") o

  method private pLvalPrec (contextprec: int) () lv =
    if getParenthLevel (Lval(lv)) >= contextprec then
      text "(" ++ self#pLval () lv ++ text ")"
    else
      self#pLval () lv

  (*** EXPRESSIONS ***)
  method pExp () (e: exp) : doc =
    let level = getParenthLevel e in
    match e with
      Const(c) -> d_const () c
    | Lval(l) -> self#pLval () l
    | UnOp(u,e1,_) ->
        let d_unop () u =
          match u with
            Neg -> text "-"
          | BNot -> text "~"
          | LNot -> text "!"
        in
        (d_unop () u) ++ chr ' ' ++ (self#pExpPrec level () e1)

    | BinOp(b,e1,e2,_) ->
        align
          ++ (self#pExpPrec level () e1)
          ++ chr ' '
          ++ (d_binop () b)
          ++ break
          ++ (self#pExpPrec level () e2)
          ++ unalign

    | CastE(t,e) ->
        text "("
          ++ self#pType None () t
          ++ text ")"
          ++ self#pExpPrec level () e

    | SizeOf (t) ->
        text "sizeof(" ++ self#pType None () t ++ chr ')'
    | SizeOfE (e) ->  text "sizeof(" ++ self#pExp () e ++ chr ')'

    | SizeOfStr s ->
        text "sizeof(" ++ d_const () (CStr s) ++ chr ')'

    | AlignOf (t) ->
        text "__alignof__(" ++ self#pType None () t ++ chr ')'
    | AlignOfE (e) ->
        text "__alignof__(" ++ self#pExp () e ++ chr ')'
    | AddrOf(lv) ->
        text "& " ++ (self#pLvalPrec addrOfLevel () lv)

    | StartOf(lv) -> self#pLval () lv

  method private pExpPrec (contextprec: int) () (e: exp) =
    let thisLevel = getParenthLevel e in
    let needParens =
      if thisLevel >= contextprec then
        true
      else if contextprec == bitwiseLevel then
        (* quiet down some GCC warnings *)
        thisLevel == additiveLevel || thisLevel == comparativeLevel
      else
        false
    in
    if needParens then
      chr '(' ++ self#pExp () e ++ chr ')'
    else
      self#pExp () e

  method pInit () = function
      SingleInit e -> self#pExp () e
    | CompoundInit (t, initl) ->
      (* We do not print the type of the Compound *)
(*
      let dinit e = d_init () e in
      dprintf "{@[%a@]}"
        (docList (chr ',' ++ break) dinit) initl
*)
        let printDesignator =
          if not !msvcMode then begin
            (* Print only for union when we do not initialize the first field *)
            match unrollType t, initl with
              TComp(ci, _), [(Field(f, NoOffset), _)] ->
                if not (ci.cstruct) && ci.cfields != [] &&
                  (List.hd ci.cfields).fname = f.fname then
                  true
                else
                  false
            | _ -> false
          end else
            false
        in
        let d_oneInit = function
            Field(f, NoOffset), i ->
              (if printDesignator then
                text ("." ^ f.fname ^ " = ")
              else nil) ++ self#pInit () i
          | Index(e, NoOffset), i ->
              (if printDesignator then
                text "[" ++ self#pExp () e ++ text "] = " else nil) ++
                self#pInit () i
          | _ -> E.s (unimp "Trying to print malformed initializer")
        in
        chr '{' ++ (align
                      ++ ((docList (chr ',' ++ break) d_oneInit) () initl)
                      ++ unalign)
          ++ chr '}'
(*
    | ArrayInit (_, _, il) ->
        chr '{' ++ (align
                      ++ ((docList (chr ',' ++ break) (self#pInit ())) () il)
                      ++ unalign)
          ++ chr '}'
*)
  (* dump initializers to a file. *)
  method dInit (out: out_channel) (ind: int) (i: init) =
    (* Dump an array *)
    let dumpArray (bt: typ) (il: 'a list) (getelem: 'a -> init) =
      let onALine = (* How many elements on a line *)
        match unrollType bt with TComp _ | TArray _ -> 1 | _ -> 4
      in
      let rec outputElements (isfirst: bool) (room_on_line: int) = function
          [] -> output_string out "}"
        | (i: 'a) :: rest ->
            if not isfirst then output_string out ", ";
            let new_room_on_line =
              if room_on_line == 0 then begin
                output_string out "\n"; output_string out (String.make ind ' ');
                onALine - 1
              end else
                room_on_line - 1
            in
            self#dInit out (ind + 2) (getelem i);
            outputElements false new_room_on_line rest
      in
      output_string out "{ ";
      outputElements true onALine il
    in
    match i with
      SingleInit e ->
        fprint out 80 (indent ind (self#pExp () e))
    | CompoundInit (t, initl) -> begin
        match unrollType t with
          TArray(bt, _, _) ->
            dumpArray bt initl (fun (_, i) -> i)
        | _ ->
            (* Now a structure or a union *)
            fprint out 80 (indent ind (self#pInit () i))
    end
(*
    | ArrayInit (bt, len, initl) -> begin
        (* If the base type does not contain structs then use the pInit
        match unrollType bt with
          TComp _ | TArray _ ->
            dumpArray bt initl (fun x -> x)
        | _ -> *)
            fprint out 80 (indent ind (self#pInit () i))
    end
*)

  (** What terminator to print after an instruction. sometimes we want to
   * print sequences of instructions separated by comma *)
  val mutable printInstrTerminator = ";"

  (*** INSTRUCTIONS ****)
  method pInstr () (i:instr) =       (* imperative instruction *)
    match i with
    | Set(lv,e,l) -> begin
        (* Be nice to some special cases *)
        match e with
          BinOp((PlusA|PlusPI|IndexPI),Lval(lv'),Const(CInt64(one,_,_)),_)
            when lv == lv' && one = Int64.one && not !printCilAsIs ->
              self#pLineDirective l
                ++ self#pLval () lv
                ++ text (" ++" ^ printInstrTerminator)

        | BinOp((MinusA|MinusPI),Lval(lv'),
                Const(CInt64(one,_,_)), _)
            when lv == lv' && one = Int64.one && not !printCilAsIs ->
                  self#pLineDirective l
                    ++ self#pLval () lv
                    ++ text (" --" ^ printInstrTerminator)

        | BinOp((PlusA|PlusPI|IndexPI),Lval(lv'),Const(CInt64(mone,_,_)),_)
            when lv == lv' && mone = Int64.minus_one && not !printCilAsIs ->
              self#pLineDirective l
                ++ self#pLval () lv
                ++ text (" --" ^ printInstrTerminator)

        | BinOp((PlusA|PlusPI|IndexPI|MinusA|MinusPP|MinusPI|BAnd|BOr|BXor|
          Mult|Div|Mod|Shiftlt|Shiftrt) as bop,
                Lval(lv'),e,_) when lv == lv' ->
                  self#pLineDirective l
                    ++ self#pLval () lv
                    ++ text " " ++ d_binop () bop
                    ++ text "= "
                    ++ self#pExp () e
                    ++ text printInstrTerminator

        | _ ->
            self#pLineDirective l
              ++ self#pLval () lv
              ++ text " = "
              ++ self#pExp () e
              ++ text printInstrTerminator

    end
      (* In cabs2cil we have turned the call to builtin_va_arg into a
       * three-argument call: the last argument is the address of the
       * destination *)
    | Call(None, Lval(Var vi, NoOffset), [dest; SizeOf t; adest], l)
        when vi.vname = "__builtin_va_arg" && not !printCilAsIs ->
          let rec stripCast = function
              CastE (_, e) -> stripCast e
            | e -> e in
          let destlv = match stripCast adest with
            AddrOf destlv -> destlv
          | _ -> E.s (E.error "Encountered unexpected call to %s\n" vi.vname)
          in
          self#pLineDirective l
            ++ self#pLval () destlv ++ text " = "

            (* Now the function name *)
            ++ text "__builtin_va_arg"
            ++ text "(" ++ (align
                              (* Now the arguments *)
                              ++ self#pExp () dest
                              ++ chr ',' ++ break
                              ++ self#pType None () t
                              ++ unalign)
            ++ text (")" ^ printInstrTerminator)

      (* In cabs2cil we have dropped the last argument in the call to
       * __builtin_stdarg_start. *)
    | Call(None, Lval(Var vi, NoOffset), [marker], l)
        when vi.vname = "__builtin_stdarg_start" && not !printCilAsIs -> begin
          let last = self#getLastNamedArgument vi.vname in
          self#pInstr () (Call(None,Lval(Var vi,NoOffset),[marker; last],l))
        end

      (* In cabs2cil we have dropped the last argument in the call to
       * __builtin_next_arg. *)
    | Call(res, Lval(Var vi, NoOffset), [ ], l)
        when vi.vname = "__builtin_next_arg" && not !printCilAsIs -> begin
          let last = self#getLastNamedArgument vi.vname in
          self#pInstr () (Call(res,Lval(Var vi,NoOffset),[last],l))
        end

    | Call(dest,e,args,l) ->
        self#pLineDirective l
          ++ (match dest with
            None -> nil
          | Some lv ->
              self#pLval () lv ++ text " = " ++
                (* Maybe we need to print a cast *)
                (let destt = typeOfLval lv in
                match unrollType (typeOf e) with
                  TFun (rt, _, _, _) when typeSig rt <> typeSig destt ->
                    text "(" ++ self#pType None () destt ++ text ")"
                | _ -> nil))
          (* Now the function name *)
          ++ (let ed = self#pExp () e in
              match e with
                Lval(Var _, _) -> ed
              | _ -> text "(" ++ ed ++ text ")")
          ++ text "(" ++
          (align
             (* Now the arguments *)
             ++ (docList (chr ',' ++ break)
                   (self#pExp ()) () args)
             ++ unalign)
        ++ text (")" ^ printInstrTerminator)

    | Asm(attrs, tmpls, outs, ins, clobs, l) ->
        if !msvcMode then
          self#pLineDirective l
            ++ text "__asm {"
            ++ (align
                  ++ (docList line text () tmpls)
                  ++ unalign)
            ++ text ("}" ^ printInstrTerminator)
        else
          self#pLineDirective l
            ++ text ("__asm__ ")
            ++ self#pAttrs () attrs
            ++ text " ("
            ++ (align
                  ++ (docList line
                        (fun x -> text ("\"" ^ escape_string x ^ "\""))
                        () tmpls)
                  ++
                  (if outs = [] && ins = [] && clobs = [] then
                    nil
                else
                  (text ": "
                     ++ (docList (chr ',' ++ break)
                           (fun (c, lv) ->
                             text ("\"" ^ escape_string c ^ "\" (")
                               ++ self#pLval () lv
                               ++ text ")") () outs)))
                ++
                  (if ins = [] && clobs = [] then
                    nil
                  else
                    (text ": "
                       ++ (docList (chr ',' ++ break)
                             (fun (c, e) ->
                               text ("\"" ^ escape_string c ^ "\" (")
                                 ++ self#pExp () e
                                 ++ text ")") () ins)))
                  ++
                  (if clobs = [] then nil
                  else
                    (text ": "
                       ++ (docList (chr ',' ++ break)
                             (fun c -> text ("\"" ^ escape_string c ^ "\""))
                             ()
                             clobs)))
                  ++ unalign)
            ++ text (")" ^ printInstrTerminator)


  (**** STATEMENTS ****)
  method pStmt () (s:stmt) =        (* control-flow statement *)
    self#pStmtNext invalidStmt () s

  method dStmt (out: out_channel) (ind: int) (s:stmt) : unit =
    fprint out 80 (indent ind (self#pStmt () s))

  method dBlock (out: out_channel) (ind: int) (b:block) : unit =
    fprint out 80 (indent ind (self#pBlock () b))

  method private pStmtNext (next: stmt) () (s: stmt) =
    (* print the labels *)
    ((docList line (fun l -> self#pLabel () l)) () s.labels)
      (* print the statement itself. If the labels are non-empty and the
      * statement is empty, print a semicolon  *)
      ++
      (if s.skind = Instr [] && s.labels <> [] then
        text ";"
      else
        (if s.labels <> [] then line else nil)
          ++ self#pStmtKind next () s.skind)

  method private pLabel () = function
      Label (s, _, true) -> text (s ^ ": ")
    | Label (s, _, false) -> text (s ^ ": /* CIL Label */ ")
    | Case (e, _) -> text "case " ++ self#pExp () e ++ text ": "
    | Default _ -> text "default: "

  (* The pBlock will put the unalign itself *)
  method pBlock () (blk: block) =
    let rec dofirst () = function
        [] -> nil
      | [x] -> self#pStmtNext invalidStmt () x
      | x :: rest -> dorest nil x rest
    and dorest acc prev = function
        [] -> acc ++ (self#pStmtNext invalidStmt () prev)
      | x :: rest ->
          dorest (acc ++ (self#pStmtNext x () prev) ++ line)
            x rest
    in
    (* Let the host of the block decide on the alignment. The d_block will
     * pop the alignment as well  *)
    text "{"
      ++
      (if blk.battrs <> [] then
        self#pAttrsGen true blk.battrs
      else nil)
      ++ line
      ++ (dofirst () blk.bstmts)
      ++ unalign ++ line ++ text "}"


  (* Store here the name of the last file printed in a line number. This is
   * private to the object *)
  val mutable lastFileName = ""
  (* Make sure that you only call self#pLineDirective on an empty line *)
  method pLineDirective ?(forcefile=false) l =
    currentLoc := l;
    match !lineDirectiveStyle with
    | Some style when l.line > 0 ->
        let directive =
          match style with
          | LineComment -> text "//#line "
          | LinePreprocessorOutput when not !msvcMode -> chr '#'
          | _ -> text "#line"
        in
        let filename =
          if forcefile || l.file <> lastFileName then
            begin
              lastFileName <- l.file;
              text " \"" ++ text l.file ++ text "\""
            end
          else
            nil
        in
        leftflush ++ directive ++ chr ' ' ++ num l.line ++ filename ++ line
    | _ ->
        nil


  method private pStmtKind (next: stmt) () = function
      Return(None, l) ->
        self#pLineDirective l
          ++ text "return;"

    | Return(Some e, l) ->
        self#pLineDirective l
          ++ text "return ("
          ++ self#pExp () e
          ++ text ");"

    | Goto (sref, l) -> begin
        (* Grab one of the labels *)
        let rec pickLabel = function
            [] -> None
          | Label (l, _, _) :: _ -> Some l
          | _ :: rest -> pickLabel rest
        in
        match pickLabel !sref.labels with
          Some l -> text ("goto " ^ l ^ ";")
        | None ->
            ignore (error "Cannot find label for target of goto\n");
            text "goto __invalid_label;"
    end

    | Break l ->
        self#pLineDirective l
          ++ text "break;"

    | Continue l ->
        self#pLineDirective l
          ++ text "continue;"

    | Instr il ->
        align
          ++ (docList line (fun i -> self#pInstr () i) () il)
          ++ unalign

    | If(be,t,{bstmts=[];battrs=[]},l) when not !printCilAsIs ->
        self#pLineDirective l
          ++ text "if"
          ++ (align
                ++ text " ("
                ++ self#pExp () be
                ++ text ") "
                ++ self#pBlock () t)

    | If(be,t,{bstmts=[{skind=Goto(gref,_);labels=[]} as s];
                battrs=[]},l)
     when !gref == next && not !printCilAsIs ->
       self#pLineDirective l
         ++ text "if"
         ++ (align
               ++ text " ("
               ++ self#pExp () be
               ++ text ") "
               ++ self#pBlock () t)

    | If(be,{bstmts=[];battrs=[]},e,l) when not !printCilAsIs ->
        self#pLineDirective l
          ++ text "if"
          ++ (align
                ++ text " ("
                ++ self#pExp () (UnOp(LNot,be,intType))
                ++ text ") "
                ++ self#pBlock () e)

    | If(be,{bstmts=[{skind=Goto(gref,_);labels=[]} as s];
           battrs=[]},e,l)
      when !gref == next && not !printCilAsIs ->
        self#pLineDirective l
          ++ text "if"
          ++ (align
                ++ text " ("
                ++ self#pExp () (UnOp(LNot,be,intType))
                ++ text ") "
                ++ self#pBlock () e)

    | If(be,t,e,l) ->
        self#pLineDirective l
          ++ (align
                ++ text "if"
                ++ (align
                      ++ text " ("
                      ++ self#pExp () be
                      ++ text ") "
                      ++ self#pBlock () t)
                ++ text " "   (* sm: indent next code 2 spaces (was 4) *)
                ++ (align
                      ++ text "else "
                      ++ self#pBlock () e)
          ++ unalign)

    | Switch(e,b,_,l) ->
        self#pLineDirective l
          ++ (align
                ++ text "switch ("
                ++ self#pExp () e
                ++ text ") "
                ++ self#pBlock () b)
    | Loop(b, l, _, _) -> begin
        (* Maybe the first thing is a conditional. Turn it into a WHILE *)
        try
          let term, bodystmts =
            let rec skipEmpty = function
                [] -> []
              | {skind=Instr [];labels=[]} :: rest -> skipEmpty rest
              | x -> x
            in
            (* Bill McCloskey: Do not remove the If if it has labels *)
            match skipEmpty b.bstmts with
              {skind=If(e,tb,fb,_); labels=[]} :: rest
                                              when not !printCilAsIs -> begin
                match skipEmpty tb.bstmts, skipEmpty fb.bstmts with
                  [], {skind=Break _; labels=[]} :: _  -> e, rest
                | {skind=Break _; labels=[]} :: _, []
                                     -> UnOp(LNot, e, intType), rest
                | _ -> raise Not_found
              end
            | _ -> raise Not_found
          in
          self#pLineDirective l
            ++ text "wh"
            ++ (align
                  ++ text "ile ("
                  ++ self#pExp () term
                  ++ text ") "
                  ++ self#pBlock () {bstmts=bodystmts; battrs=b.battrs})

        with Not_found ->
          self#pLineDirective l
            ++ text "wh"
            ++ (align
                  ++ text "ile (1) "
                  ++ self#pBlock () b)
    end
    | Block b -> align ++ self#pBlock () b

    | TryFinally (b, h, l) ->
        self#pLineDirective l
          ++ text "__try "
          ++ align
          ++ self#pBlock () b
          ++ text " __fin" ++ align ++ text "ally "
          ++ self#pBlock () h

    | TryExcept (b, (il, e), h, l) ->
        self#pLineDirective l
          ++ text "__try "
          ++ align
          ++ self#pBlock () b
          ++ text " __e" ++ align ++ text "xcept(" ++ line
          ++ align
          (* Print the instructions but with a comma at the end, instead of
           * semicolon *)
          ++ (printInstrTerminator <- ",";
              let res =
                (docList line (self#pInstr ())
                   () il)
              in
              printInstrTerminator <- ";";
              res)
          ++ self#pExp () e
          ++ text ") " ++ unalign
          ++ self#pBlock () h


  (*** GLOBALS ***)
  method pGlobal () (g:global) : doc =       (* global (vars, types, etc.) *)
    match g with
    | GFun (fundec, l) ->
        (* If the function has attributes then print a prototype because
        * GCC cannot accept function attributes in a definition *)
        let oldattr = fundec.svar.vattr in
        (* Always pring the file name before function declarations *)
        let proto =
          if oldattr <> [] then
            (self#pLineDirective l) ++ (self#pVDecl () fundec.svar)
              ++ chr ';' ++ line
          else nil in
        (* Temporarily remove the function attributes *)
        fundec.svar.vattr <- [];
        let body = (self#pLineDirective ~forcefile:true l)
                      ++ (self#pFunDecl () fundec) in
        fundec.svar.vattr <- oldattr;
        proto ++ body ++ line

    | GType (typ, l) ->
        self#pLineDirective ~forcefile:true l ++
          text "typedef "
          ++ (self#pType (Some (text typ.tname)) () typ.ttype)
          ++ text ";\n"

    | GEnumTag (enum, l) ->
        self#pLineDirective l ++
          text "enum" ++ align ++ text (" " ^ enum.ename) ++
          self#pAttrs () enum.eattr ++ text " {" ++ line
          ++ (docList (chr ',' ++ line)
                (fun (n,i, loc) ->
                  text (n ^ " = ")
                    ++ self#pExp () i)
                () enum.eitems)
          ++ unalign ++ line ++ text "};\n"

    | GEnumTagDecl (enum, l) -> (* This is a declaration of a tag *)
        self#pLineDirective l ++
          text ("enum " ^ enum.ename ^ ";\n")

    | GCompTag (comp, l) -> (* This is a definition of a tag *)
        let n = comp.cname in
        let su, su1, su2 =
          if comp.cstruct then "struct", "str", "uct"
          else "union",  "uni", "on"
        in
        let sto_mod, rest_attr = separateStorageModifiers comp.cattr in
        self#pLineDirective ~forcefile:true l ++
          text su1 ++ (align ++ text su2 ++ chr ' ' ++ (self#pAttrs () sto_mod)
                         ++ text n
                         ++ text " {" ++ line
                         ++ ((docList line (self#pFieldDecl ())) ()
                               comp.cfields)
                         ++ unalign)
          ++ line ++ text "}" ++
          (self#pAttrs () rest_attr) ++ text ";\n"

    | GCompTagDecl (comp, l) -> (* This is a declaration of a tag *)
        self#pLineDirective l ++
          text (compFullName comp) ++ text ";\n"

    | GVar (vi, io, l) ->
        self#pLineDirective ~forcefile:true l ++
          self#pVDecl () vi
          ++ chr ' '
          ++ (match io.init with
            None -> nil
          | Some i -> text " = " ++
                (let islong =
                  match i with
                    CompoundInit (_, il) when List.length il >= 8 -> true
                  | _ -> false
                in
                if islong then
                  line ++ self#pLineDirective l ++ text "  "
                else nil) ++
                (self#pInit () i))
          ++ text ";\n"

    (* print global variable 'extern' declarations, and function prototypes *)
    | GVarDecl (vi, l) ->
        self#pLineDirective l ++
          (self#pVDecl () vi)
          ++ text ";\n"

    | GAsm (s, l) ->
        self#pLineDirective l ++
          text ("__asm__(\"" ^ escape_string s ^ "\");\n")

    | GPragma (Attr(an, args), l) ->
        (* sm: suppress printing pragmas that gcc does not understand *)
        (* assume anything starting with "ccured" is ours *)
        (* also don't print the 'combiner' pragma *)
        (* nor 'cilnoremove' *)
        let suppress =
          not !print_CIL_Input &&
          not !msvcMode &&
          ((startsWith "box" an) ||
           (startsWith "ccured" an) ||
           (an = "merger") ||
           (an = "cilnoremove")) in
        let d =
          match an, args with
          | _, [] ->
              text an
          | "weak", [ACons (symbol, [])] ->
              text "weak " ++ text symbol
          | _ ->
            text (an ^ "(")
              ++ docList (chr ',') (self#pAttrParam ()) () args
              ++ text ")"
        in
        self#pLineDirective l
          ++ (if suppress then text "/* " else text "")
          ++ (text "#pragma ")
          ++ d
          ++ (if suppress then text " */\n" else text "\n")

    | GText s  ->
        if s <> "//" then
          text s ++ text "\n"
        else
          nil


   method dGlobal (out: out_channel) (g: global) : unit =
     (* For all except functions and variable with initializers, use the
      * pGlobal *)
     match g with
       GFun (fdec, l) ->
         (* If the function has attributes then print a prototype because
          * GCC cannot accept function attributes in a definition *)
         let oldattr = fdec.svar.vattr in
         let proto =
           if oldattr <> [] then
             (self#pLineDirective l) ++ (self#pVDecl () fdec.svar)
               ++ chr ';' ++ line
           else nil in
         fprint out 80 (proto ++ (self#pLineDirective ~forcefile:true l));
         (* Temporarily remove the function attributes *)
         fdec.svar.vattr <- [];
         fprint out 80 (self#pFunDecl () fdec);
         fdec.svar.vattr <- oldattr;
         output_string out "\n"

     | GVar (vi, {init = Some i}, l) -> begin
         fprint out 80
           (self#pLineDirective ~forcefile:true l ++
              self#pVDecl () vi
              ++ text " = "
              ++ (let islong =
                match i with
                  CompoundInit (_, il) when List.length il >= 8 -> true
                | _ -> false
              in
              if islong then
                line ++ self#pLineDirective l ++ text "  "
              else nil));
         self#dInit out 3 i;
         output_string out ";\n"
     end

     | g -> fprint out 80 (self#pGlobal () g)

   method pFieldDecl () fi =
     (self#pType
        (Some (text (if fi.fname = missingFieldName then "" else fi.fname)))
        ()
        fi.ftype)
       ++ text " "
       ++ (match fi.fbitfield with None -> nil
       | Some i -> text ": " ++ num i ++ text " ")
       ++ self#pAttrs () fi.fattr
       ++ text ";"

  method private pFunDecl () f =
      self#pVDecl () f.svar
      ++  line
      ++ text "{ "
      ++ (align
            (* locals. *)
            ++ (docList line (fun vi -> self#pVDecl () vi ++ text ";")
                  () f.slocals)
            ++ line ++ line
            (* the body *)
            ++ ((* remember the declaration *) currentFormals <- f.sformals;
                let body = self#pBlock () f.sbody in
                currentFormals <- [];
                body))
      ++ line
      ++ text "}"

  (***** PRINTING DECLARATIONS and TYPES ****)

  method pType (nameOpt: doc option) (* Whether we are declaring a name or
                                      * we are just printing a type *)
               () (t:typ) =       (* use of some type *)
    let name = match nameOpt with None -> nil | Some d -> d in
    let printAttributes (a: attributes) =
      let pa = self#pAttrs () a in
      match nameOpt with
      | None when not !print_CIL_Input && not !msvcMode ->
          (* Cannot print the attributes in this case because gcc does not
           * like them here, except if we are printing for CIL, or for MSVC.
           * In fact, for MSVC we MUST print attributes such as __stdcall *)
          if pa = nil then nil else
          text "/*" ++ pa ++ text "*/"
      | _ -> pa
    in
    match t with
      TVoid a ->
        text "void"
          ++ self#pAttrs () a
          ++ text " "
          ++ name

    | TInt (ikind,a) ->
        d_ikind () ikind
          ++ self#pAttrs () a
          ++ text " "
          ++ name

    | TFloat(fkind, a) ->
        d_fkind () fkind
          ++ self#pAttrs () a
          ++ text " "
          ++ name

    | TComp (comp, a) -> (* A reference to a struct *)
        let su = if comp.cstruct then "struct" else "union" in
        text (su ^ " " ^ comp.cname ^ " ")
          ++ self#pAttrs () a
          ++ name

    | TEnum (enum, a) ->
        text ("enum " ^ enum.ename ^ " ")
          ++ self#pAttrs () a
          ++ name
    | TPtr (bt, a)  ->
        (* Parenthesize the ( * attr name) if a pointer to a function or an
         * array. However, on MSVC the __stdcall modifier must appear right
         * before the pointer constructor "(__stdcall *f)". We push them into
         * the parenthesis. *)
        let (paren: doc option), (bt': typ) =
          match bt with
            TFun(rt, args, isva, fa) when !msvcMode ->
              let an, af', at = partitionAttributes ~default:AttrType fa in
              (* We take the af' and we put them into the parentheses *)
              Some (text "(" ++ printAttributes af'),
              TFun(rt, args, isva, addAttributes an at)

          | TFun _ | TArray _ -> Some (text "("), bt

          | _ -> None, bt
        in
        let name' = text "*" ++ printAttributes a ++ name in
        let name'' = (* Put the parenthesis *)
          match paren with
            Some p -> p ++ name' ++ text ")"
          | _ -> name'
        in
        self#pType
          (Some name'')
          ()
          bt'

    | TArray (elemt, lo, a) ->
        let name' =
          if a == [] then name else
          if nameOpt == None then printAttributes a else
          text "(" ++ printAttributes a ++ name ++ text ")"
        in
        self#pType
          (Some (name'
                   ++ text "["
                   ++ (match lo with None -> nil | Some e -> self#pExp () e)
                   ++ text "]"))
          ()
          elemt

    | TFun (restyp, args, isvararg, a) ->
        let name' =
          if a == [] then name else
          if nameOpt == None then printAttributes a else
          text "(" ++ printAttributes a ++ name ++ text ")"
        in
        self#pType
          (Some
             (name'
                ++ text "("
                ++ (align
                      ++
                      (if args = Some [] && isvararg then
                        text "..."
                      else
                        (if args = None then nil
                        else if args = Some [] then text "void"
                        else
                          let pArg (aname, atype, aattr) =
                            let stom, rest = separateStorageModifiers aattr in
                            (* First the storage modifiers *)
                            (self#pAttrs () stom)
                              ++ (self#pType (Some (text aname)) () atype)
                              ++ text " "
                              ++ self#pAttrs () rest
                          in
                          (docList (chr ',' ++ break) pArg) ()
                            (argsToList args))
                          ++ (if isvararg then break ++ text ", ..." else nil))
                      ++ unalign)
                ++ text ")"))
          ()
          restyp

  | TNamed (t, a) ->
      text t.tname ++ self#pAttrs () a ++ text " " ++ name

  | TBuiltin_va_list a ->
      text "__builtin_va_list"
       ++ self#pAttrs () a
        ++ text " "
        ++ name


  (**** PRINTING ATTRIBUTES *********)
  method pAttrs () (a: attributes) =
    self#pAttrsGen false a


  (* Print one attribute. Return also an indication whether this attribute
   * should be printed inside the __attribute__ list *)
  method pAttr (Attr(an, args): attribute) : doc * bool =
    (* Recognize and take care of some known cases *)
    match an, args with
      "const", [] -> text "const", false
          (* Put the aconst inside the attribute list *)
    | "aconst", [] when not !msvcMode -> text "__const__", true
    | "thread", [] when not !msvcMode -> text "__thread", false
    | "volatile", [] -> text "volatile", false
    | "restrict", [] -> text "__restrict", false
    | "missingproto", [] -> text "/* missing proto */", false
    | "cdecl", [] when !msvcMode -> text "__cdecl", false
    | "stdcall", [] when !msvcMode -> text "__stdcall", false
    | "fastcall", [] when !msvcMode -> text "__fastcall", false
    | "declspec", args when !msvcMode ->
        text "__declspec("
          ++ docList (chr ',') (self#pAttrParam ()) () args
          ++ text ")", false
    | "w64", [] when !msvcMode -> text "__w64", false
    | "asm", args ->
        text "__asm__("
          ++ docList (chr ',') (self#pAttrParam ()) () args
          ++ text ")", false
    (* we suppress printing mode(__si__) because it triggers an *)
    (* internal compiler error in all current gcc versions *)
    (* sm: I've now encountered a problem with mode(__hi__)... *)
    (* I don't know what's going on, but let's try disabling all "mode"..*)
    | "mode", [ACons(tag,[])] ->
        text "/* mode(" ++ text tag ++ text ") */", false

    (* sm: also suppress "format" because we seem to print it in *)
    (* a way gcc does not like *)
    | "format", _ -> text "/* format attribute */", false

    (* sm: here's another one I don't want to see gcc warnings about.. *)
    | "mayPointToStack", _ when not !print_CIL_Input
    (* [matth: may be inside another comment.]
      -> text "/*mayPointToStack*/", false
    *)
      -> text "", false

    | _ -> (* This is the dafault case *)
        (* Add underscores to the name *)
        let an' = if !msvcMode then "__" ^ an else "__" ^ an ^ "__" in
        if args = [] then
          text an', true
        else
          text (an' ^ "(")
            ++ (docList (chr ',') (self#pAttrParam ()) () args)
            ++ text ")",
          true

  method pAttrParam () = function
    | AInt n -> num n
    | AStr s -> text ("\"" ^ escape_string s ^ "\"")
    | ACons(s, []) -> text s
    | ACons(s,al) ->
        text (s ^ "(")
          ++ (docList (chr ',') (self#pAttrParam ()) () al)
          ++ text ")"
    | ASizeOfE a -> text "sizeof(" ++ self#pAttrParam () a ++ text ")"
    | ASizeOf t -> text "sizeof(" ++ self#pType None () t ++ text ")"
    | AAlignOfE a -> text "__alignof__(" ++ self#pAttrParam () a ++ text ")"
    | AAlignOf t -> text "__alignof__(" ++ self#pType None () t ++ text ")"
    | AUnOp(u,a1) ->
        let d_unop () u =
          match u with
            Neg -> text "-"
          | BNot -> text "~"
          | LNot -> text "!"
        in
        (d_unop () u) ++ text " (" ++ (self#pAttrParam () a1) ++ text ")"

    | ABinOp(b,a1,a2) ->
        align
          ++ text "("
          ++ (self#pAttrParam () a1)
          ++ text ") "
          ++ (d_binop () b)
          ++ break
          ++ text " (" ++ (self#pAttrParam () a2) ++ text ") "
          ++ unalign
    | ADot (ap, s) -> (self#pAttrParam () ap) ++ text ("." ^ s)

  (* A general way of printing lists of attributes *)
  method private pAttrsGen (block: bool) (a: attributes) =
    (* Scan all the attributes and separate those that must be printed inside
     * the __attribute__ list *)
    let rec loop (in__attr__: doc list) = function
        [] -> begin
          match in__attr__ with
            [] -> nil
          | _ :: _->
              (* sm: added 'forgcc' calls to not comment things out
               * if CIL is the consumer; this is to address a case
               * Daniel ran into where blockattribute(nobox) was being
               * dropped by the merger
               *)
              (if block then
                text (" " ^ (forgcc "/*") ^ " __blockattribute__(")
               else
                 text "__attribute__((")

                ++ (docList (chr ',' ++ break)
                      (fun a -> a)) () in__attr__
                ++ text ")"
                ++ (if block then text (forgcc "*/") else text ")")
        end
      | x :: rest ->
          let dx, ina = self#pAttr x in
          if ina then
            loop (dx :: in__attr__) rest
          else
            dx ++ text " " ++ loop in__attr__ rest
    in
    let res = loop [] a in
    if res = nil then
      res
    else
      text " " ++ res ++ text " "

end (* class defaultCilPrinterClass *)

let defaultCilPrinter = new defaultCilPrinterClass

(* Top-level printing functions *)
let printType (pp: cilPrinter) () (t: typ) : doc =
  pp#pType None () t

let printExp (pp: cilPrinter) () (e: exp) : doc =
  pp#pExp () e

let printLval (pp: cilPrinter) () (lv: lval) : doc =
  pp#pLval () lv

let printGlobal (pp: cilPrinter) () (g: global) : doc =
  pp#pGlobal () g

let dumpGlobal (pp: cilPrinter) (out: out_channel) (g: global) : unit =
  pp#dGlobal out g

let printAttr (pp: cilPrinter) () (a: attribute) : doc =
  let ad, _ = pp#pAttr a in ad

let printAttrs (pp: cilPrinter) () (a: attributes) : doc =
  pp#pAttrs () a

let printInstr (pp: cilPrinter) () (i: instr) : doc =
  pp#pInstr () i

let printStmt (pp: cilPrinter) () (s: stmt) : doc =
  pp#pStmt () s

let printBlock (pp: cilPrinter) () (b: block) : doc =
  (* We must add the alignment ourselves, beucase pBlock will pop it *)
  align ++ pp#pBlock () b

let dumpStmt (pp: cilPrinter) (out: out_channel) (ind: int) (s: stmt) : unit =
  pp#dStmt out ind s

let dumpBlock (pp: cilPrinter) (out: out_channel) (ind: int) (b: block) : unit =
  pp#dBlock out ind b

let printInit (pp: cilPrinter) () (i: init) : doc =
  pp#pInit () i

let dumpInit (pp: cilPrinter) (out: out_channel) (ind: int) (i: init) : unit =
  pp#dInit out ind i

(* Now define some short cuts *)
let d_exp () e = printExp defaultCilPrinter () e
let d_lval () lv = printLval defaultCilPrinter () lv
let d_offset base () off = defaultCilPrinter#pOffset base off
let d_init () i = printInit defaultCilPrinter () i
let d_type () t = printType defaultCilPrinter () t
let d_global () g = printGlobal defaultCilPrinter () g
let d_attrlist () a = printAttrs defaultCilPrinter () a
let d_attr () a = printAttr defaultCilPrinter () a
let d_attrparam () e = defaultCilPrinter#pAttrParam () e
let d_label () l = defaultCilPrinter#pLabel () l
let d_stmt () s = printStmt defaultCilPrinter () s
let d_block () b = printBlock defaultCilPrinter () b
let d_instr () i = printInstr defaultCilPrinter () i

let d_shortglobal () = function
    GPragma (Attr(an, _), _) -> dprintf "#pragma %s" an
  | GType (ti, _) -> dprintf "typedef %s" ti.tname
  | GVarDecl (vi, _) -> dprintf "declaration of %s" vi.vname
  | GVar (vi, _, _) -> dprintf "definition of %s" vi.vname
  | GCompTag(ci,_) -> dprintf "definition of %s" (compFullName ci)
  | GCompTagDecl(ci,_) -> dprintf "declaration of %s" (compFullName ci)
  | GEnumTag(ei,_) -> dprintf "definition of enum %s" ei.ename
  | GEnumTagDecl(ei,_) -> dprintf "declaration of enum %s" ei.ename
  | GFun(fd, _) -> dprintf "definition of %s" fd.svar.vname
  | GText _ -> text "GText"
  | GAsm _ -> text "GAsm"


(* sm: given an ordinary CIL object printer, yield one which
 * behaves the same, except it never prints #line directives
 * (this is useful for debugging printfs) *)
let dn_obj (func: unit -> 'a -> doc) : (unit -> 'a -> doc) =
begin
  (* construct the closure to return *)
  let theFunc () (obj:'a) : doc =
  begin
    let prevStyle = !lineDirectiveStyle in
    lineDirectiveStyle := None;
    let ret = (func () obj) in    (* call underlying printer *)
    lineDirectiveStyle := prevStyle;
    ret
  end in
  theFunc
end

(* now define shortcuts for the non-location-printing versions,
 * with the naming prefix "dn_" *)
let dn_exp       = (dn_obj d_exp)
let dn_lval      = (dn_obj d_lval)
(* dn_offset is missing because it has a different interface *)
let dn_init      = (dn_obj d_init)
let dn_type      = (dn_obj d_type)
let dn_global    = (dn_obj d_global)
let dn_attrlist  = (dn_obj d_attrlist)
let dn_attr      = (dn_obj d_attr)
let dn_attrparam = (dn_obj d_attrparam)
let dn_stmt      = (dn_obj d_stmt)
let dn_instr     = (dn_obj d_instr)


(* Now define a cilPlainPrinter *)
class plainCilPrinterClass =
  (* We keep track of the composite types that we have done to avoid
   * recursion *)
  let donecomps : (int, unit) H.t = H.create 13 in
  object (self)

  inherit defaultCilPrinterClass as super

  (*** PLAIN TYPES ***)
  method pType (dn: doc option) () (t: typ) =
    match dn with
      None -> self#pOnlyType () t
    | Some d -> d ++ text " : " ++ self#pOnlyType () t

 method private pOnlyType () = function
     TVoid a -> dprintf "TVoid(@[%a@])" self#pAttrs a
   | TInt(ikind, a) -> dprintf "TInt(@[%a,@?%a@])"
         d_ikind ikind self#pAttrs a
   | TFloat(fkind, a) ->
       dprintf "TFloat(@[%a,@?%a@])" d_fkind fkind self#pAttrs a
   | TNamed (t, a) ->
       dprintf "TNamed(@[%s,@?%a,@?%a@])"
         t.tname self#pOnlyType t.ttype self#pAttrs a
   | TPtr(t, a) -> dprintf "TPtr(@[%a,@?%a@])" self#pOnlyType t self#pAttrs a
   | TArray(t,l,a) ->
       let dl = match l with
         None -> text "None" | Some l -> dprintf "Some(@[%a@])" self#pExp l in
       dprintf "TArray(@[%a,@?%a,@?%a@])"
         self#pOnlyType t insert dl self#pAttrs a
   | TEnum(enum,a) -> dprintf "Enum(%s,@[%a@])" enum.ename self#pAttrs a
   | TFun(tr,args,isva,a) ->
       dprintf "TFun(@[%a,@?%a%s,@?%a@])"
         self#pOnlyType tr
         insert
         (if args = None then text "None"
         else (docList (chr ',' ++ break)
                 (fun (an,at,aa) ->
                   dprintf "%s: %a" an self#pOnlyType at))
             ()
             (argsToList args))
         (if isva then "..." else "") self#pAttrs a
   | TComp (comp, a) ->
       if H.mem donecomps comp.ckey then
         dprintf "TCompLoop(%s %s, _, %a)"
           (if comp.cstruct then "struct" else "union") comp.cname
           self#pAttrs comp.cattr
       else begin
         H.add donecomps comp.ckey (); (* Add it before we do the fields *)
         dprintf "TComp(@[%s %s,@?%a,@?%a,@?%a@])"
           (if comp.cstruct then "struct" else "union") comp.cname
           (docList (chr ',' ++ break)
              (fun f -> dprintf "%s : %a" f.fname self#pOnlyType f.ftype))
           comp.cfields
           self#pAttrs comp.cattr
           self#pAttrs a
       end
   | TBuiltin_va_list a ->
       dprintf "TBuiltin_va_list(%a)" self#pAttrs a


  (* Some plain pretty-printers. Unlike the above these expose all the
   * details of the internal representation *)
  method pExp () = function
    Const(c) ->
      text "Const(" ++ d_const () c ++ text ")"
  | Lval(lv) ->
      text "Lval("
        ++ (align
              ++ self#pLval () lv
              ++ unalign)
        ++ text ")"

  | CastE(t,e) -> dprintf "CastE(@[%a,@?%a@])" self#pOnlyType t self#pExp e

  | UnOp(u,e1,_) ->
      let d_unop () u =
        match u with
          Neg -> text "-"
        | BNot -> text "~"
        | LNot -> text "!"
      in
      dprintf "UnOp(@[%a,@?%a@])"
        d_unop u self#pExp e1

  | BinOp(b,e1,e2,_) ->
      dprintf "%a(@[%a,@?%a@])" d_binop b
        self#pExp e1 self#pExp e2

  | SizeOf (t) ->
      text "sizeof(" ++ self#pType None () t ++ chr ')'
  | SizeOfE (e) ->
      text "sizeofE(" ++ self#pExp () e ++ chr ')'
  | SizeOfStr (s) ->
      text "sizeofStr(" ++ d_const () (CStr s) ++ chr ')'
  | AlignOf (t) ->
      text "__alignof__(" ++ self#pType None () t ++ chr ')'
  | AlignOfE (e) ->
      text "__alignof__(" ++ self#pExp () e ++ chr ')'

  | StartOf lv -> dprintf "StartOf(%a)" self#pLval lv
  | AddrOf (lv) -> dprintf "AddrOf(%a)" self#pLval lv



  method private d_plainoffset () = function
      NoOffset -> text "NoOffset"
    | Field(fi,o) ->
        dprintf "Field(@[%s:%a,@?%a@])"
          fi.fname self#pOnlyType fi.ftype self#d_plainoffset o
     | Index(e, o) ->
         dprintf "Index(@[%a,@?%a@])" self#pExp e self#d_plainoffset o

  method pInit () = function
      SingleInit e -> dprintf "SI(%a)" d_exp e
    | CompoundInit (t, initl) ->
        let d_plainoneinit (o, i) =
          self#d_plainoffset () o ++ text " = " ++ self#pInit () i
        in
        dprintf "CI(@[%a,@?%a@])" self#pOnlyType t
          (docList (chr ',' ++ break) d_plainoneinit) initl
(*
    | ArrayInit (t, len, initl) ->
        let idx = ref (- 1) in
        let d_plainoneinit i =
          incr idx;
          text "[" ++ num !idx ++ text "] = " ++ self#pInit () i
        in
        dprintf "AI(@[%a,%d,@?%a@])" self#pOnlyType t len
          (docList (chr ',' ++ break) d_plainoneinit) initl
*)
  method pLval () (lv: lval) =
    match lv with
    | Var vi, o -> dprintf "Var(@[%s,@?%a@])" vi.vname self#d_plainoffset o
    | Mem e, o -> dprintf "Mem(@[%a,@?%a@])" self#pExp e self#d_plainoffset o


end
let plainCilPrinter = new plainCilPrinterClass

(* And now some shortcuts *)
let d_plainexp () e = plainCilPrinter#pExp () e
let d_plaintype () t = plainCilPrinter#pType None () t
let d_plaininit () i = plainCilPrinter#pInit () i
let d_plainlval () l = plainCilPrinter#pLval () l

let rec d_typsig () = function
    TSArray (ts, eo, al) ->
      dprintf "TSArray(@[%a,@?%a,@?%a@])"
        d_typsig ts
        insert (match eo with None -> text "None" | Some e -> d_exp () e)
        d_attrlist al
  | TSPtr (ts, al) ->
      dprintf "TSPtr(@[%a,@?%a@])"
        d_typsig ts d_attrlist al
  | TSComp (iss, name, al) ->
      dprintf "TSComp(@[%s %s,@?%a@])"
        (if iss then "struct" else "union") name
        d_attrlist al
  | TSFun (rt, args, isva, al) ->
      dprintf "TSFun(@[%a,@?%a,%b,@?%a@])"
        d_typsig rt
        (docList (chr ',' ++ break) (d_typsig ())) args isva
        d_attrlist al
  | TSEnum (n, al) ->
      dprintf "TSEnum(@[%s,@?%a@])"
        n d_attrlist al
  | TSBase t -> dprintf "TSBase(%a)" d_type t



   (* Make a varinfo. Used mostly as a helper function below  *)
let makeVarinfo global name typ =
  (* Strip const from type for locals *)
  let vi =
    { vname = name;
      vid   = !nextGlobalVID;
      vglob = global;
      vtype = if global then typ else typeRemoveAttributes ["const"] typ;
      vdecl = lu;
      vinline = false;
      vattr = [];
      vstorage = NoStorage;
      vaddrof = false;
      vreferenced = false;    (* sm *)
    } in
  incr nextGlobalVID;
  vi

let copyVarinfo (vi: varinfo) (newname: string) : varinfo =
  let vi' = {vi with vname = newname; vid = !nextGlobalVID } in
  incr nextGlobalVID;
  vi'

let makeLocal fdec name typ = (* a helper function *)
  fdec.smaxid <- 1 + fdec.smaxid;
  let vi = makeVarinfo false name typ in
  vi

   (* Make a local variable and add it to a function *)
let makeLocalVar fdec ?(insert = true) name typ =
  let vi = makeLocal fdec name typ in
  if insert then fdec.slocals <- fdec.slocals @ [vi];
  vi


let makeTempVar fdec ?(name = "__cil_tmp") typ : varinfo =
  let name = name ^ (string_of_int (1 + fdec.smaxid)) in
  makeLocalVar fdec name typ


  (* Set the formals and re-create the function name based on the information*)
let setFormals (f: fundec) (forms: varinfo list) =
  f.sformals <- forms; (* Set the formals *)
  match unrollType f.svar.vtype with
    TFun(rt, _, isva, fa) ->
      f.svar.vtype <-
         TFun(rt,
              Some (List.map (fun a -> (a.vname, a.vtype, a.vattr)) forms),
              isva, fa)
  | _ -> E.s (E.bug "Set formals. %s does not have function type\n"
                f.svar.vname)

   (* Set the types of arguments and results as given by the function type
    * passed as the second argument *)
let setFunctionType (f: fundec) (t: typ) =
  match unrollType t with
    TFun (rt, Some args, va, a) ->
      if List.length f.sformals <> List.length args then
        E.s (E.bug "setFunctionType: number of arguments differs from the number of formals");
      (* Change the function type. *)
      f.svar.vtype <- t;
      (* Change the sformals and we know that indirectly we'll change the
       * function type *)
      List.iter2
        (fun (an,at,aa) f ->
          f.vtype <- at; f.vattr <- aa)
        args f.sformals

  | _ -> E.s (E.bug "setFunctionType: not a function type")


let setMaxId (f: fundec) =
  f.smaxid <- List.length f.sformals + List.length f.slocals


  (* Make a formal variable for a function. Insert it in both the sformals
   * and the type of the function. You can optionally specify where to insert
   * this one. If where = "^" then it is inserted first. If where = "$" then
   * it is inserted last. Otherwise where must be the name of a formal after
   * which to insert this. By default it is inserted at the end. *)
let makeFormalVar fdec ?(where = "$") name typ : varinfo =
  (* Search for the insertion place *)
  let thenewone = ref fdec.svar in (* Just a placeholder *)
  let makeit () : varinfo =
    let vi = makeLocal fdec name typ in
    thenewone := vi;
    vi
  in
  let rec loopFormals = function
      [] ->
        if where = "$" then [makeit ()]
        else E.s (E.error "makeFormalVar: cannot find insert-after formal %s"
                    where)
    | f :: rest when f.vname = where -> f :: makeit () :: rest
    | f :: rest -> f :: loopFormals rest
  in
  let newformals =
    if where = "^" then makeit () :: fdec.sformals else
    loopFormals fdec.sformals in
  setFormals fdec newformals;
  !thenewone

   (* Make a global variable. Your responsibility to make sure that the name
    * is unique *)
let makeGlobalVar name typ =
  let vi = makeVarinfo true name typ in
  vi


   (* Make an empty function *)
let emptyFunction name =
  { svar  = makeGlobalVar name (TFun(voidType, Some [], false,[]));
    smaxid = 0;
    slocals = [];
    sformals = [];
    sbody = mkBlock [];
    smaxstmtid = None;
  }



    (* A dummy function declaration handy for initialization *)
let dummyFunDec = emptyFunction "@dummy"
let dummyFile =
  { globals = [];
    fileName = "<dummy>";
    globinit = None;
    globinitcalled = false}

let saveBinaryFile (cil_file : file) (filename : string) =
  let outchan = open_out_bin filename in
  Marshal.to_channel outchan cil_file [] ;
  close_out outchan

let saveBinaryFileChannel (cil_file : file) (outchan : out_channel) =
  Marshal.to_channel outchan cil_file []

let loadBinaryFile (filename : string) : file =
  let inchan = open_in_bin filename in
  let cil_file = (Marshal.from_channel inchan : file) in
  close_in inchan ;
  cil_file


(* Take the name of a file and make a valid symbol name out of it. There are
 * a few chanracters that are not valid in symbols *)
let makeValidSymbolName (s: string) =
  let s = String.copy s in (* So that we can update in place *)
  let l = String.length s in
  for i = 0 to l - 1 do
    let c = String.get s i in
    let isinvalid =
      match c with
        '-' | '.' -> true
      | _ -> false
    in
    if isinvalid then
      String.set s i '_';
  done;
  s


(*** Define the visiting engine ****)
(* visit all the nodes in a Flx_cil_cil expression *)
let doVisit (vis: cilVisitor)
            (startvisit: 'a -> 'a visitAction)
            (children: cilVisitor -> 'a -> 'a)
            (node: 'a) : 'a =
  let action = startvisit node in
  match action with
    SkipChildren -> node
  | ChangeTo node' -> node'
  | _ -> (* DoChildren and ChangeDoChildrenPost *)
      let nodepre = match action with
        ChangeDoChildrenPost (node', _) -> node'
      | _ -> node
      in
      let nodepost = children vis nodepre in
      match action with
        ChangeDoChildrenPost (_, f) -> f nodepost
      | _ -> nodepost

(* mapNoCopy is like map but avoid copying the list if the function does not
 * change the elements. *)
let rec mapNoCopy (f: 'a -> 'a) = function
    [] -> []
  | (i :: resti) as li ->
      let i' = f i in
      let resti' = mapNoCopy f resti in
      if i' != i || resti' != resti then i' :: resti' else li

let rec mapNoCopyList (f: 'a -> 'a list) = function
    [] -> []
  | (i :: resti) as li ->
      let il' = f i in
      let resti' = mapNoCopyList f resti in
      match il' with
        [i'] when i' == i && resti' == resti -> li
      | _ -> il' @ resti'

(* A visitor for lists *)
let doVisitList  (vis: cilVisitor)
                 (startvisit: 'a -> 'a list visitAction)
                 (children: cilVisitor -> 'a -> 'a)
                 (node: 'a) : 'a list =
  let action = startvisit node in
  match action with
    SkipChildren -> [node]
  | ChangeTo nodes' -> nodes'
  | _ ->
      let nodespre = match action with
        ChangeDoChildrenPost (nodespre, _) -> nodespre
      | _ -> [node]
      in
      let nodespost = mapNoCopy (children vis) nodespre in
      match action with
        ChangeDoChildrenPost (_, f) -> f nodespost
      | _ -> nodespost

let debugVisit = false

let rec visitCilExpr (vis: cilVisitor) (e: exp) : exp =
  doVisit vis vis#vexpr childrenExp e
and childrenExp (vis: cilVisitor) (e: exp) : exp =
  let vExp e = visitCilExpr vis e in
  let vTyp t = visitCilType vis t in
  let vLval lv = visitCilLval vis lv in
  match e with
    Const _ -> e
  | SizeOf t ->
      let t'= vTyp t in
      if t' != t then SizeOf t' else e
  | SizeOfE e1 ->
      let e1' = vExp e1 in
      if e1' != e1 then SizeOfE e1' else e
  | SizeOfStr s -> e

  | AlignOf t ->
      let t' = vTyp t in
      if t' != t then AlignOf t' else e
  | AlignOfE e1 ->
      let e1' = vExp e1 in
      if e1' != e1 then AlignOfE e1' else e
  | Lval lv ->
      let lv' = vLval lv in
      if lv' != lv then Lval lv' else e
  | UnOp (uo, e1, t) ->
      let e1' = vExp e1 in let t' = vTyp t in
      if e1' != e1 || t' != t then UnOp(uo, e1', t') else e
  | BinOp (bo, e1, e2, t) ->
      let e1' = vExp e1 in let e2' = vExp e2 in let t' = vTyp t in
      if e1' != e1 || e2' != e2 || t' != t then BinOp(bo, e1',e2',t') else e
  | CastE (t, e1) ->
      let t' = vTyp t in let e1' = vExp e1 in
      if t' != t || e1' != e1 then CastE(t', e1') else e
  | AddrOf lv ->
      let lv' = vLval lv in
      if lv' != lv then AddrOf lv' else e
  | StartOf lv ->
      let lv' = vLval lv in
      if lv' != lv then StartOf lv' else e

and visitCilInit (vis: cilVisitor) (i: init) : init =
  doVisit vis vis#vinit childrenInit i
and childrenInit (vis: cilVisitor) (i: init) : init =
  let fExp e = visitCilExpr vis e in
  let fInit i = visitCilInit vis i in
  let fTyp t = visitCilType vis t in
  match i with
  | SingleInit e ->
      let e' = fExp e in
      if e' != e then SingleInit e' else i
  | CompoundInit (t, initl) ->
      let t' = fTyp t in
      (* Collect the new initializer list, in reverse. We prefer two
       * traversals to ensure tail-recursion. *)
      let newinitl : (offset * init) list ref = ref [] in
      (* Keep track whether the list has changed *)
      let hasChanged = ref false in
      let doOneInit ((o, i) as oi) =
        let o' = visitCilInitOffset vis o in    (* use initializer version *)
        let i' = fInit i in
        let newio =
          if o' != o || i' != i then
            begin hasChanged := true; (o', i') end else oi
        in
        newinitl := newio :: !newinitl
      in
      List.iter doOneInit initl;
      let initl' = if !hasChanged then List.rev !newinitl else initl in
      if t' != t || initl' != initl then CompoundInit (t', initl') else i
(*
  | ArrayInit (bt, len, initl) ->
      let bt' = fTyp bt in
      (* Collect the new initializer list, in reverse. We prefer two
       * traversals to ensure tail-recursion. *)
      let newinitl : init list ref = ref [] in
      (* Keep track whether the list has changed *)
      let hasChanged = ref false in
      List.iter (fun i -> let i' = fInit i in
                          let i'' =
                            if i' != i then
                              begin hasChanged := true; i' end else i
                          in
                          newinitl := i'' :: !newinitl) initl;
      let initl' = if !hasChanged then List.rev !newinitl else initl in
      if bt' != bt || initl' != initl then ArrayInit(bt', len, initl') else i
*)

and visitCilLval (vis: cilVisitor) (lv: lval) : lval =
  doVisit vis vis#vlval childrenLval lv
and childrenLval (vis: cilVisitor) (lv: lval) : lval =
  (* and visit its subexpressions *)
  let vExp e = visitCilExpr vis e in
  let vTyp t = visitCilType vis t in
  let vOff off = visitCilOffset vis off in
  match lv with
    Var v, off ->
      let v'   = doVisit vis vis#vvrbl (fun _ x -> x) v in
      let off' = vOff off in
      if v' != v || off' != off then Var v', off' else lv
  | Mem e, off ->
      let e' = vExp e in
      let off' = vOff off in
      if e' != e || off' != off then Mem e', off' else lv

and visitCilOffset (vis: cilVisitor) (off: offset) : offset =
  doVisit vis vis#voffs childrenOffset off
and childrenOffset (vis: cilVisitor) (off: offset) : offset =
  let vOff off = visitCilOffset vis off in
  match off with
    Field (f, o) ->
      let o' = vOff o in
      if o' != o then Field (f, o') else off
  | Index (e, o) ->
      let e' = visitCilExpr vis e in
      let o' = vOff o in
      if e' != e || o' != o then Index (e', o') else off
  | NoOffset -> off

(* sm: for offsets in initializers, the 'startvisit' will be the
 * vinitoffs method, but we can re-use the childrenOffset from
 * above since recursive offsets are visited by voffs.  (this point
 * is moot according to cil.mli which claims the offsets in
 * initializers will never recursively contain offsets)
 *)
and visitCilInitOffset (vis: cilVisitor) (off: offset) : offset =
  doVisit vis vis#vinitoffs childrenOffset off

and visitCilInstr (vis: cilVisitor) (i: instr) : instr list =
  let oldloc = !currentLoc in
  currentLoc := (get_instrLoc i);
  assertEmptyQueue vis;
  let res = doVisitList vis vis#vinst childrenInstr i in
  currentLoc := oldloc;
  (* See if we have accumulated some instructions *)
  vis#unqueueInstr () @ res

and childrenInstr (vis: cilVisitor) (i: instr) : instr =
  let fExp = visitCilExpr vis in
  let fLval = visitCilLval vis in
  match i with
  | Set(lv,e,l) ->
      let lv' = fLval lv in let e' = fExp e in
      if lv' != lv || e' != e then Set(lv',e',l) else i
  | Call(None,f,args,l) ->
      let f' = fExp f in let args' = mapNoCopy fExp args in
      if f' != f || args' != args then Call(None,f',args',l) else i
  | Call(Some lv,fn,args,l) ->
      let lv' = fLval lv in let fn' = fExp fn in
      let args' = mapNoCopy fExp args in
      if lv' != lv || fn' != fn || args' != args
      then Call(Some lv', fn', args', l) else i

  | Asm(sl,isvol,outs,ins,clobs,l) ->
      let outs' = mapNoCopy (fun ((s,lv) as pair) ->
                               let lv' = fLval lv in
                               if lv' != lv then (s,lv') else pair) outs in
      let ins'  = mapNoCopy (fun ((s,e) as pair) ->
                               let e' = fExp e in
                               if e' != e then (s,e') else pair) ins in
      if outs' != outs || ins' != ins then
        Asm(sl,isvol,outs',ins',clobs,l) else i


(* visit all nodes in a Flx_cil_cil statement tree in preorder *)
and visitCilStmt (vis: cilVisitor) (s: stmt) : stmt =
  let oldloc = !currentLoc in
  currentLoc := (get_stmtLoc s.skind) ;
  assertEmptyQueue vis;
  let toPrepend : instr list ref = ref [] in (* childrenStmt may add to this *)
  let res = doVisit vis vis#vstmt (childrenStmt toPrepend) s in
  (* Now see if we have saved some instructions *)
  toPrepend := !toPrepend @ vis#unqueueInstr ();
  (match !toPrepend with
    [] -> () (* Return the same statement *)
  | _ ->
      (* Make our statement contain the instructions to prepend *)
      res.skind <- Block { battrs = []; bstmts = [ mkStmt (Instr !toPrepend);
                                                   mkStmt res.skind ] });
  currentLoc := oldloc;
  res

and childrenStmt (toPrepend: instr list ref) (vis:cilVisitor) (s:stmt): stmt =
  let fExp e = (visitCilExpr vis e) in
  let fLval lv = (visitCilLval vis lv) in
  let fOff o = (visitCilOffset vis o) in
  let fBlock b = visitCilBlock vis b in
  let fInst i = visitCilInstr vis i in
  (* Just change the statement kind *)
  let skind' =
    match s.skind with
      Break _ | Continue _ | Goto _ | Return (None, _) -> s.skind
    | Return (Some e, l) ->
        let e' = fExp e in
        if e' != e then Return (Some e', l) else s.skind
    | Loop (b, l, s1, s2) ->
        let b' = fBlock b in
        if b' != b then Loop (b', l, s1, s2) else s.skind
    | If(e, s1, s2, l) ->
        let e' = fExp e in
        (*if e queued any instructions, pop them here and remember them so that
          they are inserted before the If stmt, not in the then block. *)
        toPrepend := vis#unqueueInstr ();
        let s1'= fBlock s1 in let s2'= fBlock s2 in
        (* the stmts in the blocks should have cleaned up after themselves.*)
        assertEmptyQueue vis;
        if e' != e || s1' != s1 || s2' != s2 then
          If(e', s1', s2', l) else s.skind
    | Switch (e, b, stmts, l) ->
        let e' = fExp e in
        toPrepend := vis#unqueueInstr (); (* insert these before the switch *)
        let b' = fBlock b in
        (* the stmts in b should have cleaned up after themselves.*)
        assertEmptyQueue vis;
        (* Don't do stmts, but we better not change those *)
        if e' != e || b' != b then Switch (e', b', stmts, l) else s.skind
    | Instr il ->
        let il' = mapNoCopyList fInst il in
        if il' != il then Instr il' else s.skind
    | Block b ->
        let b' = fBlock b in
        if b' != b then Block b' else s.skind
    | TryFinally (b, h, l) ->
        let b' = fBlock b in
        let h' = fBlock h in
        if b' != b || h' != h then TryFinally(b', h', l) else s.skind
    | TryExcept (b, (il, e), h, l) ->
        let b' = fBlock b in
        assertEmptyQueue vis;
        (* visit the instructions *)
        let il' = mapNoCopyList fInst il in
        (* Visit the expression *)
        let e' = fExp e in
        let il'' =
          let more = vis#unqueueInstr () in
          if more != [] then
            il' @ more
          else
            il'
        in
        let h' = fBlock h in
        (* Now collect the instructions *)
        if b' != b || il'' != il || e' != e || h' != h then
          TryExcept(b', (il'', e'), h', l)
        else s.skind
  in
  if skind' != s.skind then s.skind <- skind';
  (* Visit the labels *)
  let labels' =
    let fLabel = function
        Case (e, l) as lb ->
          let e' = fExp e in
          if e' != e then Case (e', l) else lb
        | lb -> lb
    in
    mapNoCopy fLabel s.labels
  in
  if labels' != s.labels then s.labels <- labels';
  s



and visitCilBlock (vis: cilVisitor) (b: block) : block =
  doVisit vis vis#vblock childrenBlock b
and childrenBlock (vis: cilVisitor) (b: block) : block =
  let fStmt s = visitCilStmt vis s in
  let stmts' = mapNoCopy fStmt b.bstmts in
  if stmts' != b.bstmts then { battrs = b.battrs; bstmts = stmts'} else b


and visitCilType (vis : cilVisitor) (t : typ) : typ =
  doVisit vis vis#vtype childrenType t
and childrenType (vis : cilVisitor) (t : typ) : typ =
  (* look for types referred to inside t's definition *)
  let fTyp t  = visitCilType vis t in
  let fAttr a = visitCilAttributes vis a in
  match t with
    TPtr(t1, a) ->
      let t1' = fTyp t1 in
      let a' = fAttr a in
      if t1' != t || a' != a then TPtr(t1', a') else t
  | TArray(t1, None, a) ->
      let t1' = fTyp t1 in
      let a' = fAttr a in
      if t1' != t || a' != a  then TArray(t1', None, a') else t
  | TArray(t1, Some e, a) ->
      let t1' = fTyp t1 in
      let e' = visitCilExpr vis e in
      let a' = fAttr a in
      if t1' != t || e' != e  || a' != a then TArray(t1', Some e', a') else t

      (* DON'T recurse into the compinfo, this is done in visitCilGlobal.
         User can iterate over cinfo.cfields manually, if desired.*)
  | TComp(cinfo, a) ->
      let a' = fAttr a in
      if a != a' then TComp(cinfo, a') else t

  | TFun(rettype, args, isva, a) ->
      let rettype' = fTyp rettype in
      (* iterate over formals, as variable declarations *)
      let argslist = argsToList args in
      let visitArg ((an,at,aa) as arg) =
        let at' = fTyp at in
        let aa' = fAttr aa in
        if at' != at || aa' != aa then (an,at',aa') else arg
      in
      let argslist' = mapNoCopy visitArg argslist in
      let a' = fAttr a in
      if rettype' != rettype || argslist' != argslist || a' != a  then
        let args' = if argslist' == argslist then args else Some argslist' in
        TFun(rettype', args', isva, a') else t

  | TNamed(t1, a) -> (* Do not go into the type. Will do it at the time of
                      * GType *)
      let a' = fAttr a in
      if a' != a  then TNamed (t1, a') else t

  | _ ->  (* other types (TVoid, TInt, TFloat, TEnum, and TBuiltin_va_list)
             don't contain nested types, but they do have attributes. *)
      let a = typeAttrs t in
      let a' = fAttr a in
      if a' != a  then setTypeAttrs t a' else t


(* for declarations, we visit the types inside; but for uses, *)
(* we just visit the varinfo node *)
and visitCilVarDecl (vis : cilVisitor) (v : varinfo) : varinfo =
  doVisit vis vis#vvdec childrenVarDecl v
and childrenVarDecl (vis : cilVisitor) (v : varinfo) : varinfo =
  v.vtype <- visitCilType vis v.vtype;
  v.vattr <- visitCilAttributes vis v.vattr;
  v

and visitCilAttributes (vis: cilVisitor) (al: attribute list) : attribute list=
   let al' =
     mapNoCopyList (doVisitList vis vis#vattr childrenAttribute) al in
   if al' != al then
     (* Must re-sort *)
     addAttributes al' []
   else
     al
and childrenAttribute (vis: cilVisitor) (a: attribute) : attribute =
  let fTyp t  = visitCilType vis t in
  let rec doarg (aa: attrparam) =
    match aa with
      AInt _ | AStr _ -> aa
    | ACons(n, args) ->
        let args' = mapNoCopy doarg args in
        if args' != args then ACons(n, args') else aa
    | ASizeOf t ->
        let t' = fTyp t in
        if t' != t then ASizeOf t' else aa
    | ASizeOfE e ->
        let e' = doarg e in
        if e' != e then ASizeOfE e' else aa
    | AAlignOf t ->
        let t' = fTyp t in
        if t' != t then AAlignOf t' else aa
    | AAlignOfE e ->
        let e' = doarg e in
        if e' != e then AAlignOfE e' else aa
    | AUnOp (uo, e1) ->
        let e1' = doarg e1 in
        if e1' != e1 then AUnOp (uo, e1') else aa
    | ABinOp (bo, e1, e2) ->
        let e1' = doarg e1 in
        let e2' = doarg e2 in
        if e1' != e1 || e2' != e2 then ABinOp (bo, e1', e2') else aa
    | ADot (ap, s) ->
        let ap' = doarg ap in
        if ap' != ap then ADot (ap', s) else aa

  in
  match a with
    Attr (n, args) ->
      let args' = mapNoCopy doarg args in
      if args' != args then Attr(n, args') else a



let rec visitCilFunction (vis : cilVisitor) (f : fundec) : fundec =
  if debugVisit then ignore (E.log "Visiting function %s\n" f.svar.vname);
  doVisit vis vis#vfunc childrenFunction f

and childrenFunction (vis : cilVisitor) (f : fundec) : fundec =
  f.svar <- visitCilVarDecl vis f.svar; (* hit the function name *)
  (* visit local declarations *)
  f.slocals <- mapNoCopy (visitCilVarDecl vis) f.slocals;
  (* visit the formals *)
  let newformals = mapNoCopy (visitCilVarDecl vis) f.sformals in
  (* Make sure the type reflects the formals *)
  setFormals f newformals;
  f.sbody <- visitCilBlock vis f.sbody;        (* visit the body *)
  f

let rec visitCilGlobal (vis: cilVisitor) (g: global) : global list =
  (*(trace "visit" (dprintf "visitCilGlobal\n"));*)
  let oldloc = !currentLoc in
  currentLoc := (get_globalLoc g) ;
  let res = doVisitList vis vis#vglob childrenGlobal g in
  currentLoc := oldloc;
  res
and childrenGlobal (vis: cilVisitor) (g: global) : global =
  match g with
  | GFun (f, l) ->
      let f' = visitCilFunction vis f in
      if f' != f then GFun (f', l) else g
  | GType(t, l) ->
      t.ttype <- visitCilType vis t.ttype;
      g

  | GEnumTagDecl _ | GCompTagDecl _ -> g (* Nothing to visit *)
  | GEnumTag (enum, _) ->
      (trace "visit" (dprintf "visiting global enum %s\n" enum.ename));
      (* Do the values and attributes of the enumerated items *)
      let itemVisit (name, exp, loc) = (name, visitCilExpr vis exp, loc) in
      enum.eitems <- mapNoCopy itemVisit enum.eitems;
      enum.eattr <- visitCilAttributes vis enum.eattr;
      g

  | GCompTag (comp, _) ->
      (trace "visit" (dprintf "visiting global comp %s\n" comp.cname));
      (* Do the types and attirbutes of the fields *)
      let fieldVisit = fun fi ->
        fi.ftype <- visitCilType vis fi.ftype;
        fi.fattr <- visitCilAttributes vis fi.fattr
      in
      List.iter fieldVisit comp.cfields;
      g

  | GVarDecl(v, l) ->
      let v' = visitCilVarDecl vis v in
      if v' != v then GVarDecl (v', l) else g
  | GVar (v, inito, l) ->
      let v' = visitCilVarDecl vis v in
      (match inito.init with
        None -> ()
      | Some i -> let i' = visitCilInit vis i in
        if i' != i then inito.init <- Some i');

      if v' != v then GVar (v', inito, l) else g

  | GPragma (a, l) -> begin
      match visitCilAttributes vis [a] with
        [a'] -> if a' != a then GPragma (a', l) else g
      | _ -> E.s (E.unimp "visitCilAttributes returns more than one attribute")
  end
  | _ -> g


(* Iterate over all globals, including the global initializer *)
let iterGlobals (fl: file)
                (doone: global -> unit) : unit =
  let doone' g =
      currentLoc := get_globalLoc g;
      doone g
  in
  List.iter doone' fl.globals;
  (match fl.globinit with
    None -> ()
  | Some g -> doone' (GFun(g, locUnknown)))

(* Fold over all globals, including the global initializer *)
let foldGlobals (fl: file)
                (doone: 'a -> global -> 'a)
                (acc: 'a) : 'a =
  let doone' acc g =
      currentLoc := get_globalLoc g;
      doone acc g
  in
  let acc' = List.fold_left doone' acc fl.globals in
  (match fl.globinit with
    None -> acc'
  | Some g -> doone' acc' (GFun(g, locUnknown)))


(* A visitor for the whole file that does not change the globals *)
let visitCilFileSameGlobals (vis : cilVisitor) (f : file) : unit =
  let fGlob g = visitCilGlobal vis g in
  iterGlobals f (fun g ->
    match fGlob g with
      [g'] when g' == g || g' = g -> () (* Try to do the pointer check first *)
    | gl ->
        ignore (E.log "You used visitCilFilSameGlobals but the global got changed:\n %a\nchanged to %a\n" d_global g (docList line (d_global ())) gl);
        ())

(* Be careful with visiting the whole file because it might be huge. *)
let visitCilFile (vis : cilVisitor) (f : file) : unit =
  let fGlob g = visitCilGlobal vis g in
  (* Scan the globals. Make sure this is tail recursive. *)
  let rec loop (acc: global list) = function
      [] -> f.globals <- List.rev acc
    | g :: restg ->
        loop ((List.rev (fGlob g)) @ acc) restg
  in
  loop [] f.globals;
  (* the global initializer *)
  (match f.globinit with
    None -> ()
  | Some g -> f.globinit <- Some (visitCilFunction vis g))



(** Create or fetch the global initializer. Tries to put a call to in the the
 * function with the main_name *)
let getGlobInit ?(main_name="main") (fl: file) =
  match fl.globinit with
    Some f -> f
  | None -> begin
      (* Sadly, we cannot use the Filename library because it does not like
       * function names with multiple . in them *)
      let f =
        let len = String.length fl.fileName in
        (* Find the last path separator and record the first . that we see,
        * going backwards *)
        let lastDot = ref len in
        let rec findLastPathSep i =
          if i < 0 then -1 else
          let c = String.get fl.fileName i in
          if c = '/' || c = '\\' then i
          else begin
            if c = '.' && !lastDot = len then
              lastDot := i;
            findLastPathSep (i - 1)
          end
        in
        let lastPathSep = findLastPathSep (len - 1) in
        let basenoext =
          String.sub fl.fileName (lastPathSep + 1) (!lastDot - lastPathSep - 1)
        in
        emptyFunction
          (makeValidSymbolName ("__globinit_" ^ basenoext))
      in
      fl.globinit <- Some f;
      (* Now try to add a call to the global initialized at the beginning of
       * main *)
      let mainname = "main" in
      let inserted = ref false in
      List.iter
        (fun g ->
          match g with
            GFun(m, lm) when m.svar.vname = "main" ->
              (* Prepend a prototype to the global initializer *)
              fl.globals <- GVarDecl (f.svar, lm) :: fl.globals;
              m.sbody.bstmts <-
                 compactStmts (mkStmt (Instr [Call(None,
                                                   Lval(var f.svar),
                                                   [], locUnknown)])
                               :: m.sbody.bstmts);
              inserted := true;
              if !E.verboseFlag then
                ignore (E.log "Inserted the globinit\n");
              fl.globinitcalled <- true;
          | _ -> ())
        fl.globals;

      if not !inserted then
        ignore (E.warn "Cannot find %s to add global initializer %s"
                  main_name f.svar.vname);

      f
  end



(* Fold over all globals, including the global initializer *)
let mapGlobals (fl: file)
               (doone: global -> global) : unit =
  fl.globals <- List.map doone fl.globals;
  (match fl.globinit with
    None -> ()
  | Some g -> begin
      match doone (GFun(g, locUnknown)) with
        GFun(g', _) -> fl.globinit <- Some g'
      | _ -> E.s (E.bug "mapGlobals: globinit is not a function")
  end)



let dumpFile (pp: cilPrinter) (out : out_channel) file =
  printDepth := 99999;  (* We don't want ... in the output *)
  (* If we are in RELEASE mode then we do not print indentation *)
  (* AB: These flags are no longer used by Flx_cil_pretty *)
(*
  noBreaks := true; noAligns := true;
  assert (noBreaks := false; noAligns := false; true);
*)
  Flx_cil_pretty.fastMode := true;
  (* In debug mode the asserts are executed
  assert (Flx_cil_pretty.fastMode := false; true); *)
  if !E.verboseFlag then
    ignore (E.log "printing file %s\n" file.fileName);
  let print x = fprint out 78 x in
  print (text ("/* Generated by CIL v. " ^ cilVersion ^ " */\n" ^
               (* sm: I want to easily tell whether the generated output
                * is with print_CIL_Input or not *)
               "/* print_CIL_Input is " ^ (if !print_CIL_Input then "true" else "false") ^ " */\n\n"));
  iterGlobals file (fun g -> dumpGlobal pp out g);

  (* sm: we have to flush the output channel; if we don't then under *)
  (* some circumstances (I haven't figure out exactly when, but it happens *)
  (* more often with big inputs), we get a truncated output file *)
  flush out



(******************
 ******************
 ******************)



(******************** OPTIMIZATIONS *****)
let rec peepHole1 (* Process one statement and possibly replace it *)
                  (doone: instr -> instr list option)
                  (* Scan a block and recurse inside nested blocks *)
                  (ss: stmt list) : unit =
  let rec doInstrList (il: instr list) : instr list =
    match il with
      [] -> []
    | i :: rest -> begin
        match doone i with
          None -> i :: doInstrList rest
        | Some sl -> doInstrList (sl @ rest)
    end
  in

  List.iter
    (fun s ->
      match s.skind with
        Instr il -> s.skind <- Instr (doInstrList il)
      | If (e, tb, eb, _) ->
          peepHole1 doone tb.bstmts;
          peepHole1 doone eb.bstmts
      | Switch (e, b, _, _) -> peepHole1 doone b.bstmts
      | Loop (b, l, _, _) -> peepHole1 doone b.bstmts
      | Block b -> peepHole1 doone b.bstmts
      | TryFinally (b, h, l) ->
          peepHole1 doone b.bstmts;
          peepHole1 doone h.bstmts
      | TryExcept (b, (il, e), h, l) ->
          peepHole1 doone b.bstmts;
          peepHole1 doone h.bstmts;
          s.skind <- TryExcept(b, (doInstrList il, e), h, l);
      | Return _ | Goto _ | Break _ | Continue _ -> ())
    ss

let rec peepHole2  (* Process two statements and possibly replace them both *)
                   (dotwo: instr * instr -> instr list option)
                   (ss: stmt list) : unit =
  let rec doInstrList (il: instr list) : instr list =
    match il with
      [] -> []
    | [i] -> [i]
    | (i1 :: ((i2 :: rest) as rest2)) ->
        begin
          match dotwo (i1,i2) with
            None -> i1 :: doInstrList rest2
          | Some sl -> doInstrList (sl @ rest)
        end
  in
  List.iter
    (fun s ->
      match s.skind with
        Instr il -> s.skind <- Instr (doInstrList il)
      | If (e, tb, eb, _) ->
          peepHole2 dotwo tb.bstmts;
          peepHole2 dotwo eb.bstmts
      | Switch (e, b, _, _) -> peepHole2 dotwo b.bstmts
      | Loop (b, l, _, _) -> peepHole2 dotwo b.bstmts
      | Block b -> peepHole2 dotwo b.bstmts
      | TryFinally (b, h, l) -> peepHole2 dotwo b.bstmts;
                                peepHole2 dotwo h.bstmts
      | TryExcept (b, (il, e), h, l) ->
          peepHole2 dotwo b.bstmts;
          peepHole2 dotwo h.bstmts;
          s.skind <- TryExcept (b, (doInstrList il, e), h, l)

      | Return _ | Goto _ | Break _ | Continue _ -> ())
    ss






let dExp: doc -> exp =
  fun d -> Const(CStr(sprint 80 d))

let dInstr: doc -> location -> instr =
  fun d l -> Asm([], [sprint 80 d], [], [], [], l)

let dGlobal: doc -> location -> global =
  fun d l -> GAsm(sprint 80 d, l)

let rec addOffset (toadd: offset) (off: offset) : offset =
  match off with
    NoOffset -> toadd
  | Field(fid', offset) -> Field(fid', addOffset toadd offset)
  | Index(e, offset) -> Index(e, addOffset toadd offset)

 (* Add an offset at the end of an lv *)
let addOffsetLval toadd (b, off) : lval =
 b, addOffset toadd off

let rec removeOffset (off: offset) : offset * offset =
  match off with
    NoOffset -> NoOffset, NoOffset
  | Field(f, NoOffset) -> NoOffset, off
  | Index(i, NoOffset) -> NoOffset, off
  | Field(f, restoff) ->
      let off', last = removeOffset restoff in
      Field(f, off'), last
  | Index(i, restoff) ->
      let off', last = removeOffset restoff in
      Index(i, off'), last

let removeOffsetLval ((b, off): lval) : lval * offset =
  let off', last = removeOffset off in
  (b, off'), last

  (* Make an AddrOf. Given an lval of type T will give back an expression of
   * type ptr(T)  *)
let mkAddrOf ((b, off) as lval) : exp =
  (* Never take the address of a register variable *)
  (match lval with
    Var vi, off when vi.vstorage = Register -> vi.vstorage <- NoStorage
  | _ -> ());
  match lval with
    Mem e, NoOffset -> e
  | b, Index(z, NoOffset) when isZero z -> StartOf (b, NoOffset)(* array *)
  | _ -> AddrOf lval


let mkAddrOrStartOf (lv: lval) : exp =
  match unrollType (typeOfLval lv) with
    TArray _ -> StartOf lv
  | _ -> mkAddrOf lv


  (* Make a Mem, while optimizing AddrOf. The type of the addr must be
   * TPtr(t) and the type of the resulting lval is t. Note that in CIL the
   * implicit conversion between a function and a pointer to a function does
   * not apply. You must do the conversion yourself using AddrOf *)
let mkMem ~(addr: exp) ~(off: offset) : lval =
  let res =
    match addr, off with
      AddrOf lv, _ -> addOffsetLval off lv
    | StartOf lv, _ -> (* Must be an array *)
        addOffsetLval (Index(zero, off)) lv
    | _, _ -> Mem addr, off
  in
(*  ignore (E.log "memof : %a:%a\nresult = %a\n"
            d_plainexp addr d_plainoffset off d_plainexp res); *)
  res


let isIntegralType t =
  match unrollType t with
    (TInt _ | TEnum _) -> true
  | _ -> false

let isArithmeticType t =
  match unrollType t with
    (TInt _ | TEnum _ | TFloat _) -> true
  | _ -> false


let isPointerType t =
  match unrollType t with
    TPtr _ -> true
  | _ -> false

let isFunctionType t =
  match unrollType t with
    TFun _ -> true
  | _ -> false

let splitFunctionType (ftype: typ)
    : typ * (string * typ * attributes) list option * bool * attributes =
  match unrollType ftype with
    TFun (rt, args, isva, a) -> rt, args, isva, a
  | _ -> E.s (bug "splitFunctionType invoked on a non function type %a"
                d_type ftype)

let splitFunctionTypeVI (fvi: varinfo)
    : typ * (string * typ * attributes) list option * bool * attributes =
  match unrollType fvi.vtype with
    TFun (rt, args, isva, a) -> rt, args, isva, a
  | _ -> E.s (bug "Function %s invoked on a non function type" fvi.vname)

let isArrayType t =
  match unrollType t with
    TArray _ -> true
  | _ -> false


let rec isConstant = function
  | Const _ -> true
  | UnOp (_, e, _) -> isConstant e
  | BinOp (_, e1, e2, _) -> isConstant e1 && isConstant e2
  | Lval (Var vi, NoOffset) ->
      (vi.vglob && isArrayType vi.vtype || isFunctionType vi.vtype)
  | Lval _ -> false
  | SizeOf _ | SizeOfE _ | SizeOfStr _ | AlignOf _ | AlignOfE _ -> true
  | CastE (_, e) -> isConstant e
  | AddrOf (Var vi, off) | StartOf (Var vi, off)
        -> vi.vglob && isConstantOff off
  | AddrOf (Mem e, off) | StartOf(Mem e, off)
        -> isConstant e && isConstantOff off

and isConstantOff = function
    NoOffset -> true
  | Field(fi, off) -> isConstantOff off
  | Index(e, off) -> isConstant e && isConstantOff off


let getCompField (cinfo:compinfo) (fieldName:string) : fieldinfo =
  (List.find (fun fi -> fi.fname = fieldName) cinfo.cfields)


let rec mkCastT ~(e: exp) ~(oldt: typ) ~(newt: typ) =
  (* Do not remove old casts because they are conversions !!! *)
  if typeSig oldt = typeSig newt then begin
    e
  end else begin
    (* Watch out for constants *)
    match newt, e with
      TInt(newik, []), Const(CInt64(i, _, _)) -> kinteger64 newik i
    | _ -> CastE(newt,e)
  end

let mkCast ~(e: exp) ~(newt: typ) =
  mkCastT e (typeOf e) newt

type existsAction =
    ExistsTrue                          (* We have found it *)
  | ExistsFalse                         (* Stop processing this branch *)
  | ExistsMaybe                         (* This node is not what we are
                                         * looking for but maybe its
                                         * successors are *)
let existsType (f: typ -> existsAction) (t: typ) : bool =
  let memo : (int, unit) H.t = H.create 17 in  (* Memo table *)
  let rec loop t =
    match f t with
      ExistsTrue -> true
    | ExistsFalse -> false
    | ExistsMaybe ->
        (match t with
          TNamed (t', _) -> loop t'.ttype
        | TComp (c, _) -> loopComp c
        | TArray (t', _, _) -> loop t'
        | TPtr (t', _) -> loop t'
        | TFun (rt, args, _, _) ->
            (loop rt || List.exists (fun (_, at, _) -> loop at)
              (argsToList args))
        | _ -> false)
  and loopComp c =
    if H.mem memo c.ckey then
      (* We are looping, the answer must be false *)
      false
    else begin
      H.add memo c.ckey ();
      List.exists (fun f -> loop f.ftype) c.cfields
    end
  in
  loop t

(**
 **
 ** MACHINE DEPENDENT PART
 **
 **)
exception SizeOfError of typ


(* Get the minimum aligment in bytes for a given type *)
let rec alignOf_int = function
  | TInt((IChar|ISChar|IUChar), _) -> 1
  | TInt((IBool), _) -> !theMachine.alignof_cbool
  | TInt((IShort|IUShort), _) -> !theMachine.alignof_short
  | TInt((IInt|IUInt), _) -> !theMachine.alignof_int
  | TInt((ILong|IULong), _) -> !theMachine.alignof_long
  | TInt((ILongLong|IULongLong), _) -> !theMachine.alignof_longlong
  | TEnum _ -> !theMachine.alignof_enum

  | TFloat(FFloat, _) -> !theMachine.alignof_float
  | TFloat(FDouble, _) -> !theMachine.alignof_double
  | TFloat(FLongDouble, _) -> !theMachine.alignof_longdouble

  | TFloat(IFloat, _) -> !theMachine.alignof_imaginary
  | TFloat(IDouble, _) -> !theMachine.alignof_doubleimaginary
  | TFloat(ILongDouble, _) -> !theMachine.alignof_longdoubleimaginary

  | TFloat(CFloat, _) -> !theMachine.alignof_complex
  | TFloat(CDouble, _) -> !theMachine.alignof_doublecomplex
  | TFloat(CLongDouble, _) -> !theMachine.alignof_longdoublecomplex

  | TNamed (t, _) -> alignOf_int t.ttype
  | TArray (t, _, _) -> alignOf_int t
  | TPtr _ | TBuiltin_va_list _ -> !theMachine.sizeof_ptr

        (* For composite types get the maximum alignment of any field inside *)
  | TComp (c, _) ->
      (* On GCC the zero-width fields do not contribute to the alignment. On
       * MSVC only those zero-width that _do_ appear after other
       * bitfields contribute to the alignment. So we drop those that
       * do not occur after othe bitfields *)
      let rec dropZeros (afterbitfield: bool) = function
        | f :: rest when f.fbitfield = Some 0 && not afterbitfield ->
            dropZeros afterbitfield rest
        | f :: rest -> f :: dropZeros (f.fbitfield <> None) rest
        | [] -> []
      in
      let fields = dropZeros false c.cfields in
      List.fold_left
        (fun sofar f ->
          (* Bitfields with zero width do not contribute to the alignment in
           * GCC *)
          if not !msvcMode && f.fbitfield = Some 0 then sofar else
          max sofar (alignOf_int f.ftype)) 1 fields
        (* These are some error cases *)
  | TFun _ when not !msvcMode -> !theMachine.alignof_fun

  | (TFun _ | TVoid _) as t -> raise (SizeOfError t)



type offsetAcc =
    { oaFirstFree: int;        (* The first free bit *)
      oaLastFieldStart: int;   (* Where the previous field started *)
      oaLastFieldWidth: int;   (* The width of the previous field. Might not
                                * be same as FirstFree - FieldStart because
                                * of internal padding *)
      oaPrevBitPack: (int * ikind * int) option; (* If the previous fields
                                                   * were packed bitfields,
                                                   * the bit where packing
                                                   * has started, the ikind
                                                   * of the bitfield and the
                                                   * width of the ikind *)
    }


(* GCC version *)
(* Does not use the sofar.oaPrevBitPack *)
let rec offsetOfFieldAcc_GCC (fi: fieldinfo)
                             (sofar: offsetAcc) : offsetAcc =
  (* field type *)
  let ftype = unrollType fi.ftype in
  let ftypeAlign = 8 * alignOf_int ftype in
  let ftypeBits = bitsSizeOf ftype in
(*
  if fi.fcomp.cname = "comp2468" ||
     fi.fcomp.cname = "comp2469" ||
     fi.fcomp.cname = "comp2470" ||
     fi.fcomp.cname = "comp2471" ||
     fi.fcomp.cname = "comp2472" ||
     fi.fcomp.cname = "comp2473" ||
     fi.fcomp.cname = "comp2474" ||
     fi.fcomp.cname = "comp2475" ||
     fi.fcomp.cname = "comp2476" ||
     fi.fcomp.cname = "comp2477" ||
     fi.fcomp.cname = "comp2478" then

    ignore (E.log "offsetOfFieldAcc_GCC(%s of %s:%a%a,firstFree=%d,pack=%a)\n"
              fi.fname fi.fcomp.cname
              d_type ftype
              insert
              (match fi.fbitfield with
                None -> nil
              | Some wdthis -> dprintf ":%d" wdthis)
              sofar.oaFirstFree
              insert
              (match sofar.oaPrevBitPack with
                None -> text "None"
              | Some (packstart, _, wdpack) ->
                  dprintf "Some(packstart=%d,wd=%d)"
                    packstart wdpack));
*)
  match ftype, fi.fbitfield with
    (* A width of 0 means that we must end the current packing. It seems that
     * GCC pads only up to the alignment boundary for the type of this field.
     * *)
  | _, Some 0 ->
      let firstFree      = addTrailing sofar.oaFirstFree ftypeAlign in
      { oaFirstFree      = firstFree;
        oaLastFieldStart = firstFree;
        oaLastFieldWidth = 0;
        oaPrevBitPack    = None }

    (* A bitfield cannot span more alignment boundaries of its type than the
     * type itself *)
  | _, Some wdthis
      when (sofar.oaFirstFree + wdthis + ftypeAlign - 1) / ftypeAlign
            - sofar.oaFirstFree / ftypeAlign > ftypeBits / ftypeAlign ->
          let start = addTrailing sofar.oaFirstFree ftypeAlign in
          { oaFirstFree      = start + wdthis;
            oaLastFieldStart = start;
            oaLastFieldWidth = wdthis;
            oaPrevBitPack    = None }

   (* Try a simple method. Just put the field down *)
  | _, Some wdthis ->
      { oaFirstFree      = sofar.oaFirstFree + wdthis;
        oaLastFieldStart = sofar.oaFirstFree;
        oaLastFieldWidth = wdthis;
        oaPrevBitPack    = None
      }

     (* Non-bitfield *)
  | _, None ->
      (* Align this field *)
      let newStart = addTrailing sofar.oaFirstFree ftypeAlign  in
      { oaFirstFree = newStart + ftypeBits;
        oaLastFieldStart = newStart;
        oaLastFieldWidth = ftypeBits;
        oaPrevBitPack = None;
      }

(* MSVC version *)
and offsetOfFieldAcc_MSVC (fi: fieldinfo)
                              (sofar: offsetAcc) : offsetAcc =
  (* field type *)
  let ftype = unrollType fi.ftype in
  let ftypeAlign = 8 * alignOf_int ftype in
  let ftypeBits = bitsSizeOf ftype in
(*
  ignore (E.log "offsetOfFieldAcc_MSVC(%s of %s:%a%a,firstFree=%d, pack=%a)\n"
            fi.fname fi.fcomp.cname
            d_type ftype
            insert
            (match fi.fbitfield with
              None -> nil
            | Some wdthis -> dprintf ":%d" wdthis)
            sofar.oaFirstFree
            insert
            (match sofar.oaPrevBitPack with
              None -> text "None"
            | Some (prevpack, _, wdpack) -> dprintf "Some(prev=%d,wd=%d)"
                  prevpack wdpack));
*)
  match ftype, fi.fbitfield, sofar.oaPrevBitPack with
    (* Ignore zero-width bitfields that come after non-bitfields *)
  | TInt (ikthis, _), Some 0, None ->
      let firstFree      = sofar.oaFirstFree in
      { oaFirstFree      = firstFree;
        oaLastFieldStart = firstFree;
        oaLastFieldWidth = 0;
        oaPrevBitPack    = None }

    (* If we are in a bitpack and we see a bitfield for a type with the
     * different width than the pack, then we finish the pack and retry *)
  | _, Some _, Some (packstart, _, wdpack) when wdpack != ftypeBits ->
      let firstFree =
        if sofar.oaFirstFree = packstart then packstart else
        packstart + wdpack
      in
      offsetOfFieldAcc_MSVC fi
        { oaFirstFree      = addTrailing firstFree ftypeAlign;
          oaLastFieldStart = sofar.oaLastFieldStart;
          oaLastFieldWidth = sofar.oaLastFieldWidth;
          oaPrevBitPack    = None }

    (* A width of 0 means that we must end the current packing. *)
  | TInt (ikthis, _), Some 0, Some (packstart, _, wdpack) ->
      let firstFree =
        if sofar.oaFirstFree = packstart then packstart else
        packstart + wdpack
      in
      let firstFree      = addTrailing firstFree ftypeAlign in
      { oaFirstFree      = firstFree;
        oaLastFieldStart = firstFree;
        oaLastFieldWidth = 0;
        oaPrevBitPack    = Some (firstFree, ikthis, ftypeBits) }

   (* Flx_cil_check for a bitfield that fits in the current pack after some other
    * bitfields *)
  | TInt(ikthis, _), Some wdthis, Some (packstart, ikprev, wdpack)
      when  packstart + wdpack >= sofar.oaFirstFree + wdthis ->
              { oaFirstFree = sofar.oaFirstFree + wdthis;
                oaLastFieldStart = sofar.oaFirstFree;
                oaLastFieldWidth = wdthis;
                oaPrevBitPack = sofar.oaPrevBitPack
              }


  | _, _, Some (packstart, _, wdpack) -> (* Finish up the bitfield pack and
                                          * restart. *)
      let firstFree =
        if sofar.oaFirstFree = packstart then packstart else
        packstart + wdpack
      in
      offsetOfFieldAcc_MSVC fi
        { oaFirstFree      = addTrailing firstFree ftypeAlign;
          oaLastFieldStart = sofar.oaLastFieldStart;
          oaLastFieldWidth = sofar.oaLastFieldWidth;
          oaPrevBitPack    = None }

        (* No active bitfield pack. But we are seeing a bitfield. *)
  | TInt(ikthis, _), Some wdthis, None ->
      let firstFree     = addTrailing sofar.oaFirstFree ftypeAlign in
      { oaFirstFree     = firstFree + wdthis;
        oaLastFieldStart = firstFree;
        oaLastFieldWidth = wdthis;
        oaPrevBitPack = Some (firstFree, ikthis, ftypeBits); }

     (* No active bitfield pack. Non-bitfield *)
  | _, None, None ->
      (* Align this field *)
      let firstFree = addTrailing sofar.oaFirstFree ftypeAlign  in
      { oaFirstFree = firstFree + ftypeBits;
        oaLastFieldStart = firstFree;
        oaLastFieldWidth = ftypeBits;
        oaPrevBitPack = None;
      }

  | _, Some _, None -> E.s (E.bug "offsetAcc")


and offsetOfFieldAcc ~(fi: fieldinfo)
                     ~(sofar: offsetAcc) : offsetAcc =
  if !msvcMode then offsetOfFieldAcc_MSVC fi sofar
  else offsetOfFieldAcc_GCC fi sofar

(* The size of a type, in bits. If struct or array then trailing padding is
 * added *)
and bitsSizeOf t =
  match t with
    (* For long long sometimes the alignof and sizeof are different *)
  | TInt((ILongLong|IULongLong), _) -> 8 * !theMachine.sizeof_longlong
  | TFloat(FDouble, _) -> 8 * 8
  | TFloat(FLongDouble, _) -> 8 * !theMachine.sizeof_longdouble
  | TInt _ | TFloat _ | TEnum _ | TPtr _ | TBuiltin_va_list _
    -> 8 * alignOf_int t
  | TNamed (t, _) -> bitsSizeOf t.ttype
  | TComp (comp, _) when comp.cfields = [] -> begin
      (* Empty structs are allowed in msvc mode *)
      if not comp.cdefined && not !msvcMode then
        raise (SizeOfError t) (*abstract type*)
      else
        0
  end

  | TComp (comp, _) when comp.cstruct -> (* Struct *)
        (* Go and get the last offset *)
      let startAcc =
        { oaFirstFree = 0;
          oaLastFieldStart = 0;
          oaLastFieldWidth = 0;
          oaPrevBitPack = None;
        } in
      let lastoff =
        List.fold_left (fun acc fi -> offsetOfFieldAcc ~fi ~sofar:acc)
          startAcc comp.cfields
      in
      if !msvcMode && lastoff.oaFirstFree = 0 && comp.cfields <> [] then
          (* On MSVC if we have just a zero-width bitfields then the length
           * is 32 and is not padded  *)
        32
      else
        addTrailing lastoff.oaFirstFree (8 * alignOf_int t)

  | TComp (comp, _) -> (* when not comp.cstruct *)
        (* Get the maximum of all fields *)
      let startAcc =
        { oaFirstFree = 0;
          oaLastFieldStart = 0;
          oaLastFieldWidth = 0;
          oaPrevBitPack = None;
        } in
      let max =
        List.fold_left (fun acc fi ->
          let lastoff = offsetOfFieldAcc ~fi ~sofar:startAcc in
          if lastoff.oaFirstFree > acc then
            lastoff.oaFirstFree else acc) 0 comp.cfields in
        (* Add trailing by simulating adding an extra field *)
      addTrailing max (8 * alignOf_int t)

  | TArray(t, Some len, _) -> begin
      match constFold true len with
        Const(CInt64(l,_,_)) ->
          addTrailing ((bitsSizeOf t) * (Int64.to_int l)) (8 * alignOf_int t)
      | _ -> raise (SizeOfError t)
  end


  | TVoid _ -> 8 * !theMachine.sizeof_void
  | TFun _ when not !msvcMode -> (* On GCC the size of a function is defined *)
      8 * !theMachine.sizeof_fun

  | TArray (_, None, _) | TFun _ -> raise (SizeOfError t)


and addTrailing nrbits roundto =
    (nrbits + roundto - 1) land (lnot (roundto - 1))

and sizeOf t =
  try
    integer ((bitsSizeOf t) lsr 3)
  with SizeOfError _ -> SizeOf(t)


and bitsOffset (baset: typ) (off: offset) : int * int =
  let rec loopOff (baset: typ) (width: int) (start: int) = function
      NoOffset -> start, width
    | Index(e, off) -> begin
        let ei =
          match isInteger e with
            Some i64 -> Int64.to_int i64
          | None -> raise (SizeOfError baset)
        in
        let bt =
          match unrollType baset with
            TArray(bt, _, _) -> bt
          | _ -> E.s (E.bug "bitsOffset: Index on a non-array")
        in
        let bitsbt = bitsSizeOf bt in
        loopOff bt bitsbt (start + ei * bitsbt) off
    end
    | Field(f, off) when not f.fcomp.cstruct ->
        (* All union fields start at offset 0 *)
        loopOff f.ftype (bitsSizeOf f.ftype) start off

    | Field(f, off) ->
        (* Construct a list of fields preceeding and including this one *)
        let prevflds =
          let rec loop = function
              [] -> E.s (E.bug "bitsOffset: Cannot find field %s in %s\n"
                           f.fname f.fcomp.cname)
            | fi' :: _ when fi' == f -> [fi']
            | fi' :: rest -> fi' :: loop rest
          in
          loop f.fcomp.cfields
        in
        let lastoff =
          List.fold_left (fun acc fi' -> offsetOfFieldAcc ~fi:fi' ~sofar:acc)
            { oaFirstFree      = 0; (* Start at 0 because each struct is done
                                     * separately *)
              oaLastFieldStart = 0;
              oaLastFieldWidth = 0;
              oaPrevBitPack    = None } prevflds
        in
        (* ignore (E.log "Field %s of %s: start=%d, lastFieldStart=%d\n"
                  f.fname f.fcomp.cname start lastoff.oaLastFieldStart); *)
        loopOff f.ftype lastoff.oaLastFieldWidth
               (start + lastoff.oaLastFieldStart) off
  in
  loopOff baset (bitsSizeOf baset) 0 off




(*** Constant folding. If machdep is true then fold even sizeof operations ***)
and constFold (machdep: bool) (e: exp) : exp =
  match e with
    BinOp(bop, e1, e2, tres) -> constFoldBinOp machdep bop e1 e2 tres
  | UnOp(unop, e1, tres) -> begin
      try
        let tk =
          match unrollType tres with
            TInt(ik, _) -> ik
          | TEnum _ -> IInt
          | _ -> raise Not_found (* probably a float *)
        in
        match constFold machdep e1 with
          Const(CInt64(i,ik,_)) as e1c -> begin
            match unop with
              Neg -> kinteger64 tk (Int64.neg i)
            | BNot -> kinteger64 tk (Int64.lognot i)
            | LNot -> if i = Int64.zero then one else zero
            end
        | e1c -> UnOp(unop, e1c, tres)
      with Not_found -> e
  end
        (* Characters are integers *)
  | Const(CChr c) -> Const(CInt64(Int64.of_int (Char.code c),
                                  IInt, None))
  | SizeOf t when machdep -> begin
      try
        let bs = bitsSizeOf t in
        kinteger !kindOfSizeOf (bs / 8)
      with SizeOfError _ -> e
  end
  | SizeOfE e when machdep -> constFold machdep (SizeOf (typeOf e))
  | SizeOfStr s when machdep -> kinteger !kindOfSizeOf (1 + String.length s)
  | AlignOf t when machdep -> kinteger !kindOfSizeOf (alignOf_int t)
  | AlignOfE e when machdep -> begin
      (* The alignmetn of an expression is not always the alignment of its
       * type. I know that for strings this is not true *)
      match e with
        Const (CStr _) when not !msvcMode ->
          kinteger !kindOfSizeOf !theMachine.alignof_str
            (* For an array, it is the alignment of the array ! *)
      | _ -> constFold machdep (AlignOf (typeOf e))
  end

  | CastE (t, e) -> begin
      match constFold machdep e, unrollType t with
        (* Might truncate silently *)
        Const(CInt64(i,k,_)), TInt(nk,_) ->
          let i' = truncateInteger64 nk i in
          Const(CInt64(i', nk, None))
      | e', _ -> CastE (t, e')
  end

  | _ -> e

and constFoldBinOp (machdep: bool) bop e1 e2 tres =
  let e1' = constFold machdep e1 in
  let e2' = constFold machdep e2 in
  if isIntegralType tres then begin
    let newe =
      let rec mkInt = function
          Const(CChr c) -> Const(CInt64(Int64.of_int (Char.code c),
                                        IInt, None))
        | CastE(TInt (ik, ta), e) -> begin
            match mkInt e with
              Const(CInt64(i, _, _)) ->
                let i' = truncateInteger64 ik i in
                Const(CInt64(i', ik, None))

            | e' -> CastE(TInt(ik, ta), e')
        end
        | e -> e
      in
      let tk =
        match unrollType tres with
          TInt(ik, _) -> ik
        | TEnum _ -> IInt
        | _ -> E.s (bug "constFoldBinOp")
      in
      (* See if the result is unsigned *)
      let isunsigned typ = not (isSigned typ) in
      let ge (unsigned: bool) (i1: int64) (i2: int64) : bool =
        if unsigned then
          let l1 = Int64.shift_right_logical i1 1 in
          let l2 = Int64.shift_right_logical i2 1 in (* Both positive now *)
          (l1 > l2) || (l1 = l2 &&
                        Int64.logand i1 Int64.one >= Int64.logand i2 Int64.one)
        else i1 >= i2
      in
      (* Assume that the necessary promotions have been done *)
      match bop, mkInt e1', mkInt e2' with
      | PlusA, Const(CInt64(z,_,_)), e2'' when z = Int64.zero -> e2''
      | PlusA, e1'', Const(CInt64(z,_,_)) when z = Int64.zero -> e1''
      | PlusPI, e1'', Const(CInt64(z,_,_)) when z = Int64.zero -> e1''
      | IndexPI, e1'', Const(CInt64(z,_,_)) when z = Int64.zero -> e1''
      | MinusPI, e1'', Const(CInt64(z,_,_)) when z = Int64.zero -> e1''
      | PlusA, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          kinteger64 tk (Int64.add i1 i2)
      | MinusA, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          kinteger64 tk (Int64.sub i1 i2)
      | Mult, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          kinteger64 tk (Int64.mul i1 i2)
      | Div, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 -> begin
          try kinteger64 tk (Int64.div i1 i2)
          with Division_by_zero -> BinOp(bop, e1', e2', tres)
      end
      | Mod, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 -> begin
          try kinteger64 tk (Int64.rem i1 i2)
          with Division_by_zero -> BinOp(bop, e1', e2', tres)
      end
      | BAnd, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          kinteger64 tk (Int64.logand i1 i2)
      | BOr, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          kinteger64 tk (Int64.logor i1 i2)
      | BXor, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          kinteger64 tk (Int64.logxor i1 i2)
      | Shiftlt, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,IInt,_)) ->
          kinteger64 tk (Int64.shift_left i1 (Int64.to_int i2))
      | Shiftrt, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,IInt,_)) ->
          if isunsigned ik1 then
            kinteger64 tk (Int64.shift_right_logical i1 (Int64.to_int i2))
          else
            kinteger64 tk (Int64.shift_right i1 (Int64.to_int i2))

      | Eq, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          integer (if i1 = i2 then 1 else 0)
      | Ne, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          integer (if i1 <> i2 then 1 else 0)
      | Le, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          integer (if ge (isunsigned ik1) i2 i1 then 1 else 0)

      | Ge, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          integer (if ge (isunsigned ik1) i1 i2 then 1 else 0)

      | Lt, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          integer (if i1 <> i2 && ge (isunsigned ik1) i2 i1 then 1 else 0)

      | Gt, Const(CInt64(i1,ik1,_)),Const(CInt64(i2,ik2,_)) when ik1 = ik2 ->
          integer (if i1 <> i2 && ge (isunsigned ik1) i1 i2 then 1 else 0)
      | LAnd, _, _ when isZero e1' || isZero e2' -> zero
      | LOr, _, _ when isZero e1' -> e2'
      | LOr, _, _ when isZero e2' -> e1'
      | _ -> BinOp(bop, e1', e2', tres)
    in
    if debugConstFold then
      ignore (E.log "Folded %a to %a\n" d_exp (BinOp(bop, e1', e2', tres)) d_exp newe);
    newe
  end else
    BinOp(bop, e1', e2', tres)


(* Try to do an increment, with constant folding *)
let increm (e: exp) (i: int) =
  let et = typeOf e in
  let bop = if isPointerType et then PlusPI else PlusA in
  constFold false (BinOp(bop, e, integer i, et))

exception LenOfArray
let lenOfArray (eo: exp option) : int =
  match eo with
    None -> raise LenOfArray
  | Some e -> begin
      match constFold true e with
      | Const(CInt64(ni, _, _)) when ni >= Int64.zero ->
          Int64.to_int ni
      | e -> raise LenOfArray
  end


(*** Make a initializer for zeroe-ing a data type ***)
let rec makeZeroInit (t: typ) : init =
  match unrollType t with
    TInt (ik, _) -> SingleInit (Const(CInt64(Int64.zero, ik, None)))
  | TFloat(fk, _) -> SingleInit(Const(CReal(0.0, fk, None)))
  | TEnum _ -> SingleInit zero
  | TComp (comp, _) as t' when comp.cstruct ->
      let inits =
        List.fold_right
          (fun f acc ->
            if f.fname <> missingFieldName then
              (Field(f, NoOffset), makeZeroInit f.ftype) :: acc
            else
              acc)
          comp.cfields []
      in
      CompoundInit (t', inits)

  | TComp (comp, _) as t' when not comp.cstruct ->
      let fstfield =
        match comp.cfields with
          f :: _ -> f
        | [] -> E.s (unimp "Cannot create init for empty union")
      in
      CompoundInit(t, [(Field(fstfield, NoOffset),
                        makeZeroInit fstfield.ftype)])

  | TArray(bt, Some len, _) as t' ->
      let n =
        match constFold true len with
          Const(CInt64(n, _, _)) -> Int64.to_int n
        | _ -> E.s (E.unimp "Cannot understand length of array")
      in
      let initbt = makeZeroInit bt in
      let rec loopElems acc i =
        if i < 0 then acc
        else loopElems ((Index(integer i, NoOffset), initbt) :: acc) (i - 1)
      in
      CompoundInit(t', loopElems [] (n - 1))

  | TArray (bt, None, at) as t' ->
      (* Unsized array, allow it and fill it in later
       * (see cabs2cil.ml, collectInitializer) *)
      CompoundInit (t', [])

  | TPtr _ as t -> SingleInit(CastE(t, zero))
  | x -> E.s (unimp "Cannot initialize type: %a" d_type x)


(**** Fold over the list of initializers in a Compound. In the case of an
 * array initializer only the initializers present are scanned (a prefix of
 * all initializers) *)
let foldLeftCompound
    ~(doinit: offset -> init -> typ -> 'a -> 'a)
    ~(ct: typ)
    ~(initl: (offset * init) list)
    ~(acc: 'a) : 'a =
  match unrollType ct with
    TArray(bt, _, _) ->
      List.fold_left (fun acc (o, i) -> doinit o i bt acc) acc initl

  | TComp (comp, _) ->
      let getTypeOffset = function
          Field(f, NoOffset) -> f.ftype
        | _ -> E.s (bug "foldLeftCompound: malformed initializer")
      in
      List.fold_left
        (fun acc (o, i) -> doinit o i (getTypeOffset o) acc) acc initl

  | _ -> E.s (unimp "Type of Compound is not array or struct or union")

(**** Fold over the list of initializers in a Compound. Like foldLeftCompound
 * but scans even the zero-initializers that are missing at the end of the
 * array *)
let foldLeftCompoundAll
    ~(doinit: offset -> init -> typ -> 'a -> 'a)
    ~(ct: typ)
    ~(initl: (offset * init) list)
    ~(acc: 'a) : 'a =
  match unrollType ct with
    TArray(bt, leno, _) -> begin
      let part =
        List.fold_left (fun acc (o, i) -> doinit o i bt acc) acc initl in
      (* See how many more we have to do *)
      match leno with
        Some lene -> begin
          match constFold true lene with
            Const(CInt64(i, _, _)) ->
              let len_array = Int64.to_int i in
              let len_init = List.length initl in
              if len_array > len_init then
                let zi = makeZeroInit bt in
                let rec loop acc i =
                  if i >= len_array then acc
                  else
                    loop (doinit (Index(integer i, NoOffset)) zi bt acc)
                         (i + 1)
                in
                loop part (len_init + 1)
              else
                part
          | _ -> E.s (unimp "foldLeftCompoundAll: array with initializer and non-constant length\n")
        end

      | _ -> E.s (unimp "foldLeftCompoundAll: TArray with initializer and no length")
    end
  | TComp (comp, _) ->
      let getTypeOffset = function
          Field(f, NoOffset) -> f.ftype
        | _ -> E.s (bug "foldLeftCompound: malformed initializer")
      in
      List.fold_left
        (fun acc (o, i) -> doinit o i (getTypeOffset o) acc) acc initl

  | _ -> E.s (E.unimp "Type of Compound is not array or struct or union")



let rec isCompleteType t =
  match unrollType t with
  | TArray(t, None, _) -> false
  | TArray(t, Some z, _) when isZero z -> false
  | TComp (comp, _) -> (* Struct or union *)
      List.for_all (fun fi -> isCompleteType fi.ftype) comp.cfields
  | _ -> true



let debugAlpha (prefix: string) = false
(*** Alpha conversion ***)
let alphaSeparator = "___"
let alphaSeparatorLen = String.length alphaSeparator

(** For each prefix we remember the list of suffixes and the next integer
 * suffix to use *)
type alphaTableData = int * (string * location) list

type undoAlphaElement =
    AlphaChangedSuffix of alphaTableData ref * alphaTableData (* The
                                             * reference that was changed and
                                             * the old suffix *)
  | AlphaAddedSuffix of string          (* We added this new entry to the
                                         * table *)

(* Create a new name based on a given name. The new name is formed from a
 * prefix (obtained from the given name by stripping a suffix consisting of
 * the alphaSeparator followed by only digits), followed by alphaSeparator
 * and then by a positive integer suffix. The first argument is a table
 * mapping name prefixes to the largest suffix used so far for that
 * prefix. The largest suffix is one when only the version without suffix has
 * been used. *)
let rec newAlphaName ~(alphaTable: (string, alphaTableData ref) H.t)
                     ~(undolist: undoAlphaElement list ref option)
                     ~(lookupname: string) : string * location =
  alphaWorker ~alphaTable:alphaTable ~undolist:undolist
              ~lookupname:lookupname true


(** Just register the name so that we will not use in the future *)
and registerAlphaName ~(alphaTable: (string, alphaTableData ref) H.t)
                      ~(undolist: undoAlphaElement list ref option)
                      ~(lookupname: string) : unit =
  ignore (alphaWorker ~alphaTable:alphaTable ~undolist:undolist
                      ~lookupname:lookupname false)


and alphaWorker      ~(alphaTable: (string, alphaTableData ref) H.t)
                     ~(undolist: undoAlphaElement list ref option)
                     ~(lookupname: string)
                     (make_new: bool) : string * location =
  let prefix, suffix, (numsuffix: int) = splitNameForAlpha ~lookupname in
  if debugAlpha prefix then
    ignore (E.log "Alpha worker: prefix=%s suffix=%s (%d) create=%b. "
              prefix suffix numsuffix make_new);
  let newname, (oldloc: location) =
    try
      let rc = H.find alphaTable prefix in
      let max, suffixes = !rc in
      (* We have seen this prefix *)
      if debugAlpha prefix then
        ignore (E.log " Old max %d. Old suffixes: @[%a@]" max
                  (docList (chr ',')
                     (fun (s, l) -> dprintf "%a:%s" d_loc l s)) suffixes);
      (* Save the undo info *)
      (match undolist with
        Some l -> l := AlphaChangedSuffix (rc, !rc) :: !l
      | _ -> ());

      let newmax, newsuffix, (oldloc: location), newsuffixes =
        if numsuffix > max then begin
          (* Clearly we have not seen it *)
          numsuffix, suffix, !currentLoc,
          (suffix, !currentLoc) :: suffixes
        end else begin
          match List.filter (fun (n, _) -> n = suffix) suffixes with
            [] -> (* Not found *)
              max, suffix, !currentLoc, (suffix, !currentLoc) :: suffixes
          | [(_, l) ] ->
              (* We have seen this exact suffix before *)
              if make_new then
                let newsuffix = alphaSeparator ^ (string_of_int (max + 1)) in
                max + 1, newsuffix, l, (newsuffix, !currentLoc) :: suffixes
              else
                max, suffix, !currentLoc, suffixes
          |  _ -> E.s (E.bug "Flx_cil_cil.alphaWorker")
        end
      in
      rc := (newmax, newsuffixes);
      prefix ^ newsuffix, oldloc
    with Not_found -> begin (* First variable with this prefix *)
      (match undolist with
        Some l -> l := AlphaAddedSuffix prefix :: !l
      | _ -> ());
      H.add alphaTable prefix (ref (numsuffix, [ (suffix, !currentLoc) ]));
      if debugAlpha prefix then ignore (E.log " First seen. ");
      lookupname, !currentLoc  (* Return the original name *)
    end
  in
  if debugAlpha prefix then
    ignore (E.log " Res=: %s (%a)\n" newname d_loc oldloc);
  newname, oldloc

(* Strip the suffix. Return the prefix, the suffix (including the separator
 * and the numeric value, possibly empty), and the
 * numeric value of the suffix (possibly -1 if missing) *)
and splitNameForAlpha ~(lookupname: string) : (string * string * int) =
  let len = String.length lookupname in
  (* Search backward for the numeric suffix. Return the first digit of the
   * suffix. Returns len if no numeric suffix *)
  let rec skipSuffix (i: int) =
    if i = -1 then -1 else
    let c = Char.code (String.get lookupname i) - Char.code '0' in
    if c >= 0 && c <= 9 then
      skipSuffix (i - 1)
    else (i + 1)
  in
  let startSuffix = skipSuffix (len - 1) in

  if startSuffix >= len (* No digits at all at the end *) ||
     startSuffix <= alphaSeparatorLen     (* Not enough room for a prefix and
                                           * the separator before suffix *) ||
     (* Suffix starts with a 0 and has more characters after that *)
     (startSuffix < len - 1 && String.get lookupname startSuffix = '0')  ||
     alphaSeparator <> String.sub lookupname
                                 (startSuffix - alphaSeparatorLen)
                                 alphaSeparatorLen
  then
    (lookupname, "", -1)  (* No valid suffix in the name *)
  else
    (String.sub lookupname 0 (startSuffix - alphaSeparatorLen),
     String.sub lookupname (startSuffix - alphaSeparatorLen)
                           (len - startSuffix + alphaSeparatorLen),
     int_of_string (String.sub lookupname startSuffix (len - startSuffix)))


let getAlphaPrefix ~(lookupname:string) : string =
  let p, _, _ = splitNameForAlpha ~lookupname:lookupname in
  p

(* Undoes the changes as specified by the undolist *)
let undoAlphaChanges ~(alphaTable: (string, alphaTableData ref) H.t)
                     ~(undolist: undoAlphaElement list) =
  List.iter
    (function
        AlphaChangedSuffix (where, old) ->
          where := old
      | AlphaAddedSuffix name ->
          if debugAlpha name then
            ignore (E.log "Removing %s from alpha table\n" name);
          H.remove alphaTable name)
    undolist

let docAlphaTable () (alphaTable: (string, alphaTableData ref) H.t) =
  let acc : (string * (int * (string * location) list)) list ref = ref [] in
  H.iter (fun k d -> acc := (k, !d) :: !acc) alphaTable;
  docList line (fun (k, (d, _)) -> dprintf "  %s -> %d" k d) () !acc


(** Uniquefy the variable names *)
let uniqueVarNames (f: file) : unit =
  (* Setup the alpha conversion table for globals *)
  let gAlphaTable: (string, alphaTableData ref) H.t = H.create 113 in
  (* Keep also track of the global names that we have used. Map them to the
   * variable ID. We do this only to check that we do not have two globals
   * with the same name. *)
  let globalNames: (string, int) H.t = H.create 113 in
  (* Scan the file and add the global names to the table *)
  iterGlobals f
    (function
        GVarDecl(vi, l)
      | GVar(vi, _, l)
      | GFun({svar = vi}, l) ->
          (* See if we have used this name already for something else *)
          (try
            let oldid = H.find globalNames vi.vname in
            if oldid <> vi.vid then
              ignore (warn "The name %s is used for two distinct globals"
                        vi.vname);
            (* Here if we have used this name already. Go ahead *)
            ()
          with Not_found -> begin
            (* Here if this is the first time we define a name *)
            H.add globalNames vi.vname vi.vid;
            (* And register it *)
            registerAlphaName gAlphaTable None vi.vname;
            ()
          end)
      | _ -> ());

  (* Now we must scan the function bodies and rename the locals *)
  iterGlobals f
    (function
        GFun(fdec, l) -> begin
          currentLoc := l;
          (* Setup an undo list to be able to revert the changes to the
           * global alpha table *)
          let undolist = ref [] in
          (* Process one local variable *)
          let processLocal (v: varinfo) =
            let newname, oldloc =
              newAlphaName gAlphaTable (Some undolist) v.vname in
            if false && newname <> v.vname then (* Disable this warning *)
              ignore (warn "uniqueVarNames: Changing the name of local %s in %s to %s (due to duplicate at %a)\n"
                        v.vname fdec.svar.vname newname d_loc oldloc);
            v.vname <- newname
          in
          (* Do the formals first *)
          List.iter processLocal fdec.sformals;
          (* Fix the type again *)
          setFormals fdec fdec.sformals;
          (* And now the locals *)
          List.iter processLocal fdec.slocals;
          (* Undo the changes to the global table *)
          undoAlphaChanges gAlphaTable !undolist;
          ()
        end
      | _ -> ());
  ()


(* A visitor that makes a deep copy of a function body *)
class copyFunctionVisitor (newname: string) = object (self)
  inherit nopCilVisitor

      (* Keep here a maping from locals to their copies *)
  val map : (string, varinfo) H.t = H.create 113
      (* Keep here a maping from statements to their copies *)
  val stmtmap : (int, stmt) H.t = H.create 113
  val sid = ref 0 (* Will have to assign ids to statements *)
      (* Keep here a list of statements to be patched *)
  val patches : stmt list ref = ref []

  val argid = ref 0

      (* This is the main function *)
  method vfunc (f: fundec) : fundec visitAction =
    (* We need a map from the old locals/formals to the new ones *)
    H.clear map;
    argid := 0;
     (* Make a copy of the fundec. *)
    let f' = {f with svar = f.svar} in
    let patchfunction (f' : fundec) =
      (* Change the name. Only this late to allow the visitor to copy the
       * svar  *)
      f'.svar.vname <- newname;
      let findStmt (i: int) =
        try H.find stmtmap i
        with Not_found -> E.s (bug "Cannot find the copy of stmt#%d" i)
      in
      let patchstmt (s: stmt) =
        match s.skind with
          Goto (sr, l) ->
            (* Make a copy of the reference *)
            let sr' = ref (findStmt !sr.sid) in
            s.skind <- Goto (sr',l)
        | Switch (e, body, cases, l) ->
            s.skind <- Switch (e, body,
                               List.map (fun cs -> findStmt cs.sid) cases, l)
        | _ -> ()
      in
      List.iter patchstmt !patches;
      f'
    in
    patches := [];
    sid := 0;
    H.clear stmtmap;
    ChangeDoChildrenPost (f', patchfunction)

      (* We must create a new varinfo for each declaration. Memoize to
       * maintain sharing *)
  method vvdec (v: varinfo) =
    (* Some varinfo have empty names. Give them some name *)
    if v.vname = "" then begin
      v.vname <- "arg" ^ string_of_int !argid; incr argid
    end;
    try
      ChangeTo (H.find map v.vname)
    with Not_found -> begin
      let v' = {v with vid = !nextGlobalVID} in
      incr nextGlobalVID;
      H.add map v.vname v';
      ChangeDoChildrenPost (v', fun x -> x)
    end

      (* We must replace references to local variables *)
  method vvrbl (v: varinfo) =
    if v.vglob then SkipChildren else
    try
      ChangeTo (H.find map v.vname)
    with Not_found ->
      E.s (bug "Cannot find the new copy of local variable %s" v.vname)


        (* Replace statements. *)
  method vstmt (s: stmt) : stmt visitAction =
    s.sid <- !sid; incr sid;
    let s' = {s with sid = s.sid} in
    H.add stmtmap s.sid s'; (* Remember where we copied this *)
    (* if we have a Goto or a Switch remember them to fixup at end *)
    (match s'.skind with
      (Goto _ | Switch _) -> patches := s' :: !patches
    | _ -> ());
    (* Do the children *)
    ChangeDoChildrenPost (s', fun x -> x)

      (* Copy blocks since they are mutable *)
  method vblock (b: block) =
    ChangeDoChildrenPost ({b with bstmts = b.bstmts}, fun x -> x)


  method vglob _ = E.s (bug "copyFunction should not be used on globals")
end

(* We need a function that copies a CIL function. *)
let copyFunction (f: fundec) (newname: string) : fundec =
  visitCilFunction (new copyFunctionVisitor(newname)) f

(********* Compute the CFG ********)
let sid_counter = ref 0
let statements : stmt list ref = ref []
(* Clear all info about the CFG in statements *)
class clear : cilVisitor = object
  inherit nopCilVisitor
  method vstmt s = begin
    s.sid <- !sid_counter ;
    incr sid_counter ;
    statements := s :: !statements;
    s.succs <- [] ;
    s.preds <- [] ;
    DoChildren
  end
  method vexpr _ = SkipChildren
  method vtype _ = SkipChildren
  method vinst _ = SkipChildren
end

let link source dest = begin
  if not (List.mem dest source.succs) then
    source.succs <- dest :: source.succs ;
  if not (List.mem source dest.preds) then
    dest.preds <- source :: dest.preds
end
let trylink source dest_option = match dest_option with
  None -> ()
| Some(dest) -> link source dest

let rec succpred_block b fallthrough =
  let rec handle sl = match sl with
    [] -> ()
  | [a] -> succpred_stmt a fallthrough
  | hd :: tl -> succpred_stmt hd (Some(List.hd tl)) ;
                handle tl
  in handle b.bstmts
and succpred_stmt s fallthrough =
  match s.skind with
    Instr _ -> trylink s fallthrough
  | Return _ -> ()
  | Goto(dest,l) -> link s !dest
  | Break _
  | Continue _
  | Switch _ ->
    failwith "computeCFGInfo: cannot be called on functions with break, continue or switch statements. Use prepareCFG first to remove them."
  | If(e1,b1,b2,l) ->
      (match b1.bstmts with
        [] -> trylink s fallthrough
      | hd :: tl -> (link s hd ; succpred_block b1 fallthrough )) ;
      (match b2.bstmts with
        [] -> trylink s fallthrough
      | hd :: tl -> (link s hd ; succpred_block b2 fallthrough ))
  | Loop(b,l,_,_) -> begin match b.bstmts with
                   [] -> failwith "computeCFGInfo: empty loop"
                 | hd :: tl ->
                    link s hd ;
                    succpred_block b (Some(hd))
                 end
  | Block(b) -> begin match b.bstmts with
                  [] -> trylink s fallthrough
                | hd :: tl -> link s hd ;
                    succpred_block b fallthrough
                end
  | TryExcept _ | TryFinally _ ->
      failwith "computeCFGInfo: structured exception handling not implemented"

(* [weimer] Sun May  5 12:25:24 PDT 2002
 * This code was pulled from ext/switch.ml because it looks like we really
 * want it to be part of CIL.
 *
 * Here is the magic handling to
 *  (1) replace switch statements with if/goto
 *  (2) remove "break"
 *  (3) remove "default"
 *  (4) remove "continue"
 *)
let is_case_label l = match l with
  | Case _ | Default _ -> true
  | _ -> false

let switch_count = ref (-1)
let get_switch_count () =
  switch_count := 1 + !switch_count ;
  !switch_count

let switch_label = ref (-1)

let rec xform_switch_stmt s break_dest cont_dest label_index = begin
  s.labels <- List.map (fun lab -> match lab with
    Label _ -> lab
  | Case(e,l) ->
      let suffix =
        match isInteger e with
        | Some value ->
            if value < Int64.zero then
              "neg_" ^ Int64.to_string (Int64.neg value)
            else
              Int64.to_string value
        | None ->
            incr switch_label;
            "exp_" ^ string_of_int !switch_label
      in
      let str = Flx_cil_pretty.sprint 80
          (Flx_cil_pretty.dprintf "switch_%d_%s" label_index suffix) in
      (Label(str,l,false))
  | Default(l) -> (Label(Printf.sprintf
                  "switch_%d_default" label_index,l,false))
  ) s.labels ;
  match s.skind with
  | Instr _ | Return _ | Goto _ -> ()
  | Break(l) -> begin try
                  s.skind <- Goto(break_dest (),l)
                with e ->
                  ignore (error "prepareCFG: break: %a@!" d_stmt s) ;
                  raise e
                end
  | Continue(l) -> begin try
                  s.skind <- Goto(cont_dest (),l)
                with e ->
                  ignore (error "prepareCFG: continue: %a@!" d_stmt s) ;
                  raise e
                end
  | If(e,b1,b2,l) -> xform_switch_block b1 break_dest cont_dest label_index ;
                     xform_switch_block b2 break_dest cont_dest label_index
  | Switch(e,b,sl,l) -> begin
      (* change
       * switch (se) {
       *   case 0: s0 ;
       *   case 1: s1 ; break;
       *   ...
       * }
       *
       * into:
       *
       * if (se == 0) goto label_0;
       * else if (se == 1) goto label_1;
       * ...
       * else if (0) { // body_block
       *  label_0: s0;
       *  label_1: s1; goto label_break;
       *  ...
       * } else if (0) { // break_block
       *  label_break: ; // break_stmt
       * }
       *)
      let i = get_switch_count () in
      let break_stmt = mkStmt (Instr []) in
      break_stmt.labels <-
                                [Label((Printf.sprintf "switch_%d_break" i),l,false)] ;
      let break_block = mkBlock [ break_stmt ] in
      let body_block = b in
      let body_if_stmtkind = (If(zero,body_block,break_block,l)) in

      (* The default case, if present, must be used only if *all*
      non-default cases fail [ISO/IEC 9899:1999, §6.8.4.2, ¶5]. As a
      result, we sort the order in which we handle the labels (but not the
      order in which we print out the statements, so fall-through still
      works as expected). *)
      let compare_choices s1 s2 = match s1.labels, s2.labels with
      | (Default(_) :: _), _ -> 1
      | _, (Default(_) :: _) -> -1
      | _, _ -> 0
      in

      let rec handle_choices sl = match sl with
        [] -> body_if_stmtkind
      | stmt_hd :: stmt_tl -> begin
        let rec handle_labels lab_list = begin
          match lab_list with
            [] -> handle_choices stmt_tl
          | Case(ce,cl) :: lab_tl ->
              let pred = BinOp(Eq,e,ce,intType) in
              let then_block = mkBlock [ mkStmt (Goto(ref stmt_hd,cl)) ] in
              let else_block = mkBlock [ mkStmt (handle_labels lab_tl) ] in
              If(pred,then_block,else_block,cl)
          | Default(dl) :: lab_tl ->
              (* ww: before this was 'if (1) goto label', but as Ben points
              out this might confuse someone down the line who doesn't have
              special handling for if(1) into thinking that there are two
              paths here. The simpler 'goto label' is what we want. *)
              Block(mkBlock [ mkStmt (Goto(ref stmt_hd,dl)) ;
                              mkStmt (handle_labels lab_tl) ])
          | Label(_,_,_) :: lab_tl -> handle_labels lab_tl
        end in
        handle_labels stmt_hd.labels
      end in
      s.skind <- handle_choices (List.sort compare_choices sl) ;
      xform_switch_block b (fun () -> ref break_stmt) cont_dest i
    end
  | Loop(b,l,_,_) ->
          let i = get_switch_count () in
          let break_stmt = mkStmt (Instr []) in
          break_stmt.labels <-
                                                [Label((Printf.sprintf "while_%d_break" i),l,false)] ;
          let cont_stmt = mkStmt (Instr []) in
          cont_stmt.labels <-
                                                [Label((Printf.sprintf "while_%d_continue" i),l,false)] ;
          b.bstmts <- cont_stmt :: b.bstmts ;
          let this_stmt = mkStmt
            (Loop(b,l,Some(cont_stmt),Some(break_stmt))) in
          let break_dest () = ref break_stmt in
          let cont_dest () = ref cont_stmt in
          xform_switch_block b break_dest cont_dest label_index ;
          break_stmt.succs <- s.succs ;
          let new_block = mkBlock [ this_stmt ; break_stmt ] in
          s.skind <- Block new_block
  | Block(b) -> xform_switch_block b break_dest cont_dest label_index

  | TryExcept _ | TryFinally _ ->
      failwith "xform_switch_statement: structured exception handling not implemented"

end and xform_switch_block b break_dest cont_dest label_index =
  try
    let rec link_succs sl = match sl with
    | [] -> ()
    | hd :: tl -> (if hd.succs = [] then hd.succs <- tl) ; link_succs tl
    in
    link_succs b.bstmts ;
    List.iter (fun stmt ->
      xform_switch_stmt stmt break_dest cont_dest label_index) b.bstmts ;
  with e ->
    List.iter (fun stmt -> ignore
      (warn "prepareCFG: %a@!" d_stmt stmt)) b.bstmts ;
    raise e

(* prepare a function for computeCFGInfo by removing break, continue,
 * default and switch statements/labels and replacing them with Ifs and
 * Gotos. *)
let prepareCFG (fd : fundec) : unit =
  xform_switch_block fd.sbody
      (fun () -> failwith "prepareCFG: break with no enclosing loop")
      (fun () -> failwith "prepareCFG: continue with no enclosing loop") (-1)

(* make the cfg and return a list of statements *)
let computeCFGInfo (f : fundec) (global_numbering : bool) : stmt list =
  let clear_it = new clear in
  if not global_numbering then
    sid_counter := 0 ;
  statements := [];
  ignore (visitCilBlock clear_it f.sbody) ;
  f.smaxstmtid <- Some (!sid_counter) ;
  succpred_block f.sbody (None);
  let res = !statements in
  statements := [];
  res

let initCIL () =
  (* Set the machine *)
  theMachine := if !msvcMode then M.msvc else M.gcc;
  (* Pick type for string literals *)
  stringLiteralType := if !theMachine.const_string_literals then
    charConstPtrType
  else
    charPtrType;
  (* Find the right ikind given the size *)
  let findIkind (unsigned: bool) (sz: int) : ikind =
    (* Test the most common sizes first *)
    if sz = !theMachine.sizeof_int then
      if unsigned then IUInt else IInt
    else if sz = !theMachine.sizeof_long then
      if unsigned then IULong else ILong
    else if sz = 1 then
      if unsigned then IUChar else IChar
    else if sz = !theMachine.sizeof_short then
      if unsigned then IUShort else IShort
    else if sz = !theMachine.sizeof_longlong then
      if unsigned then IULongLong else ILongLong
    else
      E.s(E.unimp "initCIL: cannot find the right ikind for size %d\n" sz)
  in
  upointType := TInt(findIkind true !theMachine.sizeof_ptr, []);
  kindOfSizeOf := findIkind true !theMachine.sizeof_size;
  typeOfSizeOf := TInt(!kindOfSizeOf, []);
  H.add gccBuiltins "__builtin_memset"
    (voidPtrType, [ voidPtrType; intType; intType ], false);
  wcharKind := findIkind false !theMachine.sizeof_wchar;
  wcharType := TInt(!wcharKind, []);
  char_is_unsigned := !theMachine.char_is_unsigned;
  little_endian := !theMachine.little_endian;
  nextGlobalVID := 1;
  nextCompinfoKey := 1


(* We want to bring all type declarations before the data declarations. This
 * is needed for code of the following form:

   int f(); // Prototype without arguments
   typedef int FOO;
   int f(FOO x) { ... }

   In CIL the prototype also lists the type of the argument as being FOO,
   which is undefined.

   There is one catch with this scheme. If the type contains an array whose
   length refers to variables then those variables must be declared before
   the type *)

let pullTypesForward = true


    (* Scan a type and collect the variables that are refered *)
class getVarsInGlobalClass (pacc: varinfo list ref) = object
  inherit nopCilVisitor
  method vvrbl (vi: varinfo) =
    pacc := vi :: !pacc;
    SkipChildren

  method vglob = function
      GType _ | GCompTag _ -> DoChildren
    | _ -> SkipChildren

end

let getVarsInGlobal (g : global) : varinfo list =
  let pacc : varinfo list ref = ref [] in
  let v : cilVisitor = new getVarsInGlobalClass pacc in
  ignore (visitCilGlobal v g);
  !pacc

let hasPrefix p s =
  let pl = String.length p in
  (String.length s >= pl) && String.sub s 0 pl = p

let pushGlobal (g: global)
               ~(types:global list ref)
               ~(variables: global list ref) =
  if not pullTypesForward then
    variables := g :: !variables
  else
    begin
      (* Collect a list of variables that are refered from the type. Return
       * Some if the global should go with the types and None if it should go
       * to the variables. *)
      let varsintype : (varinfo list * location) option =
        match g with
          GType (_, l) | GCompTag (_, l) -> Some (getVarsInGlobal g, l)
        | GEnumTag (_, l) | GPragma (Attr("pack", _), l)
        | GCompTagDecl (_, l) | GEnumTagDecl (_, l) -> Some ([], l)
          (** Move the warning pragmas early
        | GPragma(Attr(s, _), l) when hasPrefix "warning" s -> Some ([], l)
          *)
        | _ -> None (* Does not go with the types *)
      in
      match varsintype with
      None -> variables := g :: !variables
    | Some (vl, loc) ->
        types :=
           (* insert declarations for referred variables ('vl'), before
            * the type definition 'g' itself *)
           g :: (List.fold_left (fun acc v -> GVarDecl(v, loc) :: acc)
                                !types vl)
  end


type formatArg =
    Fe of exp
  | Feo of exp option  (** For array lengths *)
  | Fu of unop
  | Fb of binop
  | Fk of ikind
  | FE of exp list (** For arguments in a function call *)
  | Ff of (string * typ * attributes) (** For a formal argument *)
  | FF of (string * typ * attributes) list (* For formal argument lists *)
  | Fva of bool (** For the ellipsis in a function type *)
  | Fv of varinfo
  | Fl of lval
  | Flo of lval option (** For the result of a function call *)
  | Fo of offset
  | Fc of compinfo
  | Fi of instr
  | FI of instr list
  | Ft of typ
  | Fd of int
  | Fg of string
  | Fs of stmt
  | FS of stmt list
  | FA of attributes

  | Fp of attrparam
  | FP of attrparam list

  | FX of string

let d_formatarg () = function
    Fe e -> dprintf "Fe(%a)" d_exp e
  | Feo None -> dprintf "Feo(None)"
  | Feo (Some e) -> dprintf "Feo(%a)" d_exp e
  | FE _ -> dprintf "FE()"
  | Fk ik -> dprintf "Fk()"
  | Fva b -> dprintf "Fva(%b)" b
  | Ff (an, _, _) -> dprintf "Ff(%s)" an
  | FF _ -> dprintf "FF(...)"
  | FA _ -> dprintf "FA(...)"
  | Fu uo -> dprintf "Fu()"
  | Fb bo -> dprintf "Fb()"
  | Fv v -> dprintf "Fv(%s)" v.vname
  | Fl l -> dprintf "Fl(%a)" d_lval l
  | Flo None -> dprintf "Flo(None)"
  | Flo (Some l) -> dprintf "Flo(%a)" d_lval l
  | Fo o -> dprintf "Fo"
  | Fc ci -> dprintf "Fc(%s)" ci.cname
  | Fi i -> dprintf "Fi(...)"
  | FI i -> dprintf "FI(...)"
  | Ft t -> dprintf "Ft(%a)" d_type t
  | Fd n -> dprintf "Fd(%d)" n
  | Fg s -> dprintf "Fg(%s)" s
  | Fp _ -> dprintf "Fp(...)"
  | FP n -> dprintf "FP(...)"
  | Fs _ -> dprintf "FS"
  | FS _ -> dprintf "FS"

  | FX _ -> dprintf "FX()"



@h=tangler('src/compiler/cil/flx_cil_cil.mli')
@select(h)

(*
 * CIL: An intermediate language for analyzing C programs.
 *
 * George Necula
 *
 *)

(** CIL API Documentation. An html version of this document can be found at
 * http://manju.cs.berkeley.edu/cil. *)

(** Call this function to perform some initialization. Call if after you have
 * set {!Flx_cil_cil.msvcMode}.  *)
val initCIL: unit -> unit


(** This are the CIL version numbers. A CIL version is a number of the form
 * M.m.r (major, minor and release) *)
val cilVersion: string
val cilVersionMajor: int
val cilVersionMinor: int
val cilVersionRevision: int

(** This module defines the abstract syntax of CIL. It also provides utility
 * functions for traversing the CIL data structures, and pretty-printing
 * them. The parser for both the GCC and MSVC front-ends can be invoked as
 * [Flx_cil_frontc.parse: string -> unit ->] {!Flx_cil_cil.file}. This function must be given
 * the name of a preprocessed C file and will return the top-level data
 * structure that describes a whole source file. By default the parsing and
 * elaboration into CIL is done as for GCC source. If you want to use MSVC
 * source you must set the {!Flx_cil_cil.msvcMode} to [true] and must also invoke the
 * function [Flx_cil_frontc.setMSVCMode: unit -> unit]. *)


(** {b The Abstract Syntax of CIL} *)


(** The top-level representation of a CIL source file (and the result of the
 * parsing and elaboration). Its main contents is the list of global
 * declarations and definitions. You can iterate over the globals in a
 * {!Flx_cil_cil.file} using the following iterators: {!Flx_cil_cil.mapGlobals},
 * {!Flx_cil_cil.iterGlobals} and {!Flx_cil_cil.foldGlobals}. You can also use the
 * {!Flx_cil_cil.dummyFile} when you need a {!Flx_cil_cil.file} as a placeholder. For each
 * global item CIL stores the source location where it appears (using the
 * type {!Flx_cil_cil.location}) *)

type file =
    { mutable fileName: string;   (** The complete file name *)
      mutable globals: global list; (** List of globals as they will appear
                                        in the printed file *)
      mutable globinit: fundec option;
      (** An optional global initializer function. This is a function where
       * you can put stuff that must be executed before the program is
       * started. This function, is conceptually at the end of the file,
       * although it is not part of the globals list. Use {!Flx_cil_cil.getGlobInit}
       * to create/get one. *)
      mutable globinitcalled: bool;
      (** Whether the global initialization function is called in main. This
          should always be false if there is no global initializer. When
          you create a global initialization CIL will try to insert code in
          main to call it. *)
    }
(** Top-level representation of a C source file *)

(** {b Globals}. The main type for representing global declarations and
 * definitions. A list of these form a CIL file. The order of globals in the
 * file is generally important. *)

(** A global declaration or definition *)
and global =
  | GType of typeinfo * location
    (** A typedef. All uses of type names (through the [TNamed] constructor)
        must be preceded in the file by a definition of the name. The string
        is the defined name and always not-empty. *)

  | GCompTag of compinfo * location
    (** Defines a struct/union tag with some fields. There must be one of
        these for each struct/union tag that you use (through the [TComp]
        constructor) since this is the only context in which the fields are
        printed. Consequently nested structure tag definitions must be
        broken into individual definitions with the innermost structure
        defined first. *)

  | GCompTagDecl of compinfo * location
    (** Declares a struct/union tag. Use as a forward declaration. This is
      * printed without the fields.  *)

  | GEnumTag of enuminfo * location
   (** Declares an enumeration tag with some fields. There must be one of
      these for each enumeration tag that you use (through the [TEnum]
      constructor) since this is the only context in which the items are
      printed. *)

  | GEnumTagDecl of enuminfo * location
    (** Declares an enumeration tag. Use as a forward declaration. This is
      * printed without the items.  *)

  | GVarDecl of varinfo * location
   (** A variable declaration (not a definition). If the variable has a
       function type then this is a prototype. There can be several
       declarations and at most one definition for a given variable. If both
       forms appear then they must share the same varinfo structure. A
       prototype shares the varinfo with the fundec of the definition. Either
       has storage Extern or there must be a definition in this file *)

  | GVar  of varinfo * initinfo * location
     (** A variable definition. Can have an initializer. The initializer is
      * updateable so that you can change it without requiring to recreate
      * the list of globals. There can be at most one definition for a
      * variable in an entire program. Cannot have storage Extern or function
      * type. *)

  | GFun of fundec * location
     (** A function definition. *)

  | GAsm of string * location           (** Global asm statement. These ones
                                            can contain only a template *)
  | GPragma of attribute * location     (** Pragmas at top level. Use the same
                                            syntax as attributes *)
  | GText of string                     (** Some text (printed verbatim) at
                                            top level. E.g., this way you can
                                            put comments in the output.  *)

(** {b Types}. A C type is represented in CIL using the type {!Flx_cil_cil.typ}.
 * Among types we differentiate the integral types (with different kinds
 * denoting the sign and precision), floating point types, enumeration types,
 * array and pointer types, and function types. Every type is associated with
 * a list of attributes, which are always kept in sorted order. Use
 * {!Flx_cil_cil.addAttribute} and {!Flx_cil_cil.addAttributes} to construct list of
 * attributes. If you want to inspect a type, you should use
 * {!Flx_cil_cil.unrollType} or {!Flx_cil_cil.unrollTypeDeep} to see through the uses of
 * named types. *)
(** CIL is configured at build-time with the sizes and alignments of the
 * underlying compiler (GCC or MSVC). CIL contains functions that can compute
 * the size of a type (in bits) {!Flx_cil_cil.bitsSizeOf}, the alignment of a type
 * (in bytes) {!Flx_cil_cil.alignOf_int}, and can convert an offset into a start and
 * width (both in bits) using the function {!Flx_cil_cil.bitsOffset}. At the moment
 * these functions do not take into account the [packed] attributes and
 * pragmas. *)

and typ =
    TVoid of attributes   (** Void type. Also predefined as {!Flx_cil_cil.voidType} *)
  | TInt of ikind * attributes
     (** An integer type. The kind specifies the sign and width. Several
      * useful variants are predefined as {!Flx_cil_cil.intType}, {!Flx_cil_cil.uintType},
      * {!Flx_cil_cil.longType}, {!Flx_cil_cil.charType}. *)


  | TFloat of fkind * attributes
     (** A floating-point type. The kind specifies the precision. You can
      * also use the predefined constant {!Flx_cil_cil.doubleType}. *)

  | TPtr of typ * attributes
           (** Pointer type. Several useful variants are predefined as
            * {!Flx_cil_cil.charPtrType}, {!Flx_cil_cil.charConstPtrType} (pointer to a
            * constant character), {!Flx_cil_cil.voidPtrType},
            * {!Flx_cil_cil.intPtrType}  *)

  | TArray of typ * exp option * attributes
           (** Array type. It indicates the base type and the array length. *)

  | TFun of typ * (string * typ * attributes) list option * bool * attributes
          (** Function type. Indicates the type of the result, the name, type
           * and name attributes of the formal arguments ([None] if no
           * arguments were specified, as in a function whose definition or
           * prototype we have not seen; [Some \[\]] means void). Use
           * {!Flx_cil_cil.argsToList} to obtain a list of arguments. The boolean
           * indicates if it is a variable-argument function. If this is the
           * type of a varinfo for which we have a function declaration then
           * the information for the formals must match that in the
           * function's sformals. Use {!Flx_cil_cil.setFormals} or
           * {!Flx_cil_cil.setFunctionType} for this purpose. *)

  | TNamed of typeinfo * attributes
          (* The use of a named type. Each such type name must be preceded
           * in the file by a [GType] global. This is printed as just the
           * type name. The actual referred type is not printed here and is
           * carried only to simplify processing. To see through a sequence
           * of named type references, use {!Flx_cil_cil.unrollType} or
           * {!Flx_cil_cil.unrollTypeDeep}. The attributes are in addition to those
           * given when the type name was defined. *)

  | TComp of compinfo * attributes
(** The most delicate issue for C types is that recursion that is possible by
 * using structures and pointers. To address this issue we have a more
 * complex representation for structured types (struct and union). Each such
 * type is represented using the {!Flx_cil_cil.compinfo} type. For each composite
 * type the {!Flx_cil_cil.compinfo} structure must be declared at top level using
 * [GCompTag] and all references to it must share the same copy of the
 * structure. The attributes given are those pertaining to this use of the
 * type and are in addition to the attributes that were given at the
 * definition of the type and which are stored in the {!Flx_cil_cil.compinfo}. *)

  | TEnum of enuminfo * attributes
           (** A reference to an enumeration type. All such references must
               share the enuminfo among them and with a [GEnumTag] global that
               precedes all uses. The attributes refer to this use of the
               enumeration and are in addition to the attributes of the
               enumeration itself, which are stored inside the enuminfo  *)


  | TBuiltin_va_list of attributes
            (** This is the same as the gcc's type with the same name *)

(**
 There are a number of functions for querying the kind of a type. These are
 {!Flx_cil_cil.isIntegralType},
 {!Flx_cil_cil.isArithmeticType},
 {!Flx_cil_cil.isPointerType},
 {!Flx_cil_cil.isFunctionType},
 {!Flx_cil_cil.isArrayType}.

 There are two easy ways to scan a type. First, you can use the
{!Flx_cil_cil.existsType} to return a boolean answer about a type. This function
is controlled by a user-provided function that is queried for each type that is
used to construct the current type. The function can specify whether to
terminate the scan with a boolean result or to continue the scan for the
nested types.

 The other method for scanning types is provided by the visitor interface (see
 {!Flx_cil_cil.cilVisitor}).

 If you want to compare types (or to use them as hash-values) then you should
use instead type signatures (represented as {!Flx_cil_cil.typsig}). These
contain the same information as types but canonicalized such that simple Ocaml
structural equality will tell whether two types are equal. Use
{!Flx_cil_cil.typeSig} to compute the signature of a type. If you want to ignore
certain type attributes then use {!Flx_cil_cil.typeSigWithAttrs}.

*)


(** Various kinds of integers *)
and ikind =
    IBool       (** [_Bool] *)
  | IChar       (** [char] *)
  | ISChar      (** [signed char] *)
  | IUChar      (** [unsigned char] *)
  | IInt        (** [int] *)
  | IUInt       (** [unsigned int] *)
  | IShort      (** [short] *)
  | IUShort     (** [unsigned short] *)
  | ILong       (** [long] *)
  | IULong      (** [unsigned long] *)
  | ILongLong   (** [long long] (or [_int64] on Microsoft Visual C) *)
  | IULongLong  (** [unsigned long long] (or [unsigned _int64] on Microsoft
                    Visual C) *)

(** Various kinds of floating-point numbers*)
and fkind =
  | FFloat      (** [float] *)
  | FDouble     (** [double] *)
  | FLongDouble (** [long double] *)

  | CFloat      (** [float _Complex] *)
  | CDouble     (** [double _Complex] *)
  | CLongDouble (** [long double _Complex] *)

  | IFloat      (** [float _Imaginary] *)
  | IDouble     (** [double _Imaginary] *)
  | ILongDouble (** [long double _Imaginary] *)


(** {b Attributes.} *)

and attribute = Attr of string * attrparam list
(** An attribute has a name and some optional parameters. The name should not
 * start or end with underscore. When CIL parses attribute names it will
 * strip leading and ending underscores (to ensure that the multitude of GCC
 * attributes such as const, __const and __const__ all mean the same thing.) *)

(** Attributes are lists sorted by the attribute name. Use the functions
 * {!Flx_cil_cil.addAttribute} and {!Flx_cil_cil.addAttributes} to insert attributes in an
 * attribute list and maintain the sortedness. *)
and attributes = attribute list

(** The type of parameters of attributes *)
and attrparam =
  | AInt of int                          (** An integer constant *)
  | AStr of string                       (** A string constant *)
  | ACons of string * attrparam list       (** Constructed attributes. These
                                             are printed [foo(a1,a2,...,an)].
                                             The list of parameters can be
                                             empty and in that case the
                                             parentheses are not printed. *)
  | ASizeOf of typ                       (** A way to talk about types *)
  | ASizeOfE of attrparam
  | AAlignOf of typ
  | AAlignOfE of attrparam
  | AUnOp of unop * attrparam
  | ABinOp of binop * attrparam * attrparam
  | ADot of attrparam * string           (** a.foo **)

(** {b Structures.} The {!Flx_cil_cil.compinfo} describes the definition of a
 * structure or union type. Each such {!Flx_cil_cil.compinfo} must be defined at the
 * top-level using the [GCompTag] constructor and must be shared by all
 * references to this type (using either the [TComp] type constructor or from
 * the definition of the fields.

   If all you need is to scan the definition of each
 * composite type once, you can do that by scanning all top-level [GCompTag].

 * Constructing a {!Flx_cil_cil.compinfo} can be tricky since it must contain fields
 * that might refer to the host {!Flx_cil_cil.compinfo} and furthermore the type of
 * the field might need to refer to the {!Flx_cil_cil.compinfo} for recursive types.
 * Use the {!Flx_cil_cil.mkCompInfo} function to create a {!Flx_cil_cil.compinfo}. You can
 * easily fetch the {!Flx_cil_cil.fieldinfo} for a given field in a structure with
 * {!Flx_cil_cil.getCompField}. *)

(** The definition of a structure or union type. Use {!Flx_cil_cil.mkCompInfo} to
 * make one and use {!Flx_cil_cil.copyCompInfo} to copy one (this ensures that a new
 * key is assigned and that the fields have the right pointers to parents.). *)
and compinfo = {
    mutable cstruct: bool;
   (** True if struct, False if union *)
    mutable cname: string;
   (** The name. Always non-empty. Use {!Flx_cil_cil.compFullName} to get the full
    * name of a comp (along with the struct or union) *)
    mutable ckey: int;
    (** A unique integer. This is assigned by {!Flx_cil_cil.mkCompInfo} using a
     * global variable in the Flx_cil_cil module. Thus two identical structs in two
     * different files might have different keys. Use {!Flx_cil_cil.copyCompInfo} to
     * copy structures so that a new key is assigned. *)
    mutable cfields: fieldinfo list;
    (** Information about the fields. Notice that each fieldinfo has a
      * pointer back to the host compinfo. This means that you should not
      * share fieldinfo's between two compinfo's *)
    mutable cattr:   attributes;
    (** The attributes that are defined at the same time as the composite
     * type. These attributes can be supplemented individually at each
     * reference to this [compinfo] using the [TComp] type constructor. *)
    mutable cdefined: bool;
    (** This boolean flag can be used to distinguish between structures
     that have not been defined and those that have been defined but have
     no fields (such things are allowed in gcc). *)
    mutable creferenced: bool;
    (** True if used. Initially set to false. *)
  }

(** {b Structure fields.} The {!Flx_cil_cil.fieldinfo} structure is used to describe
 * a structure or union field. Fields, just like variables, can have
 * attributes associated with the field itself or associated with the type of
 * the field (stored along with the type of the field). *)

(** Information about a struct/union field *)
and fieldinfo = {
    mutable fcomp: compinfo;
     (** The host structure that contains this field. There can be only one
      * [compinfo] that contains the field. *)
    mutable fname: string;
    (** The name of the field. Might be the value of {!Flx_cil_cil.missingFieldName}
     * in which case it must be a bitfield and is not printed and it does not
     * participate in initialization *)
    mutable ftype: typ;
    (** The type *)
    mutable fbitfield: int option;
    (** If a bitfield then ftype should be an integer type and the width of
     * the bitfield must be 0 or a positive integer smaller or equal to the
     * width of the integer type. A field of width 0 is used in C to control
     * the alignment of fields. *)
    mutable fattr: attributes;
    (** The attributes for this field (not for its type) *)
    mutable floc: location;
    (** The location where this field is defined *)
    mutable fstorage: storage;
    (** Must be NoStorage or Static,
      * indicates nonstatic or static member *)
}



(** {b Enumerations.} Information about an enumeration. This is shared by all
 * references to an enumeration. Make sure you have a [GEnumTag] for each of
 * of these. *)

(** Information about an enumeration *)
and enuminfo = {
    mutable ename: string;
    (** The name. Always non-empty. *)
    mutable eitems: (string * exp * location) list;
    (** Items with names and values. This list should be non-empty. The item
     * values must be compile-time constants. *)
    mutable eattr: attributes;
    (** The attributes that are defined at the same time as the enumeration
     * type. These attributes can be supplemented individually at each
     * reference to this [enuminfo] using the [TEnum] type constructor. *)
    mutable ereferenced: bool;
    (** True if used. Initially set to false*)
}

(** {b Enumerations.} Information about an enumeration. This is shared by all
 * references to an enumeration. Make sure you have a [GEnumTag] for each of
 * of these. *)

(** Information about a defined type *)
and typeinfo = {
    mutable tname: string;
    (** The name. Can be empty only in a [GType] when introducing a composite
     * or enumeration tag. If empty cannot be referred to from the file *)
    mutable ttype: typ;
    (** The actual type. This includes the attributes that were present in
     * the typedef *)
    mutable treferenced: bool;
    (** True if used. Initially set to false*)
}

(** {b Variables.}
 Each local or global variable is represented by a unique {!Flx_cil_cil.varinfo}
structure. A global {!Flx_cil_cil.varinfo} can be introduced with the [GVarDecl] or
[GVar] or [GFun] globals. A local varinfo can be introduced as part of a
function definition {!Flx_cil_cil.fundec}.

 All references to a given global or local variable must refer to the same
copy of the [varinfo]. Each [varinfo] has a globally unique identifier that
can be used to index maps and hashtables (the name can also be used for this
purpose, except for locals from different functions). This identifier is
constructor using a global counter.

 It is very important that you construct [varinfo] structures using only one
 of the following functions:
- {!Flx_cil_cil.makeGlobalVar} : to make a global variable
- {!Flx_cil_cil.makeTempVar} : to make a temporary local variable whose name
will be generated so that to avoid conflict with other locals.
- {!Flx_cil_cil.makeLocalVar} : like {!Flx_cil_cil.makeTempVar} but you can specify the
exact name to be used.
- {!Flx_cil_cil.copyVarinfo}: make a shallow copy of a varinfo assigning a new name
and a new unique identifier

 A [varinfo] is also used in a function type to denote the list of formals.

*)

(** Information about a variable. *)
and varinfo = {
    mutable vname: string;
    (** The name of the variable. Cannot be empty. It is primarily your
     * responsibility to ensure the uniqueness of a variable name. For local
     * variables {!Flx_cil_cil.makeTempVar} helps you ensure that the name is unique.
     *)

    mutable vtype: typ;
    (** The declared type of the variable. *)

    mutable vattr: attributes;
    (** A list of attributes associated with the variable.*)
    mutable vstorage: storage;
    (** The storage-class *)

    mutable vglob: bool;
    (** True if this is a global variable*)

    mutable vinline: bool;
    (** Whether this varinfo is for an inline function. *)

    mutable vdecl: location;
    (** Location of variable declaration. *)

    mutable vid: int;
    (** A unique integer identifier. This field will be
     * set for you if you use one of the {!Flx_cil_cil.makeFormalVar},
     * {!Flx_cil_cil.makeLocalVar}, {!Flx_cil_cil.makeTempVar}, {!Flx_cil_cil.makeGlobalVar}, or
     * {!Flx_cil_cil.copyVarinfo}. *)

    mutable vaddrof: bool;
    (** True if the address of this variable is taken. CIL will set these
     * flags when it parses C, but you should make sure to set the flag
     * whenever your transformation create [AddrOf] expression. *)

    mutable vreferenced: bool;
    (** True if this variable is ever referenced. This is computed by
     * [removeUnusedVars]. It is safe to just initialize this to False *)
}

(** Storage-class information *)
and storage =
    | NoStorage                          (** The default storage. Nothing is
                                         * printed  *)
    | Static
    | Register
    | Extern


(** {b Expressions.} The CIL expression language contains only the side-effect free expressions of
C. They are represented as the type {!Flx_cil_cil.exp}. There are several
interesting aspects of CIL expressions:

 Integer and floating point constants can carry their textual representation.
This way the integer 15 can be printed as 0xF if that is how it occurred in the
source.

 CIL uses 64 bits to represent the integer constants and also stores the width
of the integer type. Care must be taken to ensure that the constant is
representable with the given width. Use the functions {!Flx_cil_cil.kinteger},
{!Flx_cil_cil.kinteger64} and {!Flx_cil_cil.integer} to construct constant
expressions. CIL predefines the constants {!Flx_cil_cil.zero},
{!Flx_cil_cil.one} and {!Flx_cil_cil.mone} (for -1).

 Use the functions {!Flx_cil_cil.isConstant} and {!Flx_cil_cil.isInteger} to test if
an expression is a constant and a constant integer respectively.

 CIL keeps the type of all unary and binary expressions. You can think of that
type qualifying the operator. Furthermore there are different operators for
arithmetic and comparisons on arithmetic types and on pointers.

 Another unusual aspect of CIL is that the implicit conversion between an
expression of array type and one of pointer type is made explicit, using the
[StartOf] expression constructor (which is not printed). If you apply the
[AddrOf}]constructor to an lvalue of type [T] then you will be getting an
expression of type [TPtr(T)].

 You can find the type of an expression with {!Flx_cil_cil.typeOf}.

 You can perform constant folding on expressions using the function
{!Flx_cil_cil.constFold}.
*)

(** Expressions (Side-effect free)*)
and exp =
    Const      of constant              (** Constant *)
  | Lval       of lval                  (** Lvalue *)
  | SizeOf     of typ
    (** sizeof(<type>). Has [unsigned int] type (ISO 6.5.3.4). This is not
     * turned into a constant because some transformations might want to
     * change types *)

  | SizeOfE    of exp
    (** sizeof(<expression>) *)

  | SizeOfStr  of string
    (** sizeof(string_literal). We separate this case out because this is the
      * only instance in which a string literal should not be treated as
      * having type pointer to character. *)

  | AlignOf    of typ
    (** This corresponds to the GCC __alignof_. Has [unsigned int] type *)
  | AlignOfE   of exp


  | UnOp       of unop * exp * typ
    (** Unary operation. Includes the type of the result. *)

  | BinOp      of binop * exp * exp * typ
    (** Binary operation. Includes the type of the result. The arithmetic
     * conversions are made explicit for the arguments. *)

  | CastE      of typ * exp
    (** Use {!Flx_cil_cil.mkCast} to make casts.  *)

  | AddrOf     of lval
    (** Always use {!Flx_cil_cil.mkAddrOf} to construct one of these. Apply to an
     * lvalue of type [T] yields an expression of type [TPtr(T)] *)

  | StartOf    of lval
    (** Conversion from an array to a pointer to the beginning of the array.
     * Given an lval of type [TArray(T)] produces an expression of type
     * [TPtr(T)]. In C this operation is implicit, the [StartOf] operator is
     * not printed. We have it in CIL because it makes the typing rules
     * simpler. *)

(** {b Constants.} *)

(** Literal constants *)
and constant =
  | CInt64 of int64 * ikind * string option
    (** Integer constant. Give the ikind (see ISO9899 6.1.3.2) and the
     * textual representation, if available. (This allows us to print a
     * constant as, for example, 0xF instead of 15.) Use {!Flx_cil_cil.integer} or
     * {!Flx_cil_cil.kinteger} to create these. Watch out for integers that cannot be
     * represented on 64 bits. OCAML does not give Overflow exceptions. *)
  | CStr of string
    (* String constant. The escape characters inside the string have been
     * already interpreted. This constant has pointer to character type! The
     * only case when you would like a string literal to have an array type
     * is when it is an argument to sizeof. In that case you should use
     * SizeOfStr. *)
  | CWStr of int64 list
    (* Wide character string constant. Note that the local interpretation
     * of such a literal depends on {!Flx_cil_cil.wcharType} and {!Flx_cil_cil.wcharKind}.
     * Such a constant has type pointer to {!Flx_cil_cil.wcharType}. The
     * escape characters in the string have not been "interpreted" in
     * the sense that L"A\xabcd" remains "A\xabcd" rather than being
     * represented as the wide character list with two elements: 65 and
     * 43981. That "interpretation" depends on the underlying wide
     * character type. *)
  | CChr of char
    (** Character constant *)
  | CReal of float * fkind * string option
     (** Floating point constant. Give the fkind (see ISO 6.4.4.2) and also
      * the textual representation, if available. *)

(** Unary operators *)
and unop =
    Neg                                 (** Unary minus *)
  | BNot                                (** Bitwise complement (~) *)
  | LNot                                (** Logical Not (!) *)

(** Binary operations *)
and binop =
    PlusA                               (** arithmetic + *)
  | PlusPI                              (** pointer + integer *)
  | IndexPI                             (** pointer + integer but only when
                                         * it arises from an expression
                                         * [e\[i\]] when [e] is a pointer and
                                         * not an array. This is semantically
                                         * the same as PlusPI but CCured uses
                                         * this as a hint that the integer is
                                         * probably positive. *)
  | MinusA                              (** arithmetic - *)
  | MinusPI                             (** pointer - integer *)
  | MinusPP                             (** pointer - pointer *)
  | Mult                                (** * *)
  | Div                                 (** / *)
  | Mod                                 (** % *)
  | Shiftlt                             (** shift left *)
  | Shiftrt                             (** shift right *)

  | Lt                                  (** <  (arithmetic comparison) *)
  | Gt                                  (** >  (arithmetic comparison) *)
  | Le                                  (** <= (arithmetic comparison) *)
  | Ge                                  (** >  (arithmetic comparison) *)
  | Eq                                  (** == (arithmetic comparison) *)
  | Ne                                  (** != (arithmetic comparison) *)
  | BAnd                                (** bitwise and *)
  | BXor                                (** exclusive-or *)
  | BOr                                 (** inclusive-or *)

  | LAnd                                (** logical and. Unlike other
                                         * expressions this one does not
                                         * always evaluate both operands. If
                                         * you want to use these, you must
                                         * set {!Flx_cil_cil.useLogicalOperators}. *)
  | LOr                                 (** logical or. Unlike other
                                         * expressions this one does not
                                         * always evaluate both operands.  If
                                         * you want to use these, you must
                                         * set {!Flx_cil_cil.useLogicalOperators}. *)

(** {b Lvalues.} Lvalues are the sublanguage of expressions that can appear at the left of an assignment or as operand to the address-of operator.
In C the syntax for lvalues is not always a good indication of the meaning
of the lvalue. For example the C value
{v
a[0][1][2]
 v}
 might involve 1, 2 or 3 memory reads when used in an expression context,
depending on the declared type of the variable [a]. If [a] has type [int
\[4\]\[4\]\[4\]] then we have one memory read from somewhere inside the area
that stores the array [a]. On the other hand if [a] has type [int ***] then
the expression really means [* ( * ( * (a + 0) + 1) + 2)], in which case it is
clear that it involves three separate memory operations.

An lvalue denotes the contents of a range of memory addresses. This range
is denoted as a host object along with an offset within the object. The
host object can be of two kinds: a local or global variable, or an object
whose address is in a pointer expression. We distinguish the two cases so
that we can tell quickly whether we are accessing some component of a
variable directly or we are accessing a memory location through a pointer.
To make it easy to
tell what an lvalue means CIL represents lvalues as a host object and an
offset (see {!Flx_cil_cil.lval}). The host object (represented as
{!Flx_cil_cil.lhost}) can be a local or global variable or can be the object
pointed-to by a pointer expression. The offset (represented as
{!Flx_cil_cil.offset}) is a sequence of field or array index designators.

 Both the typing rules and the meaning of an lvalue is very precisely
specified in CIL.

 The following are a few useful function for operating on lvalues:
- {!Flx_cil_cil.mkMem} - makes an lvalue of [Mem] kind. Use this to ensure
that certain equivalent forms of lvalues are canonized.
For example, [*&x = x].
- {!Flx_cil_cil.typeOfLval} - the type of an lvalue
- {!Flx_cil_cil.typeOffset} - the type of an offset, given the type of the
host.
- {!Flx_cil_cil.addOffset} and {!Flx_cil_cil.addOffsetLval} - extend sequences
of offsets.
- {!Flx_cil_cil.removeOffset} and {!Flx_cil_cil.removeOffsetLval} - shrink sequences
of offsets.

The following equivalences hold {v
Mem(AddrOf(Mem a, aoff)), off   = Mem a, aoff + off
Mem(AddrOf(Var v, aoff)), off   = Var v, aoff + off
AddrOf (Mem a, NoOffset)        = a
 v}

*)
(** An lvalue *)
and lval =
    lhost * offset

(** The host part of an {!Flx_cil_cil.lval}. *)
and lhost =
  | Var        of varinfo
    (** The host is a variable. *)

  | Mem        of exp
    (** The host is an object of type [T] when the expression has pointer
     * [TPtr(T)]. *)


(** The offset part of an {!Flx_cil_cil.lval}. Each offset can be applied to certain
  * kinds of lvalues and its effect is that it advances the starting address
  * of the lvalue and changes the denoted type, essentially focusing to some
  * smaller lvalue that is contained in the original one. *)
and offset =
  | NoOffset          (** No offset. Can be applied to any lvalue and does
                        * not change either the starting address or the type.
                        * This is used when the lval consists of just a host
                        * or as a terminator in a list of other kinds of
                        * offsets. *)

  | Field      of fieldinfo * offset
                      (** A field offset. Can be applied only to an lvalue
                       * that denotes a structure or a union that contains
                       * the mentioned field. This advances the offset to the
                       * beginning of the mentioned field and changes the
                       * type to the type of the mentioned field. *)

  | Index    of exp * offset
                     (** An array index offset. Can be applied only to an
                       * lvalue that denotes an array. This advances the
                       * starting address of the lval to the beginning of the
                       * mentioned array element and changes the denoted type
                       * to be the type of the array element *)


(** {b Initializers.}
A special kind of expressions are those that can appear as initializers for
global variables (initialization of local variables is turned into
assignments). The initializers are represented as type {!Flx_cil_cil.init}. You
can create initializers with {!Flx_cil_cil.makeZeroInit} and you can conveniently
scan compound initializers them with {!Flx_cil_cil.foldLeftCompound} or with {!Flx_cil_cil.foldLeftCompoundAll}.
*)
(** Initializers for global variables. *)
and init =
  | SingleInit   of exp   (** A single initializer *)
  | CompoundInit   of typ * (offset * init) list
    (** Used only for initializers of structures, unions and arrays. The
     * offsets are all of the form [Field(f, NoOffset)] or [Index(i,
     * NoOffset)] and specify the field or the index being initialized. For
     * structures all fields must have an initializer (except the unnamed
     * bitfields), in the proper order. This is necessary since the offsets
     * are not printed. For unions there must be exactly one initializer. If
     * the initializer is not for the first field then a field designator is
     * printed, so you better be on GCC since MSVC does not understand this.
     * For arrays, however, we allow you to give only a prefix of the
     * initializers. You can scan an initializer list with
     * {!Flx_cil_cil.foldLeftCompound} or with {!Flx_cil_cil.foldLeftCompoundAll}. *)


(** We want to be able to update an initializer in a global variable, so we
 * define it as a mutable field *)
and initinfo = {
    mutable init : init option;
  }

(** {b Function definitions.}
A function definition is always introduced with a [GFun] constructor at the
top level. All the information about the function is stored into a
{!Flx_cil_cil.fundec}. Some of the information (e.g. its name, type,
storage, attributes) is stored as a {!Flx_cil_cil.varinfo} that is a field of the
[fundec]. To refer to the function from the expression language you must use
the [varinfo].

 The function definition contains, in addition to the body, a list of all the
local variables and separately a list of the formals. Both kind of variables
can be referred to in the body of the function. The formals must also be shared
with the formals that appear in the function type. For that reason, to
manipulate formals you should use the provided functions
{!Flx_cil_cil.makeFormalVar} and {!Flx_cil_cil.setFormals}.
*)
(** Function definitions. *)
and fundec =
    { mutable svar:     varinfo;
         (** Holds the name and type as a variable, so we can refer to it
          * easily from the program. All references to this function either
          * in a function call or in a prototype must point to the same
          * [varinfo]. *)
      mutable sformals: varinfo list;
        (** Formals. These must be in the same order and with the same
         * information as the formal information in the type of the function.
         * Use {!Flx_cil_cil.setFormals} or
         * {!Flx_cil_cil.setFunctionType} to set these formals and ensure that they
         * are reflected in the function type. Do not make copies of these
         * because the body refers to them. *)
      mutable slocals: varinfo list;
        (** Locals. Does NOT include the sformals. Do not make copies of
         * these because the body refers to them. *)
      mutable smaxid: int;           (** Max local id. Starts at 0. Used for
                                      * creating the names of new temporary
                                      * variables. Updated by
                                      * {!Flx_cil_cil.makeLocalVar} and
                                      * {!Flx_cil_cil.makeTempVar}. You can also use
                                      * {!Flx_cil_cil.setMaxId} to set it after you
                                      * have added the formals and locals. *)
      mutable sbody: block;          (** The function body. *)
      mutable smaxstmtid: int option;  (** max id of a (reachable) statement
                                        * in this function, if we have
                                        * computed it. range = 0 ...
                                        * (smaxstmtid-1) *)
    }


(** A block is a sequence of statements with the control falling through from
    one element to the next *)
and block =
   { mutable battrs: attributes;      (** Attributes for the block *)
     mutable bstmts: stmt list;       (** The statements comprising the block*)
   }


(** {b Statements}.
CIL statements are the structural elements that make the CFG. They are
represented using the type {!Flx_cil_cil.stmt}. Every
statement has a (possibly empty) list of labels. The
{!Flx_cil_cil.stmtkind} field of a statement indicates what kind of statement it
is.

 Use {!Flx_cil_cil.mkStmt} to make a statement and the fill-in the fields.

CIL also comes with support for control-flow graphs. The [sid] field in
[stmt] can be used to give unique numbers to statements, and the [succs]
and [preds] fields can be used to maintain a list of successors and
predecessors for every statement. The CFG information is not computed by
default. Instead you must explicitly use the functions
{!Flx_cil_cil.prepareCFG} and {!Flx_cil_cil.computeCFGInfo} to do it.

*)
(** Statements. *)
and stmt = {
    mutable labels: label list;
    (** Whether the statement starts with some labels, case statements or
     * default statements. *)

    mutable skind: stmtkind;
    (** The kind of statement *)

    mutable sid: int;
    (** A number (>= 0) that is unique in a function. Filled in only after
     * the CFG is computed. *)
    mutable succs: stmt list;
    (** The successor statements. They can always be computed from the skind
     * and the context in which this statement appears. Filled in only after
     * the CFG is computed. *)
    mutable preds: stmt list;
    (** The inverse of the succs function. *)
  }

(** Labels *)
and label =
    Label of string * location * bool
          (** A real label. If the bool is "true", the label is from the
           * input source program. If the bool is "false", the label was
           * created by CIL or some other transformation *)
  | Case of exp * location              (** A case statement *)
  | Default of location                 (** A default statement *)



(** The various kinds of control-flow statements statements *)
and stmtkind =
  | Instr  of instr list
  (** A group of instructions that do not contain control flow. Control
   * implicitly falls through. *)

  | Return of exp option * location
   (** The return statement. This is a leaf in the CFG. *)

  | Goto of stmt ref * location
   (** A goto statement. Appears from actual goto's in the code or from
    * goto's that have been inserted during elaboration. The reference
    * points to the statement that is the target of the Goto. This means that
    * you have to update the reference whenever you replace the target
    * statement. The target statement MUST have at least a label. *)

  | Break of location
   (** A break to the end of the nearest enclosing Loop or Switch *)

  | Continue of location
   (** A continue to the start of the nearest enclosing [Loop] *)
  | If of exp * block * block * location
   (** A conditional. Two successors, the "then" and the "else" branches.
    * Both branches fall-through to the successor of the If statement. *)

  | Switch of exp * block * (stmt list) * location
   (** A switch statement. The statements that implement the cases can be
    * reached through the provided list. For each such target you can find
    * among its labels what cases it implements. The statements that
    * implement the cases are somewhere within the provided [block]. *)

  | Loop of block * location * (stmt option) * (stmt option)
    (** A [while(1)] loop. The termination test is implemented in the body of
     * a loop using a [Break] statement. If prepareCFG has been called,
     * the first stmt option will point to the stmt containing the continue
     * label for this loop and the second will point to the stmt containing
     * the break label for this loop. *)

  | Block of block
    (** Just a block of statements. Use it as a way to keep some block
     * attributes local *)

    (** On MSVC we support structured exception handling. This is what you
     * might expect. Control can get into the finally block either from the
     * end of the body block, or if an exception is thrown. *)
  | TryFinally of block * block * location

    (** On MSVC we support structured exception handling. The try/except
     * statement is a bit tricky:
         [__try { blk }
         __except (e) {
            handler
         }]

         The argument to __except  must be an expression. However, we keep a
         list of instructions AND an expression in case you need to make
         function calls. We'll print those as a comma expression. The control
         can get to the __except expression only if an exception is thrown.
         After that, depending on the value of the expression the control
         goes to the handler, propagates the exception, or retries the
         exception !!!
     *)
  | TryExcept of block * (instr list * exp) * block * location


(** {b Instructions}.
 An instruction {!Flx_cil_cil.instr} is a statement that has no local
(intraprocedural) control flow. It can be either an assignment,
function call, or an inline assembly instruction. *)

(** Instructions. *)
and instr =
    Set        of lval * exp * location
   (** An assignment. The type of the expression is guaranteed to be the same
    * with that of the lvalue *)
  | Call       of lval option * exp * exp list * location
   (** A function call with the (optional) result placed in an lval. It is
    * possible that the returned type of the function is not identical to
    * that of the lvalue. In that case a cast is printed. The type of the
    * actual arguments are identical to those of the declared formals. The
    * number of arguments is the same as that of the declared formals, except
    * for vararg functions. This construct is also used to encode a call to
    * "__builtin_va_arg". In this case the second argument (which should be a
    * type T) is encoded SizeOf(T) *)

  | Asm        of attributes * (* Really only const and volatile can appear
                               * here *)
                  string list *         (* templates (CR-separated) *)
                  (string * lval) list * (* outputs must be lvals with
                                          * constraints. I would like these
                                          * to be actually variables, but I
                                          * run into some trouble with ASMs
                                          * in the Linux sources  *)
                  (string * exp) list * (* inputs with constraints *)
                  string list *         (* register clobbers *)
                  location
    (** There are for storing inline assembly. They follow the GCC
      * specification:
{v
  asm [volatile] ("...template..." "..template.."
                  : "c1" (o1), "c2" (o2), ..., "cN" (oN)
                  : "d1" (i1), "d2" (i2), ..., "dM" (iM)
                  : "r1", "r2", ..., "nL" );
 v}

where the parts are

  - [volatile] (optional): when present, the assembler instruction
    cannot be removed, moved, or otherwise optimized
  - template: a sequence of strings, with %0, %1, %2, etc. in the string to
    refer to the input and output expressions. I think they're numbered
    consecutively, but the docs don't specify. Each string is printed on
    a separate line. This is the only part that is present for MSVC inline
    assembly.
  - "ci" (oi): pairs of constraint-string and output-lval; the
    constraint specifies that the register used must have some
    property, like being a floating-point register; the constraint
    string for outputs also has "=" to indicate it is written, or
    "+" to indicate it is both read and written; 'oi' is the
    name of a C lvalue (probably a variable name) to be used as
    the output destination
  - "dj" (ij): pairs of constraint and input expression; the constraint
    is similar to the "ci"s.  the 'ij' is an arbitrary C expression
    to be loaded into the corresponding register
  - "rk": registers to be regarded as "clobbered" by the instruction;
    "memory" may be specified for arbitrary memory effects

an example (from gcc manual):
{v
  asm volatile ("movc3 %0,%1,%2"
                : /* no outputs */
                : "g" (from), "g" (to), "g" (count)
                : "r0", "r1", "r2", "r3", "r4", "r5");
 v}
*)

(** Describes a location in a source file *)
and location = {
    line: int;             (** The line number. -1 means "do not know" *)
    file: string;          (** The name of the source file*)
    byte: int;             (** The byte position in the source file *)
}



(** To be able to add/remove features easily, each feature should be package
   * as an interface with the following interface. These features should be *)
type featureDescr = {
    fd_enabled: bool ref;
    (** The enable flag. Set to default value  *)

    fd_name: string;
    (** This is used to construct an option "--doxxx" and "--dontxxx" that
     * enable and disable the feature  *)

    fd_description: string;
    (* A longer name that can be used to document the new options  *)

    fd_extraopt: (string * Arg.spec * string) list;
    (** Additional command line options *)

    fd_doit: (file -> unit);
    (** This performs the transformation *)

    fd_post_check: bool;
    (* Whether to perform a CIL consistency checking after this stage, if
     * checking is enabled (--check is passed to cilly). Set this to true if
     * your feature makes any changes for the program. *)
}

(** Comparison function for locations.
 ** Compares first by filename, then line, then byte *)
val compareLoc: location -> location -> int

(** {b Values for manipulating globals} *)

(** Make an empty function *)
val emptyFunction: string -> fundec

(** Update the formals of a [fundec] and make sure that the function type
    has the same information. Will copy the name as well into the type. *)
val setFormals: fundec -> varinfo list -> unit

(** Set the types of arguments and results as given by the function type
 * passed as the second argument. Will not copy the names from the function
 * type to the formals *)
val setFunctionType: fundec -> typ -> unit

(** Update the smaxid after you have populated with locals and formals
 * (unless you constructed those using {!Flx_cil_cil.makeLocalVar} or
 * {!Flx_cil_cil.makeTempVar}. *)
val setMaxId: fundec -> unit

(** A dummy function declaration handy when you need one as a placeholder. It
 * contains inside a dummy varinfo. *)
val dummyFunDec: fundec

(** A dummy file *)
val dummyFile: file

(** Write a {!Flx_cil_cil.file} in binary form to the filesystem. The file can be
 * read back in later using {!Flx_cil_cil.loadBinaryFile}, possibly saving parsing
 * time. The second argument is the name of the file that should be
 * created. *)
val saveBinaryFile : file -> string -> unit

(** Write a {!Flx_cil_cil.file} in binary form to the filesystem. The file can be
 * read back in later using {!Flx_cil_cil.loadBinaryFile}, possibly saving parsing
 * time. Does not close the channel. *)
val saveBinaryFileChannel : file -> out_channel -> unit

(** Read a {!Flx_cil_cil.file} in binary form from the filesystem. The first
 * argument is the name of a file previously created by
 * {!Flx_cil_cil.saveBinaryFile}. *)
val loadBinaryFile : string -> file

(** Get the global initializer and create one if it does not already exist.
 * When it creates a global initializer it attempts to place a call to it in
 * the main function named by the optional argument (default "main")  *)
val getGlobInit: ?main_name:string -> file -> fundec

(** Iterate over all globals, including the global initializer *)
val iterGlobals: file -> (global -> unit) -> unit

(** Fold over all globals, including the global initializer *)
val foldGlobals: file -> ('a -> global -> 'a) -> 'a -> 'a

(** Map over all globals, including the global initializer and change things
    in place *)
val mapGlobals: file -> (global -> global) -> unit

(** Prepare a function for CFG information computation by
  * {!Flx_cil_cil.computeCFGInfo}. This function converts all [Break], [Switch],
  * [Default] and [Continue] {!Flx_cil_cil.stmtkind}s and {!Flx_cil_cil.label}s into [If]s
  * and [Goto]s, giving the function body a very CFG-like character. This
  * function modifies its argument in place. *)
val prepareCFG: fundec -> unit

(** Compute the CFG information for all statements in a fundec and return a
  * list of the statements. The input fundec cannot have [Break], [Switch],
  * [Default], or [Continue] {!Flx_cil_cil.stmtkind}s or {!Flx_cil_cil.label}s. Use
  * {!Flx_cil_cil.prepareCFG} to transform them away.  The second argument should
  * be [true] if you wish a global statement number, [false] if you wish a
  * local (per-function) statement numbering. *)
val computeCFGInfo: fundec -> bool -> stmt list


(** Create a deep copy of a function. There should be no sharing between the
 * copy and the original function *)
val copyFunction: fundec -> string -> fundec


(** CIL keeps the types at the beginning of the file and the variables at the
 * end of the file. This function will take a global and add it to the
 * corresponding stack. Its operation is actually more complicated because if
 * the global declares a type that contains references to variables (e.g. in
 * sizeof in an array length) then it will also add declarations for the
 * variables to the types stack *)
val pushGlobal: global -> types: global list ref
                       -> variables: global list ref -> unit

(** A list of the GCC built-in functions. Maps the name to the result and
  * argument types, and whether it is vararg *)
val gccBuiltins: (string, typ * typ list * bool) Hashtbl.t


(** A list of the MSVC built-in functions. Maps the name to the result and
 * argument types, and whether it is vararg *)
val msvcBuiltins: (string, typ * typ list * bool) Hashtbl.t

(** {b Values for manipulating initializers} *)


(** Make a initializer for zero-ing a data type *)
val makeZeroInit: typ -> init


(** Fold over the list of initializers in a Compound. [doinit] is called on
 * every present initializer, even if it is of compound type. In the case of
 * arrays there might be missing zero-initializers at the end of the list.
 * These are not scanned. This is much like [List.fold_left] except we also
 * pass the type of the initializer *)
val foldLeftCompound:
    doinit: (offset -> init -> typ -> 'a -> 'a) ->
    ct: typ ->
    initl: (offset * init) list ->
    acc: 'a -> 'a


(** Fold over the list of initializers in a Compound, like
 * {!Flx_cil_cil.foldLeftCompound} but in the case of an array it scans even missing
 * zero initializers at the end of the array *)
val foldLeftCompoundAll:
    doinit: (offset -> init -> typ -> 'a -> 'a) ->
    ct: typ ->
    initl: (offset * init) list ->
    acc: 'a -> 'a



(** {b Values for manipulating types} *)

(** void *)
val voidType: typ

(* is the given type "void"? *)
val isVoidType: typ -> bool

(* is the given type "void *"? *)
val isVoidPtrType: typ -> bool

(** int *)
val intType: typ

(** unsigned int *)
val uintType: typ

(** long *)
val longType: typ

(** unsigned long *)
val ulongType: typ

(** char *)
val charType: typ

(** char * *)
val charPtrType: typ

(** wchar_t (depends on architecture) and is set when you call
 * {!Flx_cil_cil.initCIL}. *)
val wcharKind: ikind ref
val wcharType: typ ref

(** char const * *)
val charConstPtrType: typ

(** void * *)
val voidPtrType: typ

(** int * *)
val intPtrType: typ

(** unsigned int * *)
val uintPtrType: typ

(** double *)
val doubleType: typ

(* An unsigned integer type that fits pointers. Depends on {!Flx_cil_cil.msvcMode}
 *  and is set when you call {!Flx_cil_cil.initCIL}. *)
val upointType: typ ref

(* An unsigned integer type that is the type of sizeof. Depends on
 * {!Flx_cil_cil.msvcMode} and is set when you call {!Flx_cil_cil.initCIL}.  *)
val typeOfSizeOf: typ ref

(** Returns true if and only if the given integer type is signed. *)
val isSigned: ikind -> bool

(** Creates a a (potentially recursive) composite type. The arguments are:
 * (1) a boolean indicating whether it is a struct or a union, (2) the name
 * (always non-empty), (3) a function that when given a representation of the
 * structure type constructs the type of the fields recursive type (the first
 * argument is only useful when some fields need to refer to the type of the
 * structure itself), and (4) a list of attributes to be associated with the
 * composite type. The resulting compinfo has the field "cdefined" only if
 * the list of fields is non-empty. *)
val mkCompInfo: bool ->      (* whether it is a struct or a union *)
               string ->     (* name of the composite type; cannot be empty *)
               (compinfo ->
                  (string * typ * int option * attributes * location * storage) list) ->
               (* a function that when given a forward
                  representation of the structure type constructs the type of
                  the fields. The function can ignore this argument if not
                  constructing a recursive type.  *)
               attributes -> compinfo

(** Makes a shallow copy of a {!Flx_cil_cil.compinfo} changing the name and the key.*)
val copyCompInfo: compinfo -> string -> compinfo

(** This is a constant used as the name of an unnamed bitfield. These fields
    do not participate in initialization and their name is not printed. *)
val missingFieldName: string

(** Get the full name of a comp *)
val compFullName: compinfo -> string

(** Returns true if this is a complete type.
   This means that sizeof(t) makes sense.
   Incomplete types are not yet defined
   structures and empty arrays. *)
val isCompleteType: typ -> bool

(** Unroll a type until it exposes a non
 * [TNamed]. Will drop the top-level attributes appearing in [TNamed]!!! *)
val unrollType: typ -> typ   (* Might drop some attributes !! *)

(** Unroll all the TNamed in a type (even under type constructors such as
 * [TPtr], [TFun] or [TArray]. Does not unroll the types of fields in [TComp]
 * types. *)
val unrollTypeDeep: typ -> typ   (* Might drop some attributes !! *)

(** True if the argument is an integral type (i.e. integer or enum) *)
val isIntegralType: typ -> bool

(** True if the argument is an arithmetic type (i.e. integer, enum or
    floating point *)
val isArithmeticType: typ -> bool

(**True if the argument is a pointer type *)
val isPointerType: typ -> bool

(** True if the argument is a function type *)
val isFunctionType: typ -> bool

(** Obtain the argument list ([] if None) *)
val argsToList: (string * typ * attributes) list option
                  -> (string * typ * attributes) list

(** True if the argument is an array type *)
val isArrayType: typ -> bool

(** Raised when {!Flx_cil_cil.lenOfArray} fails either because the length is [None]
  * or because it is a non-constant expression *)
exception LenOfArray

(** Call to compute the array length as present in the array type, to an
  * integer. Raises {!Flx_cil_cil.LenOfArray} if not able to compute the length, such
  * as when there is no length or the length is not a constant. *)
val lenOfArray: exp option -> int

(** Return a named fieldinfo in compinfo, or raise Not_found *)
val getCompField: compinfo -> string -> fieldinfo


(** A datatype to be used in conjunction with [existsType] *)
type existsAction =
    ExistsTrue                          (* We have found it *)
  | ExistsFalse                         (* Stop processing this branch *)
  | ExistsMaybe                         (* This node is not what we are
                                         * looking for but maybe its
                                         * successors are *)

(** Scans a type by applying the function on all elements.
    When the function returns ExistsTrue, the scan stops with
    true. When the function returns ExistsFalse then the current branch is not
    scanned anymore. Care is taken to
    apply the function only once on each composite type, thus avoiding
    circularity. When the function returns ExistsMaybe then the types that
    construct the current type are scanned (e.g. the base type for TPtr and
    TArray, the type of fields for a TComp, etc). *)
val existsType: (typ -> existsAction) -> typ -> bool


(** Given a function type split it into return type,
 * arguments, is_vararg and attributes. An error is raised if the type is not
 * a function type *)
val splitFunctionType:
    typ -> typ * (string * typ * attributes) list option * bool * attributes
(** Same as {!Flx_cil_cil.splitFunctionType} but takes a varinfo. Prints a nicer
 * error message if the varinfo is not for a function *)
val splitFunctionTypeVI:
    varinfo -> typ * (string * typ * attributes) list option * bool * attributes


(** {b Type signatures} *)

(** Type signatures. Two types are identical iff they have identical
 * signatures. These contain the same information as types but canonicalized.
 * For example, two function types that are identical except for the name of
 * the formal arguments are given the same signature. Also, [TNamed]
 * constructors are unrolled. *)
type typsig =
    TSArray of typsig * exp option * attributes
  | TSPtr of typsig * attributes
  | TSComp of bool * string * attributes
  | TSFun of typsig * typsig list * bool * attributes
  | TSEnum of string * attributes
  | TSBase of typ

(** Print a type signature *)
val d_typsig: unit -> typsig -> Flx_cil_pretty.doc

(** Compute a type signature *)
val typeSig: typ -> typsig

(** Like {!Flx_cil_cil.typeSig} but customize the incorporation of attributes *)
val typeSigWithAttrs: (attributes -> attributes) -> typ -> typsig

(** Replace the attributes of a signature (only at top level) *)
val setTypeSigAttrs: attributes -> typsig -> typsig

(** Get the top-level attributes of a signature *)
val typeSigAttrs: typsig -> attributes

(*********************************************************)
(**  LVALUES *)

(** Make a varinfo. Use this (rarely) to make a raw varinfo. Use other
 * functions to make locals ({!Flx_cil_cil.makeLocalVar} or {!Flx_cil_cil.makeFormalVar} or
 * {!Flx_cil_cil.makeTempVar}) and globals ({!Flx_cil_cil.makeGlobalVar}). Note that this
 * function will assign a new identifier. The first argument specifies
 * whether the varinfo is for a global. *)
val makeVarinfo: bool -> string -> typ -> varinfo

(** Make a formal variable for a function. Insert it in both the sformals
    and the type of the function. You can optionally specify where to insert
    this one. If where = "^" then it is inserted first. If where = "$" then
    it is inserted last. Otherwise where must be the name of a formal after
    which to insert this. By default it is inserted at the end. *)
val makeFormalVar: fundec -> ?where:string -> string -> typ -> varinfo

(** Make a local variable and add it to a function's slocals (only if insert =
    true, which is the default). Make sure you know what you are doing if you
    set insert=false.  *)
val makeLocalVar: fundec -> ?insert:bool -> string -> typ -> varinfo

(** Make a temporary variable and add it to a function's slocals. The name of
    the temporary variable will be generated based on the given name hint so
    that to avoid conflicts with other locals.  *)
val makeTempVar: fundec -> ?name: string -> typ -> varinfo


(** Make a global variable. Your responsibility to make sure that the name
    is unique *)
val makeGlobalVar: string -> typ -> varinfo

(** Make a shallow copy of a [varinfo] and assign a new identifier *)
val copyVarinfo: varinfo -> string -> varinfo

(** Add an offset at the end of an lvalue. Make sure the type of the lvalue
 * and the offset are compatible. *)
val addOffsetLval: offset -> lval -> lval

(** [addOffset o1 o2] adds [o1] to the end of [o2]. *)
val addOffset:     offset -> offset -> offset

(** Remove ONE offset from the end of an lvalue. Returns the lvalue with the
 * trimmed offset and the final offset. If the final offset is [NoOffset]
 * then the original [lval] did not have an offset. *)
val removeOffsetLval: lval -> lval * offset

(** Remove ONE offset from the end of an offset sequence. Returns the
 * trimmed offset and the final offset. If the final offset is [NoOffset]
 * then the original [lval] did not have an offset. *)
val removeOffset:   offset -> offset * offset

(** Compute the type of an lvalue *)
val typeOfLval: lval -> typ

(** Compute the type of an offset from a base type *)
val typeOffset: typ -> offset -> typ


(*******************************************************)
(** {b Values for manipulating expressions} *)


(* Construct integer constants *)

(** 0 *)
val zero: exp

(** 1 *)
val one: exp

(** -1 *)
val mone: exp


(** Construct an integer of a given kind, using OCaml's int64 type. If needed
  * it will truncate the integer to be within the representable range for the
  * given kind. *)
val kinteger64: ikind -> int64 -> exp

(** Construct an integer of a given kind. Converts the integer to int64 and
  * then uses kinteger64. This might truncate the value if you use a kind
  * that cannot represent the given integer. This can only happen for one of
  * the Char or Short kinds *)
val kinteger: ikind -> int -> exp

(** Construct an integer of kind IInt. You can use this always since the
    OCaml integers are 31 bits and are guaranteed to fit in an IInt *)
val integer: int -> exp


(** True if the given expression is a (possibly cast'ed)
    character or an integer constant *)
val isInteger: exp -> int64 option

(** True if the expression is a compile-time constant *)
val isConstant: exp -> bool

(** True if the given expression is a (possibly cast'ed) integer or character
    constant with value zero *)
val isZero: exp -> bool

(** Do constant folding on an expression. If the first argument is true then
    will also compute compiler-dependent expressions such as sizeof *)
val constFold: bool -> exp -> exp

(** Do constant folding on a binary operation. The bulk of the work done by
    [constFold] is done here. If the first argument is true then
    will also compute compiler-dependent expressions such as sizeof *)
val constFoldBinOp: bool -> binop -> exp -> exp -> typ -> exp

(** Increment an expression. Can be arithmetic or pointer type *)
val increm: exp -> int -> exp


(** Makes an lvalue out of a given variable *)
val var: varinfo -> lval

(** Make an AddrOf. Given an lvalue of type T will give back an expression of
    type ptr(T). It optimizes somewhat expressions like "& v" and "& v[0]"  *)
val mkAddrOf: lval -> exp


(** Like mkAddrOf except if the type of lval is an array then it uses
    StartOf. This is the right operation for getting a pointer to the start
    of the storage denoted by lval. *)
val mkAddrOrStartOf: lval -> exp

(** Make a Mem, while optimizing AddrOf. The type of the addr must be
    TPtr(t) and the type of the resulting lval is t. Note that in CIL the
    implicit conversion between an array and the pointer to the first
    element does not apply. You must do the conversion yourself using
    StartOf *)
val mkMem: addr:exp -> off:offset -> lval

(** Make an expression that is a string constant (of pointer type) *)
val mkString: string -> exp

(** Construct a cast when having the old type of the expression. If the new
  * type is the same as the old type, then no cast is added. *)
val mkCastT: e:exp -> oldt:typ -> newt:typ -> exp

(** Like {!Flx_cil_cil.mkCastT} but uses typeOf to get [oldt] *)
val mkCast: e:exp -> newt:typ -> exp

(** Compute the type of an expression *)
val typeOf: exp -> typ

(** Convert a string representing a C integer literal to an expression.
 * Handles the prefixes 0x and 0 and the suffixes L, U, UL, LL, ULL *)
val parseInt: string -> exp


(**********************************************)
(** {b Values for manipulating statements} *)

(** Construct a statement, given its kind. Initialize the [sid] field to -1,
    and [labels], [succs] and [preds] to the empty list *)
val mkStmt: stmtkind -> stmt

(** Construct a block with no attributes, given a list of statements *)
val mkBlock: stmt list -> block

(** Construct a statement consisting of just one instruction *)
val mkStmtOneInstr: instr -> stmt

(** Try to compress statements so as to get maximal basic blocks *)
(* use this instead of List.@ because you get fewer basic blocks *)
val compactStmts: stmt list -> stmt list

(** Returns an empty statement (of kind [Instr]) *)
val mkEmptyStmt: unit -> stmt

(** A instr to serve as a placeholder *)
val dummyInstr: instr

(** A statement consisting of just [dummyInstr] *)
val dummyStmt: stmt

(** Make a while loop. Can contain Break or Continue *)
val mkWhile: guard:exp -> body:stmt list -> stmt list

(** Make a for loop for(i=start; i<past; i += incr) \{ ... \}. The body
    can contain Break but not Continue. Can be used with i a pointer
    or an integer. Start and done must have the same type but incr
    must be an integer *)
val mkForIncr:  iter:varinfo -> first:exp -> stopat:exp -> incr:exp
                 -> body:stmt list -> stmt list

(** Make a for loop for(start; guard; next) \{ ... \}. The body can
    contain Break but not Continue !!! *)
val mkFor: start:stmt list -> guard:exp -> next: stmt list ->
                                       body: stmt list -> stmt list



(**************************************************)
(** {b Values for manipulating attributes} *)

(** Various classes of attributes *)
type attributeClass =
    AttrName of bool
        (** Attribute of a name. If argument is true and we are on MSVC then
            the attribute is printed using __declspec as part of the storage
            specifier  *)
  | AttrFunType of bool
        (** Attribute of a function type. If argument is true and we are on
            MSVC then the attribute is printed just before the function name *)
  | AttrType  (** Attribute of a type *)

(** This table contains the mapping of predefined attributes to classes.
    Extend this table with more attributes as you need. This table is used to
    determine how to associate attributes with names or types *)
val attributeHash: (string, attributeClass) Hashtbl.t

(** Partition the attributes into classes:name attributes, function type,
    and type attributes *)
val partitionAttributes:  default:attributeClass ->
                         attributes -> attribute list * (* AttrName *)
                                       attribute list * (* AttrFunType *)
                                           attribute list   (* AttrType *)

(** Add an attribute. Maintains the attributes in sorted order of the second
    argument *)
val addAttribute: attribute -> attributes -> attributes

(** Add a list of attributes. Maintains the attributes in sorted order. The
    second argument must be sorted, but not necessarily the first *)
val addAttributes: attribute list -> attributes -> attributes

(** Remove all attributes with the given name. Maintains the attributes in
    sorted order.  *)
val dropAttribute: string -> attributes -> attributes

(** Retains attributes with the given name *)
val filterAttributes: string -> attributes -> attributes

(** True if the named attribute appears in the attribute list. The list of
    attributes must be sorted.  *)
val hasAttribute: string -> attributes -> bool

(** Returns all the attributes contained in a type. This requires a traversal
    of the type structure, in case of composite, enumeration and named types *)
val typeAttrs: typ -> attribute list

val setTypeAttrs: typ -> attributes -> typ (* Resets the attributes *)


(** Add some attributes to a type *)
val typeAddAttributes: attribute list -> typ -> typ

(** Remove all attributes with the given names from a type. Note that this
    does not remove attributes from typedef and tag definitions, just from
    their uses *)
val typeRemoveAttributes: string list -> typ -> typ


(******************
 ******************  VISITOR
 ******************)
(** {b The visitor} *)

(** Different visiting actions. 'a will be instantiated with [exp], [instr],
    etc. *)
type 'a visitAction =
    SkipChildren                        (** Do not visit the children. Return
                                            the node as it is. *)
  | DoChildren                          (** Continue with the children of this
                                            node. Rebuild the node on return
                                            if any of the children changes
                                            (use == test) *)
  | ChangeTo of 'a                      (** Replace the expression with the
                                            given one *)
  | ChangeDoChildrenPost of 'a * ('a -> 'a) (** First consider that the entire
                                           exp is replaced by the first
                                           parameter. Then continue with
                                           the children. On return rebuild
                                           the node if any of the children
                                           has changed and then apply the
                                           function on the node *)



(** A visitor interface for traversing CIL trees. Create instantiations of
 * this type by specializing the class {!Flx_cil_cil.nopCilVisitor}. Each of the
 * specialized visiting functions can also call the [queueInstr] to specify
 * that some instructions should be inserted before the current instruction
 * or statement. Use syntax like [self#queueInstr] to call a method
 * associated with the current object. *)
class type cilVisitor = object
  method vvdec: varinfo -> varinfo visitAction
    (** Invoked for each variable declaration. The subtrees to be traversed
     * are those corresponding to the type and attributes of the variable.
     * Note that variable declarations are all the [GVar], [GVarDecl], [GFun],
     * all the [varinfo] in formals of function types, and the formals and
     * locals for function definitions. This means that the list of formals
     * in a function definition will be traversed twice, once as part of the
     * function type and second as part of the formals in a function
     * definition. *)

  method vvrbl: varinfo -> varinfo visitAction
    (** Invoked on each variable use. Here only the [SkipChildren] and
     * [ChangeTo] actions make sense since there are no subtrees. Note that
     * the type and attributes of the variable are not traversed for a
     * variable use *)

  method vexpr: exp -> exp visitAction
    (** Invoked on each expression occurrence. The subtrees are the
     * subexpressions, the types (for a [Cast] or [SizeOf] expression) or the
     * variable use. *)

  method vlval: lval -> lval visitAction
    (** Invoked on each lvalue occurrence *)

  method voffs: offset -> offset visitAction
    (** Invoked on each offset occurrence that is *not* as part
      * of an initializer list specification, i.e. in an lval or
      * recursively inside an offset. *)

  method vinitoffs: offset -> offset visitAction
    (** Invoked on each offset appearing in the list of a
      * CompoundInit initializer.  *)

  method vinst: instr -> instr list visitAction
    (** Invoked on each instruction occurrence. The [ChangeTo] action can
     * replace this instruction with a list of instructions *)

  method vstmt: stmt -> stmt visitAction
    (** Control-flow statement. The default [DoChildren] action does not
     * create a new statement when the components change. Instead it updates
     * the contents of the original statement. This is done to preserve the
     * sharing with [Goto] and [Case] statements that point to the original
     * statement. If you use the [ChangeTo] action then you should take care
     * of preserving that sharing yourself.  *)

  method vblock: block -> block visitAction     (** Block. *)
  method vfunc: fundec -> fundec visitAction    (** Function definition.
                                                    Replaced in place. *)
  method vglob: global -> global list visitAction (** Global (vars, types,
                                                      etc.)  *)
  method vinit: init -> init visitAction        (** Initializers for globals *)
  method vtype: typ -> typ visitAction          (** Use of some type. Note
                                                 * that for structure/union
                                                 * and enumeration types the
                                                 * definition of the
                                                 * composite type is not
                                                 * visited. Use [vglob] to
                                                 * visit it.  *)
  method vattr: attribute -> attribute list visitAction
    (** Attribute. Each attribute can be replaced by a list *)

    (** Add here instructions while visiting to queue them to preceede the
     * current statement or instruction being processed. Use this method only
     * when you are visiting an expression that is inside a function body, or
     * a statement, because otherwise there will no place for the visitor to
     * place your instructions. *)
  method queueInstr: instr list -> unit

    (** Gets the queue of instructions and resets the queue. This is done
     * automatically for you when you visit statments. *)
  method unqueueInstr: unit -> instr list

end

(** Default Visitor. Traverses the CIL tree without modifying anything *)
class nopCilVisitor: cilVisitor

(* other cil constructs *)

(** Visit a file. This will will re-cons all globals TWICE (so that it is
 * tail-recursive). Use {!Flx_cil_cil.visitCilFileSameGlobals} if your visitor will
 * not change the list of globals.  *)
val visitCilFile: cilVisitor -> file -> unit

(** A visitor for the whole file that does not change the globals (but maybe
 * changes things inside the globals). Use this function instead of
 * {!Flx_cil_cil.visitCilFile} whenever appropriate because it is more efficient for
 * long files. *)
val visitCilFileSameGlobals: cilVisitor -> file -> unit

(** Visit a global *)
val visitCilGlobal: cilVisitor -> global -> global list

(** Visit a function definition *)
val visitCilFunction: cilVisitor -> fundec -> fundec

(* Visit an expression *)
val visitCilExpr: cilVisitor -> exp -> exp

(** Visit an lvalue *)
val visitCilLval: cilVisitor -> lval -> lval

(** Visit an lvalue or recursive offset *)
val visitCilOffset: cilVisitor -> offset -> offset

(** Visit an initializer offset *)
val visitCilInitOffset: cilVisitor -> offset -> offset

(** Visit an instruction *)
val visitCilInstr: cilVisitor -> instr -> instr list

(** Visit a statement *)
val visitCilStmt: cilVisitor -> stmt -> stmt

(** Visit a block *)
val visitCilBlock: cilVisitor -> block -> block

(** Visit a type *)
val visitCilType: cilVisitor -> typ -> typ

(** Visit a variable declaration *)
val visitCilVarDecl: cilVisitor -> varinfo -> varinfo

(** Visit an initializer *)
val visitCilInit: cilVisitor -> init -> init


(** Visit a list of attributes *)
val visitCilAttributes: cilVisitor -> attribute list -> attribute list

(* And some generic visitors. The above are built with these *)




(** {b Flx_cil_utility functions} *)

(** Whether the pretty printer should print output for the MS VC compiler.
   Default is GCC. After you set this function you should call {!Flx_cil_cil.initCIL}. *)
val msvcMode: bool ref


(** Whether to use the logical operands LAnd and LOr. By default, do not use
 * them because they are unlike other expressions and do not evaluate both of
 * their operands *)
val useLogicalOperators: bool ref

(** Styles of printing line directives *)
type lineDirectiveStyle =
  | LineComment
  | LinePreprocessorInput
  | LinePreprocessorOutput

(** How to print line directives *)
val lineDirectiveStyle: lineDirectiveStyle option ref

(** Whether we print something that will only be used as input to our own
 * parser. In that case we are a bit more liberal in what we print *)
val print_CIL_Input: bool ref

(** Whether to print the CIL as they are, without trying to be smart and
  * print nicer code. Normally this is false, in which case the pretty
  * printer will turn the while(1) loops of CIL into nicer loops, will not
  * print empty "else" blocks, etc. These is one case howewer in which if you
  * turn this on you will get code that does not compile: if you use varargs
  * the __builtin_va_arg function will be printed in its internal form. *)
val printCilAsIs: bool ref

(** {b Debugging support} *)

(** A reference to the current location. If you are careful to set this to
 * the current location then you can use some built-in logging functions that
 * will print the location. *)
val currentLoc: location ref

(** CIL has a fairly easy to use mechanism for printing error messages. This
 * mechanism is built on top of the pretty-printer mechanism (see
 * {!Flx_cil_pretty.doc}) and the error-message modules (see {!Flx_cil_errormsg.error}).

 Here is a typical example for printing a log message: {v
ignore (Flx_cil_errormsg.log "Expression %a is not positive (at %s:%i)\n"
                        d_exp e loc.file loc.line)
 v}

 and here is an example of how you print a fatal error message that stop the
* execution: {v
Flx_cil_errormsg.s (Flx_cil_errormsg.bug "Why am I here?")
 v}

 Notice that you can use C format strings with some extension. The most
useful extension is "%a" that means to consumer the next two argument from
the argument list and to apply the first to [unit] and then to the second
and to print the resulting {!Flx_cil_pretty.doc}. For each major type in CIL there is
a corresponding function that pretty-prints an element of that type:
*)


(** Flx_cil_pretty-print a location *)
val d_loc: unit -> location -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print the {!Flx_cil_cil.currentLoc} *)
val d_thisloc: unit -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an integer of a given kind *)
val d_ikind: unit -> ikind -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a floating-point kind *)
val d_fkind: unit -> fkind -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print storage-class information *)
val d_storage: unit -> storage -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a constant *)
val d_const: unit -> constant -> Flx_cil_pretty.doc


(** A printer interface for CIL trees. Create instantiations of
 * this type by specializing the class {!Flx_cil_cil.defaultCilPrinterClass}. *)
class type cilPrinter = object
  method pVDecl: unit -> varinfo -> Flx_cil_pretty.doc
    (** Invoked for each variable declaration. Note that variable
     * declarations are all the [GVar], [GVarDecl], [GFun], all the [varinfo]
     * in formals of function types, and the formals and locals for function
     * definitions. *)

  method pVar: varinfo -> Flx_cil_pretty.doc
    (** Invoked on each variable use. *)

  method pLval: unit -> lval -> Flx_cil_pretty.doc
    (** Invoked on each lvalue occurrence *)

  method pOffset: Flx_cil_pretty.doc -> offset -> Flx_cil_pretty.doc
    (** Invoked on each offset occurrence. The second argument is the base. *)

  method pInstr: unit -> instr -> Flx_cil_pretty.doc
    (** Invoked on each instruction occurrence. *)

  method pLabel: unit -> label -> Flx_cil_pretty.doc
    (** Print a label. *)

  method pStmt: unit -> stmt -> Flx_cil_pretty.doc
    (** Control-flow statement. This is used by
     * {!Flx_cil_cil.printGlobal} and by {!Flx_cil_cil.dumpGlobal}. *)

  method dStmt: out_channel -> int -> stmt -> unit
    (** Dump a control-flow statement to a file with a given indentation.
     * This is used by {!Flx_cil_cil.dumpGlobal}. *)

  method dBlock: out_channel -> int -> block -> unit
    (** Dump a control-flow block to a file with a given indentation.
     * This is used by {!Flx_cil_cil.dumpGlobal}. *)

  method pBlock: unit -> block -> Flx_cil_pretty.doc

  method pBlock: unit -> block -> Flx_cil_pretty.doc
    (** Print a block. *)

  method pGlobal: unit -> global -> Flx_cil_pretty.doc
    (** Global (vars, types, etc.). This can be slow and is used only by
     * {!Flx_cil_cil.printGlobal} but not by {!Flx_cil_cil.dumpGlobal}. *)

  method dGlobal: out_channel -> global -> unit
    (** Dump a global to a file with a given indentation. This is used by
     * {!Flx_cil_cil.dumpGlobal} *)

  method pFieldDecl: unit -> fieldinfo -> Flx_cil_pretty.doc
    (** A field declaration *)

  method pType: Flx_cil_pretty.doc option -> unit -> typ -> Flx_cil_pretty.doc
  (* Use of some type in some declaration. The first argument is used to print
   * the declared element, or is None if we are just printing a type with no
   * name being declared. Note that for structure/union and enumeration types
   * the definition of the composite type is not visited. Use [vglob] to
   * visit it.  *)

  method pAttr: attribute -> Flx_cil_pretty.doc * bool
    (** Attribute. Also return an indication whether this attribute must be
      * printed inside the __attribute__ list or not. *)

  method pAttrParam: unit -> attrparam -> Flx_cil_pretty.doc
    (** Attribute parameter *)

  method pAttrs: unit -> attributes -> Flx_cil_pretty.doc
    (** Attribute lists *)

  method pLineDirective: ?forcefile:bool -> location -> Flx_cil_pretty.doc
    (** Print a line-number. This is assumed to come always on an empty line.
     * If the forcefile argument is present and is true then the file name
     * will be printed always. Otherwise the file name is printed only if it
     * is different from the last time time this function is called. The last
     * file name is stored in a private field inside the cilPrinter object. *)

  method pStmtKind : stmt -> unit -> stmtkind -> Flx_cil_pretty.doc
    (** Print a statement kind. The code to be printed is given in the
     * {!Flx_cil_cil.stmtkind} argument.  The initial {!Flx_cil_cil.stmt} argument
     * records the statement which follows the one being printed;
     * {!Flx_cil_cil.defaultCilPrinterClass} uses this information to prettify
     * statement printing in certain special cases. *)

  method pExp: unit -> exp -> Flx_cil_pretty.doc
    (** Print expressions *)

  method pInit: unit -> init -> Flx_cil_pretty.doc
    (** Print initializers. This can be slow and is used by
     * {!Flx_cil_cil.printGlobal} but not by {!Flx_cil_cil.dumpGlobal}. *)

  method dInit: out_channel -> int -> init -> unit
    (** Dump a global to a file with a given indentation. This is used by
     * {!Flx_cil_cil.dumpGlobal} *)
end

class defaultCilPrinterClass: cilPrinter
val defaultCilPrinter: cilPrinter

(* Top-level printing functions *)
(** Print a type given a pretty printer *)
val printType: cilPrinter -> unit -> typ -> Flx_cil_pretty.doc

(** Print an expression given a pretty printer *)
val printExp: cilPrinter -> unit -> exp -> Flx_cil_pretty.doc

(** Print an lvalue given a pretty printer *)
val printLval: cilPrinter -> unit -> lval -> Flx_cil_pretty.doc

(** Print a global given a pretty printer *)
val printGlobal: cilPrinter -> unit -> global -> Flx_cil_pretty.doc

(** Print an attribute given a pretty printer *)
val printAttr: cilPrinter -> unit -> attribute -> Flx_cil_pretty.doc

(** Print a set of attributes given a pretty printer *)
val printAttrs: cilPrinter -> unit -> attributes -> Flx_cil_pretty.doc

(** Print an instruction given a pretty printer *)
val printInstr: cilPrinter -> unit -> instr -> Flx_cil_pretty.doc

(** Print a statement given a pretty printer. This can take very long
 * (or even overflow the stack) for huge statements. Use {!Flx_cil_cil.dumpStmt}
 * instead. *)
val printStmt: cilPrinter -> unit -> stmt -> Flx_cil_pretty.doc

(** Print a block given a pretty printer. This can take very long
 * (or even overflow the stack) for huge block. Use {!Flx_cil_cil.dumpBlock}
 * instead. *)
val printBlock: cilPrinter -> unit -> block -> Flx_cil_pretty.doc

(** Dump a statement to a file using a given indentation. Use this instead of
 * {!Flx_cil_cil.printStmt} whenever possible. *)
val dumpStmt: cilPrinter -> out_channel -> int -> stmt -> unit

(** Dump a block to a file using a given indentation. Use this instead of
 * {!Flx_cil_cil.printBlock} whenever possible. *)
val dumpBlock: cilPrinter -> out_channel -> int -> block -> unit

(** Print an initializer given a pretty printer. This can take very long
 * (or even overflow the stack) for huge initializers. Use {!Flx_cil_cil.dumpInit}
 * instead. *)
val printInit: cilPrinter -> unit -> init -> Flx_cil_pretty.doc

(** Dump an initializer to a file using a given indentation. Use this instead of
 * {!Flx_cil_cil.printInit} whenever possible. *)
val dumpInit: cilPrinter -> out_channel -> int -> init -> unit

(** Flx_cil_pretty-print a type using {!Flx_cil_cil.defaultCilPrinter} *)
val d_type: unit -> typ -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an expression using {!Flx_cil_cil.defaultCilPrinter}  *)
val d_exp: unit -> exp -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an lvalue using {!Flx_cil_cil.defaultCilPrinter}   *)
val d_lval: unit -> lval -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an offset using {!Flx_cil_cil.defaultCilPrinter}, given the pretty
 * printing for the base.   *)
val d_offset: Flx_cil_pretty.doc -> unit -> offset -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an initializer using {!Flx_cil_cil.defaultCilPrinter}.  This can be
 * extremely slow (or even overflow the stack) for huge initializers. Use
 * {!Flx_cil_cil.dumpInit} instead. *)
val d_init: unit -> init -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a binary operator *)
val d_binop: unit -> binop -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an attribute using {!Flx_cil_cil.defaultCilPrinter}  *)
val d_attr: unit -> attribute -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an argument of an attribute using {!Flx_cil_cil.defaultCilPrinter}  *)
val d_attrparam: unit -> attrparam -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a list of attributes using {!Flx_cil_cil.defaultCilPrinter}  *)
val d_attrlist: unit -> attributes -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print an instruction using {!Flx_cil_cil.defaultCilPrinter}   *)
val d_instr: unit -> instr -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a label using {!Flx_cil_cil.defaultCilPrinter} *)
val d_label: unit -> label -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a statement using {!Flx_cil_cil.defaultCilPrinter}. This can be
 * extremely slow (or even overflow the stack) for huge statements. Use
 * {!Flx_cil_cil.dumpStmt} instead. *)
val d_stmt: unit -> stmt -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a block using {!Flx_cil_cil.defaultCilPrinter}. This can be
 * extremely slow (or even overflow the stack) for huge blocks. Use
 * {!Flx_cil_cil.dumpBlock} instead. *)
val d_block: unit -> block -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print the internal representation of a global using
 * {!Flx_cil_cil.defaultCilPrinter}. This can be extremely slow (or even overflow the
 * stack) for huge globals (such as arrays with lots of initializers). Use
 * {!Flx_cil_cil.dumpGlobal} instead. *)
val d_global: unit -> global -> Flx_cil_pretty.doc


(** Versions of the above pretty printers, that don't print #line directives *)
val dn_exp       : unit -> exp -> Flx_cil_pretty.doc
val dn_lval      : unit -> lval -> Flx_cil_pretty.doc
(* dn_offset is missing because it has a different interface *)
val dn_init      : unit -> init -> Flx_cil_pretty.doc
val dn_type      : unit -> typ -> Flx_cil_pretty.doc
val dn_global    : unit -> global -> Flx_cil_pretty.doc
val dn_attrlist  : unit -> attributes -> Flx_cil_pretty.doc
val dn_attr      : unit -> attribute -> Flx_cil_pretty.doc
val dn_attrparam : unit -> attrparam -> Flx_cil_pretty.doc
val dn_stmt      : unit -> stmt -> Flx_cil_pretty.doc
val dn_instr     : unit -> instr -> Flx_cil_pretty.doc


(** Flx_cil_pretty-print a short description of the global. This is useful for error
 * messages *)
val d_shortglobal: unit -> global -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print a global. Here you give the channel where the printout
 * should be sent. *)
val dumpGlobal: cilPrinter -> out_channel -> global -> unit

(** Flx_cil_pretty-print an entire file. Here you give the channel where the printout
 * should be sent. *)
val dumpFile: cilPrinter -> out_channel -> file -> unit


(* the following error message producing functions also print a location in
 * the code. use {!Flx_cil_errormsg.bug} and {!Flx_cil_errormsg.unimp} if you do not want
 * that *)

(** Like {!Flx_cil_errormsg.bug} except that {!Flx_cil_cil.currentLoc} is also printed *)
val bug: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_errormsg.unimp} except that {!Flx_cil_cil.currentLoc}is also printed *)
val unimp: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_errormsg.error} except that {!Flx_cil_cil.currentLoc} is also printed *)
val error: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_cil.error} except that it explicitly takes a location argument,
 * instead of using the {!Flx_cil_cil.currentLoc} *)
val errorLoc: location -> ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_errormsg.warn} except that {!Flx_cil_cil.currentLoc} is also printed *)
val warn: ('a,unit,Flx_cil_pretty.doc) format -> 'a


(** Like {!Flx_cil_errormsg.warnOpt} except that {!Flx_cil_cil.currentLoc} is also printed.
 * This warning is printed only of {!Flx_cil_errormsg.warnFlag} is set. *)
val warnOpt: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_errormsg.warn} except that {!Flx_cil_cil.currentLoc} and context
    is also printed *)
val warnContext: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_errormsg.warn} except that {!Flx_cil_cil.currentLoc} and context is also
 * printed. This warning is printed only of {!Flx_cil_errormsg.warnFlag} is set. *)
val warnContextOpt: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_cil.warn} except that it explicitly takes a location argument,
 * instead of using the {!Flx_cil_cil.currentLoc} *)
val warnLoc: location -> ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Sometimes you do not want to see the syntactic sugar that the above
 * pretty-printing functions add. In that case you can use the following
 * pretty-printing functions. But note that the output of these functions is
 * not valid C *)

(** Flx_cil_pretty-print the internal representation of an expression *)
val d_plainexp: unit -> exp -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print the internal representation of an integer *)
val d_plaininit: unit -> init -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print the internal representation of an lvalue *)
val d_plainlval: unit -> lval -> Flx_cil_pretty.doc

(** Flx_cil_pretty-print the internal representation of an lvalue offset
val d_plainoffset: unit -> offset -> Flx_cil_pretty.doc *)

(** Flx_cil_pretty-print the internal representation of a type *)
val d_plaintype: unit -> typ -> Flx_cil_pretty.doc



(** {b ALPHA conversion} *)

(** This is the type of the elements that are recorded by the alpha
 * conversion functions in order to be able to undo changes to the tables
 * they modify. Useful for implementing
 * scoping *)
type undoAlphaElement

(** This is the type of the elements of the alpha renaming table. *)
type alphaTableData


(** Create a new name based on a given name. The new name is formed from a
 * prefix (obtained from the given name by stripping a suffix consisting of _
 * followed by only digits), followed by a special separator and then by a
 * positive integer suffix. The first argument is a table mapping name
 * prefixes to some data that specifies what suffixes have been used and how
 * to create the new one. This function updates the table with the new
 * largest suffix generated. The "undolist" argument, when present, will be
 * used by the function to record information that can be used by
 * {!Flx_cil_cil.undoAlphaChanges} to undo those changes. Note that the undo
 * information will be in reverse order in which the action occurred. Returns
 * the new name and, if different from the lookupname, the location of the
 * previous occurrence. This function knows about the location implicitly
 * from the {!Flx_cil_cil.currentLoc}. *)
val newAlphaName: alphaTable:(string, alphaTableData ref) Hashtbl.t ->
                  undolist: undoAlphaElement list ref option ->
                  lookupname:string -> string * location


(** Register a name with an alpha conversion table to ensure that when later
  * we call newAlphaName we do not end up generating this one *)
val registerAlphaName: alphaTable:(string, alphaTableData ref) Hashtbl.t ->
                       undolist: undoAlphaElement list ref option ->
                       lookupname:string -> unit

(** Split the name in preparation for newAlphaName. The prefix returned is
    used to index into the hashtable. The next result value is a separator
    (either empty or the separator chosen to separate the original name from
     the index)  *)
val docAlphaTable: unit -> (string, alphaTableData ref) Hashtbl.t -> Flx_cil_pretty.doc


val getAlphaPrefix: lookupname:string -> string

(** Undo the changes to a table *)
val undoAlphaChanges: alphaTable:(string, alphaTableData ref) Hashtbl.t ->
                      undolist:undoAlphaElement list -> unit

(** Assign unique names to local variables. This might be necessary after you
 * transformed the code and added or renamed some new variables. Names are
 * not used by CIL internally, but once you print the file out the compiler
 * downstream might be confused. You might
 * have added a new global that happens to have the same name as a local in
 * some function. Rename the local to ensure that there would never be
 * confusioin. Or, viceversa, you might have added a local with a name that
 * conflicts with a global *)
val uniqueVarNames: file -> unit

(** {b Optimization Passes} *)

(** A peephole optimizer that processes two adjacent statements and possibly
    replaces them both. If some replacement happens, then the new statements
    are themselves subject to optimization *)
val peepHole2: (instr * instr -> instr list option) -> stmt list -> unit

(** Similar to [peepHole2] except that the optimization window consists of
    one statement, not two *)
val peepHole1: (instr -> instr list option) -> stmt list -> unit

(** {b Machine dependency} *)


(** Raised when one of the bitsSizeOf functions cannot compute the size of a
    type. This can happen because the type contains array-length expressions
    that we don't know how to compute or because it is a type whose size is
    not defined (e.g. TFun or an undefined compinfo)  *)
exception SizeOfError of typ

(** The size of a type, in bits. Trailing padding is added for structs and
 * arrays. Raises {!Flx_cil_cil.SizeOfError} when it cannot compute the size. This
 * function is architecture dependent, so you should only call this after you
 * call {!Flx_cil_cil.initCIL}. Remember that on GCC sizeof(void) is 1! *)
val bitsSizeOf: typ -> int

(* The size of a type, in bytes. Returns a constant expression or a "sizeof"
 * expression if it cannot compute the size. This function is architecture
 * dependent, so you should only call this after you call {!Flx_cil_cil.initCIL}.  *)
val sizeOf: typ -> exp

(** The minimum alignment (in bytes) for a type. This function is
 * architecture dependent, so you should only call this after you call
 * {!Flx_cil_cil.initCIL}. *)
val alignOf_int: typ -> int

(** Give a type of a base and an offset, returns the number of bits from the
 * base address and the width (also expressed in bits) for the subobject
 * denoted by the offset. Raises {!Flx_cil_cil.SizeOfError} when it cannot compute
 * the size. This function is architecture dependent, so you should only call
 * this after you call {!Flx_cil_cil.initCIL}. *)
val bitsOffset: typ -> offset -> int * int


(** Whether "char" is unsigned. Set after you call {!Flx_cil_cil.initCIL} *)
val char_is_unsigned: bool ref

(** Whether the machine is little endian. Set after you call {!Flx_cil_cil.initCIL} *)
val little_endian: bool ref

(** Represents a location that cannot be determined *)
val locUnknown: location

(** Return the location of an instruction *)
val get_instrLoc: instr -> location

(** Return the location of a global, or locUnknown *)
val get_globalLoc: global -> location

(** Return the location of a statement, or locUnknown *)
val get_stmtLoc: stmtkind -> location


(** Generate an {!Flx_cil_cil.exp} to be used in case of errors. *)
val dExp: Flx_cil_pretty.doc -> exp

(** Generate an {!Flx_cil_cil.instr} to be used in case of errors. *)
val dInstr: Flx_cil_pretty.doc -> location -> instr

(** Generate a {!Flx_cil_cil.global} to be used in case of errors. *)
val dGlobal: Flx_cil_pretty.doc -> location -> global

(** Like map but try not to make a copy of the list *)
val mapNoCopy: ('a -> 'a) -> 'a list -> 'a list

(** Like map but each call can return a list. Try not to make a copy of the
    list *)
val mapNoCopyList: ('a -> 'a list) -> 'a list -> 'a list

(** sm: return true if the first is a prefix of the second string *)
val startsWith: string -> string -> bool


(** {b An Interpreter for constructing CIL constructs} *)

(** The type of argument for the interpreter *)
type formatArg =
    Fe of exp
  | Feo of exp option  (** For array lengths *)
  | Fu of unop
  | Fb of binop
  | Fk of ikind
  | FE of exp list (** For arguments in a function call *)
  | Ff of (string * typ * attributes) (** For a formal argument *)
  | FF of (string * typ * attributes) list (** For formal argument lists *)
  | Fva of bool (** For the ellipsis in a function type *)
  | Fv of varinfo
  | Fl of lval
  | Flo of lval option

  | Fo of offset

  | Fc of compinfo
  | Fi of instr
  | FI of instr list
  | Ft of typ
  | Fd of int
  | Fg of string
  | Fs of stmt
  | FS of stmt list
  | FA of attributes

  | Fp of attrparam
  | FP of attrparam list

  | FX of string


(** Flx_cil_pretty-prints a format arg *)
val d_formatarg: unit -> formatArg -> Flx_cil_pretty.doc

@h=tangler('src/compiler/cil/flx_cil_cilutil.mli')
@select(h)

val doFlx_cil_check : bool ref
val logCalls : bool ref
val logWrites : bool ref
val doPartial : bool ref
val doSimpleMem : bool ref
val doOneRet : bool ref
val doStackGuard : bool ref
val doHeapify : bool ref
val makeCFG : bool ref
val printFlx_cil_stats : bool ref
val sliceGlobal : bool ref
val printStages : bool ref
val doCxxPP : bool ref
val libDir : string ref

@h=tangler('src/compiler/cil/flx_cil_cilutil.ml')
@select(h)

(* Keep here the globally-visible flags *)
let doFlx_cil_check= ref false   (* Whether to check CIL *)

let logCalls = ref false (* Whether to produce a log with all the function
                          * calls made *)
let logWrites = ref false (* Whether to produce a log with all the mem
                          * writes made *)
let doPartial = ref false (* Whether to do partial evaluation and constant
                          * folding *)
let doSimpleMem = ref false (* reduce complex memory expressions so that
                          * they contain at most one lval *)
let doOneRet = ref false (* make a functions have at most one 'return' *)
let doStackGuard = ref false (* instrument function calls and returns to
maintain a separate stack for return addresses *)
let doHeapify = ref false (* move stack-allocated arrays to the heap *)
let makeCFG = ref false (* turn the input CIL file into something more like
                          * a CFG *)
let printFlx_cil_stats = ref false

(* when 'sliceGlobal' is set, then when 'rmtmps' runs, only globals*)
(* marked with #pragma cilnoremove(whatever) are kept; when used with *)
(* cilly.asm.exe, the effect is to slice the input on the noremove symbols *)
let sliceGlobal = ref false


let printStages = ref false


let doCxxPP = ref false

let libDir = ref ""

@h=tangler('src/compiler/cil/flx_cil_clist.ml')
@select(h)

open Flx_cil_pretty
open Flx_cil_trace

(* We often need to concatenate sequences and using lists for this purpose is
 * expensive. So we define a kind of "concatenable lists" that are easier to
 * concatenate *)
type 'a clist =
  | CList of 'a list             (* This is the only representation for empty
                                  * *)
  | CConsL of 'a * 'a clist
  | CConsR of 'a clist * 'a
  | CSeq  of 'a clist * 'a clist (* We concatenate only two of them at this
                                  * time. Neither is CEmpty. To be sure
                                  * always use append to make these  *)

let rec listifyOnto (tail: 'a list) = function
    CList l -> l @ tail
  | CConsL (x, l) -> x :: listifyOnto tail l
  | CConsR (l, x) -> listifyOnto (x :: tail) l
  | CSeq (l1, l2) -> listifyOnto (listifyOnto tail l2) l1

let toList l = listifyOnto [] l
let fromList l = CList l


let single x = CList [x]
let empty = CList []

let checkBeforeAppend  (l1: 'a clist) (l2: 'a clist) : bool =
  l1 != l2 || l1 = (CList [])

let append l1 l2 =
  if l1 = CList [] then l2 else
  if l2 = CList [] then l1 else
  begin
    if l1 == l2 then
      raise (Failure "You should not use Flx_cil_clist.append to double a list");
    CSeq (l1, l2)
  end

let rec length (acc: int) = function
    CList l -> acc + (List.length l)
  | CConsL (x, l) -> length (acc + 1) l
  | CConsR (l, _) -> length (acc + 1) l
  | CSeq (l1, l2) -> length (length acc l1) l2
let length l = length 0 l  (* The external version *)

let map (f: 'a -> 'b) (l: 'a clist) : 'b clist =
  let rec loop = function
      CList l -> CList (List.map f l)
    | CConsL (x, l) -> let x' = f x in CConsL (x', loop l)
    | CConsR (l, x) -> let l' = loop l in CConsR (l', f x)
    | CSeq (l1, l2) -> let l1' = loop l1 in CSeq (l1', loop l2)
  in
  loop l


let fold_left (f: 'acc -> 'a -> 'acc) (start: 'acc) (l: 'a clist) =
  let rec loop (start: 'acc) = function
      CList l -> List.fold_left f start l
    | CConsL (x, l) -> loop (f start x) l
    | CConsR (l, x) -> let res = loop start l in f res x
    | CSeq (l1, l2) ->
        let res1 = loop start l1 in
        loop res1 l2
  in
  loop start l

let iter (f: 'a -> unit) (l: 'a clist) : unit =
  let rec loop = function
      CList l -> List.iter f l
    | CConsL (x, l) -> f x; loop l
    | CConsR (l, x) -> loop l; f x
    | CSeq (l1, l2) -> loop l1; loop l2
  in
  loop l


let rec rev = function
    CList l -> CList (List.rev l)
  | CConsL (x, l) -> CConsR (rev l, x)
  | CConsR (l, x) -> CConsL (x, rev l)
  | CSeq (l1, l2) -> CSeq (rev l2, rev l1)


let docCList (sep: doc) (doone: 'a -> doc) () (dl: 'a clist) =
  fold_left
    (fun (acc: doc) (elem: 'a) ->
      let elemd = doone elem in
      if acc == nil then elemd else acc ++ sep ++ elemd)
    nil
    dl


(* let debugFlx_cil_check (lst: 'a clist) : unit =*)
(*   (* use a hashtable to store values encountered *)*)
(*   let tbl : 'a bool H.t = (H.create 13) in*)

(*   letrec recurse (node: 'a clist) =*)
(*     (* have we seen*)*)

(*     match node with*)
(*     | CList*)


(* --------------- testing ----------------- *)
type boxedInt =
  | BI of int
  | SomethingElse

let d_boxedInt () b =
  match b with
  | BI(i) -> (dprintf "%d" i)
  | SomethingElse -> (text "somethingElse")


(* sm: some simple tests of CLists *)
let testCList () : unit =
begin
  (trace "sm" (dprintf "in testCList\n"));

  let clist1 = (fromList [BI(1); BI(2); BI(3)]) in
  (trace "sm" (dprintf "length of clist1 is %d\n"
                       (length clist1) ));

  let flattened = (toList clist1) in
  (trace "sm" (dprintf "flattened: %a\n"
                       (docList (chr ',' ++ break) (d_boxedInt ()))
                       flattened));


end
@h=tangler('src/compiler/cil/flx_cil_clist.mli')
@select(h)

(** Flx_cil_utilities for managing "concatenable lists" (clists). We often need to
    concatenate sequences, and using lists for this purpose is expensive. This
    module provides routines to manage such lists more efficiently. In this
    model, we never do cons or append explicitly. Instead we maintain
    the elements of the list in a special data structure. Routines are provided
    to convert to/from ordinary lists, and carry out common list operations.*)

(** The clist datatype. A clist can be an ordinary list, or a clist preceded
    or followed by an element, or two clists implicitly appended together*)
type 'a clist =
  | CList of 'a list             (** The only representation for the empty
                                     list. Try to use sparingly.  *)
  | CConsL of 'a * 'a clist      (** Do not use this a lot because scanning
                                   * it is not tail recursive *)
  | CConsR of 'a clist * 'a
  | CSeq of 'a clist * 'a clist (** We concatenate only two of them at this
                                    time. Neither is the empty clist. To be
                                    sure always use append to make these *)


(** Convert a clist to an ordinary list *)
val toList: 'a clist -> 'a list

(** Convert an ordinary list to a clist *)
val fromList: 'a list -> 'a clist

(** Create a clist containing one element *)
val single: 'a -> 'a clist

(** The empty clist *)
val empty: 'a clist


(** Append two clists *)
val append: 'a clist -> 'a clist -> 'a clist

(** A useful check to assert before an append. It checks that the two lists
 * are not identically the same (Except if they are both empty) *)
val checkBeforeAppend: 'a clist -> 'a clist -> bool

(** Find the length of a clist *)
val length: 'a clist -> int

(** Map a function over a clist. Returns another clist *)
val map: ('a -> 'b) -> 'a clist -> 'b clist


(** A version of fold_left that works on clists *)
val fold_left: ('acc -> 'a -> 'acc) -> 'acc -> 'a clist -> 'acc

(** A version of iter that works on clists *)
val iter: ('a -> unit) -> 'a clist -> unit

(** Reverse a clist *)
val rev: 'a clist -> 'a clist

(** A document for printing a clist (similar to [docList]) *)
val docCList:
    Flx_cil_pretty.doc -> ('a -> Flx_cil_pretty.doc) -> unit -> 'a clist -> Flx_cil_pretty.doc

@h=tangler('src/compiler/cil/flx_cil_formatcil.ml')
@select(h)
open Flx_cil_cil
open Flx_cil_pretty
open Flx_cil_trace      (* sm: 'trace' function *)
module E = Flx_cil_errormsg
module H = Hashtbl

let noMemoize = ref false

let expMemoTable :
    (string, (((string * formatArg) list -> exp) *
               (exp -> formatArg list option))) H.t = H.create 23

let typeMemoTable :
    (string, (((string * formatArg) list -> typ) *
               (typ -> formatArg list option))) H.t = H.create 23

let lvalMemoTable :
    (string, (((string * formatArg) list -> lval) *
               (lval -> formatArg list option))) H.t = H.create 23

let instrMemoTable :
    (string, ((location -> (string * formatArg) list -> instr) *
               (instr -> formatArg list option))) H.t = H.create 23

let stmtMemoTable :
    (string, ((string -> typ -> varinfo) ->
              location ->
              (string * formatArg) list -> stmt)) H.t = H.create 23

let stmtsMemoTable :
    (string, ((string -> typ -> varinfo) ->
              location ->
              (string * formatArg) list -> stmt list)) H.t = H.create 23


let doParse (prog: string)
            (theParser: (Lexing.lexbuf -> Flx_cil_formatparse.token)
                                          -> Lexing.lexbuf -> 'a)
            (memoTable: (string, 'a) H.t) : 'a =
  try
    if !noMemoize then raise Not_found else
    H.find memoTable prog
  with Not_found -> begin
    let lexbuf = Flx_cil_formatlex.init prog in
    try
      Flx_cil_formatparse.initialize Flx_cil_formatlex.initial lexbuf;
      let res = theParser Flx_cil_formatlex.initial lexbuf in
      H.add memoTable prog res;
      Flx_cil_formatlex.finish ();
      res
    with Parsing.Parse_error -> begin
      Flx_cil_formatlex.finish ();
      E.s (E.error "Parsing error: %s" prog)
    end
    | e -> begin
        ignore (E.log "Caught %s while parsing\n" (Printexc.to_string e));
        Flx_cil_formatlex.finish ();
        raise e
    end
  end


let cExp (prog: string) : (string * formatArg) list -> exp =
  let cf = doParse prog Flx_cil_formatparse.expression expMemoTable in
  (fst cf)

let cLval (prog: string) : (string * formatArg) list -> lval =
  let cf = doParse prog Flx_cil_formatparse.lval lvalMemoTable in
  (fst cf)

let cType (prog: string) : (string * formatArg) list -> typ =
  let cf = doParse prog Flx_cil_formatparse.typename typeMemoTable in
  (fst cf)

let cInstr (prog: string) : location -> (string * formatArg) list -> instr =
  let cf = doParse prog Flx_cil_formatparse.instr instrMemoTable in
  (fst cf)

let cStmt (prog: string) : (string -> typ -> varinfo) ->
                           location -> (string * formatArg) list -> stmt =
  let cf = doParse prog Flx_cil_formatparse.stmt stmtMemoTable in
  cf

let cStmts (prog: string) :
    (string -> typ -> varinfo) ->
    location -> (string * formatArg) list -> stmt list =
  let cf = doParse prog Flx_cil_formatparse.stmt_list stmtsMemoTable in
  cf



(* Match an expression *)
let dExp (prog: string) : exp -> formatArg list option =
  let df = doParse prog Flx_cil_formatparse.expression expMemoTable in
  (snd df)

(* Match an lvalue *)
let dLval (prog: string) : lval -> formatArg list option =
  let df = doParse prog Flx_cil_formatparse.lval lvalMemoTable in
  (snd df)


(* Match a type *)
let dType (prog: string) : typ -> formatArg list option =
  let df = doParse prog Flx_cil_formatparse.typename typeMemoTable in
  (snd df)



(* Match an instruction *)
let dInstr (prog: string) : instr -> formatArg list option =
  let df = doParse prog Flx_cil_formatparse.instr instrMemoTable in
  (snd df)


let test () =
  (* Construct a dummy function *)
  let func = emptyFunction "test_formatcil" in
  (* Construct a few varinfo *)
  let res = makeLocalVar func "res" (TPtr(intType, [])) in
  let arr = makeLocalVar func "arr" (TArray(TPtr(intType, []),
                                            Some (integer 8), [])) in
  let fptr = makeLocalVar func "fptr"
      (TPtr(TFun(intType, None, false, []), [])) in
  (* Construct an instruction *)
  let makeInstr () =
    Call(Some (var res),
         Lval (Mem (CastE(TPtr(TFun(TPtr(intType, []),
                                    Some [ ("", intType, []);
                                           ("a2", TPtr(intType, []), []);
                                           ("a3", TPtr(TPtr(intType, []),
                                                       []), []) ],
                                    false, []), []),
                          Lval (var fptr))),
               NoOffset),
         [  ], locUnknown)
  in
  let times = 100000 in
  (* Make the instruction the regular way *)
  Flx_cil_stats.time "make instruction regular"
    (fun _ -> for i = 0 to times do ignore (makeInstr ()) done)
    ();
  (* Now make the instruction interpreted *)
  noMemoize := true;
  Flx_cil_stats.time "make instruction interpreted"
    (fun _ -> for i = 0 to times do
      let ins =
        cInstr "%v:res = (* ((int * (*)(int, int * a2, int * * a3))%v:fptr))();"
          locUnknown [ ("res", Fv res);
                       ("fptr", Fv fptr) ]
      in
      ()
    done)
    ();
  (* Now make the instruction interpreted with memoization *)
  noMemoize := false;
  Flx_cil_stats.time "make instruction interpreted memoized"
    (fun _ -> for i = 0 to times do
      let ins =
        cInstr "%v:res = (* ((int * (*)(int, int * a2, int * * a3))%v:fptr))();"
          locUnknown [ ("res", Fv res); ("fptr", Fv fptr) ]
      in
      ()
    done)
    ();
  (* Now make the instruction interpreted with partial application *)
  let partInstr =
    cInstr "%v:res = (* ((int * (*)(int, int * a2, int * * a3))%v:fptr))();" in
  Flx_cil_stats.time "make instruction interpreted partial"
    (fun _ -> for i = 0 to times do
      let ins =
        partInstr
          locUnknown [ ("res", Fv res); ("fptr", Fv fptr) ]
      in
      ()
    done)
    ();

  ()


@h=tangler('src/compiler/cil/flx_cil_formatcil.mli')
@select(h)

(** {b An Interpreter for constructing CIL constructs} *)


(** Constructs an expression based on the program and the list of arguments.
 * Each argument consists of a name followed by the actual data. This
 * argument will be placed instead of occurrences of "%v:name" in the pattern
 * (where the "v" is dependent on the type of the data). The parsing of the
 * string is memoized. * Only the first expression is parsed. *)
val cExp: string -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.exp

(** Constructs an lval based on the program and the list of arguments.
 * Only the first lvalue is parsed.
 * The parsing of the string is memoized. *)
val cLval: string -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.lval

(** Constructs a type based on the program and the list of arguments.
 * Only the first type is parsed.
 * The parsing of the string is memoized. *)
val cType: string -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.typ


(** Constructs an instruction based on the program and the list of arguments.
 * Only the first instruction is parsed.
 * The parsing of the string is memoized. *)
val cInstr: string -> Flx_cil_cil.location ->
                      (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.instr

(* Constructs a statement based on the program and the list of arguments. We
 * also pass a function that can be used to make new varinfo's for the
 * declared variables, and a location to be used for the statements. Only the
 * first statement is parsed. The parsing of the string is memoized. *)
val cStmt: string ->
           (string -> Flx_cil_cil.typ -> Flx_cil_cil.varinfo) ->
           Flx_cil_cil.location -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.stmt

(** Constructs a list of statements *)
val cStmts: string ->
            (string -> Flx_cil_cil.typ -> Flx_cil_cil.varinfo) ->
            Flx_cil_cil.location -> (string * Flx_cil_cil.formatArg) list ->
            Flx_cil_cil.stmt list

(** Deconstructs an expression based on the program. Produces an optional
 * list of format arguments. The parsing of the string is memoized. *)
val dExp: string -> Flx_cil_cil.exp -> Flx_cil_cil.formatArg list option

(** Deconstructs an lval based on the program. Produces an optional
 * list of format arguments. The parsing of the string is memoized. *)
val dLval: string -> Flx_cil_cil.lval -> Flx_cil_cil.formatArg list option


(** Deconstructs a type based on the program. Produces an optional list of
 * format arguments. The parsing of the string is memoized. *)
val dType: string -> Flx_cil_cil.typ -> Flx_cil_cil.formatArg list option


(** Deconstructs an instruction based on the program. Produces an optional
 * list of format arguments. The parsing of the string is memoized. *)
val dInstr: string -> Flx_cil_cil.instr -> Flx_cil_cil.formatArg list option


(** If set then will not memoize the parsed patterns *)
val noMemoize: bool ref

(** Just a testing function *)
val test: unit -> unit

@h=tangler('src/compiler/cil/flx_cil_formatlex.mli')
@select(h)

exception Eof
exception InternalError of string

val keywords : (string, Flx_cil_formatparse.token) Hashtbl.t
val scan_ident : string -> Flx_cil_formatparse.token
val init : prog:string -> Lexing.lexbuf
val finish : unit -> unit
val error : string -> 'a
val scan_escape : string -> string
val get_value : char -> int
val scan_hex_escape : string -> string
val scan_oct_escape : string -> string
val wbtowc : string -> string
val wstr_to_warray : string -> string
val getArgName : Lexing.lexbuf -> int -> string
val initial : Lexing.lexbuf -> Flx_cil_formatparse.token
val comment : Lexing.lexbuf -> unit
val endline : Lexing.lexbuf -> Flx_cil_formatparse.token

@h=tangler('src/compiler/cil/flx_cil_formatlex.mll','data')
@select(h)
(* A simple lexical analyzer for constructing CIL based on format strings *)
{
open Flx_cil_formatparse
exception Eof
exception InternalError of string
module H = Hashtbl
module E = Flx_cil_errormsg
(*
** Keyword hashtable
*)
let keywords = H.create 211

(*
** Useful primitives
*)
let scan_ident id =
  try H.find keywords id
  with Not_found -> IDENT id  (* default to variable name *)

(*
** Buffer processor
*)


let init ~(prog: string) : Lexing.lexbuf =
  H.clear keywords;
  Flx_cil_lexerhack.currentPattern := prog;
  List.iter
    (fun (key, token) -> H.add keywords key token)
    [ ("const", CONST); ("__const", CONST); ("__const__", CONST);
      ("static", STATIC);
      ("extern", EXTERN);
      ("long", LONG);
      ("short", SHORT);
      ("signed", SIGNED);
      ("unsigned", UNSIGNED);
      ("volatile", VOLATILE);
      ("char", CHAR);
      ("int", INT);
      ("_Imaginary", IMAGINARY);
      ("_Complex", COMPLEX);
      ("_Bool", BOOL);
      ("float", FLOAT);
      ("double", DOUBLE);
      ("void", VOID);
      ("enum", ENUM);
      ("struct", STRUCT);
      ("typedef", TYPEDEF);
      ("union", UNION);
      ("break", BREAK);
      ("continue", CONTINUE);
      ("goto", GOTO);
      ("return", RETURN);
      ("switch", SWITCH);
      ("case", CASE);
      ("default", DEFAULT);
      ("while", WHILE);
      ("do", DO);
      ("for", FOR);
      ("if", IF);
      ("else", ELSE);
      ("__attribute__", ATTRIBUTE); ("__attribute", ATTRIBUTE);
      ("__int64", INT64);
      ("__builtin_va_arg", BUILTIN_VA_ARG);
    ];
  E.startParsingFromString prog

let finish () =
  E.finishParsing ()

(*** Error handling ***)
let error msg =
  E.parse_error msg


(*** escape character management ***)
let scan_escape str =
  match str with
    "n" -> "\n"
  | "r" -> "\r"
  | "t" -> "\t"
  | "b" -> "\b"
  | "f" -> "\012"  (* ASCII code 12 *)
  | "v" -> "\011"  (* ASCII code 11 *)
  | "a" -> "\007"  (* ASCII code 7 *)
  | "e" -> "\027"  (* ASCII code 27. This is a GCC extension *)
  | _ -> str

let get_value chr =
  match chr with
    '0'..'9' -> (Char.code chr) - (Char.code '0')
  | 'a'..'z' -> (Char.code chr) - (Char.code 'a') + 10
  | 'A'..'Z' -> (Char.code chr) - (Char.code 'A') + 10
  | _ -> 0
let scan_hex_escape str =
  String.make 1 (Char.chr (
                 (get_value (String.get str 0)) * 16
                   + (get_value (String.get str 1))
                   ))
let scan_oct_escape str =
  (* weimer: wide-character constants like L'\400' may be bigger than
   * 256 (in fact, may be up to 511), so Char.chr cannot be used directly *)
  let the_value = (get_value (String.get str 0)) * 64
                   + (get_value (String.get str 1)) * 8
                   + (get_value (String.get str 2)) in
  if the_value < 256 then String.make 1 (Char.chr the_value )
  else (String.make 1 (Char.chr (the_value / 256))) ^
       (String.make 1 (Char.chr (the_value mod 256)))

(* ISO standard locale-specific function to convert a wide character
 * into a sequence of normal characters. Here we work on strings.
 * We convert L"Hi" to "H\000i\000" *)
let wbtowc wstr =
  let len = String.length wstr in
  let dest = String.make (len * 2) '\000' in
  for i = 0 to len-1 do
    dest.[i*2] <- wstr.[i] ;
  done ;
  dest

(* This function converst the "Hi" in L"Hi" to { L'H', L'i', L'\0' } *)
let wstr_to_warray wstr =
  let len = String.length wstr in
  let res = ref "{ " in
  for i = 0 to len-1 do
    res := !res ^ (Printf.sprintf "L'%c', " wstr.[i])
  done ;
  res := !res ^ "}" ;
  !res

let getArgName (l: Lexing.lexbuf) (prefixlen: int) =
  let lexeme = Lexing.lexeme l in
  let ll = String.length lexeme in
  if  ll > prefixlen then
    String.sub lexeme (prefixlen + 1) (ll - prefixlen - 1)
  else
    ""
}

let decdigit = ['0'-'9']
let octdigit = ['0'-'7']
let hexdigit = ['0'-'9' 'a'-'f' 'A'-'F']
let letter = ['a'- 'z' 'A'-'Z']

let floatsuffix = ['f' 'F' 'l' 'L']

let usuffix = ['u' 'U']
let lsuffix = "l"|"L"|"ll"|"LL"
let intsuffix = lsuffix | usuffix | usuffix lsuffix | lsuffix usuffix

let intnum = decdigit+ intsuffix?
let octnum = '0' octdigit+ intsuffix?
let hexnum = '0' ['x' 'X'] hexdigit+ intsuffix?

let exponent = ['e' 'E']['+' '-']? decdigit+
let fraction  = '.' decdigit+
let floatraw = (intnum? fraction)
                        |(intnum exponent)
                        |(intnum? fraction exponent)
                        |(intnum '.')
                        |(intnum '.' exponent)
let floatnum = floatraw floatsuffix?

let ident = (letter|'_')(letter|decdigit|'_')*
let attribident = (letter|'_')(letter|decdigit|'_'|':')
let blank = [' ' '\t' '\012' '\r']
let escape = '\\' _
let hex_escape = '\\' ['x' 'X'] hexdigit hexdigit
let oct_escape = '\\' octdigit  octdigit octdigit


(* The arguments are of the form %l:foo *)
let argname = ':' ident

rule initial =
        parse   blank                   { initial lexbuf}
|               "/*"                    { let _ = comment lexbuf in
                                          initial lexbuf}
|               "//"                    { endline lexbuf }
|               "\n"                    { E.newline (); initial lexbuf}
|               floatnum                {CST_FLOAT (Lexing.lexeme lexbuf)}
|               hexnum                  {CST_INT (Lexing.lexeme lexbuf)}
|               octnum                  {CST_INT (Lexing.lexeme lexbuf)}
|               intnum                  {CST_INT (Lexing.lexeme lexbuf)}
|               "..."                   {ELLIPSIS}
|               "-="                    {MINUS_EQ}
|               "+="                    {PLUS_EQ}
|               "*="                    {STAR_EQ}
|               "<<"                    {INF_INF}
|               ">>"                    {SUP_SUP}
|               "=="                    {EQ_EQ}
|               "!="                    {EXCLAM_EQ}
|               "<="                    {INF_EQ}
|               ">="                    {SUP_EQ}
|               "="                     {EQ}
|               "<"                     {INF}
|               ">"                     {SUP}
|               "++"                    {PLUS_PLUS}
|               "--"                    {MINUS_MINUS}
|               "->"                    {ARROW}
|               '+'                     {PLUS}
|               '-'                     {MINUS}
|               '*'                     {STAR}
|               '/'                     {SLASH}
|               '!'                     {EXCLAM}
|               '&'                     {AND}
|               '|'                     {PIPE}
|               '^'                     {CIRC}
|               '~'                     {TILDE}
|               '['                     {LBRACKET}
|               ']'                     {RBRACKET}
|               '{'                     {LBRACE}
|               '}'                     {RBRACE}
|               '('                     {LPAREN}
|               ')'                     {RPAREN}
|               ';'                     {SEMICOLON}
|               ','                     {COMMA}
|               '.'                     {DOT}
|               ':'                     {COLON}
|               '?'                     {QUEST}
|               "sizeof"                {SIZEOF}

|               "%eo" argname           {ARG_eo (getArgName lexbuf 3) }
|               "%e"  argname           {ARG_e  (getArgName lexbuf 2) }
|               "%E"  argname           {ARG_E  (getArgName lexbuf 2) }
|               "%u"  argname           {ARG_u  (getArgName lexbuf 2) }
|               "%b"  argname           {ARG_b  (getArgName lexbuf 2) }
|               "%t"  argname           {ARG_t  (getArgName lexbuf 2) }
|               "%d"  argname           {ARG_d  (getArgName lexbuf 2) }
|               "%lo" argname           {ARG_lo (getArgName lexbuf 3) }
|               "%l"  argname           {ARG_l  (getArgName lexbuf 2) }
|               "%i"  argname           {ARG_i  (getArgName lexbuf 2) }
|               "%I"  argname           {ARG_I  (getArgName lexbuf 2) }
|               "%o"  argname           {ARG_o  (getArgName lexbuf 2) }
|               "%va" argname           {ARG_va (getArgName lexbuf 3) }
|               "%v"  argname           {ARG_v  (getArgName lexbuf 2) }
|               "%k"  argname           {ARG_k  (getArgName lexbuf 2) }
|               "%f"  argname           {ARG_f  (getArgName lexbuf 2) }
|               "%F"  argname           {ARG_F  (getArgName lexbuf 2) }
|               "%p"  argname           {ARG_p  (getArgName lexbuf 2) }
|               "%P"  argname           {ARG_P  (getArgName lexbuf 2) }
|               "%s"  argname           {ARG_s  (getArgName lexbuf 2) }
|               "%S"  argname           {ARG_S  (getArgName lexbuf 2) }
|               "%g"  argname           {ARG_g  (getArgName lexbuf 2) }
|               "%A"  argname           {ARG_A  (getArgName lexbuf 2) }
|               "%c"  argname           {ARG_c  (getArgName lexbuf 2) }

|               '%'                     {PERCENT}
|               ident                   {scan_ident (Lexing.lexeme lexbuf)}
|               eof                     {EOF}
|               _                       {E.parse_error
                                                "Flx_cil_formatlex: Invalid symbol"
                                                (Lexing.lexeme_start lexbuf)
                                                (Lexing.lexeme_end lexbuf);
                                         raise Parsing.Parse_error
                                        }

and comment =
    parse
      "*/"                              { () }
|     '\n'                              { E.newline (); comment lexbuf }
|               _                       { comment lexbuf }


and endline = parse
        '\n'                    { E.newline (); initial lexbuf}
|       _                       { endline lexbuf}

@h=tangler('src/compiler/cil/flx_cil_formatparse.mly','data')
@select(h)
/*(* Parser for constructing CIL from format strings *)
*/
%{
open Flx_cil_cil
open Flx_cil_pretty
module E = Flx_cil_errormsg

let parse_error msg : 'a =           (* sm: c++-mode highlight hack: -> ' <- *)
  E.hadErrors := true;
  E.parse_error
    msg
    (Parsing.symbol_start ()) (Parsing.symbol_end ())


let getArg (argname: string) (args: (string * formatArg) list) =
  try
    snd (List.find (fun (n, a) -> n = argname) args)
  with _ ->
    E.s (error "Pattern string %s does not have argument with name %s\n"
           !Flx_cil_lexerhack.currentPattern argname)

let wrongArgType (which: string) (expected: string) (found: formatArg) =
  E.s (bug "Expecting %s argument (%s) and found %a\n"
         expected which d_formatarg found)

let doUnop (uo: unop) subexp =
  ((fun args ->
        let e = (fst subexp) args in
        UnOp(uo, e, typeOf e)),

   (fun e -> match e with
     UnOp(uo', e', _) when uo  = uo' -> (snd subexp) e'
   | _ -> None))

let buildPlus e1 e2 : exp =
  let t1 = typeOf e1 in
  if isPointerType t1 then
    BinOp(PlusPI, e1, e2, t1)
  else
    BinOp(PlusA, e1, e2, t1)

let buildMinus e1 e2 : exp =
  let t1 = typeOf e1 in
  let t2 = typeOf e2 in
  if isPointerType t1 then
    if isPointerType t2 then
      BinOp(MinusPP, e1, e2, intType)
    else
      BinOp(MinusPI, e1, e2, t1)
  else
    BinOp(MinusA, e1, e2, t1)

let doBinop bop e1t e2t =
  ((fun args ->
    let e1 = (fst e1t) args in
    let e2 = (fst e2t) args in
    let t1 = typeOf e1 in
    BinOp(bop, e1, e2, t1)),

   (fun e -> match e with
     BinOp(bop', e1, e2, _) when bop' = bop -> begin
       match (snd e1t) e1, (snd e2t) e2 with
         Some m1, Some m2 -> Some (m1 @ m2)
       | _, _ -> None
     end
   | _ -> None))

(* Flx_cil_check the equivalence of two format lists *)
let rec checkSameFormat (fl1: formatArg list) (fl2: formatArg list) =
  match fl1, fl2 with
    [], [] -> true
  | h1::t1, h2::t2 -> begin
      let rec checkOffsetEq o1 o2 =
        match o1, o2 with
          NoOffset, NoOffset -> true
        | Field(f1, o1'), Field(f2, o2') ->
            f1.fname = f2.fname && checkOffsetEq o1' o2'
        | Index(e1, o1'), Index(e2, o2') ->
            checkOffsetEq o1' o2' && checkExpEq e1 e2
        | _, _ -> false

      and checkExpEq e1 e2 =
        match e1, e2 with
          Const(CInt64(n1, _, _)), Const(CInt64(n2, _, _)) -> n1 = n2
        | Lval l1, Lval l2 -> checkLvalEq l1 l2
        | UnOp(uo1, e1, _), UnOp(uo2, e2, _) ->
            uo1 = uo2 && checkExpEq e1 e2
        | BinOp(bo1, e11, e12, _), BinOp(bo2, e21, e22, _) ->
            bo1 = bo2 && checkExpEq e11 e21 && checkExpEq e21 e22
        | AddrOf l1, AddrOf l2 -> checkLvalEq l1 l2
        | StartOf l1, StartOf l2 -> checkLvalEq l1 l2
        | SizeOf t1, SizeOf t2 -> typeSig t1 = typeSig t2
        | _, _ ->
            ignore (E.warn "checkSameFormat for Fe"); false

      and checkLvalEq l1 l2 =
        match l1, l2 with
          (Var v1, o1), (Var v2, o2) -> v1 == v2 && checkOffsetEq o1 o2
        | (Mem e1, o1), (Mem e2, o2) ->
            checkOffsetEq o1 o2 && checkExpEq e1 e2
        | _, _ -> false
      in
      let hdeq =
        match h1, h2 with
          Fv v1, Fv v2 -> v1 == v2
        | Fd n1, Fd n2 -> n1 = n2
        | Fe e1, Fe e2 -> checkExpEq e1 e2
        | Fi i1, Fi i2 -> ignore (E.warn "checkSameFormat for Fi"); false
        | Ft t1, Ft t2 -> typeSig t1 = typeSig t2
        | Fl l1, Fl l2 -> checkLvalEq l1 l2
        | Fo o1, Fo o2 -> checkOffsetEq o1 o2
        | Fc c1, Fc c2 -> c1 == c2
        | _, _ -> false
      in
      hdeq || checkSameFormat t1 t2
  end
  | _, _ -> false

let matchBinopEq (bopeq: binop -> bool) lvt et =
  (fun i -> match i with
    Set (lv, BinOp(bop', Lval (lv'), e', _), l) when bopeq bop' -> begin
      match lvt lv, lvt lv', et e' with
        Some m1, Some m1', Some m2 ->
          (* Must check that m1 and m2 are the same *)
          if checkSameFormat m1 m1' then
            Some (m1 @ m2)
          else
            None
      | _, _, _ -> None
     end
  | _ -> None)

let doBinopEq bop lvt et =
  ((fun loc args ->
    let l = (fst lvt) args in
    Set(l, BinOp(bop, (Lval l), (fst et) args, typeOfLval l), loc)),

   matchBinopEq (fun bop' -> bop = bop') (snd lvt) (snd et))


let getField (bt: typ) (fname: string) : fieldinfo =
  match unrollType bt with
    TComp(ci, _) -> begin
      try
        List.find (fun f -> fname = f.fname) ci.cfields
      with Not_found ->
        E.s (bug "Cannot find field %s in %s\n" fname (compFullName ci))
    end
  | t -> E.s (bug "Trying to access field %s in non-struct\n" fname)


let matchIntType (ik: ikind) (t:typ) : formatArg list option =
  match unrollType t with
    TInt(ik', _) when ik = ik' -> Some []
  | _ -> None

let matchFloatType (fk: fkind) (t:typ) : formatArg list option =
  match unrollType t with
    TFloat(fk', _) when fk = fk' -> Some []
  | _ -> None

let doAttr (id: string)
           (aargs: (((string * formatArg) list -> attrparam list) *
                    (attrparam list -> formatArg list option)) option)
    =
  let t = match aargs with
    Some t -> t
  | None -> (fun _ -> []),
            (function [] -> Some [] | _ -> None)
  in
  ((fun args -> Attr (id, (fst t) args)),

   (fun attrs ->
     (* Find the attributes with the same ID *)
     List.fold_left
       (fun acc a ->
         match acc, a with
           Some _, _ -> acc (* We found one already *)
         | None, Attr(id', args) when id = id' ->
             (* Now match the arguments *)
             (snd t) args
         | None, _ -> acc)
       None
       attrs))


type falist = formatArg list

type maybeInit =
    NoInit
  | InitExp of exp
  | InitCall of lval * exp list

%}

%token <string> IDENT
%token <string> CST_CHAR
%token <string> CST_INT
%token <string> CST_FLOAT
%token <string> CST_STRING
%token <string> CST_WSTRING
%token <string> NAMED_TYPE

%token EOF
%token BOOL CHAR INT DOUBLE FLOAT COMPLEX IMAGINARY VOID INT64 INT32
%token ENUM STRUCT TYPEDEF UNION
%token SIGNED UNSIGNED LONG SHORT
%token VOLATILE EXTERN STATIC CONST RESTRICT AUTO REGISTER

%token <string> ARG_e ARG_eo ARG_E ARG_u ARG_b ARG_t ARG_d ARG_lo ARG_l ARG_i
%token <string> ARG_o ARG_va ARG_f ARG_F ARG_A ARG_v ARG_k ARG_c ARG_d
%token <string> ARG_s ARG_p ARG_P ARG_I ARG_S ARG_g

%token SIZEOF ALIGNOF

%token EQ
%token ARROW DOT

%token EQ_EQ EXCLAM_EQ INF SUP INF_EQ SUP_EQ
%token MINUS_EQ PLUS_EQ STAR_EQ
%token PLUS MINUS STAR SLASH PERCENT
%token TILDE AND PIPE CIRC
%token EXCLAM AND_AND PIPE_PIPE
%token INF_INF SUP_SUP
%token PLUS_PLUS MINUS_MINUS

%token RPAREN LPAREN RBRACE LBRACE LBRACKET RBRACKET
%token COLON SEMICOLON COMMA ELLIPSIS QUEST

%token BREAK CONTINUE GOTO RETURN
%token SWITCH CASE DEFAULT
%token WHILE DO FOR
%token IF THEN ELSE

%token ATTRIBUTE INLINE ASM TYPEOF FUNCTION__ PRETTY_FUNCTION__ LABEL__
%token BUILTIN_VA_ARG BUILTIN_VA_LIST
%token BLOCKATTRIBUTE
%token DECLSPEC
%token <string> MSASM MSATTR
%token PRAGMA


/* operator precedence */
%nonassoc       IF
%nonassoc       ELSE


%left   COMMA

 /*(* Set the following precedences higer than COMMA *)*/
%nonassoc ARG_e ARG_d ARG_lo ARG_l ARG_i ARG_v ARG_I ARG_g
%right  EQ PLUS_EQ MINUS_EQ STAR_EQ SLASH_EQ PERCENT_EQ
                AND_EQ PIPE_EQ CIRC_EQ INF_INF_EQ SUP_SUP_EQ
%right  COLON
%left   PIPE_PIPE
%left   AND_AND
%left   ARG_b
%left   PIPE
%left   CIRC
%left   AND
%left   EQ_EQ EXCLAM_EQ
%left   INF SUP INF_EQ SUP_EQ
%left   INF_INF SUP_SUP
%left   PLUS MINUS
%left   STAR SLASH PERCENT CONST RESTRICT VOLATILE
%right  ARG_u EXCLAM TILDE PLUS_PLUS MINUS_MINUS CAST RPAREN ADDROF SIZEOF ALIGNOF
%left   LBRACKET
%left   DOT ARROW LPAREN LBRACE
%nonassoc IDENT QUEST CST_INT

%start initialize expression typename offset lval instr stmt stmt_list


%type <unit> initialize
%type <((string -> Flx_cil_cil.typ -> Flx_cil_cil.varinfo) -> Flx_cil_cil.location -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.stmt)> stmt
%type <((string -> Flx_cil_cil.typ -> Flx_cil_cil.varinfo) -> Flx_cil_cil.location -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.stmt list)> stmt_list

%type <((string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.exp) * (Flx_cil_cil.exp -> Flx_cil_cil.formatArg list option)> expression

%type <((string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.exp) * (Flx_cil_cil.exp -> Flx_cil_cil.formatArg list option)> constant

%type <((string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.lval) * (Flx_cil_cil.lval -> Flx_cil_cil.formatArg list option)> lval

%type <((string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.typ) * (Flx_cil_cil.typ -> Flx_cil_cil.formatArg list option)> typename

%type <(Flx_cil_cil.attributes -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.typ) * (Flx_cil_cil.typ -> Flx_cil_cil.formatArg list option)> type_spec

%type <((string * Flx_cil_cil.formatArg) list -> (string * Flx_cil_cil.typ * Flx_cil_cil.attributes) list option * bool) * ((string * Flx_cil_cil.typ * Flx_cil_cil.attributes) list option * bool -> Flx_cil_cil.formatArg list option)> parameters


%type <(Flx_cil_cil.location -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.instr) * (Flx_cil_cil.instr -> Flx_cil_cil.formatArg list option)> instr

%type <(Flx_cil_cil.typ -> (string * Flx_cil_cil.formatArg) list -> Flx_cil_cil.offset) * (Flx_cil_cil.offset -> Flx_cil_cil.formatArg list option)> offset


%%


initialize:
 /* empty */   {  }
;

/* (*** Expressions ***) */


expression:
|               ARG_e  {  (* Count arguments eagerly *)
                            let currentArg = $1 in
                            ((fun args ->
                               match getArg currentArg args with
                                   Fe e -> e
                                 | a -> wrongArgType currentArg
                                            "expression" a),

                             (fun e -> Some [ Fe e ]))
                         }

|               constant { $1 }

|               lval     %prec IDENT
                        { ((fun args -> Lval ((fst $1) args)),

                             (fun e -> match e with
                                Lval l -> (snd $1) l
                              | _ -> None))
                         }

|               SIZEOF expression
                        { ((fun args -> SizeOfE ((fst $2) args)),

                           fun e -> match e with
                             SizeOfE e' -> (snd $2) e'
                           | _ -> None)
                        }

|               SIZEOF LPAREN typename RPAREN
                        { ((fun args -> SizeOf ((fst $3) args)),

                           (fun e -> match e with
                              SizeOf t -> (snd $3) t
                           |  _ -> None))
                        }

|               ALIGNOF expression
                        { ((fun args -> AlignOfE ((fst $2) args)),

                           (fun e -> match e with
                             AlignOfE e' -> (snd $2) e' | _ -> None))
                        }

|               ALIGNOF LPAREN typename RPAREN
                        { ((fun args -> AlignOf ((fst $3) args)),

                           (fun e -> match e with
                             AlignOf t' -> (snd $3) t' | _ -> None))
                        }

|               PLUS expression
                        { $2 }
|               MINUS expression
                        { doUnop Neg $2 }

|               EXCLAM expression
                        { doUnop LNot $2 }

|               TILDE expression
                        { doUnop BNot $2 }

|               argu expression %prec ARG_u
                        { ((fun args ->
                             let e = (fst $2) args in
                             UnOp((fst $1) args, e, typeOf e)),

                           (fun e -> match e with
                             UnOp(uo, e', _) -> begin
                               match (snd $1) uo, (snd $2) e' with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _ -> None
                             end
                           | _ -> None))
                        }


|               AND expression                          %prec ADDROF
                        { ((fun args ->
                             match (fst $2) args with
                                Lval l -> mkAddrOf l
                              | _ -> E.s (bug "AddrOf applied to a non lval")),
                          (fun e -> match e with
                            AddrOf l -> (snd $2) (Lval l)
                          | e -> (snd $2) (Lval (mkMem e NoOffset))))
                         }

|               LPAREN expression RPAREN
                        { $2 }

|               expression PLUS expression
                        { ((fun args -> buildPlus ((fst $1) args)
                                                  ((fst $3) args)),
                          (fun e -> match e with
                            BinOp((PlusPI|PlusA), e1, e2, _) -> begin
                              match (snd $1) e1, (snd $3) e2 with
                                Some m1, Some m2 -> Some (m1 @ m2)
                              | _, _ -> None
                            end
                          | _ -> None))
                        }

|               expression MINUS expression
                        { ((fun args -> buildMinus ((fst $1) args)
                                                   ((fst $3) args)),

                           (fun e -> match e with
                             BinOp((MinusPP|MinusPI|MinusA), e1, e2, _) ->
                               begin
                                 match (snd $1) e1, (snd $3) e2 with
                                   Some m1, Some m2 -> Some (m1 @ m2)
                                 | _, _ -> None
                               end
                           | _ -> None))
                        }
|               expression argb expression %prec ARG_b
                        { ((fun args ->
                               let e1 = (fst $1) args in
                               let bop = (fst $2) args in
                               let e2 = (fst $3) args in
                               let t1 = typeOf e1 in
                               BinOp(bop, e1, e2, t1)),

                           (fun e -> match e with
                             BinOp(bop, e1, e2, _) -> begin
                               match (snd $1) e1,(snd $2) bop,(snd $3) e2 with
                                 Some m1, Some m2, Some m3 ->
                                   Some (m1 @ m2 @ m3)
                               | _, _, _ -> None
                             end
                           | _ -> None))
                        }

|               expression STAR expression
                        { doBinop Mult $1 $3 }
|               expression SLASH expression
                        { doBinop Div $1 $3 }
|               expression PERCENT expression
                        { doBinop Mod $1 $3 }
|               expression  INF_INF expression
                        { doBinop Shiftlt $1 $3 }
|               expression  SUP_SUP expression
                        { doBinop Shiftrt $1 $3 }
|               expression AND expression
                        { doBinop BAnd $1 $3 }
|               expression PIPE expression
                        { doBinop BOr $1 $3 }
|               expression CIRC expression
                        { doBinop BXor $1 $3 }
|               expression EQ_EQ expression
                        { doBinop Eq $1 $3 }
|               expression EXCLAM_EQ expression
                        { doBinop Ne $1 $3 }
|               expression INF expression
                        { doBinop Lt $1 $3 }
|               expression SUP expression
                        { doBinop Gt $1 $3 }
|               expression INF_EQ expression
                        { doBinop Le $1 $3 }
|               expression SUP_EQ expression
                        { doBinop Ge $1 $3 }

|               LPAREN typename RPAREN expression
                         { ((fun args ->
                              let t = (fst $2) args in
                              let e = (fst $4) args in
                              mkCast e t),

                            (fun e ->
                              let t', e' =
                                match e with
                                  CastE (t', e') -> t', e'
                                | _ -> typeOf e, e
                              in
                              match (snd $2) t', (snd $4 e') with
                                Some m1, Some m2 -> Some (m1 @ m2)
                              | _, _ -> None))
                         }
;

/*(* Separate the ARG_ to ensure that the counting of arguments is right *)*/
argu :
|   ARG_u              { let currentArg = $1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fu uo -> uo
                           | a -> wrongArgType currentArg "unnop" a),

                          fun uo -> Some [ Fu uo ])
                       }
;

argb :
|   ARG_b              { let currentArg = $1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fb bo -> bo
                           | a -> wrongArgType currentArg "binop" a),

                          fun bo -> Some [ Fb bo ])
                       }
;

constant:
|   ARG_d              { let currentArg = $1 in
                           ((fun args ->
                             match getArg currentArg args with
                               Fd n -> integer n
                              | a -> wrongArgType currentArg "integer" a),

                            fun e -> match e with
                              Const(CInt64(n, _, _)) ->
                                Some [ Fd (Int64.to_int n) ]
                            | _ -> None)
                         }

|   ARG_g             { let currentArg = $1 in
                        ((fun args ->
                             match getArg currentArg args with
                               Fg s -> Const(CStr s)
                              | a -> wrongArgType currentArg "string" a),

                            fun e -> match e with
                              Const(CStr s) ->
                                Some [ Fg s ]
                            | _ -> None)
                         }
|   CST_INT              { let n = parseInt $1 in
                           ((fun args -> n),

                            (fun e -> match e, n with
                              Const(CInt64(e', _, _)),
                              Const(CInt64(n', _, _)) when e' = n' -> Some []
                            | _ -> None))
                         }
;


/*(***************** LVALUES *******************)*/
lval:
|   ARG_l             { let currentArg = $1 in
                           ((fun args ->
                                match getArg currentArg args with
                                  Fl l -> l
                                | Fv v -> Var v, NoOffset
                                | a -> wrongArgType currentArg "lval" a),

                            fun l -> Some [ Fl l ])
                         }

|   argv offset       %prec ARG_v
                         { ((fun args ->
                              let v = (fst $1) args in
                               (Var v, (fst $2) v.vtype args)),

                            (fun l -> match l with
                              Var vi, off -> begin
                                match (snd $1) vi, (snd $2) off with
                                  Some m1, Some m2 -> Some (m1 @ m2)
                                | _ -> None
                              end
                            | _ -> None))
                         }

|   STAR expression      { ((fun args -> mkMem ((fst $2) args) NoOffset),

                           (fun l -> match l with
                              Mem e, NoOffset -> (snd $2) e
                           | _, _ -> None))
                         }

|   expression ARROW IDENT offset
             { ((fun args ->
                   let e = (fst $1) args in
                   let baset =
                     match unrollTypeDeep (typeOf e) with
                       TPtr (t, _) -> t
                     | _ -> E.s (bug "Expecting a pointer for field %s\n" $3)
                   in
                   let fi = getField baset $3 in
                   mkMem e (Field(fi, (fst $4) fi.ftype args))),

                (fun l -> match l with
                   Mem e, Field(fi, off) when fi.fname = $3 -> begin
                     match (snd $1) e, (snd $4) off with
                       Some m1, Some m2 -> Some (m1 @ m2)
                     | _, _ -> None
                   end
                | _, _ -> None))
             }

|   LPAREN STAR expression RPAREN offset
             { ((fun args ->
                 let e = (fst $3) args in
                 let baset =
                   match unrollTypeDeep (typeOf e) with
                     TPtr (t, _) -> t
                   | _ -> E.s (bug "Expecting a pointer\n")
                 in
                 mkMem e ((fst $5) baset args)),

                (fun l -> match l with
                  Mem e, off -> begin
                    match (snd $3) e, (snd $5 off) with
                      Some m1, Some m2 -> Some (m1 @ m2)
                    | _, _ -> None
                  end
                | _, _ -> None))
              }
    ;

argv :
|   ARG_v              { let currentArg = $1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fv v -> v
                           | a -> wrongArgType currentArg "varinfo" a),

                          fun v -> Some [ Fv v ])
                       }
|  IDENT               { let currentArg = $1 in
                         ((fun args ->
                           match getArg currentArg args with
                             Fv v -> v
                           | a -> wrongArgType currentArg "varinfo" a),
                         (fun v ->
                             E.s (bug "identifiers (%s) are not supported for deconstruction" currentArg)))
                       }
;


/*(********** OFFSETS *************)*/
offset:
|  ARG_o             { let currentArg = $1 in
                            ((fun t args ->
                                match getArg currentArg args with
                                  Fo o -> o
                                | a -> wrongArgType currentArg "offset" a),

                              (fun off -> Some [ Fo off ]))
                          }

|  /* empty */            { ((fun t args -> NoOffset),

                             (fun off -> match off with
                                NoOffset -> Some []
                              | _ -> None))
                          }

|  DOT IDENT offset       { ((fun t args ->
                                let fi = getField t $2 in
                                Field (fi, (fst $3) fi.ftype args)),

                            (fun off -> match off with
                               Field (fi, off') when fi.fname = $2 ->
                                 (snd $3) off'
                            | _ -> None))
                          }

|  LBRACKET expression RBRACKET offset
                   { ((fun t args ->
                     let bt =
                       match unrollType t with
                         TArray(bt, _, _) -> bt
                       | _ -> E.s (error "Flx_cil_formatcil: expecting an array for index")
                     in
                     let e = (fst $2) args in
                     Index(e, (fst $4) bt args)),

                    (fun off -> match off with
                      Index (e, off') -> begin
                        match (snd $2) e, (snd $4) off with
                          Some m1, Some m2 -> Some (m1 @ m2)
                        | _, _ -> None
                      end
                    | _ -> None))
                    }
;


/*(************ TYPES **************)*/
typename: one_formal  { ((fun args ->
                            let (_, ft, _) = (fst $1) args in
                            ft),

                         (fun t -> (snd $1) ("", t, [])))
                      }
;

one_formal:
/*(* Do not allow attributes for the name *)*/
| type_spec attributes decl
                   { ((fun args ->
                        let tal = (fst $2) args in
                        let ts = (fst $1) tal args in
                        let (fn, ft, _) = (fst $3) ts args in
                        (fn, ft, [])),

                      (fun (fn, ft, fa) ->
                         match (snd $3) (fn, ft) with
                           Some (restt, m3) -> begin
                             match (snd $1) restt,
                                   (snd $2) (typeAttrs restt)with
                               Some m1, Some m2 ->
                                 Some (m1 @ m2 @ m3)
                             | _, _ -> None
                           end
                         | _ -> None))
                   }

| ARG_f
                   { let currentArg = $1 in
                     ((fun args ->
                         match getArg currentArg args with
                          Ff (fn, ft, fa) -> (fn, ft, fa)
                         | a  -> wrongArgType currentArg "formal" a),

                      (fun (fn, ft, fa) -> Some [ Ff (fn, ft, fa) ]))
                   }
;

type_spec:
|   ARG_t       { let currentArg = $1 in
                     ((fun al args ->
                       match getArg currentArg args with
                          Ft t -> typeAddAttributes al t
                       | a -> wrongArgType currentArg "type" a),

                      (fun t -> Some [ Ft t ]))
                      }

|   VOID            { ((fun al args -> TVoid al),

                       (fun t -> match unrollType t with
                           TVoid _ -> Some []
                         | _ -> None)) }

|   ARG_k           { let currentArg = $1 in
                      ((fun al args ->
                        match getArg currentArg args with
                          Fk ik -> TInt(ik, al)
                        | a -> wrongArgType currentArg "ikind" a),

                       (fun t -> match unrollType t with
                         TInt(ik, _) -> Some [ Fk ik ]
                       | _ -> None))
                    }

|   CHAR            { ((fun al args -> TInt(IChar, al)),
                       (matchIntType IChar)) }
|   UNSIGNED CHAR   { ((fun al args -> TInt(IUChar, al)),
                       matchIntType IUChar) }

|   SHORT           { ((fun al args -> TInt(IShort, al)),
                       matchIntType IShort) }
|   UNSIGNED SHORT  { ((fun al args -> TInt(IUShort, al)),
                       matchIntType IUShort) }

|   INT             { ((fun al args -> TInt(IInt, al)),
                       matchIntType IInt) }
|   UNSIGNED INT    { ((fun al args -> TInt(IUInt, al)), matchIntType IUInt) }

|   LONG             { ((fun al args -> TInt(ILong, al)),
                        matchIntType ILong) }
|   UNSIGNED LONG    { ((fun al args -> TInt(IULong, al)),
                        matchIntType IULong) }

|   LONG LONG          { ((fun al args -> TInt(ILongLong, al)),

                          matchIntType ILongLong)
                        }
|   UNSIGNED LONG LONG    { ((fun al args -> TInt(IULongLong, al)),

                             matchIntType IULongLong)
                           }

|   FLOAT           { ((fun al args -> TFloat(FFloat, al)),
                       matchFloatType FFloat)
                    }
|   DOUBLE          { ((fun al args -> TFloat(FDouble, al)),
                       matchFloatType FDouble) }

|   COMPLEX         { ((fun al args -> TFloat(CFloat, al)),
                       matchFloatType CFloat ) }

|   IMAGINARY       { ((fun al args -> TFloat(IFloat, al)),
                       matchFloatType IFloat) }

|   STRUCT ARG_c { let currentArg = $2 in
                      ((fun al args ->
                         match getArg currentArg args with
                           Fc ci -> TComp(ci, al)
                         | a -> wrongArgType currentArg "compinfo" a),

                        (fun t -> match unrollType t with
                            TComp(ci, _) -> Some [ Fc ci ]
                          | _ -> None))
                    }
|   UNION ARG_c { let currentArg = $2 in
                     ((fun al args ->
                         match getArg currentArg args with
                           Fc ci -> TComp(ci, al)
                         | a -> wrongArgType currentArg "compinfo" a),

                        (fun t -> match unrollType t with
                            TComp(ci, _) -> Some [ Fc ci ]
                          | _ -> None))

                   }

|   TYPEOF LPAREN expression RPAREN
                   { ((fun al args -> typeAddAttributes al
                                        (typeOf ((fst $3) args))),

                      (fun t -> E.s (bug "Cannot match typeof(e)\n")))
                   }
;

decl:
|  STAR attributes decl
                    { ((fun ts args ->
                         let al = (fst $2) args in
                         (fst $3) (TPtr(ts, al)) args),

                       (fun (fn, ft) ->
                         match (snd $3) (fn, ft) with
                           Some (TPtr(bt, al), m2) -> begin
                             match (snd $2) al with
                               Some m1 -> Some (bt, m1 @ m2)
                             | _ -> None
                           end
                         | _ -> None))
                    }

|  direct_decl  { $1 }
;

direct_decl:
|  /* empty */     { ((fun ts args -> ("", ts, [])),

                      (* Match any name in this case *)
                      (fun (fn, ft) ->
                         Some (unrollType ft, [])))
                   }

|  IDENT           { ((fun ts args -> ($1, ts, [])),

                      (fun (fn, ft) ->
                        if fn = "" || fn = $1 then
                          Some (unrollType ft, [])
                        else
                          None))
                   }

|  LPAREN attributes decl RPAREN
                   { ((fun ts args ->
                          let al = (fst $2) args in
                          (fst $3) (typeAddAttributes al ts) args),

                      (fun (fn, ft) -> begin
                        match (snd $3) (fn, ft) with
                          Some (restt, m2) -> begin
                            match (snd $2) (typeAttrs restt) with
                              Some m1 -> Some (restt, m1 @ m2)
                            | _ -> None
                          end
                        | _ -> None
                      end))
                   }

|  direct_decl LBRACKET exp_opt RBRACKET
                   { ((fun ts args ->
                        (fst $1) (TArray(ts, (fst $3) args, [])) args),

                     (fun (fn, ft) ->
                       match (snd $1) (fn, ft) with
                         Some (TArray(bt, lo, _), m1) -> begin
                           match (snd $3) lo with
                             Some m2 -> Some (unrollType bt, m1 @ m2)
                           | _ -> None
                         end
                       | _ -> None))
                   }


/*(* We use parentheses around the function to avoid conflicts *)*/
|  LPAREN attributes decl RPAREN LPAREN parameters RPAREN
                   { ((fun ts args ->
                        let al = (fst $2) args in
                        let pars, isva = (fst $6) args in
                        (fst $3) (TFun(ts, pars, isva, al)) args),

                      (fun (fn, ft) ->
                         match (snd $3) (fn, ft) with
                           Some (TFun(rt, args, isva, al), m1) -> begin
                             match (snd $2) al, (snd $6) (args, isva) with
                               Some m2, Some m6
                               -> Some (unrollType rt, m1 @ m2 @ m6)
                             | _ -> None
                           end
                         | _ -> None))
                   }
;

parameters:
| /* empty */      { ((fun args -> (None, false)),

                     (* Match any formals *)
                      (fun (pars, isva) ->
                        match pars, isva with
                          (_, false) -> Some []
                        | _ -> None))
                   }

| parameters_ne    { ((fun args ->
                        let (pars : (string * typ * attributes) list),
                            (isva : bool) = (fst $1) args in
                        (Some pars), isva),

                     (function
                         ((Some pars), isva) -> (snd $1) (pars, isva)
                       |  _ -> None))
                   }
;
parameters_ne:
| ELLIPSIS
                   { ((fun args -> ([], true)),

                      (function
                          ([], true) -> Some []
                        | _ -> None))
                   }

| ARG_va           { let currentArg = $1 in
                     ((fun args ->
                       match getArg currentArg args with
                         Fva isva -> ([], isva)
                       | a -> wrongArgType currentArg "vararg" a),

                     (function
                         ([], isva) -> Some [ Fva isva ]
                       | _ -> None))
                   }

| ARG_F            { let currentArg = $1 in
                     ((fun args ->
                       match getArg currentArg args with
                        FF fl -> ( fl, false)
                       | a  -> wrongArgType currentArg "formals" a),

                      (function
                          (pars, false) -> Some [ FF pars ]
                        | _ -> None))
                   }

| one_formal       { ((fun args -> ([(fst $1) args], false)),

                     (function
                         ([ f ], false) -> (snd $1) f
                       | _ -> None))
                   }


| one_formal COMMA parameters_ne
                   { ((fun args ->
                        let this = (fst $1) args in
                        let (rest, isva) = (fst $3) args in
                        (this :: rest, isva)),

                      (function
                          ((f::rest, isva)) -> begin
                            match (snd $1) f, (snd $3) (rest, isva) with
                              Some m1, Some m2 -> Some (m1 @ m2)
                            | _, _ -> None
                          end
                        | _ -> None))
                   }
;





exp_opt:
   /* empty */     { ((fun args -> None),
                      (* Match anything if the pattern does not have a len *)
                      (fun _ -> Some [])) }

|  expression      { ((fun args -> Some ((fst $1) args)),

                      (fun lo -> match lo with
                        Some e -> (snd $1) e
                      | _ -> None))
                   }
|  ARG_eo          { let currentArg = $1 in
                     ((fun args ->
                       match getArg currentArg args with
                         Feo lo -> lo
                       | a -> wrongArgType currentArg "exp_opt" a),

                      fun lo -> Some [ Feo lo ])
                   }
;



attributes:
  /*(* Ignore other attributes *)*/
  /* empty */     { ((fun args -> []),
                     (fun attrs -> Some [])) }

| ARG_A           { let currentArg = $1 in
                    ((fun args ->
                        match getArg currentArg args with
                          FA al -> al
                        | a -> wrongArgType currentArg "attributes" a),

                     (fun al -> Some [ FA al ]))
                  }

| attribute attributes
                  { ((fun args ->
                       addAttribute ((fst $1) args) ((fst $2) args)),
                     (* Pass all the attributes down *)
                     (fun attrs ->
                       match (snd $1) attrs, (snd $2) attrs with
                         Some m1, Some m2 -> Some (m1 @ m2)
                       | _, _ -> None))
                  }
;

attribute:
|   CONST                               { doAttr "const" None }
|   RESTRICT                            { doAttr "restrict" None }
|   VOLATILE                            { doAttr "volatile" None }
|   ATTRIBUTE LPAREN LPAREN attr RPAREN RPAREN
                                        { $4 }

;


attr:
|   IDENT
                          { doAttr $1 None }

|   IDENT LPAREN attr_args_ne RPAREN
                          { doAttr $1 (Some $3) }
;

attr_args_ne:
    attr_arg                     { ((fun args -> [ (fst $1) args ]),

                                    (fun aargs -> match aargs with
                                      [ arg ] -> (snd $1) arg
                                    | _ -> None))
                                 }
|   attr_arg COMMA attr_args_ne  { ((fun args ->
                                      let this = (fst $1) args in
                                      this :: ((fst $3) args)),

                                    (fun aargs -> match aargs with
                                      h :: rest -> begin
                                        match (snd $1) h, (snd $3) rest with
                                          Some m1, Some m2 -> Some (m1 @ m2)
                                        | _, _ -> None
                                      end
                                    | _ -> None))
                                  }
|   ARG_P               { let currentArg = $1 in
                          ((fun args ->
                            match getArg currentArg args with
                              FP al -> al
                            | a -> wrongArgType currentArg "attrparams" a),

                           (fun al -> Some [ FP al ]))
                        }
;

attr_arg:
|   IDENT            { ((fun args -> ACons($1, [])),

                        (fun aarg -> match aarg with
                            ACons(id, []) when id = $1 -> Some []
                        | _ -> None))
                     }
|   IDENT LPAREN attr_args_ne RPAREN
                     { ((fun args -> ACons($1, (fst $3) args)),

                        (fun aarg -> match aarg with
                            ACons(id, args) when id = $1 ->
                              (snd $3) args
                        | _ -> None))
                     }
|   ARG_p            { let currentArg = $1 in
                       ((fun args ->
                          match getArg currentArg args with
                            Fp p -> p
                          | a -> wrongArgType currentArg "attrparam" a),

                        (fun ap -> Some [ Fp ap]))
                     }

;

/* (********** INSTRUCTIONS ***********) */
instr:
|               ARG_i SEMICOLON
                        { let currentArg = $1 in
                          ((fun loc args ->
                                match getArg currentArg args with
                                  Fi i -> i
                                | a -> wrongArgType currentArg "instr" a),

                           (fun i -> Some [ Fi i]))
                        }

|               lval EQ expression SEMICOLON
                        { ((fun loc args ->
                              Set((fst $1) args, (fst $3) args, loc)),

                           (fun i -> match i with
                             Set (lv, e, l) -> begin
                               match (snd $1) lv, (snd $3) e with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _, _ -> None
                             end
                           | _ -> None))
                        }

|               lval PLUS_EQ expression SEMICOLON
                        { ((fun loc args ->
                              let l = (fst $1) args in
                              Set(l, buildPlus (Lval l) ((fst $3) args), loc)),

                           matchBinopEq
                             (fun bop -> bop = PlusPI || bop = PlusA)
                             (snd $1) (snd $3))
                        }

|               lval MINUS_EQ expression SEMICOLON
                        { ((fun loc args ->
                              let l = (fst $1) args in
                              Set(l,
                                  buildMinus (Lval l) ((fst $3) args), loc)),

                           matchBinopEq (fun bop -> bop = MinusA
                                               || bop = MinusPP
                                               || bop = MinusPI)
                                      (snd $1)  (snd $3))
                        }
|               lval STAR_EQ expression SEMICOLON
                        { doBinopEq Mult $1 $3 }

|               lval SLASH_EQ expression SEMICOLON
                        { doBinopEq Div $1 $3 }

|               lval PERCENT_EQ expression SEMICOLON
                        { doBinopEq Mod $1 $3 }

|               lval AND_EQ expression SEMICOLON
                        { doBinopEq BAnd $1 $3 }

|               lval PIPE_EQ expression SEMICOLON
                        { doBinopEq BOr $1 $3 }

|               lval CIRC_EQ expression SEMICOLON
                        { doBinopEq BXor $1 $3 }

|               lval INF_INF_EQ expression SEMICOLON
                        { doBinopEq Shiftlt $1 $3 }

|               lval SUP_SUP_EQ expression SEMICOLON
                        { doBinopEq Shiftrt $1 $3 }

/* (* Would be nice to be able to condense the next three rules but we get
 * into conflicts *)*/
|               lval EQ lval LPAREN arguments RPAREN  SEMICOLON
                        { ((fun loc args ->
                              Call(Some ((fst $1) args), Lval ((fst $3) args),
                                     (fst $5) args, loc)),

                           (fun i -> match i with
                             Call(Some l, Lval f, args, loc) -> begin
                               match (snd $1) l, (snd $3) f, (snd $5) args with
                                 Some m1, Some m2, Some m3 ->
                                   Some (m1 @ m2 @ m3)
                               | _, _, _ -> None
                             end
                           | _ -> None))
                        }

|                       lval LPAREN arguments RPAREN  SEMICOLON
                        { ((fun loc args ->
                              Call(None, Lval ((fst $1) args),
                                     (fst $3) args, loc)),

                           (fun i -> match i with
                             Call(None, Lval f, args, loc) -> begin
                               match (snd $1) f, (snd $3) args with
                                 Some m1, Some m2 -> Some (m1 @ m2)
                               | _, _ -> None
                             end
                           | _ -> None))
                         }

|                 arglo lval LPAREN arguments RPAREN  SEMICOLON
                     { ((fun loc args ->
                       Call((fst $1) args, Lval ((fst $2) args),
                            (fst $4) args, loc)),

                        (fun i -> match i with
                          Call(lo, Lval f, args, loc) -> begin
                            match (snd $1) lo, (snd $2) f, (snd $4) args with
                              Some m1, Some m2, Some m3 ->
                                Some (m1 @ m2 @ m3)
                            | _, _, _ -> None
                          end
                        | _ -> None))
                     }
;

/* (* Separate this out to ensure that the counting or arguments is right *)*/
arglo:
    ARG_lo               { let currentArg = $1 in
                           ((fun args ->
                             let res =
                               match getArg currentArg args with
                                 Flo x -> x
                               | a -> wrongArgType currentArg "lval option" a
                             in
                             res),

                            (fun lo -> Some [ Flo lo ]))
                         }
;
arguments:
    /* empty */   { ((fun args -> []),

                     (fun actuals -> match actuals with
                          [] -> Some []
                         | _ -> None))
                  }

| arguments_ne    { $1 }
;

arguments_ne:
  expression      { ((fun args -> [ (fst $1) args ]),

                     (fun actuals -> match actuals with
                        [ h ] -> (snd $1) h
                       | _ -> None))
                  }

| ARG_E           {  let currentArg = $1 in
                     ((fun args ->
                         match getArg currentArg args with
                           FE el -> el
                          | a -> wrongArgType currentArg "arguments" a),

                      (fun actuals -> Some [ FE actuals ]))
                  }

| expression COMMA arguments_ne
                  { ((fun args -> ((fst $1) args) :: ((fst $3) args)),

                     (fun actuals -> match actuals with
                         h :: rest -> begin
                           match (snd $1) h, (snd $3) rest with
                             Some m1, Some m2 -> Some (m1 @ m2)
                           | _, _ -> None
                         end
                       | _ -> None))
                  }
;


/*(******** STATEMENTS *********)*/
stmt:
    IF LPAREN expression RPAREN stmt           %prec IF
                  { (fun mkTemp loc args ->
                         mkStmt (If((fst $3) args,
                                    mkBlock [ $5 mkTemp loc args ],
                                    mkBlock [], loc)))
                  }
|   IF LPAREN expression RPAREN stmt ELSE stmt
                  { (fun mkTemp loc args ->
                         mkStmt (If((fst $3) args,
                                    mkBlock [ $5 mkTemp loc args ],
                                    mkBlock [ $7 mkTemp loc args], loc)))
                  }
|   RETURN exp_opt SEMICOLON
                  { (fun mkTemp loc args ->
                         mkStmt (Return((fst $2) args, loc)))
                  }
|   BREAK SEMICOLON
                  { (fun mkTemp loc args ->
                         mkStmt (Break loc))
                  }
|   CONTINUE SEMICOLON
                  { (fun mkTemp loc args ->
                         mkStmt (Continue loc))
                  }
|   LBRACE stmt_list RBRACE
                  { (fun mkTemp loc args ->
                         let stmts = $2 mkTemp loc args in
                         mkStmt (Block (mkBlock (stmts))))
                  }
|   WHILE LPAREN expression RPAREN stmt
                  { (fun mkTemp loc args ->
                        let e = (fst $3) args in
                        let e =
                          if isPointerType(typeOf e) then
                            mkCast e !upointType
                          else e
                        in
                        mkStmt
                          (Loop (mkBlock [ mkStmt
                                             (If(e,
                                                 mkBlock [],
                                                 mkBlock [ mkStmt
                                                             (Break loc) ],
                                                 loc));
                                           $5 mkTemp loc args ],
                                 loc, None, None)))
                   }
|   instr_list    { (fun mkTemp loc args ->
                       mkStmt (Instr ($1 loc args)))
                  }
|   ARG_s         { let currentArg = $1 in
                    (fun mkTemp loc args ->
                       match getArg currentArg args with
                         Fs s -> s
                       | a -> wrongArgType currentArg "stmt" a) }
;

stmt_list:
    /* empty */  { (fun mkTemp loc args -> []) }

|   ARG_S        { let currentArg = $1 in
                   (fun mkTemp loc args ->
                       match getArg currentArg args with
                       | FS sl -> sl
                       | a -> wrongArgType currentArg "stmts" a)
                 }
|   stmt stmt_list
                 { (fun mkTemp loc args ->
                      let this = $1 mkTemp loc args in
                      this :: ($2 mkTemp loc args))
                 }
/* (* We can also have a declaration *) */
|   type_spec attributes decl maybe_init SEMICOLON stmt_list
                { (fun mkTemp loc args ->
                     let tal = (fst $2) args in
                     let ts  = (fst $1) tal args in
                     let (n, t, _) = (fst $3) ts args in
                     let init = $4 args in
                     (* Before we proceed we must create the variable *)
                     let v = mkTemp n t in
                     (* Now we parse the rest *)
                     let rest = $6 mkTemp loc ((n, Fv v) :: args) in
                     (* Now we add the initialization instruction to the
                      * front *)
                     match init with
                       NoInit -> rest
                     | InitExp e ->
                         mkStmtOneInstr (Set((Var v, NoOffset), e, loc))
                         :: rest
                     | InitCall (f, args) ->
                         mkStmtOneInstr (Call(Some (Var v, NoOffset),
                                              Lval f, args, loc))
                         :: rest

                                                           )
                 }
;

instr_list:
     /*(* Set this rule to very low precedence to ensure that we shift as
          many instructions as possible *)*/
    instr   %prec COMMA
                 { (fun loc args -> [ ((fst $1) loc args) ]) }
|   ARG_I        { let currentArg = $1 in
                   (fun loc args ->
                       match getArg currentArg args with
                       | FI il -> il
                       | a -> wrongArgType currentArg "instrs" a)
                 }
|   instr instr_list
                 { (fun loc args ->
                      let this = (fst $1) loc args in
                      this :: ($2 loc args))
                 }
;


maybe_init:
|                               { (fun args -> NoInit) }
| EQ expression                 { (fun args -> InitExp ((fst $2) args)) }
| EQ lval LPAREN arguments RPAREN
                                { (fun args ->
                                    InitCall((fst $2) args, (fst $4) args)) }
;
%%

@h=tangler('src/compiler/cil/flx_cil_mergecil.ml')
@select(h)
(* mergecil.ml *)
(* This module is responsible for merging multiple CIL source trees into
 * a single, coherent CIL tree which contains the union of all the
 * definitions in the source files.  It effectively acts like a linker,
 * but at the source code level instead of the object code level. *)


module P = Flx_cil_pretty
open Flx_cil_cil
module E = Flx_cil_errormsg
module H = Hashtbl
open Flx_cil_trace

let debugMerge = false
let debugInlines = false

let ignore_merge_conflicts = ref false

(* Try to merge structure with the same name. However, do not complain if
 * they are not the same *)
let mergeSynonyms = true


(** Whether to use path compression *)
let usePathCompression = false

(* Try to merge definitions of inline functions. They can appear in multiple
 * files and we would like them all to be the same. This can slow down the
 * merger an order of magnitude !!! *)
let mergeInlines = true

let mergeInlinesRepeat = mergeInlines && true

let mergeInlinesWithAlphaConvert = mergeInlines && true

(* when true, merge duplicate definitions of externally-visible functions;
 * this uses a mechanism which is faster than the one for inline functions,
 * but only probabilistically accurate *)
let mergeGlobals = true


(* Return true if 's' starts with the prefix 'p' *)
let prefix p s =
  let lp = String.length p in
  let ls = String.length s in
  lp <= ls && String.sub s 0 lp = p



(* A name is identified by the index of the file in which it occurs (starting
 * at 0 with the first file) and by the actual name. We'll keep name spaces
 * separate *)

(* We define a data structure for the equivalence classes *)
type 'a node =
    { nname: string;   (* The actual name *)
      nfidx: int;      (* The file index *)
      ndata: 'a;       (* Data associated with the node *)
      mutable nloc: (location * int) option;
      (* location where defined and index within the file of the definition.
       * If None then it means that this node actually DOES NOT appear in the
       * given file. In rare occasions we need to talk in a given file about
       * types that are not defined in that file. This happens with undefined
       * structures but also due to cross-contamination of types in a few of
       * the cases of combineType (see the definition of combineTypes). We
       * try never to choose as representatives nodes without a definition.
       * We also choose as representative the one that appears earliest *)
      mutable nrep: 'a node;  (* A pointer to another node in its class (one
                               * closer to the representative). The nrep node
                               * is always in an earlier file, except for the
                               * case where a name is undefined in one file
                               * and defined in a later file. If this pointer
                               * points to the node itself then this is the
                               * representative.  *)
      mutable nmergedSyns: bool (* Whether we have merged the synonyms for
                                 * the node of this name *)
    }

let d_nloc () (lo: (location * int) option) : P.doc =
  match lo with
    None -> P.text "None"
  | Some (l, idx) -> P.dprintf "Some(%d at %a)" idx d_loc l

(* Make a node with a self loop. This is quite tricky. *)
let mkSelfNode (eq: (int * string, 'a node) H.t) (* The equivalence table *)
               (syn: (string, 'a node) H.t) (* The synonyms table *)
               (fidx: int) (name: string) (data: 'a)
               (l: (location * int) option) =
  let res = { nname = name; nfidx = fidx; ndata = data; nloc = l;
              nrep  = Obj.magic 1; nmergedSyns = false; } in
  res.nrep <- res; (* Make the self cycle *)
  H.add eq (fidx, name) res; (* Add it to the proper table *)
  if mergeSynonyms && not (prefix "__anon" name) then
    H.add syn name res;
  res

let debugFind = false

(* Find the representative with or without path compression *)
let rec find (pathcomp: bool) (nd: 'a node) =
  if debugFind then
    ignore (E.log "  find %s(%d)\n" nd.nname nd.nfidx);
  if nd.nrep == nd then begin
    if debugFind then
      ignore (E.log "  = %s(%d)\n" nd.nname nd.nfidx);
    nd
  end else begin
    let res = find pathcomp nd.nrep in
    if usePathCompression && pathcomp && nd.nrep != res then
      nd.nrep <- res; (* Compress the paths *)
    res
  end


(* Union two nodes and return the new representative. We prefer as the
 * representative a node defined earlier. We try not to use as
 * representatives nodes that are not defined in their files. We return a
 * function for undoing the union. Make sure that between the union and the
 * undo you do not do path compression *)
let union (nd1: 'a node) (nd2: 'a node) : 'a node * (unit -> unit) =
  (* Move to the representatives *)
  let nd1 = find true nd1 in
  let nd2 = find true nd2 in
  if nd1 == nd2 then begin
    (* It can happen that we are trying to union two nodes that are already
     * equivalent. This is because between the time we check that two nodes
     * are not already equivalent and the time we invoke the union operation
     * we check type isomorphism which might change the equivalence classes *)
(*
    ignore (warn "unioning already equivalent nodes for %s(%d)"
              nd1.nname nd1.nfidx);
*)
    nd1, fun x -> x
  end else begin
    let rep, norep = (* Choose the representative *)
      if (nd1.nloc != None) =  (nd2.nloc != None) then
        (* They have the same defined status. Choose the earliest *)
        if nd1.nfidx < nd2.nfidx then nd1, nd2
        else if nd1.nfidx > nd2.nfidx then nd2, nd1
        else (* In the same file. Choose the one with the earliest index *) begin
          match nd1.nloc, nd2.nloc with
            Some (_, didx1), Some (_, didx2) ->
              if didx1 < didx2 then nd1, nd2 else
              if didx1 > didx2 then nd2, nd1
              else begin
              ignore (warn
                        "Merging two elements (%s and %s) in the same file (%d) with the same idx (%d) within the file"
                        nd1.nname nd2.nname nd1.nfidx didx1);
                nd1, nd2
              end
          | _, _ -> (* both none. Does not matter which one we choose. Should
              * not happen though. *)
              (* sm: it does happen quite a bit when, e.g. merging STLport with
               * some client source; I'm disabling the warning since it supposedly
               * is harmless anyway, so is useless noise *)
              (* sm: re-enabling on claim it now will probably not happen *)
              ignore (warn "Merging two undefined elements in the same file: %s and %s\n" nd1.nname nd2.nname);
              nd1, nd2
        end
      else (* One is defined, the other is not. Choose the defined one *)
        if nd1.nloc != None then nd1, nd2 else nd2, nd1
    in
    let oldrep = norep.nrep in
    norep.nrep <- rep;
    rep, (fun () -> norep.nrep <- oldrep)
  end
(*
let union (nd1: 'a node) (nd2: 'a node) : 'a node * (unit -> unit) =
  if nd1 == nd2 && nd1.nname = "!!!intEnumInfo!!!" then begin
    ignore (warn "unioning two identical nodes for %s(%d)"
              nd1.nname nd1.nfidx);
    nd1, fun x -> x
  end else
    union nd1 nd2
*)
(* Find the representative for a node and compress the paths in the process *)
let findReplacement
    (pathcomp: bool)
    (eq: (int * string, 'a node) H.t)
    (fidx: int)
    (name: string) : ('a * int) option =
  if debugFind then
    ignore (E.log "findReplacement for %s(%d)\n" name fidx);
  try
    let nd = H.find eq (fidx, name) in
    if nd.nrep == nd then begin
      if debugFind then
        ignore (E.log "  is a representative\n");
      None (* No replacement if this is the representative of its class *)
    end else
      let rep = find pathcomp nd in
      if rep != rep.nrep then
        E.s (bug "find does not return the representative\n");
      if debugFind then
        ignore (E.log "  RES = %s(%d)\n" rep.nname rep.nfidx);
      Some (rep.ndata, rep.nfidx)
  with Not_found -> begin
    if debugFind then
      ignore (E.log "  not found in the map\n");
    None
  end

(* Make a node if one does not already exist. Otherwise return the
 * representative *)
let getNode    (eq: (int * string, 'a node) H.t)
               (syn: (string, 'a node) H.t)
               (fidx: int) (name: string) (data: 'a)
               (l: (location * int) option) =
  let debugGetNode = false in
  if debugGetNode then
    ignore (E.log "getNode(%s(%d), %a)\n"
              name fidx d_nloc l);
  try
    let res = H.find eq (fidx, name) in

    (match res.nloc, l with
      (* Maybe we have a better location now *)
      None, Some _ -> res.nloc <- l
    | Some (old_l, old_idx), Some (l, idx) ->
        if old_idx != idx then
          ignore (warn "Duplicate definition of node %s(%d) at indices %d(%a) and %d(%a)"
                    name fidx old_idx d_loc old_l idx d_loc l)
        else
          ()

    | _, _ -> ());
    if debugGetNode then
      ignore (E.log "  node already found\n");
    find false res (* No path compression *)
  with Not_found -> begin
    let res = mkSelfNode eq syn fidx name data l in
    if debugGetNode then
      ignore (E.log "   made a new one\n");
    res
  end



(* Dump a graph *)
let dumpGraph (what: string) (eq: (int * string, 'a node) H.t) : unit =
  ignore (E.log "Equivalence graph for %s is:\n" what);
  H.iter (fun (fidx, name) nd ->
    ignore (E.log "  %s(%d) %s-> "
              name fidx (if nd.nloc = None then "(undef)" else ""));
    if nd.nrep == nd then
      ignore (E.log "*\n")
    else
      ignore (E.log " %s(%d)\n" nd.nrep.nname nd.nrep.nfidx ))
    eq




(* For each name space we define a set of equivalence classes *)
let vEq: (int * string, varinfo node) H.t = H.create 111 (* Vars *)
let sEq: (int * string, compinfo node) H.t = H.create 111 (* Struct + union *)
let eEq: (int * string, enuminfo node) H.t = H.create 111 (* Enums *)
let tEq: (int * string, typeinfo node) H.t = H.create 111 (* Type names*)
let iEq: (int * string, varinfo node) H.t = H.create 111 (* Inlines *)

(* Sometimes we want to merge synonyms. We keep some tables indexed by names.
 * Each name is mapped to multiple exntries *)
let vSyn: (string, varinfo node) H.t = H.create 111 (* Not actually used *)
let iSyn: (string, varinfo node) H.t = H.create 111 (* Inlines *)
let sSyn: (string, compinfo node) H.t = H.create 111
let eSyn: (string, enuminfo node) H.t = H.create 111
let tSyn: (string, typeinfo node) H.t = H.create 111

(** A global environment for variables. Put in here only the non-static
  * variables, indexed by their name.  *)
let vEnv : (string, varinfo node) H.t = H.create 111


(* A set of inline functions indexed by their printout ! *)
let inlineBodies : (P.doc, varinfo node) H.t = H.create 111

(** A number of alpha conversion tables. We ought to keep one table for each
 * name space. Unfortunately, because of the way the C lexer works, type
 * names must be different from variable names!! We one alpha table both for
 * variables and types. *)
let vtAlpha : (string, alphaTableData ref) H.t = H.create 57 (* Variables and
                                                             * types *)
let sAlpha : (string, alphaTableData ref) H.t = H.create 57 (* Structures and
                                                             * unions have
                                                             * the same name
                                                             * space *)
let eAlpha : (string, alphaTableData ref) H.t = H.create 57 (* Enumerations *)


(** Keep track, for all global function definitions, of the names of the formal
 * arguments. They might change during merging of function types if the
 * prototype occurs after the function definition and uses different names.
 * We'll restore the names at the end *)
let formalNames: (int * string, string list) H.t = H.create 111


(* Accumulate here the globals in the merged file *)
let theFileTypes = ref []
let theFile      = ref []

(* add 'g' to the merged file *)
let mergePushGlobal (g: global) : unit =
  pushGlobal g ~types:theFileTypes ~variables:theFile

let mergePushGlobals gl = List.iter mergePushGlobal gl


(* The index of the current file being scanned *)
let currentFidx = ref 0

let currentDeclIdx = ref 0 (* The index of the definition in a file. This is
                            * maintained both in pass 1 and in pass 2. Make
                            * sure you count the same things in both passes. *)
(* Keep here the file names *)
let fileNames : (int, string) H.t = H.create 113



(* Remember the composite types that we have already declared *)
let emittedCompDecls: (string, bool) H.t = H.create 113
(* Remember the variables also *)
let emittedVarDecls: (string, bool) H.t = H.create 113

(* also keep track of externally-visible function definitions;
 * name maps to declaration, location, and semantic checksum *)
let emittedFunDefn: (string, fundec * location * int) H.t = H.create 113
(* and same for variable definitions; name maps to GVar fields *)
let emittedVarDefn: (string, varinfo * init option * location) H.t = H.create 113

(** A mapping from the new names to the original names. Used in PASS2 when we
 * rename variables. *)
let originalVarNames: (string, string) H.t = H.create 113

(* Initialize the module *)
let init () =
  H.clear sAlpha;
  H.clear eAlpha;
  H.clear vtAlpha;

  H.clear vEnv;

  H.clear vEq;
  H.clear sEq;
  H.clear eEq;
  H.clear tEq;
  H.clear iEq;

  H.clear vSyn;
  H.clear sSyn;
  H.clear eSyn;
  H.clear tSyn;
  H.clear iSyn;

  theFile := [];
  theFileTypes := [];

  H.clear formalNames;
  H.clear inlineBodies;

  currentFidx := 0;
  currentDeclIdx := 0;
  H.clear fileNames;

  H.clear emittedVarDecls;
  H.clear emittedCompDecls;

  H.clear emittedFunDefn;
  H.clear emittedVarDefn;

  H.clear originalVarNames


(* Some enumerations have to be turned into an integer. We implement this by
 * introducing a special enumeration type which we'll recognize later to be
 * an integer *)
let intEnumInfo =
  { ename = "!!!intEnumInfo!!!"; (* This is otherwise invalid *)
    eitems = [];
    eattr = [];
    ereferenced = false;
  }
(* And add it to the equivalence graph *)
let intEnumInfoNode =
  getNode eEq eSyn 0 intEnumInfo.ename intEnumInfo
                     (Some (locUnknown, 0))

    (* Combine the types. Raises the Failure exception with an error message.
     * isdef says whether the new type is for a definition *)
type combineWhat =
    CombineFundef (* The new definition is for a function definition. The old
                   * is for a prototype *)
  | CombineFunarg (* Comparing a function argument type with an old prototype
                   * arg *)
  | CombineFunret (* Comparing the return of a function with that from an old
                   * prototype *)
  | CombineOther


let rec combineTypes (what: combineWhat)
                     (oldfidx: int)  (oldt: typ)
                     (fidx: int) (t: typ)  : typ =
  match oldt, t with
  | TVoid olda, TVoid a -> TVoid (addAttributes olda a)
  | TInt (oldik, olda), TInt (ik, a) ->
      let combineIK oldk k =
        if oldk == k then oldk else
        (* GCC allows a function definition to have a more precise integer
         * type than a prototype that says "int" *)
        if not !msvcMode && oldk = IInt && bitsSizeOf t <= 32
           && (what = CombineFunarg || what = CombineFunret)
        then
          k
        else (
          let msg =
            P.sprint ~width:80
              (P.dprintf
                 "(different integer types %a and %a)"
                 d_type oldt d_type t) in
          raise (Failure msg)
        )
      in
      TInt (combineIK oldik ik, addAttributes olda a)

  | TFloat (oldfk, olda), TFloat (fk, a) ->
      let combineFK oldk k =
        if oldk == k then oldk else
        (* GCC allows a function definition to have a more precise integer
         * type than a prototype that says "double" *)
        if not !msvcMode && oldk = FDouble && k = FFloat
           && (what = CombineFunarg || what = CombineFunret)
        then
          k
        else
          raise (Failure "(different floating point types)")
      in
      TFloat (combineFK oldfk fk, addAttributes olda a)

  | TEnum (oldei, olda), TEnum (ei, a) ->
      (* Matching enumerations always succeeds. But sometimes it maps both
       * enumerations to integers *)
      matchEnumInfo oldfidx oldei fidx ei;
      TEnum (oldei, addAttributes olda a)


        (* Strange one. But seems to be handled by GCC *)
  | TEnum (oldei, olda) , TInt(IInt, a) -> TEnum(oldei,
                                                 addAttributes olda a)

        (* Strange one. But seems to be handled by GCC. Warning. Here we are
         * leaking types from new to old  *)
  | TInt(IInt, olda), TEnum (ei, a) -> TEnum(ei, addAttributes olda a)

  | TComp (oldci, olda) , TComp (ci, a) ->
      matchCompInfo oldfidx oldci fidx ci;
      (* If we get here we were successful *)
      TComp (oldci, addAttributes olda a)

  | TArray (oldbt, oldsz, olda), TArray (bt, sz, a) ->
      let combbt = combineTypes CombineOther oldfidx oldbt fidx bt in
      let combinesz =
        match oldsz, sz with
          None, Some _ -> sz
        | Some _, None -> oldsz
        | None, None -> oldsz
        | Some oldsz', Some sz' ->
            let samesz =
              match constFold true oldsz', constFold true sz' with
                Const(CInt64(oldi, _, _)), Const(CInt64(i, _, _)) -> oldi = i
              | _, _ -> false
            in
            if samesz then oldsz else
            raise (Failure "(different array sizes)")
      in
      TArray (combbt, combinesz, addAttributes olda a)

  | TPtr (oldbt, olda), TPtr (bt, a) ->
      TPtr (combineTypes CombineOther oldfidx oldbt fidx bt,
            addAttributes olda a)

        (* WARNING: In this case we are leaking types from new to old !! *)
  | TFun (_, _, _, [Attr("missingproto",_)]), TFun _ -> t


  | TFun _, TFun (_, _, _, [Attr("missingproto",_)]) -> oldt

  | TFun (oldrt, oldargs, oldva, olda), TFun (rt, args, va, a) ->
      let newrt =
        combineTypes
          (if what = CombineFundef then CombineFunret else CombineOther)
          oldfidx oldrt fidx rt
      in
      if oldva != va then
        raise (Failure "(diferent vararg specifiers)");
      (* If one does not have arguments, believe the one with the
      * arguments *)
      let newargs =
        if oldargs = None then args else
        if args = None then oldargs else
        let oldargslist = argsToList oldargs in
        let argslist = argsToList args in
        if List.length oldargslist <> List.length argslist then
          raise (Failure "(different number of arguments)")
        else begin
          (* Go over the arguments and update the old ones with the
          * adjusted types *)
          Some
            (List.map2
               (fun (on, ot, oa) (an, at, aa) ->
                 let n = if an <> "" then an else on in
                 let t =
                   combineTypes
                     (if what = CombineFundef then
                       CombineFunarg else CombineOther)
                     oldfidx ot fidx at
                 in
                 let a = addAttributes oa aa in
                 (n, t, a))
               oldargslist argslist)
        end
      in
      TFun (newrt, newargs, oldva, addAttributes olda a)

  | TBuiltin_va_list olda, TBuiltin_va_list a ->
      TBuiltin_va_list (addAttributes olda a)

  | TNamed (oldt, olda), TNamed (t, a) ->
      matchTypeInfo oldfidx oldt fidx t;
      (* If we get here we were able to match *)
      TNamed(oldt, addAttributes olda a)

        (* Unroll first the new type *)
  | _, TNamed (t, a) ->
      let res = combineTypes what oldfidx oldt fidx t.ttype in
      typeAddAttributes a res

        (* And unroll the old type as well if necessary *)
  | TNamed (oldt, a), _ ->
      let res = combineTypes what oldfidx oldt.ttype fidx t in
      typeAddAttributes a res

  | _ -> (
      (* raise (Failure "(different type constructors)") *)
      let msg:string = (P.sprint 1000 (P.dprintf "(different type constructors: %a vs. %a)"
                                                 d_type oldt  d_type t)) in
      raise (Failure msg)
    )


(* Match two compinfos and throw a Failure if they do not match *)
and matchCompInfo (oldfidx: int) (oldci: compinfo)
                     (fidx: int)    (ci: compinfo) : unit =
  if oldci.cstruct <> ci.cstruct then
    raise (Failure "(different struct/union types)");
  (* See if we have a mapping already *)
  (* Make the nodes if not already made. Actually return the
  * representatives *)
  let oldcinode = getNode sEq sSyn oldfidx oldci.cname oldci None in
  let    cinode = getNode sEq sSyn    fidx    ci.cname    ci None in
  if oldcinode == cinode then (* We already know they are the same *)
        ()
  else begin
    (* Replace with the representative data *)
    let oldci = oldcinode.ndata in
    let oldfidx = oldcinode.nfidx in
    let ci = cinode.ndata in
    let fidx = cinode.nfidx in

    let old_len = List.length oldci.cfields in
    let len = List.length ci.cfields in
    (* It is easy to catch here the case when the new structure is undefined
     * and the old one was defined. We just reuse the old *)
    (* More complicated is the case when the old one is not defined but the
     * new one is. We still reuse the old one and we'll take care of defining
     * it later with the new fields. *)
    if len <> 0 && old_len <> 0 && old_len <> len then (
      let curLoc = !currentLoc in     (* d_global blows this away.. *)
      (trace "merge" (P.dprintf "different # of fields\n%d: %a\n%d: %a\n"
                                old_len  d_global (GCompTag(oldci,locUnknown))
                                    len  d_global (GCompTag(ci,locUnknown))
                     ));
      currentLoc := curLoc;
      let msg = Printf.sprintf
          "(different number of fields in %s and %s: %d != %d.)"
          oldci.cname ci.cname old_len len in
      raise (Failure msg)
    );
    (* We check that they are defined in the same way. While doing this there
     * might be recursion and we have to watch for going into an infinite
     * loop. So we add the assumption that they are equal *)
    let newrep, undo = union oldcinode cinode in
    (* We check the fields but watch for Failure. We only do the check when
     * the lengths are the same. Due to the code above this the other
     * possibility is that one of the length is 0, in which case we reuse the
     * old compinfo. *)
    if old_len = len then
      (try
        List.iter2
          (fun oldf f ->
            if oldf.fbitfield <> f.fbitfield then
              raise (Failure "(different bitfield info)");
            if oldf.fattr <> f.fattr then
              raise (Failure "(different field attributes)");
            (* Make sure the types are compatible *)
            let newtype =
              combineTypes CombineOther oldfidx oldf.ftype fidx f.ftype
            in
            (* Change the type in the representative *)
            oldf.ftype <- newtype;
          )
          oldci.cfields ci.cfields
      with Failure reason -> begin
        (* Our assumption was wrong. Forget the isomorphism *)
        undo ();
        let msg =
          P.sprint ~width:80
            (P.dprintf
               "\n\tFailed assumption that %s and %s are isomorphic %s@!%a@!%a"
               (compFullName oldci) (compFullName ci) reason
               dn_global (GCompTag(oldci,locUnknown))
               dn_global (GCompTag(ci,locUnknown)))
               in
        raise (Failure msg)
      end);
    (* We get here when we succeeded checking that they are equal *)
    newrep.ndata.cattr <- addAttributes oldci.cattr ci.cattr;
    ()
  end

(* Match two enuminfos and throw a Failure if they do not match *)
and matchEnumInfo (oldfidx: int) (oldei: enuminfo)
                   (fidx: int)    (ei: enuminfo) : unit =
  (* Find the node for this enum, no path compression. *)
  let oldeinode = getNode eEq eSyn oldfidx oldei.ename oldei None in
  let einode    = getNode eEq eSyn fidx ei.ename ei None in
  if oldeinode == einode then (* We already know they are the same *)
    ()
  else begin
    (* Replace with the representative data *)
    let oldei = oldeinode.ndata in
    let oldfidx = oldeinode.nfidx in
    let ei = einode.ndata in
    let fidx = einode.nfidx in
    (* Try to match them. But if you cannot just make them both integers *)
    try
      (* We do not have a mapping. They better be defined in the same way *)
      if List.length oldei.eitems <> List.length ei.eitems then
        raise (Failure "(different number of enumeration elements)");
      (* We check that they are defined in the same way. This is a fairly
      * conservative check. *)
      List.iter2
        (fun (old_iname, old_iv, _) (iname, iv, _) ->
          if old_iname <> iname then
            raise (Failure "(different names for enumeration items)");
          let samev =
            match constFold true old_iv, constFold true iv with
              Const(CInt64(oldi, _, _)), Const(CInt64(i, _, _)) -> oldi = i
            | _ -> false
          in
          if not samev then
            raise (Failure "(different values for enumeration items)"))
        oldei.eitems ei.eitems;
      (* Set the representative *)
      let newrep, _ = union oldeinode einode in
      (* We get here if the enumerations match *)
      newrep.ndata.eattr <- addAttributes oldei.eattr ei.eattr;
      ()
    with Failure msg -> begin
      (* Get here if you cannot merge two enumeration nodes *)
      if oldeinode != intEnumInfoNode then begin
        let _ = union oldeinode intEnumInfoNode in ()
      end;
      if einode != intEnumInfoNode then begin
        let _ = union einode intEnumInfoNode in ()
      end;
    end
  end


(* Match two typeinfos and throw a Failure if they do not match *)
and matchTypeInfo (oldfidx: int) (oldti: typeinfo)
                   (fidx: int)      (ti: typeinfo) : unit =
  if oldti.tname = "" || ti.tname = "" then
    E.s (bug "matchTypeInfo for anonymous type\n");
  (* Find the node for this enum, no path compression. *)
  let oldtnode = getNode tEq tSyn oldfidx oldti.tname oldti None in
  let    tnode = getNode tEq tSyn    fidx ti.tname    ti None in
  if oldtnode == tnode then (* We already know they are the same *)
    ()
  else begin
    (* Replace with the representative data *)
    let oldti = oldtnode.ndata in
    let oldfidx = oldtnode.nfidx in
    let ti = tnode.ndata in
    let fidx = tnode.nfidx in
    (* Flx_cil_check that they are the same *)
    (try
      ignore (combineTypes CombineOther oldfidx oldti.ttype fidx ti.ttype);
    with Failure reason -> begin
      let msg =
        P.sprint ~width:80
          (P.dprintf
             "\n\tFailed assumption that %s and %s are isomorphic %s"
             oldti.tname ti.tname reason) in
      raise (Failure msg)
    end);
    let _ = union oldtnode tnode in
    ()
  end

(* Scan all files and do two things *)
(* 1. Initialize the alpha renaming tables with the names of the globals so
 * that when we come in the second pass to generate new names, we do not run
 * into conflicts.  *)
(* 2. For all declarations of globals unify their types. In the process
 * construct a set of equivalence classes on type names, structure and
 * enumeration tags  *)
(* 3. We clean the referenced flags *)

let rec oneFilePass1 (f:file) : unit =
  H.add fileNames !currentFidx f.fileName;
  if debugMerge || !E.verboseFlag then
    ignore (E.log "Pre-merging (%d) %s\n" !currentFidx f.fileName);
  currentDeclIdx := 0;
  if f.globinitcalled || f.globinit <> None then
    E.s (E.warn "Merging file %s has global initializer" f.fileName);

  (* We scan each file and we look at all global varinfo. We see if globals
   * with the same name have been encountered before and we merge those types
   * *)
  let matchVarinfo (vi: varinfo) (l: location * int) =
    ignore (registerAlphaName vtAlpha None vi.vname);
    (* Make a node for it and put it in vEq *)
    let vinode = mkSelfNode vEq vSyn !currentFidx vi.vname vi (Some l) in
    try
      let oldvinode = find true (H.find vEnv vi.vname) in
      let oldloc, _ =
        match oldvinode.nloc with
          None -> E.s (bug "old variable is undefined")
        | Some l -> l
      in
      let oldvi     = oldvinode.ndata in
      (* There is an old definition. We must combine the types. Do this first
       * because it might fail *)
      let newtype =
        try
          combineTypes CombineOther
            oldvinode.nfidx oldvi.vtype
            !currentFidx vi.vtype;
        with (Failure reason) -> begin
          (* Go ahead *)
          let f = if !ignore_merge_conflicts then warn else error in
          ignore (f "Incompatible declaration for %s (from %s(%d)).@! Previous was at %a (from %s (%d)) %s "
                    vi.vname (H.find fileNames !currentFidx) !currentFidx
                    d_loc oldloc
                    (H.find fileNames oldvinode.nfidx) oldvinode.nfidx
                    reason);
          raise Not_found
        end
      in
      let newrep, _ = union oldvinode vinode in
      (* We do not want to turn non-"const" globals into "const" one. That
       * can happen if one file declares the variable a non-const while
       * others declare it as "const". *)
      if hasAttribute "const" (typeAttrs vi.vtype) !=
         hasAttribute "const" (typeAttrs oldvi.vtype) then begin
        newrep.ndata.vtype <- typeRemoveAttributes ["const"] newtype;
      end else begin
        newrep.ndata.vtype <- newtype;
      end;
      (* clean up the storage.  *)
      let newstorage =
        if vi.vstorage = oldvi.vstorage || vi.vstorage = Extern then
          oldvi.vstorage
        else if oldvi.vstorage = Extern then vi.vstorage
        (* Sometimes we turn the NoStorage specifier into Static for inline
         * functions *)
        else if oldvi.vstorage = Static &&
                vi.vstorage = NoStorage then Static
        else begin
          ignore (warn "Inconsistent storage specification for %s. Now is %a and previous was %a at %a"
                    vi.vname d_storage vi.vstorage d_storage oldvi.vstorage
                    d_loc oldloc);
          vi.vstorage
        end
      in
      newrep.ndata.vstorage <- newstorage;
      newrep.ndata.vattr <- addAttributes oldvi.vattr vi.vattr;
      ()
    with Not_found -> (* Not present in the previous files. Remember it for
                       * later  *)
      H.add vEnv vi.vname vinode

  in
  List.iter
    (function
      | GVarDecl (vi, l) | GVar (vi, _, l) ->
          currentLoc := l;
          incr currentDeclIdx;
          vi.vreferenced <- false;
          if vi.vstorage <> Static then begin
            matchVarinfo vi (l, !currentDeclIdx);
          end

      | GFun (fdec, l) ->
          currentLoc := l;
          incr currentDeclIdx;
          (* Save the names of the formal arguments *)
          let _, args, _, _ = splitFunctionTypeVI fdec.svar in
          H.add formalNames (!currentFidx, fdec.svar.vname)
            (List.map (fun (fn, _, _) -> fn) (argsToList args));
          fdec.svar.vreferenced <- false;
          (* Force inline functions to be static. *)
          (* GN: This turns out to be wrong. inline functions are external,
           * unless specified to be static. *)
          (*
          if fdec.svar.vinline && fdec.svar.vstorage = NoStorage then
            fdec.svar.vstorage <- Static;
          *)
          if fdec.svar.vstorage <> Static then begin
            matchVarinfo fdec.svar (l, !currentDeclIdx)
          end else begin
            if fdec.svar.vinline && mergeInlines then
              (* Just create the nodes for inline functions *)
              ignore (getNode iEq iSyn !currentFidx
                        fdec.svar.vname fdec.svar (Some (l, !currentDeclIdx)))
          end
              (* Make nodes for the defined type and structure tags *)
      | GType (t, l) ->
          incr currentDeclIdx;
          t.treferenced <- false;
          if t.tname <> "" then (* The empty names are just for introducing
                                 * undefined comp tags *)
            ignore (getNode tEq tSyn !currentFidx t.tname t
                      (Some (l, !currentDeclIdx)))
          else begin (* Go inside and clean the referenced flag for the
                      * declared tags *)
            match t.ttype with
              TComp (ci, _) ->
                ci.creferenced <- false;
                (* Create a node for it *)
                ignore (getNode sEq sSyn !currentFidx ci.cname ci None)

            | TEnum (ei, _) ->
                ei.ereferenced <- false;
                ignore (getNode eEq eSyn !currentFidx ei.ename ei None);

            | _ -> E.s (bug "Anonymous Gtype is not TComp")
          end

      | GCompTag (ci, l) ->
          incr currentDeclIdx;
          ci.creferenced <- false;
          ignore (getNode sEq sSyn !currentFidx ci.cname ci
                    (Some (l, !currentDeclIdx)))
      | GEnumTag (ei, l) ->
          incr currentDeclIdx;
          ei.ereferenced <- false;
          ignore (getNode eEq eSyn !currentFidx ei.ename ei
                    (Some (l, !currentDeclIdx)))

      | _ -> ())
    f.globals


(* Try to merge synonyms. Do not give an error if they fail to merge *)
let doMergeSynonyms
    (syn : (string, 'a node) H.t)
    (eq : (int * string, 'a node) H.t)
    (compare : int -> 'a -> int -> 'a -> unit) (* A comparison function that
                                                * throws Failure if no match *)
    : unit =
  H.iter (fun n node ->
    if not node.nmergedSyns then begin
      (* find all the nodes for the same name *)
      let all = H.find_all syn n in
      let rec tryone (classes: 'a node list) (* A number of representatives
                                              * for this name *)
                     (nd: 'a node) : 'a node list (* Returns an expanded set
                                                   * of classes *) =
        nd.nmergedSyns <- true;
        (* Compare in turn with all the classes we have so far *)
        let rec compareWithClasses = function
            [] -> [nd](* No more classes. Add this as a new class *)
          | c :: restc ->
              try
                compare c.nfidx c.ndata  nd.nfidx nd.ndata;
                (* Success. Stop here the comparison *)
                c :: restc
              with Failure _ -> (* Failed. Try next class *)
                c :: (compareWithClasses restc)
        in
        compareWithClasses classes
      in
      (* Start with an empty set of classes for this name *)
      let _ = List.fold_left tryone [] all in
      ()
    end)
    syn


let matchInlines (oldfidx: int) (oldi: varinfo)
                 (fidx: int) (i: varinfo) =
  let oldinode = getNode iEq iSyn oldfidx oldi.vname oldi None in
  let    inode = getNode iEq iSyn    fidx    i.vname    i None in
  if oldinode == inode then
    ()
  else begin
    (* Replace with the representative data *)
    let oldi = oldinode.ndata in
    let oldfidx = oldinode.nfidx in
    let i = inode.ndata in
    let fidx = inode.nfidx in
    (* There is an old definition. We must combine the types. Do this first
     * because it might fail *)
    oldi.vtype <-
       combineTypes CombineOther
         oldfidx oldi.vtype fidx i.vtype;
    (* We get here if we have success *)
    (* Combine the attributes as well *)
    oldi.vattr <- addAttributes oldi.vattr i.vattr;
    (* Do not union them yet because we do not know that they are the same.
     * We have checked only the types so far *)
    ()
  end

(************************************************************
 *
 *  PASS 2
 *
 *
 ************************************************************)

(** Keep track of the functions we have used already in the file. We need
  * this to avoid removing an inline function that has been used already.
  * This can only occur if the inline function is defined after it is used
  * already; a bad style anyway *)
let varUsedAlready: (string, unit) H.t = H.create 111

(** A visitor that renames uses of variables and types *)
class renameVisitorClass = object (self)
  inherit nopCilVisitor

      (* This is either a global variable which we took care of, or a local
       * variable. Must do its type and attributes. *)
  method vvdec (vi: varinfo) = DoChildren

      (* This is a variable use. See if we must change it *)
  method vvrbl (vi: varinfo) : varinfo visitAction =
    if not vi.vglob then DoChildren else
    if vi.vreferenced then begin
      H.add varUsedAlready vi.vname ();
      DoChildren
    end else begin
      match findReplacement true vEq !currentFidx vi.vname with
        None -> DoChildren
      | Some (vi', oldfidx) ->
          if debugMerge then
              ignore (E.log "Renaming use of var %s(%d) to %s(%d)\n"
                        vi.vname !currentFidx vi'.vname oldfidx);
          vi'.vreferenced <- true;
          H.add varUsedAlready vi'.vname ();
          ChangeTo vi'
    end


        (* The use of a type. Change only those types whose underlying info
         * is not a root. *)
  method vtype (t: typ) =
    match t with
      TComp (ci, a) when not ci.creferenced -> begin
        match findReplacement true sEq !currentFidx ci.cname with
          None -> DoChildren
        | Some (ci', oldfidx) ->
            if debugMerge then
              ignore (E.log "Renaming use of %s(%d) to %s(%d)\n"
                        ci.cname !currentFidx ci'.cname oldfidx);
            ChangeTo (TComp (ci', visitCilAttributes (self :> cilVisitor) a))
      end
    | TEnum (ei, a) when not ei.ereferenced -> begin
        match findReplacement true eEq !currentFidx ei.ename with
          None -> DoChildren
        | Some (ei', _) ->
            if ei' == intEnumInfo then
              (* This is actually our friend intEnumInfo *)
              ChangeTo (TInt(IInt, visitCilAttributes (self :> cilVisitor) a))
            else
              ChangeTo (TEnum (ei', visitCilAttributes (self :> cilVisitor) a))
      end

    | TNamed (ti, a) when not ti.treferenced -> begin
        match findReplacement true tEq !currentFidx ti.tname with
          None -> DoChildren
        | Some (ti', _) ->
            ChangeTo (TNamed (ti', visitCilAttributes (self :> cilVisitor) a))
    end

    | _ -> DoChildren

  (* The Field offset might need to be changed to use new compinfo *)
  method voffs = function
      Field (f, o) -> begin
        (* See if the compinfo was changed *)
        if f.fcomp.creferenced then
          DoChildren
        else begin
          match findReplacement true sEq !currentFidx f.fcomp.cname with
            None -> DoChildren (* We did not replace it *)
          | Some (ci', oldfidx) -> begin
              (* First, find out the index of the original field *)
              let rec indexOf (i: int) = function
                  [] ->
                    E.s (bug "Cannot find field %s in %s(%d)\n"
                           f.fname (compFullName f.fcomp) !currentFidx)
                | f' :: rest when f' == f -> i
                | _ :: rest -> indexOf (i + 1) rest
              in
              let index = indexOf 0 f.fcomp.cfields in
              if List.length ci'.cfields <= index then
                E.s (bug "Too few fields in replacement %s(%d) for %s(%d)\n"
                       (compFullName ci') oldfidx
                       (compFullName f.fcomp) !currentFidx);
              let f' = List.nth ci'.cfields index in
              ChangeDoChildrenPost (Field (f', o), fun x -> x)
          end
        end
      end
    | _ -> DoChildren

  method vinitoffs o =
    (self#voffs o)      (* treat initializer offsets same as lvalue offsets *)

end

let renameVisitor = new renameVisitorClass


(** A visitor that renames uses of inline functions that were discovered in
 * pass 2 to be used before they are defined. This is like the renameVisitor
 * except it only looks at the variables (thus it is a bit more efficient)
 * and it also renames forward declarations of the inlines to be removed. *)

class renameInlineVisitorClass = object (self)
  inherit nopCilVisitor

      (* This is a variable use. See if we must change it *)
  method vvrbl (vi: varinfo) : varinfo visitAction =
    if not vi.vglob then DoChildren else
    if vi.vreferenced then begin (* Already renamed *)
      DoChildren
    end else begin
      match findReplacement true vEq !currentFidx vi.vname with
        None -> DoChildren
      | Some (vi', oldfidx) ->
          if debugMerge then
              ignore (E.log "Renaming var %s(%d) to %s(%d)\n"
                        vi.vname !currentFidx vi'.vname oldfidx);
          vi'.vreferenced <- true;
          ChangeTo vi'
    end

  (* And rename some declarations of inlines to remove. We cannot drop this
   * declaration (see small1/combineinline6) *)
  method vglob = function
      GVarDecl(vi, l) when vi.vinline -> begin
        (* Get the original name *)
        let origname =
          try H.find originalVarNames vi.vname
          with Not_found -> vi.vname
        in
        (* Now see if this must be replaced *)
        match findReplacement true vEq !currentFidx origname with
          None -> DoChildren
        | Some (vi', _) -> ChangeTo [GVarDecl (vi', l)]
      end
    | _ -> DoChildren

end
let renameInlinesVisitor = new renameInlineVisitorClass


(* sm: First attempt at a semantic checksum for function bodies.
 * Ideally, two function's checksums would be equal only when their
 * bodies were provably equivalent; but I'm using a much simpler and
 * less accurate heuristic here.  It should be good enough for the
 * purpose I have in mind, which is doing duplicate removal of
 * multiply-instantiated template functions. *)
let functionFlx_cil_checksum (dec: fundec) : int =
begin
  (* checksum the structure of the statements (only) *)
  let rec stmtListSum (lst : stmt list) : int =
    (List.fold_left (fun acc s -> acc + (stmtSum s)) 0 lst)
  and stmtSum (s: stmt) : int =
    (* strategy is to just throw a lot of prime numbers into the
     * computation in hopes of avoiding accidental collision.. *)
    match s.skind with
    | Instr(l) -> 13 + 67*(List.length l)
    | Return(_) -> 17
    | Goto(_) -> 19
    | Break(_) -> 23
    | Continue(_) -> 29
    | If(_,b1,b2,_) -> 31 + 37*(stmtListSum b1.bstmts)
                          + 41*(stmtListSum b2.bstmts)
    | Switch(_,b,_,_) -> 43 + 47*(stmtListSum b.bstmts)
                            (* don't look at stmt list b/c is not part of tree *)
    | Loop(b,_,_,_) -> 49 + 53*(stmtListSum b.bstmts)
    | Block(b) -> 59 + 61*(stmtListSum b.bstmts)
    | TryExcept (b, (il, e), h, _) ->
        67 + 83*(stmtListSum b.bstmts) + 97*(stmtListSum h.bstmts)
    | TryFinally (b, h, _) ->
        103 + 113*(stmtListSum b.bstmts) + 119*(stmtListSum h.bstmts)
  in

  (* disabled 2nd and 3rd measure because they appear to get different
   * values, for the same code, depending on whether the code was just
   * parsed into CIL or had previously been parsed into CIL, printed
   * out, then re-parsed into CIL *)
  let a,b,c,d,e =
    (List.length dec.sformals),        (* # formals *)
    0 (*(List.length dec.slocals)*),         (* # locals *)
    0 (*dec.smaxid*),                        (* estimate of internal statement count *)
    (List.length dec.sbody.bstmts),    (* number of statements at outer level *)
    (stmtListSum dec.sbody.bstmts) in  (* checksum of statement structure *)
  (*(trace "sm" (P.dprintf "sum: %s is %d %d %d %d %d\n"*)
  (*                       dec.svar.vname a b c d e));*)
  2*a + 3*b + 5*c + 7*d + 11*e
end


(* sm: equality for initializers, etc.; this is like '=', except
 * when we reach shared pieces (like references into the type
 * structure), we use '==', to prevent circularity *)
(* update: that's no good; I'm using this to find things which
 * are equal but from different CIL trees, so nothing will ever
 * be '=='.. as a hack I'll just change those places to 'true',
 * so these functions are not now checking proper equality..
 * places where equality is not complete are marked "INC" *)
let rec equalInits (x: init) (y: init) : bool =
begin
  match x,y with
  | SingleInit(xe), SingleInit(ye) -> (equalExps xe ye)
  | CompoundInit(xt, xoil), CompoundInit(yt, yoil) ->
      (*(xt == yt) &&*)  (* INC *)       (* types need to be identically equal *)
      let rec equalLists xoil yoil : bool =
        match xoil,yoil with
        | ((xo,xi) :: xrest), ((yo,yi) :: yrest) ->
            (equalOffsets xo yo) &&
            (equalInits xi yi) &&
            (equalLists xrest yrest)
        | [], [] -> true
        | _, _ -> false
      in
      (equalLists xoil yoil)
  | _, _ -> false
end

and equalOffsets (x: offset) (y: offset) : bool =
begin
  match x,y with
  | NoOffset, NoOffset -> true
  | Field(xfi,xo), Field(yfi,yo) ->
      (xfi.fname = yfi.fname) &&     (* INC: same fieldinfo name.. *)
      (equalOffsets xo yo)
  | Index(xe,xo), Index(ye,yo) ->
      (equalExps xe ye) &&
      (equalOffsets xo yo)
  | _,_ -> false
end

and equalExps (x: exp) (y: exp) : bool =
begin
  match x,y with
  | Const(xc), Const(yc) ->        xc = yc   ||    (* safe to use '=' on literals *)
    (
      (* CIL changes (unsigned)0 into 0U during printing.. *)
      match xc,yc with
      | CInt64(xv,_,_),CInt64(yv,_,_) ->
          (Int64.to_int xv) = 0   &&     (* ok if they're both 0 *)
          (Int64.to_int yv) = 0
      | _,_ -> false
    )
  | Lval(xl), Lval(yl) ->          (equalLvals xl yl)
  | SizeOf(xt), SizeOf(yt) ->      true (*INC: xt == yt*)  (* identical types *)
  | SizeOfE(xe), SizeOfE(ye) ->    (equalExps xe ye)
  | AlignOf(xt), AlignOf(yt) ->    true (*INC: xt == yt*)
  | AlignOfE(xe), AlignOfE(ye) ->  (equalExps xe ye)
  | UnOp(xop,xe,xt), UnOp(yop,ye,yt) ->
      xop = yop &&
      (equalExps xe ye) &&
      true  (*INC: xt == yt*)
  | BinOp(xop,xe1,xe2,xt), BinOp(yop,ye1,ye2,yt) ->
      xop = yop &&
      (equalExps xe1 ye1) &&
      (equalExps xe2 ye2) &&
      true  (*INC: xt == yt*)
  | CastE(xt,xe), CastE(yt,ye) ->
      (*INC: xt == yt &&*)
      (equalExps xe ye)
  | AddrOf(xl), AddrOf(yl) ->      (equalLvals xl yl)
  | StartOf(xl), StartOf(yl) ->    (equalLvals xl yl)

  (* initializers that go through CIL multiple times sometimes lose casts they
   * had the first time; so allow a different of a cast *)
  | CastE(xt,xe), ye ->
      (equalExps xe ye)
  | xe, CastE(yt,ye) ->
      (equalExps xe ye)

  | _,_ -> false
end

and equalLvals (x: lval) (y: lval) : bool =
begin
  match x,y with
  | (Var(xv),xo), (Var(yv),yo) ->
      (* I tried, I really did.. the problem is I see these names
       * before merging collapses them, so __T123 != __T456,
       * so whatever *)
      (*(xv.vname = vy.vname) &&      (* INC: same varinfo names.. *)*)
      (equalOffsets xo yo)

  | (Mem(xe),xo), (Mem(ye),yo) ->
      (equalExps xe ye) &&
      (equalOffsets xo yo)
  | _,_ -> false
end

let equalInitOpts (x: init option) (y: init option) : bool =
begin
  match x,y with
  | None,None -> true
  | Some(xi), Some(yi) -> (equalInits xi yi)
  | _,_ -> false
end


  (* Now we go once more through the file and we rename the globals that we
   * keep. We also scan the entire body and we replace references to the
   * representative types or variables. We set the referenced flags once we
   * have replaced the names. *)
let oneFilePass2 (f: file) =
  if debugMerge || !E.verboseFlag then
    ignore (E.log "Final merging phase (%d): %s\n"
              !currentFidx f.fileName);
  currentDeclIdx := 0; (* Even though we don't need it anymore *)
  H.clear varUsedAlready;
  H.clear originalVarNames;
  (* If we find inline functions that are used before being defined, and thus
   * before knowing that we can throw them away, then we mark this flag so
   * that we can make another pass over the file *)
  let repeatPass2 = ref false in
  (* Keep a pointer to the contents of the file so far *)
  let savedTheFile = !theFile in

  let processOneGlobal (g: global) : unit =
      (* Process a varinfo. Reuse an old one, or rename it if necessary *)
    let processVarinfo (vi: varinfo) (vloc: location) : varinfo =
      if vi.vreferenced then
        vi (* Already done *)
      else begin
        (* Maybe it is static. Rename it then *)
        if vi.vstorage = Static then begin
          let newName, _ = newAlphaName vtAlpha None vi.vname in
          (* Remember the original name *)
          H.add originalVarNames newName vi.vname;
          if debugMerge then ignore (E.log "renaming %s at %a to %s\n"
                                           vi.vname d_loc vloc newName);
          vi.vname <- newName;
          vi.vid <- H.hash vi.vname;
          vi.vreferenced <- true;
          vi
        end else begin
          (* Find the representative *)
          match findReplacement true vEq !currentFidx vi.vname with
            None -> vi (* This is the representative *)
          | Some (vi', _) -> (* Reuse some previous one *)
              vi'.vreferenced <- true; (* Mark it as done already *)
              vi'.vaddrof <- vi.vaddrof || vi'.vaddrof;
              vi'
        end
      end
    in
    try
      match g with
      | GVarDecl (vi, l) as g ->
          currentLoc := l;
          incr currentDeclIdx;
          let vi' = processVarinfo vi l in
          if vi != vi' then (* Drop this declaration *) ()
          else if H.mem emittedVarDecls vi'.vname then (* No need to keep it *)
            ()
          else begin
            H.add emittedVarDecls vi'.vname true; (* Remember that we emitted
                                                   * it  *)
            mergePushGlobals (visitCilGlobal renameVisitor g)
          end

      | GVar (vi, init, l) as g ->
          currentLoc := l;
          incr currentDeclIdx;
          let vi' = processVarinfo vi l in
          (* We must keep this definition even if we reuse this varinfo,
           * because maybe the previous one was a declaration *)
          H.add emittedVarDecls vi.vname true; (* Remember that we emitted it*)

          let emitIt:bool = (not mergeGlobals) ||
            try
              let prevVar, prevInitOpt, prevLoc =
                (H.find emittedVarDefn vi'.vname) in
              (* previously defined; same initializer? *)
              if (equalInitOpts prevInitOpt init.init) then (
                (trace "mergeGlob"
                  (P.dprintf "dropping global var %s at %a in favor of the one at %a\n"
                             vi'.vname  d_loc l  d_loc prevLoc));
                false  (* do not emit *)
              )
              else (
                (ignore (warn "global var %s at %a has different initializer than %a\n"
                              vi'.vname  d_loc l  d_loc prevLoc));
                (* emit it so we get a compiler error.. I think it would be
                 * better to give an error message and *not* emit, since doing
                 * this explicitly violates the CIL invariant of only one GVar
                 * per name, but the rest of this file is very permissive so
                 * I'll be similarly permissive.. *)
                true
              )
            with Not_found -> (
              (* no previous definition *)
              (H.add emittedVarDefn vi'.vname (vi', init.init, l));
              true     (* emit it *)
            )
          in

          if emitIt then
            mergePushGlobals (visitCilGlobal renameVisitor (GVar(vi', init, l)))

      | GFun (fdec, l) as g ->
          currentLoc := l;
          incr currentDeclIdx;
          (* We apply the renaming *)
          fdec.svar <- processVarinfo fdec.svar l;
          (* Get the original name. *)
          let origname =
            try H.find originalVarNames fdec.svar.vname
            with Not_found -> fdec.svar.vname
          in
          (* Go in there and rename everything as needed *)
          let fdec' =
            match visitCilGlobal renameVisitor g with
              [GFun(fdec', _)] -> fdec'
            | _ -> E.s (unimp "renameVisitor for GFun returned something else")
          in
          let g' = GFun(fdec', l) in
          (* Now restore the parameter names *)
          let _, args, _, _ = splitFunctionTypeVI fdec'.svar in
          let oldnames, foundthem =
            try H.find formalNames (!currentFidx, origname), true
            with Not_found -> begin
              ignore (warnOpt "Cannot find %s in formalNames" origname);
              [], false
            end
          in
          if foundthem then begin
            let argl = argsToList args in
            if List.length oldnames <> List.length argl then
              E.s (unimp "After merging the function has more arguments");
            List.iter2
              (fun oldn a -> if oldn <> "" then a.vname <- oldn)
              oldnames fdec.sformals;
            (* Reflect them in the type *)
            setFormals fdec fdec.sformals
          end;
          (** See if we can remove this inline function *)
          if fdec'.svar.vinline && mergeInlines then begin
            let printout =
              (* Temporarily turn of printing of lines *)
              let oldprintln = !lineDirectiveStyle in
              lineDirectiveStyle := None;
              (* Temporarily set the name to all functions in the same way *)
              let newname = fdec'.svar.vname in
              fdec'.svar.vname <- "@@alphaname@@";
              (* If we must do alpha conversion then temporarily set the
               * names of the local variables and formals in a standard way *)
              let nameId = ref 0 in
              let newName () = incr nameId;  in
              let oldNames : string list ref = ref [] in
              let renameOne (v: varinfo) =
                oldNames := v.vname :: !oldNames;
                incr nameId;
                v.vname <- "___alpha" ^ string_of_int !nameId
              in
              let undoRenameOne (v: varinfo) =
                match !oldNames with
                  n :: rest ->
                    oldNames := rest;
                    v.vname <- n
                | _ -> E.s (bug "undoRenameOne")
              in
              (* Remember the original type *)
              let origType = fdec'.svar.vtype in
              if mergeInlinesWithAlphaConvert then begin
                (* Rename the formals *)
                List.iter renameOne fdec'.sformals;
                (* Reflect in the type *)
                setFormals fdec' fdec'.sformals;
                (* Now do the locals *)
                List.iter renameOne fdec'.slocals
              end;
              (* Now print it *)
              let res = d_global () g' in
              lineDirectiveStyle := oldprintln;
              fdec'.svar.vname <- newname;
              if mergeInlinesWithAlphaConvert then begin
                (* Do the locals in reverse order *)
                List.iter undoRenameOne (List.rev fdec'.slocals);
                (* Do the formals in reverse order *)
                List.iter undoRenameOne (List.rev fdec'.sformals);
                (* Restore the type *)
                fdec'.svar.vtype <- origType;
              end;
              res
            in
            (* Make a node for this inline function using the original name. *)
            let inode =
              getNode vEq vSyn !currentFidx origname fdec'.svar
                (Some (l, !currentDeclIdx))
            in
            if debugInlines then begin
              ignore (E.log "getNode %s(%d) with loc=%a. declidx=%d\n"
                        inode.nname inode.nfidx
                        d_nloc inode.nloc
                        !currentDeclIdx);
              ignore (E.log
                        "Looking for previous definition of inline %s(%d)\n"
                        origname !currentFidx);
            end;
            try
              let oldinode = H.find inlineBodies printout in
              if debugInlines then
                ignore (E.log "  Matches %s(%d)\n"
                          oldinode.nname oldinode.nfidx);
              (* There is some other inline function with the same printout.
               * We should reuse this, but watch for the case when the inline
               * was already used. *)
              if H.mem varUsedAlready fdec'.svar.vname then begin
                if mergeInlinesRepeat then begin
                  repeatPass2 := true
                end else begin
                  ignore (warn "Inline function %s because it is used before it is defined" fdec'.svar.vname);
                  raise Not_found
                end
              end;
              let _ = union oldinode inode in
              (* Clean up the vreferenced bit in the new inline, so that we
               * can rename it. Reset the name to the original one so that
               * we can find the replacement name. *)
              fdec'.svar.vreferenced <- false;
              fdec'.svar.vname <- origname;
              () (* Drop this definition *)
            with Not_found -> begin
              if debugInlines then ignore (E.log " Not found\n");
              H.add inlineBodies printout inode;
              mergePushGlobal g'
            end
          end else begin
            (* either the function is not inline, or we're not attempting to
             * merge inlines *)
            if (mergeGlobals &&
                not fdec'.svar.vinline &&
                fdec'.svar.vstorage <> Static) then
              begin
                (* sm: this is a non-inline, non-static function.  I want to
                * consider dropping it if a same-named function has already
                * been put into the merged file *)
                let curSum = (functionFlx_cil_checksum fdec') in
                (*(trace "mergeGlob" (P.dprintf "I see extern function %s, sum is %d\n"*)
              (*                              fdec'.svar.vname curSum));*)
                try
                  let prevFun, prevLoc, prevSum =
                    (H.find emittedFunDefn fdec'.svar.vname) in
                  (* previous was found *)
                  if (curSum = prevSum) then
                    (trace "mergeGlob"
                       (P.dprintf "dropping duplicate def'n of func %s at %a in favor of that at %a\n"
                          fdec'.svar.vname  d_loc l  d_loc prevLoc))
                  else begin
                    (* the checksums differ, so print a warning but keep the
                     * older one to avoid a link error later.  I think this is
                     * a reasonable approximation of what ld does. *)
                    (ignore (warn "def'n of func %s at %a (sum %d) conflicts with the one at %a (sum %d); keeping the one at %a.\n"
                               fdec'.svar.vname  d_loc l  curSum  d_loc prevLoc
                               prevSum d_loc prevLoc))
                  end
                with Not_found -> begin
                  (* there was no previous definition *)
                  (mergePushGlobal g');
                  (H.add emittedFunDefn fdec'.svar.vname (fdec', l, curSum))
                end
              end else begin
                (* not attempting to merge global functions, or it was static
                 * or inline *)
                mergePushGlobal g'
              end
          end

      | GCompTag (ci, l) as g -> begin
          currentLoc := l;
          incr currentDeclIdx;
          if ci.creferenced then
            ()
          else begin
            match findReplacement true sEq !currentFidx ci.cname with
              None ->
                (* A new one, we must rename it and keep the definition *)
                (* Make sure this is root *)
                (try
                  let nd = H.find sEq (!currentFidx, ci.cname) in
                  if nd.nrep != nd then
                    E.s (bug "Setting creferenced for struct %s(%d) which is not root!\n"
                           ci.cname !currentFidx);
                with Not_found -> begin
                  E.s (bug "Setting creferenced for struct %s(%d) which is not in the sEq!\n"
                         ci.cname !currentFidx);
                end);
                let newname, _ = newAlphaName sAlpha None ci.cname in
                ci.cname <- newname;
                ci.creferenced <- true;
                ci.ckey <- H.hash (compFullName ci);
                (* Now we should visit the fields as well *)
                H.add emittedCompDecls ci.cname true; (* Remember that we
                                                       * emitted it  *)
                mergePushGlobals (visitCilGlobal renameVisitor g)
            | Some (oldci, oldfidx) -> begin
                (* We are not the representative. Drop this declaration
                 * because we'll not be using it. *)
                ()
            end
          end
      end
      | GEnumTag (ei, l) as g -> begin
          currentLoc := l;
          incr currentDeclIdx;
          if ei.ereferenced then
            ()
          else begin
            match findReplacement true eEq !currentFidx ei.ename with
              None -> (* We must rename it *)
                let newname, _ = newAlphaName eAlpha None ei.ename in
                ei.ename <- newname;
                ei.ereferenced <- true;
                (* And we must rename the items to using the same name space
                 * as the variables *)
                ei.eitems <-
                   List.map
                     (fun (n, i, loc) ->
                       let newname, _ = newAlphaName vtAlpha None n in
                       newname, i, loc)
                     ei.eitems;
                mergePushGlobals (visitCilGlobal renameVisitor g);
            | Some (ei', _) -> (* Drop this since we are reusing it from
                                * before *)
                ()
          end
      end
      | GCompTagDecl (ci, l) -> begin
          currentLoc := l; (* This is here just to introduce an undefined
                            * structure. But maybe the structure was defined
                            * already.  *)
          (* Do not increment currentDeclIdx because it is not incremented in
           * pass 1*)
          if H.mem emittedCompDecls ci.cname then
            () (* It was already declared *)
          else begin
            H.add emittedCompDecls ci.cname true;
            (* Keep it as a declaration *)
            mergePushGlobal g;
          end
      end

      | GEnumTagDecl (ei, l) ->
          currentLoc := l;
          (* Do not increment currentDeclIdx because it is not incremented in
           * pass 1*)
          (* Keep it as a declaration *)
          mergePushGlobal g


      | GType (ti, l) as g -> begin
          currentLoc := l;
          incr currentDeclIdx;
          if ti.treferenced then
            ()
          else begin
            match findReplacement true tEq !currentFidx ti.tname with
              None -> (* We must rename it and keep it *)
                let newname, _ = newAlphaName vtAlpha None ti.tname in
                ti.tname <- newname;
                ti.treferenced <- true;
                mergePushGlobals (visitCilGlobal renameVisitor g);
            | Some (ti', _) ->(* Drop this since we are reusing it from
                * before *)
                  ()
          end
      end
      | g -> mergePushGlobals (visitCilGlobal renameVisitor g)
  with e -> begin
    let globStr:string = (P.sprint 1000 (P.dprintf
      "error when merging global %a: %s"
      d_global g  (Printexc.to_string e))) in
    ignore (E.log "%s\n" globStr);
    (*"error when merging global: %s\n" (Printexc.to_string e);*)
    mergePushGlobal (GText (P.sprint 80
                              (P.dprintf "/* error at %t:" d_thisloc)));
    mergePushGlobal g;
    mergePushGlobal (GText ("*************** end of error*/"));
    raise e
  end
  in
  (* Now do the real PASS 2 *)
  List.iter processOneGlobal f.globals;
  (* See if we must re-visit the globals in this file because an inline that
   * is being removed was used before we saw the definition and we decided to
   * remove it *)
  if mergeInlinesRepeat && !repeatPass2 then begin
    if debugMerge || !E.verboseFlag then
      ignore (E.log "Repeat final merging phase (%d): %s\n"
                !currentFidx f.fileName);
    (* We are going to rescan the globals we have added while processing this
     * file. *)
    let theseGlobals : global list ref = ref [] in
    (* Scan a list of globals until we hit a given tail *)
    let rec scanUntil (tail: 'a list) (l: 'a list) =
      if tail == l then ()
      else
        match l with
        | [] -> E.s (bug "mergecil: scanUntil could not find the marker\n")
        | g :: rest ->
            theseGlobals := g :: !theseGlobals;
            scanUntil tail rest
    in
    (* Collect in theseGlobals all the globals from this file *)
    theseGlobals := [];
    scanUntil savedTheFile !theFile;
    (* Now reprocess them *)
    theFile := savedTheFile;
    List.iter (fun g ->
                 theFile := (visitCilGlobal renameInlinesVisitor g) @ !theFile)
      !theseGlobals;
    (* Now check if we have inlines that we could not remove
    H.iter (fun name _ ->
      if not (H.mem inlinesRemoved name) then
        ignore (warn "Could not remove inline %s. I have no idea why!\n"
                  name))
      inlinesToRemove *)
  end


let merge (files: file list) (newname: string) : file =
  init ();

  (* Make the first pass over the files *)
  currentFidx := 0;
  List.iter (fun f -> oneFilePass1 f; incr currentFidx) files;

  (* Now maybe try to force synonyms to be equal *)
  if mergeSynonyms then begin
    doMergeSynonyms sSyn sEq matchCompInfo;
    doMergeSynonyms eSyn eEq matchEnumInfo;
    doMergeSynonyms tSyn tEq matchTypeInfo;
    if mergeInlines then begin
      (* Copy all the nodes from the iEq to vEq as well. This is needed
       * because vEq will be used for variable renaming *)
      H.iter (fun k n -> H.add vEq k n) iEq;
      doMergeSynonyms iSyn iEq matchInlines;
    end
  end;

  (* Now maybe dump the graph *)
  if debugMerge then begin
    dumpGraph "type" tEq;
    dumpGraph "struct and union" sEq;
    dumpGraph "enum" eEq;
    dumpGraph "variable" vEq;
    if mergeInlines then dumpGraph "inline" iEq;
  end;
  (* Make the second pass over the files. This is when we start rewriting the
   * file *)
  currentFidx := 0;
  List.iter (fun f -> oneFilePass2 f; incr currentFidx) files;

  (* Now reverse the result and return the resulting file *)
  let rec revonto acc = function
      [] -> acc
    | x :: t -> revonto (x :: acc) t
  in
  let res =
    { fileName = newname;
      globals  = revonto (revonto [] !theFile) !theFileTypes;
      globinit = None;
      globinitcalled = false } in
  init (); (* Make the GC happy *)
  (* We have made many renaming changes and sometimes we have just guessed a
   * name wrong. Make sure now that the local names are unique. *)
  uniqueVarNames res;
  res





@h=tangler('src/compiler/cil/flx_cil_mergecil.mli')
@select(h)
(** Set this to true to ignore the merge conflicts *)
val ignore_merge_conflicts: bool ref

(** Merge a number of CIL files *)
val merge: Flx_cil_cil.file list -> string -> Flx_cil_cil.file

@h=tangler('src/compiler/cil/flx_cil_rmtmps.ml')
@select(h)
(* rmtmps.ml *)
(* implementation for rmtmps.mli *)

open Flx_cil_pretty
open Flx_cil_cil
module H = Hashtbl
module E = Flx_cil_errormsg
module U = Flx_cil_util



let trace = Flx_cil_trace.trace "rmtmps"



(***********************************************************************
 *
 *  Clearing of "referenced" bits
 *
 *)


let clearReferencedBits file =
  let considerGlobal global =
    match global with
    | GType (info, _) ->
        trace (dprintf "clearing mark: %a\n" d_shortglobal global);
        info.treferenced <- false

    | GEnumTag (info, _)
    | GEnumTagDecl (info, _) ->
        trace (dprintf "clearing mark: %a\n" d_shortglobal global);
        info.ereferenced <- false

    | GCompTag (info, _)
    | GCompTagDecl (info, _) ->
        trace (dprintf "clearing mark: %a\n" d_shortglobal global);
        info.creferenced <- false

    | GVar ({vname = name} as info, _, _)
    | GVarDecl ({vname = name} as info, _) ->
        trace (dprintf "clearing mark: %a\n" d_shortglobal global);
        info.vreferenced <- false

    | GFun ({svar = info} as func, _) ->
        trace (dprintf "clearing mark: %a\n" d_shortglobal global);
        info.vreferenced <- false;
        let clearMark local =
          trace (dprintf "clearing mark: local %s\n" local.vname);
          local.vreferenced <- false
        in
        List.iter clearMark func.slocals

    | _ ->
        ()
  in
  iterGlobals file considerGlobal


(***********************************************************************
 *
 *  Scanning and categorization of pragmas
 *
 *)


(* collections of names of things to keep *)
type collection = (string, unit) H.t
type keepers = {
    typedefs : collection;
    enums : collection;
    structs : collection;
    unions : collection;
    defines : collection;
  }


(* rapid transfer of control when we find a malformed pragma *)
exception Bad_pragma

let ccureddeepcopystring = "ccureddeepcopy"
(* Save this length so we don't recompute it each time. *)
let ccureddeepcopystring_length = String.length ccureddeepcopystring

(* CIL and CCured define several pragmas which prevent removal of
 * various global symbols.  Here we scan for those pragmas and build
 * up collections of the corresponding symbols' names.
 *)

let categorizePragmas file =

  (* names of things which should be retained *)
  let keepers = {
    typedefs = H.create 0;
    enums = H.create 0;
    structs = H.create 0;
    unions = H.create 0;
    defines = H.create 1
  } in

  (* populate these name collections in light of each pragma *)
  let considerPragma =

    let badPragma location pragma =
      ignore (warnLoc location "Invalid argument to pragma %s" pragma)
    in

    function
      | GPragma (Attr ("cilnoremove" as directive, args), location) ->
          (* a very flexible pragma: can retain typedefs, enums,
           * structs, unions, or globals (functions or variables) *)
          begin
            let processArg arg =
              try
                match arg with
                | AStr specifier ->
                    (* isolate and categorize one symbol name *)
                    let collection, name =
                      (* Two words denotes a typedef, enum, struct, or
                       * union, as in "type foo" or "enum bar".  A
                       * single word denotes a global function or
                       * variable. *)
                      let whitespace = Str.regexp "[ \t]+" in
                      let words = Str.split whitespace specifier in
                      match words with
                      | ["type"; name] ->
                          keepers.typedefs, name
                      | ["enum"; name] ->
                          keepers.enums, name
                      | ["struct"; name] ->
                          keepers.structs, name
                      | ["union"; name] ->
                          keepers.unions, name
                      | [name] ->
                          keepers.defines, name
                      | _ ->
                          raise Bad_pragma
                    in
                    H.add collection name ()
                | _ ->
                    raise Bad_pragma
              with Bad_pragma ->
                badPragma location directive
            in
            List.iter processArg args
          end

      (*** Begin CCured-specific checks:  ***)
      (* these pragmas indirectly require that we keep the function named in
          -- the first arguments of boxmodelof and ccuredwrapperof, and
          -- the third argument of ccureddeepcopy*. *)
      | GPragma (Attr("ccuredwrapper" as directive, attribute :: _), location) ->
          begin
            match attribute with
            | AStr name ->
                H.add keepers.defines name ()
            | _ ->
                badPragma location directive
          end
      | GPragma (Attr("ccuredvararg" as directive, funcname :: (ASizeOf t) :: _), location) ->
          begin
            match t with
            | TComp(c,_) when c.cstruct -> (* struct *)
                H.add keepers.structs c.cname ()
            | TComp(c,_) -> (* union *)
                H.add keepers.unions c.cname ()
            | TNamed(ti,_) ->
                H.add keepers.typedefs ti.tname ()
            | TEnum(ei, _) ->
                H.add keepers.enums ei.ename ()
            | _ ->
                ()
          end
      | GPragma (Attr(directive, _ :: _ :: attribute :: _), location)
           when String.length directive > ccureddeepcopystring_length
               && (Str.first_chars directive ccureddeepcopystring_length)
                   = ccureddeepcopystring ->
          begin
            match attribute with
            | AStr name ->
                H.add keepers.defines name ()
            | _ ->
                badPragma location directive
          end
      (** end CCured-specific stuff **)
      | _ ->
          ()
  in
  iterGlobals file considerPragma;
  keepers



(***********************************************************************
 *
 *  Function body elimination from pragmas
 *
 *)


(* When performing global slicing, any functions not explicitly marked
 * as pragma roots are reduced to mere declarations.  This leaves one
 * with a reduced source file that still compiles to object code, but
 * which contains the bodies of only explicitly retained functions.
 *)

let amputateFunctionBodies keptGlobals file =
  let considerGlobal = function
    | GFun ({svar = {vname = name} as info}, location)
      when not (H.mem keptGlobals name) ->
        trace (dprintf "slicing: reducing to prototype: function %s\n" name);
        GVarDecl (info, location)
    | other ->
        other
  in
  mapGlobals file considerGlobal



(***********************************************************************
 *
 *  Root collection from pragmas
 *
 *)


let isPragmaRoot keepers = function
  | GType ({tname = name} as info, _) ->
      H.mem keepers.typedefs name
  | GEnumTag ({ename = name} as info, _)
  | GEnumTagDecl ({ename = name} as info, _) ->
      H.mem keepers.enums name
  | GCompTag ({cname = name; cstruct = structure} as info, _)
  | GCompTagDecl ({cname = name; cstruct = structure} as info, _) ->
      let collection = if structure then keepers.structs else keepers.unions in
      H.mem collection name
  | GVar ({vname = name} as info, _, _)
  | GVarDecl ({vname = name} as info, _)
  | GFun ({svar = {vname = name} as info}, _) ->
      H.mem keepers.defines name
  | _ ->
      false



(***********************************************************************
 *
 *  Common root collecting utilities
 *
 *)


let traceRoot reason global =
  trace (dprintf "root (%s): %a@!" reason d_shortglobal global);
  true


let traceNonRoot reason global =
  trace (dprintf "non-root (%s): %a@!" reason d_shortglobal global);
  false


let hasExportingAttribute funvar =
  let rec isExportingAttribute = function
    | Attr ("constructor", []) -> true
    | Attr ("destructor", []) -> true
    | _ -> false
  in
  List.exists isExportingAttribute funvar.vattr



(***********************************************************************
 *
 *  Root collection from external linkage
 *
 *)


(* Exported roots are those global symbols which are visible to the
 * linker and dynamic loader.  For variables, this consists of
 * anything that is not "static".  For functions, this consists of:
 *
 * - functions declared extern inline
 * - functions declared neither inline nor static
 * - functions bearing a "constructor" or "destructor" attribute
 *)

let isExportedRoot global =
  let result = match global with
  | GVar ({vstorage = storage}, _, _) as global
    when storage != Static ->
      true
  | GFun ({svar = v} as fundec, _) as global ->
      if hasExportingAttribute v then
        true
      else if v.vstorage = Extern then (* Keep all extern functions *)
        true
      else if v.vstorage = Static then (* Do not keep static functions *)
        false
      else if v.vinline then (* Do not keep inline functions, unless they
                              * are Extern also *)
        false
      else
        true
  | global ->
      false
  in
  trace (dprintf "exported root -> %b for %a@!" result d_shortglobal global);
  result



(***********************************************************************
 *
 *  Root collection for complete programs
 *
 *)


(* Exported roots are "main()" and functions bearing a "constructor"
 * or "destructor" attribute.  These are the only things which must be
 * retained in a complete program.
 *)

let isCompleteProgramRoot global =
  let result = match global with
  | GFun ({svar = {vname = "main"; vstorage = vstorage} as info}, _) ->
      vstorage <> Static
  | GFun (fundec, _)
    when hasExportingAttribute fundec.svar ->
      true
  | _ ->
      false
  in
  trace (dprintf "complete program root -> %b for %a@!" result d_shortglobal global);
  result


(***********************************************************************
 *
 *  Transitive reachability closure from roots
 *
 *)


(* This visitor recursively marks all reachable types and variables as used. *)
class markReachableVisitor globalMap = object (self)
  inherit nopCilVisitor

  method vglob = function
    | GType (typeinfo, _) ->
        typeinfo.treferenced <- true;
        DoChildren
    | GCompTag (compinfo, _)
    | GCompTagDecl (compinfo, _) ->
        compinfo.creferenced <- true;
        DoChildren
    | GEnumTag (enuminfo, _)
    | GEnumTagDecl (enuminfo, _) ->
        enuminfo.ereferenced <- true;
        DoChildren
    | GVar (varinfo, _, _)
    | GVarDecl (varinfo, _)
    | GFun ({svar = varinfo}, _) ->
        varinfo.vreferenced <- true;
        DoChildren
    | _ ->
        SkipChildren

  method vvrbl v =
    if not v.vreferenced then
      begin
        let name = v.vname in
        if v.vglob then
          trace (dprintf "marking transitive use: global %s\n" name)
        else
          trace (dprintf "marking transitive use: local %s\n" name);

        (* If this is a global, we need to keep everything used in its
         * definition and declarations. *)
        if v.vglob then
          begin
            trace (dprintf "descending: global %s\n" name);
            let descend global =
              ignore (visitCilGlobal (self :> cilVisitor) global)
            in
            let globals = Hashtbl.find_all globalMap name in
            List.iter descend globals
          end
        else
          v.vreferenced <- true;
      end;
    SkipChildren

  method vtype typ =
    let old : bool =
      let visitAttrs attrs =
        ignore (visitCilAttributes (self :> cilVisitor) attrs)
      in
      let visitType typ =
        ignore (visitCilType (self :> cilVisitor) typ)
      in
      match typ with
      | TEnum(e, attrs) ->
          let old = e.ereferenced in
          if not old then
            begin
              trace (dprintf "marking transitive use: enum %s\n" e.ename);
              e.ereferenced <- true;
              visitAttrs attrs;
              visitAttrs e.eattr
            end;
          old

      | TComp(c, attrs) ->
          let old = c.creferenced in
          if not old then
            begin
              trace (dprintf "marking transitive use: compound %s\n" c.cname);
              c.creferenced <- true;

              (* to recurse, we must ask explicitly *)
              let recurse f = visitType f.ftype in
              List.iter recurse c.cfields;
              visitAttrs attrs;
              visitAttrs c.cattr
            end;
          old

      | TNamed(ti, attrs) ->
          let old = ti.treferenced in
          if not old then
            begin
              trace (dprintf "marking transitive use: typedef %s\n" ti.tname);
              ti.treferenced <- true;

              (* recurse deeper into the type referred-to by the typedef *)
              (* to recurse, we must ask explicitly *)
              visitType ti.ttype;
              visitAttrs attrs
            end;
          old

      | _ ->
          (* for anything else, just look inside it *)
          false
    in
    if old then
      SkipChildren
    else
      DoChildren
end


let markReachable file isRoot =
  (* build a mapping from global names back to their definitions & declarations *)
  let globalMap = Hashtbl.create 137 in
  let considerGlobal global =
    match global with
    | GFun ({svar = info}, _)
    | GVar (info, _, _)
    | GVarDecl (info, _) ->
        Hashtbl.add globalMap info.vname global
    | _ ->
        ()
  in
  iterGlobals file considerGlobal;

  (* mark everything reachable from the global roots *)
  let visitor = new markReachableVisitor globalMap in
  let visitIfRoot global =
    if isRoot global then
      begin
        trace (dprintf "traversing root global: %a\n" d_shortglobal global);
        ignore (visitCilGlobal visitor global)
      end
    else
      trace (dprintf "skipping non-root global: %a\n" d_shortglobal global)
  in
  iterGlobals file visitIfRoot


(**********************************************************************
 *
 * Marking and removing of unused labels
 *
 **********************************************************************)

(* We keep only one label, preferably one that was not introduced by CIL.
 * Scan a list of labels and return the data for the label that should be
 * kept, and the remaining filtered list of labels *)
let labelsToKeep (ll: label list) : (string * location * bool) * label list =
  let rec loop (sofar: string * location * bool) = function
      [] -> sofar, []
    | l :: rest ->
        let newlabel, keepl =
          match l with
          | Case _ | Default _ -> sofar, true
          | Label (ln, lloc, isorig) -> begin
              match isorig, sofar with
              | false, ("", _, _) ->
                  (* keep this one only if we have no label so far *)
                  (ln, lloc, isorig), false
              | false, _ -> sofar, false
              | true, (_, _, false) ->
                  (* this is an original label; prefer it to temporary or
                   * missing labels *)
                  (ln, lloc, isorig), false
              | true, _ -> sofar, false
          end
        in
        let newlabel', rest' = loop newlabel rest in
        newlabel', (if keepl then l :: rest' else rest')
  in
  loop ("", locUnknown, false) ll

class markUsedLabels (labelMap: (string, unit) H.t) = object
  inherit nopCilVisitor

  method vstmt (s: stmt) =
    match s.skind with
      Goto (dest, _) ->
        let (ln, _, _), _ = labelsToKeep !dest.labels in
        if ln = "" then
          E.s (E.bug "rmtmps: destination of statement does not have labels");
        (* Mark it as used *)
        H.replace labelMap ln ();
        DoChildren

    | _ -> DoChildren

   (* No need to go into expressions or instructions *)
  method vexpr _ = SkipChildren
  method vinst _ = SkipChildren
  method vtype _ = SkipChildren
end

class removeUnusedLabels (labelMap: (string, unit) H.t) = object
  inherit nopCilVisitor

  method vstmt (s: stmt) =
    let (ln, lloc, lorig), lrest = labelsToKeep s.labels in
    s.labels <-
       (if ln <> "" && H.mem labelMap ln then (* We had labels *)
         (Label(ln, lloc, lorig) :: lrest)
       else
         lrest);
    DoChildren

   (* No need to go into expressions or instructions *)
  method vexpr _ = SkipChildren
  method vinst _ = SkipChildren
  method vtype _ = SkipChildren
end

(***********************************************************************
 *
 *  Removal of unused symbols
 *
 *)


(* regular expression matching names of uninteresting locals *)
let uninteresting =
  let names = [
    (* Flx_cil_cil.makeTempVar *)
    "__cil_tmp";

    (* sm: I don't know where it comes from but these show up all over. *)
    (* this doesn't seem to do what I wanted.. *)
    "iter";

    (* various macros in glibc's <bits/string2.h> *)
    "__result";
    "__s"; "__s1"; "__s2";
    "__s1_len"; "__s2_len";
    "__retval"; "__len";

    (* various macros in glibc's <ctype.h> *)
    "__c"; "__res";

    (* We remove the __malloc variables *)
  ] in

  (* optional alpha renaming *)
  let alpha = "\\(___[0-9]+\\)?" in

  let pattern = "\\(" ^ (String.concat "\\|" names) ^ "\\)" ^ alpha ^ "$" in
  Str.regexp pattern


let removeUnmarked file =
  let removedLocals = ref [] in

  let filterGlobal global =
    match global with
    (* unused global types, variables, and functions are simply removed *)
    | GType ({treferenced = false}, _)
    | GCompTag ({creferenced = false}, _)
    | GCompTagDecl ({creferenced = false}, _)
    | GEnumTag ({ereferenced = false}, _)
    | GEnumTagDecl ({ereferenced = false}, _)
    | GVar ({vreferenced = false}, _, _)
    | GVarDecl ({vreferenced = false}, _)
    | GFun ({svar = {vreferenced = false}}, _) ->
        trace (dprintf "removing global: %a\n" d_shortglobal global);
        false

    (* retained functions may wish to discard some unused locals *)
    | GFun (func, _) ->
        let rec filterLocal local =
          if not local.vreferenced then
            begin
              (* along the way, record the interesting locals that were removed *)
              let name = local.vname in
              trace (dprintf "removing local: %s\n" name);
              if not (Str.string_match uninteresting name 0) then
                removedLocals := (func.svar.vname ^ "::" ^ name) :: !removedLocals;
            end;
          local.vreferenced
        in
        func.slocals <- List.filter filterLocal func.slocals;
        (* We also want to remove unused labels. We do it all here, including
         * marking the used labels *)
        let usedLabels:(string, unit) H.t = H.create 13 in
        ignore (visitCilBlock (new markUsedLabels usedLabels) func.sbody);
        (* And now we scan again and we remove them *)
        ignore (visitCilBlock (new removeUnusedLabels usedLabels) func.sbody);
        true

    (* all other globals are retained *)
    | _ ->
        trace (dprintf "keeping global: %a\n" d_shortglobal global);
        true
  in
  file.globals <- List.filter filterGlobal file.globals;
  !removedLocals


(***********************************************************************
 *
 *  Exported interface
 *
 *)


type rootsFilter = global -> bool

let isDefaultRoot = isExportedRoot


let keepUnused = ref false

let rec removeUnusedTemps ?(isRoot : rootsFilter = isDefaultRoot) file =
  if !keepUnused || Flx_cil_trace.traceActive "disableTmpRemoval" then
    Flx_cil_trace.trace "disableTmpRemoval" (dprintf "temp removal disabled\n")
  else
    begin
      if !E.verboseFlag then
        ignore (E.log "Removing unused temporaries\n" );

      if Flx_cil_trace.traceActive "printCilTree" then
        dumpFile defaultCilPrinter stdout file;

      (* digest any pragmas that would create additional roots *)
      let keepers = categorizePragmas file in

      (* if slicing, remove the bodies of non-kept functions *)
      if !Flx_cil_cilutil.sliceGlobal then
        amputateFunctionBodies keepers.defines file;

      (* build up the root set *)
      let isRoot global =
        isPragmaRoot keepers global ||
        isRoot global
      in

      (* mark everything reachable from the global roots *)
      clearReferencedBits file;
      markReachable file isRoot;

      (* take out the trash *)
      let removedLocals = removeUnmarked file in

      (* print which original source variables were removed *)
      if false && removedLocals != [] then
        let count = List.length removedLocals in
        if count > 2000 then
          ignore (E.warn "%d unused local variables removed" count)
        else
          ignore (E.warn "%d unused local variables removed:@!%a"
                    count (docList (chr ',' ++ break) text) removedLocals)
    end
@h=tangler('src/compiler/cil/flx_cil_rmtmps.mli')
@select(h)

(* rmtmps.mli *)
(* remove unused things from cil files:               *)
(*   - local temporaries introduced but not used      *)
(*   - global declarations that are not used          *)
(*   - types that are not used                        *)
(*   - labels that are not used (gn)                  *)


(* Some clients may wish to augment or replace the standard strategy
 * for finding the initially reachable roots.  The optional
 * "isRoot" argument to Flx_cil_rmtmps.removeUnusedTemps grants this
 * flexibility.  If given, it should name a function which will return
 * true if a given global should be treated as a retained root.
 *
 * Function Flx_cil_rmtmps.isDefaultRoot encapsulates the default root
 * collection, which consists of those global variables and functions
 * which are visible to the linker and runtime loader.  A client's
 * root filter can use this if the goal is to augment rather than
 * replace the standard logic.  Function Flx_cil_rmtmps.isExportedRoot is an
 * alternate name for this same function.
 *
 * Function Flx_cil_rmtmps.isCompleteProgramRoot is an example of an alternate
 * root collection.  This function assumes that it is operating on a
 * complete program rather than just one object file.  It treats
 * "main()" as a root, as well as any function carrying the
 * "constructor" or "destructor" attribute.  All other globals are
 * candidates for removal, regardless of their linkage.
 *
 * Note that certain CIL- and CCured-specific pragmas induce
 * additional global roots.  This functionality is always present, and
 * is not subject to replacement by "filterRoots".
 *)

type rootsFilter = Flx_cil_cil.global -> bool
val isDefaultRoot : rootsFilter
val isExportedRoot : rootsFilter
val isCompleteProgramRoot : rootsFilter

(* process a complete Flx_cil_cil file *)
val removeUnusedTemps: ?isRoot:rootsFilter -> Flx_cil_cil.file -> unit


val keepUnused: bool ref (* Set this to true to turn off this module *)

@h=tangler('src/compiler/cil/flx_cil_cabs2cil.ml')
@select(h)
(* Type check and elaborate ABS to CIL *)

(* The references to ISO means ANSI/ISO 9899-1999 *)
module A = Flx_cil_cabs
module E = Flx_cil_errormsg
module H = Hashtbl

open Flx_cil_cabs
open Flx_cil_cabs_helper
open Flx_cil_pretty
open Flx_cil_cil
open Flx_cil_trace


let debugGlobal = false

(* Leave a certain global alone. Use a negative number to disable. *)
let nocil: int ref = ref (-1)

(* Indicates whether we're allowed to duplicate small chunks. *)
let allowDuplication: bool ref = ref true

(* ---------- source error message handling ------------- *)
let lu = locUnknown
let cabslu = {lineno = -10; filename = "cabs lu"; byteno = -10;}


(** Interface to the Flx_cil_cprint printer *)
let withFlx_cil_cprint (f: 'a -> unit) (x: 'a) : unit =
  Flx_cil_cprint.commit (); Flx_cil_cprint.flush ();
  let old = !Flx_cil_cprint.out in
  Flx_cil_cprint.out := !E.logChannel;
  f x;
  Flx_cil_cprint.commit (); Flx_cil_cprint.flush ();
  flush !Flx_cil_cprint.out;
  Flx_cil_cprint.out := old


(* Keep a list of functions that were called without a prototype. *)
let noProtoFunctions : (int, bool) H.t = H.create 13

(* Flx_cil_check that s starts with the prefix p *)
let prefix p s =
  let lp = String.length p in
  let ls = String.length s in
  lp <= ls && String.sub s 0 lp = p

(***** COMPUTED GOTO ************)

(* The address of labels are small integers (starting from 0). A computed
 * goto is replaced with a switch on the address of the label. We generate
 * only one such switch and we'll jump to it from all computed gotos. To
 * accomplish this we'll add a local variable to store the target of the
 * goto. *)

(* The local variable in which to put the detination of the goto and the
 * statement where to jump *)
let gotoTargetData: (varinfo * stmt) option ref = ref None

(* The "addresses" of labels *)
let gotoTargetHash: (string, int) H.t = H.create 13
let gotoTargetNextAddr: int ref = ref 0


(********** TRANSPARENT UNION ******)
(* Flx_cil_check if a type is a transparent union, and return the first field if it
 * is *)
let isTransparentUnion (t: typ) : fieldinfo option =
  match unrollType t with
    TComp (comp, _) when not comp.cstruct ->
      (* Turn transparent unions into the type of their first field *)
      if hasAttribute "transparent_union" (typeAttrs t) then begin
        match comp.cfields with
          f :: _ -> Some f
        | _ -> E.s (unimp "Empty transparent union: %s" (compFullName comp))
      end else
        None
  | _ -> None

(* When we process an argument list, remember the argument index which has a
 * transparent union type, along with the original type. We need this to
 * process function definitions *)
let transparentUnionArgs : (int * typ) list ref = ref []

let debugLoc = false
let convLoc (l : cabsloc) =
  if debugLoc then
    ignore (E.log "convLoc at %s: line %d, btye %d\n" l.filename l.lineno l.byteno);
  {line = l.lineno; file = l.filename; byte = l.byteno}


let isOldStyleVarArgName n =
  if !msvcMode then n = "va_alist"
  else n = "__builtin_va_alist"

let isOldStyleVarArgTypeName n =
  if !msvcMode then n = "va_list"  || n = "__ccured_va_list"
  else n = "__builtin_va_alist_t"

(* Weimer
 * multi-character character constants
 * In MSCV, this code works:
 *
 * long l1 = 'abcd';  // note single quotes
 * char * s = "dcba";
 * long * lptr = ( long * )s;
 * long l2 = *lptr;
 * assert(l1 == l2);
 *
 * We need to change a multi-character character literal into the
 * appropriate integer constant. However, the plot sickens: we
 * must also be able to handle things like 'ab\nd' (value = * "d\nba")
 * and 'abc' (vale = *"cba").
 *
 * First we convert 'AB\nD' into the list [ 65 ; 66 ; 10 ; 68 ], then we
 * multiply and add to get the desired value.
 *)

(* Given a character constant (like 'a' or 'abc') as a list of 64-bit
 * values, turn it into a CIL constant.  Multi-character constants are
 * treated as multi-digit numbers with radix given by the bit width of
 * the specified type (either char or wchar_t). *)
let reduce_multichar typ =
  let radix = bitsSizeOf typ in
  List.fold_left
    (fun acc -> Int64.add (Int64.shift_left acc 8))
    Int64.zero

let interpret_character_constant char_list =
  let value = reduce_multichar charType char_list in
  if value < (Int64.of_int 256) then
    (CChr(Char.chr (Int64.to_int value))),(TInt(IChar,[]))
  else begin
    let orig_rep = None (* Some("'" ^ (String.escaped str) ^ "'") *) in
    if value < (Int64.of_int 65536) then
      (CInt64(value,IUShort,orig_rep)),(TInt(IUShort,[]))
    else if value <= (Int64.of_int32 Int32.max_int) then
      (CInt64(value,IULong,orig_rep)),(TInt(IULong,[]))
    else
      (CInt64(value,IULongLong,orig_rep)),(TInt(IULongLong,[]))
  end

(*** EXPRESSIONS *************)

                                        (* We collect here the program *)
let theFile : global list ref = ref []
let theFileTypes : global list ref = ref []

let initGlobals () = theFile := []; theFileTypes := []


let cabsPushGlobal (g: global) =
  pushGlobal g ~types:theFileTypes ~variables:theFile

(* Keep track of some variable ids that must be turned into definitions. We
 * do this when we encounter what appears a definition of a global but
 * without initializer. We leave it a declaration because maybe down the road
 * we see another definition with an initializer. But if we don't see any
 * then we turn the last such declaration into a definition without
 * initializer *)
let mustTurnIntoDef: (int, bool) H.t = H.create 117

(* Globals that have already been defined. Indexed by the variable name. *)
let alreadyDefined: (string, location) H.t = H.create 117

(* Globals that were created due to static local variables. We chose their
 * names to be distinct from any global encountered at the time. But we might
 * see a global with conflicting name later in the file. *)
let staticLocals: (string, varinfo) H.t = H.create 13


(* Typedefs. We chose their names to be distinct from any global encounterd
 * at the time. But we might see a global with conflicting name later in the
 * file *)
let typedefs: (string, typeinfo) H.t = H.create 13

let popGlobals () =
  let rec revonto (tail: global list) = function
      [] -> tail

    | GVarDecl (vi, l) :: rest
      when vi.vstorage != Extern && H.mem mustTurnIntoDef vi.vid ->
        H.remove mustTurnIntoDef vi.vid;
        revonto (GVar (vi, {init = None}, l) :: tail) rest

    | x :: rest -> revonto (x :: tail) rest
  in
  revonto (revonto [] !theFile) !theFileTypes


(********* ENVIRONMENTS ***************)

(* The environment is kept in two distinct data structures. A hash table maps
 * each original variable name into a varinfo (for variables, or an
 * enumeration tag, or a type). (Note that the varinfo might contain an
 * alpha-converted name different from that of the lookup name.) The Ocaml
 * hash tables can keep multiple mappings for a single key. Each time the
 * last mapping is returned and upon deletion the old mapping is restored. To
 * keep track of local scopes we also maintain a list of scopes (represented
 * as lists).  *)
type envdata =
    EnvVar of varinfo                   (* The name refers to a variable
                                         * (which could also be a function) *)
  | EnvEnum of exp * typ                (* The name refers to an enumeration
                                         * tag for which we know the value
                                         * and the host type *)
  | EnvTyp of typ                       (* The name is of the form  "struct
                                         * foo", or "union foo" or "enum foo"
                                         * and refers to a type. Note that
                                         * the name of the actual type might
                                         * be different from foo due to alpha
                                         * conversion *)
  | EnvLabel of string                  (* The name refers to a label. This
                                         * is useful for GCC's locally
                                         * declared labels. The lookup name
                                         * for this category is "label foo" *)

let env : (string, envdata * location) H.t = H.create 307
(* We also keep a global environment. This is always a subset of the env *)
let genv : (string, envdata * location) H.t = H.create 307

 (* In the scope we keep the original name, so we can remove them from the
  * hash table easily *)
type undoScope =
    UndoRemoveFromEnv of string
  | UndoResetAlphaCounter of alphaTableData ref * alphaTableData
  | UndoRemoveFromAlphaTable of string

let scopes :  undoScope list ref list ref = ref []

let isAtTopLevel () =
  !scopes = []


(* When you add to env, you also add it to the current scope *)
let addLocalToEnv (n: string) (d: envdata) =
(*  ignore (E.log "%a: adding local %s to env\n" d_loc !currentLoc n); *)
  H.add env n (d, !currentLoc);
    (* If we are in a scope, then it means we are not at top level. Add the
     * name to the scope *)
  (match !scopes with
    [] -> begin
      match d with
        EnvVar _ ->
          E.s (E.bug "addLocalToEnv: not in a scope when adding %s!" n)
      | _ -> () (* We might add types *)
    end
  | s :: _ ->
      s := (UndoRemoveFromEnv n) :: !s)


let addGlobalToEnv (k: string) (d: envdata) : unit =
(*  ignore (E.log "%a: adding global %s to env\n" d_loc !currentLoc k); *)
  H.add env k (d, !currentLoc);
  (* Also add it to the global environment *)
  H.add genv k (d, !currentLoc)



(* Create a new name based on a given name. The new name is formed from a
 * prefix (obtained from the given name as the longest prefix that ends with
 * a non-digit), followed by a '_' and then by a positive integer suffix. The
 * first argument is a table mapping name prefixes with the largest suffix
 * used so far for that prefix. The largest suffix is one when only the
 * version without suffix has been used. *)
let alphaTable : (string, alphaTableData ref) H.t = H.create 307
        (* vars and enum tags. For composite types we have names like "struct
         * foo" or "union bar" *)

(* To keep different name scopes different, we add prefixes to names
 * specifying the kind of name: the kind can be one of "" for variables or
 * enum tags, "struct" for structures and unions (they share the name space),
 * "enum" for enumerations, or "type" for types *)
let kindPlusName (kind: string)
                 (origname: string) : string =
  if kind = "" then origname else
  kind ^ " " ^ origname


let stripKind (kind: string) (kindplusname: string) : string =
  let l = 1 + String.length kind in
  if l > 1 then
    String.sub kindplusname l (String.length kindplusname - l)
  else
    kindplusname

let newAlphaName (globalscope: bool) (* The name should have global scope *)
                 (kind: string)
                 (origname: string) : string * location =
  let lookupname = kindPlusName kind origname in
  (* If we are in a scope then it means that we are alpha-converting a local
   * name. Go and add stuff to reset the state of the alpha table but only to
   * the top-most scope (that of the enclosing function) *)
  let rec findEnclosingFun = function
      [] -> (* At global scope *)()
    | [s] -> begin
        let prefix = getAlphaPrefix lookupname in
        try
          let countref = H.find alphaTable prefix in
          s := (UndoResetAlphaCounter (countref, !countref)) :: !s
        with Not_found ->
          s := (UndoRemoveFromAlphaTable prefix) :: !s
    end
    | _ :: rest -> findEnclosingFun rest
  in
  if not globalscope then
    findEnclosingFun !scopes;
  let newname, oldloc = Flx_cil_cil.newAlphaName alphaTable None lookupname in
  stripKind kind newname, oldloc




let explodeString (nullterm: bool) (s: string) : char list =
  let rec allChars i acc =
    if i < 0 then acc
    else allChars (i - 1) ((String.get s i) :: acc)
  in
  allChars (-1 + String.length s)
    (if nullterm then [Char.chr 0] else [])

(*** In order to process GNU_BODY expressions we must record that a given
 *** COMPUTATION is interesting *)
let gnu_body_result : (A.statement * ((exp * typ) option ref)) ref
    = ref (A.NOP cabslu, ref None)

(*** When we do statements we need to know the current return type *)
let currentReturnType : typ ref = ref (TVoid([]))
let currentFunctionFDEC: fundec ref = ref dummyFunDec


let lastStructId = ref 0
let anonStructName (k: string) (suggested: string) =
  incr lastStructId;
  "__anon" ^ k ^ (if suggested <> "" then "_"  ^ suggested else "")
  ^ "_" ^ (string_of_int (!lastStructId))


let constrExprId = ref 0


let startFile () =
  H.clear env;
  H.clear genv;
  H.clear alphaTable;
  lastStructId := 0



let enterScope () =
  scopes := (ref []) :: !scopes

     (* Exit a scope and clean the environment. We do not yet delete from
      * the name table *)
let exitScope () =
  let this, rest =
    match !scopes with
      car :: cdr -> car, cdr
    | [] -> E.s (error "Not in a scope")
  in
  scopes := rest;
  let rec loop = function
      [] -> ()
    | UndoRemoveFromEnv n :: t ->
        H.remove env n; loop t
    | UndoRemoveFromAlphaTable n :: t -> H.remove alphaTable n; loop t
    | UndoResetAlphaCounter (vref, oldv) :: t ->
        vref := oldv;
        loop t
  in
  loop !this

(* Lookup a variable name. Return also the location of the definition. Might
 * raise Not_found  *)
let lookupVar (n: string) : varinfo * location =
  match H.find env n with
    (EnvVar vi), loc -> vi, loc
  | _ -> raise Not_found

let lookupGlobalVar (n: string) : varinfo * location =
  match H.find genv n with
    (EnvVar vi), loc -> vi, loc
  | _ -> raise Not_found

let docEnv () =
  let acc : (string * (envdata * location)) list ref = ref [] in
  let doone () = function
      EnvVar vi, l ->
        dprintf "Var(%s,global=%b) (at %a)" vi.vname vi.vglob d_loc l
    | EnvEnum (tag, typ), l -> dprintf "Enum (at %a)" d_loc l
    | EnvTyp t, l -> text "typ"
    | EnvLabel l, _ -> text ("label " ^ l)
  in
  H.iter (fun k d -> acc := (k, d) :: !acc) env;
  docList line (fun (k, d) -> dprintf "  %s -> %a" k doone d) () !acc



(* Add a new variable. Do alpha-conversion if necessary *)
let alphaConvertVarAndAddToEnv (addtoenv: bool) (vi: varinfo) : varinfo =
(*
  ignore (E.log "%t: alphaConvert(addtoenv=%b) %s" d_thisloc addtoenv vi.vname);
*)
  (* Announce the name to the alpha conversion table *)
  let newname, oldloc = newAlphaName (addtoenv && vi.vglob) "" vi.vname in
  (* Make a copy of the vi if the name has changed. Never change the name for
   * global variables *)
  let newvi =
    if vi.vname = newname then
      vi
    else begin
      if vi.vglob then begin
        (* Perhaps this is because we have seen a static local which happened
         * to get the name that we later want to use for a global. *)
        try
          let static_local_vi = H.find staticLocals vi.vname in
          H.remove staticLocals vi.vname;
          (* Use the new name for the static local *)
          static_local_vi.vname <- newname;
          (* And continue using the last one *)
          vi
        with Not_found -> begin
          (* Or perhaps we have seen a typedef which stole our name. This is
           possible because typedefs use the same name space *)
          try
            let typedef_ti = H.find typedefs vi.vname in
            H.remove typedefs vi.vname;
            (* Use the new name for the typedef instead *)
            typedef_ti.tname <- newname;
            (* And continue using the last name *)
            vi
          with Not_found ->
            E.s (E.error "It seems that we would need to rename global %s (to %s) because of previous occurrence at %a"
                   vi.vname newname d_loc oldloc);
        end
      end else
        copyVarinfo vi newname
    end
  in
  (* Store all locals in the slocals (in reversed order). We'll reverse them
   * and take out the formals at the end of the function *)
  if not vi.vglob then
    !currentFunctionFDEC.slocals <- newvi :: !currentFunctionFDEC.slocals;

  (if addtoenv then
    if vi.vglob then
      addGlobalToEnv vi.vname (EnvVar newvi)
    else
      addLocalToEnv vi.vname (EnvVar newvi));
(*
  ignore (E.log "  new=%s\n" newvi.vname);
*)
(*  ignore (E.log "After adding %s alpha table is: %a\n"
            newvi.vname docAlphaTable alphaTable); *)
  newvi


(* Strip the "const" from the type. It is unfortunate that const variables
 * can only be set in initialization. Once we decided to move all
 * declarations to the top of the functions, we have no way of setting a
 * "const" variable. Furthermore, if the type of the variable is an array or
 * a struct we must recursively strip the "const" from fields and array
 * elements. *)
let rec stripConstLocalType (t: typ) : typ =
  let dc a =
    if hasAttribute "const" a then
      dropAttribute "const" a
    else a
  in
  match t with
  | TPtr (bt, a) ->
      (* We want to be able to detect by pointer equality if the type has
       * changed. So, don't realloc the type unless necessary. *)
      let a' = dc a in if a != a' then TPtr(bt, a') else t
  | TInt (ik, a) ->
      let a' = dc a in if a != a' then TInt(ik, a') else t
  | TFloat(fk, a) ->
      let a' = dc a in if a != a' then TFloat(fk, a') else t
  | TNamed (ti, a) ->
      (* We must go and drop the consts from the typeinfo as well ! *)
      let t' = stripConstLocalType ti.ttype in
      if t != t' then begin
        (* ignore (warn "Stripping \"const\" from typedef %s\n" ti.tname); *)
        ti.ttype <- t'
      end;
      let a' = dc a in if a != a' then TNamed(ti, a') else t

  | TEnum (ei, a) ->
      let a' = dc a in if a != a' then TEnum(ei, a') else t

  | TArray(bt, leno, a) ->
      (* We never assign to the array. So, no need to change the const. But
       * we must change it on the base type *)
      let bt' = stripConstLocalType bt in
      if bt' != bt then TArray(bt', leno, a) else t

  | TComp(ci, a) -> (* Again, no need to change the a. But we must change the
                     * fields. *)
      List.iter
        (fun f ->
          let t' = stripConstLocalType f.ftype in
          if t' != f.ftype then begin
            ignore (warnOpt "Stripping \"const\" from field %s of %s\n"
                      f.fname (compFullName ci));
            f.ftype <- t'
          end)
        ci.cfields;
      t

    (* We never assign functions either *)
  | TFun(rt, args, va, a) -> t
  | TVoid _ -> E.s (bug "cabs2cil: stripConstLocalType: void")
  | TBuiltin_va_list a ->
      let a' = dc a in if a != a' then TBuiltin_va_list a' else t




(* Create a new temporary variable *)
let newTempVar typ =
  let stripConst t =
    let a = typeAttrs t in
    let a1 = dropAttribute "const" a in
    setTypeAttrs t a1
  in
  if !currentFunctionFDEC == dummyFunDec then
    E.s (bug "newTempVar called outside a function");
(*  ignore (E.log "stripConstLocalType(%a) for temporary\n" d_type typ); *)
  let t' = stripConstLocalType typ in
  (* Start with the name "tmp". The alpha converter will fix it *)
  let vi = makeVarinfo false "tmp" t' in
  alphaConvertVarAndAddToEnv false  vi (* Do not add to the environment *)
(*
    { vname = "tmp";  (* addNewVar will make the name fresh *)
      vid   = newVarId "tmp" false;
      vglob = false;
      vtype = t';
      vdecl = locUnknown;
      vinline = false;
      vattr = [];
      vaddrof = false;
      vreferenced = false;   (* sm *)
      vstorage = NoStorage;
    }
*)

let mkAddrOfAndMark ((b, off) as lval) : exp =
  (* Mark the vaddrof flag if b is a variable *)
  (match b with
    Var vi -> vi.vaddrof <- true
  | _ -> ());
  mkAddrOf lval

(* Call only on arrays *)
let mkStartOfAndMark ((b, off) as lval) : exp =
  (* Mark the vaddrof flag if b is a variable *)
  (match b with
    Var vi -> vi.vaddrof <- true
  | _ -> ());
  let res = StartOf lval in
  res



   (* Keep a set of self compinfo for composite types *)
let compInfoNameEnv : (string, compinfo) H.t = H.create 113
let enumInfoNameEnv : (string, enuminfo) H.t = H.create 113


let lookupTypeNoError (kind: string)
                      (n: string) : typ * location =
  let kn = kindPlusName kind n in
  match H.find env kn with
    EnvTyp t, l -> t, l
  | _ -> raise Not_found

let lookupType (kind: string)
               (n: string) : typ * location =
  try
    lookupTypeNoError kind n
  with Not_found ->
    E.s (error "Cannot find type %s (kind:%s)\n" n kind)

(* Create the self ref cell and add it to the map. Return also an indication
 * if this is a new one. *)
let createCompInfo (iss: bool) (n: string) : compinfo * bool =
  (* Add to the self cell set *)
  let key = (if iss then "struct " else "union ") ^ n in
  try
    H.find compInfoNameEnv key, false (* Only if not already in *)
  with Not_found -> begin
    (* Create a compinfo. This will have "cdefined" false. *)
    let res = mkCompInfo iss n (fun _ -> []) [] in
    H.add compInfoNameEnv key res;
    res, true
  end

(* Create the self ref cell and add it to the map. Return an indication
 * whether this is a new one. *)
let createEnumInfo (n: string) : enuminfo * bool =
  (* Add to the self cell set *)
  try
    H.find enumInfoNameEnv n, false (* Only if not already in *)
  with Not_found -> begin
    (* Create a enuminfo *)
    let enum = { ename = n; eitems = [];
                 eattr = []; ereferenced = false; } in
    H.add enumInfoNameEnv n enum;
    enum, true
  end


   (* kind is either "struct" or "union" or "enum" and n is a name *)
let findCompType kind n a =
  let key = kind ^ " " ^ n in
  let makeForward () =
    (* This is a forward reference, either because we have not seen this
     * struct already or because we want to create a version with different
     * attributes  *)
    if kind = "enum" then
      let enum, isnew = createEnumInfo n in
      if isnew then
        cabsPushGlobal (GEnumTagDecl (enum, !currentLoc));
      TEnum (enum, a)
    else
      let iss = if kind = "struct" then true else false in
      let self, isnew = createCompInfo iss n in
      if isnew then
        cabsPushGlobal (GCompTagDecl (self, !currentLoc));
      TComp (self, a)
  in
  try
    let old, _ = lookupTypeNoError kind n in (* already defined  *)
    let olda = typeAttrs old in
    if olda = a then old else makeForward ()
  with Not_found -> makeForward ()


(* A simple visitor that searchs a statement for labels *)
class canDropStmtClass pRes = object
  inherit nopCilVisitor

  method vstmt s =
    if s.labels != [] then
      (pRes := false; SkipChildren)
    else
      if !pRes then DoChildren else SkipChildren

  method vinst _ = SkipChildren
  method vexpr _ = SkipChildren

end
let canDropStatement (s: stmt) : bool =
  let pRes = ref true in
  let vis = new canDropStmtClass pRes in
  ignore (visitCilStmt vis s);
  !pRes

(**** Occasionally we see structs with no name and no fields *)


module BlockChunk =
  struct
    type chunk = {
        stmts: stmt list;
        postins: instr list;              (* Some instructions to append at
                                           * the ends of statements (in
                                           * reverse order)  *)
                                        (* A list of case statements visible at the
                                         * outer level *)
        cases: (label * stmt) list
      }

    let empty =
      { stmts = []; postins = []; cases = []; }

    let isEmpty (c: chunk) =
      c.postins == [] && c.stmts == []

    let isNotEmpty (c: chunk) = not (isEmpty c)

    let i2c (i: instr) =
      { empty with postins = [i] }

    (* Occasionally, we'll have to push postins into the statements *)
    let pushPostIns (c: chunk) : stmt list =
      if c.postins = [] then c.stmts
      else
        let rec toLast = function
            [{skind=Instr il} as s] as stmts ->
              s.skind <- Instr (il @ (List.rev c.postins));
              stmts

          | [] -> [mkStmt (Instr (List.rev c.postins))]

          | a :: rest -> a :: toLast rest
        in
        compactStmts (toLast c.stmts)


    let c2block (c: chunk) : block =
      { battrs = [];
        bstmts = pushPostIns c;
      }

    (* Add an instruction at the end. Never refer to this instruction again
     * after you call this *)
    let (+++) (c: chunk) (i : instr) =
      {c with postins = i :: c.postins}

    (* Append two chunks. Never refer to the original chunks after you call
     * this. And especially never share c2 with somebody else *)
    let (@@) (c1: chunk) (c2: chunk) =
      { stmts = compactStmts (pushPostIns c1 @ c2.stmts);
        postins = c2.postins;
        cases = c1.cases @ c2.cases;
      }

    let skipChunk = empty

    let returnChunk (e: exp option) (l: location) : chunk =
      { stmts = [ mkStmt (Return(e, l)) ];
        postins = [];
        cases = []
      }

    let ifChunk (be: exp) (l: location) (t: chunk) (e: chunk) : chunk =

      { stmts = [ mkStmt(If(be, c2block t, c2block e, l))];
        postins = [];
        cases = t.cases @ e.cases;
      }

        (* We can duplicate a chunk if it has a few simple statements, and if
         * it does not have cases *)
    let duplicateChunk (c: chunk) = (* raises Failure if you should not
                                     * duplicate this chunk *)
      if not !allowDuplication then
        raise (Failure "cannot duplicate: disallowed by user");
      if c.cases != [] then raise (Failure "cannot duplicate: has cases") else
      let pCount = ref (List.length c.postins) in
      { stmts =
        List.map
          (fun s ->
            if s.labels != [] then
              raise (Failure "cannot duplicate: has labels");
            (match s.skind with
              If _ | Switch _ | Loop _ | Block _ ->
                raise (Failure "cannot duplicate: complex stmt")
            | Instr il ->
                pCount := !pCount + List.length il
            | _ -> incr pCount);
            if !pCount > 5 then raise (Failure ("cannot duplicate: too many instr"));
            (* We can just copy it because there is nothing to share here.
             * Except maybe for the ref cell in Goto but it is Ok to share
             * that, I think *)
            { s with sid = s.sid}) c.stmts;
        postins = c.postins; (* There is no shared stuff in instructions *)
        cases = []
      }
(*
    let duplicateChunk (c: chunk) =
      if isEmpty c then c else raise (Failure ("cannot duplicate: isNotEmpty"))
*)
    (* We can drop a chunk if it does not have labels inside *)
    let canDrop (c: chunk) =
      List.for_all canDropStatement c.stmts

    let loopChunk (body: chunk) : chunk =
      (* Make the statement *)
      let loop = mkStmt (Loop (c2block body, !currentLoc, None, None)) in
      { stmts = [ loop (* ; n *) ];
        postins = [];
        cases = body.cases;
      }

    let breakChunk (l: location) : chunk =
      { stmts = [ mkStmt (Break l) ];
        postins = [];
        cases = [];
      }

    let continueChunk (l: location) : chunk =
      { stmts = [ mkStmt (Continue l) ];
        postins = [];
        cases = []
      }

        (* Keep track of the gotos *)
    let backFlx_cil_patchGotos : (string, stmt ref list ref) H.t = H.create 17
    let addGoto (lname: string) (bref: stmt ref) : unit =
      let gotos =
        try
          H.find backFlx_cil_patchGotos lname
        with Not_found -> begin
          let gotos = ref [] in
          H.add backFlx_cil_patchGotos lname gotos;
          gotos
        end
      in
      gotos := bref :: !gotos

        (* Keep track of the labels *)
    let labelStmt : (string, stmt) H.t = H.create 17
    let initLabels () =
      H.clear backFlx_cil_patchGotos;
      H.clear labelStmt

    let resolveGotos () =
      H.iter
        (fun lname gotos ->
          try
            let dest = H.find labelStmt lname in
            List.iter (fun gref -> gref := dest) !gotos
          with Not_found -> begin
            E.s (error "Label %s not found\n" lname)
          end)
        backFlx_cil_patchGotos

        (* Get the first statement in a chunk. Might need to change the
         * statements in the chunk *)
    let getFirstInChunk (c: chunk) : stmt * stmt list =
      (* Get the first statement and add the label to it *)
      match c.stmts with
        s :: _ -> s, c.stmts
      | [] -> (* Add a statement *)
          let n = mkEmptyStmt () in
          n, n :: c.stmts

    let consLabel (l: string) (c: chunk) (loc: location)
                                (in_original_program_text : bool) : chunk =
      (* Get the first statement and add the label to it *)
      let labstmt, stmts' = getFirstInChunk c in
      (* Add the label *)
      labstmt.labels <- Label (l, loc, in_original_program_text) ::
                                labstmt.labels;
      H.add labelStmt l labstmt;
      if c.stmts == stmts' then c else {c with stmts = stmts'}

    let s2c (s:stmt) : chunk =
      { stmts = [ s ];
        postins = [];
        cases = [];
      }

    let gotoChunk (ln: string) (l: location) : chunk =
      let gref = ref dummyStmt in
      addGoto ln gref;
      { stmts = [ mkStmt (Goto (gref, l)) ];
        postins = [];
        cases = [];
      }

    let caseRangeChunk (el: exp list) (l: location) (next: chunk) =
      let fst, stmts' = getFirstInChunk next in
      let labels = List.map (fun e -> Case (e, l)) el in
      let cases  = List.map (fun l -> (l, fst)) labels in
      fst.labels <- labels @ fst.labels;
      { next with stmts = stmts'; cases = cases @ next.cases}

    let defaultChunk (l: location) (next: chunk) =
      let fst, stmts' = getFirstInChunk next in
      let lb = Default l in
      fst.labels <- lb :: fst.labels;
      { next with stmts = stmts'; cases = (lb, fst) :: next.cases}


    let switchChunk (e: exp) (body: chunk) (l: location) =
      (* Make the statement *)
      let switch = mkStmt (Switch (e, c2block body,
                                   List.map (fun (_, s) -> s) body.cases,
                                   l)) in
      { stmts = [ switch (* ; n *) ];
        postins = [];
        cases = [];
      }

    let mkFunctionBody (c: chunk) : block =
      resolveGotos (); initLabels ();
      if c.cases <> [] then
        E.s (error "Switch cases not inside a switch statement\n");
      c2block c

  end

open BlockChunk


(************ Labels ***********)
(* Since we turn dowhile and for loops into while we need to take care in
 * processing the continue statement. For each loop that we enter we place a
 * marker in a list saying what kinds of loop it is. When we see a continue
 * for a Non-while loop we must generate a label for the continue *)
type loopstate =
    While
  | NotWhile of string ref

let continues : loopstate list ref = ref []

let startLoop iswhile =
  continues := (if iswhile then While else NotWhile (ref "")) :: !continues

(* Sometimes we need to create new label names *)
let newLabelName (base: string) = fst (newAlphaName false "label" base)

let continueOrLabelChunk (l: location) : chunk =
  match !continues with
    [] -> E.s (error "continue not in a loop")
  | While :: _ -> continueChunk l
  | NotWhile lr :: _ ->
      if !lr = "" then begin
        lr := newLabelName "__Cont"
      end;
      gotoChunk !lr l

let consLabContinue (c: chunk) =
  match !continues with
    [] -> E.s (error "labContinue not in a loop")
  | While :: rest -> c
  | NotWhile lr :: rest -> if !lr = "" then c else consLabel !lr c !currentLoc false

let exitLoop () =
  match !continues with
    [] -> E.s (error "exit Loop not in a loop")
  | _ :: rest -> continues := rest


(* In GCC we can have locally declared labels. *)
let genNewLocalLabel (l: string) =
  (* Call the newLabelName to register the label name in the alpha conversion
   * table. *)
  let l' = newLabelName l in
  (* Add it to the environment *)
  addLocalToEnv (kindPlusName "label" l) (EnvLabel l');
  l'

let lookupLabel (l: string) =
  try
    match H.find env (kindPlusName "label" l) with
      EnvLabel l', _ -> l'
    | _ -> raise Not_found
  with Not_found ->
    l


(** ALLOCA ***)
let allocaFun =
  let fdec = emptyFunction "alloca" in
  fdec.svar.vtype <-
     TFun(voidPtrType, Some [ ("len", uintType, []) ], false, []);
  fdec

(* Maps local variables that are variable sized arrays to the expression that
 * denotes their length *)
let varSizeArrays : (int, exp) H.t = H.create 17

(**** EXP actions ***)
type expAction =
    ADrop                               (* Drop the result. Only the
                                         * side-effect is interesting *)
  | ASet of lval * typ                  (* Put the result in a given lval,
                                         * provided it matches the type. The
                                         * type is the type of the lval. *)
  | AExp of typ option                  (* Return the exp as usual.
                                         * Optionally we can specify an
                                         * expected type. This is useful for
                                         * constants. The expected type is
                                         * informational only, we do not
                                         * guarantee that the converted
                                         * expression has that type.You must
                                         * use a doCast afterwards to make
                                         * sure. *)
  | AExpLeaveArrayFun                   (* Do it like an expression, but do
                                         * not convert arrays of functions
                                         * into pointers *)


(*** Result of compiling conditional expressions *)
type condExpRes =
    CEExp of chunk * exp (* Do a chunk and then an expression *)
  | CEAnd of condExpRes * condExpRes
  | CEOr  of condExpRes * condExpRes
  | CENot of condExpRes

(******** CASTS *********)
let integralPromotion (t : typ) : typ = (* c.f. ISO 6.3.1.1 *)
  match unrollType t with
          (* We assume that an IInt can hold even an IUShort *)
    TInt ((IShort|IUShort|IChar|ISChar|IUChar), a) -> TInt(IInt, a)
  | TInt _ -> t
  | TEnum (_, a) -> TInt(IInt, a)
  | t -> E.s (error "integralPromotion: not expecting %a" d_type t)


let arithmeticConversion    (* c.f. ISO 6.3.1.8 *)
    (t1: typ)
    (t2: typ) : typ =
  let checkToInt _ = () in  (* dummies for now *)
  let checkToFloat _ = () in
  match unrollType t1, unrollType t2 with
    TFloat(FLongDouble, _), _ -> checkToFloat t2; t1
  | _, TFloat(FLongDouble, _) -> checkToFloat t1; t2
  | TFloat(FDouble, _), _ -> checkToFloat t2; t1
  | _, TFloat (FDouble, _) -> checkToFloat t1; t2
  | TFloat(FFloat, _), _ -> checkToFloat t2; t1
  | _, TFloat (FFloat, _) -> checkToFloat t1; t2
  | _, _ -> begin
      let t1' = integralPromotion t1 in
      let t2' = integralPromotion t2 in
      match unrollType t1', unrollType t2' with
        TInt(IULongLong, _), _ -> checkToInt t2'; t1'
      | _, TInt(IULongLong, _) -> checkToInt t1'; t2'

      (* We assume a long long is always larger than a long  *)
      | TInt(ILongLong, _), _ -> checkToInt t2'; t1'
      | _, TInt(ILongLong, _) -> checkToInt t1'; t2'

      | TInt(IULong, _), _ -> checkToInt t2'; t1'
      | _, TInt(IULong, _) -> checkToInt t1'; t2'


      | TInt(ILong,_), TInt(IUInt,_)
            when bitsSizeOf t1' <= bitsSizeOf t2' -> TInt(IULong,[])
      | TInt(IUInt,_), TInt(ILong,_)
            when bitsSizeOf t2' <= bitsSizeOf t1' -> TInt(IULong,[])

      | TInt(ILong, _), _ -> checkToInt t2'; t1'
      | _, TInt(ILong, _) -> checkToInt t1'; t2'

      | TInt(IUInt, _), _ -> checkToInt t2'; t1'
      | _, TInt(IUInt, _) -> checkToInt t1'; t2'

      | TInt(IInt, _), TInt (IInt, _) -> t1'

      | _, _ -> E.s (error "arithmeticConversion")
  end


(* Specify whether the cast is from the source code *)
let rec castTo ?(fromsource=false)
                (ot : typ) (nt : typ) (e : exp) : (typ * exp ) =
(*
  ignore (E.log "%t: castTo:%s %a->%a\n"
            d_thisloc
            (if fromsource then "(source)" else "")
            d_type ot d_type nt);
*)
  if not fromsource && typeSig ot = typeSig nt then
    (* Do not put the cast if it is not necessary, unless it is from the
     * source. *)
    (ot, e)
  else begin
    let result = (nt, mkCastT e ot nt) in
(*
    ignore (E.log "castTo: ot=%a nt=%a\n  result is %a\n"
              d_type ot d_type nt
              d_plainexp (snd result));
*)
    (* Now see if we can have a cast here *)
    match ot, nt with
      TNamed(r, _), _ -> castTo r.ttype nt e
    | _, TNamed(r, _) -> castTo ot r.ttype e
    | TInt(ikindo,_), TInt(ikindn,_) ->
        (* We used to ignore attributes on integer-integer casts. Not anymore *)
        (* if ikindo = ikindn then (nt, e) else *)
        result

    | TPtr (told, _), TPtr(tnew, _) -> result

    | TInt _, TPtr _ -> result

    | TPtr _, TInt _ -> result

    | TArray _, TPtr _ -> result

    | TArray(t1,_,_), TArray(t2,None,_) when typeSig t1 = typeSig t2 -> (nt, e)

    | TPtr _, TArray(_,_,_) -> (nt, e)

    | TEnum _, TInt _ -> result
    | TFloat _, (TInt _|TEnum _) -> result
    | (TInt _|TEnum _), TFloat _ -> result
    | TFloat _, TFloat _ -> result
    | TInt _, TEnum _ -> result
    | TEnum _, TEnum _ -> result

    | TEnum _, TPtr _ -> result
    | TBuiltin_va_list _, (TInt _ | TPtr _) ->
        result

    | (TInt _ | TPtr _), TBuiltin_va_list _ ->
        ignore (warnOpt "Casting %a to __builtin_va_list" d_type ot);
        result

    | TPtr _, TEnum _ ->
        ignore (warnOpt "Casting a pointer into an enumeration type");
        result

          (* The expression is evaluated for its side-effects *)
    | (TInt _ | TEnum _ | TPtr _ ), TVoid _ ->
        (ot, e)

          (* Even casts between structs are allowed when we are only
           * modifying some attributes *)
    | TComp (comp1, a1), TComp (comp2, a2) when comp1.ckey = comp2.ckey ->
        (nt, e)

    | _ -> E.s (error "cabs2cil: castTo %a -> %a@!" d_type ot d_type nt)
  end


(* A cast that is used for conditional expressions. Pointers are Ok *)
let checkBool (ot : typ) (e : exp) : bool =
  match unrollType ot with
    TInt _ -> true
  | TPtr _ -> true
  | TEnum _ -> true
  | TFloat _ -> true
  |  _ -> E.s (error "castToBool %a" d_type ot)


(* We have our own version of addAttributes that does not allow duplicates *)
let cabsAddAttributes al0 (al: attributes) : attributes =
  if al0 == [] then al else
  List.fold_left
    (fun acc (Attr(an, _) as a) ->
      (* See if the attribute is already in there *)
      match filterAttributes an acc with
        [] -> addAttribute a acc (* Nothing with that name *)
      | a' :: _ ->
          if a = a' then
            acc (* Already in *)
          else begin
            ignore (warnOpt
                      "Duplicate attribute %a along with %a"
                      d_attr a d_attr a');
            (* let acc' = dropAttribute an acc in *)
            (** Keep both attributes *)
            addAttribute a acc
          end)
    al
    al0

let cabsTypeAddAttributes a0 t =
  begin
    match a0 with
    | [] ->
        (* no attributes, keep same type *)
          t
    | _ ->
        (* anything else: add a0 to existing attributes *)
          let add (a: attributes) = cabsAddAttributes a0 a in
          match t with
            TVoid a -> TVoid (add a)
          | TInt (ik, a) ->
              (* Here we have to watch for the mode attribute *)
(* sm: This stuff is to handle a GCC extension where you can request integers*)
(* of specific widths using the "mode" attribute syntax; for example:     *)
(*   typedef int int8_t __attribute__ ((__mode__ (  __QI__ ))) ;          *)
(* The cryptic "__QI__" defines int8_t to be 8 bits wide, instead of the  *)
(* 32 bits you'd guess if you didn't know about "mode".  The relevant     *)
(* testcase is test/small2/mode_sizes.c, and it was inspired by my        *)
(* /usr/include/sys/types.h.                                              *)
(*                                                                        *)
(* A consequence of this handling is that we throw away the mode          *)
(* attribute, which we used to go out of our way to avoid printing anyway.*)
              let ik', a0' =
                (* Go over the list of new attributes and come back with a
                 * filtered list and a new integer kind *)
                List.fold_left
                  (fun (ik', a0') a0one ->
                    match a0one with
                      Attr("mode", [ACons(mode,[])]) -> begin
                        (trace "gccwidth" (dprintf "I see mode %s applied to an int type\n"
                                             mode (* #$@!#@ ML! d_type t *) ));
                        (* the cases below encode the 32-bit assumption.. *)
                        match (ik', mode) with
                        | (IInt, "__QI__")      -> (IChar, a0')
                        | (IInt, "__byte__")    -> (IChar, a0')
                        | (IInt, "__HI__")      -> (IShort,  a0')
                        | (IInt, "__SI__")      -> (IInt, a0')   (* same as t *)
                        | (IInt, "__word__")    -> (IInt, a0')
                        | (IInt, "__pointer__") -> (IInt, a0')
                        | (IInt, "__DI__")      -> (ILongLong, a0')

                        | (IUInt, "__QI__")     -> (IUChar, a0')
                        | (IUInt, "__byte__")   -> (IUChar, a0')
                        | (IUInt, "__HI__")     -> (IUShort, a0')
                        | (IUInt, "__SI__")     -> (IUInt, a0')
                        | (IUInt, "__word__")   -> (IUInt, a0')
                        | (IUInt, "__pointer__")-> (IUInt, a0')
                        | (IUInt, "__DI__")     -> (IULongLong, a0')

                        | _ ->
                            (ignore (error "GCC width mode %s applied to unexpected type, or unexpected mode"
                                       mode));
                            (ik', a0one :: a0')

                      end
                    | _ -> (ik', a0one :: a0'))
                  (ik, [])
                  a0
              in
              TInt (ik', cabsAddAttributes a0' a)

          | TFloat (fk, a) -> TFloat (fk, add a)
          | TEnum (enum, a) -> TEnum (enum, add a)
          | TPtr (t, a) -> TPtr (t, add a)
          | TArray (t, l, a) -> TArray (t, l, add a)
          | TFun (t, args, isva, a) -> TFun(t, args, isva, add a)
          | TComp (comp, a) -> TComp (comp, add a)
          | TNamed (t, a) -> TNamed (t, add a)
          | TBuiltin_va_list a -> TBuiltin_va_list (add a)
  end


(* Do types *)
    (* Combine the types. Raises the Failure exception with an error message.
     * isdef says whether the new type is for a definition *)
type combineWhat =
    CombineFundef (* The new definition is for a function definition. The old
                   * is for a prototype *)
  | CombineFunarg (* Comparing a function argument type with an old prototype
                   * arg *)
  | CombineFunret (* Comparing the return of a function with that from an old
                   * prototype *)
  | CombineOther

(* We sometimes want to succeed in combining two structure types that are
 * identical except for the names of the structs. We keep a list of types
 * that are known to be equal *)
let isomorphicStructs : (string * string, bool) H.t = H.create 15

let rec combineTypes (what: combineWhat) (oldt: typ) (t: typ) : typ =
  match oldt, t with
  | TVoid olda, TVoid a -> TVoid (cabsAddAttributes olda a)
  | TInt (oldik, olda), TInt (ik, a) ->
      let combineIK oldk k =
        if oldk = k then oldk else
        (* GCC allows a function definition to have a more precise integer
         * type than a prototype that says "int" *)
        if not !msvcMode && oldk = IInt && bitsSizeOf t <= 32
           && (what = CombineFunarg || what = CombineFunret) then
          k
        else
          raise (Failure "different integer types")
      in
      TInt (combineIK oldik ik, cabsAddAttributes olda a)
  | TFloat (oldfk, olda), TFloat (fk, a) ->
      let combineFK oldk k =
        if oldk = k then oldk else
        (* GCC allows a function definition to have a more precise integer
         * type than a prototype that says "double" *)
        if not !msvcMode && oldk = FDouble && k = FFloat
           && (what = CombineFunarg || what = CombineFunret) then
          k
        else
          raise (Failure "different floating point types")
      in
      TFloat (combineFK oldfk fk, cabsAddAttributes olda a)
  | TEnum (_, olda), TEnum (ei, a) ->
      TEnum (ei, cabsAddAttributes olda a)

        (* Strange one. But seems to be handled by GCC *)
  | TEnum (oldei, olda) , TInt(IInt, a) -> TEnum(oldei,
                                                 cabsAddAttributes olda a)
        (* Strange one. But seems to be handled by GCC *)
  | TInt(IInt, olda), TEnum (ei, a) -> TEnum(ei, cabsAddAttributes olda a)


  | TComp (oldci, olda) , TComp (ci, a) ->
      if oldci.cstruct <> ci.cstruct then
        raise (Failure "different struct/union types");
      let comb_a = cabsAddAttributes olda a in
      if oldci.cname = ci.cname then
        TComp (oldci, comb_a)
      else
        (* Now maybe they are actually the same *)
        if H.mem isomorphicStructs (oldci.cname, ci.cname) then
          (* We know they are the same *)
          TComp (oldci, comb_a)
        else begin
          (* If one has 0 fields (undefined) while the other has some fields
           * we accept it *)
          let oldci_nrfields = List.length oldci.cfields in
          let ci_nrfields = List.length ci.cfields in
          if oldci_nrfields = 0 then
            TComp (ci, comb_a)
          else if ci_nrfields = 0 then
            TComp (oldci, comb_a)
          else begin
            (* Make sure that at least they have the same number of fields *)
            if  oldci_nrfields <> ci_nrfields then begin
(*
              ignore (E.log "different number of fields: %s had %d and %s had %d\n"
                        oldci.cname oldci_nrfields
                        ci.cname ci_nrfields);
*)
              raise (Failure "different structs(number of fields)");
            end;
            (* Assume they are the same *)
            H.add isomorphicStructs (oldci.cname, ci.cname) true;
            H.add isomorphicStructs (ci.cname, oldci.cname) true;
            (* Flx_cil_check that the fields are isomorphic and watch for Failure *)
            (try
              List.iter2 (fun oldf f ->
                if oldf.fbitfield <> f.fbitfield then
                  raise (Failure "different structs(bitfield info)");
                if oldf.fattr <> f.fattr then
                  raise (Failure "different structs(field attributes)");
                (* Make sure the types are compatible *)
                ignore (combineTypes CombineOther oldf.ftype f.ftype);
                ) oldci.cfields ci.cfields
            with Failure _ as e -> begin
              (* Our assumption was wrong. Forget the isomorphism *)
              ignore (E.log "\tFailed in our assumption that %s and %s are isomorphic\n"
                        oldci.cname ci.cname);
              H.remove isomorphicStructs (oldci.cname, ci.cname);
              H.remove isomorphicStructs (ci.cname, oldci.cname);
              raise e
            end);
            (* We get here if we succeeded *)
            TComp (oldci, comb_a)
          end
        end

  | TArray (oldbt, oldsz, olda), TArray (bt, sz, a) ->
      let newbt = combineTypes CombineOther oldbt bt in
      let newsz =
        if oldsz = sz then sz else
        match oldsz, sz with
          None, Some _ -> sz
        | Some _, None -> oldsz
        | _ -> raise (Failure "different array lengths")
      in
      TArray (newbt, newsz, cabsAddAttributes olda a)

  | TPtr (oldbt, olda), TPtr (bt, a) ->
      TPtr (combineTypes CombineOther oldbt bt, cabsAddAttributes olda a)

  | TFun (_, _, _, [Attr("missingproto",_)]), TFun _ -> t

  | TFun (oldrt, oldargs, oldva, olda), TFun (rt, args, va, a) ->
      let newrt = combineTypes
          (if what = CombineFundef then CombineFunret else CombineOther)
          oldrt rt
      in
      if oldva != va then
        raise (Failure "diferent vararg specifiers");
      (* If one does not have arguments, believe the one with the
      * arguments *)
      let newargs =
        if oldargs = None then args else
        if args = None then oldargs else
        let oldargslist = argsToList oldargs in
        let argslist = argsToList args in
        if List.length oldargslist <> List.length argslist then
          raise (Failure "different number of arguments")
        else begin
          (* Go over the arguments and update the old ones with the
          * adjusted types *)
          Some
            (List.map2
               (fun (on, ot, oa) (an, at, aa) ->
                 (* Update the names. Always prefer the new name. This is
                  * very important if the prototype uses different names than
                  * the function definition. *)
                 let n = if an <> "" then an else on in
                 let t =
                   combineTypes
                     (if what = CombineFundef then
                       CombineFunarg else CombineOther)
                     ot at
                 in
                 let a = addAttributes oa aa in
                 (n, t, a))
               oldargslist argslist)
        end
      in
      TFun (newrt, newargs, oldva, cabsAddAttributes olda a)

  | TNamed (oldt, olda), TNamed (t, a) when oldt.tname = t.tname ->
      TNamed (oldt, cabsAddAttributes olda a)

        (* Unroll first the new type *)
  | _, TNamed (t, a) ->
      let res = combineTypes what oldt t.ttype in
      cabsTypeAddAttributes a res

        (* And unroll the old type as well if necessary *)
  | TNamed (oldt, a), _ ->
      let res = combineTypes what oldt.ttype t in
      cabsTypeAddAttributes a res

  | _ -> raise (Failure "different type constructors")


(* Create and cache varinfo's for globals. Starts with a varinfo but if the
 * global has been declared already it might come back with another varinfo.
 * Returns the varinfo to use (might be the old one), and an indication
 * whether the variable exists already in the environment *)
let makeGlobalVarinfo (isadef: bool) (vi: varinfo) : varinfo * bool =
  try (* See if already defined, in the global environment. We could also
       * look it up in the whole environment but in that case we might see a
       * local. This can happen when we declare an extern variable with
       * global scope but we are in a local scope. *)
    let oldvi, oldloc = lookupGlobalVar vi.vname in
    begin
      try
        oldvi.vtype <-
           combineTypes
             (if isadef then CombineFundef else CombineOther)
             oldvi.vtype vi.vtype
         ;
        (* It was already defined. We must reuse the varinfo.
         * But clean up the storage.  *)
        let newstorage =
          match oldvi.vstorage, vi.vstorage with
          | Extern, other
          | NoStorage, other
          | other, Extern
          | other, NoStorage ->
              other
          | _ ->
              if vi.vstorage != oldvi.vstorage then
                ignore (warn
                          "Inconsistent storage specification for %s. Previous declaration: %a"
                          vi.vname d_loc oldloc);
              vi.vstorage
        in
        oldvi.vinline <- oldvi.vinline || vi.vinline;
        oldvi.vstorage <- newstorage;
        oldvi.vattr <- cabsAddAttributes oldvi.vattr vi.vattr;
        oldvi, true

      with Failure reason ->
        ignore (E.log "old type = %a\n" d_plaintype oldvi.vtype);
        ignore (E.log "new type = %a\n" d_plaintype vi.vtype);
        if !Flx_cil_lexerhack.get_lang () =`C then
          E.s (error "Declaration of %s does not match previous declaration from %a (%s)."
               vi.vname d_loc oldloc reason)
        else begin
          ignore (E.log "[Overload] %s." vi.vname);
          vi, false
        end
    end;


  with Not_found -> begin (* A new one.  *)
    (* Announce the name to the alpha conversion table. This will not
     * actually change the name of the vi. See the definition of
     * alphaConvertVarAndAddToEnv *)
    alphaConvertVarAndAddToEnv true vi, false
  end

let conditionalConversion (t2: typ) (t3: typ) : typ =
  let is_char k = match k with
    IChar | ISChar | IUChar -> true
  | _ -> false in
  let tresult =  (* ISO 6.5.15 *)
    match unrollType t2, unrollType t3 with
      (TInt _ | TEnum _ | TFloat _),
      (TInt _ | TEnum _ | TFloat _) ->
        arithmeticConversion t2 t3
    | TComp (comp2,_), TComp (comp3,_)
          when comp2.ckey = comp3.ckey -> t2
    | TPtr(_, _), TPtr(TVoid _, _) -> t2
    | TPtr(TVoid _, _), TPtr(_, _) -> t3
    | TPtr _, TPtr _ when typeSig t2 = typeSig t3 -> t2
    | TPtr _, TInt _  -> t2 (* most likely comparison with 0 *)
    | TInt _, TPtr _ -> t3 (* most likely comparison with 0 *)

          (* When we compare two pointers of diffent type, we combine them
           * using the same algorithm when combining multiple declarations of
           * a global *)
    | (TPtr _) as t2', (TPtr _ as t3') -> begin
        try combineTypes CombineOther t2' t3'
        with Failure msg -> begin
          ignore (warn "A.QUESTION: %a does not match %a (%s)"
                    d_type (unrollType t2) d_type (unrollType t3) msg);
          t2 (* Just pick one *)
        end
    end
    | _, _ -> E.s (error "A.QUESTION for invalid combination of types")
  in
  tresult

(* Some utilitites for doing initializers *)

let debugInit = false

type preInit =
  | NoInitPre
  | SinglePre of exp
  | CompoundPre of int ref (* the maximum used index *)
                 * preInit array ref (* an array with initializers *)

(* Instructions on how to handle designators *)
type handleDesignators =
  | Handle (* Handle them yourself *)
  | DoNotHandle (* Do not handle them your self *)
  | HandleAsNext (* First behave as if you have a NEXT_INIT. Useful for going
                  * into nested designators *)
  | HandleFirst (* Handle only the first designator *)

(* Set an initializer *)
let rec setOneInit (this: preInit)
                   (o: offset) (e: exp) : preInit =
  match o with
    NoOffset -> SinglePre e
  | _ ->
      let idx, (* Index in the current comp *)
          restoff (* Rest offset *) =
        match o with
        | Index(Const(CInt64(i,_,_)), off) -> Int64.to_int i, off
        | Field (f, off) ->
            (* Find the index of the field *)
            let rec loop (idx: int) = function
                [] -> E.s (bug "Cannot find field %s" f.fname)
              | f' :: _ when f'.fname = f.fname -> idx
              | _ :: restf -> loop (idx + 1) restf
            in
            loop 0 f.fcomp.cfields, off
        | _ -> E.s (bug "setOneInit: non-constant index")
      in
      let pMaxIdx, pArray =
        match this  with
          NoInitPre  -> (* No initializer so far here *)
            ref idx, ref (Array.create (max 32 (idx + 1)) NoInitPre)

        | CompoundPre (pMaxIdx, pArray) ->
            if !pMaxIdx < idx then begin
              pMaxIdx := idx;
              (* Maybe we also need to grow the array *)
              let l = Array.length !pArray in
              if l <= idx then begin
                let growBy = max (max 32 (idx + 1 - l)) (l / 2) in
                let newarray = Array.make (growBy + idx) NoInitPre in
                Array.blit !pArray 0 newarray 0 l;
                pArray := newarray
              end
            end;
            pMaxIdx, pArray
        | SinglePre e ->
            E.s (unimp "Index %d is already initialized" idx)
      in
      assert (idx >= 0 && idx < Array.length !pArray);
      let this' = setOneInit !pArray.(idx) restoff e in
      !pArray.(idx) <- this';
      CompoundPre (pMaxIdx, pArray)


(* collect a CIL initializer, given the original syntactic initializer
 * 'preInit'; this returns a type too, since initialization of an array
 * with unspecified size actually changes the array's type
 * (ANSI C, 6.7.8, para 22) *)
let rec collectInitializer
    (this: preInit)
    (thistype: typ) : (init * typ) =
  if this = NoInitPre then (makeZeroInit thistype), thistype
  else
    match unrollType thistype, this with
    | _ , SinglePre e -> SingleInit e, thistype
    | TArray (bt, leno, at), CompoundPre (pMaxIdx, pArray) ->
        let (len, newtype) =
          (* normal case: use array's declared length, newtype=thistype *)
          try (lenOfArray leno, thistype)

          (* unsized array case, length comes from initializers *)
          with LenOfArray ->
            (!pMaxIdx + 1,
             TArray (bt, Some (integer (!pMaxIdx + 1)), at))
        in
        if !pMaxIdx >= len then
          E.s (E.bug "collectInitializer: too many initializers(%d >= %d)\n"
                 !pMaxIdx len);
        (* len could be extremely big. So omit the last initializers, if they
         * are many (more than 16) *)
(*
        ignore (E.log "collectInitializer: len = %d, pMaxIdx= %d\n"
                  len !pMaxIdx); *)
        let endAt =
          if len - 1 > !pMaxIdx + 16 then
            !pMaxIdx
          else
            len - 1
        in
        (* Make one zero initializer to be used next *)
        let oneZeroInit = makeZeroInit bt in
        let rec collect (acc: (offset * init) list) (idx: int) =
          if idx = -1 then acc
          else
            let thisi =
              if idx > !pMaxIdx then oneZeroInit
              else (fst (collectInitializer !pArray.(idx) bt))
            in
            collect ((Index(integer idx, NoOffset), thisi) :: acc) (idx - 1)
        in

        CompoundInit (thistype, collect [] endAt), newtype

    | TComp (comp, _), CompoundPre (pMaxIdx, pArray) when comp.cstruct ->
        let rec collect (idx: int) = function
            [] -> []
          | f :: restf ->
              if f.fname = missingFieldName then
                collect (idx + 1) restf
              else
                let thisi =
                  if idx > !pMaxIdx then
                    makeZeroInit f.ftype
                  else
                    collectFieldInitializer !pArray.(idx) f
                in
                (Field(f, NoOffset), thisi) :: collect (idx + 1) restf
        in
        CompoundInit (thistype, collect 0 comp.cfields), thistype

    | TComp (comp, _), CompoundPre (pMaxIdx, pArray) when not comp.cstruct ->
        (* Find the field to initialize *)
        let rec findField (idx: int) = function
            [] -> E.s (bug "collectInitializer: union")
          | _ :: rest when idx < !pMaxIdx && !pArray.(idx) = NoInitPre ->
              findField (idx + 1) rest
          | f :: _ when idx = !pMaxIdx ->
              Field(f, NoOffset),
              collectFieldInitializer !pArray.(idx) f
          | _ -> E.s (error "Can initialize only one field for union")
        in
        if !msvcMode && !pMaxIdx != 0 then
          ignore (warn "On MSVC we can initialize only the first field of a union");
        CompoundInit (thistype, [ findField 0 comp.cfields ]), thistype

    | _ -> E.s (unimp "collectInitializer")

and collectFieldInitializer
    (this: preInit)
    (f: fieldinfo) : init =
  (* collect, and rewrite type *)
  let init,newtype = (collectInitializer this f.ftype) in
  f.ftype <- newtype;
  init


type stackElem =
    InArray of offset * typ * int * int ref (* offset of parent, base type,
                                             * length, current index. If the
                                             * array length is unspecified we
                                             * use Int.max_int  *)
  | InComp  of offset * compinfo * fieldinfo list (* offset of parent,
                                                   base comp, current fields *)


(* A subobject is given by its address. The address is read from the end of
 * the list (the bottom of the stack), starting with the current object *)
type subobj = { mutable stack: stackElem list; (* With each stack element we
                                                * store the offset of its
                                                * PARENT  *)
                mutable eof: bool; (* The stack is empty and we reached the
                                    * end *)
                mutable soTyp: typ; (* The type of the subobject. Set using
                                     * normalSubobj after setting stack. *)
                mutable soOff: offset; (* The offset of the subobject. Set
                                        * using normalSubobj after setting
                                        * stack.  *)
                        curTyp: typ; (* Type of current object. See ISO for
                                      * the definition of the current object *)
                        curOff: offset; (* The offset of the current obj *)
                        host: varinfo; (* The host that we are initializing.
                                        * For error messages *)
              }


(* Make a subobject iterator *)
let rec makeSubobj
    (host: varinfo)
    (curTyp: typ)
    (curOff: offset) =
  let so =
    { host = host; curTyp = curTyp; curOff = curOff;
      stack = []; eof = false;
      (* The next are fixed by normalSubobj *)
      soTyp = voidType; soOff = NoOffset } in
  normalSubobj so;
  so

  (* Normalize a stack so the we always point to a valid subobject. Do not
   * descend into type *)
and normalSubobj (so: subobj) : unit =
  match so.stack with
    [] -> so.soOff <- so.curOff; so.soTyp <- so.curTyp
        (* The array is over *)
  | InArray (parOff, bt, leno, current) :: rest ->
      if leno = !current then begin (* The array is over *)
        if debugInit then ignore (E.log "Past the end of array\n");
        so.stack <- rest;
        advanceSubobj so
      end else begin
        so.soTyp <- bt;
        so.soOff <- addOffset (Index(integer !current, NoOffset)) parOff
      end

        (* The fields are over *)
  | InComp (parOff, comp, nextflds) :: rest ->
      if nextflds = [] then begin (* No more fields here *)
        if debugInit then ignore (E.log "Past the end of structure\n");
        so.stack <- rest;
        advanceSubobj so
      end else begin
        let fst = List.hd nextflds in
        so.soTyp <- fst.ftype;
        so.soOff <- addOffset (Field(fst, NoOffset)) parOff
      end

  (* Advance to the next subobject. Always apply to a normalized object *)
and advanceSubobj (so: subobj) : unit =
  if so.eof then E.s (bug "advanceSubobj past end");
  match so.stack with
  | [] -> if debugInit then ignore (E.log "Setting eof to true\n");
          so.eof <- true
  | InArray (parOff, bt, leno, current) :: rest ->
      if debugInit then ignore (E.log "  Advancing to [%d]\n" (!current + 1));
      (* so.stack <- InArray (parOff, bt, leno, current + 1) :: rest; *)
      incr current;
      normalSubobj so

        (* The fields are over *)
  | InComp (parOff, comp, nextflds) :: rest ->
      if debugInit then
        ignore (E.log "Advancing past .%s\n" (List.hd nextflds).fname);
      let flds' = try List.tl nextflds with _ -> E.s (bug "advanceSubobj") in
      so.stack <- InComp(parOff, comp, flds') :: rest;
      normalSubobj so



(* Find the fields to initialize in a composite. *)
let fieldsToInit
    (comp: compinfo)
    (designator: string option)
    : fieldinfo list =
  (* Never look at anonymous fields *)
  let flds1 =
    List.filter (fun f -> f.fname <> missingFieldName) comp.cfields in
  let flds2 =
    match designator with
      None -> flds1
    | Some fn ->
        let rec loop = function
            [] -> E.s (error "Cannot find designated field %s" fn)
          | (f :: _) as nextflds when f.fname = fn -> nextflds
          | _ :: rest -> loop rest
        in
        loop flds1
  in
  (* If it is a union we only initialize one field *)
  match flds2 with
    [] -> []
  | (f :: rest) as toinit ->
      if comp.cstruct then toinit else [f]


let integerArrayLength (leno: exp option) : int =
  match leno with
    None -> max_int
  | Some len -> begin
      try lenOfArray leno
      with LenOfArray ->
        E.s (error "Initializing non-constant-length array\n  length=%a\n"
               d_exp len)
  end

(* sm: I'm sure something like this already exists, but ... *)
let isNone (o : 'a option) : bool =
  match o with
  | None -> true
  | Some _ -> false


let annonCompFieldNameId = ref 0
let annonCompFieldName = "__annonCompField"



(* Flx_cil_utility ***)
let rec replaceLastInList
    (lst: A.expression list)
    (how: A.expression -> A.expression) : A.expression list=
  match lst with
    [] -> []
  | [e] -> [how e]
  | h :: t -> h :: replaceLastInList t how





let convBinOp (bop: A.binary_operator) : binop =
  match bop with
    A.ADD -> PlusA
  | A.SUB -> MinusA
  | A.MUL -> Mult
  | A.DIV -> Div
  | A.MOD -> Mod
  | A.BAND -> BAnd
  | A.BOR -> BOr
  | A.XOR -> BXor
  | A.SHL -> Shiftlt
  | A.SHR -> Shiftrt
  | A.EQ -> Eq
  | A.NE -> Ne
  | A.LT -> Lt
  | A.LE -> Le
  | A.GT -> Gt
  | A.GE -> Ge
  | _ -> E.s (error "convBinOp")

(**** PEEP-HOLE optimizations ***)
let afterConversion (c: chunk) : chunk =
  (* Now scan the statements and find Instr blocks *)
  let collapseCallCast = function
      Call(Some(Var vi, NoOffset), f, args, l),
      Set(destlv, CastE (newt, Lval(Var vi', NoOffset)), _)
      when (not vi.vglob &&
            String.length vi.vname >= 3 &&
            String.sub vi.vname 0 3 = "tmp" &&
            vi' == vi)
      -> Some [Call(Some destlv, f, args, l)]
    | _ -> None
  in
  (* First add in the postins *)
  let sl = pushPostIns c in
  peepHole2 collapseCallCast sl;
  { c with stmts = sl; postins = [] }

(***** Try to suggest a name for the anonymous structures *)
let suggestAnonName (nl: A.name list) =
  match nl with
    [] -> ""
  | (n, _, _, _) :: _ -> n

(****** TYPE SPECIFIERS *******)
let rec doSpecList (suggestedAnonName: string) (* This string will be part of
                                                * the names for anonymous
                                                * structures and enums  *)
                   (specs: A.spec_elem list)
       (* Returns the base type, the storage, whether it is inline and the
        * (unprocessed) attributes *)
    : typ * storage * bool * A.attribute list =
  (* Do one element and collect the type specifiers *)
  let isinline = ref false in (* If inline appears *)
  (* The storage is placed here *)
  let storage : storage ref = ref NoStorage in

  (* Collect the attributes.  Unfortunately, we cannot treat GCC
   * __attributes__ and ANSI C const/volatile the same way, since they
   * associate with structures differently.  Specifically, ANSI
   * qualifiers never apply to structures (ISO 6.7.3), whereas GCC
   * attributes always do (GCC manual 4.30).  Therefore, they are
   * collected and processed separately. *)
  let attrs : A.attribute list ref = ref [] in      (* __attribute__, etc. *)
  let cvattrs : A.cvspec list ref = ref [] in       (* const/volatile *)

  let doSpecElem (se: A.spec_elem)
                 (acc: A.typeSpecifier list)
                  : A.typeSpecifier list =
    match se with
      A.SpecTypedef -> acc
    | A.SpecInline -> isinline := true; acc
    | A.SpecStorage st ->
        if !storage <> NoStorage then
          E.s (error "Multiple storage specifiers");
        let sto' =
          match st with
            A.NO_STORAGE -> NoStorage
          | A.AUTO -> NoStorage
          | A.REGISTER -> Register
          | A.STATIC -> Static
          | A.EXTERN -> Extern
        in
        storage := sto';
        acc

    | A.SpecCV cv -> cvattrs := cv :: !cvattrs; acc
    | A.SpecAttr a -> attrs := a :: !attrs; acc
    | A.SpecType ts -> ts :: acc
    | A.SpecPattern _ -> E.s (E.bug "SpecPattern in cabs2cil input")
  in
  (* Now scan the list and collect the type specifiers. Preserve the order *)
  let tspecs = List.fold_right doSpecElem specs [] in

  let tspecs' =
    (* GCC allows a named type that appears first to be followed by things
     * like "short", "signed", "unsigned" or "long". *)
    match tspecs with
      A.Tnamed n :: (_ :: _ as rest) when not !msvcMode ->
        (* If rest contains "short" or "long" then drop the Tnamed *)
        if List.exists (function A.Tshort -> true
                               | A.Tlong -> true | _ -> false) rest then
          rest
        else
          tspecs

    | _ -> tspecs
  in
  (* Sort the type specifiers *)
  let sortedspecs =
    let order = function (* Don't change this *)
      | A.Tvoid -> 0
      | A.Tbool -> 0
      | A.Tsigned -> 1
      | A.Tunsigned -> 2
      | A.Tchar -> 3
      | A.Tshort -> 4
      | A.Tlong -> 5
      | A.Tint -> 6
      | A.Tint64 -> 7
      | A.Tfloat -> 8
      | A.Tdouble -> 9
      | A.Tcomplex -> 10
      | A.Timaginary -> 10
      | _ -> 11 (* There should be at most one of the others *)
    in
    (* Hopefully this is stable sort *)
    List.sort (fun ts1 ts2 -> compare (order ts1) (order ts2)) tspecs'
  in
  (* And now try to make sense of it. See ISO 6.7.2 *)
  let bt =
    match sortedspecs with
      [A.Tvoid] -> TVoid []
    | [A.Tchar] -> TInt(IChar, [])
    | [A.Tsigned; A.Tchar] -> TInt(ISChar, [])
    | [A.Tunsigned; A.Tchar] -> TInt(IUChar, [])

    | [A.Tshort] -> TInt(IShort, [])
    | [A.Tsigned; A.Tshort] -> TInt(IShort, [])
    | [A.Tshort; A.Tint] -> TInt(IShort, [])
    | [A.Tsigned; A.Tshort; A.Tint] -> TInt(IShort, [])

    | [A.Tunsigned; A.Tshort] -> TInt(IUShort, [])
    | [A.Tunsigned; A.Tshort; A.Tint] -> TInt(IUShort, [])

    | [] -> TInt(IInt, [])
    | [A.Tint] -> TInt(IInt, [])
    | [A.Tsigned] -> TInt(IInt, [])
    | [A.Tsigned; A.Tint] -> TInt(IInt, [])

    | [A.Tunsigned] -> TInt(IUInt, [])
    | [A.Tunsigned; A.Tint] -> TInt(IUInt, [])

    | [A.Tlong] -> TInt(ILong, [])
    | [A.Tsigned; A.Tlong] -> TInt(ILong, [])
    | [A.Tlong; A.Tint] -> TInt(ILong, [])
    | [A.Tsigned; A.Tlong; A.Tint] -> TInt(ILong, [])

    | [A.Tunsigned; A.Tlong] -> TInt(IULong, [])
    | [A.Tunsigned; A.Tlong; A.Tint] -> TInt(IULong, [])

    | [A.Tlong; A.Tlong] -> TInt(ILongLong, [])
    | [A.Tsigned; A.Tlong; A.Tlong] -> TInt(ILongLong, [])
    | [A.Tlong; A.Tlong; A.Tint] -> TInt(ILongLong, [])
    | [A.Tsigned; A.Tlong; A.Tlong; A.Tint] -> TInt(ILongLong, [])

    | [A.Tunsigned; A.Tlong; A.Tlong] -> TInt(IULongLong, [])
    | [A.Tunsigned; A.Tlong; A.Tlong; A.Tint] -> TInt(IULongLong, [])

    (* int64 is to support MSVC *)
    | [A.Tint64] -> TInt(ILongLong, [])
    | [A.Tsigned; A.Tint64] -> TInt(ILongLong, [])

    | [A.Tunsigned; A.Tint64] -> TInt(IULongLong, [])

    | [A.Tfloat] -> TFloat(FFloat, [])
    | [A.Tdouble] -> TFloat(FDouble, [])
    | [A.Tlong; A.Tdouble] -> TFloat(FLongDouble, [])


    | [A.Tcomplex] -> TFloat(CFloat, [])
    | [A.Tfloat; A.Tcomplex] -> TFloat(CFloat, [])
    | [A.Tdouble; A.Tcomplex] -> TFloat(CDouble, [])
    | [A.Tlong; A.Tdouble; A.Tcomplex] -> TFloat(CLongDouble, [])

    | [A.Timaginary] -> TFloat(IFloat, [])
    | [A.Tdouble; A.Timaginary] -> TFloat(IDouble, [])
    | [A.Tlong; A.Tdouble; A.Timaginary] -> TFloat(ILongDouble, [])

     (* Now the other type specifiers *)
    | [A.Tnamed n] -> begin
        if n = "__builtin_va_list" &&
          Flx_cil_machdep.gccHas__builtin_va_list then begin
            TBuiltin_va_list []
        end else
          let t =
            match lookupType "type" n with
              (TNamed _) as x, _ -> x
            | typ -> E.s (error "Named type %s is not mapped correctly\n" n)
          in
          t
    end

    | [A.Tstruct (n, None, _)] -> (* A reference to a struct *)
        if n = "" then E.s (error "Missing struct tag on incomplete struct");
        findCompType "struct" n []
    | [A.Tstruct (n, Some nglist, extraAttrs)] -> (* A definition of a struct *)
      let n' =
        if n <> "" then n else anonStructName "struct" suggestedAnonName in
      (* Use the (non-cv) attributes now *)
      let a = extraAttrs @ !attrs in
      attrs := [];
      makeCompType true n' nglist (doAttributes a)

    | [A.Tunion (n, None, _)] -> (* A reference to a union *)
        if n = "" then E.s (error "Missing union tag on incomplete union");
        findCompType "union" n []
    | [A.Tunion (n, Some nglist, extraAttrs)] -> (* A definition of a union *)
        let n' =
          if n <> "" then n else anonStructName "union" suggestedAnonName in
        (* Use the attributes now *)
        let a = extraAttrs @ !attrs in
        attrs := [];
        makeCompType false n' nglist (doAttributes a)

    | [A.Tenum (n, None, _)] -> (* Just a reference to an enum *)
        if n = "" then E.s (error "Missing enum tag on incomplete enum");
        findCompType "enum" n []

    | [A.Tenum (n, Some eil, extraAttrs)] -> (* A definition of an enum *)
        let n' =
          if n <> "" then n else anonStructName "enum" suggestedAnonName in
        (* make a new name for this enumeration *)
        let n'', _  = newAlphaName true "enum" n' in
        (* Create the enuminfo, or use one that was created already for a
         * forward reference *)
        (* Use the attributes now *)
        let a = extraAttrs @ !attrs in
        attrs := [];
        let enum, _ = createEnumInfo n'' in
        enum.eattr <- doAttributes a;
        let res = TEnum (enum, []) in

        (* sm: start a scope for the enum tag values, since they *
        * can refer to earlier tags *)
        enterScope ();

        (* as each name,value pair is determined, this is called *)
        let rec processName kname i loc rest = begin
          (* add the name to the environment, but with a faked 'typ' field;
           * we don't know the full type yet (since that includes all of the
           * tag values), but we won't need them in here  *)
          addLocalToEnv kname (EnvEnum (i, res));

          (* add this tag to the list so that it ends up in the real
          * environment when we're finished  *)
          let newname, _  = newAlphaName true "" kname in
          (kname, (newname, i, loc)) :: loop (increm i 1) rest
        end

        and loop i = function
            [] -> []
          | (kname, A.NOTHING, cloc) :: rest ->
              (* use the passed-in 'i' as the value, since none specified *)
              processName kname i (convLoc cloc) rest

          | (kname, e, cloc) :: rest ->
              (* constant-eval 'e' to determine tag value *)
              let i = match isIntConstExp e with
                  Some e' -> e'
                | _ -> E.s (error "enum without const integer initializer")
              in
              processName kname i (convLoc cloc) rest
        in

        (* sm: now throw away the environment we built for eval'ing the enum
        * tags, so we can add to the new one properly  *)
        exitScope ();

        let fields = loop zero eil in
        (* Now set the right set of items *)
        enum.eitems <- List.map (fun (_, x) -> x) fields;
        (* Record the enum name in the environment *)
        addLocalToEnv (kindPlusName "enum" n'') (EnvTyp res);
        (* And define the tag *)
        cabsPushGlobal (GEnumTag (enum, !currentLoc));
        res


    | [A.TtypeofE e] ->
        (* We process e as AExpLeaveArrayfun to avoid conversion of arrays
        * and functions into pointers *)
        let (c, e', t) = doExp false e AExpLeaveArrayFun in
        let t' =
          match e' with
            StartOf(lv) -> typeOfLval lv
                (* If this is a string literal, then we treat it as in sizeof*)
          | Const (CStr s) -> begin
              match typeOf e' with
                TPtr(bt, _) -> (* This is the type of arary elements *)
                  TArray(bt, Some (SizeOfStr s), [])
              | _ -> E.s (bug "The typeOf a string is not a pointer type")
          end
          | _ -> t
        in
(*
        ignore (E.log "typeof(%a) = %a\n" d_exp e' d_plaintype t');
*)
        t'

    | [A.TtypeofT (specs, dt)] ->
        let typ = doOnlyType specs dt in
        typ

    | _ ->
        E.s (error "Invalid combination of type specifiers")
  in
  bt,!storage,!isinline,List.rev (!attrs @ (convertCVtoAttr !cvattrs))

(* given some cv attributes, convert them into named attributes for
 * uniform processing *)
and convertCVtoAttr (src: A.cvspec list) : A.attribute list =
  match src with
  | [] -> []
  | CV_CONST    :: tl -> ("const",[])    :: (convertCVtoAttr tl)
  | CV_VOLATILE :: tl -> ("volatile",[]) :: (convertCVtoAttr tl)
  | CV_RESTRICT :: tl -> ("restrict",[]) :: (convertCVtoAttr tl)


and makeVarInfoFlx_cil_cabs
                ~(isformal: bool)
                ~(isglobal: bool)
                (ldecl : location)
                (bt, sto, inline, attrs)
                (n,ndt,a)
      : varinfo =
  let vtype, nattr =
    doType (AttrName false) bt (A.PARENTYPE(attrs, ndt, a)) in
  if inline && not (isFunctionType vtype) then
    ignore (error "inline for a non-function: %s" n);
  let t =
    if not isglobal && not isformal then begin
      (* Sometimes we call this on the formal argument of a function with no
       * arguments. Don't call stripConstLocalType in that case *)
(*      ignore (E.log "stripConstLocalType(%a) for %s\n" d_type vtype n); *)
      stripConstLocalType vtype
    end else
      vtype
  in
  let vi = makeVarinfo isglobal n t in
  vi.vstorage <- sto;
  vi.vattr <- nattr;
  vi.vdecl <- ldecl;
  (* ignore (E.log "Created local %s : %a\n" vi.vname d_type vi.vtype); *)
  vi

(* Process a local variable declaration and allow variable-sized arrays *)
and makeVarSizeVarInfo (ldecl : location)
                       spec_res
                       (n,ndt,a)
   : varinfo * chunk * exp * bool =
  if not !msvcMode then
    match isVariableSizedArray ndt with
      None ->
        makeVarInfoFlx_cil_cabs ~isformal:false
                        ~isglobal:false
                        ldecl spec_res (n,ndt,a), empty, zero, false
    | Some (ndt', se, len) ->
        makeVarInfoFlx_cil_cabs ~isformal:false
                        ~isglobal:false
                        ldecl spec_res (n,ndt',a), se, len, true
  else
    makeVarInfoFlx_cil_cabs ~isformal:false
                    ~isglobal:false
                    ldecl spec_res (n,ndt,a), empty, zero, false

and doAttr (a: A.attribute) : attribute list =
  (* Strip the leading and trailing underscore *)
  let stripUnderscore (n: string) : string =
    let l = String.length n in
    let rec start i =
      if i >= l then
        E.s (error "Invalid attribute name %s" n);
      if String.get n i = '_' then start (i + 1) else i
    in
    let st = start 0 in
    let rec finish i =
      (* We know that we will stop at >= st >= 0 *)
      if String.get n i = '_' then finish (i - 1) else i
    in
    let fin = finish (l - 1) in
    String.sub n st (fin - st + 1)
  in
  match a with
(*    ("restrict", []) -> [] *)
  | (s, []) -> [Attr (stripUnderscore s, [])]
  | (s, el) ->
      let rec attrOfExp (strip: bool) (a: A.expression) : attrparam =
        match a with
          A.VARIABLE n -> begin
            let n' = if strip then stripUnderscore n else n in
            (** See if this is an enumeration *)
            try
              match H.find env n' with
                EnvEnum (tag, _), _ -> begin
                  match isInteger (constFold true tag) with
                    Some i64 -> AInt (Int64.to_int i64)
                  |  _ -> ACons(n', [])
                end
              | _ -> ACons (n', [])
            with Not_found -> ACons(n', [])
          end
        | A.CONSTANT (A.CONST_STRING s) -> AStr s
        | A.CONSTANT (A.CONST_INT str) -> AInt (int_of_string str)
        | A.CALL(A.VARIABLE n, args) -> begin
            let n' = if strip then stripUnderscore n else n in
            let ae' = List.map ae args in
            ACons(n', ae')
        end
        | A.EXPR_SIZEOF e -> ASizeOfE (ae e)
        | A.TYPE_SIZEOF (bt, dt) -> ASizeOf (doOnlyType bt dt)
        | A.EXPR_ALIGNOF e -> AAlignOfE (ae e)
        | A.TYPE_ALIGNOF (bt, dt) -> AAlignOf (doOnlyType bt dt)
        | A.BINARY(A.AND, aa1, aa2) ->
            ABinOp(LAnd, ae aa1, ae aa2)
        | A.BINARY(A.OR, aa1, aa2) ->
            ABinOp(LOr, ae aa1, ae aa2)
        | A.BINARY(abop, aa1, aa2) ->
            ABinOp (convBinOp abop, ae aa1, ae aa2)
        | A.UNARY(A.PLUS, aa) -> ae aa
        | A.UNARY(A.MINUS, aa) -> AUnOp (Neg, ae aa)
        | A.UNARY(A.BNOT, aa) -> AUnOp(BNot, ae aa)
        | A.UNARY(A.NOT, aa) -> AUnOp(LNot, ae aa)
        | A.MEMBEROF (e, s) -> ADot (ae e, s)
        | _ ->
            ignore (E.log "Invalid expression in attribute: ");
            withFlx_cil_cprint Flx_cil_cprint.print_expression a;
            E.s (error "cabs2cil: invalid expression")

      and ae (e: A.expression) = attrOfExp false e
      in
      (* Sometimes we need to convert attrarg into attr *)
      let arg2attr = function
        | ACons (s, args) -> Attr (s, args)
        | a ->
            E.s (error "Invalid form of attribute: %a"
                   d_attrparam a);
      in
      if s = "__attribute__" then (* Just a wrapper for many attributes*)
        List.map (fun e -> arg2attr (attrOfExp true e)) el
      else if s = "__blockattribute__" then (* Another wrapper *)
        List.map (fun e -> arg2attr (attrOfExp true e)) el
      else if s = "__declspec" then
        List.map (fun e -> arg2attr (attrOfExp false e)) el
      else
        [Attr(stripUnderscore s, List.map (attrOfExp false) el)]

and doAttributes (al: A.attribute list) : attribute list =
  List.fold_left (fun acc a -> cabsAddAttributes (doAttr a) acc) [] al



and doType (nameortype: attributeClass) (* This is AttrName if we are doing
                                         * the type for a name, or AttrType
                                         * if we are doing this type in a
                                         * typedef *)
           (bt: typ)                    (* The base type *)
           (dt: A.decl_type)
  (* Returns the new type and the accumulated name (or type attribute
    if nameoftype =  AttrType) attributes *)
  : typ * attribute list =

  (* Now do the declarator type. But remember that the structure of the
   * declarator type is as printed, meaning that it is the reverse of the
   * right one *)
  let rec doDeclType (bt: typ) (acc: attribute list) = function
      A.JUSTBASE -> bt, acc
    | A.PARENTYPE (a1, d, a2) ->
        let a1' = doAttributes a1 in
        let a1n, a1f, a1t = partitionAttributes AttrType a1' in
        let a2' = doAttributes a2 in
        let a2n, a2f, a2t = partitionAttributes nameortype a2' in
        let bt' = cabsTypeAddAttributes a1t bt in
        let bt'', a1fadded =
          match unrollType bt with
            TFun _ -> cabsTypeAddAttributes a1f bt', true
          | _ -> bt', false
        in
        (* Now recurse *)
        let restyp, nattr = doDeclType bt'' acc d in
        (* Add some more type attributes *)
        let restyp = cabsTypeAddAttributes a2t restyp in
        (* See if we can add some more type attributes *)
        let restyp' =
          match unrollType restyp with
            TFun _ ->
              if a1fadded then
                cabsTypeAddAttributes a2f restyp
              else
                cabsTypeAddAttributes a2f
                  (cabsTypeAddAttributes a1f restyp)
          | TPtr ((TFun _ as tf), ap) when not !msvcMode ->
              if a1fadded then
                TPtr(cabsTypeAddAttributes a2f tf, ap)
              else
                TPtr(cabsTypeAddAttributes a2f
                       (cabsTypeAddAttributes a1f tf), ap)
          | _ ->
              if a1f <> [] && not a1fadded then
                E.s (error "Invalid position for (prefix) function type attributes:%a"
                       d_attrlist a1f);
              if a2f <> [] then
                E.s (error "Invalid position for (post) function type attributes:%a"
                       d_attrlist a2f);
              restyp
        in
        (* Now add the name attributes and return *)
        restyp', cabsAddAttributes a1n (cabsAddAttributes a2n nattr)

    | A.PTR (al, d) ->
        let al' = doAttributes al in
        let an, af, at = partitionAttributes AttrType al' in
        (* Now recurse *)
        let restyp, nattr = doDeclType (TPtr(bt, at)) acc d in
        (* See if we can do anything with function type attributes *)
        let restyp' =
          match unrollType restyp with
            TFun _ -> cabsTypeAddAttributes af restyp
          | TPtr((TFun _ as tf), ap) ->
              TPtr(cabsTypeAddAttributes af tf, ap)
          | _ ->
              if af <> [] then
                E.s (error "Invalid position for function type attributes:%a"
                       d_attrlist af);
              restyp
        in
        (* Now add the name attributes and return *)
        restyp', cabsAddAttributes an nattr


    | A.ARRAY (d, al, len) ->
        let lo =
          (* JMS:
          Cil fails on sizeof() in constants .. we don't
          actually care so just make all arrays unknown length
          None
          *)
          match len with
            A.NOTHING -> None
          | _ ->
              let len' = doPureExp len in
              let _, len'' = castTo (typeOf len') intType len' in
              Some len''
        in
        let al' = doAttributes al in
        doDeclType (TArray(bt, lo, al')) acc d

    | A.PROTO (d, args, isva) ->
        (* Start a scope for the parameter names *)
        enterScope ();
        (* Intercept the old-style use of varargs.h. On GCC this means that
         * we have ellipsis and a last argument "builtin_va_alist:
         * builtin_va_alist_t". On MSVC we do not have the ellipsis and we
         * have a last argument "va_alist: va_list" *)
        let args', isva' =
          if args != [] && !msvcMode = not isva then begin
            let newisva = ref isva in
            let rec doLast = function
                [([A.SpecType (A.Tnamed atn)], (an, A.JUSTBASE, [], _))]
                  when isOldStyleVarArgTypeName atn &&
                       isOldStyleVarArgName an -> begin
                         (* Turn it into a vararg *)
                         newisva := true;
                         (* And forget about this argument *)
                         []
                       end

              | a :: rest -> a :: doLast rest
              | [] -> []
            in
            let args' = doLast args in
            (args', !newisva)
          end else (args, isva)
        in
        (* Make the argument as for a formal *)
        let doOneArg (s, (n, ndt, a, cloc)) : varinfo =
          let s' = doSpecList n s in
          makeVarInfoFlx_cil_cabs ~isformal:true ~isglobal:false (convLoc cloc) s' (n,ndt,a)
        in
        let targs : varinfo list option =
          match List.map doOneArg args'  with
          | [] -> None (* No argument list *)
          | [t] when (match t.vtype with TVoid _ -> true | _ -> false) ->
              Some []
          | l -> Some l
        in
        exitScope ();
        (* Turn [] types into pointers in the arguments and the result type.
         * Turn function types into pointers to respective. This simplifies
         * our life a lot, and is what the standard requires. *)
        let rec fixupArgumentTypes (argidx: int) (args: varinfo list) : unit =
          match args with
            [] -> ()
          | a :: args' ->
              (match unrollType a.vtype with
                TArray(t,_,attr) -> a.vtype <- TPtr(t, attr)
              | TFun _ -> a.vtype <- TPtr(a.vtype, [])
              | TComp (comp, _) as t -> begin
                  match isTransparentUnion a.vtype with
                    None ->  ()
                  | Some fstfield ->
                      transparentUnionArgs :=
                         (argidx, a.vtype) :: !transparentUnionArgs;
                      a.vtype <- fstfield.ftype;
              end
              | _ -> ());
              fixupArgumentTypes (argidx + 1) args'
        in
        let args =
          match targs with
            None -> None
          | Some argl ->
              fixupArgumentTypes 0 argl;
              Some (List.map (fun a -> (a.vname, a.vtype, a.vattr)) argl)
        in
        let tres =
          match unrollType bt with
            TArray(t,_,attr) -> TPtr(t, attr)
          | _ -> bt
        in
        doDeclType (TFun (tres, args, isva', [])) acc d

  in
  doDeclType bt [] dt

(* If this is a declarator for a variable size array then turn it into a
   pointer type and a length *)
and isVariableSizedArray (dt: A.decl_type)
    : (A.decl_type * chunk * exp) option =
  let res = ref None in
  let rec findArray = function
    ARRAY (JUSTBASE, al, lo) when lo != A.NOTHING ->
      (* Allow non-constant expressions *)
      let (se, e', _) = doExp false lo (AExp (Some intType)) in
      if isNotEmpty se || not (isConstant e') then begin
        res := Some (se, e');
        PTR (al, JUSTBASE)
      end else
        ARRAY (JUSTBASE, al, lo)
    | ARRAY (dt, al, lo) -> ARRAY (findArray dt, al, lo)
    | PTR (al, dt) -> PTR (al, findArray dt)
    | JUSTBASE -> JUSTBASE
    | PARENTYPE (prea, dt, posta) -> PARENTYPE (prea, findArray dt, posta)
    | PROTO (dt, f, a) -> PROTO (findArray dt, f, a)
  in
  let dt' = findArray dt in
  match !res with
    None -> None
  | Some (se, e) -> Some (dt', se, e)

and doOnlyType (specs: A.spec_elem list) (dt: A.decl_type) : typ =
  let bt',sto,inl,attrs = doSpecList "" specs in
  if sto <> NoStorage || inl then
    E.s (error "Storage or inline specifier in type only");
  let tres, nattr = doType AttrType bt' (A.PARENTYPE(attrs, dt, [])) in
  if nattr <> [] then
    E.s (error "Name attributes in only_type: %a"
           d_attrlist nattr);
  tres


and makeCompType (isstruct: bool)
                 (n: string)
                 (nglist: A.field_group list)
                 (a: attribute list) =
  (* Make a new name for the structure *)
  let kind = if isstruct then "struct" else "union" in
  let n', _  = newAlphaName true kind n in
  (* Create the self cell for use in fields and forward references. Or maybe
   * one exists already from a forward reference  *)
  let comp, _ = createCompInfo isstruct n' in
  let doFieldGroup ((s: A.spec_elem list),
                    (nl: (A.name * A.expression option) list)) : 'a list =
    (* Do the specifiers exactly once *)
    let sugg = match nl with
      [] -> ""
    | ((n, _, _, _), _) :: _ -> n
    in
    let bt, sto, inl, attrs = doSpecList sugg s in
    (* Do the fields *)
    let makeFieldInfo
        (((n,ndt,a,cloc) : A.name), (widtho : A.expression option))
      : fieldinfo =
      if sto <> NoStorage && sto <> Static || inl then
        E.s (error "Non-static Storage or inline not allowed for fields");
      let ftype, nattr =
        doType (AttrName false) bt (A.PARENTYPE(attrs, ndt, a)) in
      let width =
        match widtho with
          None -> None
        | Some w -> begin
            (match unrollType ftype with
              TInt (ikind, a) -> ()
            | TEnum _ -> ()
            | _ -> E.s (error "Base type for bitfield is not an integer type"));
            match isIntegerConstant w with
                Some n -> Some n
              | None -> E.s (error "bitfield width is not an integer constant")
          end
      in
      (* If the field is unnamed and its type is a structure of union type
       * then give it a distinguished name  *)
      let n' =
        if n = missingFieldName then begin
          match unrollType ftype with
            TComp _ -> begin
              incr annonCompFieldNameId;
              annonCompFieldName ^ (string_of_int !annonCompFieldNameId)
            end
          | _ -> n
        end else
          n
      in
      { fcomp     =  comp;
        fname     =  n';
        ftype     =  ftype;
        fbitfield =  width;
        fattr     =  nattr;
        floc      =  convLoc cloc;
        fstorage  = sto
      }
    in
    List.map makeFieldInfo nl
  in


  let flds = List.concat (List.map doFieldGroup nglist) in
  if comp.cfields <> [] then begin
    (* This appears to be a multiply defined structure. This can happen from
    * a construct like "typedef struct foo { ... } A, B;". This is dangerous
    * because at the time B is processed some forward references in { ... }
    * appear as backward references, which coild lead to circularity in
    * the type structure. We do a thourough check and then we reuse the type
    * for A *)
    let fieldsSig fs = List.map (fun f -> typeSig f.ftype) fs in
    if fieldsSig comp.cfields <> fieldsSig flds then
      ignore (error "%s seems to be multiply defined" (compFullName comp))
  end else
    comp.cfields <- flds;

(*  ignore (E.log "makeComp: %s: %a\n" comp.cname d_attrlist a); *)
  comp.cattr <- a;
  let toplevel_typedef = false in
  let res = TComp (comp, []) in
  (* This compinfo is defined, even if there are no fields *)
  comp.cdefined <- true;
  (* Create a typedef for this one *)
  cabsPushGlobal (GCompTag (comp, !currentLoc));

      (* There must be a self cell created for this already *)
  addLocalToEnv (kindPlusName kind n) (EnvTyp res);
  (* Now create a typedef with just this type *)
  res

and preprocessCast (specs: A.specifier)
                   (dt: A.decl_type)
                   (ie: A.init_expression)
  : A.specifier * A.decl_type * A.init_expression =
  let typ = doOnlyType specs dt in
  (* If we are casting to a union type then we have to treat this as a
   * constructor expression. This is to handle the gcc extension that allows
   * cast from a type of a field to the type of the union  *)
  let ie' =
    match unrollType typ, ie with
      TComp (c, _), A.SINGLE_INIT _ when not c.cstruct ->
        A.COMPOUND_INIT [(A.INFIELD_INIT ("___matching_field",
                                          A.NEXT_INIT),
                          ie)]
    | _, _ -> ie
  in
  (* Maybe specs contains an unnamed composite. Replace with the name so that
   * when we do again the specs we get the right name  *)
  let specs1 =
    match typ with
      TComp (ci, _) ->
        List.map
          (function
              A.SpecType (A.Tstruct ("", flds, [])) ->
                A.SpecType (A.Tstruct (ci.cname, None, []))
            | A.SpecType (A.Tunion ("", flds, [])) ->
                A.SpecType (A.Tunion (ci.cname, None, []))
            | s -> s) specs
    | _ -> specs
  in
  specs1, dt, ie'

and isIntConstExp (aexp) : exp option =
  match doExp true aexp (AExp None) with
    (* first, filter for those Const exps that are integers *)
    | (c, (Const (CInt64 (i,_,_)) as p),_) when isEmpty c ->
        Some p
    | (c, (Const (CChr i) as p),_) when isEmpty c ->
        Some p
    (* other Const expressions are not ok *)
    | (_, (Const _), _) ->
        None
    (* now, anything else that 'doExp true' returned is ok (provided
       that it didn't yield side effects); this includes, in particular,
       the various sizeof and alignof expression kinds *)
    | (c, e, _) when isEmpty c ->
        Some e
    (* we only get here when the expression had side effects *)
    | _ ->
        None

(* this is like 'isIntConstExp', but retrieves the actual integer
 * the expression denotes; I have not extended it to work with
 * sizeof/alignof since (for CCured) we can't const-eval those,
 * and it's not clear whether they can be bitfield width specifiers
 * anyway (since that's where this function is used) *)
and isIntegerConstant (aexp) : int option =
  match doExp true aexp (AExp None) with
      (c, (Const (CInt64 (i,_,_)) as p),_) when isEmpty c ->
        Some (Int64.to_int i)
    | (c, (Const (CChr i) as p),_) when isEmpty c ->
        Some (Char.code i)
    | _ -> None

     (* Process an expression and in the process do some type checking,
      * extract the effects as separate statements  *)
and doExp (isconst: bool)    (* In a constant *)
          (e: A.expression)
          (what: expAction) : (chunk * exp * typ) =
  (* A subexpression of array type is automatically turned into StartOf(e).
   * Similarly an expression of function type is turned into AddrOf. So
   * essentially doExp should never return things of type TFun or TArray *)
  let processArrayFun e t =
    match e, unrollType t with
      (Lval(lv) | CastE(_, Lval lv)), TArray(tbase, _, a) ->
        mkStartOfAndMark lv, TPtr(tbase, a)
    | (Lval(lv) | CastE(_, Lval lv)), TFun _  ->
        mkAddrOfAndMark lv, TPtr(t, [])
    | _, (TArray _ | TFun _) ->
        E.s (error "Array or function expression is not lval: %a@!"
               d_plainexp e)
    | _ -> e, t
  in
  (* Before we return we call finishExp *)
  let finishExp ?(newWhat=what)
                (se: chunk) (e: exp) (t: typ) : chunk * exp * typ =
    match newWhat with
      ADrop -> (se, e, t)
    | AExpLeaveArrayFun ->
        (se, e, t) (* It is important that we do not do "processArrayFun" in
                    * this case. We exploit this when we process the typeOf
                    * construct *)
    | AExp _ ->
        let (e', t') = processArrayFun e t in
        (se, e', t')

    | ASet (lv, lvt) -> begin
        (* See if the set was done already *)
        match e with
          Lval(lv') when lv == lv' ->
            (se, e, t)
        | _ ->
            let (e', t') = processArrayFun e t in
            let (t'', e'') = castTo t' lvt e' in
(*
            ignore (E.log "finishExp: e = %a\n  e'' = %a\n" d_plainexp e d_plainexp e'');
*)
            (se +++ (Set(lv, e'', !currentLoc)), e'', t'')
    end
  in
  let rec findField (n: string) (fidlist: fieldinfo list) : offset * typ =
    (* Depth first search for the field. This appears to be what GCC does.
     * MSVC checks that there are no ambiguous field names, so it does not
     * matter how we search *)
    let rec search = function
        [] -> NoOffset, voidType (* Did not find *)
      | fid :: rest when fid.fname = n -> Field(fid, NoOffset), fid.ftype
      | fid :: rest when prefix annonCompFieldName fid.fname -> begin
          match unrollType fid.ftype with
            TComp (ci, _) ->
              let off, t = search ci.cfields in
              if off = NoOffset then
                search rest  (* Continue searching *)
              else
                Field (fid, off), t
          | _ -> E.s (bug "unnamed field type is not a struct/union")
      end
      | _ :: rest -> search rest
    in
    let off, t = search fidlist in
    if off = NoOffset then
      E.s (error "Cannot find field %s" n);
    off, t
  in
  try
    match e with
    | A.NOTHING when what = ADrop -> finishExp empty (integer 0) intType
    | A.NOTHING ->
        let res = Const(CStr "exp_nothing") in
        finishExp empty res (typeOf res)

    (* Do the potential lvalues first *)
    | A.VARIABLE n -> begin
        (* Look up in the environment *)
        try
          let envdata = H.find env n in
          match envdata with
            EnvVar vi, _ ->
              if isconst &&
                 not (isFunctionType vi.vtype) &&
                 not (isArrayType vi.vtype)then
                E.s (error "variable appears in constant");
              finishExp empty (Lval(var vi)) vi.vtype
          | EnvEnum (tag, typ), _ ->
              finishExp empty tag typ
          | _ -> raise Not_found
        with Not_found -> begin
          if isOldStyleVarArgName n then
            E.s (error "Cannot resolve variable %s. This could be a CIL bug due to the handling of old-style variable argument functions.\n" n)
          else
            E.s (error "Cannot resolve variable %s.\n" n)
        end
    end
    | A.INDEX (e1, e2) -> begin
        (* Recall that doExp turns arrays into StartOf pointers *)
        let (se1, e1', t1) = doExp false e1 (AExp None) in
        let (se2, e2', t2) = doExp false e2 (AExp None) in
        let se = se1 @@ se2 in
        let (e1'', t1, e2'', tresult) =
          (* Either e1 or e2 can be the pointer *)
          match unrollType t1, unrollType t2 with
            TPtr(t1e,_), (TInt _|TEnum _) -> e1', t1, e2', t1e
          | (TInt _|TEnum _), TPtr(t2e,_) -> e2', t2, e1', t2e
          | _ ->
              E.s (error
                     "Expecting a pointer type in index:@! t1=%a@!t2=%a@!"
                     d_plaintype t1 d_plaintype t2)
        in
        (* We have to distinguish the construction based on the type of e1'' *)
        let res =
          match e1'' with
            StartOf array -> (* A real array indexing operation *)
              addOffsetLval (Index(e2'', NoOffset)) array
          | _ -> (* Turn into *(e1 + e2) *)
              mkMem (BinOp(IndexPI, e1'', e2'', t1)) NoOffset
        in
        (* Do some optimization of StartOf *)
        finishExp se (Lval res) tresult

    end
    | A.UNARY (A.MEMOF, e) ->
        if isconst then
          E.s (error "MEMOF in constant");
        let (se, e', t) = doExp false e (AExp None) in
        let tresult =
          match unrollType t with
          | TPtr(te, _) -> te
          | _ -> E.s (error "Expecting a pointer type in *. Got %a@!"
                        d_plaintype t)
        in
        finishExp se
                  (Lval (mkMem e' NoOffset))
                  tresult

           (* e.str = (& e + off(str)). If e = (be + beoff) then e.str = (be
            * + beoff + off(str))  *)
    | A.MEMBEROF (e, str) ->
        (* member of is actually allowed if we only take the address *)
        (* if isconst then
          E.s (error "MEMBEROF in constant");  *)
        let (se, e', t') = doExp false e (AExp None) in
        let lv =
          match e' with
            Lval x -> x
          | CastE(_, Lval x) -> x
          | _ -> E.s (error "Expected an lval in MEMBEROF (field %s)" str)
        in
        let field_offset, field_type =
          match unrollType t' with
            TComp (comp, _) -> findField str comp.cfields
          | _ -> E.s (error "expecting a struct with field %s" str)
        in
        let lv' = Lval(addOffsetLval field_offset lv) in
        finishExp se lv' field_type

       (* e->str = * (e + off(str)) *)
    | A.MEMBEROFPTR (e, str) ->
        if isconst then
          E.s (error "MEMBEROFPTR in constant");
        let (se, e', t') = doExp false e (AExp None) in
        let pointedt =
          match unrollType t' with
            TPtr(t1, _) -> t1
          | TArray(t1,_,_) -> t1
          | _ -> E.s (error "expecting a pointer to a struct")
        in
        let field_offset, field_type =
          match unrollType pointedt with
            TComp (comp, _) -> findField str comp.cfields
          | x ->
              E.s (error
                     "expecting a struct with field %s. Found %a. t1 is %a"
                     str d_type x d_type t')
        in
        finishExp se (Lval (mkMem e' field_offset)) field_type


    | A.CONSTANT ct -> begin
        let hasSuffix str =
          let l = String.length str in
          fun s ->
            let ls = String.length s in
            l >= ls && s = String.uppercase (String.sub str (l - ls) ls)
        in
        match ct with
          A.CONST_INT str -> begin
            let res = parseInt str in
            finishExp empty res (typeOf res)
          end

(*
        | A.CONST_WSTRING wstr ->
            let len = List.length wstr in
            let wchar_t = !wcharType in
            (* We will make an array big enough to contain the wide
             * characters and the wide-null terminator *)
            let ws_t = TArray(wchar_t, Some (integer len), []) in
            let ws =
              makeGlobalVar ("wide_string" ^ string_of_int !lastStructId)
                ws_t
            in
            ws.vstorage <- Static;
            incr lastStructId;
            (* Make the initializer. Idx is a wide_char index.  *)
            let rec loop (idx: int) (s: int64 list) =
              match s with
                [] -> []
              | wc::rest ->
                  let wc_cilexp = Const (CInt64(wc, IInt, None)) in
                  (Index(integer idx, NoOffset),
                   SingleInit (mkCast wc_cilexp wchar_t))
                  :: loop (idx + 1) rest
            in
            (* Add the definition for the array *)
            cabsPushGlobal (GVar(ws,
                                 {init = Some (CompoundInit(ws_t,
                                                            loop 0 wstr))},
                                 !currentLoc));
            finishExp empty (StartOf(Var ws, NoOffset))
              (TPtr(wchar_t, []))
              *)

        | A.CONST_WSTRING (ws: int64 list) ->
            (* takes a list of strings, and converts it to a WIDE string. *)
            let intlist_to_wstring (str: int64 list) : string =
              (* L"\xabcd" "e" must to go
                 L"\xabcd\x65" and NOT L"\xabcde" *)
              let rec loop lst must_escape = match lst with
                [] -> "" (* "\000" GN: nul-termination is implicit *)
              | hd :: tl ->
                let must_escape_now = must_escape ||
                   (compare hd (Int64.of_int 255) > 0) ||
                   (compare hd Int64.zero < 0) in
                let this_piece =
                  if must_escape_now then
                    Printf.sprintf "\\x%Lx" hd
                  else
                    String.make 1 (Char.chr (Int64.to_int hd))
                in
                this_piece ^ (loop tl must_escape_now)
              in loop str false
            in
            let res = Const(CWStr ((* intlist_to_wstring *) ws)) in
            finishExp empty res (typeOf res)

        | A.CONST_STRING s ->
            (* Maybe we burried __FUNCTION__ in there *)
            let s' =
              try
                let start = String.index s (Char.chr 0) in
                let l = String.length s in
                let tofind = (String.make 1 (Char.chr 0)) ^ "__FUNCTION__" in
                let past = start + String.length tofind in
                if past <= l &&
                   String.sub s start (String.length tofind) = tofind then
                  (if start > 0 then String.sub s 0 start else "") ^
                  !currentFunctionFDEC.svar.vname ^
                  (if past < l then String.sub s past (l - past) else "")
                else
                  s
              with Not_found -> s
            in
            let res = Const(CStr s') in
            finishExp empty res (typeOf res)

        | A.CONST_CHAR char_list ->
            let a, b = (interpret_character_constant char_list) in
            finishExp empty (Const a) b

        | A.CONST_WCHAR char_list ->
            let value = reduce_multichar !wcharType char_list in
            let result = kinteger64 !wcharKind value in
            finishExp empty result (typeOf result)

        | A.CONST_FLOAT str -> begin
            (* Maybe it ends in U or UL. Strip those *)
            let l = String.length str in
            let hasSuffix = hasSuffix str in
            let baseint, kind =
              if  hasSuffix "L" then
                String.sub str 0 (l - 1), FLongDouble
              else if hasSuffix "F" then
                String.sub str 0 (l - 1), FFloat
              else if hasSuffix "D" then
                String.sub str 0 (l - 1), FDouble
              else
                str, FDouble
            in
            try
              finishExp empty
                (Const(CReal(float_of_string baseint, kind,
                             Some str)))
                (TFloat(kind,[]))
            with e -> begin
              ignore (E.log "float_of_string %s (%s)\n" str
                        (Printexc.to_string e));
              let res = Const(CStr "booo CONS_FLOAT") in
              finishExp empty res (typeOf res)
            end
        end
    end

    | A.TYPE_SIZEOF (bt, dt) ->
        let typ = doOnlyType bt dt in
        finishExp empty (SizeOf(typ)) !typeOfSizeOf

      (* Intercept the sizeof("string") *)
    | A.EXPR_SIZEOF (A.CONSTANT (A.CONST_STRING s)) -> begin
        (* Process the string first *)
        match doExp isconst (A.CONSTANT (A.CONST_STRING s)) (AExp None) with
          _, Const(CStr s), _ ->
            finishExp empty (SizeOfStr s) !typeOfSizeOf
        | _ -> E.s (bug "cabs2cil: sizeOfStr")
    end

    | A.EXPR_SIZEOF e ->
        (* Allow non-constants in sizeof *)
        (* Do not convert arrays and functions into pointers *)
        let (se, e', t) = doExp false e AExpLeaveArrayFun in
        (* !!!! The book says that the expression is not evaluated, so we
           * drop the potential side-effects
        if isNotEmpty se then
          ignore (warn "Warning: Dropping side-effect in EXPR_SIZEOF\n");
*)
        let size =
          match e' with                 (* If we are taking the sizeof an
                                         * array we must drop the StartOf  *)
            StartOf(lv) -> SizeOfE (Lval(lv))

                (* Maybe we are taking the sizeof for a CStr. In that case we
                 * mean the pointer to the start of the string *)
          | Const(CStr _) -> SizeOf (charPtrType)

                (* Maybe we are taking the sizeof a variable-sized array *)
          | Lval (Var vi, NoOffset) -> begin
              try
                H.find varSizeArrays vi.vid
              with Not_found -> SizeOfE e'
          end
          | _ -> SizeOfE e'
        in
        finishExp empty size !typeOfSizeOf

    | A.TYPE_ALIGNOF (bt, dt) ->
        let typ = doOnlyType bt dt in
        finishExp empty (AlignOf(typ)) !typeOfSizeOf

    | A.EXPR_ALIGNOF e ->
        let (se, e', t) = doExp false e AExpLeaveArrayFun in
        (* !!!! The book says that the expression is not evaluated, so we
           * drop the potential side-effects
        if isNotEmpty se then
          ignore (warn "Warning: Dropping side-effect in EXPR_ALIGNOF\n");
*)
        let e'' =
          match e' with                 (* If we are taking the alignof an
                                         * array we must drop the StartOf  *)
            StartOf(lv) -> Lval(lv)

          | _ -> e'
        in
        finishExp empty (AlignOfE(e'')) !typeOfSizeOf

    | A.CAST ((specs, dt), ie) ->
        let s', dt', ie' = preprocessCast specs dt ie in
        (* We know now that we can do s' and dt' many times *)
        let typ = doOnlyType s' dt' in
        let what' =
          match what with
            AExp (Some _) -> AExp (Some typ)
          | AExp None -> what
          | ADrop | AExpLeaveArrayFun -> what
          | ASet (lv, lvt) ->
              (* If the cast from typ to lvt would be dropped, then we
               * continue with a Set *)
              if false && typeSig typ = typeSig lvt then
                what
              else
                AExp None (* We'll create a temporary *)
        in
        (* Remember here if we have done the Set *)
        let (se, e', t') =
          match ie' with
            A.SINGLE_INIT e -> doExp isconst e what'

          | A.NO_INIT -> E.s (error "missing expression in cast")
          | A.COMPOUND_INIT _ -> begin
              (* Pretend that we are declaring and initializing a brand new
               * variable  *)
              let newvar = "__constr_expr_" ^ string_of_int (!constrExprId) in
              incr constrExprId;
              let spec_res = doSpecList "" s' in
              let se1 =
                if !scopes == [] then begin
                  ignore (createGlobal spec_res
                            ((newvar, dt', [], cabslu), ie'));
                  empty
                end else
                  createLocal spec_res ((newvar, dt', [], cabslu), ie')
              in
              (* Now pretend that e is just a reference to the newly created
               * variable *)
              let se, e', t' = doExp isconst (A.VARIABLE newvar) what' in
              (* If typ is an array then the doExp above has already added a
               * StartOf. We must undo that now so that it is done once by
               * the finishExp at the end of this case *)
              let e2, t2 =
                match unrollType typ, e' with
                  TArray _, StartOf lv -> Lval lv, typ
                | _, _ -> e', t'
              in
              se1 @@ se, e2, t2
          end
        in
        let (t'', e'') =
          match typ with
            TVoid _ when what' = ADrop -> (t', e') (* strange GNU thing *)
          |  _ ->
              (* Do this to check the cast *)
              let newtyp, newexp = castTo ~fromsource:true t' typ e' in
              newtyp, newexp
        in
        finishExp se e'' t''

    | A.UNARY(A.MINUS, e) ->
        let (se, e', t) = doExp isconst e (AExp None) in
        if isIntegralType t then
          let tres = integralPromotion t in
          let e'' =
            match e' with
            | Const(CInt64(i, ik, _)) -> kinteger64 ik (Int64.neg i)
            | _ -> UnOp(Neg, mkCastT e' t tres, tres)
          in
          finishExp se e'' tres
        else
          if isArithmeticType t then
            finishExp se (UnOp(Neg,e',t)) t
          else
            E.s (error "Unary - on a non-arithmetic type")

    | A.UNARY(A.BNOT, e) ->
        let (se, e', t) = doExp isconst e (AExp None) in
        if isIntegralType t then
          let tres = integralPromotion t in
          let e'' = UnOp(BNot, mkCastT e' t tres, tres) in
          finishExp se e'' tres
        else
          E.s (error "Unary ~ on a non-integral type")

    | A.UNARY(A.PLUS, e) -> doExp isconst e what


    | A.UNARY(A.ADDROF, e) -> begin
        match e with
          A.COMMA el -> (* GCC extension *)
            doExp false
              (A.COMMA (replaceLastInList el (fun e -> A.UNARY(A.ADDROF, e))))
              what
        | A.QUESTION (e1, e2, e3) -> (* GCC extension *)
            doExp false
              (A.QUESTION (e1, A.UNARY(A.ADDROF, e2), A.UNARY(A.ADDROF, e3)))
              what
        | A.VARIABLE s when
            isOldStyleVarArgName s
            && (match !currentFunctionFDEC.svar.vtype with
                   TFun(_, _, true, _) -> true | _ -> false) ->
            (* We are in an old-style variable argument function and we are
             * taking the address of the argument that was removed while
             * processing the function type. We compute the address based on
             * the address of the last real argument *)
            if !msvcMode then begin
              let rec getLast = function
                  [] -> E.s (unimp "old-style variable argument function without real arguments")
                | [a] -> a
                | _ :: rest -> getLast rest
              in
              let last = getLast !currentFunctionFDEC.sformals in
              let res = mkAddrOfAndMark (var last) in
              let tres = typeOf res in
              let tres', res' = castTo tres (TInt(IULong, [])) res in
              (* Now we must add to this address to point to the next
              * argument. Round up to a multiple of 4  *)
              let sizeOfLast =
                (((bitsSizeOf last.vtype) + 31) / 32) * 4
              in
              let res'' =
                BinOp(PlusA, res', kinteger IULong sizeOfLast, tres')
              in
              finishExp empty res'' tres'
            end else begin (* On GCC the only reliable way to do this is to
                          * call builtin_next_arg. If we take the address of
                          * a local we are going to get the address of a copy
                          * of the local ! *)

              doExp isconst
                (A.CALL (A.VARIABLE "__builtin_next_arg",
                         [A.CONSTANT (A.CONST_INT "0")]))
                what
            end

        | (A.VARIABLE _ | A.UNARY (A.MEMOF, _) | (* Regular lvalues *)
           A.INDEX _ | A.MEMBEROF _ | A.MEMBEROFPTR _ |
           A.CAST (_, A.COMPOUND_INIT _)) -> begin
            let (se, e', t) = doExp false e (AExp None) in
            (* ignore (E.log "ADDROF on %a : %a\n" d_plainexp e'
                      d_plaintype t); *)
            match e' with
             ( Lval x | CastE(_, Lval x)) ->
               finishExp se (mkAddrOfAndMark x) (TPtr(t, []))

            | StartOf (lv) ->
                let tres = TPtr(typeOfLval lv, []) in (* pointer to array *)
                finishExp se (mkAddrOfAndMark lv) tres

              (* Function names are converted into pointers to the function.
               * Taking the address-of again does not change things *)
            | AddrOf (Var v, NoOffset) when isFunctionType v.vtype ->
                finishExp se e' t

            | _ -> E.s (error "Expected lval for ADDROF. Got %a@!"
                          d_plainexp e')
        end
        | _ -> E.s (error "Unexpected operand for addrof")
    end
    | A.UNARY((A.PREINCR|A.PREDECR) as uop, e) -> begin
        match e with
          A.COMMA el -> (* GCC extension *)
            doExp isconst
              (A.COMMA (replaceLastInList el
                          (fun e -> A.UNARY(uop, e))))
              what
        | A.QUESTION (e1, e2q, e3q) -> (* GCC extension *)
            doExp isconst
              (A.QUESTION (e1, A.UNARY(uop, e2q),
                           A.UNARY(uop, e3q)))
              what

        | (A.VARIABLE _ | A.UNARY (A.MEMOF, _) | (* Regular lvalues *)
           A.INDEX _ | A.MEMBEROF _ | A.MEMBEROFPTR _ |
           A.CAST _ (* A GCC extension *)) -> begin
             let uop' = if uop = A.PREINCR then PlusA else MinusA in
             if isconst then
               E.s (error "PREINCR or PREDECR in constant");
             let (se, e', t) = doExp false e (AExp None) in
             let lv =
               match e' with
                 Lval x -> x
               | CastE (_, Lval x) -> x (* A GCC extension. The operation is
                                         * done at the cast type. The result
                                         * is also of the cast type *)
               | _ -> E.s (error "Expected lval for ++ or --")
             in
             let tresult, result = doBinOp uop' e' t one intType in
             finishExp (se +++ (Set(lv, mkCastT result tresult t,
                                    !currentLoc)))
               e'
               tresult   (* Should this be t instead ??? *)
           end
        | _ -> E.s (error "Unexpected operand for prefix -- or ++")
    end

    | A.UNARY((A.POSINCR|A.POSDECR) as uop, e) -> begin
        match e with
          A.COMMA el -> (* GCC extension *)
            doExp isconst
              (A.COMMA (replaceLastInList el
                          (fun e -> A.UNARY(uop, e))))
              what
        | A.QUESTION (e1, e2q, e3q) -> (* GCC extension *)
            doExp isconst
              (A.QUESTION (e1, A.UNARY(uop, e2q), A.UNARY(uop, e3q)))
              what

        | (A.VARIABLE _ | A.UNARY (A.MEMOF, _) | (* Regular lvalues *)
           A.INDEX _ | A.MEMBEROF _ | A.MEMBEROFPTR _ |
           A.CAST _ (* A GCC extension *) ) -> begin
             if isconst then
               E.s (error "POSTINCR or POSTDECR in constant");
             (* If we do not drop the result then we must save the value *)
             let uop' = if uop = A.POSINCR then PlusA else MinusA in
             let (se, e', t) = doExp false e (AExp None) in
             let lv =
               match e' with
                 Lval x -> x
               | CastE (_, Lval x) -> x (* GCC extension. The addition must
                                         * be be done at the cast type. The
                                         * result of this is also of the cast
                                         * type *)
               | _ -> E.s (error "Expected lval for ++ or --")
             in
             let tresult, opresult = doBinOp uop' e' t one intType in
             let se', result =
               if what <> ADrop then
                 let tmp = newTempVar t in
                 se +++ (Set(var tmp, e', !currentLoc)), Lval(var tmp)
               else
                 se, e'
             in
             finishExp
               (se' +++ (Set(lv, mkCastT opresult tresult t,
                             !currentLoc)))
               result
               tresult   (* Should this be t instead ??? *)
           end
        | _ -> E.s (error "Unexpected operand for suffix ++ or --")
    end

    | A.BINARY(A.ASSIGN, e1, e2) -> begin
        match e1 with
          A.COMMA el -> (* GCC extension *)
            doExp isconst
              (A.COMMA (replaceLastInList el
                          (fun e -> A.BINARY(A.ASSIGN, e, e2))))
              what
        | A.QUESTION (e1, e2q, e3q) -> (* GCC extension *)
            doExp isconst
              (A.QUESTION (e1, A.BINARY(A.ASSIGN, e2q, e2),
                           A.BINARY(A.ASSIGN, e3q, e2)))
              what
        | A.CAST (t, A.SINGLE_INIT e) -> (* GCC extension *)
            doExp isconst
              (A.CAST (t,
                       A.SINGLE_INIT (A.BINARY(A.ASSIGN, e,
                                               A.CAST (t, A.SINGLE_INIT e2)))))
              what

        | (A.VARIABLE _ | A.UNARY (A.MEMOF, _) | (* Regular lvalues *)
           A.INDEX _ | A.MEMBEROF _ | A.MEMBEROFPTR _ ) -> begin
             if isconst then E.s (error "ASSIGN in constant");
             let (se1, e1', lvt) = doExp false e1 (AExp None) in
             let lv =
               match e1' with
                 Lval x -> x
               | _ -> E.s (error "Expected lval for assignment. Got %a\n"
                             d_plainexp e1')
             in
             let (se2, e'', t'') = doExp false e2 (ASet(lv, lvt)) in
             finishExp (se1 @@ se2) e1' lvt
           end
        | _ -> E.s (error "Invalid left operand for ASSIGN")
    end

    | A.BINARY((A.ADD|A.SUB|A.MUL|A.DIV|A.MOD|A.BAND|A.BOR|A.XOR|
      A.SHL|A.SHR|A.EQ|A.NE|A.LT|A.GT|A.GE|A.LE) as bop, e1, e2) ->
        let bop' = convBinOp bop in
        let (se1, e1', t1) = doExp isconst e1 (AExp None) in
        let (se2, e2', t2) = doExp isconst e2 (AExp None) in
        let tresult, result = doBinOp bop' e1' t1 e2' t2 in
        finishExp (se1 @@ se2) result tresult

          (* assignment operators *)
    | A.BINARY((A.ADD_ASSIGN|A.SUB_ASSIGN|A.MUL_ASSIGN|A.DIV_ASSIGN|
      A.MOD_ASSIGN|A.BAND_ASSIGN|A.BOR_ASSIGN|A.SHL_ASSIGN|
      A.SHR_ASSIGN|A.XOR_ASSIGN) as bop, e1, e2) -> begin
        match e1 with
          A.COMMA el -> (* GCC extension *)
            doExp isconst
              (A.COMMA (replaceLastInList el
                          (fun e -> A.BINARY(bop, e, e2))))
              what
        | A.QUESTION (e1, e2q, e3q) -> (* GCC extension *)
            doExp isconst
              (A.QUESTION (e1, A.BINARY(bop, e2q, e2),
                           A.BINARY(bop, e3q, e2)))
              what

        | (A.VARIABLE _ | A.UNARY (A.MEMOF, _) | (* Regular lvalues *)
           A.INDEX _ | A.MEMBEROF _ | A.MEMBEROFPTR _ |
           A.CAST _ (* GCC extension *) ) -> begin
             if isconst then
               E.s (error "op_ASSIGN in constant");
             let bop' = match bop with
               A.ADD_ASSIGN -> PlusA
             | A.SUB_ASSIGN -> MinusA
             | A.MUL_ASSIGN -> Mult
             | A.DIV_ASSIGN -> Div
             | A.MOD_ASSIGN -> Mod
             | A.BAND_ASSIGN -> BAnd
             | A.BOR_ASSIGN -> BOr
             | A.XOR_ASSIGN -> BXor
             | A.SHL_ASSIGN -> Shiftlt
             | A.SHR_ASSIGN -> Shiftrt
             | _ -> E.s (error "binary +=")
             in
             let (se1, e1', t1) = doExp false e1 (AExp None) in
             let lv1 =
               match e1' with
                 Lval x -> x
               | CastE (_, Lval x) -> x (* GCC extension. The operation and
                                         * the result are at the cast type  *)
               | _ -> E.s (error "Expected lval for assignment with arith")
             in
             let (se2, e2', t2) = doExp false e2 (AExp None) in
             let tresult, result = doBinOp bop' e1' t1 e2' t2 in
             (* We must cast the result to the type of the lv1, which may be
              * different than t1 if lv1 was a Cast *)
             let _, result' = castTo tresult (typeOfLval lv1) result in
             (* The type of the result is the type of the left-hand side  *)
             finishExp (se1 @@ se2 +++
                        (Set(lv1, result', !currentLoc)))
               e1'
               t1
           end
        | _ -> E.s (error "Unexpected left operand for assignment with arith")
      end


    | A.BINARY((A.AND|A.OR), _, _) | A.UNARY(A.NOT, _) -> begin
        let ce = doCondExp isconst e in
        (* We must normalize the result to 0 or 1 *)
        match ce with
          CEExp (se, ((Const _) as c)) ->
            finishExp se (if isZero c then zero else one) intType
        | CEExp (se, e) ->
            let e' =
              let te = typeOf e in
              let _, zte = castTo intType te zero in
              BinOp(Ne, e, zte, te)
            in
            finishExp se e' intType
        | _ ->
            let tmp = var (newTempVar intType) in
            finishExp (compileCondExp ce
                         (empty +++ (Set(tmp, integer 1,
                                         !currentLoc)))
                         (empty +++ (Set(tmp, integer 0,
                                         !currentLoc))))
              (Lval tmp)
              intType
    end

    | A.CALL(f, args) ->
        if isconst then
          E.s (error "CALL in constant");
        let (sf, f', ft') =
          match f with                  (* Treat the VARIABLE case separate
                                         * becase we might be calling a
                                         * function that does not have a
                                         * prototype. In that case assume it
                                         * takes INTs as arguments  *)
            A.VARIABLE n -> begin
              try
                let vi, _ = lookupVar n in
                (empty, Lval(var vi), vi.vtype) (* Found. Do not use
                                                 * finishExp. Simulate what =
                                                 * AExp None  *)
              with Not_found -> begin
                ignore (warnOpt "Calling function %s without prototype." n);
                let ftype = TFun(intType, None, false,
                                 [Attr("missingproto",[])]) in
                (* Add a prototype to the environment *)
                let proto, _ =
                  makeGlobalVarinfo false (makeGlobalVar n ftype) in
                (* Make it EXTERN *)
                proto.vstorage <- Extern;
                H.add noProtoFunctions proto.vid true;
                (* Add it to the file as well *)
                cabsPushGlobal (GVarDecl (proto, !currentLoc));
                (empty, Lval(var proto), ftype)
              end
            end
          | _ -> doExp false f (AExp None)
        in
        (* Get the result type and the argument types *)
        let (resType, argTypes, isvar, f'') =
          match unrollType ft' with
            TFun(rt,at,isvar,a) -> (rt,at,isvar,f')
          | TPtr (t, _) -> begin
              match unrollType t with
                TFun(rt,at,isvar,a) -> (* Make the function pointer
                                            * explicit  *)
                  let f'' =
                    match f' with
                      AddrOf lv -> Lval(lv)
                    | _ -> Lval(mkMem f' NoOffset)
                  in
                  (rt,at,isvar, f'')
              | x ->
                  E.s (error "Unexpected type of the called function %a: %a"
                         d_exp f' d_type x)
          end
          | x ->  E.s (error "Unexpected type of the called function %a: %a"
                         d_exp f' d_type x)
        in
        let argTypesList = argsToList argTypes in
        (* Drop certain qualifiers from the result type *)
        let resType' = resType in
        (* Before we do the arguments we try to intercept a few builtins. For
         * these we have defined then with a different type, so we do not
         * want to give warnings. *)
        let isVarArgBuiltin =
          match f'' with
            Lval (Var fv, NoOffset) ->
              fv.vname = "__builtin_stdarg_start" ||
              fv.vname = "__builtin_va_arg" ||
              fv.vname = "__builtin_next_arg"
            | _ -> false
        in

        (* Do the arguments. In REVERSE order !!! Both GCC and MSVC do this *)
        let rec loopArgs
            : (string * typ * attributes) list * A.expression list
          -> (chunk * exp list) = function
            | ([], []) -> (empty, [])

            | args, [] ->
                if not isVarArgBuiltin then
                  ignore (warnOpt
                            "Too few arguments in call to %a."
                            d_exp f');
                (empty, [])

            | ((_, at, _) :: atypes, a :: args) ->
                let (ss, args') = loopArgs (atypes, args) in
                let (sa, a', att) = doExp false a (AExp (Some at)) in
                let (at'', a'') = castTo att at a' in
                (ss @@ sa, a'' :: args')

            | ([], args) -> (* No more types *)
                if not isvar && argTypes != None && not isVarArgBuiltin then
                  (* Do not give a warning for functions without a prototype*)
                  ignore (warnOpt "Too many arguments in call to %a" d_exp f');
                let rec loop = function
                    [] -> (empty, [])
                  | a :: args ->
                      let (ss, args') = loop args in
                      let (sa, a', at) = doExp false a (AExp None) in
                      (ss @@ sa, a' :: args')
                in
                loop args
        in
        let (sargs, args') = loopArgs (argTypesList, args) in
        let f3, what3, args3, is__builtin_va_arg =
          let rec dropCasts = function CastE (_, e) -> dropCasts e | e -> e in
          (* Get the name of the last formal *)
          let getNameLastFormal () : string =
            match !currentFunctionFDEC.svar.vtype with
              TFun(_, Some args, true, _) -> begin
                match List.rev args with
                  (last_par_name, _, _) :: _ -> last_par_name
                | _ -> ""
              end
            | _ -> ""
          in
          match f'' with
            Lval(Var fv, NoOffset) -> begin
              if fv.vname = "__builtin_va_arg" then begin
                match args' with
                  marker :: SizeOf resTyp :: _ -> begin
                    (* Make a variable of the desired type *)
                    let destlv, destlvtyp =
                      match what with
                        ASet (lv, lvt) -> lv, lvt
                      | _ -> var (newTempVar resTyp), resTyp
                    in
                    f'',
                    ASet (destlv, destlvtyp),
                    [marker; SizeOf resTyp; AddrOf destlv],
                    true
                  end
                | _ ->
                    ignore (warn "Invalid call to %s\n" fv.vname);
                    f'',what, args', false
              end else if fv.vname = "__builtin_stdarg_start" then begin
                match args' with
                  marker :: last :: [] -> begin
                    let isOk =
                      match dropCasts last with
                        Lval (Var lastv, NoOffset) ->
                          lastv.vname = getNameLastFormal ()
                      | _ -> false
                    in
                    if not isOk then
                      ignore (warn "The second argument in call to %s should be the last formal argument\n" fv.vname);

                    (* Flx_cil_check that "lastv" is indeed the last variable in the
                     * prototype and then drop it *)
                    f'', what, [marker], false
                  end
                | _ ->
                    ignore (warn "Invalid call to %s\n" fv.vname);
                    f'',what, args', false

              (* We have to turn uses of __builtin_varargs_start into uses
               * of __builtin_stdarg_start (because we have dropped the
               * __builtin_va_alist argument from this function *)

              end else if fv.vname = "__builtin_varargs_start" then begin
                (* Lookup the prototype for the replacement *)
                let v, _  =
                  try lookupGlobalVar "__builtin_stdarg_start"
                  with Not_found -> E.s (bug "Cannot find __builtin_stdarg_start to replace %s\n" fv.vname)
                in
                Lval (var v),
                what,
                args',
                false

              end else if fv.vname = "__builtin_next_arg" then begin
                match args' with
                  last :: [] -> begin
                    let isOk =
                      match dropCasts last with
                        Lval (Var lastv, NoOffset) ->
                          lastv.vname = getNameLastFormal ()
                      | _ -> false
                    in
                    if not isOk then
                      ignore (warn "The argument in call to %s should be the last formal argument\n" fv.vname);

                    f'', what, [ ], false
                  end
                | _ ->
                    ignore (warn "Invalid call to %s\n" fv.vname);
                    f'',what, args', false
              end else
                f'', what, args', false
            end
          | _ -> f'',what, args', false
        in
        begin
          match what3 with
            ADrop ->
              finishExp
                (sf @@ sargs +++ (Call(None,f3,args3, !currentLoc)))
                (integer 0) intType
              (* Set to a variable of corresponding type *)
          | ASet(lv, vtype) ->
              (* Make an exception here for __builtin_va_arg *)
              if is__builtin_va_arg then
                finishExp
                  (sf @@ sargs
                           +++ (Call(None,f3,args3, !currentLoc)))
                  (Lval(lv))
                  vtype
              else
                finishExp
                  (sf @@ sargs
                           +++ (Call(Some lv,f3,args3, !currentLoc)))
                  (Lval(lv))
                  vtype

          | _ -> begin
              (* Must create a temporary *)
              match f3, args3 with     (* Some constant folding *)
                Lval(Var fv, NoOffset), [Const _]
                  when fv.vname = "__builtin_constant_p" ->
                    finishExp (sf @@ sargs) (integer 1) intType
              | _ ->
                  let tmp, restyp' =
                    match what3 with
                      AExp (Some t) -> newTempVar t, t
                    | _ -> newTempVar resType', resType'
                  in
                  let i = Call(Some (var tmp),f3,args3, !currentLoc) in
                  finishExp (sf @@ sargs +++ i) (Lval(var tmp)) restyp'
          end
        end

    | A.COMMA el ->
        if isconst then
          E.s (error "COMMA in constant");
        let rec loop sofar = function
            [e] ->
              let (se, e', t') = doExp false e what in (* Pass on the action *)
              (sofar @@ se, e', t')
(*
              finishExp (sofar @@ se) e' t' (* does not hurt to do it twice.
                                             * GN: it seems it does *)
*)
          | e :: rest ->
              let (se, _, _) = doExp false e ADrop in
              loop (sofar @@ se) rest
          | [] -> E.s (error "empty COMMA expression")
        in
        loop empty el

    | A.QUESTION (e1,e2,e3) when what = ADrop ->
        if isconst then
          E.s (error "QUESTION with ADrop in constant");
        let (se3,_,_) = doExp false e3 ADrop in
        let se2 =
          match e2 with
            A.NOTHING -> skipChunk
          | _ -> let (se2,_,_) = doExp false e2 ADrop in se2
        in
        finishExp (doCondition isconst e1 se2 se3) zero intType

    | A.QUESTION (e1, e2, e3) -> begin (* what is not ADrop *)
        (* Compile the conditional expression *)
        let ce1 = doCondExp isconst e1 in
        (* Now we must find the type of both branches, in order to compute
         * the type of the result *)
        let se2, e2'o (* is an option. None means use e1 *), t2 =
          match e2 with
            A.NOTHING -> begin (* The same as the type of e1 *)
              match ce1 with
                CEExp (_, e1') -> empty, None, typeOf e1' (* Do not promote
                                                             to bool *)
              | _ -> empty, None, intType
            end
          | _ ->
              let se2, e2', t2 = doExp isconst e2 (AExp None) in
              se2, Some e2', t2
        in
        (* Do e3 for real *)
        let se3, e3', t3 = doExp isconst e3 (AExp None) in
        (* Compute the type of the result *)
        let tresult = conditionalConversion t2 t3 in
        match ce1 with
          CEExp (se1, Const(CInt64(i, _, _)))
           when i = Int64.zero && canDrop se2 ->
             finishExp (se1 @@ se3) (snd (castTo t3 tresult e3')) tresult
        | CEExp (se1, (Const(CInt64(i, _, _)) as e1'))
           when i <> Int64.zero && canDrop se3 -> begin
             match e2'o with
               None -> (* use e1' *)
                 finishExp (se1 @@ se2) (snd (castTo t2 tresult e1')) tresult
             | Some e2' ->
                 finishExp (se1 @@ se2) (snd (castTo t2 tresult e2')) tresult
           end

        | _ -> (* Use a conditional *) begin
            match e2 with
              A.NOTHING ->
                let tmp = var (newTempVar tresult) in
                let (se1, _, _) = doExp isconst e1 (ASet(tmp, tresult)) in
                let (se3, _, _) = doExp isconst e3 (ASet(tmp, tresult)) in
                finishExp (se1 @@ ifChunk (Lval(tmp)) lu
                                    skipChunk se3)
                  (Lval(tmp))
                  tresult
            | _ ->
                let lv, lvt =
                  match what with
                  | ASet (lv, lvt) -> lv, lvt
                  | _ ->
                      let tmp = newTempVar tresult in
                      var tmp, tresult
                in
                (* Now do e2 and e3 for real *)
                let (se2, _, _) = doExp isconst e2 (ASet(lv, lvt)) in
                let (se3, _, _) = doExp isconst e3 (ASet(lv, lvt)) in
                finishExp (doCondition isconst e1 se2 se3) (Lval(lv)) tresult
        end

(*
        (* Do these only to collect the types  *)
        let se2, e2', t2' =
          match e2 with
            A.NOTHING -> (* A GNU thing. Use e1 as e2 *)
              doExp isconst e1 (AExp None)
          | _ -> doExp isconst e2 (AExp None) in
        (* Do e3 for real *)
        let se3, e3', t3' = doExp isconst e3 (AExp None) in
        (* Compute the type of the result *)
        let tresult = conditionalConversion e2' t2' e3' t3' in
        if     (isEmpty se2 || e2 = A.NOTHING)
            && isEmpty se3 && isconst then begin
          (* Use the Question. This allows Question in initializers without
          * having to do constant folding  *)
          let se1, e1', t1 = doExp isconst e1 (AExp None) in
          ignore (checkBool t1 e1');
          let e2'' =
            if e2 = A.NOTHING then
              mkCastT e1' t1 tresult
            else mkCastT e2' t2' tresult (* We know se2 is empty *)
          in
          let e3'' = mkCastT e3' t3' tresult in
          let resexp =
            match e1' with
              Const(CInt64(i, _, _)) when i <> Int64.zero -> e2''
            | Const(CInt64(z, _, _)) when z = Int64.zero -> e3''
            | _ -> Question(e1', e2'', e3'')
          in
          finishExp se1 resexp tresult
        end else begin (* Now use a conditional *)
          match e2 with
            A.NOTHING ->
              let tmp = var (newTempVar tresult) in
              let (se1, _, _) = doExp isconst e1 (ASet(tmp, tresult)) in
              let (se3, _, _) = doExp isconst e3 (ASet(tmp, tresult)) in
              finishExp (se1 @@ ifChunk (Lval(tmp)) lu
                                  skipChunk se3)
                (Lval(tmp))
                tresult
          | _ ->
              let lv, lvt =
                match what with
                | ASet (lv, lvt) -> lv, lvt
                | _ ->
                    let tmp = newTempVar tresult in
                    var tmp, tresult
              in
              (* Now do e2 and e3 for real *)
              let (se2, _, _) = doExp isconst e2 (ASet(lv, lvt)) in
              let (se3, _, _) = doExp isconst e3 (ASet(lv, lvt)) in
              finishExp (doCondition isconst e1 se2 se3) (Lval(lv)) tresult
        end
*)
    end

    | A.GNU_BODY b -> begin
        (* Find the last A.COMPUTATION and remember it. This one is invoked
         * on the reversed list of statements. *)
        let rec findLastComputation = function
            s :: _  ->
              let rec findLast = function
                  A.SEQUENCE (_, s, loc) -> findLast s
                | CASE (_, s, _) -> findLast s
                | CASERANGE (_, _, s, _) -> findLast s
                | LABEL (_, s, _) -> findLast s
                | (A.COMPUTATION _) as s -> s
                | _ -> raise Not_found
              in
              findLast s
          | [] -> raise Not_found
        in
        (* Save the previous data *)
        let old_gnu = ! gnu_body_result in
        let lastComp, isvoidbody =
          match what with
            ADrop -> (* We are dropping the result *)
              A.NOP cabslu, true
          | _ ->
              try findLastComputation (List.rev b.A.bstmts), false
              with Not_found ->
                E.s (error "Cannot find COMPUTATION in GNU.body")
                  (*                A.NOP cabslu, true *)
        in
        (* Prepare some data to be filled by doExp *)
        let data : (exp * typ) option ref = ref None in
        gnu_body_result := (lastComp, data);

        let se = doBody b in

        gnu_body_result := old_gnu;
        match !data with
          None when isvoidbody -> finishExp se zero voidType
        | None -> E.s (bug "Cannot find COMPUTATION in GNU.body")
        | Some (e, t) -> finishExp se e t
    end

    | A.LABELADDR l -> begin (* GCC's taking the address of a label *)
        let l = lookupLabel l in (* To support locallly declared labels *)
        let addrval =
          try H.find gotoTargetHash l
          with Not_found -> begin
            let res = !gotoTargetNextAddr in
            incr gotoTargetNextAddr;
            H.add gotoTargetHash l res;
            res
          end
        in
        finishExp empty (mkCast (integer addrval) voidPtrType) voidPtrType
    end

    | A.EXPR_PATTERN _ -> E.s (E.bug "EXPR_PATTERN in cabs2cil input")

  with e -> begin
    ignore (E.log "error in doExp (%s)@!" (Printexc.to_string e));
    (i2c (dInstr (dprintf "booo_exp(%t)" d_thisloc) !currentLoc),
     integer 0, intType)
  end

(* bop is always the arithmetic version. Change it to the appropriate pointer
 * version if necessary *)
and doBinOp (bop: binop) (e1: exp) (t1: typ) (e2: exp) (t2: typ) : typ * exp =
  let doArithmetic () =
    let tres = arithmeticConversion t1 t2 in
    (* Keep the operator since it is arithmetic *)
    tres,
    constFoldBinOp false bop (mkCastT e1 t1 tres) (mkCastT e2 t2 tres) tres
  in
  let doArithmeticComp () =
    let tres = arithmeticConversion t1 t2 in
    (* Keep the operator since it is arithemtic *)
    intType,
    constFoldBinOp false bop (mkCastT e1 t1 tres) (mkCastT e2 t2 tres) intType
  in
  let doIntegralArithmetic () =
    let tres = unrollType (arithmeticConversion t1 t2) in
    match tres with
      TInt _ ->
        tres,
        constFoldBinOp false bop (mkCastT e1 t1 tres) (mkCastT e2 t2 tres) tres
    | _ -> E.s (error "%a operator on a non-integer type" d_binop bop)
  in
  let pointerComparison e1 t1 e2 t2 =
    (* Cast both sides to an integer *)
    let commontype = !upointType in
    intType,
    constFoldBinOp false bop (mkCastT e1 t1 commontype)
      (mkCastT e2 t2 commontype) intType
  in

  match bop with
    (Mult|Div) -> doArithmetic ()
  | (Mod|BAnd|BOr|BXor) -> doIntegralArithmetic ()
  | (Shiftlt|Shiftrt) -> (* ISO 6.5.7. Only integral promotions. The result
                          * has the same type as the left hand side *)
      if !msvcMode then
        (* MSVC has a bug. We duplicate it here *)
        doIntegralArithmetic ()
      else
        let t1' = integralPromotion t1 in
        let t2' = integralPromotion t2 in
        t1',
        constFoldBinOp false bop (mkCastT e1 t1 t1') (mkCastT e2 t2 t2') t1'

  | (PlusA|MinusA)
      when isArithmeticType t1 && isArithmeticType t2 -> doArithmetic ()
  | (Eq|Ne|Lt|Le|Ge|Gt)
      when isArithmeticType t1 && isArithmeticType t2 ->
        doArithmeticComp ()
  | PlusA when isPointerType t1 && isIntegralType t2 ->
      t1,
      constFoldBinOp false PlusPI e1 (mkCastT e2 t2 (integralPromotion t2)) t1
  | PlusA when isIntegralType t1 && isPointerType t2 ->
      t2,
      constFoldBinOp false PlusPI e2 (mkCastT e1 t1 (integralPromotion t1)) t2
  | MinusA when isPointerType t1 && isIntegralType t2 ->
      t1,
      constFoldBinOp false MinusPI e1 (mkCastT e2 t2 (integralPromotion t2)) t1
  | MinusA when isPointerType t1 && isPointerType t2 ->
      let commontype = t1 in
      intType,
      constFoldBinOp false MinusPP (mkCastT e1 t1 commontype)
                                   (mkCastT e2 t2 commontype) intType
  | (Le|Lt|Ge|Gt|Eq|Ne) when isPointerType t1 && isPointerType t2 ->
      pointerComparison e1 t1 e2 t2
  | (Eq|Ne) when isPointerType t1 && isZero e2 ->
      pointerComparison e1 t1 (mkCastT zero intType t1) t1
  | (Eq|Ne) when isPointerType t2 && isZero e1 ->
      pointerComparison (mkCastT zero intType t2) t2 e2 t2


  | (Eq|Ne|Le|Lt|Ge|Gt) when isPointerType t1 && isArithmeticType t2 ->
      ignore (warnOpt "Comparison of pointer and non-pointer");
      (* Cast both values to upointType *)
      doBinOp bop (mkCastT e1 t1 !upointType) !upointType
                  (mkCastT e2 t2 !upointType) !upointType
  | (Eq|Ne|Le|Lt|Ge|Gt) when isArithmeticType t1 && isPointerType t2 ->
      ignore (warnOpt "Comparison of pointer and non-pointer");
      (* Cast both values to upointType *)
      doBinOp bop (mkCastT e1 t1 !upointType) !upointType
                  (mkCastT e2 t2 !upointType) !upointType

  | _ -> E.s (error "doBinOp: %a\n" d_plainexp (BinOp(bop,e1,e2,intType)))

(* Constant fold a conditional. This is because we want to avoid having
 * conditionals in the initializers. So, we try very hard to avoid creating
 * new statements. *)
and doCondExp (isconst: bool)
              (e: A.expression) : condExpRes =
  let rec addChunkBeforeCE (c0: chunk) = function
      CEExp (c, e) -> CEExp (c0 @@ c, e)
    | CEAnd (ce1, ce2) -> CEAnd (addChunkBeforeCE c0 ce1, ce2)
    | CEOr (ce1, ce2) -> CEOr (addChunkBeforeCE c0 ce1, ce2)
    | CENot ce1 -> CENot (addChunkBeforeCE c0 ce1)
  in
  let rec canDropCE = function
      CEExp (c, e) -> canDrop c
    | CEAnd (ce1, ce2) | CEOr (ce1, ce2) -> canDropCE ce1 && canDropCE ce2
    | CENot (ce1) -> canDropCE ce1
  in
  match e with
    A.BINARY (A.AND, e1, e2) -> begin
      let ce1 = doCondExp isconst e1 in
      let ce2 = doCondExp isconst e2 in
      match ce1, ce2 with
        CEExp (se1, (Const(CInt64 _) as ci1)), _ ->
          if not (isZero ci1) then
            addChunkBeforeCE se1 ce2
          else
            (* se2 might contain labels so we cannot drop it *)
            if canDropCE ce2 then
              ce1
            else
              CEAnd (ce1, ce2)
      | CEExp(se1, e1'), CEExp (se2, e2') when
              !useLogicalOperators && isEmpty se1 && isEmpty se2 ->
          CEExp (empty, BinOp(LAnd,
                              mkCast e1' intType,
                              mkCast e2' intType, intType))
      | _ -> CEAnd (ce1, ce2)
    end

  | A.BINARY (A.OR, e1, e2) -> begin
      let ce1 = doCondExp isconst e1 in
      let ce2 = doCondExp isconst e2 in
      match ce1, ce2 with
        CEExp (se1, (Const(CInt64 _) as ci1)), _ ->
          if isZero ci1 then
            addChunkBeforeCE se1 ce2
          else
            (* se2 might contain labels so we cannot drop it *)
            if canDropCE ce2 then
              ce1
            else
              CEOr (ce1, ce2)

      | CEExp (se1, e1'), CEExp (se2, e2') when
              !useLogicalOperators && isEmpty se1 && isEmpty se2 ->
          CEExp (empty, BinOp(LOr, mkCast e1' intType,
                              mkCast e2' intType, intType))
      | _ -> CEOr (ce1, ce2)
    end

  | A.UNARY(A.NOT, e1) -> begin
      match doCondExp isconst e1 with
        CEExp (se1, (Const(CInt64 _) as ci1)) ->
          if isZero ci1 then
            CEExp (se1, one)
          else
            CEExp (se1, zero)
      | CEExp (se1, e) when isEmpty se1 ->
          CEExp (empty, UnOp(LNot, mkCast e intType, intType))

      | ce1 -> CENot ce1
  end

  | _ ->
      let (se, e, t) as rese = doExp isconst e (AExp None) in
      ignore (checkBool t e);
      CEExp (se, constFold isconst e)

and compileCondExp (ce: condExpRes) (st: chunk) (sf: chunk) : chunk =
  match ce with
  | CEAnd (ce1, ce2) ->
      let (sf1, sf2) =
        (* If sf is small then will copy it *)
        try (sf, duplicateChunk sf)
        with Failure _ ->
          let lab = newLabelName "_L" in
          (gotoChunk lab lu, consLabel lab sf !currentLoc false)
      in
      let st' = compileCondExp ce2 st sf1 in
      let sf' = sf2 in
      compileCondExp ce1 st' sf'

  | CEOr (ce1, ce2) ->
      let (st1, st2) =
        (* If st is small then will copy it *)
        try (st, duplicateChunk st)
        with Failure _ ->
          let lab = newLabelName "_L" in
          (gotoChunk lab lu, consLabel lab st !currentLoc false)
      in
      let st' = st1 in
      let sf' = compileCondExp ce2 st2 sf in
      compileCondExp ce1 st' sf'

  | CENot ce1 -> compileCondExp ce1 sf st

  | CEExp (se, e) -> begin
      match e with
        Const(CInt64(i,_,_)) when i <> Int64.zero && canDrop sf -> se @@ st
      | Const(CInt64(z,_,_)) when z = Int64.zero && canDrop st -> se @@ sf
      | _ -> se @@ ifChunk e !currentLoc st sf
  end


(* A special case for conditionals *)
and doCondition (isconst: bool) (* If we are in constants, we do our best to
                                 * eliminate the conditional *)
                (e: A.expression)
                (st: chunk)
                (sf: chunk) : chunk =
  compileCondExp (doCondExp isconst e) st sf


and doPureExp (e : A.expression) : exp =
  let (se, e', _) = doExp true e (AExp None) in
  if isNotEmpty se then
   E.s (error "doPureExp: not pure");
  e'

and doInitializer
    (vi: varinfo)
    (inite: A.init_expression)
   (* Return the accumulated chunk, the initializer and the new type (might be
    * different for arrays) *)
  : chunk * init * typ =

  (* Setup the pre-initializer *)
  let topPreInit = ref NoInitPre in
  if debugInit then
    ignore (E.log "\nStarting a new initializer for %s : %a\n"
              vi.vname d_type vi.vtype);
  let topSetupInit (o: offset) (e: exp) =
    if debugInit then
      ignore (E.log " set %a := %a\n"  d_lval (Var vi, o) d_exp e);
    let newinit = setOneInit !topPreInit o e in
    if newinit != !topPreInit then topPreInit := newinit
  in
  let acc, restl =
    let so = makeSubobj vi vi.vtype NoOffset in
    doInit vi.vglob topSetupInit so empty [ (A.NEXT_INIT, inite) ]
  in
  if restl <> [] then
    ignore (warn "Ignoring some initializers");
  (* sm: we used to do array-size fixups here, but they only worked
   * for toplevel array types; now, collectInitializer does the job,
   * including for nested array types *)
  let typ' = unrollType vi.vtype
  in
  if debugInit then
    ignore (E.log "Collecting the initializer for %s\n" vi.vname);
  let (init, typ'') = collectInitializer !topPreInit typ' in
  if debugInit then
    ignore (E.log "Finished the initializer for %s\n" vi.vname);
  acc, init, typ''



(* Consume some initializers. Watch out here. Make sure we use only
 * tail-recursion because these things can be big.  *)
and doInit
    (isconst: bool)
    (setone: offset -> exp -> unit) (* Use to announce an intializer *)
    (so: subobj)
    (acc: chunk)
    (initl: (A.initwhat * A.init_expression) list)

    (* Return the resulting chunk along with some unused initializers *)
  : chunk * (A.initwhat * A.init_expression) list =

  let whoami () = d_lval () (Var so.host, so.soOff) in

  let initl1 =
    match initl with
    | (A.NEXT_INIT,
       A.SINGLE_INIT (A.CAST ((s, dt), ie))) :: rest ->
         let s', dt', ie' = preprocessCast s dt ie in
         (A.NEXT_INIT, A.SINGLE_INIT (A.CAST ((s', dt'), ie'))) :: rest
    | _ -> initl
  in
      (* Sometimes we have a cast in front of a compound (in GCC). This
       * appears as a single initializer. Ignore the cast  *)
  let initl2 =
    match initl1 with
      (what,
       A.SINGLE_INIT (A.CAST (_, A.COMPOUND_INIT ci))) :: rest ->
         (what, A.COMPOUND_INIT ci) :: rest
    | _ -> initl1
  in
  let allinitl = initl2 in

  if debugInit then begin
    ignore (E.log "doInit for %t %s (current %a). Looking at: " whoami
              (if so.eof then "(eof)" else "")
              d_lval (Var so.host, so.curOff));
    (match allinitl with
      [] -> ignore (E.log "[]")
    | (what, ie) :: _ ->
        withFlx_cil_cprint
          Flx_cil_cprint.print_init_expression (A.COMPOUND_INIT [(what, ie)]));
    ignore (E.log "\n");
  end;
  match unrollType so.soTyp, allinitl with
    _, [] -> acc, [] (* No more initializers return *)

        (* No more subobjects *)
  | _, (A.NEXT_INIT, _) :: _ when so.eof -> acc, allinitl


        (* If we are at an array of characters and the initializer is a
         * string literal (optionally enclosed in braces) then explode the
         * string into characters *)
  | TArray(bt, leno, _),
      (A.NEXT_INIT,
       (A.SINGLE_INIT(A.CONSTANT (A.CONST_STRING s))|
       A.COMPOUND_INIT
         [(A.NEXT_INIT,
           A.SINGLE_INIT(A.CONSTANT
                           (A.CONST_STRING s)))])) :: restil
    when (match unrollType bt with
            TInt((IChar|IUChar|ISChar), _) -> true
          | TInt _ ->
              (*Base type is a scalar other than char. Maybe a wchar_t?*)
              E.s (error "Using a string literal to initialize something other than a character array.\n")
          | _ ->  false (* OK, this is probably an array of strings. Handle *)
         )              (* it with the other arrays below.*)
    ->
      let charinits =
        let init c = A.NEXT_INIT, A.SINGLE_INIT(A.CONSTANT (A.CONST_CHAR [c]))
        in
        let collector =
          (* ISO 6.7.8 para 14: final NUL added only if no size specified, or
           * if there is room for it; btw, we can't rely on zero-init of
           * globals, since this array might be a local variable *)
          if ((isNone leno) or ((String.length s) < (integerArrayLength leno)))
            then ref [init Int64.zero]
            else ref []
        in
        for pos = String.length s - 1 downto 0 do
          collector := init (Int64.of_int (Char.code (s.[pos]))) :: !collector
        done;
        !collector
      in
      (* Create a separate object for the array *)
      let so' = makeSubobj so.host so.soTyp so.soOff in
      (* Go inside the array *)
      let leno = integerArrayLength leno in
      so'.stack <- [InArray(so'.curOff, bt, leno, ref 0)];
      normalSubobj so';
      let acc', initl' = doInit isconst setone so' acc charinits in
      if initl' <> [] then
        ignore (warn "Too many initializers for character array %t" whoami);
      (* Advance past the array *)
      advanceSubobj so;
      (* Continue *)
      let res = doInit isconst setone so acc' restil in
      res

        (* If we are at an array of WIDE characters and the initializer is a
         * WIDE string literal (optionally enclosed in braces) then explore
         * the WIDE string into characters *)
  (* [weimer] Wed Jan 30 15:38:05 PST 2002
   * Despite what the compiler says, this match case is used and it is
   * important. *)
  | TArray(bt, leno, _),
      (A.NEXT_INIT,
       (A.SINGLE_INIT(A.CONSTANT (A.CONST_WSTRING s)) |
       A.COMPOUND_INIT
         [(A.NEXT_INIT,
           A.SINGLE_INIT(A.CONSTANT
                           (A.CONST_WSTRING s)))])) :: restil
    when(let bt' = unrollType bt in
         match bt' with
           (* compare bt to wchar_t, ignoring signed vs. unsigned *)
           TInt _ when (bitsSizeOf bt') = (bitsSizeOf !wcharType) -> true
         | TInt _ ->
              (*Base type is a scalar other than wchar_t.  Maybe a char?*)
              E.s (error "Using a wide string literal to initialize something other than a wchar_t array.\n")
         | _ -> false (* OK, this is probably an array of strings. Handle *)
        )             (* it with the other arrays below.*)
    ->
      let maxWChar =  (*  (2**(bitsSizeOf !wcharType)) - 1  *)
        Int64.sub (Int64.shift_left Int64.one (bitsSizeOf !wcharType))
          Int64.one in
      let charinits =
        let init c =
          if (compare c maxWChar > 0) then (* if c > maxWChar *)
            E.s (error "cab2cil:doInit:character 0x%Lx too big." c);
          A.NEXT_INIT,
          A.SINGLE_INIT(A.CONSTANT (A.CONST_INT (Int64.to_string c)))
        in
        (List.map init s) @
        (
          (* ISO 6.7.8 para 14: final NUL added only if no size specified, or
           * if there is room for it; btw, we can't rely on zero-init of
           * globals, since this array might be a local variable *)
          if ((isNone leno) or ((List.length s) < (integerArrayLength leno)))
            then [init Int64.zero]
            else [])
(*
        List.map
          (fun c ->
            if (compare c maxWChar > 0) then (* if c > maxWChar *)
              E.s (error "cab2cil:doInit:character 0x%Lx too big." c)
            else
              (A.NEXT_INIT,
               A.SINGLE_INIT(A.CONSTANT (A.CONST_INT (Int64.to_string c)))))
      s
*)
      in
      (* Create a separate object for the array *)
      let so' = makeSubobj so.host so.soTyp so.soOff in
      (* Go inside the array *)
      let leno = integerArrayLength leno in
      so'.stack <- [InArray(so'.curOff, bt, leno, ref 0)];
      normalSubobj so';
      let acc', initl' = doInit isconst setone so' acc charinits in
      if initl' <> [] then
        (* sm: see above regarding ISO 6.7.8 para 14, which is not implemented
         * for wchar_t because, as far as I can tell, we don't even put in
         * the automatic NUL (!) *)
        ignore (warn "Too many initializers for wchar_t array %t" whoami);
      (* Advance past the array *)
      advanceSubobj so;
      (* Continue *)
      doInit isconst setone so acc' restil

      (* If we are at an array and we see a single initializer then it must
       * be one for the first element *)
  | TArray(bt, leno, al), (A.NEXT_INIT, A.SINGLE_INIT oneinit) :: restil  ->
      (* Grab the length if there is one *)
      let leno = integerArrayLength leno in
      so.stack <- InArray(so.soOff, bt, leno, ref 0) :: so.stack;
      normalSubobj so;
      (* Start over with the fields *)
      doInit isconst setone so acc allinitl

    (* If we are at a composite and we see a single initializer of the same
     * type as the composite then grab it all. If the type is not the same
     * then we must go on and try to initialize the fields *)
  | TComp (comp, _), (A.NEXT_INIT, A.SINGLE_INIT oneinit) :: restil ->
      let se, oneinit', t' = doExp isconst oneinit (AExp None) in
      if (match unrollType t' with
             TComp (comp', _) when comp'.ckey = comp.ckey -> true
            | _ -> false)
      then begin
        (* Initialize the whole struct *)
        setone so.soOff oneinit';
        (* Advance to the next subobject *)
        advanceSubobj so;
        doInit isconst setone so (acc @@ se) restil
      end else begin (* Try to initialize fields *)
        let toinit = fieldsToInit comp None in
        so.stack <- InComp(so.soOff, comp, toinit) :: so.stack;
        normalSubobj so;
        doInit isconst setone so acc allinitl
      end

     (* A scalar with a single initializer *)
  | _, (A.NEXT_INIT, A.SINGLE_INIT oneinit) :: restil ->
      let se, oneinit', t' = doExp isconst oneinit (AExp(Some so.soTyp)) in
      setone so.soOff (mkCastT oneinit' t' so.soTyp);
      (* Move on *)
      advanceSubobj so;
      doInit isconst setone so (acc @@ se) restil


     (* An array with a compound initializer. The initializer is for the
      * array elements *)
  | TArray (bt, leno, _), (A.NEXT_INIT, A.COMPOUND_INIT initl) :: restil ->
      (* Create a separate object for the array *)
      let so' = makeSubobj so.host so.soTyp so.soOff in
      (* Go inside the array *)
      let leno = integerArrayLength leno in
      so'.stack <- [InArray(so'.curOff, bt, leno, ref 0)];
      normalSubobj so';
      let acc', initl' = doInit isconst setone so' acc initl in
      if initl' <> [] then
        ignore (warn "Too many initializers for array %t" whoami);
      (* Advance past the array *)
      advanceSubobj so;
      (* Continue *)
      let res = doInit isconst setone so acc' restil in
      res

   (* We have a designator that tells us to select the matching union field.
    * This is to support a GCC extension *)
  | TComp(ci, _), [(A.NEXT_INIT,
                    A.COMPOUND_INIT [(A.INFIELD_INIT ("___matching_field",
                                                     A.NEXT_INIT),
                                      A.SINGLE_INIT oneinit)])]
                      when not ci.cstruct ->
      (* Do the expression to find its type *)
      let _, _, t' = doExp isconst oneinit (AExp None) in
      let tsig = typeSigWithAttrs (fun _ -> []) t' in
      let rec findField = function
          [] -> E.s (error "Cannot find matching union field in cast")
        | fi :: rest when typeSigWithAttrs (fun _ -> []) fi.ftype = tsig -> fi
        | _ :: rest -> findField rest
      in
      let fi = findField ci.cfields in
      (* Change the designator and redo *)
      doInit isconst setone so acc [(A.INFIELD_INIT (fi.fname, A.NEXT_INIT),
                                     A.SINGLE_INIT oneinit)]


        (* A structure with a composite initializer. We initialize the fields*)
  | TComp (comp, _), (A.NEXT_INIT, A.COMPOUND_INIT initl) :: restil ->
      (* Create a separate subobject iterator *)
      let so' = makeSubobj so.host so.soTyp so.soOff in
      (* Go inside the comp *)
      so'.stack <- [InComp(so'.curOff, comp, fieldsToInit comp None)];
      normalSubobj so';
      let acc', initl' = doInit isconst setone so' acc initl in
      if initl' <> [] then
        ignore (warn "Too many initializers for structure");
      (* Advance past the structure *)
      advanceSubobj so;
      (* Continue *)
      doInit isconst setone so acc' restil

        (* A scalar with a initializer surrounded by braces *)
  | _, (A.NEXT_INIT, A.COMPOUND_INIT [(A.NEXT_INIT,
                                       A.SINGLE_INIT oneinit)]) :: restil ->
      let se, oneinit', t' = doExp isconst oneinit (AExp(Some so.soTyp)) in
      setone so.soOff (mkCastT oneinit' t' so.soTyp);
      (* Move on *)
      advanceSubobj so;
      doInit isconst setone so (acc @@ se) restil

  | t, (A.NEXT_INIT, _) :: _ ->
      E.s (unimp "doInit: unexpected NEXT_INIT for %a\n" d_type t);

   (* We have a designator *)
  | _, (what, ie) :: restil when what != A.NEXT_INIT ->
      (* Process a designator and position to the designated subobject *)
      let rec addressSubobj
          (so: subobj)
          (what: A.initwhat)
          (acc: chunk) : chunk =
        (* Always start from the current element *)
        so.stack <- []; so.eof <- false;
        normalSubobj so;
        let rec address (what: A.initwhat) (acc: chunk)  : chunk =
          match what with
            A.NEXT_INIT -> acc
          | A.INFIELD_INIT (fn, whatnext) -> begin
              match unrollType so.soTyp with
                TComp (comp, _) ->
                  let toinit = fieldsToInit comp (Some fn) in
                  so.stack <- InComp(so.soOff, comp, toinit) :: so.stack;
                  normalSubobj so;
                  address whatnext acc

              | _ -> E.s (error "Field designator %s not in a struct " fn)
          end

          | A.ATINDEX_INIT(idx, whatnext) -> begin
              match unrollType so.soTyp with
                TArray (bt, leno, _) ->
                  let ilen = integerArrayLength leno in
                  let nextidx', doidx =
                    let (doidx, idxe', _) =
                      doExp true idx (AExp(Some intType)) in
                    match constFold true idxe', isNotEmpty doidx with
                      Const(CInt64(x, _, _)), false -> Int64.to_int x, doidx
                    | _ -> E.s (error
                      "INDEX initialization designator is not a constant")
                  in
                  if nextidx' < 0 || nextidx' >= ilen then
                    E.s (error "INDEX designator is outside bounds");
                  so.stack <-
                     InArray(so.soOff, bt, ilen, ref nextidx') :: so.stack;
                  normalSubobj so;
                  address whatnext (acc @@ doidx)

              | _ -> E.s (error "INDEX designator for a non-array")
          end

          | A.ATINDEXRANGE_INIT _ ->
              E.s (bug "addressSubobj: INDEXRANGE")
        in
        address what acc
      in
      (* First expand the INDEXRANGE by making copies *)
      let rec expandRange (top: A.initwhat -> A.initwhat) = function
        | A.INFIELD_INIT (fn, whatnext) ->
            expandRange (fun what -> top (A.INFIELD_INIT(fn, what))) whatnext
        | A.ATINDEX_INIT (idx, whatnext) ->
            expandRange (fun what -> top (A.ATINDEX_INIT(idx, what))) whatnext

        | A.ATINDEXRANGE_INIT (idxs, idxe) ->
            let (doidxs, idxs', _) =
              doExp true idxs (AExp(Some intType)) in
            let (doidxe, idxe', _) =
              doExp true idxe (AExp(Some intType)) in
            if isNotEmpty doidxs || isNotEmpty doidxe then
              E.s (error "Range designators are not constants\n");
            let first, last =
              match constFold true idxs', constFold true idxe' with
                Const(CInt64(s, _, _)),
                Const(CInt64(e, _, _)) ->
                  Int64.to_int s, Int64.to_int e
              | _ -> E.s (error
                 "INDEX_RANGE initialization designator is not a constant")
            in
            if first < 0 || first > last then
              E.s (error
                     "start index larger than end index in range initializer");
            let rec loop (i: int) =
              if i > last then restil
              else
                (top (A.ATINDEX_INIT(A.CONSTANT(A.CONST_INT(string_of_int i)),
                                     A.NEXT_INIT)), ie)
                :: loop (i + 1)
            in
            doInit isconst setone so acc (loop first)

        | A.NEXT_INIT -> (* We have not found any RANGE *)
            let acc' = addressSubobj so what acc in
            doInit isconst setone so (acc @@ acc')
              ((A.NEXT_INIT, ie) :: restil)
      in
      expandRange (fun x -> x) what

  | t, (what, ie) :: _ ->
      E.s (bug "doInit: cases for t=%a" d_type t)


(* Create and add to the file (if not already added) a global. Return the
 * varinfo *)
and createGlobal (specs : (typ * storage * bool * A.attribute list))
                 (((n,ndt,a,cloc) as nm, inite) : A.init_name) : varinfo =
  try
    if debugGlobal then
      ignore (E.log "createGlobal: %s\n" n);
            (* Make a first version of the varinfo *)
    let vi = makeVarInfoFlx_cil_cabs ~isformal:false
                             ~isglobal:true (convLoc cloc) specs (n,ndt,a) in
    (* Add the variable to the environment before doing the initializer
     * because it might refer to the variable itself *)
    if isFunctionType vi.vtype then begin
      if inite != A.NO_INIT  then
        E.s (error "Function declaration with initializer (%s)\n"
               vi.vname);
      (* sm: if it's a function prototype, and the storage class *)
      (* isn't specified, make it 'extern'; this fixes a problem *)
      (* with no-storage prototype and static definition *)
      if vi.vstorage = NoStorage then
        (*(trace "sm" (dprintf "adding extern to prototype of %s\n" n));*)
        vi.vstorage <- Extern;
    end;
    let vi, alreadyInEnv = makeGlobalVarinfo (inite != A.NO_INIT) vi in
(*
    ignore (E.log "createGlobal %a: %s type=%a\n"
       d_loc (convLoc cloc) vi.vname d_plaintype vi.vtype);
*)
            (* Do the initializer and complete the array type if necessary *)
    let init : init option =
      if inite = A.NO_INIT then
        None
      else
        let se, ie', et = doInitializer vi inite in
        (* Maybe we now have a better type *)
        vi.vtype <- et;
        if isNotEmpty se then
          E.s (error "global initializer");
        Some ie'
    in

    try
      let oldloc = H.find alreadyDefined vi.vname in
      if init != None then begin
        E.s (error "Global %s was already defined at %a\n"
               vi.vname d_loc oldloc);
      end;
      if debugGlobal then
        ignore (E.log " global %s was already defined\n" vi.vname);
      (* Do not declare it again *)
      vi
    with Not_found -> begin
      (* Not already defined *)
      if debugGlobal then
        ignore (E.log " first definition for %s\n" vi.vname);
      if init != None then begin
        (* weimer: Sat Dec  8 17:43:34  2001
         * MSVC NT Kernel headers include this lovely line:
         * extern const GUID __declspec(selectany) \
         *  MOUNTDEV_MOUNTED_DEVICE_GUID = { 0x53f5630d, 0xb6bf, 0x11d0, { \
         *  0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b } };
         * So we allow "extern" + "initializer" if "const" is
         * around. *)
        (* sm: As I read the ISO spec, in particular 6.9.2 and 6.7.8,
         * "extern int foo = 3" is exactly equivalent to "int foo = 3";
         * that is, if you put an initializer, then it is a definition,
         * and "extern" is redundantly giving the name external linkage.
         * gcc emits a warning, I guess because it is contrary to
         * usual practice, but I think CIL warnings should be about
         * semantic rather than stylistic issues, so I see no reason to
         * even emit a warning. *)
        if vi.vstorage = Extern then
          vi.vstorage <- NoStorage;     (* equivalent and canonical *)

        H.add alreadyDefined vi.vname !currentLoc;
        H.remove mustTurnIntoDef vi.vid;
        cabsPushGlobal (GVar(vi, {init = init}, !currentLoc));
        vi
      end else begin
        if not (isFunctionType vi.vtype)
           && not (H.mem mustTurnIntoDef vi.vid) then
          begin
            H.add mustTurnIntoDef vi.vid true
          end;
        if not alreadyInEnv then begin (* Only one declaration *)
          (* If it has function type it is a prototype *)
          cabsPushGlobal (GVarDecl (vi, !currentLoc));
          vi
        end else begin
          if debugGlobal then
            ignore (E.log " already in env %s\n" vi.vname);
          vi
        end
      end
    end
  with e -> begin
    ignore (E.log "error in createGlobal(%s: %a): %s\n" n
              d_loc !currentLoc
              (Printexc.to_string e));
    cabsPushGlobal (dGlobal (dprintf "booo - error in global %s (%t)"
                           n d_thisloc) !currentLoc);
    dummyFunDec.svar
  end
(*
          ignore (E.log "Env after processing global %s is:@!%t@!"
                    n docEnv);
          ignore (E.log "Alpha after processing global %s is:@!%t@!"
                    n docAlphaTable)
*)

(* Must catch the Static local variables. Make them global *)
and createLocal ((_, sto, _, _) as specs)
                ((((n, ndt, a, cloc) : A.name),
                  (e: A.init_expression)) as init_name)
  : chunk =
  let loc = convLoc cloc in
  (* Flx_cil_check if we are declaring a function *)
  let rec isProto (dt: decl_type) : bool =
    match dt with
    | PROTO (JUSTBASE, _, _) -> true
    | PROTO (x, _, _) -> isProto x
    | PARENTYPE (_, x, _) -> isProto x
    | ARRAY (x, _, _) -> isProto x
    | PTR (_, x) -> isProto x
    | _ -> false
  in
  match ndt with
    (* Maybe we have a function prototype in local scope. Make it global. We
     * do this even if the storage is Static *)
  | _ when isProto ndt ->
      let vi = createGlobal specs init_name in
      (* Add it to the environment to shadow previous decls *)
      addLocalToEnv n (EnvVar vi);
      empty

  | _ when sto = Static ->
      if debugGlobal then
        ignore (E.log "createGlobal (local static): %s\n" n);

      (* Now alpha convert it to make sure that it does not conflict with
       * existing globals or locals from this function. *)
      let newname, _  = newAlphaName true "" n in
      (* Make it global  *)
      let vi = makeVarInfoFlx_cil_cabs ~isformal:false
                               ~isglobal:true
                               loc specs (newname, ndt, a) in
      (* However, we have a problem if a real global appears later with the
       * name that we have happened to choose for this one. Remember these names
       * for later. *)
      H.add staticLocals vi.vname vi;
      (* Add it to the environment as a local so that the name goes out of
       * scope properly *)
      addLocalToEnv n (EnvVar vi);
      let init : init option =
        if e = A.NO_INIT then
          None
        else begin
          let se, ie', et = doInitializer vi e in
          (* Maybe we now have a better type *)
          vi.vtype <- et;
          if isNotEmpty se then
            E.s (error "global static initializer");
          (* Maybe the initializer refers to the function itself.
             Push a prototype for the function, just in case. Hopefully,
             if does not refer to the locals *)
          cabsPushGlobal (GVarDecl (!currentFunctionFDEC.svar, !currentLoc));
          Some ie'
        end
      in
      cabsPushGlobal (GVar(vi, {init = init}, !currentLoc));
      empty

  (* Maybe we have an extern declaration. Make it a global *)
  | _ when sto = Extern ->
      let vi = createGlobal specs init_name in
      (* Add it to the local environment to ensure that it shadows previous
       * local variables *)
      addLocalToEnv n (EnvVar vi);
      empty

  | _ ->
      (* Make a variable of potentially variable size. If se0 <> empty then
       * it is a variable size variable *)
      let vi,se0,len,isvarsize =
        makeVarSizeVarInfo loc specs (n, ndt, a) in

      let vi = alphaConvertVarAndAddToEnv true vi in        (* Replace vi *)
      let se1 =
        if isvarsize then begin (* Variable-sized array *)
          ignore (warn "Variable-sized local variable %s" vi.vname);
          (* Make a local variable to keep the length *)
          let savelen =
            makeVarInfoFlx_cil_cabs
                        ~isformal:false
                        ~isglobal:false
                        loc
                        (TInt(IUInt, []), NoStorage, false, [])
                        ("__lengthof" ^ vi.vname,JUSTBASE, [])
          in
          (* Register it *)
          let savelen = alphaConvertVarAndAddToEnv true savelen in
          (* Compute the sizeof *)
          let sizeof =
            BinOp(Mult,
                  SizeOfE (Lval(Mem(Lval(var vi)), NoOffset)),
                  Lval (var savelen), !typeOfSizeOf) in
          (* Register the length *)
          H.add varSizeArrays vi.vid sizeof;
          (* There can be no initializer for this *)
          if e != A.NO_INIT then
            E.s (error "Variable-sized array cannot have initializer");
          se0 +++ (Set(var savelen, len, !currentLoc))
            (* Initialize the variable *)
            +++ (Call(Some(var vi), Lval(var allocaFun.svar),
                      [ sizeof  ], !currentLoc))
        end else empty
      in
      if e = A.NO_INIT then
        se1 (* skipChunk *)
      else begin
        let se4, ie', et = doInitializer vi e in
        (* Fix the length *)
        (match vi.vtype, ie', et with
            (* We have a length now *)
          TArray(_,None, _), _, TArray(_, Some _, _) -> vi.vtype <- et
            (* Initializing a local array *)
        | TArray(TInt((IChar|IUChar|ISChar), _) as bt, None, a),
             SingleInit(Const(CStr s)), _ ->
               vi.vtype <- TArray(bt,
                                  Some (integer (String.length s + 1)),
                                  a)
        | _, _, _ -> ());
        (* Now create assignments instead of the initialization *)
        se1 @@ se4 @@ (assignInit (Var vi, NoOffset) ie' et empty)
      end


(* Do one declaration *)
and doDecl (isglobal: bool) : A.definition -> chunk = function
  | A.DECDEF ((s, nl), loc) ->
      currentLoc := convLoc(loc);
      (* Do the specifiers exactly once *)
      let sugg =
        match nl with
          [] -> ""
        | ((n, _, _, _), _) :: _ -> n
      in
      let spec_res = doSpecList sugg s in
      (* Do all the variables and concatenate the resulting statements *)
      let doOneDeclarator (acc: chunk) (n: init_name) =
        if isglobal then begin
          (* For a global we ignore the varinfo that is created  *)
          ignore (createGlobal spec_res n);
          acc
        end else
          acc @@ createLocal spec_res n
      in
      List.fold_left doOneDeclarator empty nl

  | A.TYPEDEF (ng, loc) ->
     currentLoc := convLoc(loc);
     doTypedef ng; empty

  | A.ONLYTYPEDEF (s, loc) ->
      currentLoc := convLoc(loc);
      doOnlyTypedef s; empty

  | A.GLOBASM (s,loc) when isglobal ->
      currentLoc := convLoc(loc);
      cabsPushGlobal (GAsm (s, !currentLoc));
      empty

  | A.PRAGMA (a, loc) when isglobal -> begin
      currentLoc := convLoc(loc);
      match doAttr ("dummy", [a]) with
        [Attr("dummy", [a'])] ->
          let a'' =
            match a' with
            | ACons (s, args) -> Attr (s, args)
            | _ -> E.s (error "Unexpected attribute in #pragma")
          in
          cabsPushGlobal (GPragma (a'', !currentLoc));
          empty

      | _ -> E.s (error "Too many attributes in pragma")
  end
  | A.TRANSFORMER (_, _, _) -> E.s (E.bug "TRANSFORMER in cabs2cil input")
  | A.EXPRTRANSFORMER (_, _, _) ->
      E.s (E.bug "EXPRTRANSFORMER in cabs2cil input")

  (* If there are multiple definitions of extern inline, turn all but the
   * first into a prototype *)
  | A.FUNDEF (((specs,(n,dt,a,loc')) : A.single_name),
              (body : A.block), loc, _)
      when isglobal && isExtern specs && isInline specs
           && (H.mem genv (n ^ "__extinline")) ->
       currentLoc := convLoc(loc);
       ignore (warn "Duplicate extern inline definition for %s ignored"
                 n);
       (* Treat it as a prototype *)
       doDecl isglobal (A.DECDEF ((specs, [((n,dt,a,loc'), A.NO_INIT)]), loc))

  | A.FUNDEF (((specs,(n,dt,a, _)) : A.single_name),
              (body : A.block), loc1, loc2) when isglobal ->
    begin
      let funloc = convLoc loc1 in
      let endloc = convLoc loc2 in
(*      ignore (E.log "Definition of %s at %a\n" n d_loc funloc); *)
      currentLoc := funloc;
      E.withContext
        (fun _ -> dprintf "2cil: %s" n)
        (fun _ ->
          try
            (* Make the fundec right away, and we'll populate it later. We
             * need this throughout the code to create temporaries. *)
            currentFunctionFDEC :=
               { svar     = makeGlobalVar "@tempname@" voidType;
                 slocals  = []; (* For now we'll put here both the locals and
                                 * the formals. Then "endFunction" will
                                 * separate them *)
                 sformals = []; (* Not final yet *)
                 smaxid   = 0;
                 sbody    = dummyFunDec.sbody; (* Not final yet *)
                 smaxstmtid = None;
               };
            !currentFunctionFDEC.svar.vdecl <- funloc;

            constrExprId := 0;
            (* Setup the environment. Add the formals to the locals. Maybe
            * they need alpha-conv  *)
            enterScope ();  (* Start the scope *)

            H.clear varSizeArrays;

            (* Do not process transparent unions in function definitions.
            * We'll do it later *)
            transparentUnionArgs := [];

            (* Fix the NAME and the STORAGE *)
            let _ =
              let bt,sto,inl,attrs = doSpecList n specs in
              !currentFunctionFDEC.svar.vinline <- inl;

              let ftyp, funattr =
                doType (AttrName false) bt (A.PARENTYPE(attrs, dt, a)) in
              !currentFunctionFDEC.svar.vtype <- ftyp;
              !currentFunctionFDEC.svar.vattr <- funattr;

              (* If this is the definition of an extern inline then we change
               * its name, by adding the suffix __extinline. We also make it
               * static *)
              let n', sto' =
                let n' = n ^ "__extinline" in
                if inl && sto = Extern then
                  n', Static
                else begin
                  (* Maybe this is the body of a previous extern inline. Then
                  * we must take that one out of the environment because it
                  * is not used from here on. This will also ensure that
                  * then we make this functions' varinfo we will not think
                  * it is a duplicate definition *)
                  (try
                    ignore (lookupVar n'); (* n' is defined *)
                    let oldvi, _ = lookupVar n in
                    if oldvi.vname <> n' then
                      E.s (bug "extern inline redefinition: %s (expected %s)"
                             oldvi.vname n');
                    H.remove env n; H.remove genv n;
                    H.remove env n'; H.remove genv n'
                  with Not_found -> ());
                  n, sto
                end
              in
              (* Now we have the name and the storage *)
              !currentFunctionFDEC.svar.vname <- n';
              !currentFunctionFDEC.svar.vstorage <- sto'
            in

            (* Add the function itself to the environment. Add it before
            * you do the body because the function might be recursive. Add
            * it also before you add the formals to the environment
            * because there might be a formal with the same name as the
            * function and we want it to take precedence. *)
            (* Make a variable out of it and put it in the environment *)
            !currentFunctionFDEC.svar <-
               fst (makeGlobalVarinfo true !currentFunctionFDEC.svar);

            (* If it is extern inline then we add it to the global
             * environment for the original name as well. This will ensure
             * that all uses of this function will refer to the renamed
             * function *)
            addGlobalToEnv n (EnvVar !currentFunctionFDEC.svar);

            if H.mem alreadyDefined !currentFunctionFDEC.svar.vname then
              E.s (error "There is a definition already for %s" n);

(*
            ignore (E.log "makefunvar:%s@! type=%a@! vattr=%a@!"
                        n d_type thisFunctionVI.vtype
                        d_attrlist thisFunctionVI.vattr);
*)

            (* makeGlobalVarinfo might have changed the type of the function
             * (when combining it with the type of the prototype). So get the
             * type only now. *)

            (**** Process the TYPE and the FORMALS ***)
            let _ =
              let (returnType, formals_t, isvararg, funta) =
                splitFunctionTypeVI !currentFunctionFDEC.svar
              in
              (* Record the returnType for doStatement *)
              currentReturnType   := returnType;


              (* Create the formals and add them to the environment. *)
              (* sfg: extract locations for the formals from dt *)
              let doFormal (loc : location) (fn, ft, fa) =
                let f = makeVarinfo false fn ft in
                  (f.vdecl <- loc;
                   f.vattr <- fa;
                   alphaConvertVarAndAddToEnv true f)
              in
              let rec doFormals fl' ll' =
                begin
                  match (fl', ll') with
                    | [], _ -> []

                    | fl, [] -> (* no more locs available *)
                          List.map (doFormal !currentLoc) fl

                    | f::fl, (_,(_,_,_,l))::ll ->
                        (* sfg: these lets seem to be necessary to
                         *  force the right order of evaluation *)
                        let f' = doFormal (convLoc l) f in
                        let fl' = doFormals fl ll in
                          f' :: fl'
                end
              in
              let fmlocs = (match dt with PROTO(_, fml, _) -> fml | _ -> []) in
              let formals = doFormals (argsToList formals_t) fmlocs in

              (* Recreate the type based on the formals. *)
              let ftype = TFun(returnType,
                               Some (List.map (fun f -> (f.vname,
                                                         f.vtype,
                                                         f.vattr)) formals),
                               isvararg, funta) in
              (*
              ignore (E.log "Funtype of %s: %a\n" n' d_type ftype);
              *)
              (* Now fix the names of the formals in the type of the function
              * as well *)
              !currentFunctionFDEC.svar.vtype <- ftype;
              !currentFunctionFDEC.sformals <- formals;
            in
            (* Now change the type of transparent union args back to what it
             * was so that the body type checks. We must do it this late
             * because makeGlobalVarinfo from above might choke if we give
             * the function a type containing transparent unions  *)
            let _ =
              let rec fixbackFormals (idx: int) (args: varinfo list) : unit=
                match args with
                  [] -> ()
                | a :: args' ->
                    (* Fix the type back to a transparent union type *)
                    (try
                      let origtype = List.assq idx !transparentUnionArgs in
                      a.vtype <- origtype;
                    with Not_found -> ());
                    fixbackFormals (idx + 1) args'
              in
              fixbackFormals 0 !currentFunctionFDEC.sformals;
              transparentUnionArgs := [];
            in

            (********** Now do the BODY *************)
            let _ =
              let stmts = doBody body in
              (* Finish everything *)
              exitScope ();

              (* Now fill in the computed goto statement with cases. Do this
               * before mkFunctionbody which resolves the gotos *)
              (match !gotoTargetData with
                Some (switchv, switch) ->
                  let switche, l =
                    match switch.skind with
                      Switch (switche, _, _, l) -> switche, l
                    | _ -> E.s(bug "the computed goto statement not a switch")
                  in
                  (* Build a default chunk that segfaults *)
                  let default =
                    defaultChunk
                      l
                      (i2c (Set ((Mem (mkCast (integer 0) intPtrType),
                                  NoOffset),
                                 integer 0, l)))
                  in
                  let bodychunk = ref default in
                  H.iter (fun lname laddr ->
                    bodychunk :=
                       caseRangeChunk
                         [integer laddr] l
                         (gotoChunk lname l @@ !bodychunk))
                    gotoTargetHash;
                  (* Now recreate the switch *)
                  let newswitch = switchChunk switche !bodychunk l in
                  (* We must still share the old switch statement since we
                  * have already inserted the goto's *)
                  let newswitchkind =
                    match newswitch.stmts with
                      [ s]
                        when newswitch.postins = [] && newswitch.cases = []->
                          s.skind
                    | _ -> E.s (bug "Unexpected result from switchChunk")
                  in
                  switch.skind <- newswitchkind

              | None -> ());
              (* Now finish the body and store it *)
              !currentFunctionFDEC.sbody <- mkFunctionBody stmts;
              (* Reset the global parameters *)
              gotoTargetData := None;
              H.clear gotoTargetHash;
              gotoTargetNextAddr := 0;
            in



(*
              ignore (E.log "endFunction %s at %t:@! sformals=%a@!  slocals=%a@!"
              !currentFunctionFDEC.svar.vname d_thisloc
              (docList (chr ',') (fun v -> text v.vname))
              !currentFunctionFDEC.sformals
              (docList (chr ',') (fun v -> text v.vname))
              !currentFunctionFDEC.slocals);
*)

            let rec dropFormals formals locals =
              match formals, locals with
                [], l -> l
              | f :: formals, l :: locals ->
                  if f != l then
                    E.s (bug "formal %s is not in locals (found instead %s)"
                           f.vname l.vname);
                  dropFormals formals locals
              | _ -> E.s (bug "Too few locals")
            in
            !currentFunctionFDEC.slocals
              <- dropFormals !currentFunctionFDEC.sformals
                   (List.rev !currentFunctionFDEC.slocals);
            setMaxId !currentFunctionFDEC;

            (* Now go over the types of the formals and pull out the formals
             * with transparent union type. Replace them with some shadow
             * parameters and then add assignments  *)
            let _ =
              let newformals, newbody =
                List.fold_right (* So that the formals come out in order *)
                  (fun f (accform, accbody) ->
                    match isTransparentUnion f.vtype with
                      None -> (f :: accform, accbody)
                    | Some fstfield ->
                        (* A new shadow to be placed in the formals. Use
                         * makeTempVar to update smaxid and all others. *)
                        let shadow =
                          makeTempVar !currentFunctionFDEC fstfield.ftype in
                        (* Now take it out of the locals and replace it with
                        * the current formal. It is not worth optimizing this
                        * one  *)
                        !currentFunctionFDEC.slocals <-
                           f ::
                           (List.filter (fun x -> x.vid <> shadow.vid)
                              !currentFunctionFDEC.slocals);
                        (shadow :: accform,
                         mkStmt (Instr [Set ((Var f, Field(fstfield,
                                                           NoOffset)),
                                             Lval (var shadow),
                                             !currentLoc)]) :: accbody))
                  !currentFunctionFDEC.sformals
                  ([], !currentFunctionFDEC.sbody.bstmts)
              in
              !currentFunctionFDEC.sbody.bstmts <- newbody;
              (* To make sure sharing with the type is proper *)
              setFormals !currentFunctionFDEC newformals;
            in

            (* Now see whether we can fall through to the end of the function
             * *)
            (* weimer: Sat Dec 8 17:30:47 2001 MSVC NT kernel headers include
             * functions like long convert(x) { __asm { mov eax, x \n cdq } }
             * That set a return value via an ASM statement. As a result, I
             * am changing this so a final ASM statement does not count as
             * "fall through" for the purposes of this warning.  *)
            let instrFallsThrough (i : instr) = match i with
              Set _ -> true
            | Call (None, Lval (Var e, NoOffset), _, _) ->
                (* See if this is exit, or if it has the noreturn attribute *)
                if e.vname = "exit" then false
                else if hasAttribute "noreturn" e.vattr then false
                else true
            | Call _ -> true
            | Asm _ -> false
            in
            let rec stmtFallsThrough (s: stmt) : bool =
              match s.skind with
                Instr(il) ->
                  List.fold_left (fun acc elt ->
                                      acc && instrFallsThrough elt) true il
              | Return _ | Break _ | Continue _ -> false
              | Goto _ -> false
              | If (_, b1, b2, _) ->
                  blockFallsThrough b1 || blockFallsThrough b2
              | Switch (e, b, targets, _) ->
                   (* See if there is a "default" case *)
                   if not
                      (List.exists (fun s ->
                         List.exists (function Default _ -> true | _ -> false)
                                      s.labels)
                                   targets) then begin
(*
                      ignore (E.log "Switch falls through because no default");

*)                      true (* We fall through because there is no default *)
                   end else begin
                      (* We must examine all cases. If any falls through,
                       * then the switch falls through. *)
                      blockFallsThrough b
                   end
              | Loop _ -> true (* Conservative *)
              | Block b -> blockFallsThrough b
              | TryFinally (b, h, _) -> blockFallsThrough h
              | TryExcept (b, _, h, _) -> true (* Conservative *)
            and blockFallsThrough b =
              let rec fall = function
                  [] -> true
                | s :: rest ->
                    if stmtFallsThrough s then begin
(*
                        ignore (E.log "Stmt %a falls through\n" d_stmt s);
*)
                        fall rest
                    end else begin
(*
                        ignore (E.log "Stmt %a DOES NOT fall through\n"
                                      d_stmt s);
*)
                      (* If we are not falling thorough then maybe there
                      * are labels who are *)
                        labels rest
                    end
              and labels = function
                  [] -> false
                    (* We have a label, perhaps we can jump here *)
                  | s :: rest when s.labels <> [] ->
(*
                     ignore (E.log "invoking fall %a: %a\n"
                                      d_loc !currentLoc d_stmt s);
*)
                     fall (s :: rest)
                  | _ :: rest -> labels rest
              in
              let res = fall b.bstmts in
(*
              ignore (E.log "blockFallsThrough=%b %a\n" res d_block b);
*)
              res
            in
            if blockFallsThrough !currentFunctionFDEC.sbody then begin
              let retval =
                match unrollType !currentReturnType with
                  TVoid _ -> None
                | (TInt _ | TEnum _ | TFloat _ | TPtr _) as rt ->
                    ignore (warn "Body of function %s falls-through. Adding a return statement\n"  !currentFunctionFDEC.svar.vname);
                    Some (mkCastT zero intType rt)
                | _ ->
                    ignore (warn "Body of function %s falls-through and cannot find an appropriate return value\n" !currentFunctionFDEC.svar.vname);
                    None
              in
              !currentFunctionFDEC.sbody.bstmts <-
                 !currentFunctionFDEC.sbody.bstmts
                 @ [mkStmt (Return(retval, endloc))]
            end;

            (* ignore (E.log "The env after finishing the body of %s:\n%t\n"
                        n docEnv); *)
            cabsPushGlobal (GFun (!currentFunctionFDEC, funloc));
            empty
          with e -> begin
            ignore (E.log "error in collectFunction %s: %s\n"
                      n (Printexc.to_string e));
            cabsPushGlobal (GAsm("error in function " ^ n, !currentLoc));
            empty
          end)
        () (* argument of E.withContext *)
    end (* FUNDEF *)

  | LINKAGE (n, loc, dl) ->
      currentLoc := convLoc loc;
      if n <> "C" then
        ignore (warn "Encountered linkage specification \"%s\"" n);
      if not isglobal then
        E.s (error "Encountered linkage specification in local scope");
      (* For now drop the linkage on the floor !!! *)
      List.iter
        (fun d ->
          let s = doDecl isglobal d in
          if isNotEmpty s then
            E.s (bug "doDecl returns non-empty statement for global"))
        dl;
      empty

  | NAMESPACE (n, loc, dl) ->
      currentLoc := convLoc loc;
      List.iter
        (fun d ->
          let s = doDecl isglobal d in
          if isNotEmpty s then
            E.s (bug "doDecl returns non-empty statement for global"))
        dl;
      empty

  | _ -> E.s (error "unexpected form of declaration")

and doTypedef ((specs, nl): A.name_group) =
  try
    (* Do the specifiers exactly once *)
    let bt, sto, inl, attrs = doSpecList (suggestAnonName nl) specs in
    if sto <> NoStorage || inl then
      E.s (error "Storage or inline specifier not allowed in typedef");
    let createTypedef ((n,ndt,a,loc) : A.name) =
      (*    E.s (error "doTypeDef") *)
      try
        let newTyp, tattr =
          doType AttrType bt (A.PARENTYPE(attrs, ndt, a))  in
        let newTyp' = cabsTypeAddAttributes tattr newTyp in
        (* Create a new name for the type. Use the same name space as that of
        * variables to avoid confusion between variable names and types. This
        * is actually necessary in some cases.  *)
        let n', _  = newAlphaName true "" n in
        let ti = { tname = n'; ttype = newTyp'; treferenced = false } in
        (* Since we use the same name space, we might later hit a global with
         * the same name and we would want to change the name of the global.
         * It is better to change the name of the type instead. So, remember
         * all types whose names have changed *)
        H.add typedefs n' ti;
        let namedTyp = TNamed(ti, []) in
        (* Register the type. register it as local because we might be in a
        * local context  *)
        addLocalToEnv (kindPlusName "type" n) (EnvTyp (TNamed(ti, [])));
        cabsPushGlobal (GType (ti, !currentLoc))
      with e -> begin
        ignore (E.log "Error on A.TYPEDEF (%s)\n"
                  (Printexc.to_string e));
        cabsPushGlobal (GAsm ("booo_typedef:" ^ n, !currentLoc))
      end
    in
    List.iter createTypedef nl
  with e -> begin
    ignore (E.log "Error on A.TYPEDEF (%s)\n"
              (Printexc.to_string e));
    let fstname =
      match nl with
        [] -> "<missing name>"
      | (n, _, _, _) :: _ -> n
    in
    cabsPushGlobal (GAsm ("booo_typedef: " ^ fstname, !currentLoc))
  end

and doOnlyTypedef (specs: A.spec_elem list) : unit =
  try
    let bt, sto, inl, attrs = doSpecList "" specs in
    if sto <> NoStorage || inl then
      E.s (error "Storage or inline specifier not allowed in typedef");
    let restyp, nattr = doType AttrType bt (A.PARENTYPE(attrs,
                                                        A.JUSTBASE, [])) in
    if nattr <> [] then
      ignore (warn "Ignoring identifier attribute");
           (* doSpec will register the type. *)
    (* See if we are defining a composite or enumeration type, and in that
     * case move the attributes from the defined type into the composite type
     * *)
    let isadef =
      List.exists
        (function
            A.SpecType(A.Tstruct(_, Some _, _)) -> true
          | A.SpecType(A.Tunion(_, Some _, _)) -> true
          | A.SpecType(A.Tenum(_, Some _, _)) -> true
          | _ -> false) specs
    in
    match restyp with
      TComp(ci, al) ->
        if isadef then begin
          ci.cattr <- cabsAddAttributes ci.cattr al;
          (* The GCompTag was already added *)
        end else (* Add a GCompTagDecl *)
          cabsPushGlobal (GCompTagDecl(ci, !currentLoc))
    | TEnum(ei, al) ->
        if isadef then begin
          ei.eattr <- cabsAddAttributes ei.eattr al;
        end else
          cabsPushGlobal (GEnumTagDecl(ei, !currentLoc))
    | _ ->
        ignore (warn "Ignoring un-named typedef that does not introduce a struct or enumeration type\n")

  with e -> begin
    ignore (E.log "Error on A.ONLYTYPEDEF (%s)\n"
              (Printexc.to_string e));
    cabsPushGlobal (GAsm ("booo_typedef", !currentLoc))
  end

and assignInit (lv: lval)
               (ie: init)
               (iet: typ)
               (acc: chunk) : chunk =
  match ie with
    SingleInit e ->
      let (_, e'') = castTo iet (typeOfLval lv) e in
      acc +++ (Set(lv, e'', !currentLoc))
  | CompoundInit (t, initl) ->
      foldLeftCompound
        ~doinit:(fun off i it acc ->
          assignInit (addOffsetLval off lv) i it acc)
        ~ct:t
        ~initl:initl
        ~acc:acc
(*
  | ArrayInit (bt, len, initl) ->
      let idx = ref ( -1 ) in
      List.fold_left
        (fun acc i ->
          assignInit (addOffsetLval (Index(integer !idx, NoOffset)) lv) i bt acc)
        acc
        initl
*)
  (* Now define the processors for body and statement *)
and doBody (blk: A.block) : chunk =
  enterScope ();
  (* Rename the labels and add them to the environment *)
  List.iter (fun l -> ignore (genNewLocalLabel l)) blk.blabels;
  (* See if we have some attributes *)
  let battrs = doAttributes blk.A.battrs in

  let bodychunk =
    afterConversion
      (List.fold_left   (* !!! @ evaluates its arguments backwards *)
         (fun prev s -> let res = doStatement s in prev @@ res)
         empty
         blk.A.bstmts)
  in
  exitScope ();
  if battrs = [] then
    bodychunk
  else begin
    let b = c2block bodychunk in
    b.battrs <- battrs;
    s2c (mkStmt (Block b))
  end

and doStatement (s : A.statement) : chunk =
  try
    match s with
      A.NOP _ -> skipChunk
    | A.COMPUTATION (e, loc) ->
        currentLoc := convLoc loc;
        let (lasts, data) = !gnu_body_result in
        if lasts == s then begin      (* This is the last in a GNU_BODY *)
          let (s', e', t') = doExp false e (AExp None) in
          data := Some (e', t');      (* Record the result *)
          s'
        end else
          let (s', _, _) = doExp false e ADrop in
            (* drop the side-effect free expression *)
            (* And now do some peep-hole optimizations *)
          s'

    | A.BLOCK (b, loc) ->
        currentLoc := convLoc loc;
        doBody b

    | A.SEQUENCE (s1, s2, loc) ->
        (doStatement s1) @@ (doStatement s2)

    | A.IF(e,st,sf,loc) ->
        let st' = doStatement st in
        let sf' = doStatement sf in
        currentLoc := convLoc loc;
        doCondition false e st' sf'

    | A.WHILE(e,s,loc) ->
        startLoop true;
        let s' = doStatement s in
        exitLoop ();
        let loc' = convLoc loc in
        currentLoc := loc';
        loopChunk ((doCondition false e skipChunk
                      (breakChunk loc'))
                   @@ s')

    | A.DOWHILE(e,s,loc) ->
        startLoop false;
        let s' = doStatement s in
        let loc' = convLoc loc in
        currentLoc := loc';
        let s'' =
          consLabContinue (doCondition false e skipChunk (breakChunk loc'))
        in
        exitLoop ();
        loopChunk (s' @@ s'')

    | A.FOR(fc1,e2,e3,s,loc) -> begin
        let loc' = convLoc loc in
        currentLoc := loc';
        enterScope (); (* Just in case we have a declaration *)
        let (se1, _, _) =
          match fc1 with
            FC_EXP e1 -> doExp false e1 ADrop
          | FC_DECL d1 -> (doDecl false d1, zero, voidType)
        in
        let (se3, _, _) = doExp false e3 ADrop in
        startLoop false;
        let s' = doStatement s in
        currentLoc := loc';
        let s'' = consLabContinue se3 in
        exitLoop ();
        let res =
          match e2 with
            A.NOTHING -> (* This means true *)
              se1 @@ loopChunk (s' @@ s'')
          | _ ->
              se1 @@ loopChunk ((doCondition false e2 skipChunk (breakChunk loc'))
                                @@ s' @@ s'')
        in
        exitScope ();
        res
    end
    | A.BREAK loc ->
        let loc' = convLoc loc in
        currentLoc := loc';
        breakChunk loc'

    | A.CONTINUE loc ->
        let loc' = convLoc loc in
        currentLoc := loc';
        continueOrLabelChunk loc'

    | A.RETURN (A.NOTHING, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        (match !currentReturnType with
           TVoid _ -> ()
          | _ ->
            ignore (warn "Return statement without a value in function returning %a\n" d_type !currentReturnType));
        returnChunk None loc'

    | A.RETURN (e, loc) -> begin
        let loc' = convLoc loc in
        currentLoc := loc';
        (* Sometimes we return the result of a void function call *)
        match !currentReturnType with
          TVoid _ ->
            ignore (warn "Return statement with a value in function returning void");
            let (se, _, _) = doExp false e ADrop in
            se @@ returnChunk None loc'
        | _ ->
            let (se, e', et) =
              doExp false e (AExp (Some !currentReturnType)) in
            let (et'', e'') = castTo et (!currentReturnType) e' in
            se @@ (returnChunk (Some e'') loc')
    end

    | A.SWITCH (e, s, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        let (se, e', et) = doExp false e (AExp (Some intType)) in
        let (et'', e'') = castTo et intType e' in
        let s' = doStatement s in
        se @@ (switchChunk e'' s' loc')

    | A.CASE (e, s, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        let (se, e', et) = doExp false e (AExp None) in
        if isNotEmpty se then
          E.s (error "Case statement with a non-constant");
        caseRangeChunk [constFold false e'] loc' (doStatement s)

    | A.CASERANGE (el, eh, s, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        let (sel, el', etl) = doExp false el (AExp None) in
        let (seh, eh', etl) = doExp false eh (AExp None) in
        if isNotEmpty sel || isNotEmpty seh then
          E.s (error "Case statement with a non-constant");
        let il, ih =
          match constFold true el', constFold true eh' with
            Const(CInt64(il, _, _)), Const(CInt64(ih, _, _)) ->
              Int64.to_int il, Int64.to_int ih
          | _ -> E.s (unimp "Cannot understand the constants in case range")
        in
        if il > ih then
          E.s (error "Empty case range");
        let rec mkAll (i: int) =
          if i > ih then [] else integer i :: mkAll (i + 1)
        in
        caseRangeChunk (mkAll il) loc' (doStatement s)


    | A.DEFAULT (s, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        defaultChunk loc' (doStatement s)

    | A.LABEL (l, s, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        (* Lookup the label because it might have been locally defined *)
        consLabel (lookupLabel l) (doStatement s) loc' true

    | A.GOTO (l, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        (* Maybe we need to rename this label *)
        gotoChunk (lookupLabel l) loc'

    | A.COMPGOTO (e, loc) -> begin
        let loc' = convLoc loc in
        currentLoc := loc';
        (* Do the expression *)
        let se, e', t' = doExp false e (AExp (Some voidPtrType)) in
        match !gotoTargetData with
          Some (switchv, switch) -> (* We have already generated this one  *)
            se
            @@ i2c(Set (var switchv, mkCast e' uintType, loc'))
            @@ s2c(mkStmt(Goto (ref switch, loc')))

        | None -> begin
            (* Make a temporary variable *)
            let vchunk = createLocal
                (TInt(IUInt, []), NoStorage, false, [])
                (("__compgoto", A.JUSTBASE, [], loc), A.NO_INIT)
            in
            if not (isEmpty vchunk) then
              E.s (unimp "Non-empty chunk in creating temporary for goto *");
            let switchv, _ =
              try lookupVar "__compgoto"
              with Not_found -> E.s (bug "Cannot find temporary for goto *");
            in
            (* Make a switch statement. We'll fill in the statements at the
            * end of the function *)
            let switch = mkStmt (Switch (Lval(var switchv),
                                         mkBlock [], [], loc')) in
            (* And make a label for it since we'll goto it *)
            switch.labels <- [Label ("__docompgoto", loc', false)];
            gotoTargetData := Some (switchv, switch);
            se @@ i2c (Set(var switchv, mkCast e' uintType, loc')) @@
            s2c switch
        end
      end

    | A.DEFINITION d ->
        doDecl false d

    | A.ASM (asmattr, tmpls, outs, ins, clobs, loc) ->
        (* Make sure all the outs are variables *)
        let loc' = convLoc loc in
        let attr' = doAttributes asmattr in
        currentLoc := loc';
        let temps : (lval * varinfo) list ref = ref [] in
        let stmts : chunk ref = ref empty in
        let outs' =
          List.map
            (fun (c, e) ->
              let (se, e', t) = doExp false e (AExp None) in
              let lv =
                match e' with
                | Lval lval
                | StartOf lval -> lval
                | _ -> E.s (error "Expected lval for ASM outputs")
              in
              stmts := !stmts @@ se;
              (c, lv)) outs
        in
      (* Get the side-effects out of expressions *)
        let ins' =
          List.map
            (fun (c, e) ->
              let (se, e', et) = doExp false e (AExp None) in
              stmts := !stmts @@ se;
              (c, e'))
            ins
        in
        !stmts @@
        (i2c (Asm(attr', tmpls, outs', ins', clobs, loc')))

    | TRY_FINALLY (b, h, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        let b': chunk = doBody b in
        let h': chunk = doBody h in
        if b'.cases <> [] || h'.cases <> [] then
          E.s (error "Try statements cannot contain switch cases");

        s2c (mkStmt (TryFinally (c2block b', c2block h', loc')))

    | TRY_EXCEPT (b, e, h, loc) ->
        let loc' = convLoc loc in
        currentLoc := loc';
        let b': chunk = doBody b in
        (* Now do e *)
        let ((se: chunk), e', t') = doExp false e (AExp None) in
        let h': chunk = doBody h in
        if b'.cases <> [] || h'.cases <> [] || se.cases <> [] then
          E.s (error "Try statements cannot contain switch cases");
        (* Now take se and try to convert it to a list of instructions. This
         * might not be always possible *)
        let il' =
          match compactStmts se.stmts with
            [] -> se.postins
          | [ s ] -> begin
              match s.skind with
                Instr il -> il @ se.postins
              | _ -> E.s (error "Except expression contains unexpected statement")
            end
          | _ -> E.s (error "Except expression contains too many statements")
        in
        s2c (mkStmt (TryExcept (c2block b', (il', e'), c2block h', loc')))

  with e -> begin
    (ignore (E.log "Error in doStatement (%s)\n" (Printexc.to_string e)));
    consLabel "booo_statement" empty (convLoc (get_statementloc s)) false
  end


(* Translate a file *)
let convFile ((fname : string), (dl : Flx_cil_cabs.definition list)) : Flx_cil_cil.file =
  (* Clean up the global types *)
  E.hadErrors := false;
  initGlobals();
  startFile ();
  H.clear compInfoNameEnv;
  H.clear enumInfoNameEnv;
  H.clear mustTurnIntoDef;
  H.clear alreadyDefined;
  H.clear staticLocals;
  H.clear typedefs;
  H.clear isomorphicStructs;
  annonCompFieldNameId := 0;
  if !E.verboseFlag || !Flx_cil_cilutil.printStages then
    ignore (E.log "Converting CABS->CIL\n");
  (* Setup the built-ins, but do not add their prototypes to the file *)
  let setupBuiltin name (resTyp, argTypes, isva) =
    let v =
      makeGlobalVar name (TFun(resTyp,
                               Some (List.map (fun at -> ("", at, []))
                                       argTypes),
                               isva, [])) in
    ignore (alphaConvertVarAndAddToEnv true v)
  in
  H.iter setupBuiltin (if !msvcMode then msvcBuiltins else gccBuiltins);

  let globalidx = ref 0 in
  let doOneGlobal (d: A.definition) =
    let s = doDecl true d in
    if isNotEmpty s then
      E.s (bug "doDecl returns non-empty statement for global");
    (* See if this is one of the globals which we can leave alone. Increment
     * globalidx and see if we must leave this alone. *)
    if
      (match d with
        A.DECDEF _ -> true
      | A.FUNDEF _ -> true
      | _ -> false) && (incr globalidx; !globalidx = !nocil) then begin
          (* Create a file where we put the CABS output *)
          let temp_cabs_name = "__temp_cabs" in
          let temp_cabs = open_out temp_cabs_name in
          (* Now print the CABS in there *)
          Flx_cil_cprint.commit (); Flx_cil_cprint.flush ();
          let old = !Flx_cil_cprint.out in (* Save the old output channel *)
          Flx_cil_cprint.out := temp_cabs;
          Flx_cil_cprint.print_def d;
          Flx_cil_cprint.commit (); Flx_cil_cprint.flush ();
          flush !Flx_cil_cprint.out;
          Flx_cil_cprint.out := old;
          close_out temp_cabs;
          (* Now read everythign in *and create a GText from it *)
          let temp_cabs = open_in temp_cabs_name in
          let buff = Buffer.create 1024 in
          Buffer.add_string buff "// Start of CABS form\n";
          Buffer.add_channel buff temp_cabs (in_channel_length temp_cabs);
          Buffer.add_string buff "// End of CABS form\n";
          close_in temp_cabs;
          (* Try to pop the last thing in the file *)
          (match !theFile with
            _ :: rest -> theFile := rest
          | _ -> ());
          (* Insert in the file a GText *)
          cabsPushGlobal (GText(Buffer.contents buff))
    end
  in
  List.iter doOneGlobal dl;
  let globals = ref (popGlobals ()) in

  H.clear noProtoFunctions;
  H.clear mustTurnIntoDef;
  H.clear alreadyDefined;
  H.clear compInfoNameEnv;
  H.clear enumInfoNameEnv;
  H.clear isomorphicStructs;
  H.clear staticLocals;
  H.clear typedefs;
  H.clear env;
  H.clear genv;
  if false then ignore (E.log "Flx_cil_cabs2cil converted %d globals\n" !globalidx);
  (* We are done *)
  { fileName = fname;
    globals  = !globals;
    globinit = None;
    globinitcalled = false;
  }

@h=tangler('src/compiler/cil/flx_cil_cabs2cil.mli')
@select(h)
val convFile: Flx_cil_cabs.file -> Flx_cil_cil.file

(* Set this integer to the index of the global to be left in CABS form. Use
 * -1 to disable *)
val nocil: int ref

(* Indicates whether we're allowed to duplicate small chunks of code. *)
val allowDuplication: bool ref

@h=tangler('src/compiler/cil/flx_cil_patch.ml')
@select(h)


(* patch.ml *)
(* CABS file patching *)

open Flx_cil_cabs
open Flx_cil_cabs_helper
open Flx_cil_trace
open Flx_cil_pretty
open Flx_cil_cabsvisit

(* binding of a unification variable to a syntactic construct *)
type binding =
  | BSpecifier of string * spec_elem list
  | BName of string * string
  | BExpr of string * expression

(* thrown when unification fails *)
exception NoMatch

(* thrown when an attempt to find the associated binding fails *)
exception BadBind of string

(* trying to isolate performance problems; will hide all the *)
(* potentially expensive debugging output behind "if verbose .." *)
let verbose : bool = true


(* raise NoMatch if x and y are not equal *)
let mustEq (x : 'a) (y : 'a) : unit =
begin
  if (x <> y) then (
    if verbose then
      (trace "patchDebug" (dprintf "mismatch by structural disequality\n"));
    raise NoMatch
  )
end

(* why isn't this in the core Ocaml library? *)
let identity x = x


let isPatternVar (s : string) : bool =
begin
  ((String.length s) >= 1) && ((String.get s 0) = '@')
end

(* 's' is actually "@name(blah)"; extract the 'blah' *)
let extractPatternVar (s : string) : string =
  (*(trace "patch" (dprintf "extractPatternVar %s\n" s));*)
  (String.sub s 6 ((String.length s) - 7))


(* a few debugging printers.. *)
let printExpr (e : expression) =
begin
  if (verbose && traceActive "patchDebug") then (
    Flx_cil_cprint.print_expression e; Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.flush ()
  )
end

let printSpec (spec: spec_elem list) =
begin
  if (verbose && traceActive "patchDebug") then (
    Flx_cil_cprint.print_specifiers spec;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.flush ()
  )
end

let printSpecs (pat : spec_elem list) (tgt : spec_elem list) =
begin
  (printSpec pat);
  (printSpec tgt)
end

let printDecl (pat : name) (tgt : name) =
begin
  if (verbose && traceActive "patchDebug") then (
    Flx_cil_cprint.print_name pat;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.print_name tgt;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.flush ()
  )
end

let printDeclType (pat : decl_type) (tgt : decl_type) =
begin
  if (verbose && traceActive "patchDebug") then (
    Flx_cil_cprint.print_decl "__missing_field_name" pat;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.print_decl "__missing_field_name" tgt;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.flush ()
  )
end

let printDefn (d : definition) =
begin
  if (verbose && traceActive "patchDebug") then (
    Flx_cil_cprint.print_def d;
    Flx_cil_cprint.flush ()
  )
end


(* class to describe how to modify the tree for subtitution *)
class substitutor (bindings : binding list) = object(self)
  inherit nopFlx_cil_cabsVisitor as super

  (* look in the binding list for a given name *)
  method findBinding (name : string) : binding =
  begin
    try
      (List.find
        (fun b ->
          match b with
          | BSpecifier(n, _) -> n=name
          | BName(n, _) -> n=name
          | BExpr(n, _) -> n=name)
        bindings)
    with
      Not_found -> raise (BadBind ("name not found: " ^ name))
  end

  method vexpr (e:expression) : expression visitAction =
  begin
    match e with
    | EXPR_PATTERN(name) -> (
        match (self#findBinding name) with
        | BExpr(_, expr) -> ChangeTo(expr)    (* substitute bound expression *)
        | _ -> raise (BadBind ("wrong type: " ^ name))
      )
    | _ -> DoChildren
  end

  (* use of a name *)
  method vvar (s:string) : string =
  begin
    if (isPatternVar s) then (
      let nameString = (extractPatternVar s) in
      match (self#findBinding nameString) with
      | BName(_, str) -> str        (* substitute *)
      | _ -> raise (BadBind ("wrong type: " ^ nameString))
    )
    else
      s
  end

  (* binding introduction of a name *)
  method vname (k: nameKind) (spec: specifier) (n: name) : name visitAction =
  begin
    match n with (s (*variable name*), dtype, attrs, loc) -> (
      let replacement = (self#vvar s) in    (* use replacer from above *)
      if (s <> replacement) then
        ChangeTo(replacement, dtype, attrs, loc)
      else
        DoChildren                          (* no replacement *)
    )
  end

  method vspec (specList: specifier) : specifier visitAction =
  begin
    if verbose then (trace "patchDebug" (dprintf "substitutor: vspec\n"));
    (printSpec specList);

    (* are any of the specifiers SpecPatterns?  we have to check the entire *)
    (* list, not just the head, because e.g. "typedef @specifier(foo)" has *)
    (* "typedef" as the head of the specifier list *)
    if (List.exists (fun elt -> match elt with
                                | SpecPattern(_) -> true
                                | _ -> false)
                    specList) then begin
      (* yes, replace the existing list with one got by *)
      (* replacing all occurrences of SpecPatterns *)
      (trace "patchDebug" (dprintf "at least one spec pattern\n"));
      ChangeTo
        (List.flatten
          (List.map
            (* for each specifier element, yield the specifier list *)
            (* to which it maps; then we'll flatten the final result *)
            (fun elt ->
              match elt with
              | SpecPattern(name) -> (
                  match (self#findBinding name) with
                  | BSpecifier(_, replacement) -> (
                      (trace "patchDebug" (dprintf "replacing pattern %s\n" name));
                      replacement
                    )
                  | _ -> raise (BadBind ("wrong type: " ^ name))
                )
              | _ -> [elt]    (* leave this one alone *)
            )
            specList
          )
        )
    end
    else
      (* none of the specifiers in specList are patterns *)
      DoChildren
  end

  method vtypespec (tspec: typeSpecifier) : typeSpecifier visitAction =
  begin
    match tspec with
    | Tnamed(str) when (isPatternVar str) ->
        ChangeTo(Tnamed(self#vvar str))
    | Tstruct(str, fields, extraAttrs) when (isPatternVar str) -> (
        (trace "patchDebug" (dprintf "substituting %s\n" str));
        ChangeDoChildrenPost(Tstruct((self#vvar str), fields, extraAttrs), identity)
      )
    | Tunion(str, fields, extraAttrs) when (isPatternVar str) ->
        (trace "patchDebug" (dprintf "substituting %s\n" str));
        ChangeDoChildrenPost(Tunion((self#vvar str), fields, extraAttrs), identity)
    | _ -> DoChildren
  end

end


(* why can't I have forward declarations in the language?!! *)
let unifyExprFwd : (expression -> expression -> binding list) ref
  = ref (fun e e -> [])


(* substitution for expressions *)
let substExpr (bindings : binding list) (expr : expression) : expression =
begin
  if verbose then
    (trace "patchDebug" (dprintf "substExpr with %d bindings\n" (List.length bindings)));
  (printExpr expr);

  (* apply the transformation *)
  let result = (visit_cabsExpression (new substitutor bindings :> cabsVisitor) expr) in
  (printExpr result);

  result
end

let d_loc (_:unit) (loc: cabsloc) : doc =
  text loc.filename ++ chr ':' ++ num loc.lineno


(* class to describe how to modify the tree when looking for places *)
(* to apply expression transformers *)
class exprTransformer (srcpattern : expression) (destpattern : expression)
                      (patchline : int) (srcloc : cabsloc) = object(self)
  inherit nopFlx_cil_cabsVisitor as super

  method vexpr (e:expression) : expression visitAction =
  begin
    (* see if the source pattern matches this subexpression *)
    try (
      let bindings = (!unifyExprFwd srcpattern e) in

      (* match! *)
      (trace "patch" (dprintf "expr match: patch line %d, src %a\n"
                              patchline d_loc srcloc));
      ChangeTo(substExpr bindings destpattern)
    )

    with NoMatch -> (
      (* doesn't apply *)
      DoChildren
    )
  end

  (* other constructs left unchanged *)
end


let unifyList (pat : 'a list) (tgt : 'a list)
              (unifyElement : 'a -> 'a -> binding list) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifyList (pat len %d, tgt len %d)\n"
                                 (List.length pat) (List.length tgt)));

  (* walk down the lists *)
  let rec loop pat tgt : binding list =
    match pat, tgt with
    | [], [] -> []
    | (pelt :: prest), (telt :: trest) ->
         (unifyElement pelt telt) @
         (loop prest trest)
    | _,_ -> (
        (* no match *)
        if verbose then (
          (trace "patchDebug" (dprintf "mismatching list length\n"));
        );
        raise NoMatch
     )
  in
  (loop pat tgt)
end


let gettime () : float =
  (Unix.times ()).Unix.tms_utime

let rec applyFlx_cil_patch (patchFile : file) (srcFile : file) : file =
begin
  let patch : definition list = (snd patchFile) in
  let srcFname : string = (fst srcFile) in
  let src : definition list = (snd srcFile) in

  (trace "patchTime" (dprintf "applyFlx_cil_patch start: %f\n" (gettime ())));
  if (traceActive "patchDebug") then
    Flx_cil_cprint.out := stdout      (* hack *)
  else ();

  (* more hackery *)
  unifyExprFwd := unifyExpr;

  (* patch a single source definition, yield transformed *)
  let rec patchDefn (patch : definition list) (d : definition) : definition list =
  begin
    match patch with
    | TRANSFORMER(srcpattern, destpattern, loc) :: rest -> (
        if verbose then
          (trace "patchDebug"
            (dprintf "considering applying defn pattern at line %d to src at %a\n"
                     loc.lineno d_loc (get_definitionloc d)));

        (* see if the source pattern matches the definition 'd' we have *)
        try (
          let bindings = (unifyDefn srcpattern d) in

          (* we have a match!  apply the substitutions *)
          (trace "patch" (dprintf "defn match: patch line %d, src %a\n"
                                  loc.lineno d_loc (get_definitionloc d)));

          (List.map (fun destElt -> (substDefn bindings destElt)) destpattern)
        )

        with NoMatch -> (
          (* no match, continue down list *)
          (*(trace "patch" (dprintf "no match\n"));*)
          (patchDefn rest d)
        )
      )

    | EXPRTRANSFORMER(srcpattern, destpattern, loc) :: rest -> (
        if verbose then
          (trace "patchDebug"
            (dprintf "considering applying expr pattern at line %d to src at %a\n"
                     loc.lineno d_loc (get_definitionloc d)));

        (* walk around in 'd' looking for expressions to modify *)
        let dList = (visit_cabsDefinition
                      ((new exprTransformer srcpattern destpattern
                                            loc.lineno (get_definitionloc d))
                       :> cabsVisitor)
                      d
                    ) in

        (* recursively invoke myself to try additional patches *)
        (* since visit_cabsDefinition might return a list, I'll try my *)
        (* addtional patches on every yielded definition, then collapse *)
        (* all of them into a single list *)
        (List.flatten (List.map (fun d -> (patchDefn rest d)) dList))
      )

    | _ :: rest -> (
        (* not a transformer; just keep going *)
        (patchDefn rest d)
      )
    | [] -> (
        (* reached the end of the patch file with no match *)
        [d]     (* have to wrap it in a list ... *)
      )
  end in

  (* transform all the definitions *)
  let result : definition list =
    (List.flatten (List.map (fun d -> (patchDefn patch d)) src)) in

  (*Flx_cil_cprint.print_defs result;*)

  if (traceActive "patchDebug") then (
    (* avoid flush bug? yes *)
    Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.flush ()
  );

  (trace "patchTime" (dprintf "applyFlx_cil_patch finish: %f\n" (gettime ())));
  (srcFname, result)
end


(* given a definition pattern 'pat', and a target concrete defintion 'tgt', *)
(* determine if they can be unified; if so, return the list of bindings of *)
(* unification variables in pat; otherwise raise NoMatch *)
and unifyDefn (pat : definition) (tgt : definition) : binding list =
begin
  match pat, tgt with
  | DECDEF((pspecifiers, pdeclarators), _),
    DECDEF((tspecifiers, tdeclarators), _) -> (
      if verbose then
        (trace "patchDebug" (dprintf "unifyDefn of DECDEFs\n"));
      (unifySpecifiers pspecifiers tspecifiers) @
      (unifyInitDeclarators pdeclarators tdeclarators)
    )

  | TYPEDEF((pspec, pdecl), _),
    TYPEDEF((tspec, tdecl), _) -> (
      if verbose then
        (trace "patchDebug" (dprintf "unifyDefn of TYPEDEFs\n"));
      (unifySpecifiers pspec tspec) @
      (unifyDeclarators pdecl tdecl)
    )

  | ONLYTYPEDEF(pspec, _),
    ONLYTYPEDEF(tspec, _) -> (
      if verbose then
        (trace "patchDebug" (dprintf "unifyDefn of ONLYTYPEDEFs\n"));
      (unifySpecifiers pspec tspec)
    )

  | _, _ -> (
      if verbose then
        (trace "patchDebug" (dprintf "mismatching definitions\n"));
      raise NoMatch
    )
end

and unifySpecifier (pat : spec_elem) (tgt : spec_elem) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifySpecifier\n"));
  (printSpecs [pat] [tgt]);

  if (pat = tgt) then [] else

  match pat, tgt with
  | SpecType(tspec1), SpecType(tspec2) ->
      (unifyTypeSpecifier tspec1 tspec2)
  | SpecPattern(name), _ ->
      (* record that future occurrances of @specifier(name) will yield this specifier *)
      if verbose then
        (trace "patchDebug" (dprintf "found specifier match for %s\n" name));
      [BSpecifier(name, [tgt])]
  | _,_ -> (
      (* no match *)
      if verbose then (
        (trace "patchDebug" (dprintf "mismatching specifiers\n"));
      );
      raise NoMatch
   )
end

and unifySpecifiers (pat : spec_elem list) (tgt : spec_elem list) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifySpecifiers\n"));
  (printSpecs pat tgt);

  (* canonicalize the specifiers by sorting them *)
  let pat' = (List.stable_sort compare pat) in
  let tgt' = (List.stable_sort compare tgt) in

  (* if they are equal, they match with no further checking *)
  if (pat' = tgt') then [] else

  (* walk down the lists; don't walk the sorted lists because the *)
  (* pattern must always be last, if it occurs *)
  let rec loop pat tgt : binding list =
    match pat, tgt with
    | [], [] -> []
    | [SpecPattern(name)], _ ->
        (* final SpecPattern matches anything which comes after *)
        (* record that future occurrences of @specifier(name) will yield this specifier *)
        if verbose then
          (trace "patchDebug" (dprintf "found specifier match for %s\n" name));
        [BSpecifier(name, tgt)]
    | (pspec :: prest), (tspec :: trest) ->
         (unifySpecifier pspec tspec) @
         (loop prest trest)
    | _,_ -> (
        (* no match *)
        if verbose then (
          (trace "patchDebug" (dprintf "mismatching specifier list length\n"));
        );
        raise NoMatch
     )
  in
  (loop pat tgt)
end

and unifyTypeSpecifier (pat: typeSpecifier) (tgt: typeSpecifier) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifyTypeSpecifier\n"));

  if (pat = tgt) then [] else

  match pat, tgt with
  | Tnamed(s1), Tnamed(s2) -> (unifyString s1 s2)
  | Tstruct(name1, None, _), Tstruct(name2, None, _) ->
      (unifyString name1 name2)
  | Tstruct(name1, Some(fields1), _), Tstruct(name2, Some(fields2), _) ->
      (* ignoring extraAttrs b/c we're just trying to come up with a list
       * of substitutions, and there's no unify_attributes function, and
       * I don't care at this time about checking that they are equal .. *)
      (unifyString name1 name2) @
      (unifyList fields1 fields2 unifyField)
  | Tunion(name1, None, _), Tstruct(name2, None, _) ->
      (unifyString name1 name2)
  | Tunion(name1, Some(fields1), _), Tunion(name2, Some(fields2), _) ->
      (unifyString name1 name2) @
      (unifyList fields1 fields2 unifyField)
  | Tenum(name1, None, _), Tenum(name2, None, _) ->
      (unifyString name1 name2)
  | Tenum(name1, Some(items1), _), Tenum(name2, Some(items2), _) ->
      (mustEq items1 items2);    (* enum items *)
      (unifyString name1 name2)
  | TtypeofE(exp1), TtypeofE(exp2) ->
      (unifyExpr exp1 exp2)
  | TtypeofT(spec1, dtype1), TtypeofT(spec2, dtype2) ->
      (unifySpecifiers spec1 spec2) @
      (unifyDeclType dtype1 dtype2)
  | _ -> (
      if verbose then (trace "patchDebug" (dprintf "mismatching typeSpecifiers\n"));
      raise NoMatch
    )
end

and unifyField (pat : field_group) (tgt : field_group) : binding list =
begin
  match pat,tgt with (spec1, list1), (spec2, list2) -> (
    (unifySpecifiers spec1 spec2) @
    (unifyList list1 list2 unifyNameExprOpt)
  )
end

and unifyNameExprOpt (pat : name * expression option)
                     (tgt : name * expression option) : binding list =
begin
  match pat,tgt with
  | (name1, None), (name2, None) -> (unifyName name1 name2)
  | (name1, Some(exp1)), (name2, Some(exp2)) ->
      (unifyName name1 name2) @
      (unifyExpr exp1 exp2)
  | _,_ -> []
end

and unifyName (pat : name) (tgt : name) : binding list =
begin
  match pat,tgt with (pstr, pdtype, pattrs, ploc), (tstr, tdtype, tattrs, tloc) ->
    (mustEq pattrs tattrs);
    (unifyString pstr tstr) @
    (unifyDeclType pdtype tdtype)
end

and unifyInitDeclarators (pat : init_name list) (tgt : init_name list) : binding list =
begin
  (*
    if verbose then
      (trace "patchDebug" (dprintf "unifyInitDeclarators, pat %d, tgt %d\n"
                                   (List.length pat) (List.length tgt)));
  *)

  match pat, tgt with
  | ((pdecl, piexpr) :: prest),
    ((tdecl, tiexpr) :: trest) ->
      (unifyDeclarator pdecl tdecl) @
      (unifyInitExpr piexpr tiexpr) @
      (unifyInitDeclarators prest trest)
  | [], [] -> []
  | _, _ -> (
      if verbose then
        (trace "patchDebug" (dprintf "mismatching init declarators\n"));
      raise NoMatch
    )
end

and unifyDeclarators (pat : name list) (tgt : name list) : binding list =
  (unifyList pat tgt unifyDeclarator)

and unifyDeclarator (pat : name) (tgt : name) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifyDeclarator\n"));
  (printDecl pat tgt);

  match pat, tgt with
  | (pname, pdtype, pattr, ploc),
    (tname, tdtype, tattr, tloc) ->
      (mustEq pattr tattr);
      (unifyDeclType pdtype tdtype) @
      (unifyString pname tname)
end

and unifyDeclType (pat : decl_type) (tgt : decl_type) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifyDeclType\n"));
  (printDeclType pat tgt);

  match pat, tgt with
  | JUSTBASE, JUSTBASE -> []
  | PARENTYPE(pattr1, ptype, pattr2),
    PARENTYPE(tattr1, ttype, tattr2) ->
      (mustEq pattr1 tattr1);
      (mustEq pattr2 tattr2);
      (unifyDeclType ptype ttype)
  | ARRAY(ptype, pattr, psz),
    ARRAY(ttype, tattr, tsz) ->
      (mustEq pattr tattr);
      (unifyDeclType ptype ttype) @
      (unifyExpr psz tsz)
  | PTR(pattr, ptype),
    PTR(tattr, ttype) ->
      (mustEq pattr tattr);
      (unifyDeclType ptype ttype)
  | PROTO(ptype, pformals, pva),
    PROTO(ttype, tformals, tva) ->
      (mustEq pva tva);
      (unifyDeclType ptype ttype) @
      (unifySingleNames pformals tformals)
  | _ -> (
      if verbose then
        (trace "patchDebug" (dprintf "mismatching decl_types\n"));
      raise NoMatch
    )
end

and unifySingleNames (pat : single_name list) (tgt : single_name list) : binding list =
begin
  if verbose then
    (trace "patchDebug" (dprintf "unifySingleNames, pat %d, tgt %d\n"
                                 (List.length pat) (List.length tgt)));

  match pat, tgt with
  | [], [] -> []
  | (pspec, pdecl) :: prest,
    (tspec, tdecl) :: trest ->
      (unifySpecifiers pspec tspec) @
      (unifyDeclarator pdecl tdecl) @
      (unifySingleNames prest trest)
  | _, _ -> (
      if verbose then
        (trace "patchDebug" (dprintf "mismatching single_name lists\n"));
      raise NoMatch
    )
end

and unifyString (pat : string) (tgt : string) : binding list =
begin
  (* equal? match with no further ado *)
  if (pat = tgt) then [] else

  (* is the pattern a variable? *)
  if (isPatternVar pat) then
    (* pat is actually "@name(blah)"; extract the 'blah' *)
    let varname = (extractPatternVar pat) in

    (* when substituted, this name becomes 'tgt' *)
    if verbose then
      (trace "patchDebug" (dprintf "found name match for %s\n" varname));
    [BName(varname, tgt)]

  else (
    if verbose then
      (trace "patchDebug" (dprintf "mismatching names: %s and %s\n" pat tgt));
    raise NoMatch
  )
end

and unifyExpr (pat : expression) (tgt : expression) : binding list =
begin
  (* if they're equal, that's good enough *)
  if (pat = tgt) then [] else

  (* shorter name *)
  let ue = unifyExpr in

  (* because of the equality check above, I can omit some cases *)
  match pat, tgt with
  | UNARY(pop, pexpr),
    UNARY(top, texpr) ->
      (mustEq pop top);
      (ue pexpr texpr)
  | BINARY(pop, pexp1, pexp2),
    BINARY(top, texp1, texp2) ->
      (mustEq pop top);
      (ue pexp1 texp1) @
      (ue pexp2 texp2)
  | QUESTION(p1, p2, p3),
    QUESTION(t1, t2, t3) ->
      (ue p1 t1) @
      (ue p2 t2) @
      (ue p3 t3)
  | CAST((pspec, ptype), piexpr),
    CAST((tspec, ttype), tiexpr) ->
      (mustEq ptype ttype);
      (unifySpecifiers pspec tspec) @
      (unifyInitExpr piexpr tiexpr)
  | CALL(pfunc, pargs),
    CALL(tfunc, targs) ->
      (ue pfunc tfunc) @
      (unifyExprs pargs targs)
  | COMMA(pexprs),
    COMMA(texprs) ->
      (unifyExprs pexprs texprs)
  | EXPR_SIZEOF(pexpr),
    EXPR_SIZEOF(texpr) ->
      (ue pexpr texpr)
  | TYPE_SIZEOF(pspec, ptype),
    TYPE_SIZEOF(tspec, ttype) ->
      (mustEq ptype ttype);
      (unifySpecifiers pspec tspec)
  | EXPR_ALIGNOF(pexpr),
    EXPR_ALIGNOF(texpr) ->
      (ue pexpr texpr)
  | TYPE_ALIGNOF(pspec, ptype),
    TYPE_ALIGNOF(tspec, ttype) ->
      (mustEq ptype ttype);
      (unifySpecifiers pspec tspec)
  | INDEX(parr, pindex),
    INDEX(tarr, tindex) ->
      (ue parr tarr) @
      (ue pindex tindex)
  | MEMBEROF(pexpr, pfield),
    MEMBEROF(texpr, tfield) ->
      (mustEq pfield tfield);
      (ue pexpr texpr)
  | MEMBEROFPTR(pexpr, pfield),
    MEMBEROFPTR(texpr, tfield) ->
      (mustEq pfield tfield);
      (ue pexpr texpr)
  | GNU_BODY(pblock),
    GNU_BODY(tblock) ->
      (mustEq pblock tblock);
      []
  | EXPR_PATTERN(name), _ ->
      (* match, and contribute binding *)
      if verbose then
        (trace "patchDebug" (dprintf "found expr match for %s\n" name));
      [BExpr(name, tgt)]
  | a, b ->
      if (verbose && traceActive "patchDebug") then (
        (trace "patchDebug" (dprintf "mismatching expression\n"));
        (printExpr a);
        (printExpr b)
      );
      raise NoMatch
end

and unifyInitExpr (pat : init_expression) (tgt : init_expression) : binding list =
begin
  (*
    Flx_cil_cprint.print_init_expression pat;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.print_init_expression tgt;  Flx_cil_cprint.force_new_line ();
    Flx_cil_cprint.flush ();
  *)

  match pat, tgt with
  | NO_INIT, NO_INIT -> []
  | SINGLE_INIT(pe), SINGLE_INIT(te) ->
      (unifyExpr pe te)
  | COMPOUND_INIT(plist),
    COMPOUND_INIT(tlist) -> (
      let rec loop plist tlist =
        match plist, tlist with
        | ((pwhat, piexpr) :: prest),
          ((twhat, tiexpr) :: trest) ->
            (mustEq pwhat twhat);
            (unifyInitExpr piexpr tiexpr) @
            (loop prest trest)
        | [], [] -> []
        | _, _ -> (
            if verbose then
              (trace "patchDebug" (dprintf "mismatching compound init exprs\n"));
            raise NoMatch
          )
      in
      (loop plist tlist)
    )
  | _,_ -> (
      if verbose then
        (trace "patchDebug" (dprintf "mismatching init exprs\n"));
      raise NoMatch
    )
end

and unifyExprs (pat : expression list) (tgt : expression list) : binding list =
  (unifyList pat tgt unifyExpr)


(* given the list of bindings 'b', substitute them into 'd' to yield a new definition *)
and substDefn (bindings : binding list) (defn : definition) : definition =
begin
  if verbose then
    (trace "patchDebug" (dprintf "substDefn with %d bindings\n" (List.length bindings)));
  (printDefn defn);

  (* apply the transformation *)
  match (visit_cabsDefinition (new substitutor bindings :> cabsVisitor) defn) with
  | [d] -> d    (* expect a singleton list *)
  | _ -> (failwith "didn't get a singleton list where I expected one")
end


(* end of file *)
@h=tangler('src/compiler/cil/flx_cil_patch.mli')
@select(h)


(* patch.mli *)
(* interface for patch.ml *)

val applyFlx_cil_patch : Flx_cil_cabs.file -> Flx_cil_cabs.file -> Flx_cil_cabs.file
@h=tangler('src/compiler/cil/flx_cil_errormsg.ml')
@select(h)

open Flx_cil_pretty



let debugFlag  = ref false              (* If set then print debugging info *)
let verboseFlag = ref false

(**** Error reporting ****)
(* JS: added this *)
exception Flx_cil_parse_error of string * int * int * int

exception Error
let s (d : doc) = raise Error

let hadErrors = ref false

let errorContext = ref []
let pushContext f = errorContext := f :: (!errorContext)
let popContext () =
  match !errorContext with
    _ :: t -> errorContext := t
  | [] -> s (eprintf "Bug: cannot pop error context")


let withContext ctx f x =
  pushContext ctx;
  try
    let res = f x in
    popContext ();
    res
  with e -> begin
    popContext ();
    raise e
  end

                                        (* Make sure that showContext calls
                                         * each f with its appropriate
                                         * errorContext as it was when it was
                                         * pushed *)
let showContext () =
  let rec loop = function
      [] -> ()
    | f :: rest -> (errorContext := rest; (* Just in case f raises an error *)
                    ignore (eprintf "  Context : %t@!" f);
                    loop rest)
  in
  let old = !errorContext in
  try
    loop old;
    errorContext := old
  with e -> begin
    errorContext := old;
    raise e
  end

let contextMessage name d =
  ignore (eprintf "@!%s: %a@!" name insert d);
  showContext ()

let warnFlag = ref false

let logChannel : out_channel ref = ref stderr


let bug (fmt : ('a,unit,doc) format) : 'a =
  let f d =
    hadErrors := true; contextMessage "Bug" d;
    flush !logChannel;
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let error (fmt : ('a,unit,doc) format) : 'a =
  let f d = hadErrors := true; contextMessage "Error" d;
    flush !logChannel;
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let unimp (fmt : ('a,unit,doc) format) : 'a =
  let f d = hadErrors := true; contextMessage "Unimplemented" d;
    flush !logChannel;
    nil
  in
  Flx_cil_pretty.gprintf f fmt

let warn (fmt : ('a,unit,doc) format) : 'a =
  let f d = contextMessage "Warning" d; flush !logChannel; nil in
  Flx_cil_pretty.gprintf f fmt

let warnOpt (fmt : ('a,unit,doc) format) : 'a =
    let f d =
      if !warnFlag then contextMessage "Warning" d; flush !logChannel;
      nil in
    Flx_cil_pretty.gprintf f fmt


let log (fmt : ('a,unit,doc) format) : 'a =
  let f d = fprint !logChannel 80 d; flush !logChannel; d in
  Flx_cil_pretty.gprintf f fmt

let null (fmt : ('a,unit,doc) format) : 'a =
  let f d = Flx_cil_pretty.nil in
  Flx_cil_pretty.gprintf f fmt

let check (what: bool) (fmt : ('a,unit,doc) format) : 'a =
  if what then
     what
  else begin
    let f d =
      if not what then begin
         hadErrors := true; contextMessage "Assert" d;
         flush !logChannel; raise Error
    end else nil in
    Flx_cil_pretty.gprintf f fmt
  end

let theLexbuf = ref (Lexing.from_string "")

let fail format = Flx_cil_pretty.gprintf (fun x -> Flx_cil_pretty.fprint stderr 80 x;
                                           raise (Failure "")) format



(***** Handling parsing errors ********)
type parseinfo =
    { mutable  linenum: int      ; (* Current line *)
      mutable  linestart: int    ; (* The position in the buffer where the
                                    * current line starts *)
      mutable fileName : string   ; (* Current file *)
      mutable hfile   : string   ; (* High-level file *)
      mutable hline   : int;       (* High-level line *)
      lexbuf          : Lexing.lexbuf;
      inchan          : in_channel option; (* None, if from a string *)
      mutable   num_errors : int;  (* Errors so far *)
    }

let dummyinfo =
    { linenum   = 1;
      linestart = 0;
      fileName  = "" ;
      lexbuf    = Lexing.from_string "";
      inchan    = None;
      hfile     = "";
      hline     = 0;
      num_errors = 0;
    }

let current = ref dummyinfo

let setHLine (l: int) : unit =
    !current.hline <- l
let setHFile (f: string) : unit =
    !current.hfile <- f

let rem_quotes str = String.sub str 1 ((String.length str) - 2)

(* Change \ into / in file names. To avoid complications with escapes *)
let cleanFileName str =
  let str1 =
    if str <> "" && String.get str 0 = '"' (* '"' ( *)
    then rem_quotes str else str in
  let l = String.length str1 in
  let rec loop (copyto: int) (i: int) =
    if i >= l then
      String.sub str1 0 copyto
     else
       let c = String.get str1 i in
       if c <> '\\' then begin
          String.set str1 copyto c; loop (copyto + 1) (i + 1)
       end else begin
          String.set str1 copyto '/';
          if i < l - 2 && String.get str1 (i + 1) = '\\' then
              loop (copyto + 1) (i + 2)
          else
              loop (copyto + 1) (i + 1)
       end
  in
  loop 0 0

let startParsing (fname: string) =
  let inchan =
    try open_in fname with
      _ -> s (error "Cannot find input file %s" fname) in
  let lexbuf = Lexing.from_channel inchan in
  let i =
    { linenum = 1; linestart = 0;
      fileName = cleanFileName (Filename.basename fname);
      lexbuf = lexbuf; inchan = Some inchan;
      hfile = ""; hline = 0;
      num_errors = 0 } in
  current := i;
  lexbuf

let startParsingFromString ?(file="<string>") ?(line=1) (str: string) =
  let lexbuf = Lexing.from_string str in
  let i =
    { linenum = line; linestart = line - 1;
      fileName = file;
      hfile = ""; hline = 0;
      lexbuf = lexbuf;
      inchan = None;
      num_errors = 0 }
  in
  current := i;
  lexbuf

let finishParsing () =
  let i = !current in
  (match i.inchan with Some c -> close_in c | _ -> ());
  current := dummyinfo


(* Call this function to announce a new line *)
let newline () =
  let i = !current in
  i.linenum <- 1 + i.linenum;
  i.linestart <- Lexing.lexeme_start i.lexbuf

let newHline () =
  let i = !current in
  i.hline <- 1 + i.hline

let setCurrentLine (i: int) =
  !current.linenum <- i

let setCurrentFile (n: string) =
  !current.fileName <- cleanFileName n


let max_errors = 20  (* Stop after 20 errors *)

let parse_error (msg: string) : 'a =
  (* Sometimes the Ocaml parser raises errors in symbol_start and symbol_end *)
  let token_start, token_end =
    try Parsing.symbol_start (), Parsing.symbol_end ()
    with e -> begin
      ignore (warn "Parsing raised %s\n" (Printexc.to_string e));
      0, 0
    end
  in
  let i = !current in
  let adjStart =
    if token_start < i.linestart then 0 else token_start - i.linestart in
  let adjEnd =
    if token_end < i.linestart then 0 else token_end - i.linestart in
  output_string
    stderr
    (i.fileName ^ "[" ^ (string_of_int i.linenum) ^ ":"
                        ^ (string_of_int adjStart) ^ "-"
                        ^ (string_of_int adjEnd)
                  ^ "]"
     ^ " : " ^ msg);
  output_string stderr "\n";
  flush stderr ;
  i.num_errors <- i.num_errors + 1;
  if i.num_errors > max_errors then begin
    output_string stderr "Too many errors. Aborting.\n" ;
    exit 1
  end;
  raise (Flx_cil_parse_error (i.fileName, i.linenum, adjStart, adjEnd))
  (*
  raise Parsing.Parse_error
  *)




(* More parsing support functions: line, file, char count *)
let getPosition () : int * string * int =
  let i = !current in
  i.linenum, i.fileName, Lexing.lexeme_start i.lexbuf


let getHPosition () =
  !current.hline, !current.hfile

(** Type for source-file locations *)
type location =
    { file: string; (** The file name *)
      line: int;    (** The line number *)
      hfile: string; (** The high-level file name, or "" if not present *)
      hline: int;    (** The high-level line number, or 0 if not present *)
    }

let d_loc () l =
  text (l.file ^ ":" ^ string_of_int l.line)

let d_hloc () (l: location) =
  dprintf "%s:%d%a" l.file l.line
    insert (if l.hline > 0 then dprintf " (%s:%d)" l.hfile l.hline else nil)

let locUnknown = { file = ""; hfile = ""; line = -1; hline = -1 }

let getLocation () =
  let hl, hf = getHPosition () in
  let l, f, c = getPosition () in
  { hfile = hf; hline = hl;
    file = f; line = l }

@h=tangler('src/compiler/cil/flx_cil_errormsg.mli')
@select(h)
(** Flx_cil_utility functions for error-reporting *)

(** A channel for printing log messages *)
val logChannel : out_channel ref

(** If set then print debugging info *)
val debugFlag  : bool ref

val verboseFlag : bool ref


(** Set to true if you want to see all warnings. *)
val warnFlag: bool ref

(** Error reporting functions raise this exception *)
exception Error

(* JS: added this *)
exception Flx_cil_parse_error of string * int * int * int


   (* Error reporting. All of these functions take same arguments as a
    * Flx_cil_pretty.eprintf. They raise the exception Error after they print their
    * stuff. However, their type indicates that they return a "Flx_cil_pretty.doc"
    * (due to the need to use the built-in type "format") return a doc. Thus
    * use as follows:  E.s (E.bug "different lengths (%d != %d)" l1 l2)
     *)

(** Prints an error message of the form [Error: ...].
    Use in conjunction with s, for example: [E.s (E.error ... )]. *)
val error:         ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Similar to [error] except that its output has the form [Bug: ...] *)
val bug:           ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Similar to [error] except that its output has the form [Unimplemented: ...] *)
val unimp:         ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Stop the execution by raising an Error. Use "s (error "Foo")"  *)
val s:             Flx_cil_pretty.doc -> 'a

(** This is set whenever one of the above error functions are called. It must
    be cleared manually *)
val hadErrors: bool ref

(** Like {!Flx_cil_errormsg.error} but does not raise the {!Flx_cil_errormsg.Error}
 * exception. Use: [ignore (E.warn ...)] *)
val warn:    ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Like {!Flx_cil_errormsg.warn} but optional. Printed only if the
 * {!Flx_cil_errormsg.warnFlag} is set *)
val warnOpt: ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Print something to [logChannel] *)
val log:           ('a,unit,Flx_cil_pretty.doc) format -> 'a

   (* All of the error and warning reporting functions can also print a
    * context. To register a context printing function use "pushContext". To
    * remove the last registered one use "popContext". If one of the error
    * reporting functions is called it will invoke all currently registered
    * context reporting functions in the reverse order they were registered. *)

(** Do not actually print (i.e. print to /dev/null) *)
val null : ('a,unit,Flx_cil_pretty.doc) format -> 'a

(** Registers a context printing function *)
val pushContext  : (unit -> Flx_cil_pretty.doc) -> unit

(** Removes the last registered context printing function *)
val popContext   : unit -> unit

(** Show the context stack to stderr *)
val showContext : unit -> unit

(** To ensure that the context is registered and removed properly, use the
    function below *)
val withContext  : (unit -> Flx_cil_pretty.doc) -> ('a -> 'b) -> 'a -> 'b



val newline: unit -> unit  (* Call this function to announce a new line *)
val newHline: unit -> unit

val getPosition: unit -> int * string * int (* Line number, file name,
                                               current byte count in file *)
val getHPosition: unit -> int * string (** high-level position *)

val setHLine: int -> unit
val setHFile: string -> unit

val setCurrentLine: int -> unit
val setCurrentFile: string -> unit

(** Type for source-file locations *)
type location =
    { file: string; (** The file name *)
      line: int;    (** The line number *)
      hfile: string; (** The high-level file name, or "" if not present *)
      hline: int;    (** The high-level line number, or 0 if not present *)
    }

val d_loc: unit -> location -> Flx_cil_pretty.doc
val d_hloc: unit -> location -> Flx_cil_pretty.doc

val getLocation: unit -> location

val parse_error: string -> (* A message *)
                 'a

(** An unknown location for use when you need one but you don't have one *)
val locUnknown: location


val startParsing: string -> Lexing.lexbuf (* Call this function to start
                                           * parsing *)
val startParsingFromString: ?file:string -> ?line:int -> string
                            -> Lexing.lexbuf

val finishParsing: unit -> unit (* Call this function to finish parsing and
                                 * close the input channel *)


@h=tangler('src/compiler/cil/flx_cil_inthash.mli')
@select(h)
type 'a t = { mutable size : int; mutable data : 'a bucketlist array; }
and 'a bucketlist = Empty | Cons of int * 'a * 'a bucketlist
val create : int -> 'a t
val clear : 'a t -> unit
val copy : 'a t -> 'a t
val resize : 'a t -> unit
val add : 'a t -> int -> 'a -> unit
val remove : 'a t -> int -> unit
val find_rec : int -> 'a bucketlist -> 'a
val find : 'a t -> int -> 'a
val find_all : 'a t -> int -> 'a list
val replace : 'a t -> int -> 'a -> unit
val mem : 'a t -> int -> bool
val iter : (int -> 'a -> 'b) -> 'a t -> unit
val fold : (int -> 'a -> 'b -> 'b) -> 'a t -> 'b -> 'b
val memoize : unit t -> int -> (int -> unit) -> unit

@h=tangler('src/compiler/cil/flx_cil_inthash.ml')
@select(h)
(** A hash table specialized on integer keys *)
type 'a t =
  { mutable size: int;                        (* number of elements *)
    mutable data: 'a bucketlist array } (* the buckets *)

and 'a bucketlist =
    Empty
  | Cons of int * 'a * 'a bucketlist

let create initial_size =
  let s = min (max 1 initial_size) Sys.max_array_length in
  { size = 0; data = Array.make s Empty }

let clear h =
  for i = 0 to Array.length h.data - 1 do
    h.data.(i) <- Empty
  done;
  h.size <- 0

let copy h =
  { size = h.size;
    data = Array.copy h.data }

let resize tbl =
  let odata = tbl.data in
  let osize = Array.length odata in
  let nsize = min (2 * osize + 1) Sys.max_array_length in
  if nsize <> osize then begin
    let ndata = Array.create nsize Empty in
    let rec insert_bucket = function
        Empty -> ()
      | Cons(key, data, rest) ->
          insert_bucket rest; (* preserve original order of elements *)
          let nidx = key mod nsize in
          ndata.(nidx) <- Cons(key, data, ndata.(nidx)) in
    for i = 0 to osize - 1 do
      insert_bucket odata.(i)
    done;
    tbl.data <- ndata;
  end

let add h key info =
  let i = key mod (Array.length h.data) in
  let bucket = Cons(key, info, h.data.(i)) in
  h.data.(i) <- bucket;
  h.size <- succ h.size;
  if h.size > Array.length h.data lsl 1 then resize h

let remove h key =
  let rec remove_bucket = function
      Empty ->
        Empty
    | Cons(k, i, next) ->
        if k = key
        then begin h.size <- pred h.size; next end
        else Cons(k, i, remove_bucket next) in
  let i = key mod (Array.length h.data) in
  h.data.(i) <- remove_bucket h.data.(i)

let rec find_rec key = function
    Empty ->
      raise Not_found
  | Cons(k, d, rest) ->
      if key = k then d else find_rec key rest

let find h key =
  match h.data.(key mod (Array.length h.data)) with
    Empty -> raise Not_found
  | Cons(k1, d1, rest1) ->
      if key = k1 then d1 else
      match rest1 with
        Empty -> raise Not_found
      | Cons(k2, d2, rest2) ->
          if key = k2 then d2 else
          match rest2 with
            Empty -> raise Not_found
          | Cons(k3, d3, rest3) ->
              if key = k3 then d3 else find_rec key rest3

let find_all h key =
  let rec find_in_bucket = function
    Empty ->
      []
  | Cons(k, d, rest) ->
      if k = key then d :: find_in_bucket rest else find_in_bucket rest in
  find_in_bucket h.data.(key mod (Array.length h.data))

let replace h key info =
  let rec replace_bucket = function
      Empty ->
        raise Not_found
    | Cons(k, i, next) ->
        if k = key
        then Cons(k, info, next)
        else Cons(k, i, replace_bucket next) in
  let i = key mod (Array.length h.data) in
  let l = h.data.(i) in
  try
    h.data.(i) <- replace_bucket l
  with Not_found ->
    h.data.(i) <- Cons(key, info, l);
    h.size <- succ h.size;
    if h.size > Array.length h.data lsl 1 then resize h

let mem h key =
  let rec mem_in_bucket = function
  | Empty ->
      false
  | Cons(k, d, rest) ->
      k = key || mem_in_bucket rest in
  mem_in_bucket h.data.(key mod (Array.length h.data))

let iter f h =
  let rec do_bucket = function
      Empty ->
        ()
    | Cons(k, d, rest) ->
        f k d; do_bucket rest in
  let d = h.data in
  for i = 0 to Array.length d - 1 do
    do_bucket d.(i)
  done

let fold (f: int -> 'a -> 'b -> 'b) (h: 'a t) (init: 'b) =
  let rec do_bucket b accu =
    match b with
      Empty ->
        accu
    | Cons(k, d, rest) ->
        do_bucket rest (f k d accu) in
  let d = h.data in
  let accu = ref init in
  for i = 0 to Array.length d - 1 do
    accu := do_bucket d.(i) !accu
  done;
  !accu


let memoize (h: 'a t) (key: int) (f: int -> 'a) : 'a =
  let i = key mod (Array.length h.data) in
  let rec find_rec key = function
      Empty -> addit ()
    | Cons(k, d, rest) ->
        if key = k then d else find_rec key rest
  and find_in_bucket key = function
      Empty -> addit ()
    | Cons(k1, d1, rest1) ->
        if key = k1 then d1 else
        match rest1 with
          Empty -> addit ()
        | Cons(k2, d2, rest2) ->
            if key = k2 then d2 else
            match rest2 with
              Empty -> addit ()
            | Cons(k3, d3, rest3) ->
                if key = k3 then d3 else find_rec key rest3
  and addit () =
    let it = f key in
    h.data.(i) <- Cons(key, it, h.data.(i));
    h.size <- succ h.size;
    if h.size > Array.length h.data lsl 1 then resize h
  in
  find_in_bucket key h.data.(i)


@h=tangler('src/compiler/cil/flx_cil_pretty.ml')
@select(h)

(******************************************************************************)
(* Flx_cil_pretty printer
   This module contains several fast, but sub-optimal heuristics to pretty-print
   structured text.
*)

let debug =  false

(* Choose an algorithm *)
type algo = George | Aman | Gap
let  algo = George
let fastMode       = ref false


(** Whether to print identation or not (for faster printing and smaller
  * output) *)
let printIndent = ref true

(******************************************************************************)
(* The doc type and constructors *)

type doc =
    Nil
  | Text     of string
  | Concat   of doc * doc
  | CText    of doc * string
  | Break
  | Line
  | LeftFlush
  | Align
  | Unalign
  | Mark
  | Unmark

(* Break a string at \n *)
let rec breakString (acc: doc) (str: string) : doc =
  try
    (* Printf.printf "breaking string %s\n" str; *)
    let r = String.index str '\n' in
    (* Printf.printf "r=%d\n" r; *)
    let len = String.length str in
    if r > 0 then begin
      (* Printf.printf "Taking %s\n" (String.sub str 0 r); *)
      let acc' = Concat(CText (acc, String.sub str 0 r), Line) in
      if r = len - 1 then (* The last one *)
        acc'
      else begin
        (* Printf.printf "Continuing with %s\n" (String.sub str (r + 1) (len - r - 1)); *)
        breakString acc'
          (String.sub str (r + 1) (len - r - 1))
      end
    end else (* The first is a newline *)
      breakString (Concat(acc, Line))
        (String.sub str (r + 1) (len - r - 1))
  with Not_found ->
    if acc = Nil then Text str else CText (acc, str)

let nil           = Nil
let text s        = breakString nil s
let num  i        = text (string_of_int i)
let real f        = text (string_of_float f)
let chr  c        = text (String.make 1 c)
let align         = Align
let unalign       = Unalign
let line          = Line
let leftflush     = LeftFlush
let break         = Break
let mark          = Mark
let unmark        = Unmark

(* Note that the ++ operator in Ocaml are left-associative. This means
 * that if you have a long list of ++ then the whole thing is very unbalanced
 * towards the left side. This is the worst possible case since scanning the
 * left side of a Concat is the non-tail recursive case. *)

let (++) d1 d2 = Concat (d1, d2)

(* Ben Liblit fix *)
let indent n d = text (String.make n ' ') ++ (align ++ (d ++ unalign))

let markup d = mark ++ d ++ unmark

(* Format a sequence. The first argument is a separator *)
let seq ~(sep:doc)  ~(doit:'a -> doc) ~(elements: 'a list) =
  let rec loop (acc: doc) = function
      []     -> acc
    | h :: t ->
        let fh = doit h in  (* Make sure this is done first *)
        loop (acc ++ sep ++ fh) t
  in
  (match elements with
    [] -> nil
  | h :: t ->
      let fh = doit h in loop fh t)


let docArray (sep:doc) (doit:int -> 'a -> doc) () (elements:'a array) =
  let len = Array.length elements in
  if len = 0 then
    nil
  else
    let rec loop (acc: doc) i =
      if i >= len then acc else
      let fi = doit i elements.(i) in (* Make sure this is done first *)
      loop (acc ++ sep ++ fi) (i + 1)
    in
    let f0 = doit 0 elements.(0) in
    loop f0 1

let docOpt delem () = function
    None -> text "None"
  | Some e -> text "Some(" ++ (delem () e) ++ chr ')'



let docList (sep:doc) (doit:'a -> doc) () (elements:'a list) =
  seq sep doit elements

let insert () d = d


let d_list (sep:string) (doit:unit -> 'a -> doc) () (elts:'a list) : doc =
  (* thunk 'doit' to match docList's interface *)
  let internalDoit (elt:'a) =
    (doit () elt) in
  (docList (text sep) internalDoit () elts)


(******************************************************************************)
(* Some debugging stuff *)

let dbgprintf x = Printf.fprintf stderr x

let rec dbgPrintDoc = function
    Nil -> dbgprintf "(Nil)"
  | Text s -> dbgprintf "(Text %s)" s
  | Concat (d1,d2) -> dbgprintf ""; dbgPrintDoc  d1; dbgprintf " ++\n ";
      dbgPrintDoc  d2; dbgprintf ""
  | CText (d,s) -> dbgPrintDoc  d; dbgprintf " ++ \"%s\"" s;
  | Break -> dbgprintf "(Break)"
  | Line -> dbgprintf "(Line)"
  | LeftFlush -> dbgprintf "(LeftFlush)"
  | Align -> dbgprintf "(Align)"
  | Unalign -> dbgprintf "(Unalign)"
  | Mark -> dbgprintf "(Mark)"
  | Unmark -> dbgprintf "(Unmark)"

(******************************************************************************)
(* The "george" algorithm *)

(* When we construct documents, most of the time they are heavily unbalanced
 * towards the left. This is due to the left-associativity of ++ and also to
 * the fact that constructors such as docList construct from the let of a
 * sequence. We would prefer to shift the imbalance to the right to avoid
 * consuming a lot of stack when we traverse the document *)
let rec flatten (acc: doc) = function
  | Concat (d1, d2) -> flatten (flatten acc d2) d1
  | CText (d, s) -> flatten (Concat(Text s, acc)) d
  | Nil -> acc (* Get rid of Nil *)
  | d -> Concat(d, acc)

(* We keep a stack of active aligns. *)
type align =
    { mutable gainBreak: int;  (* This is the gain that is associated with
                                 * taking the break associated with this
                                 * alignment mark. If this is 0, then there
                                 * is no break associated with the mark *)
      mutable isTaken: bool ref; (* If breakGain is > 0 then this is a ref
                                  * cell that must be set to true when the
                                  * break is taken. These ref cells are also
                                  * int the "breaks" list  *)
            deltaFromPrev: int ref; (* The column of this alignment mark -
                                     * the column of the previous mark.
                                     * Shared with the deltaToNext of the
                                     * previous active align  *)
             deltaToNext: int ref  (* The column of the next alignment mark -
                                    * the columns of this one. Shared with
                                    * deltaFromPrev of the next active align *)
    }

(* We use references to avoid the need to pass data around all the time *)
let aligns: align list ref =  (* The current stack of active alignment marks,
                               * with the top at the head. Never empty.  *)
  ref [{ gainBreak = 0; isTaken = ref false;
         deltaFromPrev = ref 0; deltaToNext = ref 0; }]

let topAlignAbsCol = ref 0 (* The absolute column of the top alignment *)

let pushAlign (abscol: int) =
  let topalign = List.hd !aligns in
  let res =
    { gainBreak = 0; isTaken = ref false;
      deltaFromPrev = topalign.deltaToNext; (* Share with the previous *)
      deltaToNext = ref 0; (* Allocate a new ref *)} in
  aligns := res :: !aligns;
  res.deltaFromPrev := abscol - !topAlignAbsCol;
  topAlignAbsCol := abscol

let popAlign () =
  match !aligns with
    top :: t when t != [] ->
      aligns := t;
      topAlignAbsCol := !topAlignAbsCol - !(top.deltaFromPrev)
  | _ -> failwith "Unmatched unalign\n"

(** We keep a list of active markup sections. For each one we keep the column
 * we are in *)
let activeMarkups: int list ref = ref []


(* Keep a list of ref cells for the breaks, in the same order that we see
 * them in the document *)
let breaks: bool ref list ref = ref []

(* The maximum column that we should use *)
let maxCol = ref 0

(* Sometimes we take all the optional breaks *)
let breakAllMode = ref false

(* We are taking a newline and moving left *)
let newline () =
  let topalign = List.hd !aligns in (* aligns is never empty *)
  if debug then
    dbgprintf "Taking a newline: reseting gain of %d\n" topalign.gainBreak;
  topalign.gainBreak <- 0;        (* Erase the current break info *)
  if !breakAllMode && !topAlignAbsCol < !maxCol then
    breakAllMode := false;
  !topAlignAbsCol                          (* This is the new column *)



(* Choose the align with the best gain. We outght to find a better way to
 * keep the aligns sorted, especially since they gain never changes (when the
 * align is the top align) *)
let chooseBestGain () : align option =
  let bestGain = ref 0 in
  let rec loop (breakingAlign: align option) = function
      [] -> breakingAlign
    | a :: resta ->
        if debug then dbgprintf "Looking at align with gain %d\n" a.gainBreak;
        if a.gainBreak > !bestGain then begin
          bestGain := a.gainBreak;
          loop (Some a) resta
        end else
          loop breakingAlign resta
  in
  loop None !aligns


(* Another one that chooses the break associated with the current align only *)
let chooseLastGain () : align option =
  let topalign = List.hd !aligns in
  if topalign.gainBreak > 0 then Some topalign else None

(* We have just advanced to a new column. See if we must take a line break *)
let movingRight (abscol: int) : int =
  (* Keep taking the best break until we get back to the left of maxCol or no
   * more are left *)
  let rec tryAgain abscol =
    if abscol <= !maxCol then abscol else
    begin
      if debug then
        dbgprintf "Looking for a break to take in column %d\n" abscol;
      (* Find the best gain there is out there *)
      match if !fastMode then None else chooseBestGain () with
        None -> begin
          (* No breaks are available. Take all breaks from now on *)
          breakAllMode := true;
          if debug then
            dbgprintf "Can't find any breaks\n";
          abscol
        end
      | Some breakingAlign -> begin
          let topalign = List.hd !aligns in
          let theGain = breakingAlign.gainBreak in
          assert (theGain > 0);
          if debug then dbgprintf "Taking break at %d. gain=%d\n" abscol theGain;
          breakingAlign.isTaken := true;
          breakingAlign.gainBreak <- 0;
          if breakingAlign != topalign then begin
            breakingAlign.deltaToNext :=
               !(breakingAlign.deltaToNext) - theGain;
            topAlignAbsCol := !topAlignAbsCol - theGain
          end;
          tryAgain (abscol - theGain)
      end
    end
  in
  tryAgain abscol


(* Keep track of nested align in gprintf. Each gprintf format string must
 * have properly nested align/unalign pairs. When the nesting depth surpasses
 * !printDepth then we print ... and we skip until the matching unalign *)
let printDepth = ref 10000000 (* WRW: must see whole thing *)
let alignDepth = ref 0

let useAlignDepth = true

(** Start an align. Return true if we ahve just passed the threshhold *)
let enterAlign () =
  incr alignDepth;
  useAlignDepth && !alignDepth = !printDepth + 1

(** Exit an align *)
let exitAlign () =
  decr alignDepth

(** See if we are at a low-enough align level (and we should be printing
 * normally) *)
let shallowAlign () =
  not useAlignDepth || !alignDepth <= !printDepth


(* Pass the current absolute column and compute the new column *)
let rec scan (abscol: int) (d: doc) : int =
  match d with
    Nil -> abscol
  | Concat (d1, d2) -> scan (scan abscol d1) d2
  | Text s when shallowAlign () ->
      let sl = String.length s in
      if debug then
        dbgprintf "Done string: %s from %d to %d\n" s abscol (abscol + sl);
      movingRight (abscol + sl)
  | CText (d, s) ->
      let abscol' = scan abscol d in
      if shallowAlign () then begin
        let sl = String.length s in
        if debug then
          dbgprintf "Done string: %s from %d to %d\n" s abscol' (abscol' + sl);
        movingRight (abscol' + sl)
      end else
        abscol'

  | Align ->
      pushAlign abscol;
      if enterAlign () then
        movingRight (abscol + 3) (* "..." *)
      else
        abscol

  | Unalign -> exitAlign (); popAlign (); abscol

  | Line when shallowAlign () -> (* A forced line break *)
      if !activeMarkups != [] then
        failwith "Line breaks inside markup sections";
      newline ()

  | LeftFlush when shallowAlign ()  -> (* Keep cursor left-flushed *) 0

  | Break when shallowAlign () -> (* An optional line break. Always a space
                                   * followed by an optional line break *)
      if !activeMarkups != [] then
        failwith "Line breaks inside markup sections";
      let takenref = ref false in
      breaks := takenref :: !breaks;
      let topalign = List.hd !aligns in (* aligns is never empty *)
      if !breakAllMode then begin
        takenref := true;
        newline ()
      end else begin
        (* If there was a previous break there it stays not taken, forever.
         * So we overwrite it. *)
        topalign.isTaken <- takenref;
        topalign.gainBreak <- 1 + abscol - !topAlignAbsCol;
        if debug then
          dbgprintf "Registering a break at %d with gain %d\n"
            (1 + abscol) topalign.gainBreak;
        movingRight (1 + abscol)
      end

  | Mark -> activeMarkups := abscol :: !activeMarkups;
            abscol

  | Unmark -> begin
      match !activeMarkups with
        old :: rest -> activeMarkups := rest;
                       old
      | [] -> failwith "Too many unmark"
  end

  | _ -> (* Align level is too deep *) abscol


(** Keep a running counter of the newlines we are taking. You can read and
  * reset this from user code, if you want *)
let countNewLines = ref 0

(* The actual function that takes a document and prints it *)
let emitDoc
    (emitString: string -> int -> unit) (* emit a number of copies of a
                                         * string *)
    (d: doc) =
  let aligns: int list ref = ref [0] in (* A stack of alignment columns *)

  let wantIndent = ref false in
  (* Use this function to take a newline *)
  (* AB: modified it to flag wantIndent. The actual indentation is done only
     if leftflush is not encountered *)
  let newline () =
    match !aligns with
      [] -> failwith "Ran out of aligns"
    | x :: _ ->
        emitString "\n" 1;
        incr countNewLines;
        wantIndent := true;
        x
  in
  (* Print indentation if wantIndent was previously flagged ; reset this flag *)
  let indentIfNeeded () =
    if !printIndent && !wantIndent then ignore (
      match !aligns with
        [] -> failwith "Ran out of aligns"
      | x :: _ ->
          if x > 0 then emitString " "  x;
          x);
    wantIndent := false
  in
  (* A continuation passing style loop *)
  let rec loopCont (abscol: int) (d: doc) (cont: int -> unit) : unit
      (* the new column *) =
    match d with
      Nil -> cont abscol
    | Concat (d1, d2) ->
        loopCont abscol d1 (fun abscol' -> loopCont abscol' d2 cont)

    | Text s when shallowAlign () ->
        let sl = String.length s in
        indentIfNeeded ();
        emitString s 1;
        cont (abscol + sl)

    | CText (d, s) ->
        loopCont abscol d
          (fun abscol' ->
            if shallowAlign () then
              let sl = String.length s in
              indentIfNeeded ();
              emitString s 1;
              cont (abscol' + sl)
            else
              cont abscol')

    | Align ->
        aligns := abscol :: !aligns;
        if enterAlign () then begin
          indentIfNeeded ();
          emitString "..." 1;
          cont (abscol + 3)
        end else
          cont abscol

    | Unalign -> begin
        match !aligns with
          [] -> failwith "Unmatched unalign"
        | _ :: rest ->
            exitAlign ();
            aligns := rest; cont abscol
    end
    | Line when shallowAlign ()  -> cont (newline ())
    | LeftFlush when shallowAlign () -> wantIndent := false;  cont (0)
    | Break when shallowAlign () -> begin
        match !breaks with
          [] -> failwith "Break without a takenref"
        | istaken :: rest ->
            breaks := rest; (* Consume the break *)
            if !istaken then cont (newline ())
            else begin
              indentIfNeeded ();
              emitString " " 1;
              cont (abscol + 1)
            end
    end

    | Mark ->
        activeMarkups := abscol :: !activeMarkups;
        cont abscol

    | Unmark -> begin
        match !activeMarkups with
          old :: rest -> activeMarkups := rest;
                         cont old
        | [] -> failwith "Unmark without a mark"
    end

    | _ -> (* Align is too deep *)
        cont abscol
  in

  loopCont 0 d (fun x -> ())


(* Print a document on a channel *)
let fprint (chn: out_channel) ~(width: int) doc =
  maxCol := width;
  breaks := [];
  alignDepth := 0;
  activeMarkups := [];
  ignore (scan 0 doc);
  breaks := List.rev !breaks;
  alignDepth := 0;
  ignore (emitDoc
            (fun s nrcopies ->
              for i = 1 to nrcopies do
                output_string chn s
              done) doc);
  activeMarkups := [];
  breaks := [] (* We must do this especially if we don't do emit (which
                * consumes breaks) because otherwise we waste memory *)

(* Print the document to a string *)
let sprint ~(width : int)  doc : string =
  maxCol := width;
  breaks := [];
  activeMarkups := [];
  alignDepth := 0;
  ignore (scan 0 doc);
  breaks := List.rev !breaks;
  let buf = Buffer.create 1024 in
  let rec add_n_strings str num =
    if num <= 0 then ()
    else begin Buffer.add_string buf str; add_n_strings str (num - 1) end
  in
  alignDepth := 0;
  emitDoc add_n_strings doc;
  breaks  := [];
  activeMarkups := [];
  Buffer.contents buf


                                        (* The rest is based on printf.ml *)
(*
external format_int: string -> int -> string = "format_int"
external format_float: string -> float -> string = "format_float"
*)
let format_int fmt x = string_of_int x
let format_float fmt x = string_of_float x

let gprintf (finish : doc -> doc)
    (format : ('a, unit, doc) format) : 'a =
  let format = (Obj.magic format : string) in

  (* Record the starting align depth *)
  let startAlignDepth = !alignDepth in
  (* Special concatenation functions *)
  let dconcat (acc: doc) (another: doc) =
    if !alignDepth > !printDepth then acc else acc ++ another in
  let dctext1 (acc: doc) (str: string) =
    if !alignDepth > !printDepth then acc else
    CText(acc, str)
  in
  (* Special finish function *)
  let dfinish dc =
    if !alignDepth <> startAlignDepth then
      prerr_string ("Unmatched align/unalign in " ^ format ^ "\n");
    finish dc
  in
  let flen    = String.length format in
                                        (* Reading a format character *)
  let fget    = String.unsafe_get format in
                                        (* Output a literal sequence of
                                         * characters, starting at i. The
                                         * character at i does not need to be
                                         * checked.  *)
  let rec literal acc i =
    let rec skipChars j =
      if j >= flen ||
      (match fget j with
        '%' -> true
      | '@' -> true
      | '\n' -> true
      | _ -> false) then
        collect (dctext1 acc (String.sub format i (j-i))) j
      else
        skipChars (succ j)
    in
    skipChars (succ i)
                                        (* the main collection function *)
  and collect (acc: doc) (i: int) =
    if i >= flen then begin
      Obj.magic (dfinish acc)
    end else begin
      let c = fget i in
      if c = '%' then begin
        let j = skip_args (succ i) in
        match fget j with
          '%' -> literal acc j
        | 's' ->
            Obj.magic(fun s ->
              let str =
                if j <= i+1 then
                  s
                else
                  let sl = String.length s in
                  let p =
                    try
                      int_of_string (String.sub format (i+1) (j-i-1))
                    with _ ->
                      invalid_arg "fprintf: bad %s format" in
                  if p > 0 && sl < p then
                    (String.make (p - sl) ' ') ^ s
                  else if p < 0 && sl < -p then
                    s ^ (String.make (-p - sl) ' ')
                  else
                    s
              in
              collect (breakString acc str) (succ j))
        | 'c' ->
            Obj.magic(fun c ->
              collect (dctext1 acc (String.make 1 c)) (succ j))
        | 'd' | 'i' | 'o' | 'x' | 'X' | 'u' ->
            Obj.magic(fun n ->
              collect (dctext1 acc
                         (format_int (String.sub format i
                                                  (j-i+1)) n))
                (succ j))
    (* L, l, and n are the Int64, Int32, and Nativeint modifiers to the integer
       formats d,i,o,x,X,u.  For example, %Lo means print an Int64 in octal.*)
        | 'L' ->
            if j != i + 1 then  (*Int64.format handles simple formats like %d.
                     * Any special flags eaten by skip_args will confuse it. *)
              invalid_arg ("dprintf: unimplemented format "
                           ^ (String.sub format i (j-i+1)));
            let j' = succ j in (* eat the d,i,x etc. *)
            let format_spec = "% " in
            String.set format_spec 1 (fget j'); (* format_spec = "%x", etc. *)
            Obj.magic(fun n ->
              collect (dctext1 acc
                         (Int64.format format_spec n))
                (succ j'))
        | 'l' ->
            if j != i + 1 then invalid_arg ("dprintf: unimplemented format "
                                            ^ (String.sub format i (j-i+1)));
            let j' = succ j in (* eat the d,i,x etc. *)
            let format_spec = "% " in
            String.set format_spec 1 (fget j'); (* format_spec = "%x", etc. *)
            Obj.magic(fun n ->
              collect (dctext1 acc
                         (Int32.format format_spec n))
                (succ j'))
        | 'n' ->
            if j != i + 1 then invalid_arg ("dprintf: unimplemented format "
                                            ^ (String.sub format i (j-i+1)));
            let j' = succ j in (* eat the d,i,x etc. *)
            let format_spec = "% " in
            String.set format_spec 1 (fget j'); (* format_spec = "%x", etc. *)
            Obj.magic(fun n ->
              collect (dctext1 acc
                         (Nativeint.format format_spec n))
                (succ j'))
        | 'f' | 'e' | 'E' | 'g' | 'G' ->
            Obj.magic(fun f ->
              collect (dctext1 acc
                         (format_float (String.sub format i (j-i+1)) f))
                (succ j))
        | 'b' ->
            Obj.magic(fun b ->
              collect (dctext1 acc (string_of_bool b)) (succ j))
        | 'a' ->
            Obj.magic(fun pprinter arg ->
              collect (dconcat acc (pprinter () arg)) (succ j))
        | 't' ->
            Obj.magic(fun pprinter ->
              collect (dconcat acc (pprinter ())) (succ j))
        | c ->
            invalid_arg ("dprintf: unknown format %s" ^ String.make 1 c)

      end else if c = '@' then begin
        if i + 1 < flen then begin
          match fget (succ i) with

                                        (* Now the special format characters *)
            '[' ->                      (* align *)
              let newacc =
                if !alignDepth > !printDepth then
                  acc
                else if !alignDepth = !printDepth then
                  CText(acc, "...")
                else
                  acc ++ align
              in
              incr alignDepth;
              collect newacc (i + 2)

          | ']' ->                        (* unalign *)
              decr alignDepth;
              let newacc =
                if !alignDepth >= !printDepth then
                  acc
                else
                  acc ++ unalign
              in
              collect newacc (i + 2)
          | '!' ->                        (* hard-line break *)
              collect (dconcat acc line) (i + 2)
          | '?' ->                        (* soft line break *)
              collect (dconcat acc (break)) (i + 2)
          | '<' ->
              collect (dconcat acc mark) (i +1)
          | '>' ->
              collect (dconcat acc unmark) (i +1)
          | '^' ->                        (* left-flushed *)
              collect (dconcat acc (leftflush)) (i + 2)
          | '@' ->
              collect (dctext1 acc "@") (i + 2)
          | c ->
              invalid_arg ("dprintf: unknown format @" ^ String.make 1 c)
        end else
          invalid_arg "dprintf: incomplete format @"
      end else if c = '\n' then begin
        collect (dconcat acc line) (i + 1)
      end else
        literal acc i
    end

  and skip_args j =
    match String.unsafe_get format j with
      '0' .. '9' | ' ' | '.' | '-' -> skip_args (succ j)
    | c -> j

  in
  collect Nil 0

let withPrintDepth dp thunk =
  let opd = !printDepth in
  printDepth := dp;
  thunk ();
  printDepth := opd



let flushOften = ref false

let dprintf format     = gprintf (fun x -> x) format
let fprintf chn format =
  let f d = fprint chn 80 d; d in
        (* weimeric hack begins -- flush output to streams *)
  let res = gprintf f format in
        (* save the value we would have returned, flush the channel and then
         * return it -- this allows us to see debug input near infinite loops
         * *)
  if !flushOften then flush chn;
  res
        (* weimeric hack ends *)

let printf format = fprintf stdout format
let eprintf format = fprintf stderr format



(******************************************************************************)
let getAlgoName = function
    George -> "George"
  | Aman   -> "Aman"
  | Gap    -> "Gap"

let getAboutString () : string =
  "(Flx_cil_pretty: ALGO=" ^ (getAlgoName algo) ^ ")"


@h=tangler('src/compiler/cil/flx_cil_pretty.mli')
@select(h)
(** Flx_cil_utility functions for pretty-printing. The major features provided by
    this module are
- An [fprintf]-style interface with support for user-defined printers
- The printout is fit to a width by selecting some of the optional newlines
- Constructs for alignment and indentation
- Print ellipsis starting at a certain nesting depth
- Constructs for printing lists and arrays

 Flx_cil_pretty-printing occurs in two stages:
- Construct a {!Flx_cil_pretty.doc} object that encodes all of the elements to be
  printed
  along with alignment specifiers and optional and mandatory newlines
- Format the {!Flx_cil_pretty.doc} to a certain width and emit it as a string, to an
  output stream or pass it to a user-defined function

 The formatting algorithm is not optimal but it does a pretty good job while
 still operating in linear time. The original version was based on a pretty
 printer by Philip Wadler which turned out to not scale to large jobs.
*)

(** API *)

(** The type of unformated documents. Elements of this type can be
 * constructed in two ways. Either with a number of constructor shown below,
 * or using the {!Flx_cil_pretty.dprintf} function with a [printf]-like interface.
 * The {!Flx_cil_pretty.dprintf} method is slightly slower so we do not use it for
 * large jobs such as the output routines for a compiler. But we use it for
 * small jobs such as logging and error messages. *)
type doc



(** Constructors for the doc type. *)




(** Constructs an empty document *)
val nil          : doc


(** Concatenates two documents. This is an infix operator that associates to
    the left. *)
val (++)         : doc -> doc -> doc


(** A document that prints the given string *)
val text         : string -> doc


(** A document that prints an integer in decimal form *)
val num          : int    -> doc


(** A document that prints a real number *)
val real         : float  -> doc

(** A document that prints a character. This is just like {!Flx_cil_pretty.text}
    with a one-character string. *)
val chr          : char   -> doc


(** A document that consists of a mandatory newline. This is just like [(text
    "\n")]. The new line will be indented to the current indentation level,
    unless you use {!Flx_cil_pretty.leftflush} right after this. *)
val line         : doc

(** Use after a {!Flx_cil_pretty.line} to prevent the indentation. Whatever follows
 * next will be flushed left. Indentation resumes on the next line. *)
val leftflush    : doc


(** A document that consists of either a space or a line break. Also called
    an optional line break. Such a break will be
    taken only if necessary to fit the document in a given width. If the break
    is not taken a space is printed instead. *)
val break: doc

(** Mark the current column as the current indentation level. Does not print
    anything. All taken line breaks will align to this column. The previous
    alignment level is saved on a stack. *)
val align: doc

(** Reverts to the last saved indentation level. *)
val unalign: doc


(** Mark the beginning of a markup section. The width of a markup section is
 * considered 0 for the purpose of computing identation *)
val mark: doc

(** The end of a markup section *)
val unmark: doc

(************* Now some syntactic sugar *****************)
(** Syntactic sugar *)

(** Indents the document. Same as [((text "  ") ++ align ++ doc ++ unalign)],
    with the specified number of spaces. *)
val indent: int -> doc -> doc

(** Prints a document as markup. The marked document cannot contain line
 * breaks or alignment constructs. *)
val markup: doc -> doc

(** Formats a sequence. [sep] is a separator, [doit] is a function that
 * converts an element to a document. *)
val seq: sep:doc -> doit:('a ->doc) -> elements:'a list -> doc


(** An alternative function for printing a list. The [unit] argument is there
 * to make this function more easily usable with the {!Flx_cil_pretty.dprintf}
 * interface. *)
val docList: doc -> ('a -> doc) -> unit -> 'a list -> doc

(** sm: Yet another list printer.  This one accepts the same kind of
  * printing function that {!Flx_cil_pretty.dprintf} does, and itself works
  * in the dprintf context.  Also accepts
  * a string as the separator since that's by far the most common.  *)
val d_list: string -> (unit -> 'a -> doc) -> unit -> 'a list -> doc

(** Formats an array. A separator and a function that prints an array
    element *)
val docArray: doc -> (int -> 'a -> doc) -> unit -> 'a array -> doc

(** Prints an ['a option] with [None] or [Some] *)
val docOpt: (unit -> 'a -> doc) -> unit -> 'a option -> doc


(** A function that is useful with the [printf]-like interface *)
val insert: unit -> doc -> doc

val dprintf: ('a, unit, doc) format -> 'a
(** This function provides an alternative method for constructing
    [doc] objects. The first argument for this function is a format string
    argument (of type [('a, unit, doc) format]; if you insist on
    understanding what that means see the module [Printf]). The format string
    is like that for the [printf] function in C, except that it understands a
    few more formatting controls, all starting with the @ character.

 The following special formatting characters are understood (these do not
 correspond to arguments of the function):
-  @\[ Inserts an {!Flx_cil_pretty.align}. Every format string must have matching
        {!Flx_cil_pretty.align} and {!Flx_cil_pretty.unalign}.
-  @\] Inserts an {!Flx_cil_pretty.unalign}.
-  @!  Inserts a {!Flx_cil_pretty.line}. Just like "\n"
-  @?  Inserts a {!Flx_cil_pretty.break}.
-  @<  Inserts a {!Flx_cil_pretty.mark}.
-  @<  Inserts a {!Flx_cil_pretty.unmark}.
-  @^  Inserts a {!Flx_cil_pretty.leftflush}
       Should be used immediately after @! or "\n".
-  @@ : inserts a @ character

 In addition to the usual [printf] % formatting characters the following two
 new characters are supported:
- %t Corresponds to an argument of type [unit -> doc]. This argument is
     invoked to produce a document
- %a Corresponds to {b two} arguments. The first of type [unit -> 'a -> doc]
     and the second of type ['a]. (The extra [unit] is do to the
     peculiarities of the built-in support for format strings in Ocaml. It
     turns out that it is not a major problem.) Here is an example of how
     you use this:

{v dprintf "Name=%s, SSN=%7d, Children=\@\[%a\@\]\n"
             pers.name pers.ssn (docList (chr ',' ++ break) text)
             pers.children v}

 The result of [dprintf] is a {!Flx_cil_pretty.doc}. You can format the document and
 emit it using the functions {!Flx_cil_pretty.fprint} and {!Flx_cil_pretty.sprint}.

*)

(** Format the document to the given width and emit it to the given channel *)
val fprint: out_channel -> width:int -> doc -> unit

(** Format the document to the given width and emit it as a string *)
val sprint: width:int -> doc -> string

(** Like {!Flx_cil_pretty.dprintf} followed by {!Flx_cil_pretty.fprint} *)
val fprintf: out_channel -> ('a, unit, doc) format -> 'a

(** Like {!Flx_cil_pretty.fprintf} applied to [stdout] *)
val printf: ('a, unit, doc) format -> 'a

(** Like {!Flx_cil_pretty.fprintf} applied to [stderr] *)
val eprintf: ('a, unit, doc) format -> 'a

(** Like {!Flx_cil_pretty.dprintf} but more general. It also takes a function that is
 * invoked on the constructed document but before any formatting is done. *)
val gprintf: (doc -> doc) -> ('a, unit, doc) format -> 'a

(* sm: arg!  why can't I write this function?! *)
(* * Like {!Flx_cil_pretty.dprintf} but yielding a string with no newlines *)
(*val sprintf: (doc, unit, doc) format -> string*)

(* sm: different tack.. *)
(* doesn't work either.  well f it anyway *)
(*val failwithf: ('a, unit, doc) format -> 'a*)


(** Invokes a thunk, with printDepth temporarily set to the specified value *)
val withPrintDepth : int -> (unit -> unit) -> unit

(** The following variables can be used to control the operation of the printer *)

(** Specifies the nesting depth of the [align]/[unalign] pairs at which
    everything is replaced with ellipsis *)
val printDepth   : int ref

val printIndent  : bool ref  (** If false then does not indent *)


(** If set to [true] then optional breaks are taken only when the document
    has exceeded the given width. This means that the printout will looked
    more ragged but it will be faster *)
val fastMode  : bool ref

val flushOften   : bool ref  (** If true the it flushes after every print *)


(** Keep a running count of the taken newlines. You can read and write this
  * from the client code if you want *)
val countNewLines : int ref
@h=tangler('src/compiler/cil/flx_cil_stats.ml')
@select(h)
(* The following functions are implemented in perfcount.c *)

(* Returns true is we have the performance counters *)
external has_performance_counters: unit -> bool = "has_performance_counters"

(* Returns number of seconds since the first read *)
external read_pentium_perfcount : unit -> float = "read_pentium_perfcount"



(* Whether to use the performance counters (on Pentium only) *)

(* The performance counters are disabled by default. *)
let do_use_performance_counters = ref false

                                        (* A hierarchy of timings *)

type t = { name : string;
           mutable time : float; (* In seconds *)
           mutable sub  : t list}

                                        (* Create the top level *)
let top = { name = "TOTAL";
            time = 0.0;
            sub  = []; }

                                        (* The stack of current path through
                                         * the hierarchy. The first is the
                                         * leaf. *)
let current : t list ref = ref [top]

exception NoPerfCount
let reset (perfcount: bool) =
  top.sub <- [];
  if perfcount then begin
    if not (has_performance_counters ()) then begin
      raise NoPerfCount
    end
  end;
  do_use_performance_counters := perfcount



let print chn msg =
  (* Total up *)
  top.time <- List.fold_left (fun sum f -> sum +. f.time) 0.0 top.sub;
  let rec prTree ind node =
    if !do_use_performance_counters then
      (Printf.fprintf chn "%s%-20s          %8.5f s\n"
         (String.make ind ' ') node.name node.time)
    else
      (Printf.fprintf chn "%s%-20s          %6.3f s\n"
         (String.make ind ' ') node.name node.time);

   List.iter (prTree (ind + 2)) node.sub
  in
  Printf.fprintf chn "%s" msg;
  List.iter (prTree 0) [ top ];
  Printf.fprintf chn "Timing used %s\n"
    (if !do_use_performance_counters then "performance counters" else "Unix.time");
  ()



(* Get the current time, in seconds *)
let get_current_time () : float =
  if !do_use_performance_counters then
    read_pentium_perfcount ()
  else
    (Unix.times ()).Unix.tms_utime

let repeattime limit str f arg =
                                        (* Find the right stat *)
  let stat : t =
    let curr = match !current with h :: _ -> h | _ -> assert false in
    let rec loop = function
        h :: _ when h.name = str -> h
      | _ :: rest -> loop rest
      | [] ->
          let nw = {name = str; time = 0.0; sub = []} in
          curr.sub <- nw :: curr.sub;
          nw
    in
    loop curr.sub
  in
  let oldcurrent = !current in
  current := stat :: oldcurrent;
  let start = get_current_time () in
  let rec loop count =
    let res   = f arg in
    let diff = get_current_time () -. start in
    if diff < limit then
      loop (count + 1)
    else begin
      stat.time <- stat.time +. (diff /. float(count));
      current := oldcurrent;                (* Pop the current stat *)
      res                                   (* Return the function result *)
    end
  in
  loop 1


let time str f arg = repeattime 0.0 str f arg















@h=tangler('src/compiler/cil/flx_cil_stats.mli')
@select(h)
(** Flx_cil_utilities for maintaining timing statistics *)

(** Resets all the timings. Invoke with "true" if you want to switch to using
 * the hardware performance counters from now on. You get an exception if
 * there are not performance counters available *)
val reset: bool -> unit
exception NoPerfCount

(** Flx_cil_check if we have performance counters *)
val has_performance_counters: unit -> bool

(** Time a function and associate the time with the given string. If some
    timing information is already associated with that string, then accumulate
    the times. If this function is invoked within another timed function then
    you can have a hierarchy of timings *)
val time : string -> ('a -> 'b) -> 'a -> 'b

(** repeattime is like time but runs the function several times until the total
    running time is greater or equal to the first argument. The total time is
    then divided by the number of times the function was run. *)
val repeattime : float -> string -> ('a -> 'b) -> 'a -> 'b

(** Print the current stats preceeded by a message *)
val print : out_channel -> string -> unit






@h=tangler('src/compiler/cil/flx_cil_trace.ml')
@select(h)
(* Flx_cil_trace module implementation
 * see trace.mli
 *)

open Flx_cil_pretty;;


(* --------- traceSubsystems --------- *)
(* this is the list of tags (usually subsystem names) for which
 * trace output will appear *)
let traceSubsystems : string list ref = ref [];;


let traceAddSys (subsys : string) : unit =
  (* (ignore (printf "traceAddSys %s\n" subsys)); *)
  traceSubsystems := subsys :: !traceSubsystems
;;


let traceActive (subsys : string) : bool =
  (* (List.mem elt list) returns true if something in list equals ('=') elt *)
  (List.mem subsys !traceSubsystems)
;;


let rec parseString (str : string) (delim : char) : string list =
begin
  if (not (String.contains str delim)) then
    if ((String.length str) = 0) then
      []
    else
      [str]

  else
    let d = ((String.index str delim) + 1) in
    if (d = 1) then
      (* leading delims are eaten *)
      (parseString (String.sub str d ((String.length str) - d)) delim)
    else
      (String.sub str 0 (d-1)) ::
        (parseString (String.sub str d ((String.length str) - d)) delim)
end;;

let traceAddMulti (systems : string) : unit =
begin
  let syslist = (parseString systems ',') in
  (List.iter traceAddSys syslist)
end;;



(* --------- traceIndent --------- *)
let traceIndentLevel : int ref = ref 0;;


let traceIndent (sys : string) : unit =
  if (traceActive sys) then
    traceIndentLevel := !traceIndentLevel + 2
;;

let traceOutdent (sys : string) : unit =
  if ((traceActive sys) &&
      (!traceIndentLevel >= 2)) then
    traceIndentLevel := !traceIndentLevel - 2
;;


(* --------- trace --------- *)
(* return a tag to prepend to a trace output
 * e.g. "  %%% mysys: "
 *)
let traceTag (sys : string) : Flx_cil_pretty.doc =
  (* return string of 'i' spaces *)
  let rec ind (i : int) : string =
    if (i <= 0) then
      ""
    else
      " " ^ (ind (i-1))

  in
  (text ((ind !traceIndentLevel) ^ "%%% " ^ sys ^ ": "))
;;


(* this is the trace function; its first argument is a string
 * tag, and subsequent arguments are like printf formatting
 * strings ("%a" and whatnot) *)
let trace
    (subsys : string)                   (* subsystem identifier for enabling tracing *)
    (d : Flx_cil_pretty.doc)                    (* something made by 'dprintf' *)
    : unit =                            (* no return value *)
  (* (ignore (printf "trace %s\n" subsys)); *)

  (* see if the subsystem's tracing is turned on *)
  if (traceActive subsys) then
    begin
      (fprint stderr 80                 (* print it *)
         ((traceTag subsys) ++ d));     (* with prepended subsys tag *)
      (* mb: flush after every message; useful if the program hangs in an
         infinite loop... *)
      (flush stderr)
    end
  else
    ()                                           (* eat it *)
;;


let tracei (sys : string) (d : Flx_cil_pretty.doc) : unit =
  (* trace before indent *)
  (trace sys d);
  (traceIndent sys)
;;

let traceu (sys : string) (d : Flx_cil_pretty.doc) : unit =
  (* trace after outdent *)
  (* no -- I changed my mind -- I want trace *then* outdent *)
  (trace sys d);
  (traceOutdent sys)
;;




(* -------------------------- trash --------------------- *)
(* TRASH START

(* sm: more experimenting *)
(trace "no" (dprintf "no %d\n" 5));
(trace "yes" (dprintf "yes %d\n" 6));
(trace "maybe" (dprintf "maybe %d\n" 7));

TRASH END *)
@h=tangler('src/compiler/cil/flx_cil_trace.mli')
@select(h)
(* Flx_cil_trace module
 * Scott McPeak, 5/4/00
 *
 * The idea is to pepper the source with debugging printfs,
 * and be able to select which ones to actually display at
 * runtime.
 *
 * It is built on top of the Flx_cil_pretty module for printing data
 * structures.
 *
 * To a first approximation, this is needed to compensate for
 * the lack of a debugger that does what I want...
 *)


(* this is the list of tags (usually subsystem names) for which
 * trace output will appear *)
val traceSubsystems : string list ref

(* interface to add a new subsystem to trace (slightly more
 * convenient than direclty changing 'tracingSubsystems') *)
val traceAddSys : string -> unit

(* query whether a particular subsystem is being traced *)
val traceActive : string -> bool

(* add several systems, separated by commas *)
val traceAddMulti : string -> unit


(* current indentation level for tracing *)
val traceIndentLevel : int ref

(* bump up or down the indentation level, if the given subsys
 * is being traced *)
val traceIndent : string -> unit
val traceOutdent : string -> unit


(* this is the trace function; its first argument is a string
 * tag, and second argument is a 'doc' (which is what 'dprintf'
 * returns).
 *
 * so a sample usage might be
 *   (trace "mysubsys" (dprintf "something neat happened %d times\n" counter))
 *)
val trace : string -> Flx_cil_pretty.doc -> unit


(* special flavors that indent/outdent as well.  the indent version
 * indents *after* printing, while the outdent version outdents
 * *before* printing.  thus, a sequence like
 *
 *   (tracei "foo" (dprintf "beginning razzle-dazzle\n"))
 *     ..razzle..
 *     ..dazzle..
 *   (traceu "foo" (dprintf "done with razzle-dazzle\n"))
 *
 * will do the right thing
 *
 * update -- I changed my mind!  I decided I prefer it like this
 *   %%% sys: (myfunc args)
 *     %%% ...inner stuff...
 *     %%% sys: myfunc returning 56
 *
 * so now they both print before in/outdenting
 *)
val tracei : string -> Flx_cil_pretty.doc -> unit
val traceu : string -> Flx_cil_pretty.doc -> unit


@h=tangler('src/compiler/cil/flx_cil_util.mli')
@select(h)
(** A bunch of generally useful functions *)

exception GotSignal of int

val withTimeout : float -> (* Seconds for timeout *)
                (int -> 'b) -> (* What to do if we have a timeout. The
                                        * argument passed is the signal number
                                        * received. *)
                ('a -> 'b) -> (* The function to run *)
                'a -> (* And its argument *)
   'b

val docHash : ('a -> 'b -> Flx_cil_pretty.doc) -> unit ->
  (('a, 'b) Hashtbl.t) -> Flx_cil_pretty.doc


val hash_to_list: ('a, 'b) Hashtbl.t -> ('a * 'b) list

val keys: ('a, 'b) Hashtbl.t -> 'a list


(** Copy a hash table into another *)
val hash_copy_into: ('a, 'b) Hashtbl.t -> ('a, 'b) Hashtbl.t -> unit

(** First, a few utility functions I wish were in the standard prelude *)

val anticompare: 'a -> 'a -> int

val list_drop : int -> 'a list -> 'a list
val list_span: ('a -> bool) -> ('a list) -> 'a list * 'a list
val list_insert_by: ('a -> 'a -> int) -> 'a -> 'a list -> 'a list
val list_head_default: 'a -> 'a list -> 'a
val list_iter3 : ('a -> 'b -> 'c -> unit) ->
  'a list -> 'b list -> 'c list -> unit
val get_some_option_list : 'a option list -> 'a list

(** Iterate over a list passing the index as you go *)
val list_iteri: (int -> 'a -> unit) -> 'a list -> unit
val list_mapi: (int -> 'a -> 'b) -> 'a list -> 'b list

(** Like fold_left but pass the index into the list as well *)
val list_fold_lefti: ('acc -> int -> 'a -> 'acc) -> 'acc -> 'a list -> 'acc

val int_range_list : int -> int -> int list

(* Create a list of length l *)
val list_init : int -> (int -> 'a) -> 'a list


(** mapNoCopy is like map but avoid copying the list if the function does not
 * change the elements *)

val mapNoCopy: ('a -> 'a) -> 'a list -> 'a list

val mapNoCopyList: ('a -> 'a list) -> 'a list -> 'a list

val filterNoCopy: ('a -> bool) -> 'a list -> 'a list

(** Growable arrays *)
type 'a growArrayFill =
    Elem of 'a
  | Susp of (int -> 'a)

type 'a growArray = {
            gaFill: 'a growArrayFill;
            (** Stuff to use to fill in the array as it grows *)

    mutable gaMaxInitIndex: int;
            (** Maximum index that was written to. -1 if no writes have
             * been made.  *)

    mutable gaData: 'a array;
  }

val newGrowArray: int -> 'a growArrayFill -> 'a growArray
(** [newGrowArray initsz fillhow] *)

val getReg: 'a growArray -> int -> 'a
val setReg: 'a growArray -> int -> 'a -> unit
val copyGrowArray: 'a growArray -> 'a growArray
val deepCopyGrowArray: 'a growArray -> ('a -> 'a) -> 'a growArray


val growArray_iteri:  (int -> 'a -> unit) -> 'a growArray -> unit
(** Iterate over the initialized elements of the array *)

val growArray_foldl: ('acc -> 'a -> 'acc) -> 'acc ->'a growArray -> 'acc
(** Fold left over the initialized elements of the array *)

(** hasPrefix prefix str returns true with str starts with prefix *)
val hasPrefix: string -> string -> bool


(** Given a ref cell, produce a thunk that later restores it to its current value *)
val restoreRef: ?deepCopy:('a -> 'a) -> 'a ref -> unit -> unit

(** Given a hash table, produce a thunk that later restores it to its current value *)
val restoreHash: ?deepCopy:('b -> 'b) -> ('a, 'b) Hashtbl.t -> unit -> unit

(** Given an array, produce a thunk that later restores it to its current value *)
val restoreArray: ?deepCopy:('a -> 'a) -> 'a array -> unit -> unit


(** Given a list of thunks, produce a thunk that runs them all *)
val runThunks: (unit -> unit) list -> unit -> unit


val memoize: ('a, 'b) Hashtbl.t ->
            'a ->
            ('a -> 'b) -> 'b

(** Just another name for memoize *)
val findOrAdd: ('a, 'b) Hashtbl.t ->
            'a ->
            ('a -> 'b) -> 'b

val tryFinally:
    ('a -> 'b) -> (* The function to run *)
    ('b option -> unit) -> (* Something to run at the end. The None case is
                          * used when an exception is thrown *)
    'a -> 'b


(** The state information that the UI must display is viewed abstractly as a
 * set of registers. *)
type registerInfo = {
    rName: string; (** The name of the register *)
    rGroup: string; (** The name of the group to which this register belongs.
                     * The special group Engine.machineRegisterGroup
                     * contains the machine registers, which are displayed in
                     * a special window. *)
    rVal: Flx_cil_pretty.doc; (** The value to be displayed about a register *)
    rOneLineVal: Flx_cil_pretty.doc option (** The value to be displayed on one line *)
}


(** Get the value of an option.  Raises Failure if None *)
val valOf : 'a option -> 'a

(**
 * An accumulating for loop.
 *
 * Initialize the accumulator with init.  The current index and accumulator
 * from the previous iteration is passed to f.
 *)
val fold_for : init:'a -> lo:int -> hi:int -> (int -> 'a -> 'a) -> 'a

(************************************************************************)

module type STACK = sig
  type 'a t
  (** The type of stacks containing elements of type ['a]. *)

  exception Empty
  (** Raised when Stack.pop or Stack.top is applied to an empty stack. *)

  val create : unit -> 'a t


  val push : 'a -> 'a t -> unit
  (** [push x s] adds the element [x] at the top of stack [s]. *)

  val pop : 'a t -> 'a
  (** [pop s] removes and returns the topmost element in stack [s],
     or raises [Empty] if the stack is empty. *)

  val top : 'a t -> 'a
  (** [top s] returns the topmost element in stack [s],
     or raises [Empty] if the stack is empty. *)

  val clear : 'a t -> unit
  (** Discard all elements from a stack. *)

  val copy : 'a t -> 'a t
  (** Return a copy of the given stack. *)

  val is_empty : 'a t -> bool
  (** Return [true] if the given stack is empty, [false] otherwise. *)

  val length : 'a t -> int
  (** Return the number of elements in a stack. *)

  val iter : ('a -> unit) -> 'a t -> unit
  (** [iter f s] applies [f] in turn to all elements of [s],
     from the element at the top of the stack to the element at the
     bottom of the stack. The stack itself is unchanged. *)
end

module Stack : STACK

(************************************************************************
   Configuration
************************************************************************)
(** The configuration data can be of several types **)
type configData =
    ConfInt of int
  | ConfBool of bool
  | ConfFloat of float
  | ConfString of string
  | ConfList of configData list


(** Load the configuration from a file *)
val loadConfiguration: string -> unit

(** Save the configuration in a file. Overwrites the previous values *)
val saveConfiguration: string -> unit


(** Clear all configuration data *)
val clearConfiguration: unit -> unit

(** Set a configuration element, with a key. Overwrites the previous values *)
val setConfiguration: string -> configData -> unit

(** Find a configuration elements, given a key. Raises Not_found if it canont
 * find it *)
val findConfiguration: string -> configData

(** Like findConfiguration but extracts the integer *)
val findConfigurationInt: string -> int

(** Looks for an integer configuration element, and if it is found, it uses
 * the given function. Otherwise, does nothing *)
val useConfigurationInt: string -> (int -> unit) -> unit


val findConfigurationBool: string -> bool
val useConfigurationBool: string -> (bool -> unit) -> unit

val findConfigurationString: string -> string
val useConfigurationString: string -> (string -> unit) -> unit

val findConfigurationList: string -> configData list
val useConfigurationList: string -> (configData list -> unit) -> unit


(************************************************************************)

(** Symbols are integers that are uniquely associated with names *)
type symbol = int

(** Get the name of a symbol *)
val symbolName: symbol -> string

(** Register a symbol name and get the symbol for it *)
val registerSymbolName: string -> symbol

(** Register a number of consecutive symbol ids. The naming function will be
 * invoked with indices from 0 to the counter - 1. Returns the id of the
 * first symbol created *)
val registerSymbolRange: int -> (int -> string) -> symbol

@h=tangler('src/compiler/cil/flx_cil_util.ml')
@select(h)
(** Flx_cil_utility functions for Coolaid *)
module E = Flx_cil_errormsg
module H = Hashtbl
module IH = Flx_cil_inthash

open Flx_cil_pretty

exception GotSignal of int

let withTimeout (secs: float) (* Seconds for timeout *)
                (handler: int -> 'b) (* What to do if we have a timeout. The
                                        * argument passed is the signal number
                                        * received. *)
                (f: 'a -> 'b) (* The function to run *)
                (arg: 'a) (* And its argument *)
   : 'b =
  let oldHandler =
    Sys.signal Sys.sigalrm
      (Sys.Signal_handle
         (fun i ->
           ignore (E.log "Got signal %d\n" i);
           raise (GotSignal i)))
  in
  let reset_sigalrm () =
    ignore (Unix.setitimer Unix.ITIMER_REAL { Unix.it_value = 0.0;
                                              Unix.it_interval = 0.0;});
    Sys.set_signal Sys.sigalrm oldHandler;
  in
  ignore (Unix.setitimer Unix.ITIMER_REAL
            { Unix.it_value    = secs;
              Unix.it_interval = 0.0;});
  (* ignore (Unix.alarm 2); *)
  try
    let res = f arg in
    reset_sigalrm ();
    res
  with exc -> begin
    reset_sigalrm ();
    ignore (E.log "Got an exception\n");
    match exc with
      GotSignal i ->
        handler i
    | _ -> raise exc
  end

(** Print a hash table *)
let docHash (one: 'a -> 'b -> doc) () (h: ('a, 'b) H.t) =
  let theDoc = ref nil in
  (H.fold
     (fun key data acc -> acc ++ one key data)
     h
     align) ++ unalign



let hash_to_list (h: ('a, 'b) H.t) : ('a * 'b) list =
  H.fold
    (fun key data acc -> (key, data) :: acc)
    h
    []

let keys (h: ('a, 'b) H.t) : 'a list =
  H.fold
    (fun key data acc -> key :: acc)
    h
    []

let hash_copy_into (hfrom: ('a, 'b) H.t) (hto: ('a, 'b) H.t) : unit =
  H.clear hto;
  H.iter (H.add hto) hfrom

let anticompare a b = compare b a
;;


let rec list_drop (n : int) (xs : 'a list) : 'a list =
  if n < 0 then invalid_arg "Flx_cil_util.list_drop";
  if n = 0 then
    xs
  else begin
    match xs with
    | [] -> invalid_arg "Flx_cil_util.list_drop"
    | y::ys -> list_drop (n-1) ys
  end


let rec list_span (p : 'a -> bool) (xs : 'a list) : 'a list * 'a list =
  begin match xs with
  | [] -> ([],[])
  | x::xs' ->
      if p x then
        let (ys,zs) = list_span p xs' in (x::ys,zs)
      else ([],xs)
  end
;;

let rec list_rev_append revxs ys =
  begin match revxs with
  | [] -> ys
  | x::xs -> list_rev_append xs (x::ys)
  end
;;
let list_insert_by (cmp : 'a -> 'a -> int)
    (x : 'a) (xs : 'a list) : 'a list =
  let rec helper revhs ts =
    begin match ts with
    | [] -> List.rev (x::revhs)
    | t::ts' ->
        if cmp x t >= 0 then helper (t::revhs) ts'
        else list_rev_append (x::revhs) ts
    end
  in
  helper [] xs
;;

let list_head_default (d : 'a) (xs : 'a list) : 'a =
  begin match xs with
  | [] -> d
  | x::_ -> x
  end
;;

let rec list_iter3 f xs ys zs =
  begin match xs, ys, zs with
  | [], [], [] -> ()
  | x::xs, y::ys, z::zs -> f x y z; list_iter3 f xs ys zs
  | _ -> invalid_arg "Flx_cil_util.list_iter3"
  end
;;

let rec get_some_option_list (xs : 'a option list) : 'a list =
  begin match xs with
  | [] -> []
  | None::xs  -> get_some_option_list xs
  | Some x::xs -> x :: get_some_option_list xs
  end
;;

let list_iteri (f: int -> 'a -> unit) (l: 'a list) : unit =
  let rec loop (i: int) (l: 'a list) : unit =
    match l with
      [] -> ()
    | h :: t -> f i h; loop (i + 1) t
  in
  loop 0 l

let list_mapi (f: int -> 'a -> 'b) (l: 'a list) : 'b list =
  let rec loop (i: int) (l: 'a list) : 'b list =
    match l with
      [] -> []
    | h :: t ->
        let headres = f i h in
        headres :: loop (i + 1) t
  in
  loop 0 l

let list_fold_lefti (f: 'acc -> int -> 'a -> 'acc) (start: 'acc)
                   (l: 'a list) : 'acc =
  let rec loop (i, acc) l =
    match l with
      [] -> acc
    | h :: t -> loop (i + 1, f acc i h) t
  in
  loop (0, start) l


let list_init (len : int) (init_fun : int -> 'a) : 'a list =
  let rec loop n acc =
    if n < 0 then acc
    else loop (n-1) ((init_fun n)::acc)
  in
  loop (len - 1) []
;;


(** Generates the range of integers starting with a and ending with b *)
let int_range_list (a: int) (b: int) =
  list_init (b - a + 1) (fun i -> a + i)


(** Some handling of registers *)
type 'a growArrayFill =
    Elem of 'a
  | Susp of (int -> 'a)

type 'a growArray = {
            gaFill: 'a growArrayFill;
            (** Stuff to use to fill in the array as it grows *)

    mutable gaMaxInitIndex: int;
            (** Maximum index that was written to. -1 if no writes have
             * been made.  *)

    mutable gaData: 'a array;
  }

let growTheArray (ga: 'a growArray) (len: int)
                 (toidx: int) (why: string) : unit =
  if toidx >= len then begin
    (* Grow the array by 50% *)
    let newlen = toidx + 1 + len  / 2 in
(*
    ignore (E.log "growing an array to idx=%d (%s)\n" toidx why);
*)
    let data' = begin match ga.gaFill with
      Elem x ->

        let data'' = Array.create newlen x in
        Array.blit ga.gaData 0 data'' 0 len;
        data''
    | Susp f -> Array.init newlen
          (fun i -> if i < len then ga.gaData.(i) else f i)
    end
    in
    ga.gaData <- data'
  end

let getReg (ga: 'a growArray) (r: int) : 'a =
  let len = Array.length ga.gaData in
  if r >= len then
    growTheArray ga len r "get";

  ga.gaData.(r)

let setReg (ga: 'a growArray) (r: int) (what: 'a) : unit =
  let len = Array.length ga.gaData in
  if r >= len then
    growTheArray ga len r "set";
  if r > ga.gaMaxInitIndex then ga.gaMaxInitIndex <- r;
  ga.gaData.(r) <- what

let newGrowArray (initsz: int) (fill: 'a growArrayFill) : 'a growArray =
  { gaFill = fill;
    gaMaxInitIndex = -1;
    gaData = begin match fill with
      Elem x -> Array.create initsz x
    | Susp f -> Array.init initsz f
    end; }

let copyGrowArray (ga: 'a growArray) : 'a growArray =
  { ga with gaData = Array.copy ga.gaData }

let deepCopyGrowArray (ga: 'a growArray) (copy: 'a -> 'a): 'a growArray =
  { ga with gaData = Array.map copy ga.gaData }



(** Iterate over the initialized elements of the array *)
let growArray_iteri  (f: int -> 'a -> unit) (ga: 'a growArray) =
  for i = 0 to ga.gaMaxInitIndex do
    f i ga.gaData.(i)
  done


(** Fold left over the initialized elements of the array *)
let growArray_foldl (f: 'acc -> 'a -> 'acc)
                    (acc: 'acc) (ga: 'a growArray) : 'acc =
  let rec loop (acc: 'acc) (idx: int) : 'acc =
    if idx > ga.gaMaxInitIndex then
      acc
    else
      loop (f acc ga.gaData.(idx)) (idx + 1)
  in
  loop acc 0




let hasPrefix (prefix: string) (what: string) : bool =
  let pl = String.length prefix in
  try String.sub what 0 pl = prefix
  with Invalid_argument _ -> false



let restoreRef ?(deepCopy=(fun x -> x)) (r: 'a ref) : (unit -> unit) =
  let old = deepCopy !r in
  (fun () -> r := old)

let restoreHash ?deepCopy (h: ('a, 'b) H.t) : (unit -> unit) =
  let old =
    match deepCopy with
      None -> H.copy h
    | Some f ->
        let old = H.create 13 in
        H.iter (fun k d -> H.add old k (f d)) h;
        old
  in
  (fun () -> hash_copy_into old h)

let restoreArray ?deepCopy (a: 'a array) : (unit -> unit) =
  let old = Array.copy a in
  (match deepCopy with
    None -> ()
  | Some f -> Array.iteri (fun i v -> old.(i) <- f v) old);
  (fun () -> Array.blit old 0 a 0 (Array.length a))

let runThunks (l: (unit -> unit) list) : (unit -> unit) =
  fun () -> List.iter (fun f -> f ()) l



(* Memoize *)
let memoize (h: ('a, 'b) Hashtbl.t)
            (arg: 'a)
            (f: 'a -> 'b) : 'b =
  try
    Hashtbl.find h arg
  with Not_found -> begin
    let res = f arg in
    Hashtbl.add h arg res;
    res
  end

(* Just another name for memoize *)
let findOrAdd h arg f = memoize h arg f

(* A tryFinally function *)
let tryFinally
    (main: 'a -> 'b) (* The function to run *)
    (final: 'b option -> unit)  (* Something to run at the end *)
    (arg: 'a) : 'b =
  try
    let res: 'b = main arg in
    final (Some res);
    res
  with e -> begin
    final None;
    raise e
  end




(** The state information that the GUI must display is viewed abstractly as a
 * set of registers. *)
type registerInfo = {
    rName: string; (** The name of the register *)
    rGroup: string; (** The name of the group to which this register belongs.
                     * The special group Engine.machineRegisterGroup
                     * contains the machine registers. *)
    rVal: Flx_cil_pretty.doc; (** The value to be displayed about a register *)
    rOneLineVal: Flx_cil_pretty.doc option (** The value to be displayed on one line *)
}



let valOf : 'a option -> 'a = function
    None -> raise (Failure "Flx_cil_util.valOf")
  | Some x -> x

(**
 * An accumulating for loop.
 *
 * Initialize the accumulator with init.  The current index and accumulator
 * from the previous iteration is passed to f.
 *)
let fold_for ~(init: 'a) ~(lo: int) ~(hi: int) (f: int -> 'a -> 'a) =
  let rec forloop i acc =
    if i > hi then acc
    else forloop (i+1) (f i acc)
  in
  forloop lo init

(************************************************************************)

module type STACK = sig
  type 'a t
  (** The type of stacks containing elements of type ['a]. *)

  exception Empty
  (** Raised when Stack.pop or Stack.top is applied to an empty stack. *)

  val create : unit -> 'a t
  (** Return a new stack, initially empty. *)

  val push : 'a -> 'a t -> unit
  (** [push x s] adds the element [x] at the top of stack [s]. *)

  val pop : 'a t -> 'a
  (** [pop s] removes and returns the topmost element in stack [s],
     or raises [Empty] if the stack is empty. *)

  val top : 'a t -> 'a
  (** [top s] returns the topmost element in stack [s],
     or raises [Empty] if the stack is empty. *)

  val clear : 'a t -> unit
  (** Discard all elements from a stack. *)

  val copy : 'a t -> 'a t
  (** Return a copy of the given stack. *)

  val is_empty : 'a t -> bool
  (** Return [true] if the given stack is empty, [false] otherwise. *)

  val length : 'a t -> int
  (** Return the number of elements in a stack. *)

  val iter : ('a -> unit) -> 'a t -> unit
  (** [iter f s] applies [f] in turn to all elements of [s],
     from the element at the top of the stack to the element at the
     bottom of the stack. The stack itself is unchanged. *)
end

module Stack = struct

  type 'a t = { mutable length : int;
                stack : 'a Stack.t; }

  exception Empty

  let create () = { length = 0;
                    stack = Stack.create(); }

  let push x s =
    s.length <- s.length + 1;
    Stack.push x s.stack

  let pop s =
    s.length <- s.length - 1;
    Stack.pop s.stack

  let top s =
    Stack.top s.stack

  let clear s =
    s.length <- 0;
    Stack.clear s.stack

  let copy s = { length = s.length;
                 stack = Stack.copy s.stack; }

  let is_empty s =
    Stack.is_empty s.stack

  let length s = s.length

  let iter f s =
    Stack.iter f s.stack

end

(************************************************************************)

let absoluteFilename (fname: string) =
  if Filename.is_relative fname then
    Filename.concat (Sys.getcwd ()) fname
  else
    fname


(* mapNoCopy is like map but avoid copying the list if the function does not
 * change the elements. *)
let rec mapNoCopy (f: 'a -> 'a) = function
    [] -> []
  | (i :: resti) as li ->
      let i' = f i in
      let resti' = mapNoCopy f resti in
      if i' != i || resti' != resti then i' :: resti' else li

let rec mapNoCopyList (f: 'a -> 'a list) = function
    [] -> []
  | (i :: resti) as li ->
      let il' = f i in
      let resti' = mapNoCopyList f resti in
      match il' with
        [i'] when i' == i && resti' == resti -> li
      | _ -> il' @ resti'


(* Use a filter function that does not rewrite the list unless necessary *)
let rec filterNoCopy (f: 'a -> bool) (l: 'a list) : 'a list =
  match l with
    [] -> []
  | h :: rest when not (f h) -> filterNoCopy f rest
  | h :: rest ->
      let rest' = filterNoCopy f rest in
      if rest == rest' then l else h :: rest'


(************************************************************************

 Configuration

 ************************************************************************)
(** The configuration data can be of several types **)
type configData =
    ConfInt of int
  | ConfBool of bool
  | ConfFloat of float
  | ConfString of string
  | ConfList of configData list


(* Store here window configuration file *)
let configurationData: (string, configData) H.t = H.create 13

let clearConfiguration () = H.clear configurationData

let setConfiguration (key: string) (c: configData) =
  H.replace configurationData key c

let findConfiguration (key: string) : configData =
  H.find configurationData key

let findConfigurationInt (key: string) : int =
  match findConfiguration key with
    ConfInt i -> i
  | _ ->
      ignore (E.warn "Configuration %s is not an integer" key);
      raise Not_found

let useConfigurationInt (key: string) (f: int -> unit) =
  try f (findConfigurationInt key)
  with Not_found -> ()

let findConfigurationString (key: string) : string =
  match findConfiguration key with
    ConfString s -> s
  | _ ->
      ignore (E.warn "Configuration %s is not a string" key);
      raise Not_found

let useConfigurationString (key: string) (f: string -> unit) =
  try f (findConfigurationString key)
  with Not_found -> ()


let findConfigurationBool (key: string) : bool =
  match findConfiguration key with
    ConfBool b -> b
  | _ ->
      ignore (E.warn "Configuration %s is not a boolean" key);
      raise Not_found

let useConfigurationBool (key: string) (f: bool -> unit) =
  try f (findConfigurationBool key)
  with Not_found -> ()

let findConfigurationList (key: string) : configData list  =
  match findConfiguration key with
    ConfList l -> l
  | _ ->
      ignore (E.warn "Configuration %s is not a list" key);
      raise Not_found

let useConfigurationList (key: string) (f: configData list -> unit) =
  try f (findConfigurationList key)
  with Not_found -> ()


let saveConfiguration (fname: string) =
  (** Convert configuration data to a string, for saving externally *)
  let configToString (c: configData) : string =
    let buff = Buffer.create 80 in
    let rec loop (c: configData) : unit =
      match c with
        ConfInt i ->
          Buffer.add_char buff 'i';
          Buffer.add_string buff (string_of_int i);
          Buffer.add_char buff ';'

      | ConfBool b ->
          Buffer.add_char buff 'b';
          Buffer.add_string buff (string_of_bool b);
          Buffer.add_char buff ';'

      | ConfFloat f ->
          Buffer.add_char buff 'f';
          Buffer.add_string buff (string_of_float f);
          Buffer.add_char buff ';'

      | ConfString s ->
          if String.contains s '"' then
            E.s (E.unimp "Guilib: configuration string contains quotes");
          Buffer.add_char buff '"';
          Buffer.add_string buff s;
          Buffer.add_char buff '"'; (* '"' *)

      | ConfList l ->
          Buffer.add_char buff '[';
          List.iter loop l;
          Buffer.add_char buff ']'
    in
    loop c;
    Buffer.contents buff
  in
  try
    let oc = open_out fname in
    ignore (E.log "Saving configuration to %s\n" (absoluteFilename fname));
    H.iter (fun k c ->
      output_string oc (k ^ "\n");
      output_string oc ((configToString c) ^ "\n"))
      configurationData;
    close_out oc
  with _ ->
    ignore (E.warn "Cannot open configuration file %s\n" fname)


(** Make some regular expressions early *)
let intRegexp = Str.regexp "i\\([0-9]+\\);"
let floatRegexp = Str.regexp "f\\([0-9]+\\.[0-9]+\\);"
let boolRegexp = Str.regexp "b\\(\\(true\\)\\|\\(false\\)\\);"
let stringRegexp = Str.regexp "\"\\([^\"]*\\)\""

let loadConfiguration (fname: string) : unit =
  H.clear configurationData;

  let stringToConfig (s: string) : configData =
    let idx = ref 0 in (** the current index *)
    let l = String.length s in

    let rec getOne () : configData =
      if !idx >= l then raise Not_found;

      if Str.string_match intRegexp s !idx then begin
        idx := Str.match_end ();
        ConfInt (int_of_string (Str.matched_group 1 s))
      end else if Str.string_match floatRegexp s !idx then begin
        idx := Str.match_end ();
        ConfFloat (float_of_string (Str.matched_group 1 s))
      end else if Str.string_match boolRegexp s !idx then begin
        idx := Str.match_end ();
        ConfBool (bool_of_string (Str.matched_group 1 s))
      end else if  Str.string_match stringRegexp s !idx then begin
        idx := Str.match_end ();
        ConfString (Str.matched_group 1 s)
      end else if String.get s !idx = '[' then begin
        (* We are starting a list *)
        incr idx;
        let rec loop (acc: configData list) : configData list =
          if !idx >= l then begin
            ignore (E.warn "Non-terminated list in configuration %s" s);
            raise Not_found
          end;
          if String.get s !idx = ']' then begin
            incr idx;
            List.rev acc
          end else
            loop (getOne () :: acc)
        in
        ConfList (loop [])
      end else begin
        ignore (E.warn "Bad configuration element in a list: %s\n"
                  (String.sub s !idx (l - !idx)));
        raise Not_found
      end
    in
    getOne ()
  in
  (try
    let ic = open_in fname in
    ignore (E.log "Loading configuration from %s\n" (absoluteFilename fname));
    (try
      while true do
        let k = input_line ic in
        let s = input_line ic in
        try
          let c = stringToConfig s in
          setConfiguration k c
        with Not_found -> ()
      done
    with End_of_file -> ());
    close_in ic;
  with _ -> () (* no file, ignore *));

  ()



(************************************************************************)

(*********************************************************************)
type symbol = int

(**{ Registering symbol names} *)
let registeredSymbolNames: (string, symbol) H.t = H.create 113
let symbolNames: string IH.t = IH.create 113
let nextSymbolId = ref 0

let registerSymbolName (n: string) : symbol =
  try H.find registeredSymbolNames n
  with Not_found -> begin
    let id = !nextSymbolId in
    incr nextSymbolId;
    H.add registeredSymbolNames n id;
    IH.add symbolNames id n;
    id
  end

(** Register a range of symbols. The mkname function will be invoked for
 * indices starting at 0 *)
let registerSymbolRange (count: int) (mkname: int -> string) : symbol =
  if count < 0 then E.s (E.bug "registerSymbolRange: invalid counter");
  let first = !nextSymbolId in
  for i = 0 to count - 1 do
    ignore (registerSymbolName (mkname i))
  done;
  first

let symbolName (id: symbol) : string =
  try IH.find symbolNames id
  with Not_found ->
    ignore (E.warn "Cannot find the name of symbol %d" id);
    "pseudo" ^ string_of_int id


