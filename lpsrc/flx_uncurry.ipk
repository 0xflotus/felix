@head(1,"uncurry gen")
@h = tangler("src/compiler/flxlib/flx_uncurry.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_call

val uncurry_gen:
  sym_state_t ->
  (bid_t, bid_t list) Hashtbl.t *
  fully_bound_symbol_table_t ->
  int (* number of new functions made *)
 
@h = tangler("src/compiler/flxlib/flx_uncurry.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child
open Flx_reparent
open Flx_spexes
open Flx_foldvars


let hfind msg h k = 
  try Hashtbl.find h k
  with Not_found ->
    print_endline ("flx_inline Hashtbl.find failed " ^ msg);
    raise Not_found

let rec vs_is_ts vs ts =  match vs,ts with
  | (_,i)::vt,(`BTYP_var (j,`BTYP_type 0))::tt when i = j -> vs_is_ts vt tt
  | [],[] -> true
  | _ -> false

let id x = x 

let find_uncurry_expr syms bbdfns uncurry_map vs e = 
  let aux e = match e with 
  | `BEXPR_apply
    (
      (
        `BEXPR_apply 
        (
          (`BEXPR_closure (f,ts),_),
          ((a_e,a_t) as a)
        ),
        t
      ),
      ((b_e,b_t) as b)
    ),ret
    when Hashtbl.mem uncurry_map f && vs_is_ts vs ts ->
    let c,k,n = Hashtbl.find uncurry_map f in
    Hashtbl.replace uncurry_map f (c,k,n+1)

  | x -> ()
  in iter_tbexpr ignore aux ignore e

let find_uncurry_exe syms bbdfns uncurry_map vs exe = 
  begin match exe with
  | `BEXE_call 
    (
      sr,
      (
        `BEXPR_apply 
        (
          (`BEXPR_closure (f,ts),_),
          ((a_e,a_t) as a)
        ),
        t
      ),
      ((b_e,b_t) as b)
    )
    when Hashtbl.mem uncurry_map f && vs_is_ts vs ts ->
    let c,k,n = Hashtbl.find uncurry_map f in
    Hashtbl.replace uncurry_map f (c,k,n+1)
  | x -> ()
  end
  ;
  iter_bexe ignore (find_uncurry_expr syms bbdfns uncurry_map vs) ignore ignore ignore exe

let find_uncurry_exes syms bbdfns uncurry_map vs exes = 
  iter (find_uncurry_exe syms bbdfns uncurry_map vs) exes

let get_ps bbdfns f = 
  match hfind "get_ps" bbdfns f with
  | _,_,_,`BBDCL_function (_,_,(ps,_),_,_) 
  | _,_,_,`BBDCL_procedure (_,_,(ps,_),_) -> ps
  | _ -> assert false

let unpack syms ps a : tbexpr_t list = 
  match ps with
  | [] -> []   (* arg should be unit *)
  | [_] -> [a] (* one param, one arg *)
  | _ ->       (* multiple params *)
  match a with
  | `BEXPR_tuple ls,`BTYP_tuple ts ->
    assert (length ts = length ps);
    assert (length ls = length ts);
    ls

  | `BEXPR_tuple ls,`BTYP_array (t,`BTYP_unitsum k) ->
    assert (k = length ps);
    assert (length ls = k);
    ls

  | x,`BTYP_tuple ts ->
    assert (length ts = length ps);
    let xs = map (fun i -> `BEXPR_get_n (i,a)) (nlist (length ts)) in
    combine xs ts

  | x,`BTYP_array (t,`BTYP_unitsum k) ->
    assert (k = length ps);
    map (fun i -> `BEXPR_get_n (i,a),t) (nlist k)

  | x,t -> 
    print_endline ("Unexpected non tuple type " ^ sbt syms.dfns t);
    assert false (* argument isn't a tuple type! *)

let merge_args syms bbdfns f c a b =
  let psf = get_ps bbdfns f in
  let psc = get_ps bbdfns c in
  let args = unpack syms psf a @ unpack syms psc b in
  match args with
  | [x] -> x
  | _ -> `BEXPR_tuple args,`BTYP_tuple (map snd args)

let uncurry_expr syms bbdfns uncurry_map vs e = 
  let rec aux e = match map_tbexpr id aux id e with
  | `BEXPR_apply
    (
      (
        `BEXPR_apply 
        (
          (`BEXPR_closure (f,ts),_),
          ((a_e,a_t) as a)
        ),
        t
      ),
      ((b_e,b_t) as b)
    ),ret
    when Hashtbl.mem uncurry_map f && vs_is_ts vs ts ->
    let e = 
      let c,k,n = Hashtbl.find uncurry_map f in
      Hashtbl.replace uncurry_map f (c,k,n+1);
      let ab = merge_args syms bbdfns f c a b in
      `BEXPR_apply ((`BEXPR_closure (k,ts),t),ab),ret
    in aux e
  | x -> x
  in aux e

let uncurry_exe syms bbdfns uncurry_map vs exe = 
  let exe = match exe with
  | `BEXE_call 
    (
      sr,
      (
        `BEXPR_apply 
        (
          (`BEXPR_closure (f,ts),_),
          ((a_e,a_t) as a)
        ),
        t
      ),
      ((b_e,b_t) as b)
    )
    when Hashtbl.mem uncurry_map f && vs_is_ts vs ts ->
    let c,k,n = Hashtbl.find uncurry_map f in
    Hashtbl.replace uncurry_map f (c,k,n+1);
    let ab = merge_args syms bbdfns f c a b in
    `BEXE_call (sr,(`BEXPR_closure (k,ts),t),ab)
  | x -> x 
  in
  map_bexe id (uncurry_expr syms bbdfns uncurry_map vs) id id id exe

let uncurry_exes syms bbdfns uncurry_map vs exes = map (uncurry_exe syms bbdfns uncurry_map vs) exes

let uncurry_gen syms (child_map,(bbdfns: fully_bound_symbol_table_t)) : int =
  let ut = Hashtbl.create 97 in (* dummy usage table *)
  let vm = Hashtbl.create 97 in (* dummy varmap *)
  let rl = Hashtbl.create 97 in (* dummy relabel *)
  let uncurry_map = Hashtbl.create 97 in

  (* make the uncurry map *)
  Hashtbl.iter
  (fun i (id,parent,sr,bbdcl) -> match bbdcl with
  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    begin match exes with  
    | [`BEXE_fun_return (sr2,(`BEXPR_closure (f,ts),_))] 
      when is_child child_map i f && vs_is_ts vs ts
      ->
      let k = !(syms.counter) in incr (syms.counter);
      Hashtbl.add uncurry_map i (f,k,0);
      if syms.compiler_options.print_flag then
      print_endline ("Detected curried function " ^ id ^ "<" ^ si i ^"> ret child= " ^ si f ^ " synth= " ^ si k)

    | _ -> ()
    end

  | _ -> ()
  )
  bbdfns
  ;

  (* count curried calls to these functions *)
  Hashtbl.iter
  (fun i (id,parent,sr,bbdcl) -> match bbdcl with
  | `BBDCL_procedure (props,vs,(ps,traint),exes) ->
    find_uncurry_exes syms bbdfns uncurry_map vs exes

  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    find_uncurry_exes syms bbdfns uncurry_map vs exes
  | _ -> ()
  )
  bbdfns
  ;

  if syms.compiler_options.print_flag then
  Hashtbl.iter
  (fun i (c,k,n) ->
     print_endline ("MAYBE UNCURRY: Orig " ^ si i ^ " ret child " ^ si c ^ " synth " ^ si k ^ " count=" ^ si n);
  )
  uncurry_map
  ;

  (* make a list of the ones actually called in curried form *)
  let to_uncurry = ref [] in
  Hashtbl.iter 
  (fun i (_,_,n) -> 
    if n > 0 then to_uncurry := i :: !to_uncurry
  ) 
  uncurry_map
  ;

  (* remove any function which is an ancestor of any other:
     keep the children (arbitrary choice)
  *)
  let isnot_asc adult = 
    fold_left 
    (fun acc child -> acc && not (Flx_child.is_ancestor bbdfns child adult))
    true !to_uncurry
  in

  let to_uncurry = filter isnot_asc (!to_uncurry) in

  let nu_uncurry_map = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i j -> 
    if mem i to_uncurry 
    then begin 
      Hashtbl.add nu_uncurry_map i j
      (*
      ; 
      print_endline ("Keeping " ^ si i)
      *)
    end else begin
      (*
      print_endline ("Discarding (ancestor) " ^ si i)
      *)
    end
  )
  uncurry_map;

  let uncurry_map = nu_uncurry_map in

  if syms.compiler_options.print_flag then
  Hashtbl.iter
  (fun i (c,k,n) ->
     print_endline ("ACTUALLY UNCURRY: Orig " ^ si i ^ " ret child " ^ si c ^ " synth " ^ si k ^ " count=" ^ si n);
  )
  uncurry_map
  ;


  (* synthesise the new functions *)
  let nufuns = ref 0 in
  Hashtbl.iter
  (fun i (c,k,n) -> 
    begin
      incr nufuns;
      if syms.compiler_options.print_flag then
      print_endline ("UNCURRY: Orig " ^ si i ^ " ret child " ^ si c ^ " synth " ^ si k ^ " count=" ^ si n);
      let idm,parent,sr,bbdcl = Hashtbl.find bbdfns i in
      let idc,parentc,src,bbdclc = Hashtbl.find bbdfns c in
      assert (parentc = Some i);
      let props, vs, ps, traint, ret, exes = 
        match bbdcl with
        | `BBDCL_function (props,vs,(ps,traint),ret,exes) -> props, vs, ps, traint, ret, exes 
        | _ -> assert false
      in
      let fixup vsc psc exesc =
        assert (vs = vsc);
        let extras = map (fun {pindex=i}->i) ps in
        let revariable =
          Flx_reparent.reparent_children syms 
          (ut,child_map,bbdfns) 
          vs (length vsc) 
          c (Some k) rl vm true extras
        in
        let revar i = try Hashtbl.find revariable i with Not_found -> i in

        iter 
          (fun {pkind=pk; ptyp=t; pid=s; pindex=pi} -> 
            let n = revar pi in
            let bbdcl = match pk with
            | `PVal -> `BBDCL_val (vs,t)
            | `PVar -> `BBDCL_var (vs,t)
            | _ -> failwith "Unimplemented curried fun param not var or val"
            in
            if syms.compiler_options.print_flag then
            print_endline ("New param " ^ s ^ " " ^ si n ^ " <-- " ^ si pi ^ ", parent " ^ si k ^ " <-- " ^ si i);
            Hashtbl.add bbdfns n (s ^ "_uncurry",Some k,sr,bbdcl);
            Flx_child.add_child child_map k n
          ) 
          ps 
        ;

        begin
          iter (fun ({pid=s; pindex=i} as p) -> assert (i <> revar i)) (ps @ psc);
        end;

        let ps = map (fun ({pid=s; pindex=i} as p) -> {p with pid=s^"_uncurry"; pindex = revar i}) ps in
        let psc = map (fun ({pindex=i} as p) -> {p with pindex = revar i}) psc in
        let ps = ps @ psc in
        let rec revare e = map_tbexpr revar revare id e in
        let exes = map (fun exe -> map_bexe revar revare id id id exe) exesc in
        begin match parent with
        | Some p -> Flx_child.add_child child_map p k
        | None -> ()
        end
        ;
        ps,exes
      in
      match bbdclc with
      | `BBDCL_function (propsc,vsc,(psc,traintc),retc,exesc) ->
        let ps,exes = fixup vsc psc exesc in
        let bbdcl = `BBDCL_function (propsc,vs,(ps,traintc), retc, exes) in
        Hashtbl.add bbdfns k (idm^"_uncurry",parent,sr,bbdcl)

      | `BBDCL_procedure (propsc,vsc,(psc,traintc),exesc) ->
        let ps,exes = fixup vsc psc exesc in
        let bbdcl = `BBDCL_procedure (propsc,vs,(ps,traintc), exes) in
        Hashtbl.add bbdfns k (idm^"_uncurry",parent,sr,bbdcl)

      | _ -> assert false
    end
  )
  uncurry_map
  ;
  (* replace calls *)
  Hashtbl.iter
  (fun i (id,parent,sr,bbdcl) -> match bbdcl with
  | `BBDCL_procedure (props,vs,(ps,traint),exes) ->
    let exes = uncurry_exes syms bbdfns uncurry_map vs exes in
    Hashtbl.replace bbdfns i 
      (id,parent,sr,`BBDCL_procedure (props,vs,(ps,traint),exes))

  | `BBDCL_function (props,vs,(ps,traint),ret,exes) ->
    let exes = uncurry_exes syms bbdfns uncurry_map vs exes in
    Hashtbl.replace bbdfns i 
      (id,parent,sr,`BBDCL_function (props,vs,(ps,traint),ret,exes))
  | _ -> ()
  )
  bbdfns
  ;

  !nufuns

