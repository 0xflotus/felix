@execfile("flxbuild"+os.sep+"iscrutil.py")

@env = setup_test('test/pthread/pthread-')

@head(1,'pthread')

@execfile('config'+os.sep+'config.py')
@h = tangler('config/flx_pthread.fpc')
@select(h)
Name: pthread
Description: Pre-emptive threading support
Version: $Id$

@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_pthread_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_pthread_static")
 elif WIN32:
   tangle("provides_dlib: -lflx_pthread_dynamic")
   tangle("provides_slib: -lflx_pthread_static")
 else:
   tangle("provides_dlib: -lflx_pthread_dynamic")
   tangle("provides_slib: -lflx_pthread_static")
 if PTHREAD_SWITCH:
   tangle("requires_dlibs: "+PTHREAD_SWITCH)
   tangle("requires_slibs: "+PTHREAD_SWITCH)

Requires: flx_gc

@h = tangler('spkgs/flx_pthread.py')
@select(h)

PTHREADRTL_INTERFACES = [
  'src/pthread/pthread_thread.hpp',               # portable
  'src/pthread/pthread_win_posix_condv_emul.hpp', # win32 and posix
  'src/pthread/pthread_mutex.hpp',                # portable
  'src/pthread/pthread_counter.hpp',              # portable
  'src/pthread/pthread_waitable_bool.hpp',        # portable
  'src/pthread/pthread_condv.hpp',                # portable
  'src/pthread/pthread_semaphore.hpp',            # portable
  'src/pthread/pthread_monitor.hpp',              # portable
  'src/pthread/pthread_sleep_queue.hpp',          # portable
  'src/pthread/pthread_work_fifo.hpp',            # portable
]

PTHREAD_CPPS = [
  "src/pthread/pthread_win_posix_condv_emul", # portability hackery
  "src/pthread/pthread_mutex", 
  "src/pthread/pthread_condv",
  "src/pthread/pthread_counter",
  "src/pthread/pthread_waitable_bool",
  "src/pthread/pthread_semaphore",
  "src/pthread/pthread_monitor",
  "src/pthread/pthread_sleep_queue",
  "src/pthread/pthread_work_fifo",
  "src/pthread/pthread_thread_control",
]

POSIX_PTHREAD_CPPS = [
  'src/pthread/pthread_posix_thread', 
]

LINUX_PTHREAD_CPPS = [
]

SOLARIS_PTHREAD_CPPS = [
]

WINDOWS_PTHREAD_CPPS = [
  'src/pthread/pthread_win_thread', 
]

BSD_PTHREAD_CPPS = [
]

EXTRA_SYS_LIBS = ""
if WIN32:
  PTHREAD_CPPS = PTHREAD_CPPS + WINDOWS_PTHREAD_CPPS

if POSIX:
  PTHREAD_CPPS = PTHREAD_CPPS + POSIX_PTHREAD_CPPS

if LINUX:
  PTHREAD_CPPS = PTHREAD_CPPS + LINUX_PTHREAD_CPPS

if BSD or MACOSX:
  PTHREAD_CPPS = PTHREAD_CPPS + BSD_PTHREAD_CPPS

if SOLARIS:
  PTHREAD_CPPS = PTHREAD_CPPS + SOLARIS_PTHREAD_CPPS
  EXTRA_SYS_LIBS = "-lrt " # man sem_wait

@tangle('completion_tests = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')

cpp_cpps = PTHREAD_CPPS
rtl_interfaces = PTHREADRTL_INTERFACES
lib_requires = ['libflx_exceptions']
dflags = EXTRA_SYS_LIBS
sflags = EXTRA_SYS_LIBS
pkg_requires = ['flx_exceptions','flx_rtl_config'] 
iscr_source = ["lpsrc/flx_pthread.pak"]
build_macro = "PTHREAD"
weaver_directory = 'doc/rtl/flx_pthread/'
tmpdir = ['pthread']
xfiles= [
  'src/pthread/pthread_condv.cpp',
  'src/pthread/pthread_condv.hpp',
  'src/pthread/pthread_counter.cpp',
  'src/pthread/pthread_counter.hpp',
  'src/pthread/pthread_monitor.cpp',
  'src/pthread/pthread_monitor.hpp',
  'src/pthread/pthread_mutex.cpp',
  'src/pthread/pthread_mutex.hpp',
  'src/pthread/pthread_posix_thread.cpp',
  'src/pthread/pthread_semaphore.cpp',
  'src/pthread/pthread_semaphore.hpp',
  'src/pthread/pthread_sleep_queue.cpp',
  'src/pthread/pthread_sleep_queue.hpp',
  'src/pthread/pthread_thread.hpp',
  'src/pthread/pthread_thread_control.cpp',
  'src/pthread/pthread_waitable_bool.cpp',
  'src/pthread/pthread_waitable_bool.hpp',
  'src/pthread/pthread_win_posix_condv_emul.cpp',
  'src/pthread/pthread_win_posix_condv_emul.hpp',
  'src/pthread/pthread_win_thread.cpp',
  'src/pthread/pthread_work_fifo.cpp',
  'src/pthread/pthread_work_fifo.hpp',
  ]

@h=tangler('pthread/target/flx_pthread_config.hpp')
@select(h)
#ifndef __FLX_PTHREAD_CONFIG_H__
#define __FLX_PTHREAD_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_PTHREAD
#define PTHREAD_EXTERN FLX_EXPORT
#else
#define PTHREAD_EXTERN FLX_IMPORT
#endif
#endif

@head(1,"Pre-emptive threads (pthread)")
Note WE say pthread means 'pre-emptive thread' not
merely Posix thread. Confusing on Solaris especially.
However it fits with name fthread for felix threads
which are actually s- (synchronous) or np- (non-preemptive) 
threads.

@h=tangler('lib/pthread.flx')
@select(h)
#import <flx.flxh>

header pthread_hxx = '#include "pthread_thread.hpp"';
header mutex_hxx = '#include "pthread_mutex.hpp"';
header condv_hxx = '#include "pthread_condv.hpp"';
header counter_hxx = '#include "pthread_counter.hpp"';
header semaphore_hxx = '#include "pthread_semaphore.hpp"';
header monitor_hxx = '#include "pthread_monitor.hpp"';
header work_fifo_hxx = '#include "pthread_work_fifo.hpp"';

publish """
This module provides access to the operating system's native
threading routines. On systems with multiple cpus, this may
increase performance as the operating system may schedule
threads on different processors.
"""
module Pthread
{
  requires package "flx_pthread";
  open C_hack;

  type job_queue = "flx::pthread::worker_fifo*" requires work_fifo_hxx;

  gen mk_job_queue: int * int -> job_queue = "new flx::pthread::worker_fifo($1,$2)";
  
  proc spawn_pthread(p:1->0)
  {
      var con = start p;              // get continuation of p
      var fthr = mk_thread con;
      svc$ svc_spawn_pthread fthr;
  }

  type mutex = "flx::pthread::flx_mutex_t" requires mutex_hxx;
  proc lock: lvalue[mutex] = "$1.lock();";
  proc unlock: lvalue[mutex] = "$1.unlock();";
  proc lock (m:&mutex) { lock$ *m; }
  proc unlock (m:&mutex) { unlock$ *m; }

  // pre-emptive thread channels (monitor)
  type pchannel[t] = "flx::pthread::monitor_t*" requires monitor_hxx;

  fun mk_pchannel[t]: 1->pchannel[t] = 
    "new flx::pthread::monitor_t()"
  ;

  // NOTE: read/write on pchannels uses suspend/resume
  // to tell any pending collector it is safe to proceed
  // whilst it is doing the I/O (which may block),
  // to block returning from the I/O during a collection
  // AND, if the I/O completed before the collection got
  // going, to yield at this point. 

  proc _read[t]: pchannel[t] * ptr[ptr[t]] = """
    {
    FLX_SAVE_REGS;
    PTF gcp->collector->get_thread_control()->suspend();
    //fprintf(stderr,"READ:DQ\\n");
    *$2 = (?1*)($1->dequeue());
    //fprintf(stderr,"DONE READ:DQ\\n");
    PTF gcp->collector->get_thread_control()->resume();
    }
  """;

  gen read[t] (chan:pchannel[t]) = {
    var p : ptr[t];
    _read (chan, addr p);
    return *p;
  }

  proc _write[t]: pchannel[t] * ptr[t] = """
    {
    FLX_SAVE_REGS;
    PTF gcp->collector->get_thread_control()->suspend();
    //fprintf(stderr,"WRITE:NQ\\n");
    $1->enqueue((void*)$2);
    //fprintf(stderr,"DONE WRITE:NQ\\n");
    PTF gcp->collector->get_thread_control()->resume();
    }
  """;

  proc write[t](chan:pchannel[t], v:t) {
    var ps = cast[ptr[t]]$ xnew v;
    _write (chan,ps);
  }
}

@env.head(1,'pthread tests')
@env.head(2)
@select(env.test('.flx'))
#import <flx.flxh>
include "flx_faio";
include "pthread";
open Pthread;

print "Pthread spawning test"; endl;

proc thr (x:int) { print "Thread "; print x; endl; }

proc flx_main
{
  print "Running main\n";
  var chan = mk_pchannel[int]();
  var dummy: int;

  spawn_pthread { thr 1; write (chan,1); };
  spawn_pthread { thr 2; write (chan,2); };
  spawn_pthread { thr 3; write (chan,3); };
  spawn_pthread { thr 4; write (chan,4); };
  spawn_pthread { thr 5; write (chan,5); };
  spawn_pthread { thr 6; write (chan,6); };
  spawn_pthread { thr 7; write (chan,7); };
  print "Spawned\n";
  dummy = read chan; // 1
  print "joined "; print dummy; endl;
  dummy = read chan; // 2
  print "joined "; print dummy; endl;
  dummy = read chan; // 3
  print "joined "; print dummy; endl;
  dummy = read chan; // 4
  print "joined "; print dummy; endl;
  dummy = read chan; // 5
  print "joined "; print dummy; endl;
  dummy = read chan; // 6
  print "joined "; print dummy; endl;
  dummy = read chan; // 7
  print "joined "; print dummy; endl;
  print "Joined all\n";
}

export proc flx_main of (1) as "flx_main";
@doc()

@env.head(2)
@select(env.test('.flx'))
#import <flx.flxh>
include "pthread";
include "flx_faio";
open String;

print "Garbage collector world stop test"; endl;

var clock = Faio::mk_alarm_clock();

proc randprint(n:int)
{
  var i = 5;
  print$ "Start Thread number "+str(n); endl;
  whilst i > 0 do
    var d = double_of$ Cstdlib::rand()%10;
    if d == 0.0 do
      print "ZERO FOUND -- collecting!"; endl;
      collect;
      print "collected!"; endl;
    done;
    print$ "Thread "+str n +" Sleep #"+str i+" for "+str d+" sec"; endl;
    --i;
    Faio::sleep (clock,d);
  done; 
  print$ "Finish Thread number "+str(n); endl;
}

Pthread::spawn_pthread { randprint(1); };
Pthread::spawn_pthread { randprint(2); };
Pthread::spawn_pthread { randprint(3); };
Pthread::spawn_pthread { randprint(4); };
Pthread::spawn_pthread { randprint(5); };

print "Mainline done!"; endl;
@doc()
