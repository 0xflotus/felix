@import config
@from flxbuild.iscrutil import setup_test
@from flxbuild.flxutil import unix2native

@env = setup_test(get_input_frame(), 'test/pthread/pthread-')

@head(1,'pthread')

@h = tangler('config/flx_pthread.fpc')
@select(h)
Name: pthread
Description: Pre-emptive threading support
Version: $Id$

@if config.HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_pthread_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_pthread_static")
 elif config.WIN32:
   tangle("provides_dlib: -lflx_pthread_dynamic")
   tangle("provides_slib: -lflx_pthread_static")
 else:
   tangle("provides_dlib: -lflx_pthread_dynamic")
   tangle("provides_slib: -lflx_pthread_static")
 if config.PTHREAD_SWITCH:
   tangle("requires_dlibs: "+config.PTHREAD_SWITCH)
   tangle("requires_slibs: "+config.PTHREAD_SWITCH)

includes: "pthread_thread.hpp"
Requires: flx_gc

@h = tangler('spkgs/flx_pthread.py')
@select(h)
import os
import glob

import config
from flxbuild.flxutil import unix2native

PTHREADRTL_INTERFACES = [
  'src/pthread/pthread_thread.hpp',               # portable
  'src/pthread/pthread_win_posix_condv_emul.hpp', # win32 and posix
  'src/pthread/pthread_mutex.hpp',                # portable
  'src/pthread/pthread_counter.hpp',              # portable
  'src/pthread/pthread_waitable_bool.hpp',        # portable
  'src/pthread/pthread_condv.hpp',                # portable
  'src/pthread/pthread_semaphore.hpp',            # portable
  'src/pthread/pthread_monitor.hpp',              # portable
  'src/pthread/pthread_sleep_queue.hpp',          # portable
  'src/pthread/pthread_work_fifo.hpp',            # portable
]

PTHREAD_CPPS = [
  "src/pthread/pthread_win_posix_condv_emul", # portability hackery
  "src/pthread/pthread_mutex",
  "src/pthread/pthread_condv",
  "src/pthread/pthread_counter",
  "src/pthread/pthread_waitable_bool",
  "src/pthread/pthread_semaphore",
  "src/pthread/pthread_monitor",
  "src/pthread/pthread_sleep_queue",
  "src/pthread/pthread_work_fifo",
  "src/pthread/pthread_thread_control",
]

POSIX_PTHREAD_CPPS = [
  'src/pthread/pthread_posix_thread',
]

LINUX_PTHREAD_CPPS = [
]

SOLARIS_PTHREAD_CPPS = [
]

WINDOWS_PTHREAD_CPPS = [
  'src/pthread/pthread_win_thread',
]

BSD_PTHREAD_CPPS = [
]

EXTRA_SYS_LIBS = ""
if config.WIN32:
  PTHREAD_CPPS = PTHREAD_CPPS + WINDOWS_PTHREAD_CPPS

if config.POSIX:
  PTHREAD_CPPS = PTHREAD_CPPS + POSIX_PTHREAD_CPPS

if config.LINUX:
  PTHREAD_CPPS = PTHREAD_CPPS + LINUX_PTHREAD_CPPS

if config.BSD or config.MACOSX:
  PTHREAD_CPPS = PTHREAD_CPPS + BSD_PTHREAD_CPPS

if config.SOLARIS:
  PTHREAD_CPPS = PTHREAD_CPPS + SOLARIS_PTHREAD_CPPS
  EXTRA_SYS_LIBS = "-lrt " # man sem_wait

@tangle('completion_tests = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')

cpp_cpps = PTHREAD_CPPS
lib_requires = ['libflx_exceptions']
dflags = EXTRA_SYS_LIBS
sflags = EXTRA_SYS_LIBS
build_macro = "PTHREAD"

rtl_interfaces = PTHREADRTL_INTERFACES
felix_rtl = ['src/pthread/pthread.flx']

pkg_requires = ['flx_exceptions','flx_rtl_config']
iscr_source = ["lpsrc/flx_pthread.pak"]
weaver_directory = 'doc/rtl/flx_pthread/'
tmpdir = ['pthread']
xfiles= [os.path.join('src', 'pthread', '*')]

@h=tangler('config/target/flx_pthread_config.hpp')
@select(h)
#ifndef __FLX_PTHREAD_CONFIG_H__
#define __FLX_PTHREAD_CONFIG_H__
#include "flx_rtl_config.hpp"
#ifdef BUILD_PTHREAD
#define PTHREAD_EXTERN FLX_EXPORT
#else
#define PTHREAD_EXTERN FLX_IMPORT
#endif
#endif

@head(1,"Pre-emptive threads (pthread)")
Note WE say pthread means 'pre-emptive thread' not
merely Posix thread. Confusing on Solaris especially.
However it fits with name fthread for felix threads
which are actually s- (synchronous) or np- (non-preemptive)
threads.

@env.head(1,'pthread tests')
@env.head(2)
@select(env.test('.flx'))
#import <flx.flxh>
include "flx_faio";
include "pthread";
open Pthread;

print "Pthread spawning test"; endl;

proc thr (x:int) { print "Thread "; print x; endl; }

proc flx_main
{
  print "Running main\n";
  var chan = mk_pchannel[int]();
  var dummy: int;

  spawn_pthread { thr 1; write (chan,1); };
  spawn_pthread { thr 2; write (chan,2); };
  spawn_pthread { thr 3; write (chan,3); };
  spawn_pthread { thr 4; write (chan,4); };
  spawn_pthread { thr 5; write (chan,5); };
  spawn_pthread { thr 6; write (chan,6); };
  spawn_pthread { thr 7; write (chan,7); };
  print "Spawned\n";
  dummy = read chan; // 1
  print "joined "; print dummy; endl;
  dummy = read chan; // 2
  print "joined "; print dummy; endl;
  dummy = read chan; // 3
  print "joined "; print dummy; endl;
  dummy = read chan; // 4
  print "joined "; print dummy; endl;
  dummy = read chan; // 5
  print "joined "; print dummy; endl;
  dummy = read chan; // 6
  print "joined "; print dummy; endl;
  dummy = read chan; // 7
  print "joined "; print dummy; endl;
  print "Joined all\n";
}

export proc flx_main of (1) as "flx_main";
@doc()

@env.head(2)
@select(env.test('.flx'))
#import <flx.flxh>
include "pthread";
include "flx_faio";
open String;

print "Garbage collector world stop test"; endl;

var clock = Faio::mk_alarm_clock();

proc randprint(n:int)
{
  var i = 5;
  print$ "Start Thread number "+str(n); endl;
  whilst i > 0 do
    var d = double_of$ Cstdlib::rand()%10;
    if d == 0.0 do
      print "ZERO FOUND -- collecting!"; endl;
      collect;
      print "collected!"; endl;
    done;
    print$ "Thread "+str n +" Sleep #"+str i+" for "+str d+" sec"; endl;
    --i;
    Faio::sleep (clock,d);
  done;
  print$ "Finish Thread number "+str(n); endl;
}

Pthread::spawn_pthread { randprint(1); };
Pthread::spawn_pthread { randprint(2); };
Pthread::spawn_pthread { randprint(3); };
Pthread::spawn_pthread { randprint(4); };
Pthread::spawn_pthread { randprint(5); };

print "Mainline done!"; endl;
@doc()
