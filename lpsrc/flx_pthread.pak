@head(1,'pthread')
$Log$
Revision 1.32  2006/07/17 01:14:27  skaller
Change the way pthread switch is handled to conform to
normal packaging system (instead of weird special case),
should fix solaris problem.

Revision 1.31  2006/07/16 20:53:57  skaller
Modify thread creation error to include the error code.

Revision 1.30  2006/07/16 20:18:06  skaller
Abort program if worker_fifo::start_worker_thread fails.
To be fixed later to something possibly saner.

Revision 1.29  2006/07/16 10:14:36  rfistman
added some printfs to diagnose thread creation probs

Revision 1.28  2006/07/05 07:36:42  skaller
Fiddles to speed test

Revision 1.27  2006/06/26 10:18:13  rfistman

fixed a few typos "provide_lib" -> "provides_lib". this was stopping
 things building in the right order (e.g. libflx being built after
 the code that needed it).

Revision 1.26  2006/06/24 11:49:49  skaller
Fix dependencies on flx_gc for Cygwin.

Revision 1.25  2006/05/07 08:08:04  idadesub
actually, this test cannot be checked yet, as it's non-deterministic

Revision 1.24  2006/05/07 07:19:38  idadesub
adding expected output for test

Revision 1.23  2006/05/03 08:38:54  idadesub
generating more documents.
moved a couple of the rtl felix-specific projects into the flx_ namespace
in order to keep things separate from the docs for other non-felix projects

Revision 1.22  2006/04/25 10:38:42  rfistman
added solaris libs (-lrt for semaphores, -lnsl, -lsocket) missing from some
pkgs and added -lnsl -lsocket to flx_pkgconfig bootstrap, added missing
namespace to evtport demuxer

Revision 1.21  2006/04/18 05:25:45  skaller
Rewrite sleep queue.

Revision 1.20  2006/04/17 08:20:26  skaller
needs assert.h

Revision 1.19  2006/04/17 07:19:59  skaller
Make monitor slightly more efficient

Revision 1.18  2006/04/16 04:49:10  skaller
Maybe fixed monitor to allow for spurious condition variable wait exits.

Revision 1.17  2006/04/15 04:20:05  rfistman
fixed bug in sleep queue in which an empty stack could be popped
thanks to a spurious condition var wakeup. condition var predicates
must be rechecked!

Revision 1.16  2006/04/08 08:18:34  rfistman
fixed up flx_listener, working on portable regression test for tcp
bug still at large in nocygwin flx_accept - hope it's portable!

Revision 1.15  2006/03/15 10:22:59  rfistman
fixing 64bit cl build

Revision 1.14  2006/03/10 15:48:24  skaller
Add pretty printer for C++.

Revision 1.13  2006/03/08 22:30:49  skaller
Add requires package "flx_pthread" to module Pthread

Revision 1.12  2006/03/08 14:51:16  skaller
Tests for pthreads, callbacks.

Revision 1.11  2006/03/08 07:15:54  skaller
Async channels now working

Revision 1.10  2006/03/07 04:22:36  skaller
Termination in presence of spawned pthreads should now
be working, using new ts_locker class. Exception handling
on per thread basis not implemented yet.

Revision 1.9  2006/03/06 13:16:17  skaller
Fix library builds so exports and imports are properly
distinguished on a library by library basis.

Revision 1.8  2006/03/06 03:28:52  skaller
Win32 detached threads (same as joinable ones really)

Revision 1.7  2006/03/06 03:20:11  rfistman
fixed typo in win32 stuff

Revision 1.6  2006/03/06 01:29:29  skaller
spawn_pthread: init works

Revision 1.5  2006/03/05 07:52:41  skaller
Add detached threads, to be used for job queues.

Revision 1.4  2006/03/04 17:29:11  skaller
Polymorphic reductions working!

Revision 1.3  2006/03/02 02:41:39  skaller
Fixes for Win32/MSVC++ build.

Revision 1.2  2006/03/01 13:43:17  skaller
COnfig packages now seem to work on Linux. Added dependency
on libflx to flx_pthread.

Revision 1.1  2006/02/28 02:07:13  skaller
Refactor demux into demux + pthread.

@execfile('config'+os.sep+'config.py')
@h = tangler('config/flx_pthread.fpc')
@select(h)
Name: pthread
Description: Pre-emptive threading support
Version: $Id$

@EXTRA_SYS_LIBS = ""
@if SOLARIS: 
  EXTRA_SYS_LIBS="-lrt"

@if string.strip(PTHREAD_SWITCH):  
  EXTRA_SYS_LIBS = EXTRA_SYS_LIBS + " " +PTHREAD_SWITCH

@if HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_pthread_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_pthread_static")
 else:
   tangle("provides_dlib: -lflx_pthread_dynamic")
   tangle("provides_slib: -lflx_pthread_static")

   if string.strip(EXTRA_SYS_LIBS):
     tangle("requires_dlibs: "+EXTRA_SYS_LIBS)
     tangle("requires_slibs: "+EXTRA_SYS_LIBS)

Requires: flx_gc

@h = tangler('spkgs/flx_pthread.py')
@select(h)

PTHREADRTL_INTERFACES = [
 'pthread/pthread_thread.hpp',        # portable
 'pthread/pthread_win_posix_condv_emul.hpp',         # win32 and posix
 'pthread/pthread_mutex.hpp',         # portable
 'pthread/pthread_counter.hpp',       # portable
 'pthread/pthread_condv.hpp',         # portable
 'pthread/pthread_semaphore.hpp',     # portable
 'pthread/pthread_monitor.hpp',       # portable
 'pthread/pthread_sleep_queue.hpp',   # portable
 'pthread/pthread_work_fifo.hpp',     # portable
]

PTHREAD_CPPS = [
  "pthread/pthread_win_posix_condv_emul", # portability hackery
  "pthread/pthread_mutex", 
  "pthread/pthread_condv",
  "pthread/pthread_counter",
  "pthread/pthread_semaphore",
  "pthread/pthread_monitor",
  "pthread/pthread_sleep_queue",
  "pthread/pthread_work_fifo",
  "rtl/flx_ts_collector",
]

POSIX_PTHREAD_CPPS = [
  'pthread/pthread_posix_thread', 
]

LINUX_PTHREAD_CPPS = [
]

SOLARIS_PTHREAD_CPPS = [
]

WINDOWS_PTHREAD_CPPS = [
  'pthread/pthread_win_thread', 
]

BSD_PTHREAD_CPPS = [
]

EXTRA_SYS_LIBS = ""
if WIN32:
  PTHREAD_CPPS = PTHREAD_CPPS + WINDOWS_PTHREAD_CPPS

if POSIX:
  PTHREAD_CPPS = PTHREAD_CPPS + POSIX_PTHREAD_CPPS

if LINUX:
  PTHREAD_CPPS = PTHREAD_CPPS + LINUX_PTHREAD_CPPS

if BSD or MACOSX:
  PTHREAD_CPPS = PTHREAD_CPPS + BSD_PTHREAD_CPPS

if SOLARIS:
  PTHREAD_CPPS = PTHREAD_CPPS + SOLARIS_PTHREAD_CPPS
  EXTRA_SYS_LIBS = "-lrt " # man sem_wait

if string.strip(PTHREAD_SWITCH):
  EXTRA_SYS_LIBS = EXTRA_SYS_LIBS + " " + PTHREAD_SWITCH

cpp_cpps = PTHREAD_CPPS
rtl_interfaces = PTHREADRTL_INTERFACES
lib_requires = ['libflx_gc']
dflags = EXTRA_SYS_LIBS
sflags = EXTRA_SYS_LIBS
pkg_requires = ['flx_rtl'] # flx_rtl provides flx_rtl_config.hpp
iscr_source = ["lpsrc/flx_pthread.pak"]
build_macro = "PTHREAD"
weaver_directory = 'doc/rtl/flx_pthread/'

@h=tangler('rtl/flx_pthread_config.hpp')
@select(h)
#ifndef __FLX_PTHREAD_CONFIG_GUARD__
#define __FLX_PTHREAD_CONFIG_GUARD__
#include "flx_rtl_config.hpp"
#ifdef BUILD_PTHREAD
#define PTHREAD_EXTERN FLX_EXPORT
#else
#define PTHREAD_EXTERN FLX_IMPORT
#endif
#endif

@head(1,"Pre-emptive threads (pthread)")
Note WE say pthread means 'pre-emptive thread' not
merely Posix thread. Confusing on Solaris especially.
However it fits with name fthread for felix threads
which are actually s- (synchronous) or np- (non-preemptive) 
threads.

@head(2,'Thread')
@h=tangler('pthread/pthread_thread.hpp')
@select(h)
#ifndef __FLX_THREAD__
#define __FLX_THREAD__
#include <flx_pthread_config.hpp>

#ifdef _WIN32
#include <windows.h>
#else
#include <pthread.h>
#endif

// auto pthread, because I forget how to deallocate them nicely
// could init in the constructor, but ultimately you don't want the thread
// barging in before you've finished doing other stuff
// Addendum (20051128): doing stdio in turns out to be not very safe.
// I don't know if printf et al are supposed to be thread safe (most impls
// seem to try to be) but I sometimes get deadlocks in ppc64 os x 10.4.2
// with 4.0.1 when printfing to stdout. Nasty.

namespace flx { namespace pthread {

// ********************************************************
/// Posix Threads. This class simply wraps the creation
/// and joining of threads. It is not safe.
// ********************************************************

class PTHREAD_EXTERN flx_detached_thread_t {
#ifdef _WIN32
  HANDLE    thread;
#else
  pthread_t   thr;        ///< the thread
#endif
  flx_detached_thread_t(flx_detached_thread_t const&); // uncopyable
  void operator=(flx_detached_thread_t const&); // uncopyable
public:
  flx_detached_thread_t();
  ~flx_detached_thread_t();
#ifdef _WIN32
  int init(LPTHREAD_START_ROUTINE, LPVOID lParam);
#else
  int init(void* (*start)(void*), void* udat);
#endif
};

class PTHREAD_EXTERN flx_thread_t {
#ifdef _WIN32
  HANDLE    thread;
#else
  pthread_t   thr;        ///< the thread
#endif
  flx_thread_t(flx_thread_t const&); // uncopyable
  void operator=(flx_thread_t const&); // uncopyable
public:
  flx_thread_t();
  ~flx_thread_t();
#ifdef _WIN32
  int init(LPTHREAD_START_ROUTINE, LPVOID lParam);
#else
  int init(void* (*start)(void*), void* udat);
#endif
  void join();  
};

/// RAII wrapper for thread class
class PTHREAD_EXTERN flx_thread_wrapper_t {
  flx_thread_t thread;
  flx_thread_wrapper_t(flx_thread_wrapper_t const&); // uncopyable
  void operator=(flx_thread_wrapper_t const&); // uncopyable
public:
  ~flx_thread_wrapper_t();
#ifndef _WIN32
  flx_thread_wrapper_t(void* (*start)(void*), void* udat);
#else  
  flx_thread_wrapper_t(LPTHREAD_START_ROUTINE, LPVOID);
#endif
};

}}
#endif

@h=tangler('pthread/pthread_posix_thread.cpp')
@select(h)
#include "pthread_thread.hpp"
#include <stdio.h>
#include <string.h>  // strerror

namespace flx { namespace pthread {

// ---- detached threads ----------

flx_detached_thread_t::flx_detached_thread_t(flx_detached_thread_t const&){} // uncopyable
void flx_detached_thread_t::operator=(flx_detached_thread_t const&){} // uncopyable

int 
flx_detached_thread_t::init(void* (*start)(void*), void* udat)
{
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
  int res = pthread_create(&thr, &attr, start, udat);
  if(res)
  {
     fprintf(stderr, "flx_detached_thread_t: pthread_create_failed [%d]: %s\n",
       res, strerror(res)
     );
  }
  pthread_attr_destroy(&attr);
  return res;
}

flx_detached_thread_t::~flx_detached_thread_t() { }
flx_detached_thread_t::flx_detached_thread_t() { }

// ---- joinable threads ----------
flx_thread_t::flx_thread_t(flx_thread_t const&){} // uncopyable
void flx_thread_t::operator=(flx_thread_t const&){} // uncopyable

int 
flx_thread_t::init(void* (*start)(void*), void* udat)
{
  int res = pthread_create(&thr, NULL, start, udat);
  if(res)
  {
     fprintf(stderr, "flx_thread_t: pthread_create_failed [%d]: %s\n",
       res,strerror(res)
     );
  }
  return res;
}

void flx_thread_t::join() { pthread_join(thr, NULL); }

flx_thread_t::~flx_thread_t() { }
flx_thread_t::flx_thread_t() { }

// ---- joinable thread wrapper ----------

flx_thread_wrapper_t::flx_thread_wrapper_t(flx_thread_wrapper_t const&){} // uncopyable
void flx_thread_wrapper_t::operator=(flx_thread_wrapper_t const&){} // uncopyable

flx_thread_wrapper_t::flx_thread_wrapper_t(void* (*start)(void*), void* udat)
{
  thread.init(start,udat);
}

flx_thread_wrapper_t::~flx_thread_wrapper_t() { thread.join(); }

}}

@h=tangler('pthread/pthread_win_thread.cpp')
@select(h)
#include "pthread_thread.hpp"
#include <stdio.h>

namespace flx { namespace pthread {

// ---- detached threads ----------

flx_detached_thread_t::flx_detached_thread_t(flx_detached_thread_t const&){} // uncopyable
void flx_detached_thread_t::operator=(flx_detached_thread_t const&){} // uncopyable

// returns -1 on failure with error in GetLastError, 0 if all good.
int 
flx_detached_thread_t::init(LPTHREAD_START_ROUTINE fn, LPVOID lParam)
{
  DWORD thread_id = 0;
  thread = (HANDLE)CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)fn, lParam, 0,
    &thread_id);  
  if(!thread)
  {
    DWORD err = GetLastError();
    fprintf(stderr, "flx_detached_thread_t: CreateThread failed: %i\n", err);
    return err;
  }
  return 0;
}

flx_detached_thread_t::~flx_detached_thread_t() { CloseHandle(thread); }
flx_detached_thread_t::flx_detached_thread_t() { }

// ---- joinable threads ----------
flx_thread_t::flx_thread_t(flx_thread_t const&){} // uncopyable
void flx_thread_t::operator=(flx_thread_t const&){} // uncopyable


flx_thread_t::flx_thread_t() { }
flx_thread_t::~flx_thread_t() { }

// this should be idempotent
void
flx_thread_t::join()
{
  // Let's try and wait for the thread to finish, however first I have to
  // tell it to finish up.

  DWORD  wait_res = WaitForSingleObject(thread, INFINITE);

  // will this give me my return status? how do I get that?
  if(WAIT_FAILED == wait_res)
  {
    fprintf(stderr,"thread wait failed (%li)\n", GetLastError());
  }

  // I've already tried waiting on the  thread's exit
  if(!CloseHandle(thread))
  {
    fprintf(stderr,"failed to delete thread (%li)\n", GetLastError());
  }
}

// returns -1 on failure with error in GetLastError, 0 if all good.
int
flx_thread_t::init(LPTHREAD_START_ROUTINE fn, LPVOID lParam)
{
  DWORD thread_id = 0;
  thread = (HANDLE)CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)fn, lParam, 0,
    &thread_id);  

  if(!thread)
  {
    DWORD err = GetLastError();
    fprintf(stderr, "flx_thread_t: CreateThread failed: %i\n", err);
    return err;
  }

  return 0;
}

// ---- joinable thread wrapper ----------
flx_thread_wrapper_t::flx_thread_wrapper_t(LPTHREAD_START_ROUTINE f, LPVOID lParam)
{
  thread.init(f,lParam);
}
flx_thread_wrapper_t::~flx_thread_wrapper_t() { thread.join(); }

}}

@head(1,"Mutex")
@head(2,'Windows Emulation of Posix Synchronisation primitives')
@h=tangler('pthread/pthread_win_posix_condv_emul.hpp')
@select(h)
#ifndef __WIN_POSIX_CONDV_EMUL__
#define __WIN_POSIX_CONDV_EMUL__
// Note: no namespaces here!
// See http://www.cs.wustl.edu/~schmidt/win32-cv-1.html

#include "flx_pthread_config.hpp"
#ifdef _WIN32
#include <windows.h>

typedef HANDLE pthread_mutex_t;
typedef void pthread_mutexattr_t; // do NOT use them!
typedef void pthread_condattr_t; // do NOT use them!

struct pthread_cond_t
{
  int waiters_count_;
  // Number of waiting threads.

  CRITICAL_SECTION waiters_count_lock_;
  // Serialize access to <waiters_count_>.

  HANDLE sema_;
  // Semaphore used to queue up threads waiting for the condition to
  // become signaled. 

  HANDLE waiters_done_;
  // An auto-reset event used by the broadcast/signal thread to wait
  // for all the waiting thread(s) to wake up and be released from the
  // semaphore. 

  size_t was_broadcast_;
  // Keeps track of whether we were broadcasting or signaling.  This
  // allows us to optimize the code if we're just signaling.
};

// THIS IS SICK but there ain't no other way in C
#define ETIMEDOUT WAIT_TIMEOUT
// looks like EAGAIN is available in minggw, but not in vs sdk.
#ifndef EAGAIN
#define EAGAIN WAIT_TIMEOUT
#endif

int PTHREAD_EXTERN pthread_mutex_init (pthread_mutex_t*, const pthread_mutexattr_t*);
int PTHREAD_EXTERN pthread_mutex_lock(pthread_mutex_t*);
int PTHREAD_EXTERN pthread_mutex_unlock(pthread_mutex_t*);
int PTHREAD_EXTERN pthread_mutex_destroy(pthread_mutex_t*);

int PTHREAD_EXTERN pthread_cond_init (pthread_cond_t*, const pthread_condattr_t*);
int PTHREAD_EXTERN pthread_cond_destroy(pthread_cond_t*);
int PTHREAD_EXTERN pthread_cond_wait (pthread_cond_t*, pthread_mutex_t*);
int PTHREAD_EXTERN pthread_cond_timedwait(pthread_cond_t*, pthread_mutex_t*, struct timespec const*);
int PTHREAD_EXTERN pthread_cond_uswait(pthread_cond_t*, pthread_mutex_t*, unsigned long us);
int PTHREAD_EXTERN pthread_cond_signal (pthread_cond_t*); 
int PTHREAD_EXTERN pthread_cond_broadcast (pthread_cond_t*);


typedef HANDLE sem_t;

int PTHREAD_EXTERN sem_init(sem_t *sem, int pshared, unsigned int value);
int PTHREAD_EXTERN sem_wait(sem_t * sem);
int PTHREAD_EXTERN sem_trywait(sem_t * sem);
int PTHREAD_EXTERN sem_post(sem_t * sem);
int PTHREAD_EXTERN sem_getvalue(sem_t * sem, int * sval);
int PTHREAD_EXTERN sem_destroy(sem_t * sem);

#else
#include <errno.h>
#include <pthread.h>
#include <semaphore.h>
// emulate the native Window functionality
int PTHREAD_EXTERN pthread_cond_uswait( pthread_cond_t*, pthread_mutex_t*, unsigned long us);
#endif
#endif

@h=tangler('pthread/pthread_win_posix_condv_emul.cpp')
@select(h)
#include "pthread_win_posix_condv_emul.hpp"
#include <assert.h>
#ifdef _WIN32
#include <string.h>

struct timespec {
  unsigned long tv_sec;
  unsigned long tv_nsec;
};

int pthread_mutex_init (pthread_mutex_t *m, const pthread_mutexattr_t*)
{
  *m = CreateMutex(NULL,FALSE,NULL); 
  return 0;
}

int pthread_mutex_lock(pthread_mutex_t *m)
{
  WaitForSingleObject(*m,INFINITE); 
  return 0;
}

int pthread_mutex_unlock(pthread_mutex_t *m)
{
  ReleaseMutex(*m);
  return 0;
}

int pthread_mutex_destroy(pthread_mutex_t *m)
{
  CloseHandle(*m);
  return 0;
}

int 
pthread_cond_init 
(
  pthread_cond_t *cv,
  const pthread_condattr_t *
)
{
  cv->waiters_count_ = 0;
  cv->was_broadcast_ = 0;
  cv->sema_ = CreateSemaphore 
  (
    NULL,       // no security
    0,          // initially 0
    0x7fffffff, // max count .. (I hate limits .. but thats a lot of pthreads)
    NULL        // unnamed
  ); 
  InitializeCriticalSection (&cv->waiters_count_lock_);
  cv->waiters_done_ = CreateEvent 
  (
    NULL,  // no security
    FALSE, // auto-reset
    FALSE, // non-signaled initially
    NULL   // unnamed
  );
  return 0;
}

int 
pthread_cond_destroy(pthread_cond_t *cv)
{
  CloseHandle(cv->sema_);
  CloseHandle(cv->waiters_done_);
  return 0;
}

// returns ETIMEDOUT = WAIT_TIMEOUT
static int
private_cond_wait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex,
  unsigned long ms
)
{
  // Avoid race conditions.
  EnterCriticalSection (&cv->waiters_count_lock_);
  cv->waiters_count_++;
  LeaveCriticalSection (&cv->waiters_count_lock_);

  // This call atomically releases the mutex and waits on the
  // semaphore until <pthread_cond_signal> or <pthread_cond_broadcast>
  // are called by another thread.
  int res = SignalObjectAndWait (*external_mutex, cv->sema_, ms, FALSE);

  // Reacquire lock to avoid race conditions.
  EnterCriticalSection (&cv->waiters_count_lock_);

  // We're no longer waiting...
  cv->waiters_count_--;

  // Check to see if we're the last waiter after <pthread_cond_broadcast>.
  int last_waiter = cv->was_broadcast_ && cv->waiters_count_ == 0;

  LeaveCriticalSection (&cv->waiters_count_lock_);

  // If we're the last waiter thread during this particular broadcast
  // then let all the other threads proceed.
  if (last_waiter)
    // This call atomically signals the <waiters_done_> event and waits until
    // it can acquire the <external_mutex>.  This is required to ensure fairness. 
    SignalObjectAndWait (cv->waiters_done_, *external_mutex, INFINITE, FALSE);
  else
    // Always regain the external mutex since that's the guarantee we
    // give to our callers. 
    WaitForSingleObject (*external_mutex, INFINITE);
  return res;
}

int
pthread_cond_wait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex
)
{
  return private_cond_wait(cv,external_mutex,INFINITE);
}

// Posix is a pain in the butt here
// we have to get the current time and subtract it
// from the target time to get a duration
// the pain is that we probably wanted a duration
// and had to construct a target time by adding it
// to the current time
//
// to fix this we add the native Windows mode (a duration)
// to posix

int
pthread_cond_uswait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex,
  unsigned long us
)
{

  // Windows waits in ms, ours in us
  return private_cond_wait(cv,external_mutex,us * 1000);
}

int
pthread_cond_timedwait 
(
  pthread_cond_t *cv, 
  pthread_mutex_t *external_mutex,
  struct timespec const *abstime
)
{
  unsigned long t1 = abstime->tv_sec * 1000 + abstime->tv_nsec / 1000;
  SYSTEMTIME tod;
  GetSystemTime(&tod);
  FILETIME ft;
  SystemTimeToFileTime(&tod,&ft);
  ULARGE_INTEGER now;  // so we can do some maths
  assert(sizeof(now) == sizeof(ft));
  memcpy(&now, &ft, sizeof(now));
  unsigned long t0 = now.QuadPart / 10; // us now 
  unsigned long timeout = t1>t0 ? t1 - t0 : 0;
  return private_cond_wait(cv,external_mutex,timeout);
}

int
pthread_cond_signal (pthread_cond_t *cv)
{
  EnterCriticalSection (&cv->waiters_count_lock_);
  int have_waiters = cv->waiters_count_ > 0;
  LeaveCriticalSection (&cv->waiters_count_lock_);

  // If there aren't any waiters, then this is a no-op.  
  if (have_waiters)
    ReleaseSemaphore (cv->sema_, 1, 0);
  return 0;
}

int
pthread_cond_broadcast (pthread_cond_t *cv)
{
  // This is needed to ensure that <waiters_count_> and <was_broadcast_> are
  // consistent relative to each other.
  EnterCriticalSection (&cv->waiters_count_lock_);
  int have_waiters = 0;

  if (cv->waiters_count_ > 0) {
    // We are broadcasting, even if there is just one waiter...
    // Record that we are broadcasting, which helps optimize
    // <pthread_cond_wait> for the non-broadcast case.
    cv->was_broadcast_ = 1;
    have_waiters = 1;
  }

  if (have_waiters) {
    // Wake up all the waiters atomically.
    ReleaseSemaphore (cv->sema_, cv->waiters_count_, 0);

    LeaveCriticalSection (&cv->waiters_count_lock_);

    // Wait for all the awakened threads to acquire the counting
    // semaphore. 
    WaitForSingleObject (cv->waiters_done_, INFINITE);
    // This assignment is okay, even without the <waiters_count_lock_> held 
    // because no other waiter threads can wake up to access it.
    cv->was_broadcast_ = 0;
  }
  else
    LeaveCriticalSection (&cv->waiters_count_lock_);
  return 0;
}

int sem_init(sem_t *sem, int pshared, unsigned int value)
{
  *sem = CreateSemaphore(NULL,value,0x7FFFFFFF,NULL);
  return 0;
}

int sem_wait(sem_t * sem) 
{ 
  return WaitForSingleObject(*sem,INFINITE); 
}

int sem_trywait(sem_t * sem) 
{ 
  return WaitForSingleObject(*sem,0); 
}

int sem_post(sem_t * sem) 
{ 
  return ReleaseSemaphore(*sem,1,NULL); 
}

int sem_getvalue(sem_t * sem, int * sval)
{
  LONG x;  
  ReleaseSemaphore(*sem,0,&x); 
  *sval = x;
  return 0;
}

int sem_destroy(sem_t * sem) 
{
  return CloseHandle(*sem);
}


#else

//POSIX
#include <time.h>
#include <sys/time.h>

int pthread_cond_uswait(
  pthread_cond_t *cv, 
  pthread_mutex_t *m, 
  unsigned long us
)
{
  timeval tv;
  gettimeofday(&tv,NULL);
  unsigned long t0 = tv.tv_sec * 1000000uL + tv.tv_usec;
  unsigned long t1 = t0 + us;
  timespec ts;
  ts.tv_sec = t1 / 1000000uL;
  ts.tv_nsec = (t1 % 1000000uL) * 1000;
  return pthread_cond_timedwait(cv,m,&ts);
}

#endif

@head(2,'Portable Mutex')
@h=tangler('pthread/pthread_mutex.hpp')
@select(h)
#ifndef __FLX_MUTEX__
#define __FLX_MUTEX__
#include "flx_pthread_config.hpp"

#include "pthread_win_posix_condv_emul.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Mutex.
// ********************************************************
class PTHREAD_EXTERN flx_mutex_t {
  flx_mutex_t(flx_mutex_t const&); // uncopyable
  void operator=(flx_mutex_t const&); // uncopyable
public:
  pthread_mutex_t m;        // be nice, don't touch
  flx_mutex_t();
  ~flx_mutex_t();
  void lock();
  void unlock();
};

class PTHREAD_EXTERN flx_mutex_locker_t {
  flx_mutex_t* p;
  flx_mutex_locker_t(flx_mutex_locker_t const&); // uncopyable
  void operator=(flx_mutex_locker_t const&); // uncopyable
public:
  flx_mutex_locker_t(flx_mutex_t& pm);
  ~flx_mutex_locker_t();
};

}} // namespace pthread, flx
#endif

@h=tangler('pthread/pthread_mutex.cpp')
@select(h)
#include "pthread_mutex.hpp"
#include <stdio.h>
#include <assert.h>

namespace flx { namespace pthread {
flx_mutex_t::flx_mutex_t(flx_mutex_t const&){} // uncopyable
void flx_mutex_t::operator=(flx_mutex_t const&){} // uncopyable

flx_mutex_t::flx_mutex_t() { pthread_mutex_init(&m, NULL); }

flx_mutex_t::~flx_mutex_t() { pthread_mutex_destroy(&m); }
void flx_mutex_t::lock() { pthread_mutex_lock(&m); }
void flx_mutex_t::unlock() { pthread_mutex_unlock(&m);}

flx_mutex_locker_t::flx_mutex_locker_t(flx_mutex_locker_t const&){} // uncopyable
void flx_mutex_locker_t::operator=(flx_mutex_locker_t const&){} // uncopyable
flx_mutex_locker_t::flx_mutex_locker_t(flx_mutex_t& pm) : p(&pm) { p->lock(); }
flx_mutex_locker_t::~flx_mutex_locker_t() { p->unlock(); }

}}

@head(1,"Counter")
@h=tangler('pthread/pthread_counter.hpp')
@select(h)
#ifndef __PTHREAD_COUNTER__
#define __PTHREAD_COUNTER__
#include <flx_pthread_config.hpp>
#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Counter with zero signal
// ********************************************************
class PTHREAD_EXTERN flx_ts_counter_t {
  flx_mutex_t m;
  flx_condv_t c;
  long x;
  void operator=(flx_ts_counter_t const &);
  flx_ts_counter_t(flx_ts_counter_t const &);
public:
  flx_ts_counter_t();
  ~flx_ts_counter_t();
  long pre_incr(); // value AFTER increment
  long pre_decr(); // value AFTER decrement
  long post_incr(); // value BEFORE increment
  long post_decr(); // value BEFORE decrement

  long get();
  long set(long);   // returns argument
  long swap(long);  // returns old value
  long decr_pos(); // decrement if >0
  void wait_zero(); // wait for zero
  long operator++() { return pre_incr(); }
  long operator--() { return pre_decr(); }
  long operator++(int) { return post_incr(); }
  long operator--(int) { return post_decr(); }
  long operator*() { return get(); }
  long operator=(long a) { return set(a); }
};
}}

#endif

@h=tangler('pthread/pthread_counter.cpp')
@select(h)
#include "pthread_counter.hpp"
#include <stdio.h>

namespace flx { namespace pthread {


flx_ts_counter_t::flx_ts_counter_t() : x(0) {}

flx_ts_counter_t::~flx_ts_counter_t() { 
  wait_zero(); 
}

long flx_ts_counter_t::pre_incr() {
  flx_mutex_locker_t l(m);
  ++x;
  return x;
}

long flx_ts_counter_t::pre_decr() {
  flx_mutex_locker_t l(m);
  --x;
  if(x==0) c.signal();
  return x;
}

long flx_ts_counter_t::post_incr() {
  flx_mutex_locker_t l(m);
  ++x;
  return x+1;
}

long flx_ts_counter_t::post_decr() {
  flx_mutex_locker_t l(m);
  --x;
  if(x==0) c.signal();
  return x+1;
}

long flx_ts_counter_t::decr_pos() {
  flx_mutex_locker_t l(m);
  if(x>0)--x;
  if(x==0) c.signal();
  return x;
}

long flx_ts_counter_t::get() {
  flx_mutex_locker_t l(m);
  return x;
}

long flx_ts_counter_t::set(long a) {
  flx_mutex_locker_t l(m);
  x = a;
  return x;
}

long flx_ts_counter_t::swap(long a) {
  flx_mutex_locker_t l(m);
  long tmp = x;
  x = a;
  if(x==0) c.signal();
  return tmp;
}

void flx_ts_counter_t::wait_zero() {
  flx_mutex_locker_t l(m);
  while(1){
    if(x==0)return;
    c.wait(&m);
  }
}

}}

@head(1,"Condition Variable")
@head(2,'Portable Condition Variable')
@h=tangler('pthread/pthread_condv.hpp')
@select(h)
#ifndef __CONDV__
#define __CONDV__
#include <flx_pthread_config.hpp>
#include "pthread_mutex.hpp"

#include "pthread_win_posix_condv_emul.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Condition Variable.
// ********************************************************
class PTHREAD_EXTERN flx_condv_t {
public:
  pthread_cond_t cv;        // be nice, don't touch
  flx_condv_t();
  ~flx_condv_t();
  void signal();
  void broadcast();
  void wait(flx_mutex_t*);
  int timedwait(flx_mutex_t*, timespec*);
};

}} // namespace pthread, flx
#endif

@h=tangler('pthread/pthread_condv.cpp')
@select(h)
#include "pthread_condv.hpp"
#include <stdio.h>        // printf debugging
#include <assert.h>

namespace flx { namespace pthread {

flx_condv_t::flx_condv_t() { pthread_cond_init(&cv, NULL); }
flx_condv_t::~flx_condv_t() { pthread_cond_destroy(&cv); }
void flx_condv_t::wait(flx_mutex_t *m) { pthread_cond_wait(&cv,&(m->m)); }
void flx_condv_t::signal() { pthread_cond_signal(&cv);}
void flx_condv_t::broadcast() { pthread_cond_broadcast(&cv); }
int flx_condv_t::timedwait(flx_mutex_t *m, timespec *t) {
  int res = pthread_cond_timedwait(&cv,&(m->m),t);
  #ifndef _WIN32
  if(res==EINVAL) return 0; // this is NOT an error!
  #endif
  return res;
}
}}

@head(1,"Semaphore")
@head(2,'Portable Semaphore')
@h=tangler('pthread/pthread_semaphore.hpp')
@select(h)
#ifndef __SEMAPHORE__
#define __SEMAPHORE__
#include <flx_pthread_config.hpp>
#include "pthread_mutex.hpp"

#include "pthread_win_posix_condv_emul.hpp"

namespace flx { namespace pthread {

// ********************************************************
/// Semaphore
// ********************************************************
class PTHREAD_EXTERN flx_semaphore_t {
  sem_t sem;
public:
  flx_semaphore_t(int n=0);
  ~flx_semaphore_t();
  void post();
  void operator++() { post(); }
  void wait();
  void operator--() { wait(); }
  int get();
  int operator*() { return get(); }

  /// atomic test and decrement if non-zero function.
  /// returns EAGAIN on failure to decrement.
  int trywait(); 
};

}} // namespace pthread, flx
#endif

@h=tangler('pthread/pthread_semaphore.cpp')
@select(h)
#include "pthread_semaphore.hpp"
#include <stdio.h>        // printf debugging
#include <assert.h>

namespace flx { namespace pthread {
flx_semaphore_t::flx_semaphore_t(int n) { sem_init(&sem, 0, n); }
flx_semaphore_t::~flx_semaphore_t() { sem_destroy(&sem); }
void flx_semaphore_t::wait() { sem_wait(&sem); }
int flx_semaphore_t::trywait() { return sem_trywait(&sem); }
void flx_semaphore_t::post() { sem_post(&sem); }
int flx_semaphore_t::get(){ int x; sem_getvalue(&sem,&x); return x; }

}}

@h=tangler('pthread/pthread_monitor.hpp')
@select(h)
#ifndef __MONITOR__
#define __MONITOR__
#include <flx_pthread_config.hpp>
#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"
#include "pthread_semaphore.hpp"

// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace pthread {

// ********************************************************
/// A monitor is an concurrent version of a channel.
/// It matches up readers and writers in pairs,
/// synchronising transfer of one datum.
///
/// Unlike the bounded queue below, a monitor is a fully
/// synchronised unbuffered transfer, mediated by a full
/// handshake.
/// 
/// In particular, unlike the queue of size 1, the writer
/// cannot proceed until the reader sends an acknowlege
/// signal.
///
/// This logic matches that provides by schannels, but 
/// across an asynchronous boundary.
// ********************************************************

class PTHREAD_EXTERN monitor_t {
  flx_mutex_t m; 
  flx_mutex_t rm; 
  flx_mutex_t wm; 
  int dataput;
  int datagot;
  flx_condv_t ack;
  void *data;
public:
  monitor_t();
  ~monitor_t();
  void enqueue(void*);
  void* dequeue();
};

}} // namespace pthread, flx
#endif

@h=tangler('pthread/pthread_monitor.cpp')
@select(h)
#include "pthread_monitor.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror
#include <assert.h>

using namespace std;

namespace flx { namespace pthread {

monitor_t::monitor_t() : dataput(0),datagot(0) {}
monitor_t::~monitor_t() { }
inline static void handshake_pos(int &a, flx_condv_t &c, flx_mutex_t &m)
{
  ++a;
  if(a != 0) do { c.wait(&m); } while (a != 0);
  else c.signal();
  assert(a == 0);
  //if(!(a == 0)) fprintf(stderr,"ASSER FAIL\n");
}

inline static void handshake_neg(int &a, flx_condv_t &c, flx_mutex_t &m)
{
  --a;
  if(a != 0) do { c.wait(&m); } while (a != 0);
  else c.signal();
  assert(a == 0);
  //if(!(a == 0)) fprintf(stderr,"ASSER FAIL\n");
}

void
monitor_t::enqueue(void* elt)
{
  flx_mutex_locker_t   wl(wm); // exclude other writers
  flx_mutex_locker_t   l(m);
  data = elt;
  handshake_pos(dataput, ack, m);
  handshake_pos(datagot, ack, m);
}

void*
monitor_t::dequeue()
{
  flx_mutex_locker_t   rl(rm); // exclude other readers
  flx_mutex_locker_t   l(m);
  handshake_neg(dataput, ack, m);
  void *d = data;              // get the data
  handshake_neg(datagot, ack, m);
  return d;
}

}}

@head(1,"Portable Thread safe Queue")
Both queue and dequeue operations are critical
sections protected by a mutex.
@p()
When the queue is empty, the dequeue operation waits 
on a semaphore signaled by the enqueue operation.

@h=tangler('pthread/pthread_sleep_queue.hpp')
@select(h)
#ifndef __SLEEPQUEUE__
#define __SLEEPQUEUE__
#include <flx_pthread_config.hpp>
#include "pthread_mutex.hpp"
#include "pthread_condv.hpp"

// interface for a consumer/producer queue. threads requesting a resource
// that isn't there block until one is available. push/pop re-entrant

namespace flx { namespace pthread {

// ********************************************************
/// Thread safe bounded queue.
///
/// The queue can be locked by setting bound=0.
/// In this state it can only be unlocked by setting a non-zero bound.
///
/// If the bound is set to 1 (the default),
/// then the queue is always either empty or full.
/// An empty queue blocks readers until a writer sends some data.
/// A full queue blocks writers, until a reader reads the data.
/// Note that when the queue is empty a writer can write data
/// and continues without waiting for the data to be read.
// ********************************************************

class PTHREAD_EXTERN sleep_queue_t {
  flx_condv_t size_changed; 
  void *lame_opaque;  
  size_t bound;
public:
  flx_mutex_t member_lock; 
  sleep_queue_t(size_t);
  ~sleep_queue_t();
  void enqueue(void*);
  void* dequeue();
  void resize(size_t);
  void wait_until_empty();
};

}} // namespace pthread, flx
#endif

@h=tangler('pthread/pthread_sleep_queue.cpp')
@select(h)
#include "pthread_sleep_queue.hpp"
#include <queue>        // stl to the bloated rescue
#include <string.h>       // strerror

using namespace std;

namespace flx { namespace pthread {
typedef queue<void*> void_queue;

#define ELTQ ((void_queue*)lame_opaque)

sleep_queue_t::sleep_queue_t(size_t n) : bound(n)
{
  lame_opaque = new void_queue;
}

// Much care is needed deleting a queue.
// A safe method is possible .. but not provided here
sleep_queue_t::~sleep_queue_t()
{
  delete ELTQ;
}

void sleep_queue_t::wait_until_empty() { 
  flx_mutex_locker_t   l(member_lock);
  while(!ELTQ->empty())
    size_changed.wait(&member_lock);
}

void
sleep_queue_t::enqueue(void* elt)
{
  flx_mutex_locker_t   l(member_lock);
  while(ELTQ->size() >= bound) // guard against spurious wakeups!
    size_changed.wait(&member_lock);
  ELTQ->push(elt);
  size_changed.broadcast(); // cannot return an error
}

void*
sleep_queue_t::dequeue()
{
  flx_mutex_locker_t   l(member_lock);
  while(ELTQ->empty())  // guard against spurious wakeups!
    size_changed.wait(&member_lock);
  void *elt = ELTQ->front();
  ELTQ->pop();
  size_changed.broadcast();
  return elt;
}

void 
sleep_queue_t::resize(size_t n)
{
  flx_mutex_locker_t   l(member_lock);
  bound = n;
  // get things rolling again
  size_changed.broadcast();
}

}}


@head(1,'Portable Job Queue')
The class is actually a thread plus a job queue.
@h=tangler('pthread/pthread_work_fifo.hpp')
@select(h)
#ifndef __WORKER_FIFO__
#define __WORKER_FIFO__
#include <flx_pthread_config.hpp>
#include "pthread_thread.hpp"
#include "pthread_mutex.hpp"
#include "pthread_sleep_queue.hpp"

namespace flx { namespace pthread {

/// Class of jobs to be queued in fifo for execution.
class PTHREAD_EXTERN worker_task
{
public:
  virtual ~worker_task() {}   // c++ should do this automatically

  /// function called by worker thread to carry out user job
  virtual void doit() = 0;     

  /// function called by worker thread after doit() is completed
  /// used to notify job completion
  virtual void finished() = 0; // finished hook (mi serve start gancia?)
};

/// Linear job scheduler, executes jobs in turn from queue
class PTHREAD_EXTERN worker_fifo
{
  sleep_queue_t fifo;
  int nthreads;                 /// scheduled number of threads

  static void* thread_start(void*); // thread entry point, passed this
  bool thread_loop_body();      // returns keep going flag
  void stop_worker_thread();
  void start_worker_thread();

public:
  worker_fifo(int n, int m);   /// n: Q bound, m: # of threads
  ~worker_fifo();
  void add_worker_task(worker_task* task);
  int get_nthreads()const;
  void set_nthreads(int);
};

}} // namespace pthread, flx
#endif  // __WORKER_FIFO__

@h=tangler('pthread/pthread_work_fifo.cpp')
@select(h)
#include <stdio.h>    // printf
#include <stdlib.h>   // abort

#include "pthread_work_fifo.hpp"
namespace flx { namespace pthread {

int worker_fifo::get_nthreads()const { return nthreads; }

void worker_fifo::set_nthreads(int n)
{
  while(nthreads<n) start_worker_thread();
  while(nthreads>n) stop_worker_thread();
}

void worker_fifo::start_worker_thread()
{
  ++nthreads;
  fprintf(stderr,"Spawn detached worker thread, count=%d\n",nthreads);
  int result =
#ifdef _WIN32
  flx_detached_thread_t().init((LPTHREAD_START_ROUTINE)thread_start, this);
#else
  flx_detached_thread_t().init(thread_start, this);
#endif
  if (result != 0)
  {
    fprintf(stderr, "FATAL ERROR: Spawn of pre-emptive thread failed!\n");
    abort();
  }
}

worker_fifo::worker_fifo(int n, int m) : fifo(n), nthreads(0)
{
  set_nthreads(m);
}

void
worker_fifo::stop_worker_thread()
{
  fprintf(stderr,"Kill detached worker thread, count=%d\n",nthreads);
  --nthreads;
  add_worker_task(NULL);    // thread safe takedown.
}

worker_fifo::~worker_fifo()
{
  while(nthreads>0)stop_worker_thread();
  fifo.wait_until_empty();
}

// io thread entry point, passed this
void*
worker_fifo::thread_start(void* udat)
{ 
  worker_fifo*  fio = (worker_fifo*)udat;
  while(fio->thread_loop_body()) ;
  return 0;             // return status.
}

// dequeues one task and executes it, calling finished hook. interprets
// null task as a request to exit.
bool
worker_fifo::thread_loop_body()
{
  worker_task*  req = (worker_task*)fifo.dequeue();
  //fprintf(stderr,"dequeued worker_task (%p)\n", req);

  if(!req) return false;        // finished, got quit signal

  req->doit();
  req->finished();          // finish hook. I find this handy

  return true;            // keep going
}

void
worker_fifo::add_worker_task(worker_task* task)
{
  //fprintf(stderr,"adding worker task %p\n",task);
  fifo.enqueue(task);         // don't worry, fifo is re-entrant
}

}}


@h=tangler('lib/pthread.flx')
@select(h)
#import <flx.flxh>

header mutex_hxx = '#include "pthread_mutex.hpp"';
header condv_hxx = '#include "pthread_condv.hpp"';
header counter_hxx = '#include "pthread_counter.hpp"';
header semaphore_hxx = '#include "pthread_semaphore.hpp"';
header monitor_hxx = '#include "pthread_monitor.hpp"';

module Pthread
{
  requires package "flx_pthread";
  open C_hack;
  proc spawn_pthread(p:1->0)
  {
      var con = start p;              // get continuation of p
      var fthr = mk_thread con;
      svc$ svc_spawn_pthread fthr;
  }

  type mutex = "flx_mutex_t" requires mutex_hxx;
  proc lock: lvalue[mutex] = "$1.lock();";
  proc unlock: lvalue[mutex] = "$1.unlock();";
  proc lock (m:&mutex) { lock$ *m; }
  proc unlock (m:&mutex) { unlock$ *m; }

  // pre-emptive thread channels (monitor)
  type pchannel[t] = "flx::pthread::monitor_t*" requires monitor_hxx;

  fun mk_pchannel[t]: 1->pchannel[t] = 
    "new flx::pthread::monitor_t()"
  ; 

  proc _read[t]: pchannel[t] * ptr[ptr[t]] = "*$2 = (?1*)($1->dequeue());";

  proc read[t](v:&t,chan:pchannel[t]) {
    var p : ptr[t];
    _read (chan, addr p);
    *v = *p;
  }

  proc _write[t]: pchannel[t] * ptr[t] = "$1->enqueue((void*)$2);";
  proc write[t](chan:pchannel[t], v:t) {
    var ps = cast[ptr[t]]$ xnew v;
    _write (chan,ps);
  }
}

@h=tangler('test/nd101.flx')
@select(h)
#import <flx.flxh>
include "flx_faio";
include "pthread";
open Pthread;

print "Pthread spawning test"; endl;

proc thr (x:int) { print "Thread "; print x; endl; }

proc flx_main
{
  print "Running main\n";
  var chan = mk_pchannel[int]();
  var dummy: int;

  spawn_pthread { thr 1; write (chan,1); };
  spawn_pthread { thr 2; write (chan,2); };
  spawn_pthread { thr 3; write (chan,3); };
  spawn_pthread { thr 4; write (chan,4); };
  spawn_pthread { thr 5; write (chan,5); };
  spawn_pthread { thr 6; write (chan,6); };
  spawn_pthread { thr 7; write (chan,7); };
  print "Spawned\n";
  &dummy <- read chan; // 1
  print "joined "; print dummy; endl;
  &dummy <- read chan; // 2
  print "joined "; print dummy; endl;
  &dummy <- read chan; // 3
  print "joined "; print dummy; endl;
  &dummy <- read chan; // 4
  print "joined "; print dummy; endl;
  &dummy <- read chan; // 5
  print "joined "; print dummy; endl;
  &dummy <- read chan; // 6
  print "joined "; print dummy; endl;
  &dummy <- read chan; // 7
  print "joined "; print dummy; endl;
  print "Joined all\n";
}

export proc flx_main of (1) as "flx_main";

@h=tangler('test/nd102.flx')
@select(h)
#import <flx.flxh>
include "pthread";
include "flx_faio";
open String;

print "Garbage collector world stop test"; endl;

proc randprint(n:int)
{
  var i = 5;
  print$ "Start Thread number "+str(n); endl;
  whilst i > 0 do
    var d = double_of$ Cstdlib::rand()%10;
    if d == 0.0 do
      print "ZERO FOUND -- collecting!"; endl;
      collect;
      print "collected!"; endl;
    done;
    print$ "Thread "+str n +" Sleep #"+str i+" for "+str d+" sec"; endl;
    --i;
    Faio::sleep d;
  done; 
  print$ "Finish Thread number "+str(n); endl;
}

Pthread::spawn_pthread { randprint(1); };
Pthread::spawn_pthread { randprint(2); };
Pthread::spawn_pthread { randprint(3); };
Pthread::spawn_pthread { randprint(4); };
Pthread::spawn_pthread { randprint(5); };

print "Mainline done!"; endl;
