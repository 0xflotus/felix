@head(1,'The type registry')
Flx supports algebraic type expressions. For some of these,
we need to construct a C++ class type. To ensure the same
name is provided for each such class, we use a registry
which maps the (bound) type expression to an integer.
@p()
The routine register_type_rn is a non-recursive registration
procedure.
@p()
The routine register_type_r registers types recursively.
The 'exclude' argument is a list of types which should
not be registered, this is used to break potential
infinite recursions. Note carefully that components
are always registered before the type, so that they'll
be defined before they're used. There two exceptions:
for a pointer an incomplete type is sufficient,
and sometimes necessary to break type recursion;
and, unions may be recursive, but are represented
by pointers anyhow.
@p()
Note that a function may accept an argument tuple
one of whose arguments is a pointer to a function
of the same type.
@p()
Note that the types of implicitly declared tuples
will be caught here, since the only thing you can
do with a tuple is make it the argument of a function.

@h = tangler("src/flx_treg.mli")
@select(h)
open Flx_types

val register_type_nr:
  sym_state_t ->
  btypecode_t ->
  unit

val register_type_r:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  btypecode_t list ->
  btypecode_t ->
  unit

@h = tangler("src/flx_treg.ml")
@select(h)
open Flx_types
open Flx_typing
open Flx_unify
open Flx_print
open Flx_exceptions
open Flx_util
open Flx_srcref
open Flx_name
open List

let register_type_nr syms t =
  match t with
  | `BTYP_fix _ 
  | `BTYP_tuple []
    -> ()
  | _ 
    ->
    let t = fold t in
    if not (Hashtbl.mem syms.registry t)
    then
      let () = check_recursion t in
      let n = !(syms.counter) in
      incr syms.counter;
      if syms.compiler_options.print_flag then
      print_endline ("//Register type " ^ si n ^ ": " ^ string_of_btypecode syms.dfns t);
      Hashtbl.add syms.registry t n

let rec register_type_r syms bbdfns exclude t =
  let t = lower t in
  (*
  let sp = String.make (length exclude * 2) ' ' in
  print_endline (sp ^ "Register type " ^ string_of_btypecode syms.dfns t);
  if (mem t exclude) then print_endline (sp ^ "Excluded ..");
  *)
  if not (mem t exclude) then
  let rr t' = register_type_r syms bbdfns (t :: exclude) t' in
  let rnr t = register_type_nr syms t in
  let t' = unfold t in
  (*
  print_endline (sp ^ "Unfolded type " ^ string_of_btypecode syms.dfns t');
  *)
  match t' with
  | `BTYP_void -> ()
  | `BTYP_fix i -> failwith ("[register_type_r] Fixpoint "^si i^"encountered") 
  | `BTYP_var i -> failwith ("Attempt to register type variable " ^ si i)
  | `BTYP_function (ps,ret) -> rr ps; rr ret; rnr t
  | `BTYP_array (ps,ret) -> rr ps; rr ret; rnr t
  | `BTYP_tuple ps -> iter rr ps; rnr t
  | `BTYP_sum ps -> iter rr ps; rnr t

  (* NOTE: pointer type is registered before the type it points
    to because it can be incomplete, whereas the type it
    points to may need a complete pointer type: this
    is always the case for recursion under a pointer
  *)

  | `BTYP_pointer ts -> rnr t; rr ts
  | `BTYP_binding (src,dst) -> rr dst
  | `BTYP_inst (i,ts)->
     iter rr ts;

    let id, parent, entry = 
      try Hashtbl.find bbdfns i
      with Not_found -> 
        match Hashtbl.find syms.dfns i with
        { id=id; sr=sr; parent=parent; symdef=entry } ->
        failwith 
        (
          "register_type_r Can't find " ^ 
          id ^ "[" ^ si i ^ "]" ^
          " in fully bound symbol table: " ^
          short_string_of_src sr
        )
    in
    begin match entry with
    | `BBDCL_union (vs,cs) -> 
      let cts = map snd cs in
      let cts = map (tsubst vs ts) cts in
      iter rr cts;
      rnr t

    | `BBDCL_struct (vs,cs) -> 
      let cts = map snd cs in
      let cts = map (tsubst vs ts) cts in
      iter rr cts;
      if length cts > 1 then rnr (`BTYP_tuple cts);
      rnr t;

      let argt = typeoflist cts in
      rnr argt;                             (* argument tuple *)
      rnr (`BTYP_function (argt,t))         (* constructor *)

    | `BBDCL_abs (vs,ct) -> 
      rnr t 

    | _ -> 
      failwith 
      (
        "[register_type_r] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry i
      )
    end

  | _ -> 
    failwith 
    (
      "Unexpected kind in register type: " ^ 
      string_of_btypecode syms.dfns t
    )

