@head(1,'Dypgen')

@h = tangler('spkgs/dyplib.py')
@select(h)
caml_interfaces = [
#  'dypgen/dyplib/sig',
  'dypgen/dyplib/dyp',
]

caml_implementations = [
  'dypgen/dyplib/priority_by_relation',
  'dypgen/dyplib/automaton',
  'dypgen/dyplib/gs',
#  'dypgen/dyplib/parser',
  'dypgen/dyplib/dyp',
]

#caml_pack = [
#  ("Dyp",'dypgen/dyplib/dyp',[
#    'dypgen/dyplib/sig',
#    'dypgen/dyplib/gs',
#    'dypgen/dyplib/priority_by_relation',
#    'dypgen/dyplib/automaton',
#    'dypgen/dyplib/parser'
#  ])
#]

caml_include_paths=['dypgen/dyplib']
caml_provide_lib = 'dypgen/dyplib/dyplib'
iscr_source = ["lpsrc/dyp.pak"]
weaver_directory = 'doc/dypgen/'



@h = tangler('spkgs/pgen.py')
@select(h)
caml_include_paths=['src','dypgen/dyplib','dypgen/generators/pgen']
caml_lexes = ['dypgen/generators/pgen/pgen_lexer']
caml_implementations=[
  'dypgen/generators/pgen/pgen_parser_param',
  'dypgen/generators/pgen/pgen_lexer'
]
caml_provide_lib = 'dypgen/generators/pgen/pgen'
caml_require_libs = ['flx_version','dyplib','pgen']
caml_exes = ['dypgen/generators/pgen/pgen']
iscr_source = ["lpsrc/dyp.pak"]
weaver_directory = 'doc/dypgen/'
pkg_requires = ['flx_version','dyplib']


@h = tangler('spkgs/dypgen.py')
@select(h)
caml_lexes = [
  'dypgen/generators/dypgen/dypgen_lexer',
  'dypgen/generators/dypgen/insert_linenum'
]

caml_pgenparses = ['dypgen/generators/dypgen/dypgen_parser']
caml_interfaces =[
  'dypgen/generators/dypgen/parse_tree',
  'dypgen/generators/dypgen/dypgen_parser',
]
caml_implementations=[
  'dypgen/generators/dypgen/argument',
  'dypgen/generators/dypgen/dypgen_parser',
  'dypgen/generators/dypgen/dypgen_lexer',
  'dypgen/generators/dypgen/insert_linenum',
]
caml_include_paths=['src','dypgen/dyplib','dypgen/generators/dypgen']
caml_provide_lib = 'dypgen/generators/dypgen/dypgen'
caml_require_libs = ['flx_version','dyplib','dypgen']
caml_exes = ['dypgen/generators/dypgen/dypgen']
iscr_source = ["lpsrc/dyp.pak"]
pkg_requires = ['flx_version','dyplib','pgen']
weaver_directory = 'doc/dypgen/'

@h=tangler('dypgen/dyplib/dyp.mli')
@select(h)
module type Dyp_parameters_type =
sig
  val str_token_name : int -> string
    (** Makes possible to display relevant error messages about
        tokens' names and rules *)
  val entry_points : (int * int) list
    (** These are the entry points of the grammar
      (with their corresponding dummy_token) *)
  (*val str_non_terminal : int -> string*)
    (** Makes possible to display relevant error messages about non terminals'
        names and rules *)
  val priority_names : string array
  val merge_warning : bool
    (** If set to true then the parser will emits a warning each time a merge
    happen. *)
  val token_nb : int
    (** The number of terminal symbols in the grammar. *)
  val undef_nt : bool
end
(** Input signature of the functor [Parser] *)


val dypgen_verbose : int ref
(** by default = 0, gives infos about the parsing if set>0,
  breaks re-entrancy if set>2. *)
type token_name = int
type non_ter = int
type 'a pliteral =
  | Ter of token_name
  | Non_ter of 'a
type priority

val default_priority : priority

type non_terminal_priority =
  | No_priority
  | Eq_priority of priority
  | Less_priority of priority
  | Lesseq_priority of priority
  | Greater_priority of priority
  | Greatereq_priority of priority
(** This type makes possible to assign precedence to non terminals in
the rhs of rules.
If the non_terminal_priority of the non terminal E in the following 
rule : A -> E  is Less_priority pc1, and that the parser has so far 
reduced a substring to E yielding the priority class pc2 for this
substring, then the parser reduces with A -> E to A only if we have
the relation pc1 -> pc2 in the priority set used to construct the 
parsing_device (see below create_parsing_device).
  The Toeq constructor behaves the same way except that it also 
accepts pc1 for priority class of the substring even if we don't
have pc1 -> pc1 in the priority set. *)

type priority_data
val empty_priority_data : priority_data
val is_relation : priority_data -> priority -> priority -> bool
val insert_priority : priority_data -> string -> (priority_data * priority)
val find_priority : priority_data -> string -> priority

val set_relation : priority_data -> bool -> priority -> priority ->
  priority_data
(** this set p1<p2 true if b=true and false if b=false *)

val update_priority : priority_data -> (priority * priority * bool) list ->
priority_data
  (** [update_priority ps [pc1,pc2,true]]
  adds the binary relation [pc1] -> [pc2] to [ps]
  [update_priority ps [pc1,pc2,false]]
  removes the relation [pc1] -> [pc2] from [ps] if it exists. *)

val add_list_relations : priority_data -> (priority list) -> priority_data
  (** [add_list_relation ps [p1;...;p2]] adds the relations
  [p1:p2],...,[p1:pn],[p2:p3],...,[p2:pn],...,[p(n-1):pn] to ps. *)

type lit = (int * non_terminal_priority) pliteral
type rule = non_ter * (lit list) * priority

type ('obj,'data,'local_data) dypgen_toolbox = {
  mutable global_data : 'data;
  mutable local_data : 'local_data;
  last_local_data : 'local_data;
  mutable priority_data : priority_data;
  mutable add_rules : (rule * (
    ('obj,'data,'local_data) dypgen_toolbox -> 'obj list -> 'obj)) list;
  mutable remove_rules : rule list;
  mutable will_shift : bool;
  mutable keep_grammar : bool;
  mutable next_state : out_channel option;
  mutable next_grammar : out_channel option;
  symbol_start : unit -> int;
  symbol_start_pos : unit -> Lexing.position;
  symbol_end : unit -> int;
  symbol_end_pos : unit -> Lexing.position;
  rhs_start : int -> int;
  rhs_start_pos : int -> Lexing.position;
  rhs_end : int -> int;
  rhs_end_pos : int -> Lexing.position;
  add_nt : string -> string -> non_ter;
  find_nt : string -> non_ter * string;
  print_state : out_channel -> unit;
  print_grammar : out_channel -> unit;
}

exception Giveup
(** This exception can be raised by an action, then the parser gives
up the current reduction and the parsing along the current path is
stopped. *)

exception Undefined_nt of string
(** This exception is raised when there is in the grammar a non
terminal that is in a right-hand side but never in a left-hand
side (i.e. it is never defined). The string represents this non
terminal. *)

exception Bad_constructor of (string * string * string)
(** This exception is raised when a value is returned by a user action
with a bad constructor (not corresponding to the non terminal). This
can only happen with rules defined dynamically.
1st string is the rule and can be used to be printed.
2nd string is the name of the constructor that should have been used.
3rd string is the name of the constructor that has been used. *)

exception Constructor_mismatch of (string * string)
(** This exception is raised when a nt is added with a constructor cons
but it already exists with another constructor.
1st string is the name of the previous constructor,
2nd string is the name of the constructor one tried to add. *)

exception Syntax_error
(** This exception is raised by glrParse if the parser is stuck in a
situtation where no shift and no reduction is possible. *)

type ('obj,'gd,'ld) merge_function =
  ('obj * 'gd * 'ld) list -> ('obj list * 'gd * 'ld)

val keep_all : ('obj,'gd,'ld) merge_function
val keep_one : ('obj,'gd,'ld) merge_function

module Dyp_special_types :
sig
  type automaton_kind = [ `LR0 | `LALR | `LR1 ]
  type datadyn

  type debug_infos = {
    prt_state : out_channel -> unit;
    prt_grammar : out_channel -> unit;
  }

  type ('obj,'data,'local_data) action =
    Dypgen_action of ( 'obj list -> (Lexing.position * Lexing.position) ->
      (Lexing.position * Lexing.position) list -> 'data -> datadyn ->
      'local_data -> 'local_data -> priority_data -> debug_infos ->
      ('obj * bool * bool *
      'data * datadyn * 'local_data *
      ((rule * ('obj,'data,'local_data) action) list)
      * (rule list) * priority_data * (out_channel option)
      * (out_channel option)) )
  (** Type of the actions bound to rules in the grammar. A classic action
    takes as argument one obj for each symbol in the right hand side
    of its associated rule and returns an obj. This makes possible to
    build an abstract syntax tree, arguments objects being subtrees, or
    to compute values. A dynamic action does the same thing and in
    addition it returns a list of couples (rule,action) to be added to
    the grammar and a list of rules to be removed from the grammar.
    The boolean tells whether the possibility of a shift must be
    regarded or not. data and priority_data are accessible to the 
    actions and local_data for the dynamic ones.
    The two (out_channel option) are for displaying the next automaton
    state and next grammar. *)
end


module Make_dyp :
functor (E : Dyp_parameters_type) ->
sig

  module Tools :
  sig
    val add_nt : string -> string -> Dyp_special_types.datadyn ref -> non_ter
    val find_nt : string -> Dyp_special_types.datadyn -> (non_ter * string)
    val init_datadyn : (string * int * string) list -> string list ->
      Dyp_special_types.datadyn
    (*val init_merge_map : ('obj merge_function * int) list ->
      'obj merge_map*)
    val empty_datadyn : Dyp_special_types.datadyn
    (*val empty_merge_map : 'obj merge_map*)
    type ('global_data,'local_data) data_equal = {
      global_data_equal : 'global_data -> 'global_data -> bool;
      local_data_equal : 'local_data -> 'local_data -> bool }
    val automaton_kind : Dyp_special_types.automaton_kind ref
    val transform_action :
      (('obj,'data,'local_data) dypgen_toolbox ->
        'obj list -> 'obj) ->
      ('obj,'data,'local_data) Dyp_special_types.action
    val keep_zero : ('obj,'gd,'ld) merge_function
  end

  module type Parser_type =
  sig
    type ('obj,'b,'c) parsing_device
      (** Abstract type of a structure which contains an parsing_device, the
      grammar associated to it and the actions associated to the grammar and
      other data. *)

    val create_parsing_device :
      (rule * ('obj,'data,'local_data) Dyp_special_types.action) list ->
      priority_data -> Dyp_special_types.automaton_kind -> 'data ->
      'local_data ->
      Dyp_special_types.datadyn -> string array -> int array ->
      ('obj,'data,'local_data) parsing_device
      (** Returns the parsing_device which parses strings written with
        the input grammar and assuming the relations between priority
        classes which are contained in the input priority data. *)

    val update_parsing_device_data :
      ('obj,'data,'local_data) parsing_device ->
      'data -> 'local_data -> ('obj,'data,'local_data) parsing_device

    val glrParse : ('obj,'data,'local_data) parsing_device ->
          ('token -> 'obj) -> ('token -> int) -> ('token -> string) -> int ->
          ('data,'local_data) Tools.data_equal ->
          ('obj -> bool) array -> ('obj -> string) ->
          ('obj,'data,'local_data) merge_function array ->
          ('a -> 'token) -> 'a ->
          ('a -> (Lexing.position * Lexing.position)) ->
          (('obj * priority) list)
    (** Given a parsing_device and a list of tokens (the input string),
        [glrParse] returns the list of the parse objects of the input string.
        If there is no ambiguity there is only one object in the list. The
        list may be a forest of abstract syntax trees or a list of computed
        values.
        [int] is the name of the entry point. *)
  end

  module Parser_PIA : Parser_type
  module Parser_PAR : Parser_type
end

@h=tangler('dypgen/dyplib/automaton.ml')
@select(h)
let log_channel = ref stdout
let log_stack_channel = ref stdout

let dypgen_verbose = ref 0

let list_append l1 l2 = List.rev_append (List.rev l1) l2
let (@) l1 l2 = list_append l1 l2

type token_name = int

type 'a pliteral =
  | Ter of token_name
  | Non_ter of 'a

(*module Priority = Priority_by_relation.Make(struct type priority = int end)*)
include Priority_by_relation

type ('lhs,'nt_lit) prule_bis = 'lhs * ('nt_lit pliteral array)
type 'nt_lit p_rhs = 'nt_lit pliteral array

type non_ter = int
type lit = (non_ter * non_terminal_priority) pliteral
type rule = non_ter * (lit list) * priority

module Ordered_non_ter =
struct
  type t = non_ter
  let compare = Pervasives.compare
end
module Nt_map = Map.Make(Ordered_non_ter)

(*type ('obj,'gd,'ld) merge_result =
  Merge of ('obj list * 'gd * 'ld) | Dont_merge
type ('obj,'gd,'ld) merge_function =
  'obj list -> 'gd -> 'ld -> 'obj -> 'gd -> 'ld ->
  ('obj,'gd,'ld) merge_result*)

type ('obj,'gd,'ld) merge_function =
  ('obj * 'gd * 'ld) list -> ('obj list * 'gd * 'ld)

(*let keep_all ol gd ld o _ _ = Merge (o::ol,gd,ld)
let keep_one _ gd ld o _ _ = Merge ([o],gd,ld)*)

let keep_all l = match l with
  | (_,gd,ld)::_ -> List.map (fun (o,_,_) -> o) l, gd, ld
  | [] -> assert false

let keep_one l = match l with
  | (o,gd,ld)::_ -> [o], gd, ld
  | [] -> assert false

module Ordered_int =
struct
  type t = int
  let compare = Pervasives.compare
end

module Int_map = Map.Make(Ordered_int)
module Int_set = Set.Make(Ordered_int)

(*type datadyn = ((int * int) String_map.t) * (int Int_map.t) * int*)
(* 1st map is with key : the string of the non terminal and associated values are 2 int. 1st int is the non_ter value, 2nd int is the non_ter value (an int with dypgen) of the non_terminal of the initial grammar which has the same 'type' as this non terminal.
The 2nd map associates the first int with the second int of the values of the previous map (i.e. a nt name to its 'type').
The rigthmost int is the number of non terminals in the map *)

module Dyp_special_types =
struct
  type automaton_kind = [ `LR0 | `LALR | `LR1 ]
  type datadyn = {
    nt_map : ((int * int * string) String_map.t);
      (* map from the string of the non ter to the couple
      of its number and the number of a constructor that should
      be the constructor of the values returned by this nt.
      The string is the string of this constructor. *)
    cons_map : int String_map.t;
      (* map from the string of the constructor to its number. *)
    nt_num : int; (* the number of non terminals *)
    cons_nb : int
   }
  (*type datadyn = (int String_map.t) * int*)

  type debug_infos = {
    prt_state : out_channel -> unit;
    prt_grammar : out_channel -> unit;
  }

  type ('obj,'data,'local_data) action =
    Dypgen_action of ( 'obj list -> (Lexing.position * Lexing.position) ->
      (Lexing.position * Lexing.position) list -> 'data -> datadyn ->
      'local_data -> 'local_data -> priority_data -> debug_infos ->
      ('obj * bool * bool *
      'data * datadyn * 'local_data *
      ((rule * ('obj,'data,'local_data) action) list)
      * (rule list) * priority_data * (out_channel option)
      * (out_channel option)) )
end
open Dyp_special_types

module type Automaton_parameters =
sig
  type non_terminal
  type lhs
  type lit_nt
  (*val str_token_name : int -> string
  val str_non_terminal : non_terminal -> string*)
  (*val token_epsilon : int*)
  val str_priority : int -> string
  (*val select_rule : priority_data -> lit_nt -> lhs -> bool*)
  (*val select_lhs : lit_nt -> priority_data -> (int Prio_map.t) array -> lhs list*)
  val lhs_list : lit_nt -> priority_data -> (int Prio_map.t) array -> lhs list
  type lhslists
  val lhslists_init : int -> lhslists
  val comp_lhslist : lit_nt -> lhslists -> priority_data -> (int Prio_map.t) array -> lhs list
  (*val lhsl_of_nt : non_terminal -> (int Prio_map.t) array -> lhs list*)
end

module type Non_terminal_type =
sig
  type non_terminal
  type lhs
  type lit_nt
  val nt_of_lit : lit_nt -> non_terminal
  val lit_of_nt : non_terminal -> lit_nt
  val nt_of_lhs : lhs -> non_terminal
  val fst_of_lhs : lhs -> non_ter
  val ind_of_lhs : lhs -> int
  val ind_of_nt : non_terminal -> int
  val test_array_nt : bool array -> lit_nt -> bool
  val array_nt_size : int -> int
  val clean_array_nt : bool array -> lit_nt list -> unit
  val get_lhs_prio : lhs -> priority
  val new_rhs_lit : lit_nt -> (int Prio_map.t) array -> int-> lit_nt
  val str_token_name : int -> string
  val str_non_terminal : non_terminal -> string array -> string
  val str_lhs : lhs -> string array -> string
end

module type Grammar_type =
sig
  type non_terminal
  type lhs
  type lit_nt
  val nt_of_lit : lit_nt -> non_terminal
  val lit_of_nt : non_terminal -> lit_nt
  val nt_of_lhs : lhs -> non_terminal
  val fst_of_lhs : lhs -> non_ter
  val ind_of_lhs : lhs -> int
  val ind_of_nt : non_terminal -> int
  val test_array_nt : bool array -> lit_nt -> bool
  val array_nt_size : int -> int
  val clean_array_nt : bool array -> lit_nt list -> unit
  val new_rhs_lit : lit_nt -> (int Prio_map.t) array -> int -> lit_nt
  val get_lhs_prio : lhs -> priority
  type rule_bis = (lhs,lit_nt) prule_bis
  type rhs = lit_nt p_rhs
  module Map_rhs : Map.S with type key = rhs
  type ('a,'b,'c) grammar = ((('a,'b,'c) action) list Map_rhs.t) array
    (* the index of the array is the index of the non terminal of the lhs
      i.e. the 3rd int. *)
    (* to fix: the type grammar should not be available to Automaton *)
  type item = (int * int)
  (* 1st int is rule number
     2nd int is dot position *)
  (*type item_rhs = rhs * int*)
  module Item_map : Map.S with type key=item
  (*module Irhs_map : Map.S with type key=item_rhs*)
  module TNS : Set.S with type elt=token_name
  type item_set = {
    mutable reducible : (int * TNS.t) list;
    mutable kernel_nt : (int * int) list;
    mutable kernel_t : (int * int) list;
    mutable non_kernel : int list;
    (*mutable nt_to_add : Int_set.t*)
  }
  val new_item_set : unit -> item_set
  val dummy_item_set : item_set
  val compare_is : item_set -> item_set -> int
  val str_token_name : token_name -> string
  val str_non_terminal : non_terminal -> string array -> string
  val str_lhs : lhs -> string array -> string
  type literal = lit_nt pliteral
  val str_literal : literal -> string array -> string
  val str_handle : literal array -> int -> string array -> string
  val str_token_set : TNS.t -> string
  val print_reducible : out_channel -> rhs array -> lhs array ->
    string array -> (int * TNS.t) -> unit
  val print_kernel : out_channel -> rhs array -> lhs array ->
    string array -> (int * int) -> unit
  val print_non_kernel : out_channel -> rhs array -> lhs array ->
    string array -> int -> unit
  val print_item : out_channel -> lhs array -> int ->
    string array -> (literal array * int) -> unit
end

module Grammar_struct(Ntt:Non_terminal_type) =
struct
  include Ntt
  type literal = lit_nt pliteral
  type rule_bis = (lhs,lit_nt) prule_bis
  type rhs = lit_nt p_rhs

  (*module Ordered_rule_bis =
    struct
    type t = rule_bis
    let compare (nt1,l1,_) (nt2,l2,_) =
      Pervasives.compare (nt1,l1) (nt2,l2)
  end
  module Map_r = Map.Make (Ordered_rule_bis)
  type ('a,'b,'c) grammar = (('a,'b,'c) action) list Map_r.t*)

  module Ordered_rhs =
    struct
    type t = rhs
    let compare l1 l2 =
      Pervasives.compare l1 l2
  end
  module Map_rhs = Map.Make (Ordered_rhs)
  type ('a,'b,'c) grammar = ((('a,'b,'c) action) list Map_rhs.t) array

  (** [int] is the dot position in the item *)
  type item = (int * int)
  type item_rhs = rhs * int

  module Ordered_items =
  struct
    type t = item
    let compare = Pervasives.compare
  end
  module Item_map = Map.Make(Ordered_items)

  (*module Ordered_item_rhs =
  struct
    type t = item_rhs
    let compare = Pervasives.compare
  end
  module Irhs_map = Map.Make(Ordered_item_rhs)*)

  module Ordered_token_name =
  struct
    type t = token_name
    let compare = Pervasives.compare
  end
  module TNS = Set.Make (Ordered_token_name)


  type item_set = {
    mutable reducible : (int * TNS.t) list;
    mutable kernel_nt : (int * int) list;
    mutable kernel_t : (int * int) list;
    mutable non_kernel : int list;
    (*mutable nt_to_add : Int_set.t*)
  }
  
  let new_item_set () = {
    reducible = [];
    kernel_nt = [];
    kernel_t = [];
    non_kernel = [];
    (*nt_to_add = Int_set.empty*)
  }
  let dummy_item_set = {
    reducible = [];
    kernel_nt = [];
    kernel_t = [];
    non_kernel = [];
    (*nt_to_add = Int_set.empty*)
  }

  let compare_is is1 is2 = Pervasives.compare is1 is2
    (*let c = Pervasives.compare is1.reducible is2.reducible in
    if c<>0 then c else
    let c = Pervasives.compare is1.kernel_t is2.kernel_t in
    if c<>0 then c else
    let c = Pervasives.compare is1.kernel_nt is2.kernel_nt in
    if c<>0 then c else
    let c = Pervasives.compare is1.non_kernel is2.non_kernel in
    if c<>0 then c else Int_set.compare is1.nt_to_add is2.nt_to_add*)

  let str_literal lit str_non_ter = match lit with
    | Ter tk -> str_token_name tk
    | Non_ter nt -> str_non_terminal (nt_of_lit nt) str_non_ter

  let str_handle litl dp str_non_ter =
    let rec aux i s =
      let s1 = if dp=i then s^"." else s in
      if i=Array.length litl then s1
      else aux (i+1) (s1^(str_literal litl.(i) str_non_ter)^" ")
    in
    aux 0 ""

    (*| [] when dp = 0 -> "."
    | [] -> ""
    | t::q -> if dp=0 then ("."^(str_literal t)^" "^(str_handle q (dp-1)))
      else ((str_literal t)^" "^(str_handle q (dp-1))) *)

  let str_token_set tns =
    let f tn str = str^(str_token_name tn)^"," in
    let str = TNS.fold f tns "" in
    if str = "" then "" else
    let string_length = (String.length str) in
    String.sub str 0 (string_length-1)

  (*let print_item ((nt,litl,length),dp) (tns:TNS.t) =
    Printf.fprintf !log_channel "   %s -> %s, (%s) ; length=%d\n" (str_lhs nt)
      (str_handle litl dp) (str_token_set tns) length*)
  let print_reducible chan gram_rhs lhs_table str_non_ter (rn,tns) =
    let lhs,rhs = lhs_table.(rn), gram_rhs.(rn) in
    Printf.fprintf chan "   %s -> %s, (%s)\n"
      (str_lhs lhs str_non_ter)
      (str_handle rhs (Array.length rhs) str_non_ter) (str_token_set tns)

  let print_kernel chan gram_rhs lhs_table str_non_ter (rn,dp) =
    let lhs,rhs = lhs_table.(rn), gram_rhs.(rn) in
    Printf.fprintf chan "   %s -> %s\n"
      (str_lhs lhs str_non_ter) (str_handle rhs dp str_non_ter)

  let print_non_kernel chan gram_rhs lhs_table str_non_ter rn =
    print_kernel chan gram_rhs lhs_table str_non_ter (rn,0)

  let print_item chan lhs_of_ind ind str_non_ter (rhs,dp) =
    Printf.fprintf chan "   %s -> %s\n"
      (str_lhs (lhs_of_ind.(ind)) str_non_ter)
      (str_handle rhs dp str_non_ter)

end



module Automaton_make(Gr:Grammar_type)
  (Ap:Automaton_parameters with type non_terminal=Gr.non_terminal
    and type lit_nt=Gr.lit_nt with type lhs=Gr.lhs) =
struct
open Ap
open Gr

  let token_epsilon = 0

(** this type is used to construct the automaton. Each state in the automaton
    has a field of type [lit_trans] which is the literal of transition to
    this state. The difference with the type [literal] is that there is no
    priority attached to the non terminals. *)
type lit_trans = non_terminal pliteral
(*  | Ter of token_name
  | Non_ter of non_terminal*)

let lit_trans (lit:lit_nt pliteral) = match lit with
  | Non_ter nt -> Non_ter (nt_of_lit nt)
  | Ter t -> Ter t



(** [int] is the length of the [literal] list *)
(* type rule_bis = non_terminal_name * (literal list) * priority * int *)
(* the marker rule_kind is used by the parser. The parser checks the lookahead token to know if it can reduce only in the case of classic rule because dynamic ones can add new rules which may make the lookahead token condition irrelevant *)

(*module Grammar_module = Grammar_struct(Ntt)
include Grammar_module*)



module Ordered_item_set =
struct
  type t = item_set * int (* int is the number of items *)
  let compare (is1,n1) (is2,n2) =
    if n1>n2 then 1
    else if n2>n1 then -1
    else Pervasives.compare
      (is1.reducible,is1.kernel_nt,is1.kernel_t)
      (is2.reducible,is2.kernel_nt,is2.kernel_t)
end

module Map_is = Map.Make(Ordered_item_set)


(*module OrdLi =
struct
  type t = lit_trans
  let compare = Pervasives.compare
end
module Li_map = Map.Make(OrdLi)*)


  (** [li] is the literal of transition from the previous states *)
module rec State :
sig
  type state = {
    number : int;
    li : lit_trans;
    items : item_set;
    mutable succ_states : state list;
    (*mutable pred_states : State.State_set.t Li_map.t*)
  }
  module State_set : Set.S with type elt = state
end
=
struct
  type state = {
      number : int;
      li : lit_trans;
      items : item_set;
      mutable succ_states : state list;
      (*mutable pred_states : State.State_set.t Li_map.t*)
    }
  module State_set =
  struct
    module Ordered_States =
    struct
      type t = state
      let compare s1 s2 = compare_is s1.items s2.items
    end
    module State_set_prime = Set.Make(Ordered_States)
    include (State_set_prime:Set.S with type elt = state)
  end
end

include State

(*let add_edge n1 n2 =
  n1.succ_states <- Li_map.add n2.li n2 n1.succ_states*)(*;
  let state_set = try Li_map.find n1.li n2.pred_states
    with Not_found -> State_set.empty in
  let state_set = State_set.add n1 state_set in
  n2.pred_states <- Li_map.add n1.li state_set n2.pred_states*)

(*let mem_edge s1 s2 =
  Li_map.mem s2.li s1.succ_states*)


(*module Ordered_literal =
struct
  type t = literal
  let compare = Pervasives.compare
end

module Map_lit = Map.Make(Ordered_literal)*)
(* ATTENTION : on s'en sert dans first_on_literal pour la structure
first_memo, on distingue un non terminal avec deux non_terminal_priority
alors que ça ne sert à rien. Il faut : soit ne pas distinguer les deux,
soit s'en servir pour restreindre les lookahead set en utilisant les
priorités. *)




(** Assign unique numbers to states. *)
(*let number_aut (s0:state) =
  let f s (n:int) visited_v =
    if State_set.mem s visited_v then (n,visited_v,Li_map.empty) else
      ((*s.number <- n;*)
      (n+1,State_set.add s visited_v,s.succ_states))
  in
  let rec map_succ _ state (n,visited_v) =
    let n,visited_v,v_map = f state n visited_v in
    Li_map.fold map_succ v_map (n,visited_v)
  in
  let n,visited_v,vertex_map = f s0 0 State_set.empty in
  let n,visited_v = Li_map.fold map_succ vertex_map (n,visited_v) in
  n*)


(** STRING functions used to print the states of the automaton *)


let str_literal_trans lit str_non_ter = match lit with
  | Ter tk -> str_token_name tk
  | Non_ter nt -> str_non_terminal nt str_non_ter

let rec str_tok_list ll str_non_ter = match ll with
  | [] -> ""
  | [tok] -> str_literal (Ter tok) str_non_ter
  | tok::tl -> (str_literal (Ter tok) str_non_ter)^","^
      (str_tok_list tl str_non_ter)


let str_state_succ sl str_non_ter =
  let f str state =
    str^" ["^(string_of_int state.number)^","^
    (str_literal_trans state.li str_non_ter)^"]"
  in
  List.fold_left f "" sl

(*let str_state_pred sl =
  let f lit state_set str =
    let f2 state str =
      str^" ["^(string_of_int state.number)^","^(str_literal_trans lit)^"]"
    in
    State_set.fold f2 state_set str
  in
  Li_map.fold f sl ""*)



let print_item_set chan is gram_rhs lhs_table lhs_of_ind str_non_ter =
  Printf.fprintf chan "  nb of items: %d\n"
  ((List.length is.reducible)+(List.length is.kernel_nt)+
  (List.length is.kernel_t)+(List.length is.non_kernel));
  List.iter (print_reducible chan gram_rhs lhs_table str_non_ter)
    is.reducible;
  List.iter (print_kernel chan gram_rhs lhs_table str_non_ter) is.kernel_t;
  List.iter (print_kernel chan gram_rhs lhs_table str_non_ter) is.kernel_nt;
  List.iter (print_non_kernel chan gram_rhs lhs_table str_non_ter)
    is.non_kernel(*;
  Printf.fprintf !log_channel "  nt to add:\n";
  let f i =
    Printf.fprintf !log_channel "   %s\n" (str_lhs lhs_of_ind.(i));
  in
  Int_set.iter f is.nt_to_add*)

let print_state s gram_rhs lhs_table lhs_of_ind str_non_ter =
  Printf.fprintf !log_channel " State %d\n" s.number;
  Printf.fprintf !log_channel "  li : %s\n"
    (str_literal_trans s.li str_non_ter);
  Printf.fprintf !log_channel "  items :\n";
  print_item_set !log_channel s.items gram_rhs lhs_table lhs_of_ind
    str_non_ter;
  Printf.fprintf !log_channel "  next states : %s\n"
    (str_state_succ s.succ_states str_non_ter)(*;
  Printf.fprintf !log_channel "  previous states : %s\n" (str_state_pred s.pred_states)*)

let rec str_lit_list litl str_non_ter = match litl with
  | [] -> ""
  | lit::tl -> (str_literal lit str_non_ter)^" "^
      (str_lit_list tl str_non_ter)

let str_rule (nt,litl,_) str_non_ter =
  (str_lhs nt str_non_ter)^" -> "^(str_lit_list litl str_non_ter)

let rec print_rule_list rl str_non_ter = match rl with
  | [] -> ()
  | r::t -> Printf.fprintf !log_channel " %s\n"
    (str_rule r str_non_ter); print_rule_list t str_non_ter


(** Used to print the content of an automaton. *)
let print_aut v0 gram_rhs lhs_table lhs_of_ind str_non_ter =
  output_string !log_channel "\n"; output_string !log_channel "\n";
  output_string !log_channel
"----------------------------------- Automaton ----------------------------------\n";
  output_string !log_channel "\n";
  let f s visited_v =
    if State_set.mem s visited_v then (visited_v,[]) else
      (print_state s gram_rhs lhs_table lhs_of_ind str_non_ter;
      print_newline ();
      (State_set.add s visited_v,s.succ_states))
  in
  let rec map_succ visited_v state  =
    let visited_v,v_map = f state visited_v in
    List.fold_left map_succ visited_v v_map
  in
  let visited_v,vertex_map = f v0 State_set.empty in
  List.fold_left map_succ visited_v vertex_map

let print_map m gram_rhs lhs_table lhs_of_ind str_non_ter =
  let f (is,_) s =
    let () = Printf.fprintf !log_channel "state %d\n" (s.number) in
    print_item_set !log_channel is gram_rhs lhs_table lhs_of_ind str_non_ter
  in
  Map_is.iter f m



(**** CLOSURE functions used to close an items set *****)


module Ordered_rule_bis =
struct
  type t = rule_bis
  let compare = Pervasives.compare
end
module RbS = Set.Make(Ordered_rule_bis)

module First =
struct
  type t = TNS.t * bool (* true=contains epsilon *)
  let tns (tns,_) = tns
  let union (tns1,b1) (tns2,b2) = (TNS.union tns1 tns2, b1||b2)
  let empty = (TNS.empty,false)
  let add tok (tns,b) = (TNS.add tok tns,b)
  let mem tok (tns,_) = TNS.mem tok tns
  let mem_epsilon (_,b) = b
  let add_epsilon (tns,_) = (tns,true)
end


let compute_first first_memo grammar nt_nb prio_dat array_nt_prio lhs_of_ind =
  let ind_of_lit nt_lit = ind_of_nt (nt_of_lit nt_lit) in
  
  let rec first_on_nt nt vrules =
    (*output_string !log_channel ("first_on_nt "^(string_of_int n));*)
    let f lhs litl _ rbs = RbS.add (lhs,litl) rbs in
    let lhs_l = lhs_list nt prio_dat array_nt_prio in
    let foldfun rbs lhs = Map_rhs.fold (f lhs) grammar.(ind_of_lhs lhs) rbs in
    let nt_rules = List.fold_left foldfun RbS.empty lhs_l in
    let aux r tns =
      if RbS.mem r vrules then tns else
      let vrules = RbS.add r vrules in
      let (_,litl) = r in
      let tns2 = first_on_litl litl 0 None vrules in
      (First.union tns tns2)
    in
    let tns = RbS.fold aux nt_rules First.empty in
    let ind = ind_of_lit nt in
    first_memo.(ind) <- Some tns;
    tns
  
  and first_on_litl litl p la vrules =
    let rec aux i tns =
      if i=Array.length litl then match la with
        | Some tok -> First.add tok tns
        | None -> First.add_epsilon tns
      else match litl.(i) with
        | Ter ter -> (First.add ter tns)
        | Non_ter nt ->
          let tns2 =
            match first_memo.(ind_of_lit nt) with
            | Some tns -> tns
            | None -> first_on_nt nt vrules
          in
          if First.mem_epsilon tns2 then
            aux (i+1) (First.union tns tns2)
          else (First.union tns tns2)
    in
    aux p First.empty
  in
  
  for i=0 to nt_nb-1 do
    let nt = nt_of_lhs (lhs_of_ind.(i)) in
    let j = ind_of_nt nt in
    match first_memo.(j) with
      | None ->
          let nt_lit = lit_of_nt nt in
          first_memo.(j) <- Some (first_on_nt nt_lit RbS.empty)
      | _ -> ()
  done



let first litl la p first_memo =
  let ind_of_lit nt_lit = ind_of_nt (nt_of_lit nt_lit) in
  
  let first_on_litl litl p la vrules =
    let rec aux i tns =
      if i=Array.length litl then match la with
        | Some tok -> First.add tok tns
        | None -> tns (*TNS.add token_epsilon tns*)
      else match litl.(i) with
        | Ter ter -> (First.add ter tns)
        | Non_ter nt ->
          let tns2 =
            match first_memo.(ind_of_lit nt) with
            | Some tns -> tns
            | None -> assert false
          in
          if First.mem_epsilon tns2 then
            aux (i+1) (First.union tns tns2)
          else (First.union tns tns2)
    in
    First.tns (aux p First.empty)
  in
  
  first_on_litl litl p la RbS.empty



(* AUTOMATON CREATION *)

let countst = ref 0
(** This ref counts the number of state creations. *)
let count_trans = ref 0
(** This ref counts the number of transitions between states. *)

(* ---------------------------- LR(1) automaton ---------------------------- *)

(*

let nonkernel_items (lit:literal) (gram:('a,'b,'c) grammar) (tns:TNS.t) prio_dat array_nt_prio nt_nb =
  match lit with
  | Non_ter nt ->
      let f lhs litl _ items_set =
        IS.add (ind_of_lhs lhs) (litl,0) tns items_set
      in
      let lhs_list = select_lhs nt prio_dat array_nt_prio in
      let f2 is lhs = Map_rhs.fold (f lhs) gram.(ind_of_lhs lhs) is in
      List.fold_left f2 (IS.make nt_nb) lhs_list
  | Ter _ -> failwith "Non terminal expected"

let closure (is:IS.t) (first_memo:First.t option array) (gram:('a,'b,'c) grammar) prio_dat array_nt_prio nt_nb =
  let aux2 _ (litl,dp) (tns:TNS.t) its =
    try
      let a1 = litl.(dp) in
      match lit_trans a1 with
        | Ter _ -> (IS.make nt_nb)
        | Non_ter a1nt ->
          let tok_s =
            if dp=(Array.length litl)-1 then tns
            else
              let f1 tok tok_s =
                let tns =
                  first litl (Some tok) (dp+1) first_memo
                in
                (TNS.union tns tok_s)
              in
              TNS.fold f1 tns TNS.empty
          in
          let its3 = nonkernel_items a1 gram tok_s prio_dat array_nt_prio nt_nb in
          (IS.diff its3 its)
    with Invalid_argument("index out of bounds") -> (IS.make nt_nb)
  in
  let rec aux1 (its1:IS.t) (its2:IS.t) =
    (*Printf.fprintf !log_channel "compt_bug=%d\n" compt_bug; flush_all ();*)
    (* its1 = the new items one has just added, its2 = the items one has added
       since closure's call. *)
    let f ind irhs tns (its1,its2) =
      let its3 = aux2 ind irhs tns its2 in
      (IS.union its3 its1),(IS.union its3 its2)
    in
    let its1,its2 = IS.fold f its1 ((IS.make nt_nb),its2) in
    if its1 = (IS.make nt_nb) then its2 else (aux1 its1 its2)
  in
  aux1 is is
*)

(*module Ordered_lit_trans=
struct
  type t = lit_trans
  let compare = Pervasives.compare
end

module Map_lit_trans = Map.Make(Ordered_lit_trans)*)

(*
let move s is_trace first_memo gram prio_dat array_nt_prio nt_nb =
  let is_trace_tok,is_trace_nt = is_trace in
  let f1 ind (rhs,dp) tns lit_map =
    if dp = Array.length rhs then lit_map
    else
      let lit = lit_trans rhs.(dp) in
      let is =
        try Map_lit_trans.find lit lit_map
        with Not_found -> (IS.make nt_nb),0
      in
      let new_is = (IS.add ind (rhs,dp+1) tns (fst is)),((snd is)+1) in
      Map_lit_trans.add lit new_is lit_map
  in
  let lit_map = IS.fold f1 s.items Map_lit_trans.empty in
  let f2 (lit:lit_trans) (is:IS.t * int) vl =
    count_trans := !count_trans+1;
    try
      let v1 = match lit with
        | Ter t -> Map_is.find is is_trace_tok.(t)
        | Non_ter nt -> Map_is.find is is_trace_nt.(ind_of_nt nt)
      in
      add_edge s v1;
      vl
    with Not_found ->
      let () = countst := (!countst+1) in
      let is1 = closure (fst is) first_memo gram prio_dat array_nt_prio nt_nb in
      let v1 = {
        li = lit;
        items = is1;
        number = !countst;
        succ_states = Li_map.empty;
        pred_states = Li_map.empty
      } in
      add_edge s v1;
      let () = match lit with
        | Ter t -> is_trace_tok.(t) <- Map_is.add is v1 is_trace_tok.(t)
        | Non_ter nt -> is_trace_nt.(ind_of_nt nt) <-
            Map_is.add is v1 is_trace_nt.(ind_of_nt nt)
      in
      (Li_map.add v1.li v1 vl)
  in
  Map_lit_trans.fold f2 lit_map Li_map.empty

let build_automaton_LR1 (is0:IS.t) (lit0:lit_trans) is_trace first_memo (gram:('a,'b,'c) grammar) prio_dat it_nb array_nt_prio nt_nb lhs_of_ind =
  let rec map_succ _ state is_trace =
    (*Printf.fprintf !log_channel "-state built-";
    print_state state lhs_of_ind;
    Printf.fprintf !log_channel "\n";*)
    let v_map = move state is_trace first_memo gram prio_dat array_nt_prio nt_nb in
    Li_map.fold map_succ v_map is_trace
  in
  let is1 = closure is0 first_memo gram prio_dat array_nt_prio nt_nb in
  let v0 = {
    li = lit0;
    items = is1;
    number = !countst;
    succ_states = Li_map.empty;
    pred_states = Li_map.empty
  } in
  let is_trace_tok,is_trace_nt = is_trace in
  let () = match lit0 with
    | Ter t -> is_trace_tok.(t) <- Map_is.add (is0,it_nb) v0 is_trace_tok.(t)
    | Non_ter nt -> is_trace_nt.(ind_of_nt nt) <-
        Map_is.add (is0,it_nb) v0 is_trace_nt.(ind_of_nt nt)
  in
  (*let is_trace = Map_is.add is0 v0 is_trace in*)
  let _,_(*first_memo*) =
    Li_map.fold map_succ
      (Li_map.add v0.li v0 Li_map.empty)
      is_trace
  in
  (*first_memo_print first_memo;*)
  v0
*)

(* --------------------------- `LALR(1) automaton --------------------------- *)


(*let closure_LR0 (is:item_set) gram_rhs gram_lhs =
  let f ind (nk,red) =
    match gram_lhs.(ind) with
      | rn_l, None -> (rn_l@nk,red)
      | rn_l, (Some rn) -> (rn_l@nk,(rn,TNS.empty)::red)
  in
  let non_kernel,reducible = Int_set.fold f is.nt_to_add ([],is.reducible) in
  is.reducible <- reducible;
  is.non_kernel <- non_kernel;
  is.nt_to_add <- Int_set.empty*)



let closure_v0_LR0 (is:item_set) gram_rhs gram_lhs nt_to_add =
  let f ind (nk,red) =
    match gram_lhs.(ind) with
      | rn_l, None -> (rn_l@nk,red)
      | rn_l, (Some rn) -> (rn_l@nk,(rn,TNS.empty)::red)
  in
  let non_kernel,reducible = Int_set.fold f nt_to_add ([],is.reducible) in
  is.reducible <- is.reducible@reducible;
  is.non_kernel <- is.non_kernel@non_kernel(*;
  is.nt_to_add <- Int_set.empty*)


(* array_lhs is still not used, it should be ysed to avoid calling
Int_set.add too many times in f1. Then we could give up the Int_set for a list.
array_lhs should be useful for both prio in automaton and prio at runtime. *)
let move_LR0 s is_trace gram_rhs gram_lhs r_L prio_dat array_nt_prio lhslists array_lt_ter array_lt_nt array_nt array_lhs =
  let is_trace_tok,is_trace_nt = is_trace in
  
  let f1 lt_list (rn,dp) =
    let rhs = gram_rhs.(rn) in
    let is,lt_list = match rhs.(dp) with
      | Ter t -> (match array_lt_ter.(t) with
        | None ->
            let is = new_item_set () in
            array_lt_ter.(t) <- Some is;
            is,(lit_trans rhs.(dp))::lt_list
        | Some is -> is,lt_list)
      | Non_ter nt -> (match array_lt_nt.(ind_of_nt (nt_of_lit nt)) with
        | None ->
            let is = new_item_set () in
            array_lt_nt.(ind_of_nt (nt_of_lit nt)) <- Some is;
            is,(lit_trans rhs.(dp))::lt_list
        | Some is -> is,lt_list)
    in
    let () =
      if dp+1 = Array.length rhs then
        is.reducible <- (rn,TNS.empty)::is.reducible
      else
      match rhs.(dp+1) with
        | Ter _ -> is.kernel_t <- (rn,dp+1)::is.kernel_t
        | Non_ter nt ->
            (is.kernel_nt <- (rn,dp+1)::is.kernel_nt)
    in
    lt_list
  in
  
  let lt_list = List.fold_left f1 [] s.items.kernel_nt in
  let lt_list = List.fold_left f1 lt_list s.items.kernel_t in
  let f3 lt_list rn = f1 lt_list (rn,0) in
  let lt_list = List.fold_left f3 lt_list s.items.non_kernel in
  
  let f2 vl (lit:lit_trans) =
    let is = match lit with
      | Ter t -> (match array_lt_ter.(t) with
          Some is -> is | None -> assert false)
      | Non_ter nt -> (match array_lt_nt.(ind_of_nt nt) with
          Some is -> is | None -> assert false)
    in
    
    count_trans := !count_trans+1;
    let it_nb =
      (List.length is.reducible)
      + (List.length is.kernel_nt)
      + (List.length is.kernel_t)
    in
    let old_reducible = is.reducible in
    (* epsilon rules may be added to reducible by closure_LR0 *)
    try
      let v1 = match lit with
        | Ter t -> Map_is.find (is,it_nb) is_trace_tok.(t)
        | Non_ter nt -> Map_is.find (is,it_nb) is_trace_nt.(ind_of_nt nt)
      in
      s.succ_states <- v1::s.succ_states;
      vl
    with Not_found ->
      countst := (!countst+1);
      let f1 (nt_to_add,nt_list) (rn,dp) = match gram_rhs.(rn).(dp) with
        | Non_ter nt ->
            let lhs_l,nt_list =
              if test_array_nt array_nt nt then [],nt_list
              else (comp_lhslist nt lhslists prio_dat array_nt_prio),
                nt::nt_list
            in
            let g1 nt_to_add ind =
              Int_set.add ind nt_to_add
            in
            let g2 nt_to_add lhs =
              let ind_list = r_L.(ind_of_lhs lhs) in
              List.fold_left g1 nt_to_add ind_list
            in
            (List.fold_left g2 nt_to_add lhs_l), nt_list
        | Ter _ -> assert false
      in
      let nt_to_add, nt_list =
        List.fold_left f1 (Int_set.empty,[]) is.kernel_nt
      in
      clean_array_nt array_nt nt_list;
      let f ind (nk,red) = match gram_lhs.(ind) with
        | rn_l, None -> (rn_l@nk,red)
        | rn_l, (Some rn) -> (rn_l@nk,(rn,TNS.empty)::red)
      in
      let non_kernel,reducible =
        Int_set.fold f nt_to_add ([],is.reducible)
      in
      is.reducible <- reducible;
      is.non_kernel <- non_kernel;
      let v1 = {
        li = lit;
        items = is;
        number = !countst;
        succ_states = [];
        (*pred_states = Li_map.empty*)
      } in
      let old_is = { is with reducible = old_reducible } in
      let () = match lit with
        | Ter t -> is_trace_tok.(t) <-
            Map_is.add (old_is,it_nb) v1 is_trace_tok.(t)
        | Non_ter nt -> is_trace_nt.(ind_of_nt nt) <-
            Map_is.add (old_is,it_nb) v1 is_trace_nt.(ind_of_nt nt)
      in
      s.succ_states <- v1::s.succ_states;
      v1::vl
  in
  let vl = List.fold_left f2 [] lt_list in
  let clear_array lit = match lit with
    | Ter t -> array_lt_ter.(t) <- None
    | Non_ter nt -> array_lt_nt.(ind_of_nt nt) <- None
  in
  List.iter clear_array lt_list;
  vl





(* on n'a pas besoin de nt_nb, c'est la longueur de gram_lhs  *)

let build_automaton_LR0 (is0:item_set) (lit0:lit_trans) is_trace (gram_rhs:rhs array) (gram_lhs:((int list) * (int option)) array) prio_dat it_nb array_nt_prio lhs_of_ind lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter =
  
  let array_lt_ter = Array.make token_nb None in
  let array_lt_nt = Array.make ist_nt_nb None in
  
  Gc.set { (Gc.get()) with Gc.space_overhead = 100 };
  
  let array_nt = Array.make (array_nt_size ist_nt_nb) false in
  let array_lhs = Array.make (Array.length gram_lhs) false in
  (* May be replaced by array of int 31 times shorter *)
  
  let rec map_succ (is_trace,state_list) v =
    (*Printf.fprintf !log_channel "-state built-\n";
    print_state v gram_rhs lhs_table lhs_of_ind str_non_ter;
    Printf.fprintf !log_channel "\n";
    flush_all ();*)
    (*Printf.printf "build state %d\n" v.number;
    flush_all ();*)
    let vl =
      move_LR0 v is_trace gram_rhs gram_lhs r_L prio_dat
        array_nt_prio lhslists array_lt_ter array_lt_nt
        array_nt array_lhs
    in
    List.fold_left map_succ (is_trace,v::state_list) vl
  in
  closure_v0_LR0 is0 gram_rhs gram_lhs nt_to_add;
  let v0 = {
    li = lit0;
    items = is0;
    number = !countst; (* should always be 0 *)
    succ_states = [];
    (*pred_states = Li_map.empty*)
  } in
  let is_trace_tok,is_trace_nt = is_trace in
  let () = match lit0 with
    | Ter t -> is_trace_tok.(t) <- Map_is.add (is0,it_nb) v0 is_trace_tok.(t)
    | Non_ter nt -> is_trace_nt.(ind_of_nt nt) <-
        Map_is.add (is0,it_nb) v0 is_trace_nt.(ind_of_nt nt)
  in
  (*let is_trace = Map_is.add is0 v0 is_trace in*)
  let is_trace,state_list =
    List.fold_left map_succ (is_trace,[v0]) [v0]
  in
  Gc.set { (Gc.get()) with Gc.space_overhead = 80 };
  (*let _ = print_aut v0 gram_rhs lhs_table lhs_of_ind in*)
  is_trace,state_list

let build_automaton_LALR (is0:item_set) (lit0:lit_trans) is_trace gram_rhs gram_lhs prio_dat it_nb array_nt_prio nt_of_ind lhs_of_ind lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter =
  (*let time1 = Sys.time () in
  compute_first first_memo gram nt_nb prio_dat array_nt_prio lhs_of_ind;
  let time2 = Sys.time () in
  Printf.printf "first computed, %.3f sec\n" (time2-.time1);*)
  (*flush_all ();*)
  let is_trace,state_list =
    build_automaton_LR0 is0 lit0 is_trace gram_rhs
    gram_lhs prio_dat it_nb array_nt_prio lhs_of_ind lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter
  in
  
  state_list


let build_automaton automaton_kind (is0:item_set) (lit0:lit_trans) is_trace gram_rhs gram_lhs verbose prio_dat it_nb array_nt_prio nt_of_ind lhs_of_ind lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter =
  countst := 0;
  count_trans := 0;
  let time1 = Sys.time () in
  let state_list = match automaton_kind with
    | `LR0 ->
        let _,state_list =
          build_automaton_LR0 is0 lit0 is_trace gram_rhs gram_lhs
            prio_dat it_nb array_nt_prio lhs_of_ind lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter
        in state_list
    | `LALR -> build_automaton_LALR is0 lit0 is_trace
        gram_rhs gram_lhs prio_dat it_nb array_nt_prio nt_of_ind lhs_of_ind
        lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter
    | `LR1 ->
        print_endline "LR(1) automaton currently not available, `LALR(1) is chosen.";
        build_automaton_LALR is0 lit0 is_trace
        gram_rhs gram_lhs prio_dat it_nb array_nt_prio nt_of_ind lhs_of_ind
        lhslists r_L lhs_table ist_nt_nb token_nb nt_to_add str_non_ter
  in
  let time2 = Sys.time () in
  if verbose>0 then
    (let str_aut_kind = match automaton_kind with
      `LR0 -> "LR(0)" | `LALR -> "`LALR(1)" | `LR1 -> "LR(1)" in
    Printf.fprintf !log_channel "%s automaton built, %d states, %d transitions, %.3f sec\n"
    str_aut_kind (!countst+1) (!count_trans+1) (time2-.time1);
    (*let _ = print_aut v0 lhs_of_ind in*)
    flush stdout) else ();
  state_list,!countst





(** The following functions are used to cover 2 automatons to test whether
    they are equal. *) 
(*
let eq_vertex s1 s2 =
  if s1.li<>s2.li then false else
  if (IS.compare_is s1.items s2.items)=0 then true
  else false

exception Look_for_lit_failed

let eq_next n1 v2 =
  let aux1 _ v l = v.li::l in
  let key_list = Li_map.fold aux1 n1 [] in
  let aux2 key = (Li_map.find key v2.succ_states) in
  try (true,List.map aux2 key_list) with Not_found -> (false,[])
*)

(*
let eq_aut automaton1 automaton2 =
  let n1 = number_aut automaton1 in
  let n2 = number_aut automaton2 in
  if n1<>n2 then false else
  if eq_vertex automaton1.init automaton2.init = false then false else
  let next1 = automaton1.init.succ_states in
  let b,next2 = eq_next next1 automaton2.init in
  if b = false then false else
  let rec aux n1 n2 vv b =
    if b = false then false,vv else
    match (n1,n2) with
      | ([],[]) -> true,vv
      | (_,[]) -> false,vv
      | ([],_) -> false,vv
      | (v1::t1,v2::t2) -> if State_set.mem v1 vv then aux t1 t2 vv true else
          let new_vv = State_set.add v1 vv in
          let bb = eq_vertex v1 v2 in
          if bb = false then false,new_vv else
          let next1 = v1.succ_states in
          let bb,next2 = eq_next next1 v2 in
          if bb = false then false,new_vv else
          let b,new_vv = aux next1 next2 new_vv true in
          if b = false then (false,new_vv) else aux t1 t2 new_vv true
  in
  let b,vv = aux next1 next2 (State_set.add automaton1.init State_set.empty) true in
  b
*)
end

@h=tangler('dypgen/dyplib/dyp.ml')
@select(h)
module type Dyp_parameters_type =
sig
  val str_token_name : int -> string
    (** Makes possible to display relevant error messages about
        tokens' names and rules *)

  val entry_points : (int * int) list
    (** These are the entry points of the grammar *)
  (*val str_non_terminal : int -> string*)
    (** Makes possible to display relevant error messages about non terminals'
        names and rules *)

  val priority_names : string array

  val merge_warning : bool
    (** If set to true then the parser will emits a warning each time a merge
    happen. *)
  val token_nb : int
    (** The number of terminal symbols in the grammar. *)
  val undef_nt : bool
end
(** Input signature of the functor [Parser] *)

let list_map f l = List.rev (List.rev_map f l)

include Automaton
open Dyp_special_types

let default_priority = 0

type ('obj,'data,'local_data) dypgen_toolbox = {
  mutable global_data : 'data;
  mutable local_data : 'local_data;
  last_local_data : 'local_data;
  mutable priority_data : priority_data;
  mutable add_rules : (rule * (
    ('obj,'data,'local_data) dypgen_toolbox -> 'obj list -> 'obj)) list;
  mutable remove_rules : rule list;
  mutable will_shift : bool;
  mutable keep_grammar : bool;
  mutable next_state : out_channel option;
  mutable next_grammar : out_channel option;
  symbol_start : unit -> int;
  symbol_start_pos : unit -> Lexing.position;
  symbol_end : unit -> int;
  symbol_end_pos : unit -> Lexing.position;
  rhs_start : int -> int;
  rhs_start_pos : int -> Lexing.position;
  rhs_end : int -> int;
  rhs_end_pos : int -> Lexing.position;
  add_nt : string -> string -> non_ter;
  find_nt : string -> non_ter * string;
  print_state : out_channel -> unit;
  print_grammar : out_channel -> unit;
}


exception Giveup
exception Undefined_nt of string
exception Bad_constructor of (string * string * string)
exception Constructor_mismatch of (string * string)
exception Syntax_error
    (** This exception is raised by glrParse if the parser is stuck in a
    situtation where no shift and no reduction is possible. *)


(** The way this module handles GLR is documented in the following paper :
Scott McPeak, Elkhound: A fast, practical GLR parser generator, University of 
California Berkeley, Report No. UCB/CSD-2-1214, December 2002 ; figures 7 and 8.
Optimizations which are specific to Elkhound are not implemented.

This implementation adds dynamic changes to the grammar at run-time during 
parsing. These modifications take place in the function reduceViaPath. 

When a reduction is performed the parser checks whether the action is 'classic' 
(no change to the grammar) or 'dynamic' and proceeds with the modifications to 
the grammar and the automaton if needed. If the parsing follows simultaneously 
several paths, as it may be the case with GLR parsing, then there is a distinct 
grammar and a distinct automaton for each path if needed.

Following Scott McPeak's report the stack is implemented as a graph.
*)
module Make_dyp(E:Dyp_parameters_type) =
struct
open E


let countred = ref 0
(* counts the number if reductions performed
it is only used for information *)

type counters = {
  countsn : int;
  counted : int;
  count_token : int;
  count_g : int } (* counts number of grammars *)

open Gs

let non_terminal_startprime = 0


module Ordered_urule =
struct
  type t = rule
  let compare = Pervasives.compare
end

module Urule_map = Map.Make(Ordered_urule)
type ('a,'b,'c) user_grammar = (('a,'b,'c) action) list Urule_map.t

module type Other_parameters =
sig
  type non_terminal
  type lit_nt
  type lhs
  (*val str_non_terminal : non_terminal -> string*)
  (*val select_rule : priority_data -> lit_nt -> non_terminal -> bool*)
  (*val select_lhs : lit_nt -> priority_data -> (int Prio_map.t) array -> lhs list*)
  val lhs_list : lit_nt -> priority_data -> (int Prio_map.t) array -> lhs list
  type lhslists
  val lhslists_init : int -> lhslists
  val comp_lhslist : lit_nt -> lhslists -> priority_data -> (int Prio_map.t) array -> lhs list
  (*val lhsl_of_non_ter : non_ter -> (int Prio_map.t) array -> lhs list*)
  val lhs_startprime : lhs
  val non_ter_of_nt : non_terminal -> int
  val non_ter_of_lhs : lhs -> int
  val dummy_lhs : lhs
  type ('a,'b,'c) grammar
  type rhs
  module Map_rhs : Map.S with type key = rhs
  val make_real_grammar : ('a,'b,'c) user_grammar -> priority_data ->
    string array ->
    (((('a,'b,'c) action) list Map_rhs.t) array * (int Prio_map.t) array *
     int * int * non_terminal array * int array *
     int array * lhs array * int)
  type prio_imprint
  type item_set
  val new_prio_imprint : priority_data -> prio_imprint -> item_set ->
    (non_terminal pliteral) -> priority -> rhs array -> lhs array ->
    lhs array -> string array -> (prio_imprint * bool)
  val change_rn : prio_imprint -> item_set -> int Int_map.t ->
    (prio_imprint * item_set)
  val print_prio_imp : out_channel -> rhs array -> lhs array ->
    prio_imprint -> string array -> unit
  val default_prio_imp : prio_imprint
  val prio_imp_equal : prio_imprint -> prio_imprint -> bool
  (*val prev_is : item_set -> rhs array -> item_set*)
  type rule_bis
  val entry_point_prio :
    non_ter -> prio_imprint -> rhs array ->
    (non_terminal pliteral) -> priority
  val prio_imprint_check : int -> rhs array -> prio_imprint -> bool
  val str_with_priority : priority -> string
end

module NTS = Set.Make(Ordered_non_ter)


module Tools =
struct
  let automaton_kind = ref `LR0

  type ('global_data,'local_data) data_equal = {
    global_data_equal : 'global_data -> 'global_data -> bool;
    local_data_equal : 'local_data -> 'local_data -> bool }

  let add_nt (s:string) (cons:string)
      (datadyn:(Dyp_special_types.datadyn ref)) =
    let { nt_map=nt_map; cons_map=cons_map;
      nt_num=nt_nb; cons_nb=cons_nb } = !datadyn
    in
    try
      let nt,old_cons_i,old_cons =
        String_map.find s nt_map
      in
      if cons<>old_cons
      then raise (Constructor_mismatch(old_cons,cons))
      else nt
    with Not_found ->
      (let cons_map,cons_nb,cons_i =
        try
          let cons_i = String_map.find cons cons_map in
          cons_map, cons_nb, cons_i
        with Not_found ->
          String_map.add cons cons_nb cons_map,
          cons_nb+1, cons_nb
      in
      datadyn :=
        { nt_map = String_map.add s (nt_nb,cons_i,cons) nt_map;
          cons_map = String_map.add cons cons_i cons_map;
          nt_num = nt_nb+1;
          cons_nb = cons_nb };
      nt_nb)

  let find_nt s datadyn =
    let nt,_,cons = String_map.find s datadyn.nt_map in nt,cons


  let init_datadyn ntl consl =
    let aux1 (nt_map,n) (nt,cons_i,cons) =
      (String_map.add nt (n,cons_i,cons) nt_map),(n+1)
    in
    let nt_map, nt_nb =
      List.fold_left aux1 (String_map.empty,1) ntl
    in
    let aux2 (cons_map,i) cons =
      (String_map.add cons i cons_map),(i+1)
    in
    let cons_map, cons_nb =
      List.fold_left aux2 (String_map.empty,0) consl
    in
    { nt_map = nt_map; cons_map = cons_map;
    nt_num = nt_nb; cons_nb = cons_nb }


  (*let init_merge_map (mnl:('obj merge_function * int) list) =
    let aux mm (mf,nt) = Nt_map.add nt mf mm in
    List.fold_left aux Nt_map.empty mnl*)

  let empty_datadyn = {
    nt_map = String_map.empty;
    cons_map = String_map.empty;
    nt_num = 1;
    (* there is always at least one nt : S', which is not in
    nt_map, but this is not very relevant, empty_datadyn is just
    used in pgen. *)
    cons_nb = 0 }

  (*let empty_merge_map = Nt_map.empty*)

  let rec transform_action a =
    Dyp_special_types.Dypgen_action(fun av_list symbol_pos
    position_list data_arg datadyn local_data_arg last_local_data_arg
    prio_data debug_infos ->
      let __dypgen_datadyn = ref datadyn in
      let dyp = {
        global_data = data_arg;
        local_data = local_data_arg;
        last_local_data = last_local_data_arg;
        priority_data = prio_data;
        add_rules = [];
        remove_rules = [];
        will_shift = true;
        keep_grammar = false;
        next_state = None;
        next_grammar = None;
        symbol_start = (fun () -> (fst symbol_pos).Lexing.pos_cnum);
        symbol_start_pos = (fun () -> fst symbol_pos);
        symbol_end = (fun () -> (snd symbol_pos).Lexing.pos_cnum);
        symbol_end_pos = (fun () -> snd symbol_pos);
        rhs_start = (fun i -> (fst (List.nth position_list (i-1))).Lexing.pos_cnum);
        rhs_start_pos = (fun i -> fst (List.nth position_list (i-1)));
        rhs_end = (fun i -> (snd (List.nth position_list (i-1))).Lexing.pos_cnum);
        rhs_end_pos = (fun i -> snd (List.nth position_list (i-1)));
        add_nt = (fun nt cons -> add_nt nt cons __dypgen_datadyn);
        find_nt = (fun (s:string) -> find_nt s !__dypgen_datadyn);
      print_state =
        debug_infos.Dyp_special_types.prt_state;
      print_grammar =
        debug_infos.Dyp_special_types.prt_grammar
      }
      in
      let new_obj = a dyp av_list in
      let mapfun (r,ac) = (r,(transform_action ac)) in
      let add_rules_transformed = List.map mapfun dyp.add_rules in
      (new_obj,dyp.will_shift,dyp.keep_grammar,dyp.global_data,!__dypgen_datadyn,
      dyp.local_data,add_rules_transformed,dyp.remove_rules,
      dyp.priority_data,dyp.next_state,dyp.next_grammar))

  let keep_zero l = match l with
    | (o,gd,ld)::_ -> [], gd, ld
    | [] -> assert false
end

open Tools

module Parser(Gr:Grammar_type)(F:Other_parameters with type non_terminal = Gr.non_terminal and type lit_nt = Gr.lit_nt and type ('a,'b,'c) grammar = ('a,'b,'c) Gr.grammar and type lhs=Gr.lhs and type item_set = Gr.item_set and type rule_bis = Gr.rule_bis and type rhs = Gr.rhs) =
struct

open F
open Gr



module Aut_param =
struct
  type non_terminal = Gr.non_terminal
  type lit_nt = Gr.lit_nt
  type lhs = Gr.lhs
  let str_priority p = priority_names.(p)
  (*let token_epsilon = E.token_epsilon*)
  (*let select_rule = F.select_rule*)
  (*let select_lhs = F.select_lhs*)
  let lhs_list = F.lhs_list
  type lhslists = F.lhslists
  let lhslists_init = F.lhslists_init
  let comp_lhslist = F.comp_lhslist
  (*let lhsl_of_non_ter = F.lhsl_of_non_ter*)
end

module Automat = Automaton_make(Gr)(Aut_param)
open Automat
open Aut_param


type ('a,'b,'c) grammar = ('a,'b,'c) Gr.grammar

(* ******* CE QUI SUIT EST A DEPLACER DANS UN AUTRE FICHIER ****** *)




(*module Ordered_ntcouple =
struct
  type t = non_ter * non_ter
  let compare = Pervasives.compare
end
module Map_ntc = Map.Make(Ordered_ntcouple)*)

(*module OrdPrioNb =
struct
  type t = int * int
  let compare = Pervasives.compare
end
module PrioNb_set = Set.Make(OrdPrioNb)*)


type ('obj,'data,'local_data) parsing_device = {
  gram_lhs : ((int list) * (int option)) array;
  gram_rhs : rhs array;
  lhs_table : lhs array;
  actions : ('obj,'data,'local_data) action list array;
  g_nb : int; (* grammar number *)
  user_g : ('obj,'data,'local_data) user_grammar;
  table : int array array array;
  (* 1st index for state
  2nd index: 0 for terminals, 1 for non terminals
  3rd index to choose which terminal or nt. *)
  table_it : item_set array;
  table_lit_trans : lit_trans array;
  lhslists : lhslists;
  po : bool option array array;
    (** Patial order between non terminal name couples. A couple of non
     terminals is bound to a bool. This may be implemented alternatively
     with a set : the presence of a couple (nt1,nt2) in the set would
     denote that nt1<=nt2 is true. This would save memory space. *)
  data : 'data;
  prio : priority_data;
  local_data : 'local_data;
  datadyn : datadyn;
  (*global_merge : 'obj merge_function;*)
  aut_kind : automaton_kind;
  nt_nb : int;
    (* number of non terminals in the internal grammar
     (as opposed to the user grammar. *)
  non_ter_of_ind : int array;
  prio_of_ind : int array;
  nt_of_ind : non_terminal array;
  lhs_of_ind : lhs array;
  str_non_ter : string array;
  cons_of_nt : int array
}

(*type saved_parsing_device = {
  sa_init : state;
  sa_po : bool Map_ntc.t
}*)

module Ordered_rule =
struct
  type t = rule
  let compare = Pervasives.compare
end

module RS = Set.Make (Ordered_rule)

(* This function decides if the non terminal nt1 can derive the non terminal
nt2 and stores the results in po_array. If it needed to decide whether another
non terminal nt can derive nt2 then it stores it too in po_array. nt_epsilon
stores the non terminals which can derive epsilon.*)
let derive nt1 nt2 user_g po_array nt_epsilon =

  (*let rec derive_epsilon nt nt_epsion vr =*)
  (* il semble que ça marchait malgré cette faute de frappe (nt_epsion) *)
  let rec derive_epsilon nt vr =
    (*try (Nt_map.find nt nt_epsilon),nt_epsilon with Not_found ->*)
    match nt_epsilon.(nt) with Some b -> b
    | None ->
    let f r _ b =
      let (nt,l,_) = r in
      if b then true else
      if nt<>nt1 then false else
      if RS.mem r vr then false else
      match l with
        | [] -> true
        | litl -> begin
            let rec f2 litl =
              match litl with
                | (Non_ter (nt,_))::t -> nt::(f2 t)
                | _ -> []
            in
            let ntl = f2 litl in
            if (List.length ntl)<>(List.length ntl) then false
            else
            let rec f3 (ntl:non_ter list) =
              match ntl with
                | [] -> true
                | nt::t ->
                    let b =
                      let b = derive_epsilon nt (RS.add r vr) in
                      let () = nt_epsilon.(nt) <- Some b in b
                    in
                    if b then f3 t
                    else false
            in
            f3 ntl
        end
    in
    Urule_map.fold f user_g false
  in

  let rec aux nt1 nt2 vr =
    (*try (Map_ntc.find (nt1,nt2) po_array),po_array,nt_epsilon with Not_found ->*)
    match po_array.(nt1).(nt2) with Some b -> b
    | None ->
    let f r _ b =
      let (nt,l,_) = r in
      if b then true else
      if nt<>nt1 then false else
      if RS.mem r vr then false else
      match l with
        | [Non_ter (ntbis,_)] when ntbis=nt2 -> true
        | [Non_ter (ntbis,_)] ->
            let b = aux ntbis nt2 (RS.add r vr) in
            let () = (po_array.(ntbis).(nt2) <- Some b) in b
        | litl -> begin
            let rec f2 litl =
              match litl with
                | (Non_ter (nt,_))::t -> nt::(f2 t)
                | _ -> []
            in
            let ntl = f2 litl in
            if (List.length ntl)<>(List.length ntl) then false
            else
            let rec f3 n1 n2 ntl =
              match ntl with
                | [] -> true
                | nt::t ->
                    let b =
                      if n1=n2 then let b = aux nt nt2 (RS.add r vr) in
                        let () = po_array.(nt).(nt2) <- Some b in b
                      else let b = derive_epsilon nt RS.empty in
                        let () = nt_epsilon.(nt) <- Some b in b
                    in
                    if b then f3 (n1+1) n2 t
                    else false
            in
            let rec f4 n = match n with
              | 0 -> false
              | _ -> let b = f3 1 n ntl in
                  if b then true
                  else f4 (n-1)
            in
            f4 (List.length ntl)
        end
    in
    Urule_map.fold f user_g false
  in
  let b = aux nt1 nt2 RS.empty in
  let () = po_array.(nt1).(nt2) <- Some b in
  b


let print_r_L r_L =
  let f j = print_int j; print_string " " in
  for i=0 to (Array.length r_L)-1 do
    (print_int i; print_string " -L-> ";
    List.iter f r_L.(i); print_newline ())
  done


let print_rel_L rel_L width n =
  let str_bin bin =
    let rec aux c i =
      if i=31 then c else
      aux (c^(string_of_int ((bin lsr i) mod 2))) (i+1)
    in
    aux "" 0
  in
  for i=0 to width-1 do
    (for j=0 to n-1 do
      Printf.printf "%s\n" (str_bin rel_L.(i).(j))
    done;
    print_newline ())
  done





(*let compute_L_woPath gram_rhs gram_lhs lhslists prio_dat array_nt_prio =
  (* n is the number of lhs in the grammar (nt_nb) *)
  
  let n = Array.length gram_lhs in
  let width = (n+30)/31 in
  let ba = Array.make 31 0 in
  let all_one = ref 0 in
  for i=0 to 30 do
    (ba.(i) <- 1 lsl i;
    all_one := !all_one + ba.(i))
  done;
  
  (*Printf.printf "compute_L called\n";
  flush_all ();*)
  
  let dim = n*width in
  
  let rel_L = Array.make (2*dim) 0 in
  
  let f i rhs =
    match rhs.(0) with (* rhs should never be of length 0 here *)
      | Non_ter nt ->
          let l = comp_lhslist nt lhslists prio_dat array_nt_prio in
          let g j =
            let w1,w2 = i/31, i mod 31 in
            let k = ind_of_lhs j in
            rel_L.(dim+k+n*w1) <- rel_L.(dim+k+n*w1) lor ba.(w2)
          in
          List.iter g l
      | Ter _ -> ()
  in
  
  for i=0 to n-1 do
    (let w1,w2 = i/31, i mod 31 in
    rel_L.(dim+i+n*w1) <- rel_L.(dim+i+n*w1) lor ba.(w2);
    let rn_l = fst gram_lhs.(i) in
    let g rn =
      f i gram_rhs.(rn)
    in
    List.iter g rn_l)
  done;
  
  for k=0 to n-1 do (
    (*Printf.printf "k=%d\n" k; flush_all ();*)
    for i=0 to width-1 do
      for j=0 to n-1 do
        let l0,l1 = (k+1) mod 2, k mod 2 in
        let b =
          if (rel_L.(l0*dim+j+n*(k/31)) lsr (k mod 31)) mod 2 = 0
          then 0 else !all_one
        in
        rel_L.(l1*dim+j+n*i) <- rel_L.(l0*dim+j+n*i) lor
          (rel_L.(l0*dim+k+n*i) land b)
      done
    done)
  done;
  
  let l = (n-1) mod 2 in
  
  let r_L = Array.make (n+30) [] in
  
  for i=0 to width-1 do
    for j=0 to n-1 do
      for k=0 to 30 do
        if (rel_L.(l*dim+j+n*i) lsr k) mod 2 = 1
        then
          let m = i*31+k in
          r_L.(m) <- j::r_L.(m)
        else ()
      done
    done
  done;
  
  (rel_L,r_L)*)


let compute_L gram_rhs gram_lhs lhslists prio_dat array_nt_prio first_memo =
  (* n is the number of lhs in the grammar (nt_nb) *)
  
  let n = Array.length gram_lhs in
  let width = (n+30)/31 in
  let ba = Array.make 31 0 in
  let all_one = ref 0 in
  for i=0 to 30 do
    (ba.(i) <- 1 lsl i;
    all_one := !all_one + ba.(i))
  done;
  
  
  let dim = n*width in
  
  let rel_L = Array.make (2*dim) 0 in
  
  let f i rhs =
    match rhs.(0) with (* rhs should never be of length 0 here *)
      | Non_ter nt ->
          let l = comp_lhslist nt lhslists prio_dat array_nt_prio in
          let g j =
            let ind = dim+(ind_of_lhs j)+n*(i/31) in
            rel_L.(ind) <- rel_L.(ind) lor ba.(i mod 31)
          in
          List.iter g l
      | Ter _ -> ()
  in
  
  for i=0 to n-1 do
    (let ind = dim+i+n*(i/31) in
    rel_L.(ind) <- rel_L.(ind) lor ba.(i mod 31);
    let rn_l = fst gram_lhs.(i) in
    let g rn =
      f i gram_rhs.(rn)
    in
    List.iter g rn_l)
  done;
  
  for k=0 to n-1 do (
    (*Printf.printf "k=%d\n" k; flush_all ();*)
    let l0 = ((k+1) mod 2)*dim in
    let l1 = (k mod 2)*dim in
    let k0 = n*(k/31) in
    let k1 = k mod 31 in
    for i=0 to width-1 do
      let i0 = n*i in
      for j=0 to n-1 do
        let b =
          if (rel_L.(l0+j+k0) lsr k1) mod 2 = 0
          then 0 else !all_one
        in
        rel_L.(l1+j+i0) <- rel_L.(l0+j+i0) lor
          (rel_L.(l0+k+i0) land b)
      done
    done)
  done;
  
  let l = ((n-1) mod 2)*dim in
  
  let r_L = Array.make (n+30) [] in
  
  for i=0 to width-1 do
    let i0 = n*i in
    let i1 = i*31 in
    for j=0 to n-1 do
      for k=0 to 30 do
        if (rel_L.(l+j+i0) lsr k) mod 2 = 1
        then
          let m = i1+k in
          r_L.(m) <- j::r_L.(m)
        else ()
      done
    done
  done;
  
  (rel_L,r_L)


(*let compute_L gram_rhs gram_lhs lhslists prio_dat array_nt_prio first_memo =
  (* n is the number of lhs in the grammar (nt_nb) *)
  
  let n = Array.length gram_lhs in
  let width = (n+30)/31 in
  let ba = Array.make 31 0 in
  let all_one = ref 0 in
  for i=0 to 30 do
    (ba.(i) <- 1 lsl i;
    all_one := !all_one + ba.(i))
  done;
  
  
  let dim = n*width in
  
  let rel_L = Array.make (2*dim) 0 in
  
  let f i rhs =
    match rhs.(0) with (* rhs should never be of length 0 here *)
      | Non_ter nt ->
          let l = comp_lhslist nt lhslists prio_dat array_nt_prio in
          let g j =
            let w1,w2 = i/31, i mod 31 in
            let k = ind_of_lhs j in
            rel_L.(dim+k+n*w1) <- rel_L.(dim+k+n*w1) lor ba.(w2)
          in
          List.iter g l
      | Ter _ -> ()
  in
  
  for i=0 to n-1 do
    (let w1,w2 = i/31, i mod 31 in
    rel_L.(dim+i+n*w1) <- rel_L.(dim+i+n*w1) lor ba.(w2);
    let rn_l = fst gram_lhs.(i) in
    let g rn =
      f i gram_rhs.(rn)
    in
    List.iter g rn_l)
  done;
  
  for k=0 to n-1 do (
    (*Printf.printf "k=%d\n" k; flush_all ();*)
    for i=0 to width-1 do
      for j=0 to n-1 do
        let l0,l1 = (k+1) mod 2, k mod 2 in
        let b =
          if (rel_L.(l0*dim+j+n*(k/31)) lsr (k mod 31)) mod 2 = 0
          then 0 else !all_one
        in
        rel_L.(l1*dim+j+n*i) <- rel_L.(l0*dim+j+n*i) lor
          (rel_L.(l0*dim+k+n*i) land b)
      done
    done)
  done;
  
  let l = (n-1) mod 2 in
  
  let r_L = Array.make (n+30) [] in
  
  for i=0 to width-1 do
    for j=0 to n-1 do
      for k=0 to 30 do
        if (rel_L.(l*dim+j+n*i) lsr k) mod 2 = 1
        then
          let m = i*31+k in
          r_L.(m) <- j::r_L.(m)
        else ()
      done
    done
  done;
  
  (rel_L,r_L)*)


(*let compute_L gram_rhs gram_lhs lhslists prio_dat array_nt_prio =
  (* n is the number of lhs in the grammar (nt_nb) *)
  
  let n = Array.length gram_lhs in
  let width = (n+30)/31 in
  let ba = Array.make 31 0 in
  let all_one = ref 0 in
  for i=0 to 30 do
    (ba.(i) <- 1 lsl i;
    all_one := !all_one + ba.(i))
  done;
  
  (*Printf.printf "compute_L called\n";
  flush_all ();*)
  
  let rel_L =
    [|Array.init width (fun _ -> Array.make n 0);
      Array.init width (fun _ -> Array.make n 0)|]
  in
  
  let f i rhs =
    match rhs.(0) with (* rhs should never be of length 0 here *)
      | Non_ter nt ->
          let l = comp_lhslist nt lhslists prio_dat array_nt_prio in
          let g j =
            let w1,w2 = i/31, i mod 31 in
            let k = ind_of_lhs j in
            rel_L.(1).(w1).(k) <- rel_L.(1).(w1).(k) lor ba.(w2)
          in
          List.iter g l
      | Ter _ -> ()
  in
  
  for i=0 to n-1 do
    (let w1,w2 = i/31, i mod 31 in
    rel_L.(1).(w1).(i) <- rel_L.(1).(w1).(i) lor ba.(w2);
    let rn_l = fst gram_lhs.(i) in
    let g rn =
      f i gram_rhs.(rn)
    in
    List.iter g rn_l)
  done;
  
  for k=0 to n-1 do (
    (*Printf.printf "k=%d\n" k; flush_all ();*)
    for i=0 to width-1 do
      for j=0 to n-1 do
        let l0,l1 = (k+1) mod 2, k mod 2 in
        let b =
          if (rel_L.(l0).(k/31).(j) lsr (k mod 31)) mod 2 = 0
          then 0 else !all_one
        in
        rel_L.(l1).(i).(j) <- rel_L.(l0).(i).(j) lor
          (rel_L.(l0).(i).(k) land b)
      done
    done)
  done;
  
  let l = (n-1) mod 2 in
  
  let r_L = Array.make (n+30) [] in
  
  for i=0 to width-1 do
    for j=0 to n-1 do
      for k=0 to 30 do
        if (rel_L.(l).(i).(j) lsr k) mod 2 = 1
        then
          let m = i*31+k in
          r_L.(m) <- j::r_L.(m)
        else ()
      done
    done
  done;
  
  (rel_L,r_L)*)


let create_aut gram_rhs gram_lhs r_L init_is lit prio_dat it_nb array_nt_prio nt_of_ind lhs_of_ind ist_nt_nb lhslists lhs_table nt_to_add str_non_ter =
  let () = countst := 0 in
  let is_trace =
    (Array.make E.token_nb Map_is.empty),
    (Array.make ist_nt_nb Map_is.empty)
  in
  let state_list,n =
    build_automaton !automaton_kind init_is lit is_trace
      gram_rhs gram_lhs !dypgen_verbose prio_dat it_nb
      array_nt_prio nt_of_ind lhs_of_ind lhslists r_L lhs_table
      ist_nt_nb token_nb nt_to_add str_non_ter
  in
  state_list,n

(*let create_po user_g =
  let collect_nt (nt,_,_) _ nts = NTS.add nt nts in
  let nt_set = Urule_map.fold collect_nt user_g NTS.empty in
  let cover_nts nt1 (po_array,nt_epsilon) =
  (* nt_epsilon is used to record whether a non terminal can derive epsilon *)
    let aux nt2 (po_array,nt_epsilon) =
      if Map_ntc.mem (nt1,nt2) po_array then po_array,nt_epsilon
      else derive nt1 nt2 user_g po_array nt_epsilon
    in
    NTS.fold aux nt_set (po_array,nt_epsilon)
  in
  let po_array,_ = NTS.fold cover_nts nt_set (Map_ntc.empty,Nt_map.empty) in
  po_array*)

let create_po user_g nt_nb str_non_ter =
  let time1 = Sys.time () in
  let po_array =
    Array.init nt_nb (fun _ -> (Array.make nt_nb None))
  in
  let nt_epsilon = Array.make nt_nb None in
  let rec rhs_tokless litl = match litl with
    | (Ter _)::_ -> false
    | (Non_ter _)::tl -> rhs_tokless tl
    | [] -> true
  in
  let fold_fun r a (new_g,nts0,nts1) =
    let (nt,litl,_) = r in
    let nts0 = NTS.add nt nts0 in
    let new_g,nts1 = match litl with
      | [] -> let () = nt_epsilon.(nt) <- Some true in new_g,nts1
      | [Non_ter (nt2,_)] -> let () = po_array.(nt).(nt2) <- Some true in
          new_g,(NTS.add nt nts1)
      | _ ->
          if rhs_tokless litl then
            (Urule_map.add r a new_g),(NTS.add nt nts1)
          else (new_g,nts1)
    in
    (new_g,nts0,nts1)
  in
  let user_g, nt_set_0, nt_set_1 =
    Urule_map.fold fold_fun user_g (Urule_map.empty,NTS.empty,NTS.empty)
  in
  let nt_set_2 = NTS.diff nt_set_0 nt_set_1 in
  
  let cover_nts_2 nt1 =
    let aux nt2 = po_array.(nt1).(nt2) <- Some false in
    NTS.iter aux nt_set_0;
    nt_epsilon.(nt1) <- Some false
  in
  let () = NTS.iter cover_nts_2 nt_set_2 in
  
  let cover_nts_1 nt1 =
  (* nt_epsilon is used to record whether a non terminal can derive epsilon *)
    let aux nt2 =
      (*if Map_ntc.mem (nt1,nt2) po_array then po_array,nt_epsilon
      else let _,pm,nte = derive nt1 nt2 user_g po_array nt_epsilon in pm,nte*)
      let b = match po_array.(nt1).(nt2) with
        | None -> derive nt1 nt2 user_g po_array nt_epsilon
        | Some b -> b
        (*try (Map_ntc.find (nt1,nt2) po_array),po_array,nt_epsilon
        with Not_found -> derive nt1 nt2 user_g po_array nt_epsilon*)
      in
      if b && nt1=nt2 then
        let () = Printf.fprintf stderr
          "Error: non terminal `%s' can derive itself, cyclic grammars are not allowed\n"
          (str_non_ter.(nt1)) in
        failwith "cyclic grammar"
      else ()
    in
    NTS.iter aux nt_set_0
  in
  let () = NTS.iter cover_nts_1 nt_set_1 in
  
  let time2 = Sys.time () in
  if !dypgen_verbose>1 then
    (Printf.fprintf !log_channel "po_array built, %.3f sec\n" (time2-.time1);
    flush stdout) else ();
  po_array



let print_table_state chan i table table_it table_lit_trans gram_rhs lhs_table lhs_of_ind str_non_ter nt_of_ind =
  let tnb, ntnb = Array.length table.(0).(0), Array.length table.(0).(1) in
  let f tab len name_fun =
    for i=0 to len-1 do
      if tab.(i)>=0 then Printf.printf "(%s,%d) " (name_fun i) tab.(i)
    done
  in
  Printf.fprintf chan " State %d\n" i;
  Printf.fprintf chan "  li: %s\n  items:\n"
    (str_literal_trans table_lit_trans.(i) str_non_ter);
  print_item_set chan table_it.(i) gram_rhs lhs_table
    lhs_of_ind str_non_ter;
  Printf.fprintf chan "  next states (shift):\n   ";
  f table.(i).(0) tnb E.str_token_name; print_newline ();
  Printf.fprintf chan "  next states (reduction):\n   ";
  f table.(i).(1) ntnb
    (fun i -> str_non_terminal (nt_of_ind.(i)) str_non_ter);
  print_newline (); print_newline ()

let print_tables table table_it table_lit_trans gram_rhs lhs_table lhs_of_ind str_non_ter nt_of_ind =
  Printf.printf "\nTables\n\n";
  for i=0 to (Array.length table)-1 do
    print_table_state !log_channel i table table_it table_lit_trans gram_rhs
      lhs_table lhs_of_ind str_non_ter nt_of_ind
  done



let make_table state_list n ist_nt_nb gram_rhs lhs_table lhs_of_ind =
  let table = Array.init n
    (fun _ -> [|Array.make E.token_nb (-1);Array.make ist_nt_nb (-1)|])
  in
  (*Printf.printf "E.token_nb=%d, ist_nt_nb=%d\n" E.token_nb ist_nt_nb;*)
  let table_it = Array.make n dummy_item_set in
  let table_lit_trans = Array.make n (Ter 0) in
  
  let g num succ = match succ.li with
    | Ter t ->
        (*Printf.printf "Ter %s, t=%d\n" (str_token_name t) t;*)
        table.(num).(0).(t) <- succ.number
    | Non_ter nt ->
        (*Printf.printf "Non_ter %s\n" (str_non_terminal nt);*)
        table.(num).(1).(ind_of_nt nt) <- succ.number
  in
  let f v =
    (*Printf.printf "process state %d\n" v.number;*)
    List.iter (g v.number) v.succ_states;
    table_it.(v.number) <- v.items;
    table_lit_trans.(v.number) <- v.li
  in
  
  List.iter f state_list;
  
  (*print_tables table table_it table_lit_trans gram_rhs lhs_table lhs_of_ind;*)
  
  table,table_it,table_lit_trans


let create_parsing_device_with_init gram_rhs gram_lhs lhs_table
    actions r_L user_g (data:'b) datadyn (local_data:'c)
    (pcs:priority_data) init_is
    lit user_nt_nb po_array it_nb array_nt_prio nt_of_ind
    non_ter_of_ind prio_of_ind lhs_of_ind g_nb ist_nt_nb lhslists
    nt_to_add str_non_ter cons_of_nt =
  let state_list,n = create_aut gram_rhs gram_lhs r_L init_is
    lit pcs it_nb array_nt_prio nt_of_ind lhs_of_ind ist_nt_nb
    lhslists lhs_table nt_to_add str_non_ter in
  let table,table_it,table_lit_trans =
    make_table state_list (n+1) ist_nt_nb gram_rhs
      lhs_table lhs_of_ind
  in
  let parsing_device =
    { actions = actions ; gram_rhs = gram_rhs ;
      gram_lhs = gram_lhs ; lhs_table = lhs_table ;
      g_nb = g_nb; user_g = user_g ; table = table ;
      table_it = table_it ; table_lit_trans = table_lit_trans ;
      lhslists = lhslists ; po = po_array ; data = data;
      local_data = local_data ; datadyn = datadyn ;
      prio = pcs ;
      aut_kind = !automaton_kind ;
      nt_nb = Array.length gram_lhs; non_ter_of_ind=non_ter_of_ind;
      prio_of_ind=prio_of_ind; nt_of_ind=nt_of_ind;
      lhs_of_ind=lhs_of_ind; str_non_ter=str_non_ter;
      cons_of_nt=cons_of_nt }
   in
  parsing_device


(*let dummy_token_name = 0*)
let dummy_token_map =
  let aux dt_map (ep,dt) = Int_map.add ep dt dt_map in
  List.fold_left aux Int_map.empty E.entry_points


let init_is gram_rhs gram_lhs r_L array_nt_prio lhslists prio_dat array_nt_prio =
  (*let non_ter_of_lit nt_lit = non_ter_of_nt (nt_of_lit nt_lit) in*)
  let is = new_item_set () in
  let aux nt_to_add rn =
  (*print_endline ("> "^(string_of_int (Array.length gram_rhs.(rn))));
  print_endline ("> "^(str_handle gram_rhs.(rn) 0));*)
  match gram_rhs.(rn) with
    | [|Non_ter nt|] ->
        (is.non_kernel <- rn::is.non_kernel;
        let lhs_l =
          comp_lhslist nt lhslists prio_dat array_nt_prio
        in
        let g1 nt_to_add ind =
          Int_set.add ind nt_to_add
        in
        let g2 nt_to_add lhs =
          let ind_list = r_L.(ind_of_lhs lhs) in
          List.fold_left g1 nt_to_add ind_list
        in
        (List.fold_left g2 nt_to_add lhs_l))
    | _ -> assert false
  in
  is,(List.fold_left aux Int_set.empty (fst gram_lhs.(0)))



let init_lit = Ter 0

let create_parsing_device_bis
    (gram_lhs:((int list) * (int option)) array)
    gram_rhs lhs_table
    actions aut_kind (data:'b) (local_data:'c)
    (pcs:priority_data)
    user_nt_nb po_array user_g datadyn array_nt_prio nt_of_ind
    non_ter_of_ind prio_of_ind lhs_of_ind g_nb ist_nt_nb str_non_ter
    cons_of_nt =
    (* gram must already contain the rules S' -> entry_point *)
  automaton_kind := aut_kind;
  let lhslists = lhslists_init ist_nt_nb in
  
  let first_memo = Array.make ist_nt_nb None in
  
  (*let time1 = Sys.time () in
  compute_first first_memo gram nt_nb prio_dat array_nt_prio lhs_of_ind;
  let time2 = Sys.time () in
  Printf.printf "first computed, %.3f sec\n" (time2-.time1);*)
  
  let time1 = Sys.time () in
  let _, r_L = compute_L gram_rhs gram_lhs lhslists
    pcs array_nt_prio first_memo in
  let time2 = Sys.time () in
  if !dypgen_verbose>1 then
    Printf.fprintf !log_channel "r_L computed, %.3f sec\n"
      (time2-.time1);
  let is0, nt_to_add = init_is gram_rhs gram_lhs r_L array_nt_prio
    lhslists pcs array_nt_prio
  in
  create_parsing_device_with_init gram_rhs gram_lhs
    lhs_table actions r_L user_g data
    datadyn local_data pcs
    is0 init_lit user_nt_nb
    po_array 0 array_nt_prio nt_of_ind non_ter_of_ind prio_of_ind
    lhs_of_ind g_nb ist_nt_nb lhslists nt_to_add str_non_ter cons_of_nt


let update_parsing_device_data automaton dat ldat =
  { automaton with data=dat ; local_data = ldat }

(*let create_saved_parsing_device gram nt_nb prio_dat =
  let v , po_array = create_a_and_po (gram:('a,'b,'c) grammar)
    (init_is gram) init_lit nt_nb prio_dat in
  { sa_init = v ; sa_po = po_array }

let complete_parsing_device sa gram aut_kind data local_data priodata
    merge_map global_merge nt_nb =
  { g = gram ; init = sa.sa_init ; po = sa.sa_po ;
  data = data ; local_data = local_data ; prio = priodata ; merge_map = merge_map;
  global_merge = global_merge ; aut_kind = aut_kind ; nt_nb = nt_nb }*)





let update_user_g ral user_g =
  let f user_g (r,a) =
    let al = try Urule_map.find r user_g with Not_found -> [] in
    Urule_map.add r (a::al) user_g
  in
  List.fold_left f user_g ral


let str_rule rn gram_rhs lhs_table str_non_ter =
    Printf.sprintf "%s -> %s"
      (str_lhs lhs_table.(rn) str_non_ter)
      (str_handle gram_rhs.(rn) (-1) str_non_ter)

let print_grammar chan gram_rhs lhs_table str_non_ter =
  for i=0 to (Array.length lhs_table)-1 do
    Printf.fprintf chan "rn:%d  %s\n" i
      (str_rule i gram_rhs lhs_table str_non_ter)
  done;
  print_newline ()


let print_gram_lhs gram_lhs lhs_of_ind str_non_ter =
  let f i rn =
    Printf.printf "lhs:%s  rn:%d\n" (str_lhs lhs_of_ind.(i) str_non_ter) rn
  in
  for i=0 to (Array.length gram_lhs)-2 do (
    (match snd gram_lhs.(i) with
    | None ->
        Printf.printf "no epsilon rule for %s\n"
          (str_lhs (lhs_of_ind.(i)) str_non_ter)
    | Some rn ->
        Printf.printf "no epsilon rule nb %d for %s\n" rn
          (str_lhs (lhs_of_ind.(i)) str_non_ter)
    );
    List.iter (f i) (fst gram_lhs.(i)) )
  done


let print_g g lhs_of_ind str_non_ter =
  let f i rhs _ =
    Printf.printf "%s -> %s\n" (str_lhs lhs_of_ind.(i) str_non_ter)
      (str_handle rhs 0 str_non_ter)
  in
  for i=0 to (Array.length g)-1 do
    F.Map_rhs.iter (f i) g.(i)
  done

let print_lhs_of_ind lhs_of_ind str_non_ter =
  for i=0 to (Array.length lhs_of_ind)-1 do
    Printf.printf "ind %d = lhs %s\n" i (str_lhs lhs_of_ind.(i) str_non_ter)
  done


let make_grams_actions g nbr array_nt_prio kernel_nt kernel_t reducible g_lhs g_rhs lhs_t actions lhs_of_ind =
  let gl_len = (Array.length g)+1 in
  let gram_lhs = Array.make gl_len ([],None) in
  (* The last cell of the array will be kept ([],None) and reserved
  for the non terminals appearing in the rhs of the "seed" items,
  i.e. kernel items of the initial state, when the automaton is
  generated for a modification of the grammar. *)
  
  let g1 rn_set (rn,_) = Int_set.add rn rn_set in
  
  let rn_set = List.fold_left g1 Int_set.empty kernel_nt in
  let rn_set = List.fold_left g1 rn_set kernel_t in
  
  let reducible = List.filter
    (fun (rn,_) -> Array.length g_rhs.(rn)>0) reducible
  in
  
  let rn_set = List.fold_left g1 rn_set reducible in
  
  let g2 rn (rn_map1,rn_map2,i) =
    (Int_map.add rn i rn_map1),
    (Int_map.add i rn rn_map2), i+1
    in
  
  let rn_map1,rn_map2,ir_nb =
    Int_set.fold g2 rn_set (Int_map.empty,Int_map.empty,0)
  in
  
  let gram_rhs = Array.make (ir_nb+nbr) [||] in
  let lhs_table = Array.make (ir_nb+nbr) dummy_lhs in
  let new_actions = Array.make (ir_nb+nbr)
    [Dypgen_action (fun ol _ _ d dd ld _ pd _ ->
      (List.hd ol,false,false,d,dd,ld,[],[],pd,None,None))]
  in
  
  let correct_rhs rhs =
    let len = Array.length rhs in
    let new_rhs = Array.make len (Ter 0) in
    for i=0 to len-1 do match rhs.(i) with
      | Ter _ -> new_rhs.(i) <- rhs.(i)
      | Non_ter nt -> new_rhs.(i) <-
          Non_ter (new_rhs_lit nt array_nt_prio (gl_len-1))
    done;
    new_rhs
  in
  
  for i=0 to ir_nb-1 do
    (let rn = Int_map.find i rn_map2 in
    new_actions.(i) <- actions.(rn);
    gram_rhs.(i) <- correct_rhs g_rhs.(rn);
    lhs_table.(i) <- lhs_t.(rn))
  done;
  
  let g3 (rn,x) = ((Int_map.find rn rn_map1),x) in
  
  let kernel_nt = List.map g3 kernel_nt in
  let kernel_t = List.map g3 kernel_t in
  let reducible = List.map g3 reducible in
  
  let rn = ref ir_nb in
  
  let f i rhs ac =
    gram_rhs.(!rn) <- rhs;
    new_actions.(!rn) <- ac;
    lhs_table.(!rn) <- lhs_of_ind.(i);
    let (rnl,iop) = gram_lhs.(i) in
    (if Array.length rhs > 0 then gram_lhs.(i) <- (!rn::rnl,iop)
    else gram_lhs.(i) <- (rnl,Some !rn));
    incr rn
  in
  for i=0 to (Array.length g)-1 do
    F.Map_rhs.iter (f i) g.(i)
  done;
  
  (*print_grammar gram_rhs lhs_table;
  print_g g lhs_of_ind;
  print_lhs_of_ind lhs_of_ind;
  print_gram_lhs gram_lhs lhs_of_ind;*)
  
  gram_lhs, gram_rhs, lhs_table, new_actions, kernel_nt,
  kernel_t, reducible, rn_map1


let make_grammar ral prio_dat str_non_ter =
  let user_g = update_user_g ral Urule_map.empty in
  let
   g,array_nt_prio,user_nt_nb,ist_nt_nb,
   nt_of_ind,non_ter_of_ind,prio_of_ind,lhs_of_ind,nbr
     = make_real_grammar user_g prio_dat str_non_ter
  in
  let gram_lhs,gram_rhs,lhs_table,actions,_,_,_,_ =
    make_grams_actions g nbr array_nt_prio [] [] []
    [||] [||] [||] [||] lhs_of_ind
  in
  let po_array = create_po user_g user_nt_nb str_non_ter in
  gram_lhs,gram_rhs,lhs_table,actions,user_nt_nb,ist_nt_nb,po_array,
  user_g,array_nt_prio,nt_of_ind,non_ter_of_ind,prio_of_ind,
  lhs_of_ind



let create_parsing_device rapf_list priority_data aut_kind global_data local_data datadyn str_non_ter cons_of_nt =
  let gram_lhs,gram_rhs,lhs_table,actions,user_nt_nb,ist_nt_nb,
    po_array,user_g, array_nt_prio,nt_of_ind,non_ter_of_ind,
    prio_of_ind,lhs_of_ind =
    make_grammar rapf_list priority_data str_non_ter
  in
  create_parsing_device_bis gram_lhs gram_rhs lhs_table actions aut_kind
    global_data local_data priority_data
    user_nt_nb po_array user_g datadyn array_nt_prio nt_of_ind
    non_ter_of_ind prio_of_ind lhs_of_ind 0 ist_nt_nb str_non_ter
    cons_of_nt


(** UPDATE AUTOMATON used in reduceViaPath to change the grammar and the automaton
    when new rule_bis are added and old ones are removed. *)

let remove_from_user_g rl user_g =
  let f user_g r = Urule_map.remove r user_g in
  List.fold_left f user_g rl

let build_nt_to_add gram_rhs r_L item_list lhslists prio_dat array_nt_prio =
  let nta nt_to_add (rn,dp) = match gram_rhs.(rn).(dp) with
    | Non_ter nt ->
        let lhs_l =
          comp_lhslist nt lhslists prio_dat array_nt_prio
        in
        let g1 nt_to_add ind =
          Int_set.add ind nt_to_add
        in
        let g2 nt_to_add lhs =
          let ind_list = r_L.(ind_of_lhs lhs) in
          List.fold_left g1 nt_to_add ind_list
        in
        List.fold_left g2 nt_to_add lhs_l
    | _ -> assert false
  in
  List.fold_left nta Int_set.empty item_list


let str_user_rhs rhs =
  let rec aux s rhs = match rhs with
    | [] -> s
    | (Non_ter (nt,_))::tl -> aux (s^" "^(string_of_int nt)) tl
    | (Ter t)::tl -> aux (s^" "^(E.str_token_name t)) tl
  in
  aux "" rhs

let str_user_rule (lhs,rhs,_) =
  (string_of_int lhs)^" -> "^(str_user_rhs rhs)

let print_ral ral =
  let f (r,a) = print_endline (str_user_rule r) in
  List.iter f ral




let update_parsing_device parsing_device ral_add r_remove newdata newdatadyn
    newlocal_data newprio lit_trans g_nb kernel_nt kernel_t reducible =
  
  (*print_ral ral_add;*)
  
  let user_g = remove_from_user_g r_remove parsing_device.user_g in
  let user_g = update_user_g ral_add user_g in
  
  let str_non_ter = Array.make newdatadyn.nt_num "" in
  let f str_nt (i,_,_) = str_non_ter.(i) <- str_nt in
  String_map.iter f newdatadyn.nt_map;
  
  let
    g,array_nt_prio,user_nt_nb,ist_nt_nb,
    nt_of_ind,non_ter_of_ind,prio_of_ind,lhs_of_ind,nbr =
    make_real_grammar user_g newprio str_non_ter
  in
  
  (*print_endline "previous grammar:";
  print_grammar stdout parsing_device.gram_rhs
    parsing_device.lhs_table parsing_device.str_non_ter;
  print_endline "* end of previous grammar *";
  print_endline "previous lhs_of_ind:";
  for i=0 to (Array.length parsing_device.lhs_of_ind)-1 do
    Printf.printf "  %d : %s\n" i
      (str_lhs parsing_device.lhs_of_ind.(i)
       parsing_device.str_non_ter)
  done;
  print_endline "* end of previous lhs_of_ind *";*)
  
  let gram_lhs,gram_rhs,lhs_table,actions,kernel_nt,kernel_t,
    reducible,rn_map =
    make_grams_actions g nbr array_nt_prio kernel_nt kernel_t reducible
      parsing_device.gram_lhs parsing_device.gram_rhs
      parsing_device.lhs_table parsing_device.actions lhs_of_ind
  in
  
  (*print_endline "new grammar:";
  print_grammar stdout gram_rhs lhs_table str_non_ter;
  print_endline "* end of new, grammar *";
  print_endline "new lhs_of_ind:";
  for i=0 to (Array.length lhs_of_ind)-1 do
    Printf.printf "  %d : %s\n" i
      (str_lhs lhs_of_ind.(i) str_non_ter)
  done;
  print_endline "* end of new lhs_of_ind *";*)
  
  let po_array = create_po user_g user_nt_nb str_non_ter in
  
  let first_memo = Array.make ist_nt_nb None in
  
  (*let time1 = Sys.time () in
  compute_first first_memo gram nt_nb prio_dat array_nt_prio lhs_of_ind;
  let time2 = Sys.time () in
  Printf.printf "first computed, %.3f sec\n" (time2-.time1);*)
  
  let lhslists = lhslists_init ist_nt_nb in
  let time1 = Sys.time () in
  let _, r_L = compute_L gram_rhs gram_lhs lhslists
    newprio array_nt_prio first_memo
  in
  let time2 = Sys.time () in
  if !dypgen_verbose>1 then
    Printf.fprintf !log_channel "r_L computed, %.3f sec\n"
      (time2-.time1);
  let nt_to_add =
    build_nt_to_add gram_rhs r_L kernel_nt (*(kernel_nt@kernel_t)*)
      lhslists newprio array_nt_prio
  in
  let init_is_updated_parsing_device,it_nb =
    { reducible = reducible;
      kernel_nt = kernel_nt;
      kernel_t = kernel_t;
      non_kernel = []
    },
    (List.length kernel_nt)+(List.length kernel_t)+
    (List.length reducible)
    (*let f ind irhs tns ((is:IS.t),it_nb) =
      let (_,dp) = irhs in
      if dp=0 then is,it_nb
      else
        (IS.insert ind irhs tns is),(it_nb+1)
    in
    IS.fold f s_rightSib.items (IS.make nt_nb,0)*)
  in
  (* All the kernel items are selected in the current state after
   the reduction happened. An items set is made with them and
   used as the starting state of a new automaton. *)
  
  let cons_of_nt = Array.make newdatadyn.nt_num 0 in
  let aux _ (i,cons_i,_) =
    cons_of_nt.(i) <- cons_i
  in
  String_map.iter aux newdatadyn.nt_map;
  
  (*print_endline "cons_of_nt array:";
  for i=0 to (Array.length cons_of_nt)-1 do
    print_endline (string_of_int cons_of_nt.(i))
  done;
  print_endline "end of cons_of_nt array";*)
          (*print_endline "lhs_of_ind:";
          for i=0 to (Array.length lhs_of_ind)-1 do
            Printf.printf "  %d : %s\n" i
              (str_lhs lhs_of_ind.(i)
               str_non_ter)
          done;
          print_endline "* end of lhs_of_ind *";*)
  
  create_parsing_device_with_init gram_rhs gram_lhs lhs_table actions r_L
    user_g newdata newdatadyn newlocal_data parsing_device.prio
    init_is_updated_parsing_device lit_trans user_nt_nb
    po_array it_nb array_nt_prio nt_of_ind non_ter_of_ind
    prio_of_ind lhs_of_ind g_nb ist_nt_nb lhslists nt_to_add str_non_ter
    cons_of_nt,
  rn_map

(* ******* CE QUI PRECEDE EST A DEPLACER DANS UN AUTRE FICHIER ****** *)







type ('obj,'data,'local_data) vertex_lab = {
  state_nb : int;
  pdev : ('obj,'data,'local_data) parsing_device;
  sn_nb : int;
  first_token : int;
  last_token : int;
  lexer_pos : (Lexing.position * Lexing.position);
  prio_imprint : F.prio_imprint
}
(* sn_nb is the number of the stack node, which is useful to distinguish
the stack nodes.
first_token is the number of the first token of the part of the input corresponding to this stack node.
last_token is the number of the last token of the part of the input corresponding to this stack node.
These two fields are used to determine the order of the reductions.

prio_imprint : stack node should not be merged if there is an item i and
a non terminal nt in the rhs of i before the 'dot' such that nt was yielded
with two different priorities. This ensures that when two stack nodes are
merged, the "history of priorities" is the same. Thus, for any stack nodes
each items is either 'valid' with respect to the priorities of all paths
from this node or it is not valid for all paths. This validity is stored
in the bool. The priority list is the history of priorities.
Before being merged, two stack nodes must have the same prio_imprint,
see the function find_rightSib
*)

type 'obj edge_lab = 'obj list * int

type ('a,'b) path = ('a,'b) Gs.vertex * (('a,'b) Gs.edge list) * int
(** Gs.vertex is for the start of the path, int is the token number, i.e.
the first token in the part of the input which would be reduced if a reduction
along this path of the graph-structured stack happens. *)

(** [find_paths] returns a list of couples ([path],[token_nb]), where a path is
    a list of edges of the graph structured stack [gs] . The returned paths
    have the following properties : they begin at stack node [sn], their length
    is [len], the nodes along each path contain states which associated
    literals are in [litl], these literals take place along the path in the
    same order as in the list [litl] (actually in reverse). These paths are the
    ones along which a reduction can be performed by a production rule which
    rhs is [litl].
    [token_nb] is the token number of the leftmost stack node of a path, i.e.
    the dest stack node of the edge which is at the end of the list of edges
    which is [path]. It is the number of the token which is the first in the
    part of the input which would be reduced by the rule given as argument.
    [find_paths] is used in [doReductions] and in [insertLimitedReductions]
    and in [insertLimitedReductions2]. *)
let find_paths (sn:('a,'b) Gs.vertex) ind (rhs:rhs) rn =
  let b = prio_imprint_check rn
    sn.vertex_label.pdev.gram_rhs
    sn.vertex_label.prio_imprint in
  if b = false then [] else
  let rec aux n succ path =
    if n = 0 then match path with
      | e::_ -> let s = e.dest in [path,(s.vertex_label).last_token]
      | [] -> [[],-1]
    else
    match succ with
      | [] -> []
      | e::t ->
          let sn2 = e.dest in
          let succ2 = sn2.succ_edges in
          (aux (n-1) succ2 (e::path))@(aux n t path)
  in
  aux (Array.length rhs) sn.succ_edges []

let stack_node_equal sn1 sn2 = sn1.vertex_label.sn_nb = sn2.vertex_label.sn_nb

let edge_equal e1 e2 = (snd e1.edge_label) = (snd e2.edge_label)
let edge_list_equal el1 el2 = List.for_all2 edge_equal el1 el2

(* revcat a b = rev a @ b *)
let rec revcat a b = match a with
  | [] -> b
  | h :: t -> revcat t (h::b)

(** Maintains a partially ordered list of couples (path,rule_bis), where a path is
    a list of edges of the graph structured stack. This function inserts the couple
    of the path [p] and the rule_bis [r] in the list [l] at its right place. The
    partial order is the field [po] of the state which is held by the source
    stack node of the first edge of the path [p].
    The partial order is implemented as a 2 dim array of type bool option.
    The need for this partial order is explained in Scott McPeak's report.
    A better data structure than a list should be used. *)
let insert_partially_ordered l (((start_node,p,token_nb):('a,'b) path),(ind,rhs), (rn,tns)) =
  let parsing_device = start_node.vertex_label.pdev in
  let non_ter_of_ind = parsing_device.non_ter_of_ind in
  if non_ter_of_ind.(ind) = non_terminal_startprime then l (* Do not reduce with S'->S *)
  else
  let rec aux result l = match l with
    | [] -> revcat result [((start_node,p,token_nb),(ind,rhs),(tns,rn))]
    | ((start1,p1,tnb1),(ind1,rhs1),(tns1,rn1))::tl ->
        if tnb1<token_nb then (* yes, this is the good order *)
          revcat result (((start_node,p,token_nb),(ind,rhs),(tns,rn))::l)
        else
        if tnb1>token_nb
        then aux (((start1,p1,tnb1),(ind1,rhs1),(tns1,rn1))::result) tl
        else
        let parsing_device1 = start1.vertex_label.pdev in
        if parsing_device.g_nb <> parsing_device1.g_nb
        then aux (((start1,p1,tnb1),(ind1,rhs1),(tns1,rn1))::result) tl
        else
        (*let (unt1,_,_),(unt,_,_) = nt1,nt in*)
        (*let rel = Map_ntc.find ((non_ter_of_nt nt1),(non_ter_of_nt nt))
          parsing_device.po in*)
        let rel =
          match parsing_device.po.(non_ter_of_ind.(ind1)).(non_ter_of_ind.(ind)) with
          | Some b -> b
          | None -> assert false
        in
        if rel then revcat result
         (((start_node,p,token_nb),(ind,rhs),(tns,rn))::l)
        else if non_ter_of_ind.(ind)=non_ter_of_ind.(ind1) && rhs=rhs1 &&
          (stack_node_equal start_node start1) && (edge_list_equal p p1)
        then revcat result l
        else aux (((start1,p1,tnb1),(ind1,rhs1),(tns1,rn1))::result) tl
  in
  aux [] l

(* The following functions are used when pathList is a queue, using 
the module Path_queue. (but it seems to be slower) *)
(*let compare_path path path1 =
  let ((start_node,p,token_nb),(ind,rhs)) = path in
  let ((start1,p1,tnb1),(ind1,rhs1)) = path1 in
  if token_nb<tnb1 then -1
  else if token_nb>tnb1 then 1 else
  let parsing_device = start_node.vertex_label.pdev in
  let parsing_device1 = start1.vertex_label.pdev in
  if parsing_device.g_nb<parsing_device1.g_nb then -1
  else if parsing_device.g_nb>parsing_device1.g_nb then 1
  else
  let ntoi = parsing_device.non_ter_of_ind in
  let rel =
    match parsing_device.po.(ntoi.(ind1)).(ntoi.(ind)) with
    | Some b -> b
    | None -> assert false
  in
  if rel then -1 else
  let rel =
    match parsing_device.po.(ntoi.(ind)).(ntoi.(ind1)) with
    | Some b -> b
    | None -> assert false
  in
  if rel then 1 else
  let c = Pervasives.compare (ind,rhs) (ind1,rhs1) in
  if c<>0 then c else
  let c = Pervasives.compare start_node.vertex_label.sn_nb
    start1.vertex_label.sn_nb in
  if c<>0 then c else
  let rec aux l1 l2 = match l1,l2 with
    | [],[] -> 0
    | _,[] -> 1
    | [],_ -> -1
    | (e1::t1),(e2::t2) ->
        let c = Pervasives.compare (snd e1.edge_label)
          (snd e2.edge_label) in
        if c<>0 then c else aux t1 t2
  in aux p p1

let insert_path path path_queue =
  let (start_node,_,_),(ind,_) = path in
  let pdev = start_node.vertex_label.pdev in
  let ntoi = pdev.non_ter_of_ind in
  if ntoi.(ind) = non_terminal_startprime then path_queue else
  (* Do not reduce with S'->S *)
  Path_queue.insert compare_path path path_queue

let pop_path path_queue =
  Path_queue.pop compare_path path_queue*)

let print_path sn p =
  let snnb = sn.vertex_label.sn_nb in
  let () = Printf.fprintf !log_channel "sn:%d; " snnb in flush_all ();
  let f e =
    let _,ednb = e.edge_label in
    Printf.fprintf !log_channel "%d " ednb
  in
  let () = List.iter f p in
  Printf.fprintf !log_channel "\n"

let insertLimitedReductions pathList link t topmost dummy_token_name =
  let _,edge_nb = link.edge_label in
  let aux1 pathList sn =
    let v,pdev = sn.vertex_label.state_nb,sn.vertex_label.pdev in
    let aux2 pathList (rn,tns) =
      (*if && (!automaton_kind=LR0 || (TNS.mem t tns) ||
         (TNS.mem dummy_token_name tns)) || (rule_kind=Dynamic_rule)) then*)
        let rhs,ind = pdev.gram_rhs.(rn), ind_of_lhs pdev.lhs_table.(rn) in
        let paths = find_paths sn ind rhs rn in
        let aux3 pathList (p,tnb) =
          if List.exists (function e -> (snd e.edge_label)=edge_nb) p then
            let () = if !dypgen_verbose>2 then print_path sn p else () in
            insert_partially_ordered pathList ((sn,p,tnb),(ind,rhs),(tns,rn))
            (*insert_path ((sn,p,tnb),(ind,rhs)) pathList*)
          else pathList
        in
        List.fold_left aux3 pathList paths
      (*else pathList*)
    in
    List.fold_left aux2 pathList pdev.table_it.(v).reducible
  in
  List.fold_left aux1 pathList topmost

  (*let _,edge_nb = link.edge_label in
  let aux1 pathList sn =
    let v,aut = sn.vertex_label.state_nb,sn.vertex_label.pdev in
    let aux2 ind (rhs,dp) tns pathList =
      if dp = Array.length rhs (*&& (!automaton_kind=LR0 || (TNS.mem t tns) ||
         (TNS.mem dummy_token_name tns)) || (rule_kind=Dynamic_rule))*) then
        let paths = find_paths sn ind rhs in
        let aux3 pathList (p,tnb) =
          if List.exists (function e -> (snd e.edge_label)=edge_nb) p then
            let () = if !dypgen_verbose>2 then print_path sn p else () in
            insert_partially_ordered pathList ((sn,p,tnb),(ind,rhs))
            (*insert_path ((sn,p,tnb),(ind,rhs)) pathList*)
          else pathList
        in
        List.fold_left aux3 pathList paths
      else pathList
    in
    IS.fold aux2 v.items pathList
  in
  List.fold_left aux1 pathList topmost*)

let insertLimitedReductions2 pathList t sn dummy_token_name =
  let v,pdev = sn.vertex_label.state_nb,sn.vertex_label.pdev in
  let aux2 pathList (rn,tns) =
    (*if && (!automaton_kind=LR0 || (TNS.mem t tns) ||
         (TNS.mem dummy_token_name tns)) || (rule_kind=Dynamic_rule)) then*)
      let rhs,ind = pdev.gram_rhs.(rn), ind_of_lhs pdev.lhs_table.(rn) in
      let paths = find_paths sn ind rhs rn in
      let aux3 pathList (p,tnb) =
        let () = if !dypgen_verbose>2 then print_path sn p else () in
        insert_partially_ordered pathList ((sn,p,tnb),(ind,rhs),(tns,rn))
        (*insert_path ((sn,p,tnb),(ind,rhs)) pathList*)
      in
      List.fold_left aux3 pathList paths
    (*else pathList*)
  in
  List.fold_left aux2 pathList pdev.table_it.(v).reducible

  (*let v,pdev = sn.vertex_label.state_nb,sn.vertex_label.pdev in
  let aux2 ind (rhs,dp) tns pathList =
    if dp = Array.length rhs (*&& (!automaton_kind=LR0 || (TNS.mem t tns) ||
         (TNS.mem dummy_token_name tns)) || (rule_kind=Dynamic_rule))*) then
      let paths = find_paths sn ind rhs in
      let aux3 pathList (p,tnb) =
        let () = if !dypgen_verbose>2 then print_path sn p else () in
        insert_partially_ordered pathList ((sn,p,tnb),(ind,rhs))
        (*insert_path ((sn,p,tnb),(ind,rhs)) pathList*)
      in
      List.fold_left aux3 pathList paths
    else pathList
  in
  IS.fold aux2 v.items pathList*)

exception Find_rightSib_failed

(** [find_rightSib] is used in [reduceViaPath] and [doShift].
    Its purpose is to find in the stack nodes list [snl] a stack node which
    holds the same grammar as [g_leftSib] and which holds a state which has an
    items set equal to [is_rightSib]. *)
let find_rightSib prio_imp g_nb_rightSib st_nb datadyn_rightSib snl
  gd ld gd_equal ld_equal =
  let rec aux snl = match snl with
    | [] -> raise Find_rightSib_failed
    | sn::tl ->
        let (v_nb,parsing_device, sn_prio_imp) =
          sn.vertex_label.state_nb, sn.vertex_label.pdev,
          sn.vertex_label.prio_imprint
        in
        if v_nb = st_nb && parsing_device.g_nb = g_nb_rightSib &&
          parsing_device.datadyn == datadyn_rightSib &&
          gd_equal parsing_device.data gd &&
          ld_equal parsing_device.local_data ld &&
          (prio_imp_equal prio_imp sn_prio_imp)
        then sn
        else aux tl
  in
  aux snl

(*let rec last_in_list l =  match l with
  | [x] -> x
  | _::tl -> last_in_list tl
  | [] -> failwith "error last_in_list, empty list"*)

(*let replace_in_pathList pathList edge_nb new_link =
  let aux2 e = if snd e.edge_label = edge_nb then new_link else e in
  let aux1 ((sn,edl,tnb),r) = ((sn,list_map aux2 edl,tnb),r) in
  list_map aux1 pathList*)


let print_sn sn =
  let chan = !log_stack_channel in
  let { state_nb = v; pdev = parsing_device; sn_nb = snnb;
    first_token = first_token; last_token = last_token;
    prio_imprint = prio_imp } = sn.vertex_label
  in
  let lhs_of_ind = parsing_device.lhs_of_ind in
  let gram_rhs = parsing_device.gram_rhs in
  let lhs_table = parsing_device.lhs_table in
  let is = parsing_device.table_it.(v) in
  let str_non_ter = parsing_device.str_non_ter in
  output_string chan "____________________________________\n";
  let () = Printf.fprintf chan "STACK NODE <%d>, first token: %d, last token:%d\n" snnb first_token last_token in
  output_string chan "\n";
  (*let () = print_state v lhs_of_ind in*)
  print_item_set chan is gram_rhs lhs_table lhs_of_ind str_non_ter;
  let () = Printf.fprintf chan "  state number: %d\n" v in
  output_string chan "\n";
  output_string chan " priority imprint:\n";
  print_prio_imp chan gram_rhs lhs_table prio_imp str_non_ter;
  let f3 f4 ed =
    let _,ednb = ed.edge_label in
    let { state_nb = v; sn_nb = snnb} = f4 ed in
    Printf.fprintf chan "  sn:%d ed:%d st:%d\n" snnb ednb v
  in
  output_string chan "\n";
  output_string chan " predecessor stack nodes :\n";
  (*let () = List.iter (f3 (fun e -> e.source.vertex_label))
    sn.pred_edges in
  output_string chan "\n";*)
  output_string chan " successor stack nodes :\n";
  let () = List.iter (f3 (fun e -> e.dest.vertex_label)) sn.succ_edges in
  output_string chan "\n"




open Lexing

exception Find_link_failed

let complete_reduction (*gs*) pathList topmost leftSib pdev_rightSib
    v_rightSib new_obj t nt lexer_pos prio counters data_equal
    dummy_token_name prio_imp_lS is_lS first_token merge_map cons_index =
  countred := !countred + 1;
(*   let _ = Printf.fprintf !log_channel "complete_reduction called\n" in *)
  let gram_rhs, lhs_table = pdev_rightSib.gram_rhs, pdev_rightSib.lhs_table in
  let prio_imp,b =
    new_prio_imprint pdev_rightSib.prio
      prio_imp_lS
      is_lS
      (Non_ter nt) prio
      gram_rhs
      lhs_table leftSib.vertex_label.pdev.lhs_of_ind
      leftSib.vertex_label.pdev.str_non_ter
  in
  (*if !dypgen_verbose>2 then
    (Printf.fprintf !log_channel "new_prio_imprint returned:\n";
     print_prio_imp !log_channel pdev_rightSib.lhs_of_ind prio_imp;
     output_string !log_channel "\n");*)
  if b=false
  then
    ((*Printf.fprintf !log_channel "complete_reduction b=false\n";
    (*Printf.fprintf !log_channel "state nb : %d\n"
      leftSib.vertex_label.state_nb;*)
    print_prio_imp !log_channel gram_rhs lhs_table prio_imp_lS;
    output_string !log_channel "\n";
    print_item_set !log_channel is_lS gram_rhs lhs_table
      pdev_rightSib.lhs_of_ind;
    output_string !log_channel "\n";
    print_prio_imp !log_channel gram_rhs lhs_table prio_imp_lS;
    output_string !log_channel "\n";*)
    (*gs,*)pathList,topmost,counters,merge_map)
  else
  try
    let rightSib =
      find_rightSib prio_imp pdev_rightSib.g_nb v_rightSib
        pdev_rightSib.datadyn topmost 0 0
        (fun _ _ -> true) (fun _ _ -> true)
    in
    let find_link (*gs*) rightSib leftSib =
      let rec aux el = match el with
        | [] -> raise Find_link_failed
        | e::tl -> if (stack_node_equal e.dest leftSib) then e else aux tl
      in
      aux rightSib.succ_edges
    in
    try
      let link = find_link (*gs*) rightSib leftSib in
      (*let _ = Printf.fprintf !log_channel "complete_reduction called, merge\n" in*)
      let link_label = link.edge_label in
      let old_obj_list = (fst link_label) in
      let edge_nb = snd link_label in
      if (!dypgen_verbose>2 || E.merge_warning) && old_obj_list<>[] then
        (let (start_pos,end_pos) = lexer_pos in
        let col1 = start_pos.pos_cnum - start_pos.pos_bol in
        let col2 = end_pos.pos_cnum - end_pos.pos_bol in
        Printf.fprintf !log_channel "Warning: parser merges non terminal `%s'%s\nin file \"%s\", from l:%d,c:%d to l:%d,c:%d\n"
        (str_non_terminal nt pdev_rightSib.str_non_ter)
        (str_with_priority prio) start_pos.pos_fname start_pos.pos_lnum
        col1 end_pos.pos_lnum col2);
      
      let merge_item =
        try
          let (sn,_,_,objdata_list) = Int_map.find edge_nb merge_map in
          sn,link,cons_index,
          (new_obj,rightSib.vertex_label.pdev.data,
            rightSib.vertex_label.pdev.local_data)::objdata_list
        with Not_found ->
          let old_obj = match old_obj_list with
            | [o] -> o
            | _ -> assert false
          in
          rightSib,link,cons_index,
          [(new_obj,rightSib.vertex_label.pdev.data,
            rightSib.vertex_label.pdev.local_data);
          (old_obj,pdev_rightSib.data,pdev_rightSib.local_data)]
      in
      let merge_map = Int_map.add edge_nb merge_item merge_map in
      
      (*let merge = merge_array.(cons_index) in
      let new_obj_list,global_data,local_data = match
        merge old_obj_list pdev_rightSib.data pdev_rightSib.local_data
        new_obj rightSib.vertex_label.pdev.data
        rightSib.vertex_label.pdev.local_data with
          | Merge merge_res -> merge_res
          | Dont_merge -> raise Find_rightSib_failed
      in
      let () = rightSib.vertex_label <- { rightSib.vertex_label with
        pdev = { rightSib.vertex_label.pdev with
          data = global_data ; local_data = local_data }}
      in
      let () = link.edge_label <- (new_obj_list,edge_nb) in*)
      pathList,topmost,counters,merge_map
    with
      Find_link_failed ->
      (*let _ = Printf.fprintf !log_channel
        "complete_reduction called, Find_link_failed\n" in*)
      if data_equal.global_data_equal pdev_rightSib.data
        rightSib.vertex_label.pdev.data &&
        data_equal.local_data_equal pdev_rightSib.local_data
        rightSib.vertex_label.pdev.local_data then ()
        else raise Find_rightSib_failed;
      let link = Gs.create_e rightSib ([new_obj],counters.counted) leftSib in
      if (!dypgen_verbose>2) then
        Printf.fprintf !log_stack_channel "Edge %d created from <%d> to <%d>\n"
          counters.counted rightSib.vertex_label.sn_nb leftSib.vertex_label.sn_nb;
      let counters = {counters with counted = counters.counted+1 } in
      let pathList =
        insertLimitedReductions pathList link t topmost
          dummy_token_name
      in
      pathList,topmost,counters,merge_map
  with
    Find_rightSib_failed ->
    (*let _ = Printf.fprintf !log_channel
      "complete_reduction called, Find_rightSib_failed\n" in*)
    let rightSib = Gs.create_v {
      state_nb = v_rightSib;
      pdev = pdev_rightSib;
      sn_nb = counters.countsn;
      first_token = first_token;
      last_token = counters.count_token;
      lexer_pos = lexer_pos;
      prio_imprint = prio_imp }
    in
    let _ = Gs.create_e rightSib ([new_obj],counters.counted) leftSib in
    if !dypgen_verbose>2 then print_sn rightSib;
    let counters = { counters with
      countsn = counters.countsn+1;
      counted = counters.counted+1 }
    in
    (*let gs = rightSib::gs in*)
    let topmost = rightSib::topmost in
    let pathList =
      insertLimitedReductions2 pathList t rightSib
       dummy_token_name
    in
    pathList,topmost,counters,merge_map



let position_map p start_node =
  let rec aux res l = match l with
    | [] -> List.rev (start_node.vertex_label.lexer_pos::res)
    | e::t -> aux (e.dest.vertex_label.lexer_pos::res) t
  in
  try aux [] (List.tl p)
  with Failure _ -> [start_node.vertex_label.lexer_pos]



let left_rec_rule lhs rhs =
  try match rhs.(0) with
    | Non_ter nt -> nt_of_lit nt = nt_of_lhs lhs
    | _ -> false
  with Invalid_argument _ -> false



let reduceViaPath (((start_node:('a,'b) Gs.vertex),(p:('a,'b) Gs.edge list),_),(ind,rhs),(rn,tns)) (t:token_name) (*(gs:(('a,'b) Gs.vertex) list)*) pathList (topmost:('a,'b) Gs.vertex list) counters data_equal dummy_token_name test_cons str_cons merge_map =
  
  if !dypgen_verbose>2 then
    (Printf.fprintf !log_channel "reduceViaPath called, start_node=%d\n  "
      start_node.vertex_label.sn_nb;
    print_path start_node p;
    flush_all ());
  
  (*let position_map e = e.source.vertex_label.lexer_pos in
  let position_list = list_map position_map p in*)
  let first_token = match p with
    | [] -> counters.count_token
    | [_] -> start_node.vertex_label.first_token
    | _::h::_ -> h.dest.vertex_label.first_token
  in
  let position_list = position_map p start_node in
  let end_node_pos = try fst (List.hd position_list)
    with Failure _ -> Lexing.dummy_pos in
  let start_node_pos = snd start_node.vertex_label.lexer_pos in
  let symbol_pos = (end_node_pos,start_node_pos) in
  (* ^ this is the good order actually ^ *)
  let leftSib, snd_node = match p with
    | [] -> start_node, start_node
    | [h] -> h.dest, start_node
    | h1::h2::_ -> h1.dest, h2.dest
  in
  let v,pdev_leftSib =
    leftSib.vertex_label.state_nb,leftSib.vertex_label.pdev in
  let prio_dat = pdev_leftSib.prio in
  let prio = pdev_leftSib.prio_of_ind.(ind) in
  let nt_of_ind = pdev_leftSib.nt_of_ind in
  (* collect_objs collects objects along the path p.
     The head of the list corresponds to the leftmost
     object in gs. *)
  let rec collect_objs p = match p with
    | e::tl -> let obj_ll = collect_objs tl in
        let obj_list = fst e.edge_label in
        let f1 new_obj_ll obj_l =
          let f2 new_obj_ll obj =
            (obj::obj_l)::new_obj_ll
          in
          List.fold_left f2 new_obj_ll obj_list
        in
        let obj_ll = List.fold_left f1 [] obj_ll in
        obj_ll
    | [] -> [[]]
  in
  let obj_ll = collect_objs p in

  (*let ac_l = Map_rhs.find rhs pdev_leftSib.g.(ind) in*)
  let ac_l = start_node.vertex_label.pdev.actions.(rn) in
  (*let succ = v.succ_states in*)
  (*let v_rightSib = Li_map.find (Non_ter nt_of_ind.(ind)) succ  in*)
  let non_ter = fst_of_lhs pdev_leftSib.lhs_of_ind.(ind) in
  let ind_1 = ind_of_nt (nt_of_lhs pdev_leftSib.lhs_of_ind.(ind)) in
  let v_rightSib = pdev_leftSib.table.(v).(1).(ind_1) in
  let last_parsing_device = start_node.vertex_label.pdev in
  
  let foldfun (pathList,topmost,will_shift,counters,merge_map) toPass =
    try
      let rec try_actions ac_l = match ac_l with
        | (Dypgen_action f)::tl_ac_l ->
           let print_s outchan =
             print_table_state outchan
               start_node.vertex_label.state_nb
               last_parsing_device.table
               last_parsing_device.table_it
               last_parsing_device.table_lit_trans
               last_parsing_device.gram_rhs
               last_parsing_device.lhs_table
               last_parsing_device.lhs_of_ind
               last_parsing_device.str_non_ter
               last_parsing_device.nt_of_ind
            in
           let print_g outchan =
             print_grammar outchan
               last_parsing_device.gram_rhs
               last_parsing_device.lhs_table
               last_parsing_device.str_non_ter
           in
           (try
              (*Printf.fprintf !log_channel "f stack node=%d\n"
                start_node.vertex_label.sn_nb;*)
              let x = f toPass symbol_pos position_list last_parsing_device.data
              pdev_leftSib.datadyn pdev_leftSib.local_data
              last_parsing_device.local_data prio_dat
              { prt_state = print_s;
              prt_grammar = print_g } in
              (*Printf.fprintf !log_channel "f stack node=%d\n"
                start_node.vertex_label.sn_nb;*)
              x
           with Giveup -> try_actions tl_ac_l)
        | [] -> raise Giveup
      in
      let new_obj, will_shift2, keep_gram, newdata, newdatadyn, newlocal_data,
        rapf_add, r_remove, newprio, chan_s, chan_g = try_actions ac_l
      in
      let cons_index = try pdev_leftSib.cons_of_nt.(non_ter)
        with e -> (Printf.printf "dyp.ml l:1962, error cons_of_nt:%d\n"
          (Array.length pdev_leftSib.cons_of_nt); raise e)
      in
      if test_cons.(cons_index) new_obj = false then
        let sr = str_rule rn pdev_leftSib.gram_rhs
          pdev_leftSib.lhs_table pdev_leftSib.str_non_ter
        in
        let (_,cons) = Tools.find_nt
          pdev_leftSib.str_non_ter.(non_ter) pdev_leftSib.datadyn
        in
        (*let () =
          Printf.printf "cons_index: %d\nnon_ter: %d\nind: %d\nrn: %d\n"
            cons_index non_ter ind rn;
          print_endline "cons_of_nt array:";
          for i=0 to (Array.length pdev_leftSib.cons_of_nt)-1 do
            Printf.printf "  %d : %d\n"
              i pdev_leftSib.cons_of_nt.(i)
          done;
          print_endline "* end of cons_of_nt array *";
          print_endline "str_non_ter:";
          for i=0 to (Array.length pdev_leftSib.str_non_ter)-1 do
            Printf.printf "  %d : %s\n" i pdev_leftSib.str_non_ter.(i)
          done;
          print_endline " * end of str_non_ter *";
          print_endline "grammar:";
          print_grammar stdout pdev_leftSib.gram_rhs
            pdev_leftSib.lhs_table pdev_leftSib.str_non_ter;
          print_endline "* end of grammar *";
          print_endline "lhs_of_ind:";
          for i=0 to (Array.length pdev_leftSib.lhs_of_ind)-1 do
            Printf.printf "  %d : %s\n" i
              (str_lhs pdev_leftSib.lhs_of_ind.(i)
               pdev_leftSib.str_non_ter)
          done;
          print_endline "* end of lhs_of_ind *"
        in*)
        raise (Bad_constructor(sr,cons,(str_cons new_obj)))
      else ();
      let v_rightSib,pdev_rightSib,counters,(prio_imp_lS,is_lS) =
        if rapf_add=[] && r_remove=[] && newprio==prio_dat then
          if (TNS.mem t tns = false)&&(TNS.mem dummy_token_name tns = false)
            && !automaton_kind<>`LR0 then raise Giveup else
          match keep_gram,
            left_rec_rule pdev_leftSib.lhs_of_ind.(ind) rhs with
          | true, true
            when snd_node.vertex_label.pdev.g_nb
            = last_parsing_device.g_nb ->
              snd_node.vertex_label.state_nb,
              { snd_node.vertex_label.pdev
                with data = newdata ;
                local_data = newlocal_data ;
                datadyn = last_parsing_device.datadyn },
               counters,
              (leftSib.vertex_label.prio_imprint,
              pdev_leftSib.table_it.(v))
          | true, _ ->
              let pdev_rightSib, rn_map =
                let is = pdev_leftSib.table_it.(v_rightSib) in
                let lit_trans = pdev_leftSib.table_lit_trans.(v_rightSib) in
                (update_parsing_device
                  { last_parsing_device with
                    gram_lhs = pdev_leftSib.gram_lhs;
                    gram_rhs = pdev_leftSib.gram_rhs;
                    lhs_table = pdev_leftSib.lhs_table;
                    actions = pdev_leftSib.actions }
                  [] []
                  newdata last_parsing_device.datadyn newlocal_data
                  newprio lit_trans
                  (counters.count_g+1) is.kernel_nt is.kernel_t is.reducible)
              in
              0,pdev_rightSib,
              { counters with count_g = counters.count_g+1 },
              (change_rn leftSib.vertex_label.prio_imprint
              pdev_leftSib.table_it.(v) rn_map)
          | _ ,_ ->
              v_rightSib,{ pdev_leftSib with data = newdata ;
              local_data = newlocal_data },counters,
              (leftSib.vertex_label.prio_imprint,
              pdev_leftSib.table_it.(v))
        else
          let pdev_rightSib, rn_map =
            let is = pdev_leftSib.table_it.(v_rightSib) in
            let lit_trans = pdev_leftSib.table_lit_trans.(v_rightSib) in
              (update_parsing_device pdev_leftSib rapf_add r_remove
                newdata newdatadyn newlocal_data newprio lit_trans
                (counters.count_g+1) is.kernel_nt is.kernel_t is.reducible)
          in
          0,pdev_rightSib,
          { counters with count_g = counters.count_g+1 },
          (change_rn leftSib.vertex_label.prio_imprint
          pdev_leftSib.table_it.(v) rn_map)
      in
      (match chan_s with
        | None -> ()
        | Some chan ->
             print_table_state chan v_rightSib
               pdev_rightSib.table
               pdev_rightSib.table_it
               pdev_rightSib.table_lit_trans
               pdev_rightSib.gram_rhs
               pdev_rightSib.lhs_table
               pdev_rightSib.lhs_of_ind
               pdev_rightSib.str_non_ter
               pdev_rightSib.nt_of_ind);
      (match chan_g with
        | None -> ()
        | Some chan ->
             print_grammar chan
               pdev_rightSib.gram_rhs
               pdev_rightSib.lhs_table
               pdev_rightSib.str_non_ter);
      
      let (*gs,*)pathList,topmost,counters,merge_map =
        complete_reduction (*gs*) pathList topmost leftSib
        pdev_rightSib v_rightSib new_obj t (nt_of_ind.(ind))
        symbol_pos prio counters data_equal dummy_token_name
        prio_imp_lS is_lS first_token merge_map cons_index
      in
      (*gs,*)pathList,topmost,(will_shift2 && will_shift),counters,merge_map
    with Giveup -> ((*gs,*)pathList,topmost,will_shift,counters,merge_map)
  in
  List.fold_left foldfun (pathList,topmost,true,counters,merge_map) obj_ll



let remove_edge edge_nb sn =
  let rec aux succ_edges res = match succ_edges with
    | [] -> res
    | {edge_label = (_,n); dest = _ }::t when n=edge_nb -> res@t
    | e::t -> aux t (e::res)
  in
  sn.succ_edges <- aux sn.succ_edges []



let remove_path_edge edge_nb pathList =
  let aux1 e = match e with
    | { edge_label = (_,n) ; dest = _ } when n=edge_nb -> false
    | _ -> true
  in
  let aux2 ((_,p,_),_,_) = List.for_all aux1 p in
  List.filter aux2 pathList



let do_merge merge_map merge_array topmost pathList counters t dummy_token_name =
  let f edge_nb (sn,link,cons_index,objdata_list)
  (topmost,pathList,counters) =
    let obj_list,glo_dat,loc_dat =
      merge_array.(cons_index) objdata_list
    in
    let pdev = sn.vertex_label.pdev in
    if List.length sn.succ_edges >1 then
      (remove_edge edge_nb sn;
      if !dypgen_verbose>2 then Printf.fprintf !log_stack_channel "Edge %d removed\n" edge_nb;
      (*Printf.fprintf !log_channel "do_merge, nb de link>1, obj_datalist length=%d\n"
        (List.length objdata_list);*)
      let pathList = remove_path_edge edge_nb pathList in
      let rightSib = Gs.create_v { sn.vertex_label with
        pdev = {pdev with data = glo_dat; local_data = loc_dat };
        sn_nb = counters.countsn }
      in
      let _ = Gs.create_e rightSib (obj_list,counters.counted) link.dest in
      if !dypgen_verbose>2 then print_sn rightSib;
      let counters = {counters with
        countsn = counters.countsn+1;
        counted = counters.counted+1 }
      in
      let topmost = rightSib::topmost in
      let pathList =
        insertLimitedReductions2 pathList t rightSib
         dummy_token_name
      in
      topmost,pathList,counters)
    else
      (sn.vertex_label <- { sn.vertex_label with pdev = {pdev with
        data = glo_dat; local_data = loc_dat } };
      (*Printf.fprintf !log_channel "do_merge, nb de link=1, obj_datalist length=%d\n"
        (List.length objdata_list);*)
      link.edge_label <- (obj_list,edge_nb);
      topmost,pathList,counters)
  in
  Int_map.fold f merge_map (topmost,pathList,counters)



let compare_pr (((start_node,p,token_nb):('a,'b) path),(ind,rhs), (rn,tns))
    ((start1,p1,tnb1),(ind1,rhs1),(tns1,rn1)) =
  if tnb1<token_nb then -1
  else if tnb1>token_nb then 1
  else
  let parsing_device1 = start1.vertex_label.pdev in
  let parsing_device = start_node.vertex_label.pdev in
  if parsing_device.g_nb <> parsing_device1.g_nb then 0
  else
   let non_ter_of_ind = parsing_device.non_ter_of_ind in
   let rel =
    match parsing_device.po.(non_ter_of_ind.(ind)).(non_ter_of_ind.(ind1)) with
    | Some b -> b
    | None -> assert false
  in
  if rel then 1 else 0



let doReductions (t:token_name) (*gs*) (topmost:('a,'b) Gs.vertex list)
    entry_point counters data_equal dummy_token_name test_cons str_cons
    merge_array =
  
(* let _ = Printf.fprintf !log_channel "(doReductions) longueur topmost : %d\n" (List.length topmost) in *)

  let aux1 pathList sn =
    let st_nb,pdev = sn.vertex_label.state_nb,sn.vertex_label.pdev in
    
    (*let aux2 ind (rhs,dp) tns pathList =*)
    let aux2 pathList (rn,tns) =
      let ind = ind_of_lhs pdev.lhs_table.(rn) in
      if
        (!automaton_kind=`LR0 || t<>dummy_token_name ||
        (pdev.non_ter_of_ind.(ind))=entry_point ||
        (t=dummy_token_name && TNS.mem t tns) )
          (*(!automaton_kind=LR0 ||
          (t<>dummy_token_name && TNS.mem t tns) ||
          (pdev.non_ter_of_ind.(ind))=entry_point ||
          (t=dummy_token_name && TNS.mem t tns) )*)
          (* commented code above: for early test of the lookahead
            token, this makes parsing 5% faster but rules would need
            to be differentiated between classic and the one
            that change the grammar, because the test must not be
            performed on the latter. *)
      then
        let rhs = pdev.gram_rhs.(rn) in
        let paths =
          list_map (function (p,tnb) -> sn,p,tnb)
            (find_paths sn ind rhs rn)
        in
        let aux3 pathList p =
          insert_partially_ordered pathList (p,(ind,rhs),(tns,rn))
          (*insert_path (p,(ind,rhs)) pathList*)
        in
        List.fold_left aux3 pathList paths
      else pathList
    in
    
    List.fold_left aux2 pathList pdev.table_it.(st_nb).reducible
  in
  
  let pathList = List.fold_left aux1 (*Path_queue.empty*) [] topmost in
  
  let rec aux4 pathList topmost counters last_pr merge_map =
    match pathList with
    | [] ->
        let topmost,pathList,counters =
          do_merge merge_map merge_array topmost pathList counters t dummy_token_name
        in
        (match pathList with [] -> topmost,counters
          | _ -> aux4 pathList topmost counters None Int_map.empty)
    | pr::_ ->
        let merge_map,topmost,pathList,counters = match last_pr with
          | None -> merge_map,topmost,pathList,counters
          | Some pr0 ->
              if compare_pr pr pr0 = 1 then
                (let topmost,pathList,counters =
                  do_merge merge_map merge_array topmost pathList counters t dummy_token_name
                in
                Int_map.empty,topmost,pathList,counters)
              else merge_map,topmost,pathList,counters
        in
        (match pathList with
          | pr::tl ->
            let pathList,topmost,counters,merge_map =
              let pathList,topmost,will_shift,counters,merge_map =
                reduceViaPath pr t tl topmost counters data_equal
                  dummy_token_name test_cons str_cons merge_map
              in
              if will_shift = false then
                let (sn,_,_),_,_ = pr in
                let topmost = List.filter (function x -> x!=sn) topmost in
                pathList,topmost,counters,merge_map
              else pathList,topmost,counters,merge_map
            in
            aux4 pathList topmost counters (Some pr) merge_map
          | [] -> topmost,counters)
  in
  aux4 pathList topmost counters None Int_map.empty




let doShifts tok_name tok_value (*gs*) (prevTops:('a,'b) Gs.vertex list)
    lexbuf_position lexbuf counters data_equal =
(*   let _ = Printf.fprintf !log_channel "(doShift) longueur prevTops : %d\n" (List.length prevTops) in *)
  let f ((*gs,*)topmost,counters) sn =
    let state_nb,parsing_device =
      sn.vertex_label.state_nb,sn.vertex_label.pdev
    in
    let table = parsing_device.table in
    let table_it = parsing_device.table_it in
    let next_state = table.(state_nb).(0).(tok_name) in
    if next_state = -1 then (*gs,*)topmost,counters else
    
    let prio_imp,b =
      new_prio_imprint parsing_device.prio sn.vertex_label.prio_imprint
        table_it.(state_nb) (Ter tok_name) 0
        parsing_device.gram_rhs parsing_device.lhs_table
        parsing_device.lhs_of_ind parsing_device.str_non_ter
    in
    if b=false then (*gs,*)topmost,counters else
    try
      let rightSib =
        find_rightSib prio_imp parsing_device.g_nb
        next_state parsing_device.datadyn topmost
        parsing_device.data parsing_device.local_data
        data_equal.global_data_equal
        data_equal.local_data_equal
      in
      let _ = Gs.create_e rightSib ([tok_value],counters.counted) sn in
      if (!dypgen_verbose>2) then
        Printf.fprintf !log_stack_channel "Link %d created from <%d> to <%d>\n"
          counters.counted rightSib.vertex_label.sn_nb sn.vertex_label.sn_nb;
      let counters = {counters with counted = counters.counted+1 } in
      (*gs,*)topmost,counters
    with Find_rightSib_failed ->
      let rightSib = Gs.create_v {
        state_nb = next_state;
        pdev = parsing_device;
        sn_nb = counters.countsn;
        first_token = counters.count_token-1;
        last_token = counters.count_token;
        lexer_pos = lexbuf_position lexbuf;
        prio_imprint = prio_imp }
      in
      let _ = Gs.create_e rightSib ([tok_value],counters.counted) sn in
      if !dypgen_verbose>2 then print_sn rightSib;
      let counters = { counters with
        countsn = counters.countsn+1;
        counted = counters.counted+1 }
      in
      (*let gs = rightSib::gs in*)
      (*gs,*)(rightSib::topmost),counters

  in
  List.fold_left f ((*gs,*)[],counters) prevTops



(** This function print the content of the (graph) stack [gs], it is meant 
    for debugging purpose. *)
(*let print_gs gs title =
(* Problème posé par le fait que v est maintenant un numéro d'état et non plus un état. On pourrait passer les tableaux nécesssaires mais on ne peut quand même pas avoir les états des automates générés pour des extensions (numéro d'état non pertinent). *)
  output_string !log_channel "\n"; output_string !log_channel "\n";
  output_string !log_channel title;
  output_string !log_channel "\n";
  let f sn =
    let { state_nb = v; pdev = parsing_device; sn_nb = snnb;
      token_shifted = token_nb ; prio_imprint = prio_imp } = sn.vertex_label
    in
    let lhs_of_ind = parsing_device.lhs_of_ind in
    output_string !log_channel "____________________________________\n";
    let () = Printf.fprintf !log_channel "STACK NODE <%d>, token number : %d\n" snnb token_nb in
    output_string !log_channel "\n";
    (*let () = print_state v lhs_of_ind in*)
    let () = Printf.fprintf !log_channel "state number : %d\n" v in
    output_string !log_channel "\n";
    output_string !log_channel " priority imprint :\n";
    print_prio_imp lhs_of_ind prio_imp;
    let f3 f4 ed = ()
      (*let _,ednb = ed.edge_label in
      let { aut_vertex = v; sn_nb = snnb} = f4 ed in
      Printf.fprintf !log_channel "  sn:%d ed:%d st:%d\n" snnb ednb v.number*)
    in
    output_string !log_channel "\n";
    output_string !log_channel " predecessor stack nodes :\n";
    (*let () = List.iter (f3 (fun e -> e.source.vertex_label))
      sn.pred_edges in
    output_string !log_channel "\n";*)
    output_string !log_channel " successor stack nodes :\n";
    let () = List.iter (f3 (fun e -> e.dest.vertex_label)) sn.succ_edges in
    output_string !log_channel "\n"
  in
  List.iter f gs*)




(*let non_ter_of_li li = match li with
  | Non_ter nt -> nt
  | _ -> failwith "non_ter_of_li"*)

(** Despite the use of the [merge] function there may be several final parse
    objects, because two objects won't be merged if the two currents grammars
    are not the same, and because merge may keep several objects.
    Therefore, [log_parse_forest] is used to put in a list all the final parse
    objects. *)
let log_parse_forest successful entry_point gram_rhs =
  let f l sn =
    let prio_imp = sn.vertex_label.prio_imprint in
    let st_nb = sn.vertex_label.state_nb in
    let tlt = sn.vertex_label.pdev.table_lit_trans in
    let li = tlt.(st_nb) in
    (*let prio_l,_ = Item_map.find (r,1) prio_imp in*)
    (*let prio = 0 in*) (*List.hd prio_l in*)
    let prio = entry_point_prio entry_point prio_imp gram_rhs li in
    let edges = sn.succ_edges in
    let f2 l e =
      let snnb = e.dest.vertex_label.sn_nb in
      if snnb = 0 then
        let ol = fst e.edge_label in
        let f3 o = (o,prio) in
        (list_map f3 ol)@l
      else l
    in
    List.fold_left f2 l edges
  in
  List.fold_left f [] successful



(* The same automaton is used for all entry points, so the parser
tries to match all of them and then it selects the entry point it
is looking for. This may make the parser slower and should be
addressed in the future. *)
let glrParse parsing_device get_value get_name str_token
    (entry_point:non_ter) data_equal test_cons str_cons merge_array
    (lexfun:('a -> 'token)) (lexbuf:'a)
    (lexbuf_position:'a -> (Lexing.position * Lexing.position)) =
  
  let counters = {
    countsn = 0;
    counted = 0;
    count_token = 0;
    count_g = 0 }
  in
  
  let time1 = Sys.time () in
  (*print_endline "parsing begins";*)
  
  (*dypgen_verbose := 3;*)
  
  let log_count = ref 0 in
  if !dypgen_verbose>2 then (
    (try
      let log_count_chan = open_in "dypgen_log_count" in
      let dlc = input_line log_count_chan in
      let dlc = if dlc = "" then "0" else dlc in
      let () = log_count := int_of_string dlc in
      close_in log_count_chan
    with _ -> log_count := 0);
    let log_count_chan = open_out "dypgen_log_count" in
    output_string log_count_chan (string_of_int (!log_count+1));
    close_out log_count_chan;
    log_channel :=
      open_out ("dypgen_"^(string_of_int !log_count)^".log");
    log_stack_channel :=
      open_out ("dypgen_gs_"^(string_of_int !log_count)^".log");
    output_string !log_stack_channel
    "\n\n--------------- Graph Structured Stack ---------------\n\n");

  let start = Gs.create_v {
    state_nb = 0;
    pdev = parsing_device;
    sn_nb = counters.countsn;
    first_token = 0;
    last_token = 0;
    lexer_pos = lexbuf_position lexbuf;
    prio_imprint = default_prio_imp }
  in
  let dummy_token_name = Int_map.find entry_point dummy_token_map in
  let counters = { counters with countsn=counters.countsn+1 } in
  (*let gs = [start] in*)
  let topmost = [start] in
  (*let title_gs = "------------------------- Graph Structured Stack -------------------------\n" in*)
  (*let title_tm =
    "-------------------------- Topmost Stack Nodes --------------------------\n"
  in*)
  let is_successful sn =
    let st_nb = sn.vertex_label.state_nb in
    let tlt = sn.vertex_label.pdev.table_lit_trans in
    let li = tlt.(st_nb) in
    match li with
      | Non_ter nt when (non_ter_of_nt nt)=entry_point -> true
      | _ -> false
  in

  let rec aux_la (*gs*) topmost t counters =
    if !dypgen_verbose>2 then
      (Printf.fprintf !log_channel "\nTOKEN : %s, size of topmost = %d\n"
        (str_token t) (List.length topmost); flush_all ());
    let (*gs,*)topmost,counters =
      doReductions (get_name t) (*gs*) topmost entry_point counters
        data_equal dummy_token_name test_cons str_cons merge_array
    in
    let counters = { counters with
      count_token = counters.count_token+1 }
    in
    let (*gs,*)topmost,counters =
      doShifts (get_name t) (get_value t) (*gs*) topmost lexbuf_position
        lexbuf counters data_equal
    in
    let (*gs,*)topmost,counters =
      doReductions dummy_token_name (*gs*) topmost entry_point counters
        data_equal dummy_token_name test_cons str_cons merge_array in
      (* tries to reduce to the entry point *)
    if topmost = []
    then ((*if !dypgen_verbose>2 then print_gs (*gs*) title_gs;*)
      raise Syntax_error)
    else
    let successful = List.filter is_successful topmost in
    if successful<>[] then (*gs,*)successful,counters else
      aux_la (*gs*) topmost (lexfun lexbuf) counters
  in

  let rec aux_LR0 (*gs*) topmost t counters =
    (*Printf.printf "token number %d\n" counters.count_token;*)
    (*Gc.minor ();*)
    if !dypgen_verbose>2 then
      (Printf.fprintf !log_channel "\nTOKEN : %s, size of topmost = %d\n"
        (str_token t) (List.length topmost); flush_all ());
    let counters =
      { counters with count_token = counters.count_token+1 }
    in
    let (*gs,*)topmost,counters =
      doShifts (get_name t) (get_value t) (*gs*) topmost lexbuf_position
        lexbuf counters data_equal
    in
    let (*gs,*)topmost,counters =
      doReductions dummy_token_name (*gs*) topmost entry_point counters
        data_equal dummy_token_name test_cons str_cons merge_array
    in
    if topmost = []
    then ((*if !dypgen_verbose>2 then print_gs (*gs*) title_gs;*)
      raise Syntax_error)
    else
    let successful = List.filter is_successful topmost in
    if successful<>[] then (*gs,*)successful,counters else
    aux_LR0 (*gs*) topmost (lexfun lexbuf) counters
  in

  (*let gs,topmost = if !automaton_kind=LR0
    then doReductions dummy_token_name gs topmost
    else gs,topmost in*)
  let ((*gs,*)successful,counters) =
    try (
      if !automaton_kind <> `LR0
      then aux_la (*gs*) topmost (lexfun lexbuf) counters
      else
        let (*gs,*)topmost,counters = (* reduces initial epsilon rules *)
          doReductions dummy_token_name (*gs*) topmost entry_point
            counters data_equal dummy_token_name test_cons str_cons
            merge_array
        in
        aux_LR0 (*gs*) topmost (lexfun lexbuf) counters)
    with Syntax_error ->
      (flush_all ();
      if !dypgen_verbose>2 then close_out !log_channel;
      raise Syntax_error)
  in
  
  (*if !dypgen_verbose>2 then print_gs gs title_gs;*)
  if !dypgen_verbose>1 then
    (let time2 = Sys.time () in
    Printf.fprintf !log_channel "parsing time = %.3f\n"
      (time2-.time1);
    output_string !log_channel ("number of stack nodes = "^
      (string_of_int counters.countsn)^"\n");
    output_string !log_channel ("number of edges = "^
      (string_of_int counters.counted)^"\n");
    output_string !log_channel ("number of reductions = "^
      (string_of_int !countred)^"\n");
    flush_all ());
  (*print_endline "end of parsing";*)
  if !dypgen_verbose>2 then close_out !log_channel;
  log_parse_forest successful entry_point parsing_device.gram_rhs

end






module Ntt_PrioInAutomaton =
struct
  type non_terminal = non_ter * priority * int
  type lhs = non_ter * priority * int
  type lit_nt = non_terminal
  let nt_of_lit nt = nt
  let lit_of_nt nt = nt
  let nt_of_lhs nt = nt
  let fst_of_lhs (nt,_,_) = nt
  let ind_of_lhs (_,_,i) = i
  let ind_of_nt (_,_,i) = i
  let test_array_nt array_nt (_,_,i) =
    if array_nt.(i) then true else
      (array_nt.(i) <- true; false)
  let array_nt_size i = i
  let clean_array_nt array_nt nt_list =
    List.iter (fun (_,_,i) -> array_nt.(i) <- false) nt_list
  let new_rhs_lit (nt,p,_) array_nt_prio n =
    try let ind = Prio_map.find p array_nt_prio.(nt) in (nt,p,ind)
    with Not_found -> (nt,p,n)
  let get_lhs_prio (_,p,_) = p
  let str_token_name = E.str_token_name
  let str_non_terminal (nt,p,i) str_non_ter =
    if p = 0 then
      "("^(str_non_ter.(nt))^":"^(string_of_int nt)^","^(string_of_int i)^")"
      (*str_non_ter.(nt)*)
    else
      "("^(str_non_ter.(nt))^
      ","^(E.priority_names.(p))^ ","^(string_of_int i)^")"
  let str_lhs = str_non_terminal
end

module Ntt_PrioAtRuntime =
struct
  type non_terminal = non_ter
  type lhs = non_ter * priority * int
  type lit_nt = non_ter * non_terminal_priority
  let nt_of_lit (nt,_) = nt
  let lit_of_nt nt = (nt,No_priority)
  let nt_of_lhs (nt,_,_) = nt
  let fst_of_lhs (nt,_,_) = nt
  let ind_of_lhs (_,_,i) = i
  let ind_of_nt i = i
  let test_array_nt _ _ = false
  let clean_array_nt array_nt nt_list = ()
  let array_nt_size _ = 0
  let new_rhs_lit nt_lit _ _ = nt_lit
  let get_lhs_prio (_,p,_) = p
  let str_token_name = E.str_token_name
  let str_non_terminal nt str_non_ter = str_non_ter.(nt)
  let str_lhs (nt,p,i) str_non_ter =
    if p = 0 then
      "("^(str_non_ter.(nt))^","^(string_of_int i)^")"
    else
      "("^(str_non_ter.(nt))^
      ","^(E.priority_names.(p))^ ","^(string_of_int i)^")"
end

module Grammar_PrioInAutomaton = Grammar_struct(Ntt_PrioInAutomaton)
module Grammar_PrioAtRuntime = Grammar_struct(Ntt_PrioAtRuntime)




module PrioInAutomaton =
struct

(*let select_rule _ _ _ = true*)
(*let select_lhs nt _ _ = [nt]*)
let lhs_list nt _ _ = [nt]
type lhslists = Dummy_lhslists
let lhslists_init _ = Dummy_lhslists
let comp_lhslist nt _ _ _ = [nt]

(*let lhsl_of_non_ter nt _ = [nt]*)
let lhs_startprime = (0,0,0)

module OrdPrioNb =
struct
  type t = int * int
  let compare = Pervasives.compare
end
module PrioNb_set = Set.Make(OrdPrioNb)
module Non_ter_set = Set.Make(Ordered_non_ter)
open Grammar_PrioInAutomaton
module Map_rhs = Grammar_PrioInAutomaton.Map_rhs
type ('a,'b,'c) grammar = ('a,'b,'c) Grammar_PrioInAutomaton.grammar
type non_terminal = Grammar_PrioInAutomaton.non_terminal
type lhs = Grammar_PrioInAutomaton.lhs
type lit_nt = Grammar_PrioInAutomaton.lit_nt
let non_ter_of_nt  (nt,_,_) = nt
let non_ter_of_lhs (nt,_,_) = nt
let dummy_lhs = (0,0,0)
type item_set = Grammar_PrioInAutomaton.item_set
type rule_bis = Grammar_PrioInAutomaton.rule_bis
type rhs = Grammar_PrioInAutomaton.rhs
let str_with_priority _ = ""

let nt_prio_to_prio_set p_map (ps:Prio_set.t) p = match p with
  | No_priority -> ps
  | Eq_priority pr -> Prio_set.add pr Prio_set.empty
  | Less_priority pr -> (try fst (Prio_map.find pr p_map.prd_rel)
      with Not_found -> Prio_set.empty)
  | Lesseq_priority pr -> Prio_set.add pr (try (fst (Prio_map.find pr p_map.prd_rel))
      with Not_found -> Prio_set.empty)
  | Greater_priority pr -> (try snd (Prio_map.find pr p_map.prd_rel)
      with Not_found -> Prio_set.empty)
  | Greatereq_priority pr -> Prio_set.add pr (try (snd (Prio_map.find pr p_map.prd_rel))
      with Not_found -> Prio_set.empty)
      (* this may result in pr being 2 times in the list and result in
         2 times the same rule_bis, but it will be only once
         in the new_grammar because a grammar is a map of key
         rule_bis. *)
(*let nt_prio_to_prio_set p_map (ps:Prio_set.t) p = match p with
  | No_priority -> ps
  | Less_priority pr -> (try fst (Prio_map.find pr p_map.prd_rel)
      with Not_found -> Prio_set.empty)
  | Lesseq_priority pr -> Prio_set.add pr (try (fst (Prio_map.find pr p_map.prd_rel))
      with Not_found -> Prio_set.empty)
      (* this may result in pr being 2 times in the list and result in
         2 times the same rule_bis, but it will be only once
         in the new_grammar because a grammar is a map of key
         rule_bis. *)*)

let new_rules p_map array_nt_ps array_nt_prio ps ntn litl len prio nt_nb str_non_ter =
  let aux2 tn lit_l = (Ter tn)::lit_l in
  let aux3 nt p lit_ll =
    let rec aux4 lit_ll new_lit_ll = match lit_ll with
      | lit_l::tl ->
          let prio_set = nt_prio_to_prio_set p_map ps p in
          let prio_set2 = array_nt_ps.(nt) in
          let prio_set = Prio_set.inter prio_set prio_set2 in
          let f1 pr pn_set =
            let n = try Prio_map.find pr array_nt_prio.(nt)
              with Not_found -> failwith "Not_found in new_rules rhs"
                | Invalid_argument("index out of bounds") ->
                    (Printf.fprintf !log_channel "Error: non terminal `%s' is out of bounds.\n"
                    (str_non_ter.(nt));failwith "index out of bounds in new_rules rhs")
                    (*(Printf.fprintf !log_channel "Warning: non terminal `%s' is never in a left-hand side.\n"
                    (E.str_non_terminal nt); -1)*)
            in
            PrioNb_set.add (pr,n) pn_set
          in
          let pn_set = Prio_set.fold f1 prio_set PrioNb_set.empty in
          let f (pr,n) l = ((Non_ter (nt,pr,n))::lit_l)::l in
          let lit_ll_2 = PrioNb_set.fold f pn_set [] in
          aux4 tl lit_ll_2@new_lit_ll
      | [] -> new_lit_ll
    in
    aux4 lit_ll []
  in
  let rec aux1 litl lit_ll = match litl with
    | (Ter tn)::tl -> aux1 tl (list_map (aux2 tn) lit_ll)
    | (Non_ter (nt,p))::tl -> aux1 tl (aux3 nt p lit_ll)
    | [] -> lit_ll
  in
  let lit_ll = aux1 litl [[]] in
  let array_of_list l =
    let a = Array.make len (Ter 0) in
    let _ = List.fold_left (fun i x -> a.(i) <- x; (i+1)) 0 l in
    a
  in
  let lit_ll = List.map array_of_list lit_ll in
  let nb = try Prio_map.find prio array_nt_prio.(ntn)
    with Not_found -> failwith "Not_found in new_rules lhs"
  in
  let complete_new_rule lit_l = ((ntn,prio,nb),lit_l) in
  list_map complete_new_rule lit_ll


(* ps is the set of all priorities. *)
let make_real_grammar (user_g:('a,'b,'c) user_grammar) (pmap:priority_data) str_non_ter =
  
  if !dypgen_verbose>1 then
    (let nbr = Urule_map.fold (fun _ _ n -> n+1) user_g 0 in
    Printf.fprintf !log_channel "size of the grammar : %d rules\n" nbr);
  
  let ps =
    Prio_map.fold (fun p _ pset ->
      (*output_string !log_channel
      ("add priority :"^(priority_names.(p))^"\n");*)
      Prio_set.add p pset) pmap.prd_rel Prio_set.empty
  in
  let ps = Prio_set.add default_priority ps in
  let foldfun user_g (ep,_) =
    Urule_map.add (non_terminal_startprime,[Non_ter (ep,No_priority)],0)
      [(Dypgen_action(fun x _ _ d ld _ dd prd _ ->
      (List.hd x,true,false,d,ld,dd,[],[],prd,None,None)))] user_g
  in
  let user_g = List.fold_left foldfun user_g entry_points in
  (*let foldfun3 (nt,_,_) _ non_ter_set = Non_ter_set.add nt non_ter_set in
  let non_ter_set = Urule_map.fold foldfun3 user_g Non_ter_set.empty in
  let nt_nb = Non_ter_set.cardinal non_ter_set in*)
  let f1 (nt,litl,_) _ n =
    let n = max n nt in
    let f2 n lit = match lit with
      | Non_ter (nt,_) -> max n nt
      | _ -> n
    in
    List.fold_left f2 n litl
  in
  let nt_nb = (Urule_map.fold f1 user_g 0)+1 in
  
  if !dypgen_verbose>1 then
    Printf.fprintf !log_channel "number of non terminals : %d\n" nt_nb;
  
  if E.undef_nt then
    (let check_nt_def = Array.make nt_nb (false,false) in
    let rec f4 rhs = match rhs with
      | (Non_ter (nt,_))::tl ->
          let b,_ = check_nt_def.(nt) in
          check_nt_def.(nt) <- (b,true);
          f4 tl
      | _::tl -> f4 tl
      | [] -> ()
    in
    let f3 (nt,rhs,_) _ =
      let _,b = check_nt_def.(nt) in
      check_nt_def.(nt) <- (true,b);
      f4 rhs
    in
    Urule_map.iter f3 user_g;
    for i=0 to nt_nb-1 do
      if check_nt_def.(i) = (false,true) then
        raise (Undefined_nt(str_non_ter.(i)))
    done);
  
  let array_nt_ps = Array.make nt_nb Prio_set.empty in
  
  let iterfun (nt,_,p) _ = array_nt_ps.(nt) <- Prio_set.add p array_nt_ps.(nt) in
  
  Urule_map.iter iterfun user_g;
  
  let array_nt_prio = Array.make nt_nb Prio_map.empty in
  let rec f_rec i n = if i=nt_nb then n else
    let prio_set = array_nt_ps.(i) in
    let foldfun prio (prio_map,n) = (Prio_map.add prio n prio_map),(n+1) in
    let prio_map,n = Prio_set.fold foldfun prio_set (Prio_map.empty,n) in
    let () = array_nt_prio.(i) <- prio_map in
    f_rec (i+1) n
  in
  let newnt_nb = f_rec 0 0 in
  
  let non_ter_of_ind = Array.make newnt_nb 0 in
  let prio_of_ind = Array.make newnt_nb 0 in
  let nt_of_ind = Array.make newnt_nb (0,0,0) in
  let f2 nt p n =
    non_ter_of_ind.(n) <- nt;
    prio_of_ind.(n) <- p;
    nt_of_ind.(n) <- (nt,p,n)
  in
  for i=0 to nt_nb-1 do
    Prio_map.iter (f2 i) array_nt_prio.(i)
  done;
  
  (*let rec print_array_nt_prio i =
    if i=nt_nb then () else
    (print_string ("  "^(E.str_non_terminal i)^" : ");
    Prio_map.iter (fun p _ -> print_string (priority_names.(p)^" ")) array_nt_prio.(i);
    print_newline ();
    print_array_nt_prio (i+1))
  in
  print_endline "array_nt_prio :";
  print_array_nt_prio 0;*)
  
  (*let fiter nt ps =
    print_string ("nt: "^(E.str_non_terminal nt));
    Prio_set.iter (fun p -> print_string (priority_names.(p)^" ")) ps;
    output_string !log_channel "\n"
  in
  Nt_map.iter fiter nt_prio_map;*)
  
  let g = Array.make newnt_nb Map_rhs.empty in
  
  let aux (ntn,litl,p) a =
    let litl = List.rev litl in
    let rl =
      new_rules pmap array_nt_ps array_nt_prio ps ntn litl
        (List.length litl) p nt_nb str_non_ter
    in
    let f ((_,_,i),litl) = g.(i) <- Map_rhs.add litl a g.(i) in
    List.iter f rl
  in
  let () = Urule_map.iter aux user_g in
  let aux _ _ i = i+1 in
  let rec f nt i = if nt=newnt_nb then i else
    f (nt+1) (Map_rhs.fold aux g.(nt) i)
  in
  let nbr = f 0 0 in
  if !dypgen_verbose>1 then
    (Printf.fprintf !log_channel "size of the new grammar : %d rules\n" nbr;
    Printf.fprintf !log_channel "number of new non terminals : %d\n" newnt_nb;
    flush stdout);
  g,array_nt_prio,nt_nb,newnt_nb,nt_of_ind,non_ter_of_ind,
  prio_of_ind,nt_of_ind,nbr


type prio_imprint = int

let new_prio_imprint _ _ _ _ _ _ _ _ _ = 0,true
let change_rn pi is _ = pi,is
let default_prio_imp = 0
let prio_imprint_check _ _ _ = true
let prio_imp_equal _ _ = true
let print_prio_imp _ _ _ _ _ = ()
(* let prev_is is _ = is *)
let entry_point_prio _ _ _ li = match li with
  | Non_ter (_,p,_) -> p
  | Ter _ -> failwith "entry_point_prio, priority in automaton"

end



module PrioAtRuntime =
struct

open Grammar_PrioAtRuntime
module Map_rhs = Grammar_PrioAtRuntime.Map_rhs
type ('a,'b,'c) grammar = ('a,'b,'c) Grammar_PrioAtRuntime.grammar
type non_terminal = Grammar_PrioAtRuntime.non_terminal
type lit_nt = Grammar_PrioAtRuntime.lit_nt
type lhs = Grammar_PrioAtRuntime.lhs
let non_ter_of_nt nt = nt
let non_ter_of_lhs (nt,_,_) = nt
let dummy_lhs = (0,0,0)
type item_set = Grammar_PrioAtRuntime.item_set
type rule_bis = Grammar_PrioAtRuntime.rule_bis
type rhs = Grammar_PrioAtRuntime.rhs
let str_with_priority p = " with priority `"^(priority_names.(p))^"'"

(*let select_rule prio_dat ntn (_,p,_) =
  let nt,nt_p = ntn in
  match nt_p with
    | No_priority -> true
    | Eq_priority q -> p=q
    | Less_priority q -> is_relation prio_dat p q
    | Lesseq_priority q -> (is_relation prio_dat p q) || (p=q)
    | Greater_priority q -> is_relation prio_dat q p
    | Greatereq_priority q -> (is_relation prio_dat q p) || (p=q) *)

(*let str_nt_lit (nt,nt_p) =
  match nt_p with
    | No_priority -> "("^(str_non_terminal nt)^",No_priority)"
    | Eq_priority q -> "("^(str_non_terminal nt)^",="^priority_names.(q)^")"
    | Less_priority q -> "("^(str_non_terminal nt)^",<"^priority_names.(q)^")"
    | Lesseq_priority q -> "("^(str_non_terminal nt)^",<="^priority_names.(q)^")"
    | Greater_priority q -> "("^(str_non_terminal nt)^",>"^priority_names.(q)^")"
    | Greatereq_priority q -> "("^(str_non_terminal nt)^",>="^priority_names.(q)^")"*)

(*let select_lhs (nt,nt_p) prio_dat array_nt_prio =
  (*print_endline ("select_lhs sur "^(str_nt_lit (nt,nt_p)));*)
  let test = match nt_p with
    | No_priority -> (fun _ -> true)
    | Eq_priority q -> (fun p -> p=q)
    | Less_priority q -> (fun p -> is_relation prio_dat p q)
    | Lesseq_priority q -> (fun p -> (is_relation prio_dat p q) || (p=q))
    | Greater_priority q -> (fun p -> is_relation prio_dat q p)
    | Greatereq_priority q -> (fun p -> (is_relation prio_dat q p) || (p=q))
  in
  let rec f p =
    if p = prio_dat.prd_nb then [] else
    if test p then
      try
        let ind = Prio_map.find p array_nt_prio.(nt) in
        (nt,p,ind)::(f (p+1))
      with Not_found -> f (p+1)
    else f (p+1)
  in
  let l = f 0 in
  (*List.iter (fun lhs -> print_endline (str_lhs lhs)) l;*)
  l*)

let lhs_list (nt,_) prio_dat array_nt_prio =
  let rec f p =
    if p = prio_dat.prd_nb then [] else
      try
        let ind = Prio_map.find p array_nt_prio.(nt) in
        (nt,p,ind)::(f (p+1))
      with Not_found -> f (p+1)
  in
  f 0

module Ordered_ntp =
struct
  type t = non_terminal_priority
  let compare = Pervasives.compare
end
module Ntp_map = Map.Make(Ordered_ntp)

type lhslists = ((lhs list) Ntp_map.t) array
let lhslists_init i = Array.make i Ntp_map.empty

let comp_lhslist (nt,nt_p) lhslists prio_dat array_nt_prio =
  (*print_endline ("comp_lhslist sur "^(str_nt_lit (nt,nt_p)));*)
  try Ntp_map.find nt_p lhslists.(nt) with Not_found ->(
  let test = match nt_p with
    | No_priority -> (fun _ -> true)
    | Eq_priority q -> (fun p -> p=q)
    | Less_priority q -> (fun p -> is_relation prio_dat p q)
    | Lesseq_priority q -> (fun p -> (is_relation prio_dat p q) || (p=q))
    | Greater_priority q -> (fun p -> is_relation prio_dat q p)
    | Greatereq_priority q -> (fun p -> (is_relation prio_dat q p) || (p=q))
  in
  let rec f p =
    if p = prio_dat.prd_nb then [] else
    if test p then
      try
        let ind = Prio_map.find p array_nt_prio.(nt) in
        (nt,p,ind)::(f (p+1))
      with Not_found -> f (p+1)
        | e -> (Printf.printf "array_nt_prio.(nt), nt=%d, len=%d\n"
          nt (Array.length array_nt_prio); raise e)
    else f (p+1)
  in
  let l = f 0 in
  lhslists.(nt) <- Ntp_map.add nt_p l lhslists.(nt);
  (*List.iter (fun lhs -> print_endline (str_lhs lhs)) l;*)
  l)
  | e -> (Printf.printf "lhslists length=%d\n"
     (Array.length lhslists); raise e)

let lhs_startprime = (0,0,0)

(*let lhsl_of_non_ter nt array_nt_prio =
  let f p ind lhs_l = (nt,p,ind)::lhs_l in
  Prio_map.fold f array_nt_prio.(nt) []*)

(*let compute_nt_nb g =
  let f1 (nt,litl,_) _ n =
    let n = max n nt in
    let f2 n lit = match lit with
      | Non_ter (nt,_) -> max n nt
      | _ -> n
    in
    List.fold_left f2 n litl
  in
  (Map_r.fold f1 g 0)+1*)
(*  let foldfun3 (nt,_,_,_,_) _ non_ter_set = NTS.add nt non_ter_set in
  let non_ter_set = Map_r.fold foldfun3 g NTS.empty in
  NTS.cardinal non_ter_set*)

(*let rule_bis_of_rule (nt,l,p) = (nt,l,p,(List.length l))*)

(*let make_real_grammar user_g _ =
  let foldfun r a g = Map_r.add (rule_bis_of_rule r) a g in
  let g = Urule_map.fold foldfun user_g Map_r.empty in
  let foldfun g ep =
    Map_r.add (non_terminal_startprime,[Non_ter (ep,No_priority)],0,1)
      [(Dypgen_action(fun x _ _ d ld dd prd -> (List.hd x,true,d,ld,dd,[],[],prd)))] g
  in
  let nt_nb = compute_nt_nb g in
  (List.fold_left foldfun g entry_points),nt_nb,nt_nb*)


let make_real_grammar (user_g:('a,'b,'c) user_grammar) (pmap:priority_data) str_non_ter =
  if !dypgen_verbose>1 then
    (let nbr = Urule_map.fold (fun _ _ n -> n+1) user_g 0 in
    Printf.fprintf !log_channel "size of the grammar : %d rules\n" nbr);
  let foldfun user_g (ep,_) =
    Urule_map.add (non_terminal_startprime,[Non_ter (ep,No_priority)],0)
      [(Dypgen_action(fun x _ _ d ld _ dd prd _ ->
          (List.hd x,true,false,d,ld,dd,[],[],prd,None,None)))] user_g
  in
  let user_g = List.fold_left foldfun user_g entry_points in
  (*let foldfun3 (nt,_,_) _ non_ter_set = Non_ter_set.add nt non_ter_set in
  let non_ter_set = Urule_map.fold foldfun3 user_g Non_ter_set.empty in
  let nt_nb = Non_ter_set.cardinal non_ter_set in*)
  let f1 (nt,litl,_) _ n =
    let n = max n nt in
    let f2 n lit = match lit with
      | Non_ter (nt,_) -> max n nt
      | _ -> n
    in
    List.fold_left f2 n litl
  in
  let nt_nb = (Urule_map.fold f1 user_g 0)+1 in
  if !dypgen_verbose>1 then
    Printf.fprintf !log_channel "number of non terminals : %d\n" nt_nb;
  
  if E.undef_nt then
    (let check_nt_def = Array.make nt_nb (false,false) in
    let rec f4 rhs = match rhs with
      | (Non_ter (nt,_))::tl ->
          let b,_ = check_nt_def.(nt) in
          check_nt_def.(nt) <- (b,true);
          f4 tl
      | _::tl -> f4 tl
      | [] -> ()
    in
    let f3 (nt,rhs,_) _ =
      let _,b = check_nt_def.(nt) in
      check_nt_def.(nt) <- (true,b);
      f4 rhs
    in
    Urule_map.iter f3 user_g;
    for i=0 to nt_nb-1 do
      if check_nt_def.(i) = (false,true) then
        raise (Undefined_nt(str_non_ter.(i)))
    done);
  
  let array_nt_ps = Array.make nt_nb Prio_set.empty in
  
  let iterfun (nt,_,p) _ = array_nt_ps.(nt) <- Prio_set.add p array_nt_ps.(nt) in
  
  let () = Urule_map.iter iterfun user_g in
  
  let array_nt_prio = Array.make nt_nb Prio_map.empty in
  let rec f_rec i n = if i=nt_nb then n else
    let prio_set = array_nt_ps.(i) in
    let foldfun prio (prio_map,n) = (Prio_map.add prio n prio_map),(n+1) in
    let prio_map,n = Prio_set.fold foldfun prio_set (Prio_map.empty,n) in
    let () = array_nt_prio.(i) <- prio_map in
    f_rec (i+1) n
  in
  let newnt_nb = f_rec 0 0 in
  
  let non_ter_of_ind = Array.make newnt_nb 0 in
  let prio_of_ind = Array.make newnt_nb 0 in
  let lhs_of_ind = Array.make newnt_nb (0,0,0) in
  let f2 nt p n =
    non_ter_of_ind.(n) <- nt;
    prio_of_ind.(n) <- p;
    lhs_of_ind.(n) <- (nt,p,n)
  in
  for i=0 to nt_nb-1 do
    Prio_map.iter (f2 i) array_nt_prio.(i)
  done;
  
  (*let rec print_array_nt_prio i =
    if i=nt_nb then () else
    (print_string ("  "^(str_non_terminal i)^" : ");
    Prio_map.iter (fun p _ -> print_string (priority_names.(p)^" ")) array_nt_prio.(i);
    print_newline ();
    print_array_nt_prio (i+1))
  in
  print_endline "array_nt_prio :";
  print_array_nt_prio 0;*)
  
  (*let fiter nt ps =
    print_string ("nt: "^(E.str_non_terminal nt));
    Prio_set.iter (fun p -> print_string (priority_names.(p)^" ")) ps;
    output_string !log_channel "\n"
  in
  Nt_map.iter fiter nt_prio_map;*)
  
  let g = Array.make newnt_nb Map_rhs.empty in
  
  let array_of_list l =
    let a = Array.make (List.length l) (Ter 0) in
    let _ = List.fold_left (fun i x -> a.(i) <- x; (i+1)) 0 l in
    a
  in
  
  let aux (ntn,litl,p) a =
    let ind = Prio_map.find p array_nt_prio.(ntn) in
    g.(ind) <- Map_rhs.add (array_of_list litl) a g.(ind)
  in
  let () = Urule_map.iter aux user_g in
  
  let aux _ _ i = i+1 in
  let rec f nt i = if nt=newnt_nb then i else
    f (nt+1) (Map_rhs.fold aux g.(nt) i)
  in
  let nbr = f 0 0 in
  if !dypgen_verbose>1 then
    (Printf.fprintf !log_channel "size of the new grammar : %d rules\n" nbr;
    Printf.fprintf !log_channel "number of new non terminals : %d\n" newnt_nb;
    flush stdout);
  g,array_nt_prio,nt_nb,nt_nb,non_ter_of_ind,non_ter_of_ind,prio_of_ind,lhs_of_ind,nbr


(*type prio_imprint = int*)
type prio_imprint = ((priority list) * bool) Item_map.t

let symb_of_lit lit = match lit with
  | Ter t -> Ter t
  | Non_ter (n,_) -> Non_ter n

(*let new_prio_imprint _ _ _ _ = 0,true*)

let print_prio_imp chan gram_rhs lhs_table prio_imp str_non_ter =
  let f (rn,dp) (pl,b) =
    print_kernel chan gram_rhs lhs_table str_non_ter (rn,dp);
    let f2 s p = s^(E.priority_names.(p))^" " in
    output_string chan ("  "^(string_of_bool b)^" : ["^(List.fold_left f2 " " pl)^"]\n")
  in
  Item_map.iter f prio_imp


let new_prio_imprint priodat prio_imp is symb prio gram_rhs lhs_table lhs_of_ind str_non_ter =
  let f (new_pi,b) (rn,dp) =
    let rhs = gram_rhs.(rn) in
    let lit = rhs.(dp) in
    if (symb_of_lit lit)<>symb then (new_pi,b) else
    let b1 = match lit with
      | Ter _ | Non_ter (_,No_priority) -> true
      | Non_ter (_,Eq_priority p) -> prio=p
      | Non_ter (_,Less_priority p) ->
          is_relation priodat prio p
      | Non_ter (_,Lesseq_priority p) ->
          (is_relation priodat prio p)||(p=prio)
      | Non_ter (_,Greater_priority p) ->
          is_relation priodat p prio
      | Non_ter (_,Greatereq_priority p) ->
          (is_relation priodat p prio)||(p=prio)
    in
    let old_prio_l,old_b =
      if dp=0 then ([],true) else
      try Item_map.find (rn,dp) prio_imp
      with Not_found ->
        (
        print_kernel !log_channel gram_rhs lhs_table str_non_ter (rn,dp);
        print_prio_imp !log_channel gram_rhs lhs_table prio_imp str_non_ter;
        failwith "new_prio_imprint")
    in
    (Item_map.add (rn,dp+1) ((prio::old_prio_l),(b1 && old_b)) new_pi),
    (b || b1)
  in
  let im,b = List.fold_left f (Item_map.empty,false) is.kernel_t in
  let im,b = List.fold_left f (im,b) is.kernel_nt in
  let g x rn = f x (rn,0) in
  List.fold_left g (im,b) is.non_kernel
  (* If the returned bool is true then the parser can complete the reduction.
  In the case of the shift it is false only if the token is not
  expected, not because of priorities. *)

let change_rn prio_imp is rn_map =
  let new_is = new_item_set () in
  let f kernel (rn,x) =
    try
      let new_rn = Int_map.find rn rn_map in
      (new_rn,x)::kernel
    with Not_found -> kernel
  in
  new_is.kernel_nt <- List.fold_left f [] is.kernel_nt;
  new_is.kernel_t <- List.fold_left f [] is.kernel_t;
  new_is.reducible <- List.fold_left f [] is.reducible;
  let g non_kernel rn =
    try
      let new_rn = Int_map.find rn rn_map in
      new_rn::non_kernel
    with Not_found -> non_kernel
  in
  new_is.non_kernel <- List.fold_left g [] is.non_kernel;
  
  let h (rn,dp) pi new_prio_imp =
    try
      let new_rn = Int_map.find rn rn_map in
      Item_map.add (new_rn,dp) pi new_prio_imp
    with Not_found -> new_prio_imp
  in
  let new_prio_imp = Item_map.fold h prio_imp Item_map.empty in
  new_prio_imp, new_is

let prio_imprint_check rn gram_rhs prio_imp =
  let _,b = try Item_map.find (rn,Array.length gram_rhs.(rn)) prio_imp
    with Not_found -> [],true in
  b
  (*let _,b = try Item_map.find (ind,(rhs,Array.length rhs)) prio_imp
    with Not_found -> [],true in
  b*)

let default_prio_imp = Item_map.empty
let prio_imp_equal pi1 pi2 = Item_map.equal (=) pi1 pi2

exception Prio_found of priority

let entry_point_prio entry_point (prio_imp:prio_imprint) (gram_rhs:rhs array) _ =
  let f (rn,dp) (prio_l,_) =
    if rn >= Array.length gram_rhs then (
      Printf.fprintf !log_channel "rn=%d, gram_rhs len=%d\n"
      rn (Array.length gram_rhs); failwith "entry_pp");
    if dp<>1 || Array.length gram_rhs.(rn)<>1 then () else
    match gram_rhs.(rn).(0) with
      | Non_ter (nt,_) when nt=entry_point ->
          raise (Prio_found (List.hd prio_l))
      | _ -> ()
  in
  try Item_map.iter f prio_imp;
    failwith "entry_point_prio"
  with Prio_found prio -> prio
  
  (*let r =
    (lhs_startprime,[Non_ter(entry_point,No_priority)],1)
  in*)
  (*let prio_l,_ = Item_map.find
    ((ind_of_lhs lhs_startprime),(([|Non_ter(entry_point,No_priority)|]),1))
    prio_imp in
  try List.hd prio_l with Failure _ -> failwith "entry_point_prio"*)

(*let prev_is is gram_rhs =
  let f (kt,knt,nk) (rn,dp) =
    if dp=1 then (kt,knt,rn::nk) else
    match gram_rhs.(rn).(dp-1) with
      | Ter _ -> ((rn,dp-1)::kt,knt,nk)
      | Non_ter _ -> (kt,(rn,dp-1)::knt,nk)
  in
  let kernel_t, kernel_nt, non_kernel =
    List.fold_left f ([],[],[]) is.kernel_t in
  let kernel_t, kernel_nt, non_kernel =
    List.fold_left f (kernel_t, kernel_nt, non_kernel) is.kernel_t
  in
  let reducible = List.map
    (fun (rn,_) -> (rn,Array.length gram_rhs.(rn)))
    is.reducible
  in
  let reducible = List.filter (fun (_,dp) -> dp>0) reducible in
  let kernel_t, kernel_nt, non_kernel =
    List.fold_left f (kernel_t, kernel_nt, non_kernel) reducible
  in
  { dummy_item_set with
  kernel_t = kernel_t;
  kernel_nt = kernel_nt;
  non_kernel = non_kernel }*)

end

module Parser_PIA = Parser(Grammar_PrioInAutomaton)(PrioInAutomaton)
module Parser_PAR = Parser(Grammar_PrioAtRuntime)(PrioAtRuntime)

module type Parser_type =
sig
  type ('obj,'b,'c) parsing_device
    (** Abstract type of a structure which contains an parsing_device, the
    grammar associated to it and the actions associated to the grammar and
    other data. *)

  val create_parsing_device :
    (rule * ('obj,'data,'local_data) Dyp_special_types.action) list ->
    priority_data -> Dyp_special_types.automaton_kind -> 'data ->
    'local_data ->
     Dyp_special_types.datadyn -> string array -> int array ->
    ('obj,'data,'local_data) parsing_device
    (** Returns the parsing_device which parses strings written with the input
        grammar and assuming the relations between priority classes which
        are contained in the input priority data. *)

  val update_parsing_device_data : ('obj,'data,'local_data) parsing_device ->
    'data -> 'local_data -> ('obj,'data,'local_data) parsing_device

  val glrParse : ('obj,'data,'local_data) parsing_device ->
        ('token -> 'obj) -> ('token -> int) -> ('token -> string) -> int ->
        ('data,'local_data) Tools.data_equal ->
        ('obj -> bool) array -> ('obj -> string) ->
        ('obj,'data,'local_data) merge_function array ->
        ('a -> 'token) -> 'a ->
        ('a -> (Lexing.position * Lexing.position)) ->
        (('obj * priority) list)
    (** Given a parsing_device and a list of tokens (the input string),
        [glrParse] returns the list of the parse objects of the input string.
        If there is no ambiguity there is only one object in the list. The
        list may be a forest of abstract syntax trees or a list of computed
        values.
        [int] is the name of the entry point. *)
end


end


@h=tangler('dypgen/dyplib/priority_by_relation.ml')
@select(h)
type priority = int

type non_terminal_priority =
  | No_priority
  | Eq_priority of priority
  | Less_priority of priority
  | Lesseq_priority of priority
  | Greater_priority of priority
  | Greatereq_priority of priority
(** This type makes possible to assign precedence to non terminals in 
          the rhs of rules.
            If the non_terminal_priority of the non terminal E in the following 
          rule : A -> E  is Less_priority pc1, and that the parser has so far 
          reduced a substring to E yielding the priority class pc2 for this
          substring, then the parser reduces with A -> E to A only if we have
          the relation pc1 -> pc2 in the priority set used to construct the 
          automaton (see below create_automaton).
            The Toeq constructor behaves the same way except that it also 
          accepts pc1 for priority class of the substring even if we don't
          have pc1 -> pc1 in the priority set. *)

let str_ntp ntp = match ntp with
  | No_priority -> "No_priority"
  | Eq_priority p -> "="^(string_of_int p)
  | Less_priority p -> "<"^(string_of_int p)
  | Lesseq_priority p -> "<="^(string_of_int p)
  | Greater_priority p -> ">"^(string_of_int p)
  | Greatereq_priority p -> ">="^(string_of_int p)

let start_priority = No_priority

module OrdPrio =
struct
  type t = priority
  let compare = Pervasives.compare
end
module Ordered_string =
struct
  type t = string
  let compare = Pervasives.compare
end

module Prio_set = Set.Make(OrdPrio)
module Prio_map = Map.Make(OrdPrio)
module String_map = Map.Make(Ordered_string)

type priority_data = {
  prd_rel : (Prio_set.t * Prio_set.t) Prio_map.t;
  prd_strmap : (int String_map.t);
  prd_nb : int }
(* This is a map from a priority to a couple of priority set :
p -> (ps1,ps2) where ps1 is the set of all priorities q s.a. q<p
and ps2 is the set of all priorities r s.a. p<r
The string_map maps the string of a priority to its int value.
int is the number of priorities. *)

(* REMARQUE : Puisque les priorités sont des entiers, la structure qu'il nous faut c'est un tableau à 2 entrées :
prio_dat.(p).(q) = true <=> p<q *)



(* this set p1<p2 true if b=true and false if b=false *)
let set_relation priodat b p1 p2 =
  let (ps1,ps2) = try Prio_map.find p1 priodat.prd_rel
    with Not_found -> failwith "set_relation" (*(Prio_set.empty, Prio_set.empty)*)
  in
  let (ps3,ps4) = try Prio_map.find p2 priodat.prd_rel
    with Not_found -> failwith "set_relation" (*(Prio_set.empty, Prio_set.empty)*)
  in
  let (ps2,ps3) =
    if b then (Prio_set.add p2 ps2),(Prio_set.add p1 ps3)
    else (Prio_set.remove p2 ps2),(Prio_set.remove p1 ps3)
  in
  let prd_rel =
    Prio_map.add p2 (ps3,ps4) (Prio_map.add p1 (ps1,ps2) priodat.prd_rel)
  in
  { priodat with prd_rel = prd_rel }

let insert_priority priodat str =
  try
    let p = String_map.find str priodat.prd_strmap in
    (priodat,p)
  with Not_found ->
    let p = priodat.prd_nb in
    let strmap = String_map.add str p priodat.prd_strmap in
    let rel = Prio_map.add p (Prio_set.empty,Prio_set.empty) priodat.prd_rel in
    { prd_rel = rel ; prd_strmap = strmap ; prd_nb = (p+1) },p

let find_priority priodat str =
  String_map.find str priodat.prd_strmap

let default_priority = 0
let empty_priority_data =
{ prd_rel = Prio_map.empty ; prd_strmap = String_map.empty ; prd_nb = 0 }
let empty_priority_data = fst (insert_priority empty_priority_data "default_priority")

let is_relation priodat p1 p2 =
  try
    let (_,ps) = Prio_map.find p1 priodat.prd_rel in
    Prio_set.mem p2 ps
  with Not_found -> false


let update_priority priodat ppbl =
  let aux priodat (p1,p2,b) = set_relation priodat b p1 p2 in
  List.fold_left aux priodat ppbl
(** update_priority ps [pc1,pc2,true]
adds the binary relation pc1 -> pc2 to ps
update_priority ps [pc1,pc2,false]
removes the relation pc1 -> pc2 from ps if it exists. *)

(* used for p1<p2<p3<...<pn *)
let add_list_relations priodat l =
  let foldfun p1 priodat p2 = set_relation priodat true p1 p2 in
  let rec aux p1 l priodat = match l with
    | [p2] -> set_relation priodat true p1 p2
    | p2::tl ->
        let priodat = List.fold_left (foldfun p1) priodat l in
        aux p2 tl priodat
    | [] -> failwith "add_list_relation"
  in
  aux (List.hd l) (List.tl l) priodat

(* does the same as the previous except that there is the reflexivity *)
(*let add_list_relations_order priodat l =
  let foldfun p1 priodat p2 = set_relation priodat true p1 p2 in
  let rec aux p1 l priodat = match l with
    | [p2] -> set_relation priodat true p1 p2
    | p2::tl ->
        let priodat = List.fold_left (foldfun p1) priodat l in
        aux p2 tl priodat
    | [] -> failwith "add_list_relation"
  in
  aux (List.hd l) l priodat*)

@h=tangler('dypgen/dyplib/gs.ml')
@select(h)
type
  ('n,'e) vertex = {
    mutable vertex_label : 'n;
    mutable succ_edges : (('n,'e) edge) list;
    (*mutable pred_edges : (('n,'e) edge) list*)
  }
  and ('n,'e) edge = {
    mutable edge_label : 'e;
    mutable dest : ('n,'e) vertex;
    (*mutable source : ('n,'e) vertex*)
  }

let create_e v1 label v2 =
  let new_edge = { edge_label = label; (*source = v1;*) dest = v2} in
  v1.succ_edges <- new_edge::(v1.succ_edges);
  (*v2.pred_edges <- new_edge::(v2.pred_edges);*)
  new_edge

(*let remove_edge_e edge =
  let v1 = edge.source in
  let v2 = edge.dest in
  let f e = e!=edge in
  v1.succ_edges <- List.filter f v1.succ_edges;
  v2.pred_edges <- List.filter f v2.pred_edges*)

let create_v label =
  { vertex_label = label; succ_edges = []; (*pred_edges = []*) }


@h=tangler('dypgen/generators/pgen/pgen_lexer.mll')
@select(h)
{
open Pgen_parser_param
let ocaml_code_buffer = ref ""
let paren_count = ref 0
let in_string = ref false
let comment_count = ref 0
}

let newline = ('\010' | '\013' | "\013\010")
let blank = [' ' '\009' '\012']
let lowercase = ['a'-'z' '\223'-'\246' '\248'-'\255' '_']
let uppercase = ['A'-'Z' '\192'-'\214' '\216'-'\222']
let identchar = 
  ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']

rule token = parse
  | newline
      { token lexbuf }
  | blank +
      { token lexbuf }
  | "%token" { KWD_TOKEN }
  | "%start" { KWD_START }
  | "%relation" { KWD_RELATION }
  | "%full" { KWD_FULL }
  | lowercase identchar *
      { LIDENT(Lexing.lexeme lexbuf) }
  | uppercase identchar *
      { UIDENT(Lexing.lexeme lexbuf) }
  | "("  { LPAREN }
  | ")"  { RPAREN }
  | ":"  { COLON }
  | "%%"  { PERCENTPERCENT }
  | "<"
      { ocaml_code_buffer := "";
        ocaml_type lexbuf;
        OCAML_TYPE (!ocaml_code_buffer)
      }
  | "{"
      { ocaml_code_buffer := "";
        ocaml_code lexbuf;
        OCAML_CODE (!ocaml_code_buffer)
      }
  | "|"  { BAR }
  | "="  { EQUAL }
  | eof { EOF }

and ocaml_code = parse
  | "}" 
      { 
        if !in_string = false && !comment_count = 0 then
          begin
            if (!paren_count) = 0 then ()
            else
              let _ = ocaml_code_buffer := ((!ocaml_code_buffer) ^ 
                (String.make 1 (Lexing.lexeme_char lexbuf 0))) in
              let _ = paren_count := ((!paren_count)-1) in
              ocaml_code lexbuf
          end
        else
          begin
            ocaml_code_buffer := (!ocaml_code_buffer) ^ "}";
            ocaml_code lexbuf
          end
      }  
  | "$"
      { ocaml_code_buffer := ((!ocaml_code_buffer) ^ 
          "_");
        ocaml_code lexbuf
      }
  | "\\\""
      { ocaml_code_buffer := ((!ocaml_code_buffer) ^ "\\\"");
        ocaml_code lexbuf
      }
  | "\""
      { 
        if !in_string then in_string := false else in_string := true;
        ocaml_code_buffer := (!ocaml_code_buffer) ^ "\"";
        ocaml_code lexbuf
      }
  | "{"
      { ocaml_code_buffer := (!ocaml_code_buffer) ^ "{";
        if !in_string = false && !comment_count = 0 then
          paren_count := (!paren_count)+1;
        ocaml_code lexbuf
      }
  | "(*"
      { 
        if !in_string then () else comment_count := !comment_count + 1;
        ocaml_code_buffer := ((!ocaml_code_buffer) ^ "(*");
        ocaml_code lexbuf
      }
  | "*)"
      { 
        if !in_string then () else comment_count := !comment_count - 1;
        ocaml_code_buffer := ((!ocaml_code_buffer) ^ "*)");
        ocaml_code lexbuf
      }
  | _ 
      { ocaml_code_buffer := ((!ocaml_code_buffer) ^ 
          (String.make 1 (Lexing.lexeme_char lexbuf 0)));
        ocaml_code lexbuf
      }

and ocaml_type = parse
  | ">" { () }
  | _ 
      { ocaml_code_buffer := ((!ocaml_code_buffer) ^ 
          (String.make 1 (Lexing.lexeme_char lexbuf 0)));
        ocaml_type lexbuf
      }

@h=tangler('dypgen/generators/pgen/pgen.ml')
@select(h)
(*
pgen: a simple GLR parser generator for Objective Caml,
priority_by_relation is used.
Dyp_special_types.Dypgen_action actions are not possible with pgen and actions cannot use the structures
data and priority_data, priorities of rules are constant only.
Cyclic grammars are not handled.
If no priority are stated for a rule in pgen input file, then default_priority
(i.e. 0) is chosen.
merge functions (for two sub parse trees reduced to the same non terminal) cannot be
stated by the user and is always the choice of the first parse tree.

An input file for pgen follows this frame :

{
optional header code for the Parser_parameters module.
}

%token Token1 <type> Token2 (* Constructors for token *)
%start <type> main
%relation (* optional field *)
p1:p2
p1:p3 (* means the relation is true for p1->p2, the field %relation is optional *)

%%

main:
 | sequence of terminals and non terminals { ocaml action code } priority
...

non_terminal:
 | ... {...} priority
...

{
Optional ocaml code, trailer of the main parser code.
}

This is the end of the input file.

In action code $1 is the name of the obj associated to the first literal in the
rhs of the rule, $2 the second, etc.
*)

module P = Dyp.Make_dyp(Pgen_parser_param)

open Pgen_parser_param
open P
open P.Parser_PAR
open Printf
open Dyp
let priority_data, default_priority =
  Dyp.insert_priority Dyp.empty_priority_data "default_priority"

let str_token t = match t with
  | LPAREN -> "("
  | RPAREN -> ")"
  | COLON -> ":"
  | PERCENTPERCENT -> "%%"
  | LBRACE -> "}"
  | RBRACE -> "}"
  | BAR -> "|"
  | EQUAL -> "="
  | EOF -> "EOF"
  | KWD_TOKEN -> "%token"
  | KWD_START -> "%start"
  | KWD_RELATION -> "%relation"
  | KWD_FULL -> "%full"
  | OCAML_CODE c -> c
  | OCAML_TYPE t -> t
  | UIDENT i -> i
  | LIDENT i -> i

let get_name t = match t with
  | LPAREN -> tn_lparen
  | RPAREN -> tn_rparen
  | COLON -> tn_colon
  | PERCENTPERCENT -> tn_percentpercent
  | LBRACE -> tn_lbrace
  | RBRACE -> tn_rbrace
  | BAR -> tn_bar
  | EQUAL -> tn_equal
  | EOF -> tn_EOF
  | KWD_TOKEN -> tn_kwd_token
  | KWD_START -> tn_kwd_start
  | KWD_RELATION -> tn_kwd_relation
  | KWD_FULL -> tn_kwd_full
  | OCAML_CODE _ -> tn_ocaml_code
  | OCAML_TYPE _ -> tn_ocaml_type
  | UIDENT _ -> tn_uident
  | LIDENT _ -> tn_lident


(*let () = dypgen_verbose := 2*)
(*let () = number_of_tokens := 19*)

let verbose_ref = ref 0
let process_verbose_mode () = verbose_ref := 1
let string_ref = ref ""
let process_argument s =
  if s = "" then raise (Arg.Bad "missing input file name")
  else string_ref := s
let list_arg = [("-v",Arg.Unit process_verbose_mode,"activate verbose mode: gives details of the parsing of the input file")]
let _ = Arg.parse list_arg process_argument "usage: pgen [-v] file_name.dyp"
let _ = if !string_ref = "" then
  let _ = print_string "usage: pgen [-v] file_name.dyp\n" in exit 0

let prio = 0


let ntn_start = 1
let ntn_parser_param_info = 2
let ntn_token_list = 3
let ntn_relation = 4
let ntn_start_def = 5
let ntn_grammar = 6
let ntn_bar_opt = 7
let ntn_literal_list = 8
let ntn_priority = 9
let ntn_optional_code = 10
(*let ntn_startprime = 0*)

type data = Data_void

type obj =
    Obj_void
  | Code of string
  | Obj_type of string
  | Parser_parameters_info of parser_param_info
  | Token_list of (token_desc list) 
  | Obj_start of string * string
  | Relation of relation_desc
  | Grammar of (rule_desc list)
  | Literal_list of (literal_desc list)
  | Obj_uident of string
  | Obj_lident of string
  | Obj_lparen
  | Obj_rparen
  | Obj_equal
  | Pgen_input of (string * parser_param_info * (rule_desc list) * string)
(* Pgen_input : (header code of module Parser_parameters, token list, eof token, relation (optional), trailer code of module Parser_parameters, header code of parser (optional), grammar, trailer code of parser (optional))*)

let r_pgen_input = (ntn_start,[Non_ter (ntn_optional_code, No_priority); Non_ter (ntn_parser_param_info,No_priority); Ter tn_percentpercent; Non_ter (ntn_grammar,No_priority); Non_ter (ntn_optional_code, No_priority); Ter tn_EOF],default_priority)
(* Start -> optional_code parser_param_inf PercentPercent grammar optional_code Eof *)

let a_pgen_input = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [Code c1; Parser_parameters_info (tl,rel,start); _; Grammar g; Code c2; _] ->
        Pgen_input (c1,(tl,rel,start),g,c2)
    | _ -> failwith "a_pgen_input"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_start_def = (ntn_start_def,[Ter tn_kwd_start; Ter tn_ocaml_type; Ter tn_lident],default_priority)
(* start_def -> Kwd_start Ocaml_type Lident *)

let a_start_def = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [Obj_void; Obj_type t; Obj_lident s] -> Obj_start (s,t)
    | _ -> failwith "a_start_def"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_parser_param_info_0 = (ntn_parser_param_info,[Non_ter (ntn_start_def,No_priority)],default_priority)
(* parser_param_info -> start_def *)
let r_parser_param_info_1 = (ntn_parser_param_info,[Non_ter (ntn_token_list,No_priority)],default_priority)
(* parser_param_info -> token_list *)
let r_parser_param_info_3 = (ntn_parser_param_info,[Non_ter (ntn_relation,No_priority)],default_priority)
(* parser_param_info -> relation *)
let r_parser_param_info_4 = (ntn_parser_param_info,[Non_ter (ntn_parser_param_info, No_priority); Non_ter (ntn_parser_param_info, No_priority)],default_priority)
(* parser_param_info -> parser_param_info parser_param_info *)

let a_parser_param_info = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [Obj_start (st,t)] -> Parser_parameters_info ([],[],(st,t))
    | [Token_list tl] -> Parser_parameters_info (tl,[],("",""))
    | [Relation rel] -> Parser_parameters_info ([],rel,("",""))
    | [Parser_parameters_info (tl1,rel1,st1); Parser_parameters_info (tl2,rel2,st2)] ->
        let st = if fst st2 = "" then st1 else st2 in
        Parser_parameters_info (tl1@tl2,rel1@rel2,st)
    | _ -> failwith "a_parser_param_info"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_optional_code_0 = (ntn_optional_code,[],default_priority)
(* optional_code -> *)
let r_optional_code_1 = (ntn_optional_code,[Ter tn_ocaml_code],default_priority)
(* optional_code -> Ocaml_code *)

let a_optional_code = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [] -> Code ""
    | [Code c] -> Code c
    | _ -> failwith "a_optional_code"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_token_list_1 = (ntn_token_list,[Ter tn_kwd_token; Ter tn_uident],default_priority)
(* token_list -> Kwd_token Uident *)
let r_token_list_2 = (ntn_token_list,[Ter tn_kwd_token; Ter tn_ocaml_type;  Ter tn_uident],default_priority)
(* token_list -> Kwd_token Ocaml_type Uident *)
let r_token_list_3 = (ntn_token_list,[Non_ter (ntn_token_list,No_priority); Ter tn_uident],default_priority)
(* token_list -> token_list Uident *)
let r_token_list_4 = (ntn_token_list,[Non_ter (ntn_token_list,No_priority); Ter tn_ocaml_type;  Ter tn_uident],default_priority)
(* token_list -> token_list Ocaml_type Uident *)

let a_token_list = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [Obj_void; Obj_uident tok] -> Token_list [(tok,"No_type")]
    | [Obj_void; Obj_type typ; Obj_uident tok] ->
        Token_list [(tok,typ)]
    | [Token_list tl; Obj_uident tok] -> Token_list ((tok,"No_type")::tl)
    | [Token_list tl; Obj_type typ; Obj_uident tok] ->
        Token_list ((tok,typ)::tl)
    | _ -> failwith "a_token_list"
),true,false,Data_void,dd,ld,[],[],prd,None,None)


let r_relation_1 = (ntn_relation,[Ter tn_kwd_relation],default_priority) 
(* relation -> Kwd_relation *)
let r_relation_2 = (ntn_relation,[Ter tn_kwd_relation; Ter tn_lident; Ter tn_colon; Ter tn_lident],default_priority)
(* relation -> Kwd_relation Lident Colon Lident *)
let r_relation_3 = (ntn_relation,[Non_ter (ntn_relation,No_priority); Ter tn_lident; Ter tn_colon; Ter tn_lident],default_priority)
(* relation -> relation Lident Colon Lident *)

let a_relation = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [Obj_void] -> Relation []
    | [Obj_void; Obj_lident p1; Obj_void; Obj_lident p2] -> Relation [(p1,p2)]
    | [Relation rel; Obj_lident p1; Obj_void; Obj_lident p2] -> Relation ((p1,p2)::rel)
    | _ -> failwith "a_relation"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_grammar_1 = (ntn_grammar,[Ter tn_lident; Ter tn_colon; Non_ter (ntn_bar_opt,No_priority); Non_ter (ntn_literal_list,No_priority); Ter tn_ocaml_code; Non_ter (ntn_priority,No_priority)],default_priority)
(* grammar -> Lident Colon opt_bar literal_list Ocaml_code priority *)
let r_grammar_2 = (ntn_grammar,[Non_ter (ntn_grammar,No_priority); Ter tn_lident; Ter tn_colon; Non_ter (ntn_bar_opt,No_priority); Non_ter (ntn_literal_list,No_priority); Ter tn_ocaml_code; Non_ter (ntn_priority,No_priority)],default_priority)
(* grammar -> grammar Lident Colon opt_bar literal_list Ocaml_code priority *)
let r_grammar_3 = (ntn_grammar,[Non_ter (ntn_grammar,No_priority);Ter tn_bar; Non_ter (ntn_literal_list,No_priority); Ter tn_ocaml_code; Non_ter (ntn_priority,No_priority)],default_priority)
(* grammar -> grammar Bar literal_list Ocaml_code priority *)

let r_grammar_4 = (ntn_grammar,[Ter tn_lident; Ter tn_colon; Non_ter (ntn_bar_opt,No_priority); Non_ter (ntn_literal_list,No_priority); Ter tn_kwd_full; Ter tn_ocaml_code; Non_ter (ntn_priority,No_priority)],default_priority)
(* grammar -> Lident Colon opt_bar literal_list KWD_FULL Ocaml_code priority *)
let r_grammar_5 = (ntn_grammar,[Non_ter (ntn_grammar,No_priority); Ter tn_lident; Ter tn_colon; Non_ter (ntn_bar_opt,No_priority); Non_ter (ntn_literal_list,No_priority); Ter tn_kwd_full; Ter tn_ocaml_code; Non_ter (ntn_priority,No_priority)],default_priority)
(* grammar -> grammar Lident Colon opt_bar literal_list KWD_FULL Ocaml_code priority *)
let r_grammar_6 = (ntn_grammar,[Non_ter (ntn_grammar,No_priority);Ter tn_bar; Non_ter (ntn_literal_list,No_priority); Ter tn_kwd_full; Ter tn_ocaml_code; Non_ter (ntn_priority,No_priority)],default_priority)
(* grammar -> grammar Bar literal_list KWD_FULL Ocaml_code priority *)

let a_grammar = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [Obj_lident nt;Obj_void;Obj_void;Literal_list ll;Code c;Obj_lident p] ->
        Grammar [(nt,p,List.rev ll,Classic_action c)]
    | [Grammar g;Obj_lident nt;Obj_void;Obj_void;Literal_list ll;Code c;Obj_lident p] ->
        Grammar ((nt,p,List.rev ll,Classic_action c)::g)
    | [Grammar g;Obj_void;Literal_list ll;Code c;Obj_lident p] ->
        let last_rule = List.hd g in
        let lhs_non_terminal,_,_,_ = last_rule in
        Grammar ((lhs_non_terminal,p,List.rev ll,Classic_action c)::g)
    | [Obj_lident nt;Obj_void;Obj_void;Literal_list ll;Obj_void;Code c;Obj_lident p] ->
        Grammar [(nt,p,List.rev ll,Full_action c)]
    | [Grammar g;Obj_lident nt;Obj_void;Obj_void;Literal_list ll;Obj_void;Code c;Obj_lident p] ->
        Grammar ((nt,p,List.rev ll,Full_action c)::g)
    | [Grammar g;Obj_void;Literal_list ll;Obj_void;Code c;Obj_lident p] ->
        let last_rule = List.hd g in
        let lhs_non_terminal,_,_,_ = last_rule in
        Grammar ((lhs_non_terminal,p,List.rev ll,Full_action c)::g)
    | _ -> failwith "a_grammar"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_bar_opt_0 = (ntn_bar_opt,[],default_priority)
(* bar_opt -> *)
let r_bar_opt_1 = (ntn_bar_opt,[Ter tn_bar],default_priority)
(* bar_opt -> Bar *)

let a_bar_opt = Dyp_special_types.Dypgen_action(fun _ _ _ d dd ld _ prd _ -> Obj_void,true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_literal_list_0 = (ntn_literal_list,[],default_priority)
(* literal_list ->  *)
let r_literal_list_1 = (ntn_literal_list,[Ter tn_uident],default_priority)
(* literal_list -> Uident *)
let r_literal_list_2 = (ntn_literal_list,[Ter tn_lident],default_priority)
(* literal_list -> Lident *)
let r_literal_list_3 = (ntn_literal_list,[Ter tn_lident; Ter tn_lparen; Ter tn_equal; Ter tn_lident; Ter tn_rparen],default_priority)
(* literal_list -> Lident Lparen Equal Lident Rparen *)
let r_literal_list_4 = (ntn_literal_list,[Ter tn_lident; Ter tn_lparen; Ter tn_lident; Ter tn_rparen],default_priority)
(* literal_list -> Lident Lparen Lident Rparen *)
let r_literal_list_5 = (ntn_literal_list,[Non_ter (ntn_literal_list,No_priority); Ter tn_uident],default_priority)
(* literal_list -> literal_list Uident *)
let r_literal_list_6 = (ntn_literal_list,[Non_ter (ntn_literal_list,No_priority); Ter tn_lident],default_priority)
(* literal_list -> literal_list Lident *)
let r_literal_list_7 = (ntn_literal_list,[Non_ter (ntn_literal_list,No_priority); Ter tn_lident; Ter tn_lparen; Ter tn_equal; Ter tn_lident; Ter tn_rparen],default_priority)
(* literal_list -> literal_list Lident Lparen Equal Lident Rparen *)
let r_literal_list_8 = (ntn_literal_list,[Non_ter (ntn_literal_list,No_priority); Ter tn_lident; Ter tn_lparen; Ter tn_lident; Ter tn_rparen],default_priority)
(* literal_list -> literal_list Lident Lparen Lident Rparen *)

let a_literal_list = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [] -> Literal_list []
    | [Obj_uident tok] ->
        Literal_list [Obj_terminal tok]
    | [Obj_lident nt] ->
        Literal_list [Obj_non_terminal (nt,"No_priority",false)]
    | [Obj_lident nt; Obj_lparen; Obj_equal; Obj_lident p; Obj_rparen] -> 
        Literal_list [Obj_non_terminal (nt,p,true)]
    | [Obj_lident nt; Obj_lparen; Obj_lident p; Obj_rparen] -> 
        Literal_list [Obj_non_terminal (nt,p,false)]
    | [Literal_list ll; Obj_uident tok] -> 
        Literal_list ((Obj_terminal tok)::ll)
    | [Literal_list ll; Obj_lident nt] ->
        Literal_list ((Obj_non_terminal (nt,"No_priority",false))::ll)
    | [Literal_list ll; Obj_lident nt; Obj_lparen; Obj_equal; Obj_lident p; Obj_rparen] -> 
        Literal_list ((Obj_non_terminal (nt,p,true))::ll)
    | [Literal_list ll; Obj_lident nt; Obj_lparen; Obj_lident p; Obj_rparen] -> 
       Literal_list ((Obj_non_terminal (nt,p,false))::ll)
    | _ -> failwith "a_literal_list"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let r_priority_0 = (ntn_priority,[],default_priority)
let r_priority_1 = (ntn_priority,[Ter tn_lident],default_priority)

let a_priority = Dyp_special_types.Dypgen_action(fun l _ _ d dd ld _ prd _ ->
  (match l with
    | [] -> Obj_lident "default priority"
    | [Obj_lident s] -> Obj_lident s
    | _ -> failwith "a_priority"
),true,false,Data_void,dd,ld,[],[],prd,None,None)

let prio_data = empty_priority_data

let parsing_device = create_parsing_device [
(r_pgen_input,a_pgen_input);
(r_optional_code_0,a_optional_code);
(r_optional_code_1,a_optional_code);
(r_start_def,a_start_def);
(r_parser_param_info_0,a_parser_param_info);
(r_parser_param_info_1,a_parser_param_info);
(r_parser_param_info_3,a_parser_param_info);
(r_parser_param_info_4,a_parser_param_info);
(r_token_list_1,a_token_list);
(r_token_list_2,a_token_list);
(r_token_list_3,a_token_list);
(r_token_list_4,a_token_list);
(r_relation_1,a_relation);
(r_relation_2,a_relation);
(r_relation_3,a_relation);
(r_grammar_1,a_grammar);
(r_grammar_2,a_grammar);
(r_grammar_3,a_grammar);
(r_grammar_4,a_grammar);
(r_grammar_5,a_grammar);
(r_grammar_6,a_grammar);
(r_bar_opt_0,a_bar_opt);
(r_bar_opt_1,a_bar_opt);
(r_literal_list_0,a_literal_list);
(r_literal_list_1,a_literal_list);
(r_literal_list_2,a_literal_list);
(r_literal_list_3,a_literal_list);
(r_literal_list_4,a_literal_list);
(r_literal_list_5,a_literal_list);
(r_literal_list_6,a_literal_list);
(r_literal_list_7,a_literal_list);
(r_literal_list_8,a_literal_list);
(r_priority_0,a_priority);
(r_priority_1,a_priority)
] empty_priority_data `LR0 Data_void 0 P.Tools.empty_datadyn nt_names
(Array.make 11 0)

let input_file = !string_ref
let output_file = (Filename.chop_extension input_file)^".ml"
let output_file_mli = (Filename.chop_extension input_file)^".mli"

let lexbuf = Lexing.from_channel (Pervasives.open_in input_file)

let get_value t = match t with
  | LIDENT s -> Obj_lident s
  | UIDENT s -> Obj_uident s
  | OCAML_CODE s -> Code s
  | OCAML_TYPE t -> Obj_type t
  | LPAREN -> Obj_lparen
  | RPAREN -> Obj_rparen
  | EQUAL -> Obj_equal
  | _ -> Obj_void

let data_equal = {
P.Tools.global_data_equal = (==);
P.Tools.local_data_equal = (==) }

let parse_result = glrParse parsing_device get_value get_name str_token ntn_start data_equal [|fun _ -> true|] (fun _ -> "")
[|Dyp.keep_one|]
Pgen_lexer.token lexbuf
(fun _ -> (Lexing.dummy_pos,Lexing.dummy_pos))

let header_main, token_list, relation, non_terminal_start, start_type,
  grammar, trailer_main = match fst (List.hd parse_result) with
  | Pgen_input (c1,(b,d,(st,start_type)),g,c2) -> (c1,b,d,st,start_type,g,c2)
  | _ -> failwith "parse tree"
let header_main = header_main^"\n"
let trailer_main = trailer_main^"\n"

module Ordered_string =
struct
  type t = string
  let compare = Pervasives.compare
end

module String_set = Set.Make(Ordered_string)
module String_map = Map.Make(Ordered_string)


(* string ["a";"b";"c"] returns "[a;b;c]" *)
let string_list sl =
  let aux code s = code^s^";" in
  let code = List.fold_left aux "[" sl in
  let string_length = String.length code in
  (String.sub code 0 (string_length-1))^"]"


let code_token_decl,(*code_export_module,*)token_map =
  let code_token_decl = "type token =" in
  let aux (code_token_decl,token_map) (tok,typ) =
    if typ = "No_type"
    then (code_token_decl^" | "^tok),
      (String_map.add tok typ token_map)
    else (code_token_decl^" | "^tok^" of ("^typ^")"),
      (String_map.add tok typ token_map)
  in
  let code_token_decl,token_map =
    List.fold_left aux (code_token_decl,String_map.empty) token_list
  in
  let code_token_decl = code_token_decl^"\n" in
  code_token_decl,
  (*"module Export_type = \nstruct\n"^
  code_token_decl ^"end\ninclude Export_type\n\n",*)
  token_map



let code_token_name_decl,token_name_map(*, code_number_of_tokens*) =
  let code_token_name_decl = "" in
  let aux (code,n,token_name_map) (tok,_) =
    (code^"let token_name_"^tok^" = "^(string_of_int n)^"\n",
    (n+1),String_map.add tok n token_name_map)
  in
  let code_token_name_decl,n,token_name_map =
    List.fold_left aux (code_token_name_decl,2,String_map.empty) token_list
  in
  (*let code_token_name_decl =
    code_token_name_decl^"let dummy_token_name = "^(string_of_int n)^"\n"
    ^"let token_name_epsilon = "^(string_of_int (n+1))^"\n"
    ^"let token_epsilon = token_name_epsilon\n"
  in*)
  code_token_name_decl^"let token_nb = "^(string_of_int n)^"\n", token_name_map
  (*String_map.add "dummy" n token_name_map,
  "let () = number_of_tokens := "^(string_of_int (n+2))^"\n"*)



let code_token_functions, code_str_token_name =
  let code_token_functions =
    (*"let compare_token_name t1 t2 = Pervasives.compare t1 t2\n"^*)
    "let get_name t = match t with"
  in
  let aux code (tok,typ) =
    if typ = "No_type" then code^" | "^tok^" -> token_name_"^tok
    else code^" | "^tok^" _ -> token_name_"^tok
  in
  let code_token_functions = List.fold_left aux code_token_functions token_list in
  let code_token_functions =
    code_token_functions^"\n"^
    "let str_token t = match t with\n"
  in
  let aux code (tok,typ) =
    if typ = "No_type" then code^" | "^tok^" -> \""^tok^"\""
    else if typ = "int" then code^" | "^tok^" i -> string_of_int i"
    else if typ = "string" then code^" | "^tok^" s -> s"
    else code^" | "^tok^" _ -> \""^tok^"\""
  in
  let code_token_functions =
    (List.fold_left aux code_token_functions token_list)^"\n"
  in
  let code_str_token_name =
    let rec aux token_list = match token_list with
      | (tok,_)::t::l -> "\""^tok^"\";"^(aux (t::l))
      | [(tok,_)] -> "\""^tok^"\""
      | _ -> assert false
    in
    "let token_name_array = [|\"dummy_token\";\"token_epsilon\";"^
    (aux token_list)^"|]\n"^
    "let str_token_name t = token_name_array.(t)\n"
  in
  code_token_functions, code_str_token_name



(*
let code_token_decl = "type token ="
let aux (code_token_decl,token_map) (tok,typ) =
  if typ = "No_type" then (code_token_decl^" | "^tok),(String_map.add tok typ token_map)
  else (code_token_decl^" | "^tok^" of ("^typ^")"),(String_map.add tok typ token_map)
let code_token_decl,token_map = List.fold_left aux (code_token_decl,String_map.empty) token_list
let code_token_decl = code_token_decl^"\n"

let code_token_name_decl = "type token_name ="
let aux code (tok,_) = code^" | token_name_"^tok
let code_token_name_decl = List.fold_left aux code_token_name_decl token_list
let code_token_name_decl = code_token_name_decl^" | token_name_epsilon | token_name_dummy\n"
^"let dummy_token_name = token_name_dummy\n"
^"let token_epsilon = token_name_epsilon\n"

let code_token_functions =
"let compare_token_name t1 t2 = Pervasives.compare t1 t2
let get_name t = match t with"
let aux code (tok,typ) =
  if typ = "No_type" then code^" | "^tok^" -> token_name_"^tok
  else code^" | "^tok^" _ -> token_name_"^tok
let code_token_functions = List.fold_left aux code_token_functions token_list

let code_token_functions = code_token_functions^"\nlet str_token t = match t with\n"
let aux code (tok,typ) =
  if typ = "No_type" then code^" | "^tok^" -> \""^tok^"\""
  else if typ = "int" then code^" | "^tok^" i -> string_of_int i"
  else if typ = "string" then code^" | "^tok^" s -> s"
  else code^" | "^tok^" _ -> \""^tok^"\""
let code_token_functions = List.fold_left aux code_token_functions token_list

let code_token_functions = code_token_functions^"let str_token_name t = match t with\n"
let aux code (tok,_) = code^" | token_name_"^tok^" -> \""^tok^"\""
let code_token_functions = List.fold_left aux code_token_functions token_list
let code_token_functions = code_token_functions^" | token_name_epsilon -> \"epsilon\"\n"
^" | token_name_dummy -> \"dummy\"\n\n"
*)


(*let code_non_terminal_decl = "type non_ter = "
let aux1 st_set ld = match ld with
  | Obj_terminal _ -> st_set
  | Obj_non_terminal (nt,_,_) -> String_set.add nt st_set
let aux2 st_set (lhs_nt,_,ld_list,_) =
  List.fold_left aux1 (String_set.add lhs_nt st_set) ld_list
let non_terminal_set = List.fold_left aux2 String_set.empty grammar
let aux nt_string code = code^" | Non_terminal_name_"^nt_string
let code_non_terminal_decl = String_set.fold aux non_terminal_set code_non_terminal_decl
let code_non_terminal_decl = code_non_terminal_decl^" | Non_terminal_name_startprime\n"*)

let code_non_terminal_decl,non_terminal_set =
  let aux1 st_set ld = match ld with
    | Obj_terminal _ -> st_set
    | Obj_non_terminal (nt,_,_) -> String_set.add nt st_set
  in
  let aux2 st_set (lhs_nt,_,ld_list,_) =
    List.fold_left aux1 (String_set.add lhs_nt st_set) ld_list
  in
  let non_terminal_set = List.fold_left aux2 String_set.empty grammar in
  let aux nt_string (code1,n) =
    code1^"let "^nt_string^" = "^(string_of_int n)^"\n",
    (n+1)
  in
  let code_non_terminal_decl,_ =
    String_set.fold aux non_terminal_set
     ("",1)
  in
  code_non_terminal_decl,
  non_terminal_set



let code_nt_functions =
  let code = "let entry_points = [("^non_terminal_start^",1)]\n"(*^
    "let str_non_terminal nt = nt_names.(nt)\n"*)
  in
  let aux nt_string code = code^";\""^nt_string^"\"" in
  let code_nt_names =
    String_set.fold aux non_terminal_set ""
  in
  let code_nt_names = "let nt_names = [|\"0\""^code_nt_names^"|]\n" in
  code_nt_names^code




let code_main_1 =
"module P = Dyp.Make_dyp(Parser_parameters_module)
open Parser_parameters_module
open P
open P.Parser_PAR
open Dyp
type priority = Dyp.priority
let priority_data, default_priority =
  Dyp.insert_priority Dyp.empty_priority_data \"default_priority\"\n\n"

(*let code_priority_def = "let default_priority = 0\n"*)

let aux (str_set:String_set.t) (p1,p2) =
  String_set.add p2 (String_set.add p1 str_set)
let priority_set = List.fold_left aux String_set.empty relation

let aux1 st_set ld = match ld with
  | Obj_terminal _ -> st_set
  | Obj_non_terminal (_,p,_) -> if p="No_priority" then st_set
      else String_set.add p st_set
let aux2 st_set (_,p,ld_list,_) =
  List.fold_left aux1 (String_set.add p st_set) ld_list
let priority_set = List.fold_left aux2 priority_set grammar

let aux p (st_map,n) = (String_map.add p n st_map,n+1)
let priority_map,_ = String_set.fold aux priority_set (String_map.empty,1)

let priority_map = String_map.add "default priority" 0 priority_map

(*let code_var_list n =
  if n = 0 then "" else
  let rec aux p =
    if n = p then "__dypgen_av_"^(string_of_int p)
    else "__dypgen_av_"^(string_of_int p)^";"^(aux (p+1))
  in
  aux 1*)

let aux (lhs_nt,p,ld_list,ocaml_code) =
  let aux2 code ld = match ld with
    | Obj_terminal ter -> code^"Ter token_name_"^ter^";"
    | Obj_non_terminal (ntn,p,eq) ->
        let code_p =
          if p = "No_priority" then "No_priority "
          else
            (if eq then "Lesseq_priority " else "Less_priority ")^
            (string_of_int (String_map.find p priority_map))
        in
        code^"Non_ter ("^ntn^","^code_p^");"
  in
  (*let code_priority = (string_of_int (String_map.find p priority_map)) in*)
  let code_literal_list = List.fold_left aux2 "" ld_list in
  let string_length = (String.length code_literal_list) in
  let code_literal_list =
    if string_length = 0 then code_literal_list
    else String.sub code_literal_list 0 (string_length-1)
  in
  let code_rule = "("^ lhs_nt^ ",["^ code_literal_list^ "],default_priority)" in
  
  (*let aux_av (code,n) lit =
    let typ = match lit with
      | Obj_terminal ter -> let typ = String_map.find ter token_map in
          if typ = "No_type" then "unit" else typ
      | Obj_non_terminal (nt,_,_) -> "'"^nt
    in code^"let _"^(string_of_int n)^" = (Obj.obj __dypgen_av_"^
      (string_of_int n)^" : "^typ^") in \n",(n+1)
  in
  let action_variable_code,_ = List.fold_left aux_av ("",1) ld_list in*)
  
  (*let rule_type = if lhs_nt = non_terminal_start then start_type else "'"^lhs_nt in*)
  
  let code_var_list =
    let f (code,n) lit = match lit with
      | Obj_terminal ter -> let typ = String_map.find ter token_map in
          if typ = "No_type" then
            code^" _"^(string_of_int n)^";", n+1
          else code^"Obj_"^ter^" _"^(string_of_int n)^";", n+1
      | Obj_non_terminal (nt,_,_) -> code^"Obj_"^nt^" _"^(string_of_int n)^";", n+1
    in
    let c,_ = List.fold_left f ("",1) ld_list in
    let s_length = (String.length c) in
    if s_length = 0 then c
    else String.sub c 0 (s_length-1)
  in
  
  let code_action = match ocaml_code with
    | Classic_action oc_code ->
        "Dyp_special_types.Dypgen_action(fun action_variable__l _ _ _data _dd _ld _lld _prd _ -> (match action_variable__l with ["^
        code_var_list^"] -> Obj_"^lhs_nt^" ("^oc_code^
        ") | _ -> failwith \"Invalid number of arguments in action\"),true,false,_data,_dd,_ld,[],[],_prd,None,None)"
    | Full_action oc_code ->
        "Dyp_special_types.Dypgen_action(fun action_variable__l _ _ _data _dd _ld _lld  _prd _ -> (match action_variable__l with ["^
        code_var_list^"] -> "^
        "let ob,b,d = "^oc_code^
        " in ((Obj_"^lhs_nt^" ob),b,false,d,_dd,_ld,[],[],_prd,None,None)\n"^
        " | _ -> failwith \"Invalid number or kind of arguments in action\"))"
  in
  "("^code_rule^","^code_action^")"

let list_code_rapf = List.map aux grammar
let code_grammar =
  let rec aux sl = match sl with
    | [] -> ""
    | [s] -> s
    | s::t -> s^"\n;\n"^(aux t)
  in "let rapf_list = [\n"^(aux list_code_rapf)^"]\n"

(*let code_grammar = code_grammar^"let current_grammar,nt_nb,map_po,user_g = make_grammar \n"*)

let code_prio_data = "let current_priority_data = empty_priority_data\n"
let aux code (p1,p2) =
  let i1 = string_of_int (String_map.find p1 priority_map) in
  let i2 = string_of_int (String_map.find p2 priority_map) in
  code^"let current_priority_data = update_priority current_priority_data [("^
   i1^","^i2^",true)]\n"
let code_prio_data = (List.fold_left aux code_prio_data relation)^"\n"

let code_main_2 = "let parsing_device = create_parsing_device rapf_list empty_priority_data `LR0 0 0 P.Tools.empty_datadyn nt_names (Array.make (Array.length nt_names) 0)\n"

let code_main_2 = code_main_2^
"let "^non_terminal_start^" f lexbuf =
  let data_equal = {
    P.Tools.global_data_equal = (==);
    P.Tools.local_data_equal = (==) }
  in
  let lexbuf_position lexbuf = (lexbuf.Lexing.lex_curr_p,lexbuf.Lexing.lex_start_p) in
  let pf = glrParse parsing_device __dypgen_get_value get_name str_token "^
  non_terminal_start^
  " data_equal  [|fun _ -> true|] (fun _ -> \"\")
    [|Dyp.keep_one|]
    f lexbuf lexbuf_position in
  let aux1 (o,p) = match o with
    | Obj_"^non_terminal_start^
    " r -> (r,p) | _ -> failwith \"Wrong type for entry result\" in
  List.map aux1 pf\n\n"

let parser_param_header = "
module Parser_parameters_module =
struct\n\n"

(*let code_export_module = "module Export_type = \nstruct\n"^ code_token_decl^"end\ninclude Export_type\n\n"*)

let code_type_obj =
  let code_obj =
    let aux nt code =
      if nt = non_terminal_start then code
      else code^" '"^nt^","
    in
    let type_param =(String_set.fold aux non_terminal_set "") in
    let string_length = String.length type_param in
    let type_param = String.sub type_param 0 (string_length-1) in
    "("^type_param^") obj"
  in
  let aux1 tok typ code = if typ = "No_type" then code^"  | Obj_"^tok^"\n"
    else code^"  | Obj_"^tok^" of ("^typ^")\n"
  in
  let aux2 nt code =
    if nt = non_terminal_start then
      code^"  | Obj_"^nt^" of "^start_type^"\n"
    else code^"  | Obj_"^nt^" of '"^nt^"\n"
  in
  "type "^code_obj^" =\n"^
  (String_map.fold aux1 token_map "")^
  (String_set.fold aux2 non_terminal_set "")^
  "type data = Data_void\n"



(*let code_merge_functions =
  let aux nt_string code = code^"let merge_"^nt_string^" ol _ = ol\n" in
  String_set.fold aux non_terminal_set ""

let code_merge_map =
  let code_merge_function_list = string_list merge_function_list in
  "let merge_map = P.Tools.init_merge_map "^
  code_merge_function_list*)
  (*let aux nt_string code = code^"let merge_map = Nt_map.add "^
    nt_string^" merge_"^nt_string^" merge_map\n" in
  "let merge_map = Nt_map.empty\n"^
  (String_set.fold aux non_terminal_set "")*)

(*let code_merge_map =
  let aux2 nt_string nt_int mfl = ("(fun ol o -> (
  let f1 o = match o with "^obj_pref^"Obj_"^nt_string^" ob -> ob
    | _ -> failwith \"type error, bad obj in dyp_merge_"^nt_string^"\"
  in
  let o = f1 o in
  let ol = List.map f1 ol in
  let ol = dyp_merge_"^nt_string^" ol o in
  let f2 o = "^obj_pref^"Obj_"^nt_string^" o in
  List.map f2 ol)),"^(string_of_int nt_int))::mfl
  in
  let merge_function_list = String_map.fold aux2 non_terminal_map [] in
  let code_merge_function_list = string_list merge_function_list in
  (String_set.fold aux1 non_terminal_set "")^
  "let merge_map = P.Tools.init_merge_map "^code_merge_function_list^"\n"
*)


let code_get_value =
  let aux code (tok,typ) =
    let s = if typ = "No_type" then " -> Obj_"^tok^"\n"
      else " x -> Obj_"^tok^" x\n"
    in
    code^"  | "^tok^s
  in
  "let __dypgen_get_value t = match t with\n"^
  (List.fold_left aux "" token_list)^"\n"

let parser_code = parser_param_header^
  (*code_export_module^*)

  code_token_name_decl^
  code_str_token_name^

  code_non_terminal_decl^
  code_nt_functions^

  (*code_parser_param_info^*)
  "let priority_names = [|\"0\"|]"^
  "let merge_warning = false\n"^
  "let undef_nt = true\n"^
  "end\n\n"^

  code_main_1^
  code_token_decl^
  code_token_functions^
  (*code_number_of_tokens^*)
  code_type_obj^
  code_get_value^
  (*"let merge ol _ = ol\n"^*)
  header_main^
  code_grammar^
  code_prio_data^
  (*code_merge_functions^*)
  trailer_main^
  (*code_merge_map^*)
  code_main_2

let parser_code_mli =
  "type priority\n"^
  code_token_decl^"val "^non_terminal_start^
  " : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> ("^start_type^" * priority) list\n"

let dest_file = open_out output_file
let dest_file_mli = open_out output_file_mli

let () = output_string dest_file parser_code
let () = output_string dest_file_mli parser_code_mli

@h=tangler('dypgen/generators/pgen/pgen_parser_param.ml')
@select(h)
(*module Prio =
struct
  type priority = int
  let compare_priority p1 p2 = Pervasives.compare p1 p2
end

include Prio
include Dyp.Priority_by_relation.Make (Prio)

let init_priority = 0
let str_prio p = (string_of_int p) *)

(*type data = Data_void
let global_data_equal = (==)
let local_data_equal = (==)*)


let undef_nt = true

let tn_lparen = 0
let tn_rparen = 1
let tn_colon = 2
let tn_percentpercent = 3
let tn_lbrace = 4
let tn_rbrace = 5
let tn_bar = 6
let tn_equal = 7
let tn_EOF = 8
let tn_kwd_token = 9
let tn_kwd_start = 10
let tn_kwd_relation = 11
let tn_kwd_full = 12
let tn_ocaml_code = 13
let tn_ocaml_type = 14
let tn_uident = 15
let tn_lident = 16

let token_nb = 17

(*let compare_token_name t1 t2 = Pervasives.compare t1 t2*)
let token_names = [|"dummy";"epsilon";"(";")";":";"%%";"{";"}";"|";"=";"EOF";"%token";"%start";"%relation";"%full";"ocaml_code";"ocaml_type";"Uident";"Lident"|]
let str_token_name t = token_names.(t)

type token = LPAREN | RPAREN | COLON | PERCENTPERCENT | LBRACE | RBRACE | BAR | EQUAL | EOF | KWD_TOKEN | KWD_START | KWD_RELATION | KWD_FULL | OCAML_CODE of string | OCAML_TYPE of string | UIDENT of string | LIDENT of string


(*type token_assoc = Token_assoc_left | Token_assoc_right | Token_nonassoc | Token_assoc
module Ordered_token_name =
struct
  type t = token_name
  let compare = Pervasives.compare
end
module TN_map = Map.Make(Ordered_token_name)
let token_assoc_map = TN_map.empty*)


let entry_points = [(1,1)]

let nt_names = [|"S'";"start";"parser_param_info";"token_list";"relation";"start_def";"grammar";"bar_opt";"literal_list";"priority";"optional_code"|]

(*let str_non_terminal nt = nt_names.(nt)*)

type token_desc = string * string (* 2nd string is for type, if no type is mentioned then the string No_type is chosen *)
type literal_desc = Obj_terminal of string | Obj_non_terminal of (string * string * bool) (* 2nd string for the priority identifier, bool is true=Toeq, bool is false=To *)
type action_desc = Classic_action of string | Full_action of string
type rule_desc = (string * string * (literal_desc list) * action_desc)
type relation_desc = ((string * string) list)
type parser_param_info = (token_desc list) * relation_desc * (string * string)
(*last string is for start statement *)
let priority_names = [|"0"|]

let merge_warning = false

@h=tangler('dypgen/generators/dypgen/dypgen_parser.dyp')
@select(h)
{
open Printf
open Parse_tree

let () = dypgen_verbose := 0

let empty_ppi = {
  token_list = [];
  relation = [];
  start = [];
  generic_merge = [];
  cons = [];
  additional_cons = [];
  nt_type = [];
  single_nt = [] }
}

%token LPAREN RPAREN COMMA SEMI COLON PERCENTPERCENT LBRACE RBRACE BAR LESS GREATER EQUAL KWD_TOKEN KWD_START KWD_RELATION KWD_MLI KWD_MLITOP KWD_MLTOP KWD_MERGE KWD_CONSTRUCTOR KWD_FOR KWD_TYPE KWD_NON_TERMINAL <string * (int * int)> OCAML_CODE <string> OCAML_TYPE <string * (int * int)> PATTERN <string * (int * int * int)> UIDENT <string * (int * int * int)> LIDENT EOF

%start <Parse_tree.obj> main

%%

main: | optional_mltop optional_code parser_param_infos PERCENTPERCENT grammar optional_trailer optional_mlitop optional_mli EOF
  { ($1,$2,$3, List.rev $5,$6,$7,$8) }

optional_trailer:
  |                           { ("",(0,0)) }
  | PERCENTPERCENT OCAML_CODE { $2 }

parser_param_info:
  | KWD_START OCAML_TYPE LIDENT  { {empty_ppi with start = [((fst $3),$2)]} }
  | token_list                   { {empty_ppi with token_list = $1} }
  | relation                     { {empty_ppi with relation = $1} }
  | KWD_CONSTRUCTOR UIDENT KWD_FOR lident_list
      { { empty_ppi with cons = [(fst $2,List.rev $4)] }  }
  | KWD_CONSTRUCTOR uident_list
      { { empty_ppi with additional_cons = List.rev $2 }  }
  | KWD_MERGE LIDENT uident_list
      { {empty_ppi with generic_merge = [((fst $2),List.rev $3)]} }
  | KWD_TYPE OCAML_TYPE lident_list
      { {empty_ppi with nt_type = [$2,List.rev $3]} }
  | KWD_NON_TERMINAL lident_list
      { {empty_ppi with single_nt = List.rev $2} }

parser_param_infos:
  | parser_param_info { $1 }
  | parser_param_infos parser_param_info
    %full {
      { token_list = ($2.token_list@$1.token_list);
        relation = $2.relation@$1.relation;
        start = $2.start@$1.start;
        generic_merge = $2.generic_merge@$1.generic_merge;
        cons = $2.cons@$1.cons;
        additional_cons = $2.additional_cons@$1.additional_cons;
        nt_type = $2.nt_type@$1.nt_type;
        single_nt = $2.single_nt@$1.single_nt },
        false,$data }

lident_list:
  | LIDENT             { [(fst $1)] }
  | lident_list LIDENT { (fst $2)::$1 }

uident_list:
  | UIDENT             { [(fst $1)] }
  | uident_list UIDENT { (fst $2)::$1 }

optional_code:
  |            { ("",(0,0)) }
  | OCAML_CODE { $1 }

optional_mli:
  |                    { ("",(0,0)) }
  | KWD_MLI OCAML_CODE { $2 }

optional_mlitop:
  |                    { ("",(0,0)) }
  | KWD_MLITOP OCAML_CODE { $2 }

optional_mltop:
  |                    { ("",(0,0)) }
  | KWD_MLTOP OCAML_CODE { $2 }


token_list:
  | KWD_TOKEN UIDENT             { [((fst $2),"No_type")] }
  | KWD_TOKEN OCAML_TYPE UIDENT  { [((fst $3),$2)] }
  | token_list UIDENT            { ((fst $2),"No_type")::$1 }
  | token_list OCAML_TYPE UIDENT { ((fst $3),$2)::$1 }

relation:
  | KWD_RELATION { [] }
  | relation relation_list { (Rel_list (List.rev $2))::$1 }
  | relation LIDENT { (Rel_single (fst $2))::$1 }

relation_list:
  | LIDENT LESS LIDENT { [(fst $3);(fst $1)] }
  | relation_list LESS LIDENT { (fst $3)::$1 }

grammar:
  | grammar entry_def  { $2@$1 }
  | entry_def  { $1 }

entry_def:
  LIDENT COLON opt_bar rhs_list
  { let f (rl1,rl2) (prio,litl,pa_l,code,add_rules) =
      (fst $1,prio,litl,pa_l,code)::rl1,add_rules@rl2
    in
    let rl1,rl2 = List.fold_left f ([],[]) (List.rev $4) in
    rl2@rl1 }

rhs_list:
  | rhs { [$1] }
  | rhs_list BAR rhs { $3::$1 }

rhs:
  | literal_list OCAML_CODE priority
      { let litl,_,part_act_l,additional_rules = $1 in
        ($3,List.rev litl, part_act_l, $2, additional_rules) }

opt_bar:
  |     { () }
  | BAR { () }

literal_list:
  |        { ([],0,[],[]) }
  | literal_list opt_par_act literal opt_pattern
      { let l,len,part_act_l,add_rule1 = $1 in
        if len=0 && $2<>(("",(0,0)),[("_","_",(0,0))])
        then raise Giveup else
        let part_act_l =
          let pa,patl = $2 in
          if pa=("",(0,0)) then part_act_l
          else ((pa,len),patl)::part_act_l
        in
        let lit,add_rule2 = $3 in
        let pat_typ = match lit with
          | Obj_terminal s -> fst s
          | Obj_non_terminal (s,_,_,_) -> s
        in
        ( ((lit,([fst $4,pat_typ,snd $4]:((string*string*(int*int)) list)))::l), (len+1),
          part_act_l, add_rule2@add_rule1 ) }

literal:
  | UIDENT { (Obj_terminal $1),[] }
  | nested {
      (Obj_non_terminal ((fst (fst $1)),
        ("No_priority",(-1,-1,-1)),Pr_eq,1)),
      (snd $1) }
  | LIDENT LPAREN EQUAL LIDENT RPAREN
      { (Obj_non_terminal ((fst $1),$4,Pr_eq,1)),[] }
  | LIDENT LPAREN LESS EQUAL LIDENT RPAREN
      { (Obj_non_terminal ((fst $1),$5,Pr_lesseq,1)),[] }
  | LIDENT LPAREN LESS LIDENT RPAREN
      { (Obj_non_terminal ((fst $1),$4,Pr_less,1)),[] }
  | LIDENT LPAREN GREATER EQUAL LIDENT RPAREN
      { (Obj_non_terminal ((fst $1),$5,Pr_greatereq,1)),[] }
  | LIDENT LPAREN GREATER LIDENT RPAREN
      { (Obj_non_terminal ((fst $1),$4,Pr_greater,1)),[] }


nested:
  | LIDENT { ($1,[]) }
  | LPAREN rhs_list RPAREN  %full
    { let nt = "dypgen__nested_nt_"^(string_of_int $data) in
      let f (rl1,rl2) (prio,litl,pa_l,code,add_rules) =
        (nt,prio,litl,pa_l,code)::rl1,add_rules@rl2
      in
      let rl1,rl2 = List.fold_left f ([],[]) (List.rev $2) in
      ((nt,(0,0,0)),rl2@rl1),true,($data+1) }

priority:
  |        { ("default_priority",(-1,-1,-1)) }
  | LIDENT { $1 }


opt_par_act:
  |                        { (("",(0,0)),["_","_",(0,0)]) }
  | OCAML_CODE opt_pattern { ($1,[fst $2,"_",snd $2]) }

opt_pattern:
  |         { ("_",(0,0)) }
  | PATTERN { (fst $1,snd $1) }

@h=tangler('dypgen/generators/dypgen/parse_tree.mli')
@select(h)
type token_desc = string * string
(* 2nd string is for type, if no type is mentioned then the string No_type is chosen *)
type nt_priority_desc = Pr_eq | Pr_less | Pr_lesseq | Pr_greater | Pr_greatereq
type literal_desc = Obj_terminal of (string * (int * int * int)) (* (line,col1,col2) *)
  | Obj_non_terminal of (string * (string * (int * int * int)) * nt_priority_desc * int)
(* 2nd string for the priority identifier, bool is true=Toeq, bool is false=To *)
(* the last int is the number of arguments, the parser always returns 1 for it. It is used for partial actions, a rule with partial actions is split and new non terminals are created by dypgen. The result of partial action is a (n+1)-tuple if there are n arguments for this action, thus the following partial actions or the action, can access these arguments. The n arguments are the n first values of the (n+1)-tuple and the last value is the value computed by the partial action.*)
type priority_desc = (string * (int * int * int)) (*| Prio_fun of (string * int)*)
type action_desc = string * (int * int)
type pattern_desc = (string * string * (int * int)) list
type rule_desc = string * priority_desc * ((literal_desc * pattern_desc) list) *
  (((action_desc * int) * pattern_desc) list) * action_desc
(*
(((action_desc * int) * (string list)) list) is the list of the partial actions, the int is the place of the partial action in the right-hand side.
The string lists after literal_desc and action_desc are patterns. the parser only retuns list of one element, but the processing of patterns of partial actions makes use of the list.
*)
type relation_desc = Rel_list of (string list) | Rel_single of string
type set_desc = string * (string list)
type parser_param_info = {
  token_list : token_desc list;
  relation : relation_desc list;
  start : (string * string) list;
  generic_merge :(string * (string list)) list;
  cons : (string * (string list)) list;
  additional_cons : string list;
  nt_type : (string * string list) list;
  single_nt : string list }
type obj = action_desc * action_desc * parser_param_info * (rule_desc list) * action_desc * action_desc * action_desc

@h=tangler('dypgen/generators/dypgen/argument.ml')
@select(h)
let verbose = ref 1
let merge_warning = ref false
let lexer = ref "ocamllex"
let aut_kind = ref "`LR0"
let emit_token_type = ref true
let priority_enforcement = ref "PIA"
let process_verbose_mode () = verbose := 2
let process_merge_warning () = merge_warning := true
let process_lexer s = if s="ocamllex" || s="ulex" || s="other" then lexer := s else failwith "illegal --lexer option"

(*let process_aut_kind s = if s="LR0" || s="LALR" || s="LR1" then aut_kind := s else failwith "illegal --automaton option"*)

let process_aut_kind s =
  if s="LR0" then ()
  else if s="LALR" || s="LR1" then
    (Printf.fprintf stderr
    "Sorry, %s is not available in this version of dypgen\n" s;
    exit 2)
  else failwith "illegal --automaton option"

let process_prio_aut () = priority_enforcement:="PIA"
let process_prio_pt () = priority_enforcement:="PAR"

let string_ref = ref ""
let process_argument s =
  if s = "" then raise (Arg.Bad "missing input file name")
  else string_ref := s
let pv_obj = ref false
let process_pv_obj () = pv_obj := true
let pv_token = ref false
let process_pv_token () = pv_token := true
let process_noemit_token_type () = emit_token_type := false

let undef_nt = ref true
let process_no_undef_nt () = undef_nt := false

let process_version () = print_endline "version 20070726"

let list_arg = [
("-v",Arg.Unit process_verbose_mode,"activates verbose mode: gives details of the parsing of the input file");
("--merge-warning",Arg.Unit process_merge_warning,"activates merge warning: the generated parser will emit a warning on the standard output each time a merge happens");
("--lexer",Arg.String process_lexer,"by default the lexer is ocamllex, use --lexer ulex to specify ulex as the lexer and --lexer other for another lexer, this has an effect on the interface of the parser.");

(*("--automaton",Arg.String process_aut_kind,"by default the automaton is LR(0), use --automaton LALR or --automaton LR1 if you prefer one of them");*)

("--automaton",Arg.String process_aut_kind,"");

(*("--prio-aut",Arg.Unit process_prio_aut,"use --prio-aut to make the priority enforcement embedded into the automaton, by default they are enforced while parsing.");*)

("--prio-pt",Arg.Unit process_prio_pt,"use --prio-pt to make the priorities  be enforced at parsing time, by default their enforcement is embedded into the automaton.");

("--pv-obj",Arg.Unit process_pv_obj,"the type constructor obj is made as a sum of polymorphic variants instead of a sum of constructors. This is useful when the maximum number of constructors allowed is reached.");
("--pv-token",Arg.Unit process_pv_token,"the type token is made as a sum of polymorphic variants instead of a sum of constructors. This is useful when the maximum number of constructors allowed is reached.");
("--noemit-token-type",Arg.Unit process_noemit_token_type,"the type token is not emitted in the mli or ml files, it must be provided by the user instead.");

("--no-undef-nt",Arg.Unit process_no_undef_nt,"prevents the exception Undefined_nt from being raised.");

("--version",Arg.Unit process_version,"gives the version of dypgen and exit.")
]

(*let _ = Arg.parse list_arg process_argument "usage: dypgen [-v] [--noemit-token-type] [--merge-warning] [--lexer (ocamllex|ulex|other)] [--automaton (LR0|LALR|LR1)] [--prio-aut] [--pv-obj] file_name.dyp"*)

let _ = Arg.parse list_arg process_argument "usage: dypgen [-v] [--merge-warning] [--lexer (ocamllex|ulex|other)] [--prio-pt] [--pv-obj] [--no-bad-cons] [--no-undef-nt] file_name.dyp"

(*let _ = if !string_ref = "" then
  let _ = print_string "usage: dypgen [-v] [--merge-warning] [--lexer (ocamllex|ulex|other)] [--automaton (LR0|LALR|LR1)] [--prio-aut] [--pv-obj] file_name.dyp\n" in exit 0*)

let _ = if !string_ref = "" then
  let _ = print_string "usage: dypgen [-v] [--merge-warning] [--lexer (ocamllex|ulex|other)] [--prio-pt] [--pv-obj] [--no-bad-cons] [--no-undef-nt] file_name.dyp\n" in exit 0

@h=tangler('dypgen/generators/dypgen/dypgen.ml')
@select(h)
open Parse_tree
open Lexing
open Printf
open Dypgen_lexer


let input_file = !(Argument.string_ref)
let input_file_short = Filename.chop_extension input_file
let output_file = input_file_short^".ml"
let output_file_mli = input_file_short^".mli"


let lexbuf = Lexing.from_channel (Pervasives.open_in input_file)

let parse_result =
  try Dypgen_parser.main Dypgen_lexer.token lexbuf
  with Failure _ -> (
    let b = ref true in
    let () = match !start_dypgen_comment with
      | [] -> ()
      | pos::_ ->
          let line = pos.pos_lnum in
          let col = pos.pos_cnum - pos.pos_bol in
          let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nDypgen comment not terminated\n"
        input_file line col
    in
    if !start_ocaml_type<>dummy_pos then (
      let line = !start_ocaml_type.pos_lnum in
      let col = !start_ocaml_type.pos_cnum - !start_ocaml_type.pos_bol in
      let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nOcaml type statement not terminated\n"
        input_file line col);
    if !start_pattern<>dummy_pos then (
      let line = !start_pattern.pos_lnum in
      let col = !start_pattern.pos_cnum - !start_pattern.pos_bol in
      let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nOcaml pattern not terminated\n"
        input_file line col);
    if !start_ocaml_code<>dummy_pos then (
      let line = !start_ocaml_code.pos_lnum in
      let col = !start_ocaml_code.pos_cnum - !start_ocaml_code.pos_bol in
      let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nOcaml code not terminated\n"
        input_file line col);
    if !start_string<>dummy_pos then (
      let line = !start_string.pos_lnum in
      let col = !start_string.pos_cnum - !start_string.pos_bol in
      let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nString not terminated\n"
        input_file line col);
    let () = match !start_bracket with
      | [] -> ()
      | pos::_ ->
          let line = pos.pos_lnum in
          let col = pos.pos_cnum - pos.pos_bol in
          let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nBracket not closed\n"
        input_file line col
    in
    let () = match !start_curlyb with
      | [] -> ()
      | pos::_ ->
          let line = pos.pos_lnum in
          let col = pos.pos_cnum - pos.pos_bol in
          let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nCurly brace not closed\n"
        input_file line col
    in
    let () = match !start_ocaml_comment with
      | [] -> ()
      | pos::_ ->
          let line = pos.pos_lnum in
          let col = pos.pos_cnum - pos.pos_bol in
          let () = b:= false in
      fprintf stderr "File \"%s\", line %d, character %d:\nDypgen comment not terminated\n"
        input_file line col
    in
    if !b then (
      let line2 = lexbuf.lex_curr_p.pos_lnum in
      let col2 = lexbuf.lex_curr_p.pos_cnum - lexbuf.lex_curr_p.pos_bol in
      let pos1 = lexeme_start_p lexbuf in
      let line1 = pos1.pos_lnum in
      let col1 = pos1.pos_cnum - pos1.pos_bol in
      if line1=line2 then
        fprintf stderr "File \"%s\", line %d, characters %d-%d:\nLexing failed\n"
          input_file line2 col1 col2
      else
        fprintf stderr "File \"%s\", from l:%d, c:%d to l:%d, c:%d :\nLexing failed\n"
          input_file line1 col1 line2 col2);
    exit 2)
  | Dyp.Syntax_error -> (
      let line2 = lexbuf.lex_curr_p.pos_lnum in
      let col2 = lexbuf.lex_curr_p.pos_cnum - lexbuf.lex_curr_p.pos_bol in
      let pos1 = lexeme_start_p lexbuf in
      let line1 = pos1.pos_lnum in
      let col1 = pos1.pos_cnum - pos1.pos_bol in
      if line1=line2 then
        fprintf stderr "File \"%s\", line %d, characters %d-%d\nSyntax error\n"
          input_file line2 col1 col2
      else
        fprintf stderr "File \"%s\", from l:%d, c:%d to l:%d,c:%d\nSyntax error\n"
          input_file line1 col1 line2 col2;
    exit 2)



let 
  (topheader_main,(topheader_main_pos,topheader_main_offset)), 
  (header_main,(header_main_pos,header_main_offset)), 
  token_list, 
  relation,
  non_terminal_start_list, 
  generic_merge, 
  cons_list, 
  nt_type_list,
  single_nt_list, 
  add_cons_list,
  grammar, 
  (trailer_main,(trailer_main_pos,trailer_main_offset)),
  (topmli_code,(topmli_code_pos,topmli_code_offset)) ,
  (mli_code,(mli_code_pos,mli_code_offset)) 
  =
    let mltop,c1,ppi,g,c2,mlitop,c3 = fst (List.hd parse_result) in
    (mltop,c1,ppi.token_list,ppi.relation,ppi.start,
    ppi.generic_merge,ppi.cons,ppi.nt_type,ppi.single_nt,
    ppi.additional_cons,g,c2,mlitop,c3)


let obj_pref = if !Argument.pv_obj then "`" else ""
let token_pref = if !Argument.pv_token then "`" else ""



let append_string_to_buffer buf str =
  Buffer.add_string buf str; buf

let ($) = append_string_to_buffer



(* string ["a";"b";"c"] returns "[a;b;c]" *)
let string_list sl =
  let aux code s = code^s^";" in
  let code = List.fold_left aux "[" sl in
  let string_length = String.length code in
  (if code="" then "" else String.sub code 0 (string_length-1))^"]"



let grammar =
  
  let n_first l n =
    let rec aux l1 l n =
      if n=0 then (List.rev l1,l) else match l with
        | h::t ->
            aux (h::l1) t (n-1)
        | [] -> failwith "grammar n_first"
    in
    aux [] l n
  in
  (*let rec n_first l n =
    if n=0 then [],l else match l with
      | h::t ->
          let l1,l2 = n_first t (n-1) in h::l1,l2
      | [] -> failwith "grammar n_first"
  in*)
  let return_n n =
    let rec aux res n =
      if n=0 then res
      else aux ("_"^(string_of_int n)^","^res) (n-1)
    in
    aux "" n
  in
  
  let aux (new_gr,newnt_nb) ra =
    
    let (lhs_nt,prio,ld_list,(par_act_l:((action_desc*int)*pattern_desc) list),
      (ocaml_code,ocaml_code_pos)) = ra in
    if par_act_l = [] then
    ((lhs_nt,prio,ld_list,(par_act_l:((action_desc*int)*pattern_desc) list),
      ((ocaml_code,("","")),ocaml_code_pos))::new_gr,newnt_nb)
    else
    
    let rec f new_gr newnt_nb litl last_pos res_nb
              (par_act_l:((action_desc*int)*pattern_desc) list) patternl =
      match par_act_l with
      | [] -> (new_gr,newnt_nb,litl,res_nb,patternl)
      | (((ac_code,i),pos),patl)::tl ->
          let arg_nb = pos-last_pos in
          let new_nt = if last_pos = 0 then [] else
            [(Obj_non_terminal ("dypgen__nt_"^(string_of_int (newnt_nb-1)),
            ("No_priority",(-1,-1,-1)),Pr_eq,res_nb)),patternl]
          in
          let litl1,litl2 = n_first litl arg_nb in
          let new_litl = new_nt@litl1 in
          let patternl = List.map (fun (_,x) -> x) new_litl in
          let patternl = List.flatten patternl in
          let patternl = patternl@patl in
          let ac_code = ac_code,("("^(return_n (res_nb+arg_nb))^"(","))") in
          let new_gr =
            ("dypgen__nt_"^(string_of_int newnt_nb),("default_priority",(-1,-1,-1)),
            new_litl,[],(ac_code,i))::new_gr
          in
          f new_gr (newnt_nb+1) litl2 pos (res_nb+arg_nb+1) tl patternl
    in
    
    let new_gr,newnt_nb,litl,res_nb,patternl =
      f new_gr newnt_nb ld_list 0 0 par_act_l []
    in
    let new_nt =
      ((Obj_non_terminal ("dypgen__nt_"^(string_of_int (newnt_nb-1)),
      ("No_priority",(-1,-1,-1)),Pr_eq,res_nb)),patternl)
    in
    let new_litl = new_nt::litl in
    let new_gr =
      (lhs_nt,prio,new_litl,[],((ocaml_code,("","")),ocaml_code_pos))::new_gr
    in
    (new_gr,newnt_nb)
  in
  let g,_ = List.fold_left aux ([],0) grammar in g


let insert_line_number = "\n# insert-line-number \""^output_file^"\"\n"
let sharp_line_number lnum = "\n# "^(string_of_int lnum)^" \""^input_file^"\"\n"

let space_string n = String.make (max n 0) ' '


let topheader_main = if topheader_main="" then "\n" else
  (sharp_line_number topheader_main_pos)^(space_string topheader_main_offset)^
  topheader_main^insert_line_number
let header_main = if header_main="" then "\n" else
  (sharp_line_number header_main_pos)^(space_string header_main_offset)^
  header_main^insert_line_number
let trailer_main = if trailer_main = "" then ""
  else(sharp_line_number trailer_main_pos)^(space_string trailer_main_offset)^
  trailer_main^insert_line_number
let topmli_code = if topmli_code = "" then "\n" else
  (sharp_line_number topmli_code_pos)^(space_string topmli_code_offset)^
  topmli_code^insert_line_number
let mli_code = if mli_code = "" then "\n" else
  (sharp_line_number mli_code_pos)^(space_string mli_code_offset)^
  mli_code^insert_line_number


module Ordered_string =
struct
  type t = string
  let compare = Pervasives.compare
end

module String_set = Set.Make(Ordered_string)
module String_map = Map.Make(Ordered_string)



let nt_type_map =
  let f2 typ nt_type_map nt =
    String_map.add nt typ nt_type_map
  in
  let f1 nt_type_map (typ,nt_list) =
    List.fold_left (f2 typ) nt_type_map nt_list
  in
  let nt_type_map = List.fold_left f1 String_map.empty nt_type_list in
  let f3 nt_type_map (nt,typ) = f2 typ nt_type_map nt in
  List.fold_left f3 nt_type_map non_terminal_start_list



let code_undef_nt =
  if !Argument.undef_nt then "  let undef_nt = true\n"
  else "  let undef_nt = false\n"



let code_type_token, (*code_export_module,*) token_map =
  let lbra,rbra = if !Argument.pv_token then " [","]" else "","" in
  let code_type_token = "type token ="^lbra^"\n" in
  let aux (code_type_token,token_map) (tok,typ) =
    if typ = "No_type" then
      (code_type_token^"  | "^token_pref^tok^"\n"),
      (String_map.add tok typ token_map)
    else
      (code_type_token^"  | "^token_pref^tok^" of ("^typ^")\n"),
      (String_map.add tok typ token_map)
  in
  let code_type_token, token_map =
    List.fold_left aux (code_type_token,String_map.empty) token_list
  in
  let code_type_token = code_type_token^rbra^"\n"
  in
  (if !Argument.emit_token_type then code_type_token else ""),
  (*"module Export_type =\nstruct\n"^
  code_type_token ^"end\ninclude Export_type\n\n",*)
  token_map



let code_token_name_decl,token_name_map,code_token_nb =
  (*let code_token_name_decl = "type token_name = int\n" in*)
  let token_name_map = String_map.empty in
  (*let token_name_map = String_map.add "dummy" 0 String_map.empty in
  let token_name_map = String_map.add "epsilon" 1 token_name_map in*)
  let aux (code,n,token_name_map) (tok,_) =
    (code^"  let t_"^tok^" = "^(string_of_int n)^"\n",
    (n+1),String_map.add tok n token_name_map)
  in
  let code_token_name_decl,n,token_name_map =
    List.fold_left aux
      ("",1+(List.length non_terminal_start_list),token_name_map)
      token_list
  in
  code_token_name_decl, token_name_map,
  "  let token_nb = "^(string_of_int n)^"\n"



let code_get_token_name, code_str_token, code_str_token_name, code_token_name_array =
  let code_get_token_name =
    "  let get_token_name t = match t with\n"
  in
  let aux code (tok,typ) =
    if typ = "No_type" then code^"    | "^token_pref^tok^" -> t_"^tok^"\n"
    else code^"    | "^token_pref^tok^" _ -> t_"^tok^"\n"
  in
  let code_get_token_name =
    List.fold_left aux code_get_token_name token_list
  in
  let code_str_token =
    "  let str_token t = match t with\n"
  in
  let aux code (tok,typ) =
    if typ = "No_type" then code^"    | "^token_pref^tok^" -> \""^tok^"\"\n"
    else if typ = "int"
    then code^"    | "^token_pref^tok^" i -> \""^tok^"(\"^(string_of_int i)^\")\"\n"
    else if typ = "string" then code^"    | "^token_pref^tok^" s -> \""^tok^"(\"^s^\")\"\n"
    else code^"    | "^token_pref^tok^" _ -> \""^tok^"\"\n"
  in
  let code_str_token =
    (List.fold_left aux code_str_token token_list)
  in
  let code_token_name_array, code_str_token_name =
    let rec aux res token_list = match token_list with
      | (tok,_)::t::l -> aux (res^"    \""^tok^"\";\n") (t::l)
      | [(tok,_)] -> res^"    \""^tok^"\""
      | _ -> assert false
    in
    let aux_dummy_tok str (nts,_) =
      (str^"    \"dummy_token_"^nts^"\";\n")
    in
    let dummy_tok_l =
      List.fold_left aux_dummy_tok "" non_terminal_start_list
    in
    "  let token_name_array =\n  [|\"token_epsilon\";\n"^dummy_tok_l^
    (aux "" token_list)^"|]\n",
    "  let str_token_name t = Dyp_symbols_array.token_name_array.(t)\n"
  in
  code_get_token_name, code_str_token, code_str_token_name,
  code_token_name_array



let code_ter_of_string, code_ter_string_list, code_String_ter_map =
  let code = "  let ter_string_list = [" in
  let aux str n cl = ");"::(string_of_int n)::("\n      (\""^str^"\",")::cl in
  let code_list = String_map.fold aux token_name_map [code] in
  let code_list = List.rev ("]\n"::code_list) in
  "  let ter_of_string =\n    List.fold_left (fun tsm (s,i) -> String_ter_map.add s i tsm)\n     String_ter_map.empty ter_string_list\n",
  String.concat "" code_list,
  "  module Ordered_string =
  struct
    type t = string
    let compare = Pervasives.compare
  end
  module String_ter_map = Map.Make(Ordered_string)\n"



let map_card m =
  String_map.fold (fun _ _ i-> i+1) m 0


let code_non_terminal_decl, non_terminal_map, non_terminal_set =
  let code_non_terminal_decl = "" in
  let non_terminal_set =
    let aux1 st_set ld = match ld with
      | (Obj_terminal _),_ -> st_set
      | (Obj_non_terminal (nt,_,_,_)),_ -> String_set.add nt st_set
    in
    let aux2 (st_set1,st_set2) (lhs_nt,_,ld_list,_,_) =
      (String_set.add lhs_nt st_set1),(List.fold_left aux1 st_set2 ld_list)
    in
    let nt_set_lhs,nt_set_rhs =
      List.fold_left aux2 (String_set.empty,String_set.empty) grammar
    in
    let foldfun entryp_set (ep,_) = String_set.add ep entryp_set in
    let entryp_set =
      List.fold_left foldfun String_set.empty non_terminal_start_list
    in
    let nt_not_in_lhs = String_set.union nt_set_rhs entryp_set in
    let nt_not_in_lhs = String_set.diff nt_not_in_lhs nt_set_lhs in
    let nt_not_in_rhs = String_set.diff nt_set_lhs nt_set_rhs in
    let nt_not_in_rhs = String_set.diff nt_not_in_rhs entryp_set in
    let f hs nt =
      print_endline ("File \""^input_file^"\":");
      print_endline ("Warning: non terminal `"^nt^"' is never in a "^hs)
    in
    String_set.iter (f "left-hand side.") nt_not_in_lhs;
    String_set.iter (f "right-hand side.") nt_not_in_rhs;
    let nt_set =
      String_set.union entryp_set
      (String_set.union nt_set_lhs nt_set_rhs)
    in
    let foldfun2 nt_set nt = String_set.add nt nt_set in
    let nt_set = List.fold_left foldfun2 nt_set single_nt_list in
    let foldfun4 nt_set nt = String_set.add nt nt_set in
    let foldfun3 nt_set (_,nt_list) =
      List.fold_left foldfun4 nt_set nt_list
    in
    List.fold_left foldfun3 nt_set cons_list
  in
  let aux nt_string (code1,n,nt_map) = (
    code1^"  let "^nt_string^" = "^(string_of_int n)^"\n",
    (n+1),String_map.add nt_string n nt_map)
  in
  let code_non_terminal_decl, non_terminal_number,
    non_terminal_map =
      String_set.fold aux non_terminal_set
      (code_non_terminal_decl,1,String_map.empty)
  in
  (*Printf.printf "cardinal non_terminal_set = %d\n"
    (String_set.cardinal non_terminal_set);
  Printf.printf "cardinal non_terminal_map = %d\n"
    (map_card non_terminal_map);*)
  code_non_terminal_decl,non_terminal_map,non_terminal_set

let nt_cons_map =
  
  let aux nt ntcm = String_map.add nt ("Obj_"^nt) ntcm in
  let ntcm = String_set.fold aux non_terminal_set String_map.empty in
  
  let aux2 cons ntcm nt = String_map.add nt cons ntcm in
  let aux ntcm (cons,ntl) =
    List.fold_left (aux2 cons) ntcm ntl
  in
  let m = List.fold_left aux ntcm cons_list in
  (*Printf.printf "cardinal nt_cons_map = %d\n" (map_card m);*)
  m

let code_merge_warning =
  if !Argument.merge_warning
  then "  let merge_warning = true\n"
  else "  let merge_warning = false\n"



let code_lexbuf_position = if !Argument.lexer = "ocamllex" then
  "  let lexbuf_position lexbuf = (lexbuf.Lexing.lex_start_p,lexbuf.Lexing.lex_curr_p)\n"
  else "  let lexbuf_position _ = (Lexing.dummy_pos,Lexing.dummy_pos)\n"



let code_nt_functions, code_str_non_ter =
  let aux (str,n) (nts,_) =
    (str^"    (Dyp_symbols."^nts^","^(string_of_int n)^");\n"),(n+1)
  in
  let nts_list,_ = List.fold_left aux ("",1) non_terminal_start_list in
  let string_length = String.length nts_list in
  let nts_list =  if nts_list="" then ""
    else String.sub nts_list 0 (string_length-1) in
  let ntna s code = code^"    \""^s^"\";\n" in
  let nt_ar = (String_set.fold ntna non_terminal_set "") in
  let string_length = String.length nt_ar in
  let nt_ar = String.sub nt_ar 0 (string_length-1) in
  "  let entry_points = [\n"^nts_list^"]\n"(*^
  "  let str_non_terminal nt =\n    try Dyp_symbols_array.non_ter_array.(nt)\n"^
  "    with Invalid_argument _ -> (\"new_nt_\"^(string_of_int nt))\n"*),
  "  let str_non_ter =\n  [|\"S'\";\n"^nt_ar^"|]\n"



(*let Dyp_parameters_signature =
  let aux_tok code (tok,_) = code^"val token_"^tok^" : int\n" in
  let token_id_type = List.fold_left aux_tok "" token_list in
  let aux_nt nt code = code^"val "^nt^" : int\n" in
  let non_ter_id_type = String_set.fold aux_nt non_terminal_set "" in
  "sig\n"^
  token_id_type^
  non_ter_id_type^
  "end"*)



let code_main_1 =
"module Dyp_runtime = Dyp.Make_dyp(Dyp_parameters)\n"^
"module Dyp_engine = Dyp_runtime.Parser_"^(!Argument.priority_enforcement)^"\n\n"



let code_priority_def,priority_set,code_priority_names =
  let code_priority_names =
    "  let priority_names = [|\n    \"default_priority\"" in
  let aux1 (str_set:String_set.t) rel = match rel with
    | Rel_list l -> List.fold_left (fun set p -> String_set.add p set) str_set l
    | Rel_single p1 -> String_set.add p1 str_set
  in
  let priority_set1 = List.fold_left aux1 String_set.empty relation in
  let aux1 st_set ld = match ld with
    | (Obj_terminal _),_ -> st_set
    | (Obj_non_terminal (_,(p,(line,col1,col2)),_,_)),_ -> if p="No_priority" then st_set
        else (if String_set.mem p priority_set1=false && p<>"default_priority" then (
          printf "File \"%s\", line %d, characters %d-%d:\n" input_file line col1 col2;
          printf "Warning: the priority `%s' is not declared\n" p);
        String_set.add p st_set)
  in
  let aux2 st_set (_,(p,(line,col1,col2)),ld_list,_,_) =
    let st_set = String_set.add p st_set in
    if String_set.mem p priority_set1=false && p<>"default_priority" then (
          printf "File \"%s\", line %d, characters %d-%d:\n" input_file line col1 col2;
          printf "Warning: the priority `%s' is not declared\n" p);
    List.fold_left aux1 st_set ld_list
  in
  let priority_set = List.fold_left aux2 priority_set1 grammar in
  let aux p (code,code_pn,n) =
      if p="default_priority" then (code,code_pn,n) else
      ((code^"  let priority_data, "^p^
      " = Dyp.insert_priority priority_data \""^p^"\"\n"),
      code_pn^";\n    \""^p^"\"",
      (n+1))
  in
  let code_priority_def,code_priority_names,_ =
    String_set.fold aux priority_set
      ("  let priority_data, default_priority =\n"^
      "    Dyp.insert_priority Dyp.empty_priority_data \"default_priority\"\n",
      code_priority_names,1)
  in
  code_priority_def,priority_set,code_priority_names^"|]\n"


let code_global_local_data =
"let global_data = ref ()
let local_data = ref ()
let global_data_equal = (==)
let local_data_equal = (==)\n\n"



let code_test_cons, code_cons_of_nt, cons_of_nt, cons_map, cons_array, code_str_cons =
  
  let aux1 _ cons s = String_set.add cons s in
  let s = String_map.fold aux1 nt_cons_map String_set.empty in
  
  let aux0 s cons = String_set.add cons s in
  let s = List.fold_left aux0 s add_cons_list in
  
  let buf = Buffer.create 10000 in
  let _ = buf $ "  let str_cons o = match o with\n" in
  let aux cons _ =
    buf $ "    | " $ obj_pref $ cons $ " _ -> \"" $ cons $"\"\n"
  in
  let _ = String_set.fold aux s buf in
  let _ = buf $
    "    | _ -> failwith \"str_cons, unexpected constructor\"\n" in
  let code_str_cons = Buffer.contents buf in
  
  let cons_array = Array.make (String_set.cardinal s) "" in
  let aux2 cons (codl,m,n) =
    cons_array.(n) <- cons;
    let code_fun =
      "  (fun x -> match x with "^obj_pref^cons^
      " _ -> true | _ -> false)" in
    (";\n"::code_fun::codl,
    String_map.add cons n m, n+1)
  in
  let code_tc = "let __dypgen_test_cons =  [|\n" in
  let code, cons_map, _ =
    String_set.fold aux2 s ([code_tc],String_map.empty,0)
  in
  
  let code = List.rev ("|]\n\n"::(List.tl code)) in
  let code_tc = String.concat "" code in
  
  let cons_of_nt =
    Array.make ((String_set.cardinal non_terminal_set)+1) 0
  in
  let aux3 nt cons (l,i) =
    let cons_i = String_map.find cons cons_map in
    cons_of_nt.(i) <- cons_i;
    (";\n"::(string_of_int cons_i)::"    "::l, (i+1))
  in
  let code_cont = "  let cons_of_nt =\n  [|0;\n" in
  (* first corresponds to S' (which has no constructor anyway). *)
  let code,_ = String_map.fold aux3 nt_cons_map ([code_cont],1) in
  let code = List.rev ("|]\n"::(List.tl code)) in
  let code_cont = String.concat "" code in
  code_tc, code_cont, cons_of_nt, cons_map, cons_array, code_str_cons



let code_datadyn =
  let code_datadyn =
    "  let datadyn = Dyp_runtime.Tools.init_datadyn [\n"
  in
  let aux1 nt_str (codl,nt) =
    let i = cons_of_nt.(nt) in
    ";\n"::("    \""^nt_str^"\","^(string_of_int i)^
    ",\""^cons_array.(i)^"\"")::codl,
    nt+1
  in
  let codl,_ = String_set.fold aux1 non_terminal_set ([code_datadyn],1) in
  let codl = "\n    ][\n"::(List.tl codl) in
  let aux2 cons _ codl = ";\n"::("    \""^cons^"\"")::codl in
  let codl = String_map.fold aux2 cons_map codl in
  let codl = List.rev ("]\n"::(List.tl codl)) in
  String.concat "" codl



(*let code_dypgen_toolbox_type =
"type ('obj,'data,'local_data) dypgen_toolbox = {
  mutable global_data : 'data;
  mutable local_data : 'local_data;
  mutable priority_data : Dyp.priority_data;
  mutable add_rules : (Dyp.rule * (
    ('obj,'data,'local_data) dypgen_toolbox -> 'obj list -> 'obj)) list;
  mutable remove_rules : Dyp.rule list;
  mutable will_shift : bool;
  mutable next_state : out_channel option;
  mutable next_grammar : out_channel option;
  symbol_start : unit -> int;
  symbol_start_pos : unit -> Lexing.position;
  symbol_end : unit -> int;
  symbol_end_pos : unit -> Lexing.position;
  rhs_start : int -> int;
  rhs_start_pos : int -> Lexing.position;
  rhs_end : int -> int;
  rhs_end_pos : int -> Lexing.position;
  add_nt : string -> string -> Dyp.non_ter;
  find_nt : string -> Dyp.non_ter * string;
  print_state : out_channel -> unit;
  print_grammar : out_channel -> unit;
}\n\n"*)



(*let code_transform_action =
"  open Dyp
  let rec transform_action a =
    Dyp.Dyp_special_types.Dypgen_action(fun av_list symbol_pos
    position_list data_arg datadyn local_data_arg prio_data debug_infos ->
      let __dypgen_datadyn = ref datadyn in
      let dyp = {
        global_data = data_arg;
        local_data = local_data_arg;
        priority_data = prio_data;
        add_rules = [];
        remove_rules = [];
        will_shift = true;
        next_state = None;
        next_grammar = None;
        symbol_start = (fun () -> (fst symbol_pos).Lexing.pos_cnum);
        symbol_start_pos = (fun () -> fst symbol_pos);
        symbol_end = (fun () -> (snd symbol_pos).Lexing.pos_cnum);
        symbol_end_pos = (fun () -> snd symbol_pos);
        rhs_start = (fun i -> (fst (List.nth position_list (i-1))).Lexing.pos_cnum);
        rhs_start_pos = (fun i -> fst (List.nth position_list (i-1)));
        rhs_end = (fun i -> (snd (List.nth position_list (i-1))).Lexing.pos_cnum);
        rhs_end_pos = (fun i -> snd (List.nth position_list (i-1)));
        add_nt = (fun nt cons -> Dyp_runtime.Tools.add_nt nt cons __dypgen_datadyn);
        find_nt = (fun (s:string) -> Dyp_runtime.Tools.find_nt s !__dypgen_datadyn);
      print_state =
        debug_infos.Dyp.Dyp_special_types.prt_state;
      print_grammar =
        debug_infos.Dyp.Dyp_special_types.prt_grammar
      }
      in
      let new_obj = a dyp av_list in
      let mapfun (r,ac) = (r,(transform_action ac)) in
      let add_rules_transformed = List.map mapfun dyp.add_rules in
      (new_obj,dyp.will_shift,dyp.global_data,!__dypgen_datadyn,
      dyp.local_data,add_rules_transformed,dyp.remove_rules,
      dyp.priority_data,dyp.next_state,dyp.next_grammar))\n"*)



let code_grammar =
  
  let aux (lhs_nt,(prio,_),ld_list,par_act_l,ocaml_code) =
    let aux2 code ld = match ld with
      | (Obj_terminal (ter,(line,col1,col2))),_ ->
          let _ = (try String_map.find ter token_map
            with Not_found -> (
              fprintf stderr "File \"%s\", line %d, characters %d-%d:\n" input_file line col1 col2;
              fprintf stderr "Token `%s' not declared\n" ter; exit 2))
          in
          code^"Dyp.Ter Dyp_symbols.t_"^ter^";"
      | (Obj_non_terminal (ntn,(p,_),eq,_)),_ ->
          let code_p =
            if p = "No_priority" then "Dyp.No_priority "
            else (match eq with
              | Pr_eq -> "Dyp.Eq_priority "
              | Pr_lesseq -> "Dyp.Lesseq_priority "
              | Pr_less -> "Dyp.Less_priority "
              | Pr_greater -> "Dyp.Greater_priority "
              | Pr_greatereq -> "Dyp.Greatereq_priority ")^"Dyp_priority_data."^p
          in
          code^"Dyp.Non_ter (Dyp_symbols."^ntn^","^code_p^");"
    in
    
    let code_literal_list = List.fold_left aux2 "" ld_list in
    
    let string_length = (String.length code_literal_list) in
    let code_literal_list =
      if string_length = 0 then code_literal_list
      else if code_literal_list="" then ""
        else String.sub code_literal_list 0 (string_length-1)
    in
    let code_rule = "(Dyp_symbols."^lhs_nt^",["^ code_literal_list^ "],Dyp_priority_data."^prio^")" in
    
    let code_var_list =
      let f (code,n) lit = match lit with
        | (Obj_terminal (ter,_)),patternl ->
            let typ = String_map.find ter token_map in
            if typ = "No_type" then
              code^" _"^(string_of_int n)^";", n+1
            else
              let pat,pat_typ,(lnum,offset) = List.hd patternl in
              code^"`Real_obj ("^obj_pref^"Obj_"^ter^" "^
              " ("^(sharp_line_number lnum)^
              (space_string offset)^
              (try "("^pat^":"^(String_map.find pat_typ token_map)^")"
              with Not_found -> pat)^
              insert_line_number^" as _"^(string_of_int n)^"));",
              n+1
        | (Obj_non_terminal (nt,_,_,res_nb)),patternl ->
            let rec aux res n patl = match patl with
              | [pat,nt,(lnum,offset)] ->
                  res^" ("^(sharp_line_number lnum)^
                  (space_string offset)^
                  (try "("^pat^":'dypgen__"^(String_map.find nt nt_cons_map)^")"
                  with Not_found -> pat)^
                  (*(try "("^pat^":"^
                    (try String_map.find lhs_nt nt_type_map
                    with Not_found ->
                      "'dypgen__"^(String_map.find nt nt_cons_map))^")"
                  with Not_found -> pat)^*)
                  insert_line_number^
                  " as _"^(string_of_int n)^")"
              | (pat,nt,(lnum,offset))::tl ->
                  aux (res^" ("^(sharp_line_number lnum)^
                  (space_string offset)^
                  (try "("^pat^":'dypgen__"^(String_map.find nt nt_cons_map)^")"
                  with Not_found -> pat)^
                  insert_line_number^
                  " as _"^(string_of_int n)^")"^
                  ",") (n+1) tl
              | _ -> failwith "code_var_list"
            in
            let str = aux "" n patternl in
            (*code^"`Real_obj ("^obj_pref^"Obj_"^nt^" ("^str^"));",*)
            code^"`Real_obj ("^obj_pref^(String_map.find nt nt_cons_map)^" ("^str^"));",
            (* The extra parentheses around str are necessary
              for non terminals generated by partial actions. *)
            (*code^"`Real_obj ("^obj_pref^
            (String_map.find nt nt_cons_map)^str^");",*)
            n+(List.length patternl)
      in
      let c,_ = List.fold_left f ("",1) ld_list in
      let s_length = (String.length c) in
      if s_length = 0 then c
      else String.sub c 0 (s_length-1)
    in

    let code_action =
      let (action,(header_act,trailer_act)),(lnum,offset) = ocaml_code in
      let typ =
        try
          String_map.find lhs_nt nt_type_map
        with Not_found -> "'dypgen__"^
          (String_map.find lhs_nt nt_cons_map)
      in
      String.concat ""
        ["Dyp_runtime.Tools.transform_action ";
        " (fun dyp __dypgen_av_list -> (match ";
        "(Dyp_aux_functions.transform_av_list ";
        "__dypgen_av_list) with [";
        code_var_list;"] -> ";obj_pref;
        (String_map.find lhs_nt nt_cons_map);" ";header_act;
        (sharp_line_number (lnum-1));"(\n";(space_string offset);
        "(";action;"):";typ;")";
        (* The extra parentheses around action are useful when the action
        is empty, it converts it to unit. *)
        insert_line_number;trailer_act;" | _ -> raise Dyp.Giveup))"]
    in
    
    String.concat "" ["(";code_rule;",";code_action;")"]
  in
  let list_code_rapf = List.map aux grammar in
  let rec aux res sl = match sl with
    | [s] -> "let __dypgen_ra_list =\n[\n"::s::res
    | s::t -> aux ("\n;\n"::s::res) t
    | [] -> failwith "empty grammar"
  in
  let list_code_rapf = aux ["]\n\n"] list_code_rapf in
  String.concat "" list_code_rapf

  (*let code_grammar =*)
    (*let rec aux sl = match sl with
      | [] -> ""
      | [s] -> s
      | s::t -> s^"\n;\n"^(aux t)
    in "let __dypgen_ra_list =\n[\n"^
    (aux list_code_rapf)^"]\n\n"*)
  (*in
  code_grammar^
  "let current_grammar,nt_nb,map_po,user_g = make_grammar rapf_list __dypgen_priority_data\n"*)



let code_transform_av_list =
  let aux t typ code =
    if typ="No_type" then
      code^"      | "^obj_pref^"Obj_"^t^" -> `Dummy_obj\n"
    else code
  in
  let code_match_dummy = String_map.fold aux token_map "" in
"  let transform_av_list l =
    let f o = match o with\n"^code_match_dummy^
  "      | x -> `Real_obj x
    in
    List.map f l\n"



let code_prio_data =
  (*let code_relation_data = "let __dypgen_priority_data = Dyp.empty_priority_data\n" in*)
  let aux code rel = match rel with
    | Rel_list l ->
        let code_rel_list = List.fold_left (fun c s -> c^s^";") "" l in
        let string_length = String.length code_rel_list in
        let code_rel_list = "["^
          (if code_rel_list="" then ""
           else (String.sub code_rel_list 0 (string_length-1)))
          ^"]" in
        code^"  let priority_data = Dyp.add_list_relations priority_data "
        ^code_rel_list^"\n"
    | Rel_single p -> code(*^"let __dypgen_priority_data = Dyp.insert_priority __dypgen_priority_data "^p^"\n"*)
  in
  (List.fold_left aux "" relation)




(*
module Pparam =
struct
  let default_priority = 0
  type token = Token_void
  type obj = Obj_void
  type token_name = int
  let dummy_token_name = token_dummy_to_marshal
  let token_epsilon = token_epsilon_to_marshal
  let compare_token_name t1 t2 = Pervasives.compare t1 t2
  let get_name t = 0
  let str_token t = ""
  let str_token_name t = ""
  type Dyp.non_ter = int
  let entry_points =
    let map_fun (nts,_) = String_map.find nts non_terminal_map in
    List.map map_fun non_terminal_start_list
  let compare_ntn nt1 nt2 = Pervasives.compare nt1 nt2
  let str_non_terminal nt = string_of_int nt
  type data = Data_void
  let compare_data = (=)
  let default_data = Data_void
  type datadyn = Datadyn_void
  let default_datadyn = Datadyn_void
  let default_obj = Obj_void
  let get_value t = Obj_void
  type automaton_kind = `LR1 | `LALR
  let automaton_kind = if automaton_is_`LR1 then `LR1 else `LALR
  let merge_warning = false
end

module Prio =
struct
  type priority = int
end

module Pparam_relation =
struct
  include Prio
  include Dyp.Priority_by_relation.Make(Prio)
  include Pparam
end

module Pparam_set =
struct
  include Prio
  include Dyp.Priority_by_set.Make(Prio)
  include Pparam
end

module P_relation = Dyp.Parser.Make(Pparam_relation)
module P_set = Dyp.Parser.Make(Pparam_set)

let cst c = (function i -> c)

module Calc_aut_relation =
struct
  open Pparam_relation
  open P_relation
  let rhs_lit obj_lit = match obj_lit with
    | Obj_terminal ter -> Dyp.Ter (String_map.find ter token_name_map)
    | Obj_non_terminal (ntn,p,eq) ->
        let prio_nt =
          if p = "No_priority" then No_priority
          else
            let prio = String_map.find p priority_map in
            if eq then Lesseq_priority prio else Less_priority prio
        in
        Dyp.Non_ter (String_map.find ntn non_terminal_map,prio_nt)
  let aux (nt,_,l,ac_desc) =
    let ac = match ac_desc with
      | Dynamic_action _ -> Dyp.Dyp_special_types.Dypgen_action(fun _ _ _ _ _ _ -> Obj_void,true,default_data,
          default_datadyn, [], [], Dyp.empty_priority_data)
      | _ -> Classic(fun _ _ _ _ _ -> Obj_void,true,default_data)
    in
    (((String_map.find nt non_terminal_map),List.map rhs_lit l),ac,cst 0)
  let rapf_list = if set = [] then List.map aux grammar else []

  let grammar_for_sa = if set = [] then add_grammar empty_grammar rapf_list else empty_grammar
  let marshaled_automaton = if set = [] then
    Marshal.to_string (create_saved_automaton grammar_for_sa) []
    else ""
end

module Calc_aut_set =
struct
  open Pparam_set
  open P_set
  let aux priority_set_map (x,pl) =
    if pl=["priority declaration"] then priority_set_map else
    let f s = String_map.find s priority_map in
    let ntn_p = change_ntp_list empty_ntp (List.map f pl) in
    String_map.add x ntn_p priority_set_map
  let priority_set_map = if set=[] then String_map.empty else
    List.fold_left aux String_map.empty set

  let rhs_lit obj_lit = match obj_lit with
    | Obj_terminal ter -> Dyp.Ter (String_map.find ter token_name_map)
    | Obj_non_terminal (ntn,p,eq) ->
        let prio_nt =
          if p = "No_priority" then No_priority
          else
            let prio = String_map.find p priority_set_map in
            if eq then failwith("equal with priority_by_set")
            else prio
        in
        Dyp.Non_ter (String_map.find ntn non_terminal_map,prio_nt)
  let aux (nt,_,l,ac_desc) =
    let ac = match ac_desc with
      | Dynamic_action _ -> Dyp.Dyp_special_types.Dypgen_action(fun _ _ _ _ _ _ -> Obj_void,true,default_data,
          default_datadyn, [], [], Dyp.empty_priority_data)
      | _ -> Classic(fun _ _ _ _ _ -> Obj_void,true,default_data)
    in
    (((String_map.find nt non_terminal_map),List.map rhs_lit l),ac,cst 0)
  let rapf_list = if set=[] then [] else List.map aux grammar

  let grammar_for_sa = if set = [] then empty_grammar else add_grammar empty_grammar rapf_list
  let marshaled_automaton = if set = [] then "" else
    Marshal.to_string (create_saved_automaton grammar_for_sa) []
end




let code_marshaled_automaton =
  let marshaled_automaton =
    if set = [] then Calc_aut_relation.marshaled_automaton
    else Calc_aut_set.marshaled_automaton
  in
  let marshaled_automaton = String.escaped marshaled_automaton in
  "let marshaled_automaton = \""^marshaled_automaton^"\"\n"
*)


let code_main_2 =
  let aux str (nts,_) = try
  str^"let "^nts^" f lexbuf =
  let automaton = Dyp_engine.update_parsing_device_data __dypgen_automaton !global_data
    !local_data in
  let pf = Dyp_engine.glrParse automaton Dyp_aux_functions.get_token_value
    Dyp_symbols.get_token_name Dyp_symbols.str_token
    Dyp_symbols."^nts^" __dypgen_data_equal __dypgen_test_cons Dyp_symbols_array.str_cons __dypgen_merge_array f lexbuf
    Dyp_aux_functions.lexbuf_position in
  let aux1 (o,p) = match o with
    | "^obj_pref^(String_map.find nts nt_cons_map)^" r -> (r,p)
    | _ -> failwith \"Wrong type for entry result\" in
  List.map aux1 pf\n\n" with Not_found -> failwith "code_main_2"
  in
(*"let saved_automaton = Marshal.from_string marshaled_automaton 0
let automaton = complete_automaton saved_automaton current_grammar default_data default_datadyn __dypgen_priority_data merge_map merge\n"^*)
"let __dypgen_automaton = Dyp_engine.create_parsing_device __dypgen_ra_list Dyp_priority_data.priority_data "^
!Argument.aut_kind^" !global_data !local_data Dyp_aux_functions.datadyn Dyp_symbols_array.str_non_ter Dyp_symbols_array.cons_of_nt\n\n"^
  "let __dypgen_data_equal = {\n"^
  "  Dyp_runtime.Tools.global_data_equal = global_data_equal;\n"^
  "  Dyp_runtime.Tools.local_data_equal = local_data_equal }\n\n"^
  (List.fold_left aux "" non_terminal_start_list)



let code_type_obj =
  (*if !Argument.pv_obj then "" else*)
  let code_obj =
    let aux nt code =
      if List.exists (fun (nts,_) -> nts=nt) non_terminal_start_list
      then code else code^"'"^nt^","
    in
    let type_param =(String_set.fold aux non_terminal_set "") in
    let string_length = String.length type_param in
    (if type_param="" then ""
      else "("^(String.sub type_param 0 (string_length-1))^")")^
    " obj"
  in
  let aux1 tok typ code = if typ = "No_type" then code^"  | "^obj_pref^"Obj_"^tok^"\n"
    else code^"  | "^obj_pref^"Obj_"^tok^" of ("^typ^")\n"
  in
  let aux2 nt (code,conss) =
    let cons = String_map.find nt nt_cons_map in
    if String_set.mem cons conss then (code,conss) else
    let code =
      try
        let (_,start_type) =
          List.find (fun (nts,_) -> nts=nt) non_terminal_start_list
        in code^"  | "^obj_pref^cons^" of ("^start_type^")\n"
      with Not_found -> code^"  | "^obj_pref^cons^" of '"^nt^"\n"
    in
    code, (String_set.add cons conss)
  in
  let code,_ = (String_set.fold aux2 non_terminal_set ("",String_set.empty)) in
  "type "^
  code_obj^
  " ="^
  (if !Argument.pv_obj then " [\n" else "\n")^
  (String_map.fold aux1 token_map "")^code^
  (if !Argument.pv_obj then " ]\n\n" else "\n")



let code_merge_functions =
  let aux cons_s _ code = code^"let dyp_merge_"^cons_s^
  " = Dyp_runtime.Tools.keep_zero\n" in
  (String_map.fold aux cons_map "")^
  (*"let keep_all ol o = o::ol\n"^
  "let Dyp.keep_oldest ol _ =
  let rec aux l = match l with [] -> [] | [c] -> [c] | _::t -> aux t in
  aux ol\n"^
  "let keep_newest _ o = [o]\n"^*)
  "let dyp_merge = Dyp.keep_one\n"

let code_merge_array =
  let aux4 gmf gmm nt = String_map.add nt gmf gmm in
  let aux3 gmm (gmf,nt_l) = List.fold_left (aux4 gmf) gmm nt_l in
  let gen_merge_map = List.fold_left aux3 String_map.empty generic_merge in
  let aux1 cons_s _ code = code^"let dyp_merge_"^cons_s^
    " l =\n"^
    try let gen_merge = String_map.find cons_s gen_merge_map in
      "  "^gen_merge^" l\n"
    with Not_found -> (
      "  match dyp_merge_"^cons_s^" l with\n"^
      "    | ([],_,_) -> dyp_merge l\n"^
      "    | res -> res\n")
  in
  let aux2 cons_s _ ma = ";\n"::("(fun l -> (
  let f1 (o,gd,ld) = match o with "^obj_pref^cons_s^" ob -> (ob,gd,ld)
    | _ -> failwith \"type error, bad obj in dyp_merge_"^cons_s^"\"
  in
  let l = List.map f1 l in
  let (ol,gd,ld) = dyp_merge_"^cons_s^" l in
  let f2 o = "^obj_pref^cons_s^" o in
  (List.map f2 ol, gd, ld)))")::ma
  in
  let merge_array_l = List.rev
    ("|]\n\n"::(List.tl (String_map.fold aux2 cons_map
     ["let __dypgen_merge_array = [|"])))
  in
  let code_merge_array = String.concat "" merge_array_l in
  
  (String_map.fold aux1 cons_map "")^"\n"^
  code_merge_array^"\n\n"



let code_get_token_value =
  let aux code (tok,typ) =
    let s = if typ = "No_type" then " -> "^obj_pref^"Obj_"^tok^"\n"
      else " x -> "^obj_pref^"Obj_"^tok^" x\n"
    in
    code^"    | "^token_pref^tok^s
  in
  "  let get_token_value t = match t with\n"^
  (List.fold_left aux "" token_list)





let parser_codl = [
  topheader_main;
  code_type_token;

  "module Dyp_symbols =\nstruct\n";
  code_non_terminal_decl;
  code_token_name_decl;
  code_get_token_name;
  code_str_token;
  code_ter_string_list;
  code_String_ter_map;
  code_ter_of_string;
  "end\n\n";

  code_type_obj;

  "module Dyp_symbols_array =\nstruct\n";
  code_str_non_ter;
  code_token_name_array;
  code_cons_of_nt;
  code_str_cons;
  "end\n\n";

  "module Dyp_parameters =\nstruct\n";
  code_token_nb;
  code_undef_nt;
  code_nt_functions;
  code_str_token_name;
  code_priority_names;
  code_merge_warning;
  "end\n\n";

  code_main_1;

  "module Dyp_aux_functions =\nstruct\n";
  code_datadyn;
  code_get_token_value;
  code_lexbuf_position;
  code_transform_av_list;
  "end\n\n";

  "module Dyp_priority_data =\nstruct\n";
  code_priority_def;
  code_prio_data;
  "end\n\n";

  code_global_local_data;
  code_merge_functions;

  header_main;

  code_grammar;
  code_merge_array;
  code_test_cons;
  (* if test_cons is defined before the header then it may
  cause an error like:
    This expression has type (('a, 'b, 'c) obj -> bool) array
    but is here used with type (('a, 'b, type_N) obj -> bool) array
    The type constructor type_N would escape its scope *)
  code_main_2;
  trailer_main]

let parser_code = String.concat "" parser_codl



let parser_code_mli =
  let entry_code =
    if !Argument.lexer = "ocamllex"
    then " : (Lexing.lexbuf -> token) -> Lexing.lexbuf -> "
    else if !Argument.lexer = "ulex"
    then " : (Ulexing.lexbuf -> token) -> Ulexing.lexbuf -> "
    else " : ('a -> token) -> 'a -> "
  in
  let aux str (nts,start_type) =
    str^"val "^nts^entry_code^"(("^start_type^") * Dyp.priority) list\n"
  in
  let aux2 p code = if p="default_priority" then code
    else code^"  val "^p^" : Dyp.priority\n"
  in
  topmli_code ^
  code_type_token^
  "module Dyp_priority_data :\nsig\n"^
  "  val priority_data : Dyp.priority_data\n"^
  "  val default_priority : Dyp.priority\n"^
  (String_set.fold aux2 priority_set "")^
  "end\n\n"^
  (List.fold_left aux "" non_terminal_start_list)^
  mli_code


let () = Insert_linenum.buffer := String.copy parser_code
let lexbuf = Lexing.from_string parser_code
let parser_code = Insert_linenum.insert_linenum lexbuf
(*let parser_code = parser_code^code_marshaled_automaton^code_main_2*)
(*let parser_code = parser_code^code_main_2*)

let () = Insert_linenum.buffer := String.copy parser_code_mli
let lexbuf = Lexing.from_string parser_code_mli
let parser_code_mli = Insert_linenum.insert_linenum lexbuf

let dest_file = open_out output_file
let dest_file_mli = open_out output_file_mli

let () = output_string dest_file parser_code
let () = output_string dest_file_mli parser_code_mli
let () = close_out dest_file
let () = close_out dest_file_mli

@h=tangler('dypgen/generators/dypgen/dypgen_lexer.mll')
@select(h)
{
open Dypgen_parser
open Lexing

let ($) = Buffer.add_string
let ocaml_code_buffer = Buffer.create 100000
(*let paren_count = ref 0*)
let in_string = ref false
let comment_count = ref 0
(*let dypgen_comment = ref 0*)
let look_for_type = ref false

let start_ocaml_type = ref dummy_pos
let start_ocaml_code = ref dummy_pos
let start_curlyb = ref []
let start_bracket = ref []
let start_pattern = ref dummy_pos
let start_dypgen_comment = ref []
let start_ocaml_comment = ref []
let start_string = ref dummy_pos

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
}

let newline = ('\010' | '\013' | "\013\010")
let blank = [' ' '\009' '\012']
let lowercase = ['a'-'z' '\223'-'\246' '\248'-'\255' '_']
let uppercase = ['A'-'Z' '\192'-'\214' '\216'-'\222']
let identchar = 
  ['A'-'Z' 'a'-'z' '_' '\192'-'\214' '\216'-'\246' '\248'-'\255' '\'' '0'-'9']

rule token = parse
  | newline
      { update_loc lexbuf None 1 false 0;
        token lexbuf
      }
  | blank +
      { token lexbuf }
  | "%token" { look_for_type:=true; KWD_TOKEN }
  | "%start" { look_for_type:=true; KWD_START }
  | "%relation" { look_for_type:=false; KWD_RELATION }
  | "%mlitop" { KWD_MLITOP }
  | "%mltop" { KWD_MLTOP }
  | "%mli" { KWD_MLI }
  | "%constructor" { KWD_CONSTRUCTOR }
  | "%for" { KWD_FOR }
  | "%non_terminal" { KWD_NON_TERMINAL }
  | "%type" { KWD_TYPE }
  | "%merge" blank { KWD_MERGE }
  | lowercase identchar *
      { let pos = lexeme_start_p lexbuf in
        let line = pos.pos_lnum in
        let col1 = pos.pos_cnum - pos.pos_bol in
        let col2 = lexbuf.lex_curr_p.pos_cnum - lexbuf.lex_curr_p.pos_bol in
        LIDENT((Lexing.lexeme lexbuf),(line,col1,col2)) }
  | uppercase identchar *
      { let pos = lexeme_start_p lexbuf in
        let line = pos.pos_lnum in
        let col1 = pos.pos_cnum - pos.pos_bol in
        let col2 = lexbuf.lex_curr_p.pos_cnum - lexbuf.lex_curr_p.pos_bol in
        UIDENT((Lexing.lexeme lexbuf),(line,col1,col2)) }
  | "("  { LPAREN }
  | ")"  { RPAREN }
  | "["
      { Buffer.clear ocaml_code_buffer;
        let pos = lexeme_start_p lexbuf in
        start_pattern := pos;
        (*paren_count:=1;*)
        ocaml_code lexbuf;
        PATTERN (Buffer.contents ocaml_code_buffer,
          (pos.pos_lnum,pos.pos_cnum-pos.pos_bol))
      }
  | ","  { COMMA }
  | ";"  { SEMI }
  | ":"  { COLON }
  | ">"  { GREATER }
  | "%%" { look_for_type:=false; PERCENTPERCENT }
  | "<"
      { if !look_for_type=false then LESS
        else
          (Buffer.clear ocaml_code_buffer;
          start_ocaml_type := lexeme_start_p lexbuf;
          ocaml_type lexbuf;
          OCAML_TYPE (Buffer.contents ocaml_code_buffer))
      }
  | "{"
      { Buffer.clear ocaml_code_buffer;
        let pos = lexeme_start_p lexbuf in
        start_ocaml_code := pos;
        ocaml_code lexbuf;
        OCAML_CODE (Buffer.contents ocaml_code_buffer,
          (pos.pos_lnum,pos.pos_cnum-pos.pos_bol))
      }
  | "/*"
       { (*dypgen_comment := !dypgen_comment+1;*)
         start_dypgen_comment := (lexeme_start_p lexbuf)::(!start_dypgen_comment);
         comment lexbuf; token lexbuf }
  | "|"  { BAR }
  | "="  { EQUAL }
  | eof { EOF }

and comment = parse
  | "/*" { (*dypgen_comment := !dypgen_comment+1;*)
           start_dypgen_comment := (lexeme_start_p lexbuf)::(!start_dypgen_comment);
           comment lexbuf }
  | "*/"
      { (*dypgen_comment := !dypgen_comment-1;*)
         start_dypgen_comment := List.tl (!start_dypgen_comment);
         if !start_dypgen_comment=[] then () else comment lexbuf }
  | newline
      { update_loc lexbuf None 1 false 0; comment lexbuf }
  | _ { comment lexbuf }

and ocaml_code = parse
  | "}" 
      { 
        if !in_string = false && !comment_count = 0 then
          begin
            match !start_curlyb with
              | [] ->
                if !start_ocaml_code=dummy_pos then (
                  ocaml_code_buffer $ "}";
                  ocaml_code lexbuf)
                else start_ocaml_code:=dummy_pos
              | _::tl ->
                  start_curlyb:=tl;
                  ocaml_code_buffer $ "}";
                  ocaml_code lexbuf

            (*if (!paren_count) = 0 then start_ocaml_code := dummy_pos
            else
              let _ = ocaml_code_buffer $
                (String.make 1 (Lexing.lexeme_char lexbuf 0)) in
              let _ = paren_count := ((!paren_count)-1) in
              ocaml_code lexbuf*)
          end
        else
          begin
            ocaml_code_buffer $ "}";
            ocaml_code lexbuf
          end
      }
  | "]" { if !in_string=false && !comment_count=0 then (
          match !start_bracket with
            | _::tl -> start_bracket := tl;
                ocaml_code_buffer $ "]";
                ocaml_code lexbuf
            | [] ->
                if !start_pattern=dummy_pos then (
                  ocaml_code_buffer $ "]";
                  ocaml_code lexbuf)
                else
                  start_pattern:=dummy_pos)
          else (
            ocaml_code_buffer $ "]";
            ocaml_code lexbuf) }
  | "[" { if !in_string=false && !comment_count=0 then
            start_bracket := (lexeme_start_p lexbuf)::(!start_bracket);
          ocaml_code_buffer $ "[";
          ocaml_code lexbuf }
  | "$"
      { (if !in_string then ocaml_code_buffer $ "$"
      else ocaml_code_buffer $ "_");
        ocaml_code lexbuf
      }
  | "\\\\"
      { ocaml_code_buffer $ "\\\\";
        ocaml_code lexbuf
      }
  | "\\\""
      { ocaml_code_buffer $ "\\\"";
        ocaml_code lexbuf
      }
  | "\""
      { 
        if !in_string then (in_string := false; start_string := dummy_pos)
        else (in_string := true; start_string := lexeme_start_p lexbuf);
        ocaml_code_buffer $ "\"";
        ocaml_code lexbuf
      }
  | "{"
      { ocaml_code_buffer $ "{";
        if !in_string = false && !comment_count = 0 then
          start_curlyb := (lexeme_start_p lexbuf)::!start_curlyb;
          (*paren_count := (!paren_count)+1;*)
        ocaml_code lexbuf
      }
  | "(*"
      { 
        if !in_string then () else (comment_count := !comment_count + 1;
          start_ocaml_comment :=
            (lexeme_start_p lexbuf)::(!start_ocaml_comment));
        ocaml_code_buffer $ "(*";
        ocaml_code lexbuf
      }
  | "*)"
      { 
        if !in_string then () else (comment_count := !comment_count - 1;
          start_ocaml_comment := List.tl (!start_ocaml_comment));
        ocaml_code_buffer $ "*)";
        ocaml_code lexbuf
      }
  | newline
      { update_loc lexbuf None 1 false 0;
        ocaml_code_buffer $
          (String.make 1 (Lexing.lexeme_char lexbuf 0));
        ocaml_code lexbuf
      }
  | _
      { ocaml_code_buffer $
          (String.make 1 (Lexing.lexeme_char lexbuf 0));
        ocaml_code lexbuf
      }

and ocaml_type = parse
  | "->"
      { ocaml_code_buffer $ "->";
        ocaml_type lexbuf
      }
  | ">" { start_ocaml_type := dummy_pos; () }
  | newline
      { update_loc lexbuf None 1 false 0;
        ocaml_code_buffer $
          (String.make 1 (Lexing.lexeme_char lexbuf 0));
        ocaml_type lexbuf
      }
  | _
      { ocaml_code_buffer $
          (String.make 1 (Lexing.lexeme_char lexbuf 0));
        ocaml_type lexbuf
      }

@h=tangler('dypgen/generators/dypgen/insert_linenum.mll')
@select(h)
{
open Lexing

let buffer = ref ""

let update_loc lexbuf file line absolute chars =
  let pos = lexbuf.lex_curr_p in
  let new_file = match file with
                 | None -> pos.pos_fname
                 | Some s -> s
  in
  lexbuf.lex_curr_p <- { pos with
    pos_fname = new_file;
    pos_lnum = if absolute then line else pos.pos_lnum + line;
    pos_bol = pos.pos_cnum - chars;
  }
}

let newline = ('\010' | '\013' | "\013\010")

rule insert_linenum = parse
  | newline
      { update_loc lexbuf None 1 false 0;
        (*buffer := ((!buffer)^(Lexing.lexeme lexbuf));*)
        insert_linenum lexbuf
      }
  | "# insert-line-number"
      {
        let pos = Lexing.lexeme_start_p lexbuf in
        let space = "                    " in
        let str = "# "^(string_of_int (pos.pos_lnum+1)) in
        let () = String.blit str 0 space 0 (String.length str) in
        let () = String.blit space 0 !buffer pos.pos_cnum 20 in
        (*buffer := ((!buffer)^"# "^(string_of_int (pos.pos_lnum+1)));*)
        insert_linenum lexbuf
      }

  | eof
      { let result = !buffer in
        buffer := "";
        result }
  | [^'#''\010''\013']+
      {
        (*buffer := ((!buffer)^(Lexing.lexeme lexbuf));*)
        insert_linenum lexbuf
      }
  | _
      {
        (*buffer := ((!buffer)^(Lexing.lexeme lexbuf));*)
        insert_linenum lexbuf
      }

