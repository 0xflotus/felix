@head(1,"Axiom Check")
Scan all exes, replace BEXE_axiom_check e with 
BEXE_assert (axiom e) for each axiom that matches
the argument e.

@h = tangler("src/flx_axiom.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2

val axiom_check:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  unit
 
@h = tangler("src/flx_axiom.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_generic
open Flx_maps
open Flx_exceptions
open Flx_use
open Flx_child

let verify syms bbdfns csr e =
  let xx = ref [] in
  iter
  ( fun (id, axsr, axiom_kind, bvs, (bpl,precond), x) ->
    match x with | `BEquation _ -> () | `BPredicate x ->
    (*
    print_endline ("Checking for cases of axiom " ^ id);
    *)
    let param = match bpl with
      | [] -> `BEXPR_tuple [],`BTYP_tuple []
      | [{pindex=i;ptyp=t}] -> `BEXPR_name (i,[]),t
      | ls -> 
        let xs = map (fun {pindex=i; ptyp=t}->`BEXPR_name (i,[]),t) ls in
        let ts = map snd xs in
        `BEXPR_tuple xs,`BTYP_tuple ts
    in
    let tvars = map (fun (_,i) -> i) bvs in
    let evars = map (fun {pindex=i} -> i) bpl in
    let result = expr_maybe_matches syms.dfns tvars evars param e in
    match result with
    | None -> ()
    | Some (tmgu, emgu) ->
      (*
      print_endline (sbe syms.dfns e ^  " MATCHES AXIOM " ^ id);
      *)
      let xsub x = fold_left (fun x (i,e) -> expr_term_subst x i e) x emgu in
      let tsub t = list_subst tmgu t in
      (*
      print_endline ("tmgu= " ^ catmap ", " (fun (i,t) -> si i ^ "->" ^ sbt syms.dfns t) tmgu);
      *)
      let ident x = x in 
      let rec aux x = map_tbexpr ident aux tsub x in
      let cond = aux (xsub x) in
      let precond = match precond with
      | Some x -> Some (aux (xsub x))
      | None -> None
      in
      let comment = `BEXE_comment (csr,"Check " ^ id) in
      let ax = `BEXE_assert2 (csr,axsr,precond,cond) in
      (*
      print_endline ("Assertion: " ^ tsbe syms.dfns cond);
      *)
      xx := ax :: comment :: !xx
  )
  syms.axioms
  ;
  !xx

let fixup_exes syms bbdfns bexes =
  let rec aux inx outx = match inx with
  | [] -> rev outx
  | `BEXE_axiom_check (sr,e) :: t -> 
    (*
    print_endline ("Axiom check case "  ^ sbe syms.dfns e);
    *)
    aux t ((verify syms bbdfns sr e) @ outx)
    
  | h :: t -> aux t (h::outx)
  in 
  aux bexes []

let axiom_check syms bbdfns =
  Hashtbl.iter
  (fun i (id,sr,parent,entry) ->
    match entry with
    | `BBDCL_function (ps,bvs,bpar,bty,bexes) ->
      let bexes = fixup_exes syms bbdfns bexes in
      let entry = `BBDCL_function (ps,bvs,bpar,bty,bexes) in
      Hashtbl.replace bbdfns i (id,sr,parent,entry)
      
    | `BBDCL_procedure (ps,bvs,bpar,bexes) ->
      let bexes = fixup_exes syms bbdfns bexes in
      let entry = `BBDCL_procedure (ps,bvs,bpar,bexes) in
      Hashtbl.replace bbdfns i (id,sr,parent,entry)
 
    | _ -> ()
  )
  bbdfns

