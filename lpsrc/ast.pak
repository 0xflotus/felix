@head(1,'ast')
@h=tangler('licences/ast_licence.txt','data')
@select(h)
The ast software
Copyright (c) 2002, Regents of the University of California
All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

    * Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.

    * Redistributions in binary form must reproduce the above 
      copyright notice, this list of conditions and the following 
      disclaimer in the documentation and/or other materials provided 
      with the distribution.

    * Neither the name of the University of California, Berkeley nor 
      the names of its contributors may be used to endorse or promote 
      products derived from this software without specific prior 
      written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

@h=tangler('elk/ast_ast.ast.h')
@select(h)
// ast.ast.h
// *** DO NOT EDIT ***
// generated automatically by astgen, from ast.ast

#ifndef AST_AST_H
#define AST_AST_H

#include "ast_asthelp.h"

// fwd decls
class ASTSpecFile;
class ToplevelForm;
class TF_verbatim;
class TF_impl_verbatim;
class TF_class;
class TF_option;
class TF_enum;
class ASTClass;
class AccessMod;
class Annotation;
class UserDecl;
class CustomCode;
class CtorArg;
class BaseClass;


// *** DO NOT EDIT ***

#include "sm_str.h"

  // this signals to ast.hand.cc that ast.ast.cc is nonempty,
  // so none of the bootstrap code in ast.hand.cc should be used
  #define GENERATED_AST_PRESENT

// *** DO NOT EDIT ***
class ASTSpecFile {
public:      // data
  ASTList <ToplevelForm > forms;

public:      // funcs
  ASTSpecFile(ASTList <ToplevelForm > *_forms) : forms(_forms) {
  }
  ~ASTSpecFile();

  char const *kindName() const { return "ASTSpecFile"; }

  ASTSpecFile *clone() const;

  void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

};



// *** DO NOT EDIT ***
class ToplevelForm {
public:      // data

public:      // funcs
  ToplevelForm() {
  }
  virtual ~ToplevelForm();

  enum Kind { TF_VERBATIM, TF_IMPL_VERBATIM, TF_CLASS, TF_OPTION, TF_ENUM, NUM_KINDS };
  virtual Kind kind() const = 0;

  static char const * const kindNames[NUM_KINDS];
  char const *kindName() const { return kindNames[kind()]; }

  DECL_AST_DOWNCASTS(TF_verbatim, TF_VERBATIM)
  DECL_AST_DOWNCASTS(TF_impl_verbatim, TF_IMPL_VERBATIM)
  DECL_AST_DOWNCASTS(TF_class, TF_CLASS)
  DECL_AST_DOWNCASTS(TF_option, TF_OPTION)
  DECL_AST_DOWNCASTS(TF_enum, TF_ENUM)

  virtual ToplevelForm *clone() const=0;

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

};

class TF_verbatim : public ToplevelForm {
public:      // data
  sm_string code;

public:      // funcs
  TF_verbatim(sm_string _code) : ToplevelForm(), code(_code) {
  }
  virtual ~TF_verbatim();

  virtual Kind kind() const { return TF_VERBATIM; }
  enum { TYPE_TAG = TF_VERBATIM };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual TF_verbatim *clone() const;

};

class TF_impl_verbatim : public ToplevelForm {
public:      // data
  sm_string code;

public:      // funcs
  TF_impl_verbatim(sm_string _code) : ToplevelForm(), code(_code) {
  }
  virtual ~TF_impl_verbatim();

  virtual Kind kind() const { return TF_IMPL_VERBATIM; }
  enum { TYPE_TAG = TF_IMPL_VERBATIM };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual TF_impl_verbatim *clone() const;

};

class TF_class : public ToplevelForm {
public:      // data
  ASTClass *super;
  ASTList <ASTClass > ctors;

public:      // funcs
  TF_class(ASTClass *_super, ASTList <ASTClass > *_ctors) : ToplevelForm(), super(_super), ctors(_ctors) {
  }
  virtual ~TF_class();

  virtual Kind kind() const { return TF_CLASS; }
  enum { TYPE_TAG = TF_CLASS };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual TF_class *clone() const;

  public:  bool hasChildren() const { return ctors.isNotEmpty(); };
};

class TF_option : public ToplevelForm {
public:      // data
  sm_string name;
  ASTList <sm_string > args;

public:      // funcs
  TF_option(sm_string _name, ASTList <sm_string > *_args) : ToplevelForm(), name(_name), args(_args) {
  }
  virtual ~TF_option();

  virtual Kind kind() const { return TF_OPTION; }
  enum { TYPE_TAG = TF_OPTION };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual TF_option *clone() const;

};

class TF_enum : public ToplevelForm {
public:      // data
  sm_string name;
  ASTList <sm_string > enumerators;

public:      // funcs
  TF_enum(sm_string _name, ASTList <sm_string > *_enumerators) : ToplevelForm(), name(_name), enumerators(_enumerators) {
  }
  virtual ~TF_enum();

  virtual Kind kind() const { return TF_ENUM; }
  enum { TYPE_TAG = TF_ENUM };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual TF_enum *clone() const;

};



// *** DO NOT EDIT ***
class ASTClass {
public:      // data
  sm_string name;
  ASTList <CtorArg > args;
  ASTList <BaseClass > bases;
  ASTList <Annotation > decls;

public:      // funcs
  ASTClass(sm_string _name, ASTList <CtorArg > *_args, ASTList <BaseClass > *_bases, ASTList <Annotation > *_decls) : name(_name), args(_args), bases(_bases), decls(_decls) {
  }
  ~ASTClass();

  char const *kindName() const { return "ASTClass"; }

  ASTClass *clone() const;

  void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  public:  sm_string classKindName() const;
};



// *** DO NOT EDIT ***

  // specifies what kind of userdecl this is; pub/priv/prot are uninterpreted
  // class members with the associated access control; ctor and dtor are
  // code to be inserted into the ctor or dtor, respectively
  enum AccessCtl {
    AC_PUBLIC,      // access
    AC_PRIVATE,     //   control
    AC_PROTECTED,   //     keywords
    AC_CTOR,        // insert into ctor
    AC_DTOR,        // insert into dtor
    AC_PUREVIRT,    // declare pure virtual in superclass, and impl in subclass
    NUM_ACCESSCTLS
  };

  // map the enum value to a sm_string like "public"
  sm_string toString(AccessCtl acc);      // defined in ast.cc

// *** DO NOT EDIT ***
class AccessMod {
public:      // data
  AccessCtl acc;
  ASTList <sm_string > mods;

public:      // funcs
  AccessMod(AccessCtl _acc, ASTList <sm_string > *_mods) : acc(_acc), mods(_mods) {
  }
  ~AccessMod();

  char const *kindName() const { return "AccessMod"; }

  AccessMod *clone() const;

  void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  public:  bool hasMod(char const *mod) const;
};



// *** DO NOT EDIT ***
class Annotation {
public:      // data

public:      // funcs
  Annotation() {
  }
  virtual ~Annotation();

  enum Kind { USERDECL, CUSTOMCODE, NUM_KINDS };
  virtual Kind kind() const = 0;

  static char const * const kindNames[NUM_KINDS];
  char const *kindName() const { return kindNames[kind()]; }

  DECL_AST_DOWNCASTS(UserDecl, USERDECL)
  DECL_AST_DOWNCASTS(CustomCode, CUSTOMCODE)

  virtual Annotation *clone() const=0;

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

};

class UserDecl : public Annotation {
public:      // data
  AccessMod *amod;
  sm_string code;
  sm_string init;

public:      // funcs
  UserDecl(AccessMod *_amod, sm_string _code, sm_string _init) : Annotation(), amod(_amod), code(_code), init(_init) {
  }
  virtual ~UserDecl();

  virtual Kind kind() const { return USERDECL; }
  enum { TYPE_TAG = USERDECL };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual UserDecl *clone() const;

  public:  AccessCtl access() const { return amod->acc; };
};

class CustomCode : public Annotation {
public:      // data
  sm_string qualifier;
  sm_string code;

public:      // funcs
  CustomCode(sm_string _qualifier, sm_string _code) : Annotation(), qualifier(_qualifier), code(_code) {
     used=false;
  }
  virtual ~CustomCode();

  virtual Kind kind() const { return CUSTOMCODE; }
  enum { TYPE_TAG = CUSTOMCODE };

  virtual void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

  virtual CustomCode *clone() const;

  public:  bool used;
};



// *** DO NOT EDIT ***
class CtorArg {
public:      // data
  bool isOwner;
  sm_string type;
  sm_string name;
  sm_string defaultValue;

public:      // funcs
  CtorArg(bool _isOwner, sm_string _type, sm_string _name, sm_string _defaultValue) : isOwner(_isOwner), type(_type), name(_name), defaultValue(_defaultValue) {
  }
  ~CtorArg();

  char const *kindName() const { return "CtorArg"; }

  CtorArg *clone() const;

  void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

};



// *** DO NOT EDIT ***
class BaseClass {
public:      // data
  AccessCtl access;
  sm_string name;

public:      // funcs
  BaseClass(AccessCtl _access, sm_string _name) : access(_access), name(_name) {
  }
  ~BaseClass();

  char const *kindName() const { return "BaseClass"; }

  BaseClass *clone() const;

  void debugPrint(ostream &os, int indent, char const *subtreeName = "tree") const;

};




#endif // AST_AST_H
@h=tangler('elk/ast_ast.hand.h')
@select(h)
// ast.hand.h            see license.txt for copyright and terms of use
// generated (by hand) from ast.ast

#ifndef BOOTSTRAP
  // in non-bootstrap mode, use the generated file
#include "ast_ast.ast.h"
#endif

#ifndef GENERATED_AST_PRESENT
// use the code below if either:
//   - BOOTSTRAP was defined
//   - ast.gen.h was empty

#ifndef AST_HAND_H
#define AST_HAND_H

#include "ast_asthelp.h"

// fwd decls
class ASTSpecFile;
class ToplevelForm;
class TF_verbatim;
class ASTClass;
class UserDecl;
class ASTCtor;
class CtorArg;


#include "sm_str.h"

class ASTSpecFile {
public:
  ASTList<ToplevelForm> forms;

public:
  ASTSpecFile(ASTList<ToplevelForm> *_forms) : forms(_forms) {}
  ~ASTSpecFile() {}

  void debugPrint(ostream &os, int indent) const;
};


class ToplevelForm {
public:
  ToplevelForm() {}
  virtual ~ToplevelForm() {}

  enum Kind { TF_VERBATIM, ASTCLASS, NUM_KINDS };
  virtual Kind kind() const = 0;

  DECL_AST_DOWNCASTS(TF_verbatim, TF_VERBATIM)
  DECL_AST_DOWNCASTS(ASTClass, ASTCLASS)

  virtual void debugPrint(ostream &os, int indent) const;
};

class TF_verbatim : public ToplevelForm {
public:
  sm_string code;

public:
  TF_verbatim(sm_string _code)
    : code(_code) 
  {}
  virtual ~TF_verbatim() {}

  virtual Kind kind() const { return TF_VERBATIM; }
  enum { TYPE_TAG = TF_VERBATIM };

  virtual void debugPrint(ostream &os, int indent) const;
};

class ASTClass : public ToplevelForm {
public:
  sm_string name;
  ASTList<CtorArg> superCtor;
  ASTList<UserDecl> decls;
  ASTList<ASTCtor> ctors;

public:
  ASTClass(sm_string _name, ASTList<CtorArg> *_superCtor,
           ASTList<UserDecl> *_decls, ASTList<ASTCtor> *_ctors) :
    name(_name), superCtor(_superCtor), decls(_decls), ctors(_ctors)
  {}
  ~ASTClass() {}

  virtual Kind kind() const { return ASTCLASS; }
  enum { TYPE_TAG = ASTCLASS };

  virtual void debugPrint(ostream &os, int indent) const;
  
  public: bool hasChildren() const { return ctors.isNotEmpty(); }
};


  enum AccessCtl { AC_PUBLIC, AC_PRIVATE, AC_PROTECTED };
  sm_string toString(AccessCtl acc);      // defined in ast.cc


class UserDecl {
public:
  AccessCtl access;
  sm_string code;

public:
  UserDecl(AccessCtl _access, sm_string _code)
    : access(_access), code(_code)
  {}
  ~UserDecl() {}

  void debugPrint(ostream &os, int indent) const;
};


class ASTCtor {
public:
  sm_string name;
  ASTList<CtorArg> args;
  ASTList<UserDecl> decls;

public:
  ASTCtor(sm_string _name, ASTList<CtorArg> *_args, ASTList<UserDecl> *_decls)
    : name(_name), args(_args), decls(_decls)
  {}
  ~ASTCtor() {}

  void debugPrint(ostream &os, int indent) const;
  
  public: sm_string kindName() const;
};


class CtorArg {
public:
  bool owner;
  sm_string type;
  sm_string name;

public:
  CtorArg(bool _owner, sm_string _type, sm_string _name)
    : owner(_owner),
      type(_type),
      name(_name)
  {}
  ~CtorArg() {}

  void debugPrint(ostream &os, int indent) const;
};

#endif // AST_HAND_H

#endif // !GENERATED_AST_PRESENT
@h=tangler('elk/ast_asthelp.h')
@select(h)
// asthelp.h            see license.txt for copyright and terms of use
// included by generated ast code

#ifndef ASTHELP_H
#define ASTHELP_H

#include "sm_astlist.h"
#include "ast_fakelist.h"
#include "sm_str.h"
#include "ast_locstr.h"

#include <iostream.h>    // ostream

// ----------------- downcasts --------------------
// the 'if' variants return NULL if the type isn't what's expected;
// the 'as' variants throw an exception in that case
#define DECL_AST_DOWNCASTS(type, tag)            \
  type const *if##type##C() const;               \
  type *if##type()                               \
    { return const_cast<type*>(if##type##C()); } \
  type const *as##type##C() const;               \
  type *as##type()                               \
    { return const_cast<type*>(as##type##C()); } \
  bool is##type() const                          \
    { return kind() == tag; }


#define DEFN_AST_DOWNCASTS(superclass, type, tag)\
  type const *superclass::if##type##C() const    \
  {                                              \
    if (kind() == tag) {                         \
      return (type const*)this;                  \
    }                                            \
    else {                                       \
      return NULL;                               \
    }                                            \
  }                                              \
                                                 \
  type const *superclass::as##type##C() const    \
  {                                              \
    xassert(kind() == tag);                      \
    return (type const*)this;                    \
  }


// ------------------- const typecase --------------------
#define ASTSWITCHC(supertype, nodeptr)           \
{                                                \
  supertype const *switch_nodeptr = (nodeptr);   \
  switch (switch_nodeptr->kind())

#define ASTCASEC(type, var)                           \
  case type::TYPE_TAG: {                              \
    type const *var = switch_nodeptr->as##type##C();

// the "1" versions mean "one argument", i.e. they
// do not bind a variable of the specified type
#define ASTCASEC1(type)                               \
  case type::TYPE_TAG: {

#define ASTNEXTC(type, var)                           \
    break;                                            \
  } /* end previous case */                           \
  case type::TYPE_TAG: {                              \
    type const *var = switch_nodeptr->as##type##C();

#define ASTNEXTC1(type)                               \
    break;                                            \
  } /* end previous case */                           \
  case type::TYPE_TAG: {

// end a case, and add an empty 'default' construct
#define ASTENDCASECD                                  \
    break;                                            \
  } /* end final case */                              \
  default: ;    /* silence warning */                 \
} /* end scope started before switch */

#define ASTDEFAULTC                                   \
    break;                                            \
  } /* end final case */                              \
  default: {

// end a case where an explicit default was present, or
// there is no need to add one (e.g. because it was exhaustive)
#define ASTENDCASEC                                   \
    break;                                            \
  } /* end final case */                              \
} /* end scope started before switch */


// ------------------- non-const typecase --------------------
#define ASTSWITCH(supertype, nodeptr)            \
{                                                \
  supertype *switch_nodeptr = (nodeptr);         \
  switch (switch_nodeptr->kind())

#define ASTCASE(type, var)                            \
  case type::TYPE_TAG: {                              \
    type *var = switch_nodeptr->as##type();

#define ASTCASE1(type)                                \
  case type::TYPE_TAG: {

#define ASTNEXT(type, var)                            \
    break;                                            \
  } /* end previous case */                           \
  case type::TYPE_TAG: {                              \
    type *var = switch_nodeptr->as##type();

#define ASTNEXT1(type)                                \
    break;                                            \
  } /* end previous case */                           \
  case type::TYPE_TAG: {

// end-of-switch behavior is same as in const case
#define ASTENDCASED ASTENDCASECD
#define ASTDEFAULT ASTDEFAULTC
#define ASTENDCASE ASTENDCASEC


// ------------------- debug print helpers -----------------
ostream &ind(ostream &os, int indent);

// I occasionally want to see addresses, so I just throw this
// switch and recompile..
#if 1
  // headers w/o addresses
  #define PRINT_HEADER(subtreeName, clsname)                 \
    ind(os, indent) << subtreeName << " = " #clsname ":\n";  \
    indent += 2   /* user ; */
#else
  // headers w/ addresses
  #define PRINT_HEADER(subtreeName, clsname)                                           \
    ind(os, indent) << subtreeName << " = " #clsname " (" << ((void*)this) << "):\n";  \
    indent += 2   /* user ; */
#endif


#define PRINT_STRING(var) \
  debugPrintStr(var, #var, os, indent)    /* user ; */

void debugPrintStr(sm_string const &s, char const *name,
                   ostream &os, int indent);


#define PRINT_LIST(T, list) \
  debugPrintList(list, #list, os, indent)     /* user ; */

template <class T>
void debugPrintList(ASTList<T> const &list, char const *name,
                    ostream &os, int indent)
{
  ind(os, indent) << name << ":\n";
  int ct=0;
  {
    FOREACH_ASTLIST(T, list, iter) {
      iter.data()->debugPrint(os, indent+2,
        sm_stringc << name << "[" << ct++ << "]");
    }
  }
}

// provide explicit specialization for sm_strings
void debugPrintList(ASTList<sm_string> const &list, char const *name,
                    ostream &os, int indent);
void debugPrintList(ASTList<LocString> const &list, char const *name,
                    ostream &os, int indent);


#define PRINT_FAKE_LIST(T, list) \
  debugPrintFakeList(list, #list, os, indent)     /* user ; */

template <class T>
void debugPrintFakeList(FakeList<T> const *list, char const *name,
                        ostream &os, int indent)
{
  ind(os, indent) << name << ":\n";
  int ct=0;
  {
    FAKELIST_FOREACH(T, list, iter) {
      iter->debugPrint(os, indent+2,
        sm_stringc << name << "[" << ct++ << "]");
    }
  }
}

// note that we never make FakeLists of sm_strings, since of course
// sm_strings do not have a 'next' pointer


#define PRINT_SUBTREE(tree)                     \
  if (tree) {                                   \
    (tree)->debugPrint(os, indent, #tree);      \
  }                                             \
  else {                                        \
    ind(os, indent) << #tree << " is null\n";   \
  } /* user ; (optional) */


#define PRINT_GENERIC(var) \
  ind(os, indent) << #var << " = " << ::toString(var) << "\n"   /* user ; */


#define PRINT_BOOL(var) \
  ind(os, indent) << #var << " = " << (var? "true" : "false") << "\n"   /* user ; */


// ------------------- xml print helpers -----------------
// dsw: given above in the debug print section.
//  ostream &ind(ostream &os, int indent);

#define XMLPRINT_HEADER(clsname)                            \
  ind(os, indent) << "<object type=\"" << #clsname "\">\n"; \
  indent += 2   /* user ; */                                \

#define XMLPRINT_FOOTER(clsname)                            \
  indent -= 2;                                              \
  ind(os, indent) << "</object>\n" /* user ; */ 

#define XMLPRINT_STRING(var)                                \
  xmlPrintStr(var, #var, os, indent) /* user ; */

void xmlPrintStr(sm_string const &s, char const *name,
                 ostream &os, int indent);


#define XMLPRINT_LIST(T, list)                              \
  xmlPrintList(list, #list, os, indent) /* user ; */

template <class T>
void xmlPrintList(ASTList<T> const &list, char const *name,
                  ostream &os, int indent)
{
  ind(os, indent) << "<member type=list name=\"" << name << "\">\n";
  {
    FOREACH_ASTLIST(T, list, iter) {
      iter.data()->xmlPrint(os, indent+2);
    }
  }
  ind(os, indent) << "</member>\n";
}

// provide explicit specialization for sm_strings
void xmlPrintList(ASTList<sm_string> const &list, char const *name,
                    ostream &os, int indent);
void xmlPrintList(ASTList<LocString> const &list, char const *name,
                    ostream &os, int indent);


#define XMLPRINT_FAKE_LIST(T, list) \
  xmlPrintFakeList(list, #list, os, indent)     /* user ; */

template <class T>
void xmlPrintFakeList(FakeList<T> const *list, char const *name,
                        ostream &os, int indent)
{
  ind(os, indent) << "<member type=fakelist name=\"" << name << "\">\n";
  {
    FAKELIST_FOREACH(T, list, iter) {
      iter->xmlPrint(os, indent+2);
    }
  }
  ind(os, indent) << "</member>\n";
}

// note that we never make FakeLists of sm_strings, since of course
// sm_strings do not have a 'next' pointer


#define XMLPRINT_SUBTREE(tree)                         \
  if (tree) {                                          \
    (tree)->xmlPrint(os, indent);                      \
  }                                                    \
  else {                                               \
    xassert(0); /* dsw:not sure what to do here yet */ \
    ind(os, indent) << #tree << " is null\n";          \
  } /* user ; (optional) */


// dsw: there's no way this can work in general
#define XMLPRINT_GENERIC(var)                                                         \
  ind(os, indent) << "<member type=generic name=\"" << #var << "\">\n";               \
  ind(os, indent+2) << "<object type=generic val=\"" << ::toString(var) << "\" />\n"; \
  ind(os, indent) << "</member>\n"   /* user ; */


#define XMLPRINT_BOOL(var)                                                                 \
  ind(os, indent) << "<member type=bool name=\"" << #var << "\">\n";                       \
  ind(os, indent+2) << "<object type=bool val=\"" << (var? "true" : "false") << "\" />\n"; \
  ind(os, indent) << "</member>\n"   /* user ; */


// ---------------------- deep-copy ------------------
// returns a new'd list because the AST node ctors want
// to accept an owner ptr to a list
template <class T>
ASTList<T> * /*owner*/ cloneASTList(ASTList<T> const &src)
{
  ASTList<T> *ret = new ASTList<T>;

  FOREACH_ASTLIST(T, src, iter) {
    ret->append(iter.data()->clone());
  }

  return ret;
}


// returns owner pointer to list of serfs.. using this isn't ideal
// because ASTList normally is owning, and probably deletes its
// elements in its destructor..
template <class T>
ASTList<T> * /*owner*/ shallowCloneASTList(ASTList<T> const &src)
{
  ASTList<T> *ret = new ASTList<T>;

  FOREACH_ASTLIST(T, src, iter) {
    // list backbone is const, but nodes' constness leaks away..
    ret->append(const_cast<T*>(iter.data()));
  }

  return ret;
}


// deep copy of a FakeList
template <class T>
FakeList<T> * /*owner*/ cloneFakeList(FakeList<T> const *src)
{
  if (!src) {
    return FakeList<T>::emptyList();     // base case of recursion
  }

  // clone first element
  T *head = src->firstC()->clone();
  xassert(head->next == NULL);     // it had better not copy the list tail itself!

  // attach to result of cloning the tail
  FakeList<T> *tail = cloneFakeList(src->butFirstC());
  return tail->prepend(head);
}


#endif // ASTHELP_H
@h=tangler('elk/ast_ccsstr.h')
@select(h)
// ccsstr.h            see license.txt for copyright and terms of use
// C++ substrate for my parser

#ifndef CCSSTR_H
#define CCSSTR_H

#include "ast_embedded.h"

class CCSubstrateTest;

class CCSubstrate : public EmbeddedLang {
private:
  enum State {
    ST_NORMAL,       // normal text
    ST_STRING,       // inside a sm_string literal
    ST_CHAR,         // inside a char literal
    ST_SLASH,        // from ST_NORMAL, just saw a slash
    ST_C_COMMENT,    // inside a C comment
    ST_CC_COMMENT,   // inside a C++ comment
    NUM_STATES
  } state;
  int nesting;       // depth of paren/bracket/brace nesting
  bool backslash;    // in ST_{STRING,CHAR}, just seen backslash?
  bool star;         // in ST_C_COMMENT, just seen '*'?

  // so test code can interrogate internal state
  friend class CCSubstrateTest;

public:
  CCSubstrate(ReportError *err = NULL);
  virtual ~CCSubstrate();

  // EmbeddedLang entry points (see gramlex.h for description
  // of each function)
  virtual void reset(int initNest = 0);
  virtual void handle(char const *str, int len, char finalDelim);
  virtual bool zeroNesting() const;
  virtual sm_string getFuncBody() const;
  virtual sm_string getDeclName() const;
};

#endif // CCSSTR_H
@h=tangler('elk/ast_embedded.h')
@select(h)
// embedded.h            see license.txt for copyright and terms of use
// interface to an embedded language processor

#ifndef EMBEDDED_H
#define EMBEDDED_H

#include "sm_str.h"
#include "ast_reporterr.h"

class EmbeddedLang {
public:
  // for reporting errors
  ReportError *err;

  // all text processed so far; it collects the
  // embedded code; clients will call 'handle' a
  // bunch of times and then expect to retrieve
  // the text from here
  sm_stringBuilder text;

  // when true (set by the lexer), the 'text' is to
  // be interpreted as an expression, rather than a
  // complete function body; this affects what
  // getFuncBody() returns
  bool exprOnly;

  // when true the text is a declaration, so we have to
  // add a single semicolon
  bool isDeclaration;

public:
  EmbeddedLang(ReportError *err = NULL /*print to stdout*/);
  virtual ~EmbeddedLang();    // silence warning

  // start from scratch
  virtual void reset(int initNest = 0) = 0;

  // process the given sm_string of characters, as source text in
  // the embedded language; 'finalDelim' is provided for printing
  // informative error messages
  virtual void handle(char const *str, int len, char finalDelim) = 0;

  // return true if we're at a nesting level of zero
  // and not in a sm_string, etc. -- characters at this
  // level have "usual" meaning
  virtual bool zeroNesting() const = 0;

  // return the body of the embedded function; should
  // always return a complete function body, even when
  // exprOnly is true (by adding to 'text' if necessary)
  virtual sm_string getFuncBody() const = 0;

  // return the name of the declared function, assuming
  // that is the context in which 'text' was collected
  virtual sm_string getDeclName() const = 0;
};

#endif // EMBEDDED_H
@h=tangler('elk/ast_fakelist.h')
@select(h)
// fakelist.h            see license.txt for copyright and terms of use
// headerless list of nodes where each node has a 'next' field

#ifndef FAKELIST_H
#define FAKELIST_H

// idea: define a templatized class such that a pointer to
// this class appears to present access to a list of the
// underlying T objects; but in fact, the pointer is actually
// a T pointer, and T contains a field called 'next' which
// inductively defines the list contents.  then such a pointer
// could be used to provide documentation of the presence of
// the list (and not just one node), and a uniform (with other
// list interfaces) syntactic interface, while hiding an
// efficient representation

// why not just insist that all objects be derived from some
// base class, e.g. FakeListNode, that defines 'next'?  because
// what is the type of 'next'?  it has to be FakeListNode*, but
// then either it must be physically first, or else 'next' is
// a pointer to the interior and I have to worry about whether
// the casts to/from the outer type will be correctly offset; and
// then getting to the next node requires a cast (the usual
// problem with subtyping polymorphism)

// for now, the list is non-owning (unless you call 'deallocNodes')

class Some_undefined_class;

template <class T>
class FakeList {
private:
  // you can't create or delete one of these
  FakeList();
  ~FakeList();

  // silence a silly egcs-1.1.2 warning (this function isn't defined)
  friend class Some_undefined_class;

  // this class has *no* data--an object of this type is
  // never actually created!  instead we play with pointers
  // to this "type", and cast to T* as necessary

public:
  // this is as much of a constructor as there is
  static FakeList<T> *makeList(T *node) { return (FakeList<T>*)node; }
  static FakeList<T> *emptyList()       { return NULL; }

  // this will deallocate all the nodes in the list; the list itself
  // is, therefore, also deallocated and should not be used after this
  void deallocNodes();

  // simple selectors
  int count() const;
  bool isEmpty() const                  { return this == NULL; }
  bool isNotEmpty() const               { return !isEmpty(); }

  // "car" in Lisp terminology
  T *first()                            { return (T*)this; }
  T const *firstC() const               { return (T const*)this; }

  // "cdr" in Lisp terminology
  FakeList<T> *butFirst()               { return makeList(first()->next); }
  FakeList<T> const *butFirstC() const  { return makeList(firstC()->next); }

  // similar to "cons" in Lisp terminology (but this doesn't allocate)
  FakeList<T> *prepend(T *newHead)
  {
    // I'm going to be surprised if this is ever not true.. it's
    // a potential problem in cc.gr, since I'm assuming there that
    // 'newHead' is not already on any other lists...
    //
    // update: This does occasionally get triggered, because a node
    // might get yielded to two contexts.  Failing this assertion is a
    // symptom that the sharing needs to be more carefully managed.
    // It's often the case that newHead->next in fact equals first()
    // already, but if the client code wants to let that slide it's
    // going to have to check itself; I don't want to silently allow
    // accidental happens-to-not-change-anything overwriting down in
    // this code.
    xassert(newHead->next == NULL);

    newHead->next = first();
    return makeList(newHead);
  }

  // random access (linear time of course)
  T const *nthC(int n) const;
  T *nth(int n) { return const_cast<T*>(nthC(n)); }

  // don't add an 'append' method; I think if you're trying to append
  // with FakeLists then you're probably misusing them

  // perhaps breaking the idea a little...
  FakeList<T> *reverse();

  // this class is deliberately sparse on methods for now, since I'm
  // not sure what kind of manipulations I'll want, given that this
  // class's purpose is fairly specialized (AST lists)
};



// I'm deliberately contradicting the convention elsewhere, where
// "FOREACH" comes first; I think it should have come second to begin
// with, and since this class isn't derived from any of the others
// with the opposite convention, this is as good a place as any to
// reverse it

#define FAKELIST_FOREACH(NodeType, listPtr, nodePtrVar)   \
  for (NodeType const *nodePtrVar = listPtr->firstC();    \
       nodePtrVar != NULL;                                \
       nodePtrVar = nodePtrVar->next)

#define FAKELIST_FOREACH_NC(NodeType, listPtr, nodePtrVar)   \
  for (NodeType *nodePtrVar = listPtr->first();              \
       nodePtrVar != NULL;                                   \
       nodePtrVar = nodePtrVar->next)


template <class T>
void FakeList<T>::deallocNodes()
{
  T *p = first();
  while (p) {
    T *next = p->next;

    // just in case T's destructor thinks it owns 'next',
    // nullify it since I'm going to dealloc it myself
    p->next = NULL;
    delete p;

    p = next;
  }
}


template <class T>
int FakeList<T>::count() const
{
  int ct = 0;
  FAKELIST_FOREACH(T, this, p) {
    ct++;
  }
  return ct;
}


template <class T>
T const *FakeList<T>::nthC(int n) const
{
  const FakeList<T> *p = this;
  while (n > 0) {
    p = p->butFirstC();  // segfaults if n is too small
    n--;
  }
  return p->firstC();
}


template <class T>
FakeList<T> *FakeList<T>::reverse()
{
  FakeList<T> *src = this;
  FakeList<T> *dest = emptyList();

  while (src->isNotEmpty()) {
    // remove first element of 'src'
    T *first = src->first();
    src = src->butFirst();
    first->next = NULL;

    // put it at the head of 'dest'
    dest = dest->prepend(first);
  }

  return dest;
}


#endif // FAKELIST_H
@h=tangler('elk/ast_gramlex.h')
@select(h)
// gramlex.h            see license.txt for copyright and terms of use
// GrammarLexer: a c++ lexer class for use with Flex's generated c++ scanner
// this lexer class is used both for parsing both AST and grammar descriptions;
// they differ in their .lex description, but their lexing state is the same

#ifndef __GRAMLEX_H
#define __GRAMLEX_H


// This included file is part of the Flex distribution.  It is
// installed in /usr/include on my Linux machine.  By including it, we
// get the declaration of the yyFlexLexer class.  Note that the file
// that flex generates, gramlex.yy.cc, also #includes this file.
// Perhaps also worth mentioning: I'm developing this with flex 2.5.4.
//
// update: This approach was too problematic.  I've taken to distributing
// FlexLexer.h myself.
#include "sm_flexlexer.h"

#include <iostream.h>         // istream

// token code definitions
#define TOK_EOF 0             // better name
#define TOK_INCLUDE 1         // not seen by parser


// other includes
#include "sm_str.h"
#include "sm_objlist.h"
#include "sm_srcloc.h"
#include "ast_embedded.h"
#include "ast_strtable.h"


// this class just holds the lexer state so it is properly encapsulated
// (and therefore, among other things, re-entrant)
class GrammarLexer : public yyFlexLexer, public ReportError {
public:      // types
  enum Constants {
    lexBufferSize = 4096,          // size of new lex buffers
  };

  // return true if the given token code is one of those representing
  // embedded text
  typedef bool (*isEmbedTok)(int tokCode);

  // error reporter that uses fileState instead of tokenStartLoc
  class AltReportError : public ReportError {
    GrammarLexer &lexer;

  public:
    AltReportError(GrammarLexer &L) : lexer(L) {}

    virtual void reportError(char const *msg);
    virtual void reportWarning(char const *msg);
  };
  friend class AltReportError;
  
public:      // data
  // exposed so a user-provided 'embedded' can use it
  AltReportError altReporter;

private:     // data
  // state of a file we were or are lexing
  struct FileState {
    SourceLoc loc;                 // location in the file
    istream *source;               // (owner?) source stream
    yy_buffer_state *bufstate;     // (owner?) flex's internal buffer state

  public:
    FileState(char const *filename, istream *source);
    ~FileState();

    FileState(FileState const &obj);
    FileState& operator= (FileState const &obj);
  };

  FileState fileState;             // state for file we're lexing now
  ObjList<FileState> fileStack;    // stack of files we will return to

  SourceLoc tokenStartLoc;         // location of start of current token

  // support for embedded code
  char embedStart;                 // if nonzero, punctuation that triggers
                                   // embedded processing
  char embedFinish;                // which character ends the embedded section
  int embedMode;                   // TOK_FUNDECL_BODY or TOK_FUN_BODY
  EmbeddedLang *embedded;          // (owner) the processor
  isEmbedTok embedTokTest;         // for printing diagnostics
  bool allowInit;                  // true if embedded can have an initializer

  int prevState;                   // so /**/ doesn't change start state
  
  int prevToken;                   // last token code yielded (ugly hack)

public:      // data
  // todo: can eliminate commentStartLine in favor of tokenStartLoc?
  //int commentStartLine;            // for reporting unterminated C comments
  int integerLiteral;              // to store number literal value
  StringRef sm_stringLiteral;         // sm_string in quotes, minus the quotes
  StringRef includeFileName;       // name in an #include directive

  // defined in the base class, FlexLexer:
  //   const char *YYText();           // start of matched text
  //   int YYLeng();                   // number of matched characters

  StringTable &strtable;           // sm_string table

  // count of errors encountered
  int errors;

private:     // funcs
  // disallowed
  GrammarLexer(GrammarLexer const &);

  // called to advance the column count
  void advCol(int n) 
    { fileState.loc = sourceLocManager->advCol(fileState.loc, n); }

  // called when a newline is encountered
  void newLine()
    { fileState.loc = sourceLocManager->advLine(fileState.loc); }
  
  // adds a sm_string with only the specified # of chars; writes (but
  // then restores) a null terminator if necessary, so 'str' isn't const
  StringRef addString(char *str, int len) const;
                                        
  // nominally true if 'ch' equals 'embedFinish', but with a niggle
  bool embedFinishMatches(char ch) const;

public:      // funcs
  // create a new lexer that will read from to named stream,
  // or stdin if it is NULL
  GrammarLexer(isEmbedTok embedTokTest,
               StringTable &strtable,
               char const *fname = "<stdin>",
               istream * /*owner*/ source = NULL,
               EmbeddedLang * /*owner*/ embedded = NULL /*i.e. assume C lexics*/);

  // clean up
  ~GrammarLexer();

  // get current token as a sm_string
  StringRef curToken() const;
  int curLen() const { return const_cast<GrammarLexer*>(this)->YYLeng(); }

  // current token's embedded text
  StringRef curFuncBody() const;
  StringRef curDeclBody() const { return curFuncBody(); }    // implementation artifact
  StringRef curDeclName() const;

  // read the next token and return its code; returns TOK_EOF for end of file;
  // this function is defined in flex's output source code; this one
  // *does* return TOK_INCLUDE
  virtual int yylex();

  // similar to yylex, but process TOK_INCLUDE internally
  int yylexInc();

  // begin an embedded sequence
  void beginEmbed(char finish, int mode, int initNest = 0)
  {
    embedded->reset(initNest);
    embedFinish = finish;
    embedMode = mode;
  }

  // info about location of current token
  char const *curFname() const 
    { return sourceLocManager->getFile(tokenStartLoc); }
  int curLine() const 
    { return sourceLocManager->getLine(tokenStartLoc); }
  int curCol() const 
    { return sourceLocManager->getCol(tokenStartLoc); }
  SourceLoc curLoc() const { return tokenStartLoc; }
  sm_string curLocStr() const;    // sm_string with file/line/col

  // error reporting; called by the lexer code
  void err(char const *msg) { reportError(msg); }     // msg should not include a newline
  void errorUnterminatedComment();
  void errorMalformedInclude();
  void errorIllegalCharacter(char ch);

  void printError(SourceLoc loc, char const *msg);
  void printWarning(SourceLoc loc, char const *msg);

  // for processing includes
  void recursivelyProcess(char const *fname, istream * /*owner*/ source);
  void popRecursiveFile();
  bool hasPendingFiles() const;
  
  // ReportError funcs
  virtual void reportError(char const *msg);
  virtual void reportWarning(char const *msg);
};


#endif // __GRAMLEX_H
@h=tangler('elk/ast_locstr.h')
@select(h)
// locstr.h            see license.txt for copyright and terms of use
// location & sm_string table reference

#ifndef LOCSTR_H
#define LOCSTR_H
                                          
#include <iostream.h>    // ostream
#include <string.h>      // strlen

#include "ast_strtable.h"
#include "sm_srcloc.h"

class LocString {
public:    // data
  SourceLoc loc;
  StringRef str;

public:    // funcs
  LocString();
  LocString(LocString const &obj);
  LocString(SourceLoc loc, StringRef str);

  LocString(Flatten&);
  void xfer(Flatten &flat);

  // deallocates its argument; intended for convenient use in bison grammar files
  EXPLICIT LocString(LocString *obj) { copyAndDel(obj); }
  void copyAndDel(LocString *obj);

  // sometimes useful for generating arguments to the above ctor
  LocString *clone() const;

  LocString& operator= (LocString const &obj)
    { loc = obj.loc; str = obj.str; return *this; }

  // sm_string with location info
  sm_string locString() const { return toString(loc); }

  // (read-only) sm_string-like behavior
  friend ostream& operator<< (ostream &os, LocString const &loc)
    { return os << loc.str; }
  friend sm_stringBuilder& operator<< (sm_stringBuilder &sb, LocString const &loc)
    { return sb << loc.str; }
  StringRef strref() const { return str; }
  operator StringRef () const { return str; }
  char operator [] (int index) const { return str[index]; }
  bool equals(char const *other) const;    // sm_string comparison
  int length() const { return strlen(str); }

  // experimenting with allowing 'str' to be null, which is convenient
  // when the sm_string table isn't available
  bool isNull() const { return str == NULL; }
  bool isNonNull() const { return !isNull(); }
  
  bool validLoc() const { return loc != SL_UNKNOWN; }
};

// yields simply the sm_string, no location info
sm_string toString(LocString const &s);


// useful for constructing literal sm_strings in source code
#define LITERAL_LOCSTRING(str)                                   \
  LocString(HERE_SOURCELOC, str)


#endif // LOCSTR_H
@h=tangler('elk/ast_reporterr.h')
@select(h)
// reporterr.h            see license.txt for copyright and terms of use
// interface for reporting errors and warnings

#ifndef REPORTERR_H
#define REPORTERR_H

class ReportError {
public:                                     
  // report an error; 'str' should not have a newline
  virtual void reportError(char const *str)=0;

  // report a warning
  virtual void reportWarning(char const *str)=0;
};


// print messages to stdout with "error: " or "warning: " prepended
class SimpleReportError : public ReportError {
public:
  virtual void reportError(char const *str);
  virtual void reportWarning(char const *str);
};

extern SimpleReportError simpleReportError;


// throw away messages
class SilentReportError : public ReportError {
public:
  virtual void reportError(char const *str);
  virtual void reportWarning(char const *str);
};

extern SilentReportError silentReportError;



#endif // REPORTERR_H
@h=tangler('elk/ast_strtable.h')
@select(h)
// strtable.h            see license.txt for copyright and terms of use
// implements a collection of immutable sm_strings with unique representatives

#ifndef STRTABLE_H
#define STRTABLE_H

#include "sm_strhash.h"

// fwd
class Flatten;

// global sm_string table for use during flattening/unflattening;
// it's up to clients to manage this ptr, as this module doesn't
// do anything besides define it into existence
// (this isn't the ideal solution..)
extern class StringTable *flattenStrTable;


// the type of references to sm_strings in a sm_string table; the pointer
// can be used directly in equality comparisons, because several calls
// to 'add' return the same pointer; and it points to the represented
// sm_string (null-terminated), so it can be printed directly, etc.
typedef char const *StringRef;


class StringTable {
private:    // types
  // constants
  enum {
    rackSize = 16000,      // size of one rack
    longThreshold = 1000,  // minimum length of a "long" sm_string
  };

  // some of the sm_strings stored in the table
  struct Rack {
    Rack *next;            // (owner) next rack, if any; for deallocation
    int usedBytes;         // # of bytes of 'data' that are used
    char data[rackSize];   // data where sm_strings are stored

  public:
    Rack(Rack *n) : next(n), usedBytes(0) {}
    int availBytes() const { return rackSize - usedBytes; }
    char *nextByte() { return data + usedBytes; }
  };

  // stores long sm_strings
  struct LongString {
    LongString *next;      // (owner) next long sm_string
    char *data;            // (owner) sm_string data, any length (null terminated)

  public:
    LongString(LongString *n, char *d) : next(n), data(d) {}
  };

private:    // data
  // hash table mapping sm_strings to pointers into one
  // of the sm_string racks
  StringHash hash;

  // linked list of racks; only walked at dealloc time; we add new
  // sm_strings to the first rack, and prepend a new one if necessary;
  // 'racks' is never null
  Rack *racks;

  // similar for long sm_strings
  LongString *longStrings;

private:    // funcs
  // not allowed
  StringTable(StringTable&);
  void operator=(StringTable&);
  void operator==(StringTable&);

  // for mapping data to keys, in the hashtable
  static char const *identity(void *data);

public:     // funcs
  StringTable();
  ~StringTable();
               
  // throw away everything in this table
  void clear();

  // add 'src' to the table, if it isn't already there; return a
  // unique representative, such that multiple calls to 'add' with
  // the same sm_string contents will always yield the same value
  StringRef add(char const *src);

  // some syntactic sugar
  StringRef operator() (char const *src) { return add(src); }

  // if 'src' is in the table, return its representative; if not,
  // return NULL
  StringRef get(char const *src) const;

  // similar functions for sm_strings with specified lengths
  // this doesn't work because the underlying hash table interface needs null terminators..
  //StringRef add(char const *src, int len);
  //StringRef get(char const *src, int len) const;

  // read/write binary
  void xfer(Flatten &flat, StringRef &ref);
};


#endif // STRTABLE_H

@h=tangler('elk/ast_ast.ast.cpp')
@select(h)
// ast.ast.cc
// *** DO NOT EDIT ***
// generated automatically by astgen, from ast.ast

#include "ast_ast.ast.h"


// ------------------ ASTSpecFile -------------------
// *** DO NOT EDIT ***
ASTSpecFile::~ASTSpecFile()
{
  forms.deleteAll();
}

void ASTSpecFile::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, ASTSpecFile);

  PRINT_LIST(ToplevelForm, forms);
}

ASTSpecFile *ASTSpecFile::clone() const
{
  ASTSpecFile *ret = new ASTSpecFile(
    cloneASTList(forms)
  );
  return ret;
}


// ------------------ ToplevelForm -------------------
// *** DO NOT EDIT ***
ToplevelForm::~ToplevelForm()
{
}

char const * const ToplevelForm::kindNames[ToplevelForm::NUM_KINDS] = {
  "TF_verbatim",
  "TF_impl_verbatim",
  "TF_class",
  "TF_option",
  "TF_enum",
};

void ToplevelForm::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_verbatim, TF_VERBATIM)

TF_verbatim::~TF_verbatim()
{
}

void TF_verbatim::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, TF_verbatim);

  ToplevelForm::debugPrint(os, indent, subtreeName);

  PRINT_STRING(code);
}

TF_verbatim *TF_verbatim::clone() const
{
  TF_verbatim *ret = new TF_verbatim(
    code
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_impl_verbatim, TF_IMPL_VERBATIM)

TF_impl_verbatim::~TF_impl_verbatim()
{
}

void TF_impl_verbatim::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, TF_impl_verbatim);

  ToplevelForm::debugPrint(os, indent, subtreeName);

  PRINT_STRING(code);
}

TF_impl_verbatim *TF_impl_verbatim::clone() const
{
  TF_impl_verbatim *ret = new TF_impl_verbatim(
    code
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_class, TF_CLASS)

TF_class::~TF_class()
{
  delete super;
  ctors.deleteAll();
}

void TF_class::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, TF_class);

  ToplevelForm::debugPrint(os, indent, subtreeName);

  PRINT_SUBTREE(super);
  PRINT_LIST(ASTClass, ctors);
}

TF_class *TF_class::clone() const
{
  TF_class *ret = new TF_class(
    super? super->clone() : NULL,
    cloneASTList(ctors)
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_option, TF_OPTION)

TF_option::~TF_option()
{
  while (args.isNotEmpty()) {
    args.removeFirst();
  }
}

void TF_option::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, TF_option);

  ToplevelForm::debugPrint(os, indent, subtreeName);

  PRINT_STRING(name);
  PRINT_LIST(sm_string, args);
}

TF_option *TF_option::clone() const
{
  TF_option *ret = new TF_option(
    name,
    shallowCloneASTList(args)
  );
  return ret;
}

DEFN_AST_DOWNCASTS(ToplevelForm, TF_enum, TF_ENUM)

TF_enum::~TF_enum()
{
  while (enumerators.isNotEmpty()) {
    enumerators.removeFirst();
  }
}

void TF_enum::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, TF_enum);

  ToplevelForm::debugPrint(os, indent, subtreeName);

  PRINT_STRING(name);
  PRINT_LIST(sm_string, enumerators);
}

TF_enum *TF_enum::clone() const
{
  TF_enum *ret = new TF_enum(
    name,
    shallowCloneASTList(enumerators)
  );
  return ret;
}


// ------------------ ASTClass -------------------
// *** DO NOT EDIT ***
ASTClass::~ASTClass()
{
  args.deleteAll();
  bases.deleteAll();
  decls.deleteAll();
}

void ASTClass::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, ASTClass);

  PRINT_STRING(name);
  PRINT_LIST(CtorArg, args);
  PRINT_LIST(BaseClass, bases);
  PRINT_LIST(Annotation, decls);
}

ASTClass *ASTClass::clone() const
{
  ASTClass *ret = new ASTClass(
    name,
    cloneASTList(args),
    cloneASTList(bases),
    cloneASTList(decls)
  );
  return ret;
}


// ------------------ AccessMod -------------------
// *** DO NOT EDIT ***
AccessMod::~AccessMod()
{
  while (mods.isNotEmpty()) {
    mods.removeFirst();
  }
}

void AccessMod::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, AccessMod);

  PRINT_GENERIC(acc);
  PRINT_LIST(sm_string, mods);
}

AccessMod *AccessMod::clone() const
{
  AccessMod *ret = new AccessMod(
    acc,
    shallowCloneASTList(mods)
  );
  return ret;
}


// ------------------ Annotation -------------------
// *** DO NOT EDIT ***
Annotation::~Annotation()
{
}

char const * const Annotation::kindNames[Annotation::NUM_KINDS] = {
  "UserDecl",
  "CustomCode",
};

void Annotation::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
}

DEFN_AST_DOWNCASTS(Annotation, UserDecl, USERDECL)

UserDecl::~UserDecl()
{
  delete amod;
}

void UserDecl::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, UserDecl);

  Annotation::debugPrint(os, indent, subtreeName);

  PRINT_SUBTREE(amod);
  PRINT_STRING(code);
  PRINT_STRING(init);
}

UserDecl *UserDecl::clone() const
{
  UserDecl *ret = new UserDecl(
    amod? amod->clone() : NULL,
    code,
    init
  );
  return ret;
}

DEFN_AST_DOWNCASTS(Annotation, CustomCode, CUSTOMCODE)

CustomCode::~CustomCode()
{
}

void CustomCode::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, CustomCode);

  Annotation::debugPrint(os, indent, subtreeName);

  PRINT_STRING(qualifier);
  PRINT_STRING(code);
}

CustomCode *CustomCode::clone() const
{
  CustomCode *ret = new CustomCode(
    qualifier,
    code
  );
  return ret;
}


// ------------------ CtorArg -------------------
// *** DO NOT EDIT ***
CtorArg::~CtorArg()
{
}

void CtorArg::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, CtorArg);

  PRINT_BOOL(isOwner);
  PRINT_STRING(type);
  PRINT_STRING(name);
  PRINT_STRING(defaultValue);
}

CtorArg *CtorArg::clone() const
{
  CtorArg *ret = new CtorArg(
    isOwner,
    type,
    name,
    defaultValue
  );
  return ret;
}


// ------------------ BaseClass -------------------
// *** DO NOT EDIT ***
BaseClass::~BaseClass()
{
}

void BaseClass::debugPrint(ostream &os, int indent, char const *subtreeName) const
{
  PRINT_HEADER(subtreeName, BaseClass);

  PRINT_GENERIC(access);
  PRINT_STRING(name);
}

BaseClass *BaseClass::clone() const
{
  BaseClass *ret = new BaseClass(
    access,
    name
  );
  return ret;
}


// *** DO NOT EDIT ***


#include "sm_strutil.h"

sm_string toString(AccessCtl acc)
{
  char const *arr[] = {
    "public",
    "private",
    "protected",
    "ctor",
    "dtor",
    "pure_virtual"
  };
  STATIC_ASSERT(TABLESIZE(arr) == NUM_ACCESSCTLS);
  xassert((unsigned)acc < NUM_ACCESSCTLS);
  return sm_string(arr[acc]);
}

sm_string ASTClass::classKindName() const
{
  sm_string ret = sm_stringToupper(name);
  if (ret == name) {
    // this simplemindedly avoids collisions with itself, and I think
    // it even avoids collisions with other classes, since if they would
    // collide with this, they'd collide with themselves too, and hence
    // get an extra "KIND_" prepended..
    ret &= "KIND_";
  }
  return ret;
}

bool AccessMod::hasMod(char const *mod) const
{
  FOREACH_ASTLIST(sm_string, mods, iter) {
    if (iter.data()->equals(mod)) {
      return true;
    }
  }
  return false;      // not found
}



@h=tangler('elk/ast_asthelp.cpp')
@select(h)
// asthelp.cc            see license.txt for copyright and terms of use
// code for what's declared in asthelp.h

#include "ast_asthelp.h"
#include "sm_strutil.h"

// ----------- debugPrint helpers -----------------------
ostream &ind(ostream &os, int indent)
{
  while (indent--) {
    os << " ";
  }
  return os;
}


void debugPrintStr(sm_string const &s, char const *name,
                   ostream &os, int indent)
{
  ind(os, indent) << name << " = " << quoted(s) << "\n";
}


template <class STR>
void debugPrintStringList(ASTList<STR> const &list, char const *name,
                          ostream &os, int indent)
{
  ind(os, indent) << name << ": ";
  {
    int ct=0;
    FOREACH_ASTLIST(STR, list, iter) {
      if (ct++ > 0) {
        os << ", ";
      }
      os << quoted(*( iter.data() ));
    }
  }
  os << "\n";
}


void debugPrintList(ASTList<sm_string> const &list, char const *name,
                    ostream &os, int indent)
{
  debugPrintStringList(list, name, os, indent);
}

void debugPrintList(ASTList<LocString> const &list, char const *name,
                    ostream &os, int indent)
{
  debugPrintStringList(list, name, os, indent);
}


// ----------- xmlPrint helpers -----------------------
void xmlPrintStr(sm_string const &s, char const *name,
                 ostream &os, int indent)
{
  ind(os, indent) << "<member type=sm_string name = \"" << name << "\">\n";
  // dsw: quoted might add another layer of quotes.
  ind(os, indent+2) << "<value type=sm_string val=\"" << quoted(s) << "\" />\n";
  ind(os, indent) << "</member>\n";
}


template <class STR>
void xmlPrintStringList(ASTList<STR> const &list, char const *name,
                        ostream &os, int indent)
{
  ind(os, indent) << "<member type=sm_stringList name = \"" << name << "\">\n";
  {
    FOREACH_ASTLIST(STR, list, iter) {
      // dsw: quoted might add another layer of quotes.
      ind(os, indent+2) << "<object type=sm_string val=\"" << quoted(*( iter.data() )) << "\" />\n";
    }
  }
  ind(os, indent) << "</member>\n";
}


void xmlPrintList(ASTList<sm_string> const &list, char const *name,
                  ostream &os, int indent)
{
  xmlPrintStringList(list, name, os, indent);
}

void xmlPrintList(ASTList<LocString> const &list, char const *name,
                  ostream &os, int indent)
{
  xmlPrintStringList(list, name, os, indent);
}
@h=tangler('elk/ast_ccsstr.cpp')
@select(h)
// ccsstr.cc            see license.txt for copyright and terms of use
// code for ccsstr.h

#include "ast_ccsstr.h"
#include "sm_xassert.h"
#include "sm_exc.h"
#include "sm_strutil.h"
#include "ast_reporterr.h"

#include <iostream.h>    // cout
#include <ctype.h>       // isspace


CCSubstrate::CCSubstrate(ReportError *err)
  : EmbeddedLang(err)
{
  reset();
}

void CCSubstrate::reset(int initNest)
{
  state = ST_NORMAL;
  nesting = initNest;
  backslash = false;
  star = false;
  text.setlength(0);
}


CCSubstrate::~CCSubstrate()
{}


void CCSubstrate::handle(char const *str, int len, char finalDelim)
{
  text.append(str, len);

  for (; len>0; len--,str++) {
    switch (state) {
      case ST_NORMAL:
        switch (*str) {
          case '{':
          case '(':
          case '[':
            nesting++;
            break;

          case '}':
          case ')':
          case ']':
            if (nesting == 0) {
              err->reportError(sm_stringc
                << "unexpected closing delimiter `" << *str
                << "' -- probably due to missing `" << finalDelim << "'");
            }
            else {
              nesting--;
            }
            break;

          case '\"':
            state = ST_STRING;
            break;

          case '\'':
            state = ST_CHAR;
            break;

          case '/':
            state = ST_SLASH;
            break;
        }
        break;

      case ST_STRING:
      case ST_CHAR:
        if (!backslash) {
          if ((state == ST_STRING && *str == '\"') ||
              (state == ST_CHAR && *str == '\'')) {
            state = ST_NORMAL;
          }
          else if (*str == '\\') {
            backslash = true;
          }
          else if (*str == '\n') {
            err->reportError("unterminated sm_string or char literal");
          }
        }
        else {
          backslash = false;
        }
        break;

      case ST_SLASH:
        if (*str == '*') {
          state = ST_C_COMMENT;
        }
        else if (*str == '/') {
          state = ST_CC_COMMENT;
        }
        else {
          state = ST_NORMAL;
        }
        break;

      case ST_C_COMMENT:
        if (!star) {
          if (*str == '*') {
            star = true;
          }
        }
        else {
          star = false;
          if (*str == '/') {
            state = ST_NORMAL;
          }
        }
        break;

      case ST_CC_COMMENT:
        // I don't like the possibility of escaped newlines
        // in C++ comments, so I don't support it (so there!)
        if (*str == '\n') {
          state = ST_NORMAL;
        }
        break;

      default:
        xfailure("unknown state");
    }
  }
}


bool CCSubstrate::zeroNesting() const
{
  return (state == ST_NORMAL || state == ST_SLASH) &&
         nesting == 0;
}


sm_string CCSubstrate::getFuncBody() const
{
  if (isDeclaration) {
    // I used to be appending ';' here, but now I need the flexibility to
    // add additional test before it, so I will rely on the caller to add
    // semicolons where necessary
    return text;
  }
  else if (exprOnly) {
    return sm_stringc << "return " << text << ";";
  }
  else {
    return text;
  }
}


sm_string CCSubstrate::getDeclName() const
{
  // go with the rather inelegant heuristic that the word
  // just before the first '(' is the function's name
  char const *start = text.pcharc();
  char const *p = start;
  
  // find first '('
  while (*p && *p!='(') { p++; }
  if (!*p) {
    xformat("missing '('");
  }             
  if (p == start) {
    xformat("missing name");
  }

  // skip backward past any whitespace before the '('
  p--;
  while (p>=start && isspace(*p)) { p--; }
  if (p<start) {
    xformat("missing name");
  }
  char const *nameEnd = p+1;    // char just past last
  
  // move backward through the name
  while (p>=start && 
         (isalnum(*p) || *p=='_'))
    { p--; }
  p++;    // move back to most recent legal char
  
  // done
  return sm_string(p, nameEnd-p);
}


// ------------------ test code -------------------
#ifdef TEST_CCSSTR

#define CC CCSubstrate
#define Test CCSubstrateTest

// test code is put into a class just so that CCSubstrate
// can grant it access to private fields
class Test {
public:
  void feed(CC &cc, char const *src);
  void test(char const *src, CC::State state, int nesting, bool flag);
  void normal(char const *src, int nesting);
  void str(char const *src, int nesting, bool bs);
  void yes(char const *src);
  void no(char const *src);
  void name(char const *body, char const *n);
  void badname(char const *body);
  int main();
};


#define min(a,b) ((a)<(b)?(a):(b))

void Test::feed(CC &cc, char const *src)
{
  //cout << "trying: " << src << endl;
  while (*src) {
    // feed it in 10 char increments, to test split processing too
    int len = min(strlen(src), 10);
    cc.handle(src, len, '}');
    src += len;
  }
}


void Test::test(char const *src, CC::State state, int nesting, bool flag)
{
  CC cc(&silentReportError);
  feed(cc, src);

  if (!( cc.state == state &&
         cc.nesting == nesting &&
         (state==CC::ST_C_COMMENT? cc.star==flag :
                                   cc.backslash==flag) )) {
    xfailure(sm_stringc << "failed on src: " << src);
  }
}


void Test::normal(char const *src, int nesting)
{
  test(src, CC::ST_NORMAL, nesting, false);
}

void Test::str(char const *src, int nesting, bool bs)
{
  test(src, CC::ST_STRING, nesting, bs);

  // repeat the test with single-tick
  sm_string another = replace(src, "\"", "\'");
  test(another, CC::ST_CHAR, nesting, bs);
}


void Test::yes(char const *src)
{
  CC cc(&silentReportError);
  feed(cc, src);

  xassert(cc.zeroNesting());
}

void Test::no(char const *src)
{
  CC cc(&silentReportError);
  feed(cc, src);

  xassert(!cc.zeroNesting());
}

void Test::name(char const *body, char const *n)
{
  CC cc(&silentReportError);
  feed(cc, body);
  xassert(cc.getDeclName().equals(n));
}

void Test::badname(char const *body)
{
  CC cc(&silentReportError);
  feed(cc, body);
  try {
    cc.getDeclName();
    xfailure("got a name when it shoudn't have!");
  }
  catch (...)
    {}
}


int Test::main()
{
  // quiet!
  xBase::logExceptions = false;

  normal("int main()", 0);
  normal("int main() { hi", 1);
  normal("int main() { hi {", 2);
  normal("int main() { hi { foo[5", 3);
  normal("int main() { hi { foo[5] and ", 2);
  normal("int main() { hi { foo[5] and } bar ", 1);
  normal("int main() { hi { foo[5] and } bar } baz ", 0);

  normal("main() { printf(\"hello \\ world\"); ret", 1);

  normal("()[]{}([{}])", 0);
  normal("{ ()[]{}([{}]) } ", 0);
  normal("( ()[]{}([{}]) )", 0);
  normal("[ ()[]{}([{}]) ]", 0);
  normal("\"foo\" ()[]{}([{}])", 0);

  str("main() { printf(\"hello", 2, false);
  str("main() { printf(\"hello \\", 2, true);
  str("main() { printf(\"hello \\ world", 2, false);
  str("main() { printf(\"hello \\ world\", \"hi", 2, false);

  test("\"a\" 'b' (", CC::ST_NORMAL, 1, false);

  yes("main() {}");
  yes("main() { printf(\"foo\", 3, 4 /*yep{*/); }");
  yes("some // junk {\n more");
  yes("'\\''");
  yes("\"\\\"\"");
  yes("[][][][][]");
  yes("\"[[[\"");
  yes("*");
  yes("/* [ /* [ */");

  no("\"");
  no("(");
  no(" ( /* ) */ ");

  name("int main()", "main");
  name("int eval(Environment &env)", "eval");
  name("man()", "man");
  badname("(");
  badname("  (");
  badname("  ");
  badname("");
  badname(")");
  badname("main");

  cout << "\nccsstr: all tests PASSED\n";

  return 0;
}

int main()
{
  Test t;
  return t.main();
}

#endif // TEST_CCSSTR
@h=tangler('elk/ast_embedded.cpp')
@select(h)
// embedded.cc            see license.txt for copyright and terms of use
// code for embedded.h

#include "ast_embedded.h"

EmbeddedLang::EmbeddedLang(ReportError *e)
  : err(e? e : &simpleReportError),
    text(),
    exprOnly(false),
    isDeclaration(false)
{}

EmbeddedLang::~EmbeddedLang()
{}
@h=tangler('elk/ast_gramlex.cpp')
@select(h)
// gramlex.cc            see license.txt for copyright and terms of use
// code for gramlex.h

#include "ast_gramlex.h"
#include "sm_trace.h"
#include "ast_ccsstr.h"
#include "sm_ckheap.h"

#include <fstream.h>     // cout, ifstream


// workaround for flex-2.5.31
#ifdef FLEX_STD    // detect later versions of flex
  // copied from flex's output
  #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
                            ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
                            : NULL)

  // the 'yy_current_buffer' field was replaced by the buffer stack
  // alluded to above
  #define yy_current_buffer YY_CURRENT_BUFFER
#endif // FLEX_STD


// ----------------- GrammarLexer::AltReportError ---------------
void GrammarLexer::AltReportError::reportError(char const *msg)
{
  lexer.printError(lexer.fileState.loc, msg);
}

void GrammarLexer::AltReportError::reportWarning(char const *msg)
{
  lexer.printWarning(lexer.fileState.loc, msg);
}


// ----------------- GrammarLexer::FileState --------------------
GrammarLexer::FileState::FileState(char const *filename, istream *src)
  : loc(sourceLocManager->encodeBegin(filename)),
    source(src),
    bufstate(NULL)
{}


GrammarLexer::FileState::~FileState()
{
  // we let ~GrammarLexer take care of deletions here since we
  // have to know what ~yyFlexLexer is going to do, and we
  // don't have enough context here to know that
}


GrammarLexer::FileState::FileState(FileState const &obj)
{
  *this = obj;
}


GrammarLexer::FileState &GrammarLexer::FileState::
  operator= (FileState const &obj)
{
  if (this != &obj) {
    loc = obj.loc;
    source = obj.source;
    bufstate = obj.bufstate;
  }
  return *this;
}


// ---------------------- GrammarLexer --------------------------
GrammarLexer::GrammarLexer(isEmbedTok test, StringTable &strtbl,
                           char const *fname, istream *source,
                           EmbeddedLang *userEmb)
  : yyFlexLexer(source),
    altReporter(*this),
    fileState(fname, source),
    fileStack(),
    tokenStartLoc(SL_UNKNOWN),
    embedStart(0),
    embedFinish(0),
    embedMode(0),
    embedded(userEmb? userEmb : new CCSubstrate(&altReporter)),
    embedTokTest(test),
    allowInit(false),
    prevState(0),       // same as INITIAL, but this value isn't used
    prevToken(0),       // hack..
    integerLiteral(0),
    sm_stringLiteral(""),
    includeFileName(""),
    strtable(strtbl),
    errors(0)
{
  trace("tmp") << "source is " << source << endl;

  // grab initial buffer object so we can restore it after
  // processing an include file (turns out this doesn't work
  // because it's NULL now; see recursivelyProcess())
  fileState.bufstate = yy_current_buffer;
}

GrammarLexer::~GrammarLexer()
{
  // ~yyFlexLexer deletes its current buffer, but not any
  // of the istream sources it's been passed

  // first let's unpop any unpopped input files
  while (hasPendingFiles()) {
    popRecursiveFile();
  }

  // now delete the original istream source
  // 
  // 10/09/04: This used to say "fileState.source != cin", but that
  // invokes cin.operator void*(), which always returns 0 or -1 in
  // gcc-2.95.3's library.  I believe I intended to compare addresses,
  // though at this point I'm not sure since I don't know where the
  // call sites to the constructor are.  (I found this problem because
  // at one point Elsa (erroneously) choked on this construction.)
  if (fileState.source &&
      fileState.source != &cin) {
    //checkHeap();
    //checkHeapNode(fileState.source);   // this is wrong b/c of virtual inheritance..
    delete fileState.source;
    //checkHeap();
  }

  delete embedded;
}


int GrammarLexer::yylexInc()
{
  // get raw token
  int code = yylex();
  
  // save this code for next time; part of what makes this hack
  // problematic is that this assignment is only performed if the
  // client calls 'yylexInc'..
  prevToken = code;

  // include processing
  if (code == TOK_INCLUDE) {
    sm_string fname = includeFileName;

    // 'in' will be deleted in ~GrammarLexer
    ifstream *in = new ifstream(fname);
    if (!*in) {
      err(sm_stringc << "unable to open include file `" << fname << "'");
    }
    else {
      recursivelyProcess(fname, in);
    }

    // go to next token (tail recursive)
    return yylexInc();
  }

  if (code == TOK_EOF  &&  hasPendingFiles()) {
    popRecursiveFile();
    return yylexInc();
  }

  #if 1
  // possible performance problem
  if (embedTokTest(code)) {
    trace("lex") << "yielding embedded (" << code << ") at "
                 << curLocStr() << ": "
                 << curFuncBody() << endl;
  }
  else {
    trace("lex") << "yielding token (" << code << ") "
                 << curToken() << " at "
                 << curLocStr() << endl;
  }
  #endif // 0/1

  // nothing special
  return code;
}


StringRef GrammarLexer::curToken() const
{
  return addString(yytext, yyleng);
}

StringRef GrammarLexer::addString(char *str, int len) const
{
  // write a null terminator temporarily
  char wasThere = str[len];
  if (wasThere) {
    str[len] = 0;
    StringRef ret = strtable.add(str);
    str[len] = wasThere;
    return ret;
  }
  else {
    return strtable.add(str);
  }
}


bool GrammarLexer::embedFinishMatches(char ch) const
{
  return ch == embedFinish ||
         (allowInit && ch=='=');     // to handle initial value syntax
}


StringRef GrammarLexer::curFuncBody() const
{
  return strtable.add(embedded->getFuncBody());
}


StringRef GrammarLexer::curDeclName() const
{
  return strtable.add(embedded->getDeclName());
}


sm_string GrammarLexer::curLocStr() const
{
  return toString(curLoc());
}


void GrammarLexer::reportError(char const *msg)
{
  printError(curLoc(), msg);
}

void GrammarLexer::printError(SourceLoc loc, char const *msg)
{
  errors++;
  cerr << toString(loc) << ": error: " << msg << endl;
}


void GrammarLexer::reportWarning(char const *msg)
{
  printWarning(curLoc(), msg);
}

void GrammarLexer::printWarning(SourceLoc loc, char const *msg)
{
  cerr << toString(loc) << ": warning: " << msg << endl;
}


void GrammarLexer::errorUnterminatedComment()
{
  err(sm_stringc << "unterminated comment, beginning on line " //<< commentStartLine);
              << sourceLocManager->getLine(tokenStartLoc));
}

void GrammarLexer::errorMalformedInclude()
{
  err(sm_stringc << "malformed include");
}

void GrammarLexer::errorIllegalCharacter(char ch)
{
  err(sm_stringc << "illegal character: `" << ch << "'");
}


void GrammarLexer::recursivelyProcess(char const *fname, istream *source)
{
  trace("lex") << "recursively processing " << fname << endl;
                       
  // grab current buffer; this is necessary because when we
  // tried to grab it in the ctor it was NULL
  fileState.bufstate = yy_current_buffer;
  xassert(fileState.bufstate);

  // push current state
  fileStack.prepend(new FileState(fileState));

  // reset current state
  fileState = FileState(fname, source);

  // storing this in 'bufstate' is redundant because of the
  // assignment above, but no big deal
  fileState.bufstate = yy_create_buffer(source, lexBufferSize);

  // switch underlying lexer over to new file
  yy_switch_to_buffer(fileState.bufstate);
}


void GrammarLexer::popRecursiveFile()
{
  trace("lex") << "done processing " <<     
    sourceLocManager->getFile(fileState.loc) << endl;

  // among other things, this prevents us from accidentally deleting
  // flex's first buffer (which it presumably takes care of) or
  // deleting 'cin'
  xassert(hasPendingFiles());

  // close down stuff associated with current file
  yy_delete_buffer(fileState.bufstate);
  delete fileState.source;

  // pop stack
  FileState *st = fileStack.removeAt(0);
  fileState = *st;
  delete st;
  
  // point flex at the new (old) buffer
  yy_switch_to_buffer(fileState.bufstate);
}


bool GrammarLexer::hasPendingFiles() const
{
  return fileStack.isNotEmpty();
}



#ifdef TEST_GRAMLEX

// defined in gramlex.lex
bool isGramlexEmbed(int code);

int main(int argc)
{
  SourceLocManager mgr;
  GrammarLexer lexer(isGramlexEmbed);
  traceAddSys("lex");

  cout << "go!\n";

  while (1) {
    // any argument disables include processing
    int code = argc==1? lexer.yylexInc() : lexer.yylex();
    if (code == 0) {  // eof
      break;
    }

    else if (isGramlexEmbed(code)) {
      cout << "embedded code at " << lexer.curLocStr()
           << ": " << lexer.curFuncBody()
           << endl;
    }
    
    else if (code == TOK_INCLUDE) {
      // if I use yylexInc above, this is never reached
      cout << "include at " << lexer.curLocStr()
           << ": filename is `" << lexer.includeFileName.pcharc()
           << "'\n";
    }
    
    else {
      cout << "token at " << lexer.curLocStr()
           << ": code=" << code
           << ", text: " << lexer.curToken().pcharc()
           << endl;
    }
  }

  return 0;
}

#endif // TEST_GRAMLEX
@h=tangler('elk/ast_locstr.cpp')
@select(h)
// locstr.cc            see license.txt for copyright and terms of use
// code for locstr.h

#include "ast_locstr.h"

LocString::LocString()
  : loc(SL_UNKNOWN),
    str(NULL)           // problem with "" is we don't have the sm_string table here..
{}

LocString::LocString(LocString const &obj)
  : loc(obj.loc),
    str(obj.str)
{}

LocString::LocString(SourceLoc L, StringRef s)
  : loc(L),
    str(s)
{}


LocString::LocString(Flatten&)
  : loc(SL_UNKNOWN), str(NULL)
{}

void LocString::xfer(Flatten &flat)
{
  // doh.. flattening locs is hard.  I wasn't even doing
  // it before.  issues:
  //   - don't want to store the file name lots of times
  //   - what if the file goes away, or we're in a different directory?
  //   - what if the file is changed, what loc to use then?
  // so for now I'm punting and not saving the loc at all...

  xassert(flattenStrTable);
  flattenStrTable->xfer(flat, str);
}


void LocString::copyAndDel(LocString *obj)
{
  loc = obj->loc;
  str = obj->str;
  delete obj;
}

LocString *LocString::clone() const
{
  return new LocString(*this);
}


bool LocString::equals(char const *other) const
{
  if (!str) {
    return !other;                            // equal if both null
  }
  else {
    return other && 0==strcmp(str, other);    // or same contents
  }
}

sm_string toString(LocString const &s)
{
  return sm_string(s.str);
}
@h=tangler('elk/ast_reporterr.cpp')
@select(h)
// reporterr.cc            see license.txt for copyright and terms of use
// code for reporterr.h

#include "ast_reporterr.h"

#include <iostream.h>       // cout


// --------------------- SimpleReportError -------------------------
void SimpleReportError::reportError(char const *str)
{
  cout << "error: " << str << endl;
}

void SimpleReportError::reportWarning(char const *str)
{
  cout << "warning: " << str << endl;
}

SimpleReportError simpleReportError;


// --------------------- SilentReportError -------------------------
void SilentReportError::reportError(char const *str)
{}

void SilentReportError::reportWarning(char const *str)
{}

SilentReportError silentReportError;


// EOF
@h=tangler('elk/ast_strtable.cpp')
@select(h)
// strtable.cc            see license.txt for copyright and terms of use
// code for strtable.h

#include "ast_strtable.h"
#include "sm_xassert.h"
#include "sm_flatten.h"

#include <string.h>      // strlen


StringTable *flattenStrTable = NULL;


STATICDEF char const *StringTable::identity(void *data)
{
  return (char const*)data;
}


StringTable::StringTable()
  : hash(identity),
    racks(NULL),
    longStrings(NULL)
{}


StringTable::~StringTable()
{
  clear();
}

void StringTable::clear()
{
  hash.empty();
  
  while (racks != NULL) {
    Rack *temp = racks;
    racks = racks->next;
    delete temp;
  }

  while (longStrings != NULL) {
    LongString *temp = longStrings;
    longStrings = longStrings->next;
    delete temp->data;
    delete temp;
  }
}


StringRef StringTable::add(char const *src)
{
  // see if it's already here
  StringRef ret = get(src);
  if (ret) {
    return ret;
  }

  int len = strlen(src)+1;     // include null terminator

  // is it a long sm_string?
  if (len >= longThreshold) {
    char *d = new char[len];
    ret = d;
    memcpy(d, src, len);

    // prepend a new long-sm_string entry
    longStrings = new LongString(longStrings, d);
  }

  else {
    // see if we need a new rack
    if (!racks || len > racks->availBytes()) {
      // need a new rack
      xassert(len <= rackSize);
      racks = new Rack(racks);     // prepend new rack
    }

    // add the sm_string to the last rack
    ret = racks->nextByte();
    memcpy(racks->nextByte(), src, len);
    racks->usedBytes += len;
  }

  // enter the intended location into the indexing structures
  hash.add(ret, (void*)ret);

  return ret;
}


StringRef StringTable::get(char const *src) const
{
  return (StringRef)hash.get(src);
}

                                        
// for now, just store each instance separately ...
void StringTable::xfer(Flatten &flat, StringRef &ref)
{
  if (flat.reading()) {
    // read the sm_string
    char *str;
    flat.xferCharString(str);

    if (str) {
      // add to table
      ref = add(str);

      // delete sm_string's storage
      delete str;
    }
    else {
      // was NULL
      ref = NULL;
    }
  }
  
  else {
    // copy it to disk
    // since we're writing, the cast is ok
    flat.xferCharString(const_cast<char*&>(ref));
  }
}
@h=tangler('elk/ast_towner.cpp')
@select(h)
// towner.cc            see license.txt for copyright and terms of use
// test owner stuff

#include "sm_owner.h"
#include <stdio.h>    // printf

class Foo;
void someCrap(Foo *f)
{
  //delete f;
  // good -- egcs-1.1.2 doesn't allow this, so I won't accidentally
  // get destructors missed because of forward decls (like could
  // happen with Borland)
}


// a simple class to play with
class Foo {
public:
  static int count;    // # of Foos there are
  int x;

public:
  Foo(int a);
  ~Foo();
};

int Foo::count = 0;

Foo::Foo(int ax)
  : x(ax)
{
  printf("created Foo at %p\n", this);
  count++;
}

Foo::~Foo()
{
  printf("destroying Foo at %p\n", this);
  count--;
}


void printFoo(Foo *f)
{
  printf("Foo at %p, x=%d\n", f, f? f->x : 0);
}

void printFooC(Foo const *f)
{
  printf("const Foo at %p, x=%d\n", f, f? f->x : 0);
}

void printInt(int x)
{
  printf("int x is %d\n", x);
}


// make it, forget to free it
void test1()
{
  printf("----------- test1 -----------\n");
  Owner<Foo> f;
  f = new Foo(4);
}

// access all of the operators as non-const
void test2()
{
  printf("----------- test2 -----------\n");
  Owner<Foo> f(new Foo(6));

  printFoo(f);
  (*f).x = 9;
  f->x = 12;
}

// access all of the operators as const
void test3()
{
  printf("----------- test3 -----------\n");
  Owner<Foo> f(new Foo(8));
  Owner<Foo> const &g = f;

  printFooC(g);
  printInt((*g).x);      // egcs-1.1.2 allows this for non-const operator fn!!!
  printInt(g->x);
}

// test exchange of ownership
void test4()
{
  printf("----------- test4 -----------\n");
  //Owner<Foo> f = new Foo(3);     // egcs-1.1.2 does the wrong thing here
  Owner<Foo> f(new Foo(3));
  Owner<Foo> g;
  g = f;
  printFoo(f);    // should be null
  f = g.xfr();
  printFoo(g);    // should be null
}


int main()
{
  test1();
  test2();
  test3();
  test4();
  
  printf("%d Foos leaked\n", Foo::count);
  return Foo::count;
}

