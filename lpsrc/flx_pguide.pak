@set_title("Felix Programmers Guide")
@head(1,"Audience")
This document is for programmers who need to understand
how to bind Felix to C/C++. It explains the data structures
and naming conventions used by Felix.

@head(1,"Architecture")
Felix targets shared libraries.
It generates a single C++ implementation file
and a corresponding header file.
@p()
The architectural design currently requires
a driver which dynamically loads the library
using dlopen() and links to symbols using dlsym.
@p()
Exported variables, functions, and procedures have
the link names given by the client using an
export statement.
@p()
Exported types have link names generated by Felix,
but Felix also generates a typedef using the
name given in the export statement.
@p()
Before a Felix library can be invoked,
three objects must be created: the global frame,
process frame, and thread frame.
@p()
The global frame typically contains constants,
but it may also be used for inter-process communication.
@p()
The process frame is currently unused, but it is intended
to contain data shared between threads.
@p()
The thread frame contains data local to a thread,
typically data to be shared between Felix coroutines.
@p()
A shared library is also a module whose initialisation method
must be called to initialise the module by executing its body.
@p()
When execution is complete, the thread frame, process frame,
and global frame must be destroyed.
Here is a synopsis of the relevant functions:
@begin_displayed_code()
#include "mymodule.hpp"
extern "C" global_frame_t *create_global_frame();
extern "C" void destroy_global_frame();
extern "C" process_frame_t *create_process_frame(
  global_frame_t *gf
);
extern "C" void destroy_process_frame(
  process_frame_t *pf
);
extern "C" thread_frame_t *create_thread_frame(
  global_frame_t *gf,
  process_frame_t *pf,
  flx::gc::generic::collector_t *gc
);
extern "C" void destroy_thread_frame(
  thread_frame_t *tf
);
extern "C" continuation_t *start(
  global_frame_t *gf,
  process_frame_t *pf,
  thread_frame_t *tf
);
@end_displayed_code()
The start method returns a pointer to a continuation
object.

@head(1,"Continuations")
Felix operates by procedural continuation passing.
This provides stackless, event driven operation.
The basic technique for executing a single
coroutine via continuations is:
@begin_displayed_code()
  while(p) p = p->resume();
@end_displayed_code()
where p is the pointer to the continuation the
start routine returned.
@p()
In an event driven context, a flag is set
indicating when an message is required:
@begin_displayed_code()
  while(p)
  {
    while(p && !p->action != wait_action) p = p->resume();
    *(message_t*)p->p_message) = next_message;
    p->action = yield_action;
  }
@end_displayed_code()

@head(1,"Cooperative multitasking")
The client driver may invoke other exported functions
and procedures in the library. Functions are ordinary
C functions and require no special handling: they use
the stack, and return with a result.
@p()
The exported version of a function always requires
pointers to the global frame, process frame, and
thread frame to be passed as the first three arguments.
The other arguments are the C types corresponding
to the Felix types of the funcion (see below).
@p()
Procedures, on the other hand, always return a pointer
to a continuation which must be resumed repeatedly
as described above.
@p()
Note that module constants and variables are accessed
by the global, process, and thread frames.
@p()
In a typical use, a single queue of messages is
filled by one or more OS threads from external
sources (such as TCP/IP sockets). Each message
contains some session identifier. The client
driver extracts the identifier and maps it to
a Felix coroutine which is waiting for the message,
or creates a new one if necessary. That coroutine
is passed the message and resumed. When it again
is blocked, the next message is read and sent to
a coroutine, not necessarily the same one.
Thus at most one coroutine is ever executing,
and the one which is is chosen by the client driver.

@head(1,"Garbage Collector")
The client must provide a garbage collector
meeting the Felix requirements: it must implement
the abstract class "flx::gc::generic::collector_t",
a pointer to which is stored in the thread frame.
@p()
Felix constructs collectable objects with a placement
form of operator new which invokes the collectors
allocator, and provides the collector with various
data including a map of the object indicating
where all the pointers are.
@p()
Felix does not actually call the collection function though.
Typically, the collector is called by the client
driver each time a coroutine
blocks, however, it is entirely up to the client.
It is also possible to call the collector from
Felix code using a library function.
@p()
Felix finalises objects by calling their C++ destructor.
Note that the order of finalisation is not guarranteed,
and that finalisation is performed on unreachable object
by the collector (and hence will not occur until the
collector is invoked).
@p()
The collector also supports reference counting
to permit synchronous finalisation and deletion
of partially ordered (acyclic) memory
however Felix doesn't currently
generate code utilising this feature.
@p()
Finally note that variables in Felix are organised
into frames, typically the variables in a procedure
are all in the same frame. The frames are actually
of continuation_t type, however there is an invisible
header block used by the collector. An object in a frame
will not be finalised until the frame is unreachable,
that is, until all the variables in the frame are
unreachable.

@head(1,"Pointers")
Felix supports pointers to variables. The implementation is a struct
consisting of two points: the first pointer "frame"
is to the frame containing the variable, and the second "data"
is to the actual variable. The garbage collector
uses the frame pointer to determine if one or more
objects in a frame is reachable.

@head(1,"Type Abstraction")
@head(2,"Primitives")
Felix allows binding of C/C++ types to Felix ones
inside Felix source code using binding statments,
for example:
@begin_displayed_code()
type Int = "int";
fun add: Int * Int -> Int = "$1 + $2";
@end_displayed_code()
Such types must be first class: default
initialisable, copyable, assignable and
destructible. A non-copyable object must
be refered to using a pointer or some kind
of handle (such as a smart pointer).
@p()
Note that the only way to access such primitive
types is via client supplied functions and procedures,
that is, the types are abstract on the Felix side
(though they're concrete on the C/C++ side).
@p()
Although primitive types must be assignable,
Felix assignments are modelled by calls to a set procedure,
in particular an assignment x = y is syntactic sugar
for set(&x, y).
You must define a set procedure of type &T * T
for assignments to work.

@head(2,"Structs and tuples")
A Felix struct is represented by a C++ struct with the
components in the same order, and using the same names.
@p()
A Felix tuple is similar, but the member names
are mem1, mem2, mem3 .. etc.
@p()
Both n-ary structs and tuples have an n-ary constructor.
In addition, if the struct is exported, a C function
wrapping the constructor is provided.
@p()
For each Felix struct, a set of functions get_<name>
accepting an argument of the struct type and returning
a value of the component type is generated,
where <name> is the component name.
@p()
The component access notation x.y in rvalue context is syntactic
sugar for get_y x. If a primitive type is defined
with a set of such get methods, the dot notation
can be used as a shorthand; in other words,
access to structs is always via projection functions
and thus fully abstract.
@p()
Similarly, procedures named ref_<name> accepting a pointer
to the struct type and a value of the component type
are created, and,
in an lvalue context, the notation x.y is syntactic sugar
for ref_y. Note that a reference is a Felix pointer,
that is, a struct with two C pointers in it.

@head(1,"Unions and variants")
All union components in Felix are represented
by a single struct _uctor_ with member
variant of type int, and data of type void*.
The variant is the zero orgin sequence number
of the variant as declared, whilst data points
to the constructor argument if it exists, or
is null otherwise. The data member is cast
on use to the correct type.
@p()
A planned optimisation is to use a plain int
if all variants of a union have no arguments.
@()
The abstract representation of a union consists
of three functions: an injection function called
a constructor, which
creates the union type from an argument,
a test function which tests if a union value
is a particular case, and a destructor
function which extracts the argument of a constructor:
the later is unsafe and should always be preceded by
a test to check the type at run time.
@p()
Note that type recursion in unions works because
the constructor argument is always in a separate
piece of memory, and accessed via a pointer.
@p()
...

