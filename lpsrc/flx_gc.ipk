@head(1,'Garbage collector')
The Felix garbage collector consists of two components: the collector
abstraction, and a concrete collector.
@p()
The abstraction consists of an abstract class collector_t,
which models the collector,
an abstract class allocator_t, which models an allocator,
and two concrete classes:
shape_t, which defines a type shape descriptor, and frame_t,
which describes an allocated memory block, called a frame.
@p()
The frame_t data is stored at the beginning of every block
the collector manages, this is called the header part. 
The rest of the block is for client data, and is called the client part.
The collector manages frames in terms of pointers to the whole block,
which are also pointers to the header. The client only sees a pointer
to the client part.
@p()
The header contains links to other frames, so the collector can navigate 
the set of blocks, and a pointer to a shape object, 
which describes where in the client part pointers reside, so that the
collector can chase down all the reachable blocks.
@p()
The collector mechanism provides resources for a simple
mark and sweep collector, reference counting, and manual
deletion. It also provides for user written finalisers,
in particular C++ class destructors.
@p()
Note that the collector is a 'world stop' synchronous collector.
Collection only occurs when you call the collect() method of the
collector object.
@p()
Note the Felix allocator abstraction is not compatible with 
the C++ allocator concept; instead, it is a simple wrapper
around the malloc/free interface. It is provided primarily
to allow instrumentation of allocations, although it is possible
to supply a user written allocator.

@h = tangler('rtl/flx_gc.hpp')
@select(h)
#ifndef FLX_GC
#define FLX_GC

#include <cstdlib>
#ifndef FLX_RTL_CONFIG
#include "flx_rtl_config.hpp"
#endif

// we use an STL set to hold the collection of roots
#include <set>

namespace flx {
namespace gc {
namespace generic {
// Here are the types we refer to:

struct FLX_RTL_EXTERN frame_t;      // the type of all collectable objects
struct FLX_RTL_EXTERN gc_shape_t;   // the shape of collectable objects
struct FLX_RTL_EXTERN collector_t;  // the collector itself
struct FLX_RTL_EXTERN allocator_t;  // the collector itself

enum gc_shape_flags_t {
  gc_flags_default    = 0,            //< collectable and mobile
  gc_flags_immobile   = 1,            //< cannot be moved
  gc_flags_persistent = 2             //< cannot be deallocated
};

/// Describes runtime object shape.
struct FLX_RTL_EXTERN gc_shape_t
{
  gc_shape_t *next_shape;         ///< pointer to next shape in list or NULL
  char const *cname;              ///< C++ typename
  std::size_t count;              ///< array element count
  std::size_t amt;                ///< bytes allocated
  void (*finaliser)(collector_t*, void*);  ///< finalisation function
  std::size_t n_offsets;          ///< number of offsets
  std::size_t *offsets;           ///< actual offsets
  gc_shape_flags_t flags;         ///< flags
  // convenience constructor
  gc_shape_t(
    gc_shape_t *ns,
    char const *cn,
    std::size_t count_a,
    std::size_t amt_a,
    void (*finaliser_a)(collector_t*, void*),
    std::size_t n_offsets_a,
    std::size_t *offsets_a
  );
  gc_shape_t(
    gc_shape_t *ns,
    char const *cn,
    std::size_t count_a,
    std::size_t amt_a,
    void (*finaliser_a)(collector_t*, void*),
    std::size_t n_offsets_a,
    std::size_t *offsets_a,
    gc_shape_flags_t flags_a
  );
};
@doc()
The following template is provided as a standard wrapper
for C++ class destructors. The term
@begin_displayed_code()
  std_finaliser<T>
@end_displayed_code()
denotes a function pointer to the wrapper for the destructor
of class T, which can be used as a finaliser in the shape
descriptor of a T. The client is cautioned than the order
of finalisation may not be what is expected. Finalisers
should be provided for all C++ objects managed by the Felix
collector and not refering to Felix objects, 
but which contain pointers to other objects that need 
to be deleted when the main object is destroyed;
for example a string class managing an array of char
requires its destructor be invoked to delete the managed
array, and so a finaliser wrapping the destructor must
be provided.
@p()
C data types may, of course, also require destruction,
and Felix therefore can provide programmers with
the convenience of C++ destructors, even for C data types.

@select(h)
template<class T>
void std_finaliser(collector_t*, void *t)
{
  static_cast<T*>(t) -> ~T();
}

@doc()
Here is the allocator abstraction.
@select(h)

/// Allocator abstraction.

struct allocator_t {
  bool debug;
  allocator_t():debug(false){}
  virtual void *allocate(std::size_t)=0;
  virtual void deallocate(void *, std::size_t)=0;
  virtual ~allocator_t(){};
  void set_debug(bool d){debug=d;}
};

@doc()
And here is the collector abstraction.
@select(h)

/// Collector abstraction.
struct FLX_RTL_EXTERN collector_t
{
  bool debug;
  void set_debug(bool d){debug=d;}
  collector_t();
  virtual ~collector_t(){}

@doc()
These routines just provide statistics.
@select(h)
  unsigned long get_allocation_count()const {
    return v_get_allocation_count(); 
  }

  unsigned long get_root_count()const { 
    return v_get_root_count(); 
  }

  unsigned long get_allocation_amt()const { 
    return v_get_allocation_amt(); 
  }

@doc()
Hooks for the supplied allocator, which operate in
terms of shape objects rather than raw memory amounts.
@select(h)
  void *allocate(gc_shape_t *shape, unsigned long x) {
    return v_allocate(shape,x);
  }

  void deallocate(frame_t *fp) {
    v_deallocate(fp);
  }

@doc()
The mark and sweep collector algorithm.
@select(h)
  unsigned long collect() { 
    return v_collect(); 
  }

@doc()
Routines to add and remove roots.
@select(h)
  void add_root(void *memory) {
    v_add_root(memory);
  }

  void remove_root(void *memory) {
    v_remove_root(memory);
  }

@doc()
Routine to optimise store by compaction. Optional,
does nothing if not implemented. The closed flag
should be set to true if a collection has just been
done, and, no foreign pointers are expected anywhere,
otherwise it should be set to false. Setting it to
true enables a check that every pointer found
is live (points to an known object) or NULL.
This may not be the case if there is any garbage,
which may contain the address on the machine stack
that used to point to a live frame (but the frame
is now gone).

@select(h)
  void compact(bool closed) {
    v_compact(closed);
  }

@doc()
Integrity check for the data structure being managed.
@select(h)
  void check() {
    v_check();
  }

private:
  virtual unsigned long v_get_allocation_count()const=0;
  virtual unsigned long v_get_root_count()const=0;
  virtual unsigned long v_get_allocation_amt()const=0;
  virtual void *v_allocate(gc_shape_t *shape, unsigned long)=0;
  virtual void v_deallocate(frame_t *fp)=0;
  virtual unsigned long v_collect()=0;
  virtual void v_add_root(void *memory)=0;
  virtual void v_remove_root(void *memory)=0;
  virtual void v_compact(bool closed)=0;
  virtual void v_check()=0;

@doc()
It doesn't make any sense to copy collector objects
about.
@select(h)
  void operator=(collector_t const&);
  collector_t(collector_t const&);
};


@doc()
The destroy function unconditionally deletes an object,
so it must only be used when there are no managed pointers
to the object. Other pointers might exist, and that is normally
OK provided they're not dereferenced.

@select(h)
void FLX_RTL_EXTERN destroy(void *b);

@doc()
The following routines are provided to help
safely manage pointers. The can be used
to initialise, assign and destroy, and delete 
pointer variables, where delete implies
both NULLing out the variable and also deleting
the object pointed to. 
@p()
Each untyped routine has a corresponding
template to provide a type safe interface.

@select(h)
void FLX_RTL_EXTERN _init_ptr(void **a, void *b);
void FLX_RTL_EXTERN _set_ptr(void **a, void *b);
void FLX_RTL_EXTERN _release_ptr(void **a);
void FLX_RTL_EXTERN _destroy_ptr(void **a);

template<class T>
void init_ptr(T **a, T *b)
{
  _init_ptr
  (
    reinterpret_cast<void**>(a),
    reinterpret_cast<void*>(b)
  );
}

template<class T>
void set_ptr(T **a, T *b)
{
  _set_ptr
  (
    reinterpret_cast<void**>(a),
    reinterpret_cast<void*>(b)
  );
}

template<class T>
void release_ptr(T **a)
{
  _release_ptr
  (
    reinterpret_cast<void**>(a)
  );
}

template<class T>
void destroy_ptr(T **a)
{
  _destroy_ptr
  (
    reinterpret_cast<void**>(a)
  );
}

@doc()
These two routines are used to reset the type
of object an memory block hold, and reset the
length of an array, respectively.

@select(h)
FLX_RTL_EXTERN void flx_reset_shape(void *memory, gc_shape_t &);
FLX_RTL_EXTERN void flx_reset_count(void *memory, unsigned long); 

}}} // end namespaces

@doc()
The following two routines are used to provide
C++ type safe heap allocation. There are no corresponding
delete routines, please use the destroy function.
@p()
Note these routines are now placed
in the global namespace to accomodate Metrowerks
compiler on Mac OS. 

@select(h)
/// Allocate collectable object
FLX_RTL_EXTERN void *operator new
(
  std::size_t, 
  flx::gc::generic::collector_t &, 
  flx::gc::generic::gc_shape_t &
);

/// Allocate collectable array
FLX_RTL_EXTERN void *operator new
(
  std::size_t, 
  flx::gc::generic::collector_t &, 
  flx::gc::generic::gc_shape_t &, 
  unsigned long
);

#endif

@h=tangler('rtl/flx_gc_private.hpp')
@select(h)
// THIS IS A HACK .. required by generic pointer
// manipulators -- but really should be private to the Felix
// default collector implementation

namespace flx {
namespace gc {
namespace generic { // SHOULD BE NAMESPACE collector

/// Heap Frame header
struct frame_t
{
  gc_shape_t *shape;      // the shape of each object
  unsigned long n_objects; // how many objects (for arrays)
  frame_t *next;          // the next and previous objects
  frame_t *prev;          // in the collectors list
  collector_t *collector; // the managing collector
  bool garbage;           // the garbage flag
  bool finalised;         // whether the object is finalised
};

}}} // end namespaces

// ----------------------------------------------------

#define _ROUNDUP(i,n) ((i + n - 1) / n * n)
#define _ALIGN(i) _ROUNDUP(i,FLX_MAX_ALIGN)

#define FRAMESIZE int(_ALIGN(sizeof(flx::gc::generic::frame_t)))
#define FRAME_TO_CLIENT(p) \
  ((void*)((unsigned char*)(void*)p + FRAMESIZE))
#define CLIENT_TO_FRAME(p) \
  ((frame_t*)(void*)((unsigned char*)p - FRAMESIZE))


@h=tangler('rtl/flx_gc.cpp')
@select(h)

#include "flx_gc.hpp"
#include <cstdio>
#include <cassert>
#include "flx_gc_private.hpp"

namespace flx {
namespace gc {
namespace generic {

// create a shape object given an array of offsets
gc_shape_t::gc_shape_t
(
  gc_shape_t *ns,
  char const *cn,
  std::size_t count_a,
  std::size_t amt_a,
  void (*finaliser_a)(collector_t*, void*),
  std::size_t n_offsets_a,
  std::size_t *offsets_a,
  gc_shape_flags_t flags_a
)
  :
  next_shape(ns),
  cname(cn),
  count(count_a),
  amt(amt_a),
  finaliser(finaliser_a),
  n_offsets(n_offsets_a),
  offsets(offsets_a),
  flags(flags_a)
{}

// with flags defaulted
gc_shape_t::gc_shape_t
(
  gc_shape_t *ns,
  char const *cn,
  std::size_t count_a,
  std::size_t amt_a,
  void (*finaliser_a)(collector_t*, void*),
  std::size_t n_offsets_a,
  std::size_t *offsets_a
)
  :
  next_shape(ns),
  cname(cn),
  count(count_a),
  amt(amt_a),
  finaliser(finaliser_a),
  n_offsets(n_offsets_a),
  offsets(offsets_a),
  flags(gc_flags_default)
{}

void destroy(void *p)
{
  if(p)
  {
    frame_t *fp = CLIENT_TO_FRAME(p);
    if(!fp->finalised)
      fp->collector->deallocate(fp);
   }
}

// b may be 0
void _init_ptr(void **a, void *b)
{
  *a = b;
}

// *a or b may be 0
void _set_ptr(void **a, void *b)
{
  *a = b;
}

// *a may be 0
void _release_ptr(void **a)
{
  *a = 0;
}

void _destroy_ptr(void **a)
{
  void *b = *a; // save the pointer value
  *a=0;         // null out the variable
  destroy(b);
}

void reset_shape(void *memory, gc_shape_t &shape)
{
  assert(memory);
  CLIENT_TO_FRAME(memory)->shape = &shape;
}

void reset_count(void *memory, unsigned long n)
{
  assert(memory);
  CLIENT_TO_FRAME(memory)->n_objects = n;
}

collector_t::collector_t() : debug(false) {}


}}} // end namespaces

// in global namespace now ..
void *operator new(
  std::size_t amt,
  flx::gc::generic::collector_t &collector,
  flx::gc::generic::gc_shape_t &shape
)
{
  if (amt != shape.amt)
  {
    fprintf(stderr,"Shape size error: allocator size = %ld\n",amt);
    fprintf(stderr,"Shape %s size = %ld\n",shape.cname,shape.amt);
    abort();
  }
  return collector.allocate(&shape,1);
}

void *operator new(
  std::size_t amt,
  flx::gc::generic::collector_t &collector,
  flx::gc::generic::gc_shape_t &shape,
  unsigned long count
)
{
  assert (amt == shape.amt * count);
  return collector.allocate(&shape,count);
}


@select(tangler('rtl/flx_collector.hpp'))
#ifndef FLX_COLLECTOR
#define FLX_COLLECTOR
#include "flx_gc.hpp"
#include "flx_gc_private.hpp"
#include <map>

namespace flx {
namespace gc {
namespace collector {
using namespace generic;

struct FLX_RTL_EXTERN malloc_free;
struct FLX_RTL_EXTERN flx_collector_t;

/// Allocator using malloc and free.
struct FLX_RTL_EXTERN malloc_free : public virtual allocator_t 
{
  void *allocate(std::size_t);
  void deallocate(void *, std::size_t);
};


/// Naive Mark and Sweep Collector.
struct FLX_RTL_EXTERN flx_collector_t : public collector_t
{
  flx_collector_t(allocator_t *);
  ~flx_collector_t();

  // special to this collector ..?
  void set_min_arena_size(unsigned long);
  bool check_client_pointer(void *);
  bool check_frame_pointer(frame_t *);


protected:

  /// allocator
  void *impl_allocate(gc_shape_t *ptr_map, unsigned long);
  void impl_deallocate(frame_t *frame);

  /// collector (returns number of objects collected)
  unsigned long impl_collect();

  // add and remove roots
  void impl_add_root(void *memory);
  void impl_remove_root(void *memory);

  //
  void check();

  // statistics
  unsigned long impl_get_allocation_count()const;
  unsigned long impl_get_root_count()const;
  unsigned long impl_get_allocation_amt()const;

  void impl_compact(bool closed);
  void impl_check();

private:
  /// allocator
  void *v_allocate(gc_shape_t *ptr_map, unsigned long);
  void v_deallocate(frame_t *frame);

  /// collector (returns number of objects collected)
  unsigned long v_collect();

  // add and remove roots
  void v_add_root(void *memory);
  void v_remove_root(void *memory);

  //
  void v_check();
  // statistics
  unsigned long v_get_allocation_count()const;
  unsigned long v_get_root_count()const;
  unsigned long v_get_allocation_amt()const;

  void v_compact(bool closed);

private:
  bool collecting;
  unsigned long allocation_count;
  unsigned long root_count;
  unsigned long allocation_amt;

 
  void unlink(frame_t *frame);
  void dispose(frame_t *frame);
    // calls post_delete or delete_frame

  void post_delete(frame_t *frame);
  void delete_frame(frame_t *frame);
  unsigned long reap();

  void mark();
  unsigned long sweep(); // calls scan_object
  void scan_object(frame_t *frame);

  frame_t *first;
  frame_t *to_delete;
  typedef std::map<frame_t*,unsigned long, std::less<frame_t*> > rootmap_t;
  rootmap_t roots;
  bool parity;
  allocator_t *allocator;

  // if compaction is being used this stuff controls
  // the arena. The arena ptr grows DOWN towards the
  // start of the arena. arena is NULL unless arenas
  // are being used. Once in use, the allocator is
  // not (normally) used for individual objects

  void *arena;       // if compaction is being used, lo address
  void *arena_high;  // arena base (high) address
  void *arena_ptr;   // current top of the stack
  unsigned long arena_size; // hi - lo
  unsigned long arena_free; // ptr - lo
  float arena_size_factor;
  unsigned long min_arena_size;
};

}}} // end namespaces
#endif

@select(tangler('rtl/flx_collector.cpp'))
#include <cstdlib>
#include <map>
#include <limits.h>
#include <cassert>
#include <cstdio>
#include <cstddef>
#include "flx_rtl_config.hpp"
#include "flx_collector.hpp"
namespace flx {
namespace gc {
namespace collector {

static int mcount FLX_UNUSED = 0;
#ifdef HAVE_GXX_X86
register void *sp __asm__("esp");
#else
// this was getting us unused variable warnings
// static void *sp = 0;
#endif

void *low_sp = 0;
void *hi_sp = 0;

void *malloc_free::allocate(std::size_t amt)
{
  void *p = malloc(amt);
  if(debug)fprintf(stderr,"Malloc %ld bytes, address = %p\n",amt,p);
  //++mcount;
  //void *x = sp;
  //if (low_sp == NULL) low_sp = x,hi_sp = x;
  //else { 
  //  if (x < low_sp) low_sp = x;
  //  if (x > hi_sp) hi_sp = x;
  //}
  //if(mcount%100==0)printf("malloc %p, count=%d,stack size = %ld\n",p,mcount,(char*)hi_sp - (char*)low_sp);
  if(p)return p;
  else {
    fprintf(stderr,"Felix: Malloc out of memory, blk=%ld\n",long(amt));
    abort();
  }
}


void malloc_free::deallocate(void *p, std::size_t)
{
  //printf("free %p\n",p);
  if(debug)fprintf(stderr,"Free %p\n",p);
  free(p);
}

void *flx_collector_t::v_allocate(gc_shape_t *ptr_map, unsigned long x) {
  return impl_allocate(ptr_map, x);
}

void flx_collector_t::v_deallocate(frame_t *frame) {
  impl_deallocate(frame);
}

unsigned long flx_collector_t::v_collect() {
  return impl_collect();
}

void flx_collector_t::v_add_root(void *memory) {
  impl_add_root(memory);
}

void flx_collector_t::v_remove_root(void *memory) {
  impl_remove_root(memory);
}

void flx_collector_t::v_check() {
  impl_check();
}

unsigned long flx_collector_t::v_get_allocation_count()const {
  return impl_get_allocation_count();
}

unsigned long flx_collector_t::v_get_root_count()const {
  return impl_get_root_count();
}

unsigned long flx_collector_t::v_get_allocation_amt()const {
  return impl_get_allocation_amt();
}

void flx_collector_t::v_compact(bool closed) {
  impl_compact(closed);
}


unsigned long flx_collector_t::impl_get_allocation_count()const
{
  return allocation_count;
}

unsigned long flx_collector_t::impl_get_root_count()const
{
  return root_count;
}

unsigned long flx_collector_t::impl_get_allocation_amt()const
{
  return allocation_amt;
}


flx_collector_t::flx_collector_t(allocator_t *a) :
  collecting(false),
  allocation_count(0),
  root_count(0),
  allocation_amt(0),
  first(0),
  to_delete(0),
  parity(false),
  allocator(a),
  arena(0),
  arena_high(0),
  arena_ptr(0),
  arena_size(0),
  arena_free(0),
  arena_size_factor(1.6f),
  min_arena_size(1000000) // 1Meg
{}

void flx_collector_t::set_min_arena_size(unsigned long x) 
{  
  min_arena_size = x; 
}

void * flx_collector_t::impl_allocate(gc_shape_t *shape, unsigned long nobj)
{
  // calculate how much memory to request
  std::size_t amt = nobj * shape->amt * shape->count + FRAMESIZE;

  // allocate a block
  frame_t *fp;
  if(!arena || shape->flags & generic::gc_flags_immobile || amt > arena_free)
    fp = (frame_t*)allocator->allocate(amt);
  else
  {
    amt = _ALIGN(amt);
    arena_ptr = (unsigned char*)arena_ptr - amt;
    arena_free -= amt;
    fp = (frame_t*)arena_ptr;
    if(debug)fprintf(stderr, "New arena object at %p, size %ld\n",arena_ptr,amt);
  }
  assert(fp); // Got some memory!

  if(debug)fprintf(stderr,"Allocated %p-0x%x= new %s\n", FRAME_TO_CLIENT(fp),FRAMESIZE,shape->cname);
  // initialise the shape, garbage flag, and refcount
  fp->shape = shape;
  fp->garbage = parity;
  fp->finalised = false;
  fp->n_objects = nobj;
  fp->collector = this;

  // link the frame into the collectors list
  fp->prev = 0;
  fp->next = first;
  if(first) first->prev = fp;
  first = fp;

  // update statistics
  allocation_count++;
  allocation_amt += amt;
  //fprintf(stderr,"ADDING %ld to allocation amt, result %ld\n",long(amt),long(allocation_amt));
  // return client memory pointer
  return FRAME_TO_CLIENT(fp);
}

void flx_collector_t::impl_deallocate(frame_t *fp)
{
  unlink(fp);
  dispose(fp);
}

void flx_collector_t::unlink(frame_t *fp)
{
  // check we have a pointer to an object
  assert(fp);

  // flag the object as finalised, even before
  // actually calling the finaliser, to
  // prevent recursion via destroy
  fp->finalised = true;

  // call the finaliser if there is one
  void (*finaliser)(collector_t*, void*) = fp->shape->finaliser;
  if (finaliser)  
  {
    void *cp = FRAME_TO_CLIENT(fp);
    (*finaliser)(this,cp);
  }
  // unlink the frame from the collectors list
  if(fp->prev)
    fp->prev->next = fp->next;
  else {
    assert(first==fp);
    first=fp->next;
  }
  if(fp->next)
    fp->next->prev = fp->prev;
}

void flx_collector_t::post_delete(frame_t *fp)
{
  assert(collecting);
  // link into list of objects to delete
  // this list uses the prev pointer!
  fp->prev = to_delete;
  to_delete = fp;
}

void flx_collector_t::dispose(frame_t *fp)
{
  if(collecting) post_delete(fp);
  else delete_frame(fp);
}

void flx_collector_t::delete_frame(frame_t *fp)
{
  // update statistics
  allocation_count--;
  gc_shape_t *shape = fp->shape;
  unsigned long nobj = shape -> count * fp -> n_objects;
  std::size_t size = shape->amt * nobj + FRAMESIZE;
  //fprintf(stderr,"Raw frame %p size %ld\n",fp,long(size));
  // check if pointer is in arena
  if(arena && 
    std::less_equal<void*>()(arena_ptr,fp) && // ptr <= fp < base
    std::less<void*>()(fp,arena_high) 
  )
  {
    size = _ALIGN(size); // FRAGILE
    //fprintf(stderr,"In arena!");
  }
  else
  {
    //fprintf(stderr,"Not in arena\n");
    allocator->deallocate(fp, size);
  }

  allocation_amt -= size;
  //fprintf(stderr,"Subtracting %ld result is %ld\n",long(size),long(allocation_amt));
  //fprintf(stderr, "delete frame %p: nalloc=%ld, alloc=%ld, size = %ld\n",
  //  fp, allocation_count, allocation_amt,long(size)
  //);
}

unsigned long flx_collector_t::reap ()
{
  unsigned long count = 0;
  while(to_delete)
  {
    frame_t *next = to_delete-> prev;
    delete_frame(to_delete);
    to_delete = next;
    ++count;
  }
  return count;
}


unsigned long flx_collector_t::sweep()
{
  if(debug)fprintf(stderr,"Collector: Sweep\n");
  collecting=true;
  frame_t *current = first;
  while(current)
  {
    if(current->garbage == parity)
    {
      if(debug)fprintf(stderr,"Garbage %p=%s\n",current,current->shape->cname);
      unlink(current);
      post_delete(current);
    }
    current = current->next;
  }
  parity = !parity;
  collecting = false;
  return reap();
}

void flx_collector_t::impl_add_root(void *memory)
{
  if(!memory)
  {
    fprintf(stderr, "GC ERROR: ADD NULL ROOT\n");
    abort();
  }
  frame_t *p =  CLIENT_TO_FRAME(memory);
  rootmap_t::iterator iter = roots.find(p);
  if(iter == roots.end())
  {
    std::pair<frame_t *const, unsigned long> entry(p,1UL);
    roots.insert (entry);
    root_count++;
  }
  else
    ++(*iter).second;
}

void flx_collector_t::impl_remove_root(void *memory)
{
  frame_t *p =  CLIENT_TO_FRAME(memory);
  rootmap_t::iterator iter = roots.find(p);
  if(iter == roots.end())
  {
    fprintf(stderr, "GC ERROR: REMOVE ROOT WHICH IS NOT ROOT\n");
    abort();
  }
  if((*iter).second == 1UL)
  {
    roots.erase(iter);
    root_count--;
  }
  else
    --(*iter).second;
}

void flx_collector_t::scan_object(frame_t *frame)
{
  if(debug)fprintf(stderr,"Scanning %p\n",frame);
  if(debug)fprintf(stderr,"Scanning [valid] %p=%s\n",frame,frame->shape->cname);
  if(frame->garbage == parity)
  {
    if(debug){
      fprintf(stderr,"Reachable %p\n",frame);
      gc_shape_t * shape = frame->shape;
      fprintf(stderr,"Reachable [valid] %p=%s\n",frame,shape->cname);
      for(unsigned int i=0; i<shape->n_offsets; ++i)
      {
        unsigned long offset = shape->offsets[i];
        unsigned char *p = (unsigned char*)FRAME_TO_CLIENT(frame);
        void *x = *(void**)(p+offset);
        if(x) {
          bool valid = check_client_pointer(x);
          fprintf(stderr," offset: 0x%04lx %p->[%p-0x%x] %s\n",
            offset,p+offset,x,FRAMESIZE,
            valid?"[valid]":"INVALID"
          );
          if(!valid) abort();
        }
        else
          fprintf(stderr," offset: 0x%04lx %p->[%p] NULL\n",
            offset,p+offset,x);
      }
    }
    frame->garbage = !parity; // reachable!
    gc_shape_t *shape = frame->shape;
    unsigned long n_objects = frame->n_objects * shape->count;
    std::size_t obj_size = shape->amt;
    std::size_t n_offsets = shape->n_offsets;
    std::size_t *offsets = shape->offsets;
    unsigned char *p = (unsigned char*)FRAME_TO_CLIENT(frame);

    for(unsigned long j=0; j<n_objects; ++j)
    {
      for(unsigned int i=0; i<n_offsets; ++i)
      {
        void **q = (void**)(void*)(p + offsets[i]);
        if(*q)
          scan_object(CLIENT_TO_FRAME(*q));
      }
      p+=obj_size;
    }
  }
}

void flx_collector_t::mark()
{
  if(debug)fprintf(stderr,"Collector: Running mark\n");
  assert (root_count == roots.size());

  rootmap_t::iterator const end = roots.end();
  for(
    rootmap_t::iterator i = roots.begin();
    i != end;
    ++i
  )
    scan_object((*i).first);
}

unsigned long flx_collector_t::impl_collect()
{
  if(debug)fprintf(stderr,"Running collector\n");
  mark();
  unsigned long r = sweep();
  if(debug)impl_check();
  return r;
}

static int vpcompare(void const *a, void const *b) {
  void *aa = *(void**)a;
  void *bb = *(void**)b;
  if (std::less<void*>()(aa,bb)) return -1;
  if (std::equal_to<void*>()(aa,bb)) return 0;
  return 1;
}

// scan all known objects, and check every pointer
// is either NULL or points to one of them

void flx_collector_t::impl_check()
{
  if(debug)fprintf(stderr,"RUNNING HEAP INTEGRITY CHECK\n");
  unsigned long nobj = allocation_count;
  void **ctrl = (void**)malloc(nobj * sizeof(void*));
  unsigned long handled = 0;
  unsigned long allocated = 0;
  frame_t *lfirst = first;
  unsigned long inarena = 0;
  unsigned long outofarena = 0;
  while(lfirst) {
    ctrl[handled++]=lfirst;
    gc_shape_t *shape = lfirst->shape;
    unsigned long n_objects = lfirst->n_objects * shape->count;
    unsigned long size = n_objects * shape->amt + FRAMESIZE;
    if(arena && 
      std::less_equal<void*>()(arena_ptr,lfirst) && // ptr <= fp < base
      std::less<void*>()(lfirst,arena_high) 
    )
    {
      size = _ALIGN(size); // FRAGILE
      inarena++;
    }
    else 
      outofarena++
    ;
    //fprintf(stderr,"Object %p size %ld type %s\n",lfirst,long(size),shape->cname);
    allocated += size;
    lfirst = lfirst->next;
  }

  if(handled != nobj)
  {
    fprintf(stderr,"Wrong number of objects\n");
    abort();
  }

  if(allocated != allocation_amt)
  {
    fprintf(stderr,"Wrong allocation amount: recorded as %ld, counted as %ld\n",
      allocation_amt, allocated
    );
    fprintf(stderr, "Objects in arena = %ld, objects out of arena = %ld\n",
      inarena,outofarena
    );
    abort();
  }
  qsort(ctrl,nobj,sizeof(void*),vpcompare);

  for(unsigned int i = 0; i<nobj; ++i) {
    frame_t *frame = (frame_t*) ctrl[i];
    gc_shape_t *shape = frame->shape;
    unsigned long n_objects = frame->n_objects * shape->count;

    // scan the frame for pointers and adjust them
    unsigned char *client = (unsigned char*)FRAME_TO_CLIENT(frame);
    size_t *offsets = shape -> offsets;
    for(unsigned int nel = 0; nel < n_objects; nel++)
    {
      for(unsigned int k = 0; k<shape->n_offsets; ++k) 
      {
        size_t offset = offsets[k];
        void **loc = (void**)(client + offset);
        void *client_ptr = *loc;
        if (client_ptr) // leave NULL alone 
        {
          void *address= CLIENT_TO_FRAME(client_ptr);
          void **res = (void**) bsearch(
            &address,
            ctrl,nobj,
            sizeof(void*),
            vpcompare
          );
          if(!res) {
            fprintf(stderr, 
              "CHECK: In object frame=%p, type %s, subobject #%d,\n"
              "offset #%d->%ld, at address %p,\n"
              "pointer [frame=%p, client=%p] NOT IN GC LIST\n",
              frame, shape->cname,nel,k,offset,loc,address,client_ptr);
            abort();
          }
        }
      }
      client += shape->amt;
    }
  }

  rootmap_t::iterator last = roots.end();
  for(
    rootmap_t::iterator iter = roots.begin();
    iter != last;
    ++iter
  )
  {
    std::pair<frame_t *const, unsigned long> root_record = *iter;
    void **res = (void**) bsearch(
      &root_record.first,
      ctrl,nobj,
      sizeof(void*),
      vpcompare
    );
    if(!res) {
      fprintf(stderr,"CHECK: WOOPS CANNOT FIND ROOT! %p\n",root_record.first);
      abort();
    }
  }
  free(ctrl);
}

bool flx_collector_t::check_frame_pointer(frame_t *p)
{
  frame_t *current = first;
  while(current)
  {
    if(current == p) return true;
    current = current->next;
  }
  return false;
}

bool flx_collector_t::check_client_pointer(void *p)
{
  return p?check_frame_pointer (CLIENT_TO_FRAME(p)):true;
}

flx_collector_t::~flx_collector_t()
{
  //THIS IS VERY DANGEROUS! What if don't want to collect
  //the garbage for efficiency reasons???
  //
  // ELIDED .. already caused a bug!
  //
  //roots.clear();
  //root_count = 0;
  //sweep();
}

// ONCE THIS ROUTINE IS CALLED, the allocator
// is never used again for individual objects.
// The compactor puts all the targets in a SINGLE frame
// and so they cannot be deallocated by the allocator.
// Instead, the only way to clean up garbage is by 
// compacting again. We have to do this when we run out
// of memory --- but ONLY when we're in compacting mode:
// if we try it out of compacting mode we're screwed,
// because we have to allocate enough memory for a copy
// of ALL the objects (and if just ran out on a single
// operation that is going to be impossible!

struct compact_entry_t {
  void *old_frame;
  void *new_frame;
};

static int compact_entry_compare
(
  void const *a, 
  void const *b
) {
  void * aa = ((compact_entry_t const*)a) -> old_frame;
  void * bb = ((compact_entry_t const*)b) -> old_frame;
  if (std::less<void*>()(aa,bb)) return -1;
  else if (std::equal_to<void*>()(aa,bb)) return 0;
  else return 1;
}

void flx_collector_t::impl_compact(bool closed) {
  //if(arena)
  //fprintf(stderr,"arena size = %ld, free space %d%%\n",
  //  arena_size, int(float(arena_free)/float(arena_size)*100.0f)
  //);

  unsigned long nobj = allocation_count;
  unsigned long memreq = allocation_amt;

  // temporary hack: if arena has at least 20% free space don't compact
  if(arena && float(arena_free>>8) / float(arena_size>>8) > 0.2) return;
  //fprintf(stderr,"COMPACTING\n");
  compact_entry_t *ctrl = (compact_entry_t*)malloc(nobj * sizeof(compact_entry_t));
  unsigned long handled = 0;

  // empty the collectors list of objects into the control array
  // the effect is to simply forget all the objects!

  if(debug)fprintf(stderr,"FRAME SIZE = %x\n",FRAMESIZE);
  if(debug)
    fprintf(stderr,"Building array of %ld frames\n",nobj);
  while(first) {
    ctrl[handled++].old_frame=first;
    first = first->next;
  }
  assert(handled == nobj);

  if(debug)fprintf(stderr,"Sorting array");
  qsort(ctrl,nobj,sizeof(compact_entry_t),compact_entry_compare);

  // make a new arena, make sure it is aligned!
  if(debug)
    fprintf(stderr,"MEMREQ=%ld\n",memreq);
  unsigned long new_arena_size = (unsigned long)(memreq * arena_size_factor) + 256 + nobj * FLX_MAX_ALIGN;
  if(new_arena_size < min_arena_size) new_arena_size = min_arena_size ;
  if(debug)fprintf(stderr,"UNALIGNED MEMORY REQUIREMENT=%ld\n",new_arena_size);
  new_arena_size = _ALIGN(new_arena_size);
  if(debug)fprintf(stderr,"ALIGNED MEMORY REQUIREMENT=%ld\n",new_arena_size);
  if(debug)fprintf(stderr,"Allocating new arena, size=%ld\n",new_arena_size);
  unsigned char *new_arena = (unsigned char*)allocator->allocate(new_arena_size);
  unsigned char *new_arena_ptr = new_arena + new_arena_size;
  unsigned long new_arena_free = new_arena_size;
  unsigned char *new_arena_high = new_arena_ptr;

  if(debug)fprintf(stderr,"new arena =%p\n",new_arena);
  if(debug)fprintf(stderr,"arena_ptr =%p\n",new_arena_ptr);

  // assign new locations to our objects
  for(unsigned long int j = 0; j<nobj; ++j) {
    unsigned long int i = nobj - j - 1;
    // calculate the object size
    frame_t *frame = (frame_t*) ctrl[i].old_frame;
    gc_shape_t *shape = frame->shape;
    if(shape->flags & gc_flags_immobile)
    {
      // don't move immobile objects
      ctrl[i].new_frame = frame;
      //fprintf(stderr, "Immobile %p type %s\n",frame, shape->cname);
    }
    else
    {
      unsigned long n_objects = frame->n_objects * shape->count;
      unsigned long amt = shape->amt * n_objects + FRAMESIZE;
      if(arena && 
        std::less_equal<void*>()(arena_ptr,frame) && // ptr <= fp < base
        std::less<void*>()(frame,arena_high) 
      )
        amt = _ALIGN(amt); // FRAGILE
      allocation_amt -= amt;
      unsigned long new_amt = _ALIGN(amt);
      allocation_amt += new_amt;

      // allocate store in arena
      new_arena_ptr = (unsigned char*)new_arena_ptr - new_amt;
      new_arena_free -= new_amt;
      ctrl[i].new_frame = new_arena_ptr;
      //fprintf(stderr,"MOVE OBJECT %p old size %ld new size %ld to %p\n",frame,amt,new_amt,new_arena_ptr);
      if(debug)
        if(amt != new_amt)
          fprintf(stderr,"NONARENA TO ARENA MOVE\n");
    }
  }

  // copy the objects and update pointers
  if(debug)fprintf(stderr,"COPYING OBJECTS\n");
  for(unsigned int i = 0; i<nobj; ++i) {
    frame_t *old_frame = (frame_t*) ctrl[i].old_frame;
    frame_t *new_frame = (frame_t*) ctrl[i].new_frame;
    gc_shape_t *shape = old_frame->shape;
    //if(debug)fprintf(stderr,"\nCOPYING OBJECT %s at %p to %p\n",shape->cname,old_frame,new_frame);
    unsigned long n_objects = old_frame->n_objects * shape->count;
    std::size_t obj_size = shape->amt;

    // NOTE: NOT ALIGNED!! in case source is not an arena
    unsigned long amt = obj_size * n_objects + FRAMESIZE;
    //if(debug)fprintf(stderr,"Raw size %ld\n",amt);

    // copy the frame: we use memmove because
    // we might be doing an in-place compaction
    if (new_frame != old_frame)
      memmove(new_frame,old_frame,amt)
    ;

    //if(debug)fprintf(stderr,"Linking into collector list\n");
    // link the frame into the collectors list
    new_frame->prev = 0;
    new_frame->next = first;
    if(first) first->prev = new_frame;
    first = new_frame;

    // scan the frame for pointers and adjust them
    unsigned char *client = (unsigned char*)FRAME_TO_CLIENT(new_frame);
    size_t *offsets = shape -> offsets;
    //if(debug)fprintf(stderr,"Client pointer %p\n",client);
    //if(debug)fprintf(stderr,"SCANNING frame %d, %ld objects\n",i,n_objects);
    for(unsigned int nel = 0; nel < n_objects; nel++)
    {
      for(unsigned int k = 0; k<shape->n_offsets; ++k) 
      {
        size_t offset = offsets[k];
        //if(debug)fprintf(stderr,"Scanning offset #%d, offset %ld, \n",k,(long)offset);

        void **loc = (void**)(client + offset);
        //if(debug)fprintf(stderr,"ADDRESS OF POINTER %p\n",loc);
        void *client_ptr = *loc;
        //if(debug)fprintf(stderr,"VALUE OF CLIENT POINTER %p\n",client_ptr);
        if (client_ptr) // leave NULL alone 
        {
          void *address= CLIENT_TO_FRAME(client_ptr);
          //if(debug)fprintf(stderr,"FRAME POINTER %p\n",address);
          //if(debug)fprintf(stderr,"SEARCHING\n");
          compact_entry_t *res = (compact_entry_t*) bsearch(
            &address,
            ctrl,nobj,
            sizeof(compact_entry_t),
            compact_entry_compare
          );
          //if(debug)fprintf(stderr,"SEARCH DONE\n");
          //if(debug)fprintf(stderr,"RESULT ADDRESS=%p\n",res);
          if(closed)
          {
            if(!res) {
              fprintf(stderr, "COMPACTOR: CANNOT FIND ADDRESS %p!!!!!!!\n",address);
              abort();
            }
            //if(debug)fprintf(stderr,"New frame pointer is %p\n",res->new_frame);
            //if(debug)fprintf(stderr,"New client pointer is %p\n",FRAME_TO_CLIENT(res->new_frame));
          }
          // finally adjust the pointer if needed
          if(res)
            *loc = FRAME_TO_CLIENT(res->new_frame);
        }
      }
      client += shape->amt;
    }
  }

  //if(debug)fprintf(stderr,"SCANNING COMPLETE\n");
  // discard the old arena now (if there was one)
  if (arena)
  {
    if(debug)fprintf(stderr,"DEALLOCATING OLD ARENA\n");
    allocator->deallocate(arena, arena_size);
  }
  arena = new_arena;
  arena_size = new_arena_size;
  arena_free = new_arena_free;
  arena_ptr = new_arena_ptr;
  arena_high = new_arena_high;

  if(debug)
    fprintf(stderr,"NEW ARENA: LO %p HI %p PTR %p\n",arena, arena_high,arena_ptr);

  //if(debug)fprintf(stderr, "FIXING ROOTS\n");
  rootmap_t old_roots = roots;
  roots.clear();

  rootmap_t::iterator last = old_roots.end();
  for(
    rootmap_t::iterator iter = old_roots.begin();
    iter != last;
    ++iter
  )
  {
    std::pair<frame_t *const, unsigned long> old_root_record = *iter;
    compact_entry_t *res = (compact_entry_t*) bsearch(
      &old_root_record.first,
      ctrl,nobj,
      sizeof(compact_entry_t),
      compact_entry_compare
    );
    if(!res) {
      fprintf(stderr,"WOOPS CANNOT FIND ROOT! %p\n",old_root_record.first);
      abort();
    }
    std::pair<frame_t *const, unsigned long> new_root_record
    (
      (frame_t*)res->new_frame,
      old_root_record.second
    );
    roots.insert(new_root_record);
  }
  //if(debug)fprintf(stderr,"FIXED UP ROOTS\n");
  free(ctrl);
}

}}} // end namespaces

@select(tangler('rtl/flx_ts_collector.hpp'))
#ifndef FLX_TS_COLLECTOR
#define FLX_TS_COLLECTOR
#include "flx_collector.hpp"
#include "demux_mutex.hpp"

namespace flx {
namespace gc {
namespace collector {

/// Naive thread safe Mark and Sweep Collector.
struct FLX_RTL_EXTERN flx_ts_collector_t : 
  public flx::gc::collector::flx_collector_t
{
  flx_ts_collector_t(allocator_t *);
  ~flx_ts_collector_t();

private:
  /// allocator
  void *v_allocate(gc_shape_t *ptr_map, unsigned long);
  void v_deallocate(frame_t *frame);

  /// collector (returns number of objects collected)
  unsigned long v_collect();

  // add and remove roots
  void v_add_root(void *memory);
  void v_remove_root(void *memory);

  //
  void v_check();
  // statistics
  unsigned long v_get_allocation_count()const;
  unsigned long v_get_root_count()const;
  unsigned long v_get_allocation_amt()const;

  void v_compact(bool closed);

private:
  mutable flx::demux::flx_mutex_t mut;
};

}}} // end namespaces
#endif

@select(tangler('rtl/flx_ts_collector.cpp'))
#include "flx_rtl_config.hpp"
#include "flx_ts_collector.hpp"

namespace flx {
namespace gc {
namespace collector {

flx_ts_collector_t::flx_ts_collector_t(allocator_t *a) : 
  flx_collector_t(a) 
{}

flx_ts_collector_t::~flx_ts_collector_t(){}

void *flx_ts_collector_t::v_allocate(gc_shape_t *ptr_map, unsigned long x) {
  flx::demux::flx_mutex_locker_t l(mut);
  return impl_allocate(ptr_map,x);
}

void flx_ts_collector_t::v_deallocate(frame_t *frame) {
  flx::demux::flx_mutex_locker_t l(mut);
  impl_deallocate(frame);
}

unsigned long flx_ts_collector_t::v_collect() {
  flx::demux::flx_mutex_locker_t l(mut);
  return impl_collect();
}

void flx_ts_collector_t::v_add_root(void *memory) {
  flx::demux::flx_mutex_locker_t l(mut);
  impl_add_root(memory);
}

void flx_ts_collector_t::v_remove_root(void *memory) {
  flx::demux::flx_mutex_locker_t l(mut);
  impl_remove_root(memory);
}

void flx_ts_collector_t::v_check() {
  flx::demux::flx_mutex_locker_t l(mut);
  impl_check();
}

unsigned long flx_ts_collector_t::v_get_allocation_count()const {
  flx::demux::flx_mutex_locker_t l(mut);
  return impl_get_allocation_count();
}

unsigned long flx_ts_collector_t::v_get_root_count()const {
  flx::demux::flx_mutex_locker_t l(mut);
  return impl_get_root_count();
}

unsigned long flx_ts_collector_t::v_get_allocation_amt()const {
  flx::demux::flx_mutex_locker_t l(mut);
  return impl_get_allocation_amt();
}

void flx_ts_collector_t::v_compact(bool closed) {
  flx::demux::flx_mutex_locker_t l(mut);
  impl_compact(closed);
}


}}} // end namespaces


