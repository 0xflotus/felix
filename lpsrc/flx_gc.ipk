@head(1,'Garbage collector')
The Felix garbage collector consists of two components: the collector
abstraction, and a concrete collector.
@p()
The abstraction consists of an abstract class collector_t,
which models the collector,
an abstract class allocator_t, which models an allocator,
and two concrete classes:
shape_t, which defines a type shape descriptor, and frame_t,
which describes an allocated memory block, called a frame.
@p()
The frame_t data is stored at the beginning of every block
the collector manages, this is called the header part. 
The rest of the block is for client data, and is called the client part.
The collector manages frames in terms of pointers to the whole block,
which are also pointers to the header. The client only sees a pointer
to the client part.
@p()
The header contains links to other frames, so the collector can navigate 
the set of blocks, and a pointer to a shape object, 
which describes where in the client part pointers reside, so that the
collector can chase down all the reachable blocks.
@p()
The collector mechanism provides resources for a simple
mark and sweep collector, reference counting, and manual
deletion. It also provides for user written finalisers,
in particular C++ class destructors.
@p()
Note that the collector is a 'world stop' synchronous collector.
Collection only occurs when you call the collect() method of the
collector object.
@p()
Note the Felix allocator abstraction is not compatible with 
the C++ allocator concept; instead, it is a simple wrapper
around the malloc/free interface. It is provided primarily
to allow instrumentation of allocations, although it is possible
to supply a user written allocator.

@h = tangler('rtl/flx_gc.hpp')
@select(h)
#ifndef FLX_GC
#define FLX_GC

#include <cstdlib>
#ifndef FLX_RTL_CONFIG
#include "flx_rtl_config.hpp"
#endif

// we use an STL set to hold the collection of roots
#include <set>

namespace flx {
namespace gc {
namespace generic {
// Here are the types we refer to:

struct FLX_RTL_EXTERN frame_t;      // the type of all collectable objects
struct FLX_RTL_EXTERN gc_shape_t;   // the shape of collectable objects
struct FLX_RTL_EXTERN collector_t;  // the collector itself
struct FLX_RTL_EXTERN allocator_t;  // the collector itself

struct FLX_RTL_EXTERN gc_shape_t
{
  char const *cname;              // C++ typename
  std::size_t count;              // array element count
  std::size_t amt;                // bytes allocated
  void (*finaliser)(collector_t*, void*);  // finalisation function
  std::size_t n_offsets;          // number of offsets
  std::size_t *offsets;           // actual offsets

  // convenience constructor
  gc_shape_t(
    char const *cn,
    std::size_t count_a,
    std::size_t amt_a,
    void (*finaliser_a)(collector_t*, void*),
    std::size_t n_offsets_a,
    std::size_t *offsets_a
  );
};
@doc()
The following template is provided as a standard wrapper
for C++ class destructors. The term
@begin_displayed_code()
  std_finaliser<T>
@end_displayed_code()
denotes a function pointer to the wrapper for the destructor
of class T, which can be used as a finaliser in the shape
descriptor of a T. The client is cautioned than the order
of finalisation may not be what is expected. Finalisers
should be provided for all C++ objects managed by the Felix
collector and not refering to Felix objects, 
but which contain pointers to other objects that need 
to be deleted when the main object is destroyed;
for example a string class managing an array of char
requires its destructor be invoked to delete the managed
array, and so a finaliser wrapping the destructor must
be provided.
@p()
C data types may, of course, also require destruction,
and Felix therefore can provide programmers with
the convenience of C++ destructors, even for C data types.

@select(h)
template<class T>
void std_finaliser(collector_t*, void *t)
{
  static_cast<T*>(t) -> ~T();
}

@doc()
Here is the frame_t data type.
@select(h)
struct frame_t
{
  gc_shape_t *shape;      // the shape of each object
  unsigned long n_objects; // how many objects (for arrays)
  frame_t *next;          // the next and previous objects
  frame_t *prev;          // in the collectors list
  collector_t *collector; // the managing collector
  bool garbage;           // the garbage flag
  bool finalised;         // whether the object is finalised
};

@doc()
Its unfortunate, but neither C nor C++ provide
proper alignment controls, and rather than mess
around with weird macro solutions, we just fix
a reasonable figure for 32 bit machines and hope
for the best. Change this figure for your machine
if necessary.

@select(h)
@tangle('#define _MAX_ALIGN '+str(MAX_ALIGN))

// ----------------------------------------------------

#define _ROUNDUP(i,n) ((i + n - 1) / n * n)
#define _ALIGN(i) _ROUNDUP(i,_MAX_ALIGN)

#define FRAMESIZE int(_ALIGN(sizeof(frame_t)))
#define FRAME_TO_CLIENT(p) \
  ((void*)((unsigned char*)(void*)p + FRAMESIZE))
#define CLIENT_TO_FRAME(p) \
  ((frame_t*)(void*)((unsigned char*)p - FRAMESIZE))

@doc()
Here is the allocator abstraction.
@select(h)
struct allocator_t {
  bool debug;
  allocator_t():debug(false){}
  virtual void *allocate(std::size_t)=0;
  virtual void deallocate(void *, std::size_t)=0;
  virtual ~allocator_t(){};
  void set_debug(bool d){debug=d;}
};

@doc()
And here is the collector abstraction.
@select(h)
struct FLX_RTL_EXTERN collector_t
{
  bool debug;
  void set_debug(bool d){debug=d;}
  collector_t();
  virtual ~collector_t(){}

@doc()
These routines just provide statistics.
@select(h)
  virtual unsigned long get_allocation_count()const=0;
  virtual unsigned long get_root_count()const=0;
  virtual unsigned long get_allocation_amt()const=0;

@doc()
Hooks for the supplied allocator, which operate in
terms of shape objects rather than raw memory amounts.
@select(h)
  virtual void *allocate(gc_shape_t *shape, unsigned long)=0;
  virtual void deallocate(frame_t *fp)=0;
@doc()
The mark and sweep collector algorithm.
@select(h)
  virtual unsigned long collect()=0;

@doc()
Routines to add and remove roots.
@select(h)
  virtual void add_root(void *memory)=0;
  virtual void remove_root(void *memory)=0;

@doc()
Integrity check for the data structure being managed.
@select(h)
  virtual void check()=0;

@doc()
It doesn't make any sense to copy collector objects
about.
@select(h)
private: // no assignment or copy
  void operator=(collector_t const&);
  collector_t(collector_t const&);
};


@doc()
The destroy function unconditionally deletes an object,
so it must only be used when there are no managed pointers
to the object. Other pointers might exist, and that is normally
OK provided they're not dereferenced.

@select(h)
void FLX_RTL_EXTERN destroy(void *b);

@doc()
The following routines are provided to help
safely manage pointers. The can be used
to initialise, assign and destroy, and delete 
pointer variables, where delete implies
both NULLing out the variable and also deleting
the object pointed to. 
@p()
Each untyped routine has a corresponding
template to provide a type safe interface.

@select(h)
void FLX_RTL_EXTERN _init_ptr(void **a, void *b);
void FLX_RTL_EXTERN _set_ptr(void **a, void *b);
void FLX_RTL_EXTERN _release_ptr(void **a);
void FLX_RTL_EXTERN _destroy_ptr(void **a);

template<class T>
void init_ptr(T **a, T *b)
{
  _init_ptr
  (
    reinterpret_cast<void**>(a),
    reinterpret_cast<void*>(b)
  );
}

template<class T>
void set_ptr(T **a, T *b)
{
  _set_ptr
  (
    reinterpret_cast<void**>(a),
    reinterpret_cast<void*>(b)
  );
}

template<class T>
void release_ptr(T **a)
{
  _release_ptr
  (
    reinterpret_cast<void**>(a)
  );
}

template<class T>
void destroy_ptr(T **a)
{
  _destroy_ptr
  (
    reinterpret_cast<void**>(a)
  );
}

@doc()
These two routines are used to reset the type
of object an memory block hold, and reset the
length of an array, respectively.

@select(h)
FLX_RTL_EXTERN void flx_reset_shape(void *memory, gc_shape_t &);
FLX_RTL_EXTERN void flx_reset_count(void *memory, unsigned long); 

}}} // end namespaces

@doc()
The following two routines are used to provide
C++ type safe heap allocation. There are no corresponding
delete routines, please use the destroy function.
@p()
Note these routines are now placed
in the global namespace to accomodate Metrowerks
compiler on Mac OS. 

@select(h)
FLX_RTL_EXTERN void *operator new
(
  std::size_t, 
  flx::gc::generic::collector_t &, 
  flx::gc::generic::gc_shape_t &
);

FLX_RTL_EXTERN void *operator new
(
  std::size_t, 
  flx::gc::generic::collector_t &, 
  flx::gc::generic::gc_shape_t &, 
  unsigned long
);

#endif

@select(tangler('rtl/flx_gc.cpp'))

#include "flx_gc.hpp"
#include <cstdio>
#include <cassert>
namespace flx {
namespace gc {
namespace generic {

// create a shape object given an array of offsets
gc_shape_t::gc_shape_t
(
  char const *cn,
  std::size_t count_a,
  std::size_t amt_a,
  void (*finaliser_a)(collector_t*, void*),
  std::size_t n_offsets_a,
  std::size_t *offsets_a
)
  :
  cname(cn),
  count(count_a),
  amt(amt_a),
  finaliser(finaliser_a),
  n_offsets(n_offsets_a),
  offsets(offsets_a)
{}

void destroy(void *p)
{
  if(p)
  {
    frame_t *fp = CLIENT_TO_FRAME(p);
    if(!fp->finalised)
      fp->collector->deallocate(fp);
   }
}

// b may be 0
void _init_ptr(void **a, void *b)
{
  *a = b;
}

// *a or b may be 0
void _set_ptr(void **a, void *b)
{
  *a = b;
}

// *a may be 0
void _release_ptr(void **a)
{
  *a = 0;
}

void _destroy_ptr(void **a)
{
  void *b = *a; // save the pointer value
  *a=0;         // null out the variable
  destroy(b);
}

void reset_shape(void *memory, gc_shape_t &shape)
{
  assert(memory);
  CLIENT_TO_FRAME(memory)->shape = &shape;
}

void reset_count(void *memory, unsigned long n)
{
  assert(memory);
  CLIENT_TO_FRAME(memory)->n_objects = n;
}

collector_t::collector_t() : debug(false) {}


}}} // end namespaces

// in global namespace now ..
void *operator new(
  std::size_t amt,
  flx::gc::generic::collector_t &collector,
  flx::gc::generic::gc_shape_t &shape
)
{
  if (amt != shape.amt)
  {
    fprintf(stderr,"Shape size error: allocator size = %ld\n",amt);
    fprintf(stderr,"Shape %s size = %ld\n",shape.cname,shape.amt);
    abort();
  }
  return collector.allocate(&shape,1);
}

void *operator new(
  std::size_t amt,
  flx::gc::generic::collector_t &collector,
  flx::gc::generic::gc_shape_t &shape,
  unsigned long count
)
{
  assert (amt == shape.amt * count);
  return collector.allocate(&shape,count);
}


@select(tangler('rtl/flx_collector.hpp'))
#ifndef FLX_COLLECTOR
#define FLX_COLLECTOR
#include "flx_gc.hpp"
#include <map>

namespace flx {
namespace gc {
namespace collector {
using namespace generic;

struct FLX_RTL_EXTERN malloc_free;
struct FLX_RTL_EXTERN flx_collector_t;

struct FLX_RTL_EXTERN malloc_free : public virtual allocator_t {
  void *allocate(std::size_t);
  void deallocate(void *, std::size_t);
};


struct FLX_RTL_EXTERN flx_collector_t : public collector_t
{
  flx_collector_t(allocator_t *);
  ~flx_collector_t();

  // allocator
  void *allocate(gc_shape_t *ptr_map, unsigned long);

  // collector (returns number of objects collected)
  unsigned long collect();

  // add and remove roots
  void add_root(void *memory);
  void remove_root(void *memory);

  //
  void check();
  bool check_client_pointer(void *);
  bool check_frame_pointer(frame_t *);

  // statistics
  unsigned long get_allocation_count()const;
  unsigned long get_root_count()const;
  unsigned long get_allocation_amt()const;

private:
  bool collecting;
  unsigned long allocation_count;
  unsigned long root_count;
  unsigned long allocation_amt;

  void deallocate(frame_t *frame);
    // calls unlink and dispose

  void unlink(frame_t *frame);
  void dispose(frame_t *frame);
    // calls post_delete or delete_frame

  void post_delete(frame_t *frame);
  void delete_frame(frame_t *frame);
  unsigned long reap();

  void mark();
  unsigned long sweep(); // calls scan_object
  void scan_object(frame_t *frame);

  frame_t *first;
  frame_t *to_delete;
  typedef std::map<frame_t*,unsigned long, std::less<frame_t*> > rootmap_t;
  rootmap_t roots;
  bool parity;
  allocator_t *allocator;
};

}}} // end namespaces
#endif

@select(tangler('rtl/flx_collector.cpp'))
#include <cstdlib>
#include <map>
#include <limits.h>
#include <cassert>
#include <cstdio>
#include <cstddef>
#include "flx_rtl_config.hpp"
#include "flx_collector.hpp"
namespace flx {
namespace gc {
namespace collector {

static int mcount FLX_UNUSED = 0;
#ifdef HAVE_GXX_X86
register void *sp __asm__("esp");
#else
static void *sp = 0;
#endif

void *low_sp = 0;
void *hi_sp = 0;

void *malloc_free::allocate(std::size_t amt)
{
  void *p = malloc(amt);
  if(debug)fprintf(stderr,"Malloc %p\n",p);
  //++mcount;
  //void *x = sp;
  //if (low_sp == NULL) low_sp = x,hi_sp = x;
  //else { 
  //  if (x < low_sp) low_sp = x;
  //  if (x > hi_sp) hi_sp = x;
  //}
  //if(mcount%100==0)printf("malloc %p, count=%d,stack size = %ld\n",p,mcount,(char*)hi_sp - (char*)low_sp);
  if(p)return p;
  else {
    fprintf(stderr,"Felix: Malloc out of memory, blk=%ld\n",long(amt));
    abort();
  }
}

void malloc_free::deallocate(void *p, std::size_t)
{
  //printf("free %p\n",p);
  if(debug)fprintf(stderr,"Free %p\n",p);
  free(p);
}

unsigned long flx_collector_t::get_allocation_count()const
{
  return allocation_count;
}

unsigned long flx_collector_t::get_root_count()const
{
  return root_count;
}

unsigned long flx_collector_t::get_allocation_amt()const
{
  return allocation_amt;
}


flx_collector_t::flx_collector_t(allocator_t *a) :
  collecting(false),
  allocation_count(0),
  root_count(0),
  allocation_amt(0),
  first(0),
  to_delete(0),
  parity(false),
  allocator(a)
{}


void * flx_collector_t::allocate(gc_shape_t *shape, unsigned long nobj)
{
  // calculate how much memory to request
  std::size_t amt = nobj * shape->amt + FRAMESIZE;

  // allocate a block
  frame_t *fp = (frame_t*)allocator->allocate(amt);
  assert(fp); // Got some memory!

  // initialise the shape, garbage flag, and refcount
  fp->shape = shape;
  fp->garbage = parity;
  fp->finalised = false;
  fp->n_objects = nobj;
  fp->collector = this;

  // link the frame into the collectors list
  fp->prev = 0;
  fp->next = first;
  if(first) first->prev = fp;
  first = fp;

  // update statistics
  allocation_count++;
  allocation_amt += amt;

  // return client memory pointer
  return FRAME_TO_CLIENT(fp);
}

void flx_collector_t::deallocate(frame_t *fp)
{
  unlink(fp);
  dispose(fp);
}

void flx_collector_t::unlink(frame_t *fp)
{

  // check we have a pointer to an object
  assert(fp);

  // flag the object as finalised, even before
  // actually calling the finaliser, to
  // prevent recursion via destroy
  fp->finalised = true;

  // call the finaliser if there is one
  void (*finaliser)(collector_t*, void*) = fp->shape->finaliser;
  if (finaliser)  
  {
    void *cp = FRAME_TO_CLIENT(fp);
    (*finaliser)(this,cp);
  }
  // unlink the frame from the collectors list
  if(fp->prev)
    fp->prev->next = fp->next;
  else {
    assert(first==fp);
    first=fp->next;
  }
  if(fp->next)
    fp->next->prev = fp->prev;
}

void flx_collector_t::post_delete(frame_t *fp)
{
  assert(collecting);
  // link into list of objects to delete
  // this list uses the prev pointer!
  fp->prev = to_delete;
  to_delete = fp;
}

void flx_collector_t::dispose(frame_t *fp)
{
  if(collecting) post_delete(fp);
  else delete_frame(fp);
}

void flx_collector_t::delete_frame(frame_t *fp)
{
  // update statistics
  allocation_count--;
  std::size_t size = fp->shape->amt + FRAMESIZE;
  allocation_amt -= size;

  // deallocate the storage
  allocator->deallocate(fp, size);
}

unsigned long flx_collector_t::reap ()
{
  unsigned long count = 0;
  while(to_delete)
  {
    frame_t *next = to_delete-> prev;
    delete_frame(to_delete);
    to_delete = next;
    ++count;
  }
  return count;
}


unsigned long flx_collector_t::sweep()
{
  if(debug)fprintf(stderr,"Collector: Sweep\n");
  collecting=true;
  frame_t *current = first;
  while(current)
  {
    if(current->garbage == parity)
    {
      if(debug)fprintf(stderr,"Garbage %p=%s\n",current,current->shape->cname);
      unlink(current);
      post_delete(current);
    }
    current = current->next;
  }
  parity = !parity;
  collecting = false;
  return reap();
}

void flx_collector_t::add_root(void *memory)
{
  if(!memory)
  {
    fprintf(stderr, "GC ERROR: ADD NULL ROOT\n");
    abort();
  }
  frame_t *p =  CLIENT_TO_FRAME(memory);
  rootmap_t::iterator iter = roots.find(p);
  if(iter == roots.end())
  {
    std::pair<frame_t *const, unsigned long> entry(p,1UL);
    roots.insert (entry);
    root_count++;
  }
  else
    ++(*iter).second;
}

void flx_collector_t::remove_root(void *memory)
{
  frame_t *p =  CLIENT_TO_FRAME(memory);
  rootmap_t::iterator iter = roots.find(p);
  if(iter == roots.end())
  {
    fprintf(stderr, "GC ERROR: REMOVE ROOT WHICH IS NOT ROOT\n");
    abort();
  }
  if((*iter).second == 1UL)
  {
    roots.erase(iter);
    root_count--;
  }
  else
    --(*iter).second;
}

void flx_collector_t::scan_object(frame_t *frame)
{
  if(debug)fprintf(stderr,"Scanning %p\n",frame);
  if(debug)fprintf(stderr,"Scanning [valid] %p=%s\n",frame,frame->shape->cname);
  if(frame->garbage == parity)
  {
    if(debug){
      fprintf(stderr,"Reachable %p\n",frame);
      gc_shape_t * shape = frame->shape;
      fprintf(stderr,"Reachable [valid] %p=%s\n",frame,shape->cname);
      for(unsigned int i=0; i<shape->n_offsets; ++i)
      {
        unsigned long offset = shape->offsets[i];
        unsigned char *p = (unsigned char*)FRAME_TO_CLIENT(frame);
        void *x = *(void**)(p+offset);
        if(x) {
          bool valid = check_client_pointer(x);
          fprintf(stderr," offset: 0x%04lx %p->[%p-0x%x] %s\n",
            offset,p+offset,x,FRAMESIZE,
            valid?"[valid]":"INVALID"
          );
          if(!valid) abort();
        }
        else
          fprintf(stderr," offset: 0x%04lx %p->[%p] NULL\n",
            offset,p+offset,x);
      }
    }
    frame->garbage = !parity; // reachable!
    gc_shape_t *shape = frame->shape;
    unsigned long n_objects = frame->n_objects * shape->count;
    std::size_t obj_size = shape->amt;
    std::size_t n_offsets = shape->n_offsets;
    std::size_t *offsets = shape->offsets;
    unsigned char *p = (unsigned char*)FRAME_TO_CLIENT(frame);

    for(unsigned long j=0; j<n_objects; ++j)
    {
      for(unsigned int i=0; i<n_offsets; ++i)
      {
        void **q = (void**)(void*)(p + offsets[i]);
        if(*q)
          scan_object(CLIENT_TO_FRAME(*q));
      }
      p+=obj_size;
    }
  }
}

void flx_collector_t::mark()
{
  if(debug)fprintf(stderr,"Collector: Running mark\n");
  assert (root_count == roots.size());

  rootmap_t::iterator const end = roots.end();
  for(
    rootmap_t::iterator i = roots.begin();
    i != end;
    ++i
  )
    scan_object((*i).first);
}

unsigned long flx_collector_t::collect()
{
  if(debug)fprintf(stderr,"Running collector\n");
  mark();
  return sweep();
}

void flx_collector_t::check()
{
 // not implemented: should scan all objects,
 // and check total memory is as expected
 // can also check back links, statistics,
 // and parity
}

bool flx_collector_t::check_frame_pointer(frame_t *p)
{
  frame_t *current = first;
  while(current)
  {
    if(current == p) return true;
    current = current->next;
  }
  return false;
}

bool flx_collector_t::check_client_pointer(void *p)
{
  return p?check_frame_pointer (CLIENT_TO_FRAME(p)):true;
}

flx_collector_t::~flx_collector_t()
{
  //THIS IS VERY DANGEROUS! What if don't want to collect
  //the garbage for efficiency reasons???
  //
  // ELIDED .. already caused a bug!
  //
  //roots.clear();
  //root_count = 0;
  //sweep();
}

}}} // end namespaces


