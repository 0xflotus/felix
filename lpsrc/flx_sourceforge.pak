@head(1,'Sourceforge web site top level')
These HTML pages are manually prepared.
The output lives in the subdirectory www,
but the files must be at the top level on the
sourceforge site to link to everything properly.
@f = open("VERSION")
@flx_version = string.strip(f.readline())
@f.close()
@select(tangler('www/index.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Felix</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Felix: The power language for C++ programmers</H1>
@tangle("<H2>Felix Version "+flx_version+"</H1>")
<P>
<STRONG>Learn</STRONG> more from the
@tangle("<A HREF=flx_"+flx_version+"/tut/doc/en_flx_tutorial_top.html>tutorial</A>.")
<STRONG>Download</STRONG> <A HREF=download.html>felix</A> now! 
See <A HREF=developer.html>developer</A> to <STRONG>contribute</STRONG>. 
</P><P>
Felix is new, high power, Open Source, community based
programming language which
provides an ML style type system with a syntax that C++
programmers should find easy to learn. It generates 
C++ and supports both use of C++ types as primitives,
as well as embedding in existing C++ written architectures
in a natural manner.
</P><P>
Unlike many other scripting
languages, Felix boasts <STRONG>seamless integration</STRONG>
with C and C++ code bases, which it achieves by adopting
the C/C++ object model directly.
</P><P>
<STRONG>Control inversion</STRONG> converts logical threads
into continuation objects with resume() callback methods, 
allowing embedding in event driven message passing frameworks,
and supporting high speed context switching
of cooperatively multitasked logics, called
ultra-lightweight threads. Memory is the only limit
on the number of UL-threads supported, and context
switching times of order O(1) can be achieved using
hash tables. Applications include web services,
telephony, GUI, and other event driven message passing
systems.
</P>
<P>Support for <STRONG>Domain Specific Languages</STRONG>
is provided by incorporating some of the them directly into 
the core compiler, with the idea of later providing
an abstracted extension mechanism. We currently
support regular matching and lexing, and hope to extend
this set to include parsing, numerical computation,
term rewriting, XML processing, and SQL.
</P><P>
<STRONG>Language Features</STRONG> include:
<UL>
<LI>Algebraic Data Types including
<UL>
<LI>Tuples</LI>
<LI>Variants with full support for inductive types</LI>
<LI>Structs</LI>
<LI>First class Higher Order Functions and Procedures with Currying</LI>
</UL>
</LI>
<LI>Pattern matching</LI>
<LI>Regular matching</LI>
<LI>Type inference for variables and function returns</LI>
<LI>Garbage Collection</LI>
<LI>LALR(1) yaccable Grammar</LI>
<LI>No primitive types in core language: all primitives supplied by user</LI>
<LI>C++ binding constructions</LI>
<LI>Module system</LI>
<LI>ISO10646/Unicode character set</LI>
<LI>Compile time parametric polymorphism</LI>
</UL>

<STRONG>Libraries</STRONG> include:
<UL>
<LI>Standard Library includes bindings for</LI>
<UL>
<LI>C99/C++ exact and normal integral types</LI>
<LI>C99 floats</LI>
<LI>string(8 bit), ustring(32 bit)</LI>
<LI>GNU multiple precision arithmetic (gmp) package</LI>
</UL>
</UL>
<STRONG>Architecture</STRONG> support includes:
<UL>
<LI>Control Inversion: mechanical translation of blocking reads into callbacks provides event
driven cooperative multi-tasking</LI>
<LI>Targets dynamically loaded shared libraries</LI>
<LI>User written drivers allow integration into existing message passing
frameworks</LI>
<LI>Sample drivers for stand alone program and standard input</LI>
</UL>
<STRONG>Implementation</STRONG> information:
<UL>
<LI>All source written using the Literate Programming 
tool <A HREF=http://interscript.sf.net>interscript</A></LI>
<LI>Compiler implemented in <A HREF=http://caml.inria.fr>Ocaml 3.07</A></LI>
<LI>Generates ISO C++ code</LI>
</UL>
<P>
Felix is <STRONG>Compatible</STRONG> with most platforms including
all Unix variants, Windows with or without Cygwin, and Mac. 
A C++ compiler and either the ocaml native code or bytecode
compiler with bignum support is required to use Felix.
</P>
<P>
<STRONG>Browse</STRONG> the felix sourceforge <A HREF=http://sourceforge.net/projects/felix/>project</A> page.
</P>
<P>
<STRONG>Browse</STRONG> the felix 
<UL>
@tangle("<LI><A HREF=flx_"+flx_version+"/tut/doc/en_flx_tutorial_top.html>main tutorial</A>,")
@tangle("<LI><A HREF=flx_"+flx_version+"/tut/doc/en_flx_tut_bind_top.html>binding and embedding tutorial</A> or")
@tangle("<LI><A HREF=flx_"+flx_version+"/tut/doc/en_flx_tut_macro_top.html>macro processor tutorial</A> ")
@tangle("<LI><A HREF=flx_"+flx_version+"/htmlman/felix_1.html>man pages</A> ")
</UL>
online.
</P>
<P>
<STRONG>Browse</STRONG> the felix ocaml implementation module reference 
@tangle("<A HREF=flx_"+flx_version+"/impldoc/index.html>tutorial</A> generated by ocamldoc.")
</P>
<P><STRONG>Join</STRONG> the mailing list for discussion of
the Felix <A HREF= 
http://lists.sourceforge.net/lists/listinfo/felix-language>language.</A>
</P><P>
<STRONG>Join</STRONG> the mailing list for discussion of the Felix 
<A
HREF=http://lists.sourceforge.net/lists/listinfo/felix-impl>implementation</A>
</P>
The CVS location is
<STRONG>cvs.sourceforge.net:/cvsroot/felix</STRONG>
<P>
CVS web access <A
HREF="http://sourceforge.net/cvs/?group_id=28597">here</A>
<P>
<STRONG>Browse</STRONG> the complete documented source code, test suite, etc,
using 
@tangle("<LI><A HREF=flx_"+flx_version+"/doc/en_flx_top.html>frames</A>,")
or
@tangle("<LI><A HREF=flx_"+flx_version+"/doc/en_flx.html>without frames</A>,")
The documentation is generated by <A
HREF=//interscript.sf.net>interscript</A>.
</BODY>
</HTML>

@select(tangler('www/download.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
@tangle("<TITLE>Felix Download Felix "+flx_version+"</TITLE>")
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Prerequisites</H2>
<P>You must first have installed:
<OL>
<LI><A HREF=http://caml.inria.fr>Ocaml 3.07</A> to build
the Felix compiler,

<LI>The ocaml package <A HREF=http://www.carva.org/sylvain.le-gall/ocaml-fileutils.html>fileutils</A>
written by <A HREF=mailto@sylvain.le-gall@polytechnique.org>Sylvain Le Gall</A>. There is also
a copy of this package <A HREF=ocaml-fileutils-latest.tar.gz>cached here</A>

<LI><A HREF=http://www.python.org>Python</A>
to run the build scripts,

<LI>A C++ compiler. The build script is preset to 
use GNU g++.
</OL>
</P>
<H1>Supported Platforms</H1>
<P>Currently a Unix like environment is required. Felix 
has been built on the following platforms:
<OL>
<LI>Linux RH9 (g++)
<LI>Mac OS9 (CodeWarrior)
<LI>OSX 10.3 (g++)
<LI>Solaris 9 SPARC (g++)
<LI>Free BSD 5.2.1 i386 (g++)
<LI>Win32 Cygwin (g++)
<LI>Win32 MingW (g++)
</OL>
</P>

<H1>Download</H1>
@tangle("<P> Download developer tarball <A HREF=flx_"+flx_version+"_src.tgz>flx_"+flx_version+"_src.tgz</A> (486391bytes)")
</P>
<H1>Make procedure</H1>
To bootstrap the build, type
</P><P><CODE>
make boot
</CODE></P><P>
on the command line to unpack the build scripts and makefile.
You may need to <STRONG>edit</STRONG> the file
</P><P><CODE>
config/config.py
</CODE></P>
to suit your platform.</P><P>
You should now be able to:
</P><P>
<CODE>
make<BR>
make doc<BR>
</CODE></P>
<P>Become superuser and type
</P>
<P><CODE>
make install
</CODE></P><P>
to install the system, by default in /usr/local/lib/felix,
the scripting driver harness in /usr/local/bin,
and the man pages in /usr/local/man.
If these install points are not suitable for your
system, you'll have to <STRONG>edit</STRONG> the config/config.py file.
</P>
<H1>Building your Library</H1>
<P>Felix only comes with a core service library.
Instead of providing a more complete library,
we provide a tool for generating wrappers for
you complete C environment. Type
</P><P><CODE>
make default_wrappers
</CODE></P><P>
to copy the wrapper generator control files, found in the 
<CODE>config</CODE> directory, and
ending in <CODE>.flxcc.default</CODE>
to the corresponding files without the <CODE>.default</CODE>
suffix. You can now <STRONG>edit</STRONG> these <CODE>.flxcc</CODE>
files as required, they won't be clobbered except by another
<CODE>make default_wrappers</CODE> command. Type
</P><P><CODE>
make wrappers
</CODE></P><P>
to generate wrappers for the sample files. After the wrappers
are generated you can install resulting directory trees
in an appropriate place such as <CODE>/usr/local/lib/felix/lib</CODE>.
</P>
<P><STRONG>DO NOT EXPECT THIS PROCESS TO WORK WITHOUT
EDITING THE CONTROL FILES</STRONG>. The sample files
work on my Redhat Linux, version 9, system. Read the
<A HREF=flxcc.html>flxcc</A> reference material
for more information. Whilst every effort is made
to reduce the pain of configuring the wrapper generator,
<EM>wrapping your whole C environment in one go</EM>
is an ambitious task. Take the time to build stable
standard library, because all your subsequent programming
will depend on it. C++ is the only other programming language
capable of providing you instant access to your complete
C programming environment. Flxcc cannot currently wrap C++
headers.
</P>

<H1>CVS access</H1>
To keep up to date,
you need to connect to the CVS archive, the CVS
address is: <STRONG>cvs.sourceforge.net:/cvsroot/felix</STRONG>,
see
<A HREF=http://sourceforge.net/cvs/?group_id=28597>CVS web access</A>

The first time you need to so, pressing Enter key for password:
</P><P><CODE>
make backup<BR>
rm -rf lpsrc<BR>
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/felix login<BR>
cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/felix co lpsrc<BR>
</CODE>
</P><P>Thereafter you should be able to do:

</P><P><CODE>
make backup<BR>
cd lpsrc<BR>
cvs update<BR>
cd ..<BR>
</CODE>
</P><P>Continue after refreshing the archive with:
</P><P><CODE>
make virgin<BR>
make boot<BR>
make<BR>
</CODE>
</P><P>and build documentation and install as required.
</P>

<H1>Mailing lists</H1>
<P><OL>
<LI>
<A HREF=http://lists.sourceforge.net/lists/listinfo/felix-language>Language discussion</A>
<LI><A HREF=http://lists.sourceforge.net/lists/listinfo/felix-impl>Compiler implementation discussion</A>
</OL><P>

<H1>Contact</H1>
<P>The principal developer is
<A HREF=mailto:skaller@users.sourceforge.net>John Skaller</A>
</P>

<H1>See also</H1>
<A HREF=developer.html>Developer Info</A>
</P>

</BODY>

@select(tangler('www/developer.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
@tangle("<TITLE>Felix Developers Info</TITLE>")
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Contributing</H1>
<P>To join this exciting project you need to do the following:</P>
<P>
<OL>
<LI><A HREF=download.html>Build</A> and install felix</LI>
<LI>Join the <A HREF=http://lists.sourceforge.net/lists/listinfo/felix-language>Language discussion</A>
mailing list and announce yourself and the result of your build attempt.
</LI>
<LI>Let us know what your interest in Felix is,
how we can help you, and what you might be able to
do to help us.
</LI>
<LI>Contribute something</LI>
<LI>Request developer status</LI>
</OL>
</P>
<H1>Job List</H1>
<P>
Please read <A HREF=jobs.html>Jobs</A>.
</P>
<H1>Coding Guide</H1>
<P>
Please read <A HREF=coding.html>Coding Guidelines</A>.
</P>
<H1>Flxcc wrapper generator</H1>
<P>
There is some information on using the <A HREF=flxcc.html>flxcc</A> wrapper generator.
</P>
</BODY>
</HTML>

@select(tangler('www/jobs.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
@tangle("<TITLE>Felix Jobs</TITLE>")
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Jobs</H1>
<P>Felix is an open source community based programming language project.
The community basis leads to a need for considerable 
administrative, advocacy, diplomatic, and political skills,
particularly project management at this stage.
</P><P>
As a compiler project, a wide range of opporunities
also exist for improving the compiler and writing
reference documentation as well as actually deciding what to
put in, and implementing it.
<P><EM>Everyone is welcome to contribute to the language design
process.</EM>
</P>
<TABLE>
<TR><TD>Project manager</TD><TD>Overall activity coordination</TD></TR>
<TR><TD>Advocate</TD><TD>Publish articles in various media</TD></TR>
<TR><TD>Web Site designer</TD><TD>Manage the felix.sf.net web site</TD></TR>
<TR><TD>Build Tester</TD><TD>Check the build on  particular platform</TD></TR>
<TR><TD>Compiler writer</TD><TD>Implement core <A HREF=compiler.html>compiler</A></TD></TR>
<TR><TD>Core library Developer</TD><TD>Implement core libraries</TD></TR>
<TR><TD>Library Developer</TD><TD>Implement Standard library components</TD></TR>
<TR><TD>Wrapper Library Developer</TD><TD>Develop wrappers for your favourite C or C++ library</TD></TR>
<TR><TD>Manual writer</TD><TD>Specify language semantics</TD></TR>
<TR><TD>Manual writer</TD><TD>Write User Guide</TD></TR>
<TR><TD>Tester</TD><TD>Write unit tests</TD></TR>
</TABLE>
</BODY>
</HTML>

@select(tangler('www/compiler.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
@tangle("<TITLE>Felix Compiler Implementors</TITLE>")
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Compiler documentation</H1>
<P>The ocamldoc generated <A HREF=impldoc/index.html>module reference</A>
for the modules in the core compiler are useful sometimes.
</P>
</BODY>
</HTML>


@select(tangler('www/flxcc.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
<TITLE>Flxcc Wrapper Generator</TITLE>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Flxcc Wrapper Generator</H1>
<P>Felix now ships with <STRONG>flxcc</STRONG> which can 
be used to bulk generate wrappers for installed libraries.
This tool is very much work in progress.</P>
<P>To execute, you should first <STRONG>install Felix</STRONG>.
This is because the tool executes 'flxg', the Felix compiler,
and it will use the one in the current PATH, not the development
version.
</P><P>
Then use the command:
</P><P><CODE>
  flxcc control_filename.flxcc
</CODE></P><P>to execute the wrapper generator. When it finishes
you can copy the generated wrappers and precompiled headers
to where you want to install them, perhaps the 
</P><P><CODE>felix/lib</CODE></P>
<P>directory.</P>
<H2>Flxcc control file format</H2>
The first thing you need to do is type
</P><P><CODE>
  make default_wrappers
</CODE></P>
<P>which copies a sample control file
</P><P><CODE>
  config/usr_include.flxcc.default
</CODE></P><P>to</P><P>
<CODE>
  config/usr_include.flxcc
</CODE></P><P>where you can edit it without fear it
will be clobbered by a new install. Examine the
file and find some commands:
</P>
<P><STRONG>// </STRONG><EM> comment</EM><BR>is a comment line and
is ignored.</P>

<P><STRONG>outdir</STRONG><CODE> flxcc_out</CODE><BR>specifies the directory
into which wrappers will be written.</P>

<P><STRONG>prein</STRONG> <CODE>usr_include.h</CODE><BR>
specifies the name
of the C header file which flxcc generates.</P>

<P><STRONG>preout</STRONG><CODE> usr_include.hhh</CODE><BR>
specifies the name
of the preprocessed C header file which is generated by
the C preprocessor</P>

<P><STRONG>preprocessor</STRONG><CODE> gcc -E</CODE><BR>
specifies the
preprocessor command to use to preprocess files.
</P>

<P><STRONG>path</STRONG> <EM>directory</EM><BR>
adds a directory
to the include path given to the preprocessor with
a -I option</P>

<P><STRONG>incfile</STRONG> <EM>filename.h</EM><BR> 
adds the
regular C header file
to the list of #include directives placed in the
prein file.</P>

<P><STRONG>incdir</STRONG> <EM>directory</EM><BR>
adds all the regular
files in the given directory
to the list of #include directives placed in the
prein file.</P>

<P><STRONG>recincdir</STRONG> <EM>directory</EM><BR> 
adds all the regular 
files in the given directory, or any descendant thereof, to the
list of #include directives placed in the prein file.</P>

<P><STRONG>exclude</STRONG> <EM>filename</EM><BR>
excludes a file
or (for recincdir) a directory, from consideration
as a file to #include in the prein file</P>

<P>Felix now generates the prein file, runs the preprocessor
on it to generate the preout file. It then parses the preout 
file using the frontc/cil parser. </P>

<P>This creates an internal representation of
the set of C headers included. Note that the headers
represented are the transitive closure of the ones listed
in the prein file: any of the files #included can #include
other files.</P>

<P><STRONG>merge</STRONG> <EM>filename1 filename2 </EM><BR>
This command tells flxcc to cheat, and pretend all
definitions which occur in filename1 occur in filename2.
This command must be used for internal implementation
detail files such as GNU <STRONG>bits</STRONG> files
which give an #error if included directly.
Note that flxcc may still generate an empty module
for such files even if the definitions have been
merged into another file</P>

<P><STRONG>noheader</STRONG> <EM>filename</EM><BR>
tells flxcc
not to generate a C #include for this file when it
is generating the Felix wrapper.
This command must be used for internal implementation
detail files such as GNU <STRONG>bits</STRONG> files
which give an #error if included directly.
</P>

<P><STRONG>rename</STRONG> <EM>sym1 sym2</EM><BR>
tells flxcc
to replace occurences of a Felix identifier sym1 with
identifier sym2. This command is required to rename
any symbol which happens to be a Felix keyword, but
it can also be used to resolve other clashes with
externally defined names. Note it cannot resolve
any <EM>internal</EM> clashes since all occurences
are renamed.
</P>

<P><STRONG>ignore</STRONG> <EM>sym1</EM><BR>
tells flxcc
to drop any definition of the specified symbol.
This command is needed to prevent clashes with
externally defined symbols such as standard library
names. Uses of the symbol, however, are not affected,
and so can map onto standard library names.
</P>

<P><STRONG>#include </STRONG> <EM>filename</EM><BR>
tells flxcc to parse the denoted file for flxcc
control statements.

<H2>Generated Output Example</H2>
<P><CODE><PRE>
// /usr/include/stdio.h
//Raw Input file: usr_include.hhh
//Generated by Felix Version 1.0.7
//Timestamp: 2004/5/27 21:34:18 UTC
//Timestamp: 2004/5/28 7:34:18 (local)
include 'std';

header '#include "/usr/include/stdio.h"';

//INCLUDES
include "usr/include/_G_config_lib";
include "usr/include/features_lib";
include "usr/include/getopt_lib";
include "usr/include/libio_lib";
include "usr/include/sys/types_lib";
include "usr/lib/gcc-lib/i386-redhat-linux/3.2.2/include/stdarg_lib";

module _usr_include_stdio_h
{
  open C_hack;
  open _usr_include__G_config_h;
  open _usr_include_features_h;
  open _usr_include_getopt_h;
  open _usr_include_libio_h;
  open _usr_include_sys_types_h;
  open _usr_lib_gcc_lib_i386_redhat_linux_3_2_2_include_stdarg_h;
  
  //EXTERNALLY COMPLETED TYPES
  //type _struct__IO_FILE defined in _usr_include_libio_h='/usr/include/libio.h';
  
  //STRUCT or UNION ALIASES
  typedef FILE = _struct__IO_FILE;
  typedef __FILE = _struct__IO_FILE;
  
  //TYPE ALIASES
  typedef fpos_t = _G_fpos_t;
  
  //VARIABLES
  const stdout: ptr[_struct__IO_FILE] = 'stdout';
  const stderr: ptr[_struct__IO_FILE] = 'stderr';
  const stdin: ptr[_struct__IO_FILE] = 'stdin';
  const sys_nerr: int = 'sys_nerr';
  const sys_errlist: cptr[cptr[char]] = 'sys_errlist';
  
  //PROCEDURES
  proc clearerr: ptr[FILE] = 'clearerr($a);';
  proc perror: cptr[char] = 'perror($a);';
  proc setlinebuf: ptr[FILE] = 'setlinebuf($a);';
  proc flockfile: ptr[FILE] = 'flockfile($a);';
  proc rewind: ptr[FILE] = 'rewind($a);';
  proc setbuf: ptr[FILE] * ptr[char] = 'setbuf($a);';
  proc clearerr_unlocked: ptr[FILE] = 'clearerr_unlocked($a);';
  proc setbuffer: ptr[FILE] * ptr[char] * size = 'setbuffer($a);';
  proc funlockfile: ptr[FILE] = 'funlockfile($a);';
  
  //FUNCTIONS
  fun puts: cptr[char] -> int = 'puts($a)';
  fun sscanf[t]: t -> int = 'sscanf($a)';
  fun putw: int * ptr[FILE] -> int = 'putw($a)';
  fun gets: ptr[char] -> ptr[char] = 'gets($a)';
  fun fscanf[t]: t -> int = 'fscanf($a)';
  fun getw: ptr[FILE] -> int = 'getw($a)';
  fun vfprintf: ptr[FILE] * cptr[char] * __gnuc_va_list -> int = 'vfprintf($a)';
  fun fgetpos: ptr[FILE] * ptr[fpos_t] -> int = 'fgetpos($a)';
  fun fseek: ptr[FILE] * long * int -> int = 'fseek($a)';
  fun rename: cptr[char] * cptr[char] -> int = 'rename($a)';
  fun fdopen: int * cptr[char] -> ptr[FILE] = 'fdopen($a)';
  fun fread_unlocked: address * size * size * ptr[FILE] -> size = 'fread_unlocked($a)';
  fun feof: ptr[FILE] -> int = 'feof($a)';
  fun ftell: ptr[FILE] -> long = 'ftell($a)';
  fun getchar_unlocked: 1 -> int = 'getchar_unlocked($a)';
  fun fwrite_unlocked: caddress * size * size * ptr[FILE] -> size = 'fwrite_unlocked($a)';
  fun fgetc_unlocked: ptr[FILE] -> int = 'fgetc_unlocked($a)';
  fun fopen: cptr[char] * cptr[char] -> ptr[FILE] = 'fopen($a)';
  fun putchar_unlocked: int -> int = 'putchar_unlocked($a)';
  fun ctermid: ptr[char] -> ptr[char] = 'ctermid($a)';
  fun sprintf[t]: t -> int = 'sprintf($a)';
  fun ftrylockfile: ptr[FILE] -> int = 'ftrylockfile($a)';
  fun ferror: ptr[FILE] -> int = 'ferror($a)';
  fun freopen: cptr[char] * cptr[char] * ptr[FILE] -> ptr[FILE] = 'freopen($a)';
  fun feof_unlocked: ptr[FILE] -> int = 'feof_unlocked($a)';
  fun remove: cptr[char] -> int = 'remove($a)';
  fun fileno_unlocked: ptr[FILE] -> int = 'fileno_unlocked($a)';
  fun setvbuf: ptr[FILE] * ptr[char] * int * size -> int = 'setvbuf($a)';
  fun printf[t]: t -> int = 'printf($a)';
  fun fflush: ptr[FILE] -> int = 'fflush($a)';
  fun tempnam: cptr[char] * cptr[char] -> ptr[char] = 'tempnam($a)';
  fun fputc: int * ptr[FILE] -> int = 'fputc($a)';
  fun pclose: ptr[FILE] -> int = 'pclose($a)';
  fun popen: cptr[char] * cptr[char] -> ptr[FILE] = 'popen($a)';
  fun tmpnam: ptr[char] -> ptr[char] = 'tmpnam($a)';
  fun tmpnam_r: ptr[char] -> ptr[char] = 'tmpnam_r($a)';
  fun ungetc: int * ptr[FILE] -> int = 'ungetc($a)';
  fun fgetc: ptr[FILE] -> int = 'fgetc($a)';
  fun fileno: ptr[FILE] -> int = 'fileno($a)';
  fun fclose: ptr[FILE] -> int = 'fclose($a)';
  fun ferror_unlocked: ptr[FILE] -> int = 'ferror_unlocked($a)';
  fun fprintf[t]: t -> int = 'fprintf($a)';
  fun vprintf: cptr[char] * __gnuc_va_list -> int = 'vprintf($a)';
  fun fread: address * size * size * ptr[FILE] -> size = 'fread($a)';
  fun fputs: cptr[char] * ptr[FILE] -> int = 'fputs($a)';
  fun fgets: ptr[char] * int * ptr[FILE] -> ptr[char] = 'fgets($a)';
  fun tmpfile: 1 -> ptr[FILE] = 'tmpfile($a)';
  fun fsetpos: ptr[FILE] * cptr[fpos_t] -> int = 'fsetpos($a)';
  fun snprintf[t]: t -> int = 'snprintf($a)';
  fun putc_unlocked: int * ptr[FILE] -> int = 'putc_unlocked($a)';
  fun getc_unlocked: ptr[FILE] -> int = 'getc_unlocked($a)';
  fun getchar: 1 -> int = 'getchar($a)';
  fun fflush_unlocked: ptr[FILE] -> int = 'fflush_unlocked($a)';
  fun putc: int * ptr[FILE] -> int = 'putc($a)';
  fun vsnprintf: ptr[char] * size * cptr[char] * __gnuc_va_list -> int = 'vsnprintf($a)';
  fun putchar: int -> int = 'putchar($a)';
  fun vsprintf: ptr[char] * cptr[char] * __gnuc_va_list -> int = 'vsprintf($a)';
  fun getc: ptr[FILE] -> int = 'getc($a)';
  fun fputc_unlocked: int * ptr[FILE] -> int = 'fputc_unlocked($a)';
  fun fwrite: caddress * size * size * ptr[FILE] -> size = 'fwrite($a)';
  fun scanf[t]: t -> int = 'scanf($a)';
  
  //STRUCT and UNION FIELDS
  fun get__cur_column: __FILE -> ushort = '$1._cur_column';
  fun get__IO_write_end: __FILE -> ptr[char] = '$1._IO_write_end';
  fun get__IO_buf_end: __FILE -> ptr[char] = '$1._IO_buf_end';
  fun get__fileno: __FILE -> int = '$1._fileno';
  fun get__IO_read_ptr: __FILE -> ptr[char] = '$1._IO_read_ptr';
  fun get__IO_buf_base: __FILE -> ptr[char] = '$1._IO_buf_base';
  fun get__IO_backup_base: __FILE -> ptr[char] = '$1._IO_backup_base';
  fun get__IO_read_base: __FILE -> ptr[char] = '$1._IO_read_base';
  fun get__IO_write_base: __FILE -> ptr[char] = '$1._IO_write_base';
  fun get__markers: __FILE -> ptr[_struct__IO_marker] = '$1._markers';
  fun get__IO_save_end: __FILE -> ptr[char] = '$1._IO_save_end';
  fun get__IO_write_ptr: __FILE -> ptr[char] = '$1._IO_write_ptr';
  fun get__old_offset: __FILE -> __off_t = '$1._old_offset';
  fun get__IO_save_base: __FILE -> ptr[char] = '$1._IO_save_base';
  fun get__chain: __FILE -> ptr[_struct__IO_FILE] = '$1._chain';
  fun get__flags: __FILE -> int = '$1._flags';
  fun get__vtable_offset: __FILE -> tiny = '$1._vtable_offset';
  fun get__mode: __FILE -> int = '$1._mode';
  fun get__shortbuf: __FILE -> ptr[char] = '$1._shortbuf';
  fun get__flags2: __FILE -> int = '$1._flags2';
  fun get__lock: __FILE -> ptr[_IO_lock_t] = '$1._lock';
  fun get__unused2: __FILE -> ptr[char] = '$1._unused2';
  fun get__offset: __FILE -> __off64_t = '$1._offset';
  fun get__IO_read_end: __FILE -> ptr[char] = '$1._IO_read_end';
}
</PRE></CODE></P>
</BODY>
</HTML>


@select(tangler('www/coding.html','data'))
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
@tangle("<TITLE>Felix Developers Info</TITLE>")
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8">
</HEAD>
<BODY>
<H1>Coding Guidelines</H1>
<H2>Media</H2>
<P>Felix currently <EM>requires</EM> all original sources
to be encapsulated in interscript text files.
</P><P>
Files must end in either:
<OL>
<LI>pak for top level packages</LI>
<LI>ipk for subcomponents of those packages</LI>
</OL>
</P><P>If you have a large data file, or one
which is an authoritative externally sourced work
such as an academic paper or standards data,
a special exemption may be made to avoid gratuitious 
wrapping and tangling, whilst alleviating the customer
of the need to separately download it.
</P>
<H2>Character set</H2>
<P>
Felix uses UTF-8 encoding of ISO10646/Unicode.
Try to restrict use to the code points 
U+20 to U+7E plus U+10 (newline), the graphic
characters of ASCII plus newline and space.
</P><P>
Although interscript can handle diverse encodings,
we do not use this facility. Note in particular
<EM>Latin-1 encoded text is not supported</EM>.
</P><P>
Special exception: data files deliberately using
foreign encodings and character sets for the purpose
of testing codecs. Note: a few Latin-1 encoded characters
do appear occasionally in harmless places such as 
people's names. 
</P><P>
<EM>Tabs are not permitted in original sources</EM>,
and they may not be generated with a single
exception: makefiles, because they're required.
</P>
<H2>Code layout guidelines</H2>
<P>
The standard shiftwidth is 2.
Indentation must be systematic.
Extra indentation is not allowed.
Exactly one space should be used in flowing text.
The exact indentation style is up to the individual developer.
</P><P>
Text should be constrained to 65 columns where possible.
Extremely long lines are not allowed in original source (however
it is OK to generate long lines). All literate
programmed code should be preformatted for book pages,
which have very narrow width.
</P>
</BODY>
</HTML>

