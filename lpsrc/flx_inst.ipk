@head(1,"Elide unused entries")
Name binding pass 2.

@h = tangler("src/flx_inst.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_typing
open Flx_mtypes2

val instantiate:
  sym_state_t ->
  fully_bound_symbol_table_t ->
  bid_t ->
  biface_t list ->
  unit

@h = tangler("src/flx_inst.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_mbind
open Flx_srcref
open List
open Flx_unify
open Flx_treg
open Flx_exceptions
open Flx_maps

let add_inst syms ref_insts1 (i,ts) =
  let x = i, map reduce_type ts in
  let has_variables = 
    fold_left
    (fun truth t -> truth || var_occurs t)
    false
    ts
  in
  if has_variables then
  failwith
  (
    "Attempt to register instance " ^ si i ^ "[" ^
    catmap ", " (sbt syms.dfns) ts ^
    "] with type variable in a subscript"
  )
  ;
  if not (FunInstSet.mem x !ref_insts1)
  && not (Hashtbl.mem syms.instances x)
  then ref_insts1 := FunInstSet.add x !ref_insts1

let rec process_expr syms bbdfns ref_insts1 hvarmap sr ((e,t) as be) =
  (*
  print_endline ("Process expr " ^ sbe syms.dfns be ^ " .. raw type " ^ sbt syms.dfns t);
  print_endline (" .. instantiated type " ^ string_of_btypecode syms.dfns (varmap_subst hvarmap t));
  *)
  let ue e = process_expr syms bbdfns ref_insts1 hvarmap sr e in
  let ui i ts = add_inst syms ref_insts1 (i,ts) in
  let ut t = register_type_r ui syms bbdfns [] sr (reduce_type t) in
  let vs t = varmap_subst hvarmap t in
  ut (vs t)
  ;
  begin match e with
  | `BEXPR_deref e
  | `BEXPR_get_n (_,e)
  | `BEXPR_match_case (_,e)
  | `BEXPR_case_arg (_,e)
    -> ue e
    
  | `BEXPR_apply_prim (index,ts,a)
  | `BEXPR_apply_direct (index,ts,a)
  | `BEXPR_apply_stack (index,ts,a)
  | `BEXPR_apply ((`BEXPR_closure (index,ts),_),a) ->
    let id,parent,sr2,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[process_expr(apply instance)] Can't find index " ^ si index)
    in
    begin match entry with
    (* function type not needed for direct call *)
    | `BBDCL_fun _ 
    | `BBDCL_function _ -> 
      let ts = map vs ts in
      ui index ts; ue a
    (* the remaining cases are struct/variant type constructors,
    which probably don't need types either .. fix me!
    *)
    (* | _ -> ue f; ue a *)
    | _ -> ui index ts; ue a
    end
    
  | `BEXPR_apply (e1,e2) -> 
    ue e1; ue e2

  | `BEXPR_tuple es -> iter ue es 
     
  | `BEXPR_coercion (e,t) -> ue e; ut (vs t)
     
  | `BEXPR_case (_,t) -> ut (vs t)

  | `BEXPR_ref (i,ts) 
  | `BEXPR_name (i,ts)
  | `BEXPR_closure (i,ts)
    -> 
    (* substitute out display variables *)
    let ts = map vs ts in
    ui i ts; iter ut ts

  | `BEXPR_literal _ -> ()
  | `BEXPR_expr (_,t) -> ut t
  end

and process_exe syms bbdfns ref_insts1 ts hvarmap (exe:bexe_t) =
  let ue sr e = process_expr syms bbdfns ref_insts1 hvarmap sr e in
  let uis i ts = add_inst syms ref_insts1 (i,ts) in
  let ui i = uis i ts in
  (*
  print_endline ("processing exe " ^ string_of_bexe syms.dfns 0 exe);
  *)
  match exe with
  | `BEXE_call_prim (sr,i,ts,e2) 
  | `BEXE_call_direct (sr,i,ts,e2) 
  | `BEXE_jump_direct (sr,i,ts,e2) 
  | `BEXE_call_stack (sr,i,ts,e2) 
    -> 
    let ut t = register_type_r uis syms bbdfns [] sr (reduce_type t) in
    let vs t = varmap_subst hvarmap t in
    let ts = map vs ts in
    iter ut ts;
    add_inst syms ref_insts1 (i,ts);
    ue sr e2

  | `BEXE_call (sr,e1,e2) 
  | `BEXE_jump (sr,e1,e2) 
    -> ue sr e1; ue sr e2
    
  | `BEXE_loop (sr,_,e)
  | `BEXE_ifgoto (sr,e,_)
  | `BEXE_ifnotgoto (sr,e,_)
  | `BEXE_fun_return (sr,e) 
    -> ue sr e

  (* this is wrong: initialisation is not use .. *)
  | `BEXE_init (sr,i,e) -> ui i; ue sr e
  | `BEXE_assign (sr,e1,e2) -> ue sr e1; ue sr e2

  | `BEXE_read (sr,i) -> ui i 

  | `BEXE_regmatch (sr,e,(_,_,h,_)) -> 
    ue sr e;
    Hashtbl.iter
    (fun _ e -> ue sr e)
    h

  | `BEXE_reglex (sr,p1,p2,(_,_,h,_)) -> 
    ue sr p1; 
    ue sr  p2;
    Hashtbl.iter
    (fun _ e -> ue sr e)
    h

  | `BEXE_label _
  | `BEXE_halt _
  | `BEXE_goto _
  | `BEXE_code _
  | `BEXE_nonreturn_code _
  | `BEXE_comment _
  | `BEXE_nop _
  | `BEXE_proc_return _
    -> ()

and process_exes syms bbdfns ref_insts1 ts hvarmap exes = 
  iter (process_exe syms bbdfns ref_insts1 ts hvarmap) exes

and process_function syms bbdfns hvarmap ref_insts1 index sr argtypes ret exes ts =
  process_exes syms bbdfns ref_insts1 ts hvarmap exes ;

and process_inst syms bbdfns ref_insts1 i ts inst =
  let uis i ts = add_inst syms ref_insts1 (i,ts) in
  let ui i = uis i ts in
  let do_reqs vs reqs = iter (fun (i,ts)-> uis i( map vs ts)) reqs in
  let id,parent,sr,entry = 
    try Hashtbl.find bbdfns i 
    with Not_found -> failwith ("[process_inst] Can't find index " ^ si i)
  in 
  let rtr t = register_type_r uis syms bbdfns [] sr (reduce_type t) in
  let rtnr t = register_type_nr syms t in
  if syms.compiler_options.print_flag then
  print_endline ("//Instance "^si inst ^ "="^id^"<" ^ si i ^ ">[" ^ catmap "," (string_of_btypecode syms.dfns) ts ^ "]");
  match entry with
  | `BBDCL_function (props,vs,ps,ret,exes) -> 
    let argtypes = map (fun x -> snd (snd x)) ps in
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    process_function syms bbdfns hvarmap ref_insts1 i sr argtypes ret exes ts
 
  | `BBDCL_procedure (props,vs,ps, exes) ->
    let argtypes = map (fun x -> snd (snd x)) ps in
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    process_function syms bbdfns hvarmap ref_insts1 i sr argtypes `BTYP_void exes ts

  | `BBDCL_union (vs,ps)
  | `BBDCL_struct (vs,ps)
  | `BBDCL_cstruct (vs,ps)
    ->
    let argtypes = map snd ps in
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let tss = map (varmap_subst hvarmap) argtypes in
    iter rtr tss;
    rtnr (`BTYP_inst (i,ts))

  | `BBDCL_val (vs,t)
  | `BBDCL_var (vs,t)
    ->
    (* assert (length vs = length ts); *)
    if length vs <> length ts
    then syserr sr
    (
      "ts/vs mismatch instantiating variable " ^ id ^ "<"^si i^">, inst "^si inst^": vs = [" ^
      catmap ";" (fun (s,i)-> s ^"<"^si i^">") vs ^ "], " ^
      "ts = [" ^
      catmap ";" (fun t->sbt syms.dfns t) ts ^ "]"
    );
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let t = varmap_subst hvarmap t in
    rtr t
 
  | `BBDCL_const (vs,t,_,reqs) ->
    assert (length vs = length ts);
    (*
    if length vs <> length ts
    then syserr sr
    (
      "ts/vs mismatch index "^si i^", inst "^si inst^": vs = [" ^
      catmap ";" (fun (s,i)-> s ^"<"^si i^">") vs ^ "], " ^
      "ts = [" ^
      catmap ";" (fun t->sbt syms.dfns t) ts ^ "]"
    );
    *)
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let t = varmap_subst hvarmap t in
    rtr t;
    let vs t = varmap_subst hvarmap t in
    do_reqs vs reqs
 
  (* shortcut -- header and body can only require other header and body *)
  | `BBDCL_header (vs,s,reqs)
  | `BBDCL_body (vs,s,reqs)
    -> 
    (*
    print_endline ("Handling requirements of header/body " ^ s);
    *)
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let vs t = varmap_subst hvarmap t in
    do_reqs vs reqs


  | `BBDCL_fun (vs,argtypes,ret,_,reqs) ->
    (*
    print_endline ("Handling requirements of fun " ^ id);
    *)
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let vs t = varmap_subst hvarmap t in
    do_reqs vs reqs;
    process_function syms bbdfns hvarmap ref_insts1 i sr argtypes ret [] ts

  | `BBDCL_proc (vs,argtypes,_,reqs) ->
    (*
    print_endline ("Handling requirements of proc " ^ id);
    *)
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let vs t = varmap_subst hvarmap t in
    do_reqs vs reqs;
    process_function syms bbdfns hvarmap ref_insts1 i sr argtypes `BTYP_void [] ts

  | `BBDCL_abs (vs,_,_,reqs)
    -> 
    assert (length vs = length ts);
    let vars = map2 (fun (s,i) t -> i,t) vs ts in
    let hvarmap = hashtable_of_list vars in
    let vs t = varmap_subst hvarmap t in
    do_reqs vs reqs
(* 
  This routine creates the instance tables.
  There are 2 tables: instance types and function types (including procs)

  The type registry holds the types used.
  The instance registry holds a pair:
  (index, types)
  where index is the function or procedure index,
  and types is a list of types to instantiated it.

  The algorithm starts with a list of roots, being
  the top level init routine and any exported functions.
  These must be non-generic.

  It puts these into a set of functions to be examined.
  Then it begins examining the set by chosing one function
  and moving it to the 'examined' set.

  It registers the function type, and then
  examines the body.

  In the process of examining the body,
  every function or procedure call is examined.

  The function being called is added to the
  to be examined list with the calling type arguments.
  Note that these type arguments may include type variables
  which have to be replaced by their instances which are
  passed to the examination routine.

  The process continues until there are no unexamined
  functions left. The effect is to instantiate every used
  type and function.
*)

let instantiate syms bbdfns (root:bid_t) (bifaces:biface_t list) =
  (* empty instantiation registry *)
  let insts1 = ref FunInstSet.empty in

  begin 
    (* append routine to add an instance *)
    let add_cand i ts = insts1 := FunInstSet.add (i,ts) !insts1 in

    (* add the root *)
    add_cand root [];

    (* add exported functions, and register exported types *)
    let ui i ts = add_inst syms insts1 (i,ts) in
    iter 
    (function 
      | `BIFACE_export_fun (_,x,_) -> add_cand x []
      | `BIFACE_export_type (sr,t,_) ->
        register_type_r ui syms bbdfns [] sr t
    ) 
    bifaces
  end
  ;

  let add_instance i ts =
    let n = !(syms.counter) in
    incr (syms.counter);
    Hashtbl.add syms.instances (i,ts) n;
    n
  in

  while not (FunInstSet.is_empty !insts1) do
    let (index,vars) as x = FunInstSet.choose !insts1 in
    insts1 := FunInstSet.remove x !insts1;
    let inst = add_instance index vars in
    process_inst syms bbdfns insts1 index vars inst
  done


(* BUG!!!!! Abstract type requirements aren't handled!! *)

