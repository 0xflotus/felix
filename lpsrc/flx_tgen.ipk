@h = tangler('src/flx_tgen.mli')
@select(h)
open Flx_types
val collect_types :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  unit

val gen_types :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

val gen_type_names :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

@h = tangler('src/flx_tgen.ml')
@select(h)
open Flx_types
open Flx_print
open Flx_typing
open Flx_srcref
open Flx_unify
open Flx_name
open Flx_csubst

@head(2,'The type registry')
Flx supports algebraic type expressions. For some of these,
we need to construct a C++ class type. To ensure the same
name is provided for each such class, we use a registry
which maps the (bound) type expression to an integer.
@p()
The routine register_type_rn is a non-recursive registration
procedure.
@p()
The routine register_type_r registers types recursively.
The 'exclude' argument is a list of types which should
not be registered, this is used to break potential
infinite recursions. Note carefully that components
are always registered before the type, so that they'll
be defined before they're used. There two exceptions:
for a pointer an incomplete type is sufficient,
and sometimes necessary to break type recursion;
and, unions may be recursive, but are represented
by pointers anyhow.
@p()
Note that a function may accept an argument tuple
one of whose arguments is a pointer to a function
of the same type.
@p()
Note that the types of implicitly declared tuples
will be caught here, since the only thing you can
do with a tuple is make it the argument of a function.

@select(h)
let register_type_nr syms t =
  match t with
  | `BTYP_fix _ 
  | `BTYP_tuple []
    -> ()
  | _ 
    ->
    if not (Hashtbl.mem syms.registry t)
    then
      let n = !(syms.counter) in
      incr syms.counter;
      Hashtbl.add syms.registry t n

let rec register_type_r syms bbdfns exclude t =
  (*
  print_endline (string_of_btypecode dfns t);
  *)
  let t = lower t in
  if not (List.mem t exclude) then
  let rr t' = register_type_r 
    syms bbdfns (t :: exclude) t'
  in
  let rnr t = register_type_nr syms t in
  match unfold t with
  | `BTYP_void -> ()
  | `BTYP_fix _ -> ()
  | `BTYP_var _ -> failwith "Attempt to register type variable"
  | `BTYP_function (ps,ret) -> rr ps; rr ret; rnr t
  | `BTYP_tuple ps -> List.iter rr ps; rnr t
  | `BTYP_sum ps -> List.iter rr ps; rnr t
  | `BTYP_pointer t' -> rr t' 
    (* We don't register pointer types: use _ref_ template! *)
  | `BTYP_binding (src,dst) -> rr dst
  | `BTYP_inst (i,ts)->
     List.iter rr ts;
     rnr t

  | `BTYP_name index ->
    let id, parent, entry = 
      try Hashtbl.find bbdfns index 
      with Not_found -> 
        let id,sr,parent,entry= Hashtbl.find syms.dfns index in
        failwith 
        (
          "register_type_r Can't find " ^ 
          id ^ "[" ^ string_of_int index ^ "]" ^
          " in fully bound symbol table: " ^
          short_string_of_src sr
        )
    in
    begin match entry with
    | `BBDCL_union cs -> 
      List.iter rr (List.map snd cs);      (* components *)
      rnr t                                (* the union type *)

    | `BBDCL_struct cs -> 
      let argt = typeoflist (List.map snd cs) in
      List.iter rr (List.map snd cs);      (* components *)
      rnr argt;                            (* argument tuple *)
      rnr t;                               (* the struct type *)
      rnr (`BTYP_function (argt,t))         (* constructor *)

    | `BBDCL_abs (vs,ct) -> 
      ( match vs with 
      | [] -> rnr t 
      | _ -> failwith "[register_type_r] Can't register template"
      )
      (*
      failwith 
      (
        "[register_type_r] expected type declaration, got type parameter " ^
        string_of_bbdcl dfns entry index
      )
      *)
    | _ -> 
      failwith 
      (
        "[register_type_r] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> 
    failwith 
    (
      "Unexpected kind in register type: " ^ 
      string_of_btypecode syms.dfns t
    )

@doc()
We now need to collect the types required for declarations.
In order to sequence the C++ declarations according to
dependecies, our recursive analysis takes care only
to assign an integer to a type when all type on which
it depends have been processed. 
@p()
Note that implicitly declared tuple types should
still get registered. The reason is that they can't
be used unless the type is an argument of some 
function or procedure, which we should pick up here.
@select(h)

let collect_types syms bbdfns = 
  let registry = syms.registry
  and dfns = syms.dfns 
  and counter = syms.counter
  in
  let rr t = register_type_r syms bbdfns [] t in
  let rnr t = register_type_nr syms t in
  Hashtbl.iter
  begin fun index (id,parent,bbdcl) -> 
    (* if proper_descendant dfns parent
    then 
    *)
    begin
      (*
      print_endline (
        "Collecting BBDCL " ^ id ^ "<" ^ string_of_int index ^ 
        ">, parent="^
        match parent with 
        | Some i ->string_of_int i
        | None -> "None"
      );
      print_endline ("=======>  " ^ string_of_bbdcl syms.dfns bbdcl index);
      *)
      match bbdcl with
      | `BBDCL_abs (vs,_) -> 
        if List.length vs = 0
        then rnr (`BTYP_name index)
        (* ignore generic types *)

      | `BBDCL_function (ps,ret,_,_) ->
        let a = typeoflist (List.map snd ps) in
        rr (`BTYP_function (a,ret))

      | `BBDCL_fun (vs,ps,ret,_) ->
        if List.length vs = 0
        then
          let a = typeoflist ps in
          rr (`BTYP_function (a,ret))
        (* ignore generic functions *)

      | `BBDCL_procedure (ps,_,_) ->
        let a = typeoflist (List.map snd ps) in
        rr (`BTYP_function (a,`BTYP_void))

      | `BBDCL_proc (vs,ps,_) ->
        if List.length vs = 0
        then
          let a = typeoflist ps in
          rr (`BTYP_function (a,`BTYP_void))
        (* ignore generic procedures *)

      | `BBDCL_val t
      | `BBDCL_var t
      | `BBDCL_const (t,_) -> rr t

      | `BBDCL_union _
      | `BBDCL_struct _ -> rr (`BTYP_name index)

      | `BBDCL_body _ -> ()
      | `BBDCL_header _ -> ()
    end
  end
  bbdfns 
  ;
  Hashtbl.iter
  (fun t _ -> rr t)
  syms.instantiated_types

@doc()
Now some code to generate the bases, given the
hashtable. We also mangle c++ abstract type names.
@select(h)
let all_voids ls =    
    List.fold_left 
    (fun acc t -> acc && (t = `BTYP_void))
    true ls

let all_units ls =    
    List.fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls ->  all_units ls
  | _ -> false

let gen_type_name syms bbdfns (index,typ) =
  let tn t = cpp_classname syms bbdfns t in
  match typ with
  | `BTYP_fix i -> ""
  | `BTYP_var i -> failwith "[gen_type_name] Can't gen name of type variable"
  | `BTYP_binding _ -> failwith "[gen_type_name] Unexpected binding type"
  | `BTYP_function _ ->
    let name = tn typ in
    "struct " ^ name ^ ";\n"

  | `BTYP_tuple [] -> ""
  | `BTYP_tuple ts ->
    let name = tn typ in
    "struct " ^ name ^ ";\n"

  | `BTYP_sum ts ->
    if is_unitsum typ
    then
      "typedef int " ^ tn typ ^ ";\n"
    else
      "typedef _uctor_ " ^ tn typ ^ ";\n"

  | `BTYP_void -> ""
  | `BTYP_pointer t -> "//Pointer by template"

  | `BTYP_inst (i,vs) ->
    let sr,id,parent,dcl = Hashtbl.find syms.dfns i in
    let ct = 
      match dcl with
      | `SYMDEF_dcl (`DCL_abs (_,ct)) -> ct
      | _ -> failwith "Expected primitive type"
    in
    let name = tn typ in
    let s = csubst syms bbdfns ct [] [] `BTYP_void vs in
    "typedef " ^ s ^ " " ^ name ^ ";\n"

  | `BTYP_name index ->
    let name = tn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index
      with _ -> failwith ("[gen_type_name] can't find type" ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_struct cs ->
      "struct " ^ name ^ ";\n"

    | `BBDCL_union ls -> 
      if all_voids (List.map snd ls)
      then
        "typedef int " ^ tn typ ^ ";\n"
      else
        "typedef _uctor_ " ^ tn typ ^ ";\n"

    | `BBDCL_abs (vs,ct) -> 
      (match vs with
      | [] -> "typedef " ^ ct ^ " " ^ tn typ ^ ";\n" 
      | _ -> "[gen_type_name] can't name template"
      )
    | _ -> 
      failwith 
      (
        "[gen_type_name] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> failwith "Unexpected metatype in gen_type_name"

let gen_type syms bbdfns (index,typ) =
  (*
  print_endline (
    "GENERATING TYPE " ^
    string_of_int index^": " ^ 
    string_of_btypecode dfns typ
  );
  *)
  "//TYPE "^string_of_int index^": " ^ string_of_btypecode syms.dfns typ ^ "\n"^
  let tn t = cpp_typename syms bbdfns t in
  let cn t = cpp_classname syms bbdfns t in
  match unfold typ with

  | `BTYP_var _ -> failwith "[gen_type] can't gen type variable"
  | `BTYP_fix _ -> failwith "[gen_type] can't gen type fixpoint"
  | `BTYP_binding _ -> failwith ("gen_type] Unexpected binding type")

  (* PROCEDURE *)
  | `BTYP_function (a,`BTYP_void) ->
    let name = cn typ  
    and argtype = tn a
    in
    "struct " ^ name ^
    ": continuation_t {\n" ^
    (if a <> `BTYP_tuple [] 
    then
    "  virtual continuation_t *call(continuation_t *, "^argtype^" const &)=0;\n"
    else
    "  virtual continuation_t *call(continuation_t *)=0;\n"
    ) ^
    "  virtual continuation_t *resume()=0;\n"  ^
    "};\n"

  (* FUNCTION *)
  | `BTYP_function (a,r) ->
    let name = cn typ  
    and argtype = tn a
    and rettype = tn r
    in
    "struct " ^ name ^ " {\n" ^
    "  virtual "^rettype^" apply("^
    (if a = `BTYP_tuple []
    then ""
    else argtype^" const &") ^
    ")=0;\n"  ^
    "};\n"

  | `BTYP_sum _ -> "" (* union typedef *)

  | `BTYP_tuple [] -> "" 
  | `BTYP_tuple ts ->
    let components = ref [] in
    let counter = ref 0 in
    List.iter 
    (fun t -> 
      components := !components @ [!counter, t]; 
      incr counter
    )
    ts
    ;
    let mem_dcls = String.concat "" (List.map 
    (fun (i,t) ->
      "  " ^ tn t ^ " " ^
      "mem_" ^ string_of_int i ^ ";\n"
    )
    !components)

    and param_dcls =  String.concat ",\n" (List.map
    (fun (i,t) -> "    " ^ tn t ^ " arg_" ^ string_of_int i)
    !components) ^ "\n"
    
    and ctor_inits = String.concat ",\n" (List.map
    (fun (i,t) -> "    mem_" ^ string_of_int i ^ "(arg_" ^ string_of_int i ^ ")")
    !components) ^ "\n"
    in 
    
    let name = cn typ in
    let ctor = 
      "  " ^ name ^ "\n" ^
      "  (\n" ^
      param_dcls ^
      "  ) :\n" ^
      ctor_inits ^
      "  {}\n"
    in
    "struct " ^ name ^ " {\n" ^
    mem_dcls^
    "  " ^ name ^ "(){}\n"^
    ctor ^
    "};\n"

  | `BTYP_void -> ""
  | `BTYP_pointer t -> failwith "Generate pointer type: should use template"
    (*
    let name = tn typ in
    let data_type = tn t in
    "struct " ^ name ^ " {\n" ^
    "  void *frame;\n" ^
    "  "^data_type^" *data;\n" ^
    "  " ^ name ^ "(){}\n" ^
    "  " ^ name ^ "(" ^ data_type ^ " *d, void *f) : data(d), frame(f) {}\n" ^
    "};\n"
    *)

  | `BTYP_inst _ -> ""

  | `BTYP_name index ->
    let name = tn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_type] can't find index " ^ string_of_int index)
    in
    begin match entry with
    | `BBDCL_struct cs ->
      let ctor = 
        let equiv_tuple_type = typeoflist (List.map snd cs) in
        match List.length cs with
        | 0 -> "" (* just use default ctor *)
        | 1 -> 
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg): " ^
          fst (List.hd cs) ^ "(_arg) {}\n" 
        | _ ->
          let ctor_inits = ref [] in 
          let counter = ref 0 in
          List.iter 
          (fun (name,typ) -> 
            let n = !counter in incr counter; 
            ctor_inits :=
              (name ^ "(_arg.mem_"^string_of_int n ^")")
              :: !ctor_inits
          )
          cs
          ;
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg) :\n" ^
          "    " ^ String.concat ",\n    " (List.rev !ctor_inits) ^
          "\n  {}\n" 
      in
      "struct " ^ name ^ "{\n" ^
      "  "^ name ^ "(){}\n" ^
      ctor ^
      String.concat "" 
      (
        List.map 
        (
          fun (name,typ) -> "  " ^ tn typ ^ 
          " " ^
          name ^ ";\n"
        )
        cs
      ) ^
      "};\n"

    | `BBDCL_union _ -> "" (* covered by prior typedef of _uctor_ or int *)
    | `BBDCL_abs (vs,ct) -> ""
    | _ -> 
      failwith 
      (
        "[gen_typ] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> failwith "Unexpected metatype in gen_type"

let gen_type_names syms bbdfns ts = 
  (* print_endline "GENERATING TYPE NAMES"; *)
  let s = Buffer.create 100 in
  List.iter 
  (fun t -> Buffer.add_string s (gen_type_name syms bbdfns t))
  ts;
  Buffer.contents s

let gen_types syms bbdfns ts = 
  (* print_endline "GENERATING TYPES"; *)
  let s = Buffer.create 100 in
  List.iter 
  (fun t -> Buffer.add_string s (gen_type syms bbdfns t))
  ts;
  Buffer.contents s

