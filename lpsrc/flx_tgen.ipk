@h = tangler('src/flx_tgen.mli')
@select(h)
open Flx_types
val gen_tuples:
  sym_state_t -> string

val collect_types :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  unit

val gen_types :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

val gen_type_names :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

val template_header:
  string list -> string -> string

@h = tangler('src/flx_tgen.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_typing
open Flx_srcref
open Flx_unify
open Flx_name
open Flx_csubst
open List

@head(2,'The type registry')
Flx supports algebraic type expressions. For some of these,
we need to construct a C++ class type. To ensure the same
name is provided for each such class, we use a registry
which maps the (bound) type expression to an integer.
@p()
The routine register_type_rn is a non-recursive registration
procedure.
@p()
The routine register_type_r registers types recursively.
The 'exclude' argument is a list of types which should
not be registered, this is used to break potential
infinite recursions. Note carefully that components
are always registered before the type, so that they'll
be defined before they're used. There two exceptions:
for a pointer an incomplete type is sufficient,
and sometimes necessary to break type recursion;
and, unions may be recursive, but are represented
by pointers anyhow.
@p()
Note that a function may accept an argument tuple
one of whose arguments is a pointer to a function
of the same type.
@p()
Note that the types of implicitly declared tuples
will be caught here, since the only thing you can
do with a tuple is make it the argument of a function.

@select(h)
let register_type_nr syms t =
  match t with
  | `BTYP_fix _ 
  | `BTYP_tuple []
    -> ()
  | _ 
    ->
    let _, t = normalise_type t in
    if not (Hashtbl.mem syms.registry t)
    then
      let n = !(syms.counter) in
      incr syms.counter;
      Hashtbl.add syms.registry t n

let rec register_type_r syms bbdfns exclude t =
  (*
  print_endline (string_of_btypecode dfns t);
  *)
  let t = lower t in
  if not (mem t exclude) then
  let rr t' = register_type_r 
    syms bbdfns (t :: exclude) t'
  in
  let rnr t = register_type_nr syms t in
  let t' = unfold t in
  match t' with
  | `BTYP_void -> ()
  | `BTYP_fix _ -> ()
  | `BTYP_var _ -> () (* failwith "Attempt to register type variable" *)
  | `BTYP_function (ps,ret) -> rr ps; rr ret; rnr t
  | `BTYP_tuple ps -> iter rr ps; rnr t
  | `BTYP_sum ps -> iter rr ps; rnr t
  | `BTYP_pointer t' -> rr t' 

    (* We don't register pointer types: use _ref_ template! *)
  | `BTYP_binding (src,dst) -> rr dst
  | `BTYP_inst (i,ts)->
     iter rr ts;
     rnr t

  | `BTYP_name index ->
    let id, parent, entry = 
      try Hashtbl.find bbdfns index 
      with Not_found -> 
        let id,sr,parent,entry= Hashtbl.find syms.dfns index in
        failwith 
        (
          "register_type_r Can't find " ^ 
          id ^ "[" ^ si index ^ "]" ^
          " in fully bound symbol table: " ^
          short_string_of_src sr
        )
    in
    begin match entry with
    | `BBDCL_union cs -> 
      iter rr (map snd cs);      (* components *)
      rnr t                                (* the union type *)

    | `BBDCL_struct cs -> 
      let argt = typeoflist (map snd cs) in
      iter rr (map snd cs);      (* components *)
      rnr argt;                            (* argument tuple *)
      rnr t;                               (* the struct type *)
      rnr (`BTYP_function (argt,t))         (* constructor *)

    | `BBDCL_abs (vs,ct) -> 
      ( match vs with 
      | [] -> rnr t 
      | _ -> failwith "[register_type_r] Can't register template"
      )
      (*
      failwith 
      (
        "[register_type_r] expected type declaration, got type parameter " ^
        string_of_bbdcl dfns entry index
      )
      *)
    | _ -> 
      failwith 
      (
        "[register_type_r] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> 
    failwith 
    (
      "Unexpected kind in register type: " ^ 
      string_of_btypecode syms.dfns t
    )

@doc()
We now need to collect the types required for declarations.
In order to sequence the C++ declarations according to
dependecies, our recursive analysis takes care only
to assign an integer to a type when all type on which
it depends have been processed. 
@p()
Note that implicitly declared tuple types should
still get registered. The reason is that they can't
be used unless the type is an argument of some 
function or procedure, which we should pick up here.
@select(h)

let collect_types syms bbdfns = 
  let registry = syms.registry
  and dfns = syms.dfns 
  and counter = syms.counter
  in
  let rr t = register_type_r syms bbdfns [] t in
  let rnr t = register_type_nr syms t in
  Hashtbl.iter
  begin fun index (id,parent,bbdcl) -> 
    (* if proper_descendant dfns parent
    then 
    *)
    begin
      (*
      print_endline (
        "Collecting BBDCL " ^ id ^ "<" ^ si index ^ 
        ">, parent="^
        match parent with 
        | Some i ->si i
        | None -> "None"
      );
      print_endline ("=======>  " ^ string_of_bbdcl syms.dfns bbdcl index);
      *)
      match bbdcl with
      | `BBDCL_abs (vs,_) -> 
        rnr (`BTYP_name index)

      | `BBDCL_function (vs, ps,ret,_,_) ->
        let a = typeoflist (map (fun x-> snd (snd x)) ps) in
        rr (`BTYP_function (a,ret))

      | `BBDCL_fun (vs,ps,ret,_) ->
        let a = typeoflist ps in
        rr (`BTYP_function (a,ret))

      | `BBDCL_procedure (vs,ps,_,_) ->
        let a = typeoflist (map (fun x->snd (snd x)) ps) in
        rr (`BTYP_function (a,`BTYP_void))

      | `BBDCL_proc (vs,ps,_) ->
        let a = typeoflist ps in
        rr (`BTYP_function (a,`BTYP_void))

      | `BBDCL_val t
      | `BBDCL_var t
      | `BBDCL_const (t,_) -> rr t

      | `BBDCL_union _
      | `BBDCL_struct _ -> rr (`BTYP_name index)

      | `BBDCL_body _ -> ()
      | `BBDCL_header _ -> ()
    end
  end
  bbdfns 
  ;
  Hashtbl.iter
  (fun t _ -> rr t)
  syms.instantiated_types

@doc()
Now some code to generate the bases, given the
hashtable. We also mangle c++ abstract type names.
@select(h)
let all_voids ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_void))
    true ls

let all_units ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls ->  all_units ls
  | _ -> false

(* makes string 'template<typename U, typename V .. >' *)
let template_header vars trailer = 
  if length vars = 0 then ""
  else 
    "template<" ^ 
    catmap ", "(fun x -> "typename " ^ x)  vars ^ 
    ">" ^ 
    trailer

let gen_tuple n =
  let name = "_tuple"^ si n in
  let vars = map (fun i-> "T" ^ si i) (nlist n) in
  template_header vars "\n"^
  "struct " ^ name ^ " {\n" ^
  catmap "" 
  (fun i -> "  T"^si i ^ " mem_" ^ si i ^ ";\n")
  (nlist n)
  ^
  "  " ^ name ^ "(" ^
  catmap ", " 
  (fun i -> "T"^si i ^ " a" ^ si i) 
  (nlist n) ^
  "):\n    " ^ 
   catmap ", " 
  (fun i -> "mem_"^si i ^ "(a" ^ si i^")") 
  (nlist n) ^
  "{}\n" ^
  "  " ^ name ^ "(){}\n" ^
  "};"


let find_max_tuple syms =
  let n = ref 0 in
  Hashtbl.iter
  (fun t _ -> 
    match t with 
    | `BTYP_tuple ts -> 
      let m = length ts in 
      if m > !n then n := m
    | _ -> ()
  )
  syms.registry
  ;
  !n

let gen_tuples syms =
  let b = Buffer.create 20000 in
  for i = 2 to find_max_tuple syms do
    Buffer.add_string b (gen_tuple i)
  done
  ;
  Buffer.contents b

(* this routine generates a typedef 
which names the type. If the type has
type variables, a class template is used.

This routine generates INCOMPLETE types for classes
to provide forward references that subsequent
complete type definitions can use.
*)

let gen_type_name syms bbdfns (index,typ) =
  let cn t = cpp_type_classname syms bbdfns t in
  let tn t = cpp_typename syms bbdfns t in
  let tni vs t = cpp_type_instance syms bbdfns t vs in
  let varmap,typ = normalise_type typ in
  let count = length varmap in
  let vars = map (fun i-> "T" ^ si i) (nlist count) in
  let template = template_header vars "\n  " in
  let descr = 
    "\n//"^(if count = 0 then "" else "GENERIC ")^
    "TYPE "^si index^": " ^ string_of_btypecode syms.dfns typ ^ "\n" 
  in
  match typ with
  | `BTYP_fix i -> ""
  | `BTYP_var i -> failwith "[gen_type_name] Can't gen name of type variable"
  | `BTYP_binding _ -> failwith "[gen_type_name] Unexpected binding type"
  | `BTYP_function _ ->
    descr ^
    let name = cn typ in
    template ^
    "struct " ^ name ^ ";\n"

  | `BTYP_tuple [] -> ""
  | `BTYP_tuple ts ->
    print_endline descr;
    descr ^
    let name = cn typ in
    let typedef = 
      "typedef _tuple" ^ si (length ts) ^
      template_args (map tn ts)
    in 
      if count = 0 then typedef ^ " " ^ name ^ ";\n"
      else template ^ "struct " ^ name ^ " { " ^ typedef ^ " t; };\n"


  | `BTYP_sum ts ->
    descr ^
    if is_unitsum typ
    then
      "typedef int " ^ tn typ ^ ";\n"
    else
      "typedef _uctor_ " ^ tn typ ^ ";\n"

  | `BTYP_void -> ""
  | `BTYP_pointer t -> ""

  | `BTYP_inst (i,vs) ->
    descr ^
    (* THIS ROUTINE WILL CHANGE TO USE TEMPLATES *)
    let sr,id,parent,dcl = Hashtbl.find syms.dfns i in
    let ct = 
      match dcl with
      | `SYMDEF_dcl (`DCL_abs (_,ct)) -> ct
      | _ -> failwith "[gen_type] Expected primitive type"
    in
    let name = tn typ in
    let dummy_ge = fun _ -> (assert false) in
    let s = csubst dummy_ge syms bbdfns ct [] [] `BTYP_void vs in
    "typedef " ^ s ^ " " ^ name ^ ";\n"

  | `BTYP_name index ->
    descr ^
    let name = cn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index
      with _ -> failwith ("[gen_type_name] can't find type" ^ si index)
    in
    begin match entry with
    | `BBDCL_struct cs ->
      "struct " ^ name ^ ";\n"

    | `BBDCL_union ls -> 
      if all_voids (map snd ls)
      then
        "typedef int " ^ tn typ ^ ";\n"
      else
        "typedef _uctor_ " ^ tn typ ^ ";\n"

    | `BBDCL_abs (vs,ct) -> 
      (match vs with
      | [] -> "typedef " ^ ct ^ " " ^ tn typ ^ ";\n" 
      | _ -> "[gen_type_name] can't name template"
      )
    | _ -> 
      failwith 
      (
        "[gen_type_name] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> failwith "Unexpected metatype in gen_type_name"

(* This routine generates complete types when needed *)
let gen_type syms bbdfns (index,typ) =
  print_endline (
    "GENERATING TYPE " ^
    si index^": " ^ 
    string_of_btypecode syms.dfns typ
  );
  let tn t = cpp_typename syms bbdfns t in
  let cn t = cpp_type_classname syms bbdfns t in
  let varmap,typ = normalise_type typ in
  let count = length varmap in
  let vars = map (fun i-> "T" ^ si i) (nlist count) in
  let template = template_header vars "\n" in
  let descr = 
    "\n//" ^ 
    (
      if count =0 then "" 
      else "GENERIC "
    )^
    "TYPE "^
    si index^
    ": " ^ 
    string_of_btypecode syms.dfns typ ^ 
    "\n" 
  in
  match unfold typ with
  | `BTYP_var _ -> failwith "[gen_type] can't gen type variable"
  | `BTYP_fix _ -> failwith "[gen_type] can't gen type fixpoint"
  | `BTYP_binding _ -> failwith ("gen_type] Unexpected binding type")

  (* PROCEDURE *)
  | `BTYP_function (a,`BTYP_void) ->
    descr ^
    let name = cn typ  
    and argtype = tn a
    in
    template ^ 
    "struct " ^ name ^
    ": con_t {\n" ^
    (if a <> `BTYP_tuple [] 
    then
    "  virtual con_t *call(con_t *, "^argtype^" const &)=0;\n"
    else
    "  virtual con_t *call(con_t *)=0;\n"
    ) ^
    "  virtual con_t *resume()=0;\n"  ^
    "};\n"

  (* FUNCTION *)
  | `BTYP_function (a,r) ->
    descr ^
    let name = cn typ  
    and argtype = tn a
    and rettype = tn r
    in
    template ^
    "struct " ^ name ^ " {\n" ^
    "  virtual "^rettype^" apply("^
    (if a = `BTYP_tuple []
    then ""
    else argtype^" const &") ^
    ")=0;\n"  ^
    "};\n"

  | `BTYP_sum _ -> "" (* union typedef *)

  | `BTYP_tuple [] -> "" 
  | `BTYP_tuple ts -> ""
  | `BTYP_void -> ""
  | `BTYP_pointer t -> failwith "Generate pointer type: should use template"
    (*
    let name = tn typ in
    let data_type = tn t in
    "struct " ^ name ^ " {\n" ^
    "  void *frame;\n" ^
    "  "^data_type^" *data;\n" ^
    "  " ^ name ^ "(){}\n" ^
    "  " ^ name ^ "(" ^ data_type ^ " *d, void *f) : data(d), frame(f) {}\n" ^
    "};\n"
    *)

  | `BTYP_inst _ -> ""

  | `BTYP_name index ->
    let name = tn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_type] can't find index " ^ si index)
    in
    begin match entry with
    | `BBDCL_struct cs ->
      descr ^
      let ctor = 
        let equiv_tuple_type = typeoflist (map snd cs) in
        match length cs with
        | 0 -> "" (* just use default ctor *)
        | 1 -> 
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg): " ^
          fst (hd cs) ^ "(_arg) {}\n" 
        | _ ->
          let ctor_inits = ref [] in 
          let counter = ref 0 in
         iter 
          (fun (name,typ) -> 
            let n = !counter in incr counter; 
            ctor_inits :=
              (name ^ "(_arg.mem_"^si n ^")")
              :: !ctor_inits
          )
          cs
          ;
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg) :\n" ^
          "    " ^ String.concat ",\n    " (rev !ctor_inits) ^
          "\n  {}\n" 
      in
      "struct " ^ name ^ "{\n" ^
      "  "^ name ^ "(){}\n" ^
      ctor ^
      String.concat "" 
      (
       map 
        (
          fun (name,typ) -> "  " ^ tn typ ^ 
          " " ^
          name ^ ";\n"
        )
        cs
      ) ^
      "};\n"

    | `BBDCL_union _ -> "" (* covered by prior typedef of _uctor_ or int *)
    | `BBDCL_abs (vs,ct) -> "" (* THIS WILL MAKE A TEMPLATE SOON *)
    | _ -> 
      failwith 
      (
        "[gen_typ] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> failwith "Unexpected metatype in gen_type"

let gen_type_names syms bbdfns ts = 
  (* print_endline "GENERATING TYPE NAMES"; *)
  let s = Buffer.create 100 in
 iter 
  (fun t -> 
    Buffer.add_string s (gen_type_name syms bbdfns t)
  )
  ts;
  Buffer.contents s

let gen_types syms bbdfns ts = 
  (* print_endline "GENERATING TYPES"; *)
  let s = Buffer.create 100 in
  iter 
  (fun t -> 
    Buffer.add_string s (gen_type syms bbdfns t)
  )
  ts;
  Buffer.contents s

