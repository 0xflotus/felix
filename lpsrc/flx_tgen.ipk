@head(1,'Type generator')
@h = tangler('src/flx_tgen.mli')
@select(h)
open Flx_types

val gen_types :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

val gen_type_names :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

@h = tangler('src/flx_tgen.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_typing
open Flx_srcref
open Flx_unify
open Flx_name
open Flx_csubst
open Flx_exceptions
open Flx_treg
open List

@doc()
Now some code to generate the bases, given the
hashtable. We also mangle c++ abstract type names.
@select(h)
let all_voids ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_void))
    true ls

let all_units ls =    
    fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls ->  all_units ls
  | _ -> false

let gen_tuple name typs =
  let n = length typs in
  "struct " ^ name ^ " {\n" ^
  catmap "" 
  (fun (t,i) -> "  "^t^ " mem_" ^ si i ^ ";\n")
  (combine typs (nlist n))
  ^
  "  " ^ name ^ "(" ^
  catmap ", " 
  (fun (t,i) -> t^" a" ^ si i) 
  (combine typs (nlist n))
  ^
  "):\n    " ^ 
   catmap ", " 
  (fun i -> "mem_"^si i ^ "(a" ^ si i^")") 
  (nlist n) ^
  "{}\n" ^
  "  " ^ name ^ "(){}\n" ^
  "};\n"

(* copy ctor, assignment, and destructor are generated; 
  we have to supply the pointer constructor and default
  constructor though. Note that it matters not if this
  type is sliced, since it's nothing more than a type
  correct wrapper for its base
*)
let gen_ref name typ =
  "struct " ^ name ^ ": _ref_ {\n" ^
  "  "^name^"(){}\n" ^
  "  "^name^"(void *f, " ^typ^" *d): _ref_(f,d){}\n" ^
  "  "^typ^" *operator->()const { return ("^typ^"*)data; }\n" ^
  "  "^typ^" &operator*() const { return *("^typ^"*)data; }\n" ^
  "};\n"

(* this routine generates a typedef (for primitives)
or struct declaration which names the type. 
*)

let gen_type_name syms bbdfns (index,typ) =
  (*
  print_endline (
    "GENERATING TYPE NAME " ^
    si index^": " ^ 
    string_of_btypecode syms.dfns typ
  );
  *)
  let cn t = cpp_type_classname syms t in
  let tn t = cpp_typename syms t in
  let descr = 
    "\n//TYPE "^si index^": " ^ string_of_btypecode syms.dfns typ ^ "\n" 
  in
  match unfold typ with
  | `BTYP_fix i -> ""
  | `BTYP_var i -> failwith "[gen_type_name] Can't gen name of type variable"
  | `BTYP_binding _ -> failwith "[gen_type_name] Unexpected binding type"

  | `BTYP_tuple [] -> "" (* unit *)

  | `BTYP_pointer _
  | `BTYP_tuple _
  | `BTYP_function _ ->
    descr ^
    let name = cn typ in
    "struct " ^ name ^ ";\n"


  | `BTYP_sum ts ->
    descr ^
    if is_unitsum typ
    then
      "typedef int " ^ tn typ ^ ";\n"
    else
      "typedef _uctor_ " ^ tn typ ^ ";\n"

  | `BTYP_void -> ""

  | `BTYP_inst (i,ts) -> 
    let id,parent,entry = 
      try Hashtbl.find bbdfns i
      with _ -> failwith ("[gen_type_name] can't find type" ^ si i)
    in
    begin match entry with
    | `BBDCL_abs (vs,ct) -> 
      let descr = 
        "\n//PRIMITIVE "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        string_of_btypecode syms.dfns typ ^ 
        "\n" 
      in
      let instance_name = cn typ in
      let tss = map tn ts in
      let instance = csubst ct [] [] "Error" "Error" tss in
      descr ^ "typedef " ^ instance ^ " " ^ instance_name ^ ";\n"

    | `BBDCL_struct _ ->
      let descr = 
        "\n//STRUCT "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        string_of_btypecode syms.dfns typ ^ 
        "\n" 
      in
      let name = cn typ in
      descr ^ "struct " ^ name ^ ";\n"

    | `BBDCL_union (vs,ls) ->
      let descr = 
        "\n//UNION "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        string_of_btypecode syms.dfns typ ^ 
        "\n" 
      in
      let name = cn typ in
      descr ^
      let lss = map snd ls in
      let lss = map (tsubst vs ts) lss in
      if all_voids lss
      then
        "typedef int " ^ name ^ ";\n"
      else
        descr ^
        "typedef _uctor_ " ^ name ^ ";\n"


    | _ -> 
      failwith 
      (
        "[gen_type_name] Expected definition "^si i^" to be generic primitive, got " ^ 
        string_of_bbdcl syms.dfns entry i ^
        " instance types [" ^
        catmap ", " tn ts ^
        "]"
      )
    end

  | `BTYP_name index ->
    let name = cn typ in
    print_endline 
    (
      "[gen_type_name] non generic type shouldn't happen now " ^ name ^ "<" ^ si index ^ ">"
    );
    let id,parent,entry = 
      try Hashtbl.find bbdfns index
      with _ -> failwith ("[gen_type_name] can't find type" ^ si index)
    in
    begin match entry with
    | `BBDCL_struct (vs,cs) ->
      descr ^
      "struct " ^ name ^ ";\n"

    | `BBDCL_union (vs,ls) -> 
      (* 
        all unions have the same type, 
        we cast on use to get the right type 
      *)
      if all_voids (map snd ls)
      then
        descr ^
        "typedef int " ^ tn typ ^ ";\n"
      else
        descr ^
        "typedef _uctor_ " ^ tn typ ^ ";\n"

    | `BBDCL_abs (vs,ct) -> 
      begin match vs with
      | [] -> descr ^ "typedef " ^ ct ^ " " ^ tn typ ^ ";\n" 
      | _ -> 
        let descr = 
          "\n//GENERIC PRIMITIVE TYPE " ^ 
          si index^": " ^ 
          string_of_btypecode syms.dfns typ ^ 
          "\n" 
        in
        let vs = map fst vs in
        let prim = csubst ct [] [] "Error" "Error" vs in
        descr ^ "  struct " ^ name ^ " {\n" ^
        "    typedef "^prim^" t;\n" ^
        "  };\n"
      end
    | _ -> 
      failwith 
      (
        "[gen_type_name] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> failwith "Unexpected metatype in gen_type_name"

(* This routine generates complete types when needed *)
let gen_type syms bbdfns (index,typ) =
  (*
  print_endline (
    "GENERATING TYPE " ^
    si index^": " ^ 
    string_of_btypecode syms.dfns typ
  );
  *)
  let tn t = cpp_typename syms t in
  let cn t = cpp_type_classname syms t in
  let descr = 
    "\n//TYPE "^ si index^ ": " ^ 
    string_of_btypecode syms.dfns typ ^ 
    "\n" 
  in
  match unfold typ with
  | `BTYP_var _ -> failwith "[gen_type] can't gen type variable"
  | `BTYP_fix _ -> failwith "[gen_type] can't gen type fixpoint"
  | `BTYP_binding _ -> failwith ("gen_type] Unexpected binding type")

  (* PROCEDURE *)
  | `BTYP_function (a,`BTYP_void) ->
    descr ^
    let name = cn typ  
    and argtype = tn a
    in
    "struct " ^ name ^
    ": con_t {\n" ^
    (if a <> `BTYP_tuple [] 
    then
    "  virtual con_t *call(con_t *, "^argtype^" const &)=0;\n"
    else
    "  virtual con_t *call(con_t *)=0;\n"
    ) ^
    "  virtual con_t *resume()=0;\n"  ^
    "};\n"

  (* FUNCTION *)
  | `BTYP_function (a,r) ->
    descr ^
    let name = cn typ  
    and argtype = tn a
    and rettype = tn r
    in
    "struct " ^ name ^ " {\n" ^
    "  virtual "^rettype^" apply("^
    (if a = `BTYP_tuple []
    then ""
    else argtype^" const &") ^
    ")=0;\n"  ^
    "};\n"

  | `BTYP_sum _ -> "" (* union typedef *)

  | `BTYP_tuple [] -> "" 
  | `BTYP_tuple ts -> 
     descr ^
     gen_tuple (cn typ) (map tn ts)
     
  | `BTYP_void -> ""
  | `BTYP_pointer t -> 
    let name = tn typ in
    let t = tn t in
    descr ^ gen_ref name t

  | `BTYP_inst (i,ts) ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns i
      with _ -> failwith ("[gen_type_name] can't find type" ^ si i)
    in
    begin match entry with
    | `BBDCL_abs (vs,ct) -> ""
    | `BBDCL_struct (vs,cts) ->
      let cts = map (fun (name,typ) -> name, tsubst vs ts typ) cts in
      let ctss = map (fun (name,typ) -> name, tn typ) cts in
      let descr = 
        "\n//GENERIC STRUCT "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        string_of_btypecode syms.dfns typ ^ 
        "\n" 
      in
      let name = cn typ in
      descr ^ "struct " ^ name ^ " {\n" 
      ^
      catmap ""
      (fun (name,typ) -> "  " ^ typ ^ " " ^ name ^ ";\n")
      ctss
      ^ 
      "  " ^ name ^ "(){}\n" ^
      "  " ^ name ^ "(" 
      ^
      catmap ", "
      (fun (name,typ) -> typ ^ " _a_" ^ name )
      ctss
      ^
      ")\n" ^
      "    : " 
      ^
      catmap ", "
      (fun (name,_) -> name ^"(_a_" ^ name ^ ")")
      ctss
      ^
      "  {}\n" ^
      begin
        if length cts > 1 then
        let equiv_tuple = `BTYP_tuple (map snd cts) in
        "  " ^ name ^ "("^ tn equiv_tuple ^ " _a)\n" ^
        "    : " 
        ^
        catmap ", "
        (fun ((name,_),i) -> name ^"(_a.mem_" ^si i^ ")")
        (combine ctss (nlist (length ctss)))
        ^
        "  {}\n" 
        else ""
      end
      ^
      "};\n"
      

    | `BBDCL_union _ -> ""

    | _ -> 
      failwith 
      (
        "[gen_type] Expected definition "^si i^" to be generic primitive, got " ^ 
        string_of_bbdcl syms.dfns entry i ^
        " instance types [" ^
        catmap ", " tn ts ^
        "]"
      )
    end


  | `BTYP_name index ->
    print_endline ("[gen_type] Deprecated BTYP_name " ^ si index);
    let name = tn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_type] can't find index " ^ si index)
    in
    begin match entry with
    | `BBDCL_struct (vs,cs) ->
      descr ^
      let ctor = 
        let equiv_tuple_type = typeoflist (map snd cs) in
        match length cs with
        | 0 -> "" (* just use default ctor *)
        | 1 -> 
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg): " ^
          fst (hd cs) ^ "(_arg) {}\n" 
        | _ ->
          let ctor_inits = ref [] in 
          let counter = ref 0 in
         iter 
          (fun (name,typ) -> 
            let n = !counter in incr counter; 
            ctor_inits :=
              (name ^ "(_arg.mem_"^si n ^")")
              :: !ctor_inits
          )
          cs
          ;
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg) :\n" ^
          "    " ^ String.concat ",\n    " (rev !ctor_inits) ^
          "\n  {}\n" 
      in
      "struct " ^ name ^ "{\n" ^
      "  "^ name ^ "(){}\n" ^
      ctor ^
      String.concat "" 
      (
       map 
        (
          fun (name,typ) -> "  " ^ tn typ ^ 
          " " ^
          name ^ ";\n"
        )
        cs
      ) ^
      "};\n"

    | `BBDCL_union _ -> "" (* covered by prior typedef of _uctor_ or int *)
    | `BBDCL_abs (vs,ct) -> ""
    | _ -> 
      failwith 
      (
        "[gen_typ] expected type declaration, got " ^
        string_of_bbdcl syms.dfns entry index
      )
    end
  | _ -> failwith "Unexpected metatype in gen_type"

let gen_type_names syms bbdfns ts = 
  (* print_endline "GENERATING TYPE NAMES"; *)
  let s = Buffer.create 100 in
 iter 
  (fun (i,t) -> 
    try
      Buffer.add_string s (gen_type_name syms bbdfns (i,t))
    with Not_found -> 
      failwith ("Can't gen type name " ^ si i ^ "=" ^ string_of_btypecode syms.dfns t)
  )
  ts;
  Buffer.contents s

let gen_types syms bbdfns ts = 
  (* print_endline "GENERATING TYPES"; *)
  let s = Buffer.create 100 in
  iter 
  (fun t -> 
    Buffer.add_string s (gen_type syms bbdfns t)
  )
  ts;
  Buffer.contents s

