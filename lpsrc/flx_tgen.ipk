@head(1,'Type generator')
@h = tangler('src/flx_tgen.mli')
@select(h)
open Flx_types
open Flx_mtypes2

val gen_types :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

val gen_type_names :
  sym_state_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

@h = tangler('src/flx_tgen.ml')
@select(h)
open Flx_util
open Flx_types
open Flx_mtypes1
open Flx_mtypes2
open Flx_print
open Flx_typing
open Flx_srcref
open Flx_unify
open Flx_name
open Flx_cexpr
open Flx_csubst
open Flx_exceptions
open Flx_treg
open List

@doc()
Now some code to generate the bases, given the
hashtable. We also mangle c++ abstract type names.
@select(h)
let gen_tuple name tn typs =
  let n = length typs in
  "struct " ^ name ^ " {\n" ^
  catmap "" 
  (fun (t,i) -> 
    if t = `BTYP_tuple [] 
    then "  // elided mem_" ^ si i ^ "(type unit)\n"
    else "  "^tn t^ " mem_" ^ si i ^ ";\n"
  )
  (combine typs (nlist n))
  ^
  "  " ^ name ^ "(){}\n" (* default constructor *)
  ^
  (
    if fold_left (fun r t -> r && t = `BTYP_tuple []) true typs 
    then "" 
    else
    "  " ^ name ^ "(" ^
    fold_left 
    (fun s (t,i) -> 
      if t = `BTYP_tuple [] then s 
      else 
        s ^ 
        (if String.length s > 0 then ", " else "") ^
        tn t^" a" ^ si i
    ) 
    ""
    (combine typs (nlist n))
    ^
    "):\n    " 
    ^ 
    fold_left
    (fun s (t,i) -> 
      if t = `BTYP_tuple [] then s 
      else
        s ^
        (if String.length s > 0 then ", " else "") ^
        "mem_"^si i ^ "(a" ^ si i^")"
    ) 
    ""
    (combine typs (nlist n))
    ^
    "{}\n"
  )
  ^
  "};\n"

(* copy ctor, assignment, and destructor are generated; 
  we have to supply the pointer constructor and default
  constructor though. Note that it matters not if this
  type is sliced, since it's nothing more than a type
  correct wrapper for its base
*)
let gen_ref name typ =
  "struct " ^ name ^ ": _ref_ {\n" ^
  "  "^name^"(){}\n" ^
  "  "^name^"(void *f, " ^typ^" *d): _ref_(f,d){}\n" ^
  "  "^typ^" *operator->()const { return ("^typ^"*)get_data(); }\n" ^
  "  "^typ^" &operator*() const { return *("^typ^"*)get_data(); }\n" ^
  "};\n"

(* this routine generates a typedef (for primitives)
or struct declaration which names the type. 
*)

let gen_type_name syms bbdfns (index,typ) =
  (*
  print_endline (
    "GENERATING TYPE NAME " ^
    si index^": " ^ 
    sbt syms.dfns typ
  );
  *)
  let cn t = cpp_type_classname syms t in
  let tn t = cpp_typename syms t in
  let descr = 
    "\n//TYPE "^si index^": " ^ sbt syms.dfns typ ^ "\n" 
  in
  match unfold syms.dfns typ with
  | `BTYP_fix i -> ""
  | `BTYP_var i -> failwith "[gen_type_name] Can't gen name of type variable"

  | `BTYP_tuple [] -> "" (* unit *)

  | `BTYP_pointer _
  | `BTYP_tuple _
  | `BTYP_array _
  | `BTYP_function _ ->
    descr ^
    let name = cn typ in
    "struct " ^ name ^ ";\n"


  | `BTYP_unitsum k ->
      "typedef int " ^ tn typ ^ ";\n"

  | `BTYP_sum ts ->
    descr ^
    if is_unitsum typ
    then
      "typedef int " ^ tn typ ^ ";\n"
    else
      "typedef _uctor_ " ^ tn typ ^ ";\n"

  | `BTYP_void -> ""

  | `BTYP_inst (i,ts) -> 
    let id,parent,sr,entry = 
      try Hashtbl.find bbdfns i
      with _ -> failwith ("[gen_type_name] can't find type" ^ si i)
    in
    begin match entry with
    | `BBDCL_abs (vs,quals,ct,_) -> 
      let complete = not (mem `Incomplete quals) in
      let descr = 
        "\n//"^(if complete then "" else "INCOMPLETE ")^
        "PRIMITIVE "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      let instance_name = cn typ in
      let tss = map tn ts in
      let instance = 
        match ct with
        | `Str c -> c
        | `StrTemplate c ->
        try sc "expr" (csubst sr sr c [] [] "Error" "Error" tss "atom" "Error" ["Error"] ["Error"]) 
        with Not_found -> failwith "[gen_type_name] Unexpected error in csubst"
      in

      (* special hack to avoid 'typedef int int' when we decide
      to use the native typename in generated code instead of
      an alias
      *)
      (if instance = instance_name
      then descr ^ "//" 
      else descr
      )
      ^
      "typedef " ^ instance ^ " " ^ instance_name ^ ";\n"

    | `BBDCL_cstruct _ -> if ts = [] then "" else
      let descr = 
        "\n//CSTRUCT "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      let instance_name = cn typ in
      let instance = id ^ "<" ^ catmap "," cn ts ^"> " in
      descr ^
      "typedef " ^ instance ^ " " ^ instance_name ^ ";\n"


    | `BBDCL_class _ ->  
      begin
        (*
        print_endline "[gen_type_name] CLASS TYPE INSTANCE";
        *)
        let type_instance_name = cn typ in
        let class_name = cpp_instance_name syms bbdfns i ts in
        let class_instance = 
          try Hashtbl.find syms.instances (i,ts)
          with Not_found -> assert false
        in
        let descr = 
          "\n//CLASS "^si i ^" TYPE INSTANCE " ^ 
          si index^": " ^ 
          sbt syms.dfns typ ^ 
          ", CLASS INSTANCE " ^ si class_instance ^
          "\n" 
        in
        descr ^
        "struct " ^ class_name ^"; // class instance \n"  ^
        "typedef " ^ class_name ^" *"^type_instance_name^"; // type instance\n" 
      end

    | `BBDCL_cclass _ ->  if ts = [] then "" else
      let descr = 
        "\n//CCLASS "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      let instance_name = cn typ in
      let instance = id ^ "<" ^ catmap "," cn ts ^"> " in
      descr ^
      "typedef " ^ instance ^ " *" ^ instance_name ^ ";\n"

    | `BBDCL_struct _ ->
      let descr = 
        "\n//STRUCT "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      let name = cn typ in
      descr ^ "struct " ^ name ^ ";\n"

    | `BBDCL_union (vs,ls) ->
      let descr = 
        "\n//UNION "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      let name = cn typ in
      descr ^
      let lss = map snd ls in
      let lss = map (tsubst vs ts) lss in
      let len = si (length lss) in
      if all_voids lss
      then
        "typedef int " ^ name ^ "; //ncases="^len^"\n"
      else
        "typedef _uctor_ " ^ name ^ "; //ncases="^len^"\n"


    | _ -> 
      failwith 
      (
        "[gen_type_name] Expected definition "^si i^" to be generic primitive, got " ^ 
        string_of_bbdcl syms.dfns entry i ^
        " instance types [" ^
        catmap ", " tn ts ^
        "]"
      )
    end

  | _ -> failwith "Unexpected metatype in gen_type_name"

let mk_listwise_ctor syms i name typ cts ctss = 
  if length cts = 1 then
  let ctn,ctt = hd ctss in
    "  " ^ name ^ "("^ ctt ^ " const & _a): " ^
    ctn^"(_a){}\n"
  else ""


(*
  let argt = map snd cts in
  let argt = typeoflist argt in
  let ctor_type = `BTYP_fun
  let ctor_type =

  let tn t = cpp_typename syms t in
  "  " ^ name ^ "(" 
  ^
  catmap ", "
  (fun (name,typ) -> typ ^ " _a_" ^ name )
  ctss
  ^
  ")\n" ^
  "    : " 
  ^
  catmap ", "
  (fun (name,_) -> name ^"(_a_" ^ name ^ ")")
  ctss
  ^
  "  {}\n" ^
  begin
    match cts with
    | [] | [_] -> ""
    | h :: t -> let th = snd h in
    try iter (fun (_,t) -> if t <> th then raise Not_found) cts;
      let equiv_array = `BTYP_array (th, `BTYP_unitsum (length cts)) in
      "  " ^ name ^ "("^ tn equiv_array ^ " const &_a)\n" ^
      "    : " 
      ^
      catmap ", "
      (fun ((name,_),i) -> name ^"(_a.data[" ^si i^ "])")
      (combine ctss (nlist (length ctss)))
      ^
      "  {}\n" 

    with Not_found ->
      let equiv_tuple = `BTYP_tuple (map snd cts) in
      "  " ^ name ^ "("^ tn equiv_tuple ^ " const &_a)\n" ^
      "    : " 
      ^
      catmap ", "
      (fun ((name,_),i) -> name ^"(_a.mem_" ^si i^ ")")
      (combine ctss (nlist (length ctss)))
      ^
      "  {}\n" 
  end
*)

(* This routine generates complete types when needed *)
let gen_type syms bbdfns (index,typ) =
  (*
  print_endline (
    "GENERATING TYPE " ^
    si index^": " ^ 
    sbt syms.dfns typ
  );
  *)
  let tn t = cpp_typename syms t in
  let cn t = cpp_type_classname syms t in
  let descr = 
    "\n//TYPE "^ si index^ ": " ^ 
    sbt syms.dfns typ ^ 
    "\n" 
  in
  match unfold syms.dfns typ with
  | `BTYP_var _ -> failwith "[gen_type] can't gen type variable"
  | `BTYP_fix _ -> failwith "[gen_type] can't gen type fixpoint"

  (* PROCEDURE *)
  | `BTYP_function (a,`BTYP_void) ->
    descr ^
    let name = cn typ  
    and argtype = tn a
    and unitproc = a = `BTYP_tuple[]
    in
    "struct " ^ name ^
    ": con_t {\n" ^
    "  typedef void rettype;\n" ^
    "  typedef " ^ (if unitproc then "void" else argtype) ^ " argtype;\n" ^
    (if unitproc 
    then
    "  virtual con_t *call(con_t *)=0;\n"
    else
    "  virtual con_t *call(con_t *, "^argtype^" const &)=0;\n"
    ) ^
    "  virtual "^name^" *clone()const=0;\n"  ^
    "  virtual con_t *resume()=0;\n"  ^
    "};\n"

  (* FUNCTION *)
  | `BTYP_function (a,r) ->
    descr ^
    let name = cn typ  
    and argtype = tn a
    and rettype = tn r
    and unitfun = a = `BTYP_tuple[]
    in
    "struct " ^ name ^ " {\n" ^
    "  typedef " ^ rettype ^ " rettype;\n" ^
    "  typedef " ^ (if unitfun then "void" else argtype) ^ " argtype;\n" ^
    "  virtual "^rettype^" apply("^
    (if unitfun then "" else argtype^" const &") ^
    ")=0;\n"  ^
    "  virtual "^name^" *clone()const=0;\n"  ^
    "  virtual ~"^name^"(){};\n" ^
    "};\n"

  | `BTYP_unitsum _ -> "" (* union typedef *)
  | `BTYP_sum _ -> "" (* union typedef *)

  | `BTYP_tuple [] -> "" 
  | `BTYP_tuple ts -> 
     descr ^
     gen_tuple (cn typ) tn ts
     
  | `BTYP_void -> ""
  | `BTYP_pointer t -> 
    let name = tn typ in
    let t = tn t in
    descr ^ gen_ref name t

  | `BTYP_array (v,i) ->
    let name = tn typ in
    let v = tn v in
    let n =
      match i with
      | `BTYP_unitsum k -> k
      | `BTYP_sum ls ->
        if all_units ls then length ls
        else 
          failwith 
          (
            "Array index must be unit sum, got\n" ^
            sbt syms.dfns i
          )
      | _ ->
        failwith 
        (
          "Array index must be unit sum, got\n" ^
          sbt syms.dfns i
        )
    in
    descr ^
    "struct " ^ name ^ " {\n" ^
    "  static size_t const len = " ^ si n ^ ";\n" ^
    "  typedef " ^ v ^ " element_type;\n" ^
    "  " ^ v ^ " data[" ^ si n ^ "];\n" ^
    "};\n"
  

  | `BTYP_inst (i,ts) ->
    let id,parent,sr,entry = 
      try Hashtbl.find bbdfns i
      with _ -> failwith ("[gen_type_name] can't find type" ^ si i)
    in
    begin match entry with
    | `BBDCL_abs (vs,quals,ct,_) -> ""
    | `BBDCL_cstruct (vs,cts) -> ""
    | `BBDCL_cclass (vs,cts) -> ""
    | `BBDCL_class vs -> 
      (*
      print_endline "[gen_type] FOUND CLASS TYPE INSTANCE (doing nothing)";
      *)
      ""

      (*
      let name = cn typ in
      let descr = 
        "\n//GENERIC CLASS "^si i ^" INSTANCE TYPE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      descr ^ "//see " ^ name ^ ";\n"
      *)

    | `BBDCL_struct (vs,cts) ->
      let cts = map (fun (name,typ) -> name, tsubst vs ts typ) cts in
      let ctss = map (fun (name,typ) -> name, tn typ) cts in
      let name = cn typ in
      let listwise_ctor = mk_listwise_ctor syms i name typ cts ctss in
      let descr = 
        "\n//GENERIC STRUCT "^si i ^" INSTANCE " ^ 
        si index^": " ^ 
        sbt syms.dfns typ ^ 
        "\n" 
      in
      descr ^ "struct " ^ name ^ " {\n" 
      ^
      catmap ""
      (fun (name,typ) -> "  " ^ typ ^ " " ^ name ^ ";\n")
      ctss
      ^ 
      "  " ^ name ^ "(){}\n" ^
      listwise_ctor
      ^
      "};\n"
      

    | `BBDCL_union _ -> ""

    | _ -> 
      failwith 
      (
        "[gen_type] Expected definition "^si i^" to be generic primitive, got " ^ 
        string_of_bbdcl syms.dfns entry i ^
        " instance types [" ^
        catmap ", " tn ts ^
        "]"
      )
    end

  | _ -> failwith "Unexpected metatype in gen_type"

let gen_type_names syms bbdfns ts = 
  (* print_endline "GENERATING TYPE NAMES"; *)
  let s = Buffer.create 100 in
  iter 
  (fun (i,t) -> 
    try
      Buffer.add_string s (gen_type_name syms bbdfns (i,t))
    with Not_found -> 
      failwith ("Can't gen type name " ^ si i ^ "=" ^ sbt syms.dfns t)
  )
  ts;
  Buffer.contents s

let gen_types syms bbdfns ts = 
  (* print_endline "GENERATING TYPES"; *)
  let s = Buffer.create 100 in
  iter 
  (fun t -> 
    Buffer.add_string s (gen_type syms bbdfns t)
  )
  ts;
  Buffer.contents s

