@h = tangler('src/flx_tgen.mli')
@select(h)
open Flx_types
val cpp_typename :
  type_registry_t ->
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  btypecode_t -> string

val ptr_map_of_type:
  type_registry_t ->
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  btypecode_t -> string

val cpp_classname :
  type_registry_t ->
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  btypecode_t -> string

val gen_types :
  type_registry_t ->
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string

val gen_type_names :
  type_registry_t ->
  symbol_table_t ->
  fully_bound_symbol_table_t ->
  (int * btypecode_t) list -> string


@h = tangler('src/flx_tgen.ml')
@select(h)
open Flx_types
open Flx_print
open Flx_typing
open Flx_srcref

let mangle_cpp_typename ct =
  let n = String.length ct in
  let buf = Buffer.create (n+20) in
  let tack_ch ch = Buffer.add_char buf ch in
  let tack_str str = Buffer.add_string buf str in
  for i=0 to n - 1 do
    match ct.[i] with
    | ':' -> tack_ch '_'
    | '*' -> tack_str "_p"
    | '<' -> tack_ch '_'
    | '>' -> tack_ch '_'
    | ' ' -> tack_ch '_'
    | x -> tack_ch x
  done;
  Buffer.contents buf

let rec cpp_typename registry dfns bbdfns t = 
  let tn t = cpp_typename registry dfns bbdfns t in
  let t = type_fold t in
  try match t with
  | `BTYP_fix i ->  failwith "Can't name type fixpoint"
  | `BTYP_tuple [] -> "unit"
  | `BTYP_function (_,`BTYP_void) -> 
    "_procedure_type_" ^ string_of_int (Hashtbl.find registry t) ^ "*"
  | `BTYP_function _ -> 
    "_function_type_" ^ string_of_int (Hashtbl.find registry t) ^ "*"
  | `BTYP_tuple _ -> "_tuple_type_" ^ string_of_int (Hashtbl.find registry t)
  | `BTYP_sum _ -> "_sum_type_" ^ string_of_int (Hashtbl.find registry t)

  | `BTYP_pointer t' -> "_ref_<"^tn t'^">"
  | `BTYP_void -> "void"
  | `BTYP_none -> failwith "[cpp_typename] Expected real type, got 'none'"
  | `BTYP_binding (_,t) -> tn t
  | `BTYP_name index ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index
      with Not_found -> failwith ("cpp_typename Can't find index " ^ string_of_int index ^ " in fully bound symbol table")
    in begin match entry with
      | `BBDCL_union _ -> "_union_" ^ string_of_int index ^ "_" ^ id
      | `BBDCL_struct _ ->"_struct_" ^ string_of_int index ^ "_" ^id
      | `BBDCL_abs ct -> "_abs_" ^ string_of_int index ^ "_" ^ mangle_cpp_typename ct
      | _ -> 
        failwith 
        (
          "[cpp_typename] expected type declaration, got " ^
          string_of_bbdcl dfns entry index
        )
    end
  
  with Not_found -> 
    failwith 
    (
      "[cpp_typename] Expected type "^ 
      string_of_btypecode dfns t ^ 
      " to be in registry"
    )

let rec cpp_classname registry dfns bbdfns t = 
  let tn t = cpp_typename registry dfns bbdfns t in
  let t = type_fold t in
  try match type_fold t with
  | `BTYP_fix i -> failwith "type fixpoint doesn't have class"
  | `BTYP_binding _ -> failwith "[cpp_classname] Unexpected binding type"
  | `BTYP_tuple [] -> "unit"
  | `BTYP_void -> failwith "void doesn't have a classname"
  | `BTYP_function (_,`BTYP_void) -> 
    "_procedure_type_" ^ string_of_int (Hashtbl.find registry t)
  | `BTYP_function _ -> 
    "_function_type_" ^ string_of_int (Hashtbl.find registry t) 
  | `BTYP_tuple _ -> "_tuple_type_" ^ string_of_int (Hashtbl.find registry t)
  | `BTYP_sum _ -> "_sum_type_" ^ string_of_int (Hashtbl.find registry t)
  | `BTYP_pointer t' -> "_ref_<"^tn t'^">"
  | `BTYP_none -> 
    failwith "[cpp_typename] Expected real type, got 'none'"
  | `BTYP_name index ->
    let id,parent,entry = 
      try Hashtbl.find bbdfns index
      with Not_found -> failwith ("cpp_classname Can't find index " ^ string_of_int index ^ " in fully bound symbol table")
    in begin match entry with
      | `BBDCL_union _ -> "_union_" ^ string_of_int index ^ "_" ^ id
      | `BBDCL_struct _ ->"_struct_" ^ string_of_int index ^ "_" ^id
      | `BBDCL_abs ct -> "_abs_" ^ string_of_int index ^ "_" ^ mangle_cpp_typename ct
      | _ -> 
        failwith 
        (
          "[cpp_classname] expected type declaration, got " ^
          string_of_bbdcl dfns entry index
        )
    end
  
  with Not_found -> 
    failwith 
    (
      "[cpp_classname] Expected type "^ 
      string_of_btypecode dfns t ^ 
      " to be in registry"
    )

@doc()
Now some code to generate the bases, given the
hashtable. We also mangle c++ abstract type names.
@select(h)
let is_unitsum (t:btypecode_t) = match t with
  | `BTYP_sum ls -> 
    List.fold_left 
    (fun acc t -> acc && (t = `BTYP_tuple []))
    true ls

  | _ -> false

let gen_type_name registry dfns bbdfns (index,typ) =
  let tn t = cpp_classname registry dfns bbdfns t in
  (*
  print_endline ("gen_type_name " ^ string_of_btypecode dfns typ);
  *)
  match type_unfold typ with
  | `BTYP_fix i -> failwith "[gen_type_name] Unexpected fix"
  | `BTYP_binding _ -> failwith "[gen_type_name] Unexpected binding type"
  | `BTYP_function (_,`BTYP_tuple []) ->
     "// elided " ^ tn typ
  | `BTYP_function _ ->
    let name = tn typ in
    "struct " ^ name ^ ";\n"
  | `BTYP_tuple ts ->
    let name = tn typ in
    "struct " ^ name ^ ";\n"

  | `BTYP_sum ts ->
    if is_unitsum typ
    then
      "typedef int " ^ tn typ ^ ";\n"
    else
      "typedef _uctor_ " ^ tn typ ^ ";\n"

  | `BTYP_void -> ""
  | `BTYP_none -> ""
  | `BTYP_pointer t -> "//Pointer by template"

  | `BTYP_name index ->
    let name = tn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index
      with _ -> failwith ("[gen_type_name] can't find type" ^ string_of_int index)
    in
    match entry with
    | `BBDCL_struct cs ->
      "struct " ^ name ^ ";\n"
    | `BBDCL_union _ -> 
      "typedef _uctor_ " ^ tn typ ^ ";\n"
    | `BBDCL_abs ct -> "typedef " ^ ct ^ " " ^ tn typ ^ ";\n" 
    | _ -> 
      failwith 
      (
        "[gen_type_name] expected type declaration, got " ^
        string_of_bbdcl dfns entry index
      )

let gen_type registry dfns bbdfns (index,typ) =
  (*
  print_endline (
    "GENERATING TYPE " ^
    string_of_int index^": " ^ 
    string_of_btypecode dfns typ
  );
  *)
  "//TYPE "^string_of_int index^": " ^ string_of_btypecode dfns typ ^ "\n"^
  let tn t = cpp_typename registry dfns bbdfns t in
  let cn t = cpp_classname registry dfns bbdfns t in
  match type_unfold typ with

  | `BTYP_fix _ -> failwith "[gen_type] can't gen type fixpoint"
  | `BTYP_binding _ -> failwith ("gen_type] Unexpected binding type")

  (* PROCEDURE *)
  | `BTYP_function (a,`BTYP_void) ->
    let name = cn typ  
    and argtype = tn a
    in
    "struct " ^ name ^
    ": continuation_t {\n" ^
    (if a <> `BTYP_tuple [] 
    then
    "  virtual continuation_t *call(continuation_t *, "^argtype^" const &)=0;\n"
    else
    "  virtual continuation_t *call(continuation_t *)=0;\n"
    ) ^
    "  virtual continuation_t *resume()=0;\n"  ^
    "};\n"

  (* FUNCTION *)
  | `BTYP_function (a,`BTYP_tuple []) ->
     "//  -- returns unit, elided\n"

  | `BTYP_function (a,r) ->
    let name = cn typ  
    and argtype = tn a
    and rettype = tn r
    in
    "struct " ^ name ^ " {\n" ^
    "  virtual "^rettype^" apply("^
    (if a = `BTYP_tuple []
    then ""
    else argtype^" const &") ^
    ")=0;\n"  ^
    "};\n"

  | `BTYP_sum _ -> "" (* union typedef *)

  | `BTYP_tuple ts ->
    let components = ref [] in
    let counter = ref 1 in
    List.iter 
    (fun t -> 
      components := !components @ [!counter, t]; 
      incr counter
    )
    ts
    ;
    let mem_dcls = String.concat "" (List.map 
    (fun (i,t) ->
      "  " ^ tn t ^ " " ^
      "mem_" ^ string_of_int i ^ ";\n"
    )
    !components)

    and param_dcls =  String.concat ",\n" (List.map
    (fun (i,t) -> "    " ^ tn t ^ " arg_" ^ string_of_int i)
    !components) ^ "\n"
    
    and ctor_inits = String.concat ",\n" (List.map
    (fun (i,t) -> "    mem_" ^ string_of_int i ^ "(arg_" ^ string_of_int i ^ ")")
    !components) ^ "\n"
    in 
    
    let name = cn typ in
    let ctor = 
      "  " ^ name ^ "\n" ^
      "  (\n" ^
      param_dcls ^
      "  ) :\n" ^
      ctor_inits ^
      "  {}\n"
    in
    "struct " ^ name ^ " {\n" ^
    mem_dcls^
    "  " ^ name ^ "(){}\n"^
    ctor ^
    "};\n"

  | `BTYP_void -> ""
  | `BTYP_none -> ""
  | `BTYP_pointer t -> failwith "Generate pointer type: should use template"
    (*
    let name = tn typ in
    let data_type = tn t in
    "struct " ^ name ^ " {\n" ^
    "  void *frame;\n" ^
    "  "^data_type^" *data;\n" ^
    "  " ^ name ^ "(){}\n" ^
    "  " ^ name ^ "(" ^ data_type ^ " *d, void *f) : data(d), frame(f) {}\n" ^
    "};\n"
    *)

  | `BTYP_name index ->
    let name = tn typ in
    let id,parent,entry = 
      try Hashtbl.find bbdfns index 
      with _ -> failwith ("[gen_type] can't find index " ^ string_of_int index)
    in
    match entry with
    | `BBDCL_struct cs ->
      let ctor = 
        let equiv_tuple_type = typeoflist (List.map snd cs) in
        match List.length cs with
        | 0 -> "" (* just use default ctor *)
        | 1 -> 
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg): " ^
          fst (List.hd cs) ^ "(_arg) {}\n" 
        | _ ->
          let ctor_inits = ref [] in 
          let counter = ref 1 in
          List.iter 
          (fun (name,typ) -> 
            let n = !counter in incr counter; 
            ctor_inits :=
              (name ^ "(_arg.mem_"^string_of_int n ^")")
              :: !ctor_inits
          )
          cs
          ;
          "  " ^ name ^ "(" ^ tn equiv_tuple_type ^ " const &_arg) :\n" ^
          "    " ^ String.concat ",\n    " (List.rev !ctor_inits) ^
          "\n  {}\n" 
      in
      "struct " ^ name ^ "{\n" ^
      "  "^ name ^ "(){}\n" ^
      ctor ^
      String.concat "" 
      (
        List.map 
        (
          fun (name,typ) -> "  " ^ tn typ ^ 
          " " ^
          name ^ ";\n"
        )
        cs
      ) ^
      "};\n"

    | `BBDCL_union _ -> "" (* covered by prior typedef of _uctor_ *)
    | `BBDCL_abs ct -> ""
    | _ -> 
      failwith 
      (
        "[gen_typ] expected type declaration, got " ^
        string_of_bbdcl dfns entry index
      )

let gen_type_names registry dfns bbdfns ts = 
  (* print_endline "GENERATING TYPE NAMES"; *)
  String.concat "" 
  (List.map (gen_type_name registry dfns bbdfns) ts)

let gen_types registry dfns bbdfns ts = 
  (* print_endline "GENERATING TYPES"; *)
  String.concat "" 
  (List.map (gen_type registry dfns bbdfns) ts)

let ptr_map_of_type registry dfns bbdfns t =
   if is_unitsum t
   then "(flx::gc::generic::gc_shape_t*)0" (* SHOULD NOT HAPPEN BUT .. *)
   else match t with
   | `BTYP_sum _ -> "_uctor_ptr_map"
   | `BTYP_name index ->
      begin match Hashtbl.find dfns index with
      | (_,_,_,`SYMDEF_dcl (`DCL_union _)) ->
        "_uctor_ptr_map"
      | _ ->
        cpp_typename registry dfns bbdfns t ^ "_ptr_map"
      end
   | _ ->
      cpp_typename registry dfns bbdfns t ^ "_ptr_map"

