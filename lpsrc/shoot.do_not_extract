
@def showgraph(machine,test,title):
  get_weaver()._write(
    '''<P></P><TABLE BORDER=2 ALIGN=center>
   <CAPTION>'''+title+'''</CAPTION>
   <TR><TD>
   <IMG ALT="'''+title+'''" SRC="machine/'''+machine+'''/images/'''+test+'''.jpg">
   </TD></TR></TABLE><P></P>
   ''')

@def showdata(fn):
  begin_displayed_code()
  try:
    f = open(fn)
    data = f.read()
    f.close()
    lines = string.split(data,'\n')
    for line in lines: weave(line+'\n')
  except:
    weave(fn+" not available\n")
  end_displayed_code()


@import glob
@raw_machs = glob.glob("speed/machine/*")
@machs = []
@for i in raw_machs: machs.append(i[14:])


@head(1,'[ackermann]')
@for i in machs:
  showgraph(i,'ack','ackermann on '+i)
  showdata('speed/machine/'+i+'/rankings/ackermann.txt')

@select(tangler('speed/specs/ackermann.py'))
descr='ackermann'
min=5
max=10

@select(tangler('speed/src/ocaml/ackermann.ml'))
(*
 * $Id: ackermann.ocaml,v 1.2 2004-09-29 06:24:25 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * with help from Markus Mottl
 *
 * Made more idiomatic by Pierre Etchemaite
 *)

let rec ack m n = match m,n with
  | 0,n -> n + 1
  | m,0 -> ack (m - 1) 1
  | m,n -> ack (m - 1) (ack m (n - 1));;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
Printf.printf "Ack(3,%d): %d\n" n (ack 3 n)

@select(tangler('speed/src/felix/ackermann.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
fun ack(x:int,y:int):int =>
  if x == 0 then y + 1
  elif y == 0 then ack(x-1, 1)
  else ack(x-1, ack(x, y-1))
  endif
;

v := ack(3,n);
print "Ack(3,"; print n; print "): "; print v; endl;



@select(tangler('speed/src/ada/ackermann.ada'))
-- $Id: ackermann.gnat,v 1.4 2005-03-25 07:59:06 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- by James S. Rogers
-- revised by Vasiliy Fofanov
--
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Strings.Fixed;
with Ack_F;

procedure Ackermann is
  Num : Natural;
  function L_Trim(Source : String; Side : Ada.Strings.Trim_End := Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
begin
  if Argument_Count = 1 then
    Num := Natural'Value(Argument(1));
  else
    Num := 1;
  end if;

  Put("Ack(3,");
  Put(L_Trim ( Natural'Image (Num)));
  Put("):");
  Put(Natural'Image (Ack_F (3, Num)));
end Ackermann;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural;

----------------------------------------------------------------------

function Ack_F (M, N : Natural) return Natural is
pragma Suppress(All_Checks);
begin
   if M = 0 then
      return N + 1;
   elsif N = 0 then
      return Ack_F (M - 1, 1);
   else
      return Ack_F (M - 1, Ack_F (M, N - 1));
   end if;
end Ack_F;


@head(1,'[ary]')
@for i in machs:
  showgraph(i,'ack','ary on '+i)
  showdata('speed/machine/'+i+'/rankings/ary.txt')

@select(tangler('speed/specs/ary.py'))
descr='ary'
min=5
max=10

@select(tangler('speed/src/c/ary.c'))
/* -*- mode: c -*-
 * $Id: ary.gcc,v 1.2 2004-05-22 07:25:00 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * this program is modified from:
 *   http://cm.bell-labs.com/cm/cs/who/bwk/interps/pap.html
 * Timing Trials, or, the Trials of Timing: Experiments with Scripting
 * and User-Interface Languages</a> by Brian W. Kernighan and
 * Christopher J. Van Wyk.
 *
 * I added free() to deallocate memory.
 */

#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int i, k, *x, *y;
	
    x = (int *) calloc(n, sizeof(int));
    y = (int *) calloc(n, sizeof(int));

    for (i = 0; i < n; i++) {
	x[i] = i + 1;
    }
    for (k=0; k<1000; k++) {
	for (i = n-1; i >= 0; i--) {
	    y[i] += x[i];
	}
    }

    fprintf(stdout, "%d %d\n", y[0], y[n-1]);

    free(x);
    free(y);

    return(0);
}

@select(tangler('speed/src/ocaml/ary.ml'))
(*
 * $Id: ary.ocaml,v 1.2 2004-05-22 07:25:00 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let _ =
  let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
  let lix = n - 1 and x = Array.make n 0 and y = Array.make n 0 in
  for i = 0 to lix do x.(i) <- i + 1 done;
  for k = 0 to 999 do for i = lix downto 0 do y.(i) <- x.(i) + y.(i) done done;
  Printf.printf "%d %d\n" y.(0) y.(lix)

@select(tangler('speed/src/felix/ary.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>

n := atoi(System::argv 1);
//adapted from C solution
open Carray;

x := array_calloc[int] n;
y := array_calloc[int] n;

var i = 0;
whilst i < n do x.[i] = i + 1; ++i; done;

var k = 0;
whilst k<1000 do
  i = n - 1;
  whilst i >= 0 do
    y.[i] = y.[i] + x.[i];
    --i;
  done;
  ++k;
done;

print y.[0]; print " "; print y.[n-1]; endl;
free x;
free y;


@select(tangler('speed/src/ada/ary.ada'))
-- $Id: ary.gnat,v 1.2 2004-08-14 08:19:16 bfulgham Exp $
-- http://shootout.alioth.debian.org/
-- Ada 95 code by C.C.
-- Revised with suggestions by James S. Rogers

with Text_IO, Ada.Command_Line, Ada.Strings.Fixed;

procedure Ary is
   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
               Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
   N        : Positive := 1;
begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   declare
      pragma suppress (All_Checks);
      type Vect is array (1 .. N) of Integer;
      X : Vect;
      Y : Vect := (Others => 0);
   begin
      for K in Vect'Range loop
         X (K) := K;
      end loop;

      for Iter in 1 .. 1000 loop
         for K in reverse Vect'Range loop
	    Y(K) := Y(K) + X(K);
         end loop;
      end loop;
      Text_IO.Put_Line (L_Trim (Integer'Image (Y (1))) &
               Integer'Image (Y (N)));
   end;
end Ary;

@head(1,'[binarytrees]')
@for i in machs:
  showgraph(i,'ack','binarytrees on '+i)
  showdata('speed/machine/'+i+'/rankings/binarytrees.txt')

@select(tangler('speed/specs/binarytrees.py'))
descr='binarytrees'
min=5
max=10

@select(tangler('speed/src/c/binarytrees.c'))
/* The Computer Language Shootout Benchmarks
   http://shootout.alioth.debian.org/

   contributed by Kevin Carson
   compilation:
       gcc -O3 -fomit-frame-pointer -funroll-loops -static binary-trees.c -lm
       icc -O3 -ip -unroll -static binary-trees.c -lm
*/

#include <malloc.h>
#include <math.h>
#include <stdio.h>
#include <stdlib.h>


typedef struct tn {
    struct tn*    left;
    struct tn*    right;
    long          item;
} treeNode;


treeNode* NewTreeNode(treeNode* left, treeNode* right, long item)
{
    treeNode*    new;

    new = (treeNode*)malloc(sizeof(treeNode));

    new->left = left;
    new->right = right;
    new->item = item;

    return new;
} /* NewTreeNode() */


long ItemCheck(treeNode* tree)
{
    if (tree->left == NULL)
        return tree->item;
    else
        return tree->item + ItemCheck(tree->left) - ItemCheck(tree->right);
} /* ItemCheck() */


treeNode* BottomUpTree(long item, unsigned depth)
{
    if (depth > 0)
        return NewTreeNode
        (
            BottomUpTree(2 * item - 1, depth - 1),
            BottomUpTree(2 * item, depth - 1),
            item
        );
    else
        return NewTreeNode(NULL, NULL, item);
} /* BottomUpTree() */


void DeleteTree(treeNode* tree)
{
    if (tree->left != NULL)
    {
        DeleteTree(tree->left);
        DeleteTree(tree->right);
    }

    free(tree);
} /* DeleteTree() */


int main(int argc, char* argv[])
{
    unsigned   N, depth, minDepth, maxDepth, stretchDepth;
    treeNode   *stretchTree, *longLivedTree, *tempTree;

    N = atol(argv[1]);

    minDepth = 4;

    if ((minDepth + 2) > N)
        maxDepth = minDepth + 2;
    else
        maxDepth = N;

    stretchDepth = maxDepth + 1;

    stretchTree = BottomUpTree(0, stretchDepth);
    printf
    (
        "stretch tree of depth %u\t check: %li\n",
        stretchDepth,
        ItemCheck(stretchTree)
    );

    DeleteTree(stretchTree);

    longLivedTree = BottomUpTree(0, maxDepth);

    for (depth = minDepth; depth <= maxDepth; depth += 2)
    {
        long    i, iterations, check;

        iterations = pow(2, maxDepth - depth + minDepth);

        check = 0;

        for (i = 1; i <= iterations; i++)
        {
            tempTree = BottomUpTree(i, depth);
            check += ItemCheck(tempTree);
            DeleteTree(tempTree);

            tempTree = BottomUpTree(-i, depth);
            check += ItemCheck(tempTree);
            DeleteTree(tempTree);
        } /* for(i = 1...) */

        printf
        (
            "%li\t trees of depth %u\t check: %li\n",
            iterations * 2,
            depth,
            check
        );
    } /* for(depth = minDepth...) */

    printf
    (
        "long lived tree of depth %u\t check: %li\n",
        maxDepth,
        ItemCheck(longLivedTree)
    );

    return 0;
} /* main() */

@select(tangler('speed/src/ocaml/binarytrees.ml'))
(* binarytrees.ml
 *
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * De-optimized by Isaac Gouy
 *)

type 'a tree = Empty | Node of 'a tree * 'a * 'a tree

let rec make i d =
(* if d = 0 then Empty *)
  if d = 0 then Node(Empty, i, Empty)
  else let i2 = 2 * i and d = d - 1 in Node(make (i2 - 1) d, i, make i2 d)

let rec check = function Empty -> 0 | Node(l, i, r) -> i + check l - check r


let min_depth = 4
let max_depth = (let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10 in
                 max (min_depth + 2) n)
let stretch_depth = max_depth + 1

let () =
  (* Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024 }; *)
  let c = check (make 0 stretch_depth) in
  Printf.printf "stretch tree of depth %i\t check: %i\n" stretch_depth c

let long_lived_tree = make 0 max_depth

let rec loop_depths d =
  if d <= max_depth then
    let niter = 1 lsl (max_depth - d + min_depth) and c = ref 0 in
    for i = 1 to niter do c := !c + check(make i d) + check(make (-i) d) done;
    Printf.printf "%i\t trees of depth %i\t check: %i\n" (2 * niter) d !c;
    loop_depths (d + 2)

let () =
  loop_depths min_depth;
  Printf.printf "long lived tree of depth %i\t check: %i\n"
    max_depth (check long_lived_tree)


@select(tangler('speed/src/ada/binarytrees.ada'))
----------------------------------------------------------------
-- BinaryTrees
--
-- Ada 95 (GNAT)
--
-- Contributed by Jim Rogers
----------------------------------------------------------------
with Treenodes; use Treenodes;
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_Io; use Ada.Integer_Text_Io;
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Characters.Latin_1; use Ada.Characters.Latin_1;

procedure Binarytrees is
   Min_Depth : constant Positive := 4;
   N : Natural := 1;
   Stretch_Tree : TreeNode;
   Long_Lived_Tree : TreeNode;
   Short_Lived_Tree_1 : TreeNode;
   Short_Lived_Tree_2 : TreeNode;
   Max_Depth : Positive;
   Stretch_Depth : Positive;
   Check : Integer;
   Sum : Integer;
   Depth : Natural;
   Iterations : Positive;
begin
   if Argument_Count > 0 then
      N := Positive'Value(Argument(1));
   end if;
   Max_Depth := Positive'Max(Min_Depth + 2, N);
   Stretch_Depth := Max_Depth + 1;
   Stretch_Tree := Bottom_Up_Tree(0, Stretch_Depth);
   Item_Check(Stretch_Tree, Check);
   Put("stretch tree of depth ");
   Put(Item => Stretch_Depth, Width => 1);
   Put(Ht & " check: ");
   Put(Item => Check, Width => 1);
   New_Line;
   
   Long_Lived_Tree := Bottom_Up_Tree(0, Max_Depth);
   
   Depth := Min_Depth;
   while Depth <= Max_Depth loop
      Iterations := 2**(Max_Depth - Depth + Min_Depth);
      Check := 0;
      for I in 1..Iterations loop
         Short_Lived_Tree_1 := Bottom_Up_Tree(Item => I, Depth => Depth);
         Short_Lived_Tree_2 := Bottom_Up_Tree(Item =>-I, Depth => Depth);
         Item_Check(Short_Lived_Tree_1, Sum);
         Check := check + Sum;
         Item_Check(Short_Lived_Tree_2, Sum);
         Check := Check + Sum;
      end loop;
      Put(Item => Iterations * 2, Width => 0);
      Put(Ht & " trees of depth ");
      Put(Item => Depth, Width => 0);
      Put(Ht & " check: ");
      Put(Item => Check, Width => 0);
      New_Line;
      Depth := Depth + 2;
   end loop;
   Put("long lived tree of depth ");
   Put(Item => Max_Depth, Width => 0);
   Put(Ht & " check: ");
   Item_Check(Long_Lived_Tree, Check);
   Put(Item => Check, Width => 0);
   New_Line;
end BinaryTrees;
----------------------------------------------------------------
-- BinaryTrees
--
-- Ada 95 (GNAT)
--
-- Contributed by Jim Rogers
----------------------------------------------------------------

package Treenodes is
   type Treenode is private;
   function Bottom_Up_Tree(Item : Integer; Depth : Integer) return Treenode;
   procedure Item_Check(This : in out Treenode; Sum : out Integer);
private
   type Node;
   type Treenode is access Node;
   type Node is record
      Left  : Treenode := null;
      Right : Treenode := null;
      Item  : Integer  := 0; 
   end record;
end Treenodes;
----------------------------------------------------------------
-- BinaryTrees
--
-- Ada 95 (GNAT)
--
-- Contributed by Jim Rogers
----------------------------------------------------------------

with Ada.Unchecked_Deallocation;

package body Treenodes is
   function Bottom_Up_Tree(Item : Integer; Depth : Integer)
      return Treenode is
   begin
      if Depth > 0 then
         return new Node'(Bottom_Up_Tree((2*Item) -1, Depth -1),
            Bottom_Up_Tree(2 * Item, Depth -1),
            Item);
      else
         return new Node'(null, null, Item);
      end if;
   end Bottom_Up_Tree;

   procedure Item_Check (This : in out Treenode; Sum : out Integer) is
      procedure Free is new Ada.Unchecked_Deallocation(Node, Treenode);
      Left_Sum, Right_Sum : Integer;
   begin
      if This.Left = null then
         Sum := This.Item;
      else
         Item_Check(This.Left, Left_Sum);
         Item_Check(This.Right, Right_Sum);
         Sum :=  This.Item + Left_Sum - Right_Sum;
      end if;
      Free(This);      
   end Item_Check;

end Treenodes;
@head(1,'[chameneos]')
@for i in machs:
  showgraph(i,'ack','chameneos on '+i)
  showdata('speed/machine/'+i+'/rankings/chameneos.txt')

@select(tangler('speed/specs/chameneos.py'))
descr='chameneos'
min=5
max=10

@select(tangler('speed/src/c/chameneos.c'))
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Josh Goldfoot
*/

#include <semaphore.h>
#include <pthread.h>
#include <stdio.h>
#include <stdlib.h>

typedef enum { Blue, Red, Yellow, Faded } color;

sem_t AtMostTwo;
sem_t Mutex;
sem_t SemPriv;

int mpStatus = 1;
color aColor, bColor;
long meetingsLeft;
long reports[4];

color complementaryColor (color c1, color c2)
{
  if (c2 == Faded) return Faded;
  if (c1 == c2) return c1;
  switch (c1)
    {
    case Blue:
      return c2 == Red ? Yellow : Red;
    case Red:
      return c2 == Blue ? Yellow : Blue;
    case Yellow:
      return c2 == Blue ? Red : Blue;
    default:
      return c1;
    }
}

color Cooperation (int id, color c)
{
  color otherColor;

  sem_wait (&AtMostTwo);
  sem_wait (&Mutex);
  switch (mpStatus)
    {
    case 1:
      aColor = c;
      mpStatus = 2;
      sem_post (&Mutex);
      sem_wait (&SemPriv);
      otherColor = bColor;
      sem_post (&Mutex);
      sem_post (&AtMostTwo);
      sem_post (&AtMostTwo);
      break;
    case 2:
      mpStatus = (--meetingsLeft > 0 ? 1 : 3);
      bColor = c;
      otherColor = aColor;
      sem_post (&SemPriv);
      break;
    case 3:
    default:
      otherColor = Faded;
      sem_post (&Mutex);
      sem_post (&AtMostTwo);
    }
  return otherColor;
}

void chameneosCode (void *args)
{
  int myId;
  long meetings;
  color myColor, otherColor;
  sscanf ((char *) args, "%d %d", &myId, &myColor);
  meetings = 0;
  while (myColor != Faded)
    {
      otherColor = Cooperation (myId, myColor);
      myColor = complementaryColor (myColor, otherColor);
      meetings++;
    }
  reports[myId] = meetings - 1;
}

int main (int argc, char *argv[])
{
  color tabColor[4] = { Blue, Red, Yellow, Blue };
  pthread_t tabPid[4];
  char theArgs[32][4];
  int i;

  sem_init (&AtMostTwo, 0, 2);
  sem_init (&Mutex, 0, 1);
  sem_init (&SemPriv, 0, 0);

  meetingsLeft = (argc > 1) ? atoi (argv[1]) : 1000000;

  for (i = 0; i < 4; i++)
    {
      sprintf (theArgs[i], "%d %d", i, tabColor[i]);
      pthread_create (&tabPid[i], NULL, (void *(*)(void *)) chameneosCode,
		      theArgs[i]);
    }
  for (i = 0; i < 4; i++)
    pthread_join (tabPid[i], NULL);

  long sum = reports[0];
  for (i = 1; i < 4; i++)
    sum += reports[i];
  printf ("%d\n", sum);

  return 0;
}

@select(tangler('speed/src/ocaml/chameneos.ml'))
(*
 * The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Vladimir Silyaev
 *)

type color = B | R | Y | Faded
    
let compl c1 c2 = match c1,c2 with
  B,R | R,B -> Y
  | Y,R | R,Y -> B
| B,Y | Y,B -> R
| c,_ -> c

let n = ref (try int_of_string (Array.get Sys.argv 1) with _ -> 10)

let meet = 
  let first = ref None in
    fun creature cont ->
      if !n <= 0 then (cont Faded)
      else match !first with
	  None -> 
	    first := Some (creature, cont)
	| Some (creature',cont') -> 
	    decr n;
	    first := None;
	    cont creature';
	    cont' creature
	  
let wait,step = 
  let q = ref [] in
  (fun cont -> q := cont :: !q),
  (fun _ -> let q' = !q in q := [] ;
     match q' with
	 [] -> false
       | _ -> List.iter (fun c -> c ()) q';true)
    
      
let rec creature stop color =
  let rec body n color = 
    meet color 
      (function Faded -> stop n
	 | color' ->
	     let color = compl color color' in      
	       wait (fun _ -> body (succ n) color)
      )
  in
    body 0 color

let _ =     
  let met = ref 0 in
    List.iter (creature (fun n -> met := !met + n))  [B;R;Y;B;];
    while step () do () done;
    Printf.printf "%i\n" !met
      

@head(1,'[dispatch]')
@for i in machs:
  showgraph(i,'ack','dispatch on '+i)
  showdata('speed/machine/'+i+'/rankings/dispatch.txt')

@select(tangler('speed/specs/dispatch.py'))
descr='dispatch'
min=5
max=10

@head(1,'[echo]')
@for i in machs:
  showgraph(i,'ack','echo on '+i)
  showdata('speed/machine/'+i+'/rankings/echo.txt')

@select(tangler('speed/specs/echo.py'))
descr='echo'
min=5
max=10

@select(tangler('speed/src/c/echo.c'))
/* -*- mode: c -*-
 * $Id: echo.gcc,v 1.1.1.1 2004-05-19 18:09:36 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <sys/wait.h>
#include <netinet/in.h>


typedef int (*SOCKACTION_P)(int,struct sockaddr *,socklen_t);
#define DATA "Hello there sailor\n"

void myabort (char *m) { fprintf(stderr, "%s\n", m); exit(1); }
void sysabort (char *m) { perror(m); exit(1); }

int sigchld = 0;
void reaper (int sig) { sigchld = 1; }

int 
genericSock(int port,SOCKACTION_P action,char *actionExceptionText) {
    int ss, optval = 1;
    struct sockaddr_in sin;
    if ((ss = socket(PF_INET, SOCK_STREAM, 0)) == -1)
	sysabort("socket");
    if (setsockopt(ss, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval)) == -1)
	sysabort("setsockopt");
    memset(&sin,0,sizeof(sin));
    sin.sin_family = AF_INET;
    sin.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
    sin.sin_port = port; 
    if (action(ss, (struct sockaddr *)&sin,(socklen_t)sizeof(sin)) == -1)
	sysabort(actionExceptionText);

    return(ss);
}

int
server_sock () {
    int ss = genericSock(0,(SOCKACTION_P)bind,"server/bind");
    return(listen(ss,2),ss);
}

int
client_sock (int port) {
    return(genericSock(port,(SOCKACTION_P)connect,"client/connect"));
}

int
get_port (int sock) {
    struct sockaddr_in sin;
    socklen_t slen = sizeof(sin);
    if (getsockname(sock, (struct sockaddr *)&sin, &slen) == -1)
	sysabort("server/getsockname");
    return(sin.sin_port);
}    

void
echo_client (int n, int port) {
    int i, sock, olen, len, nwritten, nread;
    char *offset, obuf[64], ibuf[64];
    char *end = ibuf + sizeof(ibuf);

    sock = client_sock(port);
    strcpy(obuf, DATA);
    olen = strlen(obuf);
    for (i=0; i<n; i++) {
	len = olen;
	offset = obuf;
	while (len > 0) {
	    if ((nwritten = write(sock, offset, len)) == -1)
		sysabort("client/write");
	    offset += nwritten;
	    len -= nwritten;
	}
	offset = ibuf;
	while ((nread = read(sock, offset, (end - offset))) > 0) {
	    offset += nread;
	    if (*(offset-1) == '\n') break;
	}
	if (nread == -1)
	    sysabort("client/read");
	*offset = 0;
	if ((strcmp(obuf, ibuf)) != 0) {
	    char mbuf[128];
	    sprintf(mbuf, "client: \"%s\" ne \"%s\"", obuf, ibuf);
	    myabort(mbuf);
	}
    }
    close(sock);
}

void
echo_server (int n) {
    int ssock, csock, len, nwritten, total_bytes;
    pid_t pid;
    char buf[64], *offset;
    struct sockaddr_in sin;
    socklen_t slen = sizeof(sin);
    int status;

    ssock = server_sock();
    signal(SIGCHLD, reaper);
    if ((pid = fork()) == -1)
	sysabort("server/fork");
    if (pid) {
	/* parent is server */
	if ((csock = accept(ssock, (struct sockaddr *)&sin, &slen)) == -1)
	    sysabort("server/accept");
	total_bytes = 0;
	while ((len = read(csock, buf, sizeof(buf))) > 0) {
	    if (sigchld) myabort("server/sigchld");
	    offset = buf;
	    total_bytes += len;
	    while (len > 0) {
		if ((nwritten = write(csock, offset, len)) == -1)
		    sysabort("server/write");
		offset += nwritten;
		len -= nwritten;
	    }
	}
	if (len == -1)
	    sysabort("server/read");
	close(csock);
	fprintf(stdout, "server processed %d bytes\n", total_bytes);
    } else {
	/* child is client */
	echo_client(n, get_port(ssock));
    }
    wait(&status);
}

int
main(int argc, char *argv[]) {
    echo_server((argc == 2) ? atoi(argv[1]) : 1);
    return(0);
}

@select(tangler('speed/src/ocaml/echo.ml'))
(*
 * $Id: echo.ocaml,v 1.1.1.1 2004-05-19 18:09:37 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

open Unix

let data = "Hello there sailor\n"

let rec sock_write sock buf offset = function
  | 0 -> ()
  | len ->
      let nwritten = write sock buf offset len in
      sock_write sock buf (offset + nwritten) (len - nwritten)

let sock_readline buf sock =
  let offset = ref (read sock buf 0 64) in
  while buf.[!offset - 1] <> '\n' do
    offset := !offset + read sock buf !offset 64
  done;
  !offset

let rec buf_ok buf n = n <= 0 || buf.[n] = data.[n] && buf_ok buf (n - 1)

let echo_client n port =
  let sock = socket PF_INET SOCK_STREAM 0 in
  connect sock (ADDR_INET (inet_addr_of_string "127.0.0.1", port));
  let len = String.length data and buf = String.create 64 in
  for i = 1 to n do
    sock_write sock data 0 len;
    let ans_len = sock_readline buf sock in
    if ans_len <> len || not (buf_ok buf (len - 1)) then
      failwith ("client got bad data: " ^ String.sub buf 0 ans_len)
  done;
  close sock

let ssock =
  let ssock = socket PF_INET SOCK_STREAM 0
  and addr = inet_addr_of_string "127.0.0.1" in
  bind ssock (ADDR_INET (addr, 0));
  setsockopt ssock SO_REUSEADDR true;
  listen ssock 2;
  ssock

let get_port sock =
  match getsockname sock with
  | ADDR_INET (_, port) -> port
  | ADDR_UNIX _ -> failwith "getsockname"

let echo_server n =
  let port = get_port ssock and pid = fork() in
  if pid <> 0 then begin
    let csock, addr = accept ssock
    and buf = String.create 64 and len = ref 0 and nread = ref 1 in
    while !nread > 0 do
      nread := read csock buf 0 64;
      sock_write csock buf 0 !nread;
      len := !len + !nread
    done;
    ignore (wait ());
    Printf.printf "server processed %d bytes\n" !len end
  else echo_client n port

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
echo_server n

@head(1,'[except]')
@for i in machs:
  showgraph(i,'ack','except on '+i)
  showdata('speed/machine/'+i+'/rankings/except.txt')

@select(tangler('speed/specs/except.py'))
descr='except'
min=5
max=10

@select(tangler('speed/src/c/except.c'))
/* -*- mode: c -*-
 * $Id: except.gcc,v 1.1.1.1 2004-05-19 18:09:42 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <setjmp.h>

int HI = 0, LO = 0;

static jmp_buf Hi_exception;
static jmp_buf Lo_exception;

void blowup (int n) {
    if (n & 1) {
	longjmp(Lo_exception, 1);
    } else {
	longjmp(Hi_exception, 1);
    }
}

void lo_function (volatile int n) {
    if (setjmp(Lo_exception) != 0) {
	LO++;
    } else {
	blowup(n);
    }
}

void hi_function (volatile int n) {
    if (setjmp(Hi_exception) != 0) {
	HI++;
    } else {
	lo_function(n);
    }
}

void some_function (int n) {
    hi_function(n);
}

int
main(int argc, char *argv[]) {
    int volatile N = ((argc == 2) ? atoi(argv[1]) : 1);

    while (N) {
	some_function(N--);
    }
    printf("Exceptions: HI=%d / LO=%d\n", HI, LO);
    return(0);
}

@select(tangler('speed/src/ocaml/except.ml'))
(*
 * $Id: except.ocaml,v 1.1.1.1 2004-05-19 18:09:43 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 * and Mark Baker
 *)

exception HiException of int
exception LoException of int

let hi = ref 0
let lo = ref 0

let blowup n =
  if n mod 2 = 0 then raise (LoException n)
  else raise (HiException n)

let lo_fun n = try blowup n with LoException _ -> incr lo
let hi_fun n = try lo_fun n with HiException _ -> incr hi

let some_fun n =
  try hi_fun n with exc -> print_endline "Should not get here."; raise exc

let _ =
  let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
  for i = 1 to n do some_fun i done;
  Printf.printf "Exceptions: HI=%d / LO=%d\n" !hi !lo

@select(tangler('speed/src/felix/except.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
// Felix uses explicitly passed closures to handle errors
// and therefore guarrantees exceptions get caught statically

typedef err = int -> void;

var hi = 0;
var lo = 0;

proc blowup (n:int, hie:err, loe:err) {
  if n % 2 == 0 do loe n; else hie n; done;
}

proc lo_fun (n:int, hie:err) {
  blowup (n,hie,loe of (int));
  proc loe(n:int) { ++lo; goto fin; }
fin:>
}

proc hi_fun (n:int) {
  lo_fun (n,hie of (int));
  proc hie(n:int) { ++hi; goto fin; }
fin:>
}

proc some_fun (n:int) { hi_fun n; }

var i = n - 1;
until i < 0 do some_fun i; --i; done;
print "Exceptions: HI="; print hi; print " / LO="; print lo; endl;



@select(tangler('speed/src/ada/except.ada'))
-- $Id: except.gnat,v 1.1 2004-05-23 06:34:14 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Text_IO, Ada.Strings.Fixed, Ada.Command_Line;

procedure Except is
   High_Exception : exception;
   Low_Exception  : exception;
   Low            : Integer := 0;
   High           : Integer := 0;

   procedure Blowup (K : Integer) is
      pragma Inline (Blowup);
   begin
      case 1 = (K mod 2) is
         when False => raise High_Exception;
         when True  => raise Low_Exception;
      end case;
   end Blowup;

   procedure Low_Function (K : Integer) is
      pragma Inline (Low_Function);
   begin
      Blowup (K);
   exception
      when Low_Exception => Low := Low + 1;
   end Low_Function;

   procedure High_Function (K : Integer) is
      pragma Inline (High_Function);
   begin
      Low_Function (K);
   exception
      when High_Exception => High := High + 1;
   end High_Function;

   procedure Some_Function (K : Integer) is
      pragma Inline (Some_Function);
   begin
      High_Function (K);
   exception
      when others => Text_IO.Put_Line ("We shouldn't get here");
   end Some_Function;

   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
               Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
   N        : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for K in reverse 0 .. N - 1 loop
      Some_Function (K);
   end loop;
   Text_IO.Put_Line ("Exceptions: HI=" & L_Trim (Natural'Image (High)) &
            " / LO=" & L_Trim (Natural'Image (Low)));
end Except;

@head(1,'[fannkuch]')
@for i in machs:
  showgraph(i,'ack','fannkuch on '+i)
  showdata('speed/machine/'+i+'/rankings/fannkuch.txt')

@select(tangler('speed/specs/fannkuch.py'))
descr='fannkuch'
min=5
max=10

@select(tangler('speed/src/c/fannkuch.c'))
/*
 * The Computer Lannguage Shootout
 * http://shootout.alioth.debian.org/
 * Contributed by Heiner Marxen
 *
 * "fannkuch"	for C gcc
 *
 * $Id: fannkuch.gcc,v 1.5 2005-12-04 23:58:38 igouy-guest Exp $
 */

#include <stdio.h>
#include <stdlib.h>

#define Int	int
#define Aint	int

    static long
fannkuch( int n )
{
    Aint*	perm;
    Aint*	perm1;
    Aint*	count;
    long	flips;
    long	flipsMax;
    Int		r;
    Int		i;
    Int		k;
    Int		didpr;
    const Int	n1	= n - 1;

    if( n < 1 ) return 0;

    perm  = calloc(n, sizeof(*perm ));
    perm1 = calloc(n, sizeof(*perm1));
    count = calloc(n, sizeof(*count));

    for( i=0 ; i<n ; ++i ) perm1[i] = i;	/* initial (trivial) permu */

    r = n; didpr = 0; flipsMax = 0;
    for(;;) {
	if( didpr < 30 ) {
	    for( i=0 ; i<n ; ++i ) printf("%d", (int)(1+perm1[i]));
	    printf("\n");
	    ++didpr;
	}
	for( ; r!=1 ; --r ) {
	    count[r-1] = r;
	}

#define XCH(x,y)	{ Aint t_mp; t_mp=(x); (x)=(y); (y)=t_mp; }

	if( ! (perm1[0]==0 || perm1[n1]==n1) ) {
	    flips = 0;
	    for( i=1 ; i<n ; ++i ) {	/* perm = perm1 */
		perm[i] = perm1[i];
	    }
	    k = perm1[0];		/* cache perm[0] in k */
	    do {			/* k!=0 ==> k>0 */
		Int	j;
		for( i=1, j=k-1 ; i<j ; ++i, --j ) {
		    XCH(perm[i], perm[j])
		}
		++flips;
		/*
		 * Now exchange k (caching perm[0]) and perm[k]... with care!
		 * XCH(k, perm[k]) does NOT work!
		 */
		j=perm[k]; perm[k]=k ; k=j;
	    }while( k );
	    if( flipsMax < flips ) {
		flipsMax = flips;
	    }
	}

	for(;;) {
	    if( r == n ) {
		return flipsMax;
	    }
	    /* rotate down perm[0..r] by one */
	    {
		Int	perm0 = perm1[0];
		i = 0;
		while( i < r ) {
		    k = i+1;
		    perm1[i] = perm1[k];
		    i = k;
		}
		perm1[r] = perm0;
	    }
	    if( (count[r] -= 1) > 0 ) {
		break;
	    }
	    ++r;
	}
    }
}

    int
main( int argc, char* argv[] )
{
    int		n = (argc>1) ? atoi(argv[1]) : 0;

    printf("Pfannkuchen(%d) = %ld\n", n, fannkuch(n));
    return 0;
}

@select(tangler('speed/src/ocaml/fannkuch.ml'))
(* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Christophe Papazian
   Decembre 2005
*)

(* please compile with -unsafe to optimize speed *)

open Array open Printf

(*global variables*)
let n = try if length Sys.argv>1 then int_of_string Sys.argv.(1)else 7  with _->7
let r = init(n+2)(fun x -> x-1) and p=init n((+)1) and s=create n 0

(*pretty printing function*)
let q() = iter print_int p;print_newline()

(*counting permutations*)
let rec a n = r.(n)<-(r.(n)+1); 
  if r.(n)=n-1 then a(n+1) 
  else (if r.(n)=n then r.(n)<-0;n)

(*swapping arrays*)
let w m= let rec a i=i=n||(p.(i)<>(i+1)&&a(i+1))in
if a 0 then
  (for i=0 to n-1 do s.(i)<-p.(i)done;
   let rec y m= let x=s.(0)-1 in 
   if x=0 then m 
   else (for i=0 to((x-1) lsr 1)do
	   let t=s.(i)in let o = x-i in s.(i)<-s.(o);
	   s.(o)<-t done;y(m+1)) 
   in y m) else 0
  
(*building new permutations*)
let x n = 
  for i=1 to n-1 do let t=p.(0)in 
  for j=0 to i-1 do p.(j)<-p.(j+1) done; p.(i)<-t done

(* main *)
let _ = let rec f i m z= (* printing loop *)
  if i <=n && z>0 
  then(q();x i;f(a 2)(max m(w 0))(z-1))
  else (if z>0 then q();g i m)
	and g i m= if i <=n (* non printing loop *)
	then(x i; g(a 2)(max m(w 0)))
	else m in
printf "Pfannkuchen(%i) = %i\n" n (f (a 2) 0 30)

@select(tangler('speed/src/ada/fannkuch.ada'))
-----------------------------------------------------------------------
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- converted to Ada by Jim Rogers
-- compile: gcc -c -gnatwu -O2 -gnatn -funroll-loops -gnatp fannkuch.adb
-----------------------------------------------------------------------
with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_Io; use Ada.Text_Io;

procedure Fannkuch is
   package Pos_Io is new Ada.Text_Io.Integer_Io(Positive);
   use Pos_IO;
   type Perm_Array is array(Natural range <>) of Natural;
   procedure Swap(A, B : in out Natural) is
      Temp : Natural := A;
   begin
      A := B;
      B := Temp;
   end Swap;
   
   function Fann(N : Positive) return Natural is
      M        : Natural := N - 1;
      Perm     : Perm_Array(0..M);
      Perm1    : Perm_Array(0..M);
      Count    : Perm_Array(0..M);
      Max_Flips_Count : Natural:= 0;
      R        : Natural := N;
      Check    : Natural := 0;
   begin
      for I in Perm1'range loop
         Perm1(I) := I;
      end loop;
      loop
         if Check < 30 then
            for I in Perm1'range loop
               Put(Item => Perm1(I) + 1, Width => 1);
            end loop;
            New_Line;
            Check := Check + 1;
         end if;
         while R /= 1 loop
            Count(R - 1) := R;
            R := R - 1;
         end loop;
         if not (Perm1(0) = 0 or Perm1(M) = M) then
            Perm := Perm1;
            declare
               Flips_Count : Natural := 0;
               K           : Natural;
            begin
               loop
                  K := Perm(0);
                  exit when K = 0;
                  for I in 0..((K + 1)/2 -1) loop
                     Swap(Perm(I), Perm(K - I));
                  end loop;
                  Flips_Count := Flips_Count + 1;
               end loop;
               if Flips_Count > Max_Flips_Count then
                  Max_Flips_Count := Flips_Count;
               end if;
            end;
         end if;
         loop
            if R = N then 
               return Max_Flips_Count;
            end if;
            declare
               Perm0 : Natural := Perm1(0);
               J : Natural;
               I : Natural := 0;
            begin
               while I < R loop
                  J := I + 1;
                  Perm1(I) := Perm1(J);
                  I := J;
               end loop;
               Perm1(r) := Perm0;
            end;
            Count(R) := Count(R) - 1;
            exit when Count(R) > 0;
            r := R + 1;
         end loop;
      end loop;
   end Fann;
   Num : Positive := 7;
   Result : Positive;
begin
   if Argument_Count > 0 then
      Num := Positive'Value(Argument(1));
   end if;
   Result := Fann(Num);
   Put("Pfannkuchen(" );
   Put(Item => Num, Width => 0);
   Put(") = ");
   Put(Item => Result, Width => 0);
   New_Line;
end Fannkuch;


@head(1,'[fasta]')
@for i in machs:
  showgraph(i,'ack','fasta on '+i)
  showdata('speed/machine/'+i+'/rankings/fasta.txt')

@select(tangler('speed/specs/fasta.py'))
descr='fasta'
min=5
max=10

@select(tangler('speed/src/c/fasta.c'))
/* -*- mode: c -*-
 * $Id: fasta.gcc,v 1.1 2005-03-19 07:50:09 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 *
 * by Paul Hsieh
 */

#include <stdio.h>
#include <stdlib.h>

#define IM 139968
#define IA   3877
#define IC  29573

double gen_random (double max) {
    static long last = 42;
    return max * (last = (last * IA + IC) % IM) / IM;
}

struct aminoacids {
    char c;
    double p;
};

/* Weighted selection from alphabet */

void makeCumulative (struct aminoacids * genelist, int count) {
    double cp = 0.0;
    int i;

    for (i=0; i < count; i++) {
        cp += genelist[i].p;
        genelist[i].p = cp;
    }
}

char selectRandom (const struct aminoacids * genelist, int count) {
    double r = gen_random (1);
    int i, lo, hi;

    if (r < genelist[0].p) return genelist[0].c;

    lo = 0;
    hi = count-1;

    while (hi > lo+1) {
        i = (hi + lo) / 2;
        if (r < genelist[i].p) hi = i; else lo = i;
    }
    return genelist[hi].c;
}

/* Generate and write FASTA format */

#define LINE_LENGTH (60)

void makeRandomFasta (const char * id, const char * desc, const struct 
aminoacids * genelist, int count, int n) {
   int todo = n;
   int i, m;

   printf (">%s %s\n", id, desc);

   for (; todo > 0; todo -= LINE_LENGTH) {
       char pick[LINE_LENGTH+1];
       if (todo < LINE_LENGTH) m = todo; else m = LINE_LENGTH;
       for (i=0; i < m; i++) pick[i] = selectRandom (genelist, count);
       pick[m] = '\0';
       puts (pick);
   }
}

void makeRepeatFasta (const char * id, const char * desc, const char * 
s, int n) {
   char * ss;
   int todo = n, k = 0, kn = strlen (s);
   int m;

   ss = (char *) malloc (kn + 1);
   memcpy (ss, s, kn+1);

   printf (">%s %s\n", id, desc);

   for (; todo > 0; todo -= LINE_LENGTH) {
       if (todo < LINE_LENGTH) m = todo; else m = LINE_LENGTH;

       while (m >= kn - k) {
           printf ("%s", s+k);
           m -= kn - k;
           k = 0;
       }

       ss[k + m] = '\0';
       puts (ss+k);
       ss[k + m] = s[m+k];
       k += m;
   }

   free (ss);
}

/* Main -- define alphabets, make 3 fragments */

struct aminoacids iub[] = {
    { 'a', 0.27 },
    { 'c', 0.12 },
    { 'g', 0.12 },
    { 't', 0.27 },

    { 'B', 0.02 },
    { 'D', 0.02 },
    { 'H', 0.02 },
    { 'K', 0.02 },
    { 'M', 0.02 },
    { 'N', 0.02 },
    { 'R', 0.02 },
    { 'S', 0.02 },
    { 'V', 0.02 },
    { 'W', 0.02 },
    { 'Y', 0.02 }
};

#define IUB_LEN (sizeof (iub) / sizeof (struct aminoacids))

struct aminoacids homosapiens[] = {
    { 'a', 0.3029549426680 },
    { 'c', 0.1979883004921 },
    { 'g', 0.1975473066391 },
    { 't', 0.3015094502008 },
};

#define HOMOSAPIENS_LEN (sizeof (homosapiens) / sizeof (struct aminoacids))

char * alu =
   "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" \
   "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" \
   "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" \
   "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" \
   "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" \
   "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" \
   "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

int main (int argc, char * argv[]) {
    int n = 1000;

    if (argc > 1) sscanf (argv[1], "%d", &n);

    makeCumulative (iub, IUB_LEN);
    makeCumulative (homosapiens, HOMOSAPIENS_LEN);

    makeRepeatFasta ("ONE", "Homo sapiens alu", alu, n*2);
    makeRandomFasta ("TWO", "IUB ambiguity codes", iub, IUB_LEN, n*3);
    makeRandomFasta ("THREE", "Homo sapiens frequency", homosapiens, 
HOMOSAPIENS_LEN, n*5);

    return 0;
}


@select(tangler('speed/src/ada/fasta.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/04/07

package Fasta_Pck is

   type Real is new Long_Float;

   type Aminoacid is record
      C : Character;
      P : Real;
   end record;

   type Aminoacid_Set is array (Positive range <>) of Aminoacid;

   procedure Make_Cumulative (Gene_List : in out Aminoacid_Set);

   function Select_Random (Gene_List : in Aminoacid_Set) return Character;

   procedure Make_Random_Fasta
     (Id, Desc : in String; Gene_List : in Aminoacid_Set; N : in Positive);

   procedure Make_Repeat_Fasta (Id, Desc, S : in String; N : in Positive);

end Fasta_Pck;

with Ada.Text_IO; use Ada.Text_IO;

package body Fasta_Pck is

   Line_Length : constant := 60;

   Last        : Natural := 42;

   function Gen_Random (Max : in Real) return Real;
   pragma Inline (Gen_Random);

   function Gen_Random (Max : in Real) return Real is
      IM : constant := 139_968;
      IA : constant :=   3_877;
      IC : constant :=  29_573;
   begin
      Last := (Last * IA + IC) mod IM;
      return (Max * Real (Last)) / Real (IM);
   end Gen_Random;

   procedure Make_Cumulative (Gene_List : in out Aminoacid_Set) is
      C : Real := Gene_List (Gene_List'First).P;
   begin
      for K in Gene_List'First + 1 .. Gene_List'Last loop
         C := C + Gene_List (K).P;
         Gene_List (K).P := C;
      end loop;
   end Make_Cumulative;

   function Select_Random (Gene_List : in Aminoacid_Set) return Character is
      R         : Real := Gen_Random (1.0);
      I, Lo, Hi : Integer;
   begin
      if R < Gene_List (Gene_List'First).P then
         return Gene_List (Gene_List'First).C;
      end if;

      Lo := 0;
      Hi := Gene_List'Last;

      while Hi > Lo + 1 loop
         I := (Hi + Lo) / 2;
         if R < Gene_List (I).P then
            Hi := I;
         else
            Lo := I;
         end if;
      end loop;

      return Gene_List (Hi).C;
   end Select_Random;

   procedure Make_Random_Fasta
     (Id, Desc : in String; Gene_List : in Aminoacid_Set; N : in Positive)
   is
      Todo : Integer := N;
      M    : Integer;
      Pick : String (1 .. Line_Length);
   begin
      Put_Line (">" & Id & ' ' & Desc);

      while Todo > 0 loop
         M := Natural'Min (Todo, Line_Length);

         for K in 1 .. M loop
            Pick (K) := Select_Random (Gene_List);
         end loop;

         Put_Line (Pick (1 .. M));
         Todo := Todo - Line_Length;
      end loop;
   end Make_Random_Fasta;

   procedure Make_Repeat_Fasta (Id, Desc, S : in String; N : in Positive) is
      Todo : Integer := N;
      K    : Positive := S'First;
      M    : Natural;
   begin
      Put_Line (">" & Id & ' ' & Desc);

      while Todo > 0 loop
         M := Natural'Min (Todo, Line_Length);

         while M >= S'Length - K + S'First loop
            Put (S (K .. S'Last));
            M := M - (S'Length - K + S'First);
            K := S'First;
         end loop;

         Put_Line (S (K .. K + M - S'First));
         K := K + M - S'First + 1;

         Todo := Todo - Line_Length;
      end loop;
   end Make_Repeat_Fasta;

end Fasta_Pck;

with Ada.Command_Line; use Ada.Command_Line;
with Fasta_Pck;        use Fasta_Pck;

procedure Fasta is
   Homosapiens : Aminoacid_Set :=
                   (('a', 0.3029549426680), ('c', 0.1979883004921),
                    ('g', 0.1975473066391), ('t', 0.3015094502008));
   Iub         : Aminoacid_Set :=
                   (('a', 0.27), ('c', 0.12), ('g', 0.12), ('t', 0.27),
                    ('B', 0.02), ('D', 0.02), ('H', 0.02), ('K', 0.02),
                    ('M', 0.02), ('N', 0.02), ('R', 0.02), ('S', 0.02),
                    ('V', 0.02), ('W', 0.02), ('Y', 0.02));
   Alu         : constant String :=
                    "GGCCGGGCGCGGTGGCTCACGCCTGTAATCCCAGCACTTTGG" &
                    "GAGGCCGAGGCGGGCGGATCACCTGAGGTCAGGAGTTCGAGA" &
                    "CCAGCCTGGCCAACATGGTGAAACCCCGTCTCTACTAAAAAT" &
                    "ACAAAAATTAGCCGGGCGTGGTGGCGCGCGCCTGTAATCCCA" &
                    "GCTACTCGGGAGGCTGAGGCAGGAGAATCGCTTGAACCCGGG" &
                    "AGGCGGAGGTTGCAGTGAGCCGAGATCGCGCCACTGCACTCC" &
                    "AGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAA";

   N           : constant Positive := Positive'Value (Argument (1));

begin
   Make_Cumulative (Iub);
   Make_Cumulative (Homosapiens);

   Make_Repeat_Fasta ("ONE", "Homo sapiens alu", alu, N * 2);
   Make_Random_Fasta ("TWO", "IUB ambiguity codes", Iub, N * 3);
   Make_Random_Fasta
     ("THREE", "Homo sapiens frequency", Homosapiens, N * 5);
end Fasta;

@head(1,'[fibo]')
@for i in machs:
  showgraph(i,'ack','fibo on '+i)
  showdata('speed/machine/'+i+'/rankings/fibo.txt')

@select(tangler('speed/specs/fibo.py'))
descr='fibo'
min=5
max=10

@select(tangler('speed/src/c/fibo.c'))
/* -*- mode: c -*-
 * $Id: fibo.gcc,v 1.6 2005-04-25 19:01:38 igouy-guest Exp $
 * http://shootout.alioth.debian.org/
 * Revised with register allocation by David Bronaugh
 */

#include <stdio.h>
#include <stdlib.h>

static unsigned long
fib(unsigned long n) {
    return( (n < 2) ? 1 : (fib(n-2) + fib(n-1)) );
}

int
main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%ld\n", fib(N));
    return(0);
}

@select(tangler('speed/src/ocaml/fibo.ml'))
(*
 * $Id: fibo.ocaml,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
 * http://shootout.alioth.debian.org/
 *
 * Revised per the Lisp versions, by Dan Weber
 * Revised back by Brent to match specification of problem.
 *)

let rec fib n =
   if n < 2 then 1 else fib (n - 2) + fib (n - 1);;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
Printf.printf "%d\n" (fib n)


@select(tangler('speed/src/felix/fibo.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);

fun fib(n:int):int =>
  if n < 2 then 1 else fib (n - 2) + fib (n - 1) endif
;

v := fib(n);
print v; endl;


@select(tangler('speed/src/ada/fibo.ada'))
-- $Id: fibo.gnat,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22

with Ada.Text_IO, Ada.Integer_Text_IO, Ada.Command_Line;
use  Ada.Text_IO, Ada.Integer_Text_IO, Ada.Command_Line;

with Pck_Fibo;

procedure Fibo is
   N : Natural;
begin
   N := Natural'Value (Argument (1));
   Put (Item => Pck_Fibo.Fib (N), Width => 0);
   New_Line;
end Fibo;
-- $Id: fibo.gnat,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
-- http://dada.perl.it/shootout/
-- Contributed by Pascal Obry on 2005/03/22

package Pck_Fibo is

   function Fib (N : in Natural) return Natural;

end Pck_Fibo;
-- $Id: fibo.gnat,v 1.5 2005-04-25 19:01:38 igouy-guest Exp $
-- http://shootout.alioth.debian.org/
-- Contributed by Pascal Obry on 2005/03/22

package body Pck_Fibo is

   function Fib (N : in Natural) return Natural is
   begin
      if N <= 1 then
         return 1;
      else
         return Fib (N - 2) + Fib (N - 1);
      end if;
   end Fib;

end Pck_Fibo;

@head(1,'[harmonic]')
@for i in machs:
  showgraph(i,'ack','harmonic on '+i)
  showdata('speed/machine/'+i+'/rankings/harmonic.txt')

@select(tangler('speed/specs/harmonic.py'))
descr='harmonic'
min=5
max=10

@select(tangler('speed/src/c/harmonic.c'))
/* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   contributed by Greg Buchholz 
   Optimized by Paul Hsieh
   compile:  gcc -O2 -o harmonic harmonic.c
*/
#include<stdio.h>
#include<stdlib.h>

int main (int argc, char **argv)
{
    double i=1, sum=0;
    int n;

    for(n = atoi(argv[1]); n > 0; n--, i++)
        sum += 1/i;

    printf("%.9f\n", sum);
    return 0;
}


@select(tangler('speed/src/ocaml/harmonic.ml'))
(* The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Will M. Farr
 * Tweaked by Jon Harrop
 *)

let sum_harmonic4 n =
  let sum = ref 1.0 and ifloat = ref 2.0 in
  for i = 2 to n do
    sum := !sum +. 1.0 /. !ifloat;
    ifloat := !ifloat +. 1.0
  done;
  !sum

let () = Printf.printf "%0.9f\n" (sum_harmonic4 (int_of_string (Sys.argv.(1))))

@select(tangler('speed/src/ada/harmonic.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/18

with Ada.Text_IO;            use Ada.Text_IO;
with Ada.Command_Line;       use Ada.Command_Line;
with Ada.Long_Float_Text_IO; use Ada.Long_Float_Text_IO;

procedure Harmonic is
   Partial_Sum : Long_Float := 0.0;
   N           : Natural;
begin
   N := Integer'Value (Argument (1));

   for I in 1 .. N loop
      Partial_Sum := Partial_Sum + (1.0 / Long_Float (I));
   end loop;

   Put (Item => Partial_Sum, Aft => 9, Exp => 0);
   New_Line;
end Harmonic;

@head(1,'[hash]')
@for i in machs:
  showgraph(i,'ack','hash on '+i)
  showdata('speed/machine/'+i+'/rankings/hash.txt')

@select(tangler('speed/specs/hash.py'))
descr='hash'
min=5
max=10

@select(tangler('speed/src/c/hash.c'))
/* -*- mode: c -*-
 * $Id: hash.gcc,v 1.1.1.1 2004-05-19 18:09:55 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "../../Include/simple_hash.h"

int main(int argc, char *argv[]) {
    int i, c=0, n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[32];
	
    struct ht_ht *ht = ht_create(n);
    
    for (i=1; i<=n; i++) {
	sprintf(buf, "%x", i);
	(ht_find_new(ht, buf))->val = i;
    }

    for (i=n; i>0; i--) {
	sprintf(buf, "%d", i);
	if (ht_find(ht, buf)) c++;
    }

    ht_destroy(ht);

    printf("%d\n", c);
    return(0);
}

@select(tangler('speed/src/ocaml/hash.ml'))
(*
 * $Id: hash.ocaml,v 1.1.1.1 2004-05-19 18:09:55 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let hexdigits =  [| '0'; '1'; '2'; '3'; '4'; '5'; '6'; '7'; '8'; '9';
                    'a'; 'b'; 'c'; 'd'; 'e'; 'f'; |]

let buf = String.create 32

let rec hexstring_of_int idx len = function
  | n when n <= 0 -> String.sub buf idx len
  | n ->
      let new_idx = idx - 1 in
      buf.[new_idx] <- hexdigits.(n land 15);
      hexstring_of_int new_idx (len + 1) (n lsr 4);;

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1 in
let hx = Hashtbl.create n and c = ref 0 in
for i = 1 to n do Hashtbl.add hx (hexstring_of_int 32 0 i) true done;
for i = n downto 1 do if Hashtbl.mem hx (string_of_int i) then incr c done;
Printf.printf "%d\n" !c

@select(tangler('speed/src/felix/hash.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
include "stl";
open Stl;
open Stl::HashMap;

requires ext_string_hash;

body hexer """
string hex(int x) { char buf[20]; sprintf(buf,"%x",x); return buf; }
""";

fun hex: int -> string requires hexer;

var hm = HashMap::create[string,int]();

var i = n; until i == 0 do
  insert(hm,hex i,i);
  --i;
done;

var c = 0;
i = n; until i == 0 do
  if mem (hm,str i) do c++; done;
  --i;
done;

print c; endl;



@head(1,'[hash2]')
@for i in machs:
  showgraph(i,'ack','hash2 on '+i)
  showdata('speed/machine/'+i+'/rankings/hash2.txt')

@select(tangler('speed/specs/hash2.py'))
descr='hash2'
min=5
max=10

@select(tangler('speed/src/c/hash2.c'))
/* -*- mode: c -*-
 * $Id: hash2.gcc,v 1.1.1.1 2004-05-19 18:10:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "../../Include/simple_hash.h"

int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    char buf[32];
    struct ht_ht *ht1 = ht_create(10000);
    struct ht_ht *ht2 = ht_create(10000);
    struct ht_node *node;

    for (i=0; i<=9999; ++i) {
	sprintf(buf, "foo_%d", i);
	ht_find_new(ht1, buf)->val = i;
    }

    for (i=0; i<n; ++i) {
	for (node=ht_first(ht1); node; node=ht_next(ht1)) {
	    ht_find_new(ht2, node->key)->val += node->val;
	}
    }

    printf("%d %d %d %d\n",
	   (ht_find(ht1, "foo_1"))->val,
	   (ht_find(ht1, "foo_9999"))->val,
	   (ht_find(ht2, "foo_1"))->val,
	   (ht_find(ht2, "foo_9999"))->val);

    ht_destroy(ht1);
    ht_destroy(ht2);
    return(0);
}

@select(tangler('speed/src/ocaml/hash2.ml'))
(*
 * $Id: hash2.ocaml,v 1.1.1.1 2004-05-19 18:10:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
and hash1 = Hashtbl.create 10000 and hash2 = Hashtbl.create 10000 in
let update_hash2 k v =
  try let valref = Hashtbl.find hash2 k in valref := !valref + !v
  with Not_found -> Hashtbl.add hash2 k (ref !v) in
for i = 0 to 9999 do Hashtbl.add hash1 ("foo_" ^ string_of_int i) (ref i) done;
for i = 1 to n do Hashtbl.iter update_hash2 hash1 done;
Printf.printf "%d %d %d %d\n"
  !(Hashtbl.find hash1 "foo_1") !(Hashtbl.find hash1 "foo_9999")
  !(Hashtbl.find hash2 "foo_1") !(Hashtbl.find hash2 "foo_9999")

@select(tangler('speed/src/felix/hash2.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
include "stl";
open Stl;
open Stl::HashMap;

requires ext_string_hash;

var h1 = HashMap::create[string,int]();

var i = 1; until i == 10000 do
  s := "foo_" + str i;
  insert (h1, s, i);
  ++i;
done;

var h2 = HashMap::create[string,int]();

i=n; until i == 0 do
  var j = begin h1; until j == end h1 do
    k, v := deref j;
    //h2.[k] = h2.[k] + v;
    h2.[k] += v;
    ++j;
  done;
  --i;
done;

print h1.["foo_1"]; print " "; print h1.["foo_9999"]; print " " ;
print h2.["foo_1"]; print " "; print h2.["foo_9999"]; endl;


@head(1,'[health]')
@for i in machs:
  showgraph(i,'ack','health on '+i)
  showdata('speed/machine/'+i+'/rankings/health.txt')

@select(tangler('speed/specs/health.py'))
descr='health'
min=5
max=10

@select(tangler('speed/src/ocaml/health.ml'))
(* health.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * $Id: health.ocaml,v 1.9 2005-05-23 07:46:49 chris00-guest Exp $
 *)

(* Adjust GC behavior *)
let () = Gc.set { (Gc.get()) with Gc.minor_heap_size = 1024 * 1024 }

(* Mutable single linked lists.  Useful interface only. *)
(* module type Lsig =
sig
  type 'a t
  val make : unit -> 'a t
  val add : 'a -> 'a t -> unit
  val iter : ('a -> unit) -> 'a t -> unit
  val fold_left : ('a -> 'b -> 'a) -> 'a -> 'b t -> 'a
  val filter : ('a -> bool) -> 'a t -> unit  (** filter in place *)
  val clear_and_copy : 'a t -> 'a t
   (** [clear_and_copy l] clears [l] and return a copy of it. *)
end *)
module L (* : Lsig *) =
struct
  (* The standard solution is to define a special termination "symbol"
     for the list, e.g. [None] as in

     type 'a list = 'a node option
     and 'a node = { data : 'a; mutable next : 'a list }

     but that introduce an additional indirection, so here we use
     a "last node" and physical equality to avoid it. *)
  type 'a t = { mutable first : 'a list;  mutable last : 'a list }
  and 'a list = { mutable data : 'a;  mutable next : 'a list }

  let make () =
    let rec node = { data = Obj.magic 0;  next = node } in
    { first = node;  last = node }

  (* The element [e] must be added to the end of [l]. *)
  let add e l =
    l.last.data <- e;
    let rec node = { data = Obj.magic 0;  next = node } in
    l.last.next <- node;
    l.last <- node


  let rec iter_node f node last =
    if node != last then (f node.data; iter_node f node.next last)
  let iter f l = iter_node f l.first l.last

  let rec fold_node f a node last =
    if node == last then a else fold_node f (f a node.data) node.next last
  let fold_left f a l = fold_node f a l.first l.last


  let rec keep_node f node0 last =
    let node = node0.next in
    if node != last (* otherwise: nothing to do *) then
      if f node.data then keep_node f node last (* keep node *)
      else skip_node f node0 node.next last
  and skip_node f node0 node last =
    if node == last then node0.next <- last (* close the modified list *)
    else if f node.data then (node0.next <- node; keep_node f node last)
    else skip_node f node0 node.next last

  let rec filter_1st f l node =
    if node == l.last then l.first <- l.last (* none selected, empty list *)
    else if f node.data then (l.first <- node; keep_node f node l.last)
    else filter_1st f l node.next (* skip node *)

  let filter f l = filter_1st f l l.first

  let clear_and_copy l =
    let node0 = l.first and node1 = l.last in
    let rec node = { data = Obj.magic 0;  next = node } in
    l.first <- node; l.last <- node;
    { first = node0;  last = node1 }
end


type patient = {
  mutable remaining_time : int;
  mutable hospital_time : int;
  mutable hospital_visits : int;
}


let patient_stay p s =
  p.remaining_time <- s;  p.hospital_time <- p.hospital_time + s

type totals = int * int * int (* patients, hospital time, hospital visits *)

let add_patient (n, t, v) p =
  (n + 1, t + p.hospital_time, v + p.hospital_visits)

let ( ++ ) (n0, t0, v0) (n1, t1, v1) = (n0 + n1, t0 + t1, v0 + v1)


module Hospital =
struct
  (* Hospital.t is mutable *)
  type t = {
    triage : patient L.t;
    examination : patient L.t;
    treatement : patient L.t;
    mutable discharged : totals;

    mutable available_staff : int;
    mutable seed : int;
    has_no_regional_hospital : bool; (* i.e. "top" one *)
    transfers : patient L.t;
  }

  (* Shootout random generator, but with hospital seed *)
  let im = 139968 and ia = 3877 and ic = 29573
  let inv_im = 1. /. float im

  let random h max =
    h.seed <- (h.seed * ia + ic) mod im;
    max *. float h.seed *. inv_im

  let make has_no_regional_hospital level seed =
    { triage = L.make();  examination = L.make();  treatement = L.make();
      discharged = (0,0,0);  available_staff = 1 lsl (level - 1);
      seed = seed;  has_no_regional_hospital = has_no_regional_hospital;
      transfers = L.make(); }

  let totals h =
    let tot = L.fold_left add_patient (0,0,0) h.triage in
    let tot = L.fold_left add_patient tot h.examination in
    let tot = L.fold_left add_patient tot h.treatement in
    tot ++ h.discharged

  let new_arrival h p =
    p.hospital_visits <- p.hospital_visits + 1;
    if h.available_staff > 0 then (
      h.available_staff <- h.available_staff - 1;
      L.add p h.examination;
      patient_stay p 3
    )
    else L.add p h.triage

  let discharge_patients h =
    let treat p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	h.available_staff <- h.available_staff + 1;
	h.discharged <- add_patient h.discharged p;
	false
      ) in
    L.filter treat h.treatement

  let treat_or_transfer_patients h =
    let examine p =
      p.remaining_time <- p.remaining_time - 1;
      if p.remaining_time > 0 then true else (
	if random h 1.0 > 0.1 || h.has_no_regional_hospital then (
	  (* Treat patient -- no transfer *)
	  L.add p h.treatement;
	  patient_stay p 10;
	)
	else (
	  (* Transfer to regional hospital *)
	  h.available_staff <- h.available_staff + 1;
	  L.add p h.transfers;
	);
	false
      ) in
    L.filter examine h.examination

  let triage_patients h =
    let triage p =
      if h.available_staff > 0 then (
	h.available_staff <- h.available_staff - 1;
	L.add p h.examination;
	patient_stay p 3;
	false
      )
      else (p.hospital_time <- p.hospital_time + 1;  true) in
    L.filter triage h.triage

  let triage_examination_treatment h =
    discharge_patients h;
    treat_or_transfer_patients h;
    triage_patients h;
    if random h 1.0 > 0.7 then new_arrival h {
      remaining_time = 0; hospital_time = 0; hospital_visits = 0 }
end


(* Hierarchical health care: a region consisting of a hospital and
   (possibly) some districts. *)
type health_care = Region of Hospital.t * (health_care array)

let levels = 5
let districts = 4

let rec create_health_care level seed1 seed2 =
  let create i = create_health_care (level - 1) (4 * seed1 + i + 1) seed2 in
  Region(Hospital.make (level = levels) level (seed1 * seed2),
	 Array.init (if level <= 1 then 0 else districts) create)

let rec transfer_patients (Region(h, districts)) =
  let transfer d =
    L.iter (fun p -> Hospital.new_arrival h p) (transfer_patients d) in
  Array.iter transfer districts;
  Hospital.triage_examination_treatment h;
  (* Return the transfer queue -- leaving the one of [h] empty. *)
  L.clear_and_copy h.Hospital.transfers

let rec accumulate_totals (Region(h, districts)) =
  Array.fold_left (fun tot d -> tot ++ accumulate_totals d) (0,0,0) districts
  ++ Hospital.totals h

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 100 in
  let Region(lh,_) as hc = create_health_care levels 0 42 in
  for i = 1 to n do ignore(transfer_patients hc) done;
  let (pat, time, visits) = accumulate_totals hc in
  Printf.printf "Patients: %i\nTime:     %i\nVisits:   %i\n" pat time visits;
  Printf.printf "\nTreatment Queue - Remaining Treatment Time\n";
  L.iter (fun p -> Printf.printf "%i\tanonymous patient\n" p.remaining_time)
    lh.Hospital.treatement

@head(1,'[heapsort]')
@for i in machs:
  showgraph(i,'ack','heapsort on '+i)
  showdata('speed/machine/'+i+'/rankings/heapsort.txt')

@select(tangler('speed/specs/heapsort.py'))
descr='heapsort'
min=5
max=10

@select(tangler('speed/src/c/heapsort.c'))
/* -*- mode: c -*-
 * $Id: heapsort.gcc,v 1.1.1.1 2004-05-19 18:10:08 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdlib.h>
#include <math.h>
#include <stdio.h>

#define IM 139968
#define IA   3877
#define IC  29573

double
gen_random(double max) {
    static long last = 42;
    return( max * (last = (last * IA + IC) % IM) / IM );
}

void
heapsort(int n, double *ra) {
    int i, j;
    int ir = n;
    int l = (n >> 1) + 1;
    double rra;

    for (;;) {
	if (l > 1) {
	    rra = ra[--l];
	} else {
	    rra = ra[ir];
	    ra[ir] = ra[1];
	    if (--ir == 1) {
		ra[1] = rra;
		return;
	    }
	}
	i = l;
	j = l << 1;
	while (j <= ir) {
	    if (j < ir && ra[j] < ra[j+1]) { ++j; }
	    if (rra < ra[j]) {
		ra[i] = ra[j];
		j += (i = j);
	    } else {
		j = ir + 1;
	    }
	}
	ra[i] = rra;
    }
}

int
main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1);
    double *ary;
    int i;
    
    /* create an array of N random doubles */
    ary = (double *)malloc((N+1) * sizeof(double));
    for (i=1; i<=N; i++) {
	ary[i] = gen_random(1);
    }

    heapsort(N, ary);

    printf("%.10f\n", ary[N]);

    free(ary);
    return(0);
}


@select(tangler('speed/src/ocaml/heapsort.ml'))
(*
 * $Id: heapsort.ocaml,v 1.1.1.1 2004-05-19 18:10:10 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let im = 139968 and ia = 3877 and ic = 29573 and last_ref = ref 42

let gen_random max =
  let new_last = (!last_ref * ia + ic) mod im in
  last_ref := new_last;
  max *. float_of_int new_last /. float im


let heapsort n ra =
  let l = ref ((n lsr 1) + 1)
  and rra = ref 0.0 and i = ref 0 and j = ref 0 and ir = ref n in
  try
    while true do
      if !l > 1 then begin
        decr l;
        rra := ra.(!l)
      end
      else begin
        rra := ra.(!ir);
        ra.(!ir) <- ra.(1);
        decr ir;
        if !ir = 1 then begin
          ra.(1) <- !rra;
          raise Exit
        end
      end;
      i := !l;
      j := !l lsl 1;
      while !j <= !ir do
        if !j < !ir && ra.(!j) < ra.(!j+1) then incr j;
        if !rra < ra.(!j) then begin
          ra.(!i) <- ra.(!j);
          i := !j;
          j := !j + !i
        end
        else j := !ir + 1;
      done;
      ra.(!i) <- !rra;
    done
  with Exit -> ()

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
let ary = Array.init (n + 1) (fun _ -> gen_random 1.0) in
heapsort n ary;
Printf.printf "%.10f\n" ary.(n)

@select(tangler('speed/src/felix/heapsort.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
// stolen from C implementation

fun gen_random: double -> double
  requires body """
    #define IM 139968
    #define IA   3877
    #define IC  29573
    static long last;
    double
    gen_random(double max) {
        static long last = 42;
        return( max * (last = (last * IA + IC) % IM) / IM );
    }
""";
typedef darray = C_hack::ptr[double];

fun subscript: darray * int -> lvalue[double] = "$1[$2]";

val cows_jump_over_moon = false;

proc heapsort(n:int, ra: darray) {
    var i:int;
    var j:int;
    var ir = n;
    var l = (n / 2) + 1;
    var rra:double;

    until cows_jump_over_moon do
        if l > 1 do
            --l;
            rra = ra.[l];
        else
            rra = ra.[ir];
            ra.[ir] = ra.[1];
            --ir;
            if ir == 1 do
                ra.[1] = rra;
                return;
            done;
        done;
        i = l;
        j = l * 2;
        whilst j <= ir do
            if j < ir and ra.[j] < ra.[j+1] do ++j; done;
            if rra < ra.[j] do
                ra.[i] = ra.[j];
                i = j;
                j *= 2;
            else
                j = ir + 1;
            done;
        done;
        ra.[i] = rra;
    done;
}

var ary = Carray::array_alloc[double] (n+1);
var i = n; until i == 0 do
    ary.[i] = gen_random(1.0);
    --i;
done;

heapsort(n, ary);

proc print_10f: double = 'printf("%.10f\\n", $1);';
print_10f ary.[n];

Carray::free ary;


@select(tangler('speed/src/ada/heapsort.ada'))
-- $Id: heapsort.gnat,v 1.2 2005-03-30 21:06:00 obry-guest Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.
-- Modified by Pascal Obry on 2005/03/30

package Random_Long_Float is
   function Gen_Random (Supr : Long_Float) return Long_Float;
   pragma Inline (Gen_Random);
end Random_Long_Float;

package body Random_Long_Float is
   IM          : constant Positive := 139968;
   IA          : constant Integer  := 3877;
   IC          : constant Integer  := 29573;
   Last        : Integer := 42;

   function Gen_Random (Supr : Long_Float) return Long_Float is
   begin
      Last := (Last * IA + IC) mod IM;
      return Supr * Long_Float (Last) / Long_Float (IM);
   end Gen_Random;
end Random_Long_Float;

package Heapsort_Pck is

   type Long_Float_Array is array (Positive range <>) of Long_Float;
   type Long_Float_Array_Ptr is access Long_Float_Array;

   procedure Heapsort (A : in out Long_Float_Array);
end Heapsort_Pck;

package body Heapsort_Pck is

   procedure Heapsort (A : in out Long_Float_Array) is
      First         : constant Positive := A'First;
      IR            : Integer;
      One           : constant Integer := 1;
      Minus_One     : constant Integer := -1;
      First_Minus_1 : constant Integer := First + Minus_One;
      First_Plus_1  : constant Integer := First + One;
      RRA           : Long_Float;
      L             : Integer := One + (A'Length / 2);
      K1, K2        : Integer;
   begin
      if A'Length <= 0 then
         return;
      end if;
      IR := A'Last;
      loop
         if L > One then
            L := L - One;
            RRA := A (First_Minus_1 + L);
         else
            RRA := A (IR);
            A (IR) := A (First);
            if IR <= First_Plus_1 then
               A (First) := RRA;
               exit;
            else
               IR := IR + Minus_One;
            end if;
         end if;
         K1 := First_Minus_1 + L;
         K2 := K1 + L;
         while K2 <= IR loop
            if K2 < IR then
               if A (K2) < A (K2 + One) then
                  K2 := K2 + One;
               end if;
            end if;
            if RRA < A (K2) then
               A (K1) := A (K2);
               K1 := K2;
               K2 := K1 + (K1 - First_Minus_1);
            else
               K2 := IR + One;
            end if;
         end loop;
         A (K1) := RRA;
      end loop;
   end Heapsort;

end Heapsort_Pck;

with Ada.Command_Line, Text_IO;
with Heapsort_Pck; use Heapsort_Pck;
with Random_Long_Float;

procedure Heapsort is
   package Rio is new Text_IO.Float_IO (Num => Long_Float);

   N : Positive;
   X : Long_Float_Array_Ptr;
begin
   N := Positive'Value (Ada.Command_Line.Argument (1));
   X := new Long_Float_Array (1 .. N);
   for Iter in X'Range loop
      X (Iter) := Random_Long_Float.Gen_Random (Supr => 1.0);
   end loop;

   Heapsort (A => X.all);
   Rio.Put (X (X'Last), Fore => 0, Aft => 10, Exp => 0);
   Text_IO.New_Line;
end Heapsort;

@head(1,'[hello]')
@for i in machs:
  showgraph(i,'ack','hello on '+i)
  showdata('speed/machine/'+i+'/rankings/hello.txt')

@select(tangler('speed/specs/hello.py'))
descr='hello'
min=5
max=10

@select(tangler('speed/src/c/hello.c'))
/* -*- mode: c -*-
 * $Id: hello.gcc,v 1.1.1.1 2004-05-19 18:10:16 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>

int main() {
    fputs("hello world\n", stdout);
    return(0);
}


@select(tangler('speed/src/ocaml/hello.ml'))
(*
 * $Id: hello.ocaml,v 1.1.1.1 2004-05-19 18:10:16 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *)

print_endline "hello world"

@select(tangler('speed/src/felix/hello.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
print "hello world"; endl;


@select(tangler('speed/src/ada/hello.ada'))
-- $Id: hello.gnat,v 1.1 2004-05-23 07:03:09 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Ada.Text_IO;
procedure Hello is
begin
   Ada.Text_IO.Put_Line ("hello world");
end Hello;

@head(1,'[implicitode]')
@for i in machs:
  showgraph(i,'ack','implicitode on '+i)
  showdata('speed/machine/'+i+'/rankings/implicitode.txt')

@select(tangler('speed/specs/implicitode.py'))
descr='implicitode'
min=5
max=10

@select(tangler('speed/src/ocaml/implicitode.ml'))
(* implicitode.ml                                           -*-tuareg-*-
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 * Cleaned up and made more idiomatic by Christophe Troestler
 *)

module type SCALAR = sig
  type t
  val ( + ) : t -> t -> t
  val ( - ) : t -> t -> t
  val ( * ) : t -> t -> t
  val ( / ) : t -> t -> t
  val mk : int -> t
  val mf : float -> t
  val pr : t -> string
end

module FL64 : SCALAR = struct
  type t = float
  let ( + ) x y = x +. y
  let ( - ) x y = x -. y
  let ( * ) x y = x *. y
  let ( / ) x y = x /. y
  let mk = float
  let mf x = x
  let pr x = Printf.sprintf "%.12e" x
end

(* Low precision floating point type. *)
module FL : SCALAR = struct
  type t = float
  let pr x = Printf.sprintf "%.2e" x
  let mf x =
    if x = 0.0 then 0.0 else
      let k = truncate(log(abs_float x)) in
      let x' = exp(6. -. float k) in floor(x *. x' +. 0.5) /. x'
  let mk x = mf (float x)
  let ( + ) x y = mf (x +. y)
  let ( - ) x y = mf (x -. y)
  let ( * ) x y = mf (x *. y)
  let ( / ) x y = mf (x /. y)
end

(* Complex numbers on the field [F].  Overflow is not handled. *)
module C(F : SCALAR) = struct
  type t = { re: F.t; im: F.t }
  let mk a = { re = F.mk a;  im = F.mk 0 }
  let mf a = { re = F.mf a;  im = F.mk 0 }
  let mc a b = { re = a; im = b }
  let pr a = F.pr a.re ^ " " ^ F.pr a.im

  open F
  let ( + ) a b = { re = a.re + b.re;  im = a.im + b.im }
  and ( - ) a b = { re = a.re - b.re;  im = a.im - b.im }
  and ( * ) a b = { re = a.re * b.re - a.im * b.im;
		    im = a.re * b.im + a.im * b.re }
  and ( / ) a b =
    let mag = b.re * b.re + b.im * b.im in
    { re = (a.re * b.re + a.im * b.im) / mag;
      im = (a.im * b.re - a.re * b.im) / mag }
end

module Functions(F : SCALAR) = struct
  let f0 = F.mk 0 and f1 = F.mk 1 and f2 = F.mk 2 and f3 = F.mk 3
  let f5 = F.mk 5 and f6 = F.mk 6 and f7 = F.mk 7
  let sqr x = F.( * ) x x
  let rec ( ** ) x k =
    if k = 0 then f1
    else if k mod 2 = 0 then sqr(x**(k/2)) else F.( * ) x (x**(k-1))

  open F
  let rat x = ((f2 * x + f3 * x**2 + f7 * x**6 + f5 * x**11 + f1)
	       / (f5 * x - f6 * x**3 - f3 * x**7 + f2))

  (* Automatic differentiation type on the field [F]. *)
  module AD = struct
    type t = { x : F.t; dx : F.t }
    let mk i = { x = F.mk i; dx = f0 }
    let mf x = { x = F.mf x; dx = f0 }
    let pr a = pr a.x ^ " " ^ pr a.dx
    let vr y dy = { x = y; dx = dy }
    let ( + ) a b = { x = a.x + b.x;  dx = a.dx + b.dx }
    and ( - ) a b = { x = a.x - b.x;  dx = a.dx - b.dx }
    and ( * ) a b = { x = a.x * b.x;  dx = a.dx * b.x + a.x * b.dx }
    and ( / ) a b = { x = a.x/b.x; dx = (a.dx*b.x-a.x*b.dx)/(b.x*b.x) }

    let newton x0 n g =
      let x = ref x0 in
      for i = 1 to n do
	let v = g(vr !x f1) in
	x := F.(-) !x (F.(/) v.x v.dx)
      done; !x

    let trapezoid_method_rooter gad gf y0 t0 t1 =
      let vt1 = vr t1 f0
      and dt2 = vr (F.(/) (F.(-) t1 t0) f2) f0
      and vy0 = vr y0 f0
      and vg0 = vr (gf t0 y0) f0 in
      fun y1 -> (gad vt1 y1 + vg0) * dt2 + vy0 - y1

    let trapezoid_method t0 dt y0 gad gf numsteps =
      let y = ref y0 and t = ref t0 in
      for i = 1 to numsteps do
	y := newton !y 10 (trapezoid_method_rooter gad gf !y !t (F.(+) !t dt));
	t := F.(+) !t dt;
      done; !y
  end
end

module Integrate_functions(F : SCALAR) = struct
  module Funs = Functions(F)
  module AD = Funs.AD
  module ADFuns = Functions(AD)
  open F

  let sqrintegrandad t y = ADFuns.sqr y
  let sqrintegrandf t y = Funs.sqr y
  let ratintegrandad t y = AD.(-) (ADFuns.rat y) t
  let ratintegrandf t y = Funs.rat y -  t
  let integrate_functions x0 n =
    let integ f df = AD.trapezoid_method (mk 1) (mk 1 / mk n) x0 f df n in
    print_string ("i1 " ^ (pr (integ sqrintegrandad sqrintegrandf)) ^"\n");
    print_string ("i2 " ^ (pr (integ ratintegrandad ratintegrandf)) ^"\n")
  end

module Funs = Functions(FL64)
module AD = Funs.AD
module ADFuns = Functions(AD)

let mysqrt x = AD.(-) (ADFuns.sqr x) (AD.mk 2)
let () =
  let f1 = FL64.mk 1 in
  print_string("rational_taylor_series: " ^
		 (AD.pr (ADFuns.rat (AD.vr (FL64.mf 0.25) f1))) ^ "\n");
  print_string("newton-sqrt_2: " ^ (FL64.pr (AD.newton f1 10 mysqrt)) ^ "\n");
  print_string("newton-rat: " ^
		 (FL64.pr (AD.newton (FL64.mk (-1)) 6 ADFuns.rat)) ^ "\n")

let n = int_of_string(Array.get Sys.argv 1)
let pfl64 = FL64.mf 0.02
let pfl = FL.mf 0.02
module I1 = Integrate_functions(FL64)
module I2 = Integrate_functions(FL)
let () =
  I1.integrate_functions pfl64 (n*4);
  I2.integrate_functions pfl n

module CFL64 = C(FL64)
module CFL = C(FL)
module I3 = Integrate_functions(CFL64)
module I4 = Integrate_functions(CFL)
let () =
  I3.integrate_functions (CFL64.mc pfl64 pfl64) n;
  I4.integrate_functions (CFL.mc pfl pfl) n

@head(1,'[knucleotide]')
@for i in machs:
  showgraph(i,'ack','knucleotide on '+i)
  showdata('speed/machine/'+i+'/rankings/knucleotide.txt')

@select(tangler('speed/specs/knucleotide.py'))
descr='knucleotide'
min=5
max=10

@select(tangler('speed/src/c/knucleotide.c'))
/* The Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by Josh Goldfoot
   to compile, use gcc -O3

   This revision uses "simple_hash.h," available from
   http://cvs.alioth.debian.org/cgi-bin/cvsweb.cgi/shootout/bench/Include/?cvsroot=shootout

*/
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdlib.h>
#include "../../Include/simple_hash.h"

long
hash_table_size (int fl, long buflen)
{
  long maxsize1, maxsize2;

  maxsize1 = buflen - fl;
  maxsize2 = 4;
  while (--fl > 0 && maxsize2 < maxsize1)
    maxsize2 = maxsize2 * 4;
  if (maxsize1 < maxsize2)
    return maxsize1;
  return maxsize2;
}

struct ht_ht *
generate_frequencies (int fl, char *buffer, long buflen)
{
  struct ht_ht *ht;
  char *reader;
  long i;
  char nulled;

  if (fl > buflen)
    return NULL;

  ht = ht_create (hash_table_size (fl, buflen));
  for (i = 0; i < buflen - fl + 1; i++)
    {
      reader = &(buffer[i]);
      nulled = reader[fl];
      reader[fl] = 0x00;
      ht_find_new (ht, reader)->val++;
      reader[fl] = nulled;
    }
  return ht;
}

typedef struct ssorter
{
  char *string;
  int num;
} sorter;

void
write_frequencies (int fl, char *buffer, long buflen)
{
  struct ht_ht *ht;
  long total, i, j, size;
  struct ht_node *nd;
  sorter *s;
  sorter tmp;

  ht = generate_frequencies (fl, buffer, buflen);
  total = 0;
  size = 0;
  for (nd = ht_first (ht); nd != NULL; nd = ht_next (ht))
    {
      total = total + nd->val;
      size++;
    }
  s = calloc (size, sizeof (sorter));
  i = 0;
  for (nd = ht_first (ht); nd != NULL; nd = ht_next (ht))
    {
      s[i].string = nd->key;
      s[i++].num = nd->val;
    }
  for (i = 0; i < size - 1; i++)
    for (j = i + 1; j < size; j++)
      if (s[i].num < s[j].num)
	{
	  memcpy (&tmp, &(s[i]), sizeof (sorter));
	  memcpy (&(s[i]), &(s[j]), sizeof (sorter));
	  memcpy (&(s[j]), &tmp, sizeof (sorter));
	}
  for (i = 0; i < size; i++)
    printf ("%s %.3f\n", s[i].string, 100 * (float) s[i].num / total);
  printf ("\n");
  ht_destroy (ht);
  free (s);
}

void
write_count (char *searchFor, char *buffer, long buflen)
{
  struct ht_ht *ht;

  ht = generate_frequencies (strlen (searchFor), buffer, buflen);
  printf ("%d\t%s\n", ht_find_new (ht, searchFor)->val, searchFor);
  ht_destroy (ht);
}

int
main ()
{
  char c;
  char *line, *buffer, *tmp, *x;
  int i, linelen, nothree;
  long buflen, seqlen;

  line = malloc (256);
  if (!line)
    return -1;
  seqlen = 0;
  nothree = 1;

  while (nothree && fgets (line, 255, stdin))
    if (line[0] == '>' && line[1] == 'T' && line[2] == 'H')
      nothree = 0;
  free (line);

  buflen = 10240;
  buffer = malloc (buflen + 1);
  if (!buffer)
    return -1;
  x = buffer;

  while (fgets (x, 255, stdin))
    {
      linelen = strlen (x);
      if (linelen)
	{
	  if (x[linelen - 1] == '\n')
	    linelen--;
	  c = x[0];
	  if (c == '>')
	    break;
	  else if (c != ';')
	    {
	      seqlen = seqlen + linelen;
	      if (seqlen + 512 >= buflen)
		{
		  buflen = buflen + 10240;
		  tmp = realloc (buffer, buflen + 1);
		  if (tmp == NULL)
		    return -1;
		  buffer = tmp;
		  x = &(buffer[seqlen]);
		}
	      else
		x = &(x[linelen]);
	      x[0] = 0;
	    }
	}
    }
  for (i = 0; i < seqlen; i++)
    buffer[i] = toupper (buffer[i]);
  write_frequencies (1, buffer, seqlen);
  write_frequencies (2, buffer, seqlen);
  write_count ("GGT", buffer, seqlen);
  write_count ("GGTA", buffer, seqlen);
  write_count ("GGTATT", buffer, seqlen);
  write_count ("GGTATTTTAATT", buffer, seqlen);
  write_count ("GGTATTTTAATTTATAGT", buffer, seqlen);
  free (buffer);
  return 0;
}

@select(tangler('speed/src/ada/knucleotide.ada'))
-------------------------------------------------------------------------------
--  The Computer Language Shootout http://shootout.alioth.debian.org/
--
--  Contributed by Martin Krischik
-------------------------------------------------------------------------------

pragma Ada_95;

--  Standart set of performance improving pragmas as suggested by the GNAT users manual.
pragma Restrictions (Max_Asynchronous_Select_Nesting => 0);
pragma Restrictions (No_Abort_Statements);
pragma Restrictions (No_Finalization);

with Ada.Characters.Handling;
with Ada.Characters.Latin_1;
with Ada.Integer_Text_IO;
with Ada.IO_Exceptions;
with Ada.Float_Text_IO;
with Ada.Strings.Bounded;
with Ada.Text_IO;

--  The shootout is using an old Ada 95 compiler so only the GNAT hash tables and sort are
--  available. As soon as the new Ada 2005 compiler is available we can use Ada.Containers which
--  are more high level and should reduce the LOC significantly and make the programm more
--  "plain vanilla".
with GNAT.Heap_Sort_G;
with GNAT.HTable;

procedure KNucleotide is
   subtype Frequencies is Integer range 1 .. 18;

   package Fragments is new Ada.Strings.Bounded.Generic_Bounded_Length (Frequencies'Last);

   use type Fragments.Bounded_String;

   subtype Fragment is Fragments.Bounded_String;

   ----------------------------------------------------------------------------
   --
   --  Read data from Standart_Input and return the section THREE as String
   --
   function Read return String;

   ----------------------------------------------------------------------------
   --
   --  Calculate and write data - either a percentage for all fragments found or - when
   --  Nucleotide_Fragment is given - the count for that fragment.
   --
   procedure Write
     (Nucleotide_Length   : in Frequencies;
      Nucleotide_Fragment : in Fragment := Fragments.Null_Bounded_String);

   ----------------------------------------------------------------------------
   --
   --  List of fragments to be analyzed for this test
   --
   Fragment_3  : constant Fragment := Fragments.To_Bounded_String ("GGT");
   Fragment_4  : constant Fragment := Fragments.To_Bounded_String ("GGTA");
   Fragment_6  : constant Fragment := Fragments.To_Bounded_String ("GGTATT");
   Fragment_12 : constant Fragment := Fragments.To_Bounded_String ("GGTATTTTAATT");
   Fragment_18 : constant Fragment := Fragments.To_Bounded_String ("GGTATTTTAATTTATAGT");

   ----------------------------------------------------------------------------
   --
   --  Read data from Standart_Input and return the section THREE as String
   --
   function Read return String is
      -------------------------------------------------------------------------
      --
      --  Skip data on Standart_Input until ">THREE" is found
      --
      procedure Skip_To_Section;

      -------------------------------------------------------------------------
      --
      --  Read next data section - until EOF oder a line beginning with > is found
      --
      function Read_Section return String;

      pragma Inline (Read_Section);
      pragma Inline (Skip_To_Section);

      Section_Marker : constant Character := '>';
      Section        : constant String    := Section_Marker & "THREE";

      -------------------------------------------------------------------------
      --
      --  Read next data section - until EOF oder a line beginning with > is found.
      --
      function Read_Section return String is
         --
         --  We are using a recursive read function which won't need any heap storage. For
         --  fairness sake we use the same initial buffer size as the C demo.
         --
         Buffer     : String (1 .. 10240);
         Read_First : Natural := Buffer'First;
         Read_Last  : Natural := Buffer'First;
      begin
         loop
            Ada.Text_IO.Get_Line
              (Item => Buffer (Read_First .. Buffer'Last),
               Last => Read_Last);
            exit when Buffer (Read_First) = Section_Marker;
            if Read_Last = Buffer'Last then
               return Buffer & Read_Section;
            end if;
            Read_First := Read_Last + 1;
         end loop;
         return Buffer (1 .. Read_Last);
      exception
         when Ada.IO_Exceptions.End_Error =>
            return Buffer (1 .. Read_Last);
      end Read_Section;

      ------------------------------------------------------------------------
      --
      --  Skip data on Standart_Input until ">THREE" is found
      --
      procedure Skip_To_Section is
         --
         --  The line lenght of the test data is 60 character. Note: Get_Line would survive
         --  longer lines as well - they would just be read in two parts.
         --
         Line      : String (1 .. 60);
         Read_Last : Natural;
      begin
         loop
            Ada.Text_IO.Get_Line (Item => Line, Last => Read_Last);
            exit when Line (1 .. 6) = Section;
         end loop;
      end Skip_To_Section;

   begin
      Skip_To_Section;
      return Ada.Characters.Handling.To_Upper (Read_Section);
   end Read;

   ---------------------------------------------------------------------------
   --
   --  Data read as single String
   --
   Buffer : constant String := Read;

   ----------------------------------------------------------------------------
   --
   --  Calculate and write data - either a percentage for all fragments found or - when
   --  Nucleotide_Fragment is given - the count for that fragment.
   --
   procedure Write
     (Nucleotide_Length   : in Frequencies;
      Nucleotide_Fragment : in Fragment := Fragments.Null_Bounded_String)
   is
      ------------------------------------------------------------------------
      --
      --  The Calculator package calculates the nucleotide frequencies and keeps the result
      --  inside a hash table as requested by the shootout rules.
      --
      package Calculator is
         ---------------------------------------------------------------------
         --
         --  Elements used to store inside hash table
         --
         type Element_Type is private;
         type Element_Access is access Element_Type;
         for Element_Access'Storage_Size use 16#60_00_00#;

         ---------------------------------------------------------------------
         --
         --  Calculate the calculates the nucleotide frequencies
         --
         procedure Calculate_Frequencies (Length : Frequencies);

         ---------------------------------------------------------------------
         --
         --  Get the count for the given nucleotide fragment
         --
         function Get (Nucleotide_Fragment : Fragment) return Natural;

         ---------------------------------------------------------------------
         --
         --  Start to iterate over all element of hash table
         --
         function Get_First return Element_Access;

         ---------------------------------------------------------------------
         --
         --  Continue itereation over the hash table
         --
         function Get_Next return Element_Access;

         ---------------------------------------------------------------------
         --
         --  Get count for element
         --
         function Count (Element : Element_Access) return Natural;

         ---------------------------------------------------------------------
         --
         --  Get key for element
         --
         function Key (Element : Element_Access) return Fragment;

         ---------------------------------------------------------------------
         --
         --  Get total count over all elements - as well as the count of elements
         --
         procedure Get_Total (Total : out Natural; Count : out Natural);

         pragma Inline (Calculate_Frequencies);
         pragma Inline (Get);
         pragma Inline (Get_First);
         pragma Inline (Get_Next);
         pragma Inline (Count);
         pragma Inline (Key);
         pragma Inline (Get_Total);
      private
         ---------------------------------------------------------------------
         --
         --  Elements used to store inside hash table.
         --
         type Element_Type is record
            Count : Natural        := 0;
            Key   : Fragment       := Fragments.Null_Bounded_String;
            Next  : Element_Access := null;
         end record;
      end Calculator;

      package body Calculator is
         type Hash_Type is range 0 .. 2 ** 16;

         function Hash (Key : Fragment) return Hash_Type;
         procedure Set_Next (E : Element_Access; Next : Element_Access);
         function Next (E : Element_Access) return Element_Access;
         function Get_Key (E : Element_Access) return Fragment;

         pragma Inline (Hash);
         pragma Inline (Set_Next);
         pragma Inline (Next);
         pragma Inline (Get_Key);

         package Table is new GNAT.HTable.Static_HTable (
            Header_Num => Hash_Type,
            Element => Element_Type,
            Elmt_Ptr => Element_Access,
            Null_Ptr => null,
            Key => Fragment,
            Hash => Hash,
            Equal => Fragments. "=",
            Set_Next => Set_Next,
            Next => Next,
            Get_Key => Get_Key);

         function Hash_Function is new GNAT.HTable.Hash (Header_Num => Hash_Type);

         ---------------------------------------------------------------------
         --
         --  Calculate the calculates the nucleotide frequencies
         --
         procedure Calculate_Frequencies (Length : Frequencies) is
         begin
            Table.Reset;
            for I in  1 .. Buffer'Last - Integer (Length) + 1 loop
               declare
                  Key     : constant Fragment       :=
                     Fragments.To_Bounded_String (Buffer (I .. I + Length - 1));
                  Element : constant Element_Access := Table.Get (Key);
               begin
                  if Element /= null then
                     Element.all.Count := Natural'Succ (Element.all.Count);
                  else
                     Table.Set (new Element_Type'(Count => 1, Key => Key, Next => null));
                  end if;
               end;
            end loop;
            return;
         end Calculate_Frequencies;

         ---------------------------------------------------------------------
         --
         --  Get count for element
         --
         function Count (Element : Element_Access) return Natural is
         begin
            return Element.all.Count;
         end Count;

         ---------------------------------------------------------------------
         --
         --  Get the count for the given nucleotide fragment
         --
         function Get (Nucleotide_Fragment : Fragment) return Natural is
            The_Element : constant Element_Access := Table.Get (Nucleotide_Fragment);
         begin
            if The_Element /= null then
               return The_Element.all.Count;
            else
               return 0;
            end if;
         end Get;

         ---------------------------------------------------------------------
         --
         --  Start to iterate over all element of hash table
         --
         function Get_First return Element_Access is
         begin
            return Table.Get_First;
         end Get_First;

         ---------------------------------------------------------------------
         --
         --  Get key for element
         --
         function Get_Key (E : Element_Access) return Fragment is
         begin
            return E.all.Key;
         end Get_Key;

         ---------------------------------------------------------------------
         --
         --  Continue itereation over the hash table
         --
         function Get_Next return Element_Access is
         begin
            return Table.Get_Next;
         end Get_Next;

         ---------------------------------------------------------------------
         --
         --  Get total count over all elements - as well as the count of elements
         --
         procedure Get_Total (Total : out Natural; Count : out Natural) is
            The_Element : Element_Access := Table.Get_First;
         begin
            Total := 0;
            Count := 0;
            while The_Element /= null loop
               Total       := Total + The_Element.all.Count;
               Count       := Count + 1;
               The_Element := Table.Get_Next;
            end loop;
         end Get_Total;

         function Hash (Key : Fragment) return Hash_Type is
         begin
            return Hash_Function (Fragments.To_String (Key));
         end Hash;

         ---------------------------------------------------------------------
         --
         --  Get key for element
         --
         function Key (Element : in Element_Access) return Fragment is
         begin
            return Element.all.Key;
         end Key;

         function Next (E : Element_Access) return Element_Access is
         begin
            return E.all.Next;
         end Next;

         procedure Set_Next (E : Element_Access; Next : Element_Access) is
         begin
            E.all.Next := Next;
         end Set_Next;
      end Calculator;

   begin
      Calculator.Calculate_Frequencies (Nucleotide_Length);

      if Nucleotide_Fragment = Fragments.Null_Bounded_String then
         Calculate_Total : declare
            Count : Natural;
            Total : Natural;
         begin
            Calculator.Get_Total (Total => Total, Count => Count);

            Get_Sort_Put : declare
               Data : array (0 .. Count) of Calculator.Element_Access;

               procedure Move (From : Natural; To : Natural);
               function Less_Then (Op1, Op2 : Natural) return Boolean;

               pragma Inline (Move);
               pragma Inline (Less_Then);

               package Heap_Sort is new GNAT.Heap_Sort_G (Move => Move, Lt => Less_Then);

               function Less_Then (Op1, Op2 : Natural) return Boolean is
               begin
                  return Calculator.Count (Data (Op1)) > Calculator.Count (Data (Op2));
               end Less_Then;

               procedure Move (From : Natural; To : Natural) is
               begin
                  Data (To) := Data (From);
               end Move;
            begin
               Data (0) := null;
               Data (1) := Calculator.Get_First;

               for I in  2 .. Data'Last loop
                  Data (I) := Calculator.Get_Next;
               end loop;

               Heap_Sort.Sort (Data'Last);

               for I in  1 .. Data'Last loop
                  Ada.Text_IO.Put (Fragments.To_String (Calculator.Key (Data (I))));
                  Ada.Text_IO.Put (Ada.Characters.Latin_1.Space);
                  Ada.Float_Text_IO.Put
                    (Item => 100.0 * Float (Calculator.Count (Data (I))) / Float (Total),
                     Fore => 1,
                     Aft  => 3,
                     Exp  => 0);
                  Ada.Text_IO.New_Line;
               end loop;
               Ada.Text_IO.New_Line;
            end Get_Sort_Put;
         end Calculate_Total;
      else
         Ada.Integer_Text_IO.Put (Item => Calculator.Get (Nucleotide_Fragment), Width => 1);
         Ada.Text_IO.Put (Ada.Characters.Latin_1.HT);
         Ada.Text_IO.Put_Line (Fragments.To_String (Nucleotide_Fragment));
      end if;
      return;
   end Write;

begin
   Write (1);
   Write (2);
   Write (Fragments.Length (Fragment_3), Fragment_3);
   Write (Fragments.Length (Fragment_4), Fragment_4);
   Write (Fragments.Length (Fragment_6), Fragment_6);
   Write (Fragments.Length (Fragment_12), Fragment_12);
   Write (Fragments.Length (Fragment_18), Fragment_18);
   return;
end KNucleotide;

-------------------------------------------------------------------------------
--   vim: textwidth=0 nowrap tabstop=8 shiftwidth=3 softtabstop=3 expandtab vim: filetype=ada
--   encoding=latin1 fileformat=unix

@head(1,'[lists]')
@for i in machs:
  showgraph(i,'ack','lists on '+i)
  showdata('speed/machine/'+i+'/rankings/lists.txt')

@select(tangler('speed/specs/lists.py'))
descr='lists'
min=5
max=10

@select(tangler('speed/src/c/lists.c'))
/* -*- mode: c -*-
 * $Id: lists.gcc,v 1.1.1.1 2004-05-19 18:10:23 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define SIZE 10000

// a simple Double Linked List
// the head node is special, it's val is length of list
typedef struct DLL {
    int val;
    struct DLL *next;	/* points to next or head (if at tail) */
    struct DLL *prev;	/* points to prev or tail (if at head) */
} DLL;

inline int list_length(DLL *head) { return(head->val); }
inline int list_empty(DLL *head) { return(list_length(head) == 0); }
inline DLL *list_first(DLL *head) { return(head->next); }
inline DLL *list_last(DLL *head) { return(head->prev); }

void list_push_tail(DLL *head, DLL *item) {
    DLL *tail = head->prev;
    tail->next = item;
    item->next = head;
    head->prev = item;
    item->prev = tail;
    head->val++;
}

DLL *list_pop_tail(DLL *head) {
    DLL *prev, *tail;
    if (list_empty(head)) return(NULL);
    tail = head->prev;
    prev = tail->prev;
    prev->next = head;
    head->prev = prev;
    head->val--;
    return(tail);
}

void list_push_head(DLL *head, DLL *item) {
    DLL *next = head->next;
    head->next = item;
    next->prev = item;
    item->next = next;
    item->prev = head;
    head->val++;
}

DLL *list_pop_head(DLL *head) {
    DLL *next;
    if (list_empty(head)) return(NULL);
    next = head->next;
    head->next = next->next;
    next->next->prev = head;
    head->val--;
    return(next);
}

int list_equal(DLL *x, DLL *y) {
    DLL *xp, *yp;
    // first val's checked will be list lengths
    for (xp=x, yp=y; xp->next != x; xp=xp->next, yp=yp->next) {
	if (xp->val != yp->val) return(0);
    }
    if (xp->val != yp->val) return(0);
    return(yp->next == y);
}

void list_print(char *msg, DLL *x) {
    DLL *xp, *first = x->next;
    int i = 0;
    fputs(msg, stdout);
    printf("length: %d\n", list_length(x));
    for (xp=x->next; xp->next != first; xp=xp->next) {
	printf("i:%3d  v:%3d  n:%3d  p:%3d\n", ++i,
	       xp->val, xp->next->val, xp->prev->val);
    }
    printf("[last entry points to list head]\n");
    printf("[val of next of tail is:  %d]\n", xp->next->val);
}

DLL *list_new() {
    DLL *l = (DLL *)malloc(sizeof(DLL));
    l->next = l;
    l->prev = l;
    l->val = 0;
    return(l);
}

/* inclusive sequence 'from' <-> 'to' */
DLL *list_sequence(int from, int to) {
    int size, tmp, i, j;
    DLL *l;
    if (from > to) {
	tmp = from; from = to; to = tmp;
    }
    size = to - from + 1;
    l = (DLL *)malloc((size+1) * sizeof(DLL));
    from--;
    for (i=0, j=1; i<size; ++i, ++j) {
	l[i].next = &l[i+1];
	l[j].prev = &l[j-1];
	l[i].val = from++;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].prev = &l[size-1];
    l[size].val = from;
    l[0].val = size;
    return(l);
}

DLL *list_copy(DLL *x) {
    int i, j, size = list_length(x);
    DLL *xp, *l = (DLL *)malloc((size+1) * sizeof(DLL));
    for (i=0, j=1, xp=x; i<size; i++, j++, xp=xp->next) {
	l[i].next = &l[j];
	l[j].prev = &l[i];
	l[i].val = xp->val;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].val = list_last(x)->val;
    return(l);
}

void list_reverse (DLL *head) {
    DLL *tmp, *p = head;
    do {
	tmp = p->next;
	p->next = p->prev;
	p->prev = tmp;
	p = tmp;
    } while (p != head);
}

int test_lists() {
    int len = 0;
    // create a list of integers (li1) from 1 to SIZE
    DLL *li1 = list_sequence(1, SIZE);
    // copy the list to li2
    DLL *li2 = list_copy(li1);
    // remove each individual item from left side of li2 and
    // append to right side of li3 (preserving order)
    DLL *li3 = list_new();
    // compare li2 and li1 for equality
    if (!list_equal(li2, li1)) {
	fprintf(stderr, "li2 and li1 are not equal\n");
	exit(1);
    }
    while (!list_empty(li2)) {
	list_push_tail(li3, list_pop_head(li2));
    }
    // li2 must now be empty
    if (!list_empty(li2)) {
	fprintf(stderr, "li2 should be empty now\n");
	exit(1);
    }
    // remove each individual item from right side of li3 and
    // append to right side of li2 (reversing list)
    while (!list_empty(li3)) {
	list_push_tail(li2, list_pop_tail(li3));
    }
    // li3 must now be empty
    if (!list_empty(li3)) {
	fprintf(stderr, "li3 should be empty now\n");
	exit(1);
    }
    // reverse li1 in place
    list_reverse(li1);
    // check that li1's first item is now SIZE
    if (list_first(li1)->val != SIZE) {
	fprintf(stderr, "li1 first value wrong, wanted %d, got %d\n",
		SIZE, list_first(li1)->val);
	exit(1);
    }
    // check that li1's last item is now 1
    if (list_last(li1)->val != 1) {
	fprintf(stderr, "last value wrong, wanted %d, got %d\n",
		SIZE, list_last(li1)->val);
	exit(1);
    }
    // check that li2's first item is now SIZE
    if (list_first(li2)->val != SIZE) {
	fprintf(stderr, "li2 first value wrong, wanted %d, got %d\n",
		SIZE, list_first(li2)->val);
	exit(1);
    }
    // check that li2's last item is now 1
    if (list_last(li2)->val != 1) {
	fprintf(stderr, "last value wrong, wanted %d, got %d\n",
		SIZE, list_last(li2)->val);
	exit(1);
    }
    // check that li1's length is still SIZE
    if (list_length(li1) != SIZE) {
	fprintf(stderr, "li1 size wrong, wanted %d, got %d\n",
		SIZE, list_length(li1));
	exit(1);
    }
    // compare li1 and li2 for equality
    if (!list_equal(li1, li2)) {
	fprintf(stderr, "li1 and li2 are not equal\n");
	exit(1);
    }
    len = list_length(li1);
    free(li1);
    free(li2);
    free(li3);
    // return the length of the list
    return(len);
}

int main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int result = 0;
    while(n--) result = test_lists();
    printf("%d\n", result);
    return 0;
}

@select(tangler('speed/src/ocaml/lists.ml'))
(*
 * $Id: lists.ocaml,v 1.1.1.1 2004-05-19 18:10:23 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Benedict Rosenau
 * improved by Jean-Christophe Filliatre
 *)

module Deque = struct
  type t = { size: int; mutable first: int; mutable last: int; fld: int array }

  exception Empty
  exception Full

  let empty n =
    let n = max (succ n) 1 in
    { size = n; first = 0; last = 0; fld = Array.make n 0 }

  let iota n =
    let size = succ n in
    { size = size; first = 0; last = n; fld = Array.init size succ }

  let up n s = if n < 0 then n + s else n
  let down n s = if n >= s then n - s else n
  let one_up n s = if n == s - 1 then 0 else n + 1
  let one_down n s = if n == 0 then s - 1 else n - 1

  let length q = up (q.last - q.first) q.size

  let rec array_eq q1 off1 q2 off2 n =
    n == 0 ||
      q1.fld.(off1) == q2.fld.(off2) &&
      (array_eq q1 (one_up off1 q1.size) q2 (one_up off2 q2.size) (n - 1))

  let equal q1 q2 =
    let len1 = length q1 in
    len1 == length q2 && array_eq q1 q1.first q2 q2.first len1

  let nth q n =
    if n < 0 or n >= length q then failwith "nth";
    q.fld.(down (q.first + n) q.size)

  let push_back q elem =
    let last' = one_up q.last q.size in
    if last' == q.first then raise Full;
    q.fld.(q.last) <- elem;
    q.last <- last'

  let take_front q =
    if q.first == q.last then raise Empty;
    let old_first = q.first in
    q.first <- one_up q.first q.size;
    q.fld.(old_first)

  let take_back q =
    if q.first == q.last then raise Empty;
    let new_last = one_down q.last q.size in
    q.last <- new_last;
    q.fld.(new_last)

  let copy q =
    { size = q.size; first = q.first; last = q.last; fld = Array.copy q.fld }

  let reverse q =
    let w = length q in
    for i = 0 to (w lsr 1) - 1 do
      let i1 = down (q.first + i) q.size and i2 = up (q.last - 1 - i) q.size in
      let v1 = q.fld.(i1) in
      q.fld.(i1) <- q.fld.(i2);
      q.fld.(i2) <- v1
    done
end

let test_lists () =
  let size = 10000 in
  let d1 = Deque.iota size in
  let d2 = Deque.copy d1
  and d3 = Deque.empty size in
  for i = 1 to Deque.length d2 do Deque.push_back d3 (Deque.take_front d2) done;
  for i = 1 to Deque.length d3 do Deque.push_back d2 (Deque.take_back d3) done;
  Deque.reverse d1;
  if size <> Deque.nth d1 0 then failwith "First test failed";
  if Deque.length d1 <> Deque.length d2 then failwith "Second test failed";
  if not (Deque.equal d1 d2) then failwith "Third test failed";
  Deque.length d1

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
for i = 2 to n do ignore (test_lists ()) done;
Printf.printf "%d\n" (test_lists ())

@select(tangler('speed/src/felix/lists.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
// Adapted from C solution

header """
// a simple Double Linked List
// the head node is special, it's val is length of list
struct DLL {
    int val;
    struct DLL *next;        /* points to next or head (if at tail) */
    struct DLL *prev;        /* points to prev or tail (if at head) */
};
""";

body """
inline int len(DLL *head) { return(head->val); }
inline int empty(DLL *head) { return(len(head) == 0); }
inline DLL *first(DLL *head) { return(head->next); }
inline DLL *last(DLL *head) { return(head->prev); }

void push_tail(DLL *head, DLL *item) {
    DLL *tail = head->prev;
    tail->next = item;
    item->next = head;
    head->prev = item;
    item->prev = tail;
    head->val++;
}

DLL *pop_tail(DLL *head) {
    DLL *prev, *tail;
    if (empty(head)) return(NULL);
    tail = head->prev;
    prev = tail->prev;
    prev->next = head;
    head->prev = prev;
    head->val--;
    return(tail);
}

void push_head(DLL *head, DLL *item) {
    DLL *next = head->next;
    head->next = item;
    next->prev = item;
    item->next = next;
    item->prev = head;
    head->val++;
}

DLL *pop_head(DLL *head) {
    DLL *next;
    if (empty(head)) return(NULL);
    next = head->next;
    head->next = next->next;
    next->next->prev = head;
    head->val--;
    return(next);
}

int list_equal(DLL *x, DLL *y) {
    DLL *xp, *yp;
    // first val's checked will be list lengths
    for (xp=x, yp=y; xp->next != x; xp=xp->next, yp=yp->next) {
        if (xp->val != yp->val) return(0);
    }
    if (xp->val != yp->val) return(0);
    return(yp->next == y);
}

DLL *list_new() {
    DLL *l = (DLL *)malloc(sizeof(DLL));
    l->next = l;
    l->prev = l;
    l->val = 0;
    return(l);
}

/* inclusive sequence 'from' <-> 'to' */
DLL *list_sequence(int from, int to) {
    int size, tmp, i, j;
    DLL *l;
    if (from > to) {
        tmp = from; from = to; to = tmp;
    }
    size = to - from + 1;
    l = (DLL *)malloc((size+1) * sizeof(DLL));
    from--;
    for (i=0, j=1; i<size; ++i, ++j) {
        l[i].next = &l[i+1];
        l[j].prev = &l[j-1];
        l[i].val = from++;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].prev = &l[size-1];
    l[size].val = from;
    l[0].val = size;
    return(l);
}

DLL *copy(DLL *x) {
    int i, j, size = len(x);
    DLL *xp, *l = (DLL *)malloc((size+1) * sizeof(DLL));
    for (i=0, j=1, xp=x; i<size; i++, j++, xp=xp->next) {
        l[i].next = &l[j];
        l[j].prev = &l[i];
        l[i].val = xp->val;
    }
    l[0].prev = &l[size];
    l[size].next = &l[0];
    l[size].val = last(x)->val;
    return(l);
}

void rev (DLL *head) {
    DLL *tmp, *p = head;
    do {
        tmp = p->next;
        p->next = p->prev;
        p->prev = tmp;
        p = tmp;
    } while (p != head);
}
""";

type DLL_head = "DLL*";
type DLL_item = "DLL*";

fun get: DLL_item -> int = "$1->val";

fun len: DLL_head -> int;
fun empty: DLL_head -> bool;

fun non_empty(x:DLL_head)=> not (empty x);

fun first: DLL_head -> DLL_item;
fun last: DLL_head -> DLL_item;

proc push_tail: DLL_head * DLL_item;
fun pop_tail: DLL_head -> DLL_item;
proc push_head: DLL_head * DLL_item;

fun pop_head: DLL_head -> DLL_item;
fun eq: DLL_head * DLL_head -> bool = "list_equal($1,$2)";
fun ne (x:DLL_head,y:DLL_head) => not (x == y);

fun list_new: unit -> DLL_head;

/* inclusive sequence 'from' <-> 'to' */
fun list_sequence: int * int -> DLL_head;
fun copy: DLL_head -> DLL_head;

proc rev: DLL_head;
proc free: DLL_head = "std::free($1);";

proc check(cond:bool) (msg:string) {
  open System;
  open Text_file;
  if cond goto endoff;
  writeln (stderr,msg);
  exit 1;
endoff:>
}

SIZE:=10000;


var result: int;
proc test_lists() {
    var li1 = list_sequence(1, SIZE);
    var li2 = copy(li1);
    var x : DLL_item;
    check (li2 == li1) "li2 and li1 are not equal";

    // remove each individual item from left side of li2 and
    // append to right side of li3 (preserving order)
    var li3 = list_new();
    whilst non_empty li2 do
        x = pop_head li2;
        push_tail(li3, x);
    done;

    check (empty li2) "li2 should be empty now";

    // remove each individual item from right side of li3 and
    // append to right side of li2 (reversing list)
    whilst non_empty li3 do
        x = pop_tail li3;
        push_tail(li2, x);
    done;

    check (empty li3) "li3 should be empty now";

    // reverse li1 in place
    rev li1;

    check (get (first li1) == SIZE) "li1 first value wrong";
    check (get (last li1) == 1) "last value wrong";

    check (get (first li2) == SIZE) "li2 first value wrong";
    check (get (last li2) == 1) "li2 last value wrong";
    check (len li1 == SIZE) "li1 size wrong";

    // compare li1 and li2 for equality
    check (li1 == li2) "li1 and li2 are not equal";

    result = len li1;
    free li1;
    free li2;
    free li3;
}

var i = n;
until i == 0 do test_lists; --i; done;
print result; endl;


@select(tangler('speed/src/ada/lists.ada'))
-- $Id: lists.gnat,v 1.2 2005-05-13 16:24:18 igouy-guest Exp $
-- http://dada.perl.it/shootout/ 
-- by James S. Rogers
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Integer_Text_Io; use Ada.Integer_Text_IO;
with Ada.Unchecked_Deallocation;
with Ada.Command_Line; use Ada.Command_Line;

procedure Listoperations is
   pragma suppress(All_Checks);
   package Listops is
      Empty_List_Error : exception;
      type List is private;
      function Length(Item : in List) return Natural;
      function Is_Empty(Item : in List) return Boolean;
      type List_Element is private;
      type Element_Access is access List_Element;
      function First(Item : in List) return List_Element;
      function Last(Item : in List) return List_Element;
      procedure Push_Tail(Item : in out List; Element : in Integer);
      procedure Pop_Tail(Item : in out List; Element : out Integer);
      procedure Push_Head(Item : in out List; Element : in Integer);
      procedure Pop_Head(Item : in out List; Element : out Integer);
      function "="(Left, Right : in List) return Boolean;
      function New_List return List;
      function Sequence(From, To : Integer) return List;
      function Copy(Source : List) return List;
      procedure List_Reverse(Source : in out List);
      procedure Empty_List(Source : in out List);
      procedure Print(Msg : in String; Item : in List);
      function Test_Lists return Integer;
   private
      type List_Element is record
         Value : Integer := 0;
         Previous : Element_Access := null;
         Next     : Element_Access := null;
      end record;
      type List is record
         Length : Natural := 0;
         Head   : Element_Access := null;
         Tail   : Element_Access := null;
      end record;
   end Listops;

   package body Listops is
      function Length(Item : in List) return Natural is
      begin
         return Item.Length;
      end Length;
      function Is_Empty(Item : in List) return Boolean is
      begin
         return Item.Length = 0;
      end Is_Empty;
      function First(Item : List) return List_Element is
      begin
         if Is_Empty(Item) then
            raise Empty_List_Error;
         end if;
         return Item.Head.All;
      end First;
      function Last(Item : List) return List_Element is
      begin
         if Is_Empty(Item) then
            raise Empty_List_Error;
         end if;
         return Item.Tail.All;
      end Last;
      procedure Push_Tail(Item : in out List; Element : in Integer) is
         Tail : Element_Access := Item.Tail;
         Temp : Element_Access := new List_Element;
      begin
         Temp.Value := Element;
         Item.Length := Item.Length + 1;
         Item.Tail := Temp;
         if Tail /= null then
            Temp.Previous := Tail;
            Tail.Next := Temp;
         else
            Item.Head := Temp;
         end if;
      end Push_Tail;
      procedure Pop_Tail(Item : in out List; Element : out Integer) is
         procedure Free is new Ada.Unchecked_Deallocation(List_Element,
Element_Access);
         Temp : Element_Access := Item.Tail;
      begin
         if Item.Length >= 1 then
            Item.Length := Item.Length - 1;
            Element := Item.Tail.Value;
            Item.Tail := Item.Tail.Previous;
            if Item.Tail /= null then
               Item.Tail.Next := null;
            else
               Item.Head := null;
            end if;
            if Temp /= null then
               Free(Temp);
            end if;
         end if;
      end Pop_Tail;
      procedure Push_Head(Item : in out List; Element : in Integer) is
         Head : Element_Access := Item.Head;
         Temp : Element_Access := new List_Element;
      begin
         Temp.Value := Element;
         Item.Length := Item.Length + 1;
         Temp.Next := Head;
         Item.Head := Temp;
         if Head /= null then
            Head.Previous := Temp;
         else
            Item.Tail := Temp;
         end if;
      end Push_Head;
      procedure Pop_Head(Item : in out List; Element : out Integer) is
         procedure Free is new Ada.Unchecked_Deallocation(List_Element,
Element_Access);
            Head : Element_Access := Item.Head;
         begin
            if Head /= null then
               Element := Head.Value;
               Item.Head := Item.Head.Next;
               Item.Length := Item.Length - 1;
               if Item.Head = null then
                  Item.Tail := null;
               else
                  Item.Head.Previous := null;
               end if;
               Free(Head);
            end if;
         end Pop_Head;
      function "="(Left, Right : List) return Boolean is
         Left_Ptr : Element_Access := Left.Head;
         Right_Ptr : Element_Access := Right.Head;
         Result : Boolean := True;
      begin
         if Left.Length = Right.Length then
            while Left_Ptr /= null loop
               if Left_Ptr.Value /= Right_Ptr.Value then
                  Result := False;
                  exit;
               end if;
               Left_Ptr := Left_Ptr.Next;
               Right_Ptr := Right_Ptr.Next;
            end loop;
         else
            Result := False;
         end if;
         return Result;
      end "=";
      function New_List return List is
         Result : List;
      begin
         return Result;
      end New_List;
      function Sequence(From, To : Integer) return List is
         Result : List;
         Temp : Integer;
         Low : Integer := From;
         High : Integer := To;
      begin
         if From > To then
            Temp := From;
            Low := To;
            High := Temp;
         end if;
         for Val in Low..High loop
            Push_Tail(Result, Val);
         end loop;
         return Result;
      end Sequence;
      function Copy(Source : List) return List is
         Result : List;
         Source_Ptr : Element_Access := Source.Head;
      begin
         while Source_Ptr /= null loop
            Push_Tail(Item => Result, Element => Source_Ptr.Value);
            Source_Ptr := Source_Ptr.Next;
         end loop;
         return Result;
      end Copy;
      procedure List_Reverse(Source : in out List) is
         Head : Element_Access := Source.Head;
         Temp : Element_Access;
      begin
         Temp := Source.Head;
         Source.Head := Source.Tail;
         Source.Tail := Temp;
         if Head = null then
            raise Empty_List_Error;
         end if;
         loop
            Temp := Head.Next;
            Head.Next := Head.Previous;
            Head.Previous := Temp;
            Head := Temp;
            exit when Head = null;
         end loop;
      end List_Reverse;
      procedure Empty_List(Source : in out List) is
         procedure Free is new Ada.Unchecked_Deallocation(List_Element,
Element_Access);
         Source_Ptr : Element_Access := Source.Head;
         Temp : Element_Access;
      begin
         while Source_Ptr /= null loop
            Temp := Source_Ptr;
            Source_Ptr := Source_Ptr.Next;
            Free(Temp);
         end loop;
         Source := New_List;
      end Empty_List;
      procedure Print(Msg : in String; Item : in List) is
         Source_Ptr : Element_Access := Item.Head;
      begin
         Put_Line(Msg);
         Put_Line("Length:" & Integer'Image(Length(Item)));
         while Source_Ptr /= null loop
            if Source_Ptr.Previous /= null then
               Put(Item => Source_Ptr.Previous.Value, Width => 6);
            end if;
            Put(Item => Source_Ptr.Value, Width => 6);
            if Source_Ptr.Next /= null then
               Put(Item => Source_Ptr.Next.Value, Width => 6);
            end if;
            New_Line;
            Source_Ptr := Source_Ptr.Next;
         end loop;
      end Print;
      function Test_Lists return Integer is
         Size : constant Integer := 10_000;
         Li1, Li2, Li3 : List; -- all are created as empty lists
         Temp_Element : Integer;
         Len : Integer;
      begin
         -- Create a list of integers from 1 to Size
         Li1 := Sequence(1, Size);
         -- Copy the list to Li2
         Li2 := Copy(Li1);
         -- Compare Li1 and Li2 for equality
         if Li1 /= Li2 then
            Put_Line("Li1 and Li2 are not equal!");
            return -1;
         end if;
         while not Is_Empty(Li2) loop
            Pop_Head(Li2, Temp_Element);
            Push_Tail(Li3, Temp_Element);
         end loop;
         -- Li2 must be empty now
         if not Is_Empty(Li2) then
            Put_Line("Li2 should be empty now!");
            return -1;
         end if;
         -- Append each item from Li3 to Li2
         -- reversing the list
         while not Is_Empty(Li3) loop
            Pop_Tail(Li3, Temp_Element);
            Push_Tail(Li2, Temp_Element);
         end loop;
         -- Li3 must be empty now
         if not Is_Empty(Li3) then
            Put_Line("Li3 should be empty now!");
            return -1;
         end if;
         -- reverse Li1 in place
         List_Reverse(Li1);
         -- check that Li1's first item is still Size
         if First(Li1).Value /= Size then
            Put_Line("First Li1 value wrong. Wanted" & Integer'Image(Size) &
               " got" & Integer'Image(First(Li1).Value));
            return -1;
         end if;
         -- Ensure Li1 last value is now 1
         if Last(Li1).Value /= 1 then
            Put_Line("Last Li1 value wrong, wanted 1, got" &
               Integer'Image(Last(Li1).Value));
            return -1;
         end if;
         -- Check that Li2's first value is now Size
         if First(Li2).Value /= Size then
            Put_Line("First Li2 value wrong, wanted" &
               Integer'Image(Size) & " got" &
               Integer'Image(First(Li2).Value));
            return -1;
         end if;
         -- Check that Li2's last item is now 1
         if Last(Li2).Value /= 1 then
            Put_Line("Last Li2 value wrong, wanted 1");
            return -1;
         end if;
         -- Check that Li1's size is still Size
         if Length(Li1) /= Size then
            Put_Line("Li1 size wrong, wanted" &
               Integer'Image(Size) & " got" &
               Integer'Image(Length(Li1)));
            return -1;
         end if;
         -- compare Li1 and Li2 for equality
         if Li1 /= Li2 then
            Put_Line("Li1 and Li2 are not equal.");
            return -1;
         end if;
         Len := Length(Li1);
         Empty_List(Li1);
         Empty_List(Li2);
         Empty_List(Li3);
         return Len;
      end Test_Lists;
   end Listops;
   Max : Positive;
   Result : Natural;
begin
   begin
      Max := Positive'Value(Argument(1));
   exception
      when others =>
         Max := 16;
   end;
   for Iter in 1..Max loop
      Result := Listops.Test_Lists;
   end loop;
   Ada.Integer_Text_IO.Put(Item => Result, Width => 0);
   Ada.Text_IO.New_Line;
end Listoperations;



@head(1,'[magicsquares]')
@for i in machs:
  showgraph(i,'ack','magicsquares on '+i)
  showdata('speed/machine/'+i+'/rankings/magicsquares.txt')

@select(tangler('speed/specs/magicsquares.py'))
descr='magicsquares'
min=5
max=10

@head(1,'[mandelbrot]')
@for i in machs:
  showgraph(i,'ack','mandelbrot on '+i)
  showdata('speed/machine/'+i+'/rankings/mandelbrot.txt')

@select(tangler('speed/specs/mandelbrot.py'))
descr='mandelbrot'
min=5
max=10

@select(tangler('speed/src/ocaml/mandelbrot.ml'))
(*								-*tuareg-*-
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 * Enhanced by Christian Szegedy <szegedy@t-online.de>
 *             Yaron Minsky <yminsky-guest>
 *)

let niter = 50
let limit = 2.

let limit2 = limit *. limit

type complex = { mutable r: float; mutable i: float }

let add_bit0 ~tmp:z c byte =
  z.r <- 0.;
  z.i <- 0.;
  let cr = c.r and ci = c.i in
  try
    for i = 1 to niter do
      let zi = 2. *. z.r *. z.i +. ci in
      z.r <- z.r *. z.r -. z.i *. z.i +. cr;
      z.i <- zi;
      if z.r *. z.r +. zi *. zi > limit2 then raise Exit;
    done;
    (byte lsl 1) lor 0x01
  with Exit -> (byte lsl 1) lor 0x00

let () =
  let w = int_of_string(Array.get Sys.argv 1) in
  let h = w in
  let fw = float w
  and fh = float h
  and cplmt8 = 8 - w mod 8 in
  Printf.printf "P4\n%i %i\n" w h;
  let byte = ref 0
  and bit = ref 0 in
  let c = { r = 0.0; i = 0.0 } in
  let tmp = { r = 0.0; i = 0.0 } in
  for y = 0 to h - 1 do
    c.i <- 2. *. float y /. fh -. 1.;
    for x = 0 to w - 1 do
      c.r <- 2. *. float x /. fw -. 1.5;
      byte := add_bit0 ~tmp c !byte;
      incr bit;
      if !bit = 8 then (
        output_byte stdout !byte;
        byte := 0;
        bit := 0;
      )
    done;
    if !bit <> 0 then (
      output_byte stdout (!byte lsl cplmt8);
      byte := 0;
      bit := 0;
    )
  done

@head(1,'[matrix]')
@for i in machs:
  showgraph(i,'ack','matrix on '+i)
  showdata('speed/machine/'+i+'/rankings/matrix.txt')

@select(tangler('speed/specs/matrix.py'))
descr='matrix'
min=5
max=10

@select(tangler('speed/src/c/matrix.c'))
/* -*- mode: c -*-
 * $Id: matrix.gcc,v 1.1.1.1 2004-05-19 18:10:33 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#define SIZE 30

int **mkmatrix(int rows, int cols) {
    int i, j, count = 1;
    int **m = (int **) malloc(rows * sizeof(int *));
    for (i=0; i<rows; i++) {
	m[i] = (int *) malloc(cols * sizeof(int));
	for (j=0; j<cols; j++) {
	    m[i][j] = count++;
	}
    }
    return(m);
}

void zeromatrix(int rows, int cols, int **m) {
    int i, j;
    for (i=0; i<rows; i++)
	for (j=0; j<cols; j++)
	    m[i][j] = 0;
}

void freematrix(int rows, int **m) {
    while (--rows > -1) { free(m[rows]); }
    free(m);
}

int **mmult(int rows, int cols, int **m1, int **m2, int **m3) {
    int i, j, k, val;
    for (i=0; i<rows; i++) {
	for (j=0; j<cols; j++) {
	    val = 0;
	    for (k=0; k<cols; k++) {
		val += m1[i][k] * m2[k][j];
	    }
	    m3[i][j] = val;
	}
    }
    return(m3);
}

int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
	
    int **m1 = mkmatrix(SIZE, SIZE);
    int **m2 = mkmatrix(SIZE, SIZE);
    int **mm = mkmatrix(SIZE, SIZE);

    for (i=0; i<n; i++) {
	mm = mmult(SIZE, SIZE, m1, m2, mm);
    }
    printf("%d %d %d %d\n", mm[0][0], mm[2][3], mm[3][2], mm[4][4]);

    freematrix(SIZE, m1);
    freematrix(SIZE, m2);
    freematrix(SIZE, mm);
    return(0);
}

@select(tangler('speed/src/ocaml/matrix.ml'))
(*
 * $Id: matrix.ocaml,v 1.1.1.1 2004-05-19 18:10:34 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let mkmatrix rows cols =
  let count = ref 1 and last_col = cols - 1
  and m = Array.make_matrix rows cols 0 in
  for i = 0 to rows - 1 do
    let mi = m.(i) in
    for j = 0 to last_col do mi.(j) <- !count; incr count done;
  done;
  m

let rec inner_loop k v m1i m2 j =
  if k < 0 then v
  else inner_loop (k - 1) (v + m1i.(k) * m2.(k).(j)) m1i m2 j

let mmult rows cols m1 m2 m3 =
  let last_col = cols - 1 and last_row = rows - 1 in
  for i = 0 to last_row do
    let m1i = m1.(i) and m3i = m3.(i) in
    for j = 0 to last_col do m3i.(j) <- inner_loop last_row 0 m1i m2 j done;
  done

let size = 30
let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let m1 = mkmatrix size size and m2 = mkmatrix size size
let m3 = Array.make_matrix size size 0;;
for i = 2 to n do mmult size size m1 m2 m3 done;
mmult size size m1 m2 m3;
Printf.printf "%d %d %d %d\n" m3.(0).(0) m3.(2).(3) m3.(3).(2) m3.(4).(4)

@select(tangler('speed/src/felix/matrix.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
//Adapted from C++ solution.

body """
int **mkmatrix(int rows, int cols) {
  int i, j, count = 1;
  int **m = (int **) malloc(rows * sizeof(int *));
  for (i=0; i<rows; i++) {
    m[i] = (int *) malloc(cols * sizeof(int));
    for (j=0; j<cols; j++) m[i][j] = count++;
  }
  return(m);
}

void zeromatrix(int rows, int cols, int **m) {
  int i, j;
  for (i=0; i<rows; i++)
  for (j=0; j<cols; j++)
    m[i][j] = 0;
}

void freematrix(int rows, int **m) {
  while (--rows > -1) free(m[rows]);
  free(m);
}

void mmult(int rows, int cols, int **m1, int **m2, int **m3) {
  int i, j, k, val;
  for (i=0; i<rows; i++)
  for (j=0; j<cols; j++) {
    val = 0;
    for (k=0; k<cols; k++) val += m1[i][k] * m2[k][j];
    m3[i][j] = val;
  }
}

int get(int **mm, int x, int y) { return mm[x][y];}
""";

type matrix = "int**";
fun mkmatrix: int * int -> matrix;
fun get: matrix * int * int -> int;
proc zeromatrix: matrix;
proc mmult: int * int * matrix * matrix * matrix;
proc freematrix: int * matrix;

SIZE := 30;
m1 := mkmatrix(SIZE,SIZE);
m2 := mkmatrix(SIZE,SIZE);
mm := mkmatrix(SIZE,SIZE);

var i = n;
until i == 0 do
  mmult(SIZE, SIZE, m1, m2, mm);
  --i;
done;

print (get(mm,0,0)); print " ";
print (get(mm,2,3)); print " ";
print (get(mm,3,2)); print " ";
print (get(mm,4,4)); endl;

freematrix(SIZE, m1);
freematrix(SIZE, m2);
freematrix(SIZE, mm);


@select(tangler('speed/src/ada/matrix.ada'))
-- $Id: matrix.gnat,v 1.2 2005-03-13 23:29:08 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry.

with Text_IO, Ada.Strings.Fixed, Ada.Command_Line;

procedure Matrix is

   pragma Suppress (All_Checks);

   use Ada;

   Size : constant Natural := 30;

   type Int is new Integer;
   type Int_Matrix is array (1 .. Size, 1 .. Size) of Int;

   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
       Ada.Strings.Left ) return String renames Ada.Strings.Fixed.Trim;

   procedure Mk_Matrix (M : out Int_Matrix) is
      Count : Int := 1;
   begin
      for I in M'Range (1) loop
         for J in M'Range (2) loop
            M (I, J) := Count;
            Count := Count + 1;
         end loop;
      end loop;
   end Mk_Matrix;

   procedure M_Mult (M1, M2 : Int_Matrix; MM : in out Int_Matrix) is
      Sum : Int;
   begin
      for I in M1'Range (1) loop
         for J in M2'Range (2) loop
            Sum := 0;
            for KK in M1'Range (2) loop
               Sum := Sum + M1 (I, KK) * M2 (KK, J);
            end loop;
            MM (I, J) := Sum;
         end loop;
      end loop;
   end M_Mult;

   M1, M2, MM : Int_Matrix;
   N          : Positive := 1;

begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;

   Mk_Matrix (M1);
   Mk_Matrix (M2);

   for Iter in 1 .. N loop
      M_Mult (M1, M2, MM);
   end loop;

   Text_IO.Put_Line
     (L_Trim (Int'Image (MM (1, 1))) & Int'Image (MM (3, 4)) &
        Int'Image (MM (4, 3)) & Int'Image (MM (5, 5)));
end Matrix;

@head(1,'[message]')
@for i in machs:
  showgraph(i,'ack','message on '+i)
  showdata('speed/machine/'+i+'/rankings/message.txt')

@select(tangler('speed/specs/message.py'))
descr='message'
min=5
max=10

@select(tangler('speed/src/c/message.c'))
/* The Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * contributed by anon
 * compile with -Os -lpthread
 */

#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <unistd.h>
#include <pthread.h>	// -lpthread
#include <semaphore.h>

#define THREADS 500

#define STACKSZ (100*1024) // 100K
#define SWL_SLEEP (1000000/1000)

sem_t *s;

void
semwaitlocked(sem_t *sem) // profiling shows this is the bottleneck
{
	int v;
	for (sem_getvalue(sem, &v);
		v > 0;
		usleep(SWL_SLEEP),
		sem_getvalue(sem, &v));
}

void *
work(void *a)
{
	for (;;) {
		/*
		 * sem_wait() can get interrupted, just call it again
		 * TODO: see sys/kern/uipc_sem.c:618 in FreeBSD
		 */
		for (; sem_wait(s) != 0; pthread_yield());
		semwaitlocked(s);
	}
	return NULL;
}

int
main(int argc, char *argv[])
{
	unsigned int times;
	assert(argc == 2 && sscanf(argv[1], "%u", &times) == 1);
	
	int sum = 0;
	pthread_attr_t attr;
	pthread_t t[THREADS];
	int i, j;

	s = malloc(sizeof(sem_t));
	assert(s != NULL);
	assert(sem_init(s, 0, 0) == 0);
	assert(pthread_attr_init(&attr) == 0);
	//size_t sztmp;
	//assert(pthread_attr_getstacksize(&attr, &sztmp) == 0);
	//printf("default stack size: %ub\n", (unsigned int)sztmp);
	assert(pthread_attr_setstacksize(&attr, STACKSZ) == 0);
	for (i = 0; i < THREADS; i++) {
		assert(pthread_create(&t[i], &attr, work, NULL) == 0);
	}
	for (j = 0; j < times; j++) {
		for (i = 0; i < THREADS; i++) {
			/*
			 * from sem_post(3) in freebsd:
			 * > If there are threads blocked on the semaphore
			 * > when sem_post() is called, then the highest
			 * > priority thread that has been blocked the
			 * > longest on the semaphore will be allowed to
			 * > return from sem_wait().
			 */
			sem_post(s);
		}
		semwaitlocked(s);
		sum += THREADS;
	}
	printf("%d\n", sum);

	exit(0);
}

@select(tangler('speed/src/ocaml/message.ml'))
(* The Great Computer Language Shootout 
   http://shootout.alioth.debian.org/

   Contributed by David Teller (D.O.Teller@sussex.ac.uk)
*)

let adder_thread (incoming, outgoing) =
  while true do
    Event.sync(Event.send outgoing (Event.sync(Event.receive incoming) + 1))
  done

let rec make_chain n cur =
  if n = 0 then cur else
    let next = Event.new_channel() in
    let _ = Thread.create adder_thread (cur, next) in
    make_chain (n-1) next

let rec sum chan0 chan1 total n =
  if n = 0 then total else (
    Event.sync(Event.send chan0 0);
    sum chan0 chan1 (total + Event.sync(Event.receive chan1)) (n-1)
  )

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 10
  and first_channel = Event.new_channel() in
  let last_channel  = make_chain 500 first_channel in
  print_int(sum first_channel last_channel 0 n); print_newline()

@select(tangler('speed/src/ada/message.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/17

with Ada.Integer_Text_Io; use Ada.Integer_Text_Io;
with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;

procedure Message is
   type Link;
   type Link_Access is access Link;
   task type Link (Next_Link : Link_Access; Num_Iter : Positive) is
      pragma Storage_Size (100000);
      entry Receive (I : in Integer);
   end Link;

   task body Link is
      Val     : Integer := 0;
      New_Val : Integer;
   begin
      for iter in 1 .. Num_Iter loop
         accept Receive (I : in Integer) do
            New_Val := I;
         end Receive;

         if Next_Link = null then
            Val := Val + New_Val + 1;
         else
            Val := New_Val + 1;
            Next_Link.Receive (Val);
         end if;
      end loop;

      if Next_Link = null then
         Put (Item => Val, Width => 0);
         New_Line;
      end if;
   end Link;

   Num_Tasks : Positive := 500;
   Num_Iter  : Positive := 200;
   New_Task  : Link_Access;
   Last_Task : Link_Access := null;
begin
   if Argument_Count > 0 then
      Num_Iter := Positive'Value (Argument (1));
   end if;

   for Item in 1 .. Num_Tasks loop
      New_Task  := new Link (Last_Task, Num_Iter);
      Last_Task := New_Task;
   end loop;

   for iter in 1 .. Num_Iter loop
      New_Task.Receive (0);
   end loop;
end Message;


@head(1,'[meteor]')
@for i in machs:
  showgraph(i,'ack','meteor on '+i)
  showdata('speed/machine/'+i+'/rankings/meteor.txt')

@select(tangler('speed/specs/meteor.py'))
descr='meteor'
min=5
max=10

@head(1,'[methcall]')
@for i in machs:
  showgraph(i,'ack','methcall on '+i)
  showdata('speed/machine/'+i+'/rankings/methcall.txt')

@select(tangler('speed/specs/methcall.py'))
descr='methcall'
min=5
max=10

@select(tangler('speed/src/c/methcall.c'))
/* -*- mode: c -*-
 * $Id: methcall.gcc,v 1.1.1.1 2004-05-19 18:10:40 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>


enum {false, true};

#define TOGGLE \
    char state; \
    char (*value)(struct Toggle *); \
    struct Toggle *(*activate)(struct Toggle *)

#define DESTROY  free

typedef struct Toggle {
    TOGGLE;
} Toggle;

char toggle_value(Toggle *this) {
    return(this->state);
}
Toggle *toggle_activate(Toggle *this) {
    this->state = !this->state;
    return(this);
}
Toggle *init_Toggle(Toggle *this, char start_state) {
    this->state = start_state;
    this->value = toggle_value;
    this->activate = toggle_activate;
    return(this);
}
Toggle *new_Toggle(char start_state) {
    Toggle *this = (Toggle *)malloc(sizeof(Toggle));
    return(init_Toggle(this, start_state));
}


typedef struct NthToggle {
    TOGGLE;
    int count_max;
    int counter;
} NthToggle;

NthToggle *nth_toggle_activate(NthToggle *this) {
    if (++this->counter >= this->count_max) {
	this->state = !this->state;
	this->counter = 0;
    }
    return(this);
}
NthToggle *init_NthToggle(NthToggle *this, int max_count) {
    this->count_max = max_count;
    this->counter = 0;
    this->activate = (Toggle *(*)(Toggle *))nth_toggle_activate;
    return(this);
}
NthToggle *new_NthToggle(char start_state, int max_count) {
    NthToggle *this = (NthToggle *)malloc(sizeof(NthToggle));
    this = (NthToggle *)init_Toggle((Toggle *)this, start_state);
    return(init_NthToggle(this, max_count));
}


int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    Toggle *tog;
    NthToggle *ntog;
    char val = true;

    tog = new_Toggle(true);
    for (i=0; i<n; i++) {
	val = tog->activate(tog)->value(tog);
    }
    fputs(val ? "true\n" : "false\n", stdout);
    DESTROY(tog);
    
    val = true;
    ntog = new_NthToggle(val, 3);
    for (i=0; i<n; i++) {
	val = ntog->activate(ntog)->value(ntog);
    }
    fputs(val ? "true\n" : "false\n", stdout);
    DESTROY(ntog);
    return 0;
}

@select(tangler('speed/src/ocaml/methcall.ml'))
(*
 * $Id: methcall.ocaml,v 1.1.1.1 2004-05-19 18:10:41 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 * with contributions from Markus Mottl
 *)

class toggle start_state = object (self)
  val mutable state = start_state

  method value = state
  method activate = state <- not state; self
end

class nth_toggle start_state max_counter = object (self)
  inherit toggle start_state

  val count_max = max_counter
  val mutable counter = 0

  method activate =
    counter <- counter + 1;
    if counter >= count_max then begin state <- not state; counter <- 0 end;
    self
end

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let tog = new toggle true;;
for i = 2 to n do ignore tog#activate#value done;
Printf.printf "%b\n" tog#activate#value;
let ntog = new nth_toggle true 3 in
for i = 2 to n do ignore ntog#activate#value done;
Printf.printf "%b\n" ntog#activate#value

@select(tangler('speed/src/felix/methcall.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
// Adapted from C++ solution

body """
class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() { return(state); }
    virtual Toggle* activate() {
        state = !state;
        return this;
    }
protected:
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
        Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle *activate() {
        if (++this->counter >= this->count_max) {
            state = !state;
            counter = 0;
        }
        return this;
    }
private:
    int count_max;
    int counter;
};
""";

pod type toggle =  "class Toggle*";
fun new_toggle: bool -> toggle = "new Toggle($1)";
fun new_ntoggle: bool * int -> toggle = "new NthToggle($1,$2)";
proc del: toggle = "delete $1;";
fun value: toggle -> bool = "$1->value()";
proc activate: toggle = "$1->activate();";

proc check (t:toggle) {
  var tt = t;
  var v = true;
  var i = n;
  until i == 0 do
    activate tt;
    v = value tt;
    --i;
  done;
  print v; endl;
  del t;
}

check (new_toggle true);
check (new_ntoggle (true, 3));



@select(tangler('speed/src/ada/methcall.ada'))
-- $Id: methcall.gnat,v 1.1 2004-05-23 07:14:27 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Text_IO, Ada.Command_Line, Ada.Characters.Handling;

procedure MethCall is
   package Toggles is
      type A_Rec is                          --  'tagged' implies hidden field,
         tagged record                       --   and can append new fields
            Value       : Boolean := True;
         end record;

      procedure Activate (A : in out A_Rec);

      type B_Rec is new A_Rec with                 --  Add more fields to A_Rec
         record
            Flip_Period : Positive := 1;
            Count       : Natural := 0;
         end record;

      procedure Activate (B : in out B_Rec);
      pragma Inline (Activate);
   end Toggles;

   package body Toggles is
      procedure Activate (A : in out A_Rec) is
      begin
         A.Value := not A.Value;
      end Activate;

      procedure Activate (B : in out B_Rec) is
      begin
         B.Count := B.Count + 1;
         if B.Count = B.Flip_Period then
            B.Count := 0;
            B.Value := not B.Value;
         end if;
      end Activate;
   end Toggles;

   X        : Toggles.A_Rec := (Value => True);
   Y        : Toggles.B_Rec := (Value => True, Count => 0, Flip_Period => 3);
   Val      : Boolean;
   N        : Positive := 1;
begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for Iter in 1 .. N loop
      Toggles.Activate (X);
      Val := X.Value;
   end loop;
   Text_IO.Put_Line (Ada.Characters.Handling.To_Lower (Boolean'Image (Val)));
   for Iter in 1 .. N loop
      Toggles.Activate (Y);
      Val := Y.Value;
   end loop;
   Text_IO.Put_Line (Ada.Characters.Handling.To_Lower (Boolean'Image (Val)));
end MethCall;

@head(1,'[moments]')
@for i in machs:
  showgraph(i,'ack','moments on '+i)
  showdata('speed/machine/'+i+'/rankings/moments.txt')

@select(tangler('speed/specs/moments.py'))
descr='moments'
min=5
max=10

@select(tangler('speed/src/c/moments.c'))
/* -*- mode: c -*-
 * $Id: moments.gcc,v 1.1.1.1 2004-05-19 18:10:47 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Waldek Hebisch
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#define MAXLINELEN 128

/* kmedian permutes elements of a to get
   a[i]<=a[k] for i<k
   a[i]>=a[k] for i>k
	See. N. Wirth, Algorithms+data structures = Programs
*/

void kmedian(double *a, int n, int k) 
{
	while (1){
		int j=random()%n; 
		double b = a[j];
		int i=0;
        	j = n-1;
        	while(1) {
        	    while( a[i]<b ) i++;
        	    while( a[j]>b ) j--;
        	    if(i<j) {
                	double tmp=a[i];
                	a[i]=a[j];
                	a[j]=tmp;
                	i++;
                	j--;
       		    } else {
                	if(a[j]<b) j++;
                	if(a[i]>b) i--;
			break;
        	    }
        	}
		if(i<k) {
			k-=i+1;
			n-=i+1;
			a+=i+1;
		} else if (j>k) { 
			n=j;
		} else return;
	}
}

double max(double *a, int n)
{
	int j;
	double temp=a[0];
	for(j=1;j<n;j++) { 
		if(a[j]>temp) {
			temp=a[j];
		}
	}
	return temp;
}


int
main() {
    char line[MAXLINELEN];
    int i, n = 0, mid = 0;
    double sum = 0.0;
    double mean = 0.0;
    double average_deviation = 0.0;
    double standard_deviation = 0.0;
    double variance = 0.0;
    double skew = 0.0;
    double kurtosis = 0.0;
    double median = 0.0;
    double deviation = 0.0;
    int array_size = 4096;

    double *nums = (double *)malloc(array_size * sizeof(double));

    while (fgets(line, MAXLINELEN, stdin)) {
	sum += (nums[n++] = atof(line));
	if (n == array_size) {
	    array_size *= 2;
	    nums = (double *)realloc(nums, array_size * sizeof(double));
	}
    }
    mean = sum/n;
    for (i=0; i<n; i++) {
	double dev = nums[i] - mean;
	double dev2=dev*dev;
	double dev3=dev2*dev;
	double dev4=dev3*dev;
	average_deviation += fabs(dev);
	variance += dev2 /*pow(deviation,2)*/;
	skew += dev3 /* pow(deviation,3) */;
	kurtosis += dev4 /* pow(deviation,4) */;
    }
    average_deviation /= n;
    variance /= (n - 1);
    standard_deviation = sqrt(variance);
    if (variance) {
	skew /= (n * variance * standard_deviation);
	kurtosis = (kurtosis/(n * variance * variance)) - 3.0;
    }
    mid = (n/2);
    kmedian(nums, n, mid); 
    median = n % 2 ? nums[mid] : (nums[mid] + max(nums,mid))/2;
    free(nums);
    printf("n:                  %d\n", n);
    printf("median:             %f\n", median);
    printf("mean:               %f\n", mean);
    printf("average_deviation:  %f\n", average_deviation);
    printf("standard_deviation: %f\n", standard_deviation);
    printf("variance:           %f\n", variance);
    printf("skew:               %f\n", skew);
    printf("kurtosis:           %f\n", kurtosis);

    return(0);
}

@select(tangler('speed/src/ocaml/moments.ml'))
(*
 * $Id: moments.ocaml,v 1.1.1.1 2004-05-19 18:10:48 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let cutoff = 5

(* Unscrupulously stolen from Array.stable_sort (OCaml standard distribution) *)
let sort_floats len (ar : float array) =
  let merge src1ofs src1len src2 src2ofs src2len dst dstofs =
    let src1r = src1ofs + src1len and src2r = src2ofs + src2len in
    let rec loop i1 s1 i2 s2 d =
      if s1 <= s2 then begin
        dst.(d) <- s1;
        let i1 = i1 + 1 in
        if i1 < src1r then loop i1 ar.(i1) i2 s2 (d + 1)
        else Array.blit src2 i2 dst (d + 1) (src2r - i2)
      end else begin
        dst.(d) <- s2;
        let i2 = i2 + 1 in
        if i2 < src2r then loop i1 s1 i2 src2.(i2) (d + 1)
        else Array.blit ar i1 dst (d + 1) (src1r - i1)
      end in
    loop src1ofs ar.(src1ofs) src2ofs src2.(src2ofs) dstofs in
  let isortto srcofs dst dstofs len =
    for i = 0 to len - 1 do
      let e = ar.(srcofs + i) and j = ref (dstofs + i - 1) in
      while !j >= dstofs && e <= dst.(!j) do
        dst.(!j + 1) <- dst.(!j);
        decr j;
      done;
      dst.(!j + 1) <- e
    done in
  let rec sortto srcofs dst dstofs len =
    if len <= cutoff then isortto srcofs dst dstofs len else begin
      let l1 = len / 2 in
      let l2 = len - l1 in
      sortto (srcofs + l1) dst (dstofs + l1) l2;
      sortto srcofs ar (srcofs + l2) l1;
      merge (srcofs + l2) l1 dst (dstofs + l1) l2 dst dstofs
    end in
  if len <= cutoff then isortto 0 ar 0 len else begin
    let l1 = len / 2 in
    let l2 = len - l1 in
    let t = Array.make l2 ar.(0) in
    sortto l1 t 0 l2;
    sortto 0 ar l2 l1;
    merge l2 l1 t 0 l2 ar 0
  end

let n_ref = ref 0 and sum_ref = ref 0.0 and size_ref = ref 4096
let nums_ref = ref (Array.create !size_ref 0.0);;

try
  while true do
    let num = float_of_string (input_line stdin) in
    !nums_ref.(!n_ref) <- num;
    sum_ref := !sum_ref +. num;
    incr n_ref;
    let size = !size_ref in
    if !n_ref = size then begin
      let new_size = size lsl 2 in
      size_ref := new_size;
      let new_ar = Array.create new_size 0.0 in
      Array.blit !nums_ref 0 new_ar 0 size;
      nums_ref := new_ar
    end
  done
with End_of_file -> ();

let n = !n_ref and nums = !nums_ref in
let n_float = float n in
let mean = !sum_ref /. n_float
and avg_dev_ref = ref 0.0 and std_dev_ref = ref 0.0 and var_ref = ref 0.0
and skew_ref = ref 0.0 and kurt_ref = ref 0.0 in

for i = 0 to n - 1 do
  let dev = nums.(i) -. mean in
  avg_dev_ref := !avg_dev_ref +. abs_float dev;
  let dev2 = dev *. dev in
  var_ref := !var_ref +. dev2;
  let dev3 = dev2 *. dev in
  skew_ref := !skew_ref +. dev3;
  kurt_ref := !kurt_ref +. dev3 *. dev
done;

let avg_dev = !avg_dev_ref /. n_float and var = !var_ref /. float (n - 1) in
let std_dev = sqrt var in

if var > 0.0 then begin
  skew_ref := !skew_ref /. n_float /. var /. std_dev;
  kurt_ref := !kurt_ref /. n_float /. var /. var -. 3.0
end;

sort_floats n nums;

let median =
  let mid = n lsr 1 in
  if n mod 2 = 1 then nums.(mid)
  else (nums.(mid) +. nums.(mid - 1)) /. 2.0 in

Printf.printf "n:                  %d\n" n;
Printf.printf "median:             %f\n" median;
Printf.printf "mean:               %f\n" mean;
Printf.printf "average_deviation:  %f\n" avg_dev;
Printf.printf "standard_deviation: %f\n" std_dev;
Printf.printf "variance:           %f\n" var;
Printf.printf "skew:               %f\n" !skew_ref;
Printf.printf "kurtosis:           %f\n" !kurt_ref

@select(tangler('speed/src/felix/moments.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
include "stl";
// adapted from C solution

/* kmedian permutes elements of a to get
   a[i]<=a[k] for i<k
   a[i]>=a[k] for i>k
        See. N. Wirth, Algorithms+data structures = Programs
*/

open Stl;
open Stl::Vector;

proc printf: double = 'printf("%f",$1);';

proc kmedian(v: stl_vector[double], mid:int)
{
  var a = begin v;
  var k = mid;
  var n = len v;
  whilst true do
    var j = Cstdlib::rand() % n;
    b := a.[j];
    var i = 0;
    j = n-1;
    var flag = true;
    whilst flag do
      whilst  a.[i] < b do i++; done;
      whilst  a.[j] > b do j--; done;
      if i<j do
        a.[i] <-> a.[j];
        i++;
        j--;
      else
        if a.[j] < b do j++; done;
        if a.[i] > b do i--; done;
        flag = false;
      done;
    done;

    if i<k do
      k -= i+1;
      n -= i+1;
      a += i+1;
    elif j>k do
      n=j;
    else return;
    done;
  done;
}

fun max(a:stl_vector[double], n:int):double =
{
  var temp=a.[0];
  var j = n-1;
  until j == 0 do
    if a.[j]>temp do temp=a.[j]; done;
    --j;
  done;
  return temp;
}


var sum = 0.0;
var average_deviation = 0.0;
var standard_deviation = 0.0;
var variance = 0.0;
var skew = 0.0;
var kurtosis = 0.0;
var median = 0.0;
var deviation = 0.0;

var nums:stl_vector[double];

var line = Text_file::readln Text_file::stdin;
until line == "" do
  v := String::atof line;
  sum += v;
  push_back (nums,v);
  line = Text_file::readln Text_file::stdin;
done;

m := len nums;
mean := sum/double_of m;
var i = 0; until i == m do
  dev := nums.[i] - mean;
  dev2 := dev*dev;
  dev3 := dev2*dev;
  dev4 := dev3*dev;
  average_deviation += fabs dev;
  variance += dev2 /*pow(deviation,2)*/;
  skew += dev3 /* pow(deviation,3) */;
  kurtosis += dev4 /* pow(deviation,4) */;
  ++i;
done;

average_deviation /= double_of m;
variance /= double_of (m - 1);
standard_deviation = sqrt variance;
if variance != 0.0 do
  skew /= double_of m * variance * standard_deviation;
  kurtosis = kurtosis/(double_of m * variance * variance) - 3.0;
done;

mid := m / 2;
kmedian(nums, mid);
median =
  if m % 2 == 1 then nums.[mid]          // odd
  else (nums.[mid] + max (nums,mid))/2.0 // even
  endif
;

print "n:                  "; print m; endl;
print "median:             "; printf median; endl;
print "mean:               "; printf mean; endl;
print "average_deviation:  "; printf average_deviation; endl;
print "standard_deviation: "; printf standard_deviation; endl;
print "variance:           "; printf variance; endl;
print "skew:               "; printf skew; endl;
print "kurtosis:           "; printf kurtosis; endl;


@select(tangler('speed/src/ada/moments.ada'))
-- $Id: moments.gnat,v 1.8 2005-03-30 20:31:48 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22
-- Revised by Vasiliy Fofanov 2005/03/23
-- Modified by Pascal Obry on 2005/03/30

generic
   type Item_Type is private;
   with function "<=" (X, Y : Item_Type) return Boolean;
   type Sequence is array (Integer range <>) of Item_Type;
procedure Quick_Sort (S : in out Sequence; Lwb, Upb : in Integer);

procedure Quick_Sort (S : in out Sequence; Lwb, Upb : in Integer) is
   Pivot : Item_Type := S (Upb);
   Front : Integer := Lwb;
   Back  : Integer := Upb;
   Temp  : Item_Type;
begin
   if Lwb < Upb then
      while  (Front <= Back)  loop
         while not  (Pivot <= S (Front)) loop
            Front := Front + 1;
         end loop;
         while not  (S (Back) <= Pivot) loop
            Back := Back - 1;
         end loop;
         if Front <= Back then
            Temp := S (Front);
            S (Front) := S (Back);
            S (Back) := Temp;
            Front := Front + 1;
            Back  := Back - 1;
         end if;
      end loop;
      Quick_Sort (S, Lwb, Back);
      Quick_Sort (S, Front, Upb);
   end if;
end Quick_Sort;

-- $Id: moments.gnat,v 1.8 2005-03-30 20:31:48 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22
-- Revised by Vasiliy Fofanov 2005/03/23
-- Modified by Pascal Obry on 2005/03/30

with System, Ada.Numerics.Generic_Elementary_Functions;
with Ada.Text_IO; use Ada.Text_IO;
with Quick_Sort;
with GNAT.Dynamic_Tables;

procedure Moments is

   type Real is new Long_Float;

   package AF is new
     Ada.Numerics.Generic_Elementary_Functions (Float_Type => Real);
   package RIO is new Ada.Text_IO.Float_IO (Num => Real);

   procedure Put
     (Item : Real; Fore : Field := 0; Aft : Field := 6;
      Exp  : Field := 0) renames RIO.Put;

   package Real_Table is
      new GNAT.Dynamic_Tables (Real, Integer, 1, 4_096, 200);

   procedure Sort is new Quick_Sort (Real, "<=", Real_Table.Table_Type);

   Table                    : Real_Table.Instance;

   Dev, D_2, Mean, Median   : Real;
   Standard_Deviation       : Real;
   Sum, Avg_Abs_Deviation   : Real    := 0.0;
   Variance, Skew, Kurtosis : Real    := 0.0;
   M                        : Natural := 0;
   Value                    : Real;

begin
   Real_Table.Init (Table);

   begin
      loop
         RIO.Get (Item => Value);
         M := M + 1;
         Real_Table.Append (Table, Value);
         Sum := Sum + Value;
      end loop;
   exception
      when others => null;
   end;

   Mean := Sum / Real (M);

   for K in 1 .. M loop
      Dev               := Table.Table (K) - Mean;
      Avg_Abs_Deviation := Avg_Abs_Deviation + abs Dev;
      D_2               := Dev * Dev;
      Variance          := Variance + D_2;
      Skew              := Skew + (D_2 * Dev);
      Kurtosis          := Kurtosis + (D_2 * D_2);
   end loop;

   Avg_Abs_Deviation  := Avg_Abs_Deviation / Real (M);
   Variance           := Variance / Real (M - 1);
   Standard_Deviation := AF.Sqrt (Variance);

   if Variance < 10.0 * Real'Model_Epsilon then
      Put_Line ("> Reduced accuracy results: 0 = ((Variance/10 + 1) - 1)");
   else
      Skew     := Skew / (Real (M) * Variance * Standard_Deviation);
      Kurtosis := -3.0 + Kurtosis / (Real (M) * Variance * Variance);
   end if;

   Sort (Table.Table.all, 1, M);

   if 1 = (M mod 2) then
      Median := Table.Table ((M + 1) / 2);
   else
      Median := (Table.Table (M / 2) + Table.Table (1 + M / 2)) / 2.0;
   end if;

   Put_Line ("n:                 " & Integer'Image (M));
   Put ("median:             "); Put (Median);              New_Line;
   Put ("mean:               "); Put (Mean);                New_Line;
   Put ("average_deviation:  "); Put (Avg_Abs_Deviation);   New_Line;
   Put ("standard_deviation: "); Put (Standard_Deviation);  New_Line;
   Put ("variance:           "); Put (Variance);            New_Line;
   Put ("skew:               "); Put (Skew);                New_Line;
   Put ("kurtosis:           "); Put (Kurtosis);            New_Line;
end Moments;

@head(1,'[nbody]')
@for i in machs:
  showgraph(i,'ack','nbody on '+i)
  showdata('speed/machine/'+i+'/rankings/nbody.txt')

@select(tangler('speed/specs/nbody.py'))
descr='nbody'
min=5
max=10

@select(tangler('speed/src/c/nbody.c'))
/*
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * contributed by Christoph Bauer
 *  
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define pi 3.141592653589793
#define solar_mass (4 * pi * pi)
#define days_per_year 365.24

struct planet {
  double x, y, z;
  double vx, vy, vz;
  double mass;
};

void advance(int nbodies, struct planet * bodies, double dt)
{
  int i, j;

  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      double mag = dt / (distance * distance * distance);
      b->vx -= dx * b2->mass * mag;
      b->vy -= dy * b2->mass * mag;
      b->vz -= dz * b2->mass * mag;
      b2->vx += dx * b->mass * mag;
      b2->vy += dy * b->mass * mag;
      b2->vz += dz * b->mass * mag;
    }
  }
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    b->x += dt * b->vx;
    b->y += dt * b->vy;
    b->z += dt * b->vz;
  }
}

double energy(int nbodies, struct planet * bodies)
{
  double e;
  int i, j;

  e = 0.0;
  for (i = 0; i < nbodies; i++) {
    struct planet * b = &(bodies[i]);
    e += 0.5 * b->mass * (b->vx * b->vx + b->vy * b->vy + b->vz * b->vz);
    for (j = i + 1; j < nbodies; j++) {
      struct planet * b2 = &(bodies[j]);
      double dx = b->x - b2->x;
      double dy = b->y - b2->y;
      double dz = b->z - b2->z;
      double distance = sqrt(dx * dx + dy * dy + dz * dz);
      e -= (b->mass * b2->mass) / distance;
    }
  }
  return e;
}

void offset_momentum(int nbodies, struct planet * bodies)
{
  double px = 0.0, py = 0.0, pz = 0.0;
  int i;
  for (i = 0; i < nbodies; i++) {
    px += bodies[i].vx * bodies[i].mass;
    py += bodies[i].vy * bodies[i].mass;
    pz += bodies[i].vz * bodies[i].mass;
  }
  bodies[0].vx = - px / solar_mass;
  bodies[0].vy = - py / solar_mass;
  bodies[0].vz = - pz / solar_mass;
}

#define NBODIES 5
struct planet bodies[NBODIES] = {
  {                               /* sun */
    0, 0, 0, 0, 0, 0, solar_mass
  },
  {                               /* jupiter */
    4.84143144246472090e+00,
    -1.16032004402742839e+00,
    -1.03622044471123109e-01,
    1.66007664274403694e-03 * days_per_year,
    7.69901118419740425e-03 * days_per_year,
    -6.90460016972063023e-05 * days_per_year,
    9.54791938424326609e-04 * solar_mass
  },
  {                               /* saturn */
    8.34336671824457987e+00,
    4.12479856412430479e+00,
    -4.03523417114321381e-01,
    -2.76742510726862411e-03 * days_per_year,
    4.99852801234917238e-03 * days_per_year,
    2.30417297573763929e-05 * days_per_year,
    2.85885980666130812e-04 * solar_mass
  },
  {                               /* uranus */
    1.28943695621391310e+01,
    -1.51111514016986312e+01,
    -2.23307578892655734e-01,
    2.96460137564761618e-03 * days_per_year,
    2.37847173959480950e-03 * days_per_year,
    -2.96589568540237556e-05 * days_per_year,
    4.36624404335156298e-05 * solar_mass
  },
  {                               /* neptune */
    1.53796971148509165e+01,
    -2.59193146099879641e+01,
    1.79258772950371181e-01,
    2.68067772490389322e-03 * days_per_year,
    1.62824170038242295e-03 * days_per_year,
    -9.51592254519715870e-05 * days_per_year,
    5.15138902046611451e-05 * solar_mass
  }
};

int main(int argc, char ** argv)
{
  int n = atoi(argv[1]);
  int i;

  offset_momentum(NBODIES, bodies);
  printf ("%.9f\n", energy(NBODIES, bodies));
  for (i = 1; i <= n; i++)
    advance(NBODIES, bodies, 0.01);
  printf ("%.9f\n", energy(NBODIES, bodies));
  return 0;
}


@select(tangler('speed/src/ocaml/nbody.ml'))
(* nbody.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)


let pi = 3.141592653589793
let solar_mass = 4. *. pi *. pi
let days_per_year = 365.24

type planet = { mutable x : float;  mutable y : float;  mutable z : float;
                mutable vx: float;  mutable vy: float;  mutable vz: float;
                mass : float }

let advance bodies dt =
  let n = Array.length bodies - 1 in
  for i = 0 to Array.length bodies - 1 do
    let b = bodies.(i) in
    for j = i+1 to Array.length bodies - 1 do
      let b' = bodies.(j) in
      let dx = b.x -. b'.x  and dy = b.y -. b'.y  and dz = b.z -. b'.z in
      let dist2 = dx *. dx +. dy *. dy +. dz *. dz in
      let mag = dt /. (dist2 *. sqrt(dist2)) in

      b.vx <- b.vx -. dx *. b'.mass *. mag;
      b.vy <- b.vy -. dy *. b'.mass *. mag;
      b.vz <- b.vz -. dz *. b'.mass *. mag;

      b'.vx <- b'.vx +. dx *. b.mass *. mag;
      b'.vy <- b'.vy +. dy *. b.mass *. mag;
      b'.vz <- b'.vz +. dz *. b.mass *. mag;
    done
  done;
  for i = 0 to n do
    let b = bodies.(i) in
    b.x <- b.x +. dt *. b.vx;
    b.y <- b.y +. dt *. b.vy;
    b.z <- b.z +. dt *. b.vz;
  done


let energy bodies =
  let e = ref 0. in
  for i = 0 to Array.length bodies - 1 do
    let b = bodies.(i) in
    e := !e +. 0.5 *. b.mass *. (b.vx *. b.vx +. b.vy *. b.vy +. b.vz *. b.vz);
    for j = i+1 to Array.length bodies - 1 do
      let b' = bodies.(j) in
      let dx = b.x -. b'.x  and dy = b.y -. b'.y  and dz = b.z -. b'.z in
      let distance = sqrt(dx *. dx +. dy *. dy +. dz *. dz) in
      e := !e -. (b.mass *. b'.mass) /. distance
    done
  done;
  !e


let offset_momentum bodies =
  let px = ref 0. and py = ref 0. and pz = ref 0. in
  for i = 0 to Array.length bodies - 1 do
    px := !px +. bodies.(i).vx *. bodies.(i).mass;
    py := !py +. bodies.(i).vy *. bodies.(i).mass;
    pz := !pz +. bodies.(i).vz *. bodies.(i).mass;
  done;
  bodies.(0).vx <- -. !px /. solar_mass;
  bodies.(0).vy <- -. !py /. solar_mass;
  bodies.(0).vz <- -. !pz /. solar_mass


let jupiter = { x = 4.84143144246472090e+00;
                y = -1.16032004402742839e+00;
                z = -1.03622044471123109e-01;
                vx = 1.66007664274403694e-03 *. days_per_year;
                vy = 7.69901118419740425e-03 *. days_per_year;
                vz = -6.90460016972063023e-05 *. days_per_year;
                mass = 9.54791938424326609e-04 *. solar_mass;    }

let saturn = { x = 8.34336671824457987e+00;
               y = 4.12479856412430479e+00;
               z = -4.03523417114321381e-01;
               vx = -2.76742510726862411e-03 *. days_per_year;
               vy = 4.99852801234917238e-03 *. days_per_year;
               vz = 2.30417297573763929e-05 *. days_per_year;
               mass = 2.85885980666130812e-04 *. solar_mass;     }

let uranus = { x = 1.28943695621391310e+01;
               y = -1.51111514016986312e+01;
               z = -2.23307578892655734e-01;
               vx = 2.96460137564761618e-03 *. days_per_year;
               vy = 2.37847173959480950e-03 *. days_per_year;
               vz = -2.96589568540237556e-05 *. days_per_year;
               mass = 4.36624404335156298e-05 *. solar_mass;     }

let neptune = { x = 1.53796971148509165e+01;
                y = -2.59193146099879641e+01;
                z = 1.79258772950371181e-01;
                vx = 2.68067772490389322e-03 *. days_per_year;
                vy = 1.62824170038242295e-03 *. days_per_year;
                vz = -9.51592254519715870e-05 *. days_per_year;
                mass = 5.15138902046611451e-05 *. solar_mass;   }

let sun = { x = 0.;  y = 0.;  z = 0.;  vx = 0.;  vy = 0.; vz = 0.;
            mass = solar_mass; }

let bodies = [| sun; jupiter; saturn; uranus; neptune |]

let () =
  let n = int_of_string(Sys.argv.(1)) in
  offset_momentum bodies;
  Printf.printf "%.9f\n" (energy bodies);
  for i = 1 to n do advance bodies 0.01 done;
  Printf.printf "%.9f\n" (energy bodies)

@select(tangler('speed/src/ada/nbody.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

with Ada.Numerics; use Ada.Numerics;
with Ada.Numerics.Generic_Elementary_Functions;

package Nbody_Pck is

   type Real is Digits 15;

   package Math is new Ada.Numerics.Generic_Elementary_Functions (Real);

   Solar_Mass    : constant Real := 4.0 * Pi * Pi;
   Days_Per_Year : constant Real := 365.24;

   type Data is record
      X, Y, Z    : Real;
      Vx, Vy, Vz : Real;
      Mass       : Real;
   end record;

   type Body_Name is (Sun, Jupiter, Saturn, Uranus, Neptune);

   Bodies : array (Body_Name) of Data :=
              (Jupiter => (X    => 4.84143144246472090e+00,
                           Y    => -1.16032004402742839e+00,
                           Z    => -1.03622044471123109e-01,
                           Vx   => 1.66007664274403694e-03 * Days_Per_Year,
                           Vy   => 7.69901118419740425e-03 * Days_Per_Year,
                           Vz   => -6.90460016972063023e-05 * Days_Per_Year,
                           Mass => 9.54791938424326609e-04 * Solar_Mass),

               Saturn  => (X    => 8.34336671824457987e+00,
                           Y    => 4.12479856412430479e+00,
                           Z    => -4.03523417114321381e-01,
                           Vx   => -2.76742510726862411e-03 * Days_Per_Year,
                           Vy   => 4.99852801234917238e-03 * Days_Per_Year,
                           Vz   => 2.30417297573763929e-05 * Days_Per_Year,
                           Mass => 2.85885980666130812e-04 * Solar_Mass),

               Uranus  => (X    => 1.28943695621391310e+01,
                           y    => -1.51111514016986312e+01,
                           Z    => -2.23307578892655734e-01,
                           Vx   => 2.96460137564761618e-03 * Days_Per_Year,
                           Vy   => 2.37847173959480950e-03 * Days_Per_Year,
                           Vz   => -2.96589568540237556e-05 * Days_Per_Year,
                           Mass => 4.36624404335156298e-05 * Solar_Mass),

               Neptune => (X    => 1.53796971148509165e+01,
                           Y    => -2.59193146099879641e+01,
                           Z    => 1.79258772950371181e-01,
                           Vx   => 2.68067772490389322e-03 * Days_Per_Year,
                           Vy   => 1.62824170038242295e-03 * Days_Per_Year,
                           Vz   => -9.51592254519715870e-05 * Days_Per_Year,
                           Mass => 5.15138902046611451e-05 * Solar_Mass),

               Sun     => (X    => 0.0,
                           Y    => 0.0,
                           Z    => 0.0,
                           Vx   => 0.0,
                           Vy   => 0.0,
                           Vz   => 0.0,
                           Mass => Solar_Mass));

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real);

   function Energy return Real;

   procedure Advance (Dt : in Real);

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

package body Nbody_Pck is

   procedure Offset_Momentum
     (Planet     : in out Data;
      Px, Py, Pz : in     Real) is
   begin
      Planet.Vx := -Px / Solar_Mass;
      Planet.Vy := -Py / Solar_Mass;
      Planet.Vz := -Pz / Solar_Mass;
   end Offset_Momentum;

   function Energy return Real is
      Dx, Dy, Dz, Distance : Real;
      E                    : Real := 0.0;
   begin
      for I in Bodies'Range loop
        E := E + 0.5 * Bodies (I).Mass
          * (Bodies (I).Vx * Bodies (I).Vx
               + Bodies (I).Vy * Bodies (I).Vy
               + Bodies (I).Vz * Bodies (I).Vz);

        if I /= Body_Name'Last then
           for J in Body_Name'Succ (I) .. Body_Name'Last loop
              Dx := Bodies (I).X - Bodies (J).X;
              Dy := Bodies (I).Y - Bodies (J).Y;
              Dz := Bodies (I).Z - Bodies (J).Z;

              Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
              E := E - (Bodies (I).Mass * Bodies (J).Mass) / Distance;
           end loop;
        end if;
      end loop;
      return E;
   end Energy;

   procedure Advance (Dt : in Real) is
      Dx, Dy, Dz, Distance, Mag : Real;
   begin
      for I in Body_Name'Range loop
         if I /= Body_Name'Last then
            for J in Body_Name'Succ (I) .. Body_Name'Last loop
               Dx := Bodies (I).X - Bodies (J).X;
               Dy := Bodies (I).Y - Bodies (J).Y;
               Dz := Bodies (I).Z - Bodies (J).Z;

               Distance := Math.Sqrt (Dx * Dx + Dy * Dy + Dz * Dz);
               Mag := Dt / (Distance ** 3);

               Bodies (I).Vx := Bodies (I).Vx - Dx * Bodies (J).Mass * Mag;
               Bodies (I).Vy := Bodies (I).Vy - Dy * Bodies (J).Mass * Mag;
               Bodies (I).Vz := Bodies (I).Vz - Dz * Bodies (J).Mass * Mag;

               Bodies (J).Vx := Bodies (J).Vx + Dx * Bodies (I).Mass * Mag;
               Bodies (J).Vy := Bodies (J).Vy + Dy * Bodies (I).Mass * Mag;
               Bodies (J).Vz := Bodies (J).Vz + Dz * Bodies (I).Mass * Mag;
            end loop;
         end if;
      end loop;

      for I in Body_Name'Range loop
         Bodies (I).X := Bodies (I).X + Dt * Bodies (I).Vx;
         Bodies (I).Y := Bodies (I).Y + Dt * Bodies (I).Vy;
         Bodies (I).Z := Bodies (I).Z + Dt * Bodies (I).Vz;
      end loop;
   end Advance;

end Nbody_Pck;

-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Pascal Obry on 2005/03/21

with Ada.Command_Line; use Ada.Command_Line;
with Ada.Text_IO;      use Ada.Text_IO;
with Nbody_Pck;        use Nbody_Pck;

procedure Nbody is

   package RIO is new Float_Io (Real);

   procedure Put
     (Item : Real; Fore : Field := 0; Aft : Field := 9;
      Exp  : Field := 0) renames RIO.Put;

   N : constant Integer := Integer'Value (Argument (1));

   Px, Py, Pz : Real := 0.0;

begin
   for I in Body_Name'Range loop
      Px := Px + Bodies (I).Vx * Bodies (I).Mass;
      Py := Py + Bodies (I).Vy * Bodies (I).Mass;
      Pz := Pz + Bodies (I).Vz * Bodies (I).Mass;
   end loop;

   Offset_Momentum (Bodies (Sun), Px, Py, Pz);

   Put (Energy);
   New_Line;

   for K in 1 .. N loop
      Advance (0.01);
   end loop;

   Put (Energy);
   New_Line;
end Nbody;

@head(1,'[nestedloop]')
@for i in machs:
  showgraph(i,'ack','nestedloop on '+i)
  showdata('speed/machine/'+i+'/rankings/nestedloop.txt')

@select(tangler('speed/specs/nestedloop.py'))
descr='nestedloop'
min=5
max=10

@select(tangler('speed/src/c/nestedloop.c'))
/* -*- mode: c -*-
 * $Id: nestedloop.gcc,v 1.1.1.1 2004-05-19 18:10:56 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int a, b, c, d, e, f, x=0;
	
    for (a=0; a<n; a++)
	for (b=0; b<n; b++)
	    for (c=0; c<n; c++)
		for (d=0; d<n; d++)
		    for (e=0; e<n; e++)
			for (f=0; f<n; f++)
			    x++;

    printf("%d\n", x);
    return(0);
}

@select(tangler('speed/src/ocaml/nestedloop.ml'))
(*
 * $Id: nestedloop.ocaml,v 1.1.1.1 2004-05-19 18:10:56 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * based on code from Florian Hars and Markus Mottl
 *)

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let rec loopF x = function 0 -> x | i -> loopF (x+1) (i-1)
let rec loopE x = function 0 -> x | i -> loopE (loopF x n) (i-1)
let rec loopD x = function 0 -> x | i -> loopD (loopE x n) (i-1)
let rec loopC x = function 0 -> x | i -> loopC (loopD x n) (i-1)
let rec loopB x = function 0 -> x | i -> loopB (loopC x n) (i-1)
let rec loopA x = function 0 -> x | i -> loopA (loopB x n) (i-1);;
Printf.printf "%d\n" (loopA 0 n)

@select(tangler('speed/src/felix/nestedloop.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
var x = 0;

var a=0;
whilst a<n do
  var b=0;
  whilst b<n do
    var c=0;
    whilst c<n do
      var d=0;
      whilst d<n do
        var e=0;
        whilst e<n do
          var f=0;
          whilst f<n do
            x++;
            ++f;
          done;
          ++e;
        done;
        ++d;
      done;
      ++c;
    done;
    ++b;
  done;
  ++a;
done;

print x; endl;


@select(tangler('speed/src/ada/nestedloop.ada'))
-- $Id: nestedloop.gnat,v 1.1 2004-05-23 07:14:28 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Ada.Text_IO, Ada.Integer_Text_IO, Ada.Command_Line;

procedure NestedLoop is
   Count, M : Natural := 0;
   N        : Positive := 1;
begin

   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   M := N - 1;
   for A in 0 .. M loop
      for B in 0 .. M loop
         for C in 0 .. M loop
            for D in 0 .. M loop
               for E in 0 .. M loop
                  for F in 0 .. M loop
                     Count := Count + 1;
                  end loop;
               end loop;
            end loop;
         end loop;
      end loop;
   end loop;
   Ada.Integer_Text_IO.Put (Item => Count, Width => 0);
   Ada.Text_IO.New_Line;
end NestedLoop;


@head(1,'[nsieve]')
@for i in machs:
  showgraph(i,'ack','nsieve on '+i)
  showdata('speed/machine/'+i+'/rankings/nsieve.txt')

@select(tangler('speed/specs/nsieve.py'))
descr='nsieve'
min=5
max=10

@select(tangler('speed/src/c/nsieve.c'))
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// Precedent C entry modified by bearophile for speed and size, 31 Jan 2006
// Compile with:  -O3 -s -std=c99 -fomit-frame-pointer

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef unsigned char boolean;


static void nsieve(int m) {
    unsigned int count = 0, i, j;
    boolean * flags = (boolean *) malloc(m * sizeof(boolean));
    memset(flags, 1, m);

    for (i = 2; i < m; ++i)
        if (flags[i]) {
            ++count;
            for (j = i << 1; j < m; j += i)
//                if (flags[j]) 
                   flags[j] = 0;
    }

    free(flags);
    printf("Primes up to %8u %8u\n", m, count);
}

int main(int argc, char * argv[]) {
    int m = atoi(argv[1]);
    for (int i = 0; i < 3; i++)
        nsieve(10000 << (m-i));
    return 0;
}

@select(tangler('speed/src/ada/nsieve.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;

procedure Nsieve is

   function Count (M : in Natural) return Natural is
      type Boolean_Array is array (2 .. M) of Boolean;
      C : Natural := 0;
      S : Boolean_Array := (others => True);
      I : Positive;
   begin
      for K in S'Range loop
         if S (K) then
            C := C + 1;
            I := K * 2;
            while I <= M loop
               S (I) := False;
               I := I + K;
            end loop;
         end if;
      end loop;
      return C;
   end Count;

   procedure Run (N : in Natural) is
      M : Natural;
   begin
      M := 2 ** N * 10_000;
      Put ("Primes up to ");
      Put (Item => M, Width => 8);
      Put (" ");
      Put (Item => Count (M), Width => 8);
      New_Line;
   end Run;

   N : constant Natural := Natural'Value (Argument (1));
begin
   Run (N);
   Run (N - 1);
   Run (N - 2);
   
end Nsieve;
@head(1,'[nsievebits]')
@for i in machs:
  showgraph(i,'ack','nsievebits on '+i)
  showdata('speed/machine/'+i+'/rankings/nsievebits.txt')

@select(tangler('speed/specs/nsievebits.py'))
descr='nsievebits'
min=5
max=10

@select(tangler('speed/src/c/nsievebits.c'))
/*
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/ 
 *
 * Written by Dima Dorfman, 2004
 * Compile: gcc -std=c99 -O2 -o nsieve_bits_gcc nsieve_bits.c
 */

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <string.h>

typedef uint_fast8_t bits;
#define	NBITS	(CHAR_BIT * sizeof(bits))

static uintmax_t
nsieve(uintmax_t m)
{
	uintmax_t count, i, j;
	bits a[m / NBITS];

	memset(a, (1 << CHAR_BIT) - 1, sizeof(a));
	count = 0;
	for (i = 2; i < m; ++i)
		if (a[i / NBITS] & (1 << i % NBITS)) {
			for (j = i + i; j < m; j += i)
				a[j / NBITS] &= ~(1 << j % NBITS);
			++count;
		}
	return (count);
}

static void
test(unsigned long n)
{
	uintmax_t count, m;

	m = (1 << n) * 10000;
	count = nsieve(m);
	printf("Primes up to %8ju %8ju\n", m, count);
}

int
main(int ac, char **av)
{
	unsigned long n;
	char *cp;

	if (ac < 2) {
usage:		fprintf(stderr, "usage: nsieve N\n");
		exit(2);
	}
	n = strtoul(av[1], &cp, 10);
	if (*av[1] == '\0' || *cp != '\0' || n == ULONG_MAX)
		goto usage;
	test(n);
	if (n >= 1)
		test(n - 1);
	if (n >= 2)
		test(n - 2);
	exit(0);
}

@head(1,'[objinst]')
@for i in machs:
  showgraph(i,'ack','objinst on '+i)
  showdata('speed/machine/'+i+'/rankings/objinst.txt')

@select(tangler('speed/specs/objinst.py'))
descr='objinst'
min=5
max=10

@select(tangler('speed/src/c/objinst.c'))
/* -*- mode: c -*-
 * $Id: objinst.gcc,v 1.1.1.1 2004-05-19 18:11:02 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>


enum {false, true};

#define TOGGLE \
    char state; \
    char (*value)(struct Toggle *); \
    struct Toggle *(*activate)(struct Toggle *)

#define DESTROY  free

typedef struct Toggle {
    TOGGLE;
} Toggle;

char toggle_value(Toggle *this) {
    return(this->state);
}
Toggle *toggle_activate(Toggle *this) {
    this->state = !this->state;
    return(this);
}
Toggle *init_Toggle(Toggle *this, char start_state) {
    this->state = start_state;
    this->value = toggle_value;
    this->activate = toggle_activate;
    return(this);
}
Toggle *new_Toggle(char start_state) {
    Toggle *this = (Toggle *)malloc(sizeof(Toggle));
    return(init_Toggle(this, start_state));
}


typedef struct NthToggle {
    TOGGLE;
    int count_max;
    int counter;
} NthToggle;

NthToggle *nth_toggle_activate(NthToggle *this) {
    if (++this->counter >= this->count_max) {
	this->state = !this->state;
	this->counter = 0;
    }
    return(this);
}
NthToggle *init_NthToggle(NthToggle *this, int max_count) {
    this->count_max = max_count;
    this->counter = 0;
    this->activate = (Toggle *(*)(Toggle *))nth_toggle_activate;
    return(this);
}
NthToggle *new_NthToggle(char start_state, int max_count) {
    NthToggle *this = (NthToggle *)malloc(sizeof(NthToggle));
    this = (NthToggle *)init_Toggle((Toggle *)this, start_state);
    return(init_NthToggle(this, max_count));
}


int main(int argc, char *argv[]) {
    int i, n = ((argc == 2) ? atoi(argv[1]) : 1);
    Toggle *tog;
    NthToggle *ntog;

    tog = new_Toggle(true);
    for (i=0; i<5; i++) {
	fputs((tog->activate(tog)->value(tog)) ? "true\n" : "false\n", stdout);
    }
    DESTROY(tog);
    for (i=0; i<n; i++) {
	tog = new_Toggle(true);
	DESTROY(tog);
    }
    
    fputs("\n", stdout);

    ntog = new_NthToggle(true, 3);
    for (i=0; i<8; i++) {
	fputs((ntog->activate(ntog)->value(ntog)) ? "true\n" : "false\n", stdout);
    }
    DESTROY(ntog);
    for (i=0; i<n; i++) {
	ntog = new_NthToggle(true, 3);
	DESTROY(ntog);
    }
    return 0;
}

@select(tangler('speed/src/ocaml/objinst.ml'))
(*
 * $Id: objinst.ocaml,v 1.1.1.1 2004-05-19 18:11:03 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 * with contributions from Markus Mottl
 *)

class toggle start_state = object (self)
  val mutable state = start_state

  method value = state
  method activate = state <- not state; self
end

class nth_toggle start_state max_counter = object (self)
  inherit toggle start_state

  val count_max = max_counter
  val mutable counter = 0

  method activate =
    counter <- counter + 1;
    if counter >= count_max then begin
      state <- not state;
      counter <- 0
    end;
    self
end

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let tog = new toggle true;;
for i = 1 to 5 do Printf.printf "%b\n" tog#activate#value done;
for i = 1 to n do ignore (new toggle true) done;
print_newline ();
let ntog = new nth_toggle true 3 in
for i = 1 to 8 do Printf.printf "%b\n" ntog#activate#value done;
for i = 1 to n do ignore (new nth_toggle true 3) done

@select(tangler('speed/src/felix/objinst.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
// Adapted from C++ solution

body """
class Toggle {
public:
    Toggle(bool start_state) : state(start_state) { }
    virtual ~Toggle() {  }
    bool value() { return(state); }
    virtual Toggle* activate() {
        state = !state;
        return this;
    }
protected:
    bool state;
};

class NthToggle : public Toggle {
public:
    NthToggle(bool start_state, int max_counter) :
        Toggle(start_state), count_max(max_counter), counter(0) {
    }
    Toggle *activate() {
        if (++this->counter >= this->count_max) {
            state = !state;
            counter = 0;
        }
        return this;
    }
private:
    int count_max;
    int counter;
};
""";

pod type toggle =  "class Toggle*";

fun new_toggle: bool -> toggle = "new Toggle($1)";
fun new_ntoggle: bool * int -> toggle = "new NthToggle($1,$2)";
proc del: toggle = "delete $1;";
fun value: toggle -> bool = "$1->value()";
proc activate: toggle = "$1->activate();";
proc print (t: toggle) { print (value t); }

proc check(t: toggle, k:int) {
  var tt = t;
  var i=k;
  until i == 0 do
    activate tt;
    print tt; endl;
    --i;
  done;
  del t;
}

check(new_toggle true,5);

{
  var i = n;
  until i == 0 do
    del (new_toggle true);
    --i;
  done;
  endl;
};

check (new_ntoggle(true, 3), 8);

{
  var i = n;
  until i == 0 do
    del (new_ntoggle (true, 3));
    --i;
  done;
};


@select(tangler('speed/src/ada/objinst.ada'))
-- $Id: objinst.gnat,v 1.1 2004-05-23 07:14:28 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

-- Annotated Ada Reference Manual ISO/IEC 8652:1995: http://www.ada-auth.org/

with Ada.Command_Line, Ada.Characters.Handling, Text_IO, Ada.Tags;

procedure ObjInst is    --  3.451
   pragma Suppress (Discriminant_Check);
   pragma Suppress (Access_Check);
   package CH renames Ada.Characters.Handling;
   use type Ada.Tags.Tag;

   package Toggles is
      type A_Rec is
         tagged record                 --  'tagged' allows fields to be added
            Value       : Boolean := True;
         end record;

      type B_Rec is new A_Rec with
         record
            Flip_Period : Positive := 1;
            Count       : Natural := 0;
         end record;

      type A_Recs_Family_Ptr is access all A_Rec'Class;

      function Activate (X : A_Recs_Family_Ptr) return A_Recs_Family_Ptr;
      pragma Inline (Activate);
   end Toggles;

   package body Toggles is
      function Activate (X : A_Recs_Family_Ptr) return A_Recs_Family_Ptr is
         pragma Suppress (Range_Check);
         pragma Suppress (Tag_Check);
      begin                   --  X is a ptr: no "in out" parms in a function
         if X.all'Tag = A_Rec'Tag then                         --  A_Rec case
            X.all.Value := not X.all.Value;
         else
            declare                       --  Make visible the 2 B_Rec fields
               pragma Suppress (Tag_Check);
               B        : B_Rec renames B_Rec (X.all);
            begin
               B.Count := B.Count + 1;
               if B.Count = B.Flip_Period then
                  B.Count := 0;
                  B.Value := not B.Value;
               end if;
            end;
         end if;
         return X;
      end Activate;
   end Toggles;

   A        : aliased Toggles.A_Rec;      --  "aliased", since X'Access is used
   B        : aliased Toggles.B_Rec;      --  "access all" above for aliased
   N        : Positive := 1;
   Res      : Boolean;
begin
   begin
      N := Positive'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   A := Toggles.A_Rec'(Value => True);
   for K in 1 .. 5 loop
      Res := Toggles.Activate (A'Access).Value;
      Text_IO.Put_Line (CH.To_Lower (Boolean'Image (Res)));
   end loop;
   for Iter in 1 .. N loop
      A := Toggles.A_Rec'(Value => True);
   end loop;
   Text_IO.New_Line;
   B := Toggles.B_Rec'(Value => True, Flip_Period => 3, Count => 0);
   for K in 1 .. 8 loop
      Res := Toggles.Activate (B'Access).Value;
      Text_IO.Put_Line (CH.To_Lower (Boolean'Image (Res)));
   end loop;
   for Iter in 1 .. N loop
      B := Toggles.B_Rec'(Value => True, Flip_Period => 3, Count => 0);
   end loop;
end ObjInst;

@head(1,'[partialsums]')
@for i in machs:
  showgraph(i,'ack','partialsums on '+i)
  showdata('speed/machine/'+i+'/rankings/partialsums.txt')

@select(tangler('speed/specs/partialsums.py'))
descr='partialsums'
min=5
max=10

@select(tangler('speed/src/c/partialsums.c'))
/*
** The Great Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
**
** compile with:
**   gcc -O3 -fomit-frame-pointer -ffast-math -o partialsums partialsums.c -lm
**   Adding -march=<yourcpu> may help, too.
**   On a P4/K8 or later try adding: --march=<yourcpu> -mfpmath=sse -msse2 
*/

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

int main(int argc, char **argv)
{
  int k, n = atoi(argv[1]);
  double sum;

/*
** Yes, I tried using a double as a primary or secondary loop variable.
** But the x86 ABI requires a cleared x87 FPU stack before every call
** (e.g. to sin()) which nullifies any performance gains.
**
** Combining all loops does not pay off because the x87 FPU has to shuffle
** stack slots and/or runs out of registers. This may not be entirely true
** for SSE2 with fully inlined FPU code (-ffast-math required). Dito for
** other CPUs with a register-based FPU and a sane FP ABI.
**
** Auto vectorization may be a bit easier with separate loops, too.
*/
#define kd ((double)k)

  sum = 0.0;
  for (k = 0; k <= n; k++) {  /* pow(2.0/3.0, kd) inlined */
    double x = 1.0, q = 2.0/3.0;
    int j = k;
    for (;;) { if (j & 1) x *= q; if ((j >>= 1) == 0) break; q = q*q; }
    sum += x;
  }
  printf("%.9f\t(2/3)^k\n", sum);

  sum = 0.0;
  for (k = 1 ; k <= n; k++) sum += 1/sqrt(kd);  /* aka pow(kd, -0.5) */
  printf("%.9f\tk^-0.5\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/(kd*(kd+1.0));
  printf("%.9f\t1/k(k+1)\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) {
    double sk = sin(kd);
    sum += 1.0/(kd*kd*kd*sk*sk);
  }
  printf("%.9f\tFlint Hills\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) {
    double ck = cos(kd);
    sum += 1.0/((kd*kd)*kd*ck*ck);
  }
  printf("%.9f\tCookson Hills\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/kd;
  printf("%.9f\tHarmonic\n", sum);

  sum = 0.0;
  for (k = 1; k <= n; k++) sum += 1.0/(kd*kd);
  printf("%.9f\tRiemann Zeta\n", sum);

  sum = 0.0;
  for (k = 1; k <= n-1; k += 2) sum += 1.0/kd;
  for (k = 2; k <= n; k += 2) sum -= 1.0/kd;
  printf("%.9f\tAlternating Harmonic\n", sum);

  sum = 0.0;
  for (k = 1; k <= 2*n-1; k += 4) sum += 1.0/kd;
  for (k = 3; k <= 2*n; k += 4) sum -= 1.0/kd;
  printf("%.9f\tGregory\n", sum);

  return 0;
}


@select(tangler('speed/src/ocaml/partialsums.ml'))
(* partialsums.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Christophe TROESTLER
 *)

let n = try int_of_string (Array.get Sys.argv 1) with _ -> 25000

let () =
  let sum = ref 0.0 in
  for k = 0 to n do sum := !sum +. (2. /. 3.)**(float k) done;
  Printf.printf "%.9f\t(2/3)^k\n" !sum;

  sum := 0.0;
  for k = 1 to n do sum := !sum +. 1. /. sqrt(float k) done;
  Printf.printf "%.9f\tk^-0.5\n" !sum;

  sum := 0.0;
  for k = 1 to n do let k = float k in sum := !sum +. 1.0/.(k*.(k+.1.0)) done;
  Printf.printf "%.9f\t1/k(k+1)\n" !sum;

  sum := 0.0;
  for k = 1 to n do
    let k = float k in let  sk = sin(k) in
    sum := !sum +. 1.0 /. (k *. k *. k *. sk *. sk)
  done;
  Printf.printf "%.9f\tFlint Hills\n" !sum;

  sum := 0.0;
  for k = 1 to n do
    let k = float k in let ck = cos(k) in
    sum := !sum +. 1.0 /. (k *. k *. k *. ck *. ck)
  done;
  Printf.printf "%.9f\tCookson Hills\n" !sum;

  sum := 0.0;
  for k = 1 to n do sum := !sum +. 1. /. float k done;
  Printf.printf "%.9f\tHarmonic\n" !sum;

  sum := 0.0;
  for k = 1 to n do let k = float k in sum := !sum +. 1. /. (k *. k) done;
  Printf.printf "%.9f\tRiemann Zeta\n" !sum;

  sum := 0.0;  let a = ref(-1.0) in
  for k = 1 to n do a := -. !a; sum := !sum +. !a /. float k done;
  Printf.printf "%.9f\tAlternating Harmonic\n" !sum;

  sum := 0.0;  a := -1.0;
  for k = 1 to n do a := -. !a; sum := !sum +. !a /. (2. *. float k -. 1.) done;
  Printf.printf "%.9f\tGregory\n" !sum

@head(1,'[pidigits]')
@for i in machs:
  showgraph(i,'ack','pidigits on '+i)
  showdata('speed/machine/'+i+'/rankings/pidigits.txt')

@select(tangler('speed/specs/pidigits.py'))
descr='pidigits'
min=5
max=10

@select(tangler('speed/src/c/pidigits.c'))
/*
** The Computer Language Shootout
** http://shootout.alioth.debian.org/
** contributed by Mike Pall
**
**   gcc -O3 -fomit-frame-pointer -o pidigits pidigits.c -lgmp
*/

#include <stdio.h>
#include <stdlib.h>
#include <gmp.h>

typedef struct ctx_s {
  mpz_t q, r, s, t;	/* Transformation matrix components. */
  mpz_t u, v, w;	/* Temporary numbers. */
  int d, i, n;		/* Counters. */
  char digits[10+1];	/* Accumulated digits for one line. */
} ctx_t;

/* Compose matrix with numbers on the right. */
static void compose_r(ctx_t *c, int bq, int br, int bs, int bt)
{
  mpz_mul_si(c->u, c->r, bs);
  mpz_mul_si(c->r, c->r, bq);
  mpz_mul_si(c->v, c->t, br);
  mpz_add(c->r, c->r, c->v);
  mpz_mul_si(c->t, c->t, bt);
  mpz_add(c->t, c->t, c->u);
  mpz_mul_si(c->s, c->s, bt);
  mpz_mul_si(c->u, c->q, bs);
  mpz_add(c->s, c->s, c->u);
  mpz_mul_si(c->q, c->q, bq);
}

/* Compose matrix with numbers on the left. */
static void compose_l(ctx_t *c, int bq, int br, int bs, int bt)
{
  mpz_mul_si(c->r, c->r, bt);
  mpz_mul_si(c->u, c->q, br);
  mpz_add(c->r, c->r, c->u);
  mpz_mul_si(c->u, c->t, bs);
  mpz_mul_si(c->t, c->t, bt);
  mpz_mul_si(c->v, c->s, br);
  mpz_add(c->t, c->t, c->v);
  mpz_mul_si(c->s, c->s, bq);
  mpz_add(c->s, c->s, c->u);
  mpz_mul_si(c->q, c->q, bq);
}

/* Extract one digit. */
static int extract(ctx_t *c, unsigned int j)
{
  mpz_mul_ui(c->u, c->q, j);
  mpz_add(c->u, c->u, c->r);
  mpz_mul_ui(c->v, c->s, j);
  mpz_add(c->v, c->v, c->t);
  mpz_tdiv_q(c->w, c->u, c->v);
  return mpz_get_ui(c->w);
}

/* Print one digit. Returns 1 for the last digit. */
static int prdigit(ctx_t *c, int y)
{
  c->digits[c->d++] = '0'+y;
  if (++c->i % 10 == 0 || c->i == c->n) {
    c->digits[c->d] = '\0';
    printf("%-10s\t:%d\n", c->digits, c->i);
    c->d = 0;
  }
  return c->i == c->n;
}

/* Generate successive digits of PI. */
static void pidigits(ctx_t *c)
{
  int k = 1;
  c->d = 0;
  c->i = 0;
  mpz_init_set_ui(c->q, 1);
  mpz_init_set_ui(c->r, 0);
  mpz_init_set_ui(c->s, 0);
  mpz_init_set_ui(c->t, 1);
  mpz_init(c->u);
  mpz_init(c->v);
  mpz_init(c->w);
  for (;;) {
    int y = extract(c, 3);
    if (y == extract(c, 4)) {
      if (prdigit(c, y)) return;
      compose_r(c, 10, -10*y, 0, 1);
    } else {
      compose_l(c, k, 4*k+2, 0, 2*k+1);
      k++;
    }
  }
}

int main(int argc, char **argv)
{
  ctx_t c;
  c.n = argc > 1 ? atoi(argv[1]) : 27;
  pidigits(&c);
  return 0;
}


@select(tangler('speed/src/ada/pidigits.ada'))
--  The Computer Language Shootout
--  http://shootout.alioth.debian.org
--  Calculate digits of pi using the
--  Unbounded Spigot Algorithms
--
--  From Pascal code by Vincent Snijders
--  gmp headers by Karl-Michael Schindler
--  Translated by (New) P2Ada v. 17-June-2006

with Ada.Text_IO;                       use Ada.Text_IO;
with Ada.Integer_Text_IO;               use Ada.Integer_Text_IO;
with Ada.Command_Line;                  use Ada.Command_Line;
with Ada.Calendar;                      use Ada.Calendar;

with Interfaces.C;

procedure pidigits is

  pragma Suppress(All_Checks);

  package GMP_mini is
    type mp_limb_t is new Interfaces.C.unsigned;
    type mp_ptr is access mp_limb_t;

    type mpz_t is record
      mp_alloc, mp_size : Interfaces.C.int;
      mp_d    : mp_ptr;
    end record;

    procedure mpz_init (Dest: out mpz_t);
    pragma Import(C, mpz_init, "__gmpz_init");

    procedure mpz_init_set_ui (Dest: out mpz_t; Src: in Interfaces.C.unsigned_long);
    pragma Import(C, mpz_init_set_ui, "__gmpz_init_set_ui");

    procedure mpz_mul_ui (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.unsigned_long);
    pragma Import(C, mpz_mul_ui, "__gmpz_mul_ui");

    procedure mpz_mul_si (Dest: out mpz_t; Src1: in mpz_t; Src2: in Interfaces.C.int);
    pragma Import(C, mpz_mul_si, "__gmpz_mul_si");

    procedure mpz_add (Dest: out mpz_t; Src1, Src2: in mpz_t);
    pragma Import(C, mpz_add, "__gmpz_add");

    procedure mpz_tdiv_q (Dest: out mpz_t; Src1, Src2: in mpz_t);
    pragma Import(C, mpz_tdiv_q, "__gmpz_tdiv_q");

    function  mpz_get_ui (Src: in mpz_t) return Interfaces.C.unsigned_long;
    pragma Import(C, mpz_get_ui, "__gmpz_get_ui");

    pragma Linker_Options("-lgmp");

  end GMP_Mini;

  procedure Print_pi_digits(num_digits: Integer) is
    use GMP_mini;

    q,r,s,t: mpz_t; --  Transformation matrix components

    u,v,w: mpz_t;   --  Temporary variables

    k,digit: Interfaces.C.int;
    c,i: Integer;
    line: String(1 ..10);

    function Extract(x: Interfaces.C.Unsigned_long) return Interfaces.C.int is
    begin
      mpz_mul_ui(u, q, x);
      mpz_add(u, u, r);
      mpz_mul_ui(v, s, x);
      mpz_add(v, v, t);
      mpz_tdiv_q(w, u, v);
      return Interfaces.C.int(mpz_get_ui(w));
    end Extract;

    use Interfaces.C;

    function IsSafe return Boolean is
    begin
      return digit = Extract(4);
    end IsSafe;

    procedure Produce is
    begin
      mpz_mul_si(r, r, 10);
      mpz_mul_si(v, t, -10 * digit);
      mpz_add(r, r, v);
      mpz_mul_si(q, q, 10);
    end Produce;

    procedure Consume is
    begin
      k:= k + 1;
      mpz_mul_si(r, r, 2*k+1);
      mpz_mul_si(u, q, 4*k+2);
      mpz_add(r, r, u);
      mpz_mul_si(t, t, 2*k+1);
      mpz_mul_si(v, s, 4*k+2);
      mpz_add(t, t, v);
      mpz_mul_si(s, s, k);
      mpz_mul_si(q, q, k);
    end Consume;

  begin
    k := 0;
    i := 0;
    c := 0;
    mpz_init_set_ui(q, 1);
    mpz_init_set_ui(r, 0);
    mpz_init_set_ui(s, 0);
    mpz_init_set_ui(t, 1);
    mpz_init(u);
    mpz_init(v);
    mpz_init(w);
    while i < num_digits loop
      digit := Extract(3);
      while not IsSafe loop
        Consume;
        digit:= Extract(3);
      end loop;
      Produce;
      c:= c + 1;
      line(c) := Character'Val(Character'Pos('0')+digit);
      i:= i + 1;
      if c = 10 then
        Put(line & ASCII.HT & ':');
        Put(i,0); New_Line;
        c := 0;
      end if;
    end loop;
    if  c/=0 then
      Put(line(1..c));
      for i in c+1..10 loop
        Put(' ');
      end loop;
      Put(ASCII.HT & ':');
      Put(i,0);
      New_Line;
    end if;
  end Print_pi_digits;

  n: Integer;

  t0,t1: Time;
  timing: constant Boolean:= False;

begin
  n:= 2_500;
  if Argument_Count=1 then
    n:= Integer'Value(Argument(1));
  end if;
  if timing then
    t0:= Clock;
  end if;
  Print_pi_digits(n);
  if timing then
    t1:= Clock;
    Put("Time in seconds: " & Duration'Image(t1-t0) & " [press return]");
    Skip_Line;
  end if;
end pidigits;

@head(1,'[process]')
@for i in machs:
  showgraph(i,'ack','process on '+i)
  showdata('speed/machine/'+i+'/rankings/process.txt')

@select(tangler('speed/specs/process.py'))
descr='process'
min=5
max=10

@select(tangler('speed/src/ocaml/process.ml'))
(* The Great Computer Language Shootout
   http://shootout.alioth.debian.org/

   Contributed by David Teller (D.O.Teller@sussex.ac.uk)
*)

let adder_thread (incoming, outgoing) =
  Event.sync(Event.send outgoing (Event.sync(Event.receive incoming) + 1))

let rec make_chain n cur =
  if n = 0 then cur else
    let next = Event.new_channel() in
    let _ = Thread.create adder_thread (cur, next) in
    make_chain (n-1) next

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1
  and first_channel = Event.new_channel() in
  let last_channel  = make_chain n first_channel in
  Event.sync(Event.send first_channel 0);
  print_int(Event.sync(Event.receive last_channel))

@select(tangler('speed/src/ada/process.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org
--
-- Contributed by Jim Rogers
-- Fixed by Pascal Obry on 2005/03/18

with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Command_Line;    use Ada.Command_Line;

procedure Process is

   type Link;
   type Link_Access is access Link;

   task type Link (Next_Link : Link_Access)is
      pragma Storage_Size (100_000);
      entry Receive (I : in Integer);
   end Link;

   task body Link is
      Val : Integer;
   begin
      accept Receive (I : in Integer) do
         Val := I;
      end Receive;

      if Next_Link = Null then
         Put(Item => Val + 1, Width => 0);
         New_Line;
      else
         Next_Link.Receive (Val + 1);
      end if;
   end Link;

   Num_Tasks : Positive := 251;
   New_Task  : Link_Access;
   Last_Task : Link_Access := null;

begin
   if Argument_Count > 0 then
      Num_Tasks := Positive'Value (Argument (1));
   end if;

   for Item in 1..Num_Tasks loop
      New_Task := new Link (Last_Task);
      Last_Task := New_Task;
   end loop;

   New_Task.Receive (0);
end Process;

@head(1,'[prodcons]')
@for i in machs:
  showgraph(i,'ack','prodcons on '+i)
  showdata('speed/machine/'+i+'/rankings/prodcons.txt')

@select(tangler('speed/specs/prodcons.py'))
descr='prodcons'
min=5
max=10

@select(tangler('speed/src/c/prodcons.c'))
/* -*- mode: c -*-
 * $Id: prodcons.gcc,v 1.1.1.1 2004-05-19 18:11:09 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <signal.h>
#include <errno.h>
#include <sys/types.h>
#include <pthread.h>

pthread_mutex_t mutex;
pthread_cond_t control;
void producer(int *arg);
void consumer(int *arg);
int count, data, consumed, produced;


int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    pthread_t t1, t2;
    
    count = data = consumed = produced = 0;

    if (pthread_mutex_init(&mutex, NULL)) {
	perror("pthread_mutex_init");
	exit(1);
    }
    if (pthread_cond_init(&control, NULL)) {
	perror("pthread_cond_init");
	exit(1);
    }
    if (pthread_create(&t1, (pthread_attr_t *)NULL,
		       (void * (*)(void *))producer, (void *)&n)) {
	perror("pthread_create");
	exit(1);
    }
    if (pthread_create(&t2, (pthread_attr_t *)NULL,
		       (void * (*)(void *))consumer, (void *)&n)) {
	perror("pthread_create");
	exit(1);
    }
  
    pthread_join(t1, NULL);
    pthread_join(t2, NULL);
    fprintf(stdout, "%d %d\n", produced, consumed);
    return(0);
}


void producer(int *arg) {
    int i, n = *arg;
    for (i=1; i<=n; i++) {
	pthread_mutex_lock(&mutex);
	while (count == 1) {
	    pthread_cond_wait(&control, &mutex);
	}
	data = i;
	count = 1;
	pthread_cond_signal(&control);
	pthread_mutex_unlock(&mutex);
	produced++;
    }
}
 

void consumer(int *arg) {
    int i = 0, n = *arg;
    while (1) {
	pthread_mutex_lock(&mutex);
	while (count == 0) {
	    pthread_cond_wait(&control, &mutex);
	}
	i = data;
	count = 0;
	pthread_cond_signal(&control);
	pthread_mutex_unlock(&mutex);
	consumed++;
	if (i == n) return;
    }
}


@select(tangler('speed/src/ocaml/prodcons.ml'))
(*
 * $Id: prodcons.ocaml,v 1.1.1.1 2004-05-19 18:11:10 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * ocamlopt -thread unix.cmxa threads.cmxa prodcons.ml -o prodcons
 *  or
 * ocamlc -thread unix.cma threads.cma prodcons.ml -o prodcons
 *)

let count = ref 0
let data = ref 0
let produced = ref 0
let consumed = ref 0
let m = Mutex.create ()
let c = Condition.create ()

let producer n =
  for i = 1 to n do
    Mutex.lock m;
    while !count = 1 do Condition.wait c m done;
    data := i;
    incr count;
    Condition.signal c;
    Mutex.unlock m;
    incr produced
  done

let consumer n =
  let i = ref 0 in
  while !i <> n do
    Mutex.lock m;
    while !count = 0 do Condition.wait c m done;
    i := !data;
    decr count;
    Condition.signal c;
    Mutex.unlock m;
    incr consumed
  done

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let p = Thread.create producer n and c = Thread.create consumer n;;
Thread.join p; Thread.join c;
Printf.printf "%d %d\n" !produced !consumed

@select(tangler('speed/src/felix/prodcons.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
var produced = 0;
var consumed = 0;

proc consumer() {
  until consumed == n do
    var x:int; read x;
    ++consumed;
  done;
}

proc producer() {
  var i = 1;
  until produced == n do
    ++produced;
    send[int] (&con) i;
    ++i;
  done;
}

var con = start the consumer ();
var prod= start the producer ();
run prod;

print produced; print " "; print consumed; endl;


@select(tangler('speed/src/ada/prodcons.ada'))
-- $Id: prodcons.gnat,v 1.2 2005-05-13 16:24:18 igouy-guest Exp $
-- http://dada.perl.it/shootout/ 
-- Ada 95 code by C.C.

with Ada.Strings.Fixed, Ada.Command_Line, Text_IO;

procedure ProdCons is

   type Data_Type is new Integer;
   End_Of_Data    : constant Data_Type := Data_Type'First;

   protected Queue is
      entry Put (Data : Data_Type);
      entry Get (Data_Out : out Data_Type);
   private
      Count          : Natural := 0;
      Buffer         : Data_Type;
   end Queue;

   protected body Queue is
      entry Put (Data : Data_Type)
         when Count = 0 is
      begin
         Buffer := Data;
         Count := Count + 1;
      end Put;

      entry Get (Data_Out : out Data_Type)
         when Count /= 0 is
      begin
         Data_Out := Buffer;
         Count := Count - 1;
      end Get;
   end Queue;

   Produced, Consumed : Natural := 0;

   task type Producer_Task (N : Natural);
   task type Consumer_Task (N : Natural);

   task body Producer_Task is
   begin
      for Data_K in 1 .. Data_Type (N) loop
         Queue.Put (Data => Data_K);
         Produced := Produced + 1;
      end loop;
      Queue.Put (Data => End_Of_Data);
   end Producer_Task;

   task body Consumer_Task is
      Data        : Data_Type;
   begin
      loop
         Queue.Get (Data_Out => Data);
         exit when Data = End_Of_Data;
         Consumed := Consumed + 1;
      end loop;
   end Consumer_Task;

   function L_Trim (Source : String; Side : Ada.Strings.Trim_End :=
               Ada.Strings.Left) return String renames Ada.Strings.Fixed.Trim;
   N        : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   declare
      Producer    : Producer_Task (N => N);
      Consumer    : Consumer_Task (N => N);
   begin
      null;
   end;
   Text_IO.Put_Line (L_Trim (Natural'Image (Produced)) &
            Natural'Image (Consumed));
end ProdCons;


@head(1,'[random]')
@for i in machs:
  showgraph(i,'ack','random on '+i)
  showdata('speed/machine/'+i+'/rankings/random.txt')

@select(tangler('speed/specs/random.py'))
descr='random'
min=5
max=10

@select(tangler('speed/src/c/random.c'))
/* -*- mode: c -*-
 * $Id: random.gcc,v 1.1.1.1 2004-05-19 18:11:15 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#define IM 139968
#define IA 3877
#define IC 29573

inline double gen_random(double max) {
    static long last = 42;
    
    last = (last * IA + IC) % IM;
    return( max * last / IM );
}

int main(int argc, char *argv[]) {
    int N = ((argc == 2) ? atoi(argv[1]) : 1) - 1;
    
    while (N--) {
	gen_random(100.0);
    }
    printf("%.9f\n", gen_random(100.0));
    return(0);
}

@select(tangler('speed/src/ocaml/random.ml'))
(* random.ml
 *
 * $Id: random.ocaml,v 1.4 2005-05-12 12:52:50 chris00-guest Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let im = 139968
and ia = 3877
and ic = 29573

let rec gen_random n seed rand inv_im max =
  if n = 0 then rand else
    let new_seed = (seed * ia + ic) mod im in
    gen_random (n-1) new_seed (max *. float new_seed *. inv_im) inv_im max

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1000 in
  Printf.printf "%.9f\n" (gen_random n 42 0.0 (1. /. float im) 100.0)

@select(tangler('speed/src/felix/random.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
//adapted from Ocaml solution
im := 139968;
ia := 3877;
ic := 29573;
first_last := 42;

proc printf: double = 'printf("%.9f",$1);';


fun gen_random (max:double, last:int, i:int):double =>
  let ?new_last = (last * ia + ic) % im in
  if i > 1 then gen_random (max, new_last, (i - 1))
  else max * double_of new_last / double_of im
  endif
;

printf (gen_random (100.0, first_last, n)); endl;


@select(tangler('speed/src/ada/random.ada'))
-- $Id: random.gnat,v 1.2 2005-03-25 07:59:08 bfulgham Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Pascal Obry on 2005/03/22
-- Revised by Vasiliy Fofanov 2005/03/23

with System, Ada.Command_Line, Ada.Text_IO;

procedure Random is
   type Real is new Long_Float;
   package Rio is new Ada.Text_IO.Float_IO (Num => Real);

   package Random_Real is
      function Gen_Random (Supr : Real) return Real;
      pragma Inline (Gen_Random);
   end Random_Real;

   package body Random_Real is
      IM          : constant Positive := 139968;
      IA          : constant Integer := 3877;
      IC          : constant Integer := 29573;
      Last        : Integer := 42;

      function Gen_Random (Supr : Real) return Real is
         pragma Suppress (Overflow_Check);
         pragma Suppress (Range_Check);
      begin
         Last := (Last * IA + IC) mod IM;
         return Supr * Real (Last) / Real (IM);
      end Gen_Random;
         --  Assume no overflow for "Natural ((IM - 1) * IA + IC)"
   end Random_Real;

   Result   : Real;
   N        : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for Iter in 1 .. N loop
      Result := Random_Real.Gen_Random (Supr => 100.0);
   end loop;
   Rio.Put (Result, Fore => 0, Aft => 9, Exp => 0);
   Ada.Text_IO.New_Line;
end Random;

@head(1,'[recursive]')
@for i in machs:
  showgraph(i,'ack','recursive on '+i)
  showdata('speed/machine/'+i+'/rankings/recursive.txt')

@select(tangler('speed/specs/recursive.py'))
descr='recursive'
min=5
max=10

@select(tangler('speed/src/c/recursive.c'))
// The Computer Language Shootout
// http://shootout.alioth.debian.org/
// recursive test, by bearophile, Jan 24 2006
// Compile with: -O3 -s -fomit-frame-pointer -funroll-loops

#include <stdio.h>

int Ack(int x, int y) {
    if (x == 0)
        return y+1;
    if (y == 0)
        return Ack(x-1, 1);
    return Ack(x-1, Ack(x, y-1));
}

int Fib(int n) {
    if (n < 2)
        return 1;
    return Fib(n-2) + Fib(n-1);
}

double FibFP(double n) {
    if (n < 2.0)
        return 1.0;
    return FibFP(n-2.0) + FibFP(n-1.0);
}

int Tak(int x, int y, int z) {
    if (y < x)
        return Tak( Tak(x-1, y, z), Tak(y-1, z, x), Tak(z-1, x, y) );
    return z;
}

double TakFP(double x, double y, double z) {
    if (y < x)
        return TakFP( TakFP(x-1.0, y, z), TakFP(y-1.0, z, x), TakFP(z-1.0, x, y) );
    return z;
}

int main(int argc, char **argv) {
    int n = atoi(argv[1]) - 1;
    printf("Ack(3,%d): %d\n", n+1, Ack(3, n+1));
    printf("Fib(%.1f): %.1f\n", 28.0+n, FibFP(28.0+n));
    printf("Tak(%d,%d,%d): %d\n", 3*n, 2*n, n, Tak(3*n, 2*n, n));
    printf("Fib(3): %d\n", Fib(3));
    printf("Tak(3.0,2.0,1.0): %.1f\n", TakFP(3.0, 2.0, 1.0));
    return 0;
}

@select(tangler('speed/src/ada/recursive.ada'))
-----------------------------------------------------------------------
-- The Computer Language Shootout
-- http://shootout.alioth.debian.org
-- contributed by Jim Rogers
-----------------------------------------------------------------------

with Ada.Text_Io; use Ada.Text_Io;
with Ada.Command_Line; use Ada.Command_Line;

procedure Recursive is
   type Real is digits 18;
   package Real_Io is new Ada.Text_Io.Float_Io(Real);
   use Real_Io;
   package Int_Io is new Ada.Text_Io.Integer_Io(Long_Integer);
   use Int_Io;
   
   N : Long_Integer;
   
   function Ack (M, N : Long_Integer) return Long_Integer is
   begin
      if M = 0 then
         return N + 1;
      end if;
      if N = 0 then 
         return Ack(M - 1, 1);
      end if;
      return Ack(M - 1, Ack(M, N - 1));
   end Ack;
   function Fib(N : Long_Integer) return Long_Integer is
   begin
      if N < 2 then 
         return 1;
      else
         return Fib(N - 2) + Fib(N - 1);
      end if;
   end Fib;
   function Tak(X, Y, Z : Long_Integer) return Long_Integer is
   begin
      if Y < X then
         return Tak(Tak(X -1, Y, Z), Tak(Y-1, Z, X), Tak(Z - 1, X, Y));
      else
         return Z;
      end if;
   end Tak;
   function Fib(N : Real) return Real is
   begin
      if N < 2.0 then
         return 1.0;
      else
         return Fib(N - 2.0) + Fib(N - 1.0);
      end if;
   end Fib;
   function Tak(X, Y, Z : Real) return Real is
   begin
      if Y < X then
         return Tak(Tak(X - 1.0, Y, X), Tak(Y - 1.0, Z, X), Tak(Z - 1.0, X, Y));
      else
         return Z;
      end if;
   end Tak;
   
begin
   N := Long_Integer'Value(Argument(1));
   
   Put("Ack(3,"); Put(Item => N, Width => 1); Put("): ");
   Put(Item => Ack(3, N), Width => 1); New_Line;
   
   Put("Fib("); Put(Item => Real(N)+27.0, Fore => 1, Aft => 1, Exp => 0); 
   Put("): "); Put(Item => Fib(Real(N) + 27.0), Fore => 1, Aft => 1, Exp => 0);
   New_Line;
   
   N := N - 1;
   Put("Tak("); Put(Item => N*3, Width => 1); Put(",");
   Put(Item => N*2, Width => 1); Put(","); Put(Item => N, Width => 1);
   Put("): "); Put(Item => Tak(N*3, N*2, N), Width => 1); New_Line;
   
   Put("Fib(3): "); Put(Item => Fib(3), Width => 0); New_Line;
   Put("Tak(3.0,2.0,1.0): "); Put(Item => Tak(3.0,2.0,1.0), Aft => 1, Exp => 0, Fore => 1);
   New_Line;
   
end Recursive;

@head(1,'[regexdna]')
@for i in machs:
  showgraph(i,'ack','regexdna on '+i)
  showdata('speed/machine/'+i+'/rankings/regexdna.txt')

@select(tangler('speed/specs/regexdna.py'))
descr='regexdna'
min=5
max=10

@head(1,'[regexmatch]')
@for i in machs:
  showgraph(i,'ack','regexmatch on '+i)
  showdata('speed/machine/'+i+'/rankings/regexmatch.txt')

@select(tangler('speed/specs/regexmatch.py'))
descr='regexmatch'
min=5
max=10

@select(tangler('speed/src/c/regexmatch.c'))
/* -*- mode: c -*-
 * $Id: regexmatch.gcc,v 1.1.1.1 2004-05-19 18:11:23 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <pcre.h>
#include <string.h>

#define MAXLINES   100
#define MAXLINELEN 132

char *pattern = 
"(?:^|[^\\d\\(])"		/* must be preceeded by non-digit */
"(\\()?"			/* match 1: possible initial left paren */
"(\\d\\d\\d)"			/* match 2: area code is 3 digits */
"(?(1)\\))"			/* if match1 then match right paren */
"[ ]"				/* area code followed by one space */
"(\\d\\d\\d)"			/* match 3: prefix of 3 digits */
"[ -]"				/* separator is either space or dash */
"(\\d\\d\\d\\d)"		/* match 4: last 4 digits */
"\\D"				/* must be followed by a non-digit */
;


int
main(int argc, char *argv[]) {
    int NUM = ((argc == 2) ? atoi(argv[1]) : 1);
    int count;
    char *cptr = "";
    char **phones;
    pcre *re;
    int erroffset;
    const char *errptr;
    int n, lines = 0;
    char num[256];
    int i, j, k, matchlen;
    char *matchoffset;
    int nmatches;
    int *ovec, ovecsize;
    pcre_extra *study;

    phones = (char **)malloc(MAXLINES * sizeof(char *));
    if (!phones) {
	fprintf(stderr, "malloc for phones array failed\n");
	exit(1);
    }
    lines = 0;
    while (cptr) {
	phones[lines] = (char *)malloc(MAXLINELEN);
	if (!phones[lines]) {
	    fprintf(stderr, "malloc to hold line #%d failed\n", lines);
	    exit(1);
	}
	cptr = fgets(phones[lines], MAXLINELEN, stdin);
	lines++;
	if (lines > MAXLINES) {
	    fprintf(stderr, "MAXLINES is too small\n");
	    exit(1);
	}
    }

    re = pcre_compile(pattern, 0, &errptr, &erroffset, NULL);
    if (!re) {
	fprintf(stderr, "can't open compile regexp\n");
	exit(1);
    }

    study = pcre_study(re, 0, &errptr);

    if (pcre_fullinfo(re, NULL, PCRE_INFO_CAPTURECOUNT, &nmatches) != 0) {
	fprintf(stderr, "pcre_fullinfo failed\n");
	exit(1);
    }
    nmatches++;			/* add match of entire pattern */

    ovecsize = sizeof(int) * nmatches * 3;
    ovec = (int *)malloc(ovecsize);
    if (!ovec) {
	fprintf(stderr, "malloc for ovec array failed\n");
	exit(1);
    }

    count = 0;
    while (NUM--) {
	for (i=0; i<lines; i++) {
	    n = pcre_exec(re, study,
			  phones[i], strlen(phones[i]), 0,
			  0, ovec, ovecsize);
	    if (n == nmatches) {
		/* stuff the match into the buffer "num" */
		k = 2*2;	/* initial offset into ovec */
		/* areacode */
		j = 0;
		num[j++] = '(';
		matchoffset = phones[i] + ovec[k];
		matchlen = ovec[k+1] - ovec[k];
		strncpy(num+j, matchoffset, matchlen);
		j += matchlen; k += 2;
		num[j++] = ')';
		/* space separator */
		num[j++] = ' ';
		/* exchange */
		matchoffset = phones[i] + ovec[k];
		matchlen = ovec[k+1] - ovec[k];
		strncpy(num+j, matchoffset, matchlen);
		j += matchlen; k += 2;
		/* dash */
		num[j++] = '-';
		/* last 4 digits */
		matchoffset = phones[i] + ovec[k];
		matchlen = ovec[k+1] - ovec[k];
		strncpy(num+j, matchoffset, matchlen);
		j += matchlen; k += 2;
		/* with a cherry on top */
		num[j] = 0;
		if (0 == NUM) {
		    count++;
		    printf("%d: %s\n", count, num);
		}
	    }
	}
    }

    for (i=0; i<MAXLINES; i++) {
	free(phones[i]);
    }
    free(phones);
    free(ovec);

    return(0);
}


@select(tangler('speed/src/ocaml/regexmatch.ml'))
(* regexmatch.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 * This program uses the Str module that comes with OCaml standard
 * distribution.
 *)

open Printf

let re = Str.regexp (
  "[^0-9(]*" (* must be preceded by non-digit *)
  ^ "\\(([0-9][0-9][0-9])\\|[0-9][0-9][0-9]\\)" (* match1: area code *)
  ^ " \\([0-9][0-9][0-9]\\)[ -]" (* space, prefix=3 digits, separator *)
  ^ "\\([0-9][0-9][0-9][0-9]\\)\\([^0-9]\\|$\\)" (* 4 digits, non-digit *)
)

(* Read all the lines from stdin *)
let phones =
  let lines = ref [] in
  try  while true do lines := (input_line stdin) :: !lines done; assert(false)
  with End_of_file -> List.rev !lines

let check_phone must_print count line =
  if Str.string_match re line 0 then (
    let area = Str.matched_group 1 line
    and prefix = Str.matched_group 2 line
    and digits = Str.matched_group 3 line in
    let num = (if area.[0] = '(' then sprintf "%s %s-%s"
	       else sprintf "(%s) %s-%s") area prefix digits in
    if must_print then (incr count; printf "%i: %s\n" !count num)
  )

let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ -> 1 in
  List.iter (check_phone true (ref 0)) phones;
  for i = 2 to n do List.iter (check_phone false (ref 0)) phones done


@select(tangler('speed/src/felix/regexmatch.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);

open Lexer;

regexp digit = ["0123456789"];
regexp digits3 = digit digit digit;
regexp digits4 =  digits3 digit;

regexp area_code = digits3 | "(" digits3 ")";
regexp exchange = digits3;

regexp phone = area_code " " exchange (" " | "-") digits4;

// Felix, like Python, provides no literals of char type
zero := ord("0".[0]);
nine := ord("9".[0]);

// Felix regular matching currently only supports
// actual regular sets of strings -- it does not support
// lookback or lookahead because they're not regular
//
// So we have to hand code the context check.
//
fun check_context(start: iterator, finish: iterator): string =
{
  prior :=  ord(deref(start-1));
  next := ord(deref(finish));
  return
    if zero <= prior &<= nine
    or zero <= next &<= nine
    then ""
    else string_between(start, finish)
    endif
  ;
}

// this is the actual lexer function
fun lexit (start:iterator, finish:iterator): iterator * string =>
  reglex start to finish with
  | phone => check_context (lexeme_start, lexeme_end)
  | _ => ""
  endmatch
;

// hack so context_check won't crash (pre- and append space)
val data = " " + Text_file::load(Text_file::stdin)+" ";
first := Lexer::start_iterator data;
finish := Lexer::end_iterator data;


var i=n;
var current: iterator;
var s: string;
whilst i>1 do
  current = first;
  until current == finish do
    current, s = lexit(current, finish);
  done;
  --i;
done;

proc print_phone(x:string, j:int) {
  n := len x;
  var s = "";
  var i = 0;
  whilst i<n do
    if zero <= ord(x.[i]) &<= nine do
      s = s + ord(x.[i]);
    done;
    ++i;
  done;
  print j; print ": ";
  print ("("+s.[0 to 3]+") "+s.[3 to 6]+"-"+s.[6 to 10]); endl;
}

current = first;
var j = 0;
until current == finish do
 current, s = lexit(current, finish);
 if s != "" do  ++j; print_phone (s,j); done;
done;


@head(1,'[revcomp]')
@for i in machs:
  showgraph(i,'ack','revcomp on '+i)
  showdata('speed/machine/'+i+'/rankings/revcomp.txt')

@select(tangler('speed/specs/revcomp.py'))
descr='revcomp'
min=5
max=10

@select(tangler('speed/src/ocaml/revcomp.ml'))
(* reverse-complement.ml 
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)


let complement =
  let cplt = Array.init 256 (fun i -> Char.chr i) in
  List.iter (fun (c1, c2) ->
	       cplt.(Char.code c1) <- c2;
	       cplt.(Char.code c2) <- c1;
	       cplt.(Char.code(Char.lowercase c1)) <- c2;
	       cplt.(Char.code(Char.lowercase c2)) <- c1;  )
    [ ('A','T'); ('C','G'); ('B','V'); ('D','H'); ('K','M'); ('R','Y') ];
  cplt

(* [reverse s] reverse-complement the string [s] in place. *)
let reverse s =
  let rec rev i j =
    if i < j then (
      let si = s.[i] in
      s.[i] <- complement.(Char.code s.[j]);
      s.[j] <- complement.(Char.code si);
      rev (i + 1) (j - 1)
    ) in
  rev 0 (String.length s - 1);
  s

let print_fasta =
  let rec print60 pos len dna =
    if len > 60 then (
      output stdout dna pos 60; print_string "\n";
      print60 (pos + 60) (len - 60) dna
    )
    else (output stdout dna pos len; print_string "\n") in
  fun dna -> print60 0 (String.length dna) dna


let () =
  let buf = Buffer.create 4096 in
  try while true do
    let line = input_line stdin in
    if String.length line > 0 && line.[0] = '>' then (
      if Buffer.length buf > 0 then print_fasta(reverse(Buffer.contents buf));
      Buffer.clear buf;
      print_endline line
    )
    else Buffer.add_string buf line
  done with End_of_file -> print_fasta(reverse(Buffer.contents buf))


@select(tangler('speed/src/ada/revcomp.ada'))
-- $Id: revcomp.gnat,v 1.2 2005-04-04 09:59:22 obry-guest Exp $
-- http://dada.perl.it/shootout/
-- Contributed by Pascal Obry on 2005/03/19
-- Optimized by Bill Findlay on 2005/04/04

with Ada.Text_IO;                use Ada.Text_IO;
with Ada.Unchecked_Deallocation;

procedure Revcomp is

   Complement : constant array (Character) of Character :=
                  ('A' => 'T', 'C' => 'G', 'G' => 'C', 'T' => 'A', 'U' => 'A',
                   'M' => 'K', 'R' => 'Y', 'W' => 'W', 'S' => 'S', 'Y' => 'R',
                   'K' => 'M', 'V' => 'B', 'H' => 'D', 'D' => 'H', 'B' => 'V',
                   'N' => 'N',
                   'a' => 'T', 'c' => 'G', 'g' => 'C', 't' => 'A', 'u' => 'A',
                   'm' => 'K', 'r' => 'Y', 'w' => 'W', 's' => 'S', 'y' => 'R',
                   'k' => 'M', 'v' => 'B', 'h' => 'D', 'd' => 'H', 'b' => 'V',
                   'n' => 'N',
                   others => '?');

   Max_Length : constant := 60;

   type String_Access is access String;

   procedure Free is new Ada.Unchecked_Deallocation (String, String_Access);

   procedure Get_Fasta (Seq : in out String_Access; Length : out Natural) is
      Ptr  : String_Access;
      J, K : Natural := 0;
      C    : Character;
      EOL  : Boolean;
   begin
      Length := 0;

      loop
         Look_Ahead (C, EOL);
         exit when C /= '>' and C /= ';' ;
         Get_Line (Seq (1 .. Seq'Length), J);
         if Seq (1) = '>' then
            Put_Line (Seq (1 .. J));
         end if;
      end loop;

      loop
         if Length + Max_Length > Seq'Length then
            Ptr := Seq;
            Seq := new String (1 .. 2 * Seq'Length);
            Seq (1 .. Length) := Ptr (1 .. Length);
            Free (Ptr);
         end if;

         Get_Line (Seq (Length + 1 .. Length + Max_Length), J);
         K := J - Length;
         Length := J;

         if K = Max_Length then
            Skip_Line;
         end if;

         Look_Ahead (C, EOL);

         if K < Max_Length or else C = '>' or else C = ';' then
            return;
         end if;
      end loop;
   exception
      when End_Error =>
         return;
   end Get_Fasta;

   procedure Reverse_Fasta (Fasta : in out String) is
      C    : Character;
      L, R : Natural;
   begin
      for I in 0 .. Fasta'Length loop
         L := Fasta'First + I;
         R := Fasta'Last - I;
         exit when L > R;
         C := Fasta (L);
         Fasta (L) := Complement (Fasta (R));
         Fasta (R) := Complement (C);
      end loop;
   end Reverse_Fasta;

   procedure Put_Reversed_Fasta (Fasta : in out String) is
      L : Natural := Fasta'Last;
   begin
      while L >= Max_Length loop
         Reverse_Fasta (Fasta (L - Max_Length + 1 .. L));
         Put_Line (Fasta (L - Max_Length + 1 .. L));
         L := L - Max_Length;
      end loop;
      if L > 0 then
         Reverse_Fasta (Fasta (1 .. L));
         Put_Line (Fasta (1 .. L));
      end if;
   end Put_Reversed_Fasta;

   Seq    : String_Access := new String (1 .. 1_024);
   Length : Natural;

begin
   loop
      Get_Fasta (Seq, Length);
      exit when Length = 0;
      Put_Reversed_Fasta (Seq (1 .. Length));
   end loop;
end Revcomp;

@head(1,'[reversefile]')
@for i in machs:
  showgraph(i,'ack','reversefile on '+i)
  showdata('speed/machine/'+i+'/rankings/reversefile.txt')

@select(tangler('speed/specs/reversefile.py'))
descr='reversefile'
min=5
max=10

@select(tangler('speed/src/c/reversefile.c'))
/* -*- mode: c -*-
 * $Id: reversefile.gcc,v 1.5 2004-10-18 07:15:07 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * 
 * from Alan Post <apost@recalcitrant.org>
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <limits.h>
#include <sys/uio.h>

#define MAXREAD 4096
#define IOV_MAX 1024

typedef struct buf_t { char d[MAXREAD];
                       size_t len;
                       struct buf_t *next;} buf_t;

static print_string( char *data, size_t len,
                     struct iovec *vec, size_t *p_ivec )
{
    vec[ *p_ivec ].iov_base = data;
    vec[ *p_ivec ].iov_len = (int) len;
    ++ *p_ivec;
    if ( *p_ivec == IOV_MAX )
    {
        writev( STDOUT_FILENO, vec, *p_ivec );
        *p_ivec = 0;
    }
}

static print_line( char *pos, char *end, buf_t **p_loh,
                   struct iovec *vec, size_t *p_ivec )
{
    print_string( pos, end - pos, vec, p_ivec );
    for (; *p_loh != NULL; *p_loh = (*p_loh)->next )
        print_string( (*p_loh)->d, (*p_loh)->len, vec, p_ivec );
}

static void rev_print( buf_t *head )
{
    buf_t *loh = NULL;
    buf_t *curr = head;

    struct iovec vec[ IOV_MAX ];
    size_t ivec = 0;

    while ( 1 )
    {
        char *buf = curr->d;
        char *end = buf + curr->len;
        char *pos = end;
        for (;; pos--)
        {
            if ( pos <= buf )
            {
                buf_t *new_curr = curr->next;

                if ( new_curr == NULL )
                {
                    print_line( pos, end, &loh, vec, &ivec );
                    writev( STDOUT_FILENO, vec, ivec );
                    return;
                }

                curr->len = end - buf;
                curr->next = loh;
                loh = curr;
                
                curr = new_curr;
                break;
            }
            if ( *(pos-1) == '\n' )
            {
                print_line( pos, end, &loh, vec, &ivec );
                end = pos;
            }
        }
    }
    assert( NULL == "unreachable" );
}

static void f( buf_t *tail )
{
    buf_t head;

    head.next = tail;
    head.len = read( STDIN_FILENO, head.d, MAXREAD );

    if ( head.len == MAXREAD ) f( &head );
    else rev_print( &head );
}

int main(int argc, char *argv[])
{
    f( NULL );
    return EXIT_SUCCESS;
}


@select(tangler('speed/src/ocaml/reversefile.ml'))
(*
 * $Id: reversefile.ocaml,v 1.1.1.1 2004-05-19 18:12:18 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * author: Jean-Francois Monin
 * date: Thu Jan 27 00:28:51 CET 2001
 * France Telecom R & D, Lannion
 * ocamlopt -noassert -unsafe -ccopt -O3 rev.ml -o rev
 *)

let size = 10000

let rec lect stack buf pos free =
  let nrd = input stdin buf pos free in
  if nrd = 0 then stack, buf, pos (* buf filled only until pos *)
  else if nrd = free then lect (buf :: stack) (String.create size) 0 size
  else lect stack buf (pos + nrd) (free - nrd)

let output_buf (buf, len) = output stdout buf 0 len

let rec rev_write tail stack buf len pos =
  if pos = 0 then
    match stack with
    | [] -> output stdout buf 0 len; List.iter output_buf tail
    | topbuf :: stack ->
        let toplen = String.length topbuf in
        rev_write ((buf, len) :: tail) stack topbuf toplen toplen
  else if buf.[pos - 1] = '\n' then
    begin
      output stdout buf pos (len - pos);
      List.iter output_buf tail;
      rev_write [] stack buf pos (pos - 1)
    end
  else rev_write tail stack buf len (pos - 1);;

let stack, buf, length = lect [] (String.create size) 0 size;;
rev_write [] stack buf length length

@select(tangler('speed/src/felix/reversefile.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);

open List;
open Text_file;

var x = Empty[string];
var s = readln stdin;
until s == "" do
  x = Cons (s,x);
  s = readln stdin;
done;

proc plist(x:list[string]){
  match x with
  | Cons (?s,?t) => { print s; plist t; }
  |  _ => {}
  endmatch;
};

plist x;


@select(tangler('speed/src/ada/reversefile.ada'))
-- $Id: reversefile.gnat,v 1.2 2004-08-16 08:00:24 bfulgham Exp $
-- http://shootout.alioth.debian.org/
--
-- by James S. Rogers
-- 
with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;
with Ada.Text_Io; use Ada.Text_Io;

procedure Reversefile is
  Contents : Unbounded_String := Null_Unbounded_String;
  Next_Char : Character;
begin
  while not End_Of_File loop
    Get(Next_Char);
    Contents := Contents & Next_Char;
  end loop;
  for Iter in reverse 1..Length(Contents) loop
    Put(Item => Element(Source => Contents, Index => Iter));
  end loop;
end Reversefile;

@head(1,'[sieve]')
@for i in machs:
  showgraph(i,'ack','sieve on '+i)
  showdata('speed/machine/'+i+'/rankings/sieve.txt')

@select(tangler('speed/specs/sieve.py'))
descr='sieve'
min=5
max=10

@select(tangler('speed/src/c/sieve.c'))
/* -*- mode: c -*-
 * $Id: sieve.gcc,v 1.1.1.1 2004-05-19 18:12:27 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>

int
main(int argc, char *argv[]) {
    int NUM = ((argc == 2) ? atoi(argv[1]) : 1);
    static char flags[8192 + 1];
    long i, k;
    int count = 0;

    while (NUM--) {
	count = 0; 
	for (i=2; i <= 8192; i++) {
	    flags[i] = 1;
	}
	for (i=2; i <= 8192; i++) {
	    if (flags[i]) {
		// remove all multiples of prime: i
		for (k=i+i; k <= 8192; k+=i) {
		    flags[k] = 0;
		}
		count++;
	    }
	}
    }
    printf("Count: %d\n", count);
    return(0);
}


@select(tangler('speed/src/ocaml/sieve.ml'))
(*
 * $Id: sieve.ocaml,v 1.1.1.1 2004-05-19 18:12:27 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * based on code from Markus Mottl
 * slightly improved by Claude Marche and Jean-Christophe Filliatre
 *)

let init_flags = String.make 8193 't'
let flags = String.make 8193 't'

let rec inner_loop f i k =
  if k < 8193 then begin f.[k] <- 'f'; inner_loop f i (k + i) end

let rec middle_loop f i cnt =
  if i < 8193 then
    if f.[i] = 't' then begin
      inner_loop f i (i + i);
      middle_loop f (i + 1) (cnt + 1) end
    else middle_loop f (i + 1) cnt
  else cnt

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1;;
for iter = 2 to n do
  String.blit init_flags 0 flags 0 8193;
  ignore (middle_loop flags 2 0);
done;
Printf.printf "Count: %d\n" (middle_loop flags 2 0)

@select(tangler('speed/src/felix/sieve.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
type barry = "char*";
fun mk_barry : unit -> barry = "(char*)calloc(8193,1)";
proc free : barry = "free($1);";
fun subscript: barry * int -> lvalue[bool] = "$1[$2]";

var prime = mk_barry();
var i:int;
var k: int;
var count = 0;
var m = n;

until m == 0 do
  m--;
  count = 0;
  for {i=2;} { i <= 8192 } { i++; } { prime.[i] = true; };
  i=2;
  whilst i <= 8192 do
    if prime.[i] do
      k=i+i;
      whilst k <= 8192 do
        prime.[k] = false;
        k+=i;
      done;
      count++;
    done;
    i++;
  done;
done;

free prime;

print "Count: "; print count; endl;


@select(tangler('speed/src/ada/sieve.ada'))
-- $Id: sieve.gnat,v 1.1 2004-05-23 07:14:28 bfulgham Exp $
-- http://dada.perl.it/shootout/
-- Ada 95 code by C.C.

with Text_IO, Ada.Command_Line;

procedure Sieve is
   High        : constant := 8192;
   Is_Prime    : array (2 .. High) of Boolean;
   Count, K, N : Natural := 0;
begin
   begin
      N := Natural'Value (Ada.Command_Line.Argument (1));
   exception
      when Constraint_Error => null;
   end;
   for Iter in 1 .. N loop
      declare
         pragma Suppress (Overflow_Check);
         pragma Suppress (Index_Check);
         pragma Suppress (Range_Check);
      begin
         Count := 0;
         Is_Prime := (others => True);
         for J in Is_Prime'Range loop
            if Is_Prime (J) then
               K := J + J;
               while K <= Is_Prime'Last loop
                  Is_Prime (K) := False;        --  K is not a prime since a
                  K := K + J;                   --  multiple of prime J
               end loop;
               Count := Count + 1;
            end if;
         end loop;
      end;
   end loop;
   Text_IO.Put_Line ("Count:" & Natural'Image (Count));
end Sieve;

@head(1,'[spectralnorm]')
@for i in machs:
  showgraph(i,'ack','spectralnorm on '+i)
  showdata('speed/machine/'+i+'/rankings/spectralnorm.txt')

@select(tangler('speed/specs/spectralnorm.py'))
descr='spectralnorm'
min=5
max=10

@select(tangler('speed/src/c/spectralnorm.c'))
/* -*- mode: c -*-
 * 
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Sebastien Loisel
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double eval_A(int i, int j) { return 1.0/((i+j)*(i+j+1)/2+i+1); }

void eval_A_times_u(int N, const double u[], double Au[])
{
  int i,j;
  for(i=0;i<N;i++)
    {
      Au[i]=0;
      for(j=0;j<N;j++) Au[i]+=eval_A(i,j)*u[j];
    }
}

void eval_At_times_u(int N, const double u[], double Au[])
{
  int i,j;
  for(i=0;i<N;i++)
    {
      Au[i]=0;
      for(j=0;j<N;j++) Au[i]+=eval_A(j,i)*u[j];
    }
}

void eval_AtA_times_u(int N, const double u[], double AtAu[])
{ double v[N]; eval_A_times_u(N,u,v); eval_At_times_u(N,v,AtAu); }

int main(int argc, char *argv[])
{
  int i;
  int N = ((argc == 2) ? atoi(argv[1]) : 2000);
  double u[N],v[N],vBv,vv;
  for(i=0;i<N;i++) u[i]=1;
  for(i=0;i<10;i++)
    {
      eval_AtA_times_u(N,u,v);
      eval_AtA_times_u(N,v,u);
    }
  vBv=vv=0;
  for(i=0;i<N;i++) { vBv+=u[i]*v[i]; vv+=v[i]*v[i]; }
  printf("%0.9f\n",sqrt(vBv/vv));
  return 0;
}


@select(tangler('speed/src/ocaml/spectralnorm.ml'))
(* The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 * 
 * Contributed by Sebastien Loisel
 * Cleanup by Troestler Christophe
 *)

let eval_A i j = 1. /. float((i+j)*(i+j+1)/2+i+1)

let eval_A_times_u u v =
  let n = Array.length v - 1 in
  for i = 0 to  n do
    v.(i) <- 0.0;
    for j = 0 to n do v.(i) <- v.(i) +. eval_A i j *. u.(j) done;
  done

let eval_At_times_u u v =
  let n = Array.length v -1 in
  for i = 0 to n do
    v.(i) <- 0.0;
    for j = 0 to n do v.(i) <- v.(i) +. eval_A j i *. u.(j) done;
  done

let eval_AtA_times_u u v =
  let w = Array.make (Array.length u) 0.0 in
  eval_A_times_u u w; eval_At_times_u w v


let () =
  let n = try int_of_string(Array.get Sys.argv 1) with _ ->  2000 in
  let u = Array.make n 1.0  and  v = Array.make n 0.0 in
  for i = 0 to 9 do
    eval_AtA_times_u u v; eval_AtA_times_u v u
  done;

  let vv = ref 0.0  and  vBv = ref 0.0 in
  for i=0 to n-1 do
    vv := !vv +. v.(i) *. v.(i);
    vBv := !vBv +. u.(i) *. v.(i)
  done;
  Printf.printf "%0.9f\n" (sqrt(!vBv /. !vv))

@select(tangler('speed/src/ada/spectralnorm.ada'))
-----------------------------------------
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
-- 
-- Contributed by Jim Rogers
-----------------------------------------
package Spectral_Utils is
   type Matrix is array(Natural range <>) of Long_Float;
   
   function Eval_A(I, J : Integer) return Long_Float;
   procedure Eval_A_Times(U : Matrix; Au : out Matrix);
   procedure Eval_At_Times(U : Matrix; Au : out Matrix);
   procedure Eval_Ata_Times_U(U : Matrix; Atau : out Matrix);
end Spectral_Utils;

-----------------------------------------
-- The Great Computer Language Shootout
--
-- Contributed by Jim Rogers
-----------------------------------------
package body Spectral_Utils is

   function Eval_A (I, J : Integer) return Long_Float is
   begin
      return 1.0 / Long_Float((I + J) * (I + J + 1) /2 + I + 1);
   end Eval_A;
   
   procedure Eval_A_Times (U : Matrix; Au : out Matrix) is
   begin
      for I in Au'range loop
         Au(I) := 0.0;
         for J in U'range loop
            Au(I) := Au(I) + Eval_A(I, J) * U(J);
         end loop;
      end loop;
   end Eval_A_Times;
   
   procedure Eval_At_Times (U : Matrix; Au : out Matrix) is
   begin
      for I in Au'range loop
         Au(I) := 0.0;
         for J in U'range loop
            Au(I) := Au(I) + Eval_A(J, I) * U(J);
         end loop;
      end loop;
   end Eval_At_Times;
   
   procedure Eval_Ata_Times_U (U : Matrix; Atau : out Matrix) is
      V : Matrix(0..U'Length - 1);
   begin
      Eval_A_Times(U, V);
      Eval_At_Times(V, Atau);
   end Eval_Ata_Times_U;
   
end Spectral_Utils;

-----------------------------------------------------------
-- The Great Computer Language Shootout
--
-- Contributed by Jim Rogers
-----------------------------------------------------------

with Ada.Text_Io;
with Ada.Numerics.Generic_Elementary_Functions ;
with Ada.Command_Line; use Ada.Command_Line;
with Spectral_Utils; use Spectral_Utils;

procedure SpectralNorm is
   package Long_Io is new Ada.Text_Io.Float_Io(Long_Float);
   package Long_Funcs is new Ada.Numerics.Generic_Elementary_Functions(Long_Float);
   use Long_Funcs;
   N : Natural := 100;
   Vbv, vv : Long_Float := 0.0;
begin
   if Argument_Count = 1 then
      N := Natural'Value(Argument(1));
   end if;
   
   declare
      U : Matrix(0..N-1) := (Others => 1.0);
      V : Matrix(0..N-1) := (Others => 0.0);
   begin
      for I in 1..10 loop
         Eval_Ata_Times_U(U, V);
         Eval_Ata_Times_U(V, U);
      end loop;
      for I in V'range loop
         Vbv := Vbv + U(I) * V(I);
         Vv := Vv + V(I)*V(I);
      end loop;
   end;
   Long_Io.Put(Item => Sqrt(Vbv/Vv), Fore => 1, Aft => 9, Exp => 0);
   Ada.Text_Io.New_Line;
end SpectralNorm;






@head(1,'[spellcheck]')
@for i in machs:
  showgraph(i,'ack','spellcheck on '+i)
  showdata('speed/machine/'+i+'/rankings/spellcheck.txt')

@select(tangler('speed/specs/spellcheck.py'))
descr='spellcheck'
min=5
max=10

@select(tangler('speed/src/c/spellcheck.c'))
/* -*- mode: c -*-
 * $Id: spellcheck.gcc,v 1.1.1.1 2004-05-19 18:13:26 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Brad Knotwell
 */

#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include "simple_hash.h"

#define MAXLINELEN 128

struct ht_ht *dict = NULL;

int handleInput(FILE *input,void (*hashManipFn)(char *))
{
    int wordbufsize = 80,i = 0;
    char *cp, *wordbuf = (char *)malloc(wordbufsize + 1);
    char line[MAXLINELEN];
    
    if((wordbuf = malloc(wordbufsize+1)) == NULL) 
        return(fprintf(stderr,"malloc\n"),0);

    while (fgets(line, MAXLINELEN, input))
	for (cp=line; *cp > 0; cp++) {
	    if (isspace(*cp)) {
		if (i) {
		    wordbuf[i] = '\0';
                    hashManipFn(wordbuf);
		    i = 0;
		}
	    } else {
		wordbuf[i++] = *cp;
		if (i == wordbufsize) {
		    wordbufsize *= 2;
		    if((wordbuf = realloc(wordbuf, wordbufsize + 1)) == NULL)
                        return(fprintf(stderr, "realloc\n"), 0);
		}
	    }
        }

    free(wordbuf);
    return(1);
}

void spellCheck(char *key) { 
    if (ht_find_new(dict,key)->val != 1) printf("%s\n",key);
}

void hashLoad(char *key) { ht_find_new(dict,key)->val = 1; }
 
int main(int argc, char *argv[]) {
    FILE *fh;
    int rc;

    /*  
        ht_create doesn't handle malloc and calloc failures 
        so this is superfluous 
    */
    if((dict = ht_create(40000)) == NULL)
        return(fprintf(stderr,"hash creation failed\n"),EXIT_FAILURE);
    
    if ((fh = fopen("Usr.Dict.Words", "r")) == NULL) 
        return(fprintf(stderr,"couldn't open dictionary\n"),EXIT_FAILURE);

    rc = ((handleInput(fh,hashLoad) && handleInput(stdin,spellCheck)) ? EXIT_SUCCESS : EXIT_FAILURE);

    ht_destroy(dict);
    return(rc);
}

@select(tangler('speed/src/ocaml/spellcheck.ml'))
(*
 * $Id: spellcheck.ocaml,v 1.1.1.1 2004-05-19 18:13:26 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * with help from Markus Mottl
 *)

let dict = Hashtbl.create 40000 and ic = open_in "Usr.Dict.Words" in
try while true do Hashtbl.add dict (input_line ic) true done
with End_of_file -> close_in ic;
let rec loop () =
  let word = input_line stdin in
  if not (Hashtbl.mem dict word) then print_endline word;
  loop () in
try loop () with End_of_file -> ()

@select(tangler('speed/src/felix/spellcheck.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
include "stl";
open Stl;
open Stl::HashSet;
open Text_file;

requires ext_string_hash;

var prefix = Env::getenv "DICT_DIR";
if prefix == "" do prefix = "./"; done;


var dict = HashSet::create[string]();
var f = fopen_input (prefix + "Usr.Dict.Words");
var word = readln f;
until word == "" do insert (dict,word); word = readln f; done;
fclose f;

word = readln stdin;
until word == "" do
  if not (mem (dict,word)) do print word; done;
  word = readln stdin;
done;


@select(tangler('speed/src/ada/spellcheck.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by David Sauvage 2005/04/07
with Dictionnary_Mgr;

procedure Spellcheck is
begin
   Dictionnary_Mgr.Load ("Usr.Dict.Words");
   Dictionnary_Mgr.Word_Analysis;
end Spellcheck;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by David Sauvage 2005/04/07
with GNAT.Spitbol;

package Dictionnary_Mgr is

   package Dictionnary is new GNAT.Spitbol.Table (Boolean, False, Boolean'Image);

   Map : Dictionnary.Table (40_000);

   -- ------------------------------------------------
   procedure Load (File_Name : String);
   -- ------------------------------------------------
   procedure Word_analysis;

end Dictionnary_Mgr;
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by David Sauvage 2005/04/07
with Ada.Streams, Ada.Streams.Stream_IO, Ada.Text_IO, GNAT.Spitbol;
use  Ada.Streams, Ada.Streams.Stream_IO;

package body Dictionnary_Mgr is

   Tmp_Word : String (1 ..128);
   Index    : Natural range 0 .. Tmp_Word'Last := 0;

   -- ------------------------------------------------
   procedure Load (File_Name : String) is
      Dictionnary_File : File_Type;
      Buffer           : Stream_Element_Array (1 .. 4_096);
      Last             : Stream_Element_Offset;

      -- ------------------------------------------------
      procedure Process (Buffer : Stream_Element_Array) is
      begin
           for I in Buffer'Range loop
            if Character'Val(Buffer (I)) = ASCII.LF then
               if Index > 1 then
                  Dictionnary.Set (Map, Tmp_Word (1 .. Index),True);
               end if;
               Index := 0;
            else
               Index := Index + 1;
               Tmp_Word(Index) := Character'Val(Buffer (I));

            end if;
         end loop;
      end Process;

   begin
      Open (Dictionnary_File, In_File, File_Name);

      loop
         Read (Dictionnary_File, Buffer, Last);
         Process (Buffer (1 .. Last));
         exit when Last < Buffer'Length;
      end loop ;

      Close (Dictionnary_File);
   end Load;

   -- ------------------------------------------------
   procedure Word_analysis is
      Word : String (1 .. 128);
      Last : Natural;
      use Ada.Text_IO;
   begin

      loop
         Get_Line (Word, Last);
         if not Dictionnary.Present (Map, Word (1 .. Last)) then
            Put_Line (Standard_Output, Word (1 .. Last));
         end if;
      end loop;

   exception
      when Ada.Text_IO.End_Error =>
         null;
   end Word_analysis;

end Dictionnary_Mgr;

@head(1,'[strcat]')
@for i in machs:
  showgraph(i,'ack','strcat on '+i)
  showdata('speed/machine/'+i+'/rankings/strcat.txt')

@select(tangler('speed/specs/strcat.py'))
descr='strcat'
min=5
max=10

@select(tangler('speed/src/c/strcat.c'))
/* -*- mode: c -*-
 * $Id: strcat.gcc,v 1.1.1.1 2004-05-19 18:13:34 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define STUFF "hello\n"

int
main(int argc, char *argv[]) {
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    int i, buflen = 32;
    char *strbuf = calloc(sizeof(char), buflen);
    char *strend = strbuf;
    int stufflen = strlen(STUFF);

    if (!strbuf) { perror("calloc strbuf"); exit(1); }
    for (i=0; i<n; i++) {
	if (((strbuf+buflen)-strend) < (stufflen+1)) {
	    buflen = 2*buflen;
	    strbuf = realloc(strbuf, buflen);
	    if (!strbuf) { perror("realloc strbuf"); exit(1); }
	    strend = strbuf + strlen(strbuf);
	}
	/* much faster to strcat to strend than to strbuf */
	strcat(strend, STUFF);
	strend += stufflen;
    }
    fprintf(stdout, "%d\n", strlen(strbuf));
    free(strbuf);

    sleep(1);
    return(0);
}

@select(tangler('speed/src/ocaml/strcat.ml'))
(*
 * $Id: strcat.ocaml,v 1.1.1.1 2004-05-19 18:13:35 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from: Benedikt Rosenau
 *)

let n = if Array.length Sys.argv > 1 then int_of_string Sys.argv.(1) else 1
let buf = Buffer.create 0;;
for i = 1 to n do Buffer.add_string buf "hello\n" done;
Printf.printf "%d\n" (Buffer.length buf); Unix.sleep(1)

@select(tangler('speed/src/felix/strcat.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
// Adapted from C++ solution

var str = "";
var capacity = 31;
reserve(str,capacity); // as per C-string
var newLength = 6;
var i = n;
until i == 0 do
  if newLength > capacity do
    capacity *= 2;
    reserve(str,capacity);
  done;
  str += c"hello\n";
  newLength += 6;
  --i;
done;

print (len str); endl;


@head(1,'[sumcol]')
@for i in machs:
  showgraph(i,'ack','sumcol on '+i)
  showdata('speed/machine/'+i+'/rankings/sumcol.txt')

@select(tangler('speed/specs/sumcol.py'))
descr='sumcol'
min=5
max=10

@select(tangler('speed/src/c/sumcol.c'))
/* -*- mode: c -*-
 * $Id: sumcol.gcc,v 1.1.1.1 2004-05-19 18:13:43 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 */

#include <stdio.h>
#include <stdlib.h>

#define MAXLINELEN 128

int
main() {
    int sum = 0;
    char line[MAXLINELEN];

    while (fgets(line, MAXLINELEN, stdin)) {
	sum += atoi(line);
    }
    printf("%d\n", sum);
    return(0);
}


@select(tangler('speed/src/ocaml/sumcol.ml'))
(*
 * $Id: sumcol.ocaml,v 1.1.1.1 2004-05-19 18:13:44 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * from Markus Mottl
 *)

let sum = ref 0
let rec loop () = sum := !sum + int_of_string (input_line stdin); loop ();;
try loop () with End_of_file -> Printf.printf "%d\n" !sum

@select(tangler('speed/src/felix/sumcol.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);

open Text_file;
var sum = 0;
var line = readln stdin;

until line == "" do
  sum += atoi(line);
  line = readln stdin;
done;

print sum; endl;



@select(tangler('speed/src/ada/sumcol.ada'))
-- $Id: sumcol.gnat,v 1.4 2005-03-30 11:01:07 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- by James S. Rogers
-- Simplified by Pascal Obry on 2005/03/17
-- Faster version by Bill Findlay on 2005/03/23

with Ada.Text_IO, Ada.Strings.Fixed;
use  Ada.Text_IO, Ada.Strings.Fixed;

procedure SumCol is
  Line : String (1 .. 128);
  Sum  : Integer := 0;
  Len  : Natural;
begin
  loop
    Get_Line (Item => Line, Last => Len);
    Sum := Sum + Integer'Value (Line (1 .. Len));
   end loop;
exception
   when End_Error =>
      Put_Line (Trim (Integer'Image(Sum), Ada.Strings.Both));
end SumCol;

@head(1,'[takfp]')
@for i in machs:
  showgraph(i,'ack','takfp on '+i)
  showdata('speed/machine/'+i+'/rankings/takfp.txt')

@select(tangler('speed/specs/takfp.py'))
descr='takfp'
min=5
max=10

@select(tangler('speed/src/c/takfp.c'))
/* $Id: takfp.gcc,v 1.3 2004-12-10 08:09:21 bfulgham Exp $
 * http://shootout.alioth.debian.org/ 
 * Contributed by Brent Fulgham 
 */
#include <stdio.h>
#include <stdlib.h>

float Tak (float x, float y, float z)
{
    if (y >= x) return z;
    return Tak(Tak(x-1,y,z), Tak(y-1,z,x), Tak(z-1,x,y));
}

int main(int argc, char* argv[])
{
    int n = ((argc == 2) ? atoi(argv[1]) : 1);
    printf("%.1f\n", Tak(n*3.0, n*2.0, n*1.0));
    return 0;
}

/* Make Brent's life easier...
 * vim: ts=4 ft=c
 */

@select(tangler('speed/src/ocaml/takfp.ml'))
(* takfp.ml                                                 -*-tuareg-*-
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by William Douglas Neumann
 *)

let rec tak x y z =
  if y >= x then z
  else tak (tak (x -. 1.) y z) (tak (y -. 1.) z x) (tak (z -. 1.) x y)

let () =
  let n = try float_of_string(Array.get Sys.argv 1) with _ -> 7. in
  Printf.printf "%.1f\n" (tak (3. *. n) (2. *. n) n)

@select(tangler('speed/src/felix/takfp.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
proc print1: double = 'printf("%.1f\\n",$1);';

fun Tak (x:double, y:double, z:double): double =>
  if (y >= x) then z
  else Tak(Tak(x-1.0,y,z), Tak(y-1.0,z,x), Tak(z-1.0,x,y))
  endif
;

w := double_of n;
print1 (Tak(w*3.0, w*2.0, w*1.0));

#import <flx.flxh>

// vim: ts=4 ft=felix

@select(tangler('speed/src/ada/takfp.ada'))
-- $Id: takfp.gnat,v 1.6 2005-03-30 17:53:38 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Vasiliy Fofanov and Pascal Obry on 2005/03/22
-- Fixed by Pascal Obry on 2005/03/30

package Takfp_Pck is
   function Tak (X, Y, Z : Float) return Float;
end Takfp_Pck;

package body Takfp_Pck is

   function Tak (X, Y, Z : Float) return Float is
   begin
      if Y >= X then
         return Z;
      else
         return Tak
           (Tak (X - 1.0, Y, Z), Tak (Y - 1.0, Z, X), Tak (Z - 1.0, X, Y));
      end if;
   end Tak;

end Takfp_Pck;

-- $Id: takfp.gnat,v 1.6 2005-03-30 17:53:38 obry-guest Exp $
-- http://shootout.alioth.debian.org
-- Contributed by Vasiliy Fofanov and Pascal Obry on 2005/03/22
-- Fixed by Pascal Obry on 2005/03/30

with Ada.Text_IO;       use Ada.Text_IO;
with Ada.Float_Text_IO; use Ada.Float_Text_IO;
with Ada.Command_Line;  use Ada.Command_Line;
with Takfp_Pck;         use Takfp_Pck;

procedure Takfp is
   N : Float;
begin
   N := Float'Value (Argument (1));
   Put (Tak (N * 3.0, N * 2.0, N * 1.0), 0, 1, 0);
   New_Line;
end Takfp;

@head(1,'[tcpecho]')
@for i in machs:
  showgraph(i,'ack','tcpecho on '+i)
  showdata('speed/machine/'+i+'/rankings/tcpecho.txt')

@select(tangler('speed/specs/tcpecho.py'))
descr='tcpecho'
min=5
max=10

@select(tangler('speed/src/c/tcpecho.c'))
/* 
 The Great Computer Language Shootout
  http://shootout.alioth.debian.org/

  contributed by John O'Hare 05 August 2005.
*/


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define PORT_NUMBER 12340
#define M 6400
#define REPLY_SIZE 64
#define REQUEST_SIZE 64
#define BUFFER_SIZE 1024

void server()
{
	int sock;
	int conn;
	struct sockaddr_in servaddr;
	struct sockaddr_in cliaddr;
	unsigned int cliaddr_len;
	char* reply = malloc(REPLY_SIZE);
	char* buf = malloc(BUFFER_SIZE);

	memset(reply, '<', REPLY_SIZE);

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		exit(10);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (bind(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(11);

	if (listen(sock, 1) < 0)
		exit(12);

	if ((conn = accept(sock, (struct sockaddr *) &cliaddr, &cliaddr_len)) < 0)
		exit(13);

	while (recv(conn, buf, BUFFER_SIZE, 0) > 0) {
		if (send(conn, reply, REPLY_SIZE, 0) != REPLY_SIZE)
			exit(14);
	}

	close(conn);
	close(sock);

	free(buf);
}

void client(int n)
{
	int sock;
	struct sockaddr_in servaddr;
	char* request = malloc(REQUEST_SIZE);
	char* buf = malloc(BUFFER_SIZE);
	int tmpbytes;
	int bytes = 0;
	int replies = 0;

	memset(request, '>', REQUEST_SIZE);

	sleep(2); //wait for server to start

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) 
		exit(2);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (connect(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(3);

	while (n-- > 0) {
		tmpbytes = 0;

		if (send(sock, request, REQUEST_SIZE, 0) != REQUEST_SIZE)
			exit(4);

		while (tmpbytes < REPLY_SIZE)
			tmpbytes += recv(sock, buf, BUFFER_SIZE - 1, 0);
		bytes += tmpbytes;
		replies++;
	}
	close(sock);

	printf("replies: %d\tbytes: %d\n", replies, bytes);

	free(request);
	free(buf);
}

int main (int argc, char** argv)
{	
	int pid;
	int n;

	n = (argc == 2 ? atoi(argv[1]) : 1);

	if ((pid = fork()) < 0) {
		return 1;
	}
	if (pid == 0) {
		client(M * n);
	} else {
		server();
	}
	return 0;
}

@select(tangler('speed/src/ocaml/tcpecho.ml'))
(* tcp-request-reply.ml / tcp-echo.ml / tcp-stream.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

let m = 6400 and reply_size = 64  (* tcp-echo *)

let request_size = 64
let buffer_size  = 4096
let port	 = 11000

let reply   = String.create reply_size
let request = String.create request_size

(* Monomorphic version for speed *)
let min i j = if (i:int) < j then i else j

(* Return [false] if EOF is reached *)
let rec read sock buf n =
  n <= 0 || (let r = Unix.read sock buf 0 (min n buffer_size) in
	     r > 0 && read sock buf (n - r))

let server sock =
  let b = String.create buffer_size in
  let (s, _) = Unix.accept sock in
  while read s b request_size do ignore(Unix.write s reply 0 reply_size) done;
  Unix.close s;
  Unix.close sock

let client n =
  let b = String.create buffer_size
  and replies = ref 0 and bytes = ref 0 in (* useless but mandated by spec *)
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.connect sock (Unix.ADDR_INET(Unix.inet_addr_loopback, port));
  for i = 1 to n do
    ignore(Unix.write sock request 0 request_size);
    ignore(read sock b reply_size);
    bytes := !bytes + reply_size;
    incr replies
  done;
  Unix.close sock;
  Printf.printf "replies: %i\tbytes: %i\n" !replies !bytes; flush stdout


let () =
  let n = m * (try int_of_string Sys.argv.(1) with _ -> 10) in
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.setsockopt sock Unix.SO_REUSEADDR true;
  Unix.bind sock (Unix.ADDR_INET(Unix.inet_addr_any, port));
  Unix.listen sock 1;
  match Unix.fork() with
  | 0 ->   server sock
  | pid -> client n; ignore(Unix.wait())


@select(tangler('speed/src/ada/tcpecho.ada'))
-- $Id: tcpecho.gnat,v 1.1 2005-03-31 14:08:44 obry-guest Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry on 2005/03/31

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Streams;         use Ada.Streams;
with GNAT.Sockets;        use GNAT.Sockets;

procedure TCPEcho is

   N            : constant Positive := Positive'Value (Argument (1));
   M            : constant := 6_400;
   Reply_Size   : constant := 64;
   Request_Size : constant := 64;

   Reply   : constant Stream_Element_Array := (1 .. Reply_Size => 88);
   Request : constant Stream_Element_Array := (1 .. Request_Size => 23);

   Address : Sock_Addr_Type;

   task Client is
      entry Start;
   end Client;

   task body Client is
      Socket : Socket_Type;
      Buffer : Stream_Element_Array (1 .. Reply_Size);
      Last   : Stream_Element_Offset;
      Count  : Natural := 0;
      Bytes  : Natural := 0;
   begin
      accept Start;

      Create_Socket (Socket);
      Connect_Socket (Socket, Address);

      for K in 1 .. M * N loop
         Send_Socket (Socket, Request, Last);

         Bytes := 0;
         while Bytes /= Reply_Size loop
            Receive_Socket (Socket, Buffer, Last);
            Bytes := Bytes + Natural (Last);
         end loop;

         Count := Count + Bytes;
      end loop;

      Close_Socket (Socket);

      Put ("replies: "); Put (N * M, Width => 0);
      Put (ASCII.HT & "bytes: "); Put (Count, Width => 0);
   end Client;

   Server_Socket : Socket_Type;
   Socket        : Socket_Type;
   Buffer        : Stream_Element_Array (1 .. Request_Size);
   Last          : Stream_Element_Offset;

begin
   Address.Addr := Addresses (Get_Host_By_Name ("localhost"), 1);
   Address.Port := 2987;

   Create_Socket (Server_Socket);
   Bind_Socket (Server_Socket, Address);
   Listen_Socket (Server_Socket);

   Client.Start;

   Accept_Socket (Server_Socket, Socket, Address);

   for K in 1 .. M * N loop
      Receive_Socket (Socket, Buffer, Last);
      Send_Socket (Socket, Reply, Last);
   end loop;
end TCPEcho;

@head(1,'[tcpsocket]')
@for i in machs:
  showgraph(i,'ack','tcpsocket on '+i)
  showdata('speed/machine/'+i+'/rankings/tcpsocket.txt')

@select(tangler('speed/specs/tcpsocket.py'))
descr='tcpsocket'
min=5
max=10

@head(1,'[tcpstream]')
@for i in machs:
  showgraph(i,'ack','tcpstream on '+i)
  showdata('speed/machine/'+i+'/rankings/tcpstream.txt')

@select(tangler('speed/specs/tcpstream.py'))
descr='tcpstream'
min=5
max=10

@select(tangler('speed/src/c/tcp-stream.c'))
/* 
 The Great Computer Language Shootout
  http://shootout.alioth.debian.org/

  contributed by John O'Hare 05 August 2005.
*/


#include <stdio.h>
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define PORT_NUMBER 12342
#define M 1
#define REPLY_SIZE 409600
#define REQUEST_SIZE 64
#define BUFFER_SIZE 1024

void server()
{
	int sock;
	int conn;
	struct sockaddr_in servaddr;
	struct sockaddr_in cliaddr;
	unsigned int cliaddr_len;
	char* reply = malloc(REPLY_SIZE);
	char* buf = malloc(BUFFER_SIZE);

	memset(reply, '<', REPLY_SIZE);

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0)
		exit(10);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (bind(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(11);

	if (listen(sock, 1) < 0)
		exit(12);

	if ((conn = accept(sock, (struct sockaddr *) &cliaddr, &cliaddr_len)) < 0)
		exit(13);

	while (recv(conn, buf, BUFFER_SIZE, 0) > 0) {
		if (send(conn, reply, REPLY_SIZE, 0) != REPLY_SIZE)
			exit(14);
	}

	close(conn);
	close(sock);

	free(buf);
}

void client(int n)
{
	int sock;
	struct sockaddr_in servaddr;
	char* request = malloc(REQUEST_SIZE);
	char* buf = malloc(BUFFER_SIZE);
	int tmpbytes;
	int bytes = 0;
	int replies = 0;

	memset(request, '>', REQUEST_SIZE);

	sleep(2); //wait for server to start

	if ((sock = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) 
		exit(2);

	memset(&servaddr, 0, sizeof(servaddr));
	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htonl(INADDR_LOOPBACK);
	servaddr.sin_port = htons(PORT_NUMBER);

	if (connect(sock, (struct sockaddr *) &servaddr, sizeof(servaddr)) < 0)
		exit(3);

	while (n-- > 0) {
		tmpbytes = 0;

		if (send(sock, request, REQUEST_SIZE, 0) != REQUEST_SIZE)
			exit(4);

		while (tmpbytes < REPLY_SIZE)
			tmpbytes += recv(sock, buf, BUFFER_SIZE - 1, 0);
		bytes += tmpbytes;
		replies++;
	}
	close(sock);

	printf("replies: %d\tbytes: %d\n", replies, bytes);

	free(request);
	free(buf);
}

int main (int argc, char** argv)
{	
	int pid;
	int n;

	n = (argc == 2 ? atoi(argv[1]) : 1);

	if ((pid = fork()) < 0) {
		return 1;
	}
	if (pid == 0) {
		client(M * n);
	} else {
		server();
	}
	return 0;
}

@select(tangler('speed/src/ocaml/tcpstream.ml'))
(* tcp-request-reply.ml / tcp-echo.ml / tcp-stream.ml
 *
 * The Great Computer Language Shootout
 * http://shootout.alioth.debian.org/
 *
 * Contributed by Troestler Christophe
 *)

let m = 1 and reply_size = 409600 (* tcp-stream *)

let request_size = 64
let buffer_size  = 4096
let port	 = 11000

let reply   = String.create reply_size
let request = String.create request_size

(* Monomorphic version for speed *)
let min i j = if (i:int) < j then i else j

(* Return [false] if EOF is reached *)
let rec read sock buf n =
  n <= 0 || (let r = Unix.read sock buf 0 (min n buffer_size) in
	     r > 0 && read sock buf (n - r))

let server sock =
  let b = String.create buffer_size in
  let (s, _) = Unix.accept sock in
  while read s b request_size do ignore(Unix.write s reply 0 reply_size) done;
  Unix.close s;
  Unix.close sock

let client n =
  let b = String.create buffer_size
  and replies = ref 0 and bytes = ref 0 in (* useless but mandated by spec *)
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.connect sock (Unix.ADDR_INET(Unix.inet_addr_loopback, port));
  for i = 1 to n do
    ignore(Unix.write sock request 0 request_size);
    ignore(read sock b reply_size);
    bytes := !bytes + reply_size;
    incr replies
  done;
  Unix.close sock;
  Printf.printf "replies: %i\tbytes: %i\n" !replies !bytes; flush stdout


let () =
  let n = m * (try int_of_string Sys.argv.(1) with _ -> 10) in
  let sock = Unix.socket Unix.PF_INET Unix.SOCK_STREAM 0 in
  Unix.setsockopt sock Unix.SO_REUSEADDR true;
  Unix.bind sock (Unix.ADDR_INET(Unix.inet_addr_any, port));
  Unix.listen sock 1;
  match Unix.fork() with
  | 0 ->   server sock
  | pid -> client n; ignore(Unix.wait())


@select(tangler('speed/src/ada/tcpstream.ada'))
-- $Id: tcpstream.gnat,v 1.1 2005-03-31 14:10:02 obry-guest Exp $
-- http://shootout.alioth.debian.org/
--
-- Contributed by Pascal Obry on 2005/03/31

with Ada.Command_Line;    use Ada.Command_Line;
with Ada.Text_IO;         use Ada.Text_IO;
with Ada.Integer_Text_IO; use Ada.Integer_Text_IO;
with Ada.Streams;         use Ada.Streams;
with GNAT.Sockets;        use GNAT.Sockets;

procedure TCPStream is

   N            : constant Positive := Positive'Value (Argument (1));
   M            : constant := 1;
   Reply_Size   : constant := 409_600;
   Request_Size : constant := 64;

   Reply   : constant Stream_Element_Array := (1 .. Reply_Size => 88);
   Request : constant Stream_Element_Array := (1 .. Request_Size => 23);

   Address : Sock_Addr_Type;

   task Client is
      entry Start;
   end Client;

   task body Client is
      Socket : Socket_Type;
      Buffer : Stream_Element_Array (1 .. Reply_Size);
      Last   : Stream_Element_Offset;
      Count  : Natural := 0;
      Bytes  : Natural := 0;
   begin
      accept Start;

      Create_Socket (Socket);
      Connect_Socket (Socket, Address);

      for K in 1 .. M * N loop
         Send_Socket (Socket, Request, Last);

         Bytes := 0;
         while Bytes /= Reply_Size loop
            Receive_Socket (Socket, Buffer, Last);
            Bytes := Bytes + Natural (Last);
         end loop;

         Count := Count + Bytes;
      end loop;

      Close_Socket (Socket);

      Put ("replies: "); Put (N * M, Width => 0);
      Put (ASCII.HT & "bytes: "); Put (Count, Width => 0);
   end Client;

   Server_Socket : Socket_Type;
   Socket        : Socket_Type;
   Buffer        : Stream_Element_Array (1 .. Request_Size);
   Last          : Stream_Element_Offset;

begin
   Address.Addr := Addresses (Get_Host_By_Name ("localhost"), 1);
   Address.Port := 2987;

   Create_Socket (Server_Socket);
   Bind_Socket (Server_Socket, Address);
   Listen_Socket (Server_Socket);

   Client.Start;

   Accept_Socket (Server_Socket, Socket, Address);

   for K in 1 .. M * N loop
      Receive_Socket (Socket, Buffer, Last);
      Send_Socket (Socket, Reply, Last);
   end loop;
end TCPStream;

@head(1,'[wc]')
@for i in machs:
  showgraph(i,'ack','wc on '+i)
  showdata('speed/machine/'+i+'/rankings/wc.txt')

@select(tangler('speed/specs/wc.py'))
descr='wc'
min=5
max=10

@select(tangler('speed/src/c/wc.c'))
/* -*- mode: c -*-
 * $Id: wc.gcc,v 1.2 2004-06-18 07:02:55 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 *
 * Author: Waldemar Hebisch (hebisch@math.uni.wroc.pl)
 * Optimizations: Michael Herf (mike@herfconsulting.com)
 * Further Revisions: Paul Hsieh (qed@pobox.com)
 */

#include <stdio.h>
#include <unistd.h>
#include <limits.h>

#define BSIZ 4096

unsigned long ws[UCHAR_MAX + 1];
unsigned long nws[UCHAR_MAX + 1];
char buff[BSIZ];

int main(void) {
    unsigned long prev_nws = 0x10000L, w_cnt = 0, l_cnt = 0, b_cnt = 0, cnt;

    /* Fill tables */
    for (cnt = 0; cnt <= UCHAR_MAX; cnt++) {
         ws[cnt] =  (cnt == ' ' || cnt == '\n' || cnt == '\t') + (0x10000L & -(cnt == '\n'));
	nws[cnt] = !(cnt == ' ' || cnt == '\n' || cnt == '\t') +  0x10000L;
    }

    
    /* Main loop */
    while (0 != (cnt = read (0, buff, BSIZ))) {
        unsigned long vect_count = 0;
	unsigned char *pp, *pe;

	b_cnt += cnt;
	pe = buff + cnt;
	pp = buff;

	while (pp < pe) {
	    vect_count +=  ws[*pp] & prev_nws;
	    prev_nws    = nws[*pp];
	    pp ++;
	}
	w_cnt += vect_count  & 0xFFFFL;
	l_cnt += vect_count >> 16;
    }

    w_cnt += 1 & prev_nws;

    printf ("%d %d %d\n", l_cnt, w_cnt, b_cnt);
    return 0;
}

@select(tangler('speed/src/ocaml/wc.ml'))
(*
 * $Id: wc.ocaml,v 1.1.1.1 2004-05-19 18:13:51 bfulgham Exp $
 * http://www.bagley.org/~doug/shootout/
 * based on code by Cuihtlauac ALVARADO and Markus Mottl
 *)

let nl = ref 0 and nw = ref 0 and nc = ref 0 and max = 4096
let buf = String.create max

let readblock scanfun =
  let nread = input stdin buf 0 max in
  if nread = 0 then ()
  else begin nc := !nc + nread; scanfun 0 nread end

let rec scan_out_of_word i n =
  if i < n then
    match buf.[i] with
    | '\n' -> incr nl; scan_out_of_word (i + 1) n
    | ' ' | '\t' -> scan_out_of_word (i + 1) n
    | _ -> incr nw; scan_in_word (i+1) n
  else readblock scan_out_of_word

and scan_in_word i n =
  if i < n then
    match buf.[i] with
    | '\n' -> incr nl; scan_out_of_word (i + 1) n
    | ' '|'\t' -> scan_out_of_word (i + 1) n
    | _ -> scan_in_word (i + 1) n
  else readblock scan_in_word;;

scan_out_of_word 0 0;
Printf.printf "%d %d %d\n" !nl !nw !nc

@select(tangler('speed/src/felix/wc.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
open Ulong;

body '''
#include <limits.h>
#include <unistd.h>
#define BSIZE 4096
unsigned long wds[UCHAR_MAX + 1];
unsigned long nwds[UCHAR_MAX + 1];
char sp=' ';
char tab = '\\t';
char lf='\\n';
unsigned char buff[BSIZE];
''';

const UCHAR_MAX:int;
const BSIZE:int;
const sp:int;
const lf:int;
const tab:int;

proc setws: int * ulong = "wds[$1]=$2;";
proc setnws: int * ulong = "nwds[$1]=$2;";
fun getws: ulong -> ulong = "wds[$1]";
fun getnws: ulong -> ulong = "nwds[$1]";

fun readbuf: unit -> int = "read(0,buff,BSIZE)";

var prev_nws = 0x1_0000uL;
var w_cnt = 0uL;
var l_cnt = 0uL;
var b_cnt = 0uL;

type iterator = "unsigned char *";
fun eq: iterator * iterator -> bool = "$1 == $2";
fun deref: iterator -> ulong = "*$1";
fun add: iterator * ulong -> iterator = "$1 + $2";
proc post_incr: iterator = "$1++;";

fun band: ulong * ulong -> ulong = "$1 & $2";
fun hi: ulong -> ulong = "$1 >> 16";
fun lo: ulong -> ulong = "$1 & 0xFFFFuL";
fun parity : ulong -> ulong = "$1 & 1uL";
fun neg: ulong -> ulong = "-$1";

const buff: iterator = "buff";

fun iswhite(ch:int) =>
  ch == sp or ch == tab or ch == lf;

fun islf(ch:int)=> ch == lf;

fun ul(x:bool)=> C_hack::cast[ulong]x;

/* Fill tables */
{
  var ch = UCHAR_MAX; until ch < 0 do
    setws(ch, ul (iswhite ch) + band (0x10000uL,  -(ul (islf ch))));
    setnws(ch, ul (not (iswhite ch)) +  0x10000uL);
    --ch;
  done;
};

/* Main loop */
{
  var cnt: ulong;
  proc uread() {
    var n = readbuf();
    if n < 0 do System::exit 1; done;
    cnt = C_hack::cast[ulong]n;
  }

  uread;
  whilst cnt > 0uL do
    var vect_count = 0uL;
    var pp:iterator;
    pe := buff + cnt;

    b_cnt += cnt;
    pp = buff;

    until pp == pe do
      vect_count += band (getws(deref pp), prev_nws);
      prev_nws    = getnws(deref pp);
      pp++;
    done;
    w_cnt += lo vect_count;
    l_cnt += hi vect_count;
    uread;
  done;

  w_cnt += parity prev_nws;
};

print l_cnt; print " "; print w_cnt; print " "; print b_cnt; endl;


@select(tangler('speed/src/ada/wc.ada'))
-- $Id: wc.gnat,v 1.4 2005-03-30 13:56:16 obry-guest Exp $
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by Marius Amado Alves
-- Fixed by Pascal Obry on 2005/03/30
--
-- gnatmake -O3 cw.adb

with Ada.Characters.Handling;  use Ada.Characters.Handling;
with Ada.Characters.Latin_1;   use Ada.Characters.Latin_1;
with Ada.Command_Line;         use Ada.Command_Line;
with Ada.Streams;              use Ada.Streams;
with Ada.Streams.Stream_IO;    use Ada.Streams.Stream_IO;
with Ada.Strings.Fixed;
with Ada.Text_IO;              use Ada.Text_IO;
with Ada.Text_IO.Text_Streams; use Ada.Text_IO.Text_Streams;

procedure wc is

   Input_Stream : constant Text_Streams.Stream_Access :=
     Stream (Current_Input);
   EOL          : constant Stream_Element := Character'Pos (LF);
   Is_Separator : constant array (Stream_Element) of Boolean :=
     (0 .. 32 | 127 .. 159 => True, others => False);

   In_Word : Boolean := False;
   Buffer  : Stream_Element_Array (1 .. 4_096);
   N       : Stream_Element_Offset;

   Lines   : Natural := 0;
   Words   : Natural := 0;
   Total   : Natural := 0;

   procedure Begin_Word is
   begin
      Words := Words + 1;
      In_Word := True;
   end Begin_Word;

   procedure End_Word is
   begin
      In_Word := False;
   end End_Word;

   procedure End_Line is
   begin
      Lines := Lines + 1;
      End_Word;
   end End_Line;

   procedure Count_Words (S : in Stream_Element_Array) is
   begin
      Total := Total + S'Length;
      for I in S'Range loop
         if S (I) = EOL then
            End_Line;
         else
            if Is_Separator (S (I)) then
               if In_Word then
                  End_Word;
               end if;
            else
               if not In_Word then
                  Begin_Word;
               end if;
            end if;
         end if;
      end loop;
   end Count_Words;

   pragma Inline (Begin_Word, End_Word, End_Line, Count_Words);

begin
   loop
      Read (Root_Stream_Type'Class (Input_Stream.all), Buffer, N);
      Count_Words (Buffer (1 .. N));
      exit when N < Buffer'Length;
   end loop;

   declare
      Result : constant String :=
        Natural'Image (Lines) & Natural'Image (Words) & Natural'Image (Total);
   begin
      Ada.Text_IO.Put_Line (Result (Result'First + 1 .. Result'Last));
   end;
end wc;

@head(1,'[wordfreq]')
@for i in machs:
  showgraph(i,'ack','wordfreq on '+i)
  showdata('speed/machine/'+i+'/rankings/wordfreq.txt')

@select(tangler('speed/specs/wordfreq.py'))
descr='wordfreq'
min=5
max=10

@select(tangler('speed/src/ocaml/wordfreq.ml'))
(*
 * $Id: wordfreq.ocaml,v 1.3 2004-09-29 06:24:32 bfulgham Exp $
 * http://shootout.alioth.debian.org/
 * with help from Markus Mottl
 *)

let max = 4096
let buf = String.create max
let count = Hashtbl.create 75000 and wbuf = Buffer.create 64
let to_list w c l = Printf.sprintf "%7d %s" !c w :: l

let rec scan_words i n inword =
  if i < n then
    let c = buf.[i] in
    if 'a' <= c && c <= 'z' then begin
      Buffer.add_char wbuf c;
      scan_words (i + 1) n true
    end
    else if 'A' <= c && c <= 'Z' then begin
      Buffer.add_char wbuf (Char.unsafe_chr (Char.code c + 32));
      scan_words (i + 1) n true
    end
    else if inword then begin
      let word = Buffer.contents wbuf in
      begin try incr (Hashtbl.find count word)
      with Not_found -> Hashtbl.add count word (ref 1) end;
      Buffer.clear wbuf;
      scan_words (i + 1) n false
    end
    else scan_words (i + 1) n false
  else
    let nread = input stdin buf 0 max in
    if nread <> 0 then scan_words 0 nread inword;;

scan_words 0 0 false;

let out_lines = Hashtbl.fold (fun k d l -> (k, !d) :: l) count [] in
List.iter (fun (k, d) -> Printf.printf "%7d %s\n" d k)
  (List.sort (fun (ka, da) (kb, db) -> 
                let c = compare db da in
                if c <> 0 then c
                else String.compare kb ka) out_lines)


@select(tangler('speed/src/felix/wordfreq.flx'))
//
// Contributed by John Skaller
//
#import <flx.flxh>
n := atoi(System::argv 1);
include "stl";
open Stl;
open Stl::HashMap;
open Stl::Set;
open Text_file;
open Lexer;

body lt_cmp[t] """
  namespace std {
    template<>
    bool less<?1> :: operator()(?1 const &a, ?1 const &b)const {
     return a.mem_0 == b.mem_0 ?? a.mem_1 < b.mem_1 : a.mem_0 > b.mem_0;
    }
  }
""";

proc tolower : lvalue[string] = "tol($1);" requires
  body """
    void tol(std::string &x) {
      std::string::iterator e = x.end();
      for(std::string::iterator i = x.begin(); i != e; ++i)
        *i = tolower (*i);
    }
  """,
  cctype_hxx
;

requires ext_string_hash;
requires lt_cmp[int * string];

regexp upper = ["ABCDEFGHIJKLMNOPQRSTUVWXYZ"];
regexp lower = ["abcdefghijklmnopqrstuvwxyz"];
regexp wrd = ( upper | lower) +;

fun lexit (start:iterator, finish:iterator): iterator * bool =>
  reglex start to finish with
  | wrd => true
  | _ => false
  endmatch
;

var dict = HashMap::create[string,int]();
proc add_word(s:iterator, e:iterator)
{
  var word = string_between(s,e);
  tolower word;
  p := find (dict,word);
  if p == end dict do
    insert (dict,word,1);
  else
    k,j := deref p;
    (deref p).(1) ++;
  done;
};

{
  var data = readln stdin;
  until data == "" do
    first := start_iterator data;
    last := end_iterator data;

    var current = first;
    var next = first;
    var isword : bool;
    until current == last do
      next, isword = lexit(current, last);
      if isword do
        add_word(current,next);
        current = next;
      else
        ++current;
      done;
    done;
    data = readln stdin;
  done;
};

var wmap = Set::create[int * string] ();
{
  var cur = begin dict;
  dlast := end dict;
  until cur == dlast do
    word, count := deref cur;
    insert (wmap,(count,word));
    ++cur;
  done;
};

{
  var cur = begin wmap;
  last := end wmap;
  until cur == last do
    count, word := deref cur;
    print ("       " + str count).[-7 to]; print " "; print word; endl;
    ++cur;
  done;
};


@select(tangler('speed/src/ada/wordfreq.ada'))
-- The Great Computer Language Shootout
-- http://shootout.alioth.debian.org/
--
-- contributed by Marius Amado Alves
--
-- gnatmake -O3 -gnatp word_frequency.adb

with Ada.Streams;
with Ada.Streams.Stream_IO;
with Ada.Text_IO;
with Ada.Text_IO.Text_Streams;

procedure WordFreq is

    use Ada.Streams;

    Buffer : Stream_Element_Array (1 .. 4096);
    Input_Stream : Ada.Text_IO.Text_Streams.Stream_Access
      := Ada.Text_IO.Text_Streams.Stream (Ada.Text_IO.Current_Input);
    N : Stream_Element_Offset;
    Is_Separator : array (Stream_Element) of Boolean :=
      (Character'Pos ('A') .. Character'Pos ('Z') |
       Character'Pos ('a') .. Character'Pos ('z') => False,
       others => True);

    -- N-ary tree of word counts
    -- used to increment the counts in one pass of the input file
    -- branches on the letter
    -- carries the count
    -- very fast
    -- but very space consuming

    subtype Letter is Stream_Element range
       Character'Pos ('a') .. Character'Pos ('z');
    type Word is array (Positive range <>) of Letter;
    type Tree;
    type Tree_Ptr is access Tree;
    type Node is
       record
          Count : Natural := 0;
          Subtree : Tree_Ptr := null;
       end record;
    type Tree is array (Letter) of Node;

    procedure Inc (X : in out Integer) is begin X := X + 1; end;
    procedure Dec (X : in out Integer) is begin X := X - 1; end;
    pragma Inline (Inc, Dec);

    procedure Inc_Word (Parent : Tree_Ptr; Descendents : Word) is
    begin
       if Descendents'Length > 0 then
          declare
             Child_Index : Positive := Descendents'First;
             Child : Letter renames Descendents (Child_Index);
          begin
             if Descendents'Length = 1 then
                Inc (Parent (Child).Count);
             else
                if Parent (Child).Subtree = null then
                   Parent (Child).Subtree := new Tree;
                end if;
                Inc_Word
                  (Parent (Child).Subtree,
                   Descendents (Child_Index + 1 .. Descendents'Last));
             end if;
          end;
       end if;
    end;

    -- Binary tree of word counts
    -- used for sorting the result by the count (frequency)
    -- branches on the word count
    -- carries the word form

    type Form_Ptr is access Word;
    type Binary_Tree;
    type Binary_Tree_Ptr is access Binary_Tree;
    type Binary_Tree is
       record
          Form : Form_Ptr;
          Count : Natural;
          Left, Right : Binary_Tree_Ptr;
       end record;

    procedure Add_Node (Parent : in out Binary_Tree_Ptr; 
                        Form : Form_Ptr; Count : Natural) is
    begin
       if Parent = null then
          Parent := new Binary_Tree;
          Parent.Form := Form;
          Parent.Count := Count;
       else
          if Count < Parent.Count then
             Add_Node (Parent.Left, Form, Count);
          else
             Add_Node (Parent.Right, Form, Count);
          end if;
       end if;
    end;

    -- end of binary tree primitives

    Root : Tree_Ptr := new Tree;
    Btree : Binary_Tree_Ptr := null;
    Current_Word : Word (1 .. 1000);
    Current_Word_Length : Natural range 0 .. Current_Word'Last := 0;
    In_Word : Boolean := False;

    procedure Append_To_Word (E : Letter) is
    begin
       Inc (Current_Word_Length);
       Current_Word (Current_Word_Length) := E;
       In_Word := True;
    end;

    procedure End_Word is
    begin
       if Current_Word_Length > 0 then
          Inc_Word (Root, Current_Word (1 .. Current_Word_Length));
       end if;
       Current_Word_Length := 0;
       In_Word := False;
    end;

    To_Lower : array (Stream_Element) of Letter;

    procedure Initialise_To_Lower_Map is
       D : Integer := Character'Pos ('a') - Character'Pos ('A');
    begin
       for I in Character'Pos ('a') .. Character'Pos ('z') loop
          To_Lower (Stream_Element (I)) := Letter (I);
          To_Lower (Stream_Element (I - D)) := Letter (I);
       end loop;
    end;

    procedure Process (S : Stream_Element_Array) is
    begin
       for I in S'Range loop
          if Is_Separator (S (I)) then
             if In_Word then End_Word; end if;
          else
             Append_To_Word (To_Lower (S (I)));
          end if;
       end loop;
    end;

    pragma Inline (Append_To_Word, End_Word, Process);

    procedure Populate_Btree (Ntree : Tree_Ptr) is
    begin
       Inc (Current_Word_Length);
       for I in Letter'Range loop
          Current_Word (Current_Word_Length) := I;
          if Ntree (I).Count > 0 then
             Add_Node
                (Btree,
                 Form => new Word'(Current_Word (1 .. Current_Word_Length)),
                 Count => Ntree (I).Count);
          end if;
          if Ntree (I).Subtree /= null then
             Populate_Btree (Ntree (I).Subtree);
          end if;
       end loop;
       Dec (Current_Word_Length);
    end;

    procedure Populate_Btree is
    begin
       Current_Word_Length := 0;
       Populate_Btree (Root);
    end;

    function To_String (X : Form_Ptr) return String is
       S : String (X'Range);
    begin
       for I in X'Range loop
          S (I) := Character'Val (X (I));
       end loop;
       return S;
    end;

    subtype String7 is String (1 .. 7);

    function Img7 (X : Natural) return String7 is
       S : String := Natural'Image (X);
    begin
       return String' (1 .. 8 - S'Length => ' ') & S (2 .. S'Last);
    end;

    pragma Inline (To_String, Img7);

    procedure Dump_Btree (X : Binary_Tree_Ptr := Btree) is
    begin
       if X /= null then
          Dump_Btree (X.Right);
          Ada.Text_IO.Put_Line
            (Img7 (X.Count) & " " & To_String (X.Form));
          Dump_Btree (X.Left);
       end if;
    end;

begin
    Initialise_To_Lower_Map;
    loop
       Read (Root_Stream_Type'Class (Input_Stream.all), Buffer, N);
       Process (Buffer (1 .. N));
       exit when N < Buffer'Length;
    end loop;
    if In_Word then End_Word; end if;
    Populate_Btree;
    Dump_Btree;
end;

