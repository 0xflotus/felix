
@head(1,"Name Binding")
Name binding pass 2.

@h = tangler("src/flx_mbind.mli")
@select(h)
open Flx_types
val gen_match_check:
  pattern_t ->
  expr_t ->
  expr_t
  
val get_pattern_vars:
  (string, range_srcref * extract_t list) Hashtbl.t ->     
                              (* Hashtable of variable -> extractor *)
  pattern_t ->      (* pattern *)
  extract_t list -> (* extractor for this pattern *)
  unit

val gen_extractor:
  extract_t list ->
  expr_t ->
  expr_t

@h = tangler("src/flx_mbind.ml")
@select(h)
open Flx_util
open Flx_types
open Flx_print
open Flx_mtypes
open Flx_typing
open Flx_bind
open Flx_overload
open Flx_lookup
open Flx_ebind
open Flx_srcref

(* the extractor is a function to be applied to
   the argument to extract the value of the identifier;
   it is represented here as a list of functions
   to be applied, with the function at the top
   of the list to be applied last.

   Note that the difference between an abstract 
   extractor and a concrete one is that the
   abstract one isn't applied to anything,
   while the concrete one is applied to a specific
   expression.
*)

let gen_extractor 
  (extractor : extract_t list) 
  (mv : expr_t) 
: expr_t =
  List.fold_right
  (fun x marg -> match x with
    | Proj_n (sr,n) -> AST_get_n (sr,(n,marg))
    | Udtor (sr,qn) -> AST_ctor_arg (sr,(qn,marg))
  )
  extractor
  mv

let rec subst vars e mv = 
  let subst e = subst vars e mv in
  match e with
  | AST_deref (sr,e') -> AST_deref (sr,subst e')
  | AST_name (sr,([name],TYP_none)) ->
    if Hashtbl.mem vars name 
    then 
      let sr,extractor = Hashtbl.find vars name in
      gen_extractor extractor mv
    else e
    
  | AST_name _ -> e
  | AST_ref (sr,e') -> AST_ref (sr,subst e')
  | AST_literal _ -> e
  | AST_apply (sr,(f,e)) -> AST_apply (sr,(subst f,subst e))
  | AST_tuple (sr,es) -> AST_tuple (sr,List.map subst es)


  (* Only one of these should occur, but I can't
     figure out which one at the moment
  *)
  | AST_method_apply (sr,(id,e)) -> 
    AST_method_apply (sr,(id, subst e))
  | AST_dot (sr,(e,id)) -> 
    AST_dot (sr,(subst e, id))
 
  | AST_lambda _ ->
    failwith "Lambda in 'when' expression not implemented!"
  | AST_match_ctor _ ->
    failwith "AST_match_ctor in 'when' expression not implemented"
  | AST_ctor_arg _ ->
    failwith "AST_ctor_arg in 'when' expression not implemented"
  | AST_get_n _ ->
    failwith "AST_get_n in 'when' expression not implemented"

(* This routine runs through a pattern looking for
  pattern variables, and adds a record to a hashtable
  keyed by each variable name. The data recorded
  is the list of extractors which must be applied
  to 'deconstruct' the data type to get the part
  which the variable denotes in the pattern

  for example, for the pattern

    | Ctor (1,(x,_))

  the extractor for x is

    [Udtor "Ctor"; Proj_n 2; Proj_n 1]

  since x is the first component of the second
  component of the argument of the constructor "Ctor"
*)
  
let rec get_pattern_vars 
  vars      (* Hashtable of variable -> range_srcref * extractor *)
  pat       (* pattern *)
  extractor (* extractor for this pattern *)
= 
  match pat with
  | PAT_name (sr,id) -> Hashtbl.add vars id (sr,extractor)
  
  | PAT_tuple (sr,pats) ->
    let n = ref 0 in
    List.iter
    (fun pat -> 
      let sr = src_of_pattern pat in
      let extractor' = (Proj_n (sr,!n)) :: extractor in
      incr n; 
      get_pattern_vars vars pat extractor'
    )
    pats

  | PAT_regexp _ -> 
    failwith "[get_pattern_vars] Can't handle regexp yet" 

  | PAT_nonconst_ctor (sr,name,pat) ->
    let extractor' = (Udtor (sr, name)) :: extractor in
    get_pattern_vars vars pat extractor'
    
  | PAT_as (sr,pat,id) -> 
    Hashtbl.add vars id (sr,extractor);
    get_pattern_vars vars pat extractor
 
  | PAT_when (sr,pat,expr) ->
    get_pattern_vars vars pat extractor

  | _ -> ()

let rec gen_match_check pat (arg:expr_t) =
  let lint sr i = AST_literal (sr,AST_int ("int",i)) 
  and lstr sr s = AST_literal (sr,AST_string s) 
  and lfloat sr x = AST_literal (sr,AST_float x)
  and apl2 sr f x1 x2 = 
    AST_apply 
    (
      sr,
      (AST_name (sr,([f],TYP_none)),AST_tuple (sr,[x1;x2]))
    )
  and truth sr = AST_name (sr,(["true"],TYP_none))
  in 
  match pat with
  | PAT_int (sr,i) -> apl2 sr "eq" (lint sr i) arg
  | PAT_string (sr,s) -> apl2 sr "eq" (lstr sr s) arg

  (* ranges *)
  | PAT_int_range (sr,i1,i2) -> 
    let b1 = apl2 sr "le" (lint sr i1) arg
    and b2 = apl2 sr "le" arg (lint sr i2)
    in apl2 sr "land" b1 b2

  | PAT_string_range (sr,s1,s2) ->
    let b1 = apl2 sr "le" (lstr sr s1) arg
    and b2 = apl2 sr "le" arg (lstr sr s2)
    in apl2 sr "land" b1 b2

  | PAT_float_range (sr,x1,x2) ->
    let b1 = apl2 sr "le" (lfloat sr x1) arg
    and b2 = apl2 sr "le" arg (lfloat sr x2)
    in apl2 sr "land" b1 b2


  (* other *)
  | PAT_name (sr,_) -> truth sr
  | PAT_tuple (sr,pats) ->
    let counter = ref 1 in
    List.fold_left 
    (fun init pat ->
      let sr = src_of_pattern pat in
      let n = !counter in
      incr counter;
      apl2 sr "land" init 
        (
          gen_match_check pat (AST_get_n (sr,(n, arg)))
        )
    )
    (
      let pat = List.hd pats in 
      let sr = src_of_pattern pat in
      gen_match_check pat (AST_get_n (sr,(0, arg)))
    )
    (List.tl pats)

  | PAT_any sr -> truth sr
  | PAT_regexp _ -> 
    failwith "[gen_match_check] Can't handle regexp yet" 
  | PAT_const_ctor (sr,name) ->
    AST_match_ctor (sr,(name,arg))
    
  | PAT_nonconst_ctor (sr,name,pat) ->
    let check_component = AST_match_ctor (sr,(name,arg)) in
    let tuple = AST_ctor_arg (sr,(name,arg)) in
    let check_tuple = gen_match_check pat tuple in
    apl2 sr "land" check_component check_tuple
    
  | PAT_as (sr,pat,_) -> gen_match_check pat arg

  | PAT_when (sr,pat,expr) ->
   let vars =  Hashtbl.create 97 in
   get_pattern_vars vars pat [];
   apl2 sr "land" (gen_match_check pat arg) (subst vars expr arg)
   

