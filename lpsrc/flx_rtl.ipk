@head(1,"Run time driver support library")
This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h = tangler("rtl/flx_rtl.hpp")
@select(h)
#ifndef FLX_RTL
#define FLX_RTL
#ifndef FLX_GC
#include "flx_gc.hpp"
#endif
#include <string>

@if HAVE_CGOTO:
  tangle("#define FLX_HAVE_CGOTO")
@if HAVE_ASM_LABELS:
  tangle("#define FLX_HAVE_ASM_LABELS")
//
#if defined(FLX_HAVE_CGOTO) && defined(FLX_HAVE_ASM_LABELS)
#define FLX_CGOTO
#endif

// for declarations in header file 
#define FLX_FMEM_DECL \
  thread_frame_t *ptf;

#define FLX_FPAR_DECL \
    thread_frame_t *_ptf


namespace flx { namespace rtl {

// CONTINUATION
struct con_t // abstract base for mutable continuations
{
#ifdef FLX_CGOTO
  void *pc;
#else
   int pc;
#endif

  enum action_t        // what the dispatch should do
  {                    // when the resume callback returns
    yield_action,      // cooperative yield (resume after housekeeping)
    wait_action        // resume with new message
  } action;

  void *p_message;   // where the next message is put

  con_t();
  virtual con_t *resume()=0;
  // virtual con_t *clone()const=0; 
  virtual ~con_t();
  con_t * _caller;
};

//REFERENCE
struct _ref_
{
  void *frame;
  void *data;

  _ref_(){}
  _ref_(void *f, void *d): frame(f), data(d) {}
  ~_ref_()
  { 
    frame=0; 
  }

  _ref_(_ref_ const& r) : frame(r.frame), data(r.data) 
  {
  }
  void operator = (_ref_ const& r);
};

extern flx::gc::generic::gc_shape_t _ref_ptr_map;

//VARIANTS
struct _uctor_
{
  int variant;
  void *data;
  _uctor_() : variant(-1), data(0) {}
  _uctor_(int i, void *d) : variant(i), data(d) {}
};

extern flx::gc::generic::gc_shape_t _uctor_ptr_map;

// UNIT
struct unit {};

// EXEC protocol failure
// Thrown when trying to run a dead procedure
struct flx_exec_failure_t {
  std::string filename;
  std::string operation;
  std::string what;
  flx_exec_failure_t(std::string f, std::string o, std::string w);
};


}} // namespaces

// for generated code in body file
#define INIT_PC pc=0;

#ifdef FLX_CGOTO
  #define FLX_START_SWITCH if(pc)goto *pc;
  #define FLX_SET_PC(x) pc=&&case_##x;
  #define FLX_CASE_LABEL(x) case_##x:;
  #define FLX_DECLARE_LABEL(n,i,x) \
    extern void f##i##_##n##_##x(void) __asm__("l"#i"_"#n"_"#x);
  #define FLX_LABEL(n,i,x) x:\
    __asm__(".global l"#i"_"#n"_"#x);\
    __asm__("l"#i"_"#n"_"#x":");\
    __asm__(""::"g"(&&x));
  #define FLX_FARTARGET(n,i,x) (void*)&f##i##_##n##_##x
  #define FLX_END_SWITCH
#else
  #define FLX_START_SWITCH switch(pc){case 0:;
  #define FLX_SET_PC(x) pc=x;
  #define FLX_CASE_LABEL(x) case x:;
  #define FLX_DECLARE_LABEL(n,i,x)
  #define FLX_LABEL(n,i,x) case n: x:;
  #define FLX_FARTARGET(n,i,x) n
  #define FLX_END_SWITCH }
#endif

#define FLX_RETURN \
{ \
  con_t *tmp = _caller; \
  _caller = 0; \
  return tmp; \
}
  
#define FLX_FMEM_INIT ptf(_ptf)
#define FLX_FPAR_PASS ptf
#define FLX_NEWP(x) new(gc,x##_ptr_map)x

#define FLX_FINALISER(x) \
static void x##_finaliser(collector_t *, void *p){\
  ((x*)p)->~x();\
}

#define FLX_FRAME_WRAPPERS \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  thread_frame_t *p = new(*gc,thread_frame_t_ptr_map) thread_frame_t(gc);\
  return p;\
}

#define FLX_START_WRAPPER(x)\
extern "C" con_t *flx_start(\
  thread_frame_t *ptf,\
  int argc,\
  char **argv\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  return (new(*ptf->gc,x##_ptr_map) \
    x(ptf)) ->call(0);\
}


#endif

@h = tangler("rtl/flx_rtl.cpp")
@select(h)
#include "flx_rtl.hpp"
#include <cstdio>

namespace flx { namespace rtl {
con_t::con_t() : pc(0), action(yield_action), _caller(0) { 
#ifdef FLX_DEBUG_CONT
 printf("Constructing %p\n",this);
#endif
}
con_t::~con_t(){
#ifdef FLX_DEBUG_CONT
  printf("Destroying %p\n",this);
#endif
}

void _ref_::operator = (_ref_ const& r)
{
  if (data != r.data)
  {
    if (frame != r.frame)
    {
      frame = r.frame;
    }
    data = r.data;
  }
}

//OFFSETS for _ref_
static std::size_t _ref_offsets[1]={
    offsetof(_ref_,frame)
};

static void _ref_finaliser (flx::gc::generic::collector_t *, void *p)
{
  ((_ref_*)p)->~_ref_();
}

flx::gc::generic::gc_shape_t _ref_ptr_map(
  1,sizeof(_ref_),
  _ref_finaliser,
  1,
  _ref_offsets
);

//OFFSETS for _uctor_
static std::size_t _uctor_offsets[1]= { 
  offsetof(_uctor_,data) 
};

flx::gc::generic::gc_shape_t _uctor_ptr_map (
  1,
  sizeof(_uctor_),
  0,
  1,
  _uctor_offsets
);
                                                                                
flx_exec_failure_t::flx_exec_failure_t(std::string f, std::string o, std::string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}


}}

@head(2,"Unix Dynamic linker")
This is a Unix specific module, which uses dlopen
and friends to dynamically attach a shared file
representing a felix top level module to an 
application, and extract the standard 
symbols from it.
@p()
The link routine links the following symbols,
which must be present in all felix libraries.

@begin_displayed_code()
  create_thread_frame
  start
@end_displayed_code()

The unlink routine is called to unlink the library.
@p()
Note that felix never generates variables of static,
storage class, however felix has no control over
used C/C++ code embedded in Felix library modules.
DO NOT use static storage class for variables,
or even constants which require dynamic initialisation.

@h = tangler("rtl/flx_dynlink.hpp")
@select(h)
#ifndef FLX_DYNLINK
#define FLX_DYNLINK
#ifndef FLX_RTL
#include "flx_rtl.hpp"
#include "flx_gc.hpp"
#endif
#include <string>
using namespace std;

#ifndef FLX_STATIC_LINK
#include <dlfcn.h>
#define DLSYM(x,y) dlsym(x,#y)
#else
#define DLSYM(x,y) (void*)&y
#endif
// Utilities to make dynamic linkage and
// initialisation of Felix modules easier
//
// We provide a standard exception to report
// link failure (missing symbol).
//
// We provide a a class flx_dynlink_t which
// opens a Felix shared library given a filename,
// and links the mandatory symbols
// The user may derive from this class to add
// linkage for extra symbols
//
// We provide a class flx_libinit_t which
// initialises and terminates a Felix module
// The user may derive from this class to add
// extra initialisation or termination processing.
//
// [Note: the virtuals are *deliberately* private. 
// Be sure to make your overrides private too,
// so they cannot be called:
// they're dispatched automatically by wrappers
// defined in the base]

// must be at global scope, because the users is
struct thread_frame_t;

namespace flx { namespace rtl {

struct flx_link_failure_t {
  string filename;
  string operation;
  string what;
  flx_link_failure_t(string f, string o, string w);
};

// frame creators
typedef thread_frame_t *(*thread_frame_creator_t)
(
  flx::gc::generic::collector_t*
);

// library initialisation routine
typedef con_t *(*start_t)
(
  thread_frame_t*,
  int,
  char **
);

struct flx_dynlink_t
{
  // data
  void *library;
  thread_frame_creator_t thread_frame_creator;
  start_t start_sym;
  long refcnt;

  // routines
  void link(char const *filename) throw(flx_link_failure_t);
  void unlink();

private:
  // the user should override this procedure to
  // link any extra symbols.
  // on error, throw a flx_link_failure_t,
  // otherwise your exception will be dishonoured
  // and a generic link_failure_t thrown anyhow

  virtual void usr_link();
    // called after mandatory symbols are linked
};

struct flx_libinit_t 
{
  thread_frame_t *thread_frame;
  con_t *start_proc;
  flx_dynlink_t *lib;
  flx::gc::generic::collector_t *collector;
  void create
  (
    flx_dynlink_t *lib_a, 
    flx::gc::generic::collector_t *collector_a,
    int argc,
    char **argv
  );

  void destroy ();

  con_t *bind_proc(void *fn, void *data);
  
private:
  // the user can override these procedures
  // to perform any additional initialisation
  // and termination required.
  
  virtual void usr_create(); 
    // called after standard init completes
    
  virtual void usr_destroy(); 
    // called before standard destroy starts
};

}} // namespaces
#endif

@h = tangler("rtl/flx_dynlink.cpp")
@select(h)
#include "flx_dynlink.hpp"
#ifdef FLX_STATIC_LINK
extern void *create_thread_frame;
extern void *flx_start;
#endif

namespace flx { namespace rtl {

flx_link_failure_t::flx_link_failure_t(string f, string o, string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

void flx_dynlink_t::link(char const *filename) throw(flx_link_failure_t)
{

#ifndef FLX_STATIC_LINK
  library = dlopen(filename,RTLD_NOW);
  if(!library) 
    throw flx_link_failure_t(filename,"dlopen",dlerror());
#endif

  //fprintf(stderr,"File %s dlopened at %p ok\n",filename,library);

  thread_frame_creator = (thread_frame_creator_t)
    DLSYM(library,create_thread_frame);
  if(!thread_frame_creator) 
    throw flx_link_failure_t(filename,"dlsym","create_thread_frame");

  //fprintf(stderr,"Thread frame creator found at %p\n",thread_frame_creator);

  start_sym = (start_t)DLSYM(library,flx_start);
  if(!start_sym) 
    throw flx_link_failure_t(filename,"dlsym","flx_start");

  //fprintf(stderr,"Start symbol found at %p\n",start_sym);
  
  refcnt = 1L;

  //fprintf(stderr,"Set refcnt to 1\n");
  try { usr_link(); }
  catch (flx_link_failure_t &) { throw; }
  catch (...) { 
    throw flx_link_failure_t
    (
      filename,
      "usr_link()",
      "Unknown user exception"
    );
  }
}

void flx_dynlink_t::unlink()
{
  --refcnt;
  if(refcnt == 0) {
    //fprintf(stderr,"closing library\n");
#ifndef FLX_STATIC_LINK
    //dlclose(library);
#endif
  }
}

void flx_dynlink_t::usr_link(){}

void flx_libinit_t::create
(
  flx_dynlink_t *lib_a, 
  flx::gc::generic::collector_t *collector_a,
  int argc,
  char **argv
)
{
  lib = lib_a;
  collector = collector_a;
  thread_frame = lib->thread_frame_creator(
    collector 
  );
  //fprintf(stderr,"Incrementing refcnt\n");
  ++lib->refcnt;
  collector->add_root(thread_frame);
  start_proc = lib->start_sym(thread_frame, argc, argv);
  usr_create();
}

void flx_libinit_t::usr_create(){}

void flx_libinit_t::destroy () {
  usr_destroy();
  collector->remove_root(thread_frame);
  //fprintf(stderr,"Decrementing refcnt\n");
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
  --lib->refcnt;
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
}

void flx_libinit_t::usr_destroy (){}

con_t *flx_libinit_t::bind_proc(void *fn, void *data) {
  typedef con_t *(*binder_t)(void *,void*);
  return ((binder_t)fn)(thread_frame,data);
}

}} // namespaces


@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.
@p()
For statically linked programs,
command line arguments are passed directly,
the debugging switch isn't supported.
@p()
For dynamically loaded programs, the name of the
driver and optional --debug switch given before the
shared library name are not passed.

@h = tangler('rtl/flx_run.cpp')
@select(h)
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <cstring>
#include <cassert>

#include <string>
#include <unistd.h>
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"
@if HAVE_GXX:
  tangle('#define HAVE_GXX')

@if HAVE_GXX_X86:
  tangle('#define HAVE_GXX_X86')

using namespace std;
using namespace flx::rtl;
#ifdef HAVE_GXX_X86
register void *sp __asm__("esp");
#else
static void *sp = 0;
#endif

int main(int argc, char** argv)
{
#ifndef FLX_STATIC_LINK  
  if (argc<2) 
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    return 1;
  }
  char *filename = argv[1];
  char **flx_argv = argv+1;
  int flx_argc = argc-1;
  bool debug = (argc > 1) && (strcmp(argv[1],"--debug")==0);
  if(debug)
  {
    if(argc<3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    filename = argv[2];
    --flx_argc;
    ++flx_argv;
  }
#else
  char *filename = argv[0];
  char **flx_argv = argv;
  int flx_argc = argc;
  bool debug = false;
//  printf("Statically linked Felix program running\n");
#endif
#ifdef HAVE_GXX
    static void *init_sp = sp;
    static void *init_fframe = __builtin_frame_address(0);
    static void *init_ret = __builtin_return_address(0);
#endif
  if(debug)
    for(int i=0; i<flx_argc; ++i) 
    fprintf(stderr,"flx_argv[%d]->%s\n",i,flx_argv[i]);
  try 
  {
    if(debug)fprintf(stderr,"flx_run driver begins %s\n",flx_argv[0]);
    flx_dynlink_t library;
    flx_libinit_t instance;

    library.link(filename);
    flx::gc::collector::malloc_free allocator;
    flx::gc::collector::flx_collector_t collector(&allocator);
    instance.create(&library, &collector,flx_argc,flx_argv);
 
    int gc_counter = 0;
    con_t *top = instance.start_proc;
    collector.add_root(top);
    con_t *old_root = top;

    while( top && top->action == con_t::yield_action)
    {
      top = top->resume();
      gc_counter++;
      if(gc_counter == 1000)
      {
        gc_counter = 0;
        // reset the root to the current top
        if(old_root != top) {
          if(top) collector.add_root(top);
          if(old_root) collector.remove_root(old_root);
          old_root = top;
        }
        unsigned long n = collector.collect();
        if(debug)printf("collected %ld\n",n);
      }
    }
    if(old_root) collector.remove_root(old_root);
    {
      unsigned long n = collector.collect();
      unsigned long a = collector.get_allocation_count();
      //if(a!=0)
      //  fprintf(stderr,"flx_run %ld uncollected objects!\n",a);
    }
    //fprintf(stderr,"Destroying instance ..\n");
    instance.destroy();
    //fprintf(stderr,"Collecting ..\n");
    unsigned long n = collector.collect();
    unsigned long a = collector.get_allocation_count();
    //fprintf(stderr,"Collecting done ..\n");
    if(a!=0){
      fprintf(stderr,"flx_run %ld uncollected objects!\n",a);
      return 5;
    }
    //fprintf(stderr,"Libref cnt = %ld\n",library.refcnt);
    //if(library.refcnt >0)
    //{
    //  fprintf(stderr,"flx_run %p library still referenced %ld times (expected 1)\n",library.library,library.refcnt);
    //}
    //fprintf(stderr,"Unlinking library ..\n");
    library.unlink();
    if(library.refcnt >0)
    {
      fprintf(stderr,"flx_run %p library still referenced %ld times?!\n",library.library,library.refcnt);
      return 6;
    }
    if(debug)fprintf(stderr,"flx_run driver ends normally, collected %ld,left=%ld\n",n,a);
  }
  catch (flx_link_failure_t x)
  {
    fprintf(stderr,"Dynamic linkage error\n");
    fprintf(stderr,"filename: %s\n",x.filename.data());
    fprintf(stderr,"operation: %s\n",x.operation.data());
    fprintf(stderr,"what: %s\n",x.what.data());
    return 2;
  }
  catch (flx_exec_failure_t x)
  {
    fprintf(stderr,"Execution error\n");
    fprintf(stderr,"filename: %s\n",x.filename.data());
    fprintf(stderr,"operation: %s\n",x.operation.data());
    fprintf(stderr,"what: %s\n",x.what.data());
    return 3;
  }
  catch (...)
  {
    fprintf(stderr,"flx_run driver ends with unknown EXCEPTION\n");
    return 4;
  }
#ifdef HAVE_GXX
    // check the frame pointer isn't corrupted
    static void *fin_sp = sp;
    static void *fin_fframe = __builtin_frame_address(0);
    static void *fin_ret = __builtin_return_address(0);
    if (init_sp != fin_sp ) {
      fprintf(stderr,"g++: STACK POINTER ERROR %p != %p\n",init_sp,fin_sp);
    }
    if (init_fframe != fin_fframe) {
      fprintf(stderr,"g++: FRAME POINTER ERROR %p != %p\n",init_fframe,fin_fframe);
    }
    else if (init_ret != fin_ret) {
      fprintf(stderr,"g++: RETURN ADDRESS ERROR %p != %p\n",init_ret,fin_ret);
    }
#endif
  if(debug)fprintf(stderr,"flx_run driver ends OK\n");
  return 0;
}


