@head(1,"Run time driver support library")
This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h = tangler("rtl/flx_rtl.hpp")
@select(h)
#ifndef FLX_RTL
#define FLX_RTL
#ifndef FLX_GC
#include <rtl/flx_gc.hpp>
#endif
#include <string>

//enable or disable refcounting: off by default
#ifdef FLX_REFCNT
#define incref(x) flx::gc::generic::incref(x)
#define _incref(x) flx::gc::generic::_incref(x)
#define decref(x) flx::gc::generic::decref(x)
#define _release_ptr(x) flx::gc::generic::_release_ptr(x)
#else
#define incref(x) x
#define _incref(x) x
#define decref(x) x
#define _release_ptr(x) *x = 0
#endif

namespace flx { namespace rtl {

// CONTINUATION
struct con_t // abstract base for mutable continuations
{
  int pc;              // program counter
  enum action_t        // what the dispatch should do
  {                    // when the resume callback returns
    yield_action,      // cooperative yield (resume after housekeeping)
    wait_action        // resume with new message
  } action;

  void *p_message;   // where the next message is put

  con_t();
  virtual con_t *resume()=0;
  virtual con_t *clone()const=0;
  virtual ~con_t();
  con_t * _caller;
};

//REFERENCE
struct _ref_
{
  void *frame;
  void *data;

  _ref_(){}
  _ref_(void *f, void *d): frame(f), data(d) {}
  ~_ref_()
  { 
    //printf("destroy ref decref %p\n", frame);
    _release_ptr(&frame); 
  }

  _ref_(_ref_ const& r) : frame(r.frame), data(r.data) 
  {
    //printf("copy ref incref %p\n", frame);
    _incref(frame);
  }
  void operator = (_ref_ const& r);
};

extern flx::gc::generic::gc_shape_t _ref_ptr_map;

//VARIANTS
struct _uctor_
{
  int variant;
  void *data;
  _uctor_() : variant(-1), data(0) {}
  _uctor_(int i, void *d) : variant(i), data(d) {}
};

// UNIT
struct unit {};

// EXEC protocol failure
// Thrown when trying to run a dead procedure
struct flx_exec_failure_t {
  std::string filename;
  std::string operation;
  std::string what;
  flx_exec_failure_t(std::string f, std::string o, std::string w);
};


}} // namespaces
#endif

@h = tangler("rtl/flx_rtl.cpp")
@select(h)
#include "flx_rtl.hpp"
#include <cstdio>

namespace flx { namespace rtl {
con_t::con_t() : pc(0), action(yield_action), _caller(0) { 
#ifdef FLX_DEBUG_CONT
 printf("Constructing %p\n",this);
#endif
}
con_t::~con_t(){
#ifdef FLX_DEBUG_CONT
  printf("Destroying %p\n",this);
#endif
}

void _ref_::operator = (_ref_ const& r)
{
  if (data != r.data)
  {
    if (frame != r.frame)
    {
      //printf("assign [old frame] ref decref %p\n", frame);
      decref(frame);
      frame = r.frame;
      //printf("assign [new frame] ref incref %p\n", frame);
      _incref(frame);
    }
    data = r.data;
  }
}

//OFFSETS for _ref_
static size_t _ref_offsets[1]={
    offsetof(_ref_,frame)
};

static void _ref_finaliser (flx::gc::generic::collector_t *, void *p)
{
  ((_ref_*)p)->~_ref_();
}

flx::gc::generic::gc_shape_t _ref_ptr_map(
  1,sizeof(_ref_),
  _ref_finaliser,
  1,
  _ref_offsets
);

flx_exec_failure_t::flx_exec_failure_t(std::string f, std::string o, std::string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}


}}

@head(2,"Unix Dynamic linker")
This is a Unix specific module, which uses dlopen
and friends to dynamically attach a shared file
representing a felix top level module to an 
application, and extract the standard 
symbols from it.
@p()
The link routine links the following symbols,
which must be present in all felix libraries.

@begin_displayed_code()
  create_global_frame
  create_process_frame
  create_thread_frame
  start
  destroy_thread_frame
  destroy_process_frame
  destroy_global_frame
@end_displayed_code()

The unlink routine is called to unlink the library.
@p()
Note that felix never generates variables of static,
storage class, however felix has no control over
used C/C++ code embedded in Felix library modules.
DO NOT use static storage class for variables,
or even constants which require dynamic initialisation.

@h = tangler("rtl/flx_dynlink.hpp")
@select(h)
#ifndef FLX_DYNLINK
#define FLX_DYNLINK
#ifndef FLX_RTL
#include "flx_rtl.hpp"
#include "flx_gc.hpp"
#endif
#include <string>
using namespace std;

// Utilities to make dynamic linkage and
// initialisation of Felix modules easier
//
// We provide a standard exception to report
// link failure (missing symbol).
//
// We provide a a class flx_dynlink_t which
// opens a Felix shared library given a filename,
// and links the mandatory symbols
// The user may derive from this class to add
// linkage for extra symbols
//
// We provide a class flx_libinit_t which
// initialises and terminates a Felix module
// The user may derive from this class to add
// extra initialisation or termination processing.
//
// [Note: the virtuals are *deliberately* private. 
// Be sure to make your overrides private too,
// so they cannot be called:
// they're dispatched automatically by wrappers
// defined in the base]

namespace flx { namespace rtl {

struct flx_link_failure_t {
  string filename;
  string operation;
  string what;
  flx_link_failure_t(string f, string o, string w);
};

// frame types are incomplete
typedef void global_frame_t;
typedef void process_frame_t;
typedef void thread_frame_t;

// frame creators
typedef global_frame_t *(*global_frame_creator_t)(void);
typedef process_frame_t *(*process_frame_creator_t)(global_frame_t*);
typedef thread_frame_t *(*thread_frame_creator_t)
(
  global_frame_t*,
  process_frame_t*, 
  flx::gc::generic::collector_t*
);

// frame destructors
typedef void (*global_frame_destructor_t)(global_frame_t*);
typedef void (*process_frame_destructor_t)(process_frame_t*);
typedef thread_frame_t *(*thread_frame_destructor_t) (thread_frame_t*);


// library initialisation routine
typedef con_t *(*start_t)
(
  global_frame_t*, 
  process_frame_t*, 
  thread_frame_t*
);

struct flx_dynlink_t
{
  // data
  void *library;
  global_frame_creator_t global_frame_creator;
  process_frame_creator_t process_frame_creator;
  thread_frame_creator_t thread_frame_creator;
  global_frame_destructor_t global_frame_destructor;
  process_frame_destructor_t process_frame_destructor;
  thread_frame_destructor_t thread_frame_destructor;
  start_t start;

  // routines
  void link(char const *filename) throw(flx_link_failure_t);
  void unlink();

private:
  // the user should override this procedure to
  // link any extra symbols.
  // on error, throw a flx_link_failure_t,
  // otherwise your exception will be dishonoured
  // and a generic link_failure_t thrown anyhow

  virtual void usr_link();
    // called after mandatory symbols are linked
};

struct flx_libinit_t 
{
  global_frame_t *global_frame;
  process_frame_t *process_frame;
  thread_frame_t *thread_frame;
  con_t *start;
  flx_dynlink_t *lib;

  void create
  (
    flx_dynlink_t *lib_a, 
    flx::gc::generic::collector_t *collector
  );

  void destroy ();

private:
  // the user can override these procedures
  // to perform any additional initialisation
  // and termination required.
  
  virtual void usr_create(); 
    // called after standard init completes
    
  virtual void usr_destroy(); 
    // called before standard destroy starts
};

}} // namespaces
#endif

@h = tangler("rtl/flx_dynlink.cpp")
@select(h)
#include "flx_dynlink.hpp"
#ifndef FLX_STATIC_LINK
#include <dlfcn.h>
#define dlsym(x,y) dlsym(x,#y)
#else
#define dlsym(x,y) (void*)&y
extern void *create_global_frame;
extern void *create_process_frame;
extern void *create_thread_frame;
extern void *destroy_global_frame;
extern void *destroy_process_frame;
extern void *destroy_thread_frame;
extern void *start;
#endif

namespace flx { namespace rtl {

flx_link_failure_t::flx_link_failure_t(string f, string o, string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

void flx_dynlink_t::link(char const *filename) throw(flx_link_failure_t)
{

#ifndef FLX_STATIC_LINK
  library = dlopen(filename,RTLD_NOW);
  if(!library) throw flx_link_failure_t(filename,"dlopen",dlerror());
#endif

  global_frame_creator = (global_frame_creator_t)
    dlsym(library,create_global_frame);
  if(!global_frame_creator) 
    throw(filename,"dlsym","create_global_frame");

  process_frame_creator = (process_frame_creator_t)
    dlsym(library,create_process_frame);
  if(!process_frame_creator)
    throw flx_link_failure_t(filename,"dlsym","create_process_frame");

  thread_frame_creator = (thread_frame_creator_t)
    dlsym(library,create_thread_frame);
  if(!thread_frame_creator) 
    throw flx_link_failure_t(filename,"dlsym","create_thread_frame");

  global_frame_destructor = (global_frame_destructor_t)
    dlsym(library,destroy_global_frame);
  if(!global_frame_destructor) 
    throw flx_link_failure_t(filename,"dlsym","destroy_global_frame");

  process_frame_destructor = (process_frame_destructor_t)
    dlsym(library,destroy_process_frame);
  if(!process_frame_destructor) 
    throw flx_link_failure_t(filename,"dlsym","destroy_process_frame");

  thread_frame_destructor = (thread_frame_destructor_t)
    dlsym(library,destroy_thread_frame);
  if(!thread_frame_destructor) 
    throw flx_link_failure_t(filename,"dlsym","destroy_thread_frame");

  start = (start_t)
#ifndef FLX_STATIC_LINK
    dlsym(library,start);
#else
  (void*)&::start;
#endif
  if(!start) 
    throw flx_link_failure_t(filename,"dlsym","start");

  try { usr_link(); }
  catch (flx_link_failure_t &) { throw; }
  catch (...) { 
    throw flx_link_failure_t
    (
      filename,
      "usr_link()",
      "Unknown user exception"
    );
  }
}

void flx_dynlink_t::unlink()
{
#ifndef FLX_STATIC_LINK
  dlclose(library);
#endif
}
  
void flx_dynlink_t::usr_link(){}

void flx_libinit_t::create
(
  flx_dynlink_t *lib_a, 
  flx::gc::generic::collector_t *collector
)
{
  lib = lib_a;
#ifdef FLX_STATIC_LINK
//  printf("Building frames now ..\n");
//  printf("Global frame creator is %p\n",lib->global_frame_creator);
#endif
  global_frame = lib->global_frame_creator();
#ifdef FLX_STATIC_LINK
//  printf("Built global frame %p\n",global_frame);
#endif
  process_frame = lib->process_frame_creator(global_frame);
  thread_frame = lib->thread_frame_creator(
    global_frame, 
    process_frame, 
    collector 
  );
#ifdef FLX_STATIC_LINK
//  printf("Built frames, creating init continuation ..\n");
#endif
  start = lib->start(global_frame, process_frame, thread_frame);
#ifdef FLX_STATIC_LINK
//  printf("Init continuation created %p\n",start);
#endif
  usr_create();
}

void flx_libinit_t::usr_create(){}

void flx_libinit_t::destroy () {
  usr_destroy();
  lib->thread_frame_destructor(thread_frame);
  lib->process_frame_destructor(process_frame);
  lib->global_frame_destructor(global_frame);
}

void flx_libinit_t::usr_destroy (){}


}} // namespaces


@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.

@h = tangler('rtl/flx_run.cpp')
@select(h)
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <cstring>
#include <cassert>

#include <string>
#include <unistd.h>
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"

using namespace std;
using namespace flx::rtl;

int main(int argc, char* argv[])
{
#ifndef FLX_STATIC_LINK  
  if (argc<2) 
  {
    printf("usage: flx_run <shared library (may need ./ prefix)>\n");
    return 1;
  }
  char *filename = argv[1];
  char **flx_argv = argv+1;
  int flx_argc = argc-1;
#else
  char *filename = "static";
  char **flx_argv = argv;
  int flx_argc = argc;
//  printf("Statically linked Felix program running\n");
#endif
  try 
  {
    //printf("flx_run driver begins\n");
    flx_dynlink_t library;
    flx_libinit_t instance;

    library.link(filename);
#ifdef FLX_STATIC_LINK
//    printf("Linked %s\n",filename);
#endif
    flx::gc::collector::malloc_free allocator;
    flx::gc::collector::flx_collector_t collector(&allocator);
    instance.create(&library, &collector);
#ifdef FLX_STATIC_LINK
//    printf("Created instance %s\n",filename);
#endif
 
    int gc_counter = 0;
    con_t *top = instance.start;
    collector.add_root(top);
    con_t *old_root = top;

    while( top && top->action == con_t::yield_action)
    {
      top = top->resume();
      gc_counter++;
      if(gc_counter == 100)
      {
        gc_counter = 0;
        // reset the root to the current top
        if(old_root != top) {
          if(top) collector.add_root(top);
          if(old_root) collector.remove_root(old_root);
          old_root = top;
        }
        collector.collect();
      }
    }

    instance.destroy();
    collector.collect();
    //printf("flx_run driver ends normally\n");
    return 0;
  }
  catch (flx_link_failure_t x)
  {
    printf("Dynamic linkage error\n");
    printf("filename: %s\n",x.filename.data());
    printf("operation: %s\n",x.operation.data());
    printf("what: %s\n",x.what.data());
    return 2;
  }
  catch (flx_exec_failure_t x)
  {
    printf("Execution error\n");
    printf("filename: %s\n",x.filename.data());
    printf("operation: %s\n",x.operation.data());
    printf("what: %s\n",x.what.data());
    return 3;
  }
  catch (...)
  {
    printf("flx_run driver ends with unknown EXCEPTION\n");
    return 4;
  }
}


