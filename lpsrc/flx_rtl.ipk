@head(1,"Run time driver support library")
This package contains core types and routines
to facilitate construction of drivers for
felix shared libraries. A felix driver is the top
level interface between the embedding application
and the felix generated shared libraries.
@p()
The code we give is platform independent, except as noted.
@p()
The code all lives in directory rtl, the run time
library support directory. The symbols are defined
in namespace flx::rtl, except as noted.

@h = tangler("rtl/flx_meta.hpp")
@select(h)
#ifndef FLX_META
#define FLX_META
// taken from BOOST
@if HAVE_INCLASS_MEMBER_INITIALIZATION:
  tangle('#define FLX_HAVE_INCLASS_MEMBER_INITIALIZATION')
#ifdef FLX_HAVE_INCLASS_MEMBER_INITIALIZATION
#  define FLX_STATIC_CONSTANT(type, assignment) static const type assignment
#else
#  define FLX_STATIC_CONSTANT(type, assignment) enum { assignment }
#endif

#include <cstddef>

template <std::size_t> struct type_with_alignment;
@for k in flx_aligns.keys():
  t = flx_aligns[k]
  tangle('template <> struct type_with_alignment<'+str(k)+'>{ typedef '+t+' type; };')

template <typename T> struct alignment_of;

template <typename T>
struct alignment_of_hack
{
  char c;
  T t;
  alignment_of_hack();
};

template <unsigned A, unsigned S>
struct alignment_logic
{
  FLX_STATIC_CONSTANT(std::size_t, value = A < S ? A : S);
};

template< typename T >
struct alignment_of
{
  FLX_STATIC_CONSTANT(std::size_t, value =
    (alignment_logic<
      sizeof(alignment_of_hack<T>) - sizeof(T),
      sizeof(T)
    >::value));
};

template<std::size_t L, std::size_t A> 
struct aligned_storage
{
  union type
  {
    unsigned char data_[ L ];
    typename type_with_alignment<A>::type align_;
  };
};

template<typename T>
struct store_of 
{
  typedef typename aligned_storage<sizeof(T), alignment_of<T>::value>::type type;
};

// convert an rvalue to an lvalue
template<typename T> 
T const &lvalue(T const &x) 
{ 
  return x; 
}

// this reinterpret cast works with rvalues too
template<typename T, typename U>
T &reinterpret(U const &x) {
  return reinterpret_cast<T&>(const_cast<U&>(x));
}
#endif

@h = tangler("rtl/flx_rtl_config.hpp")
@select(h)
#ifndef FLX_RTL_CONFIG
#define FLX_RTL_CONFIG
#ifndef FLX_RTL_GNU
@if HAVE_ISNAN_IN_IEEEFP:
  tangle('#define HAVE_ISNAN_IN_IEEEFP')

@if HAVE_GXX:
  tangle('#define HAVE_GXX')

@if HAVE_GXX_X86:
  tangle('#define HAVE_GXX_X86')

@if HAVE_CGOTO:
  tangle("#define FLX_HAVE_CGOTO")

@if USE_REGPARM3:
  tangle("#define FLX_USE_REGPARM3")
  
@if HAVE_ASM_LABELS:
  tangle("#define FLX_HAVE_ASM_LABELS")

@if HAVE_DLOPEN:
  tangle("#define HAVE_DLOPEN")

@if MACOSX:
  tangle("#define MACOSX")

@if HAVE_MSVC:
  tangle("#define HAVE_MSVC")

//
#if defined(FLX_HAVE_CGOTO) && defined(FLX_HAVE_ASM_LABELS)
#define FLX_CGOTO
#endif

//#if  !defined(FLX_STATIC_LINK) && (defined(__CYGWIN__) || defined(_WIN32))
#if  !defined(FLX_STATIC_LINK) && (defined(_WIN32))
#define FLX_EXPORT __declspec(dllexport)
#else
#define FLX_EXPORT
#endif

//#if  !defined(FLX_STATIC_LINK) && (defined(__CYGWIN__) || defined(_WIN32))
#if  !defined(FLX_STATIC_LINK) && (defined(_WIN32))
#if defined(FLX_BUILD_DYNAMIC_RTL)
#define FLX_RTL_EXTERN __declspec(dllexport)
#else
#define FLX_RTL_EXTERN __declspec(dllimport)
#endif
#else
#define FLX_RTL_EXTERN
#endif

#if defined(MACOSX) && !defined(HAVE_DLOPEN)
#define MACOSX_NODLCOMPAT
#endif

#ifdef HAVE_GXX
#define FLX_ALWAYS_INLINE __attribute__ ((always_inline))
#define FLX_NOINLINE __attribute__ ((noinline))
#define FLX_CONST __attribute__ ((const))
#define FLX_PURE __attribute__ ((pure))
#define GXX_PARSER_HACK (void)0,
#define FLX_UNUSED __attribute__((unused))
#else
#define FLX_ALWAYS_INLINE
#define FLX_NOINLINE 
#define FLX_CONST
#define FLX_PURE 
#define GXX_PARSER_HACK
#define FLX_UNUSED
#endif
#endif

@def cal_raw_address():
  if SIZEOF_INT == SIZEOF_VOIDP: return "unsigned"
  if SIZEOF_LONG == SIZEOF_VOIDP: return "unsigned long"
  if SIZEOF_LONGLONG == SIZEOF_VOIDP: return "unsigned long long"
  raise "Cannot find an int the size of a void pointer"

@tangle("#define FLX_RAWADDRESS "+cal_raw_address())

#endif

@head(2,"Procedure Continuation Abstraction")
The heart of the driver/library interface
is the continuation class. Note the message pointer
is an abstract address and must be cast to the
right type by client drivers.

@h = tangler("rtl/flx_rtl.hpp")
@select(h)
#ifndef FLX_RTL
#define FLX_RTL
#include "flx_rtl_config.hpp"
#include "flx_meta.hpp"
#ifndef FLX_GC
#include "flx_gc.hpp"
#endif
#include <string>

#if defined(FLX_PTF_STATIC_STRUCT)
#define PTF ptf.
#elif defined(FLX_PTF_STATIC_POINTER)
#define PTF ptf->
#else
#define PTF ptf->
#endif

// for declarations in header file 
#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t ptf;
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FMEM_DECL
#define FLX_FPAR_DECL_ONLY
#define FLX_FPAR_DECL
#define FLX_APAR_DECL_ONLY
#define FLX_APAR_DECL
#define FLX_DCL_THREAD_FRAME extern thread_frame_t *ptf;
#else
#define FLX_FMEM_DECL thread_frame_t *ptf;
#define FLX_FPAR_DECL_ONLY thread_frame_t *_ptf
#define FLX_FPAR_DECL thread_frame_t *_ptf,
#define FLX_APAR_DECL_ONLY thread_frame_t *ptf
#define FLX_APAR_DECL thread_frame_t *ptf,
#define FLX_DCL_THREAD_FRAME
#endif

namespace flx { namespace rtl {

struct FLX_RTL_EXTERN con_t;
struct FLX_RTL_EXTERN fthread_t;
extern flx::gc::generic::gc_shape_t _fthread_ptr_map;
struct FLX_RTL_EXTERN _ref_;
extern flx::gc::generic::gc_shape_t _ref_ptr_map;
struct FLX_RTL_EXTERN _uctor_;
extern FLX_RTL_EXTERN flx::gc::generic::gc_shape_t _uctor_ptr_map;
extern FLX_RTL_EXTERN flx::gc::generic::gc_shape_t _int_ptr_map;
extern FLX_RTL_EXTERN flx::gc::generic::gc_shape_t unit_ptr_map;
struct FLX_RTL_EXTERN flx_exec_failure_t;

// UNIT
struct FLX_RTL_EXTERN unit {};
struct FLX_RTL_EXTERN flx_exec_failure_t;
struct FLX_RTL_EXTERN flx_range_srcref_t;
struct FLX_RTL_EXTERN flx_match_failure_t;
struct FLX_RTL_EXTERN flx_assert_failure_t;
struct FLX_RTL_EXTERN flx_switch_failure_t;

// SERVICE REQUEST CODE
// THESE VALUES MUST SYNCH WITH THE STANDARD LIBRARY
enum svc_t      // what the dispatch should do
{                        // when the resume callback returns
  svc_yield = 0,
  svc_get_fthread=1,
  svc_read=2,
  svc_general=3,
  svc_end
};

// CONTINUATION
struct FLX_RTL_EXTERN con_t // abstract base for mutable continuations
{
#ifdef FLX_CGOTO
  void *pc;
#else
   int pc;
#endif

  _uctor_ *p_svc;   // pointer to service request

  con_t();
  virtual con_t *resume()=0;
  virtual ~con_t();
  con_t * _caller;
};

struct FLX_RTL_EXTERN fthread_t // fthread abstraction
{
  fthread_t();
  fthread_t(con_t*);
  con_t *cc; // current continuation
  virtual _uctor_ *run();
  _uctor_ *get_svc()const;
  virtual ~fthread_t();
};

//REFERENCE
// note: non-polymorphic, so ctor can be inline
struct FLX_RTL_EXTERN _ref_
{
  void *frame;
  void *data;

  _ref_(){}
  _ref_(void *f, void *d): frame(f), data(d) {}
  ~_ref_()
  { 
    frame=0; 
  }

  _ref_(_ref_ const& r) : frame(r.frame), data(r.data) 
  {
  }
  void operator = (_ref_ const& r);
};


//VARIANTS
// note: non-polymorphic, so ctor can be inline
struct FLX_RTL_EXTERN _uctor_
{
  int variant;
  void *data;
  _uctor_() : variant(-1), data(0) {}
  _uctor_(int i, void *d) : variant(i), data(d) {}
};


// EXEC protocol failure
// Thrown when trying to run a dead procedure
struct FLX_RTL_EXTERN flx_exec_failure_t {
  std::string filename;
  std::string operation;
  std::string what;
  flx_exec_failure_t(std::string f, std::string o, std::string w);
  virtual ~flx_exec_failure_t();
};

struct FLX_RTL_EXTERN flx_range_srcref_t {
  char *filename;
  int startline;
  int startcol;
  int endline;
  int endcol;
  flx_range_srcref_t(char *f,int sl, int sc, int el, int ec);
};

// MATCH failure
// Thrown when no match cases match the argument of a match,
// regmatch, or reglex

struct FLX_RTL_EXTERN flx_match_failure_t {
  flx_range_srcref_t flx_loc;
  char *cxx_srcfile;    // in C++ file
  int cxx_srcline;      // __LINE__ macro
  flx_match_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_match_failure_t();
};

// ASSERT failure
struct FLX_RTL_EXTERN flx_assert_failure_t {
  flx_range_srcref_t flx_loc;
  char *cxx_srcfile;    // in C++ file
  int cxx_srcline;      // __LINE__ macro
  flx_assert_failure_t(flx_range_srcref_t ff, char *cf, int cl);
  virtual ~flx_assert_failure_t();
};

// SWITCH failure -- this is a system failure!
struct FLX_RTL_EXTERN flx_switch_failure_t {
  virtual ~flx_switch_failure_t();
};


}} // namespaces

#define FLX_MATCH_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_match_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

#define FLX_ASSERT_FAILURE(f,sl,sc,el,ec) \
  throw flx::rtl::flx_assert_failure_t (flx_range_srcref_t(f,sl,sc,el,ec),__FILE__,__LINE__)

// for generated code in body file
#define INIT_PC pc=0;

#ifdef FLX_CGOTO
  #define FLX_START_SWITCH if(pc)goto *pc;
  #define FLX_SET_PC(x) pc=&&case_##x;
  #define FLX_CASE_LABEL(x) case_##x:;
  #define FLX_DECLARE_LABEL(n,i,x) \
    extern void f##i##_##n##_##x(void) __asm__("l"#i"_"#n"_"#x);
  #define FLX_LABEL(n,i,x) x:\
    __asm__(".global l"#i"_"#n"_"#x);\
    __asm__("l"#i"_"#n"_"#x":");\
    __asm__(""::"g"(&&x));
  #define FLX_FARTARGET(n,i,x) (void*)&f##i##_##n##_##x
  #define FLX_END_SWITCH
#else
  #define FLX_START_SWITCH switch(pc){case 0:;
  #define FLX_SET_PC(x) pc=x;
  #define FLX_CASE_LABEL(x) case x:;
  #define FLX_DECLARE_LABEL(n,i,x)
  #define FLX_LABEL(n,i,x) case n: x:;
  #define FLX_FARTARGET(n,i,x) n
  #define FLX_END_SWITCH default: throw flx_switch_failure_t(); }
#endif

#define FLX_RETURN \
{ \
  con_t *tmp = _caller; \
  _caller = 0; \
  return tmp; \
}

#define FLX_NEWP(x) new(*PTF gc,x##_ptr_map)x

#define FLX_FINALISER(x) \
static void x##_finaliser(collector_t *, void *p){\
  ((x*)p)->~x();\
}

#if defined(FLX_USE_REGPARM3) && defined(HAVE_GXX_X86)
#define FLX_REGPARM __attribute__((regparm(3)))
#else
#define FLX_REGPARM
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define _PTF _ptf.
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT_PTF(x)
#define FLX_DEF_THREAD_FRAME thread_frame_t ptf;
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FMEM_INIT_ONLY
#define FLX_FMEM_INIT :
#define FLX_FPAR_PASS_ONLY
#define FLX_FPAR_PASS
#define _PTF _ptf->
#define _PTFV
#define FLX_PASS_PTF 0
#define FLX_EAT_PTF(x)
#define FLX_DEF_THREAD_FRAME thread_frame_t *ptf=0;
#else
#define FLX_FMEM_INIT_ONLY : ptf(_ptf)
#define FLX_FMEM_INIT : ptf(_ptf),
#define FLX_FPAR_PASS_ONLY ptf
#define FLX_FPAR_PASS ptf,
#define _PTF _ptf->
#define _PTFV _ptf
#define FLX_PASS_PTF 1
#define FLX_EAT_PTF(x) x
#define FLX_DEF_THREAD_FRAME
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_FRAME_WRAPPERS \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  ptf.gc = gc;\
  return &ptf;\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_FRAME_WRAPPERS \
extern "C" thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  thread_frame_t *p = new(*gc,thread_frame_t_ptr_map) thread_frame_t(gc);\
  ptf = p;\
  return p;\
}
#else
#define FLX_FRAME_WRAPPERS \
extern "C" FLX_EXPORT thread_frame_t *create_thread_frame(\
  collector_t *gc\
) {\
  thread_frame_t *p = new(*gc,thread_frame_t_ptr_map) thread_frame_t(gc);\
  return p;\
}
#endif

#if defined(FLX_PTF_STATIC_STRUCT)
#define FLX_START_WRAPPER(x)\
extern "C" con_t *flx_start(\
  thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,x##_ptr_map) \
    x()) ->call(0);\
}
#elif defined(FLX_PTF_STATIC_POINTER)
#define FLX_START_WRAPPER(x)\
extern "C" con_t *flx_start(\
  thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,x##_ptr_map) \
    x()) ->call(0);\
}
#else 
#define FLX_START_WRAPPER(x)\
extern "C" FLX_EXPORT con_t *flx_start(\
  thread_frame_t *ptf,\
  int argc,\
  char **argv,\
  FILE *stdin_,\
  FILE *stdout_,\
  FILE *stderr_\
) {\
  ptf->argc = argc;\
  ptf->argv = argv;\
  ptf->flx_stdin = stdin_;\
  ptf->flx_stdout = stdout_;\
  ptf->flx_stderr = stderr_;\
  return (new(*ptf->gc,x##_ptr_map) \
    x(ptf)) ->call(0);\
}
#endif

#endif

@h = tangler("rtl/flx_rtl.cpp")
@select(h)
#include "flx_rtl.hpp"
#include <cstdio>

namespace flx { namespace rtl {
con_t::con_t() : pc(0), p_svc(0), _caller(0) { 
#ifdef FLX_DEBUG_CONT
 printf("Constructing %p\n",this);
#endif
}
con_t::~con_t(){
#ifdef FLX_DEBUG_CONT
  printf("Destroying %p\n",this);
#endif
}

// fthread
fthread_t::fthread_t() : cc(0) {}
fthread_t::fthread_t(con_t *a) : cc(a) {}
fthread_t::~fthread_t(){cc=0;}
_uctor_ *fthread_t::get_svc()const { return cc?cc->p_svc:0; }

_uctor_ *fthread_t::run() {
restep:
  cc->p_svc = 0;
step:  
  try { cc = cc->resume(); }
  catch (con_t *x) { cc = x; }

  if(!cc) return 0; // died

  if(cc->p_svc)
  {
    switch(cc->p_svc->variant)
    {
      case svc_get_fthread: 
        **(fthread_t***)(cc->p_svc->data) = this;
        
      case svc_yield: 
        goto restep;

      // we don't know what to do with the request,
      // so pass the buck to the driver
      default:
        return cc->p_svc;
    }
  }
  goto step;
}
//OFFSETS for fthread_t
static std::size_t _fthread_offsets[1]={
    offsetof(fthread_t,cc)
};

static void _fthread_finaliser (flx::gc::generic::collector_t *, void *p)
{
  ((fthread_t*)p)->~fthread_t();
}

flx::gc::generic::gc_shape_t _fthread_ptr_map(
  "fthread_t",
  1,sizeof(fthread_t),
  _fthread_finaliser,
  1,
  _fthread_offsets
);


void _ref_::operator = (_ref_ const& r)
{
  if (data != r.data)
  {
    if (frame != r.frame)
    {
      frame = r.frame;
    }
    data = r.data;
  }
}

//OFFSETS for _ref_
static std::size_t _ref_offsets[1]={
    offsetof(_ref_,frame)
};

static void _ref_finaliser (flx::gc::generic::collector_t *, void *p)
{
  ((_ref_*)p)->~_ref_();
}

flx::gc::generic::gc_shape_t _ref_ptr_map(
  "_ref_",
  1,sizeof(_ref_),
  _ref_finaliser,
  1,
  _ref_offsets
);

//OFFSETS for _uctor_
static std::size_t _uctor_offsets[1]= { 
  offsetof(_uctor_,data) 
};

flx::gc::generic::gc_shape_t _uctor_ptr_map (
  "_uctor_",
  1,
  sizeof(_uctor_),
  0,
  1,
  _uctor_offsets
);

flx::gc::generic::gc_shape_t _int_ptr_map (
  "int",
  1,
  sizeof(int),
  0,
  0,
  0
);

flx::gc::generic::gc_shape_t unit_ptr_map (
  "unit",
  1,
  sizeof(unit),
  0,
  0,
  0
);
                                                                                
flx_exec_failure_t::flx_exec_failure_t(std::string f, std::string o, std::string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_exec_failure_t::~flx_exec_failure_t(){}

flx_range_srcref_t::flx_range_srcref_t(char *f,int sl, int sc, int el, int ec) :
    filename(f),startline(sl),startcol(sc),endline(el),endcol(ec){}
flx_match_failure_t::flx_match_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_match_failure_t::~flx_match_failure_t(){}
flx_assert_failure_t::flx_assert_failure_t(flx_range_srcref_t ff, char *cf, int cl) :
   flx_loc(ff), cxx_srcfile(cf), cxx_srcline(cl) {}
flx_assert_failure_t::~flx_assert_failure_t(){}
flx_switch_failure_t::~flx_switch_failure_t(){}

}}

@head(2,"Unix Dynamic linker")
This is a Unix specific module, which uses dlopen
and friends to dynamically attach a shared file
representing a felix top level module to an 
application, and extract the standard 
symbols from it.
@p()
The link routine links the following symbols,
which must be present in all felix libraries.

@begin_displayed_code()
  create_thread_frame
  start
@end_displayed_code()

The unlink routine is called to unlink the library.
@p()
Note that felix never generates variables of static,
storage class, however felix has no control over
used C/C++ code embedded in Felix library modules.
DO NOT use static storage class for variables,
or even constants which require dynamic initialisation.

@h = tangler("rtl/flx_dynlink.hpp")
@select(h)
#ifndef FLX_DYNLINK
#define FLX_DYNLINK
#ifndef FLX_RTL
#include "flx_rtl.hpp"
#include "flx_gc.hpp"
#endif
#include <string>
using namespace std;

// define the type of a library handle: needed even for static linkage
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
#include <windows.h>
typedef HMODULE LIBHANDLE;
#else
  #ifdef MACOSX_NODLCOMPAT
     #include <mach-o/dyld.h>
     typedef NSModule LIBHANDLE;
   #else
     typedef void *LIBHANDLE;
   #endif
#endif

#ifndef FLX_STATIC_LINK
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
#define DLSYM(x,y) (void*)GetProcAddress(x,#y) 
#define SDLSYM(x,y) (void*)GetProcAddress(x,y) 
#else
  #ifdef MACOSX_NODLCOMPAT
    //#include <mach-o/dyld.h>
    #define DLSYM(x, y) flx::rtl::getmachosym(x,"_"#y)
    #define SDLSYM(x, y) flx::rtl::getmachosym(x,(string("_")+string(y)).data())
  #else
    #include <dlfcn.h>
    #define DLSYM(x,y) dlsym(x,#y)
    #define SDLSYM(x,y) dlsym(x,y)
  #endif
#endif

#else
#define DLSYM(x,y) (void*)&y
#define SDLSYM(x,y) (throw flx::rtl::link_failure_t("<static link>",y,"dlsym with static link requires name not string")
#endif
// Utilities to make dynamic linkage and
// initialisation of Felix modules easier
//
// We provide a standard exception to report
// link failure (missing symbol).
//
// We provide a a class flx_dynlink_t which
// opens a Felix shared library given a filename,
// and links the mandatory symbols
// The user may derive from this class to add
// linkage for extra symbols
//
// We provide a class flx_libinit_t which
// initialises and terminates a Felix module
// The user may derive from this class to add
// extra initialisation or termination processing.
//
// [Note: the virtuals are *deliberately* private. 
// Be sure to make your overrides private too,
// so they cannot be called:
// they're dispatched automatically by wrappers
// defined in the base]

// must be at global scope, because the users' is
struct thread_frame_t;

namespace flx { namespace rtl {

struct FLX_RTL_EXTERN flx_link_failure_t;
struct FLX_RTL_EXTERN flx_dynlink_t;
struct FLX_RTL_EXTERN flx_libinit_t;

struct FLX_RTL_EXTERN flx_link_failure_t {
  string filename;
  string operation;
  string what;
  flx_link_failure_t(string f, string o, string w);
  virtual ~flx_link_failure_t();
};

// frame creators
typedef thread_frame_t *(*thread_frame_creator_t)
(
  flx::gc::generic::collector_t*
);

// library initialisation routine
typedef con_t *(*start_t)
(
  thread_frame_t*,
  int,
  char **,
  FILE*,
  FILE*,
  FILE*
  
);

struct FLX_RTL_EXTERN flx_dynlink_t
{
  // data
  LIBHANDLE library;
  string filename;
  thread_frame_creator_t thread_frame_creator;
  start_t start_sym;
  long refcnt;

  // routines
  void link(char const *filename) throw(flx_link_failure_t);
  void unlink();
  virtual ~flx_dynlink_t();
private:
  // the user should override this procedure to
  // link any extra symbols.
  // on error, throw a flx_link_failure_t,
  // otherwise your exception will be dishonoured
  // and a generic link_failure_t thrown anyhow

  virtual void usr_link();
    // called after mandatory symbols are linked
};

struct FLX_RTL_EXTERN flx_libinit_t 
{
  thread_frame_t *thread_frame;
  con_t *start_proc;
  flx_dynlink_t *lib;
  flx::gc::generic::collector_t *collector;
  void create
  (
    flx_dynlink_t *lib_a, 
    flx::gc::generic::collector_t *collector_a,
    int argc,
    char **argv,
    FILE *stdin_,
    FILE *stdout_,
    FILE *stderr_
  );

  void destroy ();

  con_t *bind_proc(void *fn, void *data);
  virtual ~flx_libinit_t();
  
private:
  // the user can override these procedures
  // to perform any additional initialisation
  // and termination required.
  
  virtual void usr_create(); 
    // called after standard init completes
    
  virtual void usr_destroy(); 
    // called before standard destroy starts
};

#ifdef MACOSX_NODLCOMPAT
void* getmachosym(LIBHANDLE, const char*);
#endif

}} // namespaces
#endif

@h = tangler("rtl/flx_dynlink.cpp")
@select(h)
#include "flx_dynlink.hpp"
#ifdef FLX_STATIC_LINK
extern "C" void *create_thread_frame;
extern "C" void *flx_start;
#endif

namespace flx { namespace rtl {

#ifdef MACOSX_NODLCOMPAT
void*
getmachosym(NSModule library, const char* symname)
{
    NSSymbol    sym = NSLookupSymbolInModule(library, symname);
    if(sym)
        return NSAddressOfSymbol(sym);
    return 0;
}

#endif

flx_link_failure_t::flx_link_failure_t(string f, string o, string w) : 
  filename(f), 
  operation(o), 
  what(w) 
{}

flx_link_failure_t::~flx_link_failure_t(){}

flx_dynlink_t::~flx_dynlink_t(){}

void flx_dynlink_t::link(char const *fname) throw(flx_link_failure_t)
{
  filename=fname;
#ifndef FLX_STATIC_LINK
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
  SetErrorMode(SEM_NOOPENFILEERRORBOX);  // stop windows showing err dialogues
  library = LoadLibrary(fname);
  if(!library) 
    throw flx_link_failure_t(filename,"LoadLibrary","Cannot find dll");
#else
  #ifdef MACOSX_NODLCOMPAT
    NSObjectFileImage            bndl_img;
    NSObjectFileImageReturnCode  res;

    res = NSCreateObjectFileImageFromFile(fname, &bndl_img);

	if(NSObjectFileImageSuccess != res)
      throw flx_link_failure_t(filename, "NSCreateObjectFileImageFromFile",
              "failure to open library");

    // don't merge globals with loader's, load programmatically
    // return on error allows us to continue without being terminated

    unsigned long                link_flags;
    link_flags = NSLINKMODULE_OPTION_PRIVATE | NSLINKMODULE_OPTION_RETURN_ON_ERROR;
    library = NSLinkModule(bndl_img, fname, link_flags);

    // even if link failed, we do this
    NSDestroyObjectFileImage(bndl_img);

    // more info can be gleaned about link errors from NSLinkEditError
    if(!library)
      throw flx_link_failure_t(filename, "NSLinkModule", "failed to link");

  #else
  library = dlopen(fname,RTLD_NOW);
  if(!library) 
    throw flx_link_failure_t(filename,"dlopen",dlerror());
  #endif
#endif
#endif

  //fprintf(stderr,"File %s dlopened at %p ok\n",fname,library);

  thread_frame_creator = (thread_frame_creator_t)
    DLSYM(library,create_thread_frame);
  if(!thread_frame_creator) 
    throw flx_link_failure_t(filename,"dlsym","create_thread_frame");

  //fprintf(stderr,"Thread frame creator found at %p\n",thread_frame_creator);

  start_sym = (start_t)DLSYM(library,flx_start);
  if(!start_sym) 
    throw flx_link_failure_t(filename,"dlsym","flx_start");

  //fprintf(stderr,"Start symbol found at %p\n",start_sym);
  
  refcnt = 1L;

  //fprintf(stderr,"Set refcnt to 1\n");
  try { usr_link(); }
  catch (flx_link_failure_t &) { throw; }
  catch (...) { 
    throw flx_link_failure_t
    (
      filename,
      "usr_link()",
      "Unknown user exception"
    );
  }
}

void flx_dynlink_t::unlink()
{
  --refcnt;
  if(refcnt == 0) {
    //fprintf(stderr,"closing library\n");
#ifndef FLX_STATIC_LINK
//#if defined(_WIN32) || defined(__CYGWIN__)
#if defined(_WIN32) 
    FreeLibrary(library);
#else
  #ifdef MACOSX_NODLCOMPAT
    NSUnLinkModule(library, NSUNLINKMODULE_OPTION_NONE);
  #else
    dlclose(library);
  #endif
#endif
#endif
  }
}

void flx_dynlink_t::usr_link(){}

flx_libinit_t::~flx_libinit_t(){}

void flx_libinit_t::create
(
  flx_dynlink_t *lib_a, 
  flx::gc::generic::collector_t *collector_a,
  int argc,
  char **argv,
  FILE *stdin_,
  FILE *stdout_,
  FILE *stderr_
)
{
  lib = lib_a;
  collector = collector_a;
  thread_frame = lib->thread_frame_creator(
    collector 
  );
  //fprintf(stderr,"Incrementing refcnt\n");
  ++lib->refcnt;
  collector->add_root(thread_frame);
  start_proc = lib->start_sym(thread_frame, argc, argv, stdin_,stdout_,stderr_);
  usr_create();
}

void flx_libinit_t::usr_create(){}

void flx_libinit_t::destroy () {
  usr_destroy();
  collector->remove_root(thread_frame);
  //fprintf(stderr,"Decrementing refcnt\n");
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
  --lib->refcnt;
  //fprintf(stderr,"Ref cnt=%ld\n",lib->refcnt);
}

void flx_libinit_t::usr_destroy (){}

con_t *flx_libinit_t::bind_proc(void *fn, void *data) {
  typedef con_t *(*binder_t)(void *,void*);
  return ((binder_t)fn)(thread_frame,data);
}

}} // namespaces


@head(2,'Universal Program Driver')
This driver runs stand alone Felix programs.
It invokes the library routine 'start'.
No messages are dispatched, the Felix
program must not read any messages.
@p()
For statically linked programs,
command line arguments are passed directly,
the debugging switch isn't supported.
@p()
For dynamically loaded programs, the name of the
driver and optional --debug switch given before the
shared library name are not passed.

@h = tangler('rtl/flx_run.cxx','cpp')
@select(h)
#include <cstdlib>
#include <stdio.h>
#include <vector>
#include <list>
#include <map>
#include <cstring>
#include <cassert>

#include <string>
//#include <unistd.h>
#include "flx_rtl.hpp"

#include "flx_collector.hpp"
#include "flx_dynlink.hpp"
using namespace std;
using namespace flx::rtl;
#ifdef HAVE_GXX_X86
register void *sp __asm__("esp");
#else
static void *sp = 0;
#endif

void print_loc(FILE *ef,flx_range_srcref_t x,char *cf, int cl)
{
  fprintf(ef,"Felix location: %s %d[%d]-%d[%d]\n",
    x.filename,
    x.startline,
    x.startcol,
    x.endline,
    x.endcol
  );
  fprintf(ef,"C++ location  : %s %d\n", cf, cl);
}

int main(int argc, char** argv)
{
#ifndef FLX_STATIC_LINK  
  bool static_link = false;
  if (argc<2) 
  {
    printf("usage: flx_run [--debug] dll_filename options ..\n");
    return 1;
  }
  char *filename = argv[1];
  char **flx_argv = argv+1;
  int flx_argc = argc-1;
  bool debug = (argc > 1) && (strcmp(argv[1],"--debug")==0);
  if(debug)
  {
    if(argc<3)
    {
      printf("usage: flx_run [--debug] dll_filename options ..\n");
      return 1;
    }
    filename = argv[2];
    --flx_argc;
    ++flx_argv;
  }
#else
  bool static_link = true;
  char *filename = argv[0];
  char **flx_argv = argv;
  int flx_argc = argc;
  bool debug = false;
//  printf("Statically linked Felix program running\n");
#endif
  char *debug_env = std::getenv("FLX_DEBUG");
  debug = debug || debug_env != 0;
  if(debug)
  {
    fprintf(stderr,"Debug enabled for %s link program\n",static_link?"static":"dynamic");
  }
  char *finalise_env= std::getenv("FLX_FINALISE");
  bool finalise = finalise_env != 0;
  if(debug) 
    fprintf(stderr,"Finalisation %s\n",finalise? "Enabled" : "Disabled");
#ifdef HAVE_GXX
    if(debug) fprintf(stderr, "Compiled by g++\n");
    static void *init_sp = sp;
    static void *init_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *init_ret = __builtin_return_address(0);
#endif
  if(debug)
    for(int i=0; i<flx_argc; ++i) 
    fprintf(stderr,"flx_argv[%d]->%s\n",i,flx_argv[i]);
  try 
  {
    if(debug)
      fprintf(stderr,"flx_run driver begins %s\n",flx_argv[0]);
    flx_dynlink_t library;
    flx_libinit_t instance;

    library.link(filename);
    flx::gc::collector::malloc_free allocator;
    allocator.set_debug(debug);
    flx::gc::collector::flx_collector_t collector(&allocator);
    collector.set_debug(debug);
    instance.create(&library, &collector,flx_argc,flx_argv,stdin,stdout,stderr);
    if(debug) {
      fprintf(stderr,"loaded library %s at %p\n",filename,library.library);
      fprintf(stderr,"thread frame at %p\n",instance.thread_frame);
      fprintf(stderr,"initial continuation at %p\n",instance.start_proc);
    } 
    int gc_counter = 0;
    unsigned long collections = 0;

    con_t *top = instance.start_proc;
    fthread_t *ft = new (collector,_fthread_ptr_map) fthread_t(top);
    collector.add_root(ft);
    _uctor_ *request = ft->run();

    while( request && request->variant  == svc_yield)
    {
      gc_counter++;
      if(gc_counter == 1000)
      {
        gc_counter = 0;
        ++collections;
        unsigned long n = collector.collect();
        if(debug)fprintf(stderr,"collected %ld objects\n",n);
      }
      request = ft->run();
    }
    if(debug){
      unsigned long uncollected = collector.get_allocation_count();
      unsigned long roots = collector.get_root_count();
      fprintf(stderr,"program finished, %ld collections, %ld uncollected objects, roots %ld\n",collections,uncollected,roots);
    }
    if(finalise)
    {
      if(debug) fprintf(stderr,"Finalising\n");
      if(debug)fprintf(stderr,"removing thread %p\n",ft);
      collector.remove_root(ft);
      {
        if(debug)
          fprintf(stderr,"Data collection starts ..\n");
        unsigned long n = collector.collect();
        unsigned long a = collector.get_allocation_count();
        if(debug)
          fprintf(stderr,"flx_run collected %ld objects, %ld left\n",n,a);
      }
      if(debug)
        fprintf(stderr,"Destroying program instance\n");
      instance.destroy();

      if(debug)
        fprintf(stderr,"Final collection starts ..\n");
      unsigned long n = collector.collect();
      unsigned long a = collector.get_allocation_count();
      if(debug)
        fprintf(stderr,"Collected %ld objects, %ld left (should be 0)\n",n,a);
      if(a!=0){
        fprintf(stderr,"flx_run %ld uncollected objects, should be zero!!\n",a);
        return 5;
      }
      if(debug)
        fprintf(stderr,"Libref cnt = %ld\n",library.refcnt);
      if(library.refcnt >0)
      {
        if(debug)
          fprintf(stderr,"flx_run %p library still referenced %ld times (expected 1)\n",library.library,library.refcnt);
      }
      if(debug)
        fprintf(stderr,"Unlinking library ..\n");
      library.unlink();
      if(library.refcnt >0)
      {
        fprintf(stderr,"flx_run %p library still referenced %ld times?!\n",library.library,library.refcnt);
        return 6;
      }
      if(debug)
        fprintf(stderr,"flx_run driver ends with finalisation complete, collected %ld,left=%ld\n",n,a);
    }
    else {
      if(debug) {
        unsigned long a = collector.get_allocation_count();
        fprintf(stderr,"flx_run driver ends with finalisation skipped, %ld uncollected objects\n",a);
      }
    }
  }
  catch (flx_link_failure_t x)
  {
    fprintf(stderr,"Dynamic linkage error\n");
    fprintf(stderr,"filename: %s\n",x.filename.data());
    fprintf(stderr,"operation: %s\n",x.operation.data());
    fprintf(stderr,"what: %s\n",x.what.data());
    return 2;
  }
  catch (flx_exec_failure_t x)
  {
    fprintf(stderr,"Execution error\n");
    fprintf(stderr,"filename: %s\n",x.filename.data());
    fprintf(stderr,"operation: %s\n",x.operation.data());
    fprintf(stderr,"what: %s\n",x.what.data());
    return 3;
  }
  catch (flx_assert_failure_t x)
  {
    fprintf(stderr,"Assertion Failure\n");
    print_loc(stderr,x.flx_loc,x.cxx_srcfile, x.cxx_srcline);
    return 3;
  }
  catch (flx_match_failure_t x)
  {
    fprintf(stderr,"Match Failure\n");
    print_loc(stderr,x.flx_loc,x.cxx_srcfile, x.cxx_srcline);
    return 3;
  }
  catch (...)
  {
    fprintf(stderr,"flx_run driver ends with unknown EXCEPTION\n");
    return 4;
  }
#ifdef HAVE_GXX
    // check the frame pointer isn't corrupted
    static void *fin_sp = sp;
    static void *fin_fframe FLX_UNUSED = __builtin_frame_address(0);
    static void *fin_ret = __builtin_return_address(0);
    if (init_sp != fin_sp ) {
      fprintf(stderr,"g++: STACK POINTER ERROR %p != %p\n",init_sp,fin_sp);
    }
// I have to comment this out, because it only applies if the
// gcc compiler is using the frame pointer.. it doesn't if you
// say -fomit-frame-pointer, for example .. I don't know if there
// is a way to tell inside the code ..
#if 0
    if (init_fframe != fin_fframe) {
      fprintf(stderr,"g++: FRAME POINTER ERROR %p != %p\n",init_fframe,fin_fframe);
    }
#endif
    else if (init_ret != fin_ret) {
      fprintf(stderr,"g++: RETURN ADDRESS ERROR %p != %p\n",init_ret,fin_ret);
    }
#endif
  if(debug)fprintf(stderr,"flx_run driver ends OK\n");
  return 0;
}

@h = tangler('test/micky_mouse.cxx','cpp')
@select(h)
#include <stdio.h>
#include "flx_rtl.hpp"
#include "flx_collector.hpp"
#include "flx_dynlink.hpp"

using namespace std;
using namespace flx;

int main(int argc, char** argv)
{
  rtl::flx_dynlink_t library;
  rtl::flx_libinit_t instance;
  library.link(argc>1?argv[1]:"<static>");
  gc::collector::malloc_free allocator;
  gc::collector::flx_collector_t collector(&allocator);
  instance.create(&library, &collector,argc,argv,stdin,stdout,stderr);
  rtl::con_t *top = instance.start_proc;
  while( top ) top = top->resume();
  return 0;
}


