@execfile('config'+os.sep+'flx_data.py')
@h = tangler('src/flx_token.mli')
@select(h)
open Flx_ast
open Flx_mtypes2

type token = 
  | ERRORTOKEN of (srcref * string)
  | ENDMARKER
  | NEWLINE 
  | SLOSH
  | COMMENT of string
  | COMMENT_NEWLINE of string
  | WHITE of int
  | NAME of (srcref * string)
  | INTEGER of (srcref * string * Flx_ast.bigint)
  | FLOAT of (srcref * string * string)
  | STRING of (srcref * string)
  | CSTRING of (srcref * string)
  | FSTRING of (srcref * string)
  | QSTRING of (srcref * string)
  | WSTRING of (srcref * string)
  | USTRING of (srcref * string)
  | USER_KEYWORD of (srcref * string)
  | HASH_INCLUDE_FILES of string list
  | TOKEN_LIST of token list
  | DUMMY
  | USER10 of (srcref * string * string)
  | USERLB of (srcref * (string * string) list * string)
  | USERRB of (srcref * string)
  | LOAD_SYNTAX of (local_data_t)
  | SAVE_SYNTAX of (string)

@for k,v in flx_syms:
  tangle("  | "+k+" of srcref",inhibit_sref=1)

@for n,k in flx_keywords: 
  tangle("  | "+k+" of srcref",inhibit_sref=1)

and prio_t = [`Default | `Priority of string]

and rule_t = string * prio_t * token list * string * Flx_ast.range_srcref

and dssl_t = {
  prios : string list list;
  rules : rule_t list;
  deps : string list;
  privacy : string Drules.t; (* string -> string *)
}

and local_data_t = {
  dssls : dssl_t Drules.t;
  loaded_dssls : string list;
  scm : (range_srcref * string) list;
}

and global_data_t = {
  pcounter : int ref;
  env : Ocs_types.env;
  pdebug : bool ref;
}


@h = tangler('src/flx_prelex.mli')
@select(h)
val src_of_token : Flx_token.token -> Flx_ast.srcref
val string_of_token : Flx_token.token -> string
val name_of_token : Flx_token.token -> string

@h = tangler('src/flx_prelex.ml')
@select(h)
open Flx_token

let string_of_string s = "\"" ^  Flx_string.c_quote_of_string s ^ "\""

let string_of_token (tok :Flx_token.token): string =
  match tok with
  | DUMMY -> "DUMMY"
  | NAME (sr,s) -> s
  | INTEGER (sr,t,i) -> Big_int.string_of_big_int i
  | FLOAT (sr,t,v) -> v
  | STRING (sr,s) -> Flx_string.c_quote_of_string s 
  | CSTRING (sr,s) -> Flx_string.c_quote_of_string s 
  | FSTRING (sr,s) -> Flx_string.c_quote_of_string s 
  | QSTRING (sr,s) -> Flx_string.c_quote_of_string s 
  | WSTRING (sr,s) -> Flx_string.c_quote_of_string s 
  | USTRING (sr,s) -> Flx_string.c_quote_of_string s 
  | USER10 (sr,op,fn) -> "op10 " ^ op
  | USERLB (sr,_,lb) -> lb
  | USERRB (sr,rb) -> rb
  | USER_KEYWORD (sr,s) -> s
  | HASH_INCLUDE_FILES fs -> "include_files(" ^ String.concat "," fs ^ ")"
  | TOKEN_LIST ts -> "<<token list>>"
  | LOAD_SYNTAX _ -> "<<load syntax>>"
  | SAVE_SYNTAX f -> "<<save syntax "^f^">>"
  (*
  | PARSE_ACTION sr -> "=>#"
  *)
  
@for k,s in flx_syms:
  tangle('  | '+k+' _ -> "'+s+'"',inhibit_sref=1)

@for n,t in flx_keywords: 
  tangle('  |  '+t+' _ -> "'+n+'"',inhibit_sref=1)
@#
  | COMMENT s -> s (* C style comment, includes the /* */ pair *)
  | COMMENT_NEWLINE s -> "// " ^ s ^ "<NEWLINE>"
  | WHITE i -> String.make i ' '
  | NEWLINE -> "<NEWLINE>"
  | ENDMARKER -> "<<EOF>>"
  | ERRORTOKEN (sref,s) -> "<<ERROR '"^ s ^"'>>"
  | SLOSH -> "\\"

let name_of_token (tok :Flx_token.token): string =
  match tok with
  | DUMMY -> "DUMMY"
  | NAME (sr,s) -> "NAME"
  | INTEGER (sr,t,i) -> "INTEGER"
  | FLOAT (sr,t,v) -> "FLOAT"
  | STRING (sr,s) -> "STRING"
  | CSTRING (sr,s) -> "CSTRING"
  | FSTRING (sr,s) -> "FSTRING"
  | QSTRING (sr,s) -> "QSTRING"
  | WSTRING (sr,s) -> "WSTRING"
  | USTRING (sr,s) -> "USTRING"
  | USER10 (sr,op,f) -> "USER10"
  | USERLB _ -> "USERLB"
  | USERRB _ -> "USERRB"
  | USER_KEYWORD (sr,s) -> s
  | HASH_INCLUDE_FILES _ -> "HASH_INCLUDE_FILES"
  | TOKEN_LIST _ -> "TOKEN_LIST"
  | LOAD_SYNTAX _ -> "LOAD_SYNTAX"
  | SAVE_SYNTAX _ -> "SAVE_SYNTAX"
  (*
  | PARSE_ACTION sr -> "PARSE_ACTION"
  *)
@for k,s in flx_syms:
  tangle('  | '+k+' _ -> "'+k+'"',inhibit_sref=1)

@for n,t in flx_keywords: 
  tangle('  |  '+t+' _ -> "'+t+'"',inhibit_sref=1)
@#
  | COMMENT s -> "COMMENT"
  | COMMENT_NEWLINE s -> "COMMENT_NEWLINE"
  | WHITE i -> "WHITE"
  | NEWLINE -> "NEWLINE"
  | ENDMARKER -> "ENDMARKER"
  | ERRORTOKEN (sref,s) -> "ERRORTOKEN"
  | SLOSH -> "SLOSH"

let src_of_token t = match t with
  | DUMMY
  | NEWLINE 
  | COMMENT _
  | COMMENT_NEWLINE _
  | WHITE _ 
  | ENDMARKER
  | SLOSH 
  | HASH_INCLUDE_FILES _
  | TOKEN_LIST _
  | LOAD_SYNTAX _
  | SAVE_SYNTAX _
    -> ("",0,0,0)

  | NAME    (s,_)
  | INTEGER (s,_,_)
  | FLOAT   (s,_,_)
  | STRING  (s,_)
  | CSTRING  (s,_)
  | FSTRING  (s,_)
  | QSTRING  (s,_)
  | WSTRING  (s,_)
  | USTRING  (s,_)
  | USER10 (s,_,_)
  | USERLB (s,_,_)
  | USERRB (s,_)
  | USER_KEYWORD (s,_)
  (*
  | PARSE_ACTION s
  *)
  | ERRORTOKEN (s,_) 

@for k,s in flx_syms:
  tangle('  | '+k+' s ',inhibit_sref=1)

@for n,t in flx_keywords: 
  tangle('  | '+t+' s',inhibit_sref=1)
@#
  -> s


