@execfile("config"+os.sep+"target_cxx.py")
@execfile("flxbuild"+os.sep+"iscrutil.py")

@env = setup_test('test/mmap/mmap-')

@head(1,"Address space management")

@select(tangler('spkgs/mmap.py'))
if HAVE_MMAP:
@tangle('  unit_tests = glob.glob("'+env.root+'*.flx")')

iscr_source = ['lpsrc/flx_mmap.pak']
weaver_directory = 'doc/mmap/'

@h = tangler('config/mmap.fpc', 'data')
@select(h)
Name: mmap

@h = tangler('lib/mmap.flx')
@select(h)
#import <flx.flxh>

module Mmap
{
  header """
    #include <sys/mman.h>
    #include <unistd.h>

    // MAP_ANON is an older form of MAP_ANONYMOUS, and should be compatible
    #if !defined(MAP_ANONYMOUS) && defined(MAP_ANON)
    #  define MAP_ANONYMOUS MAP_ANON
    #endif
  """;
  
  typedef off_t = unsigned long;
  // protection options
@if HAVE_MMAP:
  if HAVE_MMAP_PROT_EXEC:  tangle('  const PROT_EXEC : int;')
  if HAVE_MMAP_PROT_READ:  tangle('  const PROT_READ : int;')
  if HAVE_MMAP_PROT_WRITE: tangle('  const PROT_WRITE : int;')

  if HAVE_MMAP_DENYWRITE:    tangle('  const MAP_DENYWRITE: int;')
  if HAVE_MMAP_ANONYMOUS:    tangle('  const MAP_ANONYMOUS: int;')
  if HAVE_MMAP_FILE:         tangle('  const MAP_FILE: int;')
  if HAVE_MMAP_FIXED:        tangle('  const MAP_FIXED: int;')
  if HAVE_MMAP_HASSEMAPHORE: tangle('  const MAP_HASSEMAPHORE: int;')
  if HAVE_MMAP_SHARED:       tangle('  const MAP_SHARED : int;')
  if HAVE_MMAP_PRIVATE:      tangle('  const MAP_PRIVATE : int;')
  if HAVE_MMAP_NORESERVE:    tangle('  const MAP_NORESERVE: int;')
  if HAVE_MMAP_LOCKED:       tangle('  const MAP_LOCKED: int;')
  if HAVE_MMAP_GROWSDOWN:    tangle('  const MAP_GROWSDOWN: int;')
  if HAVE_MMAP_32BIT:        tangle('  const MAP_32BIT: int;')
  if HAVE_MMAP_POPULATE:     tangle('  const MAP_POPULATE: int;')
  if HAVE_MMAP_NONBLOCK:     tangle('  const MAP_NONBLOCK: int;')
@#

  const MAP_FAILED : address;

  // size of a page
  const _SC_PAGESIZE : long = "sysconf(_SC_PAGESIZE)";
  
  fun mmap: 
    address * //< start address
    size *    //< bytes to map
    int *     //< protection
    int *     //< flags
    int *     //< file descriptor
    off_t     //< offset into file, multiple of _SC_PAGESIZE
    -> address; //< start of reserved address space

  fun munmap: address * size -> int;
}

@env.head(1, 'mmap tests')
@select(env.test('.flx'))
#import <flx.flxh>
include "mmap";
open Mmap;
open MixedInt;
open C_hack;

val n = cast[size](10000);
data :=
  mmap
    (
      NULL,n, 
      PROT_WRITE \| PROT_READ, 
      MAP_PRIVATE \| MAP_ANONYMOUS, 
      -1,cast[off_t]0
    )
;

if data == MAP_FAILED do
  print$ "mmap failed!\n";
else
  res := munmap(data,n);
  if res != 0 do
    print$ "munmap failed!\n";
  else
    print$ "mmap worked!\n";
  done;
done;
@doc()

@select(env.expect())
mmap worked!
@doc()

