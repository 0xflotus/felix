@head(1,"Address space management")
$Log$
Revision 1.3  2006/08/02 22:24:15  idadesub
make sure we can also deal with a None result from get_stdout

Revision 1.2  2006/07/17 17:22:40  skaller
Add test case for mmap.

Revision 1.1  2006/07/17 16:42:40  skaller
Start with config and small binding for mmap.

@select(tangler('tmp' + os.sep + 'mmap_test.cxx'))
// NOTE REQUIRES MAP_ANONYMOUS (linux only ..)
#include <sys/mman.h>
#include <stdio.h>
#include <errno.h>
#include <stdlib.h>

int main()
{
   size_t n = 10000;
   void *data = 
       mmap
       (
          NULL,n, 
          PROT_WRITE | PROT_READ, 
          MAP_PRIVATE | MAP_ANONYMOUS, 
          0,0
       )
    ;
   if (data == MAP_FAILED) 
   {
      return 1;
   }
   int res = munmap(data,n);
   if (res != 0)
   {
      return 1;
   }
   return 0;
}

@select(tangler("cpkgs/target/mmap.py"))
execfile("config"+os.sep+"config.py")
try:
  cload(globals(),"mmap")
except:
  #HAVE_MMAP=TARGET_CXX.check_header_exists(xqt,'sys/mman.h')
  try:
    result, lines = TARGET_CXX.run_static_program(xqt, get_stdout, "tmp"+os.sep+"mmap_test")
  except:
    HAVE_MMAP = 0
  else:
    HAVE_MMAP = not result
  f = cwrite("mmap")
  pa(f,locals(),"HAVE_MMAP")
  f.close()
  cload(globals(),"mmap")

@h = tangler('spkgs/mmap.py')
@select(h)
execfile('cpkgs'+os.sep+'target'+os.sep+'mmap.py')
if HAVE_MMAP:
  unit_tests = ['test'+os.sep+'flx_mmap_test.flx']

iscr_source = ['lpsrc/flx_mmap.pak']
weaver_directory = 'doc/mmap/'

@h = tangler('config/mmap.fpc')
@select(h)
Name: mmap

@h = tangler('lib/mmap.flx')
@select(h)
#import <flx.flxh>
#import <flx_platform.flxh>

module Mmap
{
  header """
    #include <sys/mman.h>
    #include <unistd.h>
  """;
  
  typedef off_t = unsigned long;
  // protection options
  const PROT_EXEC : int;
  const PROT_READ: int;
  const PROT_WRITE : int;
  const PROT_NONE: int;

  const MAP_FIXED: int;
  const MAP_SHARED: int;
  const MAP_PRIVATE: int;

#if LINUX  
  const MAP_NORESERVE: int;
  const MAP_LOCKED: int;
  const MAP_GROWSDOWN: int;
  const MAP_ANONYMOUS: int;
  const MAP_32BIT: int;
  const MAP_POPULATE: int;
  const MAP_NONBLOCK: int;
#endif

  const MAP_FAILED : address;

  // size of a page
  const _SC_PAGESIZE : long = "sysconf(_SC_PAGESIZE)";
  
  fun mmap: 
    address * //< start address
    size *    //< bytes to map
    int *     //< protection
    int *     //< flags
    int *     //< file descriptor
    off_t     //< offset into file, multiple of _SC_PAGESIZE
    -> address; //< start of reserved address space

  fun munmap: address * size -> int;
}

@h = tangler("test/flx_mmap_test.flx")
@select(h)
#import <flx.flxh>
include "mmap";
open Mmap;
open MixedInt;
open C_hack;

val n = cast[size](10000);
data :=
  mmap
    (
      NULL,n, 
      PROT_WRITE \| PROT_READ, 
      MAP_PRIVATE \| MAP_ANONYMOUS, 
      0,cast[off_t]0
    )
;

if data == MAP_FAILED do
  print$ "mmap failed!\n";
else
  res := munmap(data,n);
  if res != 0 do
    print$ "munmap failed!\n";
  else
    print$ "mmap worked!\n";
  done;
done;

@select(tangler("test/flx_mmap_test.expect"))
mmap worked!
@doc()

