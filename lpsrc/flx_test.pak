@set_title('Felix Tests')

@select(tangler('spkgs/flx_test.py'))
import os

import config

root = config.src_dir

static_drivers = [
  ('test/drivers/flx_perf_drv1', ''),
  ('test/drivers/mickey_mouse', ''),
]

dynamic_drivers = [
  ('test/drivers/flx_perf_drv1', ''),
  ('test/drivers/mickey_mouse', ''),
]

drivers_require_libs = [
  'libflx_pthread',
  'libflx',
  'libflx_gc',
  'libflx_judy',
]

unit_tests = [('test', 'drivers', 'drvr-*.flx')]
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl']
iscr_source = ['lpsrc/flx_test.pak']

xfiles = [('test', 'drivers', '*')]
@doc()

@head(1,'Drivers')
These are C++ mainline routines, which are used
to drive different kinds of Felix programs.
@p()
The Universal Filter Driver, flx_stdin,
runs a Felix program which reads standard input.
@p()
We need some other standard drivers.
An X-Windows driver would be really nice.

@head(2,'Test 1')
The Universal Program Driver, flx_run,
runs a Felix program with no inputs.
This driver is located in flx_rtl.ipk.
@p()
This routine just loops through
numbers 1 to 10, and prints if they're odd or even.

@head(2,'Performance Test')
The first test program generates lines like:
@begin_displayed_code()
0 0 TEXT
0 1 TEXT
2 2 TEXT
2 3 TEXT
...
@end_displayed_code()
where the first value is a service key, and the second
a sequence number. Messages with the same service
key are sent to the same Felix line handler task:
if one does not exist, it is created. Each task
suicides after reading two lines.
@p()
We create 1 million threads, and process 2 million
messages.
