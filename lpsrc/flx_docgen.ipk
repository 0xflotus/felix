@head(1,"Documentation generator")
Parse and print doco.
@h=tangler("misc/flxdoc_style.css","data")
@select(h)
a:visited {color : #416DFF; text-decoration : none; }
a:link {color : #416DFF; text-decoration : none;}
a:hover {color : Red; text-decoration : none; background-color: #5FFF88}
a:active {color : Red; text-decoration : underline; }
.dcl { font-weight : bold ; color : Maroon }
body { margin-left : 20px; margin-right: 20px }
body .desc { color : Blue ; margin-bottom : 30px; margin-left: 20px }
div.topentry {  margin-bottom : 0.2em; margin-left: 20px; margin-top : 0.2em }
div.subentry { margin-left: 4ex; margin-bottom : 0.1em }
div.topentry div.desc { color : Purple; margin-bottom : 5px; margin-left: 20px }
.keyword { font-weight : bold ; color : Red }
.ctype { color : Green }
.keywordsign { color : #C04600 }
.superscript { font-size : 4 }
.subscript { font-size : 4 }
.comment { font-size : 14pt ;  border: 1px solid #000000;  
  margin-top: 5px; margin-bottom: 2px; 
  margin-left -20px;
  margin-right 20px;
  text-align: left; 
  background-color: #90EDFF; 
  padding: 2px; 
  padding-left: 20px;
}

.constructor { color : Blue }
.type { color : #5C6585 }
.string { color : Maroon }
.warning { color : Red ; font-weight : bold }
.info { margin-left : 3em; margin-right : 3em }
.code { color : #465F91 ; }
h1 { font-size : 20pt ; text-align: center; }
h2 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #90BDFF ;padding: 2px; }
h3 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #90DDFF ;padding: 2px; }
h4 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #90EDFF ;padding: 2px; }
h5 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #90FDFF ;padding: 2px; }
h6 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #90BDFF ; padding: 2px; }
div.h7 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #90DDFF ; padding: 2px; }
div.h8 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #F0FFFF ; padding: 2px; }
div.h9 { font-size : 20pt ; border: 1px solid #000000; margin-top: 5px; margin-bottom: 2px;text-align: center; background-color: #FFFFFF ; padding: 2px; }
.typetable { border-style : hidden }
.indextable { border-style : hidden }
.paramstable { border-style : hidden ; padding: 5pt 5pt}
body { background-color : White }
tr { background-color : White }
td.typefieldcomment { background-color : #FFFFFF }
pre { margin-bottom: 4px }
div.sig_block {margin-left: 2em}

@h=tangler("tools/flx_doc.flx")
@select(h)
include "std";
include "flx_lex";
include "flx_token";
include "flx_grammar";

open flx_token;
open flx_grammar;
open Text_file;

use Lexer::sub;
use Lexer::eq;

fun chop_directory (s:string)=
{
  var i = len s - 1;
  until i == -1 do
    if s.[i] == "/".[0] do return s.[i+1 to]; done;
    --i;
  done;
  return s;
}

fun chop_extension (s:string)=
{
  var i = len s - 1;
  until i == -1 do
    if s.[i] == ".".[0] do return s.[to i]; done;
    --i;
  done;
  return s;
}

keywords := 
@for k,t in flx_keywords:
  tangle('("'+k+'",TOK_'+t+'),',inhibit_sref=1)
@#
  ("",TOK_EOF) // terminal
;

fun find_keyword(k:string) = 
{
  var i=0;
  var key = keywords.[i];
  until key.(0) == k or key.(0) == "" do 
    ++i;
    key = keywords.[i];
  done;
  return key.(1);
}

fun get_pretoken() = 
{
  open Flx_lex;
  def var j, var des = pre_flx_lex (i1, i2);
  match des with
  | qQuote =>        { j,des = parse_q_string (j,i2); }
  | qqqQuote =>      { j,des = parse_qqq_string (j,i2); }
  | dQuote =>        { j,des = parse_d_string (j,i2); }
  | dddQuote =>      { j,des = parse_ddd_string (j,i2); }
  | rqQuote =>       { j,des = parse_rq_string (j,i2); }
  | rqqqQuote =>     { j,des = parse_rqqq_string (j,i2); }
  | rdQuote =>       { j,des = parse_rd_string (j,i2); }
  | rdddQuote =>     { j,des = parse_rddd_string (j,i2); }
  | Preprocessor =>  { j = to_eol(j,i2) - 1; }
  | Cpp_comment =>   { j = to_eol(j,i2) - 1; }
  | C_comment =>     { j = to_end_c_comment (j,i2); }
  | _ => {}
  endmatch;
  lexeme := Lexer::string_between(i1,j);
  i1 = j;
  return
    match des with
    | Eol => TOK_EOF
    | Ident => 
      match find_keyword lexeme with
      | TOK_EOF => TOK_NAME lexeme
      | ?k => k
      endmatch

    // not really right, we should get the string
    // but enough for documentation processor

    | qQuote => TOK_STRING lexeme.[1 to -1]
    | qqqQuote => TOK_STRING lexeme.[3 to -3]
    | dQuote => TOK_STRING lexeme.[1 to -1]
    | dddQuote => TOK_STRING lexeme.[3 to -3]

    | wqQuote => TOK_STRING lexeme.[1 to -1]
    | wqqqQuote => TOK_STRING lexeme.[3 to -3]
    | wdQuote => TOK_STRING lexeme.[1 to -1]
    | wdddQuote => TOK_STRING lexeme.[3 to -3]

    | uqQuote => TOK_STRING lexeme.[1 to -1]
    | uqqqQuote => TOK_STRING lexeme.[3 to -3]
    | udQuote => TOK_STRING lexeme.[1 to -1]
    | udddQuote => TOK_STRING lexeme.[1 to -1]

    | rqQuote => TOK_STRING lexeme.[1 to -1]
    | rqqqQuote => TOK_STRING lexeme.[3 to -3]
    | rdQuote => TOK_STRING lexeme.[1 to -1]
    | rdddQuote => TOK_STRING lexeme.[3 to -3]

   
@for k,s in flx_1_char_syms:
  tangle('    | ' + k + ' => TOK_'+k,inhibit_sref=1)

@for k,s in flx_2_char_syms:
  tangle('    | ' + k + ' => TOK_'+k,inhibit_sref=1)

@for k,s in flx_3_char_syms:
  tangle('    | ' + k + ' => TOK_'+k,inhibit_sref=1)
@#
    | Preprocessor =>  TOK_EOF
    | Cpp_comment =>   TOK_EOF
    | C_comment =>     TOK_EOF
    | White => TOK_EOF

    // cheat again
    | Int => TOK_INTEGER (lexeme,"")
    | Float => TOK_FLOAT lexeme
    | _ => TOK_ERROR lexeme
    endmatch
  ;
}

endmarker := caseno TOK_ENDMARKER;
eol := '\n';

var eof = false;

kfun := keywrd "fun ";
kproc := keywrd "proc ";
ktype := keywrd "type ";
kctype := keywrd "ctype ";


var outdir = "doc_out/";

var i = 1;
var filename = System::argv 1;
if filename.[to 9] == "--outdir=" do
 outdir = filename.[9 to];
 ++i;
 filename = System::argv i;
done;

// make the output directory
C_hack::ignore(System::system("mkdir -p " + outdir));


mfile := outdir + "/index.html";
mf := fopen_output mfile;
writeln (mf, start_page "Felix Library");
writeln (mf,"<H1>"+outdir+"</H1>");

until filename == "" do
  handle_file filename;
  ++i;
  filename = System::argv i;
done;
writeln (mf,"</HTML></BODY>");
fclose mf;

var data: string;
var i1:Lexer::iterator;
var i2:Lexer::iterator;

proc handle_file(filename: string)
{
  print "Filename "; print filename; endl;
  data = load filename;
  eof = false;

  i2 = Lexer::end_iterator data;
  i1 = Lexer::start_iterator data;
  var x = 
    parse the get_token with
    | cu: flx_grammar::top => cu
    endmatch
  ;

  d :=
    match x with
    | case 1 => "Failure"
    | case 2 _ => "Success"
    endmatch
  ;
   
  print d; endl;

  if caseno x == 0 return;

  statements := 
    match x with 
    | case 2 ?cu => 
      match cu with 
      | compilation_unit_1 ?sts => sts
      endmatch
    endmatch
  ;

  basename := chop_extension (chop_directory filename);
  fn := outdir+'/'+basename+'_flx.html';
  f := fopen_output fn;
  writeln (f, start_page basename);
  writeln (f,"<H1>"+filename+"</H1>");
  writeln (mf,
    '<div class="toc_entry">' 
    (keywrd 'File ') '<A HREF="' basename '_flx.html">' filename '</A>'
    '</div>'
  );
  handle_statements (f, statements);
  writeln (f,"</HTML></BODY>");
  fclose f;
}

fun get_token(): flx_token_t = 
{
retry:>
  if i1 == i2 do
    if eof do 
      return TOK_EOF; 
    else
      eof = true; 
      return TOK_ENDMARKER;
    done;
  else
    t := get_pretoken();
    if caseno t == caseno TOK_EOF goto retry;
    return t;
  done;
}


fun start_page(title:string)=>
  '<html>' eol
  '<head>' eol
  '<meta http-equiv="Content-Type" content="text/html; charset="utf-8">' eol
  '<link rel="stylesheet" href="flxdoc_style.css" type="text/css">' eol
  '<title>' title '</title>' eol
  '</head>' eol
  '<body>' eol
;

fun dcl (name:string) =>
  '<span class="dcl">' name '</span>'
;

fun keywrd (kwd:string) =>
  '<span class="keyword">' kwd '</span>'
;


proc handle_statements (f:text_file, sts:statement_aster_t) 
{
  match sts with
  | statement_aster_1 (?s,?sts) =>
    {
      handle_statement (f,s,"");
      handle_statements (f,sts);
    }
    
  | statement_aster_2 => {}
  endmatch
  ;
}


proc handle_statement (f:text_file, s:statement_t,desc:string) {
  match s with
  | statement_1 ?s => 
    { 
      writeln(f,'<div class="topentry">');
      handle_binding_definition (f,s,desc); 
      writeln(f,'</div>');
     }
  | statement_2 ?s => 
    { 
      writeln(f,'<div class="topentry">');
      handle_declarative (f,s,desc); 
      writeln(f,'</div>');
    }
  | statement_3 ?s => {}
  | statement_4 ?s => 
    let inclusion_1 ?s = s in 
    { 
      writeln(f,'<div class="topentry">');
      writeln(f, keywrd "include "+ s); 
      writeln(f,'</div>');
    }


  | statement_5 ?s => { handle_directive (f,s); }
  | statement_6 ?s => { handle_publish (f,s); }
  | statement_7 ?s => 
    let comment_1 ?s = s in 
    { writeln(f,'<div class="comment">' s '</div>'); }

  | statement_8 ?s => {} // null
  endmatch;
}

proc handle_publish(f:text_file, p:publish_t)
{
  match p with
  | publish_1  (?desc,?bd) => 
    { 
      writeln(f,'<div class="topentry">');
      handle_binding_definition (f,bd,desc); 
      writeln(f,'</div>');
    }
  | publish_2 (?desc,?dcl) => 
    { 
      writeln(f,'<div class="topentry">');
      handle_declarative (f,dcl,desc); 
      writeln(f,'</div>');
    }
  | publish_3 ?dcl  => {} // private
  | publish_4 ?bd => {} // private
  endmatch;
}

proc print_description (f:text_file,desc:string)
{
  if desc != "" do
    writeln(f,'<div class="desc">' desc "</div>");
  done;
}

proc handle_directive (f:text_file, t:directive_t)
{
  match t with
  | directive_1 _ => {}
  | directive_2 _ => {}
  | directive_3 ?r => 
    { 
      writeln(f,'<div class="topentry">');
      handle_regdef (f,r); 
      writeln(f,'</div>');
   }
  | directive_4 ?g => 
    { 
      writeln(f,'<div class="topentry">');
      handle_glr_production (f,g); 
      writeln(f,'</div>');
    }
  | directive_5 ?m => {}
  endmatch;
}

proc handle_glr_production(f:text_file, t:glr_production_t)
{
  proc handle_glr_matching (g:glr_matching_t)
  {
    match g with
    | glr_matching_1 (?ges,_) =>
      {
        writeln(f,
          '<div class="subentry">' + 
          keywrd "| " +
          str ges +
          '</div>'
        ); 
      }
    | glr_matching_2 _ => 
      {
        writeln(f,
          '<div class="subentry">'
          (keywrd "| ")
          '<span class="desc">epsilon</span>'
          '</div>'
        ); 
      }
    endmatch;
  }

  proc handle_glr_matchings (t:glr_matchings_t)
  {
    match t with
    | glr_matchings_1 (?g,?gs) => 
      { 
        handle_glr_matching g; 
        handle_glr_matchings gs;
      }
    | glr_matchings_2 ?g => 
      {
        handle_glr_matching g; 
      }
    endmatch;
  }

  match t with
  | glr_production_1 (?nt, ?t,?ms) =>
    { 
      writeln (f,keywrd "nonterm "+ dcl nt+' : ' + str t+" = "); 
      handle_glr_matchings ms;
    }
  endmatch;
}

proc handle_regdef (f:text_file, t:regdef_t)
{
  match t with 
  | regdef_1 (?name,?re) => 
    { 
      writeln (f,keywrd "regexp "+ dcl name+' = ' + str re);
    }
  endmatch;
}

proc handle_binding_definition (f:text_file, s:binding_definition_t, desc:string)
{
  match s with
  | binding_definition_1 ?s => { handle_abstract_type (f,s); }
  | binding_definition_2 ?s => { handle_const_def (f,s); }
  | binding_definition_3 ?s => { handle_binding_header (f,s); }
  | binding_definition_4 ?s => { handle_export (f,s); }
  endmatch;
  print_description (f,desc);
}

proc handle_export (f:text_file, t:export_statement_t)
{
  match t with
  | export_statement_1 (?sn,?s) =>
    { writeln(f,keywrd "export fun " + str sn + " as " + dcl s); }

  | export_statement_2 (?sn,?s) =>
    { writeln(f,keywrd "export proc " + str sn + " as " + dcl s); }

  | export_statement_3 (?t,?s) =>
    { writeln(f,keywrd "export type " + "(" + str t + ") as " + dcl s); }
  endmatch;
}

proc handle_binding_header (f:text_file, t:binding_header_t)
{
  match t with
  | binding_header_1 (_,_) =>  {}
  | binding_header_2 (_,_) => {}
  | binding_header_3 (_,_) => {}
  | binding_header_4 (_,_) => {}
  | binding_header_5 (?name,?tvs,?h,_) =>
   { writeln(f,keywrd "header " + dcl name + str tvs); }

  | binding_header_6 (?name,?tvs,?b,_) =>
   { writeln(f,keywrd "body " + dcl name + str tvs); }

  | binding_header_7 _ => {}
  | binding_header_8 _ => {}
  endmatch;
}

proc handle_const_def (f:text_file, t:const_def_t)
{
  match t with
  | const_def_1 (?name,?tvs,?typ,?ct,_) =>
    { handle_const (f,name,tvs,typ); }
    
  | const_def_2 (?name,?tvs,?typ,_) =>
    { handle_const (f,name,tvs,typ); }
  endmatch;
}


proc handle_const (f:text_file, name:string, tvs:tvarlist_t, typ:type_expr_t)
{
  writeln(f,keywrd "const " + dcl name + str tvs + " : " + str typ);
}

proc handle_declarative (f:text_file, dcl:declarative_t, desc:string)
{
  match dcl with
  | declarative_1 ?fn => { handle_function_definition (f,fn); }
  | declarative_2 ?o => { print "object"; endl; }
  | declarative_3 ?p => { handle_procedure_definition (f,p); }
  | declarative_4 ?m => { handle_module (f,m,desc); }
  | declarative_5 ?u => { handle_union (f,u); }
  | declarative_6 ?s => { handle_struct (f,s); }
  | declarative_7 ?t => { handle_type_alias (f,t); }
  endmatch;
  print_description (f,desc);
}

proc handle_type_alias (f:text_file, t:type_alias_t)
{
  match t with
  | type_alias_1 (?name, ?tvs,?typ) =>
    { handle_typedef (f,name,tvs,typ); }
    
  | type_alias_2 (?name, ?tvs, ?args,?rt,?te) =>
    { handle_typefun (f,name,tvs,args,rt,te); }
    
  | type_alias_3 (?name, ?tvs, ?qn) => 
    { handle_rename(f,name,tvs,qn); }

  | type_alias_4 (?name,?tvs,?qn) =>
    { handle_fun_rename(f,name,tvs,qn); }

  | type_alias_5 ?qn => 
    { handle_inherit(f,qn); }
  
  endmatch;
}

proc handle_typedef (f:text_file, name:string, tvs:tvarlist_t,typ:type_expr_t)
{
  s := keywrd "typedef " + dcl name + str tvs + " = " + str typ;
  writeln(f,s);
}

// WARNING: hacked, the function value is expressed using 
// parameter names that aren't printed ..
proc handle_typefun (f:text_file, name:string, tvs:tvarlist_t, args:fun_args_t, rt:type_expr_t, typ:type_expr_t)
{
  s := keywrd "typedef fun " + dcl name + str tvs + str args + " : " + str rt + " = " + str typ;
  writeln(f,s);
}

proc handle_rename (f:text_file, name:string, tvs:tvarlist_t, qn:qualified_name_t)
{
  s := keywrd "rename " + dcl name + str tvs + " = " + str qn;
  writeln(f,s);
}

proc handle_fun_rename (f:text_file, name:string, tvs:tvarlist_t, qn:qualified_name_t)
{
  s := keywrd "rename fun " + dcl name + str tvs + " = " + str qn;
  writeln(f,s);
}

proc handle_inherit (f:text_file, qn:qualified_name_t)
{
  writeln(f,keywrd "inherit " + str qn);
}

proc handle_union (f:text_file, t:union_decl_t)
{
  match t with
  | union_decl_1 (?name,?es) => 
    {
      writeln(f,keywrd "enum " + dcl name);
      handle_enum_items (f,es);
    }
  | union_decl_2 (?name,?tvs,?sms) =>
    {
      writeln(f,keywrd "union " + dcl name+ str tvs);
      handle_sum_items(f,sms);
    }

  | union_decl_3 (?name,?tvs,?sms) =>
    {
      writeln(f,keywrd "union " + dcl name+str tvs);
      handle_sum_items(f,sms);
    }
  endmatch;
}

proc handle_struct (f:text_file, t:struct_decl_t)
{
  match t with
  | struct_decl_1 (?name,?tvs,?scs) =>
    {
      writeln(f,keywrd "struct " + dcl name+str tvs);
      handle_struct_items(f,scs);
    }

  | struct_decl_2 (?name,?tvs,?scs) =>
    {
      writeln(f,keywrd "struct " + dcl name+str tvs);
      handle_struct_items(f,scs);
    }

  | struct_decl_3 (?name,?scs) =>
    {
      writeln(f,keywrd "struct " + dcl name);
      handle_struct_items(f,scs);
    }
  endmatch;
}

proc handle_struct_items (f:text_file, t:struct_component_aster_t)
{
  match t with
  | struct_component_aster_1 (?e,?es) =>
    {
      handle_struct_item (f,e);
      handle_struct_items(f,es);
    }
  | struct_component_aster_2 => {}
  endmatch;
}

proc handle_struct_item (f:text_file, t:struct_component_t)
{
  match t with
  | struct_component_1 (?s,?t) =>
    {
      writeln(f,
        '<div class="subentry">' + 
        keywrd "var " + (dcl s)+" : "+str t +
        '</div>'
     );
    }
  endmatch;
}

proc handle_enum_items (f:text_file, t:enum_items_t)
{
  match t with
  | enum_items_1 (?es,?e) =>
    let enum_item_1 ?name = e in
    {
      handle_enum_items(f,es);
      writeln(f,
        '<div class="subentry">' + 
        keywrd "| " + (dcl name) +
        '</div>'
      );
    }
  | enum_items_2 ?e =>
    let enum_item_1 ?name = e in
    {
      writeln(f,
        '<div class="subentry">' + 
        keywrd "| " + (dcl name) +
        '</div>'
      );
    }
  endmatch;
}

proc handle_sum_items (f:text_file, t:type_sum_items_t)
{
  match t with
  | type_sum_items_1 (?es,?e) =>
    {
      handle_sum_items(f,es);
      handle_sum_item (f,e);
    }
  | type_sum_items_2 ?e =>
    {
      handle_sum_item (f,e);
    }
  endmatch;
}

proc handle_sum_item(f:text_file, t:type_sum_item_t)
{
  match t with
  | type_sum_item_1 (?name,?typ) =>
    {
      writeln(f,
        '<div class="subentry">' + 
        keywrd "| " + (dcl name)+" of " + str typ +
        '</div>'
      );
    }

  | type_sum_item_2 ?name =>
    {
      writeln(f,
        '<div class="subentry">' + 
        keywrd "| " + (dcl name) +
        '</div>'
      );
    }
  endmatch;
}

proc handle_function_definition (f:text_file, t:function_definition_t)
{
  match t with
  | function_definition_1 (?adjs,?name,?tvs,?args,?ote,_) =>
    { handle_felix_function (f,adjs,name,tvs,args,ote); }
    
  | function_definition_2 (?adjs,?name,?tvs,?args,?ote,_) =>
    { handle_felix_function (f,adjs,name,tvs,args,ote); }
   
  | function_definition_3 (?adjs,?name,?tvs,?t,_,_,_) =>
    { handle_primitive_function (f,adjs,name,tvs,t); }

  | function_definition_4 (?adjs,?name,?tvs,?t,_) =>
    { handle_primitive_function (f,adjs,name,tvs,t); }
  endmatch;
}

proc handle_procedure_definition (f:text_file, t:procedure_definition_t)
{
  match t with
  | procedure_definition_1 (?name, ?tvs,?oargs,_) =>
    let ?adjs = adjectives_2 in
    { handle_felix_procedure (f,adjs,name,tvs,oargs); }
    
  | procedure_definition_2 (?adj,?name,?tvs,_) =>
    let ?adjs = adjectives_1 (adj,adjectives_2) in
    let ?oargs = opt_fun_args_2 in
    { handle_felix_procedure (f,adjs,name,tvs,oargs); }

  | procedure_definition_3 (?name,?tvs,?t,_,_) => 
    { handle_primitive_procedure (f,name,tvs,t); }
    
  endmatch;
}

proc handle_felix_function 
(
  f:text_file,
  adjs:adjectives_t, 
  name:string,
  tvs:tvarlist_t,
  args:fun_args_t,
  ote:opt_type_expr_t
)
{
  s:= kfun (str adjs) (dcl name) (str tvs) " : " (str args) (str ote);
  writeln(f,s);
}

proc handle_felix_procedure
(
  f:text_file,
  adjs:adjectives_t, 
  name:string,
  tvs:tvarlist_t,
  oargs:opt_fun_args_t
)
{
  s:= kproc (str adjs) (dcl name) (str tvs) " : " (str oargs);
  writeln(f,s);
}

proc handle_primitive_function 
(
  f:text_file,
  adjs:adjectives_t, 
  name:string,
  tvs:tvarlist_t,
  t:type_expr_t
)
{
  s :=kfun (str adjs) (dcl name) (str tvs) " : " (str t);
  writeln(f,s);
}

proc handle_primitive_procedure
(
  f:text_file,
  name:string,
  tvs:tvarlist_t,
  t:type_expr_t
)
{
  s := kproc (dcl name) (str tvs) " : " (str t);
  writeln(f,s);
}

proc handle_module (f:text_file, m:module_definition_t, desc:string)
{
  (let module_definition_1 (?name, ?tvs,?sts) = m in
  let compound_1 ?sts = sts in
  {
    s:= keywrd "module"  " <A HREF=" name ".html>" name "</A>" (str tvs);
    writeln(f,s);
    g := fopen_output (outdir + '/'+name + ".html");
    writeln(g,start_page name);
    writeln(g,"<H1>Module " name (str tvs) "</H1>");
    print_description (g,desc);
    handle_statements (g,sts);
    writeln(g,"</HTML></BODY>");
    fclose g;
  });
}

proc handle_abstract_type (f:text_file, s: abstract_type_t)
{
  match s with
  | abstract_type_1 (?qs, ?bncl, ?rqs) => 
    { handle_ctypes (f,qs,bncl); }
  
  | abstract_type_2 (?qs, ?name, ?tvl, ?ct,?rqs) => 
    { handle_ctype (f,qs,name,tvl); }

  endmatch;
}

proc handle_ctypes (f:text_file, qs:type_quals_t, bncl: basic_name_comma_list_t)
{
  sqs := str qs;

  proc handle_inner_ctype (name:basic_name_t) 
  {
    s := sqs "  " kctype (dcl (str name));
    writeln(f,s);
  }

  proc handle_bncl(bncl: basic_name_comma_list_t)
  {
    match bncl with
    | basic_name_comma_list_1 (?name,?bncl') => 
      {
        handle_inner_ctype name;
        handle_bncl bncl';
      }
    | basic_name_comma_list_2 ?name =>
      {
        handle_inner_ctype name;
      }
    | basic_name_comma_list_3 => {}
    endmatch;
  }

  handle_bncl bncl;
}

proc handle_ctype (f:text_file, qs:type_quals_t,name:string,tvl:tvarlist_t) 
{
  sqs := str qs;
  s:= sqs " " ktype (dcl name) + (str tvl);
  writeln(f,s);
}

fun html(s:string):string =
{
  var s' = "";
  n := len s;
  var i =0; until i == n do
    ch := s.[i];
    if ch == '<'.[0] do s' += '&lt;';
    elif ch == '>'.[0] do s' += '&gt;';
    elif ch == '&'.[0] do s' += '&amp;';
    else s' += ch;
    done;
    ++i;
  done;
  return s';
}

//-----------------------------------------------
// strings representing small sub-terms
fun str : expr_t -> string =
  | expr_1 (?p,?e1,?e2) => "let <pattern> = " + str e1 " in " + str e2
  | expr_2 ?r => let rvalue_1 ?l = r in str l
;

fun str : lambda_t -> string =
  | lambda_1 ?t => str t
  | lambda_2 _ => "(fun ...)"
  | lambda_3 _ => "(fun ...)"
  | lambda_4 _ => "(fun ...)"
  | lambda_5 ?c => "{ ... }" 
;

fun str: dollar_apply_t -> string =
  | dollar_apply_1 (?a,?b) => (str a) " (" (str b) ")"
  | dollar_apply_2 ?x => str x
;

fun str : tuple_t -> string =
  | tuple_1 (?o,?t) => str o + str t
  | tuple_2 ?o => str o 
;

fun str : tuple_suffix_t -> string =
  | tuple_suffix_1 (?o,?t) => ", " + str o + str t
  | tuple_suffix_2 ?o => ", " + str o
;

fun str : or_condition_t -> string =
  | or_condition_1 (?s,?sl) => str s + " + " + str sl
  | or_condition_2 ?s => str s
;

fun str : or_list_t -> string =
  | or_list_1 (?s,?sl) => str s + " + " + str sl
  | or_list_2 ?s => str s
;

fun str : and_condition_t -> string =
  | and_condition_1 (?s,?sl) => str s + " + " + str sl
  | and_condition_2 ?s => str s
;

fun str : and_list_t -> string =
  | and_list_1 (?s,?sl) => str s + " + " + str sl
  | and_list_2 ?s => str s
;

fun str : not_condition_t -> string =
  | not_condition_1 (_,?a) => " not "+ str a
  | not_condition_2 ?a => str a 
;

fun str (t:comparison_t)=> 'comparison .. endcomparison';

fun str: opt_type_expr_t -> string =
  | opt_type_expr_1 (?t,?e) => " : " + str t + " expect " + str e
  | opt_type_expr_2 ?t => " : " + str t
  | opt_type_expr_3 ?e => " exprect " + str e
  | opt_type_expr_4 => ""
;

fun str (t: type_expr_t):string =>
  let type_expr_1 ?t = t in str t
;

fun str : arrow_t -> string =
  | arrow_1 (?cl,?a) => str cl + " &rarr; "+str a
  | arrow_2 ?cl => str cl
;

fun str : case_literal_t -> string =
  | case_literal_1 ?i => "case " + strint i
  | case_literal_2 (?i,?s) => "case " + strint i + str s
  | case_literal_3 ?s => str s
;

fun str : sum_t -> string =
  | sum_1 (?s,?sl) => str s + " + " + str sl
  | sum_2 ?s => str s
;

fun str : sum_list_t -> string =
  | sum_list_1 (?s,?sl) => str s + " + " + str sl
  | sum_list_2 ?s => str s
;

fun str: subtraction_t -> string =
  | subtraction_1 (?s,?p) => str s + " - " + str p
  | subtraction_2 ?p => str p
;

fun str : product_t -> string =
  | product_1 (?s,?sl) => str s + " * " + str sl
  | product_2 ?s => str s
;

fun str : product_list_t -> string =
  | product_list_1 (?s,?sl) => str s + " * " + str sl
  | product_list_2 ?s => str s
;

fun str : term_t -> string =
  | term_1 (?t,?p) => str t + " / " + str p
  | term_2 (?t,?p) => str t + " % " + str p
  | term_3 ?pr => str pr
;

fun str : power_t -> string =
  | power_1( ?ss, ?pr) => str ss + " ** " + str pr
  | power_2 ?ss => str ss 
;

fun str : prefixed_t -> string =
  | prefixed_1 ?p => "lvalue[" + str p + "]"
  | prefixed_2 ?p => "+"+str p
  | prefixed_3 ?p => "-"+str p
  | prefixed_4 ?p => "~"+str p
  | prefixed_5 ?p => str p
;

fun str : superscript_t -> string =
  | superscript_1 (?s,?r) => str s + " ^ " + str r
  | superscript_2 ?r => str r
;

fun str : refr_t -> string =
  | refr_1 ?r => "&" + str r
  | refr_2 ?r => "*" + str r
  | refr_3 ?a => str a
;

fun str : application_t -> string =
  | application_1 (?a,?c) => str a + " " + str c
  | application_2 ?c => "caseno " + str c
  | application_3 ?c => str c
;

fun str : coercion_t -> string =
  | coercion_1 (?c,?f) => str c + " : " + str f
  | coercion_2 ?sn => str sn 
  | coercion_3 ?f => str f
;


fun str : factor_t -> string =
  | factor_1 ?dn => str dn
  | factor_2 (?f,?e) => str f + ".["+str e+"]"
  | factor_3 (?f,?e1,?e2) => str f + ".["+str e1+" to "+str e2+"]"
  | factor_4 (?f,?e) => str f + ".["+str e+" to]"
  | factor_5 (?f,?e) =>str f + ".[to "+str e+"]"
  | factor_6 (?f,?s) => str f + "." + str s
  | factor_7 (?f,(?s1,?s2)) => str f ".(" + s1+s2+")"
;

fun str : dollar_name_t -> string =
  | dollar_name_1 ?qn => "$" + str qn
  | dollar_name_2 ?qn => "the " + str qn
  | dollar_name_3 ?qn => str qn
  | dollar_name_4 ?atom => str atom
;

fun str: qualified_name_t -> string =
  | qualified_name_1 (?qn,?snp) => str qn + "::" + str snp
  | qualified_name_2 ?snp => str snp
;

fun str : simple_name_parts_t -> string =
  | simple_name_parts_1 (?s,?ts) => s + "[" + str ts + "]"
  | simple_name_parts_2 ?s => s
;

/*
fun str : type_expr_comma_list_t -> string =
  | type_expr_comma_list_1 (?t,?ts) => str t + ", " + str ts
  | type_expr_comma_list_2 ?t => str t
  | type_expr_comma_list_3 => ""
;
*/

fun str : suffixed_name_t -> string =
  | suffixed_name_1 (?qn,?t) => str qn + " of (" + str t + ")"
;

fun str : atom_t -> string =
  | atom_1 => "..."
  | atom_2 _ => "typematch .. endmatch"
  | atom_3 (?e,?s) => "code["+str e + "] "+s
  | atom_4 (?e,?s) => "code["+str e + "] "+str s
  | atom_5 ?e => "["+str e+"]"
  | atom_6 ?e => "{"+str e+"]"
  | atom_7 _ => "parse .. endmatch"
  | atom_8 _ => "match .. endmatch"
  | atom_9 _ => "regmatch .. endmatch"
  | atom_10 _ => "{ ... }"
  | atom_11 ?e => "("+str e+")"
  | atom_12 => "()"
  | atom_13 ?e => str e
  | atom_14 _ => "if .. endif"
;

fun str (t:expr_code_prefix_t):string =>
  let expr_code_prefix_1 ?e = t in str e
;

fun str : literal_t -> string =
  | literal_1 (?s1,?s2) => s1 + s2
  | literal_2 ?s => s
  | literal_3 ?s => str s
  | literal_4 ?s => "c"+str s
;

fun str (s:string):string => '"' + s '"'; // hacky .. fix

fun strint(i:string * string):string =>
  let ?i,?j = i in i+j
;

fun str: opt_fun_args_t -> string =
  | opt_fun_args_1 ?a => str a
  | opt_fun_args_2 => "()"
;
  
fun str: fun_args_t -> string =
  | fun_args_1 (?a,?args) => "(" (str a)  ") &rarr; " + str args
  | fun_args_2 ?a =>  str a 
;

fun str: fun_arg_t -> string =
  | fun_arg_1 (?ps,?traint) => str ps + " when " + str traint
  | fun_arg_2 ?ps => str ps
  | fun_arg_3 ?s => s
;

fun str: parameter_comma_list_t -> string =
  | parameter_comma_list_1 (?a,?ps) => str a + " * " + str ps
  | parameter_comma_list_2 ?p => str p
  | parameter_comma_list_3 => ""
;

fun str: parameter_t -> string =
  | parameter_1 (?name,?t) => str t
  | parameter_2 ?name => "'" + name
  | parameter_3 (?name,?t) => "var " + str t
  | parameter_4 ?name => "var " + "'" + name
;

fun str: type_qual_t -> string =
  | type_qual_1 => "incomplete "
  | type_qual_2 => "pod "
;

fun str: type_quals_t -> string =
  | type_quals_1 (?q,?qs') => str q + str qs'
  | type_quals_2 => ""
;

fun str (name:basic_name_t): string =>
  let basic_name_1 ?name = name in name
;

fun str :  basic_name_comma_list_t -> string =
  | basic_name_comma_list_1 (?name,?bncl) => 
        str name + ", " + str bncl
  | basic_name_comma_list_2 ?name => str name
  | basic_name_comma_list_3 => ""
;

fun str : tvar_t -> string =
  | tvar_1 ?s => s
  | tvar_2 (?s,_) => s
;

fun str :  tvar_comma_list_t -> string =
  | tvar_comma_list_1 (?name,?bncl) => 
        str name + ", " + str bncl
  | tvar_comma_list_2 ?name => str name
  | tvar_comma_list_3 => ""
;

fun str : tvarlist_t -> string = 
  | tvarlist_1 ?bncl => "[" + str bncl + "]"
  | tvarlist_2 => ""
;

fun str : adjectives_t -> string =
  | adjectives_1 (?adj,?adjs) => str adj + str adjs
  | adjectives_2 => ""
;

fun str : adjective_t -> string =
  | adjective_1 => "inline "
  | adjective_2 => "noinline "
;

// regexps
fun str : re1_t -> string = // alternatives
  | re1_1 (?r1,?r2) => str r1 + " | " + str r2
  | re1_2 ?r => str r
;

fun str : re2_t -> string = // concatenation
  | re2_1 (?r1,?r2) => str r1 + " " + str r2
  | re2_2 ?r => str r
;

fun str : re3_t -> string = // postfix
  | re3_1 ?r => str r + "*"
  | re3_2 ?r => str r + "+"
  | re3_3 ?r => str r + "?"
  | re3_4 ?r => str r
;

fun str : re4_t -> string =  // regexp atom
  | re4_1 ?s => str s
  | re4_2 => '_'
  | re4_3 => '.'
  | re4_4 ?r => '(' + str r + ")"
  | re4_5 ?cs => '[' + str cs + ']'
  | re4_6 ?cs => '[^' + str cs + ']'
  | re4_7 ?name => str name
;

fun str : re_name_t -> string =
  | re_name_1 (?r,?s) => str r + "::" + str s
  | re_name_2 ?s => s
;

fun str: charset_t -> string =
  | charset_1 (?cs,?cs0) => str cs + " " + str cs0
  | charset_2 ?cs0 => str cs0
;

fun str: charset0_t -> string =
  | charset0_1 (?i1,?i2) => strint i1 + " - " + strint i2
  | charset0_2 (?s1,?s2) => str s1 + " - " + str s2
  | charset0_3 ?s => str s
  | charset0_4 ?i => strint i
;

fun str: glr_entries_t -> string =
  | glr_entries_1 (?g,?gs) => str g + " " + str gs
  | glr_entries_2 ?g => str g
;

fun str: glr_entry_t -> string =
  | glr_entry_1 (?name,?nt) => name + " : " + str nt
  | glr_entry_2 ?qn => str qn
;

fun str: glr_term_t -> string =
  | glr_term_1 ?qn => str qn
  | glr_term_2 ?alts => "(" + "..." + "}"
  | glr_term_3 ?seq => "(" + "..." + ")"
  | glr_term_4 ?quest => "(" + str quest+ ")?"
  | glr_term_5 ?star => "(" + str star + ")*"
  | glr_term_6 ?plus => "(" + str plus + ")+"
;

