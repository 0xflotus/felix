@head(1,'Sql lite')

@select(tangler("cpkgs/target/sqlite3.py"))
try:
  from config.target_sqlite3_config import *
except ImportError:
  import config
  from flxbuild.config_support import cwrite, pa
  HAVE_SQLITE3 = config.TARGET_CXX.check_header_exists('sqlite3.h')
  f=cwrite('target_sqlite3')
  pa(f,locals(),"HAVE_SQLITE3")
  f.close()

@h = tangler('spkgs/sqlite3.py')
@select(h)
import config
from cpkgs.target.sqlite3 import HAVE_SQLITE3

if HAVE_SQLITE3:
  root = config.FLX_DIR
  unit_tests = [('test', 'sqlite', 'sqlite-*.flx')]

iscr_source = ['lpsrc/flx_sqlite.pak']
weaver_directory = 'doc/sqlite/'

@h = tangler('config/sqlite3.fpc')
@select(h)
provides_dlib: -lsqlite3
provides_slib: -lsqlite3

@h = tangler('lib/flx_sqlite3.flx','data')
@select(h)
open C_hack;

module Sqlite3 {
  header "#include <sqlite3.h>";
  requires package "sqlite3";
  type sqlite3_db_t = "sqlite3*";
  gen sqlite3_open : string * &sqlite3_db_t -> int =
    "sqlite3_open($1.data(), $2)"
  ;
  proc sqlite3_close : sqlite3_db_t = "sqlite3_close($1);";
  typedef sqlite3_exec_callback_t = address * int * ptr[charp] * ptr[charp] --> int;
  gen sqlite3_exec :
    sqlite3_db_t * string * sqlite3_exec_callback_t * address * &charp -> int =
    "sqlite3_exec($1,$2.data(),$3,$4,$5)"
  ;

  gen sqlite3_errmsg : sqlite3_db_t -> charcp =
    "sqlite3_errmsg($1)"
  ;
}

syntax sql { // see: http://www.sqlite.org/lang.html
  // core
  table_name := sname =># "_1";
  database_name := sname =># "_1";
  index_name := sname =># "_1";

  database_filename : string = strstring;
  filename : string = strstring;
  delim : string = strstring; // ??

  sql_statement : string = "alter" "table" (sql_database_name . )? table_name alteration;
  alteration : string = "rename" "to" table_name;
  alteration : string = "add" "column"? column_def;

  sql_statement :string = "analyse" ((database_name .)? table_name)?;

  sql_statement : string = "attach" "database"? database_filename "as" database_name;
  sql_statement : string = "begin"
    ("deferred" | "immediate" | "exclusive" | "transaction" sname?)?;

  sql_statement : string = "end" ("transaction" sname?)?;
  sql_statement : string = "commit" ("transaction" sname?)?;
  sql_statement : string = "rollback" ("transaction" sname?)?;

  sql_statement : string = "copy" ("or" conflict_algorithm)? (database_name .)? table_name
    "from" filename ("using" "delimiters" delim);

  sql_statement : string = "create" "unique"? "index" ("if" "not" "exists")?
    (database_name .)? index_name "on" table_name lpar column_name (, column_name)* rpar;
  column_name := sname ("collate" collation_name) ("asc" | "desc")?;

  sql_command : string = 	
    "create" ("temp" | "temporary")? table
      ("if" "not" "exists")? (database_name .)? table_name
      lpar column_def (, column_def)* (, constraint)?* rpar
  ;
  sql_command : string = "create" ("temp" | "temporary")? "table" (database_name .)? table_name "as" select_statement
  column_def : string =	sname sql_type? (constraint name? column_constraint)*
  sql_type : string = 	typename |
    typename lpar number rpar |
    typename lpar number , number rpar
  ;
  column_constraint : string =
    "not" "null" conflict_clause? |
    "primary" "key" sort_order? conflict_clause? "autoincrement"? |
    "unique" conflict_clause? |
    "check" lpar expr rpar |
    "default" value |
    "collate" collation_name
  ;
  constraint : string = "primary" "key" lpar column_list rpar conflict_clause? |
    "unique" lpar column_list rpar conflict_clause? |
    "check" lpar expr rpar
  ;
  conflict_clause : string = "on" "conflict" conflict_algorithm;
}
@doc()
