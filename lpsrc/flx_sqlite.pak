@from flxbuild.iscrutil import setup_test
@from flxbuild.flxutil import unix2native

@env = setup_test(get_input_frame(), 'test/sqlite/sqlite-')

@head(1,'Sql lite')

@select(tangler("cpkgs/target/sqlite3.py"))
import config
from flxbuild.config_support import cwrite, cload, pa
try:
  cload(globals(),"target_sqlite3")
except:
  HAVE_SQLITE3 = config.TARGET_CXX.check_header_exists('sqlite3.h')
  f=cwrite('target_sqlite3')
  pa(f,locals(),"HAVE_SQLITE3")
  f.close()
  cload(globals(),"target_sqlite3")

@h = tangler('spkgs/sqlite3.py')
@select(h)
from cpkgs.target.sqlite3 import HAVE_SQLITE3
if HAVE_SQLITE3:
@tangle('  unit_tests = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')

iscr_source = ['lpsrc/flx_sqlite.pak']
weaver_directory = 'doc/sqlite/'

@h = tangler('config/sqlite3.fpc')
@select(h)
provides_dlib: -lsqlite3
provides_slib: -lsqlite3

@h = tangler('lib/flx_sqlite3.flx','data')
@select(h)
#import <flx.flxh>
open C_hack;

module Sqlite3 {
  header "#include <sqlite3.h>";
  requires package "sqlite3";
  type sqlite3_db_t = "sqlite3*";
  gen sqlite3_open : string * &sqlite3_db_t -> int =
    "sqlite3_open($1.data(), $2)"
  ;
  proc sqlite3_close : sqlite3_db_t = "sqlite3_close($1);";
  typedef sqlite3_exec_callback_t = address * int * ptr[charp] * ptr[charp] --> int;
  gen sqlite3_exec :
    sqlite3_db_t * string * sqlite3_exec_callback_t * address * &charp -> int =
    "sqlite3_exec($1,$2.data(),$3,$4,$5)"
  ;

  gen sqlite3_errmsg : sqlite3_db_t -> charcp =
    "sqlite3_errmsg($1)"
  ;
}

syntax sql { // see: http://www.sqlite.org/lang.html
  // core
  table_name := sname =># "_1";
  database_name := sname =># "_1";
  index_name := sname =># "_1";

  database_filename : string = strstring;
  filename : string = strstring;
  delim : string = strstring; // ??

  sql_statement : string = "alter" "table" (sql_database_name . )? table_name alteration;
  alteration : string = "rename" "to" table_name;
  alteration : string = "add" "column"? column_def;

  sql_statement :string = "analyse" ((database_name .)? table_name)?;

  sql_statement : string = "attach" "database"? database_filename "as" database_name;
  sql_statement : string = "begin"
    ("deferred" | "immediate" | "exclusive" | "transaction" sname?)?;

  sql_statement : string = "end" ("transaction" sname?)?;
  sql_statement : string = "commit" ("transaction" sname?)?;
  sql_statement : string = "rollback" ("transaction" sname?)?;

  sql_statement : string = "copy" ("or" conflict_algorithm)? (database_name .)? table_name
    "from" filename ("using" "delimiters" delim);

  sql_statement : string = "create" "unique"? "index" ("if" "not" "exists")?
    (database_name .)? index_name "on" table_name lpar column_name (, column_name)* rpar;
  column_name := sname ("collate" collation_name) ("asc" | "desc")?;

  sql_command : string = 	
    "create" ("temp" | "temporary")? table
      ("if" "not" "exists")? (database_name .)? table_name
      lpar column_def (, column_def)* (, constraint)?* rpar
  ;
  sql_command : string = "create" ("temp" | "temporary")? "table" (database_name .)? table_name "as" select_statement
  column_def : string =	sname sql_type? (constraint name? column_constraint)*
  sql_type : string = 	typename |
    typename lpar number rpar |
    typename lpar number , number rpar
  ;
  column_constraint : string =
    "not" "null" conflict_clause? |
    "primary" "key" sort_order? conflict_clause? "autoincrement"? |
    "unique" conflict_clause? |
    "check" lpar expr rpar |
    "default" value |
    "collate" collation_name
  ;
  constraint : string = "primary" "key" lpar column_list rpar conflict_clause? |
    "unique" lpar column_list rpar conflict_clause? |
    "check" lpar expr rpar
  ;
  conflict_clause : string = "on" "conflict" conflict_algorithm;
}

@doc()

@env.head(1,'sqlite tests')
@select(env.test('.flx'))
#import <flx.flxh>
include "flx_sqlite3";
open Sqlite3;

fun subscript: & &char * int -> &char = "$1[$2]";

cfun eh(void *data, int ncols, char * *values, char* *names):int =
{
  int ii = 0;
  whilst ii<ncols do
    print$ str names.[ii] + "=" + str values.[ii];
    if ii<ncols-1 do print ", ";  done;
    ++ii;
  done;
  println "";
  return 0;
}

void run(struct sqlite3_db_t db) {
  sql :=
    "drop table if exists fred;",
    "create table fred (name, address);",
    "insert into fred values('joe','wigram');",
    "insert into fred values('max','gpr');",
    "insert into fred values('lee','wax');",
    "insert into fred values('henry','pollen');",
    "select all name,address from fred;",
    ""
  ;
  char *usr = c"user pointer";
  char *errm = c"";

  var i = 0;
  var p = sql.[i];
  whilst p != "" do
    println p;
    val cb : sqlite3_exec_callback_t = the eh;
    res := sqlite3_exec(db,p,cb,cast[address] usr,&errm);
    if res !=0 do
      println$ "exec DB error[abort]: " + errm;
      return;
    done;
    ++i;
    p = sql.[i];
  done;
}

println "Hello";
var db : sqlite3_db_t;
err := sqlite3_open("mydb.db", &db);
if err != 0 do
  print "open DB error[abort] ";
  println $ sqlite3_errmsg db;
  goto finish;
done;

run(db);

finish:>
  sqlite3_close(db);

@doc()

@select(env.expect())
Hello
drop table if exists fred;
create table fred (name, address);
insert into fred values('joe','wigram');
insert into fred values('max','gpr');
insert into fred values('lee','wax');
insert into fred values('henry','pollen');
select all name,address from fred;
name=joe, address=wigram
name=max, address=gpr
name=lee, address=wax
name=henry, address=pollen
@doc()
