@set_title('Felix Tutorial: Macros')

@from iscrutil import setup_test

@env = setup_test(get_input_frame(), 'tut/macros/mac-')

@select(tangler('spkgs/flx_tut_macro.py'))
import glob

@tangle('TESTS = glob.glob("%s*.flx")' % env.native_root)

unit_tests = TESTS
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','faio']
iscr_source = [ 'lpsrc/flx_tut_macro.pak' ]
weaver_directory = 'doc/tutorial/macros/'

@env.head(1,'The Syntax Macro Processor')
@env.head(2,'Expression Macro Facility')
Felix provides an powerful and dangerous
expression macro facility. Felix macros
generally respect scope, so any definitions
nested in a function or module, for example,
will not be visible outside that scope.
@p()
Expresion symbols only expand inside expressions.

@env.head(3,'Macro values')
The macro val statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.

@select(env.test('.flx'))
macro val mx1 = 1+y;
macro val mx2 = 2+y;
val y = 100;
print mx1; endl; // 101
print mx2; endl; // 102
{
  macro val mx1 = 3+y; // 103
  print mx1; endl;
  macro val mx2 = mx2 + 10; // 112
};
print mx1; endl; // 101
print mx2; endl; // 102

// illustration of rescanning
macro val r1 = y1;
macro val r2 = y2;
macro val y1 = print;
macro val y2 = 1;

r1 r2; // print 1
endl;
@doc()

@select(env.expect())
101
102
103
101
102
1
@doc()

@env.head(3,'Macro variables')
The macro var statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.
@p()
Macro variables can be assigned a new value.

@select(env.test('.flx'))
macro var mx1 = 1+y;
val y = 100;
print mx1; endl; // 101
{
  macro mx1 = 3+y; // 103 [assignment!]
  print mx1; endl;
};
print mx1; endl; // 103 [uses assigned value]
@doc()

@select(env.expect())
101
103
103
@doc()

@env.head(3,'Macro variables in requirements')
Named requirements in requirements clauses are
macro expanded as expressions: they must be qualified
names though.

@select(env.test('.flx'))
header fred = "inline int f(int x){return x;}";
macro val joe = fred;
fun f: int -> int = "f($1)" requires joe;

print$ f 2; endl;
@doc()

@select(env.expect())
2
@doc()

@env.head(3,'Macro functions')
You can also define a macro function.
The expansion rules are: the body
is not expanded during definition.
At the point of call, the arguments
are expanded and then substituted into
the body, then the body is expanded.
@p()
WARNING: macro function definitions need a semi-colon
at the end. This is because the RHS is universally
treated as an expression.

@select(env.test('.flx'))
// a basic expression macro without parameters
macro fun x() =  {print 1; endl;};
x;

// an expression macro with one argument
macro fun h(z) = z + z;
print (h 1); endl;

// an expression macro denoting a procedure
macro fun f(a) = { print a; endl; };
f 1;
f 2;

// nastier example of rescanning
macro fun a() = b c;
macro fun b(x) = f;
a() 1;
// (b c) 1;
// f 1;
// { print 1; endl; };
// call {print 1; endl; } ();

// finally: recursion
macro fun j(i) =
   if(i>0) then i + j(i-1)
   else 0 endif;
print  (j 5); // 5 + 4 + 3 + 2 + 1 = 16
endl;

val q=1;
macro fun z(q) = q;
print (z q); endl;
@doc()

@select(env.expect())
1
2
1
2
1
15
1
@doc()

It is vital to understand that macros cannot break
syntactically established precedence rules.
In the last example, a 1 expands to (b c) 1,
which expands to f 1. Substitutions are implemented
by manipulation of the abstract syntax tree (AST),
not token pasting or string manipulation.

@env.head(2,'Constant Expression Folding')
The Felix macro processor also performs constant folding;
that is, evaluation of certain expressions involving
only literals. The following operations are folded:
@begin_table("op","descr")
@table_row('+int','')
@table_row('-int','')
@table_row('int+int','')
@table_row('int-int','')
@table_row('int*int','')
@table_row('int/int','')
@table_row('int%int','')
@table_row('int<int','')
@table_row('int>int','')
@table_row('int<=int','')
@table_row('int>=int','')
@table_row('int==int','')
@table_row('int!=int','')
@table_row('string+string','')
@table_row('string==string','')
@table_row('string!=string','')
@table_row('string*int','cat n copies')
@table_row('string string','cat')
@table_row('string int','cat ISO10646')
@table_row('not bool','')
@table_row('bool && bool','')
@table_row('bool or bool','')
@table_row('bool == bool','')
@table_row('bool != bool','')
@table_row('if bool then expr1 else expr2 endif','')
@end_table()
@p()
The critical operation here is that a conditional
with a constant first argument is replaced by one
of the two expressions, and the other is elided.
See the example for an application: the implication
is that the elided expression, whilst it must be
well formed syntactically, does not need to be
type correct, nor do symbols in it need to be defined.
@p()
Note that the fold uses compiler intrinsic operations
on integers, bools, and strings: user defined functions
are not applied and do not need to be defined.
Consequently, the result may disagree with a user
defined function applied at run time.  If necessary,
constant folding can be blocked with the noexpand mark 'noexpand'.
@p()
Note: the expressions
@begin_displayed_code()
  "" 999
  u"" 999
@end_displayed_code()
are semantically, but not physically equivalent.
The first operation is the UTF-8 representation
of 999, whilst the second is the UCS-32 value 999.

@select(env.test('.flx'))
header '''
#define flx_unix 0
#define flx_windows 0
#define testhook 1
#if flx_unix
#include <dlopen.h>
#elif flx_windows
#include <windows.h>
#else
#include <stdio.h>
#endif
''';
macro val Unix = case 0 of 2;
macro val Windows = case 0 of 2;

fun dlopen:string -> address = 'dlopen($1.data())';
fun LoadLibrary:string -> int = 'LoadLibrary($.data())';
fun testhook:string -> int = 'printf("LoadTheLibrary(%s)\\n",$1.data())';

macro val openlib =
  if Unix then dlopen
  elif Windows then LoadLibrary
  else testhook endif
;

macro val ext =
  if Unix then ".so"
  elif Windows then ".DLL"
  else ".lib_ext" endif
;
// conditional compilation
C_hack::ignore(openlib ("MyLibrary" ext));
@doc()

@select(env.expect())
LoadTheLibrary(MyLibrary.lib_ext)
@doc()

@env.head(2,'Procedure Macros')
A procedure macro represents a list of statements.
Macros defined in macro procedures are exported
to the surrounding scope so that macro procedures
can be used to package up a set of macro definitions.
This represents a special exception to the rule
that macros respect scope.

@select(env.test('.flx'))
// procedure macro
macro proc k ()
{
  val yy = xx * xx;
  print xx; print " -> "; print yy; endl;
}

{
  val xx = 1;
  k();
};
{
  val xx = 2;
  k();
};

macro proc pkg (x)
{
  macro proc printxy (y) { print (x+y); endl; }
  macro val doublex = x + x;
}

pkg 10;
printxy doublex; // prints 30

macro proc dump_s (sts:proc)
{
  print "Start dump_s"; endl;
  sts;
  print "End dump_s"; endl;
}

macro proc dump_e (sts:fun)
{
  print "Start dump_e"; endl;
  sts;
  print "End dump_e"; endl;
}

dump_s { print 1; endl; print 2; endl; };
dump_e { val x = 1; print x; endl; print 2; endl; };

macro proc todump () { print "Dumped"; endl; }
dump_s todump;
dump_e todump;

macro proc todump_wa (x) { print x; endl; }
dump_s (todump_wa 66);
dump_e (todump_wa 66);
@doc()

@select(env.expect())
1 -> 1
2 -> 4
30
Start dump_s
1
2
End dump_s
Start dump_e
1
2
End dump_e
Start dump_s
Dumped
End dump_s
Start dump_e
Dumped
End dump_e
Start dump_s
66
End dump_s
Start dump_e
66
End dump_e
@doc()

Note there is a crucial difference between procedure
and expressions macros. In the above example,
dump requires a proc argument. When the parameter
is expanded, the list of statements it represented
is produced. Had this been a function macro,
the result would have been an the call executable lambda
expression applied to unit argument. The difference
is in the handling of any variable declarations:
they'd be exposed in the first case, but not the second.

@env.head(2,'Advanced Procedure Macro Programming')
Felix procedure macros also contain rudimentary
control structures: you can encode labels, unconditional
jumps, conditional jumps, and returns. Note the conditional
goto requires the condition resolve to a constant expression.
Of course, the value can change with time, since it can
depend on macro variables.
@p()
This example also illustrates the macro block, which is
an anonymous procedure, called after definition. The effect
is similar to the statements in the block, except that
locally defined symbols are not exported. The construction
is regularly required by the syntax extension facility,
to prevent name conflicts when the same construction
is expanded more than once, particularly cases where
a macro expansion has as its argument another expansion
of itself.

@select(env.test('.flx'))
macro proc print_alot ()
{
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
}

print_alot();

macro {
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
};

// note the 'start' macro label is local so there
// is no clash repeating a block.

macro {
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
};
@doc()

@select(env.expect())
@tangle('10 9 8 7 6 5 4 3 2 1 ')
@tangle('10 9 8 7 6 5 4 3 2 1 ')
@tangle('10 9 8 7 6 5 4 3 2 1 ')
@doc()

@env.head(2,'Expansion Barrier')
The symbol 'noexpand' can be used to block expansion.

@select(env.test('.flx'))
// expansion barrier
macro val x = 1;
macro proc k ()
{
  val yy = noexpand x + x; // x + 1
  print noexpand x; print "+"; print x; print " -> "; print yy; endl;
}
macro x is x; // blocks x
{
  val x = 2;
  k();
};
@doc()

@select(env.expect())
2+2 -> 4
@doc()

@env.head(2,'Identifier Macros')
A identifier macros represent names. They replace names
in expressions and most declarations, including the
name of a function or variable being defined.
Names are not replaced in type expressions, patterns,
or regular expressions.
@p()
The special form in which the RHS name is called 'new'
creates a fresh, previously unused name.
@p()
Unlike other macros, the RHS name of an ident macro
is not expanded at the point of definition.
@p()
On use, the value of an ident macro is the first
name in the chain which is not an ident macro,
or which recurs.

@select(env.test('.flx'))
macro oldname is newname;
fun oldname(x:int):int = { return x; }
print (newname 1); endl;

macro proc make_ints ()
{
  macro vnew is new;
  val vnew = vold+1;
  macro vold = vnew;
}

val x = 1;

macro var vold = x;
make_ints;
make_ints;
make_ints;
print vold; endl;
@doc()

@select(env.expect())
1
4
@doc()

@env.head(3,'Forgetting Macros')
You can forget macros defined in the current scope with
the forget statement. If no arguments are given,
all macros defined in the current scope are forgotten.

@select(env.test('.flx'))
macro val hello = "Hello";
macro val place = "world";
macro fun greet() = hello " " place "!\n";
{
  macro val hello = "Hi there";
  macro val place = "locality";
  print (greet());
  macro forget place;
  print (greet());
  macro forget;
  print (greet());
};

print (greet());
@doc()

@select(env.expect())
Hi there locality!
Hi there world!
Hello world!
Hello world!
@doc()

@env.head(3,'For Loops')
Felix provides two for loops which iterate over tuples.

@select(env.test('.flx'))
macro for val i in ("Hello","World",42) do
  print i; print " ";
done;
endl;

macro for i in (a,b,c) do
  var i = 1;
  print$ Debug::repr_expr i; print "="; print i; endl;
done;
@doc()

@select(env.expect())
@tangle('Hello World 42 ')
PTF a:int=1
PTF b:int=1
PTF c:int=1
@doc()

@env.head(3,"Unpacking Tuples")
Tuples can be unpacked by macro assignment,
macro val, macro var, and macro for val statements.

@select(env.test('.flx'))
macro val x,y = 1,2;
macro var a,b = 1,2;
macro a,b = a+1,b+1;
macro for val i in x,y,a,b do print i; print " "; done; endl;

macro for val i,j in ((1,2),(3,4)) do
  print "("; print i; print ","; print j; print ")"; print " ";
done;
endl;
@doc()

@select(env.expect())
@tangle('1 2 2 3 ')
@tangle('(1,2) (3,4) ')
@doc()

@env.head(3,"String representation")
The string representation of an expression can be obtained
with the special operator _str. This is most useful for
printing a variable name (but it works for any expression).
Note the expanded value is stringized.

@select(env.test('.flx'))
var x = 1;
var y = 42;
print (_str x); print " = "; print x; endl;
print (_str y); print " = "; print y; endl;
print (_str$ x+y); print " = "; print$ x+y; endl;
@doc()

@select(env.expect())
x = 1
y = 42
(add (x, y)) = 43
@doc()

@env.head(3,"Packing Tuples")
The Felix syntax macro processor treats tuples as lists.
The for val construction can be used to iterate over
list contents. Two primitive macro functions are provided
for constructing tuples.
@p()
The _tuple function takes one argument and makes a
one element tuple. Note that the main Felix programming
language does not allow one element tuples. The macro
processor does though.
@p()
The _tuple_cons function takes two arguments, an element
and a tuple, and constructs a single tuple starting
with the first argument followed by the elements of the
second argument: this is the usual list cons function of
functional programming languages.
@p()
These two functions are most useful in recursive
expansions, particularly when driven by user defined
nontermial parses (see the next section).

@select(env.test('.flx'))
macro var x = _tuple 1;
macro x = _tuple_cons (2,x);
macro x = _tuple_cons (3,x);
macro for val i in x do print i; print " "; done; endl;
@doc()

@select(env.expect())
@tangle('3 2 1 ')
@doc()

