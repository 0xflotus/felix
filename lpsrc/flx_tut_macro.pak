@set_title('Felix Tutorial: Macros')

@execfile("flxbuild"+os.sep+"iscrutil.py")
@env = setup_test(os.path.join('tut', 'macros', 'mac-'))

@select(tangler('spkgs/flx_tut_macro.py'))
@tangle('TESTS = glob.glob("'+env.root+'*.flx")')

unit_tests = TESTS
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','faio']
iscr_source = [ 'lpsrc/flx_tut_macro.pak' ]
weaver_directory = 'doc/tutorial/macros/'

@env.head(1,'The PreProcessor')
Felix provides a C like pre-processor. Note that 
whilst it is C like in appearance, it isn't the same.
Preprocessor directives start with a # in column 1,
followed by a keyword denoting the directive.
@p()
The syntax and semantics of directives are 
described below.

@env.head(2,'Include directive')
The #include directive takes the same
form as the corresponding C preprocessor
directive.
@p()
The file names used in include directives
MUST be Unix style relative file names, no matter
what operating system is hosting the compilation.
@p()
[To be done: should require URL format]
@p()
Relative file names inside angle brackets <>
are searched for in the include path passed
to the compiler on the command line.
@p()
Relative file names in double quotes are searched
for first in the directory containing the
file which contains the include directive,
then in the include path passed to the
compiler on the command line.
@p()
Absolute file names are NOT permitted. Files relative
to the current directory are NOT permitted.
In both cases the reason is to enhance the prospects
for portability.
@p()
The C form #include MACRO is not accepted.
@p()
Note the notion path searching will be replaced
by a more powerful technique allowing shadowed
directories in the future.
@p()
Unlike the C #include directive, Felix only
includes a file once: note that symbolic links
will defeat the check for a duplication.

@h1 = env.test('.flx')
@select(h1)
#import <flx.flxh>
@tangle('print "This is '+h1.sink.name+'"; endl;')
@doc()

@select(env.expect())
@tangle('This is '+h1.sink.name)
@doc()

@h2 = env.test('.flx')
@select(h2)
#import <flx.flxh>
@tangle('#include "'+os.path.basename(h1.sink.name)+'"')
@tangle('print "This is '+h2.sink.name+'"; endl;')
@tangle('print "it should have printed the '+h1.sink.name+' message too"; endl;')
@doc()

@select(env.expect())
@tangle('This is '+h1.sink.name)
@tangle('This is '+h2.sink.name)
@tangle('it should have printed the '+h1.sink.name+' message too')
@doc()

@env.head(2,"Conditional compilation")
@env.head(3,'Macro variables and functions')
Felix provides the #define directive to
define a macro variable or macro function.
Unlike C macros, Felix macros are strictly scoped.
They apply in the file in which they're defined
and neither invade included files, nor are they
exported to including files.
@p()
However, the #import directive can be used to
include a file and also import macros into
the including file, in order to allow processing
of configuration files.
@p()
Note that unlike C, macros are ONLY expanded in
conditional directives: they have no affect on ordinary
source text.
@p()
A macro variable must be a valid constant expression
after substitution of macro variables and application
of macro functions.

@env.head(3,'Conditionals')
Felix provides the usual conditional directives
#ifdef, #ifndef, #if, #elif, #else, #endif.
[Add #switch/#case/#endswitch]
@p()
The #if and #elif directives require an argument.
@p()
The balance of the line is first tokenised by
the standard Felix tokeniser and thus may
contain Felix literals and Felix identifiers.
@p()
The line is then expanded by macro substitution.
The result is then parsed as an expression and
constant folded and must yield a boolean constant.
Note that every name encountered must name a 
preprocessor macro.

@select(env.test('.flx'))
#import <flx.flxh>
print "Defining FIRST"; endl;
#define FIRST
#ifdef FIRST
print "detected FIRST"; endl;
#else
print "BAD"; endl;
#endif
@doc()

@select(env.expect())
Defining FIRST
detected FIRST
@doc()

@select(env.test('.flx'))
#import <flx.flxh>
#define FIRST 1
#define SECOND 2
#if FIRST == 1 and SECOND == 2
print "OK"; endl;
#else
print "BAD"; endl;
#endif
@doc()

@select(env.expect())
OK
@doc()

@select(env.test('.flx'))
#import <flx.flxh>
#define FIRST 1
#define SECOND 2
#if if FIRST == 1 then SECOND == 2 else 1 == 0 endif
print "OK"; endl;
#else
print "BAD"; endl;
#endif
@doc()

@select(env.expect())
OK
@doc()

@h = env.test('.flx')
@select(h)
#define FIRST 1
@doc()

@select(env.expect())
@doc()

@select(env.test('.flx'))
#import <flx.flxh>
@tangle('#import "'+os.path.basename(h.sink.name)+'"')
#ifdef FIRST
print "OK";
#else
print "BAD";
#endif
endl;
@doc()

@select(env.expect())
OK
@env.head(2,'Long Lines')
Preprocessor directives support a kind of 'here' doc.
Place a # character after the first part of the command, and
all lines up to a line consisting solely of a #
will be taken as the argument string.
@doc()

@select(env.test('.flx'))
#import <flx.flxh>
#define ONE 1
#define TWO 1
#define THREE 1
#if #
ONE + TWO + THREE > 0
#
print "Yes"; endl;
#else
print "No"; endl;
#endif
@doc()

@select(env.expect())
Yes
@doc()

@env.head(1,'The Syntax Macro Processor')
@env.head(2,'Expression Macro Facility')
Felix provides an powerful and dangerous 
expression macro facility. Felix macros 
generally respect scope, so any definitions
nested in a function or module, for example,
will not be visible outside that scope.
@p()
Expresion symbols only expand inside expressions.

@env.head(3,'Macro values')
The macro val statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.

@select(env.test('.flx'))
#import <flx.flxh>
macro val mx1 = 1+y;
macro val mx2 = 2+y;
val y = 100;
print mx1; endl; // 101
print mx2; endl; // 102
{
  macro val mx1 = 3+y; // 103
  print mx1; endl;
  macro val mx2 = mx2 + 10; // 112
};
print mx1; endl; // 101
print mx2; endl; // 102

// illustration of rescanning 
macro val r1 = y1;
macro val r2 = y2;
macro val y1 = print;
macro val y2 = 1;

r1 r2; // print 1
endl;
@doc()

@select(env.expect())
101
102
103
101
102
1
@doc()

@env.head(3,'Macro variables')
The macro var statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.
@p()
Macro variables can be assigned a new value.

@select(env.test('.flx'))
#import <flx.flxh>
macro var mx1 = 1+y;
val y = 100;
print mx1; endl; // 101
{
  macro mx1 = 3+y; // 103 [assignment!]
  print mx1; endl;
};
print mx1; endl; // 103 [uses assigned value]
@doc()

@select(env.expect())
101
103
103
@doc()

@env.head(3,'Macro variables in requirements')
Named requirements in requirements clauses are
macro expanded as expressions: they must be qualified
names though.

@select(env.test('.flx'))
#import <flx.flxh>
header fred = "inline int f(int x){return x;}";
macro val joe = fred;
fun f: int -> int = "f($1)" requires joe;

print$ f 2; endl;
@doc()

@select(env.expect())
2
@doc()

@env.head(3,'Macro functions')
You can also define a macro function.
The expansion rules are: the body
is not expanded during definition.
At the point of call, the arguments
are expanded and then substituted into
the body, then the body is expanded.
@p()
WARNING: macro function definitions need a semi-colon
at the end. This is because the RHS is universally
treated as an expression.

@select(env.test('.flx'))
#import <flx.flxh>

// a basic expression macro without parameters
macro fun x() =  {print 1; endl;};
x;

// an expression macro with one argument
macro fun h(z) = z + z;
print (h 1); endl;

// an expression macro denoting a procedure
macro fun f(a) = { print a; endl; };
f 1;
f 2;

// nastier example of rescanning
macro fun a() = b c;
macro fun b(x) = f;
a() 1;
// (b c) 1;
// f 1;
// { print 1; endl; };
// call {print 1; endl; } ();

// finally: recursion
macro fun j(i) = 
   if(i>0) then i + j(i-1)
   else 0 endif;
print  (j 5); // 5 + 4 + 3 + 2 + 1 = 16
endl;

val q=1;
macro fun z(q) = q;
print (z q); endl;
@doc()

@select(env.expect())
1
2
1
2
1
15
1
@doc()

It is vital to understand that macros cannot break
syntactically established precedence rules.
In the last example, a 1 expands to (b c) 1,
which expands to f 1. Substitutions are implemented
by manipulation of the abstract syntax tree (AST),
not token pasting or string manipulation.

@env.head(2,'Constant Expression Folding')
The Felix macro processor also performs constant folding;
that is, evaluation of certain expressions involving 
only literals. The following operations are folded:
@begin_table("op","descr")
@table_row('+int','')
@table_row('-int','')
@table_row('int+int','')
@table_row('int-int','')
@table_row('int*int','')
@table_row('int/int','')
@table_row('int%int','')
@table_row('int<int','')
@table_row('int>int','')
@table_row('int<=int','')
@table_row('int>=int','')
@table_row('int==int','')
@table_row('int!=int','')
@table_row('string+string','')
@table_row('string==string','')
@table_row('string!=string','')
@table_row('string*int','cat n copies')
@table_row('string string','cat')
@table_row('string int','cat ISO10646')
@table_row('not bool','')
@table_row('bool && bool','')
@table_row('bool or bool','')
@table_row('bool == bool','')
@table_row('bool != bool','')
@table_row('if bool then expr1 else expr2 endif','')
@end_table()
@p()
The critical operation here is that a conditional
with a constant first argument is replaced by one
of the two expressions, and the other is elided.
See the example for an application: the implication
is that the elided expression, whilst it must be
well formed syntactically, does not need to be
type correct, nor do symbols in it need to be defined.
@p()
Note that the fold uses compiler intrinsic operations
on integers, bools, and strings: user defined functions
are not applied and do not need to be defined.
Consequently, the result may disagree with a user
defined function applied at run time.  If necessary,
constant folding can be blocked with the noexpand mark 'noexpand'.
@p()
Note: the expressions
@begin_displayed_code()
  "" 999
  u"" 999
@end_displayed_code()
are semantically, but not physically equivalent.
The first operation is the UTF-8 representation
of 999, whilst the second is the UCS-32 value 999.

@select(env.test('.flx'))
#import <flx.flxh>
header '''
#define flx_unix 0
#define flx_windows 0
#define testhook 1
#if flx_unix
#include <dlopen.h>
#elif flx_windows
#include <windows.h>
#else
#include <stdio.h>
#endif
''';
macro val Unix = case 0 of 2;
macro val Windows = case 0 of 2;

fun dlopen:string -> address = 'dlopen($1.data())';
fun LoadLibrary:string -> int = 'LoadLibrary($.data())';
fun testhook:string -> int = 'printf("LoadTheLibrary(%s)\\n",$1.data())';

macro val openlib = 
  if Unix then dlopen 
  elif Windows then LoadLibrary 
  else testhook endif
;

macro val ext = 
  if Unix then ".so" 
  elif Windows then ".DLL"
  else ".lib_ext" endif
;
// conditional compilation
C_hack::ignore(openlib ("MyLibrary" ext));
@doc()

@select(env.expect())
LoadTheLibrary(MyLibrary.lib_ext)
@doc()

@env.head(2,'Procedure Macros')
A procedure macro represents a list of statements.
Macros defined in macro procedures are exported
to the surrounding scope so that macro procedures
can be used to package up a set of macro definitions.
This represents a special exception to the rule
that macros respect scope.

@select(env.test('.flx'))
#import <flx.flxh>
// procedure macro
macro proc k ()
{
  val yy = xx * xx;
  print xx; print " -> "; print yy; endl;
}

{
  val xx = 1;
  k();
};
{
  val xx = 2;
  k();
};

macro proc pkg (x)
{
  macro proc printxy (y) { print (x+y); endl; }
  macro val doublex = x + x;
}

pkg 10;
printxy doublex; // prints 30

macro proc dump_s (sts:proc)
{
  print "Start dump_s"; endl;
  sts;
  print "End dump_s"; endl;
}

macro proc dump_e (sts:fun)
{
  print "Start dump_e"; endl;
  sts;
  print "End dump_e"; endl;
}

dump_s { print 1; endl; print 2; endl; };
dump_e { val x = 1; print x; endl; print 2; endl; };

macro proc todump () { print "Dumped"; endl; }
dump_s todump;
dump_e todump;

macro proc todump_wa (x) { print x; endl; }
dump_s (todump_wa 66);
dump_e (todump_wa 66);
@doc()

@select(env.expect())
1 -> 1
2 -> 4
30
Start dump_s
1
2
End dump_s
Start dump_e
1
2
End dump_e
Start dump_s
Dumped
End dump_s
Start dump_e
Dumped
End dump_e
Start dump_s
66
End dump_s
Start dump_e
66
End dump_e
@doc()

Note there is a crucial difference between procedure
and expressions macros. In the above example,
dump requires a proc argument. When the parameter
is expanded, the list of statements it represented
is produced. Had this been a function macro,
the result would have been an the call executable lambda
expression applied to unit argument. The difference
is in the handling of any variable declarations:
they'd be exposed in the first case, but not the second.

@env.head(2,'Advanced Procedure Macro Programming')
Felix procedure macros also contain rudimentary
control structures: you can encode labels, unconditional
jumps, conditional jumps, and returns. Note the conditional
goto requires the condition resolve to a constant expression.
Of course, the value can change with time, since it can
depend on macro variables.
@p()
This example also illustrates the macro block, which is
an anonymous procedure, called after definition. The effect
is similar to the statements in the block, except that
locally defined symbols are not exported. The construction
is regularly required by the syntax extension facility,
to prevent name conflicts when the same construction
is expanded more than once, particularly cases where
a macro expansion has as its argument another expansion
of itself.

@select(env.test('.flx'))
#import <flx.flxh>
macro proc print_alot () 
{
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
}

print_alot();

macro {
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
};

// note the 'start' macro label is local so there
// is no clash repeating a block.

macro {
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
};
@doc()

@select(env.expect())
10 9 8 7 6 5 4 3 2 1
10 9 8 7 6 5 4 3 2 1
10 9 8 7 6 5 4 3 2 1
@doc()

@env.head(2,'Expansion Barrier')
The symbol 'noexpand' can be used to block expansion.

@select(env.test('.flx'))
#include <flx.flxh>
// expansion barrier
macro val x = 1;
macro proc k ()
{
  val yy = noexpand x + x; // x + 1
  print noexpand x; print "+"; print x; print " -> "; print yy; endl;
}
macro x is x; // blocks x
{
  val x = 2;
  k();
};
@doc()

@select(env.expect())
2+2 -> 4
@doc()

@env.head(2,'Identifier Macros')
A identifier macros represent names. They replace names 
in expressions and most declarations, including the
name of a function or variable being defined.
Names are not replaced in type expressions, patterns,
or regular expressions.
@p()
The special form in which the RHS name is called 'new'
creates a fresh, previously unused name.
@p()
Unlike other macros, the RHS name of an ident macro
is not expanded at the point of definition.
@p()
On use, the value of an ident macro is the first
name in the chain which is not an ident macro,
or which recurs.

@select(env.test('.flx'))
#include <flx.flxh>

macro oldname is newname;
fun oldname(x:int):int = { return x; }
print (newname 1); endl;

macro proc make_ints ()
{
  macro vnew is new;
  val vnew = vold+1;
  macro vold = vnew;
}

val x = 1;

macro var vold = x;
make_ints;
make_ints;
make_ints;
print vold; endl;
@doc()

@select(env.expect())
1
4
@doc()

@env.head(3,'Forgetting Macros')
You can forget macros defined in the current scope with
the forget statement. If no arguments are given,
all macros defined in the current scope are forgotten. 

@select(env.test('.flx'))
#include <flx.flxh>
macro val hello = "Hello";
macro val place = "world";
macro fun greet() = hello " " place "!\n";
{
  macro val hello = "Hi there";
  macro val place = "locality";
  print (greet());
  macro forget place;
  print (greet());
  macro forget;
  print (greet());
};

print (greet());
@doc()

@select(env.expect())
Hi there locality!
Hi there world!
Hello world!
Hello world!
@doc()

@env.head(3,'For Loops')
Felix provides two for loops which iterate over tuples.

@select(env.test('.flx'))
#include <flx.flxh>
macro for val i in ("Hello","World",42) do 
  print i; print " ";
done;
endl;

macro for i in (a,b,c) do 
  var i = 1;
  print$ Debug::repr_expr i; print "="; print i; endl;
done;
@doc()

@select(env.expect())
Hello World 42 
PTF a:int=1
PTF b:int=1
PTF c:int=1
@doc()

@env.head(3,"Unpacking Tuples")
Tuples can be unpacked by macro assignment, 
macro val, macro var, and macro for val statements.

@select(env.test('.flx'))
#include <flx.flxh>
macro val x,y = 1,2;
macro var a,b = 1,2;
macro a,b = a+1,b+1;
macro for val i in x,y,a,b do print i; print " "; done; endl;

macro for val i,j in ((1,2),(3,4)) do
  print "("; print i; print ","; print j; print ")"; print " ";
done;
endl;
@doc()

@select(env.expect())
1 2 2 3 
(1,2) (3,4) 
@doc()

@env.head(3,"String representation")
The string representation of an expression can be obtained
with the special operator _str. This is most useful for
printing a variable name (but it works for any expression).
Note the expanded value is stringized.

@select(env.test('.flx'))
#include <flx.flxh>
var x = 1;
var y = 42;
print (_str x); print " = "; print x; endl;
print (_str y); print " = "; print y; endl;
print (_str$ x+y); print " = "; print$ x+y; endl;
@doc()

@select(env.expect())
x = 1
y = 42
(add (x, y)) = 43
@doc()

@env.head(3,"Packing Tuples")
The Felix syntax macro processor treats tuples as lists.
The for val construction can be used to iterate over
list contents. Two primitive macro functions are provided
for constructing tuples.
@p()
The _tuple function takes one argument and makes a 
one element tuple. Note that the main Felix programming
language does not allow one element tuples. The macro
processor does though.
@p()
The _tuple_cons function takes two arguments, an element
and a tuple, and constructs a single tuple starting
with the first argument followed by the elements of the 
second argument: this is the usual list cons function of
functional programming languages.
@p()
These two functions are most useful in recursive
expansions, particularly when driven by user defined
nontermial parses (see the next section).

@select(env.test('.flx'))
#include <flx.flxh>
macro var x = _tuple 1;
macro x = _tuple_cons (2,x);
macro x = _tuple_cons (3,x);
macro for val i in x do print i; print " "; done; endl;
@doc()

@select(env.expect())
3 2 1 
@doc()

@env.head(1,"User defined syntax")
Felix has a complete, graded system which
allows the programmer to extend its syntax.

@env.head(2,"User defined operators")
The programmer may add infix operators at a particular
precedence level. Infix operators are any sequence
of the special characters ~!@#$%^&*.?/\=(){}[], or, any identifier. 
@p()
Matching special characters is done greedily, 
the longest left prefix is considered first. 
Currently the precedence level is ignored,
and all operators are at level 10 binding just more
tightly than ||.
@p()
The infix form is replaced by a call to the specified function.
@p()
The user can also define bracket operators.
@p()
If you put some of these things in a separate file,
be sure to #import the file in every file that it is
needed.

@select(env.test('.flx'))
#import <flx.flxh>
#infix 10 "^%" myfun
print "OK"; endl;
fun myfun: int * int -> int = "$1 + $2 * 2";
print$ myfun$ 2,4; endl; // 10
print$ 2 ^% 4; endl; // 10

#bracket "[[" "]]" abs
fun abs: int -> int = "abs($1)";

print$ abs (-10); endl; //10
print$ [[ -10 ]]; endl; //10

#infix 10 fred joe
fun joe: int * int -> int = "$1 + $2 * $2";
print$ joe$ 2,3; endl; // 11
print$ 2 fred 3; endl; // 11

proc ff:lvalue[int] * int = "$1=$2;";
var x:int <- ff 1;
print x; endl;


proc gg(px:&int, a:int) { *px = a; }
var &y:int <- gg 1;
print y; endl;
@doc()

@select(env.expect())
OK
10
10
10
10
11
11
1
1
@doc()

@env.head(2,"User defined statements")
Felix allows the programmer to invent new statements.
The statements must start with a user keyword: they
may not start with an existing non-user keyword.
@p()
The Felix LR parser recognises these keywords and
switches to Recursive Descent parsing mode.
Therefore, grammar productions must not be left recursive
or the parser will crash.
@p()
The leading identifier is automatically turned into
a keyword. 
@p()
These examples are lifted from the system library.
@p()
The following identifiers have a special, obvious, meaning:
@begin_displayed_code()
  ident
  expr
  statement
  statements
  string_literal
  integer_literal
@end_displayed_code()
@p()
Felix considers productions in LIFO order, like a stack.
Therefore, general cases must be given after specialised
ones. 

@select(env.test('.flx'))
#include <flx.flxh>

#statement#
  whilst expr do statements done ; =>#
  macro {
    macro lab1 is new;
    macro lab2 is new;
    lab1:>
      if not _1 goto lab2;
      _3;
      goto lab1;
    lab2:>
  };
#

{
  var x = 10;
  whilst x > 0 do print x; print " "; --x; done;
  endl;
};

#statement#
  until expr do statements done; =>#
  macro {
    macro lab1 is new;
    macro lab2 is new;
    lab1:>
      if _1 goto lab2;
      _3;
      goto lab1;
    lab2:>
  };
#

{
  var x = 10;
  until x == 0 do print x; print " "; --x; done;
  endl;
};

#statement#
  forall ident in expr do statements done ; =>#
    macro for val _1 in _3 do _5; done;
#

forall x in (1," plus ",2," is ",1+2) do print x; done; endl;

#keyword upto
#statement#
  forall ident in expr upto expr do statements done ; =>#
  _1 = _3;
  whilst _1 <= _5 do _7; ++i; done;
#

{
  var i = 0;
  forall i in 1 upto 10 do print i; print " "; done; 
  endl;
};

#keyword downto
#statement#
  forall ident in expr downto expr do statements done ; =>#
  _1 = _3;
  whilst _1 >= _5 do _7; --i; done;
#

{
  var i = 0;
  forall i in 10 downto 1 do print i; print " "; done; 
  endl;
};
@doc()

@select(env.expect())
10 9 8 7 6 5 4 3 2 1 
10 9 8 7 6 5 4 3 2 1 
1 plus 2 is 3
1 2 3 4 5 6 7 8 9 10
10 9 8 7 6 5 4 3 2 1
@doc()

@env.head(2,"User Non terminals")
Felix syntax extensions are not limited to simple
statements. The parser is a general, backtracking
RD parser and can handle any LL grammar. The only
constraint is that it must be triggered initially by
a user defined keyword.
@p()
The example below shows how you can define and use
auxilliary nonterminal productions, which is necessary
to handle lists of things other than statements.
@p()
Currently, the user actions must be expressions
or statements. The system allows statements in tuples,
by converting them to a special kind of expression.
This allows the syntax macro processor to handle
them uniformly.
@p()
Note also that the system is openly recursive: new
user defined statements can be nested anywhere.
They are also recognized immediately after the 
preprocessor #statement statement, including in
the very next #statement definition.

@select(env.test('.flx'))
#include <flx.flxh>
#keyword DONE
#keyword THEN
#keyword ELIF
#keyword ELSE

#nonterminal elif_clause #
  ELIF expr THEN statements =># 
  (_2,_4)
#

#nonterminal elif_clauses #
  elif_clause =>#
  _tuple _1
#

#nonterminal elif_clauses #
  elif_clause elif_clauses =>#
  _tuple_cons (_1,_2)
#

#nonterminal else_clause #
  ELSE statements =># 
  ((),_2)
#  

#nonterminal else_clause #
  elif_clauses ELSE statements =># 
  (_1,_3)
#  

#statement# 
  IF expr THEN statements else_clause DONE; =>#
  macro {
    macro val elifs,elsepart = _4;
    macro endoff is new;
    macro next is new;
    if not _1 goto next;
      _3;
			goto endoff;
    next:>
      macro for val elifcond,elifclause in elifs do
      macro next' is new;
      if not elifcond goto next';
      elifclause;
      goto endoff;
    next':>
      done;
      elsepart;
    endoff:>
  };
#

val x = 2; 
IF x==1 THEN print 1; print 1; endl;
ELIF x==3 THEN print 3; print 3; endl;
ELIF x==5 THEN print 5; print 5; endl;
ELIF x==7 THEN print 7; print 7; endl;
ELSE print "None"; endl; DONE;

val y = 5;
IF y==1 THEN print 1; print 1; endl;
ELIF y==3 THEN print 3; print 3; endl;
ELIF y==5 THEN print 5; print 5; endl;
ELIF y==7 THEN print 7; print 7; endl;
ELSE print "None"; endl; DONE;

@doc()

@select(env.expect())
None
55
@doc()

@env.head(2,"User Macro Statement")
The syntax extension feature isn't limited to generated
executable statements or definitions: you can actually
generated macro statements, and thus extend the macro
processor itself. The example below introduces a 
macro conditional that accepts some statements as an 
argument instead of using a macro goto.

@select(env.test('.flx'))
#include <flx.flxh>
#statement#
  IF expr do statements done; =>#
  macro {
    macro lab is new;
    macro if not _1 goto lab;
    _3;
    macro lab:>
  };
#

IF 1 == 1 do
  print "Hello"; endl;
done;
@doc()

@select(env.expect())
Hello
@#
@doc()

