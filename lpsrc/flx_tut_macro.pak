@set_title('Felix Tutorial: Macros')
@tdir = 'tut/examples/'
@head(1,'The PreProcessor')
Felix provides a C like pre-processor. Note that 
whilst it is C like in appearance, it isn't the same.
Preprocessor directives start with a # in column 1,
followed by a keyword denoting the directive.
@p()
The syntax and semantics of directives are 
described below.

@head(2,'Include directive')
The #include directive takes the same
form as the corresponding C preprocessor
directive.
@p()
The file names used in include directives
MUST be Unix style relative file names, no matter
what operating system is hosting the compilation.
@p()
[To be done: should require URL format]
@p()
Relative file names inside angle brackets <>
are searched for in the include path passed
to the compiler on the command line.
@p()
Relative file names in double quotes are searched
for first in the directory containing the
file which contains the include directive,
then in the include path passed to the
compiler on the command line.
@p()
Absolute file names are NOT permitted. Files relative
to the current directory are NOT permitted.
In both cases the reason is to enhance the prospects
for portability.
@p()
The C form #include MACRO is not accepted.
@p()
Note the notion path searching will be replaced
by a more powerful technique allowing shadowed
directories in the future.
@p()
Unlike the C #include directive, Felix only
includes a file once: note that symbolic links
will defeat the check for a duplication.

@select(tangler(tdir+'mac101.flx'))
include "std";
print "This is mac101"; endl;

@select(tangler(tdir+'mac102.flx'))
include "std";
#include "mac101.flx"
print "This is mac102"; endl;
print "it should have printed the 101 message too"; endl;

@head(2,"Conditional compilation")
@head(3,'Macro variables and functions')
Felix provides the #define directive to
define a macro variable or macro function.
Unlike C macros, Felix macros are strictly scoped.
They apply in the file in which they're defined
and neither invade included files, nor are they
exported to including files.
@p()
However, the #import directive can be used to
include a file and also import macros into
the including file, in order to allow processing
of configuration files.
@p()
Note that unlike C, macros are ONLY expanded in
conditional directives: they have no affect on ordinary
source text.
@p()
A macro variable must be a valid constant expression
after substitution of macro variables and application
of macro functions.

@head(3,'Conditionals')
Felix provides the usual conditional directives
#ifdef, #ifndef, #if, #elif, #else, #endif.
[Add #switch/#case/#endswitch]
@p()
The #if and #elif directives require an argument.
@p()
The balance of the line is first tokenised by
the standard Felix tokeniser and thus may
contain Felix literals and Felix identifiers.
@p()
The line is then expanded by macro substitution.
The result is then parsed as an expression and
constant folded and must yield a boolean constant.
Note that every name encountered must name a 
preprocessor macro.

@select(tangler(tdir+'mac103.flx'))
include "std";
print "Defining FIRST"; endl;
#define FIRST
#ifdef FIRST
print "detected FIRST"; endl;
#else
print "BAD"; endl;
#endif

@select(tangler(tdir+'mac104.flx'))
include "std";
#define FIRST 1
#define SECOND 2
#if FIRST == 1 and SECOND == 2
print "OK"; endl;
#else
print "BAD"; endl;
#endif

@select(tangler(tdir+'mac105.flx'))
include "std";
#define FIRST 1
#define SECOND 2
#if if FIRST == 1 then SECOND == 2 else 1 == 0 endif
print "OK"; endl;
#else
print "BAD"; endl;
#endif

@select(tangler(tdir+'mac105a.flx'))
#define FIRST 1

@select(tangler(tdir+'mac105b.flx'))
include "std";
#import "mac105a.flx"
#ifdef FIRST
print "OK";
#else
print "BAD";
#endif
endl;

@head(2,'Long Lines')
Preprocessor directives support a kind of 'here' doc.
Place a # character after the command name, and
all lines up to a line consisting solely of a #
will be taken as the argument string.

@select(tangler(tdir+'mac106.flx'))
include "std";
#define ONE 1
#define TWO 1
#define THREE 1
#if #
ONE + TWO + THREE > 0
#
print "Yes"; endl;
#else
print "No"; endl;
#endif

@head(2,'Code generation with Scheme')
The Felix preprocessor contains a Scheme interpreter
which can be invoked with the scheme directive.
The directive is replaced by the output of the scheme
program. Generally, the same environment is used by
all scheme commands, to allow communication between
parts of the program.

@select(tangler(tdir+'mac107.flx'))
include "std";
#scheme (define x 1)
#scheme (define y 2)
#scheme #
(display "var x = ") (display (+ x y)) (display ";")
(newline)
#
print x; endl;

@head(1,'The Syntax Macro Processor')
@head(2,'Expression Macro Facility')
Felix provides an powerful and dangerous 
expression macro facility. Felix macros 
generally respect scope, so any definitions
nested in a function or module, for example,
will not be visible outside that scope.
@p()
Expresion symbols only expand inside expressions.

@head(3,'Macro values')
The macro val statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.

@select(tangler(tdir+'mac122.flx'))
include "std";
macro val mx1 = 1+y;
macro val mx2 = 2+y;
val y = 100;
print mx1; endl; // 101
print mx2; endl; // 102
{
  macro val mx1 = 3+y; // 103
  print mx1; endl;
  macro val mx2 = mx2 + 10; // 112
};
print mx1; endl; // 101
print mx2; endl; // 102

// illustration of rescanning 
macro val r1 = y1;
macro val r2 = y2;
macro val y1 = print;
macro val y2 = 1;

r1 r2; // print 1
endl;

@head(3,'Macro variables')
The macro var statement defines a LHS symbol
as the expansion of the RHS. The same
value can be defined any number of times,
a redefinition hides the preceding defintion
until the end of the scope.
@p()
Macro variables can be assigned a new value.

@select(tangler(tdir+'mac123.flx'))
include "std";
macro var mx1 = 1+y;
val y = 100;
print mx1; endl; // 101
{
  macro mx1 = 3+y; // 103 [assignment!]
  print mx1; endl;
};
print mx1; endl; // 103 [uses assigned value]


@head(3,'Macro functions')
You can also define a macro function.
The expansion rules are: the body
is not expanded during definition.
At the point of call, the arguments
are expanded and then substituted into
the body, then the body is expanded.

@select(tangler(tdir+'mac124.flx'))
include "std";

// a basic expression macro without parameters
macro fun x() =  {print 1; endl;};
x;

// an expression macro with one argument
macro fun h(z) = z + z;
print (h 1); endl;

// an expression macro denoting a procedure
macro fun f(a) = { print a; endl; };
f 1;
f 2;

// nastier example of rescanning
macro fun a() = b c;
macro fun b(x) = f;
a() 1;
// (b c) 1;
// f 1;
// { print 1; endl; };
// call {print 1; endl; } ();

// finally: recursion
macro fun j(i) = 
   if(i>0) then i + j(i-1)
   else 0 endif;
print  (j 5); // 5 + 4 + 3 + 2 + 1 = 16
endl;

val q=1;
macro fun z(q) = q;
print (z q); endl;

@doc()
It is vital to understand that macros cannot break
syntactically established precedence rules.
In the last example, a 1 expands to (b c) 1,
which expands to f 1. Substitutions are implemented
by manipulation of the abstract syntax tree (AST),
not token pasting or string manipulation.

@head(2,'Constant Expression Folding')
The Felix macro processor also performs constant folding;
that is, evaluation of certain expressions involving 
only literals. The following operations are folded:
@begin_table("op","descr")
@table_row('+int','')
@table_row('-int','')
@table_row('int+int','')
@table_row('int-int','')
@table_row('int*int','')
@table_row('int/int','')
@table_row('int%int','')
@table_row('int<int','')
@table_row('int>int','')
@table_row('int<=int','')
@table_row('int>=int','')
@table_row('int==int','')
@table_row('int!=int','')
@table_row('string+string','')
@table_row('string==string','')
@table_row('string!=string','')
@table_row('string*int','cat n copies')
@table_row('string string','cat')
@table_row('string int','cat ISO10646')
@table_row('not bool','')
@table_row('bool && bool','')
@table_row('bool or bool','')
@table_row('bool == bool','')
@table_row('bool != bool','')
@table_row('if bool then expr1 else expr2 endif','')
@end_table()
@p()
The critical operation here is that a conditional
with a constant first argument is replaced by one
of the two expressions, and the other is elided.
See the example for an application: the implication
is that the elided expression, whilst it must be
well formed syntactically, does not need to be
type correct, nor do symbols in it need to be defined.
@p()
Note that the fold uses compiler intrinsic operations
on integers, bools, and strings: user defined functions
are not applied and do not need to be defined.
Consequently, the result may disagree with a user
defined function applied at run time.  If necessary,
constant folding can be blocked with the noexpand mark $.
@p()
Note: the expressions
@begin_displayed_code()
  "" 999
  u"" 999
@end_displayed_code()
are semantically, but not physically equivalent.
The first operation is the UTF-8 representation
of 999, whilst the second is the UCS-32 value 999.

@select(tangler(tdir+'mac125.flx'))
include "std";
header '''
#define unix 0
#define windows 0
#define testhook 1
#if unix
#include <dlopen.h>
#elif windows
#include <windows.h>
#else
#include <stdio.h>
#endif
''';
macro val unix = case 1 of 2;
macro val windows = case 1 of 2;

fun dlopen:string -> address = 'dlopen($1.data())';
fun LoadLibrary:string -> int = 'LoadLibrary($.data())';
fun testhook:string -> int = 'printf("LoadTheLibrary(%s)\\n",$1.data())';

macro val openlib = 
  if unix then dlopen 
  elif windows then LoadLibrary 
  else testhook endif
;

macro val ext = 
  if unix then ".so" 
  elif windows then ".DLL"
  else ".lib_ext" endif
;
// conditional compilation
val lib = openlib ("MyLibrary" ext);

@head(2,'Procedure Macros')
A procedure macro represents a list of statements.
Macros defined in macro procedures are exported
to the surrounding scope so that macro procedures
can be used to package up a set of macro definitions.
This represents a special exception to the rule
that macros respect scope.

@select(tangler(tdir+'mac126.flx'))
include "std";
// procedure macro
macro proc k ()
{
  val yy = xx * xx;
  print xx; print " -> "; print yy; endl;
}

{
  val xx = 1;
  k();
};
{
  val xx = 2;
  k();
};

macro proc pkg (x)
{
  macro proc printxy (y) { print (x+y); endl; }
  macro val doublex = x + x;
}

pkg 10;
printxy doublex; // prints 30

macro proc dump_s (sts:proc)
{
  print "Start dump_s"; endl;
  sts;
  print "End dump_s"; endl;
}

macro proc dump_e (sts:fun)
{
  print "Start dump_e"; endl;
  sts;
  print "End dump_e"; endl;
}

dump_s { print 1; endl; print 2; endl; };
dump_e { val x = 1; print x; endl; print 2; endl; };

macro proc todump () { print "Dumped"; endl; }
dump_s todump;
dump_e todump;

macro proc todump_wa (x) { print x; endl; }
dump_s (todump_wa 66);
dump_e (todump_wa 66);

@doc()
Note there is a crucial difference between procedure
and expressions macros. In the above example,
dump requires a proc argument. When the parameter
is expanded, the list of statements it represented
is produced. Had this been a function macro,
the result would have been an the call executable lambda
expression applied to unit argument. The difference
is in the handling of any variable declarations:
they'd be exposed in the first case, but not the second.

@head(2,'Advanced Procedure Macro Programming')
Felix procedure macros also contain rudimentary
control structures: you can encode labels, unconditional
jumps, conditional jumps, and returns. Note the conditional
goto requires the condition resolve to a constant expression.
Of course, the value can change with time, since it can
depend on macro variables.

@select(tangler(tdir+'mac126a.flx'))
include "std";
macro proc print_alot () 
{
  macro var count = 10;
  macro start:>
    print count; print " ";
    macro count = count - 1;
    macro if count > 0 goto start;
  endl;
}

print_alot();

@head(2,'Expansion Barrier')
The symbol '$' can be used to block expansion.
@select(tangler(tdir+'mac127.flx'))
include "std";
// expansion barrier
macro val x = 1;
macro proc k ()
{
  val yy = $x + x; // x + 1
  print $x; print "+"; print x; print " -> "; print yy; endl;
}
macro ident x = x; // blocks x
{
  val x = 2;
  k();
};

@head(2,'Identifier Macros')
A identifier macros represent names. They replace names 
in expressions and most declarations, including the
name of a function or variable being defined.
Names are not replaced in type expressions, patterns,
or regular expressions.
@p()
The special form in which the RHS name is called 'new'
creates a fresh, previously unused name.
@p()
Unlike other macros, the RHS name of an ident macro
is not expanded at the point of definition.
@p()
On use, the value of an ident macro is the first
name in the chain which is not an ident macro,
or which recurs.

@select(tangler(tdir+'mac128.flx'))
include "std";

macro ident oldname = newname;
fun oldname(x:int):int = { return x; }
print (newname 1); endl;

macro proc make_ints ()
{
  macro ident vnew = new;
  val vnew = vold+1;
  macro vold = vnew;
}

val x = 1;

macro var vold = x;
make_ints;
make_ints;
make_ints;
print vold; endl;

@head(3,'Forgetting Macros')
You can forget macros defined in the current scope with
the forget statement. If no arguments are given,
all macros defined in the current scope are forgotten. 

@select(tangler(tdir+'mac129.flx'))
include "std";
macro val hello = "Hello";
macro val place = "world";
macro fun greet() = hello " " place "!\n";
{
  macro val hello = "Hi there";
  macro val place = "locality";
  print (greet());
  macro forget place;
  print (greet());
  macro forget;
  print (greet());
};

print (greet());


