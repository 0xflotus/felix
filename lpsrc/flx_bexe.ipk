@head(1,'Bind executable statements')
@h = tangler("src/flx_bexe.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes2

val bind_exes:
  sym_state_t ->
  env_t ->
  range_srcref ->
  (range_srcref * exe_t) list ->
  btypecode_t ->
  string ->
  bid_t ->
  bvs_t ->
  btypecode_t * bexe_t list

@h = tangler("src/flx_bexe.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify
open Flx_exceptions
open List

let rec check_if_parent syms child parent =
  if child = parent then true
  else
      match Hashtbl.find syms.dfns child with
      | {parent=Some parent} -> check_if_parent syms child parent
      | {parent=None} -> false

let cal_call syms sr ((p,pt) as tbe1) ((_,argt) as tbe2) =
  match unfold syms.dfns pt with
  | `BTYP_lvalue (`BTYP_function (t, `BTYP_void))
  | `BTYP_function (t, `BTYP_void) -> 
    if type_match syms.dfns t argt 
    then 
      ( 
        match p with 
        | `BEXPR_closure (i,ts) -> 
          begin match Hashtbl.find syms.dfns i with
          | {symdef=`SYMDEF_fun _ } -> 
            `BEXE_call_prim (sr,i,ts,tbe2)

          | {symdef=`SYMDEF_function _} ->
            `BEXE_call_direct (sr,i,ts,tbe2)

          | _ -> assert false
          end
        | _ -> 
          `BEXE_call (sr,(p,lower pt), tbe2)
      )
    else
      clierr sr
      (
        "[cal_call] Procedure " ^
        sbe syms.dfns tbe1 ^
        "\nof type " ^
        sbt syms.dfns pt ^
        "\napplied to argument " ^
        sbe syms.dfns tbe2 ^
        "\n of type " ^
        sbt syms.dfns argt ^
        "\nwhich doesn't agree with parameter type\n" ^
        sbt syms.dfns t 
      )

  | _ -> 
    clierr sr ("[cal_call] call non procedure, "^
    sbe syms.dfns (p,pt)
    ^"\ntype=" ^ sbt syms.dfns pt)

let cal_loop syms sr ((p,pt) as tbe1) ((_,argt) as tbe2) this =
  match unfold syms.dfns pt with
  | `BTYP_function (t, `BTYP_void) -> 
    if t = argt 
    then 
      match p with
      | `BEXPR_closure (i,ts) ->
        if check_if_parent syms i this
        then
          `BEXE_call_direct (sr,i, ts, tbe2)
        else
          clierr sr
          "[cal_loop] Loop target must be self or parent"

      | _ -> 
        clierr sr (
          "[cal_loop] Expected procedure closure, got "^
          string_of_bound_expression syms.dfns (p,pt)
        )
    else
      clierr sr
      (
        "[cal_loop] Procedure " ^
        sbe syms.dfns tbe1 ^
        "\nof type " ^
        sbt syms.dfns pt ^
        "\napplied to argument " ^
        sbe syms.dfns tbe2 ^
        "\n of type " ^
        sbt syms.dfns argt ^
        "\nwhich doesn't agree with parameter type\n" ^
        sbt syms.dfns t 
      )

  | _ -> 
    clierr sr ("[cal_loop] loop to non procedure, "^
    string_of_bound_expression syms.dfns (p,pt)
    ^"\ntype=" ^ string_of_btypecode syms.dfns pt)

exception Found of int

let print_vs vs =
  catmap "," (fun (s,i) -> s ^ "->" ^ si i) vs

let bind_exes syms env sr exes ret_type id index parent_vs = 
  (*
  print_endline ("bind_exes.. env depth="^ string_of_int (List.length env));
  print_endline "Dumping Source Executables";
  print_endline "--------------------------";
  let soe e = Flx_print.string_of_expr e in
  List.iter 
    (fun (_,x) -> print_endline (string_of_exe 1 x))
    exes
  ;
  print_endline ""
  ;

  print_endline "Binding Executables";
  print_endline "-------------------";
  *)

  (* a type variable in executable code just has to be of kind TYPE *)
  let parent_ts = map (fun (s,i) -> `BTYP_var (i,`BTYP_type)) parent_vs in
  let ret_type = ref ret_type in
  let be e : tbexpr_t = bind_expression syms env e in
  let lun sr n = lookup_name_in_env syms env sr n in
  let luqn n = lookup_qn_in_env syms env n in
  let bt sr t : btypecode_t = bind_type syms env sr t in
  let return_count = ref 0 in
  let reachable = ref true in
  let proc_return_count = ref 0 in

  let bound_exes : bexe_t list ref = ref [] in
  let tack x = bound_exes := x :: !bound_exes in
  let rec bind_exe (sr,x) = 
    (*
    print_endline ("EXE="^string_of_exe 1 x);
    *)
    if not !reachable then 
    begin 
      match x with 
      | `EXE_label _ -> ()
      | `EXE_comment _ -> ()
      | `EXE_nop _ -> ()
      | _ -> print_endline 
        (
          "WARNING: Unreachable code in "^id^": " ^ 
          string_of_exe 1 x ^ " in\n" ^ 
          short_string_of_src sr
        );
    end
    ;
    match x with
    | `EXE_comment s ->       tack (`BEXE_comment (sr,s))
    | `EXE_label s ->         reachable := true; tack (`BEXE_label (sr,s))
    | `EXE_goto s ->          reachable := false; tack (`BEXE_goto (sr,s))

    | `EXE_ifgoto (e,s) ->    
      let e',t = be e in
      if lstrip syms.dfns t = flx_bbool
      then tack (`BEXE_ifgoto (sr,(e',t), s))
      else 
        clierr (src_of_expr e)
        (
          "[bind_exes:ifgoto] Conditional requires bool argument, got " ^
          string_of_btypecode syms.dfns t
        )

    | `EXE_ifnotgoto (e,s) -> 
      let e',t = be e in
      if lstrip syms.dfns t = flx_bbool
      then tack (`BEXE_ifnotgoto (sr,(e',t), s))
      else 
        clierr (src_of_expr e)
        (
          "[bind_exes:ifnotgoto] Conditional requires bool argument, got " ^
          string_of_btypecode syms.dfns t ^ " in\n" ^
          short_string_of_src sr
        )

    | `EXE_loop (n,e2) ->
      let be2,t2 = be e2 in
      let tbe1 =
         lookup_qn_with_sig 
         syms 
         sr sr 
         env
         (`AST_name(sr,n,[]) : qualified_name_t)
         t2 
      in  
        (* reverse order .. *)
        tack (`BEXE_proc_return sr);
        (* note cal_loop actually generates a call .. *)
        tack (cal_loop syms sr tbe1 (be2,t2) index)

    | `EXE_jump (a,b) ->
      incr proc_return_count;
      bind_exe (sr,`EXE_call (a,b));
      bind_exe  (sr,`EXE_proc_return)

    | `EXE_call (#suffixed_name_t as sn, e2) -> (* OVERLOADING *)
      let sr = src_of_expr sn in
      let be2,t2 = be e2 in
      let (be1,t1) as tbe1 =
         match sn with
         | #qualified_name_t as qn ->
           lookup_qn_with_sig 
           syms 
           sr sr 
           env
           qn t2 
         | _ -> be sn
      in  
        tack (cal_call syms sr tbe1 (be2,t2))

    | `EXE_call (p,e) ->
      let p',pt' = be p and e',et' = be e in
      tack (cal_call syms sr (p', pt') (e', et'))

    | `EXE_read s ->          
      begin match lun sr s with
      | NonFunctionEntry (index) -> 
        let {symdef=entry; id=id} = Hashtbl.find syms.dfns index in
        begin match entry with
        | `SYMDEF_var _ -> ()
        | `SYMDEF_val _ -> clierr sr ("Can't read into value " ^ id)
        | `SYMDEF_parameter _ -> clierr sr ("Can't read into parameter value " ^ id)
        | _ -> clierr sr ("[bexe] Read requires variable, got " ^ id)
        end
        ;
        tack (`BEXE_read (sr,index))

      | FunctionEntry _ -> failwith "Can't read function!"
      end

    | `EXE_proc_return ->
      incr proc_return_count;
      reachable := false;
      if do_unify syms !ret_type `BTYP_void 
      then 
        begin
          ret_type := varmap_subst syms.varmap !ret_type;
          tack (`BEXE_proc_return sr)
        end
      else
        clierr sr 
        (
          "function " ^id^" has void return type"
        )

    | `EXE_fun_return e ->        
      reachable := false;
      incr return_count;
      let e',t' = be e in
      let t' = minimise syms.dfns t' in
      if do_unify syms !ret_type t' then begin
        ret_type := varmap_subst syms.varmap !ret_type;
        tack (`BEXE_fun_return (sr,(e',lower t')))
      end 
      else
        clierr sr
        (
          "In " ^ string_of_exe 0 x ^ "\n" ^
          "Wrong return type,\nexpected : " ^ 
          string_of_btypecode syms.dfns !ret_type ^
          "\nbut we got " ^
          string_of_btypecode syms.dfns t'
        )

    | `EXE_nop s ->           tack (`BEXE_nop (sr,s))
    | `EXE_code s ->          tack (`BEXE_code (sr,s))
    | `EXE_noreturn_code s ->  
      reachable := false; 
      tack (`BEXE_nonreturn_code (sr,s))

    | `EXE_assert e -> 
      let (x,t) as e' = be e in
      if lstrip syms.dfns t = flx_bbool
      then tack (`BEXE_assert (sr,e'))
      else clierr sr
      (
        "assert requires bool argument, got " ^
        string_of_btypecode syms.dfns t
      )

    | `EXE_iinit ((s,index),e) -> 
        let e',rhst = be e in
        let lhst = typeofindex_with_ts syms sr index parent_ts in
        let rhst = minimise syms.dfns rhst in
        let lhst = match lhst with |`BTYP_lvalue t -> t | t -> t in
        if type_match syms.dfns lhst rhst
        then tack (`BEXE_init (sr,index, (e',rhst)))
        else clierr sr
        (
          "[bind_exe] LHS["^s^"<"^si index^">]:\n"^
          string_of_btypecode syms.dfns lhst^
          "\n of initialisation must have same type as RHS:\n"^
          string_of_btypecode syms.dfns rhst^
          "\nunfolded LHS = " ^ sbt syms.dfns (unfold syms.dfns lhst) ^ 
          "\nenvironment type variables are " ^
          print_vs parent_vs
          
        )

    | `EXE_init (s,e) -> 
      begin match lun sr s with
      | FunctionEntry _ -> clierr sr "Can't init function constant"
      | NonFunctionEntry (index) -> 
        let e',rhst = be e in
        let lhst = typeofindex_with_ts syms sr index parent_ts in
        let rhst = minimise syms.dfns rhst in
        let lhst = match lhst with |`BTYP_lvalue t -> t | t -> t in
        (*
        print_endline ("Checking type match " ^ sbt syms.dfns lhst ^ " ?= " ^ sbt syms.dfns rhst);
        *)
        if type_match syms.dfns lhst rhst
        then tack (`BEXE_init (sr,index, (e',rhst)))
        else clierr sr
        (
          "[bind_exe] LHS["^s^"<"^si index^">]:\n"^
          string_of_btypecode syms.dfns lhst^
          "\n of initialisation must have same type as RHS:\n"^
          string_of_btypecode syms.dfns rhst^
          "\nunfolded LHS = " ^ sbt syms.dfns (unfold syms.dfns lhst) ^ 
          "\nenvironment type variables are " ^
          print_vs parent_vs
          
        )
      end

    | `EXE_assign (l,r) -> 
      let (_,lt) as bel = be l in
      begin match lt with 
      |  `BTYP_lvalue _ ->
         tack (`BEXE_assign (sr,bel, be r))
      | _ -> clierr sr "LHS must be lvalue"
      end

      (*
      begin match bel with
      | `BEXPR_name (index,_),_ -> 
        let {symdef=entry; id=id} = Hashtbl.find syms.dfns index in
        begin match entry with
        | `SYMDEF_var _ -> ()
        | `SYMDEF_val _ -> clierr sr ("Can't assign into value " ^ id)
        | `SYMDEF_parameter _ -> clierr sr ("Can't assign into parameter value " ^ id)
        | _ -> clierr sr ("[bexe] assign requires variable, got " ^ id)
        end
      | `BEXPR_deref _,_ -> ()

      | `BEXPR_apply_prim (i,_,_),_ -> 
        let {symdef=entry; id=id; vs=vs} = Hashtbl.find syms.dfns i in
        begin match entry with 
        | `SYMDEF_fun (_,t,_,_) -> 
          begin match t with
          | `TYP_lvalue _ -> ()
          | _ -> 
            print_endline 
            (
              "WARNING: assign to application of primitive "^
              id^
              " not declared to return an lvalue"
            )
          end
        | _ -> 
          failwith 
          (
            "[bexe]Expected prim apply to apply a primitive fun, got: " ^
            string_of_symdef entry id vs
          )
        end
      | _ -> 
        print_endline ("Assign to non variable..(is it an lvalue?)" ^ sbe syms.dfns bel);
        ()
      end
      ;
      tack (`BEXE_assign (sr,bel, be r))
      *)


  in 
  List.iter bind_exe exes;
  let bound_exes = List.rev !bound_exes in 
  (*
  print_endline ""
  ;
  List.iter 
    (fun x -> print_endline (string_of_bexe syms.dfns 1 x)) 
    bound_exes
  ;
  print_endline ""
  ;
  print_endline "BINDING COMPLETE"
  ;
  *)

  (* No function return statements found: it must be a procedure,
     so unify void [just a comparison with void .. heh!]
  *)
  if !return_count = 0 then
  begin
    if do_unify syms !ret_type `BTYP_void 
    then
      ret_type := varmap_subst syms.varmap !ret_type
    else
      clierr sr 
      (
        "procedure " ^id^" has non-void return type"
      )
  end
  ;

  begin match !ret_type with
  | `BTYP_void ->
    if 
      not !reachable && 
      !proc_return_count = 0 && 
      syms.compiler_options.print_flag
    then print_endline 
    (
      "WARNING: procedure " ^id^
      " has no explicit return and doesn't drop thru end," ^
      "\npossible infinite loop"
    )
  | _ ->
    if !reachable then begin 
      (* this is now a hard error .. 
         functions must manifestly return. We have to be careful
         generating code where the compiler cannot deduce 
         that a final branch cannot be taken .. the user,
         however, is required to supply a dead code assertion
         to prevent the error.
      *)
      clierr sr
      (
        "[bind_exes]: function "^id^" drops off end, missing return statement"
      )
      (*
      ;
      print_endline "[DEBUG] Instruction sequence is:";
      iter (fun exe -> print_endline (string_of_bexe syms.dfns 0 exe)) bound_exes
      *)
    end
  end
  ;
  !ret_type,bound_exes


