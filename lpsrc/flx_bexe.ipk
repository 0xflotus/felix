@head(1,'Bind executable statements')
@h = tangler("src/flx_bexe.mli")
@select(h)
open Flx_ast
open Flx_types
open Flx_mtypes1

val bind_exes:
  sym_state_t ->
  env_t ->
  range_srcref ->
  (range_srcref * exe_t) list ->
  btypecode_t ->
  string ->
  bid_t ->
  (string * int) list ->
  btypecode_t * bexe_t list

@h = tangler("src/flx_bexe.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_print
open Flx_mtypes1
open Flx_mtypes2
open Flx_typing
open Flx_lookup
open Flx_mbind
open Flx_srcref
open Flx_unify
open Flx_exceptions
open List

let rec check_if_parent syms child parent =
  if child = parent then true
  else
      match Hashtbl.find syms.dfns child with
      | {parent=Some parent} -> check_if_parent syms child parent
      | {parent=None} -> false

let cal_call syms sr ((p,pt) as tbe1) ((_,argt) as tbe2) =
  match unfold pt with
  | `BTYP_function (t, `BTYP_void) -> 
    if t = argt 
    then 
      ( 
        match p with 
        | `BEXPR_closure (i,ts) -> 
          begin match Hashtbl.find syms.dfns i with
          | {symdef=`SYMDEF_fun _ } -> 
            `BEXE_call_prim (sr,i,ts,tbe2)

          | {symdef=`SYMDEF_function _} ->
            `BEXE_call_direct (sr,i,ts,tbe2)

          | _ -> assert false
          end
        | _ -> 
          `BEXE_call (sr,(p,lower pt), tbe2)
      )
    else
      clierr sr
      (
        "[cal_call] Procedure " ^
        sbe syms.dfns tbe1 ^
        "\nof type " ^
        sbt syms.dfns pt ^
        "\napplied to argument " ^
        sbe syms.dfns tbe2 ^
        "\n of type " ^
        sbt syms.dfns argt ^
        "\nwhich doesn't agree with parameter type\n" ^
        sbt syms.dfns t 
      )

  | _ -> 
    clierr sr ("[cal_call] call non procedure, "^
    sbe syms.dfns (p,pt)
    ^"\ntype=" ^ sbt syms.dfns pt)

let cal_loop syms sr ((p,pt) as tbe1) ((_,argt) as tbe2) this =
  match unfold pt with
  | `BTYP_function (t, `BTYP_void) -> 
    if t = argt 
    then 
      match p with
      | `BEXPR_closure (i,ts) ->
        if check_if_parent syms i this
        then
          `BEXE_call_direct (sr,i, ts, tbe2)
        else
          clierr sr
          "[cal_loop] Loop target must be self or parent"

      | _ -> 
        clierr sr (
          "[cal_loop] Expected procedure closure, got "^
          string_of_bound_expression syms.dfns (p,pt)
        )
    else
      clierr sr
      (
        "[cal_loop] Procedure " ^
        sbe syms.dfns tbe1 ^
        "\nof type " ^
        sbt syms.dfns pt ^
        "\napplied to argument " ^
        sbe syms.dfns tbe2 ^
        "\n of type " ^
        sbt syms.dfns argt ^
        "\nwhich doesn't agree with parameter type\n" ^
        sbt syms.dfns t 
      )

  | _ -> 
    clierr sr ("[cal_loop] loop to non procedure, "^
    string_of_bound_expression syms.dfns (p,pt)
    ^"\ntype=" ^ string_of_btypecode syms.dfns pt)

exception Found of int

let print_vs vs =
  catmap "," (fun (s,i) -> s ^ "->" ^ si i) vs

let bind_regex syms env sr be return_count ret_type cls =
  (*
  print_endline "Binding regmatch";
  *) 
  let bd e = bind_regdef syms env [] [] e in

  (* create a unified regexp using REGEXP_code for expressions *)
  let f (e,c) = REGEXP_seq (e, REGEXP_code c) in
  let re = List.map f cls in
  let alt r1 r2 = REGEXP_alt (r1,r2) in
  let re = List.fold_right alt re REGEXP_sentinel in

  (* do lookups *)
  let re = bd re in

  (* generate transition matrix *)
  let alphabet, nstates, code_table, matrix = Flx_dfa.process_regexp re in
  let alphabet = CharSet.elements alphabet in

  (* bind RHS expressions *)
  let bcode = Hashtbl.create 97 in
  Hashtbl.iter
  (fun i c -> 
    let sr = src_of_expr c in
    let _,t as bt = be c in
    Hashtbl.add bcode i bt;
    incr return_count;
    if do_unify syms !ret_type t then
      ret_type := varmap_subst syms.varmap !ret_type
    else 
      clierr sr 
      (
        "Wrong return type,\nexpected : " ^ 
        string_of_btypecode syms.dfns !ret_type ^
        "\nbut we got " ^
        string_of_btypecode syms.dfns t ^ " in\n" ^
        short_string_of_src sr
      )
  )
  code_table
  ;
  alphabet,nstates, bcode,matrix

let bind_exes syms env sr exes ret_type id index parent_vs = 
  (*
  print_endline ("bind_exes.. env depth="^ string_of_int (List.length env));
  print_endline "Dumping Source Executables";
  print_endline "--------------------------";
  let soe e = Flx_print.string_of_expr e in
  List.iter 
    (fun (_,x) -> print_endline (string_of_exe 1 x))
    exes
  ;
  print_endline ""
  ;

  print_endline "Binding Executables";
  print_endline "-------------------";
  *)

  let parent_ts = map (fun (s,i) -> `BTYP_var i) parent_vs in
  let parent_ts_len = length parent_ts in
  let resolve_tvars ts =
    let n = length ts in
    (list_prefix parent_ts (parent_ts_len - n)) @ ts
  in
  let ret_type = ref ret_type in
  let be e : tbexpr_t = bind_expression syms env e in
  let lun sr n = lookup_name_in_env syms env sr n in
  let luqn n = lookup_qn_in_env syms env n in
  let bt sr t : btypecode_t = bind_type syms env sr t in
  let return_count = ref 0 in
  let reachable = ref true in
  let proc_return_count = ref 0 in

  let bound_exes : bexe_t list ref = ref [] in
  let tack x = bound_exes := x :: !bound_exes in
  let rec bind_exe (sr,x) = 
    (*
    print_endline ("EXE="^string_of_exe 1 x);
    *)
    if not !reachable then 
    begin 
      match x with 
      | `EXE_label _ -> ()
      | `EXE_comment _ -> ()
      | `EXE_nop _ -> ()
      | _ -> print_endline 
        (
          "WARNING: Unreachable code in "^id^": " ^ 
          string_of_exe 1 x ^ " in\n" ^ 
          short_string_of_src sr
        );
    end
    ;
    match x with
    | `EXE_comment s ->       tack (`BEXE_comment (sr,s))
    | `EXE_label s ->         reachable := true; tack (`BEXE_label (sr,s))
    | `EXE_goto s ->          reachable := false; tack (`BEXE_goto (sr,s))

    | `EXE_ifgoto (e,s) ->    
      let e',t = be e in
      if t = flx_bbool
      then tack (`BEXE_ifgoto (sr,(e',t), s))
      else 
        clierr (src_of_expr e)
        (
          "[bind_exes:ifgoto] Conditional requires bool argument, got " ^
          string_of_btypecode syms.dfns t
        )

    | `EXE_ifnotgoto (e,s) -> 
      let e',t = be e in
      if t = flx_bbool
      then tack (`BEXE_ifnotgoto (sr,(e',t), s))
      else 
        clierr (src_of_expr e)
        (
          "[bind_exes:ifnotgoto] Conditional requires bool argument, got " ^
          string_of_btypecode syms.dfns t ^ " in\n" ^
          short_string_of_src sr
        )

    | `EXE_loop (n,e2) ->
      let be2,t2 = be e2 in
      let tbe1 =
         lookup_qn_with_sig 
         syms 
         sr sr 
         env [] 
         (`AST_name(sr,n,[]) : qualified_name_t)
         t2 
      in  
        (* reverse order .. *)
        tack (`BEXE_proc_return sr);
        (* note cal_loop actually generates a call .. *)
        tack (cal_loop syms sr tbe1 (be2,t2) index)

    | `EXE_jump (a,b) ->
      incr proc_return_count;
      bind_exe (sr,`EXE_call (a,b));
      bind_exe  (sr,`EXE_proc_return)

    | `EXE_call (#suffixed_name_t as sn, e2) -> (* OVERLOADING *)
      let sr = src_of_expr sn in
      let be2,t2 = be e2 in
      let (be1,t1) as tbe1 =
         match sn with
         | #qualified_name_t as qn ->
           lookup_qn_with_sig 
           syms 
           sr sr 
           env [] 
           qn t2 
         | _ -> be sn
      in  
        tack (cal_call syms sr tbe1 (be2,t2))

    | `EXE_call (p,e) ->
      let p',pt' = be p and e',et' = be e in
      tack (cal_call syms sr (p', pt') (e', et'))

    | `EXE_read s ->          
      let dummy_sr = ("bind exes",0,0,0,0) in
      begin match lun dummy_sr s with
      | NonFunctionEntry (index) -> tack (`BEXE_read (sr,index))
      | FunctionEntry _ -> failwith "Can't read function!"
      end

    | `EXE_proc_return ->
      incr proc_return_count;
      reachable := false;
      if do_unify syms !ret_type `BTYP_void 
      then 
        begin
          ret_type := varmap_subst syms.varmap !ret_type;
          tack (`BEXE_proc_return sr)
        end
      else
        clierr sr 
        (
          "function " ^id^" has void return type"
        )

    | `EXE_fun_return e ->        
      reachable := false;
      incr return_count;
      let e',t' = be e in
      if do_unify syms !ret_type t' then begin
        ret_type := varmap_subst syms.varmap !ret_type;
        tack (`BEXE_fun_return (sr,(e',lower t')))
      end 
      else
        clierr sr
        (
          "Wrong return type,\nexpected : " ^ 
          string_of_btypecode syms.dfns !ret_type ^
          "\nbut we got " ^
          string_of_btypecode syms.dfns t'
        )

    | `EXE_nop s ->           tack (`BEXE_nop (sr,s))
    | `EXE_code s ->          tack (`BEXE_code (sr,s))
    | `EXE_noreturn_code s ->  reachable := false; tack (`BEXE_code (sr,s))

    | `EXE_init (s,e) -> 
      begin match lun sr s with
      | FunctionEntry _ -> clierr sr "Can't init function constant"
      | NonFunctionEntry (index) -> 
        (*
        print_endline "Binding RHS of initialisation with bind_expression";
        *)
        let e',rhst = be e in

        (*
        print_endline "Binding LHS of initialistion with typeofindex";
        *)
        let lhst = typeofindex_with_ts syms index parent_ts in
        let rhst = minimise rhst in
        if type_eq lhst rhst
        then tack (`BEXE_init (sr,index, (e',rhst)))
        else clierr sr
        (
          "[bind_exe] LHS["^s^"<"^si index^">:"^string_of_btypecode syms.dfns lhst^
          " of initialisation must have same type as RHS("^
          string_of_btypecode syms.dfns rhst^
          ")" ^
          " unfolded LHS = " ^ sbt syms.dfns (unfold lhst) ^ 
          "\nenvironment type variables are " ^
          print_vs parent_vs
          
        )
      end

    | `EXE_assign (l,r) -> 
      tack (`BEXE_assign (sr,be l, be r))

    | `EXE_reglex (p1,p2,cls) ->
      reachable := false;
      let p1 = be p1 in
      let p2 = be p2 in
      let regex_args = bind_regex syms env sr be return_count ret_type cls in
      tack (`BEXE_reglex (sr,p1,p2,regex_args))

    | `EXE_regmatch (e,cls) ->  
      reachable := false;
      let e = be e in
      let regex_args = bind_regex syms env sr be return_count ret_type cls in
      tack (`BEXE_regmatch (sr,e,regex_args))

  in 
  List.iter bind_exe exes;
  let bound_exes = List.rev !bound_exes in 
  (*
  print_endline ""
  ;
  List.iter 
    (fun x -> print_endline (string_of_bexe syms.dfns 1 x)) 
    bound_exes
  ;
  print_endline ""
  ;
  print_endline "BINDING COMPLETE"
  ;
  *)

  (* No function return statements found: it must be a procedure,
     so unify void [just a comparison with void .. heh!]
  *)
  if !return_count = 0 then
  begin
    if do_unify syms !ret_type `BTYP_void 
    then
      ret_type := varmap_subst syms.varmap !ret_type
    else
      clierr sr 
      (
        "procedure " ^id^" has non-void return type"
      )
  end
  ;

  begin match !ret_type with
  | `BTYP_void ->
    if not !reachable && !proc_return_count = 0
    then print_endline 
    (
      "WARNING: procedure " ^id^" has no explicit return and doesn't drop thru end," ^
      "\npossible infinite loop in\n" ^
      long_string_of_src sr
    )
  | _ ->
    if !reachable 
    then print_endline 
    (
      "WARNING: function "^id^" drops off end, possible missing return statement in\n" ^
      long_string_of_src sr
    );
  end
  ;
  !ret_type,bound_exes


