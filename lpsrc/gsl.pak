@head(1,'Gnu Scientific Library')
@select(tangler("cpkgs/target/gsl.py"))
execfile("config"+os.sep+"config.py")
try:
  cload(globals(),"target_gsl")
except:
  HAVE_GSL=TARGET_CXX.check_header_exists(xqt,'gsl.h')
  f=cwrite('target_gsl')
  pa(f,locals(),"HAVE_GSL")
  f.close()
  cload(globals(),"target_gsl")


@h = tangler('spkgs/gsl.py')
@select(h)
execfile("cpkgs"+os.sep+"target"+os.sep+"gsl.py")
if HAVE_GSL:
  iscr_source = ['lpsrc/gsl.pak']
  weaver_directory = 'doc/rtl/gsl/'

@h = tangler('config/gsl.fpc')
@select(h)
provides_dlib: -lgsl
provides_slib: -lgsl

@h=tangler('lib/gsl/gsl_blas_lib.flx')
@select(h)
//Module        : gsl_blas_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_blas.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLAS_H__
header '#include "gsl_blas.h"';

//INCLUDES
include "gsl_blas_types_lib";
include "gsl_complex_lib";
include "gsl_matrix_complex_double_lib";
include "gsl_matrix_complex_float_lib";
include "gsl_matrix_double_lib";
include "gsl_matrix_float_lib";
include "gsl_vector_complex_double_lib";
include "gsl_vector_complex_float_lib";
include "gsl_vector_double_lib";
include "gsl_vector_float_lib";

module gsl_blas_h
{
  open C_hack;
  open gsl_blas_types_h;
  open gsl_complex_h;
  open gsl_matrix_complex_double_h;
  open gsl_matrix_complex_float_h;
  open gsl_matrix_double_h;
  open gsl_matrix_float_h;
  open gsl_vector_complex_double_h;
  open gsl_vector_complex_float_h;
  open gsl_vector_double_h;
  open gsl_vector_float_h;
  
  //PROCEDURES
  proc gsl_blas_cscal: gsl_complex_float * ptr[gsl_vector_complex_float];
  proc gsl_blas_csscal: float * ptr[gsl_vector_complex_float];
  proc gsl_blas_dscal: double * ptr[gsl_vector];
  proc gsl_blas_sscal: float * ptr[gsl_vector_float];
  proc gsl_blas_zdscal: double * ptr[gsl_vector_complex];
  proc gsl_blas_zscal: gsl_complex * ptr[gsl_vector_complex];
  
  //FUNCTIONS
  fun gsl_blas_caxpy: gsl_complex_float * cptr[gsl_vector_complex_float] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_ccopy: cptr[gsl_vector_complex_float] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_cdotc: cptr[gsl_vector_complex_float] * cptr[gsl_vector_complex_float] * ptr[gsl_complex_float] -> int;
  fun gsl_blas_cdotu: cptr[gsl_vector_complex_float] * cptr[gsl_vector_complex_float] * ptr[gsl_complex_float] -> int;
  fun gsl_blas_cgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] * gsl_complex_float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_cgemv: CBLAS_TRANSPOSE_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_vector_complex_float] * gsl_complex_float * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_cgerc: gsl_complex_float * cptr[gsl_vector_complex_float] * cptr[gsl_vector_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_cgeru: gsl_complex_float * cptr[gsl_vector_complex_float] * cptr[gsl_vector_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_chemm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] * gsl_complex_float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_chemv: CBLAS_UPLO_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_vector_complex_float] * gsl_complex_float * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_cher: CBLAS_UPLO_t * float * cptr[gsl_vector_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_cher2: CBLAS_UPLO_t * gsl_complex_float * cptr[gsl_vector_complex_float] * cptr[gsl_vector_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_cher2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] * float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_cherk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * float * cptr[gsl_matrix_complex_float] * float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_cswap: ptr[gsl_vector_complex_float] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_csymm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] * gsl_complex_float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_csyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] * gsl_complex_float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_csyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * gsl_complex_float * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_ctrmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_ctrmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix_complex_float] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_ctrsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex_float * cptr[gsl_matrix_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_blas_ctrsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix_complex_float] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_blas_dasum: cptr[gsl_vector] -> double;
  fun gsl_blas_daxpy: double * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_blas_dcopy: cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_blas_ddot: cptr[gsl_vector] * cptr[gsl_vector] * ptr[double] -> int;
  fun gsl_blas_dgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * double * cptr[gsl_matrix] * cptr[gsl_matrix] * double * ptr[gsl_matrix] -> int;
  fun gsl_blas_dgemv: CBLAS_TRANSPOSE_t * double * cptr[gsl_matrix] * cptr[gsl_vector] * double * ptr[gsl_vector] -> int;
  fun gsl_blas_dger: double * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_matrix] -> int;
  fun gsl_blas_dnrm2: cptr[gsl_vector] -> double;
  fun gsl_blas_drot: ptr[gsl_vector] * ptr[gsl_vector] * double * double -> int;
  fun gsl_blas_drotg: ptr[double] * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_blas_drotm: ptr[gsl_vector] * ptr[gsl_vector] * cptr[double] -> int;
  fun gsl_blas_drotmg: ptr[double] * ptr[double] * ptr[double] * double * ptr[double] -> int;
  fun gsl_blas_dsdot: cptr[gsl_vector_float] * cptr[gsl_vector_float] * ptr[double] -> int;
  fun gsl_blas_dswap: ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_blas_dsymm: CBLAS_SIDE_t * CBLAS_UPLO_t * double * cptr[gsl_matrix] * cptr[gsl_matrix] * double * ptr[gsl_matrix] -> int;
  fun gsl_blas_dsymv: CBLAS_UPLO_t * double * cptr[gsl_matrix] * cptr[gsl_vector] * double * ptr[gsl_vector] -> int;
  fun gsl_blas_dsyr: CBLAS_UPLO_t * double * cptr[gsl_vector] * ptr[gsl_matrix] -> int;
  fun gsl_blas_dsyr2: CBLAS_UPLO_t * double * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_matrix] -> int;
  fun gsl_blas_dsyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * double * cptr[gsl_matrix] * cptr[gsl_matrix] * double * ptr[gsl_matrix] -> int;
  fun gsl_blas_dsyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * double * cptr[gsl_matrix] * double * ptr[gsl_matrix] -> int;
  fun gsl_blas_dtrmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * double * cptr[gsl_matrix] * ptr[gsl_matrix] -> int;
  fun gsl_blas_dtrmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_blas_dtrsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * double * cptr[gsl_matrix] * ptr[gsl_matrix] -> int;
  fun gsl_blas_dtrsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_blas_dzasum: cptr[gsl_vector_complex] -> double;
  fun gsl_blas_dznrm2: cptr[gsl_vector_complex] -> double;
  fun gsl_blas_icamax: cptr[gsl_vector_complex_float] -> CBLAS_INDEX_t;
  fun gsl_blas_idamax: cptr[gsl_vector] -> CBLAS_INDEX_t;
  fun gsl_blas_isamax: cptr[gsl_vector_float] -> CBLAS_INDEX_t;
  fun gsl_blas_izamax: cptr[gsl_vector_complex] -> CBLAS_INDEX_t;
  fun gsl_blas_sasum: cptr[gsl_vector_float] -> float;
  fun gsl_blas_saxpy: float * cptr[gsl_vector_float] * ptr[gsl_vector_float] -> int;
  fun gsl_blas_scasum: cptr[gsl_vector_complex_float] -> float;
  fun gsl_blas_scnrm2: cptr[gsl_vector_complex_float] -> float;
  fun gsl_blas_scopy: cptr[gsl_vector_float] * ptr[gsl_vector_float] -> int;
  fun gsl_blas_sdot: cptr[gsl_vector_float] * cptr[gsl_vector_float] * ptr[float] -> int;
  fun gsl_blas_sdsdot: float * cptr[gsl_vector_float] * cptr[gsl_vector_float] * ptr[float] -> int;
  fun gsl_blas_sgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * float * cptr[gsl_matrix_float] * cptr[gsl_matrix_float] * float * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_sgemv: CBLAS_TRANSPOSE_t * float * cptr[gsl_matrix_float] * cptr[gsl_vector_float] * float * ptr[gsl_vector_float] -> int;
  fun gsl_blas_sger: float * cptr[gsl_vector_float] * cptr[gsl_vector_float] * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_snrm2: cptr[gsl_vector_float] -> float;
  fun gsl_blas_srot: ptr[gsl_vector_float] * ptr[gsl_vector_float] * float * float -> int;
  fun gsl_blas_srotg: ptr[float] * ptr[float] * ptr[float] * ptr[float] -> int;
  fun gsl_blas_srotm: ptr[gsl_vector_float] * ptr[gsl_vector_float] * cptr[float] -> int;
  fun gsl_blas_srotmg: ptr[float] * ptr[float] * ptr[float] * float * ptr[float] -> int;
  fun gsl_blas_sswap: ptr[gsl_vector_float] * ptr[gsl_vector_float] -> int;
  fun gsl_blas_ssymm: CBLAS_SIDE_t * CBLAS_UPLO_t * float * cptr[gsl_matrix_float] * cptr[gsl_matrix_float] * float * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_ssymv: CBLAS_UPLO_t * float * cptr[gsl_matrix_float] * cptr[gsl_vector_float] * float * ptr[gsl_vector_float] -> int;
  fun gsl_blas_ssyr: CBLAS_UPLO_t * float * cptr[gsl_vector_float] * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_ssyr2: CBLAS_UPLO_t * float * cptr[gsl_vector_float] * cptr[gsl_vector_float] * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_ssyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * float * cptr[gsl_matrix_float] * cptr[gsl_matrix_float] * float * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_ssyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * float * cptr[gsl_matrix_float] * float * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_strmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * float * cptr[gsl_matrix_float] * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_strmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix_float] * ptr[gsl_vector_float] -> int;
  fun gsl_blas_strsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * float * cptr[gsl_matrix_float] * ptr[gsl_matrix_float] -> int;
  fun gsl_blas_strsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix_float] * ptr[gsl_vector_float] -> int;
  fun gsl_blas_zaxpy: gsl_complex * cptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_blas_zcopy: cptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_blas_zdotc: cptr[gsl_vector_complex] * cptr[gsl_vector_complex] * ptr[gsl_complex] -> int;
  fun gsl_blas_zdotu: cptr[gsl_vector_complex] * cptr[gsl_vector_complex] * ptr[gsl_complex] -> int;
  fun gsl_blas_zgemm: CBLAS_TRANSPOSE_t * CBLAS_TRANSPOSE_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] * gsl_complex * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zgemv: CBLAS_TRANSPOSE_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_vector_complex] * gsl_complex * ptr[gsl_vector_complex] -> int;
  fun gsl_blas_zgerc: gsl_complex * cptr[gsl_vector_complex] * cptr[gsl_vector_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zgeru: gsl_complex * cptr[gsl_vector_complex] * cptr[gsl_vector_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zhemm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] * gsl_complex * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zhemv: CBLAS_UPLO_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_vector_complex] * gsl_complex * ptr[gsl_vector_complex] -> int;
  fun gsl_blas_zher: CBLAS_UPLO_t * double * cptr[gsl_vector_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zher2: CBLAS_UPLO_t * gsl_complex * cptr[gsl_vector_complex] * cptr[gsl_vector_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zher2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] * double * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zherk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * double * cptr[gsl_matrix_complex] * double * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zswap: ptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_blas_zsymm: CBLAS_SIDE_t * CBLAS_UPLO_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] * gsl_complex * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zsyr2k: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex * cptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] * gsl_complex * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_zsyrk: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * gsl_complex * cptr[gsl_matrix_complex] * gsl_complex * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_ztrmm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex * cptr[gsl_matrix_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_ztrmv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_blas_ztrsm: CBLAS_SIDE_t * CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * gsl_complex * cptr[gsl_matrix_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_blas_ztrsv: CBLAS_UPLO_t * CBLAS_TRANSPOSE_t * CBLAS_DIAG_t * cptr[gsl_matrix_complex] * ptr[gsl_vector_complex] -> int;
}
@h=tangler('lib/gsl/gsl_blas_types_lib.flx')
@select(h)
//Module        : gsl_blas_types_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_blas_types.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLAS_TYPES_H__
header '#include "gsl_blas_types.h"';

module gsl_blas_types_h
{
  open C_hack;
  
  //TYPE ALIASES
  typedef CBLAS_ORDER_t = int;
  typedef CBLAS_SIDE_t = int;
  typedef CBLAS_UPLO_t = int;
  typedef CBLAS_INDEX_t = size;
  typedef CBLAS_TRANSPOSE_t = int;
  typedef CBLAS_DIAG_t = int;
  
  //ENUMERATION CONSTANTS
  const CblasConjTrans: int = 'CblasConjTrans';
  const CblasRight: int = 'CblasRight';
  const CblasLower: int = 'CblasLower';
  const CblasUnit: int = 'CblasUnit';
  const CblasRowMajor: int = 'CblasRowMajor';
  const CblasTrans: int = 'CblasTrans';
  const CblasUpper: int = 'CblasUpper';
  const CblasColMajor: int = 'CblasColMajor';
  const CblasNoTrans: int = 'CblasNoTrans';
  const CblasNonUnit: int = 'CblasNonUnit';
  const CblasLeft: int = 'CblasLeft';
}
@h=tangler('lib/gsl/gsl_block_char_lib.flx')
@select(h)
//Module        : gsl_block_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_CHAR_H__
header '#include "gsl_block_char.h"';

//INCLUDES
include "gsl_block_char_struct_lib";

module gsl_block_char_h
{
  open C_hack;
  open gsl_block_char_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_char_struct {
    size: size;
    data: ptr[char];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_char = gsl_block_char_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_char_struct = gsl_block_char_struct;
  
  //PROCEDURES
  proc gsl_block_char_free: ptr[gsl_block_char];
  
  //FUNCTIONS
  fun gsl_block_char_alloc: size -> ptr[gsl_block_char];
  fun gsl_block_char_calloc: size -> ptr[gsl_block_char];
  fun gsl_block_char_data: cptr[gsl_block_char] -> ptr[char];
  fun gsl_block_char_fprintf: ptr[FILE] * cptr[gsl_block_char] * cptr[char] -> int;
  fun gsl_block_char_fread: ptr[FILE] * ptr[gsl_block_char] -> int;
  fun gsl_block_char_fscanf: ptr[FILE] * ptr[gsl_block_char] -> int;
  fun gsl_block_char_fwrite: ptr[FILE] * cptr[gsl_block_char] -> int;
  fun gsl_block_char_raw_fprintf: ptr[FILE] * cptr[char] * size * size * cptr[char] -> int;
  fun gsl_block_char_raw_fread: ptr[FILE] * ptr[char] * size * size -> int;
  fun gsl_block_char_raw_fscanf: ptr[FILE] * ptr[char] * size * size -> int;
  fun gsl_block_char_raw_fwrite: ptr[FILE] * cptr[char] * size * size -> int;
  fun gsl_block_char_size: cptr[gsl_block_char] -> size;
}
@h=tangler('lib/gsl/gsl_block_char_struct_lib.flx')
@select(h)
//Module        : gsl_block_char_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_char_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_char_struct"';

module gsl_block_char_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_complex_double_lib.flx')
@select(h)
//Module        : gsl_block_complex_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_COMPLEX_DOUBLE_H__
header '#include "gsl_block_complex_double.h"';

//INCLUDES
include "gsl_block_complex_struct_lib";

module gsl_block_complex_double_h
{
  open C_hack;
  open gsl_block_complex_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_complex_struct {
    size: size;
    data: ptr[double];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_complex = gsl_block_complex_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_complex_struct = gsl_block_complex_struct;
  
  //PROCEDURES
  proc gsl_block_complex_free: ptr[gsl_block_complex];
  
  //FUNCTIONS
  fun gsl_block_complex_alloc: size -> ptr[gsl_block_complex];
  fun gsl_block_complex_calloc: size -> ptr[gsl_block_complex];
  fun gsl_block_complex_data: cptr[gsl_block_complex] -> ptr[double];
  fun gsl_block_complex_fprintf: ptr[FILE] * cptr[gsl_block_complex] * cptr[char] -> int;
  fun gsl_block_complex_fread: ptr[FILE] * ptr[gsl_block_complex] -> int;
  fun gsl_block_complex_fscanf: ptr[FILE] * ptr[gsl_block_complex] -> int;
  fun gsl_block_complex_fwrite: ptr[FILE] * cptr[gsl_block_complex] -> int;
  fun gsl_block_complex_raw_fprintf: ptr[FILE] * cptr[double] * size * size * cptr[char] -> int;
  fun gsl_block_complex_raw_fread: ptr[FILE] * ptr[double] * size * size -> int;
  fun gsl_block_complex_raw_fscanf: ptr[FILE] * ptr[double] * size * size -> int;
  fun gsl_block_complex_raw_fwrite: ptr[FILE] * cptr[double] * size * size -> int;
  fun gsl_block_complex_size: cptr[gsl_block_complex] -> size;
}
@h=tangler('lib/gsl/gsl_block_complex_float_lib.flx')
@select(h)
//Module        : gsl_block_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_COMPLEX_FLOAT_H__
header '#include "gsl_block_complex_float.h"';

//INCLUDES
include "gsl_block_complex_float_struct_lib";

module gsl_block_complex_float_h
{
  open C_hack;
  open gsl_block_complex_float_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_complex_float_struct {
    size: size;
    data: ptr[float];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_complex_float = gsl_block_complex_float_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_complex_float_struct = gsl_block_complex_float_struct;
  
  //PROCEDURES
  proc gsl_block_complex_float_free: ptr[gsl_block_complex_float];
  
  //FUNCTIONS
  fun gsl_block_complex_float_alloc: size -> ptr[gsl_block_complex_float];
  fun gsl_block_complex_float_calloc: size -> ptr[gsl_block_complex_float];
  fun gsl_block_complex_float_data: cptr[gsl_block_complex_float] -> ptr[float];
  fun gsl_block_complex_float_fprintf: ptr[FILE] * cptr[gsl_block_complex_float] * cptr[char] -> int;
  fun gsl_block_complex_float_fread: ptr[FILE] * ptr[gsl_block_complex_float] -> int;
  fun gsl_block_complex_float_fscanf: ptr[FILE] * ptr[gsl_block_complex_float] -> int;
  fun gsl_block_complex_float_fwrite: ptr[FILE] * cptr[gsl_block_complex_float] -> int;
  fun gsl_block_complex_float_raw_fprintf: ptr[FILE] * cptr[float] * size * size * cptr[char] -> int;
  fun gsl_block_complex_float_raw_fread: ptr[FILE] * ptr[float] * size * size -> int;
  fun gsl_block_complex_float_raw_fscanf: ptr[FILE] * ptr[float] * size * size -> int;
  fun gsl_block_complex_float_raw_fwrite: ptr[FILE] * cptr[float] * size * size -> int;
  fun gsl_block_complex_float_size: cptr[gsl_block_complex_float] -> size;
}
@h=tangler('lib/gsl/gsl_block_complex_float_struct_lib.flx')
@select(h)
//Module        : gsl_block_complex_float_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex_float_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_complex_float_struct"';

module gsl_block_complex_float_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_complex_lib.flx')
@select(h)
//Module        : gsl_block_complex_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_COMPLEX_LONG_DOUBLE_AT(zv,i) ((gsl_complex_long_double*)&((zv)->data[2*(i)]))
//#define GSL_COMPLEX_FLOAT_AT(zv,i) ((gsl_complex_float*)&((zv)->data[2*(i)]))
//#define GSL_COMPLEX_AT(zv,i) ((gsl_complex*)&((zv)->data[2*(i)]))
//#define GSL_BLOCK_COMPLEX(zv, i) (GSL_COMPLEX_AT((zv),(i)))
//#define GSL_BLOCK_COMPLEX(zv, i) (((i) >= (zv)->size ? (gsl_error ("index out of range", __FILE__, __LINE__, GSL_EINVAL), 0):0 , *GSL_COMPLEX_AT((zv),(i))))
//#define GSL_BLOCK_IMAG(z, i)  ((z)->data[2*(i) + 1])
//#define GSL_BLOCK_REAL(z, i)  ((z)->data[2*(i)])
//#define __GSL_BLOCK_COMPLEX__
header '#include "gsl_block_complex.h"';

module gsl_block_complex_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_complex_long_double_lib.flx')
@select(h)
//Module        : gsl_block_complex_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_COMPLEX_LONG_DOUBLE_H__
header '#include "gsl_block_complex_long_double.h"';

//INCLUDES
include "gsl_block_complex_long_double_struct_lib";

module gsl_block_complex_long_double_h
{
  open C_hack;
  open gsl_block_complex_long_double_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_complex_long_double_struct {
    size: size;
    data: ptr[ldouble];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_complex_long_double = gsl_block_complex_long_double_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_complex_long_double_struct = gsl_block_complex_long_double_struct;
  
  //PROCEDURES
  proc gsl_block_complex_long_double_free: ptr[gsl_block_complex_long_double];
  
  //FUNCTIONS
  fun gsl_block_complex_long_double_alloc: size -> ptr[gsl_block_complex_long_double];
  fun gsl_block_complex_long_double_calloc: size -> ptr[gsl_block_complex_long_double];
  fun gsl_block_complex_long_double_data: cptr[gsl_block_complex_long_double] -> ptr[ldouble];
  fun gsl_block_complex_long_double_fprintf: ptr[FILE] * cptr[gsl_block_complex_long_double] * cptr[char] -> int;
  fun gsl_block_complex_long_double_fread: ptr[FILE] * ptr[gsl_block_complex_long_double] -> int;
  fun gsl_block_complex_long_double_fscanf: ptr[FILE] * ptr[gsl_block_complex_long_double] -> int;
  fun gsl_block_complex_long_double_fwrite: ptr[FILE] * cptr[gsl_block_complex_long_double] -> int;
  fun gsl_block_complex_long_double_raw_fprintf: ptr[FILE] * cptr[ldouble] * size * size * cptr[char] -> int;
  fun gsl_block_complex_long_double_raw_fread: ptr[FILE] * ptr[ldouble] * size * size -> int;
  fun gsl_block_complex_long_double_raw_fscanf: ptr[FILE] * ptr[ldouble] * size * size -> int;
  fun gsl_block_complex_long_double_raw_fwrite: ptr[FILE] * cptr[ldouble] * size * size -> int;
  fun gsl_block_complex_long_double_size: cptr[gsl_block_complex_long_double] -> size;
}
@h=tangler('lib/gsl/gsl_block_complex_long_double_struct_lib.flx')
@select(h)
//Module        : gsl_block_complex_long_double_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex_long_double_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_complex_long_double_struct"';

module gsl_block_complex_long_double_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_complex_struct_lib.flx')
@select(h)
//Module        : gsl_block_complex_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_complex_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_complex_struct"';

module gsl_block_complex_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_double_lib.flx')
@select(h)
//Module        : gsl_block_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_DOUBLE_H__
header '#include "gsl_block_double.h"';

//INCLUDES
include "gsl_block_struct_lib";

module gsl_block_double_h
{
  open C_hack;
  open gsl_block_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_struct {
    size: size;
    data: ptr[double];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block = gsl_block_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_struct = gsl_block_struct;
  
  //PROCEDURES
  proc gsl_block_free: ptr[gsl_block];
  
  //FUNCTIONS
  fun gsl_block_alloc: size -> ptr[gsl_block];
  fun gsl_block_calloc: size -> ptr[gsl_block];
  fun gsl_block_data: cptr[gsl_block] -> ptr[double];
  fun gsl_block_fprintf: ptr[FILE] * cptr[gsl_block] * cptr[char] -> int;
  fun gsl_block_fread: ptr[FILE] * ptr[gsl_block] -> int;
  fun gsl_block_fscanf: ptr[FILE] * ptr[gsl_block] -> int;
  fun gsl_block_fwrite: ptr[FILE] * cptr[gsl_block] -> int;
  fun gsl_block_raw_fprintf: ptr[FILE] * cptr[double] * size * size * cptr[char] -> int;
  fun gsl_block_raw_fread: ptr[FILE] * ptr[double] * size * size -> int;
  fun gsl_block_raw_fscanf: ptr[FILE] * ptr[double] * size * size -> int;
  fun gsl_block_raw_fwrite: ptr[FILE] * cptr[double] * size * size -> int;
  fun gsl_block_size: cptr[gsl_block] -> size;
}
@h=tangler('lib/gsl/gsl_block_float_lib.flx')
@select(h)
//Module        : gsl_block_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_FLOAT_H__
header '#include "gsl_block_float.h"';

//INCLUDES
include "gsl_block_float_struct_lib";

module gsl_block_float_h
{
  open C_hack;
  open gsl_block_float_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_float_struct {
    size: size;
    data: ptr[float];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_float = gsl_block_float_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_float_struct = gsl_block_float_struct;
  
  //PROCEDURES
  proc gsl_block_float_free: ptr[gsl_block_float];
  
  //FUNCTIONS
  fun gsl_block_float_alloc: size -> ptr[gsl_block_float];
  fun gsl_block_float_calloc: size -> ptr[gsl_block_float];
  fun gsl_block_float_data: cptr[gsl_block_float] -> ptr[float];
  fun gsl_block_float_fprintf: ptr[FILE] * cptr[gsl_block_float] * cptr[char] -> int;
  fun gsl_block_float_fread: ptr[FILE] * ptr[gsl_block_float] -> int;
  fun gsl_block_float_fscanf: ptr[FILE] * ptr[gsl_block_float] -> int;
  fun gsl_block_float_fwrite: ptr[FILE] * cptr[gsl_block_float] -> int;
  fun gsl_block_float_raw_fprintf: ptr[FILE] * cptr[float] * size * size * cptr[char] -> int;
  fun gsl_block_float_raw_fread: ptr[FILE] * ptr[float] * size * size -> int;
  fun gsl_block_float_raw_fscanf: ptr[FILE] * ptr[float] * size * size -> int;
  fun gsl_block_float_raw_fwrite: ptr[FILE] * cptr[float] * size * size -> int;
  fun gsl_block_float_size: cptr[gsl_block_float] -> size;
}
@h=tangler('lib/gsl/gsl_block_float_struct_lib.flx')
@select(h)
//Module        : gsl_block_float_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_float_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_float_struct"';

module gsl_block_float_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_int_lib.flx')
@select(h)
//Module        : gsl_block_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_INT_H__
header '#include "gsl_block_int.h"';

//INCLUDES
include "gsl_block_int_struct_lib";

module gsl_block_int_h
{
  open C_hack;
  open gsl_block_int_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_int_struct {
    size: size;
    data: ptr[int];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_int = gsl_block_int_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_int_struct = gsl_block_int_struct;
  
  //PROCEDURES
  proc gsl_block_int_free: ptr[gsl_block_int];
  
  //FUNCTIONS
  fun gsl_block_int_alloc: size -> ptr[gsl_block_int];
  fun gsl_block_int_calloc: size -> ptr[gsl_block_int];
  fun gsl_block_int_data: cptr[gsl_block_int] -> ptr[int];
  fun gsl_block_int_fprintf: ptr[FILE] * cptr[gsl_block_int] * cptr[char] -> int;
  fun gsl_block_int_fread: ptr[FILE] * ptr[gsl_block_int] -> int;
  fun gsl_block_int_fscanf: ptr[FILE] * ptr[gsl_block_int] -> int;
  fun gsl_block_int_fwrite: ptr[FILE] * cptr[gsl_block_int] -> int;
  fun gsl_block_int_raw_fprintf: ptr[FILE] * cptr[int] * size * size * cptr[char] -> int;
  fun gsl_block_int_raw_fread: ptr[FILE] * ptr[int] * size * size -> int;
  fun gsl_block_int_raw_fscanf: ptr[FILE] * ptr[int] * size * size -> int;
  fun gsl_block_int_raw_fwrite: ptr[FILE] * cptr[int] * size * size -> int;
  fun gsl_block_int_size: cptr[gsl_block_int] -> size;
}
@h=tangler('lib/gsl/gsl_block_int_struct_lib.flx')
@select(h)
//Module        : gsl_block_int_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_int_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_int_struct"';

module gsl_block_int_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_lib.flx')
@select(h)
//Module        : gsl_block_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_H__
header '#include "gsl_block.h"';

module gsl_block_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_long_double_lib.flx')
@select(h)
//Module        : gsl_block_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_LONG_DOUBLE_H__
header '#include "gsl_block_long_double.h"';

//INCLUDES
include "gsl_block_long_double_struct_lib";

module gsl_block_long_double_h
{
  open C_hack;
  open gsl_block_long_double_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_long_double_struct {
    size: size;
    data: ptr[ldouble];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_long_double = gsl_block_long_double_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_long_double_struct = gsl_block_long_double_struct;
  
  //PROCEDURES
  proc gsl_block_long_double_free: ptr[gsl_block_long_double];
  
  //FUNCTIONS
  fun gsl_block_long_double_alloc: size -> ptr[gsl_block_long_double];
  fun gsl_block_long_double_calloc: size -> ptr[gsl_block_long_double];
  fun gsl_block_long_double_data: cptr[gsl_block_long_double] -> ptr[ldouble];
  fun gsl_block_long_double_fprintf: ptr[FILE] * cptr[gsl_block_long_double] * cptr[char] -> int;
  fun gsl_block_long_double_fread: ptr[FILE] * ptr[gsl_block_long_double] -> int;
  fun gsl_block_long_double_fscanf: ptr[FILE] * ptr[gsl_block_long_double] -> int;
  fun gsl_block_long_double_fwrite: ptr[FILE] * cptr[gsl_block_long_double] -> int;
  fun gsl_block_long_double_raw_fprintf: ptr[FILE] * cptr[ldouble] * size * size * cptr[char] -> int;
  fun gsl_block_long_double_raw_fread: ptr[FILE] * ptr[ldouble] * size * size -> int;
  fun gsl_block_long_double_raw_fscanf: ptr[FILE] * ptr[ldouble] * size * size -> int;
  fun gsl_block_long_double_raw_fwrite: ptr[FILE] * cptr[ldouble] * size * size -> int;
  fun gsl_block_long_double_size: cptr[gsl_block_long_double] -> size;
}
@h=tangler('lib/gsl/gsl_block_long_double_struct_lib.flx')
@select(h)
//Module        : gsl_block_long_double_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_long_double_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_long_double_struct"';

module gsl_block_long_double_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_long_lib.flx')
@select(h)
//Module        : gsl_block_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_LONG_H__
header '#include "gsl_block_long.h"';

//INCLUDES
include "gsl_block_long_struct_lib";

module gsl_block_long_h
{
  open C_hack;
  open gsl_block_long_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_long_struct {
    size: size;
    data: ptr[long];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_long = gsl_block_long_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_long_struct = gsl_block_long_struct;
  
  //PROCEDURES
  proc gsl_block_long_free: ptr[gsl_block_long];
  
  //FUNCTIONS
  fun gsl_block_long_alloc: size -> ptr[gsl_block_long];
  fun gsl_block_long_calloc: size -> ptr[gsl_block_long];
  fun gsl_block_long_data: cptr[gsl_block_long] -> ptr[long];
  fun gsl_block_long_fprintf: ptr[FILE] * cptr[gsl_block_long] * cptr[char] -> int;
  fun gsl_block_long_fread: ptr[FILE] * ptr[gsl_block_long] -> int;
  fun gsl_block_long_fscanf: ptr[FILE] * ptr[gsl_block_long] -> int;
  fun gsl_block_long_fwrite: ptr[FILE] * cptr[gsl_block_long] -> int;
  fun gsl_block_long_raw_fprintf: ptr[FILE] * cptr[long] * size * size * cptr[char] -> int;
  fun gsl_block_long_raw_fread: ptr[FILE] * ptr[long] * size * size -> int;
  fun gsl_block_long_raw_fscanf: ptr[FILE] * ptr[long] * size * size -> int;
  fun gsl_block_long_raw_fwrite: ptr[FILE] * cptr[long] * size * size -> int;
  fun gsl_block_long_size: cptr[gsl_block_long] -> size;
}
@h=tangler('lib/gsl/gsl_block_long_struct_lib.flx')
@select(h)
//Module        : gsl_block_long_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_long_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_long_struct"';

module gsl_block_long_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_short_lib.flx')
@select(h)
//Module        : gsl_block_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_SHORT_H__
header '#include "gsl_block_short.h"';

//INCLUDES
include "gsl_block_short_struct_lib";

module gsl_block_short_h
{
  open C_hack;
  open gsl_block_short_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_short_struct {
    size: size;
    data: ptr[short];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_short = gsl_block_short_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_short_struct = gsl_block_short_struct;
  
  //PROCEDURES
  proc gsl_block_short_free: ptr[gsl_block_short];
  
  //FUNCTIONS
  fun gsl_block_short_alloc: size -> ptr[gsl_block_short];
  fun gsl_block_short_calloc: size -> ptr[gsl_block_short];
  fun gsl_block_short_data: cptr[gsl_block_short] -> ptr[short];
  fun gsl_block_short_fprintf: ptr[FILE] * cptr[gsl_block_short] * cptr[char] -> int;
  fun gsl_block_short_fread: ptr[FILE] * ptr[gsl_block_short] -> int;
  fun gsl_block_short_fscanf: ptr[FILE] * ptr[gsl_block_short] -> int;
  fun gsl_block_short_fwrite: ptr[FILE] * cptr[gsl_block_short] -> int;
  fun gsl_block_short_raw_fprintf: ptr[FILE] * cptr[short] * size * size * cptr[char] -> int;
  fun gsl_block_short_raw_fread: ptr[FILE] * ptr[short] * size * size -> int;
  fun gsl_block_short_raw_fscanf: ptr[FILE] * ptr[short] * size * size -> int;
  fun gsl_block_short_raw_fwrite: ptr[FILE] * cptr[short] * size * size -> int;
  fun gsl_block_short_size: cptr[gsl_block_short] -> size;
}
@h=tangler('lib/gsl/gsl_block_short_struct_lib.flx')
@select(h)
//Module        : gsl_block_short_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_short_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_short_struct"';

module gsl_block_short_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_struct_lib.flx')
@select(h)
//Module        : gsl_block_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_struct"';

module gsl_block_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_uchar_lib.flx')
@select(h)
//Module        : gsl_block_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_UCHAR_H__
header '#include "gsl_block_uchar.h"';

//INCLUDES
include "gsl_block_uchar_struct_lib";

module gsl_block_uchar_h
{
  open C_hack;
  open gsl_block_uchar_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_uchar_struct {
    size: size;
    data: ptr[utiny];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_uchar = gsl_block_uchar_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_uchar_struct = gsl_block_uchar_struct;
  
  //PROCEDURES
  proc gsl_block_uchar_free: ptr[gsl_block_uchar];
  
  //FUNCTIONS
  fun gsl_block_uchar_alloc: size -> ptr[gsl_block_uchar];
  fun gsl_block_uchar_calloc: size -> ptr[gsl_block_uchar];
  fun gsl_block_uchar_data: cptr[gsl_block_uchar] -> ptr[utiny];
  fun gsl_block_uchar_fprintf: ptr[FILE] * cptr[gsl_block_uchar] * cptr[char] -> int;
  fun gsl_block_uchar_fread: ptr[FILE] * ptr[gsl_block_uchar] -> int;
  fun gsl_block_uchar_fscanf: ptr[FILE] * ptr[gsl_block_uchar] -> int;
  fun gsl_block_uchar_fwrite: ptr[FILE] * cptr[gsl_block_uchar] -> int;
  fun gsl_block_uchar_raw_fprintf: ptr[FILE] * cptr[utiny] * size * size * cptr[char] -> int;
  fun gsl_block_uchar_raw_fread: ptr[FILE] * ptr[utiny] * size * size -> int;
  fun gsl_block_uchar_raw_fscanf: ptr[FILE] * ptr[utiny] * size * size -> int;
  fun gsl_block_uchar_raw_fwrite: ptr[FILE] * cptr[utiny] * size * size -> int;
  fun gsl_block_uchar_size: cptr[gsl_block_uchar] -> size;
}
@h=tangler('lib/gsl/gsl_block_uchar_struct_lib.flx')
@select(h)
//Module        : gsl_block_uchar_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_uchar_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_uchar_struct"';

module gsl_block_uchar_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_uint_lib.flx')
@select(h)
//Module        : gsl_block_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_UINT_H__
header '#include "gsl_block_uint.h"';

//INCLUDES
include "gsl_block_uint_struct_lib";

module gsl_block_uint_h
{
  open C_hack;
  open gsl_block_uint_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_uint_struct {
    size: size;
    data: ptr[uint];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_uint = gsl_block_uint_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_uint_struct = gsl_block_uint_struct;
  
  //PROCEDURES
  proc gsl_block_uint_free: ptr[gsl_block_uint];
  
  //FUNCTIONS
  fun gsl_block_uint_alloc: size -> ptr[gsl_block_uint];
  fun gsl_block_uint_calloc: size -> ptr[gsl_block_uint];
  fun gsl_block_uint_data: cptr[gsl_block_uint] -> ptr[uint];
  fun gsl_block_uint_fprintf: ptr[FILE] * cptr[gsl_block_uint] * cptr[char] -> int;
  fun gsl_block_uint_fread: ptr[FILE] * ptr[gsl_block_uint] -> int;
  fun gsl_block_uint_fscanf: ptr[FILE] * ptr[gsl_block_uint] -> int;
  fun gsl_block_uint_fwrite: ptr[FILE] * cptr[gsl_block_uint] -> int;
  fun gsl_block_uint_raw_fprintf: ptr[FILE] * cptr[uint] * size * size * cptr[char] -> int;
  fun gsl_block_uint_raw_fread: ptr[FILE] * ptr[uint] * size * size -> int;
  fun gsl_block_uint_raw_fscanf: ptr[FILE] * ptr[uint] * size * size -> int;
  fun gsl_block_uint_raw_fwrite: ptr[FILE] * cptr[uint] * size * size -> int;
  fun gsl_block_uint_size: cptr[gsl_block_uint] -> size;
}
@h=tangler('lib/gsl/gsl_block_uint_struct_lib.flx')
@select(h)
//Module        : gsl_block_uint_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_uint_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_uint_struct"';

module gsl_block_uint_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_ulong_lib.flx')
@select(h)
//Module        : gsl_block_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_ULONG_H__
header '#include "gsl_block_ulong.h"';

//INCLUDES
include "gsl_block_ulong_struct_lib";

module gsl_block_ulong_h
{
  open C_hack;
  open gsl_block_ulong_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_ulong_struct {
    size: size;
    data: ptr[ulong];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_ulong = gsl_block_ulong_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_ulong_struct = gsl_block_ulong_struct;
  
  //PROCEDURES
  proc gsl_block_ulong_free: ptr[gsl_block_ulong];
  
  //FUNCTIONS
  fun gsl_block_ulong_alloc: size -> ptr[gsl_block_ulong];
  fun gsl_block_ulong_calloc: size -> ptr[gsl_block_ulong];
  fun gsl_block_ulong_data: cptr[gsl_block_ulong] -> ptr[ulong];
  fun gsl_block_ulong_fprintf: ptr[FILE] * cptr[gsl_block_ulong] * cptr[char] -> int;
  fun gsl_block_ulong_fread: ptr[FILE] * ptr[gsl_block_ulong] -> int;
  fun gsl_block_ulong_fscanf: ptr[FILE] * ptr[gsl_block_ulong] -> int;
  fun gsl_block_ulong_fwrite: ptr[FILE] * cptr[gsl_block_ulong] -> int;
  fun gsl_block_ulong_raw_fprintf: ptr[FILE] * cptr[ulong] * size * size * cptr[char] -> int;
  fun gsl_block_ulong_raw_fread: ptr[FILE] * ptr[ulong] * size * size -> int;
  fun gsl_block_ulong_raw_fscanf: ptr[FILE] * ptr[ulong] * size * size -> int;
  fun gsl_block_ulong_raw_fwrite: ptr[FILE] * cptr[ulong] * size * size -> int;
  fun gsl_block_ulong_size: cptr[gsl_block_ulong] -> size;
}
@h=tangler('lib/gsl/gsl_block_ulong_struct_lib.flx')
@select(h)
//Module        : gsl_block_ulong_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_ulong_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_ulong_struct"';

module gsl_block_ulong_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_block_ushort_lib.flx')
@select(h)
//Module        : gsl_block_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_BLOCK_USHORT_H__
header '#include "gsl_block_ushort.h"';

//INCLUDES
include "gsl_block_ushort_struct_lib";

module gsl_block_ushort_h
{
  open C_hack;
  open gsl_block_ushort_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_block_ushort_struct {
    size: size;
    data: ptr[ushort];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_block_ushort = gsl_block_ushort_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_block_ushort_struct = gsl_block_ushort_struct;
  
  //PROCEDURES
  proc gsl_block_ushort_free: ptr[gsl_block_ushort];
  
  //FUNCTIONS
  fun gsl_block_ushort_alloc: size -> ptr[gsl_block_ushort];
  fun gsl_block_ushort_calloc: size -> ptr[gsl_block_ushort];
  fun gsl_block_ushort_data: cptr[gsl_block_ushort] -> ptr[ushort];
  fun gsl_block_ushort_fprintf: ptr[FILE] * cptr[gsl_block_ushort] * cptr[char] -> int;
  fun gsl_block_ushort_fread: ptr[FILE] * ptr[gsl_block_ushort] -> int;
  fun gsl_block_ushort_fscanf: ptr[FILE] * ptr[gsl_block_ushort] -> int;
  fun gsl_block_ushort_fwrite: ptr[FILE] * cptr[gsl_block_ushort] -> int;
  fun gsl_block_ushort_raw_fprintf: ptr[FILE] * cptr[ushort] * size * size * cptr[char] -> int;
  fun gsl_block_ushort_raw_fread: ptr[FILE] * ptr[ushort] * size * size -> int;
  fun gsl_block_ushort_raw_fscanf: ptr[FILE] * ptr[ushort] * size * size -> int;
  fun gsl_block_ushort_raw_fwrite: ptr[FILE] * cptr[ushort] * size * size -> int;
  fun gsl_block_ushort_size: cptr[gsl_block_ushort] -> size;
}
@h=tangler('lib/gsl/gsl_block_ushort_struct_lib.flx')
@select(h)
//Module        : gsl_block_ushort_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_block_ushort_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_block_ushort_struct"';

module gsl_block_ushort_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_cblas_lib.flx')
@select(h)
//Module        : gsl_cblas_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_cblas.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define CBLAS_INDEX size_t  /* this may vary between platforms */
//#define __GSL_CBLAS_H__
header '#include "gsl_cblas.h"';

module gsl_cblas_h
{
  open C_hack;
  
  //TYPE ALIASES
  typedef CBLAS_ORDER = int;
  typedef CBLAS_TRANSPOSE = int;
  typedef CBLAS_DIAG = int;
  typedef CBLAS_SIDE = int;
  typedef CBLAS_UPLO = int;
  
  //ENUMERATION CONSTANTS
  const CblasConjTrans: int = 'CblasConjTrans';
  const CblasRight: int = 'CblasRight';
  const CblasLower: int = 'CblasLower';
  const CblasUnit: int = 'CblasUnit';
  const CblasRowMajor: int = 'CblasRowMajor';
  const CblasTrans: int = 'CblasTrans';
  const CblasUpper: int = 'CblasUpper';
  const CblasColMajor: int = 'CblasColMajor';
  const CblasNoTrans: int = 'CblasNoTrans';
  const CblasNonUnit: int = 'CblasNonUnit';
  const CblasLeft: int = 'CblasLeft';
  
  //PROCEDURES
  proc cblas_caxpy: int * caddress * caddress * int * address * int;
  proc cblas_ccopy: int * caddress * int * address * int;
  proc cblas_cdotc_sub: int * caddress * int * caddress * int * address;
  proc cblas_cdotu_sub: int * caddress * int * caddress * int * address;
  proc cblas_cgbmv: int * int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_cgemm: int * int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_cgemv: int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_cgerc: int * int * int * caddress * caddress * int * caddress * int * address * int;
  proc cblas_cgeru: int * int * int * caddress * caddress * int * caddress * int * address * int;
  proc cblas_chbmv: int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_chemm: int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_chemv: int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_cher: int * int * int * float * caddress * int * address * int;
  proc cblas_cher2: int * int * int * caddress * caddress * int * caddress * int * address * int;
  proc cblas_cher2k: int * int * int * int * int * caddress * caddress * int * caddress * int * float * address * int;
  proc cblas_cherk: int * int * int * int * int * float * caddress * int * float * address * int;
  proc cblas_chpmv: int * int * int * caddress * caddress * caddress * int * caddress * address * int;
  proc cblas_chpr: int * int * int * float * caddress * int * address;
  proc cblas_chpr2: int * int * int * caddress * caddress * int * caddress * int * address;
  proc cblas_cscal: int * caddress * address * int;
  proc cblas_csscal: int * float * address * int;
  proc cblas_cswap: int * address * int * address * int;
  proc cblas_csymm: int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_csyr2k: int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_csyrk: int * int * int * int * int * caddress * caddress * int * caddress * address * int;
  proc cblas_ctbmv: int * int * int * int * int * int * caddress * int * address * int;
  proc cblas_ctbsv: int * int * int * int * int * int * caddress * int * address * int;
  proc cblas_ctpmv: int * int * int * int * int * caddress * address * int;
  proc cblas_ctpsv: int * int * int * int * int * caddress * address * int;
  proc cblas_ctrmm: int * int * int * int * int * int * int * caddress * caddress * int * address * int;
  proc cblas_ctrmv: int * int * int * int * int * caddress * int * address * int;
  proc cblas_ctrsm: int * int * int * int * int * int * int * caddress * caddress * int * address * int;
  proc cblas_ctrsv: int * int * int * int * int * caddress * int * address * int;
  proc cblas_daxpy: int * double * cptr[double] * int * ptr[double] * int;
  proc cblas_dcopy: int * cptr[double] * int * ptr[double] * int;
  proc cblas_dgbmv: int * int * int * int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dgemm: int * int * int * int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dgemv: int * int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dger: int * int * int * double * cptr[double] * int * cptr[double] * int * ptr[double] * int;
  proc cblas_drot: int * ptr[double] * int * ptr[double] * int * double * double;
  proc cblas_drotg: ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc cblas_drotm: int * ptr[double] * int * ptr[double] * int * cptr[double];
  proc cblas_drotmg: ptr[double] * ptr[double] * ptr[double] * double * ptr[double];
  proc cblas_dsbmv: int * int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dscal: int * double * ptr[double] * int;
  proc cblas_dspmv: int * int * int * double * cptr[double] * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dspr: int * int * int * double * cptr[double] * int * ptr[double];
  proc cblas_dspr2: int * int * int * double * cptr[double] * int * cptr[double] * int * ptr[double];
  proc cblas_dswap: int * ptr[double] * int * ptr[double] * int;
  proc cblas_dsymm: int * int * int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dsymv: int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dsyr: int * int * int * double * cptr[double] * int * ptr[double] * int;
  proc cblas_dsyr2: int * int * int * double * cptr[double] * int * cptr[double] * int * ptr[double] * int;
  proc cblas_dsyr2k: int * int * int * int * int * double * cptr[double] * int * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dsyrk: int * int * int * int * int * double * cptr[double] * int * double * ptr[double] * int;
  proc cblas_dtbmv: int * int * int * int * int * int * cptr[double] * int * ptr[double] * int;
  proc cblas_dtbsv: int * int * int * int * int * int * cptr[double] * int * ptr[double] * int;
  proc cblas_dtpmv: int * int * int * int * int * cptr[double] * ptr[double] * int;
  proc cblas_dtpsv: int * int * int * int * int * cptr[double] * ptr[double] * int;
  proc cblas_dtrmm: int * int * int * int * int * int * int * double * cptr[double] * int * ptr[double] * int;
  proc cblas_dtrmv: int * int * int * int * int * cptr[double] * int * ptr[double] * int;
  proc cblas_dtrsm: int * int * int * int * int * int * int * double * cptr[double] * int * ptr[double] * int;
  proc cblas_dtrsv: int * int * int * int * int * cptr[double] * int * ptr[double] * int;
  proc cblas_saxpy: int * float * cptr[float] * int * ptr[float] * int;
  proc cblas_scopy: int * cptr[float] * int * ptr[float] * int;
  proc cblas_sgbmv: int * int * int * int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_sgemm: int * int * int * int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_sgemv: int * int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_sger: int * int * int * float * cptr[float] * int * cptr[float] * int * ptr[float] * int;
  proc cblas_srot: int * ptr[float] * int * ptr[float] * int * float * float;
  proc cblas_srotg: ptr[float] * ptr[float] * ptr[float] * ptr[float];
  proc cblas_srotm: int * ptr[float] * int * ptr[float] * int * cptr[float];
  proc cblas_srotmg: ptr[float] * ptr[float] * ptr[float] * float * ptr[float];
  proc cblas_ssbmv: int * int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_sscal: int * float * ptr[float] * int;
  proc cblas_sspmv: int * int * int * float * cptr[float] * cptr[float] * int * float * ptr[float] * int;
  proc cblas_sspr: int * int * int * float * cptr[float] * int * ptr[float];
  proc cblas_sspr2: int * int * int * float * cptr[float] * int * cptr[float] * int * ptr[float];
  proc cblas_sswap: int * ptr[float] * int * ptr[float] * int;
  proc cblas_ssymm: int * int * int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_ssymv: int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_ssyr: int * int * int * float * cptr[float] * int * ptr[float] * int;
  proc cblas_ssyr2: int * int * int * float * cptr[float] * int * cptr[float] * int * ptr[float] * int;
  proc cblas_ssyr2k: int * int * int * int * int * float * cptr[float] * int * cptr[float] * int * float * ptr[float] * int;
  proc cblas_ssyrk: int * int * int * int * int * float * cptr[float] * int * float * ptr[float] * int;
  proc cblas_stbmv: int * int * int * int * int * int * cptr[float] * int * ptr[float] * int;
  proc cblas_stbsv: int * int * int * int * int * int * cptr[float] * int * ptr[float] * int;
  proc cblas_stpmv: int * int * int * int * int * cptr[float] * ptr[float] * int;
  proc cblas_stpsv: int * int * int * int * int * cptr[float] * ptr[float] * int;
  proc cblas_strmm: int * int * int * int * int * int * int * float * cptr[float] * int * ptr[float] * int;
  proc cblas_strmv: int * int * int * int * int * cptr[float] * int * ptr[float] * int;
  proc cblas_strsm: int * int * int * int * int * int * int * float * cptr[float] * int * ptr[float] * int;
  proc cblas_strsv: int * int * int * int * int * cptr[float] * int * ptr[float] * int;
  proc cblas_xerbla[t]: t;
  proc cblas_zaxpy: int * caddress * caddress * int * address * int;
  proc cblas_zcopy: int * caddress * int * address * int;
  proc cblas_zdotc_sub: int * caddress * int * caddress * int * address;
  proc cblas_zdotu_sub: int * caddress * int * caddress * int * address;
  proc cblas_zdscal: int * double * address * int;
  proc cblas_zgbmv: int * int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zgemm: int * int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zgemv: int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zgerc: int * int * int * caddress * caddress * int * caddress * int * address * int;
  proc cblas_zgeru: int * int * int * caddress * caddress * int * caddress * int * address * int;
  proc cblas_zhbmv: int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zhemm: int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zhemv: int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zher: int * int * int * double * caddress * int * address * int;
  proc cblas_zher2: int * int * int * caddress * caddress * int * caddress * int * address * int;
  proc cblas_zher2k: int * int * int * int * int * caddress * caddress * int * caddress * int * double * address * int;
  proc cblas_zherk: int * int * int * int * int * double * caddress * int * double * address * int;
  proc cblas_zhpmv: int * int * int * caddress * caddress * caddress * int * caddress * address * int;
  proc cblas_zhpr: int * int * int * double * caddress * int * address;
  proc cblas_zhpr2: int * int * int * caddress * caddress * int * caddress * int * address;
  proc cblas_zscal: int * caddress * address * int;
  proc cblas_zswap: int * address * int * address * int;
  proc cblas_zsymm: int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zsyr2k: int * int * int * int * int * caddress * caddress * int * caddress * int * caddress * address * int;
  proc cblas_zsyrk: int * int * int * int * int * caddress * caddress * int * caddress * address * int;
  proc cblas_ztbmv: int * int * int * int * int * int * caddress * int * address * int;
  proc cblas_ztbsv: int * int * int * int * int * int * caddress * int * address * int;
  proc cblas_ztpmv: int * int * int * int * int * caddress * address * int;
  proc cblas_ztpsv: int * int * int * int * int * caddress * address * int;
  proc cblas_ztrmm: int * int * int * int * int * int * int * caddress * caddress * int * address * int;
  proc cblas_ztrmv: int * int * int * int * int * caddress * int * address * int;
  proc cblas_ztrsm: int * int * int * int * int * int * int * caddress * caddress * int * address * int;
  proc cblas_ztrsv: int * int * int * int * int * caddress * int * address * int;
  
  //FUNCTIONS
  fun cblas_dasum: int * cptr[double] * int -> double;
  fun cblas_ddot: int * cptr[double] * int * cptr[double] * int -> double;
  fun cblas_dnrm2: int * cptr[double] * int -> double;
  fun cblas_dsdot: int * cptr[float] * int * cptr[float] * int -> double;
  fun cblas_dzasum: int * caddress * int -> double;
  fun cblas_dznrm2: int * caddress * int -> double;
  fun cblas_icamax: int * caddress * int -> size;
  fun cblas_idamax: int * cptr[double] * int -> size;
  fun cblas_isamax: int * cptr[float] * int -> size;
  fun cblas_izamax: int * caddress * int -> size;
  fun cblas_sasum: int * cptr[float] * int -> float;
  fun cblas_scasum: int * caddress * int -> float;
  fun cblas_scnrm2: int * caddress * int -> float;
  fun cblas_sdot: int * cptr[float] * int * cptr[float] * int -> float;
  fun cblas_sdsdot: int * float * cptr[float] * int * cptr[float] * int -> float;
  fun cblas_snrm2: int * cptr[float] * int -> float;
}
@h=tangler('lib/gsl/gsl_cdf_lib.flx')
@select(h)
//Module        : gsl_cdf_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_cdf.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_CDF_H__
header '#include "gsl_cdf.h"';

module gsl_cdf_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_cdf_beta_P: double * double * double -> double;
  fun gsl_cdf_beta_Q: double * double * double -> double;
  fun gsl_cdf_cauchy_P: double * double -> double;
  fun gsl_cdf_cauchy_Pinv: double * double -> double;
  fun gsl_cdf_cauchy_Q: double * double -> double;
  fun gsl_cdf_cauchy_Qinv: double * double -> double;
  fun gsl_cdf_chisq_P: double * double -> double;
  fun gsl_cdf_chisq_Pinv: double * double -> double;
  fun gsl_cdf_chisq_Q: double * double -> double;
  fun gsl_cdf_chisq_Qinv: double * double -> double;
  fun gsl_cdf_exponential_P: double * double -> double;
  fun gsl_cdf_exponential_Pinv: double * double -> double;
  fun gsl_cdf_exponential_Q: double * double -> double;
  fun gsl_cdf_exponential_Qinv: double * double -> double;
  fun gsl_cdf_exppow_P: double * double * double -> double;
  fun gsl_cdf_exppow_Q: double * double * double -> double;
  fun gsl_cdf_fdist_P: double * double * double -> double;
  fun gsl_cdf_fdist_Q: double * double * double -> double;
  fun gsl_cdf_flat_P: double * double * double -> double;
  fun gsl_cdf_flat_Pinv: double * double * double -> double;
  fun gsl_cdf_flat_Q: double * double * double -> double;
  fun gsl_cdf_flat_Qinv: double * double * double -> double;
  fun gsl_cdf_gamma_P: double * double * double -> double;
  fun gsl_cdf_gamma_Pinv: double * double * double -> double;
  fun gsl_cdf_gamma_Q: double * double * double -> double;
  fun gsl_cdf_gamma_Qinv: double * double * double -> double;
  fun gsl_cdf_gaussian_P: double * double -> double;
  fun gsl_cdf_gaussian_Pinv: double * double -> double;
  fun gsl_cdf_gaussian_Q: double * double -> double;
  fun gsl_cdf_gaussian_Qinv: double * double -> double;
  fun gsl_cdf_gumbel1_P: double * double * double -> double;
  fun gsl_cdf_gumbel1_Pinv: double * double * double -> double;
  fun gsl_cdf_gumbel1_Q: double * double * double -> double;
  fun gsl_cdf_gumbel1_Qinv: double * double * double -> double;
  fun gsl_cdf_gumbel2_P: double * double * double -> double;
  fun gsl_cdf_gumbel2_Pinv: double * double * double -> double;
  fun gsl_cdf_gumbel2_Q: double * double * double -> double;
  fun gsl_cdf_gumbel2_Qinv: double * double * double -> double;
  fun gsl_cdf_laplace_P: double * double -> double;
  fun gsl_cdf_laplace_Pinv: double * double -> double;
  fun gsl_cdf_laplace_Q: double * double -> double;
  fun gsl_cdf_laplace_Qinv: double * double -> double;
  fun gsl_cdf_logistic_P: double * double -> double;
  fun gsl_cdf_logistic_Pinv: double * double -> double;
  fun gsl_cdf_logistic_Q: double * double -> double;
  fun gsl_cdf_logistic_Qinv: double * double -> double;
  fun gsl_cdf_lognormal_P: double * double * double -> double;
  fun gsl_cdf_lognormal_Pinv: double * double * double -> double;
  fun gsl_cdf_lognormal_Q: double * double * double -> double;
  fun gsl_cdf_lognormal_Qinv: double * double * double -> double;
  fun gsl_cdf_pareto_P: double * double * double -> double;
  fun gsl_cdf_pareto_Pinv: double * double * double -> double;
  fun gsl_cdf_pareto_Q: double * double * double -> double;
  fun gsl_cdf_pareto_Qinv: double * double * double -> double;
  fun gsl_cdf_rayleigh_P: double * double -> double;
  fun gsl_cdf_rayleigh_Pinv: double * double -> double;
  fun gsl_cdf_rayleigh_Q: double * double -> double;
  fun gsl_cdf_rayleigh_Qinv: double * double -> double;
  fun gsl_cdf_tdist_P: double * double -> double;
  fun gsl_cdf_tdist_Pinv: double * double -> double;
  fun gsl_cdf_tdist_Q: double * double -> double;
  fun gsl_cdf_tdist_Qinv: double * double -> double;
  fun gsl_cdf_ugaussian_P: double -> double;
  fun gsl_cdf_ugaussian_Pinv: double -> double;
  fun gsl_cdf_ugaussian_Q: double -> double;
  fun gsl_cdf_ugaussian_Qinv: double -> double;
  fun gsl_cdf_weibull_P: double * double * double -> double;
  fun gsl_cdf_weibull_Pinv: double * double * double -> double;
  fun gsl_cdf_weibull_Q: double * double * double -> double;
  fun gsl_cdf_weibull_Qinv: double * double * double -> double;
}
@h=tangler('lib/gsl/gsl_cheb_series_struct_lib.flx')
@select(h)
//Module        : gsl_cheb_series_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_cheb_series_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_cheb_series_struct"';

module gsl_cheb_series_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_chebyshev_lib.flx')
@select(h)
//Module        : gsl_chebyshev_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_chebyshev.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_CHEBYSHEV_H__
header '#include "gsl_chebyshev.h"';

//INCLUDES
include "gsl_cheb_series_struct_lib";
include "gsl_math_lib";
include "gsl_mode_lib";

module gsl_chebyshev_h
{
  open C_hack;
  open gsl_cheb_series_struct_h;
  open gsl_math_h;
  open gsl_mode_h;
  
  //CSTRUCTS 
  cstruct gsl_cheb_series_struct {
    c: ptr[double];
    order: size;
    a: double;
    b: double;
    order_sp: size;
    f: ptr[double];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_cheb_series = gsl_cheb_series_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_cheb_series_struct = gsl_cheb_series_struct;
  
  //PROCEDURES
  proc gsl_cheb_free: ptr[gsl_cheb_series];
  
  //FUNCTIONS
  fun gsl_cheb_alloc: size -> ptr[gsl_cheb_series];
  fun gsl_cheb_calc_deriv: ptr[gsl_cheb_series] * cptr[gsl_cheb_series] -> int;
  fun gsl_cheb_calc_integ: ptr[gsl_cheb_series] * cptr[gsl_cheb_series] -> int;
  fun gsl_cheb_eval: cptr[gsl_cheb_series] * double -> double;
  fun gsl_cheb_eval_err: cptr[gsl_cheb_series] * double * ptr[double] * ptr[double] -> int;
  fun gsl_cheb_eval_mode: cptr[gsl_cheb_series] * double * gsl_mode_t -> double;
  fun gsl_cheb_eval_mode_e: cptr[gsl_cheb_series] * double * gsl_mode_t * ptr[double] * ptr[double] -> int;
  fun gsl_cheb_eval_n: cptr[gsl_cheb_series] * size * double -> double;
  fun gsl_cheb_eval_n_err: cptr[gsl_cheb_series] * size * double * ptr[double] * ptr[double] -> int;
  fun gsl_cheb_init: ptr[gsl_cheb_series] * cptr[gsl_function] * double * double -> int;
}
@h=tangler('lib/gsl/gsl_check_range_lib.flx')
@select(h)
//Module        : gsl_check_range_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_check_range.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_RANGE_CHECK 1
//#define GSL_RANGE_CHECK 0
//#define __GSL_CHECK_RANGE_H__
header '#include "gsl_check_range.h"';

module gsl_check_range_h
{
  open C_hack;
  
  //VARIABLES
  const gsl_check_range: int = 'gsl_check_range';
}
@h=tangler('lib/gsl/gsl_combination_lib.flx')
@select(h)
//Module        : gsl_combination_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_combination.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_COMBINATION_H__
header '#include "gsl_combination.h"';

//INCLUDES
include "gsl_combination_struct_lib";

module gsl_combination_h
{
  open C_hack;
  open gsl_combination_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_combination_struct {
    n: size;
    k: size;
    data: ptr[size];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_combination = gsl_combination_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_combination_struct = gsl_combination_struct;
  
  //PROCEDURES
  proc gsl_combination_free: ptr[gsl_combination];
  proc gsl_combination_init_first: ptr[gsl_combination];
  proc gsl_combination_init_last: ptr[gsl_combination];
  
  //FUNCTIONS
  fun gsl_combination_alloc: size * size -> ptr[gsl_combination];
  fun gsl_combination_calloc: size * size -> ptr[gsl_combination];
  fun gsl_combination_data: cptr[gsl_combination] -> ptr[size];
  fun gsl_combination_fprintf: ptr[FILE] * cptr[gsl_combination] * cptr[char] -> int;
  fun gsl_combination_fread: ptr[FILE] * ptr[gsl_combination] -> int;
  fun gsl_combination_fscanf: ptr[FILE] * ptr[gsl_combination] -> int;
  fun gsl_combination_fwrite: ptr[FILE] * cptr[gsl_combination] -> int;
  fun gsl_combination_get: cptr[gsl_combination] * size -> size;
  fun gsl_combination_k: cptr[gsl_combination] -> size;
  fun gsl_combination_memcpy: ptr[gsl_combination] * cptr[gsl_combination] -> int;
  fun gsl_combination_n: cptr[gsl_combination] -> size;
  fun gsl_combination_next: ptr[gsl_combination] -> int;
  fun gsl_combination_prev: ptr[gsl_combination] -> int;
  fun gsl_combination_valid: ptr[gsl_combination] -> int;
}
@h=tangler('lib/gsl/gsl_combination_struct_lib.flx')
@select(h)
//Module        : gsl_combination_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_combination_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_combination_struct"';

module gsl_combination_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_complex_lib.flx')
@select(h)
//Module        : gsl_complex_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_complex.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_SET_COMPLEX_PACKED(zp,n,x,y) do {*((zp)+2*(n))=(x); *((zp)+(2*(n)+1))=(y);} while(0)
//#define GSL_SET_IMAG(zp,y) do {(zp)->dat[1]=(y);} while(0)
//#define GSL_SET_REAL(zp,x) do {(zp)->dat[0]=(x);} while(0)
//#define GSL_SET_COMPLEX(zp,x,y) do {(zp)->dat[0]=(x); (zp)->dat[1]=(y);} while(0)
//#define GSL_COMPLEX_EQ(z1,z2) (((z1).dat[0] == (z2).dat[0]) && ((z1).dat[1] == (z2).dat[1]))
//#define GSL_COMPLEX_P_IMAG(zp)  ((zp)->dat[1])
//#define GSL_COMPLEX_P_REAL(zp)  ((zp)->dat[0])
//#define GSL_COMPLEX_P(zp) ((zp)->dat)
//#define GSL_IMAG(z)     ((z).dat[1])
//#define GSL_REAL(z)     ((z).dat[0])
//#define __GSL_COMPLEX_H__
header '#include "gsl_complex.h"';

module gsl_complex_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_complex = 'gsl_complex';
  type gsl_complex_float = 'gsl_complex_float';
  type gsl_complex_long_double = 'gsl_complex_long_double';
  
  //TYPE ALIASES
  typedef gsl_complex_packed = ptr[double];
  typedef gsl_const_complex_packed_long_double = cptr[ldouble];
  typedef gsl_const_complex_packed_float = cptr[float];
  typedef gsl_const_complex_packed = cptr[double];
  typedef gsl_const_complex_packed_float_ptr = cptr[float];
  typedef gsl_complex_packed_array = ptr[double];
  typedef gsl_complex_packed_long_double = ptr[ldouble];
  typedef gsl_const_complex_packed_ptr = cptr[double];
  typedef gsl_complex_packed_long_double_ptr = ptr[ldouble];
  typedef gsl_const_complex_packed_long_double_ptr = cptr[ldouble];
  typedef gsl_complex_packed_float = ptr[float];
  typedef gsl_complex_packed_array_long_double = ptr[ldouble];
  typedef gsl_const_complex_packed_array_float = cptr[float];
  typedef gsl_const_complex_packed_array_long_double = cptr[ldouble];
  typedef gsl_complex_packed_array_float = ptr[float];
  typedef gsl_complex_packed_float_ptr = ptr[float];
  typedef gsl_complex_packed_ptr = ptr[double];
  typedef gsl_const_complex_packed_array = cptr[double];
}
@h=tangler('lib/gsl/gsl_complex_math_lib.flx')
@select(h)
//Module        : gsl_complex_math_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_complex_math.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_COMPLEX_NEGONE (gsl_complex_rect(-1.0,0.0))
//#define GSL_COMPLEX_ZERO (gsl_complex_rect(0.0,0.0))
//#define GSL_COMPLEX_ONE (gsl_complex_rect(1.0,0.0))
//#define __GSL_COMPLEX_MATH_H__
header '#include "gsl_complex_math.h"';

//INCLUDES
include "gsl_complex_lib";

module gsl_complex_math_h
{
  open C_hack;
  open gsl_complex_h;
  
  //FUNCTIONS
  fun gsl_complex_abs: gsl_complex -> double;
  fun gsl_complex_abs2: gsl_complex -> double;
  fun gsl_complex_add: gsl_complex * gsl_complex -> gsl_complex;
  fun gsl_complex_add_imag: gsl_complex * double -> gsl_complex;
  fun gsl_complex_add_real: gsl_complex * double -> gsl_complex;
  fun gsl_complex_arccos: gsl_complex -> gsl_complex;
  fun gsl_complex_arccos_real: double -> gsl_complex;
  fun gsl_complex_arccosh: gsl_complex -> gsl_complex;
  fun gsl_complex_arccosh_real: double -> gsl_complex;
  fun gsl_complex_arccot: gsl_complex -> gsl_complex;
  fun gsl_complex_arccoth: gsl_complex -> gsl_complex;
  fun gsl_complex_arccsc: gsl_complex -> gsl_complex;
  fun gsl_complex_arccsc_real: double -> gsl_complex;
  fun gsl_complex_arccsch: gsl_complex -> gsl_complex;
  fun gsl_complex_arcsec: gsl_complex -> gsl_complex;
  fun gsl_complex_arcsec_real: double -> gsl_complex;
  fun gsl_complex_arcsech: gsl_complex -> gsl_complex;
  fun gsl_complex_arcsin: gsl_complex -> gsl_complex;
  fun gsl_complex_arcsin_real: double -> gsl_complex;
  fun gsl_complex_arcsinh: gsl_complex -> gsl_complex;
  fun gsl_complex_arctan: gsl_complex -> gsl_complex;
  fun gsl_complex_arctanh: gsl_complex -> gsl_complex;
  fun gsl_complex_arctanh_real: double -> gsl_complex;
  fun gsl_complex_arg: gsl_complex -> double;
  fun gsl_complex_conjugate: gsl_complex -> gsl_complex;
  fun gsl_complex_cos: gsl_complex -> gsl_complex;
  fun gsl_complex_cosh: gsl_complex -> gsl_complex;
  fun gsl_complex_cot: gsl_complex -> gsl_complex;
  fun gsl_complex_coth: gsl_complex -> gsl_complex;
  fun gsl_complex_csc: gsl_complex -> gsl_complex;
  fun gsl_complex_csch: gsl_complex -> gsl_complex;
  fun gsl_complex_div: gsl_complex * gsl_complex -> gsl_complex;
  fun gsl_complex_div_imag: gsl_complex * double -> gsl_complex;
  fun gsl_complex_div_real: gsl_complex * double -> gsl_complex;
  fun gsl_complex_exp: gsl_complex -> gsl_complex;
  fun gsl_complex_inverse: gsl_complex -> gsl_complex;
  fun gsl_complex_log: gsl_complex -> gsl_complex;
  fun gsl_complex_log10: gsl_complex -> gsl_complex;
  fun gsl_complex_log_b: gsl_complex * gsl_complex -> gsl_complex;
  fun gsl_complex_logabs: gsl_complex -> double;
  fun gsl_complex_mul: gsl_complex * gsl_complex -> gsl_complex;
  fun gsl_complex_mul_imag: gsl_complex * double -> gsl_complex;
  fun gsl_complex_mul_real: gsl_complex * double -> gsl_complex;
  fun gsl_complex_negative: gsl_complex -> gsl_complex;
  fun gsl_complex_polar: double * double -> gsl_complex;
  fun gsl_complex_pow: gsl_complex * gsl_complex -> gsl_complex;
  fun gsl_complex_pow_real: gsl_complex * double -> gsl_complex;
  fun gsl_complex_rect: double * double -> gsl_complex;
  fun gsl_complex_sec: gsl_complex -> gsl_complex;
  fun gsl_complex_sech: gsl_complex -> gsl_complex;
  fun gsl_complex_sin: gsl_complex -> gsl_complex;
  fun gsl_complex_sinh: gsl_complex -> gsl_complex;
  fun gsl_complex_sqrt: gsl_complex -> gsl_complex;
  fun gsl_complex_sqrt_real: double -> gsl_complex;
  fun gsl_complex_sub: gsl_complex * gsl_complex -> gsl_complex;
  fun gsl_complex_sub_imag: gsl_complex * double -> gsl_complex;
  fun gsl_complex_sub_real: gsl_complex * double -> gsl_complex;
  fun gsl_complex_tan: gsl_complex -> gsl_complex;
  fun gsl_complex_tanh: gsl_complex -> gsl_complex;
}
@h=tangler('lib/gsl/gsl_const_cgs_lib.flx')
@select(h)
//Module        : gsl_const_cgs_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_const_cgs.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_CONST_CGS_THOMSON_CROSS_SECTION (6.65245853542e-25) /* cm^2 */
//#define GSL_CONST_CGS_STEFAN_BOLTZMANN_CONSTANT (5.67039934436e-5) /* g / K^4 s^3 */
//#define GSL_CONST_CGS_ERG (1e0) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_JOULE (1e7) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_DYNE (1e0) /* cm g / s^2 */
//#define GSL_CONST_CGS_NEWTON (1e5) /* cm g / s^2 */
//#define GSL_CONST_CGS_BOHR_RADIUS (5.291772083e-9) /* cm */
//#define GSL_CONST_CGS_SOLAR_MASS (1.98892e33) /* g */
//#define GSL_CONST_CGS_RAD (1e2) /* cm^2 / s^2 */
//#define GSL_CONST_CGS_ROENTGEN (2.58e-7) /* A s / g */
//#define GSL_CONST_CGS_CURIE (3.7e10) /* 1 / s */
//#define GSL_CONST_CGS_FOOTLAMBERT (1.07639104e-3) /* cd sr / cm^2 */
//#define GSL_CONST_CGS_LAMBERT (1e0) /* cd sr / cm^2 */
//#define GSL_CONST_CGS_FOOTCANDLE (1.076e-3) /* cd sr / cm^2 */
//#define GSL_CONST_CGS_PHOT (1e0) /* cd sr / cm^2 */
//#define GSL_CONST_CGS_LUX (1e-4) /* cd sr / cm^2 */
//#define GSL_CONST_CGS_LUMEN (1e0) /* cd sr */
//#define GSL_CONST_CGS_STILB (1e0) /* cd / cm^2 */
//#define GSL_CONST_CGS_GAUSS (1e-1) /* g / A s^2 */
//#define GSL_CONST_CGS_ELECTRON_CHARGE (1.602176462e-19) /* A s */
//#define GSL_CONST_CGS_FARADAY (9.6485341472e4) /* A s / mol */
//#define GSL_CONST_CGS_STOKES (1e0) /* cm^2 / s */
//#define GSL_CONST_CGS_POISE (1e0) /* g / cm s */
//#define GSL_CONST_CGS_PSI (6.89475729317e4) /* g / cm s^2 */
//#define GSL_CONST_CGS_INCH_OF_WATER (2.490889e3) /* g / cm s^2 */
//#define GSL_CONST_CGS_INCH_OF_MERCURY (3.38638815789e4) /* g / cm s^2 */
//#define GSL_CONST_CGS_METER_OF_MERCURY (1.33322368421e6) /* g / cm s^2 */
//#define GSL_CONST_CGS_TORR (1.33322368421e3) /* g / cm s^2 */
//#define GSL_CONST_CGS_STD_ATMOSPHERE (1.01325e6) /* g / cm s^2 */
//#define GSL_CONST_CGS_BAR (1e6) /* g / cm s^2 */
//#define GSL_CONST_CGS_HORSEPOWER (7.457e9) /* g cm^2 / s^3 */
//#define GSL_CONST_CGS_THERM (1.05506e15) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_BTU (1.05505585262e10) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_CALORIE (4.1868e7) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_POUNDAL (1.38255e4) /* cm g / s^2 */
//#define GSL_CONST_CGS_KILOPOUND_FORCE (4.44822161526e8) /* cm g / s^2 */
//#define GSL_CONST_CGS_POUND_FORCE (4.44822161526e5) /* cm g / s^2 */
//#define GSL_CONST_CGS_GRAM_FORCE (9.80665e2) /* cm g / s^2 */
//#define GSL_CONST_CGS_UNIFIED_ATOMIC_MASS (1.66053873e-24) /* g */
//#define GSL_CONST_CGS_CARAT (2e-1) /* g */
//#define GSL_CONST_CGS_TROY_OUNCE (3.1103475e1) /* g */
//#define GSL_CONST_CGS_UK_TON (1.0160469088e6) /* g */
//#define GSL_CONST_CGS_METRIC_TON (1e6) /* g */
//#define GSL_CONST_CGS_TON (9.0718474e5) /* g */
//#define GSL_CONST_CGS_OUNCE_MASS (2.8349523125e1) /* g */
//#define GSL_CONST_CGS_POUND_MASS (4.5359237e2) /* g */
//#define GSL_CONST_CGS_KNOT (5.14444444444e1) /* cm / s */
//#define GSL_CONST_CGS_KILOMETERS_PER_HOUR (2.77777777778e1) /* cm / s */
//#define GSL_CONST_CGS_MILES_PER_HOUR (4.4704e1) /* cm / s */
//#define GSL_CONST_CGS_UK_GALLON (4.546092e3) /* cm^3 */
//#define GSL_CONST_CGS_CANADIAN_GALLON (4.54609e3) /* cm^3 */
//#define GSL_CONST_CGS_TEASPOON (4.92892159375e0) /* cm^3 */
//#define GSL_CONST_CGS_TABLESPOON (1.47867647813e1) /* cm^3 */
//#define GSL_CONST_CGS_FLUID_OUNCE (2.95735295626e1) /* cm^3 */
//#define GSL_CONST_CGS_CUP (2.36588236501e2) /* cm^3 */
//#define GSL_CONST_CGS_PINT (4.73176473002e2) /* cm^3 */
//#define GSL_CONST_CGS_QUART (9.46352946004e2) /* cm^3 */
//#define GSL_CONST_CGS_US_GALLON (3.78541178402e3) /* cm^3 */
//#define GSL_CONST_CGS_LITER (1e3) /* cm^3 */
//#define GSL_CONST_CGS_BARN (1e-24) /* cm^2 */
//#define GSL_CONST_CGS_ACRE (4.04685642241e7) /* cm^2 */
//#define GSL_CONST_CGS_HECTARE (1e8) /* cm^2 */
//#define GSL_CONST_CGS_ANGSTROM (1e-8) /* cm */
//#define GSL_CONST_CGS_MICRON (1e-4) /* cm */
//#define GSL_CONST_CGS_TEXPOINT (3.51459803515e-2) /* cm */
//#define GSL_CONST_CGS_POINT (3.52777777778e-2) /* cm */
//#define GSL_CONST_CGS_MIL (2.54e-3) /* cm */
//#define GSL_CONST_CGS_FATHOM (1.8288e2) /* cm */
//#define GSL_CONST_CGS_NAUTICAL_MILE (1.852e5) /* cm */
//#define GSL_CONST_CGS_MILE (1.609344e5) /* cm */
//#define GSL_CONST_CGS_YARD (9.144e1) /* cm */
//#define GSL_CONST_CGS_FOOT (3.048e1) /* cm */
//#define GSL_CONST_CGS_INCH (2.54e0) /* cm */
//#define GSL_CONST_CGS_WEEK (6.048e5) /* s */
//#define GSL_CONST_CGS_DAY (8.64e4) /* s */
//#define GSL_CONST_CGS_HOUR (3.6e3) /* s */
//#define GSL_CONST_CGS_MINUTE (6e1) /* s */
//#define GSL_CONST_CGS_STANDARD_GAS_VOLUME (2.2710981e4) /* cm^3 / mol */
//#define GSL_CONST_CGS_MOLAR_GAS (8.314472e7) /* g cm^2 / K mol s^2 */
//#define GSL_CONST_CGS_PROTON_MAGNETIC_MOMENT (1.410606633e-22) /* A cm^2 */
//#define GSL_CONST_CGS_ELECTRON_MAGNETIC_MOMENT (9.28476362e-20) /* A cm^2 */
//#define GSL_CONST_CGS_NUCLEAR_MAGNETON (5.05078317e-23) /* A cm^2 */
//#define GSL_CONST_CGS_BOHR_MAGNETON (9.27400899e-20) /* A cm^2 */
//#define GSL_CONST_CGS_BOLTZMANN (1.3806503e-16) /* g cm^2 / K s^2 */
//#define GSL_CONST_CGS_RYDBERG (2.17987190389e-11) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_MASS_NEUTRON (1.67492716e-24) /* g */
//#define GSL_CONST_CGS_MASS_PROTON (1.67262158e-24) /* g */
//#define GSL_CONST_CGS_MASS_MUON (1.88353109e-25) /* g */
//#define GSL_CONST_CGS_MASS_ELECTRON (9.10938188e-28) /* g */
//#define GSL_CONST_CGS_ELECTRON_VOLT (1.602176462e-12) /* g cm^2 / s^2 */
//#define GSL_CONST_CGS_GRAV_ACCEL (9.80665e2) /* cm / s^2 */
//#define GSL_CONST_CGS_PARSEC (3.08567758135e18) /* cm */
//#define GSL_CONST_CGS_LIGHT_YEAR (9.46053620707e17) /* cm */
//#define GSL_CONST_CGS_ASTRONOMICAL_UNIT (1.49597870691e13) /* cm */
//#define GSL_CONST_CGS_PLANCKS_CONSTANT_HBAR (1.05457159642e-27) /* g cm^2 / s */
//#define GSL_CONST_CGS_PLANCKS_CONSTANT_H (6.62606876e-27) /* g cm^2 / s */
//#define GSL_CONST_CGS_GRAVITATIONAL_CONSTANT (6.673e-8) /* cm^3 / g s^2 */
//#define GSL_CONST_CGS_SPEED_OF_LIGHT (2.99792458e10) /* cm / s */
//#define __GSL_CONST_CGS__
header '#include "gsl_const_cgs.h"';

module gsl_const_cgs_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_const_cgsm_lib.flx')
@select(h)
//Module        : gsl_const_cgsm_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_const_cgsm.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_CONST_CGSM_THOMSON_CROSS_SECTION (6.65245853542e-25) /* cm^2 */
//#define GSL_CONST_CGSM_STEFAN_BOLTZMANN_CONSTANT (5.67039934436e-5) /* g / K^4 s^3 */
//#define GSL_CONST_CGSM_ERG (1e0) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_JOULE (1e7) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_DYNE (1e0) /* cm g / s^2 */
//#define GSL_CONST_CGSM_NEWTON (1e5) /* cm g / s^2 */
//#define GSL_CONST_CGSM_BOHR_RADIUS (5.291772083e-9) /* cm */
//#define GSL_CONST_CGSM_SOLAR_MASS (1.98892e33) /* g */
//#define GSL_CONST_CGSM_RAD (1e2) /* cm^2 / s^2 */
//#define GSL_CONST_CGSM_ROENTGEN (2.58e-8) /* abamp s / g */
//#define GSL_CONST_CGSM_CURIE (3.7e10) /* 1 / s */
//#define GSL_CONST_CGSM_FOOTLAMBERT (1.07639104e-3) /* cd sr / cm^2 */
//#define GSL_CONST_CGSM_LAMBERT (1e0) /* cd sr / cm^2 */
//#define GSL_CONST_CGSM_FOOTCANDLE (1.076e-3) /* cd sr / cm^2 */
//#define GSL_CONST_CGSM_PHOT (1e0) /* cd sr / cm^2 */
//#define GSL_CONST_CGSM_LUX (1e-4) /* cd sr / cm^2 */
//#define GSL_CONST_CGSM_LUMEN (1e0) /* cd sr */
//#define GSL_CONST_CGSM_STILB (1e0) /* cd / cm^2 */
//#define GSL_CONST_CGSM_GAUSS (1e0) /* g / abamp s^2 */
//#define GSL_CONST_CGSM_ELECTRON_CHARGE (1.602176462e-20) /* abamp s */
//#define GSL_CONST_CGSM_FARADAY (9.6485341472e3) /* abamp s / mol */
//#define GSL_CONST_CGSM_STOKES (1e0) /* cm^2 / s */
//#define GSL_CONST_CGSM_POISE (1e0) /* g / cm s */
//#define GSL_CONST_CGSM_PSI (6.89475729317e4) /* g / cm s^2 */
//#define GSL_CONST_CGSM_INCH_OF_WATER (2.490889e3) /* g / cm s^2 */
//#define GSL_CONST_CGSM_INCH_OF_MERCURY (3.38638815789e4) /* g / cm s^2 */
//#define GSL_CONST_CGSM_METER_OF_MERCURY (1.33322368421e6) /* g / cm s^2 */
//#define GSL_CONST_CGSM_TORR (1.33322368421e3) /* g / cm s^2 */
//#define GSL_CONST_CGSM_STD_ATMOSPHERE (1.01325e6) /* g / cm s^2 */
//#define GSL_CONST_CGSM_BAR (1e6) /* g / cm s^2 */
//#define GSL_CONST_CGSM_HORSEPOWER (7.457e9) /* g cm^2 / s^3 */
//#define GSL_CONST_CGSM_THERM (1.05506e15) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_BTU (1.05505585262e10) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_CALORIE (4.1868e7) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_POUNDAL (1.38255e4) /* cm g / s^2 */
//#define GSL_CONST_CGSM_KILOPOUND_FORCE (4.44822161526e8) /* cm g / s^2 */
//#define GSL_CONST_CGSM_POUND_FORCE (4.44822161526e5) /* cm g / s^2 */
//#define GSL_CONST_CGSM_GRAM_FORCE (9.80665e2) /* cm g / s^2 */
//#define GSL_CONST_CGSM_UNIFIED_ATOMIC_MASS (1.66053873e-24) /* g */
//#define GSL_CONST_CGSM_CARAT (2e-1) /* g */
//#define GSL_CONST_CGSM_TROY_OUNCE (3.1103475e1) /* g */
//#define GSL_CONST_CGSM_UK_TON (1.0160469088e6) /* g */
//#define GSL_CONST_CGSM_METRIC_TON (1e6) /* g */
//#define GSL_CONST_CGSM_TON (9.0718474e5) /* g */
//#define GSL_CONST_CGSM_OUNCE_MASS (2.8349523125e1) /* g */
//#define GSL_CONST_CGSM_POUND_MASS (4.5359237e2) /* g */
//#define GSL_CONST_CGSM_KNOT (5.14444444444e1) /* cm / s */
//#define GSL_CONST_CGSM_KILOMETERS_PER_HOUR (2.77777777778e1) /* cm / s */
//#define GSL_CONST_CGSM_MILES_PER_HOUR (4.4704e1) /* cm / s */
//#define GSL_CONST_CGSM_UK_GALLON (4.546092e3) /* cm^3 */
//#define GSL_CONST_CGSM_CANADIAN_GALLON (4.54609e3) /* cm^3 */
//#define GSL_CONST_CGSM_TEASPOON (4.92892159375e0) /* cm^3 */
//#define GSL_CONST_CGSM_TABLESPOON (1.47867647813e1) /* cm^3 */
//#define GSL_CONST_CGSM_FLUID_OUNCE (2.95735295626e1) /* cm^3 */
//#define GSL_CONST_CGSM_CUP (2.36588236501e2) /* cm^3 */
//#define GSL_CONST_CGSM_PINT (4.73176473002e2) /* cm^3 */
//#define GSL_CONST_CGSM_QUART (9.46352946004e2) /* cm^3 */
//#define GSL_CONST_CGSM_US_GALLON (3.78541178402e3) /* cm^3 */
//#define GSL_CONST_CGSM_LITER (1e3) /* cm^3 */
//#define GSL_CONST_CGSM_BARN (1e-24) /* cm^2 */
//#define GSL_CONST_CGSM_ACRE (4.04685642241e7) /* cm^2 */
//#define GSL_CONST_CGSM_HECTARE (1e8) /* cm^2 */
//#define GSL_CONST_CGSM_ANGSTROM (1e-8) /* cm */
//#define GSL_CONST_CGSM_MICRON (1e-4) /* cm */
//#define GSL_CONST_CGSM_TEXPOINT (3.51459803515e-2) /* cm */
//#define GSL_CONST_CGSM_POINT (3.52777777778e-2) /* cm */
//#define GSL_CONST_CGSM_MIL (2.54e-3) /* cm */
//#define GSL_CONST_CGSM_FATHOM (1.8288e2) /* cm */
//#define GSL_CONST_CGSM_NAUTICAL_MILE (1.852e5) /* cm */
//#define GSL_CONST_CGSM_MILE (1.609344e5) /* cm */
//#define GSL_CONST_CGSM_YARD (9.144e1) /* cm */
//#define GSL_CONST_CGSM_FOOT (3.048e1) /* cm */
//#define GSL_CONST_CGSM_INCH (2.54e0) /* cm */
//#define GSL_CONST_CGSM_WEEK (6.048e5) /* s */
//#define GSL_CONST_CGSM_DAY (8.64e4) /* s */
//#define GSL_CONST_CGSM_HOUR (3.6e3) /* s */
//#define GSL_CONST_CGSM_MINUTE (6e1) /* s */
//#define GSL_CONST_CGSM_STANDARD_GAS_VOLUME (2.2710981e4) /* cm^3 / mol */
//#define GSL_CONST_CGSM_MOLAR_GAS (8.314472e7) /* g cm^2 / K mol s^2 */
//#define GSL_CONST_CGSM_PROTON_MAGNETIC_MOMENT (1.410606633e-23) /* abamp cm^2 */
//#define GSL_CONST_CGSM_ELECTRON_MAGNETIC_MOMENT (9.28476362e-21) /* abamp cm^2 */
//#define GSL_CONST_CGSM_NUCLEAR_MAGNETON (5.05078317e-24) /* abamp cm^2 */
//#define GSL_CONST_CGSM_BOHR_MAGNETON (9.27400899e-21) /* abamp cm^2 */
//#define GSL_CONST_CGSM_BOLTZMANN (1.3806503e-16) /* g cm^2 / K s^2 */
//#define GSL_CONST_CGSM_RYDBERG (2.17987190389e-11) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_MASS_NEUTRON (1.67492716e-24) /* g */
//#define GSL_CONST_CGSM_MASS_PROTON (1.67262158e-24) /* g */
//#define GSL_CONST_CGSM_MASS_MUON (1.88353109e-25) /* g */
//#define GSL_CONST_CGSM_MASS_ELECTRON (9.10938188e-28) /* g */
//#define GSL_CONST_CGSM_ELECTRON_VOLT (1.602176462e-12) /* g cm^2 / s^2 */
//#define GSL_CONST_CGSM_GRAV_ACCEL (9.80665e2) /* cm / s^2 */
//#define GSL_CONST_CGSM_PARSEC (3.08567758135e18) /* cm */
//#define GSL_CONST_CGSM_LIGHT_YEAR (9.46053620707e17) /* cm */
//#define GSL_CONST_CGSM_ASTRONOMICAL_UNIT (1.49597870691e13) /* cm */
//#define GSL_CONST_CGSM_PLANCKS_CONSTANT_HBAR (1.05457159642e-27) /* g cm^2 / s */
//#define GSL_CONST_CGSM_PLANCKS_CONSTANT_H (6.62606876e-27) /* g cm^2 / s */
//#define GSL_CONST_CGSM_GRAVITATIONAL_CONSTANT (6.673e-8) /* cm^3 / g s^2 */
//#define GSL_CONST_CGSM_SPEED_OF_LIGHT (2.99792458e10) /* cm / s */
//#define __GSL_CONST_CGSM__
header '#include "gsl_const_cgsm.h"';

module gsl_const_cgsm_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_const_lib.flx')
@select(h)
//Module        : gsl_const_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_const.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_CONST__
header '#include "gsl_const.h"';

module gsl_const_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_const_mksa_lib.flx')
@select(h)
//Module        : gsl_const_mksa_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_const_mksa.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_CONST_MKSA_VACUUM_PERMEABILITY (1.25663706144e-6) /* kg m / A^2 s^2 */
//#define GSL_CONST_MKSA_VACUUM_PERMITTIVITY (8.854187817e-12) /* A^2 s^4 / kg m^3 */
//#define GSL_CONST_MKSA_THOMSON_CROSS_SECTION (6.65245853542e-29) /* m^2 */
//#define GSL_CONST_MKSA_STEFAN_BOLTZMANN_CONSTANT (5.67039934436e-8) /* kg / K^4 s^3 */
//#define GSL_CONST_MKSA_ERG (1e-7) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_JOULE (1e0) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_DYNE (1e-5) /* kg m / s^2 */
//#define GSL_CONST_MKSA_NEWTON (1e0) /* kg m / s^2 */
//#define GSL_CONST_MKSA_BOHR_RADIUS (5.291772083e-11) /* m */
//#define GSL_CONST_MKSA_SOLAR_MASS (1.98892e30) /* kg */
//#define GSL_CONST_MKSA_RAD (1e-2) /* m^2 / s^2 */
//#define GSL_CONST_MKSA_ROENTGEN (2.58e-4) /* A s / kg */
//#define GSL_CONST_MKSA_CURIE (3.7e10) /* 1 / s */
//#define GSL_CONST_MKSA_FOOTLAMBERT (1.07639104e1) /* cd sr / m^2 */
//#define GSL_CONST_MKSA_LAMBERT (1e4) /* cd sr / m^2 */
//#define GSL_CONST_MKSA_FOOTCANDLE (1.076e1) /* cd sr / m^2 */
//#define GSL_CONST_MKSA_PHOT (1e4) /* cd sr / m^2 */
//#define GSL_CONST_MKSA_LUX (1e0) /* cd sr / m^2 */
//#define GSL_CONST_MKSA_LUMEN (1e0) /* cd sr */
//#define GSL_CONST_MKSA_STILB (1e4) /* cd / m^2 */
//#define GSL_CONST_MKSA_GAUSS (1e-4) /* kg / A s^2 */
//#define GSL_CONST_MKSA_ELECTRON_CHARGE (1.602176462e-19) /* A s */
//#define GSL_CONST_MKSA_FARADAY (9.6485341472e4) /* A s / mol */
//#define GSL_CONST_MKSA_STOKES (1e-4) /* m^2 / s */
//#define GSL_CONST_MKSA_POISE (1e-1) /* kg m^-1 s^-1 */
//#define GSL_CONST_MKSA_PSI (6.89475729317e3) /* kg / m s^2 */
//#define GSL_CONST_MKSA_INCH_OF_WATER (2.490889e2) /* kg / m s^2 */
//#define GSL_CONST_MKSA_INCH_OF_MERCURY (3.38638815789e3) /* kg / m s^2 */
//#define GSL_CONST_MKSA_METER_OF_MERCURY (1.33322368421e5) /* kg / m s^2 */
//#define GSL_CONST_MKSA_TORR (1.33322368421e2) /* kg / m s^2 */
//#define GSL_CONST_MKSA_STD_ATMOSPHERE (1.01325e5) /* kg / m s^2 */
//#define GSL_CONST_MKSA_BAR (1e5) /* kg / m s^2 */
//#define GSL_CONST_MKSA_HORSEPOWER (7.457e2) /* kg m^2 / s^3 */
//#define GSL_CONST_MKSA_THERM (1.05506e8) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_BTU (1.05505585262e3) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_CALORIE (4.1868e0) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_POUNDAL (1.38255e-1) /* kg m / s^2 */
//#define GSL_CONST_MKSA_KILOPOUND_FORCE (4.44822161526e3) /* kg m / s^2 */
//#define GSL_CONST_MKSA_POUND_FORCE (4.44822161526e0) /* kg m / s^2 */
//#define GSL_CONST_MKSA_GRAM_FORCE (9.80665e-3) /* kg m / s^2 */
//#define GSL_CONST_MKSA_UNIFIED_ATOMIC_MASS (1.66053873e-27) /* kg */
//#define GSL_CONST_MKSA_CARAT (2e-4) /* kg */
//#define GSL_CONST_MKSA_TROY_OUNCE (3.1103475e-2) /* kg */
//#define GSL_CONST_MKSA_UK_TON (1.0160469088e3) /* kg */
//#define GSL_CONST_MKSA_METRIC_TON (1e3) /* kg */
//#define GSL_CONST_MKSA_TON (9.0718474e2) /* kg */
//#define GSL_CONST_MKSA_OUNCE_MASS (2.8349523125e-2) /* kg */
//#define GSL_CONST_MKSA_POUND_MASS (4.5359237e-1) /* kg */
//#define GSL_CONST_MKSA_KNOT (5.14444444444e-1) /* m / s */
//#define GSL_CONST_MKSA_KILOMETERS_PER_HOUR (2.77777777778e-1) /* m / s */
//#define GSL_CONST_MKSA_MILES_PER_HOUR (4.4704e-1) /* m / s */
//#define GSL_CONST_MKSA_UK_GALLON (4.546092e-3) /* m^3 */
//#define GSL_CONST_MKSA_CANADIAN_GALLON (4.54609e-3) /* m^3 */
//#define GSL_CONST_MKSA_TEASPOON (4.92892159375e-6) /* m^3 */
//#define GSL_CONST_MKSA_TABLESPOON (1.47867647813e-5) /* m^3 */
//#define GSL_CONST_MKSA_FLUID_OUNCE (2.95735295626e-5) /* m^3 */
//#define GSL_CONST_MKSA_CUP (2.36588236501e-4) /* m^3 */
//#define GSL_CONST_MKSA_PINT (4.73176473002e-4) /* m^3 */
//#define GSL_CONST_MKSA_QUART (9.46352946004e-4) /* m^3 */
//#define GSL_CONST_MKSA_US_GALLON (3.78541178402e-3) /* m^3 */
//#define GSL_CONST_MKSA_LITER (1e-3) /* m^3 */
//#define GSL_CONST_MKSA_BARN (1e-28) /* m^2 */
//#define GSL_CONST_MKSA_ACRE (4.04685642241e3) /* m^2 */
//#define GSL_CONST_MKSA_HECTARE (1e4) /* m^2 */
//#define GSL_CONST_MKSA_ANGSTROM (1e-10) /* m */
//#define GSL_CONST_MKSA_MICRON (1e-6) /* m */
//#define GSL_CONST_MKSA_TEXPOINT (3.51459803515e-4) /* m */
//#define GSL_CONST_MKSA_POINT (3.52777777778e-4) /* m */
//#define GSL_CONST_MKSA_MIL (2.54e-5) /* m */
//#define GSL_CONST_MKSA_FATHOM (1.8288e0) /* m */
//#define GSL_CONST_MKSA_NAUTICAL_MILE (1.852e3) /* m */
//#define GSL_CONST_MKSA_MILE (1.609344e3) /* m */
//#define GSL_CONST_MKSA_YARD (9.144e-1) /* m */
//#define GSL_CONST_MKSA_FOOT (3.048e-1) /* m */
//#define GSL_CONST_MKSA_INCH (2.54e-2) /* m */
//#define GSL_CONST_MKSA_WEEK (6.048e5) /* s */
//#define GSL_CONST_MKSA_DAY (8.64e4) /* s */
//#define GSL_CONST_MKSA_HOUR (3.6e3) /* s */
//#define GSL_CONST_MKSA_MINUTE (6e1) /* s */
//#define GSL_CONST_MKSA_STANDARD_GAS_VOLUME (2.2710981e-2) /* m^3 / mol */
//#define GSL_CONST_MKSA_MOLAR_GAS (8.314472e0) /* kg m^2 / K mol s^2 */
//#define GSL_CONST_MKSA_PROTON_MAGNETIC_MOMENT (1.410606633e-26) /* A m^2 */
//#define GSL_CONST_MKSA_ELECTRON_MAGNETIC_MOMENT (9.28476362e-24) /* A m^2 */
//#define GSL_CONST_MKSA_NUCLEAR_MAGNETON (5.05078317e-27) /* A m^2 */
//#define GSL_CONST_MKSA_BOHR_MAGNETON (9.27400899e-24) /* A m^2 */
//#define GSL_CONST_MKSA_BOLTZMANN (1.3806503e-23) /* kg m^2 / K s^2 */
//#define GSL_CONST_MKSA_RYDBERG (2.17987190389e-18) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_MASS_NEUTRON (1.67492716e-27) /* kg */
//#define GSL_CONST_MKSA_MASS_PROTON (1.67262158e-27) /* kg */
//#define GSL_CONST_MKSA_MASS_MUON (1.88353109e-28) /* kg */
//#define GSL_CONST_MKSA_MASS_ELECTRON (9.10938188e-31) /* kg */
//#define GSL_CONST_MKSA_ELECTRON_VOLT (1.602176462e-19) /* kg m^2 / s^2 */
//#define GSL_CONST_MKSA_GRAV_ACCEL (9.80665e0) /* m / s^2 */
//#define GSL_CONST_MKSA_PARSEC (3.08567758135e16) /* m */
//#define GSL_CONST_MKSA_LIGHT_YEAR (9.46053620707e15) /* m */
//#define GSL_CONST_MKSA_ASTRONOMICAL_UNIT (1.49597870691e11) /* m */
//#define GSL_CONST_MKSA_PLANCKS_CONSTANT_HBAR (1.05457159642e-34) /* kg m^2 / s */
//#define GSL_CONST_MKSA_PLANCKS_CONSTANT_H (6.62606876e-34) /* kg m^2 / s */
//#define GSL_CONST_MKSA_GRAVITATIONAL_CONSTANT (6.673e-11) /* m^3 / kg s^2 */
//#define GSL_CONST_MKSA_SPEED_OF_LIGHT (2.99792458e8) /* m / s */
//#define __GSL_CONST_MKSA__
header '#include "gsl_const_mksa.h"';

module gsl_const_mksa_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_const_mks_lib.flx')
@select(h)
//Module        : gsl_const_mks_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_const_mks.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_CONST_MKS_VACUUM_PERMEABILITY (1.25663706144e-6) /* kg m / A^2 s^2 */
//#define GSL_CONST_MKS_VACUUM_PERMITTIVITY (8.854187817e-12) /* A^2 s^4 / kg m^3 */
//#define GSL_CONST_MKS_THOMSON_CROSS_SECTION (6.65245853542e-29) /* m^2 */
//#define GSL_CONST_MKS_STEFAN_BOLTZMANN_CONSTANT (5.67039934436e-8) /* kg / K^4 s^3 */
//#define GSL_CONST_MKS_ERG (1e-7) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_JOULE (1e0) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_DYNE (1e-5) /* kg m / s^2 */
//#define GSL_CONST_MKS_NEWTON (1e0) /* kg m / s^2 */
//#define GSL_CONST_MKS_BOHR_RADIUS (5.291772083e-11) /* m */
//#define GSL_CONST_MKS_SOLAR_MASS (1.98892e30) /* kg */
//#define GSL_CONST_MKS_RAD (1e-2) /* m^2 / s^2 */
//#define GSL_CONST_MKS_ROENTGEN (2.58e-4) /* A s / kg */
//#define GSL_CONST_MKS_CURIE (3.7e10) /* 1 / s */
//#define GSL_CONST_MKS_FOOTLAMBERT (1.07639104e1) /* cd sr / m^2 */
//#define GSL_CONST_MKS_LAMBERT (1e4) /* cd sr / m^2 */
//#define GSL_CONST_MKS_FOOTCANDLE (1.076e1) /* cd sr / m^2 */
//#define GSL_CONST_MKS_PHOT (1e4) /* cd sr / m^2 */
//#define GSL_CONST_MKS_LUX (1e0) /* cd sr / m^2 */
//#define GSL_CONST_MKS_LUMEN (1e0) /* cd sr */
//#define GSL_CONST_MKS_STILB (1e4) /* cd / m^2 */
//#define GSL_CONST_MKS_GAUSS (1e-4) /* kg / A s^2 */
//#define GSL_CONST_MKS_ELECTRON_CHARGE (1.602176462e-19) /* A s */
//#define GSL_CONST_MKS_FARADAY (9.6485341472e4) /* A s / mol */
//#define GSL_CONST_MKS_STOKES (1e-4) /* m^2 / s */
//#define GSL_CONST_MKS_POISE (1e-1) /* kg m^-1 s^-1 */
//#define GSL_CONST_MKS_PSI (6.89475729317e3) /* kg / m s^2 */
//#define GSL_CONST_MKS_INCH_OF_WATER (2.490889e2) /* kg / m s^2 */
//#define GSL_CONST_MKS_INCH_OF_MERCURY (3.38638815789e3) /* kg / m s^2 */
//#define GSL_CONST_MKS_METER_OF_MERCURY (1.33322368421e5) /* kg / m s^2 */
//#define GSL_CONST_MKS_TORR (1.33322368421e2) /* kg / m s^2 */
//#define GSL_CONST_MKS_STD_ATMOSPHERE (1.01325e5) /* kg / m s^2 */
//#define GSL_CONST_MKS_BAR (1e5) /* kg / m s^2 */
//#define GSL_CONST_MKS_HORSEPOWER (7.457e2) /* kg m^2 / s^3 */
//#define GSL_CONST_MKS_THERM (1.05506e8) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_BTU (1.05505585262e3) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_CALORIE (4.1868e0) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_POUNDAL (1.38255e-1) /* kg m / s^2 */
//#define GSL_CONST_MKS_KILOPOUND_FORCE (4.44822161526e3) /* kg m / s^2 */
//#define GSL_CONST_MKS_POUND_FORCE (4.44822161526e0) /* kg m / s^2 */
//#define GSL_CONST_MKS_GRAM_FORCE (9.80665e-3) /* kg m / s^2 */
//#define GSL_CONST_MKS_UNIFIED_ATOMIC_MASS (1.66053873e-27) /* kg */
//#define GSL_CONST_MKS_CARAT (2e-4) /* kg */
//#define GSL_CONST_MKS_TROY_OUNCE (3.1103475e-2) /* kg */
//#define GSL_CONST_MKS_UK_TON (1.0160469088e3) /* kg */
//#define GSL_CONST_MKS_METRIC_TON (1e3) /* kg */
//#define GSL_CONST_MKS_TON (9.0718474e2) /* kg */
//#define GSL_CONST_MKS_OUNCE_MASS (2.8349523125e-2) /* kg */
//#define GSL_CONST_MKS_POUND_MASS (4.5359237e-1) /* kg */
//#define GSL_CONST_MKS_KNOT (5.14444444444e-1) /* m / s */
//#define GSL_CONST_MKS_KILOMETERS_PER_HOUR (2.77777777778e-1) /* m / s */
//#define GSL_CONST_MKS_MILES_PER_HOUR (4.4704e-1) /* m / s */
//#define GSL_CONST_MKS_UK_GALLON (4.546092e-3) /* m^3 */
//#define GSL_CONST_MKS_CANADIAN_GALLON (4.54609e-3) /* m^3 */
//#define GSL_CONST_MKS_TEASPOON (4.92892159375e-6) /* m^3 */
//#define GSL_CONST_MKS_TABLESPOON (1.47867647813e-5) /* m^3 */
//#define GSL_CONST_MKS_FLUID_OUNCE (2.95735295626e-5) /* m^3 */
//#define GSL_CONST_MKS_CUP (2.36588236501e-4) /* m^3 */
//#define GSL_CONST_MKS_PINT (4.73176473002e-4) /* m^3 */
//#define GSL_CONST_MKS_QUART (9.46352946004e-4) /* m^3 */
//#define GSL_CONST_MKS_US_GALLON (3.78541178402e-3) /* m^3 */
//#define GSL_CONST_MKS_LITER (1e-3) /* m^3 */
//#define GSL_CONST_MKS_BARN (1e-28) /* m^2 */
//#define GSL_CONST_MKS_ACRE (4.04685642241e3) /* m^2 */
//#define GSL_CONST_MKS_HECTARE (1e4) /* m^2 */
//#define GSL_CONST_MKS_ANGSTROM (1e-10) /* m */
//#define GSL_CONST_MKS_MICRON (1e-6) /* m */
//#define GSL_CONST_MKS_TEXPOINT (3.51459803515e-4) /* m */
//#define GSL_CONST_MKS_POINT (3.52777777778e-4) /* m */
//#define GSL_CONST_MKS_MIL (2.54e-5) /* m */
//#define GSL_CONST_MKS_FATHOM (1.8288e0) /* m */
//#define GSL_CONST_MKS_NAUTICAL_MILE (1.852e3) /* m */
//#define GSL_CONST_MKS_MILE (1.609344e3) /* m */
//#define GSL_CONST_MKS_YARD (9.144e-1) /* m */
//#define GSL_CONST_MKS_FOOT (3.048e-1) /* m */
//#define GSL_CONST_MKS_INCH (2.54e-2) /* m */
//#define GSL_CONST_MKS_WEEK (6.048e5) /* s */
//#define GSL_CONST_MKS_DAY (8.64e4) /* s */
//#define GSL_CONST_MKS_HOUR (3.6e3) /* s */
//#define GSL_CONST_MKS_MINUTE (6e1) /* s */
//#define GSL_CONST_MKS_STANDARD_GAS_VOLUME (2.2710981e-2) /* m^3 / mol */
//#define GSL_CONST_MKS_MOLAR_GAS (8.314472e0) /* kg m^2 / K mol s^2 */
//#define GSL_CONST_MKS_PROTON_MAGNETIC_MOMENT (1.410606633e-26) /* A m^2 */
//#define GSL_CONST_MKS_ELECTRON_MAGNETIC_MOMENT (9.28476362e-24) /* A m^2 */
//#define GSL_CONST_MKS_NUCLEAR_MAGNETON (5.05078317e-27) /* A m^2 */
//#define GSL_CONST_MKS_BOHR_MAGNETON (9.27400899e-24) /* A m^2 */
//#define GSL_CONST_MKS_BOLTZMANN (1.3806503e-23) /* kg m^2 / K s^2 */
//#define GSL_CONST_MKS_RYDBERG (2.17987190389e-18) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_MASS_NEUTRON (1.67492716e-27) /* kg */
//#define GSL_CONST_MKS_MASS_PROTON (1.67262158e-27) /* kg */
//#define GSL_CONST_MKS_MASS_MUON (1.88353109e-28) /* kg */
//#define GSL_CONST_MKS_MASS_ELECTRON (9.10938188e-31) /* kg */
//#define GSL_CONST_MKS_ELECTRON_VOLT (1.602176462e-19) /* kg m^2 / s^2 */
//#define GSL_CONST_MKS_GRAV_ACCEL (9.80665e0) /* m / s^2 */
//#define GSL_CONST_MKS_PARSEC (3.08567758135e16) /* m */
//#define GSL_CONST_MKS_LIGHT_YEAR (9.46053620707e15) /* m */
//#define GSL_CONST_MKS_ASTRONOMICAL_UNIT (1.49597870691e11) /* m */
//#define GSL_CONST_MKS_PLANCKS_CONSTANT_HBAR (1.05457159642e-34) /* kg m^2 / s */
//#define GSL_CONST_MKS_PLANCKS_CONSTANT_H (6.62606876e-34) /* kg m^2 / s */
//#define GSL_CONST_MKS_GRAVITATIONAL_CONSTANT (6.673e-11) /* m^3 / kg s^2 */
//#define GSL_CONST_MKS_SPEED_OF_LIGHT (2.99792458e8) /* m / s */
//#define __GSL_CONST_MKS__
header '#include "gsl_const_mks.h"';

module gsl_const_mks_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_const_num_lib.flx')
@select(h)
//Module        : gsl_const_num_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_const_num.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_CONST_NUM_YOCTO (1e-24) /* 1 */
//#define GSL_CONST_NUM_ZEPTO (1e-21) /* 1 */
//#define GSL_CONST_NUM_ATTO (1e-18) /* 1 */
//#define GSL_CONST_NUM_FEMTO (1e-15) /* 1 */
//#define GSL_CONST_NUM_PICO (1e-12) /* 1 */
//#define GSL_CONST_NUM_NANO (1e-9) /* 1 */
//#define GSL_CONST_NUM_MICRO (1e-6) /* 1 */
//#define GSL_CONST_NUM_MILLI (1e-3) /* 1 */
//#define GSL_CONST_NUM_KILO (1e3) /* 1 */
//#define GSL_CONST_NUM_MEGA (1e6) /* 1 */
//#define GSL_CONST_NUM_GIGA (1e9) /* 1 */
//#define GSL_CONST_NUM_TERA (1e12) /* 1 */
//#define GSL_CONST_NUM_PETA (1e15) /* 1 */
//#define GSL_CONST_NUM_EXA (1e18) /* 1 */
//#define GSL_CONST_NUM_ZETTA (1e21) /* 1 */
//#define GSL_CONST_NUM_YOTTA (1e24) /* 1 */
//#define GSL_CONST_NUM_AVOGADRO (6.02214199e23) /* 1 / mol */
//#define GSL_CONST_NUM_FINE_STRUCTURE (7.297352533e-3) /* 1 */
//#define __GSL_CONST_NUM__
header '#include "gsl_const_num.h"';

module gsl_const_num_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_deriv_lib.flx')
@select(h)
//Module        : gsl_deriv_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_deriv.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_DERIV_H__
header '#include "gsl_deriv.h"';

//INCLUDES
include "gsl_math_lib";

module gsl_deriv_h
{
  open C_hack;
  open gsl_math_h;
  
  //FUNCTIONS
  fun gsl_deriv_backward: cptr[gsl_function] * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_deriv_central: cptr[gsl_function] * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_deriv_forward: cptr[gsl_function] * double * double * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_dft_complex_float_lib.flx')
@select(h)
//Module        : gsl_dft_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_dft_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_DFT_COMPLEX_FLOAT_H__
header '#include "gsl_dft_complex_float.h"';

//INCLUDES
include "gsl_fft_lib";

module gsl_dft_complex_float_h
{
  open C_hack;
  open gsl_fft_h;
  
  //FUNCTIONS
  fun gsl_dft_complex_float_backward: cptr[float] * size * size * ptr[float] -> int;
  fun gsl_dft_complex_float_forward: cptr[float] * size * size * ptr[float] -> int;
  fun gsl_dft_complex_float_inverse: cptr[float] * size * size * ptr[float] -> int;
  fun gsl_dft_complex_float_transform: cptr[float] * size * size * ptr[float] * gsl_fft_direction -> int;
}
@h=tangler('lib/gsl/gsl_dft_complex_lib.flx')
@select(h)
//Module        : gsl_dft_complex_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_dft_complex.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_DFT_COMPLEX_H__
header '#include "gsl_dft_complex.h"';

//INCLUDES
include "gsl_fft_lib";

module gsl_dft_complex_h
{
  open C_hack;
  open gsl_fft_h;
  
  //FUNCTIONS
  fun gsl_dft_complex_backward: cptr[double] * size * size * ptr[double] -> int;
  fun gsl_dft_complex_forward: cptr[double] * size * size * ptr[double] -> int;
  fun gsl_dft_complex_inverse: cptr[double] * size * size * ptr[double] -> int;
  fun gsl_dft_complex_transform: cptr[double] * size * size * ptr[double] * gsl_fft_direction -> int;
}
@h=tangler('lib/gsl/gsl_dht_lib.flx')
@select(h)
//Module        : gsl_dht_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_dht.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_DHT_H__
header '#include "gsl_dht.h"';

//INCLUDES
include "gsl_dht_struct_lib";

module gsl_dht_h
{
  open C_hack;
  open gsl_dht_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_dht_struct {
    size: size;
    nu: double;
    xmax: double;
    kmax: double;
    j: ptr[double];
    Jjj: ptr[double];
    J2: ptr[double];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_dht = gsl_dht_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_dht_struct = gsl_dht_struct;
  
  //PROCEDURES
  proc gsl_dht_free: ptr[gsl_dht];
  
  //FUNCTIONS
  fun gsl_dht_alloc: size -> ptr[gsl_dht];
  fun gsl_dht_apply: cptr[gsl_dht] * ptr[double] * ptr[double] -> int;
  fun gsl_dht_init: ptr[gsl_dht] * double * double -> int;
  fun gsl_dht_k_sample: cptr[gsl_dht] * int -> double;
  fun gsl_dht_new: size * double * double -> ptr[gsl_dht];
  fun gsl_dht_x_sample: cptr[gsl_dht] * int -> double;
}
@h=tangler('lib/gsl/gsl_dht_struct_lib.flx')
@select(h)
//Module        : gsl_dht_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_dht_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_dht_struct"';

module gsl_dht_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_diff_lib.flx')
@select(h)
//Module        : gsl_diff_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_diff.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_DIFF_H__
header '#include "gsl_diff.h"';

//INCLUDES
include "gsl_math_lib";

module gsl_diff_h
{
  open C_hack;
  open gsl_math_h;
  
  //FUNCTIONS
  fun gsl_diff_backward: cptr[gsl_function] * double * ptr[double] * ptr[double] -> int;
  fun gsl_diff_central: cptr[gsl_function] * double * ptr[double] * ptr[double] -> int;
  fun gsl_diff_forward: cptr[gsl_function] * double * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_eigen_lib.flx')
@select(h)
//Module        : gsl_eigen_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_eigen.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_EIGEN_H__
header '#include "gsl_eigen.h"';

//INCLUDES
include "gsl_matrix_complex_double_lib";
include "gsl_matrix_double_lib";
include "gsl_vector_double_lib";

module gsl_eigen_h
{
  open C_hack;
  open gsl_matrix_complex_double_h;
  open gsl_matrix_double_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type gsl_eigen_symmv_workspace = 'gsl_eigen_symmv_workspace';
  type gsl_eigen_herm_workspace = 'gsl_eigen_herm_workspace';
  type gsl_eigen_sort_t = 'gsl_eigen_sort_t';
  type gsl_eigen_symm_workspace = 'gsl_eigen_symm_workspace';
  type gsl_eigen_hermv_workspace = 'gsl_eigen_hermv_workspace';
  
  //ENUMERATION CONSTANTS
  const GSL_EIGEN_SORT_ABS_DESC: int = 'GSL_EIGEN_SORT_ABS_DESC';
  const GSL_EIGEN_SORT_VAL_DESC: int = 'GSL_EIGEN_SORT_VAL_DESC';
  const GSL_EIGEN_SORT_VAL_ASC: int = 'GSL_EIGEN_SORT_VAL_ASC';
  const GSL_EIGEN_SORT_ABS_ASC: int = 'GSL_EIGEN_SORT_ABS_ASC';
  
  //PROCEDURES
  proc gsl_eigen_herm_free: ptr[gsl_eigen_herm_workspace];
  proc gsl_eigen_hermv_free: ptr[gsl_eigen_hermv_workspace];
  proc gsl_eigen_symm_free: ptr[gsl_eigen_symm_workspace];
  proc gsl_eigen_symmv_free: ptr[gsl_eigen_symmv_workspace];
  
  //FUNCTIONS
  fun gsl_eigen_herm: ptr[gsl_matrix_complex] * ptr[gsl_vector] * ptr[gsl_eigen_herm_workspace] -> int;
  fun gsl_eigen_herm_alloc: size -> ptr[gsl_eigen_herm_workspace];
  fun gsl_eigen_hermv: ptr[gsl_matrix_complex] * ptr[gsl_vector] * ptr[gsl_matrix_complex] * ptr[gsl_eigen_hermv_workspace] -> int;
  fun gsl_eigen_hermv_alloc: size -> ptr[gsl_eigen_hermv_workspace];
  fun gsl_eigen_hermv_sort: ptr[gsl_vector] * ptr[gsl_matrix_complex] * gsl_eigen_sort_t -> int;
  fun gsl_eigen_invert_jacobi: cptr[gsl_matrix] * ptr[gsl_matrix] * uint -> int;
  fun gsl_eigen_jacobi: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_matrix] * uint * ptr[uint] -> int;
  fun gsl_eigen_symm: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_eigen_symm_workspace] -> int;
  fun gsl_eigen_symm_alloc: size -> ptr[gsl_eigen_symm_workspace];
  fun gsl_eigen_symmv: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_matrix] * ptr[gsl_eigen_symmv_workspace] -> int;
  fun gsl_eigen_symmv_alloc: size -> ptr[gsl_eigen_symmv_workspace];
  fun gsl_eigen_symmv_sort: ptr[gsl_vector] * ptr[gsl_matrix] * gsl_eigen_sort_t -> int;
}
@h=tangler('lib/gsl/gsl_errno_lib.flx')
@select(h)
//Module        : gsl_errno_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_errno.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_STATUS_UPDATE(sp, s) do { if ((s) != GSL_SUCCESS) *(sp) = (s);} while(0)
//#define GSL_ERROR_SELECT_5(a,b,c,d,e) ((a) != GSL_SUCCESS ? (a) : GSL_ERROR_SELECT_4(b,c,d,e))
//#define GSL_ERROR_SELECT_4(a,b,c,d)   ((a) != GSL_SUCCESS ? (a) : GSL_ERROR_SELECT_3(b,c,d))
//#define GSL_ERROR_SELECT_3(a,b,c)     ((a) != GSL_SUCCESS ? (a) : GSL_ERROR_SELECT_2(b,c))
//#define GSL_ERROR_SELECT_2(a,b)       ((a) != GSL_SUCCESS ? (a) : ((b) != GSL_SUCCESS ? (b) : GSL_SUCCESS))
//#define GSL_ERROR_NULL(reason, gsl_errno) GSL_ERROR_VAL(reason, gsl_errno, 0)
//#define GSL_ERROR_VOID(reason, gsl_errno) \
//#define GSL_ERROR_VAL(reason, gsl_errno, value) \
//#define GSL_ERROR(reason, gsl_errno) \
//#define __GSL_ERRNO_H__
header '#include "gsl_errno.h"';

//INCLUDES

module gsl_errno_h
{
  open C_hack;
  
  //TYPE ALIASES
  typedef gsl_error_handler_t = cptr[char] * cptr[char] * int * int -> void_t;
  typedef gsl_stream_handler_t = cptr[char] * cptr[char] * int * cptr[char] -> void_t;
  
  //ENUMERATION CONSTANTS
  const GSL_FAILURE: int = 'GSL_FAILURE';
  const GSL_ETOLF: int = 'GSL_ETOLF';
  const GSL_EZERODIV: int = 'GSL_EZERODIV';
  const GSL_ETOLG: int = 'GSL_ETOLG';
  const GSL_EUNSUP: int = 'GSL_EUNSUP';
  const GSL_EUNIMPL: int = 'GSL_EUNIMPL';
  const GSL_EINVAL: int = 'GSL_EINVAL';
  const GSL_EOVRFLW: int = 'GSL_EOVRFLW';
  const GSL_EFACTOR: int = 'GSL_EFACTOR';
  const GSL_ETOLX: int = 'GSL_ETOLX';
  const GSL_ETABLE: int = 'GSL_ETABLE';
  const GSL_EDIVERGE: int = 'GSL_EDIVERGE';
  const GSL_ERUNAWAY: int = 'GSL_ERUNAWAY';
  const GSL_EROUND: int = 'GSL_EROUND';
  const GSL_SUCCESS: int = 'GSL_SUCCESS';
  const GSL_ETOL: int = 'GSL_ETOL';
  const GSL_EMAXITER: int = 'GSL_EMAXITER';
  const GSL_ECACHE: int = 'GSL_ECACHE';
  const GSL_ESING: int = 'GSL_ESING';
  const GSL_ENOPROG: int = 'GSL_ENOPROG';
  const GSL_ESANITY: int = 'GSL_ESANITY';
  const GSL_EOF: int = 'GSL_EOF';
  const GSL_ENOPROGJ: int = 'GSL_ENOPROGJ';
  const GSL_ENOTSQR: int = 'GSL_ENOTSQR';
  const GSL_EFAILED: int = 'GSL_EFAILED';
  const GSL_EBADFUNC: int = 'GSL_EBADFUNC';
  const GSL_EBADTOL: int = 'GSL_EBADTOL';
  const GSL_EUNDRFLW: int = 'GSL_EUNDRFLW';
  const GSL_ENOMEM: int = 'GSL_ENOMEM';
  const GSL_EDOM: int = 'GSL_EDOM';
  const GSL_ELOSS: int = 'GSL_ELOSS';
  const GSL_EFAULT: int = 'GSL_EFAULT';
  const GSL_ERANGE: int = 'GSL_ERANGE';
  const GSL_EBADLEN: int = 'GSL_EBADLEN';
  const GSL_CONTINUE: int = 'GSL_CONTINUE';
  
  //PROCEDURES
  proc gsl_error: cptr[char] * cptr[char] * int * int;
  proc gsl_stream_printf: cptr[char] * cptr[char] * int * cptr[char];
  
  //FUNCTIONS
  fun gsl_set_error_handler: ptr[gsl_error_handler_t] -> ptr[gsl_error_handler_t];
  fun gsl_set_error_handler_off: 1 -> ptr[gsl_error_handler_t];
  fun gsl_set_stream: ptr[FILE] -> ptr[FILE];
  fun gsl_set_stream_handler: ptr[gsl_stream_handler_t] -> ptr[gsl_stream_handler_t];
  fun gsl_strerror: int -> cptr[char];
}
@h=tangler('lib/gsl/gsl_fft_complex_float_lib.flx')
@select(h)
//Module        : gsl_fft_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_COMPLEX_FLOAT_H__
header '#include "gsl_fft_complex_float.h"';

//INCLUDES
include "gsl_complex_lib";
include "gsl_fft_lib";

module gsl_fft_complex_float_h
{
  open C_hack;
  open gsl_complex_h;
  open gsl_fft_h;
  
  //ABSTRACT TYPES
  type gsl_fft_complex_workspace_float = 'gsl_fft_complex_workspace_float';
  type gsl_fft_complex_wavetable_float = 'gsl_fft_complex_wavetable_float';
  
  //PROCEDURES
  proc gsl_fft_complex_wavetable_float_free: ptr[gsl_fft_complex_wavetable_float];
  proc gsl_fft_complex_workspace_float_free: ptr[gsl_fft_complex_workspace_float];
  
  //FUNCTIONS
  fun gsl_fft_complex_float_backward: gsl_complex_packed_array_float * size * size * cptr[gsl_fft_complex_wavetable_float] * ptr[gsl_fft_complex_workspace_float] -> int;
  fun gsl_fft_complex_float_forward: gsl_complex_packed_array_float * size * size * cptr[gsl_fft_complex_wavetable_float] * ptr[gsl_fft_complex_workspace_float] -> int;
  fun gsl_fft_complex_float_inverse: gsl_complex_packed_array_float * size * size * cptr[gsl_fft_complex_wavetable_float] * ptr[gsl_fft_complex_workspace_float] -> int;
  fun gsl_fft_complex_float_memcpy: ptr[gsl_fft_complex_wavetable_float] * ptr[gsl_fft_complex_wavetable_float] -> int;
  fun gsl_fft_complex_float_radix2_backward: gsl_complex_packed_array_float * size * size -> int;
  fun gsl_fft_complex_float_radix2_dif_backward: gsl_complex_packed_array_float * size * size -> int;
  fun gsl_fft_complex_float_radix2_dif_forward: gsl_complex_packed_array_float * size * size -> int;
  fun gsl_fft_complex_float_radix2_dif_inverse: gsl_complex_packed_array_float * size * size -> int;
  fun gsl_fft_complex_float_radix2_dif_transform: gsl_complex_packed_array_float * size * size * gsl_fft_direction -> int;
  fun gsl_fft_complex_float_radix2_forward: gsl_complex_packed_array_float * size * size -> int;
  fun gsl_fft_complex_float_radix2_inverse: gsl_complex_packed_array_float * size * size -> int;
  fun gsl_fft_complex_float_radix2_transform: gsl_complex_packed_array_float * size * size * gsl_fft_direction -> int;
  fun gsl_fft_complex_float_transform: gsl_complex_packed_array_float * size * size * cptr[gsl_fft_complex_wavetable_float] * ptr[gsl_fft_complex_workspace_float] * gsl_fft_direction -> int;
  fun gsl_fft_complex_wavetable_float_alloc: size -> ptr[gsl_fft_complex_wavetable_float];
  fun gsl_fft_complex_workspace_float_alloc: size -> ptr[gsl_fft_complex_workspace_float];
}
@h=tangler('lib/gsl/gsl_fft_complex_lib.flx')
@select(h)
//Module        : gsl_fft_complex_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft_complex.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_COMPLEX_H__
header '#include "gsl_fft_complex.h"';

//INCLUDES
include "gsl_complex_lib";
include "gsl_fft_lib";

module gsl_fft_complex_h
{
  open C_hack;
  open gsl_complex_h;
  open gsl_fft_h;
  
  //ABSTRACT TYPES
  type gsl_fft_complex_wavetable = 'gsl_fft_complex_wavetable';
  type gsl_fft_complex_workspace = 'gsl_fft_complex_workspace';
  
  //PROCEDURES
  proc gsl_fft_complex_wavetable_free: ptr[gsl_fft_complex_wavetable];
  proc gsl_fft_complex_workspace_free: ptr[gsl_fft_complex_workspace];
  
  //FUNCTIONS
  fun gsl_fft_complex_backward: gsl_complex_packed_array * size * size * cptr[gsl_fft_complex_wavetable] * ptr[gsl_fft_complex_workspace] -> int;
  fun gsl_fft_complex_forward: gsl_complex_packed_array * size * size * cptr[gsl_fft_complex_wavetable] * ptr[gsl_fft_complex_workspace] -> int;
  fun gsl_fft_complex_inverse: gsl_complex_packed_array * size * size * cptr[gsl_fft_complex_wavetable] * ptr[gsl_fft_complex_workspace] -> int;
  fun gsl_fft_complex_memcpy: ptr[gsl_fft_complex_wavetable] * ptr[gsl_fft_complex_wavetable] -> int;
  fun gsl_fft_complex_radix2_backward: gsl_complex_packed_array * size * size -> int;
  fun gsl_fft_complex_radix2_dif_backward: gsl_complex_packed_array * size * size -> int;
  fun gsl_fft_complex_radix2_dif_forward: gsl_complex_packed_array * size * size -> int;
  fun gsl_fft_complex_radix2_dif_inverse: gsl_complex_packed_array * size * size -> int;
  fun gsl_fft_complex_radix2_dif_transform: gsl_complex_packed_array * size * size * gsl_fft_direction -> int;
  fun gsl_fft_complex_radix2_forward: gsl_complex_packed_array * size * size -> int;
  fun gsl_fft_complex_radix2_inverse: gsl_complex_packed_array * size * size -> int;
  fun gsl_fft_complex_radix2_transform: gsl_complex_packed_array * size * size * gsl_fft_direction -> int;
  fun gsl_fft_complex_transform: gsl_complex_packed_array * size * size * cptr[gsl_fft_complex_wavetable] * ptr[gsl_fft_complex_workspace] * gsl_fft_direction -> int;
  fun gsl_fft_complex_wavetable_alloc: size -> ptr[gsl_fft_complex_wavetable];
  fun gsl_fft_complex_workspace_alloc: size -> ptr[gsl_fft_complex_workspace];
}
@h=tangler('lib/gsl/gsl_fft_halfcomplex_float_lib.flx')
@select(h)
//Module        : gsl_fft_halfcomplex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft_halfcomplex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_HALFCOMPLEX_FLOAT_H__
header '#include "gsl_fft_halfcomplex_float.h"';

//INCLUDES
include "gsl_fft_real_float_lib";

module gsl_fft_halfcomplex_float_h
{
  open C_hack;
  open gsl_fft_real_float_h;
  
  //ABSTRACT TYPES
  type gsl_fft_halfcomplex_wavetable_float = 'gsl_fft_halfcomplex_wavetable_float';
  
  //PROCEDURES
  proc gsl_fft_halfcomplex_wavetable_float_free: ptr[gsl_fft_halfcomplex_wavetable_float];
  
  //FUNCTIONS
  fun gsl_fft_halfcomplex_float_backward: ptr[float] * size * size * cptr[gsl_fft_halfcomplex_wavetable_float] * ptr[gsl_fft_real_workspace_float] -> int;
  fun gsl_fft_halfcomplex_float_inverse: ptr[float] * size * size * cptr[gsl_fft_halfcomplex_wavetable_float] * ptr[gsl_fft_real_workspace_float] -> int;
  fun gsl_fft_halfcomplex_float_radix2_backward: ptr[float] * size * size -> int;
  fun gsl_fft_halfcomplex_float_radix2_inverse: ptr[float] * size * size -> int;
  fun gsl_fft_halfcomplex_float_radix2_transform: ptr[float] * size * size -> int;
  fun gsl_fft_halfcomplex_float_radix2_unpack: cptr[float] * ptr[float] * size * size -> int;
  fun gsl_fft_halfcomplex_float_transform: ptr[float] * size * size * cptr[gsl_fft_halfcomplex_wavetable_float] * ptr[gsl_fft_real_workspace_float] -> int;
  fun gsl_fft_halfcomplex_float_unpack: cptr[float] * ptr[float] * size * size -> int;
  fun gsl_fft_halfcomplex_wavetable_float_alloc: size -> ptr[gsl_fft_halfcomplex_wavetable_float];
}
@h=tangler('lib/gsl/gsl_fft_halfcomplex_lib.flx')
@select(h)
//Module        : gsl_fft_halfcomplex_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft_halfcomplex.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_HALFCOMPLEX_H__
header '#include "gsl_fft_halfcomplex.h"';

//INCLUDES
include "gsl_fft_real_lib";

module gsl_fft_halfcomplex_h
{
  open C_hack;
  open gsl_fft_real_h;
  
  //ABSTRACT TYPES
  type gsl_fft_halfcomplex_wavetable = 'gsl_fft_halfcomplex_wavetable';
  
  //PROCEDURES
  proc gsl_fft_halfcomplex_wavetable_free: ptr[gsl_fft_halfcomplex_wavetable];
  
  //FUNCTIONS
  fun gsl_fft_halfcomplex_backward: ptr[double] * size * size * cptr[gsl_fft_halfcomplex_wavetable] * ptr[gsl_fft_real_workspace] -> int;
  fun gsl_fft_halfcomplex_inverse: ptr[double] * size * size * cptr[gsl_fft_halfcomplex_wavetable] * ptr[gsl_fft_real_workspace] -> int;
  fun gsl_fft_halfcomplex_radix2_backward: ptr[double] * size * size -> int;
  fun gsl_fft_halfcomplex_radix2_inverse: ptr[double] * size * size -> int;
  fun gsl_fft_halfcomplex_radix2_transform: ptr[double] * size * size -> int;
  fun gsl_fft_halfcomplex_radix2_unpack: cptr[double] * ptr[double] * size * size -> int;
  fun gsl_fft_halfcomplex_transform: ptr[double] * size * size * cptr[gsl_fft_halfcomplex_wavetable] * ptr[gsl_fft_real_workspace] -> int;
  fun gsl_fft_halfcomplex_unpack: cptr[double] * ptr[double] * size * size -> int;
  fun gsl_fft_halfcomplex_wavetable_alloc: size -> ptr[gsl_fft_halfcomplex_wavetable];
}
@h=tangler('lib/gsl/gsl_fft_lib.flx')
@select(h)
//Module        : gsl_fft_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_H__
header '#include "gsl_fft.h"';

module gsl_fft_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_fft_direction = 'gsl_fft_direction';
  
  //ENUMERATION CONSTANTS
  const backward: int = 'backward';
  const forward: int = 'forward';
}
@h=tangler('lib/gsl/gsl_fft_real_float_lib.flx')
@select(h)
//Module        : gsl_fft_real_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft_real_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_REAL_FLOAT_H__
header '#include "gsl_fft_real_float.h"';

module gsl_fft_real_float_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_fft_real_workspace_float = 'gsl_fft_real_workspace_float';
  type gsl_fft_real_wavetable_float = 'gsl_fft_real_wavetable_float';
  
  //PROCEDURES
  proc gsl_fft_real_wavetable_float_free: ptr[gsl_fft_real_wavetable_float];
  proc gsl_fft_real_workspace_float_free: ptr[gsl_fft_real_workspace_float];
  
  //FUNCTIONS
  fun gsl_fft_real_float_radix2_transform: ptr[float] * size * size -> int;
  fun gsl_fft_real_float_transform: ptr[float] * size * size * cptr[gsl_fft_real_wavetable_float] * ptr[gsl_fft_real_workspace_float] -> int;
  fun gsl_fft_real_float_unpack: cptr[float] * ptr[float] * size * size -> int;
  fun gsl_fft_real_wavetable_float_alloc: size -> ptr[gsl_fft_real_wavetable_float];
  fun gsl_fft_real_workspace_float_alloc: size -> ptr[gsl_fft_real_workspace_float];
}
@h=tangler('lib/gsl/gsl_fft_real_lib.flx')
@select(h)
//Module        : gsl_fft_real_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fft_real.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FFT_REAL_H__
header '#include "gsl_fft_real.h"';

module gsl_fft_real_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_fft_real_workspace = 'gsl_fft_real_workspace';
  type gsl_fft_real_wavetable = 'gsl_fft_real_wavetable';
  
  //PROCEDURES
  proc gsl_fft_real_wavetable_free: ptr[gsl_fft_real_wavetable];
  proc gsl_fft_real_workspace_free: ptr[gsl_fft_real_workspace];
  
  //FUNCTIONS
  fun gsl_fft_real_radix2_transform: ptr[double] * size * size -> int;
  fun gsl_fft_real_transform: ptr[double] * size * size * cptr[gsl_fft_real_wavetable] * ptr[gsl_fft_real_workspace] -> int;
  fun gsl_fft_real_unpack: cptr[double] * ptr[double] * size * size -> int;
  fun gsl_fft_real_wavetable_alloc: size -> ptr[gsl_fft_real_wavetable];
  fun gsl_fft_real_workspace_alloc: size -> ptr[gsl_fft_real_workspace];
}
@h=tangler('lib/gsl/gsl_fit_lib.flx')
@select(h)
//Module        : gsl_fit_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_fit.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_FIT_H__
header '#include "gsl_fit.h"';

module gsl_fit_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_fit_linear: cptr[double] * size * cptr[double] * size * size * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_fit_linear_est: double * double * double * double * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_fit_mul: cptr[double] * size * cptr[double] * size * size * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_fit_mul_est: double * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_fit_wlinear: cptr[double] * size * cptr[double] * size * cptr[double] * size * size * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_fit_wmul: cptr[double] * size * cptr[double] * size * cptr[double] * size * size * ptr[double] * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_function_fdf_struct_lib.flx')
@select(h)
//Module        : gsl_function_fdf_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_function_fdf_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_function_fdf_struct"';

module gsl_function_fdf_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_function_struct_lib.flx')
@select(h)
//Module        : gsl_function_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_function_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_function_struct"';

module gsl_function_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_function_vec_struct_lib.flx')
@select(h)
//Module        : gsl_function_vec_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_function_vec_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_function_vec_struct"';

module gsl_function_vec_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_heapsort_lib.flx')
@select(h)
//Module        : gsl_heapsort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_heapsort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_HEAPSORT_H__
header '#include "gsl_heapsort.h"';

module gsl_heapsort_h
{
  open C_hack;
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*gsl_heapsort_h_cft_1)(void const *,  void const *);''';
  type gsl_heapsort_h_cft_1 = 'gsl_heapsort_h_cft_1';
  
  //TYPE ALIASES
  typedef gsl_comparison_fn_t = gsl_heapsort_h_cft_1;
  
  //PROCEDURES
  proc gsl_heapsort: address * size * size * gsl_heapsort_h_cft_1;
  
  //FUNCTIONS
  fun gsl_heapsort_index: ptr[size] * caddress * size * size * gsl_heapsort_h_cft_1 -> int;
}
@h=tangler('lib/gsl/gsl_histogram2d_lib.flx')
@select(h)
//Module        : gsl_histogram2d_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_histogram2d.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_HISTOGRAM2D_H__
header '#include "gsl_histogram2d.h"';

//INCLUDES

module gsl_histogram2d_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_histogram2d_pdf = 'gsl_histogram2d_pdf';
  type gsl_histogram2d = 'gsl_histogram2d';
  
  //PROCEDURES
  proc gsl_histogram2d_free: ptr[gsl_histogram2d];
  proc gsl_histogram2d_max_bin: cptr[gsl_histogram2d] * ptr[size] * ptr[size];
  proc gsl_histogram2d_min_bin: cptr[gsl_histogram2d] * ptr[size] * ptr[size];
  proc gsl_histogram2d_pdf_free: ptr[gsl_histogram2d_pdf];
  proc gsl_histogram2d_reset: ptr[gsl_histogram2d];
  
  //FUNCTIONS
  fun gsl_histogram2d_accumulate: ptr[gsl_histogram2d] * double * double * double -> int;
  fun gsl_histogram2d_add: ptr[gsl_histogram2d] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_alloc: size * size -> ptr[gsl_histogram2d];
  fun gsl_histogram2d_calloc: size * size -> ptr[gsl_histogram2d];
  fun gsl_histogram2d_calloc_range: size * size * ptr[double] * ptr[double] -> ptr[gsl_histogram2d];
  fun gsl_histogram2d_calloc_uniform: size * size * double * double * double * double -> ptr[gsl_histogram2d];
  fun gsl_histogram2d_clone: cptr[gsl_histogram2d] -> ptr[gsl_histogram2d];
  fun gsl_histogram2d_cov: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_div: ptr[gsl_histogram2d] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_equal_bins_p: cptr[gsl_histogram2d] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_find: cptr[gsl_histogram2d] * double * double * ptr[size] * ptr[size] -> int;
  fun gsl_histogram2d_fprintf: ptr[FILE] * cptr[gsl_histogram2d] * cptr[char] * cptr[char] -> int;
  fun gsl_histogram2d_fread: ptr[FILE] * ptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_fscanf: ptr[FILE] * ptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_fwrite: ptr[FILE] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_get: cptr[gsl_histogram2d] * size * size -> double;
  fun gsl_histogram2d_get_xrange: cptr[gsl_histogram2d] * size * ptr[double] * ptr[double] -> int;
  fun gsl_histogram2d_get_yrange: cptr[gsl_histogram2d] * size * ptr[double] * ptr[double] -> int;
  fun gsl_histogram2d_increment: ptr[gsl_histogram2d] * double * double -> int;
  fun gsl_histogram2d_max_val: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_memcpy: ptr[gsl_histogram2d] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_min_val: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_mul: ptr[gsl_histogram2d] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_nx: cptr[gsl_histogram2d] -> size;
  fun gsl_histogram2d_ny: cptr[gsl_histogram2d] -> size;
  fun gsl_histogram2d_pdf_alloc: size * size -> ptr[gsl_histogram2d_pdf];
  fun gsl_histogram2d_pdf_init: ptr[gsl_histogram2d_pdf] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_pdf_sample: cptr[gsl_histogram2d_pdf] * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_histogram2d_scale: ptr[gsl_histogram2d] * double -> int;
  fun gsl_histogram2d_set_ranges: ptr[gsl_histogram2d] * cptr[double] * size * cptr[double] * size -> int;
  fun gsl_histogram2d_set_ranges_uniform: ptr[gsl_histogram2d] * double * double * double * double -> int;
  fun gsl_histogram2d_shift: ptr[gsl_histogram2d] * double -> int;
  fun gsl_histogram2d_sub: ptr[gsl_histogram2d] * cptr[gsl_histogram2d] -> int;
  fun gsl_histogram2d_sum: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_xmax: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_xmean: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_xmin: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_xsigma: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_ymax: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_ymean: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_ymin: cptr[gsl_histogram2d] -> double;
  fun gsl_histogram2d_ysigma: cptr[gsl_histogram2d] -> double;
}
@h=tangler('lib/gsl/gsl_histogram_lib.flx')
@select(h)
//Module        : gsl_histogram_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_histogram.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_HISTOGRAM_H__
header '#include "gsl_histogram.h"';

//INCLUDES

module gsl_histogram_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_histogram = 'gsl_histogram';
  type gsl_histogram_pdf = 'gsl_histogram_pdf';
  
  //PROCEDURES
  proc gsl_histogram_free: ptr[gsl_histogram];
  proc gsl_histogram_pdf_free: ptr[gsl_histogram_pdf];
  proc gsl_histogram_reset: ptr[gsl_histogram];
  
  //FUNCTIONS
  fun gsl_histogram_accumulate: ptr[gsl_histogram] * double * double -> int;
  fun gsl_histogram_add: ptr[gsl_histogram] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_alloc: size -> ptr[gsl_histogram];
  fun gsl_histogram_bins: cptr[gsl_histogram] -> size;
  fun gsl_histogram_calloc: size -> ptr[gsl_histogram];
  fun gsl_histogram_calloc_range: size * ptr[double] -> ptr[gsl_histogram];
  fun gsl_histogram_calloc_uniform: size * double * double -> ptr[gsl_histogram];
  fun gsl_histogram_clone: cptr[gsl_histogram] -> ptr[gsl_histogram];
  fun gsl_histogram_div: ptr[gsl_histogram] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_equal_bins_p: cptr[gsl_histogram] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_find: cptr[gsl_histogram] * double * ptr[size] -> int;
  fun gsl_histogram_fprintf: ptr[FILE] * cptr[gsl_histogram] * cptr[char] * cptr[char] -> int;
  fun gsl_histogram_fread: ptr[FILE] * ptr[gsl_histogram] -> int;
  fun gsl_histogram_fscanf: ptr[FILE] * ptr[gsl_histogram] -> int;
  fun gsl_histogram_fwrite: ptr[FILE] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_get: cptr[gsl_histogram] * size -> double;
  fun gsl_histogram_get_range: cptr[gsl_histogram] * size * ptr[double] * ptr[double] -> int;
  fun gsl_histogram_increment: ptr[gsl_histogram] * double -> int;
  fun gsl_histogram_max: cptr[gsl_histogram] -> double;
  fun gsl_histogram_max_bin: cptr[gsl_histogram] -> size;
  fun gsl_histogram_max_val: cptr[gsl_histogram] -> double;
  fun gsl_histogram_mean: cptr[gsl_histogram] -> double;
  fun gsl_histogram_memcpy: ptr[gsl_histogram] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_min: cptr[gsl_histogram] -> double;
  fun gsl_histogram_min_bin: cptr[gsl_histogram] -> size;
  fun gsl_histogram_min_val: cptr[gsl_histogram] -> double;
  fun gsl_histogram_mul: ptr[gsl_histogram] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_pdf_alloc: size -> ptr[gsl_histogram_pdf];
  fun gsl_histogram_pdf_init: ptr[gsl_histogram_pdf] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_pdf_sample: cptr[gsl_histogram_pdf] * double -> double;
  fun gsl_histogram_scale: ptr[gsl_histogram] * double -> int;
  fun gsl_histogram_set_ranges: ptr[gsl_histogram] * cptr[double] * size -> int;
  fun gsl_histogram_set_ranges_uniform: ptr[gsl_histogram] * double * double -> int;
  fun gsl_histogram_shift: ptr[gsl_histogram] * double -> int;
  fun gsl_histogram_sigma: cptr[gsl_histogram] -> double;
  fun gsl_histogram_sub: ptr[gsl_histogram] * cptr[gsl_histogram] -> int;
  fun gsl_histogram_sum: cptr[gsl_histogram] -> double;
}
@h=tangler('lib/gsl/gsl_ieee_utils_lib.flx')
@select(h)
//Module        : gsl_ieee_utils_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_ieee_utils.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_IEEE_UTILS_H__
header '#include "gsl_ieee_utils.h"';

//INCLUDES

module gsl_ieee_utils_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_ieee_float_rep = 'gsl_ieee_float_rep';
  type gsl_ieee_double_rep = 'gsl_ieee_double_rep';
  
  //ENUMERATION CONSTANTS
  const GSL_IEEE_ROUND_TO_NEAREST: int = 'GSL_IEEE_ROUND_TO_NEAREST';
  const GSL_IEEE_MASK_UNDERFLOW: int = 'GSL_IEEE_MASK_UNDERFLOW';
  const GSL_IEEE_MASK_DENORMALIZED: int = 'GSL_IEEE_MASK_DENORMALIZED';
  const GSL_IEEE_ROUND_TO_ZERO: int = 'GSL_IEEE_ROUND_TO_ZERO';
  const GSL_IEEE_SINGLE_PRECISION: int = 'GSL_IEEE_SINGLE_PRECISION';
  const GSL_IEEE_TYPE_DENORMAL: int = 'GSL_IEEE_TYPE_DENORMAL';
  const GSL_IEEE_ROUND_UP: int = 'GSL_IEEE_ROUND_UP';
  const GSL_IEEE_MASK_OVERFLOW: int = 'GSL_IEEE_MASK_OVERFLOW';
  const GSL_IEEE_MASK_DIVISION_BY_ZERO: int = 'GSL_IEEE_MASK_DIVISION_BY_ZERO';
  const GSL_IEEE_DOUBLE_PRECISION: int = 'GSL_IEEE_DOUBLE_PRECISION';
  const GSL_IEEE_MASK_ALL: int = 'GSL_IEEE_MASK_ALL';
  const GSL_IEEE_TRAP_INEXACT: int = 'GSL_IEEE_TRAP_INEXACT';
  const GSL_IEEE_EXTENDED_PRECISION: int = 'GSL_IEEE_EXTENDED_PRECISION';
  const GSL_IEEE_TYPE_INF: int = 'GSL_IEEE_TYPE_INF';
  const GSL_IEEE_TYPE_ZERO: int = 'GSL_IEEE_TYPE_ZERO';
  const GSL_IEEE_TYPE_NORMAL: int = 'GSL_IEEE_TYPE_NORMAL';
  const GSL_IEEE_TYPE_NAN: int = 'GSL_IEEE_TYPE_NAN';
  const GSL_IEEE_MASK_INVALID: int = 'GSL_IEEE_MASK_INVALID';
  const GSL_IEEE_ROUND_DOWN: int = 'GSL_IEEE_ROUND_DOWN';
  
  //PROCEDURES
  proc gsl_ieee_double_to_rep: cptr[double] * ptr[gsl_ieee_double_rep];
  proc gsl_ieee_env_setup: 1;
  proc gsl_ieee_float_to_rep: cptr[float] * ptr[gsl_ieee_float_rep];
  proc gsl_ieee_fprintf_double: ptr[FILE] * cptr[double];
  proc gsl_ieee_fprintf_float: ptr[FILE] * cptr[float];
  proc gsl_ieee_printf_double: cptr[double];
  proc gsl_ieee_printf_float: cptr[float];
  
  //FUNCTIONS
  fun gsl_ieee_read_mode_string: cptr[char] * ptr[int] * ptr[int] * ptr[int] -> int;
  fun gsl_ieee_set_mode: int * int * int -> int;
}
@h=tangler('lib/gsl/gsl_integration_lib.flx')
@select(h)
//Module        : gsl_integration_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_integration.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_INTEGRATION_H__
header '#include "gsl_integration.h"';

//INCLUDES
include "gsl_math_lib";

module gsl_integration_h
{
  open C_hack;
  open gsl_math_h;
  
  //ABSTRACT TYPES
  type gsl_integration_qaws_table = 'gsl_integration_qaws_table';
  type gsl_integration_workspace = 'gsl_integration_workspace';
  type gsl_integration_qawo_table = 'gsl_integration_qawo_table';
  
  //TYPE ALIASES
  typedef gsl_integration_rule = cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double] -> void_t;
  typedef gsl_integration_qawo_enum = int;
  
  //ENUMERATION CONSTANTS
  const GSL_INTEG_GAUSS15: int = 'GSL_INTEG_GAUSS15';
  const GSL_INTEG_COSINE: int = 'GSL_INTEG_COSINE';
  const GSL_INTEG_GAUSS21: int = 'GSL_INTEG_GAUSS21';
  const GSL_INTEG_GAUSS31: int = 'GSL_INTEG_GAUSS31';
  const GSL_INTEG_SINE: int = 'GSL_INTEG_SINE';
  const GSL_INTEG_GAUSS41: int = 'GSL_INTEG_GAUSS41';
  const GSL_INTEG_GAUSS51: int = 'GSL_INTEG_GAUSS51';
  const GSL_INTEG_GAUSS61: int = 'GSL_INTEG_GAUSS61';
  
  //PROCEDURES
  proc gsl_integration_qawo_table_free: ptr[gsl_integration_qawo_table];
  proc gsl_integration_qaws_table_free: ptr[gsl_integration_qaws_table];
  proc gsl_integration_qcheb: ptr[gsl_function] * double * double * ptr[double] * ptr[double];
  proc gsl_integration_qk: int * cptr[double] * cptr[double] * cptr[double] * ptr[double] * ptr[double] * cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_qk15: cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_qk21: cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_qk31: cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_qk41: cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_qk51: cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_qk61: cptr[gsl_function] * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_integration_workspace_free: ptr[gsl_integration_workspace];
  
  //FUNCTIONS
  fun gsl_integration_qag: cptr[gsl_function] * double * double * double * double * size * int * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qagi: ptr[gsl_function] * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qagil: ptr[gsl_function] * double * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qagiu: ptr[gsl_function] * double * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qagp: cptr[gsl_function] * ptr[double] * size * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qags: cptr[gsl_function] * double * double * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qawc: ptr[gsl_function] * double * double * double * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qawf: ptr[gsl_function] * double * double * size * ptr[gsl_integration_workspace] * ptr[gsl_integration_workspace] * ptr[gsl_integration_qawo_table] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qawo: ptr[gsl_function] * double * double * double * size * ptr[gsl_integration_workspace] * ptr[gsl_integration_qawo_table] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qawo_table_alloc: double * double * int * size -> ptr[gsl_integration_qawo_table];
  fun gsl_integration_qawo_table_set: ptr[gsl_integration_qawo_table] * double * double * int -> int;
  fun gsl_integration_qawo_table_set_length: ptr[gsl_integration_qawo_table] * double -> int;
  fun gsl_integration_qaws: ptr[gsl_function] * double * double * ptr[gsl_integration_qaws_table] * double * double * size * ptr[gsl_integration_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_integration_qaws_table_alloc: double * double * int * int -> ptr[gsl_integration_qaws_table];
  fun gsl_integration_qaws_table_set: ptr[gsl_integration_qaws_table] * double * double * int * int -> int;
  fun gsl_integration_qng: cptr[gsl_function] * double * double * double * double * ptr[double] * ptr[double] * ptr[size] -> int;
  fun gsl_integration_workspace_alloc: size -> ptr[gsl_integration_workspace];
}
@h=tangler('lib/gsl/gsl_interp_lib.flx')
@select(h)
//Module        : gsl_interp_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_interp.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_INTERP_H__
header '#include "gsl_interp.h"';

module gsl_interp_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_interp_accel = 'gsl_interp_accel';
  type gsl_interp_type = 'gsl_interp_type';
  type gsl_interp = 'gsl_interp';
  
  //VARIABLES
  const gsl_interp_linear: cptr[gsl_interp_type] = 'gsl_interp_linear';
  const gsl_interp_akima_periodic: cptr[gsl_interp_type] = 'gsl_interp_akima_periodic';
  const gsl_interp_polynomial: cptr[gsl_interp_type] = 'gsl_interp_polynomial';
  const gsl_interp_akima: cptr[gsl_interp_type] = 'gsl_interp_akima';
  const gsl_interp_cspline_periodic: cptr[gsl_interp_type] = 'gsl_interp_cspline_periodic';
  const gsl_interp_cspline: cptr[gsl_interp_type] = 'gsl_interp_cspline';
  
  //PROCEDURES
  proc gsl_interp_accel_free: ptr[gsl_interp_accel];
  proc gsl_interp_free: ptr[gsl_interp];
  
  //FUNCTIONS
  fun gsl_interp_accel_alloc: 1 -> ptr[gsl_interp_accel];
  fun gsl_interp_accel_find: ptr[gsl_interp_accel] * cptr[double] * size * double -> size;
  fun gsl_interp_accel_reset: ptr[gsl_interp_accel] -> int;
  fun gsl_interp_alloc: cptr[gsl_interp_type] * size -> ptr[gsl_interp];
  fun gsl_interp_bsearch: cptr[double] * double * size * size -> size;
  fun gsl_interp_eval: cptr[gsl_interp] * cptr[double] * cptr[double] * double * ptr[gsl_interp_accel] -> double;
  fun gsl_interp_eval_deriv: cptr[gsl_interp] * cptr[double] * cptr[double] * double * ptr[gsl_interp_accel] -> double;
  fun gsl_interp_eval_deriv2: cptr[gsl_interp] * cptr[double] * cptr[double] * double * ptr[gsl_interp_accel] -> double;
  fun gsl_interp_eval_deriv2_e: cptr[gsl_interp] * cptr[double] * cptr[double] * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_interp_eval_deriv_e: cptr[gsl_interp] * cptr[double] * cptr[double] * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_interp_eval_e: cptr[gsl_interp] * cptr[double] * cptr[double] * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_interp_eval_integ: cptr[gsl_interp] * cptr[double] * cptr[double] * double * double * ptr[gsl_interp_accel] -> double;
  fun gsl_interp_eval_integ_e: cptr[gsl_interp] * cptr[double] * cptr[double] * double * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_interp_init: ptr[gsl_interp] * cptr[double] * cptr[double] * size -> int;
  fun gsl_interp_min_size: cptr[gsl_interp] -> uint;
  fun gsl_interp_name: cptr[gsl_interp] -> cptr[char];
}
@h=tangler('lib/gsl/gsl_linalg_lib.flx')
@select(h)
//Module        : gsl_linalg_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_linalg.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_LINALG_H__
header '#include "gsl_linalg.h"';

//INCLUDES
include "gsl_complex_lib";
include "gsl_matrix_complex_double_lib";
include "gsl_matrix_double_lib";
include "gsl_mode_lib";
include "gsl_permutation_lib";
include "gsl_vector_complex_double_lib";
include "gsl_vector_double_lib";

module gsl_linalg_h
{
  open C_hack;
  open gsl_complex_h;
  open gsl_matrix_complex_double_h;
  open gsl_matrix_double_h;
  open gsl_mode_h;
  open gsl_permutation_h;
  open gsl_vector_complex_double_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type gsl_linalg_matrix_mod_t = 'gsl_linalg_matrix_mod_t';
  
  //ENUMERATION CONSTANTS
  const GSL_LINALG_MOD_CONJUGATE: int = 'GSL_LINALG_MOD_CONJUGATE';
  const GSL_LINALG_MOD_TRANSPOSE: int = 'GSL_LINALG_MOD_TRANSPOSE';
  const GSL_LINALG_MOD_NONE: int = 'GSL_LINALG_MOD_NONE';
  
  //FUNCTIONS
  fun gsl_linalg_HH_solve: ptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_HH_svx: ptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_LQsolve: ptr[gsl_matrix] * ptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_Lsolve_T: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_Lsvx_T: cptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_decomp: ptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_lssolve_T: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_solve_T: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_svx_T: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_unpack: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_matrix] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_LQ_update: ptr[gsl_matrix] * ptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_vecQ: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LQ_vecQT: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LU_decomp: ptr[gsl_matrix] * ptr[gsl_permutation] * ptr[int] -> int;
  fun gsl_linalg_LU_det: ptr[gsl_matrix] * int -> double;
  fun gsl_linalg_LU_invert: cptr[gsl_matrix] * cptr[gsl_permutation] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_LU_lndet: ptr[gsl_matrix] -> double;
  fun gsl_linalg_LU_refine: cptr[gsl_matrix] * cptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LU_sgndet: ptr[gsl_matrix] * int -> int;
  fun gsl_linalg_LU_solve: cptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_LU_svx: cptr[gsl_matrix] * cptr[gsl_permutation] * ptr[gsl_vector] -> int;
  fun gsl_linalg_L_solve_T: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_LQsolve_T: cptr[gsl_matrix] * cptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_Lsolve_T: cptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_Lsvx_T: cptr[gsl_matrix] * cptr[gsl_permutation] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_decomp: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_permutation] * ptr[int] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_decomp2: cptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_permutation] * ptr[int] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_solve_T: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_svx_T: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_permutation] * ptr[gsl_vector] -> int;
  fun gsl_linalg_PTLQ_update: ptr[gsl_matrix] * ptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_QRsolve: cptr[gsl_matrix] * cptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_Rsolve: cptr[gsl_matrix] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_Rsvx: cptr[gsl_matrix] * cptr[gsl_permutation] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_decomp: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_permutation] * ptr[int] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_decomp2: cptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_permutation] * ptr[int] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_solve: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_permutation] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_svx: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_permutation] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QRPT_update: ptr[gsl_matrix] * ptr[gsl_matrix] * cptr[gsl_permutation] * ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_linalg_QR_QRsolve: ptr[gsl_matrix] * ptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_QTvec: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_Qvec: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_Rsolve: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_Rsvx: cptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_decomp: ptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_lssolve: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_solve: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_svx: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_QR_unpack: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_matrix] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_QR_update: ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_linalg_R_solve: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_R_svx: cptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_SV_decomp: ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_SV_decomp_jacobi: ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_SV_decomp_mod: ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_SV_solve: cptr[gsl_matrix] * cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_balance_columns: ptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_bidiag_decomp: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_bidiag_unpack: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_bidiag_unpack2: ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_bidiag_unpack_B: cptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_cholesky_decomp: ptr[gsl_matrix] -> int;
  fun gsl_linalg_cholesky_solve: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_cholesky_svx: cptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_complex_LU_decomp: ptr[gsl_matrix_complex] * ptr[gsl_permutation] * ptr[int] -> int;
  fun gsl_linalg_complex_LU_det: ptr[gsl_matrix_complex] * int -> gsl_complex;
  fun gsl_linalg_complex_LU_invert: cptr[gsl_matrix_complex] * cptr[gsl_permutation] * ptr[gsl_matrix_complex] -> int;
  fun gsl_linalg_complex_LU_lndet: ptr[gsl_matrix_complex] -> double;
  fun gsl_linalg_complex_LU_refine: cptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] * cptr[gsl_permutation] * cptr[gsl_vector_complex] * ptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_linalg_complex_LU_sgndet: ptr[gsl_matrix_complex] * int -> gsl_complex;
  fun gsl_linalg_complex_LU_solve: cptr[gsl_matrix_complex] * cptr[gsl_permutation] * cptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_linalg_complex_LU_svx: cptr[gsl_matrix_complex] * cptr[gsl_permutation] * ptr[gsl_vector_complex] -> int;
  fun gsl_linalg_complex_householder_hm: gsl_complex * cptr[gsl_vector_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_linalg_complex_householder_hv: gsl_complex * cptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_linalg_complex_householder_transform: ptr[gsl_vector_complex] -> gsl_complex;
  fun gsl_linalg_exponential_ss: cptr[gsl_matrix] * ptr[gsl_matrix] * gsl_mode_t -> int;
  fun gsl_linalg_hermtd_decomp: ptr[gsl_matrix_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_linalg_hermtd_unpack: cptr[gsl_matrix_complex] * cptr[gsl_vector_complex] * ptr[gsl_matrix_complex] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_hermtd_unpack_T: cptr[gsl_matrix_complex] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_householder_hm: double * cptr[gsl_vector] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_householder_hm1: double * ptr[gsl_matrix] -> int;
  fun gsl_linalg_householder_hv: double * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_householder_mh: double * cptr[gsl_vector] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_householder_transform: ptr[gsl_vector] -> double;
  fun gsl_linalg_matmult: cptr[gsl_matrix] * cptr[gsl_matrix] * ptr[gsl_matrix] -> int;
  fun gsl_linalg_matmult_mod: cptr[gsl_matrix] * gsl_linalg_matrix_mod_t * cptr[gsl_matrix] * gsl_linalg_matrix_mod_t * ptr[gsl_matrix] -> int;
  fun gsl_linalg_solve_cyc_tridiag: cptr[gsl_vector] * cptr[gsl_vector] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_solve_symm_cyc_tridiag: cptr[gsl_vector] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_solve_symm_tridiag: cptr[gsl_vector] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_solve_tridiag: cptr[gsl_vector] * cptr[gsl_vector] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_symmtd_decomp: ptr[gsl_matrix] * ptr[gsl_vector] -> int;
  fun gsl_linalg_symmtd_unpack: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_linalg_symmtd_unpack_T: cptr[gsl_matrix] * ptr[gsl_vector] * ptr[gsl_vector] -> int;
}
@h=tangler('lib/gsl/gsl_machine_lib.flx')
@select(h)
//Module        : gsl_machine_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_machine.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_LOG_MACH_EPS       (-34.54)
//#define GSL_ROOT6_MACH_EPS      0.00316
//#define GSL_ROOT5_MACH_EPS      0.00100
//#define GSL_ROOT4_MACH_EPS      0.000178
//#define GSL_ROOT3_MACH_EPS      1.0e-05
//#define GSL_SQRT_MACH_EPS       3.2e-08
//#define GSL_MACH_EPS  GSL_DBL_EPSILON
//#define GSL_LOG_SFLT_EPSILON   (-7.6246189861593985e+00)
//#define GSL_ROOT6_SFLT_EPSILON  2.8061551207734325e-01
//#define GSL_ROOT5_SFLT_EPSILON  2.1763764082403100e-01
//#define GSL_ROOT4_SFLT_EPSILON  1.4865088937534013e-01
//#define GSL_ROOT3_SFLT_EPSILON  7.8745065618429588e-02
//#define GSL_SQRT_SFLT_EPSILON   2.2097086912079612e-02
//#define GSL_SFLT_EPSILON        4.8828125000000000e-04
//#define GSL_LOG_FLT_MAX    8.8722839052068352e+01
//#define GSL_ROOT6_FLT_MAX  2.6422459233807749e+06
//#define GSL_ROOT5_FLT_MAX  5.0859007855960041e+07
//#define GSL_ROOT4_FLT_MAX  4.2949672319999986e+09
//#define GSL_ROOT3_FLT_MAX  6.9814635196223242e+12
//#define GSL_SQRT_FLT_MAX   1.8446743523953730e+19
//#define GSL_FLT_MAX        3.4028234663852886e+38
//#define GSL_LOG_FLT_MIN   (-8.7336544750553102e+01)
//#define GSL_ROOT6_FLT_MIN  4.7683715820312542e-07
//#define GSL_ROOT5_FLT_MIN  2.5944428542140822e-08
//#define GSL_ROOT4_FLT_MIN  3.2927225399135965e-10
//#define GSL_ROOT3_FLT_MIN  2.2737367544323241e-13
//#define GSL_SQRT_FLT_MIN   1.0842021724855044e-19
//#define GSL_FLT_MIN        1.1754943508222875e-38
//#define GSL_LOG_FLT_EPSILON   (-1.5942385152878742e+01)
//#define GSL_ROOT6_FLT_EPSILON  7.0153878019335827e-02
//#define GSL_ROOT5_FLT_EPSILON  4.1234622211652937e-02
//#define GSL_ROOT4_FLT_EPSILON  1.8581361171917516e-02
//#define GSL_ROOT3_FLT_EPSILON  4.9215666011518501e-03
//#define GSL_SQRT_FLT_EPSILON   3.4526698300124393e-04
//#define GSL_FLT_EPSILON        1.1920928955078125e-07
//#define GSL_LOG_DBL_MAX    7.0978271289338397e+02
//#define GSL_ROOT6_DBL_MAX  2.3756689782295612e+51
//#define GSL_ROOT5_DBL_MAX  4.4765466227572707e+61
//#define GSL_ROOT4_DBL_MAX  1.1579208923731620e+77
//#define GSL_ROOT3_DBL_MAX  5.6438030941222897e+102
//#define GSL_SQRT_DBL_MAX   1.3407807929942596e+154
//#define GSL_DBL_MAX        1.7976931348623157e+308
//#define GSL_LOG_DBL_MIN   (-7.0839641853226408e+02)
//#define GSL_ROOT6_DBL_MIN  5.3034368905798218e-52
//#define GSL_ROOT5_DBL_MIN  2.9476022969691763e-62
//#define GSL_ROOT4_DBL_MIN  1.2213386697554620e-77
//#define GSL_ROOT3_DBL_MIN  2.8126442852362996e-103
//#define GSL_SQRT_DBL_MIN   1.4916681462400413e-154
//#define GSL_DBL_MIN        2.2250738585072014e-308
//#define GSL_LOG_DBL_EPSILON   (-3.6043653389117154e+01)
//#define GSL_ROOT6_DBL_EPSILON  2.4607833005759251e-03
//#define GSL_ROOT5_DBL_EPSILON  7.4009597974140505e-04
//#define GSL_ROOT4_DBL_EPSILON  1.2207031250000000e-04
//#define GSL_ROOT3_DBL_EPSILON  6.0554544523933429e-06
//#define GSL_SQRT_DBL_EPSILON   1.4901161193847656e-08
//#define GSL_DBL_EPSILON        2.2204460492503131e-16
//#define __GSL_MACHINE_H__
header '#include "gsl_machine.h"';

module gsl_machine_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_math_lib.flx')
@select(h)
//Module        : gsl_math_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_math.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_FN_VEC_EVAL(F,x,y) (*((F)->function))(x,y,(F)->params)
//#define GSL_FN_FDF_EVAL_F_DF(FDF,x,y,dy) (*((FDF)->fdf))(x,(FDF)->params,(y),(dy))
//#define GSL_FN_FDF_EVAL_DF(FDF,x) (*((FDF)->df))(x,(FDF)->params)
//#define GSL_FN_FDF_EVAL_F(FDF,x) (*((FDF)->f))(x,(FDF)->params)
//#define GSL_FN_EVAL(F,x) (*((F)->function))(x,(F)->params)
//#define GSL_MIN_LDBL(a,b)  GSL_MIN(a,b)
//#define GSL_MAX_LDBL(a,b)  GSL_MAX(a,b)
//#define GSL_MIN_DBL(a,b)   GSL_MIN(a,b)
//#define GSL_MAX_DBL(a,b)   GSL_MAX(a,b)
//#define GSL_MIN_INT(a,b)   GSL_MIN(a,b)
//#define GSL_MAX_INT(a,b)   GSL_MAX(a,b)
//#define GSL_MIN(a,b) ((a) < (b) ? (a) : (b))
//#define GSL_MAX(a,b) ((a) > (b) ? (a) : (b))
//#define GSL_IS_REAL(x) (gsl_finite(x))
//#define GSL_SIGN(x)    ((x) >= 0.0 ? 1 : -1)
//#define GSL_IS_EVEN(n) (!(GSL_IS_ODD(n)))
//#define GSL_IS_ODD(n)  ((n) & 1)
//#define M_EULER    0.57721566490153286060651209008      /* Euler constant */
//#define M_LNPI     1.14472988584940017414342735135      /* ln(pi) */
//#define M_LN2      0.69314718055994530941723212146      /* ln(2) */
//#define M_LN10     2.30258509299404568401799145468      /* ln(10) */
//#define M_2_PI     0.63661977236758134307553505349      /* 2/pi */
//#define M_1_PI     0.31830988618379067153776752675      /* 1/pi */
//#define M_2_SQRTPI 1.12837916709551257389615890312      /* 2/sqrt(pi) */
//#define M_SQRTPI   1.77245385090551602729816748334      /* sqrt(pi) */
//#define M_PI_4     0.78539816339744830966156608458      /* pi/4 */
//#define M_PI_2     1.57079632679489661923132169164      /* pi/2 */
//#define M_PI       3.14159265358979323846264338328      /* pi */
//#define M_SQRT3    1.73205080756887729352744634151      /* sqrt(3) */
//#define M_SQRT1_2  0.70710678118654752440084436210      /* sqrt(1/2) */
//#define M_SQRT2    1.41421356237309504880168872421      /* sqrt(2) */
//#define M_LOG10E   0.43429448190325182765112891892      /* log_10 (e) */
//#define M_LOG2E    1.44269504088896340735992468100      /* log_2 (e) */
//#define M_E        2.71828182845904523536028747135      /* e */
//#define __GSL_MATH_H__
header '#include "gsl_math.h"';

//INCLUDES
include "gsl_function_fdf_struct_lib";
include "gsl_function_struct_lib";
include "gsl_function_vec_struct_lib";

module gsl_math_h
{
  open C_hack;
  open gsl_function_fdf_struct_h;
  open gsl_function_struct_h;
  open gsl_function_vec_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_function_struct {
    function: gsl_math_h_cft_1;
    params: address;
  }
  cstruct gsl_function_vec_struct {
    function: gsl_math_h_cft_3;
    params: address;
  }
  cstruct gsl_function_fdf_struct {
    f: gsl_math_h_cft_1;
    df: gsl_math_h_cft_1;
    fdf: gsl_math_h_cft_2;
    params: address;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*gsl_math_h_cft_2)(double, void *, double *,  double *);''';
  type gsl_math_h_cft_2 = 'gsl_math_h_cft_2';
  header '''typedef int (*gsl_math_h_cft_3)(double, double *, void *);''';
  type gsl_math_h_cft_3 = 'gsl_math_h_cft_3';
  header '''typedef double (*gsl_math_h_cft_1)(double, void *);''';
  type gsl_math_h_cft_1 = 'gsl_math_h_cft_1';
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_function = gsl_function_struct;
  typedef gsl_function_vec = gsl_function_vec_struct;
  typedef gsl_function_fdf = gsl_function_fdf_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_function_vec_struct = gsl_function_vec_struct;
  typedef _struct_gsl_function_struct = gsl_function_struct;
  typedef _struct_gsl_function_fdf_struct = gsl_function_fdf_struct;
  
  //FUNCTIONS
  fun gsl_max: double * double -> double;
  fun gsl_min: double * double -> double;
}
@h=tangler('lib/gsl/gsl_matrix_char_lib.flx')
@select(h)
//Module        : gsl_matrix_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_CHAR_H__
header '#include "gsl_matrix_char.h"';

//INCLUDES
include "gsl_block_char_lib";
include "gsl_vector_char_lib";

module gsl_matrix_char_h
{
  open C_hack;
  open gsl_block_char_h;
  open gsl_vector_char_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_char = 'gsl_matrix_char';
  type _gsl_matrix_char_const_view = '_gsl_matrix_char_const_view';
  type _gsl_matrix_char_view = '_gsl_matrix_char_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_char_view = _gsl_matrix_char_view;
  typedef gsl_matrix_char_const_view = _gsl_matrix_char_const_view;
  
  //PROCEDURES
  proc gsl_matrix_char_free: ptr[gsl_matrix_char];
  proc gsl_matrix_char_max_index: cptr[gsl_matrix_char] * ptr[size] * ptr[size];
  proc gsl_matrix_char_min_index: cptr[gsl_matrix_char] * ptr[size] * ptr[size];
  proc gsl_matrix_char_minmax: cptr[gsl_matrix_char] * ptr[char] * ptr[char];
  proc gsl_matrix_char_minmax_index: cptr[gsl_matrix_char] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_char_set: ptr[gsl_matrix_char] * size * size * char;
  proc gsl_matrix_char_set_all: ptr[gsl_matrix_char] * char;
  proc gsl_matrix_char_set_identity: ptr[gsl_matrix_char];
  proc gsl_matrix_char_set_zero: ptr[gsl_matrix_char];
  
  //FUNCTIONS
  fun gsl_matrix_char_add: ptr[gsl_matrix_char] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_add_constant: ptr[gsl_matrix_char] * double -> int;
  fun gsl_matrix_char_add_diagonal: ptr[gsl_matrix_char] * double -> int;
  fun gsl_matrix_char_alloc: size * size -> ptr[gsl_matrix_char];
  fun gsl_matrix_char_alloc_from_block: ptr[gsl_block_char] * size * size * size * size -> ptr[gsl_matrix_char];
  fun gsl_matrix_char_alloc_from_matrix: ptr[gsl_matrix_char] * size * size * size * size -> ptr[gsl_matrix_char];
  fun gsl_matrix_char_calloc: size * size -> ptr[gsl_matrix_char];
  fun gsl_matrix_char_column: ptr[gsl_matrix_char] * size -> _gsl_vector_char_view;
  fun gsl_matrix_char_const_column: cptr[gsl_matrix_char] * size -> _gsl_vector_char_const_view;
  fun gsl_matrix_char_const_diagonal: cptr[gsl_matrix_char] -> _gsl_vector_char_const_view;
  fun gsl_matrix_char_const_ptr: cptr[gsl_matrix_char] * size * size -> cptr[char];
  fun gsl_matrix_char_const_row: cptr[gsl_matrix_char] * size -> _gsl_vector_char_const_view;
  fun gsl_matrix_char_const_subdiagonal: cptr[gsl_matrix_char] * size -> _gsl_vector_char_const_view;
  fun gsl_matrix_char_const_submatrix: cptr[gsl_matrix_char] * size * size * size * size -> _gsl_matrix_char_const_view;
  fun gsl_matrix_char_const_superdiagonal: cptr[gsl_matrix_char] * size -> _gsl_vector_char_const_view;
  fun gsl_matrix_char_const_view_array: cptr[char] * size * size -> _gsl_matrix_char_const_view;
  fun gsl_matrix_char_const_view_array_with_tda: cptr[char] * size * size * size -> _gsl_matrix_char_const_view;
  fun gsl_matrix_char_const_view_vector: cptr[gsl_vector_char] * size * size -> _gsl_matrix_char_const_view;
  fun gsl_matrix_char_const_view_vector_with_tda: cptr[gsl_vector_char] * size * size * size -> _gsl_matrix_char_const_view;
  fun gsl_matrix_char_diagonal: ptr[gsl_matrix_char] -> _gsl_vector_char_view;
  fun gsl_matrix_char_div_elements: ptr[gsl_matrix_char] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_fprintf: ptr[FILE] * cptr[gsl_matrix_char] * cptr[char] -> int;
  fun gsl_matrix_char_fread: ptr[FILE] * ptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_fscanf: ptr[FILE] * ptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_fwrite: ptr[FILE] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_get: cptr[gsl_matrix_char] * size * size -> char;
  fun gsl_matrix_char_get_col: ptr[gsl_vector_char] * cptr[gsl_matrix_char] * size -> int;
  fun gsl_matrix_char_get_row: ptr[gsl_vector_char] * cptr[gsl_matrix_char] * size -> int;
  fun gsl_matrix_char_isnull: cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_max: cptr[gsl_matrix_char] -> char;
  fun gsl_matrix_char_memcpy: ptr[gsl_matrix_char] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_min: cptr[gsl_matrix_char] -> char;
  fun gsl_matrix_char_mul_elements: ptr[gsl_matrix_char] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_ptr: ptr[gsl_matrix_char] * size * size -> ptr[char];
  fun gsl_matrix_char_row: ptr[gsl_matrix_char] * size -> _gsl_vector_char_view;
  fun gsl_matrix_char_scale: ptr[gsl_matrix_char] * double -> int;
  fun gsl_matrix_char_set_col: ptr[gsl_matrix_char] * size * cptr[gsl_vector_char] -> int;
  fun gsl_matrix_char_set_row: ptr[gsl_matrix_char] * size * cptr[gsl_vector_char] -> int;
  fun gsl_matrix_char_sub: ptr[gsl_matrix_char] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_subdiagonal: ptr[gsl_matrix_char] * size -> _gsl_vector_char_view;
  fun gsl_matrix_char_submatrix: ptr[gsl_matrix_char] * size * size * size * size -> _gsl_matrix_char_view;
  fun gsl_matrix_char_superdiagonal: ptr[gsl_matrix_char] * size -> _gsl_vector_char_view;
  fun gsl_matrix_char_swap: ptr[gsl_matrix_char] * ptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_swap_columns: ptr[gsl_matrix_char] * size * size -> int;
  fun gsl_matrix_char_swap_rowcol: ptr[gsl_matrix_char] * size * size -> int;
  fun gsl_matrix_char_swap_rows: ptr[gsl_matrix_char] * size * size -> int;
  fun gsl_matrix_char_transpose: ptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_transpose_memcpy: ptr[gsl_matrix_char] * cptr[gsl_matrix_char] -> int;
  fun gsl_matrix_char_view_array: ptr[char] * size * size -> _gsl_matrix_char_view;
  fun gsl_matrix_char_view_array_with_tda: ptr[char] * size * size * size -> _gsl_matrix_char_view;
  fun gsl_matrix_char_view_vector: ptr[gsl_vector_char] * size * size -> _gsl_matrix_char_view;
  fun gsl_matrix_char_view_vector_with_tda: ptr[gsl_vector_char] * size * size * size -> _gsl_matrix_char_view;
  fun gsl_vector_char_alloc_col_from_matrix: ptr[gsl_matrix_char] * size -> ptr[gsl_vector_char];
  fun gsl_vector_char_alloc_row_from_matrix: ptr[gsl_matrix_char] * size -> ptr[gsl_vector_char];
}
@h=tangler('lib/gsl/gsl_matrix_complex_double_lib.flx')
@select(h)
//Module        : gsl_matrix_complex_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_complex_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_COMPLEX_DOUBLE_H__
header '#include "gsl_matrix_complex_double.h"';

//INCLUDES
include "gsl_block_complex_double_lib";
include "gsl_complex_lib";
include "gsl_vector_complex_double_lib";

module gsl_matrix_complex_double_h
{
  open C_hack;
  open gsl_block_complex_double_h;
  open gsl_complex_h;
  open gsl_vector_complex_double_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_complex = 'gsl_matrix_complex';
  type _gsl_matrix_complex_const_view = '_gsl_matrix_complex_const_view';
  type _gsl_matrix_complex_view = '_gsl_matrix_complex_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_complex_view = _gsl_matrix_complex_view;
  typedef gsl_matrix_complex_const_view = _gsl_matrix_complex_const_view;
  
  //PROCEDURES
  proc gsl_matrix_complex_free: ptr[gsl_matrix_complex];
  proc gsl_matrix_complex_set: ptr[gsl_matrix_complex] * size * size * gsl_complex;
  proc gsl_matrix_complex_set_all: ptr[gsl_matrix_complex] * gsl_complex;
  proc gsl_matrix_complex_set_identity: ptr[gsl_matrix_complex];
  proc gsl_matrix_complex_set_zero: ptr[gsl_matrix_complex];
  
  //FUNCTIONS
  fun gsl_matrix_complex_add: ptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_add_constant: ptr[gsl_matrix_complex] * gsl_complex -> int;
  fun gsl_matrix_complex_add_diagonal: ptr[gsl_matrix_complex] * gsl_complex -> int;
  fun gsl_matrix_complex_alloc: size * size -> ptr[gsl_matrix_complex];
  fun gsl_matrix_complex_alloc_from_block: ptr[gsl_block_complex] * size * size * size * size -> ptr[gsl_matrix_complex];
  fun gsl_matrix_complex_alloc_from_matrix: ptr[gsl_matrix_complex] * size * size * size * size -> ptr[gsl_matrix_complex];
  fun gsl_matrix_complex_calloc: size * size -> ptr[gsl_matrix_complex];
  fun gsl_matrix_complex_column: ptr[gsl_matrix_complex] * size -> _gsl_vector_complex_view;
  fun gsl_matrix_complex_const_column: cptr[gsl_matrix_complex] * size -> _gsl_vector_complex_const_view;
  fun gsl_matrix_complex_const_diagonal: cptr[gsl_matrix_complex] -> _gsl_vector_complex_const_view;
  fun gsl_matrix_complex_const_ptr: cptr[gsl_matrix_complex] * size * size -> cptr[gsl_complex];
  fun gsl_matrix_complex_const_row: cptr[gsl_matrix_complex] * size -> _gsl_vector_complex_const_view;
  fun gsl_matrix_complex_const_subdiagonal: cptr[gsl_matrix_complex] * size -> _gsl_vector_complex_const_view;
  fun gsl_matrix_complex_const_submatrix: cptr[gsl_matrix_complex] * size * size * size * size -> _gsl_matrix_complex_const_view;
  fun gsl_matrix_complex_const_superdiagonal: cptr[gsl_matrix_complex] * size -> _gsl_vector_complex_const_view;
  fun gsl_matrix_complex_const_view_array: cptr[double] * size * size -> _gsl_matrix_complex_const_view;
  fun gsl_matrix_complex_const_view_array_with_tda: cptr[double] * size * size * size -> _gsl_matrix_complex_const_view;
  fun gsl_matrix_complex_const_view_vector: cptr[gsl_vector_complex] * size * size -> _gsl_matrix_complex_const_view;
  fun gsl_matrix_complex_const_view_vector_with_tda: cptr[gsl_vector_complex] * size * size * size -> _gsl_matrix_complex_const_view;
  fun gsl_matrix_complex_diagonal: ptr[gsl_matrix_complex] -> _gsl_vector_complex_view;
  fun gsl_matrix_complex_div_elements: ptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_fprintf: ptr[FILE] * cptr[gsl_matrix_complex] * cptr[char] -> int;
  fun gsl_matrix_complex_fread: ptr[FILE] * ptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_fscanf: ptr[FILE] * ptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_fwrite: ptr[FILE] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_get: cptr[gsl_matrix_complex] * size * size -> gsl_complex;
  fun gsl_matrix_complex_get_col: ptr[gsl_vector_complex] * cptr[gsl_matrix_complex] * size -> int;
  fun gsl_matrix_complex_get_row: ptr[gsl_vector_complex] * cptr[gsl_matrix_complex] * size -> int;
  fun gsl_matrix_complex_isnull: cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_memcpy: ptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_mul_elements: ptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_ptr: ptr[gsl_matrix_complex] * size * size -> ptr[gsl_complex];
  fun gsl_matrix_complex_row: ptr[gsl_matrix_complex] * size -> _gsl_vector_complex_view;
  fun gsl_matrix_complex_scale: ptr[gsl_matrix_complex] * gsl_complex -> int;
  fun gsl_matrix_complex_set_col: ptr[gsl_matrix_complex] * size * cptr[gsl_vector_complex] -> int;
  fun gsl_matrix_complex_set_row: ptr[gsl_matrix_complex] * size * cptr[gsl_vector_complex] -> int;
  fun gsl_matrix_complex_sub: ptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_subdiagonal: ptr[gsl_matrix_complex] * size -> _gsl_vector_complex_view;
  fun gsl_matrix_complex_submatrix: ptr[gsl_matrix_complex] * size * size * size * size -> _gsl_matrix_complex_view;
  fun gsl_matrix_complex_superdiagonal: ptr[gsl_matrix_complex] * size -> _gsl_vector_complex_view;
  fun gsl_matrix_complex_swap: ptr[gsl_matrix_complex] * ptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_swap_columns: ptr[gsl_matrix_complex] * size * size -> int;
  fun gsl_matrix_complex_swap_rowcol: ptr[gsl_matrix_complex] * size * size -> int;
  fun gsl_matrix_complex_swap_rows: ptr[gsl_matrix_complex] * size * size -> int;
  fun gsl_matrix_complex_transpose: ptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_transpose_memcpy: ptr[gsl_matrix_complex] * cptr[gsl_matrix_complex] -> int;
  fun gsl_matrix_complex_view_array: ptr[double] * size * size -> _gsl_matrix_complex_view;
  fun gsl_matrix_complex_view_array_with_tda: ptr[double] * size * size * size -> _gsl_matrix_complex_view;
  fun gsl_matrix_complex_view_vector: ptr[gsl_vector_complex] * size * size -> _gsl_matrix_complex_view;
  fun gsl_matrix_complex_view_vector_with_tda: ptr[gsl_vector_complex] * size * size * size -> _gsl_matrix_complex_view;
  fun gsl_vector_complex_alloc_col_from_matrix: ptr[gsl_matrix_complex] * size -> ptr[gsl_vector_complex];
  fun gsl_vector_complex_alloc_row_from_matrix: ptr[gsl_matrix_complex] * size -> ptr[gsl_vector_complex];
}
@h=tangler('lib/gsl/gsl_matrix_complex_float_lib.flx')
@select(h)
//Module        : gsl_matrix_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_COMPLEX_FLOAT_H__
header '#include "gsl_matrix_complex_float.h"';

//INCLUDES
include "gsl_block_complex_float_lib";
include "gsl_complex_lib";
include "gsl_vector_complex_float_lib";

module gsl_matrix_complex_float_h
{
  open C_hack;
  open gsl_block_complex_float_h;
  open gsl_complex_h;
  open gsl_vector_complex_float_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_complex_float = 'gsl_matrix_complex_float';
  type _gsl_matrix_complex_float_const_view = '_gsl_matrix_complex_float_const_view';
  type _gsl_matrix_complex_float_view = '_gsl_matrix_complex_float_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_complex_float_view = _gsl_matrix_complex_float_view;
  typedef gsl_matrix_complex_float_const_view = _gsl_matrix_complex_float_const_view;
  
  //PROCEDURES
  proc gsl_matrix_complex_float_free: ptr[gsl_matrix_complex_float];
  proc gsl_matrix_complex_float_set: ptr[gsl_matrix_complex_float] * size * size * gsl_complex_float;
  proc gsl_matrix_complex_float_set_all: ptr[gsl_matrix_complex_float] * gsl_complex_float;
  proc gsl_matrix_complex_float_set_identity: ptr[gsl_matrix_complex_float];
  proc gsl_matrix_complex_float_set_zero: ptr[gsl_matrix_complex_float];
  
  //FUNCTIONS
  fun gsl_matrix_complex_float_add: ptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_add_constant: ptr[gsl_matrix_complex_float] * gsl_complex_float -> int;
  fun gsl_matrix_complex_float_add_diagonal: ptr[gsl_matrix_complex_float] * gsl_complex_float -> int;
  fun gsl_matrix_complex_float_alloc: size * size -> ptr[gsl_matrix_complex_float];
  fun gsl_matrix_complex_float_alloc_from_block: ptr[gsl_block_complex_float] * size * size * size * size -> ptr[gsl_matrix_complex_float];
  fun gsl_matrix_complex_float_alloc_from_matrix: ptr[gsl_matrix_complex_float] * size * size * size * size -> ptr[gsl_matrix_complex_float];
  fun gsl_matrix_complex_float_calloc: size * size -> ptr[gsl_matrix_complex_float];
  fun gsl_matrix_complex_float_column: ptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_view;
  fun gsl_matrix_complex_float_const_column: cptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_const_view;
  fun gsl_matrix_complex_float_const_diagonal: cptr[gsl_matrix_complex_float] -> _gsl_vector_complex_float_const_view;
  fun gsl_matrix_complex_float_const_ptr: cptr[gsl_matrix_complex_float] * size * size -> cptr[gsl_complex_float];
  fun gsl_matrix_complex_float_const_row: cptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_const_view;
  fun gsl_matrix_complex_float_const_subdiagonal: cptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_const_view;
  fun gsl_matrix_complex_float_const_submatrix: cptr[gsl_matrix_complex_float] * size * size * size * size -> _gsl_matrix_complex_float_const_view;
  fun gsl_matrix_complex_float_const_superdiagonal: cptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_const_view;
  fun gsl_matrix_complex_float_const_view_array: cptr[float] * size * size -> _gsl_matrix_complex_float_const_view;
  fun gsl_matrix_complex_float_const_view_array_with_tda: cptr[float] * size * size * size -> _gsl_matrix_complex_float_const_view;
  fun gsl_matrix_complex_float_const_view_vector: cptr[gsl_vector_complex_float] * size * size -> _gsl_matrix_complex_float_const_view;
  fun gsl_matrix_complex_float_const_view_vector_with_tda: cptr[gsl_vector_complex_float] * size * size * size -> _gsl_matrix_complex_float_const_view;
  fun gsl_matrix_complex_float_diagonal: ptr[gsl_matrix_complex_float] -> _gsl_vector_complex_float_view;
  fun gsl_matrix_complex_float_div_elements: ptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_fprintf: ptr[FILE] * cptr[gsl_matrix_complex_float] * cptr[char] -> int;
  fun gsl_matrix_complex_float_fread: ptr[FILE] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_fscanf: ptr[FILE] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_fwrite: ptr[FILE] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_get: cptr[gsl_matrix_complex_float] * size * size -> gsl_complex_float;
  fun gsl_matrix_complex_float_get_col: ptr[gsl_vector_complex_float] * cptr[gsl_matrix_complex_float] * size -> int;
  fun gsl_matrix_complex_float_get_row: ptr[gsl_vector_complex_float] * cptr[gsl_matrix_complex_float] * size -> int;
  fun gsl_matrix_complex_float_isnull: cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_memcpy: ptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_mul_elements: ptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_ptr: ptr[gsl_matrix_complex_float] * size * size -> ptr[gsl_complex_float];
  fun gsl_matrix_complex_float_row: ptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_view;
  fun gsl_matrix_complex_float_scale: ptr[gsl_matrix_complex_float] * gsl_complex_float -> int;
  fun gsl_matrix_complex_float_set_col: ptr[gsl_matrix_complex_float] * size * cptr[gsl_vector_complex_float] -> int;
  fun gsl_matrix_complex_float_set_row: ptr[gsl_matrix_complex_float] * size * cptr[gsl_vector_complex_float] -> int;
  fun gsl_matrix_complex_float_sub: ptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_subdiagonal: ptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_view;
  fun gsl_matrix_complex_float_submatrix: ptr[gsl_matrix_complex_float] * size * size * size * size -> _gsl_matrix_complex_float_view;
  fun gsl_matrix_complex_float_superdiagonal: ptr[gsl_matrix_complex_float] * size -> _gsl_vector_complex_float_view;
  fun gsl_matrix_complex_float_swap: ptr[gsl_matrix_complex_float] * ptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_swap_columns: ptr[gsl_matrix_complex_float] * size * size -> int;
  fun gsl_matrix_complex_float_swap_rowcol: ptr[gsl_matrix_complex_float] * size * size -> int;
  fun gsl_matrix_complex_float_swap_rows: ptr[gsl_matrix_complex_float] * size * size -> int;
  fun gsl_matrix_complex_float_transpose: ptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_transpose_memcpy: ptr[gsl_matrix_complex_float] * cptr[gsl_matrix_complex_float] -> int;
  fun gsl_matrix_complex_float_view_array: ptr[float] * size * size -> _gsl_matrix_complex_float_view;
  fun gsl_matrix_complex_float_view_array_with_tda: ptr[float] * size * size * size -> _gsl_matrix_complex_float_view;
  fun gsl_matrix_complex_float_view_vector: ptr[gsl_vector_complex_float] * size * size -> _gsl_matrix_complex_float_view;
  fun gsl_matrix_complex_float_view_vector_with_tda: ptr[gsl_vector_complex_float] * size * size * size -> _gsl_matrix_complex_float_view;
  fun gsl_vector_complex_float_alloc_col_from_matrix: ptr[gsl_matrix_complex_float] * size -> ptr[gsl_vector_complex_float];
  fun gsl_vector_complex_float_alloc_row_from_matrix: ptr[gsl_matrix_complex_float] * size -> ptr[gsl_vector_complex_float];
}
@h=tangler('lib/gsl/gsl_matrix_complex_long_double_lib.flx')
@select(h)
//Module        : gsl_matrix_complex_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_complex_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_COMPLEX_LONG_DOUBLE_H__
header '#include "gsl_matrix_complex_long_double.h"';

//INCLUDES
include "gsl_block_complex_long_double_lib";
include "gsl_complex_lib";
include "gsl_vector_complex_long_double_lib";

module gsl_matrix_complex_long_double_h
{
  open C_hack;
  open gsl_block_complex_long_double_h;
  open gsl_complex_h;
  open gsl_vector_complex_long_double_h;
  
  //ABSTRACT TYPES
  type _gsl_matrix_complex_long_double_view = '_gsl_matrix_complex_long_double_view';
  type _gsl_matrix_complex_long_double_const_view = '_gsl_matrix_complex_long_double_const_view';
  type gsl_matrix_complex_long_double = 'gsl_matrix_complex_long_double';
  
  //TYPE ALIASES
  typedef gsl_matrix_complex_long_double_const_view = _gsl_matrix_complex_long_double_const_view;
  typedef gsl_matrix_complex_long_double_view = _gsl_matrix_complex_long_double_view;
  
  //PROCEDURES
  proc gsl_matrix_complex_long_double_free: ptr[gsl_matrix_complex_long_double];
  proc gsl_matrix_complex_long_double_set: ptr[gsl_matrix_complex_long_double] * size * size * gsl_complex_long_double;
  proc gsl_matrix_complex_long_double_set_all: ptr[gsl_matrix_complex_long_double] * gsl_complex_long_double;
  proc gsl_matrix_complex_long_double_set_identity: ptr[gsl_matrix_complex_long_double];
  proc gsl_matrix_complex_long_double_set_zero: ptr[gsl_matrix_complex_long_double];
  
  //FUNCTIONS
  fun gsl_matrix_complex_long_double_add: ptr[gsl_matrix_complex_long_double] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_add_constant: ptr[gsl_matrix_complex_long_double] * gsl_complex_long_double -> int;
  fun gsl_matrix_complex_long_double_add_diagonal: ptr[gsl_matrix_complex_long_double] * gsl_complex_long_double -> int;
  fun gsl_matrix_complex_long_double_alloc: size * size -> ptr[gsl_matrix_complex_long_double];
  fun gsl_matrix_complex_long_double_alloc_from_block: ptr[gsl_block_complex_long_double] * size * size * size * size -> ptr[gsl_matrix_complex_long_double];
  fun gsl_matrix_complex_long_double_alloc_from_matrix: ptr[gsl_matrix_complex_long_double] * size * size * size * size -> ptr[gsl_matrix_complex_long_double];
  fun gsl_matrix_complex_long_double_calloc: size * size -> ptr[gsl_matrix_complex_long_double];
  fun gsl_matrix_complex_long_double_column: ptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_view;
  fun gsl_matrix_complex_long_double_const_column: cptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_diagonal: cptr[gsl_matrix_complex_long_double] -> _gsl_vector_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_ptr: cptr[gsl_matrix_complex_long_double] * size * size -> cptr[gsl_complex_long_double];
  fun gsl_matrix_complex_long_double_const_row: cptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_subdiagonal: cptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_submatrix: cptr[gsl_matrix_complex_long_double] * size * size * size * size -> _gsl_matrix_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_superdiagonal: cptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_view_array: cptr[ldouble] * size * size -> _gsl_matrix_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_view_array_with_tda: cptr[ldouble] * size * size * size -> _gsl_matrix_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_view_vector: cptr[gsl_vector_complex_long_double] * size * size -> _gsl_matrix_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_const_view_vector_with_tda: cptr[gsl_vector_complex_long_double] * size * size * size -> _gsl_matrix_complex_long_double_const_view;
  fun gsl_matrix_complex_long_double_diagonal: ptr[gsl_matrix_complex_long_double] -> _gsl_vector_complex_long_double_view;
  fun gsl_matrix_complex_long_double_div_elements: ptr[gsl_matrix_complex_long_double] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_fprintf: ptr[FILE] * cptr[gsl_matrix_complex_long_double] * cptr[char] -> int;
  fun gsl_matrix_complex_long_double_fread: ptr[FILE] * ptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_fscanf: ptr[FILE] * ptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_fwrite: ptr[FILE] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_get: cptr[gsl_matrix_complex_long_double] * size * size -> gsl_complex_long_double;
  fun gsl_matrix_complex_long_double_get_col: ptr[gsl_vector_complex_long_double] * cptr[gsl_matrix_complex_long_double] * size -> int;
  fun gsl_matrix_complex_long_double_get_row: ptr[gsl_vector_complex_long_double] * cptr[gsl_matrix_complex_long_double] * size -> int;
  fun gsl_matrix_complex_long_double_isnull: cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_memcpy: ptr[gsl_matrix_complex_long_double] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_mul_elements: ptr[gsl_matrix_complex_long_double] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_ptr: ptr[gsl_matrix_complex_long_double] * size * size -> ptr[gsl_complex_long_double];
  fun gsl_matrix_complex_long_double_row: ptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_view;
  fun gsl_matrix_complex_long_double_scale: ptr[gsl_matrix_complex_long_double] * gsl_complex_long_double -> int;
  fun gsl_matrix_complex_long_double_set_col: ptr[gsl_matrix_complex_long_double] * size * cptr[gsl_vector_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_set_row: ptr[gsl_matrix_complex_long_double] * size * cptr[gsl_vector_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_sub: ptr[gsl_matrix_complex_long_double] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_subdiagonal: ptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_view;
  fun gsl_matrix_complex_long_double_submatrix: ptr[gsl_matrix_complex_long_double] * size * size * size * size -> _gsl_matrix_complex_long_double_view;
  fun gsl_matrix_complex_long_double_superdiagonal: ptr[gsl_matrix_complex_long_double] * size -> _gsl_vector_complex_long_double_view;
  fun gsl_matrix_complex_long_double_swap: ptr[gsl_matrix_complex_long_double] * ptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_swap_columns: ptr[gsl_matrix_complex_long_double] * size * size -> int;
  fun gsl_matrix_complex_long_double_swap_rowcol: ptr[gsl_matrix_complex_long_double] * size * size -> int;
  fun gsl_matrix_complex_long_double_swap_rows: ptr[gsl_matrix_complex_long_double] * size * size -> int;
  fun gsl_matrix_complex_long_double_transpose: ptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_transpose_memcpy: ptr[gsl_matrix_complex_long_double] * cptr[gsl_matrix_complex_long_double] -> int;
  fun gsl_matrix_complex_long_double_view_array: ptr[ldouble] * size * size -> _gsl_matrix_complex_long_double_view;
  fun gsl_matrix_complex_long_double_view_array_with_tda: ptr[ldouble] * size * size * size -> _gsl_matrix_complex_long_double_view;
  fun gsl_matrix_complex_long_double_view_vector: ptr[gsl_vector_complex_long_double] * size * size -> _gsl_matrix_complex_long_double_view;
  fun gsl_matrix_complex_long_double_view_vector_with_tda: ptr[gsl_vector_complex_long_double] * size * size * size -> _gsl_matrix_complex_long_double_view;
  fun gsl_vector_complex_long_double_alloc_col_from_matrix: ptr[gsl_matrix_complex_long_double] * size -> ptr[gsl_vector_complex_long_double];
  fun gsl_vector_complex_long_double_alloc_row_from_matrix: ptr[gsl_matrix_complex_long_double] * size -> ptr[gsl_vector_complex_long_double];
}
@h=tangler('lib/gsl/gsl_matrix_double_lib.flx')
@select(h)
//Module        : gsl_matrix_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_DOUBLE_H__
header '#include "gsl_matrix_double.h"';

//INCLUDES
include "gsl_block_double_lib";
include "gsl_vector_double_lib";

module gsl_matrix_double_h
{
  open C_hack;
  open gsl_block_double_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type _gsl_matrix_const_view = '_gsl_matrix_const_view';
  type gsl_matrix = 'gsl_matrix';
  type _gsl_matrix_view = '_gsl_matrix_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_const_view = _gsl_matrix_const_view;
  typedef gsl_matrix_view = _gsl_matrix_view;
  
  //PROCEDURES
  proc gsl_matrix_free: ptr[gsl_matrix];
  proc gsl_matrix_max_index: cptr[gsl_matrix] * ptr[size] * ptr[size];
  proc gsl_matrix_min_index: cptr[gsl_matrix] * ptr[size] * ptr[size];
  proc gsl_matrix_minmax: cptr[gsl_matrix] * ptr[double] * ptr[double];
  proc gsl_matrix_minmax_index: cptr[gsl_matrix] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_set: ptr[gsl_matrix] * size * size * double;
  proc gsl_matrix_set_all: ptr[gsl_matrix] * double;
  proc gsl_matrix_set_identity: ptr[gsl_matrix];
  proc gsl_matrix_set_zero: ptr[gsl_matrix];
  
  //FUNCTIONS
  fun gsl_matrix_add: ptr[gsl_matrix] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_add_constant: ptr[gsl_matrix] * double -> int;
  fun gsl_matrix_add_diagonal: ptr[gsl_matrix] * double -> int;
  fun gsl_matrix_alloc: size * size -> ptr[gsl_matrix];
  fun gsl_matrix_alloc_from_block: ptr[gsl_block] * size * size * size * size -> ptr[gsl_matrix];
  fun gsl_matrix_alloc_from_matrix: ptr[gsl_matrix] * size * size * size * size -> ptr[gsl_matrix];
  fun gsl_matrix_calloc: size * size -> ptr[gsl_matrix];
  fun gsl_matrix_column: ptr[gsl_matrix] * size -> _gsl_vector_view;
  fun gsl_matrix_const_column: cptr[gsl_matrix] * size -> _gsl_vector_const_view;
  fun gsl_matrix_const_diagonal: cptr[gsl_matrix] -> _gsl_vector_const_view;
  fun gsl_matrix_const_ptr: cptr[gsl_matrix] * size * size -> cptr[double];
  fun gsl_matrix_const_row: cptr[gsl_matrix] * size -> _gsl_vector_const_view;
  fun gsl_matrix_const_subdiagonal: cptr[gsl_matrix] * size -> _gsl_vector_const_view;
  fun gsl_matrix_const_submatrix: cptr[gsl_matrix] * size * size * size * size -> _gsl_matrix_const_view;
  fun gsl_matrix_const_superdiagonal: cptr[gsl_matrix] * size -> _gsl_vector_const_view;
  fun gsl_matrix_const_view_array: cptr[double] * size * size -> _gsl_matrix_const_view;
  fun gsl_matrix_const_view_array_with_tda: cptr[double] * size * size * size -> _gsl_matrix_const_view;
  fun gsl_matrix_const_view_vector: cptr[gsl_vector] * size * size -> _gsl_matrix_const_view;
  fun gsl_matrix_const_view_vector_with_tda: cptr[gsl_vector] * size * size * size -> _gsl_matrix_const_view;
  fun gsl_matrix_diagonal: ptr[gsl_matrix] -> _gsl_vector_view;
  fun gsl_matrix_div_elements: ptr[gsl_matrix] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_fprintf: ptr[FILE] * cptr[gsl_matrix] * cptr[char] -> int;
  fun gsl_matrix_fread: ptr[FILE] * ptr[gsl_matrix] -> int;
  fun gsl_matrix_fscanf: ptr[FILE] * ptr[gsl_matrix] -> int;
  fun gsl_matrix_fwrite: ptr[FILE] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_get: cptr[gsl_matrix] * size * size -> double;
  fun gsl_matrix_get_col: ptr[gsl_vector] * cptr[gsl_matrix] * size -> int;
  fun gsl_matrix_get_row: ptr[gsl_vector] * cptr[gsl_matrix] * size -> int;
  fun gsl_matrix_isnull: cptr[gsl_matrix] -> int;
  fun gsl_matrix_max: cptr[gsl_matrix] -> double;
  fun gsl_matrix_memcpy: ptr[gsl_matrix] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_min: cptr[gsl_matrix] -> double;
  fun gsl_matrix_mul_elements: ptr[gsl_matrix] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_ptr: ptr[gsl_matrix] * size * size -> ptr[double];
  fun gsl_matrix_row: ptr[gsl_matrix] * size -> _gsl_vector_view;
  fun gsl_matrix_scale: ptr[gsl_matrix] * double -> int;
  fun gsl_matrix_set_col: ptr[gsl_matrix] * size * cptr[gsl_vector] -> int;
  fun gsl_matrix_set_row: ptr[gsl_matrix] * size * cptr[gsl_vector] -> int;
  fun gsl_matrix_sub: ptr[gsl_matrix] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_subdiagonal: ptr[gsl_matrix] * size -> _gsl_vector_view;
  fun gsl_matrix_submatrix: ptr[gsl_matrix] * size * size * size * size -> _gsl_matrix_view;
  fun gsl_matrix_superdiagonal: ptr[gsl_matrix] * size -> _gsl_vector_view;
  fun gsl_matrix_swap: ptr[gsl_matrix] * ptr[gsl_matrix] -> int;
  fun gsl_matrix_swap_columns: ptr[gsl_matrix] * size * size -> int;
  fun gsl_matrix_swap_rowcol: ptr[gsl_matrix] * size * size -> int;
  fun gsl_matrix_swap_rows: ptr[gsl_matrix] * size * size -> int;
  fun gsl_matrix_transpose: ptr[gsl_matrix] -> int;
  fun gsl_matrix_transpose_memcpy: ptr[gsl_matrix] * cptr[gsl_matrix] -> int;
  fun gsl_matrix_view_array: ptr[double] * size * size -> _gsl_matrix_view;
  fun gsl_matrix_view_array_with_tda: ptr[double] * size * size * size -> _gsl_matrix_view;
  fun gsl_matrix_view_vector: ptr[gsl_vector] * size * size -> _gsl_matrix_view;
  fun gsl_matrix_view_vector_with_tda: ptr[gsl_vector] * size * size * size -> _gsl_matrix_view;
  fun gsl_vector_alloc_col_from_matrix: ptr[gsl_matrix] * size -> ptr[gsl_vector];
  fun gsl_vector_alloc_row_from_matrix: ptr[gsl_matrix] * size -> ptr[gsl_vector];
}
@h=tangler('lib/gsl/gsl_matrix_float_lib.flx')
@select(h)
//Module        : gsl_matrix_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_FLOAT_H__
header '#include "gsl_matrix_float.h"';

//INCLUDES
include "gsl_block_float_lib";
include "gsl_vector_float_lib";

module gsl_matrix_float_h
{
  open C_hack;
  open gsl_block_float_h;
  open gsl_vector_float_h;
  
  //ABSTRACT TYPES
  type _gsl_matrix_float_const_view = '_gsl_matrix_float_const_view';
  type gsl_matrix_float = 'gsl_matrix_float';
  type _gsl_matrix_float_view = '_gsl_matrix_float_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_float_view = _gsl_matrix_float_view;
  typedef gsl_matrix_float_const_view = _gsl_matrix_float_const_view;
  
  //PROCEDURES
  proc gsl_matrix_float_free: ptr[gsl_matrix_float];
  proc gsl_matrix_float_max_index: cptr[gsl_matrix_float] * ptr[size] * ptr[size];
  proc gsl_matrix_float_min_index: cptr[gsl_matrix_float] * ptr[size] * ptr[size];
  proc gsl_matrix_float_minmax: cptr[gsl_matrix_float] * ptr[float] * ptr[float];
  proc gsl_matrix_float_minmax_index: cptr[gsl_matrix_float] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_float_set: ptr[gsl_matrix_float] * size * size * float;
  proc gsl_matrix_float_set_all: ptr[gsl_matrix_float] * float;
  proc gsl_matrix_float_set_identity: ptr[gsl_matrix_float];
  proc gsl_matrix_float_set_zero: ptr[gsl_matrix_float];
  
  //FUNCTIONS
  fun gsl_matrix_float_add: ptr[gsl_matrix_float] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_add_constant: ptr[gsl_matrix_float] * double -> int;
  fun gsl_matrix_float_add_diagonal: ptr[gsl_matrix_float] * double -> int;
  fun gsl_matrix_float_alloc: size * size -> ptr[gsl_matrix_float];
  fun gsl_matrix_float_alloc_from_block: ptr[gsl_block_float] * size * size * size * size -> ptr[gsl_matrix_float];
  fun gsl_matrix_float_alloc_from_matrix: ptr[gsl_matrix_float] * size * size * size * size -> ptr[gsl_matrix_float];
  fun gsl_matrix_float_calloc: size * size -> ptr[gsl_matrix_float];
  fun gsl_matrix_float_column: ptr[gsl_matrix_float] * size -> _gsl_vector_float_view;
  fun gsl_matrix_float_const_column: cptr[gsl_matrix_float] * size -> _gsl_vector_float_const_view;
  fun gsl_matrix_float_const_diagonal: cptr[gsl_matrix_float] -> _gsl_vector_float_const_view;
  fun gsl_matrix_float_const_ptr: cptr[gsl_matrix_float] * size * size -> cptr[float];
  fun gsl_matrix_float_const_row: cptr[gsl_matrix_float] * size -> _gsl_vector_float_const_view;
  fun gsl_matrix_float_const_subdiagonal: cptr[gsl_matrix_float] * size -> _gsl_vector_float_const_view;
  fun gsl_matrix_float_const_submatrix: cptr[gsl_matrix_float] * size * size * size * size -> _gsl_matrix_float_const_view;
  fun gsl_matrix_float_const_superdiagonal: cptr[gsl_matrix_float] * size -> _gsl_vector_float_const_view;
  fun gsl_matrix_float_const_view_array: cptr[float] * size * size -> _gsl_matrix_float_const_view;
  fun gsl_matrix_float_const_view_array_with_tda: cptr[float] * size * size * size -> _gsl_matrix_float_const_view;
  fun gsl_matrix_float_const_view_vector: cptr[gsl_vector_float] * size * size -> _gsl_matrix_float_const_view;
  fun gsl_matrix_float_const_view_vector_with_tda: cptr[gsl_vector_float] * size * size * size -> _gsl_matrix_float_const_view;
  fun gsl_matrix_float_diagonal: ptr[gsl_matrix_float] -> _gsl_vector_float_view;
  fun gsl_matrix_float_div_elements: ptr[gsl_matrix_float] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_fprintf: ptr[FILE] * cptr[gsl_matrix_float] * cptr[char] -> int;
  fun gsl_matrix_float_fread: ptr[FILE] * ptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_fscanf: ptr[FILE] * ptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_fwrite: ptr[FILE] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_get: cptr[gsl_matrix_float] * size * size -> float;
  fun gsl_matrix_float_get_col: ptr[gsl_vector_float] * cptr[gsl_matrix_float] * size -> int;
  fun gsl_matrix_float_get_row: ptr[gsl_vector_float] * cptr[gsl_matrix_float] * size -> int;
  fun gsl_matrix_float_isnull: cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_max: cptr[gsl_matrix_float] -> float;
  fun gsl_matrix_float_memcpy: ptr[gsl_matrix_float] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_min: cptr[gsl_matrix_float] -> float;
  fun gsl_matrix_float_mul_elements: ptr[gsl_matrix_float] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_ptr: ptr[gsl_matrix_float] * size * size -> ptr[float];
  fun gsl_matrix_float_row: ptr[gsl_matrix_float] * size -> _gsl_vector_float_view;
  fun gsl_matrix_float_scale: ptr[gsl_matrix_float] * double -> int;
  fun gsl_matrix_float_set_col: ptr[gsl_matrix_float] * size * cptr[gsl_vector_float] -> int;
  fun gsl_matrix_float_set_row: ptr[gsl_matrix_float] * size * cptr[gsl_vector_float] -> int;
  fun gsl_matrix_float_sub: ptr[gsl_matrix_float] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_subdiagonal: ptr[gsl_matrix_float] * size -> _gsl_vector_float_view;
  fun gsl_matrix_float_submatrix: ptr[gsl_matrix_float] * size * size * size * size -> _gsl_matrix_float_view;
  fun gsl_matrix_float_superdiagonal: ptr[gsl_matrix_float] * size -> _gsl_vector_float_view;
  fun gsl_matrix_float_swap: ptr[gsl_matrix_float] * ptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_swap_columns: ptr[gsl_matrix_float] * size * size -> int;
  fun gsl_matrix_float_swap_rowcol: ptr[gsl_matrix_float] * size * size -> int;
  fun gsl_matrix_float_swap_rows: ptr[gsl_matrix_float] * size * size -> int;
  fun gsl_matrix_float_transpose: ptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_transpose_memcpy: ptr[gsl_matrix_float] * cptr[gsl_matrix_float] -> int;
  fun gsl_matrix_float_view_array: ptr[float] * size * size -> _gsl_matrix_float_view;
  fun gsl_matrix_float_view_array_with_tda: ptr[float] * size * size * size -> _gsl_matrix_float_view;
  fun gsl_matrix_float_view_vector: ptr[gsl_vector_float] * size * size -> _gsl_matrix_float_view;
  fun gsl_matrix_float_view_vector_with_tda: ptr[gsl_vector_float] * size * size * size -> _gsl_matrix_float_view;
  fun gsl_vector_float_alloc_col_from_matrix: ptr[gsl_matrix_float] * size -> ptr[gsl_vector_float];
  fun gsl_vector_float_alloc_row_from_matrix: ptr[gsl_matrix_float] * size -> ptr[gsl_vector_float];
}
@h=tangler('lib/gsl/gsl_matrix_int_lib.flx')
@select(h)
//Module        : gsl_matrix_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_INT_H__
header '#include "gsl_matrix_int.h"';

//INCLUDES
include "gsl_block_int_lib";
include "gsl_vector_int_lib";

module gsl_matrix_int_h
{
  open C_hack;
  open gsl_block_int_h;
  open gsl_vector_int_h;
  
  //ABSTRACT TYPES
  type _gsl_matrix_int_const_view = '_gsl_matrix_int_const_view';
  type gsl_matrix_int = 'gsl_matrix_int';
  type _gsl_matrix_int_view = '_gsl_matrix_int_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_int_const_view = _gsl_matrix_int_const_view;
  typedef gsl_matrix_int_view = _gsl_matrix_int_view;
  
  //PROCEDURES
  proc gsl_matrix_int_free: ptr[gsl_matrix_int];
  proc gsl_matrix_int_max_index: cptr[gsl_matrix_int] * ptr[size] * ptr[size];
  proc gsl_matrix_int_min_index: cptr[gsl_matrix_int] * ptr[size] * ptr[size];
  proc gsl_matrix_int_minmax: cptr[gsl_matrix_int] * ptr[int] * ptr[int];
  proc gsl_matrix_int_minmax_index: cptr[gsl_matrix_int] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_int_set: ptr[gsl_matrix_int] * size * size * int;
  proc gsl_matrix_int_set_all: ptr[gsl_matrix_int] * int;
  proc gsl_matrix_int_set_identity: ptr[gsl_matrix_int];
  proc gsl_matrix_int_set_zero: ptr[gsl_matrix_int];
  
  //FUNCTIONS
  fun gsl_matrix_int_add: ptr[gsl_matrix_int] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_add_constant: ptr[gsl_matrix_int] * double -> int;
  fun gsl_matrix_int_add_diagonal: ptr[gsl_matrix_int] * double -> int;
  fun gsl_matrix_int_alloc: size * size -> ptr[gsl_matrix_int];
  fun gsl_matrix_int_alloc_from_block: ptr[gsl_block_int] * size * size * size * size -> ptr[gsl_matrix_int];
  fun gsl_matrix_int_alloc_from_matrix: ptr[gsl_matrix_int] * size * size * size * size -> ptr[gsl_matrix_int];
  fun gsl_matrix_int_calloc: size * size -> ptr[gsl_matrix_int];
  fun gsl_matrix_int_column: ptr[gsl_matrix_int] * size -> _gsl_vector_int_view;
  fun gsl_matrix_int_const_column: cptr[gsl_matrix_int] * size -> _gsl_vector_int_const_view;
  fun gsl_matrix_int_const_diagonal: cptr[gsl_matrix_int] -> _gsl_vector_int_const_view;
  fun gsl_matrix_int_const_ptr: cptr[gsl_matrix_int] * size * size -> cptr[int];
  fun gsl_matrix_int_const_row: cptr[gsl_matrix_int] * size -> _gsl_vector_int_const_view;
  fun gsl_matrix_int_const_subdiagonal: cptr[gsl_matrix_int] * size -> _gsl_vector_int_const_view;
  fun gsl_matrix_int_const_submatrix: cptr[gsl_matrix_int] * size * size * size * size -> _gsl_matrix_int_const_view;
  fun gsl_matrix_int_const_superdiagonal: cptr[gsl_matrix_int] * size -> _gsl_vector_int_const_view;
  fun gsl_matrix_int_const_view_array: cptr[int] * size * size -> _gsl_matrix_int_const_view;
  fun gsl_matrix_int_const_view_array_with_tda: cptr[int] * size * size * size -> _gsl_matrix_int_const_view;
  fun gsl_matrix_int_const_view_vector: cptr[gsl_vector_int] * size * size -> _gsl_matrix_int_const_view;
  fun gsl_matrix_int_const_view_vector_with_tda: cptr[gsl_vector_int] * size * size * size -> _gsl_matrix_int_const_view;
  fun gsl_matrix_int_diagonal: ptr[gsl_matrix_int] -> _gsl_vector_int_view;
  fun gsl_matrix_int_div_elements: ptr[gsl_matrix_int] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_fprintf: ptr[FILE] * cptr[gsl_matrix_int] * cptr[char] -> int;
  fun gsl_matrix_int_fread: ptr[FILE] * ptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_fscanf: ptr[FILE] * ptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_fwrite: ptr[FILE] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_get: cptr[gsl_matrix_int] * size * size -> int;
  fun gsl_matrix_int_get_col: ptr[gsl_vector_int] * cptr[gsl_matrix_int] * size -> int;
  fun gsl_matrix_int_get_row: ptr[gsl_vector_int] * cptr[gsl_matrix_int] * size -> int;
  fun gsl_matrix_int_isnull: cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_max: cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_memcpy: ptr[gsl_matrix_int] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_min: cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_mul_elements: ptr[gsl_matrix_int] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_ptr: ptr[gsl_matrix_int] * size * size -> ptr[int];
  fun gsl_matrix_int_row: ptr[gsl_matrix_int] * size -> _gsl_vector_int_view;
  fun gsl_matrix_int_scale: ptr[gsl_matrix_int] * double -> int;
  fun gsl_matrix_int_set_col: ptr[gsl_matrix_int] * size * cptr[gsl_vector_int] -> int;
  fun gsl_matrix_int_set_row: ptr[gsl_matrix_int] * size * cptr[gsl_vector_int] -> int;
  fun gsl_matrix_int_sub: ptr[gsl_matrix_int] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_subdiagonal: ptr[gsl_matrix_int] * size -> _gsl_vector_int_view;
  fun gsl_matrix_int_submatrix: ptr[gsl_matrix_int] * size * size * size * size -> _gsl_matrix_int_view;
  fun gsl_matrix_int_superdiagonal: ptr[gsl_matrix_int] * size -> _gsl_vector_int_view;
  fun gsl_matrix_int_swap: ptr[gsl_matrix_int] * ptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_swap_columns: ptr[gsl_matrix_int] * size * size -> int;
  fun gsl_matrix_int_swap_rowcol: ptr[gsl_matrix_int] * size * size -> int;
  fun gsl_matrix_int_swap_rows: ptr[gsl_matrix_int] * size * size -> int;
  fun gsl_matrix_int_transpose: ptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_transpose_memcpy: ptr[gsl_matrix_int] * cptr[gsl_matrix_int] -> int;
  fun gsl_matrix_int_view_array: ptr[int] * size * size -> _gsl_matrix_int_view;
  fun gsl_matrix_int_view_array_with_tda: ptr[int] * size * size * size -> _gsl_matrix_int_view;
  fun gsl_matrix_int_view_vector: ptr[gsl_vector_int] * size * size -> _gsl_matrix_int_view;
  fun gsl_matrix_int_view_vector_with_tda: ptr[gsl_vector_int] * size * size * size -> _gsl_matrix_int_view;
  fun gsl_vector_int_alloc_col_from_matrix: ptr[gsl_matrix_int] * size -> ptr[gsl_vector_int];
  fun gsl_vector_int_alloc_row_from_matrix: ptr[gsl_matrix_int] * size -> ptr[gsl_vector_int];
}
@h=tangler('lib/gsl/gsl_matrix_lib.flx')
@select(h)
//Module        : gsl_matrix_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_H__
header '#include "gsl_matrix.h"';

module gsl_matrix_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_matrix_long_double_lib.flx')
@select(h)
//Module        : gsl_matrix_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_LONG_DOUBLE_H__
header '#include "gsl_matrix_long_double.h"';

//INCLUDES
include "gsl_block_long_double_lib";
include "gsl_vector_long_double_lib";

module gsl_matrix_long_double_h
{
  open C_hack;
  open gsl_block_long_double_h;
  open gsl_vector_long_double_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_long_double = 'gsl_matrix_long_double';
  type _gsl_matrix_long_double_const_view = '_gsl_matrix_long_double_const_view';
  type _gsl_matrix_long_double_view = '_gsl_matrix_long_double_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_long_double_view = _gsl_matrix_long_double_view;
  typedef gsl_matrix_long_double_const_view = _gsl_matrix_long_double_const_view;
  
  //PROCEDURES
  proc gsl_matrix_long_double_free: ptr[gsl_matrix_long_double];
  proc gsl_matrix_long_double_max_index: cptr[gsl_matrix_long_double] * ptr[size] * ptr[size];
  proc gsl_matrix_long_double_min_index: cptr[gsl_matrix_long_double] * ptr[size] * ptr[size];
  proc gsl_matrix_long_double_minmax: cptr[gsl_matrix_long_double] * ptr[ldouble] * ptr[ldouble];
  proc gsl_matrix_long_double_minmax_index: cptr[gsl_matrix_long_double] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_long_double_set: ptr[gsl_matrix_long_double] * size * size * ldouble;
  proc gsl_matrix_long_double_set_all: ptr[gsl_matrix_long_double] * ldouble;
  proc gsl_matrix_long_double_set_identity: ptr[gsl_matrix_long_double];
  proc gsl_matrix_long_double_set_zero: ptr[gsl_matrix_long_double];
  
  //FUNCTIONS
  fun gsl_matrix_long_double_add: ptr[gsl_matrix_long_double] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_add_constant: ptr[gsl_matrix_long_double] * double -> int;
  fun gsl_matrix_long_double_add_diagonal: ptr[gsl_matrix_long_double] * double -> int;
  fun gsl_matrix_long_double_alloc: size * size -> ptr[gsl_matrix_long_double];
  fun gsl_matrix_long_double_alloc_from_block: ptr[gsl_block_long_double] * size * size * size * size -> ptr[gsl_matrix_long_double];
  fun gsl_matrix_long_double_alloc_from_matrix: ptr[gsl_matrix_long_double] * size * size * size * size -> ptr[gsl_matrix_long_double];
  fun gsl_matrix_long_double_calloc: size * size -> ptr[gsl_matrix_long_double];
  fun gsl_matrix_long_double_column: ptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_view;
  fun gsl_matrix_long_double_const_column: cptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_const_view;
  fun gsl_matrix_long_double_const_diagonal: cptr[gsl_matrix_long_double] -> _gsl_vector_long_double_const_view;
  fun gsl_matrix_long_double_const_ptr: cptr[gsl_matrix_long_double] * size * size -> cptr[ldouble];
  fun gsl_matrix_long_double_const_row: cptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_const_view;
  fun gsl_matrix_long_double_const_subdiagonal: cptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_const_view;
  fun gsl_matrix_long_double_const_submatrix: cptr[gsl_matrix_long_double] * size * size * size * size -> _gsl_matrix_long_double_const_view;
  fun gsl_matrix_long_double_const_superdiagonal: cptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_const_view;
  fun gsl_matrix_long_double_const_view_array: cptr[ldouble] * size * size -> _gsl_matrix_long_double_const_view;
  fun gsl_matrix_long_double_const_view_array_with_tda: cptr[ldouble] * size * size * size -> _gsl_matrix_long_double_const_view;
  fun gsl_matrix_long_double_const_view_vector: cptr[gsl_vector_long_double] * size * size -> _gsl_matrix_long_double_const_view;
  fun gsl_matrix_long_double_const_view_vector_with_tda: cptr[gsl_vector_long_double] * size * size * size -> _gsl_matrix_long_double_const_view;
  fun gsl_matrix_long_double_diagonal: ptr[gsl_matrix_long_double] -> _gsl_vector_long_double_view;
  fun gsl_matrix_long_double_div_elements: ptr[gsl_matrix_long_double] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_fprintf: ptr[FILE] * cptr[gsl_matrix_long_double] * cptr[char] -> int;
  fun gsl_matrix_long_double_fread: ptr[FILE] * ptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_fscanf: ptr[FILE] * ptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_fwrite: ptr[FILE] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_get: cptr[gsl_matrix_long_double] * size * size -> ldouble;
  fun gsl_matrix_long_double_get_col: ptr[gsl_vector_long_double] * cptr[gsl_matrix_long_double] * size -> int;
  fun gsl_matrix_long_double_get_row: ptr[gsl_vector_long_double] * cptr[gsl_matrix_long_double] * size -> int;
  fun gsl_matrix_long_double_isnull: cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_max: cptr[gsl_matrix_long_double] -> ldouble;
  fun gsl_matrix_long_double_memcpy: ptr[gsl_matrix_long_double] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_min: cptr[gsl_matrix_long_double] -> ldouble;
  fun gsl_matrix_long_double_mul_elements: ptr[gsl_matrix_long_double] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_ptr: ptr[gsl_matrix_long_double] * size * size -> ptr[ldouble];
  fun gsl_matrix_long_double_row: ptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_view;
  fun gsl_matrix_long_double_scale: ptr[gsl_matrix_long_double] * double -> int;
  fun gsl_matrix_long_double_set_col: ptr[gsl_matrix_long_double] * size * cptr[gsl_vector_long_double] -> int;
  fun gsl_matrix_long_double_set_row: ptr[gsl_matrix_long_double] * size * cptr[gsl_vector_long_double] -> int;
  fun gsl_matrix_long_double_sub: ptr[gsl_matrix_long_double] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_subdiagonal: ptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_view;
  fun gsl_matrix_long_double_submatrix: ptr[gsl_matrix_long_double] * size * size * size * size -> _gsl_matrix_long_double_view;
  fun gsl_matrix_long_double_superdiagonal: ptr[gsl_matrix_long_double] * size -> _gsl_vector_long_double_view;
  fun gsl_matrix_long_double_swap: ptr[gsl_matrix_long_double] * ptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_swap_columns: ptr[gsl_matrix_long_double] * size * size -> int;
  fun gsl_matrix_long_double_swap_rowcol: ptr[gsl_matrix_long_double] * size * size -> int;
  fun gsl_matrix_long_double_swap_rows: ptr[gsl_matrix_long_double] * size * size -> int;
  fun gsl_matrix_long_double_transpose: ptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_transpose_memcpy: ptr[gsl_matrix_long_double] * cptr[gsl_matrix_long_double] -> int;
  fun gsl_matrix_long_double_view_array: ptr[ldouble] * size * size -> _gsl_matrix_long_double_view;
  fun gsl_matrix_long_double_view_array_with_tda: ptr[ldouble] * size * size * size -> _gsl_matrix_long_double_view;
  fun gsl_matrix_long_double_view_vector: ptr[gsl_vector_long_double] * size * size -> _gsl_matrix_long_double_view;
  fun gsl_matrix_long_double_view_vector_with_tda: ptr[gsl_vector_long_double] * size * size * size -> _gsl_matrix_long_double_view;
  fun gsl_vector_long_double_alloc_col_from_matrix: ptr[gsl_matrix_long_double] * size -> ptr[gsl_vector_long_double];
  fun gsl_vector_long_double_alloc_row_from_matrix: ptr[gsl_matrix_long_double] * size -> ptr[gsl_vector_long_double];
}
@h=tangler('lib/gsl/gsl_matrix_long_lib.flx')
@select(h)
//Module        : gsl_matrix_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_LONG_H__
header '#include "gsl_matrix_long.h"';

//INCLUDES
include "gsl_block_long_lib";
include "gsl_vector_long_lib";

module gsl_matrix_long_h
{
  open C_hack;
  open gsl_block_long_h;
  open gsl_vector_long_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_long = 'gsl_matrix_long';
  type _gsl_matrix_long_view = '_gsl_matrix_long_view';
  type _gsl_matrix_long_const_view = '_gsl_matrix_long_const_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_long_view = _gsl_matrix_long_view;
  typedef gsl_matrix_long_const_view = _gsl_matrix_long_const_view;
  
  //PROCEDURES
  proc gsl_matrix_long_free: ptr[gsl_matrix_long];
  proc gsl_matrix_long_max_index: cptr[gsl_matrix_long] * ptr[size] * ptr[size];
  proc gsl_matrix_long_min_index: cptr[gsl_matrix_long] * ptr[size] * ptr[size];
  proc gsl_matrix_long_minmax: cptr[gsl_matrix_long] * ptr[long] * ptr[long];
  proc gsl_matrix_long_minmax_index: cptr[gsl_matrix_long] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_long_set: ptr[gsl_matrix_long] * size * size * long;
  proc gsl_matrix_long_set_all: ptr[gsl_matrix_long] * long;
  proc gsl_matrix_long_set_identity: ptr[gsl_matrix_long];
  proc gsl_matrix_long_set_zero: ptr[gsl_matrix_long];
  
  //FUNCTIONS
  fun gsl_matrix_long_add: ptr[gsl_matrix_long] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_add_constant: ptr[gsl_matrix_long] * double -> int;
  fun gsl_matrix_long_add_diagonal: ptr[gsl_matrix_long] * double -> int;
  fun gsl_matrix_long_alloc: size * size -> ptr[gsl_matrix_long];
  fun gsl_matrix_long_alloc_from_block: ptr[gsl_block_long] * size * size * size * size -> ptr[gsl_matrix_long];
  fun gsl_matrix_long_alloc_from_matrix: ptr[gsl_matrix_long] * size * size * size * size -> ptr[gsl_matrix_long];
  fun gsl_matrix_long_calloc: size * size -> ptr[gsl_matrix_long];
  fun gsl_matrix_long_column: ptr[gsl_matrix_long] * size -> _gsl_vector_long_view;
  fun gsl_matrix_long_const_column: cptr[gsl_matrix_long] * size -> _gsl_vector_long_const_view;
  fun gsl_matrix_long_const_diagonal: cptr[gsl_matrix_long] -> _gsl_vector_long_const_view;
  fun gsl_matrix_long_const_ptr: cptr[gsl_matrix_long] * size * size -> cptr[long];
  fun gsl_matrix_long_const_row: cptr[gsl_matrix_long] * size -> _gsl_vector_long_const_view;
  fun gsl_matrix_long_const_subdiagonal: cptr[gsl_matrix_long] * size -> _gsl_vector_long_const_view;
  fun gsl_matrix_long_const_submatrix: cptr[gsl_matrix_long] * size * size * size * size -> _gsl_matrix_long_const_view;
  fun gsl_matrix_long_const_superdiagonal: cptr[gsl_matrix_long] * size -> _gsl_vector_long_const_view;
  fun gsl_matrix_long_const_view_array: cptr[long] * size * size -> _gsl_matrix_long_const_view;
  fun gsl_matrix_long_const_view_array_with_tda: cptr[long] * size * size * size -> _gsl_matrix_long_const_view;
  fun gsl_matrix_long_const_view_vector: cptr[gsl_vector_long] * size * size -> _gsl_matrix_long_const_view;
  fun gsl_matrix_long_const_view_vector_with_tda: cptr[gsl_vector_long] * size * size * size -> _gsl_matrix_long_const_view;
  fun gsl_matrix_long_diagonal: ptr[gsl_matrix_long] -> _gsl_vector_long_view;
  fun gsl_matrix_long_div_elements: ptr[gsl_matrix_long] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_fprintf: ptr[FILE] * cptr[gsl_matrix_long] * cptr[char] -> int;
  fun gsl_matrix_long_fread: ptr[FILE] * ptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_fscanf: ptr[FILE] * ptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_fwrite: ptr[FILE] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_get: cptr[gsl_matrix_long] * size * size -> long;
  fun gsl_matrix_long_get_col: ptr[gsl_vector_long] * cptr[gsl_matrix_long] * size -> int;
  fun gsl_matrix_long_get_row: ptr[gsl_vector_long] * cptr[gsl_matrix_long] * size -> int;
  fun gsl_matrix_long_isnull: cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_max: cptr[gsl_matrix_long] -> long;
  fun gsl_matrix_long_memcpy: ptr[gsl_matrix_long] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_min: cptr[gsl_matrix_long] -> long;
  fun gsl_matrix_long_mul_elements: ptr[gsl_matrix_long] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_ptr: ptr[gsl_matrix_long] * size * size -> ptr[long];
  fun gsl_matrix_long_row: ptr[gsl_matrix_long] * size -> _gsl_vector_long_view;
  fun gsl_matrix_long_scale: ptr[gsl_matrix_long] * double -> int;
  fun gsl_matrix_long_set_col: ptr[gsl_matrix_long] * size * cptr[gsl_vector_long] -> int;
  fun gsl_matrix_long_set_row: ptr[gsl_matrix_long] * size * cptr[gsl_vector_long] -> int;
  fun gsl_matrix_long_sub: ptr[gsl_matrix_long] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_subdiagonal: ptr[gsl_matrix_long] * size -> _gsl_vector_long_view;
  fun gsl_matrix_long_submatrix: ptr[gsl_matrix_long] * size * size * size * size -> _gsl_matrix_long_view;
  fun gsl_matrix_long_superdiagonal: ptr[gsl_matrix_long] * size -> _gsl_vector_long_view;
  fun gsl_matrix_long_swap: ptr[gsl_matrix_long] * ptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_swap_columns: ptr[gsl_matrix_long] * size * size -> int;
  fun gsl_matrix_long_swap_rowcol: ptr[gsl_matrix_long] * size * size -> int;
  fun gsl_matrix_long_swap_rows: ptr[gsl_matrix_long] * size * size -> int;
  fun gsl_matrix_long_transpose: ptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_transpose_memcpy: ptr[gsl_matrix_long] * cptr[gsl_matrix_long] -> int;
  fun gsl_matrix_long_view_array: ptr[long] * size * size -> _gsl_matrix_long_view;
  fun gsl_matrix_long_view_array_with_tda: ptr[long] * size * size * size -> _gsl_matrix_long_view;
  fun gsl_matrix_long_view_vector: ptr[gsl_vector_long] * size * size -> _gsl_matrix_long_view;
  fun gsl_matrix_long_view_vector_with_tda: ptr[gsl_vector_long] * size * size * size -> _gsl_matrix_long_view;
  fun gsl_vector_long_alloc_col_from_matrix: ptr[gsl_matrix_long] * size -> ptr[gsl_vector_long];
  fun gsl_vector_long_alloc_row_from_matrix: ptr[gsl_matrix_long] * size -> ptr[gsl_vector_long];
}
@h=tangler('lib/gsl/gsl_matrix_short_lib.flx')
@select(h)
//Module        : gsl_matrix_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_SHORT_H__
header '#include "gsl_matrix_short.h"';

//INCLUDES
include "gsl_block_short_lib";
include "gsl_vector_short_lib";

module gsl_matrix_short_h
{
  open C_hack;
  open gsl_block_short_h;
  open gsl_vector_short_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_short = 'gsl_matrix_short';
  type _gsl_matrix_short_const_view = '_gsl_matrix_short_const_view';
  type _gsl_matrix_short_view = '_gsl_matrix_short_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_short_const_view = _gsl_matrix_short_const_view;
  typedef gsl_matrix_short_view = _gsl_matrix_short_view;
  
  //PROCEDURES
  proc gsl_matrix_short_free: ptr[gsl_matrix_short];
  proc gsl_matrix_short_max_index: cptr[gsl_matrix_short] * ptr[size] * ptr[size];
  proc gsl_matrix_short_min_index: cptr[gsl_matrix_short] * ptr[size] * ptr[size];
  proc gsl_matrix_short_minmax: cptr[gsl_matrix_short] * ptr[short] * ptr[short];
  proc gsl_matrix_short_minmax_index: cptr[gsl_matrix_short] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_short_set: ptr[gsl_matrix_short] * size * size * short;
  proc gsl_matrix_short_set_all: ptr[gsl_matrix_short] * short;
  proc gsl_matrix_short_set_identity: ptr[gsl_matrix_short];
  proc gsl_matrix_short_set_zero: ptr[gsl_matrix_short];
  
  //FUNCTIONS
  fun gsl_matrix_short_add: ptr[gsl_matrix_short] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_add_constant: ptr[gsl_matrix_short] * double -> int;
  fun gsl_matrix_short_add_diagonal: ptr[gsl_matrix_short] * double -> int;
  fun gsl_matrix_short_alloc: size * size -> ptr[gsl_matrix_short];
  fun gsl_matrix_short_alloc_from_block: ptr[gsl_block_short] * size * size * size * size -> ptr[gsl_matrix_short];
  fun gsl_matrix_short_alloc_from_matrix: ptr[gsl_matrix_short] * size * size * size * size -> ptr[gsl_matrix_short];
  fun gsl_matrix_short_calloc: size * size -> ptr[gsl_matrix_short];
  fun gsl_matrix_short_column: ptr[gsl_matrix_short] * size -> _gsl_vector_short_view;
  fun gsl_matrix_short_const_column: cptr[gsl_matrix_short] * size -> _gsl_vector_short_const_view;
  fun gsl_matrix_short_const_diagonal: cptr[gsl_matrix_short] -> _gsl_vector_short_const_view;
  fun gsl_matrix_short_const_ptr: cptr[gsl_matrix_short] * size * size -> cptr[short];
  fun gsl_matrix_short_const_row: cptr[gsl_matrix_short] * size -> _gsl_vector_short_const_view;
  fun gsl_matrix_short_const_subdiagonal: cptr[gsl_matrix_short] * size -> _gsl_vector_short_const_view;
  fun gsl_matrix_short_const_submatrix: cptr[gsl_matrix_short] * size * size * size * size -> _gsl_matrix_short_const_view;
  fun gsl_matrix_short_const_superdiagonal: cptr[gsl_matrix_short] * size -> _gsl_vector_short_const_view;
  fun gsl_matrix_short_const_view_array: cptr[short] * size * size -> _gsl_matrix_short_const_view;
  fun gsl_matrix_short_const_view_array_with_tda: cptr[short] * size * size * size -> _gsl_matrix_short_const_view;
  fun gsl_matrix_short_const_view_vector: cptr[gsl_vector_short] * size * size -> _gsl_matrix_short_const_view;
  fun gsl_matrix_short_const_view_vector_with_tda: cptr[gsl_vector_short] * size * size * size -> _gsl_matrix_short_const_view;
  fun gsl_matrix_short_diagonal: ptr[gsl_matrix_short] -> _gsl_vector_short_view;
  fun gsl_matrix_short_div_elements: ptr[gsl_matrix_short] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_fprintf: ptr[FILE] * cptr[gsl_matrix_short] * cptr[char] -> int;
  fun gsl_matrix_short_fread: ptr[FILE] * ptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_fscanf: ptr[FILE] * ptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_fwrite: ptr[FILE] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_get: cptr[gsl_matrix_short] * size * size -> short;
  fun gsl_matrix_short_get_col: ptr[gsl_vector_short] * cptr[gsl_matrix_short] * size -> int;
  fun gsl_matrix_short_get_row: ptr[gsl_vector_short] * cptr[gsl_matrix_short] * size -> int;
  fun gsl_matrix_short_isnull: cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_max: cptr[gsl_matrix_short] -> short;
  fun gsl_matrix_short_memcpy: ptr[gsl_matrix_short] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_min: cptr[gsl_matrix_short] -> short;
  fun gsl_matrix_short_mul_elements: ptr[gsl_matrix_short] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_ptr: ptr[gsl_matrix_short] * size * size -> ptr[short];
  fun gsl_matrix_short_row: ptr[gsl_matrix_short] * size -> _gsl_vector_short_view;
  fun gsl_matrix_short_scale: ptr[gsl_matrix_short] * double -> int;
  fun gsl_matrix_short_set_col: ptr[gsl_matrix_short] * size * cptr[gsl_vector_short] -> int;
  fun gsl_matrix_short_set_row: ptr[gsl_matrix_short] * size * cptr[gsl_vector_short] -> int;
  fun gsl_matrix_short_sub: ptr[gsl_matrix_short] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_subdiagonal: ptr[gsl_matrix_short] * size -> _gsl_vector_short_view;
  fun gsl_matrix_short_submatrix: ptr[gsl_matrix_short] * size * size * size * size -> _gsl_matrix_short_view;
  fun gsl_matrix_short_superdiagonal: ptr[gsl_matrix_short] * size -> _gsl_vector_short_view;
  fun gsl_matrix_short_swap: ptr[gsl_matrix_short] * ptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_swap_columns: ptr[gsl_matrix_short] * size * size -> int;
  fun gsl_matrix_short_swap_rowcol: ptr[gsl_matrix_short] * size * size -> int;
  fun gsl_matrix_short_swap_rows: ptr[gsl_matrix_short] * size * size -> int;
  fun gsl_matrix_short_transpose: ptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_transpose_memcpy: ptr[gsl_matrix_short] * cptr[gsl_matrix_short] -> int;
  fun gsl_matrix_short_view_array: ptr[short] * size * size -> _gsl_matrix_short_view;
  fun gsl_matrix_short_view_array_with_tda: ptr[short] * size * size * size -> _gsl_matrix_short_view;
  fun gsl_matrix_short_view_vector: ptr[gsl_vector_short] * size * size -> _gsl_matrix_short_view;
  fun gsl_matrix_short_view_vector_with_tda: ptr[gsl_vector_short] * size * size * size -> _gsl_matrix_short_view;
  fun gsl_vector_short_alloc_col_from_matrix: ptr[gsl_matrix_short] * size -> ptr[gsl_vector_short];
  fun gsl_vector_short_alloc_row_from_matrix: ptr[gsl_matrix_short] * size -> ptr[gsl_vector_short];
}
@h=tangler('lib/gsl/gsl_matrix_uchar_lib.flx')
@select(h)
//Module        : gsl_matrix_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_UCHAR_H__
header '#include "gsl_matrix_uchar.h"';

//INCLUDES
include "gsl_block_uchar_lib";
include "gsl_vector_uchar_lib";

module gsl_matrix_uchar_h
{
  open C_hack;
  open gsl_block_uchar_h;
  open gsl_vector_uchar_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_uchar = 'gsl_matrix_uchar';
  type _gsl_matrix_uchar_const_view = '_gsl_matrix_uchar_const_view';
  type _gsl_matrix_uchar_view = '_gsl_matrix_uchar_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_uchar_const_view = _gsl_matrix_uchar_const_view;
  typedef gsl_matrix_uchar_view = _gsl_matrix_uchar_view;
  
  //PROCEDURES
  proc gsl_matrix_uchar_free: ptr[gsl_matrix_uchar];
  proc gsl_matrix_uchar_max_index: cptr[gsl_matrix_uchar] * ptr[size] * ptr[size];
  proc gsl_matrix_uchar_min_index: cptr[gsl_matrix_uchar] * ptr[size] * ptr[size];
  proc gsl_matrix_uchar_minmax: cptr[gsl_matrix_uchar] * ptr[utiny] * ptr[utiny];
  proc gsl_matrix_uchar_minmax_index: cptr[gsl_matrix_uchar] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_uchar_set: ptr[gsl_matrix_uchar] * size * size * utiny;
  proc gsl_matrix_uchar_set_all: ptr[gsl_matrix_uchar] * utiny;
  proc gsl_matrix_uchar_set_identity: ptr[gsl_matrix_uchar];
  proc gsl_matrix_uchar_set_zero: ptr[gsl_matrix_uchar];
  
  //FUNCTIONS
  fun gsl_matrix_uchar_add: ptr[gsl_matrix_uchar] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_add_constant: ptr[gsl_matrix_uchar] * double -> int;
  fun gsl_matrix_uchar_add_diagonal: ptr[gsl_matrix_uchar] * double -> int;
  fun gsl_matrix_uchar_alloc: size * size -> ptr[gsl_matrix_uchar];
  fun gsl_matrix_uchar_alloc_from_block: ptr[gsl_block_uchar] * size * size * size * size -> ptr[gsl_matrix_uchar];
  fun gsl_matrix_uchar_alloc_from_matrix: ptr[gsl_matrix_uchar] * size * size * size * size -> ptr[gsl_matrix_uchar];
  fun gsl_matrix_uchar_calloc: size * size -> ptr[gsl_matrix_uchar];
  fun gsl_matrix_uchar_column: ptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_view;
  fun gsl_matrix_uchar_const_column: cptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_const_view;
  fun gsl_matrix_uchar_const_diagonal: cptr[gsl_matrix_uchar] -> _gsl_vector_uchar_const_view;
  fun gsl_matrix_uchar_const_ptr: cptr[gsl_matrix_uchar] * size * size -> cptr[utiny];
  fun gsl_matrix_uchar_const_row: cptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_const_view;
  fun gsl_matrix_uchar_const_subdiagonal: cptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_const_view;
  fun gsl_matrix_uchar_const_submatrix: cptr[gsl_matrix_uchar] * size * size * size * size -> _gsl_matrix_uchar_const_view;
  fun gsl_matrix_uchar_const_superdiagonal: cptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_const_view;
  fun gsl_matrix_uchar_const_view_array: cptr[utiny] * size * size -> _gsl_matrix_uchar_const_view;
  fun gsl_matrix_uchar_const_view_array_with_tda: cptr[utiny] * size * size * size -> _gsl_matrix_uchar_const_view;
  fun gsl_matrix_uchar_const_view_vector: cptr[gsl_vector_uchar] * size * size -> _gsl_matrix_uchar_const_view;
  fun gsl_matrix_uchar_const_view_vector_with_tda: cptr[gsl_vector_uchar] * size * size * size -> _gsl_matrix_uchar_const_view;
  fun gsl_matrix_uchar_diagonal: ptr[gsl_matrix_uchar] -> _gsl_vector_uchar_view;
  fun gsl_matrix_uchar_div_elements: ptr[gsl_matrix_uchar] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_fprintf: ptr[FILE] * cptr[gsl_matrix_uchar] * cptr[char] -> int;
  fun gsl_matrix_uchar_fread: ptr[FILE] * ptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_fscanf: ptr[FILE] * ptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_fwrite: ptr[FILE] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_get: cptr[gsl_matrix_uchar] * size * size -> utiny;
  fun gsl_matrix_uchar_get_col: ptr[gsl_vector_uchar] * cptr[gsl_matrix_uchar] * size -> int;
  fun gsl_matrix_uchar_get_row: ptr[gsl_vector_uchar] * cptr[gsl_matrix_uchar] * size -> int;
  fun gsl_matrix_uchar_isnull: cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_max: cptr[gsl_matrix_uchar] -> utiny;
  fun gsl_matrix_uchar_memcpy: ptr[gsl_matrix_uchar] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_min: cptr[gsl_matrix_uchar] -> utiny;
  fun gsl_matrix_uchar_mul_elements: ptr[gsl_matrix_uchar] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_ptr: ptr[gsl_matrix_uchar] * size * size -> ptr[utiny];
  fun gsl_matrix_uchar_row: ptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_view;
  fun gsl_matrix_uchar_scale: ptr[gsl_matrix_uchar] * double -> int;
  fun gsl_matrix_uchar_set_col: ptr[gsl_matrix_uchar] * size * cptr[gsl_vector_uchar] -> int;
  fun gsl_matrix_uchar_set_row: ptr[gsl_matrix_uchar] * size * cptr[gsl_vector_uchar] -> int;
  fun gsl_matrix_uchar_sub: ptr[gsl_matrix_uchar] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_subdiagonal: ptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_view;
  fun gsl_matrix_uchar_submatrix: ptr[gsl_matrix_uchar] * size * size * size * size -> _gsl_matrix_uchar_view;
  fun gsl_matrix_uchar_superdiagonal: ptr[gsl_matrix_uchar] * size -> _gsl_vector_uchar_view;
  fun gsl_matrix_uchar_swap: ptr[gsl_matrix_uchar] * ptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_swap_columns: ptr[gsl_matrix_uchar] * size * size -> int;
  fun gsl_matrix_uchar_swap_rowcol: ptr[gsl_matrix_uchar] * size * size -> int;
  fun gsl_matrix_uchar_swap_rows: ptr[gsl_matrix_uchar] * size * size -> int;
  fun gsl_matrix_uchar_transpose: ptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_transpose_memcpy: ptr[gsl_matrix_uchar] * cptr[gsl_matrix_uchar] -> int;
  fun gsl_matrix_uchar_view_array: ptr[utiny] * size * size -> _gsl_matrix_uchar_view;
  fun gsl_matrix_uchar_view_array_with_tda: ptr[utiny] * size * size * size -> _gsl_matrix_uchar_view;
  fun gsl_matrix_uchar_view_vector: ptr[gsl_vector_uchar] * size * size -> _gsl_matrix_uchar_view;
  fun gsl_matrix_uchar_view_vector_with_tda: ptr[gsl_vector_uchar] * size * size * size -> _gsl_matrix_uchar_view;
  fun gsl_vector_uchar_alloc_col_from_matrix: ptr[gsl_matrix_uchar] * size -> ptr[gsl_vector_uchar];
  fun gsl_vector_uchar_alloc_row_from_matrix: ptr[gsl_matrix_uchar] * size -> ptr[gsl_vector_uchar];
}
@h=tangler('lib/gsl/gsl_matrix_uint_lib.flx')
@select(h)
//Module        : gsl_matrix_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_UINT_H__
header '#include "gsl_matrix_uint.h"';

//INCLUDES
include "gsl_block_uint_lib";
include "gsl_vector_uint_lib";

module gsl_matrix_uint_h
{
  open C_hack;
  open gsl_block_uint_h;
  open gsl_vector_uint_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_uint = 'gsl_matrix_uint';
  type _gsl_matrix_uint_const_view = '_gsl_matrix_uint_const_view';
  type _gsl_matrix_uint_view = '_gsl_matrix_uint_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_uint_view = _gsl_matrix_uint_view;
  typedef gsl_matrix_uint_const_view = _gsl_matrix_uint_const_view;
  
  //PROCEDURES
  proc gsl_matrix_uint_free: ptr[gsl_matrix_uint];
  proc gsl_matrix_uint_max_index: cptr[gsl_matrix_uint] * ptr[size] * ptr[size];
  proc gsl_matrix_uint_min_index: cptr[gsl_matrix_uint] * ptr[size] * ptr[size];
  proc gsl_matrix_uint_minmax: cptr[gsl_matrix_uint] * ptr[uint] * ptr[uint];
  proc gsl_matrix_uint_minmax_index: cptr[gsl_matrix_uint] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_uint_set: ptr[gsl_matrix_uint] * size * size * uint;
  proc gsl_matrix_uint_set_all: ptr[gsl_matrix_uint] * uint;
  proc gsl_matrix_uint_set_identity: ptr[gsl_matrix_uint];
  proc gsl_matrix_uint_set_zero: ptr[gsl_matrix_uint];
  
  //FUNCTIONS
  fun gsl_matrix_uint_add: ptr[gsl_matrix_uint] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_add_constant: ptr[gsl_matrix_uint] * double -> int;
  fun gsl_matrix_uint_add_diagonal: ptr[gsl_matrix_uint] * double -> int;
  fun gsl_matrix_uint_alloc: size * size -> ptr[gsl_matrix_uint];
  fun gsl_matrix_uint_alloc_from_block: ptr[gsl_block_uint] * size * size * size * size -> ptr[gsl_matrix_uint];
  fun gsl_matrix_uint_alloc_from_matrix: ptr[gsl_matrix_uint] * size * size * size * size -> ptr[gsl_matrix_uint];
  fun gsl_matrix_uint_calloc: size * size -> ptr[gsl_matrix_uint];
  fun gsl_matrix_uint_column: ptr[gsl_matrix_uint] * size -> _gsl_vector_uint_view;
  fun gsl_matrix_uint_const_column: cptr[gsl_matrix_uint] * size -> _gsl_vector_uint_const_view;
  fun gsl_matrix_uint_const_diagonal: cptr[gsl_matrix_uint] -> _gsl_vector_uint_const_view;
  fun gsl_matrix_uint_const_ptr: cptr[gsl_matrix_uint] * size * size -> cptr[uint];
  fun gsl_matrix_uint_const_row: cptr[gsl_matrix_uint] * size -> _gsl_vector_uint_const_view;
  fun gsl_matrix_uint_const_subdiagonal: cptr[gsl_matrix_uint] * size -> _gsl_vector_uint_const_view;
  fun gsl_matrix_uint_const_submatrix: cptr[gsl_matrix_uint] * size * size * size * size -> _gsl_matrix_uint_const_view;
  fun gsl_matrix_uint_const_superdiagonal: cptr[gsl_matrix_uint] * size -> _gsl_vector_uint_const_view;
  fun gsl_matrix_uint_const_view_array: cptr[uint] * size * size -> _gsl_matrix_uint_const_view;
  fun gsl_matrix_uint_const_view_array_with_tda: cptr[uint] * size * size * size -> _gsl_matrix_uint_const_view;
  fun gsl_matrix_uint_const_view_vector: cptr[gsl_vector_uint] * size * size -> _gsl_matrix_uint_const_view;
  fun gsl_matrix_uint_const_view_vector_with_tda: cptr[gsl_vector_uint] * size * size * size -> _gsl_matrix_uint_const_view;
  fun gsl_matrix_uint_diagonal: ptr[gsl_matrix_uint] -> _gsl_vector_uint_view;
  fun gsl_matrix_uint_div_elements: ptr[gsl_matrix_uint] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_fprintf: ptr[FILE] * cptr[gsl_matrix_uint] * cptr[char] -> int;
  fun gsl_matrix_uint_fread: ptr[FILE] * ptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_fscanf: ptr[FILE] * ptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_fwrite: ptr[FILE] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_get: cptr[gsl_matrix_uint] * size * size -> uint;
  fun gsl_matrix_uint_get_col: ptr[gsl_vector_uint] * cptr[gsl_matrix_uint] * size -> int;
  fun gsl_matrix_uint_get_row: ptr[gsl_vector_uint] * cptr[gsl_matrix_uint] * size -> int;
  fun gsl_matrix_uint_isnull: cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_max: cptr[gsl_matrix_uint] -> uint;
  fun gsl_matrix_uint_memcpy: ptr[gsl_matrix_uint] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_min: cptr[gsl_matrix_uint] -> uint;
  fun gsl_matrix_uint_mul_elements: ptr[gsl_matrix_uint] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_ptr: ptr[gsl_matrix_uint] * size * size -> ptr[uint];
  fun gsl_matrix_uint_row: ptr[gsl_matrix_uint] * size -> _gsl_vector_uint_view;
  fun gsl_matrix_uint_scale: ptr[gsl_matrix_uint] * double -> int;
  fun gsl_matrix_uint_set_col: ptr[gsl_matrix_uint] * size * cptr[gsl_vector_uint] -> int;
  fun gsl_matrix_uint_set_row: ptr[gsl_matrix_uint] * size * cptr[gsl_vector_uint] -> int;
  fun gsl_matrix_uint_sub: ptr[gsl_matrix_uint] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_subdiagonal: ptr[gsl_matrix_uint] * size -> _gsl_vector_uint_view;
  fun gsl_matrix_uint_submatrix: ptr[gsl_matrix_uint] * size * size * size * size -> _gsl_matrix_uint_view;
  fun gsl_matrix_uint_superdiagonal: ptr[gsl_matrix_uint] * size -> _gsl_vector_uint_view;
  fun gsl_matrix_uint_swap: ptr[gsl_matrix_uint] * ptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_swap_columns: ptr[gsl_matrix_uint] * size * size -> int;
  fun gsl_matrix_uint_swap_rowcol: ptr[gsl_matrix_uint] * size * size -> int;
  fun gsl_matrix_uint_swap_rows: ptr[gsl_matrix_uint] * size * size -> int;
  fun gsl_matrix_uint_transpose: ptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_transpose_memcpy: ptr[gsl_matrix_uint] * cptr[gsl_matrix_uint] -> int;
  fun gsl_matrix_uint_view_array: ptr[uint] * size * size -> _gsl_matrix_uint_view;
  fun gsl_matrix_uint_view_array_with_tda: ptr[uint] * size * size * size -> _gsl_matrix_uint_view;
  fun gsl_matrix_uint_view_vector: ptr[gsl_vector_uint] * size * size -> _gsl_matrix_uint_view;
  fun gsl_matrix_uint_view_vector_with_tda: ptr[gsl_vector_uint] * size * size * size -> _gsl_matrix_uint_view;
  fun gsl_vector_uint_alloc_col_from_matrix: ptr[gsl_matrix_uint] * size -> ptr[gsl_vector_uint];
  fun gsl_vector_uint_alloc_row_from_matrix: ptr[gsl_matrix_uint] * size -> ptr[gsl_vector_uint];
}
@h=tangler('lib/gsl/gsl_matrix_ulong_lib.flx')
@select(h)
//Module        : gsl_matrix_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_ULONG_H__
header '#include "gsl_matrix_ulong.h"';

//INCLUDES
include "gsl_block_ulong_lib";
include "gsl_vector_ulong_lib";

module gsl_matrix_ulong_h
{
  open C_hack;
  open gsl_block_ulong_h;
  open gsl_vector_ulong_h;
  
  //ABSTRACT TYPES
  type gsl_matrix_ulong = 'gsl_matrix_ulong';
  type _gsl_matrix_ulong_const_view = '_gsl_matrix_ulong_const_view';
  type _gsl_matrix_ulong_view = '_gsl_matrix_ulong_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_ulong_const_view = _gsl_matrix_ulong_const_view;
  typedef gsl_matrix_ulong_view = _gsl_matrix_ulong_view;
  
  //PROCEDURES
  proc gsl_matrix_ulong_free: ptr[gsl_matrix_ulong];
  proc gsl_matrix_ulong_max_index: cptr[gsl_matrix_ulong] * ptr[size] * ptr[size];
  proc gsl_matrix_ulong_min_index: cptr[gsl_matrix_ulong] * ptr[size] * ptr[size];
  proc gsl_matrix_ulong_minmax: cptr[gsl_matrix_ulong] * ptr[ulong] * ptr[ulong];
  proc gsl_matrix_ulong_minmax_index: cptr[gsl_matrix_ulong] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_ulong_set: ptr[gsl_matrix_ulong] * size * size * ulong;
  proc gsl_matrix_ulong_set_all: ptr[gsl_matrix_ulong] * ulong;
  proc gsl_matrix_ulong_set_identity: ptr[gsl_matrix_ulong];
  proc gsl_matrix_ulong_set_zero: ptr[gsl_matrix_ulong];
  
  //FUNCTIONS
  fun gsl_matrix_ulong_add: ptr[gsl_matrix_ulong] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_add_constant: ptr[gsl_matrix_ulong] * double -> int;
  fun gsl_matrix_ulong_add_diagonal: ptr[gsl_matrix_ulong] * double -> int;
  fun gsl_matrix_ulong_alloc: size * size -> ptr[gsl_matrix_ulong];
  fun gsl_matrix_ulong_alloc_from_block: ptr[gsl_block_ulong] * size * size * size * size -> ptr[gsl_matrix_ulong];
  fun gsl_matrix_ulong_alloc_from_matrix: ptr[gsl_matrix_ulong] * size * size * size * size -> ptr[gsl_matrix_ulong];
  fun gsl_matrix_ulong_calloc: size * size -> ptr[gsl_matrix_ulong];
  fun gsl_matrix_ulong_column: ptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_view;
  fun gsl_matrix_ulong_const_column: cptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_const_view;
  fun gsl_matrix_ulong_const_diagonal: cptr[gsl_matrix_ulong] -> _gsl_vector_ulong_const_view;
  fun gsl_matrix_ulong_const_ptr: cptr[gsl_matrix_ulong] * size * size -> cptr[ulong];
  fun gsl_matrix_ulong_const_row: cptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_const_view;
  fun gsl_matrix_ulong_const_subdiagonal: cptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_const_view;
  fun gsl_matrix_ulong_const_submatrix: cptr[gsl_matrix_ulong] * size * size * size * size -> _gsl_matrix_ulong_const_view;
  fun gsl_matrix_ulong_const_superdiagonal: cptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_const_view;
  fun gsl_matrix_ulong_const_view_array: cptr[ulong] * size * size -> _gsl_matrix_ulong_const_view;
  fun gsl_matrix_ulong_const_view_array_with_tda: cptr[ulong] * size * size * size -> _gsl_matrix_ulong_const_view;
  fun gsl_matrix_ulong_const_view_vector: cptr[gsl_vector_ulong] * size * size -> _gsl_matrix_ulong_const_view;
  fun gsl_matrix_ulong_const_view_vector_with_tda: cptr[gsl_vector_ulong] * size * size * size -> _gsl_matrix_ulong_const_view;
  fun gsl_matrix_ulong_diagonal: ptr[gsl_matrix_ulong] -> _gsl_vector_ulong_view;
  fun gsl_matrix_ulong_div_elements: ptr[gsl_matrix_ulong] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_fprintf: ptr[FILE] * cptr[gsl_matrix_ulong] * cptr[char] -> int;
  fun gsl_matrix_ulong_fread: ptr[FILE] * ptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_fscanf: ptr[FILE] * ptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_fwrite: ptr[FILE] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_get: cptr[gsl_matrix_ulong] * size * size -> ulong;
  fun gsl_matrix_ulong_get_col: ptr[gsl_vector_ulong] * cptr[gsl_matrix_ulong] * size -> int;
  fun gsl_matrix_ulong_get_row: ptr[gsl_vector_ulong] * cptr[gsl_matrix_ulong] * size -> int;
  fun gsl_matrix_ulong_isnull: cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_max: cptr[gsl_matrix_ulong] -> ulong;
  fun gsl_matrix_ulong_memcpy: ptr[gsl_matrix_ulong] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_min: cptr[gsl_matrix_ulong] -> ulong;
  fun gsl_matrix_ulong_mul_elements: ptr[gsl_matrix_ulong] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_ptr: ptr[gsl_matrix_ulong] * size * size -> ptr[ulong];
  fun gsl_matrix_ulong_row: ptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_view;
  fun gsl_matrix_ulong_scale: ptr[gsl_matrix_ulong] * double -> int;
  fun gsl_matrix_ulong_set_col: ptr[gsl_matrix_ulong] * size * cptr[gsl_vector_ulong] -> int;
  fun gsl_matrix_ulong_set_row: ptr[gsl_matrix_ulong] * size * cptr[gsl_vector_ulong] -> int;
  fun gsl_matrix_ulong_sub: ptr[gsl_matrix_ulong] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_subdiagonal: ptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_view;
  fun gsl_matrix_ulong_submatrix: ptr[gsl_matrix_ulong] * size * size * size * size -> _gsl_matrix_ulong_view;
  fun gsl_matrix_ulong_superdiagonal: ptr[gsl_matrix_ulong] * size -> _gsl_vector_ulong_view;
  fun gsl_matrix_ulong_swap: ptr[gsl_matrix_ulong] * ptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_swap_columns: ptr[gsl_matrix_ulong] * size * size -> int;
  fun gsl_matrix_ulong_swap_rowcol: ptr[gsl_matrix_ulong] * size * size -> int;
  fun gsl_matrix_ulong_swap_rows: ptr[gsl_matrix_ulong] * size * size -> int;
  fun gsl_matrix_ulong_transpose: ptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_transpose_memcpy: ptr[gsl_matrix_ulong] * cptr[gsl_matrix_ulong] -> int;
  fun gsl_matrix_ulong_view_array: ptr[ulong] * size * size -> _gsl_matrix_ulong_view;
  fun gsl_matrix_ulong_view_array_with_tda: ptr[ulong] * size * size * size -> _gsl_matrix_ulong_view;
  fun gsl_matrix_ulong_view_vector: ptr[gsl_vector_ulong] * size * size -> _gsl_matrix_ulong_view;
  fun gsl_matrix_ulong_view_vector_with_tda: ptr[gsl_vector_ulong] * size * size * size -> _gsl_matrix_ulong_view;
  fun gsl_vector_ulong_alloc_col_from_matrix: ptr[gsl_matrix_ulong] * size -> ptr[gsl_vector_ulong];
  fun gsl_vector_ulong_alloc_row_from_matrix: ptr[gsl_matrix_ulong] * size -> ptr[gsl_vector_ulong];
}
@h=tangler('lib/gsl/gsl_matrix_ushort_lib.flx')
@select(h)
//Module        : gsl_matrix_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_matrix_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MATRIX_USHORT_H__
header '#include "gsl_matrix_ushort.h"';

//INCLUDES
include "gsl_block_ushort_lib";
include "gsl_vector_ushort_lib";

module gsl_matrix_ushort_h
{
  open C_hack;
  open gsl_block_ushort_h;
  open gsl_vector_ushort_h;
  
  //ABSTRACT TYPES
  type _gsl_matrix_ushort_const_view = '_gsl_matrix_ushort_const_view';
  type gsl_matrix_ushort = 'gsl_matrix_ushort';
  type _gsl_matrix_ushort_view = '_gsl_matrix_ushort_view';
  
  //TYPE ALIASES
  typedef gsl_matrix_ushort_const_view = _gsl_matrix_ushort_const_view;
  typedef gsl_matrix_ushort_view = _gsl_matrix_ushort_view;
  
  //PROCEDURES
  proc gsl_matrix_ushort_free: ptr[gsl_matrix_ushort];
  proc gsl_matrix_ushort_max_index: cptr[gsl_matrix_ushort] * ptr[size] * ptr[size];
  proc gsl_matrix_ushort_min_index: cptr[gsl_matrix_ushort] * ptr[size] * ptr[size];
  proc gsl_matrix_ushort_minmax: cptr[gsl_matrix_ushort] * ptr[ushort] * ptr[ushort];
  proc gsl_matrix_ushort_minmax_index: cptr[gsl_matrix_ushort] * ptr[size] * ptr[size] * ptr[size] * ptr[size];
  proc gsl_matrix_ushort_set: ptr[gsl_matrix_ushort] * size * size * ushort;
  proc gsl_matrix_ushort_set_all: ptr[gsl_matrix_ushort] * ushort;
  proc gsl_matrix_ushort_set_identity: ptr[gsl_matrix_ushort];
  proc gsl_matrix_ushort_set_zero: ptr[gsl_matrix_ushort];
  
  //FUNCTIONS
  fun gsl_matrix_ushort_add: ptr[gsl_matrix_ushort] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_add_constant: ptr[gsl_matrix_ushort] * double -> int;
  fun gsl_matrix_ushort_add_diagonal: ptr[gsl_matrix_ushort] * double -> int;
  fun gsl_matrix_ushort_alloc: size * size -> ptr[gsl_matrix_ushort];
  fun gsl_matrix_ushort_alloc_from_block: ptr[gsl_block_ushort] * size * size * size * size -> ptr[gsl_matrix_ushort];
  fun gsl_matrix_ushort_alloc_from_matrix: ptr[gsl_matrix_ushort] * size * size * size * size -> ptr[gsl_matrix_ushort];
  fun gsl_matrix_ushort_calloc: size * size -> ptr[gsl_matrix_ushort];
  fun gsl_matrix_ushort_column: ptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_view;
  fun gsl_matrix_ushort_const_column: cptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_const_view;
  fun gsl_matrix_ushort_const_diagonal: cptr[gsl_matrix_ushort] -> _gsl_vector_ushort_const_view;
  fun gsl_matrix_ushort_const_ptr: cptr[gsl_matrix_ushort] * size * size -> cptr[ushort];
  fun gsl_matrix_ushort_const_row: cptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_const_view;
  fun gsl_matrix_ushort_const_subdiagonal: cptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_const_view;
  fun gsl_matrix_ushort_const_submatrix: cptr[gsl_matrix_ushort] * size * size * size * size -> _gsl_matrix_ushort_const_view;
  fun gsl_matrix_ushort_const_superdiagonal: cptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_const_view;
  fun gsl_matrix_ushort_const_view_array: cptr[ushort] * size * size -> _gsl_matrix_ushort_const_view;
  fun gsl_matrix_ushort_const_view_array_with_tda: cptr[ushort] * size * size * size -> _gsl_matrix_ushort_const_view;
  fun gsl_matrix_ushort_const_view_vector: cptr[gsl_vector_ushort] * size * size -> _gsl_matrix_ushort_const_view;
  fun gsl_matrix_ushort_const_view_vector_with_tda: cptr[gsl_vector_ushort] * size * size * size -> _gsl_matrix_ushort_const_view;
  fun gsl_matrix_ushort_diagonal: ptr[gsl_matrix_ushort] -> _gsl_vector_ushort_view;
  fun gsl_matrix_ushort_div_elements: ptr[gsl_matrix_ushort] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_fprintf: ptr[FILE] * cptr[gsl_matrix_ushort] * cptr[char] -> int;
  fun gsl_matrix_ushort_fread: ptr[FILE] * ptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_fscanf: ptr[FILE] * ptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_fwrite: ptr[FILE] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_get: cptr[gsl_matrix_ushort] * size * size -> ushort;
  fun gsl_matrix_ushort_get_col: ptr[gsl_vector_ushort] * cptr[gsl_matrix_ushort] * size -> int;
  fun gsl_matrix_ushort_get_row: ptr[gsl_vector_ushort] * cptr[gsl_matrix_ushort] * size -> int;
  fun gsl_matrix_ushort_isnull: cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_max: cptr[gsl_matrix_ushort] -> ushort;
  fun gsl_matrix_ushort_memcpy: ptr[gsl_matrix_ushort] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_min: cptr[gsl_matrix_ushort] -> ushort;
  fun gsl_matrix_ushort_mul_elements: ptr[gsl_matrix_ushort] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_ptr: ptr[gsl_matrix_ushort] * size * size -> ptr[ushort];
  fun gsl_matrix_ushort_row: ptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_view;
  fun gsl_matrix_ushort_scale: ptr[gsl_matrix_ushort] * double -> int;
  fun gsl_matrix_ushort_set_col: ptr[gsl_matrix_ushort] * size * cptr[gsl_vector_ushort] -> int;
  fun gsl_matrix_ushort_set_row: ptr[gsl_matrix_ushort] * size * cptr[gsl_vector_ushort] -> int;
  fun gsl_matrix_ushort_sub: ptr[gsl_matrix_ushort] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_subdiagonal: ptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_view;
  fun gsl_matrix_ushort_submatrix: ptr[gsl_matrix_ushort] * size * size * size * size -> _gsl_matrix_ushort_view;
  fun gsl_matrix_ushort_superdiagonal: ptr[gsl_matrix_ushort] * size -> _gsl_vector_ushort_view;
  fun gsl_matrix_ushort_swap: ptr[gsl_matrix_ushort] * ptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_swap_columns: ptr[gsl_matrix_ushort] * size * size -> int;
  fun gsl_matrix_ushort_swap_rowcol: ptr[gsl_matrix_ushort] * size * size -> int;
  fun gsl_matrix_ushort_swap_rows: ptr[gsl_matrix_ushort] * size * size -> int;
  fun gsl_matrix_ushort_transpose: ptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_transpose_memcpy: ptr[gsl_matrix_ushort] * cptr[gsl_matrix_ushort] -> int;
  fun gsl_matrix_ushort_view_array: ptr[ushort] * size * size -> _gsl_matrix_ushort_view;
  fun gsl_matrix_ushort_view_array_with_tda: ptr[ushort] * size * size * size -> _gsl_matrix_ushort_view;
  fun gsl_matrix_ushort_view_vector: ptr[gsl_vector_ushort] * size * size -> _gsl_matrix_ushort_view;
  fun gsl_matrix_ushort_view_vector_with_tda: ptr[gsl_vector_ushort] * size * size * size -> _gsl_matrix_ushort_view;
  fun gsl_vector_ushort_alloc_col_from_matrix: ptr[gsl_matrix_ushort] * size -> ptr[gsl_vector_ushort];
  fun gsl_vector_ushort_alloc_row_from_matrix: ptr[gsl_matrix_ushort] * size -> ptr[gsl_vector_ushort];
}
@h=tangler('lib/gsl/gsl_message_lib.flx')
@select(h)
//Module        : gsl_message_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_message.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_MESSAGE(message, mask) \
//#define GSL_MESSAGE(message, mask) do { } while(0)
//#define GSL_MESSAGE_MASK 0xffffffffu /* default all messages allowed */
//#define __GSL_MESSAGE_H__
header '#include "gsl_message.h"';

module gsl_message_h
{
  open C_hack;
  
  //VARIABLES
  const gsl_message_mask: uint = 'gsl_message_mask';
  
  //ENUMERATION CONSTANTS
  const GSL_MESSAGE_MASK_A: int = 'GSL_MESSAGE_MASK_A';
  const GSL_MESSAGE_MASK_B: int = 'GSL_MESSAGE_MASK_B';
  const GSL_MESSAGE_MASK_C: int = 'GSL_MESSAGE_MASK_C';
  const GSL_MESSAGE_MASK_D: int = 'GSL_MESSAGE_MASK_D';
  const GSL_MESSAGE_MASK_E: int = 'GSL_MESSAGE_MASK_E';
  const GSL_MESSAGE_MASK_F: int = 'GSL_MESSAGE_MASK_F';
  const GSL_MESSAGE_MASK_G: int = 'GSL_MESSAGE_MASK_G';
  const GSL_MESSAGE_MASK_H: int = 'GSL_MESSAGE_MASK_H';
  
  //PROCEDURES
  proc gsl_message: cptr[char] * cptr[char] * int * uint;
}
@h=tangler('lib/gsl/gsl_min_lib.flx')
@select(h)
//Module        : gsl_min_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_min.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MIN_H__
header '#include "gsl_min.h"';

//INCLUDES
include "gsl_math_lib";

module gsl_min_h
{
  open C_hack;
  open gsl_math_h;
  
  //ABSTRACT TYPES
  type gsl_min_fminimizer = 'gsl_min_fminimizer';
  type gsl_min_fminimizer_type = 'gsl_min_fminimizer_type';
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*gsl_min_h_cft_1)(gsl_function *, double *,  double *, double *, double *,  double *, double *, size_t);''';
  type gsl_min_h_cft_1 = 'gsl_min_h_cft_1';
  
  //TYPE ALIASES
  typedef gsl_min_bracketing_function = gsl_min_h_cft_1;
  
  //VARIABLES
  const gsl_min_fminimizer_brent: cptr[gsl_min_fminimizer_type] = 'gsl_min_fminimizer_brent';
  const gsl_min_fminimizer_goldensection: cptr[gsl_min_fminimizer_type] = 'gsl_min_fminimizer_goldensection';
  
  //PROCEDURES
  proc gsl_min_fminimizer_free: ptr[gsl_min_fminimizer];
  
  //FUNCTIONS
  fun gsl_min_find_bracket: ptr[gsl_function] * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] * size -> int;
  fun gsl_min_fminimizer_alloc: cptr[gsl_min_fminimizer_type] -> ptr[gsl_min_fminimizer];
  fun gsl_min_fminimizer_f_lower: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_fminimizer_f_minimum: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_fminimizer_f_upper: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_fminimizer_iterate: ptr[gsl_min_fminimizer] -> int;
  fun gsl_min_fminimizer_minimum: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_fminimizer_name: cptr[gsl_min_fminimizer] -> cptr[char];
  fun gsl_min_fminimizer_set: ptr[gsl_min_fminimizer] * ptr[gsl_function] * double * double * double -> int;
  fun gsl_min_fminimizer_set_with_values: ptr[gsl_min_fminimizer] * ptr[gsl_function] * double * double * double * double * double * double -> int;
  fun gsl_min_fminimizer_x_lower: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_fminimizer_x_minimum: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_fminimizer_x_upper: cptr[gsl_min_fminimizer] -> double;
  fun gsl_min_test_interval: double * double * double * double -> int;
}
@h=tangler('lib/gsl/gsl_mode_lib.flx')
@select(h)
//Module        : gsl_mode_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_mode.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_MODE_DEFAULT  0
//#define GSL_MODE_PREC(mt) ((mt) & (unsigned int)7)
//#define GSL_PREC_APPROX  2
//#define GSL_PREC_SINGLE  1
//#define GSL_PREC_DOUBLE  0
//#define __GSL_MODE_H__
header '#include "gsl_mode.h"';

module gsl_mode_h
{
  open C_hack;
  
  //TYPE ALIASES
  typedef gsl_mode_t = uint;
}
@h=tangler('lib/gsl/gsl_monte_function_struct_lib.flx')
@select(h)
//Module        : gsl_monte_function_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_monte_function_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_monte_function_struct"';

module gsl_monte_function_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_monte_lib.flx')
@select(h)
//Module        : gsl_monte_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_monte.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_MONTE_FN_EVAL(F,x) (*((F)->f))(x,(F)->dim,(F)->params)
//#define __GSL_MONTE_H__
header '#include "gsl_monte.h"';

//INCLUDES
include "gsl_monte_function_struct_lib";

module gsl_monte_h
{
  open C_hack;
  open gsl_monte_function_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_monte_function_struct {
    f: gsl_monte_h_cft_1;
    dim: size;
    params: address;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef double (*gsl_monte_h_cft_1)(double *, size_t, void *);''';
  type gsl_monte_h_cft_1 = 'gsl_monte_h_cft_1';
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_monte_function = gsl_monte_function_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_monte_function_struct = gsl_monte_function_struct;
}
@h=tangler('lib/gsl/gsl_monte_miser_lib.flx')
@select(h)
//Module        : gsl_monte_miser_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_monte_miser.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MONTE_MISER_H__
header '#include "gsl_monte_miser.h"';

//INCLUDES
include "gsl_monte_lib";
include "gsl_rng_lib";

module gsl_monte_miser_h
{
  open C_hack;
  open gsl_monte_h;
  open gsl_rng_h;
  
  //ABSTRACT TYPES
  type gsl_monte_miser_state = 'gsl_monte_miser_state';
  
  //PROCEDURES
  proc gsl_monte_miser_free: ptr[gsl_monte_miser_state];
  
  //FUNCTIONS
  fun gsl_monte_miser_alloc: size -> ptr[gsl_monte_miser_state];
  fun gsl_monte_miser_init: ptr[gsl_monte_miser_state] -> int;
  fun gsl_monte_miser_integrate: ptr[gsl_monte_function] * cptr[double] * cptr[double] * size * size * ptr[gsl_rng] * ptr[gsl_monte_miser_state] * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_monte_plain_lib.flx')
@select(h)
//Module        : gsl_monte_plain_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_monte_plain.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MONTE_PLAIN_H__
header '#include "gsl_monte_plain.h"';

//INCLUDES
include "gsl_monte_lib";
include "gsl_rng_lib";

module gsl_monte_plain_h
{
  open C_hack;
  open gsl_monte_h;
  open gsl_rng_h;
  
  //ABSTRACT TYPES
  type gsl_monte_plain_state = 'gsl_monte_plain_state';
  
  //PROCEDURES
  proc gsl_monte_plain_free: ptr[gsl_monte_plain_state];
  
  //FUNCTIONS
  fun gsl_monte_plain_alloc: size -> ptr[gsl_monte_plain_state];
  fun gsl_monte_plain_init: ptr[gsl_monte_plain_state] -> int;
  fun gsl_monte_plain_integrate: cptr[gsl_monte_function] * cptr[double] * cptr[double] * size * size * ptr[gsl_rng] * ptr[gsl_monte_plain_state] * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_monte_vegas_lib.flx')
@select(h)
//Module        : gsl_monte_vegas_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_monte_vegas.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MONTE_VEGAS_H__
header '#include "gsl_monte_vegas.h"';

//INCLUDES
include "gsl_monte_lib";
include "gsl_rng_lib";

module gsl_monte_vegas_h
{
  open C_hack;
  open gsl_monte_h;
  open gsl_rng_h;
  
  //ABSTRACT TYPES
  type gsl_monte_vegas_state = 'gsl_monte_vegas_state';
  
  //ENUMERATION CONSTANTS
  const GSL_VEGAS_MODE_IMPORTANCE: int = 'GSL_VEGAS_MODE_IMPORTANCE';
  const GSL_VEGAS_MODE_IMPORTANCE_ONLY: int = 'GSL_VEGAS_MODE_IMPORTANCE_ONLY';
  const GSL_VEGAS_MODE_STRATIFIED: int = 'GSL_VEGAS_MODE_STRATIFIED';
  
  //PROCEDURES
  proc gsl_monte_vegas_free: ptr[gsl_monte_vegas_state];
  
  //FUNCTIONS
  fun gsl_monte_vegas_alloc: size -> ptr[gsl_monte_vegas_state];
  fun gsl_monte_vegas_init: ptr[gsl_monte_vegas_state] -> int;
  fun gsl_monte_vegas_integrate: ptr[gsl_monte_function] * ptr[double] * ptr[double] * size * size * ptr[gsl_rng] * ptr[gsl_monte_vegas_state] * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_multifit_function_fdf_struct_lib.flx')
@select(h)
//Module        : gsl_multifit_function_fdf_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multifit_function_fdf_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_multifit_function_fdf_struct"';

module gsl_multifit_function_fdf_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_multifit_function_struct_lib.flx')
@select(h)
//Module        : gsl_multifit_function_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multifit_function_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_multifit_function_struct"';

module gsl_multifit_function_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_multifit_lib.flx')
@select(h)
//Module        : gsl_multifit_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multifit.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_MULTIFIT_H__
header '#include "gsl_multifit.h"';

//INCLUDES
include "gsl_matrix_double_lib";
include "gsl_vector_double_lib";

module gsl_multifit_h
{
  open C_hack;
  open gsl_matrix_double_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type gsl_multifit_linear_workspace = 'gsl_multifit_linear_workspace';
  
  //PROCEDURES
  proc gsl_multifit_linear_free: ptr[gsl_multifit_linear_workspace];
  
  //FUNCTIONS
  fun gsl_multifit_linear: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] * ptr[gsl_matrix] * ptr[double] * ptr[gsl_multifit_linear_workspace] -> int;
  fun gsl_multifit_linear_alloc: size * size -> ptr[gsl_multifit_linear_workspace];
  fun gsl_multifit_wlinear: cptr[gsl_matrix] * cptr[gsl_vector] * cptr[gsl_vector] * ptr[gsl_vector] * ptr[gsl_matrix] * ptr[double] * ptr[gsl_multifit_linear_workspace] -> int;
}
@h=tangler('lib/gsl/gsl_multifit_nlin_lib.flx')
@select(h)
//Module        : gsl_multifit_nlin_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multifit_nlin.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_MULTIFIT_FN_EVAL_F_DF(F,x,y,dy) ((*((F)->fdf))(x,(F)->params,(y),(dy)))
//#define GSL_MULTIFIT_FN_EVAL_DF(F,x,dy) ((*((F)->df))(x,(F)->params,(dy)))
//#define GSL_MULTIFIT_FN_EVAL_F(F,x,y) ((*((F)->f))(x,(F)->params,(y)))
//#define GSL_MULTIFIT_FN_EVAL(F,x,y) (*((F)->f))(x,(F)->params,(y))
//#define __GSL_MULTIFIT_NLIN_H__
header '#include "gsl_multifit_nlin.h"';

//INCLUDES
include "gsl_matrix_double_lib";
include "gsl_multifit_function_fdf_struct_lib";
include "gsl_multifit_function_struct_lib";
include "gsl_vector_double_lib";

module gsl_multifit_nlin_h
{
  open C_hack;
  open gsl_matrix_double_h;
  open gsl_multifit_function_fdf_struct_h;
  open gsl_multifit_function_struct_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type gsl_multifit_fdfsolver = 'gsl_multifit_fdfsolver';
  type gsl_multifit_fdfsolver_type = 'gsl_multifit_fdfsolver_type';
  type gsl_multifit_fsolver = 'gsl_multifit_fsolver';
  type gsl_multifit_fsolver_type = 'gsl_multifit_fsolver_type';
  
  //CSTRUCTS 
  cstruct gsl_multifit_function_struct {
    f: gsl_multifit_nlin_h_cft_1;
    n: size;
    p: size;
    params: address;
  }
  cstruct gsl_multifit_function_fdf_struct {
    f: gsl_multifit_nlin_h_cft_1;
    df: gsl_multifit_nlin_h_cft_2;
    fdf: gsl_multifit_nlin_h_cft_3;
    n: size;
    p: size;
    params: address;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*gsl_multifit_nlin_h_cft_3)(gsl_vector const *,  void *, gsl_vector *,  gsl_matrix *);''';
  type gsl_multifit_nlin_h_cft_3 = 'gsl_multifit_nlin_h_cft_3';
  header '''typedef int (*gsl_multifit_nlin_h_cft_2)(gsl_vector const *,  void *, gsl_matrix *);''';
  type gsl_multifit_nlin_h_cft_2 = 'gsl_multifit_nlin_h_cft_2';
  header '''typedef int (*gsl_multifit_nlin_h_cft_1)(gsl_vector const *,  void *, gsl_vector *);''';
  type gsl_multifit_nlin_h_cft_1 = 'gsl_multifit_nlin_h_cft_1';
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_multifit_function = gsl_multifit_function_struct;
  typedef gsl_multifit_function_fdf = gsl_multifit_function_fdf_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_multifit_function_fdf_struct = gsl_multifit_function_fdf_struct;
  typedef _struct_gsl_multifit_function_struct = gsl_multifit_function_struct;
  
  //VARIABLES
  const gsl_multifit_fdfsolver_lmsder: cptr[gsl_multifit_fdfsolver_type] = 'gsl_multifit_fdfsolver_lmsder';
  const gsl_multifit_fdfsolver_lmder: cptr[gsl_multifit_fdfsolver_type] = 'gsl_multifit_fdfsolver_lmder';
  
  //PROCEDURES
  proc gsl_multifit_fdfsolver_free: ptr[gsl_multifit_fdfsolver];
  proc gsl_multifit_fsolver_free: ptr[gsl_multifit_fsolver];
  
  //FUNCTIONS
  fun gsl_multifit_covar: cptr[gsl_matrix] * double * ptr[gsl_matrix] -> int;
  fun gsl_multifit_fdfsolver_alloc: cptr[gsl_multifit_fdfsolver_type] * size * size -> ptr[gsl_multifit_fdfsolver];
  fun gsl_multifit_fdfsolver_iterate: ptr[gsl_multifit_fdfsolver] -> int;
  fun gsl_multifit_fdfsolver_name: cptr[gsl_multifit_fdfsolver] -> cptr[char];
  fun gsl_multifit_fdfsolver_position: cptr[gsl_multifit_fdfsolver] -> ptr[gsl_vector];
  fun gsl_multifit_fdfsolver_set: ptr[gsl_multifit_fdfsolver] * ptr[gsl_multifit_function_fdf] * ptr[gsl_vector] -> int;
  fun gsl_multifit_fsolver_alloc: cptr[gsl_multifit_fsolver_type] * size * size -> ptr[gsl_multifit_fsolver];
  fun gsl_multifit_fsolver_iterate: ptr[gsl_multifit_fsolver] -> int;
  fun gsl_multifit_fsolver_name: cptr[gsl_multifit_fsolver] -> cptr[char];
  fun gsl_multifit_fsolver_position: cptr[gsl_multifit_fsolver] -> ptr[gsl_vector];
  fun gsl_multifit_fsolver_set: ptr[gsl_multifit_fsolver] * ptr[gsl_multifit_function] * ptr[gsl_vector] -> int;
  fun gsl_multifit_gradient: cptr[gsl_matrix] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_multifit_test_delta: cptr[gsl_vector] * cptr[gsl_vector] * double * double -> int;
  fun gsl_multifit_test_gradient: cptr[gsl_vector] * double -> int;
}
@h=tangler('lib/gsl/gsl_multimin_function_fdf_struct_lib.flx')
@select(h)
//Module        : gsl_multimin_function_fdf_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multimin_function_fdf_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_multimin_function_fdf_struct"';

module gsl_multimin_function_fdf_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_multimin_function_struct_lib.flx')
@select(h)
//Module        : gsl_multimin_function_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multimin_function_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_multimin_function_struct"';

module gsl_multimin_function_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_multimin_lib.flx')
@select(h)
//Module        : gsl_multimin_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multimin.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_MULTIMIN_FN_EVAL_F_DF(F,x,y,g) (*((F)->fdf))(x,(F)->params,(y),(g))
//#define GSL_MULTIMIN_FN_EVAL_DF(F,x,g) (*((F)->df))(x,(F)->params,(g))
//#define GSL_MULTIMIN_FN_EVAL_F(F,x) (*((F)->f))(x,(F)->params)
//#define GSL_MULTIMIN_FN_EVAL(F,x) (*((F)->f))(x,(F)->params)
//#define __GSL_MULTIMIN_H__
header '#include "gsl_multimin.h"';

//INCLUDES
include "gsl_multimin_function_fdf_struct_lib";
include "gsl_multimin_function_struct_lib";
include "gsl_vector_double_lib";

module gsl_multimin_h
{
  open C_hack;
  open gsl_multimin_function_fdf_struct_h;
  open gsl_multimin_function_struct_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type gsl_multimin_fminimizer = 'gsl_multimin_fminimizer';
  type gsl_multimin_fdfminimizer = 'gsl_multimin_fdfminimizer';
  type gsl_multimin_fdfminimizer_type = 'gsl_multimin_fdfminimizer_type';
  type gsl_multimin_fminimizer_type = 'gsl_multimin_fminimizer_type';
  
  //CSTRUCTS 
  cstruct gsl_multimin_function_fdf_struct {
    f: gsl_multimin_h_cft_1;
    df: gsl_multimin_h_cft_2;
    fdf: gsl_multimin_h_cft_3;
    n: size;
    params: address;
  }
  cstruct gsl_multimin_function_struct {
    f: gsl_multimin_h_cft_1;
    n: size;
    params: address;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*gsl_multimin_h_cft_3)(gsl_vector const *,  void *, double *,  gsl_vector *);''';
  type gsl_multimin_h_cft_3 = 'gsl_multimin_h_cft_3';
  header '''typedef void (*gsl_multimin_h_cft_2)(gsl_vector const *,  void *, gsl_vector *);''';
  type gsl_multimin_h_cft_2 = 'gsl_multimin_h_cft_2';
  header '''typedef double (*gsl_multimin_h_cft_1)(gsl_vector const *,  void *);''';
  type gsl_multimin_h_cft_1 = 'gsl_multimin_h_cft_1';
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_multimin_function = gsl_multimin_function_struct;
  typedef gsl_multimin_function_fdf = gsl_multimin_function_fdf_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_multimin_function_struct = gsl_multimin_function_struct;
  typedef _struct_gsl_multimin_function_fdf_struct = gsl_multimin_function_fdf_struct;
  
  //VARIABLES
  const gsl_multimin_fdfminimizer_conjugate_pr: cptr[gsl_multimin_fdfminimizer_type] = 'gsl_multimin_fdfminimizer_conjugate_pr';
  const gsl_multimin_fdfminimizer_steepest_descent: cptr[gsl_multimin_fdfminimizer_type] = 'gsl_multimin_fdfminimizer_steepest_descent';
  const gsl_multimin_fminimizer_nmsimplex: cptr[gsl_multimin_fminimizer_type] = 'gsl_multimin_fminimizer_nmsimplex';
  const gsl_multimin_fdfminimizer_conjugate_fr: cptr[gsl_multimin_fdfminimizer_type] = 'gsl_multimin_fdfminimizer_conjugate_fr';
  const gsl_multimin_fdfminimizer_vector_bfgs: cptr[gsl_multimin_fdfminimizer_type] = 'gsl_multimin_fdfminimizer_vector_bfgs';
  
  //PROCEDURES
  proc gsl_multimin_fdfminimizer_free: ptr[gsl_multimin_fdfminimizer];
  proc gsl_multimin_fminimizer_free: ptr[gsl_multimin_fminimizer];
  
  //FUNCTIONS
  fun gsl_multimin_diff: cptr[gsl_multimin_function] * cptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_multimin_fdfminimizer_alloc: cptr[gsl_multimin_fdfminimizer_type] * size -> ptr[gsl_multimin_fdfminimizer];
  fun gsl_multimin_fdfminimizer_dx: ptr[gsl_multimin_fdfminimizer] -> ptr[gsl_vector];
  fun gsl_multimin_fdfminimizer_gradient: ptr[gsl_multimin_fdfminimizer] -> ptr[gsl_vector];
  fun gsl_multimin_fdfminimizer_iterate: ptr[gsl_multimin_fdfminimizer] -> int;
  fun gsl_multimin_fdfminimizer_minimum: ptr[gsl_multimin_fdfminimizer] -> double;
  fun gsl_multimin_fdfminimizer_name: cptr[gsl_multimin_fdfminimizer] -> cptr[char];
  fun gsl_multimin_fdfminimizer_restart: ptr[gsl_multimin_fdfminimizer] -> int;
  fun gsl_multimin_fdfminimizer_set: ptr[gsl_multimin_fdfminimizer] * ptr[gsl_multimin_function_fdf] * cptr[gsl_vector] * double * double -> int;
  fun gsl_multimin_fdfminimizer_x: ptr[gsl_multimin_fdfminimizer] -> ptr[gsl_vector];
  fun gsl_multimin_fminimizer_alloc: cptr[gsl_multimin_fminimizer_type] * size -> ptr[gsl_multimin_fminimizer];
  fun gsl_multimin_fminimizer_iterate: ptr[gsl_multimin_fminimizer] -> int;
  fun gsl_multimin_fminimizer_minimum: cptr[gsl_multimin_fminimizer] -> double;
  fun gsl_multimin_fminimizer_name: cptr[gsl_multimin_fminimizer] -> cptr[char];
  fun gsl_multimin_fminimizer_set: ptr[gsl_multimin_fminimizer] * ptr[gsl_multimin_function] * cptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_multimin_fminimizer_size: cptr[gsl_multimin_fminimizer] -> double;
  fun gsl_multimin_fminimizer_x: cptr[gsl_multimin_fminimizer] -> ptr[gsl_vector];
  fun gsl_multimin_test_gradient: cptr[gsl_vector] * double -> int;
  fun gsl_multimin_test_size: double * double -> int;
}
@h=tangler('lib/gsl/gsl_multiroot_function_fdf_struct_lib.flx')
@select(h)
//Module        : gsl_multiroot_function_fdf_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multiroot_function_fdf_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_multiroot_function_fdf_struct"';

module gsl_multiroot_function_fdf_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_multiroot_function_struct_lib.flx')
@select(h)
//Module        : gsl_multiroot_function_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multiroot_function_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_multiroot_function_struct"';

module gsl_multiroot_function_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_multiroots_lib.flx')
@select(h)
//Module        : gsl_multiroots_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_multiroots.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_MULTIROOT_FN_EVAL_F_DF(F,x,y,dy) ((*((F)->fdf))(x,(F)->params,(y),(dy)))
//#define GSL_MULTIROOT_FN_EVAL_DF(F,x,dy) ((*((F)->df))(x,(F)->params,(dy)))
//#define GSL_MULTIROOT_FN_EVAL_F(F,x,y) ((*((F)->f))(x,(F)->params,(y)))
//#define GSL_MULTIROOT_FN_EVAL(F,x,y) (*((F)->f))(x,(F)->params,(y))
//#define __GSL_MULTIROOTS_H__
header '#include "gsl_multiroots.h"';

//INCLUDES
include "gsl_matrix_double_lib";
include "gsl_multiroot_function_fdf_struct_lib";
include "gsl_multiroot_function_struct_lib";
include "gsl_vector_double_lib";

module gsl_multiroots_h
{
  open C_hack;
  open gsl_matrix_double_h;
  open gsl_multiroot_function_fdf_struct_h;
  open gsl_multiroot_function_struct_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type gsl_multiroot_fsolver = 'gsl_multiroot_fsolver';
  type gsl_multiroot_fdfsolver_type = 'gsl_multiroot_fdfsolver_type';
  type gsl_multiroot_fsolver_type = 'gsl_multiroot_fsolver_type';
  type gsl_multiroot_fdfsolver = 'gsl_multiroot_fdfsolver';
  
  //CSTRUCTS 
  cstruct gsl_multiroot_function_struct {
    f: gsl_multiroots_h_cft_1;
    n: size;
    params: address;
  }
  cstruct gsl_multiroot_function_fdf_struct {
    f: gsl_multiroots_h_cft_1;
    df: gsl_multiroots_h_cft_2;
    fdf: gsl_multiroots_h_cft_3;
    n: size;
    params: address;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*gsl_multiroots_h_cft_3)(gsl_vector const *,  void *, gsl_vector *,  gsl_matrix *);''';
  type gsl_multiroots_h_cft_3 = 'gsl_multiroots_h_cft_3';
  header '''typedef int (*gsl_multiroots_h_cft_2)(gsl_vector const *,  void *, gsl_matrix *);''';
  type gsl_multiroots_h_cft_2 = 'gsl_multiroots_h_cft_2';
  header '''typedef int (*gsl_multiroots_h_cft_1)(gsl_vector const *,  void *, gsl_vector *);''';
  type gsl_multiroots_h_cft_1 = 'gsl_multiroots_h_cft_1';
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_multiroot_function = gsl_multiroot_function_struct;
  typedef gsl_multiroot_function_fdf = gsl_multiroot_function_fdf_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_multiroot_function_struct = gsl_multiroot_function_struct;
  typedef _struct_gsl_multiroot_function_fdf_struct = gsl_multiroot_function_fdf_struct;
  
  //VARIABLES
  const gsl_multiroot_fsolver_hybrids: cptr[gsl_multiroot_fsolver_type] = 'gsl_multiroot_fsolver_hybrids';
  const gsl_multiroot_fdfsolver_newton: cptr[gsl_multiroot_fdfsolver_type] = 'gsl_multiroot_fdfsolver_newton';
  const gsl_multiroot_fsolver_dnewton: cptr[gsl_multiroot_fsolver_type] = 'gsl_multiroot_fsolver_dnewton';
  const gsl_multiroot_fsolver_broyden: cptr[gsl_multiroot_fsolver_type] = 'gsl_multiroot_fsolver_broyden';
  const gsl_multiroot_fsolver_hybrid: cptr[gsl_multiroot_fsolver_type] = 'gsl_multiroot_fsolver_hybrid';
  const gsl_multiroot_fdfsolver_hybridj: cptr[gsl_multiroot_fdfsolver_type] = 'gsl_multiroot_fdfsolver_hybridj';
  const gsl_multiroot_fdfsolver_hybridsj: cptr[gsl_multiroot_fdfsolver_type] = 'gsl_multiroot_fdfsolver_hybridsj';
  const gsl_multiroot_fdfsolver_gnewton: cptr[gsl_multiroot_fdfsolver_type] = 'gsl_multiroot_fdfsolver_gnewton';
  
  //PROCEDURES
  proc gsl_multiroot_fdfsolver_free: ptr[gsl_multiroot_fdfsolver];
  proc gsl_multiroot_fsolver_free: ptr[gsl_multiroot_fsolver];
  
  //FUNCTIONS
  fun gsl_multiroot_fdfsolver_alloc: cptr[gsl_multiroot_fdfsolver_type] * size -> ptr[gsl_multiroot_fdfsolver];
  fun gsl_multiroot_fdfsolver_dx: cptr[gsl_multiroot_fdfsolver] -> ptr[gsl_vector];
  fun gsl_multiroot_fdfsolver_f: cptr[gsl_multiroot_fdfsolver] -> ptr[gsl_vector];
  fun gsl_multiroot_fdfsolver_iterate: ptr[gsl_multiroot_fdfsolver] -> int;
  fun gsl_multiroot_fdfsolver_name: cptr[gsl_multiroot_fdfsolver] -> cptr[char];
  fun gsl_multiroot_fdfsolver_root: cptr[gsl_multiroot_fdfsolver] -> ptr[gsl_vector];
  fun gsl_multiroot_fdfsolver_set: ptr[gsl_multiroot_fdfsolver] * ptr[gsl_multiroot_function_fdf] * ptr[gsl_vector] -> int;
  fun gsl_multiroot_fdjacobian: ptr[gsl_multiroot_function] * cptr[gsl_vector] * cptr[gsl_vector] * double * ptr[gsl_matrix] -> int;
  fun gsl_multiroot_fsolver_alloc: cptr[gsl_multiroot_fsolver_type] * size -> ptr[gsl_multiroot_fsolver];
  fun gsl_multiroot_fsolver_dx: cptr[gsl_multiroot_fsolver] -> ptr[gsl_vector];
  fun gsl_multiroot_fsolver_f: cptr[gsl_multiroot_fsolver] -> ptr[gsl_vector];
  fun gsl_multiroot_fsolver_iterate: ptr[gsl_multiroot_fsolver] -> int;
  fun gsl_multiroot_fsolver_name: cptr[gsl_multiroot_fsolver] -> cptr[char];
  fun gsl_multiroot_fsolver_root: cptr[gsl_multiroot_fsolver] -> ptr[gsl_vector];
  fun gsl_multiroot_fsolver_set: ptr[gsl_multiroot_fsolver] * ptr[gsl_multiroot_function] * ptr[gsl_vector] -> int;
  fun gsl_multiroot_test_delta: cptr[gsl_vector] * cptr[gsl_vector] * double * double -> int;
  fun gsl_multiroot_test_residual: cptr[gsl_vector] * double -> int;
}
@h=tangler('lib/gsl/gsl_nan_lib.flx')
@select(h)
//Module        : gsl_nan_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_nan.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_NEGZERO (-0)
//#define GSL_POSZERO (+0)
//#define GSL_NAN (gsl_nan())
//#define GSL_NAN (INFINITY/INFINITY)
//#define GSL_NAN NAN
//#define GSL_NEGINF (gsl_neginf())
//#define GSL_POSINF (gsl_posinf())
//#define GSL_NEGINF (-HUGE_VAL)
//#define GSL_POSINF HUGE_VAL
//#define GSL_NEGINF (-INFINITY)
//#define GSL_POSINF INFINITY
//#define __GSL_NAN_H__
header '#include "gsl_nan.h"';

module gsl_nan_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_ntuple_lib.flx')
@select(h)
//Module        : gsl_ntuple_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_ntuple.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_NTUPLE_H__
header '#include "gsl_ntuple.h"';

//INCLUDES
include "gsl_histogram_lib";

module gsl_ntuple_h
{
  open C_hack;
  open gsl_histogram_h;
  
  //ABSTRACT TYPES
  type gsl_ntuple_select_fn = 'gsl_ntuple_select_fn';
  type gsl_ntuple_value_fn = 'gsl_ntuple_value_fn';
  type gsl_ntuple = 'gsl_ntuple';
  
  //FUNCTIONS
  fun gsl_ntuple_bookdata: ptr[gsl_ntuple] -> int;
  fun gsl_ntuple_close: ptr[gsl_ntuple] -> int;
  fun gsl_ntuple_create: ptr[char] * address * size -> ptr[gsl_ntuple];
  fun gsl_ntuple_open: ptr[char] * address * size -> ptr[gsl_ntuple];
  fun gsl_ntuple_project: ptr[gsl_histogram] * ptr[gsl_ntuple] * ptr[gsl_ntuple_value_fn] * ptr[gsl_ntuple_select_fn] -> int;
  fun gsl_ntuple_read: ptr[gsl_ntuple] -> int;
  fun gsl_ntuple_write: ptr[gsl_ntuple] -> int;
}
@h=tangler('lib/gsl/gsl_odeiv_lib.flx')
@select(h)
//Module        : gsl_odeiv_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_odeiv.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_ODEIV_HADJ_DEC (-1) /* step decreased     */
//#define GSL_ODEIV_HADJ_NIL   0  /* step unchanged     */
//#define GSL_ODEIV_HADJ_INC   1  /* step was increased */
//#define GSL_ODEIV_JA_EVAL(S,t,y,dfdy,dfdt)  (*((S)->jacobian))(t,y,dfdy,dfdt,(S)->params)
//#define GSL_ODEIV_FN_EVAL(S,t,y,f)  (*((S)->function))(t,y,f,(S)->params)
//#define __GSL_ODEIV_H__
header '#include "gsl_odeiv.h"';

module gsl_odeiv_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_odeiv_control = 'gsl_odeiv_control';
  type gsl_odeiv_step = 'gsl_odeiv_step';
  type gsl_odeiv_evolve = 'gsl_odeiv_evolve';
  type gsl_odeiv_system = 'gsl_odeiv_system';
  type gsl_odeiv_control_type = 'gsl_odeiv_control_type';
  type gsl_odeiv_step_type = 'gsl_odeiv_step_type';
  
  //VARIABLES
  const gsl_odeiv_step_gear1: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_gear1';
  const gsl_odeiv_step_gear2: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_gear2';
  const gsl_odeiv_step_rk4imp: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rk4imp';
  const gsl_odeiv_step_rk2simp: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rk2simp';
  const gsl_odeiv_step_rkf45: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rkf45';
  const gsl_odeiv_step_rk8pd: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rk8pd';
  const gsl_odeiv_step_rk2: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rk2';
  const gsl_odeiv_step_rk4: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rk4';
  const gsl_odeiv_step_rk2imp: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rk2imp';
  const gsl_odeiv_step_bsimp: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_bsimp';
  const gsl_odeiv_step_rkck: cptr[gsl_odeiv_step_type] = 'gsl_odeiv_step_rkck';
  
  //PROCEDURES
  proc gsl_odeiv_control_free: ptr[gsl_odeiv_control];
  proc gsl_odeiv_evolve_free: ptr[gsl_odeiv_evolve];
  proc gsl_odeiv_step_free: ptr[gsl_odeiv_step];
  
  //FUNCTIONS
  fun gsl_odeiv_control_alloc: cptr[gsl_odeiv_control_type] -> ptr[gsl_odeiv_control];
  fun gsl_odeiv_control_hadjust: ptr[gsl_odeiv_control] * ptr[gsl_odeiv_step] * cptr[double] * cptr[double] * cptr[double] * ptr[double] -> int;
  fun gsl_odeiv_control_init: ptr[gsl_odeiv_control] * double * double * double * double -> int;
  fun gsl_odeiv_control_name: cptr[gsl_odeiv_control] -> cptr[char];
  fun gsl_odeiv_control_scaled_new: double * double * double * double * cptr[double] * size -> ptr[gsl_odeiv_control];
  fun gsl_odeiv_control_standard_new: double * double * double * double -> ptr[gsl_odeiv_control];
  fun gsl_odeiv_control_y_new: double * double -> ptr[gsl_odeiv_control];
  fun gsl_odeiv_control_yp_new: double * double -> ptr[gsl_odeiv_control];
  fun gsl_odeiv_evolve_alloc: size -> ptr[gsl_odeiv_evolve];
  fun gsl_odeiv_evolve_apply: ptr[gsl_odeiv_evolve] * ptr[gsl_odeiv_control] * ptr[gsl_odeiv_step] * cptr[gsl_odeiv_system] * ptr[double] * double * ptr[double] * ptr[double] -> int;
  fun gsl_odeiv_evolve_reset: ptr[gsl_odeiv_evolve] -> int;
  fun gsl_odeiv_step_alloc: cptr[gsl_odeiv_step_type] * size -> ptr[gsl_odeiv_step];
  fun gsl_odeiv_step_apply: ptr[gsl_odeiv_step] * double * double * ptr[double] * ptr[double] * cptr[double] * ptr[double] * cptr[gsl_odeiv_system] -> int;
  fun gsl_odeiv_step_name: cptr[gsl_odeiv_step] -> cptr[char];
  fun gsl_odeiv_step_order: cptr[gsl_odeiv_step] -> uint;
  fun gsl_odeiv_step_reset: ptr[gsl_odeiv_step] -> int;
}
@h=tangler('lib/gsl/gsl_permutation_lib.flx')
@select(h)
//Module        : gsl_permutation_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permutation.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTATION_H__
header '#include "gsl_permutation.h"';

//INCLUDES
include "gsl_permutation_struct_lib";

module gsl_permutation_h
{
  open C_hack;
  open gsl_permutation_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_permutation_struct {
    size: size;
    data: ptr[size];
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_permutation = gsl_permutation_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_permutation_struct = gsl_permutation_struct;
  
  //PROCEDURES
  proc gsl_permutation_free: ptr[gsl_permutation];
  proc gsl_permutation_init: ptr[gsl_permutation];
  proc gsl_permutation_reverse: ptr[gsl_permutation];
  
  //FUNCTIONS
  fun gsl_permutation_alloc: size -> ptr[gsl_permutation];
  fun gsl_permutation_calloc: size -> ptr[gsl_permutation];
  fun gsl_permutation_canonical_cycles: cptr[gsl_permutation] -> size;
  fun gsl_permutation_canonical_to_linear: ptr[gsl_permutation] * cptr[gsl_permutation] -> int;
  fun gsl_permutation_data: cptr[gsl_permutation] -> ptr[size];
  fun gsl_permutation_fprintf: ptr[FILE] * cptr[gsl_permutation] * cptr[char] -> int;
  fun gsl_permutation_fread: ptr[FILE] * ptr[gsl_permutation] -> int;
  fun gsl_permutation_fscanf: ptr[FILE] * ptr[gsl_permutation] -> int;
  fun gsl_permutation_fwrite: ptr[FILE] * cptr[gsl_permutation] -> int;
  fun gsl_permutation_get: cptr[gsl_permutation] * size -> size;
  fun gsl_permutation_inverse: ptr[gsl_permutation] * cptr[gsl_permutation] -> int;
  fun gsl_permutation_inversions: cptr[gsl_permutation] -> size;
  fun gsl_permutation_linear_cycles: cptr[gsl_permutation] -> size;
  fun gsl_permutation_linear_to_canonical: ptr[gsl_permutation] * cptr[gsl_permutation] -> int;
  fun gsl_permutation_memcpy: ptr[gsl_permutation] * cptr[gsl_permutation] -> int;
  fun gsl_permutation_mul: ptr[gsl_permutation] * cptr[gsl_permutation] * cptr[gsl_permutation] -> int;
  fun gsl_permutation_next: ptr[gsl_permutation] -> int;
  fun gsl_permutation_prev: ptr[gsl_permutation] -> int;
  fun gsl_permutation_size: cptr[gsl_permutation] -> size;
  fun gsl_permutation_swap: ptr[gsl_permutation] * size * size -> int;
  fun gsl_permutation_valid: ptr[gsl_permutation] -> int;
}
@h=tangler('lib/gsl/gsl_permutation_struct_lib.flx')
@select(h)
//Module        : gsl_permutation_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permutation_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_permutation_struct"';

module gsl_permutation_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_permute_char_lib.flx')
@select(h)
//Module        : gsl_permute_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_CHAR_H__
header '#include "gsl_permute_char.h"';

module gsl_permute_char_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_char: cptr[size] * ptr[char] * size * size -> int;
  fun gsl_permute_char_inverse: cptr[size] * ptr[char] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_complex_double_lib.flx')
@select(h)
//Module        : gsl_permute_complex_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_complex_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_COMPLEX_DOUBLE_H__
header '#include "gsl_permute_complex_double.h"';

module gsl_permute_complex_double_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_complex: cptr[size] * ptr[double] * size * size -> int;
  fun gsl_permute_complex_inverse: cptr[size] * ptr[double] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_complex_float_lib.flx')
@select(h)
//Module        : gsl_permute_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_COMPLEX_FLOAT_H__
header '#include "gsl_permute_complex_float.h"';

module gsl_permute_complex_float_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_complex_float: cptr[size] * ptr[float] * size * size -> int;
  fun gsl_permute_complex_float_inverse: cptr[size] * ptr[float] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_complex_long_double_lib.flx')
@select(h)
//Module        : gsl_permute_complex_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_complex_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_COMPLEX_LONG_DOUBLE_H__
header '#include "gsl_permute_complex_long_double.h"';

module gsl_permute_complex_long_double_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_complex_long_double: cptr[size] * ptr[ldouble] * size * size -> int;
  fun gsl_permute_complex_long_double_inverse: cptr[size] * ptr[ldouble] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_double_lib.flx')
@select(h)
//Module        : gsl_permute_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_DOUBLE_H__
header '#include "gsl_permute_double.h"';

module gsl_permute_double_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute: cptr[size] * ptr[double] * size * size -> int;
  fun gsl_permute_inverse: cptr[size] * ptr[double] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_float_lib.flx')
@select(h)
//Module        : gsl_permute_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_FLOAT_H__
header '#include "gsl_permute_float.h"';

module gsl_permute_float_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_float: cptr[size] * ptr[float] * size * size -> int;
  fun gsl_permute_float_inverse: cptr[size] * ptr[float] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_int_lib.flx')
@select(h)
//Module        : gsl_permute_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_INT_H__
header '#include "gsl_permute_int.h"';

module gsl_permute_int_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_int: cptr[size] * ptr[int] * size * size -> int;
  fun gsl_permute_int_inverse: cptr[size] * ptr[int] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_lib.flx')
@select(h)
//Module        : gsl_permute_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_H__
header '#include "gsl_permute.h"';

module gsl_permute_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_permute_long_double_lib.flx')
@select(h)
//Module        : gsl_permute_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_LONG_DOUBLE_H__
header '#include "gsl_permute_long_double.h"';

module gsl_permute_long_double_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_long_double: cptr[size] * ptr[ldouble] * size * size -> int;
  fun gsl_permute_long_double_inverse: cptr[size] * ptr[ldouble] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_long_lib.flx')
@select(h)
//Module        : gsl_permute_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_LONG_H__
header '#include "gsl_permute_long.h"';

module gsl_permute_long_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_long: cptr[size] * ptr[long] * size * size -> int;
  fun gsl_permute_long_inverse: cptr[size] * ptr[long] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_short_lib.flx')
@select(h)
//Module        : gsl_permute_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_SHORT_H__
header '#include "gsl_permute_short.h"';

module gsl_permute_short_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_short: cptr[size] * ptr[short] * size * size -> int;
  fun gsl_permute_short_inverse: cptr[size] * ptr[short] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_uchar_lib.flx')
@select(h)
//Module        : gsl_permute_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_UCHAR_H__
header '#include "gsl_permute_uchar.h"';

module gsl_permute_uchar_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_uchar: cptr[size] * ptr[utiny] * size * size -> int;
  fun gsl_permute_uchar_inverse: cptr[size] * ptr[utiny] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_uint_lib.flx')
@select(h)
//Module        : gsl_permute_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_UINT_H__
header '#include "gsl_permute_uint.h"';

module gsl_permute_uint_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_uint: cptr[size] * ptr[uint] * size * size -> int;
  fun gsl_permute_uint_inverse: cptr[size] * ptr[uint] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_ulong_lib.flx')
@select(h)
//Module        : gsl_permute_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_ULONG_H__
header '#include "gsl_permute_ulong.h"';

module gsl_permute_ulong_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_ulong: cptr[size] * ptr[ulong] * size * size -> int;
  fun gsl_permute_ulong_inverse: cptr[size] * ptr[ulong] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_ushort_lib.flx')
@select(h)
//Module        : gsl_permute_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_USHORT_H__
header '#include "gsl_permute_ushort.h"';

module gsl_permute_ushort_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_permute_ushort: cptr[size] * ptr[ushort] * size * size -> int;
  fun gsl_permute_ushort_inverse: cptr[size] * ptr[ushort] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_char_lib.flx')
@select(h)
//Module        : gsl_permute_vector_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_CHAR_H__
header '#include "gsl_permute_vector_char.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_char_lib";

module gsl_permute_vector_char_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_char_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_char: cptr[gsl_permutation] * ptr[gsl_vector_char] -> int;
  fun gsl_permute_vector_char_inverse: cptr[gsl_permutation] * ptr[gsl_vector_char] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_complex_double_lib.flx')
@select(h)
//Module        : gsl_permute_vector_complex_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_complex_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_COMPLEX_DOUBLE_H__
header '#include "gsl_permute_vector_complex_double.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_complex_double_lib";

module gsl_permute_vector_complex_double_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_complex_double_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_complex: cptr[gsl_permutation] * ptr[gsl_vector_complex] -> int;
  fun gsl_permute_vector_complex_inverse: cptr[gsl_permutation] * ptr[gsl_vector_complex] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_complex_float_lib.flx')
@select(h)
//Module        : gsl_permute_vector_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_COMPLEX_FLOAT_H__
header '#include "gsl_permute_vector_complex_float.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_complex_float_lib";

module gsl_permute_vector_complex_float_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_complex_float_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_complex_float: cptr[gsl_permutation] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_permute_vector_complex_float_inverse: cptr[gsl_permutation] * ptr[gsl_vector_complex_float] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_complex_long_double_lib.flx')
@select(h)
//Module        : gsl_permute_vector_complex_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_complex_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_COMPLEX_LONG_DOUBLE_H__
header '#include "gsl_permute_vector_complex_long_double.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_complex_long_double_lib";

module gsl_permute_vector_complex_long_double_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_complex_long_double_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_complex_long_double: cptr[gsl_permutation] * ptr[gsl_vector_complex_long_double] -> int;
  fun gsl_permute_vector_complex_long_double_inverse: cptr[gsl_permutation] * ptr[gsl_vector_complex_long_double] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_double_lib.flx')
@select(h)
//Module        : gsl_permute_vector_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_DOUBLE_H__
header '#include "gsl_permute_vector_double.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_double_lib";

module gsl_permute_vector_double_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_double_h;
  
  //FUNCTIONS
  fun gsl_permute_vector: cptr[gsl_permutation] * ptr[gsl_vector] -> int;
  fun gsl_permute_vector_inverse: cptr[gsl_permutation] * ptr[gsl_vector] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_float_lib.flx')
@select(h)
//Module        : gsl_permute_vector_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_FLOAT_H__
header '#include "gsl_permute_vector_float.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_float_lib";

module gsl_permute_vector_float_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_float_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_float: cptr[gsl_permutation] * ptr[gsl_vector_float] -> int;
  fun gsl_permute_vector_float_inverse: cptr[gsl_permutation] * ptr[gsl_vector_float] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_int_lib.flx')
@select(h)
//Module        : gsl_permute_vector_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_INT_H__
header '#include "gsl_permute_vector_int.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_int_lib";

module gsl_permute_vector_int_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_int_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_int: cptr[gsl_permutation] * ptr[gsl_vector_int] -> int;
  fun gsl_permute_vector_int_inverse: cptr[gsl_permutation] * ptr[gsl_vector_int] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_lib.flx')
@select(h)
//Module        : gsl_permute_vector_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_H__
header '#include "gsl_permute_vector.h"';

module gsl_permute_vector_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_permute_vector_long_double_lib.flx')
@select(h)
//Module        : gsl_permute_vector_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_LONG_DOUBLE_H__
header '#include "gsl_permute_vector_long_double.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_long_double_lib";

module gsl_permute_vector_long_double_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_long_double_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_long_double: cptr[gsl_permutation] * ptr[gsl_vector_long_double] -> int;
  fun gsl_permute_vector_long_double_inverse: cptr[gsl_permutation] * ptr[gsl_vector_long_double] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_long_lib.flx')
@select(h)
//Module        : gsl_permute_vector_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_LONG_H__
header '#include "gsl_permute_vector_long.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_long_lib";

module gsl_permute_vector_long_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_long_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_long: cptr[gsl_permutation] * ptr[gsl_vector_long] -> int;
  fun gsl_permute_vector_long_inverse: cptr[gsl_permutation] * ptr[gsl_vector_long] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_short_lib.flx')
@select(h)
//Module        : gsl_permute_vector_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_SHORT_H__
header '#include "gsl_permute_vector_short.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_short_lib";

module gsl_permute_vector_short_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_short_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_short: cptr[gsl_permutation] * ptr[gsl_vector_short] -> int;
  fun gsl_permute_vector_short_inverse: cptr[gsl_permutation] * ptr[gsl_vector_short] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_uchar_lib.flx')
@select(h)
//Module        : gsl_permute_vector_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_UCHAR_H__
header '#include "gsl_permute_vector_uchar.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_uchar_lib";

module gsl_permute_vector_uchar_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_uchar_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_uchar: cptr[gsl_permutation] * ptr[gsl_vector_uchar] -> int;
  fun gsl_permute_vector_uchar_inverse: cptr[gsl_permutation] * ptr[gsl_vector_uchar] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_uint_lib.flx')
@select(h)
//Module        : gsl_permute_vector_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_UINT_H__
header '#include "gsl_permute_vector_uint.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_uint_lib";

module gsl_permute_vector_uint_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_uint_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_uint: cptr[gsl_permutation] * ptr[gsl_vector_uint] -> int;
  fun gsl_permute_vector_uint_inverse: cptr[gsl_permutation] * ptr[gsl_vector_uint] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_ulong_lib.flx')
@select(h)
//Module        : gsl_permute_vector_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_ULONG_H__
header '#include "gsl_permute_vector_ulong.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_ulong_lib";

module gsl_permute_vector_ulong_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_ulong_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_ulong: cptr[gsl_permutation] * ptr[gsl_vector_ulong] -> int;
  fun gsl_permute_vector_ulong_inverse: cptr[gsl_permutation] * ptr[gsl_vector_ulong] -> int;
}
@h=tangler('lib/gsl/gsl_permute_vector_ushort_lib.flx')
@select(h)
//Module        : gsl_permute_vector_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_permute_vector_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_PERMUTE_VECTOR_USHORT_H__
header '#include "gsl_permute_vector_ushort.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_ushort_lib";

module gsl_permute_vector_ushort_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_ushort_h;
  
  //FUNCTIONS
  fun gsl_permute_vector_ushort: cptr[gsl_permutation] * ptr[gsl_vector_ushort] -> int;
  fun gsl_permute_vector_ushort_inverse: cptr[gsl_permutation] * ptr[gsl_vector_ushort] -> int;
}
@h=tangler('lib/gsl/gsl_poly_lib.flx')
@select(h)
//Module        : gsl_poly_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_poly.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_POLY_H__
header '#include "gsl_poly.h"';

//INCLUDES
include "gsl_complex_lib";

module gsl_poly_h
{
  open C_hack;
  open gsl_complex_h;
  
  //ABSTRACT TYPES
  type gsl_poly_complex_workspace = 'gsl_poly_complex_workspace';
  
  //PROCEDURES
  proc gsl_poly_complex_workspace_free: ptr[gsl_poly_complex_workspace];
  
  //FUNCTIONS
  fun gsl_poly_complex_solve: cptr[double] * size * ptr[gsl_poly_complex_workspace] * gsl_complex_packed_ptr -> int;
  fun gsl_poly_complex_solve_cubic: double * double * double * ptr[gsl_complex] * ptr[gsl_complex] * ptr[gsl_complex] -> int;
  fun gsl_poly_complex_solve_quadratic: double * double * double * ptr[gsl_complex] * ptr[gsl_complex] -> int;
  fun gsl_poly_complex_workspace_alloc: size -> ptr[gsl_poly_complex_workspace];
  fun gsl_poly_dd_eval: cptr[double] * cptr[double] * size * double -> double;
  fun gsl_poly_dd_init: ptr[double] * cptr[double] * cptr[double] * size -> int;
  fun gsl_poly_dd_taylor: ptr[double] * double * cptr[double] * cptr[double] * size * ptr[double] -> int;
  fun gsl_poly_eval: cptr[double] * int * double -> double;
  fun gsl_poly_solve_cubic: double * double * double * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_poly_solve_quadratic: double * double * double * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_pow_int_lib.flx')
@select(h)
//Module        : gsl_pow_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_pow_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_POW_INT_H__
header '#include "gsl_pow_int.h"';

module gsl_pow_int_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_pow_2: double -> double;
  fun gsl_pow_3: double -> double;
  fun gsl_pow_4: double -> double;
  fun gsl_pow_5: double -> double;
  fun gsl_pow_6: double -> double;
  fun gsl_pow_7: double -> double;
  fun gsl_pow_8: double -> double;
  fun gsl_pow_9: double -> double;
  fun gsl_pow_int: double * int -> double;
}
@h=tangler('lib/gsl/gsl_precision_lib.flx')
@select(h)
//Module        : gsl_precision_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_precision.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define _GSL_PREC_T_NUM 3
//#define __GSL_PRECISION_H__
header '#include "gsl_precision.h"';

module gsl_precision_h
{
  open C_hack;
  
  //TYPE ALIASES
  typedef gsl_prec_t = uint;
  
  //VARIABLES
  const gsl_prec_eps: cptr[double] = 'gsl_prec_eps';
  const gsl_prec_root3_eps: cptr[double] = 'gsl_prec_root3_eps';
  const gsl_prec_root5_eps: cptr[double] = 'gsl_prec_root5_eps';
  const gsl_prec_sqrt_eps: cptr[double] = 'gsl_prec_sqrt_eps';
  const gsl_prec_root4_eps: cptr[double] = 'gsl_prec_root4_eps';
  const gsl_prec_root6_eps: cptr[double] = 'gsl_prec_root6_eps';
}
@h=tangler('lib/gsl/gsl_qrng_lib.flx')
@select(h)
//Module        : gsl_qrng_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_qrng.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_QRNG_H__
header '#include "gsl_qrng.h"';

module gsl_qrng_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_qrng_type = 'gsl_qrng_type';
  type gsl_qrng = 'gsl_qrng';
  
  //VARIABLES
  const gsl_qrng_niederreiter_2: cptr[gsl_qrng_type] = 'gsl_qrng_niederreiter_2';
  const gsl_qrng_sobol: cptr[gsl_qrng_type] = 'gsl_qrng_sobol';
  
  //PROCEDURES
  proc gsl_qrng_free: ptr[gsl_qrng];
  proc gsl_qrng_init: ptr[gsl_qrng];
  
  //FUNCTIONS
  fun gsl_qrng_alloc: cptr[gsl_qrng_type] * uint -> ptr[gsl_qrng];
  fun gsl_qrng_clone: cptr[gsl_qrng] -> ptr[gsl_qrng];
  fun gsl_qrng_get: cptr[gsl_qrng] * ptr[double] -> int;
  fun gsl_qrng_memcpy: ptr[gsl_qrng] * cptr[gsl_qrng] -> int;
  fun gsl_qrng_name: cptr[gsl_qrng] -> cptr[char];
  fun gsl_qrng_size: cptr[gsl_qrng] -> size;
  fun gsl_qrng_state: cptr[gsl_qrng] -> address;
}
@h=tangler('lib/gsl/gsl_randist_lib.flx')
@select(h)
//Module        : gsl_randist_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_randist.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_RANDIST_H__
header '#include "gsl_randist.h"';

//INCLUDES
include "gsl_rng_lib";

module gsl_randist_h
{
  open C_hack;
  open gsl_rng_h;
  
  //ABSTRACT TYPES
  type gsl_ran_discrete_t = 'gsl_ran_discrete_t';
  
  //PROCEDURES
  proc gsl_ran_bivariate_gaussian: cptr[gsl_rng] * double * double * double * ptr[double] * ptr[double];
  proc gsl_ran_dir_2d: cptr[gsl_rng] * ptr[double] * ptr[double];
  proc gsl_ran_dir_2d_trig_method: cptr[gsl_rng] * ptr[double] * ptr[double];
  proc gsl_ran_dir_3d: cptr[gsl_rng] * ptr[double] * ptr[double] * ptr[double];
  proc gsl_ran_dir_nd: cptr[gsl_rng] * size * ptr[double];
  proc gsl_ran_dirichlet: cptr[gsl_rng] * size * cptr[double] * ptr[double];
  proc gsl_ran_discrete_free: ptr[gsl_ran_discrete_t];
  proc gsl_ran_multinomial: cptr[gsl_rng] * size * uint * cptr[double] * ptr[uint];
  proc gsl_ran_poisson_array: cptr[gsl_rng] * size * ptr[uint] * double;
  proc gsl_ran_sample: cptr[gsl_rng] * address * size * address * size * size;
  proc gsl_ran_shuffle: cptr[gsl_rng] * address * size * size;
  
  //FUNCTIONS
  fun gsl_ran_bernoulli: cptr[gsl_rng] * double -> uint;
  fun gsl_ran_bernoulli_pdf: uint * double -> double;
  fun gsl_ran_beta: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_beta_pdf: double * double * double -> double;
  fun gsl_ran_binomial: cptr[gsl_rng] * double * uint -> uint;
  fun gsl_ran_binomial_pdf: uint * double * uint -> double;
  fun gsl_ran_binomial_tpe: cptr[gsl_rng] * double * uint -> uint;
  fun gsl_ran_bivariate_gaussian_pdf: double * double * double * double * double -> double;
  fun gsl_ran_cauchy: cptr[gsl_rng] * double -> double;
  fun gsl_ran_cauchy_pdf: double * double -> double;
  fun gsl_ran_chisq: cptr[gsl_rng] * double -> double;
  fun gsl_ran_chisq_pdf: double * double -> double;
  fun gsl_ran_choose: cptr[gsl_rng] * address * size * address * size * size -> int;
  fun gsl_ran_dirichlet_lnpdf: size * cptr[double] * cptr[double] -> double;
  fun gsl_ran_dirichlet_pdf: size * cptr[double] * cptr[double] -> double;
  fun gsl_ran_discrete: cptr[gsl_rng] * cptr[gsl_ran_discrete_t] -> size;
  fun gsl_ran_discrete_pdf: size * cptr[gsl_ran_discrete_t] -> double;
  fun gsl_ran_discrete_preproc: size * cptr[double] -> ptr[gsl_ran_discrete_t];
  fun gsl_ran_erlang: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_erlang_pdf: double * double * double -> double;
  fun gsl_ran_exponential: cptr[gsl_rng] * double -> double;
  fun gsl_ran_exponential_pdf: double * double -> double;
  fun gsl_ran_exppow: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_exppow_pdf: double * double * double -> double;
  fun gsl_ran_fdist: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_fdist_pdf: double * double * double -> double;
  fun gsl_ran_flat: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_flat_pdf: double * double * double -> double;
  fun gsl_ran_gamma: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_gamma_int: cptr[gsl_rng] * uint -> double;
  fun gsl_ran_gamma_pdf: double * double * double -> double;
  fun gsl_ran_gaussian: cptr[gsl_rng] * double -> double;
  fun gsl_ran_gaussian_pdf: double * double -> double;
  fun gsl_ran_gaussian_ratio_method: cptr[gsl_rng] * double -> double;
  fun gsl_ran_gaussian_tail: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_gaussian_tail_pdf: double * double * double -> double;
  fun gsl_ran_geometric: cptr[gsl_rng] * double -> uint;
  fun gsl_ran_geometric_pdf: uint * double -> double;
  fun gsl_ran_gumbel1: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_gumbel1_pdf: double * double * double -> double;
  fun gsl_ran_gumbel2: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_gumbel2_pdf: double * double * double -> double;
  fun gsl_ran_hypergeometric: cptr[gsl_rng] * uint * uint * uint -> uint;
  fun gsl_ran_hypergeometric_pdf: uint * uint * uint * uint -> double;
  fun gsl_ran_landau: cptr[gsl_rng] -> double;
  fun gsl_ran_landau_pdf: double -> double;
  fun gsl_ran_laplace: cptr[gsl_rng] * double -> double;
  fun gsl_ran_laplace_pdf: double * double -> double;
  fun gsl_ran_levy: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_levy_skew: cptr[gsl_rng] * double * double * double -> double;
  fun gsl_ran_logarithmic: cptr[gsl_rng] * double -> uint;
  fun gsl_ran_logarithmic_pdf: uint * double -> double;
  fun gsl_ran_logistic: cptr[gsl_rng] * double -> double;
  fun gsl_ran_logistic_pdf: double * double -> double;
  fun gsl_ran_lognormal: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_lognormal_pdf: double * double * double -> double;
  fun gsl_ran_multinomial_lnpdf: size * cptr[double] * cptr[uint] -> double;
  fun gsl_ran_multinomial_pdf: size * cptr[double] * cptr[uint] -> double;
  fun gsl_ran_negative_binomial: cptr[gsl_rng] * double * double -> uint;
  fun gsl_ran_negative_binomial_pdf: uint * double * double -> double;
  fun gsl_ran_pareto: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_pareto_pdf: double * double * double -> double;
  fun gsl_ran_pascal: cptr[gsl_rng] * double * uint -> uint;
  fun gsl_ran_pascal_pdf: uint * double * uint -> double;
  fun gsl_ran_poisson: cptr[gsl_rng] * double -> uint;
  fun gsl_ran_poisson_pdf: uint * double -> double;
  fun gsl_ran_rayleigh: cptr[gsl_rng] * double -> double;
  fun gsl_ran_rayleigh_pdf: double * double -> double;
  fun gsl_ran_rayleigh_tail: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_rayleigh_tail_pdf: double * double * double -> double;
  fun gsl_ran_tdist: cptr[gsl_rng] * double -> double;
  fun gsl_ran_tdist_pdf: double * double -> double;
  fun gsl_ran_ugaussian: cptr[gsl_rng] -> double;
  fun gsl_ran_ugaussian_pdf: double -> double;
  fun gsl_ran_ugaussian_ratio_method: cptr[gsl_rng] -> double;
  fun gsl_ran_ugaussian_tail: cptr[gsl_rng] * double -> double;
  fun gsl_ran_ugaussian_tail_pdf: double * double -> double;
  fun gsl_ran_weibull: cptr[gsl_rng] * double * double -> double;
  fun gsl_ran_weibull_pdf: double * double * double -> double;
}
@h=tangler('lib/gsl/gsl_rng_lib.flx')
@select(h)
//Module        : gsl_rng_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_rng.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_RNG_H__
header '#include "gsl_rng.h"';

//INCLUDES

module gsl_rng_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_rng_type = 'gsl_rng_type';
  type gsl_rng = 'gsl_rng';
  
  //VARIABLES
  const gsl_rng_mrg: cptr[gsl_rng_type] = 'gsl_rng_mrg';
  const gsl_rng_uni: cptr[gsl_rng_type] = 'gsl_rng_uni';
  const gsl_rng_random32_libc5: cptr[gsl_rng_type] = 'gsl_rng_random32_libc5';
  const gsl_rng_random64_bsd: cptr[gsl_rng_type] = 'gsl_rng_random64_bsd';
  const gsl_rng_random128_glibc2: cptr[gsl_rng_type] = 'gsl_rng_random128_glibc2';
  const gsl_rng_random128_libc5: cptr[gsl_rng_type] = 'gsl_rng_random128_libc5';
  const gsl_rng_fishman18: cptr[gsl_rng_type] = 'gsl_rng_fishman18';
  const gsl_rng_slatec: cptr[gsl_rng_type] = 'gsl_rng_slatec';
  const gsl_rng_ranlxs0: cptr[gsl_rng_type] = 'gsl_rng_ranlxs0';
  const gsl_rng_ranlxs1: cptr[gsl_rng_type] = 'gsl_rng_ranlxs1';
  const gsl_rng_coveyou: cptr[gsl_rng_type] = 'gsl_rng_coveyou';
  const gsl_rng_ranlxs2: cptr[gsl_rng_type] = 'gsl_rng_ranlxs2';
  const gsl_rng_mt19937: cptr[gsl_rng_type] = 'gsl_rng_mt19937';
  const gsl_rng_ranlxd1: cptr[gsl_rng_type] = 'gsl_rng_ranlxd1';
  const gsl_rng_ranlxd2: cptr[gsl_rng_type] = 'gsl_rng_ranlxd2';
  const gsl_rng_ranmar: cptr[gsl_rng_type] = 'gsl_rng_ranmar';
  const gsl_rng_fishman20: cptr[gsl_rng_type] = 'gsl_rng_fishman20';
  const gsl_rng_borosh13: cptr[gsl_rng_type] = 'gsl_rng_borosh13';
  const gsl_rng_random256_glibc2: cptr[gsl_rng_type] = 'gsl_rng_random256_glibc2';
  const gsl_rng_r250: cptr[gsl_rng_type] = 'gsl_rng_r250';
  const gsl_rng_minstd: cptr[gsl_rng_type] = 'gsl_rng_minstd';
  const gsl_rng_knuthran2: cptr[gsl_rng_type] = 'gsl_rng_knuthran2';
  const gsl_rng_random256_libc5: cptr[gsl_rng_type] = 'gsl_rng_random256_libc5';
  const gsl_rng_taus2: cptr[gsl_rng_type] = 'gsl_rng_taus2';
  const gsl_rng_rand48: cptr[gsl_rng_type] = 'gsl_rng_rand48';
  const gsl_rng_ran0: cptr[gsl_rng_type] = 'gsl_rng_ran0';
  const gsl_rng_ran1: cptr[gsl_rng_type] = 'gsl_rng_ran1';
  const gsl_rng_vax: cptr[gsl_rng_type] = 'gsl_rng_vax';
  const gsl_rng_random128_bsd: cptr[gsl_rng_type] = 'gsl_rng_random128_bsd';
  const gsl_rng_ran2: cptr[gsl_rng_type] = 'gsl_rng_ran2';
  const gsl_rng_ran3: cptr[gsl_rng_type] = 'gsl_rng_ran3';
  const gsl_rng_random8_bsd: cptr[gsl_rng_type] = 'gsl_rng_random8_bsd';
  const gsl_rng_ranlux: cptr[gsl_rng_type] = 'gsl_rng_ranlux';
  const gsl_rng_gfsr4: cptr[gsl_rng_type] = 'gsl_rng_gfsr4';
  const gsl_rng_lecuyer21: cptr[gsl_rng_type] = 'gsl_rng_lecuyer21';
  const gsl_rng_random8_glibc2: cptr[gsl_rng_type] = 'gsl_rng_random8_glibc2';
  const gsl_rng_random8_libc5: cptr[gsl_rng_type] = 'gsl_rng_random8_libc5';
  const gsl_rng_ranlux389: cptr[gsl_rng_type] = 'gsl_rng_ranlux389';
  const gsl_rng_tt800: cptr[gsl_rng_type] = 'gsl_rng_tt800';
  const gsl_rng_random32_bsd: cptr[gsl_rng_type] = 'gsl_rng_random32_bsd';
  const gsl_rng_cmrg: cptr[gsl_rng_type] = 'gsl_rng_cmrg';
  const gsl_rng_default: cptr[gsl_rng_type] = 'gsl_rng_default';
  const gsl_rng_taus113: cptr[gsl_rng_type] = 'gsl_rng_taus113';
  const gsl_rng_random64_glibc2: cptr[gsl_rng_type] = 'gsl_rng_random64_glibc2';
  const gsl_rng_waterman14: cptr[gsl_rng_type] = 'gsl_rng_waterman14';
  const gsl_rng_random256_bsd: cptr[gsl_rng_type] = 'gsl_rng_random256_bsd';
  const gsl_rng_random_bsd: cptr[gsl_rng_type] = 'gsl_rng_random_bsd';
  const gsl_rng_random_glibc2: cptr[gsl_rng_type] = 'gsl_rng_random_glibc2';
  const gsl_rng_taus: cptr[gsl_rng_type] = 'gsl_rng_taus';
  const gsl_rng_uni32: cptr[gsl_rng_type] = 'gsl_rng_uni32';
  const gsl_rng_rand: cptr[gsl_rng_type] = 'gsl_rng_rand';
  const gsl_rng_knuthran: cptr[gsl_rng_type] = 'gsl_rng_knuthran';
  const gsl_rng_ranf: cptr[gsl_rng_type] = 'gsl_rng_ranf';
  const gsl_rng_default_seed: ulong = 'gsl_rng_default_seed';
  const gsl_rng_random64_libc5: cptr[gsl_rng_type] = 'gsl_rng_random64_libc5';
  const gsl_rng_mt19937_1998: cptr[gsl_rng_type] = 'gsl_rng_mt19937_1998';
  const gsl_rng_random32_glibc2: cptr[gsl_rng_type] = 'gsl_rng_random32_glibc2';
  const gsl_rng_mt19937_1999: cptr[gsl_rng_type] = 'gsl_rng_mt19937_1999';
  const gsl_rng_fishman2x: cptr[gsl_rng_type] = 'gsl_rng_fishman2x';
  const gsl_rng_transputer: cptr[gsl_rng_type] = 'gsl_rng_transputer';
  const gsl_rng_randu: cptr[gsl_rng_type] = 'gsl_rng_randu';
  const gsl_rng_zuf: cptr[gsl_rng_type] = 'gsl_rng_zuf';
  const gsl_rng_random_libc5: cptr[gsl_rng_type] = 'gsl_rng_random_libc5';
  
  //PROCEDURES
  proc gsl_rng_free: ptr[gsl_rng];
  proc gsl_rng_print_state: cptr[gsl_rng];
  proc gsl_rng_set: cptr[gsl_rng] * ulong;
  
  //FUNCTIONS
  fun gsl_rng_alloc: cptr[gsl_rng_type] -> ptr[gsl_rng];
  fun gsl_rng_clone: cptr[gsl_rng] -> ptr[gsl_rng];
  fun gsl_rng_env_setup: 1 -> cptr[gsl_rng_type];
  fun gsl_rng_fread: ptr[FILE] * ptr[gsl_rng] -> int;
  fun gsl_rng_fwrite: ptr[FILE] * cptr[gsl_rng] -> int;
  fun gsl_rng_get: cptr[gsl_rng] -> ulong;
  fun gsl_rng_max: cptr[gsl_rng] -> ulong;
  fun gsl_rng_memcpy: ptr[gsl_rng] * cptr[gsl_rng] -> int;
  fun gsl_rng_min: cptr[gsl_rng] -> ulong;
  fun gsl_rng_name: cptr[gsl_rng] -> cptr[char];
  fun gsl_rng_size: cptr[gsl_rng] -> size;
  fun gsl_rng_state: cptr[gsl_rng] -> address;
  fun gsl_rng_types_setup: 1 -> ptr[cptr[gsl_rng_type]];
  fun gsl_rng_uniform: cptr[gsl_rng] -> double;
  fun gsl_rng_uniform_int: cptr[gsl_rng] * ulong -> ulong;
  fun gsl_rng_uniform_pos: cptr[gsl_rng] -> double;
}
@h=tangler('lib/gsl/gsl_roots_lib.flx')
@select(h)
//Module        : gsl_roots_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_roots.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_ROOTS_H__
header '#include "gsl_roots.h"';

//INCLUDES
include "gsl_math_lib";

module gsl_roots_h
{
  open C_hack;
  open gsl_math_h;
  
  //ABSTRACT TYPES
  type gsl_root_fdfsolver = 'gsl_root_fdfsolver';
  type gsl_root_fsolver_type = 'gsl_root_fsolver_type';
  type gsl_root_fdfsolver_type = 'gsl_root_fdfsolver_type';
  type gsl_root_fsolver = 'gsl_root_fsolver';
  
  //VARIABLES
  const gsl_root_fdfsolver_steffenson: cptr[gsl_root_fdfsolver_type] = 'gsl_root_fdfsolver_steffenson';
  const gsl_root_fdfsolver_secant: cptr[gsl_root_fdfsolver_type] = 'gsl_root_fdfsolver_secant';
  const gsl_root_fdfsolver_newton: cptr[gsl_root_fdfsolver_type] = 'gsl_root_fdfsolver_newton';
  const gsl_root_fsolver_falsepos: cptr[gsl_root_fsolver_type] = 'gsl_root_fsolver_falsepos';
  const gsl_root_fsolver_bisection: cptr[gsl_root_fsolver_type] = 'gsl_root_fsolver_bisection';
  const gsl_root_fsolver_brent: cptr[gsl_root_fsolver_type] = 'gsl_root_fsolver_brent';
  
  //PROCEDURES
  proc gsl_root_fdfsolver_free: ptr[gsl_root_fdfsolver];
  proc gsl_root_fsolver_free: ptr[gsl_root_fsolver];
  
  //FUNCTIONS
  fun gsl_root_fdfsolver_alloc: cptr[gsl_root_fdfsolver_type] -> ptr[gsl_root_fdfsolver];
  fun gsl_root_fdfsolver_iterate: ptr[gsl_root_fdfsolver] -> int;
  fun gsl_root_fdfsolver_name: cptr[gsl_root_fdfsolver] -> cptr[char];
  fun gsl_root_fdfsolver_root: cptr[gsl_root_fdfsolver] -> double;
  fun gsl_root_fdfsolver_set: ptr[gsl_root_fdfsolver] * ptr[gsl_function_fdf] * double -> int;
  fun gsl_root_fsolver_alloc: cptr[gsl_root_fsolver_type] -> ptr[gsl_root_fsolver];
  fun gsl_root_fsolver_iterate: ptr[gsl_root_fsolver] -> int;
  fun gsl_root_fsolver_name: cptr[gsl_root_fsolver] -> cptr[char];
  fun gsl_root_fsolver_root: cptr[gsl_root_fsolver] -> double;
  fun gsl_root_fsolver_set: ptr[gsl_root_fsolver] * ptr[gsl_function] * double * double -> int;
  fun gsl_root_fsolver_x_lower: cptr[gsl_root_fsolver] -> double;
  fun gsl_root_fsolver_x_upper: cptr[gsl_root_fsolver] -> double;
  fun gsl_root_test_delta: double * double * double * double -> int;
  fun gsl_root_test_interval: double * double * double * double -> int;
  fun gsl_root_test_residual: double * double -> int;
}
@h=tangler('lib/gsl/gsl_sf_airy_lib.flx')
@select(h)
//Module        : gsl_sf_airy_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_airy.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_AIRY_H__
header '#include "gsl_sf_airy.h"';

//INCLUDES
include "gsl_mode_lib";
include "gsl_sf_result_lib";

module gsl_sf_airy_h
{
  open C_hack;
  open gsl_mode_h;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_airy_Ai: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Ai_deriv: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Ai_deriv_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Ai_deriv_scaled: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Ai_deriv_scaled_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Ai_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Ai_scaled: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Ai_scaled_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Bi: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Bi_deriv: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Bi_deriv_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Bi_deriv_scaled: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Bi_deriv_scaled_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Bi_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_Bi_scaled: double * gsl_mode_t -> double;
  fun gsl_sf_airy_Bi_scaled_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_zero_Ai: uint -> double;
  fun gsl_sf_airy_zero_Ai_deriv: uint -> double;
  fun gsl_sf_airy_zero_Ai_deriv_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_zero_Ai_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_zero_Bi: uint -> double;
  fun gsl_sf_airy_zero_Bi_deriv: uint -> double;
  fun gsl_sf_airy_zero_Bi_deriv_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_airy_zero_Bi_e: uint * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_bessel_lib.flx')
@select(h)
//Module        : gsl_sf_bessel_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_bessel.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_BESSEL_H__
header '#include "gsl_sf_bessel.h"';

//INCLUDES
include "gsl_mode_lib";
include "gsl_sf_result_lib";

module gsl_sf_bessel_h
{
  open C_hack;
  open gsl_mode_h;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_bessel_I0: double -> double;
  fun gsl_sf_bessel_I0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_I0_scaled: double -> double;
  fun gsl_sf_bessel_I0_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_I1: double -> double;
  fun gsl_sf_bessel_I1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_I1_scaled: double -> double;
  fun gsl_sf_bessel_I1_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_In: int * double -> double;
  fun gsl_sf_bessel_In_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_bessel_In_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_In_scaled: int * double -> double;
  fun gsl_sf_bessel_In_scaled_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_bessel_In_scaled_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Inu: double * double -> double;
  fun gsl_sf_bessel_Inu_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Inu_scaled: double * double -> double;
  fun gsl_sf_bessel_Inu_scaled_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_J0: double -> double;
  fun gsl_sf_bessel_J0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_J1: double -> double;
  fun gsl_sf_bessel_J1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Jn: int * double -> double;
  fun gsl_sf_bessel_Jn_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_bessel_Jn_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Jnu: double * double -> double;
  fun gsl_sf_bessel_Jnu_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_K0: double -> double;
  fun gsl_sf_bessel_K0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_K0_scaled: double -> double;
  fun gsl_sf_bessel_K0_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_K1: double -> double;
  fun gsl_sf_bessel_K1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_K1_scaled: double -> double;
  fun gsl_sf_bessel_K1_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Kn: int * double -> double;
  fun gsl_sf_bessel_Kn_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_bessel_Kn_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Kn_scaled: int * double -> double;
  fun gsl_sf_bessel_Kn_scaled_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_bessel_Kn_scaled_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Knu: double * double -> double;
  fun gsl_sf_bessel_Knu_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Knu_scaled: double * double -> double;
  fun gsl_sf_bessel_Knu_scaled_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Y0: double -> double;
  fun gsl_sf_bessel_Y0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Y1: double -> double;
  fun gsl_sf_bessel_Y1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Yn: int * double -> double;
  fun gsl_sf_bessel_Yn_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_bessel_Yn_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_Ynu: double * double -> double;
  fun gsl_sf_bessel_Ynu_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_i0_scaled: double -> double;
  fun gsl_sf_bessel_i0_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_i1_scaled: double -> double;
  fun gsl_sf_bessel_i1_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_i2_scaled: double -> double;
  fun gsl_sf_bessel_i2_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_il_scaled: int * double -> double;
  fun gsl_sf_bessel_il_scaled_array: int * double * ptr[double] -> int;
  fun gsl_sf_bessel_il_scaled_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_j0: double -> double;
  fun gsl_sf_bessel_j0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_j1: double -> double;
  fun gsl_sf_bessel_j1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_j2: double -> double;
  fun gsl_sf_bessel_j2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_jl: int * double -> double;
  fun gsl_sf_bessel_jl_array: int * double * ptr[double] -> int;
  fun gsl_sf_bessel_jl_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_jl_steed_array: int * double * ptr[double] -> int;
  fun gsl_sf_bessel_k0_scaled: double -> double;
  fun gsl_sf_bessel_k0_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_k1_scaled: double -> double;
  fun gsl_sf_bessel_k1_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_k2_scaled: double -> double;
  fun gsl_sf_bessel_k2_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_kl_scaled: int * double -> double;
  fun gsl_sf_bessel_kl_scaled_array: int * double * ptr[double] -> int;
  fun gsl_sf_bessel_kl_scaled_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_lnKnu: double * double -> double;
  fun gsl_sf_bessel_lnKnu_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_sequence_Jnu_e: double * gsl_mode_t * size * ptr[double] -> int;
  fun gsl_sf_bessel_y0: double -> double;
  fun gsl_sf_bessel_y0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_y1: double -> double;
  fun gsl_sf_bessel_y1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_y2: double -> double;
  fun gsl_sf_bessel_y2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_yl: int * double -> double;
  fun gsl_sf_bessel_yl_array: int * double * ptr[double] -> int;
  fun gsl_sf_bessel_yl_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_zero_J0: uint -> double;
  fun gsl_sf_bessel_zero_J0_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_zero_J1: uint -> double;
  fun gsl_sf_bessel_zero_J1_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_bessel_zero_Jnu: double * uint -> double;
  fun gsl_sf_bessel_zero_Jnu_e: double * uint * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_clausen_lib.flx')
@select(h)
//Module        : gsl_sf_clausen_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_clausen.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_CLAUSEN_H__
header '#include "gsl_sf_clausen.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_clausen_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_clausen: double -> double;
  fun gsl_sf_clausen_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_coulomb_lib.flx')
@select(h)
//Module        : gsl_sf_coulomb_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_coulomb.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_COULOMB_H__
header '#include "gsl_sf_coulomb.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_coulomb_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_coulomb_CL_array: double * int * double * ptr[double] -> int;
  fun gsl_sf_coulomb_CL_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_coulomb_wave_FG_array: double * int * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_sf_coulomb_wave_FG_e: double * double * double * int * ptr[gsl_sf_result] * ptr[gsl_sf_result] * ptr[gsl_sf_result] * ptr[gsl_sf_result] * ptr[double] * ptr[double] -> int;
  fun gsl_sf_coulomb_wave_FGp_array: double * int * double * double * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] * ptr[double] -> int;
  fun gsl_sf_coulomb_wave_F_array: double * int * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_sf_coulomb_wave_sphF_array: double * int * double * double * ptr[double] * ptr[double] -> int;
  fun gsl_sf_hydrogenicR: int * int * double * double -> double;
  fun gsl_sf_hydrogenicR_1: double * double -> double;
  fun gsl_sf_hydrogenicR_1_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hydrogenicR_e: int * int * double * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_coupling_lib.flx')
@select(h)
//Module        : gsl_sf_coupling_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_coupling.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_COUPLING_H__
header '#include "gsl_sf_coupling.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_coupling_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_coupling_3j: int * int * int * int * int * int -> double;
  fun gsl_sf_coupling_3j_e: int * int * int * int * int * int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_coupling_6j: int * int * int * int * int * int -> double;
  fun gsl_sf_coupling_6j_INCORRECT: int * int * int * int * int * int -> double;
  fun gsl_sf_coupling_6j_INCORRECT_e: int * int * int * int * int * int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_coupling_6j_e: int * int * int * int * int * int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_coupling_9j: int * int * int * int * int * int * int * int * int -> double;
  fun gsl_sf_coupling_9j_e: int * int * int * int * int * int * int * int * int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_coupling_RacahW: int * int * int * int * int * int -> double;
  fun gsl_sf_coupling_RacahW_e: int * int * int * int * int * int * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_dawson_lib.flx')
@select(h)
//Module        : gsl_sf_dawson_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_dawson.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_DAWSON_H__
header '#include "gsl_sf_dawson.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_dawson_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_dawson: double -> double;
  fun gsl_sf_dawson_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_debye_lib.flx')
@select(h)
//Module        : gsl_sf_debye_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_debye.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_DEBYE_H__
header '#include "gsl_sf_debye.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_debye_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_debye_1: double -> double;
  fun gsl_sf_debye_1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_debye_2: double -> double;
  fun gsl_sf_debye_2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_debye_3: double -> double;
  fun gsl_sf_debye_3_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_debye_4: double -> double;
  fun gsl_sf_debye_4_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_dilog_lib.flx')
@select(h)
//Module        : gsl_sf_dilog_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_dilog.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_DILOG_H__
header '#include "gsl_sf_dilog.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_dilog_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_complex_dilog_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_complex_dilog_xy_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_complex_spence_xy_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_dilog: double -> double;
  fun gsl_sf_dilog_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_elementary_lib.flx')
@select(h)
//Module        : gsl_sf_elementary_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_elementary.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_ELEMENTARY_H__
header '#include "gsl_sf_elementary.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_elementary_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_multiply: double * double -> double;
  fun gsl_sf_multiply_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_multiply_err_e: double * double * double * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_ellint_lib.flx')
@select(h)
//Module        : gsl_sf_ellint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_ellint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_ELLINT_H__
header '#include "gsl_sf_ellint.h"';

//INCLUDES
include "gsl_mode_lib";
include "gsl_sf_result_lib";

module gsl_sf_ellint_h
{
  open C_hack;
  open gsl_mode_h;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_ellint_D: double * double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_D_e: double * double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_E: double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_E_e: double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_Ecomp: double * gsl_mode_t -> double;
  fun gsl_sf_ellint_Ecomp_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_F: double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_F_e: double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_Kcomp: double * gsl_mode_t -> double;
  fun gsl_sf_ellint_Kcomp_e: double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_P: double * double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_P_e: double * double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_RC: double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_RC_e: double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_RD: double * double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_RD_e: double * double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_RF: double * double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_RF_e: double * double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
  fun gsl_sf_ellint_RJ: double * double * double * double * gsl_mode_t -> double;
  fun gsl_sf_ellint_RJ_e: double * double * double * double * gsl_mode_t * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_elljac_lib.flx')
@select(h)
//Module        : gsl_sf_elljac_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_elljac.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_ELLJAC_H__
header '#include "gsl_sf_elljac.h"';

module gsl_sf_elljac_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_sf_elljac_e: double * double * ptr[double] * ptr[double] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_sf_erf_lib.flx')
@select(h)
//Module        : gsl_sf_erf_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_erf.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_ERF_H__
header '#include "gsl_sf_erf.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_erf_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_erf: double -> double;
  fun gsl_sf_erf_Q: double -> double;
  fun gsl_sf_erf_Q_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_erf_Z: double -> double;
  fun gsl_sf_erf_Z_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_erf_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_erfc: double -> double;
  fun gsl_sf_erfc_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hazard: double -> double;
  fun gsl_sf_hazard_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_log_erfc: double -> double;
  fun gsl_sf_log_erfc_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_expint_lib.flx')
@select(h)
//Module        : gsl_sf_expint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_expint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_EXPINT_H__
header '#include "gsl_sf_expint.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_expint_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_Chi: double -> double;
  fun gsl_sf_Chi_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_Ci: double -> double;
  fun gsl_sf_Ci_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_Shi: double -> double;
  fun gsl_sf_Shi_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_Si: double -> double;
  fun gsl_sf_Si_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_atanint: double -> double;
  fun gsl_sf_atanint_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_3: double -> double;
  fun gsl_sf_expint_3_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_E1: double -> double;
  fun gsl_sf_expint_E1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_E1_scaled: double -> double;
  fun gsl_sf_expint_E1_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_E2: double -> double;
  fun gsl_sf_expint_E2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_E2_scaled: double -> double;
  fun gsl_sf_expint_E2_scaled_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_Ei: double -> double;
  fun gsl_sf_expint_Ei_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_expint_Ei_scaled: double -> double;
  fun gsl_sf_expint_Ei_scaled_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_exp_lib.flx')
@select(h)
//Module        : gsl_sf_exp_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_exp.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_EXP_H__
header '#include "gsl_sf_exp.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_exp_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_exp: double -> double;
  fun gsl_sf_exp_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exp_e10_e: double * ptr[gsl_sf_result_e10] -> int;
  fun gsl_sf_exp_err_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exp_err_e10_e: double * double * ptr[gsl_sf_result_e10] -> int;
  fun gsl_sf_exp_mult: double * double -> double;
  fun gsl_sf_exp_mult_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exp_mult_e10_e: double * double * ptr[gsl_sf_result_e10] -> int;
  fun gsl_sf_exp_mult_err_e: double * double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exp_mult_err_e10_e: double * double * double * double * ptr[gsl_sf_result_e10] -> int;
  fun gsl_sf_expm1: double -> double;
  fun gsl_sf_expm1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exprel: double -> double;
  fun gsl_sf_exprel_2: double -> double;
  fun gsl_sf_exprel_2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exprel_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_exprel_n: int * double -> double;
  fun gsl_sf_exprel_n_e: int * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_fermi_dirac_lib.flx')
@select(h)
//Module        : gsl_sf_fermi_dirac_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_fermi_dirac.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_FERMI_DIRAC_H__
header '#include "gsl_sf_fermi_dirac.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_fermi_dirac_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_fermi_dirac_0: double -> double;
  fun gsl_sf_fermi_dirac_0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_1: double -> double;
  fun gsl_sf_fermi_dirac_1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_2: double -> double;
  fun gsl_sf_fermi_dirac_2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_3half: double -> double;
  fun gsl_sf_fermi_dirac_3half_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_half: double -> double;
  fun gsl_sf_fermi_dirac_half_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_inc_0: double * double -> double;
  fun gsl_sf_fermi_dirac_inc_0_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_int: int * double -> double;
  fun gsl_sf_fermi_dirac_int_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_m1: double -> double;
  fun gsl_sf_fermi_dirac_m1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fermi_dirac_mhalf: double -> double;
  fun gsl_sf_fermi_dirac_mhalf_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_gamma_lib.flx')
@select(h)
//Module        : gsl_sf_gamma_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_gamma.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_SF_GAMMA_XMAX  171.0
//#define __GSL_SF_GAMMA_H__
header '#include "gsl_sf_gamma.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_gamma_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_beta: double * double -> double;
  fun gsl_sf_beta_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_beta_inc: double * double * double -> double;
  fun gsl_sf_beta_inc_e: double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_choose: uint * uint -> double;
  fun gsl_sf_choose_e: uint * uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_doublefact: uint -> double;
  fun gsl_sf_doublefact_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_fact: uint -> double;
  fun gsl_sf_fact_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gamma: double -> double;
  fun gsl_sf_gamma_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gamma_inc: double * double -> double;
  fun gsl_sf_gamma_inc_P: double * double -> double;
  fun gsl_sf_gamma_inc_P_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gamma_inc_Q: double * double -> double;
  fun gsl_sf_gamma_inc_Q_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gamma_inc_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gammainv: double -> double;
  fun gsl_sf_gammainv_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gammastar: double -> double;
  fun gsl_sf_gammastar_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lnbeta: double * double -> double;
  fun gsl_sf_lnbeta_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lnchoose: uint * uint -> double;
  fun gsl_sf_lnchoose_e: uint * uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lndoublefact: uint -> double;
  fun gsl_sf_lndoublefact_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lnfact: uint -> double;
  fun gsl_sf_lnfact_e: uint * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lngamma: double -> double;
  fun gsl_sf_lngamma_complex_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lngamma_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lngamma_sgn_e: double * ptr[gsl_sf_result] * ptr[double] -> int;
  fun gsl_sf_lnpoch: double * double -> double;
  fun gsl_sf_lnpoch_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lnpoch_sgn_e: double * double * ptr[gsl_sf_result] * ptr[double] -> int;
  fun gsl_sf_poch: double * double -> double;
  fun gsl_sf_poch_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_pochrel: double * double -> double;
  fun gsl_sf_pochrel_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_taylorcoeff: int * double -> double;
  fun gsl_sf_taylorcoeff_e: int * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_gegenbauer_lib.flx')
@select(h)
//Module        : gsl_sf_gegenbauer_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_gegenbauer.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_GEGENBAUER_H__
header '#include "gsl_sf_gegenbauer.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_gegenbauer_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_gegenpoly_1: double * double -> double;
  fun gsl_sf_gegenpoly_1_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gegenpoly_2: double * double -> double;
  fun gsl_sf_gegenpoly_2_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gegenpoly_3: double * double -> double;
  fun gsl_sf_gegenpoly_3_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_gegenpoly_array: int * double * double * ptr[double] -> int;
  fun gsl_sf_gegenpoly_n: int * double * double -> double;
  fun gsl_sf_gegenpoly_n_e: int * double * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_hyperg_lib.flx')
@select(h)
//Module        : gsl_sf_hyperg_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_hyperg.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_HYPERG_H__
header '#include "gsl_sf_hyperg.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_hyperg_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_hyperg_0F1: double * double -> double;
  fun gsl_sf_hyperg_0F1_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_1F1: double * double * double -> double;
  fun gsl_sf_hyperg_1F1_e: double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_1F1_int: int * int * double -> double;
  fun gsl_sf_hyperg_1F1_int_e: int * int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_2F0: double * double * double -> double;
  fun gsl_sf_hyperg_2F0_e: double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_2F1: double * double * double * double -> double;
  fun gsl_sf_hyperg_2F1_conj: double * double * double * double -> double;
  fun gsl_sf_hyperg_2F1_conj_e: double * double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_2F1_conj_renorm: double * double * double * double -> double;
  fun gsl_sf_hyperg_2F1_conj_renorm_e: double * double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_2F1_e: double * double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_2F1_renorm: double * double * double * double -> double;
  fun gsl_sf_hyperg_2F1_renorm_e: double * double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_U: double * double * double -> double;
  fun gsl_sf_hyperg_U_e: double * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_U_e10_e: double * double * double * ptr[gsl_sf_result_e10] -> int;
  fun gsl_sf_hyperg_U_int: int * int * double -> double;
  fun gsl_sf_hyperg_U_int_e: int * int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hyperg_U_int_e10_e: int * int * double * ptr[gsl_sf_result_e10] -> int;
}
@h=tangler('lib/gsl/gsl_sf_laguerre_lib.flx')
@select(h)
//Module        : gsl_sf_laguerre_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_laguerre.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_LAGUERRE_H__
header '#include "gsl_sf_laguerre.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_laguerre_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_laguerre_1: double * double -> double;
  fun gsl_sf_laguerre_1_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_laguerre_2: double * double -> double;
  fun gsl_sf_laguerre_2_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_laguerre_3: double * double -> double;
  fun gsl_sf_laguerre_3_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_laguerre_n: int * double * double -> double;
  fun gsl_sf_laguerre_n_e: int * double * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_lambert_lib.flx')
@select(h)
//Module        : gsl_sf_lambert_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_lambert.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_LAMBERT_H__
header '#include "gsl_sf_lambert.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_lambert_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_lambert_W0: double -> double;
  fun gsl_sf_lambert_W0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lambert_Wm1: double -> double;
  fun gsl_sf_lambert_Wm1_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_legendre_lib.flx')
@select(h)
//Module        : gsl_sf_legendre_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_legendre.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_LEGENDRE_H__
header '#include "gsl_sf_legendre.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_legendre_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_conicalP_0: double * double -> double;
  fun gsl_sf_conicalP_0_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_conicalP_1: double * double -> double;
  fun gsl_sf_conicalP_1_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_conicalP_cyl_reg: int * double * double -> double;
  fun gsl_sf_conicalP_cyl_reg_e: int * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_conicalP_half: double * double -> double;
  fun gsl_sf_conicalP_half_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_conicalP_mhalf: double * double -> double;
  fun gsl_sf_conicalP_mhalf_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_conicalP_sph_reg: int * double * double -> double;
  fun gsl_sf_conicalP_sph_reg_e: int * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_H3d: int * double * double -> double;
  fun gsl_sf_legendre_H3d_0: double * double -> double;
  fun gsl_sf_legendre_H3d_0_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_H3d_1: double * double -> double;
  fun gsl_sf_legendre_H3d_1_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_H3d_array: int * double * double * ptr[double] -> int;
  fun gsl_sf_legendre_H3d_e: int * double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_P1: double -> double;
  fun gsl_sf_legendre_P1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_P2: double -> double;
  fun gsl_sf_legendre_P2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_P3: double -> double;
  fun gsl_sf_legendre_P3_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_Pl: int * double -> double;
  fun gsl_sf_legendre_Pl_array: int * double * ptr[double] -> int;
  fun gsl_sf_legendre_Pl_deriv_array: int * double * ptr[double] * ptr[double] -> int;
  fun gsl_sf_legendre_Pl_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_Plm: int * int * double -> double;
  fun gsl_sf_legendre_Plm_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_legendre_Plm_deriv_array: int * int * double * ptr[double] * ptr[double] -> int;
  fun gsl_sf_legendre_Plm_e: int * int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_Q0: double -> double;
  fun gsl_sf_legendre_Q0_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_Q1: double -> double;
  fun gsl_sf_legendre_Q1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_Ql: int * double -> double;
  fun gsl_sf_legendre_Ql_e: int * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_legendre_array_size: int * int -> int;
  fun gsl_sf_legendre_sphPlm: int * int * double -> double;
  fun gsl_sf_legendre_sphPlm_array: int * int * double * ptr[double] -> int;
  fun gsl_sf_legendre_sphPlm_deriv_array: int * int * double * ptr[double] * ptr[double] -> int;
  fun gsl_sf_legendre_sphPlm_e: int * int * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_lib.flx')
@select(h)
//Module        : gsl_sf_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_H__
header '#include "gsl_sf.h"';

module gsl_sf_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_sf_log_lib.flx')
@select(h)
//Module        : gsl_sf_log_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_log.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_LOG_H__
header '#include "gsl_sf_log.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_log_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_complex_log_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_log: double -> double;
  fun gsl_sf_log_1plusx: double -> double;
  fun gsl_sf_log_1plusx_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_log_1plusx_mx: double -> double;
  fun gsl_sf_log_1plusx_mx_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_log_abs: double -> double;
  fun gsl_sf_log_abs_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_log_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_pow_int_lib.flx')
@select(h)
//Module        : gsl_sf_pow_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_pow_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_POW_INT_H__
header '#include "gsl_sf_pow_int.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_pow_int_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_pow_int: double * int -> double;
  fun gsl_sf_pow_int_e: double * int * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_psi_lib.flx')
@select(h)
//Module        : gsl_sf_psi_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_psi.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_PSI_H__
header '#include "gsl_sf_psi.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_psi_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_psi: double -> double;
  fun gsl_sf_psi_1: double -> double;
  fun gsl_sf_psi_1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_psi_1_int: int -> double;
  fun gsl_sf_psi_1_int_e: int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_psi_1piy: double -> double;
  fun gsl_sf_psi_1piy_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_psi_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_psi_int: int -> double;
  fun gsl_sf_psi_int_e: int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_psi_n: int * double -> double;
  fun gsl_sf_psi_n_e: int * double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_result_e10_struct_lib.flx')
@select(h)
//Module        : gsl_sf_result_e10_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_result_e10_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_sf_result_e10_struct"';

module gsl_sf_result_e10_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_sf_result_lib.flx')
@select(h)
//Module        : gsl_sf_result_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_result.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_SF_RESULT_SET(r,v,e) do { (r)->val=(v); (r)->err=(e); } while(0)
//#define __GSL_SF_RESULT_H__
header '#include "gsl_sf_result.h"';

//INCLUDES
include "gsl_sf_result_e10_struct_lib";
include "gsl_sf_result_struct_lib";

module gsl_sf_result_h
{
  open C_hack;
  open gsl_sf_result_e10_struct_h;
  open gsl_sf_result_struct_h;
  
  //CSTRUCTS 
  cstruct gsl_sf_result_e10_struct {
    val_: double;
    err: double;
    e10: int;
  }
  cstruct gsl_sf_result_struct {
    val_: double;
    err: double;
  }
  
  //STRUCT or UNION TAG ALIASES
  typedef gsl_sf_result = gsl_sf_result_struct;
  typedef gsl_sf_result_e10 = gsl_sf_result_e10_struct;
  
  //TYPE ALIASES
  typedef _struct_gsl_sf_result_e10_struct = gsl_sf_result_e10_struct;
  typedef _struct_gsl_sf_result_struct = gsl_sf_result_struct;
  
  //FUNCTIONS
  fun gsl_sf_result_smash_e: cptr[gsl_sf_result_e10] * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_result_struct_lib.flx')
@select(h)
//Module        : gsl_sf_result_struct_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_result_struct
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

header '#include "gsl_sf_result_struct"';

module gsl_sf_result_struct_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_sf_synchrotron_lib.flx')
@select(h)
//Module        : gsl_sf_synchrotron_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_synchrotron.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_SYNCHROTRON_H__
header '#include "gsl_sf_synchrotron.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_synchrotron_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_synchrotron_1: double -> double;
  fun gsl_sf_synchrotron_1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_synchrotron_2: double -> double;
  fun gsl_sf_synchrotron_2_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_transport_lib.flx')
@select(h)
//Module        : gsl_sf_transport_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_transport.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_TRANSPORT_H__
header '#include "gsl_sf_transport.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_transport_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_transport_2: double -> double;
  fun gsl_sf_transport_2_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_transport_3: double -> double;
  fun gsl_sf_transport_3_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_transport_4: double -> double;
  fun gsl_sf_transport_4_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_transport_5: double -> double;
  fun gsl_sf_transport_5_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_trig_lib.flx')
@select(h)
//Module        : gsl_sf_trig_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_trig.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_TRIG_H__
header '#include "gsl_sf_trig.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_trig_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_angle_restrict_pos: double -> double;
  fun gsl_sf_angle_restrict_pos_e: ptr[double] -> int;
  fun gsl_sf_angle_restrict_pos_err_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_angle_restrict_symm: double -> double;
  fun gsl_sf_angle_restrict_symm_e: ptr[double] -> int;
  fun gsl_sf_angle_restrict_symm_err_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_complex_cos_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_complex_logsin_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_complex_sin_e: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_cos: double -> double;
  fun gsl_sf_cos_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_cos_err_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hypot: double * double -> double;
  fun gsl_sf_hypot_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lncosh: double -> double;
  fun gsl_sf_lncosh_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_lnsinh: double -> double;
  fun gsl_sf_lnsinh_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_polar_to_rect: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_rect_to_polar: double * double * ptr[gsl_sf_result] * ptr[gsl_sf_result] -> int;
  fun gsl_sf_sin: double -> double;
  fun gsl_sf_sin_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_sin_err_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_sinc: double -> double;
  fun gsl_sf_sinc_e: double * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_sf_zeta_lib.flx')
@select(h)
//Module        : gsl_sf_zeta_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sf_zeta.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SF_ZETA_H__
header '#include "gsl_sf_zeta.h"';

//INCLUDES
include "gsl_sf_result_lib";

module gsl_sf_zeta_h
{
  open C_hack;
  open gsl_sf_result_h;
  
  //FUNCTIONS
  fun gsl_sf_eta: double -> double;
  fun gsl_sf_eta_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_eta_int: int -> double;
  fun gsl_sf_eta_int_e: int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_hzeta: double * double -> double;
  fun gsl_sf_hzeta_e: double * double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_zeta: double -> double;
  fun gsl_sf_zeta_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_zeta_int: int -> double;
  fun gsl_sf_zeta_int_e: int * ptr[gsl_sf_result] -> int;
  fun gsl_sf_zetam1: double -> double;
  fun gsl_sf_zetam1_e: double * ptr[gsl_sf_result] -> int;
  fun gsl_sf_zetam1_int: int -> double;
  fun gsl_sf_zetam1_int_e: int * ptr[gsl_sf_result] -> int;
}
@h=tangler('lib/gsl/gsl_siman_lib.flx')
@select(h)
//Module        : gsl_siman_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_siman.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SIMAN_H__
header '#include "gsl_siman.h"';

//INCLUDES
include "gsl_rng_lib";

module gsl_siman_h
{
  open C_hack;
  open gsl_rng_h;
  
  //ABSTRACT TYPES
  type gsl_siman_params_t = 'gsl_siman_params_t';
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*gsl_siman_h_cft_2)(gsl_rng const *, void *,  double);''';
  type gsl_siman_h_cft_2 = 'gsl_siman_h_cft_2';
  header '''typedef void (*gsl_siman_h_cft_5)(void *, void *);''';
  type gsl_siman_h_cft_5 = 'gsl_siman_h_cft_5';
  header '''typedef double (*gsl_siman_h_cft_3)(void *, void *);''';
  type gsl_siman_h_cft_3 = 'gsl_siman_h_cft_3';
  header '''typedef void *(*gsl_siman_h_cft_6)(void *);''';
  type gsl_siman_h_cft_6 = 'gsl_siman_h_cft_6';
  header '''typedef void (*gsl_siman_h_cft_4)(void *);''';
  type gsl_siman_h_cft_4 = 'gsl_siman_h_cft_4';
  header '''typedef double (*gsl_siman_h_cft_1)(void *);''';
  type gsl_siman_h_cft_1 = 'gsl_siman_h_cft_1';
  
  //TYPE ALIASES
  typedef gsl_siman_Efunc_t = gsl_siman_h_cft_1;
  typedef gsl_siman_step_t = gsl_siman_h_cft_2;
  typedef gsl_siman_copy_t = gsl_siman_h_cft_5;
  typedef gsl_siman_metric_t = gsl_siman_h_cft_3;
  typedef gsl_siman_destroy_t = gsl_siman_h_cft_4;
  typedef gsl_siman_print_t = gsl_siman_h_cft_4;
  typedef gsl_siman_copy_construct_t = gsl_siman_h_cft_6;
  
  //PROCEDURES
  proc gsl_siman_solve: cptr[gsl_rng] * address * gsl_siman_h_cft_1 * gsl_siman_h_cft_2 * gsl_siman_h_cft_3 * gsl_siman_h_cft_4 * gsl_siman_h_cft_5 * gsl_siman_h_cft_6 * gsl_siman_h_cft_4 * size * gsl_siman_params_t;
  proc gsl_siman_solve_many: cptr[gsl_rng] * address * gsl_siman_h_cft_1 * gsl_siman_h_cft_2 * gsl_siman_h_cft_3 * gsl_siman_h_cft_4 * size * gsl_siman_params_t;
}
@h=tangler('lib/gsl/gsl_sort_char_lib.flx')
@select(h)
//Module        : gsl_sort_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_CHAR_H__
header '#include "gsl_sort_char.h"';

module gsl_sort_char_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_char: ptr[char] * size * size;
  proc gsl_sort_char_index: ptr[size] * cptr[char] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_char_largest: ptr[char] * size * cptr[char] * size * size -> int;
  fun gsl_sort_char_largest_index: ptr[size] * size * cptr[char] * size * size -> int;
  fun gsl_sort_char_smallest: ptr[char] * size * cptr[char] * size * size -> int;
  fun gsl_sort_char_smallest_index: ptr[size] * size * cptr[char] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_double_lib.flx')
@select(h)
//Module        : gsl_sort_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_DOUBLE_H__
header '#include "gsl_sort_double.h"';

module gsl_sort_double_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort: ptr[double] * size * size;
  proc gsl_sort_index: ptr[size] * cptr[double] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_largest: ptr[double] * size * cptr[double] * size * size -> int;
  fun gsl_sort_largest_index: ptr[size] * size * cptr[double] * size * size -> int;
  fun gsl_sort_smallest: ptr[double] * size * cptr[double] * size * size -> int;
  fun gsl_sort_smallest_index: ptr[size] * size * cptr[double] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_float_lib.flx')
@select(h)
//Module        : gsl_sort_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_FLOAT_H__
header '#include "gsl_sort_float.h"';

module gsl_sort_float_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_float: ptr[float] * size * size;
  proc gsl_sort_float_index: ptr[size] * cptr[float] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_float_largest: ptr[float] * size * cptr[float] * size * size -> int;
  fun gsl_sort_float_largest_index: ptr[size] * size * cptr[float] * size * size -> int;
  fun gsl_sort_float_smallest: ptr[float] * size * cptr[float] * size * size -> int;
  fun gsl_sort_float_smallest_index: ptr[size] * size * cptr[float] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_int_lib.flx')
@select(h)
//Module        : gsl_sort_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_INT_H__
header '#include "gsl_sort_int.h"';

module gsl_sort_int_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_int: ptr[int] * size * size;
  proc gsl_sort_int_index: ptr[size] * cptr[int] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_int_largest: ptr[int] * size * cptr[int] * size * size -> int;
  fun gsl_sort_int_largest_index: ptr[size] * size * cptr[int] * size * size -> int;
  fun gsl_sort_int_smallest: ptr[int] * size * cptr[int] * size * size -> int;
  fun gsl_sort_int_smallest_index: ptr[size] * size * cptr[int] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_lib.flx')
@select(h)
//Module        : gsl_sort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_H__
header '#include "gsl_sort.h"';

module gsl_sort_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_sort_long_double_lib.flx')
@select(h)
//Module        : gsl_sort_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_LONG_DOUBLE_H__
header '#include "gsl_sort_long_double.h"';

module gsl_sort_long_double_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_long_double: ptr[ldouble] * size * size;
  proc gsl_sort_long_double_index: ptr[size] * cptr[ldouble] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_long_double_largest: ptr[ldouble] * size * cptr[ldouble] * size * size -> int;
  fun gsl_sort_long_double_largest_index: ptr[size] * size * cptr[ldouble] * size * size -> int;
  fun gsl_sort_long_double_smallest: ptr[ldouble] * size * cptr[ldouble] * size * size -> int;
  fun gsl_sort_long_double_smallest_index: ptr[size] * size * cptr[ldouble] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_long_lib.flx')
@select(h)
//Module        : gsl_sort_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_LONG_H__
header '#include "gsl_sort_long.h"';

module gsl_sort_long_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_long: ptr[long] * size * size;
  proc gsl_sort_long_index: ptr[size] * cptr[long] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_long_largest: ptr[long] * size * cptr[long] * size * size -> int;
  fun gsl_sort_long_largest_index: ptr[size] * size * cptr[long] * size * size -> int;
  fun gsl_sort_long_smallest: ptr[long] * size * cptr[long] * size * size -> int;
  fun gsl_sort_long_smallest_index: ptr[size] * size * cptr[long] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_short_lib.flx')
@select(h)
//Module        : gsl_sort_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_SHORT_H__
header '#include "gsl_sort_short.h"';

module gsl_sort_short_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_short: ptr[short] * size * size;
  proc gsl_sort_short_index: ptr[size] * cptr[short] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_short_largest: ptr[short] * size * cptr[short] * size * size -> int;
  fun gsl_sort_short_largest_index: ptr[size] * size * cptr[short] * size * size -> int;
  fun gsl_sort_short_smallest: ptr[short] * size * cptr[short] * size * size -> int;
  fun gsl_sort_short_smallest_index: ptr[size] * size * cptr[short] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_uchar_lib.flx')
@select(h)
//Module        : gsl_sort_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_UCHAR_H__
header '#include "gsl_sort_uchar.h"';

module gsl_sort_uchar_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_uchar: ptr[utiny] * size * size;
  proc gsl_sort_uchar_index: ptr[size] * cptr[utiny] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_uchar_largest: ptr[utiny] * size * cptr[utiny] * size * size -> int;
  fun gsl_sort_uchar_largest_index: ptr[size] * size * cptr[utiny] * size * size -> int;
  fun gsl_sort_uchar_smallest: ptr[utiny] * size * cptr[utiny] * size * size -> int;
  fun gsl_sort_uchar_smallest_index: ptr[size] * size * cptr[utiny] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_uint_lib.flx')
@select(h)
//Module        : gsl_sort_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_UINT_H__
header '#include "gsl_sort_uint.h"';

module gsl_sort_uint_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_uint: ptr[uint] * size * size;
  proc gsl_sort_uint_index: ptr[size] * cptr[uint] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_uint_largest: ptr[uint] * size * cptr[uint] * size * size -> int;
  fun gsl_sort_uint_largest_index: ptr[size] * size * cptr[uint] * size * size -> int;
  fun gsl_sort_uint_smallest: ptr[uint] * size * cptr[uint] * size * size -> int;
  fun gsl_sort_uint_smallest_index: ptr[size] * size * cptr[uint] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_ulong_lib.flx')
@select(h)
//Module        : gsl_sort_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_ULONG_H__
header '#include "gsl_sort_ulong.h"';

module gsl_sort_ulong_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_ulong: ptr[ulong] * size * size;
  proc gsl_sort_ulong_index: ptr[size] * cptr[ulong] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_ulong_largest: ptr[ulong] * size * cptr[ulong] * size * size -> int;
  fun gsl_sort_ulong_largest_index: ptr[size] * size * cptr[ulong] * size * size -> int;
  fun gsl_sort_ulong_smallest: ptr[ulong] * size * cptr[ulong] * size * size -> int;
  fun gsl_sort_ulong_smallest_index: ptr[size] * size * cptr[ulong] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_ushort_lib.flx')
@select(h)
//Module        : gsl_sort_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_USHORT_H__
header '#include "gsl_sort_ushort.h"';

module gsl_sort_ushort_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_sort_ushort: ptr[ushort] * size * size;
  proc gsl_sort_ushort_index: ptr[size] * cptr[ushort] * size * size;
  
  //FUNCTIONS
  fun gsl_sort_ushort_largest: ptr[ushort] * size * cptr[ushort] * size * size -> int;
  fun gsl_sort_ushort_largest_index: ptr[size] * size * cptr[ushort] * size * size -> int;
  fun gsl_sort_ushort_smallest: ptr[ushort] * size * cptr[ushort] * size * size -> int;
  fun gsl_sort_ushort_smallest_index: ptr[size] * size * cptr[ushort] * size * size -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_char_lib.flx')
@select(h)
//Module        : gsl_sort_vector_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_CHAR_H__
header '#include "gsl_sort_vector_char.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_char_lib";

module gsl_sort_vector_char_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_char_h;
  
  //PROCEDURES
  proc gsl_sort_vector_char: ptr[gsl_vector_char];
  
  //FUNCTIONS
  fun gsl_sort_vector_char_index: ptr[gsl_permutation] * cptr[gsl_vector_char] -> int;
  fun gsl_sort_vector_char_largest: ptr[char] * size * cptr[gsl_vector_char] -> int;
  fun gsl_sort_vector_char_largest_index: ptr[size] * size * cptr[gsl_vector_char] -> int;
  fun gsl_sort_vector_char_smallest: ptr[char] * size * cptr[gsl_vector_char] -> int;
  fun gsl_sort_vector_char_smallest_index: ptr[size] * size * cptr[gsl_vector_char] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_double_lib.flx')
@select(h)
//Module        : gsl_sort_vector_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_DOUBLE_H__
header '#include "gsl_sort_vector_double.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_double_lib";

module gsl_sort_vector_double_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_double_h;
  
  //PROCEDURES
  proc gsl_sort_vector: ptr[gsl_vector];
  
  //FUNCTIONS
  fun gsl_sort_vector_index: ptr[gsl_permutation] * cptr[gsl_vector] -> int;
  fun gsl_sort_vector_largest: ptr[double] * size * cptr[gsl_vector] -> int;
  fun gsl_sort_vector_largest_index: ptr[size] * size * cptr[gsl_vector] -> int;
  fun gsl_sort_vector_smallest: ptr[double] * size * cptr[gsl_vector] -> int;
  fun gsl_sort_vector_smallest_index: ptr[size] * size * cptr[gsl_vector] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_float_lib.flx')
@select(h)
//Module        : gsl_sort_vector_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_FLOAT_H__
header '#include "gsl_sort_vector_float.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_float_lib";

module gsl_sort_vector_float_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_float_h;
  
  //PROCEDURES
  proc gsl_sort_vector_float: ptr[gsl_vector_float];
  
  //FUNCTIONS
  fun gsl_sort_vector_float_index: ptr[gsl_permutation] * cptr[gsl_vector_float] -> int;
  fun gsl_sort_vector_float_largest: ptr[float] * size * cptr[gsl_vector_float] -> int;
  fun gsl_sort_vector_float_largest_index: ptr[size] * size * cptr[gsl_vector_float] -> int;
  fun gsl_sort_vector_float_smallest: ptr[float] * size * cptr[gsl_vector_float] -> int;
  fun gsl_sort_vector_float_smallest_index: ptr[size] * size * cptr[gsl_vector_float] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_int_lib.flx')
@select(h)
//Module        : gsl_sort_vector_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_INT_H__
header '#include "gsl_sort_vector_int.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_int_lib";

module gsl_sort_vector_int_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_int_h;
  
  //PROCEDURES
  proc gsl_sort_vector_int: ptr[gsl_vector_int];
  
  //FUNCTIONS
  fun gsl_sort_vector_int_index: ptr[gsl_permutation] * cptr[gsl_vector_int] -> int;
  fun gsl_sort_vector_int_largest: ptr[int] * size * cptr[gsl_vector_int] -> int;
  fun gsl_sort_vector_int_largest_index: ptr[size] * size * cptr[gsl_vector_int] -> int;
  fun gsl_sort_vector_int_smallest: ptr[int] * size * cptr[gsl_vector_int] -> int;
  fun gsl_sort_vector_int_smallest_index: ptr[size] * size * cptr[gsl_vector_int] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_lib.flx')
@select(h)
//Module        : gsl_sort_vector_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_H__
header '#include "gsl_sort_vector.h"';

module gsl_sort_vector_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_sort_vector_long_double_lib.flx')
@select(h)
//Module        : gsl_sort_vector_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_LONG_DOUBLE_H__
header '#include "gsl_sort_vector_long_double.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_long_double_lib";

module gsl_sort_vector_long_double_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_long_double_h;
  
  //PROCEDURES
  proc gsl_sort_vector_long_double: ptr[gsl_vector_long_double];
  
  //FUNCTIONS
  fun gsl_sort_vector_long_double_index: ptr[gsl_permutation] * cptr[gsl_vector_long_double] -> int;
  fun gsl_sort_vector_long_double_largest: ptr[ldouble] * size * cptr[gsl_vector_long_double] -> int;
  fun gsl_sort_vector_long_double_largest_index: ptr[size] * size * cptr[gsl_vector_long_double] -> int;
  fun gsl_sort_vector_long_double_smallest: ptr[ldouble] * size * cptr[gsl_vector_long_double] -> int;
  fun gsl_sort_vector_long_double_smallest_index: ptr[size] * size * cptr[gsl_vector_long_double] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_long_lib.flx')
@select(h)
//Module        : gsl_sort_vector_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_LONG_H__
header '#include "gsl_sort_vector_long.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_long_lib";

module gsl_sort_vector_long_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_long_h;
  
  //PROCEDURES
  proc gsl_sort_vector_long: ptr[gsl_vector_long];
  
  //FUNCTIONS
  fun gsl_sort_vector_long_index: ptr[gsl_permutation] * cptr[gsl_vector_long] -> int;
  fun gsl_sort_vector_long_largest: ptr[long] * size * cptr[gsl_vector_long] -> int;
  fun gsl_sort_vector_long_largest_index: ptr[size] * size * cptr[gsl_vector_long] -> int;
  fun gsl_sort_vector_long_smallest: ptr[long] * size * cptr[gsl_vector_long] -> int;
  fun gsl_sort_vector_long_smallest_index: ptr[size] * size * cptr[gsl_vector_long] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_short_lib.flx')
@select(h)
//Module        : gsl_sort_vector_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_SHORT_H__
header '#include "gsl_sort_vector_short.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_short_lib";

module gsl_sort_vector_short_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_short_h;
  
  //PROCEDURES
  proc gsl_sort_vector_short: ptr[gsl_vector_short];
  
  //FUNCTIONS
  fun gsl_sort_vector_short_index: ptr[gsl_permutation] * cptr[gsl_vector_short] -> int;
  fun gsl_sort_vector_short_largest: ptr[short] * size * cptr[gsl_vector_short] -> int;
  fun gsl_sort_vector_short_largest_index: ptr[size] * size * cptr[gsl_vector_short] -> int;
  fun gsl_sort_vector_short_smallest: ptr[short] * size * cptr[gsl_vector_short] -> int;
  fun gsl_sort_vector_short_smallest_index: ptr[size] * size * cptr[gsl_vector_short] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_uchar_lib.flx')
@select(h)
//Module        : gsl_sort_vector_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_UCHAR_H__
header '#include "gsl_sort_vector_uchar.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_uchar_lib";

module gsl_sort_vector_uchar_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_uchar_h;
  
  //PROCEDURES
  proc gsl_sort_vector_uchar: ptr[gsl_vector_uchar];
  
  //FUNCTIONS
  fun gsl_sort_vector_uchar_index: ptr[gsl_permutation] * cptr[gsl_vector_uchar] -> int;
  fun gsl_sort_vector_uchar_largest: ptr[utiny] * size * cptr[gsl_vector_uchar] -> int;
  fun gsl_sort_vector_uchar_largest_index: ptr[size] * size * cptr[gsl_vector_uchar] -> int;
  fun gsl_sort_vector_uchar_smallest: ptr[utiny] * size * cptr[gsl_vector_uchar] -> int;
  fun gsl_sort_vector_uchar_smallest_index: ptr[size] * size * cptr[gsl_vector_uchar] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_uint_lib.flx')
@select(h)
//Module        : gsl_sort_vector_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_UINT_H__
header '#include "gsl_sort_vector_uint.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_uint_lib";

module gsl_sort_vector_uint_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_uint_h;
  
  //PROCEDURES
  proc gsl_sort_vector_uint: ptr[gsl_vector_uint];
  
  //FUNCTIONS
  fun gsl_sort_vector_uint_index: ptr[gsl_permutation] * cptr[gsl_vector_uint] -> int;
  fun gsl_sort_vector_uint_largest: ptr[uint] * size * cptr[gsl_vector_uint] -> int;
  fun gsl_sort_vector_uint_largest_index: ptr[size] * size * cptr[gsl_vector_uint] -> int;
  fun gsl_sort_vector_uint_smallest: ptr[uint] * size * cptr[gsl_vector_uint] -> int;
  fun gsl_sort_vector_uint_smallest_index: ptr[size] * size * cptr[gsl_vector_uint] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_ulong_lib.flx')
@select(h)
//Module        : gsl_sort_vector_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_ULONG_H__
header '#include "gsl_sort_vector_ulong.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_ulong_lib";

module gsl_sort_vector_ulong_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_ulong_h;
  
  //PROCEDURES
  proc gsl_sort_vector_ulong: ptr[gsl_vector_ulong];
  
  //FUNCTIONS
  fun gsl_sort_vector_ulong_index: ptr[gsl_permutation] * cptr[gsl_vector_ulong] -> int;
  fun gsl_sort_vector_ulong_largest: ptr[ulong] * size * cptr[gsl_vector_ulong] -> int;
  fun gsl_sort_vector_ulong_largest_index: ptr[size] * size * cptr[gsl_vector_ulong] -> int;
  fun gsl_sort_vector_ulong_smallest: ptr[ulong] * size * cptr[gsl_vector_ulong] -> int;
  fun gsl_sort_vector_ulong_smallest_index: ptr[size] * size * cptr[gsl_vector_ulong] -> int;
}
@h=tangler('lib/gsl/gsl_sort_vector_ushort_lib.flx')
@select(h)
//Module        : gsl_sort_vector_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sort_vector_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SORT_VECTOR_USHORT_H__
header '#include "gsl_sort_vector_ushort.h"';

//INCLUDES
include "gsl_permutation_lib";
include "gsl_vector_ushort_lib";

module gsl_sort_vector_ushort_h
{
  open C_hack;
  open gsl_permutation_h;
  open gsl_vector_ushort_h;
  
  //PROCEDURES
  proc gsl_sort_vector_ushort: ptr[gsl_vector_ushort];
  
  //FUNCTIONS
  fun gsl_sort_vector_ushort_index: ptr[gsl_permutation] * cptr[gsl_vector_ushort] -> int;
  fun gsl_sort_vector_ushort_largest: ptr[ushort] * size * cptr[gsl_vector_ushort] -> int;
  fun gsl_sort_vector_ushort_largest_index: ptr[size] * size * cptr[gsl_vector_ushort] -> int;
  fun gsl_sort_vector_ushort_smallest: ptr[ushort] * size * cptr[gsl_vector_ushort] -> int;
  fun gsl_sort_vector_ushort_smallest_index: ptr[size] * size * cptr[gsl_vector_ushort] -> int;
}
@h=tangler('lib/gsl/gsl_specfunc_lib.flx')
@select(h)
//Module        : gsl_specfunc_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_specfunc.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SPECFUNC_H__
header '#include "gsl_specfunc.h"';

module gsl_specfunc_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_spline_lib.flx')
@select(h)
//Module        : gsl_spline_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_spline.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SPLINE_H__
header '#include "gsl_spline.h"';

//INCLUDES
include "gsl_interp_lib";

module gsl_spline_h
{
  open C_hack;
  open gsl_interp_h;
  
  //ABSTRACT TYPES
  type gsl_spline = 'gsl_spline';
  
  //PROCEDURES
  proc gsl_spline_free: ptr[gsl_spline];
  
  //FUNCTIONS
  fun gsl_spline_alloc: cptr[gsl_interp_type] * size -> ptr[gsl_spline];
  fun gsl_spline_eval: cptr[gsl_spline] * double * ptr[gsl_interp_accel] -> double;
  fun gsl_spline_eval_deriv: cptr[gsl_spline] * double * ptr[gsl_interp_accel] -> double;
  fun gsl_spline_eval_deriv2: cptr[gsl_spline] * double * ptr[gsl_interp_accel] -> double;
  fun gsl_spline_eval_deriv2_e: cptr[gsl_spline] * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_spline_eval_deriv_e: cptr[gsl_spline] * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_spline_eval_e: cptr[gsl_spline] * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_spline_eval_integ: cptr[gsl_spline] * double * double * ptr[gsl_interp_accel] -> double;
  fun gsl_spline_eval_integ_e: cptr[gsl_spline] * double * double * ptr[gsl_interp_accel] * ptr[double] -> int;
  fun gsl_spline_init: ptr[gsl_spline] * cptr[double] * cptr[double] * size -> int;
}
@h=tangler('lib/gsl/gsl_statistics_char_lib.flx')
@select(h)
//Module        : gsl_statistics_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_CHAR_H__
header '#include "gsl_statistics_char.h"';

module gsl_statistics_char_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_char_minmax: ptr[char] * ptr[char] * cptr[char] * size * size;
  proc gsl_stats_char_minmax_index: ptr[size] * ptr[size] * cptr[char] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_char_absdev: cptr[char] * size * size -> double;
  fun gsl_stats_char_absdev_m: cptr[char] * size * size * double -> double;
  fun gsl_stats_char_covariance: cptr[char] * size * cptr[char] * size * size -> double;
  fun gsl_stats_char_covariance_m: cptr[char] * size * cptr[char] * size * size * double * double -> double;
  fun gsl_stats_char_kurtosis: cptr[char] * size * size -> double;
  fun gsl_stats_char_kurtosis_m_sd: cptr[char] * size * size * double * double -> double;
  fun gsl_stats_char_lag1_autocorrelation: cptr[char] * size * size -> double;
  fun gsl_stats_char_lag1_autocorrelation_m: cptr[char] * size * size * double -> double;
  fun gsl_stats_char_max: cptr[char] * size * size -> char;
  fun gsl_stats_char_max_index: cptr[char] * size * size -> size;
  fun gsl_stats_char_mean: cptr[char] * size * size -> double;
  fun gsl_stats_char_median_from_sorted_data: cptr[char] * size * size -> double;
  fun gsl_stats_char_min: cptr[char] * size * size -> char;
  fun gsl_stats_char_min_index: cptr[char] * size * size -> size;
  fun gsl_stats_char_pvariance: cptr[char] * size * size * cptr[char] * size * size -> double;
  fun gsl_stats_char_quantile_from_sorted_data: cptr[char] * size * size * double -> double;
  fun gsl_stats_char_sd: cptr[char] * size * size -> double;
  fun gsl_stats_char_sd_m: cptr[char] * size * size * double -> double;
  fun gsl_stats_char_sd_with_fixed_mean: cptr[char] * size * size * double -> double;
  fun gsl_stats_char_skew: cptr[char] * size * size -> double;
  fun gsl_stats_char_skew_m_sd: cptr[char] * size * size * double * double -> double;
  fun gsl_stats_char_ttest: cptr[char] * size * size * cptr[char] * size * size -> double;
  fun gsl_stats_char_variance: cptr[char] * size * size -> double;
  fun gsl_stats_char_variance_m: cptr[char] * size * size * double -> double;
  fun gsl_stats_char_variance_with_fixed_mean: cptr[char] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_double_lib.flx')
@select(h)
//Module        : gsl_statistics_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_DOUBLE_H__
header '#include "gsl_statistics_double.h"';

module gsl_statistics_double_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_minmax: ptr[double] * ptr[double] * cptr[double] * size * size;
  proc gsl_stats_minmax_index: ptr[size] * ptr[size] * cptr[double] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_absdev: cptr[double] * size * size -> double;
  fun gsl_stats_absdev_m: cptr[double] * size * size * double -> double;
  fun gsl_stats_covariance: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_covariance_m: cptr[double] * size * cptr[double] * size * size * double * double -> double;
  fun gsl_stats_kurtosis: cptr[double] * size * size -> double;
  fun gsl_stats_kurtosis_m_sd: cptr[double] * size * size * double * double -> double;
  fun gsl_stats_lag1_autocorrelation: cptr[double] * size * size -> double;
  fun gsl_stats_lag1_autocorrelation_m: cptr[double] * size * size * double -> double;
  fun gsl_stats_max: cptr[double] * size * size -> double;
  fun gsl_stats_max_index: cptr[double] * size * size -> size;
  fun gsl_stats_mean: cptr[double] * size * size -> double;
  fun gsl_stats_median_from_sorted_data: cptr[double] * size * size -> double;
  fun gsl_stats_min: cptr[double] * size * size -> double;
  fun gsl_stats_min_index: cptr[double] * size * size -> size;
  fun gsl_stats_pvariance: cptr[double] * size * size * cptr[double] * size * size -> double;
  fun gsl_stats_quantile_from_sorted_data: cptr[double] * size * size * double -> double;
  fun gsl_stats_sd: cptr[double] * size * size -> double;
  fun gsl_stats_sd_m: cptr[double] * size * size * double -> double;
  fun gsl_stats_sd_with_fixed_mean: cptr[double] * size * size * double -> double;
  fun gsl_stats_skew: cptr[double] * size * size -> double;
  fun gsl_stats_skew_m_sd: cptr[double] * size * size * double * double -> double;
  fun gsl_stats_ttest: cptr[double] * size * size * cptr[double] * size * size -> double;
  fun gsl_stats_variance: cptr[double] * size * size -> double;
  fun gsl_stats_variance_m: cptr[double] * size * size * double -> double;
  fun gsl_stats_variance_with_fixed_mean: cptr[double] * size * size * double -> double;
  fun gsl_stats_wabsdev: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_wabsdev_m: cptr[double] * size * cptr[double] * size * size * double -> double;
  fun gsl_stats_wkurtosis: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_wkurtosis_m_sd: cptr[double] * size * cptr[double] * size * size * double * double -> double;
  fun gsl_stats_wmean: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_wsd: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_wsd_m: cptr[double] * size * cptr[double] * size * size * double -> double;
  fun gsl_stats_wsd_with_fixed_mean: cptr[double] * size * cptr[double] * size * size * double -> double;
  fun gsl_stats_wskew: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_wskew_m_sd: cptr[double] * size * cptr[double] * size * size * double * double -> double;
  fun gsl_stats_wvariance: cptr[double] * size * cptr[double] * size * size -> double;
  fun gsl_stats_wvariance_m: cptr[double] * size * cptr[double] * size * size * double -> double;
  fun gsl_stats_wvariance_with_fixed_mean: cptr[double] * size * cptr[double] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_float_lib.flx')
@select(h)
//Module        : gsl_statistics_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_FLOAT_H__
header '#include "gsl_statistics_float.h"';

module gsl_statistics_float_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_float_minmax: ptr[float] * ptr[float] * cptr[float] * size * size;
  proc gsl_stats_float_minmax_index: ptr[size] * ptr[size] * cptr[float] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_float_absdev: cptr[float] * size * size -> double;
  fun gsl_stats_float_absdev_m: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_covariance: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_covariance_m: cptr[float] * size * cptr[float] * size * size * double * double -> double;
  fun gsl_stats_float_kurtosis: cptr[float] * size * size -> double;
  fun gsl_stats_float_kurtosis_m_sd: cptr[float] * size * size * double * double -> double;
  fun gsl_stats_float_lag1_autocorrelation: cptr[float] * size * size -> double;
  fun gsl_stats_float_lag1_autocorrelation_m: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_max: cptr[float] * size * size -> float;
  fun gsl_stats_float_max_index: cptr[float] * size * size -> size;
  fun gsl_stats_float_mean: cptr[float] * size * size -> double;
  fun gsl_stats_float_median_from_sorted_data: cptr[float] * size * size -> double;
  fun gsl_stats_float_min: cptr[float] * size * size -> float;
  fun gsl_stats_float_min_index: cptr[float] * size * size -> size;
  fun gsl_stats_float_pvariance: cptr[float] * size * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_quantile_from_sorted_data: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_sd: cptr[float] * size * size -> double;
  fun gsl_stats_float_sd_m: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_sd_with_fixed_mean: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_skew: cptr[float] * size * size -> double;
  fun gsl_stats_float_skew_m_sd: cptr[float] * size * size * double * double -> double;
  fun gsl_stats_float_ttest: cptr[float] * size * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_variance: cptr[float] * size * size -> double;
  fun gsl_stats_float_variance_m: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_variance_with_fixed_mean: cptr[float] * size * size * double -> double;
  fun gsl_stats_float_wabsdev: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_wabsdev_m: cptr[float] * size * cptr[float] * size * size * double -> double;
  fun gsl_stats_float_wkurtosis: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_wkurtosis_m_sd: cptr[float] * size * cptr[float] * size * size * double * double -> double;
  fun gsl_stats_float_wmean: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_wsd: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_wsd_m: cptr[float] * size * cptr[float] * size * size * double -> double;
  fun gsl_stats_float_wsd_with_fixed_mean: cptr[float] * size * cptr[float] * size * size * double -> double;
  fun gsl_stats_float_wskew: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_wskew_m_sd: cptr[float] * size * cptr[float] * size * size * double * double -> double;
  fun gsl_stats_float_wvariance: cptr[float] * size * cptr[float] * size * size -> double;
  fun gsl_stats_float_wvariance_m: cptr[float] * size * cptr[float] * size * size * double -> double;
  fun gsl_stats_float_wvariance_with_fixed_mean: cptr[float] * size * cptr[float] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_int_lib.flx')
@select(h)
//Module        : gsl_statistics_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_INT_H__
header '#include "gsl_statistics_int.h"';

module gsl_statistics_int_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_int_minmax: ptr[int] * ptr[int] * cptr[int] * size * size;
  proc gsl_stats_int_minmax_index: ptr[size] * ptr[size] * cptr[int] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_int_absdev: cptr[int] * size * size -> double;
  fun gsl_stats_int_absdev_m: cptr[int] * size * size * double -> double;
  fun gsl_stats_int_covariance: cptr[int] * size * cptr[int] * size * size -> double;
  fun gsl_stats_int_covariance_m: cptr[int] * size * cptr[int] * size * size * double * double -> double;
  fun gsl_stats_int_kurtosis: cptr[int] * size * size -> double;
  fun gsl_stats_int_kurtosis_m_sd: cptr[int] * size * size * double * double -> double;
  fun gsl_stats_int_lag1_autocorrelation: cptr[int] * size * size -> double;
  fun gsl_stats_int_lag1_autocorrelation_m: cptr[int] * size * size * double -> double;
  fun gsl_stats_int_max: cptr[int] * size * size -> int;
  fun gsl_stats_int_max_index: cptr[int] * size * size -> size;
  fun gsl_stats_int_mean: cptr[int] * size * size -> double;
  fun gsl_stats_int_median_from_sorted_data: cptr[int] * size * size -> double;
  fun gsl_stats_int_min: cptr[int] * size * size -> int;
  fun gsl_stats_int_min_index: cptr[int] * size * size -> size;
  fun gsl_stats_int_pvariance: cptr[int] * size * size * cptr[int] * size * size -> double;
  fun gsl_stats_int_quantile_from_sorted_data: cptr[int] * size * size * double -> double;
  fun gsl_stats_int_sd: cptr[int] * size * size -> double;
  fun gsl_stats_int_sd_m: cptr[int] * size * size * double -> double;
  fun gsl_stats_int_sd_with_fixed_mean: cptr[int] * size * size * double -> double;
  fun gsl_stats_int_skew: cptr[int] * size * size -> double;
  fun gsl_stats_int_skew_m_sd: cptr[int] * size * size * double * double -> double;
  fun gsl_stats_int_ttest: cptr[int] * size * size * cptr[int] * size * size -> double;
  fun gsl_stats_int_variance: cptr[int] * size * size -> double;
  fun gsl_stats_int_variance_m: cptr[int] * size * size * double -> double;
  fun gsl_stats_int_variance_with_fixed_mean: cptr[int] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_lib.flx')
@select(h)
//Module        : gsl_statistics_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_H__
header '#include "gsl_statistics.h"';

module gsl_statistics_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_statistics_long_double_lib.flx')
@select(h)
//Module        : gsl_statistics_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_LONG_DOUBLE_H__
header '#include "gsl_statistics_long_double.h"';

module gsl_statistics_long_double_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_long_double_minmax: ptr[ldouble] * ptr[ldouble] * cptr[ldouble] * size * size;
  proc gsl_stats_long_double_minmax_index: ptr[size] * ptr[size] * cptr[ldouble] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_long_double_absdev: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_absdev_m: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_covariance: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_covariance_m: cptr[ldouble] * size * cptr[ldouble] * size * size * double * double -> double;
  fun gsl_stats_long_double_kurtosis: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_kurtosis_m_sd: cptr[ldouble] * size * size * double * double -> double;
  fun gsl_stats_long_double_lag1_autocorrelation: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_lag1_autocorrelation_m: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_max: cptr[ldouble] * size * size -> ldouble;
  fun gsl_stats_long_double_max_index: cptr[ldouble] * size * size -> size;
  fun gsl_stats_long_double_mean: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_median_from_sorted_data: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_min: cptr[ldouble] * size * size -> ldouble;
  fun gsl_stats_long_double_min_index: cptr[ldouble] * size * size -> size;
  fun gsl_stats_long_double_pvariance: cptr[ldouble] * size * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_quantile_from_sorted_data: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_sd: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_sd_m: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_sd_with_fixed_mean: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_skew: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_skew_m_sd: cptr[ldouble] * size * size * double * double -> double;
  fun gsl_stats_long_double_ttest: cptr[ldouble] * size * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_variance: cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_variance_m: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_variance_with_fixed_mean: cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_wabsdev: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_wabsdev_m: cptr[ldouble] * size * cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_wkurtosis: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_wkurtosis_m_sd: cptr[ldouble] * size * cptr[ldouble] * size * size * double * double -> double;
  fun gsl_stats_long_double_wmean: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_wsd: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_wsd_m: cptr[ldouble] * size * cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_wsd_with_fixed_mean: cptr[ldouble] * size * cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_wskew: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_wskew_m_sd: cptr[ldouble] * size * cptr[ldouble] * size * size * double * double -> double;
  fun gsl_stats_long_double_wvariance: cptr[ldouble] * size * cptr[ldouble] * size * size -> double;
  fun gsl_stats_long_double_wvariance_m: cptr[ldouble] * size * cptr[ldouble] * size * size * double -> double;
  fun gsl_stats_long_double_wvariance_with_fixed_mean: cptr[ldouble] * size * cptr[ldouble] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_long_lib.flx')
@select(h)
//Module        : gsl_statistics_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_LONG_H__
header '#include "gsl_statistics_long.h"';

module gsl_statistics_long_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_long_minmax: ptr[long] * ptr[long] * cptr[long] * size * size;
  proc gsl_stats_long_minmax_index: ptr[size] * ptr[size] * cptr[long] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_long_absdev: cptr[long] * size * size -> double;
  fun gsl_stats_long_absdev_m: cptr[long] * size * size * double -> double;
  fun gsl_stats_long_covariance: cptr[long] * size * cptr[long] * size * size -> double;
  fun gsl_stats_long_covariance_m: cptr[long] * size * cptr[long] * size * size * double * double -> double;
  fun gsl_stats_long_kurtosis: cptr[long] * size * size -> double;
  fun gsl_stats_long_kurtosis_m_sd: cptr[long] * size * size * double * double -> double;
  fun gsl_stats_long_lag1_autocorrelation: cptr[long] * size * size -> double;
  fun gsl_stats_long_lag1_autocorrelation_m: cptr[long] * size * size * double -> double;
  fun gsl_stats_long_max: cptr[long] * size * size -> long;
  fun gsl_stats_long_max_index: cptr[long] * size * size -> size;
  fun gsl_stats_long_mean: cptr[long] * size * size -> double;
  fun gsl_stats_long_median_from_sorted_data: cptr[long] * size * size -> double;
  fun gsl_stats_long_min: cptr[long] * size * size -> long;
  fun gsl_stats_long_min_index: cptr[long] * size * size -> size;
  fun gsl_stats_long_pvariance: cptr[long] * size * size * cptr[long] * size * size -> double;
  fun gsl_stats_long_quantile_from_sorted_data: cptr[long] * size * size * double -> double;
  fun gsl_stats_long_sd: cptr[long] * size * size -> double;
  fun gsl_stats_long_sd_m: cptr[long] * size * size * double -> double;
  fun gsl_stats_long_sd_with_fixed_mean: cptr[long] * size * size * double -> double;
  fun gsl_stats_long_skew: cptr[long] * size * size -> double;
  fun gsl_stats_long_skew_m_sd: cptr[long] * size * size * double * double -> double;
  fun gsl_stats_long_ttest: cptr[long] * size * size * cptr[long] * size * size -> double;
  fun gsl_stats_long_variance: cptr[long] * size * size -> double;
  fun gsl_stats_long_variance_m: cptr[long] * size * size * double -> double;
  fun gsl_stats_long_variance_with_fixed_mean: cptr[long] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_short_lib.flx')
@select(h)
//Module        : gsl_statistics_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_SHORT_H__
header '#include "gsl_statistics_short.h"';

module gsl_statistics_short_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_short_minmax: ptr[short] * ptr[short] * cptr[short] * size * size;
  proc gsl_stats_short_minmax_index: ptr[size] * ptr[size] * cptr[short] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_short_absdev: cptr[short] * size * size -> double;
  fun gsl_stats_short_absdev_m: cptr[short] * size * size * double -> double;
  fun gsl_stats_short_covariance: cptr[short] * size * cptr[short] * size * size -> double;
  fun gsl_stats_short_covariance_m: cptr[short] * size * cptr[short] * size * size * double * double -> double;
  fun gsl_stats_short_kurtosis: cptr[short] * size * size -> double;
  fun gsl_stats_short_kurtosis_m_sd: cptr[short] * size * size * double * double -> double;
  fun gsl_stats_short_lag1_autocorrelation: cptr[short] * size * size -> double;
  fun gsl_stats_short_lag1_autocorrelation_m: cptr[short] * size * size * double -> double;
  fun gsl_stats_short_max: cptr[short] * size * size -> short;
  fun gsl_stats_short_max_index: cptr[short] * size * size -> size;
  fun gsl_stats_short_mean: cptr[short] * size * size -> double;
  fun gsl_stats_short_median_from_sorted_data: cptr[short] * size * size -> double;
  fun gsl_stats_short_min: cptr[short] * size * size -> short;
  fun gsl_stats_short_min_index: cptr[short] * size * size -> size;
  fun gsl_stats_short_pvariance: cptr[short] * size * size * cptr[short] * size * size -> double;
  fun gsl_stats_short_quantile_from_sorted_data: cptr[short] * size * size * double -> double;
  fun gsl_stats_short_sd: cptr[short] * size * size -> double;
  fun gsl_stats_short_sd_m: cptr[short] * size * size * double -> double;
  fun gsl_stats_short_sd_with_fixed_mean: cptr[short] * size * size * double -> double;
  fun gsl_stats_short_skew: cptr[short] * size * size -> double;
  fun gsl_stats_short_skew_m_sd: cptr[short] * size * size * double * double -> double;
  fun gsl_stats_short_ttest: cptr[short] * size * size * cptr[short] * size * size -> double;
  fun gsl_stats_short_variance: cptr[short] * size * size -> double;
  fun gsl_stats_short_variance_m: cptr[short] * size * size * double -> double;
  fun gsl_stats_short_variance_with_fixed_mean: cptr[short] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_uchar_lib.flx')
@select(h)
//Module        : gsl_statistics_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_UCHAR_H__
header '#include "gsl_statistics_uchar.h"';

module gsl_statistics_uchar_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_uchar_minmax: ptr[utiny] * ptr[utiny] * cptr[utiny] * size * size;
  proc gsl_stats_uchar_minmax_index: ptr[size] * ptr[size] * cptr[utiny] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_uchar_absdev: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_absdev_m: cptr[utiny] * size * size * double -> double;
  fun gsl_stats_uchar_covariance: cptr[utiny] * size * cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_covariance_m: cptr[utiny] * size * cptr[utiny] * size * size * double * double -> double;
  fun gsl_stats_uchar_kurtosis: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_kurtosis_m_sd: cptr[utiny] * size * size * double * double -> double;
  fun gsl_stats_uchar_lag1_autocorrelation: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_lag1_autocorrelation_m: cptr[utiny] * size * size * double -> double;
  fun gsl_stats_uchar_max: cptr[utiny] * size * size -> utiny;
  fun gsl_stats_uchar_max_index: cptr[utiny] * size * size -> size;
  fun gsl_stats_uchar_mean: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_median_from_sorted_data: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_min: cptr[utiny] * size * size -> utiny;
  fun gsl_stats_uchar_min_index: cptr[utiny] * size * size -> size;
  fun gsl_stats_uchar_pvariance: cptr[utiny] * size * size * cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_quantile_from_sorted_data: cptr[utiny] * size * size * double -> double;
  fun gsl_stats_uchar_sd: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_sd_m: cptr[utiny] * size * size * double -> double;
  fun gsl_stats_uchar_sd_with_fixed_mean: cptr[utiny] * size * size * double -> double;
  fun gsl_stats_uchar_skew: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_skew_m_sd: cptr[utiny] * size * size * double * double -> double;
  fun gsl_stats_uchar_ttest: cptr[utiny] * size * size * cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_variance: cptr[utiny] * size * size -> double;
  fun gsl_stats_uchar_variance_m: cptr[utiny] * size * size * double -> double;
  fun gsl_stats_uchar_variance_with_fixed_mean: cptr[utiny] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_uint_lib.flx')
@select(h)
//Module        : gsl_statistics_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_UINT_H__
header '#include "gsl_statistics_uint.h"';

module gsl_statistics_uint_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_uint_minmax: ptr[uint] * ptr[uint] * cptr[uint] * size * size;
  proc gsl_stats_uint_minmax_index: ptr[size] * ptr[size] * cptr[uint] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_uint_absdev: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_absdev_m: cptr[uint] * size * size * double -> double;
  fun gsl_stats_uint_covariance: cptr[uint] * size * cptr[uint] * size * size -> double;
  fun gsl_stats_uint_covariance_m: cptr[uint] * size * cptr[uint] * size * size * double * double -> double;
  fun gsl_stats_uint_kurtosis: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_kurtosis_m_sd: cptr[uint] * size * size * double * double -> double;
  fun gsl_stats_uint_lag1_autocorrelation: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_lag1_autocorrelation_m: cptr[uint] * size * size * double -> double;
  fun gsl_stats_uint_max: cptr[uint] * size * size -> uint;
  fun gsl_stats_uint_max_index: cptr[uint] * size * size -> size;
  fun gsl_stats_uint_mean: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_median_from_sorted_data: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_min: cptr[uint] * size * size -> uint;
  fun gsl_stats_uint_min_index: cptr[uint] * size * size -> size;
  fun gsl_stats_uint_pvariance: cptr[uint] * size * size * cptr[uint] * size * size -> double;
  fun gsl_stats_uint_quantile_from_sorted_data: cptr[uint] * size * size * double -> double;
  fun gsl_stats_uint_sd: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_sd_m: cptr[uint] * size * size * double -> double;
  fun gsl_stats_uint_sd_with_fixed_mean: cptr[uint] * size * size * double -> double;
  fun gsl_stats_uint_skew: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_skew_m_sd: cptr[uint] * size * size * double * double -> double;
  fun gsl_stats_uint_ttest: cptr[uint] * size * size * cptr[uint] * size * size -> double;
  fun gsl_stats_uint_variance: cptr[uint] * size * size -> double;
  fun gsl_stats_uint_variance_m: cptr[uint] * size * size * double -> double;
  fun gsl_stats_uint_variance_with_fixed_mean: cptr[uint] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_ulong_lib.flx')
@select(h)
//Module        : gsl_statistics_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_ULONG_H__
header '#include "gsl_statistics_ulong.h"';

module gsl_statistics_ulong_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_ulong_minmax: ptr[ulong] * ptr[ulong] * cptr[ulong] * size * size;
  proc gsl_stats_ulong_minmax_index: ptr[size] * ptr[size] * cptr[ulong] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_ulong_absdev: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_absdev_m: cptr[ulong] * size * size * double -> double;
  fun gsl_stats_ulong_covariance: cptr[ulong] * size * cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_covariance_m: cptr[ulong] * size * cptr[ulong] * size * size * double * double -> double;
  fun gsl_stats_ulong_kurtosis: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_kurtosis_m_sd: cptr[ulong] * size * size * double * double -> double;
  fun gsl_stats_ulong_lag1_autocorrelation: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_lag1_autocorrelation_m: cptr[ulong] * size * size * double -> double;
  fun gsl_stats_ulong_max: cptr[ulong] * size * size -> ulong;
  fun gsl_stats_ulong_max_index: cptr[ulong] * size * size -> size;
  fun gsl_stats_ulong_mean: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_median_from_sorted_data: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_min: cptr[ulong] * size * size -> ulong;
  fun gsl_stats_ulong_min_index: cptr[ulong] * size * size -> size;
  fun gsl_stats_ulong_pvariance: cptr[ulong] * size * size * cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_quantile_from_sorted_data: cptr[ulong] * size * size * double -> double;
  fun gsl_stats_ulong_sd: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_sd_m: cptr[ulong] * size * size * double -> double;
  fun gsl_stats_ulong_sd_with_fixed_mean: cptr[ulong] * size * size * double -> double;
  fun gsl_stats_ulong_skew: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_skew_m_sd: cptr[ulong] * size * size * double * double -> double;
  fun gsl_stats_ulong_ttest: cptr[ulong] * size * size * cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_variance: cptr[ulong] * size * size -> double;
  fun gsl_stats_ulong_variance_m: cptr[ulong] * size * size * double -> double;
  fun gsl_stats_ulong_variance_with_fixed_mean: cptr[ulong] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_statistics_ushort_lib.flx')
@select(h)
//Module        : gsl_statistics_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_statistics_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_STATISTICS_USHORT_H__
header '#include "gsl_statistics_ushort.h"';

module gsl_statistics_ushort_h
{
  open C_hack;
  
  //PROCEDURES
  proc gsl_stats_ushort_minmax: ptr[ushort] * ptr[ushort] * cptr[ushort] * size * size;
  proc gsl_stats_ushort_minmax_index: ptr[size] * ptr[size] * cptr[ushort] * size * size;
  
  //FUNCTIONS
  fun gsl_stats_ushort_absdev: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_absdev_m: cptr[ushort] * size * size * double -> double;
  fun gsl_stats_ushort_covariance: cptr[ushort] * size * cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_covariance_m: cptr[ushort] * size * cptr[ushort] * size * size * double * double -> double;
  fun gsl_stats_ushort_kurtosis: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_kurtosis_m_sd: cptr[ushort] * size * size * double * double -> double;
  fun gsl_stats_ushort_lag1_autocorrelation: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_lag1_autocorrelation_m: cptr[ushort] * size * size * double -> double;
  fun gsl_stats_ushort_max: cptr[ushort] * size * size -> ushort;
  fun gsl_stats_ushort_max_index: cptr[ushort] * size * size -> size;
  fun gsl_stats_ushort_mean: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_median_from_sorted_data: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_min: cptr[ushort] * size * size -> ushort;
  fun gsl_stats_ushort_min_index: cptr[ushort] * size * size -> size;
  fun gsl_stats_ushort_pvariance: cptr[ushort] * size * size * cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_quantile_from_sorted_data: cptr[ushort] * size * size * double -> double;
  fun gsl_stats_ushort_sd: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_sd_m: cptr[ushort] * size * size * double -> double;
  fun gsl_stats_ushort_sd_with_fixed_mean: cptr[ushort] * size * size * double -> double;
  fun gsl_stats_ushort_skew: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_skew_m_sd: cptr[ushort] * size * size * double * double -> double;
  fun gsl_stats_ushort_ttest: cptr[ushort] * size * size * cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_variance: cptr[ushort] * size * size -> double;
  fun gsl_stats_ushort_variance_m: cptr[ushort] * size * size * double -> double;
  fun gsl_stats_ushort_variance_with_fixed_mean: cptr[ushort] * size * size * double -> double;
}
@h=tangler('lib/gsl/gsl_sum_lib.flx')
@select(h)
//Module        : gsl_sum_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sum.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SUM_H__
header '#include "gsl_sum.h"';

module gsl_sum_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_sum_levin_utrunc_workspace = 'gsl_sum_levin_utrunc_workspace';
  type gsl_sum_levin_u_workspace = 'gsl_sum_levin_u_workspace';
  
  //PROCEDURES
  proc gsl_sum_levin_u_free: ptr[gsl_sum_levin_u_workspace];
  proc gsl_sum_levin_utrunc_free: ptr[gsl_sum_levin_utrunc_workspace];
  
  //FUNCTIONS
  fun gsl_sum_levin_u_accel: cptr[double] * size * ptr[gsl_sum_levin_u_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_sum_levin_u_alloc: size -> ptr[gsl_sum_levin_u_workspace];
  fun gsl_sum_levin_u_minmax: cptr[double] * size * size * size * ptr[gsl_sum_levin_u_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_sum_levin_u_step: double * size * size * ptr[gsl_sum_levin_u_workspace] * ptr[double] -> int;
  fun gsl_sum_levin_utrunc_accel: cptr[double] * size * ptr[gsl_sum_levin_utrunc_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_sum_levin_utrunc_alloc: size -> ptr[gsl_sum_levin_utrunc_workspace];
  fun gsl_sum_levin_utrunc_minmax: cptr[double] * size * size * size * ptr[gsl_sum_levin_utrunc_workspace] * ptr[double] * ptr[double] -> int;
  fun gsl_sum_levin_utrunc_step: double * size * ptr[gsl_sum_levin_utrunc_workspace] * ptr[double] -> int;
}
@h=tangler('lib/gsl/gsl_sys_lib.flx')
@select(h)
//Module        : gsl_sys_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_sys.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_SYS_H__
header '#include "gsl_sys.h"';

module gsl_sys_h
{
  open C_hack;
  
  //FUNCTIONS
  fun gsl_acosh: double -> double;
  fun gsl_asinh: double -> double;
  fun gsl_atanh: double -> double;
  fun gsl_coerce_double: double -> double;
  fun gsl_coerce_float: float -> float;
  fun gsl_coerce_long_double: ldouble -> ldouble;
  fun gsl_expm1: double -> double;
  fun gsl_fcmp: double * double * double -> int;
  fun gsl_fdiv: double * double -> double;
  fun gsl_finite: double -> int;
  fun gsl_frexp: double * ptr[int] -> double;
  fun gsl_hypot: double * double -> double;
  fun gsl_isinf: double -> int;
  fun gsl_isnan: double -> int;
  fun gsl_ldexp: double * int -> double;
  fun gsl_log1p: double -> double;
  fun gsl_nan: 1 -> double;
  fun gsl_neginf: 1 -> double;
  fun gsl_posinf: 1 -> double;
}
@h=tangler('lib/gsl/gsl_types_lib.flx')
@select(h)
//Module        : gsl_types_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_types.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_VAR extern
//#define GSL_VAR extern
//#define GSL_VAR extern __declspec(dllimport)
//#define GSL_VAR extern __declspec(dllexport)
//#define __GSL_TYPES_H__
header '#include "gsl_types.h"';

module gsl_types_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_vector_char_lib.flx')
@select(h)
//Module        : gsl_vector_char_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_char.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_CHAR_H__
header '#include "gsl_vector_char.h"';

//INCLUDES
include "gsl_block_char_lib";

module gsl_vector_char_h
{
  open C_hack;
  open gsl_block_char_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_char_const_view = '_gsl_vector_char_const_view';
  type gsl_vector_char = 'gsl_vector_char';
  type _gsl_vector_char_view = '_gsl_vector_char_view';
  
  //TYPE ALIASES
  typedef gsl_vector_char_view = _gsl_vector_char_view;
  typedef gsl_vector_char_const_view = _gsl_vector_char_const_view;
  
  //PROCEDURES
  proc gsl_vector_char_free: ptr[gsl_vector_char];
  proc gsl_vector_char_minmax: cptr[gsl_vector_char] * ptr[char] * ptr[char];
  proc gsl_vector_char_minmax_index: cptr[gsl_vector_char] * ptr[size] * ptr[size];
  proc gsl_vector_char_set: ptr[gsl_vector_char] * size * char;
  proc gsl_vector_char_set_all: ptr[gsl_vector_char] * char;
  proc gsl_vector_char_set_zero: ptr[gsl_vector_char];
  
  //FUNCTIONS
  fun gsl_vector_char_add: ptr[gsl_vector_char] * cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_add_constant: ptr[gsl_vector_char] * double -> int;
  fun gsl_vector_char_alloc: size -> ptr[gsl_vector_char];
  fun gsl_vector_char_alloc_from_block: ptr[gsl_block_char] * size * size * size -> ptr[gsl_vector_char];
  fun gsl_vector_char_alloc_from_vector: ptr[gsl_vector_char] * size * size * size -> ptr[gsl_vector_char];
  fun gsl_vector_char_calloc: size -> ptr[gsl_vector_char];
  fun gsl_vector_char_const_ptr: cptr[gsl_vector_char] * size -> cptr[char];
  fun gsl_vector_char_const_subvector: cptr[gsl_vector_char] * size * size -> _gsl_vector_char_const_view;
  fun gsl_vector_char_const_subvector_with_stride: cptr[gsl_vector_char] * size * size * size -> _gsl_vector_char_const_view;
  fun gsl_vector_char_const_view_array: cptr[char] * size -> _gsl_vector_char_const_view;
  fun gsl_vector_char_const_view_array_with_stride: cptr[char] * size * size -> _gsl_vector_char_const_view;
  fun gsl_vector_char_div: ptr[gsl_vector_char] * cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_fprintf: ptr[FILE] * cptr[gsl_vector_char] * cptr[char] -> int;
  fun gsl_vector_char_fread: ptr[FILE] * ptr[gsl_vector_char] -> int;
  fun gsl_vector_char_fscanf: ptr[FILE] * ptr[gsl_vector_char] -> int;
  fun gsl_vector_char_fwrite: ptr[FILE] * cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_get: cptr[gsl_vector_char] * size -> char;
  fun gsl_vector_char_isnull: cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_max: cptr[gsl_vector_char] -> char;
  fun gsl_vector_char_max_index: cptr[gsl_vector_char] -> size;
  fun gsl_vector_char_memcpy: ptr[gsl_vector_char] * cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_min: cptr[gsl_vector_char] -> char;
  fun gsl_vector_char_min_index: cptr[gsl_vector_char] -> size;
  fun gsl_vector_char_mul: ptr[gsl_vector_char] * cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_ptr: ptr[gsl_vector_char] * size -> ptr[char];
  fun gsl_vector_char_reverse: ptr[gsl_vector_char] -> int;
  fun gsl_vector_char_scale: ptr[gsl_vector_char] * double -> int;
  fun gsl_vector_char_set_basis: ptr[gsl_vector_char] * size -> int;
  fun gsl_vector_char_sub: ptr[gsl_vector_char] * cptr[gsl_vector_char] -> int;
  fun gsl_vector_char_subvector: ptr[gsl_vector_char] * size * size -> _gsl_vector_char_view;
  fun gsl_vector_char_subvector_with_stride: ptr[gsl_vector_char] * size * size * size -> _gsl_vector_char_view;
  fun gsl_vector_char_swap: ptr[gsl_vector_char] * ptr[gsl_vector_char] -> int;
  fun gsl_vector_char_swap_elements: ptr[gsl_vector_char] * size * size -> int;
  fun gsl_vector_char_view_array: ptr[char] * size -> _gsl_vector_char_view;
  fun gsl_vector_char_view_array_with_stride: ptr[char] * size * size -> _gsl_vector_char_view;
}
@h=tangler('lib/gsl/gsl_vector_complex_double_lib.flx')
@select(h)
//Module        : gsl_vector_complex_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_complex_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_COMPLEX_DOUBLE_H__
header '#include "gsl_vector_complex_double.h"';

//INCLUDES
include "gsl_block_complex_double_lib";
include "gsl_complex_lib";
include "gsl_vector_double_lib";

module gsl_vector_complex_double_h
{
  open C_hack;
  open gsl_block_complex_double_h;
  open gsl_complex_h;
  open gsl_vector_double_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_complex_view = '_gsl_vector_complex_view';
  type gsl_vector_complex = 'gsl_vector_complex';
  type _gsl_vector_complex_const_view = '_gsl_vector_complex_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_complex_const_view = _gsl_vector_complex_const_view;
  typedef gsl_vector_complex_view = _gsl_vector_complex_view;
  
  //PROCEDURES
  proc gsl_vector_complex_free: ptr[gsl_vector_complex];
  proc gsl_vector_complex_set: ptr[gsl_vector_complex] * size * gsl_complex;
  proc gsl_vector_complex_set_all: ptr[gsl_vector_complex] * gsl_complex;
  proc gsl_vector_complex_set_zero: ptr[gsl_vector_complex];
  
  //FUNCTIONS
  fun gsl_vector_complex_alloc: size -> ptr[gsl_vector_complex];
  fun gsl_vector_complex_alloc_from_block: ptr[gsl_block_complex] * size * size * size -> ptr[gsl_vector_complex];
  fun gsl_vector_complex_alloc_from_vector: ptr[gsl_vector_complex] * size * size * size -> ptr[gsl_vector_complex];
  fun gsl_vector_complex_calloc: size -> ptr[gsl_vector_complex];
  fun gsl_vector_complex_const_imag: cptr[gsl_vector_complex] -> _gsl_vector_const_view;
  fun gsl_vector_complex_const_ptr: cptr[gsl_vector_complex] * size -> cptr[gsl_complex];
  fun gsl_vector_complex_const_real: cptr[gsl_vector_complex] -> _gsl_vector_const_view;
  fun gsl_vector_complex_const_subvector: cptr[gsl_vector_complex] * size * size -> _gsl_vector_complex_const_view;
  fun gsl_vector_complex_const_subvector_with_stride: cptr[gsl_vector_complex] * size * size * size -> _gsl_vector_complex_const_view;
  fun gsl_vector_complex_const_view_array: cptr[double] * size -> _gsl_vector_complex_const_view;
  fun gsl_vector_complex_const_view_array_with_stride: cptr[double] * size * size -> _gsl_vector_complex_const_view;
  fun gsl_vector_complex_fprintf: ptr[FILE] * cptr[gsl_vector_complex] * cptr[char] -> int;
  fun gsl_vector_complex_fread: ptr[FILE] * ptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_fscanf: ptr[FILE] * ptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_fwrite: ptr[FILE] * cptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_get: cptr[gsl_vector_complex] * size -> gsl_complex;
  fun gsl_vector_complex_imag: ptr[gsl_vector_complex] -> _gsl_vector_view;
  fun gsl_vector_complex_isnull: cptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_memcpy: ptr[gsl_vector_complex] * cptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_ptr: ptr[gsl_vector_complex] * size -> ptr[gsl_complex];
  fun gsl_vector_complex_real: ptr[gsl_vector_complex] -> _gsl_vector_view;
  fun gsl_vector_complex_reverse: ptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_set_basis: ptr[gsl_vector_complex] * size -> int;
  fun gsl_vector_complex_subvector: ptr[gsl_vector_complex] * size * size -> _gsl_vector_complex_view;
  fun gsl_vector_complex_subvector_with_stride: ptr[gsl_vector_complex] * size * size * size -> _gsl_vector_complex_view;
  fun gsl_vector_complex_swap: ptr[gsl_vector_complex] * ptr[gsl_vector_complex] -> int;
  fun gsl_vector_complex_swap_elements: ptr[gsl_vector_complex] * size * size -> int;
  fun gsl_vector_complex_view_array: ptr[double] * size -> _gsl_vector_complex_view;
  fun gsl_vector_complex_view_array_with_stride: ptr[double] * size * size -> _gsl_vector_complex_view;
}
@h=tangler('lib/gsl/gsl_vector_complex_float_lib.flx')
@select(h)
//Module        : gsl_vector_complex_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_complex_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_COMPLEX_FLOAT_H__
header '#include "gsl_vector_complex_float.h"';

//INCLUDES
include "gsl_block_complex_float_lib";
include "gsl_complex_lib";
include "gsl_vector_float_lib";

module gsl_vector_complex_float_h
{
  open C_hack;
  open gsl_block_complex_float_h;
  open gsl_complex_h;
  open gsl_vector_float_h;
  
  //ABSTRACT TYPES
  type gsl_vector_complex_float = 'gsl_vector_complex_float';
  type _gsl_vector_complex_float_view = '_gsl_vector_complex_float_view';
  type _gsl_vector_complex_float_const_view = '_gsl_vector_complex_float_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_complex_float_const_view = _gsl_vector_complex_float_const_view;
  typedef gsl_vector_complex_float_view = _gsl_vector_complex_float_view;
  
  //PROCEDURES
  proc gsl_vector_complex_float_free: ptr[gsl_vector_complex_float];
  proc gsl_vector_complex_float_set: ptr[gsl_vector_complex_float] * size * gsl_complex_float;
  proc gsl_vector_complex_float_set_all: ptr[gsl_vector_complex_float] * gsl_complex_float;
  proc gsl_vector_complex_float_set_zero: ptr[gsl_vector_complex_float];
  
  //FUNCTIONS
  fun gsl_vector_complex_float_alloc: size -> ptr[gsl_vector_complex_float];
  fun gsl_vector_complex_float_alloc_from_block: ptr[gsl_block_complex_float] * size * size * size -> ptr[gsl_vector_complex_float];
  fun gsl_vector_complex_float_alloc_from_vector: ptr[gsl_vector_complex_float] * size * size * size -> ptr[gsl_vector_complex_float];
  fun gsl_vector_complex_float_calloc: size -> ptr[gsl_vector_complex_float];
  fun gsl_vector_complex_float_const_imag: cptr[gsl_vector_complex_float] -> _gsl_vector_float_const_view;
  fun gsl_vector_complex_float_const_ptr: cptr[gsl_vector_complex_float] * size -> cptr[gsl_complex_float];
  fun gsl_vector_complex_float_const_real: cptr[gsl_vector_complex_float] -> _gsl_vector_float_const_view;
  fun gsl_vector_complex_float_const_subvector: cptr[gsl_vector_complex_float] * size * size -> _gsl_vector_complex_float_const_view;
  fun gsl_vector_complex_float_const_subvector_with_stride: cptr[gsl_vector_complex_float] * size * size * size -> _gsl_vector_complex_float_const_view;
  fun gsl_vector_complex_float_const_view_array: cptr[float] * size -> _gsl_vector_complex_float_const_view;
  fun gsl_vector_complex_float_const_view_array_with_stride: cptr[float] * size * size -> _gsl_vector_complex_float_const_view;
  fun gsl_vector_complex_float_fprintf: ptr[FILE] * cptr[gsl_vector_complex_float] * cptr[char] -> int;
  fun gsl_vector_complex_float_fread: ptr[FILE] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_fscanf: ptr[FILE] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_fwrite: ptr[FILE] * cptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_get: cptr[gsl_vector_complex_float] * size -> gsl_complex_float;
  fun gsl_vector_complex_float_imag: ptr[gsl_vector_complex_float] -> _gsl_vector_float_view;
  fun gsl_vector_complex_float_isnull: cptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_memcpy: ptr[gsl_vector_complex_float] * cptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_ptr: ptr[gsl_vector_complex_float] * size -> ptr[gsl_complex_float];
  fun gsl_vector_complex_float_real: ptr[gsl_vector_complex_float] -> _gsl_vector_float_view;
  fun gsl_vector_complex_float_reverse: ptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_set_basis: ptr[gsl_vector_complex_float] * size -> int;
  fun gsl_vector_complex_float_subvector: ptr[gsl_vector_complex_float] * size * size -> _gsl_vector_complex_float_view;
  fun gsl_vector_complex_float_subvector_with_stride: ptr[gsl_vector_complex_float] * size * size * size -> _gsl_vector_complex_float_view;
  fun gsl_vector_complex_float_swap: ptr[gsl_vector_complex_float] * ptr[gsl_vector_complex_float] -> int;
  fun gsl_vector_complex_float_swap_elements: ptr[gsl_vector_complex_float] * size * size -> int;
  fun gsl_vector_complex_float_view_array: ptr[float] * size -> _gsl_vector_complex_float_view;
  fun gsl_vector_complex_float_view_array_with_stride: ptr[float] * size * size -> _gsl_vector_complex_float_view;
}
@h=tangler('lib/gsl/gsl_vector_complex_lib.flx')
@select(h)
//Module        : gsl_vector_complex_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_complex.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_COMPLEX_LONG_DOUBLE_AT(zv,i) ((gsl_complex_long_double*)&((zv)->data[2*(i)*(zv)->stride]))
//#define GSL_COMPLEX_FLOAT_AT(zv,i) ((gsl_complex_float*)&((zv)->data[2*(i)*(zv)->stride]))
//#define GSL_COMPLEX_AT(zv,i) ((gsl_complex*)&((zv)->data[2*(i)*(zv)->stride]))
//#define GSL_VECTOR_COMPLEX(zv, i) (GSL_COMPLEX_AT((zv),(i)))
//#define GSL_VECTOR_COMPLEX(zv, i) (((i) >= (zv)->size ? (gsl_error ("index out of range", __FILE__, __LINE__, GSL_EINVAL), 0):0 , *GSL_COMPLEX_AT((zv),(i))))
//#define GSL_VECTOR_IMAG(z, i)  ((z)->data[2*(i)*(z)->stride + 1])
//#define GSL_VECTOR_REAL(z, i)  ((z)->data[2*(i)*(z)->stride])
//#define __GSL_VECTOR_COMPLEX_H__
header '#include "gsl_vector_complex.h"';

module gsl_vector_complex_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_vector_complex_long_double_lib.flx')
@select(h)
//Module        : gsl_vector_complex_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_complex_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_COMPLEX_LONG_DOUBLE_H__
header '#include "gsl_vector_complex_long_double.h"';

//INCLUDES
include "gsl_block_complex_long_double_lib";
include "gsl_complex_lib";
include "gsl_vector_long_double_lib";

module gsl_vector_complex_long_double_h
{
  open C_hack;
  open gsl_block_complex_long_double_h;
  open gsl_complex_h;
  open gsl_vector_long_double_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_complex_long_double_view = '_gsl_vector_complex_long_double_view';
  type gsl_vector_complex_long_double = 'gsl_vector_complex_long_double';
  type _gsl_vector_complex_long_double_const_view = '_gsl_vector_complex_long_double_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_complex_long_double_const_view = _gsl_vector_complex_long_double_const_view;
  typedef gsl_vector_complex_long_double_view = _gsl_vector_complex_long_double_view;
  
  //PROCEDURES
  proc gsl_vector_complex_long_double_free: ptr[gsl_vector_complex_long_double];
  proc gsl_vector_complex_long_double_set: ptr[gsl_vector_complex_long_double] * size * gsl_complex_long_double;
  proc gsl_vector_complex_long_double_set_all: ptr[gsl_vector_complex_long_double] * gsl_complex_long_double;
  proc gsl_vector_complex_long_double_set_zero: ptr[gsl_vector_complex_long_double];
  
  //FUNCTIONS
  fun gsl_vector_complex_long_double_alloc: size -> ptr[gsl_vector_complex_long_double];
  fun gsl_vector_complex_long_double_alloc_from_block: ptr[gsl_block_complex_long_double] * size * size * size -> ptr[gsl_vector_complex_long_double];
  fun gsl_vector_complex_long_double_alloc_from_vector: ptr[gsl_vector_complex_long_double] * size * size * size -> ptr[gsl_vector_complex_long_double];
  fun gsl_vector_complex_long_double_calloc: size -> ptr[gsl_vector_complex_long_double];
  fun gsl_vector_complex_long_double_const_imag: cptr[gsl_vector_complex_long_double] -> _gsl_vector_long_double_const_view;
  fun gsl_vector_complex_long_double_const_ptr: cptr[gsl_vector_complex_long_double] * size -> cptr[gsl_complex_long_double];
  fun gsl_vector_complex_long_double_const_real: cptr[gsl_vector_complex_long_double] -> _gsl_vector_long_double_const_view;
  fun gsl_vector_complex_long_double_const_subvector: cptr[gsl_vector_complex_long_double] * size * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_vector_complex_long_double_const_subvector_with_stride: cptr[gsl_vector_complex_long_double] * size * size * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_vector_complex_long_double_const_view_array: cptr[ldouble] * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_vector_complex_long_double_const_view_array_with_stride: cptr[ldouble] * size * size -> _gsl_vector_complex_long_double_const_view;
  fun gsl_vector_complex_long_double_fprintf: ptr[FILE] * cptr[gsl_vector_complex_long_double] * cptr[char] -> int;
  fun gsl_vector_complex_long_double_fread: ptr[FILE] * ptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_fscanf: ptr[FILE] * ptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_fwrite: ptr[FILE] * cptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_get: cptr[gsl_vector_complex_long_double] * size -> gsl_complex_long_double;
  fun gsl_vector_complex_long_double_imag: ptr[gsl_vector_complex_long_double] -> _gsl_vector_long_double_view;
  fun gsl_vector_complex_long_double_isnull: cptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_memcpy: ptr[gsl_vector_complex_long_double] * cptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_ptr: ptr[gsl_vector_complex_long_double] * size -> ptr[gsl_complex_long_double];
  fun gsl_vector_complex_long_double_real: ptr[gsl_vector_complex_long_double] -> _gsl_vector_long_double_view;
  fun gsl_vector_complex_long_double_reverse: ptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_set_basis: ptr[gsl_vector_complex_long_double] * size -> int;
  fun gsl_vector_complex_long_double_subvector: ptr[gsl_vector_complex_long_double] * size * size -> _gsl_vector_complex_long_double_view;
  fun gsl_vector_complex_long_double_subvector_with_stride: ptr[gsl_vector_complex_long_double] * size * size * size -> _gsl_vector_complex_long_double_view;
  fun gsl_vector_complex_long_double_swap: ptr[gsl_vector_complex_long_double] * ptr[gsl_vector_complex_long_double] -> int;
  fun gsl_vector_complex_long_double_swap_elements: ptr[gsl_vector_complex_long_double] * size * size -> int;
  fun gsl_vector_complex_long_double_view_array: ptr[ldouble] * size -> _gsl_vector_complex_long_double_view;
  fun gsl_vector_complex_long_double_view_array_with_stride: ptr[ldouble] * size * size -> _gsl_vector_complex_long_double_view;
}
@h=tangler('lib/gsl/gsl_vector_double_lib.flx')
@select(h)
//Module        : gsl_vector_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_DOUBLE_H__
header '#include "gsl_vector_double.h"';

//INCLUDES
include "gsl_block_double_lib";

module gsl_vector_double_h
{
  open C_hack;
  open gsl_block_double_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_view = '_gsl_vector_view';
  type gsl_vector = 'gsl_vector';
  type _gsl_vector_const_view = '_gsl_vector_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_const_view = _gsl_vector_const_view;
  typedef gsl_vector_view = _gsl_vector_view;
  
  //PROCEDURES
  proc gsl_vector_free: ptr[gsl_vector];
  proc gsl_vector_minmax: cptr[gsl_vector] * ptr[double] * ptr[double];
  proc gsl_vector_minmax_index: cptr[gsl_vector] * ptr[size] * ptr[size];
  proc gsl_vector_set: ptr[gsl_vector] * size * double;
  proc gsl_vector_set_all: ptr[gsl_vector] * double;
  proc gsl_vector_set_zero: ptr[gsl_vector];
  
  //FUNCTIONS
  fun gsl_vector_add: ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_vector_add_constant: ptr[gsl_vector] * double -> int;
  fun gsl_vector_alloc: size -> ptr[gsl_vector];
  fun gsl_vector_alloc_from_block: ptr[gsl_block] * size * size * size -> ptr[gsl_vector];
  fun gsl_vector_alloc_from_vector: ptr[gsl_vector] * size * size * size -> ptr[gsl_vector];
  fun gsl_vector_calloc: size -> ptr[gsl_vector];
  fun gsl_vector_const_ptr: cptr[gsl_vector] * size -> cptr[double];
  fun gsl_vector_const_subvector: cptr[gsl_vector] * size * size -> _gsl_vector_const_view;
  fun gsl_vector_const_subvector_with_stride: cptr[gsl_vector] * size * size * size -> _gsl_vector_const_view;
  fun gsl_vector_const_view_array: cptr[double] * size -> _gsl_vector_const_view;
  fun gsl_vector_const_view_array_with_stride: cptr[double] * size * size -> _gsl_vector_const_view;
  fun gsl_vector_div: ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_vector_fprintf: ptr[FILE] * cptr[gsl_vector] * cptr[char] -> int;
  fun gsl_vector_fread: ptr[FILE] * ptr[gsl_vector] -> int;
  fun gsl_vector_fscanf: ptr[FILE] * ptr[gsl_vector] -> int;
  fun gsl_vector_fwrite: ptr[FILE] * cptr[gsl_vector] -> int;
  fun gsl_vector_get: cptr[gsl_vector] * size -> double;
  fun gsl_vector_isnull: cptr[gsl_vector] -> int;
  fun gsl_vector_max: cptr[gsl_vector] -> double;
  fun gsl_vector_max_index: cptr[gsl_vector] -> size;
  fun gsl_vector_memcpy: ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_vector_min: cptr[gsl_vector] -> double;
  fun gsl_vector_min_index: cptr[gsl_vector] -> size;
  fun gsl_vector_mul: ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_vector_ptr: ptr[gsl_vector] * size -> ptr[double];
  fun gsl_vector_reverse: ptr[gsl_vector] -> int;
  fun gsl_vector_scale: ptr[gsl_vector] * double -> int;
  fun gsl_vector_set_basis: ptr[gsl_vector] * size -> int;
  fun gsl_vector_sub: ptr[gsl_vector] * cptr[gsl_vector] -> int;
  fun gsl_vector_subvector: ptr[gsl_vector] * size * size -> _gsl_vector_view;
  fun gsl_vector_subvector_with_stride: ptr[gsl_vector] * size * size * size -> _gsl_vector_view;
  fun gsl_vector_swap: ptr[gsl_vector] * ptr[gsl_vector] -> int;
  fun gsl_vector_swap_elements: ptr[gsl_vector] * size * size -> int;
  fun gsl_vector_view_array: ptr[double] * size -> _gsl_vector_view;
  fun gsl_vector_view_array_with_stride: ptr[double] * size * size -> _gsl_vector_view;
}
@h=tangler('lib/gsl/gsl_vector_float_lib.flx')
@select(h)
//Module        : gsl_vector_float_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_float.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_FLOAT_H__
header '#include "gsl_vector_float.h"';

//INCLUDES
include "gsl_block_float_lib";

module gsl_vector_float_h
{
  open C_hack;
  open gsl_block_float_h;
  
  //ABSTRACT TYPES
  type gsl_vector_float = 'gsl_vector_float';
  type _gsl_vector_float_view = '_gsl_vector_float_view';
  type _gsl_vector_float_const_view = '_gsl_vector_float_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_float_const_view = _gsl_vector_float_const_view;
  typedef gsl_vector_float_view = _gsl_vector_float_view;
  
  //PROCEDURES
  proc gsl_vector_float_free: ptr[gsl_vector_float];
  proc gsl_vector_float_minmax: cptr[gsl_vector_float] * ptr[float] * ptr[float];
  proc gsl_vector_float_minmax_index: cptr[gsl_vector_float] * ptr[size] * ptr[size];
  proc gsl_vector_float_set: ptr[gsl_vector_float] * size * float;
  proc gsl_vector_float_set_all: ptr[gsl_vector_float] * float;
  proc gsl_vector_float_set_zero: ptr[gsl_vector_float];
  
  //FUNCTIONS
  fun gsl_vector_float_add: ptr[gsl_vector_float] * cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_add_constant: ptr[gsl_vector_float] * double -> int;
  fun gsl_vector_float_alloc: size -> ptr[gsl_vector_float];
  fun gsl_vector_float_alloc_from_block: ptr[gsl_block_float] * size * size * size -> ptr[gsl_vector_float];
  fun gsl_vector_float_alloc_from_vector: ptr[gsl_vector_float] * size * size * size -> ptr[gsl_vector_float];
  fun gsl_vector_float_calloc: size -> ptr[gsl_vector_float];
  fun gsl_vector_float_const_ptr: cptr[gsl_vector_float] * size -> cptr[float];
  fun gsl_vector_float_const_subvector: cptr[gsl_vector_float] * size * size -> _gsl_vector_float_const_view;
  fun gsl_vector_float_const_subvector_with_stride: cptr[gsl_vector_float] * size * size * size -> _gsl_vector_float_const_view;
  fun gsl_vector_float_const_view_array: cptr[float] * size -> _gsl_vector_float_const_view;
  fun gsl_vector_float_const_view_array_with_stride: cptr[float] * size * size -> _gsl_vector_float_const_view;
  fun gsl_vector_float_div: ptr[gsl_vector_float] * cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_fprintf: ptr[FILE] * cptr[gsl_vector_float] * cptr[char] -> int;
  fun gsl_vector_float_fread: ptr[FILE] * ptr[gsl_vector_float] -> int;
  fun gsl_vector_float_fscanf: ptr[FILE] * ptr[gsl_vector_float] -> int;
  fun gsl_vector_float_fwrite: ptr[FILE] * cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_get: cptr[gsl_vector_float] * size -> float;
  fun gsl_vector_float_isnull: cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_max: cptr[gsl_vector_float] -> float;
  fun gsl_vector_float_max_index: cptr[gsl_vector_float] -> size;
  fun gsl_vector_float_memcpy: ptr[gsl_vector_float] * cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_min: cptr[gsl_vector_float] -> float;
  fun gsl_vector_float_min_index: cptr[gsl_vector_float] -> size;
  fun gsl_vector_float_mul: ptr[gsl_vector_float] * cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_ptr: ptr[gsl_vector_float] * size -> ptr[float];
  fun gsl_vector_float_reverse: ptr[gsl_vector_float] -> int;
  fun gsl_vector_float_scale: ptr[gsl_vector_float] * double -> int;
  fun gsl_vector_float_set_basis: ptr[gsl_vector_float] * size -> int;
  fun gsl_vector_float_sub: ptr[gsl_vector_float] * cptr[gsl_vector_float] -> int;
  fun gsl_vector_float_subvector: ptr[gsl_vector_float] * size * size -> _gsl_vector_float_view;
  fun gsl_vector_float_subvector_with_stride: ptr[gsl_vector_float] * size * size * size -> _gsl_vector_float_view;
  fun gsl_vector_float_swap: ptr[gsl_vector_float] * ptr[gsl_vector_float] -> int;
  fun gsl_vector_float_swap_elements: ptr[gsl_vector_float] * size * size -> int;
  fun gsl_vector_float_view_array: ptr[float] * size -> _gsl_vector_float_view;
  fun gsl_vector_float_view_array_with_stride: ptr[float] * size * size -> _gsl_vector_float_view;
}
@h=tangler('lib/gsl/gsl_vector_int_lib.flx')
@select(h)
//Module        : gsl_vector_int_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_int.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_INT_H__
header '#include "gsl_vector_int.h"';

//INCLUDES
include "gsl_block_int_lib";

module gsl_vector_int_h
{
  open C_hack;
  open gsl_block_int_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_int_view = '_gsl_vector_int_view';
  type gsl_vector_int = 'gsl_vector_int';
  type _gsl_vector_int_const_view = '_gsl_vector_int_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_int_view = _gsl_vector_int_view;
  typedef gsl_vector_int_const_view = _gsl_vector_int_const_view;
  
  //PROCEDURES
  proc gsl_vector_int_free: ptr[gsl_vector_int];
  proc gsl_vector_int_minmax: cptr[gsl_vector_int] * ptr[int] * ptr[int];
  proc gsl_vector_int_minmax_index: cptr[gsl_vector_int] * ptr[size] * ptr[size];
  proc gsl_vector_int_set: ptr[gsl_vector_int] * size * int;
  proc gsl_vector_int_set_all: ptr[gsl_vector_int] * int;
  proc gsl_vector_int_set_zero: ptr[gsl_vector_int];
  
  //FUNCTIONS
  fun gsl_vector_int_add: ptr[gsl_vector_int] * cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_add_constant: ptr[gsl_vector_int] * double -> int;
  fun gsl_vector_int_alloc: size -> ptr[gsl_vector_int];
  fun gsl_vector_int_alloc_from_block: ptr[gsl_block_int] * size * size * size -> ptr[gsl_vector_int];
  fun gsl_vector_int_alloc_from_vector: ptr[gsl_vector_int] * size * size * size -> ptr[gsl_vector_int];
  fun gsl_vector_int_calloc: size -> ptr[gsl_vector_int];
  fun gsl_vector_int_const_ptr: cptr[gsl_vector_int] * size -> cptr[int];
  fun gsl_vector_int_const_subvector: cptr[gsl_vector_int] * size * size -> _gsl_vector_int_const_view;
  fun gsl_vector_int_const_subvector_with_stride: cptr[gsl_vector_int] * size * size * size -> _gsl_vector_int_const_view;
  fun gsl_vector_int_const_view_array: cptr[int] * size -> _gsl_vector_int_const_view;
  fun gsl_vector_int_const_view_array_with_stride: cptr[int] * size * size -> _gsl_vector_int_const_view;
  fun gsl_vector_int_div: ptr[gsl_vector_int] * cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_fprintf: ptr[FILE] * cptr[gsl_vector_int] * cptr[char] -> int;
  fun gsl_vector_int_fread: ptr[FILE] * ptr[gsl_vector_int] -> int;
  fun gsl_vector_int_fscanf: ptr[FILE] * ptr[gsl_vector_int] -> int;
  fun gsl_vector_int_fwrite: ptr[FILE] * cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_get: cptr[gsl_vector_int] * size -> int;
  fun gsl_vector_int_isnull: cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_max: cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_max_index: cptr[gsl_vector_int] -> size;
  fun gsl_vector_int_memcpy: ptr[gsl_vector_int] * cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_min: cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_min_index: cptr[gsl_vector_int] -> size;
  fun gsl_vector_int_mul: ptr[gsl_vector_int] * cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_ptr: ptr[gsl_vector_int] * size -> ptr[int];
  fun gsl_vector_int_reverse: ptr[gsl_vector_int] -> int;
  fun gsl_vector_int_scale: ptr[gsl_vector_int] * double -> int;
  fun gsl_vector_int_set_basis: ptr[gsl_vector_int] * size -> int;
  fun gsl_vector_int_sub: ptr[gsl_vector_int] * cptr[gsl_vector_int] -> int;
  fun gsl_vector_int_subvector: ptr[gsl_vector_int] * size * size -> _gsl_vector_int_view;
  fun gsl_vector_int_subvector_with_stride: ptr[gsl_vector_int] * size * size * size -> _gsl_vector_int_view;
  fun gsl_vector_int_swap: ptr[gsl_vector_int] * ptr[gsl_vector_int] -> int;
  fun gsl_vector_int_swap_elements: ptr[gsl_vector_int] * size * size -> int;
  fun gsl_vector_int_view_array: ptr[int] * size -> _gsl_vector_int_view;
  fun gsl_vector_int_view_array_with_stride: ptr[int] * size * size -> _gsl_vector_int_view;
}
@h=tangler('lib/gsl/gsl_vector_lib.flx')
@select(h)
//Module        : gsl_vector_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_H__
header '#include "gsl_vector.h"';

module gsl_vector_h
{
  open C_hack;
}
@h=tangler('lib/gsl/gsl_vector_long_double_lib.flx')
@select(h)
//Module        : gsl_vector_long_double_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_long_double.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_LONG_DOUBLE_H__
header '#include "gsl_vector_long_double.h"';

//INCLUDES
include "gsl_block_long_double_lib";

module gsl_vector_long_double_h
{
  open C_hack;
  open gsl_block_long_double_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_long_double_const_view = '_gsl_vector_long_double_const_view';
  type _gsl_vector_long_double_view = '_gsl_vector_long_double_view';
  type gsl_vector_long_double = 'gsl_vector_long_double';
  
  //TYPE ALIASES
  typedef gsl_vector_long_double_view = _gsl_vector_long_double_view;
  typedef gsl_vector_long_double_const_view = _gsl_vector_long_double_const_view;
  
  //PROCEDURES
  proc gsl_vector_long_double_free: ptr[gsl_vector_long_double];
  proc gsl_vector_long_double_minmax: cptr[gsl_vector_long_double] * ptr[ldouble] * ptr[ldouble];
  proc gsl_vector_long_double_minmax_index: cptr[gsl_vector_long_double] * ptr[size] * ptr[size];
  proc gsl_vector_long_double_set: ptr[gsl_vector_long_double] * size * ldouble;
  proc gsl_vector_long_double_set_all: ptr[gsl_vector_long_double] * ldouble;
  proc gsl_vector_long_double_set_zero: ptr[gsl_vector_long_double];
  
  //FUNCTIONS
  fun gsl_vector_long_double_add: ptr[gsl_vector_long_double] * cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_add_constant: ptr[gsl_vector_long_double] * double -> int;
  fun gsl_vector_long_double_alloc: size -> ptr[gsl_vector_long_double];
  fun gsl_vector_long_double_alloc_from_block: ptr[gsl_block_long_double] * size * size * size -> ptr[gsl_vector_long_double];
  fun gsl_vector_long_double_alloc_from_vector: ptr[gsl_vector_long_double] * size * size * size -> ptr[gsl_vector_long_double];
  fun gsl_vector_long_double_calloc: size -> ptr[gsl_vector_long_double];
  fun gsl_vector_long_double_const_ptr: cptr[gsl_vector_long_double] * size -> cptr[ldouble];
  fun gsl_vector_long_double_const_subvector: cptr[gsl_vector_long_double] * size * size -> _gsl_vector_long_double_const_view;
  fun gsl_vector_long_double_const_subvector_with_stride: cptr[gsl_vector_long_double] * size * size * size -> _gsl_vector_long_double_const_view;
  fun gsl_vector_long_double_const_view_array: cptr[ldouble] * size -> _gsl_vector_long_double_const_view;
  fun gsl_vector_long_double_const_view_array_with_stride: cptr[ldouble] * size * size -> _gsl_vector_long_double_const_view;
  fun gsl_vector_long_double_div: ptr[gsl_vector_long_double] * cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_fprintf: ptr[FILE] * cptr[gsl_vector_long_double] * cptr[char] -> int;
  fun gsl_vector_long_double_fread: ptr[FILE] * ptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_fscanf: ptr[FILE] * ptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_fwrite: ptr[FILE] * cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_get: cptr[gsl_vector_long_double] * size -> ldouble;
  fun gsl_vector_long_double_isnull: cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_max: cptr[gsl_vector_long_double] -> ldouble;
  fun gsl_vector_long_double_max_index: cptr[gsl_vector_long_double] -> size;
  fun gsl_vector_long_double_memcpy: ptr[gsl_vector_long_double] * cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_min: cptr[gsl_vector_long_double] -> ldouble;
  fun gsl_vector_long_double_min_index: cptr[gsl_vector_long_double] -> size;
  fun gsl_vector_long_double_mul: ptr[gsl_vector_long_double] * cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_ptr: ptr[gsl_vector_long_double] * size -> ptr[ldouble];
  fun gsl_vector_long_double_reverse: ptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_scale: ptr[gsl_vector_long_double] * double -> int;
  fun gsl_vector_long_double_set_basis: ptr[gsl_vector_long_double] * size -> int;
  fun gsl_vector_long_double_sub: ptr[gsl_vector_long_double] * cptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_subvector: ptr[gsl_vector_long_double] * size * size -> _gsl_vector_long_double_view;
  fun gsl_vector_long_double_subvector_with_stride: ptr[gsl_vector_long_double] * size * size * size -> _gsl_vector_long_double_view;
  fun gsl_vector_long_double_swap: ptr[gsl_vector_long_double] * ptr[gsl_vector_long_double] -> int;
  fun gsl_vector_long_double_swap_elements: ptr[gsl_vector_long_double] * size * size -> int;
  fun gsl_vector_long_double_view_array: ptr[ldouble] * size -> _gsl_vector_long_double_view;
  fun gsl_vector_long_double_view_array_with_stride: ptr[ldouble] * size * size -> _gsl_vector_long_double_view;
}
@h=tangler('lib/gsl/gsl_vector_long_lib.flx')
@select(h)
//Module        : gsl_vector_long_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_long.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_LONG_H__
header '#include "gsl_vector_long.h"';

//INCLUDES
include "gsl_block_long_lib";

module gsl_vector_long_h
{
  open C_hack;
  open gsl_block_long_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_long_const_view = '_gsl_vector_long_const_view';
  type gsl_vector_long = 'gsl_vector_long';
  type _gsl_vector_long_view = '_gsl_vector_long_view';
  
  //TYPE ALIASES
  typedef gsl_vector_long_view = _gsl_vector_long_view;
  typedef gsl_vector_long_const_view = _gsl_vector_long_const_view;
  
  //PROCEDURES
  proc gsl_vector_long_free: ptr[gsl_vector_long];
  proc gsl_vector_long_minmax: cptr[gsl_vector_long] * ptr[long] * ptr[long];
  proc gsl_vector_long_minmax_index: cptr[gsl_vector_long] * ptr[size] * ptr[size];
  proc gsl_vector_long_set: ptr[gsl_vector_long] * size * long;
  proc gsl_vector_long_set_all: ptr[gsl_vector_long] * long;
  proc gsl_vector_long_set_zero: ptr[gsl_vector_long];
  
  //FUNCTIONS
  fun gsl_vector_long_add: ptr[gsl_vector_long] * cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_add_constant: ptr[gsl_vector_long] * double -> int;
  fun gsl_vector_long_alloc: size -> ptr[gsl_vector_long];
  fun gsl_vector_long_alloc_from_block: ptr[gsl_block_long] * size * size * size -> ptr[gsl_vector_long];
  fun gsl_vector_long_alloc_from_vector: ptr[gsl_vector_long] * size * size * size -> ptr[gsl_vector_long];
  fun gsl_vector_long_calloc: size -> ptr[gsl_vector_long];
  fun gsl_vector_long_const_ptr: cptr[gsl_vector_long] * size -> cptr[long];
  fun gsl_vector_long_const_subvector: cptr[gsl_vector_long] * size * size -> _gsl_vector_long_const_view;
  fun gsl_vector_long_const_subvector_with_stride: cptr[gsl_vector_long] * size * size * size -> _gsl_vector_long_const_view;
  fun gsl_vector_long_const_view_array: cptr[long] * size -> _gsl_vector_long_const_view;
  fun gsl_vector_long_const_view_array_with_stride: cptr[long] * size * size -> _gsl_vector_long_const_view;
  fun gsl_vector_long_div: ptr[gsl_vector_long] * cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_fprintf: ptr[FILE] * cptr[gsl_vector_long] * cptr[char] -> int;
  fun gsl_vector_long_fread: ptr[FILE] * ptr[gsl_vector_long] -> int;
  fun gsl_vector_long_fscanf: ptr[FILE] * ptr[gsl_vector_long] -> int;
  fun gsl_vector_long_fwrite: ptr[FILE] * cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_get: cptr[gsl_vector_long] * size -> long;
  fun gsl_vector_long_isnull: cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_max: cptr[gsl_vector_long] -> long;
  fun gsl_vector_long_max_index: cptr[gsl_vector_long] -> size;
  fun gsl_vector_long_memcpy: ptr[gsl_vector_long] * cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_min: cptr[gsl_vector_long] -> long;
  fun gsl_vector_long_min_index: cptr[gsl_vector_long] -> size;
  fun gsl_vector_long_mul: ptr[gsl_vector_long] * cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_ptr: ptr[gsl_vector_long] * size -> ptr[long];
  fun gsl_vector_long_reverse: ptr[gsl_vector_long] -> int;
  fun gsl_vector_long_scale: ptr[gsl_vector_long] * double -> int;
  fun gsl_vector_long_set_basis: ptr[gsl_vector_long] * size -> int;
  fun gsl_vector_long_sub: ptr[gsl_vector_long] * cptr[gsl_vector_long] -> int;
  fun gsl_vector_long_subvector: ptr[gsl_vector_long] * size * size -> _gsl_vector_long_view;
  fun gsl_vector_long_subvector_with_stride: ptr[gsl_vector_long] * size * size * size -> _gsl_vector_long_view;
  fun gsl_vector_long_swap: ptr[gsl_vector_long] * ptr[gsl_vector_long] -> int;
  fun gsl_vector_long_swap_elements: ptr[gsl_vector_long] * size * size -> int;
  fun gsl_vector_long_view_array: ptr[long] * size -> _gsl_vector_long_view;
  fun gsl_vector_long_view_array_with_stride: ptr[long] * size * size -> _gsl_vector_long_view;
}
@h=tangler('lib/gsl/gsl_vector_short_lib.flx')
@select(h)
//Module        : gsl_vector_short_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_short.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_SHORT_H__
header '#include "gsl_vector_short.h"';

//INCLUDES
include "gsl_block_short_lib";

module gsl_vector_short_h
{
  open C_hack;
  open gsl_block_short_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_short_view = '_gsl_vector_short_view';
  type _gsl_vector_short_const_view = '_gsl_vector_short_const_view';
  type gsl_vector_short = 'gsl_vector_short';
  
  //TYPE ALIASES
  typedef gsl_vector_short_view = _gsl_vector_short_view;
  typedef gsl_vector_short_const_view = _gsl_vector_short_const_view;
  
  //PROCEDURES
  proc gsl_vector_short_free: ptr[gsl_vector_short];
  proc gsl_vector_short_minmax: cptr[gsl_vector_short] * ptr[short] * ptr[short];
  proc gsl_vector_short_minmax_index: cptr[gsl_vector_short] * ptr[size] * ptr[size];
  proc gsl_vector_short_set: ptr[gsl_vector_short] * size * short;
  proc gsl_vector_short_set_all: ptr[gsl_vector_short] * short;
  proc gsl_vector_short_set_zero: ptr[gsl_vector_short];
  
  //FUNCTIONS
  fun gsl_vector_short_add: ptr[gsl_vector_short] * cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_add_constant: ptr[gsl_vector_short] * double -> int;
  fun gsl_vector_short_alloc: size -> ptr[gsl_vector_short];
  fun gsl_vector_short_alloc_from_block: ptr[gsl_block_short] * size * size * size -> ptr[gsl_vector_short];
  fun gsl_vector_short_alloc_from_vector: ptr[gsl_vector_short] * size * size * size -> ptr[gsl_vector_short];
  fun gsl_vector_short_calloc: size -> ptr[gsl_vector_short];
  fun gsl_vector_short_const_ptr: cptr[gsl_vector_short] * size -> cptr[short];
  fun gsl_vector_short_const_subvector: cptr[gsl_vector_short] * size * size -> _gsl_vector_short_const_view;
  fun gsl_vector_short_const_subvector_with_stride: cptr[gsl_vector_short] * size * size * size -> _gsl_vector_short_const_view;
  fun gsl_vector_short_const_view_array: cptr[short] * size -> _gsl_vector_short_const_view;
  fun gsl_vector_short_const_view_array_with_stride: cptr[short] * size * size -> _gsl_vector_short_const_view;
  fun gsl_vector_short_div: ptr[gsl_vector_short] * cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_fprintf: ptr[FILE] * cptr[gsl_vector_short] * cptr[char] -> int;
  fun gsl_vector_short_fread: ptr[FILE] * ptr[gsl_vector_short] -> int;
  fun gsl_vector_short_fscanf: ptr[FILE] * ptr[gsl_vector_short] -> int;
  fun gsl_vector_short_fwrite: ptr[FILE] * cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_get: cptr[gsl_vector_short] * size -> short;
  fun gsl_vector_short_isnull: cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_max: cptr[gsl_vector_short] -> short;
  fun gsl_vector_short_max_index: cptr[gsl_vector_short] -> size;
  fun gsl_vector_short_memcpy: ptr[gsl_vector_short] * cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_min: cptr[gsl_vector_short] -> short;
  fun gsl_vector_short_min_index: cptr[gsl_vector_short] -> size;
  fun gsl_vector_short_mul: ptr[gsl_vector_short] * cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_ptr: ptr[gsl_vector_short] * size -> ptr[short];
  fun gsl_vector_short_reverse: ptr[gsl_vector_short] -> int;
  fun gsl_vector_short_scale: ptr[gsl_vector_short] * double -> int;
  fun gsl_vector_short_set_basis: ptr[gsl_vector_short] * size -> int;
  fun gsl_vector_short_sub: ptr[gsl_vector_short] * cptr[gsl_vector_short] -> int;
  fun gsl_vector_short_subvector: ptr[gsl_vector_short] * size * size -> _gsl_vector_short_view;
  fun gsl_vector_short_subvector_with_stride: ptr[gsl_vector_short] * size * size * size -> _gsl_vector_short_view;
  fun gsl_vector_short_swap: ptr[gsl_vector_short] * ptr[gsl_vector_short] -> int;
  fun gsl_vector_short_swap_elements: ptr[gsl_vector_short] * size * size -> int;
  fun gsl_vector_short_view_array: ptr[short] * size -> _gsl_vector_short_view;
  fun gsl_vector_short_view_array_with_stride: ptr[short] * size * size -> _gsl_vector_short_view;
}
@h=tangler('lib/gsl/gsl_vector_uchar_lib.flx')
@select(h)
//Module        : gsl_vector_uchar_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_uchar.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_UCHAR_H__
header '#include "gsl_vector_uchar.h"';

//INCLUDES
include "gsl_block_uchar_lib";

module gsl_vector_uchar_h
{
  open C_hack;
  open gsl_block_uchar_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_uchar_view = '_gsl_vector_uchar_view';
  type _gsl_vector_uchar_const_view = '_gsl_vector_uchar_const_view';
  type gsl_vector_uchar = 'gsl_vector_uchar';
  
  //TYPE ALIASES
  typedef gsl_vector_uchar_view = _gsl_vector_uchar_view;
  typedef gsl_vector_uchar_const_view = _gsl_vector_uchar_const_view;
  
  //PROCEDURES
  proc gsl_vector_uchar_free: ptr[gsl_vector_uchar];
  proc gsl_vector_uchar_minmax: cptr[gsl_vector_uchar] * ptr[utiny] * ptr[utiny];
  proc gsl_vector_uchar_minmax_index: cptr[gsl_vector_uchar] * ptr[size] * ptr[size];
  proc gsl_vector_uchar_set: ptr[gsl_vector_uchar] * size * utiny;
  proc gsl_vector_uchar_set_all: ptr[gsl_vector_uchar] * utiny;
  proc gsl_vector_uchar_set_zero: ptr[gsl_vector_uchar];
  
  //FUNCTIONS
  fun gsl_vector_uchar_add: ptr[gsl_vector_uchar] * cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_add_constant: ptr[gsl_vector_uchar] * double -> int;
  fun gsl_vector_uchar_alloc: size -> ptr[gsl_vector_uchar];
  fun gsl_vector_uchar_alloc_from_block: ptr[gsl_block_uchar] * size * size * size -> ptr[gsl_vector_uchar];
  fun gsl_vector_uchar_alloc_from_vector: ptr[gsl_vector_uchar] * size * size * size -> ptr[gsl_vector_uchar];
  fun gsl_vector_uchar_calloc: size -> ptr[gsl_vector_uchar];
  fun gsl_vector_uchar_const_ptr: cptr[gsl_vector_uchar] * size -> cptr[utiny];
  fun gsl_vector_uchar_const_subvector: cptr[gsl_vector_uchar] * size * size -> _gsl_vector_uchar_const_view;
  fun gsl_vector_uchar_const_subvector_with_stride: cptr[gsl_vector_uchar] * size * size * size -> _gsl_vector_uchar_const_view;
  fun gsl_vector_uchar_const_view_array: cptr[utiny] * size -> _gsl_vector_uchar_const_view;
  fun gsl_vector_uchar_const_view_array_with_stride: cptr[utiny] * size * size -> _gsl_vector_uchar_const_view;
  fun gsl_vector_uchar_div: ptr[gsl_vector_uchar] * cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_fprintf: ptr[FILE] * cptr[gsl_vector_uchar] * cptr[char] -> int;
  fun gsl_vector_uchar_fread: ptr[FILE] * ptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_fscanf: ptr[FILE] * ptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_fwrite: ptr[FILE] * cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_get: cptr[gsl_vector_uchar] * size -> utiny;
  fun gsl_vector_uchar_isnull: cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_max: cptr[gsl_vector_uchar] -> utiny;
  fun gsl_vector_uchar_max_index: cptr[gsl_vector_uchar] -> size;
  fun gsl_vector_uchar_memcpy: ptr[gsl_vector_uchar] * cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_min: cptr[gsl_vector_uchar] -> utiny;
  fun gsl_vector_uchar_min_index: cptr[gsl_vector_uchar] -> size;
  fun gsl_vector_uchar_mul: ptr[gsl_vector_uchar] * cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_ptr: ptr[gsl_vector_uchar] * size -> ptr[utiny];
  fun gsl_vector_uchar_reverse: ptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_scale: ptr[gsl_vector_uchar] * double -> int;
  fun gsl_vector_uchar_set_basis: ptr[gsl_vector_uchar] * size -> int;
  fun gsl_vector_uchar_sub: ptr[gsl_vector_uchar] * cptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_subvector: ptr[gsl_vector_uchar] * size * size -> _gsl_vector_uchar_view;
  fun gsl_vector_uchar_subvector_with_stride: ptr[gsl_vector_uchar] * size * size * size -> _gsl_vector_uchar_view;
  fun gsl_vector_uchar_swap: ptr[gsl_vector_uchar] * ptr[gsl_vector_uchar] -> int;
  fun gsl_vector_uchar_swap_elements: ptr[gsl_vector_uchar] * size * size -> int;
  fun gsl_vector_uchar_view_array: ptr[utiny] * size -> _gsl_vector_uchar_view;
  fun gsl_vector_uchar_view_array_with_stride: ptr[utiny] * size * size -> _gsl_vector_uchar_view;
}
@h=tangler('lib/gsl/gsl_vector_uint_lib.flx')
@select(h)
//Module        : gsl_vector_uint_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_uint.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_UINT_H__
header '#include "gsl_vector_uint.h"';

//INCLUDES
include "gsl_block_uint_lib";

module gsl_vector_uint_h
{
  open C_hack;
  open gsl_block_uint_h;
  
  //ABSTRACT TYPES
  type gsl_vector_uint = 'gsl_vector_uint';
  type _gsl_vector_uint_view = '_gsl_vector_uint_view';
  type _gsl_vector_uint_const_view = '_gsl_vector_uint_const_view';
  
  //TYPE ALIASES
  typedef gsl_vector_uint_const_view = _gsl_vector_uint_const_view;
  typedef gsl_vector_uint_view = _gsl_vector_uint_view;
  
  //PROCEDURES
  proc gsl_vector_uint_free: ptr[gsl_vector_uint];
  proc gsl_vector_uint_minmax: cptr[gsl_vector_uint] * ptr[uint] * ptr[uint];
  proc gsl_vector_uint_minmax_index: cptr[gsl_vector_uint] * ptr[size] * ptr[size];
  proc gsl_vector_uint_set: ptr[gsl_vector_uint] * size * uint;
  proc gsl_vector_uint_set_all: ptr[gsl_vector_uint] * uint;
  proc gsl_vector_uint_set_zero: ptr[gsl_vector_uint];
  
  //FUNCTIONS
  fun gsl_vector_uint_add: ptr[gsl_vector_uint] * cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_add_constant: ptr[gsl_vector_uint] * double -> int;
  fun gsl_vector_uint_alloc: size -> ptr[gsl_vector_uint];
  fun gsl_vector_uint_alloc_from_block: ptr[gsl_block_uint] * size * size * size -> ptr[gsl_vector_uint];
  fun gsl_vector_uint_alloc_from_vector: ptr[gsl_vector_uint] * size * size * size -> ptr[gsl_vector_uint];
  fun gsl_vector_uint_calloc: size -> ptr[gsl_vector_uint];
  fun gsl_vector_uint_const_ptr: cptr[gsl_vector_uint] * size -> cptr[uint];
  fun gsl_vector_uint_const_subvector: cptr[gsl_vector_uint] * size * size -> _gsl_vector_uint_const_view;
  fun gsl_vector_uint_const_subvector_with_stride: cptr[gsl_vector_uint] * size * size * size -> _gsl_vector_uint_const_view;
  fun gsl_vector_uint_const_view_array: cptr[uint] * size -> _gsl_vector_uint_const_view;
  fun gsl_vector_uint_const_view_array_with_stride: cptr[uint] * size * size -> _gsl_vector_uint_const_view;
  fun gsl_vector_uint_div: ptr[gsl_vector_uint] * cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_fprintf: ptr[FILE] * cptr[gsl_vector_uint] * cptr[char] -> int;
  fun gsl_vector_uint_fread: ptr[FILE] * ptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_fscanf: ptr[FILE] * ptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_fwrite: ptr[FILE] * cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_get: cptr[gsl_vector_uint] * size -> uint;
  fun gsl_vector_uint_isnull: cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_max: cptr[gsl_vector_uint] -> uint;
  fun gsl_vector_uint_max_index: cptr[gsl_vector_uint] -> size;
  fun gsl_vector_uint_memcpy: ptr[gsl_vector_uint] * cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_min: cptr[gsl_vector_uint] -> uint;
  fun gsl_vector_uint_min_index: cptr[gsl_vector_uint] -> size;
  fun gsl_vector_uint_mul: ptr[gsl_vector_uint] * cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_ptr: ptr[gsl_vector_uint] * size -> ptr[uint];
  fun gsl_vector_uint_reverse: ptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_scale: ptr[gsl_vector_uint] * double -> int;
  fun gsl_vector_uint_set_basis: ptr[gsl_vector_uint] * size -> int;
  fun gsl_vector_uint_sub: ptr[gsl_vector_uint] * cptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_subvector: ptr[gsl_vector_uint] * size * size -> _gsl_vector_uint_view;
  fun gsl_vector_uint_subvector_with_stride: ptr[gsl_vector_uint] * size * size * size -> _gsl_vector_uint_view;
  fun gsl_vector_uint_swap: ptr[gsl_vector_uint] * ptr[gsl_vector_uint] -> int;
  fun gsl_vector_uint_swap_elements: ptr[gsl_vector_uint] * size * size -> int;
  fun gsl_vector_uint_view_array: ptr[uint] * size -> _gsl_vector_uint_view;
  fun gsl_vector_uint_view_array_with_stride: ptr[uint] * size * size -> _gsl_vector_uint_view;
}
@h=tangler('lib/gsl/gsl_vector_ulong_lib.flx')
@select(h)
//Module        : gsl_vector_ulong_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_ulong.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_ULONG_H__
header '#include "gsl_vector_ulong.h"';

//INCLUDES
include "gsl_block_ulong_lib";

module gsl_vector_ulong_h
{
  open C_hack;
  open gsl_block_ulong_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_ulong_view = '_gsl_vector_ulong_view';
  type _gsl_vector_ulong_const_view = '_gsl_vector_ulong_const_view';
  type gsl_vector_ulong = 'gsl_vector_ulong';
  
  //TYPE ALIASES
  typedef gsl_vector_ulong_view = _gsl_vector_ulong_view;
  typedef gsl_vector_ulong_const_view = _gsl_vector_ulong_const_view;
  
  //PROCEDURES
  proc gsl_vector_ulong_free: ptr[gsl_vector_ulong];
  proc gsl_vector_ulong_minmax: cptr[gsl_vector_ulong] * ptr[ulong] * ptr[ulong];
  proc gsl_vector_ulong_minmax_index: cptr[gsl_vector_ulong] * ptr[size] * ptr[size];
  proc gsl_vector_ulong_set: ptr[gsl_vector_ulong] * size * ulong;
  proc gsl_vector_ulong_set_all: ptr[gsl_vector_ulong] * ulong;
  proc gsl_vector_ulong_set_zero: ptr[gsl_vector_ulong];
  
  //FUNCTIONS
  fun gsl_vector_ulong_add: ptr[gsl_vector_ulong] * cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_add_constant: ptr[gsl_vector_ulong] * double -> int;
  fun gsl_vector_ulong_alloc: size -> ptr[gsl_vector_ulong];
  fun gsl_vector_ulong_alloc_from_block: ptr[gsl_block_ulong] * size * size * size -> ptr[gsl_vector_ulong];
  fun gsl_vector_ulong_alloc_from_vector: ptr[gsl_vector_ulong] * size * size * size -> ptr[gsl_vector_ulong];
  fun gsl_vector_ulong_calloc: size -> ptr[gsl_vector_ulong];
  fun gsl_vector_ulong_const_ptr: cptr[gsl_vector_ulong] * size -> cptr[ulong];
  fun gsl_vector_ulong_const_subvector: cptr[gsl_vector_ulong] * size * size -> _gsl_vector_ulong_const_view;
  fun gsl_vector_ulong_const_subvector_with_stride: cptr[gsl_vector_ulong] * size * size * size -> _gsl_vector_ulong_const_view;
  fun gsl_vector_ulong_const_view_array: cptr[ulong] * size -> _gsl_vector_ulong_const_view;
  fun gsl_vector_ulong_const_view_array_with_stride: cptr[ulong] * size * size -> _gsl_vector_ulong_const_view;
  fun gsl_vector_ulong_div: ptr[gsl_vector_ulong] * cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_fprintf: ptr[FILE] * cptr[gsl_vector_ulong] * cptr[char] -> int;
  fun gsl_vector_ulong_fread: ptr[FILE] * ptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_fscanf: ptr[FILE] * ptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_fwrite: ptr[FILE] * cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_get: cptr[gsl_vector_ulong] * size -> ulong;
  fun gsl_vector_ulong_isnull: cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_max: cptr[gsl_vector_ulong] -> ulong;
  fun gsl_vector_ulong_max_index: cptr[gsl_vector_ulong] -> size;
  fun gsl_vector_ulong_memcpy: ptr[gsl_vector_ulong] * cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_min: cptr[gsl_vector_ulong] -> ulong;
  fun gsl_vector_ulong_min_index: cptr[gsl_vector_ulong] -> size;
  fun gsl_vector_ulong_mul: ptr[gsl_vector_ulong] * cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_ptr: ptr[gsl_vector_ulong] * size -> ptr[ulong];
  fun gsl_vector_ulong_reverse: ptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_scale: ptr[gsl_vector_ulong] * double -> int;
  fun gsl_vector_ulong_set_basis: ptr[gsl_vector_ulong] * size -> int;
  fun gsl_vector_ulong_sub: ptr[gsl_vector_ulong] * cptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_subvector: ptr[gsl_vector_ulong] * size * size -> _gsl_vector_ulong_view;
  fun gsl_vector_ulong_subvector_with_stride: ptr[gsl_vector_ulong] * size * size * size -> _gsl_vector_ulong_view;
  fun gsl_vector_ulong_swap: ptr[gsl_vector_ulong] * ptr[gsl_vector_ulong] -> int;
  fun gsl_vector_ulong_swap_elements: ptr[gsl_vector_ulong] * size * size -> int;
  fun gsl_vector_ulong_view_array: ptr[ulong] * size -> _gsl_vector_ulong_view;
  fun gsl_vector_ulong_view_array_with_stride: ptr[ulong] * size * size -> _gsl_vector_ulong_view;
}
@h=tangler('lib/gsl/gsl_vector_ushort_lib.flx')
@select(h)
//Module        : gsl_vector_ushort_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_vector_ushort.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_VECTOR_USHORT_H__
header '#include "gsl_vector_ushort.h"';

//INCLUDES
include "gsl_block_ushort_lib";

module gsl_vector_ushort_h
{
  open C_hack;
  open gsl_block_ushort_h;
  
  //ABSTRACT TYPES
  type _gsl_vector_ushort_view = '_gsl_vector_ushort_view';
  type _gsl_vector_ushort_const_view = '_gsl_vector_ushort_const_view';
  type gsl_vector_ushort = 'gsl_vector_ushort';
  
  //TYPE ALIASES
  typedef gsl_vector_ushort_const_view = _gsl_vector_ushort_const_view;
  typedef gsl_vector_ushort_view = _gsl_vector_ushort_view;
  
  //PROCEDURES
  proc gsl_vector_ushort_free: ptr[gsl_vector_ushort];
  proc gsl_vector_ushort_minmax: cptr[gsl_vector_ushort] * ptr[ushort] * ptr[ushort];
  proc gsl_vector_ushort_minmax_index: cptr[gsl_vector_ushort] * ptr[size] * ptr[size];
  proc gsl_vector_ushort_set: ptr[gsl_vector_ushort] * size * ushort;
  proc gsl_vector_ushort_set_all: ptr[gsl_vector_ushort] * ushort;
  proc gsl_vector_ushort_set_zero: ptr[gsl_vector_ushort];
  
  //FUNCTIONS
  fun gsl_vector_ushort_add: ptr[gsl_vector_ushort] * cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_add_constant: ptr[gsl_vector_ushort] * double -> int;
  fun gsl_vector_ushort_alloc: size -> ptr[gsl_vector_ushort];
  fun gsl_vector_ushort_alloc_from_block: ptr[gsl_block_ushort] * size * size * size -> ptr[gsl_vector_ushort];
  fun gsl_vector_ushort_alloc_from_vector: ptr[gsl_vector_ushort] * size * size * size -> ptr[gsl_vector_ushort];
  fun gsl_vector_ushort_calloc: size -> ptr[gsl_vector_ushort];
  fun gsl_vector_ushort_const_ptr: cptr[gsl_vector_ushort] * size -> cptr[ushort];
  fun gsl_vector_ushort_const_subvector: cptr[gsl_vector_ushort] * size * size -> _gsl_vector_ushort_const_view;
  fun gsl_vector_ushort_const_subvector_with_stride: cptr[gsl_vector_ushort] * size * size * size -> _gsl_vector_ushort_const_view;
  fun gsl_vector_ushort_const_view_array: cptr[ushort] * size -> _gsl_vector_ushort_const_view;
  fun gsl_vector_ushort_const_view_array_with_stride: cptr[ushort] * size * size -> _gsl_vector_ushort_const_view;
  fun gsl_vector_ushort_div: ptr[gsl_vector_ushort] * cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_fprintf: ptr[FILE] * cptr[gsl_vector_ushort] * cptr[char] -> int;
  fun gsl_vector_ushort_fread: ptr[FILE] * ptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_fscanf: ptr[FILE] * ptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_fwrite: ptr[FILE] * cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_get: cptr[gsl_vector_ushort] * size -> ushort;
  fun gsl_vector_ushort_isnull: cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_max: cptr[gsl_vector_ushort] -> ushort;
  fun gsl_vector_ushort_max_index: cptr[gsl_vector_ushort] -> size;
  fun gsl_vector_ushort_memcpy: ptr[gsl_vector_ushort] * cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_min: cptr[gsl_vector_ushort] -> ushort;
  fun gsl_vector_ushort_min_index: cptr[gsl_vector_ushort] -> size;
  fun gsl_vector_ushort_mul: ptr[gsl_vector_ushort] * cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_ptr: ptr[gsl_vector_ushort] * size -> ptr[ushort];
  fun gsl_vector_ushort_reverse: ptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_scale: ptr[gsl_vector_ushort] * double -> int;
  fun gsl_vector_ushort_set_basis: ptr[gsl_vector_ushort] * size -> int;
  fun gsl_vector_ushort_sub: ptr[gsl_vector_ushort] * cptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_subvector: ptr[gsl_vector_ushort] * size * size -> _gsl_vector_ushort_view;
  fun gsl_vector_ushort_subvector_with_stride: ptr[gsl_vector_ushort] * size * size * size -> _gsl_vector_ushort_view;
  fun gsl_vector_ushort_swap: ptr[gsl_vector_ushort] * ptr[gsl_vector_ushort] -> int;
  fun gsl_vector_ushort_swap_elements: ptr[gsl_vector_ushort] * size * size -> int;
  fun gsl_vector_ushort_view_array: ptr[ushort] * size -> _gsl_vector_ushort_view;
  fun gsl_vector_ushort_view_array_with_stride: ptr[ushort] * size * size -> _gsl_vector_ushort_view;
}
@h=tangler('lib/gsl/gsl_version_lib.flx')
@select(h)
//Module        : gsl_version_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_version.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define GSL_VERSION "1.6"
//#define __GSL_VERSION_H__
header '#include "gsl_version.h"';

module gsl_version_h
{
  open C_hack;
  
  //VARIABLES
  const gsl_version: cptr[char] = 'gsl_version';
}
@h=tangler('lib/gsl/gsl_wavelet2d_lib.flx')
@select(h)
//Module        : gsl_wavelet2d_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_wavelet2d.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_WAVELET2D_H__
header '#include "gsl_wavelet2d.h"';

//INCLUDES
include "gsl_matrix_double_lib";
include "gsl_wavelet_lib";

module gsl_wavelet2d_h
{
  open C_hack;
  open gsl_matrix_double_h;
  open gsl_wavelet_h;
  
  //FUNCTIONS
  fun gsl_wavelet2d_nstransform: cptr[gsl_wavelet] * ptr[double] * size * size * size * gsl_wavelet_direction * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_nstransform_forward: cptr[gsl_wavelet] * ptr[double] * size * size * size * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_nstransform_inverse: cptr[gsl_wavelet] * ptr[double] * size * size * size * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_nstransform_matrix: cptr[gsl_wavelet] * ptr[gsl_matrix] * gsl_wavelet_direction * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_nstransform_matrix_forward: cptr[gsl_wavelet] * ptr[gsl_matrix] * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_nstransform_matrix_inverse: cptr[gsl_wavelet] * ptr[gsl_matrix] * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_transform: cptr[gsl_wavelet] * ptr[double] * size * size * size * gsl_wavelet_direction * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_transform_forward: cptr[gsl_wavelet] * ptr[double] * size * size * size * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_transform_inverse: cptr[gsl_wavelet] * ptr[double] * size * size * size * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_transform_matrix: cptr[gsl_wavelet] * ptr[gsl_matrix] * gsl_wavelet_direction * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_transform_matrix_forward: cptr[gsl_wavelet] * ptr[gsl_matrix] * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet2d_transform_matrix_inverse: cptr[gsl_wavelet] * ptr[gsl_matrix] * ptr[gsl_wavelet_workspace] -> int;
}
@h=tangler('lib/gsl/gsl_wavelet_lib.flx')
@select(h)
//Module        : gsl_wavelet_h
//Timestamp     : 2006/3/29 3:52:26 UTC
//Timestamp     : 2006/3/29 14:52:26 (local)
//Raw Header    : gsl_wavelet.h
//Preprocessor  : gcc -E
//Input file: gsl.flxcc.i
//Flxcc Control : gsl.flxcc
//Felix Version : 1.1.2_rc7
include 'std';

//#define __GSL_WAVELET_H__
header '#include "gsl_wavelet.h"';

module gsl_wavelet_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type gsl_wavelet_workspace = 'gsl_wavelet_workspace';
  type gsl_wavelet_type = 'gsl_wavelet_type';
  type gsl_wavelet_direction = 'gsl_wavelet_direction';
  type gsl_wavelet = 'gsl_wavelet';
  
  //VARIABLES
  const gsl_wavelet_haar_centered: cptr[gsl_wavelet_type] = 'gsl_wavelet_haar_centered';
  const gsl_wavelet_daubechies_centered: cptr[gsl_wavelet_type] = 'gsl_wavelet_daubechies_centered';
  const gsl_wavelet_daubechies: cptr[gsl_wavelet_type] = 'gsl_wavelet_daubechies';
  const gsl_wavelet_bspline_centered: cptr[gsl_wavelet_type] = 'gsl_wavelet_bspline_centered';
  const gsl_wavelet_bspline: cptr[gsl_wavelet_type] = 'gsl_wavelet_bspline';
  const gsl_wavelet_haar: cptr[gsl_wavelet_type] = 'gsl_wavelet_haar';
  
  //ENUMERATION CONSTANTS
  const backward___0: int = 'backward___0';
  const forward___0: int = 'forward___0';
  
  //PROCEDURES
  proc gsl_wavelet_free: ptr[gsl_wavelet];
  proc gsl_wavelet_workspace_free: ptr[gsl_wavelet_workspace];
  
  //FUNCTIONS
  fun gsl_wavelet_alloc: cptr[gsl_wavelet_type] * size -> ptr[gsl_wavelet];
  fun gsl_wavelet_name: cptr[gsl_wavelet] -> cptr[char];
  fun gsl_wavelet_transform: cptr[gsl_wavelet] * ptr[double] * size * size * gsl_wavelet_direction * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet_transform_forward: cptr[gsl_wavelet] * ptr[double] * size * size * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet_transform_inverse: cptr[gsl_wavelet] * ptr[double] * size * size * ptr[gsl_wavelet_workspace] -> int;
  fun gsl_wavelet_workspace_alloc: size -> ptr[gsl_wavelet_workspace];
}
