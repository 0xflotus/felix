@head(1,'pkg-config replacement')
This program provides roughly the same functionality as
the pkg-config program. It isn't the same, however,
and it uses its own files. As usual other people's software
is harder to modify so it work right than to do it oneself;(
@p()
This program should be compiled static with Felix, as early
as possible, since it is needed to compile Felix code
which uses extensions, plugins, or whatever.
Maybe the tarball should even include the C++ sources,
so it can be built early enough.

@h = tangler("spkgs/flx_pkgconfig.py")
@select(h)

# 
# we can't use flx_pkgconfig to supply platform
# libraries .. because this IS flx_pkgconfig --
# so it isn't built yet!!
#
FLXFLAGS = ""
if WIN32:
  if HAVE_MSVC:
    FLXFLAGS = "/DEFAULTLIB:ws2_32 /DEFAULTLIB:mswsock "
  else:
    FLXFLAGS = "-lws2_32 -lmswsock "
    
pkg_requires = ['flx_compiler','flx_drivers']
felix_tools = [('tools/flx_pkgconfig','bin/flx_pkgconfig')]
felix_requires_linkflags = FLXFLAGS
exes_require_libs = ['libfaio','libdemux','libflx_pthread','libflx']
iscr_source = ['lpsrc/flx_pkgconfig.pak']

@h = tangler("tools/flx_pkgconfig.flx","data")
@select(h)
#import <flx.flxh>
open String;
open List;
open System;
open Env;
open Filename;
open Text_file;
open Lexer;

regexp white = " " +;
regexp black = [^" "]+;
regexp dquoted = '"' [^'"']* '"';
regexp squoted = "'" [^"'"]* "'";
regexp quoted = dquoted | squoted;

fun lexit(start:iterator, finish:iterator): iterator * string =
{
  return reglex start to finish with
  | black => string_between(lexeme_start, lexeme_end)
  | quoted => string_between(lexeme_start+1, lexeme_end-1)
  | white => ""
  endmatch;
}

fun lexstr(s':string): list[string] =
{
  var s = s';
  val first = start_iterator s;
  val finish = end_iterator s;
  var current = first;
  var words = Empty[string];
  while { current != finish }
  {
    match lexit(current,finish) with
    | ?next,?lexeme =>
      {
        current = next;
        if lexeme != "" do words = Cons(lexeme,words); done;
      }
    endmatch;
  };
  return rev words;
}

macro val streq = eq of (string * string);

var path=getenv("PKG_CONFIG_PATH");

// parse arguments
var fields = Empty[string];
var pkgs = Empty[string];

var hide = false; // only find first file in path
var require_pkg_exists = true; // fail if file not found
var missing = false; // report missing packages
var require_field_exists = false; // fail if file doesn't contain field
var recfields = Empty[string];
var dolist = false;
var listkeys = false;
var return_code = 0;
var backwards = false;
enum keep_t {keepall, keepleftmost, keeprightmost};
var keep= keepleftmost;

var i = 1;
var arg = argv i; 
var args = Empty[string];
whilst arg != "" do args = arg + args; ++i; arg=argv i; done;
args = rev args;

fun is_prefix_of(p:string,w:string)=> p == w.[to len p];

proc parse_args(args:list[string]) 
{
  match args with
  | Empty => {}
  | Cons (?arg,?tail) =>
    {
      fun prefix(x:string)=>is_prefix_of(x,arg);

      if prefix("--hide") do hide = true;
      elif prefix("--backwards") do backwards = true;
      elif prefix("--list") do dolist = true;
      elif prefix("--missing") do missing = true;
      elif prefix("--noerror") do require_pkg_exists = false;
      elif prefix("--keeprightmost") do keep = keeprightmost;
      elif prefix("--keepleftmost") do keep = keepleftmost;
      elif prefix("--keepall") do keep = keepall;

      elif "--field" == arg.[0 to 7] do
        fields = fields + arg.[8 to];

      elif "-" == arg.[0 to 1] and "-" != arg.[1 to 2] do
        flags := arg.[1 to];
        if find(flags,chr "r") != npos do
          recfields = append_unique streq recfields "Requires";
        done;

        if find(flags,"h") != npos do hide = true; done;
        if find(flags,"b") != npos do backwards = true; done;
        if find(flags,"l") != npos do dolist = true; done;

      elif "--rec" == arg.[0 to 5] do
        var fld = arg.[6 to];
        fld = if fld == "" then "Requires" else fld endif;
        recfields = append_unique streq recfields fld;

      // add to path
      elif "--path+" == arg.[0 to 7] do
        val x = arg.[8 to];
        if path != "" do
          path= path + ":" + x;
        else
          path= x;
        done;

      // set path
      elif "--path" == arg.[0 to 6] do
        path= arg.[7 to];


      elif "@" == arg.[0 to 1] do
        val data = Text_file::load$ trim arg.[1 to];
        parse_args$ split(data,c" \n\r\t,");

      // ignore unknown options
      elif "-" == arg.[0 to 1] do ;

      // ignore empty arguments
      elif "" == arg do ;

      // package name
      else
        pkgs = pkgs + arg;
      done;
      parse_args(tail);
    }
  endmatch;
}

parse_args(args);

fun str: list[string] -> string =
  | Cons (?e,?t) => e + " " + str t
  | Empty => ""
;

//print$ "Fields   = " + str fields; endl;
//print$ "Packages = " + str pkgs; endl;

val dirs=split(path, chr ':');

//print$ "Path = " + str dirs; endl;

var result = Empty[string];

fun get_field(line:string):string * string = 
{
  var n = find (line,chr ':');
  return
    if n != npos then
        trim line.[to n],
        trim line.[n+1 to]
    else
      "",""
    endif
  ;
}

proc add_val(v:string){ 
 result = insert_unique streq result v;
//  result = rev$ Cons(v, rev result);
}

proc tail_val(v:string){ 
   result = append_unique streq result v;
//  result = Cons(v, result);
}

proc keep_val (v:string){
  result = result + v;
}

proc handle_pkg (pkg:string, trace:list[string]){
   if mem streq trace pkg return;
   var found = false;
   iter(proc (dir:string){
     val filename = 
       if dir=="" then "." else dir endif + sep + pkg + ".fpc"
     ;
     //print filename; endl;

     // examine line of one file
     file := fopen_input filename;
     if valid file do
       if dolist call add_val pkg; 
       var lines = Empty[string];
       var line = readln file;
       whilst line != "" do 
         lines = Cons(line,lines); 
         line = readln file; 
       done;
       if not backwards do lines = rev lines; done;

       iter (proc (line:string) 
       {
         //print line;
         def var key, var value = get_field(line);
         if listkeys call add_val key;
         var values = lexstr(value);

         if mem streq fields key do
           match keep with
           | keepleftmost => { iter the add_val values; }
           | keeprightmost => { iter the tail_val values; }
           | keepall => { iter the keep_val values; }
           endmatch;
         done;

         // chase dependent packages
         if mem streq recfields key do
           iter (proc (s:string){ 
             handle_pkg$ s,Cons(pkg,trace); 
           })
           values;
         done;
       })
       lines
       ;
       fclose file;
       found = true;
       if hide return; // only find first file in path
     done;
   })
   dirs;
   if not found do
     if require_pkg_exists do return_code = 1; done;
     if missing call add_val(pkg);
   done;
}

whilst not is_empty pkgs do
  match pkgs with
  | Empty => {}
  | Cons (?pkg,?tail) => 
    { 
      pkgs = tail;
      handle_pkg(pkg,Empty[string]); 
    }
  endmatch;
done;

// trim any trailing space off to ease bash scripting
print$ trim$ str result; endl;
System::exit return_code;

