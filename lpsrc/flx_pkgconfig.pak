@head(1,'pkg-config replacement')
This program provides roughly the same functionality as
the pkg-config program. It isn't the same, however,
and it uses its own files. As usual other people's software
is harder to modify so it work right than to do it oneself;(
@p()
This program should be compiled static with Felix, as early
as possible, since it is needed to compile Felix code
which uses extensions, plugins, or whatever.
Maybe the tarball should even include the C++ sources,
so it can be built early enough.

@h = tangler("spkgs/flx_pkgconfig.py")
@select(h)

# 
# we can't use flx_pkgconfig to supply platform
# libraries .. because this IS flx_pkgconfig --
# so it isn't built yet!!
#
FLXFLAGS = ""
if WIN32:
  if HAVE_MSVC:
    FLXFLAGS = "/DEFAULTLIB:ws2_32 /DEFAULTLIB:mswsock "
  else:
    FLXFLAGS = "-lws2_32 -lmswsock "
    
pkg_requires = ['flx_compiler','flx_drivers']
felix_tools = [('tools/flx_pkgconfig','bin/flx_pkgconfig')]
felix_requires_linkflags = FLXFLAGS
exes_require_libs = ['libfaio','libdemux','libflx_pthread','libflx']
iscr_source = ['lpsrc/flx_pkgconfig.ipk']

@h = tangler("tools/flx_pkgconfig.flx","data")
@select(h)
#import <flx.flxh>
open String;
open List;
open System;
open Env;
open Filename;
open Text_file;

macro val streq = eq of (string * string);

var path=getenv("PKG_CONFIG_PATH");

// parse arguments
var fields = Empty[string];
var pkgs = Empty[string];

var hide = false; // only find first file in path
var require_pkg_exists = true; // fail if file not found
var missing = false; // report missing packages
var require_field_exists = false; // fail if file doesn't contain field
var recfields = Empty[string];
var dolist = false;
var listkeys = false;
var return_code = 0;
var backwards = false;

var i = 1;
var arg = argv i; 
var args = Empty[string];
whilst arg != "" do args = arg + args; ++i; arg=argv i; done;
args = rev args;

fun is_prefix_of(p:string,w:string)=> p == w.[to len p];

proc parse_args(args:list[string]) 
{
  match args with
  | Empty => {}
  | Cons (?arg,?tail) =>
    {
      fun prefix(x:string)=>is_prefix_of(x,arg);

      if prefix("--hide") do hide = true;
      elif prefix("--backwards") do backwards = true;
      elif prefix("--list") do dolist = true;
      elif prefix("--missing") do missing = true;
      elif prefix("--noerror") do require_pkg_exists = false;

      elif "--field" == arg.[0 to 7] do
        fields = fields + arg.[8 to];

      elif "-" == arg.[0 to 1] and "-" != arg.[1 to 2] do
        flags := arg.[1 to];
        if find(flags,chr "r") != npos do
          recfields = append_unique streq recfields "Requires";
        done;

        if find(flags,"h") != npos do hide = true; done;
        if find(flags,"b") != npos do backwards = true; done;
        if find(flags,"l") != npos do dolist = true; done;

      elif "--rec" == arg.[0 to 5] do
        var fld = arg.[6 to];
        fld = if fld == "" then "Requires" else fld endif;
        recfields = append_unique streq recfields fld;

      // add to path
      elif "--path+" == arg.[0 to 7] do
        val x = arg.[8 to];
        if path != "" do
          path= path + ":" + x;
        else
          path= x;
        done;

      // set path
      elif "--path" == arg.[0 to 6] do
        path= arg.[7 to];


      elif "@" == arg.[0 to 1] do
        val data = Text_file::load$ trim arg.[1 to];
        parse_args$ split(data,c" \n\r\t,");

      // ignore unknown options
      elif "-" == arg.[0 to 1] do ;

      // ignore empty arguments
      elif "" == arg do ;

      // package name
      else
        pkgs = pkgs + arg;
      done;
      parse_args(tail);
    }
  endmatch;
}

parse_args(args);

fun str: list[string] -> string =
  | Cons (?e,?t) => e + " " + str t
  | Empty => ""
;

//print$ "Fields   = " + str fields; endl;
//print$ "Packages = " + str pkgs; endl;

val dirs=split(path, chr ':');

//print$ "Path = " + str dirs; endl;

var result = Empty[string];

fun get_field(line:string):string * string = 
{
  var n = find (line,chr ':');
  return
    if n != npos then
        trim line.[to n],
        trim line.[n+1 to]
    else
      "",""
    endif
  ;
}

var handled_pkgs = Empty[string];

proc add_val(v:string){ 
    result = append_unique streq result v;
}

proc handle_pkg (pkg:string){
   var found = false;
   iter(proc (dir:string){
     val filename = 
       if dir=="" then "." else dir endif + sep + pkg + ".fpc"
     ;
     //print filename; endl;

     // examine line of one file
     file := fopen_input filename;
     if valid file do
       if dolist call add_val pkg; 
       var line = readln file;
       whilst line != "" do
         //print line;
         def var key, var value = get_field(line);
         if listkeys call add_val key;
         var values = split(value,chr " \n");

         if mem streq fields key do
           iter the add_val values;
         done;

         // chase dependent packages
         if mem streq recfields key do
           iter (proc(v:string) {
             if not mem streq handled_pkgs v do
               pkgs = prepend_unique streq pkgs v;
             done;
           })
           values;
         done;
         line = readln file;
       done;
       fclose file;
       found = true;
       if hide return; // only find first file in path
     done;
   })
   dirs;
   if not found do
     if require_pkg_exists do return_code = 1; done;
     if missing call add_val(pkg);
   done;
}

whilst not is_empty pkgs do
  match pkgs with
  | Empty => {}
  | Cons (?pkg,?tail) => 
    { 
      pkgs = tail;
      handled_pkgs = Cons(pkg,handled_pkgs);
      handle_pkg(pkg); 
    }
  endmatch;
done;

// trim any trailing space off to ease bash scripting
if backwards do result = rev result; done;
print$ trim$ str result; endl;
System::exit return_code;

