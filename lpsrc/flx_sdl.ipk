@head(1,'SDL')
$Log$
Revision 1.7  2006/01/19 17:26:45  skaller
Add sound to SDL example. Fix serious bug in synchronous
channel I/O operations.

Revision 1.6  2006/01/18 14:52:14  skaller
Wrapped SDL event source, test case in tut/examples/sdl100

Revision 1.5  2006/01/18 05:50:04  rfistman
turned sdl_event thing into a driver request

Revision 1.4  2006/01/09 16:32:03  skaller
Integrate SDL tests, provide initial SDL event demux.

Revision 1.3  2006/01/08 08:56:44  skaller
Change rtl name for MACOSX to libflx_dynamic.dylib

Revision 1.2  2006/01/08 00:25:14  skaller
Minor fix to sdl stuff


@h=tangler('lib/SDL/SDL.flx')
@select(h)
//Module        : SDL_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_INIT_EVERYTHING   0x0000FFFF
//#define SDL_INIT_EVENTTHREAD  0x01000000      /* Not supported on all OS's */
//#define SDL_INIT_NOPARACHUTE  0x00100000      /* Don't catch fatal signals */
//#define SDL_INIT_JOYSTICK     0x00000200
//#define SDL_INIT_CDROM                0x00000100
//#define SDL_INIT_VIDEO                0x00000020
//#define SDL_INIT_AUDIO                0x00000010
//#define       SDL_INIT_TIMER          0x00000001
//#define _SDL_H
header '#include "SDL.h"';

module SDL_h
{
  open C_hack;
  
  const SDL_INIT_EVERYTHING: uint32;
  const SDL_INIT_EVENTTHREAD: uint32;
  const SDL_INIT_NOPARACHUTE: uint32;
  const SDL_INIT_JOYSTICK: uint32;
  const SDL_INIT_CDROM : uint32;
  const SDL_INIT_VIDEO: uint32;
  const SDL_INIT_AUDIO: uint32;
  const SDL_INIT_TIMER: uint32;

  //PROCEDURES
  proc SDL_Quit: 1;
  proc SDL_QuitSubSystem: uint32;
  
  //FUNCTIONS
  fun SDL_Init: uint32 -> int;
  fun SDL_InitSubSystem: uint32 -> int;
  fun SDL_WasInit: uint32 -> uint32;
}
@h=tangler('lib/SDL/SDL_active.flx')
@select(h)
//Module        : SDL_active_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_active.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_APPACTIVE         0x04            /* The application is active */
//#define SDL_APPINPUTFOCUS     0x02            /* The app has input focus */
//#define SDL_APPMOUSEFOCUS     0x01            /* The app has mouse coverage */
//#define _SDL_active_h
header '#include "SDL_active.h"';

module SDL_active_h
{
  open C_hack;
  
  //FUNCTIONS
  fun SDL_GetAppState: 1 -> uint8;
}
@h=tangler('lib/SDL/SDL_audio.flx')
@select(h)
//Module        : SDL_audio_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_audio.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_MIX_MAXVOLUME 128
//#define AUDIO_S16SYS  AUDIO_S16MSB
//#define AUDIO_U16SYS  AUDIO_U16MSB
//#define AUDIO_S16SYS  AUDIO_S16LSB
//#define AUDIO_U16SYS  AUDIO_U16LSB
//#define AUDIO_S16     AUDIO_S16LSB
//#define AUDIO_U16     AUDIO_U16LSB
//#define AUDIO_S16MSB  0x9010  /* As above, but big-endian byte order */
//#define AUDIO_U16MSB  0x1010  /* As above, but big-endian byte order */
//#define AUDIO_S16LSB  0x8010  /* Signed 16-bit samples */
//#define AUDIO_U16LSB  0x0010  /* Unsigned 16-bit samples */
//#define AUDIO_S8      0x8008  /* Signed 8-bit samples */
//#define AUDIO_U8      0x0008  /* Unsigned 8-bit samples */
//#define _SDL_audio_h
header '#include "SDL_audio.h"';

//INCLUDES
include"SDL/SDL_rwops";

module SDL_audio_h
{
  open C_hack;
  open SDL_rwops_h;

  const AUDIO_S16MSB : uint16;
  const AUDIO_U16MSB : uint16;
  const AUDIO_S16LSB : uint16;
  const AUDIO_U16LSB : uint16;
  const AUDIO_S16SYS : uint16;
  const AUDIO_U16SYS : uint16;
  const AUDIO_S16 : uint16;
  const AUDIO_U16 : uint16;
  const AUDIO_S8 : uint16;
  const AUDIO_U8 : uint16;
 
  //ABSTRACT TYPES
  type SDL_audiostatus = 'SDL_audiostatus';
  
  //CSTRUCTS 
  cstruct SDL_AudioCVT {
    needed: int;
    src_format: uint16;
    dst_format: uint16;
    rate_incr: double;
    buf: ptr[uint8];
    len: int;
    len_cvt: int;
    len_mult: int;
    len_ratio: double;
    filters: ptr[SDL_audio_h_cft_2];
    filter_index: int;
  }
  cstruct SDL_AudioSpec {
    freq: int;
    format: uint16;
    channels: uint8;
    silence: uint8;
    samples: uint16;
    padding: uint16;
    size: uint32;
    callback: SDL_audio_h_cft_1;
    userdata: address;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*SDL_audio_h_cft_2)(struct SDL_AudioCVT *,  Uint16);''';
  type SDL_audio_h_cft_2 = 'SDL_audio_h_cft_2';
  header '''typedef void (*SDL_audio_h_cft_1)(void *,  Uint8 *, int);''';
  type SDL_audio_h_cft_1 = 'SDL_audio_h_cft_1';
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_AudioSpec = SDL_AudioSpec;
  typedef _struct_SDL_AudioCVT = SDL_AudioCVT;
  
  //ENUMERATION CONSTANTS
  const SDL_AUDIO_PAUSED: int = 'SDL_AUDIO_PAUSED';
  const SDL_AUDIO_STOPPED: int = 'SDL_AUDIO_STOPPED';
  const SDL_AUDIO_PLAYING: int = 'SDL_AUDIO_PLAYING';
  
  //PROCEDURES
  proc SDL_AudioQuit: 1;
  proc SDL_CloseAudio: 1;
  proc SDL_FreeWAV: ptr[uint8];
  proc SDL_LockAudio: 1;
  proc SDL_MixAudio: ptr[uint8] * cptr[uint8] * uint32 * int;
  proc SDL_PauseAudio: int;
  proc SDL_UnlockAudio: 1;
  
  //FUNCTIONS
  fun SDL_AudioDriverName: ptr[char] * int -> ptr[char];
  fun SDL_AudioInit: cptr[char] -> int;
  fun SDL_BuildAudioCVT: ptr[SDL_AudioCVT] * uint16 * uint8 * int * uint16 * uint8 * int -> int;
  fun SDL_ConvertAudio: ptr[SDL_AudioCVT] -> int;
  fun SDL_GetAudioStatus: 1 -> SDL_audiostatus;
  fun SDL_LoadWAV_RW: ptr[SDL_RWops] * int * ptr[SDL_AudioSpec] * ptr[ptr[uint8]] * ptr[uint32] -> ptr[SDL_AudioSpec];
  fun SDL_OpenAudio: ptr[SDL_AudioSpec] * ptr[SDL_AudioSpec] -> int;
  fun SDL_LoadWAV: cptr[char] * ptr[SDL_AudioSpec] * ptr[ptr[uint8]] * ptr[uint32] -> ptr[SDL_AudioSpec];
}

@h=tangler('lib/SDL/SDL_cdrom.flx')
@select(h)
//Module        : SDL_cdrom_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_cdrom.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define MSF_TO_FRAMES(M, S, F)        ((M)*60*CD_FPS+(S)*CD_FPS+(F))
//#define FRAMES_TO_MSF(f, M,S,F)       {                                       \
//#define CD_FPS        75
//#define CD_INDRIVE(status)    ((int)status > 0)
//#define SDL_DATA_TRACK        0x04
//#define SDL_AUDIO_TRACK       0x00
//#define SDL_MAX_TRACKS        99
//#define _SDL_cdrom_h
header '#include "SDL_cdrom.h"';

module SDL_cdrom_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type CDstatus = 'CDstatus';
  
  //CSTRUCTS 
  cstruct SDL_CD {
    id: int;
    status: CDstatus;
    numtracks: int;
    cur_track: int;
    cur_frame: int;
    track: ptr[SDL_CDtrack];
  }
  cstruct SDL_CDtrack {
    id: uint8;
    type_: uint8;
    unused: uint16;
    length: uint32;
    offset: uint32;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_CD = SDL_CD;
  typedef _struct_SDL_CDtrack = SDL_CDtrack;
  
  //ENUMERATION CONSTANTS
  const CD_TRAYEMPTY: int = 'CD_TRAYEMPTY';
  const CD_PLAYING: int = 'CD_PLAYING';
  const CD_ERROR: int = 'CD_ERROR';
  const CD_PAUSED: int = 'CD_PAUSED';
  const CD_STOPPED: int = 'CD_STOPPED';
  
  //PROCEDURES
  proc SDL_CDClose: ptr[SDL_CD];
  
  //FUNCTIONS
  fun SDL_CDEject: ptr[SDL_CD] -> int;
  fun SDL_CDName: int -> cptr[char];
  fun SDL_CDNumDrives: 1 -> int;
  fun SDL_CDOpen: int -> ptr[SDL_CD];
  fun SDL_CDPause: ptr[SDL_CD] -> int;
  fun SDL_CDPlay: ptr[SDL_CD] * int * int -> int;
  fun SDL_CDPlayTracks: ptr[SDL_CD] * int * int * int * int -> int;
  fun SDL_CDResume: ptr[SDL_CD] -> int;
  fun SDL_CDStatus: ptr[SDL_CD] -> CDstatus;
  fun SDL_CDStop: ptr[SDL_CD] -> int;
}
@h=tangler('lib/SDL/SDL_error.flx')
@select(h)
//Module        : SDL_error_h
//Timestamp     : 2006/1/6 2:1:27 UTC
//Timestamp     : 2006/1/6 13:1:27 (local)
//Raw Header    : SDL_error.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_OutOfMemory()     SDL_Error(SDL_ENOMEM)
//#define _SDL_error_h
header '#include "SDL_error.h"';

module SDL_error_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type SDL_errorcode = 'SDL_errorcode';
  
  //ENUMERATION CONSTANTS
  const SDL_EFSEEK: int = 'SDL_EFSEEK';
  const SDL_ENOMEM: int = 'SDL_ENOMEM';
  const SDL_LASTERROR: int = 'SDL_LASTERROR';
  const SDL_EFREAD: int = 'SDL_EFREAD';
  const SDL_EFWRITE: int = 'SDL_EFWRITE';
  
  //PROCEDURES
  proc SDL_ClearError: 1;
  proc SDL_Error: SDL_errorcode;
  proc SDL_SetError[t]: t;
  
  //FUNCTIONS
  fun SDL_GetError: 1 -> ptr[char];
}
@h=tangler('lib/SDL/SDL_events.flx')
@select(h)
//Module        : SDL_events_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_events.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_ENABLE     1
//#define SDL_DISABLE    0
//#define SDL_IGNORE     0
//#define SDL_QUERY     -1
//#define SDL_ALLEVENTS         0xFFFFFFFF
//#define SDL_EVENTMASK(X)      (1<<(X))
//#define _SDL_events_h
header '#include "SDL_events.h"';

//INCLUDES
include"SDL/SDL_keyboard";

module SDL_events_h
{
  open C_hack;
  open SDL_keyboard_h;
  
  //ABSTRACT TYPES
  type SDL_eventaction = 'SDL_eventaction';
  type SDL_Event = 'SDL_Event';
  
  //CSTRUCTS 
  cstruct SDL_SysWMEvent {
    type_: uint8;
    msg: ptr[SDL_SysWMmsg];
  }
  cstruct SDL_ResizeEvent {
    type_: uint8;
    w: int;
    h: int;
  }
  cstruct SDL_KeyboardEvent {
    type_: uint8;
    which: uint8;
    state: uint8;
    keysym: SDL_keysym;
  }
  cstruct SDL_JoyBallEvent {
    type_: uint8;
    which: uint8;
    ball: uint8;
    xrel: int16;
    yrel: int16;
  }
  cstruct SDL_JoyHatEvent {
    type_: uint8;
    which: uint8;
    hat: uint8;
    value: uint8;
  }
  cstruct SDL_ExposeEvent {
    type_: uint8;
  }
  cstruct SDL_MouseButtonEvent {
    type_: uint8;
    which: uint8;
    button: uint8;
    state: uint8;
    x: uint16;
    y: uint16;
  }
  cstruct SDL_MouseMotionEvent {
    type_: uint8;
    which: uint8;
    state: uint8;
    x: uint16;
    y: uint16;
    xrel: int16;
    yrel: int16;
  }
  cstruct SDL_JoyButtonEvent {
    type_: uint8;
    which: uint8;
    button: uint8;
    state: uint8;
  }
  cstruct SDL_QuitEvent {
    type_: uint8;
  }
  cstruct SDL_JoyAxisEvent {
    type_: uint8;
    which: uint8;
    axis: uint8;
    value: int16;
  }
  cstruct SDL_UserEvent {
    type_: uint8;
    code_: int;
    data1: address;
    data2: address;
  }
  cstruct SDL_ActiveEvent {
    type_: uint8;
    gain: uint8;
    state: uint8;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_events_h_cft_1)(SDL_Event const *);''';
  type SDL_events_h_cft_1 = 'SDL_events_h_cft_1';
  
  //PURE INCOMPLETE TYPES
  type _struct_SDL_SysWMmsg = 'struct SDL_SysWMmsg'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_SysWMmsg = _struct_SDL_SysWMmsg;
  
  //TYPE ALIASES
  typedef _struct_SDL_JoyBallEvent = SDL_JoyBallEvent;
  typedef _struct_SDL_MouseButtonEvent = SDL_MouseButtonEvent;
  typedef _struct_SDL_ActiveEvent = SDL_ActiveEvent;
  typedef _struct_SDL_SysWMEvent = SDL_SysWMEvent;
  typedef _struct_SDL_JoyButtonEvent = SDL_JoyButtonEvent;
  typedef _struct_SDL_ResizeEvent = SDL_ResizeEvent;
  typedef _struct_SDL_KeyboardEvent = SDL_KeyboardEvent;
  typedef _struct_SDL_JoyAxisEvent = SDL_JoyAxisEvent;
  typedef _struct_SDL_JoyHatEvent = SDL_JoyHatEvent;
  typedef _struct_SDL_MouseMotionEvent = SDL_MouseMotionEvent;
  typedef _struct_SDL_ExposeEvent = SDL_ExposeEvent;
  typedef SDL_EventMasks = int;
  typedef _struct_SDL_UserEvent = SDL_UserEvent;
  typedef SDL_EventFilter = SDL_events_h_cft_1;
  typedef _struct_SDL_QuitEvent = SDL_QuitEvent;
  typedef SDL_Events = int;
  
  //ENUMERATION CONSTANTS
  const SDL_JOYBUTTONDOWNMASK: int = 'SDL_JOYBUTTONDOWNMASK';
  const SDL_MOUSEBUTTONUP: int = 'SDL_MOUSEBUTTONUP';
  const SDL_JOYBUTTONUPMASK: int = 'SDL_JOYBUTTONUPMASK';
  const SDL_JOYHATMOTIONMASK: int = 'SDL_JOYHATMOTIONMASK';
  const SDL_MOUSEBUTTONDOWN: int = 'SDL_MOUSEBUTTONDOWN';
  const SDL_KEYUP: int = 'SDL_KEYUP';
  const SDL_JOYAXISMOTIONMASK: int = 'SDL_JOYAXISMOTIONMASK';
  const SDL_MOUSEMOTIONMASK: int = 'SDL_MOUSEMOTIONMASK';
  const SDL_MOUSEEVENTMASK: int = 'SDL_MOUSEEVENTMASK';
  const SDL_EVENT_RESERVED2: int = 'SDL_EVENT_RESERVED2';
  const SDL_EVENT_RESERVED3: int = 'SDL_EVENT_RESERVED3';
  const SDL_NUMEVENTS: int = 'SDL_NUMEVENTS';
  const SDL_EVENT_RESERVED4: int = 'SDL_EVENT_RESERVED4';
  const SDL_VIDEORESIZEMASK: int = 'SDL_VIDEORESIZEMASK';
  const SDL_EVENT_RESERVED5: int = 'SDL_EVENT_RESERVED5';
  const SDL_ACTIVEEVENTMASK: int = 'SDL_ACTIVEEVENTMASK';
  const SDL_EVENT_RESERVED6: int = 'SDL_EVENT_RESERVED6';
  const SDL_EVENT_RESERVED7: int = 'SDL_EVENT_RESERVED7';
  const SDL_GETEVENT: int = 'SDL_GETEVENT';
  const SDL_JOYBALLMOTION: int = 'SDL_JOYBALLMOTION';
  const SDL_PEEKEVENT: int = 'SDL_PEEKEVENT';
  const SDL_EVENT_RESERVEDA: int = 'SDL_EVENT_RESERVEDA';
  const SDL_EVENT_RESERVEDB: int = 'SDL_EVENT_RESERVEDB';
  const SDL_NOEVENT: int = 'SDL_NOEVENT';
  const SDL_SYSWMEVENTMASK: int = 'SDL_SYSWMEVENTMASK';
  const SDL_JOYAXISMOTION: int = 'SDL_JOYAXISMOTION';
  const SDL_QUIT: int = 'SDL_QUIT';
  const SDL_VIDEORESIZE: int = 'SDL_VIDEORESIZE';
  const SDL_MOUSEBUTTONUPMASK: int = 'SDL_MOUSEBUTTONUPMASK';
  const SDL_JOYBUTTONDOWN: int = 'SDL_JOYBUTTONDOWN';
  const SDL_VIDEOEXPOSEMASK: int = 'SDL_VIDEOEXPOSEMASK';
  const SDL_MOUSEBUTTONDOWNMASK: int = 'SDL_MOUSEBUTTONDOWNMASK';
  const SDL_KEYDOWN: int = 'SDL_KEYDOWN';
  const SDL_KEYDOWNMASK: int = 'SDL_KEYDOWNMASK';
  const SDL_JOYBUTTONUP: int = 'SDL_JOYBUTTONUP';
  const SDL_JOYEVENTMASK: int = 'SDL_JOYEVENTMASK';
  const SDL_SYSWMEVENT: int = 'SDL_SYSWMEVENT';
  const SDL_USEREVENT: int = 'SDL_USEREVENT';
  const SDL_ADDEVENT: int = 'SDL_ADDEVENT';
  const SDL_QUITMASK: int = 'SDL_QUITMASK';
  const SDL_JOYHATMOTION: int = 'SDL_JOYHATMOTION';
  const SDL_JOYBALLMOTIONMASK: int = 'SDL_JOYBALLMOTIONMASK';
  const SDL_ACTIVEEVENT: int = 'SDL_ACTIVEEVENT';
  const SDL_VIDEOEXPOSE: int = 'SDL_VIDEOEXPOSE';
  const SDL_MOUSEMOTION: int = 'SDL_MOUSEMOTION';
  const SDL_KEYUPMASK: int = 'SDL_KEYUPMASK';
  
  //PROCEDURES
  proc SDL_PumpEvents: 1;
  proc SDL_SetEventFilter: SDL_events_h_cft_1;
  
  //FUNCTIONS
  fun SDL_EventState: uint8 * int -> uint8;
  fun SDL_GetEventFilter: 1 -> SDL_EventFilter;
  fun SDL_PeepEvents: ptr[SDL_Event] * int * SDL_eventaction * uint32 -> int;
  fun SDL_PollEvent: ptr[SDL_Event] -> int;
  fun SDL_PushEvent: ptr[SDL_Event] -> int;
  fun SDL_WaitEvent: ptr[SDL_Event] -> int;
}
@h=tangler('lib/SDL/SDL_joystick.flx')
@select(h)
//Module        : SDL_joystick_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_joystick.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_HAT_LEFTDOWN      (SDL_HAT_LEFT|SDL_HAT_DOWN)
//#define SDL_HAT_LEFTUP                (SDL_HAT_LEFT|SDL_HAT_UP)
//#define SDL_HAT_RIGHTDOWN     (SDL_HAT_RIGHT|SDL_HAT_DOWN)
//#define SDL_HAT_RIGHTUP               (SDL_HAT_RIGHT|SDL_HAT_UP)
//#define SDL_HAT_LEFT          0x08
//#define SDL_HAT_DOWN          0x04
//#define SDL_HAT_RIGHT         0x02
//#define SDL_HAT_UP            0x01
//#define SDL_HAT_CENTERED      0x00
//#define _SDL_joystick_h
header '#include "SDL_joystick.h"';

module SDL_joystick_h
{
  open C_hack;
  
  //PURE INCOMPLETE TYPES
  type _struct__SDL_Joystick = 'struct _SDL_Joystick'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_Joystick = _struct__SDL_Joystick;
  
  //PROCEDURES
  proc SDL_JoystickClose: ptr[SDL_Joystick];
  proc SDL_JoystickUpdate: 1;
  
  //FUNCTIONS
  fun SDL_JoystickEventState: int -> int;
  fun SDL_JoystickGetAxis: ptr[SDL_Joystick] * int -> int16;
  fun SDL_JoystickGetBall: ptr[SDL_Joystick] * int * ptr[int] * ptr[int] -> int;
  fun SDL_JoystickGetButton: ptr[SDL_Joystick] * int -> uint8;
  fun SDL_JoystickGetHat: ptr[SDL_Joystick] * int -> uint8;
  fun SDL_JoystickIndex: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickName: int -> cptr[char];
  fun SDL_JoystickNumAxes: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumBalls: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumButtons: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickNumHats: ptr[SDL_Joystick] -> int;
  fun SDL_JoystickOpen: int -> ptr[SDL_Joystick];
  fun SDL_JoystickOpened: int -> int;
  fun SDL_NumJoysticks: 1 -> int;
}
@h=tangler('lib/SDL/SDL_keyboard.flx')
@select(h)
//Module        : SDL_keyboard_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_keyboard.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_DEFAULT_REPEAT_INTERVAL   30
//#define SDL_DEFAULT_REPEAT_DELAY      500
//#define SDL_ALL_HOTKEYS               0xFFFFFFFF
//#define _SDL_keyboard_h
header '#include "SDL_keyboard.h"';

//INCLUDES
include"SDL/SDL_keysym";

module SDL_keyboard_h
{
  open C_hack;
  open SDL_keysym_h;
  
  //CSTRUCTS 
  cstruct SDL_keysym {
    scancode: uint8;
    sym: SDLKey;
    mod: SDLMod;
    unicode: uint16;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_keysym = SDL_keysym;
  
  //PROCEDURES
  proc SDL_SetModState: SDLMod;
  
  //FUNCTIONS
  fun SDL_EnableKeyRepeat: int * int -> int;
  fun SDL_EnableUNICODE: int -> int;
  fun SDL_GetKeyName: SDLKey -> ptr[char];
  fun SDL_GetKeyState: ptr[int] -> ptr[uint8];
  fun SDL_GetModState: 1 -> SDLMod;
}
@h=tangler('lib/SDL/SDL_keysym.flx')
@select(h)
//Module        : SDL_keysym_h
//Timestamp     : 2006/1/6 2:1:27 UTC
//Timestamp     : 2006/1/6 13:1:27 (local)
//Raw Header    : SDL_keysym.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define KMOD_META     (KMOD_LMETA|KMOD_RMETA)
//#define KMOD_ALT      (KMOD_LALT|KMOD_RALT)
//#define KMOD_SHIFT    (KMOD_LSHIFT|KMOD_RSHIFT)
//#define KMOD_CTRL     (KMOD_LCTRL|KMOD_RCTRL)
//#define _SDL_keysym_h
header '#include "SDL_keysym.h"';

module SDL_keysym_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type SDLKey = 'SDLKey';
  type SDLMod = 'SDLMod';
  
  //ENUMERATION CONSTANTS
  const SDLK_WORLD_1: int = 'SDLK_WORLD_1';
  const SDLK_POWER: int = 'SDLK_POWER';
  const SDLK_SLASH: int = 'SDLK_SLASH';
  const SDLK_WORLD_2: int = 'SDLK_WORLD_2';
  const SDLK_WORLD_3: int = 'SDLK_WORLD_3';
  const SDLK_F1: int = 'SDLK_F1';
  const SDLK_WORLD_4: int = 'SDLK_WORLD_4';
  const SDLK_WORLD_20: int = 'SDLK_WORLD_20';
  const SDLK_F2: int = 'SDLK_F2';
  const SDLK_WORLD_5: int = 'SDLK_WORLD_5';
  const SDLK_WORLD_21: int = 'SDLK_WORLD_21';
  const SDLK_F3: int = 'SDLK_F3';
  const SDLK_KP_EQUALS: int = 'SDLK_KP_EQUALS';
  const SDLK_WORLD_6: int = 'SDLK_WORLD_6';
  const SDLK_LEFT: int = 'SDLK_LEFT';
  const SDLK_WORLD_22: int = 'SDLK_WORLD_22';
  const SDLK_F4: int = 'SDLK_F4';
  const SDLK_WORLD_7: int = 'SDLK_WORLD_7';
  const SDLK_WORLD_23: int = 'SDLK_WORLD_23';
  const SDLK_UNDO: int = 'SDLK_UNDO';
  const SDLK_F5: int = 'SDLK_F5';
  const SDLK_WORLD_8: int = 'SDLK_WORLD_8';
  const SDLK_WORLD_24: int = 'SDLK_WORLD_24';
  const SDLK_F6: int = 'SDLK_F6';
  const SDLK_WORLD_9: int = 'SDLK_WORLD_9';
  const SDLK_WORLD_25: int = 'SDLK_WORLD_25';
  const SDLK_F7: int = 'SDLK_F7';
  const SDLK_WORLD_26: int = 'SDLK_WORLD_26';
  const SDLK_F8: int = 'SDLK_F8';
  const SDLK_WORLD_27: int = 'SDLK_WORLD_27';
  const SDLK_F9: int = 'SDLK_F9';
  const SDLK_LEFTPAREN: int = 'SDLK_LEFTPAREN';
  const SDLK_WORLD_28: int = 'SDLK_WORLD_28';
  const SDLK_WORLD_29: int = 'SDLK_WORLD_29';
  const SDLK_KP_ENTER: int = 'SDLK_KP_ENTER';
  const SDLK_CAPSLOCK: int = 'SDLK_CAPSLOCK';
  const SDLK_WORLD_30: int = 'SDLK_WORLD_30';
  const SDLK_WORLD_31: int = 'SDLK_WORLD_31';
  const SDLK_COMMA: int = 'SDLK_COMMA';
  const SDLK_WORLD_32: int = 'SDLK_WORLD_32';
  const SDLK_HASH: int = 'SDLK_HASH';
  const SDLK_SPACE: int = 'SDLK_SPACE';
  const SDLK_WORLD_33: int = 'SDLK_WORLD_33';
  const SDLK_WORLD_34: int = 'SDLK_WORLD_34';
  const SDLK_WORLD_35: int = 'SDLK_WORLD_35';
  const SDLK_PLUS: int = 'SDLK_PLUS';
  const SDLK_WORLD_36: int = 'SDLK_WORLD_36';
  const SDLK_WORLD_37: int = 'SDLK_WORLD_37';
  const SDLK_WORLD_38: int = 'SDLK_WORLD_38';
  const SDLK_KP_PERIOD: int = 'SDLK_KP_PERIOD';
  const SDLK_PAUSE: int = 'SDLK_PAUSE';
  const SDLK_WORLD_39: int = 'SDLK_WORLD_39';
  const SDLK_KP_MINUS: int = 'SDLK_KP_MINUS';
  const KMOD_LALT: int = 'KMOD_LALT';
  const SDLK_TAB: int = 'SDLK_TAB';
  const SDLK_0: int = 'SDLK_0';
  const SDLK_COMPOSE: int = 'SDLK_COMPOSE';
  const SDLK_1: int = 'SDLK_1';
  const SDLK_2: int = 'SDLK_2';
  const SDLK_LALT: int = 'SDLK_LALT';
  const SDLK_3: int = 'SDLK_3';
  const SDLK_WORLD_40: int = 'SDLK_WORLD_40';
  const SDLK_4: int = 'SDLK_4';
  const SDLK_WORLD_41: int = 'SDLK_WORLD_41';
  const SDLK_5: int = 'SDLK_5';
  const SDLK_RCTRL: int = 'SDLK_RCTRL';
  const SDLK_WORLD_42: int = 'SDLK_WORLD_42';
  const SDLK_6: int = 'SDLK_6';
  const KMOD_RALT: int = 'KMOD_RALT';
  const SDLK_WORLD_43: int = 'SDLK_WORLD_43';
  const SDLK_7: int = 'SDLK_7';
  const SDLK_WORLD_44: int = 'SDLK_WORLD_44';
  const SDLK_8: int = 'SDLK_8';
  const SDLK_WORLD_45: int = 'SDLK_WORLD_45';
  const SDLK_9: int = 'SDLK_9';
  const SDLK_ESCAPE: int = 'SDLK_ESCAPE';
  const SDLK_WORLD_46: int = 'SDLK_WORLD_46';
  const SDLK_WORLD_47: int = 'SDLK_WORLD_47';
  const SDLK_BACKQUOTE: int = 'SDLK_BACKQUOTE';
  const SDLK_RALT: int = 'SDLK_RALT';
  const SDLK_WORLD_48: int = 'SDLK_WORLD_48';
  const SDLK_CARET: int = 'SDLK_CARET';
  const SDLK_WORLD_49: int = 'SDLK_WORLD_49';
  const SDLK_RIGHT: int = 'SDLK_RIGHT';
  const SDLK_DELETE: int = 'SDLK_DELETE';
  const SDLK_RSHIFT: int = 'SDLK_RSHIFT';
  const SDLK_LESS: int = 'SDLK_LESS';
  const SDLK_AMPERSAND: int = 'SDLK_AMPERSAND';
  const SDLK_BACKSLASH: int = 'SDLK_BACKSLASH';
  const SDLK_WORLD_50: int = 'SDLK_WORLD_50';
  const SDLK_WORLD_51: int = 'SDLK_WORLD_51';
  const KMOD_LSHIFT: int = 'KMOD_LSHIFT';
  const SDLK_WORLD_52: int = 'SDLK_WORLD_52';
  const SDLK_WORLD_53: int = 'SDLK_WORLD_53';
  const SDLK_WORLD_54: int = 'SDLK_WORLD_54';
  const SDLK_RMETA: int = 'SDLK_RMETA';
  const SDLK_WORLD_55: int = 'SDLK_WORLD_55';
  const SDLK_WORLD_56: int = 'SDLK_WORLD_56';
  const SDLK_LCTRL: int = 'SDLK_LCTRL';
  const SDLK_WORLD_57: int = 'SDLK_WORLD_57';
  const SDLK_WORLD_58: int = 'SDLK_WORLD_58';
  const SDLK_WORLD_59: int = 'SDLK_WORLD_59';
  const SDLK_RETURN: int = 'SDLK_RETURN';
  const SDLK_QUESTION: int = 'SDLK_QUESTION';
  const SDLK_BREAK: int = 'SDLK_BREAK';
  const SDLK_RSUPER: int = 'SDLK_RSUPER';
  const SDLK_WORLD_60: int = 'SDLK_WORLD_60';
  const SDLK_WORLD_61: int = 'SDLK_WORLD_61';
  const KMOD_MODE: int = 'KMOD_MODE';
  const SDLK_WORLD_62: int = 'SDLK_WORLD_62';
  const SDLK_UNDERSCORE: int = 'SDLK_UNDERSCORE';
  const SDLK_WORLD_63: int = 'SDLK_WORLD_63';
  const SDLK_UNKNOWN: int = 'SDLK_UNKNOWN';
  const SDLK_WORLD_64: int = 'SDLK_WORLD_64';
  const SDLK_BACKSPACE: int = 'SDLK_BACKSPACE';
  const SDLK_WORLD_65: int = 'SDLK_WORLD_65';
  const SDLK_EQUALS: int = 'SDLK_EQUALS';
  const SDLK_WORLD_66: int = 'SDLK_WORLD_66';
  const SDLK_PAGEDOWN: int = 'SDLK_PAGEDOWN';
  const SDLK_MODE: int = 'SDLK_MODE';
  const SDLK_WORLD_67: int = 'SDLK_WORLD_67';
  const SDLK_a: int = 'SDLK_a';
  const SDLK_WORLD_68: int = 'SDLK_WORLD_68';
  const SDLK_HOME: int = 'SDLK_HOME';
  const SDLK_b: int = 'SDLK_b';
  const SDLK_WORLD_69: int = 'SDLK_WORLD_69';
  const SDLK_c: int = 'SDLK_c';
  const SDLK_LMETA: int = 'SDLK_LMETA';
  const SDLK_d: int = 'SDLK_d';
  const SDLK_e: int = 'SDLK_e';
  const SDLK_RIGHTBRACKET: int = 'SDLK_RIGHTBRACKET';
  const SDLK_f: int = 'SDLK_f';
  const SDLK_g: int = 'SDLK_g';
  const SDLK_h: int = 'SDLK_h';
  const SDLK_i: int = 'SDLK_i';
  const SDLK_j: int = 'SDLK_j';
  const SDLK_k: int = 'SDLK_k';
  const SDLK_PRINT: int = 'SDLK_PRINT';
  const SDLK_l: int = 'SDLK_l';
  const SDLK_m: int = 'SDLK_m';
  const SDLK_WORLD_70: int = 'SDLK_WORLD_70';
  const SDLK_n: int = 'SDLK_n';
  const SDLK_WORLD_71: int = 'SDLK_WORLD_71';
  const SDLK_o: int = 'SDLK_o';
  const SDLK_WORLD_72: int = 'SDLK_WORLD_72';
  const SDLK_p: int = 'SDLK_p';
  const SDLK_WORLD_73: int = 'SDLK_WORLD_73';
  const SDLK_q: int = 'SDLK_q';
  const SDLK_WORLD_74: int = 'SDLK_WORLD_74';
  const SDLK_r: int = 'SDLK_r';
  const SDLK_COLON: int = 'SDLK_COLON';
  const SDLK_WORLD_75: int = 'SDLK_WORLD_75';
  const SDLK_s: int = 'SDLK_s';
  const SDLK_WORLD_76: int = 'SDLK_WORLD_76';
  const SDLK_t: int = 'SDLK_t';
  const SDLK_WORLD_77: int = 'SDLK_WORLD_77';
  const SDLK_u: int = 'SDLK_u';
  const SDLK_WORLD_78: int = 'SDLK_WORLD_78';
  const SDLK_v: int = 'SDLK_v';
  const SDLK_WORLD_79: int = 'SDLK_WORLD_79';
  const SDLK_w: int = 'SDLK_w';
  const SDLK_x: int = 'SDLK_x';
  const SDLK_PERIOD: int = 'SDLK_PERIOD';
  const SDLK_SEMICOLON: int = 'SDLK_SEMICOLON';
  const KMOD_NONE: int = 'KMOD_NONE';
  const SDLK_y: int = 'SDLK_y';
  const SDLK_EURO: int = 'SDLK_EURO';
  const SDLK_z: int = 'SDLK_z';
  const SDLK_SYSREQ: int = 'SDLK_SYSREQ';
  const SDLK_GREATER: int = 'SDLK_GREATER';
  const SDLK_DOLLAR: int = 'SDLK_DOLLAR';
  const SDLK_WORLD_80: int = 'SDLK_WORLD_80';
  const SDLK_WORLD_81: int = 'SDLK_WORLD_81';
  const SDLK_WORLD_82: int = 'SDLK_WORLD_82';
  const SDLK_F10: int = 'SDLK_F10';
  const SDLK_WORLD_83: int = 'SDLK_WORLD_83';
  const SDLK_F11: int = 'SDLK_F11';
  const SDLK_WORLD_84: int = 'SDLK_WORLD_84';
  const SDLK_LSHIFT: int = 'SDLK_LSHIFT';
  const SDLK_F12: int = 'SDLK_F12';
  const SDLK_WORLD_85: int = 'SDLK_WORLD_85';
  const SDLK_F13: int = 'SDLK_F13';
  const SDLK_PAGEUP: int = 'SDLK_PAGEUP';
  const SDLK_WORLD_86: int = 'SDLK_WORLD_86';
  const SDLK_F14: int = 'SDLK_F14';
  const SDLK_UP: int = 'SDLK_UP';
  const SDLK_WORLD_87: int = 'SDLK_WORLD_87';
  const KMOD_RCTRL: int = 'KMOD_RCTRL';
  const SDLK_F15: int = 'SDLK_F15';
  const SDLK_WORLD_88: int = 'SDLK_WORLD_88';
  const SDLK_WORLD_89: int = 'SDLK_WORLD_89';
  const SDLK_KP_MULTIPLY: int = 'SDLK_KP_MULTIPLY';
  const SDLK_END: int = 'SDLK_END';
  const SDLK_WORLD_90: int = 'SDLK_WORLD_90';
  const SDLK_CLEAR: int = 'SDLK_CLEAR';
  const SDLK_WORLD_91: int = 'SDLK_WORLD_91';
  const SDLK_AT: int = 'SDLK_AT';
  const SDLK_WORLD_92: int = 'SDLK_WORLD_92';
  const SDLK_WORLD_93: int = 'SDLK_WORLD_93';
  const SDLK_KP_DIVIDE: int = 'SDLK_KP_DIVIDE';
  const SDLK_WORLD_94: int = 'SDLK_WORLD_94';
  const SDLK_WORLD_95: int = 'SDLK_WORLD_95';
  const SDLK_ASTERISK: int = 'SDLK_ASTERISK';
  const SDLK_LSUPER: int = 'SDLK_LSUPER';
  const KMOD_RESERVED: int = 'KMOD_RESERVED';
  const KMOD_RMETA: int = 'KMOD_RMETA';
  const KMOD_LCTRL: int = 'KMOD_LCTRL';
  const SDLK_DOWN: int = 'SDLK_DOWN';
  const SDLK_NUMLOCK: int = 'SDLK_NUMLOCK';
  const SDLK_EXCLAIM: int = 'SDLK_EXCLAIM';
  const KMOD_LMETA: int = 'KMOD_LMETA';
  const SDLK_LAST: int = 'SDLK_LAST';
  const SDLK_HELP: int = 'SDLK_HELP';
  const SDLK_KP0: int = 'SDLK_KP0';
  const SDLK_KP1: int = 'SDLK_KP1';
  const SDLK_KP2: int = 'SDLK_KP2';
  const SDLK_SCROLLOCK: int = 'SDLK_SCROLLOCK';
  const SDLK_KP3: int = 'SDLK_KP3';
  const SDLK_KP_PLUS: int = 'SDLK_KP_PLUS';
  const SDLK_INSERT: int = 'SDLK_INSERT';
  const SDLK_KP4: int = 'SDLK_KP4';
  const SDLK_WORLD_10: int = 'SDLK_WORLD_10';
  const SDLK_KP5: int = 'SDLK_KP5';
  const SDLK_WORLD_11: int = 'SDLK_WORLD_11';
  const SDLK_MINUS: int = 'SDLK_MINUS';
  const SDLK_KP6: int = 'SDLK_KP6';
  const SDLK_WORLD_12: int = 'SDLK_WORLD_12';
  const SDLK_LEFTBRACKET: int = 'SDLK_LEFTBRACKET';
  const SDLK_KP7: int = 'SDLK_KP7';
  const SDLK_WORLD_13: int = 'SDLK_WORLD_13';
  const SDLK_KP8: int = 'SDLK_KP8';
  const SDLK_WORLD_14: int = 'SDLK_WORLD_14';
  const SDLK_KP9: int = 'SDLK_KP9';
  const SDLK_RIGHTPAREN: int = 'SDLK_RIGHTPAREN';
  const SDLK_WORLD_15: int = 'SDLK_WORLD_15';
  const SDLK_WORLD_16: int = 'SDLK_WORLD_16';
  const SDLK_QUOTE: int = 'SDLK_QUOTE';
  const SDLK_FIRST: int = 'SDLK_FIRST';
  const SDLK_WORLD_17: int = 'SDLK_WORLD_17';
  const KMOD_NUM: int = 'KMOD_NUM';
  const SDLK_WORLD_18: int = 'SDLK_WORLD_18';
  const SDLK_WORLD_19: int = 'SDLK_WORLD_19';
  const SDLK_QUOTEDBL: int = 'SDLK_QUOTEDBL';
  const KMOD_RSHIFT: int = 'KMOD_RSHIFT';
  const SDLK_MENU: int = 'SDLK_MENU';
  const KMOD_CAPS: int = 'KMOD_CAPS';
  const SDLK_WORLD_0: int = 'SDLK_WORLD_0';
}
@h=tangler('lib/SDL/SDL_mouse.flx')
@select(h)
//Module        : SDL_mouse_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_mouse.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_BUTTON_RMASK      SDL_BUTTON(SDL_BUTTON_RIGHT)
//#define SDL_BUTTON_MMASK      SDL_BUTTON(SDL_BUTTON_MIDDLE)
//#define SDL_BUTTON_LMASK      SDL_BUTTON(SDL_BUTTON_LEFT)
//#define SDL_BUTTON_WHEELDOWN  5
//#define SDL_BUTTON_WHEELUP    4
//#define SDL_BUTTON_RIGHT      3
//#define SDL_BUTTON_MIDDLE     2
//#define SDL_BUTTON_LEFT               1
//#define SDL_BUTTON(X)         (SDL_PRESSED<<(X-1))
//#define _SDL_mouse_h
header '#include "SDL_mouse.h"';

//INCLUDES
include"SDL/SDL_video";

module SDL_mouse_h
{
  open C_hack;
  open SDL_video_h;
  
  //CSTRUCTS 
  cstruct SDL_Cursor {
    area: SDL_Rect;
    hot_x: int16;
    hot_y: int16;
    data: ptr[uint8];
    mask: ptr[uint8];
    save: ptr[ptr[uint8]];
    wm_cursor: ptr[WMcursor];
  }
  
  //PURE INCOMPLETE TYPES
  type _struct_WMcursor = 'struct WMcursor'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef WMcursor = _struct_WMcursor;
  
  //TYPE ALIASES
  typedef _struct_SDL_Cursor = SDL_Cursor;
  
  //PROCEDURES
  proc SDL_FreeCursor: ptr[SDL_Cursor];
  proc SDL_SetCursor: ptr[SDL_Cursor];
  proc SDL_WarpMouse: uint16 * uint16;
  
  //FUNCTIONS
  fun SDL_CreateCursor: ptr[uint8] * ptr[uint8] * int * int * int * int -> ptr[SDL_Cursor];
  fun SDL_GetCursor: 1 -> ptr[SDL_Cursor];
  fun SDL_GetMouseState: ptr[int] * ptr[int] -> uint8;
  fun SDL_GetRelativeMouseState: ptr[int] * ptr[int] -> uint8;
  fun SDL_ShowCursor: int -> int;
}
@h=tangler('lib/SDL/SDL_mutex.flx')
@select(h)
//Module        : SDL_mutex_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_mutex.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_UnlockMutex(m)    SDL_mutexV(m)
//#define SDL_LockMutex(m)      SDL_mutexP(m)
//#define SDL_MUTEX_MAXWAIT     (~(Uint32)0)
//#define SDL_MUTEX_TIMEDOUT    1
//#define _SDL_mutex_h
header '#include "SDL_mutex.h"';

module SDL_mutex_h
{
  open C_hack;
  
  //PURE INCOMPLETE TYPES
  type _struct_SDL_mutex = 'struct SDL_mutex'; //local
  type _struct_SDL_cond = 'struct SDL_cond'; //local
  type _struct_SDL_semaphore = 'struct SDL_semaphore'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_sem = _struct_SDL_semaphore;
  typedef SDL_cond = _struct_SDL_cond;
  typedef SDL_mutex = _struct_SDL_mutex;
  
  //PROCEDURES
  proc SDL_DestroyCond: ptr[SDL_cond];
  proc SDL_DestroyMutex: ptr[SDL_mutex];
  proc SDL_DestroySemaphore: ptr[SDL_sem];
  
  //FUNCTIONS
  fun SDL_CondBroadcast: ptr[SDL_cond] -> int;
  fun SDL_CondSignal: ptr[SDL_cond] -> int;
  fun SDL_CondWait: ptr[SDL_cond] * ptr[SDL_mutex] -> int;
  fun SDL_CondWaitTimeout: ptr[SDL_cond] * ptr[SDL_mutex] * uint32 -> int;
  fun SDL_CreateCond: 1 -> ptr[SDL_cond];
  fun SDL_CreateMutex: 1 -> ptr[SDL_mutex];
  fun SDL_CreateSemaphore: uint32 -> ptr[SDL_sem];
  fun SDL_SemPost: ptr[SDL_sem] -> int;
  fun SDL_SemTryWait: ptr[SDL_sem] -> int;
  fun SDL_SemValue: ptr[SDL_sem] -> uint32;
  fun SDL_SemWait: ptr[SDL_sem] -> int;
  fun SDL_SemWaitTimeout: ptr[SDL_sem] * uint32 -> int;
  fun SDL_mutexP: ptr[SDL_mutex] -> int;
  fun SDL_mutexV: ptr[SDL_mutex] -> int;
}
@h=tangler('lib/SDL/SDL_rwops.flx')
@select(h)
//Module        : SDL_rwops_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_rwops.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_RWclose(ctx)              (ctx)->close(ctx)
//#define SDL_RWwrite(ctx, ptr, size, n)        (ctx)->write(ctx, ptr, size, n)
//#define SDL_RWread(ctx, ptr, size, n) (ctx)->read(ctx, ptr, size, n)
//#define SDL_RWtell(ctx)                       (ctx)->seek(ctx, 0, SEEK_CUR)
//#define SDL_RWseek(ctx, offset, whence)       (ctx)->seek(ctx, offset, whence)
//#define _SDL_RWops_h

//INCLUDES

module SDL_rwops_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type _struct_SDL_RWops = 'struct SDL_RWops';
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_rwops_h_cft_1)(struct SDL_RWops *,  int, int);''';
  type SDL_rwops_h_cft_1 = 'SDL_rwops_h_cft_1';
  header '''typedef int (*SDL_rwops_h_cft_3)(struct SDL_RWops *,  void const *,  int, int);''';
  type SDL_rwops_h_cft_3 = 'SDL_rwops_h_cft_3';
  header '''typedef int (*SDL_rwops_h_cft_2)(struct SDL_RWops *,  void *, int,  int);''';
  type SDL_rwops_h_cft_2 = 'SDL_rwops_h_cft_2';
  header '''typedef int (*SDL_rwops_h_cft_4)(struct SDL_RWops *);''';
  type SDL_rwops_h_cft_4 = 'SDL_rwops_h_cft_4';
  
  //STRUCT or UNION TAG ALIASES
  typedef SDL_RWops = _struct_SDL_RWops;
  
  //PROCEDURES
  proc SDL_FreeRW: ptr[SDL_RWops];
  
  //FUNCTIONS
  fun SDL_AllocRW: 1 -> ptr[SDL_RWops];
  fun SDL_RWFromConstMem: caddress * int -> ptr[SDL_RWops];
  fun SDL_RWFromFP: ptr[FILE] * int -> ptr[SDL_RWops];
  fun SDL_RWFromFile: cptr[char] * cptr[char] -> ptr[SDL_RWops];
  fun SDL_RWFromMem: address * int -> ptr[SDL_RWops];
  
  //STRUCT and UNION FIELDS
  fun get_read: _struct_SDL_RWops -> SDL_rwops_h_cft_2 = '$1->read';
  fun get_write: _struct_SDL_RWops -> SDL_rwops_h_cft_3 = '$1->write';
  fun get_seek: _struct_SDL_RWops -> SDL_rwops_h_cft_1 = '$1->seek';
  fun get_close: _struct_SDL_RWops -> SDL_rwops_h_cft_4 = '$1->close';
  fun get_type: _struct_SDL_RWops -> uint32 = '$1->type';
}
@h=tangler('lib/SDL/SDL_timer.flx')
@select(h)
//Module        : SDL_timer_h
//Timestamp     : 2006/1/6 2:5:23 UTC
//Timestamp     : 2006/1/6 13:5:23 (local)
//Raw Header    : SDL_timer.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define TIMER_RESOLUTION      10      /* Experimentally determined */
//#define SDL_TIMESLICE         10
//#define _SDL_timer_h
header '#include "SDL_timer.h"';

//INCLUDES
include"SDL/SDL_types";

module SDL_timer_h
{
  open C_hack;
  open SDL_types_h;
  
  //C FUNCTION POINTER TYPES
  header '''typedef Uint32 (*SDL_timer_h_cft_2)(Uint32,  void *);''';
  type SDL_timer_h_cft_2 = 'SDL_timer_h_cft_2';
  header '''typedef Uint32 (*SDL_timer_h_cft_1)(Uint32);''';
  type SDL_timer_h_cft_1 = 'SDL_timer_h_cft_1';
  
  //PURE INCOMPLETE TYPES
  type _struct__SDL_TimerID = 'struct _SDL_TimerID'; //local
  
  //TYPE ALIASES
  typedef SDL_NewTimerCallback = SDL_timer_h_cft_2;
  typedef SDL_TimerID = ptr[_struct__SDL_TimerID];
  typedef SDL_TimerCallback = SDL_timer_h_cft_1;
  
  //PROCEDURES
  proc SDL_Delay: uint32;
  
  //FUNCTIONS
  fun SDL_AddTimer: uint32 * SDL_timer_h_cft_2 * address -> SDL_TimerID;
  fun SDL_GetTicks: 1 -> uint32;
  fun SDL_RemoveTimer: SDL_TimerID -> SDL_bool;
  fun SDL_SetTimer: uint32 * SDL_timer_h_cft_1 -> int;
  
  //CALLBACK TYPE WRAPPERS
  //callback type SDL_timer_h_cft_2, client data at 1
  typedef _fcbat_SDL_timer_h_cft_2 = uint32;
  export type (_fcbat_SDL_timer_h_cft_2) as "_fcbat_SDL_timer_h_cft_2";
  typedef _fcbt_SDL_timer_h_cft_2 = uint32 -> uint32; 
  export type (_fcbt_SDL_timer_h_cft_2) as "_fcbt_SDL_timer_h_cft_2";
  header '''Uint32 _fcbw_SDL_timer_h_cft_2(Uint32 a1,  void *a2);''';

  const _fcbw_SDL_timer_h_cft_2: SDL_timer_h_cft_2 = "_fcbw_SDL_timer_h_cft_2";
  body '''
  Uint32 _fcbw_SDL_timer_h_cft_2(Uint32 a1,  void *a2){
    return ((_fcbt_SDL_timer_h_cft_2)a2)->apply(a1);
  }''';

  
  //CALLBACK CLIENT WRAPPERS
  //callback client SDL_AddTimer, client data at 1, callback at 2
  fun wrapper_SDL_AddTimer(a1: uint32, a2: _fcbt_SDL_timer_h_cft_2): SDL_TimerID= {
    return SDL_AddTimer(a1, _fcbw_SDL_timer_h_cft_2, C_hack::cast[address]a2);
  }
}
@h=tangler('lib/SDL/SDL_types.flx')
@select(h)
//Module        : SDL_types_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_types.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_COMPILE_TIME_ASSERT(name, x)               \
//#define SDL_HAS_64BIT_TYPE    __int64
//#define SDL_HAS_64BIT_TYPE    long long
//#define SDL_HAS_64BIT_TYPE    long
//#define SDL_TABLESIZE(table)  (sizeof(table)/sizeof(table[0]))
//#define _SDL_types_h
header '#include "SDL_types.h"';

module SDL_types_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type SDL_bool = 'SDL_bool';
  type SDL_DUMMY_ENUM = 'SDL_DUMMY_ENUM';
  
  //TYPE ALIASES
  typedef Sint64 = vlong;
  typedef SDL_dummy_uint32 = ptr[int];
  typedef SDL_dummy_sint64 = ptr[int];
  typedef SDL_dummy_sint16 = ptr[int];
  typedef SDL_dummy_sint8 = ptr[int];
  typedef SDL_dummy_sint32 = ptr[int];
  typedef SDL_dummy_uint8 = ptr[int];
  typedef Uint64 = uvlong;
  typedef SDL_dummy_uint64 = ptr[int];
  typedef SDL_dummy_uint16 = ptr[int];
  typedef SDL_dummy_enum = ptr[int];
  
  //ENUMERATION CONSTANTS
  const SDL_PRESSED: int = 'SDL_PRESSED';
  const DUMMY_ENUM_VALUE: int = 'DUMMY_ENUM_VALUE';
  const SDL_RELEASED: int = 'SDL_RELEASED';
  const SDL_TRUE: int = 'SDL_TRUE';
  const SDL_FALSE: int = 'SDL_FALSE';
}
@h=tangler('lib/SDL/SDL_version.flx')
@select(h)
//Module        : SDL_version_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_version.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_VERSION_ATLEAST(X, Y, Z) \
//#define SDL_COMPILEDVERSION \
//#define SDL_VERSIONNUM(X, Y, Z)                                               \
//#define SDL_VERSION(X)                                                        \
//#define SDL_PATCHLEVEL                8
//#define SDL_MINOR_VERSION     2
//#define SDL_MAJOR_VERSION     1
//#define _SDL_version_h
header '#include "SDL_version.h"';

module SDL_version_h
{
  open C_hack;
  
  //CSTRUCTS 
  cstruct SDL_version {
    major: uint8;
    minor: uint8;
    patch: uint8;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_version = SDL_version;
  
  //FUNCTIONS
  fun SDL_Linked_Version: 1 -> cptr[SDL_version];
}
@h=tangler('lib/SDL/SDL_video.flx')
@select(h)
//Module        : SDL_video_h
//Timestamp     : 2006/1/6 2:18:42 UTC
//Timestamp     : 2006/1/6 13:18:42 (local)
//Raw Header    : SDL_video.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_BlitSurface SDL_UpperBlit
//#define SDL_SaveBMP(surface, file) \
//#define SDL_LoadBMP(file)     SDL_LoadBMP_RW(SDL_RWFromFile(file, "rb"), 1)
//#define SDL_AllocSurface    SDL_CreateRGBSurface
//#define SDL_PHYSPAL 0x02
//#define SDL_LOGPAL 0x01
//#define SDL_YVYU_OVERLAY  0x55595659  /* Packed mode: Y0+V0+Y1+U0 (1 plane) */
//#define SDL_UYVY_OVERLAY  0x59565955  /* Packed mode: U0+Y0+V0+Y1 (1 plane) */
//#define SDL_YUY2_OVERLAY  0x32595559  /* Packed mode: Y0+U0+Y1+V0 (1 plane) */
//#define SDL_IYUV_OVERLAY  0x56555949  /* Planar mode: Y + U + V  (3 planes) */
//#define SDL_YV12_OVERLAY  0x32315659  /* Planar mode: Y + V + U  (3 planes) */
//#define SDL_MUSTLOCK(surface) \
//#define SDL_PREALLOC  0x01000000      /* Surface uses preallocated memory */
//#define SDL_SRCALPHA  0x00010000      /* Blit uses source alpha blending */
//#define SDL_RLEACCEL  0x00004000      /* Surface is RLE encoded */
//#define SDL_RLEACCELOK        0x00002000      /* Private flag */
//#define SDL_SRCCOLORKEY       0x00001000      /* Blit uses a source color key */
//#define SDL_HWACCEL   0x00000100      /* Blit uses hardware acceleration */
//#define SDL_NOFRAME   0x00000020      /* No window caption or edge frame */
//#define SDL_RESIZABLE 0x00000010      /* This video mode may be resized */
//#define SDL_OPENGLBLIT        0x0000000A      /* Create an OpenGL rendering context and use it for blitting */
//#define SDL_OPENGL      0x00000002      /* Create an OpenGL rendering context */
//#define SDL_FULLSCREEN        0x80000000      /* Surface is a full screen display */
//#define SDL_DOUBLEBUF 0x40000000      /* Set up double-buffered video mode */
//#define SDL_HWPALETTE 0x20000000      /* Surface has exclusive palette */
//#define SDL_ANYFORMAT 0x10000000      /* Allow any video depth/pixel-format */
//#define SDL_ASYNCBLIT 0x00000004      /* Use asynchronous blits if possible */
//#define SDL_HWSURFACE 0x00000001      /* Surface is in video memory */
//#define SDL_SWSURFACE 0x00000000      /* Surface is in system memory */
//#define SDL_Colour SDL_Color
//#define SDL_ALPHA_TRANSPARENT 0
//#define SDL_ALPHA_OPAQUE 255
//#define _SDL_video_h
header '#include "SDL_video.h"';

//INCLUDES
include"SDL/SDL_rwops";
include"SDL/SDL_types";

module SDL_video_h
{
  open C_hack;
  open SDL_rwops_h;
  open SDL_types_h;
  
  fun SDL_MUSTLOCK: ptr[SDL_Surface] -> bool;
  const SDL_PHYSPAL : uint32;
  const SDL_LOGPAL : uint32;
  const SDL_YVYU_OVERLAY  : uint32;
  const SDL_UYVY_OVERLAY  : uint32;
  const SDL_YUY2_OVERLAY  : uint32;
  const SDL_IYUV_OVERLAY  : uint32;
  const SDL_YV12_OVERLAY  : uint32;
  const SDL_PREALLOC  : uint32;
  const SDL_SRCALPHA  : uint32;
  const SDL_RLEACCEL  : uint32;
  const SDL_RLEACCELOK        : uint32;
  const SDL_SRCCOLORKEY       : uint32;
  const SDL_HWACCEL   : uint32;
  const SDL_NOFRAME   : uint32;
  const SDL_RESIZABLE : uint32;
  const SDL_OPENGLBLIT        : uint32;
  const SDL_OPENGL      : uint32;
  const SDL_FULLSCREEN        : uint32;
  const SDL_DOUBLEBUF : uint32;
  const SDL_HWPALETTE : uint32;
  const SDL_ANYFORMAT : uint32;
  const SDL_ASYNCBLIT : uint32;
  const SDL_HWSURFACE : uint32;
  const SDL_SWSURFACE : uint32;

  //ABSTRACT TYPES
  type SDL_GrabMode = 'SDL_GrabMode';
  type SDL_GLattr = 'SDL_GLattr';
  
  //CSTRUCTS 
  cstruct SDL_Color {
    r: uint8;
    g: uint8;
    b: uint8;
    unused: uint8;
  }
  cstruct SDL_Surface {
    flags: uint32;
    format: ptr[SDL_PixelFormat];
    w: int;
    h: int;
    pitch: uint16;
    pixels: address;
    offset: int;
    hwdata: ptr[_struct_private_hwdata];
    clip_rect: SDL_Rect;
    unused1: uint32;
    locked: uint32;
    map: ptr[_struct_SDL_BlitMap];
    format_version: uint;
    refcount: int;
  }
  cstruct SDL_Overlay {
    format: uint32;
    w: int;
    h: int;
    planes: int;
    pitches: ptr[uint16];
    pixels: ptr[ptr[uint8]];
    hwfuncs: ptr[_struct_private_yuvhwfuncs];
    hwdata: ptr[_struct_private_yuvhwdata];
    hw_overlay: uint32;
    UnusedBits: uint32;
  }
  cstruct SDL_Palette {
    ncolors: int;
    colors: ptr[SDL_Color];
  }
  cstruct SDL_Rect {
    x: int16;
    y: int16;
    w: uint16;
    h: uint16;
  }
  cstruct SDL_VideoInfo {
    hw_available: uint32;
    wm_available: uint32;
    UnusedBits1: uint32;
    UnusedBits2: uint32;
    blit_hw: uint32;
    blit_hw_CC: uint32;
    blit_hw_A: uint32;
    blit_sw: uint32;
    blit_sw_CC: uint32;
    blit_sw_A: uint32;
    blit_fill: uint32;
    UnusedBits3: uint32;
    video_mem: uint32;
    vfmt: ptr[SDL_PixelFormat];
  }
  cstruct SDL_PixelFormat {
    palette: ptr[SDL_Palette];
    BitsPerPixel: uint8;
    BytesPerPixel: uint8;
    Rloss: uint8;
    Gloss: uint8;
    Bloss: uint8;
    Aloss: uint8;
    Rshift: uint8;
    Gshift: uint8;
    Bshift: uint8;
    Ashift: uint8;
    Rmask: uint32;
    Gmask: uint32;
    Bmask: uint32;
    Amask: uint32;
    colorkey: uint32;
    alpha: uint8;
  }
  
  //C FUNCTION POINTER TYPES
  header '''typedef int (*SDL_video_h_cft_1)(struct SDL_Surface *,  SDL_Rect *,  struct SDL_Surface *,  SDL_Rect *);''';
  type SDL_video_h_cft_1 = 'SDL_video_h_cft_1';
  
  //EXTERNALLY COMPLETED TYPES
  //type _struct_SDL_Surface defined in SDL_video_h='SDL_video.h';
  
  //PURE INCOMPLETE TYPES
  type _struct_SDL_BlitMap = 'struct SDL_BlitMap'; //local
  type _struct_private_yuvhwfuncs = 'struct private_yuvhwfuncs'; //local
  type _struct_private_hwdata = 'struct private_hwdata'; //local
  type _struct_private_yuvhwdata = 'struct private_yuvhwdata'; //local
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_SDL_Surface = SDL_Surface;
  typedef _struct_SDL_Overlay = SDL_Overlay;
  typedef _struct_SDL_Palette = SDL_Palette;
  typedef _struct_SDL_PixelFormat = SDL_PixelFormat;
  typedef _struct_SDL_Rect = SDL_Rect;
  typedef _struct_SDL_Color = SDL_Color;
  typedef _struct_SDL_VideoInfo = SDL_VideoInfo;
  typedef SDL_blit = SDL_video_h_cft_1;
  
  //ENUMERATION CONSTANTS
  const SDL_GL_STENCIL_SIZE: int = 'SDL_GL_STENCIL_SIZE';
  const SDL_GL_MULTISAMPLEBUFFERS: int = 'SDL_GL_MULTISAMPLEBUFFERS';
  const SDL_GL_STEREO: int = 'SDL_GL_STEREO';
  const SDL_GL_ACCUM_RED_SIZE: int = 'SDL_GL_ACCUM_RED_SIZE';
  const SDL_GRAB_OFF: int = 'SDL_GRAB_OFF';
  const SDL_GL_ACCUM_GREEN_SIZE: int = 'SDL_GL_ACCUM_GREEN_SIZE';
  const SDL_GL_ACCUM_ALPHA_SIZE: int = 'SDL_GL_ACCUM_ALPHA_SIZE';
  const SDL_GL_DEPTH_SIZE: int = 'SDL_GL_DEPTH_SIZE';
  const SDL_GRAB_FULLSCREEN: int = 'SDL_GRAB_FULLSCREEN';
  const SDL_GL_RED_SIZE: int = 'SDL_GL_RED_SIZE';
  const SDL_GL_BLUE_SIZE: int = 'SDL_GL_BLUE_SIZE';
  const SDL_GL_ACCUM_BLUE_SIZE: int = 'SDL_GL_ACCUM_BLUE_SIZE';
  const SDL_GL_GREEN_SIZE: int = 'SDL_GL_GREEN_SIZE';
  const SDL_GRAB_QUERY: int = 'SDL_GRAB_QUERY';
  const SDL_GL_ALPHA_SIZE: int = 'SDL_GL_ALPHA_SIZE';
  const SDL_GL_MULTISAMPLESAMPLES: int = 'SDL_GL_MULTISAMPLESAMPLES';
  const SDL_GL_DOUBLEBUFFER: int = 'SDL_GL_DOUBLEBUFFER';
  const SDL_GL_BUFFER_SIZE: int = 'SDL_GL_BUFFER_SIZE';
  const SDL_GRAB_ON: int = 'SDL_GRAB_ON';
  
  //PROCEDURES
  proc SDL_FreeSurface: ptr[SDL_Surface];
  proc SDL_FreeYUVOverlay: ptr[SDL_Overlay];
  proc SDL_GL_Lock: 1;
  proc SDL_GL_SwapBuffers: 1;
  proc SDL_GL_Unlock: 1;
  proc SDL_GL_UpdateRects: int * ptr[SDL_Rect];
  proc SDL_GetClipRect: ptr[SDL_Surface] * ptr[SDL_Rect];
  proc SDL_GetRGB: uint32 * ptr[SDL_PixelFormat] * ptr[uint8] * ptr[uint8] * ptr[uint8];
  proc SDL_GetRGBA: uint32 * ptr[SDL_PixelFormat] * ptr[uint8] * ptr[uint8] * ptr[uint8] * ptr[uint8];
  proc SDL_UnlockSurface: ptr[SDL_Surface];
  proc SDL_UnlockYUVOverlay: ptr[SDL_Overlay];
  proc SDL_UpdateRect: ptr[SDL_Surface] * int32 * int32 * uint32 * uint32;
  proc SDL_UpdateRects: ptr[SDL_Surface] * int * ptr[SDL_Rect];
  proc SDL_VideoQuit: 1;
  proc SDL_WM_GetCaption: ptr[ptr[char]] * ptr[ptr[char]];
  proc SDL_WM_SetCaption: cptr[char] * cptr[char];
  proc SDL_WM_SetIcon: ptr[SDL_Surface] * ptr[uint8];
  
  //FUNCTIONS
  fun SDL_BlitSurface : ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_ConvertSurface: ptr[SDL_Surface] * ptr[SDL_PixelFormat] * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateRGBSurface: uint32 * int * int * int * uint32 * uint32 * uint32 * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateRGBSurfaceFrom: address * int * int * int * int * uint32 * uint32 * uint32 * uint32 -> ptr[SDL_Surface];
  fun SDL_CreateYUVOverlay: int * int * uint32 * ptr[SDL_Surface] -> ptr[SDL_Overlay];
  fun SDL_DisplayFormat: ptr[SDL_Surface] -> ptr[SDL_Surface];
  fun SDL_DisplayFormatAlpha: ptr[SDL_Surface] -> ptr[SDL_Surface];
  fun SDL_DisplayYUVOverlay: ptr[SDL_Overlay] * ptr[SDL_Rect] -> int;
  fun SDL_FillRect: ptr[SDL_Surface] * ptr[SDL_Rect] * uint32 -> int;
  fun SDL_Flip: ptr[SDL_Surface] -> int;
  fun SDL_GL_GetAttribute: SDL_GLattr * ptr[int] -> int;
  fun SDL_GL_GetProcAddress: cptr[char] -> address;
  fun SDL_GL_LoadLibrary: cptr[char] -> int;
  fun SDL_GL_SetAttribute: SDL_GLattr * int -> int;
  fun SDL_GetGammaRamp: ptr[uint16] * ptr[uint16] * ptr[uint16] -> int;
  fun SDL_GetVideoInfo: 1 -> cptr[SDL_VideoInfo];
  fun SDL_GetVideoSurface: 1 -> ptr[SDL_Surface];
  fun SDL_ListModes: ptr[SDL_PixelFormat] * uint32 -> ptr[ptr[SDL_Rect]];
  fun SDL_LoadBMP_RW: ptr[SDL_RWops] * int -> ptr[SDL_Surface];
  fun SDL_LockSurface: ptr[SDL_Surface] -> int;
  fun SDL_LockYUVOverlay: ptr[SDL_Overlay] -> int;
  fun SDL_LowerBlit: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_MapRGB: ptr[SDL_PixelFormat] * uint8 * uint8 * uint8 -> uint32;
  fun SDL_MapRGBA: ptr[SDL_PixelFormat] * uint8 * uint8 * uint8 * uint8 -> uint32;
  fun SDL_SaveBMP_RW: ptr[SDL_Surface] * ptr[SDL_RWops] * int -> int;
  fun SDL_SetAlpha: ptr[SDL_Surface] * uint32 * uint8 -> int;
  fun SDL_SetClipRect: ptr[SDL_Surface] * cptr[SDL_Rect] -> SDL_bool;
  fun SDL_SetColorKey: ptr[SDL_Surface] * uint32 * uint32 -> int;
  fun SDL_SetColors: ptr[SDL_Surface] * ptr[SDL_Color] * int * int -> int;
  fun SDL_SetGamma: float * float * float -> int;
  fun SDL_SetGammaRamp: cptr[uint16] * cptr[uint16] * cptr[uint16] -> int;
  fun SDL_SetPalette: ptr[SDL_Surface] * int * ptr[SDL_Color] * int * int -> int;
  fun SDL_SetVideoMode: int * int * int * uint32 -> ptr[SDL_Surface];
  fun SDL_SoftStretch: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_UpperBlit: ptr[SDL_Surface] * ptr[SDL_Rect] * ptr[SDL_Surface] * ptr[SDL_Rect] -> int;
  fun SDL_VideoDriverName: ptr[char] * int -> ptr[char];
  fun SDL_VideoInit: cptr[char] * uint32 -> int;
  fun SDL_VideoModeOK: int * int * int * uint32 -> int;
  fun SDL_WM_GrabInput: SDL_GrabMode -> SDL_GrabMode;
  fun SDL_WM_IconifyWindow: 1 -> int;
  fun SDL_WM_ToggleFullScreen: ptr[SDL_Surface] -> int;
}

@h=tangler('lib/SDL/SDL_endian.flx')
@select(h)
//Module        : SDL_endian_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_endian.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDL_SwapBE64(X)       (X)
//#define SDL_SwapBE32(X)       (X)
//#define SDL_SwapBE16(X)       (X)
//#define SDL_SwapLE64(X)       SDL_Swap64(X)
//#define SDL_SwapLE32(X)       SDL_Swap32(X)
//#define SDL_SwapLE16(X)       SDL_Swap16(X)
//#define SDL_SwapBE64(X)       SDL_Swap64(X)
//#define SDL_SwapBE32(X)       SDL_Swap32(X)
//#define SDL_SwapBE16(X)       SDL_Swap16(X)
//#define SDL_SwapLE64(X)       (X)
//#define SDL_SwapLE32(X)       (X)
//#define SDL_SwapLE16(X)       (X)
//#define SDL_Swap64(X) (X)
//#define _SDL_endian_h
header '#include "SDL_endian.h"';

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_types";

module SDL_endian_h
{
  open C_hack;
  open SDL_rwops_h;
  open SDL_types_h;
  
  //FUNCTIONS
  fun SDL_ReadBE16: ptr[SDL_RWops] -> uint16;
  fun SDL_ReadBE32: ptr[SDL_RWops] -> uint32;
  fun SDL_ReadBE64: ptr[SDL_RWops] -> Uint64;
  fun SDL_ReadLE16: ptr[SDL_RWops] -> uint16;
  fun SDL_ReadLE32: ptr[SDL_RWops] -> uint32;
  fun SDL_ReadLE64: ptr[SDL_RWops] -> Uint64;
  fun SDL_Swap16: uint16 -> uint16;
  fun SDL_Swap32: uint32 -> uint32;
  fun SDL_Swap64: Uint64 -> Uint64;
  fun SDL_WriteBE16: ptr[SDL_RWops] * uint16 -> int;
  fun SDL_WriteBE32: ptr[SDL_RWops] * uint32 -> int;
  fun SDL_WriteBE64: ptr[SDL_RWops] * Uint64 -> int;
  fun SDL_WriteLE16: ptr[SDL_RWops] * uint16 -> int;
  fun SDL_WriteLE32: ptr[SDL_RWops] * uint32 -> int;
  fun SDL_WriteLE64: ptr[SDL_RWops] * Uint64 -> int;
}

@h=tangler('lib/SDL/SDL_framerate.flx')
@select(h)
//Module        : SDL_framerate_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_framerate.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define FPS_DEFAULT           30
//#define FPS_LOWER_LIMIT               1
//#define FPS_UPPER_LIMIT               200
//#define _SDL_framerate_h
header '#include "SDL_framerate.h"';

//INCLUDES
include "SDL/SDL";

module SDL_framerate_h
{
  open C_hack;
  open SDL_h;
  
  //ABSTRACT TYPES
  type FPSmanager = 'FPSmanager';
  
  //PROCEDURES
  proc SDL_framerateDelay: ptr[FPSmanager];
  proc SDL_initFramerate: ptr[FPSmanager];
  
  //FUNCTIONS
  fun SDL_getFramerate: ptr[FPSmanager] -> int;
  fun SDL_setFramerate: ptr[FPSmanager] * int -> int;
}
@h=tangler('lib/SDL/SDL_gfxPrimitives.flx')
@select(h)
//Module        : SDL_gfxPrimitives_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_gfxPrimitives.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define SDL_GFXPRIMITIVES_MINOR       0
//#define SDL_GFXPRIMITIVES_MAJOR       2
//#define M_PI  3.141592654
//#define _SDL_gfxPrimitives_h
header '#include "SDL_gfxPrimitives.h"';

//INCLUDES
include "SDL/SDL";
include "SDL/SDL_video";

module SDL_gfxPrimitives_h
{
  open C_hack;
  open SDL_h;
  open SDL_video_h;
  open math_h;
  
  //FUNCTIONS
  fun aacircleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun aacircleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aaellipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aaellipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aalineColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aalineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun aapolygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint32 -> int;
  fun aapolygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun aatrigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun aatrigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun bezierColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int * uint32 -> int;
  fun bezierRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun boxColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun boxRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun characterColor: ptr[SDL_Surface] * int16 * int16 * char * uint32 -> int;
  fun characterRGBA: ptr[SDL_Surface] * int16 * int16 * char * uint8 * uint8 * uint8 * uint8 -> int;
  fun circleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun circleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun ellipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun ellipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledCircleColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun filledCircleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledEllipseColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun filledEllipseRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledPolygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * int -> int;
  fun filledPolygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledTrigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * int -> int;
  fun filledTrigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun filledpieColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun filledpieRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun hlineColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun hlineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun lineColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun lineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun pixelColor: ptr[SDL_Surface] * int16 * int16 * uint32 -> int;
  fun pixelRGBA: ptr[SDL_Surface] * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun polygonColor: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint32 -> int;
  fun polygonRGBA: ptr[SDL_Surface] * ptr[int16] * ptr[int16] * int * uint8 * uint8 * uint8 * uint8 -> int;
  fun rectangleColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint32 -> int;
  fun rectangleRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun stringColor: ptr[SDL_Surface] * int16 * int16 * ptr[char] * uint32 -> int;
  fun stringRGBA: ptr[SDL_Surface] * int16 * int16 * ptr[char] * uint8 * uint8 * uint8 * uint8 -> int;
  fun trigonColor: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint32 -> int;
  fun trigonRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
  fun vlineColor: ptr[SDL_Surface] * int16 * int16 * int16 * uint32 -> int;
  fun vlineRGBA: ptr[SDL_Surface] * int16 * int16 * int16 * uint8 * uint8 * uint8 * uint8 -> int;
}
@h=tangler('lib/SDL/SDL_gfxPrimitives_font.flx')
@select(h)
//Module        : SDL_gfxPrimitives_font_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_gfxPrimitives_font.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define GFX_FONTDATAMAX (8*256)
header '#include "SDL_gfxPrimitives_font.h"';

module SDL_gfxPrimitives_font_h
{
  open C_hack;
  
  //VARIABLES
  const gfxPrimitivesFontdata: ptr[utiny] = 'gfxPrimitivesFontdata';
}
@h=tangler('lib/SDL/SDL_image.flx')
@select(h)
//Module        : SDL_image_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_image.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define IMG_GetError  SDL_GetError
//#define IMG_SetError  SDL_SetError
//#define SDL_IMAGE_VERSION(X)                                          \
//#define SDL_IMAGE_PATCHLEVEL  4
//#define SDL_IMAGE_MINOR_VERSION       2
//#define SDL_IMAGE_MAJOR_VERSION       1
//#define _SDL_IMAGE_H
header '#include "SDL_image.h"';

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";
include "SDL/SDL_video";

module SDL_image_h
{
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  open SDL_video_h;
  
  //FUNCTIONS
  fun IMG_InvertAlpha: int -> int;
  fun IMG_Linked_Version: 1 -> cptr[SDL_version];
  fun IMG_Load: cptr[char] -> ptr[SDL_Surface];
  fun IMG_LoadBMP_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadGIF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadJPG_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadLBM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPCX_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPNG_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadPNM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTGA_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTIF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadTyped_RW: ptr[SDL_RWops] * int * ptr[char] -> ptr[SDL_Surface];
  fun IMG_LoadXCF_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_LoadXPM_RW: ptr[SDL_RWops] -> ptr[SDL_Surface];
  fun IMG_Load_RW: ptr[SDL_RWops] * int -> ptr[SDL_Surface];
  fun IMG_ReadXPMFromArray: ptr[ptr[char]] -> ptr[SDL_Surface];
  fun IMG_isBMP: ptr[SDL_RWops] -> int;
  fun IMG_isGIF: ptr[SDL_RWops] -> int;
  fun IMG_isJPG: ptr[SDL_RWops] -> int;
  fun IMG_isLBM: ptr[SDL_RWops] -> int;
  fun IMG_isPCX: ptr[SDL_RWops] -> int;
  fun IMG_isPNG: ptr[SDL_RWops] -> int;
  fun IMG_isPNM: ptr[SDL_RWops] -> int;
  fun IMG_isTIF: ptr[SDL_RWops] -> int;
  fun IMG_isXCF: ptr[SDL_RWops] -> int;
  fun IMG_isXPM: ptr[SDL_RWops] -> int;
}
@h=tangler('lib/SDL/SDL_imageFilter.flx')
@select(h)
//Module        : SDL_imageFilter_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_imageFilter.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define _SDL_imageFilter_h
header '#include "SDL_imageFilter.h"';

module SDL_imageFilter_h
{
  open C_hack;
  
  //PROCEDURES
  proc SDL_imageFilterAlignStack: 1;
  proc SDL_imageFilterMMXoff: 1;
  proc SDL_imageFilterMMXon: 1;
  proc SDL_imageFilterRestoreStack: 1;
  
  //FUNCTIONS
  fun SDL_imageFilterAbsDiff: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterAdd: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterAddByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterAddByteToHalf: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterBinarizeUsingThreshold: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterBitAnd: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterBitNegation: ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterBitOr: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterClipToRange: ptr[utiny] * ptr[utiny] * int * utiny * utiny -> int;
  fun SDL_imageFilterConvolveKernel3x3Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel3x3ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel5x5Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel5x5ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel7x7Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel7x7ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel9x9Divide: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterConvolveKernel9x9ShiftRight: ptr[utiny] * ptr[utiny] * int * int * ptr[short] * utiny -> int;
  fun SDL_imageFilterDiv: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMMXdetect: 1 -> int;
  fun SDL_imageFilterMean: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMult: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultByByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterMultDivby2: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultDivby4: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterMultNor: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterNormalizeLinear: ptr[utiny] * ptr[utiny] * int * int * int * int * int -> int;
  fun SDL_imageFilterShiftLeft: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftLeftByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftRight: ptr[utiny] * ptr[utiny] * int * utiny -> int;
  fun SDL_imageFilterShiftRightAndMultByByte: ptr[utiny] * ptr[utiny] * int * utiny * utiny -> int;
  fun SDL_imageFilterSobelX: ptr[utiny] * ptr[utiny] * int * int -> int;
  fun SDL_imageFilterSobelXShiftRight: ptr[utiny] * ptr[utiny] * int * int * utiny -> int;
  fun SDL_imageFilterSub: ptr[utiny] * ptr[utiny] * ptr[utiny] * int -> int;
  fun SDL_imageFilterSubByte: ptr[utiny] * ptr[utiny] * int * utiny -> int;
}
@h=tangler('lib/SDL/SDL_mixer.flx')
@select(h)
//Module        : SDL_mixer_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_mixer.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define Mix_GetError  SDL_GetError
//#define Mix_SetError  SDL_SetError
//#define Mix_FadeInChannel(channel,chunk,loops,ms) Mix_FadeInChannelTimed(channel,chunk,loops,ms,-1)
//#define Mix_PlayChannel(channel,chunk,loops) Mix_PlayChannelTimed(channel,chunk,loops,-1)
//#define MIX_EFFECTSMAXSPEED  "MIX_EFFECTSMAXSPEED"
//#define MIX_CHANNEL_POST  -2
//#define Mix_LoadWAV(file)     Mix_LoadWAV_RW(SDL_RWFromFile(file, "rb"), 1)
//#define MIX_MAX_VOLUME                128     /* Volume of a chunk */
//#define MIX_DEFAULT_CHANNELS  2
//#define MIX_DEFAULT_FORMAT    AUDIO_S16MSB
//#define MIX_DEFAULT_FORMAT    AUDIO_S16LSB
//#define MIX_DEFAULT_FREQUENCY 22050
//#define MIX_CHANNELS  8
//#define MIX_VERSION(X)                SDL_MIXER_VERSION(X)
//#define MIX_PATCHLEVEL                SDL_MIXER_PATCHLEVEL
//#define MIX_MINOR_VERSION     SDL_MIXER_MINOR_VERSION
//#define MIX_MAJOR_VERSION     SDL_MIXER_MAJOR_VERSION
//#define SDL_MIXER_VERSION(X)                                          \
//#define SDL_MIXER_PATCHLEVEL  6
//#define SDL_MIXER_MINOR_VERSION       2
//#define SDL_MIXER_MAJOR_VERSION       1
//#define _SDL_MIXER_H
header '#include "SDL_mixer.h"';

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";

module SDL_mixer_h
{
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  
  //ABSTRACT TYPES
  type Mix_MusicType = 'Mix_MusicType';
  type Mix_Chunk = 'Mix_Chunk';
  type Mix_Fading = 'Mix_Fading';
  
  //C FUNCTION POINTER TYPES
  header '''typedef void (*SDL_mixer_h_cft_3)(void *, Uint8 *, int);''';
  type SDL_mixer_h_cft_3 = 'SDL_mixer_h_cft_3';
  header '''typedef void (*SDL_mixer_h_cft_1)(int, void *, int,  void *);''';
  type SDL_mixer_h_cft_1 = 'SDL_mixer_h_cft_1';
  header '''typedef void (*SDL_mixer_h_cft_2)(int, void *);''';
  type SDL_mixer_h_cft_2 = 'SDL_mixer_h_cft_2';
  header '''typedef void (*SDL_mixer_h_cft_5)(int);''';
  type SDL_mixer_h_cft_5 = 'SDL_mixer_h_cft_5';
  header '''typedef void (*SDL_mixer_h_cft_4)(void);''';
  type SDL_mixer_h_cft_4 = 'SDL_mixer_h_cft_4';
  
  //PURE INCOMPLETE TYPES
  type _struct__Mix_Music = 'struct _Mix_Music'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef Mix_Music = _struct__Mix_Music;
  
  //TYPE ALIASES
  typedef Mix_EffectDone_t = SDL_mixer_h_cft_2;
  typedef Mix_EffectFunc_t = SDL_mixer_h_cft_1;
  
  //ENUMERATION CONSTANTS
  const MUS_CMD: int = 'MUS_CMD';
  const MIX_FADING_OUT: int = 'MIX_FADING_OUT';
  const MIX_NO_FADING: int = 'MIX_NO_FADING';
  const MIX_FADING_IN: int = 'MIX_FADING_IN';
  const MUS_WAV: int = 'MUS_WAV';
  const MUS_MID: int = 'MUS_MID';
  const MUS_OGG: int = 'MUS_OGG';
  const MUS_NONE: int = 'MUS_NONE';
  const MUS_MOD: int = 'MUS_MOD';
  const MUS_MP3: int = 'MUS_MP3';
  
  //PROCEDURES
  proc Mix_ChannelFinished: SDL_mixer_h_cft_5;
  proc Mix_CloseAudio: 1;
  proc Mix_FreeChunk: ptr[Mix_Chunk];
  proc Mix_FreeMusic: ptr[Mix_Music];
  proc Mix_HookMusic: SDL_mixer_h_cft_3 * address;
  proc Mix_HookMusicFinished: SDL_mixer_h_cft_4;
  proc Mix_Pause: int;
  proc Mix_PauseMusic: 1;
  proc Mix_Resume: int;
  proc Mix_ResumeMusic: 1;
  proc Mix_RewindMusic: 1;
  proc Mix_SetPostMix: SDL_mixer_h_cft_3 * address;
  
  //FUNCTIONS
  fun Mix_AllocateChannels: int -> int;
  fun Mix_ExpireChannel: int * int -> int;
  fun Mix_FadeInChannelTimed: int * ptr[Mix_Chunk] * int * int * int -> int;
  fun Mix_FadeInMusic: ptr[Mix_Music] * int * int -> int;
  fun Mix_FadeInMusicPos: ptr[Mix_Music] * int * int * double -> int;
  fun Mix_FadeOutChannel: int * int -> int;
  fun Mix_FadeOutGroup: int * int -> int;
  fun Mix_FadeOutMusic: int -> int;
  fun Mix_FadingChannel: int -> Mix_Fading;
  fun Mix_FadingMusic: 1 -> Mix_Fading;
  fun Mix_GetChunk: int -> ptr[Mix_Chunk];
  fun Mix_GetMusicHookData: 1 -> address;
  fun Mix_GetMusicType: cptr[Mix_Music] -> Mix_MusicType;
  fun Mix_GetSynchroValue: 1 -> int;
  fun Mix_GroupAvailable: int -> int;
  fun Mix_GroupChannel: int * int -> int;
  fun Mix_GroupChannels: int * int * int -> int;
  fun Mix_GroupCount: int -> int;
  fun Mix_GroupNewer: int -> int;
  fun Mix_GroupOldest: int -> int;
  fun Mix_HaltChannel: int -> int;
  fun Mix_HaltGroup: int -> int;
  fun Mix_HaltMusic: 1 -> int;
  fun Mix_Linked_Version: 1 -> cptr[SDL_version];
  fun Mix_LoadMUS: cptr[char] -> ptr[Mix_Music];
  fun Mix_LoadWAV_RW: ptr[SDL_RWops] * int -> ptr[Mix_Chunk];
  fun Mix_OpenAudio: int * uint16 * int * int -> int;
  fun Mix_Paused: int -> int;
  fun Mix_PausedMusic: 1 -> int;
  fun Mix_PlayChannelTimed: int * ptr[Mix_Chunk] * int * int -> int;
  fun Mix_PlayMusic: ptr[Mix_Music] * int -> int;
  fun Mix_Playing: int -> int;
  fun Mix_PlayingMusic: 1 -> int;
  fun Mix_QuerySpec: ptr[int] * ptr[uint16] * ptr[int] -> int;
  fun Mix_QuickLoad_RAW: ptr[uint8] * uint32 -> ptr[Mix_Chunk];
  fun Mix_QuickLoad_WAV: ptr[uint8] -> ptr[Mix_Chunk];
  fun Mix_RegisterEffect: int * SDL_mixer_h_cft_1 * SDL_mixer_h_cft_2 * address -> int;
  fun Mix_ReserveChannels: int -> int;
  fun Mix_SetDistance: int * uint8 -> int;
  fun Mix_SetMusicCMD: cptr[char] -> int;
  fun Mix_SetMusicPosition: double -> int;
  fun Mix_SetPanning: int * uint8 * uint8 -> int;
  fun Mix_SetPosition: int * int16 * uint8 -> int;
  fun Mix_SetReverseStereo: int * int -> int;
  fun Mix_SetSynchroValue: int -> int;
  fun Mix_UnregisterAllEffects: int -> int;
  fun Mix_UnregisterEffect: int * SDL_mixer_h_cft_1 -> int;
  fun Mix_Volume: int * int -> int;
  fun Mix_VolumeChunk: ptr[Mix_Chunk] * int -> int;
  fun Mix_VolumeMusic: int -> int;
  
  //CALLBACK TYPE WRAPPERS
  //callback type SDL_mixer_h_cft_2, client data at 1
  typedef _fcbat_SDL_mixer_h_cft_2 = int; 
  export type (_fcbat_SDL_mixer_h_cft_2) as "_fcbat_SDL_mixer_h_cft_2";
  typedef _fcbt_SDL_mixer_h_cft_2 = int -> void; 
  export type (_fcbt_SDL_mixer_h_cft_2) as "_fcbt_SDL_mixer_h_cft_2";
  header '''void _fcbw_SDL_mixer_h_cft_2(int a1, void *a2);''';

  const _fcbw_SDL_mixer_h_cft_2: SDL_mixer_h_cft_2 = "_fcbw_SDL_mixer_h_cft_2";
  body '''
  void _fcbw_SDL_mixer_h_cft_2(int a1, void *a2){
    con_t *p  = ((_fcbt_SDL_mixer_h_cft_2)a2)->call(0, a1);
    while(p) p=p->resume();
  }''';

  //callback type SDL_mixer_h_cft_3, client data at 0
  typedef _fcbat_SDL_mixer_h_cft_3 = ptr[uint8] * int; 
  export type (_fcbat_SDL_mixer_h_cft_3) as "_fcbat_SDL_mixer_h_cft_3";
  typedef _fcbt_SDL_mixer_h_cft_3 = ptr[uint8] * int -> void; 
  export type (_fcbt_SDL_mixer_h_cft_3) as "_fcbt_SDL_mixer_h_cft_3";
  header '''void _fcbw_SDL_mixer_h_cft_3(void *a1, Uint8 *a2, int a3);''';

  const _fcbw_SDL_mixer_h_cft_3: SDL_mixer_h_cft_3 = "_fcbw_SDL_mixer_h_cft_3";
  body '''
  void _fcbw_SDL_mixer_h_cft_3(void *a1, Uint8 *a2, int a3){
    con_t *p  = ((_fcbt_SDL_mixer_h_cft_3)a1)->call(0, _fcbat_SDL_mixer_h_cft_3(a2, a3));
    while(p) p=p->resume();
  }''';

  
  //CALLBACK CLIENT WRAPPERS
  //callback client Mix_HookMusic, client data at 0, callback at 1
  proc wrapper_Mix_HookMusic(a1: _fcbt_SDL_mixer_h_cft_3) {
    Mix_HookMusic(_fcbw_SDL_mixer_h_cft_3, C_hack::cast[address]a1);
  }
  //callback client Mix_RegisterEffect, client data at 2, callback at 3
  fun wrapper_Mix_RegisterEffect(a1: int, a2: SDL_mixer_h_cft_1, a3: _fcbt_SDL_mixer_h_cft_2): int= {
    return Mix_RegisterEffect(a1, a2, _fcbw_SDL_mixer_h_cft_2, C_hack::cast[address]a3);
  }
  //callback client Mix_SetPostMix, client data at 0, callback at 1
  proc wrapper_Mix_SetPostMix(a1: _fcbt_SDL_mixer_h_cft_3) {
    Mix_SetPostMix(_fcbw_SDL_mixer_h_cft_3, C_hack::cast[address]a1);
  }
}
@h=tangler('lib/SDL/SDL_sound.flx')
@select(h)
//Module        : SDL_sound_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_sound.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SOUND_VERSION(x) \
//#define SOUND_VER_PATCH 1
//#define SOUND_VER_MINOR 0
//#define SOUND_VER_MAJOR 1
//#define SNDDECLSPEC
//#define SNDDECLSPEC __declspec(dllexport)
//#define SDLCALL
//#define _INCLUDE_SDL_SOUND_H_
header '#include "SDL_sound.h"';

//INCLUDES
include "SDL/SDL_rwops";

module SDL_sound_h
{
  open C_hack;
  open SDL_rwops_h;
  
  //ABSTRACT TYPES
  type Sound_Sample = 'Sound_Sample';
  type Sound_Version = 'Sound_Version';
  type Sound_AudioInfo = 'Sound_AudioInfo';
  type Sound_SampleFlags = 'Sound_SampleFlags';
  type Sound_DecoderInfo = 'Sound_DecoderInfo';
  
  //ENUMERATION CONSTANTS
  const SOUND_SAMPLEFLAG_ERROR: int = 'SOUND_SAMPLEFLAG_ERROR';
  const SOUND_SAMPLEFLAG_NONE: int = 'SOUND_SAMPLEFLAG_NONE';
  const SOUND_SAMPLEFLAG_EAGAIN: int = 'SOUND_SAMPLEFLAG_EAGAIN';
  const SOUND_SAMPLEFLAG_EOF: int = 'SOUND_SAMPLEFLAG_EOF';
  const SOUND_SAMPLEFLAG_CANSEEK: int = 'SOUND_SAMPLEFLAG_CANSEEK';
  
  //PROCEDURES
  proc Sound_ClearError: 1;
  proc Sound_FreeSample: ptr[Sound_Sample];
  proc Sound_GetLinkedVersion: ptr[Sound_Version];
  
  //FUNCTIONS
  fun Sound_AvailableDecoders: 1 -> ptr[cptr[Sound_DecoderInfo]];
  fun Sound_Decode: ptr[Sound_Sample] -> uint32;
  fun Sound_DecodeAll: ptr[Sound_Sample] -> uint32;
  fun Sound_GetError: 1 -> cptr[char];
  fun Sound_Init: 1 -> int;
  fun Sound_NewSample: ptr[SDL_RWops] * cptr[char] * ptr[Sound_AudioInfo] * uint32 -> ptr[Sound_Sample];
  fun Sound_NewSampleFromFile: cptr[char] * ptr[Sound_AudioInfo] * uint32 -> ptr[Sound_Sample];
  fun Sound_Quit: 1 -> int;
  fun Sound_Rewind: ptr[Sound_Sample] -> int;
  fun Sound_Seek: ptr[Sound_Sample] * uint32 -> int;
  fun Sound_SetBufferSize: ptr[Sound_Sample] * uint32 -> int;
}
@h=tangler('lib/SDL/SDL_rotozoom.flx')
@select(h)
//Module        : SDL_rotozoom_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_rotozoom.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define DLLINTERFACE
//#define DLLINTERFACE __declspec(dllimport)
//#define DLLINTERFACE __declspec(dllexport)
//#define SMOOTHING_ON          1
//#define SMOOTHING_OFF         0
//#define M_PI  3.141592654
//#define _SDL_rotozoom_h
header '#include "SDL_rotozoom.h"';

//INCLUDES
include "SDL/SDL";
include "SDL/SDL_video";

module SDL_rotozoom_h
{
  open C_hack;
  open SDL_h;
  open SDL_video_h;
  open math_h;
  
  //CSTRUCTS 
  cstruct tColorRGBA {
    r: uint8;
    g: uint8;
    b: uint8;
    a: uint8;
  }
  cstruct tColorY {
    y: uint8;
  }
  
  //STRUCT or UNION TAG ALIASES
  
  //TYPE ALIASES
  typedef _struct_tColorY = tColorY;
  typedef _struct_tColorRGBA = tColorRGBA;
  
  //PROCEDURES
  proc rotozoomSurfaceSize: int * int * double * double * ptr[int] * ptr[int];
  proc zoomSurfaceSize: int * int * double * double * ptr[int] * ptr[int];
  
  //FUNCTIONS
  fun rotozoomSurface: ptr[SDL_Surface] * double * double * int -> ptr[SDL_Surface];
  fun zoomSurface: ptr[SDL_Surface] * double * double * int -> ptr[SDL_Surface];
}
@h=tangler('lib/SDL/SDL_ttf.flx')
@select(h)
//Module        : SDL_ttf_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_ttf.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define TTF_GetError  SDL_GetError
//#define TTF_SetError  SDL_SetError
//#define TTF_RenderUNICODE(font, text, fg, bg) \
//#define TTF_RenderUTF8(font, text, fg, bg)    \
//#define TTF_RenderText(font, text, fg, bg)    \
//#define TTF_STYLE_UNDERLINE   0x04
//#define TTF_STYLE_ITALIC      0x02
//#define TTF_STYLE_BOLD                0x01
//#define TTF_STYLE_NORMAL      0x00
//#define UNICODE_BOM_SWAPPED   0xFFFE
//#define UNICODE_BOM_NATIVE    0xFEFF
//#define TTF_VERSION(X)                                                        \
//#define TTF_PATCHLEVEL                6
//#define TTF_MINOR_VERSION     0
//#define TTF_MAJOR_VERSION     2
//#define _SDLttf_h
header '#include "SDL_ttf.h"';

//INCLUDES
include "SDL/SDL_rwops";
include "SDL/SDL_version";
include "SDL/SDL_video";

module SDL_ttf_h
{
  open C_hack;
  open SDL_rwops_h;
  open SDL_version_h;
  open SDL_video_h;
  
  //PURE INCOMPLETE TYPES
  type _struct__TTF_Font = 'struct _TTF_Font'; //local
  
  //STRUCT or UNION TAG ALIASES
  typedef TTF_Font = _struct__TTF_Font;
  
  //PROCEDURES
  proc TTF_ByteSwappedUNICODE: int;
  proc TTF_CloseFont: ptr[TTF_Font];
  proc TTF_Quit: 1;
  proc TTF_SetFontStyle: ptr[TTF_Font] * int;
  
  //FUNCTIONS
  fun TTF_FontAscent: ptr[TTF_Font] -> int;
  fun TTF_FontDescent: ptr[TTF_Font] -> int;
  fun TTF_FontFaceFamilyName: ptr[TTF_Font] -> ptr[char];
  fun TTF_FontFaceIsFixedWidth: ptr[TTF_Font] -> int;
  fun TTF_FontFaceStyleName: ptr[TTF_Font] -> ptr[char];
  fun TTF_FontFaces: ptr[TTF_Font] -> long;
  fun TTF_FontHeight: ptr[TTF_Font] -> int;
  fun TTF_FontLineSkip: ptr[TTF_Font] -> int;
  fun TTF_GetFontStyle: ptr[TTF_Font] -> int;
  fun TTF_GlyphMetrics: ptr[TTF_Font] * uint16 * ptr[int] * ptr[int] * ptr[int] * ptr[int] * ptr[int] -> int;
  fun TTF_Init: 1 -> int;
  fun TTF_Linked_Version: 1 -> cptr[SDL_version];
  fun TTF_OpenFont: cptr[char] * int -> ptr[TTF_Font];
  fun TTF_OpenFontIndex: cptr[char] * int * long -> ptr[TTF_Font];
  fun TTF_OpenFontIndexRW: ptr[SDL_RWops] * int * int * long -> ptr[TTF_Font];
  fun TTF_OpenFontRW: ptr[SDL_RWops] * int * int -> ptr[TTF_Font];
  fun TTF_RenderGlyph_Blended: ptr[TTF_Font] * uint16 * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderGlyph_Shaded: ptr[TTF_Font] * uint16 * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderGlyph_Solid: ptr[TTF_Font] * uint16 * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Blended: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Shaded: ptr[TTF_Font] * cptr[char] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderText_Solid: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Blended: ptr[TTF_Font] * cptr[uint16] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Shaded: ptr[TTF_Font] * cptr[uint16] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUNICODE_Solid: ptr[TTF_Font] * cptr[uint16] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Blended: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Shaded: ptr[TTF_Font] * cptr[char] * SDL_Color * SDL_Color -> ptr[SDL_Surface];
  fun TTF_RenderUTF8_Solid: ptr[TTF_Font] * cptr[char] * SDL_Color -> ptr[SDL_Surface];
  fun TTF_SizeText: ptr[TTF_Font] * cptr[char] * ptr[int] * ptr[int] -> int;
  fun TTF_SizeUNICODE: ptr[TTF_Font] * cptr[uint16] * ptr[int] * ptr[int] -> int;
  fun TTF_SizeUTF8: ptr[TTF_Font] * cptr[char] * ptr[int] * ptr[int] -> int;
  fun TTF_WasInit: 1 -> int;
}
@h=tangler('lib/SDL/SDL_net.flx')
@select(h)
//Module        : SDL_net_h
//Timestamp     : 2006/1/8 3:36:0 UTC
//Timestamp     : 2006/1/8 14:36:0 (local)
//Raw Header    : /usr/include/SDL/SDL_net.h
//Preprocessor  : gcc -E
//Input file: sdl.flxcc.i
//Flxcc Control : sdl.flxcc
//Felix Version : 1.1.2_rc1
include 'std';

//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read32(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Read16(areap)          \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write32(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDLNet_Write16(value, areap)  \
//#define SDL_DATA_ALIGNED      0
//#define SDL_DATA_ALIGNED      1
//#define SDLNet_GetError       SDL_GetError
//#define SDLNet_SetError       SDL_SetError
//#define SDLNet_SocketReady(sock) \
//#define SDLNet_UDP_DelSocket(set, sock) \
//#define SDLNet_TCP_DelSocket(set, sock) \
//#define SDLNet_UDP_AddSocket(set, sock) \
//#define SDLNet_TCP_AddSocket(set, sock) \
//#define SDLNET_MAX_UDPADDRESSES       4
//#define SDLNET_MAX_UDPCHANNELS        32
//#define INADDR_BROADCAST      0xFFFFFFFF
//#define INADDR_NONE           0xFFFFFFFF
//#define INADDR_ANY            0x00000000
//#define _SDLnet_h
header '#include "SDL_net.h"';

module SDL_net_h
{
  open C_hack;
  
  //ABSTRACT TYPES
  type SDLNet_GenericSocket = 'SDLNet_GenericSocket';
  type IPaddress = 'IPaddress';
  type UDPpacket = 'UDPpacket';
  
  //PURE INCOMPLETE TYPES
  type _struct__UDPsocket = 'struct _UDPsocket'; //local
  type _struct__SDLNet_SocketSet = 'struct _SDLNet_SocketSet'; //local
  type _struct__TCPsocket = 'struct _TCPsocket'; //local
  
  //TYPE ALIASES
  typedef UDPsocket = ptr[_struct__UDPsocket];
  typedef TCPsocket = ptr[_struct__TCPsocket];
  typedef SDLNet_SocketSet = ptr[_struct__SDLNet_SocketSet];
  
  //PROCEDURES
  proc SDLNet_FreePacket: ptr[UDPpacket];
  proc SDLNet_FreePacketV: ptr[ptr[UDPpacket]];
  proc SDLNet_FreeSocketSet: SDLNet_SocketSet;
  proc SDLNet_Quit: 1;
  proc SDLNet_TCP_Close: TCPsocket;
  proc SDLNet_UDP_Close: UDPsocket;
  proc SDLNet_UDP_Unbind: UDPsocket * int;
  proc SDLNet_Write16: uint16 * address;
  proc SDLNet_Write32: uint32 * address;
  
  //FUNCTIONS
  fun SDLNet_AddSocket: SDLNet_SocketSet * SDLNet_GenericSocket -> int;
  fun SDLNet_AllocPacket: int -> ptr[UDPpacket];
  fun SDLNet_AllocPacketV: int * int -> ptr[ptr[UDPpacket]];
  fun SDLNet_AllocSocketSet: int -> SDLNet_SocketSet;
  fun SDLNet_CheckSockets: SDLNet_SocketSet * uint32 -> int;
  fun SDLNet_DelSocket: SDLNet_SocketSet * SDLNet_GenericSocket -> int;
  fun SDLNet_Init: 1 -> int;
  fun SDLNet_Read16: address -> uint16;
  fun SDLNet_Read32: address -> uint32;
  fun SDLNet_ResizePacket: ptr[UDPpacket] * int -> int;
  fun SDLNet_ResolveHost: ptr[IPaddress] * cptr[char] * uint16 -> int;
  fun SDLNet_ResolveIP: ptr[IPaddress] -> cptr[char];
  fun SDLNet_TCP_Accept: TCPsocket -> TCPsocket;
  fun SDLNet_TCP_GetPeerAddress: TCPsocket -> ptr[IPaddress];
  fun SDLNet_TCP_Open: ptr[IPaddress] -> TCPsocket;
  fun SDLNet_TCP_Recv: TCPsocket * address * int -> int;
  fun SDLNet_TCP_Send: TCPsocket * address * int -> int;
  fun SDLNet_UDP_Bind: UDPsocket * int * ptr[IPaddress] -> int;
  fun SDLNet_UDP_GetPeerAddress: UDPsocket * int -> ptr[IPaddress];
  fun SDLNet_UDP_Open: uint16 -> UDPsocket;
  fun SDLNet_UDP_Recv: UDPsocket * ptr[UDPpacket] -> int;
  fun SDLNet_UDP_RecvV: UDPsocket * ptr[ptr[UDPpacket]] -> int;
  fun SDLNet_UDP_Send: UDPsocket * int * ptr[UDPpacket] -> int;
  fun SDLNet_UDP_SendV: UDPsocket * ptr[ptr[UDPpacket]] * int -> int;
}

@h = tangler("faio/faio_sdl_event.hpp")
@select(h)
#ifndef __FAIO_SDL_EVENT__
#define __FAIO_SDL_EVENT__
#include <flx_rtl_config.hpp>
#include "demux_work_fifo.hpp"
#include "faio_drv.hpp"      // thread_wakeups, 
#include "faio_asyncio.hpp"  // flx_driver_request_base
#include <SDL_events.h>

namespace flx { namespace faio {

// ONE PROBLEM: this is faio level. It needs to know about fthreads

// get ONE SDL event
class FLX_RTL_EXTERN faio_sdl_event : public flx_driver_request_base,
  public demux::worker_task {
   thread_wakeup   fw;
   SDL_Event *e;
public:  
  faio_sdl_event() {}     // felix linkage
  faio_sdl_event(SDL_Event *_e);

  // from flx_driver_request_base
  bool start_async_op(demux::demuxer& demux, flx_drv* drv,  void* f);

  // from fifo_worker_task
  void doit();
  void finished();
};

}}
#endif

@h = tangler("faio/faio_sdl_event.cpp")
@select(h)
#include <demux_work_fifo.hpp>
#include <SDL_events.h>
#include "faio_sdl_event.hpp"

namespace flx { namespace faio {

faio_sdl_event::faio_sdl_event(SDL_Event *_e) : e(_e) {}

bool
faio_sdl_event::start_async_op(demux::demuxer& demux, flx_drv* drv, void* f)
{
  RECORD_THREAD_INFO(fw);    // so we can wake up

  // get worker fifo, add this task
  drv->get_worker_fifo()->add_worker_task(this);
  return false;              // suspended
}

void faio_sdl_event::doit() { SDL_WaitEvent(e); }  // blocks in pthread

void faio_sdl_event::finished(){ fw.wake(); }

}}

@h=tangler('lib/flx_faio_sdl.flx')
@select(h)
#import <flx.flxh>

include "SDL/SDL";
include "SDL/SDL_events";
include "flx_faio";

module SDL_events 
{
  open SDL_events_h;
  header faio_sdl_event_hpp = '#include "faio_sdl_event.hpp"';

  private type sdl_event_request = 
    "flx::faio::faio_sdl_event"
    requires faio_sdl_event_hpp
  ;

  private fun mk_sdl_event_request: ptr[SDL_Event] -> sdl_event_request = 
    "flx::faio::faio_sdl_event($1)";

  fun event_type: SDL_Event -> int = "$1.type";

  proc get_sdl_event(pe:&SDL_Event)
  {
    var cpe = unref pe;
    var req = mk_sdl_event_request cpe;
    Faio::faio_req$ &req;
  }
}

@h = tangler("tut/examples/sdl100.flx")
@select(h)
#import <flx.flxh>
include "SDL/SDL";
include "SDL/SDL_video";
include "SDL/SDL_rwops";
include "SDL/SDL_image";
include "SDL/SDL_events";
include "SDL/SDL_audio";
include "flx_faio";
include "flx_faio_sdl";

// Raw SDL interfaces
open SDL_h;
open SDL_video_h;
open SDL_rwops_h;
open SDL_image_h;
open SDL_events_h;
open SDL_audio_h;

open C_hack;
open Carray;
open MixedInt;
open Uint32;
open Uint8;

// This is the Felix asynchronous event source 
open SDL_events;

proc DrawPixel(screen:ptr[SDL_Surface], x:int32, y:int32, R:uint8, G:uint8, B:uint8)
{
    color := SDL_MapRGB((*screen).format, R, G, B);

    if SDL_MUSTLOCK(screen) do
        if SDL_LockSurface(screen) < 0 return;
    done;

    match (*(*screen).format).BytesPerPixel with
    | 1 => 
      { /* Assuming 8-bpp */
        bufp := cast[ptr[uint8]] (*screen).pixels + y*(*screen).pitch + x;
        *bufp = color;
      }

    | 2 => 
      { /* Probably 15-bpp or 16-bpp */
        bufp := cast[ptr[uint16]] (*screen).pixels + y*(*screen).pitch/2 + x;
        *bufp = color;
      }

    | 3 => 
      { /* Slow 24-bpp mode, usually not used */
        bufp := cast[ptr[uint8]](*screen).pixels + y*(*screen).pitch + x;
        *(bufp+(*(*screen).format).Rshift/8) = R;
        *(bufp+(*(*screen).format).Gshift/8) = G;
        *(bufp+(*(*screen).format).Bshift/8) = B;
      }

    | 4 => 
      { /* Probably 32-bpp */
        bufp := cast[ptr[uint32]] (*screen).pixels + y*(*screen).pitch/4 + x;
        *bufp = color;
      }
    endmatch;

    if SDL_MUSTLOCK(screen) do
        SDL_UnlockSurface(screen);
    done;
    SDL_UpdateRect(screen, x, y, 1u, 1u);
}

if SDL_Init(SDL_INIT_AUDIO \| SDL_INIT_VIDEO) < 0 do
  print "Unable to init SDL"; endl;
  System::exit(1);
done;

var screen: ptr[SDL_Surface];
screen = SDL_SetVideoMode(640, 480, 32, SDL_SWSURFACE);
if isNULL screen do
  print "Unable to set 1024x768 video"; endl;
  System::exit(1);
done;

print "yo, we're off: ";
print (*(*screen).format).BytesPerPixel;
print " bytes per pixel\n";

var i = 10i32; until i == 50i32 do
      DrawPixel(screen, i,i,250u8,220u8,220u8);
      ++i;
done;      

struct sample_t {
    data : ptr[uint8];
    dpos: uint32;
    dlen: uint32;
};

export type (sample_t) as "sample_t";

body """
#define NUM_SOUNDS 2
sample_t sounds[NUM_SOUNDS];

void mixaudio(void *unused, Uint8 *stream, int len)
{
  int i;
  Uint32 amount;

  for ( i=0; i<NUM_SOUNDS; ++i ) {
    amount = (sounds[i].dlen-sounds[i].dpos);
    if ( amount > len ) amount = len;
    SDL_MixAudio(stream, &sounds[i].data[sounds[i].dpos], amount, SDL_MIX_MAXVOLUME);
    sounds[i].dpos += amount;
  }
}
""";

macro val NUM_SOUNDS = 2;
const sounds : ptr[sample_t];
const mixaudio : SDL_audio_h_cft_1 = "mixaudio";
var fmt : SDL_AudioSpec;
fmt.freq=22050;
fmt.format=AUDIO_S16;
fmt.channels=2u8;
fmt.silence=0u8;
fmt.samples=512u16;
fmt.padding=0u16;
fmt.size=0u16;
fmt.callback=mixaudio;
fmt.userdata=NULL;

if SDL_OpenAudio(addr fmt, null_ptr[SDL_AudioSpec]) < 0 do
  print "Can't open Audio"; endl;
  System::exit 0;
done;

proc PlaySound(filename:string)
{
  var idx:int;
  var wave: SDL_AudioSpec;
  var data : ptr[uint8];
  var dlen : uint32;
  var cvt : SDL_AudioCVT;
  /* Look for an empty (or finished) sound slot */
  forall idx in 0 upto 2 do
    if sounds.[idx].dpos == sounds.[idx].dlen goto found;
  done;
  found:>
  if idx == NUM_SOUNDS do
    print "No free slot for music"; endl;
    return;
  done;

  if 
    SDL_LoadWAV(
      enconst (cstr filename), 
      addr wave, 
      addr data, 
      addr dlen
    ) == null_ptr[SDL_AudioSpec] 
  do
    print$ "Couldn't load Wav file " + filename; endl;
    return;
  done;
  print$ "Loaded Wav file " + filename; endl;
  print "Using slot "; print idx; endl;

  var result = SDL_BuildAudioCVT(
    addr cvt, 
    wave.format, 
    wave.channels, 
    wave.freq,
    AUDIO_S16,   
    2u8,
    22050
  );
  cvt.buf = array_alloc[uint8](dlen*cvt.len_mult);
  memcpy(as_address cvt.buf, as_address data, cast[size] dlen);
  cvt.len = dlen;
  result = SDL_ConvertAudio(addr cvt);
  SDL_FreeWAV(data);

  /* Put the sound data in the slot (it starts playing immediately) */
  if not (isNULL sounds.[idx].data) call free sounds.[idx].data;
  SDL_LockAudio();
  sounds.[idx].data = cvt.buf;
  sounds.[idx].dlen = cvt.len_cvt;
  sounds.[idx].dpos = 0u32;
  SDL_UnlockAudio();
}

SDL_PauseAudio 0;
{
  forall i in 1 upto 16 do
    filename := "media/sounds/fs" + str i + ".wav";
    print$ "Playing file " + filename; endl;
    PlaySound(filename);
  done;
};

var s: ptr[SDL_Surface] ^ 16;
{
  forall i in 1 upto 16 do
       filename := "media/images/fc" + str i+ ".jpg"; 
       print$ "Loading file " + filename; endl;
       rwop := SDL_RWFromFile (enconst (cstr filename),enconst (c"rb"));
       s.[i-1] = IMG_LoadJPG_RW(rwop);
  done;
};

var rcDest : SDL_Rect;
SDL_GetClipRect(screen,addr rcDest);

black := SDL_MapRGB((*screen).format, 0u8, 0u8, 0u8);

forall i in 0 upto 15 do      
  if not (isNULL s.[i]) do
    print "Show "; print i; endl;
    var r = SDL_BlitSurface ( s.[i], null_ptr[SDL_Rect], screen, addr rcDest );
    SDL_UpdateRect(screen, 0i32,0i32,0u,0u);
    Faio::sleep(5.0);
    r = SDL_FillRect(screen, addr rcDest, black);
  else
    print "Skip "; print i; endl;
  done;
done;

var e: SDL_Event;
print "Press any key"; endl;

get_sdl_event$ &e;
whilst event_type e != SDL_KEYDOWN do
  get_sdl_event$ &e;
done;


SDL_CloseAudio;
SDL_Quit;
System::exit 0;

