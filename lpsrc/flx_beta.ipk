@head(1,"Meta typing and Beta reduction")
@h = tangler("src/flx_beta.mli")
@select(h)
open Flx_types
open Flx_mtypes2

val metatype:
  sym_state_t ->
  (int * btypecode_t) list ->
  btypecode_t -> 
  btypecode_t

val beta_reduce:
  sym_state_t ->
  (int * btypecode_t) list ->
  btypecode_t -> 
  btypecode_t

@h = tangler("src/flx_beta.ml")
@select(h)
open Flx_util
open Flx_ast
open Flx_types
open Flx_mtypes1
open Flx_mtypes2

open Flx_print
open Flx_exceptions
open Flx_typing
open List
open Flx_srcref
open Flx_unify
open Flx_maps

exception BTfound of btypecode_t

(* params is list of string * bound_typecode *)
let rec metatype syms (params:(int * btypecode_t) list) term =
  (*
  print_endline ("Find Metatype  of: " ^ string_of_btypecode syms.dfns term);
  *)
  let t = metatype' syms params term in
  (*
  print_endline "Done";
  *)
  t
  
and metatype' syms (params:(int * btypecode_t) list) term =
  let st t = string_of_btypecode syms.dfns t in
  let mt t = metatype' syms params t in
  match term with
  | `BTYP_typefun (a,b,c) ->
    let ps = List.map snd a in
    let argt =
      match ps with
      | [x] -> x
      | _ -> `BTYP_tuple ps
    in 
      let rt = metatype syms (a @ params) c in
      if b<>rt
      then 
        failwith 
        (
          "In abstraction\n" ^
          st term ^
          "\nFunction body metatype \n"^
          st rt^
          "\ndoesn't agree with declared type \n" ^ 
          st b
        )
      else `BTYP_function (argt,b)

  | `BTYP_type_tuple ts ->
    `BTYP_tuple (List.map (metatype syms params) ts)

  | `BTYP_apply (a,b) ->
    begin 
      let ta = mt a
      and tb = mt b 
      in match ta with
      | `BTYP_function (x,y) ->
        if x = tb then y
        else 
          failwith "Metatype error: function argument wrong metatype"
      | _ -> failwith "Metatype error: function required for LHS of application"
    end
  | `BTYP_var (i,mt) ->  mt
    (*
    begin try 
      List.assoc i params 
      with 
        Not_found -> 
          print_endline "assoc list = ";
          List.iter
          (fun (i,s) -> 
            print_string 
            (
              string_of_int i ^ 
              ": " ^ 
              string_of_btypecode syms.dfns s ^ 
              " "
            )
          )
          params
          ;
          print_endline "";
          failwith 
          (
            "[metatype] Type variable " ^ string_of_int i ^ " not found in generic assoc list"
          )
    end
    *)

  | _ -> `BTYP_type (* THIS ISN'T RIGHT *)
  


(* fixpoint reduction: reduce
   Fix f. Lam x. e ==> Lam x. Fix z. e [f x -> z]
   to replace a recursive function
   with a recursive data structure
*)

and fixup syms ps body =
 let param = match ps with
   | [] -> assert false
   | [i,mt] -> `BTYP_var (i,mt)
   | x -> `BTYP_type_tuple (List.map (fun (i,mt) -> `BTYP_var (i,mt)) x)
 in
 (*
 print_endline ("Body  = " ^ sbt syms.dfns body);
 print_endline ("Param = " ^ sbt syms.dfns param);
 *)
 let rec aux term depth =
   let fx t = aux t (depth+1) in
   match map_btype fx term with
   | `BTYP_apply (`BTYP_fix i, arg) 
     when arg = param 
     && i + depth +1  = 0 (* looking inside application, one more level *)
     -> `BTYP_fix (i+2) (* elide application AND skip under lambda abstraction *)

   | `BTYP_typefun (a,b,c) ->
      (* NOTE we have to add 2 to depth here, an extra
      level for the lambda binder.
      NOTE also: this is NOT a recusive call to fixup!
      It doesn't fixup this function.
      *)

      `BTYP_typefun (a, fx b, aux c (depth + 2))
   | x -> x
 in 
   (* note depth 1: we seek a fix to an abstraction
   of which we're given only the body, that's an 
   extra level in the term structure 
   *)
   aux body 1

and mk_prim_type_inst syms i args =
  print_endline "MK_PRIM_TYPE";
  let t = `BTYP_inst (i,args) in
  (*
  let _,t' = normalise_type t in
  let args = match t' with
    | `BTYP_inst (_,args) -> args
    | _ -> assert false 
  in
  if not (Hashtbl.mem syms.prim_inst (i,args))
  then begin
    let n = !(syms.counter) in
    incr (syms.counter);
    Hashtbl.add syms.prim_inst (i, args) n;
    Hashtbl.add syms.rev_prim_inst n (i, args)
  end;
  *)
  t  


and beta_reduce syms (btvars:(int * btypecode_t) list) t = 
  (*
  print_endline ("Beta reduce " ^ sbt syms.dfns t);
  *)
  let t = 
  try
  beta_reduce' syms btvars [] t 
  with Failure s -> failwith ("beta-reduce failed in " ^ sbt syms.dfns t ^ "msg: " ^ s)
  in
  (*
  print_endline ("  reduced= " ^ sbt syms.dfns t);
  *)
  t

and beta_reduce' syms (btvars:(int * btypecode_t) list) termlist t = 
  (*
  print_endline ("BETA REDUCE " ^ string_of_btypecode syms.dfns t);
  *)
  match list_index termlist t with
  | Some i -> print_endline ("Beta find fixpoint " ^ si (-i-1)); `BTYP_fix (-i - 1)
  | None ->
  let br t' = beta_reduce' syms btvars (t::termlist) t' in
  let st t = string_of_btypecode syms.dfns t in
  let mt t = metatype syms btvars t in
  (* hhmm .. this has to handle a free fixpoint, because it 
  is called during construction of a recursive type .. so
  we can't do an unfold.. but them beta-reduce won't
  find fix points .. hmm .. hmm .. we could fix that by
  replacing a fixpoint with a copy of the recursed expression ..
  then let beta-reduce find it..
  *)
  match t with
  | `BTYP_inst (i,ts) -> 
    let ts = map br ts in
    begin try match Hashtbl.find syms.dfns i with
    | {id=id; symdef=`SYMDEF_type_alias _ } ->
      failwith ("Beta reduce found a type instance of "^id^" to be an alias, which it can't handle")
    | _ -> `BTYP_inst (i,ts)
    with Not_found -> `BTYP_inst (i,ts) (* could be reparented class *)
    end
  | `BTYP_tuple ls -> `BTYP_tuple (map br ls)
  | `BTYP_array (i,t) -> `BTYP_array (i, br t)
  | `BTYP_sum ls -> `BTYP_sum (map br ls)

  (* Intersection type reduction rule: if any term is 0,
     the result is 0, otherwise the result is the intersection
     of the reduced terms with 1 terms removed: if there
     are no terms return 1, if a single term return it,
     otherwise return the intersection of non units
     (at least two)
  *)
  | `BTYP_intersect ls -> 
    let ls = map br ls in
    if mem `BTYP_void ls then `BTYP_void
    else let ls = filter (fun i -> i <> `BTYP_tuple []) ls in
    begin match ls with
    | [] -> `BTYP_tuple []
    | [t] -> t
    | ls -> `BTYP_intersect ls
    end

  | `BTYP_typeset ls -> `BTYP_typeset (map br ls)

  | `BTYP_typesetunion ls -> 
    let ls = map br ls in
    (* split into explicit typesets and other terms 
      at the moment, there shouldn't be any 'other'
      terms (since there are no typeset variables ..
    *)
    let rec aux ts ot ls  = match ls with
    | [] -> 
      begin match ot with 
      | [] -> `BTYP_typeset ts
      | _ -> 
        print_endline "WARNING UNREDUCED TYPESET UNION";
        `BTYP_typesetunion (`BTYP_typeset ts :: ot)
      end

    | `BTYP_typeset xs :: t -> aux (xs @ ts) ot t
    | h :: t -> aux ts (h :: ot) t
    in aux [] [] ls

  (* NOTE: sets have no unique unit *)
  (* WARNING: this representation is dangerous: 
     we can only calculate the real intersection
     of discrete types *without type variables*

     If there are pattern variables, we may be able
     to apply unification as a reduction. However
     we have to be very careful doing that: we can't
     unify variables bound by universal or lambda quantifiers 
     or the environment: technically I think we can only
     unify existentials. For example the intersection

     'a * int & long & 'b

     may seem to be long * int, but only if 'a and 'b are
     pattern variables, i.e. dependent variables we're allowed
     to assign. If they're actually function parameters, or
     just names for types in the environment, we have to stop
     the unification algorithm from assigning them (since they're
     actually particular constants at that point).

     but the beta-reduction can be applied anywhere .. so I'm
     not at all confident of the right reduction rule yet.

     Bottom line: the rule below is a hack.
  *)
  | `BTYP_typesetintersection ls -> 
    let ls = map br ls in
    if mem (`BTYP_typeset []) ls then `BTYP_typeset []
    else begin match ls with
    | [t] -> t
    | ls -> `BTYP_typesetintersection ls
    end


  | `BTYP_type_tuple ls -> `BTYP_type_tuple (map br ls)
  | `BTYP_function (a,b) -> `BTYP_function (br a, br b)
  | `BTYP_cfunction (a,b) -> `BTYP_cfunction (br a, br b)
  | `BTYP_pointer a -> `BTYP_pointer (br a)
  | `BTYP_lvalue a -> `BTYP_lvalue (br a)

  | `BTYP_void -> t
  | `BTYP_type -> t
  | `BTYP_fix _ -> t
  | `BTYP_var _ -> t
  | `BTYP_unitsum _ -> t

  | `BTYP_apply (t1,t2) ->
    (*
    print_endline "-----------------------";
    print_endline ("Application " ^ st t);
    print_endline "";
    print_endline ("Unreduced function is " ^ st t1);
    print_endline ("Unreduced Argument is " ^ st t2);
    *)
    let t2 = br t2 in (* eager evaluation *)
    let t1 = br t1 in (* eager evaluation *)
    (*
    print_endline ("reduced function is " ^ st t1);
    print_endline ("reduced Argument is " ^ st t2);
    *)
    let mt1 = mt t1
    and mt2 = mt t2 
    in
    (*
    print_endline ("Function metatype is" ^ st mt1);
    print_endline ("Argument metatype is" ^ st mt2);
    *)
    begin match t1 with
    | `BTYP_fix _ -> `BTYP_apply(t1,t2)
    | _ ->
    begin match mt1 with
    | `BTYP_function (a,b) ->
      if a <> mt2
      then failwith ("Argument metatype not same as function parameter")
    | _ -> 
      failwith (
        "[beta_reduce] Expected LHS of application to be type function, got\n" ^ 
        st t1^"\nmeta type: " ^ st mt1
      )
    end
    ;
    begin match t1 with
    | `BTYP_typefun (ps,r,body) ->
      let v = Hashtbl.create 97 in
      begin match ps with
      | [] -> ()
      | [i,_] -> Hashtbl.add v i t2
      | _ -> 
        let ts = match t2 with 
        | `BTYP_type_tuple ts -> ts 
        | _ -> assert false 
        in
          if List.length ps <> List.length ts
          then failwith "Wrong number of arguments to typefun"
          else List.iter2 (fun (i,_) y -> Hashtbl.add v i y) ps ts
      end
      ;
      (*
      print_endline "Variable assignments are ";
      Hashtbl.iter
      (fun i t -> print_endline (string_of_int i ^ " -> " ^ st t))
      v
      ;
      print_endline ("Body is " ^ st body);
      *)
      let t = varmap_subst v body in
      (*
      print_endline ("Result of application = " ^ st t);
      *)
      br t

    | `BTYP_var _ -> t (* can't reduce it yet *)
    | `BTYP_fix _ -> t (* can't reduce it yet *)

    | _ -> failwith 
      (
        "[beta-reduce] Expected type function or variable, got " ^ 
        string_of_btypecode syms.dfns t1
      )
    end
    end

  | `BTYP_typefun (p,r,b) -> 
    let p' = List.map (fun (i,t) -> (i, br t)) p in
    (*
    print_endline ("fixing up function " ^ st t);
    *)
    (*
    print_endline ("body is " ^ st b);
    *)
    let b = fixup syms p b in
    (*
    print_endline ("After fixup body is " ^ st b);
    *)
    let b' = beta_reduce syms (p' @ btvars) b in
    (*
    print_endline ("Reducing body inside lambda, result is" ^ sbt syms.dfns b');
    *)
    `BTYP_typefun (p', br r, b')

  | `BTYP_type_match (tt,pts) ->
    (*
    print_endline ("Typematch [before reduction] " ^ sbt syms.dfns t);
    *)
    let tt = br tt in
    let pts = 
      map (fun (tp,t) -> 
        {
          tp with pattern=br tp.pattern; 
           assignments= map (fun (j,t) -> j, br t) tp.assignments
         }, br t
      ) 
      pts 
    in
    (*
    let xx = `BTYP_type_match (tt,pts) in
    print_endline ("Typematch [after reduction] " ^ sbt syms.dfns xx);
    *)
    let new_matches = ref [] in
    iter (fun (({pattern=p'; pattern_vars=dvars; assignments=eqns}, t') as x) ->
      (*
      print_endline ("Tring to unify argument with " ^ sbt syms.dfns p');
      *)
      match maybe_unification syms.dfns [p',tt] with
      | Some _ -> new_matches := x :: !new_matches
      | None -> 
        (*
        print_endline ("Discarding pattern " ^ sbt syms.dfns p'); 
        *)
        ()
    )
    pts
    ;
    let pts = rev !new_matches in
    match pts with
    | [] -> 
      failwith "[beta-reduce] typematch failure"
    | ({pattern=p';pattern_vars=dvars;assignments=eqns},t') :: _ ->
      try 
        let mgu = unification false syms.dfns [p', tt] dvars in
        let t' = list_subst eqns t' in
        list_subst mgu t'
      with Not_found -> `BTYP_type_match (tt,pts)

