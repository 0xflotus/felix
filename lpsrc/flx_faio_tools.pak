@head(1, 'Demo tools')
Tools are run with installed or testing flx script, they're
not built by the build system.

@h = tangler('spkgs/faio_tools.py')
@select(h)
pkg_requires = ['faio']
iscr_source = ['lpsrc/flx_faio_tools.pak']
weaver_directory = 'doc/tools/'

@head(2, 'A Simple Webserver')
@h = tangler("tools/webserver.flx")
@select(h)
#import <flx.flxh>

#if POSIX
include "flx_faio_posix";  // aio_ropen
//open Faio_posix;
#endif


include "flx_socket";
open Flx_socket;

include "flx_stream";
open Flx_stream;

open TerminalIByteStream[fd_t];
open TerminalIOByteStream[socket_t];

macro fun dbg(x) = { fprint (cerr,x); };


// this is a hack to make close work on a listener
// RF got this right the first time:
// in the abstract a listener is NOT a socket
// In fact, it is a socket server, with accept() a way to
// read new sockets off it ..
open TerminalIByteStream[socket_t];

fun getline_to_url (get:string) =>
  if not startswith get "GET " then
    ""
  else
    match find (get, ' ', 4) with
    | None[int] => ""
    | Some ?pos => get.[4 to pos]
    endmatch
  endif
;

fun split_url (inurl:string): opt[string*string] = {
  val url =
    if startswith inurl "http://" then
      inurl.[to 7]
    else
      inurl
    endif
  ;

  return
    match find (url, '/') with
    | None[int] => None[string*string]
    | Some ?pos => Some$ url.[0 to pos], url.[pos + 1 to]
    endmatch
  ;
}

fun parse_get_line (get:string): opt[string*string] =>
  split_url$ getline_to_url get
;

// TODO: fill in that length field, stream back the requested jpeg,
// get port from argv.

val html_header = """HTTP/0.9 200 OK\r
Date: Tue, 25 Apr 2006 00:16:12 GMT\r
Server: felix web server\r
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT\r
Connection: close\r
Content-Type: text/html\r
\r
""";

val gif_header = """HTTP/0.9 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: image/gif\r
\r
""";

val css_header = """HTTP/0.9 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: text/css\r
\r
""";


val notfound_header = """HTTP/0.9 404 Not Found\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Connection: close\r
Content-Type: text/html\r
\r
PAGE NOT FOUND:
""";


proc serve_file(infname: string, s: socket_t)
{
  var fname: string;

  // if empty string, serve index.html
  // not quite right - needs to handle directories too, so
  // not only foo.com/ -> index.html, but foo.com/images/ -> images/index.html
  if "" == infname then { fname = "index.html"; }else{ fname = infname;}endif;

  // set mime type depending on extension...
  // serve a "not found page" for that case (check for recursion)
  print "serve file: "; print fname; endl;

  // this isn't right, don't want the contents parsed as text, want them
  // sent faithfully over the wire. of course doesn't work for jpegs and other
  // binary formats.

  val suffix =
    match rfind (fname, ".") with
    | None[int] => ""
    | Some ?pos => fname.[pos + 1 to]
    endmatch
  ;

  print "suffix is "; print suffix; endl;

#if WIN32
  // quick 'n' dirty unix -> dos style pathnames
  val wname = map (fun (a:char) => if a == char '/' then char '\\' else a endif) fname;
  print "mapped "; print fname; print " -> "; print wname; endl;
  // send header
  // TransmitFile
  var wf: WFILE <- Faio_win32::OpenFile(wname);

  if wf == Faio_win32::INVALID_HANDLE_VALUE then
  {
    print "BUGGER: OpenFile failed: "; print (GetLastError()); endl;
  } else {
    print "opened "; print wname; endl;

    // mime type mapping from suffix. make better here.
    if("gif" == suffix) then { write_string(s, gif_header); }
    elif("css" == suffix) then { write_string(s, css_header); }
    else { write_string(s, html_header); } endif;

    print "Transmitting file!\n";
    TransmitFile(s, wf);

    // send footer
    CloseFile(wf);
  } endif;
#elif POSIX
  // this fn sets the O_NONBLOCK flag which is completely unnecessary
  // as read goes via the preading worker fifo. don't know if
  // O_NONBLOCK even works on actual files.
  var fd = Faio_posix::ropen(fname);

  if Faio_posix::invalid fd then
  {
    print "BUGGER, posix open failed\n";
    write_string(s, notfound_header);
    write_string(s, fname+"\r\n\n");
  } else {
    print "got fd="; print$ str fd; endl;

    // mime type mapping from suffix. make better here.
    // factor out
    if("gif" == suffix) then { write_string(s, gif_header); }
    elif("css" == suffix) then { write_string(s, css_header); }
    else { write_string(s, html_header); } endif;

    var from_strm: Faio_posix::fd_t = fd;
    var to_strm: socket_t = s;
    Flx_stream::cat(from_strm, to_strm);

    dbg q"close file $from_strm\n";
    iclose(from_strm); // this'll know how to close a unix fd
  } endif;

  // var contents = Text_file::load(fname);
  // print "loaded: "; print contents; endl;
  // print "contents len="; print (len contents); endl;
  // write_string(s, html_header + contents);

#endif
}

val webby_port = 1234;

print "FLX WEB!!! listening on port "; print webby_port; endl;

// up the queue len for stress testing
var p = webby_port;
var listener: socket_t;
mk_listener(&listener, &p, 10);

forever {
  var s: socket_t;
  accept(listener, &s);  // blocking
  dbg q"got connection $s\n";  // error check here

  // hmm - spawning an fthread is blocking the web server. don't know why
  print "spawning fthread to handle connection\n";
  spawn_fthread {
    // should spawn fthread here to allow for more io overlap

    var line: string;
    get_line(s, &line);  // should be the GET line.

    print "got line: "; print line; endl;

    // now I need to parse the GET line, get a file name out of its url
    // (e.g. unqualfied -> index.html and name/flx.jpg -> flx.jpg
    match parse_get_line line with
    | None[string*string] => {
        print "BAD get line: "; print line; endl;
      }
    | Some (?base, ?file) => {
        print "well formed get...\n";
        print "base="; print base; endl;
        print "file="; print file; endl;

        serve_file(file, s);
      }
    endmatch;

    // we've only read the GET line, so let's flush out the rest of
    // the http request so we don't get connection reset errors when
    // we close the socket. shutting down stops cat blocking (?)
    Faio_posix::shutdown(s, 1); // disallow further sends.
    cat(s, DEVNULL);

    fprint$ cerr,q"closing socket $s\n";
    ioclose(s);

  };
  collect();
};

iclose(listener);

@head(2, 'fcp: A file copy program')
@h = tangler("tools/fcp.flx")
@select(h)
#import <flx.flxh>

include "flx_faio";
include "flx_stream";

open Faio;
open Flx_stream;
open TerminalIByteStream[fd_t];
open TerminalOByteStream[fd_t];

val fnin,fnout = System::argv 1, System::argv 2;

gen openi(s:string):fd_t = {
  var f: fd_t;
  f = Faio_posix::ropen(s);
  if Faio_posix::invalid f do
    print$ "Can't open input file " + s + "\n";
    System::exit 1;
  done;
  return f;
}

typedef posix_permissions = Faio_posix::posix_permissions;

gen openo(s:string, perm:posix_permissions):fd_t = {
  var f: fd_t;
  f = Faio_posix::aio_creat(s,perm);
  if Faio_posix::invalid f do
    print$ "Can't open output file " + s + "\n";
    System::exit 1;
  done;
  return f;
}

var fin = openi(fnin);
var fout = openo(fnout,Faio_posix::access fin);
cat (fin,fout);
iclose(fin);
oclose(fout);

@head(2, 'fcmp: A file compare program')
@h = tangler("tools/fcmp.flx")
@select(h)
#import <flx.flxh>

include "flx_faio";
include "flx_stream";

open Faio;
open Flx_stream;
open TerminalIByteStream[fd_t];

val fn1,fn2 = System::argv 1, System::argv 2;

gen openi(s:string):fd_t = {
  var f: fd_t;
  f = Faio_posix::ropen(s);
  if Faio_posix::invalid f do
    print$ "Can't open input file " + s + "\n";
    System::exit 1;
  done;
  return f;
}

var f1 = openi(fn1);
var f2 = openi(fn2);
var result : int;
cmp (f1,f2, &result);
iclose(f1);
iclose(f2);

if result < 0 do
  print$ fn1 + " < " + fn2;
elif result > 0 do
  print$ fn1 + " > " + fn2;
else
  print$ fn1 + " == " + fn2;
done;
endl;

System::exit(result);

