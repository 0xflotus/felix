@execfile('config'+os.sep+'config.py')
@head(1, 'Demo tools')
Tools are run with installed or testing flx script, they're
not built by the build system.

@h = tangler('spkgs/faio_tools.py')
@select(h)
pkg_requires = ['faio']
iscr_source = ['lpsrc/flx_faio_tools.pak']
weaver_directory = 'doc/tools/'

@head(2, 'A Simple Webserver')
@h = tangler("tools/webserver.flx")
@select(h)
#import <flx.flxh>

#if POSIX
include "flx_faio_posix";  // aio_ropen
//open Faio_posix;
#endif


include "flx_socket";
open Flx_socket;

include "flx_stream";
open Flx_stream;

open TerminalIByteStream[fd_t];
open TerminalIOByteStream[socket_t];

// this is a hack to make close work on a listener
// RF got this right the first time: 
// in the abstract a listener is NOT a socket
// In fact, it is a socket server, with accept() a way to
// read new sockets off it ..
open TerminalIByteStream[socket_t]; 

header = """
string
getline_to_url(const string& get)
{
    // chomp off "GET " (should check it)
    if(get.length() < 4) return "";

    std::size_t pos = get.substr(4).find(' ');

    if(pos == string::npos) return "";

    return get.substr(4, pos);
}

// split url into base and file name http://foo.com/file.html
// -> http://foo.com + file.html. failure returns nothing.
bool
split_url(const string& inurl, string& base, string& file)
{
    // munch leading http:// if present
    string url;
    if(inurl.length() >= 7 && inurl.substr(0, 7) == "http://")
      url = inurl.substr(7);
    else
      url = inurl; 

    std::size_t pos = url.find('/');

    if(string::npos == pos)  return false;       // all bad

    base = url.substr(0, pos);
    file = url.substr(pos+1);
    return true;            // all good
}

bool
split_getline(const string& get, string& base, string& file)
{
    return split_url(getline_to_url(get), base, file);
}
""";

proc parse_get_line: string*lvalue[bool]*lvalue[string]*lvalue[string]
 = '$2 = split_getline($1, $3, $4);';

fun substr: string*int -> string = "$1.substr($2)";

// TODO: fill in that length field, stream back the requested jpeg,
// get port from argv.

val html_header = """
HTTP/1.1 200 OK
Date: Tue, 25 Apr 2006 00:16:12 GMT
Server: felix web server
Last-Modified: Wed, 01 Feb 2006 18:51:37 GMT
Accept-Ranges: bytes
Connection: close
Content-Type: text/html

""";

val gif_header = """
HTTP/1.1 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Accept-Ranges: bytes\r
Connection: close\r
Content-Type: image/gif\r

""";

val css_header = """
HTTP/1.1 200 OK\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Accept-Ranges: bytes\r
Connection: close\r
Content-Type: text/css\r

""";


val notfound_header = """
HTTP/1.1 404 Not Found\r
Date: Sun, 30 Apr 2006 07:14:50 GMT\r
Server: felix web server\r
Last-Modified: Sun, 28 Nov 2004 18:59:31 GMT\r
Accept-Ranges: bytes\r
Connection: close\r
Content-Type: text/html\r

PAGE NOT FOUND:
""";


proc substitute(s: string, a: char, b: char, res: &string)
{
  var s2: string;
  var slen = len s;
  var i: int;

  for_each{i=0;}{i<slen}{i++;}
  {
     if s.[i] == a then
     { s2 += b; } else
     { s2 += s.[i]; } endif;

  };

  *res = s2;
}

proc serve_file(infname: string, s: socket_t)
{
  var fname: string;

  // if empty string, serve index.html
  // not quite right - needs to handle directories too, so
  // not only foo.com/ -> index.html, but foo.com/images/ -> images/index.html
  if "" == infname then { fname = "index.html"; }else{ fname = infname;}endif;

  // set mime type depending on extension...
  // serve a "not found page" for that case (check for recursion)
  print "serve file: "; print fname; endl;

  // this isn't right, don't want the contents parsed as text, want them
  // sent faithfully over the wire. of course doesn't work for jpegs and other
  // binary formats.

  var suffix: string;
  var dotpos = stl_rfind(fname, char ".");
  // print "dotpos = "; print dotpos; endl;
  if stl_npos != dotpos then { suffix = substr(fname, dotpos+1); }
  else {} endif;

  print "suffix is "; print suffix; endl;

#if WIN32
  var wname: string;

  // quick 'n' dirty unix -> dos style pathnames
  substitute(fname, char '/', char '\\', &wname);
  print "mapped "; print fname; print " -> "; print wname; endl;
  // send header
  // TransmitFile
  var wf: WFILE <- OpenFile(wname);

  if wf == INVALID_HANDLE_VALUE then
  {
    print "BUGGER: OpenFile failed: "; print (GetLastError()); endl;
  } else {
    print "opened "; print wname; endl;

    // mime type mapping from suffix. make better here.
    if("gif" == suffix) then { write_string(s, gif_header); }
    elif("css" == suffix) then { write_string(s, css_header); }
    else { write_string(s, html_header); } endif;

    print "Transmitting file!\n";
    TransmitFile(s, wf);

    // send footer
    CloseFile(wf);
  } endif;
#elif POSIX
  // this fn sets the O_NONBLOCK flag which is completely unnecessary
  // as read goes via the preading worker fifo. don't know if
  // O_NONBLOCK even works on actual files.
  var fd = Faio_posix::aio_ropen(fname);

  if Faio_posix::invalid fd then 
  {
    print "BUGGER, posix open failed\n";
    write_string(s, notfound_header); 
    write_string(s, fname+"\r\n\n"); 
  } else {
    print "got fd="; print$ str fd; endl;

    // mime type mapping from suffix. make better here.
    // factor out
    if("gif" == suffix) then { write_string(s, gif_header); }
    elif("css" == suffix) then { write_string(s, css_header); }
    else { write_string(s, html_header); } endif;

    var from_strm: Faio_posix::fd_t = fd;
    var to_strm: socket_t = s;
    Flx_stream::cat(from_strm, to_strm);

    iclose(from_strm); // this'll know how to close a unix fd
  } endif;

  // var contents = Text_file::load(fname);
  // print "loaded: "; print contents; endl;
  // print "contents len="; print (len contents); endl;
  // write_string(s, html_header + contents);

#endif
}

val webby_port = 1234;

print "FLX WEB!!! listening on port "; print webby_port; endl;

// up the queue len for stress testing
var p = webby_port;
var listener: socket_t;
mk_listener(&listener, &p, 10);


proc forever {
  var s: socket_t;
  accept(listener, &s);  // blocking
  print "got connection (or something)\n";  // error check here

  // hmm - spawning an fthread is blocking the web server. don't know why
  print "spawning fthread to handle connection\n";
  spawn_fthread {
    // should spawn fthread here to allow for more io overlap

    var line: string;
    get_line(s, &line);  // should be the GET line.

    val poo = 
    if "GET " == line.[0 to 4] then line.[4 to ] else "" endif;
    print ("poo="poo); endl;

  //print ("blah " line.[0 to 4]); endl;
    print "got line: "; print line; endl;

    // now I need to parse the GET line, get a file name out of its url
    // (e.g. unqualfied -> index.html and name/flx.jpg -> flx.jpg
    var succ: bool;
    var base: string;
    var file: string;

    parse_get_line(line, succ, base, file);
    // print "succ="; print succ; endl;

    if succ then {
      print "well formed get...\n";
      print "base="; print base; endl;
      print "file="; print file; endl;

      serve_file(file, s);
    } else {
      print "BAD get line: "; print line; endl;
    } endif;

    ioclose(s);

  };
  collect();
  forever;
};
forever;

iclose(listener);

@head(2, 'fcp: A file copy program')
@h = tangler("tools/fcp.flx")
@select(h)
#import <flx.flxh>

include "flx_faio";
include "flx_stream";

open Faio;
open Flx_stream;
open TerminalIByteStream[fd_t];
open TerminalOByteStream[fd_t];

val fnin,fnout = System::argv 1, System::argv 2;

gen openi(s:string):fd_t = {
  var f: fd_t;
  f = Faio_posix::aio_ropen(s);
  if Faio_posix::invalid f do
    print$ "Can't open input file " + s + "\n";
    System::exit 1;
  done;
  return f;
}

typedef posix_permissions = Faio_posix::posix_permissions;

gen openo(s:string, perm:posix_permissions):fd_t = {
  var f: fd_t;
  f = Faio_posix::aio_creat(s,perm);
  if Faio_posix::invalid f do
    print$ "Can't open output file " + s + "\n";
    System::exit 1;
  done;
  return f;
}

var fin = openi(fnin);
var fout = openo(fnout,Faio_posix::access fin);
cat (fin,fout);
iclose(fin);
oclose(fout);

@head(2, 'fcmp: A file compare program')
@h = tangler("tools/fcmp.flx")
@select(h)
#import <flx.flxh>

include "flx_faio";
include "flx_stream";

open Faio;
open Flx_stream;
open TerminalIByteStream[fd_t];

val fn1,fn2 = System::argv 1, System::argv 2;

gen openi(s:string):fd_t = {
  var f: fd_t;
  f = Faio_posix::aio_ropen(s);
  if Faio_posix::invalid f do
    print$ "Can't open input file " + s + "\n";
    System::exit 1;
  done;
  return f;
}

var f1 = openi(fn1);
var f2 = openi(fn2);
var result = cmp (f1,f2);
iclose(f1);
iclose(f2);

if result < 0 do 
  print$ fn1 + " < " + fn2;
elif result > 0 do
  print$ fn1 + " > " + fn2;
else 
  print$ fn1 + " == " + fn2;
done;
endl;

System::exit(result);

