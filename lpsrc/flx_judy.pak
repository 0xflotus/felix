@import config
@from flxbuild.iscrutil import setup_test

@env = setup_test(get_input_frame(), 'test/judy/judy-')

@head(1,'Judy source package')
@select(tangler('spkgs/flx_judy.py'))
import os
import glob

import config

iscr_source = ['lpsrc/flx_judy.pak']
weaver_directory = 'doc/judy'

xfiles = [
  os.path.join('src', 'judy', '*'),
  os.path.join('src', 'judy', 'Judy1', '*'),
  os.path.join('src', 'judy', 'JudyCommon', '*'),
  os.path.join('src', 'judy', 'JudyHS', '*'),
  os.path.join('src', 'judy', 'JudyL', '*'),
  os.path.join('src', 'judy', 'JudySL', '*'),
]

rtl_interfaces = [
  'src/judy/Judy.h'
]

felix_rtl = [
  'src/judy/judy.flx',
]

cc_ccs = [
  'src/judy/JudyCommon/JudyMalloc',
  'src/judy/Judy1/JUDY1_Judy1ByCount',
  'src/judy/Judy1/JUDY1_Judy1Cascade',
  'src/judy/Judy1/JUDY1_Judy1Count',
  'src/judy/Judy1/JUDY1_Judy1CreateBranch',
  'src/judy/Judy1/JUDY1_Judy1Decascade',
  'src/judy/Judy1/JUDY1_Judy1First',
  'src/judy/Judy1/JUDY1_Judy1FreeArray',
  'src/judy/Judy1/JUDY1_Judy1InsertBranch',
  'src/judy/Judy1/JUDY1_Judy1MallocIF',
  'src/judy/Judy1/JUDY1_Judy1MemActive',
  'src/judy/Judy1/JUDY1_Judy1MemUsed',
  'src/judy/Judy1/JUDY1_Judy1SetArray',
  'src/judy/Judy1/JUDY1_Judy1Set',
  'src/judy/Judy1/JUDY1_Judy1Tables',
  'src/judy/Judy1/JUDY1_Judy1Unset',
  'src/judy/Judy1/JUDY1_Judy1Next',
  'src/judy/Judy1/JUDY1_Judy1NextEmpty',
  'src/judy/Judy1/JUDY1_Judy1Prev',
  'src/judy/Judy1/JUDY1_Judy1PrevEmpty',
  'src/judy/Judy1/JUDY1_Judy1Test',
  'src/judy/Judy1/JUDY1_j__udy1Test',
  'src/judy/JudyL/JUDYL_JudyLByCount',
  'src/judy/JudyL/JUDYL_JudyLCascade',
  'src/judy/JudyL/JUDYL_JudyLCount',
  'src/judy/JudyL/JUDYL_JudyLCreateBranch',
  'src/judy/JudyL/JUDYL_JudyLDecascade',
  'src/judy/JudyL/JUDYL_JudyLDel',
  'src/judy/JudyL/JUDYL_JudyLFirst',
  'src/judy/JudyL/JUDYL_JudyLFreeArray',
  'src/judy/JudyL/JUDYL_JudyLInsArray',
  'src/judy/JudyL/JUDYL_JudyLIns',
  'src/judy/JudyL/JUDYL_JudyLInsertBranch',
  'src/judy/JudyL/JUDYL_JudyLMemActive',
  'src/judy/JudyL/JUDYL_JudyLMemUsed',
  'src/judy/JudyL/JUDYL_JudyLMallocIF',
  'src/judy/JudyL/JUDYL_JudyLTables',
  'src/judy/JudyL/JUDYL_JudyLNext',
  'src/judy/JudyL/JUDYL_JudyLNextEmpty',
  'src/judy/JudyL/JUDYL_JudyLPrev',
  'src/judy/JudyL/JUDYL_JudyLPrevEmpty',
  'src/judy/JudyL/JUDYL_JudyLGet',
  'src/judy/JudyL/JUDYL_j__udyLGet',
  'src/judy/JudyHS/JudyHS',
]

include_path=['src/judy/Judy1', 'src/judy/JudyL', 'src/judy/JudyCommon', 'src/judy']

if config.TARGET_CC.options.SIZEOF_VOIDP == 8:
  macros=['JU_64BIT']
else:
  macros=['JU_32BIT']

build_macro = 'JUDY'

provides_lib = 'libflx_judy'

@tangle('unit_tests = glob.glob("%s*.flx")' % env.native_root)

@head(1,'Judy run time library')
@select(tangler('config/flx_judy.fpc'))
@if config.HAVE_MSVC:
   tangle("provides_dlib: /DEFAULTLIB:libflx_judy_dynamic")
   tangle("provides_slib: /DEFAULTLIB:libflx_judy_static")
 else:
   tangle("provides_dlib: -lflx_judy_dynamic")
   tangle("provides_slib: -lflx_judy_static")

@env.head(1, 'judy tests')
@select(env.test('.flx'))
include "judy";
open Judy;
open C_hack;

gen _ctor_address : string -> address = "(void*)$1.data()";

val je = JError_t();
var ires : int;
var pires = addr ires;
var wres : word;
var pwres = addr wres;
{
  val ja = J1Array();
  Judy1Set(ja,word 1,je,pires);
  print "1 was unset="; println$ ires;

  Judy1Set(ja,word 1,je,pires);
  print "1 was unset="; println$ ires;

  Judy1Set(ja,word 9,je,pires);
  print "9 was unset="; println$ ires;
  Judy1Set(ja,word 7,je,pires);
  print "7 was unset="; println$ ires;
  Judy1Set(ja,word 23,je,pires);
  print "23 was unset="; println$ ires;
  Judy1Set(ja,word 7,je,pires);
  print "7 was unset="; println$ ires;

  var i : int;
  forall i in 0 upto 10 do
    Judy1Test(ja,word i,je,pires);
    print i; print " isset="; println$ ires;
  done;


  Judy1Count(ja,word 0,word 10,je,pwres);
  print "count="; println$ int wres;

  var curr: word = word 0;
  var pcurr= addr curr;
  Judy1First(ja,pcurr,je,pires);
  print "First="; println$ ulong curr;
  print "res="; println$ ires;
  Judy1Next(ja,pcurr,je,pires);
  print "Next="; println$ int curr;
  print "res="; println$ ires;
  Judy1Next(ja,pcurr,je,pires);
  print "Next="; println$ int curr;
  print "res="; println$ ires;
  Judy1Next(ja,pcurr,je,pires);
  print "Next="; println$ int curr;
  print "res="; println$ ires;


  println "Done J1";
};

{
  val ja = JLArray();
  var pv : ptr[word]; // pointer to space in the array to put value
  var ppv = addr pv;
  JudyLIns(ja,word 1,je,ppv);
  *pv = word 11;
  JudyLIns(ja,word 7,je,ppv);
  *pv = word 77;
  JudyLIns(ja,word 23,je,ppv);
  *pv = word 2323;

  JudyLGet(ja,word 1,je,ppv);
  print "1->"; println$ int$ *pv;

  JudyLGet(ja,word 23,je,ppv);
  print "23->"; println$ int$ *pv;

  JudyLGet(ja,word 7,je,ppv);
  print "7->"; println$ int$ *pv;

  JudyLCount(ja,word 0,word 10,je,pwres);
  print "Count="; println$ int wres;

  var i : int;
  forall i in 0 upto 10 do
    JudyLGet(ja,word i,je,ppv);
    print i;
    if isNULL pv do
      println " --> NOT STORED";
    else
      print " --> ";
      println$ ulong$ *pv;
    done;
  done;

  var curr: word = word 0;
  var pcurr= C_hack::addr curr;
  JudyLFirst(ja,pcurr,je,ppv);
  print "First="; print$ int curr; print " -> "; println$ int$ *pv;

  JudyLNext(ja,pcurr,je,ppv);
  print "Next="; print$ int curr; print " -> "; println$ int$ *pv;


  println "Done JL";
};

{
  val ja = JHSArray();
  var pv : ptr[word]; // pointer to space in the array to put value
  var ppv = addr pv;

  s1 := "Hello";
  JudyHSIns(ja,address s1,word (len s1),je, ppv);
  *pv = word 101;

  s2 := "World";
  JudyHSIns(ja,address s2,word (len s2),je,ppv);
  *pv = word 22;

  s3 := "Silly";
  JudyHSIns(ja,address s3,word (len s3),je,ppv);
  *pv = word 303;

  JudyHSGet(ja,address s2, word (len s2),je, ppv);
  println$ "s2 -> " + str (int(*pv));
};

@select(env.expect())
1 was unset=1
1 was unset=0
9 was unset=1
7 was unset=1
23 was unset=1
7 was unset=0
0 isset=0
1 isset=1
2 isset=0
3 isset=0
4 isset=0
5 isset=0
6 isset=0
7 isset=1
8 isset=0
9 isset=1
10 isset=0
count=3
First=1
res=1
Next=7
res=1
Next=9
res=1
Next=23
res=1
Done J1
1->11
23->2323
7->77
Count=2
0 --> NOT STORED
1 --> 11
2 --> NOT STORED
3 --> NOT STORED
4 --> NOT STORED
5 --> NOT STORED
6 --> NOT STORED
7 --> 77
8 --> NOT STORED
9 --> NOT STORED
10 --> NOT STORED
First=1 -> 11
Next=7 -> 77
Done JL
s2 -> 22
@doc()

@select(env.test('.flx'))
// test Judy1
include "judy";
open Judy;
open C_hack;		// ptr...

print "judyable\n";

var j1 = J1Array();  // new bit array, all zero
var je = JError_t(); // for error info

var res: int;
var pres = ptr res;
Judy1Set(j1, word(1977), je, pres);

Judy1Test(j1, word(1977), je, pres);
print res; endl;

Judy1Test(j1, word(1978), je, pres);
print res; endl;

Judy1Set(j1, word(1000000009), je, pres);

var first: word = word 0;
var last: word = word (-1);
var n: word;

Judy1First(j1, ptr(first), je, pres);
Judy1Last(j1, ptr(last), je, pres);		// seems to give max uint
//print "first="; print(int first); endl;
//print "last="; print(ulong last); endl;

// count 1 bits between range, returning in w.
Judy1Count(j1, first, last, je, ptr(n));
print (int n); endl;

free je;
free j1;
@doc()

@select(env.expect())
judyable
1
0
2
@doc()

