@head(1,'Felix Standard Library')
@h=tangler('lib/std.flx')
@select(h)
header """
#include <stddef.h>
#include <cmath>
#include <iostream>
#include <string>
#include <assert.h>
#include <limits.h>
#include "rtl/boost_cstdint.hpp"
#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
""";

body """
using namespace std;

namespace std_flx {
  inline string mul(string s, int n) {
    string r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  inline string substr(string const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }
}
""";

@tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",
  "uchar"   : "int32_t", # Unicode/ISO10646, note: SIGNED!

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",
  "vlong"   : "long long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",
  "uvlong"  : "unsigned long long",

  #exact integers
  "int8"    : "boost::int8_t",
  "int16"   : "boost::int16_t",
  "int32"   : "boost::int32_t",
  "int64"   : "boost::int64_t",
  "uint8"   : "boost::uint8_t",
  "uint16"  : "boost::uint16_t",
  "uint32"  : "boost::uint32_t",
  "uint64"  : "boost::uint64_t",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double",
  }

@chars = ["char", "wchar", "uchar"]
@sints = [
  "tiny", "short", "int", "long", "vlong",
  "int8","int16","int32","int64"
  ]
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double", "ldouble"]

// @all = ["byte", "size","address","offset","bool"] + chars + sints + uints + floats
@all = ["byte", "size","address","offset"] + chars + sints + uints + floats
@ints = uints + sints

@def gen_type(t):
  tangle('type '+t+' = "'+tmap[t]+'";')

@for t in all:
  gen_type(t)

@def gen_asgn(t):
  tangle('  proc set: &'+t+' * '+t+' = "*$1=$2;";')
  tangle('  fun eq: '+t+' * '+t+' -> bool = "$1==$2";')
  tangle('  fun ne: '+t+' * '+t+' -> bool = "$1!=$2";')

@def gen_cmp(t):
  for opname,op in [
    ("lt","<"),
    ("le","<="),
    ("gt",">"),
    ("ge",">=")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> bool = "int($1'+op+'$2)";')


// !!!!! NEW DEFINITION OF BOOL !!!!!
typedef void = 0;
typedef unit = 1;
typedef bool = 2;
typedef any = any;

module Bool 
{
// DEFN OF true and false ..
// the order is CRITICAL for C/C++ compatibility
// We're cheating: we know bool will be optimised
// to an int by the compiler, and an int can
// suffice for a bool in C/C++
//
// NOTE!!!! if ANY naughty functions generate
// a boolean result which is other than 0 or 1 we have
// a catastrophy

  val false : bool = case 1 of 2;
  val true : bool = case 2 of 2;

  fun land: bool * bool -> bool = "$1 && $2";
  fun nand: bool * bool -> bool = "!($1 && $2)";
  fun lor: bool * bool -> bool = "$1 || $2";
  fun nor: bool * bool -> bool = "!($1 || $2)";
  fun xor: bool * bool -> bool = "$1 != $2";
  fun lnot: bool -> bool = "!$1";
  proc assert: bool = "assert($1);";
  proc print: bool = 'std::cout << ($1??"true":"false");';
}

@def gen_arith(t):
  for opname,op in [
    ("add","+"),
    ("sub","-"),
    ("mul","*"),
    ("div","/")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_mod(t):
  for opname,op in [
    ("mod","%")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_neg(t):
  tangle('  fun neg: '+t+' -> '+t+' = "-$1";')
  tangle('  fun pos: '+t+' -> '+t+' = "+$1";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)";')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)";')

@def gen_nan(t):
  tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)";')

@def gen_inc(t):
  tangle('  proc pre_incr:  &'+t+' = "++*$1;";')
  tangle('  proc pre_decr:  &'+t+' = "--*$1;";')
  tangle('  proc post_incr: &'+t+' = "++*$1;";')
  tangle('  proc post_decr: &'+t+' = "--*$1;";')
  
@#------------- INTEGER MODULES -------------------
type string = "string";
@for t in ints:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_mod(t)
  gen_neg(t)
  gen_inc(t)
  if t == "tiny":
    tangle('  proc print: tiny = "std::cout << (int)$1;";')
  elif t == "utiny":
    tangle('  proc print: utiny = "std::cout << (unsigned int)$1;";')
  else:
    tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_neg(t)
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun chr: int -> char = "(char)$1";
  proc print: char = "std::cout<<$1;";
}

module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun wchr: long -> wchar = "(wchar_t)$1";
  proc print: wchar = "std::cout<<$1;";
}

module Unicode
{
  open Int32;
  fun ord: uchar -> int32 ="$1";
  fun uchr: int32 -> uchar = "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;";
}


@#------------- STDOUT UTILITY -------------------
module Stdout 
{
  proc endl: unit = "std::cout << endl;";
  proc space: int = "std::cout << ' ';";
}

@#------------- STRING MODULES -------------------
module String
{
  open Bool;
  open Char;
  open Int;
  proc set: &string * string = "$1->assign($1);";
  proc pluseq: &string * string = "$1->append($2);";

  fun len: string -> int = "$1.size()";
  fun add: string * string -> string = "$1+$2";
  fun mul: string * int -> string = "std_flx::mul($1,$2)";
  fun mul: char * int -> string = "string($2,$1)";

  fun subscript: string * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: string * int -> string = 
    "std_flx::substr($1,$2,$1.size())";
  fun copyto: string * int -> string = 
    "std_flx::substr($1,0,$2)";
  fun substring: string * int * int -> string = 
    "std_flx::substr($1,$2,$3)";

  // comparisons
  fun eq: string * string -> bool = "$1==$2";
  fun ne: string * string -> bool = "$1!=$2";
  fun lt: string * string -> bool = "$1<$2";
  fun le: string * string -> bool = "$1<=$2";
  fun gt: string * string -> bool = "$1>$2";
  fun ge: string * string -> bool = "$1>=$2";

  proc print: string = "std::cout << $1;";
}

module Arith_casts
{
@for t1 in ints+floats:
  for t2 in ints+floats:
    tangle('  fun '+t1+'_of: '+t2+' -> '+t1+' = "('+tmap[t1]+')$1";')
}

@#------------- STL CONTAINERS -----------------------
module Stl 
{
  module Vector
  {
    type stl_vector[t] = "std::vector<`1>";
    type stl_vector_iterator[t] = "std::vector<`1>::iterator";
    type stl_vector_const_iterator[t] = "std::vector<`1>::const_iterator";
  }
  module List
  {
    type stl_list[t] = "std::list<`1>";
    type stl_list_iterator[t] = "std::list<`1>::iterator";
    type stl_list_const_iterator[t] = "std::list<`1>::const_iterator";
  }
  module Set
  {
    type stl_set[t] = "std::set<`1>";
    type stl_set_iterator[t] = "std::set<`1>::iterator";
    type stl_set_const_iterator[t] = "std::set<`1>::const_iterator";
  }
  module MultiSet
  {
    type stl_multiset[t] = "std::multiset<`1>";
    type stl_multiset_iterator[t] = "std::multiset<`1>::iterator";
    type stl_multiset_const_iterator[t] = "std::multiset<`1>::const_iterator";
  }
  module Map
  {
    type stl_map[k,v] = "std::map<`1,`2>";
    type stl_map_iterator[t] = "std::map<`1>::iterator";
    type stl_map_const_iterator[t] = "std::map<`1>::const_iterator";
  }
  module MultiMap
  {
    type stl_multimap[k,v] = "std::multimap<`1,`2>";
    type stl_multimap_iterator[t] = "std::multimap<`1>::iterator";
    type stl_multimap_const_iterator[t] = "std::multimap<`1>::const_iterator";
  }
  module Queue
  {
    type queue[t] = "std::queue[`1]";
    type stl_queue_iterator[t] = "std::queue<`1>::iterator";
    type stl_queue_const_iterator[t] = "std::queue<`1>::const_iterator";
  }
  module Deque
  {
    type deque[t] = "std::deque[`1]";
    type stl_deque_iterator[t] = "std::deque<`1>::iterator";
    type stl_deque_const_iterator[t] = "std::deque<`1>::const_iterator";
  }
  module PriorityQueue 
  {
    type stl_priority_queue[t] = "std::priority_queue[`1]";
    type stl_priority_queue_iterator[t] = "std::priority_queue<`1>::iterator";
    type stl_priority_queue_const_iterator[t] = "std::priority_queue<`1>::const_iterator";
  }
  module Stack
  {
    type stl_stack[t] = "std::stack[`1]";
    type stl_stack_iterator[t] = "std::stack<`1>::iterator";
    type stl_stack_const_iterator[t] = "std::stack<`1>::const_iterator";
  }
}
@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  // infinite loop
  proc loop (bdy:unit->void)
  {
    repeat:>
      bdy();
      goto repeat;
    dummy:> // fool reachability checker
  }

  // C style while loop
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if not (cond()) goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  // C style while loop with reversed condition
  // not the until is tested first -- zero iterations are possible
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if cond() goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  // do nothing [the name pass comes from Python]
  proc pass(){}

  // C style for loop
  proc for 
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    repeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto repeat;
    finish:>
  }
}

// ------ Open common modules -------------
open Bool;
open Int;
open Double;
open Char;
open String;
open Stdout;
open Arith_casts;
open Control;


