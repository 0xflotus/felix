@head(1,'Felix Standard Library')
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::lib","Python style substring support")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()

@select(tangler('rtl/flx_i18n.hpp'))
#ifndef FLX_I18N
#define FLX_I18N
#include <string>
namespace flx { namespace i18n {
   std::string utf8(unsigned long);
}}
#endif

@select(tangler('rtl/flx_i18n.cpp'))
#include "rtl/flx_i18n.hpp"
namespace flx { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}


@h=tangler('rtl/flx_strutil.cpp')
@select(h)
namespace flx { namespace lib {
  template<class T>
  std::basic_string<T> mul(std::basic_string<T> s, int n) {
    std::basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  std::basic_string<T> substr(std::basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }

}}

@h=tangler('lib/std.flx','data')
@# use data tangler to prevent line number generation
@select(h)
header """
#include <cstdio>
#include <cstddef>
#include <cmath>
#include <iostream>
#include <string>
#include <cassert>
#include <climits>
#include "rtl/boost_cstdint.hpp"
#include "rtl/flx_i18n.hpp"
""";

body """
#include "rtl/flx_strutil.cpp"
using namespace std;
""";

@tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",
  "uchar"   : "int32_t", # Unicode/ISO10646, note: SIGNED!

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",
  "vlong"   : "long long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",
  "uvlong"  : "unsigned long long",

  #exact integers
  "int8"    : "boost::int8_t",
  "int16"   : "boost::int16_t",
  "int32"   : "boost::int32_t",
  "int64"   : "boost::int64_t",
  "uint8"   : "boost::uint8_t",
  "uint16"  : "boost::uint16_t",
  "uint32"  : "boost::uint32_t",
  "uint64"  : "boost::uint64_t",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double",
  }

@chars = ["char", "wchar", "uchar"]
@sints = [
  "tiny", "short", "int", "long", "vlong",
  "int8","int16","int32","int64"
  ]
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double", "ldouble"]

// @all = ["byte", "size","address","offset","bool"] + chars + sints + uints + floats
@all = ["byte", "size","address","offset"] + chars + sints + uints + floats
@ints = uints + sints

@def gen_type(t):
  tangle('type '+t+' = "'+tmap[t]+'";')

@for t in all:
  gen_type(t)

@def gen_asgn(t):
  #tangle('  proc _set: &'+t+' * '+t+' = "*('+tmap[t]+'*)($1.data)=$2;";')
  tangle('  proc swap: &'+t+' * &'+t+' ="""')
  tangle('  {')
  tangle('    '+ tmap[t] + ' tmp=*('+tmap[t]+'*)($1.data);')
  tangle('    *('+tmap[t]+'*)($1.data)=*('+tmap[t]+'*)($2.data);')
  tangle('    *('+tmap[t]+'*)($2.data)=tmp;')
  tangle('  }""";')
  tangle('  fun eq: '+t+' * '+t+' -> bool = "$1==$2";')
  tangle('  fun ne: '+t+' * '+t+' -> bool = "$1!=$2";')

@def gen_cmp(t):
  for opname,op in [
    ("lt","<"),
    ("le","<="),
    ("gt",">"),
    ("ge",">=")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> bool = "int($1'+op+'$2)";')


// !!!!! NEW DEFINITION OF BOOL !!!!!
typedef void = 0;
typedef unit = 1;
typedef bool = 2;
typedef any = any;

module Bool 
{

  val false : bool = case 1 of 2; // binary 0
  val true : bool = case 2 of 2; // binary 1

  fun land: bool * bool -> bool = "$1 && $2";
  fun nand: bool * bool -> bool = "!($1 && $2)";
  fun lor: bool * bool -> bool = "$1 || $2";
  fun nor: bool * bool -> bool = "!($1 || $2)";
  fun xor: bool * bool -> bool = "$1 != $2";
  fun lnot: bool -> bool = "!$1";
  proc assert: bool = "assert($1);";
  proc print: bool = 'std::cout << ($1??"true":"false");';
}

@def gen_arith(t):
  for opname,op in [
    ("add","+"),
    ("sub","-"),
    ("mul","*"),
    ("div","/")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_uint(t):
  for opname,op in [
    ("caret","^"),
    ("vbar","|"),
    ("amper","&"),
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')
  tangle('  fun bnot: '+t+' -> '+t+' = "~$1";')


@def gen_arith_assign(t):
  for opname,op in [
    ("pluseq","+="),
    ("minuseq","-="),
    ("muleq","*="),
    ("diveq","/=")
  ]:
    tangle('  proc '+opname+': &'+t+' * '+t+' = "*('+tmap[t]+'*)($1.data)'+op+'$2;";')

@def gen_uint_assign(t):
  for opname,op in [
    ("careteq","^="),
    ("vbareq","|="),
    ("ampereq","&=")
  ]:
    tangle('  proc '+opname+': &'+t+' * '+t+' = "*('+tmap[t]+'*)($1.data)'+op+'$2;";')

@def gen_mod(t):
  for opname,op in [
    ("mod","%")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_neg(t):
  tangle('  fun neg: '+t+' -> '+t+' = "-$1";')
  tangle('  fun pos: '+t+' -> '+t+' = "+$1";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)";')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)";')

@def gen_nan(t):
  tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)";')

@def gen_inc(t):
  tangle('  proc pre_incr:  &'+t+' = "++*('+tmap[t]+'*)($1.data);";')
  tangle('  proc pre_decr:  &'+t+' = "--*('+tmap[t]+'*)($1.data);";')
  tangle('  proc post_incr: &'+t+' = "++*('+tmap[t]+'*)($1.data);";')
  tangle('  proc post_decr: &'+t+' = "--*('+tmap[t]+'*)($1.data);";')
  
@#------------- INTEGER MODULES -------------------
type string = "std::string";
@for t in ints:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  if t in uints: gen_uint(t)
  gen_arith_assign(t)
  if t in uints: gen_uint_assign(t)
  gen_mod(t)
  gen_neg(t)
  gen_inc(t)
  if t == "tiny":
    tangle('  proc print: tiny = "std::cout << (int)$1;";')
  elif t == "utiny":
    tangle('  proc print: utiny = "std::cout << (unsigned int)$1;";')
  else:
    tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_arith_assign(t)
  gen_neg(t)
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun chr: int -> char = "(char)$1";
  proc print: char = "std::cout<<$1;";
}

module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun wchr: long -> wchar = "(wchar_t)$1";
  proc print: wchar = "std::cout<<$1;";
}

module Unicode
{
  open Uint32;
  fun ord: uchar -> uint32 ="$1";
  fun uchr: uint32 -> uchar = "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;";
}


@#------------- STDOUT UTILITY -------------------
module Stdout 
{
  proc endl: unit = "std::cout << endl;";
  proc space: int = "std::cout << ' ';";
}
macro proc print_line (x) { print x; Stdout::endl; }

@#------------- STRING MODULES -------------------
module String
{
  open Bool;
  open Char;
  open Int;
@#  proc _set: &string * string = "((string*)($1.data))->assign($2);";
  proc pluseq: &string * string = "((string*)($1.data))->append($2);";

  fun len: string -> int = "$1.size()";
  fun add: string * string -> string = "$1+$2";
  fun add: string * int -> string = "$1+flx::i18n::utf8($2)";
  fun mul: string * int -> string = "flx::lib::mul($1,$2)";
  fun mul: char * int -> string = "string($2,$1)";

  fun subscript: string * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: string * int -> string = 
    "flx::lib::substr($1,$2,$1.size())";
  fun copyto: string * int -> string = 
    "flx::lib::substr($1,0,$2)";
  fun substring: string * int * int -> string = 
    "flx::lib::substr($1,$2,$3)";

  // comparisons
  fun eq: string * string -> bool = "$1==$2";
  fun ne: string * string -> bool = "$1!=$2";
  fun lt: string * string -> bool = "$1<$2";
  fun le: string * string -> bool = "$1<=$2";
  fun gt: string * string -> bool = "$1>$2";
  fun ge: string * string -> bool = "$1>=$2";

  proc print: string = "std::cout << $1;";
}

type ustring = "basic_string<uint32_t>";
module Ustring
{
  open Bool;
  open Char;
  open Int;
@#  proc _set: &ustring * ustring = "(basic_string<uint32_t>*)($1.data)->assign($1);";
  proc pluseq: &ustring * ustring = "(basic_string<uint32_t>*)($1.data)->append($2);";

  fun len: ustring -> int = "$1.size()";
  fun add: ustring * ustring -> ustring = "$1+$2";
  fun mul: ustring * int -> ustring = "flx::lib::mul($1,$2)";
  fun mul: char * int -> ustring = "ustring($2,$1)";

  fun subscript: ustring * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: ustring * int -> ustring = 
    "flx::lib::substr($1,$2,$1.size())";
  fun copyto: ustring * int -> ustring = 
    "flx::lib::substr($1,0,$2)";
  fun subustring: ustring * int * int -> ustring = 
    "flx::lib::substr($1,$2,$3)";

  // comparisons
  fun eq: ustring * ustring -> bool = "$1==$2";
  fun ne: ustring * ustring -> bool = "$1!=$2";
  fun lt: ustring * ustring -> bool = "$1<$2";
  fun le: ustring * ustring -> bool = "$1<=$2";
  fun gt: ustring * ustring -> bool = "$1>$2";
  fun ge: ustring * ustring -> bool = "$1>=$2";

  proc print: ustring = "std::cout << $1;";
}

module Arith_casts
{
@for t1 in ints+floats:
  for t2 in ints+floats:
    tangle('  fun '+t1+'_of: '+t2+' -> '+t1+' = "('+tmap[t1]+')$1";')
}

@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  // infinite loop
  proc forever (bdy:unit->void)
  {
    repeat:>
      bdy();
      goto repeat;
    dummy:> // fool reachability checker
  }

  // C style while loop
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if not (cond()) goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  // C style while loop with reversed condition
  // not the until is tested first -- zero iterations are possible
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if cond() goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  // do nothing [the name pass comes from Python]
  proc pass(){}

  // C style for loop
  proc for 
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    repeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto repeat;
    finish:>
  }

  proc fail:string = 'throw std::exception ($1);';
  fun fail_fun[t]:1->t = 'throw std::exception (""),*(?1*)0';
  fun fail_fun[t]:string->t = 'throw std::exception ($1),*(?1*)0';
}

module List
{
  union list[T] = | Empty | Cons of T * list[T];

  fun map[T,U] (f:T->U) (x:list[T]): list[U] = {
    return
      match x with
      | Empty => Empty[U]
      | Cons (?h, ?t) => Cons (f(h), map f t)
      endmatch
    ;
  }

  fun rev[T] (x:list[T]):list[T]= {
    fun aux (x:list[T]) (y:list[T]) : list[T] =
    {
      return 
        match x with
        | Empty => y
        | Cons (?h, ?t) => aux t (Cons (h, y))
        endmatch
      ;
    }
    return aux x Empty[T];
  }

  proc iter[T] (f:T->void) (x:list[T]) {
    match x with
    | Empty => {} 
    | Cons (?h,?t) => { f h; iter f t; }
    endmatch
    ;
  }

  fun fold_left[T,U] (f:U->T->U) (init:U) (x:list[T]):U =
  {
    return
      match x with
      | Empty => init
      | Cons (?h,?t) => fold_left f (f init h) t
      endmatch
    ;
  }

  fun fold_right[T,U] (f:T->U->U) (x:list[T]) (init:U):U =
  {
    return
      match x with
      | Empty => init
      | Cons (?h,?t) => fold_right f t (f h init)
      endmatch
    ;
  }
  
  fun join[T] (x:list[T]) (y:list[T]):list[T] = 
  {
    return
      match x with
      | Empty => y
      | Cons (?h,?t) => Cons (h, join t y)
      endmatch
    ;
  }

  fun cat[T] (x:list[list[T]]):list[T] =
  {
     return 
       match x with
       | Empty => Empty[T]
       | Cons (?h,?t) => fold_left join of (list[T]) h t
       endmatch
     ;
   }
}

module Text_file
{
  body """
    std::string _load_file (std::string f)
    {
      char *fname = f.data();
      FILE *fi = fopen(fname,"rt");
      if (fi)
      {
        string x = "";
        char buffer[512];
        int n;
        while (std::fgets(buffer,512,fi))
        {
          x = x + string(buffer);
        }
        fclose(fi);
        return x;
      }
      else return "";
    }
  """;
  fun load: string -> string = "_load_file($1)";
}

module Assoc_list
{
  typedef assoc_list[A,B] = List::list[(A,B)];
}

// This module provides functions to 
// use in conjunction with the reglex construction
module Lexer
{
  type iterator = "char const*";
  fun start_iterator : string -> iterator = "$1.data()";
  fun end_iterator: string -> iterator = "$1.data()+$1.size()";
  fun string_between: iterator * iterator -> string =
   "std::string($1,$2)";

  fun eq:iterator * iterator -> bool = "$1==$2";
  fun ne:iterator * iterator -> bool = "$1!=$2";
  fun lt:iterator * iterator -> bool = "$1<$2";
  fun le:iterator * iterator -> bool = "$1<=$2";
  fun ge:iterator * iterator -> bool = "$1>=$2";
  fun gt:iterator * iterator -> bool = "$1>$2";

  fun add: iterator * int -> iterator = "$1 + $2";
  fun sub: iterator * int -> iterator = "$1 - $2";
  fun sub: iterator * iterator -> int = "$1 - $2";
  proc incr: &iterator -> iterator = "++*$1.data;";

@#  proc _set: &iterator * iterator = "*(char const**)$1.data = $2;";
}

// ------ Open common modules -------------
open Bool;
open Int;
open Double;
open Char;
open String;
open Stdout;
open Arith_casts;
open Control;

@head(1,'Stl library')
@h=tangler('lib/stl.flx')
@select(h)
header '''
#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
''';
@#------------- STL CONTAINERS -----------------------
module Stl 
{
  module Vector
  {
    type stl_vector[t] = "std::vector<`1>";
    type stl_vector_iterator[t] = "std::vector<`1>::iterator";
    type stl_vector_const_iterator[t] = "std::vector<`1>::const_iterator";
  }
  module List
  {
    type stl_list[t] = "std::list<`1>";
    type stl_list_iterator[t] = "std::list<`1>::iterator";
    type stl_list_const_iterator[t] = "std::list<`1>::const_iterator";
  }
  module Set
  {
    type stl_set[t] = "std::set<`1>";
    type stl_set_iterator[t] = "std::set<`1>::iterator";
    type stl_set_const_iterator[t] = "std::set<`1>::const_iterator";
  }
  module MultiSet
  {
    type stl_multiset[t] = "std::multiset<`1>";
    type stl_multiset_iterator[t] = "std::multiset<`1>::iterator";
    type stl_multiset_const_iterator[t] = "std::multiset<`1>::const_iterator";
  }
  module Map
  {
    type stl_map[k,v] = "std::map<`1,`2>";
    type stl_map_iterator[t] = "std::map<`1>::iterator";
    type stl_map_const_iterator[t] = "std::map<`1>::const_iterator";
  }
  module MultiMap
  {
    type stl_multimap[k,v] = "std::multimap<`1,`2>";
    type stl_multimap_iterator[t] = "std::multimap<`1>::iterator";
    type stl_multimap_const_iterator[t] = "std::multimap<`1>::const_iterator";
  }
  module Queue
  {
    type queue[t] = "std::queue[`1]";
    type stl_queue_iterator[t] = "std::queue<`1>::iterator";
    type stl_queue_const_iterator[t] = "std::queue<`1>::const_iterator";
  }
  module Deque
  {
    type deque[t] = "std::deque[`1]";
    type stl_deque_iterator[t] = "std::deque<`1>::iterator";
    type stl_deque_const_iterator[t] = "std::deque<`1>::const_iterator";
  }
  module PriorityQueue 
  {
    type stl_priority_queue[t] = "std::priority_queue[`1]";
    type stl_priority_queue_iterator[t] = "std::priority_queue<`1>::iterator";
    type stl_priority_queue_const_iterator[t] = "std::priority_queue<`1>::const_iterator";
  }
  module Stack
  {
    type stl_stack[t] = "std::stack[`1]";
    type stl_stack_iterator[t] = "std::stack<`1>::iterator";
    type stl_stack_const_iterator[t] = "std::stack<`1>::const_iterator";
  }
}

@head(1,'Felix lexerlibrary')
@h=tangler('lib/flx_lex.flx')
@select(h)
include "std";
/* ====================== REGULAR DEFINITIONS ============================ */
module Flx_lex
{
  /* special characters */
  regexp quote = '\'';
  regexp dquote = '"';
  regexp slosh = '\\';
  regexp linefeed = '\n';
  regexp tab = '\t';
  regexp space = ' ';
  regexp formfeed = [12];
  regexp vtab = [11];
  regexp carriage_return = [13];
  regexp underscore = '_';

  /* character sets */
  regexp bindigit = ['0'-'1'];
  regexp octdigit = ['0'-'7'];
  regexp digit = ['0'-'9'];
  regexp hexdigit = digit | ['A'-'F'] | ['a'-'f'];
  regexp lower = ['a'-'z'];
  regexp upper = ['A'-'Z'];
  regexp letter = lower | upper;
  regexp hichar = [128-255];
  regexp white = space | tab;

  /* nasty: form control characters */
  regexp form_control = linefeed | carriage_return | vtab | formfeed;
  regexp newline_prefix = linefeed | carriage_return;
  regexp newline = formfeed | linefeed  | carriage_return linefeed;
  /* regexp newline = newline_prefix form_control * */

  regexp ordinary = letter | digit | hichar |
    '!' | '#' | '$' | '%' | '&' | '(' | ')' | '*' |
    '+' | ',' | '-' | '.' | '/' | ':' | ';' | '<' |
    '=' | '>' | '?' | '@' | '[' | ']' | '^' | '_' |
    '`' | '{' | '|' | '}' | '~'
  ;

  regexp printable = ordinary | quote | dquote | slosh;

  /* identifiers */
  regexp ucn = 
      "\\u" hexdigit hexdigit hexdigit hexdigit 
    | "\\U" hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit hexdigit
  ;

  regexp prime = '\'';
  regexp idletter = letter | underscore | hichar | ucn;
  regexp identifier = idletter (idletter | digit | prime )*;

  /* integers */
  regexp bin_lit  = '0' ('b' | 'B') (underscore? bindigit) +;
  regexp oct_lit  = '0' ('o' | 'O') (underscore? octdigit) +;
  regexp dec_lit  = ('0' ('d' | 'D'))? digit (underscore? digit) *;
  regexp hex_lit  = '0' ('x' | 'X') (underscore? hexdigit)  +;
  regexp type_suffix = 
    't'|'T'|'s'|'S'|'i'|'I'|'l'|'L'|'v'|'V'|"ll"|"LL"
    | "i8" | "i16" | "i32" | "i64"
    | "u8" | "u16" | "u32" | "u64"
    | "I8" | "I16" | "I32" | "I64"
    | "U8" | "U16" | "U32" | "U64"
  ;
  regexp signind = 'u' | 'U';
  regexp suffix = type_suffix? signind? | signind? type_suffix?;
  regexp int_lit = (bin_lit | oct_lit | dec_lit | hex_lit) suffix;

  /* floats: Follows ISO C89, except that we allow underscores */
  regexp decimal_string = digit (underscore? digit) *;
  regexp hexadecimal_string = hexdigit (underscore? hexdigit) *;

  regexp decimal_fractional_constant = 
    decimal_string '.' decimal_string?
    | '.' decimal_string
  ; 

  regexp hexadecimal_fractional_constant = 
    ("0x" |"0X")
    (hexadecimal_string '.' hexadecimal_string?
    | '.' hexadecimal_string)
  ;

  regexp decimal_exponent = ('E'|'e') ('+'|'-')? decimal_string;
  regexp binary_exponent = ('P'|'p') ('+'|'-')? decimal_string;

  regexp floating_suffix = 'L' | 'l' | 'F' | 'f' | 'D' | 'd';
  regexp floating_literal = 
    (
      decimal_fractional_constant decimal_exponent? |
      hexadecimal_fractional_constant binary_exponent?
    )
    floating_suffix?
  ;

  /* Python strings */
  regexp qqq = quote quote quote;
  regexp ddd = dquote dquote dquote ;

  regexp escape = slosh _ ;

  regexp dddnormal = ordinary | quote | escape | white | newline;
  regexp dddspecial = dddnormal | dquote dddnormal | dquote dquote dddnormal;

  regexp qqqnormal = ordinary | dquote | escape | white | newline;
  regexp qqqspecial = qqqnormal | quote qqqnormal | quote quote qqqnormal;

  regexp raw_dddnormal = ordinary | quote | slosh | white | newline;
  regexp raw_dddspecial = raw_dddnormal | dquote raw_dddnormal | dquote dquote raw_dddnormal;

  regexp raw_qqqnormal = ordinary | dquote | slosh | space | newline;
  regexp raw_qqqspecial = raw_qqqnormal | quote raw_qqqnormal | quote quote raw_qqqnormal;

  regexp qstring = (ordinary | dquote | escape | white) * quote;
  regexp dqstring = (ordinary | quote | escape | white) * dquote;
  regexp qqqstring = qqqspecial * qqq;
  regexp dddstring = dddspecial * ddd;

  regexp raw_qstring = (ordinary | dquote | escape | white) * quote;
  regexp raw_dqstring =  (ordinary | quote | escape | white) * dquote;

  regexp raw_qqqstring = raw_qqqspecial * qqq;
  regexp raw_dddstring = raw_dddspecial * ddd;

  regexp not_newline_or_slosh = ordinary | quote | dquote | white;
  regexp not_newline = not_newline_or_slosh | slosh;
  regexp quoted_filename = dquote (ordinary | quote | white | slosh)+ dquote;

  /* ====================== PARSERS ============================ */
  /* string tail lexers */

@def lexstr(x):
  tangle('  fun parse_'+x+'string(s:Lexer::iterator, e:Lexer::iterator) =' )
  tangle('  {')
  tangle('    return')
  tangle('      reglex s to e with')
  tangle('      | '+x+'string => "'+x+'string"' )
  tangle('      | _ =>  "ERRORTOKEN"' )
  tangle('      endmatch')
  tangle('    ;')
  tangle('  }')

@qtypes=[
  'q',
  'dq',
  'qqq',
  'ddd',
  'raw_q',
  'raw_dq',
  'raw_qqq',
  'raw_ddd'
 ]

@for i in qtypes: lexstr(i)

  fun to_eol(s:Lexer::iterator, e:Lexer::iterator) =
  {
    return 
      match 
        reglex s to e with
        | .* "\n" => ()
        endmatch
      with 
      | ?p,_ => p
      endmatch
    ; 
  }

  fun to_end_c_comment(s:Lexer::iterator, e:Lexer::iterator) =
  {
    var j = s;
    var again = true;
    while { again }
    {
      match 
        reglex j to e with
        | "*" "/" => "end"
        | "/" "*" => "recurse"
        | [^"/" "*"]* => "chars"
        endmatch
      with
        | ?p,"end" => { j = p; again = false; }
        | ?p,"recurse" => { j = to_end_c_comment(p,e); }
        | ?p,"chars" => { j = p; }
      endmatch
      ;
    }
    ;
    return j;
  }

  union pretoken_k = // k for "kind"
    | Ident
    | Int
    | Float
    | C_comment
    | Cpp_comment
    | Preprocessor
    | Sym
    
    | qQuote
    | dQuote
    | qqqQoute
    | dddQuote
    
    | wqQuote
    | wdQuote
    | wqqqQoute
    | wdddQuote
    
    | uqQuote
    | udQuote
    | uqqqQoute
    | udddQuote

    | rqQuote
    | rdQuote
    | rqqqQoute
    | rdddQuote
  ;
    
  fun pre_flx_lex(s:Lexer::iterator, e:Lexer::iterator) =
  {
    return reglex s to e with
    | "//" => Cpp_comment
    | "/*" => C_comment
    | identifier => Ident
    | int_lit => Int
    | floating_literal => Float

    /* Python strings */
    | quote   => qQuote
    | qqq     => qqqQuote
    | dquote  => dQuote
    | ddd     => dddQuote

    /* wide strings */
    | ('w' | 'W') quote  => wqQuote
    | ('w' | 'W') qqq    => wqqqQuote
    | ('w' | 'W') dquote => wdQuote
    | ('w' | 'W') ddd    => wdddQuote

    /* UTF32 strings */
    | ('u' | 'U') quote  => uqQuote
    | ('u' | 'U') qqq    => uqqqQuote
    | ('u' | 'U') dquote => udQuote
    | ('u' | 'U') ddd    => udddQuote

    /* Python raw strings */
    | ('r'|'R') quote   => rqQuote
    | ('r'|'R') qqq     => rqqqQuote
    | ('r'|'R') dquote  => rdQuote
    | ('r'|'R') ddd     => rdddQuote


    /* one character sequences */
    | "$" => Sym
    | "(" => Sym
    | ")" => Sym
    | "[" => Sym
    | "]" => Sym
    | "{" => Sym
    | "}" => Sym
    | "!" => Sym
    | ":" => Sym
    | "," => Sym
    | ";" => Sym
    | "+" => Sym
    | "-" => Sym
    | "*" => Sym
    | "/" => Sym
    | "|" =>Sym
    | "&" =>Sym
    | "<" =>Sym
    | ">" =>Sym
    | "=" =>Sym
    | "." =>Sym
    | "%" =>Sym
    | "`" =>Sym
    | "~" =>Sym
    | "^" =>Sym
    | "!" =>Sym
    | "?" =>Sym

    /* two character sequences */
    | "=>" =>Sym
    | "&<" =>Sym
    | "&>" =>Sym
    | ".." =>Sym
    | "::" =>Sym
    | "==" =>Sym
    | "<>" =>Sym
    | "!=" =>Sym
    | "<=" =>Sym
    | ">=" =>Sym
    | "<<" =>Sym
    | ">>" =>Sym
    | "**" =>Sym
    | "\\" =>Sym
    | "++" =>Sym
    | "--" =>Sym
    | "+=" =>Sym
    | "-=" =>Sym
    | "*=" =>Sym
    | "/=" =>Sym
    | "%=" =>Sym
    | "^=" =>Sym
    | "|=" =>Sym
    | "&=" =>Sym
    | "~=" =>Sym
    | ":=" =>Sym
    | "<-" =>Sym
    | "->" =>Sym
    | "<:" =>Sym
    | ":>" =>Sym
    | "[<" =>Sym
    | ">]" =>Sym

    /* three character sequences */
    | "<<=" => Sym
    | ">>=" =>Sym
    | "..." =>Sym
    | "<->" =>Sym
    | "&==" =>Sym
    | "&<>" => Sym
    | "&!=" =>Sym
    | "&<=" =>Sym
    | "&>=" =>Sym

    /* whitespace */
    | white + => White

    /* Preprocessor Directive */
    | "#" => Preprocessor

    | newline => Eol

    /* Anything else is an error */
    | _ => Error
    endmatch
    ;
  }
}
