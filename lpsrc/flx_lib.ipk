@head(1,'Felix Standard Library')
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::rtl::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::rtl::strutil","Python style substring support")
@table_row("rtl/flx_ioutil","C++","flx::rtl::ioutil","Standard IO support")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()

@select(tangler('rtl/flx_i18n.hpp'))
#ifndef FLX_I18N
#define FLX_I18N
#include <string>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace i18n {
   FLX_RTL_EXTERN std::string utf8(unsigned long);
}}}
#endif

@select(tangler('rtl/flx_i18n.cpp'))
#include "flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}


@h=tangler('rtl/flx_ioutil.hpp')
@select(h)
#ifndef FLX_IOUTIL
#define FLX_IOUTIL
#include <string>
#include <cstdio>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace ioutil {
  FLX_RTL_EXTERN std::string load_file (std::FILE *);
  FLX_RTL_EXTERN std::string load_file (std::string);
  FLX_RTL_EXTERN std::string readln(std::FILE*);
  FLX_RTL_EXTERN void write (std::FILE *, std::string);
  FLX_RTL_EXTERN void writeln (std::FILE *, std::string);
}}}
#endif

@h=tangler('rtl/flx_ioutil.cpp')
@select(h)
#include <cstdio>
#include <string>
#include "flx_ioutil.hpp"
namespace flx { namespace rtl { namespace ioutil {
  using namespace std;

  string load_file (FILE *fi)
  {
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  string load_file (string f)
  {
    char const *fname = f.data();
    FILE *fi = fopen(fname,"rt");
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  // includes newline if present
  // null string indicates end of file
  string readln (FILE *fi)
  {
    if(fi)
    {
      string x = "";
      char buffer[513];
      buffer[512]='\0';
      int n;
      while 
      ( 
        !(
          (n=x.size()) && 
          x[n-1]=='\n'
        ) 
        &&
        fgets(buffer,512,fi)
      )
        x = x + string(buffer);
      return x;
    }
    else return "";
  }

  void write (FILE *fi, string s)
  {
    fwrite(s.data(),s.size(),1,fi);
  }

  void writeln (FILE *fi, string s)
  {
    static char *eol = "\n";
    static int n = 0;
    if(n==0)n=strlen(eol);
    fwrite(s.data(),s.size(),1,fi);
    fwrite(eol,n,1,fi);
  }

}}}

@h=tangler('rtl/flx_strutil.cpp')
@select(h)
#include <string>
#include <sstream>
#include "flx_rtl_config.hpp"

template class FLX_RTL_EXTERN std::basic_string<char>;

namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }

  template<class T>
  string str(T const &t) {
    std::ostringstream x;
    x << t;
    return x.str();
  }

  string atostr(char const *a) {
    if(a) return a;
    else return "";
  }
}}}

@h=tangler('lib/flx_categories.flx')
@select(h)
  macro proc gen_eq(t){
    fun eq: t * t -> bool = "$1==$2" ;
    fun ne: t * t -> bool = "$1!=$2" ;
  }

  macro proc gen_cmp(t){
    gen_eq t;
    fun lt: t * t -> bool = "$1<$2" ;
    fun gt: t * t -> bool = "$1>$2" ;
    fun le: t * t -> bool = "$1<=$2" ;
    fun ge: t * t -> bool = "$1>=$2" ;
  }

  // additive group
  macro proc gen_add (t){
    fun pos: t -> t = "+$1" ;
    fun neg: t -> t = "-$1" ;
    fun add: t * t -> t = "$1+$2" ;
    fun sub: t * t -> t = "$1-$2" ;
    proc pluseq: lvalue[t] * t = "$1+=$2;";
    proc minuseq: lvalue[t] * t = "$1-=$2;";
  }

  // ring
  macro proc gen_arith(t){
    gen_add t;
    fun mul: t * t -> t = "$1*$2" ;
    fun div: t * t -> t = "$1/$2" ;
    proc muleq: lvalue[t] * t = "$1*=$2;";
    proc diveq: lvalue[t] * t = "$1/=$2;";
  }

  // division ring
  macro proc gen_dring(t){
    gen_arith t;
    fun mod : t * t -> t = "$1%$2" ;
    proc modeq: lvalue[t] * t = "$1%=$2;";
  }

  macro proc gen_forward (t){
    fun succ: t -> t = "$1:add + 1" is add;
    proc pre_incr:  lvalue[t] = "++$1;";
    proc post_incr: lvalue[t] = "$1++;";
  }

  macro proc gen_bidirectional(t){
    gen_forward t;
    fun pred: t -> t = "$1:add - 1" is add;
    proc pre_decr:  lvalue[t] = "--$1;";
    proc post_decr: lvalue[t] = "$1--;";
  }

  macro proc gen_random(t){
    gen_bidirectional t;
    fun add: t * int -> t = "$1+$2";
    fun sub: t * int -> t = "$1-$2";
    proc pluseq: lvalue[t] * int = "$1+=$2;";
    proc minuseq: lvalue[t] * int = "$1-=$2;";
  }

  // division ring
  macro proc gen_integral(t){
    gen_cmp t;
    gen_dring t;
    gen_bidirectional t;
  }

@h=tangler('lib/std.flx','data')
@# use data tangler to prevent line number generation
@select(h)
header '#include "flx_rtl_config.hpp"';
#include "flx_categories.flx"

header iostream = "#include <iostream>";
header cmath = """
#include <cmath>
#ifdef HAVE_ISNAN_IN_IEEEFP
extern "C" {
#include <ieeefp.h>
}
#endif
""";

header """
#include <cstdio>
#include <cstddef>
#include <cassert>
#include <climits>
using namespace std;
""";


header flx_ioutil = '#include "flx_ioutil.hpp"';
header flx_dynlink = '#include "flx_dynlink.hpp"';
header flx_i18n = '#include "flx_i18n.hpp"';

// note -- this code is templated, we include
// it in the header file because that's where
// most C++ compilers need it (ISO requires
// separate compilation of templates but most
// compilers as at 2004 don't implement it)

header flx_strutil = '#include "flx_strutil.cpp"';

header cctype_hxx = '#include <cctype>';
header string_hxx = '#include <string>';
header complex_hxx = '#include <complex>';
header c99_complex_h = '#include <complex.h>';

@if HAVE_STDINT:
  tangle('header c99_stdint_h = "#include <stdint.h>";')
 else:
  tangle('header c99_stdint_h = "";')

header cstdlib = "#include <cstdlib>";

@chars = ["char", "wchar", "uchar"]
@fast_sints = [
  "tiny", "short", "int", "long", "vlong"
  ]
@exact_sints = [
  "int8","int16","int32","int64"
  ]
@sints = fast_sints + exact_sints
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double", "ldouble"]
@complex = ["complex","dcomplex","lcomplex"]
@imaginary= ["imaginary", "dimaginary", "limaginary"]

typedef chars = typesetof (char, wchar, uchar);

typedef fast_sints = typesetof (tiny, short, int, long, vlong);
typedef exact_sints = typesetof(int8,int16,int32,int64);
typedef fast_uints = typesetof (utiny, ushort, uint, ulong,uvlong);
typedef exact_uints = typesetof (uint8,uint16,uint32,uint64);

typedef sints = fast_sints || exact_sints;
typedef uints = fast_uints || exact_uints;

typedef fast_ints = fast_sints || fast_uints;
typedef exact_ints = exact_sints || exact_uints;

typedef ints = sints || uints;

typedef floats = typesetof (float, double, ldouble);
typedef reals = ints || floats;

typedef complexes = typesetof (complex,dcomplex,lcomplex);
typedef imaginaries = typesetof (imaginary, dimaginary, limaginary);

typedef numbers = reals || imaginaries || complexes;


@absmap = { 
  "tiny":"abs",
  "short":"abs",
  "int":"abs",
  "long":"labs",
  "vlong":"llabs"
  }

@all = [
  "byte", "size","address","caddress","vaddress","cvaddress",
  "offset", 
  ] + chars + sints + uints + floats + complex + imaginary

@ints = uints + sints

@def gen_type(t):
  d = rmap.get(t,None)
  if d:
    tangle('pod type '+t+' = "'+tmap[t]+'" requires '+d+';')
  else:
    tangle('pod type '+t+' = "'+tmap[t]+'";')

body swapper[t] = """
  void swapper(?1 &a, ?1 &b){
    ?1 tmp = a; a = b; b = tmp;
  }
""";

proc _swap[t]: lvalue[t] * lvalue[t] = 
  "swapper($1,$2);"
  requires swapper[t];

@for t in all:
  gen_type(t)

typedef charp = C_hack::ptr[char];
typedef charcp = C_hack::cptr[char];

publish "Empty sum"
  typedef void = 0;

publish "Unit type"
  typedef unit = 1;

publish "Boolean"
  typedef bool = 2;

publish "option type"
  typedef optional[t] = 1 + t;

publish "Universal type 'x as x'"
  typedef any = any;

publish "Array type"
  typedef array[t,n] = t ^ n;

publish "Lvalue hack"
  typedef lvalue[t] = lval t;

publish "Array access: works on LHS of assignment too"
fun subscript[t,n]: array[t, n] * int -> t = "$1.data[$2]";
fun subscript[t,n]: lvalue[array[t, n]] * int -> lvalue[t] = "$1.data[$2]";

publish "Explicit array store function"
proc store[t,n]: &array[t,n] * int * t = "((?1*)($1.data))[$2]=$3;";

@def gen_uint(t):
  for opname,op in [
    ("caret","^"),
    ("vbar","|"),
    ("amper","&"),
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')
  tangle('  fun bnot: '+t+' -> '+t+' = "~$1";')


@def gen_uint_assign(t):
  for opname,op in [
    ("careteq","^="),
    ("vbareq","|="),
    ("ampereq","&=")
  ]:
    tangle('  proc '+opname+': lvalue['+t+'] * '+t+' = "$1'+op+'$2;";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)" is postfix requires cmath;')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)" is postfix requires cmath;')

@def gen_nan(t):
  if HAVE_ISNAN_IN_CMATH:
    tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)" is postfix requires cmath;')
  elif HAVE_ISNAN_IN_IEEEFP:
    tangle('  fun isnan: '+t+' -> bool = "isnanf'+fc[t]+'($1)" is postfix requires cmath;')
  else:
    tangle('  fun isnan: '+t+' -> bool = "!($1==$1)" is unary requires cmath;')

 
@#------------- TYPING ---------------------------
module Typing
{
  typedef fun dom(t:TYPE):TYPE =>
    typematch t with
    | ?a -> _ => a
    endmatch
  ;

  typedef fun cod(t:TYPE):TYPE =>
    typematch t with
    | _ -> ?b => b
    endmatch
  ;
  
  typedef fun prj1(t:TYPE):TYPE =>
    typematch t with
    | ?a * _ => a
    endmatch
  ;

  typedef fun prj2(t:TYPE):TYPE =>
    typematch t with
    | _ * ?b => b
    endmatch
  ;

  typedef fun land(x:TYPE, y:TYPE):TYPE => 
    typematch (x,  y) with
    | 0, _ => 0
    | _,0 => 0
    | _,_ => 1
    endmatch
  ;

  typedef fun lor(x:TYPE, y:TYPE):TYPE=>
    typematch (x,  y) with
    | 0, 0 => 0
    | _,_ => 1
    endmatch
  ;
}
  
@#------------- CASTS and C HACKERY ---------------
publish """
This module provides access to raw C/C++ encodings.
Incorrect typing is likely to pass by Felix and
be trapped by the C/C++ compiler. Incorrect management
of storage can lead to corruption. The use of the
C_hack module is necessary for interfacing.
"""
module C_hack
{
  publish "C void"
  incomplete type void_t = "void";

  publish "standard variable argument list pointer type"
  type va_list = "va_list";

  publish """
  GCC specific valist thingo: it will
  be optimised away if not used (eg on MSVC)
  """
  type __builtin_va_list = '__builtin_va_list';

  publish """
  Throw away result of a function call:
  only useful for C functions that are mainly
  called for side effects.
  """
  proc ignore[t]:t = "(void)$t;";
  
  fun cast[dst,src]: src->dst = '(?1)($1)';
  fun static_cast[dst,src]: src->dst = 'static_cast<?1>($1)';
  fun dynamic_cast[dst,src]: src->dst = 'dynamic_cast<?1>($1)';
  fun reinterpret_cast[dst,src]: src->dst = 'reinterpret_cast<?1>($1)';
  const sizeof[t]:size = 'sizeof(?1)';
  fun int_of:size->int='$1';
  fun size_of:int->size='$1';

  publish "Abstract type for C pointer"
  pod type ptr[t]="?1 *";

  publish "Abstract type for C pointer to const"
  pod type cptr[t]="?1 const *";

  publish "Convert pointer to pointer to const"
  fun enconst[t]: ptr[t]->cptr[t] = "(?1 const*)$1";

  publish """
  Unsafe function to get C pointer from Felix reference.
  The pointer may dangle if the collector deletes the 
  frame containing the object. 
  """
  fun unref[t]: &t->ptr[t] = "(?1*)($1.data)";

  publish """
  Function to make Felix reference from C pointer.
  This function is only safe if the C pointer
  was not allocated by the Felix collector:
  the resulting reference will never be collected
  (because the frame pointer is set to 0)
  """
  fun mkref[t]: ptr[t]->&t = "(#0 const&)flx::rtl::_ref_(0,(void*)$1)";

  publish """
  Dereference a C pointer. If the expression is an
  an lvalue, the result is an lvalue. Assignments
  to const lvalues are trapped by the C/C++ compiler.
  """
  fun deref[t]: ptr[t] -> lvalue[t] = "*$1";
  fun deref[t]: cptr[t] -> lvalue[t] = "*$1";

  publish """
  Function to take the address of a C lvalue,
  fails in C/C++ compiler if the argument isn't an lvalue.
  Addresses of Felix variables are safe to use provided the
  containing frame won't be collected. 
  Addresses of temporaries must not be taken.
  """
  fun addr[t]: lvalue[t] -> ptr[t] = "&$1";
  fun caddr[t]: lvalue[t] -> cptr[t] ="(?1 const*)&$1";
  fun as_address[t]: ptr[t]->address = "(void*)$1";
  fun address_of[t]: lvalue[t]-> address = "(void*)&$1";
  fun isNULL: address -> bool = "(NULL==$1)";
  
  publish """
  Polymorphic null pointer constant
  """
  const null_ptr[t]:ptr[t] = "(?1*)NULL";
  const null_cptr[t]:ptr[t] = "(?1 const*)NULL";

  publish """
  Unsafe output of hopefully null terminated C strings
  """
  proc print: charp = "std::cout << $1;" requires iostream;
  proc print: charcp = "std::cout << $1;" requires iostream;

  publish """ print an address in hex """
  proc print: address = "std::cout << $1;" requires iostream;

  header dflt_h = "template<class T> T dflt() { return T(); }";
  publish """
  Workaround for g++ 3.2.2 parsing bug,
  it can parse T() as a default ctor call,
  but screws up on (T())
  """
  fun dflt[t]:1->t = "dflt<?1>()" requires dflt_h;

}

module Carray
{
  requires cstdlib;
  open C_hack;

  fun array_alloc[t]: int -> ptr[t] = '(?1*)std::malloc(sizeof(?1)*$1)'; 
  fun array_calloc[t]: int -> ptr[t] = '(?1*)std::calloc(sizeof(?1),$1)'; 
  proc free[t]: ptr[t]="std::free($1);";
  fun subscript[t]: ptr[t] * int -> lvalue[t] = '$1[$2]';
}

publish "System Interface"
module System
{
  const argc:int = "ptf->argc";
  fun argv:int -> string = 'std::string($1<0||$1>=ptf->argc??"":ptf->argv[$1])';
@tangle('  const felix_version : string = \'std::string("'+flx_version+'")\';')
  fun system: string -> int = "std::system($1.data())"
    requires cstdlib;
  proc exit: int = "std::exit($1);";
  proc abort: 1 = "std::abort($1);";
  type ptf_t = "thread_frame_t*";
  const ptf:ptf_t = "ptf"; 
    // note this will NOT work if ptf is a struct,
    // then we'd need (&ptf) instead ..
    // however this model isn't supported fully yet and probably never will be
    // we may, however, make ptf a machine register
}

@#------------- Environment -------------------
module Env
{
  fun getenv:string -> string = 
    "flx::rtl::strutil::atostr(getenv($1.data()))" 
    requires flx_strutil, cstdlib;
}

module Dynlink
{
  requires flx_dynlink;
  type flx_library = "flx::rtl::flx_dynlink_t*";
  type flx_instance = "flx::rtl::flx_libinit_t";
  proc dlopen:flx_library * string = "$1->link($2.data());";
  proc dlclose:flx_library = "$1->unlink();";

  // this is a procedure, so maybe the caller is too
  // which means the thread frame must be available
  proc create: flx_library * flx_instance = 
    "_create($1,&$2,PTF gc,PTF argc,PTF argv,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr);"
    requires property "needs_gc",
    body """
    void _create
    (
      flx::rtl::flx_dynlink_t *library,
      flx::rtl::flx_libinit_t *instance,
      flx::gc::generic::collector_t *gc,
      int argc, char **argv, 
      FILE *stdin_, FILE *stdout_, FILE *stderr_
    )
    { 
      instance->create(library,gc,argc,argv,stdin_,stdout_,stderr_); 
    }
    """;
  
  private fun get_init: flx_instance -> cont = "$1.start_proc";
  private fun get_library: flx_instance -> flx_library = "$1.lib";
  proc destroy: flx_instance = "$1.destroy();";
  
  fun create_library_handle: unit->flx_library=
    "new flx::rtl::flx_dynlink_t()";

  proc delete_library_handle: flx_library =
    "delete $1;";
    
  noinline fun init_lib(filename:string):flx_instance = {
    var library = create_library_handle();
    var instance: flx_instance;
    dlopen(library,filename);
    create (library,instance);
    var init = get_init instance;
    Control::run init;
    return instance;
  }

  publish """ Run a Felix program. 
    WARNING!! All data created by the target
    program must be destroyed 
    before the library code is unlinked.
  """
  proc run_lib(filename:string) 
  {
    var instance = init_lib(filename);
    destroy_lib instance;
  }

  noinline proc destroy_lib(instance:flx_instance)
  {
    destroy instance;
    Control::collect();
    dl := get_library instance;
    dlclose dl;
    delete_library_handle dl;
  }

  publish "dlsym wrapper, returns any symbol"
  fun dlsym:flx_library * string->address = 
      "SDLSYM($1->library,$2.data())";

  publish """
    execute an address representing a top
    level exported felix procedure's C wrapper,
    this creates a 'read to run' continuation object
    by both constructing the object using the thread
    frame of the instance as an argument, and calling
    it to fix a null return address and an arbitrary
    client data pointer as arguments to the call method.
  """
  fun bind_proc: flx_instance * address * address -> cont = 
    "$1.bind_proc($2,$3)";

  fun dlib_of : flx_library -> address = "(void*)$1->library";

  proc dlsym_err:flx_library*string="""
    throw flx::rtl::flx_link_failure_t($1->filename,$2,"symbol not found");
  """;

  noinline proc run_proc (instance:flx_instance, p: string, data: address) 
  {
    var lib = get_library instance;
    var sym = dlsym(lib, p);
    if C_hack::isNULL(sym) do dlsym_err(lib,p); done;
    var f = bind_proc(instance, sym, data);
    run f;
  }

}

@#------------- Text I/O -------------------
module Text_file
{
  requires flx_ioutil;
  fun load: string -> string = "flx::rtl::ioutil::load_file($1)";
  fun load: text_file -> string = "flx::rtl::ioutil::load_file($1)";

  pod type text_file = "FILE*"; // its a macro?

  fun fopen_input: string -> text_file = 'std::fopen($1.data(),"rt")';
  fun fopen_output: string -> text_file = 'std::fopen($1.data(),"wt")';
  proc fclose: text_file = '(void)std::fclose($1);';
  fun readln: text_file -> string ="flx::rtl::ioutil::readln($1)";
  proc writeln : text_file * string ="flx::rtl::ioutil::writeln($1,$2);";
  proc write : text_file * string ="flx::rtl::ioutil::write($1,$2);";
  fun valid : text_file -> bool = "$1!=(FILE*)0";
  const stdin: text_file = "PTF flx_stdin";
  const stdout: text_file = "PTF flx_stdout";
  const stderr: text_file = "PTF flx_stderr";
}


@#------------- BOOL -------------------
publish "Bool compatible with C"
module Bool 
{

  val false : bool = case 1 of 2; // binary 0
  val true : bool = case 2 of 2; // binary 1
  gen_eq bool;
  fun land: bool * bool -> bool = "$1 && $2";
  fun nand: bool * bool -> bool = "!($1 && $2)";
  fun lor: bool * bool -> bool = "$1 || $2";
  fun nor: bool * bool -> bool = "!($1 || $2)";
  fun xor: bool * bool -> bool = "$1 != $2";
  fun lnot: bool -> bool = "!$1";
  proc print: bool = 'std::cout << ($1??"true":"false");' requires iostream;
}

@#------------- INTEGER MODULES -------------------
type string = "std::string";
@for t in ints:
  tangle("module " + string.capitalize(t))
  tangle("{")
  tangle('  gen_integral('+t+');')
  if t in fast_sints:
    tangle('  fun abs: '+t+' -> '+t+' = "'+absmap[t]+'($1)";')
  if t in uints: gen_uint(t)
  if t in uints: gen_uint_assign(t)
  if t == "tiny":
    tangle('  proc print: tiny = "std::cout << (int)$1;" requires iostream;')
    tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<int>($1)" requires flx_strutil;')
  elif t == "utiny":
    tangle('  proc print: utiny = "std::cout << (unsigned int)$1;" requires iostream;')
    tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<unsigned int>($1)" requires flx_strutil;')
  else:
    tangle('  proc print: '+t+' = "std::cout<<$1;" requires iostream;')
    tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("module " + string.capitalize(t))
  tangle("{")
  tangle('  gen_cmp('+t+');')
  tangle('  gen_arith('+t+');')
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc print: '+t+' = "std::cout<<$1;" requires iostream;')
  tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
@for t in chars:
  tangle('  gen_eq('+t+');')

module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun chr: int -> char = "(char)$1";
  proc print: char = "std::cout<<$1;" requires iostream;
}

module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun wchr: long -> wchar = "(wchar_t)$1";
  proc print: wchar = "std::cout<<$1;" requires iostream;
}

module Unicode
{
  open Uint32;
  fun ord: uchar -> uint32 ="$1";
  fun uchr: uint32 -> uchar = "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;" requires iostream;
}


@#------------- STDOUT UTILITY -------------------
module Stdout 
{
  proc endl: unit = "std::cout << std::endl;" requires iostream;
  proc space: int = "std::cout << ' ';" requires iostream;
}
macro proc print_line (x) { print x; Stdout::endl; }

@#------------- STRING MODULES -------------------
module String
{
  requires string_hxx;
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[string] * string = "$1.append($2);";
  proc pluseq: lvalue[string] * charcp = "$1.append($2);";
  proc pluseq: lvalue[string] * charp = "$1.append($2);";
  proc pluseq: lvalue[string] * char = "$1 += $2;";

  fun str: charp -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;
  fun str: charcp -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;

  fun len: string -> int = "$1.size()";
  fun add: string * string -> string = "$1+$2";
  fun add: string * int -> string = "$1+flx::rtl::i18n::utf8($2)" requires flx_i18n;
  fun mul: string * int -> string = "flx::rtl::strutil::mul($1,$2)" requires flx_strutil;
  fun mul: char * int -> string = "std::string($2,$1)";
  
  fun apply (x:string, y:string):string => x + y;
  fun apply (x:string, y:int):string => x + y;
  
  fun subscript: string * int -> char = 
    "$1[$2<0??$1.size()+$2 : $2]";
  fun copyfrom: string * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$1.size())" requires flx_strutil;
  fun copyto: string * int -> string = 
    "flx::rtl::strutil::substr($1,0,$2)" requires flx_strutil;
  fun substring: string * int * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$3)" requires flx_strutil;

  // comparisons
  gen_cmp string;

  proc print: string = "std::cout << $1;" requires iostream;
  fun atoi: string -> int = "std::atoi($1.data())" requires cstdlib;
  fun atol: string -> long = "std::atol($1.data())" requires cstdlib;
  fun atof: string -> double = "std::atof($1.data())" requires cstdlib;

  proc reserve: lvalue[string] * int = "$1.reserve($2);";

  publish "Unsafe extract buffer pointer"
  fun cstr: string -> C_hack::ptr[char] = "$1.data()";

  fun repr_expr[t]: t -> string = '\\"$a:?1\\"';
  const repr_type[t]:string = '\\"?1\\"';
}

module Cstdlib
{
  requires cstdlib;
  const RAND_MAX:long;

  proc srand: uint = 'std::srand($1);';
  fun rand: 1 -> int = 'std::rand()';
}

type ustring = "basic_string<uint32_t>" requires string_hxx;
module Ustring
{
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[ustring] * ustring = "$1.append($2);";

  fun len: ustring -> int = "$1.size()";
  fun add: ustring * ustring -> ustring = "$1+$2";
  fun mul: ustring * int -> ustring = "flx::lib::mul($1,$2)";
  fun mul: char * int -> ustring = "ustring($2,$1)";

  fun apply (x:ustring, y:ustring):ustring => x + y;
 
  fun subscript: ustring * int -> char = 
    "$1[$2<0??$1.size()+$2 : $2]";
  fun copyfrom: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$1.size())";
  fun copyto: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,0,$2)";
  fun subustring: ustring * int * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$3)";

  // comparisons
  gen_cmp ustring;

  proc print: ustring = "std::cout << $1;" requires iostream;
}

publish """
All the arithmetic casts between standard C arithmetic types.
"""
module Arith_casts
{
@for t1 in ints+floats:
  for t2 in ints+floats:
    tangle('  fun '+t1+'_of: '+t2+' -> '+t1+' = "('+tmap[t1]+')$1:cast" is cast;')
}

@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  publish 'infinite loop'
  proc forever (bdy:unit->void)
  {
    rpeat:>
      bdy();
      goto rpeat;
    dummy:> // fool reachability checker
  }

  publish 'C style while loop'
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    rpeat:>
      if not (cond()) goto finish;
      bdy();
      goto rpeat;
    finish:>
  }

  /* DISABLED: replaced by UNTIL statement until the optimiser is working
  publish """
  C style while loop with reversed condition
  note the until is tested first -- zero iterations are possible
  """
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if cond() goto finish;
      bdy();
      goto repeat;
    finish:>
  }
  */

  publish "do nothing [the name pass comes from Python]"
  proc pass(){}

  publish 'C style for loop'
  proc for_each
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    rpeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto rpeat;
    finish:>
  }

  publish 'abnormal termination with message'
  proc fail:string = 'throw std::exception ($1);';

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:1->t = 'throw std::exception (""),*(?1*)0';

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:string->t = 'throw std::exception ($1),*(?1*)0';

  publish "Felix procedural continuation type"
  _gc_pointer type cont = "flx::rtl::con_t*";

  publish "Current continuation"
  fun current_continuation: 1 -> cont = "this";

  publish "Felix fthread"
  _gc_pointer type fthread = "flx::rtl::fthread_t*";

 
  publish """
    Throw a continuation. This is unsafe. It should
    work from a top level procedure, or any function
    called by such a procedure, but may fail
    if thrown from a procedure called by a function.
    The library run and driver will catch the
    continuation and execute it instead of the
    current continuation. If the library run is used
    and the continuation being executed is down the
    C stack, the C stack will not have been correctly
    popped. Crudely, nested drivers should rethrow
    the exception until the C stack is in the correct
    state to execute the continuation, but there is no
    way to determine that at the moment.

    Compiler generated runs ignore the exception,
    the library run catches it. Exceptions typically
    use a non-local goto, and they cannot pass across
    a function boundary.
  """
  proc throw(x: unit->void) { _throw (C_hack::cast[cont] x); }
  private proc _throw: cont = "throw $1;";

  publish "Supervisor calls"
  // THESE VALUES MUST SYNC WITH THE RTL
  union svc_req_t =
  | svc_yield                          // 0
  | svc_get_fthread of address         // 1
  | svc_read of address                // 2
  | svc_general of address             // 3
  ;

  publish "Call Supervisor"
  // this interface just gets rid of the horrible requirement
  // the request be in a variable so it is addressable
  proc svc(x:svc_req_t) {
    var y=x;
    _svc y;
  }

  publish "Read primitive"
  // finds the machine address of the read buffer
  // then does a supervisor read specifying that address
  proc read[t](x:&t) { 
    val vadr : address = C_hack::as_address$ C_hack::unref x;
    req  := svc_read vadr;
    svc req;
  }

  private fun _start[t]: (t->0)*t->cont = "$1->clone()->call(0,$2)";
  fun start[t] (p:t->0) (x:t) = { return _start (p,x); }
  private fun _start0: (1->0)->cont = "$1->clone()->call(0)";
  fun start (p:1->0) = { return _start0 (p); }

  fun mk_thread: cont->fthread = "new(*PTF gc,_fthread_ptr_map) flx::rtl::fthread_t($1)";
  publish "Resume a continuation until it yields"
  fun step: cont -> cont = "$1->resume()";

  publish """
  Run a continuation until it terminates.
  Do not use this proc if the underlying
  procedure attempts to read messages.
  
  This is a low level primitive, bypassing fthreads.
  """
  proc run: cont = 
  """
  {
    flx::rtl::con_t *tmp=$1;
    if(!tmp)
      throw flx::rtl::flx_exec_failure_t (__FILE__,"run","Run terminated procedure");
    while(tmp) {
      try { tmp=tmp->resume(); }
      catch (flx::rtl::con_t *x) { tmp = x; }
    }
  }
  """;

  private proc _send[t]: &cont * t = 
  """
  {
    using namespace flx::rtl;
    con_t *tmp = *(con_t**)$1.data;
    // run target until it reaches a service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // check it is alive and making the expected service request
    if (!tmp) 
      throw flx_exec_failure_t (__FILE__,"send","Send to terminated procedure");
    if (!tmp->p_svc) 
      throw flx_exec_failure_t (__FILE__,"send","Send to unready Procedure");
    if (tmp->p_svc->variant != svc_read) 
      throw flx_exec_failure_t (__FILE__,"send","Send to Procedure which is not trying to read");
    // store the message
    **(?1**)tmp->p_svc->data= $2;
    // clear the service request
    tmp->p_svc = 0;
    // run the target until the next service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // save the new continuation
    *(con_t**)$1.data = tmp; 
  }
  """;

  publish """Send a message to a continuation.
  There is no type checking on the message type.
  The procedure is executed until
  the next wait_state, then the message is stored.

  Low level primitive, bypassing fthreads.
  """
  proc send[t] (p:&cont) (x:t)
  {
    _send (p,x);
  }

  publish """
  Invoke the garbage collector inside a procedure run
  by the top level (external) driver.

  Don't call this procedure in a procedure which is run
  with 'run', because such procedures do not link to their
  caller with frame pointers -- unless of course a such a
  procedure has a private collector.

  Note procedure called by functions are run with 
  code equivalent to 'run'.
  """
  proc collect: unit = """
    PTF gc->add_root(this); 
    PTF gc->collect();
	  PTF gc ->remove_root(this); 
  """ requires property "needs_gc";
}

@#------------- List -------------------
publish "List manipulation"
module List
{
  union list[T] = | Empty | Cons of T * list[T];

  fun map[T,U] (f:T->U) (x:list[T]): list[U] = {
    return
      match x with
      | Empty[T] => Empty[U]
      | Cons[T] (?h, ?t) => Cons (f(h), map[T,U] f t)
      endmatch
    ;
  }

  fun rev[T] (x:list[T]):list[T]= {
    fun aux (x:list[T]) (y:list[T]) : list[T] =
    {
      return 
        match x with
        | Empty[T] => y
        | Cons[T] (?h, ?t) => aux t (Cons (h, y))
        endmatch
      ;
    }
    return aux x Empty[T];
  }

  proc iter[T] (f:T->void) (x:list[T]) {
    match x with
    | Empty[T] => {} 
    | Cons[T] (?h,?t) => { f h; iter f t; }
    endmatch
    ;
  }

  fun fold_left[T,U] (f:U->T->U) (init:U) (x:list[T]):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_left f (f init h) t
      endmatch
    ;
  }

  fun fold_right[T,U] (f:T->U->U) (x:list[T]) (init:U):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_right f t (f h init)
      endmatch
    ;
  }
  
  fun join[T] (x:list[T]) (y:list[T]):list[T] = 
  {
    return
      match x with
      | Empty[T] => y
      | Cons[T] (?h,?t) => Cons (h, join t y)
      endmatch
    ;
  }

  fun add[T] (x:list[T], y: list[T]):list[T] => join x y;

  fun add[T] (x:list[T], y: T):list[T] => Cons (y, x);

  fun cat[T] (x:list[list[T]]):list[T] =
  {
     return 
       match x with
       | Empty[list[T]] => Empty[T]
       | Cons[list[T]] (?h,?t) => fold_left join of (list[T]) h t
       endmatch
     ;
   }
}

publish "Association Lists (lists of pairs)"
module Assoc_list
{
  typedef assoc_list[A,B] = List::list[(A,B)];
}

@#------------- Lexer -------------------
// This module provides functions to 
// use in conjunction with the reglex construction
module Lexer
{
  pod type iterator = "char const*";
  fun start_iterator : lvalue[string] -> iterator = "$1.data()";
  fun end_iterator: lvalue[string] -> iterator = "$1.data()+$1.size()";
  fun bounds (x:lvalue[string]): iterator * iterator = {
    return 
      start_iterator x,
      end_iterator x
    ;
  }
  fun string_between: iterator * iterator -> string =
   "std::string($1,$2)";

  gen_cmp iterator;

  fun add: iterator * int -> iterator = "$1 + $2";
  fun sub: iterator * int -> iterator = "$1 - $2";
  fun sub: iterator * iterator -> int = "$1 - $2";
  proc pre_incr: lvalue[iterator] = "++$1;";
  proc post_incr: lvalue[iterator] = "++$1;";
  fun deref: iterator -> char = "*$1";

}

// ------ Open common modules -------------
open Bool;
open Int;
open Double;
open Char;
open String;
open Stdout;
open Arith_casts;
open Control;

@head(1,'Stl library')
@h=tangler('lib/stl.flx','data')
@select(h)
#include "flx_categories.flx"

include "std";
header std_stl_vector = "#include <vector>";
header std_stl_list = "#include <list>";
header std_stl_deque = "#include <deque>";
header std_stl_queue = "#include <queue>";
header std_stl_set = "#include <set>";
header std_stl_map = "#include <map>";
header std_stl_stack = "#include <stack>";
@if HAVE_STL_GNU_CXX:
  tangle('header ext_hash_set = "#include <ext/hash_set>";')
  tangle('header ext_hash_map = "#include <ext/hash_map>";')
  tangle('header ext_slist = "#include <ext/slist>";')

// hash for std::string for use with hash containers
header ext_string_hash = """
  namespace __gnu_cxx {
    template<> struct hash<std::string> { 
      size_t operator()(std::string const& s)const;
    };
  }
""";

body ext_string_hash = """
// this is a sick hash .. fix it!
size_t __gnu_cxx::hash<std::string>::
  operator()(std::string const& s)const {
    char const *p = s.data();
    int n = s.size();
    int h = 0;
    for(; n; --n,++p) h+= 5 * *p;
    return h;
  }
""";

@#------------- STL CONTAINERS -----------------------
@def gen_pcmp(t):
  tangle('    gen_cmp '+t+';') 

@def gen_peq(t):
  tangle('    gen_eq '+t+';')

@def mkseq(n,ns='std'):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'

  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1>";')
  tangle('    fun create : unit -> '+c+' = "(GXX_PARSER_HACK '+ns+'::'+n+'<?1>())";')
  tangle('    fun create : int * t -> '+c+'= "(GXX_PARSER_HACK '+ns+'::'+n+'<?1>($1,$2))";')
  tangle('    fun create[i] : i * i -> '+c+' = "(GXX_PARSER_HACK '+ns+'::'+n+'<?1>($1,$2))";')
  gen_pcmp(c)
  tangle('    fun len: '+c+' -> int = "$1.size()";')
  tangle('    fun empty: '+c+' -> int = "$1.empty()";')

  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1>::iterator";');
  gen_pcmp(it)

  tangle('    gen_forward '+it+';')
  tangle('    fun deref : '+it+' ->  lvalue[t]  = "*$1";')

  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    proc erase : '+c+' * '+it+' = "$1.erase($1);";')
  tangle('    proc erase : '+c+' * '+it+' * '+it+' = "$1.erase($1,$2);";')
  tangle('    proc clear : '+c+' = "$1.clear();";')

  tangle('    proc pre_incr : lvalue['+it+'] = "++$1;";')
  tangle('    proc post_incr : '+it+' = "++$1;";')
  tangle('    proc pre_decr : lvalue['+it+'] = "--$1;";')
  tangle('    proc post_decr : '+it+' = "--$1;";')

@def mkrseq(n,ns='std'):
  mkseq(n,ns)
  c = 'stl_'+n+'[t]'
  rit = 'stl_'+n+'_reverse_iterator[t]'
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1>::reverse_iterator";');
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')
  tangle('    fun deref : '+rit+' ->  lvalue[t]  = "*$1";')
  gen_pcmp(rit)
  tangle('    proc pre_incr : lvalue['+rit+'] = "++$1;";')
  tangle('    proc post_incr : '+rit+' = "++$1;";')
  tangle('    proc pre_decr: lvalue['+rit+'] = "--$1;";')
  tangle('    proc post_decr : '+rit+' = "--$1;";')



@def mkinsat(n):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'
  tangle('    proc insert: '+c+' * '+it+' *  t  = "$1.insert($2,$3);";')

@def mkpuf(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc push_front : '+c+' *  t  = "$1.push_front($2);";')

@def mkpub(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc push_back : '+c+' *  t  = "$1.push_back($2);";')

@def mkpof(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc pop_front : '+c+' = "$1.pop_back();";')

@def mkpob(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc pop_back : '+c+' = "$1.pop_back();";')

@def mkfront(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun front : '+c+' -> t = "$1.front()";')

@def mkback(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun front : '+c+' -> t = "$1.front()";')

@def mksub(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun subscript : lvalue['+c+'] * int -> lvalue[t] = "$1.at($2)";')
  tangle('    fun subscript : '+c+' * int -> t = "$1.at($2)";')

@def mkset(n,ns='std'):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'
  rit = 'stl_'+n+'_reverse_iterator[t]'
  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1>";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1>::iterator";')
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1>::reverse_iterator";')
  tangle('    fun create : unit -> '+c+' = "(GXX_PARSER_HACK '+ns+'::'+n+'<?1>())";')
  tangle('    gen_cmp '+c+';')
  tangle('    fun len: '+c+'->int = "$1.size()";')
  tangle('    fun empty: '+c+'->int = "$1.empty()";')
  tangle('    gen_cmp '+it+';')
  tangle('    gen_cmp '+rit+';')
  tangle('    proc pre_incr : lvalue['+it+'] = "++$1;";')
  tangle('    proc post_incr : '+it+' = "++$1;";')
  tangle('    proc pre_incr : lvalue['+rit+'] = "++$1;";')
  tangle('    proc post_incr : '+rit+' = "++$1;";')
  tangle('    proc pre_decr : lvalue['+it+'] = "--$1;";')
  tangle('    proc post_decr : '+it+' = "--$1;";')
  tangle('    proc pre_decr: lvalue['+rit+'] = "--$1;";')
  tangle('    proc post_decr : '+rit+' = "--$1;";')
  tangle('    fun deref : '+it+' ->  t  = "*(#0*)&*$1:unary" is unary;')
  tangle('    fun deref : '+rit+' ->  t  = "*(#0*)&*$1:unary" is unary;')

  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')

  tangle('    proc insert : '+c+' * t = "$1.insert($2);";')
  tangle('    proc erase : '+c+' * '+it+' = "$1.erase($1);";')
  tangle('    proc clear : '+c+' = "$1.clear();";')
  tangle('    fun find : '+c+' * t ->  '+it+' = "$1.find($2)";')
  tangle('    fun mem : '+c+' * t -> bool = "$1.find($2) != $1.end()";')

@def mkass(n,ns='std'):
  c = 'stl_'+n+'[k,v]'
  it = 'stl_'+n+'_iterator[k,v]'
  rit = 'stl_'+n+'_reverse_iterator[k,v]'
  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1,?2>";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1,?2>::iterator";')
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1,?2>::reverse_iterator";')

  tangle('    fun create : unit -> '+c+' = "(GXX_PARSER_HACK '+ns+'::'+n+'<?1,?2>())";')
  tangle('    gen_cmp '+c+';')
  tangle('    fun len: '+c+'->int = "$1.size()";')
  tangle('    fun empty: '+c+'->int = "$1.empty()";')
  tangle('    gen_cmp '+it+';')
  tangle('    gen_cmp '+rit+';')
  tangle('    proc pre_incr : '+it+' = "++$1;";')
  tangle('    proc post_incr : '+it+' = "++$1;";')
  tangle('    proc pre_incr : '+rit+' = "++$1;";')
  tangle('    proc post_incr : '+rit+' = "++$1;";')
  tangle('    proc pre_decr : '+it+' = "--$1;";')
  tangle('    proc post_decr : '+it+' = "--$1;";')
  tangle('    proc pre_decr : '+rit+' = "--$1;";')
  tangle('    proc post_decr : '+rit+' = "--$1;";')
  tangle('    fun deref : '+it+' ->  k * lvalue[v]  = "*(#0*)&*$1:unary" is unary;')
  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    fun deref : '+rit+' ->  k * lvalue[v]  = "*(#0*)&*$1:unary" is unary;')
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')
  tangle('    proc insert : '+c+' * k * v = "$1.insert(std::make_pair($2,$3));";')
  tangle('    proc erase : '+c+' * '+it+' = "$1.erase($1);";')
  tangle('    proc clear : '+c+' = "$1.clear();";')
  tangle('    fun find : '+c+' * k ->  '+it+' = "$1.find($2)";')
  tangle('    fun mem : '+c+' * k -> bool = "$1.find($2) != $1.end()";')
   
  tangle('    fun subscript: '+c+' * k -> lvalue[v] = "$1[$2]";')

module Stl 
{
  type pair[k,v] = "std::pair<?1 const,?2>";
  fun make_pair[k,v]: k * v ->pair[k,v] = "std::make_pair($1,$2)";

  module Vector[t]
  {
    requires std_stl_vector;
@mkrseq('vector')
@mkinsat('vector')
@mkpub('vector')
@mkfront('vector')
@mkback('vector')
@mksub('vector')
    fun add: stl_vector_iterator[t] * int -> stl_vector_iterator[t] = "$1+$2";
    fun sub: stl_vector_iterator[t] * int -> stl_vector_iterator[t] = "$1-$2";
    proc pluseq: lvalue[stl_vector_iterator[t]] * int = "$1+=$2;";
    proc minuseq: lvalue[stl_vector_iterator[t]] * int -> stl_vector_iterator[t] = "$1-=$2;";
    fun subscript: stl_vector_iterator[t] * int -> lvalue[t] = "$1[$2]";
  }
  module List[t]
  {
    requires std_stl_list;
@mkrseq('list')
@mkinsat('list')
@mkpuf('list')
@mkpub('list')
@mkfront('list')
@mkback('list')
@mkpof('list')
  }
  module Queue[t]
  {
    requires std_stl_queue;
@mkseq('queue')
@mkinsat('queue')
  }
  module Deque[t]
  {
    requires std_stl_deque;
@mkrseq('deque')
@mkinsat('deque')
@mkpuf('deque')
@mkpub('deque')
@mkpof('deque')
@mkfront('deque')
@mkback('deque')
@mksub('deque')
  }
  module PriorityQueue[t]
  {
    requires std_stl_queue;
@mkseq('priorityqueue')
  }
  module Stack[t]
  {
    requires std_stl_stack;
@mkseq('stack')
  }

  module Set[t]
  {
    requires std_stl_set;
@mkset('set')
  }
  module MultiSet[t]
  {
    requires std_stl_set;
@mkset('multiset')
  }
  module Map[k,v]
  {
    requires std_stl_map;
@mkass('map')
  }
  module MultiMap[k,v]
  {
    requires std_stl_map;
@mkass('multimap')
  }

@if HAVE_STL_GNU_CXX:
  tangle('  module Slist[t]')
  tangle('  {')
  tangle('    requires ext_slist;')
  mkseq('slist','__gnu_cxx')
  mkpuf('slist')
  mkfront('slist')
  mkpof('slist')
  tangle('    proc insert_after : stl_slist[t] * stl_slist_iterator[t] *  t  = "$1.insert_after($2,$3);";')
  tangle('    proc erase_after : stl_slist[t] * stl_slist_iterator[t] = "$1.erase_after($1);";')
  tangle('  }')

@if HAVE_STL_GNU_CXX:
  tangle('// HASHTABLE based containers assume')
  tangle('// these classes will be added to C++ via TR1 in the future.')
  tangle('// g++ 3.2.2 at least has these classes')
  tangle('// The free SGI implementation may suffice as a replacement,')
  tangle('// this is what my version of g++ uses.')
  tangle('')
  tangle('  module HashSet[t]')
  tangle('  {')
  tangle('    requires ext_hash_set;')
  mkset('hash_set','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMultiSet[t]')
  tangle('  {')
  tangle('    requires ext_hash_set;')
  mkseq('hash_multiset','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMap[k,v]')
  tangle('  {')
  tangle('    requires ext_hash_map;')
  mkass('hash_map','__gnu_cxx')    
  tangle('  }')
  tangle('  module HashMultiMap[k,v]')
  tangle('  {')
  tangle('    requires ext_hash_map;')
  mkass('hash_multimap','__gnu_cxx')    
  tangle('  }')
}
