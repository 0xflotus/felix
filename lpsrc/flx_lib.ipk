@head(1,'Felix Standard Library')
@h=tangler('lib/std.flx')
@select(h)
header """
#include <stddef.h>
#include <cmath>
#include <iostream>
#include <string>
#include <assert.h>
#include <limits.h>

// this header is stolen from boost
#include <rtl/boost_cstdint.hpp>

using namespace std;

namespace std_flx {
  inline string mul(string s, int n) {
    string r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  inline string substr(string const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }
}
""";

// NOTE: typedefs for all types with literals
// are provided at the top level so that the compiler
// can find them: it would be even uglier to bind
// the module names into the compiler.

@tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",
  "uchar"   : "int32_t", # Unicode/ISO10646, note: SIGNED!

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",
  "vlong"   : "long long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",
  "uvlong"  : "unsigned long long",

  #exact integers
  "int8"    : "boost::int8_t",
  "int16"   : "boost::int16_t",
  "int32"   : "boost::int32_t",
  "int64"   : "boost::int64_t",
  "uint8"   : "boost::uint8_t",
  "uint16"  : "boost::uint16_t",
  "uint32"  : "boost::uint32_t",
  "uint64"  : "boost::uint64_t",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double",
  }

@chars = ["char", "wchar", "uchar"]
@sints = [
  "tiny", "short", "int", "long", "vlong",
  "int8","int16","int32","int64"
  ]
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double", "ldouble"]

@all = ["byte", "size","address","offset"] + chars + sints + uints + floats
@ints = uints + sints

@def gen_type(t):
  tangle('type '+t+' = "'+tmap[t]+'";')

//@for t in all:
//  gen_type(t)

@def gen_asgn(t):
  tangle('  proc set: &'+t+' * '+t+' = "*$1=$2;";')
  tangle('  fun eq: '+t+' * '+t+' -> bool = code "$1==$2";')
  tangle('  fun ne: '+t+' * '+t+' -> bool = code "$1!=$2";')

@def gen_cmp(t):
  for opname,op in [
    ("lt","<"),
    ("le","<="),
    ("gt",">"),
    ("ge",">=")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> bool = code "int($1'+op+'$2)";')


typedef void = 0;
typedef unit = 1;
typedef any = any;

module Bool 
{
// NOTE!!!! if ANY bad naughty functions generate
// a boolean result which is other than 0 or 1 we have
// a catastrophy
  typedef bool = 2;


  val false : bool = case 1 of 2;
  val true : bool = case 2 of 2;

  fun land: bool * bool -> bool = code "$1 && $2";
  fun nand: bool * bool -> bool = code "!($1 && $2)";
  fun lor: bool * bool -> bool = code "$1 || $2";
  fun nor: bool * bool -> bool = code "!($1 || $2)";
  fun xor: bool * bool -> bool = code "$1 != $2";
  fun lnot: bool -> bool = code "!$1";
  proc assert: bool = "assert($1);";
  proc print: bool = 'std::cout << ($1?"true":"false");';
}

@def gen_arith(t):
  for opname,op in [
    ("add","+"),
    ("sub","-"),
    ("mul","*"),
    ("div","/")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = code "$1'+op+'$2";')

@def gen_mod(t):
  for opname,op in [
    ("mod","%")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = code "$1'+op+'$2";')

@def gen_neg(t):
  tangle('  fun neg: '+t+' -> '+t+' = code "-$1";')
  tangle('  fun pos: '+t+' -> '+t+' = code "+$1";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = code "'+op+fc[t]+'($1, $2)";')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = code "'+op+fc[t]+'($1)";')

@def gen_nan(t):
  tangle('  fun isnan: '+t+' -> bool = code "isnan'+fc[t]+'($1)";')

@def gen_inc(t):
  tangle('  proc pre_incr:  &'+t+' = "++*$1;";')
  tangle('  proc pre_decr:  &'+t+' = "--*$1;";')
  tangle('  proc post_incr: &'+t+' = "++*$1;";')
  tangle('  proc post_decr: &'+t+' = "--*$1;";')
  
@#------------- INTEGER MODULES -------------------
@for t in ints:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_type(t)
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_mod(t)
  gen_neg(t)
  gen_inc(t)
  if t == "tiny":
    tangle('  proc print: tiny = "std::cout << (int)$1;";')
  elif t == "utiny":
    tangle('  proc print: utiny = "std::cout << (unsigned int)$1;";')
  else:
    tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_type(t)
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_neg(t)
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
module Char 
{
@gen_type("char")
  open Int;
  fun ord: char -> int = code "(int)$1";
  fun chr: int -> char = code "(char)$1";
  proc print: char = "std::cout<<$1;";
}

module Wchar
{
@gen_type("wchar")
  open Long;
  fun ord: wchar -> long = code "(long)$1";
  fun wchr: long -> wchar = code "(wchar_t)$1";
  proc print: wchar = "std::cout<<$1;";
}

module Unicode
{
@gen_type("uchar")
  open Int32;
  fun ord: uchar -> int32 = code "$1";
  fun uchr: int32 -> uchar = code "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;";
}


@#------------- STDOUT UTILITY -------------------
module Stdout 
{
  proc endl: unit = "std::cout << endl;";
  proc space: int = "std::cout << ' ';";
}

@#------------- STRING MODULES -------------------
module String
{
  type string = "std::string";
  open Bool;
  open Char;
  open Int;
  proc set: &string * string = "$1->assign($1);";
  proc pluseq: &string * string = "$1->append($2);";

  fun len: string -> int = code "$1.size()";
  fun add: string * string -> string = code "$1+$2";
  fun mul: string * int -> string = code "std_flx::mul($1,$2)";
  fun mul: char * int -> string = code "string($2,$1)";

  fun subscript: string * int -> char = 
    code "$1[$2<0?$1.size()+$2:$2]";
  fun copyfrom: string * int -> string = 
    code "std_flx::substr($1,$2,$1.size())";
  fun copyto: string * int -> string = 
    code "std_flx::substr($1,0,$2)";
  fun substring: string * int * int -> string = 
    code "std_flx::substr($1,$2,$3)";

  // comparisons
  fun eq: string * string -> bool = code "$1==$2";
  fun ne: string * string -> bool = code "$1!=$2";
  fun lt: string * string -> bool = code "$1<$2";
  fun le: string * string -> bool = code "$1<=$2";
  fun gt: string * string -> bool = code "$1>$2";
  fun ge: string * string -> bool = code "$1>=$2";

  proc print: string = "std::cout << $1;";
}

module Arith_casts
{
@for t in ints+floats:
  tangle('  open ' + string.capitalize(t) + ';')
@for t1 in ints+floats:
  for t2 in ints+floats:
    tangle('  fun '+t1+'_of: '+t2+' -> '+t1+' = code "('+tmap[t1]+')$1";')
}

@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  // infinite loop
  proc loop (body:unit->void)
  {
    repeat:>
      body();
      goto repeat;
    unreachable:> /* pretend this point is reachable */
  }

  // C style while loop
  proc while (cond:unit->bool) (body:unit->void)
  {
    repeat:>
      if not (cond()) goto finish; 
      body();
      goto repeat;
    finish:>
  }

  // C style while loop with reversed condition
  // not the until is tested first -- zero iterations are possible
  proc until(cond:unit->bool) (body:unit->void)
  {
    repeat:>
      if cond() goto finish;
      body();
      goto repeat;
    finish:>
  }

  // do nothing [the name pass comes from Python]
  proc pass(){}

  // C style for loop
  proc for 
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (body:unit->void)
  {
    init();
    repeat:>
      if not (cond()) goto finish; 
      body();
      incr();
      goto repeat;
    finish:>
  }
}

// ------ Open common modules -------------
open Bool;
open Int;
open Double;
open Char;
open String;
open Stdout;
open Arith_casts;
open Control;


