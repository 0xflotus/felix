@head(1,'Felix Standard Library')
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::rtl::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::rtl::strutil","Python style substring support")
@table_row("rtl/flx_ioutil","C++","flx::rtl::ioutil","Standard IO support")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()

@select(tangler('rtl/flx_i18n.hpp'))
#ifndef FLX_I18N
#define FLX_I18N
#include <string>
namespace flx { namespace rtl { namespace i18n {
   std::string utf8(unsigned long);
}}}
#endif

@select(tangler('rtl/flx_i18n.cpp'))
#include "rtl/flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}


@h=tangler('rtl/flx_ioutil.hpp')
@select(h)
#ifndef FLX_IOUTIL
#define FLX_IOUTIL
#include <string>
namespace flx { namespace rtl { namespace ioutil {
  std::string load_file (std::string);
}}}
#endif

@h=tangler('rtl/flx_ioutil.cpp')
@select(h)
#include <cstdio>
#include <string>
#include "rtl/flx_ioutil.hpp"
namespace flx { namespace rtl { namespace ioutil {
  using namespace std;
  string load_file (string f)
  {
    char const *fname = f.data();
    FILE *fi = fopen(fname,"rt");
    if (fi)
    {
      string x = "";
      char buffer[512];
      int n;
      while (fgets(buffer,512,fi))
      {
        x = x + string(buffer);
      }
      fclose(fi);
      return x;
    }
    else return "";
  }
}}}

@h=tangler('rtl/flx_strutil.cpp')
@select(h)
#include <string>
namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }
}}}

@h=tangler('lib/std.flx','data')
@# use data tangler to prevent line number generation
@select(h)
header """
#include <cstdio>
#include <cstddef>
#include <cmath>
#include <iostream>
#include <string>
#include <cassert>
#include <climits>
#include "rtl/boost_cstdint.hpp"
#include "rtl/flx_i18n.hpp"
#include "rtl/flx_ioutil.hpp"
#include "rtl/flx_strutil.cpp"
using namespace std;
""";

@tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",
  "uchar"   : "int32_t", # Unicode/ISO10646, note: SIGNED!

  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",
  "vlong"   : "long long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",
  "uvlong"  : "unsigned long long",

  #exact integers
  "int8"    : "boost::int8_t",
  "int16"   : "boost::int16_t",
  "int32"   : "boost::int32_t",
  "int64"   : "boost::int64_t",
  "uint8"   : "boost::uint8_t",
  "uint16"  : "boost::uint16_t",
  "uint32"  : "boost::uint32_t",
  "uint64"  : "boost::uint64_t",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double",
  }

@chars = ["char", "wchar", "uchar"]
@sints = [
  "tiny", "short", "int", "long", "vlong",
  "int8","int16","int32","int64"
  ]
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double", "ldouble"]

// @all = ["byte", "size","address","offset","bool"] + chars + sints + uints + floats
@all = ["byte", "size","address","offset"] + chars + sints + uints + floats
@ints = uints + sints

@def gen_type(t):
  tangle('type '+t+' = "'+tmap[t]+'";')

@for t in all:
  gen_type(t)

@def gen_asgn(t):
  #tangle('  proc _set: &'+t+' * '+t+' = "*('+tmap[t]+'*)($1.data)=$2;";')
  tangle('  proc swap: &'+t+' * &'+t+' ="""')
  tangle('  {')
  tangle('    '+ tmap[t] + ' tmp=*('+tmap[t]+'*)($1.data);')
  tangle('    *('+tmap[t]+'*)($1.data)=*('+tmap[t]+'*)($2.data);')
  tangle('    *('+tmap[t]+'*)($2.data)=tmp;')
  tangle('  }""";')
  tangle('  fun eq: '+t+' * '+t+' -> bool = "$1==$2";')
  tangle('  fun ne: '+t+' * '+t+' -> bool = "$1!=$2";')

@def gen_cmp(t):
  for opname,op in [
    ("lt","<"),
    ("le","<="),
    ("gt",">"),
    ("ge",">=")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> bool = "int($1'+op+'$2)";')


// !!!!! NEW DEFINITION OF BOOL !!!!!
typedef void = 0;
typedef unit = 1;
typedef bool = 2;
typedef any = any;

module Bool 
{

  val false : bool = case 1 of 2; // binary 0
  val true : bool = case 2 of 2; // binary 1

  fun land: bool * bool -> bool = "$1 && $2";
  fun nand: bool * bool -> bool = "!($1 && $2)";
  fun lor: bool * bool -> bool = "$1 || $2";
  fun nor: bool * bool -> bool = "!($1 || $2)";
  fun xor: bool * bool -> bool = "$1 != $2";
  fun lnot: bool -> bool = "!$1";
  proc assert: bool = "assert($1);";
  proc print: bool = 'std::cout << ($1??"true":"false");';
}

@def gen_arith(t):
  for opname,op in [
    ("add","+"),
    ("sub","-"),
    ("mul","*"),
    ("div","/")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_uint(t):
  for opname,op in [
    ("caret","^"),
    ("vbar","|"),
    ("amper","&"),
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')
  tangle('  fun bnot: '+t+' -> '+t+' = "~$1";')


@def gen_arith_assign(t):
  for opname,op in [
    ("pluseq","+="),
    ("minuseq","-="),
    ("muleq","*="),
    ("diveq","/=")
  ]:
    tangle('  proc '+opname+': &'+t+' * '+t+' = "*('+tmap[t]+'*)($1.data)'+op+'$2;";')

@def gen_uint_assign(t):
  for opname,op in [
    ("careteq","^="),
    ("vbareq","|="),
    ("ampereq","&=")
  ]:
    tangle('  proc '+opname+': &'+t+' * '+t+' = "*('+tmap[t]+'*)($1.data)'+op+'$2;";')

@def gen_mod(t):
  for opname,op in [
    ("mod","%")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_neg(t):
  tangle('  fun neg: '+t+' -> '+t+' = "-$1";')
  tangle('  fun pos: '+t+' -> '+t+' = "+$1";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)";')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)";')

@def gen_nan(t):
  tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)";')

@def gen_inc(t):
  tangle('  proc pre_incr:  &'+t+' = "++*('+tmap[t]+'*)($1.data);";')
  tangle('  proc pre_decr:  &'+t+' = "--*('+tmap[t]+'*)($1.data);";')
  tangle('  proc post_incr: &'+t+' = "++*('+tmap[t]+'*)($1.data);";')
  tangle('  proc post_decr: &'+t+' = "--*('+tmap[t]+'*)($1.data);";')
  
@#------------- TYPING ---------------------------
module Typing
{
  typedef fun dom(t:TYPE):TYPE = 
    typematch t with
    | ?a -> _ => a
    endmatch
  ;

  typedef fun cod(t:TYPE):TYPE = 
    typematch t with
    | _ -> ?b => b
    endmatch
  ;

}

@#------------- INTEGER MODULES -------------------
type string = "std::string";
@for t in ints:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  if t in uints: gen_uint(t)
  gen_arith_assign(t)
  if t in uints: gen_uint_assign(t)
  gen_mod(t)
  gen_neg(t)
  gen_inc(t)
  if t == "tiny":
    tangle('  proc print: tiny = "std::cout << (int)$1;";')
  elif t == "utiny":
    tangle('  proc print: utiny = "std::cout << (unsigned int)$1;";')
  else:
    tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_arith_assign(t)
  gen_neg(t)
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc print: '+t+' = "std::cout<<$1;";')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun chr: int -> char = "(char)$1";
  proc print: char = "std::cout<<$1;";
}

module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun wchr: long -> wchar = "(wchar_t)$1";
  proc print: wchar = "std::cout<<$1;";
}

module Unicode
{
  open Uint32;
  fun ord: uchar -> uint32 ="$1";
  fun uchr: uint32 -> uchar = "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;";
}


@#------------- STDOUT UTILITY -------------------
module Stdout 
{
  proc endl: unit = "std::cout << endl;";
  proc space: int = "std::cout << ' ';";
}
macro proc print_line (x) { print x; Stdout::endl; }

@#------------- STRING MODULES -------------------
module String
{
  open Bool;
  open Char;
  open Int;
@#  proc _set: &string * string = "((string*)($1.data))->assign($2);";
  proc pluseq: &string * string = "((string*)($1.data))->append($2);";

  fun len: string -> int = "$1.size()";
  fun add: string * string -> string = "$1+$2";
  fun add: string * int -> string = "$1+flx::rtl::i18n::utf8($2)";
  fun mul: string * int -> string = "flx::rtl::strutil::mul($1,$2)";
  fun mul: char * int -> string = "string($2,$1)";

  fun subscript: string * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: string * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$1.size())";
  fun copyto: string * int -> string = 
    "flx::rtl::strutil::substr($1,0,$2)";
  fun substring: string * int * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$3)";

  // comparisons
  fun eq: string * string -> bool = "$1==$2";
  fun ne: string * string -> bool = "$1!=$2";
  fun lt: string * string -> bool = "$1<$2";
  fun le: string * string -> bool = "$1<=$2";
  fun gt: string * string -> bool = "$1>$2";
  fun ge: string * string -> bool = "$1>=$2";

  proc print: string = "std::cout << $1;";
}

type ustring = "basic_string<uint32_t>";
module Ustring
{
  open Bool;
  open Char;
  open Int;
@#  proc _set: &ustring * ustring = "(basic_string<uint32_t>*)($1.data)->assign($1);";
  proc pluseq: &ustring * ustring = "(basic_string<uint32_t>*)($1.data)->append($2);";

  fun len: ustring -> int = "$1.size()";
  fun add: ustring * ustring -> ustring = "$1+$2";
  fun mul: ustring * int -> ustring = "flx::lib::mul($1,$2)";
  fun mul: char * int -> ustring = "ustring($2,$1)";

  fun subscript: ustring * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$1.size())";
  fun copyto: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,0,$2)";
  fun subustring: ustring * int * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$3)";

  // comparisons
  fun eq: ustring * ustring -> bool = "$1==$2";
  fun ne: ustring * ustring -> bool = "$1!=$2";
  fun lt: ustring * ustring -> bool = "$1<$2";
  fun le: ustring * ustring -> bool = "$1<=$2";
  fun gt: ustring * ustring -> bool = "$1>$2";
  fun ge: ustring * ustring -> bool = "$1>=$2";

  proc print: ustring = "std::cout << $1;";
}

module Arith_casts
{
@for t1 in ints+floats:
  for t2 in ints+floats:
    tangle('  fun '+t1+'_of: '+t2+' -> '+t1+' = "('+tmap[t1]+')$1";')
}

@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  // infinite loop
  proc forever (bdy:unit->void)
  {
    repeat:>
      bdy();
      goto repeat;
    dummy:> // fool reachability checker
  }

  // C style while loop
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if not (cond()) goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  // C style while loop with reversed condition
  // not the until is tested first -- zero iterations are possible
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if cond() goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  // do nothing [the name pass comes from Python]
  proc pass(){}

  // C style for loop
  proc for 
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    repeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto repeat;
    finish:>
  }

  proc fail:string = 'throw std::exception ($1);';
  fun fail_fun[t]:1->t = 'throw std::exception (""),*(?1*)0';
  fun fail_fun[t]:string->t = 'throw std::exception ($1),*(?1*)0';
}

@#------------- List -------------------
module List
{
  union list[T] = | Empty | Cons of T * list[T];

  fun map[T,U] (f:T->U) (x:list[T]): list[U] = {
    return
      match x with
      | Empty => Empty[U]
      | Cons (?h, ?t) => Cons (f(h), map f t)
      endmatch
    ;
  }

  fun rev[T] (x:list[T]):list[T]= {
    fun aux (x:list[T]) (y:list[T]) : list[T] =
    {
      return 
        match x with
        | Empty => y
        | Cons (?h, ?t) => aux t (Cons (h, y))
        endmatch
      ;
    }
    return aux x Empty[T];
  }

  proc iter[T] (f:T->void) (x:list[T]) {
    match x with
    | Empty => {} 
    | Cons (?h,?t) => { f h; iter f t; }
    endmatch
    ;
  }

  fun fold_left[T,U] (f:U->T->U) (init:U) (x:list[T]):U =
  {
    return
      match x with
      | Empty => init
      | Cons (?h,?t) => fold_left f (f init h) t
      endmatch
    ;
  }

  fun fold_right[T,U] (f:T->U->U) (x:list[T]) (init:U):U =
  {
    return
      match x with
      | Empty => init
      | Cons (?h,?t) => fold_right f t (f h init)
      endmatch
    ;
  }
  
  fun join[T] (x:list[T]) (y:list[T]):list[T] = 
  {
    return
      match x with
      | Empty => y
      | Cons (?h,?t) => Cons (h, join t y)
      endmatch
    ;
  }

  fun cat[T] (x:list[list[T]]):list[T] =
  {
     return 
       match x with
       | Empty => Empty[T]
       | Cons (?h,?t) => fold_left join of (list[T]) h t
       endmatch
     ;
   }
}

module Assoc_list
{
  typedef assoc_list[A,B] = List::list[(A,B)];
}

@#------------- Text I/O -------------------
module Text_file
{
  fun load: string -> string = "flx::rtl::ioutil::load_file($1)";
}

@#------------- Lexer -------------------
// This module provides functions to 
// use in conjunction with the reglex construction
module Lexer
{
  type iterator = "char const*";
  fun start_iterator : string -> iterator = "$1.data()";
  fun end_iterator: string -> iterator = "$1.data()+$1.size()";
  fun string_between: iterator * iterator -> string =
   "std::string($1,$2)";

  fun eq:iterator * iterator -> bool = "$1==$2";
  fun ne:iterator * iterator -> bool = "$1!=$2";
  fun lt:iterator * iterator -> bool = "$1<$2";
  fun le:iterator * iterator -> bool = "$1<=$2";
  fun ge:iterator * iterator -> bool = "$1>=$2";
  fun gt:iterator * iterator -> bool = "$1>$2";

  fun add: iterator * int -> iterator = "$1 + $2";
  fun sub: iterator * int -> iterator = "$1 - $2";
  fun sub: iterator * iterator -> int = "$1 - $2";
  proc incr: &iterator -> iterator = "++*$1.data;";

@#  proc _set: &iterator * iterator = "*(char const**)$1.data = $2;";
}

// ------ Open common modules -------------
open Bool;
open Int;
open Double;
open Char;
open String;
open Stdout;
open Arith_casts;
open Control;

@head(1,'Stl library')
@h=tangler('lib/stl.flx')
@select(h)
header '''
#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
''';
@#------------- STL CONTAINERS -----------------------
module Stl 
{
  module Vector
  {
    type stl_vector[t] = "std::vector<`1>";
    type stl_vector_iterator[t] = "std::vector<`1>::iterator";
    type stl_vector_const_iterator[t] = "std::vector<`1>::const_iterator";
  }
  module List
  {
    type stl_list[t] = "std::list<`1>";
    type stl_list_iterator[t] = "std::list<`1>::iterator";
    type stl_list_const_iterator[t] = "std::list<`1>::const_iterator";
  }
  module Set
  {
    type stl_set[t] = "std::set<`1>";
    type stl_set_iterator[t] = "std::set<`1>::iterator";
    type stl_set_const_iterator[t] = "std::set<`1>::const_iterator";
  }
  module MultiSet
  {
    type stl_multiset[t] = "std::multiset<`1>";
    type stl_multiset_iterator[t] = "std::multiset<`1>::iterator";
    type stl_multiset_const_iterator[t] = "std::multiset<`1>::const_iterator";
  }
  module Map
  {
    type stl_map[k,v] = "std::map<`1,`2>";
    type stl_map_iterator[t] = "std::map<`1>::iterator";
    type stl_map_const_iterator[t] = "std::map<`1>::const_iterator";
  }
  module MultiMap
  {
    type stl_multimap[k,v] = "std::multimap<`1,`2>";
    type stl_multimap_iterator[t] = "std::multimap<`1>::iterator";
    type stl_multimap_const_iterator[t] = "std::multimap<`1>::const_iterator";
  }
  module Queue
  {
    type queue[t] = "std::queue[`1]";
    type stl_queue_iterator[t] = "std::queue<`1>::iterator";
    type stl_queue_const_iterator[t] = "std::queue<`1>::const_iterator";
  }
  module Deque
  {
    type deque[t] = "std::deque[`1]";
    type stl_deque_iterator[t] = "std::deque<`1>::iterator";
    type stl_deque_const_iterator[t] = "std::deque<`1>::const_iterator";
  }
  module PriorityQueue 
  {
    type stl_priority_queue[t] = "std::priority_queue[`1]";
    type stl_priority_queue_iterator[t] = "std::priority_queue<`1>::iterator";
    type stl_priority_queue_const_iterator[t] = "std::priority_queue<`1>::const_iterator";
  }
  module Stack
  {
    type stl_stack[t] = "std::stack[`1]";
    type stl_stack_iterator[t] = "std::stack<`1>::iterator";
    type stl_stack_const_iterator[t] = "std::stack<`1>::const_iterator";
  }
}


