@head(1,'Felix Standard Library')
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::rtl::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::rtl::strutil","Python style substring support")
@table_row("rtl/flx_ioutil","C++","flx::rtl::ioutil","Standard IO support")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()

@select(tangler('rtl/flx_i18n.hpp'))
#ifndef FLX_I18N
#define FLX_I18N
#include <string>
namespace flx { namespace rtl { namespace i18n {
   std::string utf8(unsigned long);
}}}
#endif

@select(tangler('rtl/flx_i18n.cpp'))
#include "rtl/flx_i18n.hpp"
namespace flx { namespace rtl { namespace i18n {
  std::string utf8(unsigned long i) 
  {
    char s[6];
    if (i < 0x80UL ) 
    {
      s[0]= i;
      s[1]= 0;
    }
    else if (i < 0x800UL ) 
    {
      s[0]=0xC0u | (i >> 6ul)  & 0x1Fu;
      s[1]=0x80u | i           & 0x3Fu;
      s[2]=0;
    }
    else if (i < 0x10000UL ) 
    {
      s[0]=0xE0u | (i >> 12ul) & 0xFu;
      s[1]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[2]=0x80u | i           & 0x3F;
      s[3]=0;
    }
    else if (i < 0x200000UL ) 
    {
      s[0]=0xF0u | (i >> 18ul) & 0x7u;
      s[1]=0x80u | (i >> 12ul) & 0x3Fu;
      s[2]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[3]=0x80u | i           & 0x3F;
      s[4]=0;
    }
    else if (i < 0x4000000UL ) 
    {
      s[0]=0xF8u | (i >> 24ul) & 0x3u;
      s[1]=0x80u | (i >> 18ul) & 0x3Fu;
      s[2]=0x80u | (i >> 12ul) & 0x3Fu;
      s[3]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[4]=0x80u | i           & 0x3Fu;
      s[5]=0;
    }
    else 
    {
      s[0]=0xFCu | (i >> 30ul) & 0x1u;
      s[1]=0x80u | (i >> 24ul) & 0x3Fu;
      s[2]=0x80u | (i >> 18ul) & 0x3Fu;
      s[3]=0x80u | (i >> 12ul) & 0x3Fu;
      s[4]=0x80u | (i >> 6ul)  & 0x3Fu;
      s[5]=0x80u | i           & 0x3Fu;
      s[6]=0;
    }
    return s;
  }
}}}


@h=tangler('rtl/flx_ioutil.hpp')
@select(h)
#ifndef FLX_IOUTIL
#define FLX_IOUTIL
#include <string>
#include <cstdio>
namespace flx { namespace rtl { namespace ioutil {
  std::string load_file (std::string);
  std::string readln(std::FILE*);
}}}
#endif

@h=tangler('rtl/flx_ioutil.cpp')
@select(h)
#include <cstdio>
#include <string>
#include "rtl/flx_ioutil.hpp"
namespace flx { namespace rtl { namespace ioutil {
  using namespace std;
  string load_file (string f)
  {
    char const *fname = f.data();
    FILE *fi = fopen(fname,"rt");
    if (fi)
    {
      string x = "";
      char buffer[512];
      int n;
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  // includes newline if present
  // null string indicates end of file
  string readln (FILE *fi)
  {
    if(fi)
    {
      string x = "";
      char buffer[513];
      buffer[512]='\0';
      int n;
      while 
      ( 
        !(
          (n=x.size()) && 
          x[n-1]=='\n'
        ) 
        &&
        fgets(buffer,512,fi)
      )
        x = x + string(buffer);
      return x;
    }
    else return "";
  }
}}}

@h=tangler('rtl/flx_strutil.cpp')
@select(h)
#include <string>
namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }
}}}

@h=tangler('lib/std.flx','data')
@# use data tangler to prevent line number generation
@select(h)
header iostream "#include <iostream>";
header cmath """
#include <cmath>
@if HAVE_ISNANF_IN_IEEEFP:
  tangle("#include <ieeefp.h>")
""";

header """
#include <cstdio>
#include <cstddef>
#include <string>
#include <cassert>
#include <climits>
@if HAVE_STDINT:
  tangle("#include <stdint.h>")
#include "rtl/flx_i18n.hpp"
#include "rtl/flx_ioutil.hpp"
#include "rtl/flx_strutil.cpp"
using namespace std;
""";

header cstdlib "#include <cstdlib>";

@chars = ["char", "wchar", "uchar"]
@sints = [
  "tiny", "short", "int", "long", "vlong",
  "int8","int16","int32","int64"
  ]
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double", "ldouble"]
@complex = ["complex","dcomplex","lcomplex"]
@imaginary= ["imaginary", "dimaginary", "limaginary"]

@all = [
  "byte", "size","address","caddress","vaddress","cvaddress",
  "offset", "charp", "charcp"
  ] + chars + sints + uints + floats + complex + imaginary

@ints = uints + sints

@def gen_type(t):
  tangle('type '+t+' = "'+tmap[t]+'";')

@def gen_asgn(t):
  tangle('  proc swap: lvalue['+t+'] * lvalue['+t+'] ="""')
  tangle('  {')
  tangle('    '+ tmap[t] + ' tmp=$1;')
  tangle('    $1=$2;')
  tangle('    $2=tmp;')
  tangle('  }""";')
  tangle('  fun eq: '+t+' * '+t+' -> bool = "$1==$2";')
  tangle('  fun ne: '+t+' * '+t+' -> bool = "$1!=$2";')

@def gen_cmp(t):
  for opname,op in [
    ("lt","<"),
    ("le","<="),
    ("gt",">"),
    ("ge",">=")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> bool = "int($1'+op+'$2)";')


@for t in all:
  gen_type(t)

publish "Empty sum"
  typedef void = 0;

publish "Unit type"
  typedef unit = 1;

publish "Boolean"
  typedef bool = 2;

publish "Universal type 'x as x'"
  typedef any = any;

publish "Array type"
  typedef array[t,n] = t ^ n;

publish "Lvalue hack"
  typedef lvalue[t] = t;

publish "Array access: works on LHS of assignment too"
fun subscript[t,n]: array[t, n] * int -> t = "$1.data[$2]";

publish "Explicit array store function"
proc store[t,n]: &array[t,n] * int * t = "((?1*)($1.data))[$2]=$3;";

publish "Bool compatible with C"
module Bool 
{

  val false : bool = case 1 of 2; // binary 0
  val true : bool = case 2 of 2; // binary 1

  fun land: bool * bool -> bool = "$1 && $2";
  fun nand: bool * bool -> bool = "!($1 && $2)";
  fun lor: bool * bool -> bool = "$1 || $2";
  fun nor: bool * bool -> bool = "!($1 || $2)";
  fun xor: bool * bool -> bool = "$1 != $2";
  fun lnot: bool -> bool = "!$1";
  proc assert: bool = "assert($1);";
  proc print: bool = 'std::cout << ($1??"true":"false");' requires iostream;
}

@def gen_arith(t):
  for opname,op in [
    ("add","+"),
    ("sub","-"),
    ("mul","*"),
    ("div","/")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_uint(t):
  for opname,op in [
    ("caret","^"),
    ("vbar","|"),
    ("amper","&"),
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')
  tangle('  fun bnot: '+t+' -> '+t+' = "~$1";')


@def gen_arith_assign(t):
  for opname,op in [
    ("pluseq","+="),
    ("minuseq","-="),
    ("muleq","*="),
    ("diveq","/=")
  ]:
    tangle('  proc '+opname+': lvalue['+t+'] * '+t+' = "$1'+op+'$2;";')

@def gen_uint_assign(t):
  for opname,op in [
    ("careteq","^="),
    ("vbareq","|="),
    ("ampereq","&=")
  ]:
    tangle('  proc '+opname+': lvalue['+t+'] * '+t+' = "$1'+op+'$2;";')

@def gen_mod(t):
  for opname,op in [
    ("mod","%")
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

@def gen_neg(t):
  tangle('  fun neg: '+t+' -> '+t+' = "-$1";')
  tangle('  fun pos: '+t+' -> '+t+' = "+$1";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)" requires cmath;')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)" requires cmath;')

@def gen_nan(t):
  if HAVE_ISNAN_IN_CMATH:
    tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)" requires cmath;')
  elif HAVE_ISNANF_IN_IEEEFP:
    tangle('  fun isnan: '+t+' -> bool = "isnanf'+fc[t]+'($1)" requires cmath;')
  else:
    tangle('  fun isnan: '+t+' -> bool = "!($1==$1)" requires cmath;')

@def gen_inc(t):
  tangle('  proc pre_incr:  lvalue['+t+'] = "++$1;";')
  tangle('  proc pre_decr:  lvalue['+t+'] = "--$1;";')
  tangle('  proc post_incr: lvalue['+t+'] = "$1++;";')
  tangle('  proc post_decr: lvalue['+t+'] = "$1--;";')
  
@#------------- TYPING ---------------------------
module Typing
{
  typedef fun dom(t:TYPE):TYPE = 
    typematch t with
    | ?a -> _ => a
    endmatch
  ;

  typedef fun cod(t:TYPE):TYPE = 
    typematch t with
    | _ -> ?b => b
    endmatch
  ;

}
  
@#------------- CASTS and C HACKERY ---------------
publish """
This module provides access to raw C/C++ encodings.
Incorrect typing is likely to pass by Felix and
be trapped by the C/C++ compiler. Incorrect management
of storage can lead to corruption. The use of the
C_hack module is necessary for interfacing.
"""
module C_hack
{
  publish "C void"
  incomplete type void_t = "void";

  publish "standard variable argument list pointer type"
  type va_list = "va_list";

  publish """
  GCC specific valist thingo: it will
  be optimised away if not used (eg on MSVC)
  """
  type __builtin_va_list = '__builtin_va_list';

  publish """
  Throw away result of a function call:
  only useful for C functions that are mainly
  called for side effects.
  """
  proc ignore[t](x:t){ 
    code "";  // hack to prevent routine being optimised away
  }
  
  fun cast[dst,src]: src->dst = '(?1)$1';
  fun static_cast[dst,src]: src->dst = 'static_cast<?1>($1)';
  fun dynamic_cast[dst,src]: src->dst = 'dynamic_cast<?1>($1)';
  fun reinterpret_cast[dst,src]: src->dst = 'reinterpret_cast<?1>($1)';

  publish "Abstract type for C pointer"
  type ptr[t]="?1 *";

  publish "Abstract type for C pointer to const"
  type cptr[t]="?1 const *";

  publish "Convert pointer to pointer to const"
  fun enconst[t]: ptr[t]->cptr[t] = "(?1 const*)$1";

  publish """
  Unsafe function to get C pointer from Felix reference.
  The pointer may dangle if the collector deletes the 
  frame containing the object. 
  """
  fun unref[t]: &t->ptr[t] = "(?1*)($1.data)";

  publish """
  Function to make Felix reference from C pointer.
  This function is only safe if the C pointer
  was not allocated by the Felix collector:
  the resulting reference will never be collected
  (because the frame pointer is set to 0)
  """
  fun mkref[t]: ptr[t]->&t = "(#0 const&)flx::rtl::_ref_(0,(void*)$1)";

  publish """
  Dereference a C pointer. If the expression is an
  an lvalue, the result is an lvalue. Assignments
  to const lvalues are trapped by the C/C++ compiler.
  """
  fun deref[t]: ptr[t] -> t = "*$1";
  fun deref[t]: cptr[t] -> t = "*$1";

  publish """
  Function to take the address of a C lvalue,
  fails in C/C++ compiler if the argument isn't an lvalue.
  Addresses of Felix variables are safe to use provided the
  containing frame won't be collected. 
  Addresses of temporaries must not be taken.
  """
  fun addr[t]: t -> ptr[t] = "&$1";
  fun caddr[t]: t -> cptr[t] ="(?1 const*)&$1";
  
  publish """
  Polymorphic null pointer constant
  """
  const null_ptr[t]:ptr[t] = "(?1*)NULL";
  const null_cptr[t]:ptr[t] = "(?1 const*)NULL";

  publish """
  Unsafe output of hopefully null terminated C strings
  """
  proc print: charp = "std::cout << $1;" requires iostream;
  proc print: charcp = "std::cout << $1;" requires iostream;

  header dflt_h "template<class T> T dflt() { return T(); }";
  publish """
  Workaround for g++ 3.2.2 parsing bug,
  it can parse T() as a default ctor call,
  but screws up on (T())
  """
  fun dflt[t]:1->t = "dflt<?1>()" requires dflt_h;
}

publish "System Interface"
module System
{
  const argc:int = "pgf->argc";
  fun argv:int -> string = 'std::string($1<0||$1>=pgf->argc??"":pgf->argv[$1])';
@tangle('  const felix_version : string = \'std::string("'+flx_version+'")\';')
  fun system: string -> int = "std::system($1.data())"
    requires cstdlib;
}

@#------------- Environment -------------------
module Env
{
  fun getenv:string -> string = "std::string(std::getenv($1.data()))"
    requires cstdlib;
}

@#------------- Text I/O -------------------
module Text_file
{
  fun load: string -> string = "flx::rtl::ioutil::load_file($1)";

  type text_file = "FILE*"; // its a macro?

  fun fopen_input: string -> text_file = 'std::fopen($1.data(),"rt")';
  fun fopen_output: string -> text_file = 'std::fopen($1.data(),"wt")';
  proc fclose: text_file = '(void)std::fclose($1);';
  fun readln: text_file -> string ="flx::rtl::ioutil::readln($1)";

  const stdin: text_file = "stdin";
  const stdout: text_file = "stdout";
  const stderr: text_file = "stderr";
}


@#------------- INTEGER MODULES -------------------
type string = "std::string";
@for t in ints:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  if t in uints: gen_uint(t)
  gen_arith_assign(t)
  if t in uints: gen_uint_assign(t)
  gen_mod(t)
  gen_neg(t)
  gen_inc(t)
  if t == "tiny":
    tangle('  proc print: tiny = "std::cout << (int)$1;" requires iostream;')
  elif t == "utiny":
    tangle('  proc print: utiny = "std::cout << (unsigned int)$1;" requires iostream;')
  else:
    tangle('  proc print: '+t+' = "std::cout<<$1;" requires iostream;')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("module " + string.capitalize(t))
  tangle("{")
  gen_asgn(t)
  gen_cmp(t)
  gen_arith(t)
  gen_arith_assign(t)
  gen_neg(t)
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc print: '+t+' = "std::cout<<$1;" requires iostream;')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun chr: int -> char = "(char)$1";
  proc print: char = "std::cout<<$1;" requires iostream;
}

module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun wchr: long -> wchar = "(wchar_t)$1";
  proc print: wchar = "std::cout<<$1;" requires iostream;
}

module Unicode
{
  open Uint32;
  fun ord: uchar -> uint32 ="$1";
  fun uchr: uint32 -> uchar = "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;" requires iostream;
}


@#------------- STDOUT UTILITY -------------------
module Stdout 
{
  proc endl: unit = "std::cout << endl;" requires iostream;
  proc space: int = "std::cout << ' ';" requires iostream;
}
macro proc print_line (x) { print x; Stdout::endl; }

@#------------- STRING MODULES -------------------
module String
{
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[string] * string = "$1.append($2);";
  proc make_string: charp -> string = 'std::string($1)';
  proc make_string: charcp -> string =' std::string($1)';

  fun len: string -> int = "$1.size()";
  fun add: string * string -> string = "$1+$2";
  fun add: string * int -> string = "$1+flx::rtl::i18n::utf8($2)";
  fun mul: string * int -> string = "flx::rtl::strutil::mul($1,$2)";
  fun mul: char * int -> string = "std::string($2,$1)";

  fun subscript: string * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: string * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$1.size())";
  fun copyto: string * int -> string = 
    "flx::rtl::strutil::substr($1,0,$2)";
  fun substring: string * int * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$3)";

  // comparisons
  fun eq: string * string -> bool = "$1==$2";
  fun ne: string * string -> bool = "$1!=$2";
  fun lt: string * string -> bool = "$1<$2";
  fun le: string * string -> bool = "$1<=$2";
  fun gt: string * string -> bool = "$1>$2";
  fun ge: string * string -> bool = "$1>=$2";

  proc print: string = "std::cout << $1;" requires iostream;
  fun atoi: string -> int = "std::atoi($1.data())" requires cstdlib;

  publish "Unsafe extract buffer pointer"
  fun cstr: string -> C_hack::ptr[char] = "$1.data()";
}

type ustring = "basic_string<uint32_t>";
module Ustring
{
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[ustring] * ustring = "$1.append($2);";

  fun len: ustring -> int = "$1.size()";
  fun add: ustring * ustring -> ustring = "$1+$2";
  fun mul: ustring * int -> ustring = "flx::lib::mul($1,$2)";
  fun mul: char * int -> ustring = "ustring($2,$1)";

  fun subscript: ustring * int -> char = 
    "$1[$2<0??$1.size()+$2:$2]";
  fun copyfrom: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$1.size())";
  fun copyto: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,0,$2)";
  fun subustring: ustring * int * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$3)";

  // comparisons
  fun eq: ustring * ustring -> bool = "$1==$2";
  fun ne: ustring * ustring -> bool = "$1!=$2";
  fun lt: ustring * ustring -> bool = "$1<$2";
  fun le: ustring * ustring -> bool = "$1<=$2";
  fun gt: ustring * ustring -> bool = "$1>$2";
  fun ge: ustring * ustring -> bool = "$1>=$2";

  proc print: ustring = "std::cout << $1;" requires iostream;
}

publish """
All the arithmetic casts between standard C arithmetic types.
"""
module Arith_casts
{
@for t1 in ints+floats:
  for t2 in ints+floats:
    tangle('  fun '+t1+'_of: '+t2+' -> '+t1+' = "('+tmap[t1]+')$1";')
}

@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  publish 'infinite loop'
  proc forever (bdy:unit->void)
  {
    repeat:>
      bdy();
      goto repeat;
    dummy:> // fool reachability checker
  }

  publish 'C style while loop'
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if not (cond()) goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  publish """
  C style while loop with reversed condition
  note the until is tested first -- zero iterations are possible
  """
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeat:>
      if cond() goto finish;
      bdy();
      goto repeat;
    finish:>
  }

  publish "do nothing [the name pass comes from Python]"
  proc pass(){}

  publish 'C style for loop'
  proc for 
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    repeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto repeat;
    finish:>
  }

  publish 'abnormal termination with message'
  proc fail:string = 'throw std::exception ($1);';

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:1->t = 'throw std::exception (""),*(?1*)0';

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:string->t = 'throw std::exception ($1),*(?1*)0';

  publish "Felix procedural continuation type"
  type cont = "flx::rtl::con_t*";

  publish "Current continuation"
  fun current_continuation: 1 -> cont = "this";

  // BUGGED: doesn't pass argument
  private fun _start[t]: (t->0)*t->cont = "$1->clone()->call(0)";
  fun start[t] (p:t->0) (x:t) = { return _start (p,x); }

  publish "Resume a continuation until it yields"
  fun step: cont -> cont = "$1->resume()";

  publish """
  Run a continuation until it terminates.
  Do not use this proc if the underlying
  procedure attempts to read messages
  """
  proc run: cont = 
  """
  {
    flx::rtl::con_t *tmp=$1;
    if(!tmp)
      throw flx::rtl::flx_exec_failure_t (__FILE__,"run","Run terminated procedure");
    while(tmp)tmp=tmp->resume();
  }
  """;

  private proc _send[t]: &cont * t = 
  """
  {
    using namespace flx::rtl;
    con_t *tmp = *(con_t**)$1.data;
    while(tmp && tmp->action == yield_action)
      tmp=tmp->resume();
    if (!tmp) 
      throw flx::rtl::flx_exec_failure_t (__FILE__,"send","Send to terminated procedure");
    *(?1*)tmp->p_message = $2;
    tmp->action = yield_action;
    while(tmp && tmp->action == yield_action)
      tmp=tmp->resume();
    *(con_t**)$1.data = tmp; 
  }
  """;

  publish """Send a message to a continuation.
  There is no type checking on the message type.
  The procedure is executed until
  the next wait_state, then the message is stored.
  """
  proc send[t] (p:&cont) (x:t)
  {
    _send (p,x);
  }

  publish """
  Type of the state of a continuation.
  dead_state means, obviously, the continuation
  has terminated, wait_state means it is waiting
  for a message to be stored in a receptor variable,
  and yield_state means it has suspended itself
  for to allow the system to do any housekeeping
  such as garbage collection and can be resumed 
  at any time.
  """
  union cont_state = | yield_state | wait_state | dead_state;

  publish "Fetch the state of a continuation"
  fun get_cont_state: cont -> cont_state = "$1??$1->action:2";

  publish """
  Invoke the garbage collector inside a procedure run
  by the top level (external) driver.

  Don't call this procedure in a procedure which is run
  with 'run', because such procedures do not link to their
  caller with frame pointers -- unless of course a such a
  procedure has a private collector.

  Note procedure called by functions are run with 
  code equivalent to 'run'.
  """
  proc collect: unit = """
  	gc.add_root(this); 
  	gc.collect();
	  gc.remove_root(this); 
  """;
}

@#------------- List -------------------
publish "List manipulation"
module List
{
  union list[T] = | Empty | Cons of T * list[T];

  fun map[T,U] (f:T->U) (x:list[T]): list[U] = {
    return
      match x with
      | Empty[T] => Empty[U]
      | Cons[T] (?h, ?t) => Cons (f(h), map f t)
      endmatch
    ;
  }

  fun rev[T] (x:list[T]):list[T]= {
    fun aux (x:list[T]) (y:list[T]) : list[T] =
    {
      return 
        match x with
        | Empty[T] => y
        | Cons[T] (?h, ?t) => aux t (Cons (h, y))
        endmatch
      ;
    }
    return aux x Empty[T];
  }

  proc iter[T] (f:T->void) (x:list[T]) {
    match x with
    | Empty[T] => {} 
    | Cons[T] (?h,?t) => { f h; iter f t; }
    endmatch
    ;
  }

  fun fold_left[T,U] (f:U->T->U) (init:U) (x:list[T]):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_left f (f init h) t
      endmatch
    ;
  }

  fun fold_right[T,U] (f:T->U->U) (x:list[T]) (init:U):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_right f t (f h init)
      endmatch
    ;
  }
  
  fun join[T] (x:list[T]) (y:list[T]):list[T] = 
  {
    return
      match x with
      | Empty[T] => y
      | Cons[T] (?h,?t) => Cons (h, join t y)
      endmatch
    ;
  }

  fun add[T] (x:list[T], y: list[T]):list[T] => join x y;

  fun cat[T] (x:list[list[T]]):list[T] =
  {
     return 
       match x with
       | Empty[list[T]] => Empty[T]
       | Cons[list[T]] (?h,?t) => fold_left join of (list[T]) h t
       endmatch
     ;
   }
}

publish "Association Lists (lists of pairs)"
module Assoc_list
{
  typedef assoc_list[A,B] = List::list[(A,B)];
}

@#------------- Lexer -------------------
// This module provides functions to 
// use in conjunction with the reglex construction
module Lexer
{
  type iterator = "char const*";
  fun start_iterator : string -> iterator = "$1.data()";
  fun end_iterator: string -> iterator = "$1.data()+$1.size()";
  fun string_between: iterator * iterator -> string =
   "std::string($1,$2)";

  fun eq:iterator * iterator -> bool = "$1==$2";
  fun ne:iterator * iterator -> bool = "$1!=$2";
  fun lt:iterator * iterator -> bool = "$1<$2";
  fun le:iterator * iterator -> bool = "$1<=$2";
  fun ge:iterator * iterator -> bool = "$1>=$2";
  fun gt:iterator * iterator -> bool = "$1>$2";

  fun add: iterator * int -> iterator = "$1 + $2";
  fun sub: iterator * int -> iterator = "$1 - $2";
  fun sub: iterator * iterator -> int = "$1 - $2";
  proc incr: lvalue[iterator] = "++$1;";
  fun deref: iterator -> char = "*$1";

}

// ------ Open common modules -------------
open Bool;
open Int;
open Double;
open Char;
open String;
open Stdout;
open Arith_casts;
open Control;

@head(1,'Stl library')
@h=tangler('lib/stl.flx')
@select(h)
header '''
#include <vector>
#include <list>
#include <set>
#include <map>
#include <deque>
#include <queue>
#include <stack>
''';
@#------------- STL CONTAINERS -----------------------
module Stl 
{
  module Vector
  {
    type stl_vector[t] = "std::vector<`1>";
    type stl_vector_iterator[t] = "std::vector<`1>::iterator";
    type stl_vector_const_iterator[t] = "std::vector<`1>::const_iterator";
  }
  module List
  {
    type stl_list[t] = "std::list<`1>";
    type stl_list_iterator[t] = "std::list<`1>::iterator";
    type stl_list_const_iterator[t] = "std::list<`1>::const_iterator";
  }
  module Set
  {
    type stl_set[t] = "std::set<`1>";
    type stl_set_iterator[t] = "std::set<`1>::iterator";
    type stl_set_const_iterator[t] = "std::set<`1>::const_iterator";
  }
  module MultiSet
  {
    type stl_multiset[t] = "std::multiset<`1>";
    type stl_multiset_iterator[t] = "std::multiset<`1>::iterator";
    type stl_multiset_const_iterator[t] = "std::multiset<`1>::const_iterator";
  }
  module Map
  {
    type stl_map[k,v] = "std::map<`1,`2>";
    type stl_map_iterator[t] = "std::map<`1>::iterator";
    type stl_map_const_iterator[t] = "std::map<`1>::const_iterator";
  }
  module MultiMap
  {
    type stl_multimap[k,v] = "std::multimap<`1,`2>";
    type stl_multimap_iterator[t] = "std::multimap<`1>::iterator";
    type stl_multimap_const_iterator[t] = "std::multimap<`1>::const_iterator";
  }
  module Queue
  {
    type queue[t] = "std::queue[`1]";
    type stl_queue_iterator[t] = "std::queue<`1>::iterator";
    type stl_queue_const_iterator[t] = "std::queue<`1>::const_iterator";
  }
  module Deque
  {
    type deque[t] = "std::deque[`1]";
    type stl_deque_iterator[t] = "std::deque<`1>::iterator";
    type stl_deque_const_iterator[t] = "std::deque<`1>::const_iterator";
  }
  module PriorityQueue 
  {
    type stl_priority_queue[t] = "std::priority_queue[`1]";
    type stl_priority_queue_iterator[t] = "std::priority_queue<`1>::iterator";
    type stl_priority_queue_const_iterator[t] = "std::priority_queue<`1>::const_iterator";
  }
  module Stack
  {
    type stl_stack[t] = "std::stack[`1]";
    type stl_stack_iterator[t] = "std::stack<`1>::iterator";
    type stl_stack_const_iterator[t] = "std::stack<`1>::const_iterator";
  }
}


