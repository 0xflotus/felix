@execfile('config'+os.sep+'flx_data.py')
@head(1,'Felix Standard Library')
@head(2,"Change Log")
$Log$
Revision 1.176  2006/08/13 06:40:04  idadesub
renamed all felix macros to have FLX_ prepended to them to prevent name
collision with other external libraries

Revision 1.175  2006/08/12 17:01:49  skaller
Attempted to fix the intptr problem by fudging ALIAS stuff
in the compiler config to ensure all the ALIAS'es are defined,
whether or not there is a typedef available in stdint.h

Revision 1.174  2006/08/12 14:41:53  skaller
Revert the ALIAS changes because they didn't work, leaves an
open problem on Solaris with intptr etc.
Rewrite pthread stuff to use a portable interface, using a
wrapper which also catches exceptions which would otherwise
try to escape the thread.

Revision 1.173  2006/08/11 07:37:17  idadesub
use tmap instead of the ALIAS's, as occasionally an alias doesn't exist,
such as intmax on solaris

Revision 1.172  2006/08/11 00:45:48  skaller
Add (u)intptr and (u)intmax aliases (because I documented them :)

Revision 1.171  2006/07/31 12:45:17  skaller
Add _gc_type t type qualifier which tells that t is an allocable
type and requires a shape. Add magic substitution encoding @?n
which refers to the shape of the n'th type argument.
Fixed faulty declaration of C++ array new operator used
for allocation of a gc scannable array. Provided type
Varray::varray[t] for variable length array, this is only
a first cut: it's actually an immobile bounded length
array with size variable up to the bound.

Revision 1.170  2006/07/17 17:22:40  skaller
Add test case for mmap.

Revision 1.169  2006/07/15 11:08:10  skaller
Fixes to fail[] function, some _ctor_arg things that got a
string but the C routines needed a char*.

Revision 1.168  2006/07/15 02:14:08  skaller
Misc fiddles. Enable asserts in C++ code. Delete libraries
before ar'ing them to make sure no stale objects in them.

Revision 1.167  2006/07/10 11:33:47  skaller
Add source locations in new module Debug.

Revision 1.166  2006/06/29 06:49:30  idadesub
looks like we missed a couple "requires flx_strutil"

Revision 1.165  2006/06/14 14:47:35  skaller
Make function/procedure pointer which are constructor arguments work.

Revision 1.164  2006/06/14 04:35:14  idadesub
allow for more interesting find/mem testing

Revision 1.163  2006/06/14 03:00:20  skaller
Change std::exception to std::runtime_error in standard library
fail functions.

Revision 1.162  2006/05/25 17:29:41  skaller
Misc

@head(2,"Code")
Support table.
@begin_table("filebase","language","namespace","function")
@table_row("rtl/flx_i18n","C++","flx::rtl::i18n","utf8 codec support")
@table_row("rtl/flx_strutil","C++","flx::rtl::strutil","Python style substring support")
@table_row("rtl/flx_ioutil","C++","flx::rtl::ioutil","Standard IO support")
@table_row("lib/std","Felix","","Standard Library")
@table_row("lib/stl","Felix","","STL support")
@end_table()

@h=tangler('rtl/flx_ioutil.hpp')
@select(h)
#ifndef FLX_IOUTIL
#define FLX_IOUTIL
#include <string>
#include <cstdio>
#include "flx_rtl_config.hpp"

namespace flx { namespace rtl { namespace ioutil {
  RTL_EXTERN std::string load_file (std::FILE *);
  RTL_EXTERN std::string load_file (std::string);
  RTL_EXTERN std::string readln(std::FILE*);
  RTL_EXTERN void write (std::FILE *, std::string);
  RTL_EXTERN void writeln (std::FILE *, std::string);
}}}
#endif

@h=tangler('rtl/flx_ioutil.cpp')
@select(h)
#include <cstdio>
#include <string>
#include "flx_ioutil.hpp"
namespace flx { namespace rtl { namespace ioutil {
  using namespace std;

  string load_file (FILE *fi)
  {
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  string load_file (string f)
  {
    char const *fname = f.data();
    FILE *fi = fopen(fname,"rt");
    if (fi)
    {
      string x = "";
      char buffer[512];
      while (fgets(buffer,512,fi))
        x = x + string(buffer);
      fclose(fi);
      return x;
    }
    else return "";
  }

  // includes newline if present
  // null string indicates end of file
  string readln (FILE *fi)
  {
    if(fi)
    {
      string x = "";
      char buffer[513];
      buffer[512]='\0';
      int n;
      while 
      ( 
        !(
          (n=x.size()) && 
          x[n-1]=='\n'
        ) 
        &&
        fgets(buffer,512,fi)
      )
        x = x + string(buffer);
      return x;
    }
    else return "";
  }

  void write (FILE *fi, string s)
  {
    fwrite(s.data(),s.size(),1,fi);
  }

  void writeln (FILE *fi, string s)
  {
    static char *eol = "\n";
    static int n = 0;
    if(n==0)n=strlen(eol);
    fwrite(s.data(),s.size(),1,fi);
    fwrite(eol,n,1,fi);
  }

}}}

@h=tangler('rtl/flx_strutil.hpp')
@select(h)
#include <string>
#include <sstream>
#include <stdarg.h>

#include "flx_rtl_config.hpp"

//RF: was only to commented out to fix macosx problem,
//but lets see what happens to all the other builds.
//#ifndef MACOSX
//template class RTL_EXTERN std::basic_string<char>;
//#endif

namespace flx { namespace rtl { namespace strutil {
  using namespace std;
  template<class T>
  basic_string<T> mul(basic_string<T> s, int n) {
    basic_string<T> r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  template<class T>
  basic_string<T> substr(basic_string<T> const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }

  template<class T>
  T subscript(basic_string<T> const &s, int i)
  {
    int n = s.size();
    if(i<0)  i=i+n;
    return i<0 || i >= n ? T(0) : s[i];
  }

  template<class T>
  string str(T const &t) {
    std::ostringstream x;
    x << t;
    return x.str();
  }

  RTL_EXTERN string atostr(char const *a);
  RTL_EXTERN string ltrim(string const &x);
  RTL_EXTERN string rtrim(string const &x);
  RTL_EXTERN string flx_asprintf(char *fmt,...);

}}}

@h=tangler('rtl/flx_strutil.cpp')
@select(h)
#include "flx_strutil.hpp"

namespace flx { namespace rtl { namespace strutil {

  string atostr(char const *a) {
    if(a) return a;
    else return "";
  }

 string ltrim(string const &x) {
   int n = x.size();
   int i;
   for(i = 0; i < n; ++i)
     if(x[i]>' ')break;
   return x.substr(i,n-i);
 }

 string rtrim(string const &x) {
   int n = x.size();
   int i;
   for(i = n; i > 0; --i)
     if(x[i-1]>' ')break;
   return x.substr(0,i);
 }

#ifdef HAVE_VSNPRINTF  
  string flx_asprintf(char *fmt,...){
    va_list ap;
    va_start(ap,fmt);
    int n = vsnprintf(NULL,0,fmt,ap);
    va_end(ap);
    char *res = (char*)malloc(n+1);
    va_start(ap,fmt);
    vsnprintf(res,n+1,fmt,ap);
    va_end(ap);
    string s = string(res);
    free(res);
    return s;
  }
#else
  // THIS IS UNSAFE .. but Windows sucks.
  // It documents vsnprintf .. but doesn't provide it
  string flx_asprintf(char *fmt,...){
    va_list ap;
    int n = 1000;
    char *res = (char*)malloc(n+1);
    va_start(ap,fmt);
    vsprintf(res,fmt,ap);
    va_end(ap);
    string s = string(res);
    free(res);
    return s;
  }
#endif

}}}

@h=tangler('lib/flx_categories.flxh')
@select(h)
  macro proc gen_eq(t){
    fun eq: t * t -> bool = "$1==$2" ;
    fun ne: t * t -> bool = "$1!=$2" ;
  }

  macro proc gen_cmp(t){
    gen_eq t;
    fun lt: t * t -> bool = "$1<$2" ;
    fun gt: t * t -> bool = "$1>$2" ;
    fun le: t * t -> bool = "$1<=$2" ;
    fun ge: t * t -> bool = "$1>=$2" ;
  }

  // additive group
  macro proc gen_add (t){
    fun pos: t -> t = "+$1" ;
    fun neg: t -> t = "-$1" ;
    fun add: t * t -> t = "$1+$2" ;
    fun sub: t * t -> t = "$1-$2" ;
    proc pluseq: lvalue[t] * t = "$1+=$2;";
    proc minuseq: lvalue[t] * t = "$1-=$2;";
  }

  // ring
  macro proc gen_arith(t){
    gen_add t;
    fun mul: t * t -> t = "$1*$2" ;
    fun div: t * t -> t = "$1/$2" ;
    proc muleq: lvalue[t] * t = "$1*=$2;";
    proc diveq: lvalue[t] * t = "$1/=$2;";
  }

  // division ring
  macro proc gen_dring(t){
    gen_arith t;
    fun mod : t * t -> t = "$1%$2" ;
    proc modeq: lvalue[t] * t = "$1%=$2;";
  }

  macro proc gen_forward (t){
    fun succ: t -> t = "$1:add + 1" is add;
    proc pre_incr:  lvalue[t] = "++$1;";
    proc post_incr: lvalue[t] = "$1++;";
  }

  macro proc gen_bidirectional(t){
    gen_forward t;
    fun pred: t -> t = "$1:add - 1" is add;
    proc pre_decr:  lvalue[t] = "--$1;";
    proc post_decr: lvalue[t] = "$1--;";
  }

  macro proc gen_random(t){
    gen_bidirectional t;
    fun add: t * int -> t = "$1+$2";
    fun sub: t * int -> t = "$1-$2";
    proc pluseq: lvalue[t] * int = "$1+=$2;";
    proc minuseq: lvalue[t] * int = "$1-=$2;";
  }

  // division ring
  macro proc gen_integral(t){
    gen_cmp t;
    gen_dring t;
    gen_bidirectional t;
  }

@h=tangler('lib/flx.flxh','data')
@select(h)
#import <flx_syntax.flxh>
#import <flx_macros.flxh>
include "std";

@h=tangler('lib/flx_macros.flxh','data')
macro val true = case 1 of 2;
macro val false = case 0 of 2;
macro fun print_line (x) = { fprint (cout,x); Stdout::endl cout; };
macro fun print(x) = { fprint (cout,x); };

@h=tangler('lib/flx_syntax.flxh','data')
@select(h)
#infix 10 "/\\" wedge
#infix 10 "\\/" vee

#statement#
  whilst expr do statements done ; =># 
  macro {
    macro lab1 is new;
    macro lab2 is new;
    lab1:> 
      if not _1 goto lab2;
      _3;
      goto lab1;
    lab2:>
  };
#

#statement#
  until expr do statements done; =># 
  macro {
    macro lab1 is new;
    macro lab2 is new;
    lab1:> 
      if _1 goto lab2;
      _3;
      goto lab1;
    lab2:>
  };
#

#statement#
  forall ident in expr do statements done ; =># 
    macro for val _2 in _3 do _5; done;
#

#keyword upto
#statement# 
  forall ident in expr upto expr do statements done ; =># 
  _1 = _3;
  whilst _1 <= _5 do _7; ++_1; done;
#

#keyword downto
#statement# 
  forall ident in expr downto expr do statements done ; =># 
  _1 = _3;
  whilst _1 >= _5 do _7; --_1; done;
#

#statement publish #
  string_literal statement =># _2;
#
  
@h=tangler('lib/flx_platform.flxh','data')
@select(h)
#define true case 1 of 2
#define false case 0 of 2

@plats = ["WIN32","POSIX","LINUX","MACOSX","CYGWIN","SOLARIS","BSD"]
@for i in plats:
  if(eval(i)==1):
    tangle("#define " + i + " true")
  else:
    tangle("#define " + i + " false")
@#

macro val true = case 1 of 2;
macro val false = case 0 of 2;

@for i in plats:
  x = eval(i)
  if x == 1: y = "true"
  else: y = "false" 
  tangle("macro val " + i + " = " + y + ";")

@h=tangler('lib/std.flx','data')
@# use data tangler to prevent line number generation
@select(h)
#import <flx_syntax.flxh>
#import <flx_categories.flxh>
#import <flx_platform.flxh>
#import <flx_macros.flxh>

header '#include "flx_rtl_config.hpp"';

header iostream = "#include <iostream>";
header cmath = """
#include <cmath>
#ifdef HAVE_ISNAN_IN_IEEEFP
extern "C" {
#include <ieeefp.h>
}
#endif
""";

header """
#include <cstdio>
#include <cstddef>
#include <cassert>
#include <climits>
using namespace std;
""";

header flx_ioutil = '#include "flx_ioutil.hpp"';
header flx_dynlink = '#include "flx_dynlink.hpp"';
header flx_i18n = '#include "flx_i18n.hpp"';
header stdexcept = '#include <stdexcept>';

// note -- this code is templated, we include
// it in the header file because that's where
// most C++ compilers need it (ISO requires
// separate compilation of templates but most
// compilers as at 2004 don't implement it)

header flx_strutil = '#include "flx_strutil.hpp"';

header cctype_hxx = '#include <cctype>';
header string_hxx = '#include <string>';
header complex_hxx = '#include <complex>';
header c99_complex_h = '#include <complex.h>';

@if HAVE_STDINT:
  tangle('header c99_stdint_h = "#include <stdint.h>";')
 else:
  tangle('header c99_stdint_h = "";')

header cstdlib = "#include <cstdlib>";
header cstring = "#include <cstring>";

@chars = ["char", "wchar", "uchar"]
@fast_sints = [
  "tiny", "short", "int", "long", "vlong"
  ]
@fast_uints = [
  "utiny", "ushort", "uint", "ulong", "uvlong"
  ]
@exact_sints = [
  "int8","int16","int32","int64"
  ]
@exact_uints = [
  "uint8","uint16","uint32","uint64"
  ]
@sints = fast_sints + exact_sints
@uints = fast_uints + exact_uints
@fast_ints = fast_sints + fast_uints
@exact_ints = exact_sints + exact_uints
@ints = uints + sints

@floats = ["float", "double", "ldouble"]

@complex = ["complex","dcomplex","lcomplex"]
@imaginary= ["imaginary", "dimaginary", "limaginary"]
@all = [
  "byte", "address","caddress","vaddress","cvaddress",
  "offset", 
  ] + chars + fast_ints + floats + complex + imaginary

@def gen_type(t):
  d = rmap.get(t,None)
  if d:
    tangle('pod type '+t+' = "'+tmap[t]+'" requires '+d+';')
  else:
    tangle('pod type '+t+' = "'+tmap[t]+'";')

@for t in all:
  gen_type(t)

_gc_pointer type gcaddress = "void*";
_gc_pointer type gcptr[t]= "?1*";

@fint2cint={
  'tiny':'signed char',
  'short':'short',
  'int':'int',
  'long':'long',
  'vlong':'long long',
  'utiny':'unsigned char',
  'ushort':'unsigned short',
  'uint':'unsigned int',
  'ulong':'unsigned long',
  'uvlong':'unsigned long long',
  }

@cint2fint = {}
@for f in fint2cint.keys(): cint2fint[fint2cint[f]]=f

@def alias_sint(t):
  if t == 'int8': size = 1
  elif t == 'int16': size = 2
  elif t == 'int32': size = 4
  elif t == 'int64': size = 8
  if SIZEOF_CHAR == size: return 'tiny'
  if SIZEOF_SHORT == size: return 'short'
  if SIZEOF_INT == size: return 'int'
  if SIZEOF_LONG == size: return 'long'
  if SIZEOF_LONGLONG == size: return 'vlong'

@def alias_uint(t):
  if t == 'uint8': size = 1
  elif t == 'uint16': size = 2
  elif t == 'uint32': size = 4
  elif t == 'uint64': size = 8
  if SIZEOF_CHAR == size: return 'utiny'
  if SIZEOF_SHORT == size: return 'ushort'
  if SIZEOF_INT == size: return 'uint'
  if SIZEOF_LONG == size: return 'ulong'
  if SIZEOF_LONGLONG == size: return 'uvlong'

@# mandatory in C
@for t in ['ptrdiff','size','intmax','uintmax','intptr','uintptr']:
  equiv = cint2fint[eval('ALIAS_'+t+'_t')]
  tangle('typedef ' + t + ' = ' + equiv + ';')

@# optional in C
@for t in exact_ints:
  equiv = cint2fint[eval('ALIAS_'+t+'_t')]
  tangle('typedef ' + t + ' = ' + equiv + ';')
  tangle('rename ' + string.capitalize(t) + ' = ' + string.capitalize(equiv) + ';')

typedef chars = typesetof (char, wchar, uchar);

typedef fast_sints = typesetof (tiny, short, int, long, vlong);
typedef exact_sints = typesetof(int8,int16,int32,int64);
typedef fast_uints = typesetof (utiny, ushort, uint, ulong,uvlong);
typedef exact_uints = typesetof (uint8,uint16,uint32,uint64);

typedef sints = fast_sints || exact_sints;
typedef uints = fast_uints || exact_uints;

typedef fast_ints = fast_sints || fast_uints;
typedef exact_ints = exact_sints || exact_uints;

typedef ints = sints || uints;

typedef floats = typesetof (float, double, ldouble);
typedef reals = ints || floats;

typedef complexes = typesetof (complex,dcomplex,lcomplex);
typedef imaginaries = typesetof (imaginary, dimaginary, limaginary);

typedef numbers = reals || imaginaries || complexes;

// C integer promotion rule
typedef fun integral_promotion: TYPE -> TYPE =
  | tiny => int
  | utiny => int
  | short => int
  | ushort => int
  | int => int
  | uint => uint
  | long => long
  | ulong => ulong
  | vlong => vlong
  | uvlong => uvlong
;

// arithmetic conversion rule 
typedef fun arithmax(l: TYPE, r: TYPE): TYPE =>
  typematch integral_promotion l, integral_promotion r with
@for f1 in fint2cint.keys():
  if f1 not in ['tiny','short','utiny','ushort']:
    for f2 in fint2cint.keys():
      if f2 not in ['tiny','short','utiny','ushort']:
        f3 = cint2fint[arith_conv[(fint2cint[f1],fint2cint[f2])]]
        comment = ""
        if f1 == f2:
          if f2 <> f1: comment = "// ERROR"
        if (f1 == 'uvlong' or f2 == 'uvlong') and f3 <> 'uvlong':
          comment = "// ERROR, uvlong expected"
        elif f3 <> f1 and f3 <> f2:
          comment = "// SPECIAL PROMOTION"
        elif f1 == 'uint' and f2=='long' or f1=='long' and f2=='uint':
          comment = '// Representation Dependent (long or ulong)'
        if f1 == 'uvlong' or f2 == 'uvlong' or f3 == 'int':
          pass
        else:
          tangle('  | '+f1+','+f2+' => '+f3+' '+comment)
@#
  | uvlong,_ => uvlong
  | _,uvlong => uvlong
  | _,_ => int
  endmatch
;

@absmap = { 
  "tiny":"abs",
  "short":"abs",
  "int":"abs",
  "long":"labs",
  "vlong":"llabs"
  }

body swapper[t] = """
  void swapper(?1 &a, ?1 &b){
    ?1 tmp = a; a = b; b = tmp;
  }
""";

proc _swap[t]: lvalue[t] * lvalue[t] = 
  "swapper($1,$2);"
  requires swapper[t];

typedef charp = C_hack::ptr[char];
typedef charcp = C_hack::cptr[char];

typedef ucharp = C_hack::ptr[utiny];
typedef ucharcp = C_hack::cptr[utiny];

publish "Empty sum"
  typedef void = 0;

publish "Unit type"
  typedef unit = 1;

publish "Boolean"
  typedef bool = 2;

publish "option type"
  union opt[T] =
    | None
    | Some of T
  ;

publish "Universal type 'x as x'"
  typedef any = any;

publish "Lvalue hack"
  typedef lvalue[t] = lval t;

publish "Deref hack"
  inline fun deref[t](p:&t):lval t => _deref p;
 
@def gen_uint(t):
  for opname,op in [
    ("bxor","^"),
    ("bor","\\|"),
    ("band","\\&"),
  ]:
    tangle('  fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')
  tangle('  fun bnot: '+t+' -> '+t+' = "~$1";')


@def gen_uint_assign(t):
  for opname,op in [
    ("bxoreq","^="),
    ("boreq","|="),
    ("bandeq","&=")
  ]:
    tangle('  proc '+opname+': lvalue['+t+'] * '+t+' = "$1'+op+'$2;";')

@fc = {'float':'f', 'double':'','ldouble':'l'}
@def gen_pow(t):
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('  fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)" is postfix requires cmath;')

@def gen_trig(t):
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('  fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)" is postfix requires cmath;')

@def gen_nan(t):
  if HAVE_ISNAN_IN_CMATH:
    tangle('  fun isnan: '+t+' -> bool = "isnan'+fc[t]+'($1)" is postfix requires cmath;')
  elif HAVE_ISNAN_IN_IEEEFP:
    tangle('  fun isnan: '+t+' -> bool = "isnanf'+fc[t]+'($1)" is postfix requires cmath;')
  else:
    tangle('  fun isnan: '+t+' -> bool = "!($1==$1)" is unary requires cmath;')

 
@#------------- TYPING ---------------------------
module Typing
{
  typedef fun dom(t:TYPE):TYPE =>
    typematch t with
    | ?a -> _ => a
    endmatch
  ;

  typedef fun cod(t:TYPE):TYPE =>
    typematch t with
    | _ -> ?b => b
    endmatch
  ;
  
  typedef fun prj1(t:TYPE):TYPE =>
    typematch t with
    | ?a * _ => a
    endmatch
  ;

  typedef fun prj2(t:TYPE):TYPE =>
    typematch t with
    | _ * ?b => b
    endmatch
  ;

  typedef fun land(x:TYPE, y:TYPE):TYPE => 
    typematch (x,  y) with
    | 0, _ => 0
    | _,0 => 0
    | _,_ => 1
    endmatch
  ;

  typedef fun lor(x:TYPE, y:TYPE):TYPE=>
    typematch (x,  y) with
    | 0, 0 => 0
    | _,_ => 1
    endmatch
  ;

  const memcount[t] : int = "#memcount";
}
  
@#------------- CASTS and C HACKERY ---------------
publish """
This module provides access to raw C/C++ encodings.
Incorrect typing is likely to pass by Felix and
be trapped by the C/C++ compiler. Incorrect management
of storage can lead to corruption. The use of the
C_hack module is necessary for interfacing.
"""
module C_hack
{
  publish "C void"
  incomplete type void_t = "void";

  publish "standard variable argument list pointer type"
  type va_list = "va_list";

  publish """
  GCC specific valist thingo: it will
  be optimised away if not used (eg on MSVC)
  """
  type __builtin_va_list = '__builtin_va_list';

  publish """
  Throw away result of a function call:
  only useful for C functions that are mainly
  called for side effects.
  """
  proc ignore[t]:t = "(void)$t;";
  
  fun cast[dst,src]: src->dst = '(?1)($1)';
  fun static_cast[dst,src]: src->dst = 'static_cast<?1>($1)';
  fun dynamic_cast[dst,src]: src->dst = 'dynamic_cast<?1>($1)';
  fun reinterpret_cast[dst,src]: src->dst = 'reinterpret_cast<?1>($1)';
  fun reinterpret[dst,src]: src->dst = "reinterpret<?1>($1)";
  const sizeof[t]:size = 'sizeof(?1)';
  fun int_of:size->int='$1';
  fun size_of:int->size='$1';

  fun eq: address * address -> bool = "$1==$2";
  fun ne: address * address -> bool = "$1!=$2";

  publish "Abstract type for C pointer"
  pod type ptr[t]="?1 *";

  publish "Abstract type for C pointer to const"
  pod type cptr[t]="?1 const *";

  publish "Convert pointer to pointer to const"
  fun enconst[t]: ptr[t]->cptr[t] = "(?1 const*)$1";

  publish """
  Unsafe function to get C pointer from Felix reference.
  The pointer may dangle if the collector deletes the 
  frame containing the object. 
  """
  fun unref[t]: &t->ptr[t] = "(?1*)($1.get_data())";

  publish """
  Function to make Felix reference from C pointer.
  This function is only safe if the C pointer
  was not allocated by the Felix collector:
  the resulting reference will never be collected
  (because the frame pointer is set to 0)
  """
  fun mkref[t]: ptr[t]->&t = "(#0 const&)flx::rtl::_ref_(0,(void*)$1-NULL)";

  publish """
  Dereference a C pointer. If the expression is an
  an lvalue, the result is an lvalue. Assignments
  to const lvalues are trapped by the C/C++ compiler.
  """
  fun deref[t]: ptr[t] -> lvalue[t] = "*$1";
  fun deref[t]: cptr[t] -> lvalue[t] = "*$1";
  fun deref[t]: gcptr[t] -> lvalue[t] = "*$1";

  publish """
  Function to take the address of a C lvalue,
  fails in C/C++ compiler if the argument isn't an lvalue.
  Addresses of Felix variables are safe to use provided the
  containing frame won't be collected. 
  Addresses of temporaries must not be taken.
  """
  fun addr[t]: lvalue[t] -> ptr[t] = "&$1";
  fun caddr[t]: lvalue[t] -> cptr[t] ="(?1 const*)&$1";
  fun as_address[t]: ptr[t]->address = "(void*)$1";
  fun address_of[t]: lvalue[t]-> address = "(void*)&$1";
  fun isNULL: address -> bool = "(NULL==$1)";
  fun isNULL[t]: ptr[t] -> bool = "(NULL==$1)";
  fun isNULL[t]: cptr[t] -> bool = "(NULL==$1)";
  fun isNULL[t]: gcptr[t] -> bool = "(NULL==$1)";
  
  publish """
  Polymorphic null pointer constant
  """
  const null_ptr[t]:ptr[t] = "(?1*)NULL";
  const null_gcptr[t]:gcptr[t] = "(?1*)NULL";
  const null_cptr[t]:ptr[t] = "(?1 const*)NULL";
  const NULL : address = "NULL";

  publish """
  Unsafe output of hopefully null terminated C strings
  """
  proc fprint: ostream * charp = "*$1<<$2;" requires iostream;
  proc fprint: ostream * charcp = "*$1<<$2;" requires iostream;

  publish """ print an address in hex """
  proc fprint: ostream * address = "*$1<<$2;" requires iostream;

  header dflt_h = "template<class T> T dflt() { return T(); }";
  publish """
  Workaround for g++ 3.2.2 parsing bug,
  it can parse T() as a default ctor call,
  but screws up on (T())
  """
  fun dflt[t]:1->t = "dflt<?1>()" requires dflt_h;

  // this hackery is here to force Felix to make 
  // a suitable shape object
  private union _dummy[t] = | _new of t;
  private fun _udata[t]: _dummy[t]->gcptr[t] = "(?1*)$1.data";
  fun xnew[t](x:t) => _udata$ _new x;

  // raw allocation and deallocation
  fun malloc: int -> address = 'malloc($1)' requires stdlib_h;
  proc free: address = 'free($1);' requires stdlib_h; 
}


// the internal representation of a Felix source location
// has to be global to simplify compiler hack
type flx_location_t = "flx::rtl::flx_range_srcref_t";

module Debug 
{
  const FLX_SRCLOC : flx_location_t = "#srcloc";
  fun filename: flx_location_t -> charp = "$1.filename";
  fun startline: flx_location_t -> int = "$1.startline";
  fun startcol: flx_location_t -> int = "$1.startcol";
  fun endline: flx_location_t -> int = "$1.endline";
  fun endcol: flx_location_t -> int = "$1.endcol";

  // hack to emit C++ source file locations
  const CPP_FUNCTION : charp = "__FUNCTION__";
  const CPP_FILE: charp = "__FILE__";
  const CPP_LINE: int = "__LINE__";

  // hack to emit C code an expression would generate
  fun repr_expr[t]: t -> string = '\\"$a:?1\\"';
  
  // hack to emit C typename of a Felix type
  const repr_type[t]:string = '\\"?1\\"';
}

module Carray
{
  requires cstdlib;
  open C_hack;

  fun array_alloc[t]: int -> ptr[t] = '(?1*)std::malloc(sizeof(?1)*$1)'; 
  fun array_calloc[t]: int -> ptr[t] = '(?1*)std::calloc(sizeof(?1),$1)'; 
  proc free[t]: ptr[t]="std::free($1);";
  fun subscript[t]: ptr[t] * int -> lvalue[t] = '$1[$2]';

  fun add[t]: ptr[t] * int -> ptr[t]= '$1+$2';
  fun sub[t]: ptr[t] * int -> ptr[t] = '$1-$2';
  fun sub[t]: ptr[t] * ptr[t]-> int = '$1-$2';

  proc pre_incr[t]: lvalue[ptr[t]] = '++$1;'; 
  proc post_incr[t]: lvalue[ptr[t]] = '$1++;'; 
  proc pre_decr[t]: lvalue[ptr[t]] = '--$1;'; 
  proc post_decr[t]: lvalue[ptr[t]] = '$1--;'; 
  proc pluseq[t]: lvalue[ptr[t]] * int = '$1+=$2;'; 
  proc minuseq[t]: lvalue[ptr[t]] * int = '$1-=$2;'; 


  fun eq[t]: ptr[t] * ptr[t] -> bool = '$1==$2';
  fun ne[t]: ptr[t] * ptr[t] -> bool = '$1!=$2';
  fun lt[t]: ptr[t] * ptr[t] -> bool = '$1<$2';
  fun le[t]: ptr[t] * ptr[t] -> bool = '$1<=$2';
  fun gt[t]: ptr[t] * ptr[t] -> bool = '$1>$2';
  fun ge[t]: ptr[t] * ptr[t] -> bool = '$1>=$2';

  publish "Convert Felix array to C array"
  fun carray_of[t,n]: t ^ n -> ptr[t] = "$t.data";

  publish "Convert C array to Felix array"
  fun array_of[t,n]: ptr[t] -> ptr[t ^ n] = "*(#0*)(void*)$1";
  
  proc memcpy: address * address * size = 
    "{if($1 && $2 && $3)std::memcpy($1,$2,$3);}"
    requires cstring
  ;
}

publish "System Interface"
module System
{
  const argc:int = "ptf->argc";
  fun argv:int -> string = 'std::string($1<0||$1>=ptf->argc??"":ptf->argv[$1])';
  fun args () => List::map (the argv) (List::range argc);
@tangle('  const felix_version : string = \'std::string("'+flx_version+'")\';')
  fun system: string -> int = "std::system($1.data())"
    requires cstdlib;
  proc exit: int = "std::exit($1);";
  proc abort: 1 = "std::abort($1);";
  type ptf_t = "thread_frame_t*";
  const ptf:ptf_t = "ptf"; 
    // note this will NOT work if ptf is a struct,
    // then we'd need (&ptf) instead ..
    // however this model isn't supported fully yet and probably never will be
    // we may, however, make ptf a machine register
}

@#------------- Environment -------------------
module Env
{
  fun getenv:string -> string = 
    "flx::rtl::strutil::atostr(getenv($1.data()))" 
    requires flx_strutil, cstdlib;
}

module Dynlink
{
  requires flx_dynlink;
  type flx_library = "flx::rtl::flx_dynlink_t*";
  type flx_instance = "flx::rtl::flx_libinit_t*";
  proc dlopen:flx_library * string = "$1->link($2.data());";
  proc dlclose:flx_library = "$1->unlink();";

  // this is a procedure, so maybe the caller is too
  // which means the thread frame must be available
  proc create: flx_library * flx_instance = 
    "_create($1,$2,PTF gc,$1->main_sym,PTF argc,PTF argv,PTF flx_stdin, PTF flx_stdout, PTF flx_stderr);"
    requires property "needs_gc",
    body """
    void _create
    (
      flx::rtl::flx_dynlink_t *library,
      flx::rtl::flx_libinit_t *instance,
      flx::gc::generic::collector_t *gc,
      flx::rtl::main_t main_sym,
      int argc, char **argv, 
      FILE *stdin_, FILE *stdout_, FILE *stderr_
    )
    { 
      instance->create(library,gc,main_sym,argc,argv,stdin_,stdout_,stderr_); 
    }
    """;
  
  private fun get_init: flx_instance -> cont = "$1->start_proc";
  private fun get_library: flx_instance -> flx_library = "$1->lib";
  proc destroy: flx_instance = "$1->destroy();";
  
  fun create_library_handle: unit->flx_library=
    "new flx::rtl::flx_dynlink_t()";

  fun create_instance_handle: unit->flx_instance=
    "new flx::rtl::flx_libinit_t()";

  proc delete_library_handle: flx_library =
    "delete $1;";

  proc delete_instance_handle: flx_instance =
    "delete $1;";
    
  noinline fun init_lib(filename:string):flx_instance = {
    var library = create_library_handle();
    var instance =  create_instance_handle();
    dlopen(library,filename);
    create (library,instance);
    var init = get_init instance;
    Control::run init;
    return instance;
  }

  publish """ Run a Felix program. 
    WARNING!! All data created by the target
    program must be destroyed 
    before the library code is unlinked.
  """
  proc run_lib(filename:string) 
  {
    var instance = init_lib(filename);
    destroy_lib instance;
  }

  noinline proc destroy_lib(instance:flx_instance)
  {
    destroy instance;
    Control::collect();
    dl := get_library instance;
    delete_instance_handle instance;
    dlclose dl;
    delete_library_handle dl;
  }

  publish "dlsym wrapper, returns any symbol"
  fun dlsym:flx_library * string->address = 
      "SDLSYM($1->library,$2.data())";

  publish """
    execute an address representing a top
    level exported felix procedure's C wrapper,
    this creates a 'read to run' continuation object
    by both constructing the object using the thread
    frame of the instance as an argument, and calling
    it to fix a null return address and an arbitrary
    client data pointer as arguments to the call method.
  """
  fun bind_proc: flx_instance * address * address -> cont = 
    "$1->bind_proc($2,$3)";

  fun dlib_of : flx_library -> address = "(void*)$1->library";

  proc dlsym_err:flx_library*string="""
    throw flx::rtl::flx_link_failure_t($1->filename,$2,"symbol not found");
  """;

  noinline proc run_proc (instance:flx_instance, p: string, data: address) 
  {
    var lib = get_library instance;
    var sym = dlsym(lib, p);
    if C_hack::isNULL(sym) do dlsym_err(lib,p); done;
    var f = bind_proc(instance, sym, data);
    run f;
  }

}

@#------------- Filename -------------------
module Filename
{
@if os.sep == '\\':
   # FFS!!! we put \\\\\\\\ here:
   # Python reduces it to \\\\             !!!
   # Felix then reduces it to \\           !!! 
   # and finally C reduces it to plain \   !!!
   # don't remove the !!! because \ at eol is continuation .. argg
   tangle("  const sep : charp = c'\"\\\\\\\\\"';")
 else:
   tangle("  const sep : charp = c'\""+os.sep+"\"';")
}

@#------------- C I/O -------------------
module Cstdio
{
  header "#include <cstdio>";
  incomplete type FILE = "std::FILE";
}

@#------------- Text I/O ------------------
module Text_file
{
  requires flx_ioutil;
  fun load: string -> string = "flx::rtl::ioutil::load_file($1)";
  fun load: text_file -> string = "flx::rtl::ioutil::load_file($1)";

  pod type text_file = "FILE*"; // its a macro?

  fun fopen_input: string -> text_file = 'std::fopen($1.data(),"rt")';
  fun fopen_output: string -> text_file = 'std::fopen($1.data(),"wt")';
  proc fclose: text_file = '(void)std::fclose($1);';
  fun readln: text_file -> string ="flx::rtl::ioutil::readln($1)";
  proc writeln : text_file * string ="flx::rtl::ioutil::writeln($1,$2);";
  proc write : text_file * string ="flx::rtl::ioutil::write($1,$2);";
  fun valid : text_file -> bool = "$1!=(FILE*)0";
  const stdin: text_file = "PTF flx_stdin";
  const stdout: text_file = "PTF flx_stdout";
  const stderr: text_file = "PTF flx_stderr";
}


@#------------- BOOL -------------------
publish "Bool compatible with C"
open module Bool 
{

  gen_eq bool;
  fun land: bool * bool -> bool = "$1&&$2";
  fun nand: bool * bool -> bool = "!($1&&$2)";
  fun lor: bool * bool -> bool = "$1||$2";
  fun nor: bool * bool -> bool = "!($1||$2)";
  fun xor: bool * bool -> bool = "$1!=$2";
  fun lnot: bool -> bool = "!$1";
  proc fprint: ostream * bool = '*$1<<($2??"true":"false");' requires iostream;
}

@#------------- INTEGER MODULES -------------------

publish "Mixed Mode arithmentic"
module MixedInt 
{
  fun add[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1+$2";
  fun sub[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1-$2";
  fun mul[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1*$2";
  fun div[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1/$2";
  fun mod[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1%$2";

  fun band[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1&$2";
  fun bor[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1|$2";
  fun bxor[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1^$2";
  fun shl[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1<<$2";
  fun shr[t1:fast_ints, t2:fast_ints]: t1 * t2 -> arithmax(t1,t2)="$1>>$2";

  fun lt[t1:fast_ints, t2:fast_ints]: t1 * t2 -> bool = "$1<$2";
  fun le[t1:fast_ints, t2:fast_ints]: t1 * t2 -> bool = "$1<=$2";
  fun eq[t1:fast_ints, t2:fast_ints]: t1 * t2 -> bool = "$1==$2";
  fun ne[t1:fast_ints, t2:fast_ints]: t1 * t2 -> bool = "$1!=$2";
  fun gt[t1:fast_ints, t2:fast_ints]: t1 * t2 -> bool = "$1>$2";
  fun ge[t1:fast_ints, t2:fast_ints]: t1 * t2 -> bool = "$1>=$2";
}

type string = "std::string";
@for t in fast_ints:
  tangle("open module " + string.capitalize(t))
  tangle("{")
  tangle('  gen_integral('+t+');')
  tangle('  fun _ctor_'+t+': string -> '+t+' = "static_cast<'+tmap[t]+'>(std::atoi($1.data()))" requires cstdlib;')
  tangle('  fun _ctor_'+t+'[T:reals]: T -> '+t+' = "static_cast<'+tmap[t]+'>($1)";')
  if t in fast_sints:
    tangle('  fun abs: '+t+' -> '+t+' = "'+absmap[t]+'($1)";')
  if t in uints: gen_uint(t)
  if t in uints: gen_uint_assign(t)
  if t == "tiny":
    tangle('  proc fprint: ostream * tiny = "*$1<<(int)$2;" requires iostream;')
    tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<int>($1)" requires flx_strutil;')
  elif t == "utiny":
    tangle('  proc fprint: ostream * utiny = "*$1<<(unsigned int)$2;" requires iostream;')
    tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<unsigned int>($1)" requires flx_strutil;')
  else:
    tangle('  proc fprint: ostream * '+t+' = "*$1<<$2;" requires iostream;')
    tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;')
  tangle("}")
  tangle("")

@#------------- FLOATING MODULES -------------------
@for t in floats:
  tangle("open module " + string.capitalize(t))
  tangle("{")
  tangle('  gen_cmp('+t+');')
  tangle('  gen_arith('+t+');')
  tangle('  fun _ctor_'+t+': string -> '+t+' = "static_cast<'+tmap[t]+'>(std::atof($1.data()))" requires cstdlib;')
  tangle('  fun _ctor_'+t+'[T:reals]: T -> '+t+' = "static_cast<'+tmap[t]+'>($1)";')
  gen_pow(t)
  gen_trig(t)
  gen_nan(t)
  tangle('  proc fprint: ostream * '+t+' = "*$1<<$2;" requires iostream;')
  tangle('  fun str: '+t+' -> string = "flx::rtl::strutil::str<#1>($1)" requires flx_strutil;')
  tangle("}")
  tangle("")
  
@#------------- CHARACTER MODULES -------------------
// ordinary value of chars
@for t in chars:
  tangle('  gen_eq('+t+');')

open module Char 
{
  open Int;
  fun ord: char -> int = "(int)$1";
  fun _ctor_char: int -> char = "(char)$1";
  proc fprint: ostream * char = "*$1<<$2;" requires iostream;
}

open module Wchar
{
  open Long;
  fun ord: wchar -> long ="(long)$1";
  fun _ctor_wchar: long -> wchar = "(wchar_t)$1";
  proc fprint: ostream * wchar = "*$1<<$2;" requires iostream;
}

open module Unicode
{
  fun ord: uchar -> uint32 ="$1";
  fun _ctor_uchar: uint32 -> uchar = "$1";
  //this needs to be fixed!
  //proc print: uchar = "std::cout<<$1;" requires iostream;
}


@#------------- STDOUT UTILITY -------------------
open module Stdout 
{
  requires iostream;
  type ostream = "std::ostream*";
  const cout: ostream = "&cout";
  proc endl: ostream = "*$1<<std::endl;";
  proc endl: unit = "std::cout << std::endl;";
  proc space: int = "std::cout << ' ';";
  proc flush: unit = "std::cout.flush(); ";
}

@#------------- STRING MODULES -------------------
open module String
{
  requires string_hxx;
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[string] * string = "$1.append($2);";
  proc pluseq: lvalue[string] * charcp = "$1.append($2);";
  proc pluseq: lvalue[string] * charp = "$1.append($2);";
  proc pluseq: lvalue[string] * char = "$1 += $2;";

  fun str: charp -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;
  fun str: charcp -> string = 'flx::rtl::strutil::atostr($1)' requires flx_strutil;
  fun str: ucharp -> string = 'flx::rtl::strutil::atostr((char const*)$1)' requires flx_strutil;
  fun str: ucharcp -> string = 'flx::rtl::strutil::atostr((char const*)$1)' requires flx_strutil;

  fun len: string -> int = "$1.size()";
  fun add: string * string -> string = "$1+$2";
  fun add: string * charp -> string = "$1+$2";
  fun add: charp * string -> string = "$1+$2";
  fun add: string * char -> string = "$1+$2";
  fun add: char * string -> string = "$1+$2";
  fun add: string * int -> string = "$1+flx::rtl::i18n::utf8($2)" requires flx_i18n;
  fun mul: string * int -> string = "flx::rtl::strutil::mul($1,$2)" requires flx_strutil;
  fun mul: char * int -> string = "std::string($2,$1)";
  
  fun apply (x:string, y:string):string => x + y;
  fun apply (x:string, y:int):string => x + y;
 
  fun _ctor_char (x:string) => x.[0];

  fun subscript: string * int -> char = 
    "flx::rtl::strutil::subscript($1,$2)" requires flx_strutil;
  fun copyfrom: string * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$1.size())" requires flx_strutil;
  fun copyto: string * int -> string = 
    "flx::rtl::strutil::substr($1,0,$2)" requires flx_strutil;
  fun substring: string * int * int -> string = 
    "flx::rtl::strutil::substr($1,$2,$3)" requires flx_strutil;

  // comparisons
  gen_cmp string;

  // Note we use int instead of size here: size is correct,
  // but that would requires heaps of casts in Felix

  const stl_npos: int = "std::string::npos";

@stringfuncs = ["find", "rfind", "find_first_of", "find_first_not_of", \
      "find_last_of", "find_last_not_of"]
@stringtypes = ["string", "charp", "char"]
@for i, f in zip(range(len(stringfuncs)), stringfuncs):
    if i != 0:
      tangle('')

    for t in stringtypes:
      tangle('  fun stl_%s: string * %s -> int = "$1.%s($2)";' % (f, t, f))
      tangle('  fun stl_%s: string * %s * int -> int = "$1.%s($2,$3)";' % (f, t, f))

    tangle('')

    for t in stringtypes:
      tangle('  fun %s (s:string, e:%s) : opt[int] => match stl_%s (s, e) with | ?i when i == stl_npos => None[int] | ?i => Some i endmatch;' % (f, t, f))
      tangle('  fun %s (s:string, e:%s, i:int) : opt[int] => match stl_%s (s, e, i) with | ?i when i == stl_npos => None[int] | ?i => Some i endmatch;' % (f, t, f))
@#

  fun startswith (x:string) (e:string) : bool =
  {
    if len x < len e do
      return false;
    done;

    var i: int; forall i in 0 upto (len e) - 1 do
      if e.[i] != x.[i] do
        return false;
      done;
    done;

    return true;
  }

  fun endswith (x:string) (e:string) : bool =
  {
    val len_x = len x;
    val len_e = len e;

    if len_x < len_e do
      return false;
    done;

    var i: int; forall i in 0 upto (len_e) - 1 do
      if e.[len_e - i - 1] != x.[len_x - i - 1] do
        return false;
      done;
    done;

    return true;
  }

  fun startswith (x:string) (e:char) : bool => x.[0] == e;
  fun endsswith (x:string) (e:char) : bool => x.[len x - 1] == e;


  // trim whitespace
  fun ltrim : string -> string = 
    "flx::rtl::strutil::ltrim($1)" requires flx_strutil;
  fun rtrim : string -> string = 
    "flx::rtl::strutil::rtrim($1)" requires flx_strutil;
  fun trim (x:string) : string => ltrim$ rtrim x;

  fun split (x:string, d:char): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find (x, d) with
      | None => List::rev$ List::Cons (x, y)
      | Some ?n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }
  
  fun split (x:string, d:string): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find_first_of (x, d) with
      | None => List::rev$ List::Cons (x, y)
      | Some ?n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }

  fun split (x:string, d:charp): List::list[string] = {
    fun aux (x:string,y:List::list[string]) =>
      match find_first_of (x, d) with
      | None => List::rev$ List::Cons (x, y)
      | Some ?n => aux$ x.[n+1 to], List::Cons (x.[to n],y)
      endmatch
    ;
    return aux$ x, List::Empty[string];
  }

  // Note: pos, length!
  proc erase: string * int * int = "$1.erase($2,$3);";
  proc insert: string * int * string = "$1.insert($2,$3);";
  proc replace: string * int * int * string = "$1.replace($2,$3,$4);";

  proc fprint: ostream * C_hack::ptr[char] = "*$1<<$2;" requires iostream;
  proc fprint: ostream * C_hack::cptr[char] = "*$1<<$2;" requires iostream;
  proc fprint: ostream * string = "*$1<<$2;" requires iostream;
  fun atoi: string -> int = "std::atoi($1.data())" requires cstdlib;
  fun atol: string -> long = "std::atol($1.data())" requires cstdlib;
  fun atof: string -> double = "std::atof($1.data())" requires cstdlib;

  proc reserve: lvalue[string] * int = "$1.reserve($2);";

  publish "Unsafe extract buffer pointer"
  fun cstr: string -> C_hack::ptr[char] = "$1.data()";

  fun vsprintf[t]: C_hack::ptr[char] * t -> string = 
    "flx::rtl::strutil::flx_asprintf($1,$T2)" requires flx_strutil
  ;
}

module Cstdlib
{
  requires cstdlib;
  const RAND_MAX:long;

  proc srand: uint = 'std::srand($1);';
  fun rand: 1 -> int = 'std::rand()';
}

type ustring = "basic_string<uint32_t>" requires string_hxx;
module Ustring
{
  open Bool;
  open Char;
  open Int;
  proc pluseq: lvalue[ustring] * ustring = "$1.append($2);";

  fun len: ustring -> int = "$1.size()";
  fun add: ustring * ustring -> ustring = "$1+$2";
  fun mul: ustring * int -> ustring = "flx::lib::mul($1,$2)";
  fun mul: char * int -> ustring = "ustring($2,$1)";

  fun apply (x:ustring, y:ustring):ustring => x + y;
 
  fun subscript: ustring * int -> char = 
    "$1[$2<0??$1.size()+$2 : $2]";
  fun copyfrom: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$1.size())" requires flx_strutil;
  fun copyto: ustring * int -> ustring = 
    "flx::rtl::strutil::substr($1,0,$2)" requires flx_strutil;
  fun subustring: ustring * int * int -> ustring = 
    "flx::rtl::strutil::substr($1,$2,$3)" requires flx_strutil;

  // comparisons
  gen_cmp ustring;

  proc fprint: ostream * ustring = "*$1<<$2;" requires iostream;
}

publish """
All the arithmetic casts between standard C arithmetic types.
"""
module Arith_casts
{
@for t1 in ints+floats:
  tangle('  fun '+t1+'_of[t2:reals]: t2 -> '+t1+' = "('+tmap[t1]+')$1:cast" is cast;')
}

@#------------- CONTROL STRUCTURES -------------------
module Control 
{
  open C_hack;
  publish 'infinite loop'
  proc forever (bdy:unit->void)
  {
    rpeat:>
      bdy();
      goto rpeat;
    dummy:> // fool reachability checker
  }

  publish 'C style while loop'
  proc while (cond:unit->bool) (bdy:unit->void)
  {
    rpeat:>
      if not (cond()) goto finish;
      bdy();
      goto rpeat;
    finish:>
  }

  /* DISABLED: replaced by UNTIL statement until the optimiser is working
  publish """
  C style while loop with reversed condition
  note the until is tested first -- zero iterations are possible
  """
  proc until(cond:unit->bool) (bdy:unit->void)
  {
    repeatx:>
      if cond() goto finish;
      bdy();
      goto repeatx;
    finish:>
  }
  */

  publish "do nothing [the name pass comes from Python]"
  proc pass(){}

  publish 'C style for loop'
  proc for_each
    (init:unit->void) 
    (cond:unit->bool) 
    (incr:unit->void)
    (bdy:unit->void)
  {
    init();
    rpeat:>
      if not (cond()) goto finish;
      bdy();
      incr();
      goto rpeat;
    finish:>
  }

  publish 'abnormal termination with message'
  proc fail:string = 'throw std::runtime_error($1);' requires stdexcept;

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:1->t = 'throw std::runtime_error(""),*(?1*)0' requires stdexcept;

  publish "WILL BE DEPRECATED, these don't work right"
  fun fail_fun[t]:string->t = 'throw std::runtime_error($1),*(?1*)0' requires stdexcept;

  publish "Felix procedural continuation type"
  _gc_pointer type cont = "flx::rtl::con_t*";

  publish "Current continuation"
  fun current_continuation: 1 -> cont = "this";

  publish "Felix fthread"
  _gc_pointer type fthread = "flx::rtl::fthread_t*";

 
  publish """
    Throw a continuation. This is unsafe. It should
    work from a top level procedure, or any function
    called by such a procedure, but may fail
    if thrown from a procedure called by a function.
    The library run and driver will catch the
    continuation and execute it instead of the
    current continuation. If the library run is used
    and the continuation being executed is down the
    C stack, the C stack will not have been correctly
    popped. Crudely, nested drivers should rethrow
    the exception until the C stack is in the correct
    state to execute the continuation, but there is no
    way to determine that at the moment.

    Compiler generated runs ignore the exception,
    the library run catches it. Exceptions typically
    use a non-local goto, and they cannot pass across
    a function boundary.
  """
  proc throw(x: unit->void) { _throw (C_hack::cast[cont] x); }
  private proc _throw: cont = "throw $1;";

  // THESE VALUES MUST SYNC WITH THE RTL
  union svc_req_t =
  /*0*/ | svc_yield                          
  /*1*/ | svc_get_fthread         of ptr[fthread] 
  /*2*/ | svc_read                of address              
  /*3*/ | svc_general             of &address          
  /*4*/ | svc_reserved1
  /*5*/ | svc_spawn_pthread       of fthread
  /*6*/ | svc_spawn_detached      of fthread
  /*7*/ | svc_sread               of _schannel * &gcaddress
  /*8*/ | svc_swrite              of _schannel * &gcaddress
  /*9*/ | svc_kill                of fthread 
  /*10*/ | svc_compact
  /*11*/ | svc_collect
  /*12*/ | svc_collect_and_compact
  ;

  publish "Call Supervisor"
  // this interface just gets rid of the horrible requirement
  // the request be in a variable so it is addressable
  proc svc(x:svc_req_t) {
    var y=x;
    _svc y;
  }

  _gc_pointer type schannel[t] = "flx::rtl::schannel_t*";
  private _gc_pointer type _schannel = "flx::rtl::schannel_t*";
  fun mk_schannel[t]: 1->schannel[t] = 
    "new(*PTF gc,flx::rtl::schannel_ptr_map) flx::rtl::schannel_t(PTF gc)"
  ; 

  proc _read[t](chan:schannel[t],loc:&gcptr[t]) {
    svc$ svc_sread$ cast[_schannel] chan, reinterpret[&gcaddress] loc;
  }

  proc read[t](v:&t,chan:schannel[t]) {
    var x: gcptr[t];
    _read(chan,&x);
    *v = *x;
  }

  proc write[t](chan:schannel[t],v:t) {
    var ps = cast[gcaddress]$ xnew v;
    svc$ svc_swrite$ cast[_schannel] chan, &ps;
  }

  publish "Read primitive"
  // finds the machine address of the read buffer
  // then does a supervisor read specifying that address
  proc read[t](x:&t) { 
    val vadr : address = C_hack::as_address$ C_hack::unref x;
    req  := svc_read vadr;
    svc req;
  }

  private fun _start[t]: (t->0)*t->cont = "$1->clone()->call(0,$2)";
  fun start[t] (p:t->0) (x:t) = { return _start (p,x); }
  private fun _start0: (1->0)->cont = "$1->clone()->call(0)";
  fun start (p:1->0) = { return _start0 (p); }

  fun mk_thread: cont->fthread = "new(*PTF gc,_fthread_ptr_map) flx::rtl::fthread_t($1)";

  proc spawn_fthread(p:1->0)
  {
      var con = start p;              // get continuation of p
      var fthr = mk_thread con;
      svc$ svc_spawn_detached fthr;
  }

  publish "Resume a continuation until it yields"
  fun step: cont -> cont = "$1->resume()";
  proc kill: fthread = "$1->cc = 0;";

  publish """
  Run a continuation until it terminates.
  Do not use this proc if the underlying
  procedure attempts to read messages.
  
  This is a low level primitive, bypassing fthreads.
  """
  proc run: cont = 
  """
  {
    flx::rtl::con_t *tmp=$1;
    //if(!tmp)
    //  throw flx::rtl::flx_exec_failure_t (__FILE__,"run","Run terminated procedure");
    while(tmp) {
      try { tmp=tmp->resume(); }
      catch (flx::rtl::con_t *x) { tmp = x; }
    }
  }
  """;

  private proc _send[t]: &cont * t = 
  """
  {
    using namespace flx::rtl;
    con_t *tmp = *(con_t**)$1.get_data();
    // run target until it reaches a service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // check it is alive and making the expected service request
    if (!tmp) 
      throw flx_exec_failure_t (__FILE__,"send","Send to terminated procedure");
    if (!tmp->p_svc) 
      throw flx_exec_failure_t (__FILE__,"send","Send to unready Procedure");
    if (tmp->p_svc->variant != svc_read) 
      throw flx_exec_failure_t (__FILE__,"send","Send to Procedure which is not trying to read");
    // store the message
    **(?1**)tmp->p_svc->data= $2;
    // clear the service request
    tmp->p_svc = 0;
    // run the target until the next service request (or death)
    while(tmp && (!tmp->p_svc || tmp->p_svc->variant == svc_yield)) {
      try { tmp=tmp->resume(); }
      catch (con_t *x) { tmp = x; }
    }
    // save the new continuation
    *(con_t**)$1.get_data() = tmp;

  }
  """;

  publish """Send a message to a continuation.
  There is no type checking on the message type.
  The procedure is executed until
  the next wait_state, then the message is stored.

  Low level primitive, bypassing fthreads.
  """
  proc send[t] (p:&cont) (x:t)
  {
    _send (p,x);
  }

  publish """
  Invoke the garbage collector inside a procedure run
  by the top level (external) driver.

  Don't call this procedure in a procedure which is run
  with 'run', because such procedures do not link to their
  caller with frame pointers -- unless of course a such a
  procedure has a private collector.

  Note procedure called by functions are run with 
  code equivalent to 'run'.
  """
  proc collect() { svc svc_collect; }

}

@#------------- List -------------------
publish "List manipulation"
module List
{
  union list[T] = | Empty | Cons of T * list[T];

  fun _ctor_list[T, N] (x:Array::array[T, N]) = {
    var o = Empty[T];
    var i : int;

    forall i in Array::len(x) - 1 downto 0 do
      o = add(x.[i], o);
    done;

    return o;
  }

  fun len[T] : list[T] -> int =
    | Empty => 0
    | Cons (_,?t) => 1 + len t
  ;

  fun is_empty[T] : list[T] -> 2 =
    | Empty => true
    | _ => false
  ;

  fun map[T,U] (_f:T->U) (x:list[T]): list[U] = {
    return
      match x with
      | Empty[T] => Empty[U]
      | Cons[T] (?h, ?t) => Cons (_f(h), map[T,U] _f t)
      endmatch
    ;
  }

  noinline fun rev[T] (x:list[T]):list[T]= {
    fun aux (x:list[T]) (y:list[T]) : list[T] =
    {
      return 
        match x with
        | Empty[T] => y
        | Cons[T] (?h, ?t) => aux t (Cons (h, y))
        endmatch
      ;
    }
    return aux x Empty[T];
  }

  proc iter[T] (_f:T->void) (x:list[T]) {
    match x with
    | Empty[T] => {} 
    | Cons[T] (?h,?t) => { _f h; iter _f t; }
    endmatch
    ;
  }

  fun fold_left[T,U] (_f:U->T->U) (init:U) (x:list[T]):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_left _f (_f init h) t
      endmatch
    ;
  }

  fun fold_right[T,U] (_f:T->U->U) (x:list[T]) (init:U):U =
  {
    return
      match x with
      | Empty[T] => init
      | Cons[T] (?h,?t) => fold_right _f t (_f h init)
      endmatch
    ;
  }

  fun range (low:int, high:int, step:int) =
  {
    fun inner(low:int, high:int, step:int, values:list[int]) =
    {
      return
        if high < low
          then values
          else inner(low, high - step, step, Cons(high, values))
          endif
      ;
    }
  
    // reverse low and high so we can do negative steps
    lo, hi, s := if low < high
      then low, high, step
      else high, low, -step
      endif;
  
    // adjust the high to be the actual last value so we don't
    // have to reverse the list
    n := hi - lo - 1;
  
    return if s <= 0
      then Empty[int]
      else inner(lo, lo + n - (n % s), s, Empty[int])
      endif
    ;
  }

  fun range (low:int, high:int) => range(low, high, 1);

  fun range (num:int) => range(0, num, 1);
  
  noinline fun join[T] (x:list[T]) (y:list[T]):list[T] = 
  {
    return
      match x with
      | Empty[T] => y
      | Cons[T] (?h,?t) => Cons (h, join t y)
      endmatch
    ;
  }

  fun add[T] (x:list[T], y: list[T]):list[T] => join x y;

  fun add[T] (x:T, y: list[T]):list[T] => Cons (x, y);

  // very slow, adding to end ..
  noinline fun add[T] (x:list[T], y: T):list[T] => rev$ Cons (y, rev x);

  noinline fun cat[T] (x:list[list[T]]):list[T] =
  {
     return 
       match x with
       | Empty[list[T]] => Empty[T]
       | Cons[list[T]] (?h,?t) => fold_left join of (list[T]) h t
       endmatch
     ;
   }

  fun cat (sep:string) (x:list[string]):string = 
  {
    return
      match x with
      | Empty[string] => ''
      | Cons[string] (?h, ?t) => 
          fold_left (fun (a:string) (b:string) => a + sep + b) h t
      endmatch
    ;
  }

  fun mem[T, U] (eq:T * U -> bool) (x:list[T]) (e:U) : bool =>
    match x with 
    | Empty => false
    | Cons (?h,?t) => if eq (h, e) then true else mem eq t e endif
    endmatch
  ;

  fun mem[T] (eq:T -> bool) (x:list[T]) : bool =>
    match x with
      | Empty => false
      | Cons (?h,?t) => if eq(h) then true else mem eq t endif
    endmatch
  ;

  fun find[T, U] (eq:T * U -> bool) (x:list[T]) (e:U) : opt[T] =>
    match x with
      | Empty => None[T]
      | Cons (?h,?t) => if eq(h, e) then Some h else find eq t e endif
    endmatch
  ;

  fun find[T] (eq:T -> bool) (x:list[T]) : opt[T] =>
    match x with
      | Empty => None[T]
      | Cons (?h,?t) => if eq(h) then Some h else find eq t endif
    endmatch
  ;

  noinline fun filter[T] (P:T -> bool) (x:list[T]) : list[T] = 
  {
    fun aux (inp:list[T], out: list[T]) =>
      match inp with
      | Empty => rev out
      | Cons(?h,?t) => 
        if P(h) then aux(t,Cons(h,out))
        else aux (t,out)
        endif
      endmatch
    ;
    return aux (x,Empty[T]);
  }
  
  fun prepend_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] =>
    if mem eq x e then x else Cons (e,x) endif 
  ;

  fun insert_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] =>
    if mem eq x e then x else rev$ Cons (e,rev x) endif
  ;

  fun remove[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] =>
    filter (fun (y:T) => not eq (e,y)) x
  ;

  noinline fun append_unique[T] (eq: T * T -> bool) (x:list[T]) (e:T) : list[T] = { 
    fun aux (inp:list[T], out: list[T]) =>
      match inp with
      | Empty => rev$ Cons(e,out)
      | Cons(?h,?t) => 
        if not eq (h, e) then aux(t,Cons(h,out))
        else aux (t,out)
        endif
      endmatch
    ;
    return aux (x,Empty[T]);
  } 
}

publish "Association Lists (lists of pairs)"
module Assoc_list
{
  typedef assoc_list[A,B] = List::list[(A,B)];
}

@#------------- Array -------------------
publish "Array manipulation"

module Array 
{
  publish "Array type"
  typedef array[t,n] = t ^ n;

  publish "Array access: works on LHS of assignment too"
  fun subscript[t,n]: array[t, n] * int -> t = "$1.data[$2]";
  fun subscript[t,n]: lvalue[array[t, n]] * int -> lvalue[t] = "$1.data[$2]";

  publish "Explicit array store function"
  proc store[t,n]: &array[t,n] * int * t = "((?1*)($1.get_data()))[$2]=$3;";

  fun len[T, N] (x:array[T, N]): int => Typing::memcount[N];

  fun map[T, N, U] (_f:T->U) (x:array[T, N]): array[U, N] = {
    var o : array[U, N];
    var i : int;
    forall i in 0 upto len(x) - 1 do
      o.[i] = _f x.[i];
    done;

    return o;
  };

  fun rev[T, N] (x:array[T, N]): array[T, N] = {
    var o : array[T, N];
    var i : int;

    val length = len x;

    forall i in 0 upto length - 1 do
      o.[length - 1 - i] = x.[i];
    done;

    return o;  
  }

  proc iter[T, N] (_f:T->void) (x:array[T, N]) {
    var i : int;
    forall i in 0 upto len(x) - 1 do
      _f x.[i];
    done;
  }

  fun fold_left[T, N, U] (_f:U->T->U) (init:U) (x:array[T, N]): U = {
    var o = init;
    var i : int;

    forall i in len(x) - 1 downto 0 do 
      o = _f o x.[i];
    done;

    return o;
  }

  fun fold_right[T, N, U] (_f:T->U->U) (x:array[T, N]) (init:U): U = {
    var o = init;
    var i : int;
    val length = len x;

    forall i in 0 upto len(x) - 1 do 
      o = _f x.[i] o;
    done;

    return o;
  }

/*
  fun join[T, N, M] (x:array[T, N]) (y:array[T, M]):array[T, _flatten(N + M)] = {
    var o = array[T, _flatten(N + M)];
    val i : int;

    forall i in 0 upto len(x) - 1 do
      o.[i] = x.[i];
    done;

    val j : int;

    forall k in 0 upto len(y) - 1 do
      o.[i + j] = y.[i];
    done;

    return o;
  }
*/

  fun mem[T, N] (eq:T*T->bool) (x:array[T, N]) (e:T): bool = {
    var i : int;
    forall i in 0 upto len(x) - 1 do
      if eq(x.[i], e) do
        return true;
      done;
    done;

    return false;
  }

  fun mem[T, N] (eq:T->bool) (x:array[T, N]): bool = {
    var i : int;
    forall i in 0 upto len(x) - 1 do
      if eq(x.[i]) do
        return true;
      done;
    done;

    return false;
  }

  fun find[T, N] (eq:T*T->bool) (x:array[T, N]) (e:T): opt[T] = {
    var i : int;
    forall i in 0 upto len(x) - 1 do
      if eq(x.[i], e) do
        return Some x.[i];
      done;
    done;

    return None[T];
  }

  fun find[T, N] (eq:T->bool) (x:array[T, N]): opt[T] = {
    var i : int;

    forall i in 0 upto len(x) - 1 do
      if eq(x.[i]) do
        return Some x.[i];
    done;
    done;

    return None[T];
  }
}

publish "Bounded Variable length arrays"

module Varray
{
   _gc_pointer _gc_type t type varray[t] = "?1*";

   fun mk_array[t]: size -> varray[t] = "new(*PTF gc,@?1,(unsigned long)$1) ?1[$1]";

   fun len[t]: varray[t] -> size = "flx::gc::generic::get_count($1)";

   private // unsafe!
   proc set_length[t]: size * varray[t] = 
     """
     { 
       unsigned long newcount = $1;
       unsigned long oldcount = flx::gc::generic::get_count($2);
       flx::gc::generic::reset_count(newcount,$2);
       while(oldcount < newcount) ::new($2+oldcount++) ?1;
       while(oldcount > newcount) ($2+oldcount--)->~?1;
     }
     """;
}

@#------------- Lexer -------------------
// This module provides functions to 
// use in conjunction with the reglex construction
module Lexer
{
  pod type iterator = "char const*";
  fun start_iterator : lvalue[string] -> iterator = "$1.data()";
  fun end_iterator: lvalue[string] -> iterator = "$1.data()+$1.size()";
  fun bounds (x:lvalue[string]): iterator * iterator = {
    return 
      start_iterator x,
      end_iterator x
    ;
  }
  fun string_between: iterator * iterator -> string =
   "std::string($1,$2)";

  gen_cmp iterator;

  fun add: iterator * int -> iterator = "$1 + $2";
  fun sub: iterator * int -> iterator = "$1 - $2";
  fun sub: iterator * iterator -> int = "$1 - $2";
  proc pre_incr: lvalue[iterator] = "++$1;";
  proc post_incr: lvalue[iterator] = "++$1;";
  fun deref: iterator -> char = "*$1";

}

// ------ Open common modules -------------
//open Bool;
//open Int;
//open Double;
//open Char;
//open String;
open Array;
//open Stdout;
open Arith_casts;
open Control;
open Cstdio;

@head(1,'Stl library')
@h=tangler('lib/stl.flx','data')
@select(h)
#include <flx_categories.flxh>

include "std";
header std_stl_vector = "#include <vector>";
header std_stl_list = "#include <list>";
header std_stl_deque = "#include <deque>";
header std_stl_queue = "#include <queue>";
header std_stl_set = "#include <set>";
header std_stl_map = "#include <map>";
header std_stl_stack = "#include <stack>";
@if HAVE_STL_GNU_CXX:
  tangle('header ext_hash_set = "#include <ext/hash_set>";')
  tangle('header ext_hash_map = "#include <ext/hash_map>";')
  tangle('header ext_slist = "#include <ext/slist>";')

// hash for std::string for use with hash containers
header ext_string_hash = """
  namespace __gnu_cxx {
    template<> struct hash<std::string> { 
      size_t operator()(std::string const& s)const;
    };
  }
""";

body ext_string_hash = """
// this is a sick hash .. fix it!
size_t __gnu_cxx::hash<std::string>::
  operator()(std::string const& s)const {
    char const *p = s.data();
    int n = s.size();
    int h = 0;
    for(; n; --n,++p) h+= 5 * *p;
    return h;
  }
""";

@#------------- STL CONTAINERS -----------------------
@def gen_pcmp(t):
  tangle('    gen_cmp '+t+';') 

@def gen_peq(t):
  tangle('    gen_eq '+t+';')

@def mkseq(n,ns='std'):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'

  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1>";')
  tangle('    fun create : unit -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>())";')
  tangle('    fun create : int * t -> '+c+'= "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>($1,$2))";')
  tangle('    fun create[i] : i * i -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>($1,$2))";')
  gen_pcmp(c)
  tangle('    fun len: '+c+' -> int = "$1.size()";')
  tangle('    fun empty: '+c+' -> int = "$1.empty()";')

  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1>::iterator";');
  gen_pcmp(it)

  tangle('    gen_forward '+it+';')
  tangle('    fun deref : '+it+' ->  lvalue[t]  = "*$1";')

  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    proc erase : '+c+' * '+it+' = "$1.erase($1);";')
  tangle('    proc erase : '+c+' * '+it+' * '+it+' = "$1.erase($1,$2);";')
  tangle('    proc clear : '+c+' = "$1.clear();";')

  tangle('    proc pre_incr : lvalue['+it+'] = "++$1;";')
  tangle('    proc post_incr : '+it+' = "++$1;";')
  tangle('    proc pre_decr : lvalue['+it+'] = "--$1;";')
  tangle('    proc post_decr : '+it+' = "--$1;";')

@def mkrseq(n,ns='std'):
  mkseq(n,ns)
  c = 'stl_'+n+'[t]'
  rit = 'stl_'+n+'_reverse_iterator[t]'
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1>::reverse_iterator";');
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')
  tangle('    fun deref : '+rit+' ->  lvalue[t]  = "*$1";')
  gen_pcmp(rit)
  tangle('    proc pre_incr : lvalue['+rit+'] = "++$1;";')
  tangle('    proc post_incr : '+rit+' = "++$1;";')
  tangle('    proc pre_decr: lvalue['+rit+'] = "--$1;";')
  tangle('    proc post_decr : '+rit+' = "--$1;";')



@def mkinsat(n):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'
  tangle('    proc insert: '+c+' * '+it+' *  t  = "$1.insert($2,$3);";')

@def mkpuf(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc push_front : '+c+' *  t  = "$1.push_front($2);";')

@def mkpub(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc push_back : '+c+' *  t  = "$1.push_back($2);";')

@def mkpof(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc pop_front : '+c+' = "$1.pop_back();";')

@def mkpob(n):
  c = 'stl_'+n+'[t]'
  tangle('    proc pop_back : '+c+' = "$1.pop_back();";')

@def mkfront(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun front : '+c+' -> t = "$1.front()";')

@def mkback(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun front : '+c+' -> t = "$1.front()";')

@def mksub(n):
  c = 'stl_'+n+'[t]'
  tangle('    fun subscript : lvalue['+c+'] * int -> lvalue[t] = "$1.at($2)";')
  tangle('    fun subscript : '+c+' * int -> t = "$1.at($2)";')

@def mkset(n,ns='std'):
  c = 'stl_'+n+'[t]'
  it = 'stl_'+n+'_iterator[t]'
  rit = 'stl_'+n+'_reverse_iterator[t]'
  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1>";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1>::iterator";')
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1>::reverse_iterator";')
  tangle('    fun create : unit -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1>())";')
  tangle('    gen_cmp '+c+';')
  tangle('    fun len: '+c+'->int = "$1.size()";')
  tangle('    fun empty: '+c+'->int = "$1.empty()";')
  tangle('    gen_cmp '+it+';')
  tangle('    gen_cmp '+rit+';')
  tangle('    proc pre_incr : lvalue['+it+'] = "++$1;";')
  tangle('    proc post_incr : '+it+' = "++$1;";')
  tangle('    proc pre_incr : lvalue['+rit+'] = "++$1;";')
  tangle('    proc post_incr : '+rit+' = "++$1;";')
  tangle('    proc pre_decr : lvalue['+it+'] = "--$1;";')
  tangle('    proc post_decr : '+it+' = "--$1;";')
  tangle('    proc pre_decr: lvalue['+rit+'] = "--$1;";')
  tangle('    proc post_decr : '+rit+' = "--$1;";')
  tangle('    fun deref : '+it+' ->  t  = "*(#0*)&*$1:unary" is unary;')
  tangle('    fun deref : '+rit+' ->  t  = "*(#0*)&*$1:unary" is unary;')

  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')

  tangle('    proc insert : '+c+' * t = "$1.insert($2);";')
  tangle('    proc erase : '+c+' * '+it+' = "$1.erase($1);";')
  tangle('    proc clear : '+c+' = "$1.clear();";')
  tangle('    fun find : '+c+' * t ->  '+it+' = "$1.find($2)";')
  tangle('    fun mem : '+c+' * t -> bool = "$1.find($2) != $1.end()";')

@def mkass(n,ns='std'):
  c = 'stl_'+n+'[k,v]'
  it = 'stl_'+n+'_iterator[k,v]'
  rit = 'stl_'+n+'_reverse_iterator[k,v]'
  tangle('    type stl_'+n+' = "'+ns+'::'+n+'<?1,?2>";')
  tangle('    type stl_'+n+'_iterator = "'+ns+'::'+n+'<?1,?2>::iterator";')
  tangle('    type stl_'+n+'_reverse_iterator = "'+ns+'::'+n+'<?1,?2>::reverse_iterator";')

  tangle('    fun create : unit -> '+c+' = "(FLX_GXX_PARSER_HACK '+ns+'::'+n+'<?1,?2>())";')
  tangle('    gen_cmp '+c+';')
  tangle('    fun len: '+c+'->int = "$1.size()";')
  tangle('    fun empty: '+c+'->int = "$1.empty()";')
  tangle('    gen_cmp '+it+';')
  tangle('    gen_cmp '+rit+';')
  tangle('    proc pre_incr : '+it+' = "++$1;";')
  tangle('    proc post_incr : '+it+' = "++$1;";')
  tangle('    proc pre_incr : '+rit+' = "++$1;";')
  tangle('    proc post_incr : '+rit+' = "++$1;";')
  tangle('    proc pre_decr : '+it+' = "--$1;";')
  tangle('    proc post_decr : '+it+' = "--$1;";')
  tangle('    proc pre_decr : '+rit+' = "--$1;";')
  tangle('    proc post_decr : '+rit+' = "--$1;";')
  tangle('    fun deref : '+it+' ->  k * lvalue[v]  = "*(#0*)&*$1:unary" is unary;')
  tangle('    fun begin : '+c+'-> '+it+'= "$1.begin()";')
  tangle('    fun end : '+c+'-> '+it+'= "$1.end()";')
  tangle('    fun deref : '+rit+' ->  k * lvalue[v]  = "*(#0*)&*$1:unary" is unary;')
  tangle('    fun rbegin : '+c+'-> '+rit+'= "$1.rbegin()";')
  tangle('    fun rend : '+c+'-> '+rit+'= "$1.rend()";')
  tangle('    proc insert : '+c+' * k * v = "$1.insert(std::make_pair($2,$3));";')
  tangle('    proc erase : '+c+' * '+it+' = "$1.erase($1);";')
  tangle('    proc clear : '+c+' = "$1.clear();";')
  tangle('    fun find : '+c+' * k ->  '+it+' = "$1.find($2)";')
  tangle('    fun mem : '+c+' * k -> bool = "$1.find($2) != $1.end()";')
   
  tangle('    fun subscript: '+c+' * k -> lvalue[v] = "$1[$2]";')

module Stl 
{
  type pair[k,v] = "std::pair<?1 const,?2>";
  fun make_pair[k,v]: k * v ->pair[k,v] = "std::make_pair($1,$2)";

  module Vector[t]
  {
    requires std_stl_vector;
@mkrseq('vector')
@mkinsat('vector')
@mkpub('vector')
@mkfront('vector')
@mkback('vector')
@mksub('vector')
    fun add: stl_vector_iterator[t] * int -> stl_vector_iterator[t] = "$1+$2";
    fun sub: stl_vector_iterator[t] * int -> stl_vector_iterator[t] = "$1-$2";
    proc pluseq: lvalue[stl_vector_iterator[t]] * int = "$1+=$2;";
    proc minuseq: lvalue[stl_vector_iterator[t]] * int -> stl_vector_iterator[t] = "$1-=$2;";
    fun subscript: stl_vector_iterator[t] * int -> lvalue[t] = "$1[$2]";
  }
  module List[t]
  {
    requires std_stl_list;
@mkrseq('list')
@mkinsat('list')
@mkpuf('list')
@mkpub('list')
@mkfront('list')
@mkback('list')
@mkpof('list')
  }
  module Queue[t]
  {
    requires std_stl_queue;
@mkseq('queue')
@mkinsat('queue')
  }
  module Deque[t]
  {
    requires std_stl_deque;
@mkrseq('deque')
@mkinsat('deque')
@mkpuf('deque')
@mkpub('deque')
@mkpof('deque')
@mkfront('deque')
@mkback('deque')
@mksub('deque')
  }
  module PriorityQueue[t]
  {
    requires std_stl_queue;
@mkseq('priorityqueue')
  }
  module Stack[t]
  {
    requires std_stl_stack;
@mkseq('stack')
  }

  module Set[t]
  {
    requires std_stl_set;
@mkset('set')
  }
  module MultiSet[t]
  {
    requires std_stl_set;
@mkset('multiset')
  }
  module Map[k,v]
  {
    requires std_stl_map;
@mkass('map')
  }
  module MultiMap[k,v]
  {
    requires std_stl_map;
@mkass('multimap')
  }

@if HAVE_STL_GNU_CXX:
  tangle('  module Slist[t]')
  tangle('  {')
  tangle('    requires ext_slist;')
  mkseq('slist','__gnu_cxx')
  mkpuf('slist')
  mkfront('slist')
  mkpof('slist')
  tangle('    proc insert_after : stl_slist[t] * stl_slist_iterator[t] *  t  = "$1.insert_after($2,$3);";')
  tangle('    proc erase_after : stl_slist[t] * stl_slist_iterator[t] = "$1.erase_after($1);";')
  tangle('  }')

@if HAVE_STL_GNU_CXX:
  tangle('// HASHTABLE based containers assume')
  tangle('// these classes will be added to C++ via TR1 in the future.')
  tangle('// g++ 3.2.2 at least has these classes')
  tangle('// The free SGI implementation may suffice as a replacement,')
  tangle('// this is what my version of g++ uses.')
  tangle('')
  tangle('  module HashSet[t]')
  tangle('  {')
  tangle('    requires ext_hash_set;')
  mkset('hash_set','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMultiSet[t]')
  tangle('  {')
  tangle('    requires ext_hash_set;')
  mkseq('hash_multiset','__gnu_cxx')
  tangle('  }')
  tangle('  module HashMap[k,v]')
  tangle('  {')
  tangle('    requires ext_hash_map;')
  mkass('hash_map','__gnu_cxx')    
  tangle('  }')
  tangle('  module HashMultiMap[k,v]')
  tangle('  {')
  tangle('    requires ext_hash_map;')
  mkass('hash_multimap','__gnu_cxx')    
  tangle('  }')
}
