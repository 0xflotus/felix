@head(1,'Felix Standard Library')
@h=tangler('lib/std.flx')
@select(h)
header """
#include <stddef.h>
#include <cmath>
#include <iostream>
#include <string>
#include <assert.h>
#include <limits.h>

// BOOST IS REQUIRED FOR FELIX NOW
#include <boost/cstdint.hpp>

#ifdef BOOST_NO_INT64_T
namespace boost {
  typedef long long int64_t;
  typedef unsigned long long uint64_t;
}
#endif

using namespace std;

namespace std_flx {
  inline string mul(string s, int n) {
    string r = "";
    while(n--) r+=s;
    return r;
  }

  // normalise string positions Python style
  // note substr requires 0<=b<=size, 0<=n,
  // however n>size is OK
  inline string substr(string const &s, int b, int e)
  {
    int n = s.size();
    if(b<0)  b=b+n;
    if(b<0)  b=0;
    if(b>=n) b=n;
    if(e<0)  e=e+n;
    if(e<0)  e=0;
    if(e>=n) e=n;
    int m =  e-b;
    if(m<0)  m=0;
    return s.substr(b,m);
  }
}
""";

@tmap = {
  # addressing
  "byte"    : "unsigned char",
  "size"    : "size_t",
  "address" : "void *",
  "offset"  : "ptrdiff_t",
  
  #characters
  "char"    : "char",
  "wchar"   : "wchar_t",
  "uchar"   : "int32_t", # Unicode/ISO10646, note: SIGNED!

  #bool
  "bool"    : "bool",
  
  #signed integers
  "tiny"    : "signed char",
  "short"   : "short",
  "int"     : "int",
  "long"    : "long",
  "vlong"   : "long long",

  #unsigned integers
  "utiny"   : "unsigned char",
  "ushort"  : "unsigned short",
  "uint"    : "unsigned int",
  "ulong"   : "unsigned long",
  "uvlong"  : "unsigned long long",

  #exact integers
  "int8"    : "boost::int8_t",
  "int16"   : "boost::int16_t",
  "int32"   : "boost::int32_t",
  "int64"   : "boost::int64_t",
  "uint8"   : "boost::uint8_t",
  "uint16"  : "boost::uint16_t",
  "uint32"  : "boost::uint32_t",
  "uint64"  : "boost::uint64_t",

  #floating
  "float"   : "float",
  "double"  : "double",
  "ldouble"  : "long double",
  }

@chars = ["char", "wchar"]
@sints = [
  "tiny", "short", "int", "long", "vlong",
  "int8","int16","int32","int64"
  ]
@uints = [
  "utiny", "ushort", "uint", "ulong","uvlong",
  "uint8","uint16","uint32","uint64"
  ]
@floats = ["float", "double"]
@all = ["byte", "size","address","offset","bool"] + chars + sints + uints + floats
@ints = uints + sints

//types
@for ft in all:
  tangle('type '+ft+' = "'+tmap[ft]+'";')

//
//assignment, equality, inequality
@for t in all:
  tangle('//')
  tangle('//'+t)
  tangle('proc set: &'+t+' * '+t+' = "*$1=$2;";')
  tangle('fun eq: '+t+' * '+t+' -> bool = "$1==$2";')
  tangle('fun ne: '+t+' * '+t+' -> bool = "$1!=$2";')

// comparisons
@for t in chars + ints + floats + ["bool","size","offset","address"]:
  tangle('//')
  tangle('//'+t)
  for opname,op in [
    ("lt","<"),
    ("le","<="),
    ("gt",">"),
    ("ge",">=")
  ]:
    tangle('fun '+opname+': '+t+' * '+t+' -> bool = "$1'+op+'$2";')

//
// bool
const true : bool = "true";
const false : bool = "false";
fun land: bool * bool -> bool = "$1 && $2";
fun nand: bool * bool -> bool = "!($1 && $2)";
fun lor: bool * bool -> bool = "$1 || $2";
fun nor: bool * bool -> bool = "!($1 || $2)";
fun xor: bool * bool -> bool = "$1 != $2";
fun lnot: bool -> bool = "!$1";
proc assert: bool = "assert($1);";

//
//general arithmetic
@for t in ints + floats:
  tangle('//')
  tangle('//'+t)
  for opname,op in [
    ("add","+"),
    ("sub","-"),
    ("mul","*"),
    ("div","/")
  ]:
    tangle('fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

//
// modulus/remainder
@for t in ints:
  for opname,op in [
    ("mod","%")
  ]:
    tangle('fun '+opname+': '+t+' * '+t+' -> '+t+' = "$1'+op+'$2";')

//
// prefix negation 
@for t in ints + floats:
  tangle('fun neg: '+t+' -> '+t+' = "-$1";')
  tangle('fun pos: '+t+' -> '+t+' = "+$1";')

//
// floating math: C99 
@fc = {'float':'f', 'double':'','ldouble':'l'}
// R * R -> R
@for t in floats:
  for op in [
    'pow',
    'atan2',
    'fmod',
    'fmax','fmin'
    ]:
    tangle('fun '+op+': '+t+' * '+t+' -> '+t+' = "'+op+fc[t]+'($1, $2)";')
// R -> R
@for t in floats:
  for op in [
    'sin','cos','tan',
    'asin','acos','atan',
    'sinh','cosh','tanh',
    'asinh','acosh','atanh',
    'exp', 'log','log10',
    'fabs','sqrt',
    'ceil','floor','trunc'
    ]:
    tangle('fun '+op+': '+t+' -> '+t+' = "'+op+fc[t]+'($1)";')


//
// increment, decrement
@for t in ints:
  tangle('proc pre_incr:  &'+t+' = "++*$1;";')
  tangle('proc pre_decr:  &'+t+' = "--*$1;";')
  tangle('proc post_incr: &'+t+' = "++*$1;";')
  tangle('proc post_decr: &'+t+' = "--*$1;";')
  
//
// casts
@for t1 in ints+floats:
  tangle('//')
  tangle('//'+t1)
  for t2 in ints+floats:
    tangle('fun '+t1+'_of: '+t2+' -> '+t1+' = "('+tmap[t1]+')$2";')

// ordinary value of chars
fun ord: char -> uint = "(int)$1";
fun ord: wchar -> ulong ="(long)$1";


// chars of ordinals
fun chr: uint -> char = "(char)$1";
fun wchr: ulong -> wchar = "(wchar_t)$1";

// output
@for t in all:
  if t not in ['tiny','utiny','bool']:
    tangle('proc print: '+t+' = "std::cout<<$1;";')

// cast tiny values, so they're not printed as characters
proc print: tiny = "std::cout << (int)$1;";
proc print: utiny = "std::cout << (unsigned int)$1;";
proc print: bool = 'std::cout << ($1?"true":"false");';

proc endl: unit = "std::cout << endl;";
proc space: int = "std::cout << ' ';";

// strings
type string = "string";
proc set: &string * string = "$1->assign($1);";
proc pluseq: &string * string = "$1->append($2);";

fun len: string -> int = "$1.size()";
fun add: string * string -> string = "$1+$2";
fun mul: string * int -> string = "std_flx::mul($1,$2)";
fun mul: char * int -> string = "string($2,$1)";

fun subscript: string * int -> char = 
  "$1[$2<0?$1.size()+$2:$2]";
fun copyfrom: string * int -> string = 
  "std_flx::substr($1,$2,$1.size())";
fun copyto: string * int -> string = 
  "std_flx::substr($1,0,$2)";
fun substring: string * int * int -> string = 
  "std_flx::substr($1,$2,$3)";

// comparisons
fun eq: string * string -> bool = "$1==$2";
fun ne: string * string -> bool = "$1!=$2";
fun lt: string * string -> bool = "$1<$2";
fun le: string * string -> bool = "$1<=$2";
fun gt: string * string -> bool = "$1>$2";
fun ge: string * string -> bool = "$1>=$2";

proc print: string = "std::cout << $1;";


@h=tangler('lib/boost.flx')
@select(h)
// regular expressions
header """
#include <boost/regex.hpp>
//typedef boost::regex regex;
""";


type regex = "boost::regex";
fun regex_of_string : string -> regex = "boost::regex($1)";

type merge_pattern = "string";
fun merge_pattern_of_string: string->merge_pattern = "$1";

fun regex_match : regex * string -> bool 
  =  "boost::regex_match($2, $1)";

fun regex_match (r:regex) (s:string): bool 
{
  return regex_match(r,s);
}

fun regex_merge : regex * merge_pattern * string -> string
  = "boost::regex_merge($3,$1,$2, boost::match_default | boost::format_sed)";

fun regex_merge (r:regex) (m:merge_pattern) (s:string) :string
{
  return regex_merge(r,m,s);
}


