@head(1,'Maker')
@FLX_MAKER_CVS_ID='$Id$'
@print FLX_MAKER_CVS_ID
@execfile(os.path.join('config', 'flx_data.py'))
@execfile(os.path.join('cpkgs', 'build', 'interscript.py'))

@h = tangler('script/bin2hex.py','python')
@select(h)
# convert a binary file to hex 
import sys
fn = sys.argv[1]
f = open(fn)
data = f.read()
f.close()
counter = 0
for ch in data:
  print ("%02x" % ord(ch)),
  counter = counter + 1
  if counter == 8:
    print
    counter = 0
print

@h = tangler('script/fcount.py','python')
@select(h)
import glob
import os
import sys
if '' not in sys.path: sys.path = ['']+sys.path
import flxbuild
from flxbuild.flxutil import *

try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

try:
  key = sys.argv[2]
except:
  key = "std"

try:
  globspec = sys.argv[3]
except:
  globspec = "tut/examples/*.hpp"

print "function counter: STATS FILE",filename, "KEY", key, "GLOB",globspec
dict = {}
try:
  execfile (filename)
except:pass

files = glob.glob(globspec)

for file in files:
  cmd = 'egrep "//PROC|//FUNCTION" ' + file + ' | wc -l'
  output = xqt(cmd)[0][:-1]
  x = int(output)
  try:
    d= dict[file]
  except:
    dict[file]={}
    d = dict[file]
  d[key]=x

f = open(filename,"w")
f.write("dict="+repr(dict))
f.close()

@h = tangler('script/pfcount.py','python')
@select(h)
import glob
import os
import sys
try:
  filename = sys.argv[1]
except:
  filename = "fcounts.stats"

only_nonopt = 0
try:
  x = sys.argv[2]
except:
  only_nonopt = 1

dict = {}
try:
  execfile (filename)
except:pass

keys = {}
i = 0
for k in dict.keys():
  i = max(i,len(k))
  d = dict[k]
  for key in d.keys():
    keys[key]=None

keys = keys.keys()
j=0
for k in keys:
  j = max(j,len(k))

print "Function counts for test programs"
print "================================="
print
print ("%-"+str(i+2)+"s") % "File" + "    ",
for t in keys:
  print ("%"+str(j+2)+"s") % t,
print
print "--------"

skeys = dict.keys()
skeys.sort()

for k in skeys:
  d = dict[k]
  x= ("%-"+str(i+2)+"s") % k + "..  "
  discard = 0
  for t in keys:
    v = pkgdict.get(t,-1)
    if v == -1:
      v = ""
    elif (v == 1 or v == 0) and t == "inline" and only_nonopt: 
      discard = 1
      break
    else:
      v = str(v)
    v = ("%"+str(j+2)+"s") % v
    x = x+v
  if not discard: print x

@h = tangler('script/mk_expect','python')
@select(h)
import glob
import sys
for k in sys.argv[1:]:
  files = glob.glob(k+'/*.output')
  print '@head(1,"Expected outputs for '+k+'")'
  for i in files:
    j = i[:-7]+'.expect'
    print '@head(2,"'+j+'")'
    print '@select(tangler("'+j+'","data"))'
    f = open(i,"r")
    for l in f: print l,
    f.close()


@h = tangler('spkgs/tutorial.py')
@select(h)
pkg_requires = [
  'flx_tutorial',
  'flx_tut_macro',
  'flx_tut_bind',
  'flx_tut_migrate'
  ]

iscr_source = [
  'lpsrc/flx_tutorial',
  'lpsrc/flx_tut_macro',
  'lpsrc/flx_tut_bind',
  'lpsrc/flx_tut_migrate',
  ]
  
@h = tangler('spkgs/flx_maker.py')
@select(h)
iscr_source = ['lpsrc/flx_maker.pak']

weaver_directory = 'doc/flx/flx_maker/'

@h = tangler('spkgs/ocs.py')
@select(h)
OCS_MODULES = [
  'ocs_vartable', 
  'ocs_error', 
  'ocs_port', 
  'ocs_types', 
  'ocs_sym', 
  'ocs_env',
  'ocs_char', 
  'ocs_numaux', 
  'ocs_complex', 
  'ocs_num', 
  'ocs_numstr', 
  'ocs_lex',
  'ocs_misc',
  'ocs_read', 
  'ocs_eval', 
  'ocs_list', 
  'ocs_compile', 
  'ocs_macro', 
  'ocs_prim', 
  'ocs_string',
  'ocs_vector', 
  'ocs_print', 
  'ocs_io', 
  'ocs_contin', 
  'ocs_top', 
]

@h = tangler('umk','data')
@select(h)
#!/bin/sh
python script/maker $*
ec1=$?
if [ $ec1 != 0 ]; then
  exit $ec1
fi
@os.system("chmod u+x umk")

@h = tangler('mk','data')
@select(h)
#!/bin/sh
LOGFILE=mk_`date +"%Y-%m-%d-%H%M"`.log
echo "Saving transcript to $LOGFILE" | tee -a $LOGFILE

exec 3>&1
eval `exec 4>&1 >&3 3>&-
{
	(./umk $*) 4>&-; echo "ec1=$?;" >&4 
} 2>&1 | tee -a $LOGFILE
echo "ec2=$?;" >&4
`
if [ $ec1 != 0 ]; then
  exit $ec1
fi
@os.system("chmod u+x mk")

@h = tangler('mk.bat','data')
@select(h)
python script\maker %1 %2 %3 %4 %5 %6 %7 %8 %9
@select(tangler('mkplugins/man.py'))
class PLUGIN(Plugin):
  name = 'man'
  help = 'make the man pages'

  def runme(self):    
    print "GENERATING MAN PAGES"
    mp = glob.glob('man/man1/*.1')
    MAN_PAGES = []
    for i in mp:
      MAN_PAGES.append (i[9:])
    try: os.mkdir("doc/htmlman")
    except: pass
    dtd = ('<!DOCTYPE HTML PUBLIC \\"-//W3C//DTD HTML 4.0 Transitional//EN\\"\\n'+
      '  \\"http://www.w3.org/TR/REC-html40/loose.dtd\\">')
    try:
      for file in MAN_PAGES:
        basename = os.path.splitext(file)[0]
        vxqt(
          "man2html man/man1/" + file + 
          '| sed -e "s%<A HREF=\\"[^<]*cgi-bin/man/man2html?1+\(.*\)\\">%<A HREF=\\"\\1_1.html\\">%"' +
          '| sed -e "7d"' +
          '| sed -e "1,3d"' +
          '| sed -e "s%<html>%'+dtd+'\\n<html>%"' +
          ' >' + "doc/htmlman/" + basename+'_1.html',
        )
    except:pass
  
@select(tangler('mkplugins/impldoc.py'))
class PLUGIN(Plugin):
  name = 'impldoc'
  help = 'make the ocaml compiler documentation'
    
  def runme(self):    
    print "GENERATING OCAMLDOCS"
    erasedir('doc/impldoc')
    os.mkdir('doc/impldoc')
    try:
      vxqt('ocamldoc -I src -d doc/impldoc src/*.mli -html')
      vxqt('ocamldoc -I src -o doc/impldoc/flx_impl.tex src/*.mli -latex')
      vxqt('(cd doc/impldoc; latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex && latex --interaction=batchmode flx_impl.tex)')
    except: 
     pass # well ocamldoc is full of bugs ..

@select(tangler('mkplugins/rtldoc.py'))
class PLUGIN(Plugin):
  name = 'rtldoc'
  help = 'make the runtime language documentation'

  def runme(self):    
    print "GENERATING RTLDOCS"
    try:
      vxqt("doxygen misc/doxconf.dox")
    except:
      pass

@select(tangler('mkplugins/copy_mli2ml.py'))
class PLUGIN(Plugin):
  name = 'copy_mli2ml'

  def runme(self, MLIS):
    for f in MLIS:
      f = string.replace(f,"/",os.sep)
      src = f+'.mli'
      dst = f+'.ml'
      if filetime(src) >= filetime (dst):
        if not quiet: print("filecopy "+src+" -> "+dst)
        filecopy(src,dst)

@select(tangler('mkplugins/copy_hpp2rtl.py'))
class PLUGIN(Plugin):
  name = 'copy_hpp2rtl'

  def runme(self, HPPS):
    for f in HPPS:
      dst = os.path.join('rtl', os.path.basename(f))
      src = string.replace(f,"/",os.sep)
      if filetime(src) >= filetime (dst):
        if not quiet: print("filecopy "+src+" -> "+dst)
        filecopy(src,dst)

@select(tangler('mkplugins/build_ocaml_grammar.py'))
class PLUGIN(Plugin):
  name = 'build_ocaml_grammar'

  def runme(self, pkg, LEXS, PARSES, force):
    if not (LEXS or PARSES):
      return force

    print "CAML BUILDING GRAMMAR", pkg

    # STEP 2: Generate lexers
    for lex in LEXS:
      file = string.replace(lex,'/',os.sep)
      if not force:
        if filetime(file+'.mll') >= filetime(file+'.ml'): force = 1
      if force: vxqt(OCAMLLEX + file + '.mll')

    # STEP 3: Generate parsers
    for parse in PARSES:
      file = string.replace(parse,'/',os.sep)
      if not force:
        if filetime(file+'.mly') >= filetime(file+'.ml'): force = 1
      if force:
        vxqt(OCAMLYACC + ' -v '+ file + '.mly')
        nxqt(ENV + ' ' + GREP + " conflict " + file + ".output")

    if LEXS or PARSES:
      plugins['extract_grammar']()

    return force
@doc()

@select(tangler('mkplugins/build_ocaml_modules.py'))
#ocaml compilation
class PLUGIN(Plugin):
  name = 'build_ocaml_modules'
    
  def runme(self, pkg, INTERFACES, IMPLEMENTATIONS, INCLUDES, force):
    if not (INTERFACES or IMPLEMENTATIONS):
      return force

    print "CAML COMPILING", pkg

    # STEP 4: Compile ocaml interfaces
    for interface in INTERFACES:
      file = string.replace(interface,'/',os.sep)
      if not force:
        if filetime(file+'.mli') >= filetime(file+'.cmi'): force = 1
      if force:
        vxqt(OCAMLC + ' ' + INCLUDES + ' -c ' + file + '.mli')

    # STEP 5: Compile ocaml implementations
    for implementation in IMPLEMENTATIONS:
      file = string.replace(implementation,'/',os.sep)
      if not force:
        if filetime(file+'.ml') >= filetime(file + OCAML_OBJECT_EXTENSION): 
          force = 1
      if force:
        vxqt(OCAMLOPT + ' '+ INCLUDES + ' -c ' + file +'.ml')

    return force
@doc()

@select(tangler('mkplugins/build_ocaml_libraries.py'))
#ocaml compilation
class PLUGIN(Plugin):
  name = 'build_ocaml_libraries'

  def runme(self, IMPLEMENTATIONS, lib, force):
    if not IMPLEMENTATIONS:
      return force

    print "CAML CREATING LIBRARY", lib

    # STEP 6: Build Ocaml Library
    object_library_name = lib + OCAML_LIB_EXTENSION
    linkstring = OCAMLOPT + " -a -o " + object_library_name + " "
    library_filetime = filetime(object_library_name)

    force = 1
    for implementation in IMPLEMENTATIONS:
      linkstring = linkstring + implementation + OCAML_OBJECT_EXTENSION + " "
    vxqt(linkstring)

    return force
@doc()

@select(tangler('mkplugins/build_ocaml_exes.py'))
#ocaml compilation
class PLUGIN(Plugin):
  name = 'build_ocaml_exes'

  def runme(self, EXES, OLIBRARIES, INCLUDES, force):
    # finally, mainline *.cmx or cma files to link to executables
    if not EXES:
      return

    print "CAML LINKING EXECUTABLES"
    x = ''
    for library in OLIBRARIES:
      x = x + ' ' + library + OCAML_LIB_EXTENSION
  
    for exe in EXES:
      dst = os.path.join("bin", os.path.basename(exe))
      vxqt(OCAMLOPT + INCLUDES + ' -o ' + dst + \
          x + ' src/flx_version_hook.ml ' + exe + \
          OCAML_OBJECT_EXTENSION)
@doc()

@select(tangler('mkplugins/build_ocamls.py'))
class PLUGIN(Plugin):
  name = 'build_ocamls'
   
  def runme(self, pkg, pkgdict, force):
    LEXS = pkgdict.get("caml_lexes", [])
    PARSES = pkgdict.get("caml_parses", [])

    force = plugins['build_ocaml_grammar'].runme(pkg, LEXS, PARSES, force)

    INTERFACES = pkgdict.get("caml_interfaces", [])
    IMPLEMENTATIONS = pkgdict.get("caml_implementations", [])
    EXES = pkgdict.get("caml_exes", [])
    INCLUDES = pkgdict.get("caml_include_paths", ['src'])

    # prepend -I to each include
    if INCLUDES:
      for i in range(len(INCLUDES)):
        INCLUDES[i] = '-I ' + INCLUDES[i]
    INCLUDES = string.join(INCLUDES)

    force = plugins['build_ocaml_modules'].runme(pkg, INTERFACES, IMPLEMENTATIONS + EXES, INCLUDES, force)

    lib = pkgdict.get('caml_provide_lib', 'src'+os.sep+pkg+"lib")

    force = plugins['build_ocaml_libraries'].runme(IMPLEMENTATIONS, lib, force)

    OLIBRARIES = pkgdict.get("caml_require_libs", [])

    plugins['build_ocaml_exes'].runme(EXES, OLIBRARIES, INCLUDES, force)
  
    return force
@doc()

@select(tangler('mkplugins/build_host_tools.py'))
class PLUGIN(Plugin):
  name = 'build_host_tools'
    
  def runme(self, pkg, pkgdict):
    CCS = pkgdict.get("host_cc_ccs",[])
    CPPS = pkgdict.get("host_cpp_cpps",[])
    EXES = pkgdict.get("host_exes",[])
    LIBS = pkgdict.get("host_exes_require_libs",[])
    if len(CCS)+len(CPPS)+len(EXES)+len(LIBS)>0:
      print "BUILDING HOST TOOLS"
      pkglib = None

      if CCS:
        print "HOST C COMPILING", pkg
        pkglib = "lib"+pkg+"_host_static"

        HOST_C.build_static_rtl(vxqt, CCS, 'hostlib' + os.sep + pkglib,
              include_paths=["rtl", "elk"],
              macros=["FLX_STATIC_LINK"],
              )

      if CPPS:
        print "HOST C++ COMPILING", pkg
        pkglib = "lib"+pkg+"_host_static"

        HOST_CXX.build_static_rtl(vxqt, CPPS, 'hostlib' + os.sep + pkglib,
              include_paths=["rtl", "elk"],
              macros=["FLX_STATIC_LINK"],
              )

        for x in CCS+CPPS: 
          f = x + EXT_STATIC_OBJ
          if verbose: print "Removing", f
          deletefile(f) # delete the object files

      kwds = {\
          'include_paths': ["rtl", "elk"],
          'macros': ["FLX_STATIC_LINK"],
          'CFLAGS': CFLAGS,
          'LDFLAGS': SFLAGS,
          }
         
      if pkglib:
        kwds['lib_paths'] = ['hostlib']
        kwds['libs'] = [pkglib]

      for src, bin in EXES:
        apply(HOST_CXX.build_static_program, (vxqt, src, bin), kwds)
@doc()

@select(tangler('mkplugins/build_testfile.py'))
class PLUGIN(Plugin):
  name = 'build_test'

  def runme(self, testfile, log, quiet):
    if log is None: log = Tee()

    optimise_c = optimise or "optimise_c" in options
    mode = "std"
    if optimise_c: mode = "Optimised"

    log.write('TRANSLATING %s\n' % testfile,quiet)

    basename = os.path.splitext(testfile)[0]
    cppfilename = basename + ".cpp"
    resfilename = basename + ".resh"
    indir,infile = os.path.split(basename)
    try:
      flxg('-Ilib ' + FLXFLAGS + basename, log=log)
    except MakeError, e:
      log.write('TESTFILE -- ERROR! %s\n' % basename)
      erasefile(basename+'.cpp')
      erasefile(basename+'.hpp')
      raise e
  
    cflags = vxqtq(os.path.join( "bin", 
      "flx_pkgconfig --path=config --field=cflags @"+resfilename),
      log=log)
    cflags = string.strip(cflags[0]) + " "

    #log.write('Compiling generated code of %s\n' % testfile)
    try:
      if SUPPORT_DYNAMIC_LOADING:
        log.write("COMPILING GENERATED C++ TEST CODE: %s (dynamic)\n" % mode,quiet)
        flush()
 
        dlibs = vxqtq(os.path.join("bin", 
          "flx_pkgconfig --path=config --field=provides_dlib --field=requires_dlibs @"+resfilename),
          log=log)
        dlibs = string.strip(dlibs[0]) + " "
  
        TARGET_CXX.build_shared_dll(
            vxqt,
            basename,
            include_paths=["rtl"],
            optimise=optimise_c,
            debug=debug,
            CFLAGS=CFLAGS+" "+cflags,
            lib_paths=[SHLIB_DIR],
            LDFLAGS=DFLAGS+dlibs,
            log=log)
  
      if SUPPORT_STATIC_LINKAGE:
        log.write("COMPILING GENERATED C++ TEST CODE: %s (static)\n" % mode,quiet)
        flush()

        driver = vxqtq(os.path.join(
          "bin",
          "flx_pkgconfig -r --keeprightmost --path=config "
          "--field=flx_requires_driver @"+resfilename),
          log=log)
        driver = string.strip(driver[0])
        if driver == '': driver = 'flx_run'

        slibs = vxqtq(os.path.join(
          "bin",
          "flx_pkgconfig -r --keeprightmost --path=config "
          "--field=provides_slib --field=requires_slibs "+driver+" @"+resfilename),
          log=log)
        slibs = string.strip(slibs[0])
        #log.write("slibs=%s\n" % slibs)

        driver = driver + EXT_STATIC_OBJ
        driver = os.path.join("rtl",driver)
        #log.write('static driver =%s\n' % driver)

        TARGET_CXX.build_felix_static(
          vxqt,
          basename,
          objects=[driver],
          include_paths=["rtl"],
          optimise=optimise_c,
          debug=debug,
          macros=["FLX_STATIC_LINK"],
          CFLAGS=CFLAGS+" "+cflags,
          lib_paths=["rtl"],
          libs=[],
          LDFLAGS=SFLAGS+slibs,
          log=log)

      #log.write('TESTFILE -- OK! %s\n' % basename)
    except MakeError, e:
      log.write('TESTFILE -- ERROR! %s\n' % basename)
      erasefile(basename+EXT_SHLIB)
      erasefile(basename+EXT_EXE)
      raise e
  
    return basename
  

@select(tangler('mkplugins/diff_env.py'))
if os.name == 'nt': # build system is Windows Python
  DIFF = "FC /L /W"
  GREP = "#grep"
else:
  #DIFF = "diff -a -b " # build system is Unix Python
  # RF - trying out args that work on solaris (-a = not cool)
  # could use that sys type stuff here?
  DIFF = "diff -b" # build system is Unix Python
  GREP = "grep"


@select(tangler('mkplugins/build.py'))
class PLUGIN(Plugin):
  name = 'build'
  help = 'build the sources'

  def __init__(self, *args, **kwds):
    apply(Plugin.__init__, (self,) + args, kwds)
 
    if "extract" in options or "force_extract" in options: 
      if "build" not in phases: phases.append("build")

  def runme(self):
    global phases 

    if "build" not in phases: phases.append("build")
    if "host" not in phases: phases.append("host")
    if "target" not in phases: phases.append("target")


@select(tangler('mkplugins/virgin.py'))
#cleans everything
class PLUGIN(Plugin):
  name = 'virgin'
  help = 'clean and remove all the sources'
 
  def runme(self):
    for d in [ \
        os.path.join("bagley", "data"),
        os.path.join("bagley", "felix"),
        "bagley",
        "bin",
        os.path.join("cpkgs", "build"), 
        os.path.join("cpkgs", "host"), 
        os.path.join("cpkgs", "target"), 
        "cpkgs",
        os.path.join("demos", "faio"),
        os.path.join("demos", "sdl"),
        "demos",
        "demux",
        os.path.join("doc", "elkhound"),
        os.path.join("doc", "flx"),
        os.path.join("doc", "flxcc"),
        os.path.join("doc", "gmp"),
        os.path.join("doc", "grammar"),
        os.path.join("doc", "gsl"),
        os.path.join("doc", "htmlman"),
        os.path.join("doc", "impldoc"),
        os.path.join("doc", "mmap"),
        os.path.join("doc", "opengl"),
        os.path.join("doc", "refman"),
        os.path.join("doc", "rtl"),
        os.path.join("doc", "sdl"),
        os.path.join("doc", "test"),
        os.path.join("doc", "tutorial"),
        "doc",
        "elk",
        "faio",
        "flxbuild",
        "hostlib",
        "impldoc",
        os.path.join("lib", "gsl"),
        os.path.join("lib", "mpi"),
        os.path.join("lib", "pari"),
        os.path.join("lib", "GL"), 
        os.path.join("lib", "SDL"), 
        "lib",
        os.path.join("man", "man1"),
        "man",
        "manifests",
        os.path.join("meta", "godi"), 
        os.path.join("meta", "godiva"), 
        "meta",
        os.path.join("misc", "vim"),
        os.path.join("misc", "lua"),
        os.path.join("misc", "jedit"),
        "misc",
        "mkplugin",
        "oldebian",
        "pkg",
        os.path.join("pkg-stamps", "test", "regress"),
        os.path.join("pkg-stamps", "test"),
        os.path.join("pkg-stamps", "tut", "embedding"),
        os.path.join("pkg-stamps", "tut", "macros"),
        os.path.join("pkg-stamps", "tut", "migration"),
        os.path.join("pkg-stamps", "tut", "tutorial"),
        os.path.join("pkg-stamps", "tut"),
        "pkg-stamps",
        "pthread",
        "rtl",
        "script",
        os.path.join("speed", "specs"),
        os.path.join("speed", "src", "ada"),
        os.path.join("speed", "src", "c"),
        os.path.join("speed", "src", "felix"),
        os.path.join("speed", "src", "haskell"),
        os.path.join("speed", "src", "java"),
        os.path.join("speed", "src", "ocaml"),
        os.path.join("speed", "src", "pascal"),
        os.path.join("speed", "src"),
        os.path.join("speed", "xlators"),
        "speed",
        "spkgs",
        "src",
        os.path.join("src", "cil"),
        os.path.join("test", "drivers"),
        os.path.join("test", "faio"),
        os.path.join("test", "gmp"),
        os.path.join("test", "mmap"),
        os.path.join("test", "pthread"),
        os.path.join("test", "regress"),
        os.path.join("test", "tre"),
        "test",
        "tmp",
        os.path.join("tools", "lua"), 
        "tools",
        "tre",
        os.path.join("tut", "embedding"),
        os.path.join("tut", "examples"),
        os.path.join("tut", "macros"),
        os.path.join("tut", "migration"),
        os.path.join("tut", "sdl"),
        os.path.join("tut", "tutorial"),
        "tut",
        "www",
        ]:
      for f in glob.glob(os.path.join(d, "*")):
        print "Del",f
        erasefile(f)
      try: 
        if os.path.exists(d):
          os.rmdir(d)
          print "Rmdir",d
      except: 
        print "FAILED Rmdir",d
    for f in glob.glob(os.path.join(FLX_LPARCHIVE, "lpsrc", "*.cache")):
      erasefile(f)
    runISCR(os.path.join(FLX_LPARCHIVE, 'lpsrc', 'flx_config.pak'),1)
    sys.exit(0)
  
@select(tangler('mkplugins/clean.py'))
# cleans products, but not extracted sources
class PLUGIN(Plugin):
  name = 'clean'
  help = 'remove generated C++ and binaries from test locations'
 
  def runme(self):
    for d in glob.glob(os.path.join("pkg-stamps", "*")):
      erasefile(d)

    for d in [ 
      os.path.join("tut", "examples"),
      os.path.join("bagley", "felix"),
      "src","elk","demux","faio","lib","lpsrc","rtl","bin","test",
      ]:
      for e in ["*.hpp","*.so","*.dll","*.cpp","*.hpp",
        "*.par","*.output","*.o","*.obj",
        "*.exp","*.lib",'*.resh','*.par',
        "*.cache","*.a","*.exp","*.exe",
        "*.cmo","*.cma","*.cmi","*.cmx","*.cmxa",
        ]:
        for f in glob.glob(os.path.join(d, e)):
          erasefile(f)

    for f in glob.glob(os.path.join("lib", "*.par")):
      erasefile(f)

    for f in glob.glob(os.path.join(FLX_LPARCHIVE, "lpsrc", "*.cache")):
      erasefile(f)

@select(tangler('mkplugins/mkdoc.py'))
class PLUGIN(Plugin):
  name = 'mkdoc'

  def __init__(self, *args, **kwds):
    apply(Plugin.__init__, (self,) + args, kwds)

    self.already_generated = {}

  def runme(self, pkg, pkgdict):
    mkdirs("pkg-stamps")

    weaver_directory = pkgdict.get("weaver_directory","")
    iscr_source = pkgdict.get("iscr_source",[])
    if iscr_source and weaver_directory:
      print "GENERATING DOCUMENTATION",weaver_directory

      iscr_source = filter(lambda x: x not in self.already_generated, iscr_source)

      filecopy2dir(os.path.join('misc', 'plus.gif'),weaver_directory)
      filecopy2dir(os.path.join('misc', 'minus.gif'),weaver_directory)
      filecopy2dir(os.path.join('misc', 'dot.gif'),weaver_directory)
      filecopy2dir(os.path.join('misc', 'interscript.css'),weaver_directory)
      filecopy2dir(os.path.join('misc', 'user.css'),weaver_directory)

      for src in iscr_source:
        srcdir = os.path.join(FLX_LPARCHIVE, src)
        runISCR(
            '--language=en --weaver=web --weaver=latex '
            '--passes=2 --weaver-directory=%s %s' % (weaver_directory, srcdir))

        self.already_generated[src] = 1

@select(tangler('mkplugins/cflags.py'))
# GLOBAL COMPILATION FLAGS

# C++ STUFFS
CFLAGS = ""
SFLAGS = ""
DFLAGS = ""
EXTRA_LIBS = []

@select(tangler('mkplugins/build_target_rtl_dynamic.py'))
def build_target_rtl_dynamic(pkg, pkgdict):
  CCS = pkgdict.get("cc_ccs",[])
  CPPS = pkgdict.get("cpp_cpps",[])

  if not CCS and not CPPS:
    return

  BUILD_MACRO = pkgdict.get("build_macro","ERROR!")
  EXTRA_CFLAGS = pkgdict.get("cflags","")
  EXTRA_DFLAGS = pkgdict.get("dflags","")

  flibs = pkgdict.get("lib_requires",[])
  needs_libs = []
  for i in flibs:
    needs_libs.append(i+"_dynamic")

  lib = pkgdict.get("provides_lib","lib"+pkg)

  print " ++ "+pkg+" RTL (dynamic)"

  compile_kwds = {
      'include_paths': ['rtl'],
      'optimise': optimise,
      'debug': debug,
      'macros': ["BUILD_"+BUILD_MACRO],
      'CFLAGS': CFLAGS+EXTRA_CFLAGS,
      }

  link_kwds = {
      'lib_paths': [SHLIB_DIR],
      'libs': EXTRA_LIBS+needs_libs,
      'LDFLAGS': DFLAGS+EXTRA_DFLAGS,
      }

  if CCS:
    # RF: THIS SHOULD BE TARGET_CC AND THE OUTPUT DIR SHOULD BE THAT OF
    # THE TARGET.
    objects = apply(TARGET_CC.compile_shared_rtl, (vxqt, CCS), 
        compile_kwds)

    apply(TARGET_CC.link_shared_rtl, 
      (vxqt, objects, TARGET_CC.options.SHLIB_DIR+os.sep+lib+'_dynamic'),
      link_kwds)

    if EXT_DYLIB != EXT_SHLIB:
      apply(TARGET_CC.link_shared_dll, 
        (vxqt, objects, TARGET_CC.options.SHLIB_DIR+os.sep+lib+'_dynamic'),
        link_kwds)

  if CPPS:
    # RF: THIS SHOULD BE TARGET_CXX AND THE OUTPUT DIR SHOULD BE THAT OF
    # THE TARGET.
    objects = apply(TARGET_CXX.compile_shared_rtl, (vxqt, CPPS), 
        compile_kwds)

    apply(TARGET_CXX.link_shared_rtl, 
      (vxqt, objects, TARGET_CXX.options.SHLIB_DIR+os.sep+lib+'_dynamic'),
      link_kwds)

    if EXT_DYLIB != EXT_SHLIB:
      apply(TARGET_CXX.link_shared_dll, 
        (vxqt, objects, TARGET_CXX.options.SHLIB_DIR+os.sep+lib+'_dynamic'),
        link_kwds)

    for x in CCS + CPPS: 
      f = x + EXT_SHARED_OBJ
      if verbose: print "Removing",f
      deletefile(f) # delete the .o files

@select(tangler('mkplugins/build_target_rtl_static.py'))
def build_target_rtl_static(pkg, pkgdict):
  CCS = pkgdict.get("cc_ccs",[])
  CPPS = pkgdict.get("cpp_cpps",[])

  if not CCS and not CPPS:
    return

  EXTRA_CFLAGS = pkgdict.get("cflags","")
  lib = pkgdict.get("provides_lib","lib"+pkg)

  print " ++ "+pkg+" RTL (static)"

  kwds = {
      'include_paths': ["rtl"],
      'macros': ["FLX_STATIC_LINK"],
      'optimise': optimise,
      'debug': debug,
      'CFLAGS': CFLAGS+EXTRA_CFLAGS,
      }

  if CCS:
    apply(TARGET_CC.build_static_rtl,
        (vxqt, CCS, "rtl"+os.sep+lib+"_static"),
        kwds)

  if CPPS:
    apply(TARGET_CXX.build_static_rtl,
        (vxqt, CPPS, "rtl"+os.sep+lib+"_static"),
        kwds)

    for x in CCS + CPPS: 
      f = x + EXT_STATIC_OBJ
      if verbose: print "Removing", f
      deletefile(f) # delete the object files


@select(tangler('mkplugins/build_felix_static_drivers.py'))
def build_felix_static_drivers(pkg, pkgdict):
  DRIVERS = pkgdict.get("drivers",[])
  cflags = pkgdict.get("cflags","")
  if len(DRIVERS)>0:
    print "COMPILING DRIVERS (static)"

    for mode, src, bin, macros in DRIVERS:
      if mode=='static':
        if verbose: print 'static Compiling driver object', src
        TARGET_CXX.compile_static_main(
          vxqt,
          [src],
          include_paths=["rtl"],
          macros=["FLX_STATIC_LINK"]+macros,
          optimise=optimise,
          debug=debug,
          CFLAGS=CFLAGS+cflags)

@select(tangler('mkplugins/build_felix_dynamic_drivers.py'))
def build_felix_dynamic_drivers(pkg, pkgdict):
  DRIVERS = pkgdict.get("drivers",[])
  cflags = pkgdict.get("cflags","")
  if len(DRIVERS)>0:
    print "COMPILING DRIVERS (dynamic)"
    dflags = pkgdict.get("dflags","")
    LIBS = pkgdict.get("drivers_require_libs",[])
    libs = []
    for lib in LIBS:
      libs.append(lib+"_dynamic")

    for mode, src, bin, macros in DRIVERS:
      # this is a gross HACK! Don't make dynamic versions
      # of drivers with extra macros, they're for static
      # link of driver without async support
      if mode=='dynamic':
        if verbose: print 'dynamic Compiling driver object', src

        TARGET_CXX.build_shared_program(
            vxqt,
            src,
            bin,
            include_paths=["rtl"],
            optimise=optimise,
            debug=debug,
            macros=macros,
            CFLAGS=CFLAGS+cflags,
            lib_paths=[SHLIB_DIR],
            libs=libs,
            LDFLAGS=DFLAGS+dflags)

        deletefile(src + EXT_SHARED_OBJ)

@select(tangler('mkplugins/build_target_cpp_tools.py'))
def build_target_cpp_tools(pkg, pkgdict):
  EXES = pkgdict.get("exes",[])
  esflags = pkgdict.get("exes_require_linkflags","")
  if len(EXES)>0:
    print "BUILDING C++ TARGET TOOLS"
    LIBS = pkgdict.get("exes_require_libs",[])
    libs = []
    for lib in LIBS: libs.append(lib+"_static")
    for src,bin in EXES:
      dir = os.path.dirname(src)
      TARGET_CXX.build_static_main(
        vxqt,
        src,
        dir,
        bin,
        include_paths=["rtl"],
        macros=["FLX_STATIC_LINK"],
        CFLAGS=CFLAGS,
        lib_paths=[dir],
        libs=libs,
        LDFLAGS=SFLAGS+esflags)

      deletefile(src + EXT_STATIC_OBJ)

@select(tangler('mkplugins/build_target_felix_tools.py'))
# TARGET TOOLS : FELIX
def build_target_felix_tools(pkg, pkgdict):
  FLXS = pkgdict.get("felix_tools",[])
  if len(FLXS)>0:
    print "BUILDING FELIX TARGET TOOLS"
    LIBS = pkgdict.get("exes_require_libs",[])
    libs = []
    for lib in LIBS: libs.append(lib+"_static")
    fsflags = pkgdict.get("felix_requires_linkflags","")
    for src,exe in FLXS:
      flxg("-Ilib " + src)
      TARGET_CXX.build_felix_static(
        vxqt,
        src,
        exe,
        objects=['rtl' + os.sep + 'flx_run' + EXT_STATIC_OBJ],
        include_paths=['rtl'],
        macros=["FLX_STATIC_LINK"],
        CFLAGS=CFLAGS,
        lib_paths=['rtl'],
        libs=libs,
        LDFLAGS=SFLAGS+fsflags)

@select(tangler('mkplugins/performance.py'))
SPECIAL_TESTS = [
  (os.path.join('bin', 'drivers', 'flx_run'), os.path.join('test', 'drivers', 'flx_run_lib1.flx'),''),
  (os.path.join('test', 'drivers', 'flx_perf_drv1'), os.path.join('test', 'drivers', 'flx_perf_lib1.flx'),'1000'),
]

class PLUGIN(Plugin):
  name = 'performance'
  help = 'make performance tests'

  def runme(self):
    for driver,testfile,moreargs in SPECIAL_TESTS:
      test_basename = os.path.splitext(testfile)[0]
      drv_basename = os.path.splitext(driver)[0]
      if SUPPORT_DYNAMIC_LOADING:
        testscript = "time "+drv_basename+ " "+test_basename+EXT_SHLIB+" " + moreargs
        print '(dynamic link) Executing ',testscript
        try:
          exqt(testscript)
          #print 'TESTFILE -- OK!',testscript
        except MakeError, e:
          print 'TESTFILE -- ERROR!',testscript
          raise e

      if SUPPORT_STATIC_LINKAGE:
        testscript = "time "+test_basename+EXT_EXE+" " + moreargs
        print '(static link) Executing ',testscript
        try:
          exqt(testscript)
          #print 'TESTFILE -- OK!',testscript
        except MakeError, e:
          print 'TESTFILE -- ERROR!',testscript
          raise e

@select(tangler('mkplugins/ocaml_env.py'))
if not globals().get("ocaml_env",None):
  ocaml_env = 1

  BYTECODE = not NATIVE_CODE_COMPILER or "bytecode" in options 
  if BYTECODE:
    if "profile" in options: 
      OCAMLOPT = OCAMLCP
      OCAMLC = OCAMLCP
    else: OCAMLOPT = OCAMLB
  else:
    OCAMLOPT = OCAMLC
    if "profile" in options:
      OCAMLOPT = OCAMLOPT+' -p '

  if debug or "debug" in options:
    if NATIVE_CODE_COMPILER:
      if OCAMLC == OCAMLOPT:
        #OCAMLC = OCAMLC + ' -ccopt -g '
        OCAMLC = OCAMLC + ' '
      else:
        #OCAMLC = OCAMLC + ' -g '
        OCAMLC = OCAMLC + ' '
      #OCAMLOPT = OCAMLOPT + ' -ccopt -g '
      OCAMLOPT = OCAMLOPT + ' '
    else:
      #OCAMLOPT = OCAMLOPT + ' -g '
      OCAMLOPT = OCAMLOPT + ' '

  if "optimise_felix" in options:
    OCAMLOPT = OCAMLOPT + " -unsafe -noassert -inline 5 "

  if BYTECODE == 0:
    OCAML_OBJECT_EXTENSION = '.cmx'
    OCAML_LIB_EXTENSION = '.cmxa'
  else:
    OCAML_OBJECT_EXTENSION = '.cmo'
    OCAML_LIB_EXTENSION = '.cma'

@select(tangler('mkplugins/link_model_env.py'))
if not globals().get("link_model_env",None):
  link_model_env = 1

  CCOBJ_STATIC_LIB = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "
  CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + "-DFLX_STATIC_LINK "

  CCMACS=""
  for i in macros:
    CCMACS=CCMACS+'-D'+i+" "

  if CCMACS:
    CCOBJ_STATIC_RTL = CCOBJ_STATIC_RTL + CCMACS
    CCOBJ_STATIC_MAIN = CCOBJ_STATIC_MAIN + CCMACS
    CCOBJ_STATIC_FLX = CCOBJ_STATIC_FLX + CCMACS

    CCOBJ_DYNAMIC_RTL = CCOBJ_DYNAMIC_MAIN + CCMACS
    CCOBJ_DYNAMIC_MAIN = CCOBJ_DYNAMIC_MAIN + CCMACS
    CCOBJ_DYNAMIC_FLX = CCOBJ_DYNAMIC_FLX + CCMACS


@select(tangler('mkplugins/run_failure_tests.py'))
class PLUGIN(Plugin):
  name = 'run_failure_tests'
  help = 'run tests meant to fail'
  
  def runme(self,pkg, pkgdict, quiet, check_stamp):
    bad_tests = pkgdict.get("failure_tests",[])
    bad_tests.sort()

    failed = 0

    for testfile in bad_tests:
      log = Tee()
      log.write("**** FAILURE TESTING PACKAGE %s : %s ****\n" % (pkg, testfile))

      #log.write('Running Felix code generator on %s\n' % testfile)
      basename = os.path.splitext(testfile)[0]
      cppfilename = basename + ".cpp"

      try:
        vxqtq(os.path.join(
          'bin',
          'flxg -e -Ilib ' + basename), log=log)
        #log.write('TESTFILE -- failed as expected %s\n' % basename)
        self.successes.append((pkg, testfile, log.getvalue()))
      except MakeError, e:
        failed = 1

        log.write('TESTFILE -- SUCCEEDED, SHOULD HAVE FAILED! %s\n' % basename)

        self.failures.append((pkg, testfile, log.getvalue()))

      erasefile(basename+'.cpp')
      erasefile(basename+'.hpp')

    return not failed


@select(tangler('mkplugins/run_static_unit_tests.py'))
class PLUGIN(TestPlugin):
  name = 'run_static_unit_tests'
  help = 'run static unit tests'
  
  def runme(self, pkg, pkgdict, quiet, check_stamp):
    static_unit_tests = pkgdict.get("static_unit_tests",[])
    static_unit_tests.sort()

    return self.run_tests(pkg, pkgdict, static_unit_tests, 1, 1, 0, check_stamp,
      "*** STATIC UNIT TESTING %s : %%s ****\n" % pkg, quiet)


@select(tangler('mkplugins/run_dynamic_unit_tests.py'))
class PLUGIN(TestPlugin):
  name = 'run_dynamic_unit_tests'
  help = 'run dynamic unit tests'
  
  def runme(self, pkg, pkgdict, quiet, check_stamp):    
    dynamic_unit_tests = pkgdict.get("dynamic_unit_tests",[])
    dynamic_unit_tests.sort()

    return self.run_tests(pkg, pkgdict, dynamic_unit_tests, 1, 0, 1, check_stamp,
      "*** DYNAMIC UNIT TESTING %s : %%s ****\n" % pkg, quiet)


@select(tangler('mkplugins/run_unit_tests.py'))
class PLUGIN(TestPlugin):
  name = 'run_unit_tests'
  help = 'run unit tests'
  
  def runme(self,pkg, pkgdict, quiet, check_stamp):    
    unit_tests = pkgdict.get("unit_tests",[])
    unit_tests.sort()

    return self.run_tests(pkg, pkgdict, unit_tests, 1, 1, 1, check_stamp,
      "*** UNIT TESTING %s : %%s ****\n" % pkg, quiet)
         

@select(tangler('mkplugins/run_completion_tests.py'))
# these tests are units tests with non-deterministic results
class PLUGIN(TestPlugin):
  name = 'run_completion_tests'
  help = 'run tests that just need to finish'

  def runme(self,pkg, pkgdict, quiet, check_stamp):
    completion_tests = pkgdict.get("completion_tests",[])
    completion_tests.sort()

    return self.run_tests(pkg, pkgdict, completion_tests, 0, 1, 1, check_stamp,
      "*** COMPLETION (nondet) TESTING %s : %%s ****\n" % pkg, quiet)


@select(tangler('mkplugins/run_known_failed_tests.py'))
class PLUGIN(Plugin):
  name = 'run_known_failed_tests'
  help = 'mark tests failed that are known to fail without running'
  
  def runme(self,pkg, pkgdict, quiet, check_stamp):
    bad_tests = pkgdict.get("known_failed_tests",[])
    bad_tests.sort()

    for testfile in bad_tests:
      log = Tee()
      log.write("**** KNOWN FAILED TESTING PACKAGE %s : %s ****\n" % (pkg, testfile))

      # don't even bother to compile
      self.failures.append((pkg, testfile, ""))

    return 1 # don't report any failure!

@select(tangler('mkplugins/run_demos.py'))
class PLUGIN(TestPlugin):
  name = 'run_demos'
  help = 'run demonstrations'

  def runme(self,pkg, pkgdict, quiet=0, check_stamp=0):
    demos = pkgdict.get("demos",[])
    demos.sort()

    return self.run_tests(pkg, pkgdict, demos, 0, 1, 1, check_stamp,
      "*** DEMO PACKAGE %s : %%s ****\n" % pkg, quiet)


@select(tangler('mkplugins/xqt.py'))
if os.name=="nt":
  ENV="set PATH=bin;%PATH%&&"
else:
  if CYGWIN or WIN32:
    ENV = 'env PATH=bin:"$PATH" PYTHONPATH=.:"$PYTHONPATH" '
  elif MACOSX:
    ENV = 'PATH=bin:"$PATH" DYLD_LIBRARY_PATH=rtl:"$DYLD_LIBRARY_PATH" '
  else:
    ENV = 'PATH=bin:"$PATH" LD_LIBRARY_PATH=rtl:"$LD_LIBRARY_PATH" '


def vxqt(x, **kwds):
  kwds['verbose'] = kwds.get('verbose', verbose)
  kwds['quiet'] = kwds.get('quiet', quiet)
  return apply(xqt, (x,), kwds)


def vxqtq(x, **kwds):
  kwds['verbose'] = kwds.get('verbose', verbose)
  return apply(xqtq, (x,), kwds)


def exqt(x, **kwds): 
  return apply(vxqt, (ENV+x,), kwds)


def flxg(x, **kwds):
  x = os.path.join('bin', 'flxg ' + x)
  return apply(exqt, (x,), kwds)


#interscript command (now built in part of Felix package)
def runISCR(a,force=0):
  x = string.split(a, ' ')
  z = []
  for i in x:
    z.append('"' + i + '"')
  a = string.join(z, ' ')
  
  if force:
    exqt(ISCR + "--nocache " + a)
  else:
    exqt(ISCR + '--break-on-error ' + a)


@select(tangler('mkplugins/manifest.py'))
manifest_src_re = re.compile(r"CREATING .* NAMED FILE SOURCE (.*) \[")

def make_manifest(pkg):
  base = os.path.basename(os.path.splitext(pkg)[0])
  print "Make Manifest of",base
  fname = os.path.join("manifests", base+".log")
  runISCR("--nocache --trace=sources --trace=changes --new-logfile="+fname+" "+pkg)
  deps = []
  f = open(fname)
  for line in f.readlines():
    m = manifest_src_re.match(line)
    if m:
      g = m.group(1)
      print "Source File: "+g
      deps = append_unique(deps,os.path.join(FLX_LPARCHIVE, "lpsrc", g))
  f.close()
  f = open(os.path.join("manifests", base+".deps"),"w")
  for x in deps: f.write(x+"\n")
  f.close()

def get_deps(base):
  f = open(os.path.join("manifests", base+".deps"))
  data = f.read()
  f.close()
  files = string.split(string.strip(data),"\n")
  return files

def mk_manifests():
  mkdirs("manifests")
  paks = glob.glob(os.path.join(FLX_LPARCHIVE, "lpsrc", "*.pak"))
  for pkg in paks:
    base = os.path.basename(os.path.splitext(pkg)[0])
    fbase = os.path.join("manifests", base)

    if not os.path.exists(fbase + '.log') or not os.path.exists(fbase + '.deps'):
      print "New pak", pkg, "BUILDING MANIFEST"
      make_manifest(pkg)
    else:
      manifest_time = filetime(fbase + '.log')

      files = get_deps(base)
      src_time = newest_filetime(files)
      if src_time > manifest_time:
        print "Changed pak", pkg, "REBUILDING MANIFEST"
        make_manifest(pkg)

mk_manifests()

def get_latest_src_time(pkgdict):
  output_iscrs = []
  for iscr in pkgdict.get("iscr_source",[]):
    base = os.path.basename(os.path.splitext(iscr)[0])
    iscrs = get_deps(base)
    for i in iscrs:
      if not i in output_iscrs: output_iscrs.append(i)

  return newest_filetime(output_iscrs)

class PLUGIN(Plugin):
  name = 'cal_pkgs'
  priority = 10

  def runme(self):
    global pkgd
    global host_packages,target_packages,run_packages,doc_packages
    global host_selected_pkgs,target_selected_pkgs,run_selected_pkgs,doc_selected_pkgs

    for pkg in pkgd.keys():
      pkgdict = pkgd[pkg]
  
      latest_src_time = get_latest_src_time(pkgdict)
      if latest_src_time == 0:
        print "Pak %-20s (virtual)" % pkg
      else:
        src_time_s = fmtime(latest_src_time)
        print "Pak %-20s changed: %s" % (pkg,src_time_s)
  
      host_stamp=os.path.join("pkg-stamps", pkg+".host")
      latest_host_build_time = filetime(host_stamp)
      if latest_host_build_time == 0:
        print "  ** Host UNBUILT"
        if pkg not in host_packages: host_packages.append(pkg)
      else:
        if latest_host_build_time < latest_src_time:
          print "  ** Host build:",fmtime(latest_host_build_time)
          print "  ** REQUIRES REBUILD due to changed sources"
          if pkg not in host_packages: host_packages.append(pkg)
  
      target_stamp=os.path.join("pkg-stamps", pkg+".target")
      latest_target_build_time = filetime(target_stamp)
      if latest_target_build_time == 0:
        print "  ** Target UNBUILT"
        if pkg not in target_packages: target_packages.append(pkg)
      else:
        if latest_target_build_time < latest_src_time:
          print "  ** Target build:",fmtime(latest_target_build_time)
          print "  ** REQUIRES REBUILD due to changed sources"
          if pkg not in target_packages: target_packages.append(pkg)
  
      run_stamp=os.path.join("pkg-stamps", pkg+".run")
      latest_run_build_time = filetime(run_stamp)
      if latest_run_build_time == 0:
        print "  ** Run UNBUILT"
        if pkg not in run_packages: run_packages.append(pkg)
      else:
        if latest_run_build_time < latest_src_time:
          print "  ** Run build:",fmtime(latest_run_build_time)
          print "  ** REQUIRES REBUILD due to changed sources"
          if pkg not in run_packages: run_packages.append(pkg)

      doc_stamp=os.path.join("pkg-stamps", pkg+".doc")
      latest_doc_build_time = filetime(doc_stamp)
      if latest_doc_build_time == 0:
        print "  ** Doc UNBUILT"
        if pkg not in doc_packages: doc_packages.append(pkg)
      else:
        if latest_doc_build_time < latest_src_time:
          print "  ** Doc build:",fmtime(latest_doc_build_time)
          print "  ** REQUIRES REBUILD due to changed sources"
          if pkg not in doc_packages: doc_packages.append(pkg)

  
    # doesn't work so well if both deps and reqs specified!
    # would work better, if reqs was already reduced to
    # what actually needed o be rebuilt
  
    if "deps" in options:
      host_packages = closure(pkgdeps,host_packages)
      target_packages = closure(pkgdeps,target_packages)
      run_packages = closure(pkgdeps,run_packages)
      doc_packages = closure(pkgdeps,doc_packages)
  
    if "reqs" in options:
      host_packages = closure(pkgreqs,host_packages)
      target_packages = closure(pkgreqs,target_packages)
      run_packages = closure(pkgreqs,run_packages)
      doc_packages = closure(pkgreqs,doc_packages)
  
    host_selected_pkgs = filter(lambda x: x in host_packages,pkgs)
    target_selected_pkgs = filter(lambda x: x in target_packages,pkgs)
    run_selected_pkgs = filter(lambda x: x in run_packages,pkgs)
    doc_selected_pkgs = filter(lambda x: x in doc_packages,pkgs)
  
    if "all" in options: 
      if not quiet: print "SELECTING ALL PACKAGES"
      host_selected_pkgs = pkgs
      target_selected_pkgs = pkgs
      run_selected_pkgs = pkgs
      doc_selected_pkgs = pkgs
  
    if not quiet:
      #print "AVAILABLE SOURCES",paks
      print "Host SELECTED PACKAGES ARE ",host_selected_pkgs
      print "Target SELECTED PACKAGES ARE ",target_selected_pkgs
      print "Run SELECTED PACKAGES ARE ",run_selected_pkgs
      print "Doc SELECTED PACKAGES ARE ",doc_selected_pkgs
      print "SELECTED PHASES ARE   ",phases
      print "Build model  ",build_model
      print "Host model   ",host_model
      print "Target model ",target_model
      print "Run model    ",run_model

@select(tangler('mkplugins/make.py'))
class PLUGIN(Plugin):
  name = 'make'
  help = 'check if any packages need rebuilding'
  priority = 50

  def runme(self):
    global host_selected_pkgs,target_selected_pkgs,run_selected_pkgs
    global pkgd,phases,quiet
    mkdirs("pkg-stamps")
    check_stamp = "force" not in options

    if "host" in phases:
      ocaml_sequencer = "force" in options
      for pkg in host_selected_pkgs:
        pkgdict = pkgd[pkg]
        print "***** Host MAKING PACKAGE "+pkg+" ************"

        stamp=os.path.join("pkg-stamps", pkg+".host")
        erasefile(stamp)
        srcs = pkgdict.get("iscr_source",[])      
        for src in srcs:
          src = unix2native(src)
          if not quiet: print "REExtracting",pkg,"from",src
          runISCR(os.path.join(FLX_LPARCHIVE, src))

        MLIS = pkgdict.get("caml_raw_interfaces",[])
        HPPS = pkgdict.get("rtl_interfaces",[])

        plugins['copy_mli2ml'](MLIS)
        plugins['copy_hpp2rtl'](HPPS)

        ocaml_sequencer = plugins['build_ocamls'](pkg, pkgdict, ocaml_sequencer)

        plugins['build_host_tools'](pkg, pkgdict)

        enstamp(stamp)

    if "target" in phases:
      for pkg in target_selected_pkgs:
        pkgdict = pkgd[pkg]
        print "***** Target MAKING PACKAGE "+pkg+" ************"

        stamp=os.path.join("pkg-stamps", pkg+".target")
        erasefile(stamp)
        if SUPPORT_DYNAMIC_LOADING:
          build_target_rtl_dynamic(pkg, pkgdict)
  
        if SUPPORT_STATIC_LINKAGE:
          build_target_rtl_static(pkg, pkgdict)
      
        if SUPPORT_DYNAMIC_LOADING:
          build_felix_dynamic_drivers(pkg, pkgdict)

        if SUPPORT_STATIC_LINKAGE:
          build_felix_static_drivers(pkg, pkgdict)
  
        build_target_cpp_tools(pkg, pkgdict)
        build_target_felix_tools(pkg, pkgdict)

        # only stamp if we've passed the tests
        if plugins['run_failure_tests'](pkg, pkgdict, quiet, check_stamp):
          enstamp(stamp)

    if "run" in phases:
      for pkg in run_selected_pkgs:
        pkgdict = pkgd[pkg]
        print "***** Run MAKING PACKAGE "+pkg+" ************"

        stamp=os.path.join("pkg-stamps", pkg+".run")
        erasefile(stamp)

        # only stamp if we've passed the tests
        if \
                    plugins['run_failure_tests'](pkg, pkgdict, quiet, check_stamp) \
                and plugins['run_unit_tests'](pkg, pkgdict, quiet, check_stamp) \
                and plugins['run_static_unit_tests'](pkg, pkgdict, quiet, check_stamp) \
                and plugins['run_dynamic_unit_tests'](pkg, pkgdict, quiet, check_stamp) \
                and plugins['run_completion_tests'](pkg, pkgdict, quiet, check_stamp) \
                and plugins['run_known_failed_tests'](pkg, pkgdict, quiet, check_stamp):
          enstamp(stamp)
 

@select(tangler('flxbuild/pluginutil.py'))
class Plugin:
  name = None
  help = ''
  priority = None

  def __init__(self):
    self.failures = []
    self.successes = []
    self.used = 0

  def __call__(self,*args,**kwds):
    self.used = 1
    return apply(self.runme,args,kwds)


class TestPlugin(Plugin):
  def run_tests(self, pkg, pkgdict, testfiles, deterministic, static, dynamic, check_stamp,
          title, quiet):
    if not testfiles:
      return 1

    tests_failed = 0

    # determine the latest time that this package, and all the recurcively dependent
    # packages where last built
    latest_src_time = get_latest_src_time(pkgdict)

    for p in pkgreqs.get(pkg, []):
      latest_src_time = max(latest_src_time, get_latest_src_time(pkgd[p]))

    for testfile in testfiles:
      failed = 0
      if find_test(self.successes, pkg,testfile): continue
      if find_test(self.failures, pkg,testfile): continue

      stamp = os.path.join("pkg-stamps", testfile + '.test')
      
      # run the tests
      stamptime = filetime(stamp)
      if check_stamp and latest_src_time < stamptime:
        self.successes.append((pkg, testfile, "Stamped ok previously on "+fmtime(stamptime)))
      else:
        log = Tee()
        log.write(title % testfile)
        if not quiet:
          if stamptime == 0:
            log.write("+++UNTRIED or FAILED\n")
          elif not check_stamp:
            log.write("+++FORCED\n")
          else:
            log.write("+++OUT OF DATE, source changed since "+fmtime(stamptime)+"\n")

        # build the felix code
        try:
          basename = plugins['build_test'](testfile, log, quiet)
        except MakeError, e:
          failed = 1
          log.write('TESTFILE -- ERROR! %s (compiler)\n' % testfile)
        else:
          path = os.path.join(os.curdir, basename)
  
          # run the dynamic tests
          if dynamic and SUPPORT_DYNAMIC_LOADING:
            resfilename = basename + ".resh"
  
            try:
              driver = vxqtq(os.path.join("bin", "flx_pkgconfig") +
                " --path=config --field=flx_requires_driver --rec @" + resfilename,
                log=log)
  
              driver = string.strip(driver[0])
              if driver =='': driver = "flx_run"
              driver = os.path.join("bin", driver)
              #log.write("Driver: %s\n" % driver)
              testscript = driver + ' ' + path + EXT_SHLIB
  
              self.run_test(log, testscript, basename, deterministic, quiet,check_stamp)
            except MakeError, e:
              failed = 1
              log.write('TESTFILE -- ERROR! %s (dynamic)\n' % testscript)
              
          # run the static tests
          if static and SUPPORT_STATIC_LINKAGE:
            testscript = path + EXT_EXE
  
            try:
              self.run_test(log, testscript, basename, deterministic, quiet, check_stamp)
            except MakeError, e:
              failed = 1
              log.write('TESTFILE -- ERROR! %s (static)\n' % testscript)

        if not failed:
          enstamp(stamp)
          self.successes.append((pkg, testfile, log.getvalue()))
        else:
          erasefile(stamp)

      ####

      if failed:
        tests_failed = tests_failed + 1
        self.failures.append((pkg, testfile, log.getvalue()))
        if 'stop' in options: raise MakeError

    return tests_failed == 0


  def run_test(self, log, testscript, basename, deterministic, quiet,check_stamp):
    log.write('EXECUTING TEST CODE %s\n' % testscript, quiet)
    flush()

    # FIXME
    argfiles = glob.glob(basename + '*.args')

    if not argfiles:
      output = vxqt(ENV + testscript, verbose=1, log=log)

      f = open(basename + '.output', 'w')
      try:
        f.write(string.join(output, ""))
      finally:
        f.close()

      if deterministic:
        output = vxqt('%s %s.expect %s.output' % (DIFF, basename, basename), 
            verbose=1, log=log)

    else:
      for argcount, argfile in zip(range(len(argfiles)), argfiles):
        # read the arguments fromm the file
        f = open(argfile)
        try:
          args = string.strip(f.read())
        finally:
          f.close()

        output = vxqt(ENV + testscript + ' ' + args, verbose=1, log=log)

        f = open('%s-%s.argoutput' % (basename, argcount), 'w')
        try:
          f.write(string.join(output, ""))
        finally:
          f.close()

        if deterministic:
           output = vxqtq('%s %s-%s.argexpect %s-%s.argoutput' % \
                   (DIFF, basename, argcount, basename, argcount), 
                   verbose=1, log=log)


@select(tangler('mkplugins/help.py'))
class PLUGIN(Plugin):
  name = 'help'
  help = 'print this help message'

  def runme(self):
    items = []
    max_len = 0
    for name, plugin in plugins.items():
      if plugin.help:
        max_len = max(max_len, len(name))
        items.append((name, plugin.help))

    items.sort()

    for name, help in items:
      print '%s %s' % (string.ljust(name, max_len), help)
    
    sys.exit(0)

@select(tangler('mkplugins/test.py'))
class PLUGIN(Plugin):
  name = 'test'
  help = 'regression and tutorial combined'

  def __init__(self, *args, **kwds):
    apply(Plugin.__init__, (self,) + args, kwds)

    if "test" in options: 
      if "run" not in phases: phases.append("run")

  def runme(self):
    global quiet,force
    check_stamp = "force"  not in options
    if check_stamp:
      print "##### TEST SELECTED PACKAGES ##################"
    else:
      print "##### TEST ALL PACKAGES ##################"
    for pkg in pkgs:
      pkgdict = pkgd[pkg]
      print "***** TEST PACKAGE "+pkg+" ************"
      plugins['run_failure_tests'](pkg, pkgdict, quiet, check_stamp)
      plugins['run_unit_tests'](pkg, pkgdict, quiet, check_stamp)
      plugins['run_static_unit_tests'](pkg, pkgdict, quiet, check_stamp)
      plugins['run_dynamic_unit_tests'](pkg, pkgdict, quiet, check_stamp)
      plugins['run_completion_tests'](pkg, pkgdict, quiet, check_stamp)
      plugins['run_known_failed_tests'](pkg, pkgdict, quiet, check_stamp)

@select(tangler('mkplugins/doc.py'))
class PLUGIN(Plugin):
  name = 'doc'
  help = 'build all user documentation'

  def runme(self):
    global doc_selected_pkgs
    global quiet,force
    check_stamp = "force"  not in options
    if check_stamp:
      plugins['cal_pkgs']()
      print "##### DOCUMENT SELECTED PACKAGES ##################"
    else:
      print "##### DOCUMENT ALL PACKAGES ##################"
      doc_selected_pkgs = pkgs 

    for pkg in doc_selected_pkgs:
      pkgdict = pkgd[pkg]
      print "***** DOCUMENT PACKAGE "+pkg+" ************"

      stamp=os.path.join("pkg-stamps", pkg+".doc")
      erasefile(stamp)

      plugins['mkdoc'](pkg, pkgdict)

      enstamp(stamp)

    print "***** OCAMLDOC COMPILER [HACK!] ************"
    plugins['impldoc']()

    print "***** DOXGEN RTL [HACK!] ************"
    plugins['rtldoc']()

@select(tangler('mkplugins/demo.py'))
class PLUGIN(Plugin):
  name = 'demo'
  help = 'build and run the demos'
    
  def runme(self):
    print "##### DEMONSTRATE ALL PACKAGES ##################"
    for pkg in pkgs:
      pkgdict = pkgd[pkg]
      print "***** DEMO PACKAGE "+pkg+" ************"
      plugins['run_demos'](pkg, pkgdict)

@h = tangler('script/maker','python')
@select(h)
#!/usr/bin/env python
###############################################################
# FELIX MAKE SCRIPT
###############################################################
@tangle("FLX_MAKER_CVS_ID='"+FLX_MAKER_CVS_ID+"'")
import os
import os.path
import getopt
import glob
import stat
import string
import sys
import re
import traceback
import time
this = globals()

if '' not in sys.path: sys.path=['']+sys.path
import flxbuild
from flxbuild.flxutil import *

execfile(os.path.join("flxbuild", "pluginutil.py"))

# ------------------------------------------------
# PROCESS COMMAND LINE OPTIONS
# ------------------------------------------------

all_phases = ["build","host","target","run"]
phases = []
options = sys.argv[1:]
try:
  opts, args = getopt.getopt(sys.argv[1:], 'hvqD:Og', [ \
      'help', 'verbose', 'quiet', 'phase=', 'pkg=', 'model=', 'lparchive=',
      'optimise', 'optimize', 'no-optimise', 'no-optimize', 'no-debug'])
except getopt.error, e:
  sys.stderr.write(str(e) + '\n')
  sys.exit(1)

quiet = 0
verbose = 1
optimise = 1
debug = 1
packages = []
models = []
macros = []
lparchive = None
help_string = """\
usage: mk [options] [plugins]

flags:
  -h, --help      print this help message
  -v, --verbose   print out extra debugging info
  -q, --quiet     do not print out extra debugging info
  -O, --optimise  generate optimised code
  --no-optimise   turn off optimised code generation
  -g, --debug     generate debugging information
  --no-debug      turn off debugging information generation
  -Dmacro[=defn]  define a macro
  --phase         run only this phase of the build %s
  --pkg           build only these packages
  --model         build only these models
  --lparchive     use an alternative lpsrc directory

plugins:
  run a custom plugin. run "mk help" to get a list of plugins to run
  """ 

for o, a in opts:
  if o in ['-h', '--help']:
    print help_string % (all_phases)
    sys.exit(0)
  elif o in ['-v', '--verbose']:
    verbose = verbose + 1
  elif o in ['-q', '--quiet']:
    quiet=1
    verbose = 0
  elif o in ['-O', '--optimise', '--optimize']:
    optimise = 1
  elif o in ['--no-optimise', '--no-optimize']:
    optimise = 0
  elif o in ['-g']:
    debug = 1
  elif o in ['--no-debug']:
    debug = 0
  elif o in ['-D']:
    macros.append(a)
  elif o in ['--phase']:
    if a == '*':
      phases = all_phases
    elif a not in all_phases:
      sys.stderr.write('unknown phase: %s\n' % phase)
      sys.exit(1)
    elif a not in phases:
      phases.append(a)
  elif o in ['--pkg']:
    packages.append(a)
  elif o in ['--model']:
    if a not in models:
      models.append(a)
  elif o in ['--lparchive']:
    lparchive = a
  else:
    sys.stderr.write('unknown option: %s %s\n' % (o, a))
    sys.exit(1)

host_packages = list(packages)
target_packages = list(packages)
run_packages = list(packages)
doc_packages = list(packages)

if not quiet: print "USER SELECTED PACKAGES",packages

# ------------------------------------------------
# Load the initial config
# ------------------------------------------------

try:
  execfile(os.path.join("config", "config.py"))
except:
  xt,xv,tb = sys.exc_info()
  print "ERROR IN config/config.py"
  traceback.print_exception(xt,xv,tb)
  print "You must either"
  print "(a) edit config/config.py and fix the error, or,"
  print "(b) i) delete it, and,"
  print "    ii) run 'python script/make_config.py'"
  print "       again to reset it:"
  print "       this is done automatically by 'make boot'"
  sys.exit(1)

execfile(os.path.join("cpkgs", "build", "interscript.py"))
execfile(os.path.join("mkplugins", "xqt.py"))

FLXFLAGS = ""

if lparchive is not None:
  FLX_LPARCHIVE = lparchive

# if the user didn't say which phases to run
# then run all the phases that use the host model
# On building on Linux for MinGW, the build model
# is linux, and the host model is mingw, the target
# is win32. We'd be running all MinGW phases.
# note a phase is named for the targetted product
# NOT the machine that generates it. Thus host
# phase mingw means 'compile on Linux for MingW'

if not phases and not models:
  models = [host_model]

for model in models:
  if model == build_model:
    if "build" not in phases: phases.append("build")

for model in models:
  if model == host_model:
    if "host" not in phases: phases.append("host")

for model in models:
  if model == target_model:
    if "target" not in phases: phases.append("target")

for model in models:
  if model == run_model:
    if "run" not in phases: phases.append("run")

if verbose and options:
  print "OPTIONS: ", options

if not phases:
  phases = all_phases

print "Using LP Archive from ",
if FLX_LPARCHIVE == os.curdir:
  print "Current Directory"
else:
  print FLX_LPARCHIVE

paks = glob.glob(os.path.join(FLX_LPARCHIVE, "lpsrc", "*.pak"))

if "force_extract" in options:    
  print "FORCE EXTRACTING SOURCES: remove caches"
  for p in paks:
    cache = p + ".cache"
    if os.path.exists(cache):
      os.remove(cache)

if "extract" in options or "force_extract" in options:
  for p in paks:
    print "EXTRACTING",p,"from",FLX_LPARCHIVE
    runISCR(p)
  # this is a hack
  filecopy(
    os.path.join('misc', 'interscript.css'),
    os.path.join('speed', 'interscript.css'))

  print "EXTRACTION COMPLETE"
  sys.exit(0)


raw_pkgs = glob.glob(os.path.join("spkgs", "*.py"))
unsorted_pkgs = []
pkgd = {}
pkgs = []
pkgreqs = {}

for i in raw_pkgs:
  pkg = os.path.basename(os.path.splitext(i)[0])
  unsorted_pkgs.append(pkg)

  class X:
    execfile(os.path.join("spkgs", pkg+".py"))
  d = {}
  for k in X.__dict__.keys():
    if k[0] != '_':
      v = X.__dict__[k]
      d[k]=v
  pkgd[pkg]=d
   
def addpkg_r(pkg):
  if pkg not in pkgs:
    if pkg not in pkgd.keys():
      print "Unknown package",pkg
      print "Please extract!"
      sys.exit(1)
    else:
      reqs = pkgd[pkg].get('pkg_requires',[])
      pkgreqs[pkg]=reqs
      for i in reqs:
        addpkg_r(i)
      pkgs.append(pkg)

for pkg in unsorted_pkgs:
  addpkg_r(pkg)

# make sure we delete the pkg so that we don't leak
# references to them
del pkg

# invert the requirements in order to determine the dependencies
pkgdeps = invert(pkgreqs)

# PRINT PACKAGE DEPENDENCY INFORMATION
if "help" in options:
  print "REQS: "
  ks=pkgreqs.keys()
  ks.sort()
  length = 0
  for k in ks:
    length = max(len(k), length)
  for k in ks:
    print "  ",string.ljust(k,length),pkgreqs[k]
   
  print
  print "DEPS: "
  ks = pkgdeps.keys()
  ks.sort()
  length = 0
  for k in ks:
    length = max(len(k), length)
  for k in ks:
    print "  ",string.ljust(k,length),pkgdeps[k]

# -------------------------------------------------
# LOAD PLUGINS

plugins = {}
schedule_table = []
scheduled_plugins = []
unscheduled_plugins = []

def schedule(plugin):
  if plugin.priority is None:
    unscheduled_plugins.append(plugin)
  else:
    print "Scheduling",plugin.name," priority",plugin.priority
    schedule_table.append((plugin.priority, plugin))
    scheduled_plugins.append(plugin)

for f in glob.glob(os.path.join("mkplugins", "*.py")):
  base = os.path.basename(os.path.splitext(f)[0])

  try:
    execfile(f)
    if globals().has_key("PLUGIN"):
      plugin = PLUGIN()
      schedule(plugin)
      plugins[plugin.name] = plugin
      del PLUGIN
  except:
    print "Failed to install plugin",f
    raise

# END IMPLEMENTOR CONFIGURABLE SECTION
# -------------------------------------------------

# ----------- Here begins the actual build procedure ---------------------

def enstamp(stamp):
  mkdirs(os.path.split(stamp)[0])
  f = open(stamp,"w")
  t = fmtime(time.time())
  f.write(t+"\n")
  f.close()
  if not quiet:
    print 'Writing Stamp File:', stamp

def find_test(tl,a,b):
  for x,y,z in tl:
    if x == a and y == b: return 1
  return 0

# EXECUTE USER SELECTED PLUGINS IN COMMAND LINE ORDER
for k in options:
  if k in plugins:
    plugins[k]()
  # FIXME: commented out to allow arbitrary options
  #else:
  #  print "unknown option:", k
  #  raise MakeError

# execute scheduled operations in priority order
schedule_table.sort()
for pri,f in schedule_table:
  f()


if os.name != 'nt': # requires posix
  if "test" in options or "tutorial" in options or "fcount" in options:
    tkind = "std"
    if "inline" in options: tkind="inline"
    elif "noinline" in options: tkind="noinline"
    stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "tut/examples/*.hpp"'
    exqt(stats)
    stats = 'python script/fcount.py misc/fcounts.stats '+tkind+' "test/*.hpp"'
    exqt(stats)

  if "pfcount" in options:
    stats = 'python script/pfcount.py misc/fcounts.stats'
    exqt(stats)

  if "pfcount_all" in options:
    stats = 'python script/pfcount.py misc/fcounts.stats all'
    exqt(stats)

print

# print out all the failed plugins
failure_log = Tee()

failure_log.write("----- PLUGIN STATUS -----\n")
failed = 0
for plugin in scheduled_plugins + unscheduled_plugins:
  nfail = len(plugin.failures)
  npass = len(plugin.successes)
  failed = failed or nfail

  if nfail:
    failure_log.write('PLUGIN **FAILED**: %s, %d/%d failures\n' % (plugin.name, nfail,npass+nfail))
  else:
    if plugin.used:
      failure_log.write('PLUGIN PASSED    : %s, %d pass\n' % (plugin.name,npass))
    else:
      failure_log.write('PLUGIN UNUSED    : %s\n' % plugin.name)


if failed:
  print '^^^^^^^^^^ FAILURES by group ^^^^^^^^^^^^^'

  kats = {}
  for plugin in scheduled_plugins + unscheduled_plugins:
    if not plugin.failures:
      continue

    print '- %s: %s' % (len(plugin.failures), plugin.name)

    lookup = {}

    for pkg, file, failure in plugin.failures:
      files = lookup.get(pkg, [])
      files.append(file)
      lookup[pkg] = files

    lookup = lookup.items()
    lookup.sort()

    for pkg, files in lookup:
      files.sort()

      print '  - %s: %s' % (len(files), pkg)
      lastfile = ""
      for file in files:
        if file == lastfile: continue
        lastfile = file
        # grab the first line of the file to see if it
        # has a #line number to print out as well, so we can
        # localize the error to the interscript file location
        
        emitted = 0
        f = open(file)
        eat = 1
        while eat == 1:
          try:
            line = f.readline()
          except:
            eat = 0
          if emitted == 0: fstring = file
          else: fstring = ""
          if emitted == 0 and line[0:5] == '#line':
            comment = line
          elif line [0:8] == "//Check ":
            kat = string.strip(line[8:])
            l = kats.get(kat,[])
            l.append(file)
            kats[kat]=l
            comment = kat
          else:
            if emitted == 0:
              comment = line
            else:
              comment = ""
            eat = 0
          if line != "":
            print '      %-35s %s' % (fstring, string.strip(comment))
            emitted = 1
        if emitted == 0:
          print '      %s' % file
        f.close()

  print '^^^^^^^^^^ FAILURES by category ^^^^^^^^^^'
  keys = kats.keys()
  keys.sort()
  for kat in keys:
    print kat+":"
    files = kats[kat]
    for file in files:
      print "  ",file

f = open('errors.log', 'w')
try:
  f.write(failure_log.getvalue())
finally:
  f.close()

if failed:
  print "********* BUILD FAILED ********************"
  sys.exit(1)

print "RUN COMPLETE"

@head(1,'Makefile')
We attempt to fix the brain dead install command.
If it hits a an empty file set it gives an error:
we fix it. If it hits a subdirectory it gives an error.
We have no idea if it continues copying.

@select(tangler('Makefile','data'))
@tangle('CONFIG_ARGS=')
@tangle('PREFIX='+PREFIX)
@tangle('INSTALL_DIR=${PREFIX}/lib/felix/felix-'+flx_version)
@tangle('EXEC_DIR=${PREFIX}/bin')
@tangle('MAN_DIR=${PREFIX}/man')
@tangle('DOC_DIR=${INSTALL_DIR}')
@tangle('BUILTIN_ISCR=python -O interscript/bin/iscr.py --nocache')
@tangle('')
@tangle('all: lpsrc config script')
@tangle('\t./mk extract ')
@tangle('\t./mk --phase=build')
@tangle('\t./mk --phase=host')
@tangle('\t./mk --phase=target')
@tangle('\t./mk test ')
@tangle('')
@tangle('profile: dummy')
@tangle('\t./mk --pkg=flx_compiler profile')
@tangle('')
@tangle('bytecode: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode')
@tangle('')
@tangle('bytecode.profile: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode profile')
@tangle('')
@tangle('bytecode.debug: dummy')
@tangle('\t./mk --pkg=flx_compiler bytecode debug')
@tangle('')
@tangle('extract: dummy')
@tangle('\t./mk extract')
@tangle('')
@tangle('extract.force: dummy')
@tangle('\t./mk extract force')
@tangle('')
@tangle('tut: dummy')
@tangle('\t./mk tutorial')
@tangle('')
@tangle('grammar: dummy')
@tangle('\tenv PYTHONPATH=. python script/get_grammar src/flx_parse.mly >misc/flx_parse.grammar')
@tangle('\tenv PYTHONPATH=. python script/get_grammar src/flx_cil_cparser.mly >misc/flx_cil_cparser.grammar')
#@tangle('\tenv PYTHONPATH=. python script/elk_flx_grgen misc/flx_parse.grammar >misc/elk_flx_gr.gr')
@tangle('\tenv PYTHONPATH=. python script/flx_flx_grgen misc/flx_parse.grammar >lib/flx_grammar.flx')
#@tangle('\tenv PYTHONPATH=. python script/elk_flx_lexgen misc/flx_parse.grammar >misc/elk_flx_lex.cc')
@tangle('\tenv PYTHONPATH=. python script/flx_tokgen misc/flx_parse.grammar >lib/flx_token.flx')
@tangle('')
@tangle('compiler: dummy')
@tangle('\t./mk --pkg=flx_compiler')
@tangle('')
@tangle('flx_tools:')
@tangle('\t./mk tools')
@tangle('')
@tangle('tools: flx_tools grammar')
@tangle('#tools: flx_tools grammar tools/lua_parser')
@tangle('')
@tangle('#tools: grammar bin/flx_doc tools/lua_parser')
@tangle('')
@tangle('tools/lua_parser: tools/lua_parser.flx')
@tangle('\tbin/flx --test --static -c tools/lua_parser')
@tangle('')
@tangle('bin/flx_doc: tools/flx_doc.flx')
@tangle('\tbin/flx --test --static -c tools/flx_doc && mv tools/flx_doc bin/flx_doc')
@tangle('')
@tangle('doc: grammar tools man impldoc rtldoc tutdoc')
@tangle('')
@tangle('#doc: grammar tools libdoc man impldoc tutdoc tutstyle')
@tangle('')
@tangle('impldoc: dummy')
@tangle('\t./mk doc impldoc')
@tangle('')
@tangle('rtldoc: dummy')
@tangle('\t./mk rtldoc')
@tangle('')
@tangle('tutdoc: dummy')
@tangle('\t./mk doc tutdoc')
@tangle('\t#cp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('doc.quiet: grammar tools libdoc')
@tangle('\t./mk quiet doc man impldoc')
@tangle('\tcp doc/*.css tut/doc >/dev/null 2>&1')
@tangle('')
@tangle('libdoc: grammar tools')
@tangle('\tbin/flx_doc --outdir=libdoc \\')
@tangle('\tlib/std.flx lib/stl.flx lib/flx_lex.flx \\')
@tangle('\tlib/flx_token.flx lib/flx_grammar.flx lib/lua.flx lib/lua_parse.flx')
@tangle('\tcp misc/flxdoc_style.css libdoc')
@tangle('')
@tangle('man: dummy')
@tangle('\t./mk man')
@tangle('')
@tangle('test: dummy')
@tangle('\t./mk test ')
@tangle('')
@tangle('test.flx_ptf_static_pointer: dummy')
@tangle('\t./mk test -DFLX_PTF_STATIC_POINTER ')
@tangle('')
@tangle('test.inline: dummy')
@tangle('\t./mk inline test ')
@tangle('')
@tangle('test.inline.static: dummy')
@tangle('\t./mk inline test static ')
@tangle('')
@tangle('test.debug: dummy')
@tangle('\t./mk debug test ')
@tangle('')
@tangle('test.lua_parser: dummy')
@tangle('\tfor i in misc/lua/*.lua; do tools/lua_parser $$i; done;')
@tangle('')
@tangle('tests: dummy')
@tangle('\t./mk test check_output')
@tangle('\tmake tests.bagley')
@tangle('\tmake test.lua_parser')
@tangle('')
@tangle('tests.sdl: dummy')
@tangle('\t./mk sdl')
@tangle('\t./mk static sdl')
@tangle('')
@tangle('tests.verify: dummy')
@tangle('\t./mk test check_output')
@tangle('')
@tangle('tests.static: dummy')
@tangle('\t./mk test static log_output')
@tangle('')
@tangle('tests.inline: dummy')
@tangle('\t./mk inline test log_output')
@tangle('')
@tangle('tests.performance: dummy')
@tangle('\t./mk performance')
@tangle('')
@tangle('performance: tests.performance')
@tangle('')
@tangle('tests.regression: dummy')
@tangle('\t./mk regression')
@tangle('')
@tangle('tests.bagley: dummy')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tsh bagley/check.sh')
@tangle('')
@tangle('speed: dummy')
@tangle('\t./mk speed')
@tangle('')
@tangle('pfcount.all:')
@tangle('\t./mk pfcount_all')
@tangle('')
@tangle('pfcount:')
@tangle('\t./mk pfcount')
@tangle('')
@tangle('rtl.debug: dummy')
@tangle('\t./mk rtl debug')
@tangle('')
@tangle('rtl: dummy')
@tangle('\t./mk rtl')
@tangle('')
@tangle('rtl.optimise: dummy')
@tangle('\t./mk rtl optimise_c')
@tangle('')
@tangle('elkhound: dummy')
@tangle('\t./mk elkhound')
@tangle('')
@tangle('expect.bagley: clean')
@tangle('\t./mk bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\tenv PYTHONPATH=. python script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('expect: clean')
@tangle('\t./mk bagley')
@tangle('\tsh bagley/compile.sh')
@tangle('\tsh bagley/run.sh')
@tangle('\t./mk test log_output')
@tangle('\tenv PYTHONPATH=. python script/mk_expect tut/examples > lpsrc/flx_tut_expect.ipk')
@tangle('\tenv PYTHONPATH=. python script/mk_expect test > lpsrc/flx_test_expect.ipk')
@tangle('\tenv PYTHONPATH=. python script/mk_expect bagley/felix > lpsrc/flx_bagley_expect.ipk')
@tangle('')
@tangle('drivers: dummy')
@tangle('\t./mk drivers')
@tangle('')
@tangle('drivers.debug: dummy')
@tangle('')
@tangle('help: dummy')
@tangle('\t#type "make virgin" to wipe out the whole development system')
@tangle('\t#other than the orginal sources, this makefile, and any user config data')
@tangle('\t#')
@tangle('\t#type "make boot" to extract the dervied sources')
@tangle('\t#from the original sources, including the tutorial')
@tangle('\t#')
@tangle('\t#type "make" to build the felix compiler and runtime')
@tangle('\t#REQUIRES OCAML 3.08.1 or better')
@tangle('\t#REQUIRES g++ 3.xx or better')
@tangle('\t#')
@tangle('\t#type "make test" to build and execute all the tests')
@tangle('\t#including all the tutorial examples')
@tangle('\t#REQUIRES Felix')
@tangle('\t#')
@tangle('\t#type "make doc" to typeset the original sources')
@tangle('\t#')
@tangle('\t#Obtain the required priviledges to install into the chosen directories')
@tangle('\t#or ask someone who has the to do it for you')
@tangle('\t#type "make install" to install Felix')
@tangle('')
@tangle('script:')
@tangle('\t./boot')
@tangle('')
@tangle('clean-src:')
@tangle('\trm -rf lpsrc')
@tangle('\trm -rf interscript')
@tangle('\trm -rf raw')
@tangle('\trm -rf gpl')
@tangle('\trm -rf lgpl')
@tangle('\trm -rf sandbox')
@tangle('\trm -rf boot.sh')
@tangle('\trm -rf boot.bat')
@tangle('')
@tangle('checkout:')
@tangle('\tsvn co https://svn.sourceforge.net:/svnroot/felix/felix/trunk .')
@tangle('')
@tangle('update:')
@tangle('\tsvn update')
@tangle('')
@tangle('')

@tangle('debian/rules: lpsrc/flx_debian.pak lpsrc/flx_maker.ipk')
@tangle('\trm -rf debian')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_debian.pak')
@tangle('\tchmod u+x debian/rules')
@tangle('')
@tangle('debian-package: debian/rules')
@tangle('\t(cd .. && make -f flx/Makefile.debian_package_creator package)')
@tangle('')
@tangle('www: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_sourceforge.pak')
@tangle('')
@tangle('clean: dummy')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\tpython script/maker clean')
@tangle('')
@tangle('distclean:')
@tangle('\trm -rf pkg tut rtl test www src misc man bin doc lib impldoc htmlman tmp tmp.tmp')
@tangle('\trm -rf elk tmp faio demux tmp.out')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('\trm -rf bagley')
@tangle('\trm -rf doc_out libdoc tools doxydoc')
@tangle('\trm -rf meta licences')
@tangle('\trm -rf lpsrc/*.cache')
@tangle('\trm -rf interscript/*.pyo')
@tangle('\trm -rf interscript/*/*.pyo')
@tangle('\trm -rf interscript/*/*/*.pyo')
@tangle('\trm -rf interscript/*.pyc')
@tangle('\trm -rf interscript/*/*.pyc')
@tangle('\trm -rf interscript/*/*/*.pyc')
@tangle('\trm -rf speed')
@tangle('\trm -rf cpkgs')
@tangle('\trm -rf spkgs')
@tangle('\trm -rf pthread')
@tangle('\trm -rf flxbuild')
@tangle('\trm -rf mkplugins')
@tangle('\trm -rf olddebian')
@tangle('\trm -rf script')
@tangle('\trm -rf manifests')
@tangle('\trm -rf pkg-stamps')
@tangle('')
@tangle('virgin: distclean')
@tangle('\tcp Makefile Makefile.old')
@tangle('\trm -rf debian/')
@tangle('\trm -f README LICENCE VERSION CONTENTS INSTALL AUTHORS NEWS COPYING ChangeLog')
@tangle('')

@tangle('backup: dummy')
@tangle('\t(DATE=`date +"%Y-%m-%d-%H%M"`;\\')
@tangle('\tmkdir -p "lpbackup/$${DATE}";\\')
@tangle('\tfind lpsrc -name "*.ipk" -exec cp "{}" "lpbackup/$${DATE}" ";";\\')
@tangle('\tfind lpsrc -name "*.pak" -exec cp "{}" "lpbackup/$${DATE}" ";";\\')
@tangle('\tfind homepage -name "*.html" -exec cp "{}" "lpbackup/$${DATE}" ";"\\')
@tangle('\t)')
@tangle('')

@tangle('config: dummy')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_config.pak')
@tangle('\tenv PYTHONPATH=. python -O script/make_config.py --quiet --prefix=${PREFIX} ${CONFIG_ARGS}')
@tangle('')
@tangle('config/config.py: config')
@tangle('')
@tangle('boot: config/config.py')
@tangle('\t${BUILTIN_ISCR} lpsrc/flx_maker.pak')
@tangle('')
@tangle('default_wrappers:')
@tangle('\tfor i in tmp/*.default; do cp $$i config/`basename $$i .default`; done')
@tangle('')
@tangle('wrappers.clean:')
@tangle('\trm -rf flxcc_out c89 c99 cxx gnu89 gnu99 gnucxx cxx_sys')
@tangle('')
@tangle('config/cxx.flxcc: default_wrappers')
@tangle('')
@tangle('wrappers:')
@tangle('\tbin/flxcc config/c89.flxcc')
@tangle('\tbin/flxcc config/c99.flxcc')
@tangle('\tbin/flxcc config/gnu89.flxcc')
@tangle('\tbin/flxcc config/gnu99.flxcc')
@tangle('\tbin/flxcc config/cxx.flxcc')
@tangle('\tbin/flxcc config/cxx_sys.flxcc')
@tangle('\tbin/flxcc config/gnucxx.flxcc')
@tangle('\tbin/flxcc config/usr_include.flxcc')
@tangle('')
@tangle('install: dummy')
@tangle('\tinstall -d ${MAN_DIR}')
@tangle('\tinstall -d ${INSTALL_DIR}/bin')
@tangle('\tinstall -d ${INSTALL_DIR}/lib')
@tangle('\tinstall -d ${INSTALL_DIR}/rtl')
@tangle('\tinstall -d ${INSTALL_DIR}/config')
@tangle('\tinstall -d ${DOC_DIR}/doc')
@tangle('\tinstall -d ${EXEC_DIR}')
@tangle('\tfor file in `ls config/*.py` `ls config/*.fpc` `ls config/*.flxcc`; do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/config; fi; done')
@tangle('\tinstall bin/flx ${EXEC_DIR}')
@tangle('\tfor file in `ls bin/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/bin; fi; done')
@tangle('\tfor file in `ls rtl/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/rtl; fi; done')
@tangle('\tfor file in `ls lib/*`;      do if [ -f $$file ]; then install $$file ${INSTALL_DIR}/lib; fi; done')
@tangle('\tfor file in `ls doc/*`;      do if [ -f $$file ]; then install $$file ${DOC_DIR}/doc; fi; done')
@tangle('\tfor file in `ls man/man1/*`; do if [ -f $$file ]; then install $$file ${MAN_DIR}/man1; fi; done')
@tangle('\techo "Stuff in misc has to be installed by hand"')
@tangle('')

@tangle('dummy:')
@no_dollars = string.replace(FLX_MAKER_CVS_ID,"$","")
@tangle('\t#'+no_dollars)
@tangle('')
@tangle('.PHONY: dummy')
@tangle('')
@tangle('#')
@tangle('# ============== TARBALL MAKERS AND UPLOADERS ==============')
@tangle('#')
@tangle('# ------- TARBALL MAKERS --------------')
@tangle('#')
@tangle('')
@tangle('src_tarball: extract ')
@tangle('\trm -f felix-'+flx_version)
@tangle('\tln -s . felix-'+flx_version)
@tangle('\ttar -cvf flx_'+flx_version+'_src.tar\\')
@tangle('\t\tfelix-'+flx_version+'/configure \\')
@tangle('\t\tfelix-'+flx_version+'/mk \\')
@tangle('\t\tfelix-'+flx_version+'/autogen.sh \\')
@tangle('\t\tfelix-'+flx_version+'/*.bat \\')
@tangle('\t\tfelix-'+flx_version+'/Makefile \\')
@tangle('\t\tfelix-'+flx_version+'/README \\')
@tangle('\t\tfelix-'+flx_version+'/CONTENTS \\')
@tangle('\t\tfelix-'+flx_version+'/INSTALL \\')
@tangle('\t\tfelix-'+flx_version+'/VERSION \\')
@tangle('\t\tfelix-'+flx_version+'/LICENCE \\')
@tangle('\t\tfelix-'+flx_version+'/NEWS \\')
@tangle('\t\tfelix-'+flx_version+'/AUTHORS \\')
@tangle('\t\tfelix-'+flx_version+'/COPYING \\')
@tangle('\t\tfelix-'+flx_version+'/ChangeLog \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.ipk \\')
@tangle('\t\tfelix-'+flx_version+'/lpsrc/*.pak \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/bin/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/compilers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/core/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sinks/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/sources/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/drivers/storage/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/encoding/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/frames/platform/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/languages/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/parsers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tanglers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/tokenisers/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/utilities/*.py \\')
@tangle('\t\tfelix-'+flx_version+'/interscript/weavers/*.py ')
@# debian requires gzip -9
@tangle('\tgzip -9 flx_'+flx_version+'_src.tar')
@tangle('\tmv -f flx_'+flx_version+'_src.tar.gz flx_'+flx_version+'_src.tgz')
@tangle('')
@tangle('media_tarball:')
@tangle('\trm -f flx_media.tgz')
@tangle('\ttar -zcvf flx_media.tgz media')
@tangle('')
@tangle('doc_tarball:')
@tangle('\trm -f flx_doc.tgz')
@tangle('\ttar -zcvf flx_doc.tgz doc')
@tangle('')
@tangle('speed_tarball:')
@tangle('\trm -f flx_speed.tgz')
@tangle('\ttar -zcvf flx_speed.tgz speed/*.html speed/*.css speed/machine/*/images/*.jpg speed/machine/*/rankings/*.txt')
@tangle('')
@tangle('#')
@tangle('# ------- TARBALL FILES  --------------')
@tangle('#')
@tangle('flx_media.tgz: media_tarball')
@tangle('')
@tangle('flx_doc.tgz: doc_tarball')
@tangle('')
@tangle('flx_speed.tgz: speed_tarball')
@tangle('')
@tangle('flx_'+flx_version+'_src.tgz: src_tarball')
@tangle('')
@tangle('tarballs: flx_'+flx_version+'_src.tgz flx_speed.tgz flx_doc.tgz flx_media.tgz')
@tangle('')
@tangle('#')
@tangle('# ------- UPLOADERS --------------')
@tangle('#')
@tangle("#")
@tangle("# ******* WEB SITE MISC")
@tangle("#")
@tangle('upload_images:')
@tangle('\tscp homepage/images/*.jpg ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/images')
@tangle('')
@tangle('upload_homepage: dummy')
@tangle('\tscp homepage/*.html ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('upload_www: upload_homepage')
@tangle('\tscp www/*.html ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/www')
@tangle('')
@tangle("#")
@tangle("# ******* LP SOURCE TARBALL")
@tangle("#")
@tangle('upload_src: flx_'+flx_version+'_src.tgz')
@tangle('\tscp flx_'+flx_version+'_src.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle("#")
@tangle("# ******* MEDIA REQUIRED FOR TESTS")
@tangle("#")
@tangle('upload_media: flx_media.tgz')
@tangle('\tscp flx_media.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs')
@tangle('')
@tangle("#")
@tangle("# ******* SPEED TEST TARBALL")
@tangle("#")
@tangle('upload_speed: flx_speed.tgz')
@tangle('\tscp -r flx_speed.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle("#")
@tangle("# ******* DOC TARBALL")
@tangle("#")
@tangle('upload_docs: flx_doc.tgz')
@tangle('\tscp -r flx_doc.tgz ${USER}@felix.sf.net:/home/groups/f/fe/felix/htdocs/')
@tangle('')
@tangle('# note: media is not uploaded here because it does not change much ')
@tangle('upload: upload_src upload_speed upload_docs')
@tangle('')
@tangle("#")
@tangle("# --------- UNPACKER -----------------------")
@tangle("#")
@tangle('unpack:')
@tangle('\tssh ${USER}@felix.sf.net "(cd /home/groups/f/fe/felix/htdocs/; tar -zxvf flx_doc.tgz; tar -zxvf flx_speed.tgz)"')
@tangle('')
@tangle('')
@tangle('')
@tangle('')
@tangle('')
@tangle('')

@head(1,'README')
@select(tangler('README'))
This will be the readme file one day ..
please see the INSTALL file

@head(1,'AUTHORS')
@select(tangler('AUTHORS'))
John (Max) Skaller skaller at users dot sourceforge dot net
Peter Jolly helped do the Cygwin build

The version of frontc C parser was taken from
work by:

George C. Necula    necula at cs dot berkeley dot edu
Scott McPeak        smcpeak at cs dot berkeley dot edu
Wes Weimer          weimer at cs dot berkeley dot edu

which was in turned modified from the original parser
written by Hugues Cassé

@head(1,'COPYING')
@select(tangler('COPYING'))
Felix is free for any use. Just don't misrepresent
the Authors. The C parser is derived from
FrontC/CIL which is has BSD licence.

@head(1,'ChangeLog')
@select(tangler('ChangeLog'))
Well, this file shouldn't be here, it should
be generated by something .. 

@head(1,'NEWS')
@select(tangler('NEWS'))
Well, this file shouldn't be here, it should
be generated by something .. 


@head(1,'CONTENTS')
@select(tangler('CONTENTS'))
The tarball contains the literate programmed original sources,
all the sources derived from that by running interscript,
including Ocaml sources for the compiler, C++ sources for
the run time components, build scripts, documentation,
the tutorial, and all the examples and regression tests, 
the codes generated by running Felix against the examples,
and finally, a linux binary version of the compiler
and program driver. 

Top level files:

@tangle('  VERSION   current version number, should be '+flx_version)
  CONTENTS  (this file)
  README    the usual readme file
  INSTALL   how to install and build felix
  LICENCE   licence details
  AUTHORS   list of contributors
  NEWS      handy place to plug Felix
  ChangeLog where change info should go but doesn't

  config/buildno.txt contains the build sequence number
            this must differ between builds in case
            Marshalled data format changes
            it may not exist when you start,
            the script/maker script creates it
            when necessary
 
  Makefile   the makefile, mainly hooks into script/maker
 
  script/maker  This is the main make script, written in Python

The directories are:

  config  -- user configuration data

  lpsrc   -- LP original sources, contains EVERYTHING you need
             if you have the full tool chain installed

  lpbackup -- backup of LP sources (make backups with 'make backup' :)

  interscript -- the complete interscript package
  src     -- ocaml source code for the compiler
  test    -- regression tests and driver programs
  doc     -- the complete documented source of the compiler
  htmlman -- man pages converted to html by htmlman

  tut/doc -- the tutorial
  tut/examples  -- examples from the tutorial
  www    -- the top level of the sourceforge web site
  script -- python build script
  misc   -- misc files including vim syntax colouring file
  meta   -- contains various package manager meta-data files
  lib    -- felix standard library
  man    -- man pages for tools and some language features
  bin    -- compiler tools directory
  rtl    -- C++ run time library sources

@head(1,'LICENCE')
@select(tangler('LICENCE'))
@tangle('Version ' + flx_version + ' of Felix')
is free for any use, provided the authors
are not misrepresented in any way.

Parts of this code, included in the file 


lpsrc/flx_frontc.ipk
lpsrc/flx_cil.ipk

are covered by a BSD Licence, here is the copyright notice:
(*
 *
 * Copyright (c) 2001 by
 *  George C. Necula        necula@cs.berkeley.edu
 *  Scott McPeak        smcpeak@cs.berkeley.edu
 *  Wes Weimer          weimer@cs.berkeley.edu
 *   
 * All rights reserved.  Permission to use, copy, modify and distribute
 * this software for research purposes only is hereby granted, 
 * provided that the following conditions are met: 
 * 1. Redistributions of source code must retain the above copyright notice, 
 * this list of conditions and the following disclaimer. 
 * 2. Redistributions in binary form must reproduce the above copyright notice, 
 * this list of conditions and the following disclaimer in the documentation 
 * and/or other materials provided with the distribution. 
 * 3. The name of the authors may not be used to endorse or promote products 
 * derived from  this software without specific prior written permission. 
 *
 * DISCLAIMER:
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR 
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES 
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. 
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT, 
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, 
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS 
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON 
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF 
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 *)


@head(1,'INSTALL')
@select(tangler('INSTALL'))

FULL BUILD.
-----------

1. Download, build, and install Ocaml (3.08.1 or greater)
   if you don't have it already

   http://caml.inria.fr

2. Download, build, and install Python (1.5.2 or later)
   if you don't have it already

    http://www.python.org
    http://python.sourceforge.net

3. Download the Felix tarball (this package)
   and unpack it in your workspace
   
@tangle('   tar -zxvf flx_'+flx_version+'_src.tgz')
@tangle('   cd felix_'+flx_version)

4. Bootstrap the system.

  ./configure

OR type

   make config
   make boot
   make extract

EDIT THE FILES

  config/*.py

TO SUIT YOUR TASTES. THIS FILE IS NOT CLOBBERED.
YOU MAY NEED TO DELETE IT AND RUN 'make boot'
again to reset to the defaults.

5. Build the compiler

   make 

6. Build the documentation and tutorial

   make doc 

7. Install the compiler

   Become super user if necessary, then:

   make install -- installs felix

REBUILD
-------

  make virgin        -- this deletes EVERYTHING generated
                        except the Makefile

  make boot          -- use this to reextract after a make virgin

  make clean         -- use this to delete all output from
                        test runs

PERFORMANCE TEST
----------------

  make performance    -- takes a few minutes to run

This test flogs the cooperative mult-tasking system
by generating 1 million threads and sending each
of them two messages: its a rough guide to how much
overhead there would be handling, say, 1 million
concurrent phone calls, web connections, or sprites
in a game.

LOST THE MAKEFILE?
------------------

  env PYTHONPATH=. python interscript/bin/iscr.py lpsrc/flx.pak 
  
                     -- re-extract sources

HOW TO USE IT
-------------

make a sample program mytest.flx:

  #import <flx.flxh>
  include "std";
  print "It works!"; endl;

and then run it:
  
  flx -Ilib mytest

@head(1,'W3C Cascading Style Sheets')
Needed to view interscript generated documentation.
Also some gif images.

@python("//")
def mkgif(fn,d):
  f = open("misc"+os.sep+fn+".gif","w")
  f.write(d)
  f.close()

plus=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\x91\x00\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\x00\x00"+
  "\x00\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x14\x8c\x8f\xa0"+
  "\x0b\xb6\xb2\x9c\x82\xca\x89\x7b"+
  "\x5b\x78\x71\xcf\xce\x74\x08\x52"+
  "\x00\x00\x3b")

minus=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\x91\x00\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\x00\x00"+
  "\x00\x2c\x00\x00\x00\x00\x09\x00"+
  "\x09\x00\x00\x02\x11\x8c\x8f\xa0"+
  "\x0b\xc6\xeb\x5e\x0b\x40\x58\x3b"+
  "\x65\x96\xf1\xa1\x1f\x14\x00\x3b")

dot=("\x47\x49\x46\x38\x39\x61\x09\x00"+
  "\x09\x00\xa1\x03\x00\xfe\xfe\xfe"+
  "\x82\x82\x82\x02\x02\x02\xff\xff"+
  "\xff\x21\xfe\x15\x43\x72\x65\x61"+
  "\x74\x65\x64\x20\x77\x69\x74\x68"+
  "\x20\x54\x68\x65\x20\x47\x49\x4d"+
  "\x50\x00\x2c\x00\x00\x00\x00\x09"+
  "\x00\x09\x00\x00\x02\x14\x8c\x8f"+
  "\xa0\x0b\xb6\xb2\x1c\x10\x54\x39"+
  "\x8a\x5b\x50\x59\xbf\xb8\x31\x16"+
  "\x42\x16\x00\x3b")

mkgif("plus",plus)
mkgif("minus",plus)
mkgif("dot",dot)

//

@select(tangler('misc/interscript.css','data'))
BODY {
  background-color : #FFFFF0;
}
BODY EM {
  color: #A01010;
}

BODY CODE {
  color: #101080;
}
DIV.CODE {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
SPAN.LINENO {
  color : #101010;
  font-size: 80%;
}

DIV.CODE SPAN.KEYWORD {
  color : #000000;
  font-weight: bold;
}
DIV.CODE SPAN.NAME {
  color : #000000;
}
DIV.CODE SPAN.STRING{
  color : #004000;
}
DIV.CODE SPAN.NUMBER {
  color : #002020;
}
DIV.CODE SPAN.BRACKET {
  color : #800000;
}
DIV.CODE SPAN.PUNCT {
  color : #802000;
}
DIV.CODE SPAN.OP {
  color : #400000;
}
DIV.CODE SPAN.COMMENT {
  color : #000000;
  background-color : #FFF0FF;
  font-size: 80%;
  font-family: sans-serif;
}

TABLE.DEFAULT_TABLE_CLASS {
  color: #101010;
  background-color: #F0F0E0;
}

TABLE.DIFF {
  color: #204060;
  background-color: #FFE0E0;
}

DIV.CODE_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.CODE_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.CODE_SECTION_HEAD SMALL, DIV.CODE_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.CODE_SECTION_HEAD STRONG, DIV.CODE_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.CODE_SECTION_HEAD EM, DIV.CODE_SECTION_FOOT EM {
  display: inline;
}

DIV.TEST_OUTPUT {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.BAD_TEST_OUTPUT {
  color : #101080;
  background-color: #FFE0E0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}
DIV.TEST_OUTPUT_RESULT {
  margin-top: 1.5 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}
DIV.TEST_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.TEST_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.TEST_OUTPUT_SECTION_HEAD SMALL, DIV.TEST_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.TEST_OUTPUT_SECTION_HEAD STRONG, DIV.TEST_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.TEST_OUTPUT_SECTION_HEAD EM, DIV.TEST_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.EXPECTED_OUTPUT {
  color : #101080;
  background-color: #E0FFFF;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.EXPECTED_OUTPUT_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.EXPECTED_OUTPUT_SECTION_HEAD SMALL, DIV.EXPECTED_OUTPUT_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD STRONG, DIV.EXPECTED_OUTPUT_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.EXPECTED_OUTPUT_SECTION_HEAD EM, DIV.EXPECTED_OUTPUT_SECTION_FOOT EM {
  display: inline;
}

DIV.DIFF {
  color : #101080;
  background-color: #E0FFE0;
  margin-top: 0.0 ex;
  padding-top: 0.4 ex;
  padding-bottom: 0.2 ex;
  margin-bottom: 0.0 ex;
  margin-right: 2 ex;
  border: thin solid gray;
  display: block;
}

DIV.DIFF_SECTION_HEAD {
  margin-top: 1 ex;
  padding-top: 0.2 ex;
  border-top: 0 ex;
  padding-bottom: 0.0 ex;
  border-bottom: 0 ex;
  margin-bottom: -1 ex;
  padding-left: 0.1 em;
  display: block;
}

DIV.DIFF_SECTION_FOOT {
  margin-top: -1.0 ex;
  padding-top: 0.0 em;
  border-top-width: 0.0 em;
  border-bottom-width: 0.0 em;
  padding-bottom: 0.0 em;
  margin-bottom: 0.0 em;
  display: block;
  display:none;
}

DIV.DIFF_SECTION_HEAD SMALL, DIV.DIFF_SECTION_FOOT SMALL{
  color : #503020;
  font-size: 80%;
  display: inline;
  color: #101080;
}
DIV.DIFF_SECTION_HEAD STRONG, DIV.DIFF_SECTION_FOOT STRONG {
  font-family : monospace, courier;
  font-weight: normal;
  font-size: 100%;
  display: inline;
  color : black;
}
DIV.DIFF_SECTION_HEAD EM, DIV.DIFF_SECTION_FOOT EM {
  display: inline;
}

@select(tangler('misc/user.css','data'))
// dummy: to be replaced by the user (but needed for some browsers)


@head(1,"fishcc")
Script to compile a C program generated by FISh.
@select(tangler("bin/fishcc"))
grab=1
CCFLAGS=""
while (( "$grab" == "1" ));
do
  case x$1 in
  x-*)
    CCFLAGS="$CCFLAGS $1"
    shift
  ;;

  x*)
    grab=0
  ;;

  esac
done
@tangle('cmd="'+CCLINK_STATIC+' $1 -O -o `basename $1 .c` `echo "$CCFLAGS"` -lflx_static"')
echo $cmd
`$cmd`

@head(1,'Run script')
@select(tangler('bin/flx.bat','data'))
@@echo off
SETLOCAL
SET RUNIT=1
SET DOFLXG=1
SET DOECHO=0
SET FID=%FLX_INSTALL_DIR%
SET STATIC=0

:DOARGS
IF "-c" EQU "%1" (
SET RUNIT=0
SHIFT
GOTO DOARGS
)

IF "--nofelix" EQU "%1" (
SET DOFLXG=0
SHIFT
GOTO DOARGS
)

IF "--echo" EQU "%1" (
echo on
SET DOECHO=1
SHIFT
GOTO DOARGS
)

IF "--test" EQU "%1" (
SET FID=.
SHIFT
GOTO DOARGS
)

IF "--static" EQU "%1" (
SET STATIC=1
SHIFT
GOTO DOARGS
)

"%FID%\BIN\FLXG" -I"%FID%\LIB" %1 >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
if %STATIC% EQU 0 (
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:cflags @%1.resh >%1_cflags.txt
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MD /c /EHs /w  /I"%FID%\RTL" @%1_cflags.txt %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:provides_dlib --field:requires_dlibs @%1.resh >%1_linkflags.txt
if ERRORLEVEL 1 GOTO ERROR
link /dll %1.obj /OUT:%1.dll @%1_linkflags.txt /LIBPATH:"%FID%\BIN" /DEFAULTLIB:libflx_dynamic >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1.exp
del %1.lib
del %1_cflags.txt
del %1_linkflags.txt
IF %RUNIT% EQU 1 (
"%FID%\bin\flx_run" %1 %2 %3 %4 %5 %6 %7 %8 %9  
)
) else (
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:cflags @%1.resh >%1_cflags.txt
if ERRORLEVEL 1 GOTO ERROR
cl /nologo /MT /c /EHs /w  /I"%FID%\RTL" /DFLX_STATIC_LINK @%1_cflags.txt %1.cpp /Fo%1.obj >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
%FID%\BIN\FLX_PKGCONFIG --path:%FID%\CONFIG --field:provides_slib --field:requires_slibs @%1.resh >%1_linkflags.txt
link "%FID%\rtl\flx_run_static.obj" %1.obj /OUT:%1.exe @%1_linkflags.txt /LIBPATH:"%FID%\RTL" /DEFAULTLIB:libflx_async_static /DEFAULTLIB:libfaio_static /DEFAULTLIB:libdemux_static /DEFAULTLIB:libflx_pthread_static /DEFAULTLIB:libflx_static >"%1.LOG"
if ERRORLEVEL 1 GOTO ERROR
del %1_cflags.txt
del %1_linkflags.txt
%1 %2 %3 %4 %5 %6 %7 %8 %9
)
GOTO FINISHED
:ERROR
ECHO SOME KIND OF ERROR OCCURED, rerun with --echo
type %1.LOG
EXIT /B 1
:FINISHED
ENDLOCAL

@select(tangler('bin/flx','data'))
#!/usr/bin/env bash
# flx - felix script harness
@tangle("INSTALL_ROOT="+PREFIX+"/lib/felix/felix-"+flx_version)
@tangle("FLX_INSTALL_DIR=${FLX_INSTALL_DIR:-"+PREFIX+"/lib/felix/felix-"+flx_version+"}")
@tangle("CYGWIN="+str(CYGWIN))
@tangle("WIN32="+str(WIN32))
@tangle("MACOSX="+str(MACOSX))
@tangle("HAVE_GNU="+str(HAVE_GNU))
@tangle("HAVE_MSVC="+str(HAVE_MSVC))
@tangle('CCOBJ_DLLIB="'+CCOBJ_DYNAMIC_FLX+'"')
@tangle('CCLINK_DLLIB="'+CCLINK_DYNAMIC_FLX+'"')
@tangle('CCOBJ_STATIC_LIB="'+CCOBJ_STATIC_FLX+'"')
@tangle('CCLINK_STATIC="'+CCLINK_STATIC+'"')
@tangle('VERSION="'+flx_version+'"')
@tangle('EXT_LIB="'+EXT_LIB+'"')
@tangle('EXT_STATIC_OBJ="'+EXT_STATIC_OBJ+'"')
@tangle('EXT_SHARED_OBJ="'+EXT_SHARED_OBJ+'"')
@tangle('EXT_EXE="'+EXT_EXE+'"')
@tangle('EXT_SHLIB="'+EXT_SHLIB+'"')
@tangle('SPEC_OBJ_FILENAME="'+SPEC_OBJ_FILENAME+'"')
@tangle('SPEC_EXE_FILENAME="'+SPEC_EXE_FILENAME+'"')
@tangle('OPTIMISE="'+OPTIMISE+'"')
@tangle('DEBUG_FLAGS="'+DEBUG_FLAGS+'"')
@if PTHREAD_SWITCH != None:
  tangle('PTHREAD_SWITCH="'+PTHREAD_SWITCH+'"')
 else:
  tangle('PTHREAD_SWITCH=""')

# check for test mode: this argument must come first

TESTMODE=0
RECOMPILE=0
DEBUG=0
INLINE=10
ECHO=0
TIME=0
@if DEFAULT_LINK_MODEL=="dynamic":
   tangle("STATIC=0")
 else:
   tangle("STATIC=1")

RUNIT=1
CCFLAGS=""
FELIX=1
LINKER_SWITCHES=""
MACROS=""
grab=1
cpps=""
cppos=""
INCLUDE_DIRS=""

while (( "$grab" == "1" ));
do
  case x$1 in
  x--test=*)
    TESTMODE=1
    FLX_INSTALL_DIR=${1:7}
    shift
  ;;

  x--test)
    TESTMODE=1
    FLX_INSTALL_DIR=.
    shift
  ;;

  x--force)
    RECOMPILE=1
    shift
  ;;

  x--debug)
    DEBUG=1
    ECHO=1
    shift
  ;;

  x--time)
    TIME=1
    shift
  ;;

  x--echo)
    ECHO=1
    shift
  ;;

  x--static)
    STATIC=1
    shift
  ;;

  x--inline=*)
    INLINE=${1:9}
    shift
  ;;

  x--inline)
    INLINE=50
    shift
  ;;

  x--noinline)
    INLINE=0
    shift
  ;;

  x--opt=1)
    INLINE=10
    CCFLAGS="-O1 $CCFLAGS"
    shift
  ;;

  x--opt=2)
    INLINE=20
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--opt=3)
    INLINE=50
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--optimise)
    INLINE=10
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--optimize)
    INLINE=10
    CCFLAGS="$CCFLAGS$OPTIMISE"
    shift
  ;;

  x--version)
    echo $VERSION
    exit 0
  ;;

  x--help)
    man flx
    exit 0
  ;;

  x-c)
    RUNIT=0
    shift
  ;;

  x-I*)
    INCLUDE_DIRS="$INCLUDE_DIRS $1"
    shift
  ;;

  x--nofelix)
    FELIX=0
    shift
  ;;

  x-[lL]*)
   LINKER_SWITCHES="$LINKER_SWITCHES $1"
   shift
  ;;

  x-D*)
   MACROS="$MACROS $1"
   shift
  ;;

  x*.cpp)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .cpp`$EXT_OBJ"
    shift
  ;;

  x*.cxx)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .cxx`$EXT_OBJ"
    shift
  ;;

  x*.c)
    cpps="$cpps $1"
    cppos="$cppos `dirname $1`/`basename $1 .c`$EXT_OBJ"
    shift
  ;;

  x*.o)
    cppos="$cppos `dirname $1`/`basename $1 .o`$EXT_OBJ"
    shift
  ;;

  x*.obj)
    cppos="$cppos `dirname $1`/`basename $1 .obj`$EXT_OBJ"
    shift
  ;;

  x*.a)
    cppos="$cppos $1"
    shift
  ;;

  x*.lib)
    cppos="$cppos $1"
    shift
  ;;

  x--pkg=*)
    pkgs=" `echo \"$1\" | sed 's/--pkg=\(.*\)/\\1/'`"
    shift
  ;;

# unknown flag .. pass to both compile and link
   x-*)
      cpps="$cpps $1"
      cppos="$cppos $1"
      shift
    ;;

# the main filename -- subsequent args are args to flx_run
  x*)
    grab=0
  ;;

  esac
done

@if HAVE_MSVC:
  tangle('DLINK_STRING="/link /LIBPATH:${FLX_INSTALL_DIR}\\\\bin "')
  tangle('SLINK_STRING="/link /LIBPATH:${FLX_INSTALL_DIR}\\\\bin "')
 elif CYGWIN or WIN32:
  tangle('DLINK_STRING="-L${FLX_INSTALL_DIR}/bin "')
  tangle('SLINK_STRING="-L${FLX_INSTALL_DIR}/rtl "')
 else:
  tangle('DLINK_STRING="-L${FLX_INSTALL_DIR}/rtl "')
  tangle('SLINK_STRING="-L${FLX_INSTALL_DIR}/rtl "')


PKGCONFIG=$FLX_INSTALL_DIR/bin/flx_pkgconfig

if [ "$ECHO" = "1" ]
then
  echo "#FLX_INSTALL_DIR=$FLX_INSTALL_DIR"
  echo "#PKGCONFIG=$PKGCONFIG"
fi


# find external header files
PKGCONFIG_CFLAGS="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=cflags "

# find external dynload libraries
PKGCONFIG_DLIBS="$PKGCONFIG -r --path+=$FLX_INSTALL_DIR/config --field=provides_dlib --field=requires_dlibs "

# find external static libraries
PKGCONFIG_SLIBS="$PKGCONFIG -r --keeprightmost --path+=$FLX_INSTALL_DIR/config --field=provides_slib --field=requires_slibs "

#find driver package required
PKGCONFIG_DRIVER="$PKGCONFIG --path+=$FLX_INSTALL_DIR/config --field=flx_requires_driver "

# make a list of any *.cpp files (or other g++ options ..)

if [ $STATIC = 0 ]
then
  EXT_OBJ=$EXT_SHARED_OBJ
else
  EXT_OBJ=$EXT_STATIC_OBJ
fi

if [ "x$1" = "x" ]
then
  echo "usage: flx [options] filename"
  exit 1
fi

# Strip trailing .flx or .so
# users should type 'flx file' without extension,
# but #! interpreter always passes extension ..

case "$1" in
  *.flx)
    arg="`echo $1 | sed 's/\.flx$//'`"
    is_flx=1
  ;;

  *.so)
    arg="`echo $1 | sed 's/\.so$//'`"
    is_so=1
  ;;

  *)
    arg="$1"
esac

# Find absolute pathname

base=$arg

if [ "x$base" = "x" ]
then
  echo "No such felix program: $arg" >&2
  exit 1
fi

shift

function calpackages () {
  # find all include directories
  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_CFLAGS @$base.resh"
  fi

  INCLUDE_DIRS="$INCLUDE_DIRS $($(echo $PKGCONFIG_CFLAGS @$base.resh))"

  if [ "$ECHO" = "1" ]
  then
    echo "$PKGCONFIG_DRIVER @$base.resh"
  fi

  # find the driver package
  DRIVER_PKG=$($(echo $PKGCONFIG_DRIVER @$base.resh))
  if [ x$DRIVER_PKG = x ]
  then
    # default to flx_run if none specified
    DRIVER_PKG=flx_run
  fi

  # find the driver entity
  if [ $STATIC = 0 ]
  then
    # dynamic linkage: the driver executable
    DRIVER=$FLX_INSTALL_DIR/bin/$DRIVER_PKG$EXT_EXE
  else
    # static linkage: the driver object file
    DRIVER=$FLX_INSTALL_DIR/rtl/$DRIVER_PKG$EXT_STATIC_OBJ
  fi

  if [ $STATIC = 0 ]
  then 
    if [ "$ECHO" = "1" ]
    then
     echo "$PKGCONFIG_DLIBS @$base.resh"
    fi

    # dynamic linkage: all the libraries required by the application
    LINK_STRING="$DLINK_STRING$LINKER_SWITCHES $($(echo $PKGCONFIG_DLIBS @$base.resh))"
  else
    if [ "$ECHO" = "1" ]
    then
     echo "$PKGCONFIG_SLIBS $DRIVER_PKG @$base.resh"
    fi

    # static linkage: all the libraries required by the application and driver
    LINK_STRING="$SLINK_STRING$LINKER_SWITCHES $($(echo $PKGCONFIG_SLIBS $DRIVER_PKG @$base.resh))"
  fi

  if [ $ECHO = 1 ]
  then
    echo "#RESOURCE FILE=$base.resh"
    echo "#INCLUDE_DIRS=$INCLUDE_DIRS"
    echo "#DRIVER=$DRIVER"
    echo "#LINK_STRING=$LINK_STRING"
  fi
  
}

# grab arguments
grab=1
args=""
while (( "$grab" == "1" ));
do
  case "x$1" in
    x)
      grab=0
    ;;

    x*)
      args="$args $1"
      shift
    ;;
 esac
done

INCLUDE_DIR="-I$FLX_INSTALL_DIR/rtl"
FLXLIB="-I$FLX_INSTALL_DIR/lib"
if [ "$CYGWIN" = "1" -o "$WIN32" = "1" ]
then
  # bash is a heap of crap! The escaped quotes here are
  # required in case the PATH has a filename with spaces
  # However this actually fails on Linux!
  FLXG="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" $FLX_INSTALL_DIR/bin/flxg"
  FLXRUN="env \"PATH=$FLX_INSTALL_DIR/bin:\$PATH\" "
else
  FLXG="env PATH=$FLX_INSTALL_DIR/bin:\$PATH $FLX_INSTALL_DIR/bin/flxg"
  # the mac uses DYLD_LIBRARY_PATH instead of LD_LIBRARY_PATH
  if [ "$MACOSX" = "1" ]
  then
    FLXRUN="env DYLD_LIBRARY_PATH=$FLX_INSTALL_DIR/rtl:\$DYLD_LIBRARY_PATH "
  else
    FLXRUN="env LD_LIBRARY_PATH=$FLX_INSTALL_DIR/rtl:\$LD_LIBRARY_PATH "
  fi
fi
ELKHOUND="--elkhound=$FLX_INSTALL_DIR/bin/flx_elkhound"

DEBUGSWITCH=""
if [ "$DEBUG" = "1" ]; then DEBUGSWITCH=" --debug"; fi
STATIC_ENV=""
if [ "$DEBUG" = "1" ]; then STATIC_ENV="env FLX_DEBUG=1 "; fi

# No need to compile, just run it
if [ $STATIC = 0 ]
then
  if [ $RECOMPILE = 0 -a -r "$base$EXT_SHLIB" -a "(" ! -r "$base.flx" -o "$base$EXT_SHLIB" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      calpackages
      cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
      exit $?
    fi
  fi
else
  if [ $RECOMPILE = 0 -a -r "$base$EXT_EXE" -a "(" ! -r "$base.flx" -o "$base$EXT_EXE" -nt "$base.flx" ")" ]
  then
    if [ $RUNIT = 1 ]
    then
      cmd="$STATIC_ENV $base $args"
      if [ $ECHO = 1 ]; then echo $cmd; fi
      eval $cmd
      exit $?
    fi
  fi
fi

# Need Felix and c++ compile, then run it

if [ $DEBUG = 1 ]
then
  VERBOSE="-v"
  CCFLAGS="$CCFLAGS$DEBUG_FLAGS"
else
  VERBOSE="-q"
fi

FLXFLAGS="--inline=$INLINE"

if [ $STATIC = 0 ]
then
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND $FLXLIB $INCLUDE_DIRS $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    calpackages
    CCMD="$CCOBJ_DLLIB $CCFLAGS -DTARGET_BUILD $INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_DLLIB $CCFLAGS $cppos $base$EXT_OBJ $SPEC_EXE_FILENAME$base$EXT_SHLIB $LINK_STRING "
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
          else
            cmd="$FLXRUN$DRIVER$DEBUGSWITCH $base$EXT_SHLIB $args"
          fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
      fi
    fi
  fi
else
  if [ $FELIX = 1 ]
  then
    FCMD="$FLXG $VERBOSE $FLXFLAGS $ELKHOUND $FLXLIB $INCLUDE_DIRS $base"
    if [ $ECHO = 1 ]; then echo "$FCMD"; fi
    eval $FCMD
  fi
  if [ $? = 0 ]
  then
    calpackages
    CCMD="$CCOBJ_STATIC_LIB $CCFLAGS -DTARGET_BUILD -DFLX_STATIC_LINK $INCLUDE_DIR $INCLUDE_DIRS $MACROS $cpps $base.cpp $SPEC_OBJ_FILENAME$base$EXT_OBJ"
    LCMD="$CCLINK_STATIC $SPEC_EXE_FILENAME$base$EXT_EXE $base$EXT_OBJ ${DRIVER} $cppos $LINK_STRING"
    if [ $ECHO = 1 ]; then echo "$CCMD"; fi
    if `echo $CCMD`
    then
      if [ $ECHO = 1 ]; then echo "$LCMD"; fi
      if `echo $LCMD`
      then
        # rm -f "$base.cpp"
        if [ $RUNIT = 1 ]
        then
          if [ $TIME = 1 ]
          then
            cmd="time $STATIC_ENV $base $args"
          else
            cmd="$STATIC_ENV $base $args"
          fi
          if [ $ECHO = 1 ]; then echo $cmd; fi
          eval $cmd
        fi
      fi
    fi
  fi
fi
exit $?

@head(1,'Package Manager Meta Info')
@head(2,'GODI')
This is the Godiva file originally used to
create the GODI data. At the moment this is
the authoritative meta data. However,
godiva may not handle all the options
we need -- so the generated makefile
is included as well.

@select(tangler('meta/godiva/flx.godiva','data'))
Package: apps-felix
@tangle('Version: '+flx_version)
Revision: 0
Depends:
Build-Depends: godi-ocaml (> 3.08) 
@tangle('Sources: http://felix.sf.net/flx_'+flx_version+'_src.tgz')
@tangle('Unpacks-To: flx_'+flx_version)
Bytecode-Target: all
Opt-Target: all
Homepage: http://felix.sf.net
Maintainer: John Skaller <skaller@users.sf.net>
Options: configure
Description: Felix Compiler
Felix Compiler
.

@select(tangler('meta/godiva/flx.godiva_camlsyntax','data'))
name = "felix";
@tangle('version = "'+flx_version+'";')
revision = 0;
category = `apps;
depends = [];
build_depends = [`godi,"ocaml", Some (`gt, "3.08")];
sources_site ="http://felix.sf.net/";
@tangle('sources_basename= "flx_'+flx_version+'_src";')
sources_extension = ".tgz";
@tangle('sources_unpacksto = "flx_'+flx_version+'";')
all_target= "all";
opt_target= "all";
homepage= "http://felix.sf.net";
maintainer = "John Skaller <skaller@users.sf.net>";
options= [`configure];
short_desc = "Felix Compiler";
long_desc = "Felix Compiler";
confopts = [
  { 
    name = "SUPPORT_DYNAMIC_LOADING";
    default = "1";
    description = "Whether to support dlopen loading";
    implementation = `configarg "--SUPPORT_DYNAMIC_LOADING"
  }
];
specfile = "meta/godiva/flx.godiva_camlsyntax";
patches = [];
filesdir = None;

@select(tangler('meta/godi/DESCR','data'))
Felix Compiler and tools.

@doc()
This makefile only here for reference (don't use it,
it should be generated).

@select(tangler('meta/godi/Makefile','data'))
# This file was automatically generated by GODIVA
.include "../../mk/bsd.prefs.mk"
.include "../../mk/godi.pkg.mk"

@tangle('VERSION=        '+flx_version)
PKGNAME=        apps-felix-${VERSION}
@tangle('PKGREVISION=    '+godi_revision) 
@tangle('DISTNAME=       flx_'+flx_version)
@tangle('DISTFILES=      flx_'+flx_version+'_src.tgz')
CATEGORIES=     apps
MASTER_SITES=   http://felix.sf.net/
MAINTAINER=     John Skaller <skaller@users.sf.net>
HOMEPAGE=       http://felix.sf.net
COMMENT=        Felix Compiler

# confopt defaults:


AUTOGENERATE_PLIST = yes
PKG  =          apps-felix
MAKE_FLAGS=     PREFIX=${PREFIX}  



PATH:=          ${LOCALBASE}/bin:"${PATH}"
HAS_CONFIGURE = yes
CONFIGURE_ARGS+= --prefix ${PREFIX}
CONFIGURE_ENV+= ${BUILD_OCAMLFIND_ENV}
USE_GMAKE = yes

MAKE_ENV+=  ${BUILD_OCAMLFIND_ENV} PKGBASE=${PKGBASE:Q}

pre-configure-copy:
.	if exists(files)
	    cd files && ${PAX} -rw -pp . ${WRKSRC}
.	endif

pre-configure: pre-configure-copy

pre-install-mkdirs:
.	for d in bin lib/ocaml/pkg-lib doc share man etc info sbin include
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/${d}
.	endfor
.	for n in 1 2 3 4 5 6 7 8 9
	    ${_PKG_SILENT}${_PKG_DEBUG}mkdir -p ${PREFIX}/man/man${n}
.	endfor

pre-install: pre-install-mkdirs

ALL_TARGET=     all
.if ${GODI_HAVE_OCAMLOPT} == "yes"
# ALL_TARGET+= all
.endif

post-install:
	mkdir -p ${PREFIX}/doc/${PKG}
.	for DOC in 
	    install -m 0644 ${WRKSRC}/${DOC} ${PREFIX}/doc/${PKG}
.	endfor

.include "../../mk/bsd.pkg.mk"

@head(1,'Finish up')
Just cleaning up script now.
@try:
   os.system('chmod u+x configure')
   os.system('chmod u+x bin/flx')
   os.system('chmod u+x bin/fishcc')
 except:pass

