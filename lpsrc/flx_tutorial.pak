@set_title('Felix Tutorial')

@from flxbuild.iscrutil import setup_test
@from flxbuild.flxutil import unix2native

@env = setup_test(get_input_frame(), 'tut/tutorial/tut-', zfill_pattern=[2,2,2])

@def kat(code):
  env.kat(get_tangler(),code)

@env.head(1,'Introduction')
@env.head(2,'Hello World')
This section deals with the basic concepts in Felix.
There is no better introduction to a programming
language than the infamous hello world program

@select(env.test('.flx'))
print "Hello World\n";
@doc()

@select(env.expect())
Hello World
@doc()

and the Felix version is simplicity itself.
@p()
The expected results are provided, and the build system
compares them with the actual output and logs an error
if there are any significant differences.
@p()
You'll notice that the argument to print is not
enclosed in brackets.  We'll learn more about
this shortly.

@env.head(2,'Running Programs')
To run the example, make sure you are in the
directory containing the Felix demo package,
then type:

@begin_displayed_code()
@weave('  bin/flx '+env.root+env.level_str()+'-0')
@end_displayed_code()

This produces many files, including:

@fistuff = [
  (env.root+env.level_str()+'-0.hpp','C++ header'),
  (env.root+env.level_str()+'-0.cpp','Main implementation'),
  (env.root+env.level_str()+'-0_ctors.cpp','Constructors'),
  (env.root+env.level_str()+'-0.rtti','Run time type information'),
  (env.root+env.level_str()+'-0.resh','Resource Requirements'),
  (env.root+env.level_str()+'-0.why','Input for Theorem Prover'),
  (env.root+env.level_str()+'-0_dynamic.o','Object File (unix)'),
  (env.root+env.level_str()+'-0.so','Shared Library (unix)'),
  ]

@begin_table("File","Purpose")
@for i,j in fistuff: table_row(i,j)
@end_table()
@p()
Felix is both a scripting language and statically type-checked
fully compiled to native code high performance application
development language.
@p()
It provides the simple usage model of scripting languages
like Python, Perl, PHP, and Ruby, with the early error
detection of C++, SML, Ocaml and Haskell. With Felix you
no longer need to worry about Makefiles or building code,
just run the source, the scripting harness takes care of
calculating dependencies, recompiling stale dependents,
and linking in libraries.
@p()
It is not only the fastest scripting language
available, it competes very well with compiled languages,
and is often faster than C.

@env.head(2,'Platform Independence')
Felix provides platform independence like
Java without using a bytecode interpreter or
interpreted virtual machine, by mapping abstracted
concepts onto the platform specific technologies
at the source code level. 
@p()
The Felix code generator itself produces platform
independent C++ code which should compile on any
platform with any modern C++ compiler. Thus, the primary
vehicle for platform independence is to use the ISO Standardised
C++ object model as an abstract target, and use the local
conforming C++ compiler as the implementation vehicle.
@p()
At the same time, platform dependent features can
easily be programmed without the need for facilities
like the JNI (Java native code interface), using
binding technology directly supported in Felix
to map C and C++ functions and data types directly
into Felix. Felix uses the C++ object model, and so
can bind to most C and C++ libraries without any
needed for glue logic.


@env.head(2,'Binding to C++')
Lightweight glue is required to map types and names
across the boundary, but is simple and suitable
for everyday use.

@select(env.test('.flx'))
@kat("C binding")
type metres = "double";
fun add: metres * metres -> metres = "$1+$2";
ctor metres: double = "$1";
ctor double: metres = "$1";

val x = metres 1.2;
val y = metres 1.3;
println (double (x + y));

@select(env.expect())
2.5
@doc()

The data type introduced here is a new primitive,
that is, a fully abstract type, with semantics
defined in terms of C, but typing managed by Felix.

@env.head(2,'Extensibility')
Felix has many advanced features which make a tutorial
somewhat difficult to write. For example whilst we describe
many types such as integers and strings as part of Felix,
in fact they're primarily defined in the library. Felix
is fairly unique in that the compiler does not support any
builtin types at all. It does have builtin type combinators
though!
@p()
Similarly, when describing the syntax, an advanced user will
be aware that Felix actually has no proper syntax: the syntax
is defined in the standard library.

@env.head(1,'Primitive types')
Here is a more comprehensive set of examples
of Felix standard types and lexicology.

@env.head(2,'Bool')
Felix provides the usual boolean type bool with two values
named false and true, with false less than true. Note that
A implies B can be written A <= B which may seem counterintuitive,
but is quite logical.
@p()
The name bool is actually an alias for the canonical enumeration 2,
meaning a type with two values, and if you look closely in
the library you will find it is actually defined with
a typedef.
@p()
As with all canonical enumerations, the notation
@begin_displayed_code()
  case <index> of <count>
@end_displayed_code()
can be used to specify the n'th value of that type,
with the rather unfortunate 0 origin convention.
The names 'true' and 'false' are replaced with their canonical
values by the parser. Canonical enumerations, also called
unit sums, are explained in more detail later, however we mention
this now so you can understand that bool is not an abstract type,
but a special case of a more general class of types. Since
canonical enumerations are represented by C++ type int,
Felix bool is a C++ int, and not a C++ bool.
@p()
Bools can also be used in a conditional expression,
note that an endif keyword and both branches are always
required.
@select(env.test('.flx'))
@kat('bool')
{
  val b1 : bool = false;
  val b2 : bool = true;
  val b4 : 2 = case 0 of 2; // false
  val b3 : 2 = case 1 of 2; // true
};
println (not false);      println (lnot false);        // not
println (true and false); println (land (true,false)); // and
println (true or false);  println (lor  (true,false)); // or
                          println (xor (true,true));
println (true <= true);   println (implies (true,true));
println (if true then "TRUE" else "FALSE" endif);
@select(env.expect())
true
true
false
false
true
true
false
true
true
TRUE
@doc()

@env.head(2,'Arithmetic Types')
@env.head(3,'Integers')
Integers are not builtin types, but are in fact
defined in the standard library by binding to 
their C equivalents.
@p()
In the following table, the Felix names of the basic integer
types are given, along with the corresponding C names. Felix allows
either the Felix name or any valid C name to be used for these types.
For example 'unsigned' is an an acceptable type name in Felix
because it is in C.
@p()
The table also lists the lower case versions of the type suffices allowed
for literals of that type. Either or both the unsigned designator 'u'
or the other part may be upper case instead (however lL is not permitted
for long long, both letters must be either lower or upper case).
@begin_table("Felix name","C name","Suffix")
@table_row("tiny","signed char","t")
@table_row("utiny","unsigned char","ut, tu")
@table_row("short","signed short int","s")
@table_row("ushort","unsigned short int","us, su")
@table_row("int","signed int","<none>")
@table_row("uint","unsigned int","u")
@table_row("long","signed long int","l")
@table_row("ulong","unsigned long int","lu, ul")
@table_row("vlong","signed long long","ll, v")
@table_row("uvlong","unsigned long long","ull, llu, uv, vu")
@end_table()
@p()
The following aliases are also provided, in this
case the C name may not be used: 
@p()
@begin_table("Felix name","C name")
@table_row("size","size_t")
@table_row("ptrdiff","ptrdiff_t")
@table_row("intptr","intptr_t")
@table_row("uintptr","uintptr_t")
@table_row("intmax","intmax_t")
@table_row("uintmax","uintmax_t")
@end_table()
@p()

The following aliases for exact integers are also provided, in this
case the C name may not be used:
@p()
@begin_table("Felix name","C name","Suffix")
@table_row("int8","int8_t","i8")
@table_row("uint8","uint8_t","u8")
@table_row("int16","int16_t","i16")
@table_row("uint16","uint16_t","u16")
@table_row("int32","int32_t","i32")
@table_row("uint32","uint32_t","u32")
@table_row("int64","int64_t","i64")
@table_row("uint64","uint64_t","u64")
@end_table()
@p()
Felix guarantees all the addressing and exact integer aliases exist,
even if the C89, C++ or C99 counterparts do not. When the C/C++ counterparts
do exist, Felix binds to the same integer type, otherwise it binds to
the largest appropriate integer type (for example, if both long
and long long exist and are the same size as a pointer, and
intptr_t is not defined by C or C++, then Felix choses long long
as the alias).
@p()
Arithmetic types support the same operations as ISO C99,
except that Felix does not support bitwise operations on
signed integers (shifts are supported, they're multiplications
by powers of two).
@p()
Overflow of operations on signed types is undefined
behaviour. Operations on unsigned types cannot overflow
because they are defined as the modular residual of the
underlying mathematical operation on integers.
@p()
Thus, operations on exact unsigned integral types are fully
deterministic, and operations on signed integral types
are also deterministic when they do not overflow.
@p()
An integer literal consists of a prefix, numeric form and suffix.
The suffix is noted in the tables above.
Either the size indicator or signedness indicator 'u' or 'i'
can be wholly capitalised (but note that lL is not allowed).
@p()
The prefix denotes the radix as in the table below:
@begin_table("Prefix","Radix", "name", "Allowed digits")
@table_row("0b,0B","2", "binary","01")
@table_row("0o,0O","8", "octal","01234567")
@table_row("0d,0D,<none>","10", "decimal","0123456789")
@table_row("0x,0X","16", "hexadecimal","0123456789ABCDEFabcdef")
@end_table()
@p()
The numeric form consists of digits from the table above,
with optional underscores inserted for layout purposes.
Two underscores in a row are not permitted, one is allowed
between digits, or a digit and the prefix or suffix.
@select(env.test('.flx'))
@kat('lexemes:integer')
@kat('literals:integer')

// radix
{
  val i1 = 999;      // decimal
  val i2 = 0b1111;   // binary
  val i3 = 0o7777;   // octal
  val i4 = 0d9999;   // decimal
  val i5 = 0xF1_F2;  // hex
};

// underscores
{
  val i1 = 123_456;
  val i2 = 0x_FF_FFu;
};

// normal signed integers
{
  val i1 : tiny = 1t;
  val i2 : short = 1s;
  val i3 : int = 1; // default
  val i4 : int = 1i;
  val i5 : long = 1l;
  val i6 : vlong = 1ll;
};

// normal unsigned integers
{
  val i1 : utiny = 1tu;
  val i2 : utiny = 1ut; // u may be first or last
  val i3 : ushort = 1su;
  val i4 : uint = 1u; // default
  val i5 : uint = 1iu;
  val i6 : ulong = 1lu;
  val i7 : uvlong = 1vu;
  val i8 : uvlong = 1llu; // alternate
};

// exact signed integers
{
  val i1 : int8 = 1i8;
  val i2 : int16 = 1i16;
  val i3 : int32 = 1i32;
  val i4 : int64 = 1i64;
};

// exact unsigned integers
{
  val i1 : uint8 = 1u8; // 1iu8 not allowed
  val i2 : uint16 = 1u16;
  val i3 : uint32 = 1u32;
  val i4 : uint64 = 1u64;
};

@select(env.expect())
@doc()

@env.head(3,"Mixed Mode Integers")
Felix by default only supports arithmetic on integers
of exactly the same type. To enable mixed mode arithmetic
you can open the MixedInt module.
@select(env.test('.flx'))
@kat("type constraints")
open MixedInt;

var x = 1;
var y = 2L;

print$ x + y; endl;
@doc()

@select(env.expect())
3
@doc()


@env.head(3,"Floats")
Felix provides 3 floating point types.
@begin_table("Felix name","C++ name")
@table_row("float","float")
@table_row("double","double")
@table_row("ldouble","long double")
@end_table()
@select(env.test('.flx'))
// floats obey C99 rules, except we allow underscores
{
  val x1 : float = 2.2f;
  val x2 : double = -2.2;
  val x3 : ldouble = 2.2l;
  val x4 : double = 22_345.78;
  // val x5 : float = 0xFFFF.FFp4f; // doesn't work on g++ 2.95.3
  val x6 : double = 2.2e4;
  val x7 : float = 2.2e4f;
  println (abs x2);
};
@select(env.expect())
2.2
@doc()

@env.head(3,"Complex")
Felix provides 3 complex types corresponding to the three floating types.
@begin_table("Felix name","C++ name")
@table_row("fcomplex","std::complex<float>")
@table_row("dcomplex","std::complex<double>")
@table_row("lcomplex","std::complex<long double>")
@end_table()
@select(env.test('.flx'))
proc pr (z:dcomplex) { println (fmt[dcomplex,double](z,fixed(0,3))); }

{
  val x1 : fcomplex = fcomplex(2.2f, 1.0f);
  val x2 : dcomplex = dcomplex 2.2;
  val x3 : lcomplex = lcomplex (2.2l, 21.0l);
  println (abs x2);
  var z = 0.5 + 0.2 i;
  println z;
  pr$ sin z;
  pr$ cos z;
  pr$ tan z;
  pr$ sinh z;
  pr$ cosh z;
  pr$ tanh z;
  pr$ log z;
};
@select(env.expect())
2.2
0.5+0.2i
0.489+0.177i
0.895+-0.097i
0.519+0.253i
0.511+0.224i
1.105+0.104i
0.477+0.158i
-0.619+0.381i
@doc()

@env.head(3,'Floating matches')
Felix provides special matching for
floating point. Here are some examples:
[This may change, the need for overlapping
ranges is too ugly ..]

@select(env.test('.flx'))
@kat('match:float')
@kat('nan')

match (1.0) with
  | NaN => { print "Not a Number"; }
  | -inf .. -0.999 => { print "lt -1"; }
  | -1.001 .. 1.001 => { print "Unit circle"; }
  | 0.999 .. inf => { print "Greater than 1"; }
endmatch;
endl;

match (1.0) with
  | 0.999 .. 1.001 => { print "one"; }
endmatch;
endl;

match (1.0/3.0) with
 | 0.3333 .. 0.3334 => { print "One third"; }
endmatch;
endl;
@doc()

@select(env.expect())
Unit circle
one
One third
@doc()

Things to note are: if there is NaN test,
it must be the first test. If there is
a test -inf .. inf, it tests for a non-NaN,
and must be the last test. A NaN will fail
all tests other than a test for NaN.
@p()
A range test is neither inclusive nor exclusive!
That's why there is no test for a particular float,
and why the ranges above overlap.
Welcome to constructive mathematics!
@p()
Note that _floating_ point provides exact
comparisons; however, the patterns above
apply to constructive reals. The last
example explains this best: you can't do
non-constructive matches. [Use IEEE type
for exact FP?]


@env.head(2,'Characters')
Felix provides two character types: char and uchar.
Type char provides 256 code points, whereas uchar
provides at least 2147483648 (31 bits worth).
@p()
There are no character literals. You can use the ord
function to obtain the numeric value of a char or uchar
as an int or uint32 respectively. 
@p()
Constructors for char and uchar convert any
integer to the corresponding character. The result is 
undefined for negative values of signed types.
@p()
The char and uchar constructors can be applied to a string
of at least length 1 to obtain a literal, for example:

@select(env.test('.flx'))
println (char "Hello");
@select(env.expect())
H
@doc()

@env.head(2,'Strings')
Felix provides two kinds of strings: 8-bit and 32-bit,
denoted by string and ustring respectively.
@p()
Both kinds of string are intended to provide a universal
representation of human readable text using the
ISO-10646/Unicode character set.
@p()
Both kinds of string encode 32-bit values representing
ISO-10646 code points. Strings use UTF-8, whilst ustrings
use UCS-4.
@p()
Both kinds of string literals are replaced where they
occur with named constants with internal linkage
of types basic_string<char>, and
basic_string<uint32_t>.
@p()
String literals are output in the C files as C string
literals with all UTF-8 encoding expressed with hex
escapes, surrounded by a constructor for basic_string<char>.
@p()
Ustrings are surrounded by a Felix function which constructs
a basic_string<uint32_t> from an 8 bit C string literal
by decoding UTF-8 sequences.
@p()
Both kinds of string admit \uXXXX and \UXXXXXXXX escapes,
as well as the usual C escapes \\, \', \", \r, \n, \t, \b, \v, \f
for slosh (backslash), quote, double quote, return, newline, tab,
bell, vertical tab, and form feed, respectively.
@p()
Octal and hex escapes are NOT allowed: strings are
for internationalisable human text, and do not represent
arbitrary raw memory extents.
@p()
Although not part of the lexicology, note here two special
forms for strings: a string may be applied to a string, or,
a string may be applied to an integer. The first case is
remodelled as a concatenation, and the second as the concatenation
of the string and the ISO-10646 code point the integer represents.
Note that if the string is 8 bit, UTF-8 encoding will be applied.

@select(env.test('.flx'))
var s = "Hello" 32; // add a space after "Hello"
s = s s; // says "Hello Hello "
print s; endl;
@doc()

@select(env.expect())
Hello Hello
@doc()

@env.head(2,'Identifiers')
Felix identifiers consists of a string of
characters. The first character must be a letter
or underscore, subsequent characters may be one of a
letter, underscore, apostrophe or digit.
@p()
Certain identifiers are reserved as keywords.
Identifiers beginning with an underscore are
reserved to Felix. Identifiers containing
more than one underscore in a row are
reserved to Felix. Reserved identifiers may
be used by programmers, but not defined.
@p()
The letters referred to consist of the usual
A-Z and a-z, but also include any Unicode/ISO10646
code point recommended as a letter for the purpose
of use in identifiers of programming languages
by ISO/IEC PDTR 10176, as adopted by ISO C++.
A full table can be found in the reference manual,
Felix Standard, and source code.
@p()
These code points must be represented using UTF-8,
or by embedded Universal Character Names (ucns).
These consist of a \uXXXX or \UXXXXXXXX where the
X's are hex digits. Felix normalises all such
encodings so identifiers match properly.

@select(env.test('.flx'))
val x_y_7' = 1;
val Y_can't_U_do_this_in_C'' : double = 2.0;
val x\u05d0= 1; // x,Hebrew  aleph
val zz = x\U000005D0; // x,Hebrew aleph
@doc()
@select(env.expect())
@doc()

@env.head(1,'Functions')

@env.head(2,'Overloading')
Felix supports overloading. To demonstrate this,
we'll make a small modification to the hello
world program. You can compile and run the
program as before, just change the example number.

@select(env.test('.flx'))
print "Hello World ";
print 42;
print "\n";
@doc()

@select(env.expect())
Hello World 42
@doc()

Here you can see that there are two procedures,
one to print strings, and one to print ints,
but they're both called 'print'.
@p()
Felix allows procedures and functions to be
overloaded, as does C++. However, unlike C++,
Felix has no automatic conversions, and
overload matching must be exact.

@env.head(2,'Expressions')
Felix provides many of the operators found
in C. Here is are some examples with equivalent
function calls. The complete expression grammar is given here:
@cite_url('../../gramdoc/dssl_expressions.html')
Note that Felix does not have builtin expression syntax:
the grammar, including expressions, is defined in the library. 

@h=env.test('.flx') 
@e = env.expect()
@select(h)
// arith
println (- 1);        println (neg 1);          // negation
println (1 + 1);      println (add (1,2));      // addition
println (1 - 1);      println (sub (1,2));      // subtraction
println (1 * 1);      println (mul (1,2));      // multiplication
println (1 / 1);      println (div (1,2));      // division
println (1 % 1);      println (mod (1,2));      // modulus
println (1.2 ** 1.2); println (pow  (1.2,1.2)); // power
println (1u << 1u);   println (shl (1u,1u));          // mul pow of 2
println (1u >> 1u);   println (shr (1u,1u));          // div pow of 2
@select(e)
-1
-1
2
3
0
-1
1
2
1
0
0
1
1.24456
1.24456
2
2
0
0
@select(h)
// comparison
println (1 == 2); println (eq (1,2));  // equality
println (1 != 2); println (ne (1,2));  // inequality
println (1 < 2); println (lt (1,2));  // less
println (1 > 2); println (gt (1,2));  // greater
println (1 <= 2); println (le (1,2));  // less or equal
println (1 >= 2); println (ge (1,2));  // greater or equal
@select(e)
false
false
true
true
true
true
false
false
true
true
false
false
@doc()
@select(h)
// bitwise
println (~0x01tu); println (bnot 0x01tu);  // bitwise complement
println (0x23u \& 0x0fu); println (band (0x23u,0x0fu)); // bitwise and
println (0x23u \| 0x0fu); println (bor (0x23u,0x0fu));  // bitwise or
println (0x23u \^ 0x0fu); println (bxor (0x23u,0x0fu));  // bitwise xor
@select(e)
254
254
3
3
47
47
44
44
@env.head(2,'Statements')
@env.head(3,'Value declaration')
Felix allows values to be declared using the 'val'
keyword.

@select(env.test('.flx'))
val i = 40;
val j = 2;
val k = i + j;
print k; print "\n";
@doc()

@select(env.expect())
42
@doc()

There are three values declared here, 'i','j', and 'k'.
The first two have the type 'int', because '40' and '2'
have the type int, whilst 'k' has the type 'int'
because the addition function which takes as
an argument a pair of 'int', returns an 'int'.
@p()
Notice you did not have to declare the type of
the values. This is called 'type inference':
the compiler works out the type from the initial
value for you. You can declare the type of a variable
if you want: the following program is equivalent
to the one above:

@select(env.test('.flx'))
val i : int = 40;
val j : int = 2;
val k : int = i + j;
print k; print "\n";
@doc()

@select(env.expect())
42
@doc()

but it is never necessary for values: an initialiser
must always be given. If you do declare the type,
Felix will still deduce the type from the initialiser,
and issue an error message if the types don't agree.
@p()
Values are constants: they cannot be modified,
and, as we will see later, they cannot be addressed.
This means the compiler is free to load the value into a register
or perform other optimisations (including elide the storage
for the value entirely).
@p()
There is a shortcut form for declaring values
using the := operator:

@select(env.test('.flx'))
a := 1;
b:int := 2;

c:int,(d,e) := 3,(4,5);

print a; print " ";
print b; print " ";
print c; print " ";
print d; print " ";
print e; print " ";
endl;
@doc()

@select(env.expect())
1 2 3 4 5
@doc()

@env.head(3,'Variable declaration')
Felix also support mutable variables, which are
declared with the 'var' keyword.

@select(env.test('.flx'))
@kat("C syntax")
var i = 1;
var j : int;
while {i < 10}
{
  j = i + i;
  print j; print "\n";
  ++i;
};
@doc()

@select(env.expect())
2
4
6
8
10
12
14
16
18
@doc()

Like value declarations, the type of a variable
does not need to be declared if it is initialised.
However, as you can see uninitialised variables
are also permitted, and in this case the type
must be given.
@p()
You will notice the assignment in the line:
@begin_displayed_code()
  j = i + i;
@end_displayed_code()
Naturally, variables must be initialised
or assigned to before they are used, as in C.
@p()
You will also have noticed the 'while' loop,
one of the control structures Felix provides:
it appears to work the same way as a 'while' loop in C,
except that a trailing ; is strangely required,
and the condition is given in curly brackets.
We'll find out exactly why later, but here is a hint:
there is no while statement in Felix!
@p()
Finally, because C and C++ programmers (including
the author) often revert to their familiar syntax,
Felix allows C style variable declarations too:

@select(env.test('.flx'))
int i = 1;
int j = 0;

while (i < 10)
{
  j = i + i;
  print j; print "\n";
  ++i;
};
@doc()

Note a C style while loop can also be used, however
the trailing semi-colon is required.

@select(env.expect())
2
4
6
8
10
12
14
16
18
@doc()


@env.head(3,'Assignments')
It is sometimes useful to simultaneously assign variables
from the components of a tuple, which can done as shown below.
@p()
We may also wish to initialise multiple values, also shown below.
@p()
More generally, you may wish to assign one component to an
existing variable, create a new value binding for the second component,
and a new variable for the third. This can be done with the 'def'
keyword as illustrated.
@p()
The patterns of vals and vars on the left hand side of of such
a statement is called an lvalue pattern. (Also sometime known
as a tie).

@select(env.test('.flx'))

// multiple initialisation
r,(s,t) := 1,(2,3);

print r; print " ";
print s; print " ";
print t; print " ";
endl;

var a:int;
var b:int;
var c:int;

// multiple assignment
a,(b,c) = 1,(2,3);

print a; print " ";
print b; print " ";
print c; print " ";
endl;

def a = 1;
def val x = 2;
def var y = 3;

// mixed multiple assignment and initialisation
def (a, val d), var e = (9,8),7;

print a; print " ";
print d; print " ";
print e; print " ";
endl;
@doc()

@select(env.expect())
1 2 3
1 2 3
9 8 7
@doc()

@env.head(3,'Other Mutators')
Felix provides a range of mutators,
these being assignment operators and counting operators.
Below is a list of operators and equivalent procedure names.

@select(env.test('.flx'))
open Uint;

var i:int;
var j:int;

var u: uint;
var v: uint;

// operator    procedure
i = 1;         // assignment, intrinsic
j = 2;         // assignment, intrinsic
i <-> j;       // swap, intrinsic
i,j = j,i;     // another way to swap

// integral
i +=  1;       pluseq       (i,1);
i -=  1;       minuseq      (i,1);
i *=  1;       muleq        (i,1);
i /=  1;       diveq        (i,1);
i %=  1;       modeq        (i,1);

// bitwise: unsigned only
u ^=  1u;       bxoreq      (u,1u);
u |=  1u;       boreq       (u,1u);
u &=  1u;       bandeq      (u,1u);


// counting
++i;           pre_incr (i);
i++;           post_incr (i);
--i;           pre_decr (i);
i--;           post_decr (i);
@doc()

@select(env.expect())
@doc()

@env.head(2,'Functions')
@set_anchor('Functions')

Felix allows you to define functions,
although the syntax is different from C.
Here is an example:

@select(env.test('.flx'))
fun mid(a:int, b:int):int =
{
  val c = (a + b) / 2;
  return c;
}
print (mid(2,4)); print "\n";
@doc()

@select(env.expect())
3
@doc()

It is clear that mid returns an int,
and you might think that 'mid' has two arguments.
This is not so. All functions in Felix have
exactly one argument. Well, almost all of them :-)
I'll explain shortly.
@p()
Functions in Felix may not have any side effects,
except for diagnostic outputs.  Note however that
functions may modify their own private data,
that is, may contain and mutate local variables.
@p()
Whilst in the above example the return type of the
function is clearly given, it is not necessary,
as illustrated by the next example:

@select(env.test('.flx'))
fun mid(a:int, b:int) =
{
  val c = (a + b) / 2;
  return c;
}
print (mid(2,4)); print "\n";
@doc()

@select(env.expect())
3
@doc()

which is equivalent to the one above.
Note, however, that the types of the arguments
must be given.

@env.head(3,'Functions with shorthand syntax')
Functions can also be given with a shorthand syntax
when the result can be written easily as a single
expression:

@select(env.test('.flx'))
fun mid(a:int, b:int) => (a + b) / 2;
print (mid(2,4)); print "\n";

@select(env.expect())
3
@doc()
Note in this case the trailing semi-colon is necessary
for syntactic disambiguation.


@env.head(3,'Primitive Functions')
A function can be defined in C++ instead of Felix:

@select(env.test('.flx'))
fun mid: int * int -> int = "($1+$2)/2";
print (mid(2,4)); print "\n";
@doc()

@select(env.expect())
3
@doc()
The special notation $1 and $2 refers to the first
and second arguments, respectively. The function type
must be given with the arguments separated by asterisks
and the result following an arrow. Note that this is the
standard mathematical notation for a function whose
argument is cartesian product.
@p()
The quoted code on the right is an arbitrary C++ expression
which will be emitted by the code generator as written,
with the $ terms replaced by the C++ encoding of the corresponding
arguments. Felix generally takes care of precedences automatically
but there is a full system for telling Felix precedences, so 
the emitted code doesn't contain so many brackets as to become
unreadable.
@p()
Note that Felix does not parse or type the C++ code: the programmer
is responsible for getting it right.
@p()
Felix has a sophisticated system for binding to C++ code:
this function binding technology is one small but important part 
of it.

@env.head(3,'C Functions')
Felix normally generates C++ applicative objects for
non-inlined Felix functions, although it often simplifies
them to C functions, or even elides them completely if
all calls are inlined.
@p()
If you need to generate a C function with a specific C type
for use as a callback, you can use the cfun keyword in place
of the fun keyword:

@select(env.test('.flx'))
cfun mid(a:int, b:int) =
{
  val c = (a + b) / 2;
  return c;
}
print (mid(2,4)); print "\n";
@doc()

@select(env.expect())
3
@doc()
Note that the function is still written in Felix code,
however there are certain constraints on such functions,
such as their inability to use the garbage collector
or perform any service calls, including do any I/O on
synchronous channels.
@p()
Thus, the code you write in a cfun must clearly reduce
to ordinary C code. This is your responsibility as the
programmer: the compiler does not check if the function
is suitable for reduction to C, it just generates the
C form of a function unconditionally. This will result
in a C++ compile time error if you exceed the capabilities
of C.
@p()
Note: a cfun has an ordinary Felix function type,
not a C function pointer type.

@select(env.test('.flx'))
fun mid: int * int -> int = "($1+$2)/2";
print (mid(2,4)); print "\n";
@doc()

@select(env.expect())
3
@doc()
@env.head(3,'Functions with pattern syntax')
There is yet another syntax for functions based
on pattern matching:
@select(env.test('.flx'))
enum color {red, green, blue};

fun cname: color -> string =
  | red => "red"
  | green => "green"
  | blue => "blue"
;

println (cname red);
@doc()

@select(env.expect())
red
@doc()
This will be explained in more detail when we deal with
pattern matching and variant types later.

@env.head(3,'Constructors')
When introducing a new primitive data type via a binding to a C++
type, it is often useful to use the type name as a function
which constructs an instance of this type. We saw this in
the preface already:
@select(env.test('.flx'))
@kat("C binding")
type metres = "double";
fun add: metres * metres -> metres = "$1+$2";
ctor metres: double = "$1";
ctor double: metres = "$1";

val x = metres 1.2;
val y = metres 1.3;
println (double (x + y));

@select(env.expect())
2.5
@doc()
The keyword ctor specifies a constructor for the given
type, which is called using that type as a function name.
A constructor can be given for a type alias given by 
a typedef too. Note that constructors specify only
the function arguments, since the return type is implicit
in the type name.

@env.head(2,'Procedures')
Felix allows you to define procedures.
They're like functions, but they can't return values.
On the other hand, procedures may have side effects,
and they may read input from the driver's message
dispatch queue (which you will learn about much later).
@p()
Here is an example of a procedure definition
and use:

@select(env.test('.flx'))
proc print_newline (a:int)
{
  print a;
  print "\n";
}
print_newline 1;
@doc()

@select(env.expect())
1
@doc()

There is a special shortcut for calling procedures
with unit argument: if the procedure is called
by its name, the () can be elided:

@select(env.test('.flx'))
print 1; endl();
print 2; endl;
@doc()

@select(env.expect())
1
2
@doc()

More precisely, a statement consisting
of an (almost) atomic expression
is taken to be a call to a procedure with
unit argument. Note there is no confusion
with the use of a procedure name as an expression,
that always represents the closure of the procedure
at the point of writing.

@env.head(2,'Fibres')
Felix procedures are can also be used as threads.
To do this, use the spawn_fthread library procedure
to create a new thread of control which is scheduled
for execution.
@p()
When a fibre is scheduled it runs until it terminates
or explicitly yields control. Yielding is done by 
reading or writing on a synchronous channel. Bidirectional
are created with the mk_schannel library function.

@select(env.test('.flx'))
@kat('fibres')
var y = ();
proc f() { print "Hello"; endl; }
f y;

var x = mk_schannel[int]();

proc reader() {
  print "R1"; endl;
  var u = read x;
  print "R2-"; print u; endl;
}

proc writer() {
  print "W1"; endl;
  write (x,42);
  print "W2"; endl;
}

spawn_fthread the reader;
spawn_fthread the writer;

print "Done"; endl;
@select(env.expect())
Hello
Done
W1
R1
R2-42
W2
@doc()

@env.head(2,'Generators')
In Felix, functions are not allowed to have side-effects.
This does not mean they are pure, because they can
depend on variables. However they cannot modify any
variables outside their own bodies.
@p()
It is still possible to write functions which have 
side-effects, they just have to be explicitly noted
as generators with the gen keyword. For example:

@select(env.test('.flx'))
var cheat : int = 0;
gen f():int = {
  ++cheat;
  //print "Generator "; print cheat; endl;
  return cheat;
}

print "F 1="; print$ f(); endl; // 1

@select(env.expect())
F 1=1
@doc()
Note that generators must be used even if the side-effect
is environmental, for example reading a file may move
the current file pointer. Generators must always be used
when returning the address of a fresh object.
@p()
The semantics of functions allow Felix to duplicate
or delay calling them: a generator disables this feature
and forces the function to be called exactly once and
the result assigned to a variable which replaces the
application inside the enclosing expression.
@p()
In other words, function calls may be lazy, whereas
generators are always evaluated eagerly.

@env.head(2,'Iterators')
A generator may also yield a value and be resumed later.
This is done in two steps. First the generator uses the
yield statements instead of the return statements.
Secondly, the generator itself must be stored in a variable.

@select(env.test('.flx'))
var cheat = 0;
gen f():int = {
  again:>
    ++cheat;
    yield cheat;
    goto again;
}

var g = the f;
print "F 1="; print$ g(); endl; // 1
print "F 2="; print$ g(); endl; // 2

@select(env.expect())
F 1=1
F 2=2
@doc()
Note that when calling a generator which has yielded
the parameters are re-assigned on every call, however
control continues from the last yield point. Calling
a generator which has returned is not permitted.
@doc()
A generator using in this way is sometimes called
an iterator.
@p()
Generators are a functional form of a procedure.
Note that generators cannot read or write channels,
you have to use an actual procedure for that.

@env.head(2,'Threads')
Felix also supports first class pre-emptive threads
called p-threads. In contrast to fibres or f-threads
which effect interleaving of logical threads at explicit
exchange points, p-threads may lose control at the whim
of the operating system, and may be run in parallel if
multiple processors are available. 
@p()
Felix provides Posix mutex and condition variables for
all operating systems (including Windows). However
the primary synchronisation vehicle is the p-channel,
monitor, or rendevouz. This works with the same syntax as a 
synchronous channel.

@select(env.test('.flx'))
@kat('pthreads')
include "pthread";
open Pthread;

var x = mk_pchannel[int]();

proc reader() {
  var u = read x;
  print "R2-"; print u; endl;
}

proc writer() {
  write (x,42);
}

spawn_pthread the reader;
spawn_pthread the writer;

@select(env.expect())
R2-42
@doc()
Note that pchannels do not provide any buffering.
The data exchange is fully hand-shaken, and neither
thread may proceed until it is fully negotiated.

@env.head(1,'Programs')
@env.head(2,'Modules')
Most modern languages support packaging of related
specifications into some kind of module, and Felix
is no exception. Much of the standard library is
exhibited as modules. Documentation of the standard
modules is available here:

@cite_url("../../moduledoc/index.html")
@p()
Basic module use is quite simple:

@select(env.test('.flx'))
@kat('modules')
val top = 1;
module A {
  val a = top + 1;
  module B {
    val b = a + 1;
  }
}

print top; endl;
print root::top; endl;
print A::a; endl;
print A::B::b; endl;
@doc()

@select(env.expect())
1
1
2
3
@doc()

This example illustrates the simple use of modules,
including module nesting, and use of qualified names
to access module components.
@p()
You can put anything except export declarations in
modules that you can put at the top level, and for a
very simple reason: the top level is, in fact,
a module itself.
@p()
When a qualified name is used, the qualifier specifies
the module in which the next name must be found.
Qualification inhibits upscope overloading.
@p()
Note the name 'root' is used to name the top-level
module, in lieu of the actual module name, which is
derived from the basename of the filename.
@p()
Finally, it is vital to understand that Felix
scopes act like sets of names. Names are always defined
in parallel, and visible to all definitions in the scope,
so that all definitions are mutually recursive.
For this reason, forward declarations are never needed.
The following example is quite legal:

@begin_displayed_code()
  x = 1;
  y = x;
  var y:int;
  var x:int;
@end_displayed_code()

This is much like the 'rewriting rule' for C++ class member
functions. Note, however, that executable code
is still sequential! Thus, the order of value and variable
definition does matter: initialisations are executed
in order of writing.

@env.head(2,'Namespaces')
Modules are closed: everything in a module
has to be defined in one place. There is an open form of modules
called namespaces, illustrated below. Namespace can be built
up incrementally thru the program.
@p()
The concatenated contents of a namespace is equivalent
to a module, however code in a namespace is executed
in order of writing.
@p()
Namespace can be polymorphic and have constraints just
like modules. The text specifying the type variables
and any constraints must be repeated verbatim for
each use of the namespace.

@select(env.test('.flx'))
@kat('namespaces')
namespace A { var x = 1; }
namespace B { var x = 1; }
namespace A { var y = x+1; }
namespace B { var y = x+1; }

namespace A { print y; endl; }
namespace B { print y; endl; }

var A::z = y;
var B::z = y;

namespace A { print A::y; endl; }
namespace B { print B::y; endl; }

@select(env.expect())
2
2
2
2
@doc()

A namespace qualifier may be used before the identifier
in most definitions.

@select(env.test('.flx'))
@kat('namespaces')

print "b4 fred"; endl;

namespace fred {
  print "fred1 start"; endl;
  var x = 1;
  proc f() { print "f"; endl; }
  print "fred1 end"; endl;
}

print "between freds"; endl;

namespace fred {
  print "fred2 start"; endl;
  var y = 1;
  proc g() { print "g"; endl; }
  print "fred2 end"; endl;
};

proc fred::h() { print "h"; endl; }
print "after freds"; endl;

open fred;

print x; print " "; print y; endl;

f(); g(); h();

@select(env.expect())
b4 fred
fred1 start
fred1 end
between freds
fred2 start
fred2 end
after freds
1 1
f
g
h
@doc()



@env.head(2,"C formatting")
This is how you do printf-style string formatting.

@select(env.test('.flx'))
@kat("formatting:printf style")
print$ f"% 1.2d 0x%x %% %g %ld\n" (22,99u,9.7,88l);
@doc()

@select(env.expect())
 22 0x63 % 9.7 88
@doc()

You should note that a C format string is a first-class
statically typed function literal! Formatting errors are always
caught by the compiler. However, the format strings cannot
be dynamically constructed.
@p()
Felix also provides dynamic string based formatting,
see
@cite_url("../../moduledoc/String.html")

@doc()

@env.head(2,"Perl Formatting")
Felix provides Perl/Tcl style string interpolation,
where you can write an expression inside a string
enclosed in $() or $'' or $"". The expression is
converted to a string an replaces the $ expression.
@p()
Interpolation is statically type checked and cannot
fail at run time. Interpolation literals are actually
first class functions applied to unit and returning
a string.
@p()

@select(env.test('.flx'))
@kat("formatting:interpolation")

var x = "Hello";
var y = "World";
var u = 41;

var z = q"$x $(y) $(1+u) $'2+u'\n";

print z;
@doc()

@select(env.expect())
Hello World 42 43
@doc()
The 'q' character introduces an interpolated string;
any of the usual quoting styles is allowed.
@p()
Inside the string, the '$' character introduces
an expression which is evaluated, converted to a string
using the 'str' function, and replaced by that string.
@p()
The expression may begin with a '(', in which case
it proceeds up to the balancing ')'. You should note
the scan for brackets ignores other characters,
in particular quote marks, so this form does not
allow you to embed another string containing an
unbalanced bracket.
@p()
The expression may begin with a double quote,
single quote, or backtick, in which case it
consists of the text up to the next occurence
of the same kind of quote mark.
@p()
Finally, you can just write a Felix identifier,
starting with a letter or underscore, and
continuing with any letter, underscore, digit,
or single quote mark.

@head(3,"How it works")
The conversion uses a visible str function to do the conversions,
usually the str method of the Str typeclass, so if you have
a data type which you wish to format this way, you need to
provide an instance of Str with method str to convert it
to a string.


@env.head(1,'Structured types')
@env.head(2,'Tuples')
As you might guess from the title, Felix has
tuples. A tuple is a value consisting of an ordered sequence of
two or more values, not necessarily of the same type.
Here are some examples of tuples:
@begin_displayed_code()
  1,2
  "Hello", "World"
  (1, 2.7, "Hello")
  ()
@end_displayed_code()
The comma chain operator constructs tuples.
While brackets are not always necessary, the comma
operator has a low precedence so tuples usually
appear in brackets. Notice there is a special
unique empty tuple '()'. There are no tuples
with one component: for all values 'a', '(a)' is
equivalent.
@p()
Now perhaps you have guessed what I meant earlier
when I said the function mid only had a single
argument. If not, you get another chance,
studying this example, which is equivalent
to the Functions example.
@ref_anchor('Functions')

@select(env.test('.flx'))
fun mid(a:int, b:int):int =
{
  val c = (a + b) / 2;
  return c;
}
val x = (2,4);
print (mid x); print "\n";
@doc()

@select(env.expect())
3
@doc()

Here you can see that mid takes a single
argument which is a tuple of two ints.
@p()
A tuple is a product type: you may be
familiar with the Cartesian product of sets.
The notation for tuple types is the same,
except of course we use '*' instead of
a multiply sign: here is the declaration
of x with a type annotation:
@begin_displayed_code()
  val x : int * int = (2,4);
@end_displayed_code()
You should note that tuple construction
is not associative. Here are three
tuple value declarations with type annotations:
@begin_displayed_code()
  val x : int * int * int = (1,2,3);
  val y : (int * int) * int = ((1,2),3);
  val z : int * (int * int) = (1,(2,3));
@end_displayed_code()
These three tuples have distinct types and
values. The first has three components,
each of type int. The other two have two
components each: an int and a pair of ints,
in the two possible orderings.
@p()
The type of the empty tuple '()' is called
'unit'. It can also be called '1', the reason
will become clear soon.
@p()
I said before that 'almost' all functions in
Felix have one argument. The tuple constructor
is the exception.
@p()
You can get at tuple components using a suffixed
dot followed a zero origin integer in brackets:

@select(env.test('.flx'))
val x = (0,1,(3,4));
print x.(0); print " ";
print x.(1); print " ";
print x.(2).(0); print " ";
print x.(2).(1); print "\n";
@doc()

@select(env.expect())
0 1 3 4
@doc()

The brackets are needed so the lexer
doesn't get confused with floating point.
The notation is ugly and not recommended ..
there is a better way called pattern matching
which you will learn about soon.

@env.head(2,'Pattern Matching Tuples')
It is also possible to pattern match tuples.
Here is an example:

@select(env.test('.flx'))
val v = 1,2,(3,4);
match (v) with
  | (?x,_,?z) =>
  {
    print x;
    print ", ";
    match (z) with
      | (?a,?b) =>
      {
        print "(";
        print a;
        print ", ";
        print b;
        print ")";
      }
    endmatch;
  }
endmatch;
endl;
@doc()

@select(env.expect())
1, (3, 4)
@doc()

Notice the use of the special pattern '_', which matches
something without naming it. The ?x designation
in a pattern introduces a variable.

@env.head(2,'Numbered unions')
Numbered unions are algebraic types used to
represent alternative cases. The infix
operator + is the type combinator used
to denote them. The number is zero origin.

@select(env.test('.flx'))
open Long;

typedef three = unit +  unit + unit;
typedef four = 4;
typedef nu = int + double + long;


val x1 = case 0 of (1+1+1);
val x2 = case 1 of 3;

proc g(x:three) {
  print "Case ";
  match x with
  | case 0 => { print 0; }
  | case 1 => { print 1; }
  | case 2 => { print 2; }
  endmatch;
  print " of three\n";
}

g x1;
g x2;
g (case 2 of three);

proc f(x:nu) {
  match x with
  | case 0 ?z => { print "case 0 "; print z; }
  | case 1 ?z => { print "case 1 "; print z; }
  | case 2 ?z => { print "case 2 "; print z; }
  endmatch;
  print "\n";
}

val i1 = (case 0 of nu) 33;
val i2 = (case 1 of nu) 3.3;
val i3 = (case 2 of nu) 33L;
f i1;
f i2;
f i3;
@doc()

@select(env.expect())
Case 0 of three
Case 1 of three
Case 2 of three
case 0 33
case 1 3.3
case 2 33
@doc()

@env.head(2,'Structs')
Felix supports C like structs. A struct, like a tuple,
is a categorical product type. Unlike a tuple,
a struct is named, its members are named, and
its members are mutable.
@p()
Struct members can be used with C style dot notation.
Here is an example:

@select(env.test('.flx'))

struct XY {
  x : int;
  y : int;
}

var xy : XY;
xy.x = 1;
xy.y = 2;
print xy.x; endl;
print xy.y;  endl;
@doc()

@select(env.expect())
1
2
@doc()

The name of a struct is also the name of a function
which constructs an object of the struct type
from a tuple consisting of values to initialise
the members in sequence. For example:

@select(env.test('.flx'))

struct XY = {
  x : int;
  y : int;
}

val xy = XY(1,2);
print xy.x; endl;
print xy.y; endl;
@doc()

@select(env.expect())
1
2
@doc()

@env.head(2,'Records: anonymous structs')
A record is an anonymous struct: its a tuple with
named fields. Two records are the same type if their
field names are the same, and have the same types.
The order of fields is irrelevant.
@p()
A record can be coerced to a record with less fields.

@select(env.test('.flx'))
@kat('Records')
open Float;

typedef big = struct { a:int; b: long; c: float; };
typedef small = struct { a: int; c:float; };

proc f(x:small) {
  print$ x.a; endl;
  print$ x.c; endl;
}

val b = struct { b=2L; c=3.1f; a=6; };

f (b:small);
@doc()

@select(env.expect())
6
3.1
@doc()

[New 2007-09-20] Record values can also be written in the simpler form:
@begin_displayed_code()
  (a=1,b=2)
@end_displayed_code()
Furthermore, structs can be initialised by a record with
the same set of components, meaning the name and type agree.
@p()
Also, records can be used as arguments to functions
by specifying the parameter names.
@p()
Also parameters can have default values.

@select(env.test('.flx'))
@kat('Records')
@kat('Struct:initialised by record')

var x = struct {a=1; b=2; };
println q"a=$(x.a), b=$(x.b)";
var y = (a=3, b=4);
println q"a=$(y.a), b=$(y.b)";

struct X { aa:int; bb:int; };

val k = X (1,2);
println q"aa=$(k.aa), bb=$(k.bb)";

val j = X (bb=11,aa=22);
println q"aa=$(j.aa), bb=$(j.bb)";

val r = (bb=88,aa=99);
val q = X r;
println q"aa=$(q.aa), bb=$(q.bb)";

fun f(a:int, b:int)=> a + 2* b;
fun f(x:int, y:int)=> 2 * x + 5* y;

var d = f(b=1,a=2); // 4
println q"d=$(d)";

d = f(x=1,y=2); // 12
println q"d=$(d)";


fun g(xx:X)=> xx.aa+xx.bb;
println$ g (X (aa=1,bb=2));


proc p(a:int, b:string)
{
  println$ b + " " + str a;
}

p$ 1,"Hi";
p (a=1,b="HIHI");

fun f(a:int)=> 3 * a;
println$ f 2;
println$ f (a=4);

fun g(x:struct {a:int;})=>9 * x.a;
println$ g (a=2);

fun df(a:int=1,b:long)=> long a + b;
println$ df (1,2L);

println$ df (b=2L); // a should default to 1

fun df2(a:int=1,b:long=2L)=> long a + b;
println$ df2 (); // should default both 1 and 2
@select(env.expect())
a=1, b=2
a=3, b=4
aa=1, bb=2
aa=22, bb=11
aa=99, bb=88
d=4
d=12
3
Hi 1
HIHI 1
6
12
18
3
3
3
@doc()

@select(env.test('.flx'))
@kat('Records')
@kat('operator dot')
@kat('parameter names')
proc flooreach (name:string) (x:string)
  {println$ name  " (name)="  x; }

proc flooreach (prompt:string) (x:string)
  {println$ prompt  "(prompt)="  x; }

(name="hi") . flooreach "john";
(prompt="bye") . flooreach "erick";
@select(env.expect())
hi (name)=john
bye(prompt)=erick
@doc()
@env.head(2,'Arrays')
Felix provides arrays of constant length.
The type notation
@begin_displayed_code()
  t ^ m
@end_displayed_code()
is used to declare an array with elements
of type t, indexed by elements of type m.
Currently, m must be a sum of units, that is,
it must have the form 1 + 1 + 1 .. which
can be abbreviated by a non-negative integer
constant. The implementation is a struct
wrapping an actual C array.
@p()
An array is just a tuple of m elements of type t.
[More .. ]

@env.head(2,'Unions')
Felix supports unions, but they are a bit
different to C unions. A union is a way
of merging a finite set of types into
a single type; that is, it provides
type unification. An object of a union type
consists of a tag, identifying what type
the component has, and the actual component.
Here are some examples of unions.

@select(env.test('.flx'))
@kat("unions")

union parity =
  | Odd
  | Even
;

union int_option =
  | iSome of int
  | iNone
;

enum E {zero, one, two};

val x = Odd;
val y = iSome 1;
val z = one;

enum X {a,b=2,c,d=0xf};
fun str : X->string =
  | a => "a"
  | b => "b"
  | c => "c"
  | d => "d"
;

print$ str a + str (caseno a); endl;
print$ str b + str (caseno b); endl;
print$ str c + str (caseno c); endl;
print$ str d + str (caseno d); endl;
@doc()

@select(env.expect())
a0
b2
c3
d15
@doc()

We'll see how to actually use unions in the
next section. But note first that the parity
example is very similar to a C enumeration.
The names of the union components are
called constructors by convention.
They have two roles: they represent the
constant value of the tag indicating
which component we're talking about:
tags values are assigned sequentially,
starting at 0.
@p()
In their second role, the constructors
are considered functions, so that
Some is a function with type:
@begin_displayed_code()
  int -> int_option
@end_displayed_code()
It is important to note that the constructor
names are visible in the enclosing space,
unlike struct component names.
@p()
The enum form only permits constant constructors
(ones with no arguments), values are not permitted.

@env.head(2,'Pattern Matching Unions')
The only way to get at the current component
of a union is by pattern matching. Here is an example:

@select(env.test('.flx'))
@kat("pattern match:union")
@kat("unions:pattern match")
union int_option =
  | iSome of int
  | iNone
;

val y = iSome 1;

match y with
  | iSome ?i =>
    {
      print "Some ";
      print i;
    }
  | iNone =>
    {
      print "None";
    }
endmatch;
endl;
@doc()

@select(env.expect())
Some 1
@doc()

Notice that the value 'i' in the line
@begin_displayed_code()
  | Some ?i =>
@end_displayed_code()
can be used in the handler for that case.
This is how we get the 'int' out of the Some option.
The 'i' is scoped so it can only be seen inside
the handler for the Some case.
The question mark is used to indicate a pattern
variable, its type is deduced from the pattern context
and match argument type.
@p()
By the way, match/endmatch is an expression.
It happens in the example above that each handler
is a procedure value taking a unit argument, and the match
expression returns one of these values depending on the
argument exprssion. Oh, and it happens that the semi-colon
after the 'endmatch' keyword then executes this procedure.
@p()
It is important to note that the match expression is
purely functional! It doesn't print anything, it just
returns a procedure which could print something.

@env.head(2,'The Conditional Expression')
Felix supports the conditional expression as shown:

@select(env.test('.flx'))
@kat("conditional")

fun sign1(x:int):int =
{
  return
    if x < 0 then -1
    else
      if x == 0 then 0
      else 1
      endif
    endif
  ;
}

print (sign1 (-20)); endl;
print (sign1 0); endl;
print (sign1 20); endl;

fun sign2(x:int):int =
{
  return
    if x < 0 then -1
    elif x == 0 then 0
    else 1
    endif
  ;
}

print (sign2 (-20)); endl;
print (sign2 0); endl;
print (sign2 20); endl;


fun sign3(x:int):int =
{
  return
    match x < 0 with
    | case 1 => -1 // true
    | case 0 =>    // false
      match x == 0 with
      | case 1 =>  0 // true
      | case 0 =>  1 // false
      endmatch
    endmatch
  ;
}

print (sign3 (-20)); endl;
print (sign3 0); endl;
print (sign3 20); endl;
@doc()

@select(env.expect())
-1
0
1
-1
0
1
-1
0
1
@doc()

In the conditional construction, one or more
elif clauses may be give, however the
else clause is required. The elif clause
is used reduce the need for terminating
endif keywords.
@p()
The conditional expression is merely
a shortcut for a match, as shown in the
third sign function.

@env.head(2,'Objects')
Felix provides a way of making objects from functions.
An object is just a struct whose members are functions
nested in the scope of the object constructor function.
Variables in the constructor are hidden.
@p()
Note: the type of a member function must not depend
on a name or type defined in the object (this constraint is
because the desugaring precedes name binding).
@p()
Note: object constructors are not members, because their
types would be local to the constructor (see above).
@p()
Note: The name of the type of an object with constructor 'x' is
'_ot_x': the constructor name prefixed by '_ot_' (Ugly).
@p()
Note: you can change the methods of an object by assigning
a new functional value to the structure component.
@p()
Note: the type of the object is not part of a method
signature: their type is as written.
@p()
Note: only explicitly declared non-private functions (and procedures)
are taken as methods. Implicit functions such as blocks
are not taken.

@select(env.test('.flx'))
obj a(x:int) {
  var v = x;
  fun fetch ():int = { return v; }
  proc store (y:int) { v = y; }
}

val z = a(1);
print (z.fetch()); endl;
z.store(2);
print (z.fetch()); endl;
@doc()

@select(env.expect())
1
2
@doc()

@env.head(2,'Pointers')
Felix supports pointers. The type of a pointer to T is
denoted:
@begin_displayed_code()
  &T
@end_displayed_code()
A pointer can be created by addressing a variable
using the notation:
@begin_displayed_code()
  &v
@end_displayed_code()
Pointers can be dereferenced using the usual syntax:
@begin_displayed_code()
  *p
@end_displayed_code()
and there is the usual arrow notation:
@begin_displayed_code()
  p->x
@end_displayed_code()
which means the same as
@begin_displayed_code()
  (*p).x
@end_displayed_code()
@p()
Only variables, not values, are addressable.
Pointers are used to implement assignment.
You have seen many examples of assignment:
@begin_displayed_code()
  var v : T;
  v = e;
@end_displayed_code()
What you didn't know was that the assignment
operator is just syntactic sugar for
the procedure call:
@begin_displayed_code()
  set(&v,e);
@end_displayed_code()
This procedure is defined automatically
for structs, unions, and function and procedure
closures, that is, for Felix types; but you can
define it manually for abstract types including
primitives. The usual definition is:
@begin_displayed_code()
  type T = "T";
  proc _set: &T * t = "*$1=$2;"
@end_displayed_code()
If you don't define a set method for a primitive
type, Felix assumes the C++ assignment operator
as above. WARNING: This is wrong in principle,
since Felix cannot check such a function exists,
if it doesn't, you will get an error at C++ compilation
time instead of Felix compilation time. Be warned!
@p()
Note that all Felix primitives must be C++ assignable
and implicitly default constructible,
since in the generated code all values and variables
are first declared without an initialiser and
then assigned to.
@p()
It is important to note that in Felix,
you can take the address of any variable,
and safely pass the pointer around, without
fear it will dangle: this includes pointers
to function and procedure local variables.
@p()
This all works because Felix uses a garbage collector,
but you should note that because the frame containing
an object must be kept alive if there is a pointer into
it, returning a pointer to a function local variable
may prevent other local variables in the same
frame from being destroyed.
@p()
Here is an example:

@select(env.test('.flx'))
@kat('modules:initialisation')

fun pone (): &int =
{
  var x : int = 1;
  return &x;
}

var p1 = pone();
print (*p1); endl;
*p1 = 2;

print (*p1); endl;
@doc()

@select(env.expect())
1
2
@doc()

You should note that Felix pointers consist
of two C pointers: a pointer to the variable,
and a pointer to the frame containing the variable.
It is this frame pointer which the garbage collector
tracks. Although Felix pointers do not have to
be initialised, the frame pointer component
of the representation is always initialised to NULL
so that the garbage collector doesn't chase off into
the wild blue yonder.

@env.head(2,'Classes')
@select(env.test('.flx'))
@kat("classes")
open Long;

class Y {
  // variables
  val c : int;
  var x : int;
  var y : long;

  // accessor methods
  fun fetchc():int =>c;

  // mutators
  proc setx(a:int) { x = a; }
  proc setxy( a:int, b:long) { x = a; y = b; }

  // accessor procedures
  proc yprint() {
    print "THIS is a Y object, with x = ";
    print x; print ", y = "; print y;
    print ", and c = "; print c; endl;
  }

  // test methods calling methods

  fun f(a:int):int => g a;
  fun g(a:int):int => a + x;

  // constructors
  ctor () {}
  ctor (a:int): c(20000) { x = a; }
};

var ob <- new Y(99);
ob.x = 2;
ob.y = 3L;

print ob.c; endl;
print ob.x; endl;
print ob.y; endl;
print$ ob.fetchc(); endl;

ob.setx 22;
ob.yprint();

ob.setxy (12,33L);
ob.yprint;

print$ ob.f 1; endl;

proc ncl() {
  var x = 42;
  class J {
    var j:int;
    ctor (a:int) { j = a; }
    fun h(q:int):int => q + j + x;
  };
  var b <- new J(100);
  print$ b.h 1000; endl;
};

ncl;
@doc()

@select(env.expect())
20000
2
3
20000
THIS is a Y object, with x = 22, y = 3, and c = 20000
THIS is a Y object, with x = 12, y = 33, and c = 20000
13
1142
@doc()

@env.head(2,'Regular Expressions')
Felix provides support for matching strings
against regular expressions.
@p()
Unlike commonly used regexp libraries,
regular expressions are not strings: instead a first class
syntax is used to define them.
@p()
NOTE: Felix also provides a conventional string based regular
expression library based on Ville Laurikaris Tagged Regular Expression
library TRE.
@cite_url("../../moduledoc/Tre.html")
@p()
Felix allows you to name regular expressions with
the syntax:
@begin_displayed_code()
  regexp <name> = <regexp> ;
@end_displayed_code()
The name is an identifier. A string used in a regexp stands
for a match of each character of the string in sequence.
The following symbols are special, and are given from weakest
to strongest binding order:

@begin_table("symbol","syntax","meaning")
@table_row("|","infix","alternatives")
@table_row("*","postfix","0 or more occurences")
@table_row("+","postfix","1 or more occurences")
@table_row("?","postfix","0 or 1 occurences")
@table_row("<juxtaposition>","infix","concatenation")
@table_row("<name>","atomic","re denoted by the name in a REGEXP definition")
@table_row("<string>","atomic","sequence of chars of the string")
@table_row("[<charset>]","atomic","any char of the charset")
@table_row("[^<charset>]","atomic","any char not in the charset")
@table_row(".","atomic","any char other than end of line")
@table_row("_","atomic","any char")
@table_row("eof","atomic","end marker")
@table_row("(<regexp>)","atomic","brackets")
@end_table()
The usual notation for character sets is employed:
@begin_table("symbol","meaning")
@table_row("<string>","any character in the string")
@table_row("<char>-<char>","any between or including the two chars")
@end_table()
Note that a char is represented by a one character string.

@h = env.test('.flx')
@select(h)
regexp lower = ["abcdefghijklmnopqrstuvwxyz"];
regexp upper = ["ABCDEFGHIJKLMNOPQRSTUVWXYZ"];
regexp digit = ["0123456789"];
regexp alpha = lower | upper | "_";
regexp id = alpha (alpha | digit) *;
@doc()

Regular expressions are used in regular match expressions.
These are like ordinary matches, except that the pattern
is a regular expression, and the argument must be a string.
If more than one pattern matches the string, the first
one is used.

@select(h)
print
  regmatch "identifier" with
  | digit+ => "Number"
  | id =>  "Identifier"
  endmatch
;
endl;

print
  regmatch "9999" with
  | digit+ => "Number"
  | id =>  "Identifier"
  endmatch
;
endl;

print
  regmatch "999xxx" with
  | digit+ => "Number"
  | id =>  "Identifier"
  | _* => "Neither"
  endmatch
;
endl;
@doc()

@select(env.expect())
Identifier
Number
Neither
@doc()

Note that whilst conceptually regular matches are applied
first to last, the actual implementation uses a finite state
machine and guarranteed to be linear in the length of the input,
and, in particular independent of the number of regular expressions.
Each character is processed at most once.
@p()
Note: the generated code is *extremely* fast, within
one or two memory fetches of the fastest possible code.
here is the generated code for the inner loop of a regmatch:
@begin_displayed_code()
  while(state && start != end)
    state = matrix[*start++][state];
@end_displayed_code()

@env.head(2,'Lexing')
Felix provides a mechanism for constructing lexers.
The reglex construction matches a prefix of the string.
Of all possible matches, reglex chooses the longest match.
As for regmatch, if
more than one regexp matches, the first written is used.
@p()
The expression for each regexp has access to three
values of type iterator: lexeme_start, lexeme_end and
buffer_end.

@select(env.test('.flx'))
open Lexer;

regexp lower = ["abcdefghijklmnopqrstuvwxyz"];
regexp upper = ["ABCDEFGHIJKLMNOPQRSTUVWXYZ"];
regexp digit = ["0123456789"];
regexp alpha = lower | upper | "_";
regexp space = " ";
regexp white = space +;

fun lexit(start:iterator, finish:iterator):
  iterator * (string * string)
=
{
  return
    reglex start to finish with
    | digit+ => "Number",
      string_between(lexeme_start,lexeme_end)

    | alpha+ =>  "Identifier",
      string_between(lexeme_start,lexeme_end)

    | white =>  "White",
      string_between(lexeme_start,lexeme_end)
    endmatch
  ;
}


var s = "A string 2 lex";
val first = start_iterator s;
val finish = end_iterator s;
var current = first;

while { current != finish }
{
    match lexit(current, finish) with
    | ?next,(?kind,?lexeme) =>
    {
      current = next;
      print kind; print ": "; print lexeme; endl;
    }
    endmatch
  ;
};
print "Done.\n";
@doc()

@select(env.expect())
Identifier: A
White:
Identifier: string
White:
Number: 2
White:
Identifier: lex
Done.
@doc()

@env.head(2,'Lazy expressions')
There is a function which is so useful, there
is a special syntax for it: the lazy expression.

@select(env.test('.flx'))
var x = 1;
var y = 2;

val f1 = {x + y}; // lazy expression
fun f2():int = { return x + y; } // equivalent

print (f1 ());
print (f2 ());

x = 2; // change value of variables
y = 3;

print (f1 ());
print (f2 ());
endl;
@doc()

@select(env.expect())
3355
@doc()

The curly brackets denote a lazy expression, it is
a function which evaluates the expression when passed
the special unit value () explained below, the return type
is the type of the expression.
@p()
You can also put statements inside curly brackets
to define a lazy function:

@select(env.test('.flx'))
val x = 1;
val f = { val y = x + 1; return y; };
val eol = { endl; };

print (f ()); eol;
@doc()

@select(env.expect())
2
@doc()

If there is no return statement, a block procedure is denoted,
otherwise the return type is the type of the return
statement arguments, which must all be the same.

@env.head(2,'The block procedure')
There is a procedure which is so useful, there
is a special syntax for it, as described above in
the section on lazy things: the block.

@select(env.test('.flx'))
var x = 1;
val p1 = { print x; };
proc p2() { print x; }; // equivalent to p1 (almost)

// all these calls have the same behaviour
p1();
p1;
p2();
p2;
{ print x; }();
{ print x; };
print x; endl;
@doc()

@select(env.expect())
1111111
@doc()

The block is a procedure taking a unit argument.
So when you write one as a statement, it just gets
called: note that unlike C, that thing in
curly braces is an expression, and you must
make a statement by adding a semi-colon,
which has the effect of invoking it due to the
short cut rule.


@env.head(1,'Generics')
There are 3 kinds of genericity in Felix: ad hoc polymorphism
in the form of overloading, parametric polymophism using
type schema or families of entities indexed by types,
and specialisations modelled with apparently parametric
polymorphic typeclasses, but which are instantiated
with specialised instances.

@env.head(2,'Generic Functions')
Felix functions and procedures can be generic too.
Here is a simple example.

@select(env.test('.flx'))
header "#include <iostream>";
proc print[T]:T="std::cout << $1 << std::endl;";
fun fst[T,U](x:T,y:U): T ={ return x; }
fun snd[T,U](x:T,y:U): U ={ return y; }

val x = (1,2);
print[int] (fst[int,int] x);
print[int] (snd[int,int] x);

proc pp[T] (x:T) { print[T](x); }

pp[int] (snd[int,int] x);
@doc()

@select(env.expect())
1
2
2
@doc()

When declaring a generic function or procedure,
if one of the parameters has the type of a type
variable which is not used elsewhere, you can leave
out the type variable, and one will be synthesised for you.
Synthesised type variables are added
to the type variable list at the end. For example:

@select(env.test('.flx'))
header "#include <iostream>";
proc print[T]:T="std::cout << $1 << std::endl;";
fun fst(x,y) = { return x; }
fun snd(x,y) = { return y; }

val x = (1,2);
print[int] (fst[int,int] x);
print[int] (snd[int,int] x);

proc pp[T] (x:T) { print[T](x); }

pp[int] (snd[int,int] x);
@doc()

@select(env.expect())
1
2
2
@doc()

Note in this example, the return type cannot
be stated since it depends on a synthesised type variable.
@p()
When there is only one argument which has a type
which is a type variable, then if the type variable
is omitted, the parentheses can also be omitted.
This is particularly useful with curried declarations.
@p()
Note carefully that in the call to pair below, both the
type subscripts must be given explicity, because they cannot
be deduced from the argument.

@select(env.test('.flx'))
fun pair1 x y = { return x,y; }
fun pair2[t,u] (x:t) (y:u) = { return x,y; }
fun diag x = { return x,x; }
fun fst (x,y) = { return x; }
fun snd (x,y) = { return y; }

{
  val x34 = pair1[int,int] 3 4;
  val a = fst x34;
  val b = snd x34;
  print a; print ","; print b; endl;
};

{
  val x34 = pair2[int,int] 3 4;
  val a = fst x34;
  val b = snd x34;
  print a; print ","; print b; endl;
};

val x22 = diag 2;
val x = fst x22;
val y = snd x22;
print x; print ","; print y; endl;
@doc()

@select(env.expect())
3,4
3,4
2,2
@doc()

@env.head(2,'Generic Structs and Unions')
Felix structs and unions can be generic too.
Here is a simple example.

@select(env.test('.flx'))
union list[T] =
  | Cons of T * list[T]
  | Empty
;

struct pair[T,U] =
{
  fst : T;
  snd : U;
}

var x = Cons[int] (1,Empty[int]);
x =  Cons[int] (2,x);
x = Cons[int] (3,x);

val y = pair[int,int] (1,2);
print y.fst; print ","; print y.snd; endl;
@doc()

@select(env.expect())
1,2
@doc()
@env.head(2,"Polymorphic Classes")

@select(env.test('.flx'))
@kat("polymorphism")
@kat("classes")
open Long;

class Y[t] {
  // variables
  val c : int;
  var x : t;
  var y : long;

  // accessor methods
  fun fetchc():int =>c;

  // mutators
  proc setx(a:t) { x = a; }
  proc setxy( a:t, b:long) { x = a; y = b; }

  // accessor procedures
  proc yprint(xprint:t->0) {
    print "This IS a Y object, with x = ";
    xprint x; print ", y = "; print y;
    print ", and c = "; print c; endl;
  }

  // test methods calling methods

  fun f(a:int,add:int * t->int):int => g$ a,add;
  fun g(a:int,add:int * t->int):int => a + x;

  // constructors
  ctor () {}
  ctor (a:t): c(20000) { x = a; }
};

var ob <- new Y[int](99);
ob.x = 2;
ob.y = 3L;

print ob.c; endl;
print ob.x; endl;
print ob.y; endl;
print$ ob.fetchc(); endl;

proc iprint(x:int) { print x; }

ob.setx 22;
ob.yprint(iprint of (int));

ob.setxy (12,33L);
ob.yprint(iprint of (int));

print$ ob.f (1,add of (int*int)); endl;

proc ncl() {
  var x = 42;
  class J {
    var j:int;
    ctor (a:int) { j = a; }
    fun h(q:int):int => q + j + x;
  };
  var b <- new J(100);
  print$ b.h 1000; endl;
};

ncl;

class A[t] {
  fun f(a:t):t=>a;
  ctor (){}
};

module V[t] {
  fun f(a:t):t=>a;
};

fun X[t]() = {
  fun f(a:t):t=>a;
}
var aint <- new A[int]();
@doc()

@select(env.expect())
20000
2
3
20000
This IS a Y object, with x = 22, y = 3, and c = 20000
This IS a Y object, with x = 12, y = 33, and c = 20000
13
1142
@doc()

@env.head(2,"Polymorphic Methods")

@select(env.test('.flx'))
@kat("polymorphism")
@kat("classes")
open Long;

class Y[t] {
  // variables
  val c : int;
  var x : t;
  var y : long;

  // accessor methods
  fun fetchc():int =>c;

  // mutators
  proc setx(a:t) { x = a; }
  proc setxy( a:t, b:long) { x = a; y = b; }

  // accessor procedures
  proc yprint(xprint:t->0) {
    print "This is a Y object, with x = ";
    xprint x; print ", y = "; print y;
    print ", and c = "; print c; endl;
  }

  // test methods calling methods

  fun f(a:int,add:int * t->int):int => g$ a,add;
  fun g(a:int,add:int * t->int):int => a + x;

  // constructors
  ctor () {}
  ctor (a:t): c(20000) { x = a; }

  // polymorphic method
  fun p[u](a:u, add:t * u ->int):int => x + a;
};

var ob <- new Y[int](99);
ob.x = 2;
ob.y = 3L;

print ob.c; endl;
print ob.x; endl;
print ob.y; endl;
print$ ob.fetchc(); endl;

proc iprint(x:int) { print x; }

ob.setx 22;
ob.yprint(iprint of (int));

ob.setxy (12,33L);
ob.yprint(iprint of (int));

print$ ob.f (1,add of (int*int)); endl;
print$ ob.p[int] (1,add of (int*int)); endl;
@doc()

@select(env.expect())
20000
2
3
20000
This is a Y object, with x = 22, y = 3, and c = 20000
This is a Y object, with x = 12, y = 33, and c = 20000
13
13
@doc()


@env.head(2,'Argument Deduction')
It is inconvenient to specify the type
arguments for a function. Generally,
this is not necessary, as illustrated in
the example: Felix deduces the value
of the type variables from function arguments.

@select(env.test('.flx'))
union list[T] =
  | Cons of T * list[T]
  | Empty
;

struct pair[T,U] =
{
  fst : T;
  snd : U;
}

var x = Cons (1,Empty[int]);
  // the [int] in Empty is mandatory

x =  Cons(2,x);
x = Cons(3,x);

fun f[t] (x:list[t]):list[t] = { return x; }

x = f(x);

val y = pair(1,2);
print y.fst; print ","; print y.snd; endl;


// check nested generics now

module F[T] {
  fun id1(x:T):T = { return x; }
}

print (F[int]::id1 1); endl;

module A[T] {
  module B[U] {
    fun id2[V](x:T,y:U,z:V):V*U*T = { return z,y,x; }
  }
}

val zyx = (A[int]::B[int]::id2(1,2,3));
print zyx.(0);
print zyx.(1);
print zyx.(2);
endl;

// check specialisation
fun idt[T] (x:T):T*T = { return x,x; }
fun idt[T] (x:T*T):T*T = { return x; }

val x1 = idt(1); // calls first idt
val x2 = idt(1,2); // calls second idt
print x1.(0); print x1.(1); endl; // print 11
print x2.(0); print x2.(1); endl; // print 12

proc pr[T] (x:list[T], pp:T->void) {
  match x with
  | Cons (?i,?t) => { pp i; pr (t,pp); }
  | Empty => { print "Empty"; }
  endmatch
  ;
}

proc printint (x:int) { print x; }
  // because we can't use a primitive as a closure yet

pr (x,(printint of (int))); endl;
@doc()

@select(env.expect())
1,2
1
321
11
12
321Empty
@doc()

@env.head(2,'Generic modules')
It is also possible specify type arguments for a module.
The effect is simply that all the entities declared in
the module are parameterised by the type parameter.
@p()
Because of this, you can open a generic module,
but you must do so without specifying any type arguments.
@p()
When you use a qualified name, Felix concatenates
all the arguments and applies them to the last component.
@p()
Note this excludes parent functions, since the type
arguments of the parent of a function are fully
determined by its child.

@select(env.test('.flx'))

module X[t] {
  fun f[k]: t * k  -> t = "1";
  fun xcmp: t * t -> bool = "1";
  fun mk: 1 -> t = "1";
  fun subscript: t * t -> t = "2";
}

// both args explicit
var a1 = X[int,long]::f(1,1L);
var a2 = X[int]::f[long](1,1L);
var a3 = X::f[int,long](1,1L);

// first arg explicit
var a4 = X::f[int](1,1L);
var a5 = X[int]::f(1,1L);

// full deduction
var a6 = X::f(1,1L);

// using unqualified names
open X;
var a7 = f[int,long](1,1L);
var a8 = f[int](1,1L);
var a9 = f(1,1L);

print a1;
print a2;
print a3;
print a4;
print a5;
print a6;
print a7;
print a8;
print a9;

print (1).[2];

var x = mk[int]();
var y = mk[int]();
if xcmp(x,y) do print "YES"; endl; else print "NO"; endl; done;
@doc()

@select(env.expect())
1111111112YES
@doc()

@env.head(1,'UNFINISHED')
@env.head(2,'Inductive types')
Felix supports inductive types such as lists.
Here is a list of ints.

@select(env.test('.flx'))

union float_list =
  | Empty
  | Cons of double * float_list
;

val t0 = Empty;
val nxt = (100.1,t0);
val t1 = Cons nxt;
val t2 = Cons (200.2,t1);

proc xprint (a: float_list)
{
  match a with
  | Empty => { print "[]"; }
  | Cons (?i, ?tail) =>
    {
      print i;
      print " ";
      xprint tail;
    }
  endmatch;
}

xprint t2; endl;
@doc()

@select(env.expect())
200.2 100.1 []
@doc()

A more interesting example is now given.
Here, we use a recursive routine to build the list,
and an iterative routine to reverse it.

@select(env.test('.flx'))

union int_list =
  | Empty
  | Cons of int * int_list
;

proc xprint (a: int_list)
{
  match a with
  | Empty => { print "[]"; }
  | Cons (?i,?tail) =>
    {
      print i;
      print " ";
      xprint tail;
    }
  endmatch;
}

fun mk(i: int, tl:int_list):int_list =
{
  return
    if(i>0) then mk(i-1,Cons(i,tl))
    else tl
    endif
  ;
}

val a = mk(10,Empty);
print "List= "; xprint a; endl;

fun rev(lst:int_list):int_list =
{
  var result = Empty;
  proc aux(lst:int_list)
  {
    match lst with
    | Empty => {}
    | Cons (?head,?tail) =>
      {
        result = Cons(head,result);
        aux(tail);
      }
    endmatch;
  }
  aux(lst);
  return result;
}

print "Reversed= "; xprint (rev a); endl;
@doc()

@select(env.expect())
List= 1 2 3 4 5 6 7 8 9 10 []
Reversed= 10 9 8 7 6 5 4 3 2 1 []
@doc()

@env.head(2,'Higher order Functions')
In Felix, functions and procedures are first class:
they may accept functions or procedures as arguments,
functions may return them, and you can have variables
of function or procedure type.
@p()
In particular, a function or procedure may be
defined inside another function or procedure,
and it may still use any values or variables
defined in that function or procedure, even when
it is returned by it.
@p()
Note that when the returned function or procedure
is called later, the values of variables may have
changed since the time that it was passed.
@p()
Here is an example, beware this example
contains quite a lot of subtle features!

@select(env.test('.flx'))
@kat('functions:higher order')

var j = 2;

fun get_printer(i:int): unit->void  = {
  proc print() { print (i+j); }
  return print of (unit);
}

val print_i = get_printer(40);
print_i(); endl;
j = 3;
print_i(); endl;
@doc()

@select(env.expect())
42
43
@doc()

There are a couple of things to notice.
The function return type is given as

@begin_displayed_code()
  unit->void
@end_displayed_code()

This is the notation for a procedure type accepting
a unit argument.
@p()
Notice also that the return value is

@begin_displayed_code()
  print of (unit)
@end_displayed_code()

This is the name of the function called 'print'
which accepts a unit argument. Felix can perform
overload resolution when a function name is applied
to an argument, by inspecting the type of the argument.
In other circumstances, you have to specify the type
of the argument.
@p()
There is a subtle point of the overloading system
here. The procedure 'print of (unit)' actually
calls the procedure 'print of (int)'. Now if you are
used to C++, you may wonder how this would work:
the search for 'print of (int)' stats by finding
'print of (unit)', and in C++ it would stop right there
and report an error. In Felix, if overload resolution
for an unqualified function or procedure name fails,
the enclosing scope is examined. This 'overloading
across scopes' is allows you to extend an overload
set locally. The special rule does not apply
to qualified names (where the name must be found
in the designated scope). [I may change this!]
@p()
Another thing to notice is that
the call to print_i cannot be abbreviated by leaving
the () off. This is because print_i is a function
value, not the name of a function.
@p()
More precisely, the function specification for p of (unit)
is used to build a function closure: this consists of the
code body of the function, together with the environment
at the point of definition and the time the closure
is created: it binds to the current 'activation record'
or 'stack frame' of the enclosing function 'get_printer'.
And because that environment contains the value 'i'
initialised to 30, and the variable 'j', it will
print 40 + j as an answer when called. This is 42
the first time, since at that time j is 2, and 43 the
second time, since j is then 3.
@p()
The difference between a function specification
and a function closure may seem difficult to grasp
at first, but the implementation makes the distinction
quite clear: a function specification is a C++ class,
whereas a function closure is an object of that class.
Function closures exist at run time, function specifications
only exist at compile time. Unfortunately perhaps,
the unqualified term "function" is used to refer to both.
Even more confusing, it sometimes means procedures
as well (even though they're utterly different beasts).

@env.head(2,'The "the" keyword')
When naming functions, it annoying
to write the signature of the function
when there is clearly only one function
of a given name. in this special case
you can use the keyword 'the' to specify
you mean that function.

@select(env.test('.flx'))
@kat('the:keyword')

fun f(x:int):int=>x*x;
fun apply[s,d] (f:s->d) (x:s) : d => f x;

print (apply (the f) 4); endl;
@doc()

@select(env.expect())
16
@doc()

@env.head(2,'Currying')
Consider the following example:

@select(env.test('.flx'))
@kat('currying')

fun f4(i4:int): int->int->int->int = {
  fun f3(i3:int): int->int->int = {
    fun f2(i2:int): int->int = {
      fun f1(i1:int): int = {
        return i1+i2+i3+i4;
      }
      return f1 of (int);
    }
    return f2 of (int);
  }
  return f3 of (int);
}

print (f4 1 2 3 4); endl;
print ((f4 1 2 3) 4); endl;
print ((f4 1 2) 3 4); endl;
print ((f4 1) 2 3 4); endl;
print (((f4 1) 2 3) 4); endl;
print (((f4 1 2) 3) 4); endl;

val curry = f4 1 2;
print (curry 3 4); endl;
@doc()

@select(env.expect())
10
10
10
10
10
10
10
@doc()

You should note that -> is right associative,
so that

@begin_displayed_code()
  int->int->int->int
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  int->(int->(int->int))
@end_displayed_code()
On the other hand, application is left associative,
so that
@begin_displayed_code()
  f4 1 2 3 4
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  (((f4 1) 2) 3) 4
@end_displayed_code()

Note that the 'partial' applications such as
shown by the brackets, are of course closures
of the inner functions, and you can use them
to initialise values, assign them to variables
or pass them to functions. Such 'partial'
application is called currying (after the mathematician
Howard Curry, who invented the lambda calculus).
@p()
While this is a perfectly good defintion,
there is a lot of housekeeping going on.
Felix provides syntactic sugar that makes it easier
to declare functions suitable for currying.
Here is the equivalent code, using this sugar:

@select(env.test('.flx'))
@kat('currying')

fun f4(i4:int) (i3:int) (i2:int) (i1:int): int = {
  return i1+i2+i3+i4;
}

print (f4 1 2 3 4); endl;
print ((f4 1 2 3) 4); endl;
print ((f4 1 2) 3 4); endl;
print ((f4 1) 2 3 4); endl;
print (((f4 1) 2 3) 4); endl;
print (((f4 1 2) 3) 4); endl;

val curry = f4 1 2;
print (curry 3 4); endl;
@doc()

@select(env.expect())
10
10
10
10
10
10
10
@doc()
@select(env.test('.flx'))
@kat('currying')
// contrib: Jonathan Kelly

fun f4a (d:int) (c:int) (b:int) (a:int) : int = {
  return a*1000+b*100+c*10+d;
}

fun f4b (a:int) (b:int) (c:int) (d:int) : int = {
  return a*1000+b*100+c*10+d;
}

print (f4a 1 2 3 4); endl; // 4321

f1 := f4a 1;
print (f1 2 3 4); endl;    // 4321

print (f4b 1 2 3 4); endl; // 1234

f2 := f4b 1;
print (f2 2 3 4); endl;    // 1234
@select(env.expect())
4321
4321
1234
1234
@doc()

You may remember eariler I said that
all Felix accepted exactly one argument,
with one exception: tuple constructors.
@p()
It is conventional to say that a function like
'f4' above has 4 arguments. Of course,
you know that this isn't the case: it really
has one argument and returns a function.
It is also sometimes said that f4 has arity 4,
meaning you can chain applications 4 times,
until you get a non-function result.
@p()
Note that the notation above can be used for
procedures as well: of course, all the partial
applications except the last return functions,
and the last one returns a procedure.
@p()
It is a matter of style whether you write
functions in the curried form or not.
Any function accepting a tuple can be changed
to a currified function accepting the components
in sequence. This is conventional in some
functional programming languages (like Ocaml),
but is less heavily used in others (like SML).
@p()
In the current implementation of Felix, currified
functions are more expensive than ones accepting
tuples, but the currified version is easier to
curry :-)
@p()
As an exercise, write a function that given an
arbitrary function f accepting a tuple of 3 ints,
returns an equivalent currified version of it
that accepts 3 arguments.
@p()
What you have done is called eta-expansion.
It is necessary even for currified functions
if you want to fix the second argument, but
leave the first free.

@env.head(2,'List functions')

@select(env.test('.flx'))
@kat('list:inductive')
open List;
val x : list[int] =
  Cons (1, Cons (2, Cons (3, Empty[int])));
val y = rev x;
iter (proc (x:int) { print x; print ", "; }) x; endl;
iter (proc (x:int) { print x; print ", "; }) y; endl;

proc print (x:list[int])
{
  match x with
  | Empty[int] => { print "[]"; }
  | Cons[int] (?h,?t) =>
    {
      print "["; print h;
      iter (proc (x:int) { print ","; print x; }) t;
      print "]";
    }
  endmatch;
}

fun add (x:int) (y:int):int = { return x + y; }

val x_l_total = fold_left add of (int) 0 x;
val y_l_total = fold_left add of (int) 0 y;
val x_r_total = fold_right add of (int) x 0;
val y_r_total = fold_right add of (int) y 0;
print x_l_total; endl;
print y_l_total; endl;
print x_r_total; endl;
print y_r_total; endl;
@doc()

@select(env.expect())
1, 2, 3,
3, 2, 1,
6
6
6
6
@doc()

@env.head(2,'Koenig Lookup')
Consider the following example:

@select(env.test('.flx'))
@kat('lookup:koenig')
@kat('lookup:dependent')

module A {
  struct X {
    x: int;
  }
}
val e = A::X(5);
print e.x; endl;
@doc()

@select(env.expect())
5
@doc()

There is a subtle point here in this code.
(Isn't there always?) Recall that
@begin_displayed_code()
  e.x
@end_displayed_code()
is transformed by desugaring to the function application
@begin_displayed_code()
  get_x e
@end_displayed_code()
If that is so, how is it that the get_x of (A::X)
is found, when it is not visible in the top level scope?
The answer is that I told a white lie before.
@p()
What really happens is that e.x is transformed
into a method application. This is exactly the
same as a function application, except that
overloading uses a special kind of lookup
for the method name, called Koenig Lookup,
after its inventor, Andrew Koenig.
@p()
Koenig lookup works by searching the module
in which the type of the expression e is
defined: in Felix the type must be generative,
which means it must be a declared type
such as a named struct or union
and not an implicitly defined type like a tuple,
pointer, or function type (typedefs do not count
here, as in C they just specify an alias, they
don't define a type).
@p()
In the example, 'get_x' is defined in the module X,
because A is defined in the module X, and since
e has type 'A', Felix looks in module X for 'get_x'.
@p()
Koenig lookup only works for method calls, that is,
when you use the syntax e.x.

@env.head(2,'Dynamic modules')
Modules can contain executable code, not just declarations.
The executable code of a module is wrapped in an
initialisation function. This function is called
automatically by Felix, when the enclosing
scope is initialised. The top level module's
initialisation routine must be called manually
by the driver program.
@p()
Modules can be nested in functions or procedures.
In this case the data lives in the function
or procedure stack frame, and the module is
initialised every time the function is called.
@p()
[Add more later as features are implemented]

@env.head(2,'The ubiquitous goto')
Felix allows statements to be labelled,
and provides a conditional and unconditional goto statement.

@select(env.test('.flx'))
@kat('goto')
@kat('labels')
print "start"; endl;
var i = 1;
start_loop:>
  if (not (i<10)) goto end_loop;
  print i; endl;
  i++;
  goto start_loop;
end_loop:>
  print "finished"; endl;
@doc()

@select(env.expect())
start
1
2
3
4
5
6
7
8
9
finished
@doc()

Note that labels require a terminating :> rather
that C's plain :.
@p()
Goto is not recommended programming style,
but it is an essential primitive, and it is used
both by the compiler and in the standard library
to define control structures such as 'while'.
@p()
It is also useful for inventing your own
control structures: together with higher
order functions and currying, you can do
this quite easily in Felix, as we shall soon see.
@p()
But first consider the following example:

@select(env.test('.flx'))
@kat('goto:nonlocal')

var x = 1;
proc run()
{
  proc check()
  {
    if(x!=1) goto bad_x;
  }
  check();
  print "good x"; endl;
  x = 2;
  check();
  print "good x"; endl;
  goto finished;

bad_x:>
  print "bad_x"; endl;

finished:>
  print "finished"; endl;
}
run();
@doc()

@select(env.expect())
good x
bad_x
finished
@doc()

In this example, you see what is called a non-local
goto: a jump into an enclosing procedure. Such jumps
are quite OK.
@p()
What you can't do is jump out of a function,
that is, across a function boundary.
[the reason will become clear much later]
@p()
There is another interesting fact. A procedure
nested in a module, including the top level,
cannot jump to a label in the module.
The reason is that executable code in a module,
including any labels, are wrapped in an initialisation
procedure, which is called where the module
is defined. That initialisation procedure does not
have the procedures defined in the module nested in it,
instead, they're at the same level as the initialisation
procedure. You can't jump into the initialisation procedure
because it mightn't be active at the time the other
procedure is called.

@p()
[This may change: a better model would be a that a
module returns the enities exported
from it as a tuple: the procedures would
then be nested in the initialisation routine.
This would also make modules first class objects,
with a type described more or less as a tuple.
In turn this allows dynamic binding.]

@env.head(2,'Procedure return')
A procedure can be terminated by a goto to a label
at the end of the procedure:

@select(env.test('.flx'))
@kat('labels')
@kat('return:procedure')

proc f(x:int)
{
  if x == 0 goto zero;
  print x; endl;
  goto finished;
zero:>
  print "Zero"; endl;
finished:>
}

f(1);
f(0);
@doc()

@select(env.expect())
1
Zero
@doc()

A slightly more structured way of doing this
involves the procedural return statement:

@select(env.test('.flx'))
@kat('return:procedure')

proc f(x:int)
{
  if x == 0 goto zero;
  print x; endl;
  return;
zero:>
  print "Zero"; endl;
}

f(1);
f(0);
@doc()

@select(env.expect())
1
Zero
@doc()

This can also be shortened by using a the jump statement:

@select(env.test('.flx'))
@kat('return:procedure')

proc f(x:int)
{
  if x == 0 goto zero;
  print x; jump endl;
zero:>
  print "Zero"; jump endl;
}

f(1);
f(0);
@doc()

@select(env.expect())
1
Zero
@doc()

which is equivalent to a call statement followed by a
return, which in turn is equivalent to a call
followed by a goto the end of the procedure.

@env.head(2,'Loops')
The final call in a procedure is known as a tail call,
and and can be indicated by a jump statement as
described in the previous section, though it isn't
necessary: tail calls are detected by the compiler.
@p()
There is a special kind of tail call known
as a loop, in which the jump is made to the procedure
containing the jump, or one or its parents.
@p()
Provided no pointers are kept to any of the frames
of the procedures between the target and current
frame, so that all these frames would be garbage
collected, a jump to a parent can reuse the parent's
storage.
@p()
This is a form of goto, except that the procedure
arguments are re-initialised.
@p()
Loops are automatically detected in some cases
by the compiler. An explicit loop statement
may also be used:

@select(env.test('.flx'))
@kat('loops')

proc f(x:int)
{
  if x == 0 goto zero;
  print x; endl; loop f(x-1);
zero:>
  print "Zero"; jump endl;
}

f(10);

@select(env.expect())
10
9
8
7
6
5
4
3
2
1
Zero
@env.head(2,'Conditional Statements')
Felix supports a traditional procedural if chain.
Here is a simple if/do/done:

@select(env.test('.flx'))
@kat('conditional:functional')
// procedural if
proc f(x:int) {
  if x == 1 do print "ONE"; endl; done;
}

f 1;
f 2;
@doc()

@select(env.expect())
ONE
@doc()

You can also have an else clause:

@select(env.test('.flx'))
@kat('conditional:procedural')
// procedural if/else
proc f(x:int) {
  if x == 1 do print "ONE"; endl;
  else print "Not a one .."; endl;
  done;
}

f 1;
f 2;
@doc()

@select(env.expect())
ONE
Not a one ..
@doc()

and even elif clauses:

@select(env.test('.flx'))
@kat('conditional:procedural')
// procedural if/do/elif/else
proc f(x:int) {
  if x == 1 do print "ONE"; endl;
  elif x == 2 do print "TWO"; endl;
  else print "Not a one .."; endl;
  done;
}

f 1;
f 2;
f 3;
@doc()

@select(env.expect())
ONE
TWO
Not a one ..
@doc()

Any number of statements can be used, including none.
You can also use a conditional return or goto instead
of the do part:

@select(env.test('.flx'))
@kat('conditional:procedural')
// procedural if
proc f(x:int) {
  if x == 1 do print "ONE "; endl;
  elif x == 2 return;
  else print "Weird ";
  done;
  print "Found";
}

f 1;
f 2;
f 3;
endl;
@doc()

@select(env.expect())
ONE
FoundWeird Found
@doc()

@env.head(2,'More on Conditionals')
Of course conditional statements can be nested.
@p()
Also, like C, you can jump into conditionals,
although this practice isn't recommended.
This is because conditionals are just
shorthand for a web of labels and conditional gotos,
so adding extra labels and gotos is possible.

@select(env.test('.flx'))
@kat('conditional:procedural')

inline proc f(x:int) (y:int) {
  print "NOT ONE"; endl;
  if x == 1 do
    print 1; print " ";
    if y == 20 goto twenty;
    if y == 10 do print "TEN"; else done;
  elif x == 2 do
    print 2; print " ";
    if y == 20 do
twenty:>
      print "TWENTY";
    done;
  else print "Dunno .. ";
  done;
  endl;
}

f 1 10;
f 1 20;
f 1 40;
f 2 20;
f 3 30;
@doc()

@select(env.expect())
NOT ONE
1 TEN
NOT ONE
1 TWENTY
NOT ONE
1
NOT ONE
2 TWENTY
NOT ONE
Dunno ..
@doc()

Conditionals are primarily a convenient shorthand for
conditional expressions with procedural arguments.
Conditional expresssions always have an else part,
so that f1 and f2 below are equivalent:

@select(env.test('.flx'))
@kat('conditional:functional')

proc f1(x:int) {
  if x == 1 then { print 1; endl; }
  else {} endif;
}

proc f2(x:int) {
  if x == 1 do print 1; endl; done;
}

f1 1;
f2 1;
@doc()

@select(env.expect())
1
1
@doc()

You can see we avoid the messy 'else {}'.
@p()
Conditionals may contain declarations.
However the bodies are not blocks, and the declared
symbols are not local to the conditional bodies.
@p()
The macro processor can fold
conditional statements, in particular it can
choose between two declarations.

@select(env.test('.flx'))
@kat('conditional:folding')
macro val x = 1;
if x == 1 do val y = 1; else val y = "ONE"; done;
print y; endl;
@doc()

@select(env.expect())
1
@doc()

@env.head(2,'Failure')
The fail construction is used to abort a
task with prejudice. A string argument may be
given. A C++ exception is thrown. It cannot
be caught by the Felix program (although
it can be caught by the driver).

@select(env.test('.flx'))
@kat('termination:failure')
@kat('program:abort')
// uncomment to test
//fail "Aborted";
@doc()

@select(env.expect())
@doc()

@env.head(2,'Dynamic exception handling using goto')
Non local gotos are very useful for a form of
exception handling. Consider the following example:

@select(env.test('.flx'))
@kat('exceptions')

proc bad_calc(err: int -> void)
{
  // do some work, detect an error
  err 1; // throw exception
}

proc main
{
  proc err(errno:int)
  {
    print "error "; print errno;
    print " -- aborting"; endl;
    goto resume;
  }
  bad_calc err of (int);
  print "no error"; endl;
resume:>
  print "error handled, continuing"; endl;
}
main;
@doc()

@select(env.expect())
error 1 -- aborting
error handled, continuing
@doc()

Here, we establish a handler for an error,
which is effectively established at the
label resume: the handler is passed explicitly
to the routine which may 'raise' it.


@env.head(2,'Static exception handling using goto')
Non local gotos are very useful for another form of
exception handling. Consider the following example:

@select(env.test('.flx'))
@kat('exceptions')

proc main
{
  // do something

  // raise err1
  err 1; goto resume;

  // do something else

  // exception handlers
  proc err(errno:int)
  {
    print "error "; print errno;
    print " -- aborting"; endl;
    goto resume;
  }
resume:>
  print "error handled, continuing"; endl;
}

main;
@doc()

@select(env.expect())
error 1 -- aborting
error handled, continuing
@doc()

@env.head(2,'Procedure Values Again')
We've seen the advantages of higher order
functions and procedures. It is possible
to define anonymous procedure and function values
literally, as in the next example,
they're called lambdas, after the lambda calculus:

@select(env.test('.flx'))
@kat('closures:procedural')
val f = fun(a:int):int = { return a * a; };

print (f 1);
endl;

print
(
  (fun(a:int):int = { return a * a; })
  1
);
endl;

proc thrice(p:unit->void) { p(); p(); p(); }
thrice ( proc() { print 3; endl; } );
thrice ( proc   { print 3; endl; } );
thrice          { print 3; endl; };
{ print "finished"; endl; };
@doc()

@select(env.expect())
1
1
3
3
3
3
3
3
3
3
3
finished
@doc()

Mickey Mouse! Checkout the shortcut on the
second last line. You can just write
statements in curly brackets for an
anonymous procedure taking unit argument,
you can leave off the
@begin_displayed_code()
  proc() // or
  proc
@end_displayed_code()
But why does the last line work?
The answer is: this is a special shortcut.
A statement consisting of an anonymous
procedure taking unit, and a semicolon ;
is a shortcut for a call:
@begin_displayed_code()
  { print 1; }; // is a shortcut for ..
  { print 1; } ();
@end_displayed_code()
much the same as
@begin_displayed_code()
  endl; // is a shortcut for ..
  endl ();
@end_displayed_code()
Now, remember those ugly semicolons at the end
of the while statement? Are you getting a glimmer?
Hint: Felix doesn't have a while statement.
It's a library routine!

@env.head(2,'The while procedure')
Here is the while procedure from
the standard library, renamed While
to avoid a clash:

@select(env.test('.flx'))
@kat('procedures:higher order')
proc While (cond:unit->bool) (bdy:unit->void)
{
  repeatx:>
    if not (cond()) goto finished;
    bdy();
    goto repeatx;
  finished:>
}

var x = 10;
While {x>0} { print x; endl; x = x - 1; };
@doc()

@select(env.expect())
10
9
8
7
6
5
4
3
2
1
@doc()

Notice how simple and powerful the combination
of the lazy expression syntax, block syntax,
and currying are.
@p()
Felix actually only has a three
procedural control structures:
label/goto, procedure call/return,
and raise/attempt/catch; and even the latter
is only supported by the compiler for syntactic
convenience.
@p()
The standard library defines several
common procedural control structures.
@p()
Note that much of the rich control is obtained
from the functional subsystem. For example
the match expression is purely functional,
it simply returns one of several expressions,
but of course those expressions can be procedures
which are subsequently called: here the default
call syntax fools you into believing there
is a match statement when actually there isn't.

@env.head(2,'Lambda expressions')
Felix allows a function to be specified in an expression;
this is called a lambda expression:

@select(env.test('.flx'))
@kat('functions:anonymous')
@kat('functions:lambda')
var x = 10;
while
  (fun ():bool = { return x>0; })
  { print x; endl; x = x - 1; };
@doc()

@select(env.expect())
10
9
8
7
6
5
4
3
2
1
@doc()

Of course, we have already used lambdas in the short form,
by enclosing expressions in curly braces;
this example shows the long form. Lambdas of course
may have arguments:

@select(env.test('.flx'))
@kat('functions:anonymous')
@kat('functions:lambda')
fun f(g:int->int,x:int) = { return g x; }
print
(
  f
  (
    (fun(a:int):int = { return a + a; }),
    1
  )
); endl;
@doc()

@select(env.expect())
2
@doc()

@env.head(1,'Contract Programming')
@env.head(2,'Preconditions and postconditions')
Functions can be given preconditions:

@select(env.test('.flx'))
fun guarded_div(a:int, b:int when b!=0) =
{
  return a/b;
}
print (guarded_div(2,4)); print "\n";
@doc()

@select(env.expect())
0
@doc()

Functions can also be given postconditions:

@select(env.test('.flx'))
fun abs_div(a:int, b:int when b!=0) expect result >=0 =
{
  return abs(a/b);
}
print (abs_div(2,4)); print "\n";
@doc()

@select(env.expect())
0
@doc()

Note the special identifier 'result' may be used to
refer to the function result.
@p()
If a pre- or post- condition is not met, a C++ exception
is thrown. Typically this will result in a diagnostic
error being printed the thread terminated by the driver.
However, it is driver dependent.
@p()
At present (Felix 1.1.1) recovery is not possible,
nor is it possible to catch the exception.
@p()
Procedures may also have pre and post conditions.

@select(env.test('.flx'))
var x = 7;
var y = x;

proc decr(d:int when d>=0) expect x==y-d = {
  y = x;
  x -= d;
}

decr 2;
print x; endl;
@doc()

@select(env.expect())
5
@doc()

@env.head(2,'Axioms and Reductions')
Felix allows you to specify rewriting rules called reductions.
For example:
@begin_displayed_code()
  reduce idem(x:int): f ( f x ) => f x;
@end_displayed_code()
Specifies f is idempotent, and f(f(x)) should be reduced to just f(x).
Reductions are performed after inlining, and applied repeatly to all
expressions until code is fully reduced. The name of a reduction
is not significiant, it is for documentation only. Of course,
reductions can be polymorphic.
@p()
Axioms are statements of laws, for example
@begin_displayed_code()
  axiom symmetry (x:int,y:int): x + y == y + x;
@end_displayed_code()
states that integer addition is symmetric. Axioms
can be checked by providing test cases via calls
to the pseudo function 'axiom_check'.
@begin_displayed_code()
  var i:int; forall i in 1 upto 5 do axiom_check (i,2); done;
@end_displayed_code()
Axiom checks can be disable by the flxg compiler switch
@begin_displayed_code()
  --no-axiom-checks
@end_displayed_code()
otherwise every axiom is matched against every test case,
and each on the matches generates an assertion. An error
is printed and the program aborted if any check fails.

@select(env.test('.flx'))
@kat('axioms')
@kat('reductions')

noinline fun f(x:int):int = { print "Cheat"; endl; return x; }

reduce idem(x:int): f ( f x ) => f x;

var x = f(f(f(f(1))));
print x; endl;

axiom symmetry (x:int,y:int): x + y == y + x;
axiom associativity (x:int, y:int, z:int): (x + y) + z == x + (y + z);
reduce additive_unit(x:int): x + int 0 => x;
reduce multiplicative_unit(x:int): x * int 0 => 0;
reduce additive_unit(x:int): int 0 + x => x;
reduce multiplicative_unit(x:int): int 0 * x=> int 0;

//axiom wrong(x:int,y:int): x == y;
fun hh(x:int)=>x;

reduce silly (x:int): hh x => x;

axiom_check (1,2,3);

var i:int=1;
lab:>
  axiom_check (i,2);
  i=i+1;
  if i <= 5  goto lab;

axiom poly[t] ( sym:t * t -> t, eq:t * t-> bool, x:t, y:t):
  sym(x,y) == sym(y,x)
;

axiom_check (add of (int * int), eq of (int * int), 1,2);


@select(env.expect())
Cheat
1
@doc()

@env.head(1,'Program Structure')
This section mainly deals with the Felix module system.

@env.head(2,'The open directive')
It's really boring writing qualified names all
the time. Felix provides the open directive
to allow you to open a module so its contents
can be accessed without using qualified names.
Here's a simple example:

@select(env.test('.flx'))
@kat("open directive")
module X {
  proc print_endl (a:int) { print a; endl; }
  fun square (a:int):int = { return a * a; }
}

open X;
print_endl (square 2);
@doc()

@select(env.expect())
4
@doc()

Note that the open directive only affects lookup
of unqualified names, or the first component of
a qualified name. Lookup proceeds first in the
current scope, before considering opened modules;
then opened modules are considered, then the
parent scope, then opened modules in the parent,
etc.
@p()
The name of the module
to be opened is not looked up in the modules
opened by open directives in the same module
as itself. Open directives in containing modules
are, however, examined.
@p()
The reason for this last rule is as follows:
open directives, like Felix declarations,
are all considered in parallel; that is,
their order of writing is irrelevant;
hence, open directives are considered in a
context in which none of the open directives
have been applied.
@p()
It is not an error to open modules containing
conflicting definitions, however, it is an error
to refer to a name with conflicting definitions.
@p()
Functions with the same name in opened modules
are overloaded. If two functions have the same
signature, a reference will lead to an ambiguity.
Such an ambiguity can be resolved by hiding
such definitions in opened modules by providing
a definition in the module containing the
open directives. Alternatively, you can use
a qualified name.

@select(env.test('.flx'))
@kat("open directive")
module X1 {
  proc printme() { print "X1"; endl; }
}
module X2 {
  proc printme() { print "X2"; endl; }
}
open X1;
open X2;
proc printme() { print "top level"; endl; }

X1::printme();
X2::printme();
printme();
@doc()

@select(env.expect())
X1
X2
top level
@doc()

Finally note that the effect of opening a module
named X which contains an entity named X is well
defined: the contained X will not be seen
by other open directives, whereas the module X
will not be seen by any declarations and definitions
in the body of the containing scope.

@env.head(2,'The use directive')
The open directive opens a whole module
for internal use. Sometimes that is too coarse grained.
The use directive allows you to import individual names into
the current scope to reference with an unqualified name.
The entity refered to can be a non-function, or a set of
functions, and it can also be renamed in the use directive.
The renaming feature can also be used on names in the current
scope.
@p()
Note that you can't sensibly use a name from an opened
module, nor open a module using a used name (even as
a prefix).

@select(env.test('.flx'))
@kat("use directive")
header "#include <iostream>";
module X {
  type INT = "int";
  proc print: INT = "std::cout << $1;";
  proc endl: 1 = "std::cout << std::endl;";
  fun mkINT: int -> INT = "$1";
}

use X::INT;
use eol = X::endl;

val x:INT = X::mkINT 1;
use y = x;
X::print y; eol;
@doc()

@select(env.expect())
1
@doc()

You can see the two forms of the use directive:
@begin_displayed_code()
  use qualified_name;
  use new_name = old_qualified_name;
@end_displayed_code()
The first form requires a proper qualified name and is
equivalent to the second form, where the new_name is the
last component of the qualified_name.

@env.head(2,'Renaming definitions')
It is possible to inject a name or family
of function names defined elsewhere into the
public interface of a module with the rename
statement.
@p()
Injected entities can be found both by
unqualified and qualified lookup as if actually
defined in the module, however the denoted
entities are not actually part of the module,
and in particular they're bound in the context
in which they're actually defined.
@p()
There are two forms of the rename statement,
one for functions and one for non-functions.
@p()
The non-function form injects a reference to
a single non-function entity.
@p()
The function form injects a complete overload set.
Additional overloads can be added to the set,
either by local definitions, or further inherit
statements.
@p()
Note that unlike open or use directives, injected
names have the same priority as other names defined
in the module: any collision with a locally defined
function is final, and cannot be resolved.

@select(env.test('.flx'))
@kat("rename directive")
header "#include <iostream>";
module X {
  type x_t = "int";
  const x42 : x_t = "42";
}

module Y {
  rename y_t = X::x_t;
  rename y42=X::x42;
  proc print:y_t = "std::cout << $1 << std::endl;";
}

Y::print X::x42;
Y::print Y::y42;

rename fun print=Y::print;
rename y42=Y::y42;
rename x42=X::x42;

print x42;
print y42;
@doc()

@select(env.expect())
42
42
42
42
@doc()

@env.head(2,'Modular inheritance')
It is possible to inherit all
the symbols of a module with the inherit directive.
Unlike the open directive, inherited symbols
become part of the public interface of a module,
as well as it's private interface.
@p()
When lookup is performed, entities
defined in the module are always considered
before inherited ones. This is to ensure
a local definition can always be used to
resolve an ambiguity, and to ensure that
any binding to a local definition cannot
be hijacked by a non-local change in another
module.
@p()
Modular inclusion is transitive because
it is specified to include the whole of
the public interface of one module in another,
including any symbols that module inherits.
@p()
Note that as usual and unlike other programming
languages, Felix inheritance is fully recursive:
a module contains all the symbols it defines
plus the transitive closure of all inherited
modules.
@p()
In particular, it is quite possible for two modules
to inherit each other, thereby ensuring they
publish the same set of names: note however that
local overrides may mean the definition associated
with a name is different for each module.

@select(env.test('.flx'))
@kat("inherit directive")
header "#include <string>";

module X {
  fun f(a:int):int={ return 11; }
}
module Y {
  fun g(a:int):int={ return 22; }
}
module Z { inherit X; inherit Y; }

// check transitivity
module A {
  inherit Z;
  print (f 3); print " "; print (g 5); endl;
  print (Z::f 3); print " "; print (Z::g 5); endl;
  print (A::f 3); print " "; print (A::g 5); endl;
}


// check recurisve transitive closure
module P { inherit Q; fun ff(a:int):int={return 33;}}
module Q { inherit P; fun gg(a:int):int={return 44;}}
module R {
  inherit P;
  print (ff 1); print " "; print (gg 1); endl;
  print (P::ff 1); print " "; print (P::gg 1); endl;
  print (Q::ff 1); print " "; print (Q::gg 1); endl;
  print (R::ff 1); print " "; print (R::gg 1); endl;
}

module W {
  module J { val a:int = 1;}
  inherit J;
  print a; endl;
}
print W::a; endl;
@doc()

@select(env.expect())
11 22
11 22
11 22
33 44
33 44
33 44
33 44
1
1
@doc()

@env.head(2,'Let expression')
There is a short form for match expressions.
An expression of the form:
@begin_displayed_code()
  let letpat = expr1 in expr2
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  match expr1 with letpat => expr2 endmatch
@end_displayed_code()
The let expression is, in effect, a prefix operator with
the lowest precedence.

@select(env.test('.flx'))
@kat("let")
print (match 1 with | ?x =>  x + x endmatch); endl;
print (let ?z = 1 in z + z); endl;
print (let ?x = (let ?y = 2 in y + y) in x + x); endl; // 8
@doc()

@select(env.expect())
2
2
8
@env.head(2,'Metatyping')
Felix supports a metatyping or kinding system.
The reserved identifer TYPE denotes the kind of a type.
You can make a function that generates a type from
other types. Of course, you can pass these functions
to other type functions, and do currying.
@p()
The type evaluator is a specialised version of the
typed lambda calculus using eager evaluation.
Note that in this calculus, types are values,
and their type is TYPE, type functions are also
values, with type TYPE->TYPE. Our calculus
also supports type tuples of types such as
@begin_displayed_code()
TYPE * TYPE
@end_displayed_code()
and values such as
@begin_displayed_code()
(int, long)
@end_displayed_code()
Note that (unfortunately) in the abstraction form
@begin_displayed_code()
  fun (t:TYPE):TYPE =
  {
    t * t
  }
@end_displayed_code()
the curly braces are required, and you can even write:
@begin_displayed_code()
  fun (t:TYPE):TYPE =
  {
    return t * t;
  }
@end_displayed_code()
as for an ordinary function. This is because Felix uses
precisely the same syntax for type functions and ordinary ones;
that is, the parser uses the same grammar to build expressions
and type expresssions (though each imposes constraints).

@select(env.test('.flx'))
@kat("metatypes")
open Long;

typedef fun list (elt:TYPE):TYPE => 1 + elt * list elt;

typedef fun f(t1:TYPE, t2:TYPE->TYPE) (t3:TYPE): TYPE => (t2 t1) * t3;

typedef g = (
    fun (t1:TYPE, t2:TYPE->TYPE):TYPE->TYPE =>
      ( fun (t3:TYPE):TYPE => (t2 t1) * t3 )
  )
;


// FIXPOINTS WORKING NOW
val x : list int = case 0 of list int;

typedef fun pair (a:TYPE,b:TYPE):TYPE => a * b;
//typedef pair = (fun (a:TYPE,b:TYPE):TYPE => {a * b});

val x2 : (pair (int,long)) = (1,1L);
match x2 with
| (?a,?b) => { print a; endl; print b; endl; }
endmatch;

typedef fun twoup (x:TYPE):TYPE => x * x;

// (twoup int) * int = (int * int) * int
val x3 : (f (int,twoup of (TYPE)) (int)) = ((1,2),3);
match x3 with
| ((?a,?b),?c) => { print a; endl; print b; endl; print c; endl; }
endmatch;
@doc()

@select(env.expect())
1
1
1
2
3
@env.head(1,'Felix threads -- Cooperative Multitasking')
Felix supports event driven programming with
a threading interface.

[SECTION TO BE REPLACED]


@env.head(1,"System interface")
We show how to get at the command line arguments.
The function 'argv' returns an empty string
if the argument index is out of range.
argv 0 is usually the program name:
for the flx_run driver it's the loaded library
name: the driver name and control arguments
are stripped. (Note: the output is platform
dependent and so can't be automatically checked
by the Felix build system.)

@begin_displayed_code()
open System;
print "argc="; print argc; endl;

var i:int;
for_each {i=0;} {i<argc} {++i;}
{
  print i; print "->"; print (argv i); endl;
};
@end_displayed_code()

@env.head(1,"GLR parsing")
Felix contains a built-in parser generator. This is roughly
like a builtin yacc or bison facility, but it differs in
a significant way which makes it vastly more usable.
@p()
Yacc traditionally supports only a very specialised
subset of grammars -- LALR1 with some weak static ambiguity
resolution strategies.
@p()
The Felix system is based on Scott McPeak's Elkhound,
which is a Generalised LR, or GLR, parser. This system
support all grammars, whilst parsing SLR grammars
just as efficiently as Yacc (namely, in linear space
and time).
@p()
GLR handles ambiguity by spawning multiple concurrent
threads for all alternatives wherever the SLR(1)
prediction is inadequate. These threads process the
token stream synchronously, so there is never any backtracking.
Instead, alternatives which would be tried in sequence
by a backtracking algorithm are all tried at once.
@p()
Consequently, GLR can eat up exponentially large
amounts of memory, and finally return all possible
parse trees.
@p()
In practice, this doesn't happen. First, one of the threads
can reach an impasse where it can't handle the next
token, and it is automatically dropped as an alternative,
in the same way a failure in a backtracking algorithm
drops the current parse -- unlike backtracking, however,
that's the end of it: the viable alternatives are
already being parsed in parallel.
@p()
For many nonterminals, two alternative productions
are encoded precisely to handle the union of
two sets of cases. At some point during the parse then,
one of the productions must fail on for any input
not in the common subset of the cases. In that case,
GLR drops the failed parse attempt automatically.
@p()
When the input is in the common subset, however,
the algorithm cannot know what to do. By default,
both parses will be continued, causing a bifurcation
in the parse of a production trying to process that
symbol during *its* parse.
@p()
That divergence can only be eliminated automatically
if the whole containing production is subsequently
failed, in which case both subparses will be dropped.
@p()
For this reason, at the end of the parsing of a
a non-terminal, the client has an opportunity to
pick between the parses.

@env.head(2,"top level parser")

@select(env.test('.flx'))
@kat("parser generator")

// a type for tokens
union token_t =
  | TOK_EOF
  | TOK_PLUS
  | TOK_INT of int
;

// a token stream generator
gen get_token (s:string) ():token_t = {
  var i: int; forall i in 0 upto (len s) - 1 do
    yield
      match s.[i to i+1] with
      | "+" => TOK_PLUS
      | "1" => TOK_INT 1
      | "2" => TOK_INT 2
      | "3" => TOK_INT 3
      endmatch
    ;
  done;
  return TOK_EOF;
}

// a type for expression terms
union expr_t =
  | Integr of int
;

// a grammar for expressions
nonterm eexpr : expr_t =
| xx:eexpr TOK_PLUS y:TOK_INT =>
  match xx with
  | Integr ?i => Integr (i+y)
  endmatch

| y:TOK_INT => Integr y
;

// the input string
data := "1+2+3";

// a parser for our example
var z : 1 + int =
  parse get_token data with
  | e: eexpr => match e with | Integr ?i => i endmatch
  endmatch
;

// print the result
match z with
| case 0 => { print "Error"; }
| case 1 (?i) => { print i; }
endmatch;
endl;
@doc()

@select(env.expect())
6
@env.head(2,"nested parser")

@select(env.test('.flx'))
@kat("parser generator")

union token_t =
  | TOK_EOF
  | TOK_PLUS
  | TOK_INT of int
;

// a token stream generator
gen get_token (s:string) ():token_t = {
  var i: int; forall i in 0 upto (len s) - 1 do
    yield
      match s.[i to i+1] with
      | "+" => TOK_PLUS
      | "1" => TOK_INT 1
      | "2" => TOK_INT 2
      | "3" => TOK_INT 3
      endmatch
    ;
  done;
  return TOK_EOF;
}

union expr_t =
  | Integr of int
;

nonterm eexpr : expr_t =
| xx:eexpr TOK_PLUS y:TOK_INT =>
  match xx with
  | Integr ?i => Integr (i+y)
  endmatch

| y:TOK_INT => Integr y
;

proc try_parse() {
  // the input string
  data := "1+2+3";

  var z : 1 + int =
    parse get_token data with
    | e: eexpr => match e with | Integr ?i => i endmatch
    endmatch
  ;

  match z with
  | case 0 => { print "Error"; }
  | case 1 (?i) => { print i; }
  endmatch;
  endl;
}

try_parse();
@doc()

@select(env.expect())
6
@env.head(2,"Parser shortcuts")
The Felix parser system actually accepts
so-called meta-grammars.
@p()
You can have an anonymous sequence
of symbols or set of alternatives,
simply by enclosing them in parentheses.
The implementation declares a dummy nonterminal
for such groups, and replaces the group with
the name of the dummy non-terminal.
@p()
You can also apply the postfix operators "*", "+" and "?"
to any symbol or group. Curly brackets "{" .. "}" can also
be used and are equivalent to ( .. ) *. Note you can't
use [..] notation for optional constructions, since
this conflicts with the use of [] for type subscripts.
@p()
Note: although it makes sense, at present anonymous
nonterminal specifications can't contain names
or client code.
@p()
Note: restriction: at present each dummy is distinct,
so any anonymous expression occuring more than
once will lead to a reduce/reduce conflict.
@p()
Note: restriction: all the anonymous symbols must have attributes.

@select(env.test('.flx'))
@kat("parser generator")

// the input string
data := "1+22+33$";

// a type for tokens
union token_t =
  | TOK_EOF
  | TOK_PLUS
  | TOK_INT of int
;

// a token stream generator
var i = 0;
fun get_token():token_t =
{
  ch := data.[i to i+1];
  ++i;
  tok :=
    match ch with
    | "$" => TOK_EOF
    | "+" => TOK_PLUS
    | "1" => TOK_INT 1
    | "2" => TOK_INT 2
    | "3" => TOK_INT 3
    endmatch
  ;
  return tok;
}

// a type for expression terms
union expr_t =
  | Integr of int
;

// a grammar for expressions
nonterm eexpr : expr_t =
| xx:eexpr TOK_PLUS y:TOK_INT+ =>
  match xx with
  | Integr ?i => let case 1 (?j,_) = y in Integr (i+j)
  endmatch

| y:TOK_INT => Integr y
;

// a parser for our example
var z : 1 + int =
  parse (the get_token) with
  | e: eexpr => match e with | Integr ?i => i endmatch
  endmatch
;

// print the result
match z with
| case 0 => { print "Error"; }
| case 1 (?i) => { print i; }
endmatch;
endl;
@doc()

@select(env.expect())
6
@doc()

@env.head(2,"Lexing and parsing example")
@doc()

@select(env.test('.flx'))

open List;
open Lexer;

union token_t =
  | TOK_EOF
  | TOK_PLUS
  | TOK_INT of int
;

fun lexit(start:iterator) (finish:iterator):iterator*token_t =>
  reglex start to finish with
  | "+" => TOK_PLUS
  | ["0"-"9"]+ => TOK_INT $ int $ string_between(lexeme_start, lexeme_end)
  endmatch
;

gen get_token (var s:string) ():token_t = {
  print s; endl;
  val first = Lexer::start_iterator s;
  val finish = Lexer::end_iterator s;
  var current = first;
start:>
  if current == finish do
    goto stop;
  done;
    val next, tok = lexit current finish;
    current = next;
    yield tok;
  goto start;
stop:>
  return TOK_EOF;
}

union expr_t =
  | Integr of int
;

nonterm eexpr : expr_t =
| xx:eexpr TOK_PLUS y:TOK_INT =>
  match xx with
  | Integr ?i => Integr (i+y)
  endmatch

| y:TOK_INT => Integr y
;

proc try_parse() {
  var z : 1 + int =
    parse get_token "1+2+3" with
    | e: eexpr => match e with | Integr ?i => i endmatch
    endmatch
  ;

  match z with
  | case 0 => { print "Error"; }
  | case 1 (?i) => { print i; }
  endmatch;
  endl;
}

try_parse();
@doc()

@select(env.expect())
1+2+3
6
@doc()

@env.head(1,"Typeclasses")
Felix has typeclasses similar to Haskell. Documentation on the
standard library typeclasses is available here:
@cite_url("../../typeclassdoc/index.html")

@select(env.test('.flx'))
@kat("typeclasses")

typeclass XStr[T] {
  virtual fun str2: T->string;
}

instance XStr[int] {
  fun str2 (x:int):string => str x;
}

open List;

fun foo[T with XStr[T]] (x:list[T]):string =>
  match x with
  | Empty[T] => "()"
  | Cons(?h, ?t) => "(" + (str2 h) + ", " + (foo t) + ")"
  endmatch
;

val x = list(1,2);
print$ foo x; endl;
@doc()

@select(env.expect())
(1, (2, ()))
@doc()
in a module:
@select(env.test('.flx'))
@kat("typeclasses")

open List;

typeclass XStr[T] {
  virtual fun str2: T->string;
}

module Foo {
  instance XStr[int] {
    fun str2 (x:int):string => str x;
  }

  fun foo[T with XStr[T]] (x:T):string => str2 x;

  fun foo[T with XStr[T]] (x:list[T]):string =>
    match x with
    | Empty[T] => "()"
    | Cons(?h, ?t) => "(" + (str2 h) + ", " + (foo t) + ")"
    endmatch
  ;
}

open Foo;

print$ Foo::foo 5; endl;
print$ Foo::foo$ list(1,2,3,4); endl;

@select(env.expect())
5
(1, (2, (3, (4, ()))))
@doc()

@select(env.test('.flx'))
@kat("typeclasses:monad")

typedef fun Maybe (t:TYPE):TYPE=>opt[t];

instance Monad [the Maybe] {
  fun bind[a,b] (x:Maybe a, f:a -> Maybe b) =>
    match x with
    | None[a] => None[b]
    | Some ?x => f x
    endmatch
  ;

  fun ret[a](x:a):Maybe a => Some x;
}

fun madd(x:double) (y:double):opt[double]=>Some (y+x);
fun msub(x:double) (y:double):opt[double]=>Some (y-x);
fun mmul(x:double) (y:double):opt[double]=>Some (y*x);
fun mdiv(x:double) (y:double):opt[double]=>
  if x == 0.0 then None[double] else Some (y/x) endif
;
fun mneg(x:double):opt[double]=>Some (-x);

open Monad[the Maybe];

proc show(r:Maybe double) {
   match r with
  | Some ?x => { print x; }
  | None => { print "divide by zero somewhere"; }
  endmatch; endl;
}

// we have to put this here so it overrides left shift assignment operator
#infix 10 ">>=" bind

var x1 = 2.7; var y1 = 1.2; var z = 0.0;
{
  var r = ret x1 >>= msub y1 >>= mdiv z;
  show r;
};

{
  var r = ret x1 >>= msub y1 >>= mdiv 2.0;
  show r;
};
@select(env.expect())
divide by zero somewhere
0.75
@doc()

@env.write_katfile()

@env.head(1,"Index")
Tests by category keyword.
@env.emit_katlist()

@env.head(1,"Package Metadata")
This contains the Felix build system description of
the tutorial package.
@select(tangler('spkgs/flx_tutorial.py'))
import glob

@tangle('TESTS = glob.glob('+repr(unix2native(env.root)+"*.flx")+')')

unit_tests = TESTS
pkg_requires = ['flx_compiler','flx_drivers','flx_rtl','faio']
iscr_source = [ 'lpsrc/flx_tutorial.pak' ]

weaver_directory = 'doc/tutorial/introduction/'
tmpdir = ['tut']

@doc()


