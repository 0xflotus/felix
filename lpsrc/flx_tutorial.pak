@set_title('Felix Tutorial')
@tdir = 'tut/examples/'
@head(1,'Preface: Authors note')
This document is literate programmed using interscript.
Although it is primarily designed
as a tutorial, almost all the code examples are complete
executable programs. This is partly so readers can run
the examples as written, but there is another purpose:
tutorial examples are expected to provide coverage
of basic language features with a graded increase
in complexity, which makes the examples excellent
regression tests. And unlike other tests, the purpose
of the examples is usually well documented.
@p()
There is another role of the tutorial during development:
it provides an excellent way to check the usability
of the language and tools: issues of ease of comprehension
and use arise more easily than when working on 
the compiler itself. Development of tutorial material
in parallel with the language specification, implementation,
hard core unit tests, and reference manual, can be seen
as a form of 'Extreme Programming', but it is better
understood as the central paradigm of 'Literate Programming'.
@p()
There is no requirement to use literate programming tools like
interscript when developing Felix code. Or any
other code. But I strongly
recommend it be considered for larger projects, 
expecially libraries. The strong integration 
provided by LP is likely to challange corporate 
procedures. And they surely need it.

@head(1,'Hello Felix')
There is no better introduction to a programming
language than the infamous hello-world program.

@select(tangler(tdir+'tut01.flx'))
#include <std.flx>
print "Hello World\n";
@doc()
and the Felix version is simplicity itself.
The first line includes the standard library,
and the second prints the hello world message.
You'll notice that the argument to print is not
enclosed in backets.  We'll learn more about
this shortly.
@p()
To run the example, make sure you are in the
directory containing the Felix demo package,
then type:
@begin_displayed_code()
  bin/flx tut/examples/tut01
@end_displayed_code()
This produces three files:
@begin_displayed_code()
  tut/examples/tut01.hpp
  tut/examples/tut01.cpp
  tut/examples/tut01.so
@end_displayed_code()
We'll learn more about their structure later.

@head(1,'Overloading')
Felix supports overloading. To demonstrate this,
we'll make a small modification to the hello
world program. You can compile and run the
program as before, just change the example number.
@select(tangler(tdir+'tut02.flx'))
#include <std.flx>
print "Hello World ";
print 42;
print "\n";
@doc()
Here you can see that there are two procedures,
one to print strings, and one to print ints,
but they're both called 'print'.
@p()
Felix allows procedures and functions to be 
overloaded, as does C++. However, unlike C++,
Felix has no automatic conversions, and
overload matching must be exact.

@head(1,'Value declaration')
Felix allows values to be declared using the 'val'
keyword.
@select(tangler(tdir+'tut03.flx'))
#include <std.flx>
val i = 40;
val j = 2;
val k = i + j;
print k; print "\n";
@doc()
There are three values declared here, 'i','j', and 'k'.
The first two have the type 'int', because '40' and '2'
have the type int, whilst 'k' has the type 'int'
because the addition function which takes as
an argument a pair of 'int', returns an 'int'.
@p()
Notice you did not have to declare the type of
the values. This is called 'type inference':
the compiler works out the type from the initial
value for you. You can declare the type of a variable
if you want: the following program is equivalent
to the one above:
@select(tangler(tdir+'tut04.flx'))
#include <std.flx>
val i : int = 40;
val j : int = 2;
val k : int = i + j;
print k; print "\n";
@doc()
but it is never necessary for values: an initialiser
must always be given. If you do declare the type,
Felix will still deduce the type from the initialiser,
and issue an error message if the types don't agree.
@p()
Values are constants: they cannot be modified,
and, as we will see later, they cannot be addressed.

@head(1,'Variable declaration')
Felix also support mutable variables, which are
declared with the 'var' keyword.
@select(tangler(tdir+'tut05.flx'))
#include <std.flx>
var i = 1;
var j : int;
while (i < 10) 
{
  j = i + i;
  print j; print "\n";
  ++i;
}
@doc()
Like value declarations, the type of a variable
does not need to be declared if it is initialised.
However, as you can see uninitialised variables
are also permitted, and in this case the type
must be given.
@p()
You will notice the assignment in the line:
@begin_displayed_code()
  j = i + i;
@end_displayed_code()
Naturally, variables must be initialised
or assigned to before they are used, as in C.
@p()
You will also have noticed the 'while' loop,
one of the control structures Felix provides:
it works the same way as a 'while' loop in C.

@head(1,'Functions')
Felix allows you to define functions,
although the syntax is different from C.
Here is an example:
@select(tangler(tdir+'tut06.flx'))
#include <std.flx>
fun mid(a:int, b:int):int
{
  val c = (a + b) / 2;
  return c;
}
print (mid(2,4)); print "\n";
@doc()
It is clear that mid returns an int,
and you might think that 'mid' has two arguments.
This is not so. All functions in Felix have
exactly one argument. Well, almost all of them :-)
I'll explain this in the next example.

@head(1,'Tuples')
As you might guess from the title, Felix has
tuples. A tuple is a value consisting of an ordered sequence of 
two or more values, not necessarily of the same type.
Here are some examples of tuples:
@begin_displayed_code()
  1,2
  "Hello", "World"
  (1, 2.7, "Hello")
  ()
@end_displayed_code()
The comma operator constructs tuples.
While brackets are not always necessary, the comma
operator has a low precedence so tuples usually
appear in brackets. Notice there is a special
unique empty tuple '()'. There are no tuples
with one component: for all values 'a', '(a)' is 
equivalent.
@p()
Now perhaps you have guessed what I mean earlier
when I said the function mid only had a single
argument. If not, you get another chance,
studying this example, which is equivalent
to example 6.
@select(tangler(tdir+'tut07.flx'))
#include <std.flx>
fun mid(a:int, b:int):int
{
  val c = (a + b) / 2;
  return c;
}
val x = (2,4);
print (mid x); print "\n";
@doc()
Here you can see that mid takes a single
argument which is a tuple of two ints.
@p()
A tuple is a product type: you may be
familiar with the Cartesian product of sets.
The notation for tuple types is the same,
except of course we use '*' instead of
a multiply sign: here is the declaration
of x with a type annotation:
@begin_displayed_code()
  val x : int * int = (2,4);
@end_displayed_code()
You should note that tuple construction
is not associative. Here are three
tuple value declarations with type annotations:
@begin_displayed_code()
  val x : int * int * int = (1,2,3);
  val y : (int * int) * int = ((1,2),3);
  val z : int * (int * int) = (1,(2,3));
@end_displayed_code()
These three tuples have distinct types and
values. The first has three components,
each of type int. The other two have two
components each: an int and a pair of ints,
in the two possible orderings.
@p()
The type of the empty tuple '()' is called
'unit'.
@p()
I said before that 'almost' all functions in
Felix have one argument. The tuple constructor
is the exception.
@p()
You can get at tuple components using a suffixed
dot followed a zero origin integer in brackets:
@select(tangler(tdir+'tut08.flx'))
#include <std.flx>
val x = (0,1,(3,4));
print x.(0); print " ";
print x.(1); print " ";
print x.(2).(0); print " ";
print x.(2).(1); print "\n";
@doc()
The brackets are needed so the lexer
doesn't get confused with floating point.

@head(1,'Procedures')
Felix allows you define procedures.
They're like functions, but they can't return values.
On the other hand, procedures may have side effects,
and they may read input from the driver's message
dispatch queue.
@p()
Here is an example of a procedure definition
and use:
@select(tangler(tdir+'tut09.flx'))
#include <std.flx>
proc print_newline (a:int)
{
  print a;
  print "\n";
}
print_newline 1;
@doc()
There is a special short cut for calling procedures
with unit argument: if the procedure is called
by its name, the () can be elided:
@select(tangler(tdir+'tut10.flx'))
#include <std.flx>
print 1; endl();
print 1; endl;

@head(1,'Structs')
Felix supports C like structs. A struct, like a tuple,
is a categorical product type. Unlike a tuple,
a struct is named, its members are named, and 
its members are mutable. 
@p()
Struct members can be used with C style dot notation.
Here is an example:
@select(tangler(tdir+'tut11.flx'))
#include <std.flx>

struct XY = {
  x : int;
  y : int;
}

var xy : XY;
xy.x = 1;
xy.y = 2;
print xy.x; endl;
print xy.y;  endl;
@doc()
The name of a struct is also the name of a function
which constructs an object of the struct type
from a tuple consisting of values to initialise
the members in sequence. For example:
@select(tangler(tdir+'tut12.flx'))
#include <std.flx>

struct XY = {
  x : int;
  y : int;
}

val xy = XY(1,2);
print xy.x; endl;
print xy.y;  endl;

@head(1,'Unions')
Felix supports unions, but they are a bit
different to C unions. A union is a way
of merging a finite set of types into
a single type. An object of a union type
consists of a tag, identifying what type
the component has, and the actual component.
Here are some examples of unions.
@select(tangler(tdir+'tut13.flx'))
#include <std.flx>

union parity =
  | Odd
  | Even
;

union int_option =
  | Some of int
  | None
;

val x = Odd;
val y = Some 1;

@doc()
We'll see how to actually use unions in the
next section. But note first that the parity
example is very similar to a C enumeration.
The names of the union components are
called constructors by convention.
They have two roles: they represent the
constant value of the tag indicating 
which component we're talking about:
tags values are assigned sequentially,
starting at 0.
@p()
In their second role, the constructors
are considered functions, so that
Some is a function with type:
@begin_displayed_code()
  int -> int_option
@end_displayed_code()
It is important to note that the constructor
names are visible in the enclosing space,
unlike struct component names.

@head(1,'Pattern Matching Unions')
The only way to get at the current component
of a union is by pattern matching. Here is an example: 
@select(tangler(tdir+'tut14.flx'))
#include <std.flx>
union int_option =
  | Some of int
  | None
;

val y = Some 1;
val i = 0;

match (y) 
{
  | Some i:
    {
      print "Some "; 
      print i; 
    }
  | None: 
    {
      print "None"; 
      print i;
    }
}
endl;

@doc()
Notice that the value 'i' in the line
@begin_displayed_code()
  | Some i:
@end_displayed_code()
can be used in the handler for that case.
This is how we get the 'int' out of the Some option.
The 'i' is scoped so it can only be seen inside
the handler for the Some case. Also note that
there is no need to 'break' at the end of a 
case handler: control jumps to the end of the
match statement when the handler is finished,
it never falls through.

@head(1,'Pattern Matching Tuples')
It is also possible to match tuples.
Here is an example:
@select(tangler(tdir+'tut15.flx'))
#include <std.flx>
val x = 1,2,(3,4);
match (x) 
{
  case (x,_,z): 
  {
    print x; 
    print ", ";
    match (z)
    {
      case (a,b): 
      {
        print "(";
        print a; 
        print ", ";
        print b; 
        print ")";
      }
    }
  }
}
endl;

@head(1,'Basic Bindings')
In the previous examples, we've use the Felix standard
library. It's time to look at how it works.
@p()
The Felix language is somewhat novel in that there
are no primitive data types, not even bool.
Instead, Felix uses binding definitions to declare
abstract primitive data types, and bind them to
concrete C++ data type.
@p()
Here is an example of a binding. 
@select(tangler(tdir+'tut16.flx'))
#include <std.flx>
header """
class gauss;

struct gauss {
  int x;
  int y;

  gauss() : x(0), y(0) {}
  gauss(int _x, int _y) : x(_x), y(_y) {}

  gauss operator +(gauss z) const 
  {
    return gauss(x+z.x, y+z.y);
  }
  gauss operator *(gauss z) const
  {
    return gauss (x *z.x - y*z.y, x*z.y + y*z.x);
  }
};
""";

type gauss = "gauss";
proc set : &gauss * gauss = "*$1 = $2;";
fun add: gauss * gauss -> gauss = "$1 + $2";
fun mul: gauss * gauss -> gauss = "$1 * $2";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";
fun real: gauss -> int = "$1.x";
fun imag: gauss -> int = "$1.y";

proc print(z:gauss) { 
  print "(";
  print (real z);
  print ", ";
  print (imag z);
  print ")";
}

fun sqr(z:gauss):gauss {
  return z * z;
}

fun norm(z:gauss): int {
  return 
    real z * real z + imag z * imag z
  ;
}

val z1 = mkgauss(1,2);
val z2 = z1 + z1;
val z3 = sqr z2;
val n = norm z3;
print z1; endl;
print z2; endl;
print z3; endl;
print n; endl;

@doc()
There are lots of things to note here.
First, the header command specifies text to
be emitted literally in the generated C++.
In this case, we emit a C++ class defining
a basic gaussian integer type.
@p()
Next, we define the felix type gauss.
The definition specifies the Felix name, gauss,
and then the C++ name, which also happens to be
gauss.
@p()
Then we define the semantics of our new primitive
by primitive functions and procedures which allow
us to manipulate it. Theses consists of a function
or procedure name, a type, and the C++ code to
generate when the function or procedure is called.
@p()
In the definition string, $1 means the first argument
of the argument tuple, and $2 means the second, etc.
@p()
If the type of an argument component is prefixed
by a &, this means that a pointer is passed.
@p()
You should note that there is a predefined
correspondence between Felix operators and certain
function or procedure names. The ones we have
used here are:
@begin_displayed_code()
  Operator  Name
  =         set
  +         add
  *         mul
  ==        eq
@end_displayed_code()
@p()
Finally, note carefully that functions bind to C++
expressions, whilst procedures bind to C++ statements.
This is why the set procedure binding contains
a ; inside the string, as well as after it.
You can use a compound statement as well.

@head(1,'Seamless Binding')
Felix purports to support a property called seamless binding.
What this means is that the boundary between C++ and Felix
code is fluid. To illustrate this, lets consider
a version of the above code written entirely in Felix.

@select(tangler(tdir+'tut17.flx'))
#include <std.flx>
struct gauss = {
  x : int;
  y : int;
}

proc set ( lhs: &gauss, rhs: gauss )
{
  (*lhs).x = rhs.x;
  (*lhs).y = rhs.y;
}

fun add (a:gauss, b:gauss): gauss {
  return gauss(a.x+b.x, a.y+b.y);
}

fun mul (a:gauss, b:gauss): gauss {
  return gauss(a.x+b.x - a.y+b.y, a.x*b.y + a.y*b.x);
}

fun mkgauss (a:int,b:int):gauss { return gauss(a,b); }
fun real (z:gauss):int { return z.x; } 
fun imag (z:gauss):int { return z.y; }

proc print(z:gauss) { 
  print "(";
  print (real z);
  print ", ";
  print (imag z);
  print ")";
}

fun sqr(z:gauss):gauss {
  return z * z;
}

fun norm(z:gauss): int {
  return 
    real z * real z + imag z * imag z
  ;
}

val z1 = mkgauss(1,2);
val z2 = z1 + z1;
val z3 = sqr z2;
val n = norm z3;
print z1; endl;
print z2; endl;
print z3; endl;
print n; endl;

@doc()
The difference between these two programs is that
in the second one, gauss is a concrete 
non-primitive Felix data type.
In the first program, gauss is an abstract 
data type, together with a binding specifying
the semantics in C++.
@p()
As you can guess, the whole of the program
could have been written in C++ rather than 
Felix.

@head(1,'Operator dot')
It may look as if Felix knows how to access
the components of a Felix struct value using
operator dot. Strangely enough, this is not the
case! When you write:
@begin_displayed_code()
  expr.name
@end_displayed_code()
in a value context, it is translated to the
function application:
@begin_displayed_code()
  get_name expr
@end_displayed_code()
To illustrate this is really the case,
consider the following example.

@select(tangler(tdir+'tut18.flx'))
#include <std.flx>

// part 1
header """
struct gauss 
{ 
  int x; 
  int y; 
  gauss() : x(0), y(0) {}
  gauss(int _x, int _y) : x(_x), y(_y) {}

};
""";

type gauss = "gauss";
fun get_x: gauss -> int = "$1.x";
fun get_y: gauss -> int = "$1.y";
fun mkgauss: int * int -> gauss = "gauss($1,$2)";

val z = mkgauss(1,2);
print z.x;
print ", ";
print z.y;
endl;

// part 2
struct X = {
  x : int;
}
val i = X(1);
print (get_x i);
endl;

@doc()
In part 1, the functions get_x and get_y
are defined by binding, but the dot notation
is used to call them.
@p()
In part 2, the functions get_x and get_y are
defined by defining a struct, and they're
called directly, without the dot notation.
@p()
The dot notation is just syntactic sugar for
calling a get function.
@p()
What is more, the struct definition is just
syntactic sugar for defining an abstract type
with some get functions (as well as a 
constructor).
@p()
What this means is that for an arbitrary C++ type,
you can create an abstract binding, and define
get methods which can be called using dot notation.
Just name the methods 'get_' something.
@p()
It is also possible to access a Felix struct from
C++, although we'll defer disucssion of the C++
representation of Felix data structures until later.
[The C++ name of the struct type is not the same
as the Felix name]

@head(1,'Inductive types')
Felix supports inductive types such as lists.
Here is a list of ints.

@select(tangler(tdir+'tut19.flx'))
#include <std.flx>

union float_list =
  | Empty
  | Cons of float * float_list
;

val t0 = Empty;
val nxt = (100.1,t0);
val t1 = Cons nxt;
val t2 = Cons (200.2,t1);

proc print (a: float_list) 
{
  match (a) 
  {
    | Empty: print "[]";
    | Cons (i,tail): 
      {
        print i; 
        print " "; 
        print tail;
      }
  }
}

print t2; endl;

@doc()
A more interesting example is now given.
Here, we use a recursive routine to build the list,
and an iterative routine to reverse it.

@select(tangler(tdir+'tut20.flx'))
#include <std.flx>

union int_list =
  | Empty
  | Cons of int * int_list
;

proc print (a: int_list) 
{
  match (a) 
  {
    | Empty: print "[]";
    | Cons (i,tail): 
      {
        print i; 
        print " "; 
        print tail;
      }
  }
}

fun mk(i: int, tl:int_list):int_list
{
  if(i>0)
    return mk(i-1,Cons(i,tl));
  else return tl;
}

val a = mk(10,Empty);
print "List= "; print a; endl;

fun rev(lst:int_list):int_list
{
  var result = Empty;
  proc aux(lst:int_list)
  {
    match(lst)
    {
      | Empty: {} 
      | Cons (head,tail): 
        {
          result = Cons(head,result); 
          aux(tail);
        } 
    }
  }
  aux(lst);
  return result;
}

print "Reversed= "; print (rev a); endl;

@head(1,'Higher order Functions')
In Felix, functions and procedures are first class:
they may accept functions or procedures as arguments,
functions may return them, and you can have variables
of function or procedure type.
@p()
In particular, a function or procedure may be
defined inside another function or procedure,
and it may still use any values or variables
defined in that function or procedure, even when
it is returned by it.
@p()
Note that when the returned function or procedure
is called later, the values of variables may have
changed since the time the it was passed.
@p()
Here is an example, beware this example
contains quite a lot of subtle features!

@select(tangler(tdir+'tut21.flx'))
#include <std.flx>

var j = 2;

fun get_printer(i:int): unit->void  {
  proc print() { print (i+j); }
  return print of (unit);
}

val print_i = get_printer(40);
print_i(); endl;
j = 3;
print_i(); endl;

@doc()
There are a couple of things to notice.
The function return type is given as

@begin_displayed_code()
  unit->void
@end_displayed_code()

This is the notation for a procedure type accepting
a unit argument. 
@p()
Notice also that the return value is

@begin_displayed_code()
  print of (unit)
@end_displayed_code()

This is the name of the function called 'print' 
which accepts a unit argument. Felix can perform
overload resolution when a function name is applied
to an argument, by inspecting the type of the argument.
@p()
In other circumstances, you have to specify the type
of the argument.
@p()
There is a subtle point of the overloading system
here. The procedure 'print of (unit)' actually
calls the procedure 'print of (int)'. Now if you are
used to C++, you may wonder how this would work:
the search for 'print of (int)' stats by finding
'print of (unit)', and in C++ it would stop right there
and report an error. In Felix, if overload resolution
for an unqualified function or procedure name fails,
the enclosing scope is examined. This 'overloading
across scopes' is allows you to extend an overload
set locally. The special rule does not apply
to qualified names (where the name must be found
in the designated scope). [I may change this!]
@p()
Another thing to notice is that
the call to print_i cannot be abbreviated by leaving
the () off. This is because print_i is a function
value, not the name of a function. 
@p()
More precisely, the function specification for p of (unit)
is used to build a function closure: this consists of the
code body of the function, together with the environment
at the point of definition and the time the closure
is created: it binds to the current 'activation record'
or 'stack frame' of the enclosing function 'get_printer'.
And because that environment contains the value 'i'
initialised to 30, and the variable 'j', it will
print 40 + j as an answer when called. This is 42
the first time, since at that time j is 2, and 43 the
second time, since j is then 3.

@head(1,'Currying')
Consider the following example:
@select(tangler(tdir+'tut22.flx'))
#include <std.flx>

fun f4(i4:int): int->int->int->int  {
  fun f3(i3:int): int->int->int {
    fun f2(i2:int): int->int {
      fun f1(i1:int): int {
        return i1+i2+i3+i4;
      }
      return f1 of (int);
    }
    return f2 of (int);
  }
  return f3 of (int);
}

print (f4 1 2 3 4); endl;
print ((f4 1 2 3) 4); endl;
print ((f4 1 2) 3 4); endl;
print ((f4 1) 2 3 4); endl;
print (((f4 1) 2 3) 4); endl;
print (((f4 1 2) 3) 4); endl;

val curry = f4 1 2;
print (curry 3 4); endl;

@doc()
You should note that -> is right associative,
so that

@begin_displayed_code()
  int->int->int->int
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  int->(int->(int->int))
@end_displayed_code()
On the other hand, application is left associative,
so that
@begin_displayed_code()
  f4 1 2 3 4
@end_displayed_code()
is equivalent to
@begin_displayed_code()
  (((f4 1) 2) 3) 4
@end_displayed_code()

Note that the 'partial' applications such as
shown by the brackets, are of course closures
of the inner functions, and you can use them
to initialise values, assign them to variables
or pass them to functions. Such 'partial'
application is called currying (after the mathematician
Howard Curry, who invented the lambda calculus).
@p()
While this is a perfectly good defintion,
but there is a lot of housekeeping going on.
Felix provides syntactic sugar that makes it easier
to declare functions suitable for currying.
Here is the equivalent code, using this sugar:

@select(tangler(tdir+'tut23.flx'))
#include <std.flx>

fun f4(i4:int) (i3:int) (i2:int) (i1:int): int {
  return i1+i2+i3+i4;
}

print (f4 1 2 3 4); endl;
print ((f4 1 2 3) 4); endl;
print ((f4 1 2) 3 4); endl;
print ((f4 1) 2 3 4); endl;
print (((f4 1) 2 3) 4); endl;
print (((f4 1 2) 3) 4); endl;

val curry = f4 1 2;
print (curry 3 4); endl;

@doc()
You may remember eariler I said that
all Felix accepted exactly one argument,
with one exception: tuple constructors.
@p()
It is conventional to say that a function like
'f4' above has 4 arguments. Of course,
you know that this isn't the case: it really
has one argument and returns a function.
It is also sometimes said that f4 has arity 4,
meaning you can chain applications 4 times,
until you get a non-function result.
@p()
Note that the notation above can be used for
procedures as well: of course, all the partial
applications except the last return functions,
and the last one returns a procedure.
@p()
It is a matter of style whether you write
functions in the curried form or not.
Any function accepting a tuple can be changed
to a currified function accepting the components
in sequence. This is conventional in some
functional programming languages (like Ocaml),
but is less heavily used in others (like SML).
@p()
In the current implementation of Felix, currified
functions are more expensive than ones accepting
tuples, but the currified version is easier to
curry :-)
@p()
As an exercise, write a function that given an
arbitrary function f accepting a tuple of 3 ints,
returns an equivalent currified version of it
that accepts 3 arguments.
@p()
What you have done is called eta-expansion.
It is necessary even for currified functions
if you want to fix the first argument, but
leave the second free. There's a more elegant
way to do this using labelled arguments, 
as we shall see. [Maybe?]

